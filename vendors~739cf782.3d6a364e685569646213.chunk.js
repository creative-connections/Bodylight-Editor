(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~739cf782"],{

/***/ "HeW1":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign\n\n\n  url = url && url.__esModule ? url.default : url;\n\n  if (typeof url !== 'string') {\n    return url;\n  } // If url is already wrapped in quotes, remove them\n\n\n  if (/^['\"].*['\"]$/.test(url)) {\n    // eslint-disable-next-line no-param-reassign\n    url = url.slice(1, -1);\n  }\n\n  if (options.hash) {\n    // eslint-disable-next-line no-param-reassign\n    url += options.hash;\n  } // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n\n\n  if (/[\"'() \\t\\n]/.test(url) || options.needQuotes) {\n    return \"\\\"\".concat(url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n'), \"\\\"\");\n  }\n\n  return url;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGVXMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9nZXRVcmwuanM/MWRlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIG9wdGlvbnMgPSB7fTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGUsIG5vLXBhcmFtLXJlYXNzaWduXG5cblxuICB1cmwgPSB1cmwgJiYgdXJsLl9fZXNNb2R1bGUgPyB1cmwuZGVmYXVsdCA6IHVybDtcblxuICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9IC8vIElmIHVybCBpcyBhbHJlYWR5IHdyYXBwZWQgaW4gcXVvdGVzLCByZW1vdmUgdGhlbVxuXG5cbiAgaWYgKC9eWydcIl0uKlsnXCJdJC8udGVzdCh1cmwpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgdXJsID0gdXJsLnNsaWNlKDEsIC0xKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmhhc2gpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB1cmwgKz0gb3B0aW9ucy5oYXNoO1xuICB9IC8vIFNob3VsZCB1cmwgYmUgd3JhcHBlZD9cbiAgLy8gU2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcblxuXG4gIGlmICgvW1wiJygpIFxcdFxcbl0vLnRlc3QodXJsKSB8fCBvcHRpb25zLm5lZWRRdW90ZXMpIHtcbiAgICByZXR1cm4gXCJcXFwiXCIuY29uY2F0KHVybC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpLCBcIlxcXCJcIik7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///HeW1\n");

/***/ }),

/***/ "JPst":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join('');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === 'string') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || '').concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n  return \"/*# \".concat(data, \" */\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSlBzdC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanM/MjRmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXNlU291cmNlTWFwKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChjb250ZW50LCBcIn1cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oJycpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnksIGRlZHVwZSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgJyddXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19pXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMl0gPSBcIlwiLmNvbmNhdChtZWRpYVF1ZXJ5LCBcIiBhbmQgXCIpLmNvbmNhdChpdGVtWzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcblxuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCAnJykuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufSAvLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5cblxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG4gIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///JPst\n");

/***/ }),

/***/ "qb46":
/*!**********************************************************************************!*\
  !*** ./node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * chartjs-plugin-datalabels v0.7.0\n * https://chartjs-plugin-datalabels.netlify.com\n * (c) 2019 Chart.js Contributors\n * Released under the MIT license\n */\n(function (global, factory) {\n true ? module.exports = factory(__webpack_require__(/*! chart.js */ \"MO+k\")) :\nundefined;\n}(this, function (Chart) { 'use strict';\n\nChart = Chart && Chart.hasOwnProperty('default') ? Chart['default'] : Chart;\n\nvar helpers = Chart.helpers;\n\nvar devicePixelRatio = (function() {\n\tif (typeof window !== 'undefined') {\n\t\tif (window.devicePixelRatio) {\n\t\t\treturn window.devicePixelRatio;\n\t\t}\n\n\t\t// devicePixelRatio is undefined on IE10\n\t\t// https://stackoverflow.com/a/20204180/8837887\n\t\t// https://github.com/chartjs/chartjs-plugin-datalabels/issues/85\n\t\tvar screen = window.screen;\n\t\tif (screen) {\n\t\t\treturn (screen.deviceXDPI || 1) / (screen.logicalXDPI || 1);\n\t\t}\n\t}\n\n\treturn 1;\n}());\n\nvar utils = {\n\t// @todo move this in Chart.helpers.toTextLines\n\ttoTextLines: function(inputs) {\n\t\tvar lines = [];\n\t\tvar input;\n\n\t\tinputs = [].concat(inputs);\n\t\twhile (inputs.length) {\n\t\t\tinput = inputs.pop();\n\t\t\tif (typeof input === 'string') {\n\t\t\t\tlines.unshift.apply(lines, input.split('\\n'));\n\t\t\t} else if (Array.isArray(input)) {\n\t\t\t\tinputs.push.apply(inputs, input);\n\t\t\t} else if (!helpers.isNullOrUndef(inputs)) {\n\t\t\t\tlines.unshift('' + input);\n\t\t\t}\n\t\t}\n\n\t\treturn lines;\n\t},\n\n\t// @todo move this method in Chart.helpers.canvas.toFont (deprecates helpers.fontString)\n\t// @see https://developer.mozilla.org/en-US/docs/Web/CSS/font\n\ttoFontString: function(font) {\n\t\tif (!font || helpers.isNullOrUndef(font.size) || helpers.isNullOrUndef(font.family)) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn (font.style ? font.style + ' ' : '')\n\t\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t\t+ font.size + 'px '\n\t\t\t+ font.family;\n\t},\n\n\t// @todo move this in Chart.helpers.canvas.textSize\n\t// @todo cache calls of measureText if font doesn't change?!\n\ttextSize: function(ctx, lines, font) {\n\t\tvar items = [].concat(lines);\n\t\tvar ilen = items.length;\n\t\tvar prev = ctx.font;\n\t\tvar width = 0;\n\t\tvar i;\n\n\t\tctx.font = font.string;\n\n\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\twidth = Math.max(ctx.measureText(items[i]).width, width);\n\t\t}\n\n\t\tctx.font = prev;\n\n\t\treturn {\n\t\t\theight: ilen * font.lineHeight,\n\t\t\twidth: width\n\t\t};\n\t},\n\n\t// @todo move this method in Chart.helpers.options.toFont\n\tparseFont: function(value) {\n\t\tvar global = Chart.defaults.global;\n\t\tvar size = helpers.valueOrDefault(value.size, global.defaultFontSize);\n\t\tvar font = {\n\t\t\tfamily: helpers.valueOrDefault(value.family, global.defaultFontFamily),\n\t\t\tlineHeight: helpers.options.toLineHeight(value.lineHeight, size),\n\t\t\tsize: size,\n\t\t\tstyle: helpers.valueOrDefault(value.style, global.defaultFontStyle),\n\t\t\tweight: helpers.valueOrDefault(value.weight, null),\n\t\t\tstring: ''\n\t\t};\n\n\t\tfont.string = utils.toFontString(font);\n\t\treturn font;\n\t},\n\n\t/**\n\t * Returns value bounded by min and max. This is equivalent to max(min, min(value, max)).\n\t * @todo move this method in Chart.helpers.bound\n\t * https://doc.qt.io/qt-5/qtglobal.html#qBound\n\t */\n\tbound: function(min, value, max) {\n\t\treturn Math.max(min, Math.min(value, max));\n\t},\n\n\t/**\n\t * Returns an array of pair [value, state] where state is:\n\t * * -1: value is only in a0 (removed)\n\t * *  1: value is only in a1 (added)\n\t */\n\tarrayDiff: function(a0, a1) {\n\t\tvar prev = a0.slice();\n\t\tvar updates = [];\n\t\tvar i, j, ilen, v;\n\n\t\tfor (i = 0, ilen = a1.length; i < ilen; ++i) {\n\t\t\tv = a1[i];\n\t\t\tj = prev.indexOf(v);\n\n\t\t\tif (j === -1) {\n\t\t\t\tupdates.push([v, 1]);\n\t\t\t} else {\n\t\t\t\tprev.splice(j, 1);\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, ilen = prev.length; i < ilen; ++i) {\n\t\t\tupdates.push([prev[i], -1]);\n\t\t}\n\n\t\treturn updates;\n\t},\n\n\t/**\n\t * https://github.com/chartjs/chartjs-plugin-datalabels/issues/70\n\t */\n\trasterize: function(v) {\n\t\treturn Math.round(v * devicePixelRatio) / devicePixelRatio;\n\t}\n};\n\nfunction orient(point, origin) {\n\tvar x0 = origin.x;\n\tvar y0 = origin.y;\n\n\tif (x0 === null) {\n\t\treturn {x: 0, y: -1};\n\t}\n\tif (y0 === null) {\n\t\treturn {x: 1, y: 0};\n\t}\n\n\tvar dx = point.x - x0;\n\tvar dy = point.y - y0;\n\tvar ln = Math.sqrt(dx * dx + dy * dy);\n\n\treturn {\n\t\tx: ln ? dx / ln : 0,\n\t\ty: ln ? dy / ln : -1\n\t};\n}\n\nfunction aligned(x, y, vx, vy, align) {\n\tswitch (align) {\n\tcase 'center':\n\t\tvx = vy = 0;\n\t\tbreak;\n\tcase 'bottom':\n\t\tvx = 0;\n\t\tvy = 1;\n\t\tbreak;\n\tcase 'right':\n\t\tvx = 1;\n\t\tvy = 0;\n\t\tbreak;\n\tcase 'left':\n\t\tvx = -1;\n\t\tvy = 0;\n\t\tbreak;\n\tcase 'top':\n\t\tvx = 0;\n\t\tvy = -1;\n\t\tbreak;\n\tcase 'start':\n\t\tvx = -vx;\n\t\tvy = -vy;\n\t\tbreak;\n\tcase 'end':\n\t\t// keep natural orientation\n\t\tbreak;\n\tdefault:\n\t\t// clockwise rotation (in degree)\n\t\talign *= (Math.PI / 180);\n\t\tvx = Math.cos(align);\n\t\tvy = Math.sin(align);\n\t\tbreak;\n\t}\n\n\treturn {\n\t\tx: x,\n\t\ty: y,\n\t\tvx: vx,\n\t\tvy: vy\n\t};\n}\n\n// Line clipping (Cohen–Sutherland algorithm)\n// https://en.wikipedia.org/wiki/Cohen–Sutherland_algorithm\n\nvar R_INSIDE = 0;\nvar R_LEFT = 1;\nvar R_RIGHT = 2;\nvar R_BOTTOM = 4;\nvar R_TOP = 8;\n\nfunction region(x, y, rect) {\n\tvar res = R_INSIDE;\n\n\tif (x < rect.left) {\n\t\tres |= R_LEFT;\n\t} else if (x > rect.right) {\n\t\tres |= R_RIGHT;\n\t}\n\tif (y < rect.top) {\n\t\tres |= R_TOP;\n\t} else if (y > rect.bottom) {\n\t\tres |= R_BOTTOM;\n\t}\n\n\treturn res;\n}\n\nfunction clipped(segment, area) {\n\tvar x0 = segment.x0;\n\tvar y0 = segment.y0;\n\tvar x1 = segment.x1;\n\tvar y1 = segment.y1;\n\tvar r0 = region(x0, y0, area);\n\tvar r1 = region(x1, y1, area);\n\tvar r, x, y;\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tif (!(r0 | r1) || (r0 & r1)) {\n\t\t\t// both points inside or on the same side: no clipping\n\t\t\tbreak;\n\t\t}\n\n\t\t// at least one point is outside\n\t\tr = r0 || r1;\n\n\t\tif (r & R_TOP) {\n\t\t\tx = x0 + (x1 - x0) * (area.top - y0) / (y1 - y0);\n\t\t\ty = area.top;\n\t\t} else if (r & R_BOTTOM) {\n\t\t\tx = x0 + (x1 - x0) * (area.bottom - y0) / (y1 - y0);\n\t\t\ty = area.bottom;\n\t\t} else if (r & R_RIGHT) {\n\t\t\ty = y0 + (y1 - y0) * (area.right - x0) / (x1 - x0);\n\t\t\tx = area.right;\n\t\t} else if (r & R_LEFT) {\n\t\t\ty = y0 + (y1 - y0) * (area.left - x0) / (x1 - x0);\n\t\t\tx = area.left;\n\t\t}\n\n\t\tif (r === r0) {\n\t\t\tx0 = x;\n\t\t\ty0 = y;\n\t\t\tr0 = region(x0, y0, area);\n\t\t} else {\n\t\t\tx1 = x;\n\t\t\ty1 = y;\n\t\t\tr1 = region(x1, y1, area);\n\t\t}\n\t}\n\n\treturn {\n\t\tx0: x0,\n\t\tx1: x1,\n\t\ty0: y0,\n\t\ty1: y1\n\t};\n}\n\nfunction compute(range, config) {\n\tvar anchor = config.anchor;\n\tvar segment = range;\n\tvar x, y;\n\n\tif (config.clamp) {\n\t\tsegment = clipped(segment, config.area);\n\t}\n\n\tif (anchor === 'start') {\n\t\tx = segment.x0;\n\t\ty = segment.y0;\n\t} else if (anchor === 'end') {\n\t\tx = segment.x1;\n\t\ty = segment.y1;\n\t} else {\n\t\tx = (segment.x0 + segment.x1) / 2;\n\t\ty = (segment.y0 + segment.y1) / 2;\n\t}\n\n\treturn aligned(x, y, range.vx, range.vy, config.align);\n}\n\nvar positioners = {\n\tarc: function(vm, config) {\n\t\tvar angle = (vm.startAngle + vm.endAngle) / 2;\n\t\tvar vx = Math.cos(angle);\n\t\tvar vy = Math.sin(angle);\n\t\tvar r0 = vm.innerRadius;\n\t\tvar r1 = vm.outerRadius;\n\n\t\treturn compute({\n\t\t\tx0: vm.x + vx * r0,\n\t\t\ty0: vm.y + vy * r0,\n\t\t\tx1: vm.x + vx * r1,\n\t\t\ty1: vm.y + vy * r1,\n\t\t\tvx: vx,\n\t\t\tvy: vy\n\t\t}, config);\n\t},\n\n\tpoint: function(vm, config) {\n\t\tvar v = orient(vm, config.origin);\n\t\tvar rx = v.x * vm.radius;\n\t\tvar ry = v.y * vm.radius;\n\n\t\treturn compute({\n\t\t\tx0: vm.x - rx,\n\t\t\ty0: vm.y - ry,\n\t\t\tx1: vm.x + rx,\n\t\t\ty1: vm.y + ry,\n\t\t\tvx: v.x,\n\t\t\tvy: v.y\n\t\t}, config);\n\t},\n\n\trect: function(vm, config) {\n\t\tvar v = orient(vm, config.origin);\n\t\tvar x = vm.x;\n\t\tvar y = vm.y;\n\t\tvar sx = 0;\n\t\tvar sy = 0;\n\n\t\tif (vm.horizontal) {\n\t\t\tx = Math.min(vm.x, vm.base);\n\t\t\tsx = Math.abs(vm.base - vm.x);\n\t\t} else {\n\t\t\ty = Math.min(vm.y, vm.base);\n\t\t\tsy = Math.abs(vm.base - vm.y);\n\t\t}\n\n\t\treturn compute({\n\t\t\tx0: x,\n\t\t\ty0: y + sy,\n\t\t\tx1: x + sx,\n\t\t\ty1: y,\n\t\t\tvx: v.x,\n\t\t\tvy: v.y\n\t\t}, config);\n\t},\n\n\tfallback: function(vm, config) {\n\t\tvar v = orient(vm, config.origin);\n\n\t\treturn compute({\n\t\t\tx0: vm.x,\n\t\t\ty0: vm.y,\n\t\t\tx1: vm.x,\n\t\t\ty1: vm.y,\n\t\t\tvx: v.x,\n\t\t\tvy: v.y\n\t\t}, config);\n\t}\n};\n\nvar helpers$1 = Chart.helpers;\nvar rasterize = utils.rasterize;\n\nfunction boundingRects(model) {\n\tvar borderWidth = model.borderWidth || 0;\n\tvar padding = model.padding;\n\tvar th = model.size.height;\n\tvar tw = model.size.width;\n\tvar tx = -tw / 2;\n\tvar ty = -th / 2;\n\n\treturn {\n\t\tframe: {\n\t\t\tx: tx - padding.left - borderWidth,\n\t\t\ty: ty - padding.top - borderWidth,\n\t\t\tw: tw + padding.width + borderWidth * 2,\n\t\t\th: th + padding.height + borderWidth * 2\n\t\t},\n\t\ttext: {\n\t\t\tx: tx,\n\t\t\ty: ty,\n\t\t\tw: tw,\n\t\t\th: th\n\t\t}\n\t};\n}\n\nfunction getScaleOrigin(el) {\n\tvar horizontal = el._model.horizontal;\n\tvar scale = el._scale || (horizontal && el._xScale) || el._yScale;\n\n\tif (!scale) {\n\t\treturn null;\n\t}\n\n\tif (scale.xCenter !== undefined && scale.yCenter !== undefined) {\n\t\treturn {x: scale.xCenter, y: scale.yCenter};\n\t}\n\n\tvar pixel = scale.getBasePixel();\n\treturn horizontal ?\n\t\t{x: pixel, y: null} :\n\t\t{x: null, y: pixel};\n}\n\nfunction getPositioner(el) {\n\tif (el instanceof Chart.elements.Arc) {\n\t\treturn positioners.arc;\n\t}\n\tif (el instanceof Chart.elements.Point) {\n\t\treturn positioners.point;\n\t}\n\tif (el instanceof Chart.elements.Rectangle) {\n\t\treturn positioners.rect;\n\t}\n\treturn positioners.fallback;\n}\n\nfunction drawFrame(ctx, rect, model) {\n\tvar bgColor = model.backgroundColor;\n\tvar borderColor = model.borderColor;\n\tvar borderWidth = model.borderWidth;\n\n\tif (!bgColor && (!borderColor || !borderWidth)) {\n\t\treturn;\n\t}\n\n\tctx.beginPath();\n\n\thelpers$1.canvas.roundedRect(\n\t\tctx,\n\t\trasterize(rect.x) + borderWidth / 2,\n\t\trasterize(rect.y) + borderWidth / 2,\n\t\trasterize(rect.w) - borderWidth,\n\t\trasterize(rect.h) - borderWidth,\n\t\tmodel.borderRadius);\n\n\tctx.closePath();\n\n\tif (bgColor) {\n\t\tctx.fillStyle = bgColor;\n\t\tctx.fill();\n\t}\n\n\tif (borderColor && borderWidth) {\n\t\tctx.strokeStyle = borderColor;\n\t\tctx.lineWidth = borderWidth;\n\t\tctx.lineJoin = 'miter';\n\t\tctx.stroke();\n\t}\n}\n\nfunction textGeometry(rect, align, font) {\n\tvar h = font.lineHeight;\n\tvar w = rect.w;\n\tvar x = rect.x;\n\tvar y = rect.y + h / 2;\n\n\tif (align === 'center') {\n\t\tx += w / 2;\n\t} else if (align === 'end' || align === 'right') {\n\t\tx += w;\n\t}\n\n\treturn {\n\t\th: h,\n\t\tw: w,\n\t\tx: x,\n\t\ty: y\n\t};\n}\n\nfunction drawTextLine(ctx, text, cfg) {\n\tvar shadow = ctx.shadowBlur;\n\tvar stroked = cfg.stroked;\n\tvar x = rasterize(cfg.x);\n\tvar y = rasterize(cfg.y);\n\tvar w = rasterize(cfg.w);\n\n\tif (stroked) {\n\t\tctx.strokeText(text, x, y, w);\n\t}\n\n\tif (cfg.filled) {\n\t\tif (shadow && stroked) {\n\t\t\t// Prevent drawing shadow on both the text stroke and fill, so\n\t\t\t// if the text is stroked, remove the shadow for the text fill.\n\t\t\tctx.shadowBlur = 0;\n\t\t}\n\n\t\tctx.fillText(text, x, y, w);\n\n\t\tif (shadow && stroked) {\n\t\t\tctx.shadowBlur = shadow;\n\t\t}\n\t}\n}\n\nfunction drawText(ctx, lines, rect, model) {\n\tvar align = model.textAlign;\n\tvar color = model.color;\n\tvar filled = !!color;\n\tvar font = model.font;\n\tvar ilen = lines.length;\n\tvar strokeColor = model.textStrokeColor;\n\tvar strokeWidth = model.textStrokeWidth;\n\tvar stroked = strokeColor && strokeWidth;\n\tvar i;\n\n\tif (!ilen || (!filled && !stroked)) {\n\t\treturn;\n\t}\n\n\t// Adjust coordinates based on text alignment and line height\n\trect = textGeometry(rect, align, font);\n\n\tctx.font = font.string;\n\tctx.textAlign = align;\n\tctx.textBaseline = 'middle';\n\tctx.shadowBlur = model.textShadowBlur;\n\tctx.shadowColor = model.textShadowColor;\n\n\tif (filled) {\n\t\tctx.fillStyle = color;\n\t}\n\tif (stroked) {\n\t\tctx.lineJoin = 'round';\n\t\tctx.lineWidth = strokeWidth;\n\t\tctx.strokeStyle = strokeColor;\n\t}\n\n\tfor (i = 0, ilen = lines.length; i < ilen; ++i) {\n\t\tdrawTextLine(ctx, lines[i], {\n\t\t\tstroked: stroked,\n\t\t\tfilled: filled,\n\t\t\tw: rect.w,\n\t\t\tx: rect.x,\n\t\t\ty: rect.y + rect.h * i\n\t\t});\n\t}\n}\n\nvar Label = function(config, ctx, el, index) {\n\tvar me = this;\n\n\tme._config = config;\n\tme._index = index;\n\tme._model = null;\n\tme._rects = null;\n\tme._ctx = ctx;\n\tme._el = el;\n};\n\nhelpers$1.extend(Label.prototype, {\n\t/**\n\t * @private\n\t */\n\t_modelize: function(display, lines, config, context) {\n\t\tvar me = this;\n\t\tvar index = me._index;\n\t\tvar resolve = helpers$1.options.resolve;\n\t\tvar font = utils.parseFont(resolve([config.font, {}], context, index));\n\t\tvar color = resolve([config.color, Chart.defaults.global.defaultFontColor], context, index);\n\n\t\treturn {\n\t\t\talign: resolve([config.align, 'center'], context, index),\n\t\t\tanchor: resolve([config.anchor, 'center'], context, index),\n\t\t\tarea: context.chart.chartArea,\n\t\t\tbackgroundColor: resolve([config.backgroundColor, null], context, index),\n\t\t\tborderColor: resolve([config.borderColor, null], context, index),\n\t\t\tborderRadius: resolve([config.borderRadius, 0], context, index),\n\t\t\tborderWidth: resolve([config.borderWidth, 0], context, index),\n\t\t\tclamp: resolve([config.clamp, false], context, index),\n\t\t\tclip: resolve([config.clip, false], context, index),\n\t\t\tcolor: color,\n\t\t\tdisplay: display,\n\t\t\tfont: font,\n\t\t\tlines: lines,\n\t\t\toffset: resolve([config.offset, 0], context, index),\n\t\t\topacity: resolve([config.opacity, 1], context, index),\n\t\t\torigin: getScaleOrigin(me._el),\n\t\t\tpadding: helpers$1.options.toPadding(resolve([config.padding, 0], context, index)),\n\t\t\tpositioner: getPositioner(me._el),\n\t\t\trotation: resolve([config.rotation, 0], context, index) * (Math.PI / 180),\n\t\t\tsize: utils.textSize(me._ctx, lines, font),\n\t\t\ttextAlign: resolve([config.textAlign, 'start'], context, index),\n\t\t\ttextShadowBlur: resolve([config.textShadowBlur, 0], context, index),\n\t\t\ttextShadowColor: resolve([config.textShadowColor, color], context, index),\n\t\t\ttextStrokeColor: resolve([config.textStrokeColor, color], context, index),\n\t\t\ttextStrokeWidth: resolve([config.textStrokeWidth, 0], context, index)\n\t\t};\n\t},\n\n\tupdate: function(context) {\n\t\tvar me = this;\n\t\tvar model = null;\n\t\tvar rects = null;\n\t\tvar index = me._index;\n\t\tvar config = me._config;\n\t\tvar value, label, lines;\n\n\t\t// We first resolve the display option (separately) to avoid computing\n\t\t// other options in case the label is hidden (i.e. display: false).\n\t\tvar display = helpers$1.options.resolve([config.display, true], context, index);\n\n\t\tif (display) {\n\t\t\tvalue = context.dataset.data[index];\n\t\t\tlabel = helpers$1.valueOrDefault(helpers$1.callback(config.formatter, [value, context]), value);\n\t\t\tlines = helpers$1.isNullOrUndef(label) ? [] : utils.toTextLines(label);\n\n\t\t\tif (lines.length) {\n\t\t\t\tmodel = me._modelize(display, lines, config, context);\n\t\t\t\trects = boundingRects(model);\n\t\t\t}\n\t\t}\n\n\t\tme._model = model;\n\t\tme._rects = rects;\n\t},\n\n\tgeometry: function() {\n\t\treturn this._rects ? this._rects.frame : {};\n\t},\n\n\trotation: function() {\n\t\treturn this._model ? this._model.rotation : 0;\n\t},\n\n\tvisible: function() {\n\t\treturn this._model && this._model.opacity;\n\t},\n\n\tmodel: function() {\n\t\treturn this._model;\n\t},\n\n\tdraw: function(chart, center) {\n\t\tvar me = this;\n\t\tvar ctx = chart.ctx;\n\t\tvar model = me._model;\n\t\tvar rects = me._rects;\n\t\tvar area;\n\n\t\tif (!this.visible()) {\n\t\t\treturn;\n\t\t}\n\n\t\tctx.save();\n\n\t\tif (model.clip) {\n\t\t\tarea = model.area;\n\t\t\tctx.beginPath();\n\t\t\tctx.rect(\n\t\t\t\tarea.left,\n\t\t\t\tarea.top,\n\t\t\t\tarea.right - area.left,\n\t\t\t\tarea.bottom - area.top);\n\t\t\tctx.clip();\n\t\t}\n\n\t\tctx.globalAlpha = utils.bound(0, model.opacity, 1);\n\t\tctx.translate(rasterize(center.x), rasterize(center.y));\n\t\tctx.rotate(model.rotation);\n\n\t\tdrawFrame(ctx, rects.frame, model);\n\t\tdrawText(ctx, model.lines, rects.text, model);\n\n\t\tctx.restore();\n\t}\n});\n\nvar helpers$2 = Chart.helpers;\n\nvar MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991; // eslint-disable-line es/no-number-minsafeinteger\nvar MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;  // eslint-disable-line es/no-number-maxsafeinteger\n\nfunction rotated(point, center, angle) {\n\tvar cos = Math.cos(angle);\n\tvar sin = Math.sin(angle);\n\tvar cx = center.x;\n\tvar cy = center.y;\n\n\treturn {\n\t\tx: cx + cos * (point.x - cx) - sin * (point.y - cy),\n\t\ty: cy + sin * (point.x - cx) + cos * (point.y - cy)\n\t};\n}\n\nfunction projected(points, axis) {\n\tvar min = MAX_INTEGER;\n\tvar max = MIN_INTEGER;\n\tvar origin = axis.origin;\n\tvar i, pt, vx, vy, dp;\n\n\tfor (i = 0; i < points.length; ++i) {\n\t\tpt = points[i];\n\t\tvx = pt.x - origin.x;\n\t\tvy = pt.y - origin.y;\n\t\tdp = axis.vx * vx + axis.vy * vy;\n\t\tmin = Math.min(min, dp);\n\t\tmax = Math.max(max, dp);\n\t}\n\n\treturn {\n\t\tmin: min,\n\t\tmax: max\n\t};\n}\n\nfunction toAxis(p0, p1) {\n\tvar vx = p1.x - p0.x;\n\tvar vy = p1.y - p0.y;\n\tvar ln = Math.sqrt(vx * vx + vy * vy);\n\n\treturn {\n\t\tvx: (p1.x - p0.x) / ln,\n\t\tvy: (p1.y - p0.y) / ln,\n\t\torigin: p0,\n\t\tln: ln\n\t};\n}\n\nvar HitBox = function() {\n\tthis._rotation = 0;\n\tthis._rect = {\n\t\tx: 0,\n\t\ty: 0,\n\t\tw: 0,\n\t\th: 0\n\t};\n};\n\nhelpers$2.extend(HitBox.prototype, {\n\tcenter: function() {\n\t\tvar r = this._rect;\n\t\treturn {\n\t\t\tx: r.x + r.w / 2,\n\t\t\ty: r.y + r.h / 2\n\t\t};\n\t},\n\n\tupdate: function(center, rect, rotation) {\n\t\tthis._rotation = rotation;\n\t\tthis._rect = {\n\t\t\tx: rect.x + center.x,\n\t\t\ty: rect.y + center.y,\n\t\t\tw: rect.w,\n\t\t\th: rect.h\n\t\t};\n\t},\n\n\tcontains: function(point) {\n\t\tvar me = this;\n\t\tvar margin = 1;\n\t\tvar rect = me._rect;\n\n\t\tpoint = rotated(point, me.center(), -me._rotation);\n\n\t\treturn !(point.x < rect.x - margin\n\t\t\t|| point.y < rect.y - margin\n\t\t\t|| point.x > rect.x + rect.w + margin * 2\n\t\t\t|| point.y > rect.y + rect.h + margin * 2);\n\t},\n\n\t// Separating Axis Theorem\n\t// https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169\n\tintersects: function(other) {\n\t\tvar r0 = this._points();\n\t\tvar r1 = other._points();\n\t\tvar axes = [\n\t\t\ttoAxis(r0[0], r0[1]),\n\t\t\ttoAxis(r0[0], r0[3])\n\t\t];\n\t\tvar i, pr0, pr1;\n\n\t\tif (this._rotation !== other._rotation) {\n\t\t\t// Only separate with r1 axis if the rotation is different,\n\t\t\t// else it's enough to separate r0 and r1 with r0 axis only!\n\t\t\taxes.push(\n\t\t\t\ttoAxis(r1[0], r1[1]),\n\t\t\t\ttoAxis(r1[0], r1[3])\n\t\t\t);\n\t\t}\n\n\t\tfor (i = 0; i < axes.length; ++i) {\n\t\t\tpr0 = projected(r0, axes[i]);\n\t\t\tpr1 = projected(r1, axes[i]);\n\n\t\t\tif (pr0.max < pr1.min || pr1.max < pr0.min) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * @private\n\t */\n\t_points: function() {\n\t\tvar me = this;\n\t\tvar rect = me._rect;\n\t\tvar angle = me._rotation;\n\t\tvar center = me.center();\n\n\t\treturn [\n\t\t\trotated({x: rect.x, y: rect.y}, center, angle),\n\t\t\trotated({x: rect.x + rect.w, y: rect.y}, center, angle),\n\t\t\trotated({x: rect.x + rect.w, y: rect.y + rect.h}, center, angle),\n\t\t\trotated({x: rect.x, y: rect.y + rect.h}, center, angle)\n\t\t];\n\t}\n});\n\nfunction coordinates(view, model, geometry) {\n\tvar point = model.positioner(view, model);\n\tvar vx = point.vx;\n\tvar vy = point.vy;\n\n\tif (!vx && !vy) {\n\t\t// if aligned center, we don't want to offset the center point\n\t\treturn {x: point.x, y: point.y};\n\t}\n\n\tvar w = geometry.w;\n\tvar h = geometry.h;\n\n\t// take in account the label rotation\n\tvar rotation = model.rotation;\n\tvar dx = Math.abs(w / 2 * Math.cos(rotation)) + Math.abs(h / 2 * Math.sin(rotation));\n\tvar dy = Math.abs(w / 2 * Math.sin(rotation)) + Math.abs(h / 2 * Math.cos(rotation));\n\n\t// scale the unit vector (vx, vy) to get at least dx or dy equal to\n\t// w or h respectively (else we would calculate the distance to the\n\t// ellipse inscribed in the bounding rect)\n\tvar vs = 1 / Math.max(Math.abs(vx), Math.abs(vy));\n\tdx *= vx * vs;\n\tdy *= vy * vs;\n\n\t// finally, include the explicit offset\n\tdx += model.offset * vx;\n\tdy += model.offset * vy;\n\n\treturn {\n\t\tx: point.x + dx,\n\t\ty: point.y + dy\n\t};\n}\n\nfunction collide(labels, collider) {\n\tvar i, j, s0, s1;\n\n\t// IMPORTANT Iterate in the reverse order since items at the end of the\n\t// list have an higher weight/priority and thus should be less impacted\n\t// by the overlapping strategy.\n\n\tfor (i = labels.length - 1; i >= 0; --i) {\n\t\ts0 = labels[i].$layout;\n\n\t\tfor (j = i - 1; j >= 0 && s0._visible; --j) {\n\t\t\ts1 = labels[j].$layout;\n\n\t\t\tif (s1._visible && s0._box.intersects(s1._box)) {\n\t\t\t\tcollider(s0, s1);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn labels;\n}\n\nfunction compute$1(labels) {\n\tvar i, ilen, label, state, geometry, center;\n\n\t// Initialize labels for overlap detection\n\tfor (i = 0, ilen = labels.length; i < ilen; ++i) {\n\t\tlabel = labels[i];\n\t\tstate = label.$layout;\n\n\t\tif (state._visible) {\n\t\t\tgeometry = label.geometry();\n\t\t\tcenter = coordinates(label._el._model, label.model(), geometry);\n\t\t\tstate._box.update(center, geometry, label.rotation());\n\t\t}\n\t}\n\n\t// Auto hide overlapping labels\n\treturn collide(labels, function(s0, s1) {\n\t\tvar h0 = s0._hidable;\n\t\tvar h1 = s1._hidable;\n\n\t\tif ((h0 && h1) || h1) {\n\t\t\ts1._visible = false;\n\t\t} else if (h0) {\n\t\t\ts0._visible = false;\n\t\t}\n\t});\n}\n\nvar layout = {\n\tprepare: function(datasets) {\n\t\tvar labels = [];\n\t\tvar i, j, ilen, jlen, label;\n\n\t\tfor (i = 0, ilen = datasets.length; i < ilen; ++i) {\n\t\t\tfor (j = 0, jlen = datasets[i].length; j < jlen; ++j) {\n\t\t\t\tlabel = datasets[i][j];\n\t\t\t\tlabels.push(label);\n\t\t\t\tlabel.$layout = {\n\t\t\t\t\t_box: new HitBox(),\n\t\t\t\t\t_hidable: false,\n\t\t\t\t\t_visible: true,\n\t\t\t\t\t_set: i,\n\t\t\t\t\t_idx: j\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// TODO New `z` option: labels with a higher z-index are drawn\n\t\t// of top of the ones with a lower index. Lowest z-index labels\n\t\t// are also discarded first when hiding overlapping labels.\n\t\tlabels.sort(function(a, b) {\n\t\t\tvar sa = a.$layout;\n\t\t\tvar sb = b.$layout;\n\n\t\t\treturn sa._idx === sb._idx\n\t\t\t\t? sb._set - sa._set\n\t\t\t\t: sb._idx - sa._idx;\n\t\t});\n\n\t\tthis.update(labels);\n\n\t\treturn labels;\n\t},\n\n\tupdate: function(labels) {\n\t\tvar dirty = false;\n\t\tvar i, ilen, label, model, state;\n\n\t\tfor (i = 0, ilen = labels.length; i < ilen; ++i) {\n\t\t\tlabel = labels[i];\n\t\t\tmodel = label.model();\n\t\t\tstate = label.$layout;\n\t\t\tstate._hidable = model && model.display === 'auto';\n\t\t\tstate._visible = label.visible();\n\t\t\tdirty |= state._hidable;\n\t\t}\n\n\t\tif (dirty) {\n\t\t\tcompute$1(labels);\n\t\t}\n\t},\n\n\tlookup: function(labels, point) {\n\t\tvar i, state;\n\n\t\t// IMPORTANT Iterate in the reverse order since items at the end of\n\t\t// the list have an higher z-index, thus should be picked first.\n\n\t\tfor (i = labels.length - 1; i >= 0; --i) {\n\t\t\tstate = labels[i].$layout;\n\n\t\t\tif (state && state._visible && state._box.contains(point)) {\n\t\t\t\treturn labels[i];\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t},\n\n\tdraw: function(chart, labels) {\n\t\tvar i, ilen, label, state, geometry, center;\n\n\t\tfor (i = 0, ilen = labels.length; i < ilen; ++i) {\n\t\t\tlabel = labels[i];\n\t\t\tstate = label.$layout;\n\n\t\t\tif (state._visible) {\n\t\t\t\tgeometry = label.geometry();\n\t\t\t\tcenter = coordinates(label._el._view, label.model(), geometry);\n\t\t\t\tstate._box.update(center, geometry, label.rotation());\n\t\t\t\tlabel.draw(chart, center);\n\t\t\t}\n\t\t}\n\t}\n};\n\nvar helpers$3 = Chart.helpers;\n\nvar formatter = function(value) {\n\tif (helpers$3.isNullOrUndef(value)) {\n\t\treturn null;\n\t}\n\n\tvar label = value;\n\tvar keys, klen, k;\n\tif (helpers$3.isObject(value)) {\n\t\tif (!helpers$3.isNullOrUndef(value.label)) {\n\t\t\tlabel = value.label;\n\t\t} else if (!helpers$3.isNullOrUndef(value.r)) {\n\t\t\tlabel = value.r;\n\t\t} else {\n\t\t\tlabel = '';\n\t\t\tkeys = Object.keys(value);\n\t\t\tfor (k = 0, klen = keys.length; k < klen; ++k) {\n\t\t\t\tlabel += (k !== 0 ? ', ' : '') + keys[k] + ': ' + value[keys[k]];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '' + label;\n};\n\n/**\n * IMPORTANT: make sure to also update tests and TypeScript definition\n * files (`/test/specs/defaults.spec.js` and `/types/options.d.ts`)\n */\n\nvar defaults = {\n\talign: 'center',\n\tanchor: 'center',\n\tbackgroundColor: null,\n\tborderColor: null,\n\tborderRadius: 0,\n\tborderWidth: 0,\n\tclamp: false,\n\tclip: false,\n\tcolor: undefined,\n\tdisplay: true,\n\tfont: {\n\t\tfamily: undefined,\n\t\tlineHeight: 1.2,\n\t\tsize: undefined,\n\t\tstyle: undefined,\n\t\tweight: null\n\t},\n\tformatter: formatter,\n\tlabels: undefined,\n\tlisteners: {},\n\toffset: 4,\n\topacity: 1,\n\tpadding: {\n\t\ttop: 4,\n\t\tright: 4,\n\t\tbottom: 4,\n\t\tleft: 4\n\t},\n\trotation: 0,\n\ttextAlign: 'start',\n\ttextStrokeColor: undefined,\n\ttextStrokeWidth: 0,\n\ttextShadowBlur: 0,\n\ttextShadowColor: undefined\n};\n\n/**\n * @see https://github.com/chartjs/Chart.js/issues/4176\n */\n\nvar helpers$4 = Chart.helpers;\nvar EXPANDO_KEY = '$datalabels';\nvar DEFAULT_KEY = '$default';\n\nfunction configure(dataset, options) {\n\tvar override = dataset.datalabels;\n\tvar listeners = {};\n\tvar configs = [];\n\tvar labels, keys;\n\n\tif (override === false) {\n\t\treturn null;\n\t}\n\tif (override === true) {\n\t\toverride = {};\n\t}\n\n\toptions = helpers$4.merge({}, [options, override]);\n\tlabels = options.labels || {};\n\tkeys = Object.keys(labels);\n\tdelete options.labels;\n\n\tif (keys.length) {\n\t\tkeys.forEach(function(key) {\n\t\t\tif (labels[key]) {\n\t\t\t\tconfigs.push(helpers$4.merge({}, [\n\t\t\t\t\toptions,\n\t\t\t\t\tlabels[key],\n\t\t\t\t\t{_key: key}\n\t\t\t\t]));\n\t\t\t}\n\t\t});\n\t} else {\n\t\t// Default label if no \"named\" label defined.\n\t\tconfigs.push(options);\n\t}\n\n\t// listeners: {<event-type>: {<label-key>: <fn>}}\n\tlisteners = configs.reduce(function(target, config) {\n\t\thelpers$4.each(config.listeners || {}, function(fn, event) {\n\t\t\ttarget[event] = target[event] || {};\n\t\t\ttarget[event][config._key || DEFAULT_KEY] = fn;\n\t\t});\n\n\t\tdelete config.listeners;\n\t\treturn target;\n\t}, {});\n\n\treturn {\n\t\tlabels: configs,\n\t\tlisteners: listeners\n\t};\n}\n\nfunction dispatchEvent(chart, listeners, label) {\n\tif (!listeners) {\n\t\treturn;\n\t}\n\n\tvar context = label.$context;\n\tvar groups = label.$groups;\n\tvar callback;\n\n\tif (!listeners[groups._set]) {\n\t\treturn;\n\t}\n\n\tcallback = listeners[groups._set][groups._key];\n\tif (!callback) {\n\t\treturn;\n\t}\n\n\tif (helpers$4.callback(callback, [context]) === true) {\n\t\t// Users are allowed to tweak the given context by injecting values that can be\n\t\t// used in scriptable options to display labels differently based on the current\n\t\t// event (e.g. highlight an hovered label). That's why we update the label with\n\t\t// the output context and schedule a new chart render by setting it dirty.\n\t\tchart[EXPANDO_KEY]._dirty = true;\n\t\tlabel.update(context);\n\t}\n}\n\nfunction dispatchMoveEvents(chart, listeners, previous, label) {\n\tvar enter, leave;\n\n\tif (!previous && !label) {\n\t\treturn;\n\t}\n\n\tif (!previous) {\n\t\tenter = true;\n\t} else if (!label) {\n\t\tleave = true;\n\t} else if (previous !== label) {\n\t\tleave = enter = true;\n\t}\n\n\tif (leave) {\n\t\tdispatchEvent(chart, listeners.leave, previous);\n\t}\n\tif (enter) {\n\t\tdispatchEvent(chart, listeners.enter, label);\n\t}\n}\n\nfunction handleMoveEvents(chart, event) {\n\tvar expando = chart[EXPANDO_KEY];\n\tvar listeners = expando._listeners;\n\tvar previous, label;\n\n\tif (!listeners.enter && !listeners.leave) {\n\t\treturn;\n\t}\n\n\tif (event.type === 'mousemove') {\n\t\tlabel = layout.lookup(expando._labels, event);\n\t} else if (event.type !== 'mouseout') {\n\t\treturn;\n\t}\n\n\tprevious = expando._hovered;\n\texpando._hovered = label;\n\tdispatchMoveEvents(chart, listeners, previous, label);\n}\n\nfunction handleClickEvents(chart, event) {\n\tvar expando = chart[EXPANDO_KEY];\n\tvar handlers = expando._listeners.click;\n\tvar label = handlers && layout.lookup(expando._labels, event);\n\tif (label) {\n\t\tdispatchEvent(chart, handlers, label);\n\t}\n}\n\n// https://github.com/chartjs/chartjs-plugin-datalabels/issues/108\nfunction invalidate(chart) {\n\tif (chart.animating) {\n\t\treturn;\n\t}\n\n\t// `chart.animating` can be `false` even if there is animation in progress,\n\t// so let's iterate all animations to find if there is one for the `chart`.\n\tvar animations = Chart.animationService.animations;\n\tfor (var i = 0, ilen = animations.length; i < ilen; ++i) {\n\t\tif (animations[i].chart === chart) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// No render scheduled: trigger a \"lazy\" render that can be canceled in case\n\t// of hover interactions. The 1ms duration is a workaround to make sure an\n\t// animation is created so the controller can stop it before any transition.\n\tchart.render({duration: 1, lazy: true});\n}\n\nChart.defaults.global.plugins.datalabels = defaults;\n\nvar plugin = {\n\tid: 'datalabels',\n\n\tbeforeInit: function(chart) {\n\t\tchart[EXPANDO_KEY] = {\n\t\t\t_actives: []\n\t\t};\n\t},\n\n\tbeforeUpdate: function(chart) {\n\t\tvar expando = chart[EXPANDO_KEY];\n\t\texpando._listened = false;\n\t\texpando._listeners = {};     // {<event-type>: {<dataset-index>: {<label-key>: <fn>}}}\n\t\texpando._datasets = [];      // per dataset labels: [Label[]]\n\t\texpando._labels = [];        // layouted labels: Label[]\n\t},\n\n\tafterDatasetUpdate: function(chart, args, options) {\n\t\tvar datasetIndex = args.index;\n\t\tvar expando = chart[EXPANDO_KEY];\n\t\tvar labels = expando._datasets[datasetIndex] = [];\n\t\tvar visible = chart.isDatasetVisible(datasetIndex);\n\t\tvar dataset = chart.data.datasets[datasetIndex];\n\t\tvar config = configure(dataset, options);\n\t\tvar elements = args.meta.data || [];\n\t\tvar ctx = chart.ctx;\n\t\tvar i, j, ilen, jlen, cfg, key, el, label;\n\n\t\tctx.save();\n\n\t\tfor (i = 0, ilen = elements.length; i < ilen; ++i) {\n\t\t\tel = elements[i];\n\t\t\tel[EXPANDO_KEY] = [];\n\n\t\t\tif (visible && el && !el.hidden && !el._model.skip) {\n\t\t\t\tfor (j = 0, jlen = config.labels.length; j < jlen; ++j) {\n\t\t\t\t\tcfg = config.labels[j];\n\t\t\t\t\tkey = cfg._key;\n\n\t\t\t\t\tlabel = new Label(cfg, ctx, el, i);\n\t\t\t\t\tlabel.$groups = {\n\t\t\t\t\t\t_set: datasetIndex,\n\t\t\t\t\t\t_key: key || DEFAULT_KEY\n\t\t\t\t\t};\n\t\t\t\t\tlabel.$context = {\n\t\t\t\t\t\tactive: false,\n\t\t\t\t\t\tchart: chart,\n\t\t\t\t\t\tdataIndex: i,\n\t\t\t\t\t\tdataset: dataset,\n\t\t\t\t\t\tdatasetIndex: datasetIndex\n\t\t\t\t\t};\n\n\t\t\t\t\tlabel.update(label.$context);\n\t\t\t\t\tel[EXPANDO_KEY].push(label);\n\t\t\t\t\tlabels.push(label);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tctx.restore();\n\n\t\t// Store listeners at the chart level and per event type to optimize\n\t\t// cases where no listeners are registered for a specific event.\n\t\thelpers$4.merge(expando._listeners, config.listeners, {\n\t\t\tmerger: function(event, target, source) {\n\t\t\t\ttarget[event] = target[event] || {};\n\t\t\t\ttarget[event][args.index] = source[event];\n\t\t\t\texpando._listened = true;\n\t\t\t}\n\t\t});\n\t},\n\n\tafterUpdate: function(chart, options) {\n\t\tchart[EXPANDO_KEY]._labels = layout.prepare(\n\t\t\tchart[EXPANDO_KEY]._datasets,\n\t\t\toptions);\n\t},\n\n\t// Draw labels on top of all dataset elements\n\t// https://github.com/chartjs/chartjs-plugin-datalabels/issues/29\n\t// https://github.com/chartjs/chartjs-plugin-datalabels/issues/32\n\tafterDatasetsDraw: function(chart) {\n\t\tlayout.draw(chart, chart[EXPANDO_KEY]._labels);\n\t},\n\n\tbeforeEvent: function(chart, event) {\n\t\t// If there is no listener registered for this chart, `listened` will be false,\n\t\t// meaning we can immediately ignore the incoming event and avoid useless extra\n\t\t// computation for users who don't implement label interactions.\n\t\tif (chart[EXPANDO_KEY]._listened) {\n\t\t\tswitch (event.type) {\n\t\t\tcase 'mousemove':\n\t\t\tcase 'mouseout':\n\t\t\t\thandleMoveEvents(chart, event);\n\t\t\t\tbreak;\n\t\t\tcase 'click':\n\t\t\t\thandleClickEvents(chart, event);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t},\n\n\tafterEvent: function(chart) {\n\t\tvar expando = chart[EXPANDO_KEY];\n\t\tvar previous = expando._actives;\n\t\tvar actives = expando._actives = chart.lastActive || [];  // public API?!\n\t\tvar updates = utils.arrayDiff(previous, actives);\n\t\tvar i, ilen, j, jlen, update, label, labels;\n\n\t\tfor (i = 0, ilen = updates.length; i < ilen; ++i) {\n\t\t\tupdate = updates[i];\n\t\t\tif (update[1]) {\n\t\t\t\tlabels = update[0][EXPANDO_KEY] || [];\n\t\t\t\tfor (j = 0, jlen = labels.length; j < jlen; ++j) {\n\t\t\t\t\tlabel = labels[j];\n\t\t\t\t\tlabel.$context.active = (update[1] === 1);\n\t\t\t\t\tlabel.update(label.$context);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (expando._dirty || updates.length) {\n\t\t\tlayout.update(expando._labels);\n\t\t\tinvalidate(chart);\n\t\t}\n\n\t\tdelete expando._dirty;\n\t}\n};\n\n// TODO Remove at version 1, we shouldn't automatically register plugins.\n// https://github.com/chartjs/chartjs-plugin-datalabels/issues/42\nChart.plugins.register(plugin);\n\nreturn plugin;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicWI0Ni5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2Rpc3QvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy5qcz9hOWJlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscyB2MC43LjBcbiAqIGh0dHBzOi8vY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy5uZXRsaWZ5LmNvbVxuICogKGMpIDIwMTkgQ2hhcnQuanMgQ29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdjaGFydC5qcycpKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydjaGFydC5qcyddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5DaGFydERhdGFMYWJlbHMgPSBmYWN0b3J5KGdsb2JhbC5DaGFydCkpO1xufSh0aGlzLCBmdW5jdGlvbiAoQ2hhcnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5DaGFydCA9IENoYXJ0ICYmIENoYXJ0Lmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyBDaGFydFsnZGVmYXVsdCddIDogQ2hhcnQ7XG5cbnZhciBoZWxwZXJzID0gQ2hhcnQuaGVscGVycztcblxudmFyIGRldmljZVBpeGVsUmF0aW8gPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXHRcdGlmICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykge1xuXHRcdFx0cmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuXHRcdH1cblxuXHRcdC8vIGRldmljZVBpeGVsUmF0aW8gaXMgdW5kZWZpbmVkIG9uIElFMTBcblx0XHQvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjAyMDQxODAvODgzNzg4N1xuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMvaXNzdWVzLzg1XG5cdFx0dmFyIHNjcmVlbiA9IHdpbmRvdy5zY3JlZW47XG5cdFx0aWYgKHNjcmVlbikge1xuXHRcdFx0cmV0dXJuIChzY3JlZW4uZGV2aWNlWERQSSB8fCAxKSAvIChzY3JlZW4ubG9naWNhbFhEUEkgfHwgMSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIDE7XG59KCkpO1xuXG52YXIgdXRpbHMgPSB7XG5cdC8vIEB0b2RvIG1vdmUgdGhpcyBpbiBDaGFydC5oZWxwZXJzLnRvVGV4dExpbmVzXG5cdHRvVGV4dExpbmVzOiBmdW5jdGlvbihpbnB1dHMpIHtcblx0XHR2YXIgbGluZXMgPSBbXTtcblx0XHR2YXIgaW5wdXQ7XG5cblx0XHRpbnB1dHMgPSBbXS5jb25jYXQoaW5wdXRzKTtcblx0XHR3aGlsZSAoaW5wdXRzLmxlbmd0aCkge1xuXHRcdFx0aW5wdXQgPSBpbnB1dHMucG9wKCk7XG5cdFx0XHRpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRsaW5lcy51bnNoaWZ0LmFwcGx5KGxpbmVzLCBpbnB1dC5zcGxpdCgnXFxuJykpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuXHRcdFx0XHRpbnB1dHMucHVzaC5hcHBseShpbnB1dHMsIGlucHV0KTtcblx0XHRcdH0gZWxzZSBpZiAoIWhlbHBlcnMuaXNOdWxsT3JVbmRlZihpbnB1dHMpKSB7XG5cdFx0XHRcdGxpbmVzLnVuc2hpZnQoJycgKyBpbnB1dCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxpbmVzO1xuXHR9LFxuXG5cdC8vIEB0b2RvIG1vdmUgdGhpcyBtZXRob2QgaW4gQ2hhcnQuaGVscGVycy5jYW52YXMudG9Gb250IChkZXByZWNhdGVzIGhlbHBlcnMuZm9udFN0cmluZylcblx0Ly8gQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udFxuXHR0b0ZvbnRTdHJpbmc6IGZ1bmN0aW9uKGZvbnQpIHtcblx0XHRpZiAoIWZvbnQgfHwgaGVscGVycy5pc051bGxPclVuZGVmKGZvbnQuc2l6ZSkgfHwgaGVscGVycy5pc051bGxPclVuZGVmKGZvbnQuZmFtaWx5KSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChmb250LnN0eWxlID8gZm9udC5zdHlsZSArICcgJyA6ICcnKVxuXHRcdFx0KyAoZm9udC53ZWlnaHQgPyBmb250LndlaWdodCArICcgJyA6ICcnKVxuXHRcdFx0KyBmb250LnNpemUgKyAncHggJ1xuXHRcdFx0KyBmb250LmZhbWlseTtcblx0fSxcblxuXHQvLyBAdG9kbyBtb3ZlIHRoaXMgaW4gQ2hhcnQuaGVscGVycy5jYW52YXMudGV4dFNpemVcblx0Ly8gQHRvZG8gY2FjaGUgY2FsbHMgb2YgbWVhc3VyZVRleHQgaWYgZm9udCBkb2Vzbid0IGNoYW5nZT8hXG5cdHRleHRTaXplOiBmdW5jdGlvbihjdHgsIGxpbmVzLCBmb250KSB7XG5cdFx0dmFyIGl0ZW1zID0gW10uY29uY2F0KGxpbmVzKTtcblx0XHR2YXIgaWxlbiA9IGl0ZW1zLmxlbmd0aDtcblx0XHR2YXIgcHJldiA9IGN0eC5mb250O1xuXHRcdHZhciB3aWR0aCA9IDA7XG5cdFx0dmFyIGk7XG5cblx0XHRjdHguZm9udCA9IGZvbnQuc3RyaW5nO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0d2lkdGggPSBNYXRoLm1heChjdHgubWVhc3VyZVRleHQoaXRlbXNbaV0pLndpZHRoLCB3aWR0aCk7XG5cdFx0fVxuXG5cdFx0Y3R4LmZvbnQgPSBwcmV2O1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGhlaWdodDogaWxlbiAqIGZvbnQubGluZUhlaWdodCxcblx0XHRcdHdpZHRoOiB3aWR0aFxuXHRcdH07XG5cdH0sXG5cblx0Ly8gQHRvZG8gbW92ZSB0aGlzIG1ldGhvZCBpbiBDaGFydC5oZWxwZXJzLm9wdGlvbnMudG9Gb250XG5cdHBhcnNlRm9udDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR2YXIgZ2xvYmFsID0gQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsO1xuXHRcdHZhciBzaXplID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdCh2YWx1ZS5zaXplLCBnbG9iYWwuZGVmYXVsdEZvbnRTaXplKTtcblx0XHR2YXIgZm9udCA9IHtcblx0XHRcdGZhbWlseTogaGVscGVycy52YWx1ZU9yRGVmYXVsdCh2YWx1ZS5mYW1pbHksIGdsb2JhbC5kZWZhdWx0Rm9udEZhbWlseSksXG5cdFx0XHRsaW5lSGVpZ2h0OiBoZWxwZXJzLm9wdGlvbnMudG9MaW5lSGVpZ2h0KHZhbHVlLmxpbmVIZWlnaHQsIHNpemUpLFxuXHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdHN0eWxlOiBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KHZhbHVlLnN0eWxlLCBnbG9iYWwuZGVmYXVsdEZvbnRTdHlsZSksXG5cdFx0XHR3ZWlnaHQ6IGhlbHBlcnMudmFsdWVPckRlZmF1bHQodmFsdWUud2VpZ2h0LCBudWxsKSxcblx0XHRcdHN0cmluZzogJydcblx0XHR9O1xuXG5cdFx0Zm9udC5zdHJpbmcgPSB1dGlscy50b0ZvbnRTdHJpbmcoZm9udCk7XG5cdFx0cmV0dXJuIGZvbnQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdmFsdWUgYm91bmRlZCBieSBtaW4gYW5kIG1heC4gVGhpcyBpcyBlcXVpdmFsZW50IHRvIG1heChtaW4sIG1pbih2YWx1ZSwgbWF4KSkuXG5cdCAqIEB0b2RvIG1vdmUgdGhpcyBtZXRob2QgaW4gQ2hhcnQuaGVscGVycy5ib3VuZFxuXHQgKiBodHRwczovL2RvYy5xdC5pby9xdC01L3F0Z2xvYmFsLmh0bWwjcUJvdW5kXG5cdCAqL1xuXHRib3VuZDogZnVuY3Rpb24obWluLCB2YWx1ZSwgbWF4KSB7XG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4odmFsdWUsIG1heCkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHBhaXIgW3ZhbHVlLCBzdGF0ZV0gd2hlcmUgc3RhdGUgaXM6XG5cdCAqICogLTE6IHZhbHVlIGlzIG9ubHkgaW4gYTAgKHJlbW92ZWQpXG5cdCAqICogIDE6IHZhbHVlIGlzIG9ubHkgaW4gYTEgKGFkZGVkKVxuXHQgKi9cblx0YXJyYXlEaWZmOiBmdW5jdGlvbihhMCwgYTEpIHtcblx0XHR2YXIgcHJldiA9IGEwLnNsaWNlKCk7XG5cdFx0dmFyIHVwZGF0ZXMgPSBbXTtcblx0XHR2YXIgaSwgaiwgaWxlbiwgdjtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBhMS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHYgPSBhMVtpXTtcblx0XHRcdGogPSBwcmV2LmluZGV4T2Yodik7XG5cblx0XHRcdGlmIChqID09PSAtMSkge1xuXHRcdFx0XHR1cGRhdGVzLnB1c2goW3YsIDFdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHByZXYuc3BsaWNlKGosIDEpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwcmV2Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0dXBkYXRlcy5wdXNoKFtwcmV2W2ldLCAtMV0pO1xuXHRcdH1cblxuXHRcdHJldHVybiB1cGRhdGVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2lzc3Vlcy83MFxuXHQgKi9cblx0cmFzdGVyaXplOiBmdW5jdGlvbih2KSB7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQodiAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbztcblx0fVxufTtcblxuZnVuY3Rpb24gb3JpZW50KHBvaW50LCBvcmlnaW4pIHtcblx0dmFyIHgwID0gb3JpZ2luLng7XG5cdHZhciB5MCA9IG9yaWdpbi55O1xuXG5cdGlmICh4MCA9PT0gbnVsbCkge1xuXHRcdHJldHVybiB7eDogMCwgeTogLTF9O1xuXHR9XG5cdGlmICh5MCA9PT0gbnVsbCkge1xuXHRcdHJldHVybiB7eDogMSwgeTogMH07XG5cdH1cblxuXHR2YXIgZHggPSBwb2ludC54IC0geDA7XG5cdHZhciBkeSA9IHBvaW50LnkgLSB5MDtcblx0dmFyIGxuID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuXHRyZXR1cm4ge1xuXHRcdHg6IGxuID8gZHggLyBsbiA6IDAsXG5cdFx0eTogbG4gPyBkeSAvIGxuIDogLTFcblx0fTtcbn1cblxuZnVuY3Rpb24gYWxpZ25lZCh4LCB5LCB2eCwgdnksIGFsaWduKSB7XG5cdHN3aXRjaCAoYWxpZ24pIHtcblx0Y2FzZSAnY2VudGVyJzpcblx0XHR2eCA9IHZ5ID0gMDtcblx0XHRicmVhaztcblx0Y2FzZSAnYm90dG9tJzpcblx0XHR2eCA9IDA7XG5cdFx0dnkgPSAxO1xuXHRcdGJyZWFrO1xuXHRjYXNlICdyaWdodCc6XG5cdFx0dnggPSAxO1xuXHRcdHZ5ID0gMDtcblx0XHRicmVhaztcblx0Y2FzZSAnbGVmdCc6XG5cdFx0dnggPSAtMTtcblx0XHR2eSA9IDA7XG5cdFx0YnJlYWs7XG5cdGNhc2UgJ3RvcCc6XG5cdFx0dnggPSAwO1xuXHRcdHZ5ID0gLTE7XG5cdFx0YnJlYWs7XG5cdGNhc2UgJ3N0YXJ0Jzpcblx0XHR2eCA9IC12eDtcblx0XHR2eSA9IC12eTtcblx0XHRicmVhaztcblx0Y2FzZSAnZW5kJzpcblx0XHQvLyBrZWVwIG5hdHVyYWwgb3JpZW50YXRpb25cblx0XHRicmVhaztcblx0ZGVmYXVsdDpcblx0XHQvLyBjbG9ja3dpc2Ugcm90YXRpb24gKGluIGRlZ3JlZSlcblx0XHRhbGlnbiAqPSAoTWF0aC5QSSAvIDE4MCk7XG5cdFx0dnggPSBNYXRoLmNvcyhhbGlnbik7XG5cdFx0dnkgPSBNYXRoLnNpbihhbGlnbik7XG5cdFx0YnJlYWs7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHg6IHgsXG5cdFx0eTogeSxcblx0XHR2eDogdngsXG5cdFx0dnk6IHZ5XG5cdH07XG59XG5cbi8vIExpbmUgY2xpcHBpbmcgKENvaGVu4oCTU3V0aGVybGFuZCBhbGdvcml0aG0pXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2hlbuKAk1N1dGhlcmxhbmRfYWxnb3JpdGhtXG5cbnZhciBSX0lOU0lERSA9IDA7XG52YXIgUl9MRUZUID0gMTtcbnZhciBSX1JJR0hUID0gMjtcbnZhciBSX0JPVFRPTSA9IDQ7XG52YXIgUl9UT1AgPSA4O1xuXG5mdW5jdGlvbiByZWdpb24oeCwgeSwgcmVjdCkge1xuXHR2YXIgcmVzID0gUl9JTlNJREU7XG5cblx0aWYgKHggPCByZWN0LmxlZnQpIHtcblx0XHRyZXMgfD0gUl9MRUZUO1xuXHR9IGVsc2UgaWYgKHggPiByZWN0LnJpZ2h0KSB7XG5cdFx0cmVzIHw9IFJfUklHSFQ7XG5cdH1cblx0aWYgKHkgPCByZWN0LnRvcCkge1xuXHRcdHJlcyB8PSBSX1RPUDtcblx0fSBlbHNlIGlmICh5ID4gcmVjdC5ib3R0b20pIHtcblx0XHRyZXMgfD0gUl9CT1RUT007XG5cdH1cblxuXHRyZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjbGlwcGVkKHNlZ21lbnQsIGFyZWEpIHtcblx0dmFyIHgwID0gc2VnbWVudC54MDtcblx0dmFyIHkwID0gc2VnbWVudC55MDtcblx0dmFyIHgxID0gc2VnbWVudC54MTtcblx0dmFyIHkxID0gc2VnbWVudC55MTtcblx0dmFyIHIwID0gcmVnaW9uKHgwLCB5MCwgYXJlYSk7XG5cdHZhciByMSA9IHJlZ2lvbih4MSwgeTEsIGFyZWEpO1xuXHR2YXIgciwgeCwgeTtcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG5cdHdoaWxlICh0cnVlKSB7XG5cdFx0aWYgKCEocjAgfCByMSkgfHwgKHIwICYgcjEpKSB7XG5cdFx0XHQvLyBib3RoIHBvaW50cyBpbnNpZGUgb3Igb24gdGhlIHNhbWUgc2lkZTogbm8gY2xpcHBpbmdcblx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdC8vIGF0IGxlYXN0IG9uZSBwb2ludCBpcyBvdXRzaWRlXG5cdFx0ciA9IHIwIHx8IHIxO1xuXG5cdFx0aWYgKHIgJiBSX1RPUCkge1xuXHRcdFx0eCA9IHgwICsgKHgxIC0geDApICogKGFyZWEudG9wIC0geTApIC8gKHkxIC0geTApO1xuXHRcdFx0eSA9IGFyZWEudG9wO1xuXHRcdH0gZWxzZSBpZiAociAmIFJfQk9UVE9NKSB7XG5cdFx0XHR4ID0geDAgKyAoeDEgLSB4MCkgKiAoYXJlYS5ib3R0b20gLSB5MCkgLyAoeTEgLSB5MCk7XG5cdFx0XHR5ID0gYXJlYS5ib3R0b207XG5cdFx0fSBlbHNlIGlmIChyICYgUl9SSUdIVCkge1xuXHRcdFx0eSA9IHkwICsgKHkxIC0geTApICogKGFyZWEucmlnaHQgLSB4MCkgLyAoeDEgLSB4MCk7XG5cdFx0XHR4ID0gYXJlYS5yaWdodDtcblx0XHR9IGVsc2UgaWYgKHIgJiBSX0xFRlQpIHtcblx0XHRcdHkgPSB5MCArICh5MSAtIHkwKSAqIChhcmVhLmxlZnQgLSB4MCkgLyAoeDEgLSB4MCk7XG5cdFx0XHR4ID0gYXJlYS5sZWZ0O1xuXHRcdH1cblxuXHRcdGlmIChyID09PSByMCkge1xuXHRcdFx0eDAgPSB4O1xuXHRcdFx0eTAgPSB5O1xuXHRcdFx0cjAgPSByZWdpb24oeDAsIHkwLCBhcmVhKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eDEgPSB4O1xuXHRcdFx0eTEgPSB5O1xuXHRcdFx0cjEgPSByZWdpb24oeDEsIHkxLCBhcmVhKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHgwOiB4MCxcblx0XHR4MTogeDEsXG5cdFx0eTA6IHkwLFxuXHRcdHkxOiB5MVxuXHR9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlKHJhbmdlLCBjb25maWcpIHtcblx0dmFyIGFuY2hvciA9IGNvbmZpZy5hbmNob3I7XG5cdHZhciBzZWdtZW50ID0gcmFuZ2U7XG5cdHZhciB4LCB5O1xuXG5cdGlmIChjb25maWcuY2xhbXApIHtcblx0XHRzZWdtZW50ID0gY2xpcHBlZChzZWdtZW50LCBjb25maWcuYXJlYSk7XG5cdH1cblxuXHRpZiAoYW5jaG9yID09PSAnc3RhcnQnKSB7XG5cdFx0eCA9IHNlZ21lbnQueDA7XG5cdFx0eSA9IHNlZ21lbnQueTA7XG5cdH0gZWxzZSBpZiAoYW5jaG9yID09PSAnZW5kJykge1xuXHRcdHggPSBzZWdtZW50LngxO1xuXHRcdHkgPSBzZWdtZW50LnkxO1xuXHR9IGVsc2Uge1xuXHRcdHggPSAoc2VnbWVudC54MCArIHNlZ21lbnQueDEpIC8gMjtcblx0XHR5ID0gKHNlZ21lbnQueTAgKyBzZWdtZW50LnkxKSAvIDI7XG5cdH1cblxuXHRyZXR1cm4gYWxpZ25lZCh4LCB5LCByYW5nZS52eCwgcmFuZ2UudnksIGNvbmZpZy5hbGlnbik7XG59XG5cbnZhciBwb3NpdGlvbmVycyA9IHtcblx0YXJjOiBmdW5jdGlvbih2bSwgY29uZmlnKSB7XG5cdFx0dmFyIGFuZ2xlID0gKHZtLnN0YXJ0QW5nbGUgKyB2bS5lbmRBbmdsZSkgLyAyO1xuXHRcdHZhciB2eCA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHR2YXIgdnkgPSBNYXRoLnNpbihhbmdsZSk7XG5cdFx0dmFyIHIwID0gdm0uaW5uZXJSYWRpdXM7XG5cdFx0dmFyIHIxID0gdm0ub3V0ZXJSYWRpdXM7XG5cblx0XHRyZXR1cm4gY29tcHV0ZSh7XG5cdFx0XHR4MDogdm0ueCArIHZ4ICogcjAsXG5cdFx0XHR5MDogdm0ueSArIHZ5ICogcjAsXG5cdFx0XHR4MTogdm0ueCArIHZ4ICogcjEsXG5cdFx0XHR5MTogdm0ueSArIHZ5ICogcjEsXG5cdFx0XHR2eDogdngsXG5cdFx0XHR2eTogdnlcblx0XHR9LCBjb25maWcpO1xuXHR9LFxuXG5cdHBvaW50OiBmdW5jdGlvbih2bSwgY29uZmlnKSB7XG5cdFx0dmFyIHYgPSBvcmllbnQodm0sIGNvbmZpZy5vcmlnaW4pO1xuXHRcdHZhciByeCA9IHYueCAqIHZtLnJhZGl1cztcblx0XHR2YXIgcnkgPSB2LnkgKiB2bS5yYWRpdXM7XG5cblx0XHRyZXR1cm4gY29tcHV0ZSh7XG5cdFx0XHR4MDogdm0ueCAtIHJ4LFxuXHRcdFx0eTA6IHZtLnkgLSByeSxcblx0XHRcdHgxOiB2bS54ICsgcngsXG5cdFx0XHR5MTogdm0ueSArIHJ5LFxuXHRcdFx0dng6IHYueCxcblx0XHRcdHZ5OiB2Lnlcblx0XHR9LCBjb25maWcpO1xuXHR9LFxuXG5cdHJlY3Q6IGZ1bmN0aW9uKHZtLCBjb25maWcpIHtcblx0XHR2YXIgdiA9IG9yaWVudCh2bSwgY29uZmlnLm9yaWdpbik7XG5cdFx0dmFyIHggPSB2bS54O1xuXHRcdHZhciB5ID0gdm0ueTtcblx0XHR2YXIgc3ggPSAwO1xuXHRcdHZhciBzeSA9IDA7XG5cblx0XHRpZiAodm0uaG9yaXpvbnRhbCkge1xuXHRcdFx0eCA9IE1hdGgubWluKHZtLngsIHZtLmJhc2UpO1xuXHRcdFx0c3ggPSBNYXRoLmFicyh2bS5iYXNlIC0gdm0ueCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHkgPSBNYXRoLm1pbih2bS55LCB2bS5iYXNlKTtcblx0XHRcdHN5ID0gTWF0aC5hYnModm0uYmFzZSAtIHZtLnkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wdXRlKHtcblx0XHRcdHgwOiB4LFxuXHRcdFx0eTA6IHkgKyBzeSxcblx0XHRcdHgxOiB4ICsgc3gsXG5cdFx0XHR5MTogeSxcblx0XHRcdHZ4OiB2LngsXG5cdFx0XHR2eTogdi55XG5cdFx0fSwgY29uZmlnKTtcblx0fSxcblxuXHRmYWxsYmFjazogZnVuY3Rpb24odm0sIGNvbmZpZykge1xuXHRcdHZhciB2ID0gb3JpZW50KHZtLCBjb25maWcub3JpZ2luKTtcblxuXHRcdHJldHVybiBjb21wdXRlKHtcblx0XHRcdHgwOiB2bS54LFxuXHRcdFx0eTA6IHZtLnksXG5cdFx0XHR4MTogdm0ueCxcblx0XHRcdHkxOiB2bS55LFxuXHRcdFx0dng6IHYueCxcblx0XHRcdHZ5OiB2Lnlcblx0XHR9LCBjb25maWcpO1xuXHR9XG59O1xuXG52YXIgaGVscGVycyQxID0gQ2hhcnQuaGVscGVycztcbnZhciByYXN0ZXJpemUgPSB1dGlscy5yYXN0ZXJpemU7XG5cbmZ1bmN0aW9uIGJvdW5kaW5nUmVjdHMobW9kZWwpIHtcblx0dmFyIGJvcmRlcldpZHRoID0gbW9kZWwuYm9yZGVyV2lkdGggfHwgMDtcblx0dmFyIHBhZGRpbmcgPSBtb2RlbC5wYWRkaW5nO1xuXHR2YXIgdGggPSBtb2RlbC5zaXplLmhlaWdodDtcblx0dmFyIHR3ID0gbW9kZWwuc2l6ZS53aWR0aDtcblx0dmFyIHR4ID0gLXR3IC8gMjtcblx0dmFyIHR5ID0gLXRoIC8gMjtcblxuXHRyZXR1cm4ge1xuXHRcdGZyYW1lOiB7XG5cdFx0XHR4OiB0eCAtIHBhZGRpbmcubGVmdCAtIGJvcmRlcldpZHRoLFxuXHRcdFx0eTogdHkgLSBwYWRkaW5nLnRvcCAtIGJvcmRlcldpZHRoLFxuXHRcdFx0dzogdHcgKyBwYWRkaW5nLndpZHRoICsgYm9yZGVyV2lkdGggKiAyLFxuXHRcdFx0aDogdGggKyBwYWRkaW5nLmhlaWdodCArIGJvcmRlcldpZHRoICogMlxuXHRcdH0sXG5cdFx0dGV4dDoge1xuXHRcdFx0eDogdHgsXG5cdFx0XHR5OiB0eSxcblx0XHRcdHc6IHR3LFxuXHRcdFx0aDogdGhcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIGdldFNjYWxlT3JpZ2luKGVsKSB7XG5cdHZhciBob3Jpem9udGFsID0gZWwuX21vZGVsLmhvcml6b250YWw7XG5cdHZhciBzY2FsZSA9IGVsLl9zY2FsZSB8fCAoaG9yaXpvbnRhbCAmJiBlbC5feFNjYWxlKSB8fCBlbC5feVNjYWxlO1xuXG5cdGlmICghc2NhbGUpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGlmIChzY2FsZS54Q2VudGVyICE9PSB1bmRlZmluZWQgJiYgc2NhbGUueUNlbnRlciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIHt4OiBzY2FsZS54Q2VudGVyLCB5OiBzY2FsZS55Q2VudGVyfTtcblx0fVxuXG5cdHZhciBwaXhlbCA9IHNjYWxlLmdldEJhc2VQaXhlbCgpO1xuXHRyZXR1cm4gaG9yaXpvbnRhbCA/XG5cdFx0e3g6IHBpeGVsLCB5OiBudWxsfSA6XG5cdFx0e3g6IG51bGwsIHk6IHBpeGVsfTtcbn1cblxuZnVuY3Rpb24gZ2V0UG9zaXRpb25lcihlbCkge1xuXHRpZiAoZWwgaW5zdGFuY2VvZiBDaGFydC5lbGVtZW50cy5BcmMpIHtcblx0XHRyZXR1cm4gcG9zaXRpb25lcnMuYXJjO1xuXHR9XG5cdGlmIChlbCBpbnN0YW5jZW9mIENoYXJ0LmVsZW1lbnRzLlBvaW50KSB7XG5cdFx0cmV0dXJuIHBvc2l0aW9uZXJzLnBvaW50O1xuXHR9XG5cdGlmIChlbCBpbnN0YW5jZW9mIENoYXJ0LmVsZW1lbnRzLlJlY3RhbmdsZSkge1xuXHRcdHJldHVybiBwb3NpdGlvbmVycy5yZWN0O1xuXHR9XG5cdHJldHVybiBwb3NpdGlvbmVycy5mYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gZHJhd0ZyYW1lKGN0eCwgcmVjdCwgbW9kZWwpIHtcblx0dmFyIGJnQ29sb3IgPSBtb2RlbC5iYWNrZ3JvdW5kQ29sb3I7XG5cdHZhciBib3JkZXJDb2xvciA9IG1vZGVsLmJvcmRlckNvbG9yO1xuXHR2YXIgYm9yZGVyV2lkdGggPSBtb2RlbC5ib3JkZXJXaWR0aDtcblxuXHRpZiAoIWJnQ29sb3IgJiYgKCFib3JkZXJDb2xvciB8fCAhYm9yZGVyV2lkdGgpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdGhlbHBlcnMkMS5jYW52YXMucm91bmRlZFJlY3QoXG5cdFx0Y3R4LFxuXHRcdHJhc3Rlcml6ZShyZWN0LngpICsgYm9yZGVyV2lkdGggLyAyLFxuXHRcdHJhc3Rlcml6ZShyZWN0LnkpICsgYm9yZGVyV2lkdGggLyAyLFxuXHRcdHJhc3Rlcml6ZShyZWN0LncpIC0gYm9yZGVyV2lkdGgsXG5cdFx0cmFzdGVyaXplKHJlY3QuaCkgLSBib3JkZXJXaWR0aCxcblx0XHRtb2RlbC5ib3JkZXJSYWRpdXMpO1xuXG5cdGN0eC5jbG9zZVBhdGgoKTtcblxuXHRpZiAoYmdDb2xvcikge1xuXHRcdGN0eC5maWxsU3R5bGUgPSBiZ0NvbG9yO1xuXHRcdGN0eC5maWxsKCk7XG5cdH1cblxuXHRpZiAoYm9yZGVyQ29sb3IgJiYgYm9yZGVyV2lkdGgpIHtcblx0XHRjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJDb2xvcjtcblx0XHRjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG5cdFx0Y3R4LmxpbmVKb2luID0gJ21pdGVyJztcblx0XHRjdHguc3Ryb2tlKCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdGV4dEdlb21ldHJ5KHJlY3QsIGFsaWduLCBmb250KSB7XG5cdHZhciBoID0gZm9udC5saW5lSGVpZ2h0O1xuXHR2YXIgdyA9IHJlY3Qudztcblx0dmFyIHggPSByZWN0Lng7XG5cdHZhciB5ID0gcmVjdC55ICsgaCAvIDI7XG5cblx0aWYgKGFsaWduID09PSAnY2VudGVyJykge1xuXHRcdHggKz0gdyAvIDI7XG5cdH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnIHx8IGFsaWduID09PSAncmlnaHQnKSB7XG5cdFx0eCArPSB3O1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRoOiBoLFxuXHRcdHc6IHcsXG5cdFx0eDogeCxcblx0XHR5OiB5XG5cdH07XG59XG5cbmZ1bmN0aW9uIGRyYXdUZXh0TGluZShjdHgsIHRleHQsIGNmZykge1xuXHR2YXIgc2hhZG93ID0gY3R4LnNoYWRvd0JsdXI7XG5cdHZhciBzdHJva2VkID0gY2ZnLnN0cm9rZWQ7XG5cdHZhciB4ID0gcmFzdGVyaXplKGNmZy54KTtcblx0dmFyIHkgPSByYXN0ZXJpemUoY2ZnLnkpO1xuXHR2YXIgdyA9IHJhc3Rlcml6ZShjZmcudyk7XG5cblx0aWYgKHN0cm9rZWQpIHtcblx0XHRjdHguc3Ryb2tlVGV4dCh0ZXh0LCB4LCB5LCB3KTtcblx0fVxuXG5cdGlmIChjZmcuZmlsbGVkKSB7XG5cdFx0aWYgKHNoYWRvdyAmJiBzdHJva2VkKSB7XG5cdFx0XHQvLyBQcmV2ZW50IGRyYXdpbmcgc2hhZG93IG9uIGJvdGggdGhlIHRleHQgc3Ryb2tlIGFuZCBmaWxsLCBzb1xuXHRcdFx0Ly8gaWYgdGhlIHRleHQgaXMgc3Ryb2tlZCwgcmVtb3ZlIHRoZSBzaGFkb3cgZm9yIHRoZSB0ZXh0IGZpbGwuXG5cdFx0XHRjdHguc2hhZG93Qmx1ciA9IDA7XG5cdFx0fVxuXG5cdFx0Y3R4LmZpbGxUZXh0KHRleHQsIHgsIHksIHcpO1xuXG5cdFx0aWYgKHNoYWRvdyAmJiBzdHJva2VkKSB7XG5cdFx0XHRjdHguc2hhZG93Qmx1ciA9IHNoYWRvdztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZHJhd1RleHQoY3R4LCBsaW5lcywgcmVjdCwgbW9kZWwpIHtcblx0dmFyIGFsaWduID0gbW9kZWwudGV4dEFsaWduO1xuXHR2YXIgY29sb3IgPSBtb2RlbC5jb2xvcjtcblx0dmFyIGZpbGxlZCA9ICEhY29sb3I7XG5cdHZhciBmb250ID0gbW9kZWwuZm9udDtcblx0dmFyIGlsZW4gPSBsaW5lcy5sZW5ndGg7XG5cdHZhciBzdHJva2VDb2xvciA9IG1vZGVsLnRleHRTdHJva2VDb2xvcjtcblx0dmFyIHN0cm9rZVdpZHRoID0gbW9kZWwudGV4dFN0cm9rZVdpZHRoO1xuXHR2YXIgc3Ryb2tlZCA9IHN0cm9rZUNvbG9yICYmIHN0cm9rZVdpZHRoO1xuXHR2YXIgaTtcblxuXHRpZiAoIWlsZW4gfHwgKCFmaWxsZWQgJiYgIXN0cm9rZWQpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gQWRqdXN0IGNvb3JkaW5hdGVzIGJhc2VkIG9uIHRleHQgYWxpZ25tZW50IGFuZCBsaW5lIGhlaWdodFxuXHRyZWN0ID0gdGV4dEdlb21ldHJ5KHJlY3QsIGFsaWduLCBmb250KTtcblxuXHRjdHguZm9udCA9IGZvbnQuc3RyaW5nO1xuXHRjdHgudGV4dEFsaWduID0gYWxpZ247XG5cdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblx0Y3R4LnNoYWRvd0JsdXIgPSBtb2RlbC50ZXh0U2hhZG93Qmx1cjtcblx0Y3R4LnNoYWRvd0NvbG9yID0gbW9kZWwudGV4dFNoYWRvd0NvbG9yO1xuXG5cdGlmIChmaWxsZWQpIHtcblx0XHRjdHguZmlsbFN0eWxlID0gY29sb3I7XG5cdH1cblx0aWYgKHN0cm9rZWQpIHtcblx0XHRjdHgubGluZUpvaW4gPSAncm91bmQnO1xuXHRcdGN0eC5saW5lV2lkdGggPSBzdHJva2VXaWR0aDtcblx0XHRjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvcjtcblx0fVxuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRkcmF3VGV4dExpbmUoY3R4LCBsaW5lc1tpXSwge1xuXHRcdFx0c3Ryb2tlZDogc3Ryb2tlZCxcblx0XHRcdGZpbGxlZDogZmlsbGVkLFxuXHRcdFx0dzogcmVjdC53LFxuXHRcdFx0eDogcmVjdC54LFxuXHRcdFx0eTogcmVjdC55ICsgcmVjdC5oICogaVxuXHRcdH0pO1xuXHR9XG59XG5cbnZhciBMYWJlbCA9IGZ1bmN0aW9uKGNvbmZpZywgY3R4LCBlbCwgaW5kZXgpIHtcblx0dmFyIG1lID0gdGhpcztcblxuXHRtZS5fY29uZmlnID0gY29uZmlnO1xuXHRtZS5faW5kZXggPSBpbmRleDtcblx0bWUuX21vZGVsID0gbnVsbDtcblx0bWUuX3JlY3RzID0gbnVsbDtcblx0bWUuX2N0eCA9IGN0eDtcblx0bWUuX2VsID0gZWw7XG59O1xuXG5oZWxwZXJzJDEuZXh0ZW5kKExhYmVsLnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9tb2RlbGl6ZTogZnVuY3Rpb24oZGlzcGxheSwgbGluZXMsIGNvbmZpZywgY29udGV4dCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGluZGV4ID0gbWUuX2luZGV4O1xuXHRcdHZhciByZXNvbHZlID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcblx0XHR2YXIgZm9udCA9IHV0aWxzLnBhcnNlRm9udChyZXNvbHZlKFtjb25maWcuZm9udCwge31dLCBjb250ZXh0LCBpbmRleCkpO1xuXHRcdHZhciBjb2xvciA9IHJlc29sdmUoW2NvbmZpZy5jb2xvciwgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250Q29sb3JdLCBjb250ZXh0LCBpbmRleCk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWxpZ246IHJlc29sdmUoW2NvbmZpZy5hbGlnbiwgJ2NlbnRlciddLCBjb250ZXh0LCBpbmRleCksXG5cdFx0XHRhbmNob3I6IHJlc29sdmUoW2NvbmZpZy5hbmNob3IsICdjZW50ZXInXSwgY29udGV4dCwgaW5kZXgpLFxuXHRcdFx0YXJlYTogY29udGV4dC5jaGFydC5jaGFydEFyZWEsXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IHJlc29sdmUoW2NvbmZpZy5iYWNrZ3JvdW5kQ29sb3IsIG51bGxdLCBjb250ZXh0LCBpbmRleCksXG5cdFx0XHRib3JkZXJDb2xvcjogcmVzb2x2ZShbY29uZmlnLmJvcmRlckNvbG9yLCBudWxsXSwgY29udGV4dCwgaW5kZXgpLFxuXHRcdFx0Ym9yZGVyUmFkaXVzOiByZXNvbHZlKFtjb25maWcuYm9yZGVyUmFkaXVzLCAwXSwgY29udGV4dCwgaW5kZXgpLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IHJlc29sdmUoW2NvbmZpZy5ib3JkZXJXaWR0aCwgMF0sIGNvbnRleHQsIGluZGV4KSxcblx0XHRcdGNsYW1wOiByZXNvbHZlKFtjb25maWcuY2xhbXAsIGZhbHNlXSwgY29udGV4dCwgaW5kZXgpLFxuXHRcdFx0Y2xpcDogcmVzb2x2ZShbY29uZmlnLmNsaXAsIGZhbHNlXSwgY29udGV4dCwgaW5kZXgpLFxuXHRcdFx0Y29sb3I6IGNvbG9yLFxuXHRcdFx0ZGlzcGxheTogZGlzcGxheSxcblx0XHRcdGZvbnQ6IGZvbnQsXG5cdFx0XHRsaW5lczogbGluZXMsXG5cdFx0XHRvZmZzZXQ6IHJlc29sdmUoW2NvbmZpZy5vZmZzZXQsIDBdLCBjb250ZXh0LCBpbmRleCksXG5cdFx0XHRvcGFjaXR5OiByZXNvbHZlKFtjb25maWcub3BhY2l0eSwgMV0sIGNvbnRleHQsIGluZGV4KSxcblx0XHRcdG9yaWdpbjogZ2V0U2NhbGVPcmlnaW4obWUuX2VsKSxcblx0XHRcdHBhZGRpbmc6IGhlbHBlcnMkMS5vcHRpb25zLnRvUGFkZGluZyhyZXNvbHZlKFtjb25maWcucGFkZGluZywgMF0sIGNvbnRleHQsIGluZGV4KSksXG5cdFx0XHRwb3NpdGlvbmVyOiBnZXRQb3NpdGlvbmVyKG1lLl9lbCksXG5cdFx0XHRyb3RhdGlvbjogcmVzb2x2ZShbY29uZmlnLnJvdGF0aW9uLCAwXSwgY29udGV4dCwgaW5kZXgpICogKE1hdGguUEkgLyAxODApLFxuXHRcdFx0c2l6ZTogdXRpbHMudGV4dFNpemUobWUuX2N0eCwgbGluZXMsIGZvbnQpLFxuXHRcdFx0dGV4dEFsaWduOiByZXNvbHZlKFtjb25maWcudGV4dEFsaWduLCAnc3RhcnQnXSwgY29udGV4dCwgaW5kZXgpLFxuXHRcdFx0dGV4dFNoYWRvd0JsdXI6IHJlc29sdmUoW2NvbmZpZy50ZXh0U2hhZG93Qmx1ciwgMF0sIGNvbnRleHQsIGluZGV4KSxcblx0XHRcdHRleHRTaGFkb3dDb2xvcjogcmVzb2x2ZShbY29uZmlnLnRleHRTaGFkb3dDb2xvciwgY29sb3JdLCBjb250ZXh0LCBpbmRleCksXG5cdFx0XHR0ZXh0U3Ryb2tlQ29sb3I6IHJlc29sdmUoW2NvbmZpZy50ZXh0U3Ryb2tlQ29sb3IsIGNvbG9yXSwgY29udGV4dCwgaW5kZXgpLFxuXHRcdFx0dGV4dFN0cm9rZVdpZHRoOiByZXNvbHZlKFtjb25maWcudGV4dFN0cm9rZVdpZHRoLCAwXSwgY29udGV4dCwgaW5kZXgpXG5cdFx0fTtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtb2RlbCA9IG51bGw7XG5cdFx0dmFyIHJlY3RzID0gbnVsbDtcblx0XHR2YXIgaW5kZXggPSBtZS5faW5kZXg7XG5cdFx0dmFyIGNvbmZpZyA9IG1lLl9jb25maWc7XG5cdFx0dmFyIHZhbHVlLCBsYWJlbCwgbGluZXM7XG5cblx0XHQvLyBXZSBmaXJzdCByZXNvbHZlIHRoZSBkaXNwbGF5IG9wdGlvbiAoc2VwYXJhdGVseSkgdG8gYXZvaWQgY29tcHV0aW5nXG5cdFx0Ly8gb3RoZXIgb3B0aW9ucyBpbiBjYXNlIHRoZSBsYWJlbCBpcyBoaWRkZW4gKGkuZS4gZGlzcGxheTogZmFsc2UpLlxuXHRcdHZhciBkaXNwbGF5ID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZShbY29uZmlnLmRpc3BsYXksIHRydWVdLCBjb250ZXh0LCBpbmRleCk7XG5cblx0XHRpZiAoZGlzcGxheSkge1xuXHRcdFx0dmFsdWUgPSBjb250ZXh0LmRhdGFzZXQuZGF0YVtpbmRleF07XG5cdFx0XHRsYWJlbCA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdChoZWxwZXJzJDEuY2FsbGJhY2soY29uZmlnLmZvcm1hdHRlciwgW3ZhbHVlLCBjb250ZXh0XSksIHZhbHVlKTtcblx0XHRcdGxpbmVzID0gaGVscGVycyQxLmlzTnVsbE9yVW5kZWYobGFiZWwpID8gW10gOiB1dGlscy50b1RleHRMaW5lcyhsYWJlbCk7XG5cblx0XHRcdGlmIChsaW5lcy5sZW5ndGgpIHtcblx0XHRcdFx0bW9kZWwgPSBtZS5fbW9kZWxpemUoZGlzcGxheSwgbGluZXMsIGNvbmZpZywgY29udGV4dCk7XG5cdFx0XHRcdHJlY3RzID0gYm91bmRpbmdSZWN0cyhtb2RlbCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWUuX21vZGVsID0gbW9kZWw7XG5cdFx0bWUuX3JlY3RzID0gcmVjdHM7XG5cdH0sXG5cblx0Z2VvbWV0cnk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9yZWN0cyA/IHRoaXMuX3JlY3RzLmZyYW1lIDoge307XG5cdH0sXG5cblx0cm90YXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tb2RlbCA/IHRoaXMuX21vZGVsLnJvdGF0aW9uIDogMDtcblx0fSxcblxuXHR2aXNpYmxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbW9kZWwgJiYgdGhpcy5fbW9kZWwub3BhY2l0eTtcblx0fSxcblxuXHRtb2RlbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21vZGVsO1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKGNoYXJ0LCBjZW50ZXIpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjdHggPSBjaGFydC5jdHg7XG5cdFx0dmFyIG1vZGVsID0gbWUuX21vZGVsO1xuXHRcdHZhciByZWN0cyA9IG1lLl9yZWN0cztcblx0XHR2YXIgYXJlYTtcblxuXHRcdGlmICghdGhpcy52aXNpYmxlKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjdHguc2F2ZSgpO1xuXG5cdFx0aWYgKG1vZGVsLmNsaXApIHtcblx0XHRcdGFyZWEgPSBtb2RlbC5hcmVhO1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Y3R4LnJlY3QoXG5cdFx0XHRcdGFyZWEubGVmdCxcblx0XHRcdFx0YXJlYS50b3AsXG5cdFx0XHRcdGFyZWEucmlnaHQgLSBhcmVhLmxlZnQsXG5cdFx0XHRcdGFyZWEuYm90dG9tIC0gYXJlYS50b3ApO1xuXHRcdFx0Y3R4LmNsaXAoKTtcblx0XHR9XG5cblx0XHRjdHguZ2xvYmFsQWxwaGEgPSB1dGlscy5ib3VuZCgwLCBtb2RlbC5vcGFjaXR5LCAxKTtcblx0XHRjdHgudHJhbnNsYXRlKHJhc3Rlcml6ZShjZW50ZXIueCksIHJhc3Rlcml6ZShjZW50ZXIueSkpO1xuXHRcdGN0eC5yb3RhdGUobW9kZWwucm90YXRpb24pO1xuXG5cdFx0ZHJhd0ZyYW1lKGN0eCwgcmVjdHMuZnJhbWUsIG1vZGVsKTtcblx0XHRkcmF3VGV4dChjdHgsIG1vZGVsLmxpbmVzLCByZWN0cy50ZXh0LCBtb2RlbCk7XG5cblx0XHRjdHgucmVzdG9yZSgpO1xuXHR9XG59KTtcblxudmFyIGhlbHBlcnMkMiA9IENoYXJ0LmhlbHBlcnM7XG5cbnZhciBNSU5fSU5URUdFUiA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSIHx8IC05MDA3MTk5MjU0NzQwOTkxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVzL25vLW51bWJlci1taW5zYWZlaW50ZWdlclxudmFyIE1BWF9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXMvbm8tbnVtYmVyLW1heHNhZmVpbnRlZ2VyXG5cbmZ1bmN0aW9uIHJvdGF0ZWQocG9pbnQsIGNlbnRlciwgYW5nbGUpIHtcblx0dmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcblx0dmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcblx0dmFyIGN4ID0gY2VudGVyLng7XG5cdHZhciBjeSA9IGNlbnRlci55O1xuXG5cdHJldHVybiB7XG5cdFx0eDogY3ggKyBjb3MgKiAocG9pbnQueCAtIGN4KSAtIHNpbiAqIChwb2ludC55IC0gY3kpLFxuXHRcdHk6IGN5ICsgc2luICogKHBvaW50LnggLSBjeCkgKyBjb3MgKiAocG9pbnQueSAtIGN5KVxuXHR9O1xufVxuXG5mdW5jdGlvbiBwcm9qZWN0ZWQocG9pbnRzLCBheGlzKSB7XG5cdHZhciBtaW4gPSBNQVhfSU5URUdFUjtcblx0dmFyIG1heCA9IE1JTl9JTlRFR0VSO1xuXHR2YXIgb3JpZ2luID0gYXhpcy5vcmlnaW47XG5cdHZhciBpLCBwdCwgdngsIHZ5LCBkcDtcblxuXHRmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSB7XG5cdFx0cHQgPSBwb2ludHNbaV07XG5cdFx0dnggPSBwdC54IC0gb3JpZ2luLng7XG5cdFx0dnkgPSBwdC55IC0gb3JpZ2luLnk7XG5cdFx0ZHAgPSBheGlzLnZ4ICogdnggKyBheGlzLnZ5ICogdnk7XG5cdFx0bWluID0gTWF0aC5taW4obWluLCBkcCk7XG5cdFx0bWF4ID0gTWF0aC5tYXgobWF4LCBkcCk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdG1pbjogbWluLFxuXHRcdG1heDogbWF4XG5cdH07XG59XG5cbmZ1bmN0aW9uIHRvQXhpcyhwMCwgcDEpIHtcblx0dmFyIHZ4ID0gcDEueCAtIHAwLng7XG5cdHZhciB2eSA9IHAxLnkgLSBwMC55O1xuXHR2YXIgbG4gPSBNYXRoLnNxcnQodnggKiB2eCArIHZ5ICogdnkpO1xuXG5cdHJldHVybiB7XG5cdFx0dng6IChwMS54IC0gcDAueCkgLyBsbixcblx0XHR2eTogKHAxLnkgLSBwMC55KSAvIGxuLFxuXHRcdG9yaWdpbjogcDAsXG5cdFx0bG46IGxuXG5cdH07XG59XG5cbnZhciBIaXRCb3ggPSBmdW5jdGlvbigpIHtcblx0dGhpcy5fcm90YXRpb24gPSAwO1xuXHR0aGlzLl9yZWN0ID0ge1xuXHRcdHg6IDAsXG5cdFx0eTogMCxcblx0XHR3OiAwLFxuXHRcdGg6IDBcblx0fTtcbn07XG5cbmhlbHBlcnMkMi5leHRlbmQoSGl0Qm94LnByb3RvdHlwZSwge1xuXHRjZW50ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByID0gdGhpcy5fcmVjdDtcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogci54ICsgci53IC8gMixcblx0XHRcdHk6IHIueSArIHIuaCAvIDJcblx0XHR9O1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24oY2VudGVyLCByZWN0LCByb3RhdGlvbikge1xuXHRcdHRoaXMuX3JvdGF0aW9uID0gcm90YXRpb247XG5cdFx0dGhpcy5fcmVjdCA9IHtcblx0XHRcdHg6IHJlY3QueCArIGNlbnRlci54LFxuXHRcdFx0eTogcmVjdC55ICsgY2VudGVyLnksXG5cdFx0XHR3OiByZWN0LncsXG5cdFx0XHRoOiByZWN0Lmhcblx0XHR9O1xuXHR9LFxuXG5cdGNvbnRhaW5zOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1hcmdpbiA9IDE7XG5cdFx0dmFyIHJlY3QgPSBtZS5fcmVjdDtcblxuXHRcdHBvaW50ID0gcm90YXRlZChwb2ludCwgbWUuY2VudGVyKCksIC1tZS5fcm90YXRpb24pO1xuXG5cdFx0cmV0dXJuICEocG9pbnQueCA8IHJlY3QueCAtIG1hcmdpblxuXHRcdFx0fHwgcG9pbnQueSA8IHJlY3QueSAtIG1hcmdpblxuXHRcdFx0fHwgcG9pbnQueCA+IHJlY3QueCArIHJlY3QudyArIG1hcmdpbiAqIDJcblx0XHRcdHx8IHBvaW50LnkgPiByZWN0LnkgKyByZWN0LmggKyBtYXJnaW4gKiAyKTtcblx0fSxcblxuXHQvLyBTZXBhcmF0aW5nIEF4aXMgVGhlb3JlbVxuXHQvLyBodHRwczovL2dhbWVkZXZlbG9wbWVudC50dXRzcGx1cy5jb20vdHV0b3JpYWxzL2NvbGxpc2lvbi1kZXRlY3Rpb24tdXNpbmctdGhlLXNlcGFyYXRpbmctYXhpcy10aGVvcmVtLS1nYW1lZGV2LTE2OVxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbihvdGhlcikge1xuXHRcdHZhciByMCA9IHRoaXMuX3BvaW50cygpO1xuXHRcdHZhciByMSA9IG90aGVyLl9wb2ludHMoKTtcblx0XHR2YXIgYXhlcyA9IFtcblx0XHRcdHRvQXhpcyhyMFswXSwgcjBbMV0pLFxuXHRcdFx0dG9BeGlzKHIwWzBdLCByMFszXSlcblx0XHRdO1xuXHRcdHZhciBpLCBwcjAsIHByMTtcblxuXHRcdGlmICh0aGlzLl9yb3RhdGlvbiAhPT0gb3RoZXIuX3JvdGF0aW9uKSB7XG5cdFx0XHQvLyBPbmx5IHNlcGFyYXRlIHdpdGggcjEgYXhpcyBpZiB0aGUgcm90YXRpb24gaXMgZGlmZmVyZW50LFxuXHRcdFx0Ly8gZWxzZSBpdCdzIGVub3VnaCB0byBzZXBhcmF0ZSByMCBhbmQgcjEgd2l0aCByMCBheGlzIG9ubHkhXG5cdFx0XHRheGVzLnB1c2goXG5cdFx0XHRcdHRvQXhpcyhyMVswXSwgcjFbMV0pLFxuXHRcdFx0XHR0b0F4aXMocjFbMF0sIHIxWzNdKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0cHIwID0gcHJvamVjdGVkKHIwLCBheGVzW2ldKTtcblx0XHRcdHByMSA9IHByb2plY3RlZChyMSwgYXhlc1tpXSk7XG5cblx0XHRcdGlmIChwcjAubWF4IDwgcHIxLm1pbiB8fCBwcjEubWF4IDwgcHIwLm1pbikge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcG9pbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciByZWN0ID0gbWUuX3JlY3Q7XG5cdFx0dmFyIGFuZ2xlID0gbWUuX3JvdGF0aW9uO1xuXHRcdHZhciBjZW50ZXIgPSBtZS5jZW50ZXIoKTtcblxuXHRcdHJldHVybiBbXG5cdFx0XHRyb3RhdGVkKHt4OiByZWN0LngsIHk6IHJlY3QueX0sIGNlbnRlciwgYW5nbGUpLFxuXHRcdFx0cm90YXRlZCh7eDogcmVjdC54ICsgcmVjdC53LCB5OiByZWN0Lnl9LCBjZW50ZXIsIGFuZ2xlKSxcblx0XHRcdHJvdGF0ZWQoe3g6IHJlY3QueCArIHJlY3QudywgeTogcmVjdC55ICsgcmVjdC5ofSwgY2VudGVyLCBhbmdsZSksXG5cdFx0XHRyb3RhdGVkKHt4OiByZWN0LngsIHk6IHJlY3QueSArIHJlY3QuaH0sIGNlbnRlciwgYW5nbGUpXG5cdFx0XTtcblx0fVxufSk7XG5cbmZ1bmN0aW9uIGNvb3JkaW5hdGVzKHZpZXcsIG1vZGVsLCBnZW9tZXRyeSkge1xuXHR2YXIgcG9pbnQgPSBtb2RlbC5wb3NpdGlvbmVyKHZpZXcsIG1vZGVsKTtcblx0dmFyIHZ4ID0gcG9pbnQudng7XG5cdHZhciB2eSA9IHBvaW50LnZ5O1xuXG5cdGlmICghdnggJiYgIXZ5KSB7XG5cdFx0Ly8gaWYgYWxpZ25lZCBjZW50ZXIsIHdlIGRvbid0IHdhbnQgdG8gb2Zmc2V0IHRoZSBjZW50ZXIgcG9pbnRcblx0XHRyZXR1cm4ge3g6IHBvaW50LngsIHk6IHBvaW50Lnl9O1xuXHR9XG5cblx0dmFyIHcgPSBnZW9tZXRyeS53O1xuXHR2YXIgaCA9IGdlb21ldHJ5Lmg7XG5cblx0Ly8gdGFrZSBpbiBhY2NvdW50IHRoZSBsYWJlbCByb3RhdGlvblxuXHR2YXIgcm90YXRpb24gPSBtb2RlbC5yb3RhdGlvbjtcblx0dmFyIGR4ID0gTWF0aC5hYnModyAvIDIgKiBNYXRoLmNvcyhyb3RhdGlvbikpICsgTWF0aC5hYnMoaCAvIDIgKiBNYXRoLnNpbihyb3RhdGlvbikpO1xuXHR2YXIgZHkgPSBNYXRoLmFicyh3IC8gMiAqIE1hdGguc2luKHJvdGF0aW9uKSkgKyBNYXRoLmFicyhoIC8gMiAqIE1hdGguY29zKHJvdGF0aW9uKSk7XG5cblx0Ly8gc2NhbGUgdGhlIHVuaXQgdmVjdG9yICh2eCwgdnkpIHRvIGdldCBhdCBsZWFzdCBkeCBvciBkeSBlcXVhbCB0b1xuXHQvLyB3IG9yIGggcmVzcGVjdGl2ZWx5IChlbHNlIHdlIHdvdWxkIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgdG8gdGhlXG5cdC8vIGVsbGlwc2UgaW5zY3JpYmVkIGluIHRoZSBib3VuZGluZyByZWN0KVxuXHR2YXIgdnMgPSAxIC8gTWF0aC5tYXgoTWF0aC5hYnModngpLCBNYXRoLmFicyh2eSkpO1xuXHRkeCAqPSB2eCAqIHZzO1xuXHRkeSAqPSB2eSAqIHZzO1xuXG5cdC8vIGZpbmFsbHksIGluY2x1ZGUgdGhlIGV4cGxpY2l0IG9mZnNldFxuXHRkeCArPSBtb2RlbC5vZmZzZXQgKiB2eDtcblx0ZHkgKz0gbW9kZWwub2Zmc2V0ICogdnk7XG5cblx0cmV0dXJuIHtcblx0XHR4OiBwb2ludC54ICsgZHgsXG5cdFx0eTogcG9pbnQueSArIGR5XG5cdH07XG59XG5cbmZ1bmN0aW9uIGNvbGxpZGUobGFiZWxzLCBjb2xsaWRlcikge1xuXHR2YXIgaSwgaiwgczAsIHMxO1xuXG5cdC8vIElNUE9SVEFOVCBJdGVyYXRlIGluIHRoZSByZXZlcnNlIG9yZGVyIHNpbmNlIGl0ZW1zIGF0IHRoZSBlbmQgb2YgdGhlXG5cdC8vIGxpc3QgaGF2ZSBhbiBoaWdoZXIgd2VpZ2h0L3ByaW9yaXR5IGFuZCB0aHVzIHNob3VsZCBiZSBsZXNzIGltcGFjdGVkXG5cdC8vIGJ5IHRoZSBvdmVybGFwcGluZyBzdHJhdGVneS5cblxuXHRmb3IgKGkgPSBsYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcblx0XHRzMCA9IGxhYmVsc1tpXS4kbGF5b3V0O1xuXG5cdFx0Zm9yIChqID0gaSAtIDE7IGogPj0gMCAmJiBzMC5fdmlzaWJsZTsgLS1qKSB7XG5cdFx0XHRzMSA9IGxhYmVsc1tqXS4kbGF5b3V0O1xuXG5cdFx0XHRpZiAoczEuX3Zpc2libGUgJiYgczAuX2JveC5pbnRlcnNlY3RzKHMxLl9ib3gpKSB7XG5cdFx0XHRcdGNvbGxpZGVyKHMwLCBzMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGxhYmVscztcbn1cblxuZnVuY3Rpb24gY29tcHV0ZSQxKGxhYmVscykge1xuXHR2YXIgaSwgaWxlbiwgbGFiZWwsIHN0YXRlLCBnZW9tZXRyeSwgY2VudGVyO1xuXG5cdC8vIEluaXRpYWxpemUgbGFiZWxzIGZvciBvdmVybGFwIGRldGVjdGlvblxuXHRmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGxhYmVsID0gbGFiZWxzW2ldO1xuXHRcdHN0YXRlID0gbGFiZWwuJGxheW91dDtcblxuXHRcdGlmIChzdGF0ZS5fdmlzaWJsZSkge1xuXHRcdFx0Z2VvbWV0cnkgPSBsYWJlbC5nZW9tZXRyeSgpO1xuXHRcdFx0Y2VudGVyID0gY29vcmRpbmF0ZXMobGFiZWwuX2VsLl9tb2RlbCwgbGFiZWwubW9kZWwoKSwgZ2VvbWV0cnkpO1xuXHRcdFx0c3RhdGUuX2JveC51cGRhdGUoY2VudGVyLCBnZW9tZXRyeSwgbGFiZWwucm90YXRpb24oKSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQXV0byBoaWRlIG92ZXJsYXBwaW5nIGxhYmVsc1xuXHRyZXR1cm4gY29sbGlkZShsYWJlbHMsIGZ1bmN0aW9uKHMwLCBzMSkge1xuXHRcdHZhciBoMCA9IHMwLl9oaWRhYmxlO1xuXHRcdHZhciBoMSA9IHMxLl9oaWRhYmxlO1xuXG5cdFx0aWYgKChoMCAmJiBoMSkgfHwgaDEpIHtcblx0XHRcdHMxLl92aXNpYmxlID0gZmFsc2U7XG5cdFx0fSBlbHNlIGlmIChoMCkge1xuXHRcdFx0czAuX3Zpc2libGUgPSBmYWxzZTtcblx0XHR9XG5cdH0pO1xufVxuXG52YXIgbGF5b3V0ID0ge1xuXHRwcmVwYXJlOiBmdW5jdGlvbihkYXRhc2V0cykge1xuXHRcdHZhciBsYWJlbHMgPSBbXTtcblx0XHR2YXIgaSwgaiwgaWxlbiwgamxlbiwgbGFiZWw7XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRmb3IgKGogPSAwLCBqbGVuID0gZGF0YXNldHNbaV0ubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG5cdFx0XHRcdGxhYmVsID0gZGF0YXNldHNbaV1bal07XG5cdFx0XHRcdGxhYmVscy5wdXNoKGxhYmVsKTtcblx0XHRcdFx0bGFiZWwuJGxheW91dCA9IHtcblx0XHRcdFx0XHRfYm94OiBuZXcgSGl0Qm94KCksXG5cdFx0XHRcdFx0X2hpZGFibGU6IGZhbHNlLFxuXHRcdFx0XHRcdF92aXNpYmxlOiB0cnVlLFxuXHRcdFx0XHRcdF9zZXQ6IGksXG5cdFx0XHRcdFx0X2lkeDogalxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFRPRE8gTmV3IGB6YCBvcHRpb246IGxhYmVscyB3aXRoIGEgaGlnaGVyIHotaW5kZXggYXJlIGRyYXduXG5cdFx0Ly8gb2YgdG9wIG9mIHRoZSBvbmVzIHdpdGggYSBsb3dlciBpbmRleC4gTG93ZXN0IHotaW5kZXggbGFiZWxzXG5cdFx0Ly8gYXJlIGFsc28gZGlzY2FyZGVkIGZpcnN0IHdoZW4gaGlkaW5nIG92ZXJsYXBwaW5nIGxhYmVscy5cblx0XHRsYWJlbHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIgc2EgPSBhLiRsYXlvdXQ7XG5cdFx0XHR2YXIgc2IgPSBiLiRsYXlvdXQ7XG5cblx0XHRcdHJldHVybiBzYS5faWR4ID09PSBzYi5faWR4XG5cdFx0XHRcdD8gc2IuX3NldCAtIHNhLl9zZXRcblx0XHRcdFx0OiBzYi5faWR4IC0gc2EuX2lkeDtcblx0XHR9KTtcblxuXHRcdHRoaXMudXBkYXRlKGxhYmVscyk7XG5cblx0XHRyZXR1cm4gbGFiZWxzO1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24obGFiZWxzKSB7XG5cdFx0dmFyIGRpcnR5ID0gZmFsc2U7XG5cdFx0dmFyIGksIGlsZW4sIGxhYmVsLCBtb2RlbCwgc3RhdGU7XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bGFiZWwgPSBsYWJlbHNbaV07XG5cdFx0XHRtb2RlbCA9IGxhYmVsLm1vZGVsKCk7XG5cdFx0XHRzdGF0ZSA9IGxhYmVsLiRsYXlvdXQ7XG5cdFx0XHRzdGF0ZS5faGlkYWJsZSA9IG1vZGVsICYmIG1vZGVsLmRpc3BsYXkgPT09ICdhdXRvJztcblx0XHRcdHN0YXRlLl92aXNpYmxlID0gbGFiZWwudmlzaWJsZSgpO1xuXHRcdFx0ZGlydHkgfD0gc3RhdGUuX2hpZGFibGU7XG5cdFx0fVxuXG5cdFx0aWYgKGRpcnR5KSB7XG5cdFx0XHRjb21wdXRlJDEobGFiZWxzKTtcblx0XHR9XG5cdH0sXG5cblx0bG9va3VwOiBmdW5jdGlvbihsYWJlbHMsIHBvaW50KSB7XG5cdFx0dmFyIGksIHN0YXRlO1xuXG5cdFx0Ly8gSU1QT1JUQU5UIEl0ZXJhdGUgaW4gdGhlIHJldmVyc2Ugb3JkZXIgc2luY2UgaXRlbXMgYXQgdGhlIGVuZCBvZlxuXHRcdC8vIHRoZSBsaXN0IGhhdmUgYW4gaGlnaGVyIHotaW5kZXgsIHRodXMgc2hvdWxkIGJlIHBpY2tlZCBmaXJzdC5cblxuXHRcdGZvciAoaSA9IGxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuXHRcdFx0c3RhdGUgPSBsYWJlbHNbaV0uJGxheW91dDtcblxuXHRcdFx0aWYgKHN0YXRlICYmIHN0YXRlLl92aXNpYmxlICYmIHN0YXRlLl9ib3guY29udGFpbnMocG9pbnQpKSB7XG5cdFx0XHRcdHJldHVybiBsYWJlbHNbaV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oY2hhcnQsIGxhYmVscykge1xuXHRcdHZhciBpLCBpbGVuLCBsYWJlbCwgc3RhdGUsIGdlb21ldHJ5LCBjZW50ZXI7XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bGFiZWwgPSBsYWJlbHNbaV07XG5cdFx0XHRzdGF0ZSA9IGxhYmVsLiRsYXlvdXQ7XG5cblx0XHRcdGlmIChzdGF0ZS5fdmlzaWJsZSkge1xuXHRcdFx0XHRnZW9tZXRyeSA9IGxhYmVsLmdlb21ldHJ5KCk7XG5cdFx0XHRcdGNlbnRlciA9IGNvb3JkaW5hdGVzKGxhYmVsLl9lbC5fdmlldywgbGFiZWwubW9kZWwoKSwgZ2VvbWV0cnkpO1xuXHRcdFx0XHRzdGF0ZS5fYm94LnVwZGF0ZShjZW50ZXIsIGdlb21ldHJ5LCBsYWJlbC5yb3RhdGlvbigpKTtcblx0XHRcdFx0bGFiZWwuZHJhdyhjaGFydCwgY2VudGVyKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbnZhciBoZWxwZXJzJDMgPSBDaGFydC5oZWxwZXJzO1xuXG52YXIgZm9ybWF0dGVyID0gZnVuY3Rpb24odmFsdWUpIHtcblx0aWYgKGhlbHBlcnMkMy5pc051bGxPclVuZGVmKHZhbHVlKSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIGxhYmVsID0gdmFsdWU7XG5cdHZhciBrZXlzLCBrbGVuLCBrO1xuXHRpZiAoaGVscGVycyQzLmlzT2JqZWN0KHZhbHVlKSkge1xuXHRcdGlmICghaGVscGVycyQzLmlzTnVsbE9yVW5kZWYodmFsdWUubGFiZWwpKSB7XG5cdFx0XHRsYWJlbCA9IHZhbHVlLmxhYmVsO1xuXHRcdH0gZWxzZSBpZiAoIWhlbHBlcnMkMy5pc051bGxPclVuZGVmKHZhbHVlLnIpKSB7XG5cdFx0XHRsYWJlbCA9IHZhbHVlLnI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxhYmVsID0gJyc7XG5cdFx0XHRrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuXHRcdFx0Zm9yIChrID0gMCwga2xlbiA9IGtleXMubGVuZ3RoOyBrIDwga2xlbjsgKytrKSB7XG5cdFx0XHRcdGxhYmVsICs9IChrICE9PSAwID8gJywgJyA6ICcnKSArIGtleXNba10gKyAnOiAnICsgdmFsdWVba2V5c1trXV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuICcnICsgbGFiZWw7XG59O1xuXG4vKipcbiAqIElNUE9SVEFOVDogbWFrZSBzdXJlIHRvIGFsc28gdXBkYXRlIHRlc3RzIGFuZCBUeXBlU2NyaXB0IGRlZmluaXRpb25cbiAqIGZpbGVzIChgL3Rlc3Qvc3BlY3MvZGVmYXVsdHMuc3BlYy5qc2AgYW5kIGAvdHlwZXMvb3B0aW9ucy5kLnRzYClcbiAqL1xuXG52YXIgZGVmYXVsdHMgPSB7XG5cdGFsaWduOiAnY2VudGVyJyxcblx0YW5jaG9yOiAnY2VudGVyJyxcblx0YmFja2dyb3VuZENvbG9yOiBudWxsLFxuXHRib3JkZXJDb2xvcjogbnVsbCxcblx0Ym9yZGVyUmFkaXVzOiAwLFxuXHRib3JkZXJXaWR0aDogMCxcblx0Y2xhbXA6IGZhbHNlLFxuXHRjbGlwOiBmYWxzZSxcblx0Y29sb3I6IHVuZGVmaW5lZCxcblx0ZGlzcGxheTogdHJ1ZSxcblx0Zm9udDoge1xuXHRcdGZhbWlseTogdW5kZWZpbmVkLFxuXHRcdGxpbmVIZWlnaHQ6IDEuMixcblx0XHRzaXplOiB1bmRlZmluZWQsXG5cdFx0c3R5bGU6IHVuZGVmaW5lZCxcblx0XHR3ZWlnaHQ6IG51bGxcblx0fSxcblx0Zm9ybWF0dGVyOiBmb3JtYXR0ZXIsXG5cdGxhYmVsczogdW5kZWZpbmVkLFxuXHRsaXN0ZW5lcnM6IHt9LFxuXHRvZmZzZXQ6IDQsXG5cdG9wYWNpdHk6IDEsXG5cdHBhZGRpbmc6IHtcblx0XHR0b3A6IDQsXG5cdFx0cmlnaHQ6IDQsXG5cdFx0Ym90dG9tOiA0LFxuXHRcdGxlZnQ6IDRcblx0fSxcblx0cm90YXRpb246IDAsXG5cdHRleHRBbGlnbjogJ3N0YXJ0Jyxcblx0dGV4dFN0cm9rZUNvbG9yOiB1bmRlZmluZWQsXG5cdHRleHRTdHJva2VXaWR0aDogMCxcblx0dGV4dFNoYWRvd0JsdXI6IDAsXG5cdHRleHRTaGFkb3dDb2xvcjogdW5kZWZpbmVkXG59O1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxNzZcbiAqL1xuXG52YXIgaGVscGVycyQ0ID0gQ2hhcnQuaGVscGVycztcbnZhciBFWFBBTkRPX0tFWSA9ICckZGF0YWxhYmVscyc7XG52YXIgREVGQVVMVF9LRVkgPSAnJGRlZmF1bHQnO1xuXG5mdW5jdGlvbiBjb25maWd1cmUoZGF0YXNldCwgb3B0aW9ucykge1xuXHR2YXIgb3ZlcnJpZGUgPSBkYXRhc2V0LmRhdGFsYWJlbHM7XG5cdHZhciBsaXN0ZW5lcnMgPSB7fTtcblx0dmFyIGNvbmZpZ3MgPSBbXTtcblx0dmFyIGxhYmVscywga2V5cztcblxuXHRpZiAob3ZlcnJpZGUgPT09IGZhbHNlKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0aWYgKG92ZXJyaWRlID09PSB0cnVlKSB7XG5cdFx0b3ZlcnJpZGUgPSB7fTtcblx0fVxuXG5cdG9wdGlvbnMgPSBoZWxwZXJzJDQubWVyZ2Uoe30sIFtvcHRpb25zLCBvdmVycmlkZV0pO1xuXHRsYWJlbHMgPSBvcHRpb25zLmxhYmVscyB8fCB7fTtcblx0a2V5cyA9IE9iamVjdC5rZXlzKGxhYmVscyk7XG5cdGRlbGV0ZSBvcHRpb25zLmxhYmVscztcblxuXHRpZiAoa2V5cy5sZW5ndGgpIHtcblx0XHRrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRpZiAobGFiZWxzW2tleV0pIHtcblx0XHRcdFx0Y29uZmlncy5wdXNoKGhlbHBlcnMkNC5tZXJnZSh7fSwgW1xuXHRcdFx0XHRcdG9wdGlvbnMsXG5cdFx0XHRcdFx0bGFiZWxzW2tleV0sXG5cdFx0XHRcdFx0e19rZXk6IGtleX1cblx0XHRcdFx0XSkpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdC8vIERlZmF1bHQgbGFiZWwgaWYgbm8gXCJuYW1lZFwiIGxhYmVsIGRlZmluZWQuXG5cdFx0Y29uZmlncy5wdXNoKG9wdGlvbnMpO1xuXHR9XG5cblx0Ly8gbGlzdGVuZXJzOiB7PGV2ZW50LXR5cGU+OiB7PGxhYmVsLWtleT46IDxmbj59fVxuXHRsaXN0ZW5lcnMgPSBjb25maWdzLnJlZHVjZShmdW5jdGlvbih0YXJnZXQsIGNvbmZpZykge1xuXHRcdGhlbHBlcnMkNC5lYWNoKGNvbmZpZy5saXN0ZW5lcnMgfHwge30sIGZ1bmN0aW9uKGZuLCBldmVudCkge1xuXHRcdFx0dGFyZ2V0W2V2ZW50XSA9IHRhcmdldFtldmVudF0gfHwge307XG5cdFx0XHR0YXJnZXRbZXZlbnRdW2NvbmZpZy5fa2V5IHx8IERFRkFVTFRfS0VZXSA9IGZuO1xuXHRcdH0pO1xuXG5cdFx0ZGVsZXRlIGNvbmZpZy5saXN0ZW5lcnM7XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fSwge30pO1xuXG5cdHJldHVybiB7XG5cdFx0bGFiZWxzOiBjb25maWdzLFxuXHRcdGxpc3RlbmVyczogbGlzdGVuZXJzXG5cdH07XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoY2hhcnQsIGxpc3RlbmVycywgbGFiZWwpIHtcblx0aWYgKCFsaXN0ZW5lcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgY29udGV4dCA9IGxhYmVsLiRjb250ZXh0O1xuXHR2YXIgZ3JvdXBzID0gbGFiZWwuJGdyb3Vwcztcblx0dmFyIGNhbGxiYWNrO1xuXG5cdGlmICghbGlzdGVuZXJzW2dyb3Vwcy5fc2V0XSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNhbGxiYWNrID0gbGlzdGVuZXJzW2dyb3Vwcy5fc2V0XVtncm91cHMuX2tleV07XG5cdGlmICghY2FsbGJhY2spIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoaGVscGVycyQ0LmNhbGxiYWNrKGNhbGxiYWNrLCBbY29udGV4dF0pID09PSB0cnVlKSB7XG5cdFx0Ly8gVXNlcnMgYXJlIGFsbG93ZWQgdG8gdHdlYWsgdGhlIGdpdmVuIGNvbnRleHQgYnkgaW5qZWN0aW5nIHZhbHVlcyB0aGF0IGNhbiBiZVxuXHRcdC8vIHVzZWQgaW4gc2NyaXB0YWJsZSBvcHRpb25zIHRvIGRpc3BsYXkgbGFiZWxzIGRpZmZlcmVudGx5IGJhc2VkIG9uIHRoZSBjdXJyZW50XG5cdFx0Ly8gZXZlbnQgKGUuZy4gaGlnaGxpZ2h0IGFuIGhvdmVyZWQgbGFiZWwpLiBUaGF0J3Mgd2h5IHdlIHVwZGF0ZSB0aGUgbGFiZWwgd2l0aFxuXHRcdC8vIHRoZSBvdXRwdXQgY29udGV4dCBhbmQgc2NoZWR1bGUgYSBuZXcgY2hhcnQgcmVuZGVyIGJ5IHNldHRpbmcgaXQgZGlydHkuXG5cdFx0Y2hhcnRbRVhQQU5ET19LRVldLl9kaXJ0eSA9IHRydWU7XG5cdFx0bGFiZWwudXBkYXRlKGNvbnRleHQpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoTW92ZUV2ZW50cyhjaGFydCwgbGlzdGVuZXJzLCBwcmV2aW91cywgbGFiZWwpIHtcblx0dmFyIGVudGVyLCBsZWF2ZTtcblxuXHRpZiAoIXByZXZpb3VzICYmICFsYWJlbCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICghcHJldmlvdXMpIHtcblx0XHRlbnRlciA9IHRydWU7XG5cdH0gZWxzZSBpZiAoIWxhYmVsKSB7XG5cdFx0bGVhdmUgPSB0cnVlO1xuXHR9IGVsc2UgaWYgKHByZXZpb3VzICE9PSBsYWJlbCkge1xuXHRcdGxlYXZlID0gZW50ZXIgPSB0cnVlO1xuXHR9XG5cblx0aWYgKGxlYXZlKSB7XG5cdFx0ZGlzcGF0Y2hFdmVudChjaGFydCwgbGlzdGVuZXJzLmxlYXZlLCBwcmV2aW91cyk7XG5cdH1cblx0aWYgKGVudGVyKSB7XG5cdFx0ZGlzcGF0Y2hFdmVudChjaGFydCwgbGlzdGVuZXJzLmVudGVyLCBsYWJlbCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlTW92ZUV2ZW50cyhjaGFydCwgZXZlbnQpIHtcblx0dmFyIGV4cGFuZG8gPSBjaGFydFtFWFBBTkRPX0tFWV07XG5cdHZhciBsaXN0ZW5lcnMgPSBleHBhbmRvLl9saXN0ZW5lcnM7XG5cdHZhciBwcmV2aW91cywgbGFiZWw7XG5cblx0aWYgKCFsaXN0ZW5lcnMuZW50ZXIgJiYgIWxpc3RlbmVycy5sZWF2ZSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmIChldmVudC50eXBlID09PSAnbW91c2Vtb3ZlJykge1xuXHRcdGxhYmVsID0gbGF5b3V0Lmxvb2t1cChleHBhbmRvLl9sYWJlbHMsIGV2ZW50KTtcblx0fSBlbHNlIGlmIChldmVudC50eXBlICE9PSAnbW91c2VvdXQnKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0cHJldmlvdXMgPSBleHBhbmRvLl9ob3ZlcmVkO1xuXHRleHBhbmRvLl9ob3ZlcmVkID0gbGFiZWw7XG5cdGRpc3BhdGNoTW92ZUV2ZW50cyhjaGFydCwgbGlzdGVuZXJzLCBwcmV2aW91cywgbGFiZWwpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVDbGlja0V2ZW50cyhjaGFydCwgZXZlbnQpIHtcblx0dmFyIGV4cGFuZG8gPSBjaGFydFtFWFBBTkRPX0tFWV07XG5cdHZhciBoYW5kbGVycyA9IGV4cGFuZG8uX2xpc3RlbmVycy5jbGljaztcblx0dmFyIGxhYmVsID0gaGFuZGxlcnMgJiYgbGF5b3V0Lmxvb2t1cChleHBhbmRvLl9sYWJlbHMsIGV2ZW50KTtcblx0aWYgKGxhYmVsKSB7XG5cdFx0ZGlzcGF0Y2hFdmVudChjaGFydCwgaGFuZGxlcnMsIGxhYmVsKTtcblx0fVxufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2lzc3Vlcy8xMDhcbmZ1bmN0aW9uIGludmFsaWRhdGUoY2hhcnQpIHtcblx0aWYgKGNoYXJ0LmFuaW1hdGluZykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIGBjaGFydC5hbmltYXRpbmdgIGNhbiBiZSBgZmFsc2VgIGV2ZW4gaWYgdGhlcmUgaXMgYW5pbWF0aW9uIGluIHByb2dyZXNzLFxuXHQvLyBzbyBsZXQncyBpdGVyYXRlIGFsbCBhbmltYXRpb25zIHRvIGZpbmQgaWYgdGhlcmUgaXMgb25lIGZvciB0aGUgYGNoYXJ0YC5cblx0dmFyIGFuaW1hdGlvbnMgPSBDaGFydC5hbmltYXRpb25TZXJ2aWNlLmFuaW1hdGlvbnM7XG5cdGZvciAodmFyIGkgPSAwLCBpbGVuID0gYW5pbWF0aW9ucy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRpZiAoYW5pbWF0aW9uc1tpXS5jaGFydCA9PT0gY2hhcnQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblxuXHQvLyBObyByZW5kZXIgc2NoZWR1bGVkOiB0cmlnZ2VyIGEgXCJsYXp5XCIgcmVuZGVyIHRoYXQgY2FuIGJlIGNhbmNlbGVkIGluIGNhc2Vcblx0Ly8gb2YgaG92ZXIgaW50ZXJhY3Rpb25zLiBUaGUgMW1zIGR1cmF0aW9uIGlzIGEgd29ya2Fyb3VuZCB0byBtYWtlIHN1cmUgYW5cblx0Ly8gYW5pbWF0aW9uIGlzIGNyZWF0ZWQgc28gdGhlIGNvbnRyb2xsZXIgY2FuIHN0b3AgaXQgYmVmb3JlIGFueSB0cmFuc2l0aW9uLlxuXHRjaGFydC5yZW5kZXIoe2R1cmF0aW9uOiAxLCBsYXp5OiB0cnVlfSk7XG59XG5cbkNoYXJ0LmRlZmF1bHRzLmdsb2JhbC5wbHVnaW5zLmRhdGFsYWJlbHMgPSBkZWZhdWx0cztcblxudmFyIHBsdWdpbiA9IHtcblx0aWQ6ICdkYXRhbGFiZWxzJyxcblxuXHRiZWZvcmVJbml0OiBmdW5jdGlvbihjaGFydCkge1xuXHRcdGNoYXJ0W0VYUEFORE9fS0VZXSA9IHtcblx0XHRcdF9hY3RpdmVzOiBbXVxuXHRcdH07XG5cdH0sXG5cblx0YmVmb3JlVXBkYXRlOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciBleHBhbmRvID0gY2hhcnRbRVhQQU5ET19LRVldO1xuXHRcdGV4cGFuZG8uX2xpc3RlbmVkID0gZmFsc2U7XG5cdFx0ZXhwYW5kby5fbGlzdGVuZXJzID0ge307ICAgICAvLyB7PGV2ZW50LXR5cGU+OiB7PGRhdGFzZXQtaW5kZXg+OiB7PGxhYmVsLWtleT46IDxmbj59fX1cblx0XHRleHBhbmRvLl9kYXRhc2V0cyA9IFtdOyAgICAgIC8vIHBlciBkYXRhc2V0IGxhYmVsczogW0xhYmVsW11dXG5cdFx0ZXhwYW5kby5fbGFiZWxzID0gW107ICAgICAgICAvLyBsYXlvdXRlZCBsYWJlbHM6IExhYmVsW11cblx0fSxcblxuXHRhZnRlckRhdGFzZXRVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0LCBhcmdzLCBvcHRpb25zKSB7XG5cdFx0dmFyIGRhdGFzZXRJbmRleCA9IGFyZ3MuaW5kZXg7XG5cdFx0dmFyIGV4cGFuZG8gPSBjaGFydFtFWFBBTkRPX0tFWV07XG5cdFx0dmFyIGxhYmVscyA9IGV4cGFuZG8uX2RhdGFzZXRzW2RhdGFzZXRJbmRleF0gPSBbXTtcblx0XHR2YXIgdmlzaWJsZSA9IGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KTtcblx0XHR2YXIgZGF0YXNldCA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcblx0XHR2YXIgY29uZmlnID0gY29uZmlndXJlKGRhdGFzZXQsIG9wdGlvbnMpO1xuXHRcdHZhciBlbGVtZW50cyA9IGFyZ3MubWV0YS5kYXRhIHx8IFtdO1xuXHRcdHZhciBjdHggPSBjaGFydC5jdHg7XG5cdFx0dmFyIGksIGosIGlsZW4sIGpsZW4sIGNmZywga2V5LCBlbCwgbGFiZWw7XG5cblx0XHRjdHguc2F2ZSgpO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0ZWwgPSBlbGVtZW50c1tpXTtcblx0XHRcdGVsW0VYUEFORE9fS0VZXSA9IFtdO1xuXG5cdFx0XHRpZiAodmlzaWJsZSAmJiBlbCAmJiAhZWwuaGlkZGVuICYmICFlbC5fbW9kZWwuc2tpcCkge1xuXHRcdFx0XHRmb3IgKGogPSAwLCBqbGVuID0gY29uZmlnLmxhYmVscy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcblx0XHRcdFx0XHRjZmcgPSBjb25maWcubGFiZWxzW2pdO1xuXHRcdFx0XHRcdGtleSA9IGNmZy5fa2V5O1xuXG5cdFx0XHRcdFx0bGFiZWwgPSBuZXcgTGFiZWwoY2ZnLCBjdHgsIGVsLCBpKTtcblx0XHRcdFx0XHRsYWJlbC4kZ3JvdXBzID0ge1xuXHRcdFx0XHRcdFx0X3NldDogZGF0YXNldEluZGV4LFxuXHRcdFx0XHRcdFx0X2tleToga2V5IHx8IERFRkFVTFRfS0VZXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRsYWJlbC4kY29udGV4dCA9IHtcblx0XHRcdFx0XHRcdGFjdGl2ZTogZmFsc2UsXG5cdFx0XHRcdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRcdFx0XHRkYXRhSW5kZXg6IGksXG5cdFx0XHRcdFx0XHRkYXRhc2V0OiBkYXRhc2V0LFxuXHRcdFx0XHRcdFx0ZGF0YXNldEluZGV4OiBkYXRhc2V0SW5kZXhcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0bGFiZWwudXBkYXRlKGxhYmVsLiRjb250ZXh0KTtcblx0XHRcdFx0XHRlbFtFWFBBTkRPX0tFWV0ucHVzaChsYWJlbCk7XG5cdFx0XHRcdFx0bGFiZWxzLnB1c2gobGFiZWwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y3R4LnJlc3RvcmUoKTtcblxuXHRcdC8vIFN0b3JlIGxpc3RlbmVycyBhdCB0aGUgY2hhcnQgbGV2ZWwgYW5kIHBlciBldmVudCB0eXBlIHRvIG9wdGltaXplXG5cdFx0Ly8gY2FzZXMgd2hlcmUgbm8gbGlzdGVuZXJzIGFyZSByZWdpc3RlcmVkIGZvciBhIHNwZWNpZmljIGV2ZW50LlxuXHRcdGhlbHBlcnMkNC5tZXJnZShleHBhbmRvLl9saXN0ZW5lcnMsIGNvbmZpZy5saXN0ZW5lcnMsIHtcblx0XHRcdG1lcmdlcjogZnVuY3Rpb24oZXZlbnQsIHRhcmdldCwgc291cmNlKSB7XG5cdFx0XHRcdHRhcmdldFtldmVudF0gPSB0YXJnZXRbZXZlbnRdIHx8IHt9O1xuXHRcdFx0XHR0YXJnZXRbZXZlbnRdW2FyZ3MuaW5kZXhdID0gc291cmNlW2V2ZW50XTtcblx0XHRcdFx0ZXhwYW5kby5fbGlzdGVuZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGFmdGVyVXBkYXRlOiBmdW5jdGlvbihjaGFydCwgb3B0aW9ucykge1xuXHRcdGNoYXJ0W0VYUEFORE9fS0VZXS5fbGFiZWxzID0gbGF5b3V0LnByZXBhcmUoXG5cdFx0XHRjaGFydFtFWFBBTkRPX0tFWV0uX2RhdGFzZXRzLFxuXHRcdFx0b3B0aW9ucyk7XG5cdH0sXG5cblx0Ly8gRHJhdyBsYWJlbHMgb24gdG9wIG9mIGFsbCBkYXRhc2V0IGVsZW1lbnRzXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMvaXNzdWVzLzI5XG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMvaXNzdWVzLzMyXG5cdGFmdGVyRGF0YXNldHNEcmF3OiBmdW5jdGlvbihjaGFydCkge1xuXHRcdGxheW91dC5kcmF3KGNoYXJ0LCBjaGFydFtFWFBBTkRPX0tFWV0uX2xhYmVscyk7XG5cdH0sXG5cblx0YmVmb3JlRXZlbnQ6IGZ1bmN0aW9uKGNoYXJ0LCBldmVudCkge1xuXHRcdC8vIElmIHRoZXJlIGlzIG5vIGxpc3RlbmVyIHJlZ2lzdGVyZWQgZm9yIHRoaXMgY2hhcnQsIGBsaXN0ZW5lZGAgd2lsbCBiZSBmYWxzZSxcblx0XHQvLyBtZWFuaW5nIHdlIGNhbiBpbW1lZGlhdGVseSBpZ25vcmUgdGhlIGluY29taW5nIGV2ZW50IGFuZCBhdm9pZCB1c2VsZXNzIGV4dHJhXG5cdFx0Ly8gY29tcHV0YXRpb24gZm9yIHVzZXJzIHdobyBkb24ndCBpbXBsZW1lbnQgbGFiZWwgaW50ZXJhY3Rpb25zLlxuXHRcdGlmIChjaGFydFtFWFBBTkRPX0tFWV0uX2xpc3RlbmVkKSB7XG5cdFx0XHRzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcblx0XHRcdGNhc2UgJ21vdXNlbW92ZSc6XG5cdFx0XHRjYXNlICdtb3VzZW91dCc6XG5cdFx0XHRcdGhhbmRsZU1vdmVFdmVudHMoY2hhcnQsIGV2ZW50KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdjbGljayc6XG5cdFx0XHRcdGhhbmRsZUNsaWNrRXZlbnRzKGNoYXJ0LCBldmVudCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0YWZ0ZXJFdmVudDogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgZXhwYW5kbyA9IGNoYXJ0W0VYUEFORE9fS0VZXTtcblx0XHR2YXIgcHJldmlvdXMgPSBleHBhbmRvLl9hY3RpdmVzO1xuXHRcdHZhciBhY3RpdmVzID0gZXhwYW5kby5fYWN0aXZlcyA9IGNoYXJ0Lmxhc3RBY3RpdmUgfHwgW107ICAvLyBwdWJsaWMgQVBJPyFcblx0XHR2YXIgdXBkYXRlcyA9IHV0aWxzLmFycmF5RGlmZihwcmV2aW91cywgYWN0aXZlcyk7XG5cdFx0dmFyIGksIGlsZW4sIGosIGpsZW4sIHVwZGF0ZSwgbGFiZWwsIGxhYmVscztcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSB1cGRhdGVzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0dXBkYXRlID0gdXBkYXRlc1tpXTtcblx0XHRcdGlmICh1cGRhdGVbMV0pIHtcblx0XHRcdFx0bGFiZWxzID0gdXBkYXRlWzBdW0VYUEFORE9fS0VZXSB8fCBbXTtcblx0XHRcdFx0Zm9yIChqID0gMCwgamxlbiA9IGxhYmVscy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcblx0XHRcdFx0XHRsYWJlbCA9IGxhYmVsc1tqXTtcblx0XHRcdFx0XHRsYWJlbC4kY29udGV4dC5hY3RpdmUgPSAodXBkYXRlWzFdID09PSAxKTtcblx0XHRcdFx0XHRsYWJlbC51cGRhdGUobGFiZWwuJGNvbnRleHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGV4cGFuZG8uX2RpcnR5IHx8IHVwZGF0ZXMubGVuZ3RoKSB7XG5cdFx0XHRsYXlvdXQudXBkYXRlKGV4cGFuZG8uX2xhYmVscyk7XG5cdFx0XHRpbnZhbGlkYXRlKGNoYXJ0KTtcblx0XHR9XG5cblx0XHRkZWxldGUgZXhwYW5kby5fZGlydHk7XG5cdH1cbn07XG5cbi8vIFRPRE8gUmVtb3ZlIGF0IHZlcnNpb24gMSwgd2Ugc2hvdWxkbid0IGF1dG9tYXRpY2FsbHkgcmVnaXN0ZXIgcGx1Z2lucy5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMvaXNzdWVzLzQyXG5DaGFydC5wbHVnaW5zLnJlZ2lzdGVyKHBsdWdpbik7XG5cbnJldHVybiBwbHVnaW47XG5cbn0pKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///qb46\n");

/***/ })

}]);