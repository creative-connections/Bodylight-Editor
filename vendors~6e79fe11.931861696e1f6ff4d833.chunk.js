(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~6e79fe11"],{

/***/ "ZWlK":
/*!**************************************************!*\
  !*** ./node_modules/createjs-module/createjs.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;var createjs = (this.createjs = (this.createjs || {}));\n/*!\n* CreateJS\n* Visit http://createjs.com/ for documentation, updates and examples.\n*\n* Copyright (c) 2010 gskinner.com, inc.\n*\n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nthis.createjs = this.createjs||{};\n\n\n//##############################################################################\n// extend.js\n//##############################################################################\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Sets up the prototype chain and constructor property for a new class.\n *\n * This should be called right after creating the class constructor.\n *\n * \tfunction MySubClass() {}\n * \tcreatejs.extend(MySubClass, MySuperClass);\n * \tMySubClass.prototype.doSomething = function() { }\n *\n * \tvar foo = new MySubClass();\n * \tconsole.log(foo instanceof MySuperClass); // true\n * \tconsole.log(foo.prototype.constructor === MySubClass); // true\n *\n * @method extend\n * @param {Function} subclass The subclass.\n * @param {Function} superclass The superclass to extend.\n * @return {Function} Returns the subclass's new prototype.\n */\ncreatejs.extend = function(subclass, superclass) {\n\t\"use strict\";\n\n\tfunction o() { this.constructor = subclass; }\n\to.prototype = superclass.prototype;\n\treturn (subclass.prototype = new o());\n};\n\n//##############################################################################\n// promote.js\n//##############################################################################\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Promotes any methods on the super class that were overridden, by creating an alias in the format `prefix_methodName`.\n * It is recommended to use the super class's name as the prefix.\n * An alias to the super class's constructor is always added in the format `prefix_constructor`.\n * This allows the subclass to call super class methods without using `function.call`, providing better performance.\n *\n * For example, if `MySubClass` extends `MySuperClass`, and both define a `draw` method, then calling `promote(MySubClass, \"MySuperClass\")`\n * would add a `MySuperClass_constructor` method to MySubClass and promote the `draw` method on `MySuperClass` to the\n * prototype of `MySubClass` as `MySuperClass_draw`.\n *\n * This should be called after the class's prototype is fully defined.\n *\n * \tfunction ClassA(name) {\n * \t\tthis.name = name;\n * \t}\n * \tClassA.prototype.greet = function() {\n * \t\treturn \"Hello \"+this.name;\n * \t}\n *\n * \tfunction ClassB(name, punctuation) {\n * \t\tthis.ClassA_constructor(name);\n * \t\tthis.punctuation = punctuation;\n * \t}\n * \tcreatejs.extend(ClassB, ClassA);\n * \tClassB.prototype.greet = function() {\n * \t\treturn this.ClassA_greet()+this.punctuation;\n * \t}\n * \tcreatejs.promote(ClassB, \"ClassA\");\n *\n * \tvar foo = new ClassB(\"World\", \"!?!\");\n * \tconsole.log(foo.greet()); // Hello World!?!\n *\n * @method promote\n * @param {Function} subclass The class to promote super class methods on.\n * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.\n * @return {Function} Returns the subclass.\n */\ncreatejs.promote = function(subclass, prefix) {\n\t\"use strict\";\n\n\tvar subP = subclass.prototype, supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;\n\tif (supP) {\n\t\tsubP[(prefix+=\"_\") + \"constructor\"] = supP.constructor; // constructor is not always innumerable\n\t\tfor (var n in supP) {\n\t\t\tif (subP.hasOwnProperty(n) && (typeof supP[n] == \"function\")) { subP[prefix + n] = supP[n]; }\n\t\t}\n\t}\n\treturn subclass;\n};\n\n//##############################################################################\n// indexOf.js\n//##############################################################################\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of\n * that value.  Returns -1 if value is not found.\n *\n *      var i = createjs.indexOf(myArray, myElementToFind);\n *\n * @method indexOf\n * @param {Array} array Array to search for searchElement\n * @param searchElement Element to find in array.\n * @return {Number} The first index of searchElement in array.\n */\ncreatejs.indexOf = function (array, searchElement){\n\t\"use strict\";\n\n\tfor (var i = 0,l=array.length; i < l; i++) {\n\t\tif (searchElement === array[i]) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\n//##############################################################################\n// Event.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n// constructor:\n\t/**\n\t * Contains properties and methods shared by all events for use with\n\t * {{#crossLink \"EventDispatcher\"}}{{/crossLink}}.\n\t * \n\t * Note that Event objects are often reused, so you should never\n\t * rely on an event object's state outside of the call stack it was received in.\n\t * @class Event\n\t * @param {String} type The event type.\n\t * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.\n\t * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.\n\t * @constructor\n\t **/\n\tfunction Event(type, bubbles, cancelable) {\n\t\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * The type of event.\n\t\t * @property type\n\t\t * @type String\n\t\t **/\n\t\tthis.type = type;\n\t\n\t\t/**\n\t\t * The object that generated an event.\n\t\t * @property target\n\t\t * @type Object\n\t\t * @default null\n\t\t * @readonly\n\t\t*/\n\t\tthis.target = null;\n\t\n\t\t/**\n\t\t * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will\n\t\t * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event\n\t\t * is generated from childObj, then a listener on parentObj would receive the event with\n\t\t * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).\n\t\t * @property currentTarget\n\t\t * @type Object\n\t\t * @default null\n\t\t * @readonly\n\t\t*/\n\t\tthis.currentTarget = null;\n\t\n\t\t/**\n\t\t * For bubbling events, this indicates the current event phase:<OL>\n\t\t * \t<LI> capture phase: starting from the top parent to the target</LI>\n\t\t * \t<LI> at target phase: currently being dispatched from the target</LI>\n\t\t * \t<LI> bubbling phase: from the target to the top parent</LI>\n\t\t * </OL>\n\t\t * @property eventPhase\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @readonly\n\t\t*/\n\t\tthis.eventPhase = 0;\n\t\n\t\t/**\n\t\t * Indicates whether the event will bubble through the display list.\n\t\t * @property bubbles\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.bubbles = !!bubbles;\n\t\n\t\t/**\n\t\t * Indicates whether the default behaviour of this event can be cancelled via\n\t\t * {{#crossLink \"Event/preventDefault\"}}{{/crossLink}}. This is set via the Event constructor.\n\t\t * @property cancelable\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.cancelable = !!cancelable;\n\t\n\t\t/**\n\t\t * The epoch time at which this event was created.\n\t\t * @property timeStamp\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @readonly\n\t\t*/\n\t\tthis.timeStamp = (new Date()).getTime();\n\t\n\t\t/**\n\t\t * Indicates if {{#crossLink \"Event/preventDefault\"}}{{/crossLink}} has been called\n\t\t * on this event.\n\t\t * @property defaultPrevented\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.defaultPrevented = false;\n\t\n\t\t/**\n\t\t * Indicates if {{#crossLink \"Event/stopPropagation\"}}{{/crossLink}} or\n\t\t * {{#crossLink \"Event/stopImmediatePropagation\"}}{{/crossLink}} has been called on this event.\n\t\t * @property propagationStopped\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.propagationStopped = false;\n\t\n\t\t/**\n\t\t * Indicates if {{#crossLink \"Event/stopImmediatePropagation\"}}{{/crossLink}} has been called\n\t\t * on this event.\n\t\t * @property immediatePropagationStopped\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.immediatePropagationStopped = false;\n\t\t\n\t\t/**\n\t\t * Indicates if {{#crossLink \"Event/remove\"}}{{/crossLink}} has been called on this event.\n\t\t * @property removed\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.removed = false;\n\t}\n\tvar p = Event.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n// public methods:\n\t/**\n\t * Sets {{#crossLink \"Event/defaultPrevented\"}}{{/crossLink}} to true if the event is cancelable.\n\t * Mirrors the DOM level 2 event standard. In general, cancelable events that have `preventDefault()` called will\n\t * cancel the default behaviour associated with the event.\n\t * @method preventDefault\n\t **/\n\tp.preventDefault = function() {\n\t\tthis.defaultPrevented = this.cancelable&&true;\n\t};\n\n\t/**\n\t * Sets {{#crossLink \"Event/propagationStopped\"}}{{/crossLink}} to true.\n\t * Mirrors the DOM event standard.\n\t * @method stopPropagation\n\t **/\n\tp.stopPropagation = function() {\n\t\tthis.propagationStopped = true;\n\t};\n\n\t/**\n\t * Sets {{#crossLink \"Event/propagationStopped\"}}{{/crossLink}} and\n\t * {{#crossLink \"Event/immediatePropagationStopped\"}}{{/crossLink}} to true.\n\t * Mirrors the DOM event standard.\n\t * @method stopImmediatePropagation\n\t **/\n\tp.stopImmediatePropagation = function() {\n\t\tthis.immediatePropagationStopped = this.propagationStopped = true;\n\t};\n\t\n\t/**\n\t * Causes the active listener to be removed via removeEventListener();\n\t * \n\t * \t\tmyBtn.addEventListener(\"click\", function(evt) {\n\t * \t\t\t// do stuff...\n\t * \t\t\tevt.remove(); // removes this listener.\n\t * \t\t});\n\t * \n\t * @method remove\n\t **/\n\tp.remove = function() {\n\t\tthis.removed = true;\n\t};\n\t\n\t/**\n\t * Returns a clone of the Event instance.\n\t * @method clone\n\t * @return {Event} a clone of the Event instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Event(this.type, this.bubbles, this.cancelable);\n\t};\n\t\n\t/**\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\n\t *\n\t * @method set\n\t * @param {Object} props A generic object containing properties to copy to the instance.\n\t * @return {Event} Returns the instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t*/\n\tp.set = function(props) {\n\t\tfor (var n in props) { this[n] = props[n]; }\n\t\treturn this;\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Event (type=\"+this.type+\")]\";\n\t};\n\n\tcreatejs.Event = Event;\n}());\n\n//##############################################################################\n// EventDispatcher.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * EventDispatcher provides methods for managing queues of event listeners and dispatching events.\n\t *\n\t * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the\n\t * EventDispatcher {{#crossLink \"EventDispatcher/initialize\"}}{{/crossLink}} method.\n\t * \n\t * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the\n\t * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports\n\t * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.\n\t * \n\t * EventDispatcher also exposes a {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}} method, which makes it easier\n\t * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The \n\t * {{#crossLink \"EventDispatcher/off\"}}{{/crossLink}} method is merely an alias to\n\t * {{#crossLink \"EventDispatcher/removeEventListener\"}}{{/crossLink}}.\n\t * \n\t * Another addition to the DOM Level 2 model is the {{#crossLink \"EventDispatcher/removeAllEventListeners\"}}{{/crossLink}}\n\t * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also \n\t * includes a {{#crossLink \"Event/remove\"}}{{/crossLink}} method which removes the active listener.\n\t *\n\t * <h4>Example</h4>\n\t * Add EventDispatcher capabilities to the \"MyClass\" class.\n\t *\n\t *      EventDispatcher.initialize(MyClass.prototype);\n\t *\n\t * Add an event (see {{#crossLink \"EventDispatcher/addEventListener\"}}{{/crossLink}}).\n\t *\n\t *      instance.addEventListener(\"eventName\", handlerMethod);\n\t *      function handlerMethod(event) {\n\t *          console.log(event.target + \" Was Clicked\");\n\t *      }\n\t *\n\t * <b>Maintaining proper scope</b><br />\n\t * Scope (ie. \"this\") can be be a challenge with events. Using the {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}}\n\t * method to subscribe to events simplifies this.\n\t *\n\t *      instance.addEventListener(\"click\", function(event) {\n\t *          console.log(instance == this); // false, scope is ambiguous.\n\t *      });\n\t *      \n\t *      instance.on(\"click\", function(event) {\n\t *          console.log(instance == this); // true, \"on\" uses dispatcher scope by default.\n\t *      });\n\t * \n\t * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage\n\t * scope.\n\t *\n\t * <b>Browser support</b>\n\t * The event model in CreateJS can be used separately from the suite in any project, however the inheritance model\n\t * requires modern browsers (IE9+).\n\t *      \n\t *\n\t * @class EventDispatcher\n\t * @constructor\n\t **/\n\tfunction EventDispatcher() {\n\t\n\t\n\t// private properties:\n\t\t/**\n\t\t * @protected\n\t\t * @property _listeners\n\t\t * @type Object\n\t\t **/\n\t\tthis._listeners = null;\n\t\t\n\t\t/**\n\t\t * @protected\n\t\t * @property _captureListeners\n\t\t * @type Object\n\t\t **/\n\t\tthis._captureListeners = null;\n\t}\n\tvar p = EventDispatcher.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// static public methods:\n\t/**\n\t * Static initializer to mix EventDispatcher methods into a target object or prototype.\n\t * \n\t * \t\tEventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class\n\t * \t\tEventDispatcher.initialize(myObject); // add to a specific instance\n\t * \n\t * @method initialize\n\t * @static\n\t * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a\n\t * prototype.\n\t **/\n\tEventDispatcher.initialize = function(target) {\n\t\ttarget.addEventListener = p.addEventListener;\n\t\ttarget.on = p.on;\n\t\ttarget.removeEventListener = target.off =  p.removeEventListener;\n\t\ttarget.removeAllEventListeners = p.removeAllEventListeners;\n\t\ttarget.hasEventListener = p.hasEventListener;\n\t\ttarget.dispatchEvent = p.dispatchEvent;\n\t\ttarget._dispatchEvent = p._dispatchEvent;\n\t\ttarget.willTrigger = p.willTrigger;\n\t};\n\t\n\n// public methods:\n\t/**\n\t * Adds the specified event listener. Note that adding multiple listeners to the same function will result in\n\t * multiple callbacks getting fired.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      displayObject.addEventListener(\"click\", handleClick);\n\t *      function handleClick(event) {\n\t *         // Click happened.\n\t *      }\n\t *\n\t * @method addEventListener\n\t * @param {String} type The string type of the event.\n\t * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when\n\t * the event is dispatched.\n\t * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t * @return {Function | Object} Returns the listener for chaining or assignment.\n\t **/\n\tp.addEventListener = function(type, listener, useCapture) {\n\t\tvar listeners;\n\t\tif (useCapture) {\n\t\t\tlisteners = this._captureListeners = this._captureListeners||{};\n\t\t} else {\n\t\t\tlisteners = this._listeners = this._listeners||{};\n\t\t}\n\t\tvar arr = listeners[type];\n\t\tif (arr) { this.removeEventListener(type, listener, useCapture); }\n\t\tarr = listeners[type]; // remove may have deleted the array\n\t\tif (!arr) { listeners[type] = [listener];  }\n\t\telse { arr.push(listener); }\n\t\treturn listener;\n\t};\n\t\n\t/**\n\t * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener\n\t * only run once, associate arbitrary data with the listener, and remove the listener.\n\t * \n\t * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.\n\t * The wrapper function is returned for use with `removeEventListener` (or `off`).\n\t * \n\t * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener, or use\n\t * {{#crossLink \"Event/remove\"}}{{/crossLink}}. Likewise, each time you call `on` a NEW wrapper function is subscribed, so multiple calls\n\t * to `on` with the same params will create multiple listeners.\n\t * \n\t * <h4>Example</h4>\n\t * \n\t * \t\tvar listener = myBtn.on(\"click\", handleClick, null, false, {count:3});\n\t * \t\tfunction handleClick(evt, data) {\n\t * \t\t\tdata.count -= 1;\n\t * \t\t\tconsole.log(this == myBtn); // true - scope defaults to the dispatcher\n\t * \t\t\tif (data.count == 0) {\n\t * \t\t\t\talert(\"clicked 3 times!\");\n\t * \t\t\t\tmyBtn.off(\"click\", listener);\n\t * \t\t\t\t// alternately: evt.remove();\n\t * \t\t\t}\n\t * \t\t}\n\t * \n\t * @method on\n\t * @param {String} type The string type of the event.\n\t * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when\n\t * the event is dispatched.\n\t * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).\n\t * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.\n\t * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.\n\t * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.\n\t **/\n\tp.on = function(type, listener, scope, once, data, useCapture) {\n\t\tif (listener.handleEvent) {\n\t\t\tscope = scope||listener;\n\t\t\tlistener = listener.handleEvent;\n\t\t}\n\t\tscope = scope||this;\n\t\treturn this.addEventListener(type, function(evt) {\n\t\t\t\tlistener.call(scope, evt, data);\n\t\t\t\tonce&&evt.remove();\n\t\t\t}, useCapture);\n\t};\n\n\t/**\n\t * Removes the specified event listener.\n\t *\n\t * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy\n\t * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or\n\t * closure will not work.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      displayObject.removeEventListener(\"click\", handleClick);\n\t *\n\t * @method removeEventListener\n\t * @param {String} type The string type of the event.\n\t * @param {Function | Object} listener The listener function or object.\n\t * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t **/\n\tp.removeEventListener = function(type, listener, useCapture) {\n\t\tvar listeners = useCapture ? this._captureListeners : this._listeners;\n\t\tif (!listeners) { return; }\n\t\tvar arr = listeners[type];\n\t\tif (!arr) { return; }\n\t\tfor (var i=0,l=arr.length; i<l; i++) {\n\t\t\tif (arr[i] == listener) {\n\t\t\t\tif (l==1) { delete(listeners[type]); } // allows for faster checks.\n\t\t\t\telse { arr.splice(i,1); }\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\t\n\t/**\n\t * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the\n\t * .on method.\n\t * \n\t * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener. See \n\t * {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}} for an example.\n\t *\n\t * @method off\n\t * @param {String} type The string type of the event.\n\t * @param {Function | Object} listener The listener function or object.\n\t * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t **/\n\tp.off = p.removeEventListener;\n\n\t/**\n\t * Removes all listeners for the specified type, or all listeners of all types.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      // Remove all listeners\n\t *      displayObject.removeAllEventListeners();\n\t *\n\t *      // Remove all click listeners\n\t *      displayObject.removeAllEventListeners(\"click\");\n\t *\n\t * @method removeAllEventListeners\n\t * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.\n\t **/\n\tp.removeAllEventListeners = function(type) {\n\t\tif (!type) { this._listeners = this._captureListeners = null; }\n\t\telse {\n\t\t\tif (this._listeners) { delete(this._listeners[type]); }\n\t\t\tif (this._captureListeners) { delete(this._captureListeners[type]); }\n\t\t}\n\t};\n\n\t/**\n\t * Dispatches the specified event to all listeners.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      // Use a string event\n\t *      this.dispatchEvent(\"complete\");\n\t *\n\t *      // Use an Event instance\n\t *      var event = new createjs.Event(\"progress\");\n\t *      this.dispatchEvent(event);\n\t *\n\t * @method dispatchEvent\n\t * @param {Object | String | Event} eventObj An object with a \"type\" property, or a string type.\n\t * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,\n\t * dispatchEvent will construct an Event instance if necessary with the specified type. This latter approach can\n\t * be used to avoid event object instantiation for non-bubbling events that may not have any listeners.\n\t * @param {Boolean} [bubbles] Specifies the `bubbles` value when a string was passed to eventObj.\n\t * @param {Boolean} [cancelable] Specifies the `cancelable` value when a string was passed to eventObj.\n\t * @return {Boolean} Returns false if `preventDefault()` was called on a cancelable event, true otherwise.\n\t **/\n\tp.dispatchEvent = function(eventObj, bubbles, cancelable) {\n\t\tif (typeof eventObj == \"string\") {\n\t\t\t// skip everything if there's no listeners and it doesn't bubble:\n\t\t\tvar listeners = this._listeners;\n\t\t\tif (!bubbles && (!listeners || !listeners[eventObj])) { return true; }\n\t\t\teventObj = new createjs.Event(eventObj, bubbles, cancelable);\n\t\t} else if (eventObj.target && eventObj.clone) {\n\t\t\t// redispatching an active event object, so clone it:\n\t\t\teventObj = eventObj.clone();\n\t\t}\n\t\t\n\t\t// TODO: it would be nice to eliminate this. Maybe in favour of evtObj instanceof Event? Or !!evtObj.createEvent\n\t\ttry { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events\n\n\t\tif (!eventObj.bubbles || !this.parent) {\n\t\t\tthis._dispatchEvent(eventObj, 2);\n\t\t} else {\n\t\t\tvar top=this, list=[top];\n\t\t\twhile (top.parent) { list.push(top = top.parent); }\n\t\t\tvar i, l=list.length;\n\n\t\t\t// capture & atTarget\n\t\t\tfor (i=l-1; i>=0 && !eventObj.propagationStopped; i--) {\n\t\t\t\tlist[i]._dispatchEvent(eventObj, 1+(i==0));\n\t\t\t}\n\t\t\t// bubbling\n\t\t\tfor (i=1; i<l && !eventObj.propagationStopped; i++) {\n\t\t\t\tlist[i]._dispatchEvent(eventObj, 3);\n\t\t\t}\n\t\t}\n\t\treturn !eventObj.defaultPrevented;\n\t};\n\n\t/**\n\t * Indicates whether there is at least one listener for the specified event type.\n\t * @method hasEventListener\n\t * @param {String} type The string type of the event.\n\t * @return {Boolean} Returns true if there is at least one listener for the specified event.\n\t **/\n\tp.hasEventListener = function(type) {\n\t\tvar listeners = this._listeners, captureListeners = this._captureListeners;\n\t\treturn !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));\n\t};\n\t\n\t/**\n\t * Indicates whether there is at least one listener for the specified event type on this object or any of its\n\t * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the\n\t * specified type is dispatched from this object, it will trigger at least one listener.\n\t * \n\t * This is similar to {{#crossLink \"EventDispatcher/hasEventListener\"}}{{/crossLink}}, but it searches the entire\n\t * event flow for a listener, not just this object.\n\t * @method willTrigger\n\t * @param {String} type The string type of the event.\n\t * @return {Boolean} Returns `true` if there is at least one listener for the specified event.\n\t **/\n\tp.willTrigger = function(type) {\n\t\tvar o = this;\n\t\twhile (o) {\n\t\t\tif (o.hasEventListener(type)) { return true; }\n\t\t\to = o.parent;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[EventDispatcher]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _dispatchEvent\n\t * @param {Object | String | Event} eventObj\n\t * @param {Object} eventPhase\n\t * @protected\n\t **/\n\tp._dispatchEvent = function(eventObj, eventPhase) {\n\t\tvar l, listeners = (eventPhase==1) ? this._captureListeners : this._listeners;\n\t\tif (eventObj && listeners) {\n\t\t\tvar arr = listeners[eventObj.type];\n\t\t\tif (!arr||!(l=arr.length)) { return; }\n\t\t\ttry { eventObj.currentTarget = this; } catch (e) {}\n\t\t\ttry { eventObj.eventPhase = eventPhase; } catch (e) {}\n\t\t\teventObj.removed = false;\n\t\t\t\n\t\t\tarr = arr.slice(); // to avoid issues with items being removed or added during the dispatch\n\t\t\tfor (var i=0; i<l && !eventObj.immediatePropagationStopped; i++) {\n\t\t\t\tvar o = arr[i];\n\t\t\t\tif (o.handleEvent) { o.handleEvent(eventObj); }\n\t\t\t\telse { o(eventObj); }\n\t\t\t\tif (eventObj.removed) {\n\t\t\t\t\tthis.off(eventObj.type, o, eventPhase==1);\n\t\t\t\t\teventObj.removed = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\n\tcreatejs.EventDispatcher = EventDispatcher;\n}());\n\n//##############################################################################\n// Ticker.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * The Ticker provides a centralized tick or heartbeat broadcast at a set interval. Listeners can subscribe to the tick\n\t * event to be notified when a set time interval has elapsed.\n\t *\n\t * Note that the interval that the tick event is called is a target interval, and may be broadcast at a slower interval\n\t * when under high CPU load. The Ticker class uses a static interface (ex. `Ticker.framerate = 30;`) and\n\t * can not be instantiated.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n\t *      function handleTick(event) {\n\t *          // Actions carried out each tick (aka frame)\n\t *          if (!event.paused) {\n\t *              // Actions carried out when the Ticker is not paused.\n\t *          }\n\t *      }\n\t *\n\t * @class Ticker\n\t * @uses EventDispatcher\n\t * @static\n\t **/\n\tfunction Ticker() {\n\t\tthrow \"Ticker cannot be instantiated.\";\n\t}\n\n\n// constants:\n\t/**\n\t * In this mode, Ticker uses the requestAnimationFrame API, but attempts to synch the ticks to target framerate. It\n\t * uses a simple heuristic that compares the time of the RAF return to the target time for the current frame and\n\t * dispatches the tick when the time is within a certain threshold.\n\t *\n\t * This mode has a higher variance for time between frames than {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}},\n\t * but does not require that content be time based as with {{#crossLink \"Ticker/RAF:property\"}}{{/crossLink}} while\n\t * gaining the benefits of that API (screen synch, background throttling).\n\t *\n\t * Variance is usually lowest for framerates that are a divisor of the RAF frequency. This is usually 60, so\n\t * framerates of 10, 12, 15, 20, and 30 work well.\n\t *\n\t * Falls back to {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}} if the requestAnimationFrame API is not\n\t * supported.\n\t * @property RAF_SYNCHED\n\t * @static\n\t * @type {String}\n\t * @default \"synched\"\n\t * @readonly\n\t **/\n\tTicker.RAF_SYNCHED = \"synched\";\n\n\t/**\n\t * In this mode, Ticker passes through the requestAnimationFrame heartbeat, ignoring the target framerate completely.\n\t * Because requestAnimationFrame frequency is not deterministic, any content using this mode should be time based.\n\t * You can leverage {{#crossLink \"Ticker/getTime\"}}{{/crossLink}} and the {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}}\n\t * event object's \"delta\" properties to make this easier.\n\t *\n\t * Falls back on {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}} if the requestAnimationFrame API is not\n\t * supported.\n\t * @property RAF\n\t * @static\n\t * @type {String}\n\t * @default \"raf\"\n\t * @readonly\n\t **/\n\tTicker.RAF = \"raf\";\n\n\t/**\n\t * In this mode, Ticker uses the setTimeout API. This provides predictable, adaptive frame timing, but does not\n\t * provide the benefits of requestAnimationFrame (screen synch, background throttling).\n\t * @property TIMEOUT\n\t * @static\n\t * @type {String}\n\t * @default \"timeout\"\n\t * @readonly\n\t **/\n\tTicker.TIMEOUT = \"timeout\";\n\n\n// static events:\n\t/**\n\t * Dispatched each tick. The event will be dispatched to each listener even when the Ticker has been paused using\n\t * {{#crossLink \"Ticker/setPaused\"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n\t *      function handleTick(event) {\n\t *          console.log(\"Paused:\", event.paused, event.delta);\n\t *      }\n\t *\n\t * @event tick\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Boolean} paused Indicates whether the ticker is currently paused.\n\t * @param {Number} delta The time elapsed in ms since the last tick.\n\t * @param {Number} time The total time in ms since Ticker was initialized.\n\t * @param {Number} runTime The total time in ms that Ticker was not paused since it was initialized. For example,\n\t * \tyou could determine the amount of time that the Ticker has been paused since initialization with `time-runTime`.\n\t * @since 0.6.0\n\t */\n\n\n// public static properties:\n\t/**\n\t * Deprecated in favour of {{#crossLink \"Ticker/timingMode\"}}{{/crossLink}}, and will be removed in a future version. If true, timingMode will\n\t * use {{#crossLink \"Ticker/RAF_SYNCHED\"}}{{/crossLink}} by default.\n\t * @deprecated Deprecated in favour of {{#crossLink \"Ticker/timingMode\"}}{{/crossLink}}.\n\t * @property useRAF\n\t * @static\n\t * @type {Boolean}\n\t * @default false\n\t **/\n\tTicker.useRAF = false;\n\n\t/**\n\t * Specifies the timing api (setTimeout or requestAnimationFrame) and mode to use. See\n\t * {{#crossLink \"Ticker/TIMEOUT\"}}{{/crossLink}}, {{#crossLink \"Ticker/RAF\"}}{{/crossLink}}, and\n\t * {{#crossLink \"Ticker/RAF_SYNCHED\"}}{{/crossLink}} for mode details.\n\t * @property timingMode\n\t * @static\n\t * @type {String}\n\t * @default Ticker.TIMEOUT\n\t **/\n\tTicker.timingMode = null;\n\n\t/**\n\t * Specifies a maximum value for the delta property in the tick event object. This is useful when building time\n\t * based animations and systems to prevent issues caused by large time gaps caused by background tabs, system sleep,\n\t * alert dialogs, or other blocking routines. Double the expected frame duration is often an effective value\n\t * (ex. maxDelta=50 when running at 40fps).\n\t * \n\t * This does not impact any other values (ex. time, runTime, etc), so you may experience issues if you enable maxDelta\n\t * when using both delta and other values.\n\t * \n\t * If 0, there is no maximum.\n\t * @property maxDelta\n\t * @static\n\t * @type {number}\n\t * @default 0\n\t */\n\tTicker.maxDelta = 0;\n\t\n\t/**\n\t * When the ticker is paused, all listeners will still receive a tick event, but the <code>paused</code> property\n\t * of the event will be `true`. Also, while paused the `runTime` will not increase. See {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}},\n\t * {{#crossLink \"Ticker/getTime\"}}{{/crossLink}}, and {{#crossLink \"Ticker/getEventTime\"}}{{/crossLink}} for more\n\t * info.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n\t *      createjs.Ticker.paused = true;\n\t *      function handleTick(event) {\n\t *          console.log(event.paused,\n\t *          \tcreatejs.Ticker.getTime(false),\n\t *          \tcreatejs.Ticker.getTime(true));\n\t *      }\n\t *\n\t * @property paused\n\t * @static\n\t * @type {Boolean}\n\t * @default false\n\t **/\n\tTicker.paused = false;\n\n\n// mix-ins:\n\t// EventDispatcher methods:\n\tTicker.removeEventListener = null;\n\tTicker.removeAllEventListeners = null;\n\tTicker.dispatchEvent = null;\n\tTicker.hasEventListener = null;\n\tTicker._listeners = null;\n\tcreatejs.EventDispatcher.initialize(Ticker); // inject EventDispatcher methods.\n\tTicker._addEventListener = Ticker.addEventListener;\n\tTicker.addEventListener = function() {\n\t\t!Ticker._inited&&Ticker.init();\n\t\treturn Ticker._addEventListener.apply(Ticker, arguments);\n\t};\n\n\n// private static properties:\n\t/**\n\t * @property _inited\n\t * @static\n\t * @type {Boolean}\n\t * @protected\n\t **/\n\tTicker._inited = false;\n\n\t/**\n\t * @property _startTime\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._startTime = 0;\n\n\t/**\n\t * @property _pausedTime\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._pausedTime=0;\n\n\t/**\n\t * The number of ticks that have passed\n\t * @property _ticks\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._ticks = 0;\n\n\t/**\n\t * The number of ticks that have passed while Ticker has been paused\n\t * @property _pausedTicks\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._pausedTicks = 0;\n\n\t/**\n\t * @property _interval\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._interval = 50;\n\n\t/**\n\t * @property _lastTime\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._lastTime = 0;\n\n\t/**\n\t * @property _times\n\t * @static\n\t * @type {Array}\n\t * @protected\n\t **/\n\tTicker._times = null;\n\n\t/**\n\t * @property _tickTimes\n\t * @static\n\t * @type {Array}\n\t * @protected\n\t **/\n\tTicker._tickTimes = null;\n\n\t/**\n\t * Stores the timeout or requestAnimationFrame id.\n\t * @property _timerId\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._timerId = null;\n\t\n\t/**\n\t * True if currently using requestAnimationFrame, false if using setTimeout. This may be different than timingMode\n\t * if that property changed and a tick hasn't fired.\n\t * @property _raf\n\t * @static\n\t * @type {Boolean}\n\t * @protected\n\t **/\n\tTicker._raf = true;\n\t\n\n// static getter / setters:\n\t/**\n\t * Use the {{#crossLink \"Ticker/interval:property\"}}{{/crossLink}} property instead.\n\t * @method setInterval\n\t * @static\n\t * @param {Number} interval\n\t * @deprecated\n\t **/\n\tTicker.setInterval = function(interval) {\n\t\tTicker._interval = interval;\n\t\tif (!Ticker._inited) { return; }\n\t\tTicker._setupTick();\n\t};\n\n\t/**\n\t * Use the {{#crossLink \"Ticker/interval:property\"}}{{/crossLink}} property instead.\n\t * @method getInterval\n\t * @static\n\t * @return {Number}\n\t * @deprecated\n\t **/\n\tTicker.getInterval = function() {\n\t\treturn Ticker._interval;\n\t};\n\n\t/**\n\t * Use the {{#crossLink \"Ticker/framerate:property\"}}{{/crossLink}} property instead.\n\t * @method setFPS\n\t * @static\n\t * @param {Number} value\n\t * @deprecated\n\t **/\n\tTicker.setFPS = function(value) {\n\t\tTicker.setInterval(1000/value);\n\t};\n\n\t/**\n\t * Use the {{#crossLink \"Ticker/framerate:property\"}}{{/crossLink}} property instead.\n\t * @method getFPS\n\t * @static\n\t * @return {Number}\n\t * @deprecated\n\t **/\n\tTicker.getFPS = function() {\n\t\treturn 1000/Ticker._interval;\n\t};\n\n\t/**\n\t * Indicates the target time (in milliseconds) between ticks. Default is 50 (20 FPS).\n\t * Note that actual time between ticks may be more than specified depending on CPU load.\n\t * This property is ignored if the ticker is using the `RAF` timing mode.\n\t * @property interval\n\t * @static\n\t * @type {Number}\n\t **/\n\t \n\t/**\n\t * Indicates the target frame rate in frames per second (FPS). Effectively just a shortcut to `interval`, where\n\t * `framerate == 1000/interval`.\n\t * @property framerate\n\t * @static\n\t * @type {Number}\n\t **/\n\ttry {\n\t\tObject.defineProperties(Ticker, {\n\t\t\tinterval: { get: Ticker.getInterval, set: Ticker.setInterval },\n\t\t\tframerate: { get: Ticker.getFPS, set: Ticker.setFPS }\n\t\t});\n\t} catch (e) { console.log(e); }\n\n\n// public static methods:\n\t/**\n\t * Starts the tick. This is called automatically when the first listener is added.\n\t * @method init\n\t * @static\n\t **/\n\tTicker.init = function() {\n\t\tif (Ticker._inited) { return; }\n\t\tTicker._inited = true;\n\t\tTicker._times = [];\n\t\tTicker._tickTimes = [];\n\t\tTicker._startTime = Ticker._getTime();\n\t\tTicker._times.push(Ticker._lastTime = 0);\n\t\tTicker.interval = Ticker._interval;\n\t};\n\t\n\t/**\n\t * Stops the Ticker and removes all listeners. Use init() to restart the Ticker.\n\t * @method reset\n\t * @static\n\t **/\n\tTicker.reset = function() {\n\t\tif (Ticker._raf) {\n\t\t\tvar f = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;\n\t\t\tf&&f(Ticker._timerId);\n\t\t} else {\n\t\t\tclearTimeout(Ticker._timerId);\n\t\t}\n\t\tTicker.removeAllEventListeners(\"tick\");\n\t\tTicker._timerId = Ticker._times = Ticker._tickTimes = null;\n\t\tTicker._startTime = Ticker._lastTime = Ticker._ticks = 0;\n\t\tTicker._inited = false;\n\t};\n\n\t/**\n\t * Returns the average time spent within a tick. This can vary significantly from the value provided by getMeasuredFPS\n\t * because it only measures the time spent within the tick execution stack. \n\t * \n\t * Example 1: With a target FPS of 20, getMeasuredFPS() returns 20fps, which indicates an average of 50ms between \n\t * the end of one tick and the end of the next. However, getMeasuredTickTime() returns 15ms. This indicates that \n\t * there may be up to 35ms of \"idle\" time between the end of one tick and the start of the next.\n\t *\n\t * Example 2: With a target FPS of 30, getFPS() returns 10fps, which indicates an average of 100ms between the end of\n\t * one tick and the end of the next. However, getMeasuredTickTime() returns 20ms. This would indicate that something\n\t * other than the tick is using ~80ms (another script, DOM rendering, etc).\n\t * @method getMeasuredTickTime\n\t * @static\n\t * @param {Number} [ticks] The number of previous ticks over which to measure the average time spent in a tick.\n\t * Defaults to the number of ticks per second. To get only the last tick's time, pass in 1.\n\t * @return {Number} The average time spent in a tick in milliseconds.\n\t **/\n\tTicker.getMeasuredTickTime = function(ticks) {\n\t\tvar ttl=0, times=Ticker._tickTimes;\n\t\tif (!times || times.length < 1) { return -1; }\n\n\t\t// by default, calculate average for the past ~1 second:\n\t\tticks = Math.min(times.length, ticks||(Ticker.getFPS()|0));\n\t\tfor (var i=0; i<ticks; i++) { ttl += times[i]; }\n\t\treturn ttl/ticks;\n\t};\n\n\t/**\n\t * Returns the actual frames / ticks per second.\n\t * @method getMeasuredFPS\n\t * @static\n\t * @param {Number} [ticks] The number of previous ticks over which to measure the actual frames / ticks per second.\n\t * Defaults to the number of ticks per second.\n\t * @return {Number} The actual frames / ticks per second. Depending on performance, this may differ\n\t * from the target frames per second.\n\t **/\n\tTicker.getMeasuredFPS = function(ticks) {\n\t\tvar times = Ticker._times;\n\t\tif (!times || times.length < 2) { return -1; }\n\n\t\t// by default, calculate fps for the past ~1 second:\n\t\tticks = Math.min(times.length-1, ticks||(Ticker.getFPS()|0));\n\t\treturn 1000/((times[0]-times[ticks])/ticks);\n\t};\n\n\t/**\n\t * Use the {{#crossLink \"Ticker/paused:property\"}}{{/crossLink}} property instead.\n\t * @method setPaused\n\t * @static\n\t * @param {Boolean} value\n\t * @deprecated\n\t **/\n\tTicker.setPaused = function(value) {\n\t\t// TODO: deprecated.\n\t\tTicker.paused = value;\n\t};\n\n\t/**\n\t * Use the {{#crossLink \"Ticker/paused:property\"}}{{/crossLink}} property instead.\n\t * @method getPaused\n\t * @static\n\t * @return {Boolean}\n\t * @deprecated\n\t **/\n\tTicker.getPaused = function() {\n\t\t// TODO: deprecated.\n\t\treturn Ticker.paused;\n\t};\n\n\t/**\n\t * Returns the number of milliseconds that have elapsed since Ticker was initialized via {{#crossLink \"Ticker/init\"}}.\n\t * Returns -1 if Ticker has not been initialized. For example, you could use\n\t * this in a time synchronized animation to determine the exact amount of time that has elapsed.\n\t * @method getTime\n\t * @static\n\t * @param {Boolean} [runTime=false] If true only time elapsed while Ticker was not paused will be returned.\n\t * If false, the value returned will be total time elapsed since the first tick event listener was added.\n\t * @return {Number} Number of milliseconds that have elapsed since Ticker was initialized or -1.\n\t **/\n\tTicker.getTime = function(runTime) {\n\t\treturn Ticker._startTime ? Ticker._getTime() - (runTime ? Ticker._pausedTime : 0) : -1;\n\t};\n\n\t/**\n\t * Similar to the {{#crossLink \"Ticker/getTime\"}}{{/crossLink}} method, but returns the time on the most recent {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}}\n\t * event object.\n\t * @method getEventTime\n\t * @static\n\t * @param runTime {Boolean} [runTime=false] If true, the runTime property will be returned instead of time.\n\t * @returns {number} The time or runTime property from the most recent tick event or -1.\n\t */\n\tTicker.getEventTime = function(runTime) {\n\t\treturn Ticker._startTime ? (Ticker._lastTime || Ticker._startTime) - (runTime ? Ticker._pausedTime : 0) : -1;\n\t};\n\t\n\t/**\n\t * Returns the number of ticks that have been broadcast by Ticker.\n\t * @method getTicks\n\t * @static\n\t * @param {Boolean} pauseable Indicates whether to include ticks that would have been broadcast\n\t * while Ticker was paused. If true only tick events broadcast while Ticker is not paused will be returned.\n\t * If false, tick events that would have been broadcast while Ticker was paused will be included in the return\n\t * value. The default value is false.\n\t * @return {Number} of ticks that have been broadcast.\n\t **/\n\tTicker.getTicks = function(pauseable) {\n\t\treturn  Ticker._ticks - (pauseable ? Ticker._pausedTicks : 0);\n\t};\n\n\n// private static methods:\n\t/**\n\t * @method _handleSynch\n\t * @static\n\t * @protected\n\t **/\n\tTicker._handleSynch = function() {\n\t\tTicker._timerId = null;\n\t\tTicker._setupTick();\n\n\t\t// run if enough time has elapsed, with a little bit of flexibility to be early:\n\t\tif (Ticker._getTime() - Ticker._lastTime >= (Ticker._interval-1)*0.97) {\n\t\t\tTicker._tick();\n\t\t}\n\t};\n\n\t/**\n\t * @method _handleRAF\n\t * @static\n\t * @protected\n\t **/\n\tTicker._handleRAF = function() {\n\t\tTicker._timerId = null;\n\t\tTicker._setupTick();\n\t\tTicker._tick();\n\t};\n\n\t/**\n\t * @method _handleTimeout\n\t * @static\n\t * @protected\n\t **/\n\tTicker._handleTimeout = function() {\n\t\tTicker._timerId = null;\n\t\tTicker._setupTick();\n\t\tTicker._tick();\n\t};\n\n\t/**\n\t * @method _setupTick\n\t * @static\n\t * @protected\n\t **/\n\tTicker._setupTick = function() {\n\t\tif (Ticker._timerId != null) { return; } // avoid duplicates\n\n\t\tvar mode = Ticker.timingMode||(Ticker.useRAF&&Ticker.RAF_SYNCHED);\n\t\tif (mode == Ticker.RAF_SYNCHED || mode == Ticker.RAF) {\n\t\t\tvar f = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;\n\t\t\tif (f) {\n\t\t\t\tTicker._timerId = f(mode == Ticker.RAF ? Ticker._handleRAF : Ticker._handleSynch);\n\t\t\t\tTicker._raf = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tTicker._raf = false;\n\t\tTicker._timerId = setTimeout(Ticker._handleTimeout, Ticker._interval);\n\t};\n\n\t/**\n\t * @method _tick\n\t * @static\n\t * @protected\n\t **/\n\tTicker._tick = function() {\n\t\tvar paused = Ticker.paused;\n\t\tvar time = Ticker._getTime();\n\t\tvar elapsedTime = time-Ticker._lastTime;\n\t\tTicker._lastTime = time;\n\t\tTicker._ticks++;\n\t\t\n\t\tif (paused) {\n\t\t\tTicker._pausedTicks++;\n\t\t\tTicker._pausedTime += elapsedTime;\n\t\t}\n\t\t\n\t\tif (Ticker.hasEventListener(\"tick\")) {\n\t\t\tvar event = new createjs.Event(\"tick\");\n\t\t\tvar maxDelta = Ticker.maxDelta;\n\t\t\tevent.delta = (maxDelta && elapsedTime > maxDelta) ? maxDelta : elapsedTime;\n\t\t\tevent.paused = paused;\n\t\t\tevent.time = time;\n\t\t\tevent.runTime = time-Ticker._pausedTime;\n\t\t\tTicker.dispatchEvent(event);\n\t\t}\n\t\t\n\t\tTicker._tickTimes.unshift(Ticker._getTime()-time);\n\t\twhile (Ticker._tickTimes.length > 100) { Ticker._tickTimes.pop(); }\n\n\t\tTicker._times.unshift(time);\n\t\twhile (Ticker._times.length > 100) { Ticker._times.pop(); }\n\t};\n\n\t/**\n\t * @method _getTime\n\t * @static\n\t * @protected\n\t **/\n\tvar now = window.performance && (performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow);\n\tTicker._getTime = function() {\n\t\treturn ((now&&now.call(performance))||(new Date().getTime())) - Ticker._startTime;\n\t};\n\n\n\tcreatejs.Ticker = Ticker;\n}());\n\n//##############################################################################\n// UID.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Global utility for generating sequential unique ID numbers. The UID class uses a static interface (ex. <code>UID.get()</code>)\n\t * and should not be instantiated.\n\t * @class UID\n\t * @static\n\t **/\n\tfunction UID() {\n\t\tthrow \"UID cannot be instantiated\";\n\t}\n\n\n// private static properties:\n\t/**\n\t * @property _nextID\n\t * @type Number\n\t * @protected\n\t **/\n\tUID._nextID = 0;\n\n\n// public static methods:\n\t/**\n\t * Returns the next unique id.\n\t * @method get\n\t * @return {Number} The next unique id\n\t * @static\n\t **/\n\tUID.get = function() {\n\t\treturn UID._nextID++;\n\t};\n\n\n\tcreatejs.UID = UID;\n}());\n\n//##############################################################################\n// MouseEvent.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Passed as the parameter to all mouse/pointer/touch related events. For a listing of mouse events and their properties,\n\t * see the {{#crossLink \"DisplayObject\"}}{{/crossLink}} and {{#crossLink \"Stage\"}}{{/crossLink}} event listings.\n\t * @class MouseEvent\n\t * @param {String} type The event type.\n\t * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.\n\t * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.\n\t * @param {Number} stageX The normalized x position relative to the stage.\n\t * @param {Number} stageY The normalized y position relative to the stage.\n\t * @param {MouseEvent} nativeEvent The native DOM event related to this mouse event.\n\t * @param {Number} pointerID The unique id for the pointer.\n\t * @param {Boolean} primary Indicates whether this is the primary pointer in a multitouch environment.\n\t * @param {Number} rawX The raw x position relative to the stage.\n\t * @param {Number} rawY The raw y position relative to the stage.\n\t * @param {DisplayObject} relatedTarget The secondary target for the event.\n\t * @extends Event\n\t * @constructor\n\t **/\n\tfunction MouseEvent(type, bubbles, cancelable, stageX, stageY, nativeEvent, pointerID, primary, rawX, rawY, relatedTarget) {\n\t\tthis.Event_constructor(type, bubbles, cancelable);\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The normalized x position on the stage. This will always be within the range 0 to stage width.\n\t\t * @property stageX\n\t\t * @type Number\n\t\t*/\n\t\tthis.stageX = stageX;\n\t\n\t\t/**\n\t\t * The normalized y position on the stage. This will always be within the range 0 to stage height.\n\t\t * @property stageY\n\t\t * @type Number\n\t\t **/\n\t\tthis.stageY = stageY;\n\t\n\t\t/**\n\t\t * The raw x position relative to the stage. Normally this will be the same as the stageX value, unless\n\t\t * stage.mouseMoveOutside is true and the pointer is outside of the stage bounds.\n\t\t * @property rawX\n\t\t * @type Number\n\t\t*/\n\t\tthis.rawX = (rawX==null)?stageX:rawX;\n\t\n\t\t/**\n\t\t * The raw y position relative to the stage. Normally this will be the same as the stageY value, unless\n\t\t * stage.mouseMoveOutside is true and the pointer is outside of the stage bounds.\n\t\t * @property rawY\n\t\t * @type Number\n\t\t*/\n\t\tthis.rawY = (rawY==null)?stageY:rawY;\n\t\n\t\t/**\n\t\t * The native MouseEvent generated by the browser. The properties and API for this\n\t\t * event may differ between browsers. This property will be null if the\n\t\t * EaselJS property was not directly generated from a native MouseEvent.\n\t\t * @property nativeEvent\n\t\t * @type HtmlMouseEvent\n\t\t * @default null\n\t\t **/\n\t\tthis.nativeEvent = nativeEvent;\n\t\n\t\t/**\n\t\t * The unique id for the pointer (touch point or cursor). This will be either -1 for the mouse, or the system\n\t\t * supplied id value.\n\t\t * @property pointerID\n\t\t * @type {Number}\n\t\t */\n\t\tthis.pointerID = pointerID;\n\t\n\t\t/**\n\t\t * Indicates whether this is the primary pointer in a multitouch environment. This will always be true for the mouse.\n\t\t * For touch pointers, the first pointer in the current stack will be considered the primary pointer.\n\t\t * @property primary\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.primary = !!primary;\n\t\t\n\t\t/**\n\t\t * The secondary target for the event, if applicable. This is used for mouseout/rollout\n\t\t * events to indicate the object that the mouse entered from, mouseover/rollover for the object the mouse exited,\n\t\t * and stagemousedown/stagemouseup events for the object that was the under the cursor, if any.\n\t\t * \n\t\t * Only valid interaction targets will be returned (ie. objects with mouse listeners or a cursor set).\n\t\t * @property relatedTarget\n\t\t * @type {DisplayObject}\n\t\t */\n\t\tthis.relatedTarget = relatedTarget;\n\t}\n\tvar p = createjs.extend(MouseEvent, createjs.Event);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\t\n\t\n// getter / setters:\n\t/**\n\t * Returns the x position of the mouse in the local coordinate system of the current target (ie. the dispatcher).\n\t * @property localX\n\t * @type {Number}\n\t * @readonly\n\t */\n\tp._get_localX = function() {\n\t\treturn this.currentTarget.globalToLocal(this.rawX, this.rawY).x;\n\t};\n\t\n\t/**\n\t * Returns the y position of the mouse in the local coordinate system of the current target (ie. the dispatcher).\n\t * @property localY\n\t * @type {Number}\n\t * @readonly\n\t */\n\tp._get_localY = function() {\n\t\treturn this.currentTarget.globalToLocal(this.rawX, this.rawY).y;\n\t};\n\t\n\t/**\n\t * Indicates whether the event was generated by a touch input (versus a mouse input).\n\t * @property isTouch\n\t * @type {Boolean}\n\t * @readonly\n\t */\n\tp._get_isTouch = function() {\n\t\treturn this.pointerID !== -1;\n\t};\n\t\n\t\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tlocalX: { get: p._get_localX },\n\t\t\tlocalY: { get: p._get_localY },\n\t\t\tisTouch: { get: p._get_isTouch }\n\t\t});\n\t} catch (e) {} // TODO: use Log\n\n\n// public methods:\n\t/**\n\t * Returns a clone of the MouseEvent instance.\n\t * @method clone\n\t * @return {MouseEvent} a clone of the MouseEvent instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new MouseEvent(this.type, this.bubbles, this.cancelable, this.stageX, this.stageY, this.nativeEvent, this.pointerID, this.primary, this.rawX, this.rawY);\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[MouseEvent (type=\"+this.type+\" stageX=\"+this.stageX+\" stageY=\"+this.stageY+\")]\";\n\t};\n\n\n\tcreatejs.MouseEvent = createjs.promote(MouseEvent, \"Event\");\n}());\n\n//##############################################################################\n// Matrix2D.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Represents an affine transformation matrix, and provides tools for constructing and concatenating matrices.\n\t *\n\t * This matrix can be visualized as:\n\t *\n\t * \t[ a  c  tx\n\t * \t  b  d  ty\n\t * \t  0  0  1  ]\n\t *\n\t * Note the locations of b and c.\n\t *\n\t * @class Matrix2D\n\t * @param {Number} [a=1] Specifies the a property for the new matrix.\n\t * @param {Number} [b=0] Specifies the b property for the new matrix.\n\t * @param {Number} [c=0] Specifies the c property for the new matrix.\n\t * @param {Number} [d=1] Specifies the d property for the new matrix.\n\t * @param {Number} [tx=0] Specifies the tx property for the new matrix.\n\t * @param {Number} [ty=0] Specifies the ty property for the new matrix.\n\t * @constructor\n\t **/\n\tfunction Matrix2D(a, b, c, d, tx, ty) {\n\t\tthis.setValues(a,b,c,d,tx,ty);\n\t\t\n\t// public properties:\n\t\t// assigned in the setValues method.\n\t\t/**\n\t\t * Position (0, 0) in a 3x3 affine transformation matrix.\n\t\t * @property a\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Position (0, 1) in a 3x3 affine transformation matrix.\n\t\t * @property b\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Position (1, 0) in a 3x3 affine transformation matrix.\n\t\t * @property c\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Position (1, 1) in a 3x3 affine transformation matrix.\n\t\t * @property d\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Position (2, 0) in a 3x3 affine transformation matrix.\n\t\t * @property tx\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Position (2, 1) in a 3x3 affine transformation matrix.\n\t\t * @property ty\n\t\t * @type Number\n\t\t **/\n\t}\n\tvar p = Matrix2D.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// constants:\n\t/**\n\t * Multiplier for converting degrees to radians. Used internally by Matrix2D.\n\t * @property DEG_TO_RAD\n\t * @static\n\t * @final\n\t * @type Number\n\t * @readonly\n\t **/\n\tMatrix2D.DEG_TO_RAD = Math.PI/180;\n\n\n// static public properties:\n\t/**\n\t * An identity matrix, representing a null transformation.\n\t * @property identity\n\t * @static\n\t * @type Matrix2D\n\t * @readonly\n\t **/\n\tMatrix2D.identity = null; // set at bottom of class definition.\n\t\n\n// public methods:\n\t/**\n\t * Sets the specified values on this instance. \n\t * @method setValues\n\t * @param {Number} [a=1] Specifies the a property for the new matrix.\n\t * @param {Number} [b=0] Specifies the b property for the new matrix.\n\t * @param {Number} [c=0] Specifies the c property for the new matrix.\n\t * @param {Number} [d=1] Specifies the d property for the new matrix.\n\t * @param {Number} [tx=0] Specifies the tx property for the new matrix.\n\t * @param {Number} [ty=0] Specifies the ty property for the new matrix.\n\t * @return {Matrix2D} This instance. Useful for chaining method calls.\n\t*/\n\tp.setValues = function(a, b, c, d, tx, ty) {\n\t\t// don't forget to update docs in the constructor if these change:\n\t\tthis.a = (a == null) ? 1 : a;\n\t\tthis.b = b || 0;\n\t\tthis.c = c || 0;\n\t\tthis.d = (d == null) ? 1 : d;\n\t\tthis.tx = tx || 0;\n\t\tthis.ty = ty || 0;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Appends the specified matrix properties to this matrix. All parameters are required.\n\t * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.\n\t * @method append\n\t * @param {Number} a\n\t * @param {Number} b\n\t * @param {Number} c\n\t * @param {Number} d\n\t * @param {Number} tx\n\t * @param {Number} ty\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.append = function(a, b, c, d, tx, ty) {\n\t\tvar a1 = this.a;\n\t\tvar b1 = this.b;\n\t\tvar c1 = this.c;\n\t\tvar d1 = this.d;\n\t\tif (a != 1 || b != 0 || c != 0 || d != 1) {\n\t\t\tthis.a  = a1*a+c1*b;\n\t\t\tthis.b  = b1*a+d1*b;\n\t\t\tthis.c  = a1*c+c1*d;\n\t\t\tthis.d  = b1*c+d1*d;\n\t\t}\n\t\tthis.tx = a1*tx+c1*ty+this.tx;\n\t\tthis.ty = b1*tx+d1*ty+this.ty;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Prepends the specified matrix properties to this matrix.\n\t * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.\n\t * All parameters are required.\n\t * @method prepend\n\t * @param {Number} a\n\t * @param {Number} b\n\t * @param {Number} c\n\t * @param {Number} d\n\t * @param {Number} tx\n\t * @param {Number} ty\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.prepend = function(a, b, c, d, tx, ty) {\n\t\tvar a1 = this.a;\n\t\tvar c1 = this.c;\n\t\tvar tx1 = this.tx;\n\n\t\tthis.a  = a*a1+c*this.b;\n\t\tthis.b  = b*a1+d*this.b;\n\t\tthis.c  = a*c1+c*this.d;\n\t\tthis.d  = b*c1+d*this.d;\n\t\tthis.tx = a*tx1+c*this.ty+tx;\n\t\tthis.ty = b*tx1+d*this.ty+ty;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Appends the specified matrix to this matrix.\n\t * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.\n\t * @method appendMatrix\n\t * @param {Matrix2D} matrix\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.appendMatrix = function(matrix) {\n\t\treturn this.append(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\n\t};\n\n\t/**\n\t * Prepends the specified matrix to this matrix.\n\t * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.\n\t * For example, you could calculate the combined transformation for a child object using:\n\t * \n\t * \tvar o = myDisplayObject;\n\t * \tvar mtx = o.getMatrix();\n\t * \twhile (o = o.parent) {\n\t * \t\t// prepend each parent's transformation in turn:\n\t * \t\to.prependMatrix(o.getMatrix());\n\t * \t}\n\t * @method prependMatrix\n\t * @param {Matrix2D} matrix\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.prependMatrix = function(matrix) {\n\t\treturn this.prepend(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\n\t};\n\n\t/**\n\t * Generates matrix properties from the specified display object transform properties, and appends them to this matrix.\n\t * For example, you can use this to generate a matrix representing the transformations of a display object:\n\t * \n\t * \tvar mtx = new createjs.Matrix2D();\n\t * \tmtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);\n\t * @method appendTransform\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} scaleX\n\t * @param {Number} scaleY\n\t * @param {Number} rotation\n\t * @param {Number} skewX\n\t * @param {Number} skewY\n\t * @param {Number} regX Optional.\n\t * @param {Number} regY Optional.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.appendTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {\n\t\tif (rotation%360) {\n\t\t\tvar r = rotation*Matrix2D.DEG_TO_RAD;\n\t\t\tvar cos = Math.cos(r);\n\t\t\tvar sin = Math.sin(r);\n\t\t} else {\n\t\t\tcos = 1;\n\t\t\tsin = 0;\n\t\t}\n\n\t\tif (skewX || skewY) {\n\t\t\t// TODO: can this be combined into a single append operation?\n\t\t\tskewX *= Matrix2D.DEG_TO_RAD;\n\t\t\tskewY *= Matrix2D.DEG_TO_RAD;\n\t\t\tthis.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);\n\t\t\tthis.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);\n\t\t} else {\n\t\t\tthis.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);\n\t\t}\n\t\t\n\t\tif (regX || regY) {\n\t\t\t// append the registration offset:\n\t\t\tthis.tx -= regX*this.a+regY*this.c; \n\t\t\tthis.ty -= regX*this.b+regY*this.d;\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Generates matrix properties from the specified display object transform properties, and prepends them to this matrix.\n\t * For example, you could calculate the combined transformation for a child object using:\n\t * \n\t * \tvar o = myDisplayObject;\n\t * \tvar mtx = new createjs.Matrix2D();\n\t * \tdo  {\n\t * \t\t// prepend each parent's transformation in turn:\n\t * \t\tmtx.prependTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);\n\t * \t} while (o = o.parent);\n\t * \t\n\t * \tNote that the above example would not account for {{#crossLink \"DisplayObject/transformMatrix:property\"}}{{/crossLink}}\n\t * \tvalues. See {{#crossLink \"Matrix2D/prependMatrix\"}}{{/crossLink}} for an example that does.\n\t * @method prependTransform\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} scaleX\n\t * @param {Number} scaleY\n\t * @param {Number} rotation\n\t * @param {Number} skewX\n\t * @param {Number} skewY\n\t * @param {Number} regX Optional.\n\t * @param {Number} regY Optional.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.prependTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {\n\t\tif (rotation%360) {\n\t\t\tvar r = rotation*Matrix2D.DEG_TO_RAD;\n\t\t\tvar cos = Math.cos(r);\n\t\t\tvar sin = Math.sin(r);\n\t\t} else {\n\t\t\tcos = 1;\n\t\t\tsin = 0;\n\t\t}\n\n\t\tif (regX || regY) {\n\t\t\t// prepend the registration offset:\n\t\t\tthis.tx -= regX; this.ty -= regY;\n\t\t}\n\t\tif (skewX || skewY) {\n\t\t\t// TODO: can this be combined into a single prepend operation?\n\t\t\tskewX *= Matrix2D.DEG_TO_RAD;\n\t\t\tskewY *= Matrix2D.DEG_TO_RAD;\n\t\t\tthis.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);\n\t\t\tthis.prepend(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);\n\t\t} else {\n\t\t\tthis.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Applies a clockwise rotation transformation to the matrix.\n\t * @method rotate\n\t * @param {Number} angle The angle to rotate by, in degrees. To use a value in radians, multiply it by `180/Math.PI`.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.rotate = function(angle) {\n\t\tangle = angle*Matrix2D.DEG_TO_RAD;\n\t\tvar cos = Math.cos(angle);\n\t\tvar sin = Math.sin(angle);\n\n\t\tvar a1 = this.a;\n\t\tvar b1 = this.b;\n\n\t\tthis.a = a1*cos+this.c*sin;\n\t\tthis.b = b1*cos+this.d*sin;\n\t\tthis.c = -a1*sin+this.c*cos;\n\t\tthis.d = -b1*sin+this.d*cos;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Applies a skew transformation to the matrix.\n\t * @method skew\n\t * @param {Number} skewX The amount to skew horizontally in degrees. To use a value in radians, multiply it by `180/Math.PI`.\n\t * @param {Number} skewY The amount to skew vertically in degrees.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t*/\n\tp.skew = function(skewX, skewY) {\n\t\tskewX = skewX*Matrix2D.DEG_TO_RAD;\n\t\tskewY = skewY*Matrix2D.DEG_TO_RAD;\n\t\tthis.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), 0, 0);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Applies a scale transformation to the matrix.\n\t * @method scale\n\t * @param {Number} x The amount to scale horizontally. E.G. a value of 2 will double the size in the X direction, and 0.5 will halve it.\n\t * @param {Number} y The amount to scale vertically.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.scale = function(x, y) {\n\t\tthis.a *= x;\n\t\tthis.b *= x;\n\t\tthis.c *= y;\n\t\tthis.d *= y;\n\t\t//this.tx *= x;\n\t\t//this.ty *= y;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Translates the matrix on the x and y axes.\n\t * @method translate\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.translate = function(x, y) {\n\t\tthis.tx += this.a*x + this.c*y;\n\t\tthis.ty += this.b*x + this.d*y;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Sets the properties of the matrix to those of an identity matrix (one that applies a null transformation).\n\t * @method identity\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.identity = function() {\n\t\tthis.a = this.d = 1;\n\t\tthis.b = this.c = this.tx = this.ty = 0;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Inverts the matrix, causing it to perform the opposite transformation.\n\t * @method invert\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.invert = function() {\n\t\tvar a1 = this.a;\n\t\tvar b1 = this.b;\n\t\tvar c1 = this.c;\n\t\tvar d1 = this.d;\n\t\tvar tx1 = this.tx;\n\t\tvar n = a1*d1-b1*c1;\n\n\t\tthis.a = d1/n;\n\t\tthis.b = -b1/n;\n\t\tthis.c = -c1/n;\n\t\tthis.d = a1/n;\n\t\tthis.tx = (c1*this.ty-d1*tx1)/n;\n\t\tthis.ty = -(a1*this.ty-b1*tx1)/n;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Returns true if the matrix is an identity matrix.\n\t * @method isIdentity\n\t * @return {Boolean}\n\t **/\n\tp.isIdentity = function() {\n\t\treturn this.tx === 0 && this.ty === 0 && this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1;\n\t};\n\t\n\t/**\n\t * Returns true if this matrix is equal to the specified matrix (all property values are equal).\n\t * @method equals\n\t * @param {Matrix2D} matrix The matrix to compare.\n\t * @return {Boolean}\n\t **/\n\tp.equals = function(matrix) {\n\t\treturn this.tx === matrix.tx && this.ty === matrix.ty && this.a === matrix.a && this.b === matrix.b && this.c === matrix.c && this.d === matrix.d;\n\t};\n\n\t/**\n\t * Transforms a point according to this matrix.\n\t * @method transformPoint\n\t * @param {Number} x The x component of the point to transform.\n\t * @param {Number} y The y component of the point to transform.\n\t * @param {Point | Object} [pt] An object to copy the result into. If omitted a generic object with x/y properties will be returned.\n\t * @return {Point} This matrix. Useful for chaining method calls.\n\t **/\n\tp.transformPoint = function(x, y, pt) {\n\t\tpt = pt||{};\n\t\tpt.x = x*this.a+y*this.c+this.tx;\n\t\tpt.y = x*this.b+y*this.d+this.ty;\n\t\treturn pt;\n\t};\n\n\t/**\n\t * Decomposes the matrix into transform properties (x, y, scaleX, scaleY, and rotation). Note that these values\n\t * may not match the transform properties you used to generate the matrix, though they will produce the same visual\n\t * results.\n\t * @method decompose\n\t * @param {Object} target The object to apply the transform properties to. If null, then a new object will be returned.\n\t * @return {Object} The target, or a new generic object with the transform properties applied.\n\t*/\n\tp.decompose = function(target) {\n\t\t// TODO: it would be nice to be able to solve for whether the matrix can be decomposed into only scale/rotation even when scale is negative\n\t\tif (target == null) { target = {}; }\n\t\ttarget.x = this.tx;\n\t\ttarget.y = this.ty;\n\t\ttarget.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);\n\t\ttarget.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);\n\n\t\tvar skewX = Math.atan2(-this.c, this.d);\n\t\tvar skewY = Math.atan2(this.b, this.a);\n\n\t\tvar delta = Math.abs(1-skewX/skewY);\n\t\tif (delta < 0.00001) { // effectively identical, can use rotation:\n\t\t\ttarget.rotation = skewY/Matrix2D.DEG_TO_RAD;\n\t\t\tif (this.a < 0 && this.d >= 0) {\n\t\t\t\ttarget.rotation += (target.rotation <= 0) ? 180 : -180;\n\t\t\t}\n\t\t\ttarget.skewX = target.skewY = 0;\n\t\t} else {\n\t\t\ttarget.skewX = skewX/Matrix2D.DEG_TO_RAD;\n\t\t\ttarget.skewY = skewY/Matrix2D.DEG_TO_RAD;\n\t\t}\n\t\treturn target;\n\t};\n\t\n\t/**\n\t * Copies all properties from the specified matrix to this matrix.\n\t * @method copy\n\t * @param {Matrix2D} matrix The matrix to copy properties from.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t*/\n\tp.copy = function(matrix) {\n\t\treturn this.setValues(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\n\t};\n\n\t/**\n\t * Returns a clone of the Matrix2D instance.\n\t * @method clone\n\t * @return {Matrix2D} a clone of the Matrix2D instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Matrix2D(this.a, this.b, this.c, this.d, this.tx, this.ty);\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Matrix2D (a=\"+this.a+\" b=\"+this.b+\" c=\"+this.c+\" d=\"+this.d+\" tx=\"+this.tx+\" ty=\"+this.ty+\")]\";\n\t};\n\n\t// this has to be populated after the class is defined:\n\tMatrix2D.identity = new Matrix2D();\n\n\n\tcreatejs.Matrix2D = Matrix2D;\n}());\n\n//##############################################################################\n// DisplayProps.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * Used for calculating and encapsulating display related properties.\n\t * @class DisplayProps\n\t * @param {Number} [visible=true] Visible value.\n\t * @param {Number} [alpha=1] Alpha value.\n\t * @param {Number} [shadow=null] A Shadow instance or null.\n\t * @param {Number} [compositeOperation=null] A compositeOperation value or null.\n\t * @param {Number} [matrix] A transformation matrix. Defaults to a new identity matrix.\n\t * @constructor\n\t **/\n\tfunction DisplayProps(visible, alpha, shadow, compositeOperation, matrix) {\n\t\tthis.setValues(visible, alpha, shadow, compositeOperation, matrix);\n\t\t\n\t// public properties:\n\t\t// assigned in the setValues method.\n\t\t/**\n\t\t * Property representing the alpha that will be applied to a display object.\n\t\t * @property alpha\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Property representing the shadow that will be applied to a display object.\n\t\t * @property shadow\n\t\t * @type Shadow\n\t\t **/\n\t\n\t\t/**\n\t\t * Property representing the compositeOperation that will be applied to a display object.\n\t\t * You can find a list of valid composite operations at:\n\t\t * <a href=\"https://developer.mozilla.org/en/Canvas_tutorial/Compositing\">https://developer.mozilla.org/en/Canvas_tutorial/Compositing</a>\n\t\t * @property compositeOperation\n\t\t * @type String\n\t\t **/\n\t\t\n\t\t/**\n\t\t * Property representing the value for visible that will be applied to a display object.\n\t\t * @property visible\n\t\t * @type Boolean\n\t\t **/\n\t\t\n\t\t/**\n\t\t * The transformation matrix that will be applied to a display object.\n\t\t * @property matrix\n\t\t * @type Matrix2D\n\t\t **/\n\t}\n\tvar p = DisplayProps.prototype;\n\n// initialization:\n\t/**\n\t * Reinitializes the instance with the specified values.\n\t * @method setValues\n\t * @param {Number} [visible=true] Visible value.\n\t * @param {Number} [alpha=1] Alpha value.\n\t * @param {Number} [shadow=null] A Shadow instance or null.\n\t * @param {Number} [compositeOperation=null] A compositeOperation value or null.\n\t * @param {Number} [matrix] A transformation matrix. Defaults to an identity matrix.\n\t * @return {DisplayProps} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.setValues = function (visible, alpha, shadow, compositeOperation, matrix) {\n\t\tthis.visible = visible == null ? true : !!visible;\n\t\tthis.alpha = alpha == null ? 1 : alpha;\n\t\tthis.shadow = shadow;\n\t\tthis.compositeOperation = compositeOperation;\n\t\tthis.matrix = matrix || (this.matrix&&this.matrix.identity()) || new createjs.Matrix2D();\n\t\treturn this;\n\t};\n\n// public methods:\n\t/**\n\t * Appends the specified display properties. This is generally used to apply a child's properties its parent's.\n\t * @method append\n\t * @param {Boolean} visible desired visible value\n\t * @param {Number} alpha desired alpha value\n\t * @param {Shadow} shadow desired shadow value\n\t * @param {String} compositeOperation desired composite operation value\n\t * @param {Matrix2D} [matrix] a Matrix2D instance\n\t * @return {DisplayProps} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.append = function(visible, alpha, shadow, compositeOperation, matrix) {\n\t\tthis.alpha *= alpha;\n\t\tthis.shadow = shadow || this.shadow;\n\t\tthis.compositeOperation = compositeOperation || this.compositeOperation;\n\t\tthis.visible = this.visible && visible;\n\t\tmatrix&&this.matrix.appendMatrix(matrix);\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Prepends the specified display properties. This is generally used to apply a parent's properties to a child's.\n\t * For example, to get the combined display properties that would be applied to a child, you could use:\n\t * \n\t * \tvar o = myDisplayObject;\n\t * \tvar props = new createjs.DisplayProps();\n\t * \tdo {\n\t * \t\t// prepend each parent's props in turn:\n\t * \t\tprops.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation, o.getMatrix());\n\t * \t} while (o = o.parent);\n\t * \t\n\t * @method prepend\n\t * @param {Boolean} visible desired visible value\n\t * @param {Number} alpha desired alpha value\n\t * @param {Shadow} shadow desired shadow value\n\t * @param {String} compositeOperation desired composite operation value\n\t * @param {Matrix2D} [matrix] a Matrix2D instance\n\t * @return {DisplayProps} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.prepend = function(visible, alpha, shadow, compositeOperation, matrix) {\n\t\tthis.alpha *= alpha;\n\t\tthis.shadow = this.shadow || shadow;\n\t\tthis.compositeOperation = this.compositeOperation || compositeOperation;\n\t\tthis.visible = this.visible && visible;\n\t\tmatrix&&this.matrix.prependMatrix(matrix);\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Resets this instance and its matrix to default values.\n\t * @method identity\n\t * @return {DisplayProps} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.identity = function() {\n\t\tthis.visible = true;\n\t\tthis.alpha = 1;\n\t\tthis.shadow = this.compositeOperation = null;\n\t\tthis.matrix.identity();\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Returns a clone of the DisplayProps instance. Clones the associated matrix.\n\t * @method clone\n\t * @return {DisplayProps} a clone of the DisplayProps instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new DisplayProps(this.alpha, this.shadow, this.compositeOperation, this.visible, this.matrix.clone());\n\t};\n\n// private methods:\n\n\tcreatejs.DisplayProps = DisplayProps;\n})();\n\n//##############################################################################\n// Point.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Represents a point on a 2 dimensional x / y coordinate system.\n\t *\n\t * <h4>Example</h4>\n\t * \n\t *      var point = new createjs.Point(0, 100);\n\t * \n\t * @class Point\n\t * @param {Number} [x=0] X position.\n\t * @param {Number} [y=0] Y position.\n\t * @constructor\n\t **/\n\tfunction Point(x, y) {\n\t \tthis.setValues(x, y);\n\t \t\n\t \t\n\t// public properties:\n\t\t// assigned in the setValues method.\n\t\t/**\n\t\t * X position.\n\t\t * @property x\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Y position.\n\t\t * @property y\n\t\t * @type Number\n\t\t **/\n\t}\n\tvar p = Point.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\t\n// public methods:\n\t/** \n\t * Sets the specified values on this instance.\n\t * @method setValues\n\t * @param {Number} [x=0] X position.\n\t * @param {Number} [y=0] Y position.\n\t * @return {Point} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.setValues = function(x, y) {\n\t\tthis.x = x||0;\n\t\tthis.y = y||0;\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Copies all properties from the specified point to this point.\n\t * @method copy\n\t * @param {Point} point The point to copy properties from.\n\t * @return {Point} This point. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.copy = function(point) {\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Returns a clone of the Point instance.\n\t * @method clone\n\t * @return {Point} a clone of the Point instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Point(this.x, this.y);\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Point (x=\"+this.x+\" y=\"+this.y+\")]\";\n\t};\n\t\n\t\n\tcreatejs.Point = Point;\n}());\n\n//##############################################################################\n// Rectangle.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Represents a rectangle as defined by the points (x, y) and (x+width, y+height).\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var rect = new createjs.Rectangle(0, 0, 100, 100);\n\t *\n\t * @class Rectangle\n\t * @param {Number} [x=0] X position.\n\t * @param {Number} [y=0] Y position.\n\t * @param {Number} [width=0] The width of the Rectangle.\n\t * @param {Number} [height=0] The height of the Rectangle.\n\t * @constructor\n\t **/\n\tfunction Rectangle(x, y, width, height) {\n\t\tthis.setValues(x, y, width, height);\n\t\t\n\t\t\n\t// public properties:\n\t\t// assigned in the setValues method.\n\t\t/**\n\t\t * X position.\n\t\t * @property x\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Y position.\n\t\t * @property y\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Width.\n\t\t * @property width\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Height.\n\t\t * @property height\n\t\t * @type Number\n\t\t **/\n\t}\n\tvar p = Rectangle.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// public methods:\n\t/** \n\t * Sets the specified values on this instance.\n\t * @method setValues\n\t * @param {Number} [x=0] X position.\n\t * @param {Number} [y=0] Y position.\n\t * @param {Number} [width=0] The width of the Rectangle.\n\t * @param {Number} [height=0] The height of the Rectangle.\n\t * @return {Rectangle} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.setValues = function(x, y, width, height) {\n\t\t// don't forget to update docs in the constructor if these change:\n\t\tthis.x = x||0;\n\t\tthis.y = y||0;\n\t\tthis.width = width||0;\n\t\tthis.height = height||0;\n\t\treturn this;\n\t};\n\t\n\t/** \n\t * Extends the rectangle's bounds to include the described point or rectangle.\n\t * @method extend\n\t * @param {Number} x X position of the point or rectangle.\n\t * @param {Number} y Y position of the point or rectangle.\n\t * @param {Number} [width=0] The width of the rectangle.\n\t * @param {Number} [height=0] The height of the rectangle.\n\t * @return {Rectangle} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.extend = function(x, y, width, height) {\n\t\twidth = width||0;\n\t\theight = height||0;\n\t\tif (x+width > this.x+this.width) { this.width = x+width-this.x; }\n\t\tif (y+height > this.y+this.height) { this.height = y+height-this.y; }\n\t\tif (x < this.x) { this.width += this.x-x; this.x = x; }\n\t\tif (y < this.y) { this.height += this.y-y; this.y = y; }\n\t\treturn this;\n\t};\n\t\n\t/** \n\t * Adds the specified padding to the rectangle's bounds.\n\t * @method pad\n\t * @param {Number} top\n\t * @param {Number} left\n\t * @param {Number} right\n\t * @param {Number} bottom\n\t * @return {Rectangle} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.pad = function(top, left, bottom, right) {\n\t\tthis.x -= left;\n\t\tthis.y -= top;\n\t\tthis.width += left+right;\n\t\tthis.height += top+bottom;\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Copies all properties from the specified rectangle to this rectangle.\n\t * @method copy\n\t * @param {Rectangle} rectangle The rectangle to copy properties from.\n\t * @return {Rectangle} This rectangle. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.copy = function(rectangle) {\n\t\treturn this.setValues(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n\t};\n\t\n\t/** \n\t * Returns true if this rectangle fully encloses the described point or rectangle.\n\t * @method contains\n\t * @param {Number} x X position of the point or rectangle.\n\t * @param {Number} y Y position of the point or rectangle.\n\t * @param {Number} [width=0] The width of the rectangle.\n\t * @param {Number} [height=0] The height of the rectangle.\n\t * @return {Boolean} True if the described point or rectangle is contained within this rectangle.\n\t*/\n\tp.contains = function(x, y, width, height) {\n\t\twidth = width||0;\n\t\theight = height||0;\n\t\treturn (x >= this.x && x+width <= this.x+this.width && y >= this.y && y+height <= this.y+this.height);\n\t};\n\t\n\t/** \n\t * Returns a new rectangle which contains this rectangle and the specified rectangle.\n\t * @method union\n\t * @param {Rectangle} rect The rectangle to calculate a union with.\n\t * @return {Rectangle} A new rectangle describing the union.\n\t*/\n\tp.union = function(rect) {\n\t\treturn this.clone().extend(rect.x, rect.y, rect.width, rect.height);\n\t};\n\t\n\t/** \n\t * Returns a new rectangle which describes the intersection (overlap) of this rectangle and the specified rectangle,\n\t * or null if they do not intersect.\n\t * @method intersection\n\t * @param {Rectangle} rect The rectangle to calculate an intersection with.\n\t * @return {Rectangle} A new rectangle describing the intersection or null.\n\t*/\n\tp.intersection = function(rect) {\n\t\tvar x1 = rect.x, y1 = rect.y, x2 = x1+rect.width, y2 = y1+rect.height;\n\t\tif (this.x > x1) { x1 = this.x; }\n\t\tif (this.y > y1) { y1 = this.y; }\n\t\tif (this.x + this.width < x2) { x2 = this.x + this.width; }\n\t\tif (this.y + this.height < y2) { y2 = this.y + this.height; }\n\t\treturn (x2 <= x1 || y2 <= y1) ? null : new Rectangle(x1, y1, x2-x1, y2-y1);\n\t};\n\t\n\t/** \n\t * Returns true if the specified rectangle intersects (has any overlap) with this rectangle.\n\t * @method intersects\n\t * @param {Rectangle} rect The rectangle to compare.\n\t * @return {Boolean} True if the rectangles intersect.\n\t*/\n\tp.intersects = function(rect) {\n\t\treturn (rect.x <= this.x+this.width && this.x <= rect.x+rect.width && rect.y <= this.y+this.height && this.y <= rect.y + rect.height);\n\t};\n\t\n\t/** \n\t * Returns true if the width or height are equal or less than 0.\n\t * @method isEmpty\n\t * @return {Boolean} True if the rectangle is empty.\n\t*/\n\tp.isEmpty = function() {\n\t\treturn this.width <= 0 || this.height <= 0;\n\t};\n\t\n\t/**\n\t * Returns a clone of the Rectangle instance.\n\t * @method clone\n\t * @return {Rectangle} a clone of the Rectangle instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Rectangle(this.x, this.y, this.width, this.height);\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Rectangle (x=\"+this.x+\" y=\"+this.y+\" width=\"+this.width+\" height=\"+this.height+\")]\";\n\t};\n\t\n\t\n\tcreatejs.Rectangle = Rectangle;\n}());\n\n//##############################################################################\n// ButtonHelper.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * The ButtonHelper is a helper class to create interactive buttons from {{#crossLink \"MovieClip\"}}{{/crossLink}} or\n\t * {{#crossLink \"Sprite\"}}{{/crossLink}} instances. This class will intercept mouse events from an object, and\n\t * automatically call {{#crossLink \"Sprite/gotoAndStop\"}}{{/crossLink}} or {{#crossLink \"Sprite/gotoAndPlay\"}}{{/crossLink}},\n\t * to the respective animation labels, add a pointer cursor, and allows the user to define a hit state frame.\n\t *\n\t * The ButtonHelper instance does not need to be added to the stage, but a reference should be maintained to prevent\n\t * garbage collection.\n\t * \n\t * Note that over states will not work unless you call {{#crossLink \"Stage/enableMouseOver\"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var helper = new createjs.ButtonHelper(myInstance, \"out\", \"over\", \"down\", false, myInstance, \"hit\");\n\t *      myInstance.addEventListener(\"click\", handleClick);\n\t *      function handleClick(event) {\n\t *          // Click Happened.\n\t *      }\n\t *\n\t * @class ButtonHelper\n\t * @param {Sprite|MovieClip} target The instance to manage.\n\t * @param {String} [outLabel=\"out\"] The label or animation to go to when the user rolls out of the button.\n\t * @param {String} [overLabel=\"over\"] The label or animation to go to when the user rolls over the button.\n\t * @param {String} [downLabel=\"down\"] The label or animation to go to when the user presses the button.\n\t * @param {Boolean} [play=false] If the helper should call \"gotoAndPlay\" or \"gotoAndStop\" on the button when changing\n\t * states.\n\t * @param {DisplayObject} [hitArea] An optional item to use as the hit state for the button. If this is not defined,\n\t * then the button's visible states will be used instead. Note that the same instance as the \"target\" argument can be\n\t * used for the hitState.\n\t * @param {String} [hitLabel] The label or animation on the hitArea instance that defines the hitArea bounds. If this is\n\t * null, then the default state of the hitArea will be used. *\n\t * @constructor\n\t */\n\tfunction ButtonHelper(target, outLabel, overLabel, downLabel, play, hitArea, hitLabel) {\n\t\tif (!target.addEventListener) { return; }\n\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * The target for this button helper.\n\t\t * @property target\n\t\t * @type MovieClip | Sprite\n\t\t * @readonly\n\t\t **/\n\t\tthis.target = target;\n\t\n\t\t/**\n\t\t * The label name or frame number to display when the user mouses out of the target. Defaults to \"over\".\n\t\t * @property overLabel\n\t\t * @type String | Number\n\t\t **/\n\t\tthis.overLabel = overLabel == null ? \"over\" : overLabel;\n\t\n\t\t/**\n\t\t * The label name or frame number to display when the user mouses over the target. Defaults to \"out\".\n\t\t * @property outLabel\n\t\t * @type String | Number\n\t\t **/\n\t\tthis.outLabel = outLabel == null ? \"out\" : outLabel;\n\t\n\t\t/**\n\t\t * The label name or frame number to display when the user presses on the target. Defaults to \"down\".\n\t\t * @property downLabel\n\t\t * @type String | Number\n\t\t **/\n\t\tthis.downLabel = downLabel == null ? \"down\" : downLabel;\n\t\n\t\t/**\n\t\t * If true, then ButtonHelper will call gotoAndPlay, if false, it will use gotoAndStop. Default is false.\n\t\t * @property play\n\t\t * @default false\n\t\t * @type Boolean\n\t\t **/\n\t\tthis.play = play;\n\t\t\n\t\t\n\t//  private properties\n\t\t/**\n\t\t * @property _isPressed\n\t\t * @type Boolean\n\t\t * @protected\n\t\t **/\n\t\tthis._isPressed = false;\n\t\n\t\t/**\n\t\t * @property _isOver\n\t\t * @type Boolean\n\t\t * @protected\n\t\t **/\n\t\tthis._isOver = false;\n\t\n\t\t/**\n\t\t * @property _enabled\n\t\t * @type Boolean\n\t\t * @protected\n\t\t **/\n\t\tthis._enabled = false;\n\t\t\n\t// setup:\n\t\ttarget.mouseChildren = false; // prevents issues when children are removed from the display list when state changes.\n\t\tthis.enabled = true;\n\t\tthis.handleEvent({});\n\t\tif (hitArea) {\n\t\t\tif (hitLabel) {\n\t\t\t\thitArea.actionsEnabled = false;\n\t\t\t\thitArea.gotoAndStop&&hitArea.gotoAndStop(hitLabel);\n\t\t\t}\n\t\t\ttarget.hitArea = hitArea;\n\t\t}\n\t}\n\tvar p = ButtonHelper.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\t\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink \"ButtonHelper/enabled:property\"}}{{/crossLink}} property instead.\n\t * @method setEnabled\n\t * @param {Boolean} value\n\t * @deprecated\n\t **/\n\tp.setEnabled = function(value) { // TODO: deprecated.\n\t\tif (value == this._enabled) { return; }\n\t\tvar o = this.target;\n\t\tthis._enabled = value;\n\t\tif (value) {\n\t\t\to.cursor = \"pointer\";\n\t\t\to.addEventListener(\"rollover\", this);\n\t\t\to.addEventListener(\"rollout\", this);\n\t\t\to.addEventListener(\"mousedown\", this);\n\t\t\to.addEventListener(\"pressup\", this);\n\t\t\tif (o._reset) { o.__reset = o._reset; o._reset = this._reset;}\n\t\t} else {\n\t\t\to.cursor = null;\n\t\t\to.removeEventListener(\"rollover\", this);\n\t\t\to.removeEventListener(\"rollout\", this);\n\t\t\to.removeEventListener(\"mousedown\", this);\n\t\t\to.removeEventListener(\"pressup\", this);\n\t\t\tif (o.__reset) { o._reset = o.__reset; delete(o.__reset); }\n\t\t}\n\t};\n\t/**\n\t * Use the {{#crossLink \"ButtonHelper/enabled:property\"}}{{/crossLink}} property instead.\n\t * @method getEnabled\n\t * @return {Boolean}\n\t * @deprecated\n\t **/\n\tp.getEnabled = function() {\n\t\treturn this._enabled;\n\t};\n\n\t/**\n\t * Enables or disables the button functionality on the target.\n\t * @property enabled\n\t * @type {Boolean}\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tenabled: { get: p.getEnabled, set: p.setEnabled }\n\t\t});\n\t} catch (e) {} // TODO: use Log\n\n\n// public methods:\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[ButtonHelper]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method handleEvent\n\t * @param {Object} evt The mouse event to handle.\n\t * @protected\n\t **/\n\tp.handleEvent = function(evt) {\n\t\tvar label, t = this.target, type = evt.type;\n\t\tif (type == \"mousedown\") {\n\t\t\tthis._isPressed = true;\n\t\t\tlabel = this.downLabel;\n\t\t} else if (type == \"pressup\") {\n\t\t\tthis._isPressed = false;\n\t\t\tlabel = this._isOver ? this.overLabel : this.outLabel;\n\t\t} else if (type == \"rollover\") {\n\t\t\tthis._isOver = true;\n\t\t\tlabel = this._isPressed ? this.downLabel : this.overLabel;\n\t\t} else { // rollout and default\n\t\t\tthis._isOver = false;\n\t\t\tlabel = this._isPressed ? this.overLabel : this.outLabel;\n\t\t}\n\t\tif (this.play) {\n\t\t\tt.gotoAndPlay&&t.gotoAndPlay(label);\n\t\t} else {\n\t\t\tt.gotoAndStop&&t.gotoAndStop(label);\n\t\t}\n\t};\n\t\n\t/**\n\t * Injected into target. Preserves the paused state through a reset.\n\t * @method _reset\n\t * @protected\n\t **/\n\tp._reset = function() {\n\t\t// TODO: explore better ways to handle this issue. This is hacky & disrupts object signatures.\n\t\tvar p = this.paused;\n\t\tthis.__reset();\n\t\tthis.paused = p;\n\t};\n\n\n\tcreatejs.ButtonHelper = ButtonHelper;\n}());\n\n//##############################################################################\n// Shadow.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * This class encapsulates the properties required to define a shadow to apply to a {{#crossLink \"DisplayObject\"}}{{/crossLink}}\n\t * via its <code>shadow</code> property.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      myImage.shadow = new createjs.Shadow(\"#000000\", 5, 5, 10);\n\t *\n\t * @class Shadow\n\t * @constructor\n\t * @param {String} color The color of the shadow. This can be any valid CSS color value.\n\t * @param {Number} offsetX The x offset of the shadow in pixels.\n\t * @param {Number} offsetY The y offset of the shadow in pixels.\n\t * @param {Number} blur The size of the blurring effect.\n\t **/\n\tfunction Shadow(color, offsetX, offsetY, blur) {\n\t\t\n\t\t\n\t// public properties:\n\t\t/** \n\t\t * The color of the shadow. This can be any valid CSS color value.\n\t\t * @property color\n\t\t * @type String\n\t\t * @default null\n\t\t */\n\t\tthis.color = color||\"black\";\n\t\n\t\t/** The x offset of the shadow.\n\t\t * @property offsetX\n\t\t * @type Number\n\t\t * @default 0\n\t\t */\n\t\tthis.offsetX = offsetX||0;\n\t\n\t\t/** The y offset of the shadow.\n\t\t * @property offsetY\n\t\t * @type Number\n\t\t * @default 0\n\t\t */\n\t\tthis.offsetY = offsetY||0;\n\t\n\t\t/** The blur of the shadow.\n\t\t * @property blur\n\t\t * @type Number\n\t\t * @default 0\n\t\t */\n\t\tthis.blur = blur||0;\n\t}\n\tvar p = Shadow.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// static public properties:\n\t/**\n\t * An identity shadow object (all properties are set to 0).\n\t * @property identity\n\t * @type Shadow\n\t * @static\n\t * @final\n\t * @readonly\n\t **/\n\tShadow.identity = new Shadow(\"transparent\", 0, 0, 0);\n\n\n// public methods:\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Shadow]\";\n\t};\n\n\t/**\n\t * Returns a clone of this Shadow instance.\n\t * @method clone\n\t * @return {Shadow} A clone of the current Shadow instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Shadow(this.color, this.offsetX, this.offsetY, this.blur);\n\t};\n\t\n\n\tcreatejs.Shadow = Shadow;\n}());\n\n//##############################################################################\n// SpriteSheet.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Encapsulates the properties and methods associated with a sprite sheet. A sprite sheet is a series of images (usually\n\t * animation frames) combined into a larger image (or images). For example, an animation consisting of eight 100x100\n\t * images could be combined into a single 400x200 sprite sheet (4 frames across by 2 high).\n\t *\n\t * The data passed to the SpriteSheet constructor defines:\n\t * <ol>\n\t * \t<li> The source image or images to use.</li>\n\t * \t<li> The positions of individual image frames.</li>\n\t * \t<li> Sequences of frames that form named animations. Optional.</li>\n\t * \t<li> The target playback framerate. Optional.</li>\n\t * </ol>\n\t * <h3>SpriteSheet Format</h3>\n\t * SpriteSheets are an object with two required properties (`images` and `frames`), and two optional properties\n\t * (`framerate` and `animations`). This makes them easy to define in javascript code, or in JSON.\n\t *\n\t * <h4>images</h4>\n\t * An array of source images. Images can be either an HTMlimage\n\t * instance, or a uri to an image. The former is recommended to control preloading.\n\t *\n\t * \timages: [image1, \"path/to/image2.png\"],\n\t *\n\t * <h4>frames</h4>\n\t * Defines the individual frames. There are two supported formats for frame data:\n\t * When all of the frames are the same size (in a grid), use an object with `width`, `height`, `regX`, `regY`,\n\t * and `count` properties.\n\t *\n\t * <ul>\n\t *  <li>`width` & `height` are required and specify the dimensions of the frames</li>\n\t *  <li>`regX` & `regY` indicate the registration point or \"origin\" of the frames</li>\n\t *  <li>`spacing` indicate the spacing between frames</li>\n\t *  <li>`margin` specify the margin around the image(s)</li>\n\t *  <li>`count` allows you to specify the total number of frames in the spritesheet; if omitted, this will\n\t *  be calculated based on the dimensions of the source images and the frames. Frames will be assigned\n\t *  indexes based on their position in the source images (left to right, top to bottom).</li>\n\t * </ul>\n\t *\n\t *  \tframes: {width:64, height:64, count:20, regX: 32, regY:64, spacing:0, margin:0}\n\t *\n\t * If the frames are of different sizes, use an array of frame definitions. Each definition is itself an array\n\t * with 4 required and 3 optional entries, in the order:\n\t *\n\t * <ul>\n\t *  <li>The first four, `x`, `y`, `width`, and `height` are required and define the frame rectangle.</li>\n\t *  <li>The fifth, `imageIndex`, specifies the index of the source image (defaults to 0)</li>\n\t *  <li>The last two, `regX` and `regY` specify the registration point of the frame</li>\n\t * </ul>\n\t *\n\t * \tframes: [\n\t * \t\t// x, y, width, height, imageIndex*, regX*, regY*\n\t * \t\t[64, 0, 96, 64],\n\t * \t\t[0, 0, 64, 64, 1, 32, 32]\n\t * \t\t// etc.\n\t * \t]\n\t *\n\t * <h4>animations</h4>\n\t * Optional. An object defining sequences of frames to play as named animations. Each property corresponds to an\n\t * animation of the same name. Each animation must specify the frames to play, and may\n\t * also include a relative playback `speed` (ex. 2 would playback at double speed, 0.5 at half), and\n\t * the name of the `next` animation to sequence to after it completes.\n\t *\n\t * There are three formats supported for defining the frames in an animation, which can be mixed and matched as appropriate:\n\t * <ol>\n\t * \t<li>for a single frame animation, you can simply specify the frame index\n\t *\n\t * \t\tanimations: {\n\t * \t\t\tsit: 7\n\t * \t\t}\n\t *\n\t * </li>\n\t * <li>\n\t *      for an animation of consecutive frames, you can use an array with two required, and two optional entries\n\t * \t\tin the order: `start`, `end`, `next`, and `speed`. This will play the frames from start to end inclusive.\n\t *\n\t * \t\tanimations: {\n\t * \t\t\t// start, end, next*, speed*\n\t * \t\t\trun: [0, 8],\n\t * \t\t\tjump: [9, 12, \"run\", 2]\n\t * \t\t}\n\t *\n\t *  </li>\n\t *  <li>\n\t *     for non-consecutive frames, you can use an object with a `frames` property defining an array of frame\n\t *     indexes to play in order. The object can also specify `next` and `speed` properties.\n\t *\n\t * \t\tanimations: {\n\t * \t\t\twalk: {\n\t * \t\t\t\tframes: [1,2,3,3,2,1]\n\t * \t\t\t},\n\t * \t\t\tshoot: {\n\t * \t\t\t\tframes: [1,4,5,6],\n\t * \t\t\t\tnext: \"walk\",\n\t * \t\t\t\tspeed: 0.5\n\t * \t\t\t}\n\t * \t\t}\n\t *\n\t *  </li>\n\t * </ol>\n\t * <strong>Note:</strong> the `speed` property was added in EaselJS 0.7.0. Earlier versions had a `frequency`\n\t * property instead, which was the inverse of `speed`. For example, a value of \"4\" would be 1/4 normal speed in\n\t * earlier versions, but is 4x normal speed in EaselJS 0.7.0+.\n\t *\n\t * <h4>framerate</h4>\n\t * Optional. Indicates the default framerate to play this spritesheet at in frames per second. See\n\t * {{#crossLink \"SpriteSheet/framerate:property\"}}{{/crossLink}} for more information.\n\t *\n\t * \t\tframerate: 20\n\t *\n\t * Note that the Sprite framerate will only work if the stage update method is provided with the {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}}\n\t * event generated by the {{#crossLink \"Ticker\"}}{{/crossLink}}.\n\t *\n\t * \t\tcreatejs.Ticker.on(\"tick\", handleTick);\n\t * \t\tfunction handleTick(event) {\n\t *\t\t\tstage.update(event);\n\t *\t\t}\n\t *\n\t * <h3>Example</h3>\n\t * To define a simple sprite sheet, with a single image \"sprites.jpg\" arranged in a regular 50x50 grid with three\n\t * animations: \"stand\" showing the first frame, \"run\" looping frame 1-5 inclusive, and \"jump\" playing frame 6-8 and\n\t * sequencing back to run.\n\t *\n\t * \t\tvar data = {\n\t * \t\t\timages: [\"sprites.jpg\"],\n\t * \t\t\tframes: {width:50, height:50},\n\t * \t\t\tanimations: {\n\t * \t\t\t\tstand:0,\n\t * \t\t\t\trun:[1,5],\n\t * \t\t\t\tjump:[6,8,\"run\"]\n\t * \t\t\t}\n\t * \t\t};\n\t * \t\tvar spriteSheet = new createjs.SpriteSheet(data);\n\t * \t\tvar animation = new createjs.Sprite(spriteSheet, \"run\");\n\t *\n\t * <h3>Generating SpriteSheet Images</h3>\n\t * Spritesheets can be created manually by combining images in PhotoShop, and specifying the frame size or\n\t * coordinates manually, however there are a number of tools that facilitate this.\n\t * <ul>\n\t *     <li>Exporting SpriteSheets or HTML5 content from Flash Pro supports the EaselJS SpriteSheet format.</li>\n\t *     <li>The popular <a href=\"https://www.codeandweb.com/texturepacker/easeljs\" target=\"_blank\">Texture Packer</a> has\n\t *     EaselJS support.\n\t *     <li>SWF animations in Flash can be exported to SpriteSheets using <a href=\"http://createjs.com/zoe\" target=\"_blank\"></a></li>\n\t * </ul>\n\t *\n\t * <h3>Cross Origin Issues</h3>\n\t * <strong>Warning:</strong> Images loaded cross-origin will throw cross-origin security errors when interacted with\n\t * using:\n\t * <ul>\n\t *     <li>a mouse</li>\n\t *     <li>methods such as {{#crossLink \"Container/getObjectUnderPoint\"}}{{/crossLink}}</li>\n\t *     <li>Filters (see {{#crossLink \"Filter\"}}{{/crossLink}})</li>\n\t *     <li>caching (see {{#crossLink \"DisplayObject/cache\"}}{{/crossLink}})</li>\n\t * </ul>\n\t * You can get around this by setting `crossOrigin` property on your images before passing them to EaselJS, or\n\t * setting the `crossOrigin` property on PreloadJS' LoadQueue or LoadItems.\n\t *\n\t * \t\tvar image = new Image();\n\t * \t\timg.crossOrigin=\"Anonymous\";\n\t * \t\timg.src = \"http://server-with-CORS-support.com/path/to/image.jpg\";\n\t *\n\t * If you pass string paths to SpriteSheets, they will not work cross-origin. The server that stores the image must\n\t * support cross-origin requests, or this will not work. For more information, check out\n\t * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS\" target=\"_blank\">CORS overview on MDN</a>.\n\t *\n\t * @class SpriteSheet\n\t * @constructor\n\t * @param {Object} data An object describing the SpriteSheet data.\n\t * @extends EventDispatcher\n\t **/\n\tfunction SpriteSheet(data) {\n\t\tthis.EventDispatcher_constructor();\n\n\n\t\t// public properties:\n\t\t/**\n\t\t * Indicates whether all images are finished loading.\n\t\t * @property complete\n\t\t * @type Boolean\n\t\t * @readonly\n\t\t **/\n\t\tthis.complete = true;\n\n\t\t/**\n\t\t * Specifies the framerate to use by default for Sprite instances using the SpriteSheet. See the Sprite class\n\t\t * {{#crossLink \"Sprite/framerate:property\"}}{{/crossLink}} for more information.\n\t\t * @property framerate\n\t\t * @type Number\n\t\t **/\n\t\tthis.framerate = 0;\n\n\n\t\t// private properties:\n\t\t/**\n\t\t * @property _animations\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._animations = null;\n\n\t\t/**\n\t\t * @property _frames\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._frames = null;\n\n\t\t/**\n\t\t * @property _images\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._images = null;\n\n\t\t/**\n\t\t * @property _data\n\t\t * @protected\n\t\t * @type Object\n\t\t **/\n\t\tthis._data = null;\n\n\t\t/**\n\t\t * @property _loadCount\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._loadCount = 0;\n\n\t\t// only used for simple frame defs:\n\t\t/**\n\t\t * @property _frameHeight\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._frameHeight = 0;\n\n\t\t/**\n\t\t * @property _frameWidth\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._frameWidth = 0;\n\n\t\t/**\n\t\t * @property _numFrames\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._numFrames = 0;\n\n\t\t/**\n\t\t * @property _regX\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._regX = 0;\n\n\t\t/**\n\t\t * @property _regY\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._regY = 0;\n\n\t\t/**\n\t\t * @property _spacing\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._spacing = 0;\n\n\t\t/**\n\t\t * @property _margin\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._margin = 0;\n\n\t\t// setup:\n\t\tthis._parseData(data);\n\t}\n\tvar p = createjs.extend(SpriteSheet, createjs.EventDispatcher);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// events:\n\t/**\n\t * Dispatched when all images are loaded.  Note that this only fires if the images\n\t * were not fully loaded when the sprite sheet was initialized. You should check the complete property\n\t * to prior to adding a listener. Ex.\n\t *\n\t * \tvar sheet = new createjs.SpriteSheet(data);\n\t * \tif (!sheet.complete) {\n\t * \t\t// not preloaded, listen for the complete event:\n\t * \t\tsheet.addEventListener(\"complete\", handler);\n\t * \t}\n\t *\n\t * @event complete\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when getFrame is called with a valid frame index. This is primarily intended for use by {{#crossLink \"SpriteSheetBuilder\"}}{{/crossLink}}\n\t * when doing on-demand rendering.\n\t * @event getframe\n\t * @param {Number} index The frame index.\n\t * @param {Object} frame The frame object that getFrame will return.\n\t */\n\n\t/**\n\t * Dispatched when an image encounters an error. A SpriteSheet will dispatch an error event for each image that\n\t * encounters an error, and will still dispatch a {{#crossLink \"SpriteSheet/complete:event\"}}{{/crossLink}}\n\t * event once all images are finished processing, even if an error is encountered.\n\t * @event error\n\t * @param {String} src The source of the image that failed to load.\n\t * @since 0.8.2\n\t */\n\n\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink \"SpriteSheet/animations:property\"}}{{/crossLink}} property instead.\n\t * @method getAnimations\n\t * @return {Array}\n\t * @deprecated\n\t **/\n\tp.getAnimations = function() {\n\t\treturn this._animations.slice();\n\t};\n\n\t/**\n\t * Returns an array of all available animation names available on this sprite sheet as strings.\n\t * @property animations\n\t * @type {Array}\n\t * @readonly\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tanimations: { get: p.getAnimations }\n\t\t});\n\t} catch (e) {}\n\n\n// public methods:\n\t/**\n\t * Returns the total number of frames in the specified animation, or in the whole sprite\n\t * sheet if the animation param is omitted. Returns 0 if the spritesheet relies on calculated frame counts, and\n\t * the images have not been fully loaded.\n\t * @method getNumFrames\n\t * @param {String} animation The name of the animation to get a frame count for.\n\t * @return {Number} The number of frames in the animation, or in the entire sprite sheet if the animation param is omitted.\n\t */\n\tp.getNumFrames = function(animation) {\n\t\tif (animation == null) {\n\t\t\treturn this._frames ? this._frames.length : this._numFrames || 0;\n\t\t} else {\n\t\t\tvar data = this._data[animation];\n\t\t\tif (data == null) { return 0; }\n\t\t\telse { return data.frames.length; }\n\t\t}\n\t};\n\n\t/**\n\t * Returns an object defining the specified animation. The returned object contains:<UL>\n\t * \t<li>frames: an array of the frame ids in the animation</li>\n\t * \t<li>speed: the playback speed for this animation</li>\n\t * \t<li>name: the name of the animation</li>\n\t * \t<li>next: the default animation to play next. If the animation loops, the name and next property will be the\n\t * \tsame.</li>\n\t * </UL>\n\t * @method getAnimation\n\t * @param {String} name The name of the animation to get.\n\t * @return {Object} a generic object with frames, speed, name, and next properties.\n\t **/\n\tp.getAnimation = function(name) {\n\t\treturn this._data[name];\n\t};\n\n\t/**\n\t * Returns an object specifying the image and source rect of the specified frame. The returned object has:<UL>\n\t * \t<li>an image property holding a reference to the image object in which the frame is found</li>\n\t * \t<li>a rect property containing a Rectangle instance which defines the boundaries for the frame within that\n\t * \timage.</li>\n\t * \t<li> A regX and regY property corresponding to the regX/Y values for the frame.\n\t * </UL>\n\t * @method getFrame\n\t * @param {Number} frameIndex The index of the frame.\n\t * @return {Object} a generic object with image and rect properties. Returns null if the frame does not exist.\n\t **/\n\tp.getFrame = function(frameIndex) {\n\t\tvar frame;\n\t\tif (this._frames && (frame=this._frames[frameIndex])) { return frame; }\n\t\treturn null;\n\t};\n\n\t/**\n\t * Returns a {{#crossLink \"Rectangle\"}}{{/crossLink}} instance defining the bounds of the specified frame relative\n\t * to the origin. For example, a 90 x 70 frame with a regX of 50 and a regY of 40 would return:\n\t *\n\t * \t[x=-50, y=-40, width=90, height=70]\n\t *\n\t * @method getFrameBounds\n\t * @param {Number} frameIndex The index of the frame.\n\t * @param {Rectangle} [rectangle] A Rectangle instance to copy the values into. By default a new instance is created.\n\t * @return {Rectangle} A Rectangle instance. Returns null if the frame does not exist, or the image is not fully loaded.\n\t **/\n\tp.getFrameBounds = function(frameIndex, rectangle) {\n\t\tvar frame = this.getFrame(frameIndex);\n\t\treturn frame ? (rectangle||new createjs.Rectangle()).setValues(-frame.regX, -frame.regY, frame.rect.width, frame.rect.height) : null;\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[SpriteSheet]\";\n\t};\n\n\t/**\n\t * SpriteSheet cannot be cloned. A SpriteSheet can be shared by multiple Sprite instances without cloning it.\n\t * @method clone\n\t **/\n\tp.clone = function() {\n\t\tthrow(\"SpriteSheet cannot be cloned.\")\n\t};\n\n// private methods:\n\t/**\n\t * @method _parseData\n\t * @param {Object} data An object describing the SpriteSheet data.\n\t * @protected\n\t **/\n\tp._parseData = function(data) {\n\t\tvar i,l,o,a;\n\t\tif (data == null) { return; }\n\n\t\tthis.framerate = data.framerate||0;\n\n\t\t// parse images:\n\t\tif (data.images && (l=data.images.length) > 0) {\n\t\t\ta = this._images = [];\n\t\t\tfor (i=0; i<l; i++) {\n\t\t\t\tvar img = data.images[i];\n\t\t\t\tif (typeof img == \"string\") {\n\t\t\t\t\tvar src = img;\n\t\t\t\t\timg = document.createElement(\"img\");\n\t\t\t\t\timg.src = src;\n\t\t\t\t}\n\t\t\t\ta.push(img);\n\t\t\t\tif (!img.getContext && !img.naturalWidth) {\n\t\t\t\t\tthis._loadCount++;\n\t\t\t\t\tthis.complete = false;\n\t\t\t\t\t(function(o, src) { img.onload = function() { o._handleImageLoad(src); } })(this, src);\n\t\t\t\t\t(function(o, src) { img.onerror = function() { o._handleImageError(src); } })(this, src);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// parse frames:\n\t\tif (data.frames == null) { // nothing\n\t\t} else if (Array.isArray(data.frames)) {\n\t\t\tthis._frames = [];\n\t\t\ta = data.frames;\n\t\t\tfor (i=0,l=a.length;i<l;i++) {\n\t\t\t\tvar arr = a[i];\n\t\t\t\tthis._frames.push({image:this._images[arr[4]?arr[4]:0], rect:new createjs.Rectangle(arr[0],arr[1],arr[2],arr[3]), regX:arr[5]||0, regY:arr[6]||0 });\n\t\t\t}\n\t\t} else {\n\t\t\to = data.frames;\n\t\t\tthis._frameWidth = o.width;\n\t\t\tthis._frameHeight = o.height;\n\t\t\tthis._regX = o.regX||0;\n\t\t\tthis._regY = o.regY||0;\n\t\t\tthis._spacing = o.spacing||0;\n\t\t\tthis._margin = o.margin||0;\n\t\t\tthis._numFrames = o.count;\n\t\t\tif (this._loadCount == 0) { this._calculateFrames(); }\n\t\t}\n\n\t\t// parse animations:\n\t\tthis._animations = [];\n\t\tif ((o=data.animations) != null) {\n\t\t\tthis._data = {};\n\t\t\tvar name;\n\t\t\tfor (name in o) {\n\t\t\t\tvar anim = {name:name};\n\t\t\t\tvar obj = o[name];\n\t\t\t\tif (typeof obj == \"number\") { // single frame\n\t\t\t\t\ta = anim.frames = [obj];\n\t\t\t\t} else if (Array.isArray(obj)) { // simple\n\t\t\t\t\tif (obj.length == 1) { anim.frames = [obj[0]]; }\n\t\t\t\t\telse {\n\t\t\t\t\t\tanim.speed = obj[3];\n\t\t\t\t\t\tanim.next = obj[2];\n\t\t\t\t\t\ta = anim.frames = [];\n\t\t\t\t\t\tfor (i=obj[0];i<=obj[1];i++) {\n\t\t\t\t\t\t\ta.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else { // complex\n\t\t\t\t\tanim.speed = obj.speed;\n\t\t\t\t\tanim.next = obj.next;\n\t\t\t\t\tvar frames = obj.frames;\n\t\t\t\t\ta = anim.frames = (typeof frames == \"number\") ? [frames] : frames.slice(0);\n\t\t\t\t}\n\t\t\t\tif (anim.next === true || anim.next === undefined) { anim.next = name; } // loop\n\t\t\t\tif (anim.next === false || (a.length < 2 && anim.next == name)) { anim.next = null; } // stop\n\t\t\t\tif (!anim.speed) { anim.speed = 1; }\n\t\t\t\tthis._animations.push(name);\n\t\t\t\tthis._data[name] = anim;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _handleImageLoad\n\t * @protected\n\t **/\n\tp._handleImageLoad = function(src) {\n\t\tif (--this._loadCount == 0) {\n\t\t\tthis._calculateFrames();\n\t\t\tthis.complete = true;\n\t\t\tthis.dispatchEvent(\"complete\");\n\t\t}\n\t};\n\n\t/**\n\t * @method _handleImageError\n\t * @protected\n\t */\n\tp._handleImageError = function (src) {\n\t\tvar errorEvent = new createjs.Event(\"error\");\n\t\terrorEvent.src = src;\n\t\tthis.dispatchEvent(errorEvent);\n\n\t\t// Complete is still dispatched.\n\t\tif (--this._loadCount == 0) {\n\t\t\tthis.dispatchEvent(\"complete\");\n\t\t}\n\t};\n\n\t/**\n\t * @method _calculateFrames\n\t * @protected\n\t **/\n\tp._calculateFrames = function() {\n\t\tif (this._frames || this._frameWidth == 0) { return; }\n\n\t\tthis._frames = [];\n\n\t\tvar maxFrames = this._numFrames || 100000; // if we go over this, something is wrong.\n\t\tvar frameCount = 0, frameWidth = this._frameWidth, frameHeight = this._frameHeight;\n\t\tvar spacing = this._spacing, margin = this._margin;\n\t\t\n\t\timgLoop:\n\t\tfor (var i=0, imgs=this._images; i<imgs.length; i++) {\n\t\t\tvar img = imgs[i], imgW = img.width, imgH = img.height;\n\n\t\t\tvar y = margin;\n\t\t\twhile (y <= imgH-margin-frameHeight) {\n\t\t\t\tvar x = margin;\n\t\t\t\twhile (x <= imgW-margin-frameWidth) {\n\t\t\t\t\tif (frameCount >= maxFrames) { break imgLoop; }\n\t\t\t\t\tframeCount++;\n\t\t\t\t\tthis._frames.push({\n\t\t\t\t\t\t\timage: img,\n\t\t\t\t\t\t\trect: new createjs.Rectangle(x, y, frameWidth, frameHeight),\n\t\t\t\t\t\t\tregX: this._regX,\n\t\t\t\t\t\t\tregY: this._regY\n\t\t\t\t\t\t});\n\t\t\t\t\tx += frameWidth+spacing;\n\t\t\t\t}\n\t\t\t\ty += frameHeight+spacing;\n\t\t\t}\n\t\t}\n\t\tthis._numFrames = frameCount;\n\t};\n\n\n\tcreatejs.SpriteSheet = createjs.promote(SpriteSheet, \"EventDispatcher\");\n}());\n\n//##############################################################################\n// Graphics.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * The Graphics class exposes an easy to use API for generating vector drawing instructions and drawing them to a\n\t * specified context. Note that you can use Graphics without any dependency on the EaselJS framework by calling {{#crossLink \"Graphics/draw\"}}{{/crossLink}}\n\t * directly, or it can be used with the {{#crossLink \"Shape\"}}{{/crossLink}} object to draw vector graphics within the\n\t * context of an EaselJS display list.\n\t *\n\t * There are two approaches to working with Graphics object: calling methods on a Graphics instance (the \"Graphics API\"), or\n\t * instantiating Graphics command objects and adding them to the graphics queue via {{#crossLink \"Graphics/append\"}}{{/crossLink}}.\n\t * The former abstracts the latter, simplifying beginning and ending paths, fills, and strokes.\n\t *\n\t *      var g = new createjs.Graphics();\n\t *      g.setStrokeStyle(1);\n\t *      g.beginStroke(\"#000000\");\n\t *      g.beginFill(\"red\");\n\t *      g.drawCircle(0,0,30);\n\t *\n\t * All drawing methods in Graphics return the Graphics instance, so they can be chained together. For example,\n\t * the following line of code would generate the instructions to draw a rectangle with a red stroke and blue fill:\n\t *\n\t *      myGraphics.beginStroke(\"red\").beginFill(\"blue\").drawRect(20, 20, 100, 50);\n\t *\n\t * Each graphics API call generates a command object (see below). The last command to be created can be accessed via\n\t * {{#crossLink \"Graphics/command:property\"}}{{/crossLink}}:\n\t *\n\t *      var fillCommand = myGraphics.beginFill(\"red\").command;\n\t *      // ... later, update the fill style/color:\n\t *      fillCommand.style = \"blue\";\n\t *      // or change it to a bitmap fill:\n\t *      fillCommand.bitmap(myImage);\n\t *\n\t * For more direct control of rendering, you can instantiate and append command objects to the graphics queue directly. In this case, you\n\t * need to manage path creation manually, and ensure that fill/stroke is applied to a defined path:\n\t *\n\t *      // start a new path. Graphics.beginCmd is a reusable BeginPath instance:\n\t *      myGraphics.append(createjs.Graphics.beginCmd);\n\t *      // we need to define the path before applying the fill:\n\t *      var circle = new createjs.Graphics.Circle(0,0,30);\n\t *      myGraphics.append(circle);\n\t *      // fill the path we just defined:\n\t *      var fill = new createjs.Graphics.Fill(\"red\");\n\t *      myGraphics.append(fill);\n\t *\n\t * These approaches can be used together, for example to insert a custom command:\n\t *\n\t *      myGraphics.beginFill(\"red\");\n\t *      var customCommand = new CustomSpiralCommand(etc);\n\t *      myGraphics.append(customCommand);\n\t *      myGraphics.beginFill(\"blue\");\n\t *      myGraphics.drawCircle(0, 0, 30);\n\t *\n\t * See {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more info on creating custom commands.\n\t *\n\t * <h4>Tiny API</h4>\n\t * The Graphics class also includes a \"tiny API\", which is one or two-letter methods that are shortcuts for all of the\n\t * Graphics methods. These methods are great for creating compact instructions, and is used by the Toolkit for CreateJS\n\t * to generate readable code. All tiny methods are marked as protected, so you can view them by enabling protected\n\t * descriptions in the docs.\n\t *\n\t * <table>\n\t *     <tr><td><b>Tiny</b></td><td><b>Method</b></td><td><b>Tiny</b></td><td><b>Method</b></td></tr>\n\t *     <tr><td>mt</td><td>{{#crossLink \"Graphics/moveTo\"}}{{/crossLink}} </td>\n\t *     <td>lt</td> <td>{{#crossLink \"Graphics/lineTo\"}}{{/crossLink}}</td></tr>\n\t *     <tr><td>a/at</td><td>{{#crossLink \"Graphics/arc\"}}{{/crossLink}} / {{#crossLink \"Graphics/arcTo\"}}{{/crossLink}} </td>\n\t *     <td>bt</td><td>{{#crossLink \"Graphics/bezierCurveTo\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>qt</td><td>{{#crossLink \"Graphics/quadraticCurveTo\"}}{{/crossLink}} (also curveTo)</td>\n\t *     <td>r</td><td>{{#crossLink \"Graphics/rect\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>cp</td><td>{{#crossLink \"Graphics/closePath\"}}{{/crossLink}} </td>\n\t *     <td>c</td><td>{{#crossLink \"Graphics/clear\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>f</td><td>{{#crossLink \"Graphics/beginFill\"}}{{/crossLink}} </td>\n\t *     <td>lf</td><td>{{#crossLink \"Graphics/beginLinearGradientFill\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>rf</td><td>{{#crossLink \"Graphics/beginRadialGradientFill\"}}{{/crossLink}} </td>\n\t *     <td>bf</td><td>{{#crossLink \"Graphics/beginBitmapFill\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>ef</td><td>{{#crossLink \"Graphics/endFill\"}}{{/crossLink}} </td>\n\t *     <td>ss / sd</td><td>{{#crossLink \"Graphics/setStrokeStyle\"}}{{/crossLink}} / {{#crossLink \"Graphics/setStrokeDash\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>s</td><td>{{#crossLink \"Graphics/beginStroke\"}}{{/crossLink}} </td>\n\t *     <td>ls</td><td>{{#crossLink \"Graphics/beginLinearGradientStroke\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>rs</td><td>{{#crossLink \"Graphics/beginRadialGradientStroke\"}}{{/crossLink}} </td>\n\t *     <td>bs</td><td>{{#crossLink \"Graphics/beginBitmapStroke\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>es</td><td>{{#crossLink \"Graphics/endStroke\"}}{{/crossLink}} </td>\n\t *     <td>dr</td><td>{{#crossLink \"Graphics/drawRect\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>rr</td><td>{{#crossLink \"Graphics/drawRoundRect\"}}{{/crossLink}} </td>\n\t *     <td>rc</td><td>{{#crossLink \"Graphics/drawRoundRectComplex\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>dc</td><td>{{#crossLink \"Graphics/drawCircle\"}}{{/crossLink}} </td>\n\t *     <td>de</td><td>{{#crossLink \"Graphics/drawEllipse\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>dp</td><td>{{#crossLink \"Graphics/drawPolyStar\"}}{{/crossLink}} </td>\n\t *     <td>p</td><td>{{#crossLink \"Graphics/decodePath\"}}{{/crossLink}} </td></tr>\n\t * </table>\n\t *\n\t * Here is the above example, using the tiny API instead.\n\t *\n\t *      myGraphics.s(\"red\").f(\"blue\").r(20, 20, 100, 50);\n\t *\n\t * @class Graphics\n\t * @constructor\n\t **/\n\tfunction Graphics() {\n\n\n\t// public properties\n\t\t/**\n\t\t * Holds a reference to the last command that was created or appended. For example, you could retain a reference\n\t\t * to a Fill command in order to dynamically update the color later by using:\n\t\t *\n\t\t * \t\tvar myFill = myGraphics.beginFill(\"red\").command;\n\t\t * \t\t// update color later:\n\t\t * \t\tmyFill.style = \"yellow\";\n\t\t *\n\t\t * @property command\n\t\t * @type Object\n\t\t **/\n\t\tthis.command = null;\n\n\n\t// private properties\n\t\t/**\n\t\t * @property _stroke\n\t\t * @protected\n\t\t * @type {Stroke}\n\t\t **/\n\t\tthis._stroke = null;\n\n\t\t/**\n\t\t * @property _strokeStyle\n\t\t * @protected\n\t\t * @type {StrokeStyle}\n\t\t **/\n\t\tthis._strokeStyle = null;\n\t\t\n\t\t/**\n\t\t * @property _oldStrokeStyle\n\t\t * @protected\n\t\t * @type {StrokeStyle}\n\t\t **/\n\t\tthis._oldStrokeStyle = null;\n\t\t\n\t\t/**\n\t\t * @property _strokeDash\n\t\t * @protected\n\t\t * @type {StrokeDash}\n\t\t **/\n\t\tthis._strokeDash = null;\n\t\t\n\t\t/**\n\t\t * @property _oldStrokeDash\n\t\t * @protected\n\t\t * @type {StrokeDash}\n\t\t **/\n\t\tthis._oldStrokeDash = null;\n\n\t\t/**\n\t\t * @property _strokeIgnoreScale\n\t\t * @protected\n\t\t * @type Boolean\n\t\t **/\n\t\tthis._strokeIgnoreScale = false;\n\n\t\t/**\n\t\t * @property _fill\n\t\t * @protected\n\t\t * @type {Fill}\n\t\t **/\n\t\tthis._fill = null;\n\n\t\t/**\n\t\t * @property _instructions\n\t\t * @protected\n\t\t * @type {Array}\n\t\t **/\n\t\tthis._instructions = [];\n\n\t\t/**\n\t\t * Indicates the last instruction index that was committed.\n\t\t * @property _commitIndex\n\t\t * @protected\n\t\t * @type {Number}\n\t\t **/\n\t\tthis._commitIndex = 0;\n\n\t\t/**\n\t\t * Uncommitted instructions.\n\t\t * @property _activeInstructions\n\t\t * @protected\n\t\t * @type {Array}\n\t\t **/\n\t\tthis._activeInstructions = [];\n\n\t\t/**\n\t\t * This indicates that there have been changes to the activeInstruction list since the last updateInstructions call.\n\t\t * @property _dirty\n\t\t * @protected\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t **/\n\t\tthis._dirty = false;\n\n\t\t/**\n\t\t * Index to draw from if a store operation has happened.\n\t\t * @property _storeIndex\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis._storeIndex = 0;\n\n\t// setup:\n\t\tthis.clear();\n\t}\n\tvar p = Graphics.prototype;\n\tvar G = Graphics; // shortcut\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// static public methods:\n\t/**\n\t * Returns a CSS compatible color string based on the specified RGB numeric color values in the format\n\t * \"rgba(255,255,255,1.0)\", or if alpha is null then in the format \"rgb(255,255,255)\". For example,\n\t *\n\t *      createjs.Graphics.getRGB(50, 100, 150, 0.5);\n\t *      // Returns \"rgba(50,100,150,0.5)\"\n\t *\n\t * It also supports passing a single hex color value as the first param, and an optional alpha value as the second\n\t * param. For example,\n\t *\n\t *      createjs.Graphics.getRGB(0xFF00FF, 0.2);\n\t *      // Returns \"rgba(255,0,255,0.2)\"\n\t *\n\t * @method getRGB\n\t * @static\n\t * @param {Number} r The red component for the color, between 0 and 0xFF (255).\n\t * @param {Number} g The green component for the color, between 0 and 0xFF (255).\n\t * @param {Number} b The blue component for the color, between 0 and 0xFF (255).\n\t * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.\n\t * @return {String} A CSS compatible color string based on the specified RGB numeric color values in the format\n\t * \"rgba(255,255,255,1.0)\", or if alpha is null then in the format \"rgb(255,255,255)\".\n\t **/\n\tGraphics.getRGB = function(r, g, b, alpha) {\n\t\tif (r != null && b == null) {\n\t\t\talpha = g;\n\t\t\tb = r&0xFF;\n\t\t\tg = r>>8&0xFF;\n\t\t\tr = r>>16&0xFF;\n\t\t}\n\t\tif (alpha == null) {\n\t\t\treturn \"rgb(\"+r+\",\"+g+\",\"+b+\")\";\n\t\t} else {\n\t\t\treturn \"rgba(\"+r+\",\"+g+\",\"+b+\",\"+alpha+\")\";\n\t\t}\n\t};\n\n\t/**\n\t * Returns a CSS compatible color string based on the specified HSL numeric color values in the format \"hsla(360,100,100,1.0)\",\n\t * or if alpha is null then in the format \"hsl(360,100,100)\".\n\t *\n\t *      createjs.Graphics.getHSL(150, 100, 70);\n\t *      // Returns \"hsl(150,100,70)\"\n\t *\n\t * @method getHSL\n\t * @static\n\t * @param {Number} hue The hue component for the color, between 0 and 360.\n\t * @param {Number} saturation The saturation component for the color, between 0 and 100.\n\t * @param {Number} lightness The lightness component for the color, between 0 and 100.\n\t * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.\n\t * @return {String} A CSS compatible color string based on the specified HSL numeric color values in the format\n\t * \"hsla(360,100,100,1.0)\", or if alpha is null then in the format \"hsl(360,100,100)\".\n\t **/\n\tGraphics.getHSL = function(hue, saturation, lightness, alpha) {\n\t\tif (alpha == null) {\n\t\t\treturn \"hsl(\"+(hue%360)+\",\"+saturation+\"%,\"+lightness+\"%)\";\n\t\t} else {\n\t\t\treturn \"hsla(\"+(hue%360)+\",\"+saturation+\"%,\"+lightness+\"%,\"+alpha+\")\";\n\t\t}\n\t};\n\n\n// static properties:\n\t/**\n\t * A reusable instance of {{#crossLink \"Graphics/BeginPath\"}}{{/crossLink}} to avoid\n\t * unnecessary instantiation.\n\t * @property beginCmd\n\t * @type {Graphics.BeginPath}\n\t * @static\n\t **/\n\t // defined at the bottom of this file.\n\n\t/**\n\t * Map of Base64 characters to values. Used by {{#crossLink \"Graphics/decodePath\"}}{{/crossLink}}.\n\t * @property BASE_64\n\t * @static\n\t * @final\n\t * @readonly\n\t * @type {Object}\n\t **/\n\tGraphics.BASE_64 = {\"A\":0,\"B\":1,\"C\":2,\"D\":3,\"E\":4,\"F\":5,\"G\":6,\"H\":7,\"I\":8,\"J\":9,\"K\":10,\"L\":11,\"M\":12,\"N\":13,\"O\":14,\"P\":15,\"Q\":16,\"R\":17,\"S\":18,\"T\":19,\"U\":20,\"V\":21,\"W\":22,\"X\":23,\"Y\":24,\"Z\":25,\"a\":26,\"b\":27,\"c\":28,\"d\":29,\"e\":30,\"f\":31,\"g\":32,\"h\":33,\"i\":34,\"j\":35,\"k\":36,\"l\":37,\"m\":38,\"n\":39,\"o\":40,\"p\":41,\"q\":42,\"r\":43,\"s\":44,\"t\":45,\"u\":46,\"v\":47,\"w\":48,\"x\":49,\"y\":50,\"z\":51,\"0\":52,\"1\":53,\"2\":54,\"3\":55,\"4\":56,\"5\":57,\"6\":58,\"7\":59,\"8\":60,\"9\":61,\"+\":62,\"/\":63};\n\n\t/**\n\t * Maps numeric values for the caps parameter of {{#crossLink \"Graphics/setStrokeStyle\"}}{{/crossLink}} to\n\t * corresponding string values. This is primarily for use with the tiny API. The mappings are as follows: 0 to\n\t * \"butt\", 1 to \"round\", and 2 to \"square\".\n\t * For example, to set the line caps to \"square\":\n\t *\n\t *      myGraphics.ss(16, 2);\n\t *\n\t * @property STROKE_CAPS_MAP\n\t * @static\n\t * @final\n\t * @readonly\n\t * @type {Array}\n\t **/\n\tGraphics.STROKE_CAPS_MAP = [\"butt\", \"round\", \"square\"];\n\n\t/**\n\t * Maps numeric values for the joints parameter of {{#crossLink \"Graphics/setStrokeStyle\"}}{{/crossLink}} to\n\t * corresponding string values. This is primarily for use with the tiny API. The mappings are as follows: 0 to\n\t * \"miter\", 1 to \"round\", and 2 to \"bevel\".\n\t * For example, to set the line joints to \"bevel\":\n\t *\n\t *      myGraphics.ss(16, 0, 2);\n\t *\n\t * @property STROKE_JOINTS_MAP\n\t * @static\n\t * @final\n\t * @readonly\n\t * @type {Array}\n\t **/\n\tGraphics.STROKE_JOINTS_MAP = [\"miter\", \"round\", \"bevel\"];\n\n\t/**\n\t * @property _ctx\n\t * @static\n\t * @protected\n\t * @type {CanvasRenderingContext2D}\n\t **/\n\tvar canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement(\"canvas\"));\n\tif (canvas.getContext) {\n\t\tGraphics._ctx = canvas.getContext(\"2d\");\n\t\tcanvas.width = canvas.height = 1;\n\t}\n\n\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink \"Graphics/instructions:property\"}}{{/crossLink}} property instead.\n\t * @method getInstructions\n\t * @return {Array}\n\t * @deprecated\n\t **/\n\tp.getInstructions = function() {\n\t\tthis._updateInstructions();\n\t\treturn this._instructions;\n\t};\n\n\t/**\n\t * Returns the graphics instructions array. Each entry is a graphics command object (ex. Graphics.Fill, Graphics.Rect)\n\t * Modifying the returned array directly is not recommended, and is likely to result in unexpected behaviour.\n\t *\n\t * This property is mainly intended for introspection of the instructions (ex. for graphics export).\n\t * @property instructions\n\t * @type {Array}\n\t * @readonly\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tinstructions: { get: p.getInstructions }\n\t\t});\n\t} catch (e) {}\n\n\n// public methods:\n\t/**\n\t * Returns true if this Graphics instance has no drawing commands.\n\t * @method isEmpty\n\t * @return {Boolean} Returns true if this Graphics instance has no drawing commands.\n\t **/\n\tp.isEmpty = function() {\n\t\treturn !(this._instructions.length || this._activeInstructions.length);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Object} data Optional data that is passed to graphics command exec methods. When called from a Shape instance, the shape passes itself as the data parameter. This can be used by custom graphic commands to insert contextual data.\n\t **/\n\tp.draw = function(ctx, data) {\n\t\tthis._updateInstructions();\n\t\tvar instr = this._instructions;\n\t\tfor (var i=this._storeIndex, l=instr.length; i<l; i++) {\n\t\t\tinstr[i].exec(ctx, data);\n\t\t}\n\t};\n\n\t/**\n\t * Draws only the path described for this Graphics instance, skipping any non-path instructions, including fill and\n\t * stroke descriptions. Used for <code>DisplayObject.mask</code> to draw the clipping path, for example.\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method drawAsPath\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t **/\n\tp.drawAsPath = function(ctx) {\n\t\tthis._updateInstructions();\n\t\tvar instr, instrs = this._instructions;\n\t\tfor (var i=this._storeIndex, l=instrs.length; i<l; i++) {\n\t\t\t// the first command is always a beginPath command.\n\t\t\tif ((instr = instrs[i]).path !== false) { instr.exec(ctx); }\n\t\t}\n\t};\n\n\n// public methods that map directly to context 2D calls:\n\t/**\n\t * Moves the drawing point to the specified position. A tiny API method \"mt\" also exists.\n\t * @method moveTo\n\t * @param {Number} x The x coordinate the drawing point should move to.\n\t * @param {Number} y The y coordinate the drawing point should move to.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls).\n\t * @chainable\n\t **/\n\tp.moveTo = function(x, y) {\n\t\treturn this.append(new G.MoveTo(x,y), true);\n\t};\n\n\t/**\n\t * Draws a line from the current drawing point to the specified position, which become the new current drawing\n\t * point. Note that you *must* call {{#crossLink \"Graphics/moveTo\"}}{{/crossLink}} before the first `lineTo()`.\n\t * A tiny API method \"lt\" also exists.\n\t *\n\t * For detailed information, read the\n\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#complex-shapes-(paths)\">\n\t * whatwg spec</a>.\n\t * @method lineTo\n\t * @param {Number} x The x coordinate the drawing point should draw to.\n\t * @param {Number} y The y coordinate the drawing point should draw to.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.lineTo = function(x, y) {\n\t\treturn this.append(new G.LineTo(x,y));\n\t};\n\n\t/**\n\t * Draws an arc with the specified control points and radius.  For detailed information, read the\n\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arcto\">\n\t * whatwg spec</a>. A tiny API method \"at\" also exists.\n\t * @method arcTo\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @param {Number} x2\n\t * @param {Number} y2\n\t * @param {Number} radius\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.arcTo = function(x1, y1, x2, y2, radius) {\n\t\treturn this.append(new G.ArcTo(x1, y1, x2, y2, radius));\n\t};\n\n\t/**\n\t * Draws an arc defined by the radius, startAngle and endAngle arguments, centered at the position (x, y). For\n\t * example, to draw a full circle with a radius of 20 centered at (100, 100):\n\t *\n\t *      arc(100, 100, 20, 0, Math.PI*2);\n\t *\n\t * For detailed information, read the\n\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc\">whatwg spec</a>.\n\t * A tiny API method \"a\" also exists.\n\t * @method arc\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} radius\n\t * @param {Number} startAngle Measured in radians.\n\t * @param {Number} endAngle Measured in radians.\n\t * @param {Boolean} anticlockwise\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {\n\t\treturn this.append(new G.Arc(x, y, radius, startAngle, endAngle, anticlockwise));\n\t};\n\n\t/**\n\t * Draws a quadratic curve from the current drawing point to (x, y) using the control point (cpx, cpy). For detailed\n\t * information, read the <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto\">\n\t * whatwg spec</a>. A tiny API method \"qt\" also exists.\n\t * @method quadraticCurveTo\n\t * @param {Number} cpx\n\t * @param {Number} cpy\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.quadraticCurveTo = function(cpx, cpy, x, y) {\n\t\treturn this.append(new G.QuadraticCurveTo(cpx, cpy, x, y));\n\t};\n\n\t/**\n\t * Draws a bezier curve from the current drawing point to (x, y) using the control points (cp1x, cp1y) and (cp2x,\n\t * cp2y). For detailed information, read the\n\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-beziercurveto\">\n\t * whatwg spec</a>. A tiny API method \"bt\" also exists.\n\t * @method bezierCurveTo\n\t * @param {Number} cp1x\n\t * @param {Number} cp1y\n\t * @param {Number} cp2x\n\t * @param {Number} cp2y\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {\n\t\treturn this.append(new G.BezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y));\n\t};\n\n\t/**\n\t * Draws a rectangle at (x, y) with the specified width and height using the current fill and/or stroke.\n\t * For detailed information, read the\n\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-rect\">\n\t * whatwg spec</a>. A tiny API method \"r\" also exists.\n\t * @method rect\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w Width of the rectangle\n\t * @param {Number} h Height of the rectangle\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.rect = function(x, y, w, h) {\n\t\treturn this.append(new G.Rect(x, y, w, h));\n\t};\n\n\t/**\n\t * Closes the current path, effectively drawing a line from the current drawing point to the first drawing point specified\n\t * since the fill or stroke was last set. A tiny API method \"cp\" also exists.\n\t * @method closePath\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.closePath = function() {\n\t\treturn this._activeInstructions.length ? this.append(new G.ClosePath()) : this;\n\t};\n\n\n// public methods that roughly map to Flash graphics APIs:\n\t/**\n\t * Clears all drawing instructions, effectively resetting this Graphics instance. Any line and fill styles will need\n\t * to be redefined to draw shapes following a clear call. A tiny API method \"c\" also exists.\n\t * @method clear\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.clear = function() {\n\t\tthis._instructions.length = this._activeInstructions.length = this._commitIndex = 0;\n\t\tthis._strokeStyle = this._oldStrokeStyle = this._stroke = this._fill = this._strokeDash = this._oldStrokeDash = null;\n\t\tthis._dirty = this._strokeIgnoreScale = false;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Begins a fill with the specified color. This ends the current sub-path. A tiny API method \"f\" also exists.\n\t * @method beginFill\n\t * @param {String} color A CSS compatible color value (ex. \"red\", \"#FF0000\", or \"rgba(255,0,0,0.5)\"). Setting to\n\t * null will result in no fill.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginFill = function(color) {\n\t\treturn this._setFill(color ? new G.Fill(color) : null);\n\t};\n\n\t/**\n\t * Begins a linear gradient fill defined by the line (x0, y0) to (x1, y1). This ends the current sub-path. For\n\t * example, the following code defines a black to white vertical gradient ranging from 20px to 120px, and draws a\n\t * square to display it:\n\t *\n\t *      myGraphics.beginLinearGradientFill([\"#000\",\"#FFF\"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);\n\t *\n\t * A tiny API method \"lf\" also exists.\n\t * @method beginLinearGradientFill\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define a gradient\n\t * drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw\n\t * the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginLinearGradientFill = function(colors, ratios, x0, y0, x1, y1) {\n\t\treturn this._setFill(new G.Fill().linearGradient(colors, ratios, x0, y0, x1, y1));\n\t};\n\n\t/**\n\t * Begins a radial gradient fill. This ends the current sub-path. For example, the following code defines a red to\n\t * blue radial gradient centered at (100, 100), with a radius of 50, and draws a circle to display it:\n\t *\n\t *      myGraphics.beginRadialGradientFill([\"#F00\",\"#00F\"], [0, 1], 100, 100, 0, 100, 100, 50).drawCircle(100, 100, 50);\n\t *\n\t * A tiny API method \"rf\" also exists.\n\t * @method beginRadialGradientFill\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} y0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} r0 Radius of the inner circle that defines the gradient.\n\t * @param {Number} x1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} y1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} r1 Radius of the outer circle that defines the gradient.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginRadialGradientFill = function(colors, ratios, x0, y0, r0, x1, y1, r1) {\n\t\treturn this._setFill(new G.Fill().radialGradient(colors, ratios, x0, y0, r0, x1, y1, r1));\n\t};\n\n\t/**\n\t * Begins a pattern fill using the specified image. This ends the current sub-path. A tiny API method \"bf\" also\n\t * exists.\n\t * @method beginBitmapFill\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use\n\t * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.\n\t * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of \"repeat\",\n\t * \"repeat-x\", \"repeat-y\", or \"no-repeat\". Defaults to \"repeat\". Note that Firefox does not support \"repeat-x\" or\n\t * \"repeat-y\" (latest tests were in FF 20.0), and will default to \"repeat\".\n\t * @param {Matrix2D} matrix Optional. Specifies a transformation matrix for the bitmap fill. This transformation\n\t * will be applied relative to the parent transform.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginBitmapFill = function(image, repetition, matrix) {\n\t\treturn this._setFill(new G.Fill(null,matrix).bitmap(image, repetition));\n\t};\n\n\t/**\n\t * Ends the current sub-path, and begins a new one with no fill. Functionally identical to <code>beginFill(null)</code>.\n\t * A tiny API method \"ef\" also exists.\n\t * @method endFill\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.endFill = function() {\n\t\treturn this.beginFill();\n\t};\n\n\t/**\n\t * Sets the stroke style. Like all drawing methods, this can be chained, so you can define\n\t * the stroke style and color in a single line of code like so:\n\t *\n\t * \tmyGraphics.setStrokeStyle(8,\"round\").beginStroke(\"#F00\");\n\t *\n\t * A tiny API method \"ss\" also exists.\n\t * @method setStrokeStyle\n\t * @param {Number} thickness The width of the stroke.\n\t * @param {String | Number} [caps=0] Indicates the type of caps to use at the end of lines. One of butt,\n\t * round, or square. Defaults to \"butt\". Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with\n\t * the tiny API.\n\t * @param {String | Number} [joints=0] Specifies the type of joints that should be used where two lines meet.\n\t * One of bevel, round, or miter. Defaults to \"miter\". Also accepts the values 0 (miter), 1 (round), and 2 (bevel)\n\t * for use with the tiny API.\n\t * @param {Number} [miterLimit=10] If joints is set to \"miter\", then you can specify a miter limit ratio which\n\t * controls at what point a mitered joint will be clipped.\n\t * @param {Boolean} [ignoreScale=false] If true, the stroke will be drawn at the specified thickness regardless\n\t * of active transformations.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.setStrokeStyle = function(thickness, caps, joints, miterLimit, ignoreScale) {\n\t\tthis._updateInstructions(true);\n\t\tthis._strokeStyle = this.command = new G.StrokeStyle(thickness, caps, joints, miterLimit, ignoreScale);\n\n\t\t// ignoreScale lives on Stroke, not StrokeStyle, so we do a little trickery:\n\t\tif (this._stroke) { this._stroke.ignoreScale = ignoreScale; }\n\t\tthis._strokeIgnoreScale = ignoreScale;\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Sets or clears the stroke dash pattern.\n\t *\n\t * \tmyGraphics.setStrokeDash([20, 10], 0);\n\t *\n\t * A tiny API method `sd` also exists.\n\t * @method setStrokeDash\n\t * @param {Array} [segments] An array specifying the dash pattern, alternating between line and gap.\n\t * For example, `[20,10]` would create a pattern of 20 pixel lines with 10 pixel gaps between them.\n\t * Passing null or an empty array will clear the existing stroke dash.\n\t * @param {Number} [offset=0] The offset of the dash pattern. For example, you could increment this value to create a \"marching ants\" effect.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.setStrokeDash = function(segments, offset) {\n\t\tthis._updateInstructions(true);\n\t\tthis._strokeDash = this.command = new G.StrokeDash(segments, offset);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Begins a stroke with the specified color. This ends the current sub-path. A tiny API method \"s\" also exists.\n\t * @method beginStroke\n\t * @param {String} color A CSS compatible color value (ex. \"#FF0000\", \"red\", or \"rgba(255,0,0,0.5)\"). Setting to\n\t * null will result in no stroke.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginStroke = function(color) {\n\t\treturn this._setStroke(color ? new G.Stroke(color) : null);\n\t};\n\n\t/**\n\t * Begins a linear gradient stroke defined by the line (x0, y0) to (x1, y1). This ends the current sub-path. For\n\t * example, the following code defines a black to white vertical gradient ranging from 20px to 120px, and draws a\n\t * square to display it:\n\t *\n\t *      myGraphics.setStrokeStyle(10).\n\t *          beginLinearGradientStroke([\"#000\",\"#FFF\"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);\n\t *\n\t * A tiny API method \"ls\" also exists.\n\t * @method beginLinearGradientStroke\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginLinearGradientStroke = function(colors, ratios, x0, y0, x1, y1) {\n\t\treturn this._setStroke(new G.Stroke().linearGradient(colors, ratios, x0, y0, x1, y1));\n\t};\n\n\t/**\n\t * Begins a radial gradient stroke. This ends the current sub-path. For example, the following code defines a red to\n\t * blue radial gradient centered at (100, 100), with a radius of 50, and draws a rectangle to display it:\n\t *\n\t *      myGraphics.setStrokeStyle(10)\n\t *          .beginRadialGradientStroke([\"#F00\",\"#00F\"], [0, 1], 100, 100, 0, 100, 100, 50)\n\t *          .drawRect(50, 90, 150, 110);\n\t *\n\t * A tiny API method \"rs\" also exists.\n\t * @method beginRadialGradientStroke\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color\n\t * to 100%.\n\t * @param {Number} x0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} y0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} r0 Radius of the inner circle that defines the gradient.\n\t * @param {Number} x1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} y1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} r1 Radius of the outer circle that defines the gradient.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginRadialGradientStroke = function(colors, ratios, x0, y0, r0, x1, y1, r1) {\n\t\treturn this._setStroke(new G.Stroke().radialGradient(colors, ratios, x0, y0, r0, x1, y1, r1));\n\t};\n\n\t/**\n\t * Begins a pattern fill using the specified image. This ends the current sub-path. Note that unlike bitmap fills,\n\t * strokes do not currently support a matrix parameter due to limitations in the canvas API. A tiny API method \"bs\"\n\t * also exists.\n\t * @method beginBitmapStroke\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use\n\t * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.\n\t * @param {String} [repetition=repeat] Optional. Indicates whether to repeat the image in the fill area. One of\n\t * \"repeat\", \"repeat-x\", \"repeat-y\", or \"no-repeat\". Defaults to \"repeat\".\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginBitmapStroke = function(image, repetition) {\n\t\t// NOTE: matrix is not supported for stroke because transforms on strokes also affect the drawn stroke width.\n\t\treturn this._setStroke(new G.Stroke().bitmap(image, repetition));\n\t};\n\n\t/**\n\t * Ends the current sub-path, and begins a new one with no stroke. Functionally identical to <code>beginStroke(null)</code>.\n\t * A tiny API method \"es\" also exists.\n\t * @method endStroke\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.endStroke = function() {\n\t\treturn this.beginStroke();\n\t};\n\n\t/**\n\t * Maps the familiar ActionScript <code>curveTo()</code> method to the functionally similar {{#crossLink \"Graphics/quadraticCurveTo\"}}{{/crossLink}}\n\t * method.\n\t * @method quadraticCurveTo\n\t * @param {Number} cpx\n\t * @param {Number} cpy\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.curveTo = p.quadraticCurveTo;\n\n\t/**\n\t *\n\t * Maps the familiar ActionScript <code>drawRect()</code> method to the functionally similar {{#crossLink \"Graphics/rect\"}}{{/crossLink}}\n\t * method.\n\t * @method drawRect\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w Width of the rectangle\n\t * @param {Number} h Height of the rectangle\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawRect = p.rect;\n\n\t/**\n\t * Draws a rounded rectangle with all corners with the specified radius.\n\t * @method drawRoundRect\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w\n\t * @param {Number} h\n\t * @param {Number} radius Corner radius.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawRoundRect = function(x, y, w, h, radius) {\n\t\treturn this.drawRoundRectComplex(x, y, w, h, radius, radius, radius, radius);\n\t};\n\n\t/**\n\t * Draws a rounded rectangle with different corner radii. Supports positive and negative corner radii. A tiny API\n\t * method \"rc\" also exists.\n\t * @method drawRoundRectComplex\n\t * @param {Number} x The horizontal coordinate to draw the round rect.\n\t * @param {Number} y The vertical coordinate to draw the round rect.\n\t * @param {Number} w The width of the round rect.\n\t * @param {Number} h The height of the round rect.\n\t * @param {Number} radiusTL Top left corner radius.\n\t * @param {Number} radiusTR Top right corner radius.\n\t * @param {Number} radiusBR Bottom right corner radius.\n\t * @param {Number} radiusBL Bottom left corner radius.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawRoundRectComplex = function(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {\n\t\treturn this.append(new G.RoundRect(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL));\n\t};\n\n\t/**\n\t * Draws a circle with the specified radius at (x, y).\n\t *\n\t *      var g = new createjs.Graphics();\n\t *\t    g.setStrokeStyle(1);\n\t *\t    g.beginStroke(createjs.Graphics.getRGB(0,0,0));\n\t *\t    g.beginFill(createjs.Graphics.getRGB(255,0,0));\n\t *\t    g.drawCircle(0,0,3);\n\t *\n\t *\t    var s = new createjs.Shape(g);\n\t *\t\ts.x = 100;\n\t *\t\ts.y = 100;\n\t *\n\t *\t    stage.addChild(s);\n\t *\t    stage.update();\n\t *\n\t * A tiny API method \"dc\" also exists.\n\t * @method drawCircle\n\t * @param {Number} x x coordinate center point of circle.\n\t * @param {Number} y y coordinate center point of circle.\n\t * @param {Number} radius Radius of circle.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawCircle = function(x, y, radius) {\n\t\treturn this.append(new G.Circle(x, y, radius));\n\t};\n\n\t/**\n\t * Draws an ellipse (oval) with a specified width (w) and height (h). Similar to {{#crossLink \"Graphics/drawCircle\"}}{{/crossLink}},\n\t * except the width and height can be different. A tiny API method \"de\" also exists.\n\t * @method drawEllipse\n\t * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {{#crossLink \"Graphics/drawCircle\"}}{{/crossLink}}\n\t * which draws from center.\n\t * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {{#crossLink \"Graphics/drawCircle\"}}{{/crossLink}}\n\t * which draws from the center.\n\t * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this\n\t * number.\n\t * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawEllipse = function(x, y, w, h) {\n\t\treturn this.append(new G.Ellipse(x, y, w, h));\n\t};\n\n\t/**\n\t * Draws a star if pointSize is greater than 0, or a regular polygon if pointSize is 0 with the specified number of\n\t * points. For example, the following code will draw a familiar 5 pointed star shape centered at 100, 100 and with a\n\t * radius of 50:\n\t *\n\t *      myGraphics.beginFill(\"#FF0\").drawPolyStar(100, 100, 50, 5, 0.6, -90);\n\t *      // Note: -90 makes the first point vertical\n\t *\n\t * A tiny API method \"dp\" also exists.\n\t *\n\t * @method drawPolyStar\n\t * @param {Number} x Position of the center of the shape.\n\t * @param {Number} y Position of the center of the shape.\n\t * @param {Number} radius The outer radius of the shape.\n\t * @param {Number} sides The number of points on the star or sides on the polygon.\n\t * @param {Number} pointSize The depth or \"pointy-ness\" of the star points. A pointSize of 0 will draw a regular\n\t * polygon (no points), a pointSize of 1 will draw nothing because the points are infinitely pointy.\n\t * @param {Number} angle The angle of the first point / corner. For example a value of 0 will draw the first point\n\t * directly to the right of the center.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawPolyStar = function(x, y, radius, sides, pointSize, angle) {\n\t\treturn this.append(new G.PolyStar(x, y, radius, sides, pointSize, angle));\n\t};\n\n\t// TODO: deprecated.\n\t/**\n\t * Removed in favour of using custom command objects with {{#crossLink \"Graphics/append\"}}{{/crossLink}}.\n\t * @method inject\n\t * @deprecated\n\t **/\n\n\t/**\n\t * Appends a graphics command object to the graphics queue. Command objects expose an \"exec\" method\n\t * that accepts two parameters: the Context2D to operate on, and an arbitrary data object passed into\n\t * {{#crossLink \"Graphics/draw\"}}{{/crossLink}}. The latter will usually be the Shape instance that called draw.\n\t *\n\t * This method is used internally by Graphics methods, such as drawCircle, but can also be used directly to insert\n\t * built-in or custom graphics commands. For example:\n\t *\n\t * \t\t// attach data to our shape, so we can access it during the draw:\n\t * \t\tmyShape.color = \"red\";\n\t *\n\t * \t\t// append a Circle command object:\n\t * \t\tmyShape.graphics.append(new createjs.Graphics.Circle(50, 50, 30));\n\t *\n\t * \t\t// append a custom command object with an exec method that sets the fill style\n\t * \t\t// based on the shape's data, and then fills the circle.\n\t * \t\tmyShape.graphics.append({exec:function(ctx, shape) {\n\t * \t\t\tctx.fillStyle = shape.color;\n\t * \t\t\tctx.fill();\n\t * \t\t}});\n\t *\n\t * @method append\n\t * @param {Object} command A graphics command object exposing an \"exec\" method.\n\t * @param {boolean} clean The clean param is primarily for internal use. A value of true indicates that a command does not generate a path that should be stroked or filled.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.append = function(command, clean) {\n\t\tthis._activeInstructions.push(command);\n\t\tthis.command = command;\n\t\tif (!clean) { this._dirty = true; }\n\t\treturn this;\n\t};\n\n\t/**\n\t * Decodes a compact encoded path string into a series of draw instructions.\n\t * This format is not intended to be human readable, and is meant for use by authoring tools.\n\t * The format uses a base64 character set, with each character representing 6 bits, to define a series of draw\n\t * commands.\n\t *\n\t * Each command is comprised of a single \"header\" character followed by a variable number of alternating x and y\n\t * position values. Reading the header bits from left to right (most to least significant): bits 1 to 3 specify the\n\t * type of operation (0-moveTo, 1-lineTo, 2-quadraticCurveTo, 3-bezierCurveTo, 4-closePath, 5-7 unused). Bit 4\n\t * indicates whether position values use 12 bits (2 characters) or 18 bits (3 characters), with a one indicating the\n\t * latter. Bits 5 and 6 are currently unused.\n\t *\n\t * Following the header is a series of 0 (closePath), 2 (moveTo, lineTo), 4 (quadraticCurveTo), or 6 (bezierCurveTo)\n\t * parameters. These parameters are alternating x/y positions represented by 2 or 3 characters (as indicated by the\n\t * 4th bit in the command char). These characters consist of a 1 bit sign (1 is negative, 0 is positive), followed\n\t * by an 11 (2 char) or 17 (3 char) bit integer value. All position values are in tenths of a pixel. Except in the\n\t * case of move operations which are absolute, this value is a delta from the previous x or y position (as\n\t * appropriate).\n\t *\n\t * For example, the string \"A3cAAMAu4AAA\" represents a line starting at -150,0 and ending at 150,0.\n\t * <br />A - bits 000000. First 3 bits (000) indicate a moveTo operation. 4th bit (0) indicates 2 chars per\n\t * parameter.\n\t * <br />n0 - 110111011100. Absolute x position of -150.0px. First bit indicates a negative value, remaining bits\n\t * indicate 1500 tenths of a pixel.\n\t * <br />AA - 000000000000. Absolute y position of 0.\n\t * <br />I - 001100. First 3 bits (001) indicate a lineTo operation. 4th bit (1) indicates 3 chars per parameter.\n\t * <br />Au4 - 000000101110111000. An x delta of 300.0px, which is added to the previous x value of -150.0px to\n\t * provide an absolute position of +150.0px.\n\t * <br />AAA - 000000000000000000. A y delta value of 0.\n\t *\n\t * A tiny API method \"p\" also exists.\n\t * @method decodePath\n\t * @param {String} str The path string to decode.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.decodePath = function(str) {\n\t\tvar instructions = [this.moveTo, this.lineTo, this.quadraticCurveTo, this.bezierCurveTo, this.closePath];\n\t\tvar paramCount = [2, 2, 4, 6, 0];\n\t\tvar i=0, l=str.length;\n\t\tvar params = [];\n\t\tvar x=0, y=0;\n\t\tvar base64 = Graphics.BASE_64;\n\n\t\twhile (i<l) {\n\t\t\tvar c = str.charAt(i);\n\t\t\tvar n = base64[c];\n\t\t\tvar fi = n>>3; // highest order bits 1-3 code for operation.\n\t\t\tvar f = instructions[fi];\n\t\t\t// check that we have a valid instruction & that the unused bits are empty:\n\t\t\tif (!f || (n&3)) { throw(\"bad path data (@\"+i+\"): \"+c); }\n\t\t\tvar pl = paramCount[fi];\n\t\t\tif (!fi) { x=y=0; } // move operations reset the position.\n\t\t\tparams.length = 0;\n\t\t\ti++;\n\t\t\tvar charCount = (n>>2&1)+2;  // 4th header bit indicates number size for this operation.\n\t\t\tfor (var p=0; p<pl; p++) {\n\t\t\t\tvar num = base64[str.charAt(i)];\n\t\t\t\tvar sign = (num>>5) ? -1 : 1;\n\t\t\t\tnum = ((num&31)<<6)|(base64[str.charAt(i+1)]);\n\t\t\t\tif (charCount == 3) { num = (num<<6)|(base64[str.charAt(i+2)]); }\n\t\t\t\tnum = sign*num/10;\n\t\t\t\tif (p%2) { x = (num += x); }\n\t\t\t\telse { y = (num += y); }\n\t\t\t\tparams[p] = num;\n\t\t\t\ti += charCount;\n\t\t\t}\n\t\t\tf.apply(this,params);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Stores all graphics commands so they won't be executed in future draws. Calling store() a second time adds to\n\t * the existing store. This also affects `drawAsPath()`.\n\t *\n\t * This is useful in cases where you are creating vector graphics in an iterative manner (ex. generative art), so\n\t * that only new graphics need to be drawn (which can provide huge performance benefits), but you wish to retain all\n\t * of the vector instructions for later use (ex. scaling, modifying, or exporting).\n\t *\n\t * Note that calling store() will force the active path (if any) to be ended in a manner similar to changing\n\t * the fill or stroke.\n\t *\n\t * For example, consider a application where the user draws lines with the mouse. As each line segment (or collection of\n\t * segments) are added to a Shape, it can be rasterized using {{#crossLink \"DisplayObject/updateCache\"}}{{/crossLink}},\n\t * and then stored, so that it can be redrawn at a different scale when the application is resized, or exported to SVG.\n\t *\n\t * \t// set up cache:\n\t * \tmyShape.cache(0,0,500,500,scale);\n\t *\n\t * \t// when the user drags, draw a new line:\n\t * \tmyShape.graphics.moveTo(oldX,oldY).lineTo(newX,newY);\n\t * \t// then draw it into the existing cache:\n\t * \tmyShape.updateCache(\"source-over\");\n\t * \t// store the new line, so it isn't redrawn next time:\n\t * \tmyShape.store();\n\t *\n\t * \t// then, when the window resizes, we can re-render at a different scale:\n\t * \t// first, unstore all our lines:\n\t * \tmyShape.unstore();\n\t * \t// then cache using the new scale:\n\t * \tmyShape.cache(0,0,500,500,newScale);\n\t * \t// finally, store the existing commands again:\n\t * \tmyShape.store();\n\t *\n\t * @method store\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.store = function() {\n\t\tthis._updateInstructions(true);\n\t\tthis._storeIndex = this._instructions.length;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Unstores any graphics commands that were previously stored using {{#crossLink \"Graphics/store\"}}{{/crossLink}}\n\t * so that they will be executed in subsequent draw calls.\n\t *\n\t * @method unstore\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.unstore = function() {\n\t\tthis._storeIndex = 0;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Returns a clone of this Graphics instance. Note that the individual command objects are not cloned.\n\t * @method clone\n\t * @return {Graphics} A clone of the current Graphics instance.\n\t **/\n\tp.clone = function() {\n\t\tvar o = new Graphics();\n\t\to.command = this.command;\n\t\to._stroke = this._stroke;\n\t\to._strokeStyle = this._strokeStyle;\n\t\to._strokeDash = this._strokeDash;\n\t\to._strokeIgnoreScale = this._strokeIgnoreScale;\n\t\to._fill = this._fill;\n\t\to._instructions = this._instructions.slice();\n\t\to._commitIndex = this._commitIndex;\n\t\to._activeInstructions = this._activeInstructions.slice();\n\t\to._dirty = this._dirty;\n\t\to._storeIndex = this._storeIndex;\n\t\treturn o;\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Graphics]\";\n\t};\n\n\n// tiny API:\n\t/**\n\t * Shortcut to moveTo.\n\t * @method mt\n\t * @param {Number} x The x coordinate the drawing point should move to.\n\t * @param {Number} y The y coordinate the drawing point should move to.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls).\n\t * @chainable\n\t * @protected\n\t **/\n\tp.mt = p.moveTo;\n\n\t/**\n\t * Shortcut to lineTo.\n\t * @method lt\n\t * @param {Number} x The x coordinate the drawing point should draw to.\n\t * @param {Number} y The y coordinate the drawing point should draw to.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.lt = p.lineTo;\n\n\t/**\n\t * Shortcut to arcTo.\n\t * @method at\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @param {Number} x2\n\t * @param {Number} y2\n\t * @param {Number} radius\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.at = p.arcTo;\n\n\t/**\n\t * Shortcut to bezierCurveTo.\n\t * @method bt\n\t * @param {Number} cp1x\n\t * @param {Number} cp1y\n\t * @param {Number} cp2x\n\t * @param {Number} cp2y\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.bt = p.bezierCurveTo;\n\n\t/**\n\t * Shortcut to quadraticCurveTo / curveTo.\n\t * @method qt\n\t * @param {Number} cpx\n\t * @param {Number} cpy\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @protected\n\t * @chainable\n\t **/\n\tp.qt = p.quadraticCurveTo;\n\n\t/**\n\t * Shortcut to arc.\n\t * @method a\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} radius\n\t * @param {Number} startAngle Measured in radians.\n\t * @param {Number} endAngle Measured in radians.\n\t * @param {Boolean} anticlockwise\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @protected\n\t * @chainable\n\t **/\n\tp.a = p.arc;\n\n\t/**\n\t * Shortcut to rect.\n\t * @method r\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w Width of the rectangle\n\t * @param {Number} h Height of the rectangle\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.r = p.rect;\n\n\t/**\n\t * Shortcut to closePath.\n\t * @method cp\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.cp = p.closePath;\n\n\t/**\n\t * Shortcut to clear.\n\t * @method c\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.c = p.clear;\n\n\t/**\n\t * Shortcut to beginFill.\n\t * @method f\n\t * @param {String} color A CSS compatible color value (ex. \"red\", \"#FF0000\", or \"rgba(255,0,0,0.5)\"). Setting to\n\t * null will result in no fill.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.f = p.beginFill;\n\n\t/**\n\t * Shortcut to beginLinearGradientFill.\n\t * @method lf\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define a gradient\n\t * drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw\n\t * the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.lf = p.beginLinearGradientFill;\n\n\t/**\n\t * Shortcut to beginRadialGradientFill.\n\t * @method rf\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} y0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} r0 Radius of the inner circle that defines the gradient.\n\t * @param {Number} x1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} y1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} r1 Radius of the outer circle that defines the gradient.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.rf = p.beginRadialGradientFill;\n\n\t/**\n\t * Shortcut to beginBitmapFill.\n\t * @method bf\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use\n\t * as the pattern.\n\t * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of \"repeat\",\n\t * \"repeat-x\", \"repeat-y\", or \"no-repeat\". Defaults to \"repeat\". Note that Firefox does not support \"repeat-x\" or\n\t * \"repeat-y\" (latest tests were in FF 20.0), and will default to \"repeat\".\n\t * @param {Matrix2D} matrix Optional. Specifies a transformation matrix for the bitmap fill. This transformation\n\t * will be applied relative to the parent transform.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.bf = p.beginBitmapFill;\n\n\t/**\n\t * Shortcut to endFill.\n\t * @method ef\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.ef = p.endFill;\n\n\t/**\n\t * Shortcut to setStrokeStyle.\n\t * @method ss\n\t * @param {Number} thickness The width of the stroke.\n\t * @param {String | Number} [caps=0] Indicates the type of caps to use at the end of lines. One of butt,\n\t * round, or square. Defaults to \"butt\". Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with\n\t * the tiny API.\n\t * @param {String | Number} [joints=0] Specifies the type of joints that should be used where two lines meet.\n\t * One of bevel, round, or miter. Defaults to \"miter\". Also accepts the values 0 (miter), 1 (round), and 2 (bevel)\n\t * for use with the tiny API.\n\t * @param {Number} [miterLimit=10] If joints is set to \"miter\", then you can specify a miter limit ratio which\n\t * controls at what point a mitered joint will be clipped.\n\t * @param {Boolean} [ignoreScale=false] If true, the stroke will be drawn at the specified thickness regardless\n\t * of active transformations.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.ss = p.setStrokeStyle;\n\t\n\t/**\n\t * Shortcut to setStrokeDash.\n\t * @method sd\n\t * @param {Array} [segments] An array specifying the dash pattern, alternating between line and gap.\n\t * For example, [20,10] would create a pattern of 20 pixel lines with 10 pixel gaps between them.\n\t * Passing null or an empty array will clear any existing dash.\n\t * @param {Number} [offset=0] The offset of the dash pattern. For example, you could increment this value to create a \"marching ants\" effect.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.sd = p.setStrokeDash;\n\n\t/**\n\t * Shortcut to beginStroke.\n\t * @method s\n\t * @param {String} color A CSS compatible color value (ex. \"#FF0000\", \"red\", or \"rgba(255,0,0,0.5)\"). Setting to\n\t * null will result in no stroke.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.s = p.beginStroke;\n\n\t/**\n\t * Shortcut to beginLinearGradientStroke.\n\t * @method ls\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.ls = p.beginLinearGradientStroke;\n\n\t/**\n\t * Shortcut to beginRadialGradientStroke.\n\t * @method rs\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color\n\t * to 100%.\n\t * @param {Number} x0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} y0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} r0 Radius of the inner circle that defines the gradient.\n\t * @param {Number} x1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} y1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} r1 Radius of the outer circle that defines the gradient.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.rs = p.beginRadialGradientStroke;\n\n\t/**\n\t * Shortcut to beginBitmapStroke.\n\t * @method bs\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use\n\t * as the pattern.\n\t * @param {String} [repetition=repeat] Optional. Indicates whether to repeat the image in the fill area. One of\n\t * \"repeat\", \"repeat-x\", \"repeat-y\", or \"no-repeat\". Defaults to \"repeat\".\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.bs = p.beginBitmapStroke;\n\n\t/**\n\t * Shortcut to endStroke.\n\t * @method es\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.es = p.endStroke;\n\n\t/**\n\t * Shortcut to drawRect.\n\t * @method dr\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w Width of the rectangle\n\t * @param {Number} h Height of the rectangle\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.dr = p.drawRect;\n\n\t/**\n\t * Shortcut to drawRoundRect.\n\t * @method rr\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w\n\t * @param {Number} h\n\t * @param {Number} radius Corner radius.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.rr = p.drawRoundRect;\n\n\t/**\n\t * Shortcut to drawRoundRectComplex.\n\t * @method rc\n\t * @param {Number} x The horizontal coordinate to draw the round rect.\n\t * @param {Number} y The vertical coordinate to draw the round rect.\n\t * @param {Number} w The width of the round rect.\n\t * @param {Number} h The height of the round rect.\n\t * @param {Number} radiusTL Top left corner radius.\n\t * @param {Number} radiusTR Top right corner radius.\n\t * @param {Number} radiusBR Bottom right corner radius.\n\t * @param {Number} radiusBL Bottom left corner radius.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.rc = p.drawRoundRectComplex;\n\n\t/**\n\t * Shortcut to drawCircle.\n\t * @method dc\n\t * @param {Number} x x coordinate center point of circle.\n\t * @param {Number} y y coordinate center point of circle.\n\t * @param {Number} radius Radius of circle.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.dc = p.drawCircle;\n\n\t/**\n\t * Shortcut to drawEllipse.\n\t * @method de\n\t * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {{#crossLink \"Graphics/drawCircle\"}}{{/crossLink}}\n\t * which draws from center.\n\t * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {{#crossLink \"Graphics/drawCircle\"}}{{/crossLink}}\n\t * which draws from the center.\n\t * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this\n\t * number.\n\t * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.de = p.drawEllipse;\n\n\t/**\n\t * Shortcut to drawPolyStar.\n\t * @method dp\n\t * @param {Number} x Position of the center of the shape.\n\t * @param {Number} y Position of the center of the shape.\n\t * @param {Number} radius The outer radius of the shape.\n\t * @param {Number} sides The number of points on the star or sides on the polygon.\n\t * @param {Number} pointSize The depth or \"pointy-ness\" of the star points. A pointSize of 0 will draw a regular\n\t * polygon (no points), a pointSize of 1 will draw nothing because the points are infinitely pointy.\n\t * @param {Number} angle The angle of the first point / corner. For example a value of 0 will draw the first point\n\t * directly to the right of the center.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.dp = p.drawPolyStar;\n\n\t/**\n\t * Shortcut to decodePath.\n\t * @method p\n\t * @param {String} str The path string to decode.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.p = p.decodePath;\n\n\n// private methods:\n\t/**\n\t * @method _updateInstructions\n\t * @param commit\n\t * @protected\n\t **/\n\tp._updateInstructions = function(commit) {\n\t\tvar instr = this._instructions, active = this._activeInstructions, commitIndex = this._commitIndex;\n\n\t\tif (this._dirty && active.length) {\n\t\t\tinstr.length = commitIndex; // remove old, uncommitted commands\n\t\t\tinstr.push(Graphics.beginCmd);\n\n\t\t\tvar l = active.length, ll = instr.length;\n\t\t\tinstr.length = ll+l;\n\t\t\tfor (var i=0; i<l; i++) { instr[i+ll] = active[i]; }\n\n\t\t\tif (this._fill) { instr.push(this._fill); }\n\t\t\tif (this._stroke) {\n\t\t\t\t// doesn't need to be re-applied if it hasn't changed.\n\t\t\t\tif (this._strokeDash !== this._oldStrokeDash) {\n\t\t\t\t\tthis._oldStrokeDash = this._strokeDash;\n\t\t\t\t\tinstr.push(this._strokeDash);\n\t\t\t\t}\n\t\t\t\tif (this._strokeStyle !== this._oldStrokeStyle) {\n\t\t\t\t\tthis._oldStrokeStyle = this._strokeStyle;\n\t\t\t\t\tinstr.push(this._strokeStyle);\n\t\t\t\t}\n\t\t\t\tinstr.push(this._stroke);\n\t\t\t}\n\n\t\t\tthis._dirty = false;\n\t\t}\n\n\t\tif (commit) {\n\t\t\tactive.length = 0;\n\t\t\tthis._commitIndex = instr.length;\n\t\t}\n\t};\n\n\t/**\n\t * @method _setFill\n\t * @param fill\n\t * @protected\n\t **/\n\tp._setFill = function(fill) {\n\t\tthis._updateInstructions(true);\n\t\tthis.command = this._fill = fill;\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method _setStroke\n\t * @param stroke\n\t * @protected\n\t **/\n\tp._setStroke = function(stroke) {\n\t\tthis._updateInstructions(true);\n\t\tif (this.command = this._stroke = stroke) {\n\t\t\tstroke.ignoreScale = this._strokeIgnoreScale;\n\t\t}\n\t\treturn this;\n\t};\n\n// Command Objects:\n\t/**\n\t * @namespace Graphics\n\t */\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/lineTo\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information. See {{#crossLink \"Graphics\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class LineTo\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.LineTo = function(x, y) {\n\t\tthis.x = x; this.y = y;\n\t}).prototype.exec = function(ctx) { ctx.lineTo(this.x,this.y); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/moveTo\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class MoveTo\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx\n\t */\n\t(G.MoveTo = function(x, y) {\n\t\tthis.x = x; this.y = y;\n\t}).prototype.exec = function(ctx) { ctx.moveTo(this.x, this.y); };\n\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/arcTo\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class ArcTo\n\t * @constructor\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @param {Number} x2\n\t * @param {Number} y2\n\t * @param {Number} radius\n\t **/\n\t/**\n\t * @property x1\n\t * @type Number\n\t */\n\t/**\n\t * @property y1\n\t * @type Number\n\t */\n\t/**\n\t * @property x2\n\t * @type Number\n\t */\n\t/**\n\t * @property y2\n\t * @type Number\n\t */\n\t/**\n\t * @property radius\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.ArcTo = function(x1, y1, x2, y2, radius) {\n\t\tthis.x1 = x1; this.y1 = y1;\n\t\tthis.x2 = x2; this.y2 = y2;\n\t\tthis.radius = radius;\n\t}).prototype.exec = function(ctx) { ctx.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/arc\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class Arc\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} radius\n\t * @param {Number} startAngle\n\t * @param {Number} endAngle\n\t * @param {Number} anticlockwise\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property radius\n\t * @type Number\n\t */\n\t/**\n\t * @property startAngle\n\t * @type Number\n\t */\n\t/**\n\t * @property endAngle\n\t * @type Number\n\t */\n\t/**\n\t * @property anticlockwise\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.Arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.radius = radius;\n\t\tthis.startAngle = startAngle; this.endAngle = endAngle;\n\t\tthis.anticlockwise = !!anticlockwise;\n\t}).prototype.exec = function(ctx) { ctx.arc(this.x, this.y, this.radius, this.startAngle, this.endAngle, this.anticlockwise); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/quadraticCurveTo\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class QuadraticCurveTo\n\t * @constructor\n\t * @param {Number} cpx\n\t * @param {Number} cpy\n\t * @param {Number} x\n\t * @param {Number} y\n\t **/\n\t/**\n\t * @property cpx\n\t * @type Number\n\t */\n\t/**\n\t * @property cpy\n\t * @type Number\n\t */\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.QuadraticCurveTo = function(cpx, cpy, x, y) {\n\t\tthis.cpx = cpx; this.cpy = cpy;\n\t\tthis.x = x; this.y = y;\n\t}).prototype.exec = function(ctx) { ctx.quadraticCurveTo(this.cpx, this.cpy, this.x, this.y); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/bezierCurveTo\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class BezierCurveTo\n\t * @constructor\n\t * @param {Number} cp1x\n\t * @param {Number} cp1y\n\t * @param {Number} cp2x\n\t * @param {Number} cp2y\n\t * @param {Number} x\n\t * @param {Number} y\n\t **/\n\t/**\n\t * @property cp1x\n\t * @type Number\n\t */\n\t/**\n\t * @property cp1y\n\t * @type Number\n\t */\n\t/**\n\t * @property cp2x\n\t * @type Number\n\t */\n\t/**\n\t * @property cp2y\n\t * @type Number\n\t */\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.BezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {\n\t\tthis.cp1x = cp1x; this.cp1y = cp1y;\n\t\tthis.cp2x = cp2x; this.cp2y = cp2y;\n\t\tthis.x = x; this.y = y;\n\t}).prototype.exec = function(ctx) { ctx.bezierCurveTo(this.cp1x, this.cp1y, this.cp2x, this.cp2y, this.x, this.y); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/rect\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class Rect\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w\n\t * @param {Number} h\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property w\n\t * @type Number\n\t */\n\t/**\n\t * @property h\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.Rect = function(x, y, w, h) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.w = w; this.h = h;\n\t}).prototype.exec = function(ctx) { ctx.rect(this.x, this.y, this.w, this.h); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/closePath\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class ClosePath\n\t * @constructor\n\t **/\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.ClosePath = function() {\n\t}).prototype.exec = function(ctx) { ctx.closePath(); };\n\n\t/**\n\t * Graphics command object to begin a new path. See {{#crossLink \"Graphics\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class BeginPath\n\t * @constructor\n\t **/\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.BeginPath = function() {\n\t}).prototype.exec = function(ctx) { ctx.beginPath(); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/beginFill\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class Fill\n\t * @constructor\n\t * @param {Object} style A valid Context2D fillStyle.\n\t * @param {Matrix2D} matrix\n\t **/\n\t/**\n\t * A valid Context2D fillStyle.\n\t * @property style\n\t * @type Object\n\t */\n\t/**\n\t * @property matrix\n\t * @type Matrix2D\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\tp = (G.Fill = function(style, matrix) {\n\t\tthis.style = style;\n\t\tthis.matrix = matrix;\n\t}).prototype;\n\tp.exec = function(ctx) {\n\t\tif (!this.style) { return; }\n\t\tctx.fillStyle = this.style;\n\t\tvar mtx = this.matrix;\n\t\tif (mtx) { ctx.save(); ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty); }\n\t\tctx.fill();\n\t\tif (mtx) { ctx.restore(); }\n\t};\n\t/**\n\t * Creates a linear gradient style and assigns it to {{#crossLink \"Fill/style:property\"}}{{/crossLink}}.\n\t * See {{#crossLink \"Graphics/beginLinearGradientFill\"}}{{/crossLink}} for more information.\n\t * @method linearGradient\n\t * @param {Array} colors\n\t *\n\t * @param {Array} ratios\n\t * @param {Number} x0\n\t * @param {Number} y0\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @return {Fill} Returns this Fill object for chaining or assignment.\n\t */\n\tp.linearGradient = function(colors, ratios, x0, y0, x1, y1) {\n\t\tvar o = this.style =  Graphics._ctx.createLinearGradient(x0, y0, x1, y1);\n\t\tfor (var i=0, l=colors.length; i<l; i++) { o.addColorStop(ratios[i], colors[i]); }\n\t\to.props = {colors:colors, ratios:ratios, x0:x0, y0:y0, x1:x1, y1:y1, type:\"linear\"};\n\t\treturn this;\n\t};\n\t/**\n\t * Creates a radial gradient style and assigns it to {{#crossLink \"Fill/style:property\"}}{{/crossLink}}.\n\t * See {{#crossLink \"Graphics/beginRadialGradientFill\"}}{{/crossLink}} for more information.\n\t * @method radialGradient\n\t * @param {Array} colors\n\t * @param {Array} ratios\n\t * @param {Number} x0\n\t * @param {Number} y0\n\t * @param {Number} r0\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @param {Number} r1\n\t * @return {Fill} Returns this Fill object for chaining or assignment.\n\t */\n\tp.radialGradient = function(colors, ratios, x0, y0, r0, x1, y1, r1) {\n\t\tvar o = this.style =  Graphics._ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);\n\t\tfor (var i=0, l=colors.length; i<l; i++) { o.addColorStop(ratios[i], colors[i]); }\n\t\to.props = {colors:colors, ratios:ratios, x0:x0, y0:y0, r0:r0, x1:x1, y1:y1, r1:r1, type:\"radial\"};\n\t\treturn this;\n\t};\n\t/**\n\t * Creates a bitmap fill style and assigns it to the {{#crossLink \"Fill/style:property\"}}{{/crossLink}}.\n\t * See {{#crossLink \"Graphics/beginBitmapFill\"}}{{/crossLink}} for more information.\n\t * @method bitmap\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image  Must be loaded prior to creating a bitmap fill, or the fill will be empty.\n\t * @param {String} [repetition] One of: repeat, repeat-x, repeat-y, or no-repeat.\n\t * @return {Fill} Returns this Fill object for chaining or assignment.\n\t */\n\tp.bitmap = function(image, repetition) {\n\t\tif (image.naturalWidth || image.getContext || image.readyState >= 2) {\n\t\t\tvar o = this.style = Graphics._ctx.createPattern(image, repetition || \"\");\n\t\t\to.props = {image: image, repetition: repetition, type: \"bitmap\"};\n\t\t}\n\t\treturn this;\n\t};\n\tp.path = false;\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/beginStroke\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class Stroke\n\t * @constructor\n\t * @param {Object} style A valid Context2D fillStyle.\n\t * @param {Boolean} ignoreScale\n\t **/\n\t/**\n\t * A valid Context2D strokeStyle.\n\t * @property style\n\t * @type Object\n\t */\n\t/**\n\t * @property ignoreScale\n\t * @type Boolean\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\tp = (G.Stroke = function(style, ignoreScale) {\n\t\tthis.style = style;\n\t\tthis.ignoreScale = ignoreScale;\n\t}).prototype;\n\tp.exec = function(ctx) {\n\t\tif (!this.style) { return; }\n\t\tctx.strokeStyle = this.style;\n\t\tif (this.ignoreScale) { ctx.save(); ctx.setTransform(1,0,0,1,0,0); }\n\t\tctx.stroke();\n\t\tif (this.ignoreScale) { ctx.restore(); }\n\t};\n\t/**\n\t * Creates a linear gradient style and assigns it to {{#crossLink \"Stroke/style:property\"}}{{/crossLink}}.\n\t * See {{#crossLink \"Graphics/beginLinearGradientStroke\"}}{{/crossLink}} for more information.\n\t * @method linearGradient\n\t * @param {Array} colors\n\t * @param {Array} ratios\n\t * @param {Number} x0\n\t * @param {Number} y0\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @return {Fill} Returns this Stroke object for chaining or assignment.\n\t */\n\tp.linearGradient = G.Fill.prototype.linearGradient;\n\t/**\n\t * Creates a radial gradient style and assigns it to {{#crossLink \"Stroke/style:property\"}}{{/crossLink}}.\n\t * See {{#crossLink \"Graphics/beginRadialGradientStroke\"}}{{/crossLink}} for more information.\n\t * @method radialGradient\n\t * @param {Array} colors\n\t * @param {Array} ratios\n\t * @param {Number} x0\n\t * @param {Number} y0\n\t * @param {Number} r0\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @param {Number} r1\n\t * @return {Fill} Returns this Stroke object for chaining or assignment.\n\t */\n\tp.radialGradient = G.Fill.prototype.radialGradient;\n\t/**\n\t * Creates a bitmap fill style and assigns it to {{#crossLink \"Stroke/style:property\"}}{{/crossLink}}.\n\t * See {{#crossLink \"Graphics/beginBitmapStroke\"}}{{/crossLink}} for more information.\n\t * @method bitmap\n\t * @param {HTMLImageElement} image\n\t * @param {String} [repetition] One of: repeat, repeat-x, repeat-y, or no-repeat.\n\t * @return {Fill} Returns this Stroke object for chaining or assignment.\n\t */\n\tp.bitmap = G.Fill.prototype.bitmap;\n\tp.path = false;\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/setStrokeStyle\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class StrokeStyle\n\t * @constructor\n\t * @param {Number} width\n\t * @param {String} [caps=butt]\n\t * @param {String} [joints=miter]\n\t * @param {Number} [miterLimit=10]\n\t * @param {Boolean} [ignoreScale=false]\n\t **/\n\t/**\n\t * @property width\n\t * @type Number\n\t */\n\t/**\n\t * One of: butt, round, square\n\t * @property caps\n\t * @type String\n\t */\n\t/**\n\t * One of: round, bevel, miter\n\t * @property joints\n\t * @type String\n\t */\n\t/**\n\t * @property miterLimit\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\tp = (G.StrokeStyle = function(width, caps, joints, miterLimit, ignoreScale) {\n\t\tthis.width = width;\n\t\tthis.caps = caps;\n\t\tthis.joints = joints;\n\t\tthis.miterLimit = miterLimit;\n\t\tthis.ignoreScale = ignoreScale;\n\t}).prototype;\n\tp.exec = function(ctx) {\n\t\tctx.lineWidth = (this.width == null ? \"1\" : this.width);\n\t\tctx.lineCap = (this.caps == null ? \"butt\" : (isNaN(this.caps) ? this.caps : Graphics.STROKE_CAPS_MAP[this.caps]));\n\t\tctx.lineJoin = (this.joints == null ? \"miter\" : (isNaN(this.joints) ? this.joints : Graphics.STROKE_JOINTS_MAP[this.joints]));\n\t\tctx.miterLimit = (this.miterLimit == null ? \"10\" : this.miterLimit);\n\t\tctx.ignoreScale = (this.ignoreScale == null ? false : this.ignoreScale);\n\t};\n\tp.path = false;\n\t\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/setStrokeDash\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class StrokeDash\n\t * @constructor\n\t * @param {Array} [segments]\n\t * @param {Number} [offset=0]\n\t **/\n\t/**\n\t * @property segments\n\t * @type Array\n\t */\n\t/**\n\t * @property offset\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.StrokeDash = function(segments, offset) {\n\t\tthis.segments = segments;\n\t\tthis.offset = offset||0;\n\t}).prototype.exec = function(ctx) {\n\t\tif (ctx.setLineDash) { // feature detection.\n\t\t\tctx.setLineDash(this.segments|| G.StrokeDash.EMPTY_SEGMENTS); // instead of [] to reduce churn.\n\t\t\tctx.lineDashOffset = this.offset||0;\n\t\t}\n\t};\n\t/**\n\t * The default value for segments (ie. no dash).\n\t * @property EMPTY_SEGMENTS\n\t * @static\n\t * @final\n\t * @readonly\n\t * @protected\n\t * @type {Array}\n\t **/\n\tG.StrokeDash.EMPTY_SEGMENTS = [];\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/drawRoundRectComplex\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class RoundRect\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w\n\t * @param {Number} h\n\t * @param {Number} radiusTL\n\t * @param {Number} radiusTR\n\t * @param {Number} radiusBR\n\t * @param {Number} radiusBL\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property w\n\t * @type Number\n\t */\n\t/**\n\t * @property h\n\t * @type Number\n\t */\n\t/**\n\t * @property radiusTL\n\t * @type Number\n\t */\n\t/**\n\t * @property radiusTR\n\t * @type Number\n\t */\n\t/**\n\t * @property radiusBR\n\t * @type Number\n\t */\n\t/**\n\t * @property radiusBL\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.RoundRect = function(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.w = w; this.h = h;\n\t\tthis.radiusTL = radiusTL; this.radiusTR = radiusTR;\n\t\tthis.radiusBR = radiusBR; this.radiusBL = radiusBL;\n\t}).prototype.exec = function(ctx) {\n\t\tvar max = (w<h?w:h)/2;\n\t\tvar mTL=0, mTR=0, mBR=0, mBL=0;\n\t\tvar x = this.x, y = this.y, w = this.w, h = this.h;\n\t\tvar rTL = this.radiusTL, rTR = this.radiusTR, rBR = this.radiusBR, rBL = this.radiusBL;\n\n\t\tif (rTL < 0) { rTL *= (mTL=-1); }\n\t\tif (rTL > max) { rTL = max; }\n\t\tif (rTR < 0) { rTR *= (mTR=-1); }\n\t\tif (rTR > max) { rTR = max; }\n\t\tif (rBR < 0) { rBR *= (mBR=-1); }\n\t\tif (rBR > max) { rBR = max; }\n\t\tif (rBL < 0) { rBL *= (mBL=-1); }\n\t\tif (rBL > max) { rBL = max; }\n\n\t\tctx.moveTo(x+w-rTR, y);\n\t\tctx.arcTo(x+w+rTR*mTR, y-rTR*mTR, x+w, y+rTR, rTR);\n\t\tctx.lineTo(x+w, y+h-rBR);\n\t\tctx.arcTo(x+w+rBR*mBR, y+h+rBR*mBR, x+w-rBR, y+h, rBR);\n\t\tctx.lineTo(x+rBL, y+h);\n\t\tctx.arcTo(x-rBL*mBL, y+h+rBL*mBL, x, y+h-rBL, rBL);\n\t\tctx.lineTo(x, y+rTL);\n\t\tctx.arcTo(x-rTL*mTL, y-rTL*mTL, x+rTL, y, rTL);\n\t\tctx.closePath();\n\t};\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/drawCircle\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class Circle\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} radius\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property radius\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.Circle = function(x, y, radius) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.radius = radius;\n\t}).prototype.exec = function(ctx) { ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/drawEllipse\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class Ellipse\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w\n\t * @param {Number} h\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property w\n\t * @type Number\n\t */\n\t/**\n\t * @property h\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.Ellipse = function(x, y, w, h) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.w = w; this.h = h;\n\t}).prototype.exec = function(ctx) {\n\t\tvar x = this.x, y = this.y;\n\t\tvar w = this.w, h = this.h;\n\n\t\tvar k = 0.5522848;\n\t\tvar ox = (w / 2) * k;\n\t\tvar oy = (h / 2) * k;\n\t\tvar xe = x + w;\n\t\tvar ye = y + h;\n\t\tvar xm = x + w / 2;\n\t\tvar ym = y + h / 2;\n\n\t\tctx.moveTo(x, ym);\n\t\tctx.bezierCurveTo(x, ym-oy, xm-ox, y, xm, y);\n\t\tctx.bezierCurveTo(xm+ox, y, xe, ym-oy, xe, ym);\n\t\tctx.bezierCurveTo(xe, ym+oy, xm+ox, ye, xm, ye);\n\t\tctx.bezierCurveTo(xm-ox, ye, x, ym+oy, x, ym);\n\t};\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/drawPolyStar\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class PolyStar\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} radius\n\t * @param {Number} sides\n\t * @param {Number} pointSize\n\t * @param {Number} angle\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property radius\n\t * @type Number\n\t */\n\t/**\n\t * @property sides\n\t * @type Number\n\t */\n\t/**\n\t * @property pointSize\n\t * @type Number\n\t */\n\t/**\n\t * @property angle\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.PolyStar = function(x, y, radius, sides, pointSize, angle) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.radius = radius;\n\t\tthis.sides = sides;\n\t\tthis.pointSize = pointSize;\n\t\tthis.angle = angle;\n\t}).prototype.exec = function(ctx) {\n\t\tvar x = this.x, y = this.y;\n\t\tvar radius = this.radius;\n\t\tvar angle = (this.angle||0)/180*Math.PI;\n\t\tvar sides = this.sides;\n\t\tvar ps = 1-(this.pointSize||0);\n\t\tvar a = Math.PI/sides;\n\n\t\tctx.moveTo(x+Math.cos(angle)*radius, y+Math.sin(angle)*radius);\n\t\tfor (var i=0; i<sides; i++) {\n\t\t\tangle += a;\n\t\t\tif (ps != 1) {\n\t\t\t\tctx.lineTo(x+Math.cos(angle)*radius*ps, y+Math.sin(angle)*radius*ps);\n\t\t\t}\n\t\t\tangle += a;\n\t\t\tctx.lineTo(x+Math.cos(angle)*radius, y+Math.sin(angle)*radius);\n\t\t}\n\t\tctx.closePath();\n\t};\n\n\t// docced above.\n\tGraphics.beginCmd = new G.BeginPath(); // so we don't have to instantiate multiple instances.\n\n\n\tcreatejs.Graphics = Graphics;\n}());\n\n//##############################################################################\n// DisplayObject.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * DisplayObject is an abstract class that should not be constructed directly. Instead construct subclasses such as\n\t * {{#crossLink \"Container\"}}{{/crossLink}}, {{#crossLink \"Bitmap\"}}{{/crossLink}}, and {{#crossLink \"Shape\"}}{{/crossLink}}.\n\t * DisplayObject is the base class for all display classes in the EaselJS library. It defines the core properties and\n\t * methods that are shared between all display objects, such as transformation properties (x, y, scaleX, scaleY, etc),\n\t * caching, and mouse handlers.\n\t * @class DisplayObject\n\t * @extends EventDispatcher\n\t * @constructor\n\t **/\n\tfunction DisplayObject() {\n\t\tthis.EventDispatcher_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The alpha (transparency) for this display object. 0 is fully transparent, 1 is fully opaque.\n\t\t * @property alpha\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t **/\n\t\tthis.alpha = 1;\n\t\n\t\t/**\n\t\t * If a cache is active, this returns the canvas that holds the cached version of this display object. See {{#crossLink \"cache\"}}{{/crossLink}}\n\t\t * for more information.\n\t\t * @property cacheCanvas\n\t\t * @type {HTMLCanvasElement | Object}\n\t\t * @default null\n\t\t * @readonly\n\t\t **/\n\t\tthis.cacheCanvas = null;\n\t\n\t\t/**\n\t\t * Returns an ID number that uniquely identifies the current cache for this display object. This can be used to\n\t\t * determine if the cache has changed since a previous check.\n\t\t * @property cacheID\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.cacheID = 0;\n\t\n\t\t/**\n\t\t * Unique ID for this display object. Makes display objects easier for some uses.\n\t\t * @property id\n\t\t * @type {Number}\n\t\t * @default -1\n\t\t **/\n\t\tthis.id = createjs.UID.get();\n\t\n\t\t/**\n\t\t * Indicates whether to include this object when running mouse interactions. Setting this to `false` for children\n\t\t * of a {{#crossLink \"Container\"}}{{/crossLink}} will cause events on the Container to not fire when that child is\n\t\t * clicked. Setting this property to `false` does not prevent the {{#crossLink \"Container/getObjectsUnderPoint\"}}{{/crossLink}}\n\t\t * method from returning the child.\n\t\t *\n\t\t * <strong>Note:</strong> In EaselJS 0.7.0, the mouseEnabled property will not work properly with nested Containers. Please\n\t\t * check out the latest NEXT version in <a href=\"https://github.com/CreateJS/EaselJS/tree/master/lib\">GitHub</a> for an updated version with this issue resolved. The fix will be\n\t\t * provided in the next release of EaselJS.\n\t\t * @property mouseEnabled\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t **/\n\t\tthis.mouseEnabled = true;\n\t\t\n\t\t/**\n\t\t * If false, the tick will not run on this display object (or its children). This can provide some performance benefits.\n\t\t * In addition to preventing the \"tick\" event from being dispatched, it will also prevent tick related updates\n\t\t * on some display objects (ex. Sprite & MovieClip frame advancing, DOMElement visibility handling).\n\t\t * @property tickEnabled\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.tickEnabled = true;\n\t\n\t\t/**\n\t\t * An optional name for this display object. Included in {{#crossLink \"DisplayObject/toString\"}}{{/crossLink}} . Useful for\n\t\t * debugging.\n\t\t * @property name\n\t\t * @type {String}\n\t\t * @default null\n\t\t **/\n\t\tthis.name = null;\n\t\n\t\t/**\n\t\t * A reference to the {{#crossLink \"Container\"}}{{/crossLink}} or {{#crossLink \"Stage\"}}{{/crossLink}} object that\n\t\t * contains this display object, or null if it has not been added\n\t\t * to one.\n\t\t * @property parent\n\t\t * @final\n\t\t * @type {Container}\n\t\t * @default null\n\t\t * @readonly\n\t\t **/\n\t\tthis.parent = null;\n\t\n\t\t/**\n\t\t * The left offset for this display object's registration point. For example, to make a 100x100px Bitmap rotate\n\t\t * around its center, you would set regX and {{#crossLink \"DisplayObject/regY:property\"}}{{/crossLink}} to 50.\n\t\t * @property regX\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.regX = 0;\n\t\n\t\t/**\n\t\t * The y offset for this display object's registration point. For example, to make a 100x100px Bitmap rotate around\n\t\t * its center, you would set {{#crossLink \"DisplayObject/regX:property\"}}{{/crossLink}} and regY to 50.\n\t\t * @property regY\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.regY = 0;\n\t\n\t\t/**\n\t\t * The rotation in degrees for this display object.\n\t\t * @property rotation\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.rotation = 0;\n\t\n\t\t/**\n\t\t * The factor to stretch this display object horizontally. For example, setting scaleX to 2 will stretch the display\n\t\t * object to twice its nominal width. To horizontally flip an object, set the scale to a negative number.\n\t\t * @property scaleX\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t **/\n\t\tthis.scaleX = 1;\n\t\n\t\t/**\n\t\t * The factor to stretch this display object vertically. For example, setting scaleY to 0.5 will stretch the display\n\t\t * object to half its nominal height. To vertically flip an object, set the scale to a negative number.\n\t\t * @property scaleY\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t **/\n\t\tthis.scaleY = 1;\n\t\n\t\t/**\n\t\t * The factor to skew this display object horizontally.\n\t\t * @property skewX\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.skewX = 0;\n\t\n\t\t/**\n\t\t * The factor to skew this display object vertically.\n\t\t * @property skewY\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.skewY = 0;\n\t\n\t\t/**\n\t\t * A shadow object that defines the shadow to render on this display object. Set to `null` to remove a shadow. If\n\t\t * null, this property is inherited from the parent container.\n\t\t * @property shadow\n\t\t * @type {Shadow}\n\t\t * @default null\n\t\t **/\n\t\tthis.shadow = null;\n\t\n\t\t/**\n\t\t * Indicates whether this display object should be rendered to the canvas and included when running the Stage\n\t\t * {{#crossLink \"Stage/getObjectsUnderPoint\"}}{{/crossLink}} method.\n\t\t * @property visible\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t **/\n\t\tthis.visible = true;\n\t\n\t\t/**\n\t\t * The x (horizontal) position of the display object, relative to its parent.\n\t\t * @property x\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.x = 0;\n\t\n\t\t/** The y (vertical) position of the display object, relative to its parent.\n\t\t * @property y\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.y = 0;\n\t\t\n\t\t/**\n\t\t * If set, defines the transformation for this display object, overriding all other transformation properties\n\t\t * (x, y, rotation, scale, skew).\n\t\t * @property transformMatrix\n\t\t * @type {Matrix2D}\n\t\t * @default null\n\t\t **/\n\t\tthis.transformMatrix = null;\n\t\t\n\t\t/**\n\t\t * The composite operation indicates how the pixels of this display object will be composited with the elements\n\t\t * behind it. If `null`, this property is inherited from the parent container. For more information, read the\n\t\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#compositing\">\n\t\t * whatwg spec on compositing</a>.\n\t\t * @property compositeOperation\n\t\t * @type {String}\n\t\t * @default null\n\t\t **/\n\t\tthis.compositeOperation = null;\n\t\n\t\t/**\n\t\t * Indicates whether the display object should be drawn to a whole pixel when\n\t\t * {{#crossLink \"Stage/snapToPixelEnabled\"}}{{/crossLink}} is true. To enable/disable snapping on whole\n\t\t * categories of display objects, set this value on the prototype (Ex. Text.prototype.snapToPixel = true).\n\t\t * @property snapToPixel\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t **/\n\t\tthis.snapToPixel = true;\n\t\n\t\t/**\n\t\t * An array of Filter objects to apply to this display object. Filters are only applied / updated when {{#crossLink \"cache\"}}{{/crossLink}}\n\t\t * or {{#crossLink \"updateCache\"}}{{/crossLink}} is called on the display object, and only apply to the area that is\n\t\t * cached.\n\t\t * @property filters\n\t\t * @type {Array}\n\t\t * @default null\n\t\t **/\n\t\tthis.filters = null;\n\t\t\n\t\t/**\n\t\t * A Shape instance that defines a vector mask (clipping path) for this display object.  The shape's transformation\n\t\t * will be applied relative to the display object's parent coordinates (as if it were a child of the parent).\n\t\t * @property mask\n\t\t * @type {Shape}\n\t\t * @default null\n\t\t */\n\t\tthis.mask = null;\n\t\t\n\t\t/**\n\t\t * A display object that will be tested when checking mouse interactions or testing {{#crossLink \"Container/getObjectsUnderPoint\"}}{{/crossLink}}.\n\t\t * The hit area will have its transformation applied relative to this display object's coordinate space (as though\n\t\t * the hit test object were a child of this display object and relative to its regX/Y). The hitArea will be tested\n\t\t * using only its own `alpha` value regardless of the alpha value on the target display object, or the target's\n\t\t * ancestors (parents).\n\t\t * \n\t\t * If set on a {{#crossLink \"Container\"}}{{/crossLink}}, children of the Container will not receive mouse events.\n\t\t * This is similar to setting {{#crossLink \"mouseChildren\"}}{{/crossLink}} to false.\n\t\t *\n\t\t * Note that hitArea is NOT currently used by the `hitTest()` method, nor is it supported for {{#crossLink \"Stage\"}}{{/crossLink}}.\n\t\t * @property hitArea\n\t\t * @type {DisplayObject}\n\t\t * @default null\n\t\t */\n\t\tthis.hitArea = null;\n\t\t\n\t\t/**\n\t\t * A CSS cursor (ex. \"pointer\", \"help\", \"text\", etc) that will be displayed when the user hovers over this display\n\t\t * object. You must enable mouseover events using the {{#crossLink \"Stage/enableMouseOver\"}}{{/crossLink}} method to\n\t\t * use this property. Setting a non-null cursor on a Container will override the cursor set on its descendants.\n\t\t * @property cursor\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.cursor = null;\n\t\n\t\n\t// private properties:\n\t\t/**\n\t\t * @property _cacheOffsetX\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis._cacheOffsetX = 0;\n\t\n\t\t/**\n\t\t * @property _cacheOffsetY\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis._cacheOffsetY = 0;\n\t\t\n\t\t/**\n\t\t * @property _filterOffsetX\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis._filterOffsetX = 0;\n\t\t\n\t\t/**\n\t\t * @property _filterOffsetY\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis._filterOffsetY = 0;\n\t\t\n\t\t/**\n\t\t * @property _cacheScale\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t **/\n\t\tthis._cacheScale = 1;\n\t\n\t\t/**\n\t\t* @property _cacheDataURLID\n\t\t* @protected\n\t\t* @type {Number}\n\t\t* @default 0\n\t\t*/\n\t\tthis._cacheDataURLID = 0;\n\t\t\n\t\t/**\n\t\t* @property _cacheDataURL\n\t\t* @protected\n\t\t* @type {String}\n\t\t* @default null\n\t\t*/\n\t\tthis._cacheDataURL = null;\n\t\n\t\t/**\n\t\t * @property _props\n\t\t * @protected\n\t\t * @type {DisplayObject}\n\t\t * @default null\n\t\t **/\n\t\tthis._props = new createjs.DisplayProps();\n\t\n\t\t/**\n\t\t * @property _rectangle\n\t\t * @protected\n\t\t * @type {Rectangle}\n\t\t * @default null\n\t\t **/\n\t\tthis._rectangle = new createjs.Rectangle();\n\t\n\t\t/**\n\t\t * @property _bounds\n\t\t * @protected\n\t\t * @type {Rectangle}\n\t\t * @default null\n\t\t **/\n\t\tthis._bounds = null;\n\t}\n\tvar p = createjs.extend(DisplayObject, createjs.EventDispatcher);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\t\n// static properties:\n\t/**\n\t * Listing of mouse event names. Used in _hasMouseEventListener.\n\t * @property _MOUSE_EVENTS\n\t * @protected\n\t * @static\n\t * @type {Array}\n\t **/\n\tDisplayObject._MOUSE_EVENTS = [\"click\",\"dblclick\",\"mousedown\",\"mouseout\",\"mouseover\",\"pressmove\",\"pressup\",\"rollout\",\"rollover\"];\n\n\t/**\n\t * Suppresses errors generated when using features like hitTest, mouse events, and {{#crossLink \"getObjectsUnderPoint\"}}{{/crossLink}}\n\t * with cross domain content.\n\t * @property suppressCrossDomainErrors\n\t * @static\n\t * @type {Boolean}\n\t * @default false\n\t **/\n\tDisplayObject.suppressCrossDomainErrors = false;\n\t\n\t/**\n\t * @property _snapToPixelEnabled\n\t * @protected\n\t * @static\n\t * @type {Boolean}\n\t * @default false\n\t **/\n\tDisplayObject._snapToPixelEnabled = false; // stage.snapToPixelEnabled is temporarily copied here during a draw to provide global access.\n\n\t/**\n\t * @property _hitTestCanvas\n\t * @type {HTMLCanvasElement | Object}\n\t * @static\n\t * @protected\n\t **/\n\t/**\n\t * @property _hitTestContext\n\t * @type {CanvasRenderingContext2D}\n\t * @static\n\t * @protected\n\t **/\n\tvar canvas = createjs.createCanvas?createjs.createCanvas():document.createElement(\"canvas\"); // prevent errors on load in browsers without canvas.\n\tif (canvas.getContext) {\n\t\tDisplayObject._hitTestCanvas = canvas;\n\t\tDisplayObject._hitTestContext = canvas.getContext(\"2d\");\n\t\tcanvas.width = canvas.height = 1;\n\t}\n\n\t/**\n\t * @property _nextCacheID\n\t * @type {Number}\n\t * @static\n\t * @protected\n\t **/\n\tDisplayObject._nextCacheID = 1;\n\n\n// events:\n\t/**\n\t * Dispatched when the user presses their left mouse button over the display object. See the \n\t * {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event mousedown\n\t * @since 0.6.0\n\t */\n\t \n\t/**\n\t * Dispatched when the user presses their left mouse button and then releases it while over the display object.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event click\n\t * @since 0.6.0\n\t */\n\t \n\t/**\n\t * Dispatched when the user double clicks their left mouse button over this display object.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event dblclick\n\t * @since 0.6.0\n\t */\n\t \n\t/**\n\t * Dispatched when the user's mouse enters this display object. This event must be enabled using \n\t * {{#crossLink \"Stage/enableMouseOver\"}}{{/crossLink}}. See also {{#crossLink \"DisplayObject/rollover:event\"}}{{/crossLink}}.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event mouseover\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when the user's mouse leaves this display object. This event must be enabled using \n\t * {{#crossLink \"Stage/enableMouseOver\"}}{{/crossLink}}. See also {{#crossLink \"DisplayObject/rollout:event\"}}{{/crossLink}}.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event mouseout\n\t * @since 0.6.0\n\t */\n\t \n\t/**\n\t * This event is similar to {{#crossLink \"DisplayObject/mouseover:event\"}}{{/crossLink}}, with the following\n\t * differences: it does not bubble, and it considers {{#crossLink \"Container\"}}{{/crossLink}} instances as an\n\t * aggregate of their content.\n\t * \n\t * For example, myContainer contains two overlapping children: shapeA and shapeB. The user moves their mouse over\n\t * shapeA and then directly on to shapeB. With a listener for {{#crossLink \"mouseover:event\"}}{{/crossLink}} on\n\t * myContainer, two events would be received, each targeting a child element:<OL>\n\t * <LI>when the mouse enters shapeA (target=shapeA)</LI>\n\t * <LI>when the mouse enters shapeB (target=shapeB)</LI>\n\t * </OL>\n\t * However, with a listener for \"rollover\" instead, only a single event is received when the mouse first enters\n\t * the aggregate myContainer content (target=myContainer).\n\t * \n\t * This event must be enabled using {{#crossLink \"Stage/enableMouseOver\"}}{{/crossLink}}.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event rollover\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * This event is similar to {{#crossLink \"DisplayObject/mouseout:event\"}}{{/crossLink}}, with the following\n\t * differences: it does not bubble, and it considers {{#crossLink \"Container\"}}{{/crossLink}} instances as an\n\t * aggregate of their content.\n\t * \n\t * For example, myContainer contains two overlapping children: shapeA and shapeB. The user moves their mouse over\n\t * shapeA, then directly on to shapeB, then off both. With a listener for {{#crossLink \"mouseout:event\"}}{{/crossLink}}\n\t * on myContainer, two events would be received, each targeting a child element:<OL>\n\t * <LI>when the mouse leaves shapeA (target=shapeA)</LI>\n\t * <LI>when the mouse leaves shapeB (target=shapeB)</LI>\n\t * </OL>\n\t * However, with a listener for \"rollout\" instead, only a single event is received when the mouse leaves\n\t * the aggregate myContainer content (target=myContainer).\n\t * \n\t * This event must be enabled using {{#crossLink \"Stage/enableMouseOver\"}}{{/crossLink}}.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event rollout\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * After a {{#crossLink \"DisplayObject/mousedown:event\"}}{{/crossLink}} occurs on a display object, a pressmove\n\t * event will be generated on that object whenever the mouse moves until the mouse press is released. This can be\n\t * useful for dragging and similar operations.\n\t * @event pressmove\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * After a {{#crossLink \"DisplayObject/mousedown:event\"}}{{/crossLink}} occurs on a display object, a pressup event\n\t * will be generated on that object when that mouse press is released. This can be useful for dragging and similar\n\t * operations.\n\t * @event pressup\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * Dispatched when the display object is added to a parent container.\n\t * @event added\n\t */\n\t \n\t/**\n\t * Dispatched when the display object is removed from its parent container.\n\t * @event removed\n\t */\n\t \n\t/**\n\t * Dispatched on each display object on a stage whenever the stage updates. This occurs immediately before the\n\t * rendering (draw) pass. When {{#crossLink \"Stage/update\"}}{{/crossLink}} is called, first all display objects on\n\t * the stage dispatch the tick event, then all of the display objects are drawn to stage. Children will have their\n\t * {{#crossLink \"tick:event\"}}{{/crossLink}} event dispatched in order of their depth prior to the event being\n\t * dispatched on their parent.\n\t * @event tick\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Array} params An array containing any arguments that were passed to the Stage.update() method. For\n\t *      example if you called stage.update(\"hello\"), then the params would be [\"hello\"].\n\t * @since 0.6.0\n\t */\n\t\n\t\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink \"DisplayObject/stage:property\"}}{{/crossLink}} property instead.\n\t * @method getStage\n\t * @return {Stage}\n\t * @deprecated\n\t **/\n\tp.getStage = function() {\n\t\t// uses dynamic access to avoid circular dependencies;\n\t\tvar o = this, _Stage = createjs[\"Stage\"];\n\t\twhile (o.parent) { o = o.parent; }\n\t\tif (o instanceof _Stage) { return o; }\n\t\treturn null;\n\t};\n\n\t/**\n\t * Returns the Stage instance that this display object will be rendered on, or null if it has not been added to one.\n\t * @property stage\n\t * @type {Stage}\n\t * @readonly\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tstage: { get: p.getStage }\n\t\t});\n\t} catch (e) {}\n\n\n// public methods:\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns <code>true</code> if the draw was handled (useful for overriding functionality).\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,\n\t * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).\n\t * @return {Boolean}\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tvar cacheCanvas = this.cacheCanvas;\n\t\tif (ignoreCache || !cacheCanvas) { return false; }\n\t\tvar scale = this._cacheScale;\n\t\tctx.drawImage(cacheCanvas, this._cacheOffsetX+this._filterOffsetX, this._cacheOffsetY+this._filterOffsetY, cacheCanvas.width/scale, cacheCanvas.height/scale);\n\t\treturn true;\n\t};\n\t\n\t/**\n\t * Applies this display object's transformation, alpha, globalCompositeOperation, clipping path (mask), and shadow\n\t * to the specified context. This is typically called prior to {{#crossLink \"DisplayObject/draw\"}}{{/crossLink}}.\n\t * @method updateContext\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D to update.\n\t **/\n\tp.updateContext = function(ctx) {\n\t\tvar o=this, mask=o.mask, mtx= o._props.matrix;\n\t\t\n\t\tif (mask && mask.graphics && !mask.graphics.isEmpty()) {\n\t\t\tmask.getMatrix(mtx);\n\t\t\tctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\n\t\t\t\n\t\t\tmask.graphics.drawAsPath(ctx);\n\t\t\tctx.clip();\n\t\t\t\n\t\t\tmtx.invert();\n\t\t\tctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\n\t\t}\n\t\t\n\t\tthis.getMatrix(mtx);\n\t\tvar tx = mtx.tx, ty = mtx.ty;\n\t\tif (DisplayObject._snapToPixelEnabled && o.snapToPixel) {\n\t\t\ttx = tx + (tx < 0 ? -0.5 : 0.5) | 0;\n\t\t\tty = ty + (ty < 0 ? -0.5 : 0.5) | 0;\n\t\t}\n\t\tctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, tx, ty);\n\t\tctx.globalAlpha *= o.alpha;\n\t\tif (o.compositeOperation) { ctx.globalCompositeOperation = o.compositeOperation; }\n\t\tif (o.shadow) { this._applyShadow(ctx, o.shadow); }\n\t};\n\n\t/**\n\t * Draws the display object into a new canvas, which is then used for subsequent draws. For complex content\n\t * that does not change frequently (ex. a Container with many children that do not move, or a complex vector Shape),\n\t * this can provide for much faster rendering because the content does not need to be re-rendered each tick. The\n\t * cached display object can be moved, rotated, faded, etc freely, however if its content changes, you must\n\t * manually update the cache by calling <code>updateCache()</code> or <code>cache()</code> again. You must specify\n\t * the cache area via the x, y, w, and h parameters. This defines the rectangle that will be rendered and cached\n\t * using this display object's coordinates.\n\t *\n\t * <h4>Example</h4>\n\t * For example if you defined a Shape that drew a circle at 0, 0 with a radius of 25:\n\t *\n\t *      var shape = new createjs.Shape();\n\t *      shape.graphics.beginFill(\"#ff0000\").drawCircle(0, 0, 25);\n\t *      myShape.cache(-25, -25, 50, 50);\n\t *\n\t * Note that filters need to be defined <em>before</em> the cache is applied. Check out the {{#crossLink \"Filter\"}}{{/crossLink}}\n\t * class for more information. Some filters (ex. BlurFilter) will not work as expected in conjunction with the scale param.\n\t * \n\t * Usually, the resulting cacheCanvas will have the dimensions width*scale by height*scale, however some filters (ex. BlurFilter)\n\t * will add padding to the canvas dimensions.\n\t *\n\t * @method cache\n\t * @param {Number} x The x coordinate origin for the cache region.\n\t * @param {Number} y The y coordinate origin for the cache region.\n\t * @param {Number} width The width of the cache region.\n\t * @param {Number} height The height of the cache region.\n\t * @param {Number} [scale=1] The scale at which the cache will be created. For example, if you cache a vector shape using\n\t * \tmyShape.cache(0,0,100,100,2) then the resulting cacheCanvas will be 200x200 px. This lets you scale and rotate\n\t * \tcached elements with greater fidelity. Default is 1.\n\t **/\n\tp.cache = function(x, y, width, height, scale) {\n\t\t// draw to canvas.\n\t\tscale = scale||1;\n\t\tif (!this.cacheCanvas) { this.cacheCanvas = createjs.createCanvas?createjs.createCanvas():document.createElement(\"canvas\"); }\n\t\tthis._cacheWidth = width;\n\t\tthis._cacheHeight = height;\n\t\tthis._cacheOffsetX = x;\n\t\tthis._cacheOffsetY = y;\n\t\tthis._cacheScale = scale;\n\t\tthis.updateCache();\n\t};\n\n\t/**\n\t * Redraws the display object to its cache. Calling updateCache without an active cache will throw an error.\n\t * If compositeOperation is null the current cache will be cleared prior to drawing. Otherwise the display object\n\t * will be drawn over the existing cache using the specified compositeOperation.\n\t *\n\t * <h4>Example</h4>\n\t * Clear the current graphics of a cached shape, draw some new instructions, and then update the cache. The new line\n\t * will be drawn on top of the old one.\n\t *\n\t *      // Not shown: Creating the shape, and caching it.\n\t *      shapeInstance.clear();\n\t *      shapeInstance.setStrokeStyle(3).beginStroke(\"#ff0000\").moveTo(100, 100).lineTo(200,200);\n\t *      shapeInstance.updateCache();\n\t *\n\t * @method updateCache\n\t * @param {String} compositeOperation The compositeOperation to use, or null to clear the cache and redraw it.\n\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#compositing\">\n\t * whatwg spec on compositing</a>.\n\t **/\n\tp.updateCache = function(compositeOperation) {\n\t\tvar cacheCanvas = this.cacheCanvas;\n\t\tif (!cacheCanvas) { throw \"cache() must be called before updateCache()\"; }\n\t\tvar scale = this._cacheScale, offX = this._cacheOffsetX*scale, offY = this._cacheOffsetY*scale;\n\t\tvar w = this._cacheWidth, h = this._cacheHeight, ctx = cacheCanvas.getContext(\"2d\");\n\t\t\n\t\tvar fBounds = this._getFilterBounds();\n\t\toffX += (this._filterOffsetX = fBounds.x);\n\t\toffY += (this._filterOffsetY = fBounds.y);\n\t\t\n\t\tw = Math.ceil(w*scale) + fBounds.width;\n\t\th = Math.ceil(h*scale) + fBounds.height;\n\t\tif (w != cacheCanvas.width || h != cacheCanvas.height) {\n\t\t\t// TODO: it would be nice to preserve the content if there is a compositeOperation.\n\t\t\tcacheCanvas.width = w;\n\t\t\tcacheCanvas.height = h;\n\t\t} else if (!compositeOperation) {\n\t\t\tctx.clearRect(0, 0, w+1, h+1);\n\t\t}\n\t\t\n\t\tctx.save();\n\t\tctx.globalCompositeOperation = compositeOperation;\n\t\tctx.setTransform(scale, 0, 0, scale, -offX, -offY);\n\t\tthis.draw(ctx, true);\n\t\t// TODO: filters and cache scale don't play well together at present.\n\t\tthis._applyFilters();\n\t\tctx.restore();\n\t\tthis.cacheID = DisplayObject._nextCacheID++;\n\t};\n\n\t/**\n\t * Clears the current cache. See {{#crossLink \"DisplayObject/cache\"}}{{/crossLink}} for more information.\n\t * @method uncache\n\t **/\n\tp.uncache = function() {\n\t\tthis._cacheDataURL = this.cacheCanvas = null;\n\t\tthis.cacheID = this._cacheOffsetX = this._cacheOffsetY = this._filterOffsetX = this._filterOffsetY = 0;\n\t\tthis._cacheScale = 1;\n\t};\n\t\n\t/**\n\t * Returns a data URL for the cache, or null if this display object is not cached.\n\t * Uses cacheID to ensure a new data URL is not generated if the cache has not changed.\n\t * @method getCacheDataURL\n\t * @return {String} The image data url for the cache.\n\t **/\n\tp.getCacheDataURL = function() {\n\t\tif (!this.cacheCanvas) { return null; }\n\t\tif (this.cacheID != this._cacheDataURLID) { this._cacheDataURL = this.cacheCanvas.toDataURL(); }\n\t\treturn this._cacheDataURL;\n\t};\n\n\t/**\n\t * Transforms the specified x and y position from the coordinate space of the display object\n\t * to the global (stage) coordinate space. For example, this could be used to position an HTML label\n\t * over a specific point on a nested display object. Returns a Point instance with x and y properties\n\t * correlating to the transformed coordinates on the stage.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      displayObject.x = 300;\n\t *      displayObject.y = 200;\n\t *      stage.addChild(displayObject);\n\t *      var point = displayObject.localToGlobal(100, 100);\n\t *      // Results in x=400, y=300\n\t *\n\t * @method localToGlobal\n\t * @param {Number} x The x position in the source display object to transform.\n\t * @param {Number} y The y position in the source display object to transform.\n\t * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. \n\t * @return {Point} A Point instance with x and y properties correlating to the transformed coordinates\n\t * on the stage.\n\t **/\n\tp.localToGlobal = function(x, y, pt) {\n\t\treturn this.getConcatenatedMatrix(this._props.matrix).transformPoint(x,y, pt||new createjs.Point());\n\t};\n\n\t/**\n\t * Transforms the specified x and y position from the global (stage) coordinate space to the\n\t * coordinate space of the display object. For example, this could be used to determine\n\t * the current mouse position within the display object. Returns a Point instance with x and y properties\n\t * correlating to the transformed position in the display object's coordinate space.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      displayObject.x = 300;\n\t *      displayObject.y = 200;\n\t *      stage.addChild(displayObject);\n\t *      var point = displayObject.globalToLocal(100, 100);\n\t *      // Results in x=-200, y=-100\n\t *\n\t * @method globalToLocal\n\t * @param {Number} x The x position on the stage to transform.\n\t * @param {Number} y The y position on the stage to transform.\n\t * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. \n\t * @return {Point} A Point instance with x and y properties correlating to the transformed position in the\n\t * display object's coordinate space.\n\t **/\n\tp.globalToLocal = function(x, y, pt) {\n\t\treturn this.getConcatenatedMatrix(this._props.matrix).invert().transformPoint(x,y, pt||new createjs.Point());\n\t};\n\n\t/**\n\t * Transforms the specified x and y position from the coordinate space of this display object to the coordinate\n\t * space of the target display object. Returns a Point instance with x and y properties correlating to the\n\t * transformed position in the target's coordinate space. Effectively the same as using the following code with\n\t * {{#crossLink \"DisplayObject/localToGlobal\"}}{{/crossLink}} and {{#crossLink \"DisplayObject/globalToLocal\"}}{{/crossLink}}.\n\t *\n\t *      var pt = this.localToGlobal(x, y);\n\t *      pt = target.globalToLocal(pt.x, pt.y);\n\t *\n\t * @method localToLocal\n\t * @param {Number} x The x position in the source display object to transform.\n\t * @param {Number} y The y position on the source display object to transform.\n\t * @param {DisplayObject} target The target display object to which the coordinates will be transformed.\n\t * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. \n\t * @return {Point} Returns a Point instance with x and y properties correlating to the transformed position\n\t * in the target's coordinate space.\n\t **/\n\tp.localToLocal = function(x, y, target, pt) {\n\t\tpt = this.localToGlobal(x, y, pt);\n\t\treturn target.globalToLocal(pt.x, pt.y, pt);\n\t};\n\n\t/**\n\t * Shortcut method to quickly set the transform properties on the display object. All parameters are optional.\n\t * Omitted parameters will have the default value set.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      displayObject.setTransform(100, 100, 2, 2);\n\t *\n\t * @method setTransform\n\t * @param {Number} [x=0] The horizontal translation (x position) in pixels\n\t * @param {Number} [y=0] The vertical translation (y position) in pixels\n\t * @param {Number} [scaleX=1] The horizontal scale, as a percentage of 1\n\t * @param {Number} [scaleY=1] the vertical scale, as a percentage of 1\n\t * @param {Number} [rotation=0] The rotation, in degrees\n\t * @param {Number} [skewX=0] The horizontal skew factor\n\t * @param {Number} [skewY=0] The vertical skew factor\n\t * @param {Number} [regX=0] The horizontal registration point in pixels\n\t * @param {Number} [regY=0] The vertical registration point in pixels\n\t * @return {DisplayObject} Returns this instance. Useful for chaining commands.\n\t * @chainable\n\t*/\n\tp.setTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\tthis.scaleX = scaleX == null ? 1 : scaleX;\n\t\tthis.scaleY = scaleY == null ? 1 : scaleY;\n\t\tthis.rotation = rotation || 0;\n\t\tthis.skewX = skewX || 0;\n\t\tthis.skewY = skewY || 0;\n\t\tthis.regX = regX || 0;\n\t\tthis.regY = regY || 0;\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Returns a matrix based on this object's current transform.\n\t * @method getMatrix\n\t * @param {Matrix2D} matrix Optional. A Matrix2D object to populate with the calculated values. If null, a new\n\t * Matrix object is returned.\n\t * @return {Matrix2D} A matrix representing this display object's transform.\n\t **/\n\tp.getMatrix = function(matrix) {\n\t\tvar o = this, mtx = matrix&&matrix.identity() || new createjs.Matrix2D();\n\t\treturn o.transformMatrix ?  mtx.copy(o.transformMatrix) : mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);\n\t};\n\t\n\t/**\n\t * Generates a Matrix2D object representing the combined transform of the display object and all of its\n\t * parent Containers up to the highest level ancestor (usually the {{#crossLink \"Stage\"}}{{/crossLink}}). This can\n\t * be used to transform positions between coordinate spaces, such as with {{#crossLink \"DisplayObject/localToGlobal\"}}{{/crossLink}}\n\t * and {{#crossLink \"DisplayObject/globalToLocal\"}}{{/crossLink}}.\n\t * @method getConcatenatedMatrix\n\t * @param {Matrix2D} [matrix] A {{#crossLink \"Matrix2D\"}}{{/crossLink}} object to populate with the calculated values.\n\t * If null, a new Matrix2D object is returned.\n\t * @return {Matrix2D} The combined matrix.\n\t **/\n\tp.getConcatenatedMatrix = function(matrix) {\n\t\tvar o = this, mtx = this.getMatrix(matrix);\n\t\twhile (o = o.parent) {\n\t\t\tmtx.prependMatrix(o.getMatrix(o._props.matrix));\n\t\t}\n\t\treturn mtx;\n\t};\n\t\n\t/**\n\t * Generates a DisplayProps object representing the combined display properties of the  object and all of its\n\t * parent Containers up to the highest level ancestor (usually the {{#crossLink \"Stage\"}}{{/crossLink}}).\n\t * @method getConcatenatedDisplayProps\n\t * @param {DisplayProps} [props] A {{#crossLink \"DisplayProps\"}}{{/crossLink}} object to populate with the calculated values.\n\t * If null, a new DisplayProps object is returned.\n\t * @return {DisplayProps} The combined display properties.\n\t **/\n\tp.getConcatenatedDisplayProps = function(props) {\n\t\tprops = props ? props.identity() : new createjs.DisplayProps();\n\t\tvar o = this, mtx = o.getMatrix(props.matrix); \n\t\tdo {\n\t\t\tprops.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation);\n\t\t\t\n\t\t\t// we do this to avoid problems with the matrix being used for both operations when o._props.matrix is passed in as the props param.\n\t\t\t// this could be simplified (ie. just done as part of the prepend above) if we switched to using a pool.\n\t\t\tif (o != this) { mtx.prependMatrix(o.getMatrix(o._props.matrix)); }\n\t\t} while (o = o.parent);\n\t\treturn props;\n\t};\n\n\t/**\n\t * Tests whether the display object intersects the specified point in <em>local</em> coordinates (ie. draws a pixel\n\t * with alpha > 0 at the specified position). This ignores the alpha, shadow, hitArea, mask, and compositeOperation\n\t * of the display object.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \t\tvar myShape = new createjs.Shape();\n\t * \t\tmyShape.graphics.beginFill(\"red\").drawRect(100, 100, 20, 50);\n\t *\n\t * \t\tconsole.log(myShape.hitTest(10,10); // false\n\t * \t\tconsole.log(myShape.hitTest(110, 25); // true\n\t *\n\t * Note that to use Stage coordinates (such as {{#crossLink \"Stage/mouseX:property\"}}{{/crossLink}}), they must\n\t * first be converted to local coordinates:\n\t *\n\t *      stage.addEventListener(\"stagemousedown\", handleMouseDown);\n\t *      function handleMouseDown(event) {\n\t *      \tvar p = myShape.globalToLocal(stage.mouseX, stage.mouseY);\n\t *          var hit = myShape.hitTest(p.x, p.y);\n\t *      }\n\t *\n\t * Shape-to-shape collision is not currently supported by EaselJS.\n\t *\n\t * @method hitTest\n\t * @param {Number} x The x position to check in the display object's local coordinates.\n\t * @param {Number} y The y position to check in the display object's local coordinates.\n\t * @return {Boolean} A Boolean indicating whether a visible portion of the DisplayObject intersect the specified\n\t * local Point.\n\t*/\n\tp.hitTest = function(x, y) {\n\t\tvar ctx = DisplayObject._hitTestContext;\n\t\tctx.setTransform(1, 0, 0, 1, -x, -y);\n\t\tthis.draw(ctx);\n\n\t\tvar hit = this._testHit(ctx);\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\tctx.clearRect(0, 0, 2, 2);\n\t\treturn hit;\n\t};\n\t\n\t/**\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var myGraphics = new createjs.Graphics().beginFill(\"#ff0000\").drawCircle(0, 0, 25);\n\t *      var shape = stage.addChild(new createjs.Shape()).set({graphics:myGraphics, x:100, y:100, alpha:0.5});\n\t *\n\t * @method set\n\t * @param {Object} props A generic object containing properties to copy to the DisplayObject instance.\n\t * @return {DisplayObject} Returns the instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t*/\n\tp.set = function(props) {\n\t\tfor (var n in props) { this[n] = props[n]; }\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Returns a rectangle representing this object's bounds in its local coordinate system (ie. with no transformation).\n\t * Objects that have been cached will return the bounds of the cache.\n\t * \n\t * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use \n\t * {{#crossLink \"DisplayObject/setBounds\"}}{{/crossLink}} so that they are included when calculating Container\n\t * bounds.\n\t * \n\t * <table>\n\t * \t<tr><td><b>All</b></td><td>\n\t * \t\tAll display objects support setting bounds manually using setBounds(). Likewise, display objects that\n\t * \t\thave been cached using cache() will return the bounds of their cache. Manual and cache bounds will override\n\t * \t\tthe automatic calculations listed below.\n\t * \t</td></tr>\n\t * \t<tr><td><b>Bitmap</b></td><td>\n\t * \t\tReturns the width and height of the sourceRect (if specified) or image, extending from (x=0,y=0).\n\t * \t</td></tr>\n\t * \t<tr><td><b>Sprite</b></td><td>\n\t * \t\tReturns the bounds of the current frame. May have non-zero x/y if a frame registration point was specified\n\t * \t\tin the spritesheet data. See also {{#crossLink \"SpriteSheet/getFrameBounds\"}}{{/crossLink}}\n\t * \t</td></tr>\n\t * \t<tr><td><b>Container</b></td><td>\n\t * \t\tReturns the aggregate (combined) bounds of all children that return a non-null value from getBounds().\n\t * \t</td></tr>\n\t * \t<tr><td><b>Shape</b></td><td>\n\t * \t\tDoes not currently support automatic bounds calculations. Use setBounds() to manually define bounds.\n\t * \t</td></tr>\n\t * \t<tr><td><b>Text</b></td><td>\n\t * \t\tReturns approximate bounds. Horizontal values (x/width) are quite accurate, but vertical values (y/height) are\n\t * \t\tnot, especially when using textBaseline values other than \"top\".\n\t * \t</td></tr>\n\t * \t<tr><td><b>BitmapText</b></td><td>\n\t * \t\tReturns approximate bounds. Values will be more accurate if spritesheet frame registration points are close\n\t * \t\tto (x=0,y=0).\n\t * \t</td></tr>\n\t* </table>\n\t * \n\t * Bounds can be expensive to calculate for some objects (ex. text, or containers with many children), and\n\t * are recalculated each time you call getBounds(). You can prevent recalculation on static objects by setting the\n\t * bounds explicitly:\n\t * \n\t * \tvar bounds = obj.getBounds();\n\t * \tobj.setBounds(bounds.x, bounds.y, bounds.width, bounds.height);\n\t * \t// getBounds will now use the set values, instead of recalculating\n\t * \n\t * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its\n\t * values if you need to retain it.\n\t * \n\t * \tvar myBounds = obj.getBounds().clone();\n\t * \t// OR:\n\t * \tmyRect.copy(obj.getBounds());\n\t * \n\t * @method getBounds\n\t * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this\n\t * object.\n\t **/\n\tp.getBounds = function() {\n\t\tif (this._bounds) { return this._rectangle.copy(this._bounds); }\n\t\tvar cacheCanvas = this.cacheCanvas;\n\t\tif (cacheCanvas) {\n\t\t\tvar scale = this._cacheScale;\n\t\t\treturn this._rectangle.setValues(this._cacheOffsetX, this._cacheOffsetY, cacheCanvas.width/scale, cacheCanvas.height/scale);\n\t\t}\n\t\treturn null;\n\t};\n\t\n\t/**\n\t * Returns a rectangle representing this object's bounds in its parent's coordinate system (ie. with transformations applied).\n\t * Objects that have been cached will return the transformed bounds of the cache.\n\t * \n\t * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use \n\t * {{#crossLink \"DisplayObject/setBounds\"}}{{/crossLink}} so that they are included when calculating Container\n\t * bounds.\n\t * \n\t * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its\n\t * values if you need to retain it.\n\t * \n\t * Container instances calculate aggregate bounds for all children that return bounds via getBounds.\n\t * @method getTransformedBounds\n\t * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this object.\n\t **/\n\tp.getTransformedBounds = function() {\n\t\treturn this._getBounds();\n\t};\n\t\n\t/**\n\t * Allows you to manually specify the bounds of an object that either cannot calculate their own bounds (ex. Shape &\n\t * Text) for future reference, or so the object can be included in Container bounds. Manually set bounds will always\n\t * override calculated bounds.\n\t * \n\t * The bounds should be specified in the object's local (untransformed) coordinates. For example, a Shape instance\n\t * with a 25px radius circle centered at 0,0 would have bounds of (-25, -25, 50, 50).\n\t * @method setBounds\n\t * @param {Number} x The x origin of the bounds. Pass null to remove the manual bounds.\n\t * @param {Number} y The y origin of the bounds.\n\t * @param {Number} width The width of the bounds.\n\t * @param {Number} height The height of the bounds.\n\t **/\n\tp.setBounds = function(x, y, width, height) {\n\t\tif (x == null) { this._bounds = x; }\n\t\tthis._bounds = (this._bounds || new createjs.Rectangle()).setValues(x, y, width, height);\n\t};\n\n\t/**\n\t * Returns a clone of this DisplayObject. Some properties that are specific to this instance's current context are\n\t * reverted to their defaults (for example .parent). Caches are not maintained across clones, and some elements\n\t * are copied by reference (masks, individual filter instances, hit area)\n\t * @method clone\n\t * @return {DisplayObject} A clone of the current DisplayObject instance.\n\t **/\n\tp.clone = function() {\n\t\treturn this._cloneProps(new DisplayObject());\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[DisplayObject (name=\"+  this.name +\")]\";\n\t};\n\n\n// private methods:\n\t// separated so it can be used more easily in subclasses:\n\t/**\n\t * @method _cloneProps\n\t * @param {DisplayObject} o The DisplayObject instance which will have properties from the current DisplayObject\n\t * instance copied into.\n\t * @return {DisplayObject} o\n\t * @protected\n\t **/\n\tp._cloneProps = function(o) {\n\t\to.alpha = this.alpha;\n\t\to.mouseEnabled = this.mouseEnabled;\n\t\to.tickEnabled = this.tickEnabled;\n\t\to.name = this.name;\n\t\to.regX = this.regX;\n\t\to.regY = this.regY;\n\t\to.rotation = this.rotation;\n\t\to.scaleX = this.scaleX;\n\t\to.scaleY = this.scaleY;\n\t\to.shadow = this.shadow;\n\t\to.skewX = this.skewX;\n\t\to.skewY = this.skewY;\n\t\to.visible = this.visible;\n\t\to.x  = this.x;\n\t\to.y = this.y;\n\t\to.compositeOperation = this.compositeOperation;\n\t\to.snapToPixel = this.snapToPixel;\n\t\to.filters = this.filters==null?null:this.filters.slice(0);\n\t\to.mask = this.mask;\n\t\to.hitArea = this.hitArea;\n\t\to.cursor = this.cursor;\n\t\to._bounds = this._bounds;\n\t\treturn o;\n\t};\n\n\t/**\n\t * @method _applyShadow\n\t * @protected\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {Shadow} shadow\n\t **/\n\tp._applyShadow = function(ctx, shadow) {\n\t\tshadow = shadow || Shadow.identity;\n\t\tctx.shadowColor = shadow.color;\n\t\tctx.shadowOffsetX = shadow.offsetX;\n\t\tctx.shadowOffsetY = shadow.offsetY;\n\t\tctx.shadowBlur = shadow.blur;\n\t};\n\t\n\t\n\t/**\n\t * @method _tick\n\t * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.\n\t * @protected\n\t **/\n\tp._tick = function(evtObj) {\n\t\t// because tick can be really performance sensitive, check for listeners before calling dispatchEvent.\n\t\tvar ls = this._listeners;\n\t\tif (ls && ls[\"tick\"]) {\n\t\t\t// reset & reuse the event object to avoid construction / GC costs:\n\t\t\tevtObj.target = null;\n\t\t\tevtObj.propagationStopped = evtObj.immediatePropagationStopped = false;\n\t\t\tthis.dispatchEvent(evtObj);\n\t\t}\n\t};\n\n\t/**\n\t * @method _testHit\n\t * @protected\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @return {Boolean}\n\t **/\n\tp._testHit = function(ctx) {\n\t\ttry {\n\t\t\tvar hit = ctx.getImageData(0, 0, 1, 1).data[3] > 1;\n\t\t} catch (e) {\n\t\t\tif (!DisplayObject.suppressCrossDomainErrors) {\n\t\t\t\tthrow \"An error has occurred. This is most likely due to security restrictions on reading canvas pixel data with local or cross-domain images.\";\n\t\t\t}\n\t\t}\n\t\treturn hit;\n\t};\n\n\t/**\n\t * @method _applyFilters\n\t * @protected\n\t **/\n\tp._applyFilters = function() {\n\t\tif (!this.filters || this.filters.length == 0 || !this.cacheCanvas) { return; }\n\t\tvar l = this.filters.length;\n\t\tvar ctx = this.cacheCanvas.getContext(\"2d\");\n\t\tvar w = this.cacheCanvas.width;\n\t\tvar h = this.cacheCanvas.height;\n\t\tfor (var i=0; i<l; i++) {\n\t\t\tthis.filters[i].applyFilter(ctx, 0, 0, w, h);\n\t\t}\n\t};\n\t\n\t/**\n\t * @method _getFilterBounds\n\t * @return {Rectangle}\n\t * @protected\n\t **/\n\tp._getFilterBounds = function(rect) {\n\t\tvar l, filters = this.filters, bounds = this._rectangle.setValues(0,0,0,0);\n\t\tif (!filters || !(l=filters.length)) { return bounds; }\n\t\t\n\t\tfor (var i=0; i<l; i++) {\n\t\t\tvar f = this.filters[i];\n\t\t\tf.getBounds&&f.getBounds(bounds);\n\t\t}\n\t\treturn bounds;\n\t};\n\t\n\t/**\n\t * @method _getBounds\n\t * @param {Matrix2D} matrix\n\t * @param {Boolean} ignoreTransform If true, does not apply this object's transform.\n\t * @return {Rectangle}\n\t * @protected\n\t **/\n\tp._getBounds = function(matrix, ignoreTransform){\n\t\treturn this._transformBounds(this.getBounds(), matrix, ignoreTransform);\n\t};\n\t\n\t/**\n\t * @method _transformBounds\n\t * @param {Rectangle} bounds\n\t * @param {Matrix2D} matrix\n\t * @param {Boolean} ignoreTransform\n\t * @return {Rectangle}\n\t * @protected\n\t **/\n\tp._transformBounds = function(bounds, matrix, ignoreTransform) {\n\t\tif (!bounds) { return bounds; }\n\t\tvar x = bounds.x, y = bounds.y, width = bounds.width, height = bounds.height, mtx = this._props.matrix;\n\t\tmtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);\n\t\t\n\t\tif (x || y) { mtx.appendTransform(0,0,1,1,0,0,0,-x,-y); } // TODO: simplify this.\n\t\tif (matrix) { mtx.prependMatrix(matrix); }\n\t\t\n\t\tvar x_a = width*mtx.a, x_b = width*mtx.b;\n\t\tvar y_c = height*mtx.c, y_d = height*mtx.d;\n\t\tvar tx = mtx.tx, ty = mtx.ty;\n\t\t\n\t\tvar minX = tx, maxX = tx, minY = ty, maxY = ty;\n\n\t\tif ((x = x_a + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }\n\t\tif ((x = x_a + y_c + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }\n\t\tif ((x = y_c + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }\n\t\t\n\t\tif ((y = x_b + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }\n\t\tif ((y = x_b + y_d + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }\n\t\tif ((y = y_d + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }\n\t\t\n\t\treturn bounds.setValues(minX, minY, maxX-minX, maxY-minY);\n\t};\n\t\n\t/**\n\t * Indicates whether the display object has any mouse event listeners or a cursor.\n\t * @method _isMouseOpaque\n\t * @return {Boolean}\n\t * @protected\n\t **/\n\tp._hasMouseEventListener = function() {\n\t\tvar evts = DisplayObject._MOUSE_EVENTS;\n\t\tfor (var i= 0, l=evts.length; i<l; i++) {\n\t\t\tif (this.hasEventListener(evts[i])) { return true; }\n\t\t}\n\t\treturn !!this.cursor;\n\t};\n\n\tcreatejs.DisplayObject = createjs.promote(DisplayObject, \"EventDispatcher\");\n}());\n\n//##############################################################################\n// Container.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\t\n\n// constructor:\n/**\n * A Container is a nestable display list that allows you to work with compound display elements. For  example you could\n * group arm, leg, torso and head {{#crossLink \"Bitmap\"}}{{/crossLink}} instances together into a Person Container, and\n * transform them as a group, while still being able to move the individual parts relative to each other. Children of\n * containers have their <code>transform</code> and <code>alpha</code> properties concatenated with their parent\n * Container.\n *\n * For example, a {{#crossLink \"Shape\"}}{{/crossLink}} with x=100 and alpha=0.5, placed in a Container with <code>x=50</code>\n * and <code>alpha=0.7</code> will be rendered to the canvas at <code>x=150</code> and <code>alpha=0.35</code>.\n * Containers have some overhead, so you generally shouldn't create a Container to hold a single child.\n *\n * <h4>Example</h4>\n *\n *      var container = new createjs.Container();\n *      container.addChild(bitmapInstance, shapeInstance);\n *      container.x = 100;\n *\n * @class Container\n * @extends DisplayObject\n * @constructor\n **/\n\tfunction Container() {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The array of children in the display list. You should usually use the child management methods such as\n\t\t * {{#crossLink \"Container/addChild\"}}{{/crossLink}}, {{#crossLink \"Container/removeChild\"}}{{/crossLink}},\n\t\t * {{#crossLink \"Container/swapChildren\"}}{{/crossLink}}, etc, rather than accessing this directly, but it is\n\t\t * included for advanced uses.\n\t\t * @property children\n\t\t * @type Array\n\t\t * @default null\n\t\t **/\n\t\tthis.children = [];\n\t\t\n\t\t/**\n\t\t * Indicates whether the children of this container are independently enabled for mouse/pointer interaction.\n\t\t * If false, the children will be aggregated under the container - for example, a click on a child shape would\n\t\t * trigger a click event on the container.\n\t\t * @property mouseChildren\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.mouseChildren = true;\n\t\t\n\t\t/**\n\t\t * If false, the tick will not be propagated to children of this Container. This can provide some performance benefits.\n\t\t * In addition to preventing the \"tick\" event from being dispatched, it will also prevent tick related updates\n\t\t * on some display objects (ex. Sprite & MovieClip frame advancing, DOMElement visibility handling).\n\t\t * @property tickChildren\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.tickChildren = true;\n\t}\n\tvar p = createjs.extend(Container, createjs.DisplayObject);\n\t\n\t\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink \"Container/numChildren:property\"}}{{/crossLink}} property instead.\n\t * @method getNumChildren\n\t * @return {Number}\n\t * @deprecated\n\t **/\n\tp.getNumChildren = function() {\n\t\treturn this.children.length;\n\t};\n\n\t/**\n\t * Returns the number of children in the container.\n\t * @property numChildren\n\t * @type {Number}\n\t * @readonly\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tnumChildren: { get: p.getNumChildren }\n\t\t});\n\t} catch (e) {}\n\t\n\n// public methods:\n\t/**\n\t * Constructor alias for backwards compatibility. This method will be removed in future versions.\n\t * Subclasses should be updated to use {{#crossLink \"Utility Methods/extends\"}}{{/crossLink}}.\n\t * @method initialize\n\t * @deprecated in favour of `createjs.promote()`\n\t **/\n\tp.initialize = Container; // TODO: deprecated.\n\t\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar hasContent = this.cacheCanvas || this.children.length;\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\t\t\n\t\t// this ensures we don't have issues with display list changes that occur during a draw:\n\t\tvar list = this.children.slice();\n\t\tfor (var i=0,l=list.length; i<l; i++) {\n\t\t\tvar child = list[i];\n\t\t\tif (!child.isVisible()) { continue; }\n\t\t\t\n\t\t\t// draw the child:\n\t\t\tctx.save();\n\t\t\tchild.updateContext(ctx);\n\t\t\tchild.draw(ctx);\n\t\t\tctx.restore();\n\t\t}\n\t\treturn true;\n\t};\n\t\n\t/**\n\t * Adds a child to the top of the display list.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \t\tcontainer.addChild(bitmapInstance);\n\t *\n\t * You can also add multiple children at once:\n\t *\n\t * \t\tcontainer.addChild(bitmapInstance, shapeInstance, textInstance);\n\t *\n\t * @method addChild\n\t * @param {DisplayObject} child The display object to add.\n\t * @return {DisplayObject} The child that was added, or the last child if multiple children were added.\n\t **/\n\tp.addChild = function(child) {\n\t\tif (child == null) { return child; }\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tfor (var i=0; i<l; i++) { this.addChild(arguments[i]); }\n\t\t\treturn arguments[l-1];\n\t\t}\n\t\tif (child.parent) { child.parent.removeChild(child); }\n\t\tchild.parent = this;\n\t\tthis.children.push(child);\n\t\tchild.dispatchEvent(\"added\");\n\t\treturn child;\n\t};\n\n\t/**\n\t * Adds a child to the display list at the specified index, bumping children at equal or greater indexes up one, and\n\t * setting its parent to this Container.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      addChildAt(child1, index);\n\t *\n\t * You can also add multiple children, such as:\n\t *\n\t *      addChildAt(child1, child2, ..., index);\n\t *\n\t * The index must be between 0 and numChildren. For example, to add myShape under otherShape in the display list,\n\t * you could use:\n\t *\n\t *      container.addChildAt(myShape, container.getChildIndex(otherShape));\n\t *\n\t * This would also bump otherShape's index up by one. Fails silently if the index is out of range.\n\t *\n\t * @method addChildAt\n\t * @param {DisplayObject} child The display object to add.\n\t * @param {Number} index The index to add the child at.\n\t * @return {DisplayObject} Returns the last child that was added, or the last child if multiple children were added.\n\t **/\n\tp.addChildAt = function(child, index) {\n\t\tvar l = arguments.length;\n\t\tvar indx = arguments[l-1]; // can't use the same name as the index param or it replaces arguments[1]\n\t\tif (indx < 0 || indx > this.children.length) { return arguments[l-2]; }\n\t\tif (l > 2) {\n\t\t\tfor (var i=0; i<l-1; i++) { this.addChildAt(arguments[i], indx+i); }\n\t\t\treturn arguments[l-2];\n\t\t}\n\t\tif (child.parent) { child.parent.removeChild(child); }\n\t\tchild.parent = this;\n\t\tthis.children.splice(index, 0, child);\n\t\tchild.dispatchEvent(\"added\");\n\t\treturn child;\n\t};\n\n\t/**\n\t * Removes the specified child from the display list. Note that it is faster to use removeChildAt() if the index is\n\t * already known.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      container.removeChild(child);\n\t *\n\t * You can also remove multiple children:\n\t *\n\t *      removeChild(child1, child2, ...);\n\t *\n\t * Returns true if the child (or children) was removed, or false if it was not in the display list.\n\t * @method removeChild\n\t * @param {DisplayObject} child The child to remove.\n\t * @return {Boolean} true if the child (or children) was removed, or false if it was not in the display list.\n\t **/\n\tp.removeChild = function(child) {\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tvar good = true;\n\t\t\tfor (var i=0; i<l; i++) { good = good && this.removeChild(arguments[i]); }\n\t\t\treturn good;\n\t\t}\n\t\treturn this.removeChildAt(createjs.indexOf(this.children, child));\n\t};\n\n\t/**\n\t * Removes the child at the specified index from the display list, and sets its parent to null.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      container.removeChildAt(2);\n\t *\n\t * You can also remove multiple children:\n\t *\n\t *      container.removeChild(2, 7, ...)\n\t *\n\t * Returns true if the child (or children) was removed, or false if any index was out of range.\n\t * @method removeChildAt\n\t * @param {Number} index The index of the child to remove.\n\t * @return {Boolean} true if the child (or children) was removed, or false if any index was out of range.\n\t **/\n\tp.removeChildAt = function(index) {\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tvar a = [];\n\t\t\tfor (var i=0; i<l; i++) { a[i] = arguments[i]; }\n\t\t\ta.sort(function(a, b) { return b-a; });\n\t\t\tvar good = true;\n\t\t\tfor (var i=0; i<l; i++) { good = good && this.removeChildAt(a[i]); }\n\t\t\treturn good;\n\t\t}\n\t\tif (index < 0 || index > this.children.length-1) { return false; }\n\t\tvar child = this.children[index];\n\t\tif (child) { child.parent = null; }\n\t\tthis.children.splice(index, 1);\n\t\tchild.dispatchEvent(\"removed\");\n\t\treturn true;\n\t};\n\n\t/**\n\t * Removes all children from the display list.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \tcontainer.removeAllChildren();\n\t *\n\t * @method removeAllChildren\n\t **/\n\tp.removeAllChildren = function() {\n\t\tvar kids = this.children;\n\t\twhile (kids.length) { this.removeChildAt(0); }\n\t};\n\n\t/**\n\t * Returns the child at the specified index.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      container.getChildAt(2);\n\t *\n\t * @method getChildAt\n\t * @param {Number} index The index of the child to return.\n\t * @return {DisplayObject} The child at the specified index. Returns null if there is no child at the index.\n\t **/\n\tp.getChildAt = function(index) {\n\t\treturn this.children[index];\n\t};\n\t\n\t/**\n\t * Returns the child with the specified name.\n\t * @method getChildByName\n\t * @param {String} name The name of the child to return.\n\t * @return {DisplayObject} The child with the specified name.\n\t **/\n\tp.getChildByName = function(name) {\n\t\tvar kids = this.children;\n\t\tfor (var i=0,l=kids.length;i<l;i++) {\n\t\t\tif(kids[i].name == name) { return kids[i]; }\n\t\t}\n\t\treturn null;\n\t};\n\n\t/**\n\t * Performs an array sort operation on the child list.\n\t *\n\t * <h4>Example: Display children with a higher y in front.</h4>\n\t * \n\t *      var sortFunction = function(obj1, obj2, options) {\n\t *          if (obj1.y > obj2.y) { return 1; }\n\t *          if (obj1.y < obj2.y) { return -1; }\n\t *          return 0;\n\t *      }\n\t *      container.sortChildren(sortFunction);\n\t *\n\t * @method sortChildren\n\t * @param {Function} sortFunction the function to use to sort the child list. See JavaScript's <code>Array.sort</code>\n\t * documentation for details.\n\t **/\n\tp.sortChildren = function(sortFunction) {\n\t\tthis.children.sort(sortFunction);\n\t};\n\n\t/**\n\t * Returns the index of the specified child in the display list, or -1 if it is not in the display list.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var index = container.getChildIndex(child);\n\t *\n\t * @method getChildIndex\n\t * @param {DisplayObject} child The child to return the index of.\n\t * @return {Number} The index of the specified child. -1 if the child is not found.\n\t **/\n\tp.getChildIndex = function(child) {\n\t\treturn createjs.indexOf(this.children, child);\n\t};\n\t\n\t/**\n\t * Swaps the children at the specified indexes. Fails silently if either index is out of range.\n\t * @method swapChildrenAt\n\t * @param {Number} index1\n\t * @param {Number} index2\n\t **/\n\tp.swapChildrenAt = function(index1, index2) {\n\t\tvar kids = this.children;\n\t\tvar o1 = kids[index1];\n\t\tvar o2 = kids[index2];\n\t\tif (!o1 || !o2) { return; }\n\t\tkids[index1] = o2;\n\t\tkids[index2] = o1;\n\t};\n\t\n\t/**\n\t * Swaps the specified children's depth in the display list. Fails silently if either child is not a child of this\n\t * Container.\n\t * @method swapChildren\n\t * @param {DisplayObject} child1\n\t * @param {DisplayObject} child2\n\t **/\n\tp.swapChildren = function(child1, child2) {\n\t\tvar kids = this.children;\n\t\tvar index1,index2;\n\t\tfor (var i=0,l=kids.length;i<l;i++) {\n\t\t\tif (kids[i] == child1) { index1 = i; }\n\t\t\tif (kids[i] == child2) { index2 = i; }\n\t\t\tif (index1 != null && index2 != null) { break; }\n\t\t}\n\t\tif (i==l) { return; } // TODO: throw error?\n\t\tkids[index1] = child2;\n\t\tkids[index2] = child1;\n\t};\n\t\n\t/**\n\t * Changes the depth of the specified child. Fails silently if the child is not a child of this container, or the index is out of range.\n\t * @param {DisplayObject} child\n\t * @param {Number} index  \n\t * @method setChildIndex\n\t **/\n\tp.setChildIndex = function(child, index) {\n\t\tvar kids = this.children, l=kids.length;\n\t\tif (child.parent != this || index < 0 || index >= l) { return; }\n\t\tfor (var i=0;i<l;i++) {\n\t\t\tif (kids[i] == child) { break; }\n\t\t}\n\t\tif (i==l || i == index) { return; }\n\t\tkids.splice(i,1);\n\t\tkids.splice(index,0,child);\n\t};\n\n\t/**\n\t * Returns true if the specified display object either is this container or is a descendent (child, grandchild, etc)\n\t * of this container.\n\t * @method contains\n\t * @param {DisplayObject} child The DisplayObject to be checked.\n\t * @return {Boolean} true if the specified display object either is this container or is a descendent.\n\t **/\n\tp.contains = function(child) {\n\t\twhile (child) {\n\t\t\tif (child == this) { return true; }\n\t\t\tchild = child.parent;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Tests whether the display object intersects the specified local point (ie. draws a pixel with alpha > 0 at the\n\t * specified position). This ignores the alpha, shadow and compositeOperation of the display object, and all\n\t * transform properties including regX/Y.\n\t * @method hitTest\n\t * @param {Number} x The x position to check in the display object's local coordinates.\n\t * @param {Number} y The y position to check in the display object's local coordinates.\n\t * @return {Boolean} A Boolean indicating whether there is a visible section of a DisplayObject that overlaps the specified\n\t * coordinates.\n\t **/\n\tp.hitTest = function(x, y) {\n\t\t// TODO: optimize to use the fast cache check where possible.\n\t\treturn (this.getObjectUnderPoint(x, y) != null);\n\t};\n\n\t/**\n\t * Returns an array of all display objects under the specified coordinates that are in this container's display\n\t * list. This routine ignores any display objects with {{#crossLink \"DisplayObject/mouseEnabled:property\"}}{{/crossLink}}\n\t * set to `false`. The array will be sorted in order of visual depth, with the top-most display object at index 0.\n\t * This uses shape based hit detection, and can be an expensive operation to run, so it is best to use it carefully.\n\t * For example, if testing for objects under the mouse, test on tick (instead of on {{#crossLink \"DisplayObject/mousemove:event\"}}{{/crossLink}}),\n\t * and only if the mouse's position has changed.\n\t * \n\t * <ul>\n\t *     <li>By default (mode=0) this method evaluates all display objects.</li>\n\t *     <li>By setting the `mode` parameter to `1`, the {{#crossLink \"DisplayObject/mouseEnabled:property\"}}{{/crossLink}}\n\t * \t\tand {{#crossLink \"mouseChildren:property\"}}{{/crossLink}} properties will be respected.</li>\n\t * \t   <li>Setting the `mode` to `2` additionally excludes display objects that do not have active mouse event\n\t * \t   \tlisteners or a {{#crossLink \"DisplayObject:cursor:property\"}}{{/crossLink}} property. That is, only objects\n\t * \t   \tthat would normally intercept mouse interaction will be included. This can significantly improve performance\n\t * \t   \tin some cases by reducing the number of display objects that need to be tested.</li>\n\t * </li>\n\t * \n\t * This method accounts for both {{#crossLink \"DisplayObject/hitArea:property\"}}{{/crossLink}} and {{#crossLink \"DisplayObject/mask:property\"}}{{/crossLink}}.\n\t * @method getObjectsUnderPoint\n\t * @param {Number} x The x position in the container to test.\n\t * @param {Number} y The y position in the container to test.\n\t * @param {Number} [mode=0] The mode to use to determine which display objects to include. 0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.\n\t * @return {Array} An Array of DisplayObjects under the specified coordinates.\n\t **/\n\tp.getObjectsUnderPoint = function(x, y, mode) {\n\t\tvar arr = [];\n\t\tvar pt = this.localToGlobal(x, y);\n\t\tthis._getObjectsUnderPoint(pt.x, pt.y, arr, mode>0, mode==1);\n\t\treturn arr;\n\t};\n\n\t/**\n\t * Similar to {{#crossLink \"Container/getObjectsUnderPoint\"}}{{/crossLink}}, but returns only the top-most display\n\t * object. This runs significantly faster than <code>getObjectsUnderPoint()</code>, but is still potentially an expensive\n\t * operation. See {{#crossLink \"Container/getObjectsUnderPoint\"}}{{/crossLink}} for more information.\n\t * @method getObjectUnderPoint\n\t * @param {Number} x The x position in the container to test.\n\t * @param {Number} y The y position in the container to test.\n\t * @param {Number} mode The mode to use to determine which display objects to include.  0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.\n\t * @return {DisplayObject} The top-most display object under the specified coordinates.\n\t **/\n\tp.getObjectUnderPoint = function(x, y, mode) {\n\t\tvar pt = this.localToGlobal(x, y);\n\t\treturn this._getObjectsUnderPoint(pt.x, pt.y, null, mode>0, mode==1);\n\t};\n\t\n\t/**\n\t * Docced in superclass.\n\t */\n\tp.getBounds = function() {\n\t\treturn this._getBounds(null, true);\n\t};\n\t\n\t\n\t/**\n\t * Docced in superclass.\n\t */\n\tp.getTransformedBounds = function() {\n\t\treturn this._getBounds();\n\t};\n\n\t/**\n\t * Returns a clone of this Container. Some properties that are specific to this instance's current context are\n\t * reverted to their defaults (for example .parent).\n\t * @method clone\n\t * @param {Boolean} [recursive=false] If true, all of the descendants of this container will be cloned recursively. If false, the\n\t * properties of the container will be cloned, but the new instance will not have any children.\n\t * @return {Container} A clone of the current Container instance.\n\t **/\n\tp.clone = function(recursive) {\n\t\tvar o = this._cloneProps(new Container());\n\t\tif (recursive) { this._cloneChildren(o); }\n\t\treturn o;\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Container (name=\"+  this.name +\")]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _tick\n\t * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.\n\t * @protected\n\t **/\n\tp._tick = function(evtObj) {\n\t\tif (this.tickChildren) {\n\t\t\tfor (var i=this.children.length-1; i>=0; i--) {\n\t\t\t\tvar child = this.children[i];\n\t\t\t\tif (child.tickEnabled && child._tick) { child._tick(evtObj); }\n\t\t\t}\n\t\t}\n\t\tthis.DisplayObject__tick(evtObj);\n\t};\n\t\n\t/**\n\t * Recursively clones all children of this container, and adds them to the target container.\n\t * @method cloneChildren\n\t * @protected\n\t * @param {Container} o The target container.\n\t **/\n\tp._cloneChildren = function(o) {\n\t\tif (o.children.length) { o.removeAllChildren(); }\n\t\tvar arr = o.children;\n\t\tfor (var i=0, l=this.children.length; i<l; i++) {\n\t\t\tvar clone = this.children[i].clone(true);\n\t\t\tclone.parent = o;\n\t\t\tarr.push(clone);\n\t\t}\n\t};\n\n\t/**\n\t * @method _getObjectsUnderPoint\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Array} arr\n\t * @param {Boolean} mouse If true, it will respect mouse interaction properties like mouseEnabled, mouseChildren, and active listeners.\n\t * @param {Boolean} activeListener If true, there is an active mouse event listener on a parent object.\n\t * @param {Number} currentDepth Indicates the current depth of the search.\n\t * @return {DisplayObject}\n\t * @protected\n\t **/\n\tp._getObjectsUnderPoint = function(x, y, arr, mouse, activeListener, currentDepth) {\n\t\tcurrentDepth = currentDepth || 0;\n\t\tif (!currentDepth && !this._testMask(this, x, y)) { return null; }\n\t\tvar mtx, ctx = createjs.DisplayObject._hitTestContext;\n\t\tactiveListener = activeListener || (mouse&&this._hasMouseEventListener());\n\n\t\t// draw children one at a time, and check if we get a hit:\n\t\tvar children = this.children, l = children.length;\n\t\tfor (var i=l-1; i>=0; i--) {\n\t\t\tvar child = children[i];\n\t\t\tvar hitArea = child.hitArea;\n\t\t\tif (!child.visible || (!hitArea && !child.isVisible()) || (mouse && !child.mouseEnabled)) { continue; }\n\t\t\tif (!hitArea && !this._testMask(child, x, y)) { continue; }\n\t\t\t\n\t\t\t// if a child container has a hitArea then we only need to check its hitArea, so we can treat it as a normal DO:\n\t\t\tif (!hitArea && child instanceof Container) {\n\t\t\t\tvar result = child._getObjectsUnderPoint(x, y, arr, mouse, activeListener, currentDepth+1);\n\t\t\t\tif (!arr && result) { return (mouse && !this.mouseChildren) ? this : result; }\n\t\t\t} else {\n\t\t\t\tif (mouse && !activeListener && !child._hasMouseEventListener()) { continue; }\n\t\t\t\t\n\t\t\t\t// TODO: can we pass displayProps forward, to avoid having to calculate this backwards every time? It's kind of a mixed bag. When we're only hunting for DOs with event listeners, it may not make sense.\n\t\t\t\tvar props = child.getConcatenatedDisplayProps(child._props);\n\t\t\t\tmtx = props.matrix;\n\t\t\t\t\n\t\t\t\tif (hitArea) {\n\t\t\t\t\tmtx.appendMatrix(hitArea.getMatrix(hitArea._props.matrix));\n\t\t\t\t\tprops.alpha = hitArea.alpha;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tctx.globalAlpha = props.alpha;\n\t\t\t\tctx.setTransform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx-x, mtx.ty-y);\n\t\t\t\t(hitArea||child).draw(ctx);\n\t\t\t\tif (!this._testHit(ctx)) { continue; }\n\t\t\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\t\t\tctx.clearRect(0, 0, 2, 2);\n\t\t\t\tif (arr) { arr.push(child); }\n\t\t\t\telse { return (mouse && !this.mouseChildren) ? this : child; }\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\t\n\t/**\n\t * @method _testMask\n\t * @param {DisplayObject} target\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Boolean} Indicates whether the x/y is within the masked region.\n\t * @protected\n\t **/\n\tp._testMask = function(target, x, y) {\n\t\tvar mask = target.mask;\n\t\tif (!mask || !mask.graphics || mask.graphics.isEmpty()) { return true; }\n\t\t\n\t\tvar mtx = this._props.matrix, parent = target.parent;\n\t\tmtx = parent ? parent.getConcatenatedMatrix(mtx) : mtx.identity();\n\t\tmtx = mask.getMatrix(mask._props.matrix).prependMatrix(mtx);\n\t\t\n\t\tvar ctx = createjs.DisplayObject._hitTestContext;\n\t\tctx.setTransform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx-x, mtx.ty-y);\n\t\t\n\t\t// draw the mask as a solid fill:\n\t\tmask.graphics.drawAsPath(ctx);\n\t\tctx.fillStyle = \"#000\";\n\t\tctx.fill();\n\t\t\n\t\tif (!this._testHit(ctx)) { return false; }\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\tctx.clearRect(0, 0, 2, 2);\n\t\t\n\t\treturn true;\n\t};\n\t\n\t/**\n\t * @method _getBounds\n\t * @param {Matrix2D} matrix\n\t * @param {Boolean} ignoreTransform If true, does not apply this object's transform.\n\t * @return {Rectangle}\n\t * @protected\n\t **/\n\tp._getBounds = function(matrix, ignoreTransform) {\n\t\tvar bounds = this.DisplayObject_getBounds();\n\t\tif (bounds) { return this._transformBounds(bounds, matrix, ignoreTransform); }\n\t\t\n\t\tvar mtx = this._props.matrix;\n\t\tmtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);\n\t\tif (matrix) { mtx.prependMatrix(matrix); }\n\t\t\n\t\tvar l = this.children.length, rect=null;\n\t\tfor (var i=0; i<l; i++) {\n\t\t\tvar child = this.children[i];\n\t\t\tif (!child.visible || !(bounds = child._getBounds(mtx))) { continue; }\n\t\t\tif (rect) { rect.extend(bounds.x, bounds.y, bounds.width, bounds.height); }\n\t\t\telse { rect = bounds.clone(); }\n\t\t}\n\t\treturn rect;\n\t};\n\n\n\tcreatejs.Container = createjs.promote(Container, \"DisplayObject\");\n}());\n\n//##############################################################################\n// Stage.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * A stage is the root level {{#crossLink \"Container\"}}{{/crossLink}} for a display list. Each time its {{#crossLink \"Stage/tick\"}}{{/crossLink}}\n\t * method is called, it will render its display list to its target canvas.\n\t *\n\t * <h4>Example</h4>\n\t * This example creates a stage, adds a child to it, then uses {{#crossLink \"Ticker\"}}{{/crossLink}} to update the child\n\t * and redraw the stage using {{#crossLink \"Stage/update\"}}{{/crossLink}}.\n\t *\n\t *      var stage = new createjs.Stage(\"canvasElementId\");\n\t *      var image = new createjs.Bitmap(\"imagePath.png\");\n\t *      stage.addChild(image);\n\t *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n\t *      function handleTick(event) {\n\t *          image.x += 10;\n\t *          stage.update();\n\t *      }\n\t *\n\t * @class Stage\n\t * @extends Container\n\t * @constructor\n\t * @param {HTMLCanvasElement | String | Object} canvas A canvas object that the Stage will render to, or the string id\n\t * of a canvas object in the current document.\n\t **/\n\tfunction Stage(canvas) {\n\t\tthis.Container_constructor();\n\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * Indicates whether the stage should automatically clear the canvas before each render. You can set this to <code>false</code>\n\t\t * to manually control clearing (for generative art, or when pointing multiple stages at the same canvas for\n\t\t * example).\n\t\t *\n\t\t * <h4>Example</h4>\n\t\t *\n\t\t *      var stage = new createjs.Stage(\"canvasId\");\n\t\t *      stage.autoClear = false;\n\t\t *\n\t\t * @property autoClear\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.autoClear = true;\n\t\n\t\t/**\n\t\t * The canvas the stage will render to. Multiple stages can share a single canvas, but you must disable autoClear for all but the\n\t\t * first stage that will be ticked (or they will clear each other's render).\n\t\t *\n\t\t * When changing the canvas property you must disable the events on the old canvas, and enable events on the\n\t\t * new canvas or mouse events will not work as expected. For example:\n\t\t *\n\t\t *      myStage.enableDOMEvents(false);\n\t\t *      myStage.canvas = anotherCanvas;\n\t\t *      myStage.enableDOMEvents(true);\n\t\t *\n\t\t * @property canvas\n\t\t * @type HTMLCanvasElement | Object\n\t\t **/\n\t\tthis.canvas = (typeof canvas == \"string\") ? document.getElementById(canvas) : canvas;\n\t\n\t\t/**\n\t\t * The current mouse X position on the canvas. If the mouse leaves the canvas, this will indicate the most recent\n\t\t * position over the canvas, and mouseInBounds will be set to false.\n\t\t * @property mouseX\n\t\t * @type Number\n\t\t * @readonly\n\t\t **/\n\t\tthis.mouseX = 0;\n\t\n\t\t/**\n\t\t * The current mouse Y position on the canvas. If the mouse leaves the canvas, this will indicate the most recent\n\t\t * position over the canvas, and mouseInBounds will be set to false.\n\t\t * @property mouseY\n\t\t * @type Number\n\t\t * @readonly\n\t\t **/\n\t\tthis.mouseY = 0;\n\t\n\t\t/**\n\t\t * Specifies the area of the stage to affect when calling update. This can be use to selectively\n\t\t * re-draw specific regions of the canvas. If null, the whole canvas area is drawn.\n\t\t * @property drawRect\n\t\t * @type {Rectangle}\n\t\t */\n\t\tthis.drawRect = null;\n\t\n\t\t/**\n\t\t * Indicates whether display objects should be rendered on whole pixels. You can set the\n\t\t * {{#crossLink \"DisplayObject/snapToPixel\"}}{{/crossLink}} property of\n\t\t * display objects to false to enable/disable this behaviour on a per instance basis.\n\t\t * @property snapToPixelEnabled\n\t\t * @type Boolean\n\t\t * @default false\n\t\t **/\n\t\tthis.snapToPixelEnabled = false;\n\t\n\t\t/**\n\t\t * Indicates whether the mouse is currently within the bounds of the canvas.\n\t\t * @property mouseInBounds\n\t\t * @type Boolean\n\t\t * @default false\n\t\t **/\n\t\tthis.mouseInBounds = false;\n\t\n\t\t/**\n\t\t * If true, tick callbacks will be called on all display objects on the stage prior to rendering to the canvas.\n\t\t * @property tickOnUpdate\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.tickOnUpdate = true;\n\t\n\t\t/**\n\t\t * If true, mouse move events will continue to be called when the mouse leaves the target canvas. See\n\t\t * {{#crossLink \"Stage/mouseInBounds:property\"}}{{/crossLink}}, and {{#crossLink \"MouseEvent\"}}{{/crossLink}}\n\t\t * x/y/rawX/rawY.\n\t\t * @property mouseMoveOutside\n\t\t * @type Boolean\n\t\t * @default false\n\t\t **/\n\t\tthis.mouseMoveOutside = false;\n\t\t\n\t\t\n\t\t/**\n\t\t * Prevents selection of other elements in the html page if the user clicks and drags, or double clicks on the canvas.\n\t\t * This works by calling `preventDefault()` on any mousedown events (or touch equivalent) originating on the canvas.\n\t\t * @property preventSelection\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.preventSelection = true;\n\t\n\t\t/**\n\t\t * The hitArea property is not supported for Stage.\n\t\t * @property hitArea\n\t\t * @type {DisplayObject}\n\t\t * @default null\n\t\t */\n\t\t \n\t\t \n\t// private properties:\n\t\t/**\n\t\t * Holds objects with data for each active pointer id. Each object has the following properties:\n\t\t * x, y, event, target, overTarget, overX, overY, inBounds, posEvtObj (native event that last updated position)\n\t\t * @property _pointerData\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._pointerData = {};\n\t\n\t\t/**\n\t\t * Number of active pointers.\n\t\t * @property _pointerCount\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._pointerCount = 0;\n\t\n\t\t/**\n\t\t * The ID of the primary pointer.\n\t\t * @property _primaryPointerID\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._primaryPointerID = null;\n\t\n\t\t/**\n\t\t * @property _mouseOverIntervalID\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._mouseOverIntervalID = null;\n\t\t\n\t\t/**\n\t\t * @property _nextStage\n\t\t * @protected\n\t\t * @type Stage\n\t\t **/\n\t\tthis._nextStage = null;\n\t\t\n\t\t/**\n\t\t * @property _prevStage\n\t\t * @protected\n\t\t * @type Stage\n\t\t **/\n\t\tthis._prevStage = null;\n\t\t\n\t\t\n\t// initialize:\n\t\tthis.enableDOMEvents(true);\n\t}\n\tvar p = createjs.extend(Stage, createjs.Container);\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// events:\n\t/**\n\t * Dispatched when the user moves the mouse over the canvas.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event stagemousemove\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when the user presses their left mouse button on the canvas. See the {{#crossLink \"MouseEvent\"}}{{/crossLink}}\n\t * class for a listing of event properties.\n\t * @event stagemousedown\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when the user the user presses somewhere on the stage, then releases the mouse button anywhere that the page can detect it (this varies slightly between browsers).\n\t * You can use {{#crossLink \"Stage/mouseInBounds:property\"}}{{/crossLink}} to check whether the mouse is currently within the stage bounds.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event stagemouseup\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when the mouse moves from within the canvas area (mouseInBounds == true) to outside it (mouseInBounds == false).\n\t * This is currently only dispatched for mouse input (not touch). See the {{#crossLink \"MouseEvent\"}}{{/crossLink}}\n\t * class for a listing of event properties.\n\t * @event mouseleave\n\t * @since 0.7.0\n\t */\n\n\t/**\n\t * Dispatched when the mouse moves into the canvas area (mouseInBounds == false) from outside it (mouseInBounds == true).\n\t * This is currently only dispatched for mouse input (not touch). See the {{#crossLink \"MouseEvent\"}}{{/crossLink}}\n\t * class for a listing of event properties.\n\t * @event mouseenter\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * Dispatched each update immediately before the tick event is propagated through the display list.\n\t * You can call preventDefault on the event object to cancel propagating the tick event.\n\t * @event tickstart\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * Dispatched each update immediately after the tick event is propagated through the display list. Does not fire if\n\t * tickOnUpdate is false. Precedes the \"drawstart\" event.\n\t * @event tickend\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * Dispatched each update immediately before the canvas is cleared and the display list is drawn to it.\n\t * You can call preventDefault on the event object to cancel the draw.\n\t * @event drawstart\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * Dispatched each update immediately after the display list is drawn to the canvas and the canvas context is restored.\n\t * @event drawend\n\t * @since 0.7.0\n\t */\n\n\t \n// getter / setters:\n\t/**\n\t * Specifies a target stage that will have mouse / touch interactions relayed to it after this stage handles them.\n\t * This can be useful in cases where you have multiple layered canvases and want user interactions\n\t * events to pass through. For example, this would relay mouse events from topStage to bottomStage:\n\t *\n\t *      topStage.nextStage = bottomStage;\n\t *\n\t * To disable relaying, set nextStage to null.\n\t * \n\t * MouseOver, MouseOut, RollOver, and RollOut interactions are also passed through using the mouse over settings\n\t * of the top-most stage, but are only processed if the target stage has mouse over interactions enabled.\n\t * Considerations when using roll over in relay targets:<OL>\n\t * <LI> The top-most (first) stage must have mouse over interactions enabled (via enableMouseOver)</LI>\n\t * <LI> All stages that wish to participate in mouse over interaction must enable them via enableMouseOver</LI>\n\t * <LI> All relay targets will share the frequency value of the top-most stage</LI>\n\t * </OL>\n\t * To illustrate, in this example the targetStage would process mouse over interactions at 10hz (despite passing\n\t * 30 as it's desired frequency):\n\t * \ttopStage.nextStage = targetStage;\n\t * \ttopStage.enableMouseOver(10);\n\t * \ttargetStage.enableMouseOver(30);\n\t * \n\t * If the target stage's canvas is completely covered by this stage's canvas, you may also want to disable its\n\t * DOM events using:\n\t * \n\t *\ttargetStage.enableDOMEvents(false);\n\t * \n\t * @property nextStage\n\t * @type {Stage}\n\t **/\n\tp._get_nextStage = function() {\n\t\treturn this._nextStage;\n\t};\n\tp._set_nextStage = function(value) {\n\t\tif (this._nextStage) { this._nextStage._prevStage = null; }\n\t\tif (value) { value._prevStage = this; }\n\t\tthis._nextStage = value;\n\t};\n\t\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tnextStage: { get: p._get_nextStage, set: p._set_nextStage }\n\t\t});\n\t} catch (e) {} // TODO: use Log\n\n\n// public methods:\n\t/**\n\t * Each time the update method is called, the stage will call {{#crossLink \"Stage/tick\"}}{{/crossLink}}\n\t * unless {{#crossLink \"Stage/tickOnUpdate:property\"}}{{/crossLink}} is set to false,\n\t * and then render the display list to the canvas.\n\t *\n\t * @method update\n\t * @param {Object} [props] Props object to pass to `tick()`. Should usually be a {{#crossLink \"Ticker\"}}{{/crossLink}} event object, or similar object with a delta property.\n\t **/\n\tp.update = function(props) {\n\t\tif (!this.canvas) { return; }\n\t\tif (this.tickOnUpdate) { this.tick(props); }\n\t\tif (this.dispatchEvent(\"drawstart\", false, true) === false) { return; }\n\t\tcreatejs.DisplayObject._snapToPixelEnabled = this.snapToPixelEnabled;\n\t\tvar r = this.drawRect, ctx = this.canvas.getContext(\"2d\");\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\tif (this.autoClear) {\n\t\t\tif (r) { ctx.clearRect(r.x, r.y, r.width, r.height); }\n\t\t\telse { ctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1); }\n\t\t}\n\t\tctx.save();\n\t\tif (this.drawRect) {\n\t\t\tctx.beginPath();\n\t\t\tctx.rect(r.x, r.y, r.width, r.height);\n\t\t\tctx.clip();\n\t\t}\n\t\tthis.updateContext(ctx);\n\t\tthis.draw(ctx, false);\n\t\tctx.restore();\n\t\tthis.dispatchEvent(\"drawend\");\n\t};\n\t\n\t/**\n\t * Propagates a tick event through the display list. This is automatically called by {{#crossLink \"Stage/update\"}}{{/crossLink}}\n\t * unless {{#crossLink \"Stage/tickOnUpdate:property\"}}{{/crossLink}} is set to false.\n\t *\n\t * If a props object is passed to `tick()`, then all of its properties will be copied to the event object that is\n\t * propagated to listeners.\n\t *\n\t * Some time-based features in EaselJS (for example {{#crossLink \"Sprite/framerate\"}}{{/crossLink}} require that\n\t * a {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}} event object (or equivalent object with a delta property) be\n\t * passed as the `props` parameter to `tick()`. For example:\n\t *\n\t * \tTicker.on(\"tick\", handleTick);\n\t * \tfunction handleTick(evtObj) {\n\t * \t\t// clone the event object from Ticker, and add some custom data to it:\n\t * \t\tvar evt = evtObj.clone().set({greeting:\"hello\", name:\"world\"});\n\t * \t\t\n\t * \t\t// pass it to stage.update():\n\t * \t\tmyStage.update(evt); // subsequently calls tick() with the same param\n\t * \t}\n\t * \t\n\t * \t// ...\n\t * \tmyDisplayObject.on(\"tick\", handleDisplayObjectTick);\n\t * \tfunction handleDisplayObjectTick(evt) {\n\t * \t\tconsole.log(evt.delta); // the delta property from the Ticker tick event object\n\t * \t\tconsole.log(evt.greeting, evt.name); // custom data: \"hello world\"\n\t * \t}\n\t * \n\t * @method tick\n\t * @param {Object} [props] An object with properties that should be copied to the event object. Should usually be a Ticker event object, or similar object with a delta property.\n\t **/\n\tp.tick = function(props) {\n\t\tif (!this.tickEnabled || this.dispatchEvent(\"tickstart\", false, true) === false) { return; }\n\t\tvar evtObj = new createjs.Event(\"tick\");\n\t\tif (props) {\n\t\t\tfor (var n in props) {\n\t\t\t\tif (props.hasOwnProperty(n)) { evtObj[n] = props[n]; }\n\t\t\t}\n\t\t}\n\t\tthis._tick(evtObj);\n\t\tthis.dispatchEvent(\"tickend\");\n\t};\n\n\t/**\n\t * Default event handler that calls the Stage {{#crossLink \"Stage/update\"}}{{/crossLink}} method when a {{#crossLink \"DisplayObject/tick:event\"}}{{/crossLink}}\n\t * event is received. This allows you to register a Stage instance as a event listener on {{#crossLink \"Ticker\"}}{{/crossLink}}\n\t * directly, using:\n\t *\n\t *      Ticker.addEventListener(\"tick\", myStage\");\n\t *\n\t * Note that if you subscribe to ticks using this pattern, then the tick event object will be passed through to\n\t * display object tick handlers, instead of <code>delta</code> and <code>paused</code> parameters.\n\t * @property handleEvent\n\t * @type Function\n\t **/\n\tp.handleEvent = function(evt) {\n\t\tif (evt.type == \"tick\") { this.update(evt); }\n\t};\n\n\t/**\n\t * Clears the target canvas. Useful if {{#crossLink \"Stage/autoClear:property\"}}{{/crossLink}} is set to `false`.\n\t * @method clear\n\t **/\n\tp.clear = function() {\n\t\tif (!this.canvas) { return; }\n\t\tvar ctx = this.canvas.getContext(\"2d\");\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\tctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1);\n\t};\n\n\t/**\n\t * Returns a data url that contains a Base64-encoded image of the contents of the stage. The returned data url can\n\t * be specified as the src value of an image element.\n\t * @method toDataURL\n\t * @param {String} [backgroundColor] The background color to be used for the generated image. Any valid CSS color\n\t * value is allowed. The default value is a transparent background.\n\t * @param {String} [mimeType=\"image/png\"] The MIME type of the image format to be create. The default is \"image/png\". If an unknown MIME type\n\t * is passed in, or if the browser does not support the specified MIME type, the default value will be used.\n\t * @return {String} a Base64 encoded image.\n\t **/\n\tp.toDataURL = function(backgroundColor, mimeType) {\n\t\tvar data, ctx = this.canvas.getContext('2d'), w = this.canvas.width, h = this.canvas.height;\n\n\t\tif (backgroundColor) {\n\t\t\tdata = ctx.getImageData(0, 0, w, h);\n\t\t\tvar compositeOperation = ctx.globalCompositeOperation;\n\t\t\tctx.globalCompositeOperation = \"destination-over\";\n\t\t\t\n\t\t\tctx.fillStyle = backgroundColor;\n\t\t\tctx.fillRect(0, 0, w, h);\n\t\t}\n\n\t\tvar dataURL = this.canvas.toDataURL(mimeType||\"image/png\");\n\n\t\tif(backgroundColor) {\n\t\t\tctx.putImageData(data, 0, 0);\n\t\t\tctx.globalCompositeOperation = compositeOperation;\n\t\t}\n\n\t\treturn dataURL;\n\t};\n\n\t/**\n\t * Enables or disables (by passing a frequency of 0) mouse over ({{#crossLink \"DisplayObject/mouseover:event\"}}{{/crossLink}}\n\t * and {{#crossLink \"DisplayObject/mouseout:event\"}}{{/crossLink}}) and roll over events ({{#crossLink \"DisplayObject/rollover:event\"}}{{/crossLink}}\n\t * and {{#crossLink \"DisplayObject/rollout:event\"}}{{/crossLink}}) for this stage's display list. These events can\n\t * be expensive to generate, so they are disabled by default. The frequency of the events can be controlled\n\t * independently of mouse move events via the optional `frequency` parameter.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var stage = new createjs.Stage(\"canvasId\");\n\t *      stage.enableMouseOver(10); // 10 updates per second\n\t *\n\t * @method enableMouseOver\n\t * @param {Number} [frequency=20] Optional param specifying the maximum number of times per second to broadcast\n\t * mouse over/out events. Set to 0 to disable mouse over events completely. Maximum is 50. A lower frequency is less\n\t * responsive, but uses less CPU.\n\t **/\n\tp.enableMouseOver = function(frequency) {\n\t\tif (this._mouseOverIntervalID) {\n\t\t\tclearInterval(this._mouseOverIntervalID);\n\t\t\tthis._mouseOverIntervalID = null;\n\t\t\tif (frequency == 0) {\n\t\t\t\tthis._testMouseOver(true);\n\t\t\t}\n\t\t}\n\t\tif (frequency == null) { frequency = 20; }\n\t\telse if (frequency <= 0) { return; }\n\t\tvar o = this;\n\t\tthis._mouseOverIntervalID = setInterval(function(){ o._testMouseOver(); }, 1000/Math.min(50,frequency));\n\t};\n\n\t/**\n\t * Enables or disables the event listeners that stage adds to DOM elements (window, document and canvas). It is good\n\t * practice to disable events when disposing of a Stage instance, otherwise the stage will continue to receive\n\t * events from the page.\n\t *\n\t * When changing the canvas property you must disable the events on the old canvas, and enable events on the\n\t * new canvas or mouse events will not work as expected. For example:\n\t *\n\t *      myStage.enableDOMEvents(false);\n\t *      myStage.canvas = anotherCanvas;\n\t *      myStage.enableDOMEvents(true);\n\t *\n\t * @method enableDOMEvents\n\t * @param {Boolean} [enable=true] Indicates whether to enable or disable the events. Default is true.\n\t **/\n\tp.enableDOMEvents = function(enable) {\n\t\tif (enable == null) { enable = true; }\n\t\tvar n, o, ls = this._eventListeners;\n\t\tif (!enable && ls) {\n\t\t\tfor (n in ls) {\n\t\t\t\to = ls[n];\n\t\t\t\to.t.removeEventListener(n, o.f, false);\n\t\t\t}\n\t\t\tthis._eventListeners = null;\n\t\t} else if (enable && !ls && this.canvas) {\n\t\t\tvar t = window.addEventListener ? window : document;\n\t\t\tvar _this = this;\n\t\t\tls = this._eventListeners = {};\n\t\t\tls[\"mouseup\"] = {t:t, f:function(e) { _this._handleMouseUp(e)} };\n\t\t\tls[\"mousemove\"] = {t:t, f:function(e) { _this._handleMouseMove(e)} };\n\t\t\tls[\"dblclick\"] = {t:this.canvas, f:function(e) { _this._handleDoubleClick(e)} };\n\t\t\tls[\"mousedown\"] = {t:this.canvas, f:function(e) { _this._handleMouseDown(e)} };\n\n\t\t\tfor (n in ls) {\n\t\t\t\to = ls[n];\n\t\t\t\to.t.addEventListener(n, o.f, false);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Stage instances cannot be cloned.\n\t * @method clone\n\t **/\n\tp.clone = function() {\n\t\tthrow(\"Stage cannot be cloned.\");\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Stage (name=\"+  this.name +\")]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _getElementRect\n\t * @protected\n\t * @param {HTMLElement} e\n\t **/\n\tp._getElementRect = function(e) {\n\t\tvar bounds;\n\t\ttry { bounds = e.getBoundingClientRect(); } // this can fail on disconnected DOM elements in IE9\n\t\tcatch (err) { bounds = {top: e.offsetTop, left: e.offsetLeft, width:e.offsetWidth, height:e.offsetHeight}; }\n\n\t\tvar offX = (window.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || document.body.clientLeft || 0);\n\t\tvar offY = (window.pageYOffset || document.scrollTop || 0) - (document.clientTop  || document.body.clientTop  || 0);\n\n\t\tvar styles = window.getComputedStyle ? getComputedStyle(e,null) : e.currentStyle; // IE <9 compatibility.\n\t\tvar padL = parseInt(styles.paddingLeft)+parseInt(styles.borderLeftWidth);\n\t\tvar padT = parseInt(styles.paddingTop)+parseInt(styles.borderTopWidth);\n\t\tvar padR = parseInt(styles.paddingRight)+parseInt(styles.borderRightWidth);\n\t\tvar padB = parseInt(styles.paddingBottom)+parseInt(styles.borderBottomWidth);\n\n\t\t// note: in some browsers bounds properties are read only.\n\t\treturn {\n\t\t\tleft: bounds.left+offX+padL,\n\t\t\tright: bounds.right+offX-padR,\n\t\t\ttop: bounds.top+offY+padT,\n\t\t\tbottom: bounds.bottom+offY-padB\n\t\t}\n\t};\n\n\t/**\n\t * @method _getPointerData\n\t * @protected\n\t * @param {Number} id\n\t **/\n\tp._getPointerData = function(id) {\n\t\tvar data = this._pointerData[id];\n\t\tif (!data) { data = this._pointerData[id] = {x:0,y:0}; }\n\t\treturn data;\n\t};\n\n\t/**\n\t * @method _handleMouseMove\n\t * @protected\n\t * @param {MouseEvent} e\n\t **/\n\tp._handleMouseMove = function(e) {\n\t\tif(!e){ e = window.event; }\n\t\tthis._handlePointerMove(-1, e, e.pageX, e.pageY);\n\t};\n\n\t/**\n\t * @method _handlePointerMove\n\t * @protected\n\t * @param {Number} id\n\t * @param {Event} e\n\t * @param {Number} pageX\n\t * @param {Number} pageY\n\t * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t **/\n\tp._handlePointerMove = function(id, e, pageX, pageY, owner) {\n\t\tif (this._prevStage && owner === undefined) { return; } // redundant listener.\n\t\tif (!this.canvas) { return; }\n\t\tvar nextStage=this._nextStage, o=this._getPointerData(id);\n\n\t\tvar inBounds = o.inBounds;\n\t\tthis._updatePointerPosition(id, e, pageX, pageY);\n\t\tif (inBounds || o.inBounds || this.mouseMoveOutside) {\n\t\t\tif (id === -1 && o.inBounds == !inBounds) {\n\t\t\t\tthis._dispatchMouseEvent(this, (inBounds ? \"mouseleave\" : \"mouseenter\"), false, id, o, e);\n\t\t\t}\n\t\t\t\n\t\t\tthis._dispatchMouseEvent(this, \"stagemousemove\", false, id, o, e);\n\t\t\tthis._dispatchMouseEvent(o.target, \"pressmove\", true, id, o, e);\n\t\t}\n\t\t\n\t\tnextStage&&nextStage._handlePointerMove(id, e, pageX, pageY, null);\n\t};\n\n\t/**\n\t * @method _updatePointerPosition\n\t * @protected\n\t * @param {Number} id\n\t * @param {Event} e\n\t * @param {Number} pageX\n\t * @param {Number} pageY\n\t **/\n\tp._updatePointerPosition = function(id, e, pageX, pageY) {\n\t\tvar rect = this._getElementRect(this.canvas);\n\t\tpageX -= rect.left;\n\t\tpageY -= rect.top;\n\n\t\tvar w = this.canvas.width;\n\t\tvar h = this.canvas.height;\n\t\tpageX /= (rect.right-rect.left)/w;\n\t\tpageY /= (rect.bottom-rect.top)/h;\n\t\tvar o = this._getPointerData(id);\n\t\tif (o.inBounds = (pageX >= 0 && pageY >= 0 && pageX <= w-1 && pageY <= h-1)) {\n\t\t\to.x = pageX;\n\t\t\to.y = pageY;\n\t\t} else if (this.mouseMoveOutside) {\n\t\t\to.x = pageX < 0 ? 0 : (pageX > w-1 ? w-1 : pageX);\n\t\t\to.y = pageY < 0 ? 0 : (pageY > h-1 ? h-1 : pageY);\n\t\t}\n\n\t\to.posEvtObj = e;\n\t\to.rawX = pageX;\n\t\to.rawY = pageY;\n\n\t\tif (id === this._primaryPointerID || id === -1) {\n\t\t\tthis.mouseX = o.x;\n\t\t\tthis.mouseY = o.y;\n\t\t\tthis.mouseInBounds = o.inBounds;\n\t\t}\n\t};\n\n\t/**\n\t * @method _handleMouseUp\n\t * @protected\n\t * @param {MouseEvent} e\n\t **/\n\tp._handleMouseUp = function(e) {\n\t\tthis._handlePointerUp(-1, e, false);\n\t};\n\n\t/**\n\t * @method _handlePointerUp\n\t * @protected\n\t * @param {Number} id\n\t * @param {Event} e\n\t * @param {Boolean} clear\n\t * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t **/\n\tp._handlePointerUp = function(id, e, clear, owner) {\n\t\tvar nextStage = this._nextStage, o = this._getPointerData(id);\n\t\tif (this._prevStage && owner === undefined) { return; } // redundant listener.\n\t\t\n\t\tvar target=null, oTarget = o.target;\n\t\tif (!owner && (oTarget || nextStage)) { target = this._getObjectsUnderPoint(o.x, o.y, null, true); }\n\t\t\n\t\tif (o.down) { this._dispatchMouseEvent(this, \"stagemouseup\", false, id, o, e, target); o.down = false; }\n\t\t\n\t\tif (target == oTarget) { this._dispatchMouseEvent(oTarget, \"click\", true, id, o, e); }\n\t\tthis._dispatchMouseEvent(oTarget, \"pressup\", true, id, o, e);\n\t\t\n\t\tif (clear) {\n\t\t\tif (id==this._primaryPointerID) { this._primaryPointerID = null; }\n\t\t\tdelete(this._pointerData[id]);\n\t\t} else { o.target = null; }\n\t\t\n\t\tnextStage&&nextStage._handlePointerUp(id, e, clear, owner || target && this);\n\t};\n\n\t/**\n\t * @method _handleMouseDown\n\t * @protected\n\t * @param {MouseEvent} e\n\t **/\n\tp._handleMouseDown = function(e) {\n\t\tthis._handlePointerDown(-1, e, e.pageX, e.pageY);\n\t};\n\n\t/**\n\t * @method _handlePointerDown\n\t * @protected\n\t * @param {Number} id\n\t * @param {Event} e\n\t * @param {Number} pageX\n\t * @param {Number} pageY\n\t * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t **/\n\tp._handlePointerDown = function(id, e, pageX, pageY, owner) {\n\t\tif (this.preventSelection) { e.preventDefault(); }\n\t\tif (this._primaryPointerID == null || id === -1) { this._primaryPointerID = id; } // mouse always takes over.\n\t\t\n\t\tif (pageY != null) { this._updatePointerPosition(id, e, pageX, pageY); }\n\t\tvar target = null, nextStage = this._nextStage, o = this._getPointerData(id);\n\t\tif (!owner) { target = o.target = this._getObjectsUnderPoint(o.x, o.y, null, true); }\n\n\t\tif (o.inBounds) { this._dispatchMouseEvent(this, \"stagemousedown\", false, id, o, e, target); o.down = true; }\n\t\tthis._dispatchMouseEvent(target, \"mousedown\", true, id, o, e);\n\t\t\n\t\tnextStage&&nextStage._handlePointerDown(id, e, pageX, pageY, owner || target && this);\n\t};\n\n\t/**\n\t * @method _testMouseOver\n\t * @param {Boolean} clear If true, clears the mouseover / rollover (ie. no target)\n\t * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t * @param {Stage} eventTarget The stage that the cursor is actively over.\n\t * @protected\n\t **/\n\tp._testMouseOver = function(clear, owner, eventTarget) {\n\t\tif (this._prevStage && owner === undefined) { return; } // redundant listener.\n\t\t\n\t\tvar nextStage = this._nextStage;\n\t\tif (!this._mouseOverIntervalID) {\n\t\t\t// not enabled for mouseover, but should still relay the event.\n\t\t\tnextStage&&nextStage._testMouseOver(clear, owner, eventTarget);\n\t\t\treturn;\n\t\t}\n\t\tvar o = this._getPointerData(-1);\n\t\t// only update if the mouse position has changed. This provides a lot of optimization, but has some trade-offs.\n\t\tif (!o || (!clear && this.mouseX == this._mouseOverX && this.mouseY == this._mouseOverY && this.mouseInBounds)) { return; }\n\t\t\n\t\tvar e = o.posEvtObj;\n\t\tvar isEventTarget = eventTarget || e&&(e.target == this.canvas);\n\t\tvar target=null, common = -1, cursor=\"\", t, i, l;\n\t\t\n\t\tif (!owner && (clear || this.mouseInBounds && isEventTarget)) {\n\t\t\ttarget = this._getObjectsUnderPoint(this.mouseX, this.mouseY, null, true);\n\t\t\tthis._mouseOverX = this.mouseX;\n\t\t\tthis._mouseOverY = this.mouseY;\n\t\t}\n\n\t\tvar oldList = this._mouseOverTarget||[];\n\t\tvar oldTarget = oldList[oldList.length-1];\n\t\tvar list = this._mouseOverTarget = [];\n\n\t\t// generate ancestor list and check for cursor:\n\t\tt = target;\n\t\twhile (t) {\n\t\t\tlist.unshift(t);\n\t\t\tif (!cursor) { cursor = t.cursor; }\n\t\t\tt = t.parent;\n\t\t}\n\t\tthis.canvas.style.cursor = cursor;\n\t\tif (!owner && eventTarget) { eventTarget.canvas.style.cursor = cursor; }\n\n\t\t// find common ancestor:\n\t\tfor (i=0,l=list.length; i<l; i++) {\n\t\t\tif (list[i] != oldList[i]) { break; }\n\t\t\tcommon = i;\n\t\t}\n\n\t\tif (oldTarget != target) {\n\t\t\tthis._dispatchMouseEvent(oldTarget, \"mouseout\", true, -1, o, e, target);\n\t\t}\n\n\t\tfor (i=oldList.length-1; i>common; i--) {\n\t\t\tthis._dispatchMouseEvent(oldList[i], \"rollout\", false, -1, o, e, target);\n\t\t}\n\n\t\tfor (i=list.length-1; i>common; i--) {\n\t\t\tthis._dispatchMouseEvent(list[i], \"rollover\", false, -1, o, e, oldTarget);\n\t\t}\n\n\t\tif (oldTarget != target) {\n\t\t\tthis._dispatchMouseEvent(target, \"mouseover\", true, -1, o, e, oldTarget);\n\t\t}\n\t\t\n\t\tnextStage&&nextStage._testMouseOver(clear, owner || target && this, eventTarget || isEventTarget && this);\n\t};\n\n\t/**\n\t * @method _handleDoubleClick\n\t * @protected\n\t * @param {MouseEvent} e\n\t * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t **/\n\tp._handleDoubleClick = function(e, owner) {\n\t\tvar target=null, nextStage=this._nextStage, o=this._getPointerData(-1);\n\t\tif (!owner) {\n\t\t\ttarget = this._getObjectsUnderPoint(o.x, o.y, null, true);\n\t\t\tthis._dispatchMouseEvent(target, \"dblclick\", true, -1, o, e);\n\t\t}\n\t\tnextStage&&nextStage._handleDoubleClick(e, owner || target && this);\n\t};\n\n\t/**\n\t * @method _dispatchMouseEvent\n\t * @protected\n\t * @param {DisplayObject} target\n\t * @param {String} type\n\t * @param {Boolean} bubbles\n\t * @param {Number} pointerId\n\t * @param {Object} o\n\t * @param {MouseEvent} [nativeEvent]\n\t * @param {DisplayObject} [relatedTarget]\n\t **/\n\tp._dispatchMouseEvent = function(target, type, bubbles, pointerId, o, nativeEvent, relatedTarget) {\n\t\t// TODO: might be worth either reusing MouseEvent instances, or adding a willTrigger method to avoid GC.\n\t\tif (!target || (!bubbles && !target.hasEventListener(type))) { return; }\n\t\t/*\n\t\t// TODO: account for stage transformations?\n\t\tthis._mtx = this.getConcatenatedMatrix(this._mtx).invert();\n\t\tvar pt = this._mtx.transformPoint(o.x, o.y);\n\t\tvar evt = new createjs.MouseEvent(type, bubbles, false, pt.x, pt.y, nativeEvent, pointerId, pointerId==this._primaryPointerID || pointerId==-1, o.rawX, o.rawY);\n\t\t*/\n\t\tvar evt = new createjs.MouseEvent(type, bubbles, false, o.x, o.y, nativeEvent, pointerId, pointerId === this._primaryPointerID || pointerId === -1, o.rawX, o.rawY, relatedTarget);\n\t\ttarget.dispatchEvent(evt);\n\t};\n\n\n\tcreatejs.Stage = createjs.promote(Stage, \"Container\");\n}());\n\n//##############################################################################\n// Bitmap.js\n//##############################################################################\n\n(function() {\n\t\n\t/**\n\t * A Bitmap represents an Image, Canvas, or Video in the display list. A Bitmap can be instantiated using an existing\n\t * HTML element, or a string.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var bitmap = new createjs.Bitmap(\"imagePath.jpg\");\n\t *\n\t * <strong>Notes:</strong>\n\t * <ol>\n\t *     <li>When a string path or image tag that is not yet loaded is used, the stage may need to be redrawn before it\n\t *      will be displayed.</li>\n\t *     <li>Bitmaps with an SVG source currently will not respect an alpha value other than 0 or 1. To get around this,\n\t *     the Bitmap can be cached.</li>\n\t *     <li>Bitmaps with an SVG source will taint the canvas with cross-origin data, which prevents interactivity. This\n\t *     happens in all browsers except recent Firefox builds.</li>\n\t *     <li>Images loaded cross-origin will throw cross-origin security errors when interacted with using a mouse, using\n\t *     methods such as `getObjectUnderPoint`, or using filters, or caching. You can get around this by setting\n\t *     `crossOrigin` flags on your images before passing them to EaselJS, eg: `img.crossOrigin=\"Anonymous\";`</li>\n\t * </ol>\n\t *\n\t * @class Bitmap\n\t * @extends DisplayObject\n\t * @constructor\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | String} imageOrUri The source object or URI to an image to\n\t * display. This can be either an Image, Canvas, or Video object, or a string URI to an image file to load and use.\n\t * If it is a URI, a new Image object will be constructed and assigned to the .image property.\n\t **/\n\tfunction Bitmap(imageOrUri) {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The image to render. This can be an Image, a Canvas, or a Video. Not all browsers (especially\n\t\t * mobile browsers) support drawing video to a canvas.\n\t\t * @property image\n\t\t * @type HTMLImageElement | HTMLCanvasElement | HTMLVideoElement\n\t\t **/\n\t\tif (typeof imageOrUri == \"string\") {\n\t\t\tthis.image = document.createElement(\"img\");\n\t\t\tthis.image.src = imageOrUri;\n\t\t} else {\n\t\t\tthis.image = imageOrUri;\n\t\t}\n\t\n\t\t/**\n\t\t * Specifies an area of the source image to draw. If omitted, the whole image will be drawn.\n\t\t * Note that video sources must have a width / height set to work correctly with `sourceRect`.\n\t\t * @property sourceRect\n\t\t * @type Rectangle\n\t\t * @default null\n\t\t */\n\t\tthis.sourceRect = null;\n\t}\n\tvar p = createjs.extend(Bitmap, createjs.DisplayObject);\n\t\n\t\n// public methods:\n\t/**\n\t * Constructor alias for backwards compatibility. This method will be removed in future versions.\n\t * Subclasses should be updated to use {{#crossLink \"Utility Methods/extends\"}}{{/crossLink}}.\n\t * @method initialize\n\t * @deprecated in favour of `createjs.promote()`\n\t **/\n\tp.initialize = Bitmap; // TODO: deprecated.\n\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar image = this.image;\n\t\tvar hasContent = this.cacheCanvas || (image && (image.naturalWidth || image.getContext || image.readyState >= 2));\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t * @return {Boolean}\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache) || !this.image) { return true; }\n\t\tvar img = this.image, rect = this.sourceRect;\n\t\tif (rect) {\n\t\t\t// some browsers choke on out of bound values, so we'll fix them:\n\t\t\tvar x1 = rect.x, y1 = rect.y, x2 = x1 + rect.width, y2 = y1 + rect.height, x = 0, y = 0, w = img.width, h = img.height;\n\t\t\tif (x1 < 0) { x -= x1; x1 = 0; }\n\t\t\tif (x2 > w) { x2 = w; }\n\t\t\tif (y1 < 0) { y -= y1; y1 = 0; }\n\t\t\tif (y2 > h) { y2 = h; }\n\t\t\tctx.drawImage(img, x1, y1, x2-x1, y2-y1, x, y, x2-x1, y2-y1);\n\t\t} else {\n\t\t\tctx.drawImage(img, 0, 0);\n\t\t}\n\t\treturn true;\n\t};\n\t\n\t//Note, the doc sections below document using the specified APIs (from DisplayObject)  from\n\t//Bitmap. This is why they have no method implementations.\n\t\n\t/**\n\t * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.\n\t * You should <b>not</b> cache Bitmap instances as it can degrade performance.\n\t *\n\t * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>\n\t * To see the API for caching, please visit the DisplayObject {{#crossLink \"DisplayObject/cache\"}}{{/crossLink}}\n\t * method.\n\t * @method cache\n\t **/\n\t\n\t/**\n\t * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.\n\t * You should <b>not</b> cache Bitmap instances as it can degrade performance.\n\t *\n\t * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>\n\t * To see the API for caching, please visit the DisplayObject {{#crossLink \"DisplayObject/cache\"}}{{/crossLink}}\n\t * method.\n\t * @method updateCache\n\t **/\n\t\n\t/**\n\t * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.\n\t * You should <b>not</b> cache Bitmap instances as it can degrade performance.\n\t *\n\t * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>\n\t * To see the API for caching, please visit the DisplayObject {{#crossLink \"DisplayObject/cache\"}}{{/crossLink}}\n\t * method.\n\t * @method uncache\n\t **/\n\n\t/**\n\t * Docced in superclass.\n\t */\n\tp.getBounds = function() {\n\t\tvar rect = this.DisplayObject_getBounds();\n\t\tif (rect) { return rect; }\n\t\tvar image = this.image, o = this.sourceRect || image;\n\t\tvar hasContent = (image && (image.naturalWidth || image.getContext || image.readyState >= 2));\n\t\treturn hasContent ? this._rectangle.setValues(0, 0, o.width, o.height) : null;\n\t};\n\t\n\t/**\n\t * Returns a clone of the Bitmap instance.\n\t * @method clone\n\t * @return {Bitmap} a clone of the Bitmap instance.\n\t **/\n\tp.clone = function() {\n\t\tvar o = new Bitmap(this.image);\n\t\tif (this.sourceRect) { o.sourceRect = this.sourceRect.clone(); }\n\t\tthis._cloneProps(o);\n\t\treturn o;\n\t};\n\t\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Bitmap (name=\"+  this.name +\")]\";\n\t};\n\n\t\n\tcreatejs.Bitmap = createjs.promote(Bitmap, \"DisplayObject\");\n}());\n\n//##############################################################################\n// Sprite.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Displays a frame or sequence of frames (ie. an animation) from a SpriteSheet instance. A sprite sheet is a series of\n\t * images (usually animation frames) combined into a single image. For example, an animation consisting of 8 100x100\n\t * images could be combined into a 400x200 sprite sheet (4 frames across by 2 high). You can display individual frames,\n\t * play frames as an animation, and even sequence animations together.\n\t *\n\t * See the {{#crossLink \"SpriteSheet\"}}{{/crossLink}} class for more information on setting up frames and animations.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var instance = new createjs.Sprite(spriteSheet);\n\t *      instance.gotoAndStop(\"frameName\");\n\t *\n\t * Until {{#crossLink \"Sprite/gotoAndStop\"}}{{/crossLink}} or {{#crossLink \"Sprite/gotoAndPlay\"}}{{/crossLink}} is called,\n\t * only the first defined frame defined in the sprite sheet will be displayed.\n\t *\n\t * @class Sprite\n\t * @extends DisplayObject\n\t * @constructor\n\t * @param {SpriteSheet} spriteSheet The SpriteSheet instance to play back. This includes the source image(s), frame\n\t * dimensions, and frame data. See {{#crossLink \"SpriteSheet\"}}{{/crossLink}} for more information.\n\t * @param {String|Number} [frameOrAnimation] The frame number or animation to play initially.\n\t **/\n\tfunction Sprite(spriteSheet, frameOrAnimation) {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The frame index that will be drawn when draw is called. Note that with some {{#crossLink \"SpriteSheet\"}}{{/crossLink}}\n\t\t * definitions, this will advance non-sequentially. This will always be an integer value.\n\t\t * @property currentFrame\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @readonly\n\t\t **/\n\t\tthis.currentFrame = 0;\n\t\n\t\t/**\n\t\t * Returns the name of the currently playing animation.\n\t\t * @property currentAnimation\n\t\t * @type {String}\n\t\t * @final\n\t\t * @readonly\n\t\t **/\n\t\tthis.currentAnimation = null;\n\t\n\t\t/**\n\t\t * Prevents the animation from advancing each tick automatically. For example, you could create a sprite\n\t\t * sheet of icons, set paused to true, and display the appropriate icon by setting <code>currentFrame</code>.\n\t\t * @property paused\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t **/\n\t\tthis.paused = true;\n\t\n\t\t/**\n\t\t * The SpriteSheet instance to play back. This includes the source image, frame dimensions, and frame\n\t\t * data. See {{#crossLink \"SpriteSheet\"}}{{/crossLink}} for more information.\n\t\t * @property spriteSheet\n\t\t * @type {SpriteSheet}\n\t\t * @readonly\n\t\t **/\n\t\tthis.spriteSheet = spriteSheet;\n\t\n\t\t/**\n\t\t * Specifies the current frame index within the currently playing animation. When playing normally, this will increase\n\t\t * from 0 to n-1, where n is the number of frames in the current animation.\n\t\t *\n\t\t * This could be a non-integer value if\n\t\t * using time-based playback (see {{#crossLink \"Sprite/framerate\"}}{{/crossLink}}, or if the animation's speed is\n\t\t * not an integer.\n\t\t * @property currentAnimationFrame\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.currentAnimationFrame = 0;\n\t\n\t\t/**\n\t\t * By default Sprite instances advance one frame per tick. Specifying a framerate for the Sprite (or its related\n\t\t * SpriteSheet) will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\n\t\t * framerate.\n\t\t *\n\t\t * For example, if a Sprite with a framerate of 10 is placed on a Stage being updated at 40fps, then the Sprite will\n\t\t * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will\n\t\t * vary slightly between frames.\n\t\t *\n\t\t * This feature is dependent on the tick event object (or an object with an appropriate \"delta\" property) being\n\t\t * passed into {{#crossLink \"Stage/update\"}}{{/crossLink}}.\n\t\t * @property framerate\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.framerate = 0;\n\t\n\t\n\t// private properties:\n\t\t/**\n\t\t * Current animation object.\n\t\t * @property _animation\n\t\t * @protected\n\t\t * @type {Object}\n\t\t * @default null\n\t\t **/\n\t\tthis._animation = null;\n\t\n\t\t/**\n\t\t * Current frame index.\n\t\t * @property _currentFrame\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default null\n\t\t **/\n\t\tthis._currentFrame = null;\n\t\t\n\t\t/**\n\t\t * Skips the next auto advance. Used by gotoAndPlay to avoid immediately jumping to the next frame\n\t\t * @property _skipAdvance\n\t\t * @protected\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t **/\n\t\tthis._skipAdvance = false;\n\t\t\n\t\t\n\t\tif (frameOrAnimation != null) { this.gotoAndPlay(frameOrAnimation); }\n\t}\n\tvar p = createjs.extend(Sprite, createjs.DisplayObject);\n\n\t/**\n\t * Constructor alias for backwards compatibility. This method will be removed in future versions.\n\t * Subclasses should be updated to use {{#crossLink \"Utility Methods/extends\"}}{{/crossLink}}.\n\t * @method initialize\n\t * @deprecated in favour of `createjs.promote()`\n\t **/\n\tp.initialize = Sprite; // TODO: Deprecated. This is for backwards support of FlashCC spritesheet export.\n\n\n// events:\n\t/**\n\t * Dispatched when an animation reaches its ends.\n\t * @event animationend\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {String} name The name of the animation that just ended.\n\t * @param {String} next The name of the next animation that will be played, or null. This will be the same as name if the animation is looping.\n\t * @since 0.6.0\n\t */\n\t \n\t/**\n\t * Dispatched any time the current frame changes. For example, this could be due to automatic advancement on a tick,\n\t * or calling gotoAndPlay() or gotoAndStop().\n\t * @event change\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t */\n\n\n// public methods:\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar hasContent = this.cacheCanvas || this.spriteSheet.complete;\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\t\tthis._normalizeFrame();\n\t\tvar o = this.spriteSheet.getFrame(this._currentFrame|0);\n\t\tif (!o) { return false; }\n\t\tvar rect = o.rect;\n\t\tif (rect.width && rect.height) { ctx.drawImage(o.image, rect.x, rect.y, rect.width, rect.height, -o.regX, -o.regY, rect.width, rect.height); }\n\t\treturn true;\n\t};\n\n\t//Note, the doc sections below document using the specified APIs (from DisplayObject)  from\n\t//Bitmap. This is why they have no method implementations.\n\n\t/**\n\t * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.\n\t * You should not cache Sprite instances as it can degrade performance.\n\t * @method cache\n\t **/\n\n\t/**\n\t * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.\n\t * You should not cache Sprite instances as it can degrade performance.\n\t * @method updateCache\n\t **/\n\n\t/**\n\t * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.\n\t * You should not cache Sprite instances as it can degrade performance.\n\t * @method uncache\n\t **/\n\n\t/**\n\t * Play (unpause) the current animation. The Sprite will be paused if either {{#crossLink \"Sprite/stop\"}}{{/crossLink}}\n\t * or {{#crossLink \"Sprite/gotoAndStop\"}}{{/crossLink}} is called. Single frame animations will remain\n\t * unchanged.\n\t * @method play\n\t **/\n\tp.play = function() {\n\t\tthis.paused = false;\n\t};\n\n\t/**\n\t * Stop playing a running animation. The Sprite will be playing if {{#crossLink \"Sprite/gotoAndPlay\"}}{{/crossLink}}\n\t * is called. Note that calling {{#crossLink \"Sprite/gotoAndPlay\"}}{{/crossLink}} or {{#crossLink \"Sprite/play\"}}{{/crossLink}}\n\t * will resume playback.\n\t * @method stop\n\t **/\n\tp.stop = function() {\n\t\tthis.paused = true;\n\t};\n\n\t/**\n\t * Sets paused to false and plays the specified animation name, named frame, or frame number.\n\t * @method gotoAndPlay\n\t * @param {String|Number} frameOrAnimation The frame number or animation name that the playhead should move to\n\t * and begin playing.\n\t **/\n\tp.gotoAndPlay = function(frameOrAnimation) {\n\t\tthis.paused = false;\n\t\tthis._skipAdvance = true;\n\t\tthis._goto(frameOrAnimation);\n\t};\n\n\t/**\n\t * Sets paused to true and seeks to the specified animation name, named frame, or frame number.\n\t * @method gotoAndStop\n\t * @param {String|Number} frameOrAnimation The frame number or animation name that the playhead should move to\n\t * and stop.\n\t **/\n\tp.gotoAndStop = function(frameOrAnimation) {\n\t\tthis.paused = true;\n\t\tthis._goto(frameOrAnimation);\n\t};\n\n\t/**\n\t * Advances the playhead. This occurs automatically each tick by default.\n\t * @param [time] {Number} The amount of time in ms to advance by. Only applicable if framerate is set on the Sprite\n\t * or its SpriteSheet.\n\t * @method advance\n\t*/\n\tp.advance = function(time) {\n\t\tvar fps = this.framerate || this.spriteSheet.framerate;\n\t\tvar t = (fps && time != null) ? time/(1000/fps) : 1;\n\t\tthis._normalizeFrame(t);\n\t};\n\t\n\t/**\n\t * Returns a {{#crossLink \"Rectangle\"}}{{/crossLink}} instance defining the bounds of the current frame relative to\n\t * the origin. For example, a 90 x 70 frame with <code>regX=50</code> and <code>regY=40</code> would return a\n\t * rectangle with [x=-50, y=-40, width=90, height=70]. This ignores transformations on the display object.\n\t *\n\t * Also see the SpriteSheet {{#crossLink \"SpriteSheet/getFrameBounds\"}}{{/crossLink}} method.\n\t * @method getBounds\n\t * @return {Rectangle} A Rectangle instance. Returns null if the frame does not exist, or the image is not fully\n\t * loaded.\n\t **/\n\tp.getBounds = function() {\n\t\t// TODO: should this normalizeFrame?\n\t\treturn this.DisplayObject_getBounds() || this.spriteSheet.getFrameBounds(this.currentFrame, this._rectangle);\n\t};\n\n\t/**\n\t * Returns a clone of the Sprite instance. Note that the same SpriteSheet is shared between cloned\n\t * instances.\n\t * @method clone\n\t * @return {Sprite} a clone of the Sprite instance.\n\t **/\n\tp.clone = function() {\n\t\treturn this._cloneProps(new Sprite(this.spriteSheet));\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Sprite (name=\"+  this.name +\")]\";\n\t};\n\n// private methods:\n\t/**\n\t * @method _cloneProps\n\t * @param {Sprite} o\n\t * @return {Sprite} o\n\t * @protected\n\t **/\n\tp._cloneProps = function(o) {\n\t\tthis.DisplayObject__cloneProps(o);\n\t\to.currentFrame = this.currentFrame;\n\t\to.currentAnimation = this.currentAnimation;\n\t\to.paused = this.paused;\n\t\to.currentAnimationFrame = this.currentAnimationFrame;\n\t\to.framerate = this.framerate;\n\t\t\n\t\to._animation = this._animation;\n\t\to._currentFrame = this._currentFrame;\n\t\to._skipAdvance = this._skipAdvance;\n\t\treturn o;\n\t};\n\t\n\t/**\n\t * Advances the <code>currentFrame</code> if paused is not true. This is called automatically when the {{#crossLink \"Stage\"}}{{/crossLink}}\n\t * ticks.\n\t * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.\n\t * @protected\n\t * @method _tick\n\t **/\n\tp._tick = function(evtObj) {\n\t\tif (!this.paused) {\n\t\t\tif (!this._skipAdvance) { this.advance(evtObj&&evtObj.delta); }\n\t\t\tthis._skipAdvance = false;\n\t\t}\n\t\tthis.DisplayObject__tick(evtObj);\n\t};\n\n\n\t/**\n\t * Normalizes the current frame, advancing animations and dispatching callbacks as appropriate.\n\t * @protected\n\t * @method _normalizeFrame\n\t **/\n\tp._normalizeFrame = function(frameDelta) {\n\t\tframeDelta = frameDelta || 0;\n\t\tvar animation = this._animation;\n\t\tvar paused = this.paused;\n\t\tvar frame = this._currentFrame;\n\t\tvar l;\n\t\t\n\t\tif (animation) {\n\t\t\tvar speed = animation.speed || 1;\n\t\t\tvar animFrame = this.currentAnimationFrame;\n\t\t\tl = animation.frames.length;\n\t\t\tif (animFrame + frameDelta * speed >= l) {\n\t\t\t\tvar next = animation.next;\n\t\t\t\tif (this._dispatchAnimationEnd(animation, frame, paused, next, l - 1)) {\n\t\t\t\t\t// something changed in the event stack, so we shouldn't make any more changes here.\n\t\t\t\t\treturn;\n\t\t\t\t} else if (next) {\n\t\t\t\t\t// sequence. Automatically calls _normalizeFrame again with the remaining frames.\n\t\t\t\t\treturn this._goto(next, frameDelta - (l - animFrame) / speed);\n\t\t\t\t} else {\n\t\t\t\t\t// end.\n\t\t\t\t\tthis.paused = true;\n\t\t\t\t\tanimFrame = animation.frames.length - 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tanimFrame += frameDelta * speed;\n\t\t\t}\n\t\t\tthis.currentAnimationFrame = animFrame;\n\t\t\tthis._currentFrame = animation.frames[animFrame | 0]\n\t\t} else {\n\t\t\tframe = (this._currentFrame += frameDelta);\n\t\t\tl = this.spriteSheet.getNumFrames();\n\t\t\tif (frame >= l && l > 0) {\n\t\t\t\tif (!this._dispatchAnimationEnd(animation, frame, paused, l - 1)) {\n\t\t\t\t\t// looped.\n\t\t\t\t\tif ((this._currentFrame -= l) >= l) { return this._normalizeFrame(); }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tframe = this._currentFrame | 0;\n\t\tif (this.currentFrame != frame) {\n\t\t\tthis.currentFrame = frame;\n\t\t\tthis.dispatchEvent(\"change\");\n\t\t}\n\t};\n\n\t/**\n\t * Dispatches the \"animationend\" event. Returns true if a handler changed the animation (ex. calling {{#crossLink \"Sprite/stop\"}}{{/crossLink}},\n\t * {{#crossLink \"Sprite/gotoAndPlay\"}}{{/crossLink}}, etc.)\n\t * @property _dispatchAnimationEnd\n\t * @private\n\t * @type {Function}\n\t **/\n\tp._dispatchAnimationEnd = function(animation, frame, paused, next, end) {\n\t\tvar name = animation ? animation.name : null;\n\t\tif (this.hasEventListener(\"animationend\")) {\n\t\t\tvar evt = new createjs.Event(\"animationend\");\n\t\t\tevt.name = name;\n\t\t\tevt.next = next;\n\t\t\tthis.dispatchEvent(evt);\n\t\t}\n\t\t// did the animation get changed in the event stack?:\n\t\tvar changed = (this._animation != animation || this._currentFrame != frame);\n\t\t// if the animation hasn't changed, but the sprite was paused, then we want to stick to the last frame:\n\t\tif (!changed && !paused && this.paused) { this.currentAnimationFrame = end; changed = true; }\n\t\treturn changed;\n\t};\n\n\t/**\n\t * Moves the playhead to the specified frame number or animation.\n\t * @method _goto\n\t * @param {String|Number} frameOrAnimation The frame number or animation that the playhead should move to.\n\t * @param {Boolean} [frame] The frame of the animation to go to. Defaults to 0.\n\t * @protected\n\t **/\n\tp._goto = function(frameOrAnimation, frame) {\n\t\tthis.currentAnimationFrame = 0;\n\t\tif (isNaN(frameOrAnimation)) {\n\t\t\tvar data = this.spriteSheet.getAnimation(frameOrAnimation);\n\t\t\tif (data) {\n\t\t\t\tthis._animation = data;\n\t\t\t\tthis.currentAnimation = frameOrAnimation;\n\t\t\t\tthis._normalizeFrame(frame);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.currentAnimation = this._animation = null;\n\t\t\tthis._currentFrame = frameOrAnimation;\n\t\t\tthis._normalizeFrame();\n\t\t}\n\t};\n\n\n\tcreatejs.Sprite = createjs.promote(Sprite, \"DisplayObject\");\n}());\n\n//##############################################################################\n// Shape.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * A Shape allows you to display vector art in the display list. It composites a {{#crossLink \"Graphics\"}}{{/crossLink}}\n\t * instance which exposes all of the vector drawing methods. The Graphics instance can be shared between multiple Shape\n\t * instances to display the same vector graphics with different positions or transforms.\n\t *\n\t * If the vector art will not\n\t * change between draws, you may want to use the {{#crossLink \"DisplayObject/cache\"}}{{/crossLink}} method to reduce the\n\t * rendering cost.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var graphics = new createjs.Graphics().beginFill(\"#ff0000\").drawRect(0, 0, 100, 100);\n\t *      var shape = new createjs.Shape(graphics);\n\t *\n\t *      //Alternatively use can also use the graphics property of the Shape class to renderer the same as above.\n\t *      var shape = new createjs.Shape();\n\t *      shape.graphics.beginFill(\"#ff0000\").drawRect(0, 0, 100, 100);\n\t *\n\t * @class Shape\n\t * @extends DisplayObject\n\t * @constructor\n\t * @param {Graphics} graphics Optional. The graphics instance to display. If null, a new Graphics instance will be created.\n\t **/\n\tfunction Shape(graphics) {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The graphics instance to display.\n\t\t * @property graphics\n\t\t * @type Graphics\n\t\t **/\n\t\tthis.graphics = graphics ? graphics : new createjs.Graphics();\n\t}\n\tvar p = createjs.extend(Shape, createjs.DisplayObject);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// public methods:\n\t/**\n\t * Returns true or false indicating whether the Shape would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the Shape would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar hasContent = this.cacheCanvas || (this.graphics && !this.graphics.isEmpty());\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t};\n\n\t/**\n\t * Draws the Shape into the specified context ignoring its visible, alpha, shadow, and transform. Returns true if\n\t * the draw was handled (useful for overriding functionality).\n\t *\n\t * <i>NOTE: This method is mainly for internal use, though it may be useful for advanced uses.</i>\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,\n\t * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).\n\t * @return {Boolean}\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\t\tthis.graphics.draw(ctx, this);\n\t\treturn true;\n\t};\n\n\t/**\n\t * Returns a clone of this Shape. Some properties that are specific to this instance's current context are reverted to\n\t * their defaults (for example .parent).\n\t * @method clone\n\t * @param {Boolean} recursive If true, this Shape's {{#crossLink \"Graphics\"}}{{/crossLink}} instance will also be\n\t * cloned. If false, the Graphics instance will be shared with the new Shape.\n\t **/\n\tp.clone = function(recursive) {\n\t\tvar g = (recursive && this.graphics) ? this.graphics.clone() : this.graphics;\n\t\treturn  this._cloneProps(new Shape(g));\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Shape (name=\"+  this.name +\")]\";\n\t};\n\n\n\tcreatejs.Shape = createjs.promote(Shape, \"DisplayObject\");\n}());\n\n//##############################################################################\n// Text.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Display one or more lines of dynamic text (not user editable) in the display list. Line wrapping support (using the\n\t * lineWidth) is very basic, wrapping on spaces and tabs only. Note that as an alternative to Text, you can position HTML\n\t * text above or below the canvas relative to items in the display list using the {{#crossLink \"DisplayObject/localToGlobal\"}}{{/crossLink}}\n\t * method, or using {{#crossLink \"DOMElement\"}}{{/crossLink}}.\n\t *\n\t * <b>Please note that Text does not support HTML text, and can only display one font style at a time.</b> To use\n\t * multiple font styles, you will need to create multiple text instances, and position them manually.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var text = new createjs.Text(\"Hello World\", \"20px Arial\", \"#ff7700\");\n\t *      text.x = 100;\n\t *      text.textBaseline = \"alphabetic\";\n\t *\n\t * CreateJS Text supports web fonts (the same rules as Canvas). The font must be loaded and supported by the browser\n\t * before it can be displayed.\n\t *\n\t * <strong>Note:</strong> Text can be expensive to generate, so cache instances where possible. Be aware that not all\n\t * browsers will render Text exactly the same.\n\t * @class Text\n\t * @extends DisplayObject\n\t * @constructor\n\t * @param {String} [text] The text to display.\n\t * @param {String} [font] The font style to use. Any valid value for the CSS font attribute is acceptable (ex. \"bold\n\t * 36px Arial\").\n\t * @param {String} [color] The color to draw the text in. Any valid value for the CSS color attribute is acceptable (ex.\n\t * \"#F00\", \"red\", or \"#FF0000\").\n\t **/\n\tfunction Text(text, font, color) {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The text to display.\n\t\t * @property text\n\t\t * @type String\n\t\t **/\n\t\tthis.text = text;\n\t\n\t\t/**\n\t\t * The font style to use. Any valid value for the CSS font attribute is acceptable (ex. \"bold 36px Arial\").\n\t\t * @property font\n\t\t * @type String\n\t\t **/\n\t\tthis.font = font;\n\t\n\t\t/**\n\t\t * The color to draw the text in. Any valid value for the CSS color attribute is acceptable (ex. \"#F00\"). Default is \"#000\".\n\t\t * It will also accept valid canvas fillStyle values.\n\t\t * @property color\n\t\t * @type String\n\t\t **/\n\t\tthis.color = color;\n\t\n\t\t/**\n\t\t * The horizontal text alignment. Any of \"start\", \"end\", \"left\", \"right\", and \"center\". For detailed\n\t\t * information view the\n\t\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles\">\n\t\t * whatwg spec</a>. Default is \"left\".\n\t\t * @property textAlign\n\t\t * @type String\n\t\t **/\n\t\tthis.textAlign = \"left\";\n\t\n\t\t/**\n\t\t * The vertical alignment point on the font. Any of \"top\", \"hanging\", \"middle\", \"alphabetic\", \"ideographic\", or\n\t\t * \"bottom\". For detailed information view the <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles\">\n\t\t * whatwg spec</a>. Default is \"top\".\n\t\t * @property textBaseline\n\t\t * @type String\n\t\t*/\n\t\tthis.textBaseline = \"top\";\n\t\n\t\t/**\n\t\t * The maximum width to draw the text. If maxWidth is specified (not null), the text will be condensed or\n\t\t * shrunk to make it fit in this width. For detailed information view the\n\t\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles\">\n\t\t * whatwg spec</a>.\n\t\t * @property maxWidth\n\t\t * @type Number\n\t\t*/\n\t\tthis.maxWidth = null;\n\t\n\t\t/**\n\t\t * If greater than 0, the text will be drawn as a stroke (outline) of the specified width.\n\t\t * @property outline\n\t\t * @type Number\n\t\t **/\n\t\tthis.outline = 0;\n\t\n\t\t/**\n\t\t * Indicates the line height (vertical distance between baselines) for multi-line text. If null or 0,\n\t\t * the value of getMeasuredLineHeight is used.\n\t\t * @property lineHeight\n\t\t * @type Number\n\t\t **/\n\t\tthis.lineHeight = 0;\n\t\n\t\t/**\n\t\t * Indicates the maximum width for a line of text before it is wrapped to multiple lines. If null,\n\t\t * the text will not be wrapped.\n\t\t * @property lineWidth\n\t\t * @type Number\n\t\t **/\n\t\tthis.lineWidth = null;\n\t}\n\tvar p = createjs.extend(Text, createjs.DisplayObject);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\t\n// static properties:\n\t/**\n\t * @property _workingContext\n\t * @type CanvasRenderingContext2D\n\t * @private\n\t **/\n\tvar canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement(\"canvas\"));\n\tif (canvas.getContext) { Text._workingContext = canvas.getContext(\"2d\"); canvas.width = canvas.height = 1; }\n\t\n\t\n// constants:\n\t/**\n\t * Lookup table for the ratio to offset bounds x calculations based on the textAlign property.\n\t * @property H_OFFSETS\n\t * @type Object\n\t * @protected\n\t * @static\n\t **/\n\tText.H_OFFSETS = {start: 0, left: 0, center: -0.5, end: -1, right: -1};\n\t\n\t/**\n\t * Lookup table for the ratio to offset bounds y calculations based on the textBaseline property.\n\t * @property H_OFFSETS\n\t * @type Object\n\t * @protected\n\t * @static\n\t **/\n\tText.V_OFFSETS = {top: 0, hanging: -0.01, middle: -0.4, alphabetic: -0.8, ideographic: -0.85, bottom: -1};\n\n\n// public methods:\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar hasContent = this.cacheCanvas || (this.text != null && this.text !== \"\");\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t};\n\n\t/**\n\t * Draws the Text into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\n\t\tvar col = this.color || \"#000\";\n\t\tif (this.outline) { ctx.strokeStyle = col; ctx.lineWidth = this.outline*1; }\n\t\telse { ctx.fillStyle = col; }\n\t\t\n\t\tthis._drawText(this._prepContext(ctx));\n\t\treturn true;\n\t};\n\n\t/**\n\t * Returns the measured, untransformed width of the text without wrapping. Use getBounds for a more robust value.\n\t * @method getMeasuredWidth\n\t * @return {Number} The measured, untransformed width of the text.\n\t **/\n\tp.getMeasuredWidth = function() {\n\t\treturn this._getMeasuredWidth(this.text);\n\t};\n\n\t/**\n\t * Returns an approximate line height of the text, ignoring the lineHeight property. This is based on the measured\n\t * width of a \"M\" character multiplied by 1.2, which provides an approximate line height for most fonts.\n\t * @method getMeasuredLineHeight\n\t * @return {Number} an approximate line height of the text, ignoring the lineHeight property. This is\n\t * based on the measured width of a \"M\" character multiplied by 1.2, which approximates em for most fonts.\n\t **/\n\tp.getMeasuredLineHeight = function() {\n\t\treturn this._getMeasuredWidth(\"M\")*1.2;\n\t};\n\n\t/**\n\t * Returns the approximate height of multi-line text by multiplying the number of lines against either the\n\t * <code>lineHeight</code> (if specified) or {{#crossLink \"Text/getMeasuredLineHeight\"}}{{/crossLink}}. Note that\n\t * this operation requires the text flowing logic to run, which has an associated CPU cost.\n\t * @method getMeasuredHeight\n\t * @return {Number} The approximate height of the untransformed multi-line text.\n\t **/\n\tp.getMeasuredHeight = function() {\n\t\treturn this._drawText(null,{}).height;\n\t};\n\n\t/**\n\t * Docced in superclass.\n\t */\n\tp.getBounds = function() {\n\t\tvar rect = this.DisplayObject_getBounds();\n\t\tif (rect) { return rect; }\n\t\tif (this.text == null || this.text === \"\") { return null; }\n\t\tvar o = this._drawText(null, {});\n\t\tvar w = (this.maxWidth && this.maxWidth < o.width) ? this.maxWidth : o.width;\n\t\tvar x = w * Text.H_OFFSETS[this.textAlign||\"left\"];\n\t\tvar lineHeight = this.lineHeight||this.getMeasuredLineHeight();\n\t\tvar y = lineHeight * Text.V_OFFSETS[this.textBaseline||\"top\"];\n\t\treturn this._rectangle.setValues(x, y, w, o.height);\n\t};\n\t\n\t/**\n\t * Returns an object with width, height, and lines properties. The width and height are the visual width and height\n\t * of the drawn text. The lines property contains an array of strings, one for\n\t * each line of text that will be drawn, accounting for line breaks and wrapping. These strings have trailing\n\t * whitespace removed.\n\t * @method getMetrics\n\t * @return {Object} An object with width, height, and lines properties.\n\t **/\n\tp.getMetrics = function() {\n\t\tvar o = {lines:[]};\n\t\to.lineHeight = this.lineHeight || this.getMeasuredLineHeight();\n\t\to.vOffset = o.lineHeight * Text.V_OFFSETS[this.textBaseline||\"top\"];\n\t\treturn this._drawText(null, o, o.lines);\n\t};\n\n\t/**\n\t * Returns a clone of the Text instance.\n\t * @method clone\n\t * @return {Text} a clone of the Text instance.\n\t **/\n\tp.clone = function() {\n\t\treturn this._cloneProps(new Text(this.text, this.font, this.color));\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Text (text=\"+  (this.text.length > 20 ? this.text.substr(0, 17)+\"...\" : this.text) +\")]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _cloneProps\n\t * @param {Text} o\n\t * @protected\n\t * @return {Text} o\n\t **/\n\tp._cloneProps = function(o) {\n\t\tthis.DisplayObject__cloneProps(o);\n\t\to.textAlign = this.textAlign;\n\t\to.textBaseline = this.textBaseline;\n\t\to.maxWidth = this.maxWidth;\n\t\to.outline = this.outline;\n\t\to.lineHeight = this.lineHeight;\n\t\to.lineWidth = this.lineWidth;\n\t\treturn o;\n\t};\n\n\t/**\n\t * @method _getWorkingContext\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @return {CanvasRenderingContext2D}\n\t * @protected\n\t **/\n\tp._prepContext = function(ctx) {\n\t\tctx.font = this.font||\"10px sans-serif\";\n\t\tctx.textAlign = this.textAlign||\"left\";\n\t\tctx.textBaseline = this.textBaseline||\"top\";\n\t\treturn ctx;\n\t};\n\n\t/**\n\t * Draws multiline text.\n\t * @method _drawText\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {Object} o\n\t * @param {Array} lines\n\t * @return {Object}\n\t * @protected\n\t **/\n\tp._drawText = function(ctx, o, lines) {\n\t\tvar paint = !!ctx;\n\t\tif (!paint) {\n\t\t\tctx = Text._workingContext;\n\t\t\tctx.save();\n\t\t\tthis._prepContext(ctx);\n\t\t}\n\t\tvar lineHeight = this.lineHeight||this.getMeasuredLineHeight();\n\t\t\n\t\tvar maxW = 0, count = 0;\n\t\tvar hardLines = String(this.text).split(/(?:\\r\\n|\\r|\\n)/);\n\t\tfor (var i=0, l=hardLines.length; i<l; i++) {\n\t\t\tvar str = hardLines[i];\n\t\t\tvar w = null;\n\t\t\t\n\t\t\tif (this.lineWidth != null && (w = ctx.measureText(str).width) > this.lineWidth) {\n\t\t\t\t// text wrapping:\n\t\t\t\tvar words = str.split(/(\\s)/);\n\t\t\t\tstr = words[0];\n\t\t\t\tw = ctx.measureText(str).width;\n\t\t\t\t\n\t\t\t\tfor (var j=1, jl=words.length; j<jl; j+=2) {\n\t\t\t\t\t// Line needs to wrap:\n\t\t\t\t\tvar wordW = ctx.measureText(words[j] + words[j+1]).width;\n\t\t\t\t\tif (w + wordW > this.lineWidth) {\n\t\t\t\t\t\tif (paint) { this._drawTextLine(ctx, str, count*lineHeight); }\n\t\t\t\t\t\tif (lines) { lines.push(str); }\n\t\t\t\t\t\tif (w > maxW) { maxW = w; }\n\t\t\t\t\t\tstr = words[j+1];\n\t\t\t\t\t\tw = ctx.measureText(str).width;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr += words[j] + words[j+1];\n\t\t\t\t\t\tw += wordW;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (paint) { this._drawTextLine(ctx, str, count*lineHeight); }\n\t\t\tif (lines) { lines.push(str); }\n\t\t\tif (o && w == null) { w = ctx.measureText(str).width; }\n\t\t\tif (w > maxW) { maxW = w; }\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\tif (o) {\n\t\t\to.width = maxW;\n\t\t\to.height = count*lineHeight;\n\t\t}\n\t\tif (!paint) { ctx.restore(); }\n\t\treturn o;\n\t};\n\n\t/**\n\t * @method _drawTextLine\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {String} text\n\t * @param {Number} y\n\t * @protected\n\t **/\n\tp._drawTextLine = function(ctx, text, y) {\n\t\t// Chrome 17 will fail to draw the text if the last param is included but null, so we feed it a large value instead:\n\t\tif (this.outline) { ctx.strokeText(text, 0, y, this.maxWidth||0xFFFF); }\n\t\telse { ctx.fillText(text, 0, y, this.maxWidth||0xFFFF); }\n\t};\n\t\n\t\n\t/**\n\t * @method _getMeasuredWidth\n\t * @param {String} text\n\t * @protected\n\t **/\n\tp._getMeasuredWidth = function(text) {\n\t\tvar ctx = Text._workingContext;\n\t\tctx.save();\n\t\tvar w = this._prepContext(ctx).measureText(text).width;\n\t\tctx.restore();\n\t\treturn w;\n\t};\n\n\n\tcreatejs.Text = createjs.promote(Text, \"DisplayObject\");\n}());\n\n//##############################################################################\n// BitmapText.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Displays text using bitmap glyphs defined in a sprite sheet. Multi-line text is supported\n\t * using new line characters, but automatic wrapping is not supported. See the \n\t * {{#crossLink \"BitmapText/spriteSheet:property\"}}{{/crossLink}}\n\t * property for more information on defining glyphs.\n\t * \n\t * <strong>Important:</strong> BitmapText extends Container, but is not designed to be used as one.\n\t * As such, methods like addChild and removeChild are disabled.\n\t * @class BitmapText\n\t * @extends DisplayObject\n\t * @param {String} [text=\"\"] The text to display.\n\t * @param {SpriteSheet} [spriteSheet=null] The spritesheet that defines the character glyphs.\n\t * @constructor\n\t **/\n\tfunction BitmapText(text, spriteSheet) {\n\t\tthis.Container_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The text to display.\n\t\t * @property text\n\t\t * @type String\n\t\t * @default \"\"\n\t\t **/\n\t\tthis.text = text||\"\";\n\t\t\n\t\t/**\n\t\t * A SpriteSheet instance that defines the glyphs for this bitmap text. Each glyph/character\n\t\t * should have a single frame animation defined in the sprite sheet named the same as\n\t\t * corresponding character. For example, the following animation definition:\n\t\t *\n\t\t * \t\t\"A\": {frames: [0]}\n\t\t *\n\t\t * would indicate that the frame at index 0 of the spritesheet should be drawn for the \"A\" character. The short form\n\t\t * is also acceptable:\n\t\t * \n\t\t * \t\t\"A\": 0\n\t\t *\n\t\t * Note that if a character in the text is not found in the sprite sheet, it will also\n\t\t * try to use the alternate case (upper or lower).\n\t\t *\n\t\t * See SpriteSheet for more information on defining sprite sheet data.\n\t\t * @property spriteSheet\n\t\t * @type SpriteSheet\n\t\t * @default null\n\t\t **/\n\t\tthis.spriteSheet = spriteSheet;\n\t\n\t\t/**\n\t\t * The height of each line of text. If 0, then it will use a line height calculated\n\t\t * by checking for the height of the \"1\", \"T\", or \"L\" character (in that order). If\n\t\t * those characters are not defined, it will use the height of the first frame of the\n\t\t * sprite sheet.\n\t\t * @property lineHeight\n\t\t * @type Number\n\t\t * @default 0\n\t\t **/\n\t\tthis.lineHeight = 0;\n\t\n\t\t/**\n\t\t * This spacing (in pixels) will be added after each character in the output.\n\t\t * @property letterSpacing\n\t\t * @type Number\n\t\t * @default 0\n\t\t **/\n\t\tthis.letterSpacing = 0;\n\t\n\t\t/**\n\t\t * If a space character is not defined in the sprite sheet, then empty pixels equal to\n\t\t * spaceWidth will be inserted instead. If 0, then it will use a value calculated\n\t\t * by checking for the width of the \"1\", \"l\", \"E\", or \"A\" character (in that order). If\n\t\t * those characters are not defined, it will use the width of the first frame of the\n\t\t * sprite sheet.\n\t\t * @property spaceWidth\n\t\t * @type Number\n\t\t * @default 0\n\t\t **/\n\t\tthis.spaceWidth = 0;\n\t\t\n\t\t\n\t// private properties:\n\t \t/**\n\t\t * @property _oldProps\n\t\t * @type Object\n\t\t * @protected\n\t\t **/\n\t\tthis._oldProps = {text:0,spriteSheet:0,lineHeight:0,letterSpacing:0,spaceWidth:0};\n\t}\n\tvar p = createjs.extend(BitmapText, createjs.Container);\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n// static properties:\n\t/**\n\t * BitmapText uses Sprite instances to draw text. To reduce the creation and destruction of instances (and thus garbage collection), it maintains\n\t * an internal object pool of sprite instances to reuse. Increasing this value can cause more sprites to be\n\t * retained, slightly increasing memory use, but reducing instantiation.\n\t * @property maxPoolSize\n\t * @type Number\n\t * @static\n\t * @default 100\n\t **/\n\tBitmapText.maxPoolSize = 100;\n\t\n\t/**\n\t * Sprite object pool.\n\t * @type {Array}\n\t * @static\n\t * @private\n\t */\n\tBitmapText._spritePool = [];\n\n\t\n// public methods:\n\t/**\n\t * Docced in superclass.\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return; }\n\t\tthis._updateText();\n\t\tthis.Container_draw(ctx, ignoreCache);\n\t};\n\t\n\t/**\n\t * Docced in superclass.\n\t **/\n\tp.getBounds = function() {\n\t\tthis._updateText();\n\t\treturn this.Container_getBounds();\n\t};\n\t\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar hasContent = this.cacheCanvas || (this.spriteSheet && this.spriteSheet.complete && this.text);\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX !== 0 && this.scaleY !== 0 && hasContent);\n\t};\n\t\n\tp.clone = function() {\n\t\treturn this._cloneProps(new BitmapText(this.text, this.spriteSheet));\n\t};\n\t\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t * @method addChild\n\t **/\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t * @method addChildAt\n\t **/\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t * @method removeChild\n\t **/\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t * @method removeChildAt\n\t **/\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t * @method removeAllChildren\n\t **/\n\tp.addChild = p.addChildAt = p.removeChild = p.removeChildAt = p.removeAllChildren = function() {};\n\n\n// private methods:\n \t/**\n\t * @method _cloneProps\n\t * @param {BitmapText} o\n\t * @return {BitmapText} o\n\t * @protected\n\t **/\n\tp._cloneProps = function(o) {\n\t\tthis.Container__cloneProps(o);\n\t\to.lineHeight = this.lineHeight;\n\t\to.letterSpacing = this.letterSpacing;\n\t\to.spaceWidth = this.spaceWidth;\n\t\treturn o;\n\t};\n\t\n\t/**\n\t * @method _getFrameIndex\n\t * @param {String} character\n\t * @param {SpriteSheet} spriteSheet\n\t * @return {Number}\n\t * @protected\n\t **/\n\tp._getFrameIndex = function(character, spriteSheet) {\n\t\tvar c, o = spriteSheet.getAnimation(character);\n\t\tif (!o) {\n\t\t\t(character != (c = character.toUpperCase())) || (character != (c = character.toLowerCase())) || (c=null);\n\t\t\tif (c) { o = spriteSheet.getAnimation(c); }\n\t\t}\n\t\treturn o && o.frames[0];\n\t};\n\t\n\t/**\n\t * @method _getFrame\n\t * @param {String} character\n\t * @param {SpriteSheet} spriteSheet\n\t * @return {Object}\n\t * @protected\n\t **/\n\tp._getFrame = function(character, spriteSheet) {\n\t\tvar index = this._getFrameIndex(character, spriteSheet);\n\t\treturn index == null ? index : spriteSheet.getFrame(index);\n\t};\n\t\n\t/**\n\t * @method _getLineHeight\n\t * @param {SpriteSheet} ss\n\t * @return {Number}\n\t * @protected\n\t **/\n\tp._getLineHeight = function(ss) {\n\t\tvar frame = this._getFrame(\"1\",ss) || this._getFrame(\"T\",ss) || this._getFrame(\"L\",ss) || ss.getFrame(0);\n\t\treturn frame ? frame.rect.height : 1;\n\t};\n\t/**\n\t * @method _getSpaceWidth\n\t * @param {SpriteSheet} ss\n\t * @return {Number}\n\t * @protected\n\t **/\n\tp._getSpaceWidth = function(ss) {\n\t\tvar frame = this._getFrame(\"1\",ss) || this._getFrame(\"l\",ss) || this._getFrame(\"e\",ss) || this._getFrame(\"a\",ss) || ss.getFrame(0);\n\t\treturn frame ? frame.rect.width : 1;\n\t};\n\t\n\t/**\n\t * @method _drawText\n\t * @protected\n\t **/\n\tp._updateText = function() {\n\t\tvar x=0, y=0, o=this._oldProps, change=false, spaceW=this.spaceWidth, lineH=this.lineHeight, ss=this.spriteSheet;\n\t\tvar pool=BitmapText._spritePool, kids=this.children, childIndex=0, numKids=kids.length, sprite;\n\t\t\n\t\tfor (var n in o) {\n\t\t\tif (o[n] != this[n]) {\n\t\t\t\to[n] = this[n];\n\t\t\t\tchange = true;\n\t\t\t}\n\t\t}\n\t\tif (!change) { return; }\n\t\t\n\t\tvar hasSpace = !!this._getFrame(\" \", ss);\n\t\tif (!hasSpace && !spaceW) { spaceW = this._getSpaceWidth(ss); }\n\t\tif (!lineH) { lineH = this._getLineHeight(ss); }\n\t\t\n\t\tfor(var i=0, l=this.text.length; i<l; i++) {\n\t\t\tvar character = this.text.charAt(i);\n\t\t\tif (character == \" \" && !hasSpace) {\n\t\t\t\tx += spaceW;\n\t\t\t\tcontinue;\n\t\t\t} else if (character==\"\\n\" || character==\"\\r\") {\n\t\t\t\tif (character==\"\\r\" && this.text.charAt(i+1) == \"\\n\") { i++; } // crlf\n\t\t\t\tx = 0;\n\t\t\t\ty += lineH;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar index = this._getFrameIndex(character, ss);\n\t\t\tif (index == null) { continue; }\n\t\t\t\n\t\t\tif (childIndex < numKids) {\n\t\t\t\tsprite = kids[childIndex];\n\t\t\t} else {\n\t\t\t\tkids.push(sprite = pool.length ? pool.pop() : new createjs.Sprite());\n\t\t\t\tsprite.parent = this;\n\t\t\t\tnumKids++;\n\t\t\t}\n\t\t\tsprite.spriteSheet = ss;\n\t\t\tsprite.gotoAndStop(index);\n\t\t\tsprite.x = x;\n\t\t\tsprite.y = y;\n\t\t\tchildIndex++;\n\t\t\t\n\t\t\tx += sprite.getBounds().width + this.letterSpacing;\n\t\t}\n\t\twhile (numKids > childIndex) {\n\t\t\t // faster than removeChild.\n\t\t\tpool.push(sprite = kids.pop());\n\t\t\tsprite.parent = null;\n\t\t\tnumKids--;\n\t\t}\n\t\tif (pool.length > BitmapText.maxPoolSize) { pool.length = BitmapText.maxPoolSize; }\n\t};\n\n\n\tcreatejs.BitmapText = createjs.promote(BitmapText, \"Container\");\n}());\n\n//##############################################################################\n// MovieClip.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * The MovieClip class associates a TweenJS Timeline with an EaselJS {{#crossLink \"Container\"}}{{/crossLink}}. It allows\n\t * you to create objects which encapsulate timeline animations, state changes, and synched actions. Due to the\n\t * complexities inherent in correctly setting up a MovieClip, it is largely intended for tool output and is not included\n\t * in the main EaselJS library.\n\t *\n\t * Currently MovieClip only works properly if it is tick based (as opposed to time based) though some concessions have\n\t * been made to support time-based timelines in the future.\n\t *\n\t * <h4>Example</h4>\n\t * This example animates two shapes back and forth. The grey shape starts on the left, but we jump to a mid-point in\n\t * the animation using {{#crossLink \"MovieClip/gotoAndPlay\"}}{{/crossLink}}.\n\t *\n\t *      var stage = new createjs.Stage(\"canvas\");\n\t *      createjs.Ticker.addEventListener(\"tick\", stage);\n\t *\n\t *      var mc = new createjs.MovieClip(null, 0, true, {start:20});\n\t *      stage.addChild(mc);\n\t *\n\t *      var child1 = new createjs.Shape(\n\t *          new createjs.Graphics().beginFill(\"#999999\")\n\t *              .drawCircle(30,30,30));\n\t *      var child2 = new createjs.Shape(\n\t *          new createjs.Graphics().beginFill(\"#5a9cfb\")\n\t *              .drawCircle(30,30,30));\n\t *\n\t *      mc.timeline.addTween(\n\t *          createjs.Tween.get(child1)\n\t *              .to({x:0}).to({x:60}, 50).to({x:0}, 50));\n\t *      mc.timeline.addTween(\n\t *          createjs.Tween.get(child2)\n\t *              .to({x:60}).to({x:0}, 50).to({x:60}, 50));\n\t *\n\t *      mc.gotoAndPlay(\"start\");\n\t *\n\t * It is recommended to use <code>tween.to()</code> to animate and set properties (use no duration to have it set\n\t * immediately), and the <code>tween.wait()</code> method to create delays between animations. Note that using the\n\t * <code>tween.set()</code> method to affect properties will likely not provide the desired result.\n\t *\n\t * @class MovieClip\n\t * @main MovieClip\n\t * @extends Container\n\t * @constructor\n\t * @param {String} [mode=independent] Initial value for the mode property. One of {{#crossLink \"MovieClip/INDEPENDENT:property\"}}{{/crossLink}},\n\t * {{#crossLink \"MovieClip/SINGLE_FRAME:property\"}}{{/crossLink}}, or {{#crossLink \"MovieClip/SYNCHED:property\"}}{{/crossLink}}.\n\t * The default is {{#crossLink \"MovieClip/INDEPENDENT:property\"}}{{/crossLink}}.\n\t * @param {Number} [startPosition=0] Initial value for the {{#crossLink \"MovieClip/startPosition:property\"}}{{/crossLink}}\n\t * property.\n\t * @param {Boolean} [loop=true] Initial value for the {{#crossLink \"MovieClip/loop:property\"}}{{/crossLink}}\n\t * property. The default is `true`.\n\t * @param {Object} [labels=null] A hash of labels to pass to the {{#crossLink \"MovieClip/timeline:property\"}}{{/crossLink}}\n\t * instance associated with this MovieClip. Labels only need to be passed if they need to be used.\n\t **/\n\tfunction MovieClip(mode, startPosition, loop, labels) {\n\t\tthis.Container_constructor();\n\t\t!MovieClip.inited&&MovieClip.init(); // static init\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * Controls how this MovieClip advances its time. Must be one of 0 (INDEPENDENT), 1 (SINGLE_FRAME), or 2 (SYNCHED).\n\t\t * See each constant for a description of the behaviour.\n\t\t * @property mode\n\t\t * @type String\n\t\t * @default null\n\t\t **/\n\t\tthis.mode = mode||MovieClip.INDEPENDENT;\n\t\n\t\t/**\n\t\t * Specifies what the first frame to play in this movieclip, or the only frame to display if mode is SINGLE_FRAME.\n\t\t * @property startPosition\n\t\t * @type Number\n\t\t * @default 0\n\t\t */\n\t\tthis.startPosition = startPosition || 0;\n\t\n\t\t/**\n\t\t * Indicates whether this MovieClip should loop when it reaches the end of its timeline.\n\t\t * @property loop\n\t\t * @type Boolean\n\t\t * @default true\n\t\t */\n\t\tthis.loop = loop;\n\t\n\t\t/**\n\t\t * The current frame of the movieclip.\n\t\t * @property currentFrame\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @readonly\n\t\t */\n\t\tthis.currentFrame = 0;\n\t\n\t\t/**\n\t\t * The TweenJS Timeline that is associated with this MovieClip. This is created automatically when the MovieClip\n\t\t * instance is initialized. Animations are created by adding <a href=\"http://tweenjs.com\">TweenJS</a> Tween\n\t\t * instances to the timeline.\n\t\t *\n\t\t * <h4>Example</h4>\n\t\t *\n\t\t *      var tween = createjs.Tween.get(target).to({x:0}).to({x:100}, 30);\n\t\t *      var mc = new createjs.MovieClip();\n\t\t *      mc.timeline.addTween(tween);\n\t\t *\n\t\t * Elements can be added and removed from the timeline by toggling an \"_off\" property\n\t\t * using the <code>tweenInstance.to()</code> method. Note that using <code>Tween.set</code> is not recommended to\n\t\t * create MovieClip animations. The following example will toggle the target off on frame 0, and then back on for\n\t\t * frame 1. You can use the \"visible\" property to achieve the same effect.\n\t\t *\n\t\t *      var tween = createjs.Tween.get(target).to({_off:false})\n\t\t *          .wait(1).to({_off:true})\n\t\t *          .wait(1).to({_off:false});\n\t\t *\n\t\t * @property timeline\n\t\t * @type Timeline\n\t\t * @default null\n\t\t */\n\t\tthis.timeline = new createjs.Timeline(null, labels, {paused:true, position:startPosition, useTicks:true});\n\t\n\t\t/**\n\t\t * If true, the MovieClip's position will not advance when ticked.\n\t\t * @property paused\n\t\t * @type Boolean\n\t\t * @default false\n\t\t */\n\t\tthis.paused = false;\n\t\n\t\t/**\n\t\t * If true, actions in this MovieClip's tweens will be run when the playhead advances.\n\t\t * @property actionsEnabled\n\t\t * @type Boolean\n\t\t * @default true\n\t\t */\n\t\tthis.actionsEnabled = true;\n\t\n\t\t/**\n\t\t * If true, the MovieClip will automatically be reset to its first frame whenever the timeline adds\n\t\t * it back onto the display list. This only applies to MovieClip instances with mode=INDEPENDENT.\n\t\t * <br><br>\n\t\t * For example, if you had a character animation with a \"body\" child MovieClip instance\n\t\t * with different costumes on each frame, you could set body.autoReset = false, so that\n\t\t * you can manually change the frame it is on, without worrying that it will be reset\n\t\t * automatically.\n\t\t * @property autoReset\n\t\t * @type Boolean\n\t\t * @default true\n\t\t */\n\t\tthis.autoReset = true;\n\t\t\n\t\t/**\n\t\t * An array of bounds for each frame in the MovieClip. This is mainly intended for tool output.\n\t\t * @property frameBounds\n\t\t * @type Array\n\t\t * @default null\n\t\t */\n\t\tthis.frameBounds = this.frameBounds||null; // TODO: Deprecated. This is for backwards support of FlashCC\n\t\t\n\t\t/**\n\t\t * By default MovieClip instances advance one frame per tick. Specifying a framerate for the MovieClip\n\t\t * will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\n\t\t * framerate.\n\t\t *\n\t\t * For example, if a MovieClip with a framerate of 10 is placed on a Stage being updated at 40fps, then the MovieClip will\n\t\t * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will\n\t\t * vary slightly between frames.\n\t\t *\n\t\t * This feature is dependent on the tick event object (or an object with an appropriate \"delta\" property) being\n\t\t * passed into {{#crossLink \"Stage/update\"}}{{/crossLink}}.\n\t\t * @property framerate\n\t\t * @type {Number}\n\t\t * @default null\n\t\t **/\n\t\tthis.framerate = null;\n\t\t\n\t\t\n\t// private properties:\n\t\t/**\n\t\t * @property _synchOffset\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @private\n\t\t */\n\t\tthis._synchOffset = 0;\n\t\n\t\t/**\n\t\t * @property _prevPos\n\t\t * @type Number\n\t\t * @default -1\n\t\t * @private\n\t\t */\n\t\tthis._prevPos = -1; // TODO: evaluate using a ._reset Boolean prop instead of -1.\n\t\n\t\t/**\n\t\t * @property _prevPosition\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @private\n\t\t */\n\t\tthis._prevPosition = 0;\n\t\n\t\t/**\n\t\t * The time remaining from the previous tick, only applicable when .framerate is set.\n\t\t * @property _t\n\t\t * @type Number\n\t\t * @private\n\t\t */\n\t\tthis._t = 0;\n\t\n\t\t/**\n\t\t * List of display objects that are actively being managed by the MovieClip.\n\t\t * @property _managed\n\t\t * @type Object\n\t\t * @private\n\t\t */\n\t\tthis._managed = {};\n\t}\n\tvar p = createjs.extend(MovieClip, createjs.Container);\n\n\n// constants:\n\t/**\n\t * The MovieClip will advance independently of its parent, even if its parent is paused.\n\t * This is the default mode.\n\t * @property INDEPENDENT\n\t * @static\n\t * @type String\n\t * @default \"independent\"\n\t * @readonly\n\t **/\n\tMovieClip.INDEPENDENT = \"independent\";\n\n\t/**\n\t * The MovieClip will only display a single frame (as determined by the startPosition property).\n\t * @property SINGLE_FRAME\n\t * @static\n\t * @type String\n\t * @default \"single\"\n\t * @readonly\n\t **/\n\tMovieClip.SINGLE_FRAME = \"single\";\n\n\t/**\n\t * The MovieClip will be advanced only when its parent advances and will be synched to the position of\n\t * the parent MovieClip.\n\t * @property SYNCHED\n\t * @static\n\t * @type String\n\t * @default \"synched\"\n\t * @readonly\n\t **/\n\tMovieClip.SYNCHED = \"synched\";\n\t\n\t\n// static properties:\n\tMovieClip.inited = false;\n\t\n\t\n// static methods:\n\tMovieClip.init = function() {\n\t\tif (MovieClip.inited) { return; }\n\t\t// plugins introduce some overhead to Tween, so we only install this if an MC is instantiated.\n\t\tMovieClipPlugin.install();\n\t\tMovieClip.inited = true;\n\t};\n\t\n\t\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink \"MovieClip/labels:property\"}}{{/crossLink}} property instead.\n\t * @method getLabels\n\t * @return {Array}\n\t * @deprecated\n\t **/\n\tp.getLabels = function() {\n\t\treturn this.timeline.getLabels();\n\t};\n\t\n\t/**\n\t * Use the {{#crossLink \"MovieClip/currentLabel:property\"}}{{/crossLink}} property instead.\n\t * @method getCurrentLabel\n\t * @return {String}\n\t * @deprecated\n\t **/\n\tp.getCurrentLabel = function() {\n\t\tthis._updateTimeline();\n\t\treturn this.timeline.getCurrentLabel();\n\t};\n\t\n\t/**\n\t * Use the {{#crossLink \"MovieClip/duration:property\"}}{{/crossLink}} property instead.\n\t * @method getDuration\n\t * @return {Number}\n\t * @protected\n\t **/\n\tp.getDuration = function() {\n\t\treturn this.timeline.duration;\n\t};\n\n\t/**\n\t * Returns an array of objects with label and position (aka frame) properties, sorted by position.\n\t * Shortcut to TweenJS: Timeline.getLabels();\n\t * @property labels\n\t * @type {Array}\n\t * @readonly\n\t **/\n\t\n\t/**\n\t * Returns the name of the label on or immediately before the current frame. See TweenJS: Timeline.getCurrentLabel()\n\t * for more information.\n\t * @property currentLabel\n\t * @type {String}\n\t * @readonly\n\t **/\n\t\n\t/**\n\t * Returns the duration of this MovieClip in seconds or ticks. Identical to {{#crossLink \"MovieClip/duration:property\"}}{{/crossLink}}\n\t * and provided for Flash API compatibility.\n\t * @property totalFrames\n\t * @type {Number}\n\t * @readonly\n\t **/\n\t\n\t/**\n\t * Returns the duration of this MovieClip in seconds or ticks.\n\t * @property duration\n\t * @type {Number}\n\t * @readonly\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tlabels: { get: p.getLabels },\n\t\t\tcurrentLabel: { get: p.getCurrentLabel },\n\t\t\ttotalFrames: { get: p.getDuration },\n\t\t\tduration: { get: p.getDuration }\n\t\t});\n\t} catch (e) {}\n\n\n// public methods:\n\t/**\n\t * Constructor alias for backwards compatibility. This method will be removed in future versions.\n\t * Subclasses should be updated to use {{#crossLink \"Utility Methods/extends\"}}{{/crossLink}}.\n\t * @method initialize\n\t * @deprecated in favour of `createjs.promote()`\n\t **/\n\tp.initialize = MovieClip; // TODO: Deprecated. This is for backwards support of FlashCC\n\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\t// children are placed in draw, so we can't determine if we have content.\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\t// draw to cache first:\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\t\tthis._updateTimeline();\n\t\tthis.Container_draw(ctx, ignoreCache);\n\t\treturn true;\n\t};\n\t\n\t/**\n\t * Sets paused to false.\n\t * @method play\n\t **/\n\tp.play = function() {\n\t\tthis.paused = false;\n\t};\n\t\n\t/**\n\t * Sets paused to true.\n\t * @method stop\n\t **/\n\tp.stop = function() {\n\t\tthis.paused = true;\n\t};\n\t\n\t/**\n\t * Advances this movie clip to the specified position or label and sets paused to false.\n\t * @method gotoAndPlay\n\t * @param {String|Number} positionOrLabel The animation name or frame number to go to.\n\t **/\n\tp.gotoAndPlay = function(positionOrLabel) {\n\t\tthis.paused = false;\n\t\tthis._goto(positionOrLabel);\n\t};\n\t\n\t/**\n\t * Advances this movie clip to the specified position or label and sets paused to true.\n\t * @method gotoAndStop\n\t * @param {String|Number} positionOrLabel The animation or frame name to go to.\n\t **/\n\tp.gotoAndStop = function(positionOrLabel) {\n\t\tthis.paused = true;\n\t\tthis._goto(positionOrLabel);\n\t};\n\t\n\t/**\n\t * Advances the playhead. This occurs automatically each tick by default.\n\t * @param [time] {Number} The amount of time in ms to advance by. Only applicable if framerate is set.\n\t * @method advance\n\t*/\n\tp.advance = function(time) {\n\t\t// TODO: should we worry at all about clips who change their own modes via frame scripts?\n\t\tvar independent = MovieClip.INDEPENDENT;\n\t\tif (this.mode != independent) { return; }\n\t\t\n\t\tvar o=this, fps = o.framerate;\n\t\twhile ((o = o.parent) && fps == null) {\n\t\t\tif (o.mode == independent) { fps = o._framerate; }\n\t\t}\n\t\tthis._framerate = fps;\n\t\t\n\t\tvar t = (fps != null && fps != -1 && time != null) ? time/(1000/fps) + this._t : 1;\n\t\tvar frames = t|0;\n\t\tthis._t = t-frames; // leftover time\n\t\t\n\t\twhile (!this.paused && frames--) {\n\t\t\tthis._prevPosition = (this._prevPos < 0) ? 0 : this._prevPosition+1;\n\t\t\tthis._updateTimeline();\n\t\t}\n\t};\n\t\n\t/**\n\t * MovieClip instances cannot be cloned.\n\t * @method clone\n\t **/\n\tp.clone = function() {\n\t\t// TODO: add support for this? Need to clone the Timeline & retarget tweens - pretty complex.\n\t\tthrow(\"MovieClip cannot be cloned.\")\n\t};\n\t\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[MovieClip (name=\"+  this.name +\")]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _tick\n\t * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.\n\t * function.\n\t * @protected\n\t **/\n\tp._tick = function(evtObj) {\n\t\tthis.advance(evtObj&&evtObj.delta);\n\t\tthis.Container__tick(evtObj);\n\t};\n\t\n\t/**\n\t * @method _goto\n\t * @param {String|Number} positionOrLabel The animation name or frame number to go to.\n\t * @protected\n\t **/\n\tp._goto = function(positionOrLabel) {\n\t\tvar pos = this.timeline.resolve(positionOrLabel);\n\t\tif (pos == null) { return; }\n\t\t// prevent _updateTimeline from overwriting the new position because of a reset:\n\t\tif (this._prevPos == -1) { this._prevPos = NaN; }\n\t\tthis._prevPosition = pos;\n\t\tthis._t = 0;\n\t\tthis._updateTimeline();\n\t};\n\t\n\t/**\n\t * @method _reset\n\t * @private\n\t **/\n\tp._reset = function() {\n\t\tthis._prevPos = -1;\n\t\tthis._t = this.currentFrame = 0;\n\t\tthis.paused = false;\n\t};\n\t\n\t/**\n\t * @method _updateTimeline\n\t * @protected\n\t **/\n\tp._updateTimeline = function() {\n\t\tvar tl = this.timeline;\n\t\tvar synched = this.mode != MovieClip.INDEPENDENT;\n\t\ttl.loop = (this.loop==null) ? true : this.loop;\n\t\t\n\t\tvar pos = synched ? this.startPosition + (this.mode==MovieClip.SINGLE_FRAME?0:this._synchOffset) : (this._prevPos < 0 ? 0 : this._prevPosition);\n\t\tvar mode = synched || !this.actionsEnabled ? createjs.Tween.NONE : null;\n\t\t\n\t\t// pre-assign currentFrame so it is available to frame scripts:\n\t\tthis.currentFrame = tl._calcPosition(pos);\n\t\t\n\t\t// update timeline position, ignoring actions if this is a graphic.\n\t\ttl.setPosition(pos, mode);\n\n\t\tthis._prevPosition = tl._prevPosition;\n\t\tif (this._prevPos == tl._prevPos) { return; }\n\t\tthis.currentFrame = this._prevPos = tl._prevPos;\n\n\t\tfor (var n in this._managed) { this._managed[n] = 1; }\n\n\t\tvar tweens = tl._tweens;\n\t\tfor (var i=0, l=tweens.length; i<l; i++) {\n\t\t\tvar tween = tweens[i];\n\t\t\tvar target = tween._target;\n\t\t\tif (target == this || tween.passive) { continue; } // TODO: this assumes actions tween has this as the target. Valid?\n\t\t\tvar offset = tween._stepPosition;\n\n\t\t\tif (target instanceof createjs.DisplayObject) {\n\t\t\t\t// motion tween.\n\t\t\t\tthis._addManagedChild(target, offset);\n\t\t\t} else {\n\t\t\t\t// state tween.\n\t\t\t\tthis._setState(target.state, offset);\n\t\t\t}\n\t\t}\n\n\t\tvar kids = this.children;\n\t\tfor (i=kids.length-1; i>=0; i--) {\n\t\t\tvar id = kids[i].id;\n\t\t\tif (this._managed[id] == 1) {\n\t\t\t\tthis.removeChildAt(i);\n\t\t\t\tdelete(this._managed[id]);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _setState\n\t * @param {Array} state\n\t * @param {Number} offset\n\t * @protected\n\t **/\n\tp._setState = function(state, offset) {\n\t\tif (!state) { return; }\n\t\tfor (var i=state.length-1;i>=0;i--) {\n\t\t\tvar o = state[i];\n\t\t\tvar target = o.t;\n\t\t\tvar props = o.p;\n\t\t\tfor (var n in props) { target[n] = props[n]; }\n\t\t\tthis._addManagedChild(target, offset);\n\t\t}\n\t};\n\n\t/**\n\t * Adds a child to the timeline, and sets it up as a managed child.\n\t * @method _addManagedChild\n\t * @param {MovieClip} child The child MovieClip to manage\n\t * @param {Number} offset\n\t * @private\n\t **/\n\tp._addManagedChild = function(child, offset) {\n\t\tif (child._off) { return; }\n\t\tthis.addChildAt(child,0);\n\n\t\tif (child instanceof MovieClip) {\n\t\t\tchild._synchOffset = offset;\n\t\t\t// TODO: this does not precisely match Flash. Flash loses track of the clip if it is renamed or removed from the timeline, which causes it to reset.\n\t\t\tif (child.mode == MovieClip.INDEPENDENT && child.autoReset && !this._managed[child.id]) { child._reset(); }\n\t\t}\n\t\tthis._managed[child.id] = 2;\n\t};\n\t\n\t/**\n\t * @method _getBounds\n\t * @param {Matrix2D} matrix\n\t * @param {Boolean} ignoreTransform\n\t * @return {Rectangle}\n\t * @protected\n\t **/\n\tp._getBounds = function(matrix, ignoreTransform) {\n\t\tvar bounds = this.DisplayObject_getBounds();\n\t\tif (!bounds) {\n\t\t\tthis._updateTimeline();\n\t\t\tif (this.frameBounds) { bounds = this._rectangle.copy(this.frameBounds[this.currentFrame]); }\n\t\t}\n\t\tif (bounds) { return this._transformBounds(bounds, matrix, ignoreTransform); }\n\t\treturn this.Container__getBounds(matrix, ignoreTransform);\n\t};\n\n\n\tcreatejs.MovieClip = createjs.promote(MovieClip, \"Container\");\n\n\n\n// MovieClipPlugin for TweenJS:\n\t/**\n\t * This plugin works with <a href=\"http://tweenjs.com\" target=\"_blank\">TweenJS</a> to prevent the startPosition\n\t * property from tweening.\n\t * @private\n\t * @class MovieClipPlugin\n\t * @constructor\n\t **/\n\tfunction MovieClipPlugin() {\n\t\tthrow(\"MovieClipPlugin cannot be instantiated.\")\n\t}\n\t\n\t/**\n\t * @method priority\n\t * @private\n\t **/\n\tMovieClipPlugin.priority = 100; // very high priority, should run first\n\n\t/**\n\t * @method install\n\t * @private\n\t **/\n\tMovieClipPlugin.install = function() {\n\t\tcreatejs.Tween.installPlugin(MovieClipPlugin, [\"startPosition\"]);\n\t};\n\t\n\t/**\n\t * @method init\n\t * @param {Tween} tween\n\t * @param {String} prop\n\t * @param {String|Number|Boolean} value\n\t * @private\n\t **/\n\tMovieClipPlugin.init = function(tween, prop, value) {\n\t\treturn value;\n\t};\n\t\n\t/**\n\t * @method step\n\t * @private\n\t **/\n\tMovieClipPlugin.step = function() {\n\t\t// unused.\n\t};\n\n\t/**\n\t * @method tween\n\t * @param {Tween} tween\n\t * @param {String} prop\n\t * @param {String | Number | Boolean} value\n\t * @param {Array} startValues\n\t * @param {Array} endValues\n\t * @param {Number} ratio\n\t * @param {Object} wait\n\t * @param {Object} end\n\t * @return {*}\n\t */\n\tMovieClipPlugin.tween = function(tween, prop, value, startValues, endValues, ratio, wait, end) {\n\t\tif (!(tween.target instanceof MovieClip)) { return value; }\n\t\treturn (ratio == 1 ? endValues[prop] : startValues[prop]);\n\t};\n\n}());\n\n//##############################################################################\n// SpriteSheetUtils.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\t\n\t\n// constructor:\n\t/**\n\t * The SpriteSheetUtils class is a collection of static methods for working with {{#crossLink \"SpriteSheet\"}}{{/crossLink}}s.\n\t * A sprite sheet is a series of images (usually animation frames) combined into a single image on a regular grid. For\n\t * example, an animation consisting of 8 100x100 images could be combined into a 400x200 sprite sheet (4 frames across\n\t * by 2 high). The SpriteSheetUtils class uses a static interface and should not be instantiated.\n\t * @class SpriteSheetUtils\n\t * @static\n\t **/\n\tfunction SpriteSheetUtils() {\n\t\tthrow \"SpriteSheetUtils cannot be instantiated\";\n\t}\n\n\n// private static properties:\n\t/**\n\t * @property _workingCanvas\n\t * @static\n\t * @type HTMLCanvasElement | Object\n\t * @protected\n\t*/\n\t/**\n\t * @property _workingContext\n\t * @static\n\t * @type CanvasRenderingContext2D\n\t * @protected\n\t*/\n\tvar canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement(\"canvas\"));\n\tif (canvas.getContext) {\n\t\tSpriteSheetUtils._workingCanvas = canvas;\n\t\tSpriteSheetUtils._workingContext = canvas.getContext(\"2d\");\n\t\tcanvas.width = canvas.height = 1;\n\t}\n\n\n// public static methods:\n\t/**\n\t * <b>This is an experimental method, and may be buggy. Please report issues.</b><br/><br/>\n\t * Extends the existing sprite sheet by flipping the original frames horizontally, vertically, or both,\n\t * and adding appropriate animation & frame data. The flipped animations will have a suffix added to their names\n\t * (_h, _v, _hv as appropriate). Make sure the sprite sheet images are fully loaded before using this method.\n\t * <br/><br/>\n\t * For example:<br/>\n\t * SpriteSheetUtils.addFlippedFrames(mySpriteSheet, true, true);\n\t * The above would add frames that are flipped horizontally AND frames that are flipped vertically.\n\t * <br/><br/>\n\t * Note that you can also flip any display object by setting its scaleX or scaleY to a negative value. On some\n\t * browsers (especially those without hardware accelerated canvas) this can result in slightly degraded performance,\n\t * which is why addFlippedFrames is available.\n\t * @method addFlippedFrames\n\t * @static\n\t * @param {SpriteSheet} spriteSheet\n\t * @param {Boolean} horizontal If true, horizontally flipped frames will be added.\n\t * @param {Boolean} vertical If true, vertically flipped frames will be added.\n\t * @param {Boolean} both If true, frames that are flipped both horizontally and vertically will be added.\n\t * @deprecated Modern browsers perform better when flipping via a transform (ex. scaleX=-1) rendering this obsolete.\n\t **/\n\tSpriteSheetUtils.addFlippedFrames = function(spriteSheet, horizontal, vertical, both) {\n\t\tif (!horizontal && !vertical && !both) { return; }\n\n\t\tvar count = 0;\n\t\tif (horizontal) { SpriteSheetUtils._flip(spriteSheet,++count,true,false); }\n\t\tif (vertical) { SpriteSheetUtils._flip(spriteSheet,++count,false,true); }\n\t\tif (both) { SpriteSheetUtils._flip(spriteSheet,++count,true,true); }\n\t};\n\n\t/**\n\t * Returns a single frame of the specified sprite sheet as a new PNG image. An example of when this may be useful is\n\t * to use a spritesheet frame as the source for a bitmap fill.\n\t *\n\t * <strong>WARNING:</strong> In almost all cases it is better to display a single frame using a {{#crossLink \"Sprite\"}}{{/crossLink}}\n\t * with a {{#crossLink \"Sprite/gotoAndStop\"}}{{/crossLink}} call than it is to slice out a frame using this\n\t * method and display it with a Bitmap instance. You can also crop an image using the {{#crossLink \"Bitmap/sourceRect\"}}{{/crossLink}}\n\t * property of {{#crossLink \"Bitmap\"}}{{/crossLink}}.\n\t *\n\t * The extractFrame method may cause cross-domain warnings since it accesses pixels directly on the canvas.\n\t * @method extractFrame\n\t * @static\n\t * @param {SpriteSheet} spriteSheet The SpriteSheet instance to extract a frame from.\n\t * @param {Number|String} frameOrAnimation The frame number or animation name to extract. If an animation\n\t * name is specified, only the first frame of the animation will be extracted.\n\t * @return {HTMLImageElement} a single frame of the specified sprite sheet as a new PNG image.\n\t*/\n\tSpriteSheetUtils.extractFrame = function(spriteSheet, frameOrAnimation) {\n\t\tif (isNaN(frameOrAnimation)) {\n\t\t\tframeOrAnimation = spriteSheet.getAnimation(frameOrAnimation).frames[0];\n\t\t}\n\t\tvar data = spriteSheet.getFrame(frameOrAnimation);\n\t\tif (!data) { return null; }\n\t\tvar r = data.rect;\n\t\tvar canvas = SpriteSheetUtils._workingCanvas;\n\t\tcanvas.width = r.width;\n\t\tcanvas.height = r.height;\n\t\tSpriteSheetUtils._workingContext.drawImage(data.image, r.x, r.y, r.width, r.height, 0, 0, r.width, r.height);\n\t\tvar img = document.createElement(\"img\");\n\t\timg.src = canvas.toDataURL(\"image/png\");\n\t\treturn img;\n\t};\n\n\t/**\n\t * Merges the rgb channels of one image with the alpha channel of another. This can be used to combine a compressed\n\t * JPEG image containing color data with a PNG32 monochromatic image containing alpha data. With certain types of\n\t * images (those with detail that lend itself to JPEG compression) this can provide significant file size savings\n\t * versus a single RGBA PNG32. This method is very fast (generally on the order of 1-2 ms to run).\n\t * @method mergeAlpha\n\t * @static\n\t * @param {HTMLImageElement} rbgImage The image (or canvas) containing the RGB channels to use.\n\t * @param {HTMLImageElement} alphaImage The image (or canvas) containing the alpha channel to use.\n\t * @param {HTMLCanvasElement} canvas Optional. If specified, this canvas will be used and returned. If not, a new canvas will be created.\n\t * @return {HTMLCanvasElement} A canvas with the combined image data. This can be used as a source for Bitmap or SpriteSheet.\n\t * @deprecated Tools such as ImageAlpha generally provide better results. This will be moved to sandbox in the future.\n\t*/\n\tSpriteSheetUtils.mergeAlpha = function(rgbImage, alphaImage, canvas) {\n\t\tif (!canvas) { canvas = createjs.createCanvas?createjs.createCanvas():document.createElement(\"canvas\"); }\n\t\tcanvas.width = Math.max(alphaImage.width, rgbImage.width);\n\t\tcanvas.height = Math.max(alphaImage.height, rgbImage.height);\n\t\tvar ctx = canvas.getContext(\"2d\");\n\t\tctx.save();\n\t\tctx.drawImage(rgbImage,0,0);\n\t\tctx.globalCompositeOperation = \"destination-in\";\n\t\tctx.drawImage(alphaImage,0,0);\n\t\tctx.restore();\n\t\treturn canvas;\n\t};\n\n\n// private static methods:\n\tSpriteSheetUtils._flip = function(spriteSheet, count, h, v) {\n\t\tvar imgs = spriteSheet._images;\n\t\tvar canvas = SpriteSheetUtils._workingCanvas;\n\t\tvar ctx = SpriteSheetUtils._workingContext;\n\t\tvar il = imgs.length/count;\n\t\tfor (var i=0;i<il;i++) {\n\t\t\tvar src = imgs[i];\n\t\t\tsrc.__tmp = i; // a bit hacky, but faster than doing indexOf below.\n\t\t\tctx.setTransform(1,0,0,1,0,0);\n\t\t\tctx.clearRect(0,0,canvas.width+1,canvas.height+1);\n\t\t\tcanvas.width = src.width;\n\t\t\tcanvas.height = src.height;\n\t\t\tctx.setTransform(h?-1:1, 0, 0, v?-1:1, h?src.width:0, v?src.height:0);\n\t\t\tctx.drawImage(src,0,0);\n\t\t\tvar img = document.createElement(\"img\");\n\t\t\timg.src = canvas.toDataURL(\"image/png\");\n\t\t\t// work around a strange bug in Safari:\n\t\t\timg.width = src.width;\n\t\t\timg.height = src.height;\n\t\t\timgs.push(img);\n\t\t}\n\n\t\tvar frames = spriteSheet._frames;\n\t\tvar fl = frames.length/count;\n\t\tfor (i=0;i<fl;i++) {\n\t\t\tsrc = frames[i];\n\t\t\tvar rect = src.rect.clone();\n\t\t\timg = imgs[src.image.__tmp+il*count];\n\n\t\t\tvar frame = {image:img,rect:rect,regX:src.regX,regY:src.regY};\n\t\t\tif (h) {\n\t\t\t\trect.x = img.width-rect.x-rect.width; // update rect\n\t\t\t\tframe.regX = rect.width-src.regX; // update registration point\n\t\t\t}\n\t\t\tif (v) {\n\t\t\t\trect.y = img.height-rect.y-rect.height;  // update rect\n\t\t\t\tframe.regY = rect.height-src.regY; // update registration point\n\t\t\t}\n\t\t\tframes.push(frame);\n\t\t}\n\n\t\tvar sfx = \"_\"+(h?\"h\":\"\")+(v?\"v\":\"\");\n\t\tvar names = spriteSheet._animations;\n\t\tvar data = spriteSheet._data;\n\t\tvar al = names.length/count;\n\t\tfor (i=0;i<al;i++) {\n\t\t\tvar name = names[i];\n\t\t\tsrc = data[name];\n\t\t\tvar anim = {name:name+sfx,speed:src.speed,next:src.next,frames:[]};\n\t\t\tif (src.next) { anim.next += sfx; }\n\t\t\tframes = src.frames;\n\t\t\tfor (var j=0,l=frames.length;j<l;j++) {\n\t\t\t\tanim.frames.push(frames[j]+fl*count);\n\t\t\t}\n\t\t\tdata[anim.name] = anim;\n\t\t\tnames.push(anim.name);\n\t\t}\n\t};\n\n\n\tcreatejs.SpriteSheetUtils = SpriteSheetUtils;\n}());\n\n//##############################################################################\n// SpriteSheetBuilder.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * The SpriteSheetBuilder allows you to generate {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instances at run time\n\t * from any display object. This can allow you to maintain your assets as vector graphics (for low file size), and\n\t * render them at run time as SpriteSheets for better performance.\n\t *\n\t * SpriteSheets can be built either synchronously, or asynchronously, so that large SpriteSheets can be generated\n\t * without locking the UI.\n\t *\n\t * Note that the \"images\" used in the generated SpriteSheet are actually canvas elements, and that they will be\n\t * sized to the nearest power of 2 up to the value of {{#crossLink \"SpriteSheetBuilder/maxWidth:property\"}}{{/crossLink}}\n\t * or {{#crossLink \"SpriteSheetBuilder/maxHeight:property\"}}{{/crossLink}}.\n\t * @class SpriteSheetBuilder\n\t * @param {Number} [framerate=0] The {{#crossLink \"SpriteSheet/framerate:property\"}}{{/crossLink}} of\n\t * {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instances that are created.\n\t * @extends EventDispatcher\n\t * @constructor\n\t **/\n\tfunction SpriteSheetBuilder(framerate) {\n\t\tthis.EventDispatcher_constructor();\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The maximum width for the images (not individual frames) in the generated SpriteSheet. It is recommended to\n\t\t * use a power of 2 for this value (ex. 1024, 2048, 4096). If the frames cannot all fit within the max\n\t\t * dimensions, then additional images will be created as needed.\n\t\t * @property maxWidth\n\t\t * @type Number\n\t\t * @default 2048\n\t\t*/\n\t\tthis.maxWidth = 2048;\n\t\n\t\t/**\n\t\t * The maximum height for the images (not individual frames) in the generated SpriteSheet. It is recommended to\n\t\t * use a power of 2 for this value (ex. 1024, 2048, 4096). If the frames cannot all fit within the max\n\t\t * dimensions, then additional images will be created as needed.\n\t\t * @property maxHeight\n\t\t * @type Number\n\t\t * @default 2048\n\t\t **/\n\t\tthis.maxHeight = 2048;\n\t\n\t\t/**\n\t\t * The SpriteSheet that was generated. This will be null before a build is completed successfully.\n\t\t * @property spriteSheet\n\t\t * @type SpriteSheet\n\t\t **/\n\t\tthis.spriteSheet = null;\n\t\n\t\t/**\n\t\t * The scale to apply when drawing all frames to the SpriteSheet. This is multiplied against any scale specified\n\t\t * in the addFrame call. This can be used, for example, to generate a SpriteSheet at run time that is tailored\n\t\t * to the a specific device resolution (ex. tablet vs mobile).\n\t\t * @property scale\n\t\t * @type Number\n\t\t * @default 1\n\t\t **/\n\t\tthis.scale = 1;\n\t\n\t\t/**\n\t\t* The padding to use between frames. This is helpful to preserve antialiasing on drawn vector content.\n\t\t* @property padding\n\t\t* @type Number\n\t\t* @default 1\n\t\t**/\n\t\tthis.padding = 1;\n\t\n\t\t/**\n\t\t * A number from 0.01 to 0.99 that indicates what percentage of time the builder can use. This can be\n\t\t * thought of as the number of seconds per second the builder will use. For example, with a timeSlice value of 0.3,\n\t\t * the builder will run 20 times per second, using approximately 15ms per build (30% of available time, or 0.3s per second).\n\t\t * Defaults to 0.3.\n\t\t * @property timeSlice\n\t\t * @type Number\n\t\t * @default 0.3\n\t\t **/\n\t\tthis.timeSlice = 0.3;\n\t\n\t\t/**\n\t\t * A value between 0 and 1 that indicates the progress of a build, or -1 if a build has not\n\t\t * been initiated.\n\t\t * @property progress\n\t\t * @type Number\n\t\t * @default -1\n\t\t * @readonly\n\t\t */\n\t\tthis.progress = -1;\n\n\t\t/**\n\t\t * A {{#crossLink \"SpriteSheet/framerate:property\"}}{{/crossLink}} value that will be passed to new {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instances that are\n\t\t * created. If no framerate is specified (or it is 0), then SpriteSheets will use the {{#crossLink \"Ticker\"}}{{/crossLink}}\n\t\t * framerate.\n\t\t * @property framerate\n\t\t * @type Number\n\t\t * @default 0\n\t\t */\n\t\tthis.framerate = framerate || 0;\n\t\n\t\n\t// private properties:\n\t\t/**\n\t\t * @property _frames\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._frames = [];\n\t\n\t\t/**\n\t\t * @property _animations\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._animations = {};\n\t\n\t\t/**\n\t\t * @property _data\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._data = null;\n\t\n\t\t/**\n\t\t * @property _nextFrameIndex\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._nextFrameIndex = 0;\n\t\n\t\t/**\n\t\t * @property _index\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._index = 0;\n\t\n\t\t/**\n\t\t * @property _timerID\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._timerID = null;\n\t\n\t\t/**\n\t\t * @property _scale\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._scale = 1;\n\t}\n\tvar p = createjs.extend(SpriteSheetBuilder, createjs.EventDispatcher);\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// constants:\n\tSpriteSheetBuilder.ERR_DIMENSIONS = \"frame dimensions exceed max spritesheet dimensions\";\n\tSpriteSheetBuilder.ERR_RUNNING = \"a build is already running\";\n\n// events:\n\t/**\n\t * Dispatched when a build completes.\n\t * @event complete\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when an asynchronous build has progress.\n\t * @event progress\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Number} progress The current progress value (0-1).\n\t * @since 0.6.0\n\t */\n\n\n// public methods:\n\t/**\n\t * Adds a frame to the {{#crossLink \"SpriteSheet\"}}{{/crossLink}}. Note that the frame will not be drawn until you\n\t * call {{#crossLink \"SpriteSheetBuilder/build\"}}{{/crossLink}} method. The optional setup params allow you to have\n\t * a function run immediately before the draw occurs. For example, this allows you to add a single source multiple\n\t * times, but manipulate it or its children to change it to generate different frames.\n\t *\n\t * Note that the source's transformations (x, y, scale, rotate, alpha) will be ignored, except for regX/Y. To apply\n\t * transforms to a source object and have them captured in the SpriteSheet, simply place it into a {{#crossLink \"Container\"}}{{/crossLink}}\n\t * and pass in the Container as the source.\n\t * @method addFrame\n\t * @param {DisplayObject} source The source {{#crossLink \"DisplayObject\"}}{{/crossLink}}  to draw as the frame.\n\t * @param {Rectangle} [sourceRect] A {{#crossLink \"Rectangle\"}}{{/crossLink}} defining the portion of the\n\t * source to draw to the frame. If not specified, it will look for a `getBounds` method, bounds property, or\n\t * `nominalBounds` property on the source to use. If one is not found, the frame will be skipped.\n\t * @param {Number} [scale=1] Optional. The scale to draw this frame at. Default is 1.\n\t * @param {Function} [setupFunction] A function to call immediately before drawing this frame. It will be called with two parameters: the source, and setupData.\n\t * @param {Object} [setupData] Arbitrary setup data to pass to setupFunction as the second parameter.\n\t * @return {Number} The index of the frame that was just added, or null if a sourceRect could not be determined.\n\t **/\n\tp.addFrame = function(source, sourceRect, scale, setupFunction, setupData) {\n\t\tif (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }\n\t\tvar rect = sourceRect||source.bounds||source.nominalBounds;\n\t\tif (!rect&&source.getBounds) { rect = source.getBounds(); }\n\t\tif (!rect) { return null; }\n\t\tscale = scale||1;\n\t\treturn this._frames.push({source:source, sourceRect:rect, scale:scale, funct:setupFunction, data:setupData, index:this._frames.length, height:rect.height*scale})-1;\n\t};\n\n\t/**\n\t * Adds an animation that will be included in the created {{#crossLink \"SpriteSheet\"}}{{/crossLink}}.\n\t * @method addAnimation\n\t * @param {String} name The name for the animation.\n\t * @param {Array} frames An array of frame indexes that comprise the animation. Ex. [3,6,5] would describe an animation\n\t * that played frame indexes 3, 6, and 5 in that order.\n\t * @param {String} [next] Specifies the name of the animation to continue to after this animation ends. You can\n\t * also pass false to have the animation stop when it ends. By default it will loop to the start of the same animation.\n\t * @param {Number} [speed] Specifies a frame advance speed for this animation. For example, a value of 0.5 would\n\t * cause the animation to advance every second tick. Note that earlier versions used `frequency` instead, which had\n\t * the opposite effect.\n\t **/\n\tp.addAnimation = function(name, frames, next, speed) {\n\t\tif (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }\n\t\tthis._animations[name] = {frames:frames, next:next, speed:speed};\n\t};\n\n\t/**\n\t * This will take a {{#crossLink \"MovieClip\"}}{{/crossLink}} instance, and add its frames and labels to this\n\t * builder. Labels will be added as an animation running from the label index to the next label. For example, if\n\t * there is a label named \"foo\" at frame 0 and a label named \"bar\" at frame 10, in a MovieClip with 15 frames, it\n\t * will add an animation named \"foo\" that runs from frame index 0 to 9, and an animation named \"bar\" that runs from\n\t * frame index 10 to 14.\n\t *\n\t * Note that this will iterate through the full MovieClip with {{#crossLink \"MovieClip/actionsEnabled:property\"}}{{/crossLink}}\n\t * set to `false`, ending on the last frame.\n\t * @method addMovieClip\n\t * @param {MovieClip} source The source MovieClip instance to add to the SpriteSheet.\n\t * @param {Rectangle} [sourceRect] A {{#crossLink \"Rectangle\"}}{{/crossLink}} defining the portion of the source to\n\t * draw to the frame. If not specified, it will look for a {{#crossLink \"DisplayObject/getBounds\"}}{{/crossLink}}\n\t * method, `frameBounds` Array, `bounds` property, or `nominalBounds` property on the source to use. If one is not\n\t * found, the MovieClip will be skipped.\n\t * @param {Number} [scale=1] The scale to draw the movie clip at.\n\t * @param {Function} [setupFunction] A function to call immediately before drawing each frame. It will be called\n\t * with three parameters: the source, setupData, and the frame index.\n\t * @param {Object} [setupData] Arbitrary setup data to pass to setupFunction as the second parameter.\n\t * @param {Function} [labelFunction] This method will be called for each MovieClip label that is added with four\n\t * parameters: the label name, the source MovieClip instance, the starting frame index (in the movieclip timeline)\n\t * and the end index. It must return a new name for the label/animation, or `false` to exclude the label.\n\t **/\n\tp.addMovieClip = function(source, sourceRect, scale, setupFunction, setupData, labelFunction) {\n\t\tif (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }\n\t\tvar rects = source.frameBounds;\n\t\tvar rect = sourceRect||source.bounds||source.nominalBounds;\n\t\tif (!rect&&source.getBounds) { rect = source.getBounds(); }\n\t\tif (!rect && !rects) { return; }\n\n\t\tvar i, l, baseFrameIndex = this._frames.length;\n\t\tvar duration = source.timeline.duration;\n\t\tfor (i=0; i<duration; i++) {\n\t\t\tvar r = (rects&&rects[i]) ? rects[i] : rect;\n\t\t\tthis.addFrame(source, r, scale, this._setupMovieClipFrame, {i:i, f:setupFunction, d:setupData});\n\t\t}\n\t\tvar labels = source.timeline._labels;\n\t\tvar lbls = [];\n\t\tfor (var n in labels) {\n\t\t\tlbls.push({index:labels[n], label:n});\n\t\t}\n\t\tif (lbls.length) {\n\t\t\tlbls.sort(function(a,b){ return a.index-b.index; });\n\t\t\tfor (i=0,l=lbls.length; i<l; i++) {\n\t\t\t\tvar label = lbls[i].label;\n\t\t\t\tvar start = baseFrameIndex+lbls[i].index;\n\t\t\t\tvar end = baseFrameIndex+((i == l-1) ? duration : lbls[i+1].index);\n\t\t\t\tvar frames = [];\n\t\t\t\tfor (var j=start; j<end; j++) { frames.push(j); }\n\t\t\t\tif (labelFunction) {\n\t\t\t\t\tlabel = labelFunction(label, source, start, end);\n\t\t\t\t\tif (!label) { continue; }\n\t\t\t\t}\n\t\t\t\tthis.addAnimation(label, frames, true); // for now, this loops all animations.\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Builds a {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instance based on the current frames.\n\t * @method build\n\t * @return {SpriteSheet} The created SpriteSheet instance, or null if a build is already running or an error\n\t * occurred.\n\t **/\n\tp.build = function() {\n\t\tif (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }\n\t\tthis._startBuild();\n\t\twhile (this._drawNext()) {}\n\t\tthis._endBuild();\n\t\treturn this.spriteSheet;\n\t};\n\n\t/**\n\t * Asynchronously builds a {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instance based on the current frames. It will\n\t * run 20 times per second, using an amount of time defined by `timeSlice`. When it is complete it will call the\n\t * specified callback.\n\t * @method buildAsync\n\t * @param {Number} [timeSlice] Sets the timeSlice property on this instance.\n\t **/\n\tp.buildAsync = function(timeSlice) {\n\t\tif (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }\n\t\tthis.timeSlice = timeSlice;\n\t\tthis._startBuild();\n\t\tvar _this = this;\n\t\tthis._timerID = setTimeout(function() { _this._run(); }, 50-Math.max(0.01, Math.min(0.99, this.timeSlice||0.3))*50);\n\t};\n\n\t/**\n\t * Stops the current asynchronous build.\n\t * @method stopAsync\n\t **/\n\tp.stopAsync = function() {\n\t\tclearTimeout(this._timerID);\n\t\tthis._data = null;\n\t};\n\n\t/**\n\t * SpriteSheetBuilder instances cannot be cloned.\n\t * @method clone\n\t **/\n\tp.clone = function() {\n\t\tthrow(\"SpriteSheetBuilder cannot be cloned.\");\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[SpriteSheetBuilder]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _startBuild\n\t * @protected\n\t **/\n\tp._startBuild = function() {\n\t\tvar pad = this.padding||0;\n\t\tthis.progress = 0;\n\t\tthis.spriteSheet = null;\n\t\tthis._index = 0;\n\t\tthis._scale = this.scale;\n\t\tvar dataFrames = [];\n\t\tthis._data = {\n\t\t\timages: [],\n\t\t\tframes: dataFrames,\n\t\t\tframerate: this.framerate,\n\t\t\tanimations: this._animations // TODO: should we \"clone\" _animations in case someone adds more animations after a build?\n\t\t};\n\n\t\tvar frames = this._frames.slice();\n\t\tframes.sort(function(a,b) { return (a.height<=b.height) ? -1 : 1; });\n\n\t\tif (frames[frames.length-1].height+pad*2 > this.maxHeight) { throw SpriteSheetBuilder.ERR_DIMENSIONS; }\n\t\tvar y=0, x=0;\n\t\tvar img = 0;\n\t\twhile (frames.length) {\n\t\t\tvar o = this._fillRow(frames, y, img, dataFrames, pad);\n\t\t\tif (o.w > x) { x = o.w; }\n\t\t\ty += o.h;\n\t\t\tif (!o.h || !frames.length) {\n\t\t\t\tvar canvas = createjs.createCanvas?createjs.createCanvas():document.createElement(\"canvas\");\n\t\t\t\tcanvas.width = this._getSize(x,this.maxWidth);\n\t\t\t\tcanvas.height = this._getSize(y,this.maxHeight);\n\t\t\t\tthis._data.images[img] = canvas;\n\t\t\t\tif (!o.h) {\n\t\t\t\t\tx=y=0;\n\t\t\t\t\timg++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\t/**\n\t * @method _setupMovieClipFrame\n\t * @protected\n\t * @return {Number} The width & height of the row.\n\t **/\n\tp._setupMovieClipFrame = function(source, data) {\n\t\tvar ae = source.actionsEnabled;\n\t\tsource.actionsEnabled = false;\n\t\tsource.gotoAndStop(data.i);\n\t\tsource.actionsEnabled = ae;\n\t\tdata.f&&data.f(source, data.d, data.i);\n\t};\n\n\t/**\n\t * @method _getSize\n\t * @protected\n\t * @return {Number} The width & height of the row.\n\t **/\n\tp._getSize = function(size,max) {\n\t\tvar pow = 4;\n\t\twhile (Math.pow(2,++pow) < size){}\n\t\treturn Math.min(max,Math.pow(2,pow));\n\t};\n\n\t/**\n\t * @method _fillRow\n\t * @param {Array} frames\n\t * @param {Number} y\n\t * @param {HTMLImageElement} img\n\t * @param {Object} dataFrames\n\t * @param {Number} pad\n\t * @protected\n\t * @return {Number} The width & height of the row.\n\t **/\n\tp._fillRow = function(frames, y, img, dataFrames, pad) {\n\t\tvar w = this.maxWidth;\n\t\tvar maxH = this.maxHeight;\n\t\ty += pad;\n\t\tvar h = maxH-y;\n\t\tvar x = pad;\n\t\tvar height = 0;\n\t\tfor (var i=frames.length-1; i>=0; i--) {\n\t\t\tvar frame = frames[i];\n\t\t\tvar sc = this._scale*frame.scale;\n\t\t\tvar rect = frame.sourceRect;\n\t\t\tvar source = frame.source;\n\t\t\tvar rx = Math.floor(sc*rect.x-pad);\n\t\t\tvar ry = Math.floor(sc*rect.y-pad);\n\t\t\tvar rh = Math.ceil(sc*rect.height+pad*2);\n\t\t\tvar rw = Math.ceil(sc*rect.width+pad*2);\n\t\t\tif (rw > w) { throw SpriteSheetBuilder.ERR_DIMENSIONS; }\n\t\t\tif (rh > h || x+rw > w) { continue; }\n\t\t\tframe.img = img;\n\t\t\tframe.rect = new createjs.Rectangle(x,y,rw,rh);\n\t\t\theight = height || rh;\n\t\t\tframes.splice(i,1);\n\t\t\tdataFrames[frame.index] = [x,y,rw,rh,img,Math.round(-rx+sc*source.regX-pad),Math.round(-ry+sc*source.regY-pad)];\n\t\t\tx += rw;\n\t\t}\n\t\treturn {w:x, h:height};\n\t};\n\n\t/**\n\t * @method _endBuild\n\t * @protected\n\t **/\n\tp._endBuild = function() {\n\t\tthis.spriteSheet = new createjs.SpriteSheet(this._data);\n\t\tthis._data = null;\n\t\tthis.progress = 1;\n\t\tthis.dispatchEvent(\"complete\");\n\t};\n\n\t/**\n\t * @method _run\n\t * @protected\n\t **/\n\tp._run = function() {\n\t\tvar ts = Math.max(0.01, Math.min(0.99, this.timeSlice||0.3))*50;\n\t\tvar t = (new Date()).getTime()+ts;\n\t\tvar complete = false;\n\t\twhile (t > (new Date()).getTime()) {\n\t\t\tif (!this._drawNext()) { complete = true; break; }\n\t\t}\n\t\tif (complete) {\n\t\t\tthis._endBuild();\n\t\t} else {\n\t\t\tvar _this = this;\n\t\t\tthis._timerID = setTimeout(function() { _this._run(); }, 50-ts);\n\t\t}\n\t\tvar p = this.progress = this._index/this._frames.length;\n\t\tif (this.hasEventListener(\"progress\")) {\n\t\t\tvar evt = new createjs.Event(\"progress\");\n\t\t\tevt.progress = p;\n\t\t\tthis.dispatchEvent(evt);\n\t\t}\n\t};\n\n\t/**\n\t * @method _drawNext\n\t * @protected\n\t * @return Boolean Returns false if this is the last draw.\n\t **/\n\tp._drawNext = function() {\n\t\tvar frame = this._frames[this._index];\n\t\tvar sc = frame.scale*this._scale;\n\t\tvar rect = frame.rect;\n\t\tvar sourceRect = frame.sourceRect;\n\t\tvar canvas = this._data.images[frame.img];\n\t\tvar ctx = canvas.getContext(\"2d\");\n\t\tframe.funct&&frame.funct(frame.source, frame.data);\n\t\tctx.save();\n\t\tctx.beginPath();\n\t\tctx.rect(rect.x, rect.y, rect.width, rect.height);\n\t\tctx.clip();\n\t\tctx.translate(Math.ceil(rect.x-sourceRect.x*sc), Math.ceil(rect.y-sourceRect.y*sc));\n\t\tctx.scale(sc,sc);\n\t\tframe.source.draw(ctx); // display object will draw itself.\n\t\tctx.restore();\n\t\treturn (++this._index) < this._frames.length;\n\t};\n\n\n\tcreatejs.SpriteSheetBuilder = createjs.promote(SpriteSheetBuilder, \"EventDispatcher\");\n}());\n\n//##############################################################################\n// DOMElement.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * <b>This class is still experimental, and more advanced use is likely to be buggy. Please report bugs.</b>\n\t *\n\t * A DOMElement allows you to associate a HTMLElement with the display list. It will be transformed\n\t * within the DOM as though it is child of the {{#crossLink \"Container\"}}{{/crossLink}} it is added to. However, it is\n\t * not rendered to canvas, and as such will retain whatever z-index it has relative to the canvas (ie. it will be\n\t * drawn in front of or behind the canvas).\n\t *\n\t * The position of a DOMElement is relative to their parent node in the DOM. It is recommended that\n\t * the DOM Object be added to a div that also contains the canvas so that they share the same position\n\t * on the page.\n\t *\n\t * DOMElement is useful for positioning HTML elements over top of canvas content, and for elements\n\t * that you want to display outside the bounds of the canvas. For example, a tooltip with rich HTML\n\t * content.\n\t *\n\t * <h4>Mouse Interaction</h4>\n\t *\n\t * DOMElement instances are not full EaselJS display objects, and do not participate in EaselJS mouse\n\t * events or support methods like hitTest. To get mouse events from a DOMElement, you must instead add handlers to\n\t * the htmlElement (note, this does not support EventDispatcher)\n\t *\n\t *      var domElement = new createjs.DOMElement(htmlElement);\n\t *      domElement.htmlElement.onclick = function() {\n\t *          console.log(\"clicked\");\n\t *      }\n\t *\n\t * @class DOMElement\n\t * @extends DisplayObject\n\t * @constructor\n\t * @param {HTMLElement} htmlElement A reference or id for the DOM element to manage.\n\t */\n\tfunction DOMElement(htmlElement) {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t\tif (typeof(htmlElement)==\"string\") { htmlElement = document.getElementById(htmlElement); }\n\t\tthis.mouseEnabled = false;\n\t\t\n\t\tvar style = htmlElement.style;\n\t\tstyle.position = \"absolute\";\n\t\tstyle.transformOrigin = style.WebkitTransformOrigin = style.msTransformOrigin = style.MozTransformOrigin = style.OTransformOrigin = \"0% 0%\";\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The DOM object to manage.\n\t\t * @property htmlElement\n\t\t * @type HTMLElement\n\t\t */\n\t\tthis.htmlElement = htmlElement;\n\t\n\t\n\t// private properties:\n\t\t/**\n\t\t * @property _oldMtx\n\t\t * @type Matrix2D\n\t\t * @protected\n\t\t */\n\t\tthis._oldProps = null;\n\t}\n\tvar p = createjs.extend(DOMElement, createjs.DisplayObject);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// public methods:\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t */\n\tp.isVisible = function() {\n\t\treturn this.htmlElement != null;\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t * @return {Boolean}\n\t */\n\tp.draw = function(ctx, ignoreCache) {\n\t\t// this relies on the _tick method because draw isn't called if the parent is not visible.\n\t\t// the actual update happens in _handleDrawEnd\n\t\treturn true;\n\t};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method cache\n\t */\n\tp.cache = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method uncache\n\t */\n\tp.uncache = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method updateCache\n\t */\n\tp.updateCache = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method hitTest\n\t */\n\tp.hitTest = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method localToGlobal\n\t */\n\tp.localToGlobal = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method globalToLocal\n\t */\n\tp.globalToLocal = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method localToLocal\n\t */\n\tp.localToLocal = function() {};\n\n\t/**\n\t * DOMElement cannot be cloned. Throws an error.\n\t * @method clone\n\t */\n\tp.clone = function() {\n\t\tthrow(\"DOMElement cannot be cloned.\")\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t */\n\tp.toString = function() {\n\t\treturn \"[DOMElement (name=\"+  this.name +\")]\";\n\t};\n\n\t/**\n     * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances\n\t * are not full EaselJS display objects and do not participate in EaselJS mouse events.\n\t * @event click\n\t */\n\n     /**\n     * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances\n \t * are not full EaselJS display objects and do not participate in EaselJS mouse events.\n\t * @event dblClick\n\t */\n\n     /**\n      * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances\n \t  * are not full EaselJS display objects and do not participate in EaselJS mouse events.\n\t  * @event mousedown\n\t  */\n\n     /**\n      * The HTMLElement can listen for the mouseover event, not the DOMElement instance.\n      * Since DOMElement instances are not full EaselJS display objects and do not participate in EaselJS mouse events.\n      * @event mouseover\n\t  */\n\n     /**\n      * Not applicable to DOMElement.\n\t  * @event tick\n\t  */\n\n\n// private methods:\n\t/**\n\t * @method _tick\n\t * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.\n\t * function.\n\t * @protected\n\t */\n\tp._tick = function(evtObj) {\n\t\tvar stage = this.getStage();\n\t\tstage&&stage.on(\"drawend\", this._handleDrawEnd, this, true);\n\t\tthis.DisplayObject__tick(evtObj);\n\t};\n\t\n\t/**\n\t * @method _handleDrawEnd\n\t * @param {Event} evt\n\t * @protected\n\t */\n\tp._handleDrawEnd = function(evt) {\n\t\tvar o = this.htmlElement;\n\t\tif (!o) { return; }\n\t\tvar style = o.style;\n\t\t\n\t\tvar props = this.getConcatenatedDisplayProps(this._props), mtx = props.matrix;\n\t\t\n\t\tvar visibility = props.visible ? \"visible\" : \"hidden\";\n\t\tif (visibility != style.visibility) { style.visibility = visibility; }\n\t\tif (!props.visible) { return; }\n\t\t\n\t\tvar oldProps = this._oldProps, oldMtx = oldProps&&oldProps.matrix;\n\t\tvar n = 10000; // precision\n\t\t\n\t\tif (!oldMtx || !oldMtx.equals(mtx)) {\n\t\t\tvar str = \"matrix(\" + (mtx.a*n|0)/n +\",\"+ (mtx.b*n|0)/n +\",\"+ (mtx.c*n|0)/n +\",\"+ (mtx.d*n|0)/n +\",\"+ (mtx.tx+0.5|0);\n\t\t\tstyle.transform = style.WebkitTransform = style.OTransform = style.msTransform = str +\",\"+ (mtx.ty+0.5|0) +\")\";\n\t\t\tstyle.MozTransform = str +\"px,\"+ (mtx.ty+0.5|0) +\"px)\";\n\t\t\tif (!oldProps) { oldProps = this._oldProps = new createjs.DisplayProps(true, NaN); }\n\t\t\toldProps.matrix.copy(mtx);\n\t\t}\n\t\t\n\t\tif (oldProps.alpha != props.alpha) {\n\t\t\tstyle.opacity = \"\"+(props.alpha*n|0)/n;\n\t\t\toldProps.alpha = props.alpha;\n\t\t}\n\t};\n\n\n\tcreatejs.DOMElement = createjs.promote(DOMElement, \"DisplayObject\");\n}());\n\n//##############################################################################\n// Filter.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Base class that all filters should inherit from. Filters need to be applied to objects that have been cached using\n\t * the {{#crossLink \"DisplayObject/cache\"}}{{/crossLink}} method. If an object changes, please cache it again, or use\n\t * {{#crossLink \"DisplayObject/updateCache\"}}{{/crossLink}}. Note that the filters must be applied before caching.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      myInstance.filters = [\n\t *          new createjs.ColorFilter(0, 0, 0, 1, 255, 0, 0),\n\t *          new createjs.BlurFilter(5, 5, 10)\n\t *      ];\n\t *      myInstance.cache(0,0, 100, 100);\n\t *\n\t * Note that each filter can implement a {{#crossLink \"Filter/getBounds\"}}{{/crossLink}} method, which returns the\n\t * margins that need to be applied in order to fully display the filter. For example, the {{#crossLink \"BlurFilter\"}}{{/crossLink}}\n\t * will cause an object to feather outwards, resulting in a margin around the shape.\n\t *\n\t * <h4>EaselJS Filters</h4>\n\t * EaselJS comes with a number of pre-built filters:\n\t * <ul><li>{{#crossLink \"AlphaMapFilter\"}}{{/crossLink}} : Map a greyscale image to the alpha channel of a display object</li>\n\t *      <li>{{#crossLink \"AlphaMaskFilter\"}}{{/crossLink}}: Map an image's alpha channel to the alpha channel of a display object</li>\n\t *      <li>{{#crossLink \"BlurFilter\"}}{{/crossLink}}: Apply vertical and horizontal blur to a display object</li>\n\t *      <li>{{#crossLink \"ColorFilter\"}}{{/crossLink}}: Color transform a display object</li>\n\t *      <li>{{#crossLink \"ColorMatrixFilter\"}}{{/crossLink}}: Transform an image using a {{#crossLink \"ColorMatrix\"}}{{/crossLink}}</li>\n\t * </ul>\n\t *\n\t * @class Filter\n\t * @constructor\n\t **/\n\tfunction Filter() {}\n\tvar p = Filter.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// public methods:\n\t/**\n\t * Provides padding values for this filter. That is, how much the filter will extend the visual bounds of an object it is applied to.\n\t * @method getBounds\n\t * @param {Rectangle} [rect] If specified, the provided Rectangle instance will be expanded by the padding amounts and returned.\n\t * @return {Rectangle} If a `rect` param was provided, it is returned. If not, either a new rectangle with the padding values, or null if no padding is required for this filter.\n\t **/\n\tp.getBounds = function(rect) {\n\t\treturn rect;\n\t};\n\n\t/**\n\t * Applies the filter to the specified context.\n\t * @method applyFilter\n\t * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.\n\t * @param {Number} x The x position to use for the source rect.\n\t * @param {Number} y The y position to use for the source rect.\n\t * @param {Number} width The width to use for the source rect.\n\t * @param {Number} height The height to use for the source rect.\n\t * @param {CanvasRenderingContext2D} [targetCtx] The 2D context to draw the result to. Defaults to the context passed to ctx.\n\t * @param {Number} [targetX] The x position to draw the result to. Defaults to the value passed to x.\n\t * @param {Number} [targetY] The y position to draw the result to. Defaults to the value passed to y.\n\t * @return {Boolean} If the filter was applied successfully.\n\t **/\n\tp.applyFilter = function(ctx, x, y, width, height, targetCtx, targetX, targetY) {\n\t\t// this is the default behaviour because most filters access pixel data. It is overridden when not needed.\n\t\ttargetCtx = targetCtx || ctx;\n\t\tif (targetX == null) { targetX = x; }\n\t\tif (targetY == null) { targetY = y; }\n\t\ttry {\n\t\t\tvar imageData = ctx.getImageData(x, y, width, height);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this._applyFilter(imageData)) {\n\t\t\ttargetCtx.putImageData(imageData, targetX, targetY);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Filter]\";\n\t};\n\n\t/**\n\t * Returns a clone of this Filter instance.\n\t * @method clone\n\t * @return {Filter} A clone of the current Filter instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Filter();\n\t};\n\t\n// private methods:\n\t/**\n\t * @method _applyFilter\n\t * @param {ImageData} imageData Target ImageData instance.\n\t * @return {Boolean}\n\t **/\n\tp._applyFilter = function(imageData) { return true; };\n\n\n\tcreatejs.Filter = Filter;\n}());\n\n//##############################################################################\n// BlurFilter.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Applies a box blur to DisplayObjects. Note that this filter is fairly CPU intensive, particularly if the quality is\n\t * set higher than 1.\n\t *\n\t * <h4>Example</h4>\n\t * This example creates a red circle, and then applies a 5 pixel blur to it. It uses the {{#crossLink \"Filter/getBounds\"}}{{/crossLink}}\n\t * method to account for the spread that the blur causes.\n\t *\n\t *      var shape = new createjs.Shape().set({x:100,y:100});\n\t *      shape.graphics.beginFill(\"#ff0000\").drawCircle(0,0,50);\n\t *\n\t *      var blurFilter = new createjs.BlurFilter(5, 5, 1);\n\t *      shape.filters = [blurFilter];\n\t *      var bounds = blurFilter.getBounds();\n\t *\n\t *      shape.cache(-50+bounds.x, -50+bounds.y, 100+bounds.width, 100+bounds.height);\n\t *\n\t * See {{#crossLink \"Filter\"}}{{/crossLink}} for an more information on applying filters.\n\t * @class BlurFilter\n\t * @extends Filter\n\t * @constructor\n\t * @param {Number} [blurX=0] The horizontal blur radius in pixels.\n\t * @param {Number} [blurY=0] The vertical blur radius in pixels.\n\t * @param {Number} [quality=1] The number of blur iterations.\n\t **/\n\tfunction BlurFilter( blurX, blurY, quality) {\n\t\tif ( isNaN(blurX) || blurX < 0 ) blurX = 0;\n\t\tif ( isNaN(blurY) || blurY < 0 ) blurY = 0;\n\t\tif ( isNaN(quality) || quality < 1  ) quality = 1;\n\n\n\t\t// public properties:\n\t\t/**\n\t\t * Horizontal blur radius in pixels\n\t\t * @property blurX\n\t\t * @default 0\n\t\t * @type Number\n\t\t **/\n\t\tthis.blurX = blurX | 0;\n\n\t\t/**\n\t\t * Vertical blur radius in pixels\n\t\t * @property blurY\n\t\t * @default 0\n\t\t * @type Number\n\t\t **/\n\t\tthis.blurY = blurY | 0;\n\n\t\t/**\n\t\t * Number of blur iterations. For example, a value of 1 will produce a rough blur. A value of 2 will produce a\n\t\t * smoother blur, but take twice as long to run.\n\t\t * @property quality\n\t\t * @default 1\n\t\t * @type Number\n\t\t **/\n\t\tthis.quality = quality | 0;\n\t}\n\tvar p = createjs.extend(BlurFilter, createjs.Filter);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// constants:\n\t/**\n\t * Array of multiply values for blur calculations.\n\t * @property MUL_TABLE\n\t * @type Array\n\t * @protected\n\t * @static\n\t **/\n\tBlurFilter.MUL_TABLE = [1, 171, 205, 293, 57, 373, 79, 137, 241, 27, 391, 357, 41, 19, 283, 265, 497, 469, 443, 421, 25, 191, 365, 349, 335, 161, 155, 149, 9, 278, 269, 261, 505, 245, 475, 231, 449, 437, 213, 415, 405, 395, 193, 377, 369, 361, 353, 345, 169, 331, 325, 319, 313, 307, 301, 37, 145, 285, 281, 69, 271, 267, 263, 259, 509, 501, 493, 243, 479, 118, 465, 459, 113, 446, 55, 435, 429, 423, 209, 413, 51, 403, 199, 393, 97, 3, 379, 375, 371, 367, 363, 359, 355, 351, 347, 43, 85, 337, 333, 165, 327, 323, 5, 317, 157, 311, 77, 305, 303, 75, 297, 294, 73, 289, 287, 71, 141, 279, 277, 275, 68, 135, 67, 133, 33, 262, 260, 129, 511, 507, 503, 499, 495, 491, 61, 121, 481, 477, 237, 235, 467, 232, 115, 457, 227, 451, 7, 445, 221, 439, 218, 433, 215, 427, 425, 211, 419, 417, 207, 411, 409, 203, 202, 401, 399, 396, 197, 49, 389, 387, 385, 383, 95, 189, 47, 187, 93, 185, 23, 183, 91, 181, 45, 179, 89, 177, 11, 175, 87, 173, 345, 343, 341, 339, 337, 21, 167, 83, 331, 329, 327, 163, 81, 323, 321, 319, 159, 79, 315, 313, 39, 155, 309, 307, 153, 305, 303, 151, 75, 299, 149, 37, 295, 147, 73, 291, 145, 289, 287, 143, 285, 71, 141, 281, 35, 279, 139, 69, 275, 137, 273, 17, 271, 135, 269, 267, 133, 265, 33, 263, 131, 261, 130, 259, 129, 257, 1];\n\n\t/**\n\t * Array of shift values for blur calculations.\n\t * @property SHG_TABLE\n\t * @type Array\n\t * @protected\n\t * @static\n\t **/\n\tBlurFilter.SHG_TABLE = [0, 9, 10, 11, 9, 12, 10, 11, 12, 9, 13, 13, 10, 9, 13, 13, 14, 14, 14, 14, 10, 13, 14, 14, 14, 13, 13, 13, 9, 14, 14, 14, 15, 14, 15, 14, 15, 15, 14, 15, 15, 15, 14, 15, 15, 15, 15, 15, 14, 15, 15, 15, 15, 15, 15, 12, 14, 15, 15, 13, 15, 15, 15, 15, 16, 16, 16, 15, 16, 14, 16, 16, 14, 16, 13, 16, 16, 16, 15, 16, 13, 16, 15, 16, 14, 9, 16, 16, 16, 16, 16, 16, 16, 16, 16, 13, 14, 16, 16, 15, 16, 16, 10, 16, 15, 16, 14, 16, 16, 14, 16, 16, 14, 16, 16, 14, 15, 16, 16, 16, 14, 15, 14, 15, 13, 16, 16, 15, 17, 17, 17, 17, 17, 17, 14, 15, 17, 17, 16, 16, 17, 16, 15, 17, 16, 17, 11, 17, 16, 17, 16, 17, 16, 17, 17, 16, 17, 17, 16, 17, 17, 16, 16, 17, 17, 17, 16, 14, 17, 17, 17, 17, 15, 16, 14, 16, 15, 16, 13, 16, 15, 16, 14, 16, 15, 16, 12, 16, 15, 16, 17, 17, 17, 17, 17, 13, 16, 15, 17, 17, 17, 16, 15, 17, 17, 17, 16, 15, 17, 17, 14, 16, 17, 17, 16, 17, 17, 16, 15, 17, 16, 14, 17, 16, 15, 17, 16, 17, 17, 16, 17, 15, 16, 17, 14, 17, 16, 15, 17, 16, 17, 13, 17, 16, 17, 17, 16, 17, 14, 17, 16, 17, 16, 17, 16, 17, 9];\n\n// public methods:\n\t/** docced in super class **/\n\tp.getBounds = function (rect) {\n\t\tvar x = this.blurX|0, y = this.blurY| 0;\n\t\tif (x <= 0 && y <= 0) { return rect; }\n\t\tvar q = Math.pow(this.quality, 0.2);\n\t\treturn (rect || new createjs.Rectangle()).pad(x*q+1,y*q+1,x*q+1,y*q+1);\n\t};\n\n\t/** docced in super class **/\n\tp.clone = function() {\n\t\treturn new BlurFilter(this.blurX, this.blurY, this.quality);\n\t};\n\n\t/** docced in super class **/\n\tp.toString = function() {\n\t\treturn \"[BlurFilter]\";\n\t};\n\n\n// private methods:\n\n\t/** docced in super class **/\n\tp._applyFilter = function (imageData) {\n\n\t\tvar radiusX = this.blurX >> 1;\n\t\tif (isNaN(radiusX) || radiusX < 0) return false;\n\t\tvar radiusY = this.blurY >> 1;\n\t\tif (isNaN(radiusY) || radiusY < 0) return false;\n\t\tif (radiusX == 0 && radiusY == 0) return false;\n\n\t\tvar iterations = this.quality;\n\t\tif (isNaN(iterations) || iterations < 1) iterations = 1;\n\t\titerations |= 0;\n\t\tif (iterations > 3) iterations = 3;\n\t\tif (iterations < 1) iterations = 1;\n\n\t\tvar px = imageData.data;\n\t\tvar x=0, y=0, i=0, p=0, yp=0, yi=0, yw=0, r=0, g=0, b=0, a=0, pr=0, pg=0, pb=0, pa=0;\n\n\t\tvar divx = (radiusX + radiusX + 1) | 0;\n\t\tvar divy = (radiusY + radiusY + 1) | 0;\n\t\tvar w = imageData.width | 0;\n\t\tvar h = imageData.height | 0;\n\n\t\tvar w1 = (w - 1) | 0;\n\t\tvar h1 = (h - 1) | 0;\n\t\tvar rxp1 = (radiusX + 1) | 0;\n\t\tvar ryp1 = (radiusY + 1) | 0;\n\n\t\tvar ssx = {r:0,b:0,g:0,a:0};\n\t\tvar sx = ssx;\n\t\tfor ( i = 1; i < divx; i++ )\n\t\t{\n\t\t\tsx = sx.n = {r:0,b:0,g:0,a:0};\n\t\t}\n\t\tsx.n = ssx;\n\n\t\tvar ssy = {r:0,b:0,g:0,a:0};\n\t\tvar sy = ssy;\n\t\tfor ( i = 1; i < divy; i++ )\n\t\t{\n\t\t\tsy = sy.n = {r:0,b:0,g:0,a:0};\n\t\t}\n\t\tsy.n = ssy;\n\n\t\tvar si = null;\n\n\n\t\tvar mtx = BlurFilter.MUL_TABLE[radiusX] | 0;\n\t\tvar stx = BlurFilter.SHG_TABLE[radiusX] | 0;\n\t\tvar mty = BlurFilter.MUL_TABLE[radiusY] | 0;\n\t\tvar sty = BlurFilter.SHG_TABLE[radiusY] | 0;\n\n\t\twhile (iterations-- > 0) {\n\n\t\t\tyw = yi = 0;\n\t\t\tvar ms = mtx;\n\t\t\tvar ss = stx;\n\t\t\tfor (y = h; --y > -1;) {\n\t\t\t\tr = rxp1 * (pr = px[(yi) | 0]);\n\t\t\t\tg = rxp1 * (pg = px[(yi + 1) | 0]);\n\t\t\t\tb = rxp1 * (pb = px[(yi + 2) | 0]);\n\t\t\t\ta = rxp1 * (pa = px[(yi + 3) | 0]);\n\n\t\t\t\tsx = ssx;\n\n\t\t\t\tfor( i = rxp1; --i > -1; )\n\t\t\t\t{\n\t\t\t\t\tsx.r = pr;\n\t\t\t\t\tsx.g = pg;\n\t\t\t\t\tsx.b = pb;\n\t\t\t\t\tsx.a = pa;\n\t\t\t\t\tsx = sx.n;\n\t\t\t\t}\n\n\t\t\t\tfor( i = 1; i < rxp1; i++ )\n\t\t\t\t{\n\t\t\t\t\tp = (yi + ((w1 < i ? w1 : i) << 2)) | 0;\n\t\t\t\t\tr += ( sx.r = px[p]);\n\t\t\t\t\tg += ( sx.g = px[p+1]);\n\t\t\t\t\tb += ( sx.b = px[p+2]);\n\t\t\t\t\ta += ( sx.a = px[p+3]);\n\n\t\t\t\t\tsx = sx.n;\n\t\t\t\t}\n\n\t\t\t\tsi = ssx;\n\t\t\t\tfor ( x = 0; x < w; x++ )\n\t\t\t\t{\n\t\t\t\t\tpx[yi++] = (r * ms) >>> ss;\n\t\t\t\t\tpx[yi++] = (g * ms) >>> ss;\n\t\t\t\t\tpx[yi++] = (b * ms) >>> ss;\n\t\t\t\t\tpx[yi++] = (a * ms) >>> ss;\n\n\t\t\t\t\tp = ((yw + ((p = x + radiusX + 1) < w1 ? p : w1)) << 2);\n\n\t\t\t\t\tr -= si.r - ( si.r = px[p]);\n\t\t\t\t\tg -= si.g - ( si.g = px[p+1]);\n\t\t\t\t\tb -= si.b - ( si.b = px[p+2]);\n\t\t\t\t\ta -= si.a - ( si.a = px[p+3]);\n\n\t\t\t\t\tsi = si.n;\n\n\t\t\t\t}\n\t\t\t\tyw += w;\n\t\t\t}\n\n\t\t\tms = mty;\n\t\t\tss = sty;\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\tyi = (x << 2) | 0;\n\n\t\t\t\tr = (ryp1 * (pr = px[yi])) | 0;\n\t\t\t\tg = (ryp1 * (pg = px[(yi + 1) | 0])) | 0;\n\t\t\t\tb = (ryp1 * (pb = px[(yi + 2) | 0])) | 0;\n\t\t\t\ta = (ryp1 * (pa = px[(yi + 3) | 0])) | 0;\n\n\t\t\t\tsy = ssy;\n\t\t\t\tfor( i = 0; i < ryp1; i++ )\n\t\t\t\t{\n\t\t\t\t\tsy.r = pr;\n\t\t\t\t\tsy.g = pg;\n\t\t\t\t\tsy.b = pb;\n\t\t\t\t\tsy.a = pa;\n\t\t\t\t\tsy = sy.n;\n\t\t\t\t}\n\n\t\t\t\typ = w;\n\n\t\t\t\tfor( i = 1; i <= radiusY; i++ )\n\t\t\t\t{\n\t\t\t\t\tyi = ( yp + x ) << 2;\n\n\t\t\t\t\tr += ( sy.r = px[yi]);\n\t\t\t\t\tg += ( sy.g = px[yi+1]);\n\t\t\t\t\tb += ( sy.b = px[yi+2]);\n\t\t\t\t\ta += ( sy.a = px[yi+3]);\n\n\t\t\t\t\tsy = sy.n;\n\n\t\t\t\t\tif( i < h1 )\n\t\t\t\t\t{\n\t\t\t\t\t\typ += w;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tyi = x;\n\t\t\t\tsi = ssy;\n\t\t\t\tif ( iterations > 0 )\n\t\t\t\t{\n\t\t\t\t\tfor ( y = 0; y < h; y++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tp = yi << 2;\n\t\t\t\t\t\tpx[p+3] = pa =(a * ms) >>> ss;\n\t\t\t\t\t\tif ( pa > 0 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpx[p]   = ((r * ms) >>> ss );\n\t\t\t\t\t\t\tpx[p+1] = ((g * ms) >>> ss );\n\t\t\t\t\t\t\tpx[p+2] = ((b * ms) >>> ss );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpx[p] = px[p+1] = px[p+2] = 0\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tp = ( x + (( ( p = y + ryp1) < h1 ? p : h1 ) * w )) << 2;\n\n\t\t\t\t\t\tr -= si.r - ( si.r = px[p]);\n\t\t\t\t\t\tg -= si.g - ( si.g = px[p+1]);\n\t\t\t\t\t\tb -= si.b - ( si.b = px[p+2]);\n\t\t\t\t\t\ta -= si.a - ( si.a = px[p+3]);\n\n\t\t\t\t\t\tsi = si.n;\n\n\t\t\t\t\t\tyi += w;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( y = 0; y < h; y++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tp = yi << 2;\n\t\t\t\t\t\tpx[p+3] = pa =(a * ms) >>> ss;\n\t\t\t\t\t\tif ( pa > 0 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpa = 255 / pa;\n\t\t\t\t\t\t\tpx[p]   = ((r * ms) >>> ss ) * pa;\n\t\t\t\t\t\t\tpx[p+1] = ((g * ms) >>> ss ) * pa;\n\t\t\t\t\t\t\tpx[p+2] = ((b * ms) >>> ss ) * pa;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpx[p] = px[p+1] = px[p+2] = 0\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tp = ( x + (( ( p = y + ryp1) < h1 ? p : h1 ) * w )) << 2;\n\n\t\t\t\t\t\tr -= si.r - ( si.r = px[p]);\n\t\t\t\t\t\tg -= si.g - ( si.g = px[p+1]);\n\t\t\t\t\t\tb -= si.b - ( si.b = px[p+2]);\n\t\t\t\t\t\ta -= si.a - ( si.a = px[p+3]);\n\n\t\t\t\t\t\tsi = si.n;\n\n\t\t\t\t\t\tyi += w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn true;\n\t};\n\n\tcreatejs.BlurFilter = createjs.promote(BlurFilter, \"Filter\");\n}());\n\n//##############################################################################\n// AlphaMapFilter.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\t\n\t\n// constructor:\n\t/**\n\t * Applies a greyscale alpha map image (or canvas) to the target, such that the alpha channel of the result will\n\t * be copied from the red channel of the map, and the RGB channels will be copied from the target.\n\t *\n\t * Generally, it is recommended that you use {{#crossLink \"AlphaMaskFilter\"}}{{/crossLink}}, because it has much\n\t * better performance.\n\t *\n\t * <h4>Example</h4>\n\t * This example draws a red->blue box, caches it, and then uses the cache canvas as an alpha map on a 100x100 image.\n\t *\n\t *       var box = new createjs.Shape();\n\t *       box.graphics.beginLinearGradientFill([\"#ff0000\", \"#0000ff\"], [0, 1], 0, 0, 0, 100)\n\t *       box.graphics.drawRect(0, 0, 100, 100);\n\t *       box.cache(0, 0, 100, 100);\n\t *\n\t *       var bmp = new createjs.Bitmap(\"path/to/image.jpg\");\n\t *       bmp.filters = [\n\t *           new createjs.AlphaMapFilter(box.cacheCanvas)\n\t *       ];\n\t *       bmp.cache(0, 0, 100, 100);\n\t *       stage.addChild(bmp);\n\t *\n\t * See {{#crossLink \"Filter\"}}{{/crossLink}} for more information on applying filters.\n\t * @class AlphaMapFilter\n\t * @extends Filter\n\t * @constructor\n\t * @param {HTMLImageElement|HTMLCanvasElement} alphaMap The greyscale image (or canvas) to use as the alpha value for the\n\t * result. This should be exactly the same dimensions as the target.\n\t **/\n\tfunction AlphaMapFilter(alphaMap) {\n\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * The greyscale image (or canvas) to use as the alpha value for the result. This should be exactly the same\n\t\t * dimensions as the target.\n\t\t * @property alphaMap\n\t\t * @type HTMLImageElement|HTMLCanvasElement\n\t\t **/\n\t\tthis.alphaMap = alphaMap;\n\t\t\n\t\t\n\t// private properties:\n\t\t/**\n\t\t * @property _alphaMap\n\t\t * @protected\n\t\t * @type HTMLImageElement|HTMLCanvasElement\n\t\t **/\n\t\tthis._alphaMap = null;\n\t\t\n\t\t/**\n\t\t * @property _mapData\n\t\t * @protected\n\t\t * @type Uint8ClampedArray\n\t\t **/\n\t\tthis._mapData = null;\n\t}\n\tvar p = createjs.extend(AlphaMapFilter, createjs.Filter);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// public methods:\n\t/** docced in super class **/\n\tp.clone = function () {\n\t\tvar o = new AlphaMapFilter(this.alphaMap);\n\t\to._alphaMap = this._alphaMap;\n\t\to._mapData = this._mapData;\n\t\treturn o;\n\t};\n\n\t/** docced in super class **/\n\tp.toString = function () {\n\t\treturn \"[AlphaMapFilter]\";\n\t};\n\n\n// private methods:\n\t/** docced in super class **/\n\tp._applyFilter = function (imageData) {\n\t\tif (!this.alphaMap) { return true; }\n\t\tif (!this._prepAlphaMap()) { return false; }\n\t\t\n\t\t// TODO: update to support scenarios where the target has different dimensions.\n\t\tvar data = imageData.data;\n\t\tvar map = this._mapData;\n\t\tfor(var i=0, l=data.length; i<l; i += 4) { data[i + 3] = map[i] || 0; }\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t * @method _prepAlphaMap\n\t * @protected\n\t **/\n\tp._prepAlphaMap = function () {\n\t\tif (!this.alphaMap) { return false; }\n\t\tif (this.alphaMap == this._alphaMap && this._mapData) { return true; }\n\n\t\tthis._mapData = null;\n\t\tvar map = this._alphaMap = this.alphaMap;\n\t\tvar canvas = map;\n\t\tvar ctx;\n\t\tif (map instanceof HTMLCanvasElement) {\n\t\t\tctx = canvas.getContext(\"2d\");\n\t\t} else {\n\t\t\tcanvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement(\"canvas\");\n\t\t\tcanvas.width = map.width;\n\t\t\tcanvas.height = map.height;\n\t\t\tctx = canvas.getContext(\"2d\");\n\t\t\tctx.drawImage(map, 0, 0);\n\t\t}\n\n\t\ttry {\n\t\t\tvar imgData = ctx.getImageData(0, 0, map.width, map.height);\n\t\t} catch (e) {\n\t\t\t//if (!this.suppressCrossDomainErrors) throw new Error(\"unable to access local image data: \" + e);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis._mapData = imgData.data;\n\t\treturn true;\n\t};\n\n\n\tcreatejs.AlphaMapFilter = createjs.promote(AlphaMapFilter, \"Filter\");\n}());\n\n//##############################################################################\n// AlphaMaskFilter.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Applies the alpha from the mask image (or canvas) to the target, such that the alpha channel of the result will\n\t * be derived from the mask, and the RGB channels will be copied from the target. This can be used, for example, to\n\t * apply an alpha mask to a display object. This can also be used to combine a JPG compressed RGB image with a PNG32\n\t * alpha mask, which can result in a much smaller file size than a single PNG32 containing ARGB.\n\t *\n\t * <b>IMPORTANT NOTE: This filter currently does not support the targetCtx, or targetX/Y parameters correctly.</b>\n\t *\n\t * <h4>Example</h4>\n\t * This example draws a gradient box, then caches it and uses the \"cacheCanvas\" as the alpha mask on a 100x100 image.\n\t *\n\t *      var box = new createjs.Shape();\n\t *      box.graphics.beginLinearGradientFill([\"#000000\", \"rgba(0, 0, 0, 0)\"], [0, 1], 0, 0, 100, 100)\n\t *      box.graphics.drawRect(0, 0, 100, 100);\n\t *      box.cache(0, 0, 100, 100);\n\t *\n\t *      var bmp = new createjs.Bitmap(\"path/to/image.jpg\");\n\t *      bmp.filters = [\n\t *          new createjs.AlphaMaskFilter(box.cacheCanvas)\n\t *      ];\n\t *      bmp.cache(0, 0, 100, 100);\n\t *\n\t * See {{#crossLink \"Filter\"}}{{/crossLink}} for more information on applying filters.\n\t * @class AlphaMaskFilter\n\t * @extends Filter\n\t * @constructor\n\t * @param {HTMLImageElement|HTMLCanvasElement} mask\n\t **/\n\tfunction AlphaMaskFilter(mask) {\n\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * The image (or canvas) to use as the mask.\n\t\t * @property mask\n\t\t * @type HTMLImageElement|HTMLCanvasElement\n\t\t **/\n\t\tthis.mask = mask;\n\t}\n\tvar p = createjs.extend(AlphaMaskFilter, createjs.Filter);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\t\n\n// public methods:\n\t/**\n\t * Applies the filter to the specified context.\n\t *\n\t * <strong>IMPORTANT NOTE: This filter currently does not support the targetCtx, or targetX/Y parameters\n\t * correctly.</strong>\n\t * @method applyFilter\n\t * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.\n\t * @param {Number} x The x position to use for the source rect.\n\t * @param {Number} y The y position to use for the source rect.\n\t * @param {Number} width The width to use for the source rect.\n\t * @param {Number} height The height to use for the source rect.\n\t * @param {CanvasRenderingContext2D} [targetCtx] NOT SUPPORTED IN THIS FILTER. The 2D context to draw the result to. Defaults to the context passed to ctx.\n\t * @param {Number} [targetX] NOT SUPPORTED IN THIS FILTER. The x position to draw the result to. Defaults to the value passed to x.\n\t * @param {Number} [targetY] NOT SUPPORTED IN THIS FILTER. The y position to draw the result to. Defaults to the value passed to y.\n\t * @return {Boolean} If the filter was applied successfully.\n\t **/\n\tp.applyFilter = function (ctx, x, y, width, height, targetCtx, targetX, targetY) {\n\t\tif (!this.mask) { return true; }\n\t\ttargetCtx = targetCtx || ctx;\n\t\tif (targetX == null) { targetX = x; }\n\t\tif (targetY == null) { targetY = y; }\n\n\t\ttargetCtx.save();\n\t\tif (ctx != targetCtx) {\n\t\t\t// TODO: support targetCtx and targetX/Y\n\t\t\t// clearRect, then draw the ctx in?\n\t\t\treturn false;\n\t\t}\n\n\t\ttargetCtx.globalCompositeOperation = \"destination-in\";\n\t\ttargetCtx.drawImage(this.mask, targetX, targetY);\n\t\ttargetCtx.restore();\n\t\treturn true;\n\t};\n\n\t/** docced in super class **/\n\tp.clone = function () {\n\t\treturn new AlphaMaskFilter(this.mask);\n\t};\n\n\t/** docced in super class **/\n\tp.toString = function () {\n\t\treturn \"[AlphaMaskFilter]\";\n\t};\n\n\n\tcreatejs.AlphaMaskFilter = createjs.promote(AlphaMaskFilter, \"Filter\");\n}());\n\n//##############################################################################\n// ColorFilter.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Applies a color transform to DisplayObjects.\n\t *\n\t * <h4>Example</h4>\n\t * This example draws a red circle, and then transforms it to Blue. This is accomplished by multiplying all the channels\n\t * to 0 (except alpha, which is set to 1), and then adding 255 to the blue channel.\n\t *\n\t *      var shape = new createjs.Shape().set({x:100,y:100});\n\t *      shape.graphics.beginFill(\"#ff0000\").drawCircle(0,0,50);\n\t *\n\t *      shape.filters = [\n\t *          new createjs.ColorFilter(0,0,0,1, 0,0,255,0)\n\t *      ];\n\t *      shape.cache(-50, -50, 100, 100);\n\t *\n\t * See {{#crossLink \"Filter\"}}{{/crossLink}} for an more information on applying filters.\n\t * @class ColorFilter\n\t * @param {Number} [redMultiplier=1] The amount to multiply against the red channel. This is a range between 0 and 1.\n\t * @param {Number} [greenMultiplier=1] The amount to multiply against the green channel. This is a range between 0 and 1.\n\t * @param {Number} [blueMultiplier=1] The amount to multiply against the blue channel. This is a range between 0 and 1.\n\t * @param {Number} [alphaMultiplier=1] The amount to multiply against the alpha channel. This is a range between 0 and 1.\n\t * @param {Number} [redOffset=0] The amount to add to the red channel after it has been multiplied. This is a range\n\t * between -255 and 255.\n\t * @param {Number} [greenOffset=0] The amount to add to the green channel after it has been multiplied. This is a range\n\t  * between -255 and 255.\n\t * @param {Number} [blueOffset=0] The amount to add to the blue channel after it has been multiplied. This is a range\n\t  * between -255 and 255.\n\t * @param {Number} [alphaOffset=0] The amount to add to the alpha channel after it has been multiplied. This is a range\n\t  * between -255 and 255.\n\t * @constructor\n\t * @extends Filter\n\t **/\n\tfunction ColorFilter(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {\n\t\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * Red channel multiplier.\n\t\t * @property redMultiplier\n\t\t * @type Number\n\t\t **/\n\t\tthis.redMultiplier = redMultiplier != null ? redMultiplier : 1;\n\t\n\t\t/**\n\t\t * Green channel multiplier.\n\t\t * @property greenMultiplier\n\t\t * @type Number\n\t\t **/\n\t\tthis.greenMultiplier = greenMultiplier != null ? greenMultiplier : 1;\n\t\n\t\t/**\n\t\t * Blue channel multiplier.\n\t\t * @property blueMultiplier\n\t\t * @type Number\n\t\t **/\n\t\tthis.blueMultiplier = blueMultiplier != null ? blueMultiplier : 1;\n\t\n\t\t/**\n\t\t * Alpha channel multiplier.\n\t\t * @property alphaMultiplier\n\t\t * @type Number\n\t\t **/\n\t\tthis.alphaMultiplier = alphaMultiplier != null ? alphaMultiplier : 1;\n\t\n\t\t/**\n\t\t * Red channel offset (added to value).\n\t\t * @property redOffset\n\t\t * @type Number\n\t\t **/\n\t\tthis.redOffset = redOffset || 0;\n\t\n\t\t/**\n\t\t * Green channel offset (added to value).\n\t\t * @property greenOffset\n\t\t * @type Number\n\t\t **/\n\t\tthis.greenOffset = greenOffset || 0;\n\t\n\t\t/**\n\t\t * Blue channel offset (added to value).\n\t\t * @property blueOffset\n\t\t * @type Number\n\t\t **/\n\t\tthis.blueOffset = blueOffset || 0;\n\t\n\t\t/**\n\t\t * Alpha channel offset (added to value).\n\t\t * @property alphaOffset\n\t\t * @type Number\n\t\t **/\n\t\tthis.alphaOffset = alphaOffset || 0;\n\t}\n\tvar p = createjs.extend(ColorFilter, createjs.Filter);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// public methods:\n\t/** docced in super class **/\n\tp.toString = function() {\n\t\treturn \"[ColorFilter]\";\n\t};\n\n\t/** docced in super class **/\n\tp.clone = function() {\n\t\treturn new ColorFilter(this.redMultiplier, this.greenMultiplier, this.blueMultiplier, this.alphaMultiplier, this.redOffset, this.greenOffset, this.blueOffset, this.alphaOffset);\n\t};\n\t\n\n// private methods:\n\t/** docced in super class **/\n\tp._applyFilter = function(imageData) {\n\t\tvar data = imageData.data;\n\t\tvar l = data.length;\n\t\tfor (var i=0; i<l; i+=4) {\n\t\t\tdata[i] = data[i]*this.redMultiplier+this.redOffset;\n\t\t\tdata[i+1] = data[i+1]*this.greenMultiplier+this.greenOffset;\n\t\t\tdata[i+2] = data[i+2]*this.blueMultiplier+this.blueOffset;\n\t\t\tdata[i+3] = data[i+3]*this.alphaMultiplier+this.alphaOffset;\n\t\t}\n\t\treturn true;\n\t};\n\n\n\tcreatejs.ColorFilter = createjs.promote(ColorFilter, \"Filter\");\n}());\n\n//##############################################################################\n// ColorMatrix.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Provides helper functions for assembling a matrix for use with the {{#crossLink \"ColorMatrixFilter\"}}{{/crossLink}}.\n\t * Most methods return the instance to facilitate chained calls.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      myColorMatrix.adjustHue(20).adjustBrightness(50);\n\t *\n\t * See {{#crossLink \"Filter\"}}{{/crossLink}} for an example of how to apply filters, or {{#crossLink \"ColorMatrixFilter\"}}{{/crossLink}}\n\t * for an example of how to use ColorMatrix to change a DisplayObject's color.\n\t * @class ColorMatrix\n\t * @param {Number} brightness\n\t * @param {Number} contrast\n\t * @param {Number} saturation\n\t * @param {Number} hue\n\t * @constructor\n\t **/\n\tfunction ColorMatrix(brightness, contrast, saturation, hue) {\n\t\tthis.setColor(brightness, contrast, saturation, hue);\n\t}\n\tvar p = ColorMatrix.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// constants:\n\t/**\n\t * Array of delta values for contrast calculations.\n\t * @property DELTA_INDEX\n\t * @type Array\n\t * @protected\n\t * @static\n\t **/\n\tColorMatrix.DELTA_INDEX = [\n\t\t0,    0.01, 0.02, 0.04, 0.05, 0.06, 0.07, 0.08, 0.1,  0.11,\n\t\t0.12, 0.14, 0.15, 0.16, 0.17, 0.18, 0.20, 0.21, 0.22, 0.24,\n\t\t0.25, 0.27, 0.28, 0.30, 0.32, 0.34, 0.36, 0.38, 0.40, 0.42,\n\t\t0.44, 0.46, 0.48, 0.5,  0.53, 0.56, 0.59, 0.62, 0.65, 0.68,\n\t\t0.71, 0.74, 0.77, 0.80, 0.83, 0.86, 0.89, 0.92, 0.95, 0.98,\n\t\t1.0,  1.06, 1.12, 1.18, 1.24, 1.30, 1.36, 1.42, 1.48, 1.54,\n\t\t1.60, 1.66, 1.72, 1.78, 1.84, 1.90, 1.96, 2.0,  2.12, 2.25,\n\t\t2.37, 2.50, 2.62, 2.75, 2.87, 3.0,  3.2,  3.4,  3.6,  3.8,\n\t\t4.0,  4.3,  4.7,  4.9,  5.0,  5.5,  6.0,  6.5,  6.8,  7.0,\n\t\t7.3,  7.5,  7.8,  8.0,  8.4,  8.7,  9.0,  9.4,  9.6,  9.8,\n\t\t10.0\n\t];\n\n\t/**\n\t * Identity matrix values.\n\t * @property IDENTITY_MATRIX\n\t * @type Array\n\t * @protected\n\t * @static\n\t **/\n\tColorMatrix.IDENTITY_MATRIX = [\n\t\t1,0,0,0,0,\n\t\t0,1,0,0,0,\n\t\t0,0,1,0,0,\n\t\t0,0,0,1,0,\n\t\t0,0,0,0,1\n\t];\n\n\t/**\n\t * The constant length of a color matrix.\n\t * @property LENGTH\n\t * @type Number\n\t * @protected\n\t * @static\n\t **/\n\tColorMatrix.LENGTH = ColorMatrix.IDENTITY_MATRIX.length;\n\n\n// public methods:\n\t/**\n\t * Resets the instance with the specified values.\n\t * @method setColor\n\t * @param {Number} brightness\n\t * @param {Number} contrast\n\t * @param {Number} saturation\n\t * @param {Number} hue\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tp.setColor = function(brightness,contrast,saturation,hue) {\n\t\treturn this.reset().adjustColor(brightness,contrast,saturation,hue);\n\t};\n\n\t/**\n\t * Resets the matrix to identity values.\n\t * @method reset\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tp.reset = function() {\n\t\treturn this.copy(ColorMatrix.IDENTITY_MATRIX);\n\t};\n\n\t/**\n\t * Shortcut method to adjust brightness, contrast, saturation and hue.\n\t * Equivalent to calling adjustHue(hue), adjustContrast(contrast),\n\t * adjustBrightness(brightness), adjustSaturation(saturation), in that order.\n\t * @method adjustColor\n\t * @param {Number} brightness\n\t * @param {Number} contrast\n\t * @param {Number} saturation\n\t * @param {Number} hue\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.adjustColor = function(brightness,contrast,saturation,hue) {\n\t\tthis.adjustHue(hue);\n\t\tthis.adjustContrast(contrast);\n\t\tthis.adjustBrightness(brightness);\n\t\treturn this.adjustSaturation(saturation);\n\t};\n\n\t/**\n\t * Adjusts the brightness of pixel color by adding the specified value to the red, green and blue channels.\n\t * Positive values will make the image brighter, negative values will make it darker.\n\t * @method adjustBrightness\n\t * @param {Number} value A value between -255 & 255 that will be added to the RGB channels.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.adjustBrightness = function(value) {\n\t\tif (value == 0 || isNaN(value)) { return this; }\n\t\tvalue = this._cleanValue(value,255);\n\t\tthis._multiplyMatrix([\n\t\t\t1,0,0,0,value,\n\t\t\t0,1,0,0,value,\n\t\t\t0,0,1,0,value,\n\t\t\t0,0,0,1,0,\n\t\t\t0,0,0,0,1\n\t\t]);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Adjusts the contrast of pixel color.\n\t * Positive values will increase contrast, negative values will decrease contrast.\n\t * @method adjustContrast\n\t * @param {Number} value A value between -100 & 100.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.adjustContrast = function(value) {\n\t\tif (value == 0 || isNaN(value)) { return this; }\n\t\tvalue = this._cleanValue(value,100);\n\t\tvar x;\n\t\tif (value<0) {\n\t\t\tx = 127+value/100*127;\n\t\t} else {\n\t\t\tx = value%1;\n\t\t\tif (x == 0) {\n\t\t\t\tx = ColorMatrix.DELTA_INDEX[value];\n\t\t\t} else {\n\t\t\t\tx = ColorMatrix.DELTA_INDEX[(value<<0)]*(1-x)+ColorMatrix.DELTA_INDEX[(value<<0)+1]*x; // use linear interpolation for more granularity.\n\t\t\t}\n\t\t\tx = x*127+127;\n\t\t}\n\t\tthis._multiplyMatrix([\n\t\t\tx/127,0,0,0,0.5*(127-x),\n\t\t\t0,x/127,0,0,0.5*(127-x),\n\t\t\t0,0,x/127,0,0.5*(127-x),\n\t\t\t0,0,0,1,0,\n\t\t\t0,0,0,0,1\n\t\t]);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Adjusts the color saturation of the pixel.\n\t * Positive values will increase saturation, negative values will decrease saturation (trend towards greyscale).\n\t * @method adjustSaturation\n\t * @param {Number} value A value between -100 & 100.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.adjustSaturation = function(value) {\n\t\tif (value == 0 || isNaN(value)) { return this; }\n\t\tvalue = this._cleanValue(value,100);\n\t\tvar x = 1+((value > 0) ? 3*value/100 : value/100);\n\t\tvar lumR = 0.3086;\n\t\tvar lumG = 0.6094;\n\t\tvar lumB = 0.0820;\n\t\tthis._multiplyMatrix([\n\t\t\tlumR*(1-x)+x,lumG*(1-x),lumB*(1-x),0,0,\n\t\t\tlumR*(1-x),lumG*(1-x)+x,lumB*(1-x),0,0,\n\t\t\tlumR*(1-x),lumG*(1-x),lumB*(1-x)+x,0,0,\n\t\t\t0,0,0,1,0,\n\t\t\t0,0,0,0,1\n\t\t]);\n\t\treturn this;\n\t};\n\n\n\t/**\n\t * Adjusts the hue of the pixel color.\n\t * @method adjustHue\n\t * @param {Number} value A value between -180 & 180.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.adjustHue = function(value) {\n\t\tif (value == 0 || isNaN(value)) { return this; }\n\t\tvalue = this._cleanValue(value,180)/180*Math.PI;\n\t\tvar cosVal = Math.cos(value);\n\t\tvar sinVal = Math.sin(value);\n\t\tvar lumR = 0.213;\n\t\tvar lumG = 0.715;\n\t\tvar lumB = 0.072;\n\t\tthis._multiplyMatrix([\n\t\t\tlumR+cosVal*(1-lumR)+sinVal*(-lumR),lumG+cosVal*(-lumG)+sinVal*(-lumG),lumB+cosVal*(-lumB)+sinVal*(1-lumB),0,0,\n\t\t\tlumR+cosVal*(-lumR)+sinVal*(0.143),lumG+cosVal*(1-lumG)+sinVal*(0.140),lumB+cosVal*(-lumB)+sinVal*(-0.283),0,0,\n\t\t\tlumR+cosVal*(-lumR)+sinVal*(-(1-lumR)),lumG+cosVal*(-lumG)+sinVal*(lumG),lumB+cosVal*(1-lumB)+sinVal*(lumB),0,0,\n\t\t\t0,0,0,1,0,\n\t\t\t0,0,0,0,1\n\t\t]);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Concatenates (multiplies) the specified matrix with this one.\n\t * @method concat\n\t * @param {Array} matrix An array or ColorMatrix instance.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.concat = function(matrix) {\n\t\tmatrix = this._fixMatrix(matrix);\n\t\tif (matrix.length != ColorMatrix.LENGTH) { return this; }\n\t\tthis._multiplyMatrix(matrix);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Returns a clone of this ColorMatrix.\n\t * @method clone\n\t * @return {ColorMatrix} A clone of this ColorMatrix.\n\t **/\n\tp.clone = function() {\n\t\treturn (new ColorMatrix()).copy(this);\n\t};\n\n\t/**\n\t * Return a length 25 (5x5) array instance containing this matrix's values.\n\t * @method toArray\n\t * @return {Array} An array holding this matrix's values.\n\t **/\n\tp.toArray = function() {\n\t\tvar arr = [];\n\t\tfor (var i= 0, l=ColorMatrix.LENGTH; i<l; i++) {\n\t\t\tarr[i] = this[i];\n\t\t}\n\t\treturn arr;\n\t};\n\n\t/**\n\t * Copy the specified matrix's values to this matrix.\n\t * @method copy\n\t * @param {Array} matrix An array or ColorMatrix instance.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.copy = function(matrix) {\n\t\tvar l = ColorMatrix.LENGTH;\n\t\tfor (var i=0;i<l;i++) {\n\t\t\tthis[i] = matrix[i];\n\t\t}\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[ColorMatrix]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _multiplyMatrix\n\t * @param {Array} matrix\n\t * @protected\n\t **/\n\tp._multiplyMatrix = function(matrix) {\n\t\tvar i, j, k, col = [];\n\n\t\tfor (i=0;i<5;i++) {\n\t\t\tfor (j=0;j<5;j++) {\n\t\t\t\tcol[j] = this[j+i*5];\n\t\t\t}\n\t\t\tfor (j=0;j<5;j++) {\n\t\t\t\tvar val=0;\n\t\t\t\tfor (k=0;k<5;k++) {\n\t\t\t\t\tval += matrix[j+k*5]*col[k];\n\t\t\t\t}\n\t\t\t\tthis[j+i*5] = val;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Make sure values are within the specified range, hue has a limit of 180, brightness is 255, others are 100.\n\t * @method _cleanValue\n\t * @param {Number} value The raw number\n\t * @param {Number} limit The maximum that the number can be. The minimum is the limit * -1.\n\t * @protected\n\t **/\n\tp._cleanValue = function(value, limit) {\n\t\treturn Math.min(limit,Math.max(-limit,value));\n\t};\n\n\t/**\n\t * Makes sure matrixes are 5x5 (25 long).\n\t * @method _fixMatrix\n\t * @param {Array} matrix\n\t * @protected\n\t **/\n\tp._fixMatrix = function(matrix) {\n\t\tif (matrix instanceof ColorMatrix) { matrix = matrix.toArray(); }\n\t\tif (matrix.length < ColorMatrix.LENGTH) {\n\t\t\tmatrix = matrix.slice(0,matrix.length).concat(ColorMatrix.IDENTITY_MATRIX.slice(matrix.length,ColorMatrix.LENGTH));\n\t\t} else if (matrix.length > ColorMatrix.LENGTH) {\n\t\t\tmatrix = matrix.slice(0,ColorMatrix.LENGTH);\n\t\t}\n\t\treturn matrix;\n\t};\n\n\n\tcreatejs.ColorMatrix = ColorMatrix;\n}());\n\n//##############################################################################\n// ColorMatrixFilter.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Allows you to carry out complex color operations such as modifying saturation, brightness, or inverting. See the\n\t * {{#crossLink \"ColorMatrix\"}}{{/crossLink}} for more information on changing colors. For an easier color transform,\n\t * consider the {{#crossLink \"ColorFilter\"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t * This example creates a red circle, inverts its hue, and then saturates it to brighten it up.\n\t *\n\t *      var shape = new createjs.Shape().set({x:100,y:100});\n\t *      shape.graphics.beginFill(\"#ff0000\").drawCircle(0,0,50);\n\t *\n\t *      var matrix = new createjs.ColorMatrix().adjustHue(180).adjustSaturation(100);\n\t *      shape.filters = [\n\t *          new createjs.ColorMatrixFilter(matrix)\n\t *      ];\n\t *\n\t *      shape.cache(-50, -50, 100, 100);\n\t *\n\t * See {{#crossLink \"Filter\"}}{{/crossLink}} for an more information on applying filters.\n\t * @class ColorMatrixFilter\n\t * @constructor\n\t * @extends Filter\n\t * @param {Array | ColorMatrix} matrix A 4x5 matrix describing the color operation to perform. See also the {{#crossLink \"ColorMatrix\"}}{{/crossLink}}\n\t * class.\n\t **/\n\tfunction ColorMatrixFilter(matrix) {\n\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * A 4x5 matrix describing the color operation to perform. See also the {{#crossLink \"ColorMatrix\"}}{{/crossLink}}\n\t\t * @property matrix\n\t\t * @type Array | ColorMatrix\n\t\t **/\n\t\tthis.matrix = matrix;\n\t}\n\tvar p = createjs.extend(ColorMatrixFilter, createjs.Filter);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\t\n\n// public methods:\n\t/** docced in super class **/\n\tp.toString = function() {\n\t\treturn \"[ColorMatrixFilter]\";\n\t};\n\n\t/** docced in super class **/\n\tp.clone = function() {\n\t\treturn new ColorMatrixFilter(this.matrix);\n\t};\n\n// private methods:\n\t/** docced in super class **/\n\tp._applyFilter = function(imageData) { \n\t\tvar data = imageData.data;\n\t\tvar l = data.length;\n\t\tvar r,g,b,a;\n\t\tvar mtx = this.matrix;\n\t\tvar m0 =  mtx[0],  m1 =  mtx[1],  m2 =  mtx[2],  m3 =  mtx[3],  m4 =  mtx[4];\n\t\tvar m5 =  mtx[5],  m6 =  mtx[6],  m7 =  mtx[7],  m8 =  mtx[8],  m9 =  mtx[9];\n\t\tvar m10 = mtx[10], m11 = mtx[11], m12 = mtx[12], m13 = mtx[13], m14 = mtx[14];\n\t\tvar m15 = mtx[15], m16 = mtx[16], m17 = mtx[17], m18 = mtx[18], m19 = mtx[19];\n\n\t\tfor (var i=0; i<l; i+=4) {\n\t\t\tr = data[i];\n\t\t\tg = data[i+1];\n\t\t\tb = data[i+2];\n\t\t\ta = data[i+3];\n\t\t\tdata[i] = r*m0+g*m1+b*m2+a*m3+m4; // red\n\t\t\tdata[i+1] = r*m5+g*m6+b*m7+a*m8+m9; // green\n\t\t\tdata[i+2] = r*m10+g*m11+b*m12+a*m13+m14; // blue\n\t\t\tdata[i+3] = r*m15+g*m16+b*m17+a*m18+m19; // alpha\n\t\t}\n\t\treturn true;\n\t};\n\n\n\tcreatejs.ColorMatrixFilter = createjs.promote(ColorMatrixFilter, \"Filter\");\n}());\n\n//##############################################################################\n// Touch.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n * Global utility for working with multi-touch enabled devices in EaselJS. Currently supports W3C Touch API (iOS and\n * modern Android browser) and the Pointer API (IE), including ms-prefixed events in IE10, and unprefixed in IE11.\n *\n * Ensure that you {{#crossLink \"Touch/disable\"}}{{/crossLink}} touch when cleaning up your application. You do not have\n * to check if touch is supported to enable it, as it will fail gracefully if it is not supported.\n *\n * <h4>Example</h4>\n *\n *      var stage = new createjs.Stage(\"canvasId\");\n *      createjs.Touch.enable(stage);\n *\n * <strong>Note:</strong> It is important to disable Touch on a stage that you are no longer using:\n *\n *      createjs.Touch.disable(stage);\n *\n * @class Touch\n * @static\n **/\n\tfunction Touch() {\n\t\tthrow \"Touch cannot be instantiated\";\n\t}\n\n\n// public static methods:\n\t/**\n\t * Returns `true` if touch is supported in the current browser.\n\t * @method isSupported\n\t * @return {Boolean} Indicates whether touch is supported in the current browser.\n\t * @static\n\t **/\n\tTouch.isSupported = function() {\n\t\treturn\t!!(('ontouchstart' in window) // iOS & Android\n\t\t\t|| (window.navigator['msPointerEnabled'] && window.navigator['msMaxTouchPoints'] > 0) // IE10\n\t\t\t|| (window.navigator['pointerEnabled'] && window.navigator['maxTouchPoints'] > 0)); // IE11+\n\t};\n\n\t/**\n\t * Enables touch interaction for the specified EaselJS {{#crossLink \"Stage\"}}{{/crossLink}}. Currently supports iOS\n\t * (and compatible browsers, such as modern Android browsers), and IE10/11. Supports both single touch and\n\t * multi-touch modes. Extends the EaselJS {{#crossLink \"MouseEvent\"}}{{/crossLink}} model, but without support for\n\t * double click or over/out events. See the MouseEvent {{#crossLink \"MouseEvent/pointerId:property\"}}{{/crossLink}}\n\t * for more information.\n\t * @method enable\n\t * @param {Stage} stage The {{#crossLink \"Stage\"}}{{/crossLink}} to enable touch on.\n\t * @param {Boolean} [singleTouch=false] If `true`, only a single touch will be active at a time.\n\t * @param {Boolean} [allowDefault=false] If `true`, then default gesture actions (ex. scrolling, zooming) will be\n\t * allowed when the user is interacting with the target canvas.\n\t * @return {Boolean} Returns `true` if touch was successfully enabled on the target stage.\n\t * @static\n\t **/\n\tTouch.enable = function(stage, singleTouch, allowDefault) {\n\t\tif (!stage || !stage.canvas || !Touch.isSupported()) { return false; }\n\t\tif (stage.__touch) { return true; }\n\n\t\t// inject required properties on stage:\n\t\tstage.__touch = {pointers:{}, multitouch:!singleTouch, preventDefault:!allowDefault, count:0};\n\n\t\t// note that in the future we may need to disable the standard mouse event model before adding\n\t\t// these to prevent duplicate calls. It doesn't seem to be an issue with iOS devices though.\n\t\tif ('ontouchstart' in window) { Touch._IOS_enable(stage); }\n\t\telse if (window.navigator['msPointerEnabled'] || window.navigator[\"pointerEnabled\"]) { Touch._IE_enable(stage); }\n\t\treturn true;\n\t};\n\n\t/**\n\t * Removes all listeners that were set up when calling `Touch.enable()` on a stage.\n\t * @method disable\n\t * @param {Stage} stage The {{#crossLink \"Stage\"}}{{/crossLink}} to disable touch on.\n\t * @static\n\t **/\n\tTouch.disable = function(stage) {\n\t\tif (!stage) { return; }\n\t\tif ('ontouchstart' in window) { Touch._IOS_disable(stage); }\n\t\telse if (window.navigator['msPointerEnabled'] || window.navigator[\"pointerEnabled\"]) { Touch._IE_disable(stage); }\n\t\t\n\t\tdelete stage.__touch;\n\t};\n\n\n// Private static methods:\n\t/**\n\t * @method _IOS_enable\n\t * @protected\n\t * @param {Stage} stage\n\t * @static\n\t **/\n\tTouch._IOS_enable = function(stage) {\n\t\tvar canvas = stage.canvas;\n\t\tvar f = stage.__touch.f = function(e) { Touch._IOS_handleEvent(stage,e); };\n\t\tcanvas.addEventListener(\"touchstart\", f, false);\n\t\tcanvas.addEventListener(\"touchmove\", f, false);\n\t\tcanvas.addEventListener(\"touchend\", f, false);\n\t\tcanvas.addEventListener(\"touchcancel\", f, false);\n\t};\n\n\t/**\n\t * @method _IOS_disable\n\t * @protected\n\t * @param {Stage} stage\n\t * @static\n\t **/\n\tTouch._IOS_disable = function(stage) {\n\t\tvar canvas = stage.canvas;\n\t\tif (!canvas) { return; }\n\t\tvar f = stage.__touch.f;\n\t\tcanvas.removeEventListener(\"touchstart\", f, false);\n\t\tcanvas.removeEventListener(\"touchmove\", f, false);\n\t\tcanvas.removeEventListener(\"touchend\", f, false);\n\t\tcanvas.removeEventListener(\"touchcancel\", f, false);\n\t};\n\n\t/**\n\t * @method _IOS_handleEvent\n\t * @param {Stage} stage\n\t * @param {Object} e The event to handle\n\t * @protected\n\t * @static\n\t **/\n\tTouch._IOS_handleEvent = function(stage, e) {\n\t\tif (!stage) { return; }\n\t\tif (stage.__touch.preventDefault) { e.preventDefault&&e.preventDefault(); }\n\t\tvar touches = e.changedTouches;\n\t\tvar type = e.type;\n\t\tfor (var i= 0,l=touches.length; i<l; i++) {\n\t\t\tvar touch = touches[i];\n\t\t\tvar id = touch.identifier;\n\t\t\tif (touch.target != stage.canvas) { continue; }\n\n\t\t\tif (type == \"touchstart\") {\n\t\t\t\tthis._handleStart(stage, id, e, touch.pageX, touch.pageY);\n\t\t\t} else if (type == \"touchmove\") {\n\t\t\t\tthis._handleMove(stage, id, e, touch.pageX, touch.pageY);\n\t\t\t} else if (type == \"touchend\" || type == \"touchcancel\") {\n\t\t\t\tthis._handleEnd(stage, id, e);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _IE_enable\n\t * @protected\n\t * @param {Stage} stage\n\t * @static\n\t **/\n\tTouch._IE_enable = function(stage) {\n\t\tvar canvas = stage.canvas;\n\t\tvar f = stage.__touch.f = function(e) { Touch._IE_handleEvent(stage,e); };\n\n\t\tif (window.navigator[\"pointerEnabled\"] === undefined) {\n\t\t\tcanvas.addEventListener(\"MSPointerDown\", f, false);\n\t\t\twindow.addEventListener(\"MSPointerMove\", f, false);\n\t\t\twindow.addEventListener(\"MSPointerUp\", f, false);\n\t\t\twindow.addEventListener(\"MSPointerCancel\", f, false);\n\t\t\tif (stage.__touch.preventDefault) { canvas.style.msTouchAction = \"none\"; }\n\t\t} else {\n\t\t\tcanvas.addEventListener(\"pointerdown\", f, false);\n\t\t\twindow.addEventListener(\"pointermove\", f, false);\n\t\t\twindow.addEventListener(\"pointerup\", f, false);\n\t\t\twindow.addEventListener(\"pointercancel\", f, false);\n\t\t\tif (stage.__touch.preventDefault) { canvas.style.touchAction = \"none\"; }\n\n\t\t}\n\t\tstage.__touch.activeIDs = {};\n\t};\n\n\t/**\n\t * @method _IE_disable\n\t * @protected\n\t * @param {Stage} stage\n\t * @static\n\t **/\n\tTouch._IE_disable = function(stage) {\n\t\tvar f = stage.__touch.f;\n\n\t\tif (window.navigator[\"pointerEnabled\"] === undefined) {\n\t\t\twindow.removeEventListener(\"MSPointerMove\", f, false);\n\t\t\twindow.removeEventListener(\"MSPointerUp\", f, false);\n\t\t\twindow.removeEventListener(\"MSPointerCancel\", f, false);\n\t\t\tif (stage.canvas) {\n\t\t\t\tstage.canvas.removeEventListener(\"MSPointerDown\", f, false);\n\t\t\t}\n\t\t} else {\n\t\t\twindow.removeEventListener(\"pointermove\", f, false);\n\t\t\twindow.removeEventListener(\"pointerup\", f, false);\n\t\t\twindow.removeEventListener(\"pointercancel\", f, false);\n\t\t\tif (stage.canvas) {\n\t\t\t\tstage.canvas.removeEventListener(\"pointerdown\", f, false);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _IE_handleEvent\n\t * @param {Stage} stage\n\t * @param {Object} e The event to handle.\n\t * @protected\n\t * @static\n\t **/\n\tTouch._IE_handleEvent = function(stage, e) {\n\t\tif (!stage) { return; }\n\t\tif (stage.__touch.preventDefault) { e.preventDefault && e.preventDefault(); }\n\t\tvar type = e.type;\n\t\tvar id = e.pointerId;\n\t\tvar ids = stage.__touch.activeIDs;\n\n\t\tif (type == \"MSPointerDown\" || type == \"pointerdown\") {\n\t\t\tif (e.srcElement != stage.canvas) { return; }\n\t\t\tids[id] = true;\n\t\t\tthis._handleStart(stage, id, e, e.pageX, e.pageY);\n\t\t} else if (ids[id]) { // it's an id we're watching\n\t\t\tif (type == \"MSPointerMove\" || type == \"pointermove\") {\n\t\t\t\tthis._handleMove(stage, id, e, e.pageX, e.pageY);\n\t\t\t} else if (type == \"MSPointerUp\" || type == \"MSPointerCancel\"\n\t\t\t\t\t|| type == \"pointerup\" || type == \"pointercancel\") {\n\t\t\t\tdelete(ids[id]);\n\t\t\t\tthis._handleEnd(stage, id, e);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _handleStart\n\t * @param {Stage} stage\n\t * @param {String|Number} id\n\t * @param {Object} e\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @protected\n\t **/\n\tTouch._handleStart = function(stage, id, e, x, y) {\n\t\tvar props = stage.__touch;\n\t\tif (!props.multitouch && props.count) { return; }\n\t\tvar ids = props.pointers;\n\t\tif (ids[id]) { return; }\n\t\tids[id] = true;\n\t\tprops.count++;\n\t\tstage._handlePointerDown(id, e, x, y);\n\t};\n\n\t/**\n\t * @method _handleMove\n\t * @param {Stage} stage\n\t * @param {String|Number} id\n\t * @param {Object} e\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @protected\n\t **/\n\tTouch._handleMove = function(stage, id, e, x, y) {\n\t\tif (!stage.__touch.pointers[id]) { return; }\n\t\tstage._handlePointerMove(id, e, x, y);\n\t};\n\n\t/**\n\t * @method _handleEnd\n\t * @param {Stage} stage\n\t * @param {String|Number} id\n\t * @param {Object} e\n\t * @protected\n\t **/\n\tTouch._handleEnd = function(stage, id, e) {\n\t\t// TODO: cancel should be handled differently for proper UI (ex. an up would trigger a click, a cancel would more closely resemble an out).\n\t\tvar props = stage.__touch;\n\t\tvar ids = props.pointers;\n\t\tif (!ids[id]) { return; }\n\t\tprops.count--;\n\t\tstage._handlePointerUp(id, e, true);\n\t\tdelete(ids[id]);\n\t};\n\n\n\tcreatejs.Touch = Touch;\n}());\n\n//##############################################################################\n// version.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * Static class holding library specific information such as the version and buildDate of\n\t * the library.\n\t * @class EaselJS\n\t **/\n\tvar s = createjs.EaselJS = createjs.EaselJS || {};\n\n\t/**\n\t * The version string for this release.\n\t * @property version\n\t * @type String\n\t * @static\n\t **/\n\ts.version = /*=version*/\"0.8.2\"; // injected by build process\n\n\t/**\n\t * The build date for this release in UTC format.\n\t * @property buildDate\n\t * @type String\n\t * @static\n\t **/\n\ts.buildDate = /*=date*/\"Thu, 26 Nov 2015 20:44:34 GMT\"; // injected by build process\n\n})();\n\n//##############################################################################\n// version.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * Static class holding library specific information such as the version and buildDate of the library.\n\t * @class PreloadJS\n\t **/\n\tvar s = createjs.PreloadJS = createjs.PreloadJS || {};\n\n\t/**\n\t * The version string for this release.\n\t * @property version\n\t * @type {String}\n\t * @static\n\t **/\n\ts.version = /*=version*/\"0.6.2\"; // injected by build process\n\n\t/**\n\t * The build date for this release in UTC format.\n\t * @property buildDate\n\t * @type {String}\n\t * @static\n\t **/\n\ts.buildDate = /*=date*/\"Thu, 26 Nov 2015 20:44:31 GMT\"; // injected by build process\n\n})();\n\n//##############################################################################\n// proxy.js\n//##############################################################################\n\n/**\n * Various utilities that the CreateJS Suite uses. Utilities are created as separate files, and will be available on the\n * createjs namespace directly.\n *\n * <h4>Example</h4>\n *\n *      myObject.addEventListener(\"change\", createjs.proxy(myMethod, scope));\n *\n * @class Utility Methods\n * @main Utility Methods\n */\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * A function proxy for methods. By default, JavaScript methods do not maintain scope, so passing a method as a\n\t * callback will result in the method getting called in the scope of the caller. Using a proxy ensures that the\n\t * method gets called in the correct scope.\n\t *\n\t * Additional arguments can be passed that will be applied to the function when it is called.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      myObject.addEventListener(\"event\", createjs.proxy(myHandler, this, arg1, arg2));\n\t *\n\t *      function myHandler(arg1, arg2) {\n\t *           // This gets called when myObject.myCallback is executed.\n\t *      }\n\t *\n\t * @method proxy\n\t * @param {Function} method The function to call\n\t * @param {Object} scope The scope to call the method name on\n\t * @param {mixed} [arg] * Arguments that are appended to the callback for additional params.\n\t * @public\n\t * @static\n\t */\n\tcreatejs.proxy = function (method, scope) {\n\t\tvar aArgs = Array.prototype.slice.call(arguments, 2);\n\t\treturn function () {\n\t\t\treturn method.apply(scope, Array.prototype.slice.call(arguments, 0).concat(aArgs));\n\t\t};\n\t}\n\n}());\n\n//##############################################################################\n// ErrorEvent.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * A general error {{#crossLink \"Event\"}}{{/crossLink}}, that describes an error that occurred, as well as any details.\n\t * @class ErrorEvent\n\t * @param {String} [title] The error title\n\t * @param {String} [message] The error description\n\t * @param {Object} [data] Additional error data\n\t * @constructor\n\t */\n\tfunction ErrorEvent(title, message, data) {\n\t\tthis.Event_constructor(\"error\");\n\n\t\t/**\n\t\t * The short error title, which indicates the type of error that occurred.\n\t\t * @property title\n\t\t * @type String\n\t\t */\n\t\tthis.title = title;\n\n\t\t/**\n\t\t * The verbose error message, containing details about the error.\n\t\t * @property message\n\t\t * @type String\n\t\t */\n\t\tthis.message = message;\n\n\t\t/**\n\t\t * Additional data attached to an error.\n\t\t * @property data\n\t\t * @type {Object}\n\t\t */\n\t\tthis.data = data;\n\t}\n\n\tvar p = createjs.extend(ErrorEvent, createjs.Event);\n\n\tp.clone = function() {\n\t\treturn new createjs.ErrorEvent(this.title, this.message, this.data);\n\t};\n\n\tcreatejs.ErrorEvent = createjs.promote(ErrorEvent, \"Event\");\n\n}());\n\n//##############################################################################\n// ProgressEvent.js\n//##############################################################################\n\n(function (scope) {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A CreateJS {{#crossLink \"Event\"}}{{/crossLink}} that is dispatched when progress changes.\n\t * @class ProgressEvent\n\t * @param {Number} loaded The amount that has been loaded. This can be any number relative to the total.\n\t * @param {Number} [total=1] The total amount that will load. This will default to 1, so if the `loaded` value is\n\t * a percentage (between 0 and 1), it can be omitted.\n\t * @todo Consider having this event be a \"fileprogress\" event as well\n\t * @constructor\n\t */\n\tfunction ProgressEvent(loaded, total) {\n\t\tthis.Event_constructor(\"progress\");\n\n\t\t/**\n\t\t * The amount that has been loaded (out of a total amount)\n\t\t * @property loaded\n\t\t * @type {Number}\n\t\t */\n\t\tthis.loaded = loaded;\n\n\t\t/**\n\t\t * The total \"size\" of the load.\n\t\t * @property total\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.total = (total == null) ? 1 : total;\n\n\t\t/**\n\t\t * The percentage (out of 1) that the load has been completed. This is calculated using `loaded/total`.\n\t\t * @property progress\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.progress = (total == 0) ? 0 : this.loaded / this.total;\n\t};\n\n\tvar p = createjs.extend(ProgressEvent, createjs.Event);\n\n\t/**\n\t * Returns a clone of the ProgressEvent instance.\n\t * @method clone\n\t * @return {ProgressEvent} a clone of the Event instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new createjs.ProgressEvent(this.loaded, this.total);\n\t};\n\n\tcreatejs.ProgressEvent = createjs.promote(ProgressEvent, \"Event\");\n\n}(window));\n\n//##############################################################################\n// json3.js\n//##############################################################################\n\n/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */\n;(function () {\n  // Detect the `define` function exposed by asynchronous module loaders. The\n  // strict `define` check is necessary for compatibility with `r.js`.\n  var isLoader =  true && __webpack_require__(/*! !webpack amd options */ \"PDX0\");\n\n  // A set of types used to distinguish objects from primitives.\n  var objectTypes = {\n    \"function\": true,\n    \"object\": true\n  };\n\n  // Detect the `exports` object exposed by CommonJS implementations.\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n  // Use the `global` object exposed by Node (including Browserify via\n  // `insert-module-globals`), Narwhal, and Ringo as the default context,\n  // and the `window` object in browsers. Rhino exports a `global` function\n  // instead.\n  var root = objectTypes[typeof window] && window || this,\n      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == \"object\" && global;\n\n  if (freeGlobal && (freeGlobal[\"global\"] === freeGlobal || freeGlobal[\"window\"] === freeGlobal || freeGlobal[\"self\"] === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  // Public: Initializes JSON 3 using the given `context` object, attaching the\n  // `stringify` and `parse` functions to the specified `exports` object.\n  function runInContext(context, exports) {\n    context || (context = root[\"Object\"]());\n    exports || (exports = root[\"Object\"]());\n\n    // Native constructor aliases.\n    var Number = context[\"Number\"] || root[\"Number\"],\n        String = context[\"String\"] || root[\"String\"],\n        Object = context[\"Object\"] || root[\"Object\"],\n        Date = context[\"Date\"] || root[\"Date\"],\n        SyntaxError = context[\"SyntaxError\"] || root[\"SyntaxError\"],\n        TypeError = context[\"TypeError\"] || root[\"TypeError\"],\n        Math = context[\"Math\"] || root[\"Math\"],\n        nativeJSON = context[\"JSON\"] || root[\"JSON\"];\n\n    // Delegate to the native `stringify` and `parse` implementations.\n    if (typeof nativeJSON == \"object\" && nativeJSON) {\n      exports.stringify = nativeJSON.stringify;\n      exports.parse = nativeJSON.parse;\n    }\n\n    // Convenience aliases.\n    var objectProto = Object.prototype,\n        getClass = objectProto.toString,\n        isProperty, forEach, undef;\n\n    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\n    var isExtended = new Date(-3509827334573292);\n    try {\n      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\n      // results for certain dates in Opera >= 10.53.\n      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\n        // Safari < 2.0.2 stores the internal millisecond time value correctly,\n        // but clips the values returned by the date methods to the range of\n        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\n        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\n    } catch (exception) {}\n\n    // Internal: Determines whether the native `JSON.stringify` and `parse`\n    // implementations are spec-compliant. Based on work by Ken Snyder.\n    function has(name) {\n      if (has[name] !== undef) {\n        // Return cached feature test result.\n        return has[name];\n      }\n      var isSupported;\n      if (name == \"bug-string-char-index\") {\n        // IE <= 7 doesn't support accessing string characters using square\n        // bracket notation. IE 8 only supports this for primitives.\n        isSupported = \"a\"[0] != \"a\";\n      } else if (name == \"json\") {\n        // Indicates whether both `JSON.stringify` and `JSON.parse` are\n        // supported.\n        isSupported = has(\"json-stringify\") && has(\"json-parse\");\n      } else {\n        var value, serialized = '{\"a\":[1,true,false,null,\"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t\"]}';\n        // Test `JSON.stringify`.\n        if (name == \"json-stringify\") {\n          var stringify = exports.stringify, stringifySupported = typeof stringify == \"function\" && isExtended;\n          if (stringifySupported) {\n            // A test function object with a custom `toJSON` method.\n            (value = function () {\n              return 1;\n            }).toJSON = value;\n            try {\n              stringifySupported =\n                // Firefox 3.1b1 and b2 serialize string, number, and boolean\n                // primitives as object literals.\n                stringify(0) === \"0\" &&\n                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\n                // literals.\n                stringify(new Number()) === \"0\" &&\n                stringify(new String()) == '\"\"' &&\n                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\n                // does not define a canonical JSON representation (this applies to\n                // objects with `toJSON` properties as well, *unless* they are nested\n                // within an object or array).\n                stringify(getClass) === undef &&\n                // IE 8 serializes `undefined` as `\"undefined\"`. Safari <= 5.1.7 and\n                // FF 3.1b3 pass this test.\n                stringify(undef) === undef &&\n                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\n                // respectively, if the value is omitted entirely.\n                stringify() === undef &&\n                // FF 3.1b1, 2 throw an error if the given value is not a number,\n                // string, array, object, Boolean, or `null` literal. This applies to\n                // objects with custom `toJSON` methods as well, unless they are nested\n                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\n                // methods entirely.\n                stringify(value) === \"1\" &&\n                stringify([value]) == \"[1]\" &&\n                // Prototype <= 1.6.1 serializes `[undefined]` as `\"[]\"` instead of\n                // `\"[null]\"`.\n                stringify([undef]) == \"[null]\" &&\n                // YUI 3.0.0b1 fails to serialize `null` literals.\n                stringify(null) == \"null\" &&\n                // FF 3.1b1, 2 halts serialization if an array contains a function:\n                // `[1, true, getClass, 1]` serializes as \"[1,true,],\". FF 3.1b3\n                // elides non-JSON values from objects and arrays, unless they\n                // define custom `toJSON` methods.\n                stringify([undef, getClass, null]) == \"[null,null,null]\" &&\n                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\n                // where character escape codes are expected (e.g., `\\b` => `\\u0008`).\n                stringify({ \"a\": [value, true, false, null, \"\\x00\\b\\n\\f\\r\\t\"] }) == serialized &&\n                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\n                stringify(null, value) === \"1\" &&\n                stringify([1, 2], null, 1) == \"[\\n 1,\\n 2\\n]\" &&\n                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\n                // serialize extended years.\n                stringify(new Date(-8.64e15)) == '\"-271821-04-20T00:00:00.000Z\"' &&\n                // The milliseconds are optional in ES 5, but required in 5.1.\n                stringify(new Date(8.64e15)) == '\"+275760-09-13T00:00:00.000Z\"' &&\n                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\n                // four-digit years instead of six-digit years. Credits: @Yaffle.\n                stringify(new Date(-621987552e5)) == '\"-000001-01-01T00:00:00.000Z\"' &&\n                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\n                // values less than 1000. Credits: @Yaffle.\n                stringify(new Date(-1)) == '\"1969-12-31T23:59:59.999Z\"';\n            } catch (exception) {\n              stringifySupported = false;\n            }\n          }\n          isSupported = stringifySupported;\n        }\n        // Test `JSON.parse`.\n        if (name == \"json-parse\") {\n          var parse = exports.parse;\n          if (typeof parse == \"function\") {\n            try {\n              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\n              // Conforming implementations should also coerce the initial argument to\n              // a string prior to parsing.\n              if (parse(\"0\") === 0 && !parse(false)) {\n                // Simple parsing test.\n                value = parse(serialized);\n                var parseSupported = value[\"a\"].length == 5 && value[\"a\"][0] === 1;\n                if (parseSupported) {\n                  try {\n                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\n                    parseSupported = !parse('\"\\t\"');\n                  } catch (exception) {}\n                  if (parseSupported) {\n                    try {\n                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading\n                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\n                      // certain octal literals.\n                      parseSupported = parse(\"01\") !== 1;\n                    } catch (exception) {}\n                  }\n                  if (parseSupported) {\n                    try {\n                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\n                      // points. These environments, along with FF 3.1b1 and 2,\n                      // also allow trailing commas in JSON objects and arrays.\n                      parseSupported = parse(\"1.\") !== 1;\n                    } catch (exception) {}\n                  }\n                }\n              }\n            } catch (exception) {\n              parseSupported = false;\n            }\n          }\n          isSupported = parseSupported;\n        }\n      }\n      return has[name] = !!isSupported;\n    }\n\n    if (!has(\"json\")) {\n      // Common `[[Class]]` name aliases.\n      var functionClass = \"[object Function]\",\n          dateClass = \"[object Date]\",\n          numberClass = \"[object Number]\",\n          stringClass = \"[object String]\",\n          arrayClass = \"[object Array]\",\n          booleanClass = \"[object Boolean]\";\n\n      // Detect incomplete support for accessing string characters by index.\n      var charIndexBuggy = has(\"bug-string-char-index\");\n\n      // Define additional utility methods if the `Date` methods are buggy.\n      if (!isExtended) {\n        var floor = Math.floor;\n        // A mapping between the months of the year and the number of days between\n        // January 1st and the first of the respective month.\n        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n        // Internal: Calculates the number of days between the Unix epoch and the\n        // first day of the given month.\n        var getDay = function (year, month) {\n          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\n        };\n      }\n\n      // Internal: Determines if a property is a direct property of the given\n      // object. Delegates to the native `Object#hasOwnProperty` method.\n      if (!(isProperty = objectProto.hasOwnProperty)) {\n        isProperty = function (property) {\n          var members = {}, constructor;\n          if ((members.__proto__ = null, members.__proto__ = {\n            // The *proto* property cannot be set multiple times in recent\n            // versions of Firefox and SeaMonkey.\n            \"toString\": 1\n          }, members).toString != getClass) {\n            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but\n            // supports the mutable *proto* property.\n            isProperty = function (property) {\n              // Capture and break the object's prototype chain (see section 8.6.2\n              // of the ES 5.1 spec). The parenthesized expression prevents an\n              // unsafe transformation by the Closure Compiler.\n              var original = this.__proto__, result = property in (this.__proto__ = null, this);\n              // Restore the original prototype chain.\n              this.__proto__ = original;\n              return result;\n            };\n          } else {\n            // Capture a reference to the top-level `Object` constructor.\n            constructor = members.constructor;\n            // Use the `constructor` property to simulate `Object#hasOwnProperty` in\n            // other environments.\n            isProperty = function (property) {\n              var parent = (this.constructor || constructor).prototype;\n              return property in this && !(property in parent && this[property] === parent[property]);\n            };\n          }\n          members = null;\n          return isProperty.call(this, property);\n        };\n      }\n\n      // Internal: Normalizes the `for...in` iteration algorithm across\n      // environments. Each enumerated key is yielded to a `callback` function.\n      forEach = function (object, callback) {\n        var size = 0, Properties, members, property;\n\n        // Tests for bugs in the current environment's `for...in` algorithm. The\n        // `valueOf` property inherits the non-enumerable flag from\n        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\n        (Properties = function () {\n          this.valueOf = 0;\n        }).prototype.valueOf = 0;\n\n        // Iterate over a new instance of the `Properties` class.\n        members = new Properties();\n        for (property in members) {\n          // Ignore all properties inherited from `Object.prototype`.\n          if (isProperty.call(members, property)) {\n            size++;\n          }\n        }\n        Properties = members = null;\n\n        // Normalize the iteration algorithm.\n        if (!size) {\n          // A list of non-enumerable properties inherited from `Object.prototype`.\n          members = [\"valueOf\", \"toString\", \"toLocaleString\", \"propertyIsEnumerable\", \"isPrototypeOf\", \"hasOwnProperty\", \"constructor\"];\n          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\n          // properties.\n          forEach = function (object, callback) {\n            var isFunction = getClass.call(object) == functionClass, property, length;\n            var hasProperty = !isFunction && typeof object.constructor != \"function\" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;\n            for (property in object) {\n              // Gecko <= 1.0 enumerates the `prototype` property of functions under\n              // certain conditions; IE does not.\n              if (!(isFunction && property == \"prototype\") && hasProperty.call(object, property)) {\n                callback(property);\n              }\n            }\n            // Manually invoke the callback for each non-enumerable property.\n            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));\n          };\n        } else if (size == 2) {\n          // Safari <= 2.0.4 enumerates shadowed properties twice.\n          forEach = function (object, callback) {\n            // Create a set of iterated properties.\n            var members = {}, isFunction = getClass.call(object) == functionClass, property;\n            for (property in object) {\n              // Store each property name to prevent double enumeration. The\n              // `prototype` property of functions is not enumerated due to cross-\n              // environment inconsistencies.\n              if (!(isFunction && property == \"prototype\") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\n                callback(property);\n              }\n            }\n          };\n        } else {\n          // No bugs detected; use the standard `for...in` algorithm.\n          forEach = function (object, callback) {\n            var isFunction = getClass.call(object) == functionClass, property, isConstructor;\n            for (property in object) {\n              if (!(isFunction && property == \"prototype\") && isProperty.call(object, property) && !(isConstructor = property === \"constructor\")) {\n                callback(property);\n              }\n            }\n            // Manually invoke the callback for the `constructor` property due to\n            // cross-environment inconsistencies.\n            if (isConstructor || isProperty.call(object, (property = \"constructor\"))) {\n              callback(property);\n            }\n          };\n        }\n        return forEach(object, callback);\n      };\n\n      // Public: Serializes a JavaScript `value` as a JSON string. The optional\n      // `filter` argument may specify either a function that alters how object and\n      // array members are serialized, or an array of strings and numbers that\n      // indicates which properties should be serialized. The optional `width`\n      // argument may be either a string or number that specifies the indentation\n      // level of the output.\n      if (!has(\"json-stringify\")) {\n        // Internal: A map of control characters and their escaped equivalents.\n        var Escapes = {\n          92: \"\\\\\\\\\",\n          34: '\\\\\"',\n          8: \"\\\\b\",\n          12: \"\\\\f\",\n          10: \"\\\\n\",\n          13: \"\\\\r\",\n          9: \"\\\\t\"\n        };\n\n        // Internal: Converts `value` into a zero-padded string such that its\n        // length is at least equal to `width`. The `width` must be <= 6.\n        var leadingZeroes = \"000000\";\n        var toPaddedString = function (width, value) {\n          // The `|| 0` expression is necessary to work around a bug in\n          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== \"0\"`.\n          return (leadingZeroes + (value || 0)).slice(-width);\n        };\n\n        // Internal: Double-quotes a string `value`, replacing all ASCII control\n        // characters (characters with code unit values between 0 and 31) with\n        // their escaped equivalents. This is an implementation of the\n        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\n        var unicodePrefix = \"\\\\u00\";\n        var quote = function (value) {\n          var result = '\"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;\n          var symbols = useCharIndex && (charIndexBuggy ? value.split(\"\") : value);\n          for (; index < length; index++) {\n            var charCode = value.charCodeAt(index);\n            // If the character is a control character, append its Unicode or\n            // shorthand escape sequence; otherwise, append the character as-is.\n            switch (charCode) {\n              case 8: case 9: case 10: case 12: case 13: case 34: case 92:\n                result += Escapes[charCode];\n                break;\n              default:\n                if (charCode < 32) {\n                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));\n                  break;\n                }\n                result += useCharIndex ? symbols[index] : value.charAt(index);\n            }\n          }\n          return result + '\"';\n        };\n\n        // Internal: Recursively serializes an object. Implements the\n        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\n        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\n          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\n          try {\n            // Necessary for host object support.\n            value = object[property];\n          } catch (exception) {}\n          if (typeof value == \"object\" && value) {\n            className = getClass.call(value);\n            if (className == dateClass && !isProperty.call(value, \"toJSON\")) {\n              if (value > -1 / 0 && value < 1 / 0) {\n                // Dates are serialized according to the `Date#toJSON` method\n                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\n                // for the ISO 8601 date time string format.\n                if (getDay) {\n                  // Manually compute the year, month, date, hours, minutes,\n                  // seconds, and milliseconds if the `getUTC*` methods are\n                  // buggy. Adapted from @Yaffle's `date-shim` project.\n                  date = floor(value / 864e5);\n                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\n                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\n                  date = 1 + date - getDay(year, month);\n                  // The `time` value specifies the time within the day (see ES\n                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\n                  // to compute `A modulo B`, as the `%` operator does not\n                  // correspond to the `modulo` operation for negative numbers.\n                  time = (value % 864e5 + 864e5) % 864e5;\n                  // The hours, minutes, seconds, and milliseconds are obtained by\n                  // decomposing the time within the day. See section 15.9.1.10.\n                  hours = floor(time / 36e5) % 24;\n                  minutes = floor(time / 6e4) % 60;\n                  seconds = floor(time / 1e3) % 60;\n                  milliseconds = time % 1e3;\n                } else {\n                  year = value.getUTCFullYear();\n                  month = value.getUTCMonth();\n                  date = value.getUTCDate();\n                  hours = value.getUTCHours();\n                  minutes = value.getUTCMinutes();\n                  seconds = value.getUTCSeconds();\n                  milliseconds = value.getUTCMilliseconds();\n                }\n                // Serialize extended years correctly.\n                value = (year <= 0 || year >= 1e4 ? (year < 0 ? \"-\" : \"+\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +\n                  \"-\" + toPaddedString(2, month + 1) + \"-\" + toPaddedString(2, date) +\n                  // Months, dates, hours, minutes, and seconds should have two\n                  // digits; milliseconds should have three.\n                  \"T\" + toPaddedString(2, hours) + \":\" + toPaddedString(2, minutes) + \":\" + toPaddedString(2, seconds) +\n                  // Milliseconds are optional in ES 5.0, but required in 5.1.\n                  \".\" + toPaddedString(3, milliseconds) + \"Z\";\n              } else {\n                value = null;\n              }\n            } else if (typeof value.toJSON == \"function\" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, \"toJSON\"))) {\n              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\n              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\n              // ignores all `toJSON` methods on these objects unless they are\n              // defined directly on an instance.\n              value = value.toJSON(property);\n            }\n          }\n          if (callback) {\n            // If a replacement function was provided, call it to obtain the value\n            // for serialization.\n            value = callback.call(object, property, value);\n          }\n          if (value === null) {\n            return \"null\";\n          }\n          className = getClass.call(value);\n          if (className == booleanClass) {\n            // Booleans are represented literally.\n            return \"\" + value;\n          } else if (className == numberClass) {\n            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\n            // `\"null\"`.\n            return value > -1 / 0 && value < 1 / 0 ? \"\" + value : \"null\";\n          } else if (className == stringClass) {\n            // Strings are double-quoted and escaped.\n            return quote(\"\" + value);\n          }\n          // Recursively serialize objects and arrays.\n          if (typeof value == \"object\") {\n            // Check for cyclic structures. This is a linear search; performance\n            // is inversely proportional to the number of unique nested objects.\n            for (length = stack.length; length--;) {\n              if (stack[length] === value) {\n                // Cyclic structures cannot be serialized by `JSON.stringify`.\n                throw TypeError();\n              }\n            }\n            // Add the object to the stack of traversed objects.\n            stack.push(value);\n            results = [];\n            // Save the current indentation level and indent one additional level.\n            prefix = indentation;\n            indentation += whitespace;\n            if (className == arrayClass) {\n              // Recursively serialize array elements.\n              for (index = 0, length = value.length; index < length; index++) {\n                element = serialize(index, value, callback, properties, whitespace, indentation, stack);\n                results.push(element === undef ? \"null\" : element);\n              }\n              result = results.length ? (whitespace ? \"[\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"]\" : (\"[\" + results.join(\",\") + \"]\")) : \"[]\";\n            } else {\n              // Recursively serialize object members. Members are selected from\n              // either a user-specified list of property names, or the object\n              // itself.\n              forEach(properties || value, function (property) {\n                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\n                if (element !== undef) {\n                  // According to ES 5.1 section 15.12.3: \"If `gap` {whitespace}\n                  // is not the empty string, let `member` {quote(property) + \":\"}\n                  // be the concatenation of `member` and the `space` character.\"\n                  // The \"`space` character\" refers to the literal space\n                  // character, not the `space` {width} argument provided to\n                  // `JSON.stringify`.\n                  results.push(quote(property) + \":\" + (whitespace ? \" \" : \"\") + element);\n                }\n              });\n              result = results.length ? (whitespace ? \"{\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"}\" : (\"{\" + results.join(\",\") + \"}\")) : \"{}\";\n            }\n            // Remove the object from the traversed object stack.\n            stack.pop();\n            return result;\n          }\n        };\n\n        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\n        exports.stringify = function (source, filter, width) {\n          var whitespace, callback, properties, className;\n          if (objectTypes[typeof filter] && filter) {\n            if ((className = getClass.call(filter)) == functionClass) {\n              callback = filter;\n            } else if (className == arrayClass) {\n              // Convert the property names array into a makeshift set.\n              properties = {};\n              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));\n            }\n          }\n          if (width) {\n            if ((className = getClass.call(width)) == numberClass) {\n              // Convert the `width` to an integer and create a string containing\n              // `width` number of space characters.\n              if ((width -= width % 1) > 0) {\n                for (whitespace = \"\", width > 10 && (width = 10); whitespace.length < width; whitespace += \" \");\n              }\n            } else if (className == stringClass) {\n              whitespace = width.length <= 10 ? width : width.slice(0, 10);\n            }\n          }\n          // Opera <= 7.54u2 discards the values associated with empty string keys\n          // (`\"\"`) only if they are used directly within an object member list\n          // (e.g., `!(\"\" in { \"\": 1})`).\n          return serialize(\"\", (value = {}, value[\"\"] = source, value), callback, properties, whitespace, \"\", []);\n        };\n      }\n\n      // Public: Parses a JSON source string.\n      if (!has(\"json-parse\")) {\n        var fromCharCode = String.fromCharCode;\n\n        // Internal: A map of escaped control characters and their unescaped\n        // equivalents.\n        var Unescapes = {\n          92: \"\\\\\",\n          34: '\"',\n          47: \"/\",\n          98: \"\\b\",\n          116: \"\\t\",\n          110: \"\\n\",\n          102: \"\\f\",\n          114: \"\\r\"\n        };\n\n        // Internal: Stores the parser state.\n        var Index, Source;\n\n        // Internal: Resets the parser state and throws a `SyntaxError`.\n        var abort = function () {\n          Index = Source = null;\n          throw SyntaxError();\n        };\n\n        // Internal: Returns the next token, or `\"$\"` if the parser has reached\n        // the end of the source string. A token may be a string, number, `null`\n        // literal, or Boolean literal.\n        var lex = function () {\n          var source = Source, length = source.length, value, begin, position, isSigned, charCode;\n          while (Index < length) {\n            charCode = source.charCodeAt(Index);\n            switch (charCode) {\n              case 9: case 10: case 13: case 32:\n                // Skip whitespace tokens, including tabs, carriage returns, line\n                // feeds, and space characters.\n                Index++;\n                break;\n              case 123: case 125: case 91: case 93: case 58: case 44:\n                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\n                // the current position.\n                value = charIndexBuggy ? source.charAt(Index) : source[Index];\n                Index++;\n                return value;\n              case 34:\n                // `\"` delimits a JSON string; advance to the next character and\n                // begin parsing the string. String tokens are prefixed with the\n                // sentinel `@` character to distinguish them from punctuators and\n                // end-of-string tokens.\n                for (value = \"@\", Index++; Index < length;) {\n                  charCode = source.charCodeAt(Index);\n                  if (charCode < 32) {\n                    // Unescaped ASCII control characters (those with a code unit\n                    // less than the space character) are not permitted.\n                    abort();\n                  } else if (charCode == 92) {\n                    // A reverse solidus (`\\`) marks the beginning of an escaped\n                    // control character (including `\"`, `\\`, and `/`) or Unicode\n                    // escape sequence.\n                    charCode = source.charCodeAt(++Index);\n                    switch (charCode) {\n                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:\n                        // Revive escaped control characters.\n                        value += Unescapes[charCode];\n                        Index++;\n                        break;\n                      case 117:\n                        // `\\u` marks the beginning of a Unicode escape sequence.\n                        // Advance to the first character and validate the\n                        // four-digit code point.\n                        begin = ++Index;\n                        for (position = Index + 4; Index < position; Index++) {\n                          charCode = source.charCodeAt(Index);\n                          // A valid sequence comprises four hexdigits (case-\n                          // insensitive) that form a single hexadecimal value.\n                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\n                            // Invalid Unicode escape sequence.\n                            abort();\n                          }\n                        }\n                        // Revive the escaped character.\n                        value += fromCharCode(\"0x\" + source.slice(begin, Index));\n                        break;\n                      default:\n                        // Invalid escape sequence.\n                        abort();\n                    }\n                  } else {\n                    if (charCode == 34) {\n                      // An unescaped double-quote character marks the end of the\n                      // string.\n                      break;\n                    }\n                    charCode = source.charCodeAt(Index);\n                    begin = Index;\n                    // Optimize for the common case where a string is valid.\n                    while (charCode >= 32 && charCode != 92 && charCode != 34) {\n                      charCode = source.charCodeAt(++Index);\n                    }\n                    // Append the string as-is.\n                    value += source.slice(begin, Index);\n                  }\n                }\n                if (source.charCodeAt(Index) == 34) {\n                  // Advance to the next character and return the revived string.\n                  Index++;\n                  return value;\n                }\n                // Unterminated string.\n                abort();\n              default:\n                // Parse numbers and literals.\n                begin = Index;\n                // Advance past the negative sign, if one is specified.\n                if (charCode == 45) {\n                  isSigned = true;\n                  charCode = source.charCodeAt(++Index);\n                }\n                // Parse an integer or floating-point value.\n                if (charCode >= 48 && charCode <= 57) {\n                  // Leading zeroes are interpreted as octal literals.\n                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {\n                    // Illegal octal literal.\n                    abort();\n                  }\n                  isSigned = false;\n                  // Parse the integer component.\n                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);\n                  // Floats cannot contain a leading decimal point; however, this\n                  // case is already accounted for by the parser.\n                  if (source.charCodeAt(Index) == 46) {\n                    position = ++Index;\n                    // Parse the decimal component.\n                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                    if (position == Index) {\n                      // Illegal trailing decimal.\n                      abort();\n                    }\n                    Index = position;\n                  }\n                  // Parse exponents. The `e` denoting the exponent is\n                  // case-insensitive.\n                  charCode = source.charCodeAt(Index);\n                  if (charCode == 101 || charCode == 69) {\n                    charCode = source.charCodeAt(++Index);\n                    // Skip past the sign following the exponent, if one is\n                    // specified.\n                    if (charCode == 43 || charCode == 45) {\n                      Index++;\n                    }\n                    // Parse the exponential component.\n                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                    if (position == Index) {\n                      // Illegal empty exponent.\n                      abort();\n                    }\n                    Index = position;\n                  }\n                  // Coerce the parsed value to a JavaScript number.\n                  return +source.slice(begin, Index);\n                }\n                // A negative sign may only precede numbers.\n                if (isSigned) {\n                  abort();\n                }\n                // `true`, `false`, and `null` literals.\n                if (source.slice(Index, Index + 4) == \"true\") {\n                  Index += 4;\n                  return true;\n                } else if (source.slice(Index, Index + 5) == \"false\") {\n                  Index += 5;\n                  return false;\n                } else if (source.slice(Index, Index + 4) == \"null\") {\n                  Index += 4;\n                  return null;\n                }\n                // Unrecognized token.\n                abort();\n            }\n          }\n          // Return the sentinel `$` character if the parser has reached the end\n          // of the source string.\n          return \"$\";\n        };\n\n        // Internal: Parses a JSON `value` token.\n        var get = function (value) {\n          var results, hasMembers;\n          if (value == \"$\") {\n            // Unexpected end of input.\n            abort();\n          }\n          if (typeof value == \"string\") {\n            if ((charIndexBuggy ? value.charAt(0) : value[0]) == \"@\") {\n              // Remove the sentinel `@` character.\n              return value.slice(1);\n            }\n            // Parse object and array literals.\n            if (value == \"[\") {\n              // Parses a JSON array, returning a new JavaScript array.\n              results = [];\n              for (;; hasMembers || (hasMembers = true)) {\n                value = lex();\n                // A closing square bracket marks the end of the array literal.\n                if (value == \"]\") {\n                  break;\n                }\n                // If the array literal contains elements, the current token\n                // should be a comma separating the previous element from the\n                // next.\n                if (hasMembers) {\n                  if (value == \",\") {\n                    value = lex();\n                    if (value == \"]\") {\n                      // Unexpected trailing `,` in array literal.\n                      abort();\n                    }\n                  } else {\n                    // A `,` must separate each array element.\n                    abort();\n                  }\n                }\n                // Elisions and leading commas are not permitted.\n                if (value == \",\") {\n                  abort();\n                }\n                results.push(get(value));\n              }\n              return results;\n            } else if (value == \"{\") {\n              // Parses a JSON object, returning a new JavaScript object.\n              results = {};\n              for (;; hasMembers || (hasMembers = true)) {\n                value = lex();\n                // A closing curly brace marks the end of the object literal.\n                if (value == \"}\") {\n                  break;\n                }\n                // If the object literal contains members, the current token\n                // should be a comma separator.\n                if (hasMembers) {\n                  if (value == \",\") {\n                    value = lex();\n                    if (value == \"}\") {\n                      // Unexpected trailing `,` in object literal.\n                      abort();\n                    }\n                  } else {\n                    // A `,` must separate each object member.\n                    abort();\n                  }\n                }\n                // Leading commas are not permitted, object property names must be\n                // double-quoted strings, and a `:` must separate each property\n                // name and value.\n                if (value == \",\" || typeof value != \"string\" || (charIndexBuggy ? value.charAt(0) : value[0]) != \"@\" || lex() != \":\") {\n                  abort();\n                }\n                results[value.slice(1)] = get(lex());\n              }\n              return results;\n            }\n            // Unexpected token encountered.\n            abort();\n          }\n          return value;\n        };\n\n        // Internal: Updates a traversed object member.\n        var update = function (source, property, callback) {\n          var element = walk(source, property, callback);\n          if (element === undef) {\n            delete source[property];\n          } else {\n            source[property] = element;\n          }\n        };\n\n        // Internal: Recursively traverses a parsed JSON object, invoking the\n        // `callback` function for each value. This is an implementation of the\n        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\n        var walk = function (source, property, callback) {\n          var value = source[property], length;\n          if (typeof value == \"object\" && value) {\n            // `forEach` can't be used to traverse an array in Opera <= 8.54\n            // because its `Object#hasOwnProperty` implementation returns `false`\n            // for array indices (e.g., `![1, 2, 3].hasOwnProperty(\"0\")`).\n            if (getClass.call(value) == arrayClass) {\n              for (length = value.length; length--;) {\n                update(value, length, callback);\n              }\n            } else {\n              forEach(value, function (property) {\n                update(value, property, callback);\n              });\n            }\n          }\n          return callback.call(source, property, value);\n        };\n\n        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\n        exports.parse = function (source, callback) {\n          var result, value;\n          Index = 0;\n          Source = \"\" + source;\n          result = get(lex());\n          // If a JSON string contains multiple tokens, it is invalid.\n          if (lex() != \"$\") {\n            abort();\n          }\n          // Reset the parser state.\n          Index = Source = null;\n          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\"\"] = result, value), \"\", callback) : result;\n        };\n      }\n    }\n\n    exports[\"runInContext\"] = runInContext;\n    return exports;\n  }\n\n  if (freeExports && !isLoader) {\n    // Export for CommonJS environments.\n    runInContext(root, freeExports);\n  } else {\n    // Export for web browsers and JavaScript engines.\n    var nativeJSON = root.JSON,\n        previousJSON = root[\"JSON3\"],\n        isRestored = false;\n\n    var JSON3 = runInContext(root, (root[\"JSON3\"] = {\n      // Public: Restores the original value of the global `JSON` object and\n      // returns a reference to the `JSON3` object.\n      \"noConflict\": function () {\n        if (!isRestored) {\n          isRestored = true;\n          root.JSON = nativeJSON;\n          root[\"JSON3\"] = previousJSON;\n          nativeJSON = previousJSON = null;\n        }\n        return JSON3;\n      }\n    }));\n\n    root.JSON = {\n      \"parse\": JSON3.parse,\n      \"stringify\": JSON3.stringify\n    };\n  }\n\n  // Export for asynchronous module loaders.\n  if (isLoader) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return JSON3;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n}).call(this);\n\n//##############################################################################\n// DomUtils.js\n//##############################################################################\n\n(function () {\n\n\t/**\n\t * A few utilities for interacting with the dom.\n\t * @class DomUtils\n\t */\n\tvar s = {};\n\n\ts.appendToHead = function (el) {\n\t\ts.getHead().appendChild(el)\n\t}\n\n\ts.getHead = function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}\n\n\ts.getBody = function () {\n\t\treturn document.body || document.getElementsByTagName(\"body\")[0];\n\t}\n\n\tcreatejs.DomUtils = s;\n\n}());\n\n//##############################################################################\n// DataUtils.js\n//##############################################################################\n\n(function () {\n\n\t/**\n\t * A few data utilities for formatting different data types.\n\t * @class DataUtils\n\t */\n\tvar s = {};\n\n\t// static methods\n\t/**\n\t * Parse XML using the DOM. This is required when preloading XML or SVG.\n\t * @method parseXML\n\t * @param {String} text The raw text or XML that is loaded by XHR.\n\t * @param {String} type The mime type of the XML. Use \"text/xml\" for XML, and  \"image/svg+xml\" for SVG parsing.\n\t * @return {XML} An XML document\n\t * @static\n\t */\n\ts.parseXML = function (text, type) {\n\t\tvar xml = null;\n\t\t// CocoonJS does not support XML parsing with either method.\n\n\t\t// Most browsers will use DOMParser\n\t\t// IE fails on certain SVG files, so we have a fallback below.\n\t\ttry {\n\t\t\tif (window.DOMParser) {\n\t\t\t\tvar parser = new DOMParser();\n\t\t\t\txml = parser.parseFromString(text, type);\n\t\t\t}\n\t\t} catch (e) {\n\t\t}\n\n\t\t// Fallback for IE support.\n\t\tif (!xml) {\n\t\t\ttry {\n\t\t\t\txml = new ActiveXObject(\"Microsoft.XMLDOM\");\n\t\t\t\txml.async = false;\n\t\t\t\txml.loadXML(text);\n\t\t\t} catch (e) {\n\t\t\t\txml = null;\n\t\t\t}\n\t\t}\n\n\t\treturn xml;\n\t};\n\n\t/**\n\t * Parse a string into an Object.\n\t * @method parseJSON\n\t * @param {String} value The loaded JSON string\n\t * @returns {Object} A JavaScript object.\n\t */\n\ts.parseJSON = function (value) {\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\treturn JSON.parse(value);\n\t\t} catch (e) {\n\t\t\t// TODO; Handle this with a custom error?\n\t\t\tthrow e;\n\t\t}\n\t};\n\n\tcreatejs.DataUtils = s;\n\n}());\n\n//##############################################################################\n// LoadItem.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * All loaders accept an item containing the properties defined in this class. If a raw object is passed instead,\n\t * it will not be affected, but it must contain at least a {{#crossLink \"src:property\"}}{{/crossLink}} property. A\n\t * string path or HTML tag is also acceptable, but it will be automatically converted to a LoadItem using the\n\t * {{#crossLink \"create\"}}{{/crossLink}} method by {{#crossLink \"AbstractLoader\"}}{{/crossLink}}\n\t * @class LoadItem\n\t * @constructor\n\t * @since 0.6.0\n\t */\n\tfunction LoadItem() {\n\t\t/**\n\t\t * The source of the file that is being loaded. This property is <b>required</b>. The source can either be a\n\t\t * string (recommended), or an HTML tag.\n\t\t * This can also be an object, but in that case it has to include a type and be handled by a plugin.\n\t\t * @property src\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.src = null;\n\n\t\t/**\n\t\t * The type file that is being loaded. The type of the file is usually inferred by the extension, but can also\n\t\t * be set manually. This is helpful in cases where a file does not have an extension.\n\t\t * @property type\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.type = null;\n\n\t\t/**\n\t\t * A string identifier which can be used to reference the loaded object. If none is provided, this will be\n\t\t * automatically set to the {{#crossLink \"src:property\"}}{{/crossLink}}.\n\t\t * @property id\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.id = null;\n\n\t\t/**\n\t\t * Determines if a manifest will maintain the order of this item, in relation to other items in the manifest\n\t\t * that have also set the `maintainOrder` property to `true`. This only applies when the max connections has\n\t\t * been set above 1 (using {{#crossLink \"LoadQueue/setMaxConnections\"}}{{/crossLink}}). Everything with this\n\t\t * property set to `false` will finish as it is loaded. Ordered items are combined with script tags loading in\n\t\t * order when {{#crossLink \"LoadQueue/maintainScriptOrder:property\"}}{{/crossLink}} is set to `true`.\n\t\t * @property maintainOrder\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.maintainOrder = false;\n\n\t\t/**\n\t\t * A callback used by JSONP requests that defines what global method to call when the JSONP content is loaded.\n\t\t * @property callback\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.callback = null;\n\n\t\t/**\n\t\t * An arbitrary data object, which is included with the loaded object.\n\t\t * @property data\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis.data = null;\n\n\t\t/**\n\t\t * The request method used for HTTP calls. Both {{#crossLink \"AbstractLoader/GET:property\"}}{{/crossLink}} or\n\t\t * {{#crossLink \"AbstractLoader/POST:property\"}}{{/crossLink}} request types are supported, and are defined as\n\t\t * constants on {{#crossLink \"AbstractLoader\"}}{{/crossLink}}.\n\t\t * @property method\n\t\t * @type {String}\n\t\t * @default get\n\t\t */\n\t\tthis.method = createjs.LoadItem.GET;\n\n\t\t/**\n\t\t * An object hash of name/value pairs to send to the server.\n\t\t * @property values\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis.values = null;\n\n\t\t/**\n\t\t * An object hash of headers to attach to an XHR request. PreloadJS will automatically attach some default\n\t\t * headers when required, including \"Origin\", \"Content-Type\", and \"X-Requested-With\". You may override the\n\t\t * default headers by including them in your headers object.\n\t\t * @property headers\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis.headers = null;\n\n\t\t/**\n\t\t * Enable credentials for XHR requests.\n\t\t * @property withCredentials\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.withCredentials = false;\n\n\t\t/**\n\t\t * Set the mime type of XHR-based requests. This is automatically set to \"text/plain; charset=utf-8\" for text\n\t\t * based files (json, xml, text, css, js).\n\t\t * @property mimeType\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.mimeType = null;\n\n\t\t/**\n\t\t * Sets the crossOrigin attribute for CORS-enabled images loading cross-domain.\n\t\t * @property crossOrigin\n\t\t * @type {boolean}\n\t\t * @default Anonymous\n\t\t */\n\t\tthis.crossOrigin = null;\n\n\t\t/**\n\t\t * The duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR\n\t\t * (level one) loading, as XHR (level 2) provides its own timeout event.\n\t\t * @property loadTimeout\n\t\t * @type {Number}\n\t\t * @default 8000 (8 seconds)\n\t\t */\n\t\tthis.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;\n\t};\n\n\tvar p = LoadItem.prototype = {};\n\tvar s = LoadItem;\n\n\t/**\n\t * Default duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR\n\t * (level one) loading, as XHR (level 2) provides its own timeout event.\n\t * @property LOAD_TIMEOUT_DEFAULT\n\t * @type {number}\n\t * @static\n\t */\n\ts.LOAD_TIMEOUT_DEFAULT = 8000;\n\n\t/**\n\t * Create a LoadItem.\n\t * <ul>\n\t *     <li>String-based items are converted to a LoadItem with a populated {{#crossLink \"src:property\"}}{{/crossLink}}.</li>\n\t *     <li>LoadItem instances are returned as-is</li>\n\t *     <li>Objects are returned with any needed properties added</li>\n\t * </ul>\n\t * @method create\n\t * @param {LoadItem|String|Object} value The load item value\n\t * @returns {LoadItem|Object}\n\t * @static\n\t */\n\ts.create = function (value) {\n\t\tif (typeof value == \"string\") {\n\t\t\tvar item = new LoadItem();\n\t\t\titem.src = value;\n\t\t\treturn item;\n\t\t} else if (value instanceof s) {\n\t\t\treturn value;\n\t\t} else if (value instanceof Object && value.src) {\n\t\t\tif (value.loadTimeout == null) {\n\t\t\t\tvalue.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;\n\t\t\t}\n\t\t\treturn value;\n\t\t} else {\n\t\t\tthrow new Error(\"Type not recognized.\");\n\t\t}\n\t};\n\n\t/**\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var loadItem = new createjs.LoadItem().set({src:\"image.png\", maintainOrder:true});\n\t *\n\t * @method set\n\t * @param {Object} props A generic object containing properties to copy to the LoadItem instance.\n\t * @return {LoadItem} Returns the instance the method is called on (useful for chaining calls.)\n\t*/\n\tp.set = function(props) {\n\t\tfor (var n in props) { this[n] = props[n]; }\n\t\treturn this;\n\t};\n\n\tcreatejs.LoadItem = s;\n\n}());\n\n//##############################################################################\n// RequestUtils.js\n//##############################################################################\n\n(function () {\n\n\t/**\n\t * Utilities that assist with parsing load items, and determining file types, etc.\n\t * @class RequestUtils\n\t */\n\tvar s = {};\n\n\t/**\n\t * The Regular Expression used to test file URLS for an absolute path.\n\t * @property ABSOLUTE_PATH\n\t * @type {RegExp}\n\t * @static\n\t */\n\ts.ABSOLUTE_PATT = /^(?:\\w+:)?\\/{2}/i;\n\n\t/**\n\t * The Regular Expression used to test file URLS for a relative path.\n\t * @property RELATIVE_PATH\n\t * @type {RegExp}\n\t * @static\n\t */\n\ts.RELATIVE_PATT = (/^[./]*?\\//i);\n\n\t/**\n\t * The Regular Expression used to test file URLS for an extension. Note that URIs must already have the query string\n\t * removed.\n\t * @property EXTENSION_PATT\n\t * @type {RegExp}\n\t * @static\n\t */\n\ts.EXTENSION_PATT = /\\/?[^/]+\\.(\\w{1,5})$/i;\n\n\t/**\n\t * Parse a file path to determine the information we need to work with it. Currently, PreloadJS needs to know:\n\t * <ul>\n\t *     <li>If the path is absolute. Absolute paths start with a protocol (such as `http://`, `file://`, or\n\t *     `//networkPath`)</li>\n\t *     <li>If the path is relative. Relative paths start with `../` or `/path` (or similar)</li>\n\t *     <li>The file extension. This is determined by the filename with an extension. Query strings are dropped, and\n\t *     the file path is expected to follow the format `name.ext`.</li>\n\t * </ul>\n\t * @method parseURI\n\t * @param {String} path\n\t * @returns {Object} An Object with an `absolute` and `relative` Boolean values, as well as an optional 'extension`\n\t * property, which is the lowercase extension.\n\t * @static\n\t */\n\ts.parseURI = function (path) {\n\t\tvar info = {absolute: false, relative: false};\n\t\tif (path == null) { return info; }\n\n\t\t// Drop the query string\n\t\tvar queryIndex = path.indexOf(\"?\");\n\t\tif (queryIndex > -1) {\n\t\t\tpath = path.substr(0, queryIndex);\n\t\t}\n\n\t\t// Absolute\n\t\tvar match;\n\t\tif (s.ABSOLUTE_PATT.test(path)) {\n\t\t\tinfo.absolute = true;\n\n\t\t\t// Relative\n\t\t} else if (s.RELATIVE_PATT.test(path)) {\n\t\t\tinfo.relative = true;\n\t\t}\n\n\t\t// Extension\n\t\tif (match = path.match(s.EXTENSION_PATT)) {\n\t\t\tinfo.extension = match[1].toLowerCase();\n\t\t}\n\t\treturn info;\n\t};\n\n\t/**\n\t * Formats an object into a query string for either a POST or GET request.\n\t * @method formatQueryString\n\t * @param {Object} data The data to convert to a query string.\n\t * @param {Array} [query] Existing name/value pairs to append on to this query.\n\t * @static\n\t */\n\ts.formatQueryString = function (data, query) {\n\t\tif (data == null) {\n\t\t\tthrow new Error('You must specify data.');\n\t\t}\n\t\tvar params = [];\n\t\tfor (var n in data) {\n\t\t\tparams.push(n + '=' + escape(data[n]));\n\t\t}\n\t\tif (query) {\n\t\t\tparams = params.concat(query);\n\t\t}\n\t\treturn params.join('&');\n\t};\n\n\t/**\n\t * A utility method that builds a file path using a source and a data object, and formats it into a new path.\n\t * @method buildPath\n\t * @param {String} src The source path to add values to.\n\t * @param {Object} [data] Object used to append values to this request as a query string. Existing parameters on the\n\t * path will be preserved.\n\t * @returns {string} A formatted string that contains the path and the supplied parameters.\n\t * @static\n\t */\n\ts.buildPath = function (src, data) {\n\t\tif (data == null) {\n\t\t\treturn src;\n\t\t}\n\n\t\tvar query = [];\n\t\tvar idx = src.indexOf('?');\n\n\t\tif (idx != -1) {\n\t\t\tvar q = src.slice(idx + 1);\n\t\t\tquery = query.concat(q.split('&'));\n\t\t}\n\n\t\tif (idx != -1) {\n\t\t\treturn src.slice(0, idx) + '?' + this.formatQueryString(data, query);\n\t\t} else {\n\t\t\treturn src + '?' + this.formatQueryString(data, query);\n\t\t}\n\t};\n\n\t/**\n\t * @method isCrossDomain\n\t * @param {LoadItem|Object} item A load item with a `src` property.\n\t * @return {Boolean} If the load item is loading from a different domain than the current location.\n\t * @static\n\t */\n\ts.isCrossDomain = function (item) {\n\t\tvar target = document.createElement(\"a\");\n\t\ttarget.href = item.src;\n\n\t\tvar host = document.createElement(\"a\");\n\t\thost.href = location.href;\n\n\t\tvar crossdomain = (target.hostname != \"\") &&\n\t\t\t\t\t\t  (target.port != host.port ||\n\t\t\t\t\t\t   target.protocol != host.protocol ||\n\t\t\t\t\t\t   target.hostname != host.hostname);\n\t\treturn crossdomain;\n\t};\n\n\t/**\n\t * @method isLocal\n\t * @param {LoadItem|Object} item A load item with a `src` property\n\t * @return {Boolean} If the load item is loading from the \"file:\" protocol. Assume that the host must be local as\n\t * well.\n\t * @static\n\t */\n\ts.isLocal = function (item) {\n\t\tvar target = document.createElement(\"a\");\n\t\ttarget.href = item.src;\n\t\treturn target.hostname == \"\" && target.protocol == \"file:\";\n\t};\n\n\t/**\n\t * Determine if a specific type should be loaded as a binary file. Currently, only images and items marked\n\t * specifically as \"binary\" are loaded as binary. Note that audio is <b>not</b> a binary type, as we can not play\n\t * back using an audio tag if it is loaded as binary. Plugins can change the item type to binary to ensure they get\n\t * a binary result to work with. Binary files are loaded using XHR2. Types are defined as static constants on\n\t * {{#crossLink \"AbstractLoader\"}}{{/crossLink}}.\n\t * @method isBinary\n\t * @param {String} type The item type.\n\t * @return {Boolean} If the specified type is binary.\n\t * @static\n\t */\n\ts.isBinary = function (type) {\n\t\tswitch (type) {\n\t\t\tcase createjs.AbstractLoader.IMAGE:\n\t\t\tcase createjs.AbstractLoader.BINARY:\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Check if item is a valid HTMLImageElement\n\t * @method isImageTag\n\t * @param {Object} item\n\t * @returns {Boolean}\n\t * @static\n\t */\n\ts.isImageTag = function(item) {\n\t\treturn item instanceof HTMLImageElement;\n\t};\n\n\t/**\n\t * Check if item is a valid HTMLAudioElement\n\t * @method isAudioTag\n\t * @param {Object} item\n\t * @returns {Boolean}\n\t * @static\n\t */\n\ts.isAudioTag = function(item) {\n\t\tif (window.HTMLAudioElement) {\n\t\t\treturn item instanceof HTMLAudioElement;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Check if item is a valid HTMLVideoElement\n\t * @method isVideoTag\n\t * @param {Object} item\n\t * @returns {Boolean}\n\t * @static\n\t */\n\ts.isVideoTag = function(item) {\n\t\tif (window.HTMLVideoElement) {\n\t\t\treturn item instanceof HTMLVideoElement;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Determine if a specific type is a text-based asset, and should be loaded as UTF-8.\n\t * @method isText\n\t * @param {String} type The item type.\n\t * @return {Boolean} If the specified type is text.\n\t * @static\n\t */\n\ts.isText = function (type) {\n\t\tswitch (type) {\n\t\t\tcase createjs.AbstractLoader.TEXT:\n\t\t\tcase createjs.AbstractLoader.JSON:\n\t\t\tcase createjs.AbstractLoader.MANIFEST:\n\t\t\tcase createjs.AbstractLoader.XML:\n\t\t\tcase createjs.AbstractLoader.CSS:\n\t\t\tcase createjs.AbstractLoader.SVG:\n\t\t\tcase createjs.AbstractLoader.JAVASCRIPT:\n\t\t\tcase createjs.AbstractLoader.SPRITESHEET:\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Determine the type of the object using common extensions. Note that the type can be passed in with the load item\n\t * if it is an unusual extension.\n\t * @method getTypeByExtension\n\t * @param {String} extension The file extension to use to determine the load type.\n\t * @return {String} The determined load type (for example, <code>AbstractLoader.IMAGE</code>). Will return `null` if\n\t * the type can not be determined by the extension.\n\t * @static\n\t */\n\ts.getTypeByExtension = function (extension) {\n\t\tif (extension == null) {\n\t\t\treturn createjs.AbstractLoader.TEXT;\n\t\t}\n\n\t\tswitch (extension.toLowerCase()) {\n\t\t\tcase \"jpeg\":\n\t\t\tcase \"jpg\":\n\t\t\tcase \"gif\":\n\t\t\tcase \"png\":\n\t\t\tcase \"webp\":\n\t\t\tcase \"bmp\":\n\t\t\t\treturn createjs.AbstractLoader.IMAGE;\n\t\t\tcase \"ogg\":\n\t\t\tcase \"mp3\":\n\t\t\tcase \"webm\":\n\t\t\t\treturn createjs.AbstractLoader.SOUND;\n\t\t\tcase \"mp4\":\n\t\t\tcase \"webm\":\n\t\t\tcase \"ts\":\n\t\t\t\treturn createjs.AbstractLoader.VIDEO;\n\t\t\tcase \"json\":\n\t\t\t\treturn createjs.AbstractLoader.JSON;\n\t\t\tcase \"xml\":\n\t\t\t\treturn createjs.AbstractLoader.XML;\n\t\t\tcase \"css\":\n\t\t\t\treturn createjs.AbstractLoader.CSS;\n\t\t\tcase \"js\":\n\t\t\t\treturn createjs.AbstractLoader.JAVASCRIPT;\n\t\t\tcase 'svg':\n\t\t\t\treturn createjs.AbstractLoader.SVG;\n\t\t\tdefault:\n\t\t\t\treturn createjs.AbstractLoader.TEXT;\n\t\t}\n\t};\n\n\tcreatejs.RequestUtils = s;\n\n}());\n\n//##############################################################################\n// AbstractLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n// constructor\n\t/**\n\t * The base loader, which defines all the generic methods, properties, and events. All loaders extend this class,\n\t * including the {{#crossLink \"LoadQueue\"}}{{/crossLink}}.\n\t * @class AbstractLoader\n\t * @param {LoadItem|object|string} loadItem The item to be loaded.\n\t * @param {Boolean} [preferXHR] Determines if the LoadItem should <em>try</em> and load using XHR, or take a\n\t * tag-based approach, which can be better in cross-domain situations. Not all loaders can load using one or the\n\t * other, so this is a suggested directive.\n\t * @param {String} [type] The type of loader. Loader types are defined as constants on the AbstractLoader class,\n\t * such as {{#crossLink \"IMAGE:property\"}}{{/crossLink}}, {{#crossLink \"CSS:property\"}}{{/crossLink}}, etc.\n\t * @extends EventDispatcher\n\t */\n\tfunction AbstractLoader(loadItem, preferXHR, type) {\n\t\tthis.EventDispatcher_constructor();\n\n\t\t// public properties\n\t\t/**\n\t\t * If the loader has completed loading. This provides a quick check, but also ensures that the different approaches\n\t\t * used for loading do not pile up resulting in more than one `complete` {{#crossLink \"Event\"}}{{/crossLink}}.\n\t\t * @property loaded\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.loaded = false;\n\n\t\t/**\n\t\t * Determine if the loader was canceled. Canceled loads will not fire complete events. Note that this property\n\t\t * is readonly, so {{#crossLink \"LoadQueue\"}}{{/crossLink}} queues should be closed using {{#crossLink \"LoadQueue/close\"}}{{/crossLink}}\n\t\t * instead.\n\t\t * @property canceled\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @readonly\n\t\t */\n\t\tthis.canceled = false;\n\n\t\t/**\n\t\t * The current load progress (percentage) for this item. This will be a number between 0 and 1.\n\t\t *\n\t\t * <h4>Example</h4>\n\t\t *\n\t\t *     var queue = new createjs.LoadQueue();\n\t\t *     queue.loadFile(\"largeImage.png\");\n\t\t *     queue.on(\"progress\", function() {\n\t\t *         console.log(\"Progress:\", queue.progress, event.progress);\n\t\t *     });\n\t\t *\n\t\t * @property progress\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.progress = 0;\n\n\t\t/**\n\t\t * The type of item this loader will load. See {{#crossLink \"AbstractLoader\"}}{{/crossLink}} for a full list of\n\t\t * supported types.\n\t\t * @property type\n\t\t * @type {String}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * A formatter function that converts the loaded raw result into the final result. For example, the JSONLoader\n\t\t * converts a string of text into a JavaScript object. Not all loaders have a resultFormatter, and this property\n\t\t * can be overridden to provide custom formatting.\n\t\t *\n\t\t * Optionally, a resultFormatter can return a callback function in cases where the formatting needs to be\n\t\t * asynchronous, such as creating a new image. The callback function is passed 2 parameters, which are callbacks\n\t\t * to handle success and error conditions in the resultFormatter. Note that the resultFormatter method is\n\t\t * called in the current scope, as well as the success and error callbacks.\n\t\t *\n\t\t * <h4>Example asynchronous resultFormatter</h4>\n\t\t *\n\t\t * \tfunction _formatResult(loader) {\n\t\t * \t\treturn function(success, error) {\n\t\t * \t\t\tif (errorCondition) { error(errorDetailEvent); }\n\t\t * \t\t\tsuccess(result);\n\t\t * \t\t}\n\t\t * \t}\n\t\t * @property resultFormatter\n\t\t * @type {Function}\n\t\t * @default null\n\t\t */\n\t\tthis.resultFormatter = null;\n\n\t\t// protected properties\n\t\t/**\n\t\t * The {{#crossLink \"LoadItem\"}}{{/crossLink}} this loader represents. Note that this is null in a {{#crossLink \"LoadQueue\"}}{{/crossLink}},\n\t\t * but will be available on loaders such as {{#crossLink \"XMLLoader\"}}{{/crossLink}} and {{#crossLink \"ImageLoader\"}}{{/crossLink}}.\n\t\t * @property _item\n\t\t * @type {LoadItem|Object}\n\t\t * @private\n\t\t */\n\t\tif (loadItem) {\n\t\t\tthis._item = createjs.LoadItem.create(loadItem);\n\t\t} else {\n\t\t\tthis._item = null;\n\t\t}\n\n\t\t/**\n\t\t * Whether the loader will try and load content using XHR (true) or HTML tags (false).\n\t\t * @property _preferXHR\n\t\t * @type {Boolean}\n\t\t * @private\n\t\t */\n\t\tthis._preferXHR = preferXHR;\n\n\t\t/**\n\t\t * The loaded result after it is formatted by an optional {{#crossLink \"resultFormatter\"}}{{/crossLink}}. For\n\t\t * items that are not formatted, this will be the same as the {{#crossLink \"_rawResult:property\"}}{{/crossLink}}.\n\t\t * The result is accessed using the {{#crossLink \"getResult\"}}{{/crossLink}} method.\n\t\t * @property _result\n\t\t * @type {Object|String}\n\t\t * @private\n\t\t */\n\t\tthis._result = null;\n\n\t\t/**\n\t\t * The loaded result before it is formatted. The rawResult is accessed using the {{#crossLink \"getResult\"}}{{/crossLink}}\n\t\t * method, and passing `true`.\n\t\t * @property _rawResult\n\t\t * @type {Object|String}\n\t\t * @private\n\t\t */\n\t\tthis._rawResult = null;\n\n\t\t/**\n\t\t * A list of items that loaders load behind the scenes. This does not include the main item the loader is\n\t\t * responsible for loading. Examples of loaders that have sub-items include the {{#crossLink \"SpriteSheetLoader\"}}{{/crossLink}} and\n\t\t * {{#crossLink \"ManifestLoader\"}}{{/crossLink}}.\n\t\t * @property _loadItems\n\t\t * @type {null}\n\t\t * @protected\n\t\t */\n\t\tthis._loadedItems = null;\n\n\t\t/**\n\t\t * The attribute the items loaded using tags use for the source.\n\t\t * @type {string}\n\t\t * @default null\n\t\t * @private\n\t\t */\n\t\tthis._tagSrcAttribute = null;\n\n\t\t/**\n\t\t * An HTML tag (or similar) that a loader may use to load HTML content, such as images, scripts, etc.\n\t\t * @property _tag\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._tag = null;\n\t};\n\n\tvar p = createjs.extend(AbstractLoader, createjs.EventDispatcher);\n\tvar s = AbstractLoader;\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n\t/**\n\t * Defines a POST request, use for a method value when loading data.\n\t * @property POST\n\t * @type {string}\n\t * @default post\n\t * @static\n\t */\n\ts.POST = \"POST\";\n\n\t/**\n\t * Defines a GET request, use for a method value when loading data.\n\t * @property GET\n\t * @type {string}\n\t * @default get\n\t * @static\n\t */\n\ts.GET = \"GET\";\n\n\t/**\n\t * The preload type for generic binary types. Note that images are loaded as binary files when using XHR.\n\t * @property BINARY\n\t * @type {String}\n\t * @default binary\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.BINARY = \"binary\";\n\n\t/**\n\t * The preload type for css files. CSS files are loaded using a &lt;link&gt; when loaded with XHR, or a\n\t * &lt;style&gt; tag when loaded with tags.\n\t * @property CSS\n\t * @type {String}\n\t * @default css\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.CSS = \"css\";\n\n\t/**\n\t * The preload type for image files, usually png, gif, or jpg/jpeg. Images are loaded into an &lt;image&gt; tag.\n\t * @property IMAGE\n\t * @type {String}\n\t * @default image\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.IMAGE = \"image\";\n\n\t/**\n\t * The preload type for javascript files, usually with the \"js\" file extension. JavaScript files are loaded into a\n\t * &lt;script&gt; tag.\n\t *\n\t * Since version 0.4.1+, due to how tag-loaded scripts work, all JavaScript files are automatically injected into\n\t * the body of the document to maintain parity between XHR and tag-loaded scripts. In version 0.4.0 and earlier,\n\t * only tag-loaded scripts are injected.\n\t * @property JAVASCRIPT\n\t * @type {String}\n\t * @default javascript\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.JAVASCRIPT = \"javascript\";\n\n\t/**\n\t * The preload type for json files, usually with the \"json\" file extension. JSON data is loaded and parsed into a\n\t * JavaScript object. Note that if a `callback` is present on the load item, the file will be loaded with JSONP,\n\t * no matter what the {{#crossLink \"LoadQueue/preferXHR:property\"}}{{/crossLink}} property is set to, and the JSON\n\t * must contain a matching wrapper function.\n\t * @property JSON\n\t * @type {String}\n\t * @default json\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.JSON = \"json\";\n\n\t/**\n\t * The preload type for jsonp files, usually with the \"json\" file extension. JSON data is loaded and parsed into a\n\t * JavaScript object. You are required to pass a callback parameter that matches the function wrapper in the JSON.\n\t * Note that JSONP will always be used if there is a callback present, no matter what the {{#crossLink \"LoadQueue/preferXHR:property\"}}{{/crossLink}}\n\t * property is set to.\n\t * @property JSONP\n\t * @type {String}\n\t * @default jsonp\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.JSONP = \"jsonp\";\n\n\t/**\n\t * The preload type for json-based manifest files, usually with the \"json\" file extension. The JSON data is loaded\n\t * and parsed into a JavaScript object. PreloadJS will then look for a \"manifest\" property in the JSON, which is an\n\t * Array of files to load, following the same format as the {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}\n\t * method. If a \"callback\" is specified on the manifest object, then it will be loaded using JSONP instead,\n\t * regardless of what the {{#crossLink \"LoadQueue/preferXHR:property\"}}{{/crossLink}} property is set to.\n\t * @property MANIFEST\n\t * @type {String}\n\t * @default manifest\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.MANIFEST = \"manifest\";\n\n\t/**\n\t * The preload type for sound files, usually mp3, ogg, or wav. When loading via tags, audio is loaded into an\n\t * &lt;audio&gt; tag.\n\t * @property SOUND\n\t * @type {String}\n\t * @default sound\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.SOUND = \"sound\";\n\n\t/**\n\t * The preload type for video files, usually mp4, ts, or ogg. When loading via tags, video is loaded into an\n\t * &lt;video&gt; tag.\n\t * @property VIDEO\n\t * @type {String}\n\t * @default video\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.VIDEO = \"video\";\n\n\t/**\n\t * The preload type for SpriteSheet files. SpriteSheet files are JSON files that contain string image paths.\n\t * @property SPRITESHEET\n\t * @type {String}\n\t * @default spritesheet\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.SPRITESHEET = \"spritesheet\";\n\n\t/**\n\t * The preload type for SVG files.\n\t * @property SVG\n\t * @type {String}\n\t * @default svg\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.SVG = \"svg\";\n\n\t/**\n\t * The preload type for text files, which is also the default file type if the type can not be determined. Text is\n\t * loaded as raw text.\n\t * @property TEXT\n\t * @type {String}\n\t * @default text\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.TEXT = \"text\";\n\n\t/**\n\t * The preload type for xml files. XML is loaded into an XML document.\n\t * @property XML\n\t * @type {String}\n\t * @default xml\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.XML = \"xml\";\n\n// Events\n\t/**\n\t * The {{#crossLink \"ProgressEvent\"}}{{/crossLink}} that is fired when the overall progress changes. Prior to\n\t * version 0.6.0, this was just a regular {{#crossLink \"Event\"}}{{/crossLink}}.\n\t * @event progress\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * The {{#crossLink \"Event\"}}{{/crossLink}} that is fired when a load starts.\n\t * @event loadstart\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @since 0.3.1\n\t */\n\n\t/**\n\t * The {{#crossLink \"Event\"}}{{/crossLink}} that is fired when the entire queue has been loaded.\n\t * @event complete\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * The {{#crossLink \"ErrorEvent\"}}{{/crossLink}} that is fired when the loader encounters an error. If the error was\n\t * encountered by a file, the event will contain the item that caused the error. Prior to version 0.6.0, this was\n\t * just a regular {{#crossLink \"Event\"}}{{/crossLink}}.\n\t * @event error\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * The {{#crossLink \"Event\"}}{{/crossLink}} that is fired when the loader encounters an internal file load error.\n\t * This enables loaders to maintain internal queues, and surface file load errors.\n\t * @event fileerror\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The even type (\"fileerror\")\n\t * @param {LoadItem|object} The item that encountered the error\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * The {{#crossLink \"Event\"}}{{/crossLink}} that is fired when a loader internally loads a file. This enables\n\t * loaders such as {{#crossLink \"ManifestLoader\"}}{{/crossLink}} to maintain internal {{#crossLink \"LoadQueue\"}}{{/crossLink}}s\n\t * and notify when they have loaded a file. The {{#crossLink \"LoadQueue\"}}{{/crossLink}} class dispatches a\n\t * slightly different {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}} event.\n\t * @event fileload\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type (\"fileload\")\n\t * @param {Object} item The file item which was specified in the {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}}\n\t * or {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}} call. If only a string path or tag was specified, the\n\t * object will contain that value as a `src` property.\n\t * @param {Object} result The HTML tag or parsed result of the loaded item.\n\t * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted\n\t * to a usable object.\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * The {{#crossLink \"Event\"}}{{/crossLink}} that is fired after the internal request is created, but before a load.\n\t * This allows updates to the loader for specific loading needs, such as binary or XHR image loading.\n\t * @event initialize\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type (\"initialize\")\n\t * @param {AbstractLoader} loader The loader that has been initialized.\n\t */\n\n\n\t/**\n\t * Get a reference to the manifest item that is loaded by this loader. In some cases this will be the value that was\n\t * passed into {{#crossLink \"LoadQueue\"}}{{/crossLink}} using {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}} or\n\t * {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}. However if only a String path was passed in, then it will\n\t * be a {{#crossLink \"LoadItem\"}}{{/crossLink}}.\n\t * @method getItem\n\t * @return {Object} The manifest item that this loader is responsible for loading.\n\t * @since 0.6.0\n\t */\n\tp.getItem = function () {\n\t\treturn this._item;\n\t};\n\n\t/**\n\t * Get a reference to the content that was loaded by the loader (only available after the {{#crossLink \"complete:event\"}}{{/crossLink}}\n\t * event is dispatched.\n\t * @method getResult\n\t * @param {Boolean} [raw=false] Determines if the returned result will be the formatted content, or the raw loaded\n\t * data (if it exists).\n\t * @return {Object}\n\t * @since 0.6.0\n\t */\n\tp.getResult = function (raw) {\n\t\treturn raw ? this._rawResult : this._result;\n\t};\n\n\t/**\n\t * Return the `tag` this object creates or uses for loading.\n\t * @method getTag\n\t * @return {Object} The tag instance\n\t * @since 0.6.0\n\t */\n\tp.getTag = function () {\n\t\treturn this._tag;\n\t};\n\n\t/**\n\t * Set the `tag` this item uses for loading.\n\t * @method setTag\n\t * @param {Object} tag The tag instance\n\t * @since 0.6.0\n\t */\n\tp.setTag = function(tag) {\n\t  this._tag = tag;\n\t};\n\n\t/**\n\t * Begin loading the item. This method is required when using a loader by itself.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var queue = new createjs.LoadQueue();\n\t *      queue.on(\"complete\", handleComplete);\n\t *      queue.loadManifest(fileArray, false); // Note the 2nd argument that tells the queue not to start loading yet\n\t *      queue.load();\n\t *\n\t * @method load\n\t */\n\tp.load = function () {\n\t\tthis._createRequest();\n\n\t\tthis._request.on(\"complete\", this, this);\n\t\tthis._request.on(\"progress\", this, this);\n\t\tthis._request.on(\"loadStart\", this, this);\n\t\tthis._request.on(\"abort\", this, this);\n\t\tthis._request.on(\"timeout\", this, this);\n\t\tthis._request.on(\"error\", this, this);\n\n\t\tvar evt = new createjs.Event(\"initialize\");\n\t\tevt.loader = this._request;\n\t\tthis.dispatchEvent(evt);\n\n\t\tthis._request.load();\n\t};\n\n\t/**\n\t * Close the the item. This will stop any open requests (although downloads using HTML tags may still continue in\n\t * the background), but events will not longer be dispatched.\n\t * @method cancel\n\t */\n\tp.cancel = function () {\n\t\tthis.canceled = true;\n\t\tthis.destroy();\n\t};\n\n\t/**\n\t * Clean up the loader.\n\t * @method destroy\n\t */\n\tp.destroy = function() {\n\t\tif (this._request) {\n\t\t\tthis._request.removeAllEventListeners();\n\t\t\tthis._request.destroy();\n\t\t}\n\n\t\tthis._request = null;\n\n\t\tthis._item = null;\n\t\tthis._rawResult = null;\n\t\tthis._result = null;\n\n\t\tthis._loadItems = null;\n\n\t\tthis.removeAllEventListeners();\n\t};\n\n\t/**\n\t * Get any items loaded internally by the loader. The enables loaders such as {{#crossLink \"ManifestLoader\"}}{{/crossLink}}\n\t * to expose items it loads internally.\n\t * @method getLoadedItems\n\t * @return {Array} A list of the items loaded by the loader.\n\t * @since 0.6.0\n\t */\n\tp.getLoadedItems = function () {\n\t\treturn this._loadedItems;\n\t};\n\n\n\t// Private methods\n\t/**\n\t * Create an internal request used for loading. By default, an {{#crossLink \"XHRRequest\"}}{{/crossLink}} or\n\t * {{#crossLink \"TagRequest\"}}{{/crossLink}} is created, depending on the value of {{#crossLink \"preferXHR:property\"}}{{/crossLink}}.\n\t * Other loaders may override this to use different request types, such as {{#crossLink \"ManifestLoader\"}}{{/crossLink}},\n\t * which uses {{#crossLink \"JSONLoader\"}}{{/crossLink}} or {{#crossLink \"JSONPLoader\"}}{{/crossLink}} under the hood.\n\t * @method _createRequest\n\t * @protected\n\t */\n\tp._createRequest = function() {\n\t\tif (!this._preferXHR) {\n\t\t\tthis._request = new createjs.TagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);\n\t\t} else {\n\t\t\tthis._request = new createjs.XHRRequest(this._item);\n\t\t}\n\t};\n\n\t/**\n\t * Create the HTML tag used for loading. This method does nothing by default, and needs to be implemented\n\t * by loaders that require tag loading.\n\t * @method _createTag\n\t * @param {String} src The tag source\n\t * @return {HTMLElement} The tag that was created\n\t * @protected\n\t */\n\tp._createTag = function(src) { return null; };\n\n\t/**\n\t * Dispatch a loadstart {{#crossLink \"Event\"}}{{/crossLink}}. Please see the {{#crossLink \"AbstractLoader/loadstart:event\"}}{{/crossLink}}\n\t * event for details on the event payload.\n\t * @method _sendLoadStart\n\t * @protected\n\t */\n\tp._sendLoadStart = function () {\n\t\tif (this._isCanceled()) { return; }\n\t\tthis.dispatchEvent(\"loadstart\");\n\t};\n\n\t/**\n\t * Dispatch a {{#crossLink \"ProgressEvent\"}}{{/crossLink}}.\n\t * @method _sendProgress\n\t * @param {Number | Object} value The progress of the loaded item, or an object containing <code>loaded</code>\n\t * and <code>total</code> properties.\n\t * @protected\n\t */\n\tp._sendProgress = function (value) {\n\t\tif (this._isCanceled()) { return; }\n\t\tvar event = null;\n\t\tif (typeof(value) == \"number\") {\n\t\t\tthis.progress = value;\n\t\t\tevent = new createjs.ProgressEvent(this.progress);\n\t\t} else {\n\t\t\tevent = value;\n\t\t\tthis.progress = value.loaded / value.total;\n\t\t\tevent.progress = this.progress;\n\t\t\tif (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }\n\t\t}\n\t\tthis.hasEventListener(\"progress\") && this.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Dispatch a complete {{#crossLink \"Event\"}}{{/crossLink}}. Please see the {{#crossLink \"AbstractLoader/complete:event\"}}{{/crossLink}} event\n\t * @method _sendComplete\n\t * @protected\n\t */\n\tp._sendComplete = function () {\n\t\tif (this._isCanceled()) { return; }\n\n\t\tthis.loaded = true;\n\n\t\tvar event = new createjs.Event(\"complete\");\n\t\tevent.rawResult = this._rawResult;\n\n\t\tif (this._result != null) {\n\t\t\tevent.result = this._result;\n\t\t}\n\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Dispatch an error {{#crossLink \"Event\"}}{{/crossLink}}. Please see the {{#crossLink \"AbstractLoader/error:event\"}}{{/crossLink}}\n\t * event for details on the event payload.\n\t * @method _sendError\n\t * @param {ErrorEvent} event The event object containing specific error properties.\n\t * @protected\n\t */\n\tp._sendError = function (event) {\n\t\tif (this._isCanceled() || !this.hasEventListener(\"error\")) { return; }\n\t\tif (event == null) {\n\t\t\tevent = new createjs.ErrorEvent(\"PRELOAD_ERROR_EMPTY\"); // TODO: Populate error\n\t\t}\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Determine if the load has been canceled. This is important to ensure that method calls or asynchronous events\n\t * do not cause issues after the queue has been cleaned up.\n\t * @method _isCanceled\n\t * @return {Boolean} If the loader has been canceled.\n\t * @protected\n\t */\n\tp._isCanceled = function () {\n\t\tif (window.createjs == null || this.canceled) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * A custom result formatter function, which is called just before a request dispatches its complete event. Most\n\t * loader types already have an internal formatter, but this can be user-overridden for custom formatting. The\n\t * formatted result will be available on Loaders using {{#crossLink \"getResult\"}}{{/crossLink}}, and passing `true`.\n\t * @property resultFormatter\n\t * @type Function\n\t * @return {Object} The formatted result\n\t * @since 0.6.0\n\t */\n\tp.resultFormatter = null;\n\n\t/**\n\t * Handle events from internal requests. By default, loaders will handle, and redispatch the necessary events, but\n\t * this method can be overridden for custom behaviours.\n\t * @method handleEvent\n\t * @param {Event} event The event that the internal request dispatches.\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp.handleEvent = function (event) {\n\t\tswitch (event.type) {\n\t\t\tcase \"complete\":\n\t\t\t\tthis._rawResult = event.target._response;\n\t\t\t\tvar result = this.resultFormatter && this.resultFormatter(this);\n\t\t\t\tif (result instanceof Function) {\n\t\t\t\t\tresult.call(this,\n\t\t\t\t\t\t\tcreatejs.proxy(this._resultFormatSuccess, this),\n\t\t\t\t\t\t\tcreatejs.proxy(this._resultFormatFailed, this)\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthis._result =  result || this._rawResult;\n\t\t\t\t\tthis._sendComplete();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"progress\":\n\t\t\t\tthis._sendProgress(event);\n\t\t\t\tbreak;\n\t\t\tcase \"error\":\n\t\t\t\tthis._sendError(event);\n\t\t\t\tbreak;\n\t\t\tcase \"loadstart\":\n\t\t\t\tthis._sendLoadStart();\n\t\t\t\tbreak;\n\t\t\tcase \"abort\":\n\t\t\tcase \"timeout\":\n\t\t\t\tif (!this._isCanceled()) {\n\t\t\t\t\tthis.dispatchEvent(new createjs.ErrorEvent(\"PRELOAD_\" + event.type.toUpperCase() + \"_ERROR\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\t/**\n\t * The \"success\" callback passed to {{#crossLink \"AbstractLoader/resultFormatter\"}}{{/crossLink}} asynchronous\n\t * functions.\n\t * @method _resultFormatSuccess\n\t * @param {Object} result The formatted result\n\t * @private\n\t */\n\tp._resultFormatSuccess = function (result) {\n\t\tthis._result = result;\n\t\tthis._sendComplete();\n\t};\n\n\t/**\n\t * The \"error\" callback passed to {{#crossLink \"AbstractLoader/resultFormatter\"}}{{/crossLink}} asynchronous\n\t * functions.\n\t * @method _resultFormatSuccess\n\t * @param {Object} error The error event\n\t * @private\n\t */\n\tp._resultFormatFailed = function (event) {\n\t\tthis._sendError(event);\n\t};\n\n\t/**\n\t * @method buildPath\n\t * @protected\n\t * @deprecated Use the {{#crossLink \"RequestUtils\"}}{{/crossLink}} method {{#crossLink \"RequestUtils/buildPath\"}}{{/crossLink}}\n\t * instead.\n\t */\n\tp.buildPath = function (src, data) {\n\t\treturn createjs.RequestUtils.buildPath(src, data);\n\t};\n\n\t/**\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t */\n\tp.toString = function () {\n\t\treturn \"[PreloadJS AbstractLoader]\";\n\t};\n\n\tcreatejs.AbstractLoader = createjs.promote(AbstractLoader, \"EventDispatcher\");\n\n}());\n\n//##############################################################################\n// AbstractMediaLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * The AbstractMediaLoader is a base class that handles some of the shared methods and properties of loaders that\n\t * handle HTML media elements, such as Video and Audio.\n\t * @class AbstractMediaLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @param {String} type The type of media to load. Usually \"video\" or \"audio\".\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction AbstractMediaLoader(loadItem, preferXHR, type) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, type);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = \"src\";\n\n        this.on(\"initialize\", this._updateXHR, this);\n\t};\n\n\tvar p = createjs.extend(AbstractMediaLoader, createjs.AbstractLoader);\n\n\t// static properties\n\t// public methods\n\tp.load = function () {\n\t\t// TagRequest will handle most of this, but Sound / Video need a few custom properties, so just handle them here.\n\t\tif (!this._tag) {\n\t\t\tthis._tag = this._createTag(this._item.src);\n\t\t}\n\n\t\tthis._tag.preload = \"auto\";\n\t\tthis._tag.load();\n\n\t\tthis.AbstractLoader_load();\n\t};\n\n\t// protected methods\n\t/**\n\t * Creates a new tag for loading if it doesn't exist yet.\n\t * @method _createTag\n\t * @private\n\t */\n\tp._createTag = function () {};\n\n\n\tp._createRequest = function() {\n\t\tif (!this._preferXHR) {\n\t\t\tthis._request = new createjs.MediaTagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);\n\t\t} else {\n\t\t\tthis._request = new createjs.XHRRequest(this._item);\n\t\t}\n\t};\n\n    // protected methods\n    /**\n     * Before the item loads, set its mimeType and responseType.\n     * @property _updateXHR\n     * @param {Event} event\n     * @private\n     */\n    p._updateXHR = function (event) {\n        // Only exists for XHR\n        if (event.loader.setResponseType) {\n            event.loader.setResponseType(\"blob\");\n        }\n    };\n\n\t/**\n\t * The result formatter for media files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLVideoElement|HTMLAudioElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\tthis._tag.removeEventListener && this._tag.removeEventListener(\"canplaythrough\", this._loadedHandler);\n\t\tthis._tag.onstalled = null;\n\t\tif (this._preferXHR) {\n            var URL = window.URL || window.webkitURL;\n            var result = loader.getResult(true);\n\n\t\t\tloader.getTag().src = URL.createObjectURL(result);\n\t\t}\n\t\treturn loader.getTag();\n\t};\n\n\tcreatejs.AbstractMediaLoader = createjs.promote(AbstractMediaLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// AbstractRequest.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * A base class for actual data requests, such as {{#crossLink \"XHRRequest\"}}{{/crossLink}}, {{#crossLink \"TagRequest\"}}{{/crossLink}},\n\t * and {{#crossLink \"MediaRequest\"}}{{/crossLink}}. PreloadJS loaders will typically use a data loader under the\n\t * hood to get data.\n\t * @class AbstractRequest\n\t * @param {LoadItem} item\n\t * @constructor\n\t */\n\tvar AbstractRequest = function (item) {\n\t\tthis._item = item;\n\t};\n\n\tvar p = createjs.extend(AbstractRequest, createjs.EventDispatcher);\n\n\t// public methods\n\t/**\n\t * Begin a load.\n\t * @method load\n\t */\n\tp.load =  function() {};\n\n\t/**\n\t * Clean up a request.\n\t * @method destroy\n\t */\n\tp.destroy = function() {};\n\n\t/**\n\t * Cancel an in-progress request.\n\t * @method cancel\n\t */\n\tp.cancel = function() {};\n\n\tcreatejs.AbstractRequest = createjs.promote(AbstractRequest, \"EventDispatcher\");\n\n}());\n\n//##############################################################################\n// TagRequest.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * An {{#crossLink \"AbstractRequest\"}}{{/crossLink}} that loads HTML tags, such as images and scripts.\n\t * @class TagRequest\n\t * @param {LoadItem} loadItem\n\t * @param {HTMLElement} tag\n\t * @param {String} srcAttribute The tag attribute that specifies the source, such as \"src\", \"href\", etc.\n\t */\n\tfunction TagRequest(loadItem, tag, srcAttribute) {\n\t\tthis.AbstractRequest_constructor(loadItem);\n\n\t\t// protected properties\n\t\t/**\n\t\t * The HTML tag instance that is used to load.\n\t\t * @property _tag\n\t\t * @type {HTMLElement}\n\t\t * @protected\n\t\t */\n\t\tthis._tag = tag;\n\n\t\t/**\n\t\t * The tag attribute that specifies the source, such as \"src\", \"href\", etc.\n\t\t * @property _tagSrcAttribute\n\t\t * @type {String}\n\t\t * @protected\n\t\t */\n\t\tthis._tagSrcAttribute = srcAttribute;\n\n\t\t/**\n\t\t * A method closure used for handling the tag load event.\n\t\t * @property _loadedHandler\n\t\t * @type {Function}\n\t\t * @private\n\t\t */\n\t\tthis._loadedHandler = createjs.proxy(this._handleTagComplete, this);\n\n\t\t/**\n\t\t * Determines if the element was added to the DOM automatically by PreloadJS, so it can be cleaned up after.\n\t\t * @property _addedToDOM\n\t\t * @type {Boolean}\n\t\t * @private\n\t\t */\n\t\tthis._addedToDOM = false;\n\n\t\t/**\n\t\t * Determines what the tags initial style.visibility was, so we can set it correctly after a load.\n\t\t *\n\t\t * @type {null}\n\t\t * @private\n\t\t */\n\t\tthis._startTagVisibility = null;\n\t};\n\n\tvar p = createjs.extend(TagRequest, createjs.AbstractRequest);\n\n\t// public methods\n\tp.load = function () {\n\t\tthis._tag.onload = createjs.proxy(this._handleTagComplete, this);\n\t\tthis._tag.onreadystatechange = createjs.proxy(this._handleReadyStateChange, this);\n\t\tthis._tag.onerror = createjs.proxy(this._handleError, this);\n\n\t\tvar evt = new createjs.Event(\"initialize\");\n\t\tevt.loader = this._tag;\n\n\t\tthis.dispatchEvent(evt);\n\n\t\tthis._hideTag();\n\n\t\tthis._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);\n\n\t\tthis._tag[this._tagSrcAttribute] = this._item.src;\n\n\t\t// wdg:: Append the tag AFTER setting the src, or SVG loading on iOS will fail.\n\t\tif (this._tag.parentNode == null) {\n\t\t\twindow.document.body.appendChild(this._tag);\n\t\t\tthis._addedToDOM = true;\n\t\t}\n\t};\n\n\tp.destroy = function() {\n\t\tthis._clean();\n\t\tthis._tag = null;\n\n\t\tthis.AbstractRequest_destroy();\n\t};\n\n\t// private methods\n\t/**\n\t * Handle the readyStateChange event from a tag. We need this in place of the `onload` callback (mainly SCRIPT\n\t * and LINK tags), but other cases may exist.\n\t * @method _handleReadyStateChange\n\t * @private\n\t */\n\tp._handleReadyStateChange = function () {\n\t\tclearTimeout(this._loadTimeout);\n\t\t// This is strictly for tags in browsers that do not support onload.\n\t\tvar tag = this._tag;\n\n\t\t// Complete is for old IE support.\n\t\tif (tag.readyState == \"loaded\" || tag.readyState == \"complete\") {\n\t\t\tthis._handleTagComplete();\n\t\t}\n\t};\n\n\t/**\n\t * Handle any error events from the tag.\n\t * @method _handleError\n\t * @protected\n\t */\n\tp._handleError = function() {\n\t\tthis._clean();\n\t\tthis.dispatchEvent(\"error\");\n\t};\n\n\t/**\n\t * Handle the tag's onload callback.\n\t * @method _handleTagComplete\n\t * @private\n\t */\n\tp._handleTagComplete = function () {\n\t\tthis._rawResult = this._tag;\n\t\tthis._result = this.resultFormatter && this.resultFormatter(this) || this._rawResult;\n\n\t\tthis._clean();\n\t\tthis._showTag();\n\n\t\tthis.dispatchEvent(\"complete\");\n\t};\n\n\t/**\n\t * The tag request has not loaded within the time specified in loadTimeout.\n\t * @method _handleError\n\t * @param {Object} event The XHR error event.\n\t * @private\n\t */\n\tp._handleTimeout = function () {\n\t\tthis._clean();\n\t\tthis.dispatchEvent(new createjs.Event(\"timeout\"));\n\t};\n\n\t/**\n\t * Remove event listeners, but don't destroy the request object\n\t * @method _clean\n\t * @private\n\t */\n\tp._clean = function() {\n\t\tthis._tag.onload = null;\n\t\tthis._tag.onreadystatechange = null;\n\t\tthis._tag.onerror = null;\n\t\tif (this._addedToDOM && this._tag.parentNode != null) {\n\t\t\tthis._tag.parentNode.removeChild(this._tag);\n\t\t}\n\t\tclearTimeout(this._loadTimeout);\n\t};\n\n\tp._hideTag = function() {\n\t\tthis._startTagVisibility = this._tag.style.visibility;\n\t\tthis._tag.style.visibility = \"hidden\";\n\t};\n\n\tp._showTag = function() {\n\t\tthis._tag.style.visibility = this._startTagVisibility;\n\t};\n\n\t/**\n\t * Handle a stalled audio event. The main place this happens is with HTMLAudio in Chrome when playing back audio\n\t * that is already in a load, but not complete.\n\t * @method _handleStalled\n\t * @private\n\t */\n\tp._handleStalled = function () {\n\t\t//Ignore, let the timeout take care of it. Sometimes its not really stopped.\n\t};\n\n\tcreatejs.TagRequest = createjs.promote(TagRequest, \"AbstractRequest\");\n\n}());\n\n//##############################################################################\n// MediaTagRequest.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * An {{#crossLink \"TagRequest\"}}{{/crossLink}} that loads HTML tags for video and audio.\n\t * @class MediaTagRequest\n\t * @param {LoadItem} loadItem\n\t * @param {HTMLAudioElement|HTMLVideoElement} tag\n\t * @param {String} srcAttribute The tag attribute that specifies the source, such as \"src\", \"href\", etc.\n\t * @constructor\n\t */\n\tfunction MediaTagRequest(loadItem, tag, srcAttribute) {\n\t\tthis.AbstractRequest_constructor(loadItem);\n\n\t\t// protected properties\n\t\tthis._tag = tag;\n\t\tthis._tagSrcAttribute = srcAttribute;\n\t\tthis._loadedHandler = createjs.proxy(this._handleTagComplete, this);\n\t};\n\n\tvar p = createjs.extend(MediaTagRequest, createjs.TagRequest);\n\tvar s = MediaTagRequest;\n\n\t// public methods\n\tp.load = function () {\n\t\tvar sc = createjs.proxy(this._handleStalled, this);\n\t\tthis._stalledCallback = sc;\n\n\t\tvar pc = createjs.proxy(this._handleProgress, this);\n\t\tthis._handleProgress = pc;\n\n\t\tthis._tag.addEventListener(\"stalled\", sc);\n\t\tthis._tag.addEventListener(\"progress\", pc);\n\n\t\t// This will tell us when audio is buffered enough to play through, but not when its loaded.\n\t\t// The tag doesn't keep loading in Chrome once enough has buffered, and we have decided that behaviour is sufficient.\n\t\tthis._tag.addEventListener && this._tag.addEventListener(\"canplaythrough\", this._loadedHandler, false); // canplaythrough callback doesn't work in Chrome, so we use an event.\n\n\t\tthis.TagRequest_load();\n\t};\n\n\t// private methods\n\tp._handleReadyStateChange = function () {\n\t\tclearTimeout(this._loadTimeout);\n\t\t// This is strictly for tags in browsers that do not support onload.\n\t\tvar tag = this._tag;\n\n\t\t// Complete is for old IE support.\n\t\tif (tag.readyState == \"loaded\" || tag.readyState == \"complete\") {\n\t\t\tthis._handleTagComplete();\n\t\t}\n\t};\n\n\tp._handleStalled = function () {\n\t\t//Ignore, let the timeout take care of it. Sometimes its not really stopped.\n\t};\n\n\t/**\n\t * An XHR request has reported progress.\n\t * @method _handleProgress\n\t * @param {Object} event The XHR progress event.\n\t * @private\n\t */\n\tp._handleProgress = function (event) {\n\t\tif (!event || event.loaded > 0 && event.total == 0) {\n\t\t\treturn; // Sometimes we get no \"total\", so just ignore the progress event.\n\t\t}\n\n\t\tvar newEvent = new createjs.ProgressEvent(event.loaded, event.total);\n\t\tthis.dispatchEvent(newEvent);\n\t};\n\n\t// protected methods\n\tp._clean = function () {\n\t\tthis._tag.removeEventListener && this._tag.removeEventListener(\"canplaythrough\", this._loadedHandler);\n\t\tthis._tag.removeEventListener(\"stalled\", this._stalledCallback);\n\t\tthis._tag.removeEventListener(\"progress\", this._progressCallback);\n\n\t\tthis.TagRequest__clean();\n\t};\n\n\tcreatejs.MediaTagRequest = createjs.promote(MediaTagRequest, \"TagRequest\");\n\n}());\n\n//##############################################################################\n// XHRRequest.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n// constructor\n\t/**\n\t * A preloader that loads items using XHR requests, usually XMLHttpRequest. However XDomainRequests will be used\n\t * for cross-domain requests if possible, and older versions of IE fall back on to ActiveX objects when necessary.\n\t * XHR requests load the content as text or binary data, provide progress and consistent completion events, and\n\t * can be canceled during load. Note that XHR is not supported in IE 6 or earlier, and is not recommended for\n\t * cross-domain loading.\n\t * @class XHRRequest\n\t * @constructor\n\t * @param {Object} item The object that defines the file to load. Please see the {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}}\n\t * for an overview of supported file properties.\n\t * @extends AbstractLoader\n\t */\n\tfunction XHRRequest (item) {\n\t\tthis.AbstractRequest_constructor(item);\n\n\t\t// protected properties\n\t\t/**\n\t\t * A reference to the XHR request used to load the content.\n\t\t * @property _request\n\t\t * @type {XMLHttpRequest | XDomainRequest | ActiveX.XMLHTTP}\n\t\t * @private\n\t\t */\n\t\tthis._request = null;\n\n\t\t/**\n\t\t * A manual load timeout that is used for browsers that do not support the onTimeout event on XHR (XHR level 1,\n\t\t * typically IE9).\n\t\t * @property _loadTimeout\n\t\t * @type {Number}\n\t\t * @private\n\t\t */\n\t\tthis._loadTimeout = null;\n\n\t\t/**\n\t\t * The browser's XHR (XMLHTTPRequest) version. Supported versions are 1 and 2. There is no official way to detect\n\t\t * the version, so we use capabilities to make a best guess.\n\t\t * @property _xhrLevel\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t * @private\n\t\t */\n\t\tthis._xhrLevel = 1;\n\n\t\t/**\n\t\t * The response of a loaded file. This is set because it is expensive to look up constantly. This property will be\n\t\t * null until the file is loaded.\n\t\t * @property _response\n\t\t * @type {mixed}\n\t\t * @private\n\t\t */\n\t\tthis._response = null;\n\n\t\t/**\n\t\t * The response of the loaded file before it is modified. In most cases, content is converted from raw text to\n\t\t * an HTML tag or a formatted object which is set to the <code>result</code> property, but the developer may still\n\t\t * want to access the raw content as it was loaded.\n\t\t * @property _rawResponse\n\t\t * @type {String|Object}\n\t\t * @private\n\t\t */\n\t\tthis._rawResponse = null;\n\n\t\tthis._canceled = false;\n\n\t\t// Setup our event handlers now.\n\t\tthis._handleLoadStartProxy = createjs.proxy(this._handleLoadStart, this);\n\t\tthis._handleProgressProxy = createjs.proxy(this._handleProgress, this);\n\t\tthis._handleAbortProxy = createjs.proxy(this._handleAbort, this);\n\t\tthis._handleErrorProxy = createjs.proxy(this._handleError, this);\n\t\tthis._handleTimeoutProxy = createjs.proxy(this._handleTimeout, this);\n\t\tthis._handleLoadProxy = createjs.proxy(this._handleLoad, this);\n\t\tthis._handleReadyStateChangeProxy = createjs.proxy(this._handleReadyStateChange, this);\n\n\t\tif (!this._createXHR(item)) {\n\t\t\t//TODO: Throw error?\n\t\t}\n\t};\n\n\tvar p = createjs.extend(XHRRequest, createjs.AbstractRequest);\n\n// static properties\n\t/**\n\t * A list of XMLHTTP object IDs to try when building an ActiveX object for XHR requests in earlier versions of IE.\n\t * @property ACTIVEX_VERSIONS\n\t * @type {Array}\n\t * @since 0.4.2\n\t * @private\n\t */\n\tXHRRequest.ACTIVEX_VERSIONS = [\n\t\t\"Msxml2.XMLHTTP.6.0\",\n\t\t\"Msxml2.XMLHTTP.5.0\",\n\t\t\"Msxml2.XMLHTTP.4.0\",\n\t\t\"MSXML2.XMLHTTP.3.0\",\n\t\t\"MSXML2.XMLHTTP\",\n\t\t\"Microsoft.XMLHTTP\"\n\t];\n\n// Public methods\n\t/**\n\t * Look up the loaded result.\n\t * @method getResult\n\t * @param {Boolean} [raw=false] Return a raw result instead of a formatted result. This applies to content\n\t * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be\n\t * returned instead.\n\t * @return {Object} A result object containing the content that was loaded, such as:\n\t * <ul>\n\t *      <li>An image tag (&lt;image /&gt;) for images</li>\n\t *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts loaded with tags may be added to the\n\t *      HTML head.</li>\n\t *      <li>A style tag for CSS (&lt;style /&gt;)</li>\n\t *      <li>Raw text for TEXT</li>\n\t *      <li>A formatted JavaScript object defined by JSON</li>\n\t *      <li>An XML document</li>\n\t *      <li>An binary arraybuffer loaded by XHR</li>\n\t * </ul>\n\t * Note that if a raw result is requested, but not found, the result will be returned instead.\n\t */\n\tp.getResult = function (raw) {\n\t\tif (raw && this._rawResponse) {\n\t\t\treturn this._rawResponse;\n\t\t}\n\t\treturn this._response;\n\t};\n\n\t// Overrides abstract method in AbstractRequest\n\tp.cancel = function () {\n\t\tthis.canceled = true;\n\t\tthis._clean();\n\t\tthis._request.abort();\n\t};\n\n\t// Overrides abstract method in AbstractLoader\n\tp.load = function () {\n\t\tif (this._request == null) {\n\t\t\tthis._handleError();\n\t\t\treturn;\n\t\t}\n\n\t\t//Events\n\t\tif (this._request.addEventListener != null) {\n\t\t\tthis._request.addEventListener(\"loadstart\", this._handleLoadStartProxy, false);\n\t\t\tthis._request.addEventListener(\"progress\", this._handleProgressProxy, false);\n\t\t\tthis._request.addEventListener(\"abort\", this._handleAbortProxy, false);\n\t\t\tthis._request.addEventListener(\"error\", this._handleErrorProxy, false);\n\t\t\tthis._request.addEventListener(\"timeout\", this._handleTimeoutProxy, false);\n\n\t\t\t// Note: We don't get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.\n\t\t\tthis._request.addEventListener(\"load\", this._handleLoadProxy, false);\n\t\t\tthis._request.addEventListener(\"readystatechange\", this._handleReadyStateChangeProxy, false);\n\t\t} else {\n\t\t\t// IE9 support\n\t\t\tthis._request.onloadstart = this._handleLoadStartProxy;\n\t\t\tthis._request.onprogress = this._handleProgressProxy;\n\t\t\tthis._request.onabort = this._handleAbortProxy;\n\t\t\tthis._request.onerror = this._handleErrorProxy;\n\t\t\tthis._request.ontimeout = this._handleTimeoutProxy;\n\n\t\t\t// Note: We don't get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.\n\t\t\tthis._request.onload = this._handleLoadProxy;\n\t\t\tthis._request.onreadystatechange = this._handleReadyStateChangeProxy;\n\t\t}\n\n\t\t// Set up a timeout if we don't have XHR2\n\t\tif (this._xhrLevel == 1) {\n\t\t\tthis._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);\n\t\t}\n\n\t\t// Sometimes we get back 404s immediately, particularly when there is a cross origin request.  // note this does not catch in Chrome\n\t\ttry {\n\t\t\tif (!this._item.values || this._item.method == createjs.AbstractLoader.GET) {\n\t\t\t\tthis._request.send();\n\t\t\t} else if (this._item.method == createjs.AbstractLoader.POST) {\n\t\t\t\tthis._request.send(createjs.RequestUtils.formatQueryString(this._item.values));\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.dispatchEvent(new createjs.ErrorEvent(\"XHR_SEND\", null, error));\n\t\t}\n\t};\n\n\tp.setResponseType = function (type) {\n\t\t// Some old browsers doesn't support blob, so we convert arraybuffer to blob after response is downloaded\n\t\tif (type === 'blob') {\n\t\t\ttype = window.URL ? 'blob' : 'arraybuffer';\n\t\t\tthis._responseType = type;\n\t\t}\n\t\tthis._request.responseType = type;\n\t};\n\n\t/**\n\t * Get all the response headers from the XmlHttpRequest.\n\t *\n\t * <strong>From the docs:</strong> Return all the HTTP headers, excluding headers that are a case-insensitive match\n\t * for Set-Cookie or Set-Cookie2, as a single string, with each header line separated by a U+000D CR U+000A LF pair,\n\t * excluding the status line, and with each header name and header value separated by a U+003A COLON U+0020 SPACE\n\t * pair.\n\t * @method getAllResponseHeaders\n\t * @return {String}\n\t * @since 0.4.1\n\t */\n\tp.getAllResponseHeaders = function () {\n\t\tif (this._request.getAllResponseHeaders instanceof Function) {\n\t\t\treturn this._request.getAllResponseHeaders();\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t};\n\n\t/**\n\t * Get a specific response header from the XmlHttpRequest.\n\t *\n\t * <strong>From the docs:</strong> Returns the header field value from the response of which the field name matches\n\t * header, unless the field name is Set-Cookie or Set-Cookie2.\n\t * @method getResponseHeader\n\t * @param {String} header The header name to retrieve.\n\t * @return {String}\n\t * @since 0.4.1\n\t */\n\tp.getResponseHeader = function (header) {\n\t\tif (this._request.getResponseHeader instanceof Function) {\n\t\t\treturn this._request.getResponseHeader(header);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t};\n\n// protected methods\n\t/**\n\t * The XHR request has reported progress.\n\t * @method _handleProgress\n\t * @param {Object} event The XHR progress event.\n\t * @private\n\t */\n\tp._handleProgress = function (event) {\n\t\tif (!event || event.loaded > 0 && event.total == 0) {\n\t\t\treturn; // Sometimes we get no \"total\", so just ignore the progress event.\n\t\t}\n\n\t\tvar newEvent = new createjs.ProgressEvent(event.loaded, event.total);\n\t\tthis.dispatchEvent(newEvent);\n\t};\n\n\t/**\n\t * The XHR request has reported a load start.\n\t * @method _handleLoadStart\n\t * @param {Object} event The XHR loadStart event.\n\t * @private\n\t */\n\tp._handleLoadStart = function (event) {\n\t\tclearTimeout(this._loadTimeout);\n\t\tthis.dispatchEvent(\"loadstart\");\n\t};\n\n\t/**\n\t * The XHR request has reported an abort event.\n\t * @method handleAbort\n\t * @param {Object} event The XHR abort event.\n\t * @private\n\t */\n\tp._handleAbort = function (event) {\n\t\tthis._clean();\n\t\tthis.dispatchEvent(new createjs.ErrorEvent(\"XHR_ABORTED\", null, event));\n\t};\n\n\t/**\n\t * The XHR request has reported an error event.\n\t * @method _handleError\n\t * @param {Object} event The XHR error event.\n\t * @private\n\t */\n\tp._handleError = function (event) {\n\t\tthis._clean();\n\t\tthis.dispatchEvent(new createjs.ErrorEvent(event.message));\n\t};\n\n\t/**\n\t * The XHR request has reported a readyState change. Note that older browsers (IE 7 & 8) do not provide an onload\n\t * event, so we must monitor the readyStateChange to determine if the file is loaded.\n\t * @method _handleReadyStateChange\n\t * @param {Object} event The XHR readyStateChange event.\n\t * @private\n\t */\n\tp._handleReadyStateChange = function (event) {\n\t\tif (this._request.readyState == 4) {\n\t\t\tthis._handleLoad();\n\t\t}\n\t};\n\n\t/**\n\t * The XHR request has completed. This is called by the XHR request directly, or by a readyStateChange that has\n\t * <code>request.readyState == 4</code>. Only the first call to this method will be processed.\n\t * @method _handleLoad\n\t * @param {Object} event The XHR load event.\n\t * @private\n\t */\n\tp._handleLoad = function (event) {\n\t\tif (this.loaded) {\n\t\t\treturn;\n\t\t}\n\t\tthis.loaded = true;\n\n\t\tvar error = this._checkError();\n\t\tif (error) {\n\t\t\tthis._handleError(error);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._response = this._getResponse();\n\t\t// Convert arraybuffer back to blob\n\t\tif (this._responseType === 'arraybuffer') {\n\t\t\ttry {\n\t\t\t\tthis._response = new Blob([this._response]);\n\t\t\t} catch (e) {\n\t\t\t\t// Fallback to use BlobBuilder if Blob constructor is not supported\n\t\t\t\t// Tested on Android 2.3 ~ 4.2 and iOS5 safari\n\t\t\t\twindow.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\t\t\t\tif (e.name === 'TypeError' && window.BlobBuilder) {\n\t\t\t\t\tvar builder = new BlobBuilder();\n\t\t\t\t\tbuilder.append(this._response);\n\t\t\t\t\tthis._response = builder.getBlob();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._clean();\n\n\t\tthis.dispatchEvent(new createjs.Event(\"complete\"));\n\t};\n\n\t/**\n\t * The XHR request has timed out. This is called by the XHR request directly, or via a <code>setTimeout</code>\n\t * callback.\n\t * @method _handleTimeout\n\t * @param {Object} [event] The XHR timeout event. This is occasionally null when called by the backup setTimeout.\n\t * @private\n\t */\n\tp._handleTimeout = function (event) {\n\t\tthis._clean();\n\n\t\tthis.dispatchEvent(new createjs.ErrorEvent(\"PRELOAD_TIMEOUT\", null, event));\n\t};\n\n// Protected\n\t/**\n\t * Determine if there is an error in the current load. This checks the status of the request for problem codes. Note\n\t * that this does not check for an actual response. Currently, it only checks for 404 or 0 error code.\n\t * @method _checkError\n\t * @return {int} If the request status returns an error code.\n\t * @private\n\t */\n\tp._checkError = function () {\n\t\t//LM: Probably need additional handlers here, maybe 501\n\t\tvar status = parseInt(this._request.status);\n\n\t\tswitch (status) {\n\t\t\tcase 404:   // Not Found\n\t\t\tcase 0:     // Not Loaded\n\t\t\t\treturn new Error(status);\n\t\t}\n\t\treturn null;\n\t};\n\n\t/**\n\t * Validate the response. Different browsers have different approaches, some of which throw errors when accessed\n\t * in other browsers. If there is no response, the <code>_response</code> property will remain null.\n\t * @method _getResponse\n\t * @private\n\t */\n\tp._getResponse = function () {\n\t\tif (this._response != null) {\n\t\t\treturn this._response;\n\t\t}\n\n\t\tif (this._request.response != null) {\n\t\t\treturn this._request.response;\n\t\t}\n\n\t\t// Android 2.2 uses .responseText\n\t\ttry {\n\t\t\tif (this._request.responseText != null) {\n\t\t\t\treturn this._request.responseText;\n\t\t\t}\n\t\t} catch (e) {\n\t\t}\n\n\t\t// When loading XML, IE9 does not return .response, instead it returns responseXML.xml\n\t\ttry {\n\t\t\tif (this._request.responseXML != null) {\n\t\t\t\treturn this._request.responseXML;\n\t\t\t}\n\t\t} catch (e) {\n\t\t}\n\n\t\treturn null;\n\t};\n\n\t/**\n\t * Create an XHR request. Depending on a number of factors, we get totally different results.\n\t * <ol><li>Some browsers get an <code>XDomainRequest</code> when loading cross-domain.</li>\n\t *      <li>XMLHttpRequest are created when available.</li>\n\t *      <li>ActiveX.XMLHTTP objects are used in older IE browsers.</li>\n\t *      <li>Text requests override the mime type if possible</li>\n\t *      <li>Origin headers are sent for crossdomain requests in some browsers.</li>\n\t *      <li>Binary loads set the response type to \"arraybuffer\"</li></ol>\n\t * @method _createXHR\n\t * @param {Object} item The requested item that is being loaded.\n\t * @return {Boolean} If an XHR request or equivalent was successfully created.\n\t * @private\n\t */\n\tp._createXHR = function (item) {\n\t\t// Check for cross-domain loads. We can't fully support them, but we can try.\n\t\tvar crossdomain = createjs.RequestUtils.isCrossDomain(item);\n\t\tvar headers = {};\n\n\t\t// Create the request. Fallback to whatever support we have.\n\t\tvar req = null;\n\t\tif (window.XMLHttpRequest) {\n\t\t\treq = new XMLHttpRequest();\n\t\t\t// This is 8 or 9, so use XDomainRequest instead.\n\t\t\tif (crossdomain && req.withCredentials === undefined && window.XDomainRequest) {\n\t\t\t\treq = new XDomainRequest();\n\t\t\t}\n\t\t} else { // Old IE versions use a different approach\n\t\t\tfor (var i = 0, l = s.ACTIVEX_VERSIONS.length; i < l; i++) {\n\t\t\t\tvar axVersion = s.ACTIVEX_VERSIONS[i];\n\t\t\t\ttry {\n\t\t\t\t\treq = new ActiveXObject(axVersion);\n\t\t\t\t\tbreak;\n\t\t\t\t} catch (e) {\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (req == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Default to utf-8 for Text requests.\n\t\tif (item.mimeType == null && createjs.RequestUtils.isText(item.type)) {\n\t\t\titem.mimeType = \"text/plain; charset=utf-8\";\n\t\t}\n\n\t\t// IE9 doesn't support overrideMimeType(), so we need to check for it.\n\t\tif (item.mimeType && req.overrideMimeType) {\n\t\t\treq.overrideMimeType(item.mimeType);\n\t\t}\n\n\t\t// Determine the XHR level\n\t\tthis._xhrLevel = (typeof req.responseType === \"string\") ? 2 : 1;\n\n\t\tvar src = null;\n\t\tif (item.method == createjs.AbstractLoader.GET) {\n\t\t\tsrc = createjs.RequestUtils.buildPath(item.src, item.values);\n\t\t} else {\n\t\t\tsrc = item.src;\n\t\t}\n\n\t\t// Open the request.  Set cross-domain flags if it is supported (XHR level 1 only)\n\t\treq.open(item.method || createjs.AbstractLoader.GET, src, true);\n\n\t\tif (crossdomain && req instanceof XMLHttpRequest && this._xhrLevel == 1) {\n\t\t\theaders[\"Origin\"] = location.origin;\n\t\t}\n\n\t\t// To send data we need to set the Content-type header)\n\t\tif (item.values && item.method == createjs.AbstractLoader.POST) {\n\t\t\theaders[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n\t\t}\n\n\t\tif (!crossdomain && !headers[\"X-Requested-With\"]) {\n\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t}\n\n\t\tif (item.headers) {\n\t\t\tfor (var n in item.headers) {\n\t\t\t\theaders[n] = item.headers[n];\n\t\t\t}\n\t\t}\n\n\t\tfor (n in headers) {\n\t\t\treq.setRequestHeader(n, headers[n])\n\t\t}\n\n\t\tif (req instanceof XMLHttpRequest && item.withCredentials !== undefined) {\n\t\t\treq.withCredentials = item.withCredentials;\n\t\t}\n\n\t\tthis._request = req;\n\n\t\treturn true;\n\t};\n\n\t/**\n\t * A request has completed (or failed or canceled), and needs to be disposed.\n\t * @method _clean\n\t * @private\n\t */\n\tp._clean = function () {\n\t\tclearTimeout(this._loadTimeout);\n\n\t\tif (this._request.removeEventListener != null) {\n\t\t\tthis._request.removeEventListener(\"loadstart\", this._handleLoadStartProxy);\n\t\t\tthis._request.removeEventListener(\"progress\", this._handleProgressProxy);\n\t\t\tthis._request.removeEventListener(\"abort\", this._handleAbortProxy);\n\t\t\tthis._request.removeEventListener(\"error\", this._handleErrorProxy);\n\t\t\tthis._request.removeEventListener(\"timeout\", this._handleTimeoutProxy);\n\t\t\tthis._request.removeEventListener(\"load\", this._handleLoadProxy);\n\t\t\tthis._request.removeEventListener(\"readystatechange\", this._handleReadyStateChangeProxy);\n\t\t} else {\n\t\t\tthis._request.onloadstart = null;\n\t\t\tthis._request.onprogress = null;\n\t\t\tthis._request.onabort = null;\n\t\t\tthis._request.onerror = null;\n\t\t\tthis._request.ontimeout = null;\n\t\t\tthis._request.onload = null;\n\t\t\tthis._request.onreadystatechange = null;\n\t\t}\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[PreloadJS XHRRequest]\";\n\t};\n\n\tcreatejs.XHRRequest = createjs.promote(XHRRequest, \"AbstractRequest\");\n\n}());\n\n//##############################################################################\n// LoadQueue.js\n//##############################################################################\n\n/*\n TODO: WINDOWS ISSUES\n * No error for HTML audio in IE 678\n * SVG no failure error in IE 67 (maybe 8) TAGS AND XHR\n * No script complete handler in IE 67 TAGS (XHR is fine)\n * No XML/JSON in IE6 TAGS\n * Need to hide loading SVG in Opera TAGS\n * No CSS onload/readystatechange in Safari or Android TAGS (requires rule checking)\n * SVG no load or failure in Opera XHR\n * Reported issues with IE7/8\n */\n\n(function () {\n\t\"use strict\";\n\n// constructor\n\t/**\n\t * The LoadQueue class is the main API for preloading content. LoadQueue is a load manager, which can preload either\n\t * a single file, or queue of files.\n\t *\n\t * <b>Creating a Queue</b><br />\n\t * To use LoadQueue, create a LoadQueue instance. If you want to force tag loading where possible, set the preferXHR\n\t * argument to false.\n\t *\n\t *      var queue = new createjs.LoadQueue(true);\n\t *\n\t * <b>Listening for Events</b><br />\n\t * Add any listeners you want to the queue. Since PreloadJS 0.3.0, the {{#crossLink \"EventDispatcher\"}}{{/crossLink}}\n\t * lets you add as many listeners as you want for events. You can subscribe to the following events:<ul>\n\t *     <li>{{#crossLink \"AbstractLoader/complete:event\"}}{{/crossLink}}: fired when a queue completes loading all\n\t *     files</li>\n\t *     <li>{{#crossLink \"AbstractLoader/error:event\"}}{{/crossLink}}: fired when the queue encounters an error with\n\t *     any file.</li>\n\t *     <li>{{#crossLink \"AbstractLoader/progress:event\"}}{{/crossLink}}: Progress for the entire queue has\n\t *     changed.</li>\n\t *     <li>{{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}}: A single file has completed loading.</li>\n\t *     <li>{{#crossLink \"LoadQueue/fileprogress:event\"}}{{/crossLink}}: Progress for a single file has changes. Note\n\t *     that only files loaded with XHR (or possibly by plugins) will fire progress events other than 0 or 100%.</li>\n\t * </ul>\n\t *\n\t *      queue.on(\"fileload\", handleFileLoad, this);\n\t *      queue.on(\"complete\", handleComplete, this);\n\t *\n\t * <b>Adding files and manifests</b><br />\n\t * Add files you want to load using {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}} or add multiple files at a\n\t * time using a list or a manifest definition using {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}. Files are\n\t * appended to the end of the active queue, so you can use these methods as many times as you like, whenever you\n\t * like.\n\t *\n\t *      queue.loadFile(\"filePath/file.jpg\");\n\t *      queue.loadFile({id:\"image\", src:\"filePath/file.jpg\"});\n\t *      queue.loadManifest([\"filePath/file.jpg\", {id:\"image\", src:\"filePath/file.jpg\"}]);\n\t *\n\t *      // Use an external manifest\n\t *      queue.loadManifest(\"path/to/manifest.json\");\n\t *      queue.loadManifest({src:\"manifest.json\", type:\"manifest\"});\n\t *\n\t * If you pass `false` as the `loadNow` parameter, the queue will not kick of the load of the files, but it will not\n\t * stop if it has already been started. Call the {{#crossLink \"AbstractLoader/load\"}}{{/crossLink}} method to begin\n\t * a paused queue. Note that a paused queue will automatically resume when new files are added to it with a\n\t * `loadNow` argument of `true`.\n\t *\n\t *      queue.load();\n\t *\n\t * <b>File Types</b><br />\n\t * The file type of a manifest item is auto-determined by the file extension. The pattern matching in PreloadJS\n\t * should handle the majority of standard file and url formats, and works with common file extensions. If you have\n\t * either a non-standard file extension, or are serving the file using a proxy script, then you can pass in a\n\t * <code>type</code> property with any manifest item.\n\t *\n\t *      queue.loadFile({src:\"path/to/myFile.mp3x\", type:createjs.AbstractLoader.SOUND});\n\t *\n\t *      // Note that PreloadJS will not read a file extension from the query string\n\t *      queue.loadFile({src:\"http://server.com/proxy?file=image.jpg\", type:createjs.AbstractLoader.IMAGE});\n\t *\n\t * Supported types are defined on the {{#crossLink \"AbstractLoader\"}}{{/crossLink}} class, and include:\n\t * <ul>\n\t *     <li>{{#crossLink \"AbstractLoader/BINARY:property\"}}{{/crossLink}}: Raw binary data via XHR</li>\n\t *     <li>{{#crossLink \"AbstractLoader/CSS:property\"}}{{/crossLink}}: CSS files</li>\n\t *     <li>{{#crossLink \"AbstractLoader/IMAGE:property\"}}{{/crossLink}}: Common image formats</li>\n\t *     <li>{{#crossLink \"AbstractLoader/JAVASCRIPT:property\"}}{{/crossLink}}: JavaScript files</li>\n\t *     <li>{{#crossLink \"AbstractLoader/JSON:property\"}}{{/crossLink}}: JSON data</li>\n\t *     <li>{{#crossLink \"AbstractLoader/JSONP:property\"}}{{/crossLink}}: JSON files cross-domain</li>\n\t *     <li>{{#crossLink \"AbstractLoader/MANIFEST:property\"}}{{/crossLink}}: A list of files to load in JSON format, see\n\t *     {{#crossLink \"AbstractLoader/loadManifest\"}}{{/crossLink}}</li>\n\t *     <li>{{#crossLink \"AbstractLoader/SOUND:property\"}}{{/crossLink}}: Audio file formats</li>\n\t *     <li>{{#crossLink \"AbstractLoader/SPRITESHEET:property\"}}{{/crossLink}}: JSON SpriteSheet definitions. This\n\t *     will also load sub-images, and provide a {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instance.</li>\n\t *     <li>{{#crossLink \"AbstractLoader/SVG:property\"}}{{/crossLink}}: SVG files</li>\n\t *     <li>{{#crossLink \"AbstractLoader/TEXT:property\"}}{{/crossLink}}: Text files - XHR only</li>\n     *     <li>{{#crossLink \"AbstractLoader/VIDEO:property\"}}{{/crossLink}}: Video objects</li>\n\t *     <li>{{#crossLink \"AbstractLoader/XML:property\"}}{{/crossLink}}: XML data</li>\n\t * </ul>\n\t *\n\t * <em>Note: Loader types used to be defined on LoadQueue, but have been moved to AbstractLoader for better\n\t * portability of loader classes, which can be used individually now. The properties on LoadQueue still exist, but\n\t * are deprecated.</em>\n\t *\n\t * <b>Handling Results</b><br />\n\t * When a file is finished downloading, a {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}} event is\n\t * dispatched. In an example above, there is an event listener snippet for fileload. Loaded files are usually a\n\t * formatted object that can be used immediately, including:\n\t * <ul>\n\t *     <li>Binary: The binary loaded result</li>\n\t *     <li>CSS: A &lt;link /&gt; tag</li>\n\t *     <li>Image: An &lt;img /&gt; tag</li>\n\t *     <li>JavaScript: A &lt;script /&gt; tag</li>\n\t *     <li>JSON/JSONP: A formatted JavaScript Object</li>\n\t *     <li>Manifest: A JavaScript object.\n\t *     <li>Sound: An &lt;audio /&gt; tag</a>\n\t *     <li>SpriteSheet: A {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instance, containing loaded images.\n\t *     <li>SVG: An &lt;object /&gt; tag</li>\n\t *     <li>Text: Raw text</li>\n     *     <li>Video: A Video DOM node</li>\n\t *     <li>XML: An XML DOM node</li>\n\t * </ul>\n\t *\n\t *      function handleFileLoad(event) {\n\t *          var item = event.item; // A reference to the item that was passed in to the LoadQueue\n\t *          var type = item.type;\n\t *\n\t *          // Add any images to the page body.\n\t *          if (type == createjs.LoadQueue.IMAGE) {\n\t *              document.body.appendChild(event.result);\n\t *          }\n\t *      }\n\t *\n\t * At any time after the file has been loaded (usually after the queue has completed), any result can be looked up\n\t * via its \"id\" using {{#crossLink \"LoadQueue/getResult\"}}{{/crossLink}}. If no id was provided, then the\n\t * \"src\" or file path can be used instead, including the `path` defined by a manifest, but <strong>not including</strong>\n\t * a base path defined on the LoadQueue. It is recommended to always pass an id if you want to look up content.\n\t *\n\t *      var image = queue.getResult(\"image\");\n\t *      document.body.appendChild(image);\n\t *\n\t * Raw loaded content can be accessed using the <code>rawResult</code> property of the {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}}\n\t * event, or can be looked up using {{#crossLink \"LoadQueue/getResult\"}}{{/crossLink}}, passing `true` as the 2nd\n\t * argument. This is only applicable for content that has been parsed for the browser, specifically: JavaScript,\n\t * CSS, XML, SVG, and JSON objects, or anything loaded with XHR.\n\t *\n\t *      var image = queue.getResult(\"image\", true); // load the binary image data loaded with XHR.\n\t *\n\t * <b>Plugins</b><br />\n\t * LoadQueue has a simple plugin architecture to help process and preload content. For example, to preload audio,\n\t * make sure to install the <a href=\"http://soundjs.com\">SoundJS</a> Sound class, which will help load HTML audio,\n\t * Flash audio, and WebAudio files. This should be installed <strong>before</strong> loading any audio files.\n\t *\n\t *      queue.installPlugin(createjs.Sound);\n\t *\n\t * <h4>Known Browser Issues</h4>\n\t * <ul>\n\t *     <li>Browsers without audio support can not load audio files.</li>\n\t *     <li>Safari on Mac OS X can only play HTML audio if QuickTime is installed</li>\n\t *     <li>HTML Audio tags will only download until their <code>canPlayThrough</code> event is fired. Browsers other\n\t *     than Chrome will continue to download in the background.</li>\n\t *     <li>When loading scripts using tags, they are automatically added to the document.</li>\n\t *     <li>Scripts loaded via XHR may not be properly inspectable with browser tools.</li>\n\t *     <li>IE6 and IE7 (and some other browsers) may not be able to load XML, Text, or JSON, since they require\n\t *     XHR to work.</li>\n\t *     <li>Content loaded via tags will not show progress, and will continue to download in the background when\n\t *     canceled, although no events will be dispatched.</li>\n\t * </ul>\n\t *\n\t * @class LoadQueue\n\t * @param {Boolean} [preferXHR=true] Determines whether the preload instance will favor loading with XHR (XML HTTP\n\t * Requests), or HTML tags. When this is `false`, the queue will use tag loading when possible, and fall back on XHR\n\t * when necessary.\n\t * @param {String} [basePath=\"\"] A path that will be prepended on to the source parameter of all items in the queue\n\t * before they are loaded.  Sources beginning with a protocol such as `http://` or a relative path such as `../`\n\t * will not receive a base path.\n\t * @param {String|Boolean} [crossOrigin=\"\"] An optional flag to support images loaded from a CORS-enabled server. To\n\t * use it, set this value to `true`, which will default the crossOrigin property on images to \"Anonymous\". Any\n\t * string value will be passed through, but only \"\" and \"Anonymous\" are recommended. <strong>Note: The crossOrigin\n\t * parameter is deprecated. Use LoadItem.crossOrigin instead</strong>\n\t *\n\t * @constructor\n\t * @extends AbstractLoader\n\t */\n\tfunction LoadQueue (preferXHR, basePath, crossOrigin) {\n\t\tthis.AbstractLoader_constructor();\n\n\t\t/**\n\t\t * An array of the plugins registered using {{#crossLink \"LoadQueue/installPlugin\"}}{{/crossLink}}.\n\t\t * @property _plugins\n\t\t * @type {Array}\n\t\t * @private\n\t\t * @since 0.6.1\n\t\t */\n\t\tthis._plugins = [];\n\n\t\t/**\n\t\t * An object hash of callbacks that are fired for each file type before the file is loaded, giving plugins the\n\t\t * ability to override properties of the load. Please see the {{#crossLink \"LoadQueue/installPlugin\"}}{{/crossLink}}\n\t\t * method for more information.\n\t\t * @property _typeCallbacks\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._typeCallbacks = {};\n\n\t\t/**\n\t\t * An object hash of callbacks that are fired for each file extension before the file is loaded, giving plugins the\n\t\t * ability to override properties of the load. Please see the {{#crossLink \"LoadQueue/installPlugin\"}}{{/crossLink}}\n\t\t * method for more information.\n\t\t * @property _extensionCallbacks\n\t\t * @type {null}\n\t\t * @private\n\t\t */\n\t\tthis._extensionCallbacks = {};\n\n\t\t/**\n\t\t * The next preload queue to process when this one is complete. If an error is thrown in the current queue, and\n\t\t * {{#crossLink \"LoadQueue/stopOnError:property\"}}{{/crossLink}} is `true`, the next queue will not be processed.\n\t\t * @property next\n\t\t * @type {LoadQueue}\n\t\t * @default null\n\t\t */\n\t\tthis.next = null;\n\n\t\t/**\n\t\t * Ensure loaded scripts \"complete\" in the order they are specified. Loaded scripts are added to the document head\n\t\t * once they are loaded. Scripts loaded via tags will load one-at-a-time when this property is `true`, whereas\n\t\t * scripts loaded using XHR can load in any order, but will \"finish\" and be added to the document in the order\n\t\t * specified.\n\t\t *\n\t\t * Any items can be set to load in order by setting the {{#crossLink \"maintainOrder:property\"}}{{/crossLink}}\n\t\t * property on the load item, or by ensuring that only one connection can be open at a time using\n\t\t * {{#crossLink \"LoadQueue/setMaxConnections\"}}{{/crossLink}}. Note that when the `maintainScriptOrder` property\n\t\t * is set to `true`, scripts items are automatically set to `maintainOrder=true`, and changing the\n\t\t * `maintainScriptOrder` to `false` during a load will not change items already in a queue.\n\t\t *\n\t\t * <h4>Example</h4>\n\t\t *\n\t\t *      var queue = new createjs.LoadQueue();\n\t\t *      queue.setMaxConnections(3); // Set a higher number to load multiple items at once\n\t\t *      queue.maintainScriptOrder = true; // Ensure scripts are loaded in order\n\t\t *      queue.loadManifest([\n\t\t *          \"script1.js\",\n\t\t *          \"script2.js\",\n\t\t *          \"image.png\", // Load any time\n\t\t *          {src: \"image2.png\", maintainOrder: true} // Will wait for script2.js\n\t\t *          \"image3.png\",\n\t\t *          \"script3.js\" // Will wait for image2.png before loading (or completing when loading with XHR)\n\t\t *      ]);\n\t\t *\n\t\t * @property maintainScriptOrder\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.maintainScriptOrder = true;\n\n\t\t/**\n\t\t * Determines if the LoadQueue will stop processing the current queue when an error is encountered.\n\t\t * @property stopOnError\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.stopOnError = false;\n\n\t\t/**\n\t\t * The number of maximum open connections that a loadQueue tries to maintain. Please see\n\t\t * {{#crossLink \"LoadQueue/setMaxConnections\"}}{{/crossLink}} for more information.\n\t\t * @property _maxConnections\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t * @private\n\t\t */\n\t\tthis._maxConnections = 1;\n\n\t\t/**\n\t\t * An internal list of all the default Loaders that are included with PreloadJS. Before an item is loaded, the\n\t\t * available loader list is iterated, in the order they are included, and as soon as a loader indicates it can\n\t\t * handle the content, it will be selected. The default loader, ({{#crossLink \"TextLoader\"}}{{/crossLink}} is\n\t\t * last in the list, so it will be used if no other match is found. Typically, loaders will match based on the\n\t\t * {{#crossLink \"LoadItem/type\"}}{{/crossLink}}, which is automatically determined using the file extension of\n\t\t * the {{#crossLink \"LoadItem/src:property\"}}{{/crossLink}}.\n\t\t *\n\t\t * Loaders can be removed from PreloadJS by simply not including them.\n\t\t *\n\t\t * Custom loaders installed using {{#crossLink \"registerLoader\"}}{{/crossLink}} will be prepended to this list\n\t\t * so that they are checked first.\n\t\t * @property _availableLoaders\n\t\t * @type {Array}\n\t\t * @private\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._availableLoaders = [\n\t\t\tcreatejs.ImageLoader,\n\t\t\tcreatejs.JavaScriptLoader,\n\t\t\tcreatejs.CSSLoader,\n\t\t\tcreatejs.JSONLoader,\n\t\t\tcreatejs.JSONPLoader,\n\t\t\tcreatejs.SoundLoader,\n\t\t\tcreatejs.ManifestLoader,\n\t\t\tcreatejs.SpriteSheetLoader,\n\t\t\tcreatejs.XMLLoader,\n\t\t\tcreatejs.SVGLoader,\n\t\t\tcreatejs.BinaryLoader,\n\t\t\tcreatejs.VideoLoader,\n\t\t\tcreatejs.TextLoader\n\t\t];\n\n\t\t/**\n\t\t * The number of built in loaders, so they can't be removed by {{#crossLink \"unregisterLoader\"}}{{/crossLink}.\n\t\t\t\t * @property _defaultLoaderLength\n\t\t * @type {Number}\n\t\t * @private\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._defaultLoaderLength = this._availableLoaders.length;\n\n\t\tthis.init(preferXHR, basePath, crossOrigin);\n\t}\n\n\tvar p = createjs.extend(LoadQueue, createjs.AbstractLoader);\n\tvar s = LoadQueue;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\t/**\n\t * An internal initialization method, which is used for initial set up, but also to reset the LoadQueue.\n\t * @method init\n\t * @param preferXHR\n\t * @param basePath\n\t * @param crossOrigin\n\t * @private\n\t */\n\tp.init = function (preferXHR, basePath, crossOrigin) {\n\n\t\t// public properties\n\t\t/**\n\t\t * @property useXHR\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t * @deprecated Use preferXHR instead.\n\t\t */\n\t\tthis.useXHR = true;\n\n\t\t/**\n\t\t * Try and use XMLHttpRequest (XHR) when possible. Note that LoadQueue will default to tag loading or XHR\n\t\t * loading depending on the requirements for a media type. For example, HTML audio can not be loaded with XHR,\n\t\t * and plain text can not be loaded with tags, so it will default the the correct type instead of using the\n\t\t * user-defined type.\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis.preferXHR = true; //TODO: Get/Set\n\t\tthis._preferXHR = true;\n\t\tthis.setPreferXHR(preferXHR);\n\n\t\t// protected properties\n\t\t/**\n\t\t * Whether the queue is currently paused or not.\n\t\t * @property _paused\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis._paused = false;\n\n\t\t/**\n\t\t * A path that will be prepended on to the item's {{#crossLink \"LoadItem/src:property\"}}{{/crossLink}}. The\n\t\t * `_basePath` property will only be used if an item's source is relative, and does not include a protocol such\n\t\t * as `http://`, or a relative path such as `../`.\n\t\t * @property _basePath\n\t\t * @type {String}\n\t\t * @private\n\t\t * @since 0.3.1\n\t\t */\n\t\tthis._basePath = basePath;\n\n\t\t/**\n\t\t * An optional flag to set on images that are loaded using PreloadJS, which enables CORS support. Images loaded\n\t\t * cross-domain by servers that support CORS require the crossOrigin flag to be loaded and interacted with by\n\t\t * a canvas. When loading locally, or with a server with no CORS support, this flag can cause other security issues,\n\t\t * so it is recommended to only set it if you are sure the server supports it. Currently, supported values are \"\"\n\t\t * and \"Anonymous\".\n\t\t * @property _crossOrigin\n\t\t * @type {String}\n\t\t * @default \"\"\n\t\t * @private\n\t\t * @since 0.4.1\n\t\t */\n\t\tthis._crossOrigin = crossOrigin;\n\n\t\t/**\n\t\t * Determines if the loadStart event was dispatched already. This event is only fired one time, when the first\n\t\t * file is requested.\n\t\t * @property _loadStartWasDispatched\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @private\n\t\t */\n\t\tthis._loadStartWasDispatched = false;\n\n\t\t/**\n\t\t * Determines if there is currently a script loading. This helps ensure that only a single script loads at once when\n\t\t * using a script tag to do preloading.\n\t\t * @property _currentlyLoadingScript\n\t\t * @type {Boolean}\n\t\t * @private\n\t\t */\n\t\tthis._currentlyLoadingScript = null;\n\n\t\t/**\n\t\t * An array containing the currently downloading files.\n\t\t * @property _currentLoads\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._currentLoads = [];\n\n\t\t/**\n\t\t * An array containing the queued items that have not yet started downloading.\n\t\t * @property _loadQueue\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._loadQueue = [];\n\n\t\t/**\n\t\t * An array containing downloads that have not completed, so that the LoadQueue can be properly reset.\n\t\t * @property _loadQueueBackup\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._loadQueueBackup = [];\n\n\t\t/**\n\t\t * An object hash of items that have finished downloading, indexed by the {{#crossLink \"LoadItem\"}}{{/crossLink}}\n\t\t * id.\n\t\t * @property _loadItemsById\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._loadItemsById = {};\n\n\t\t/**\n\t\t * An object hash of items that have finished downloading, indexed by {{#crossLink \"LoadItem\"}}{{/crossLink}}\n\t\t * source.\n\t\t * @property _loadItemsBySrc\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._loadItemsBySrc = {};\n\n\t\t/**\n\t\t * An object hash of loaded items, indexed by the ID of the {{#crossLink \"LoadItem\"}}{{/crossLink}}.\n\t\t * @property _loadedResults\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._loadedResults = {};\n\n\t\t/**\n\t\t * An object hash of un-parsed loaded items, indexed by the ID of the {{#crossLink \"LoadItem\"}}{{/crossLink}}.\n\t\t * @property _loadedRawResults\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._loadedRawResults = {};\n\n\t\t/**\n\t\t * The number of items that have been requested. This helps manage an overall progress without knowing how large\n\t\t * the files are before they are downloaded. This does not include items inside of loaders such as the\n\t\t * {{#crossLink \"ManifestLoader\"}}{{/crossLink}}.\n\t\t * @property _numItems\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @private\n\t\t */\n\t\tthis._numItems = 0;\n\n\t\t/**\n\t\t * The number of items that have completed loaded. This helps manage an overall progress without knowing how large\n\t\t * the files are before they are downloaded.\n\t\t * @property _numItemsLoaded\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @private\n\t\t */\n\t\tthis._numItemsLoaded = 0;\n\n\t\t/**\n\t\t * A list of scripts in the order they were requested. This helps ensure that scripts are \"completed\" in the right\n\t\t * order.\n\t\t * @property _scriptOrder\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._scriptOrder = [];\n\n\t\t/**\n\t\t * A list of scripts that have been loaded. Items are added to this list as <code>null</code> when they are\n\t\t * requested, contain the loaded item if it has completed, but not been dispatched to the user, and <code>true</true>\n\t\t * once they are complete and have been dispatched.\n\t\t * @property _loadedScripts\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._loadedScripts = [];\n\n\t\t/**\n\t\t * The last progress amount. This is used to suppress duplicate progress events.\n\t\t * @property _lastProgress\n\t\t * @type {Number}\n\t\t * @private\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._lastProgress = NaN;\n\n\t};\n\n// static properties\n\t/**\n\t * The time in milliseconds to assume a load has failed. An {{#crossLink \"AbstractLoader/error:event\"}}{{/crossLink}}\n\t * event is dispatched if the timeout is reached before any data is received.\n\t * @property loadTimeout\n\t * @type {Number}\n\t * @default 8000\n\t * @static\n\t * @since 0.4.1\n\t * @deprecated In favour of {{#crossLink \"LoadItem/LOAD_TIMEOUT_DEFAULT:property}}{{/crossLink}} property.\n\t */\n\ts.loadTimeout = 8000;\n\n\t/**\n\t * The time in milliseconds to assume a load has failed.\n\t * @property LOAD_TIMEOUT\n\t * @type {Number}\n\t * @default 0\n\t * @deprecated in favor of the {{#crossLink \"LoadQueue/loadTimeout:property\"}}{{/crossLink}} property.\n\t */\n\ts.LOAD_TIMEOUT = 0;\n\n// Preload Types\n\t/**\n\t * @property BINARY\n\t * @type {String}\n\t * @default binary\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/BINARY:property\"}}{{/crossLink}} instead.\n\t */\n\ts.BINARY = createjs.AbstractLoader.BINARY;\n\n\t/**\n\t * @property CSS\n\t * @type {String}\n\t * @default css\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/CSS:property\"}}{{/crossLink}} instead.\n\t */\n\ts.CSS = createjs.AbstractLoader.CSS;\n\n\t/**\n\t * @property IMAGE\n\t * @type {String}\n\t * @default image\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/CSS:property\"}}{{/crossLink}} instead.\n\t */\n\ts.IMAGE = createjs.AbstractLoader.IMAGE;\n\n\t/**\n\t * @property JAVASCRIPT\n\t * @type {String}\n\t * @default javascript\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/JAVASCRIPT:property\"}}{{/crossLink}} instead.\n\t */\n\ts.JAVASCRIPT = createjs.AbstractLoader.JAVASCRIPT;\n\n\t/**\n\t * @property JSON\n\t * @type {String}\n\t * @default json\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/JSON:property\"}}{{/crossLink}} instead.\n\t */\n\ts.JSON = createjs.AbstractLoader.JSON;\n\n\t/**\n\t * @property JSONP\n\t * @type {String}\n\t * @default jsonp\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/JSONP:property\"}}{{/crossLink}} instead.\n\t */\n\ts.JSONP = createjs.AbstractLoader.JSONP;\n\n\t/**\n\t * @property MANIFEST\n\t * @type {String}\n\t * @default manifest\n\t * @static\n\t * @since 0.4.1\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/MANIFEST:property\"}}{{/crossLink}} instead.\n\t */\n\ts.MANIFEST = createjs.AbstractLoader.MANIFEST;\n\n\t/**\n\t * @property SOUND\n\t * @type {String}\n\t * @default sound\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/JAVASCRIPT:property\"}}{{/crossLink}} instead.\n\t */\n\ts.SOUND = createjs.AbstractLoader.SOUND;\n\n\t/**\n\t * @property VIDEO\n\t * @type {String}\n\t * @default video\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/JAVASCRIPT:property\"}}{{/crossLink}} instead.\n\t */\n\ts.VIDEO = createjs.AbstractLoader.VIDEO;\n\n\t/**\n\t * @property SVG\n\t * @type {String}\n\t * @default svg\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/SVG:property\"}}{{/crossLink}} instead.\n\t */\n\ts.SVG = createjs.AbstractLoader.SVG;\n\n\t/**\n\t * @property TEXT\n\t * @type {String}\n\t * @default text\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/TEXT:property\"}}{{/crossLink}} instead.\n\t */\n\ts.TEXT = createjs.AbstractLoader.TEXT;\n\n\t/**\n\t * @property XML\n\t * @type {String}\n\t * @default xml\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/XML:property\"}}{{/crossLink}} instead.\n\t */\n\ts.XML = createjs.AbstractLoader.XML;\n\n\t/**\n\t * @property POST\n\t * @type {string}\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/POST:property\"}}{{/crossLink}} instead.\n\t */\n\ts.POST = createjs.AbstractLoader.POST;\n\n\t/**\n\t * @property GET\n\t * @type {string}\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/GET:property\"}}{{/crossLink}} instead.\n\t */\n\ts.GET = createjs.AbstractLoader.GET;\n\n// events\n\t/**\n\t * This event is fired when an individual file has loaded, and been processed.\n\t * @event fileload\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Object} item The file item which was specified in the {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}}\n\t * or {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}} call. If only a string path or tag was specified, the\n\t * object will contain that value as a `src` property.\n\t * @param {Object} result The HTML tag or parsed result of the loaded item.\n\t * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted\n\t * to a usable object.\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * This {{#crossLink \"ProgressEvent\"}}{{/crossLink}} that is fired when an an individual file's progress changes.\n\t * @event fileprogress\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * This event is fired when an individual file starts to load.\n\t * @event filestart\n\t * @param {Object} The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Object} item The file item which was specified in the {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}}\n\t * or {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}} call. If only a string path or tag was specified, the\n\t * object will contain that value as a property.\n\t */\n\n\t/**\n\t * Although it extends {{#crossLink \"AbstractLoader\"}}{{/crossLink}}, the `initialize` event is never fired from\n\t * a LoadQueue instance.\n\t * @event initialize\n\t * @private\n\t */\n\n// public methods\n\t/**\n\t * Register a custom loaders class. New loaders are given precedence over loaders added earlier and default loaders.\n\t * It is recommended that loaders extend {{#crossLink \"AbstractLoader\"}}{{/crossLink}}. Loaders can only be added\n\t * once, and will be prepended to the list of available loaders.\n\t * @method registerLoader\n\t * @param {Function|AbstractLoader} loader The AbstractLoader class to add.\n\t * @since 0.6.0\n\t */\n\tp.registerLoader = function (loader) {\n\t\tif (!loader || !loader.canLoadItem) {\n\t\t\tthrow new Error(\"loader is of an incorrect type.\");\n\t\t} else if (this._availableLoaders.indexOf(loader) != -1) {\n\t\t\tthrow new Error(\"loader already exists.\"); //LM: Maybe just silently fail here\n\t\t}\n\n\t\tthis._availableLoaders.unshift(loader);\n\t};\n\n\t/**\n\t * Remove a custom loader added using {{#crossLink \"registerLoader\"}}{{/crossLink}}. Only custom loaders can be\n\t * unregistered, the default loaders will always be available.\n\t * @method unregisterLoader\n\t * @param {Function|AbstractLoader} loader The AbstractLoader class to remove\n\t */\n\tp.unregisterLoader = function (loader) {\n\t\tvar idx = this._availableLoaders.indexOf(loader);\n\t\tif (idx != -1 && idx < this._defaultLoaderLength - 1) {\n\t\t\tthis._availableLoaders.splice(idx, 1);\n\t\t}\n\t};\n\n\t/**\n\t * @method setUseXHR\n\t * @param {Boolean} value The new useXHR value to set.\n\t * @return {Boolean} The new useXHR value. If XHR is not supported by the browser, this will return false, even if\n\t * the provided value argument was true.\n\t * @since 0.3.0\n\t * @deprecated use the {{#crossLink \"LoadQueue/preferXHR:property\"}}{{/crossLink}} property, or the\n\t * {{#crossLink \"LoadQueue/setUseXHR\"}}{{/crossLink}} method instead.\n\t */\n\tp.setUseXHR = function (value) {\n\t\treturn this.setPreferXHR(value);\n\t};\n\n\t/**\n\t * Change the {{#crossLink \"preferXHR:property\"}}{{/crossLink}} value. Note that if this is set to `true`, it may\n\t * fail, or be ignored depending on the browser's capabilities and the load type.\n\t * @method setPreferXHR\n\t * @param {Boolean} value\n\t * @returns {Boolean} The value of {{#crossLink \"preferXHR\"}}{{/crossLink}} that was successfully set.\n\t * @since 0.6.0\n\t */\n\tp.setPreferXHR = function (value) {\n\t\t// Determine if we can use XHR. XHR defaults to TRUE, but the browser may not support it.\n\t\t//TODO: Should we be checking for the other XHR types? Might have to do a try/catch on the different types similar to createXHR.\n\t\tthis.preferXHR = (value != false && window.XMLHttpRequest != null);\n\t\treturn this.preferXHR;\n\t};\n\n\t/**\n\t * Stops all queued and loading items, and clears the queue. This also removes all internal references to loaded\n\t * content, and allows the queue to be used again.\n\t * @method removeAll\n\t * @since 0.3.0\n\t */\n\tp.removeAll = function () {\n\t\tthis.remove();\n\t};\n\n\t/**\n\t * Stops an item from being loaded, and removes it from the queue. If nothing is passed, all items are removed.\n\t * This also removes internal references to loaded item(s).\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      queue.loadManifest([\n\t *          {src:\"test.png\", id:\"png\"},\n\t *          {src:\"test.jpg\", id:\"jpg\"},\n\t *          {src:\"test.mp3\", id:\"mp3\"}\n\t *      ]);\n\t *      queue.remove(\"png\"); // Single item by ID\n\t *      queue.remove(\"png\", \"test.jpg\"); // Items as arguments. Mixed id and src.\n\t *      queue.remove([\"test.png\", \"jpg\"]); // Items in an Array. Mixed id and src.\n\t *\n\t * @method remove\n\t * @param {String | Array} idsOrUrls* The id or ids to remove from this queue. You can pass an item, an array of\n\t * items, or multiple items as arguments.\n\t * @since 0.3.0\n\t */\n\tp.remove = function (idsOrUrls) {\n\t\tvar args = null;\n\n\t\tif (idsOrUrls && !Array.isArray(idsOrUrls)) {\n\t\t\targs = [idsOrUrls];\n\t\t} else if (idsOrUrls) {\n\t\t\targs = idsOrUrls;\n\t\t} else if (arguments.length > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar itemsWereRemoved = false;\n\n\t\t// Destroy everything\n\t\tif (!args) {\n\t\t\tthis.close();\n\t\t\tfor (var n in this._loadItemsById) {\n\t\t\t\tthis._disposeItem(this._loadItemsById[n]);\n\t\t\t}\n\t\t\tthis.init(this.preferXHR, this._basePath);\n\n\t\t\t// Remove specific items\n\t\t} else {\n\t\t\twhile (args.length) {\n\t\t\t\tvar item = args.pop();\n\t\t\t\tvar r = this.getResult(item);\n\n\t\t\t\t//Remove from the main load Queue\n\t\t\t\tfor (i = this._loadQueue.length - 1; i >= 0; i--) {\n\t\t\t\t\tloadItem = this._loadQueue[i].getItem();\n\t\t\t\t\tif (loadItem.id == item || loadItem.src == item) {\n\t\t\t\t\t\tthis._loadQueue.splice(i, 1)[0].cancel();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//Remove from the backup queue\n\t\t\t\tfor (i = this._loadQueueBackup.length - 1; i >= 0; i--) {\n\t\t\t\t\tloadItem = this._loadQueueBackup[i].getItem();\n\t\t\t\t\tif (loadItem.id == item || loadItem.src == item) {\n\t\t\t\t\t\tthis._loadQueueBackup.splice(i, 1)[0].cancel();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (r) {\n\t\t\t\t\tthis._disposeItem(this.getItem(item));\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i = this._currentLoads.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tvar loadItem = this._currentLoads[i].getItem();\n\t\t\t\t\t\tif (loadItem.id == item || loadItem.src == item) {\n\t\t\t\t\t\t\tthis._currentLoads.splice(i, 1)[0].cancel();\n\t\t\t\t\t\t\titemsWereRemoved = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If this was called during a load, try to load the next item.\n\t\t\tif (itemsWereRemoved) {\n\t\t\t\tthis._loadNext();\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Stops all open loads, destroys any loaded items, and resets the queue, so all items can\n\t * be reloaded again by calling {{#crossLink \"AbstractLoader/load\"}}{{/crossLink}}. Items are not removed from the\n\t * queue. To remove items use the {{#crossLink \"LoadQueue/remove\"}}{{/crossLink}} or\n\t * {{#crossLink \"LoadQueue/removeAll\"}}{{/crossLink}} method.\n\t * @method reset\n\t * @since 0.3.0\n\t */\n\tp.reset = function () {\n\t\tthis.close();\n\t\tfor (var n in this._loadItemsById) {\n\t\t\tthis._disposeItem(this._loadItemsById[n]);\n\t\t}\n\n\t\t//Reset the queue to its start state\n\t\tvar a = [];\n\t\tfor (var i = 0, l = this._loadQueueBackup.length; i < l; i++) {\n\t\t\ta.push(this._loadQueueBackup[i].getItem());\n\t\t}\n\n\t\tthis.loadManifest(a, false);\n\t};\n\n\t/**\n\t * Register a plugin. Plugins can map to load types (sound, image, etc), or specific extensions (png, mp3, etc).\n\t * Currently, only one plugin can exist per type/extension.\n\t *\n\t * When a plugin is installed, a <code>getPreloadHandlers()</code> method will be called on it. For more information\n\t * on this method, check out the {{#crossLink \"SamplePlugin/getPreloadHandlers\"}}{{/crossLink}} method in the\n\t * {{#crossLink \"SamplePlugin\"}}{{/crossLink}} class.\n\t *\n\t * Before a file is loaded, a matching plugin has an opportunity to modify the load. If a `callback` is returned\n\t * from the {{#crossLink \"SamplePlugin/getPreloadHandlers\"}}{{/crossLink}} method, it will be invoked first, and its\n\t * result may cancel or modify the item. The callback method can also return a `completeHandler` to be fired when\n\t * the file is loaded, or a `tag` object, which will manage the actual download. For more information on these\n\t * methods, check out the {{#crossLink \"SamplePlugin/preloadHandler\"}}{{/crossLink}} and {{#crossLink \"SamplePlugin/fileLoadHandler\"}}{{/crossLink}}\n\t * methods on the {{#crossLink \"SamplePlugin\"}}{{/crossLink}}.\n\t *\n\t * @method installPlugin\n\t * @param {Function} plugin The plugin class to install.\n\t */\n\tp.installPlugin = function (plugin) {\n\t\tif (plugin == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (plugin.getPreloadHandlers != null) {\n\t\t\tthis._plugins.push(plugin);\n\t\t\tvar map = plugin.getPreloadHandlers();\n\t\t\tmap.scope = plugin;\n\n\t\t\tif (map.types != null) {\n\t\t\t\tfor (var i = 0, l = map.types.length; i < l; i++) {\n\t\t\t\t\tthis._typeCallbacks[map.types[i]] = map;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (map.extensions != null) {\n\t\t\t\tfor (i = 0, l = map.extensions.length; i < l; i++) {\n\t\t\t\t\tthis._extensionCallbacks[map.extensions[i]] = map;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Set the maximum number of concurrent connections. Note that browsers and servers may have a built-in maximum\n\t * number of open connections, so any additional connections may remain in a pending state until the browser\n\t * opens the connection. When loading scripts using tags, and when {{#crossLink \"LoadQueue/maintainScriptOrder:property\"}}{{/crossLink}}\n\t * is `true`, only one script is loaded at a time due to browser limitations.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var queue = new createjs.LoadQueue();\n\t *      queue.setMaxConnections(10); // Allow 10 concurrent loads\n\t *\n\t * @method setMaxConnections\n\t * @param {Number} value The number of concurrent loads to allow. By default, only a single connection per LoadQueue\n\t * is open at any time.\n\t */\n\tp.setMaxConnections = function (value) {\n\t\tthis._maxConnections = value;\n\t\tif (!this._paused && this._loadQueue.length > 0) {\n\t\t\tthis._loadNext();\n\t\t}\n\t};\n\n\t/**\n\t * Load a single file. To add multiple files at once, use the {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}\n\t * method.\n\t *\n\t * Files are always appended to the current queue, so this method can be used multiple times to add files.\n\t * To clear the queue first, use the {{#crossLink \"AbstractLoader/close\"}}{{/crossLink}} method.\n\t * @method loadFile\n\t * @param {LoadItem|Object|String} file The file object or path to load. A file can be either\n\t * <ul>\n\t *     <li>A {{#crossLink \"LoadItem\"}}{{/crossLink}} instance</li>\n\t *     <li>An object containing properties defined by {{#crossLink \"LoadItem\"}}{{/crossLink}}</li>\n\t *     <li>OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink \"LoadItem\"}}{{/crossLink}}\n\t *     in the background.</li>\n\t * </ul>\n\t * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default\n\t * value is true. If the queue is paused using {{#crossLink \"LoadQueue/setPaused\"}}{{/crossLink}}, and the value is\n\t * `true`, the queue will resume automatically.\n\t * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the\n\t * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink \"AbstractLoader/MANIFEST:property\"}}{{/crossLink}},\n\t * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>\n\t * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue\n\t * constructor, or a `path` property in a manifest definition.\n\t */\n\tp.loadFile = function (file, loadNow, basePath) {\n\t\tif (file == null) {\n\t\t\tvar event = new createjs.ErrorEvent(\"PRELOAD_NO_FILE\");\n\t\t\tthis._sendError(event);\n\t\t\treturn;\n\t\t}\n\t\tthis._addItem(file, null, basePath);\n\n\t\tif (loadNow !== false) {\n\t\t\tthis.setPaused(false);\n\t\t} else {\n\t\t\tthis.setPaused(true);\n\t\t}\n\t};\n\n\t/**\n\t * Load an array of files. To load a single file, use the {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}} method.\n\t * The files in the manifest are requested in the same order, but may complete in a different order if the max\n\t * connections are set above 1 using {{#crossLink \"LoadQueue/setMaxConnections\"}}{{/crossLink}}. Scripts will load\n\t * in the right order as long as {{#crossLink \"LoadQueue/maintainScriptOrder\"}}{{/crossLink}} is true (which is\n\t * default).\n\t *\n\t * Files are always appended to the current queue, so this method can be used multiple times to add files.\n\t * To clear the queue first, use the {{#crossLink \"AbstractLoader/close\"}}{{/crossLink}} method.\n\t * @method loadManifest\n\t * @param {Array|String|Object} manifest An list of files to load. The loadManifest call supports four types of\n\t * manifests:\n\t * <ol>\n\t *     <li>A string path, which points to a manifest file, which is a JSON file that contains a \"manifest\" property,\n\t *     which defines the list of files to load, and can optionally contain a \"path\" property, which will be\n\t *     prepended to each file in the list.</li>\n\t *     <li>An object which defines a \"src\", which is a JSON or JSONP file. A \"callback\" can be defined for JSONP\n\t *     file. The JSON/JSONP file should contain a \"manifest\" property, which defines the list of files to load,\n\t *     and can optionally contain a \"path\" property, which will be prepended to each file in the list.</li>\n\t *     <li>An object which contains a \"manifest\" property, which defines the list of files to load, and can\n\t *     optionally contain a \"path\" property, which will be prepended to each file in the list.</li>\n\t *     <li>An Array of files to load.</li>\n\t * </ol>\n\t *\n\t * Each \"file\" in a manifest can be either:\n\t * <ul>\n\t *     <li>A {{#crossLink \"LoadItem\"}}{{/crossLink}} instance</li>\n\t *     <li>An object containing properties defined by {{#crossLink \"LoadItem\"}}{{/crossLink}}</li>\n\t *     <li>OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink \"LoadItem\"}}{{/crossLink}}\n\t *     in the background.</li>\n\t * </ul>\n\t *\n\t * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default\n\t * value is true. If the queue is paused using {{#crossLink \"LoadQueue/setPaused\"}}{{/crossLink}} and this value is\n\t * `true`, the queue will resume automatically.\n\t * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the\n\t * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink \"LoadQueue/MANIFEST:property\"}}{{/crossLink}},\n\t * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>\n\t * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue\n\t * constructor, or a `path` property in a manifest definition.\n\t */\n\tp.loadManifest = function (manifest, loadNow, basePath) {\n\t\tvar fileList = null;\n\t\tvar path = null;\n\n\t\t// Array-based list of items\n\t\tif (Array.isArray(manifest)) {\n\t\t\tif (manifest.length == 0) {\n\t\t\t\tvar event = new createjs.ErrorEvent(\"PRELOAD_MANIFEST_EMPTY\");\n\t\t\t\tthis._sendError(event);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfileList = manifest;\n\n\t\t\t// String-based. Only file manifests can be specified this way. Any other types will cause an error when loaded.\n\t\t} else if (typeof(manifest) === \"string\") {\n\t\t\tfileList = [\n\t\t\t\t{\n\t\t\t\t\tsrc: manifest,\n\t\t\t\t\ttype: s.MANIFEST\n\t\t\t\t}\n\t\t\t];\n\n\t\t} else if (typeof(manifest) == \"object\") {\n\n\t\t\t// An object that defines a manifest path\n\t\t\tif (manifest.src !== undefined) {\n\t\t\t\tif (manifest.type == null) {\n\t\t\t\t\tmanifest.type = s.MANIFEST;\n\t\t\t\t} else if (manifest.type != s.MANIFEST) {\n\t\t\t\t\tvar event = new createjs.ErrorEvent(\"PRELOAD_MANIFEST_TYPE\");\n\t\t\t\t\tthis._sendError(event);\n\t\t\t\t}\n\t\t\t\tfileList = [manifest];\n\n\t\t\t\t// An object that defines a manifest\n\t\t\t} else if (manifest.manifest !== undefined) {\n\t\t\t\tfileList = manifest.manifest;\n\t\t\t\tpath = manifest.path;\n\t\t\t}\n\n\t\t\t// Unsupported. This will throw an error.\n\t\t} else {\n\t\t\tvar event = new createjs.ErrorEvent(\"PRELOAD_MANIFEST_NULL\");\n\t\t\tthis._sendError(event);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var i = 0, l = fileList.length; i < l; i++) {\n\t\t\tthis._addItem(fileList[i], path, basePath);\n\t\t}\n\n\t\tif (loadNow !== false) {\n\t\t\tthis.setPaused(false);\n\t\t} else {\n\t\t\tthis.setPaused(true);\n\t\t}\n\n\t};\n\n\t/**\n\t * Start a LoadQueue that was created, but not automatically started.\n\t * @method load\n\t */\n\tp.load = function () {\n\t\tthis.setPaused(false);\n\t};\n\n\t/**\n\t * Look up a {{#crossLink \"LoadItem\"}}{{/crossLink}} using either the \"id\" or \"src\" that was specified when loading it. Note that if no \"id\" was\n\t * supplied with the load item, the ID will be the \"src\", including a `path` property defined by a manifest. The\n\t * `basePath` will not be part of the ID.\n\t * @method getItem\n\t * @param {String} value The <code>id</code> or <code>src</code> of the load item.\n\t * @return {Object} The load item that was initially requested using {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}}\n\t * or {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}. This object is also returned via the {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}}\n\t * event as the `item` parameter.\n\t */\n\tp.getItem = function (value) {\n\t\treturn this._loadItemsById[value] || this._loadItemsBySrc[value];\n\t};\n\n\t/**\n\t * Look up a loaded result using either the \"id\" or \"src\" that was specified when loading it. Note that if no \"id\"\n\t * was supplied with the load item, the ID will be the \"src\", including a `path` property defined by a manifest. The\n\t * `basePath` will not be part of the ID.\n\t * @method getResult\n\t * @param {String} value The <code>id</code> or <code>src</code> of the load item.\n\t * @param {Boolean} [rawResult=false] Return a raw result instead of a formatted result. This applies to content\n\t * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be\n\t * returned instead.\n\t * @return {Object} A result object containing the content that was loaded, such as:\n\t * <ul>\n\t *      <li>An image tag (&lt;image /&gt;) for images</li>\n\t *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts are automatically added to the HTML\n\t *      DOM.</li>\n\t *      <li>A style tag for CSS (&lt;style /&gt; or &lt;link &gt;)</li>\n\t *      <li>Raw text for TEXT</li>\n\t *      <li>A formatted JavaScript object defined by JSON</li>\n\t *      <li>An XML document</li>\n\t *      <li>A binary arraybuffer loaded by XHR</li>\n\t *      <li>An audio tag (&lt;audio &gt;) for HTML audio. Note that it is recommended to use SoundJS APIs to play\n\t *      loaded audio. Specifically, audio loaded by Flash and WebAudio will return a loader object using this method\n\t *      which can not be used to play audio back.</li>\n\t * </ul>\n\t * This object is also returned via the {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}} event as the 'item`\n\t * parameter. Note that if a raw result is requested, but not found, the result will be returned instead.\n\t */\n\tp.getResult = function (value, rawResult) {\n\t\tvar item = this._loadItemsById[value] || this._loadItemsBySrc[value];\n\t\tif (item == null) {\n\t\t\treturn null;\n\t\t}\n\t\tvar id = item.id;\n\t\tif (rawResult && this._loadedRawResults[id]) {\n\t\t\treturn this._loadedRawResults[id];\n\t\t}\n\t\treturn this._loadedResults[id];\n\t};\n\n\t/**\n\t * Generate an list of items loaded by this queue.\n\t * @method getItems\n\t * @param {Boolean} loaded Determines if only items that have been loaded should be returned. If false, in-progress\n\t * and failed load items will also be included.\n\t * @returns {Array} A list of objects that have been loaded. Each item includes the {{#crossLink \"LoadItem\"}}{{/crossLink}},\n\t * result, and rawResult.\n\t * @since 0.6.0\n\t */\n\tp.getItems = function (loaded) {\n\t\tvar arr = [];\n\t\tfor (var n in this._loadItemsById) {\n\t\t\tvar item = this._loadItemsById[n];\n\t\t\tvar result = this.getResult(n);\n\t\t\tif (loaded === true && result == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tarr.push({\n\t\t\t\titem: item,\n\t\t\t\tresult: result,\n\t\t\t\trawResult: this.getResult(n, true)\n\t\t\t});\n\t\t}\n\t\treturn arr;\n\t};\n\n\t/**\n\t * Pause or resume the current load. Active loads will not be cancelled, but the next items in the queue will not\n\t * be processed when active loads complete. LoadQueues are not paused by default.\n\t *\n\t * Note that if new items are added to the queue using {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}} or\n\t * {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}, a paused queue will be resumed, unless the `loadNow`\n\t * argument is `false`.\n\t * @method setPaused\n\t * @param {Boolean} value Whether the queue should be paused or not.\n\t */\n\tp.setPaused = function (value) {\n\t\tthis._paused = value;\n\t\tif (!this._paused) {\n\t\t\tthis._loadNext();\n\t\t}\n\t};\n\n\t/**\n\t * Close the active queue. Closing a queue completely empties the queue, and prevents any remaining items from\n\t * starting to download. Note that currently any active loads will remain open, and events may be processed.\n\t *\n\t * To stop and restart a queue, use the {{#crossLink \"LoadQueue/setPaused\"}}{{/crossLink}} method instead.\n\t * @method close\n\t */\n\tp.close = function () {\n\t\twhile (this._currentLoads.length) {\n\t\t\tthis._currentLoads.pop().cancel();\n\t\t}\n\t\tthis._scriptOrder.length = 0;\n\t\tthis._loadedScripts.length = 0;\n\t\tthis.loadStartWasDispatched = false;\n\t\tthis._itemCount = 0;\n\t\tthis._lastProgress = NaN;\n\t};\n\n// protected methods\n\t/**\n\t * Add an item to the queue. Items are formatted into a usable object containing all the properties necessary to\n\t * load the content. The load queue is populated with the loader instance that handles preloading, and not the load\n\t * item that was passed in by the user. To look up the load item by id or src, use the {{#crossLink \"LoadQueue.getItem\"}}{{/crossLink}}\n\t * method.\n\t * @method _addItem\n\t * @param {String|Object} value The item to add to the queue.\n\t * @param {String} [path] An optional path prepended to the `src`. The path will only be prepended if the src is\n\t * relative, and does not start with a protocol such as `http://`, or a path like `../`. If the LoadQueue was\n\t * provided a {{#crossLink \"_basePath\"}}{{/crossLink}}, then it will optionally be prepended after.\n\t * @param {String} [basePath] <strong>Deprecated</strong>An optional basePath passed into a {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}\n\t * or {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}} call. This parameter will be removed in a future tagged\n\t * version.\n\t * @private\n\t */\n\tp._addItem = function (value, path, basePath) {\n\t\tvar item = this._createLoadItem(value, path, basePath); // basePath and manifest path are added to the src.\n\t\tif (item == null) {\n\t\t\treturn;\n\t\t} // Sometimes plugins or types should be skipped.\n\t\tvar loader = this._createLoader(item);\n\t\tif (loader != null) {\n\t\t\tif (\"plugins\" in loader) {\n\t\t\t\tloader.plugins = this._plugins;\n\t\t\t}\n\t\t\titem._loader = loader;\n\t\t\tthis._loadQueue.push(loader);\n\t\t\tthis._loadQueueBackup.push(loader);\n\n\t\t\tthis._numItems++;\n\t\t\tthis._updateProgress();\n\n\t\t\t// Only worry about script order when using XHR to load scripts. Tags are only loading one at a time.\n\t\t\tif ((this.maintainScriptOrder\n\t\t\t\t\t&& item.type == createjs.LoadQueue.JAVASCRIPT\n\t\t\t\t\t\t//&& loader instanceof createjs.XHRLoader //NOTE: Have to track all JS files this way\n\t\t\t\t\t)\n\t\t\t\t\t|| item.maintainOrder === true) {\n\t\t\t\tthis._scriptOrder.push(item);\n\t\t\t\tthis._loadedScripts.push(null);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Create a refined {{#crossLink \"LoadItem\"}}{{/crossLink}}, which contains all the required properties. The type of\n\t * item is determined by browser support, requirements based on the file type, and developer settings. For example,\n\t * XHR is only used for file types that support it in new browsers.\n\t *\n\t * Before the item is returned, any plugins registered to handle the type or extension will be fired, which may\n\t * alter the load item.\n\t * @method _createLoadItem\n\t * @param {String | Object | HTMLAudioElement | HTMLImageElement} value The item that needs to be preloaded.\n\t * @param {String} [path] A path to prepend to the item's source. Sources beginning with http:// or similar will\n\t * not receive a path. Since PreloadJS 0.4.1, the src will be modified to include the `path` and {{#crossLink \"LoadQueue/_basePath:property\"}}{{/crossLink}}\n\t * when it is added.\n\t * @param {String} [basePath] <strong>Deprectated</strong> A base path to prepend to the items source in addition to\n\t * the path argument.\n\t * @return {Object} The loader instance that will be used.\n\t * @private\n\t */\n\tp._createLoadItem = function (value, path, basePath) {\n\t\tvar item = createjs.LoadItem.create(value);\n\t\tif (item == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar bp = \"\"; // Store the generated basePath\n\t\tvar useBasePath = basePath || this._basePath;\n\n\t\tif (item.src instanceof Object) {\n\t\t\tif (!item.type) {\n\t\t\t\treturn null;\n\t\t\t} // the the src is an object, type is required to pass off to plugin\n\t\t\tif (path) {\n\t\t\t\tbp = path;\n\t\t\t\tvar pathMatch = createjs.RequestUtils.parseURI(path);\n\t\t\t\t// Also append basePath\n\t\t\t\tif (useBasePath != null && !pathMatch.absolute && !pathMatch.relative) {\n\t\t\t\t\tbp = useBasePath + bp;\n\t\t\t\t}\n\t\t\t} else if (useBasePath != null) {\n\t\t\t\tbp = useBasePath;\n\t\t\t}\n\t\t} else {\n\t\t\t// Determine Extension, etc.\n\t\t\tvar match = createjs.RequestUtils.parseURI(item.src);\n\t\t\tif (match.extension) {\n\t\t\t\titem.ext = match.extension;\n\t\t\t}\n\t\t\tif (item.type == null) {\n\t\t\t\titem.type = createjs.RequestUtils.getTypeByExtension(item.ext);\n\t\t\t}\n\n\t\t\t// Inject path & basePath\n\t\t\tvar autoId = item.src;\n\t\t\tif (!match.absolute && !match.relative) {\n\t\t\t\tif (path) {\n\t\t\t\t\tbp = path;\n\t\t\t\t\tvar pathMatch = createjs.RequestUtils.parseURI(path);\n\t\t\t\t\tautoId = path + autoId;\n\t\t\t\t\t// Also append basePath\n\t\t\t\t\tif (useBasePath != null && !pathMatch.absolute && !pathMatch.relative) {\n\t\t\t\t\t\tbp = useBasePath + bp;\n\t\t\t\t\t}\n\t\t\t\t} else if (useBasePath != null) {\n\t\t\t\t\tbp = useBasePath;\n\t\t\t\t}\n\t\t\t}\n\t\t\titem.src = bp + item.src;\n\t\t}\n\t\titem.path = bp;\n\n\t\t// If there's no id, set one now.\n\t\tif (item.id === undefined || item.id === null || item.id === \"\") {\n\t\t\titem.id = autoId;\n\t\t}\n\n\t\t// Give plugins a chance to modify the loadItem:\n\t\tvar customHandler = this._typeCallbacks[item.type] || this._extensionCallbacks[item.ext];\n\t\tif (customHandler) {\n\t\t\t// Plugins are now passed both the full source, as well as a combined path+basePath (appropriately)\n\t\t\tvar result = customHandler.callback.call(customHandler.scope, item, this);\n\n\t\t\t// The plugin will handle the load, or has canceled it. Ignore it.\n\t\t\tif (result === false) {\n\t\t\t\treturn null;\n\n\t\t\t\t// Load as normal:\n\t\t\t} else if (result === true) {\n\t\t\t\t// Do Nothing\n\n\t\t\t\t// Result is a loader class:\n\t\t\t} else if (result != null) {\n\t\t\t\titem._loader = result;\n\t\t\t}\n\n\t\t\t// Update the extension in case the type changed:\n\t\t\tmatch = createjs.RequestUtils.parseURI(item.src);\n\t\t\tif (match.extension != null) {\n\t\t\t\titem.ext = match.extension;\n\t\t\t}\n\t\t}\n\n\t\t// Store the item for lookup. This also helps clean-up later.\n\t\tthis._loadItemsById[item.id] = item;\n\t\tthis._loadItemsBySrc[item.src] = item;\n\n\t\tif (item.crossOrigin == null) {\n\t\t\titem.crossOrigin = this._crossOrigin;\n\t\t}\n\n\t\treturn item;\n\t};\n\n\t/**\n\t * Create a loader for a load item.\n\t * @method _createLoader\n\t * @param {Object} item A formatted load item that can be used to generate a loader.\n\t * @return {AbstractLoader} A loader that can be used to load content.\n\t * @private\n\t */\n\tp._createLoader = function (item) {\n\t\tif (item._loader != null) { // A plugin already specified a loader\n\t\t\treturn item._loader;\n\t\t}\n\n\t\t// Initially, try and use the provided/supported XHR mode:\n\t\tvar preferXHR = this.preferXHR;\n\n\t\tfor (var i = 0; i < this._availableLoaders.length; i++) {\n\t\t\tvar loader = this._availableLoaders[i];\n\t\t\tif (loader && loader.canLoadItem(item)) {\n\t\t\t\treturn new loader(item, preferXHR);\n\t\t\t}\n\t\t}\n\n\t\t// TODO: Log error (requires createjs.log)\n\t\treturn null;\n\t};\n\n\t/**\n\t * Load the next item in the queue. If the queue is empty (all items have been loaded), then the complete event\n\t * is processed. The queue will \"fill up\" any empty slots, up to the max connection specified using\n\t * {{#crossLink \"LoadQueue.setMaxConnections\"}}{{/crossLink}} method. The only exception is scripts that are loaded\n\t * using tags, which have to be loaded one at a time to maintain load order.\n\t * @method _loadNext\n\t * @private\n\t */\n\tp._loadNext = function () {\n\t\tif (this._paused) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Only dispatch loadstart event when the first file is loaded.\n\t\tif (!this._loadStartWasDispatched) {\n\t\t\tthis._sendLoadStart();\n\t\t\tthis._loadStartWasDispatched = true;\n\t\t}\n\n\t\t// The queue has completed.\n\t\tif (this._numItems == this._numItemsLoaded) {\n\t\t\tthis.loaded = true;\n\t\t\tthis._sendComplete();\n\n\t\t\t// Load the next queue, if it has been defined.\n\t\t\tif (this.next && this.next.load) {\n\t\t\t\tthis.next.load();\n\t\t\t}\n\t\t} else {\n\t\t\tthis.loaded = false;\n\t\t}\n\n\t\t// Must iterate forwards to load in the right order.\n\t\tfor (var i = 0; i < this._loadQueue.length; i++) {\n\t\t\tif (this._currentLoads.length >= this._maxConnections) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar loader = this._loadQueue[i];\n\n\t\t\t// Determine if we should be only loading one tag-script at a time:\n\t\t\t// Note: maintainOrder items don't do anything here because we can hold onto their loaded value\n\t\t\tif (!this._canStartLoad(loader)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._loadQueue.splice(i, 1);\n\t\t\ti--;\n\t\t\tthis._loadItem(loader);\n\t\t}\n\t};\n\n\t/**\n\t * Begin loading an item. Event listeners are not added to the loaders until the load starts.\n\t * @method _loadItem\n\t * @param {AbstractLoader} loader The loader instance to start. Currently, this will be an XHRLoader or TagLoader.\n\t * @private\n\t */\n\tp._loadItem = function (loader) {\n\t\tloader.on(\"fileload\", this._handleFileLoad, this);\n\t\tloader.on(\"progress\", this._handleProgress, this);\n\t\tloader.on(\"complete\", this._handleFileComplete, this);\n\t\tloader.on(\"error\", this._handleError, this);\n\t\tloader.on(\"fileerror\", this._handleFileError, this);\n\t\tthis._currentLoads.push(loader);\n\t\tthis._sendFileStart(loader.getItem());\n\t\tloader.load();\n\t};\n\n\t/**\n\t * The callback that is fired when a loader loads a file. This enables loaders like {{#crossLink \"ManifestLoader\"}}{{/crossLink}}\n\t * to maintain internal queues, but for this queue to dispatch the {{#crossLink \"fileload:event\"}}{{/crossLink}}\n\t * events.\n\t * @param {Event} event The {{#crossLink \"AbstractLoader/fileload:event\"}}{{/crossLink}} event from the loader.\n\t * @private\n\t * @since 0.6.0\n\t */\n\tp._handleFileLoad = function (event) {\n\t\tevent.target = null;\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * The callback that is fired when a loader encounters an error from an internal file load operation. This enables\n\t * loaders like M\n\t * @param event\n\t * @private\n\t */\n\tp._handleFileError = function (event) {\n\t\tvar newEvent = new createjs.ErrorEvent(\"FILE_LOAD_ERROR\", null, event.item);\n\t\tthis._sendError(newEvent);\n\t};\n\n\t/**\n\t * The callback that is fired when a loader encounters an error. The queue will continue loading unless {{#crossLink \"LoadQueue/stopOnError:property\"}}{{/crossLink}}\n\t * is set to `true`.\n\t * @method _handleError\n\t * @param {ErrorEvent} event The error event, containing relevant error information.\n\t * @private\n\t */\n\tp._handleError = function (event) {\n\t\tvar loader = event.target;\n\t\tthis._numItemsLoaded++;\n\n\t\tthis._finishOrderedItem(loader, true);\n\t\tthis._updateProgress();\n\n\t\tvar newEvent = new createjs.ErrorEvent(\"FILE_LOAD_ERROR\", null, loader.getItem());\n\t\t// TODO: Propagate actual error message.\n\n\t\tthis._sendError(newEvent);\n\n\t\tif (!this.stopOnError) {\n\t\t\tthis._removeLoadItem(loader);\n\t\t\tthis._cleanLoadItem(loader);\n\t\t\tthis._loadNext();\n\t\t} else {\n\t\t\tthis.setPaused(true);\n\t\t}\n\t};\n\n\t/**\n\t * An item has finished loading. We can assume that it is totally loaded, has been parsed for immediate use, and\n\t * is available as the \"result\" property on the load item. The raw text result for a parsed item (such as JSON, XML,\n\t * CSS, JavaScript, etc) is available as the \"rawResult\" property, and can also be looked up using {{#crossLink \"LoadQueue/getResult\"}}{{/crossLink}}.\n\t * @method _handleFileComplete\n\t * @param {Event} event The event object from the loader.\n\t * @private\n\t */\n\tp._handleFileComplete = function (event) {\n\t\tvar loader = event.target;\n\t\tvar item = loader.getItem();\n\n\t\tvar result = loader.getResult();\n\t\tthis._loadedResults[item.id] = result;\n\t\tvar rawResult = loader.getResult(true);\n\t\tif (rawResult != null && rawResult !== result) {\n\t\t\tthis._loadedRawResults[item.id] = rawResult;\n\t\t}\n\n\t\tthis._saveLoadedItems(loader);\n\n\t\t// Remove the load item\n\t\tthis._removeLoadItem(loader);\n\n\t\tif (!this._finishOrderedItem(loader)) {\n\t\t\t// The item was NOT managed, so process it now\n\t\t\tthis._processFinishedLoad(item, loader);\n\t\t}\n\n\t\t// Clean up the load item\n\t\tthis._cleanLoadItem(loader);\n\t};\n\n\t/**\n\t * Some loaders might load additional content, other than the item they were passed (such as {{#crossLink \"ManifestLoader\"}}{{/crossLink}}).\n\t * Any items exposed by the loader using {{#crossLink \"AbstractLoader/getLoadItems\"}}{{/crossLink}} are added to the\n\t * LoadQueue's look-ups, including {{#crossLink \"getItem\"}}{{/crossLink}} and {{#crossLink \"getResult\"}}{{/crossLink}}\n\t * methods.\n\t * @method _saveLoadedItems\n\t * @param {AbstractLoader} loader\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._saveLoadedItems = function (loader) {\n\t\t// TODO: Not sure how to handle this. Would be nice to expose the items.\n\t\t// Loaders may load sub-items. This adds them to this queue\n\t\tvar list = loader.getLoadedItems();\n\t\tif (list === null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tvar item = list[i].item;\n\n\t\t\t// Store item lookups\n\t\t\tthis._loadItemsBySrc[item.src] = item;\n\t\t\tthis._loadItemsById[item.id] = item;\n\n\t\t\t// Store loaded content\n\t\t\tthis._loadedResults[item.id] = list[i].result;\n\t\t\tthis._loadedRawResults[item.id] = list[i].rawResult;\n\t\t}\n\t};\n\n\t/**\n\t * Flag an item as finished. If the item's order is being managed, then ensure that it is allowed to finish, and if\n\t * so, trigger prior items to trigger as well.\n\t * @method _finishOrderedItem\n\t * @param {AbstractLoader} loader\n\t * @param {Boolean} loadFailed\n\t * @return {Boolean} If the item's order is being managed. This allows the caller to take an alternate\n\t * behaviour if it is.\n\t * @private\n\t */\n\tp._finishOrderedItem = function (loader, loadFailed) {\n\t\tvar item = loader.getItem();\n\n\t\tif ((this.maintainScriptOrder && item.type == createjs.LoadQueue.JAVASCRIPT)\n\t\t\t\t|| item.maintainOrder) {\n\n\t\t\t//TODO: Evaluate removal of the _currentlyLoadingScript\n\t\t\tif (loader instanceof createjs.JavaScriptLoader) {\n\t\t\t\tthis._currentlyLoadingScript = false;\n\t\t\t}\n\n\t\t\tvar index = createjs.indexOf(this._scriptOrder, item);\n\t\t\tif (index == -1) {\n\t\t\t\treturn false;\n\t\t\t} // This loader no longer exists\n\t\t\tthis._loadedScripts[index] = (loadFailed === true) ? true : item;\n\n\t\t\tthis._checkScriptLoadOrder();\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t};\n\n\t/**\n\t * Ensure the scripts load and dispatch in the correct order. When using XHR, scripts are stored in an array in the\n\t * order they were added, but with a \"null\" value. When they are completed, the value is set to the load item,\n\t * and then when they are processed and dispatched, the value is set to `true`. This method simply\n\t * iterates the array, and ensures that any loaded items that are not preceded by a `null` value are\n\t * dispatched.\n\t * @method _checkScriptLoadOrder\n\t * @private\n\t */\n\tp._checkScriptLoadOrder = function () {\n\t\tvar l = this._loadedScripts.length;\n\n\t\tfor (var i = 0; i < l; i++) {\n\t\t\tvar item = this._loadedScripts[i];\n\t\t\tif (item === null) {\n\t\t\t\tbreak;\n\t\t\t} // This is still loading. Do not process further.\n\t\t\tif (item === true) {\n\t\t\t\tcontinue;\n\t\t\t} // This has completed, and been processed. Move on.\n\n\t\t\tvar loadItem = this._loadedResults[item.id];\n\t\t\tif (item.type == createjs.LoadQueue.JAVASCRIPT) {\n\t\t\t\t// Append script tags to the head automatically.\n\t\t\t\tcreatejs.DomUtils.appendToHead(loadItem);\n\t\t\t}\n\n\t\t\tvar loader = item._loader;\n\t\t\tthis._processFinishedLoad(item, loader);\n\t\t\tthis._loadedScripts[i] = true;\n\t\t}\n\t};\n\n\t/**\n\t * A file has completed loading, and the LoadQueue can move on. This triggers the complete event, and kick-starts\n\t * the next item.\n\t * @method _processFinishedLoad\n\t * @param {LoadItem|Object} item\n\t * @param {AbstractLoader} loader\n\t * @protected\n\t */\n\tp._processFinishedLoad = function (item, loader) {\n\t\tthis._numItemsLoaded++;\n\n\t\t// Since LoadQueue needs maintain order, we can't append scripts in the loader.\n\t\t// So we do it here instead. Or in _checkScriptLoadOrder();\n\t\tif (!this.maintainScriptOrder && item.type == createjs.LoadQueue.JAVASCRIPT) {\n\t\t\tvar tag = loader.getTag();\n\t\t\tcreatejs.DomUtils.appendToHead(tag);\n\t\t}\n\n\t\tthis._updateProgress();\n\t\tthis._sendFileComplete(item, loader);\n\t\tthis._loadNext();\n\t};\n\n\t/**\n\t * Ensure items with `maintainOrder=true` that are before the specified item have loaded. This only applies to\n\t * JavaScript items that are being loaded with a TagLoader, since they have to be loaded and completed <strong>before</strong>\n\t * the script can even be started, since it exist in the DOM while loading.\n\t * @method _canStartLoad\n\t * @param {AbstractLoader} loader The loader for the item\n\t * @return {Boolean} Whether the item can start a load or not.\n\t * @private\n\t */\n\tp._canStartLoad = function (loader) {\n\t\tif (!this.maintainScriptOrder || loader.preferXHR) {\n\t\t\treturn true;\n\t\t}\n\t\tvar item = loader.getItem();\n\t\tif (item.type != createjs.LoadQueue.JAVASCRIPT) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this._currentlyLoadingScript) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar index = this._scriptOrder.indexOf(item);\n\t\tvar i = 0;\n\t\twhile (i < index) {\n\t\t\tvar checkItem = this._loadedScripts[i];\n\t\t\tif (checkItem == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tthis._currentlyLoadingScript = true;\n\t\treturn true;\n\t};\n\n\t/**\n\t * A load item is completed or was canceled, and needs to be removed from the LoadQueue.\n\t * @method _removeLoadItem\n\t * @param {AbstractLoader} loader A loader instance to remove.\n\t * @private\n\t */\n\tp._removeLoadItem = function (loader) {\n\t\tvar l = this._currentLoads.length;\n\t\tfor (var i = 0; i < l; i++) {\n\t\t\tif (this._currentLoads[i] == loader) {\n\t\t\t\tthis._currentLoads.splice(i, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Remove unneeded references from a loader.\n\t *\n\t * @param loader\n\t * @private\n\t */\n\tp._cleanLoadItem = function(loader) {\n\t\tvar item = loader.getItem();\n\t\tif (item) {\n\t\t\tdelete item._loader;\n\t\t}\n\t}\n\n\t/**\n\t * An item has dispatched progress. Propagate that progress, and update the LoadQueue's overall progress.\n\t * @method _handleProgress\n\t * @param {ProgressEvent} event The progress event from the item.\n\t * @private\n\t */\n\tp._handleProgress = function (event) {\n\t\tvar loader = event.target;\n\t\tthis._sendFileProgress(loader.getItem(), loader.progress);\n\t\tthis._updateProgress();\n\t};\n\n\t/**\n\t * Overall progress has changed, so determine the new progress amount and dispatch it. This changes any time an\n\t * item dispatches progress or completes. Note that since we don't always know the actual filesize of items before\n\t * they are loaded. In this case, we define a \"slot\" for each item (1 item in 10 would get 10%), and then append\n\t * loaded progress on top of the already-loaded items.\n\t *\n\t * For example, if 5/10 items have loaded, and item 6 is 20% loaded, the total progress would be:\n\t * <ul>\n\t *      <li>5/10 of the items in the queue (50%)</li>\n\t *      <li>plus 20% of item 6's slot (2%)</li>\n\t *      <li>equals 52%</li>\n\t * </ul>\n\t * @method _updateProgress\n\t * @private\n\t */\n\tp._updateProgress = function () {\n\t\tvar loaded = this._numItemsLoaded / this._numItems; // Fully Loaded Progress\n\t\tvar remaining = this._numItems - this._numItemsLoaded;\n\t\tif (remaining > 0) {\n\t\t\tvar chunk = 0;\n\t\t\tfor (var i = 0, l = this._currentLoads.length; i < l; i++) {\n\t\t\t\tchunk += this._currentLoads[i].progress;\n\t\t\t}\n\t\t\tloaded += (chunk / remaining) * (remaining / this._numItems);\n\t\t}\n\n\t\tif (this._lastProgress != loaded) {\n\t\t\tthis._sendProgress(loaded);\n\t\t\tthis._lastProgress = loaded;\n\t\t}\n\t};\n\n\t/**\n\t * Clean out item results, to free them from memory. Mainly, the loaded item and results are cleared from internal\n\t * hashes.\n\t * @method _disposeItem\n\t * @param {LoadItem|Object} item The item that was passed in for preloading.\n\t * @private\n\t */\n\tp._disposeItem = function (item) {\n\t\tdelete this._loadedResults[item.id];\n\t\tdelete this._loadedRawResults[item.id];\n\t\tdelete this._loadItemsById[item.id];\n\t\tdelete this._loadItemsBySrc[item.src];\n\t};\n\n\t/**\n\t * Dispatch a \"fileprogress\" {{#crossLink \"Event\"}}{{/crossLink}}. Please see the LoadQueue {{#crossLink \"LoadQueue/fileprogress:event\"}}{{/crossLink}}\n\t * event for details on the event payload.\n\t * @method _sendFileProgress\n\t * @param {LoadItem|Object} item The item that is being loaded.\n\t * @param {Number} progress The amount the item has been loaded (between 0 and 1).\n\t * @protected\n\t */\n\tp._sendFileProgress = function (item, progress) {\n\t\tif (this._isCanceled() || this._paused) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this.hasEventListener(\"fileprogress\")) {\n\t\t\treturn;\n\t\t}\n\n\t\t//LM: Rework ProgressEvent to support this?\n\t\tvar event = new createjs.Event(\"fileprogress\");\n\t\tevent.progress = progress;\n\t\tevent.loaded = progress;\n\t\tevent.total = 1;\n\t\tevent.item = item;\n\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Dispatch a fileload {{#crossLink \"Event\"}}{{/crossLink}}. Please see the {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}} event for\n\t * details on the event payload.\n\t * @method _sendFileComplete\n\t * @param {LoadItemObject} item The item that is being loaded.\n\t * @param {AbstractLoader} loader\n\t * @protected\n\t */\n\tp._sendFileComplete = function (item, loader) {\n\t\tif (this._isCanceled() || this._paused) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar event = new createjs.Event(\"fileload\");\n\t\tevent.loader = loader;\n\t\tevent.item = item;\n\t\tevent.result = this._loadedResults[item.id];\n\t\tevent.rawResult = this._loadedRawResults[item.id];\n\n\t\t// This calls a handler specified on the actual load item. Currently, the SoundJS plugin uses this.\n\t\tif (item.completeHandler) {\n\t\t\titem.completeHandler(event);\n\t\t}\n\n\t\tthis.hasEventListener(\"fileload\") && this.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Dispatch a filestart {{#crossLink \"Event\"}}{{/crossLink}} immediately before a file starts to load. Please see\n\t * the {{#crossLink \"LoadQueue/filestart:event\"}}{{/crossLink}} event for details on the event payload.\n\t * @method _sendFileStart\n\t * @param {LoadItem|Object} item The item that is being loaded.\n\t * @protected\n\t */\n\tp._sendFileStart = function (item) {\n\t\tvar event = new createjs.Event(\"filestart\");\n\t\tevent.item = item;\n\t\tthis.hasEventListener(\"filestart\") && this.dispatchEvent(event);\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[PreloadJS LoadQueue]\";\n\t};\n\n\tcreatejs.LoadQueue = createjs.promote(LoadQueue, \"AbstractLoader\");\n}());\n\n//##############################################################################\n// TextLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for Text files.\n\t * @class TextLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction TextLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.TEXT);\n\t};\n\n\tvar p = createjs.extend(TextLoader, createjs.AbstractLoader);\n\tvar s = TextLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader loads items that are of type {{#crossLink \"AbstractLoader/TEXT:property\"}}{{/crossLink}},\n\t * but is also the default loader if a file type can not be determined.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.TEXT;\n\t};\n\n\tcreatejs.TextLoader = createjs.promote(TextLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// BinaryLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for binary files. This is useful for loading web audio, or content that requires an ArrayBuffer.\n\t * @class BinaryLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction BinaryLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.BINARY);\n\t\tthis.on(\"initialize\", this._updateXHR, this);\n\t};\n\n\tvar p = createjs.extend(BinaryLoader, createjs.AbstractLoader);\n\tvar s = BinaryLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/BINARY:property\"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.BINARY;\n\t};\n\n\t// private methods\n\t/**\n\t * Before the item loads, set the response type to \"arraybuffer\"\n\t * @property _updateXHR\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._updateXHR = function (event) {\n\t\tevent.loader.setResponseType(\"arraybuffer\");\n\t};\n\n\tcreatejs.BinaryLoader = createjs.promote(BinaryLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// CSSLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for CSS files.\n\t * @class CSSLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction CSSLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.CSS);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = \"href\";\n\n\t\tif (preferXHR) {\n\t\t\tthis._tag = document.createElement(\"style\");\n\t\t} else {\n\t\t\tthis._tag = document.createElement(\"link\");\n\t\t}\n\n\t\tthis._tag.rel = \"stylesheet\";\n\t\tthis._tag.type = \"text/css\";\n\t};\n\n\tvar p = createjs.extend(CSSLoader, createjs.AbstractLoader);\n\tvar s = CSSLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/CSS:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.CSS;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for CSS files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLLinkElement|HTMLStyleElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\tif (this._preferXHR) {\n\t\t\tvar tag = loader.getTag();\n\n\t\t\tif (tag.styleSheet) { // IE\n\t\t\t\ttag.styleSheet.cssText = loader.getResult(true);\n\t\t\t} else {\n\t\t\t\tvar textNode = document.createTextNode(loader.getResult(true));\n\t\t\t\ttag.appendChild(textNode);\n\t\t\t}\n\t\t} else {\n\t\t\ttag = this._tag;\n\t\t}\n\n\t\tcreatejs.DomUtils.appendToHead(tag);\n\n\t\treturn tag;\n\t};\n\n\tcreatejs.CSSLoader = createjs.promote(CSSLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// ImageLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for image files.\n\t * @class ImageLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction ImageLoader (loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.IMAGE);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = \"src\";\n\n\t\t// Check if the preload item is already a tag.\n\t\tif (createjs.RequestUtils.isImageTag(loadItem)) {\n\t\t\tthis._tag = loadItem;\n\t\t} else if (createjs.RequestUtils.isImageTag(loadItem.src)) {\n\t\t\tthis._tag = loadItem.src;\n\t\t} else if (createjs.RequestUtils.isImageTag(loadItem.tag)) {\n\t\t\tthis._tag = loadItem.tag;\n\t\t}\n\n\t\tif (this._tag != null) {\n\t\t\tthis._preferXHR = false;\n\t\t} else {\n\t\t\tthis._tag = document.createElement(\"img\");\n\t\t}\n\n\t\tthis.on(\"initialize\", this._updateXHR, this);\n\t};\n\n\tvar p = createjs.extend(ImageLoader, createjs.AbstractLoader);\n\tvar s = ImageLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/IMAGE:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.IMAGE;\n\t};\n\n\t// public methods\n\tp.load = function () {\n\t\tif (this._tag.src != \"\" && this._tag.complete) {\n\t\t\tthis._sendComplete();\n\t\t\treturn;\n\t\t}\n\n\t\tvar crossOrigin = this._item.crossOrigin;\n\t\tif (crossOrigin == true) { crossOrigin = \"Anonymous\"; }\n\t\tif (crossOrigin != null && !createjs.RequestUtils.isLocal(this._item.src)) {\n\t\t\tthis._tag.crossOrigin = crossOrigin;\n\t\t}\n\n\t\tthis.AbstractLoader_load();\n\t};\n\n\t// protected methods\n\t/**\n\t * Before the item loads, set its mimeType and responseType.\n\t * @property _updateXHR\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._updateXHR = function (event) {\n\t\tevent.loader.mimeType = 'text/plain; charset=x-user-defined-binary';\n\n\t\t// Only exists for XHR\n\t\tif (event.loader.setResponseType) {\n\t\t\tevent.loader.setResponseType(\"blob\");\n\t\t}\n\t};\n\n\t/**\n\t * The result formatter for Image files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLImageElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\treturn this._formatImage;\n\t};\n\n\t/**\n\t * The asynchronous image formatter function. This is required because images have\n\t * a short delay before they are ready.\n\t * @method _formatImage\n\t * @param {Function} successCallback The method to call when the result has finished formatting\n\t * @param {Function} errorCallback The method to call if an error occurs during formatting\n\t * @private\n\t */\n\tp._formatImage = function (successCallback, errorCallback) {\n\t\tvar tag = this._tag;\n\t\tvar URL = window.URL || window.webkitURL;\n\n\t\tif (!this._preferXHR) {\n\t\t\t//document.body.removeChild(tag);\n\t\t} else if (URL) {\n\t\t\tvar objURL = URL.createObjectURL(this.getResult(true));\n\t\t\ttag.src = objURL;\n\n\t\t\ttag.addEventListener(\"load\", this._cleanUpURL, false);\n\t\t\ttag.addEventListener(\"error\", this._cleanUpURL, false);\n\t\t} else {\n\t\t\ttag.src = this._item.src;\n\t\t}\n\n\t\tif (tag.complete) {\n\t\t\tsuccessCallback(tag);\n\t\t} else {\n            tag.onload = createjs.proxy(function() {\n                successCallback(this._tag);\n            }, this);\n\n            tag.onerror = createjs.proxy(function() {\n                errorCallback(_this._tag);\n            }, this);\n\t\t}\n\t};\n\n\t/**\n\t * Clean up the ObjectURL, the tag is done with it. Note that this function is run\n\t * as an event listener without a proxy/closure, as it doesn't require it - so do not\n\t * include any functionality that requires scope without changing it.\n\t * @method _cleanUpURL\n\t * @param event\n\t * @private\n\t */\n\tp._cleanUpURL = function (event) {\n\t\tvar URL = window.URL || window.webkitURL;\n\t\tURL.revokeObjectURL(event.target.src);\n\t};\n\n\tcreatejs.ImageLoader = createjs.promote(ImageLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// JavaScriptLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for JavaScript files.\n\t * @class JavaScriptLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction JavaScriptLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.JAVASCRIPT);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = \"src\";\n\t\tthis.setTag(document.createElement(\"script\"));\n\t};\n\n\tvar p = createjs.extend(JavaScriptLoader, createjs.AbstractLoader);\n\tvar s = JavaScriptLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/JAVASCRIPT:property\"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.JAVASCRIPT;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for JavaScript files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLLinkElement|HTMLStyleElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\tvar tag = loader.getTag();\n\t\tif (this._preferXHR) {\n\t\t\ttag.text = loader.getResult(true);\n\t\t}\n\t\treturn tag;\n\t};\n\n\tcreatejs.JavaScriptLoader = createjs.promote(JavaScriptLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// JSONLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for JSON files. To load JSON cross-domain, use JSONP and the {{#crossLink \"JSONPLoader\"}}{{/crossLink}}\n\t * instead. To load JSON-formatted manifests, use {{#crossLink \"ManifestLoader\"}}{{/crossLink}}, and to\n\t * load EaselJS SpriteSheets, use {{#crossLink \"SpriteSheetLoader\"}}{{/crossLink}}.\n\t * @class JSONLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction JSONLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.JSON);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\t};\n\n\tvar p = createjs.extend(JSONLoader, createjs.AbstractLoader);\n\tvar s = JSONLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/JSON:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.JSON;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for JSON files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLLinkElement|HTMLStyleElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\tvar json = null;\n\t\ttry {\n\t\t\tjson = createjs.DataUtils.parseJSON(loader.getResult(true));\n\t\t} catch (e) {\n\t\t\tvar event = new createjs.ErrorEvent(\"JSON_FORMAT\", null, e);\n\t\t\tthis._sendError(event);\n\t\t\treturn e;\n\t\t}\n\n\t\treturn json;\n\t};\n\n\tcreatejs.JSONLoader = createjs.promote(JSONLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// JSONPLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for JSONP files, which are JSON-formatted text files, wrapped in a callback. To load regular JSON\n\t * without a callback use the {{#crossLink \"JSONLoader\"}}{{/crossLink}} instead. To load JSON-formatted manifests,\n\t * use {{#crossLink \"ManifestLoader\"}}{{/crossLink}}, and to load EaselJS SpriteSheets, use\n\t * {{#crossLink \"SpriteSheetLoader\"}}{{/crossLink}}.\n\t *\n\t * JSONP is a format that provides a solution for loading JSON files cross-domain <em>without</em> requiring CORS.\n\t * JSONP files are loaded as JavaScript, and the \"callback\" is executed once they are loaded. The callback in the\n\t * JSONP must match the callback passed to the loadItem.\n\t *\n\t * <h4>Example JSONP</h4>\n\t *\n\t * \t\tcallbackName({\n\t * \t\t\t\"name\": \"value\",\n\t *\t \t\t\"num\": 3,\n\t *\t\t\t\"obj\": { \"bool\":true }\n\t * \t\t});\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \t\tvar loadItem = {id:\"json\", type:\"jsonp\", src:\"http://server.com/text.json\", callback:\"callbackName\"}\n\t * \t\tvar queue = new createjs.LoadQueue();\n\t * \t\tqueue.on(\"complete\", handleComplete);\n\t * \t\tqueue.loadItem(loadItem);\n\t *\n\t * \t\tfunction handleComplete(event) }\n\t * \t\t\tvar json = queue.getResult(\"json\");\n\t * \t\t\tconsole.log(json.obj.bool); // true\n\t * \t\t}\n\t *\n\t * Note that JSONP files loaded concurrently require a <em>unique</em> callback. To ensure JSONP files are loaded\n\t * in order, either use the {{#crossLink \"LoadQueue/setMaxConnections\"}}{{/crossLink}} method (set to 1),\n\t * or set {{#crossLink \"LoadItem/maintainOrder:property\"}}{{/crossLink}} on items with the same callback.\n\t *\n\t * @class JSONPLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction JSONPLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, false, createjs.AbstractLoader.JSONP);\n\t\tthis.setTag(document.createElement(\"script\"));\n\t\tthis.getTag().type = \"text/javascript\";\n\t};\n\n\tvar p = createjs.extend(JSONPLoader, createjs.AbstractLoader);\n\tvar s = JSONPLoader;\n\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/JSONP:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.JSONP;\n\t};\n\n\t// public methods\n\tp.cancel = function () {\n\t\tthis.AbstractLoader_cancel();\n\t\tthis._dispose();\n\t};\n\n\t/**\n\t * Loads the JSONp file.  Because of the unique loading needs of JSONp\n\t * we don't use the AbstractLoader.load() method.\n\t *\n\t * @method load\n\t *\n\t */\n\tp.load = function () {\n\t\tif (this._item.callback == null) {\n\t\t\tthrow new Error('callback is required for loading JSONP requests.');\n\t\t}\n\n\t\t// TODO: Look into creating our own iFrame to handle the load\n\t\t// In the first attempt, FF did not get the result\n\t\t//   result instanceof Object did not work either\n\t\t//   so we would need to clone the result.\n\t\tif (window[this._item.callback] != null) {\n\t\t\tthrow new Error(\n\t\t\t\t\"JSONP callback '\" +\n\t\t\t\tthis._item.callback +\n\t\t\t\t\"' already exists on window. You need to specify a different callback or re-name the current one.\");\n\t\t}\n\n\t\twindow[this._item.callback] = createjs.proxy(this._handleLoad, this);\n\t\twindow.document.body.appendChild(this._tag);\n\n\t\tthis._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);\n\n\t\t// Load the tag\n\t\tthis._tag.src = this._item.src;\n\t};\n\n\t// private methods\n\t/**\n\t * Handle the JSONP callback, which is a public method defined on `window`.\n\t * @method _handleLoad\n\t * @param {Object} data The formatted JSON data.\n\t * @private\n\t */\n\tp._handleLoad = function (data) {\n\t\tthis._result = this._rawResult = data;\n\t\tthis._sendComplete();\n\n\t\tthis._dispose();\n\t};\n\n\t/**\n\t * The tag request has not loaded within the time specfied in loadTimeout.\n\t * @method _handleError\n\t * @param {Object} event The XHR error event.\n\t * @private\n\t */\n\tp._handleTimeout = function () {\n\t\tthis._dispose();\n\t\tthis.dispatchEvent(new createjs.ErrorEvent(\"timeout\"));\n\t};\n\n\t/**\n\t * Clean up the JSONP load. This clears out the callback and script tag that this loader creates.\n\t * @method _dispose\n\t * @private\n\t */\n\tp._dispose = function () {\n\t\twindow.document.body.removeChild(this._tag);\n\t\tdelete window[this._item.callback];\n\n\t\tclearTimeout(this._loadTimeout);\n\t};\n\n\tcreatejs.JSONPLoader = createjs.promote(JSONPLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// ManifestLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for JSON manifests. Items inside the manifest are loaded before the loader completes. To load manifests\n\t * using JSONP, specify a {{#crossLink \"LoadItem/callback:property\"}}{{/crossLink}} as part of the\n\t * {{#crossLink \"LoadItem\"}}{{/crossLink}}.\n\t *\n\t * The list of files in the manifest must be defined on the top-level JSON object in a `manifest` property. This\n\t * example shows a sample manifest definition, as well as how to to include a sub-manifest.\n\t *\n\t * \t\t{\n\t * \t\t\t\"path\": \"assets/\",\n\t *\t \t    \"manifest\": [\n\t *\t\t\t\t\"image.png\",\n\t *\t\t\t\t{\"src\": \"image2.png\", \"id\":\"image2\"},\n\t *\t\t\t\t{\"src\": \"sub-manifest.json\", \"type\":\"manifest\", \"callback\":\"jsonCallback\"}\n\t *\t \t    ]\n\t *\t \t}\n\t *\n\t * When a ManifestLoader has completed loading, the parent loader (usually a {{#crossLink \"LoadQueue\"}}{{/crossLink}},\n\t * but could also be another ManifestLoader) will inherit all the loaded items, so you can access them directly.\n\t *\n\t * Note that the {{#crossLink \"JSONLoader\"}}{{/crossLink}} and {{#crossLink \"JSONPLoader\"}}{{/crossLink}} are\n\t * higher priority loaders, so manifests <strong>must</strong> set the {{#crossLink \"LoadItem\"}}{{/crossLink}}\n\t * {{#crossLink \"LoadItem/type:property\"}}{{/crossLink}} property to {{#crossLink \"AbstractLoader/MANIFEST:property\"}}{{/crossLink}}.\n\t * @class ManifestLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction ManifestLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, null, createjs.AbstractLoader.MANIFEST);\n\n\t// Public Properties\n\t\t/**\n\t\t * An array of the plugins registered using {{#crossLink \"LoadQueue/installPlugin\"}}{{/crossLink}},\n\t\t * used to pass plugins to new LoadQueues that may be created.\n\t\t * @property _plugins\n\t\t * @type {Array}\n\t\t * @private\n\t\t * @since 0.6.1\n\t\t */\n\t\tthis.plugins = null;\n\n\n\t// Protected Properties\n\t\t/**\n\t\t * An internal {{#crossLink \"LoadQueue\"}}{{/crossLink}} that loads the contents of the manifest.\n\t\t * @property _manifestQueue\n\t\t * @type {LoadQueue}\n\t\t * @private\n\t\t */\n\t\tthis._manifestQueue = null;\n\t};\n\n\tvar p = createjs.extend(ManifestLoader, createjs.AbstractLoader);\n\tvar s = ManifestLoader;\n\n\t// static properties\n\t/**\n\t * The amount of progress that the manifest itself takes up.\n\t * @property MANIFEST_PROGRESS\n\t * @type {number}\n\t * @default 0.25 (25%)\n\t * @private\n\t * @static\n\t */\n\ts.MANIFEST_PROGRESS = 0.25;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/MANIFEST:property\"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.MANIFEST;\n\t};\n\n\t// public methods\n\tp.load = function () {\n\t\tthis.AbstractLoader_load();\n\t};\n\n\t// protected methods\n\tp._createRequest = function() {\n\t\tvar callback = this._item.callback;\n\t\tif (callback != null) {\n\t\t\tthis._request = new createjs.JSONPLoader(this._item);\n\t\t} else {\n\t\t\tthis._request = new createjs.JSONLoader(this._item);\n\t\t}\n\t};\n\n\tp.handleEvent = function (event) {\n\t\tswitch (event.type) {\n\t\t\tcase \"complete\":\n\t\t\t\tthis._rawResult = event.target.getResult(true);\n\t\t\t\tthis._result = event.target.getResult();\n\t\t\t\tthis._sendProgress(s.MANIFEST_PROGRESS);\n\t\t\t\tthis._loadManifest(this._result);\n\t\t\t\treturn;\n\t\t\tcase \"progress\":\n\t\t\t\tevent.loaded *= s.MANIFEST_PROGRESS;\n\t\t\t\tthis.progress = event.loaded / event.total;\n\t\t\t\tif (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }\n\t\t\t\tthis._sendProgress(event);\n\t\t\t\treturn;\n\t\t}\n\t\tthis.AbstractLoader_handleEvent(event);\n\t};\n\n\tp.destroy = function() {\n\t\tthis.AbstractLoader_destroy();\n\t\tthis._manifestQueue.close();\n\t};\n\n\t/**\n\t * Create and load the manifest items once the actual manifest has been loaded.\n\t * @method _loadManifest\n\t * @param {Object} json\n\t * @private\n\t */\n\tp._loadManifest = function (json) {\n\t\tif (json && json.manifest) {\n\t\t\tvar queue = this._manifestQueue = new createjs.LoadQueue();\n\t\t\tqueue.on(\"fileload\", this._handleManifestFileLoad, this);\n\t\t\tqueue.on(\"progress\", this._handleManifestProgress, this);\n\t\t\tqueue.on(\"complete\", this._handleManifestComplete, this, true);\n\t\t\tqueue.on(\"error\", this._handleManifestError, this, true);\n\t\t\tfor(var i = 0, l = this.plugins.length; i < l; i++) {\t// conserve order of plugins\n\t\t\t\tqueue.installPlugin(this.plugins[i]);\n\t\t\t}\n\t\t\tqueue.loadManifest(json);\n\t\t} else {\n\t\t\tthis._sendComplete();\n\t\t}\n\t};\n\n\t/**\n\t * An item from the {{#crossLink \"_manifestQueue:property\"}}{{/crossLink}} has completed.\n\t * @method _handleManifestFileLoad\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._handleManifestFileLoad = function (event) {\n\t\tevent.target = null;\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * The manifest has completed loading. This triggers the {{#crossLink \"AbstractLoader/complete:event\"}}{{/crossLink}}\n\t * {{#crossLink \"Event\"}}{{/crossLink}} from the ManifestLoader.\n\t * @method _handleManifestComplete\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._handleManifestComplete = function (event) {\n\t\tthis._loadedItems = this._manifestQueue.getItems(true);\n\t\tthis._sendComplete();\n\t};\n\n\t/**\n\t * The manifest has reported progress.\n\t * @method _handleManifestProgress\n\t * @param {ProgressEvent} event\n\t * @private\n\t */\n\tp._handleManifestProgress = function (event) {\n\t\tthis.progress = event.progress * (1 - s.MANIFEST_PROGRESS) + s.MANIFEST_PROGRESS;\n\t\tthis._sendProgress(this.progress);\n\t};\n\n\t/**\n\t * The manifest has reported an error with one of the files.\n\t * @method _handleManifestError\n\t * @param {ErrorEvent} event\n\t * @private\n\t */\n\tp._handleManifestError = function (event) {\n\t\tvar newEvent = new createjs.Event(\"fileerror\");\n\t\tnewEvent.item = event.data;\n\t\tthis.dispatchEvent(newEvent);\n\t};\n\n\tcreatejs.ManifestLoader = createjs.promote(ManifestLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// SoundLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for HTML audio files. PreloadJS can not load WebAudio files, as a WebAudio context is required, which\n\t * should be created by either a library playing the sound (such as <a href=\"http://soundjs.com\">SoundJS</a>, or an\n\t * external framework that handles audio playback. To load content that can be played by WebAudio, use the\n\t * {{#crossLink \"BinaryLoader\"}}{{/crossLink}}, and handle the audio context decoding manually.\n\t * @class SoundLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractMediaLoader\n\t * @constructor\n\t */\n\tfunction SoundLoader(loadItem, preferXHR) {\n\t\tthis.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SOUND);\n\n\t\t// protected properties\n\t\tif (createjs.RequestUtils.isAudioTag(loadItem)) {\n\t\t\tthis._tag = loadItem;\n\t\t} else if (createjs.RequestUtils.isAudioTag(loadItem.src)) {\n\t\t\tthis._tag = loadItem;\n\t\t} else if (createjs.RequestUtils.isAudioTag(loadItem.tag)) {\n\t\t\tthis._tag = createjs.RequestUtils.isAudioTag(loadItem) ? loadItem : loadItem.src;\n\t\t}\n\n\t\tif (this._tag != null) {\n\t\t\tthis._preferXHR = false;\n\t\t}\n\t};\n\n\tvar p = createjs.extend(SoundLoader, createjs.AbstractMediaLoader);\n\tvar s = SoundLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/SOUND:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.SOUND;\n\t};\n\n\t// protected methods\n\tp._createTag = function (src) {\n\t\tvar tag = document.createElement(\"audio\");\n\t\ttag.autoplay = false;\n\t\ttag.preload = \"none\";\n\n\t\t//LM: Firefox fails when this the preload=\"none\" for other tags, but it needs to be \"none\" to ensure PreloadJS works.\n\t\ttag.src = src;\n\t\treturn tag;\n\t};\n\n\tcreatejs.SoundLoader = createjs.promote(SoundLoader, \"AbstractMediaLoader\");\n\n}());\n\n//##############################################################################\n// VideoLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for video files.\n\t * @class VideoLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractMediaLoader\n\t * @constructor\n\t */\n\tfunction VideoLoader(loadItem, preferXHR) {\n\t\tthis.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.VIDEO);\n\n\t\tif (createjs.RequestUtils.isVideoTag(loadItem) || createjs.RequestUtils.isVideoTag(loadItem.src)) {\n\t\t\tthis.setTag(createjs.RequestUtils.isVideoTag(loadItem)?loadItem:loadItem.src);\n\n\t\t\t// We can't use XHR for a tag that's passed in.\n\t\t\tthis._preferXHR = false;\n\t\t} else {\n\t\t\tthis.setTag(this._createTag());\n\t\t}\n\t};\n\n\tvar p = createjs.extend(VideoLoader, createjs.AbstractMediaLoader);\n\tvar s = VideoLoader;\n\n\t/**\n\t * Create a new video tag\n\t *\n\t * @returns {HTMLElement}\n\t * @private\n\t */\n\tp._createTag = function () {\n\t\treturn document.createElement(\"video\");\n\t};\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/VIDEO:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.VIDEO;\n\t};\n\n\tcreatejs.VideoLoader = createjs.promote(VideoLoader, \"AbstractMediaLoader\");\n\n}());\n\n//##############################################################################\n// SpriteSheetLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for EaselJS SpriteSheets. Images inside the spritesheet definition are loaded before the loader\n\t * completes. To load SpriteSheets using JSONP, specify a {{#crossLink \"LoadItem/callback:property\"}}{{/crossLink}}\n\t * as part of the {{#crossLink \"LoadItem\"}}{{/crossLink}}. Note that the {{#crossLink \"JSONLoader\"}}{{/crossLink}}\n\t * and {{#crossLink \"JSONPLoader\"}}{{/crossLink}} are higher priority loaders, so SpriteSheets <strong>must</strong>\n\t * set the {{#crossLink \"LoadItem\"}}{{/crossLink}} {{#crossLink \"LoadItem/type:property\"}}{{/crossLink}} property\n\t * to {{#crossLink \"AbstractLoader/SPRITESHEET:property\"}}{{/crossLink}}.\n\t *\n\t * The {{#crossLink \"LoadItem\"}}{{/crossLink}} {{#crossLink \"LoadItem/crossOrigin:property\"}}{{/crossLink}} as well\n\t * as the {{#crossLink \"LoadQueue's\"}}{{/crossLink}} `basePath` argument and {{#crossLink \"LoadQueue/_preferXHR\"}}{{/crossLink}}\n\t * property supplied to the {{#crossLink \"LoadQueue\"}}{{/crossLink}} are passed on to the sub-manifest that loads\n\t * the SpriteSheet images.\n\t *\n\t * Note that the SpriteSheet JSON does not respect the {{#crossLink \"LoadQueue/_preferXHR:property\"}}{{/crossLink}}\n\t * property, which should instead be determined by the presence of a {{#crossLink \"LoadItem/callback:property\"}}{{/crossLink}}\n\t * property on the SpriteSheet load item. This is because the JSON loaded will have a different format depending on\n\t * if it is loaded as JSON, so just changing `preferXHR` is not enough to change how it is loaded.\n\t * @class SpriteSheetLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction SpriteSheetLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SPRITESHEET);\n\n\t\t// protected properties\n\t\t/**\n\t\t * An internal queue which loads the SpriteSheet's images.\n\t\t * @method _manifestQueue\n\t\t * @type {LoadQueue}\n\t\t * @private\n\t\t */\n\t\tthis._manifestQueue = null;\n\t}\n\n\tvar p = createjs.extend(SpriteSheetLoader, createjs.AbstractLoader);\n\tvar s = SpriteSheetLoader;\n\n\t// static properties\n\t/**\n\t * The amount of progress that the manifest itself takes up.\n\t * @property SPRITESHEET_PROGRESS\n\t * @type {number}\n\t * @default 0.25 (25%)\n\t * @private\n\t * @static\n\t */\n\ts.SPRITESHEET_PROGRESS = 0.25;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/SPRITESHEET:property\"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.SPRITESHEET;\n\t};\n\n\t// public methods\n\tp.destroy = function() {\n\t\tthis.AbstractLoader_destroy;\n\t\tthis._manifestQueue.close();\n\t};\n\n\t// protected methods\n\tp._createRequest = function() {\n\t\tvar callback = this._item.callback;\n\t\tif (callback != null) {\n\t\t\tthis._request = new createjs.JSONPLoader(this._item);\n\t\t} else {\n\t\t\tthis._request = new createjs.JSONLoader(this._item);\n\t\t}\n\t};\n\n\tp.handleEvent = function (event) {\n\t\tswitch (event.type) {\n\t\t\tcase \"complete\":\n\t\t\t\tthis._rawResult = event.target.getResult(true);\n\t\t\t\tthis._result = event.target.getResult();\n\t\t\t\tthis._sendProgress(s.SPRITESHEET_PROGRESS);\n\t\t\t\tthis._loadManifest(this._result);\n\t\t\t\treturn;\n\t\t\tcase \"progress\":\n\t\t\t\tevent.loaded *= s.SPRITESHEET_PROGRESS;\n\t\t\t\tthis.progress = event.loaded / event.total;\n\t\t\t\tif (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }\n\t\t\t\tthis._sendProgress(event);\n\t\t\t\treturn;\n\t\t}\n\t\tthis.AbstractLoader_handleEvent(event);\n\t};\n\n\t/**\n\t * Create and load the images once the SpriteSheet JSON has been loaded.\n\t * @method _loadManifest\n\t * @param {Object} json\n\t * @private\n\t */\n\tp._loadManifest = function (json) {\n\t\tif (json && json.images) {\n\t\t\tvar queue = this._manifestQueue = new createjs.LoadQueue(this._preferXHR, this._item.path, this._item.crossOrigin);\n\t\t\tqueue.on(\"complete\", this._handleManifestComplete, this, true);\n\t\t\tqueue.on(\"fileload\", this._handleManifestFileLoad, this);\n\t\t\tqueue.on(\"progress\", this._handleManifestProgress, this);\n\t\t\tqueue.on(\"error\", this._handleManifestError, this, true);\n\t\t\tqueue.loadManifest(json.images);\n\t\t}\n\t};\n\n\t/**\n\t * An item from the {{#crossLink \"_manifestQueue:property\"}}{{/crossLink}} has completed.\n\t * @method _handleManifestFileLoad\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._handleManifestFileLoad = function (event) {\n\t\tvar image = event.result;\n\t\tif (image != null) {\n\t\t\tvar images = this.getResult().images;\n\t\t\tvar pos = images.indexOf(event.item.src);\n\t\t\timages[pos] = image;\n\t\t}\n\t};\n\n\t/**\n\t * The images have completed loading. This triggers the {{#crossLink \"AbstractLoader/complete:event\"}}{{/crossLink}}\n\t * {{#crossLink \"Event\"}}{{/crossLink}} from the SpriteSheetLoader.\n\t * @method _handleManifestComplete\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._handleManifestComplete = function (event) {\n\t\tthis._result = new createjs.SpriteSheet(this._result);\n\t\tthis._loadedItems = this._manifestQueue.getItems(true);\n\t\tthis._sendComplete();\n\t};\n\n\t/**\n\t * The images {{#crossLink \"LoadQueue\"}}{{/crossLink}} has reported progress.\n\t * @method _handleManifestProgress\n\t * @param {ProgressEvent} event\n\t * @private\n\t */\n\tp._handleManifestProgress = function (event) {\n\t\tthis.progress = event.progress * (1 - s.SPRITESHEET_PROGRESS) + s.SPRITESHEET_PROGRESS;\n\t\tthis._sendProgress(this.progress);\n\t};\n\n\t/**\n\t * An image has reported an error.\n\t * @method _handleManifestError\n\t * @param {ErrorEvent} event\n\t * @private\n\t */\n\tp._handleManifestError = function (event) {\n\t\tvar newEvent = new createjs.Event(\"fileerror\");\n\t\tnewEvent.item = event.data;\n\t\tthis.dispatchEvent(newEvent);\n\t};\n\n\tcreatejs.SpriteSheetLoader = createjs.promote(SpriteSheetLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// SVGLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for SVG files.\n\t * @class SVGLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction SVGLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SVG);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = \"data\";\n\n\t\tif (preferXHR) {\n\t\t\tthis.setTag(document.createElement(\"svg\"));\n\t\t} else {\n\t\t\tthis.setTag(document.createElement(\"object\"));\n\t\t\tthis.getTag().type = \"image/svg+xml\";\n\t\t}\n\t};\n\n\tvar p = createjs.extend(SVGLoader, createjs.AbstractLoader);\n\tvar s = SVGLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/SVG:property\"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.SVG;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for SVG files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {Object}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\t// mime should be image/svg+xml, but Opera requires text/xml\n\t\tvar xml = createjs.DataUtils.parseXML(loader.getResult(true), \"text/xml\");\n\t\tvar tag = loader.getTag();\n\n\t\tif (!this._preferXHR && document.body.contains(tag)) {\n\t\t\tdocument.body.removeChild(tag);\n\t\t}\n\n\t\tif (xml.documentElement != null) {\n\t\t\ttag.appendChild(xml.documentElement);\n\t\t\ttag.style.visibility = \"visible\";\n\t\t\treturn tag;\n\t\t} else { // For browsers that don't support SVG, just give them the XML. (IE 9-8)\n\t\t\treturn xml;\n\t\t}\n\t};\n\n\tcreatejs.SVGLoader = createjs.promote(SVGLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// XMLLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for CSS files.\n\t * @class XMLLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction XMLLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.XML);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\t};\n\n\tvar p = createjs.extend(XMLLoader, createjs.AbstractLoader);\n\tvar s = XMLLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/XML:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.XML;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for XML files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {XMLDocument}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\treturn createjs.DataUtils.parseXML(loader.getResult(true), \"text/xml\");\n\t};\n\n\tcreatejs.XMLLoader = createjs.promote(XMLLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// version.js\n//##############################################################################\n\n(function () {\n\n\t/**\n\t * Static class holding library specific information such as the version and buildDate of the library.\n\t * The SoundJS class has been renamed {{#crossLink \"Sound\"}}{{/crossLink}}.  Please see {{#crossLink \"Sound\"}}{{/crossLink}}\n\t * for information on using sound.\n\t * @class SoundJS\n\t **/\n\tvar s = createjs.SoundJS = createjs.SoundJS || {};\n\n\t/**\n\t * The version string for this release.\n\t * @property version\n\t * @type String\n\t * @static\n\t **/\n\ts.version = /*=version*/\"0.6.2\"; // injected by build process\n\n\t/**\n\t * The build date for this release in UTC format.\n\t * @property buildDate\n\t * @type String\n\t * @static\n\t **/\n\ts.buildDate = /*=date*/\"Thu, 26 Nov 2015 20:44:31 GMT\"; // injected by build process\n\n})();\n\n//##############################################################################\n// IndexOf.js\n//##############################################################################\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of\n * that value.  Returns -1 if value is not found.\n *\n *      var i = createjs.indexOf(myArray, myElementToFind);\n *\n * @method indexOf\n * @param {Array} array Array to search for searchElement\n * @param searchElement Element to find in array.\n * @return {Number} The first index of searchElement in array.\n */\ncreatejs.indexOf = function (array, searchElement){\n\t\"use strict\";\n\n\tfor (var i = 0,l=array.length; i < l; i++) {\n\t\tif (searchElement === array[i]) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\n//##############################################################################\n// Proxy.js\n//##############################################################################\n\n/**\n * Various utilities that the CreateJS Suite uses. Utilities are created as separate files, and will be available on the\n * createjs namespace directly.\n *\n * <h4>Example</h4>\n *\n *      myObject.addEventListener(\"change\", createjs.proxy(myMethod, scope));\n *\n * @class Utility Methods\n * @main Utility Methods\n */\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * A function proxy for methods. By default, JavaScript methods do not maintain scope, so passing a method as a\n\t * callback will result in the method getting called in the scope of the caller. Using a proxy ensures that the\n\t * method gets called in the correct scope.\n\t *\n\t * Additional arguments can be passed that will be applied to the function when it is called.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      myObject.addEventListener(\"event\", createjs.proxy(myHandler, this, arg1, arg2));\n\t *\n\t *      function myHandler(arg1, arg2) {\n\t *           // This gets called when myObject.myCallback is executed.\n\t *      }\n\t *\n\t * @method proxy\n\t * @param {Function} method The function to call\n\t * @param {Object} scope The scope to call the method name on\n\t * @param {mixed} [arg] * Arguments that are appended to the callback for additional params.\n\t * @public\n\t * @static\n\t */\n\tcreatejs.proxy = function (method, scope) {\n\t\tvar aArgs = Array.prototype.slice.call(arguments, 2);\n\t\treturn function () {\n\t\t\treturn method.apply(scope, Array.prototype.slice.call(arguments, 0).concat(aArgs));\n\t\t};\n\t}\n\n}());\n\n//##############################################################################\n// BrowserDetect.js\n//##############################################################################\n\n/**\n * @class Utility Methods\n */\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * An object that determines the current browser, version, operating system, and other environment\n\t * variables via user agent string.\n\t *\n\t * Used for audio because feature detection is unable to detect the many limitations of mobile devices.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      if (createjs.BrowserDetect.isIOS) { // do stuff }\n\t *\n\t * @property BrowserDetect\n\t * @type {Object}\n\t * @param {Boolean} isFirefox True if our browser is Firefox.\n\t * @param {Boolean} isOpera True if our browser is opera.\n\t * @param {Boolean} isChrome True if our browser is Chrome.  Note that Chrome for Android returns true, but is a\n\t * completely different browser with different abilities.\n\t * @param {Boolean} isIOS True if our browser is safari for iOS devices (iPad, iPhone, and iPod).\n\t * @param {Boolean} isAndroid True if our browser is Android.\n\t * @param {Boolean} isBlackberry True if our browser is Blackberry.\n\t * @constructor\n\t * @static\n\t */\n\tfunction BrowserDetect() {\n\t\tthrow \"BrowserDetect cannot be instantiated\";\n\t};\n\n\tvar agent = BrowserDetect.agent = window.navigator.userAgent;\n\tBrowserDetect.isWindowPhone = (agent.indexOf(\"IEMobile\") > -1) || (agent.indexOf(\"Windows Phone\") > -1);\n\tBrowserDetect.isFirefox = (agent.indexOf(\"Firefox\") > -1);\n\tBrowserDetect.isOpera = (window.opera != null);\n\tBrowserDetect.isChrome = (agent.indexOf(\"Chrome\") > -1);  // NOTE that Chrome on Android returns true but is a completely different browser with different abilities\n\tBrowserDetect.isIOS = (agent.indexOf(\"iPod\") > -1 || agent.indexOf(\"iPhone\") > -1 || agent.indexOf(\"iPad\") > -1) && !BrowserDetect.isWindowPhone;\n\tBrowserDetect.isAndroid = (agent.indexOf(\"Android\") > -1) && !BrowserDetect.isWindowPhone;\n\tBrowserDetect.isBlackberry = (agent.indexOf(\"Blackberry\") > -1);\n\n\tcreatejs.BrowserDetect = BrowserDetect;\n\n}());\n\n//##############################################################################\n// AudioSprite.js\n//##############################################################################\n\n//  NOTE this is \"Class\" is purely to document audioSprite Setup and usage.\n\n\n/**\n * <strong>Note: AudioSprite is not a class, but its usage is easily lost in the documentation, so it has been called\n * out here for quick reference.</strong>\n *\n * Audio sprites are much like CSS sprites or image sprite sheets: multiple audio assets grouped into a single file.\n * Audio sprites work around limitations in certain browsers, where only a single sound can be loaded and played at a\n * time. We recommend at least 300ms of silence between audio clips to deal with HTML audio tag inaccuracy, and to prevent\n * accidentally playing bits of the neighbouring clips.\n *\n * <strong>Benefits of Audio Sprites:</strong>\n * <ul>\n *     <li>More robust support for older browsers and devices that only allow a single audio instance, such as iOS 5.</li>\n *     <li>They provide a work around for the Internet Explorer 9 audio tag limit, which restricts how many different\n *     sounds that could be loaded at once.</li>\n *     <li>Faster loading by only requiring a single network request for several sounds, especially on mobile devices\n * where the network round trip for each file can add significant latency.</li>\n * </ul>\n *\n * <strong>Drawbacks of Audio Sprites</strong>\n * <ul>\n *     <li>No guarantee of smooth looping when using HTML or Flash audio. If you have a track that needs to loop\n * \t\tsmoothly and you are supporting non-web audio browsers, do not use audio sprites for that sound if you can avoid\n * \t\tit.</li>\n *     <li>No guarantee that HTML audio will play back immediately, especially the first time. In some browsers\n *     (Chrome!), HTML audio will only load enough to play through at the current download speed  so we rely on the\n *     `canplaythrough` event to determine if the audio is loaded. Since audio sprites must jump ahead to play specific\n *     sounds, the audio may not yet have downloaded fully.</li>\n *     <li>Audio sprites share the same core source, so if you have a sprite with 5 sounds and are limited to 2\n * \t\tconcurrently playing instances, you can only play 2 of the sounds at the same time.</li>\n * </ul>\n *\n * <h4>Example</h4>\n *\n *\t\tcreatejs.Sound.initializeDefaultPlugins();\n *\t\tvar assetsPath = \"./assets/\";\n *\t\tvar sounds = [{\n *\t\t\tsrc:\"MyAudioSprite.ogg\", data: {\n *\t\t\t\taudioSprite: [\n *\t\t\t\t\t{id:\"sound1\", startTime:0, duration:500},\n *\t\t\t\t\t{id:\"sound2\", startTime:1000, duration:400},\n *\t\t\t\t\t{id:\"sound3\", startTime:1700, duration: 1000}\n *\t\t\t\t]}\n *\t\t\t}\n *\t\t];\n *\t\tcreatejs.Sound.alternateExtensions = [\"mp3\"];\n *\t\tcreatejs.Sound.on(\"fileload\", loadSound);\n *\t\tcreatejs.Sound.registerSounds(sounds, assetsPath);\n *\t\t// after load is complete\n *\t\tcreatejs.Sound.play(\"sound2\");\n *\n * You can also create audio sprites on the fly by setting the startTime and duration when creating an new AbstractSoundInstance.\n *\n * \t\tcreatejs.Sound.play(\"MyAudioSprite\", {startTime: 1000, duration: 400});\n *\n * The excellent CreateJS community has created a tool to create audio sprites, available at\n * <a href=\"https://github.com/tonistiigi/audiosprite\" target=\"_blank\">https://github.com/tonistiigi/audiosprite</a>,\n * as well as a <a href=\"http://jsfiddle.net/bharat_battu/g8fFP/12/\" target=\"_blank\">jsfiddle</a> to convert the output\n * to SoundJS format.\n *\n * @class AudioSprite\n * @since 0.6.0\n */\n\n//##############################################################################\n// PlayPropsConfig.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\t/**\n\t * A class to store the optional play properties passed in {{#crossLink \"Sound/play\"}}{{/crossLink}} and\n\t * {{#crossLink \"AbstractSoundInstance/play\"}}{{/crossLink}} calls.\n\t *\n\t * Optional Play Properties Include:\n\t * <ul>\n\t * <li>interrupt - How to interrupt any currently playing instances of audio with the same source,\n\t * if the maximum number of instances of the sound are already playing. Values are defined as <code>INTERRUPT_TYPE</code>\n\t * constants on the Sound class, with the default defined by {{#crossLink \"Sound/defaultInterruptBehavior:property\"}}{{/crossLink}}.</li>\n\t * <li>delay - The amount of time to delay the start of audio playback, in milliseconds.</li>\n\t * <li>offset - The offset from the start of the audio to begin playback, in milliseconds.</li>\n\t * <li>loop - How many times the audio loops when it reaches the end of playback. The default is 0 (no\n\t * loops), and -1 can be used for infinite playback.</li>\n\t * <li>volume - The volume of the sound, between 0 and 1. Note that the master volume is applied\n\t * against the individual volume.</li>\n\t * <li>pan - The left-right pan of the sound (if supported), between -1 (left) and 1 (right).</li>\n\t * <li>startTime - To create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.</li>\n\t * <li>duration - To create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.</li>\n\t * </ul>\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \tvar ppc = new createjs.PlayPropsConfig().set({interrupt: createjs.Sound.INTERRUPT_ANY, loop: -1, volume: 0.5})\n\t * \tcreatejs.Sound.play(\"mySound\", ppc);\n\t * \tmySoundInstance.play(ppc);\n\t *\n\t * @class PlayPropsConfig\n\t * @constructor\n\t * @since 0.6.1\n\t */\n\t// TODO think of a better name for this class\n\tvar PlayPropsConfig = function () {\n// Public Properties\n\t\t/**\n\t\t * How to interrupt any currently playing instances of audio with the same source,\n\t\t * if the maximum number of instances of the sound are already playing. Values are defined as\n\t\t * <code>INTERRUPT_TYPE</code> constants on the Sound class, with the default defined by\n\t\t * {{#crossLink \"Sound/defaultInterruptBehavior:property\"}}{{/crossLink}}.\n\t\t * @property interrupt\n\t\t * @type {string}\n\t\t * @default null\n\t\t */\n\t\tthis.interrupt = null;\n\n\t\t/**\n\t\t * The amount of time to delay the start of audio playback, in milliseconds.\n\t\t * @property delay\n\t\t * @type {Number}\n\t\t * @default null\n\t\t */\n\t\tthis.delay = null;\n\n\t\t/**\n\t\t * The offset from the start of the audio to begin playback, in milliseconds.\n\t\t * @property offset\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.offset = null;\n\n\t\t/**\n\t\t * How many times the audio loops when it reaches the end of playback. The default is 0 (no\n\t\t * loops), and -1 can be used for infinite playback.\n\t\t * @property loop\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.loop = null;\n\n\t\t/**\n\t\t * The volume of the sound, between 0 and 1. Note that the master volume is applied\n\t\t * against the individual volume.\n\t\t * @property volume\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.volume = null;\n\n\t\t/**\n\t\t * The left-right pan of the sound (if supported), between -1 (left) and 1 (right).\n\t\t * @property pan\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.pan = null;\n\n\t\t/**\n\t\t * Used to create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.\n\t\t * @property startTime\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.startTime = null;\n\n\t\t/**\n\t\t * Used to create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.\n\t\t * @property duration\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.duration = null;\n\t};\n\tvar p = PlayPropsConfig.prototype = {};\n\tvar s = PlayPropsConfig;\n\n\n// Static Methods\n\t/**\n\t * Creates a PlayPropsConfig from another PlayPropsConfig or an Object.\n\t *\n\t * @method create\n\t * @param {PlayPropsConfig|Object} value The play properties\n\t * @returns {PlayPropsConfig}\n\t * @static\n\t */\n\ts.create = function (value) {\n\t\tif (value instanceof s || value instanceof Object) {\n\t\t\tvar ppc = new createjs.PlayPropsConfig();\n\t\t\tppc.set(value);\n\t\t\treturn ppc;\n\t\t} else {\n\t\t\tthrow new Error(\"Type not recognized.\");\n\t\t}\n\t};\n\n// Public Methods\n\t/**\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var PlayPropsConfig = new createjs.PlayPropsConfig().set({loop:-1, volume:0.7});\n\t *\n\t * @method set\n\t * @param {Object} props A generic object containing properties to copy to the PlayPropsConfig instance.\n\t * @return {PlayPropsConfig} Returns the instance the method is called on (useful for chaining calls.)\n\t*/\n\tp.set = function(props) {\n\t\tfor (var n in props) { this[n] = props[n]; }\n\t\treturn this;\n\t};\n\n\tp.toString = function() {\n\t\treturn \"[PlayPropsConfig]\";\n\t};\n\n\tcreatejs.PlayPropsConfig = s;\n\n}());\n\n//##############################################################################\n// Sound.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * The Sound class is the public API for creating sounds, controlling the overall sound levels, and managing plugins.\n\t * All Sound APIs on this class are static.\n\t *\n\t * <b>Registering and Preloading</b><br />\n\t * Before you can play a sound, it <b>must</b> be registered. You can do this with {{#crossLink \"Sound/registerSound\"}}{{/crossLink}},\n\t * or register multiple sounds using {{#crossLink \"Sound/registerSounds\"}}{{/crossLink}}. If you don't register a\n\t * sound prior to attempting to play it using {{#crossLink \"Sound/play\"}}{{/crossLink}} or create it using {{#crossLink \"Sound/createInstance\"}}{{/crossLink}},\n\t * the sound source will be automatically registered but playback will fail as the source will not be ready. If you use\n\t * <a href=\"http://preloadjs.com\" target=\"_blank\">PreloadJS</a>, registration is handled for you when the sound is\n\t * preloaded. It is recommended to preload sounds either internally using the register functions or externally using\n\t * PreloadJS so they are ready when you want to use them.\n\t *\n\t * <b>Playback</b><br />\n\t * To play a sound once it's been registered and preloaded, use the {{#crossLink \"Sound/play\"}}{{/crossLink}} method.\n\t * This method returns a {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} which can be paused, resumed, muted, etc.\n\t * Please see the {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} documentation for more on the instance control APIs.\n\t *\n\t * <b>Plugins</b><br />\n\t * By default, the {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}} or the {{#crossLink \"HTMLAudioPlugin\"}}{{/crossLink}}\n\t * are used (when available), although developers can change plugin priority or add new plugins (such as the\n\t * provided {{#crossLink \"FlashAudioPlugin\"}}{{/crossLink}}). Please see the {{#crossLink \"Sound\"}}{{/crossLink}} API\n\t * methods for more on the playback and plugin APIs. To install plugins, or specify a different plugin order, see\n\t * {{#crossLink \"Sound/installPlugins\"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.FlashAudioPlugin.swfPath = \"../src/soundjs/flashaudio\";\n\t *      createjs.Sound.registerPlugins([createjs.WebAudioPlugin, createjs.FlashAudioPlugin]);\n\t *      createjs.Sound.alternateExtensions = [\"mp3\"];\n\t *      createjs.Sound.on(\"fileload\", this.loadHandler, this);\n\t *      createjs.Sound.registerSound(\"path/to/mySound.ogg\", \"sound\");\n\t *      function loadHandler(event) {\n     *          // This is fired for each sound that is registered.\n     *          var instance = createjs.Sound.play(\"sound\");  // play using id.  Could also use full source path or event.src.\n     *          instance.on(\"complete\", this.handleComplete, this);\n     *          instance.volume = 0.5;\n\t *      }\n\t *\n\t * The maximum number of concurrently playing instances of the same sound can be specified in the \"data\" argument\n\t * of {{#crossLink \"Sound/registerSound\"}}{{/crossLink}}.  Note that if not specified, the active plugin will apply\n\t * a default limit.  Currently HTMLAudioPlugin sets a default limit of 2, while WebAudioPlugin and FlashAudioPlugin set a\n\t * default limit of 100.\n\t *\n\t *      createjs.Sound.registerSound(\"sound.mp3\", \"soundId\", 4);\n\t *\n\t * Sound can be used as a plugin with PreloadJS to help preload audio properly. Audio preloaded with PreloadJS is\n\t * automatically registered with the Sound class. When audio is not preloaded, Sound will do an automatic internal\n\t * load. As a result, it may fail to play the first time play is called if the audio is not finished loading. Use\n\t * the {{#crossLink \"Sound/fileload:event\"}}{{/crossLink}} event to determine when a sound has finished internally\n\t * preloading. It is recommended that all audio is preloaded before it is played.\n\t *\n\t *      var queue = new createjs.LoadQueue();\n\t *\t\tqueue.installPlugin(createjs.Sound);\n\t *\n\t * <b>Audio Sprites</b><br />\n\t * SoundJS has added support for {{#crossLink \"AudioSprite\"}}{{/crossLink}}, available as of version 0.6.0.\n\t * For those unfamiliar with audio sprites, they are much like CSS sprites or sprite sheets: multiple audio assets\n\t * grouped into a single file.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *\t\tvar assetsPath = \"./assets/\";\n\t *\t\tvar sounds = [{\n\t *\t\t\tsrc:\"MyAudioSprite.ogg\", data: {\n\t *\t\t\t\taudioSprite: [\n\t *\t\t\t\t\t{id:\"sound1\", startTime:0, duration:500},\n\t *\t\t\t\t\t{id:\"sound2\", startTime:1000, duration:400},\n\t *\t\t\t\t\t{id:\"sound3\", startTime:1700, duration: 1000}\n\t *\t\t\t\t]}\n \t *\t\t\t}\n\t *\t\t];\n\t *\t\tcreatejs.Sound.alternateExtensions = [\"mp3\"];\n\t *\t\tcreatejs.Sound.on(\"fileload\", loadSound);\n\t *\t\tcreatejs.Sound.registerSounds(sounds, assetsPath);\n\t *\t\t// after load is complete\n\t *\t\tcreatejs.Sound.play(\"sound2\");\n\t *\n\t * <b>Mobile Playback</b><br />\n\t * Devices running iOS require the WebAudio context to be \"unlocked\" by playing at least one sound inside of a user-\n\t * initiated event (such as touch/click). Earlier versions of SoundJS included a \"MobileSafe\" sample, but this is no\n\t * longer necessary as of SoundJS 0.6.2.\n\t * <ul>\n\t *     <li>\n\t *         In SoundJS 0.4.1 and above, you can either initialize plugins or use the {{#crossLink \"WebAudioPlugin/playEmptySound\"}}{{/crossLink}}\n\t *         method in the call stack of a user input event to manually unlock the audio context.\n\t *     </li>\n\t *     <li>\n\t *         In SoundJS 0.6.2 and above, SoundJS will automatically listen for the first document-level \"mousedown\"\n\t *         and \"touchend\" event, and unlock WebAudio. This will continue to check these events until the WebAudio\n\t *         context becomes \"unlocked\" (changes from \"suspended\" to \"running\")\n\t *     </li>\n\t *     <li>\n\t *         Both the \"mousedown\" and \"touchend\" events can be used to unlock audio in iOS9+, the \"touchstart\" event\n\t *         will work in iOS8 and below. The \"touchend\" event will only work in iOS9 when the gesture is interpreted\n\t *         as a \"click\", so if the user long-presses the button, it will no longer work.\n\t *     </li>\n\t *     <li>\n\t *         When using the <a href=\"http://www.createjs.com/docs/easeljs/classes/Touch.html\">EaselJS Touch class</a>,\n\t *         the \"mousedown\" event will not fire when a canvas is clicked, since MouseEvents are prevented, to ensure\n\t *         only touch events fire. To get around this, you can either rely on \"touchend\", or:\n\t *         <ol>\n\t *             <li>Set the `allowDefault` property on the Touch class constructor to `true` (defaults to `false`).</li>\n\t *             <li>Set the `preventSelection` property on the EaselJS `Stage` to `false`.</li>\n\t *         </ol>\n\t *         These settings may change how your application behaves, and are not recommended.\n\t *     </li>\n\t * </ul>\n\t *\n\t * <b>Loading Alternate Paths and Extension-less Files</b><br />\n\t * SoundJS supports loading alternate paths and extension-less files by passing an object instead of a string for\n\t * the `src` property, which is a hash using the format `{extension:\"path\", extension2:\"path2\"}`. These labels are\n\t * how SoundJS determines if the browser will support the sound. This also enables multiple formats to live in\n\t * different folders, or on CDNs, which often has completely different filenames for each file.\n\t *\n\t * Priority is determined by the property order (first property is tried first).  This is supported by both internal loading\n\t * and loading with PreloadJS.\n\t *\n\t * <em>Note: an id is required for playback.</em>\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *\t\tvar sounds = {path:\"./audioPath/\",\n\t * \t\t\t\tmanifest: [\n\t *\t\t\t\t{id: \"cool\", src: {mp3:\"mp3/awesome.mp3\", ogg:\"noExtensionOggFile\"}}\n\t *\t\t]};\n\t *\n\t *\t\tcreatejs.Sound.alternateExtensions = [\"mp3\"];\n\t *\t\tcreatejs.Sound.addEventListener(\"fileload\", handleLoad);\n\t *\t\tcreatejs.Sound.registerSounds(sounds);\n\t *\n\t * <h3>Known Browser and OS issues</h3>\n\t * <b>IE 9 HTML Audio limitations</b><br />\n\t * <ul><li>There is a delay in applying volume changes to tags that occurs once playback is started. So if you have\n\t * muted all sounds, they will all play during this delay until the mute applies internally. This happens regardless of\n\t * when or how you apply the volume change, as the tag seems to need to play to apply it.</li>\n     * <li>MP3 encoding will not always work for audio tags, particularly in Internet Explorer. We've found default\n\t * encoding with 64kbps works.</li>\n\t * <li>Occasionally very short samples will get cut off.</li>\n\t * <li>There is a limit to how many audio tags you can load and play at once, which appears to be determined by\n\t * hardware and browser settings.  See {{#crossLink \"HTMLAudioPlugin.MAX_INSTANCES\"}}{{/crossLink}} for a safe\n\t * estimate.</li></ul>\n\t *\n\t * <b>Firefox 25 Web Audio limitations</b>\n\t * <ul><li>mp3 audio files do not load properly on all windows machines, reported\n\t * <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=929969\" target=\"_blank\">here</a>. </br>\n\t * For this reason it is recommended to pass another FF supported type (ie ogg) first until this bug is resolved, if\n\t * possible.</li></ul>\n\n\t * <b>Safari limitations</b><br />\n\t * <ul><li>Safari requires Quicktime to be installed for audio playback.</li></ul>\n\t *\n\t * <b>iOS 6 Web Audio limitations</b><br />\n\t * <ul><li>Sound is initially locked, and must be unlocked via a user-initiated event. Please see the section on\n\t * Mobile Playback above.</li>\n\t * <li>A bug exists that will distort un-cached web audio when a video element is present in the DOM that has audio\n\t * at a different sampleRate.</li>\n\t * </ul>\n\t *\n\t * <b>Android HTML Audio limitations</b><br />\n\t * <ul><li>We have no control over audio volume. Only the user can set volume on their device.</li>\n\t * <li>We can only play audio inside a user event (touch/click).  This currently means you cannot loop sound or use\n\t * a delay.</li></ul>\n\t *\n\t * <b>Web Audio and PreloadJS</b><br />\n\t * <ul><li>Web Audio must be loaded through XHR, therefore when used with PreloadJS, tag loading is not possible.\n\t * This means that tag loading can not be used to avoid cross domain issues.</li><ul>\n\t *\n\t * @class Sound\n\t * @static\n\t * @uses EventDispatcher\n\t */\n\tfunction Sound() {\n\t\tthrow \"Sound cannot be instantiated\";\n\t}\n\n\tvar s = Sound;\n\n\n// Static Properties\n\t/**\n\t * The interrupt value to interrupt any currently playing instance with the same source, if the maximum number of\n\t * instances of the sound are already playing.\n\t * @property INTERRUPT_ANY\n\t * @type {String}\n\t * @default any\n\t * @static\n\t */\n\ts.INTERRUPT_ANY = \"any\";\n\n\t/**\n\t * The interrupt value to interrupt the earliest currently playing instance with the same source that progressed the\n\t * least distance in the audio track, if the maximum number of instances of the sound are already playing.\n\t * @property INTERRUPT_EARLY\n\t * @type {String}\n\t * @default early\n\t * @static\n\t */\n\ts.INTERRUPT_EARLY = \"early\";\n\n\t/**\n\t * The interrupt value to interrupt the currently playing instance with the same source that progressed the most\n\t * distance in the audio track, if the maximum number of instances of the sound are already playing.\n\t * @property INTERRUPT_LATE\n\t * @type {String}\n\t * @default late\n\t * @static\n\t */\n\ts.INTERRUPT_LATE = \"late\";\n\n\t/**\n\t * The interrupt value to not interrupt any currently playing instances with the same source, if the maximum number of\n\t * instances of the sound are already playing.\n\t * @property INTERRUPT_NONE\n\t * @type {String}\n\t * @default none\n\t * @static\n\t */\n\ts.INTERRUPT_NONE = \"none\";\n\n\t/**\n\t * Defines the playState of an instance that is still initializing.\n\t * @property PLAY_INITED\n\t * @type {String}\n\t * @default playInited\n\t * @static\n\t */\n\ts.PLAY_INITED = \"playInited\";\n\n\t/**\n\t * Defines the playState of an instance that is currently playing or paused.\n\t * @property PLAY_SUCCEEDED\n\t * @type {String}\n\t * @default playSucceeded\n\t * @static\n\t */\n\ts.PLAY_SUCCEEDED = \"playSucceeded\";\n\n\t/**\n\t * Defines the playState of an instance that was interrupted by another instance.\n\t * @property PLAY_INTERRUPTED\n\t * @type {String}\n\t * @default playInterrupted\n\t * @static\n\t */\n\ts.PLAY_INTERRUPTED = \"playInterrupted\";\n\n\t/**\n\t * Defines the playState of an instance that completed playback.\n\t * @property PLAY_FINISHED\n\t * @type {String}\n\t * @default playFinished\n\t * @static\n\t */\n\ts.PLAY_FINISHED = \"playFinished\";\n\n\t/**\n\t * Defines the playState of an instance that failed to play. This is usually caused by a lack of available channels\n\t * when the interrupt mode was \"INTERRUPT_NONE\", the playback stalled, or the sound could not be found.\n\t * @property PLAY_FAILED\n\t * @type {String}\n\t * @default playFailed\n\t * @static\n\t */\n\ts.PLAY_FAILED = \"playFailed\";\n\n\t/**\n\t * A list of the default supported extensions that Sound will <i>try</i> to play. Plugins will check if the browser\n\t * can play these types, so modifying this list before a plugin is initialized will allow the plugins to try to\n\t * support additional media types.\n\t *\n\t * NOTE this does not currently work for {{#crossLink \"FlashAudioPlugin\"}}{{/crossLink}}.\n\t *\n\t * More details on file formats can be found at <a href=\"http://en.wikipedia.org/wiki/Audio_file_format\" target=\"_blank\">http://en.wikipedia.org/wiki/Audio_file_format</a>.<br />\n\t * A very detailed list of file formats can be found at <a href=\"http://www.fileinfo.com/filetypes/audio\" target=\"_blank\">http://www.fileinfo.com/filetypes/audio</a>.\n\t * @property SUPPORTED_EXTENSIONS\n\t * @type {Array[String]}\n\t * @default [\"mp3\", \"ogg\", \"opus\", \"mpeg\", \"wav\", \"m4a\", \"mp4\", \"aiff\", \"wma\", \"mid\"]\n\t * @since 0.4.0\n\t * @static\n\t */\n\ts.SUPPORTED_EXTENSIONS = [\"mp3\", \"ogg\", \"opus\", \"mpeg\", \"wav\", \"m4a\", \"mp4\", \"aiff\", \"wma\", \"mid\"];\n\n\t/**\n\t * Some extensions use another type of extension support to play (one of them is a codex).  This allows you to map\n\t * that support so plugins can accurately determine if an extension is supported.  Adding to this list can help\n\t * plugins determine more accurately if an extension is supported.\n\t *\n \t * A useful list of extensions for each format can be found at <a href=\"http://html5doctor.com/html5-audio-the-state-of-play/\" target=\"_blank\">http://html5doctor.com/html5-audio-the-state-of-play/</a>.\n\t * @property EXTENSION_MAP\n\t * @type {Object}\n\t * @since 0.4.0\n\t * @default {m4a:\"mp4\"}\n\t * @static\n\t */\n\ts.EXTENSION_MAP = {\n\t\tm4a:\"mp4\"\n\t};\n\n\t/**\n\t * The RegExp pattern used to parse file URIs. This supports simple file names, as well as full domain URIs with\n\t * query strings. The resulting match is: protocol:$1 domain:$2 path:$3 file:$4 extension:$5 query:$6.\n\t * @property FILE_PATTERN\n\t * @type {RegExp}\n\t * @static\n\t * @protected\n\t */\n\ts.FILE_PATTERN = /^(?:(\\w+:)\\/{2}(\\w+(?:\\.\\w+)*\\/?))?([/.]*?(?:[^?]+)?\\/)?((?:[^/?]+)\\.(\\w+))(?:\\?(\\S+)?)?$/;\n\n\n// Class Public properties\n\t/**\n\t * Determines the default behavior for interrupting other currently playing instances with the same source, if the\n\t * maximum number of instances of the sound are already playing.  Currently the default is {{#crossLink \"Sound/INTERRUPT_NONE:property\"}}{{/crossLink}}\n\t * but this can be set and will change playback behavior accordingly.  This is only used when {{#crossLink \"Sound/play\"}}{{/crossLink}}\n\t * is called without passing a value for interrupt.\n\t * @property defaultInterruptBehavior\n\t * @type {String}\n\t * @default Sound.INTERRUPT_NONE, or \"none\"\n\t * @static\n\t * @since 0.4.0\n\t */\n\ts.defaultInterruptBehavior = s.INTERRUPT_NONE;  // OJR does s.INTERRUPT_ANY make more sense as default?  Needs game dev testing to see which case makes more sense.\n\n\t/**\n\t * An array of extensions to attempt to use when loading sound, if the default is unsupported by the active plugin.\n\t * These are applied in order, so if you try to Load Thunder.ogg in a browser that does not support ogg, and your\n\t * extensions array is [\"mp3\", \"m4a\", \"wav\"] it will check mp3 support, then m4a, then wav. The audio files need\n\t * to exist in the same location, as only the extension is altered.\n\t *\n\t * Note that regardless of which file is loaded, you can call {{#crossLink \"Sound/createInstance\"}}{{/crossLink}}\n\t * and {{#crossLink \"Sound/play\"}}{{/crossLink}} using the same id or full source path passed for loading.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *\tvar sounds = [\n\t *\t\t{src:\"myPath/mySound.ogg\", id:\"example\"},\n\t *\t];\n\t *\tcreatejs.Sound.alternateExtensions = [\"mp3\"]; // now if ogg is not supported, SoundJS will try asset0.mp3\n\t *\tcreatejs.Sound.on(\"fileload\", handleLoad); // call handleLoad when each sound loads\n\t *\tcreatejs.Sound.registerSounds(sounds, assetPath);\n\t *\t// ...\n\t *\tcreatejs.Sound.play(\"myPath/mySound.ogg\"); // works regardless of what extension is supported.  Note calling with ID is a better approach\n\t *\n\t * @property alternateExtensions\n\t * @type {Array}\n\t * @since 0.5.2\n\t * @static\n\t */\n\ts.alternateExtensions = [];\n\n\t/**\n\t * The currently active plugin. If this is null, then no plugin could be initialized. If no plugin was specified,\n\t * Sound attempts to apply the default plugins: {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}}, followed by\n\t * {{#crossLink \"HTMLAudioPlugin\"}}{{/crossLink}}.\n\t * @property activePlugin\n\t * @type {Object}\n\t * @static\n\t */\n    s.activePlugin = null;\n\n\n// class getter / setter properties\n\t/**\n\t * Set the master volume of Sound. The master volume is multiplied against each sound's individual volume.  For\n\t * example, if master volume is 0.5 and a sound's volume is 0.5, the resulting volume is 0.25. To set individual\n\t * sound volume, use AbstractSoundInstance {{#crossLink \"AbstractSoundInstance/volume:property\"}}{{/crossLink}} instead.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     createjs.Sound.volume = 0.5;\n\t *\n\t *\n\t * @property volume\n\t * @type {Number}\n\t * @default 1\n\t * @since 0.6.1\n\t */\n\ts._masterVolume = 1;\n\tObject.defineProperty(s, \"volume\", {\n\t\tget: function () {return this._masterVolume;},\n\t\tset: function (value) {\n\t\t\t\tif (Number(value) == null) {return false;}\n\t\t\t\tvalue = Math.max(0, Math.min(1, value));\n\t\t\t\ts._masterVolume = value;\n\t\t\t\tif (!this.activePlugin || !this.activePlugin.setVolume || !this.activePlugin.setVolume(value)) {\n\t\t\t\t\tvar instances = this._instances;\n\t\t\t\t\tfor (var i = 0, l = instances.length; i < l; i++) {\n\t\t\t\t\t\tinstances[i].setMasterVolume(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t});\n\n\t/**\n\t * Mute/Unmute all audio. Note that muted audio still plays at 0 volume. This global mute value is maintained\n\t * separately and when set will override, but not change the mute property of individual instances. To mute an individual\n\t * instance, use AbstractSoundInstance {{#crossLink \"AbstractSoundInstance/muted:property\"}}{{/crossLink}} instead.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     createjs.Sound.muted = true;\n\t *\n\t *\n\t * @property muted\n\t * @type {Boolean}\n\t * @default false\n\t * @since 0.6.1\n\t */\n\ts._masterMute = false;\n\t// OJR references to the methods were not working, so the code had to be duplicated here\n\tObject.defineProperty(s, \"muted\", {\n\t\tget: function () {return this._masterMute;},\n\t\tset: function (value) {\n\t\t\t\tif (value == null) {return false;}\n\n\t\t\t\tthis._masterMute = value;\n\t\t\t\tif (!this.activePlugin || !this.activePlugin.setMute || !this.activePlugin.setMute(value)) {\n\t\t\t\t\tvar instances = this._instances;\n\t\t\t\t\tfor (var i = 0, l = instances.length; i < l; i++) {\n\t\t\t\t\t\tinstances[i].setMasterMute(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t});\n\n\t/**\n\t * Get the active plugins capabilities, which help determine if a plugin can be used in the current environment,\n\t * or if the plugin supports a specific feature. Capabilities include:\n\t * <ul>\n\t *     <li><b>panning:</b> If the plugin can pan audio from left to right</li>\n\t *     <li><b>volume;</b> If the plugin can control audio volume.</li>\n\t *     <li><b>tracks:</b> The maximum number of audio tracks that can be played back at a time. This will be -1\n\t *     if there is no known limit.</li>\n\t * <br />An entry for each file type in {{#crossLink \"Sound/SUPPORTED_EXTENSIONS:property\"}}{{/crossLink}}:\n\t *     <li><b>mp3:</b> If MP3 audio is supported.</li>\n\t *     <li><b>ogg:</b> If OGG audio is supported.</li>\n\t *     <li><b>wav:</b> If WAV audio is supported.</li>\n\t *     <li><b>mpeg:</b> If MPEG audio is supported.</li>\n\t *     <li><b>m4a:</b> If M4A audio is supported.</li>\n\t *     <li><b>mp4:</b> If MP4 audio is supported.</li>\n\t *     <li><b>aiff:</b> If aiff audio is supported.</li>\n\t *     <li><b>wma:</b> If wma audio is supported.</li>\n\t *     <li><b>mid:</b> If mid audio is supported.</li>\n\t * </ul>\n\t *\n\t * You can get a specific capability of the active plugin using standard object notation\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var mp3 = createjs.Sound.capabilities.mp3;\n\t *\n\t * Note this property is read only.\n\t *\n\t * @property capabilities\n\t * @type {Object}\n\t * @static\n\t * @readOnly\n\t * @since 0.6.1\n\t */\n\tObject.defineProperty(s, \"capabilities\", {\n\t\tget: function () {\n\t\t\t\t\tif (s.activePlugin == null) {return null;}\n\t\t\t\t\treturn s.activePlugin._capabilities;\n\t\t\t\t},\n\t\tset: function (value) { return false;}\n\t});\n\n\n// Class Private properties\n\t/**\n\t * Determines if the plugins have been registered. If false, the first call to play() will instantiate the default\n\t * plugins ({{#crossLink \"WebAudioPlugin\"}}{{/crossLink}}, followed by {{#crossLink \"HTMLAudioPlugin\"}}{{/crossLink}}).\n\t * If plugins have been registered, but none are applicable, then sound playback will fail.\n\t * @property _pluginsRegistered\n\t * @type {Boolean}\n\t * @default false\n\t * @static\n\t * @protected\n\t */\n\ts._pluginsRegistered = false;\n\n\t/**\n\t * Used internally to assign unique IDs to each AbstractSoundInstance.\n\t * @property _lastID\n\t * @type {Number}\n\t * @static\n\t * @protected\n\t */\n\ts._lastID = 0;\n\n\t/**\n\t * An array containing all currently playing instances. This allows Sound to control the volume, mute, and playback of\n\t * all instances when using static APIs like {{#crossLink \"Sound/stop\"}}{{/crossLink}} and {{#crossLink \"Sound/setVolume\"}}{{/crossLink}}.\n\t * When an instance has finished playback, it gets removed via the {{#crossLink \"Sound/finishedPlaying\"}}{{/crossLink}}\n\t * method. If the user replays an instance, it gets added back in via the {{#crossLink \"Sound/_beginPlaying\"}}{{/crossLink}}\n\t * method.\n\t * @property _instances\n\t * @type {Array}\n\t * @protected\n\t * @static\n\t */\n\ts._instances = [];\n\n\t/**\n\t * An object hash storing objects with sound sources, startTime, and duration via there corresponding ID.\n\t * @property _idHash\n\t * @type {Object}\n\t * @protected\n\t * @static\n\t */\n\ts._idHash = {};\n\n\t/**\n\t * An object hash that stores preloading sound sources via the parsed source that is passed to the plugin.  Contains the\n\t * source, id, and data that was passed in by the user.  Parsed sources can contain multiple instances of source, id,\n\t * and data.\n\t * @property _preloadHash\n\t * @type {Object}\n\t * @protected\n\t * @static\n\t */\n\ts._preloadHash = {};\n\n\t/**\n\t * An object hash storing {{#crossLink \"PlayPropsConfig\"}}{{/crossLink}} via the parsed source that is passed as defaultPlayProps in\n\t * {{#crossLink \"Sound/registerSound\"}}{{/crossLink}} and {{#crossLink \"Sound/registerSounds\"}}{{/crossLink}}.\n\t * @property _defaultPlayPropsHash\n\t * @type {Object}\n\t * @protected\n\t * @static\n\t * @since 0.6.1\n\t */\n\ts._defaultPlayPropsHash = {};\n\n\n// EventDispatcher methods:\n\ts.addEventListener = null;\n\ts.removeEventListener = null;\n\ts.removeAllEventListeners = null;\n\ts.dispatchEvent = null;\n\ts.hasEventListener = null;\n\ts._listeners = null;\n\n\tcreatejs.EventDispatcher.initialize(s); // inject EventDispatcher methods.\n\n\n// Events\n\t/**\n\t * This event is fired when a file finishes loading internally. This event is fired for each loaded sound,\n\t * so any handler methods should look up the <code>event.src</code> to handle a particular sound.\n\t * @event fileload\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {String} src The source of the sound that was loaded.\n\t * @param {String} [id] The id passed in when the sound was registered. If one was not provided, it will be null.\n\t * @param {Number|Object} [data] Any additional data associated with the item. If not provided, it will be undefined.\n\t * @since 0.4.1\n\t */\n\n\t/**\n\t * This event is fired when a file fails loading internally. This event is fired for each loaded sound,\n\t * so any handler methods should look up the <code>event.src</code> to handle a particular sound.\n\t * @event fileerror\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {String} src The source of the sound that was loaded.\n\t * @param {String} [id] The id passed in when the sound was registered. If one was not provided, it will be null.\n\t * @param {Number|Object} [data] Any additional data associated with the item. If not provided, it will be undefined.\n\t * @since 0.6.0\n\t */\n\n\n// Class Public Methods\n\t/**\n\t * Get the preload rules to allow Sound to be used as a plugin by <a href=\"http://preloadjs.com\" target=\"_blank\">PreloadJS</a>.\n\t * Any load calls that have the matching type or extension will fire the callback method, and use the resulting\n\t * object, which is potentially modified by Sound. This helps when determining the correct path, as well as\n\t * registering the audio instance(s) with Sound. This method should not be called, except by PreloadJS.\n\t * @method getPreloadHandlers\n\t * @return {Object} An object containing:\n\t * <ul><li>callback: A preload callback that is fired when a file is added to PreloadJS, which provides\n\t *      Sound a mechanism to modify the load parameters, select the correct file format, register the sound, etc.</li>\n\t *      <li>types: A list of file types that are supported by Sound (currently supports \"sound\").</li>\n\t *      <li>extensions: A list of file extensions that are supported by Sound (see {{#crossLink \"Sound/SUPPORTED_EXTENSIONS:property\"}}{{/crossLink}}).</li></ul>\n\t * @static\n\t * @protected\n\t */\n\ts.getPreloadHandlers = function () {\n\t\treturn {\n\t\t\tcallback:createjs.proxy(s.initLoad, s),\n\t\t\ttypes:[\"sound\"],\n\t\t\textensions:s.SUPPORTED_EXTENSIONS\n\t\t};\n\t};\n\n\t/**\n\t * Used to dispatch fileload events from internal loading.\n\t * @method _handleLoadComplete\n\t * @param event A loader event.\n\t * @protected\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts._handleLoadComplete = function(event) {\n\t\tvar src = event.target.getItem().src;\n\t\tif (!s._preloadHash[src]) {return;}\n\n\t\tfor (var i = 0, l = s._preloadHash[src].length; i < l; i++) {\n\t\t\tvar item = s._preloadHash[src][i];\n\t\t\ts._preloadHash[src][i] = true;\n\n\t\t\tif (!s.hasEventListener(\"fileload\")) { continue; }\n\n\t\t\tvar event = new createjs.Event(\"fileload\");\n\t\t\tevent.src = item.src;\n\t\t\tevent.id = item.id;\n\t\t\tevent.data = item.data;\n\t\t\tevent.sprite = item.sprite;\n\n\t\t\ts.dispatchEvent(event);\n\t\t}\n\t};\n\n\t/**\n\t * Used to dispatch error events from internal preloading.\n\t * @param event\n\t * @protected\n\t * @since 0.6.0\n\t * @static\n\t */\n\ts._handleLoadError = function(event) {\n\t\tvar src = event.target.getItem().src;\n\t\tif (!s._preloadHash[src]) {return;}\n\n\t\tfor (var i = 0, l = s._preloadHash[src].length; i < l; i++) {\n\t\t\tvar item = s._preloadHash[src][i];\n\t\t\ts._preloadHash[src][i] = false;\n\n\t\t\tif (!s.hasEventListener(\"fileerror\")) { continue; }\n\n\t\t\tvar event = new createjs.Event(\"fileerror\");\n\t\t\tevent.src = item.src;\n\t\t\tevent.id = item.id;\n\t\t\tevent.data = item.data;\n\t\t\tevent.sprite = item.sprite;\n\n\t\t\ts.dispatchEvent(event);\n\t\t}\n\t};\n\n\t/**\n\t * Used by {{#crossLink \"Sound/registerPlugins\"}}{{/crossLink}} to register a Sound plugin.\n\t *\n\t * @method _registerPlugin\n\t * @param {Object} plugin The plugin class to install.\n\t * @return {Boolean} Whether the plugin was successfully initialized.\n\t * @static\n\t * @private\n\t */\n\ts._registerPlugin = function (plugin) {\n\t\t// Note: Each plugin is passed in as a class reference, but we store the activePlugin as an instance\n\t\tif (plugin.isSupported()) {\n\t\t\ts.activePlugin = new plugin();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Register a list of Sound plugins, in order of precedence. To register a single plugin, pass a single element in the array.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.FlashAudioPlugin.swfPath = \"../src/soundjs/flashaudio/\";\n\t *      createjs.Sound.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin, createjs.FlashAudioPlugin]);\n\t *\n\t * @method registerPlugins\n\t * @param {Array} plugins An array of plugins classes to install.\n\t * @return {Boolean} Whether a plugin was successfully initialized.\n\t * @static\n\t */\n\ts.registerPlugins = function (plugins) {\n\t\ts._pluginsRegistered = true;\n\t\tfor (var i = 0, l = plugins.length; i < l; i++) {\n\t\t\tif (s._registerPlugin(plugins[i])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Initialize the default plugins. This method is automatically called when any audio is played or registered before\n\t * the user has manually registered plugins, and enables Sound to work without manual plugin setup. Currently, the\n\t * default plugins are {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}} followed by {{#crossLink \"HTMLAudioPlugin\"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \tif (!createjs.initializeDefaultPlugins()) { return; }\n\t *\n\t * @method initializeDefaultPlugins\n\t * @returns {Boolean} True if a plugin was initialized, false otherwise.\n\t * @since 0.4.0\n\t * @static\n\t */\n\ts.initializeDefaultPlugins = function () {\n\t\tif (s.activePlugin != null) {return true;}\n\t\tif (s._pluginsRegistered) {return false;}\n\t\tif (s.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin])) {return true;}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Determines if Sound has been initialized, and a plugin has been activated.\n\t *\n\t * <h4>Example</h4>\n\t * This example sets up a Flash fallback, but only if there is no plugin specified yet.\n\t *\n\t * \tif (!createjs.Sound.isReady()) {\n\t *\t\tcreatejs.FlashAudioPlugin.swfPath = \"../src/soundjs/flashaudio/\";\n\t * \t\tcreatejs.Sound.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin, createjs.FlashAudioPlugin]);\n\t *\t}\n\t *\n\t * @method isReady\n\t * @return {Boolean} If Sound has initialized a plugin.\n\t * @static\n\t */\n\ts.isReady = function () {\n\t\treturn (s.activePlugin != null);\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink \"Sound/capabilities:property\"}}{{/crossLink}} instead.\n\t *\n\t * @method getCapabilities\n\t * @return {Object} An object containing the capabilities of the active plugin.\n\t * @static\n\t * @deprecated\n\t */\n\ts.getCapabilities = function () {\n\t\tif (s.activePlugin == null) {return null;}\n\t\treturn s.activePlugin._capabilities;\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink \"Sound/capabilities:property\"}}{{/crossLink}} instead.\n\t *\n\t * @method getCapability\n\t * @param {String} key The capability to retrieve\n\t * @return {Number|Boolean} The value of the capability.\n\t * @static\n\t * @see getCapabilities\n\t * @deprecated\n\t */\n\ts.getCapability = function (key) {\n\t\tif (s.activePlugin == null) {return null;}\n\t\treturn s.activePlugin._capabilities[key];\n\t};\n\n\t/**\n\t * Process manifest items from <a href=\"http://preloadjs.com\" target=\"_blank\">PreloadJS</a>. This method is intended\n\t * for usage by a plugin, and not for direct interaction.\n\t * @method initLoad\n\t * @param {Object} src The object to load.\n\t * @return {Object|AbstractLoader} An instance of AbstractLoader.\n\t * @protected\n\t * @static\n\t */\n\ts.initLoad = function (loadItem) {\n\t\treturn s._registerSound(loadItem);\n\t};\n\n\t/**\n\t * Internal method for loading sounds.  This should not be called directly.\n\t *\n\t * @method _registerSound\n\t * @param {Object} src The object to load, containing src property and optionally containing id and data.\n\t * @return {Object} An object with the modified values that were passed in, which defines the sound.\n\t * Returns false if the source cannot be parsed or no plugins can be initialized.\n\t * Returns true if the source is already loaded.\n\t * @static\n\t * @private\n\t * @since 0.6.0\n\t */\n\n\ts._registerSound = function (loadItem) {\n\t\tif (!s.initializeDefaultPlugins()) {return false;}\n\n\t\tvar details;\n\t\tif (loadItem.src instanceof Object) {\n\t\t\tdetails = s._parseSrc(loadItem.src);\n\t\t\tdetails.src = loadItem.path + details.src;\n\t\t} else {\n\t\t\tdetails = s._parsePath(loadItem.src);\n\t\t}\n\t\tif (details == null) {return false;}\n\t\tloadItem.src = details.src;\n\t\tloadItem.type = \"sound\";\n\n\t\tvar data = loadItem.data;\n\t\tvar numChannels = null;\n\t\tif (data != null) {\n\t\t\tif (!isNaN(data.channels)) {\n\t\t\t\tnumChannels = parseInt(data.channels);\n\t\t\t} else if (!isNaN(data)) {\n\t\t\t\tnumChannels = parseInt(data);\n\t\t\t}\n\n\t\t\tif(data.audioSprite) {\n\t\t\t\tvar sp;\n\t\t\t\tfor(var i = data.audioSprite.length; i--; ) {\n\t\t\t\t\tsp = data.audioSprite[i];\n\t\t\t\t\ts._idHash[sp.id] = {src: loadItem.src, startTime: parseInt(sp.startTime), duration: parseInt(sp.duration)};\n\n\t\t\t\t\tif (sp.defaultPlayProps) {\n\t\t\t\t\t\ts._defaultPlayPropsHash[sp.id] = createjs.PlayPropsConfig.create(sp.defaultPlayProps);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (loadItem.id != null) {s._idHash[loadItem.id] = {src: loadItem.src}};\n\t\tvar loader = s.activePlugin.register(loadItem);\n\n\t\tSoundChannel.create(loadItem.src, numChannels);\n\n\t\t// return the number of instances to the user.  This will also be returned in the load event.\n\t\tif (data == null || !isNaN(data)) {\n\t\t\tloadItem.data = numChannels || SoundChannel.maxPerChannel();\n\t\t} else {\n\t\t\tloadItem.data.channels = numChannels || SoundChannel.maxPerChannel();\n\t\t}\n\n\t\tif (loader.type) {loadItem.type = loader.type;}\n\n\t\tif (loadItem.defaultPlayProps) {\n\t\t\ts._defaultPlayPropsHash[loadItem.src] = createjs.PlayPropsConfig.create(loadItem.defaultPlayProps);\n\t\t}\n\t\treturn loader;\n\t};\n\n\t/**\n\t * Register an audio file for loading and future playback in Sound. This is automatically called when using\n\t * <a href=\"http://preloadjs.com\" target=\"_blank\">PreloadJS</a>.  It is recommended to register all sounds that\n\t * need to be played back in order to properly prepare and preload them. Sound does internal preloading when required.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Sound.alternateExtensions = [\"mp3\"];\n\t *      createjs.Sound.on(\"fileload\", handleLoad); // add an event listener for when load is completed\n\t *      createjs.Sound.registerSound(\"myAudioPath/mySound.ogg\", \"myID\", 3);\n\t *      createjs.Sound.registerSound({ogg:\"path1/mySound.ogg\", mp3:\"path2/mySoundNoExtension\"}, \"myID\", 3);\n\t *\n\t *\n\t * @method registerSound\n\t * @param {String | Object} src The source or an Object with a \"src\" property or an Object with multiple extension labeled src properties.\n\t * @param {String} [id] An id specified by the user to play the sound later.  Note id is required for when src is multiple extension labeled src properties.\n\t * @param {Number | Object} [data] Data associated with the item. Sound uses the data parameter as the number of\n\t * channels for an audio instance, however a \"channels\" property can be appended to the data object if it is used\n\t * for other information. The audio channels will set a default based on plugin if no value is found.\n\t * Sound also uses the data property to hold an {{#crossLink \"AudioSprite\"}}{{/crossLink}} array of objects in the following format {id, startTime, duration}.<br/>\n\t *   id used to play the sound later, in the same manner as a sound src with an id.<br/>\n\t *   startTime is the initial offset to start playback and loop from, in milliseconds.<br/>\n\t *   duration is the amount of time to play the clip for, in milliseconds.<br/>\n\t * This allows Sound to support audio sprites that are played back by id.\n\t * @param {string} basePath Set a path that will be prepended to src for loading.\n\t * @param {Object | PlayPropsConfig} defaultPlayProps Optional Playback properties that will be set as the defaults on any new AbstractSoundInstance.\n\t * See {{#crossLink \"PlayPropsConfig\"}}{{/crossLink}} for options.\n\t * @return {Object} An object with the modified values that were passed in, which defines the sound.\n\t * Returns false if the source cannot be parsed or no plugins can be initialized.\n\t * Returns true if the source is already loaded.\n\t * @static\n\t * @since 0.4.0\n\t */\n\ts.registerSound = function (src, id, data, basePath, defaultPlayProps) {\n\t\tvar loadItem = {src: src, id: id, data:data, defaultPlayProps:defaultPlayProps};\n\t\tif (src instanceof Object && src.src) {\n\t\t\tbasePath = id;\n\t\t\tloadItem = src;\n\t\t}\n\t\tloadItem = createjs.LoadItem.create(loadItem);\n\t\tloadItem.path = basePath;\n\n\t\tif (basePath != null && !(loadItem.src instanceof Object)) {loadItem.src = basePath + src;}\n\n\t\tvar loader = s._registerSound(loadItem);\n\t\tif(!loader) {return false;}\n\n\t\tif (!s._preloadHash[loadItem.src]) { s._preloadHash[loadItem.src] = [];}\n\t\ts._preloadHash[loadItem.src].push(loadItem);\n\t\tif (s._preloadHash[loadItem.src].length == 1) {\n\t\t\t// OJR note this will disallow reloading a sound if loading fails or the source changes\n\t\t\tloader.on(\"complete\", createjs.proxy(this._handleLoadComplete, this));\n\t\t\tloader.on(\"error\", createjs.proxy(this._handleLoadError, this));\n\t\t\ts.activePlugin.preload(loader);\n\t\t} else {\n\t\t\tif (s._preloadHash[loadItem.src][0] == true) {return true;}\n\t\t}\n\n\t\treturn loadItem;\n\t};\n\n\t/**\n\t * Register an array of audio files for loading and future playback in Sound. It is recommended to register all\n\t * sounds that need to be played back in order to properly prepare and preload them. Sound does internal preloading\n\t * when required.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \t\tvar assetPath = \"./myAudioPath/\";\n\t *      var sounds = [\n\t *          {src:\"asset0.ogg\", id:\"example\"},\n\t *          {src:\"asset1.ogg\", id:\"1\", data:6},\n\t *          {src:\"asset2.mp3\", id:\"works\"}\n\t *          {src:{mp3:\"path1/asset3.mp3\", ogg:\"path2/asset3NoExtension}, id:\"better\"}\n\t *      ];\n\t *      createjs.Sound.alternateExtensions = [\"mp3\"];\t// if the passed extension is not supported, try this extension\n\t *      createjs.Sound.on(\"fileload\", handleLoad); // call handleLoad when each sound loads\n\t *      createjs.Sound.registerSounds(sounds, assetPath);\n\t *\n\t * @method registerSounds\n\t * @param {Array} sounds An array of objects to load. Objects are expected to be in the format needed for\n\t * {{#crossLink \"Sound/registerSound\"}}{{/crossLink}}: <code>{src:srcURI, id:ID, data:Data}</code>\n\t * with \"id\" and \"data\" being optional.\n\t * You can also pass an object with path and manifest properties, where path is a basePath and manifest is an array of objects to load.\n\t * Note id is required if src is an object with extension labeled src properties.\n\t * @param {string} basePath Set a path that will be prepended to each src when loading.  When creating, playing, or removing\n\t * audio that was loaded with a basePath by src, the basePath must be included.\n\t * @return {Object} An array of objects with the modified values that were passed in, which defines each sound.\n\t * Like registerSound, it will return false for any values when the source cannot be parsed or if no plugins can be initialized.\n\t * Also, it will return true for any values when the source is already loaded.\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.registerSounds = function (sounds, basePath) {\n\t\tvar returnValues = [];\n\t\tif (sounds.path) {\n\t\t\tif (!basePath) {\n\t\t\t\tbasePath = sounds.path;\n\t\t\t} else {\n\t\t\t\tbasePath = basePath + sounds.path;\n\t\t\t}\n\t\t\tsounds = sounds.manifest;\n\t\t\t// TODO document this feature\n\t\t}\n\t\tfor (var i = 0, l = sounds.length; i < l; i++) {\n\t\t\treturnValues[i] = createjs.Sound.registerSound(sounds[i].src, sounds[i].id, sounds[i].data, basePath, sounds[i].defaultPlayProps);\n\t\t}\n\t\treturn returnValues;\n\t};\n\n\t/**\n\t * Remove a sound that has been registered with {{#crossLink \"Sound/registerSound\"}}{{/crossLink}} or\n\t * {{#crossLink \"Sound/registerSounds\"}}{{/crossLink}}.\n\t * <br />Note this will stop playback on active instances playing this sound before deleting them.\n\t * <br />Note if you passed in a basePath, you need to pass it or prepend it to the src here.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Sound.removeSound(\"myID\");\n\t *      createjs.Sound.removeSound(\"myAudioBasePath/mySound.ogg\");\n\t *      createjs.Sound.removeSound(\"myPath/myOtherSound.mp3\", \"myBasePath/\");\n\t *      createjs.Sound.removeSound({mp3:\"musicNoExtension\", ogg:\"music.ogg\"}, \"myBasePath/\");\n\t *\n\t * @method removeSound\n\t * @param {String | Object} src The src or ID of the audio, or an Object with a \"src\" property, or an Object with multiple extension labeled src properties.\n\t * @param {string} basePath Set a path that will be prepended to each src when removing.\n\t * @return {Boolean} True if sound is successfully removed.\n\t * @static\n\t * @since 0.4.1\n\t */\n\ts.removeSound = function(src, basePath) {\n\t\tif (s.activePlugin == null) {return false;}\n\n\t\tif (src instanceof Object && src.src) {src = src.src;}\n\n\t\tvar details;\n\t\tif (src instanceof Object) {\n\t\t\tdetails = s._parseSrc(src);\n\t\t} else {\n\t\t\tsrc = s._getSrcById(src).src;\n\t\t\tdetails = s._parsePath(src);\n\t\t}\n\t\tif (details == null) {return false;}\n\t\tsrc = details.src;\n\t\tif (basePath != null) {src = basePath + src;}\n\n\t\tfor(var prop in s._idHash){\n\t\t\tif(s._idHash[prop].src == src) {\n\t\t\t\tdelete(s._idHash[prop]);\n\t\t\t}\n\t\t}\n\n\t\t// clear from SoundChannel, which also stops and deletes all instances\n\t\tSoundChannel.removeSrc(src);\n\n\t\tdelete(s._preloadHash[src]);\n\n\t\ts.activePlugin.removeSound(src);\n\n\t\treturn true;\n\t};\n\n\t/**\n\t * Remove an array of audio files that have been registered with {{#crossLink \"Sound/registerSound\"}}{{/crossLink}} or\n\t * {{#crossLink \"Sound/registerSounds\"}}{{/crossLink}}.\n\t * <br />Note this will stop playback on active instances playing this audio before deleting them.\n\t * <br />Note if you passed in a basePath, you need to pass it or prepend it to the src here.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \t\tassetPath = \"./myPath/\";\n\t *      var sounds = [\n\t *          {src:\"asset0.ogg\", id:\"example\"},\n\t *          {src:\"asset1.ogg\", id:\"1\", data:6},\n\t *          {src:\"asset2.mp3\", id:\"works\"}\n\t *      ];\n\t *      createjs.Sound.removeSounds(sounds, assetPath);\n\t *\n\t * @method removeSounds\n\t * @param {Array} sounds An array of objects to remove. Objects are expected to be in the format needed for\n\t * {{#crossLink \"Sound/removeSound\"}}{{/crossLink}}: <code>{srcOrID:srcURIorID}</code>.\n\t * You can also pass an object with path and manifest properties, where path is a basePath and manifest is an array of objects to remove.\n\t * @param {string} basePath Set a path that will be prepended to each src when removing.\n\t * @return {Object} An array of Boolean values representing if the sounds with the same array index were\n\t * successfully removed.\n\t * @static\n\t * @since 0.4.1\n\t */\n\ts.removeSounds = function (sounds, basePath) {\n\t\tvar returnValues = [];\n\t\tif (sounds.path) {\n\t\t\tif (!basePath) {\n\t\t\t\tbasePath = sounds.path;\n\t\t\t} else {\n\t\t\t\tbasePath = basePath + sounds.path;\n\t\t\t}\n\t\t\tsounds = sounds.manifest;\n\t\t}\n\t\tfor (var i = 0, l = sounds.length; i < l; i++) {\n\t\t\treturnValues[i] = createjs.Sound.removeSound(sounds[i].src, basePath);\n\t\t}\n\t\treturn returnValues;\n\t};\n\n\t/**\n\t * Remove all sounds that have been registered with {{#crossLink \"Sound/registerSound\"}}{{/crossLink}} or\n\t * {{#crossLink \"Sound/registerSounds\"}}{{/crossLink}}.\n\t * <br />Note this will stop playback on all active sound instances before deleting them.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     createjs.Sound.removeAllSounds();\n\t *\n\t * @method removeAllSounds\n\t * @static\n\t * @since 0.4.1\n\t */\n\ts.removeAllSounds = function() {\n\t\ts._idHash = {};\n\t\ts._preloadHash = {};\n\t\tSoundChannel.removeAll();\n\t\tif (s.activePlugin) {s.activePlugin.removeAllSounds();}\n\t};\n\n\t/**\n\t * Check if a source has been loaded by internal preloaders. This is necessary to ensure that sounds that are\n\t * not completed preloading will not kick off a new internal preload if they are played.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     var mySound = \"assetPath/asset0.ogg\";\n\t *     if(createjs.Sound.loadComplete(mySound) {\n\t *         createjs.Sound.play(mySound);\n\t *     }\n\t *\n\t * @method loadComplete\n\t * @param {String} src The src or id that is being loaded.\n\t * @return {Boolean} If the src is already loaded.\n\t * @since 0.4.0\n\t * @static\n\t */\n\ts.loadComplete = function (src) {\n\t\tif (!s.isReady()) { return false; }\n\t\tvar details = s._parsePath(src);\n\t\tif (details) {\n\t\t\tsrc = s._getSrcById(details.src).src;\n\t\t} else {\n\t\t\tsrc = s._getSrcById(src).src;\n\t\t}\n\t\tif(s._preloadHash[src] == undefined) {return false;}\n\t\treturn (s._preloadHash[src][0] == true);  // src only loads once, so if it's true for the first it's true for all\n\t};\n\n\t/**\n\t * Parse the path of a sound. Alternate extensions will be attempted in order if the\n\t * current extension is not supported\n\t * @method _parsePath\n\t * @param {String} value The path to an audio source.\n\t * @return {Object} A formatted object that can be registered with the {{#crossLink \"Sound/activePlugin:property\"}}{{/crossLink}}\n\t * and returned to a preloader like <a href=\"http://preloadjs.com\" target=\"_blank\">PreloadJS</a>.\n\t * @protected\n\t * @static\n\t */\n\ts._parsePath = function (value) {\n\t\tif (typeof(value) != \"string\") {value = value.toString();}\n\n\t\tvar match = value.match(s.FILE_PATTERN);\n\t\tif (match == null) {return false;}\n\n\t\tvar name = match[4];\n\t\tvar ext = match[5];\n\t\tvar c = s.capabilities;\n\t\tvar i = 0;\n\t\twhile (!c[ext]) {\n\t\t\text = s.alternateExtensions[i++];\n\t\t\tif (i > s.alternateExtensions.length) { return null;}\t// no extensions are supported\n\t\t}\n\t\tvalue = value.replace(\".\"+match[5], \".\"+ext);\n\n\t\tvar ret = {name:name, src:value, extension:ext};\n\t\treturn ret;\n\t};\n\n\t/**\n\t * Parse the path of a sound based on properties of src matching with supported extensions.\n\t * Returns false if none of the properties are supported\n\t * @method _parseSrc\n\t * @param {Object} value The paths to an audio source, indexed by extension type.\n\t * @return {Object} A formatted object that can be registered with the {{#crossLink \"Sound/activePlugin:property\"}}{{/crossLink}}\n\t * and returned to a preloader like <a href=\"http://preloadjs.com\" target=\"_blank\">PreloadJS</a>.\n\t * @protected\n\t * @static\n\t */\n\ts._parseSrc = function (value) {\n\t\tvar ret = {name:undefined, src:undefined, extension:undefined};\n\t\tvar c = s.capabilities;\n\n\t\tfor (var prop in value) {\n\t\t  if(value.hasOwnProperty(prop) && c[prop]) {\n\t\t\t\tret.src = value[prop];\n\t\t\t\tret.extension = prop;\n\t\t\t\tbreak;\n\t\t  }\n\t\t}\n\t\tif (!ret.src) {return false;}\t// no matches\n\n\t\tvar i = ret.src.lastIndexOf(\"/\");\n\t\tif (i != -1) {\n\t\t\tret.name = ret.src.slice(i+1);\n\t\t} else {\n\t\t\tret.name = ret.src;\n\t\t}\n\n\t\treturn ret;\n\t};\n\n\t/* ---------------\n\t Static API.\n\t --------------- */\n\t/**\n\t * Play a sound and get a {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} to control. If the sound fails to play, a\n\t * AbstractSoundInstance will still be returned, and have a playState of {{#crossLink \"Sound/PLAY_FAILED:property\"}}{{/crossLink}}.\n\t * Note that even on sounds with failed playback, you may still be able to call AbstractSoundInstance {{#crossLink \"AbstractSoundInstance/play\"}}{{/crossLink}},\n\t * since the failure could be due to lack of available channels. If the src does not have a supported extension or\n\t * if there is no available plugin, a default AbstractSoundInstance will be returned which will not play any audio, but will not generate errors.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Sound.on(\"fileload\", handleLoad);\n\t *      createjs.Sound.registerSound(\"myAudioPath/mySound.mp3\", \"myID\", 3);\n\t *      function handleLoad(event) {\n\t *      \tcreatejs.Sound.play(\"myID\");\n\t *      \t// store off AbstractSoundInstance for controlling\n\t *      \tvar myInstance = createjs.Sound.play(\"myID\", {interrupt: createjs.Sound.INTERRUPT_ANY, loop:-1});\n\t *      }\n\t *\n\t * NOTE to create an audio sprite that has not already been registered, both startTime and duration need to be set.\n\t * This is only when creating a new audio sprite, not when playing using the id of an already registered audio sprite.\n\t *\n\t * <b>Parameters Deprecated</b><br />\n\t * The parameters for this method are deprecated in favor of a single parameter that is an Object or {{#crossLink \"PlayPropsConfig\"}}{{/crossLink}}.\n\t *\n\t * @method play\n\t * @param {String} src The src or ID of the audio.\n\t * @param {String | Object} [interrupt=\"none\"|options] <b>This parameter will be renamed playProps in the next release.</b><br />\n\t * This parameter can be an instance of {{#crossLink \"PlayPropsConfig\"}}{{/crossLink}} or an Object that contains any or all optional properties by name,\n\t * including: interrupt, delay, offset, loop, volume, pan, startTime, and duration (see the above code sample).\n\t * <br /><strong>OR</strong><br />\n\t * <b>Deprecated</b> How to interrupt any currently playing instances of audio with the same source,\n\t * if the maximum number of instances of the sound are already playing. Values are defined as <code>INTERRUPT_TYPE</code>\n\t * constants on the Sound class, with the default defined by {{#crossLink \"Sound/defaultInterruptBehavior:property\"}}{{/crossLink}}.\n\t * @param {Number} [delay=0] <b>Deprecated</b> The amount of time to delay the start of audio playback, in milliseconds.\n\t * @param {Number} [offset=0] <b>Deprecated</b> The offset from the start of the audio to begin playback, in milliseconds.\n\t * @param {Number} [loop=0] <b>Deprecated</b> How many times the audio loops when it reaches the end of playback. The default is 0 (no\n\t * loops), and -1 can be used for infinite playback.\n\t * @param {Number} [volume=1] <b>Deprecated</b> The volume of the sound, between 0 and 1. Note that the master volume is applied\n\t * against the individual volume.\n\t * @param {Number} [pan=0] <b>Deprecated</b> The left-right pan of the sound (if supported), between -1 (left) and 1 (right).\n\t * @param {Number} [startTime=null] <b>Deprecated</b> To create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.\n\t * @param {Number} [duration=null] <b>Deprecated</b> To create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.\n\t * @return {AbstractSoundInstance} A {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} that can be controlled after it is created.\n\t * @static\n\t */\n\ts.play = function (src, interrupt, delay, offset, loop, volume, pan, startTime, duration) {\n\t\tvar playProps;\n\t\tif (interrupt instanceof Object || interrupt instanceof createjs.PlayPropsConfig) {\n\t\t\tplayProps = createjs.PlayPropsConfig.create(interrupt);\n\t\t} else {\n\t\t\tplayProps = createjs.PlayPropsConfig.create({interrupt:interrupt, delay:delay, offset:offset, loop:loop, volume:volume, pan:pan, startTime:startTime, duration:duration});\n\t\t}\n\t\tvar instance = s.createInstance(src, playProps.startTime, playProps.duration);\n\t\tvar ok = s._playInstance(instance, playProps);\n\t\tif (!ok) {instance._playFailed();}\n\t\treturn instance;\n\t};\n\n\t/**\n\t * Creates a {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} using the passed in src. If the src does not have a\n\t * supported extension or if there is no available plugin, a default AbstractSoundInstance will be returned that can be\n\t * called safely but does nothing.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var myInstance = null;\n\t *      createjs.Sound.on(\"fileload\", handleLoad);\n\t *      createjs.Sound.registerSound(\"myAudioPath/mySound.mp3\", \"myID\", 3);\n\t *      function handleLoad(event) {\n\t *      \tmyInstance = createjs.Sound.createInstance(\"myID\");\n\t *      \t// alternately we could call the following\n\t *      \tmyInstance = createjs.Sound.createInstance(\"myAudioPath/mySound.mp3\");\n\t *      }\n\t *\n\t * NOTE to create an audio sprite that has not already been registered, both startTime and duration need to be set.\n\t * This is only when creating a new audio sprite, not when playing using the id of an already registered audio sprite.\n\t *\n\t * @method createInstance\n\t * @param {String} src The src or ID of the audio.\n\t * @param {Number} [startTime=null] To create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.\n\t * @param {Number} [duration=null] To create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.\n\t * @return {AbstractSoundInstance} A {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} that can be controlled after it is created.\n\t * Unsupported extensions will return the default AbstractSoundInstance.\n\t * @since 0.4.0\n\t * @static\n\t */\n\ts.createInstance = function (src, startTime, duration) {\n\t\tif (!s.initializeDefaultPlugins()) {return new createjs.DefaultSoundInstance(src, startTime, duration);}\n\n\t\tvar defaultPlayProps = s._defaultPlayPropsHash[src];\t// for audio sprites, which create and store defaults by id\n\t\tsrc = s._getSrcById(src);\n\n\t\tvar details = s._parsePath(src.src);\n\n\t\tvar instance = null;\n\t\tif (details != null && details.src != null) {\n\t\t\tSoundChannel.create(details.src);\n\t\t\tif (startTime == null) {startTime = src.startTime;}\n\t\t\tinstance = s.activePlugin.create(details.src, startTime, duration || src.duration);\n\n\t\t\tdefaultPlayProps = defaultPlayProps || s._defaultPlayPropsHash[details.src];\n\t\t\tif(defaultPlayProps) {\n\t\t\t\tinstance.applyPlayProps(defaultPlayProps);\n\t\t\t}\n\t\t} else {\n\t\t\tinstance = new createjs.DefaultSoundInstance(src, startTime, duration);\n\t\t}\n\n\t\tinstance.uniqueId = s._lastID++;\n\n\t\treturn instance;\n\t};\n\n\t/**\n\t * Stop all audio (global stop). Stopped audio is reset, and not paused. To play audio that has been stopped,\n\t * call AbstractSoundInstance {{#crossLink \"AbstractSoundInstance/play\"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     createjs.Sound.stop();\n\t *\n\t * @method stop\n\t * @static\n\t */\n\ts.stop = function () {\n\t\tvar instances = this._instances;\n\t\tfor (var i = instances.length; i--; ) {\n\t\t\tinstances[i].stop();  // NOTE stop removes instance from this._instances\n\t\t}\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink \"Sound/volume:property\"}}{{/crossLink}} instead.\n\t *\n\t * @method setVolume\n\t * @param {Number} value The master volume value. The acceptable range is 0-1.\n\t * @static\n\t * @deprecated\n\t */\n\ts.setVolume = function (value) {\n\t\tif (Number(value) == null) {return false;}\n\t\tvalue = Math.max(0, Math.min(1, value));\n\t\ts._masterVolume = value;\n\t\tif (!this.activePlugin || !this.activePlugin.setVolume || !this.activePlugin.setVolume(value)) {\n\t\t\tvar instances = this._instances;\n\t\t\tfor (var i = 0, l = instances.length; i < l; i++) {\n\t\t\t\tinstances[i].setMasterVolume(value);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink \"Sound/volume:property\"}}{{/crossLink}} instead.\n\t *\n\t * @method getVolume\n\t * @return {Number} The master volume, in a range of 0-1.\n\t * @static\n\t * @deprecated\n\t */\n\ts.getVolume = function () {\n\t\treturn this._masterVolume;\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink \"Sound/muted:property\"}}{{/crossLink}} instead.\n\t *\n\t * @method setMute\n\t * @param {Boolean} value Whether the audio should be muted or not.\n\t * @return {Boolean} If the mute was set.\n\t * @static\n\t * @since 0.4.0\n\t * @deprecated\n\t */\n\ts.setMute = function (value) {\n\t\tif (value == null) {return false;}\n\n\t\tthis._masterMute = value;\n\t\tif (!this.activePlugin || !this.activePlugin.setMute || !this.activePlugin.setMute(value)) {\n\t\t\tvar instances = this._instances;\n\t\t\tfor (var i = 0, l = instances.length; i < l; i++) {\n\t\t\t\tinstances[i].setMasterMute(value);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink \"Sound/muted:property\"}}{{/crossLink}} instead.\n\t *\n\t * @method getMute\n\t * @return {Boolean} The mute value of Sound.\n\t * @static\n\t * @since 0.4.0\n\t * @deprecated\n\t */\n\ts.getMute = function () {\n\t\treturn this._masterMute;\n\t};\n\n\t/**\n\t * Set the default playback properties for all new SoundInstances of the passed in src or ID.\n\t * See {{#crossLink \"PlayPropsConfig\"}}{{/crossLink}} for available properties.\n\t *\n\t * @method setDefaultPlayProps\n\t * @param {String} src The src or ID used to register the audio.\n\t * @param {Object | PlayPropsConfig} playProps The playback properties you would like to set.\n\t * @since 0.6.1\n\t */\n\ts.setDefaultPlayProps = function(src, playProps) {\n\t\tsrc = s._getSrcById(src);\n\t\ts._defaultPlayPropsHash[s._parsePath(src.src).src] = createjs.PlayPropsConfig.create(playProps);\n\t};\n\n\t/**\n\t * Get the default playback properties for the passed in src or ID.  These properties are applied to all\n\t * new SoundInstances.  Returns null if default does not exist.\n\t *\n\t * @method getDefaultPlayProps\n\t * @param {String} src The src or ID used to register the audio.\n\t * @returns {PlayPropsConfig} returns an existing PlayPropsConfig or null if one does not exist\n\t * @since 0.6.1\n\t */\n\ts.getDefaultPlayProps = function(src) {\n\t\tsrc = s._getSrcById(src);\n\t\treturn s._defaultPlayPropsHash[s._parsePath(src.src).src];\n\t};\n\n\n\t/* ---------------\n\t Internal methods\n\t --------------- */\n\t/**\n\t * Play an instance. This is called by the static API, as well as from plugins. This allows the core class to\n\t * control delays.\n\t * @method _playInstance\n\t * @param {AbstractSoundInstance} instance The {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} to start playing.\n\t * @param {PlayPropsConfig} playProps A PlayPropsConfig object.\n\t * @return {Boolean} If the sound can start playing. Sounds that fail immediately will return false. Sounds that\n\t * have a delay will return true, but may still fail to play.\n\t * @protected\n\t * @static\n\t */\n\ts._playInstance = function (instance, playProps) {\n\t\tvar defaultPlayProps = s._defaultPlayPropsHash[instance.src] || {};\n\t\tif (playProps.interrupt == null) {playProps.interrupt = defaultPlayProps.interrupt || s.defaultInterruptBehavior};\n\t\tif (playProps.delay == null) {playProps.delay = defaultPlayProps.delay || 0;}\n\t\tif (playProps.offset == null) {playProps.offset = instance.getPosition();}\n\t\tif (playProps.loop == null) {playProps.loop = instance.loop;}\n\t\tif (playProps.volume == null) {playProps.volume = instance.volume;}\n\t\tif (playProps.pan == null) {playProps.pan = instance.pan;}\n\n\t\tif (playProps.delay == 0) {\n\t\t\tvar ok = s._beginPlaying(instance, playProps);\n\t\t\tif (!ok) {return false;}\n\t\t} else {\n\t\t\t//Note that we can't pass arguments to proxy OR setTimeout (IE only), so just wrap the function call.\n\t\t\t// OJR WebAudio may want to handle this differently, so it might make sense to move this functionality into the plugins in the future\n\t\t\tvar delayTimeoutId = setTimeout(function () {\n\t\t\t\ts._beginPlaying(instance, playProps);\n\t\t\t}, playProps.delay);\n\t\t\tinstance.delayTimeoutId = delayTimeoutId;\n\t\t}\n\n\t\tthis._instances.push(instance);\n\n\t\treturn true;\n\t};\n\n\t/**\n\t * Begin playback. This is called immediately or after delay by {{#crossLink \"Sound/playInstance\"}}{{/crossLink}}.\n\t * @method _beginPlaying\n\t * @param {AbstractSoundInstance} instance A {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} to begin playback.\n\t * @param {PlayPropsConfig} playProps A PlayPropsConfig object.\n\t * @return {Boolean} If the sound can start playing. If there are no available channels, or the instance fails to\n\t * start, this will return false.\n\t * @protected\n\t * @static\n\t */\n\ts._beginPlaying = function (instance, playProps) {\n\t\tif (!SoundChannel.add(instance, playProps.interrupt)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar result = instance._beginPlaying(playProps);\n\t\tif (!result) {\n\t\t\tvar index = createjs.indexOf(this._instances, instance);\n\t\t\tif (index > -1) {this._instances.splice(index, 1);}\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t * Get the source of a sound via the ID passed in with a register call. If no ID is found the value is returned\n\t * instead.\n\t * @method _getSrcById\n\t * @param {String} value The ID the sound was registered with.\n\t * @return {String} The source of the sound if it has been registered with this ID or the value that was passed in.\n\t * @protected\n\t * @static\n\t */\n\ts._getSrcById = function (value) {\n\t\treturn s._idHash[value] || {src: value};\n\t};\n\n\t/**\n\t * A sound has completed playback, been interrupted, failed, or been stopped. This method removes the instance from\n\t * Sound management. It will be added again, if the sound re-plays. Note that this method is called from the\n\t * instances themselves.\n\t * @method _playFinished\n\t * @param {AbstractSoundInstance} instance The instance that finished playback.\n\t * @protected\n\t * @static\n\t */\n\ts._playFinished = function (instance) {\n\t\tSoundChannel.remove(instance);\n\t\tvar index = createjs.indexOf(this._instances, instance);\n\t\tif (index > -1) {this._instances.splice(index, 1);}\t// OJR this will always be > -1, there is no way for an instance to exist without being added to this._instances\n\t};\n\n\tcreatejs.Sound = Sound;\n\n\t/**\n\t * An internal class that manages the number of active {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} instances for\n\t * each sound type. This method is only used internally by the {{#crossLink \"Sound\"}}{{/crossLink}} class.\n\t *\n\t * The number of sounds is artificially limited by Sound in order to prevent over-saturation of a\n\t * single sound, as well as to stay within hardware limitations, although the latter may disappear with better\n\t * browser support.\n\t *\n\t * When a sound is played, this class ensures that there is an available instance, or interrupts an appropriate\n\t * sound that is already playing.\n\t * #class SoundChannel\n\t * @param {String} src The source of the instances\n\t * @param {Number} [max=1] The number of instances allowed\n\t * @constructor\n\t * @protected\n\t */\n\tfunction SoundChannel(src, max) {\n\t\tthis.init(src, max);\n\t}\n\n\t/* ------------\n\t Static API\n\t ------------ */\n\t/**\n\t * A hash of channel instances indexed by source.\n\t * #property channels\n\t * @type {Object}\n\t * @static\n\t */\n\tSoundChannel.channels = {};\n\n\t/**\n\t * Create a sound channel. Note that if the sound channel already exists, this will fail.\n\t * #method create\n\t * @param {String} src The source for the channel\n\t * @param {Number} max The maximum amount this channel holds. The default is {{#crossLink \"SoundChannel.maxDefault\"}}{{/crossLink}}.\n\t * @return {Boolean} If the channels were created.\n\t * @static\n\t */\n\tSoundChannel.create = function (src, max) {\n\t\tvar channel = SoundChannel.get(src);\n\t\tif (channel == null) {\n\t\t\tSoundChannel.channels[src] = new SoundChannel(src, max);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\t/**\n\t * Delete a sound channel, stop and delete all related instances. Note that if the sound channel does not exist, this will fail.\n\t * #method remove\n\t * @param {String} src The source for the channel\n\t * @return {Boolean} If the channels were deleted.\n\t * @static\n\t */\n\tSoundChannel.removeSrc = function (src) {\n\t\tvar channel = SoundChannel.get(src);\n\t\tif (channel == null) {return false;}\n\t\tchannel._removeAll();\t// this stops and removes all active instances\n\t\tdelete(SoundChannel.channels[src]);\n\t\treturn true;\n\t};\n\t/**\n\t * Delete all sound channels, stop and delete all related instances.\n\t * #method removeAll\n\t * @static\n\t */\n\tSoundChannel.removeAll = function () {\n\t\tfor(var channel in SoundChannel.channels) {\n\t\t\tSoundChannel.channels[channel]._removeAll();\t// this stops and removes all active instances\n\t\t}\n\t\tSoundChannel.channels = {};\n\t};\n\t/**\n\t * Add an instance to a sound channel.\n\t * #method add\n\t * @param {AbstractSoundInstance} instance The instance to add to the channel\n\t * @param {String} interrupt The interrupt value to use. Please see the {{#crossLink \"Sound/play\"}}{{/crossLink}}\n\t * for details on interrupt modes.\n\t * @return {Boolean} The success of the method call. If the channel is full, it will return false.\n\t * @static\n\t */\n\tSoundChannel.add = function (instance, interrupt) {\n\t\tvar channel = SoundChannel.get(instance.src);\n\t\tif (channel == null) {return false;}\n\t\treturn channel._add(instance, interrupt);\n\t};\n\t/**\n\t * Remove an instance from the channel.\n\t * #method remove\n\t * @param {AbstractSoundInstance} instance The instance to remove from the channel\n\t * @return The success of the method call. If there is no channel, it will return false.\n\t * @static\n\t */\n\tSoundChannel.remove = function (instance) {\n\t\tvar channel = SoundChannel.get(instance.src);\n\t\tif (channel == null) {return false;}\n\t\tchannel._remove(instance);\n\t\treturn true;\n\t};\n\t/**\n\t * Get the maximum number of sounds you can have in a channel.\n\t * #method maxPerChannel\n\t * @return {Number} The maximum number of sounds you can have in a channel.\n\t */\n\tSoundChannel.maxPerChannel = function () {\n\t\treturn p.maxDefault;\n\t};\n\t/**\n\t * Get a channel instance by its src.\n\t * #method get\n\t * @param {String} src The src to use to look up the channel\n\t * @static\n\t */\n\tSoundChannel.get = function (src) {\n\t\treturn SoundChannel.channels[src];\n\t};\n\n\tvar p = SoundChannel.prototype;\n\tp.constructor = SoundChannel;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n\t/**\n\t * The source of the channel.\n\t * #property src\n\t * @type {String}\n\t */\n\tp.src = null;\n\n\t/**\n\t * The maximum number of instances in this channel.  -1 indicates no limit\n\t * #property max\n\t * @type {Number}\n\t */\n\tp.max = null;\n\n\t/**\n\t * The default value to set for max, if it isn't passed in.  Also used if -1 is passed.\n\t * #property maxDefault\n\t * @type {Number}\n\t * @default 100\n\t * @since 0.4.0\n\t */\n\tp.maxDefault = 100;\n\n\t/**\n\t * The current number of active instances.\n\t * #property length\n\t * @type {Number}\n\t */\n\tp.length = 0;\n\n\t/**\n\t * Initialize the channel.\n\t * #method init\n\t * @param {String} src The source of the channel\n\t * @param {Number} max The maximum number of instances in the channel\n\t * @protected\n\t */\n\tp.init = function (src, max) {\n\t\tthis.src = src;\n\t\tthis.max = max || this.maxDefault;\n\t\tif (this.max == -1) {this.max = this.maxDefault;}\n\t\tthis._instances = [];\n\t};\n\n\t/**\n\t * Get an instance by index.\n\t * #method get\n\t * @param {Number} index The index to return.\n\t * @return {AbstractSoundInstance} The AbstractSoundInstance at a specific instance.\n\t */\n\tp._get = function (index) {\n\t\treturn this._instances[index];\n\t};\n\n\t/**\n\t * Add a new instance to the channel.\n\t * #method add\n\t * @param {AbstractSoundInstance} instance The instance to add.\n\t * @return {Boolean} The success of the method call. If the channel is full, it will return false.\n\t */\n\tp._add = function (instance, interrupt) {\n\t\tif (!this._getSlot(interrupt, instance)) {return false;}\n\t\tthis._instances.push(instance);\n\t\tthis.length++;\n\t\treturn true;\n\t};\n\n\t/**\n\t * Remove an instance from the channel, either when it has finished playing, or it has been interrupted.\n\t * #method remove\n\t * @param {AbstractSoundInstance} instance The instance to remove\n\t * @return {Boolean} The success of the remove call. If the instance is not found in this channel, it will\n\t * return false.\n\t */\n\tp._remove = function (instance) {\n\t\tvar index = createjs.indexOf(this._instances, instance);\n\t\tif (index == -1) {return false;}\n\t\tthis._instances.splice(index, 1);\n\t\tthis.length--;\n\t\treturn true;\n\t};\n\n\t/**\n\t * Stop playback and remove all instances from the channel.  Usually in response to a delete call.\n\t * #method removeAll\n\t */\n\tp._removeAll = function () {\n\t\t// Note that stop() removes the item from the list\n\t\tfor (var i=this.length-1; i>=0; i--) {\n\t\t\tthis._instances[i].stop();\n\t\t}\n\t};\n\n\t/**\n\t * Get an available slot depending on interrupt value and if slots are available.\n\t * #method getSlot\n\t * @param {String} interrupt The interrupt value to use.\n\t * @param {AbstractSoundInstance} instance The sound instance that will go in the channel if successful.\n\t * @return {Boolean} Determines if there is an available slot. Depending on the interrupt mode, if there are no slots,\n\t * an existing AbstractSoundInstance may be interrupted. If there are no slots, this method returns false.\n\t */\n\tp._getSlot = function (interrupt, instance) {\n\t\tvar target, replacement;\n\n\t\tif (interrupt != Sound.INTERRUPT_NONE) {\n\t\t\t// First replacement candidate\n\t\t\treplacement = this._get(0);\n\t\t\tif (replacement == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0, l = this.max; i < l; i++) {\n\t\t\ttarget = this._get(i);\n\n\t\t\t// Available Space\n\t\t\tif (target == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Audio is complete or not playing\n\t\t\tif (target.playState == Sound.PLAY_FINISHED ||\n\t\t\t\ttarget.playState == Sound.PLAY_INTERRUPTED ||\n\t\t\t\ttarget.playState == Sound.PLAY_FAILED) {\n\t\t\t\treplacement = target;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (interrupt == Sound.INTERRUPT_NONE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Audio is a better candidate than the current target, according to playhead\n\t\t\tif ((interrupt == Sound.INTERRUPT_EARLY && target.getPosition() < replacement.getPosition()) ||\n\t\t\t\t(interrupt == Sound.INTERRUPT_LATE && target.getPosition() > replacement.getPosition())) {\n\t\t\t\t\treplacement = target;\n\t\t\t}\n\t\t}\n\n\t\tif (replacement != null) {\n\t\t\treplacement._interrupt();\n\t\t\tthis._remove(replacement);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[Sound SoundChannel]\";\n\t};\n\t// do not add SoundChannel to namespace\n\n}());\n\n//##############################################################################\n// AbstractSoundInstance.js\n//##############################################################################\n\n/**\n * A AbstractSoundInstance is created when any calls to the Sound API method {{#crossLink \"Sound/play\"}}{{/crossLink}} or\n * {{#crossLink \"Sound/createInstance\"}}{{/crossLink}} are made. The AbstractSoundInstance is returned by the active plugin\n * for control by the user.\n *\n * <h4>Example</h4>\n *\n *      var myInstance = createjs.Sound.play(\"myAssetPath/mySrcFile.mp3\");\n *\n * A number of additional parameters provide a quick way to determine how a sound is played. Please see the Sound\n * API method {{#crossLink \"Sound/play\"}}{{/crossLink}} for a list of arguments.\n *\n * Once a AbstractSoundInstance is created, a reference can be stored that can be used to control the audio directly through\n * the AbstractSoundInstance. If the reference is not stored, the AbstractSoundInstance will play out its audio (and any loops), and\n * is then de-referenced from the {{#crossLink \"Sound\"}}{{/crossLink}} class so that it can be cleaned up. If audio\n * playback has completed, a simple call to the {{#crossLink \"AbstractSoundInstance/play\"}}{{/crossLink}} instance method\n * will rebuild the references the Sound class need to control it.\n *\n *      var myInstance = createjs.Sound.play(\"myAssetPath/mySrcFile.mp3\", {loop:2});\n *      myInstance.on(\"loop\", handleLoop);\n *      function handleLoop(event) {\n *          myInstance.volume = myInstance.volume * 0.5;\n *      }\n *\n * Events are dispatched from the instance to notify when the sound has completed, looped, or when playback fails\n *\n *      var myInstance = createjs.Sound.play(\"myAssetPath/mySrcFile.mp3\");\n *      myInstance.on(\"complete\", handleComplete);\n *      myInstance.on(\"loop\", handleLoop);\n *      myInstance.on(\"failed\", handleFailed);\n *\n *\n * @class AbstractSoundInstance\n * @param {String} src The path to and file name of the sound.\n * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\n * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\n * @param {Object} playbackResource Any resource needed by plugin to support audio playback.\n * @extends EventDispatcher\n * @constructor\n */\n\n(function () {\n\t\"use strict\";\n\n\n// Constructor:\n\tvar AbstractSoundInstance = function (src, startTime, duration, playbackResource) {\n\t\tthis.EventDispatcher_constructor();\n\n\n\t// public properties:\n\t\t/**\n\t\t * The source of the sound.\n\t\t * @property src\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.src = src;\n\n\t\t/**\n\t\t * The unique ID of the instance. This is set by {{#crossLink \"Sound\"}}{{/crossLink}}.\n\t\t * @property uniqueId\n\t\t * @type {String} | Number\n\t\t * @default -1\n\t\t */\n\t\tthis.uniqueId = -1;\n\n\t\t/**\n\t\t * The play state of the sound. Play states are defined as constants on {{#crossLink \"Sound\"}}{{/crossLink}}.\n\t\t * @property playState\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.playState = null;\n\n\t\t/**\n\t\t * A Timeout created by {{#crossLink \"Sound\"}}{{/crossLink}} when this AbstractSoundInstance is played with a delay.\n\t\t * This allows AbstractSoundInstance to remove the delay if stop, pause, or cleanup are called before playback begins.\n\t\t * @property delayTimeoutId\n\t\t * @type {timeoutVariable}\n\t\t * @default null\n\t\t * @protected\n\t\t * @since 0.4.0\n\t\t */\n\t\tthis.delayTimeoutId = null;\n\t\t// TODO consider moving delay into AbstractSoundInstance so it can be handled by plugins\n\n\n\t// private properties\n\t// Getter / Setter Properties\n\t\t// OJR TODO find original reason that we didn't use defined functions.  I think it was performance related\n\t\t/**\n\t\t * The volume of the sound, between 0 and 1.\n\t\t *\n\t\t * The actual output volume of a sound can be calculated using:\n\t\t * <code>myInstance.volume * createjs.Sound.getVolume();</code>\n\t\t *\n\t\t * @property volume\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis._volume =  1;\n\t\tObject.defineProperty(this, \"volume\", {\n\t\t\tget: this.getVolume,\n\t\t\tset: this.setVolume\n\t\t});\n\n\t\t/**\n\t\t * The pan of the sound, between -1 (left) and 1 (right). Note that pan is not supported by HTML Audio.\n\t\t *\n\t\t * <br />Note in WebAudioPlugin this only gives us the \"x\" value of what is actually 3D audio.\n\t\t *\n\t\t * @property pan\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis._pan =  0;\n\t\tObject.defineProperty(this, \"pan\", {\n\t\t\tget: this.getPan,\n\t\t\tset: this.setPan\n\t\t});\n\n\t\t/**\n\t\t * Audio sprite property used to determine the starting offset.\n\t\t * @property startTime\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @since 0.6.1\n\t\t */\n\t\tthis._startTime = Math.max(0, startTime || 0);\n\t\tObject.defineProperty(this, \"startTime\", {\n\t\t\tget: this.getStartTime,\n\t\t\tset: this.setStartTime\n\t\t});\n\n\t\t/**\n\t\t * Sets or gets the length of the audio clip, value is in milliseconds.\n\t\t *\n\t\t * @property duration\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._duration = Math.max(0, duration || 0);\n\t\tObject.defineProperty(this, \"duration\", {\n\t\t\tget: this.getDuration,\n\t\t\tset: this.setDuration\n\t\t});\n\n\t\t/**\n\t\t * Object that holds plugin specific resource need for audio playback.\n\t\t * This is set internally by the plugin.  For example, WebAudioPlugin will set an array buffer,\n\t\t * HTMLAudioPlugin will set a tag, FlashAudioPlugin will set a flash reference.\n\t\t *\n\t\t * @property playbackResource\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis._playbackResource = null;\n\t\tObject.defineProperty(this, \"playbackResource\", {\n\t\t\tget: this.getPlaybackResource,\n\t\t\tset: this.setPlaybackResource\n\t\t});\n\t\tif(playbackResource !== false && playbackResource !== true) { this.setPlaybackResource(playbackResource); }\n\n\t\t/**\n\t\t * The position of the playhead in milliseconds. This can be set while a sound is playing, paused, or stopped.\n\t\t *\n\t\t * @property position\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._position = 0;\n\t\tObject.defineProperty(this, \"position\", {\n\t\t\tget: this.getPosition,\n\t\t\tset: this.setPosition\n\t\t});\n\n\t\t/**\n\t\t * The number of play loops remaining. Negative values will loop infinitely.\n\t\t *\n\t\t * @property loop\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @public\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._loop = 0;\n\t\tObject.defineProperty(this, \"loop\", {\n\t\t\tget: this.getLoop,\n\t\t\tset: this.setLoop\n\t\t});\n\n\t\t/**\n\t\t * Mutes or unmutes the current audio instance.\n\t\t *\n\t\t * @property muted\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._muted = false;\n\t\tObject.defineProperty(this, \"muted\", {\n\t\t\tget: this.getMuted,\n\t\t\tset: this.setMuted\n\t\t});\n\n\t\t/**\n\t\t * Pauses or resumes the current audio instance.\n\t\t *\n\t\t * @property paused\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis._paused = false;\n\t\tObject.defineProperty(this, \"paused\", {\n\t\t\tget: this.getPaused,\n\t\t\tset: this.setPaused\n\t\t});\n\n\n\t// Events\n\t\t/**\n\t\t * The event that is fired when playback has started successfully.\n\t\t * @event succeeded\n\t\t * @param {Object} target The object that dispatched the event.\n\t\t * @param {String} type The event type.\n\t\t * @since 0.4.0\n\t\t */\n\n\t\t/**\n\t\t * The event that is fired when playback is interrupted. This happens when another sound with the same\n\t\t * src property is played using an interrupt value that causes this instance to stop playing.\n\t\t * @event interrupted\n\t\t * @param {Object} target The object that dispatched the event.\n\t\t * @param {String} type The event type.\n\t\t * @since 0.4.0\n\t\t */\n\n\t\t/**\n\t\t * The event that is fired when playback has failed. This happens when there are too many channels with the same\n\t\t * src property already playing (and the interrupt value doesn't cause an interrupt of another instance), or\n\t\t * the sound could not be played, perhaps due to a 404 error.\n\t\t * @event failed\n\t\t * @param {Object} target The object that dispatched the event.\n\t\t * @param {String} type The event type.\n\t\t * @since 0.4.0\n\t\t */\n\n\t\t/**\n\t\t * The event that is fired when a sound has completed playing but has loops remaining.\n\t\t * @event loop\n\t\t * @param {Object} target The object that dispatched the event.\n\t\t * @param {String} type The event type.\n\t\t * @since 0.4.0\n\t\t */\n\n\t\t/**\n\t\t * The event that is fired when playback completes. This means that the sound has finished playing in its\n\t\t * entirety, including its loop iterations.\n\t\t * @event complete\n\t\t * @param {Object} target The object that dispatched the event.\n\t\t * @param {String} type The event type.\n\t\t * @since 0.4.0\n\t\t */\n\t};\n\n\tvar p = createjs.extend(AbstractSoundInstance, createjs.EventDispatcher);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// Public Methods:\n\t/**\n\t * Play an instance. This method is intended to be called on SoundInstances that already exist (created\n\t * with the Sound API {{#crossLink \"Sound/createInstance\"}}{{/crossLink}} or {{#crossLink \"Sound/play\"}}{{/crossLink}}).\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var myInstance = createjs.Sound.createInstance(mySrc);\n\t *      myInstance.play({interrupt:createjs.Sound.INTERRUPT_ANY, loop:2, pan:0.5});\n\t *\n\t * Note that if this sound is already playing, this call will still set the passed in parameters.\n\n\t * <b>Parameters Deprecated</b><br />\n\t * The parameters for this method are deprecated in favor of a single parameter that is an Object or {{#crossLink \"PlayPropsConfig\"}}{{/crossLink}}.\n\t *\n\t * @method play\n\t * @param {String | Object} [interrupt=\"none\"|options] <b>This parameter will be renamed playProps in the next release.</b><br />\n\t * This parameter can be an instance of {{#crossLink \"PlayPropsConfig\"}}{{/crossLink}} or an Object that contains any or all optional properties by name,\n\t * including: interrupt, delay, offset, loop, volume, pan, startTime, and duration (see the above code sample).\n\t * <br /><strong>OR</strong><br />\n\t * <b>Deprecated</b> How to interrupt any currently playing instances of audio with the same source,\n\t * if the maximum number of instances of the sound are already playing. Values are defined as <code>INTERRUPT_TYPE</code>\n\t * constants on the Sound class, with the default defined by {{#crossLink \"Sound/defaultInterruptBehavior:property\"}}{{/crossLink}}.\n\t * @param {Number} [delay=0] <b>Deprecated</b> The amount of time to delay the start of audio playback, in milliseconds.\n\t * @param {Number} [offset=0] <b>Deprecated</b> The offset from the start of the audio to begin playback, in milliseconds.\n\t * @param {Number} [loop=0] <b>Deprecated</b> How many times the audio loops when it reaches the end of playback. The default is 0 (no\n\t * loops), and -1 can be used for infinite playback.\n\t * @param {Number} [volume=1] <b>Deprecated</b> The volume of the sound, between 0 and 1. Note that the master volume is applied\n\t * against the individual volume.\n\t * @param {Number} [pan=0] <b>Deprecated</b> The left-right pan of the sound (if supported), between -1 (left) and 1 (right).\n\t * Note that pan is not supported for HTML Audio.\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t */\n\tp.play = function (interrupt, delay, offset, loop, volume, pan) {\n\t\tvar playProps;\n\t\tif (interrupt instanceof Object || interrupt instanceof createjs.PlayPropsConfig) {\n\t\t\tplayProps = createjs.PlayPropsConfig.create(interrupt);\n\t\t} else {\n\t\t\tplayProps = createjs.PlayPropsConfig.create({interrupt:interrupt, delay:delay, offset:offset, loop:loop, volume:volume, pan:pan});\n\t\t}\n\n\t\tif (this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis.applyPlayProps(playProps);\n\t\t\tif (this._paused) {\tthis.setPaused(false); }\n\t\t\treturn;\n\t\t}\n\t\tthis._cleanUp();\n\t\tcreatejs.Sound._playInstance(this, playProps);\t// make this an event dispatch??\n\t\treturn this;\n\t};\n\n\t/**\n\t * Stop playback of the instance. Stopped sounds will reset their position to 0, and calls to {{#crossLink \"AbstractSoundInstance/resume\"}}{{/crossLink}}\n\t * will fail. To start playback again, call {{#crossLink \"AbstractSoundInstance/play\"}}{{/crossLink}}.\n     *\n     * If you don't want to lose your position use yourSoundInstance.paused = true instead. {{#crossLink \"AbstractSoundInstance/paused\"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     myInstance.stop();\n\t *\n\t * @method stop\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t */\n\tp.stop = function () {\n\t\tthis._position = 0;\n\t\tthis._paused = false;\n\t\tthis._handleStop();\n\t\tthis._cleanUp();\n\t\tthis.playState = createjs.Sound.PLAY_FINISHED;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Remove all external references and resources from AbstractSoundInstance.  Note this is irreversible and AbstractSoundInstance will no longer work\n\t * @method destroy\n\t * @since 0.6.0\n\t */\n\tp.destroy = function() {\n\t\tthis._cleanUp();\n\t\tthis.src = null;\n\t\tthis.playbackResource = null;\n\n\t\tthis.removeAllEventListeners();\n\t};\n\n\t/**\n\t * Takes an PlayPropsConfig or Object with the same properties and sets them on this instance.\n\t * @method applyPlayProps\n\t * @param {PlayPropsConfig | Object} playProps A PlayPropsConfig or object containing the same properties.\n\t * @since 0.6.1\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t */\n\tp.applyPlayProps = function(playProps) {\n\t\tif (playProps.offset != null) { this.setPosition(playProps.offset) }\n\t\tif (playProps.loop != null) { this.setLoop(playProps.loop); }\n\t\tif (playProps.volume != null) { this.setVolume(playProps.volume); }\n\t\tif (playProps.pan != null) { this.setPan(playProps.pan); }\n\t\tif (playProps.startTime != null) {\n\t\t\tthis.setStartTime(playProps.startTime);\n\t\t\tthis.setDuration(playProps.duration);\n\t\t}\n\t\treturn this;\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[AbstractSoundInstance]\";\n\t};\n\n// get/set methods that allow support for IE8\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/paused:property\"}}{{/crossLink}} directly as a property,\n\t *\n\t * @deprecated\n\t * @method getPaused\n\t * @returns {boolean} If the instance is currently paused\n\t * @since 0.6.0\n\t */\n\tp.getPaused = function() {\n\t\treturn this._paused;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/paused:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setPaused\n\t * @param {boolean} value\n\t * @since 0.6.0\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t */\n\tp.setPaused = function (value) {\n\t\tif ((value !== true && value !== false) || this._paused == value) {return;}\n\t\tif (value == true && this.playState != createjs.Sound.PLAY_SUCCEEDED) {return;}\n\t\tthis._paused = value;\n\t\tif(value) {\n\t\t\tthis._pause();\n\t\t} else {\n\t\t\tthis._resume();\n\t\t}\n\t\tclearTimeout(this.delayTimeoutId);\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/volume:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setVolume\n\t * @param {Number} value The volume to set, between 0 and 1.\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t */\n\tp.setVolume = function (value) {\n\t\tif (value == this._volume) { return this; }\n\t\tthis._volume = Math.max(0, Math.min(1, value));\n\t\tif (!this._muted) {\n\t\t\tthis._updateVolume();\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/volume:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getVolume\n\t * @return {Number} The current volume of the sound instance.\n\t */\n\tp.getVolume = function () {\n\t\treturn this._volume;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/muted:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setMuted\n\t * @param {Boolean} value If the sound should be muted.\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t * @since 0.6.0\n\t */\n\tp.setMuted = function (value) {\n\t\tif (value !== true && value !== false) {return;}\n\t\tthis._muted = value;\n\t\tthis._updateVolume();\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/muted:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getMuted\n\t * @return {Boolean} If the sound is muted.\n\t * @since 0.6.0\n\t */\n\tp.getMuted = function () {\n\t\treturn this._muted;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/pan:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setPan\n\t * @param {Number} value The pan value, between -1 (left) and 1 (right).\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n\t */\n\tp.setPan = function (value) {\n\t\tif(value == this._pan) { return this; }\n\t\tthis._pan = Math.max(-1, Math.min(1, value));\n\t\tthis._updatePan();\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/pan:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getPan\n\t * @return {Number} The value of the pan, between -1 (left) and 1 (right).\n\t */\n\tp.getPan = function () {\n\t\treturn this._pan;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/position:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getPosition\n\t * @return {Number} The position of the playhead in the sound, in milliseconds.\n\t */\n\tp.getPosition = function () {\n\t\tif (!this._paused && this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis._position = this._calculateCurrentPosition();\n\t\t}\n\t\treturn this._position;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/position:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setPosition\n\t * @param {Number} value The position to place the playhead, in milliseconds.\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n\t */\n\tp.setPosition = function (value) {\n\t\tthis._position = Math.max(0, value);\n\t\tif (this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis._updatePosition();\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/startTime:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getStartTime\n\t * @return {Number} The startTime of the sound instance in milliseconds.\n\t */\n\tp.getStartTime = function () {\n\t\treturn this._startTime;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/startTime:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setStartTime\n\t * @param {number} value The new startTime time in milli seconds.\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n\t */\n\tp.setStartTime = function (value) {\n\t\tif (value == this._startTime) { return this; }\n\t\tthis._startTime = Math.max(0, value || 0);\n\t\tthis._updateStartTime();\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/duration:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getDuration\n\t * @return {Number} The duration of the sound instance in milliseconds.\n\t */\n\tp.getDuration = function () {\n\t\treturn this._duration;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/duration:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setDuration\n\t * @param {number} value The new duration time in milli seconds.\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n\t * @since 0.6.0\n\t */\n\tp.setDuration = function (value) {\n\t\tif (value == this._duration) { return this; }\n\t\tthis._duration = Math.max(0, value || 0);\n\t\tthis._updateDuration();\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/playbackResource:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setPlayback\n\t * @param {Object} value The new playback resource.\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n\t * @since 0.6.0\n\t **/\n\tp.setPlaybackResource = function (value) {\n\t\tthis._playbackResource = value;\n\t\tif (this._duration == 0) { this._setDurationFromSource(); }\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/playbackResource:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setPlayback\n\t * @param {Object} value The new playback resource.\n\t * @return {Object} playback resource used for playing audio\n\t * @since 0.6.0\n\t **/\n\tp.getPlaybackResource = function () {\n\t\treturn this._playbackResource;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/loop:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getLoop\n\t * @return {number}\n\t * @since 0.6.0\n\t **/\n\tp.getLoop = function () {\n\t\treturn this._loop;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/loop:property\"}}{{/crossLink}} directly as a property,\n\t *\n\t * @deprecated\n\t * @method setLoop\n\t * @param {number} value The number of times to loop after play.\n\t * @since 0.6.0\n\t */\n\tp.setLoop = function (value) {\n\t\tif(this._playbackResource != null) {\n\t\t\t// remove looping\n\t\t\tif (this._loop != 0 && value == 0) {\n\t\t\t\tthis._removeLooping(value);\n\t\t\t}\n\t\t\t// add looping\n\t\t\telse if (this._loop == 0 && value != 0) {\n\t\t\t\tthis._addLooping(value);\n\t\t\t}\n\t\t}\n\t\tthis._loop = value;\n\t};\n\n\n// Private Methods:\n\t/**\n\t * A helper method that dispatches all events for AbstractSoundInstance.\n\t * @method _sendEvent\n\t * @param {String} type The event type\n\t * @protected\n\t */\n\tp._sendEvent = function (type) {\n\t\tvar event = new createjs.Event(type);\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Clean up the instance. Remove references and clean up any additional properties such as timers.\n\t * @method _cleanUp\n\t * @protected\n\t */\n\tp._cleanUp = function () {\n\t\tclearTimeout(this.delayTimeoutId); // clear timeout that plays delayed sound\n\t\tthis._handleCleanUp();\n\t\tthis._paused = false;\n\n\t\tcreatejs.Sound._playFinished(this);\t// TODO change to an event\n\t};\n\n\t/**\n\t * The sound has been interrupted.\n\t * @method _interrupt\n\t * @protected\n\t */\n\tp._interrupt = function () {\n\t\tthis._cleanUp();\n\t\tthis.playState = createjs.Sound.PLAY_INTERRUPTED;\n\t\tthis._sendEvent(\"interrupted\");\n\t};\n\n\t/**\n\t * Called by the Sound class when the audio is ready to play (delay has completed). Starts sound playing if the\n\t * src is loaded, otherwise playback will fail.\n\t * @method _beginPlaying\n\t * @param {PlayPropsConfig} playProps A PlayPropsConfig object.\n\t * @return {Boolean} If playback succeeded.\n\t * @protected\n\t */\n\t// OJR FlashAudioSoundInstance overwrites\n\tp._beginPlaying = function (playProps) {\n\t\tthis.setPosition(playProps.offset);\n\t\tthis.setLoop(playProps.loop);\n\t\tthis.setVolume(playProps.volume);\n\t\tthis.setPan(playProps.pan);\n\t\tif (playProps.startTime != null) {\n\t\t\tthis.setStartTime(playProps.startTime);\n\t\t\tthis.setDuration(playProps.duration);\n\t\t}\n\n\t\tif (this._playbackResource != null && this._position < this._duration) {\n\t\t\tthis._paused = false;\n\t\t\tthis._handleSoundReady();\n\t\t\tthis.playState = createjs.Sound.PLAY_SUCCEEDED;\n\t\t\tthis._sendEvent(\"succeeded\");\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis._playFailed();\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Play has failed, which can happen for a variety of reasons.\n\t * Cleans up instance and dispatches failed event\n\t * @method _playFailed\n\t * @private\n\t */\n\tp._playFailed = function () {\n\t\tthis._cleanUp();\n\t\tthis.playState = createjs.Sound.PLAY_FAILED;\n\t\tthis._sendEvent(\"failed\");\n\t};\n\n\t/**\n\t * Audio has finished playing. Manually loop it if required.\n\t * @method _handleSoundComplete\n\t * @param event\n\t * @protected\n\t */\n\tp._handleSoundComplete = function (event) {\n\t\tthis._position = 0;  // have to set this as it can be set by pause during playback\n\n\t\tif (this._loop != 0) {\n\t\t\tthis._loop--;  // NOTE this introduces a theoretical limit on loops = float max size x 2 - 1\n\t\t\tthis._handleLoop();\n\t\t\tthis._sendEvent(\"loop\");\n\t\t\treturn;\n\t\t}\n\n\t\tthis._cleanUp();\n\t\tthis.playState = createjs.Sound.PLAY_FINISHED;\n\t\tthis._sendEvent(\"complete\");\n\t};\n\n// Plugin specific code\n\t/**\n\t * Handles starting playback when the sound is ready for playing.\n\t * @method _handleSoundReady\n\t * @protected\n \t */\n\tp._handleSoundReady = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function used to update the volume based on the instance volume, master volume, instance mute value,\n\t * and master mute value.\n\t * @method _updateVolume\n\t * @protected\n\t */\n\tp._updateVolume = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function used to update the pan\n\t * @method _updatePan\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._updatePan = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function used to update the startTime of the audio.\n\t * @method _updateStartTime\n\t * @protected\n\t * @since 0.6.1\n\t */\n\tp._updateStartTime = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function used to update the duration of the audio.\n\t * @method _updateDuration\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._updateDuration = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function used to get the duration of the audio from the source we'll be playing.\n\t * @method _updateDuration\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._setDurationFromSource = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function that calculates the current position of the playhead and sets this._position to that value\n\t * @method _calculateCurrentPosition\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._calculateCurrentPosition = function () {\n\t\t// plugin specific code that sets this.position\n\t};\n\n\t/**\n\t * Internal function used to update the position of the playhead.\n\t * @method _updatePosition\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._updatePosition = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when looping is removed during playback.\n\t * @method _removeLooping\n\t * @param {number} value The number of times to loop after play.\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._removeLooping = function (value) {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when looping is added during playback.\n\t * @method _addLooping\n\t * @param {number} value The number of times to loop after play.\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._addLooping = function (value) {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when pausing playback\n\t * @method _pause\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._pause = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when resuming playback\n\t * @method _resume\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._resume = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when stopping playback\n\t * @method _handleStop\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._handleStop = function() {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when AbstractSoundInstance is being cleaned up\n\t * @method _handleCleanUp\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._handleCleanUp = function() {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when AbstractSoundInstance has played to end and is looping\n\t * @method _handleLoop\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._handleLoop = function () {\n\t\t// plugin specific code\n\t};\n\n\tcreatejs.AbstractSoundInstance = createjs.promote(AbstractSoundInstance, \"EventDispatcher\");\n\tcreatejs.DefaultSoundInstance = createjs.AbstractSoundInstance;\t// used when no plugin is supported\n}());\n\n//##############################################################################\n// AbstractPlugin.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\n// constructor:\n \t/**\n\t * A default plugin class used as a base for all other plugins.\n\t * @class AbstractPlugin\n\t * @constructor\n\t * @since 0.6.0\n\t */\n\n\tvar AbstractPlugin = function () {\n\t// private properties:\n\t\t/**\n\t\t * The capabilities of the plugin.\n\t\t * method and is used internally.\n\t\t * @property _capabilities\n\t\t * @type {Object}\n\t\t * @default null\n\t\t * @protected\n\t\t * @static\n\t\t */\n\t\tthis._capabilities = null;\n\n\t\t/**\n\t\t * Object hash indexed by the source URI of all created loaders, used to properly destroy them if sources are removed.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._loaders = {};\n\n\t\t/**\n\t\t * Object hash indexed by the source URI of each file to indicate if an audio source has begun loading,\n\t\t * is currently loading, or has completed loading.  Can be used to store non boolean data after loading\n\t\t * is complete (for example arrayBuffers for web audio).\n\t\t * @property _audioSources\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._audioSources = {};\n\n\t\t/**\n\t\t * Object hash indexed by the source URI of all created SoundInstances, updates the playbackResource if it loads after they are created,\n\t\t * and properly destroy them if sources are removed\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._soundInstances = {};\n\n\t\t/**\n\t\t * The internal master volume value of the plugin.\n\t\t * @property _volume\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t * @protected\n\t\t */\n\t\tthis._volume = 1;\n\n\t\t/**\n\t\t * A reference to a loader class used by a plugin that must be set.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._loaderClass;\n\n\t\t/**\n\t\t * A reference to an AbstractSoundInstance class used by a plugin that must be set.\n\t\t * @type {Object}\n\t\t * @protected;\n\t\t */\n\t\tthis._soundInstanceClass;\n\t};\n\tvar p = AbstractPlugin.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// Static Properties:\n// NOTE THESE PROPERTIES NEED TO BE ADDED TO EACH PLUGIN\n\t/**\n\t * The capabilities of the plugin. This is generated via the _generateCapabilities method and is used internally.\n\t * @property _capabilities\n\t * @type {Object}\n\t * @default null\n\t * @protected\n\t * @static\n\t */\n\tAbstractPlugin._capabilities = null;\n\n\t/**\n\t * Determine if the plugin can be used in the current browser/OS.\n\t * @method isSupported\n\t * @return {Boolean} If the plugin can be initialized.\n\t * @static\n\t */\n\tAbstractPlugin.isSupported = function () {\n\t\treturn true;\n\t};\n\n\n// public methods:\n\t/**\n\t * Pre-register a sound for preloading and setup. This is called by {{#crossLink \"Sound\"}}{{/crossLink}}.\n\t * Note all plugins provide a <code>Loader</code> instance, which <a href=\"http://preloadjs.com\" target=\"_blank\">PreloadJS</a>\n\t * can use to assist with preloading.\n\t * @method register\n\t * @param {String} loadItem An Object containing the source of the audio\n\t * Note that not every plugin will manage this value.\n\t * @return {Object} A result object, containing a \"tag\" for preloading purposes.\n\t */\n\tp.register = function (loadItem) {\n\t\tvar loader = this._loaders[loadItem.src];\n\t\tif(loader && !loader.canceled) {return this._loaders[loadItem.src];}\t// already loading/loaded this, so don't load twice\n\t\t// OJR potential issue that we won't be firing loaded event, might need to trigger if this is already loaded?\n\t\tthis._audioSources[loadItem.src] = true;\n\t\tthis._soundInstances[loadItem.src] = [];\n\t\tloader = new this._loaderClass(loadItem);\n\t\tloader.on(\"complete\", this._handlePreloadComplete, this);\n\t\tthis._loaders[loadItem.src] = loader;\n\t\treturn loader;\n\t};\n\n\t// note sound calls register before calling preload\n\t/**\n\t * Internally preload a sound.\n\t * @method preload\n\t * @param {Loader} loader The sound URI to load.\n\t */\n\tp.preload = function (loader) {\n\t\tloader.on(\"error\", this._handlePreloadError, this);\n\t\tloader.load();\n\t};\n\n\t/**\n\t * Checks if preloading has started for a specific source. If the source is found, we can assume it is loading,\n\t * or has already finished loading.\n\t * @method isPreloadStarted\n\t * @param {String} src The sound URI to check.\n\t * @return {Boolean}\n\t */\n\tp.isPreloadStarted = function (src) {\n\t\treturn (this._audioSources[src] != null);\n\t};\n\n\t/**\n\t * Checks if preloading has finished for a specific source.\n\t * @method isPreloadComplete\n\t * @param {String} src The sound URI to load.\n\t * @return {Boolean}\n\t */\n\tp.isPreloadComplete = function (src) {\n\t\treturn (!(this._audioSources[src] == null || this._audioSources[src] == true));\n\t};\n\n\t/**\n\t * Remove a sound added using {{#crossLink \"WebAudioPlugin/register\"}}{{/crossLink}}. Note this does not cancel a preload.\n\t * @method removeSound\n\t * @param {String} src The sound URI to unload.\n\t */\n\tp.removeSound = function (src) {\n\t\tif (!this._soundInstances[src]) { return; }\n\t\tfor (var i = this._soundInstances[src].length; i--; ) {\n\t\t\tvar item = this._soundInstances[src][i];\n\t\t\titem.destroy();\n\t\t}\n\t\tdelete(this._soundInstances[src]);\n\t\tdelete(this._audioSources[src]);\n\t\tif(this._loaders[src]) { this._loaders[src].destroy(); }\n\t\tdelete(this._loaders[src]);\n\t};\n\n\t/**\n\t * Remove all sounds added using {{#crossLink \"WebAudioPlugin/register\"}}{{/crossLink}}. Note this does not cancel a preload.\n\t * @method removeAllSounds\n\t * @param {String} src The sound URI to unload.\n\t */\n\tp.removeAllSounds = function () {\n\t\tfor(var key in this._audioSources) {\n\t\t\tthis.removeSound(key);\n\t\t}\n\t};\n\n\t/**\n\t * Create a sound instance. If the sound has not been preloaded, it is internally preloaded here.\n\t * @method create\n\t * @param {String} src The sound source to use.\n\t * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\n\t * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\n\t * @return {AbstractSoundInstance} A sound instance for playback and control.\n\t */\n\tp.create = function (src, startTime, duration) {\n\t\tif (!this.isPreloadStarted(src)) {\n\t\t\tthis.preload(this.register(src));\n\t\t}\n\t\tvar si = new this._soundInstanceClass(src, startTime, duration, this._audioSources[src]);\n\t\tthis._soundInstances[src].push(si);\n\t\treturn si;\n\t};\n\n\t// if a plugin does not support volume and mute, it should set these to null\n\t/**\n\t * Set the master volume of the plugin, which affects all SoundInstances.\n\t * @method setVolume\n\t * @param {Number} value The volume to set, between 0 and 1.\n\t * @return {Boolean} If the plugin processes the setVolume call (true). The Sound class will affect all the\n\t * instances manually otherwise.\n\t */\n\tp.setVolume = function (value) {\n\t\tthis._volume = value;\n\t\tthis._updateVolume();\n\t\treturn true;\n\t};\n\n\t/**\n\t * Get the master volume of the plugin, which affects all SoundInstances.\n\t * @method getVolume\n\t * @return {Number} The volume level, between 0 and 1.\n\t */\n\tp.getVolume = function () {\n\t\treturn this._volume;\n\t};\n\n\t/**\n\t * Mute all sounds via the plugin.\n\t * @method setMute\n\t * @param {Boolean} value If all sound should be muted or not. Note that plugin-level muting just looks up\n\t * the mute value of Sound {{#crossLink \"Sound/getMute\"}}{{/crossLink}}, so this property is not used here.\n\t * @return {Boolean} If the mute call succeeds.\n\t */\n\tp.setMute = function (value) {\n\t\tthis._updateVolume();\n\t\treturn true;\n\t};\n\n\t// plugins should overwrite this method\n\tp.toString = function () {\n\t\treturn \"[AbstractPlugin]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * Handles internal preload completion.\n\t * @method _handlePreloadComplete\n\t * @protected\n\t */\n\tp._handlePreloadComplete = function (event) {\n\t\tvar src = event.target.getItem().src;\n\t\tthis._audioSources[src] = event.result;\n\t\tfor (var i = 0, l = this._soundInstances[src].length; i < l; i++) {\n\t\t\tvar item = this._soundInstances[src][i];\n\t\t\titem.setPlaybackResource(this._audioSources[src]);\n\t\t\t// ToDo consider adding play call here if playstate == playfailed\n\t\t}\n\t};\n\n\t/**\n\t * Handles internal preload erros\n\t * @method _handlePreloadError\n\t * @param event\n\t * @protected\n\t */\n\tp._handlePreloadError = function(event) {\n\t\t//delete(this._audioSources[src]);\n\t};\n\n\t/**\n\t * Set the gain value for master audio. Should not be called externally.\n\t * @method _updateVolume\n\t * @protected\n\t */\n\tp._updateVolume = function () {\n\t\t// Plugin Specific code\n\t};\n\n\tcreatejs.AbstractPlugin = AbstractPlugin;\n}());\n\n//##############################################################################\n// WebAudioLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * Loader provides a mechanism to preload Web Audio content via PreloadJS or internally. Instances are returned to\n\t * the preloader, and the load method is called when the asset needs to be requested.\n\t *\n\t * @class WebAudioLoader\n\t * @param {String} loadItem The item to be loaded\n\t * @extends XHRRequest\n\t * @protected\n\t */\n\tfunction Loader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.SOUND);\n\n\t};\n\tvar p = createjs.extend(Loader, createjs.AbstractLoader);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n\t/**\n\t * web audio context required for decoding audio\n\t * @property context\n\t * @type {AudioContext}\n\t * @static\n\t */\n\tLoader.context = null;\n\n\n// public methods\n\tp.toString = function () {\n\t\treturn \"[WebAudioLoader]\";\n\t};\n\n\n// private methods\n\tp._createRequest = function() {\n\t\tthis._request = new createjs.XHRRequest(this._item, false);\n\t\tthis._request.setResponseType(\"arraybuffer\");\n\t};\n\n\tp._sendComplete = function (event) {\n\t\t// OJR we leave this wrapped in Loader because we need to reference src and the handler only receives a single argument, the decodedAudio\n\t\tLoader.context.decodeAudioData(this._rawResult,\n\t         createjs.proxy(this._handleAudioDecoded, this),\n\t         createjs.proxy(this._sendError, this));\n\t};\n\n\n\t/**\n\t* The audio has been decoded.\n\t* @method handleAudioDecoded\n\t* @param decoded\n\t* @protected\n\t*/\n\tp._handleAudioDecoded = function (decodedAudio) {\n\t\tthis._result = decodedAudio;\n\t\tthis.AbstractLoader__sendComplete();\n\t};\n\n\tcreatejs.WebAudioLoader = createjs.promote(Loader, \"AbstractLoader\");\n}());\n\n//##############################################################################\n// WebAudioSoundInstance.js\n//##############################################################################\n\n/**\n * WebAudioSoundInstance extends the base api of {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} and is used by\n * {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}}.\n *\n * WebAudioSoundInstance exposes audioNodes for advanced users.\n *\n * @param {String} src The path to and file name of the sound.\n * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\n * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\n * @param {Object} playbackResource Any resource needed by plugin to support audio playback.\n * @class WebAudioSoundInstance\n * @extends AbstractSoundInstance\n * @constructor\n */\n(function () {\n\t\"use strict\";\n\n\tfunction WebAudioSoundInstance(src, startTime, duration, playbackResource) {\n\t\tthis.AbstractSoundInstance_constructor(src, startTime, duration, playbackResource);\n\n\n// public properties\n\t\t/**\n\t\t * NOTE this is only intended for use by advanced users.\n\t\t * <br />GainNode for controlling <code>WebAudioSoundInstance</code> volume. Connected to the {{#crossLink \"WebAudioSoundInstance/destinationNode:property\"}}{{/crossLink}}.\n\t\t * @property gainNode\n\t\t * @type {AudioGainNode}\n\t\t * @since 0.4.0\n\t\t *\n\t\t */\n\t\tthis.gainNode = s.context.createGain();\n\n\t\t/**\n\t\t * NOTE this is only intended for use by advanced users.\n\t\t * <br />A panNode allowing left and right audio channel panning only. Connected to WebAudioSoundInstance {{#crossLink \"WebAudioSoundInstance/gainNode:property\"}}{{/crossLink}}.\n\t\t * @property panNode\n\t\t * @type {AudioPannerNode}\n\t\t * @since 0.4.0\n\t\t */\n\t\tthis.panNode = s.context.createPanner();\n\t\tthis.panNode.panningModel = s._panningModel;\n\t\tthis.panNode.connect(this.gainNode);\n\t\tthis._updatePan();\n\n\t\t/**\n\t\t * NOTE this is only intended for use by advanced users.\n\t\t * <br />sourceNode is the audio source. Connected to WebAudioSoundInstance {{#crossLink \"WebAudioSoundInstance/panNode:property\"}}{{/crossLink}}.\n\t\t * @property sourceNode\n\t\t * @type {AudioNode}\n\t\t * @since 0.4.0\n\t\t *\n\t\t */\n\t\tthis.sourceNode = null;\n\n\n// private properties\n\t\t/**\n\t\t * Timeout that is created internally to handle sound playing to completion.\n\t\t * Stored so we can remove it when stop, pause, or cleanup are called\n\t\t * @property _soundCompleteTimeout\n\t\t * @type {timeoutVariable}\n\t\t * @default null\n\t\t * @protected\n\t\t * @since 0.4.0\n\t\t */\n\t\tthis._soundCompleteTimeout = null;\n\n\t\t/**\n\t\t * NOTE this is only intended for use by very advanced users.\n\t\t * _sourceNodeNext is the audio source for the next loop, inserted in a look ahead approach to allow for smooth\n\t\t * looping. Connected to {{#crossLink \"WebAudioSoundInstance/gainNode:property\"}}{{/crossLink}}.\n\t\t * @property _sourceNodeNext\n\t\t * @type {AudioNode}\n\t\t * @default null\n\t\t * @protected\n\t\t * @since 0.4.1\n\t\t *\n\t\t */\n\t\tthis._sourceNodeNext = null;\n\n\t\t/**\n\t\t * Time audio started playback, in seconds. Used to handle set position, get position, and resuming from paused.\n\t\t * @property _playbackStartTime\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @protected\n\t\t * @since 0.4.0\n\t\t */\n\t\tthis._playbackStartTime = 0;\n\n\t\t// Proxies, make removing listeners easier.\n\t\tthis._endedHandler = createjs.proxy(this._handleSoundComplete, this);\n\t};\n\tvar p = createjs.extend(WebAudioSoundInstance, createjs.AbstractSoundInstance);\n\tvar s = WebAudioSoundInstance;\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n\t/**\n\t * Note this is only intended for use by advanced users.\n\t * <br />Audio context used to create nodes.  This is and needs to be the same context used by {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}}.\n  \t * @property context\n\t * @type {AudioContext}\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.context = null;\n\n\t/**\n\t * Note this is only intended for use by advanced users.\n\t * <br />The scratch buffer that will be assigned to the buffer property of a source node on close.  \n\t * This is and should be the same scratch buffer referenced by {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}}.\n  \t * @property _scratchBuffer\n\t * @type {AudioBufferSourceNode}\n\t * @static\n\t */\n\ts._scratchBuffer = null;\n\n\t/**\n\t * Note this is only intended for use by advanced users.\n\t * <br /> Audio node from WebAudioPlugin that sequences to <code>context.destination</code>\n\t * @property destinationNode\n\t * @type {AudioNode}\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.destinationNode = null;\n\n\t/**\n\t * Value to set panning model to equal power for WebAudioSoundInstance.  Can be \"equalpower\" or 0 depending on browser implementation.\n\t * @property _panningModel\n\t * @type {Number / String}\n\t * @protected\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts._panningModel = \"equalpower\";\n\n\n// Public methods\n\tp.destroy = function() {\n\t\tthis.AbstractSoundInstance_destroy();\n\n\t\tthis.panNode.disconnect(0);\n\t\tthis.panNode = null;\n\t\tthis.gainNode.disconnect(0);\n\t\tthis.gainNode = null;\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[WebAudioSoundInstance]\";\n\t};\n\n\n// Private Methods\n\tp._updatePan = function() {\n\t\tthis.panNode.setPosition(this._pan, 0, -0.5);\n\t\t// z need to be -0.5 otherwise the sound only plays in left, right, or center\n\t};\n\n\tp._removeLooping = function(value) {\n\t\tthis._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\n\t};\n\n\tp._addLooping = function(value) {\n\t\tif (this.playState != createjs.Sound.PLAY_SUCCEEDED) { return; }\n\t\tthis._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0);\n\t};\n\n\tp._setDurationFromSource = function () {\n\t\tthis._duration = this.playbackResource.duration * 1000;\n\t};\n\n\tp._handleCleanUp = function () {\n\t\tif (this.sourceNode && this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis.sourceNode = this._cleanUpAudioNode(this.sourceNode);\n\t\t\tthis._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\n\t\t}\n\n\t\tif (this.gainNode.numberOfOutputs != 0) {this.gainNode.disconnect(0);}\n\t\t// OJR there appears to be a bug that this doesn't always work in webkit (Chrome and Safari). According to the documentation, this should work.\n\n\t\tclearTimeout(this._soundCompleteTimeout);\n\n\t\tthis._playbackStartTime = 0;\t// This is used by getPosition\n\t};\n\n\t/**\n\t * Turn off and disconnect an audioNode, then set reference to null to release it for garbage collection\n\t * @method _cleanUpAudioNode\n\t * @param audioNode\n\t * @return {audioNode}\n\t * @protected\n\t * @since 0.4.1\n\t */\n\tp._cleanUpAudioNode = function(audioNode) {\n\t\tif(audioNode) {\n\t\t\taudioNode.stop(0);\n\t\t\taudioNode.disconnect(0);\n\t\t\t// necessary to prevent leak on iOS Safari 7-9. will throw in almost all other\n\t\t\t// browser implementations.\n\t\t\ttry { audioNode.buffer = s._scratchBuffer; } catch(e) {}\n\t\t\taudioNode = null;\n\t\t}\n\t\treturn audioNode;\n\t};\n\n\tp._handleSoundReady = function (event) {\n\t\tthis.gainNode.connect(s.destinationNode);  // this line can cause a memory leak.  Nodes need to be disconnected from the audioDestination or any sequence that leads to it.\n\n\t\tvar dur = this._duration * 0.001;\n\t\tvar pos = this._position * 0.001;\n\t\tif (pos > dur) {pos = dur;}\n\t\tthis.sourceNode = this._createAndPlayAudioNode((s.context.currentTime - dur), pos);\n\t\tthis._playbackStartTime = this.sourceNode.startTime - pos;\n\n\t\tthis._soundCompleteTimeout = setTimeout(this._endedHandler, (dur - pos) * 1000);\n\n\t\tif(this._loop != 0) {\n\t\t\tthis._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0);\n\t\t}\n\t};\n\n\t/**\n\t * Creates an audio node using the current src and context, connects it to the gain node, and starts playback.\n\t * @method _createAndPlayAudioNode\n\t * @param {Number} startTime The time to add this to the web audio context, in seconds.\n\t * @param {Number} offset The amount of time into the src audio to start playback, in seconds.\n\t * @return {audioNode}\n\t * @protected\n\t * @since 0.4.1\n\t */\n\tp._createAndPlayAudioNode = function(startTime, offset) {\n\t\tvar audioNode = s.context.createBufferSource();\n\t\taudioNode.buffer = this.playbackResource;\n\t\taudioNode.connect(this.panNode);\n\t\tvar dur = this._duration * 0.001;\n\t\taudioNode.startTime = startTime + dur;\n\t\taudioNode.start(audioNode.startTime, offset+(this._startTime*0.001), dur - offset);\n\t\treturn audioNode;\n\t};\n\n\tp._pause = function () {\n\t\tthis._position = (s.context.currentTime - this._playbackStartTime) * 1000;  // * 1000 to give milliseconds, lets us restart at same point\n\t\tthis.sourceNode = this._cleanUpAudioNode(this.sourceNode);\n\t\tthis._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\n\n\t\tif (this.gainNode.numberOfOutputs != 0) {this.gainNode.disconnect(0);}\n\n\t\tclearTimeout(this._soundCompleteTimeout);\n\t};\n\n\tp._resume = function () {\n\t\tthis._handleSoundReady();\n\t};\n\n\t/*\n\tp._handleStop = function () {\n\t\t// web audio does not need to do anything extra\n\t};\n\t*/\n\n\tp._updateVolume = function () {\n\t\tvar newVolume = this._muted ? 0 : this._volume;\n\t  \tif (newVolume != this.gainNode.gain.value) {\n\t\t  this.gainNode.gain.value = newVolume;\n  \t\t}\n\t};\n\n\tp._calculateCurrentPosition = function () {\n\t\treturn ((s.context.currentTime - this._playbackStartTime) * 1000); // pos in seconds * 1000 to give milliseconds\n\t};\n\n\tp._updatePosition = function () {\n\t\tthis.sourceNode = this._cleanUpAudioNode(this.sourceNode);\n\t\tthis._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\n\t\tclearTimeout(this._soundCompleteTimeout);\n\n\t\tif (!this._paused) {this._handleSoundReady();}\n\t};\n\n\t// OJR we are using a look ahead approach to ensure smooth looping.\n\t// We add _sourceNodeNext to the audio context so that it starts playing even if this callback is delayed.\n\t// This technique is described here:  http://www.html5rocks.com/en/tutorials/audio/scheduling/\n\t// NOTE the cost of this is that our audio loop may not always match the loop event timing precisely.\n\tp._handleLoop = function () {\n\t\tthis._cleanUpAudioNode(this.sourceNode);\n\t\tthis.sourceNode = this._sourceNodeNext;\n\t\tthis._playbackStartTime = this.sourceNode.startTime;\n\t\tthis._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0);\n\t\tthis._soundCompleteTimeout = setTimeout(this._endedHandler, this._duration);\n\t};\n\n\tp._updateDuration = function () {\n\t\tif(this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis._pause();\n\t\t\tthis._resume();\n\t\t}\n\t};\n\n\tcreatejs.WebAudioSoundInstance = createjs.promote(WebAudioSoundInstance, \"AbstractSoundInstance\");\n}());\n\n//##############################################################################\n// WebAudioPlugin.js\n//##############################################################################\n\n(function () {\n\n\t\"use strict\";\n\n\t/**\n\t * Play sounds using Web Audio in the browser. The WebAudioPlugin is currently the default plugin, and will be used\n\t * anywhere that it is supported. To change plugin priority, check out the Sound API\n\t * {{#crossLink \"Sound/registerPlugins\"}}{{/crossLink}} method.\n\n\t * <h4>Known Browser and OS issues for Web Audio</h4>\n\t * <b>Firefox 25</b>\n\t * <li>\n\t *     mp3 audio files do not load properly on all windows machines, reported <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=929969\" target=\"_blank\">here</a>.\n\t *     <br />For this reason it is recommended to pass another FireFox-supported type (i.e. ogg) as the default\n\t *     extension, until this bug is resolved\n\t * </li>\n\t *\n\t * <b>Webkit (Chrome and Safari)</b>\n\t * <li>\n\t *     AudioNode.disconnect does not always seem to work.  This can cause the file size to grow over time if you\n\t * \t   are playing a lot of audio files.\n\t * </li>\n\t *\n\t * <b>iOS 6 limitations</b>\n\t * <ul>\n\t *     <li>\n\t *         Sound is initially muted and will only unmute through play being called inside a user initiated event\n\t *         (touch/click). Please read the mobile playback notes in the the {{#crossLink \"Sound\"}}{{/crossLink}}\n\t *         class for a full overview of the limitations, and how to get around them.\n\t *     </li>\n\t *\t   <li>\n\t *\t       A bug exists that will distort un-cached audio when a video element is present in the DOM. You can avoid\n\t *\t       this bug by ensuring the audio and video audio share the same sample rate.\n\t *\t   </li>\n\t * </ul>\n\t * @class WebAudioPlugin\n\t * @extends AbstractPlugin\n\t * @constructor\n\t * @since 0.4.0\n\t */\n\tfunction WebAudioPlugin() {\n\t\tthis.AbstractPlugin_constructor();\n\n\n// Private Properties\n\t\t/**\n\t\t * Value to set panning model to equal power for WebAudioSoundInstance.  Can be \"equalpower\" or 0 depending on browser implementation.\n\t\t * @property _panningModel\n\t\t * @type {Number / String}\n\t\t * @protected\n\t\t */\n\t\tthis._panningModel = s._panningModel;;\n\n\t\t/**\n\t\t * The web audio context, which WebAudio uses to play audio. All nodes that interact with the WebAudioPlugin\n\t\t * need to be created within this context.\n\t\t * @property context\n\t\t * @type {AudioContext}\n\t\t */\n\t\tthis.context = s.context;\n\n\t\t/**\n\t\t * A DynamicsCompressorNode, which is used to improve sound quality and prevent audio distortion.\n\t\t * It is connected to <code>context.destination</code>.\n\t\t *\n\t\t * Can be accessed by advanced users through createjs.Sound.activePlugin.dynamicsCompressorNode.\n\t\t * @property dynamicsCompressorNode\n\t\t * @type {AudioNode}\n\t\t */\n\t\tthis.dynamicsCompressorNode = this.context.createDynamicsCompressor();\n\t\tthis.dynamicsCompressorNode.connect(this.context.destination);\n\n\t\t/**\n\t\t * A GainNode for controlling master volume. It is connected to {{#crossLink \"WebAudioPlugin/dynamicsCompressorNode:property\"}}{{/crossLink}}.\n\t\t *\n\t\t * Can be accessed by advanced users through createjs.Sound.activePlugin.gainNode.\n\t\t * @property gainNode\n\t\t * @type {AudioGainNode}\n\t\t */\n\t\tthis.gainNode = this.context.createGain();\n\t\tthis.gainNode.connect(this.dynamicsCompressorNode);\n\t\tcreatejs.WebAudioSoundInstance.destinationNode = this.gainNode;\n\n\t\tthis._capabilities = s._capabilities;\n\n\t\tthis._loaderClass = createjs.WebAudioLoader;\n\t\tthis._soundInstanceClass = createjs.WebAudioSoundInstance;\n\n\t\tthis._addPropsToClasses();\n\t}\n\tvar p = createjs.extend(WebAudioPlugin, createjs.AbstractPlugin);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// Static Properties\n\tvar s = WebAudioPlugin;\n\t/**\n\t * The capabilities of the plugin. This is generated via the {{#crossLink \"WebAudioPlugin/_generateCapabilities:method\"}}{{/crossLink}}\n\t * method and is used internally.\n\t * @property _capabilities\n\t * @type {Object}\n\t * @default null\n\t * @protected\n\t * @static\n\t */\n\ts._capabilities = null;\n\n\t/**\n\t * Value to set panning model to equal power for WebAudioSoundInstance.  Can be \"equalpower\" or 0 depending on browser implementation.\n\t * @property _panningModel\n\t * @type {Number / String}\n\t * @protected\n\t * @static\n\t */\n\ts._panningModel = \"equalpower\";\n\n\t/**\n\t * The web audio context, which WebAudio uses to play audio. All nodes that interact with the WebAudioPlugin\n\t * need to be created within this context.\n\t *\n\t * Advanced users can set this to an existing context, but <b>must</b> do so before they call\n\t * {{#crossLink \"Sound/registerPlugins\"}}{{/crossLink}} or {{#crossLink \"Sound/initializeDefaultPlugins\"}}{{/crossLink}}.\n\t *\n\t * @property context\n\t * @type {AudioContext}\n\t * @static\n\t */\n\ts.context = null;\n\n\t/**\n\t * The scratch buffer that will be assigned to the buffer property of a source node on close.\n\t * Works around an iOS Safari bug: https://github.com/CreateJS/SoundJS/issues/102\n\t *\n\t * Advanced users can set this to an existing source node, but <b>must</b> do so before they call\n\t * {{#crossLink \"Sound/registerPlugins\"}}{{/crossLink}} or {{#crossLink \"Sound/initializeDefaultPlugins\"}}{{/crossLink}}.\n\t *\n\t * @property _scratchBuffer\n\t * @type {AudioBuffer}\n\t * @protected\n\t * @static\n\t */\n\t s._scratchBuffer = null;\n\n\t/**\n\t * Indicated whether audio on iOS has been unlocked, which requires a touchend/mousedown event that plays an\n\t * empty sound.\n\t * @property _unlocked\n\t * @type {boolean}\n\t * @since 0.6.2\n\t * @private\n\t */\n\ts._unlocked = false;\n\n\n// Static Public Methods\n\t/**\n\t * Determine if the plugin can be used in the current browser/OS.\n\t * @method isSupported\n\t * @return {Boolean} If the plugin can be initialized.\n\t * @static\n\t */\n\ts.isSupported = function () {\n\t\t// check if this is some kind of mobile device, Web Audio works with local protocol under PhoneGap and it is unlikely someone is trying to run a local file\n\t\tvar isMobilePhoneGap = createjs.BrowserDetect.isIOS || createjs.BrowserDetect.isAndroid || createjs.BrowserDetect.isBlackberry;\n\t\t// OJR isMobile may be redundant with _isFileXHRSupported available.  Consider removing.\n\t\tif (location.protocol == \"file:\" && !isMobilePhoneGap && !this._isFileXHRSupported()) { return false; }  // Web Audio requires XHR, which is not usually available locally\n\t\ts._generateCapabilities();\n\t\tif (s.context == null) {return false;}\n\t\treturn true;\n\t};\n\n\t/**\n\t * Plays an empty sound in the web audio context.  This is used to enable web audio on iOS devices, as they\n\t * require the first sound to be played inside of a user initiated event (touch/click).  This is called when\n\t * {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}} is initialized (by Sound {{#crossLink \"Sound/initializeDefaultPlugins\"}}{{/crossLink}}\n\t * for example).\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     function handleTouch(event) {\n\t *         createjs.WebAudioPlugin.playEmptySound();\n\t *     }\n\t *\n\t * @method playEmptySound\n\t * @static\n\t * @since 0.4.1\n\t */\n\ts.playEmptySound = function() {\n\t\tif (s.context == null) {return;}\n\t\tvar source = s.context.createBufferSource();\n\t\tsource.buffer = s._scratchBuffer;\n\t\tsource.connect(s.context.destination);\n\t\tsource.start(0, 0, 0);\n\t};\n\n\n// Static Private Methods\n\t/**\n\t * Determine if XHR is supported, which is necessary for web audio.\n\t * @method _isFileXHRSupported\n\t * @return {Boolean} If XHR is supported.\n\t * @since 0.4.2\n\t * @protected\n\t * @static\n\t */\n\ts._isFileXHRSupported = function() {\n\t\t// it's much easier to detect when something goes wrong, so let's start optimistically\n\t\tvar supported = true;\n\n\t\tvar xhr = new XMLHttpRequest();\n\t\ttry {\n\t\t\txhr.open(\"GET\", \"WebAudioPluginTest.fail\", false); // loading non-existant file triggers 404 only if it could load (synchronous call)\n\t\t} catch (error) {\n\t\t\t// catch errors in cases where the onerror is passed by\n\t\t\tsupported = false;\n\t\t\treturn supported;\n\t\t}\n\t\txhr.onerror = function() { supported = false; }; // cause irrelevant\n\t\t// with security turned off, we can get empty success results, which is actually a failed read (status code 0?)\n\t\txhr.onload = function() { supported = this.status == 404 || (this.status == 200 || (this.status == 0 && this.response != \"\")); };\n\t\ttry {\n\t\t\txhr.send();\n\t\t} catch (error) {\n\t\t\t// catch errors in cases where the onerror is passed by\n\t\t\tsupported = false;\n\t\t}\n\n\t\treturn supported;\n\t};\n\n\t/**\n\t * Determine the capabilities of the plugin. Used internally. Please see the Sound API {{#crossLink \"Sound/getCapabilities\"}}{{/crossLink}}\n\t * method for an overview of plugin capabilities.\n\t * @method _generateCapabilities\n\t * @static\n\t * @protected\n\t */\n\ts._generateCapabilities = function () {\n\t\tif (s._capabilities != null) {return;}\n\t\t// Web Audio can be in any formats supported by the audio element, from http://www.w3.org/TR/webaudio/#AudioContext-section\n\t\tvar t = document.createElement(\"audio\");\n\t\tif (t.canPlayType == null) {return null;}\n\n\t\tif (s.context == null) {\n\t\t\tif (window.AudioContext) {\n\t\t\t\ts.context = new AudioContext();\n\t\t\t} else if (window.webkitAudioContext) {\n\t\t\t\ts.context = new webkitAudioContext();\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tif (s._scratchBuffer == null) {\n\t\t\ts._scratchBuffer = s.context.createBuffer(1, 1, 22050);\n\t\t}\n\n\t\ts._compatibilitySetUp();\n\n\t\t// Listen for document level clicks to unlock WebAudio on iOS. See the _unlock method.\n\t\tif (\"ontouchstart\" in window && s.context.state != \"running\") {\n\t\t\ts._unlock(); // When played inside of a touch event, this will enable audio on iOS immediately.\n\t\t\tdocument.addEventListener(\"mousedown\", s._unlock, true);\n\t\t\tdocument.addEventListener(\"touchend\", s._unlock, true);\n\t\t}\n\n\n\t\ts._capabilities = {\n\t\t\tpanning:true,\n\t\t\tvolume:true,\n\t\t\ttracks:-1\n\t\t};\n\n\t\t// determine which extensions our browser supports for this plugin by iterating through Sound.SUPPORTED_EXTENSIONS\n\t\tvar supportedExtensions = createjs.Sound.SUPPORTED_EXTENSIONS;\n\t\tvar extensionMap = createjs.Sound.EXTENSION_MAP;\n\t\tfor (var i = 0, l = supportedExtensions.length; i < l; i++) {\n\t\t\tvar ext = supportedExtensions[i];\n\t\t\tvar playType = extensionMap[ext] || ext;\n\t\t\ts._capabilities[ext] = (t.canPlayType(\"audio/\" + ext) != \"no\" && t.canPlayType(\"audio/\" + ext) != \"\") || (t.canPlayType(\"audio/\" + playType) != \"no\" && t.canPlayType(\"audio/\" + playType) != \"\");\n\t\t}  // OJR another way to do this might be canPlayType:\"m4a\", codex: mp4\n\n\t\t// 0=no output, 1=mono, 2=stereo, 4=surround, 6=5.1 surround.\n\t\t// See http://www.w3.org/TR/webaudio/#AudioChannelSplitter for more details on channels.\n\t\tif (s.context.destination.numberOfChannels < 2) {\n\t\t\ts._capabilities.panning = false;\n\t\t}\n\t};\n\n\t/**\n\t * Set up compatibility if only deprecated web audio calls are supported.\n\t * See http://www.w3.org/TR/webaudio/#DeprecationNotes\n\t * Needed so we can support new browsers that don't support deprecated calls (Firefox) as well as old browsers that\n\t * don't support new calls.\n\t *\n\t * @method _compatibilitySetUp\n\t * @static\n\t * @protected\n\t * @since 0.4.2\n\t */\n\ts._compatibilitySetUp = function() {\n\t\ts._panningModel = \"equalpower\";\n\t\t//assume that if one new call is supported, they all are\n\t\tif (s.context.createGain) { return; }\n\n\t\t// simple name change, functionality the same\n\t\ts.context.createGain = s.context.createGainNode;\n\n\t\t// source node, add to prototype\n\t\tvar audioNode = s.context.createBufferSource();\n\t\taudioNode.__proto__.start = audioNode.__proto__.noteGrainOn;\t// note that noteGrainOn requires all 3 parameters\n\t\taudioNode.__proto__.stop = audioNode.__proto__.noteOff;\n\n\t\t// panningModel\n\t\ts._panningModel = 0;\n\t};\n\n\t/**\n\t * Try to unlock audio on iOS. This is triggered from either WebAudio plugin setup (which will work if inside of\n\t * a `mousedown` or `touchend` event stack), or the first document touchend/mousedown event. If it fails (touchend\n\t * will fail if the user presses for too long, indicating a scroll event instead of a click event.\n\t *\n\t * Note that earlier versions of iOS supported `touchstart` for this, but iOS9 removed this functionality. Adding\n\t * a `touchstart` event to support older platforms may preclude a `mousedown` even from getting fired on iOS9, so we\n\t * stick with `mousedown` and `touchend`.\n\t * @method _unlock\n\t * @since 0.6.2\n\t * @private\n\t */\n\ts._unlock = function() {\n\t\tif (s._unlocked) { return; }\n\t\ts.playEmptySound();\n\t\tif (s.context.state == \"running\") {\n\t\t\tdocument.removeEventListener(\"mousedown\", s._unlock, true);\n\t\t\tdocument.removeEventListener(\"touchend\", s._unlock, true);\n\t\t\ts._unlocked = true;\n\t\t}\n\t};\n\n\n// Public Methods\n\tp.toString = function () {\n\t\treturn \"[WebAudioPlugin]\";\n\t};\n\n\n// Private Methods\n\t/**\n\t * Set up needed properties on supported classes WebAudioSoundInstance and WebAudioLoader.\n\t * @method _addPropsToClasses\n\t * @static\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._addPropsToClasses = function() {\n\t\tvar c = this._soundInstanceClass;\n\t\tc.context = this.context;\n\t\tc._scratchBuffer = s._scratchBuffer;\n\t\tc.destinationNode = this.gainNode;\n\t\tc._panningModel = this._panningModel;\n\n\t\tthis._loaderClass.context = this.context;\n\t};\n\n\n\t/**\n\t * Set the gain value for master audio. Should not be called externally.\n\t * @method _updateVolume\n\t * @protected\n\t */\n\tp._updateVolume = function () {\n\t\tvar newVolume = createjs.Sound._masterMute ? 0 : this._volume;\n\t\tif (newVolume != this.gainNode.gain.value) {\n\t\t\tthis.gainNode.gain.value = newVolume;\n\t\t}\n\t};\n\n\tcreatejs.WebAudioPlugin = createjs.promote(WebAudioPlugin, \"AbstractPlugin\");\n}());\n\n//##############################################################################\n// HTMLAudioTagPool.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * HTMLAudioTagPool is an object pool for HTMLAudio tag instances.\n\t * @class HTMLAudioTagPool\n\t * @param {String} src The source of the channel.\n\t * @protected\n\t */\n\tfunction HTMLAudioTagPool() {\n\t\t\tthrow \"HTMLAudioTagPool cannot be instantiated\";\n\t}\n\n\tvar s = HTMLAudioTagPool;\n\n// Static Properties\n\t/**\n\t * A hash lookup of each base audio tag, indexed by the audio source.\n\t * @property _tags\n\t * @type {{}}\n\t * @static\n\t * @protected\n\t */\n\ts._tags = {};\n\n\t/**\n\t * An object pool for html audio tags\n\t * @property _tagPool\n\t * @type {TagPool}\n\t * @static\n\t * @protected\n\t */\n\ts._tagPool = new TagPool();\n\n\t/**\n\t * A hash lookup of if a base audio tag is available, indexed by the audio source\n\t * @property _tagsUsed\n\t * @type {{}}\n\t * @protected\n\t * @static\n\t */\n\ts._tagUsed = {};\n\n// Static Methods\n\t/**\n\t  * Get an audio tag with the given source.\n\t  * @method get\n\t  * @param {String} src The source file used by the audio tag.\n\t  * @static\n\t  */\n\t s.get = function (src) {\n\t\tvar t = s._tags[src];\n\t\tif (t == null) {\n\t\t\t// create new base tag\n\t\t\tt = s._tags[src] = s._tagPool.get();\n\t\t\tt.src = src;\n\t\t} else {\n\t\t\t// get base or pool\n\t\t\tif (s._tagUsed[src]) {\n\t\t\t\tt = s._tagPool.get();\n\t\t\t\tt.src = src;\n\t\t\t} else {\n\t\t\t\ts._tagUsed[src] = true;\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t };\n\n\t /**\n\t  * Return an audio tag to the pool.\n\t  * @method set\n\t  * @param {String} src The source file used by the audio tag.\n\t  * @param {HTMLElement} tag Audio tag to set.\n\t  * @static\n\t  */\n\t s.set = function (src, tag) {\n\t\t // check if this is base, if yes set boolean if not return to pool\n\t\t if(tag == s._tags[src]) {\n\t\t\t s._tagUsed[src] = false;\n\t\t } else {\n\t\t\t s._tagPool.set(tag);\n\t\t }\n\t };\n\n\t/**\n\t * Delete stored tag reference and return them to pool. Note that if the tag reference does not exist, this will fail.\n\t * @method remove\n\t * @param {String} src The source for the tag\n\t * @return {Boolean} If the TagPool was deleted.\n\t * @static\n\t */\n\ts.remove = function (src) {\n\t\tvar tag = s._tags[src];\n\t\tif (tag == null) {return false;}\n\t\ts._tagPool.set(tag);\n\t\tdelete(s._tags[src]);\n\t\tdelete(s._tagUsed[src]);\n\t\treturn true;\n\t};\n\n\t/**\n\t * Gets the duration of the src audio in milliseconds\n\t * @method getDuration\n\t * @param {String} src The source file used by the audio tag.\n\t * @return {Number} Duration of src in milliseconds\n\t * @static\n\t */\n\ts.getDuration= function (src) {\n\t\tvar t = s._tags[src];\n\t\tif (t == null || !t.duration) {return 0;}\t// OJR duration is NaN if loading has not completed\n\t\treturn t.duration * 1000;\n\t};\n\n\tcreatejs.HTMLAudioTagPool = HTMLAudioTagPool;\n\n\n// ************************************************************************************************************\n\t/**\n\t * The TagPool is an object pool for HTMLAudio tag instances.\n\t * #class TagPool\n\t * @param {String} src The source of the channel.\n\t * @protected\n\t */\n\tfunction TagPool(src) {\n\n// Public Properties\n\t\t/**\n\t\t * A list of all available tags in the pool.\n\t\t * #property tags\n\t\t * @type {Array}\n\t\t * @protected\n\t\t */\n\t\tthis._tags = [];\n\t};\n\n\tvar p = TagPool.prototype;\n\tp.constructor = TagPool;\n\n\n// Public Methods\n\t/**\n\t * Get an HTMLAudioElement for immediate playback. This takes it out of the pool.\n\t * #method get\n\t * @return {HTMLAudioElement} An HTML audio tag.\n\t */\n\tp.get = function () {\n\t\tvar tag;\n\t\tif (this._tags.length == 0) {\n\t\t\ttag = this._createTag();\n\t\t} else {\n\t\t\ttag = this._tags.pop();\n\t\t}\n\t\tif (tag.parentNode == null) {document.body.appendChild(tag);}\n\t\treturn tag;\n\t};\n\n\t/**\n\t * Put an HTMLAudioElement back in the pool for use.\n\t * #method set\n\t * @param {HTMLAudioElement} tag HTML audio tag\n\t */\n\tp.set = function (tag) {\n\t\t// OJR this first step seems unnecessary\n\t\tvar index = createjs.indexOf(this._tags, tag);\n\t\tif (index == -1) {\n\t\t\tthis._tags.src = null;\n\t\t\tthis._tags.push(tag);\n\t\t}\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[TagPool]\";\n\t};\n\n\n// Private Methods\n\t/**\n\t * Create an HTML audio tag.\n\t * #method _createTag\n\t * @param {String} src The source file to set for the audio tag.\n\t * @return {HTMLElement} Returns an HTML audio tag.\n\t * @protected\n\t */\n\tp._createTag = function () {\n\t\tvar tag = document.createElement(\"audio\");\n\t\ttag.autoplay = false;\n\t\ttag.preload = \"none\";\n\t\t//LM: Firefox fails when this the preload=\"none\" for other tags, but it needs to be \"none\" to ensure PreloadJS works.\n\t\treturn tag;\n\t};\n\n}());\n\n//##############################################################################\n// HTMLAudioSoundInstance.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * HTMLAudioSoundInstance extends the base api of {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} and is used by\n\t * {{#crossLink \"HTMLAudioPlugin\"}}{{/crossLink}}.\n\t *\n\t * @param {String} src The path to and file name of the sound.\n\t * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\n\t * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\n\t * @param {Object} playbackResource Any resource needed by plugin to support audio playback.\n\t * @class HTMLAudioSoundInstance\n\t * @extends AbstractSoundInstance\n\t * @constructor\n\t */\n\tfunction HTMLAudioSoundInstance(src, startTime, duration, playbackResource) {\n\t\tthis.AbstractSoundInstance_constructor(src, startTime, duration, playbackResource);\n\n\n// Private Properties\n\t\tthis._audioSpriteStopTime = null;\n\t\tthis._delayTimeoutId = null;\n\n\t\t// Proxies, make removing listeners easier.\n\t\tthis._endedHandler = createjs.proxy(this._handleSoundComplete, this);\n\t\tthis._readyHandler = createjs.proxy(this._handleTagReady, this);\n\t\tthis._stalledHandler = createjs.proxy(this._playFailed, this);\n\t\tthis._audioSpriteEndHandler = createjs.proxy(this._handleAudioSpriteLoop, this);\n\t\tthis._loopHandler = createjs.proxy(this._handleSoundComplete, this);\n\n\t\tif (duration) {\n\t\t\tthis._audioSpriteStopTime = (startTime + duration) * 0.001;\n\t\t} else {\n\t\t\tthis._duration = createjs.HTMLAudioTagPool.getDuration(this.src);\n\t\t}\n\t}\n\tvar p = createjs.extend(HTMLAudioSoundInstance, createjs.AbstractSoundInstance);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// Public Methods\n\t/**\n\t * Called by {{#crossLink \"Sound\"}}{{/crossLink}} when plugin does not handle master volume.\n\t * undoc'd because it is not meant to be used outside of Sound\n\t * #method setMasterVolume\n\t * @param value\n\t */\n\tp.setMasterVolume = function (value) {\n\t\tthis._updateVolume();\n\t};\n\n\t/**\n\t * Called by {{#crossLink \"Sound\"}}{{/crossLink}} when plugin does not handle master mute.\n\t * undoc'd because it is not meant to be used outside of Sound\n\t * #method setMasterMute\n\t * @param value\n\t */\n\tp.setMasterMute = function (isMuted) {\n\t\tthis._updateVolume();\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[HTMLAudioSoundInstance]\";\n\t};\n\n//Private Methods\n\tp._removeLooping = function() {\n\t\tif(this._playbackResource == null) {return;}\n\t\tthis._playbackResource.loop = false;\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t};\n\n\tp._addLooping = function() {\n\t\tif(this._playbackResource == null  || this._audioSpriteStopTime) {return;}\n\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t\tthis._playbackResource.loop = true;\n\t};\n\n\tp._handleCleanUp = function () {\n\t\tvar tag = this._playbackResource;\n\t\tif (tag != null) {\n\t\t\ttag.pause();\n\t\t\ttag.loop = false;\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, false);\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, false);\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\n\n\t\t\ttry {\n\t\t\t\ttag.currentTime = this._startTime;\n\t\t\t} catch (e) {\n\t\t\t} // Reset Position\n\t\t\tcreatejs.HTMLAudioTagPool.set(this.src, tag);\n\t\t\tthis._playbackResource = null;\n\t\t}\n\t};\n\n\tp._beginPlaying = function (playProps) {\n\t\tthis._playbackResource = createjs.HTMLAudioTagPool.get(this.src);\n\t\treturn this.AbstractSoundInstance__beginPlaying(playProps);\n\t};\n\n\tp._handleSoundReady = function (event) {\n\t\tif (this._playbackResource.readyState !== 4) {\n\t\t\tvar tag = this._playbackResource;\n\t\t\ttag.addEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, false);\n\t\t\ttag.addEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, false);\n\t\t\ttag.preload = \"auto\"; // This is necessary for Firefox, as it won't ever \"load\" until this is set.\n\t\t\ttag.load();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._updateVolume();\n\t\tthis._playbackResource.currentTime = (this._startTime + this._position) * 0.001;\n\t\tif (this._audioSpriteStopTime) {\n\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\n\t\t} else {\n\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\n\t\t\tif(this._loop != 0) {\n\t\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t\t\t\tthis._playbackResource.loop = true;\n\t\t\t}\n\t\t}\n\n\t\tthis._playbackResource.play();\n\t};\n\n\t/**\n\t * Used to handle when a tag is not ready for immediate playback when it is returned from the HTMLAudioTagPool.\n\t * @method _handleTagReady\n\t * @param event\n\t * @protected\n\t */\n\tp._handleTagReady = function (event) {\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, false);\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, false);\n\n\t\tthis._handleSoundReady();\n\t};\n\n\tp._pause = function () {\n\t\tthis._playbackResource.pause();\n\t};\n\n\tp._resume = function () {\n\t\tthis._playbackResource.play();\n\t};\n\n\tp._updateVolume = function () {\n\t\tif (this._playbackResource != null) {\n\t\t\tvar newVolume = (this._muted || createjs.Sound._masterMute) ? 0 : this._volume * createjs.Sound._masterVolume;\n\t\t\tif (newVolume != this._playbackResource.volume) {this._playbackResource.volume = newVolume;}\n\t\t}\n\t};\n\n\tp._calculateCurrentPosition = function() {\n\t\treturn (this._playbackResource.currentTime * 1000) - this._startTime;\n\t};\n\n\tp._updatePosition = function() {\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._handleSetPositionSeek, false);\n\t\ttry {\n\t\t\tthis._playbackResource.currentTime = (this._position + this._startTime) * 0.001;\n\t\t} catch (error) { // Out of range\n\t\t\tthis._handleSetPositionSeek(null);\n\t\t}\n\t};\n\n\t/**\n\t * Used to enable setting position, as we need to wait for that seek to be done before we add back our loop handling seek listener\n\t * @method _handleSetPositionSeek\n\t * @param event\n\t * @protected\n\t */\n\tp._handleSetPositionSeek = function(event) {\n\t\tif (this._playbackResource == null) { return; }\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._handleSetPositionSeek, false);\n\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t};\n\n\t/**\n\t * Timer used to loop audio sprites.\n\t * NOTE because of the inaccuracies in the timeupdate event (15 - 250ms) and in setting the tag to the desired timed\n\t * (up to 300ms), it is strongly recommended not to loop audio sprites with HTML Audio if smooth looping is desired\n\t *\n\t * @method _handleAudioSpriteLoop\n\t * @param event\n\t * @private\n\t */\n\tp._handleAudioSpriteLoop = function (event) {\n\t\tif(this._playbackResource.currentTime <= this._audioSpriteStopTime) {return;}\n\t\tthis._playbackResource.pause();\n\t\tif(this._loop == 0) {\n\t\t\tthis._handleSoundComplete(null);\n\t\t} else {\n\t\t\tthis._position = 0;\n\t\t\tthis._loop--;\n\t\t\tthis._playbackResource.currentTime = this._startTime * 0.001;\n\t\t\tif(!this._paused) {this._playbackResource.play();}\n\t\t\tthis._sendEvent(\"loop\");\n\t\t}\n\t};\n\n\t// NOTE with this approach audio will loop as reliably as the browser allows\n\t// but we could end up sending the loop event after next loop playback begins\n\tp._handleLoop = function (event) {\n\t\tif(this._loop == 0) {\n\t\t\tthis._playbackResource.loop = false;\n\t\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t\t}\n\t};\n\n\tp._updateStartTime = function () {\n\t\tthis._audioSpriteStopTime = (this._startTime + this._duration) * 0.001;\n\n\t\tif(this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\n\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\n\t\t}\n\t};\n\n\tp._updateDuration = function () {\n\t\tthis._audioSpriteStopTime = (this._startTime + this._duration) * 0.001;\n\n\t\tif(this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\n\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\n\t\t}\n\t};\n\n\tp._setDurationFromSource = function () {\n\t\tthis._duration = createjs.HTMLAudioTagPool.getDuration(this.src);\n\t\tthis._playbackResource = null;\n\t};\n\n\tcreatejs.HTMLAudioSoundInstance = createjs.promote(HTMLAudioSoundInstance, \"AbstractSoundInstance\");\n}());\n\n//##############################################################################\n// HTMLAudioPlugin.js\n//##############################################################################\n\n(function () {\n\n\t\"use strict\";\n\n\t/**\n\t * Play sounds using HTML &lt;audio&gt; tags in the browser. This plugin is the second priority plugin installed\n\t * by default, after the {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}}.  For older browsers that do not support html\n\t * audio, include and install the {{#crossLink \"FlashAudioPlugin\"}}{{/crossLink}}.\n\t *\n\t * <h4>Known Browser and OS issues for HTML Audio</h4>\n\t * <b>All browsers</b><br />\n\t * Testing has shown in all browsers there is a limit to how many audio tag instances you are allowed.  If you exceed\n\t * this limit, you can expect to see unpredictable results. Please use {{#crossLink \"Sound.MAX_INSTANCES\"}}{{/crossLink}} as\n\t * a guide to how many total audio tags you can safely use in all browsers.  This issue is primarily limited to IE9.\n\t *\n     * <b>IE html limitations</b><br />\n     * <ul><li>There is a delay in applying volume changes to tags that occurs once playback is started. So if you have\n     * muted all sounds, they will all play during this delay until the mute applies internally. This happens regardless of\n     * when or how you apply the volume change, as the tag seems to need to play to apply it.</li>\n     * <li>MP3 encoding will not always work for audio tags if it's not default.  We've found default encoding with\n     * 64kbps works.</li>\n\t * <li>Occasionally very short samples will get cut off.</li>\n\t * <li>There is a limit to how many audio tags you can load or play at once, which appears to be determined by\n\t * hardware and browser settings.  See {{#crossLink \"HTMLAudioPlugin.MAX_INSTANCES\"}}{{/crossLink}} for a safe estimate.\n\t * Note that audio sprites can be used as a solution to this issue.</li></ul>\n\t *\n\t * <b>Safari limitations</b><br />\n\t * <ul><li>Safari requires Quicktime to be installed for audio playback.</li></ul>\n\t *\n\t * <b>iOS 6 limitations</b><br />\n\t * <ul><li>can only have one &lt;audio&gt; tag</li>\n\t * \t\t<li>can not preload or autoplay the audio</li>\n\t * \t\t<li>can not cache the audio</li>\n\t * \t\t<li>can not play the audio except inside a user initiated event.</li>\n\t *\t\t<li>Note it is recommended to use {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}} for iOS (6+)</li>\n\t * \t\t<li>audio sprites can be used to mitigate some of these issues and are strongly recommended on iOS</li>\n\t * </ul>\n\t *\n\t * <b>Android Native Browser limitations</b><br />\n\t * <ul><li>We have no control over audio volume. Only the user can set volume on their device.</li>\n\t *      <li>We can only play audio inside a user event (touch/click).  This currently means you cannot loop sound or use a delay.</li></ul>\n\t * <b> Android Chrome 26.0.1410.58 specific limitations</b><br />\n\t * <ul> <li>Can only play 1 sound at a time.</li>\n\t *      <li>Sound is not cached.</li>\n\t *      <li>Sound can only be loaded in a user initiated touch/click event.</li>\n\t *      <li>There is a delay before a sound is played, presumably while the src is loaded.</li>\n\t * </ul>\n\t *\n\t * See {{#crossLink \"Sound\"}}{{/crossLink}} for general notes on known issues.\n\t *\n\t * @class HTMLAudioPlugin\n\t * @extends AbstractPlugin\n\t * @constructor\n\t */\n\tfunction HTMLAudioPlugin() {\n\t\tthis.AbstractPlugin_constructor();\n\n\n\t// Public Properties\n\t\t/**\n\t\t * This is no longer needed as we are now using object pooling for tags.\n\t\t *\n\t\t * <b>NOTE this property only exists as a limitation of HTML audio.</b>\n\t\t * @property defaultNumChannels\n\t\t * @type {Number}\n\t\t * @default 2\n\t\t * @since 0.4.0\n\t\t * @deprecated\n\t\t */\n\t\tthis.defaultNumChannels = 2;\n\n\t\tthis._capabilities = s._capabilities;\n\n\t\tthis._loaderClass = createjs.SoundLoader;\n\t\tthis._soundInstanceClass = createjs.HTMLAudioSoundInstance;\n\t}\n\n\tvar p = createjs.extend(HTMLAudioPlugin, createjs.AbstractPlugin);\n\tvar s = HTMLAudioPlugin;\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// Static Properties\n\t/**\n\t * The maximum number of instances that can be loaded or played. This is a browser limitation, primarily limited to IE9.\n\t * The actual number varies from browser to browser (and is largely hardware dependant), but this is a safe estimate.\n\t * Audio sprites work around this limitation.\n\t * @property MAX_INSTANCES\n\t * @type {Number}\n\t * @default 30\n\t * @static\n\t */\n\ts.MAX_INSTANCES = 30;\n\n\t/**\n\t * Event constant for the \"canPlayThrough\" event for cleaner code.\n\t * @property _AUDIO_READY\n\t * @type {String}\n\t * @default canplaythrough\n\t * @static\n\t * @protected\n\t */\n\ts._AUDIO_READY = \"canplaythrough\";\n\n\t/**\n\t * Event constant for the \"ended\" event for cleaner code.\n\t * @property _AUDIO_ENDED\n\t * @type {String}\n\t * @default ended\n\t * @static\n\t * @protected\n\t */\n\ts._AUDIO_ENDED = \"ended\";\n\n\t/**\n\t * Event constant for the \"seeked\" event for cleaner code.  We utilize this event for maintaining loop events.\n\t * @property _AUDIO_SEEKED\n\t * @type {String}\n\t * @default seeked\n\t * @static\n\t * @protected\n\t */\n\ts._AUDIO_SEEKED = \"seeked\";\n\n\t/**\n\t * Event constant for the \"stalled\" event for cleaner code.\n\t * @property _AUDIO_STALLED\n\t * @type {String}\n\t * @default stalled\n\t * @static\n\t * @protected\n\t */\n\ts._AUDIO_STALLED = \"stalled\";\n\n\t/**\n\t * Event constant for the \"timeupdate\" event for cleaner code.  Utilized for looping audio sprites.\n\t * This event callsback ever 15 to 250ms and can be dropped by the browser for performance.\n\t * @property _TIME_UPDATE\n\t * @type {String}\n\t * @default timeupdate\n\t * @static\n\t * @protected\n\t */\n\ts._TIME_UPDATE = \"timeupdate\";\n\n\t/**\n\t * The capabilities of the plugin. This is generated via the {{#crossLink \"HTMLAudioPlugin/_generateCapabilities\"}}{{/crossLink}}\n\t * method. Please see the Sound {{#crossLink \"Sound/getCapabilities\"}}{{/crossLink}} method for an overview of all\n\t * of the available properties.\n\t * @property _capabilities\n\t * @type {Object}\n\t * @protected\n\t * @static\n\t */\n\ts._capabilities = null;\n\n\n// Static Methods\n\t/**\n\t * Determine if the plugin can be used in the current browser/OS. Note that HTML audio is available in most modern\n\t * browsers, but is disabled in iOS because of its limitations.\n\t * @method isSupported\n\t * @return {Boolean} If the plugin can be initialized.\n\t * @static\n\t */\n\ts.isSupported = function () {\n\t\ts._generateCapabilities();\n\t\treturn (s._capabilities != null);\n\t};\n\n\t/**\n\t * Determine the capabilities of the plugin. Used internally. Please see the Sound API {{#crossLink \"Sound/getCapabilities\"}}{{/crossLink}}\n\t * method for an overview of plugin capabilities.\n\t * @method _generateCapabilities\n\t * @static\n\t * @protected\n\t */\n\ts._generateCapabilities = function () {\n\t\tif (s._capabilities != null) {return;}\n\t\tvar t = document.createElement(\"audio\");\n\t\tif (t.canPlayType == null) {return null;}\n\n\t\ts._capabilities = {\n\t\t\tpanning:false,\n\t\t\tvolume:true,\n\t\t\ttracks:-1\n\t\t};\n\n\t\t// determine which extensions our browser supports for this plugin by iterating through Sound.SUPPORTED_EXTENSIONS\n\t\tvar supportedExtensions = createjs.Sound.SUPPORTED_EXTENSIONS;\n\t\tvar extensionMap = createjs.Sound.EXTENSION_MAP;\n\t\tfor (var i = 0, l = supportedExtensions.length; i < l; i++) {\n\t\t\tvar ext = supportedExtensions[i];\n\t\t\tvar playType = extensionMap[ext] || ext;\n\t\t\ts._capabilities[ext] = (t.canPlayType(\"audio/\" + ext) != \"no\" && t.canPlayType(\"audio/\" + ext) != \"\") || (t.canPlayType(\"audio/\" + playType) != \"no\" && t.canPlayType(\"audio/\" + playType) != \"\");\n\t\t}  // OJR another way to do this might be canPlayType:\"m4a\", codex: mp4\n\t};\n\n\n// public methods\n\tp.register = function (loadItem) {\n\t\tvar tag = createjs.HTMLAudioTagPool.get(loadItem.src);\n\t\tvar loader = this.AbstractPlugin_register(loadItem);\n\t\tloader.setTag(tag);\n\n\t\treturn loader;\n\t};\n\n\tp.removeSound = function (src) {\n\t\tthis.AbstractPlugin_removeSound(src);\n\t\tcreatejs.HTMLAudioTagPool.remove(src);\n\t};\n\n\tp.create = function (src, startTime, duration) {\n\t\tvar si = this.AbstractPlugin_create(src, startTime, duration);\n\t\tsi.setPlaybackResource(null);\n\t\treturn si;\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[HTMLAudioPlugin]\";\n\t};\n\n\t// plugin does not support these\n\tp.setVolume = p.getVolume = p.setMute = null;\n\n\n\tcreatejs.HTMLAudioPlugin = createjs.promote(HTMLAudioPlugin, \"AbstractPlugin\");\n}());\n\n//##############################################################################\n// Tween.js\n//##############################################################################\n\n// TODO: possibly add a END actionsMode (only runs actions that == position)?\n// TODO: evaluate a way to decouple paused from tick registration.\n\n\n\n\n(function() {\n\t\"use strict\";\n\n\n// constructor\n\t/**\n\t * A Tween instance tweens properties for a single target. Instance methods can be chained for easy construction and sequencing:\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      target.alpha = 1;\n\t *\t    createjs.Tween.get(target)\n\t *\t         .wait(500)\n\t *\t         .to({alpha:0, visible:false}, 1000)\n\t *\t         .call(handleComplete);\n\t *\t    function handleComplete() {\n\t *\t    \t//Tween complete\n\t *\t    }\n\t *\n\t * Multiple tweens can point to the same instance, however if they affect the same properties there could be unexpected\n\t * behaviour. To stop all tweens on an object, use {{#crossLink \"Tween/removeTweens\"}}{{/crossLink}} or pass `override:true`\n\t * in the props argument.\n\t *\n\t *      createjs.Tween.get(target, {override:true}).to({x:100});\n\t *\n\t * Subscribe to the {{#crossLink \"Tween/change:event\"}}{{/crossLink}} event to get notified when a property of the\n\t * target is changed.\n\t *\n\t *      createjs.Tween.get(target, {override:true}).to({x:100}).addEventListener(\"change\", handleChange);\n\t *      function handleChange(event) {\n\t *          // The tween changed.\n\t *      }\n\t *\n\t * See the Tween {{#crossLink \"Tween/get\"}}{{/crossLink}} method for additional param documentation.\n\t * @class Tween\n\t * @param {Object} target The target object that will have its properties tweened.\n\t * @param {Object} [props] The configuration properties to apply to this tween instance (ex. `{loop:true, paused:true}`.\n\t * All properties default to false. Supported props are:<UL>\n\t *    <LI> loop: sets the loop property on this tween.</LI>\n\t *    <LI> useTicks: uses ticks for all durations instead of milliseconds.</LI>\n\t *    <LI> ignoreGlobalPause: sets the {{#crossLink \"Tween/ignoreGlobalPause:property\"}}{{/crossLink}} property on this tween.</LI>\n\t *    <LI> override: if true, `Tween.removeTweens(target)` will be called to remove any other tweens with the same target.\n\t *    <LI> paused: indicates whether to start the tween paused.</LI>\n\t *    <LI> position: indicates the initial position for this tween.</LI>\n\t *    <LI> onChange: specifies a listener for the \"change\" event.</LI>\n\t * </UL>\n\t * @param {Object} [pluginData] An object containing data for use by installed plugins. See individual\n\t * plugins' documentation for details.\n\t * @extends EventDispatcher\n\t * @constructor\n\t */\n\tfunction Tween(target, props, pluginData) {\n\n\t// public properties:\n\t\t/**\n\t\t * Causes this tween to continue playing when a global pause is active. For example, if TweenJS is using {{#crossLink \"Ticker\"}}{{/crossLink}},\n\t\t * then setting this to true (the default) will cause this tween to be paused when <code>Ticker.setPaused(true)</code>\n\t\t * is called. See the Tween {{#crossLink \"Tween/tick\"}}{{/crossLink}} method for more info. Can be set via the props\n\t\t * parameter.\n\t\t * @property ignoreGlobalPause\n\t\t * @type Boolean\n\t\t * @default false\n\t\t */\n\t\tthis.ignoreGlobalPause = false;\n\t\n\t\t/**\n\t\t * If true, the tween will loop when it reaches the end. Can be set via the props param.\n\t\t * @property loop\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.loop = false;\n\t\n\t\t/**\n\t\t * Specifies the total duration of this tween in milliseconds (or ticks if useTicks is true).\n\t\t * This value is automatically updated as you modify the tween. Changing it directly could result in unexpected\n\t\t * behaviour.\n\t\t * @property duration\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @readonly\n\t\t */\n\t\tthis.duration = 0;\n\t\n\t\t/**\n\t\t * Allows you to specify data that will be used by installed plugins. Each plugin uses this differently, but in general\n\t\t * you specify data by setting it to a property of pluginData with the same name as the plugin class.\n\t\t * @example\n\t\t *\tmyTween.pluginData.PluginClassName = data;\n\t\t * <br/>\n\t\t * Also, most plugins support a property to enable or disable them. This is typically the plugin class name followed by \"_enabled\".<br/>\n\t\t * @example\n\t\t *\tmyTween.pluginData.PluginClassName_enabled = false;<br/>\n\t\t * <br/>\n\t\t * Some plugins also store instance data in this object, usually in a property named _PluginClassName.\n\t\t * See the documentation for individual plugins for more details.\n\t\t * @property pluginData\n\t\t * @type {Object}\n\t\t */\n\t\tthis.pluginData = pluginData || {};\n\t\n\t\t/**\n\t\t * The target of this tween. This is the object on which the tweened properties will be changed. Changing\n\t\t * this property after the tween is created will not have any effect.\n\t\t * @property target\n\t\t * @type {Object}\n\t\t * @readonly\n\t\t */\n\t\tthis.target = target;\n\t\n\t\t/**\n\t\t * The current normalized position of the tween. This will always be a value between 0 and duration.\n\t\t * Changing this property directly will have no effect.\n\t\t * @property position\n\t\t * @type {Object}\n\t\t * @readonly\n\t\t */\n\t\tthis.position = null;\n\t\n\t\t/**\n\t\t * Indicates the tween's current position is within a passive wait.\n\t\t * @property passive\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @readonly\n\t\t **/\n\t\tthis.passive = false;\n\t\n\t// private properties:\t\n\t\t/**\n\t\t * @property _paused\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis._paused = false;\n\t\n\t\t/**\n\t\t * @property _curQueueProps\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._curQueueProps = {};\n\t\n\t\t/**\n\t\t * @property _initQueueProps\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._initQueueProps = {};\n\t\n\t\t/**\n\t\t * @property _steps\n\t\t * @type {Array}\n\t\t * @protected\n\t\t */\n\t\tthis._steps = [];\n\t\n\t\t/**\n\t\t * @property _actions\n\t\t * @type {Array}\n\t\t * @protected\n\t\t */\n\t\tthis._actions = [];\n\t\n\t\t/**\n\t\t * Raw position.\n\t\t * @property _prevPosition\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @protected\n\t\t */\n\t\tthis._prevPosition = 0;\n\t\n\t\t/**\n\t\t * The position within the current step.\n\t\t * @property _stepPosition\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @protected\n\t\t */\n\t\tthis._stepPosition = 0; // this is needed by MovieClip.\n\t\n\t\t/**\n\t\t * Normalized position.\n\t\t * @property _prevPos\n\t\t * @type {Number}\n\t\t * @default -1\n\t\t * @protected\n\t\t */\n\t\tthis._prevPos = -1;\n\t\n\t\t/**\n\t\t * @property _target\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._target = target;\n\t\n\t\t/**\n\t\t * @property _useTicks\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis._useTicks = false;\n\t\n\t\t/**\n\t\t * @property _inited\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis._inited = false;\n\t\t\n\t\t/**\n\t\t * Indicates whether the tween is currently registered with Tween.\n\t\t * @property _registered\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis._registered = false;\n\n\n\t\tif (props) {\n\t\t\tthis._useTicks = props.useTicks;\n\t\t\tthis.ignoreGlobalPause = props.ignoreGlobalPause;\n\t\t\tthis.loop = props.loop;\n\t\t\tprops.onChange && this.addEventListener(\"change\", props.onChange);\n\t\t\tif (props.override) { Tween.removeTweens(target); }\n\t\t}\n\t\tif (props&&props.paused) { this._paused=true; }\n\t\telse { createjs.Tween._register(this,true); }\n\t\tif (props&&props.position!=null) { this.setPosition(props.position, Tween.NONE); }\n\n\t};\n\n\tvar p = createjs.extend(Tween, createjs.EventDispatcher);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\t\n\n// static properties\n\t/**\n\t * Constant defining the none actionsMode for use with setPosition.\n\t * @property NONE\n\t * @type Number\n\t * @default 0\n\t * @static\n\t */\n\tTween.NONE = 0;\n\n\t/**\n\t * Constant defining the loop actionsMode for use with setPosition.\n\t * @property LOOP\n\t * @type Number\n\t * @default 1\n\t * @static\n\t */\n\tTween.LOOP = 1;\n\n\t/**\n\t * Constant defining the reverse actionsMode for use with setPosition.\n\t * @property REVERSE\n\t * @type Number\n\t * @default 2\n\t * @static\n\t */\n\tTween.REVERSE = 2;\n\n\t/**\n\t * Constant returned by plugins to tell the tween not to use default assignment.\n\t * @property IGNORE\n\t * @type Object\n\t * @static\n\t */\n\tTween.IGNORE = {};\n\n\t/**\n\t * @property _listeners\n\t * @type Array[Tween]\n\t * @static\n\t * @protected\n\t */\n\tTween._tweens = [];\n\n\t/**\n\t * @property _plugins\n\t * @type Object\n\t * @static\n\t * @protected\n\t */\n\tTween._plugins = {};\n\n\n// static methods\t\n\t/**\n\t * Returns a new tween instance. This is functionally identical to using \"new Tween(...)\", but looks cleaner\n\t * with the chained syntax of TweenJS.\n\t * <h4>Example</h4>\n\t *\n\t *\t\tvar tween = createjs.Tween.get(target);\n\t *\n\t * @method get\n\t * @param {Object} target The target object that will have its properties tweened.\n\t * @param {Object} [props] The configuration properties to apply to this tween instance (ex. `{loop:true, paused:true}`).\n\t * All properties default to `false`. Supported props are:\n\t * <UL>\n\t *    <LI> loop: sets the loop property on this tween.</LI>\n\t *    <LI> useTicks: uses ticks for all durations instead of milliseconds.</LI>\n\t *    <LI> ignoreGlobalPause: sets the {{#crossLink \"Tween/ignoreGlobalPause:property\"}}{{/crossLink}} property on\n\t *    this tween.</LI>\n\t *    <LI> override: if true, `createjs.Tween.removeTweens(target)` will be called to remove any other tweens with\n\t *    the same target.\n\t *    <LI> paused: indicates whether to start the tween paused.</LI>\n\t *    <LI> position: indicates the initial position for this tween.</LI>\n\t *    <LI> onChange: specifies a listener for the {{#crossLink \"Tween/change:event\"}}{{/crossLink}} event.</LI>\n\t * </UL>\n\t * @param {Object} [pluginData] An object containing data for use by installed plugins. See individual plugins'\n\t * documentation for details.\n\t * @param {Boolean} [override=false] If true, any previous tweens on the same target will be removed. This is the\n\t * same as calling `Tween.removeTweens(target)`.\n\t * @return {Tween} A reference to the created tween. Additional chained tweens, method calls, or callbacks can be\n\t * applied to the returned tween instance.\n\t * @static\n\t */\n\tTween.get = function(target, props, pluginData, override) {\n\t\tif (override) { Tween.removeTweens(target); }\n\t\treturn new Tween(target, props, pluginData);\n\t};\n\n\t/**\n\t * Advances all tweens. This typically uses the {{#crossLink \"Ticker\"}}{{/crossLink}} class, but you can call it\n\t * manually if you prefer to use your own \"heartbeat\" implementation.\n\t * @method tick\n\t * @param {Number} delta The change in time in milliseconds since the last tick. Required unless all tweens have\n\t * `useTicks` set to true.\n\t * @param {Boolean} paused Indicates whether a global pause is in effect. Tweens with {{#crossLink \"Tween/ignoreGlobalPause:property\"}}{{/crossLink}}\n\t * will ignore this, but all others will pause if this is `true`.\n\t * @static\n\t */\n\tTween.tick = function(delta, paused) {\n\t\tvar tweens = Tween._tweens.slice(); // to avoid race conditions.\n\t\tfor (var i=tweens.length-1; i>=0; i--) {\n\t\t\tvar tween = tweens[i];\n\t\t\tif ((paused && !tween.ignoreGlobalPause) || tween._paused) { continue; }\n\t\t\ttween.tick(tween._useTicks?1:delta);\n\t\t}\n\t};\n\n\t/**\n\t * Handle events that result from Tween being used as an event handler. This is included to allow Tween to handle\n\t * {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}} events from the createjs {{#crossLink \"Ticker\"}}{{/crossLink}}.\n\t * No other events are handled in Tween.\n\t * @method handleEvent\n\t * @param {Object} event An event object passed in by the {{#crossLink \"EventDispatcher\"}}{{/crossLink}}. Will\n\t * usually be of type \"tick\".\n\t * @private\n\t * @static\n\t * @since 0.4.2\n\t */\n\tTween.handleEvent = function(event) {\n\t\tif (event.type == \"tick\") {\n\t\t\tthis.tick(event.delta, event.paused);\n\t\t}\n\t};\n\n\t/**\n\t * Removes all existing tweens for a target. This is called automatically by new tweens if the `override`\n\t * property is `true`.\n\t * @method removeTweens\n\t * @param {Object} target The target object to remove existing tweens from.\n\t * @static\n\t */\n\tTween.removeTweens = function(target) {\n\t\tif (!target.tweenjs_count) { return; }\n\t\tvar tweens = Tween._tweens;\n\t\tfor (var i=tweens.length-1; i>=0; i--) {\n\t\t\tvar tween = tweens[i];\n\t\t\tif (tween._target == target) {\n\t\t\t\ttween._paused = true;\n\t\t\t\ttweens.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\ttarget.tweenjs_count = 0;\n\t};\n\n\t/**\n\t * Stop and remove all existing tweens.\n\t * @method removeAllTweens\n\t * @static\n\t * @since 0.4.1\n\t */\n\tTween.removeAllTweens = function() {\n\t\tvar tweens = Tween._tweens;\n\t\tfor (var i= 0, l=tweens.length; i<l; i++) {\n\t\t\tvar tween = tweens[i];\n\t\t\ttween._paused = true;\n\t\t\ttween.target&&(tween.target.tweenjs_count = 0);\n\t\t}\n\t\ttweens.length = 0;\n\t};\n\n\t/**\n\t * Indicates whether there are any active tweens (and how many) on the target object (if specified) or in general.\n\t * @method hasActiveTweens\n\t * @param {Object} [target] The target to check for active tweens. If not specified, the return value will indicate\n\t * if there are any active tweens on any target.\n\t * @return {Boolean} If there are active tweens.\n\t * @static\n\t */\n\tTween.hasActiveTweens = function(target) {\n\t\tif (target) { return target.tweenjs_count != null && !!target.tweenjs_count; }\n\t\treturn Tween._tweens && !!Tween._tweens.length;\n\t};\n\n\t/**\n\t * Installs a plugin, which can modify how certain properties are handled when tweened. See the {{#crossLink \"CSSPlugin\"}}{{/crossLink}}\n\t * for an example of how to write TweenJS plugins.\n\t * @method installPlugin\n\t * @static\n\t * @param {Object} plugin The plugin class to install\n\t * @param {Array} properties An array of properties that the plugin will handle.\n\t */\n\tTween.installPlugin = function(plugin, properties) {\n\t\tvar priority = plugin.priority;\n\t\tif (priority == null) { plugin.priority = priority = 0; }\n\t\tfor (var i=0,l=properties.length,p=Tween._plugins;i<l;i++) {\n\t\t\tvar n = properties[i];\n\t\t\tif (!p[n]) { p[n] = [plugin]; }\n\t\t\telse {\n\t\t\t\tvar arr = p[n];\n\t\t\t\tfor (var j=0,jl=arr.length;j<jl;j++) {\n\t\t\t\t\tif (priority < arr[j].priority) { break; }\n\t\t\t\t}\n\t\t\t\tp[n].splice(j,0,plugin);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Registers or unregisters a tween with the ticking system.\n\t * @method _register\n\t * @param {Tween} tween The tween instance to register or unregister.\n\t * @param {Boolean} value If `true`, the tween is registered. If `false` the tween is unregistered.\n\t * @static\n\t * @protected\n\t */\n\tTween._register = function(tween, value) {\n\t\tvar target = tween._target;\n\t\tvar tweens = Tween._tweens;\n\t\tif (value && !tween._registered) {\n\t\t\t// TODO: this approach might fail if a dev is using sealed objects in ES5\n\t\t\tif (target) { target.tweenjs_count = target.tweenjs_count ? target.tweenjs_count+1 : 1; }\n\t\t\ttweens.push(tween);\n\t\t\tif (!Tween._inited && createjs.Ticker) { createjs.Ticker.addEventListener(\"tick\", Tween); Tween._inited = true; }\n\t\t} else if (!value && tween._registered) {\n\t\t\tif (target) { target.tweenjs_count--; }\n\t\t\tvar i = tweens.length;\n\t\t\twhile (i--) {\n\t\t\t\tif (tweens[i] == tween) {\n\t\t\t\t\ttweens.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttween._registered = value;\n\t};\n\n\n// events:\n\t/**\n\t * Called whenever the tween's position changes.\n\t * @event change\n\t * @since 0.4.0\n\t **/\n\t\n\n// public methods:\n\t/**\n\t * Queues a wait (essentially an empty tween).\n\t * <h4>Example</h4>\n\t *\n\t *\t\t//This tween will wait 1s before alpha is faded to 0.\n\t *\t\tcreatejs.Tween.get(target).wait(1000).to({alpha:0}, 1000);\n\t *\n\t * @method wait\n\t * @param {Number} duration The duration of the wait in milliseconds (or in ticks if `useTicks` is true).\n\t * @param {Boolean} [passive] Tween properties will not be updated during a passive wait. This\n\t * is mostly useful for use with {{#crossLink \"Timeline\"}}{{/crossLink}} instances that contain multiple tweens\n\t * affecting the same target at different times.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t **/\n\tp.wait = function(duration, passive) {\n\t\tif (duration == null || duration <= 0) { return this; }\n\t\tvar o = this._cloneProps(this._curQueueProps);\n\t\treturn this._addStep({d:duration, p0:o, e:this._linearEase, p1:o, v:passive});\n\t};\n\n\t/**\n\t * Queues a tween from the current values to the target properties. Set duration to 0 to jump to these value.\n\t * Numeric properties will be tweened from their current value in the tween to the target value. Non-numeric\n\t * properties will be set at the end of the specified duration.\n\t * <h4>Example</h4>\n\t *\n\t *\t\tcreatejs.Tween.get(target).to({alpha:0}, 1000);\n\t *\n\t * @method to\n\t * @param {Object} props An object specifying property target values for this tween (Ex. `{x:300}` would tween the x\n\t * property of the target to 300).\n\t * @param {Number} [duration=0] The duration of the wait in milliseconds (or in ticks if `useTicks` is true).\n\t * @param {Function} [ease=\"linear\"] The easing function to use for this tween. See the {{#crossLink \"Ease\"}}{{/crossLink}}\n\t * class for a list of built-in ease functions.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t */\n\tp.to = function(props, duration, ease) {\n\t\tif (isNaN(duration) || duration < 0) { duration = 0; }\n\t\treturn this._addStep({d:duration||0, p0:this._cloneProps(this._curQueueProps), e:ease, p1:this._cloneProps(this._appendQueueProps(props))});\n\t};\n\n\t/**\n\t * Queues an action to call the specified function.\n\t * <h4>Example</h4>\n\t *\n\t *   \t//would call myFunction() after 1 second.\n\t *   \tmyTween.wait(1000).call(myFunction);\n\t *\n\t * @method call\n\t * @param {Function} callback The function to call.\n\t * @param {Array} [params]. The parameters to call the function with. If this is omitted, then the function\n\t *      will be called with a single param pointing to this tween.\n\t * @param {Object} [scope]. The scope to call the function in. If omitted, it will be called in the target's\n\t *      scope.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t */\n\tp.call = function(callback, params, scope) {\n\t\treturn this._addAction({f:callback, p:params ? params : [this], o:scope ? scope : this._target});\n\t};\n\n\t// TODO: add clarification between this and a 0 duration .to:\n\t/**\n\t * Queues an action to set the specified props on the specified target. If target is null, it will use this tween's\n\t * target.\n\t * <h4>Example</h4>\n\t *\n\t *\t\tmyTween.wait(1000).set({visible:false},foo);\n\t *\n\t * @method set\n\t * @param {Object} props The properties to set (ex. `{visible:false}`).\n\t * @param {Object} [target] The target to set the properties on. If omitted, they will be set on the tween's target.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t */\n\tp.set = function(props, target) {\n\t\treturn this._addAction({f:this._set, o:this, p:[props, target ? target : this._target]});\n\t};\n\n\t/**\n\t * Queues an action to play (unpause) the specified tween. This enables you to sequence multiple tweens.\n\t * <h4>Example</h4>\n\t *\n\t *\t\tmyTween.to({x:100},500).play(otherTween);\n\t *\n\t * @method play\n\t * @param {Tween} tween The tween to play.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t */\n\tp.play = function(tween) {\n\t\tif (!tween) { tween = this; }\n\t\treturn this.call(tween.setPaused, [false], tween);\n\t};\n\n\t/**\n\t * Queues an action to pause the specified tween.\n\t * @method pause\n\t * @param {Tween} tween The tween to pause. If null, it pauses this tween.\n\t * @return {Tween} This tween instance (for chaining calls)\n\t */\n\tp.pause = function(tween) {\n\t\tif (!tween) { tween = this; }\n\t\treturn this.call(tween.setPaused, [true], tween);\n\t};\n\n\t/**\n\t * Advances the tween to a specified position.\n\t * @method setPosition\n\t * @param {Number} value The position to seek to in milliseconds (or ticks if useTicks is true).\n\t * @param {Number} [actionsMode=1] Specifies how actions are handled (ie. call, set, play, pause):\n\t * <ul>\n\t *      <li>{{#crossLink \"Tween/NONE:property\"}}{{/crossLink}} (0) - run no actions.</li>\n\t *      <li>{{#crossLink \"Tween/LOOP:property\"}}{{/crossLink}} (1) - if new position is less than old, then run all\n\t *      actions between old and duration, then all actions between 0 and new.</li>\n\t *      <li>{{#crossLink \"Tween/REVERSE:property\"}}{{/crossLink}} (2) - if new position is less than old, run all\n\t *      actions between them in reverse.</li>\n\t * </ul>\n\t * @return {Boolean} Returns `true` if the tween is complete (ie. the full tween has run & {{#crossLink \"Tween/loop:property\"}}{{/crossLink}}\n\t * is `false`).\n\t */\n\tp.setPosition = function(value, actionsMode) {\n\t\tif (value < 0) { value = 0; }\n\t\tif (actionsMode == null) { actionsMode = 1; }\n\n\t\t// normalize position:\n\t\tvar t = value;\n\t\tvar end = false;\n\t\tif (t >= this.duration) {\n\t\t\tif (this.loop) { t = t%this.duration; }\n\t\t\telse {\n\t\t\t\tt = this.duration;\n\t\t\t\tend = true;\n\t\t\t}\n\t\t}\n\t\tif (t == this._prevPos) { return end; }\n\n\n\t\tvar prevPos = this._prevPos;\n\t\tthis.position = this._prevPos = t; // set this in advance in case an action modifies position.\n\t\tthis._prevPosition = value;\n\n\t\t// handle tweens:\n\t\tif (this._target) {\n\t\t\tif (end) {\n\t\t\t\t// addresses problems with an ending zero length step.\n\t\t\t\tthis._updateTargetProps(null,1);\n\t\t\t} else if (this._steps.length > 0) {\n\t\t\t\t// find our new tween index:\n\t\t\t\tfor (var i=0, l=this._steps.length; i<l; i++) {\n\t\t\t\t\tif (this._steps[i].t > t) { break; }\n\t\t\t\t}\n\t\t\t\tvar step = this._steps[i-1];\n\t\t\t\tthis._updateTargetProps(step,(this._stepPosition = t-step.t)/step.d);\n\t\t\t}\n\t\t}\n\n\t\t// run actions:\n\t\tif (actionsMode != 0 && this._actions.length > 0) {\n\t\t\tif (this._useTicks) {\n\t\t\t\t// only run the actions we landed on.\n\t\t\t\tthis._runActions(t,t);\n\t\t\t} else if (actionsMode == 1 && t<prevPos) {\n\t\t\t\tif (prevPos != this.duration) { this._runActions(prevPos, this.duration); }\n\t\t\t\tthis._runActions(0, t, true);\n\t\t\t} else {\n\t\t\t\tthis._runActions(prevPos, t);\n\t\t\t}\n\t\t}\n\n\t\tif (end) { this.setPaused(true); }\n\n        this.dispatchEvent(\"change\");\n\t\treturn end;\n\t};\n\n\t/**\n\t * Advances this tween by the specified amount of time in milliseconds (or ticks if`useTicks` is `true`).\n\t * This is normally called automatically by the Tween engine (via {{#crossLink \"Tween/tick\"}}{{/crossLink}}), but is\n\t * exposed for advanced uses.\n\t * @method tick\n\t * @param {Number} delta The time to advance in milliseconds (or ticks if `useTicks` is `true`).\n\t */\n\tp.tick = function(delta) {\n\t\tif (this._paused) { return; }\n\t\tthis.setPosition(this._prevPosition+delta);\n\t};\n\n\t/**\n\t * Pauses or plays this tween.\n\t * @method setPaused\n\t * @param {Boolean} [value=true] Indicates whether the tween should be paused (`true`) or played (`false`).\n\t * @return {Tween} This tween instance (for chaining calls)\n\t */\n\tp.setPaused = function(value) {\n\t\tif (this._paused === !!value) { return this; }\n\t\tthis._paused = !!value;\n\t\tTween._register(this, !value);\n\t\treturn this;\n\t};\n\n\t// tiny api (primarily for tool output):\n\tp.w = p.wait;\n\tp.t = p.to;\n\tp.c = p.call;\n\tp.s = p.set;\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t */\n\tp.toString = function() {\n\t\treturn \"[Tween]\";\n\t};\n\n\t/**\n\t * @method clone\n\t * @protected\n\t */\n\tp.clone = function() {\n\t\tthrow(\"Tween can not be cloned.\")\n\t};\n\n// private methods:\n\t/**\n\t * @method _updateTargetProps\n\t * @param {Object} step\n\t * @param {Number} ratio\n\t * @protected\n\t */\n\tp._updateTargetProps = function(step, ratio) {\n\t\tvar p0,p1,v,v0,v1,arr;\n\t\tif (!step && ratio == 1) {\n\t\t\t// GDS: when does this run? Just at the very end? Shouldn't.\n\t\t\tthis.passive = false;\n\t\t\tp0 = p1 = this._curQueueProps;\n\t\t} else {\n\t\t\tthis.passive = !!step.v;\n\t\t\tif (this.passive) { return; } // don't update props.\n\t\t\t// apply ease to ratio.\n\t\t\tif (step.e) { ratio = step.e(ratio,0,1,1); }\n\t\t\tp0 = step.p0;\n\t\t\tp1 = step.p1;\n\t\t}\n\n\t\tfor (var n in this._initQueueProps) {\n\t\t\tif ((v0 = p0[n]) == null) { p0[n] = v0 = this._initQueueProps[n]; }\n\t\t\tif ((v1 = p1[n]) == null) { p1[n] = v1 = v0; }\n\t\t\tif (v0 == v1 || ratio == 0 || ratio == 1 || (typeof(v0) != \"number\")) {\n\t\t\t\t// no interpolation - either at start, end, values don't change, or the value is non-numeric.\n\t\t\t\tv = ratio == 1 ? v1 : v0;\n\t\t\t} else {\n\t\t\t\tv = v0+(v1-v0)*ratio;\n\t\t\t}\n\n\t\t\tvar ignore = false;\n\t\t\tif (arr = Tween._plugins[n]) {\n\t\t\t\tfor (var i=0,l=arr.length;i<l;i++) {\n\t\t\t\t\tvar v2 = arr[i].tween(this, n, v, p0, p1, ratio, !!step&&p0==p1, !step);\n\t\t\t\t\tif (v2 == Tween.IGNORE) { ignore = true; }\n\t\t\t\t\telse { v = v2; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ignore) { this._target[n] = v; }\n\t\t}\n\n\t};\n\n\t/**\n\t * @method _runActions\n\t * @param {Number} startPos\n\t * @param {Number} endPos\n\t * @param {Boolean} includeStart\n\t * @protected\n\t */\n\tp._runActions = function(startPos, endPos, includeStart) {\n\t\tvar sPos = startPos;\n\t\tvar ePos = endPos;\n\t\tvar i = -1;\n\t\tvar j = this._actions.length;\n\t\tvar k = 1;\n\t\tif (startPos > endPos) {\n\t\t\t// running backwards, flip everything:\n\t\t\tsPos = endPos;\n\t\t\tePos = startPos;\n\t\t\ti = j;\n\t\t\tj = k = -1;\n\t\t}\n\t\twhile ((i+=k) != j) {\n\t\t\tvar action = this._actions[i];\n\t\t\tvar pos = action.t;\n\t\t\tif (pos == ePos || (pos > sPos && pos < ePos) || (includeStart && pos == startPos) ) {\n\t\t\t\taction.f.apply(action.o, action.p);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _appendQueueProps\n\t * @param {Object} o\n\t * @protected\n\t */\n\tp._appendQueueProps = function(o) {\n\t\tvar arr,oldValue,i, l, injectProps;\n\t\tfor (var n in o) {\n\t\t\tif (this._initQueueProps[n] === undefined) {\n\t\t\t\toldValue = this._target[n];\n\n\t\t\t\t// init plugins:\n\t\t\t\tif (arr = Tween._plugins[n]) {\n\t\t\t\t\tfor (i=0,l=arr.length;i<l;i++) {\n\t\t\t\t\t\toldValue = arr[i].init(this, n, oldValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._initQueueProps[n] = this._curQueueProps[n] = (oldValue===undefined) ? null : oldValue;\n\t\t\t} else {\n\t\t\t\toldValue = this._curQueueProps[n];\n\t\t\t}\n\t\t}\n\n\t\tfor (var n in o) {\n\t\t\toldValue = this._curQueueProps[n];\n\t\t\tif (arr = Tween._plugins[n]) {\n\t\t\t\tinjectProps = injectProps||{};\n\t\t\t\tfor (i=0, l=arr.length;i<l;i++) {\n\t\t\t\t\t// TODO: remove the check for .step in the next version. It's here for backwards compatibility.\n\t\t\t\t\tif (arr[i].step) { arr[i].step(this, n, oldValue, o[n], injectProps); }\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._curQueueProps[n] = o[n];\n\t\t}\n\t\tif (injectProps) { this._appendQueueProps(injectProps); }\n\t\treturn this._curQueueProps;\n\t};\n\n\t/**\n\t * @method _cloneProps\n\t * @param {Object} props\n\t * @protected\n\t */\n\tp._cloneProps = function(props) {\n\t\tvar o = {};\n\t\tfor (var n in props) {\n\t\t\to[n] = props[n];\n\t\t}\n\t\treturn o;\n\t};\n\n\t/**\n\t * @method _addStep\n\t * @param {Object} o\n\t * @protected\n\t */\n\tp._addStep = function(o) {\n\t\tif (o.d > 0) {\n\t\t\tthis._steps.push(o);\n\t\t\to.t = this.duration;\n\t\t\tthis.duration += o.d;\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method _addAction\n\t * @param {Object} o\n\t * @protected\n\t */\n\tp._addAction = function(o) {\n\t\to.t = this.duration;\n\t\tthis._actions.push(o);\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method _set\n\t * @param {Object} props\n\t * @param {Object} o\n\t * @protected\n\t */\n\tp._set = function(props, o) {\n\t\tfor (var n in props) {\n\t\t\to[n] = props[n];\n\t\t}\n\t};\n\n\tcreatejs.Tween = createjs.promote(Tween, \"EventDispatcher\");\n\n}());\n\n//##############################################################################\n// Timeline.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\t\n\n// constructor\t\n\t/**\n\t * The Timeline class synchronizes multiple tweens and allows them to be controlled as a group. Please note that if a\n\t * timeline is looping, the tweens on it may appear to loop even if the \"loop\" property of the tween is false.\n\t * @class Timeline\n\t * @param {Array} tweens An array of Tweens to add to this timeline. See {{#crossLink \"Timeline/addTween\"}}{{/crossLink}}\n\t * for more info.\n\t * @param {Object} labels An object defining labels for using {{#crossLink \"Timeline/gotoAndPlay\"}}{{/crossLink}}/{{#crossLink \"Timeline/gotoAndStop\"}}{{/crossLink}}.\n\t * See {{#crossLink \"Timeline/setLabels\"}}{{/crossLink}}\n\t * for details.\n\t * @param {Object} props The configuration properties to apply to this tween instance (ex. `{loop:true}`). All properties\n\t * default to false. Supported props are:<UL>\n\t *    <LI> loop: sets the loop property on this tween.</LI>\n\t *    <LI> useTicks: uses ticks for all durations instead of milliseconds.</LI>\n\t *    <LI> ignoreGlobalPause: sets the ignoreGlobalPause property on this tween.</LI>\n\t *    <LI> paused: indicates whether to start the tween paused.</LI>\n\t *    <LI> position: indicates the initial position for this timeline.</LI>\n\t *    <LI> onChange: specifies a listener to add for the {{#crossLink \"Timeline/change:event\"}}{{/crossLink}} event.</LI>\n\t * </UL>\n\t * @extends EventDispatcher\n\t * @constructor\n\t **/\n\tfunction Timeline(tweens, labels, props) {\n\t\tthis.EventDispatcher_constructor();\n\n\t// public properties:\n\t\t/**\n\t\t * Causes this timeline to continue playing when a global pause is active.\n\t\t * @property ignoreGlobalPause\n\t\t * @type Boolean\n\t\t **/\n\t\tthis.ignoreGlobalPause = false;\n\n\t\t/**\n\t\t * The total duration of this timeline in milliseconds (or ticks if `useTicks `is `true`). This value is usually\n\t\t * automatically updated as you modify the timeline. See {{#crossLink \"Timeline/updateDuration\"}}{{/crossLink}}\n\t\t * for more information.\n\t\t * @property duration\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @readonly\n\t\t **/\n\t\tthis.duration = 0;\n\n\t\t/**\n\t\t * If true, the timeline will loop when it reaches the end. Can be set via the props param.\n\t\t * @property loop\n\t\t * @type Boolean\n\t\t **/\n\t\tthis.loop = false;\n\n\t\t/**\n\t\t * The current normalized position of the timeline. This will always be a value between 0 and\n\t\t * {{#crossLink \"Timeline/duration:property\"}}{{/crossLink}}.\n\t\t * Changing this property directly will have no effect.\n\t\t * @property position\n\t\t * @type Object\n\t\t * @readonly\n\t\t **/\n\t\tthis.position = null;\n\n\t\t// private properties:\n\t\t/**\n\t\t * @property _paused\n\t\t * @type Boolean\n\t\t * @protected\n\t\t **/\n\t\tthis._paused = false;\n\n\t\t/**\n\t\t * @property _tweens\n\t\t * @type Array[Tween]\n\t\t * @protected\n\t\t **/\n\t\tthis._tweens = [];\n\n\t\t/**\n\t\t * @property _labels\n\t\t * @type Object\n\t\t * @protected\n\t\t **/\n\t\tthis._labels = null;\n\n\t\t/**\n\t\t * @property _labelList\n\t\t * @type Array[Object]\n\t\t * @protected\n\t\t **/\n\t\tthis._labelList = null;\n\n\t\t/**\n\t\t * @property _prevPosition\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @protected\n\t\t **/\n\t\tthis._prevPosition = 0;\n\n\t\t/**\n\t\t * @property _prevPos\n\t\t * @type Number\n\t\t * @default -1\n\t\t * @protected\n\t\t **/\n\t\tthis._prevPos = -1;\n\n\t\t/**\n\t\t * @property _useTicks\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @protected\n\t\t **/\n\t\tthis._useTicks = false;\n\t\t\n\t\t/**\n\t\t * Indicates whether the timeline is currently registered with Tween.\n\t\t * @property _registered\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis._registered = false;\n\n\n\t\tif (props) {\n\t\t\tthis._useTicks = props.useTicks;\n\t\t\tthis.loop = props.loop;\n\t\t\tthis.ignoreGlobalPause = props.ignoreGlobalPause;\n\t\t\tprops.onChange&&this.addEventListener(\"change\", props.onChange);\n\t\t}\n\t\tif (tweens) { this.addTween.apply(this, tweens); }\n\t\tthis.setLabels(labels);\n\t\tif (props&&props.paused) { this._paused=true; }\n\t\telse { createjs.Tween._register(this,true); }\n\t\tif (props&&props.position!=null) { this.setPosition(props.position, createjs.Tween.NONE); }\n\t\t\n\t};\n\t\n\tvar p = createjs.extend(Timeline, createjs.EventDispatcher);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\t\n// events:\n\t/**\n\t * Called whenever the timeline's position changes.\n\t * @event change\n\t * @since 0.5.0\n\t **/\n\n\n// public methods:\n\t/**\n\t * Adds one or more tweens (or timelines) to this timeline. The tweens will be paused (to remove them from the\n\t * normal ticking system) and managed by this timeline. Adding a tween to multiple timelines will result in\n\t * unexpected behaviour.\n\t * @method addTween\n\t * @param {Tween} ...tween The tween(s) to add. Accepts multiple arguments.\n\t * @return {Tween} The first tween that was passed in.\n\t **/\n\tp.addTween = function(tween) {\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tfor (var i=0; i<l; i++) { this.addTween(arguments[i]); }\n\t\t\treturn arguments[0];\n\t\t} else if (l == 0) { return null; }\n\t\tthis.removeTween(tween);\n\t\tthis._tweens.push(tween);\n\t\ttween.setPaused(true);\n\t\ttween._paused = false;\n\t\ttween._useTicks = this._useTicks;\n\t\tif (tween.duration > this.duration) { this.duration = tween.duration; }\n\t\tif (this._prevPos >= 0) { tween.setPosition(this._prevPos, createjs.Tween.NONE); }\n\t\treturn tween;\n\t};\n\n\t/**\n\t * Removes one or more tweens from this timeline.\n\t * @method removeTween\n\t * @param {Tween} ...tween The tween(s) to remove. Accepts multiple arguments.\n\t * @return Boolean Returns `true` if all of the tweens were successfully removed.\n\t **/\n\tp.removeTween = function(tween) {\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tvar good = true;\n\t\t\tfor (var i=0; i<l; i++) { good = good && this.removeTween(arguments[i]); }\n\t\t\treturn good;\n\t\t} else if (l == 0) { return false; }\n\n\t\tvar tweens = this._tweens;\n\t\tvar i = tweens.length;\n\t\twhile (i--) {\n\t\t\tif (tweens[i] == tween) {\n\t\t\t\ttweens.splice(i, 1);\n\t\t\t\tif (tween.duration >= this.duration) { this.updateDuration(); }\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Adds a label that can be used with {{#crossLink \"Timeline/gotoAndPlay\"}}{{/crossLink}}/{{#crossLink \"Timeline/gotoAndStop\"}}{{/crossLink}}.\n\t * @method addLabel\n\t * @param {String} label The label name.\n\t * @param {Number} position The position this label represents.\n\t **/\n\tp.addLabel = function(label, position) {\n\t\tthis._labels[label] = position;\n\t\tvar list = this._labelList;\n\t\tif (list) {\n\t\t\tfor (var i= 0,l=list.length; i<l; i++) { if (position < list[i].position) { break; } }\n\t\t\tlist.splice(i, 0, {label:label, position:position});\n\t\t}\n\t};\n\n\t/**\n\t * Defines labels for use with gotoAndPlay/Stop. Overwrites any previously set labels.\n\t * @method setLabels\n\t * @param {Object} o An object defining labels for using {{#crossLink \"Timeline/gotoAndPlay\"}}{{/crossLink}}/{{#crossLink \"Timeline/gotoAndStop\"}}{{/crossLink}}\n\t * in the form `{labelName:time}` where time is in milliseconds (or ticks if `useTicks` is `true`).\n\t **/\n\tp.setLabels = function(o) {\n\t\tthis._labels = o ?  o : {};\n\t};\n\n\t/**\n\t * Returns a sorted list of the labels defined on this timeline.\n\t * @method getLabels\n\t * @return {Array[Object]} A sorted array of objects with label and position properties.\n\t **/\n\tp.getLabels = function() {\n\t\tvar list = this._labelList;\n\t\tif (!list) {\n\t\t\tlist = this._labelList = [];\n\t\t\tvar labels = this._labels;\n\t\t\tfor (var n in labels) {\n\t\t\t\tlist.push({label:n, position:labels[n]});\n\t\t\t}\n\t\t\tlist.sort(function (a,b) { return a.position- b.position; });\n\t\t}\n\t\treturn list;\n\t};\n\n\t/**\n\t * Returns the name of the label on or immediately before the current position. For example, given a timeline with\n\t * two labels, \"first\" on frame index 4, and \"second\" on frame 8, getCurrentLabel would return:\n\t * <UL>\n\t * \t\t<LI>null if the current position is 2.</LI>\n\t * \t\t<LI>\"first\" if the current position is 4.</LI>\n\t * \t\t<LI>\"first\" if the current position is 7.</LI>\n\t * \t\t<LI>\"second\" if the current position is 15.</LI>\n\t * </UL>\n\t * @method getCurrentLabel\n\t * @return {String} The name of the current label or null if there is no label\n\t **/\n\tp.getCurrentLabel = function() {\n\t\tvar labels = this.getLabels();\n\t\tvar pos = this.position;\n\t\tvar l = labels.length;\n\t\tif (l) {\n\t\t\tfor (var i = 0; i<l; i++) { if (pos < labels[i].position) { break; } }\n\t\t\treturn (i==0) ? null : labels[i-1].label;\n\t\t}\n\t\treturn null;\n\t};\n\n\t/**\n\t * Unpauses this timeline and jumps to the specified position or label.\n\t * @method gotoAndPlay\n\t * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`)\n\t * or label to jump to.\n\t **/\n\tp.gotoAndPlay = function(positionOrLabel) {\n\t\tthis.setPaused(false);\n\t\tthis._goto(positionOrLabel);\n\t};\n\n\t/**\n\t * Pauses this timeline and jumps to the specified position or label.\n\t * @method gotoAndStop\n\t * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`) or label\n\t * to jump to.\n\t **/\n\tp.gotoAndStop = function(positionOrLabel) {\n\t\tthis.setPaused(true);\n\t\tthis._goto(positionOrLabel);\n\t};\n\n\t/**\n\t * Advances the timeline to the specified position.\n\t * @method setPosition\n\t * @param {Number} value The position to seek to in milliseconds (or ticks if `useTicks` is `true`).\n\t * @param {Number} [actionsMode] parameter specifying how actions are handled. See the Tween {{#crossLink \"Tween/setPosition\"}}{{/crossLink}}\n\t * method for more details.\n\t * @return {Boolean} Returns `true` if the timeline is complete (ie. the full timeline has run & {{#crossLink \"Timeline/loop:property\"}}{{/crossLink}}\n\t * is `false`).\n\t **/\n\tp.setPosition = function(value, actionsMode) {\n\t\tvar t = this._calcPosition(value);\n\t\tvar end = !this.loop && value >= this.duration;\n\t\tif (t == this._prevPos) { return end; }\n\t\tthis._prevPosition = value;\n\t\tthis.position = this._prevPos = t; // in case an action changes the current frame.\n\t\tfor (var i=0, l=this._tweens.length; i<l; i++) {\n\t\t\tthis._tweens[i].setPosition(t, actionsMode);\n\t\t\tif (t != this._prevPos) { return false; } // an action changed this timeline's position.\n\t\t}\n\t\tif (end) { this.setPaused(true); }\n\t\tthis.dispatchEvent(\"change\");\n\t\treturn end;\n\t};\n\n\t/**\n\t * Pauses or plays this timeline.\n\t * @method setPaused\n\t * @param {Boolean} value Indicates whether the tween should be paused (`true`) or played (`false`).\n\t **/\n\tp.setPaused = function(value) {\n\t\tthis._paused = !!value; \n\t\tcreatejs.Tween._register(this, !value);\n\t};\n\n\t/**\n\t * Recalculates the duration of the timeline. The duration is automatically updated when tweens are added or removed,\n\t * but this method is useful if you modify a tween after it was added to the timeline.\n\t * @method updateDuration\n\t **/\n\tp.updateDuration = function() {\n\t\tthis.duration = 0;\n\t\tfor (var i=0,l=this._tweens.length; i<l; i++) {\n\t\t\tvar tween = this._tweens[i];\n\t\t\tif (tween.duration > this.duration) { this.duration = tween.duration; }\n\t\t}\n\t};\n\n\t/**\n\t * Advances this timeline by the specified amount of time in milliseconds (or ticks if `useTicks` is `true`).\n\t * This is normally called automatically by the Tween engine (via the {{#crossLink \"Tween/tick:event\"}}{{/crossLink}}\n\t * event), but is exposed for advanced uses.\n\t * @method tick\n\t * @param {Number} delta The time to advance in milliseconds (or ticks if useTicks is true).\n\t **/\n\tp.tick = function(delta) {\n\t\tthis.setPosition(this._prevPosition+delta);\n\t};\n\n\t/**\n\t * If a numeric position is passed, it is returned unchanged. If a string is passed, the position of the\n\t * corresponding frame label will be returned, or `null` if a matching label is not defined.\n\t * @method resolve\n\t * @param {String|Number} positionOrLabel A numeric position value or label string.\n\t **/\n\tp.resolve = function(positionOrLabel) {\n\t\tvar pos = Number(positionOrLabel);\n\t\tif (isNaN(pos)) { pos = this._labels[positionOrLabel]; }\n\t\treturn pos;\n\t};\n\n\t/**\n\t* Returns a string representation of this object.\n\t* @method toString\n\t* @return {String} a string representation of the instance.\n\t**/\n\tp.toString = function() {\n\t\treturn \"[Timeline]\";\n\t};\n\n\t/**\n\t * @method clone\n\t * @protected\n\t **/\n\tp.clone = function() {\n\t\tthrow(\"Timeline can not be cloned.\")\n\t};\n\n// private methods:\n\t/**\n\t * @method _goto\n\t * @param {String | Number} positionOrLabel\n\t * @protected\n\t **/\n\tp._goto = function(positionOrLabel) {\n\t\tvar pos = this.resolve(positionOrLabel);\n\t\tif (pos != null) { this.setPosition(pos); }\n\t};\n\t\n\t/**\n\t * @method _calcPosition\n\t * @param {Number} value\n\t * @return {Number}\n\t * @protected\n\t **/\n\tp._calcPosition = function(value) {\n\t\tif (value < 0) { return 0; }\n\t\tif (value < this.duration) { return value; }\n\t\treturn this.loop ? value%this.duration : this.duration;\n\t};\n\n\tcreatejs.Timeline = createjs.promote(Timeline, \"EventDispatcher\");\n\n}());\n\n//##############################################################################\n// Ease.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * The Ease class provides a collection of easing functions for use with TweenJS. It does not use the standard 4 param\n\t * easing signature. Instead it uses a single param which indicates the current linear ratio (0 to 1) of the tween.\n\t *\n\t * Most methods on Ease can be passed directly as easing functions:\n\t *\n\t *      Tween.get(target).to({x:100}, 500, Ease.linear);\n\t *\n\t * However, methods beginning with \"get\" will return an easing function based on parameter values:\n\t *\n\t *      Tween.get(target).to({y:200}, 500, Ease.getPowIn(2.2));\n\t *\n\t * Please see the <a href=\"http://www.createjs.com/Demos/TweenJS/Tween_SparkTable\">spark table demo</a> for an\n\t * overview of the different ease types on <a href=\"http://tweenjs.com\">TweenJS.com</a>.\n\t *\n\t * <em>Equations derived from work by Robert Penner.</em>\n\t * @class Ease\n\t * @static\n\t **/\n\tfunction Ease() {\n\t\tthrow \"Ease cannot be instantiated.\";\n\t}\n\n\n// static methods and properties\n\t/**\n\t * @method linear\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.linear = function(t) { return t; };\n\n\t/**\n\t * Identical to linear.\n\t * @method none\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.none = Ease.linear;\n\n\t/**\n\t * Mimics the simple -100 to 100 easing in Flash Pro.\n\t * @method get\n\t * @param {Number} amount A value from -1 (ease in) to 1 (ease out) indicating the strength and direction of the ease.\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.get = function(amount) {\n\t\tif (amount < -1) { amount = -1; }\n\t\tif (amount > 1) { amount = 1; }\n\t\treturn function(t) {\n\t\t\tif (amount==0) { return t; }\n\t\t\tif (amount<0) { return t*(t*-amount+1+amount); }\n\t\t\treturn t*((2-t)*amount+(1-amount));\n\t\t};\n\t};\n\n\t/**\n\t * Configurable exponential ease.\n\t * @method getPowIn\n\t * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getPowIn = function(pow) {\n\t\treturn function(t) {\n\t\t\treturn Math.pow(t,pow);\n\t\t};\n\t};\n\n\t/**\n\t * Configurable exponential ease.\n\t * @method getPowOut\n\t * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getPowOut = function(pow) {\n\t\treturn function(t) {\n\t\t\treturn 1-Math.pow(1-t,pow);\n\t\t};\n\t};\n\n\t/**\n\t * Configurable exponential ease.\n\t * @method getPowInOut\n\t * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getPowInOut = function(pow) {\n\t\treturn function(t) {\n\t\t\tif ((t*=2)<1) return 0.5*Math.pow(t,pow);\n\t\t\treturn 1-0.5*Math.abs(Math.pow(2-t,pow));\n\t\t};\n\t};\n\n\t/**\n\t * @method quadIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quadIn = Ease.getPowIn(2);\n\t/**\n\t * @method quadOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quadOut = Ease.getPowOut(2);\n\t/**\n\t * @method quadInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quadInOut = Ease.getPowInOut(2);\n\n\t/**\n\t * @method cubicIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.cubicIn = Ease.getPowIn(3);\n\t/**\n\t * @method cubicOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.cubicOut = Ease.getPowOut(3);\n\t/**\n\t * @method cubicInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.cubicInOut = Ease.getPowInOut(3);\n\n\t/**\n\t * @method quartIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quartIn = Ease.getPowIn(4);\n\t/**\n\t * @method quartOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quartOut = Ease.getPowOut(4);\n\t/**\n\t * @method quartInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quartInOut = Ease.getPowInOut(4);\n\n\t/**\n\t * @method quintIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quintIn = Ease.getPowIn(5);\n\t/**\n\t * @method quintOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quintOut = Ease.getPowOut(5);\n\t/**\n\t * @method quintInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quintInOut = Ease.getPowInOut(5);\n\n\t/**\n\t * @method sineIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.sineIn = function(t) {\n\t\treturn 1-Math.cos(t*Math.PI/2);\n\t};\n\n\t/**\n\t * @method sineOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.sineOut = function(t) {\n\t\treturn Math.sin(t*Math.PI/2);\n\t};\n\n\t/**\n\t * @method sineInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.sineInOut = function(t) {\n\t\treturn -0.5*(Math.cos(Math.PI*t) - 1);\n\t};\n\n\t/**\n\t * Configurable \"back in\" ease.\n\t * @method getBackIn\n\t * @param {Number} amount The strength of the ease.\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getBackIn = function(amount) {\n\t\treturn function(t) {\n\t\t\treturn t*t*((amount+1)*t-amount);\n\t\t};\n\t};\n\t/**\n\t * @method backIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.backIn = Ease.getBackIn(1.7);\n\n\t/**\n\t * Configurable \"back out\" ease.\n\t * @method getBackOut\n\t * @param {Number} amount The strength of the ease.\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getBackOut = function(amount) {\n\t\treturn function(t) {\n\t\t\treturn (--t*t*((amount+1)*t + amount) + 1);\n\t\t};\n\t};\n\t/**\n\t * @method backOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.backOut = Ease.getBackOut(1.7);\n\n\t/**\n\t * Configurable \"back in out\" ease.\n\t * @method getBackInOut\n\t * @param {Number} amount The strength of the ease.\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getBackInOut = function(amount) {\n\t\tamount*=1.525;\n\t\treturn function(t) {\n\t\t\tif ((t*=2)<1) return 0.5*(t*t*((amount+1)*t-amount));\n\t\t\treturn 0.5*((t-=2)*t*((amount+1)*t+amount)+2);\n\t\t};\n\t};\n\t/**\n\t * @method backInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.backInOut = Ease.getBackInOut(1.7);\n\n\t/**\n\t * @method circIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.circIn = function(t) {\n\t\treturn -(Math.sqrt(1-t*t)- 1);\n\t};\n\n\t/**\n\t * @method circOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.circOut = function(t) {\n\t\treturn Math.sqrt(1-(--t)*t);\n\t};\n\n\t/**\n\t * @method circInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.circInOut = function(t) {\n\t\tif ((t*=2) < 1) return -0.5*(Math.sqrt(1-t*t)-1);\n\t\treturn 0.5*(Math.sqrt(1-(t-=2)*t)+1);\n\t};\n\n\t/**\n\t * @method bounceIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.bounceIn = function(t) {\n\t\treturn 1-Ease.bounceOut(1-t);\n\t};\n\n\t/**\n\t * @method bounceOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.bounceOut = function(t) {\n\t\tif (t < 1/2.75) {\n\t\t\treturn (7.5625*t*t);\n\t\t} else if (t < 2/2.75) {\n\t\t\treturn (7.5625*(t-=1.5/2.75)*t+0.75);\n\t\t} else if (t < 2.5/2.75) {\n\t\t\treturn (7.5625*(t-=2.25/2.75)*t+0.9375);\n\t\t} else {\n\t\t\treturn (7.5625*(t-=2.625/2.75)*t +0.984375);\n\t\t}\n\t};\n\n\t/**\n\t * @method bounceInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.bounceInOut = function(t) {\n\t\tif (t<0.5) return Ease.bounceIn (t*2) * .5;\n\t\treturn Ease.bounceOut(t*2-1)*0.5+0.5;\n\t};\n\n\t/**\n\t * Configurable elastic ease.\n\t * @method getElasticIn\n\t * @param {Number} amplitude\n\t * @param {Number} period\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getElasticIn = function(amplitude,period) {\n\t\tvar pi2 = Math.PI*2;\n\t\treturn function(t) {\n\t\t\tif (t==0 || t==1) return t;\n\t\t\tvar s = period/pi2*Math.asin(1/amplitude);\n\t\t\treturn -(amplitude*Math.pow(2,10*(t-=1))*Math.sin((t-s)*pi2/period));\n\t\t};\n\t};\n\t/**\n\t * @method elasticIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.elasticIn = Ease.getElasticIn(1,0.3);\n\n\t/**\n\t * Configurable elastic ease.\n\t * @method getElasticOut\n\t * @param {Number} amplitude\n\t * @param {Number} period\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getElasticOut = function(amplitude,period) {\n\t\tvar pi2 = Math.PI*2;\n\t\treturn function(t) {\n\t\t\tif (t==0 || t==1) return t;\n\t\t\tvar s = period/pi2 * Math.asin(1/amplitude);\n\t\t\treturn (amplitude*Math.pow(2,-10*t)*Math.sin((t-s)*pi2/period )+1);\n\t\t};\n\t};\n\t/**\n\t * @method elasticOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.elasticOut = Ease.getElasticOut(1,0.3);\n\n\t/**\n\t * Configurable elastic ease.\n\t * @method getElasticInOut\n\t * @param {Number} amplitude\n\t * @param {Number} period\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getElasticInOut = function(amplitude,period) {\n\t\tvar pi2 = Math.PI*2;\n\t\treturn function(t) {\n\t\t\tvar s = period/pi2 * Math.asin(1/amplitude);\n\t\t\tif ((t*=2)<1) return -0.5*(amplitude*Math.pow(2,10*(t-=1))*Math.sin( (t-s)*pi2/period ));\n\t\t\treturn amplitude*Math.pow(2,-10*(t-=1))*Math.sin((t-s)*pi2/period)*0.5+1;\n\t\t};\n\t};\n\t/**\n\t * @method elasticInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.elasticInOut = Ease.getElasticInOut(1,0.3*1.5);\n\n\tcreatejs.Ease = Ease;\n\n}());\n\n//##############################################################################\n// MotionGuidePlugin.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * A TweenJS plugin for working with motion guides.\n\t *\n\t * To use, install the plugin after TweenJS has loaded. Next tween the 'guide' property with an object as detailed below.\n\t *\n\t *       createjs.MotionGuidePlugin.install();\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      // Using a Motion Guide\n\t *\t    createjs.Tween.get(target).to({guide:{ path:[0,0, 0,200,200,200, 200,0,0,0] }},7000);\n\t *\t    // Visualizing the line\n\t *\t    graphics.moveTo(0,0).curveTo(0,200,200,200).curveTo(200,0,0,0);\n\t *\n\t * Each path needs pre-computation to ensure there's fast performance. Because of the pre-computation there's no\n\t * built in support for path changes mid tween. These are the Guide Object's properties:<UL>\n\t *      <LI> path: Required, Array : The x/y points used to draw the path with a moveTo and 1 to n curveTo calls.</LI>\n\t *      <LI> start: Optional, 0-1 : Initial position, default 0 except for when continuing along the same path.</LI>\n\t *      <LI> end: Optional, 0-1 : Final position, default 1 if not specified.</LI>\n\t *      <LI> orient: Optional, string : \"fixed\"/\"auto\"/\"cw\"/\"ccw\"<UL>\n\t *\t\t\t\t<LI>\"fixed\" forces the object to face down the path all movement (relative to start rotation),</LI>\n\t *      \t\t<LI>\"auto\" rotates the object along the path relative to the line.</LI>\n\t *      \t\t<LI>\"cw\"/\"ccw\" force clockwise or counter clockwise rotations including flash like behaviour</LI>\n\t * \t\t</UL></LI>\n\t * </UL>\n\t * Guide objects should not be shared between tweens even if all properties are identical, the library stores\n\t * information on these objects in the background and sharing them can cause unexpected behaviour. Values\n\t * outside 0-1 range of tweens will be a \"best guess\" from the appropriate part of the defined curve.\n\t *\n\t * @class MotionGuidePlugin\n\t * @constructor\n\t **/\n\tfunction MotionGuidePlugin() {\n\t\tthrow(\"MotionGuidePlugin cannot be instantiated.\")\n\t};\n\n\n// static properties:\n\t/**\n\t * @property priority\n\t * @protected\n\t * @static\n\t **/\n\tMotionGuidePlugin.priority = 0; // high priority, should run sooner\n\n\t/**\n\t * @property temporary variable storage\n\t * @private\n\t * @static\n\t */\n\tMotionGuidePlugin._rotOffS;\n\t/**\n\t * @property temporary variable storage\n\t * @private\n\t * @static\n\t */\n\tMotionGuidePlugin._rotOffE;\n\t/**\n\t * @property temporary variable storage\n\t * @private\n\t * @static\n\t */\n\tMotionGuidePlugin._rotNormS;\n\t/**\n\t * @property temporary variable storage\n\t * @private\n\t * @static\n\t */\n\tMotionGuidePlugin._rotNormE;\n\n\n// static methods\n\t/**\n\t * Installs this plugin for use with TweenJS. Call this once after TweenJS is loaded to enable this plugin.\n\t * @method install\n\t * @static\n\t **/\n\tMotionGuidePlugin.install = function() {\n\t\tcreatejs.Tween.installPlugin(MotionGuidePlugin, [\"guide\", \"x\", \"y\", \"rotation\"]);\n\t\treturn createjs.Tween.IGNORE;\n\t};\n\n\t/**\n\t * @method init\n\t * @protected\n\t * @static\n\t **/\n\tMotionGuidePlugin.init = function(tween, prop, value) {\n\t\tvar target = tween.target;\n\t\tif(!target.hasOwnProperty(\"x\")){ target.x = 0; }\n\t\tif(!target.hasOwnProperty(\"y\")){ target.y = 0; }\n\t\tif(!target.hasOwnProperty(\"rotation\")){ target.rotation = 0; }\n\n\t\tif(prop==\"rotation\"){ tween.__needsRot = true; }\n\t\treturn prop==\"guide\"?null:value;\n\t};\n\n\t/**\n\t * @method step\n\t * @protected\n\t * @static\n\t **/\n\tMotionGuidePlugin.step = function(tween, prop, startValue, endValue, injectProps) {\n\t\t// other props\n\t\tif(prop == \"rotation\"){\n\t\t\ttween.__rotGlobalS = startValue;\n\t\t\ttween.__rotGlobalE = endValue;\n\t\t\tMotionGuidePlugin.testRotData(tween, injectProps);\n\t\t}\n\t\tif(prop != \"guide\"){ return endValue; }\n\n\t\t// guide only information - Start -\n\t\tvar temp, data = endValue;\n\t\tif(!data.hasOwnProperty(\"path\")){ data.path = []; }\n\t\tvar path = data.path;\n\t\tif(!data.hasOwnProperty(\"end\")){ data.end = 1; }\n\t\tif(!data.hasOwnProperty(\"start\")){\n\t\t\tdata.start = (startValue&&startValue.hasOwnProperty(\"end\")&&startValue.path===path)?startValue.end:0;\n\t\t}\n\n\t\t// Figure out subline information\n\t\tif(data.hasOwnProperty(\"_segments\") && data._length){ return endValue; }\n\t\tvar l = path.length;\n\t\tvar accuracy = 10;\t\t// Adjust to improve line following precision but sacrifice performance (# of seg)\n\t\tif(l >= 6 && (l-2) % 4 == 0){\t// Enough points && contains correct number per entry ignoring start\n\t\t\tdata._segments = [];\n\t\t\tdata._length = 0;\n\t\t\tfor(var i=2; i<l; i+=4){\n\t\t\t\tvar sx = path[i-2], sy = path[i-1];\n\t\t\t\tvar cx = path[i+0], cy = path[i+1];\n\t\t\t\tvar ex = path[i+2], ey = path[i+3];\n\t\t\t\tvar oldX = sx, oldY = sy;\n\t\t\t\tvar tempX, tempY, total = 0;\n\t\t\t\tvar sublines = [];\n\t\t\t\tfor(var j=1; j<=accuracy; j++){\n\t\t\t\t\tvar t = j/accuracy;\n\t\t\t\t\tvar inv = 1 - t;\n\t\t\t\t\ttempX = inv*inv * sx + 2 * inv * t * cx + t*t * ex;\n\t\t\t\t\ttempY = inv*inv * sy + 2 * inv * t * cy + t*t * ey;\n\t\t\t\t\ttotal += sublines[sublines.push(Math.sqrt((temp=tempX-oldX)*temp + (temp=tempY-oldY)*temp))-1];\n\t\t\t\t\toldX = tempX;\n\t\t\t\t\toldY = tempY;\n\t\t\t\t}\n\t\t\t\tdata._segments.push(total);\n\t\t\t\tdata._segments.push(sublines);\n\t\t\t\tdata._length += total;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow(\"invalid 'path' data, please see documentation for valid paths\");\n\t\t}\n\n\t\t// Setup x/y tweens\n\t\ttemp = data.orient;\n\t\tdata.orient = true;\n\t\tvar o = {};\n\t\tMotionGuidePlugin.calc(data, data.start, o);\n\t\ttween.__rotPathS = Number(o.rotation.toFixed(5));\n\t\tMotionGuidePlugin.calc(data, data.end, o);\n\t\ttween.__rotPathE = Number(o.rotation.toFixed(5));\n\t\tdata.orient = false;\t//here and now we don't know if we need to\n\t\tMotionGuidePlugin.calc(data, data.end, injectProps);\n\t\tdata.orient = temp;\n\n\t\t// Setup rotation properties\n\t\tif(!data.orient){ return endValue; }\n\t\ttween.__guideData = data;\n\t\tMotionGuidePlugin.testRotData(tween, injectProps);\n\t\treturn endValue;\n\t};\n\n\t/**\n\t * @method testRotData\n\t * @protected\n\t * @static\n\t **/\n\tMotionGuidePlugin.testRotData = function(tween, injectProps){\n\n\t\t// no rotation informat? if we need it come back, if we don't use 0 & ensure we have guide data\n\t\tif(tween.__rotGlobalS === undefined || tween.__rotGlobalE === undefined){\n\t\t\tif(tween.__needsRot){ return; }\n\t\t\tif(tween._curQueueProps.rotation !== undefined){\n\t\t\t\ttween.__rotGlobalS = tween.__rotGlobalE = tween._curQueueProps.rotation;\n\t\t\t} else {\n\t\t\t\ttween.__rotGlobalS = tween.__rotGlobalE = injectProps.rotation = tween.target.rotation || 0;\n\t\t\t}\n\t\t}\n\t\tif(tween.__guideData === undefined){ return; }\n\n\t\t// Process rotation properties\n\t\tvar data = tween.__guideData;\n\t\tvar rotGlobalD = tween.__rotGlobalE - tween.__rotGlobalS;\n\t\tvar rotPathD = tween.__rotPathE - tween.__rotPathS;\n\t\tvar rot = rotGlobalD - rotPathD;\n\n\t\tif(data.orient == \"auto\"){\n\t\t\tif(rot > 180){\t\t\trot -= 360; }\n\t\t\telse if(rot < -180){\trot += 360; }\n\n\t\t} else if(data.orient == \"cw\"){\n\t\t\twhile(rot < 0){ rot += 360; }\n\t\t\tif(rot == 0 && rotGlobalD > 0 && rotGlobalD != 180){ rot += 360; }\n\n\t\t} else if(data.orient == \"ccw\"){\n\t\t\trot = rotGlobalD - ((rotPathD > 180)?(360-rotPathD):(rotPathD));\t// sign flipping on path\n\t\t\twhile(rot > 0){ rot -= 360; }\n\t\t\tif(rot == 0 && rotGlobalD < 0 && rotGlobalD != -180){ rot -= 360; }\n\t\t}\n\n\t\tdata.rotDelta = rot;\n\t\tdata.rotOffS = tween.__rotGlobalS - tween.__rotPathS;\n\n\t\t// reset\n\t\ttween.__rotGlobalS = tween.__rotGlobalE = tween.__guideData = tween.__needsRot = undefined;\n\t};\n\n\t/**\n\t * @method tween\n\t * @protected\n\t * @static\n\t **/\n\tMotionGuidePlugin.tween = function(tween, prop, value, startValues, endValues, ratio, wait, end) {\n\t\tvar data = endValues.guide;\n\t\tif(data == undefined || data === startValues.guide){ return value; }\n\t\tif(data.lastRatio != ratio){\n\t\t\t// first time through so calculate what I need to\n\t\t\tvar t = ((data.end-data.start)*(wait?data.end:ratio)+data.start);\n\t\t\tMotionGuidePlugin.calc(data, t, tween.target);\n\t\t\tswitch(data.orient){\n\t\t\t\tcase \"cw\":\t\t// mix in the original rotation\n\t\t\t\tcase \"ccw\":\n\t\t\t\tcase \"auto\": tween.target.rotation += data.rotOffS + data.rotDelta*ratio; break;\n\t\t\t\tcase \"fixed\":\t// follow fixed behaviour to solve potential issues\n\t\t\t\tdefault: tween.target.rotation += data.rotOffS; break;\n\t\t\t}\n\t\t\tdata.lastRatio = ratio;\n\t\t}\n\t\tif(prop == \"rotation\" && ((!data.orient) || data.orient == \"false\")){ return value; }\n\t\treturn tween.target[prop];\n\t};\n\n\t/**\n\t * Determine the appropriate x/y/rotation information about a path for a given ratio along the path.\n\t * Assumes a path object with all optional parameters specified.\n\t * @param data Data object you would pass to the \"guide:\" property in a Tween\n\t * @param ratio 0-1 Distance along path, values outside 0-1 are \"best guess\"\n\t * @param target Object to copy the results onto, will use a new object if not supplied.\n\t * @return {Object} The target object or a new object w/ the tweened properties\n\t * @static\n\t */\n\tMotionGuidePlugin.calc = function(data, ratio, target) {\n\t\tif(data._segments == undefined){ throw(\"Missing critical pre-calculated information, please file a bug\"); }\n\t\tif(target == undefined){ target = {x:0, y:0, rotation:0}; }\n\t\tvar seg = data._segments;\n\t\tvar path = data.path;\n\n\t\t// find segment\n\t\tvar pos = data._length * ratio;\n\t\tvar cap = seg.length - 2;\n\t\tvar n = 0;\n\t\twhile(pos > seg[n] && n < cap){\n\t\t\tpos -= seg[n];\n\t\t\tn+=2;\n\t\t}\n\n\t\t// find subline\n\t\tvar sublines = seg[n+1];\n\t\tvar i = 0;\n\t\tcap = sublines.length-1;\n\t\twhile(pos > sublines[i] && i < cap){\n\t\t\tpos -= sublines[i];\n\t\t\ti++;\n\t\t}\n\t\tvar t = (i/++cap)+(pos/(cap*sublines[i]));\n\n\t\t// find x/y\n\t\tn = (n*2)+2;\n\t\tvar inv = 1 - t;\n\t\ttarget.x = inv*inv * path[n-2] + 2 * inv * t * path[n+0] + t*t * path[n+2];\n\t\ttarget.y = inv*inv * path[n-1] + 2 * inv * t * path[n+1] + t*t * path[n+3];\n\n\t\t// orientation\n\t\tif(data.orient){\n\t\t\ttarget.rotation = 57.2957795 * Math.atan2(\n\t\t\t\t(path[n+1]-path[n-1])*inv + (path[n+3]-path[n+1])*t,\n\t\t\t\t(path[n+0]-path[n-2])*inv + (path[n+2]-path[n+0])*t);\n\t\t}\n\n\t\treturn target;\n\t};\n\n\tcreatejs.MotionGuidePlugin = MotionGuidePlugin;\n\n}());\n\n//##############################################################################\n// version.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * Static class holding library specific information such as the version and buildDate of\n\t * the library.\n\t * @class TweenJS\n\t **/\n\tvar s = createjs.TweenJS = createjs.TweenJS || {};\n\n\t/**\n\t * The version string for this release.\n\t * @property version\n\t * @type String\n\t * @static\n\t **/\n\ts.version = /*=version*/\"0.6.2\"; // injected by build process\n\n\t/**\n\t * The build date for this release in UTC format.\n\t * @property buildDate\n\t * @type String\n\t * @static\n\t **/\n\ts.buildDate = /*=date*/\"Thu, 26 Nov 2015 20:44:31 GMT\"; // injected by build process\n\n})();\nif( true && typeof module.exports !== \"undefined\") module.exports = this.createjs;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ \"YuTi\")(module), __webpack_require__(/*! ./../webpack/buildin/global.js */ \"yLpj\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiWldsSy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jcmVhdGVqcy1tb2R1bGUvY3JlYXRlanMuanM/NjU2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY3JlYXRlanMgPSAodGhpcy5jcmVhdGVqcyA9ICh0aGlzLmNyZWF0ZWpzIHx8IHt9KSk7XG4vKiFcbiogQ3JlYXRlSlNcbiogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgZ3NraW5uZXIuY29tLCBpbmMuXG4qXG4qIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4qIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4qIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4qIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4qIGNvbmRpdGlvbnM6XG4qXG4qIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4qIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuKlxuKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4qIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4qIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gZXh0ZW5kLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4vKipcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuXG4vKipcbiAqIFNldHMgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiBhbmQgY29uc3RydWN0b3IgcHJvcGVydHkgZm9yIGEgbmV3IGNsYXNzLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCByaWdodCBhZnRlciBjcmVhdGluZyB0aGUgY2xhc3MgY29uc3RydWN0b3IuXG4gKlxuICogXHRmdW5jdGlvbiBNeVN1YkNsYXNzKCkge31cbiAqIFx0Y3JlYXRlanMuZXh0ZW5kKE15U3ViQ2xhc3MsIE15U3VwZXJDbGFzcyk7XG4gKiBcdE15U3ViQ2xhc3MucHJvdG90eXBlLmRvU29tZXRoaW5nID0gZnVuY3Rpb24oKSB7IH1cbiAqXG4gKiBcdHZhciBmb28gPSBuZXcgTXlTdWJDbGFzcygpO1xuICogXHRjb25zb2xlLmxvZyhmb28gaW5zdGFuY2VvZiBNeVN1cGVyQ2xhc3MpOyAvLyB0cnVlXG4gKiBcdGNvbnNvbGUubG9nKGZvby5wcm90b3R5cGUuY29uc3RydWN0b3IgPT09IE15U3ViQ2xhc3MpOyAvLyB0cnVlXG4gKlxuICogQG1ldGhvZCBleHRlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YmNsYXNzIFRoZSBzdWJjbGFzcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cGVyY2xhc3MgVGhlIHN1cGVyY2xhc3MgdG8gZXh0ZW5kLlxuICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgdGhlIHN1YmNsYXNzJ3MgbmV3IHByb3RvdHlwZS5cbiAqL1xuY3JlYXRlanMuZXh0ZW5kID0gZnVuY3Rpb24oc3ViY2xhc3MsIHN1cGVyY2xhc3MpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0ZnVuY3Rpb24gbygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IHN1YmNsYXNzOyB9XG5cdG8ucHJvdG90eXBlID0gc3VwZXJjbGFzcy5wcm90b3R5cGU7XG5cdHJldHVybiAoc3ViY2xhc3MucHJvdG90eXBlID0gbmV3IG8oKSk7XG59O1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gcHJvbW90ZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuLyoqXG4gKiBAY2xhc3MgVXRpbGl0eSBNZXRob2RzXG4gKi9cblxuLyoqXG4gKiBQcm9tb3RlcyBhbnkgbWV0aG9kcyBvbiB0aGUgc3VwZXIgY2xhc3MgdGhhdCB3ZXJlIG92ZXJyaWRkZW4sIGJ5IGNyZWF0aW5nIGFuIGFsaWFzIGluIHRoZSBmb3JtYXQgYHByZWZpeF9tZXRob2ROYW1lYC5cbiAqIEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGUgc3VwZXIgY2xhc3MncyBuYW1lIGFzIHRoZSBwcmVmaXguXG4gKiBBbiBhbGlhcyB0byB0aGUgc3VwZXIgY2xhc3MncyBjb25zdHJ1Y3RvciBpcyBhbHdheXMgYWRkZWQgaW4gdGhlIGZvcm1hdCBgcHJlZml4X2NvbnN0cnVjdG9yYC5cbiAqIFRoaXMgYWxsb3dzIHRoZSBzdWJjbGFzcyB0byBjYWxsIHN1cGVyIGNsYXNzIG1ldGhvZHMgd2l0aG91dCB1c2luZyBgZnVuY3Rpb24uY2FsbGAsIHByb3ZpZGluZyBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIGBNeVN1YkNsYXNzYCBleHRlbmRzIGBNeVN1cGVyQ2xhc3NgLCBhbmQgYm90aCBkZWZpbmUgYSBgZHJhd2AgbWV0aG9kLCB0aGVuIGNhbGxpbmcgYHByb21vdGUoTXlTdWJDbGFzcywgXCJNeVN1cGVyQ2xhc3NcIilgXG4gKiB3b3VsZCBhZGQgYSBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYCBtZXRob2QgdG8gTXlTdWJDbGFzcyBhbmQgcHJvbW90ZSB0aGUgYGRyYXdgIG1ldGhvZCBvbiBgTXlTdXBlckNsYXNzYCB0byB0aGVcbiAqIHByb3RvdHlwZSBvZiBgTXlTdWJDbGFzc2AgYXMgYE15U3VwZXJDbGFzc19kcmF3YC5cbiAqXG4gKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGNsYXNzJ3MgcHJvdG90eXBlIGlzIGZ1bGx5IGRlZmluZWQuXG4gKlxuICogXHRmdW5jdGlvbiBDbGFzc0EobmFtZSkge1xuICogXHRcdHRoaXMubmFtZSA9IG5hbWU7XG4gKiBcdH1cbiAqIFx0Q2xhc3NBLnByb3RvdHlwZS5ncmVldCA9IGZ1bmN0aW9uKCkge1xuICogXHRcdHJldHVybiBcIkhlbGxvIFwiK3RoaXMubmFtZTtcbiAqIFx0fVxuICpcbiAqIFx0ZnVuY3Rpb24gQ2xhc3NCKG5hbWUsIHB1bmN0dWF0aW9uKSB7XG4gKiBcdFx0dGhpcy5DbGFzc0FfY29uc3RydWN0b3IobmFtZSk7XG4gKiBcdFx0dGhpcy5wdW5jdHVhdGlvbiA9IHB1bmN0dWF0aW9uO1xuICogXHR9XG4gKiBcdGNyZWF0ZWpzLmV4dGVuZChDbGFzc0IsIENsYXNzQSk7XG4gKiBcdENsYXNzQi5wcm90b3R5cGUuZ3JlZXQgPSBmdW5jdGlvbigpIHtcbiAqIFx0XHRyZXR1cm4gdGhpcy5DbGFzc0FfZ3JlZXQoKSt0aGlzLnB1bmN0dWF0aW9uO1xuICogXHR9XG4gKiBcdGNyZWF0ZWpzLnByb21vdGUoQ2xhc3NCLCBcIkNsYXNzQVwiKTtcbiAqXG4gKiBcdHZhciBmb28gPSBuZXcgQ2xhc3NCKFwiV29ybGRcIiwgXCIhPyFcIik7XG4gKiBcdGNvbnNvbGUubG9nKGZvby5ncmVldCgpKTsgLy8gSGVsbG8gV29ybGQhPyFcbiAqXG4gKiBAbWV0aG9kIHByb21vdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YmNsYXNzIFRoZSBjbGFzcyB0byBwcm9tb3RlIHN1cGVyIGNsYXNzIG1ldGhvZHMgb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IFRoZSBwcmVmaXggdG8gYWRkIHRvIHRoZSBwcm9tb3RlZCBtZXRob2QgbmFtZXMuIFVzdWFsbHkgdGhlIG5hbWUgb2YgdGhlIHN1cGVyY2xhc3MuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgc3ViY2xhc3MuXG4gKi9cbmNyZWF0ZWpzLnByb21vdGUgPSBmdW5jdGlvbihzdWJjbGFzcywgcHJlZml4KSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZhciBzdWJQID0gc3ViY2xhc3MucHJvdG90eXBlLCBzdXBQID0gKE9iamVjdC5nZXRQcm90b3R5cGVPZiYmT2JqZWN0LmdldFByb3RvdHlwZU9mKHN1YlApKXx8c3ViUC5fX3Byb3RvX187XG5cdGlmIChzdXBQKSB7XG5cdFx0c3ViUFsocHJlZml4Kz1cIl9cIikgKyBcImNvbnN0cnVjdG9yXCJdID0gc3VwUC5jb25zdHJ1Y3RvcjsgLy8gY29uc3RydWN0b3IgaXMgbm90IGFsd2F5cyBpbm51bWVyYWJsZVxuXHRcdGZvciAodmFyIG4gaW4gc3VwUCkge1xuXHRcdFx0aWYgKHN1YlAuaGFzT3duUHJvcGVydHkobikgJiYgKHR5cGVvZiBzdXBQW25dID09IFwiZnVuY3Rpb25cIikpIHsgc3ViUFtwcmVmaXggKyBuXSA9IHN1cFBbbl07IH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHN1YmNsYXNzO1xufTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIGluZGV4T2YuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbi8qKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBzcGVjaWZpZWQgdmFsdWUgc2VhcmNoRWxlbWVudCBpbiB0aGUgcGFzc2VkIGluIGFycmF5LCBhbmQgcmV0dXJucyB0aGUgaW5kZXggb2ZcbiAqIHRoYXQgdmFsdWUuICBSZXR1cm5zIC0xIGlmIHZhbHVlIGlzIG5vdCBmb3VuZC5cbiAqXG4gKiAgICAgIHZhciBpID0gY3JlYXRlanMuaW5kZXhPZihteUFycmF5LCBteUVsZW1lbnRUb0ZpbmQpO1xuICpcbiAqIEBtZXRob2QgaW5kZXhPZlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgQXJyYXkgdG8gc2VhcmNoIGZvciBzZWFyY2hFbGVtZW50XG4gKiBAcGFyYW0gc2VhcmNoRWxlbWVudCBFbGVtZW50IHRvIGZpbmQgaW4gYXJyYXkuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBmaXJzdCBpbmRleCBvZiBzZWFyY2hFbGVtZW50IGluIGFycmF5LlxuICovXG5jcmVhdGVqcy5pbmRleE9mID0gZnVuY3Rpb24gKGFycmF5LCBzZWFyY2hFbGVtZW50KXtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Zm9yICh2YXIgaSA9IDAsbD1hcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRpZiAoc2VhcmNoRWxlbWVudCA9PT0gYXJyYXlbaV0pIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59O1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRXZlbnQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQ29udGFpbnMgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBzaGFyZWQgYnkgYWxsIGV2ZW50cyBmb3IgdXNlIHdpdGhcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBcblx0ICogTm90ZSB0aGF0IEV2ZW50IG9iamVjdHMgYXJlIG9mdGVuIHJldXNlZCwgc28geW91IHNob3VsZCBuZXZlclxuXHQgKiByZWx5IG9uIGFuIGV2ZW50IG9iamVjdCdzIHN0YXRlIG91dHNpZGUgb2YgdGhlIGNhbGwgc3RhY2sgaXQgd2FzIHJlY2VpdmVkIGluLlxuXHQgKiBAY2xhc3MgRXZlbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYnViYmxlcyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZXZlbnQgd2lsbCBidWJibGUgdGhyb3VnaCB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNhbmNlbGFibGUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mIHRoaXMgZXZlbnQgY2FuIGJlIGNhbmNlbGxlZC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gRXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSkge1xuXHRcdFxuXHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IHR5cGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiovXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIG9iamVjdCB0aGF0IGdlbmVyYXRlZCBhbiBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgdGFyZ2V0XG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy50YXJnZXQgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY3VycmVudCB0YXJnZXQgdGhhdCBhIGJ1YmJsaW5nIGV2ZW50IGlzIGJlaW5nIGRpc3BhdGNoZWQgZnJvbS4gRm9yIG5vbi1idWJibGluZyBldmVudHMsIHRoaXMgd2lsbFxuXHRcdCAqIGFsd2F5cyBiZSB0aGUgc2FtZSBhcyB0YXJnZXQuIEZvciBleGFtcGxlLCBpZiBjaGlsZE9iai5wYXJlbnQgPSBwYXJlbnRPYmosIGFuZCBhIGJ1YmJsaW5nIGV2ZW50XG5cdFx0ICogaXMgZ2VuZXJhdGVkIGZyb20gY2hpbGRPYmosIHRoZW4gYSBsaXN0ZW5lciBvbiBwYXJlbnRPYmogd291bGQgcmVjZWl2ZSB0aGUgZXZlbnQgd2l0aFxuXHRcdCAqIHRhcmdldD1jaGlsZE9iaiAodGhlIG9yaWdpbmFsIHRhcmdldCkgYW5kIGN1cnJlbnRUYXJnZXQ9cGFyZW50T2JqICh3aGVyZSB0aGUgbGlzdGVuZXIgd2FzIGFkZGVkKS5cblx0XHQgKiBAcHJvcGVydHkgY3VycmVudFRhcmdldFxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZvciBidWJibGluZyBldmVudHMsIHRoaXMgaW5kaWNhdGVzIHRoZSBjdXJyZW50IGV2ZW50IHBoYXNlOjxPTD5cblx0XHQgKiBcdDxMST4gY2FwdHVyZSBwaGFzZTogc3RhcnRpbmcgZnJvbSB0aGUgdG9wIHBhcmVudCB0byB0aGUgdGFyZ2V0PC9MST5cblx0XHQgKiBcdDxMST4gYXQgdGFyZ2V0IHBoYXNlOiBjdXJyZW50bHkgYmVpbmcgZGlzcGF0Y2hlZCBmcm9tIHRoZSB0YXJnZXQ8L0xJPlxuXHRcdCAqIFx0PExJPiBidWJibGluZyBwaGFzZTogZnJvbSB0aGUgdGFyZ2V0IHRvIHRoZSB0b3AgcGFyZW50PC9MST5cblx0XHQgKiA8L09MPlxuXHRcdCAqIEBwcm9wZXJ0eSBldmVudFBoYXNlXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5ldmVudFBoYXNlID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50IHdpbGwgYnViYmxlIHRocm91Z2ggdGhlIGRpc3BsYXkgbGlzdC5cblx0XHQgKiBAcHJvcGVydHkgYnViYmxlc1xuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5idWJibGVzID0gISFidWJibGVzO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdGhpcyBldmVudCBjYW4gYmUgY2FuY2VsbGVkIHZpYVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50L3ByZXZlbnREZWZhdWx0XCJ9fXt7L2Nyb3NzTGlua319LiBUaGlzIGlzIHNldCB2aWEgdGhlIEV2ZW50IGNvbnN0cnVjdG9yLlxuXHRcdCAqIEBwcm9wZXJ0eSBjYW5jZWxhYmxlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmNhbmNlbGFibGUgPSAhIWNhbmNlbGFibGU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBlcG9jaCB0aW1lIGF0IHdoaWNoIHRoaXMgZXZlbnQgd2FzIGNyZWF0ZWQuXG5cdFx0ICogQHByb3BlcnR5IHRpbWVTdGFtcFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMudGltZVN0YW1wID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHt7I2Nyb3NzTGluayBcIkV2ZW50L3ByZXZlbnREZWZhdWx0XCJ9fXt7L2Nyb3NzTGlua319IGhhcyBiZWVuIGNhbGxlZFxuXHRcdCAqIG9uIHRoaXMgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IGRlZmF1bHRQcmV2ZW50ZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYge3sjY3Jvc3NMaW5rIFwiRXZlbnQvc3RvcFByb3BhZ2F0aW9uXCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXCJ9fXt7L2Nyb3NzTGlua319IGhhcyBiZWVuIGNhbGxlZCBvbiB0aGlzIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBwcm9wYWdhdGlvblN0b3BwZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB7eyNjcm9zc0xpbmsgXCJFdmVudC9zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkXG5cdFx0ICogb24gdGhpcyBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB7eyNjcm9zc0xpbmsgXCJFdmVudC9yZW1vdmVcIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkIG9uIHRoaXMgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IHJlbW92ZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMucmVtb3ZlZCA9IGZhbHNlO1xuXHR9XG5cdHZhciBwID0gRXZlbnQucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBTZXRzIHt7I2Nyb3NzTGluayBcIkV2ZW50L2RlZmF1bHRQcmV2ZW50ZWRcIn19e3svY3Jvc3NMaW5rfX0gdG8gdHJ1ZSBpZiB0aGUgZXZlbnQgaXMgY2FuY2VsYWJsZS5cblx0ICogTWlycm9ycyB0aGUgRE9NIGxldmVsIDIgZXZlbnQgc3RhbmRhcmQuIEluIGdlbmVyYWwsIGNhbmNlbGFibGUgZXZlbnRzIHRoYXQgaGF2ZSBgcHJldmVudERlZmF1bHQoKWAgY2FsbGVkIHdpbGxcblx0ICogY2FuY2VsIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50LlxuXHQgKiBAbWV0aG9kIHByZXZlbnREZWZhdWx0XG5cdCAqKi9cblx0cC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRoaXMuY2FuY2VsYWJsZSYmdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB7eyNjcm9zc0xpbmsgXCJFdmVudC9wcm9wYWdhdGlvblN0b3BwZWRcIn19e3svY3Jvc3NMaW5rfX0gdG8gdHJ1ZS5cblx0ICogTWlycm9ycyB0aGUgRE9NIGV2ZW50IHN0YW5kYXJkLlxuXHQgKiBAbWV0aG9kIHN0b3BQcm9wYWdhdGlvblxuXHQgKiovXG5cdHAuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHt7I2Nyb3NzTGluayBcIkV2ZW50L3Byb3BhZ2F0aW9uU3RvcHBlZFwifX17ey9jcm9zc0xpbmt9fSBhbmRcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkXCJ9fXt7L2Nyb3NzTGlua319IHRvIHRydWUuXG5cdCAqIE1pcnJvcnMgdGhlIERPTSBldmVudCBzdGFuZGFyZC5cblx0ICogQG1ldGhvZCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cblx0ICoqL1xuXHRwLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhdXNlcyB0aGUgYWN0aXZlIGxpc3RlbmVyIHRvIGJlIHJlbW92ZWQgdmlhIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcblx0ICogXG5cdCAqIFx0XHRteUJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZ0KSB7XG5cdCAqIFx0XHRcdC8vIGRvIHN0dWZmLi4uXG5cdCAqIFx0XHRcdGV2dC5yZW1vdmUoKTsgLy8gcmVtb3ZlcyB0aGlzIGxpc3RlbmVyLlxuXHQgKiBcdFx0fSk7XG5cdCAqIFxuXHQgKiBAbWV0aG9kIHJlbW92ZVxuXHQgKiovXG5cdHAucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZW1vdmVkID0gdHJ1ZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIEV2ZW50IGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge0V2ZW50fSBhIGNsb25lIG9mIHRoZSBFdmVudCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBFdmVudCh0aGlzLnR5cGUsIHRoaXMuYnViYmxlcywgdGhpcy5jYW5jZWxhYmxlKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBQcm92aWRlcyBhIGNoYWluYWJsZSBzaG9ydGN1dCBtZXRob2QgZm9yIHNldHRpbmcgYSBudW1iZXIgb2YgcHJvcGVydGllcyBvbiB0aGUgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2Qgc2V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBBIGdlbmVyaWMgb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBjb3B5IHRvIHRoZSBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7RXZlbnR9IFJldHVybnMgdGhlIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLnNldCA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykgeyB0aGlzW25dID0gcHJvcHNbbl07IH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0V2ZW50ICh0eXBlPVwiK3RoaXMudHlwZStcIildXCI7XG5cdH07XG5cblx0Y3JlYXRlanMuRXZlbnQgPSBFdmVudDtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBFdmVudERpc3BhdGNoZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBFdmVudERpc3BhdGNoZXIgcHJvdmlkZXMgbWV0aG9kcyBmb3IgbWFuYWdpbmcgcXVldWVzIG9mIGV2ZW50IGxpc3RlbmVycyBhbmQgZGlzcGF0Y2hpbmcgZXZlbnRzLlxuXHQgKlxuXHQgKiBZb3UgY2FuIGVpdGhlciBleHRlbmQgRXZlbnREaXNwYXRjaGVyIG9yIG1peCBpdHMgbWV0aG9kcyBpbnRvIGFuIGV4aXN0aW5nIHByb3RvdHlwZSBvciBpbnN0YW5jZSBieSB1c2luZyB0aGVcblx0ICogRXZlbnREaXNwYXRjaGVyIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9pbml0aWFsaXplXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cblx0ICogXG5cdCAqIFRvZ2V0aGVyIHdpdGggdGhlIENyZWF0ZUpTIEV2ZW50IGNsYXNzLCBFdmVudERpc3BhdGNoZXIgcHJvdmlkZXMgYW4gZXh0ZW5kZWQgZXZlbnQgbW9kZWwgdGhhdCBpcyBiYXNlZCBvbiB0aGVcblx0ICogRE9NIExldmVsIDIgZXZlbnQgbW9kZWwsIGluY2x1ZGluZyBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyLCBhbmQgZGlzcGF0Y2hFdmVudC4gSXQgc3VwcG9ydHNcblx0ICogYnViYmxpbmcgLyBjYXB0dXJlLCBwcmV2ZW50RGVmYXVsdCwgc3RvcFByb3BhZ2F0aW9uLCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24sIGFuZCBoYW5kbGVFdmVudC5cblx0ICogXG5cdCAqIEV2ZW50RGlzcGF0Y2hlciBhbHNvIGV4cG9zZXMgYSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvb25cIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLCB3aGljaCBtYWtlcyBpdCBlYXNpZXJcblx0ICogdG8gY3JlYXRlIHNjb3BlZCBsaXN0ZW5lcnMsIGxpc3RlbmVycyB0aGF0IG9ubHkgcnVuIG9uY2UsIGFuZCBsaXN0ZW5lcnMgd2l0aCBhc3NvY2lhdGVkIGFyYml0cmFyeSBkYXRhLiBUaGUgXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9vZmZcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGlzIG1lcmVseSBhbiBhbGlhcyB0b1xuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvcmVtb3ZlRXZlbnRMaXN0ZW5lclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogXG5cdCAqIEFub3RoZXIgYWRkaXRpb24gdG8gdGhlIERPTSBMZXZlbCAyIG1vZGVsIGlzIHRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnNcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLCB3aGljaCBjYW4gYmUgdXNlZCB0byBsaXN0ZW5lcnMgZm9yIGFsbCBldmVudHMsIG9yIGxpc3RlbmVycyBmb3IgYSBzcGVjaWZpYyBldmVudC4gVGhlIEV2ZW50IG9iamVjdCBhbHNvIFxuXHQgKiBpbmNsdWRlcyBhIHt7I2Nyb3NzTGluayBcIkV2ZW50L3JlbW92ZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2Qgd2hpY2ggcmVtb3ZlcyB0aGUgYWN0aXZlIGxpc3RlbmVyLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIEFkZCBFdmVudERpc3BhdGNoZXIgY2FwYWJpbGl0aWVzIHRvIHRoZSBcIk15Q2xhc3NcIiBjbGFzcy5cblx0ICpcblx0ICogICAgICBFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShNeUNsYXNzLnByb3RvdHlwZSk7XG5cdCAqXG5cdCAqIEFkZCBhbiBldmVudCAoc2VlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9hZGRFdmVudExpc3RlbmVyXCJ9fXt7L2Nyb3NzTGlua319KS5cblx0ICpcblx0ICogICAgICBpbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKFwiZXZlbnROYW1lXCIsIGhhbmRsZXJNZXRob2QpO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZXJNZXRob2QoZXZlbnQpIHtcblx0ICogICAgICAgICAgY29uc29sZS5sb2coZXZlbnQudGFyZ2V0ICsgXCIgV2FzIENsaWNrZWRcIik7XG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiA8Yj5NYWludGFpbmluZyBwcm9wZXIgc2NvcGU8L2I+PGJyIC8+XG5cdCAqIFNjb3BlIChpZS4gXCJ0aGlzXCIpIGNhbiBiZSBiZSBhIGNoYWxsZW5nZSB3aXRoIGV2ZW50cy4gVXNpbmcgdGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9vblwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QgdG8gc3Vic2NyaWJlIHRvIGV2ZW50cyBzaW1wbGlmaWVzIHRoaXMuXG5cdCAqXG5cdCAqICAgICAgaW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKGluc3RhbmNlID09IHRoaXMpOyAvLyBmYWxzZSwgc2NvcGUgaXMgYW1iaWd1b3VzLlxuXHQgKiAgICAgIH0pO1xuXHQgKiAgICAgIFxuXHQgKiAgICAgIGluc3RhbmNlLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZlbnQpIHtcblx0ICogICAgICAgICAgY29uc29sZS5sb2coaW5zdGFuY2UgPT0gdGhpcyk7IC8vIHRydWUsIFwib25cIiB1c2VzIGRpc3BhdGNoZXIgc2NvcGUgYnkgZGVmYXVsdC5cblx0ICogICAgICB9KTtcblx0ICogXG5cdCAqIElmIHlvdSB3YW50IHRvIHVzZSBhZGRFdmVudExpc3RlbmVyIGluc3RlYWQsIHlvdSBtYXkgd2FudCB0byB1c2UgZnVuY3Rpb24uYmluZCgpIG9yIGEgc2ltaWxhciBwcm94eSB0byBtYW5hZ2Vcblx0ICogc2NvcGUuXG5cdCAqXG5cdCAqIDxiPkJyb3dzZXIgc3VwcG9ydDwvYj5cblx0ICogVGhlIGV2ZW50IG1vZGVsIGluIENyZWF0ZUpTIGNhbiBiZSB1c2VkIHNlcGFyYXRlbHkgZnJvbSB0aGUgc3VpdGUgaW4gYW55IHByb2plY3QsIGhvd2V2ZXIgdGhlIGluaGVyaXRhbmNlIG1vZGVsXG5cdCAqIHJlcXVpcmVzIG1vZGVybiBicm93c2VycyAoSUU5KykuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBjbGFzcyBFdmVudERpc3BhdGNoZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gRXZlbnREaXNwYXRjaGVyKCkge1xuXHRcblx0XG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHByb3BlcnR5IF9saXN0ZW5lcnNcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiovXG5cdFx0dGhpcy5fbGlzdGVuZXJzID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHByb3BlcnR5IF9jYXB0dXJlTGlzdGVuZXJzXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgPSBudWxsO1xuXHR9XG5cdHZhciBwID0gRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblxuLy8gc3RhdGljIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogU3RhdGljIGluaXRpYWxpemVyIHRvIG1peCBFdmVudERpc3BhdGNoZXIgbWV0aG9kcyBpbnRvIGEgdGFyZ2V0IG9iamVjdCBvciBwcm90b3R5cGUuXG5cdCAqIFxuXHQgKiBcdFx0RXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUoTXlDbGFzcy5wcm90b3R5cGUpOyAvLyBhZGQgdG8gdGhlIHByb3RvdHlwZSBvZiB0aGUgY2xhc3Ncblx0ICogXHRcdEV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplKG15T2JqZWN0KTsgLy8gYWRkIHRvIGEgc3BlY2lmaWMgaW5zdGFuY2Vcblx0ICogXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QgdG8gaW5qZWN0IEV2ZW50RGlzcGF0Y2hlciBtZXRob2RzIGludG8uIFRoaXMgY2FuIGJlIGFuIGluc3RhbmNlIG9yIGFcblx0ICogcHJvdG90eXBlLlxuXHQgKiovXG5cdEV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIgPSBwLmFkZEV2ZW50TGlzdGVuZXI7XG5cdFx0dGFyZ2V0Lm9uID0gcC5vbjtcblx0XHR0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHRhcmdldC5vZmYgPSAgcC5yZW1vdmVFdmVudExpc3RlbmVyO1xuXHRcdHRhcmdldC5yZW1vdmVBbGxFdmVudExpc3RlbmVycyA9IHAucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnM7XG5cdFx0dGFyZ2V0Lmhhc0V2ZW50TGlzdGVuZXIgPSBwLmhhc0V2ZW50TGlzdGVuZXI7XG5cdFx0dGFyZ2V0LmRpc3BhdGNoRXZlbnQgPSBwLmRpc3BhdGNoRXZlbnQ7XG5cdFx0dGFyZ2V0Ll9kaXNwYXRjaEV2ZW50ID0gcC5fZGlzcGF0Y2hFdmVudDtcblx0XHR0YXJnZXQud2lsbFRyaWdnZXIgPSBwLndpbGxUcmlnZ2VyO1xuXHR9O1xuXHRcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBzcGVjaWZpZWQgZXZlbnQgbGlzdGVuZXIuIE5vdGUgdGhhdCBhZGRpbmcgbXVsdGlwbGUgbGlzdGVuZXJzIHRvIHRoZSBzYW1lIGZ1bmN0aW9uIHdpbGwgcmVzdWx0IGluXG5cdCAqIG11bHRpcGxlIGNhbGxiYWNrcyBnZXR0aW5nIGZpcmVkLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG5cdCAqICAgICAgICAgLy8gQ2xpY2sgaGFwcGVuZWQuXG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbiB8IE9iamVjdH0gbGlzdGVuZXIgQW4gb2JqZWN0IHdpdGggYSBoYW5kbGVFdmVudCBtZXRob2QsIG9yIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuXG5cdCAqIHRoZSBldmVudCBpcyBkaXNwYXRjaGVkLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9uIHwgT2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0ZW5lciBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cblx0ICoqL1xuXHRwLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuXHRcdHZhciBsaXN0ZW5lcnM7XG5cdFx0aWYgKHVzZUNhcHR1cmUpIHtcblx0XHRcdGxpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgPSB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzfHx7fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzfHx7fTtcblx0XHR9XG5cdFx0dmFyIGFyciA9IGxpc3RlbmVyc1t0eXBlXTtcblx0XHRpZiAoYXJyKSB7IHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7IH1cblx0XHRhcnIgPSBsaXN0ZW5lcnNbdHlwZV07IC8vIHJlbW92ZSBtYXkgaGF2ZSBkZWxldGVkIHRoZSBhcnJheVxuXHRcdGlmICghYXJyKSB7IGxpc3RlbmVyc1t0eXBlXSA9IFtsaXN0ZW5lcl07ICB9XG5cdFx0ZWxzZSB7IGFyci5wdXNoKGxpc3RlbmVyKTsgfVxuXHRcdHJldHVybiBsaXN0ZW5lcjtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBIHNob3J0Y3V0IG1ldGhvZCBmb3IgdXNpbmcgYWRkRXZlbnRMaXN0ZW5lciB0aGF0IG1ha2VzIGl0IGVhc2llciB0byBzcGVjaWZ5IGFuIGV4ZWN1dGlvbiBzY29wZSwgaGF2ZSBhIGxpc3RlbmVyXG5cdCAqIG9ubHkgcnVuIG9uY2UsIGFzc29jaWF0ZSBhcmJpdHJhcnkgZGF0YSB3aXRoIHRoZSBsaXN0ZW5lciwgYW5kIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG5cdCAqIFxuXHQgKiBUaGlzIG1ldGhvZCB3b3JrcyBieSBjcmVhdGluZyBhbiBhbm9ueW1vdXMgd3JhcHBlciBmdW5jdGlvbiBhbmQgc3Vic2NyaWJpbmcgaXQgd2l0aCBhZGRFdmVudExpc3RlbmVyLlxuXHQgKiBUaGUgd3JhcHBlciBmdW5jdGlvbiBpcyByZXR1cm5lZCBmb3IgdXNlIHdpdGggYHJlbW92ZUV2ZW50TGlzdGVuZXJgIChvciBgb2ZmYCkuXG5cdCAqIFxuXHQgKiA8Yj5JTVBPUlRBTlQ6PC9iPiBUbyByZW1vdmUgYSBsaXN0ZW5lciBhZGRlZCB3aXRoIGBvbmAsIHlvdSBtdXN0IHBhc3MgaW4gdGhlIHJldHVybmVkIHdyYXBwZXIgZnVuY3Rpb24gYXMgdGhlIGxpc3RlbmVyLCBvciB1c2Vcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcmVtb3ZlXCJ9fXt7L2Nyb3NzTGlua319LiBMaWtld2lzZSwgZWFjaCB0aW1lIHlvdSBjYWxsIGBvbmAgYSBORVcgd3JhcHBlciBmdW5jdGlvbiBpcyBzdWJzY3JpYmVkLCBzbyBtdWx0aXBsZSBjYWxsc1xuXHQgKiB0byBgb25gIHdpdGggdGhlIHNhbWUgcGFyYW1zIHdpbGwgY3JlYXRlIG11bHRpcGxlIGxpc3RlbmVycy5cblx0ICogXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogXG5cdCAqIFx0XHR2YXIgbGlzdGVuZXIgPSBteUJ0bi5vbihcImNsaWNrXCIsIGhhbmRsZUNsaWNrLCBudWxsLCBmYWxzZSwge2NvdW50OjN9KTtcblx0ICogXHRcdGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2dCwgZGF0YSkge1xuXHQgKiBcdFx0XHRkYXRhLmNvdW50IC09IDE7XG5cdCAqIFx0XHRcdGNvbnNvbGUubG9nKHRoaXMgPT0gbXlCdG4pOyAvLyB0cnVlIC0gc2NvcGUgZGVmYXVsdHMgdG8gdGhlIGRpc3BhdGNoZXJcblx0ICogXHRcdFx0aWYgKGRhdGEuY291bnQgPT0gMCkge1xuXHQgKiBcdFx0XHRcdGFsZXJ0KFwiY2xpY2tlZCAzIHRpbWVzIVwiKTtcblx0ICogXHRcdFx0XHRteUJ0bi5vZmYoXCJjbGlja1wiLCBsaXN0ZW5lcik7XG5cdCAqIFx0XHRcdFx0Ly8gYWx0ZXJuYXRlbHk6IGV2dC5yZW1vdmUoKTtcblx0ICogXHRcdFx0fVxuXHQgKiBcdFx0fVxuXHQgKiBcblx0ICogQG1ldGhvZCBvblxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBBbiBvYmplY3Qgd2l0aCBhIGhhbmRsZUV2ZW50IG1ldGhvZCwgb3IgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5cblx0ICogdGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIFRoZSBzY29wZSB0byBleGVjdXRlIHRoZSBsaXN0ZW5lciBpbi4gRGVmYXVsdHMgdG8gdGhlIGRpc3BhdGNoZXIvY3VycmVudFRhcmdldCBmb3IgZnVuY3Rpb24gbGlzdGVuZXJzLCBhbmQgdG8gdGhlIGxpc3RlbmVyIGl0c2VsZiBmb3Igb2JqZWN0IGxpc3RlbmVycyAoaWUuIHVzaW5nIGhhbmRsZUV2ZW50KS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gSWYgdHJ1ZSwgdGhlIGxpc3RlbmVyIHdpbGwgcmVtb3ZlIGl0c2VsZiBhZnRlciB0aGUgZmlyc3QgdGltZSBpdCBpcyB0cmlnZ2VyZWQuXG5cdCAqIEBwYXJhbSB7Kn0gW2RhdGFdIEFyYml0cmFyeSBkYXRhIHRoYXQgd2lsbCBiZSBpbmNsdWRlZCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciB3aGVuIHRoZSBsaXN0ZW5lciBpcyBjYWxsZWQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmU9ZmFsc2VdIEZvciBldmVudHMgdGhhdCBidWJibGUsIGluZGljYXRlcyB3aGV0aGVyIHRvIGxpc3RlbiBmb3IgdGhlIGV2ZW50IGluIHRoZSBjYXB0dXJlIG9yIGJ1YmJsaW5nL3RhcmdldCBwaGFzZS5cblx0ICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgdGhlIGFub255bW91cyBmdW5jdGlvbiB0aGF0IHdhcyBjcmVhdGVkIGFuZCBhc3NpZ25lZCBhcyB0aGUgbGlzdGVuZXIuIFRoaXMgaXMgbmVlZGVkIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIgbGF0ZXIgdXNpbmcgLnJlbW92ZUV2ZW50TGlzdGVuZXIuXG5cdCAqKi9cblx0cC5vbiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCBzY29wZSwgb25jZSwgZGF0YSwgdXNlQ2FwdHVyZSkge1xuXHRcdGlmIChsaXN0ZW5lci5oYW5kbGVFdmVudCkge1xuXHRcdFx0c2NvcGUgPSBzY29wZXx8bGlzdGVuZXI7XG5cdFx0XHRsaXN0ZW5lciA9IGxpc3RlbmVyLmhhbmRsZUV2ZW50O1xuXHRcdH1cblx0XHRzY29wZSA9IHNjb3BlfHx0aGlzO1xuXHRcdHJldHVybiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZnVuY3Rpb24oZXZ0KSB7XG5cdFx0XHRcdGxpc3RlbmVyLmNhbGwoc2NvcGUsIGV2dCwgZGF0YSk7XG5cdFx0XHRcdG9uY2UmJmV2dC5yZW1vdmUoKTtcblx0XHRcdH0sIHVzZUNhcHR1cmUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgZXZlbnQgbGlzdGVuZXIuXG5cdCAqXG5cdCAqIDxiPkltcG9ydGFudCBOb3RlOjwvYj4gdGhhdCB5b3UgbXVzdCBwYXNzIHRoZSBleGFjdCBmdW5jdGlvbiByZWZlcmVuY2UgdXNlZCB3aGVuIHRoZSBldmVudCB3YXMgYWRkZWQuIElmIGEgcHJveHlcblx0ICogZnVuY3Rpb24sIG9yIGZ1bmN0aW9uIGNsb3N1cmUgaXMgdXNlZCBhcyB0aGUgY2FsbGJhY2ssIHRoZSBwcm94eS9jbG9zdXJlIHJlZmVyZW5jZSBtdXN0IGJlIHVzZWQgLSBhIG5ldyBwcm94eSBvclxuXHQgKiBjbG9zdXJlIHdpbGwgbm90IHdvcmsuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGljayk7XG5cdCAqXG5cdCAqIEBtZXRob2QgcmVtb3ZlRXZlbnRMaXN0ZW5lclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gb3Igb2JqZWN0LlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXG5cdCAqKi9cblx0cC5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcblx0XHR2YXIgbGlzdGVuZXJzID0gdXNlQ2FwdHVyZSA/IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgOiB0aGlzLl9saXN0ZW5lcnM7XG5cdFx0aWYgKCFsaXN0ZW5lcnMpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIGFyciA9IGxpc3RlbmVyc1t0eXBlXTtcblx0XHRpZiAoIWFycikgeyByZXR1cm47IH1cblx0XHRmb3IgKHZhciBpPTAsbD1hcnIubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0aWYgKGFycltpXSA9PSBsaXN0ZW5lcikge1xuXHRcdFx0XHRpZiAobD09MSkgeyBkZWxldGUobGlzdGVuZXJzW3R5cGVdKTsgfSAvLyBhbGxvd3MgZm9yIGZhc3RlciBjaGVja3MuXG5cdFx0XHRcdGVsc2UgeyBhcnIuc3BsaWNlKGksMSk7IH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEEgc2hvcnRjdXQgdG8gdGhlIHJlbW92ZUV2ZW50TGlzdGVuZXIgbWV0aG9kLCB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMgYW5kIHJldHVybiB2YWx1ZS4gVGhpcyBpcyBhIGNvbXBhbmlvbiB0byB0aGVcblx0ICogLm9uIG1ldGhvZC5cblx0ICogXG5cdCAqIDxiPklNUE9SVEFOVDo8L2I+IFRvIHJlbW92ZSBhIGxpc3RlbmVyIGFkZGVkIHdpdGggYG9uYCwgeW91IG11c3QgcGFzcyBpbiB0aGUgcmV0dXJuZWQgd3JhcHBlciBmdW5jdGlvbiBhcyB0aGUgbGlzdGVuZXIuIFNlZSBcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL29uXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhbiBleGFtcGxlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIG9mZlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gb3Igb2JqZWN0LlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXG5cdCAqKi9cblx0cC5vZmYgPSBwLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBmb3IgdGhlIHNwZWNpZmllZCB0eXBlLCBvciBhbGwgbGlzdGVuZXJzIG9mIGFsbCB0eXBlcy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5yZW1vdmVBbGxFdmVudExpc3RlbmVycygpO1xuXHQgKlxuXHQgKiAgICAgIC8vIFJlbW92ZSBhbGwgY2xpY2sgbGlzdGVuZXJzXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5yZW1vdmVBbGxFdmVudExpc3RlbmVycyhcImNsaWNrXCIpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC4gSWYgb21pdHRlZCwgYWxsIGxpc3RlbmVycyBmb3IgYWxsIHR5cGVzIHdpbGwgYmUgcmVtb3ZlZC5cblx0ICoqL1xuXHRwLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuXHRcdGlmICghdHlwZSkgeyB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzID0gbnVsbDsgfVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHRoaXMuX2xpc3RlbmVycykgeyBkZWxldGUodGhpcy5fbGlzdGVuZXJzW3R5cGVdKTsgfVxuXHRcdFx0aWYgKHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMpIHsgZGVsZXRlKHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnNbdHlwZV0pOyB9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVzIHRoZSBzcGVjaWZpZWQgZXZlbnQgdG8gYWxsIGxpc3RlbmVycy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIC8vIFVzZSBhIHN0cmluZyBldmVudFxuXHQgKiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpO1xuXHQgKlxuXHQgKiAgICAgIC8vIFVzZSBhbiBFdmVudCBpbnN0YW5jZVxuXHQgKiAgICAgIHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcInByb2dyZXNzXCIpO1xuXHQgKiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdCAqXG5cdCAqIEBtZXRob2QgZGlzcGF0Y2hFdmVudFxuXHQgKiBAcGFyYW0ge09iamVjdCB8IFN0cmluZyB8IEV2ZW50fSBldmVudE9iaiBBbiBvYmplY3Qgd2l0aCBhIFwidHlwZVwiIHByb3BlcnR5LCBvciBhIHN0cmluZyB0eXBlLlxuXHQgKiBXaGlsZSBhIGdlbmVyaWMgb2JqZWN0IHdpbGwgd29yaywgaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIGEgQ3JlYXRlSlMgRXZlbnQgaW5zdGFuY2UuIElmIGEgc3RyaW5nIGlzIHVzZWQsXG5cdCAqIGRpc3BhdGNoRXZlbnQgd2lsbCBjb25zdHJ1Y3QgYW4gRXZlbnQgaW5zdGFuY2UgaWYgbmVjZXNzYXJ5IHdpdGggdGhlIHNwZWNpZmllZCB0eXBlLiBUaGlzIGxhdHRlciBhcHByb2FjaCBjYW5cblx0ICogYmUgdXNlZCB0byBhdm9pZCBldmVudCBvYmplY3QgaW5zdGFudGlhdGlvbiBmb3Igbm9uLWJ1YmJsaW5nIGV2ZW50cyB0aGF0IG1heSBub3QgaGF2ZSBhbnkgbGlzdGVuZXJzLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtidWJibGVzXSBTcGVjaWZpZXMgdGhlIGBidWJibGVzYCB2YWx1ZSB3aGVuIGEgc3RyaW5nIHdhcyBwYXNzZWQgdG8gZXZlbnRPYmouXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbmNlbGFibGVdIFNwZWNpZmllcyB0aGUgYGNhbmNlbGFibGVgIHZhbHVlIHdoZW4gYSBzdHJpbmcgd2FzIHBhc3NlZCB0byBldmVudE9iai5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBmYWxzZSBpZiBgcHJldmVudERlZmF1bHQoKWAgd2FzIGNhbGxlZCBvbiBhIGNhbmNlbGFibGUgZXZlbnQsIHRydWUgb3RoZXJ3aXNlLlxuXHQgKiovXG5cdHAuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50T2JqLCBidWJibGVzLCBjYW5jZWxhYmxlKSB7XG5cdFx0aWYgKHR5cGVvZiBldmVudE9iaiA9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHQvLyBza2lwIGV2ZXJ5dGhpbmcgaWYgdGhlcmUncyBubyBsaXN0ZW5lcnMgYW5kIGl0IGRvZXNuJ3QgYnViYmxlOlxuXHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblx0XHRcdGlmICghYnViYmxlcyAmJiAoIWxpc3RlbmVycyB8fCAhbGlzdGVuZXJzW2V2ZW50T2JqXSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdGV2ZW50T2JqID0gbmV3IGNyZWF0ZWpzLkV2ZW50KGV2ZW50T2JqLCBidWJibGVzLCBjYW5jZWxhYmxlKTtcblx0XHR9IGVsc2UgaWYgKGV2ZW50T2JqLnRhcmdldCAmJiBldmVudE9iai5jbG9uZSkge1xuXHRcdFx0Ly8gcmVkaXNwYXRjaGluZyBhbiBhY3RpdmUgZXZlbnQgb2JqZWN0LCBzbyBjbG9uZSBpdDpcblx0XHRcdGV2ZW50T2JqID0gZXZlbnRPYmouY2xvbmUoKTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gVE9ETzogaXQgd291bGQgYmUgbmljZSB0byBlbGltaW5hdGUgdGhpcy4gTWF5YmUgaW4gZmF2b3VyIG9mIGV2dE9iaiBpbnN0YW5jZW9mIEV2ZW50PyBPciAhIWV2dE9iai5jcmVhdGVFdmVudFxuXHRcdHRyeSB7IGV2ZW50T2JqLnRhcmdldCA9IHRoaXM7IH0gY2F0Y2ggKGUpIHt9IC8vIHRyeS9jYXRjaCBhbGxvd3MgcmVkaXNwYXRjaGluZyBvZiBuYXRpdmUgZXZlbnRzXG5cblx0XHRpZiAoIWV2ZW50T2JqLmJ1YmJsZXMgfHwgIXRoaXMucGFyZW50KSB7XG5cdFx0XHR0aGlzLl9kaXNwYXRjaEV2ZW50KGV2ZW50T2JqLCAyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHRvcD10aGlzLCBsaXN0PVt0b3BdO1xuXHRcdFx0d2hpbGUgKHRvcC5wYXJlbnQpIHsgbGlzdC5wdXNoKHRvcCA9IHRvcC5wYXJlbnQpOyB9XG5cdFx0XHR2YXIgaSwgbD1saXN0Lmxlbmd0aDtcblxuXHRcdFx0Ly8gY2FwdHVyZSAmIGF0VGFyZ2V0XG5cdFx0XHRmb3IgKGk9bC0xOyBpPj0wICYmICFldmVudE9iai5wcm9wYWdhdGlvblN0b3BwZWQ7IGktLSkge1xuXHRcdFx0XHRsaXN0W2ldLl9kaXNwYXRjaEV2ZW50KGV2ZW50T2JqLCAxKyhpPT0wKSk7XG5cdFx0XHR9XG5cdFx0XHQvLyBidWJibGluZ1xuXHRcdFx0Zm9yIChpPTE7IGk8bCAmJiAhZXZlbnRPYmoucHJvcGFnYXRpb25TdG9wcGVkOyBpKyspIHtcblx0XHRcdFx0bGlzdFtpXS5fZGlzcGF0Y2hFdmVudChldmVudE9iaiwgMyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAhZXZlbnRPYmouZGVmYXVsdFByZXZlbnRlZDtcblx0fTtcblxuXHQvKipcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXG5cdCAqIEBtZXRob2QgaGFzRXZlbnRMaXN0ZW5lclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuXHQgKiovXG5cdHAuaGFzRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLCBjYXB0dXJlTGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVycztcblx0XHRyZXR1cm4gISEoKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnNbdHlwZV0pIHx8IChjYXB0dXJlTGlzdGVuZXJzICYmIGNhcHR1cmVMaXN0ZW5lcnNbdHlwZV0pKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQgdHlwZSBvbiB0aGlzIG9iamVjdCBvciBhbnkgb2YgaXRzXG5cdCAqIGFuY2VzdG9ycyAocGFyZW50LCBwYXJlbnQncyBwYXJlbnQsIGV0YykuIEEgcmV0dXJuIHZhbHVlIG9mIHRydWUgaW5kaWNhdGVzIHRoYXQgaWYgYSBidWJibGluZyBldmVudCBvZiB0aGVcblx0ICogc3BlY2lmaWVkIHR5cGUgaXMgZGlzcGF0Y2hlZCBmcm9tIHRoaXMgb2JqZWN0LCBpdCB3aWxsIHRyaWdnZXIgYXQgbGVhc3Qgb25lIGxpc3RlbmVyLlxuXHQgKiBcblx0ICogVGhpcyBpcyBzaW1pbGFyIHRvIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9oYXNFdmVudExpc3RlbmVyXCJ9fXt7L2Nyb3NzTGlua319LCBidXQgaXQgc2VhcmNoZXMgdGhlIGVudGlyZVxuXHQgKiBldmVudCBmbG93IGZvciBhIGxpc3RlbmVyLCBub3QganVzdCB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB3aWxsVHJpZ2dlclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG5cdCAqKi9cblx0cC53aWxsVHJpZ2dlciA9IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHR2YXIgbyA9IHRoaXM7XG5cdFx0d2hpbGUgKG8pIHtcblx0XHRcdGlmIChvLmhhc0V2ZW50TGlzdGVuZXIodHlwZSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdG8gPSBvLnBhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbRXZlbnREaXNwYXRjaGVyXVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX2Rpc3BhdGNoRXZlbnRcblx0ICogQHBhcmFtIHtPYmplY3QgfCBTdHJpbmcgfCBFdmVudH0gZXZlbnRPYmpcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50UGhhc2Vcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2Rpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudE9iaiwgZXZlbnRQaGFzZSkge1xuXHRcdHZhciBsLCBsaXN0ZW5lcnMgPSAoZXZlbnRQaGFzZT09MSkgPyB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzIDogdGhpcy5fbGlzdGVuZXJzO1xuXHRcdGlmIChldmVudE9iaiAmJiBsaXN0ZW5lcnMpIHtcblx0XHRcdHZhciBhcnIgPSBsaXN0ZW5lcnNbZXZlbnRPYmoudHlwZV07XG5cdFx0XHRpZiAoIWFycnx8IShsPWFyci5sZW5ndGgpKSB7IHJldHVybjsgfVxuXHRcdFx0dHJ5IHsgZXZlbnRPYmouY3VycmVudFRhcmdldCA9IHRoaXM7IH0gY2F0Y2ggKGUpIHt9XG5cdFx0XHR0cnkgeyBldmVudE9iai5ldmVudFBoYXNlID0gZXZlbnRQaGFzZTsgfSBjYXRjaCAoZSkge31cblx0XHRcdGV2ZW50T2JqLnJlbW92ZWQgPSBmYWxzZTtcblx0XHRcdFxuXHRcdFx0YXJyID0gYXJyLnNsaWNlKCk7IC8vIHRvIGF2b2lkIGlzc3VlcyB3aXRoIGl0ZW1zIGJlaW5nIHJlbW92ZWQgb3IgYWRkZWQgZHVyaW5nIHRoZSBkaXNwYXRjaFxuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGwgJiYgIWV2ZW50T2JqLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDsgaSsrKSB7XG5cdFx0XHRcdHZhciBvID0gYXJyW2ldO1xuXHRcdFx0XHRpZiAoby5oYW5kbGVFdmVudCkgeyBvLmhhbmRsZUV2ZW50KGV2ZW50T2JqKTsgfVxuXHRcdFx0XHRlbHNlIHsgbyhldmVudE9iaik7IH1cblx0XHRcdFx0aWYgKGV2ZW50T2JqLnJlbW92ZWQpIHtcblx0XHRcdFx0XHR0aGlzLm9mZihldmVudE9iai50eXBlLCBvLCBldmVudFBoYXNlPT0xKTtcblx0XHRcdFx0XHRldmVudE9iai5yZW1vdmVkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblxuXHRjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIgPSBFdmVudERpc3BhdGNoZXI7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVGlja2VyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogVGhlIFRpY2tlciBwcm92aWRlcyBhIGNlbnRyYWxpemVkIHRpY2sgb3IgaGVhcnRiZWF0IGJyb2FkY2FzdCBhdCBhIHNldCBpbnRlcnZhbC4gTGlzdGVuZXJzIGNhbiBzdWJzY3JpYmUgdG8gdGhlIHRpY2tcblx0ICogZXZlbnQgdG8gYmUgbm90aWZpZWQgd2hlbiBhIHNldCB0aW1lIGludGVydmFsIGhhcyBlbGFwc2VkLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIGludGVydmFsIHRoYXQgdGhlIHRpY2sgZXZlbnQgaXMgY2FsbGVkIGlzIGEgdGFyZ2V0IGludGVydmFsLCBhbmQgbWF5IGJlIGJyb2FkY2FzdCBhdCBhIHNsb3dlciBpbnRlcnZhbFxuXHQgKiB3aGVuIHVuZGVyIGhpZ2ggQ1BVIGxvYWQuIFRoZSBUaWNrZXIgY2xhc3MgdXNlcyBhIHN0YXRpYyBpbnRlcmZhY2UgKGV4LiBgVGlja2VyLmZyYW1lcmF0ZSA9IDMwO2ApIGFuZFxuXHQgKiBjYW4gbm90IGJlIGluc3RhbnRpYXRlZC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLlRpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBoYW5kbGVUaWNrKTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVUaWNrKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIC8vIEFjdGlvbnMgY2FycmllZCBvdXQgZWFjaCB0aWNrIChha2EgZnJhbWUpXG5cdCAqICAgICAgICAgIGlmICghZXZlbnQucGF1c2VkKSB7XG5cdCAqICAgICAgICAgICAgICAvLyBBY3Rpb25zIGNhcnJpZWQgb3V0IHdoZW4gdGhlIFRpY2tlciBpcyBub3QgcGF1c2VkLlxuXHQgKiAgICAgICAgICB9XG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBAY2xhc3MgVGlja2VyXG5cdCAqIEB1c2VzIEV2ZW50RGlzcGF0Y2hlclxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0ZnVuY3Rpb24gVGlja2VyKCkge1xuXHRcdHRocm93IFwiVGlja2VyIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWQuXCI7XG5cdH1cblxuXG4vLyBjb25zdGFudHM6XG5cdC8qKlxuXHQgKiBJbiB0aGlzIG1vZGUsIFRpY2tlciB1c2VzIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgQVBJLCBidXQgYXR0ZW1wdHMgdG8gc3luY2ggdGhlIHRpY2tzIHRvIHRhcmdldCBmcmFtZXJhdGUuIEl0XG5cdCAqIHVzZXMgYSBzaW1wbGUgaGV1cmlzdGljIHRoYXQgY29tcGFyZXMgdGhlIHRpbWUgb2YgdGhlIFJBRiByZXR1cm4gdG8gdGhlIHRhcmdldCB0aW1lIGZvciB0aGUgY3VycmVudCBmcmFtZSBhbmRcblx0ICogZGlzcGF0Y2hlcyB0aGUgdGljayB3aGVuIHRoZSB0aW1lIGlzIHdpdGhpbiBhIGNlcnRhaW4gdGhyZXNob2xkLlxuXHQgKlxuXHQgKiBUaGlzIG1vZGUgaGFzIGEgaGlnaGVyIHZhcmlhbmNlIGZvciB0aW1lIGJldHdlZW4gZnJhbWVzIHRoYW4ge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1RJTUVPVVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIGJ1dCBkb2VzIG5vdCByZXF1aXJlIHRoYXQgY29udGVudCBiZSB0aW1lIGJhc2VkIGFzIHdpdGgge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1JBRjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSB3aGlsZVxuXHQgKiBnYWluaW5nIHRoZSBiZW5lZml0cyBvZiB0aGF0IEFQSSAoc2NyZWVuIHN5bmNoLCBiYWNrZ3JvdW5kIHRocm90dGxpbmcpLlxuXHQgKlxuXHQgKiBWYXJpYW5jZSBpcyB1c3VhbGx5IGxvd2VzdCBmb3IgZnJhbWVyYXRlcyB0aGF0IGFyZSBhIGRpdmlzb3Igb2YgdGhlIFJBRiBmcmVxdWVuY3kuIFRoaXMgaXMgdXN1YWxseSA2MCwgc29cblx0ICogZnJhbWVyYXRlcyBvZiAxMCwgMTIsIDE1LCAyMCwgYW5kIDMwIHdvcmsgd2VsbC5cblx0ICpcblx0ICogRmFsbHMgYmFjayB0byB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvVElNRU9VVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpZiB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIEFQSSBpcyBub3Rcblx0ICogc3VwcG9ydGVkLlxuXHQgKiBAcHJvcGVydHkgUkFGX1NZTkNIRURcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBcInN5bmNoZWRcIlxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRUaWNrZXIuUkFGX1NZTkNIRUQgPSBcInN5bmNoZWRcIjtcblxuXHQvKipcblx0ICogSW4gdGhpcyBtb2RlLCBUaWNrZXIgcGFzc2VzIHRocm91Z2ggdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBoZWFydGJlYXQsIGlnbm9yaW5nIHRoZSB0YXJnZXQgZnJhbWVyYXRlIGNvbXBsZXRlbHkuXG5cdCAqIEJlY2F1c2UgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZyZXF1ZW5jeSBpcyBub3QgZGV0ZXJtaW5pc3RpYywgYW55IGNvbnRlbnQgdXNpbmcgdGhpcyBtb2RlIHNob3VsZCBiZSB0aW1lIGJhc2VkLlxuXHQgKiBZb3UgY2FuIGxldmVyYWdlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9nZXRUaW1lXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3RpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgb2JqZWN0J3MgXCJkZWx0YVwiIHByb3BlcnRpZXMgdG8gbWFrZSB0aGlzIGVhc2llci5cblx0ICpcblx0ICogRmFsbHMgYmFjayBvbiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvVElNRU9VVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpZiB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIEFQSSBpcyBub3Rcblx0ICogc3VwcG9ydGVkLlxuXHQgKiBAcHJvcGVydHkgUkFGXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgXCJyYWZcIlxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRUaWNrZXIuUkFGID0gXCJyYWZcIjtcblxuXHQvKipcblx0ICogSW4gdGhpcyBtb2RlLCBUaWNrZXIgdXNlcyB0aGUgc2V0VGltZW91dCBBUEkuIFRoaXMgcHJvdmlkZXMgcHJlZGljdGFibGUsIGFkYXB0aXZlIGZyYW1lIHRpbWluZywgYnV0IGRvZXMgbm90XG5cdCAqIHByb3ZpZGUgdGhlIGJlbmVmaXRzIG9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAoc2NyZWVuIHN5bmNoLCBiYWNrZ3JvdW5kIHRocm90dGxpbmcpLlxuXHQgKiBAcHJvcGVydHkgVElNRU9VVFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IFwidGltZW91dFwiXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdFRpY2tlci5USU1FT1VUID0gXCJ0aW1lb3V0XCI7XG5cblxuLy8gc3RhdGljIGV2ZW50czpcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgZWFjaCB0aWNrLiBUaGUgZXZlbnQgd2lsbCBiZSBkaXNwYXRjaGVkIHRvIGVhY2ggbGlzdGVuZXIgZXZlbiB3aGVuIHRoZSBUaWNrZXIgaGFzIGJlZW4gcGF1c2VkIHVzaW5nXG5cdCAqIHt7I2Nyb3NzTGluayBcIlRpY2tlci9zZXRQYXVzZWRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgaGFuZGxlVGljayk7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlVGljayhldmVudCkge1xuXHQgKiAgICAgICAgICBjb25zb2xlLmxvZyhcIlBhdXNlZDpcIiwgZXZlbnQucGF1c2VkLCBldmVudC5kZWx0YSk7XG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBAZXZlbnQgdGlja1xuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcGF1c2VkIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0aWNrZXIgaXMgY3VycmVudGx5IHBhdXNlZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhIFRoZSB0aW1lIGVsYXBzZWQgaW4gbXMgc2luY2UgdGhlIGxhc3QgdGljay5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVGhlIHRvdGFsIHRpbWUgaW4gbXMgc2luY2UgVGlja2VyIHdhcyBpbml0aWFsaXplZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJ1blRpbWUgVGhlIHRvdGFsIHRpbWUgaW4gbXMgdGhhdCBUaWNrZXIgd2FzIG5vdCBwYXVzZWQgc2luY2UgaXQgd2FzIGluaXRpYWxpemVkLiBGb3IgZXhhbXBsZSxcblx0ICogXHR5b3UgY291bGQgZGV0ZXJtaW5lIHRoZSBhbW91bnQgb2YgdGltZSB0aGF0IHRoZSBUaWNrZXIgaGFzIGJlZW4gcGF1c2VkIHNpbmNlIGluaXRpYWxpemF0aW9uIHdpdGggYHRpbWUtcnVuVGltZWAuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXG4vLyBwdWJsaWMgc3RhdGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBEZXByZWNhdGVkIGluIGZhdm91ciBvZiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGltaW5nTW9kZVwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLiBJZiB0cnVlLCB0aW1pbmdNb2RlIHdpbGxcblx0ICogdXNlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9SQUZfU1lOQ0hFRFwifX17ey9jcm9zc0xpbmt9fSBieSBkZWZhdWx0LlxuXHQgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIGluIGZhdm91ciBvZiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGltaW5nTW9kZVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQHByb3BlcnR5IHVzZVJBRlxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAZGVmYXVsdCBmYWxzZVxuXHQgKiovXG5cdFRpY2tlci51c2VSQUYgPSBmYWxzZTtcblxuXHQvKipcblx0ICogU3BlY2lmaWVzIHRoZSB0aW1pbmcgYXBpIChzZXRUaW1lb3V0IG9yIHJlcXVlc3RBbmltYXRpb25GcmFtZSkgYW5kIG1vZGUgdG8gdXNlLiBTZWVcblx0ICoge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1RJTUVPVVRcIn19e3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIlRpY2tlci9SQUZcIn19e3svY3Jvc3NMaW5rfX0sIGFuZFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvUkFGX1NZTkNIRURcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vZGUgZGV0YWlscy5cblx0ICogQHByb3BlcnR5IHRpbWluZ01vZGVcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBUaWNrZXIuVElNRU9VVFxuXHQgKiovXG5cdFRpY2tlci50aW1pbmdNb2RlID0gbnVsbDtcblxuXHQvKipcblx0ICogU3BlY2lmaWVzIGEgbWF4aW11bSB2YWx1ZSBmb3IgdGhlIGRlbHRhIHByb3BlcnR5IGluIHRoZSB0aWNrIGV2ZW50IG9iamVjdC4gVGhpcyBpcyB1c2VmdWwgd2hlbiBidWlsZGluZyB0aW1lXG5cdCAqIGJhc2VkIGFuaW1hdGlvbnMgYW5kIHN5c3RlbXMgdG8gcHJldmVudCBpc3N1ZXMgY2F1c2VkIGJ5IGxhcmdlIHRpbWUgZ2FwcyBjYXVzZWQgYnkgYmFja2dyb3VuZCB0YWJzLCBzeXN0ZW0gc2xlZXAsXG5cdCAqIGFsZXJ0IGRpYWxvZ3MsIG9yIG90aGVyIGJsb2NraW5nIHJvdXRpbmVzLiBEb3VibGUgdGhlIGV4cGVjdGVkIGZyYW1lIGR1cmF0aW9uIGlzIG9mdGVuIGFuIGVmZmVjdGl2ZSB2YWx1ZVxuXHQgKiAoZXguIG1heERlbHRhPTUwIHdoZW4gcnVubmluZyBhdCA0MGZwcykuXG5cdCAqIFxuXHQgKiBUaGlzIGRvZXMgbm90IGltcGFjdCBhbnkgb3RoZXIgdmFsdWVzIChleC4gdGltZSwgcnVuVGltZSwgZXRjKSwgc28geW91IG1heSBleHBlcmllbmNlIGlzc3VlcyBpZiB5b3UgZW5hYmxlIG1heERlbHRhXG5cdCAqIHdoZW4gdXNpbmcgYm90aCBkZWx0YSBhbmQgb3RoZXIgdmFsdWVzLlxuXHQgKiBcblx0ICogSWYgMCwgdGhlcmUgaXMgbm8gbWF4aW11bS5cblx0ICogQHByb3BlcnR5IG1heERlbHRhXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge251bWJlcn1cblx0ICogQGRlZmF1bHQgMFxuXHQgKi9cblx0VGlja2VyLm1heERlbHRhID0gMDtcblx0XG5cdC8qKlxuXHQgKiBXaGVuIHRoZSB0aWNrZXIgaXMgcGF1c2VkLCBhbGwgbGlzdGVuZXJzIHdpbGwgc3RpbGwgcmVjZWl2ZSBhIHRpY2sgZXZlbnQsIGJ1dCB0aGUgPGNvZGU+cGF1c2VkPC9jb2RlPiBwcm9wZXJ0eVxuXHQgKiBvZiB0aGUgZXZlbnQgd2lsbCBiZSBgdHJ1ZWAuIEFsc28sIHdoaWxlIHBhdXNlZCB0aGUgYHJ1blRpbWVgIHdpbGwgbm90IGluY3JlYXNlLiBTZWUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3RpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIHt7I2Nyb3NzTGluayBcIlRpY2tlci9nZXRUaW1lXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2dldEV2ZW50VGltZVwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZVxuXHQgKiBpbmZvLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIGhhbmRsZVRpY2spO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlRpY2tlci5wYXVzZWQgPSB0cnVlO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZVRpY2soZXZlbnQpIHtcblx0ICogICAgICAgICAgY29uc29sZS5sb2coZXZlbnQucGF1c2VkLFxuXHQgKiAgICAgICAgICBcdGNyZWF0ZWpzLlRpY2tlci5nZXRUaW1lKGZhbHNlKSxcblx0ICogICAgICAgICAgXHRjcmVhdGVqcy5UaWNrZXIuZ2V0VGltZSh0cnVlKSk7XG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBAcHJvcGVydHkgcGF1c2VkXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBkZWZhdWx0IGZhbHNlXG5cdCAqKi9cblx0VGlja2VyLnBhdXNlZCA9IGZhbHNlO1xuXG5cbi8vIG1peC1pbnM6XG5cdC8vIEV2ZW50RGlzcGF0Y2hlciBtZXRob2RzOlxuXHRUaWNrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IG51bGw7XG5cdFRpY2tlci5yZW1vdmVBbGxFdmVudExpc3RlbmVycyA9IG51bGw7XG5cdFRpY2tlci5kaXNwYXRjaEV2ZW50ID0gbnVsbDtcblx0VGlja2VyLmhhc0V2ZW50TGlzdGVuZXIgPSBudWxsO1xuXHRUaWNrZXIuX2xpc3RlbmVycyA9IG51bGw7XG5cdGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplKFRpY2tlcik7IC8vIGluamVjdCBFdmVudERpc3BhdGNoZXIgbWV0aG9kcy5cblx0VGlja2VyLl9hZGRFdmVudExpc3RlbmVyID0gVGlja2VyLmFkZEV2ZW50TGlzdGVuZXI7XG5cdFRpY2tlci5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG5cdFx0IVRpY2tlci5faW5pdGVkJiZUaWNrZXIuaW5pdCgpO1xuXHRcdHJldHVybiBUaWNrZXIuX2FkZEV2ZW50TGlzdGVuZXIuYXBwbHkoVGlja2VyLCBhcmd1bWVudHMpO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgc3RhdGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX2luaXRlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9pbml0ZWQgPSBmYWxzZTtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IF9zdGFydFRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9zdGFydFRpbWUgPSAwO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3BhdXNlZFRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9wYXVzZWRUaW1lPTA7XG5cblx0LyoqXG5cdCAqIFRoZSBudW1iZXIgb2YgdGlja3MgdGhhdCBoYXZlIHBhc3NlZFxuXHQgKiBAcHJvcGVydHkgX3RpY2tzXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fdGlja3MgPSAwO1xuXG5cdC8qKlxuXHQgKiBUaGUgbnVtYmVyIG9mIHRpY2tzIHRoYXQgaGF2ZSBwYXNzZWQgd2hpbGUgVGlja2VyIGhhcyBiZWVuIHBhdXNlZFxuXHQgKiBAcHJvcGVydHkgX3BhdXNlZFRpY2tzXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fcGF1c2VkVGlja3MgPSAwO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX2ludGVydmFsXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5faW50ZXJ2YWwgPSA1MDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IF9sYXN0VGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX2xhc3RUaW1lID0gMDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IF90aW1lc1xuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fdGltZXMgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3RpY2tUaW1lc1xuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fdGlja1RpbWVzID0gbnVsbDtcblxuXHQvKipcblx0ICogU3RvcmVzIHRoZSB0aW1lb3V0IG9yIHJlcXVlc3RBbmltYXRpb25GcmFtZSBpZC5cblx0ICogQHByb3BlcnR5IF90aW1lcklkXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fdGltZXJJZCA9IG51bGw7XG5cdFxuXHQvKipcblx0ICogVHJ1ZSBpZiBjdXJyZW50bHkgdXNpbmcgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBmYWxzZSBpZiB1c2luZyBzZXRUaW1lb3V0LiBUaGlzIG1heSBiZSBkaWZmZXJlbnQgdGhhbiB0aW1pbmdNb2RlXG5cdCAqIGlmIHRoYXQgcHJvcGVydHkgY2hhbmdlZCBhbmQgYSB0aWNrIGhhc24ndCBmaXJlZC5cblx0ICogQHByb3BlcnR5IF9yYWZcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fcmFmID0gdHJ1ZTtcblx0XG5cbi8vIHN0YXRpYyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvaW50ZXJ2YWw6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBzZXRJbnRlcnZhbFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnZhbFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdFRpY2tlci5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKGludGVydmFsKSB7XG5cdFx0VGlja2VyLl9pbnRlcnZhbCA9IGludGVydmFsO1xuXHRcdGlmICghVGlja2VyLl9pbml0ZWQpIHsgcmV0dXJuOyB9XG5cdFx0VGlja2VyLl9zZXR1cFRpY2soKTtcblx0fTtcblxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvaW50ZXJ2YWw6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXRJbnRlcnZhbFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRUaWNrZXIuZ2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gVGlja2VyLl9pbnRlcnZhbDtcblx0fTtcblxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvZnJhbWVyYXRlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2Qgc2V0RlBTXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLnNldEZQUyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0VGlja2VyLnNldEludGVydmFsKDEwMDAvdmFsdWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9mcmFtZXJhdGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXRGUFNcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLmdldEZQUyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAxMDAwL1RpY2tlci5faW50ZXJ2YWw7XG5cdH07XG5cblx0LyoqXG5cdCAqIEluZGljYXRlcyB0aGUgdGFyZ2V0IHRpbWUgKGluIG1pbGxpc2Vjb25kcykgYmV0d2VlbiB0aWNrcy4gRGVmYXVsdCBpcyA1MCAoMjAgRlBTKS5cblx0ICogTm90ZSB0aGF0IGFjdHVhbCB0aW1lIGJldHdlZW4gdGlja3MgbWF5IGJlIG1vcmUgdGhhbiBzcGVjaWZpZWQgZGVwZW5kaW5nIG9uIENQVSBsb2FkLlxuXHQgKiBUaGlzIHByb3BlcnR5IGlzIGlnbm9yZWQgaWYgdGhlIHRpY2tlciBpcyB1c2luZyB0aGUgYFJBRmAgdGltaW5nIG1vZGUuXG5cdCAqIEBwcm9wZXJ0eSBpbnRlcnZhbFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqKi9cblx0IFxuXHQvKipcblx0ICogSW5kaWNhdGVzIHRoZSB0YXJnZXQgZnJhbWUgcmF0ZSBpbiBmcmFtZXMgcGVyIHNlY29uZCAoRlBTKS4gRWZmZWN0aXZlbHkganVzdCBhIHNob3J0Y3V0IHRvIGBpbnRlcnZhbGAsIHdoZXJlXG5cdCAqIGBmcmFtZXJhdGUgPT0gMTAwMC9pbnRlcnZhbGAuXG5cdCAqIEBwcm9wZXJ0eSBmcmFtZXJhdGVcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiovXG5cdHRyeSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGlja2VyLCB7XG5cdFx0XHRpbnRlcnZhbDogeyBnZXQ6IFRpY2tlci5nZXRJbnRlcnZhbCwgc2V0OiBUaWNrZXIuc2V0SW50ZXJ2YWwgfSxcblx0XHRcdGZyYW1lcmF0ZTogeyBnZXQ6IFRpY2tlci5nZXRGUFMsIHNldDogVGlja2VyLnNldEZQUyB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHsgY29uc29sZS5sb2coZSk7IH1cblxuXG4vLyBwdWJsaWMgc3RhdGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBTdGFydHMgdGhlIHRpY2suIFRoaXMgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgZmlyc3QgbGlzdGVuZXIgaXMgYWRkZWQuXG5cdCAqIEBtZXRob2QgaW5pdFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VGlja2VyLmluaXQgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoVGlja2VyLl9pbml0ZWQpIHsgcmV0dXJuOyB9XG5cdFx0VGlja2VyLl9pbml0ZWQgPSB0cnVlO1xuXHRcdFRpY2tlci5fdGltZXMgPSBbXTtcblx0XHRUaWNrZXIuX3RpY2tUaW1lcyA9IFtdO1xuXHRcdFRpY2tlci5fc3RhcnRUaW1lID0gVGlja2VyLl9nZXRUaW1lKCk7XG5cdFx0VGlja2VyLl90aW1lcy5wdXNoKFRpY2tlci5fbGFzdFRpbWUgPSAwKTtcblx0XHRUaWNrZXIuaW50ZXJ2YWwgPSBUaWNrZXIuX2ludGVydmFsO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFN0b3BzIHRoZSBUaWNrZXIgYW5kIHJlbW92ZXMgYWxsIGxpc3RlbmVycy4gVXNlIGluaXQoKSB0byByZXN0YXJ0IHRoZSBUaWNrZXIuXG5cdCAqIEBtZXRob2QgcmVzZXRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRpY2tlci5yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChUaWNrZXIuX3JhZikge1xuXHRcdFx0dmFyIGYgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cub0NhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lO1xuXHRcdFx0ZiYmZihUaWNrZXIuX3RpbWVySWQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjbGVhclRpbWVvdXQoVGlja2VyLl90aW1lcklkKTtcblx0XHR9XG5cdFx0VGlja2VyLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKFwidGlja1wiKTtcblx0XHRUaWNrZXIuX3RpbWVySWQgPSBUaWNrZXIuX3RpbWVzID0gVGlja2VyLl90aWNrVGltZXMgPSBudWxsO1xuXHRcdFRpY2tlci5fc3RhcnRUaW1lID0gVGlja2VyLl9sYXN0VGltZSA9IFRpY2tlci5fdGlja3MgPSAwO1xuXHRcdFRpY2tlci5faW5pdGVkID0gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGF2ZXJhZ2UgdGltZSBzcGVudCB3aXRoaW4gYSB0aWNrLiBUaGlzIGNhbiB2YXJ5IHNpZ25pZmljYW50bHkgZnJvbSB0aGUgdmFsdWUgcHJvdmlkZWQgYnkgZ2V0TWVhc3VyZWRGUFNcblx0ICogYmVjYXVzZSBpdCBvbmx5IG1lYXN1cmVzIHRoZSB0aW1lIHNwZW50IHdpdGhpbiB0aGUgdGljayBleGVjdXRpb24gc3RhY2suIFxuXHQgKiBcblx0ICogRXhhbXBsZSAxOiBXaXRoIGEgdGFyZ2V0IEZQUyBvZiAyMCwgZ2V0TWVhc3VyZWRGUFMoKSByZXR1cm5zIDIwZnBzLCB3aGljaCBpbmRpY2F0ZXMgYW4gYXZlcmFnZSBvZiA1MG1zIGJldHdlZW4gXG5cdCAqIHRoZSBlbmQgb2Ygb25lIHRpY2sgYW5kIHRoZSBlbmQgb2YgdGhlIG5leHQuIEhvd2V2ZXIsIGdldE1lYXN1cmVkVGlja1RpbWUoKSByZXR1cm5zIDE1bXMuIFRoaXMgaW5kaWNhdGVzIHRoYXQgXG5cdCAqIHRoZXJlIG1heSBiZSB1cCB0byAzNW1zIG9mIFwiaWRsZVwiIHRpbWUgYmV0d2VlbiB0aGUgZW5kIG9mIG9uZSB0aWNrIGFuZCB0aGUgc3RhcnQgb2YgdGhlIG5leHQuXG5cdCAqXG5cdCAqIEV4YW1wbGUgMjogV2l0aCBhIHRhcmdldCBGUFMgb2YgMzAsIGdldEZQUygpIHJldHVybnMgMTBmcHMsIHdoaWNoIGluZGljYXRlcyBhbiBhdmVyYWdlIG9mIDEwMG1zIGJldHdlZW4gdGhlIGVuZCBvZlxuXHQgKiBvbmUgdGljayBhbmQgdGhlIGVuZCBvZiB0aGUgbmV4dC4gSG93ZXZlciwgZ2V0TWVhc3VyZWRUaWNrVGltZSgpIHJldHVybnMgMjBtcy4gVGhpcyB3b3VsZCBpbmRpY2F0ZSB0aGF0IHNvbWV0aGluZ1xuXHQgKiBvdGhlciB0aGFuIHRoZSB0aWNrIGlzIHVzaW5nIH44MG1zIChhbm90aGVyIHNjcmlwdCwgRE9NIHJlbmRlcmluZywgZXRjKS5cblx0ICogQG1ldGhvZCBnZXRNZWFzdXJlZFRpY2tUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0aWNrc10gVGhlIG51bWJlciBvZiBwcmV2aW91cyB0aWNrcyBvdmVyIHdoaWNoIHRvIG1lYXN1cmUgdGhlIGF2ZXJhZ2UgdGltZSBzcGVudCBpbiBhIHRpY2suXG5cdCAqIERlZmF1bHRzIHRvIHRoZSBudW1iZXIgb2YgdGlja3MgcGVyIHNlY29uZC4gVG8gZ2V0IG9ubHkgdGhlIGxhc3QgdGljaydzIHRpbWUsIHBhc3MgaW4gMS5cblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgYXZlcmFnZSB0aW1lIHNwZW50IGluIGEgdGljayBpbiBtaWxsaXNlY29uZHMuXG5cdCAqKi9cblx0VGlja2VyLmdldE1lYXN1cmVkVGlja1RpbWUgPSBmdW5jdGlvbih0aWNrcykge1xuXHRcdHZhciB0dGw9MCwgdGltZXM9VGlja2VyLl90aWNrVGltZXM7XG5cdFx0aWYgKCF0aW1lcyB8fCB0aW1lcy5sZW5ndGggPCAxKSB7IHJldHVybiAtMTsgfVxuXG5cdFx0Ly8gYnkgZGVmYXVsdCwgY2FsY3VsYXRlIGF2ZXJhZ2UgZm9yIHRoZSBwYXN0IH4xIHNlY29uZDpcblx0XHR0aWNrcyA9IE1hdGgubWluKHRpbWVzLmxlbmd0aCwgdGlja3N8fChUaWNrZXIuZ2V0RlBTKCl8MCkpO1xuXHRcdGZvciAodmFyIGk9MDsgaTx0aWNrczsgaSsrKSB7IHR0bCArPSB0aW1lc1tpXTsgfVxuXHRcdHJldHVybiB0dGwvdGlja3M7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGFjdHVhbCBmcmFtZXMgLyB0aWNrcyBwZXIgc2Vjb25kLlxuXHQgKiBAbWV0aG9kIGdldE1lYXN1cmVkRlBTXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0aWNrc10gVGhlIG51bWJlciBvZiBwcmV2aW91cyB0aWNrcyBvdmVyIHdoaWNoIHRvIG1lYXN1cmUgdGhlIGFjdHVhbCBmcmFtZXMgLyB0aWNrcyBwZXIgc2Vjb25kLlxuXHQgKiBEZWZhdWx0cyB0byB0aGUgbnVtYmVyIG9mIHRpY2tzIHBlciBzZWNvbmQuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGFjdHVhbCBmcmFtZXMgLyB0aWNrcyBwZXIgc2Vjb25kLiBEZXBlbmRpbmcgb24gcGVyZm9ybWFuY2UsIHRoaXMgbWF5IGRpZmZlclxuXHQgKiBmcm9tIHRoZSB0YXJnZXQgZnJhbWVzIHBlciBzZWNvbmQuXG5cdCAqKi9cblx0VGlja2VyLmdldE1lYXN1cmVkRlBTID0gZnVuY3Rpb24odGlja3MpIHtcblx0XHR2YXIgdGltZXMgPSBUaWNrZXIuX3RpbWVzO1xuXHRcdGlmICghdGltZXMgfHwgdGltZXMubGVuZ3RoIDwgMikgeyByZXR1cm4gLTE7IH1cblxuXHRcdC8vIGJ5IGRlZmF1bHQsIGNhbGN1bGF0ZSBmcHMgZm9yIHRoZSBwYXN0IH4xIHNlY29uZDpcblx0XHR0aWNrcyA9IE1hdGgubWluKHRpbWVzLmxlbmd0aC0xLCB0aWNrc3x8KFRpY2tlci5nZXRGUFMoKXwwKSk7XG5cdFx0cmV0dXJuIDEwMDAvKCh0aW1lc1swXS10aW1lc1t0aWNrc10pL3RpY2tzKTtcblx0fTtcblxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvcGF1c2VkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2Qgc2V0UGF1c2VkXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdFRpY2tlci5zZXRQYXVzZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdC8vIFRPRE86IGRlcHJlY2F0ZWQuXG5cdFx0VGlja2VyLnBhdXNlZCA9IHZhbHVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9wYXVzZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXRQYXVzZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdFRpY2tlci5nZXRQYXVzZWQgPSBmdW5jdGlvbigpIHtcblx0XHQvLyBUT0RPOiBkZXByZWNhdGVkLlxuXHRcdHJldHVybiBUaWNrZXIucGF1c2VkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlIFRpY2tlciB3YXMgaW5pdGlhbGl6ZWQgdmlhIHt7I2Nyb3NzTGluayBcIlRpY2tlci9pbml0XCJ9fS5cblx0ICogUmV0dXJucyAtMSBpZiBUaWNrZXIgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkLiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIHVzZVxuXHQgKiB0aGlzIGluIGEgdGltZSBzeW5jaHJvbml6ZWQgYW5pbWF0aW9uIHRvIGRldGVybWluZSB0aGUgZXhhY3QgYW1vdW50IG9mIHRpbWUgdGhhdCBoYXMgZWxhcHNlZC5cblx0ICogQG1ldGhvZCBnZXRUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtCb29sZWFufSBbcnVuVGltZT1mYWxzZV0gSWYgdHJ1ZSBvbmx5IHRpbWUgZWxhcHNlZCB3aGlsZSBUaWNrZXIgd2FzIG5vdCBwYXVzZWQgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogSWYgZmFsc2UsIHRoZSB2YWx1ZSByZXR1cm5lZCB3aWxsIGJlIHRvdGFsIHRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgZmlyc3QgdGljayBldmVudCBsaXN0ZW5lciB3YXMgYWRkZWQuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZSBUaWNrZXIgd2FzIGluaXRpYWxpemVkIG9yIC0xLlxuXHQgKiovXG5cdFRpY2tlci5nZXRUaW1lID0gZnVuY3Rpb24ocnVuVGltZSkge1xuXHRcdHJldHVybiBUaWNrZXIuX3N0YXJ0VGltZSA/IFRpY2tlci5fZ2V0VGltZSgpIC0gKHJ1blRpbWUgPyBUaWNrZXIuX3BhdXNlZFRpbWUgOiAwKSA6IC0xO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTaW1pbGFyIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvZ2V0VGltZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QsIGJ1dCByZXR1cm5zIHRoZSB0aW1lIG9uIHRoZSBtb3N0IHJlY2VudCB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBvYmplY3QuXG5cdCAqIEBtZXRob2QgZ2V0RXZlbnRUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHJ1blRpbWUge0Jvb2xlYW59IFtydW5UaW1lPWZhbHNlXSBJZiB0cnVlLCB0aGUgcnVuVGltZSBwcm9wZXJ0eSB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQgb2YgdGltZS5cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHRpbWUgb3IgcnVuVGltZSBwcm9wZXJ0eSBmcm9tIHRoZSBtb3N0IHJlY2VudCB0aWNrIGV2ZW50IG9yIC0xLlxuXHQgKi9cblx0VGlja2VyLmdldEV2ZW50VGltZSA9IGZ1bmN0aW9uKHJ1blRpbWUpIHtcblx0XHRyZXR1cm4gVGlja2VyLl9zdGFydFRpbWUgPyAoVGlja2VyLl9sYXN0VGltZSB8fCBUaWNrZXIuX3N0YXJ0VGltZSkgLSAocnVuVGltZSA/IFRpY2tlci5fcGF1c2VkVGltZSA6IDApIDogLTE7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRpY2tzIHRoYXQgaGF2ZSBiZWVuIGJyb2FkY2FzdCBieSBUaWNrZXIuXG5cdCAqIEBtZXRob2QgZ2V0VGlja3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHBhdXNlYWJsZSBJbmRpY2F0ZXMgd2hldGhlciB0byBpbmNsdWRlIHRpY2tzIHRoYXQgd291bGQgaGF2ZSBiZWVuIGJyb2FkY2FzdFxuXHQgKiB3aGlsZSBUaWNrZXIgd2FzIHBhdXNlZC4gSWYgdHJ1ZSBvbmx5IHRpY2sgZXZlbnRzIGJyb2FkY2FzdCB3aGlsZSBUaWNrZXIgaXMgbm90IHBhdXNlZCB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBJZiBmYWxzZSwgdGljayBldmVudHMgdGhhdCB3b3VsZCBoYXZlIGJlZW4gYnJvYWRjYXN0IHdoaWxlIFRpY2tlciB3YXMgcGF1c2VkIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHJldHVyblxuXHQgKiB2YWx1ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgZmFsc2UuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gb2YgdGlja3MgdGhhdCBoYXZlIGJlZW4gYnJvYWRjYXN0LlxuXHQgKiovXG5cdFRpY2tlci5nZXRUaWNrcyA9IGZ1bmN0aW9uKHBhdXNlYWJsZSkge1xuXHRcdHJldHVybiAgVGlja2VyLl90aWNrcyAtIChwYXVzZWFibGUgPyBUaWNrZXIuX3BhdXNlZFRpY2tzIDogMCk7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBzdGF0aWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZVN5bmNoXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5faGFuZGxlU3luY2ggPSBmdW5jdGlvbigpIHtcblx0XHRUaWNrZXIuX3RpbWVySWQgPSBudWxsO1xuXHRcdFRpY2tlci5fc2V0dXBUaWNrKCk7XG5cblx0XHQvLyBydW4gaWYgZW5vdWdoIHRpbWUgaGFzIGVsYXBzZWQsIHdpdGggYSBsaXR0bGUgYml0IG9mIGZsZXhpYmlsaXR5IHRvIGJlIGVhcmx5OlxuXHRcdGlmIChUaWNrZXIuX2dldFRpbWUoKSAtIFRpY2tlci5fbGFzdFRpbWUgPj0gKFRpY2tlci5faW50ZXJ2YWwtMSkqMC45Nykge1xuXHRcdFx0VGlja2VyLl90aWNrKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVSQUZcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9oYW5kbGVSQUYgPSBmdW5jdGlvbigpIHtcblx0XHRUaWNrZXIuX3RpbWVySWQgPSBudWxsO1xuXHRcdFRpY2tlci5fc2V0dXBUaWNrKCk7XG5cdFx0VGlja2VyLl90aWNrKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZVRpbWVvdXRcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9oYW5kbGVUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0VGlja2VyLl90aW1lcklkID0gbnVsbDtcblx0XHRUaWNrZXIuX3NldHVwVGljaygpO1xuXHRcdFRpY2tlci5fdGljaygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9zZXR1cFRpY2tcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9zZXR1cFRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoVGlja2VyLl90aW1lcklkICE9IG51bGwpIHsgcmV0dXJuOyB9IC8vIGF2b2lkIGR1cGxpY2F0ZXNcblxuXHRcdHZhciBtb2RlID0gVGlja2VyLnRpbWluZ01vZGV8fChUaWNrZXIudXNlUkFGJiZUaWNrZXIuUkFGX1NZTkNIRUQpO1xuXHRcdGlmIChtb2RlID09IFRpY2tlci5SQUZfU1lOQ0hFRCB8fCBtb2RlID09IFRpY2tlci5SQUYpIHtcblx0XHRcdHZhciBmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXHRcdFx0aWYgKGYpIHtcblx0XHRcdFx0VGlja2VyLl90aW1lcklkID0gZihtb2RlID09IFRpY2tlci5SQUYgPyBUaWNrZXIuX2hhbmRsZVJBRiA6IFRpY2tlci5faGFuZGxlU3luY2gpO1xuXHRcdFx0XHRUaWNrZXIuX3JhZiA9IHRydWU7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdFx0VGlja2VyLl9yYWYgPSBmYWxzZTtcblx0XHRUaWNrZXIuX3RpbWVySWQgPSBzZXRUaW1lb3V0KFRpY2tlci5faGFuZGxlVGltZW91dCwgVGlja2VyLl9pbnRlcnZhbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3RpY2tcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhdXNlZCA9IFRpY2tlci5wYXVzZWQ7XG5cdFx0dmFyIHRpbWUgPSBUaWNrZXIuX2dldFRpbWUoKTtcblx0XHR2YXIgZWxhcHNlZFRpbWUgPSB0aW1lLVRpY2tlci5fbGFzdFRpbWU7XG5cdFx0VGlja2VyLl9sYXN0VGltZSA9IHRpbWU7XG5cdFx0VGlja2VyLl90aWNrcysrO1xuXHRcdFxuXHRcdGlmIChwYXVzZWQpIHtcblx0XHRcdFRpY2tlci5fcGF1c2VkVGlja3MrKztcblx0XHRcdFRpY2tlci5fcGF1c2VkVGltZSArPSBlbGFwc2VkVGltZTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKFRpY2tlci5oYXNFdmVudExpc3RlbmVyKFwidGlja1wiKSkge1xuXHRcdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwidGlja1wiKTtcblx0XHRcdHZhciBtYXhEZWx0YSA9IFRpY2tlci5tYXhEZWx0YTtcblx0XHRcdGV2ZW50LmRlbHRhID0gKG1heERlbHRhICYmIGVsYXBzZWRUaW1lID4gbWF4RGVsdGEpID8gbWF4RGVsdGEgOiBlbGFwc2VkVGltZTtcblx0XHRcdGV2ZW50LnBhdXNlZCA9IHBhdXNlZDtcblx0XHRcdGV2ZW50LnRpbWUgPSB0aW1lO1xuXHRcdFx0ZXZlbnQucnVuVGltZSA9IHRpbWUtVGlja2VyLl9wYXVzZWRUaW1lO1xuXHRcdFx0VGlja2VyLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHRcdH1cblx0XHRcblx0XHRUaWNrZXIuX3RpY2tUaW1lcy51bnNoaWZ0KFRpY2tlci5fZ2V0VGltZSgpLXRpbWUpO1xuXHRcdHdoaWxlIChUaWNrZXIuX3RpY2tUaW1lcy5sZW5ndGggPiAxMDApIHsgVGlja2VyLl90aWNrVGltZXMucG9wKCk7IH1cblxuXHRcdFRpY2tlci5fdGltZXMudW5zaGlmdCh0aW1lKTtcblx0XHR3aGlsZSAoVGlja2VyLl90aW1lcy5sZW5ndGggPiAxMDApIHsgVGlja2VyLl90aW1lcy5wb3AoKTsgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHZhciBub3cgPSB3aW5kb3cucGVyZm9ybWFuY2UgJiYgKHBlcmZvcm1hbmNlLm5vdyB8fCBwZXJmb3JtYW5jZS5tb3pOb3cgfHwgcGVyZm9ybWFuY2UubXNOb3cgfHwgcGVyZm9ybWFuY2Uub05vdyB8fCBwZXJmb3JtYW5jZS53ZWJraXROb3cpO1xuXHRUaWNrZXIuX2dldFRpbWUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKChub3cmJm5vdy5jYWxsKHBlcmZvcm1hbmNlKSl8fChuZXcgRGF0ZSgpLmdldFRpbWUoKSkpIC0gVGlja2VyLl9zdGFydFRpbWU7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5UaWNrZXIgPSBUaWNrZXI7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVUlELmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogR2xvYmFsIHV0aWxpdHkgZm9yIGdlbmVyYXRpbmcgc2VxdWVudGlhbCB1bmlxdWUgSUQgbnVtYmVycy4gVGhlIFVJRCBjbGFzcyB1c2VzIGEgc3RhdGljIGludGVyZmFjZSAoZXguIDxjb2RlPlVJRC5nZXQoKTwvY29kZT4pXG5cdCAqIGFuZCBzaG91bGQgbm90IGJlIGluc3RhbnRpYXRlZC5cblx0ICogQGNsYXNzIFVJRFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0ZnVuY3Rpb24gVUlEKCkge1xuXHRcdHRocm93IFwiVUlEIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWRcIjtcblx0fVxuXG5cbi8vIHByaXZhdGUgc3RhdGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX25leHRJRFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFVJRC5fbmV4dElEID0gMDtcblxuXG4vLyBwdWJsaWMgc3RhdGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBuZXh0IHVuaXF1ZSBpZC5cblx0ICogQG1ldGhvZCBnZXRcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgbmV4dCB1bmlxdWUgaWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFVJRC5nZXQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gVUlELl9uZXh0SUQrKztcblx0fTtcblxuXG5cdGNyZWF0ZWpzLlVJRCA9IFVJRDtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBNb3VzZUV2ZW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogUGFzc2VkIGFzIHRoZSBwYXJhbWV0ZXIgdG8gYWxsIG1vdXNlL3BvaW50ZXIvdG91Y2ggcmVsYXRlZCBldmVudHMuIEZvciBhIGxpc3Rpbmcgb2YgbW91c2UgZXZlbnRzIGFuZCB0aGVpciBwcm9wZXJ0aWVzLFxuXHQgKiBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3RcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IGxpc3RpbmdzLlxuXHQgKiBAY2xhc3MgTW91c2VFdmVudFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBidWJibGVzIEluZGljYXRlcyB3aGV0aGVyIHRoZSBldmVudCB3aWxsIGJ1YmJsZSB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FuY2VsYWJsZSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdGhpcyBldmVudCBjYW4gYmUgY2FuY2VsbGVkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhZ2VYIFRoZSBub3JtYWxpemVkIHggcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHN0YWdlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhZ2VZIFRoZSBub3JtYWxpemVkIHkgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHN0YWdlLlxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IG5hdGl2ZUV2ZW50IFRoZSBuYXRpdmUgRE9NIGV2ZW50IHJlbGF0ZWQgdG8gdGhpcyBtb3VzZSBldmVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50ZXJJRCBUaGUgdW5pcXVlIGlkIGZvciB0aGUgcG9pbnRlci5cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmltYXJ5IEluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgdGhlIHByaW1hcnkgcG9pbnRlciBpbiBhIG11bHRpdG91Y2ggZW52aXJvbm1lbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYXdYIFRoZSByYXcgeCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhZ2UuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYXdZIFRoZSByYXcgeSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhZ2UuXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gcmVsYXRlZFRhcmdldCBUaGUgc2Vjb25kYXJ5IHRhcmdldCBmb3IgdGhlIGV2ZW50LlxuXHQgKiBAZXh0ZW5kcyBFdmVudFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBNb3VzZUV2ZW50KHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUsIHN0YWdlWCwgc3RhZ2VZLCBuYXRpdmVFdmVudCwgcG9pbnRlcklELCBwcmltYXJ5LCByYXdYLCByYXdZLCByZWxhdGVkVGFyZ2V0KSB7XG5cdFx0dGhpcy5FdmVudF9jb25zdHJ1Y3Rvcih0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlKTtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIG5vcm1hbGl6ZWQgeCBwb3NpdGlvbiBvbiB0aGUgc3RhZ2UuIFRoaXMgd2lsbCBhbHdheXMgYmUgd2l0aGluIHRoZSByYW5nZSAwIHRvIHN0YWdlIHdpZHRoLlxuXHRcdCAqIEBwcm9wZXJ0eSBzdGFnZVhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQqL1xuXHRcdHRoaXMuc3RhZ2VYID0gc3RhZ2VYO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgbm9ybWFsaXplZCB5IHBvc2l0aW9uIG9uIHRoZSBzdGFnZS4gVGhpcyB3aWxsIGFsd2F5cyBiZSB3aXRoaW4gdGhlIHJhbmdlIDAgdG8gc3RhZ2UgaGVpZ2h0LlxuXHRcdCAqIEBwcm9wZXJ0eSBzdGFnZVlcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5zdGFnZVkgPSBzdGFnZVk7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSByYXcgeCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhZ2UuIE5vcm1hbGx5IHRoaXMgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgc3RhZ2VYIHZhbHVlLCB1bmxlc3Ncblx0XHQgKiBzdGFnZS5tb3VzZU1vdmVPdXRzaWRlIGlzIHRydWUgYW5kIHRoZSBwb2ludGVyIGlzIG91dHNpZGUgb2YgdGhlIHN0YWdlIGJvdW5kcy5cblx0XHQgKiBAcHJvcGVydHkgcmF3WFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCovXG5cdFx0dGhpcy5yYXdYID0gKHJhd1g9PW51bGwpP3N0YWdlWDpyYXdYO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgcmF3IHkgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHN0YWdlLiBOb3JtYWxseSB0aGlzIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIHN0YWdlWSB2YWx1ZSwgdW5sZXNzXG5cdFx0ICogc3RhZ2UubW91c2VNb3ZlT3V0c2lkZSBpcyB0cnVlIGFuZCB0aGUgcG9pbnRlciBpcyBvdXRzaWRlIG9mIHRoZSBzdGFnZSBib3VuZHMuXG5cdFx0ICogQHByb3BlcnR5IHJhd1lcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQqL1xuXHRcdHRoaXMucmF3WSA9IChyYXdZPT1udWxsKT9zdGFnZVk6cmF3WTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIG5hdGl2ZSBNb3VzZUV2ZW50IGdlbmVyYXRlZCBieSB0aGUgYnJvd3Nlci4gVGhlIHByb3BlcnRpZXMgYW5kIEFQSSBmb3IgdGhpc1xuXHRcdCAqIGV2ZW50IG1heSBkaWZmZXIgYmV0d2VlbiBicm93c2Vycy4gVGhpcyBwcm9wZXJ0eSB3aWxsIGJlIG51bGwgaWYgdGhlXG5cdFx0ICogRWFzZWxKUyBwcm9wZXJ0eSB3YXMgbm90IGRpcmVjdGx5IGdlbmVyYXRlZCBmcm9tIGEgbmF0aXZlIE1vdXNlRXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IG5hdGl2ZUV2ZW50XG5cdFx0ICogQHR5cGUgSHRtbE1vdXNlRXZlbnRcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHVuaXF1ZSBpZCBmb3IgdGhlIHBvaW50ZXIgKHRvdWNoIHBvaW50IG9yIGN1cnNvcikuIFRoaXMgd2lsbCBiZSBlaXRoZXIgLTEgZm9yIHRoZSBtb3VzZSwgb3IgdGhlIHN5c3RlbVxuXHRcdCAqIHN1cHBsaWVkIGlkIHZhbHVlLlxuXHRcdCAqIEBwcm9wZXJ0eSBwb2ludGVySURcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMucG9pbnRlcklEID0gcG9pbnRlcklEO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIHRoZSBwcmltYXJ5IHBvaW50ZXIgaW4gYSBtdWx0aXRvdWNoIGVudmlyb25tZW50LiBUaGlzIHdpbGwgYWx3YXlzIGJlIHRydWUgZm9yIHRoZSBtb3VzZS5cblx0XHQgKiBGb3IgdG91Y2ggcG9pbnRlcnMsIHRoZSBmaXJzdCBwb2ludGVyIGluIHRoZSBjdXJyZW50IHN0YWNrIHdpbGwgYmUgY29uc2lkZXJlZCB0aGUgcHJpbWFyeSBwb2ludGVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBwcmltYXJ5XG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0dGhpcy5wcmltYXJ5ID0gISFwcmltYXJ5O1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBzZWNvbmRhcnkgdGFyZ2V0IGZvciB0aGUgZXZlbnQsIGlmIGFwcGxpY2FibGUuIFRoaXMgaXMgdXNlZCBmb3IgbW91c2VvdXQvcm9sbG91dFxuXHRcdCAqIGV2ZW50cyB0byBpbmRpY2F0ZSB0aGUgb2JqZWN0IHRoYXQgdGhlIG1vdXNlIGVudGVyZWQgZnJvbSwgbW91c2VvdmVyL3JvbGxvdmVyIGZvciB0aGUgb2JqZWN0IHRoZSBtb3VzZSBleGl0ZWQsXG5cdFx0ICogYW5kIHN0YWdlbW91c2Vkb3duL3N0YWdlbW91c2V1cCBldmVudHMgZm9yIHRoZSBvYmplY3QgdGhhdCB3YXMgdGhlIHVuZGVyIHRoZSBjdXJzb3IsIGlmIGFueS5cblx0XHQgKiBcblx0XHQgKiBPbmx5IHZhbGlkIGludGVyYWN0aW9uIHRhcmdldHMgd2lsbCBiZSByZXR1cm5lZCAoaWUuIG9iamVjdHMgd2l0aCBtb3VzZSBsaXN0ZW5lcnMgb3IgYSBjdXJzb3Igc2V0KS5cblx0XHQgKiBAcHJvcGVydHkgcmVsYXRlZFRhcmdldFxuXHRcdCAqIEB0eXBlIHtEaXNwbGF5T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHJlbGF0ZWRUYXJnZXQ7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoTW91c2VFdmVudCwgY3JlYXRlanMuRXZlbnQpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXHRcblx0XG4vLyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgbW91c2UgaW4gdGhlIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtIG9mIHRoZSBjdXJyZW50IHRhcmdldCAoaWUuIHRoZSBkaXNwYXRjaGVyKS5cblx0ICogQHByb3BlcnR5IGxvY2FsWFxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcmVhZG9ubHlcblx0ICovXG5cdHAuX2dldF9sb2NhbFggPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jdXJyZW50VGFyZ2V0Lmdsb2JhbFRvTG9jYWwodGhpcy5yYXdYLCB0aGlzLnJhd1kpLng7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgeSBwb3NpdGlvbiBvZiB0aGUgbW91c2UgaW4gdGhlIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtIG9mIHRoZSBjdXJyZW50IHRhcmdldCAoaWUuIHRoZSBkaXNwYXRjaGVyKS5cblx0ICogQHByb3BlcnR5IGxvY2FsWVxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcmVhZG9ubHlcblx0ICovXG5cdHAuX2dldF9sb2NhbFkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jdXJyZW50VGFyZ2V0Lmdsb2JhbFRvTG9jYWwodGhpcy5yYXdYLCB0aGlzLnJhd1kpLnk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50IHdhcyBnZW5lcmF0ZWQgYnkgYSB0b3VjaCBpbnB1dCAodmVyc3VzIGEgbW91c2UgaW5wdXQpLlxuXHQgKiBAcHJvcGVydHkgaXNUb3VjaFxuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQHJlYWRvbmx5XG5cdCAqL1xuXHRwLl9nZXRfaXNUb3VjaCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnBvaW50ZXJJRCAhPT0gLTE7XG5cdH07XG5cdFxuXHRcblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cdFx0XHRsb2NhbFg6IHsgZ2V0OiBwLl9nZXRfbG9jYWxYIH0sXG5cdFx0XHRsb2NhbFk6IHsgZ2V0OiBwLl9nZXRfbG9jYWxZIH0sXG5cdFx0XHRpc1RvdWNoOiB7IGdldDogcC5fZ2V0X2lzVG91Y2ggfVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlKSB7fSAvLyBUT0RPOiB1c2UgTG9nXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIE1vdXNlRXZlbnQgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7TW91c2VFdmVudH0gYSBjbG9uZSBvZiB0aGUgTW91c2VFdmVudCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBNb3VzZUV2ZW50KHRoaXMudHlwZSwgdGhpcy5idWJibGVzLCB0aGlzLmNhbmNlbGFibGUsIHRoaXMuc3RhZ2VYLCB0aGlzLnN0YWdlWSwgdGhpcy5uYXRpdmVFdmVudCwgdGhpcy5wb2ludGVySUQsIHRoaXMucHJpbWFyeSwgdGhpcy5yYXdYLCB0aGlzLnJhd1kpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbTW91c2VFdmVudCAodHlwZT1cIit0aGlzLnR5cGUrXCIgc3RhZ2VYPVwiK3RoaXMuc3RhZ2VYK1wiIHN0YWdlWT1cIit0aGlzLnN0YWdlWStcIildXCI7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5Nb3VzZUV2ZW50ID0gY3JlYXRlanMucHJvbW90ZShNb3VzZUV2ZW50LCBcIkV2ZW50XCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIE1hdHJpeDJELmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogUmVwcmVzZW50cyBhbiBhZmZpbmUgdHJhbnNmb3JtYXRpb24gbWF0cml4LCBhbmQgcHJvdmlkZXMgdG9vbHMgZm9yIGNvbnN0cnVjdGluZyBhbmQgY29uY2F0ZW5hdGluZyBtYXRyaWNlcy5cblx0ICpcblx0ICogVGhpcyBtYXRyaXggY2FuIGJlIHZpc3VhbGl6ZWQgYXM6XG5cdCAqXG5cdCAqIFx0WyBhICBjICB0eFxuXHQgKiBcdCAgYiAgZCAgdHlcblx0ICogXHQgIDAgIDAgIDEgIF1cblx0ICpcblx0ICogTm90ZSB0aGUgbG9jYXRpb25zIG9mIGIgYW5kIGMuXG5cdCAqXG5cdCAqIEBjbGFzcyBNYXRyaXgyRFxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2E9MV0gU3BlY2lmaWVzIHRoZSBhIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtiPTBdIFNwZWNpZmllcyB0aGUgYiBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYz0wXSBTcGVjaWZpZXMgdGhlIGMgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2Q9MV0gU3BlY2lmaWVzIHRoZSBkIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0eD0wXSBTcGVjaWZpZXMgdGhlIHR4IHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0eT0wXSBTcGVjaWZpZXMgdGhlIHR5IHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gTWF0cml4MkQoYSwgYiwgYywgZCwgdHgsIHR5KSB7XG5cdFx0dGhpcy5zZXRWYWx1ZXMoYSxiLGMsZCx0eCx0eSk7XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8vIGFzc2lnbmVkIGluIHRoZSBzZXRWYWx1ZXMgbWV0aG9kLlxuXHRcdC8qKlxuXHRcdCAqIFBvc2l0aW9uICgwLCAwKSBpbiBhIDN4MyBhZmZpbmUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuXHRcdCAqIEBwcm9wZXJ0eSBhXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBQb3NpdGlvbiAoMCwgMSkgaW4gYSAzeDMgYWZmaW5lIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cblx0XHQgKiBAcHJvcGVydHkgYlxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogUG9zaXRpb24gKDEsIDApIGluIGEgM3gzIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG5cdFx0ICogQHByb3BlcnR5IGNcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBvc2l0aW9uICgxLCAxKSBpbiBhIDN4MyBhZmZpbmUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuXHRcdCAqIEBwcm9wZXJ0eSBkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBQb3NpdGlvbiAoMiwgMCkgaW4gYSAzeDMgYWZmaW5lIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cblx0XHQgKiBAcHJvcGVydHkgdHhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBvc2l0aW9uICgyLCAxKSBpbiBhIDN4MyBhZmZpbmUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuXHRcdCAqIEBwcm9wZXJ0eSB0eVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0fVxuXHR2YXIgcCA9IE1hdHJpeDJELnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblxuLy8gY29uc3RhbnRzOlxuXHQvKipcblx0ICogTXVsdGlwbGllciBmb3IgY29udmVydGluZyBkZWdyZWVzIHRvIHJhZGlhbnMuIFVzZWQgaW50ZXJuYWxseSBieSBNYXRyaXgyRC5cblx0ICogQHByb3BlcnR5IERFR19UT19SQURcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdE1hdHJpeDJELkRFR19UT19SQUQgPSBNYXRoLlBJLzE4MDtcblxuXG4vLyBzdGF0aWMgcHVibGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBBbiBpZGVudGl0eSBtYXRyaXgsIHJlcHJlc2VudGluZyBhIG51bGwgdHJhbnNmb3JtYXRpb24uXG5cdCAqIEBwcm9wZXJ0eSBpZGVudGl0eVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIE1hdHJpeDJEXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdE1hdHJpeDJELmlkZW50aXR5ID0gbnVsbDsgLy8gc2V0IGF0IGJvdHRvbSBvZiBjbGFzcyBkZWZpbml0aW9uLlxuXHRcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBzcGVjaWZpZWQgdmFsdWVzIG9uIHRoaXMgaW5zdGFuY2UuIFxuXHQgKiBAbWV0aG9kIHNldFZhbHVlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW2E9MV0gU3BlY2lmaWVzIHRoZSBhIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtiPTBdIFNwZWNpZmllcyB0aGUgYiBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYz0wXSBTcGVjaWZpZXMgdGhlIGMgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2Q9MV0gU3BlY2lmaWVzIHRoZSBkIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0eD0wXSBTcGVjaWZpZXMgdGhlIHR4IHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0eT0wXSBTcGVjaWZpZXMgdGhlIHR5IHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQqL1xuXHRwLnNldFZhbHVlcyA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuXHRcdC8vIGRvbid0IGZvcmdldCB0byB1cGRhdGUgZG9jcyBpbiB0aGUgY29uc3RydWN0b3IgaWYgdGhlc2UgY2hhbmdlOlxuXHRcdHRoaXMuYSA9IChhID09IG51bGwpID8gMSA6IGE7XG5cdFx0dGhpcy5iID0gYiB8fCAwO1xuXHRcdHRoaXMuYyA9IGMgfHwgMDtcblx0XHR0aGlzLmQgPSAoZCA9PSBudWxsKSA/IDEgOiBkO1xuXHRcdHRoaXMudHggPSB0eCB8fCAwO1xuXHRcdHRoaXMudHkgPSB0eSB8fCAwO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBcHBlbmRzIHRoZSBzcGVjaWZpZWQgbWF0cml4IHByb3BlcnRpZXMgdG8gdGhpcyBtYXRyaXguIEFsbCBwYXJhbWV0ZXJzIGFyZSByZXF1aXJlZC5cblx0ICogVGhpcyBpcyB0aGUgZXF1aXZhbGVudCBvZiBtdWx0aXBseWluZyBgKHRoaXMgbWF0cml4KSAqIChzcGVjaWZpZWQgbWF0cml4KWAuXG5cdCAqIEBtZXRob2QgYXBwZW5kXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBiXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0eFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdHlcblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLmFwcGVuZCA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuXHRcdHZhciBhMSA9IHRoaXMuYTtcblx0XHR2YXIgYjEgPSB0aGlzLmI7XG5cdFx0dmFyIGMxID0gdGhpcy5jO1xuXHRcdHZhciBkMSA9IHRoaXMuZDtcblx0XHRpZiAoYSAhPSAxIHx8IGIgIT0gMCB8fCBjICE9IDAgfHwgZCAhPSAxKSB7XG5cdFx0XHR0aGlzLmEgID0gYTEqYStjMSpiO1xuXHRcdFx0dGhpcy5iICA9IGIxKmErZDEqYjtcblx0XHRcdHRoaXMuYyAgPSBhMSpjK2MxKmQ7XG5cdFx0XHR0aGlzLmQgID0gYjEqYytkMSpkO1xuXHRcdH1cblx0XHR0aGlzLnR4ID0gYTEqdHgrYzEqdHkrdGhpcy50eDtcblx0XHR0aGlzLnR5ID0gYjEqdHgrZDEqdHkrdGhpcy50eTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUHJlcGVuZHMgdGhlIHNwZWNpZmllZCBtYXRyaXggcHJvcGVydGllcyB0byB0aGlzIG1hdHJpeC5cblx0ICogVGhpcyBpcyB0aGUgZXF1aXZhbGVudCBvZiBtdWx0aXBseWluZyBgKHNwZWNpZmllZCBtYXRyaXgpICogKHRoaXMgbWF0cml4KWAuXG5cdCAqIEFsbCBwYXJhbWV0ZXJzIGFyZSByZXF1aXJlZC5cblx0ICogQG1ldGhvZCBwcmVwZW5kXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBiXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0eFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdHlcblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLnByZXBlbmQgPSBmdW5jdGlvbihhLCBiLCBjLCBkLCB0eCwgdHkpIHtcblx0XHR2YXIgYTEgPSB0aGlzLmE7XG5cdFx0dmFyIGMxID0gdGhpcy5jO1xuXHRcdHZhciB0eDEgPSB0aGlzLnR4O1xuXG5cdFx0dGhpcy5hICA9IGEqYTErYyp0aGlzLmI7XG5cdFx0dGhpcy5iICA9IGIqYTErZCp0aGlzLmI7XG5cdFx0dGhpcy5jICA9IGEqYzErYyp0aGlzLmQ7XG5cdFx0dGhpcy5kICA9IGIqYzErZCp0aGlzLmQ7XG5cdFx0dGhpcy50eCA9IGEqdHgxK2MqdGhpcy50eSt0eDtcblx0XHR0aGlzLnR5ID0gYip0eDErZCp0aGlzLnR5K3R5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBcHBlbmRzIHRoZSBzcGVjaWZpZWQgbWF0cml4IHRvIHRoaXMgbWF0cml4LlxuXHQgKiBUaGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIG11bHRpcGx5aW5nIGAodGhpcyBtYXRyaXgpICogKHNwZWNpZmllZCBtYXRyaXgpYC5cblx0ICogQG1ldGhvZCBhcHBlbmRNYXRyaXhcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4XG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5hcHBlbmRNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobWF0cml4LmEsIG1hdHJpeC5iLCBtYXRyaXguYywgbWF0cml4LmQsIG1hdHJpeC50eCwgbWF0cml4LnR5KTtcblx0fTtcblxuXHQvKipcblx0ICogUHJlcGVuZHMgdGhlIHNwZWNpZmllZCBtYXRyaXggdG8gdGhpcyBtYXRyaXguXG5cdCAqIFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgbXVsdGlwbHlpbmcgYChzcGVjaWZpZWQgbWF0cml4KSAqICh0aGlzIG1hdHJpeClgLlxuXHQgKiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIGNhbGN1bGF0ZSB0aGUgY29tYmluZWQgdHJhbnNmb3JtYXRpb24gZm9yIGEgY2hpbGQgb2JqZWN0IHVzaW5nOlxuXHQgKiBcblx0ICogXHR2YXIgbyA9IG15RGlzcGxheU9iamVjdDtcblx0ICogXHR2YXIgbXR4ID0gby5nZXRNYXRyaXgoKTtcblx0ICogXHR3aGlsZSAobyA9IG8ucGFyZW50KSB7XG5cdCAqIFx0XHQvLyBwcmVwZW5kIGVhY2ggcGFyZW50J3MgdHJhbnNmb3JtYXRpb24gaW4gdHVybjpcblx0ICogXHRcdG8ucHJlcGVuZE1hdHJpeChvLmdldE1hdHJpeCgpKTtcblx0ICogXHR9XG5cdCAqIEBtZXRob2QgcHJlcGVuZE1hdHJpeFxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXhcblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLnByZXBlbmRNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmVwZW5kKG1hdHJpeC5hLCBtYXRyaXguYiwgbWF0cml4LmMsIG1hdHJpeC5kLCBtYXRyaXgudHgsIG1hdHJpeC50eSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBtYXRyaXggcHJvcGVydGllcyBmcm9tIHRoZSBzcGVjaWZpZWQgZGlzcGxheSBvYmplY3QgdHJhbnNmb3JtIHByb3BlcnRpZXMsIGFuZCBhcHBlbmRzIHRoZW0gdG8gdGhpcyBtYXRyaXguXG5cdCAqIEZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSB0aGlzIHRvIGdlbmVyYXRlIGEgbWF0cml4IHJlcHJlc2VudGluZyB0aGUgdHJhbnNmb3JtYXRpb25zIG9mIGEgZGlzcGxheSBvYmplY3Q6XG5cdCAqIFxuXHQgKiBcdHZhciBtdHggPSBuZXcgY3JlYXRlanMuTWF0cml4MkQoKTtcblx0ICogXHRtdHguYXBwZW5kVHJhbnNmb3JtKG8ueCwgby55LCBvLnNjYWxlWCwgby5zY2FsZVksIG8ucm90YXRpb24pO1xuXHQgKiBAbWV0aG9kIGFwcGVuZFRyYW5zZm9ybVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVYXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJvdGF0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBza2V3WFxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2tld1lcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJlZ1ggT3B0aW9uYWwuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByZWdZIE9wdGlvbmFsLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAuYXBwZW5kVHJhbnNmb3JtID0gZnVuY3Rpb24oeCwgeSwgc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uLCBza2V3WCwgc2tld1ksIHJlZ1gsIHJlZ1kpIHtcblx0XHRpZiAocm90YXRpb24lMzYwKSB7XG5cdFx0XHR2YXIgciA9IHJvdGF0aW9uKk1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0XHR2YXIgY29zID0gTWF0aC5jb3Mocik7XG5cdFx0XHR2YXIgc2luID0gTWF0aC5zaW4ocik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvcyA9IDE7XG5cdFx0XHRzaW4gPSAwO1xuXHRcdH1cblxuXHRcdGlmIChza2V3WCB8fCBza2V3WSkge1xuXHRcdFx0Ly8gVE9ETzogY2FuIHRoaXMgYmUgY29tYmluZWQgaW50byBhIHNpbmdsZSBhcHBlbmQgb3BlcmF0aW9uP1xuXHRcdFx0c2tld1ggKj0gTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRcdHNrZXdZICo9IE1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0XHR0aGlzLmFwcGVuZChNYXRoLmNvcyhza2V3WSksIE1hdGguc2luKHNrZXdZKSwgLU1hdGguc2luKHNrZXdYKSwgTWF0aC5jb3Moc2tld1gpLCB4LCB5KTtcblx0XHRcdHRoaXMuYXBwZW5kKGNvcypzY2FsZVgsIHNpbipzY2FsZVgsIC1zaW4qc2NhbGVZLCBjb3Mqc2NhbGVZLCAwLCAwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5hcHBlbmQoY29zKnNjYWxlWCwgc2luKnNjYWxlWCwgLXNpbipzY2FsZVksIGNvcypzY2FsZVksIHgsIHkpO1xuXHRcdH1cblx0XHRcblx0XHRpZiAocmVnWCB8fCByZWdZKSB7XG5cdFx0XHQvLyBhcHBlbmQgdGhlIHJlZ2lzdHJhdGlvbiBvZmZzZXQ6XG5cdFx0XHR0aGlzLnR4IC09IHJlZ1gqdGhpcy5hK3JlZ1kqdGhpcy5jOyBcblx0XHRcdHRoaXMudHkgLT0gcmVnWCp0aGlzLmIrcmVnWSp0aGlzLmQ7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgbWF0cml4IHByb3BlcnRpZXMgZnJvbSB0aGUgc3BlY2lmaWVkIGRpc3BsYXkgb2JqZWN0IHRyYW5zZm9ybSBwcm9wZXJ0aWVzLCBhbmQgcHJlcGVuZHMgdGhlbSB0byB0aGlzIG1hdHJpeC5cblx0ICogRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCBjYWxjdWxhdGUgdGhlIGNvbWJpbmVkIHRyYW5zZm9ybWF0aW9uIGZvciBhIGNoaWxkIG9iamVjdCB1c2luZzpcblx0ICogXG5cdCAqIFx0dmFyIG8gPSBteURpc3BsYXlPYmplY3Q7XG5cdCAqIFx0dmFyIG10eCA9IG5ldyBjcmVhdGVqcy5NYXRyaXgyRCgpO1xuXHQgKiBcdGRvICB7XG5cdCAqIFx0XHQvLyBwcmVwZW5kIGVhY2ggcGFyZW50J3MgdHJhbnNmb3JtYXRpb24gaW4gdHVybjpcblx0ICogXHRcdG10eC5wcmVwZW5kVHJhbnNmb3JtKG8ueCwgby55LCBvLnNjYWxlWCwgby5zY2FsZVksIG8ucm90YXRpb24sIG8uc2tld1gsIG8uc2tld1ksIG8ucmVnWCwgby5yZWdZKTtcblx0ICogXHR9IHdoaWxlIChvID0gby5wYXJlbnQpO1xuXHQgKiBcdFxuXHQgKiBcdE5vdGUgdGhhdCB0aGUgYWJvdmUgZXhhbXBsZSB3b3VsZCBub3QgYWNjb3VudCBmb3Ige3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC90cmFuc2Zvcm1NYXRyaXg6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogXHR2YWx1ZXMuIFNlZSB7eyNjcm9zc0xpbmsgXCJNYXRyaXgyRC9wcmVwZW5kTWF0cml4XCJ9fXt7L2Nyb3NzTGlua319IGZvciBhbiBleGFtcGxlIHRoYXQgZG9lcy5cblx0ICogQG1ldGhvZCBwcmVwZW5kVHJhbnNmb3JtXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcm90YXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNrZXdYXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBza2V3WVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmVnWCBPcHRpb25hbC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJlZ1kgT3B0aW9uYWwuXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5wcmVwZW5kVHJhbnNmb3JtID0gZnVuY3Rpb24oeCwgeSwgc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uLCBza2V3WCwgc2tld1ksIHJlZ1gsIHJlZ1kpIHtcblx0XHRpZiAocm90YXRpb24lMzYwKSB7XG5cdFx0XHR2YXIgciA9IHJvdGF0aW9uKk1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0XHR2YXIgY29zID0gTWF0aC5jb3Mocik7XG5cdFx0XHR2YXIgc2luID0gTWF0aC5zaW4ocik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvcyA9IDE7XG5cdFx0XHRzaW4gPSAwO1xuXHRcdH1cblxuXHRcdGlmIChyZWdYIHx8IHJlZ1kpIHtcblx0XHRcdC8vIHByZXBlbmQgdGhlIHJlZ2lzdHJhdGlvbiBvZmZzZXQ6XG5cdFx0XHR0aGlzLnR4IC09IHJlZ1g7IHRoaXMudHkgLT0gcmVnWTtcblx0XHR9XG5cdFx0aWYgKHNrZXdYIHx8IHNrZXdZKSB7XG5cdFx0XHQvLyBUT0RPOiBjYW4gdGhpcyBiZSBjb21iaW5lZCBpbnRvIGEgc2luZ2xlIHByZXBlbmQgb3BlcmF0aW9uP1xuXHRcdFx0c2tld1ggKj0gTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRcdHNrZXdZICo9IE1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0XHR0aGlzLnByZXBlbmQoY29zKnNjYWxlWCwgc2luKnNjYWxlWCwgLXNpbipzY2FsZVksIGNvcypzY2FsZVksIDAsIDApO1xuXHRcdFx0dGhpcy5wcmVwZW5kKE1hdGguY29zKHNrZXdZKSwgTWF0aC5zaW4oc2tld1kpLCAtTWF0aC5zaW4oc2tld1gpLCBNYXRoLmNvcyhza2V3WCksIHgsIHkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnByZXBlbmQoY29zKnNjYWxlWCwgc2luKnNjYWxlWCwgLXNpbipzY2FsZVksIGNvcypzY2FsZVksIHgsIHkpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQXBwbGllcyBhIGNsb2Nrd2lzZSByb3RhdGlvbiB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgbWF0cml4LlxuXHQgKiBAbWV0aG9kIHJvdGF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgaW4gZGVncmVlcy4gVG8gdXNlIGEgdmFsdWUgaW4gcmFkaWFucywgbXVsdGlwbHkgaXQgYnkgYDE4MC9NYXRoLlBJYC5cblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLnJvdGF0ZSA9IGZ1bmN0aW9uKGFuZ2xlKSB7XG5cdFx0YW5nbGUgPSBhbmdsZSpNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0dmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcblxuXHRcdHZhciBhMSA9IHRoaXMuYTtcblx0XHR2YXIgYjEgPSB0aGlzLmI7XG5cblx0XHR0aGlzLmEgPSBhMSpjb3MrdGhpcy5jKnNpbjtcblx0XHR0aGlzLmIgPSBiMSpjb3MrdGhpcy5kKnNpbjtcblx0XHR0aGlzLmMgPSAtYTEqc2luK3RoaXMuYypjb3M7XG5cdFx0dGhpcy5kID0gLWIxKnNpbit0aGlzLmQqY29zO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIGEgc2tldyB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgbWF0cml4LlxuXHQgKiBAbWV0aG9kIHNrZXdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNrZXdYIFRoZSBhbW91bnQgdG8gc2tldyBob3Jpem9udGFsbHkgaW4gZGVncmVlcy4gVG8gdXNlIGEgdmFsdWUgaW4gcmFkaWFucywgbXVsdGlwbHkgaXQgYnkgYDE4MC9NYXRoLlBJYC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNrZXdZIFRoZSBhbW91bnQgdG8gc2tldyB2ZXJ0aWNhbGx5IGluIGRlZ3JlZXMuXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCovXG5cdHAuc2tldyA9IGZ1bmN0aW9uKHNrZXdYLCBza2V3WSkge1xuXHRcdHNrZXdYID0gc2tld1gqTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRza2V3WSA9IHNrZXdZKk1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0dGhpcy5hcHBlbmQoTWF0aC5jb3Moc2tld1kpLCBNYXRoLnNpbihza2V3WSksIC1NYXRoLnNpbihza2V3WCksIE1hdGguY29zKHNrZXdYKSwgMCwgMCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgYSBzY2FsZSB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgbWF0cml4LlxuXHQgKiBAbWV0aG9kIHNjYWxlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBhbW91bnQgdG8gc2NhbGUgaG9yaXpvbnRhbGx5LiBFLkcuIGEgdmFsdWUgb2YgMiB3aWxsIGRvdWJsZSB0aGUgc2l6ZSBpbiB0aGUgWCBkaXJlY3Rpb24sIGFuZCAwLjUgd2lsbCBoYWx2ZSBpdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIGFtb3VudCB0byBzY2FsZSB2ZXJ0aWNhbGx5LlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAuc2NhbGUgPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0dGhpcy5hICo9IHg7XG5cdFx0dGhpcy5iICo9IHg7XG5cdFx0dGhpcy5jICo9IHk7XG5cdFx0dGhpcy5kICo9IHk7XG5cdFx0Ly90aGlzLnR4ICo9IHg7XG5cdFx0Ly90aGlzLnR5ICo9IHk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRyYW5zbGF0ZXMgdGhlIG1hdHJpeCBvbiB0aGUgeCBhbmQgeSBheGVzLlxuXHQgKiBAbWV0aG9kIHRyYW5zbGF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAudHJhbnNsYXRlID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMudHggKz0gdGhpcy5hKnggKyB0aGlzLmMqeTtcblx0XHR0aGlzLnR5ICs9IHRoaXMuYip4ICsgdGhpcy5kKnk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIG1hdHJpeCB0byB0aG9zZSBvZiBhbiBpZGVudGl0eSBtYXRyaXggKG9uZSB0aGF0IGFwcGxpZXMgYSBudWxsIHRyYW5zZm9ybWF0aW9uKS5cblx0ICogQG1ldGhvZCBpZGVudGl0eVxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAuaWRlbnRpdHkgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmEgPSB0aGlzLmQgPSAxO1xuXHRcdHRoaXMuYiA9IHRoaXMuYyA9IHRoaXMudHggPSB0aGlzLnR5ID0gMDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogSW52ZXJ0cyB0aGUgbWF0cml4LCBjYXVzaW5nIGl0IHRvIHBlcmZvcm0gdGhlIG9wcG9zaXRlIHRyYW5zZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIGludmVydFxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAuaW52ZXJ0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGExID0gdGhpcy5hO1xuXHRcdHZhciBiMSA9IHRoaXMuYjtcblx0XHR2YXIgYzEgPSB0aGlzLmM7XG5cdFx0dmFyIGQxID0gdGhpcy5kO1xuXHRcdHZhciB0eDEgPSB0aGlzLnR4O1xuXHRcdHZhciBuID0gYTEqZDEtYjEqYzE7XG5cblx0XHR0aGlzLmEgPSBkMS9uO1xuXHRcdHRoaXMuYiA9IC1iMS9uO1xuXHRcdHRoaXMuYyA9IC1jMS9uO1xuXHRcdHRoaXMuZCA9IGExL247XG5cdFx0dGhpcy50eCA9IChjMSp0aGlzLnR5LWQxKnR4MSkvbjtcblx0XHR0aGlzLnR5ID0gLShhMSp0aGlzLnR5LWIxKnR4MSkvbjtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBtYXRyaXggaXMgYW4gaWRlbnRpdHkgbWF0cml4LlxuXHQgKiBAbWV0aG9kIGlzSWRlbnRpdHlcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICoqL1xuXHRwLmlzSWRlbnRpdHkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50eCA9PT0gMCAmJiB0aGlzLnR5ID09PSAwICYmIHRoaXMuYSA9PT0gMSAmJiB0aGlzLmIgPT09IDAgJiYgdGhpcy5jID09PSAwICYmIHRoaXMuZCA9PT0gMTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBtYXRyaXggaXMgZXF1YWwgdG8gdGhlIHNwZWNpZmllZCBtYXRyaXggKGFsbCBwcm9wZXJ0eSB2YWx1ZXMgYXJlIGVxdWFsKS5cblx0ICogQG1ldGhvZCBlcXVhbHNcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4IFRoZSBtYXRyaXggdG8gY29tcGFyZS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICoqL1xuXHRwLmVxdWFscyA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHJldHVybiB0aGlzLnR4ID09PSBtYXRyaXgudHggJiYgdGhpcy50eSA9PT0gbWF0cml4LnR5ICYmIHRoaXMuYSA9PT0gbWF0cml4LmEgJiYgdGhpcy5iID09PSBtYXRyaXguYiAmJiB0aGlzLmMgPT09IG1hdHJpeC5jICYmIHRoaXMuZCA9PT0gbWF0cml4LmQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRyYW5zZm9ybXMgYSBwb2ludCBhY2NvcmRpbmcgdG8gdGhpcyBtYXRyaXguXG5cdCAqIEBtZXRob2QgdHJhbnNmb3JtUG9pbnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggY29tcG9uZW50IG9mIHRoZSBwb2ludCB0byB0cmFuc2Zvcm0uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgcG9pbnQgdG8gdHJhbnNmb3JtLlxuXHQgKiBAcGFyYW0ge1BvaW50IHwgT2JqZWN0fSBbcHRdIEFuIG9iamVjdCB0byBjb3B5IHRoZSByZXN1bHQgaW50by4gSWYgb21pdHRlZCBhIGdlbmVyaWMgb2JqZWN0IHdpdGggeC95IHByb3BlcnRpZXMgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7UG9pbnR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLnRyYW5zZm9ybVBvaW50ID0gZnVuY3Rpb24oeCwgeSwgcHQpIHtcblx0XHRwdCA9IHB0fHx7fTtcblx0XHRwdC54ID0geCp0aGlzLmEreSp0aGlzLmMrdGhpcy50eDtcblx0XHRwdC55ID0geCp0aGlzLmIreSp0aGlzLmQrdGhpcy50eTtcblx0XHRyZXR1cm4gcHQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIERlY29tcG9zZXMgdGhlIG1hdHJpeCBpbnRvIHRyYW5zZm9ybSBwcm9wZXJ0aWVzICh4LCB5LCBzY2FsZVgsIHNjYWxlWSwgYW5kIHJvdGF0aW9uKS4gTm90ZSB0aGF0IHRoZXNlIHZhbHVlc1xuXHQgKiBtYXkgbm90IG1hdGNoIHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcyB5b3UgdXNlZCB0byBnZW5lcmF0ZSB0aGUgbWF0cml4LCB0aG91Z2ggdGhleSB3aWxsIHByb2R1Y2UgdGhlIHNhbWUgdmlzdWFsXG5cdCAqIHJlc3VsdHMuXG5cdCAqIEBtZXRob2QgZGVjb21wb3NlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0byBhcHBseSB0aGUgdHJhbnNmb3JtIHByb3BlcnRpZXMgdG8uIElmIG51bGwsIHRoZW4gYSBuZXcgb2JqZWN0IHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIHRhcmdldCwgb3IgYSBuZXcgZ2VuZXJpYyBvYmplY3Qgd2l0aCB0aGUgdHJhbnNmb3JtIHByb3BlcnRpZXMgYXBwbGllZC5cblx0Ki9cblx0cC5kZWNvbXBvc2UgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHQvLyBUT0RPOiBpdCB3b3VsZCBiZSBuaWNlIHRvIGJlIGFibGUgdG8gc29sdmUgZm9yIHdoZXRoZXIgdGhlIG1hdHJpeCBjYW4gYmUgZGVjb21wb3NlZCBpbnRvIG9ubHkgc2NhbGUvcm90YXRpb24gZXZlbiB3aGVuIHNjYWxlIGlzIG5lZ2F0aXZlXG5cdFx0aWYgKHRhcmdldCA9PSBudWxsKSB7IHRhcmdldCA9IHt9OyB9XG5cdFx0dGFyZ2V0LnggPSB0aGlzLnR4O1xuXHRcdHRhcmdldC55ID0gdGhpcy50eTtcblx0XHR0YXJnZXQuc2NhbGVYID0gTWF0aC5zcXJ0KHRoaXMuYSAqIHRoaXMuYSArIHRoaXMuYiAqIHRoaXMuYik7XG5cdFx0dGFyZ2V0LnNjYWxlWSA9IE1hdGguc3FydCh0aGlzLmMgKiB0aGlzLmMgKyB0aGlzLmQgKiB0aGlzLmQpO1xuXG5cdFx0dmFyIHNrZXdYID0gTWF0aC5hdGFuMigtdGhpcy5jLCB0aGlzLmQpO1xuXHRcdHZhciBza2V3WSA9IE1hdGguYXRhbjIodGhpcy5iLCB0aGlzLmEpO1xuXG5cdFx0dmFyIGRlbHRhID0gTWF0aC5hYnMoMS1za2V3WC9za2V3WSk7XG5cdFx0aWYgKGRlbHRhIDwgMC4wMDAwMSkgeyAvLyBlZmZlY3RpdmVseSBpZGVudGljYWwsIGNhbiB1c2Ugcm90YXRpb246XG5cdFx0XHR0YXJnZXQucm90YXRpb24gPSBza2V3WS9NYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdFx0aWYgKHRoaXMuYSA8IDAgJiYgdGhpcy5kID49IDApIHtcblx0XHRcdFx0dGFyZ2V0LnJvdGF0aW9uICs9ICh0YXJnZXQucm90YXRpb24gPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0LnNrZXdYID0gdGFyZ2V0LnNrZXdZID0gMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LnNrZXdYID0gc2tld1gvTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRcdHRhcmdldC5za2V3WSA9IHNrZXdZL01hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0fVxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ29waWVzIGFsbCBwcm9wZXJ0aWVzIGZyb20gdGhlIHNwZWNpZmllZCBtYXRyaXggdG8gdGhpcyBtYXRyaXguXG5cdCAqIEBtZXRob2QgY29weVxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXggVGhlIG1hdHJpeCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0Ki9cblx0cC5jb3B5ID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0VmFsdWVzKG1hdHJpeC5hLCBtYXRyaXguYiwgbWF0cml4LmMsIG1hdHJpeC5kLCBtYXRyaXgudHgsIG1hdHJpeC50eSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgTWF0cml4MkQgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7TWF0cml4MkR9IGEgY2xvbmUgb2YgdGhlIE1hdHJpeDJEIGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IE1hdHJpeDJEKHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRoaXMuZCwgdGhpcy50eCwgdGhpcy50eSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltNYXRyaXgyRCAoYT1cIit0aGlzLmErXCIgYj1cIit0aGlzLmIrXCIgYz1cIit0aGlzLmMrXCIgZD1cIit0aGlzLmQrXCIgdHg9XCIrdGhpcy50eCtcIiB0eT1cIit0aGlzLnR5K1wiKV1cIjtcblx0fTtcblxuXHQvLyB0aGlzIGhhcyB0byBiZSBwb3B1bGF0ZWQgYWZ0ZXIgdGhlIGNsYXNzIGlzIGRlZmluZWQ6XG5cdE1hdHJpeDJELmlkZW50aXR5ID0gbmV3IE1hdHJpeDJEKCk7XG5cblxuXHRjcmVhdGVqcy5NYXRyaXgyRCA9IE1hdHJpeDJEO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIERpc3BsYXlQcm9wcy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogVXNlZCBmb3IgY2FsY3VsYXRpbmcgYW5kIGVuY2Fwc3VsYXRpbmcgZGlzcGxheSByZWxhdGVkIHByb3BlcnRpZXMuXG5cdCAqIEBjbGFzcyBEaXNwbGF5UHJvcHNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt2aXNpYmxlPXRydWVdIFZpc2libGUgdmFsdWUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYWxwaGE9MV0gQWxwaGEgdmFsdWUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2hhZG93PW51bGxdIEEgU2hhZG93IGluc3RhbmNlIG9yIG51bGwuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9zaXRlT3BlcmF0aW9uPW51bGxdIEEgY29tcG9zaXRlT3BlcmF0aW9uIHZhbHVlIG9yIG51bGwuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbbWF0cml4XSBBIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC4gRGVmYXVsdHMgdG8gYSBuZXcgaWRlbnRpdHkgbWF0cml4LlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBEaXNwbGF5UHJvcHModmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgY29tcG9zaXRlT3BlcmF0aW9uLCBtYXRyaXgpIHtcblx0XHR0aGlzLnNldFZhbHVlcyh2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBjb21wb3NpdGVPcGVyYXRpb24sIG1hdHJpeCk7XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8vIGFzc2lnbmVkIGluIHRoZSBzZXRWYWx1ZXMgbWV0aG9kLlxuXHRcdC8qKlxuXHRcdCAqIFByb3BlcnR5IHJlcHJlc2VudGluZyB0aGUgYWxwaGEgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYSBkaXNwbGF5IG9iamVjdC5cblx0XHQgKiBAcHJvcGVydHkgYWxwaGFcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFByb3BlcnR5IHJlcHJlc2VudGluZyB0aGUgc2hhZG93IHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGEgZGlzcGxheSBvYmplY3QuXG5cdFx0ICogQHByb3BlcnR5IHNoYWRvd1xuXHRcdCAqIEB0eXBlIFNoYWRvd1xuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogUHJvcGVydHkgcmVwcmVzZW50aW5nIHRoZSBjb21wb3NpdGVPcGVyYXRpb24gdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYSBkaXNwbGF5IG9iamVjdC5cblx0XHQgKiBZb3UgY2FuIGZpbmQgYSBsaXN0IG9mIHZhbGlkIGNvbXBvc2l0ZSBvcGVyYXRpb25zIGF0OlxuXHRcdCAqIDxhIGhyZWY9XCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9DYW52YXNfdHV0b3JpYWwvQ29tcG9zaXRpbmdcIj5odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9DYW52YXNfdHV0b3JpYWwvQ29tcG9zaXRpbmc8L2E+XG5cdFx0ICogQHByb3BlcnR5IGNvbXBvc2l0ZU9wZXJhdGlvblxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqKi9cblx0XHRcblx0XHQvKipcblx0XHQgKiBQcm9wZXJ0eSByZXByZXNlbnRpbmcgdGhlIHZhbHVlIGZvciB2aXNpYmxlIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGEgZGlzcGxheSBvYmplY3QuXG5cdFx0ICogQHByb3BlcnR5IHZpc2libGVcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICoqL1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYSBkaXNwbGF5IG9iamVjdC5cblx0XHQgKiBAcHJvcGVydHkgbWF0cml4XG5cdFx0ICogQHR5cGUgTWF0cml4MkRcblx0XHQgKiovXG5cdH1cblx0dmFyIHAgPSBEaXNwbGF5UHJvcHMucHJvdG90eXBlO1xuXG4vLyBpbml0aWFsaXphdGlvbjpcblx0LyoqXG5cdCAqIFJlaW5pdGlhbGl6ZXMgdGhlIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZXMuXG5cdCAqIEBtZXRob2Qgc2V0VmFsdWVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdmlzaWJsZT10cnVlXSBWaXNpYmxlIHZhbHVlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2FscGhhPTFdIEFscGhhIHZhbHVlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NoYWRvdz1udWxsXSBBIFNoYWRvdyBpbnN0YW5jZSBvciBudWxsLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2NvbXBvc2l0ZU9wZXJhdGlvbj1udWxsXSBBIGNvbXBvc2l0ZU9wZXJhdGlvbiB2YWx1ZSBvciBudWxsLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW21hdHJpeF0gQSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguIERlZmF1bHRzIHRvIGFuIGlkZW50aXR5IG1hdHJpeC5cblx0ICogQHJldHVybiB7RGlzcGxheVByb3BzfSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLnNldFZhbHVlcyA9IGZ1bmN0aW9uICh2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBjb21wb3NpdGVPcGVyYXRpb24sIG1hdHJpeCkge1xuXHRcdHRoaXMudmlzaWJsZSA9IHZpc2libGUgPT0gbnVsbCA/IHRydWUgOiAhIXZpc2libGU7XG5cdFx0dGhpcy5hbHBoYSA9IGFscGhhID09IG51bGwgPyAxIDogYWxwaGE7XG5cdFx0dGhpcy5zaGFkb3cgPSBzaGFkb3c7XG5cdFx0dGhpcy5jb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGVPcGVyYXRpb247XG5cdFx0dGhpcy5tYXRyaXggPSBtYXRyaXggfHwgKHRoaXMubWF0cml4JiZ0aGlzLm1hdHJpeC5pZGVudGl0eSgpKSB8fCBuZXcgY3JlYXRlanMuTWF0cml4MkQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBBcHBlbmRzIHRoZSBzcGVjaWZpZWQgZGlzcGxheSBwcm9wZXJ0aWVzLiBUaGlzIGlzIGdlbmVyYWxseSB1c2VkIHRvIGFwcGx5IGEgY2hpbGQncyBwcm9wZXJ0aWVzIGl0cyBwYXJlbnQncy5cblx0ICogQG1ldGhvZCBhcHBlbmRcblx0ICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlIGRlc2lyZWQgdmlzaWJsZSB2YWx1ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gYWxwaGEgZGVzaXJlZCBhbHBoYSB2YWx1ZVxuXHQgKiBAcGFyYW0ge1NoYWRvd30gc2hhZG93IGRlc2lyZWQgc2hhZG93IHZhbHVlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb3NpdGVPcGVyYXRpb24gZGVzaXJlZCBjb21wb3NpdGUgb3BlcmF0aW9uIHZhbHVlXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IFttYXRyaXhdIGEgTWF0cml4MkQgaW5zdGFuY2Vcblx0ICogQHJldHVybiB7RGlzcGxheVByb3BzfSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLmFwcGVuZCA9IGZ1bmN0aW9uKHZpc2libGUsIGFscGhhLCBzaGFkb3csIGNvbXBvc2l0ZU9wZXJhdGlvbiwgbWF0cml4KSB7XG5cdFx0dGhpcy5hbHBoYSAqPSBhbHBoYTtcblx0XHR0aGlzLnNoYWRvdyA9IHNoYWRvdyB8fCB0aGlzLnNoYWRvdztcblx0XHR0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbiA9IGNvbXBvc2l0ZU9wZXJhdGlvbiB8fCB0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbjtcblx0XHR0aGlzLnZpc2libGUgPSB0aGlzLnZpc2libGUgJiYgdmlzaWJsZTtcblx0XHRtYXRyaXgmJnRoaXMubWF0cml4LmFwcGVuZE1hdHJpeChtYXRyaXgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFByZXBlbmRzIHRoZSBzcGVjaWZpZWQgZGlzcGxheSBwcm9wZXJ0aWVzLiBUaGlzIGlzIGdlbmVyYWxseSB1c2VkIHRvIGFwcGx5IGEgcGFyZW50J3MgcHJvcGVydGllcyB0byBhIGNoaWxkJ3MuXG5cdCAqIEZvciBleGFtcGxlLCB0byBnZXQgdGhlIGNvbWJpbmVkIGRpc3BsYXkgcHJvcGVydGllcyB0aGF0IHdvdWxkIGJlIGFwcGxpZWQgdG8gYSBjaGlsZCwgeW91IGNvdWxkIHVzZTpcblx0ICogXG5cdCAqIFx0dmFyIG8gPSBteURpc3BsYXlPYmplY3Q7XG5cdCAqIFx0dmFyIHByb3BzID0gbmV3IGNyZWF0ZWpzLkRpc3BsYXlQcm9wcygpO1xuXHQgKiBcdGRvIHtcblx0ICogXHRcdC8vIHByZXBlbmQgZWFjaCBwYXJlbnQncyBwcm9wcyBpbiB0dXJuOlxuXHQgKiBcdFx0cHJvcHMucHJlcGVuZChvLnZpc2libGUsIG8uYWxwaGEsIG8uc2hhZG93LCBvLmNvbXBvc2l0ZU9wZXJhdGlvbiwgby5nZXRNYXRyaXgoKSk7XG5cdCAqIFx0fSB3aGlsZSAobyA9IG8ucGFyZW50KTtcblx0ICogXHRcblx0ICogQG1ldGhvZCBwcmVwZW5kXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZSBkZXNpcmVkIHZpc2libGUgdmFsdWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFscGhhIGRlc2lyZWQgYWxwaGEgdmFsdWVcblx0ICogQHBhcmFtIHtTaGFkb3d9IHNoYWRvdyBkZXNpcmVkIHNoYWRvdyB2YWx1ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9zaXRlT3BlcmF0aW9uIGRlc2lyZWQgY29tcG9zaXRlIG9wZXJhdGlvbiB2YWx1ZVxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBbbWF0cml4XSBhIE1hdHJpeDJEIGluc3RhbmNlXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlQcm9wc30gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5wcmVwZW5kID0gZnVuY3Rpb24odmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgY29tcG9zaXRlT3BlcmF0aW9uLCBtYXRyaXgpIHtcblx0XHR0aGlzLmFscGhhICo9IGFscGhhO1xuXHRcdHRoaXMuc2hhZG93ID0gdGhpcy5zaGFkb3cgfHwgc2hhZG93O1xuXHRcdHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uID0gdGhpcy5jb21wb3NpdGVPcGVyYXRpb24gfHwgY29tcG9zaXRlT3BlcmF0aW9uO1xuXHRcdHRoaXMudmlzaWJsZSA9IHRoaXMudmlzaWJsZSAmJiB2aXNpYmxlO1xuXHRcdG1hdHJpeCYmdGhpcy5tYXRyaXgucHJlcGVuZE1hdHJpeChtYXRyaXgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJlc2V0cyB0aGlzIGluc3RhbmNlIGFuZCBpdHMgbWF0cml4IHRvIGRlZmF1bHQgdmFsdWVzLlxuXHQgKiBAbWV0aG9kIGlkZW50aXR5XG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlQcm9wc30gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5pZGVudGl0eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cdFx0dGhpcy5hbHBoYSA9IDE7XG5cdFx0dGhpcy5zaGFkb3cgPSB0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbiA9IG51bGw7XG5cdFx0dGhpcy5tYXRyaXguaWRlbnRpdHkoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIERpc3BsYXlQcm9wcyBpbnN0YW5jZS4gQ2xvbmVzIHRoZSBhc3NvY2lhdGVkIG1hdHJpeC5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5UHJvcHN9IGEgY2xvbmUgb2YgdGhlIERpc3BsYXlQcm9wcyBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBEaXNwbGF5UHJvcHModGhpcy5hbHBoYSwgdGhpcy5zaGFkb3csIHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uLCB0aGlzLnZpc2libGUsIHRoaXMubWF0cml4LmNsb25lKCkpO1xuXHR9O1xuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cblx0Y3JlYXRlanMuRGlzcGxheVByb3BzID0gRGlzcGxheVByb3BzO1xufSkoKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFBvaW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogUmVwcmVzZW50cyBhIHBvaW50IG9uIGEgMiBkaW1lbnNpb25hbCB4IC8geSBjb29yZGluYXRlIHN5c3RlbS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBcblx0ICogICAgICB2YXIgcG9pbnQgPSBuZXcgY3JlYXRlanMuUG9pbnQoMCwgMTAwKTtcblx0ICogXG5cdCAqIEBjbGFzcyBQb2ludFxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gWCBwb3NpdGlvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIFkgcG9zaXRpb24uXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcblx0IFx0dGhpcy5zZXRWYWx1ZXMoeCwgeSk7XG5cdCBcdFxuXHQgXHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0Ly8gYXNzaWduZWQgaW4gdGhlIHNldFZhbHVlcyBtZXRob2QuXG5cdFx0LyoqXG5cdFx0ICogWCBwb3NpdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgeFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogWSBwb3NpdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgeVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0fVxuXHR2YXIgcCA9IFBvaW50LnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblx0XG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqIFxuXHQgKiBTZXRzIHRoZSBzcGVjaWZpZWQgdmFsdWVzIG9uIHRoaXMgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2Qgc2V0VmFsdWVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSBYIHBvc2l0aW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3k9MF0gWSBwb3NpdGlvbi5cblx0ICogQHJldHVybiB7UG9pbnR9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAuc2V0VmFsdWVzID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMueCA9IHh8fDA7XG5cdFx0dGhpcy55ID0geXx8MDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDb3BpZXMgYWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgc3BlY2lmaWVkIHBvaW50IHRvIHRoaXMgcG9pbnQuXG5cdCAqIEBtZXRob2QgY29weVxuXHQgKiBAcGFyYW0ge1BvaW50fSBwb2ludCBUaGUgcG9pbnQgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG5cdCAqIEByZXR1cm4ge1BvaW50fSBUaGlzIHBvaW50LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLmNvcHkgPSBmdW5jdGlvbihwb2ludCkge1xuXHRcdHRoaXMueCA9IHBvaW50Lng7XG5cdFx0dGhpcy55ID0gcG9pbnQueTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFBvaW50IGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge1BvaW50fSBhIGNsb25lIG9mIHRoZSBQb2ludCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltQb2ludCAoeD1cIit0aGlzLngrXCIgeT1cIit0aGlzLnkrXCIpXVwiO1xuXHR9O1xuXHRcblx0XG5cdGNyZWF0ZWpzLlBvaW50ID0gUG9pbnQ7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gUmVjdGFuZ2xlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogUmVwcmVzZW50cyBhIHJlY3RhbmdsZSBhcyBkZWZpbmVkIGJ5IHRoZSBwb2ludHMgKHgsIHkpIGFuZCAoeCt3aWR0aCwgeStoZWlnaHQpLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIHJlY3QgPSBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKDAsIDAsIDEwMCwgMTAwKTtcblx0ICpcblx0ICogQGNsYXNzIFJlY3RhbmdsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gWCBwb3NpdGlvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIFkgcG9zaXRpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGg9MF0gVGhlIHdpZHRoIG9mIHRoZSBSZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0PTBdIFRoZSBoZWlnaHQgb2YgdGhlIFJlY3RhbmdsZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR0aGlzLnNldFZhbHVlcyh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0Ly8gYXNzaWduZWQgaW4gdGhlIHNldFZhbHVlcyBtZXRob2QuXG5cdFx0LyoqXG5cdFx0ICogWCBwb3NpdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgeFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogWSBwb3NpdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgeVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogV2lkdGguXG5cdFx0ICogQHByb3BlcnR5IHdpZHRoXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBIZWlnaHQuXG5cdFx0ICogQHByb3BlcnR5IGhlaWdodFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0fVxuXHR2YXIgcCA9IFJlY3RhbmdsZS5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKiogXG5cdCAqIFNldHMgdGhlIHNwZWNpZmllZCB2YWx1ZXMgb24gdGhpcyBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBzZXRWYWx1ZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIFggcG9zaXRpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSBZIHBvc2l0aW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTBdIFRoZSB3aWR0aCBvZiB0aGUgUmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodD0wXSBUaGUgaGVpZ2h0IG9mIHRoZSBSZWN0YW5nbGUuXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5zZXRWYWx1ZXMgPSBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0Ly8gZG9uJ3QgZm9yZ2V0IHRvIHVwZGF0ZSBkb2NzIGluIHRoZSBjb25zdHJ1Y3RvciBpZiB0aGVzZSBjaGFuZ2U6XG5cdFx0dGhpcy54ID0geHx8MDtcblx0XHR0aGlzLnkgPSB5fHwwO1xuXHRcdHRoaXMud2lkdGggPSB3aWR0aHx8MDtcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodHx8MDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKiBcblx0ICogRXh0ZW5kcyB0aGUgcmVjdGFuZ2xlJ3MgYm91bmRzIHRvIGluY2x1ZGUgdGhlIGRlc2NyaWJlZCBwb2ludCBvciByZWN0YW5nbGUuXG5cdCAqIEBtZXRob2QgZXh0ZW5kXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFggcG9zaXRpb24gb2YgdGhlIHBvaW50IG9yIHJlY3RhbmdsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb3IgcmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTBdIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodD0wXSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUuXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5leHRlbmQgPSBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0d2lkdGggPSB3aWR0aHx8MDtcblx0XHRoZWlnaHQgPSBoZWlnaHR8fDA7XG5cdFx0aWYgKHgrd2lkdGggPiB0aGlzLngrdGhpcy53aWR0aCkgeyB0aGlzLndpZHRoID0geCt3aWR0aC10aGlzLng7IH1cblx0XHRpZiAoeStoZWlnaHQgPiB0aGlzLnkrdGhpcy5oZWlnaHQpIHsgdGhpcy5oZWlnaHQgPSB5K2hlaWdodC10aGlzLnk7IH1cblx0XHRpZiAoeCA8IHRoaXMueCkgeyB0aGlzLndpZHRoICs9IHRoaXMueC14OyB0aGlzLnggPSB4OyB9XG5cdFx0aWYgKHkgPCB0aGlzLnkpIHsgdGhpcy5oZWlnaHQgKz0gdGhpcy55LXk7IHRoaXMueSA9IHk7IH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKiBcblx0ICogQWRkcyB0aGUgc3BlY2lmaWVkIHBhZGRpbmcgdG8gdGhlIHJlY3RhbmdsZSdzIGJvdW5kcy5cblx0ICogQG1ldGhvZCBwYWRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRvcFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbGVmdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmlnaHRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGJvdHRvbVxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAucGFkID0gZnVuY3Rpb24odG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0KSB7XG5cdFx0dGhpcy54IC09IGxlZnQ7XG5cdFx0dGhpcy55IC09IHRvcDtcblx0XHR0aGlzLndpZHRoICs9IGxlZnQrcmlnaHQ7XG5cdFx0dGhpcy5oZWlnaHQgKz0gdG9wK2JvdHRvbTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDb3BpZXMgYWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgc3BlY2lmaWVkIHJlY3RhbmdsZSB0byB0aGlzIHJlY3RhbmdsZS5cblx0ICogQG1ldGhvZCBjb3B5XG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0YW5nbGUgVGhlIHJlY3RhbmdsZSB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBUaGlzIHJlY3RhbmdsZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5jb3B5ID0gZnVuY3Rpb24ocmVjdGFuZ2xlKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0VmFsdWVzKHJlY3RhbmdsZS54LCByZWN0YW5nbGUueSwgcmVjdGFuZ2xlLndpZHRoLCByZWN0YW5nbGUuaGVpZ2h0KTtcblx0fTtcblx0XG5cdC8qKiBcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcmVjdGFuZ2xlIGZ1bGx5IGVuY2xvc2VzIHRoZSBkZXNjcmliZWQgcG9pbnQgb3IgcmVjdGFuZ2xlLlxuXHQgKiBAbWV0aG9kIGNvbnRhaW5zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFggcG9zaXRpb24gb2YgdGhlIHBvaW50IG9yIHJlY3RhbmdsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb3IgcmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTBdIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodD0wXSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIGRlc2NyaWJlZCBwb2ludCBvciByZWN0YW5nbGUgaXMgY29udGFpbmVkIHdpdGhpbiB0aGlzIHJlY3RhbmdsZS5cblx0Ki9cblx0cC5jb250YWlucyA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR3aWR0aCA9IHdpZHRofHwwO1xuXHRcdGhlaWdodCA9IGhlaWdodHx8MDtcblx0XHRyZXR1cm4gKHggPj0gdGhpcy54ICYmIHgrd2lkdGggPD0gdGhpcy54K3RoaXMud2lkdGggJiYgeSA+PSB0aGlzLnkgJiYgeStoZWlnaHQgPD0gdGhpcy55K3RoaXMuaGVpZ2h0KTtcblx0fTtcblx0XG5cdC8qKiBcblx0ICogUmV0dXJucyBhIG5ldyByZWN0YW5nbGUgd2hpY2ggY29udGFpbnMgdGhpcyByZWN0YW5nbGUgYW5kIHRoZSBzcGVjaWZpZWQgcmVjdGFuZ2xlLlxuXHQgKiBAbWV0aG9kIHVuaW9uXG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IFRoZSByZWN0YW5nbGUgdG8gY2FsY3VsYXRlIGEgdW5pb24gd2l0aC5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBBIG5ldyByZWN0YW5nbGUgZGVzY3JpYmluZyB0aGUgdW5pb24uXG5cdCovXG5cdHAudW5pb24gPSBmdW5jdGlvbihyZWN0KSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5leHRlbmQocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcblx0fTtcblx0XG5cdC8qKiBcblx0ICogUmV0dXJucyBhIG5ldyByZWN0YW5nbGUgd2hpY2ggZGVzY3JpYmVzIHRoZSBpbnRlcnNlY3Rpb24gKG92ZXJsYXApIG9mIHRoaXMgcmVjdGFuZ2xlIGFuZCB0aGUgc3BlY2lmaWVkIHJlY3RhbmdsZSxcblx0ICogb3IgbnVsbCBpZiB0aGV5IGRvIG5vdCBpbnRlcnNlY3QuXG5cdCAqIEBtZXRob2QgaW50ZXJzZWN0aW9uXG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IFRoZSByZWN0YW5nbGUgdG8gY2FsY3VsYXRlIGFuIGludGVyc2VjdGlvbiB3aXRoLlxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IEEgbmV3IHJlY3RhbmdsZSBkZXNjcmliaW5nIHRoZSBpbnRlcnNlY3Rpb24gb3IgbnVsbC5cblx0Ki9cblx0cC5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihyZWN0KSB7XG5cdFx0dmFyIHgxID0gcmVjdC54LCB5MSA9IHJlY3QueSwgeDIgPSB4MStyZWN0LndpZHRoLCB5MiA9IHkxK3JlY3QuaGVpZ2h0O1xuXHRcdGlmICh0aGlzLnggPiB4MSkgeyB4MSA9IHRoaXMueDsgfVxuXHRcdGlmICh0aGlzLnkgPiB5MSkgeyB5MSA9IHRoaXMueTsgfVxuXHRcdGlmICh0aGlzLnggKyB0aGlzLndpZHRoIDwgeDIpIHsgeDIgPSB0aGlzLnggKyB0aGlzLndpZHRoOyB9XG5cdFx0aWYgKHRoaXMueSArIHRoaXMuaGVpZ2h0IDwgeTIpIHsgeTIgPSB0aGlzLnkgKyB0aGlzLmhlaWdodDsgfVxuXHRcdHJldHVybiAoeDIgPD0geDEgfHwgeTIgPD0geTEpID8gbnVsbCA6IG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4Mi14MSwgeTIteTEpO1xuXHR9O1xuXHRcblx0LyoqIFxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCByZWN0YW5nbGUgaW50ZXJzZWN0cyAoaGFzIGFueSBvdmVybGFwKSB3aXRoIHRoaXMgcmVjdGFuZ2xlLlxuXHQgKiBAbWV0aG9kIGludGVyc2VjdHNcblx0ICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3QgVGhlIHJlY3RhbmdsZSB0byBjb21wYXJlLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSByZWN0YW5nbGVzIGludGVyc2VjdC5cblx0Ki9cblx0cC5pbnRlcnNlY3RzID0gZnVuY3Rpb24ocmVjdCkge1xuXHRcdHJldHVybiAocmVjdC54IDw9IHRoaXMueCt0aGlzLndpZHRoICYmIHRoaXMueCA8PSByZWN0LngrcmVjdC53aWR0aCAmJiByZWN0LnkgPD0gdGhpcy55K3RoaXMuaGVpZ2h0ICYmIHRoaXMueSA8PSByZWN0LnkgKyByZWN0LmhlaWdodCk7XG5cdH07XG5cdFxuXHQvKiogXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgd2lkdGggb3IgaGVpZ2h0IGFyZSBlcXVhbCBvciBsZXNzIHRoYW4gMC5cblx0ICogQG1ldGhvZCBpc0VtcHR5XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHJlY3RhbmdsZSBpcyBlbXB0eS5cblx0Ki9cblx0cC5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgUmVjdGFuZ2xlIGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gYSBjbG9uZSBvZiB0aGUgUmVjdGFuZ2xlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbUmVjdGFuZ2xlICh4PVwiK3RoaXMueCtcIiB5PVwiK3RoaXMueStcIiB3aWR0aD1cIit0aGlzLndpZHRoK1wiIGhlaWdodD1cIit0aGlzLmhlaWdodCtcIildXCI7XG5cdH07XG5cdFxuXHRcblx0Y3JlYXRlanMuUmVjdGFuZ2xlID0gUmVjdGFuZ2xlO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEJ1dHRvbkhlbHBlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFRoZSBCdXR0b25IZWxwZXIgaXMgYSBoZWxwZXIgY2xhc3MgdG8gY3JlYXRlIGludGVyYWN0aXZlIGJ1dHRvbnMgZnJvbSB7eyNjcm9zc0xpbmsgXCJNb3ZpZUNsaXBcIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0ICoge3sjY3Jvc3NMaW5rIFwiU3ByaXRlXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlcy4gVGhpcyBjbGFzcyB3aWxsIGludGVyY2VwdCBtb3VzZSBldmVudHMgZnJvbSBhbiBvYmplY3QsIGFuZFxuXHQgKiBhdXRvbWF0aWNhbGx5IGNhbGwge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRTdG9wXCJ9fXt7L2Nyb3NzTGlua319IG9yIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9nb3RvQW5kUGxheVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogdG8gdGhlIHJlc3BlY3RpdmUgYW5pbWF0aW9uIGxhYmVscywgYWRkIGEgcG9pbnRlciBjdXJzb3IsIGFuZCBhbGxvd3MgdGhlIHVzZXIgdG8gZGVmaW5lIGEgaGl0IHN0YXRlIGZyYW1lLlxuXHQgKlxuXHQgKiBUaGUgQnV0dG9uSGVscGVyIGluc3RhbmNlIGRvZXMgbm90IG5lZWQgdG8gYmUgYWRkZWQgdG8gdGhlIHN0YWdlLCBidXQgYSByZWZlcmVuY2Ugc2hvdWxkIGJlIG1haW50YWluZWQgdG8gcHJldmVudFxuXHQgKiBnYXJiYWdlIGNvbGxlY3Rpb24uXG5cdCAqIFxuXHQgKiBOb3RlIHRoYXQgb3ZlciBzdGF0ZXMgd2lsbCBub3Qgd29yayB1bmxlc3MgeW91IGNhbGwge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvZW5hYmxlTW91c2VPdmVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIGhlbHBlciA9IG5ldyBjcmVhdGVqcy5CdXR0b25IZWxwZXIobXlJbnN0YW5jZSwgXCJvdXRcIiwgXCJvdmVyXCIsIFwiZG93blwiLCBmYWxzZSwgbXlJbnN0YW5jZSwgXCJoaXRcIik7XG5cdCAqICAgICAgbXlJbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIC8vIENsaWNrIEhhcHBlbmVkLlxuXHQgKiAgICAgIH1cblx0ICpcblx0ICogQGNsYXNzIEJ1dHRvbkhlbHBlclxuXHQgKiBAcGFyYW0ge1Nwcml0ZXxNb3ZpZUNsaXB9IHRhcmdldCBUaGUgaW5zdGFuY2UgdG8gbWFuYWdlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW291dExhYmVsPVwib3V0XCJdIFRoZSBsYWJlbCBvciBhbmltYXRpb24gdG8gZ28gdG8gd2hlbiB0aGUgdXNlciByb2xscyBvdXQgb2YgdGhlIGJ1dHRvbi5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtvdmVyTGFiZWw9XCJvdmVyXCJdIFRoZSBsYWJlbCBvciBhbmltYXRpb24gdG8gZ28gdG8gd2hlbiB0aGUgdXNlciByb2xscyBvdmVyIHRoZSBidXR0b24uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbZG93bkxhYmVsPVwiZG93blwiXSBUaGUgbGFiZWwgb3IgYW5pbWF0aW9uIHRvIGdvIHRvIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyB0aGUgYnV0dG9uLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtwbGF5PWZhbHNlXSBJZiB0aGUgaGVscGVyIHNob3VsZCBjYWxsIFwiZ290b0FuZFBsYXlcIiBvciBcImdvdG9BbmRTdG9wXCIgb24gdGhlIGJ1dHRvbiB3aGVuIGNoYW5naW5nXG5cdCAqIHN0YXRlcy5cblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBbaGl0QXJlYV0gQW4gb3B0aW9uYWwgaXRlbSB0byB1c2UgYXMgdGhlIGhpdCBzdGF0ZSBmb3IgdGhlIGJ1dHRvbi4gSWYgdGhpcyBpcyBub3QgZGVmaW5lZCxcblx0ICogdGhlbiB0aGUgYnV0dG9uJ3MgdmlzaWJsZSBzdGF0ZXMgd2lsbCBiZSB1c2VkIGluc3RlYWQuIE5vdGUgdGhhdCB0aGUgc2FtZSBpbnN0YW5jZSBhcyB0aGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBjYW4gYmVcblx0ICogdXNlZCBmb3IgdGhlIGhpdFN0YXRlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2hpdExhYmVsXSBUaGUgbGFiZWwgb3IgYW5pbWF0aW9uIG9uIHRoZSBoaXRBcmVhIGluc3RhbmNlIHRoYXQgZGVmaW5lcyB0aGUgaGl0QXJlYSBib3VuZHMuIElmIHRoaXMgaXNcblx0ICogbnVsbCwgdGhlbiB0aGUgZGVmYXVsdCBzdGF0ZSBvZiB0aGUgaGl0QXJlYSB3aWxsIGJlIHVzZWQuICpcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBCdXR0b25IZWxwZXIodGFyZ2V0LCBvdXRMYWJlbCwgb3ZlckxhYmVsLCBkb3duTGFiZWwsIHBsYXksIGhpdEFyZWEsIGhpdExhYmVsKSB7XG5cdFx0aWYgKCF0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikgeyByZXR1cm47IH1cblx0XG5cdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgdGFyZ2V0IGZvciB0aGlzIGJ1dHRvbiBoZWxwZXIuXG5cdFx0ICogQHByb3BlcnR5IHRhcmdldFxuXHRcdCAqIEB0eXBlIE1vdmllQ2xpcCB8IFNwcml0ZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLnRhcmdldCA9IHRhcmdldDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGxhYmVsIG5hbWUgb3IgZnJhbWUgbnVtYmVyIHRvIGRpc3BsYXkgd2hlbiB0aGUgdXNlciBtb3VzZXMgb3V0IG9mIHRoZSB0YXJnZXQuIERlZmF1bHRzIHRvIFwib3ZlclwiLlxuXHRcdCAqIEBwcm9wZXJ0eSBvdmVyTGFiZWxcblx0XHQgKiBAdHlwZSBTdHJpbmcgfCBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5vdmVyTGFiZWwgPSBvdmVyTGFiZWwgPT0gbnVsbCA/IFwib3ZlclwiIDogb3ZlckxhYmVsO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgbGFiZWwgbmFtZSBvciBmcmFtZSBudW1iZXIgdG8gZGlzcGxheSB3aGVuIHRoZSB1c2VyIG1vdXNlcyBvdmVyIHRoZSB0YXJnZXQuIERlZmF1bHRzIHRvIFwib3V0XCIuXG5cdFx0ICogQHByb3BlcnR5IG91dExhYmVsXG5cdFx0ICogQHR5cGUgU3RyaW5nIHwgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMub3V0TGFiZWwgPSBvdXRMYWJlbCA9PSBudWxsID8gXCJvdXRcIiA6IG91dExhYmVsO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgbGFiZWwgbmFtZSBvciBmcmFtZSBudW1iZXIgdG8gZGlzcGxheSB3aGVuIHRoZSB1c2VyIHByZXNzZXMgb24gdGhlIHRhcmdldC4gRGVmYXVsdHMgdG8gXCJkb3duXCIuXG5cdFx0ICogQHByb3BlcnR5IGRvd25MYWJlbFxuXHRcdCAqIEB0eXBlIFN0cmluZyB8IE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLmRvd25MYWJlbCA9IGRvd25MYWJlbCA9PSBudWxsID8gXCJkb3duXCIgOiBkb3duTGFiZWw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIHRydWUsIHRoZW4gQnV0dG9uSGVscGVyIHdpbGwgY2FsbCBnb3RvQW5kUGxheSwgaWYgZmFsc2UsIGl0IHdpbGwgdXNlIGdvdG9BbmRTdG9wLiBEZWZhdWx0IGlzIGZhbHNlLlxuXHRcdCAqIEBwcm9wZXJ0eSBwbGF5XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICoqL1xuXHRcdHRoaXMucGxheSA9IHBsYXk7XG5cdFx0XG5cdFx0XG5cdC8vICBwcml2YXRlIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2lzUHJlc3NlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2lzUHJlc3NlZCA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2lzT3ZlclxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2lzT3ZlciA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2VuYWJsZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cdFx0XG5cdC8vIHNldHVwOlxuXHRcdHRhcmdldC5tb3VzZUNoaWxkcmVuID0gZmFsc2U7IC8vIHByZXZlbnRzIGlzc3VlcyB3aGVuIGNoaWxkcmVuIGFyZSByZW1vdmVkIGZyb20gdGhlIGRpc3BsYXkgbGlzdCB3aGVuIHN0YXRlIGNoYW5nZXMuXG5cdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcblx0XHR0aGlzLmhhbmRsZUV2ZW50KHt9KTtcblx0XHRpZiAoaGl0QXJlYSkge1xuXHRcdFx0aWYgKGhpdExhYmVsKSB7XG5cdFx0XHRcdGhpdEFyZWEuYWN0aW9uc0VuYWJsZWQgPSBmYWxzZTtcblx0XHRcdFx0aGl0QXJlYS5nb3RvQW5kU3RvcCYmaGl0QXJlYS5nb3RvQW5kU3RvcChoaXRMYWJlbCk7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXQuaGl0QXJlYSA9IGhpdEFyZWE7XG5cdFx0fVxuXHR9XG5cdHZhciBwID0gQnV0dG9uSGVscGVyLnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblx0XG4vLyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJCdXR0b25IZWxwZXIvZW5hYmxlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIHNldEVuYWJsZWRcblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdHAuc2V0RW5hYmxlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7IC8vIFRPRE86IGRlcHJlY2F0ZWQuXG5cdFx0aWYgKHZhbHVlID09IHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIG8gPSB0aGlzLnRhcmdldDtcblx0XHR0aGlzLl9lbmFibGVkID0gdmFsdWU7XG5cdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRvLmN1cnNvciA9IFwicG9pbnRlclwiO1xuXHRcdFx0by5hZGRFdmVudExpc3RlbmVyKFwicm9sbG92ZXJcIiwgdGhpcyk7XG5cdFx0XHRvLmFkZEV2ZW50TGlzdGVuZXIoXCJyb2xsb3V0XCIsIHRoaXMpO1xuXHRcdFx0by5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMpO1xuXHRcdFx0by5hZGRFdmVudExpc3RlbmVyKFwicHJlc3N1cFwiLCB0aGlzKTtcblx0XHRcdGlmIChvLl9yZXNldCkgeyBvLl9fcmVzZXQgPSBvLl9yZXNldDsgby5fcmVzZXQgPSB0aGlzLl9yZXNldDt9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG8uY3Vyc29yID0gbnVsbDtcblx0XHRcdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJvbGxvdmVyXCIsIHRoaXMpO1xuXHRcdFx0by5yZW1vdmVFdmVudExpc3RlbmVyKFwicm9sbG91dFwiLCB0aGlzKTtcblx0XHRcdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzKTtcblx0XHRcdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInByZXNzdXBcIiwgdGhpcyk7XG5cdFx0XHRpZiAoby5fX3Jlc2V0KSB7IG8uX3Jlc2V0ID0gby5fX3Jlc2V0OyBkZWxldGUoby5fX3Jlc2V0KTsgfVxuXHRcdH1cblx0fTtcblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiQnV0dG9uSGVscGVyL2VuYWJsZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXRFbmFibGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0cC5nZXRFbmFibGVkID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGJ1dHRvbiBmdW5jdGlvbmFsaXR5IG9uIHRoZSB0YXJnZXQuXG5cdCAqIEBwcm9wZXJ0eSBlbmFibGVkXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiovXG5cdHRyeSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMocCwge1xuXHRcdFx0ZW5hYmxlZDogeyBnZXQ6IHAuZ2V0RW5hYmxlZCwgc2V0OiBwLnNldEVuYWJsZWQgfVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlKSB7fSAvLyBUT0RPOiB1c2UgTG9nXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbQnV0dG9uSGVscGVyXVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgaGFuZGxlRXZlbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2dCBUaGUgbW91c2UgZXZlbnQgdG8gaGFuZGxlLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKGV2dCkge1xuXHRcdHZhciBsYWJlbCwgdCA9IHRoaXMudGFyZ2V0LCB0eXBlID0gZXZ0LnR5cGU7XG5cdFx0aWYgKHR5cGUgPT0gXCJtb3VzZWRvd25cIikge1xuXHRcdFx0dGhpcy5faXNQcmVzc2VkID0gdHJ1ZTtcblx0XHRcdGxhYmVsID0gdGhpcy5kb3duTGFiZWw7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09IFwicHJlc3N1cFwiKSB7XG5cdFx0XHR0aGlzLl9pc1ByZXNzZWQgPSBmYWxzZTtcblx0XHRcdGxhYmVsID0gdGhpcy5faXNPdmVyID8gdGhpcy5vdmVyTGFiZWwgOiB0aGlzLm91dExhYmVsO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PSBcInJvbGxvdmVyXCIpIHtcblx0XHRcdHRoaXMuX2lzT3ZlciA9IHRydWU7XG5cdFx0XHRsYWJlbCA9IHRoaXMuX2lzUHJlc3NlZCA/IHRoaXMuZG93bkxhYmVsIDogdGhpcy5vdmVyTGFiZWw7XG5cdFx0fSBlbHNlIHsgLy8gcm9sbG91dCBhbmQgZGVmYXVsdFxuXHRcdFx0dGhpcy5faXNPdmVyID0gZmFsc2U7XG5cdFx0XHRsYWJlbCA9IHRoaXMuX2lzUHJlc3NlZCA/IHRoaXMub3ZlckxhYmVsIDogdGhpcy5vdXRMYWJlbDtcblx0XHR9XG5cdFx0aWYgKHRoaXMucGxheSkge1xuXHRcdFx0dC5nb3RvQW5kUGxheSYmdC5nb3RvQW5kUGxheShsYWJlbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHQuZ290b0FuZFN0b3AmJnQuZ290b0FuZFN0b3AobGFiZWwpO1xuXHRcdH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBJbmplY3RlZCBpbnRvIHRhcmdldC4gUHJlc2VydmVzIHRoZSBwYXVzZWQgc3RhdGUgdGhyb3VnaCBhIHJlc2V0LlxuXHQgKiBAbWV0aG9kIF9yZXNldFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fcmVzZXQgPSBmdW5jdGlvbigpIHtcblx0XHQvLyBUT0RPOiBleHBsb3JlIGJldHRlciB3YXlzIHRvIGhhbmRsZSB0aGlzIGlzc3VlLiBUaGlzIGlzIGhhY2t5ICYgZGlzcnVwdHMgb2JqZWN0IHNpZ25hdHVyZXMuXG5cdFx0dmFyIHAgPSB0aGlzLnBhdXNlZDtcblx0XHR0aGlzLl9fcmVzZXQoKTtcblx0XHR0aGlzLnBhdXNlZCA9IHA7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5CdXR0b25IZWxwZXIgPSBCdXR0b25IZWxwZXI7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU2hhZG93LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogVGhpcyBjbGFzcyBlbmNhcHN1bGF0ZXMgdGhlIHByb3BlcnRpZXMgcmVxdWlyZWQgdG8gZGVmaW5lIGEgc2hhZG93IHRvIGFwcGx5IHRvIGEge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB2aWEgaXRzIDxjb2RlPnNoYWRvdzwvY29kZT4gcHJvcGVydHkuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBteUltYWdlLnNoYWRvdyA9IG5ldyBjcmVhdGVqcy5TaGFkb3coXCIjMDAwMDAwXCIsIDUsIDUsIDEwKTtcblx0ICpcblx0ICogQGNsYXNzIFNoYWRvd1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIFRoZSBjb2xvciBvZiB0aGUgc2hhZG93LiBUaGlzIGNhbiBiZSBhbnkgdmFsaWQgQ1NTIGNvbG9yIHZhbHVlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0WCBUaGUgeCBvZmZzZXQgb2YgdGhlIHNoYWRvdyBpbiBwaXhlbHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRZIFRoZSB5IG9mZnNldCBvZiB0aGUgc2hhZG93IGluIHBpeGVscy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGJsdXIgVGhlIHNpemUgb2YgdGhlIGJsdXJyaW5nIGVmZmVjdC5cblx0ICoqL1xuXHRmdW5jdGlvbiBTaGFkb3coY29sb3IsIG9mZnNldFgsIG9mZnNldFksIGJsdXIpIHtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqIFxuXHRcdCAqIFRoZSBjb2xvciBvZiB0aGUgc2hhZG93LiBUaGlzIGNhbiBiZSBhbnkgdmFsaWQgQ1NTIGNvbG9yIHZhbHVlLlxuXHRcdCAqIEBwcm9wZXJ0eSBjb2xvclxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmNvbG9yID0gY29sb3J8fFwiYmxhY2tcIjtcblx0XG5cdFx0LyoqIFRoZSB4IG9mZnNldCBvZiB0aGUgc2hhZG93LlxuXHRcdCAqIEBwcm9wZXJ0eSBvZmZzZXRYXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMub2Zmc2V0WCA9IG9mZnNldFh8fDA7XG5cdFxuXHRcdC8qKiBUaGUgeSBvZmZzZXQgb2YgdGhlIHNoYWRvdy5cblx0XHQgKiBAcHJvcGVydHkgb2Zmc2V0WVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLm9mZnNldFkgPSBvZmZzZXRZfHwwO1xuXHRcblx0XHQvKiogVGhlIGJsdXIgb2YgdGhlIHNoYWRvdy5cblx0XHQgKiBAcHJvcGVydHkgYmx1clxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmJsdXIgPSBibHVyfHwwO1xuXHR9XG5cdHZhciBwID0gU2hhZG93LnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblxuLy8gc3RhdGljIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQW4gaWRlbnRpdHkgc2hhZG93IG9iamVjdCAoYWxsIHByb3BlcnRpZXMgYXJlIHNldCB0byAwKS5cblx0ICogQHByb3BlcnR5IGlkZW50aXR5XG5cdCAqIEB0eXBlIFNoYWRvd1xuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRTaGFkb3cuaWRlbnRpdHkgPSBuZXcgU2hhZG93KFwidHJhbnNwYXJlbnRcIiwgMCwgMCwgMCk7XG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbU2hhZG93XVwiO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBTaGFkb3cgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7U2hhZG93fSBBIGNsb25lIG9mIHRoZSBjdXJyZW50IFNoYWRvdyBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTaGFkb3codGhpcy5jb2xvciwgdGhpcy5vZmZzZXRYLCB0aGlzLm9mZnNldFksIHRoaXMuYmx1cik7XG5cdH07XG5cdFxuXG5cdGNyZWF0ZWpzLlNoYWRvdyA9IFNoYWRvdztcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTcHJpdGVTaGVldC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEVuY2Fwc3VsYXRlcyB0aGUgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBhc3NvY2lhdGVkIHdpdGggYSBzcHJpdGUgc2hlZXQuIEEgc3ByaXRlIHNoZWV0IGlzIGEgc2VyaWVzIG9mIGltYWdlcyAodXN1YWxseVxuXHQgKiBhbmltYXRpb24gZnJhbWVzKSBjb21iaW5lZCBpbnRvIGEgbGFyZ2VyIGltYWdlIChvciBpbWFnZXMpLiBGb3IgZXhhbXBsZSwgYW4gYW5pbWF0aW9uIGNvbnNpc3Rpbmcgb2YgZWlnaHQgMTAweDEwMFxuXHQgKiBpbWFnZXMgY291bGQgYmUgY29tYmluZWQgaW50byBhIHNpbmdsZSA0MDB4MjAwIHNwcml0ZSBzaGVldCAoNCBmcmFtZXMgYWNyb3NzIGJ5IDIgaGlnaCkuXG5cdCAqXG5cdCAqIFRoZSBkYXRhIHBhc3NlZCB0byB0aGUgU3ByaXRlU2hlZXQgY29uc3RydWN0b3IgZGVmaW5lczpcblx0ICogPG9sPlxuXHQgKiBcdDxsaT4gVGhlIHNvdXJjZSBpbWFnZSBvciBpbWFnZXMgdG8gdXNlLjwvbGk+XG5cdCAqIFx0PGxpPiBUaGUgcG9zaXRpb25zIG9mIGluZGl2aWR1YWwgaW1hZ2UgZnJhbWVzLjwvbGk+XG5cdCAqIFx0PGxpPiBTZXF1ZW5jZXMgb2YgZnJhbWVzIHRoYXQgZm9ybSBuYW1lZCBhbmltYXRpb25zLiBPcHRpb25hbC48L2xpPlxuXHQgKiBcdDxsaT4gVGhlIHRhcmdldCBwbGF5YmFjayBmcmFtZXJhdGUuIE9wdGlvbmFsLjwvbGk+XG5cdCAqIDwvb2w+XG5cdCAqIDxoMz5TcHJpdGVTaGVldCBGb3JtYXQ8L2gzPlxuXHQgKiBTcHJpdGVTaGVldHMgYXJlIGFuIG9iamVjdCB3aXRoIHR3byByZXF1aXJlZCBwcm9wZXJ0aWVzIChgaW1hZ2VzYCBhbmQgYGZyYW1lc2ApLCBhbmQgdHdvIG9wdGlvbmFsIHByb3BlcnRpZXNcblx0ICogKGBmcmFtZXJhdGVgIGFuZCBgYW5pbWF0aW9uc2ApLiBUaGlzIG1ha2VzIHRoZW0gZWFzeSB0byBkZWZpbmUgaW4gamF2YXNjcmlwdCBjb2RlLCBvciBpbiBKU09OLlxuXHQgKlxuXHQgKiA8aDQ+aW1hZ2VzPC9oND5cblx0ICogQW4gYXJyYXkgb2Ygc291cmNlIGltYWdlcy4gSW1hZ2VzIGNhbiBiZSBlaXRoZXIgYW4gSFRNbGltYWdlXG5cdCAqIGluc3RhbmNlLCBvciBhIHVyaSB0byBhbiBpbWFnZS4gVGhlIGZvcm1lciBpcyByZWNvbW1lbmRlZCB0byBjb250cm9sIHByZWxvYWRpbmcuXG5cdCAqXG5cdCAqIFx0aW1hZ2VzOiBbaW1hZ2UxLCBcInBhdGgvdG8vaW1hZ2UyLnBuZ1wiXSxcblx0ICpcblx0ICogPGg0PmZyYW1lczwvaDQ+XG5cdCAqIERlZmluZXMgdGhlIGluZGl2aWR1YWwgZnJhbWVzLiBUaGVyZSBhcmUgdHdvIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBmcmFtZSBkYXRhOlxuXHQgKiBXaGVuIGFsbCBvZiB0aGUgZnJhbWVzIGFyZSB0aGUgc2FtZSBzaXplIChpbiBhIGdyaWQpLCB1c2UgYW4gb2JqZWN0IHdpdGggYHdpZHRoYCwgYGhlaWdodGAsIGByZWdYYCwgYHJlZ1lgLFxuXHQgKiBhbmQgYGNvdW50YCBwcm9wZXJ0aWVzLlxuXHQgKlxuXHQgKiA8dWw+XG5cdCAqICA8bGk+YHdpZHRoYCAmIGBoZWlnaHRgIGFyZSByZXF1aXJlZCBhbmQgc3BlY2lmeSB0aGUgZGltZW5zaW9ucyBvZiB0aGUgZnJhbWVzPC9saT5cblx0ICogIDxsaT5gcmVnWGAgJiBgcmVnWWAgaW5kaWNhdGUgdGhlIHJlZ2lzdHJhdGlvbiBwb2ludCBvciBcIm9yaWdpblwiIG9mIHRoZSBmcmFtZXM8L2xpPlxuXHQgKiAgPGxpPmBzcGFjaW5nYCBpbmRpY2F0ZSB0aGUgc3BhY2luZyBiZXR3ZWVuIGZyYW1lczwvbGk+XG5cdCAqICA8bGk+YG1hcmdpbmAgc3BlY2lmeSB0aGUgbWFyZ2luIGFyb3VuZCB0aGUgaW1hZ2Uocyk8L2xpPlxuXHQgKiAgPGxpPmBjb3VudGAgYWxsb3dzIHlvdSB0byBzcGVjaWZ5IHRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBzcHJpdGVzaGVldDsgaWYgb21pdHRlZCwgdGhpcyB3aWxsXG5cdCAqICBiZSBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBzb3VyY2UgaW1hZ2VzIGFuZCB0aGUgZnJhbWVzLiBGcmFtZXMgd2lsbCBiZSBhc3NpZ25lZFxuXHQgKiAgaW5kZXhlcyBiYXNlZCBvbiB0aGVpciBwb3NpdGlvbiBpbiB0aGUgc291cmNlIGltYWdlcyAobGVmdCB0byByaWdodCwgdG9wIHRvIGJvdHRvbSkuPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogIFx0ZnJhbWVzOiB7d2lkdGg6NjQsIGhlaWdodDo2NCwgY291bnQ6MjAsIHJlZ1g6IDMyLCByZWdZOjY0LCBzcGFjaW5nOjAsIG1hcmdpbjowfVxuXHQgKlxuXHQgKiBJZiB0aGUgZnJhbWVzIGFyZSBvZiBkaWZmZXJlbnQgc2l6ZXMsIHVzZSBhbiBhcnJheSBvZiBmcmFtZSBkZWZpbml0aW9ucy4gRWFjaCBkZWZpbml0aW9uIGlzIGl0c2VsZiBhbiBhcnJheVxuXHQgKiB3aXRoIDQgcmVxdWlyZWQgYW5kIDMgb3B0aW9uYWwgZW50cmllcywgaW4gdGhlIG9yZGVyOlxuXHQgKlxuXHQgKiA8dWw+XG5cdCAqICA8bGk+VGhlIGZpcnN0IGZvdXIsIGB4YCwgYHlgLCBgd2lkdGhgLCBhbmQgYGhlaWdodGAgYXJlIHJlcXVpcmVkIGFuZCBkZWZpbmUgdGhlIGZyYW1lIHJlY3RhbmdsZS48L2xpPlxuXHQgKiAgPGxpPlRoZSBmaWZ0aCwgYGltYWdlSW5kZXhgLCBzcGVjaWZpZXMgdGhlIGluZGV4IG9mIHRoZSBzb3VyY2UgaW1hZ2UgKGRlZmF1bHRzIHRvIDApPC9saT5cblx0ICogIDxsaT5UaGUgbGFzdCB0d28sIGByZWdYYCBhbmQgYHJlZ1lgIHNwZWNpZnkgdGhlIHJlZ2lzdHJhdGlvbiBwb2ludCBvZiB0aGUgZnJhbWU8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiBcdGZyYW1lczogW1xuXHQgKiBcdFx0Ly8geCwgeSwgd2lkdGgsIGhlaWdodCwgaW1hZ2VJbmRleCosIHJlZ1gqLCByZWdZKlxuXHQgKiBcdFx0WzY0LCAwLCA5NiwgNjRdLFxuXHQgKiBcdFx0WzAsIDAsIDY0LCA2NCwgMSwgMzIsIDMyXVxuXHQgKiBcdFx0Ly8gZXRjLlxuXHQgKiBcdF1cblx0ICpcblx0ICogPGg0PmFuaW1hdGlvbnM8L2g0PlxuXHQgKiBPcHRpb25hbC4gQW4gb2JqZWN0IGRlZmluaW5nIHNlcXVlbmNlcyBvZiBmcmFtZXMgdG8gcGxheSBhcyBuYW1lZCBhbmltYXRpb25zLiBFYWNoIHByb3BlcnR5IGNvcnJlc3BvbmRzIHRvIGFuXG5cdCAqIGFuaW1hdGlvbiBvZiB0aGUgc2FtZSBuYW1lLiBFYWNoIGFuaW1hdGlvbiBtdXN0IHNwZWNpZnkgdGhlIGZyYW1lcyB0byBwbGF5LCBhbmQgbWF5XG5cdCAqIGFsc28gaW5jbHVkZSBhIHJlbGF0aXZlIHBsYXliYWNrIGBzcGVlZGAgKGV4LiAyIHdvdWxkIHBsYXliYWNrIGF0IGRvdWJsZSBzcGVlZCwgMC41IGF0IGhhbGYpLCBhbmRcblx0ICogdGhlIG5hbWUgb2YgdGhlIGBuZXh0YCBhbmltYXRpb24gdG8gc2VxdWVuY2UgdG8gYWZ0ZXIgaXQgY29tcGxldGVzLlxuXHQgKlxuXHQgKiBUaGVyZSBhcmUgdGhyZWUgZm9ybWF0cyBzdXBwb3J0ZWQgZm9yIGRlZmluaW5nIHRoZSBmcmFtZXMgaW4gYW4gYW5pbWF0aW9uLCB3aGljaCBjYW4gYmUgbWl4ZWQgYW5kIG1hdGNoZWQgYXMgYXBwcm9wcmlhdGU6XG5cdCAqIDxvbD5cblx0ICogXHQ8bGk+Zm9yIGEgc2luZ2xlIGZyYW1lIGFuaW1hdGlvbiwgeW91IGNhbiBzaW1wbHkgc3BlY2lmeSB0aGUgZnJhbWUgaW5kZXhcblx0ICpcblx0ICogXHRcdGFuaW1hdGlvbnM6IHtcblx0ICogXHRcdFx0c2l0OiA3XG5cdCAqIFx0XHR9XG5cdCAqXG5cdCAqIDwvbGk+XG5cdCAqIDxsaT5cblx0ICogICAgICBmb3IgYW4gYW5pbWF0aW9uIG9mIGNvbnNlY3V0aXZlIGZyYW1lcywgeW91IGNhbiB1c2UgYW4gYXJyYXkgd2l0aCB0d28gcmVxdWlyZWQsIGFuZCB0d28gb3B0aW9uYWwgZW50cmllc1xuXHQgKiBcdFx0aW4gdGhlIG9yZGVyOiBgc3RhcnRgLCBgZW5kYCwgYG5leHRgLCBhbmQgYHNwZWVkYC4gVGhpcyB3aWxsIHBsYXkgdGhlIGZyYW1lcyBmcm9tIHN0YXJ0IHRvIGVuZCBpbmNsdXNpdmUuXG5cdCAqXG5cdCAqIFx0XHRhbmltYXRpb25zOiB7XG5cdCAqIFx0XHRcdC8vIHN0YXJ0LCBlbmQsIG5leHQqLCBzcGVlZCpcblx0ICogXHRcdFx0cnVuOiBbMCwgOF0sXG5cdCAqIFx0XHRcdGp1bXA6IFs5LCAxMiwgXCJydW5cIiwgMl1cblx0ICogXHRcdH1cblx0ICpcblx0ICogIDwvbGk+XG5cdCAqICA8bGk+XG5cdCAqICAgICBmb3Igbm9uLWNvbnNlY3V0aXZlIGZyYW1lcywgeW91IGNhbiB1c2UgYW4gb2JqZWN0IHdpdGggYSBgZnJhbWVzYCBwcm9wZXJ0eSBkZWZpbmluZyBhbiBhcnJheSBvZiBmcmFtZVxuXHQgKiAgICAgaW5kZXhlcyB0byBwbGF5IGluIG9yZGVyLiBUaGUgb2JqZWN0IGNhbiBhbHNvIHNwZWNpZnkgYG5leHRgIGFuZCBgc3BlZWRgIHByb3BlcnRpZXMuXG5cdCAqXG5cdCAqIFx0XHRhbmltYXRpb25zOiB7XG5cdCAqIFx0XHRcdHdhbGs6IHtcblx0ICogXHRcdFx0XHRmcmFtZXM6IFsxLDIsMywzLDIsMV1cblx0ICogXHRcdFx0fSxcblx0ICogXHRcdFx0c2hvb3Q6IHtcblx0ICogXHRcdFx0XHRmcmFtZXM6IFsxLDQsNSw2XSxcblx0ICogXHRcdFx0XHRuZXh0OiBcIndhbGtcIixcblx0ICogXHRcdFx0XHRzcGVlZDogMC41XG5cdCAqIFx0XHRcdH1cblx0ICogXHRcdH1cblx0ICpcblx0ICogIDwvbGk+XG5cdCAqIDwvb2w+XG5cdCAqIDxzdHJvbmc+Tm90ZTo8L3N0cm9uZz4gdGhlIGBzcGVlZGAgcHJvcGVydHkgd2FzIGFkZGVkIGluIEVhc2VsSlMgMC43LjAuIEVhcmxpZXIgdmVyc2lvbnMgaGFkIGEgYGZyZXF1ZW5jeWBcblx0ICogcHJvcGVydHkgaW5zdGVhZCwgd2hpY2ggd2FzIHRoZSBpbnZlcnNlIG9mIGBzcGVlZGAuIEZvciBleGFtcGxlLCBhIHZhbHVlIG9mIFwiNFwiIHdvdWxkIGJlIDEvNCBub3JtYWwgc3BlZWQgaW5cblx0ICogZWFybGllciB2ZXJzaW9ucywgYnV0IGlzIDR4IG5vcm1hbCBzcGVlZCBpbiBFYXNlbEpTIDAuNy4wKy5cblx0ICpcblx0ICogPGg0PmZyYW1lcmF0ZTwvaDQ+XG5cdCAqIE9wdGlvbmFsLiBJbmRpY2F0ZXMgdGhlIGRlZmF1bHQgZnJhbWVyYXRlIHRvIHBsYXkgdGhpcyBzcHJpdGVzaGVldCBhdCBpbiBmcmFtZXMgcGVyIHNlY29uZC4gU2VlXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0L2ZyYW1lcmF0ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICpcblx0ICogXHRcdGZyYW1lcmF0ZTogMjBcblx0ICpcblx0ICogTm90ZSB0aGF0IHRoZSBTcHJpdGUgZnJhbWVyYXRlIHdpbGwgb25seSB3b3JrIGlmIHRoZSBzdGFnZSB1cGRhdGUgbWV0aG9kIGlzIHByb3ZpZGVkIHdpdGggdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aWNrOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IGdlbmVyYXRlZCBieSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiBcdFx0Y3JlYXRlanMuVGlja2VyLm9uKFwidGlja1wiLCBoYW5kbGVUaWNrKTtcblx0ICogXHRcdGZ1bmN0aW9uIGhhbmRsZVRpY2soZXZlbnQpIHtcblx0ICpcdFx0XHRzdGFnZS51cGRhdGUoZXZlbnQpO1xuXHQgKlx0XHR9XG5cdCAqXG5cdCAqIDxoMz5FeGFtcGxlPC9oMz5cblx0ICogVG8gZGVmaW5lIGEgc2ltcGxlIHNwcml0ZSBzaGVldCwgd2l0aCBhIHNpbmdsZSBpbWFnZSBcInNwcml0ZXMuanBnXCIgYXJyYW5nZWQgaW4gYSByZWd1bGFyIDUweDUwIGdyaWQgd2l0aCB0aHJlZVxuXHQgKiBhbmltYXRpb25zOiBcInN0YW5kXCIgc2hvd2luZyB0aGUgZmlyc3QgZnJhbWUsIFwicnVuXCIgbG9vcGluZyBmcmFtZSAxLTUgaW5jbHVzaXZlLCBhbmQgXCJqdW1wXCIgcGxheWluZyBmcmFtZSA2LTggYW5kXG5cdCAqIHNlcXVlbmNpbmcgYmFjayB0byBydW4uXG5cdCAqXG5cdCAqIFx0XHR2YXIgZGF0YSA9IHtcblx0ICogXHRcdFx0aW1hZ2VzOiBbXCJzcHJpdGVzLmpwZ1wiXSxcblx0ICogXHRcdFx0ZnJhbWVzOiB7d2lkdGg6NTAsIGhlaWdodDo1MH0sXG5cdCAqIFx0XHRcdGFuaW1hdGlvbnM6IHtcblx0ICogXHRcdFx0XHRzdGFuZDowLFxuXHQgKiBcdFx0XHRcdHJ1bjpbMSw1XSxcblx0ICogXHRcdFx0XHRqdW1wOls2LDgsXCJydW5cIl1cblx0ICogXHRcdFx0fVxuXHQgKiBcdFx0fTtcblx0ICogXHRcdHZhciBzcHJpdGVTaGVldCA9IG5ldyBjcmVhdGVqcy5TcHJpdGVTaGVldChkYXRhKTtcblx0ICogXHRcdHZhciBhbmltYXRpb24gPSBuZXcgY3JlYXRlanMuU3ByaXRlKHNwcml0ZVNoZWV0LCBcInJ1blwiKTtcblx0ICpcblx0ICogPGgzPkdlbmVyYXRpbmcgU3ByaXRlU2hlZXQgSW1hZ2VzPC9oMz5cblx0ICogU3ByaXRlc2hlZXRzIGNhbiBiZSBjcmVhdGVkIG1hbnVhbGx5IGJ5IGNvbWJpbmluZyBpbWFnZXMgaW4gUGhvdG9TaG9wLCBhbmQgc3BlY2lmeWluZyB0aGUgZnJhbWUgc2l6ZSBvclxuXHQgKiBjb29yZGluYXRlcyBtYW51YWxseSwgaG93ZXZlciB0aGVyZSBhcmUgYSBudW1iZXIgb2YgdG9vbHMgdGhhdCBmYWNpbGl0YXRlIHRoaXMuXG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5FeHBvcnRpbmcgU3ByaXRlU2hlZXRzIG9yIEhUTUw1IGNvbnRlbnQgZnJvbSBGbGFzaCBQcm8gc3VwcG9ydHMgdGhlIEVhc2VsSlMgU3ByaXRlU2hlZXQgZm9ybWF0LjwvbGk+XG5cdCAqICAgICA8bGk+VGhlIHBvcHVsYXIgPGEgaHJlZj1cImh0dHBzOi8vd3d3LmNvZGVhbmR3ZWIuY29tL3RleHR1cmVwYWNrZXIvZWFzZWxqc1wiIHRhcmdldD1cIl9ibGFua1wiPlRleHR1cmUgUGFja2VyPC9hPiBoYXNcblx0ICogICAgIEVhc2VsSlMgc3VwcG9ydC5cblx0ICogICAgIDxsaT5TV0YgYW5pbWF0aW9ucyBpbiBGbGFzaCBjYW4gYmUgZXhwb3J0ZWQgdG8gU3ByaXRlU2hlZXRzIHVzaW5nIDxhIGhyZWY9XCJodHRwOi8vY3JlYXRlanMuY29tL3pvZVwiIHRhcmdldD1cIl9ibGFua1wiPjwvYT48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiA8aDM+Q3Jvc3MgT3JpZ2luIElzc3VlczwvaDM+XG5cdCAqIDxzdHJvbmc+V2FybmluZzo8L3N0cm9uZz4gSW1hZ2VzIGxvYWRlZCBjcm9zcy1vcmlnaW4gd2lsbCB0aHJvdyBjcm9zcy1vcmlnaW4gc2VjdXJpdHkgZXJyb3JzIHdoZW4gaW50ZXJhY3RlZCB3aXRoXG5cdCAqIHVzaW5nOlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+YSBtb3VzZTwvbGk+XG5cdCAqICAgICA8bGk+bWV0aG9kcyBzdWNoIGFzIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lci9nZXRPYmplY3RVbmRlclBvaW50XCJ9fXt7L2Nyb3NzTGlua319PC9saT5cblx0ICogICAgIDxsaT5GaWx0ZXJzIChzZWUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319KTwvbGk+XG5cdCAqICAgICA8bGk+Y2FjaGluZyAoc2VlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvY2FjaGVcIn19e3svY3Jvc3NMaW5rfX0pPC9saT5cblx0ICogPC91bD5cblx0ICogWW91IGNhbiBnZXQgYXJvdW5kIHRoaXMgYnkgc2V0dGluZyBgY3Jvc3NPcmlnaW5gIHByb3BlcnR5IG9uIHlvdXIgaW1hZ2VzIGJlZm9yZSBwYXNzaW5nIHRoZW0gdG8gRWFzZWxKUywgb3Jcblx0ICogc2V0dGluZyB0aGUgYGNyb3NzT3JpZ2luYCBwcm9wZXJ0eSBvbiBQcmVsb2FkSlMnIExvYWRRdWV1ZSBvciBMb2FkSXRlbXMuXG5cdCAqXG5cdCAqIFx0XHR2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcblx0ICogXHRcdGltZy5jcm9zc09yaWdpbj1cIkFub255bW91c1wiO1xuXHQgKiBcdFx0aW1nLnNyYyA9IFwiaHR0cDovL3NlcnZlci13aXRoLUNPUlMtc3VwcG9ydC5jb20vcGF0aC90by9pbWFnZS5qcGdcIjtcblx0ICpcblx0ICogSWYgeW91IHBhc3Mgc3RyaW5nIHBhdGhzIHRvIFNwcml0ZVNoZWV0cywgdGhleSB3aWxsIG5vdCB3b3JrIGNyb3NzLW9yaWdpbi4gVGhlIHNlcnZlciB0aGF0IHN0b3JlcyB0aGUgaW1hZ2UgbXVzdFxuXHQgKiBzdXBwb3J0IGNyb3NzLW9yaWdpbiByZXF1ZXN0cywgb3IgdGhpcyB3aWxsIG5vdCB3b3JrLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgY2hlY2sgb3V0XG5cdCAqIDxhIGhyZWY9XCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0FjY2Vzc19jb250cm9sX0NPUlNcIiB0YXJnZXQ9XCJfYmxhbmtcIj5DT1JTIG92ZXJ2aWV3IG9uIE1ETjwvYT4uXG5cdCAqXG5cdCAqIEBjbGFzcyBTcHJpdGVTaGVldFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIFNwcml0ZVNoZWV0IGRhdGEuXG5cdCAqIEBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlclxuXHQgKiovXG5cdGZ1bmN0aW9uIFNwcml0ZVNoZWV0KGRhdGEpIHtcblx0XHR0aGlzLkV2ZW50RGlzcGF0Y2hlcl9jb25zdHJ1Y3RvcigpO1xuXG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciBhbGwgaW1hZ2VzIGFyZSBmaW5pc2hlZCBsb2FkaW5nLlxuXHRcdCAqIEBwcm9wZXJ0eSBjb21wbGV0ZVxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5jb21wbGV0ZSA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBTcGVjaWZpZXMgdGhlIGZyYW1lcmF0ZSB0byB1c2UgYnkgZGVmYXVsdCBmb3IgU3ByaXRlIGluc3RhbmNlcyB1c2luZyB0aGUgU3ByaXRlU2hlZXQuIFNlZSB0aGUgU3ByaXRlIGNsYXNzXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2ZyYW1lcmF0ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgZnJhbWVyYXRlXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuZnJhbWVyYXRlID0gMDtcblxuXG5cdFx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfYW5pbWF0aW9uc1xuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBBcnJheVxuXHRcdCAqKi9cblx0XHR0aGlzLl9hbmltYXRpb25zID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfZnJhbWVzXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIEFycmF5XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2ZyYW1lcyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2ltYWdlc1xuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBBcnJheVxuXHRcdCAqKi9cblx0XHR0aGlzLl9pbWFnZXMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9kYXRhXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqKi9cblx0XHR0aGlzLl9kYXRhID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZENvdW50XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9sb2FkQ291bnQgPSAwO1xuXG5cdFx0Ly8gb25seSB1c2VkIGZvciBzaW1wbGUgZnJhbWUgZGVmczpcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2ZyYW1lSGVpZ2h0XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9mcmFtZUhlaWdodCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2ZyYW1lV2lkdGhcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2ZyYW1lV2lkdGggPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9udW1GcmFtZXNcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX251bUZyYW1lcyA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3JlZ1hcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3JlZ1ggPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9yZWdZXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9yZWdZID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfc3BhY2luZ1xuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fc3BhY2luZyA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX21hcmdpblxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fbWFyZ2luID0gMDtcblxuXHRcdC8vIHNldHVwOlxuXHRcdHRoaXMuX3BhcnNlRGF0YShkYXRhKTtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChTcHJpdGVTaGVldCwgY3JlYXRlanMuRXZlbnREaXNwYXRjaGVyKTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXG4vLyBldmVudHM6XG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gYWxsIGltYWdlcyBhcmUgbG9hZGVkLiAgTm90ZSB0aGF0IHRoaXMgb25seSBmaXJlcyBpZiB0aGUgaW1hZ2VzXG5cdCAqIHdlcmUgbm90IGZ1bGx5IGxvYWRlZCB3aGVuIHRoZSBzcHJpdGUgc2hlZXQgd2FzIGluaXRpYWxpemVkLiBZb3Ugc2hvdWxkIGNoZWNrIHRoZSBjb21wbGV0ZSBwcm9wZXJ0eVxuXHQgKiB0byBwcmlvciB0byBhZGRpbmcgYSBsaXN0ZW5lci4gRXguXG5cdCAqXG5cdCAqIFx0dmFyIHNoZWV0ID0gbmV3IGNyZWF0ZWpzLlNwcml0ZVNoZWV0KGRhdGEpO1xuXHQgKiBcdGlmICghc2hlZXQuY29tcGxldGUpIHtcblx0ICogXHRcdC8vIG5vdCBwcmVsb2FkZWQsIGxpc3RlbiBmb3IgdGhlIGNvbXBsZXRlIGV2ZW50OlxuXHQgKiBcdFx0c2hlZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNvbXBsZXRlXCIsIGhhbmRsZXIpO1xuXHQgKiBcdH1cblx0ICpcblx0ICogQGV2ZW50IGNvbXBsZXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gZ2V0RnJhbWUgaXMgY2FsbGVkIHdpdGggYSB2YWxpZCBmcmFtZSBpbmRleC4gVGhpcyBpcyBwcmltYXJpbHkgaW50ZW5kZWQgZm9yIHVzZSBieSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldEJ1aWxkZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2hlbiBkb2luZyBvbi1kZW1hbmQgcmVuZGVyaW5nLlxuXHQgKiBAZXZlbnQgZ2V0ZnJhbWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBmcmFtZSBpbmRleC5cblx0ICogQHBhcmFtIHtPYmplY3R9IGZyYW1lIFRoZSBmcmFtZSBvYmplY3QgdGhhdCBnZXRGcmFtZSB3aWxsIHJldHVybi5cblx0ICovXG5cblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiBhbiBpbWFnZSBlbmNvdW50ZXJzIGFuIGVycm9yLiBBIFNwcml0ZVNoZWV0IHdpbGwgZGlzcGF0Y2ggYW4gZXJyb3IgZXZlbnQgZm9yIGVhY2ggaW1hZ2UgdGhhdFxuXHQgKiBlbmNvdW50ZXJzIGFuIGVycm9yLCBhbmQgd2lsbCBzdGlsbCBkaXNwYXRjaCBhIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0L2NvbXBsZXRlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IG9uY2UgYWxsIGltYWdlcyBhcmUgZmluaXNoZWQgcHJvY2Vzc2luZywgZXZlbiBpZiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZC5cblx0ICogQGV2ZW50IGVycm9yXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBvZiB0aGUgaW1hZ2UgdGhhdCBmYWlsZWQgdG8gbG9hZC5cblx0ICogQHNpbmNlIDAuOC4yXG5cdCAqL1xuXG5cbi8vIGdldHRlciAvIHNldHRlcnM6XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0L2FuaW1hdGlvbnM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXRBbmltYXRpb25zXG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdHAuZ2V0QW5pbWF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hbmltYXRpb25zLnNsaWNlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIGF2YWlsYWJsZSBhbmltYXRpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoaXMgc3ByaXRlIHNoZWV0IGFzIHN0cmluZ3MuXG5cdCAqIEBwcm9wZXJ0eSBhbmltYXRpb25zXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cdFx0XHRhbmltYXRpb25zOiB7IGdldDogcC5nZXRBbmltYXRpb25zIH1cblx0XHR9KTtcblx0fSBjYXRjaCAoZSkge31cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBmcmFtZXMgaW4gdGhlIHNwZWNpZmllZCBhbmltYXRpb24sIG9yIGluIHRoZSB3aG9sZSBzcHJpdGVcblx0ICogc2hlZXQgaWYgdGhlIGFuaW1hdGlvbiBwYXJhbSBpcyBvbWl0dGVkLiBSZXR1cm5zIDAgaWYgdGhlIHNwcml0ZXNoZWV0IHJlbGllcyBvbiBjYWxjdWxhdGVkIGZyYW1lIGNvdW50cywgYW5kXG5cdCAqIHRoZSBpbWFnZXMgaGF2ZSBub3QgYmVlbiBmdWxseSBsb2FkZWQuXG5cdCAqIEBtZXRob2QgZ2V0TnVtRnJhbWVzXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBhbmltYXRpb24gVGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBnZXQgYSBmcmFtZSBjb3VudCBmb3IuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIG51bWJlciBvZiBmcmFtZXMgaW4gdGhlIGFuaW1hdGlvbiwgb3IgaW4gdGhlIGVudGlyZSBzcHJpdGUgc2hlZXQgaWYgdGhlIGFuaW1hdGlvbiBwYXJhbSBpcyBvbWl0dGVkLlxuXHQgKi9cblx0cC5nZXROdW1GcmFtZXMgPSBmdW5jdGlvbihhbmltYXRpb24pIHtcblx0XHRpZiAoYW5pbWF0aW9uID09IG51bGwpIHtcblx0XHRcdHJldHVybiB0aGlzLl9mcmFtZXMgPyB0aGlzLl9mcmFtZXMubGVuZ3RoIDogdGhpcy5fbnVtRnJhbWVzIHx8IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBkYXRhID0gdGhpcy5fZGF0YVthbmltYXRpb25dO1xuXHRcdFx0aWYgKGRhdGEgPT0gbnVsbCkgeyByZXR1cm4gMDsgfVxuXHRcdFx0ZWxzZSB7IHJldHVybiBkYXRhLmZyYW1lcy5sZW5ndGg7IH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gb2JqZWN0IGRlZmluaW5nIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uLiBUaGUgcmV0dXJuZWQgb2JqZWN0IGNvbnRhaW5zOjxVTD5cblx0ICogXHQ8bGk+ZnJhbWVzOiBhbiBhcnJheSBvZiB0aGUgZnJhbWUgaWRzIGluIHRoZSBhbmltYXRpb248L2xpPlxuXHQgKiBcdDxsaT5zcGVlZDogdGhlIHBsYXliYWNrIHNwZWVkIGZvciB0aGlzIGFuaW1hdGlvbjwvbGk+XG5cdCAqIFx0PGxpPm5hbWU6IHRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb248L2xpPlxuXHQgKiBcdDxsaT5uZXh0OiB0aGUgZGVmYXVsdCBhbmltYXRpb24gdG8gcGxheSBuZXh0LiBJZiB0aGUgYW5pbWF0aW9uIGxvb3BzLCB0aGUgbmFtZSBhbmQgbmV4dCBwcm9wZXJ0eSB3aWxsIGJlIHRoZVxuXHQgKiBcdHNhbWUuPC9saT5cblx0ICogPC9VTD5cblx0ICogQG1ldGhvZCBnZXRBbmltYXRpb25cblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBnZXQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gYSBnZW5lcmljIG9iamVjdCB3aXRoIGZyYW1lcywgc3BlZWQsIG5hbWUsIGFuZCBuZXh0IHByb3BlcnRpZXMuXG5cdCAqKi9cblx0cC5nZXRBbmltYXRpb24gPSBmdW5jdGlvbihuYW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGFbbmFtZV07XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIGltYWdlIGFuZCBzb3VyY2UgcmVjdCBvZiB0aGUgc3BlY2lmaWVkIGZyYW1lLiBUaGUgcmV0dXJuZWQgb2JqZWN0IGhhczo8VUw+XG5cdCAqIFx0PGxpPmFuIGltYWdlIHByb3BlcnR5IGhvbGRpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGltYWdlIG9iamVjdCBpbiB3aGljaCB0aGUgZnJhbWUgaXMgZm91bmQ8L2xpPlxuXHQgKiBcdDxsaT5hIHJlY3QgcHJvcGVydHkgY29udGFpbmluZyBhIFJlY3RhbmdsZSBpbnN0YW5jZSB3aGljaCBkZWZpbmVzIHRoZSBib3VuZGFyaWVzIGZvciB0aGUgZnJhbWUgd2l0aGluIHRoYXRcblx0ICogXHRpbWFnZS48L2xpPlxuXHQgKiBcdDxsaT4gQSByZWdYIGFuZCByZWdZIHByb3BlcnR5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHJlZ1gvWSB2YWx1ZXMgZm9yIHRoZSBmcmFtZS5cblx0ICogPC9VTD5cblx0ICogQG1ldGhvZCBnZXRGcmFtZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVJbmRleCBUaGUgaW5kZXggb2YgdGhlIGZyYW1lLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IGEgZ2VuZXJpYyBvYmplY3Qgd2l0aCBpbWFnZSBhbmQgcmVjdCBwcm9wZXJ0aWVzLiBSZXR1cm5zIG51bGwgaWYgdGhlIGZyYW1lIGRvZXMgbm90IGV4aXN0LlxuXHQgKiovXG5cdHAuZ2V0RnJhbWUgPSBmdW5jdGlvbihmcmFtZUluZGV4KSB7XG5cdFx0dmFyIGZyYW1lO1xuXHRcdGlmICh0aGlzLl9mcmFtZXMgJiYgKGZyYW1lPXRoaXMuX2ZyYW1lc1tmcmFtZUluZGV4XSkpIHsgcmV0dXJuIGZyYW1lOyB9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7eyNjcm9zc0xpbmsgXCJSZWN0YW5nbGVcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UgZGVmaW5pbmcgdGhlIGJvdW5kcyBvZiB0aGUgc3BlY2lmaWVkIGZyYW1lIHJlbGF0aXZlXG5cdCAqIHRvIHRoZSBvcmlnaW4uIEZvciBleGFtcGxlLCBhIDkwIHggNzAgZnJhbWUgd2l0aCBhIHJlZ1ggb2YgNTAgYW5kIGEgcmVnWSBvZiA0MCB3b3VsZCByZXR1cm46XG5cdCAqXG5cdCAqIFx0W3g9LTUwLCB5PS00MCwgd2lkdGg9OTAsIGhlaWdodD03MF1cblx0ICpcblx0ICogQG1ldGhvZCBnZXRGcmFtZUJvdW5kc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVJbmRleCBUaGUgaW5kZXggb2YgdGhlIGZyYW1lLlxuXHQgKiBAcGFyYW0ge1JlY3RhbmdsZX0gW3JlY3RhbmdsZV0gQSBSZWN0YW5nbGUgaW5zdGFuY2UgdG8gY29weSB0aGUgdmFsdWVzIGludG8uIEJ5IGRlZmF1bHQgYSBuZXcgaW5zdGFuY2UgaXMgY3JlYXRlZC5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBBIFJlY3RhbmdsZSBpbnN0YW5jZS4gUmV0dXJucyBudWxsIGlmIHRoZSBmcmFtZSBkb2VzIG5vdCBleGlzdCwgb3IgdGhlIGltYWdlIGlzIG5vdCBmdWxseSBsb2FkZWQuXG5cdCAqKi9cblx0cC5nZXRGcmFtZUJvdW5kcyA9IGZ1bmN0aW9uKGZyYW1lSW5kZXgsIHJlY3RhbmdsZSkge1xuXHRcdHZhciBmcmFtZSA9IHRoaXMuZ2V0RnJhbWUoZnJhbWVJbmRleCk7XG5cdFx0cmV0dXJuIGZyYW1lID8gKHJlY3RhbmdsZXx8bmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSgpKS5zZXRWYWx1ZXMoLWZyYW1lLnJlZ1gsIC1mcmFtZS5yZWdZLCBmcmFtZS5yZWN0LndpZHRoLCBmcmFtZS5yZWN0LmhlaWdodCkgOiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbU3ByaXRlU2hlZXRdXCI7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNwcml0ZVNoZWV0IGNhbm5vdCBiZSBjbG9uZWQuIEEgU3ByaXRlU2hlZXQgY2FuIGJlIHNoYXJlZCBieSBtdWx0aXBsZSBTcHJpdGUgaW5zdGFuY2VzIHdpdGhvdXQgY2xvbmluZyBpdC5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyhcIlNwcml0ZVNoZWV0IGNhbm5vdCBiZSBjbG9uZWQuXCIpXG5cdH07XG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX3BhcnNlRGF0YVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBBbiBvYmplY3QgZGVzY3JpYmluZyB0aGUgU3ByaXRlU2hlZXQgZGF0YS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3BhcnNlRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHR2YXIgaSxsLG8sYTtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5mcmFtZXJhdGUgPSBkYXRhLmZyYW1lcmF0ZXx8MDtcblxuXHRcdC8vIHBhcnNlIGltYWdlczpcblx0XHRpZiAoZGF0YS5pbWFnZXMgJiYgKGw9ZGF0YS5pbWFnZXMubGVuZ3RoKSA+IDApIHtcblx0XHRcdGEgPSB0aGlzLl9pbWFnZXMgPSBbXTtcblx0XHRcdGZvciAoaT0wOyBpPGw7IGkrKykge1xuXHRcdFx0XHR2YXIgaW1nID0gZGF0YS5pbWFnZXNbaV07XG5cdFx0XHRcdGlmICh0eXBlb2YgaW1nID09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHR2YXIgc3JjID0gaW1nO1xuXHRcdFx0XHRcdGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG5cdFx0XHRcdFx0aW1nLnNyYyA9IHNyYztcblx0XHRcdFx0fVxuXHRcdFx0XHRhLnB1c2goaW1nKTtcblx0XHRcdFx0aWYgKCFpbWcuZ2V0Q29udGV4dCAmJiAhaW1nLm5hdHVyYWxXaWR0aCkge1xuXHRcdFx0XHRcdHRoaXMuX2xvYWRDb3VudCsrO1xuXHRcdFx0XHRcdHRoaXMuY29tcGxldGUgPSBmYWxzZTtcblx0XHRcdFx0XHQoZnVuY3Rpb24obywgc3JjKSB7IGltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHsgby5faGFuZGxlSW1hZ2VMb2FkKHNyYyk7IH0gfSkodGhpcywgc3JjKTtcblx0XHRcdFx0XHQoZnVuY3Rpb24obywgc3JjKSB7IGltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7IG8uX2hhbmRsZUltYWdlRXJyb3Ioc3JjKTsgfSB9KSh0aGlzLCBzcmMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gcGFyc2UgZnJhbWVzOlxuXHRcdGlmIChkYXRhLmZyYW1lcyA9PSBudWxsKSB7IC8vIG5vdGhpbmdcblx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YS5mcmFtZXMpKSB7XG5cdFx0XHR0aGlzLl9mcmFtZXMgPSBbXTtcblx0XHRcdGEgPSBkYXRhLmZyYW1lcztcblx0XHRcdGZvciAoaT0wLGw9YS5sZW5ndGg7aTxsO2krKykge1xuXHRcdFx0XHR2YXIgYXJyID0gYVtpXTtcblx0XHRcdFx0dGhpcy5fZnJhbWVzLnB1c2goe2ltYWdlOnRoaXMuX2ltYWdlc1thcnJbNF0/YXJyWzRdOjBdLCByZWN0Om5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoYXJyWzBdLGFyclsxXSxhcnJbMl0sYXJyWzNdKSwgcmVnWDphcnJbNV18fDAsIHJlZ1k6YXJyWzZdfHwwIH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvID0gZGF0YS5mcmFtZXM7XG5cdFx0XHR0aGlzLl9mcmFtZVdpZHRoID0gby53aWR0aDtcblx0XHRcdHRoaXMuX2ZyYW1lSGVpZ2h0ID0gby5oZWlnaHQ7XG5cdFx0XHR0aGlzLl9yZWdYID0gby5yZWdYfHwwO1xuXHRcdFx0dGhpcy5fcmVnWSA9IG8ucmVnWXx8MDtcblx0XHRcdHRoaXMuX3NwYWNpbmcgPSBvLnNwYWNpbmd8fDA7XG5cdFx0XHR0aGlzLl9tYXJnaW4gPSBvLm1hcmdpbnx8MDtcblx0XHRcdHRoaXMuX251bUZyYW1lcyA9IG8uY291bnQ7XG5cdFx0XHRpZiAodGhpcy5fbG9hZENvdW50ID09IDApIHsgdGhpcy5fY2FsY3VsYXRlRnJhbWVzKCk7IH1cblx0XHR9XG5cblx0XHQvLyBwYXJzZSBhbmltYXRpb25zOlxuXHRcdHRoaXMuX2FuaW1hdGlvbnMgPSBbXTtcblx0XHRpZiAoKG89ZGF0YS5hbmltYXRpb25zKSAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl9kYXRhID0ge307XG5cdFx0XHR2YXIgbmFtZTtcblx0XHRcdGZvciAobmFtZSBpbiBvKSB7XG5cdFx0XHRcdHZhciBhbmltID0ge25hbWU6bmFtZX07XG5cdFx0XHRcdHZhciBvYmogPSBvW25hbWVdO1xuXHRcdFx0XHRpZiAodHlwZW9mIG9iaiA9PSBcIm51bWJlclwiKSB7IC8vIHNpbmdsZSBmcmFtZVxuXHRcdFx0XHRcdGEgPSBhbmltLmZyYW1lcyA9IFtvYmpdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkgeyAvLyBzaW1wbGVcblx0XHRcdFx0XHRpZiAob2JqLmxlbmd0aCA9PSAxKSB7IGFuaW0uZnJhbWVzID0gW29ialswXV07IH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGFuaW0uc3BlZWQgPSBvYmpbM107XG5cdFx0XHRcdFx0XHRhbmltLm5leHQgPSBvYmpbMl07XG5cdFx0XHRcdFx0XHRhID0gYW5pbS5mcmFtZXMgPSBbXTtcblx0XHRcdFx0XHRcdGZvciAoaT1vYmpbMF07aTw9b2JqWzFdO2krKykge1xuXHRcdFx0XHRcdFx0XHRhLnB1c2goaSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgeyAvLyBjb21wbGV4XG5cdFx0XHRcdFx0YW5pbS5zcGVlZCA9IG9iai5zcGVlZDtcblx0XHRcdFx0XHRhbmltLm5leHQgPSBvYmoubmV4dDtcblx0XHRcdFx0XHR2YXIgZnJhbWVzID0gb2JqLmZyYW1lcztcblx0XHRcdFx0XHRhID0gYW5pbS5mcmFtZXMgPSAodHlwZW9mIGZyYW1lcyA9PSBcIm51bWJlclwiKSA/IFtmcmFtZXNdIDogZnJhbWVzLnNsaWNlKDApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChhbmltLm5leHQgPT09IHRydWUgfHwgYW5pbS5uZXh0ID09PSB1bmRlZmluZWQpIHsgYW5pbS5uZXh0ID0gbmFtZTsgfSAvLyBsb29wXG5cdFx0XHRcdGlmIChhbmltLm5leHQgPT09IGZhbHNlIHx8IChhLmxlbmd0aCA8IDIgJiYgYW5pbS5uZXh0ID09IG5hbWUpKSB7IGFuaW0ubmV4dCA9IG51bGw7IH0gLy8gc3RvcFxuXHRcdFx0XHRpZiAoIWFuaW0uc3BlZWQpIHsgYW5pbS5zcGVlZCA9IDE7IH1cblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9ucy5wdXNoKG5hbWUpO1xuXHRcdFx0XHR0aGlzLl9kYXRhW25hbWVdID0gYW5pbTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZUltYWdlTG9hZFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5faGFuZGxlSW1hZ2VMb2FkID0gZnVuY3Rpb24oc3JjKSB7XG5cdFx0aWYgKC0tdGhpcy5fbG9hZENvdW50ID09IDApIHtcblx0XHRcdHRoaXMuX2NhbGN1bGF0ZUZyYW1lcygpO1xuXHRcdFx0dGhpcy5jb21wbGV0ZSA9IHRydWU7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZUltYWdlRXJyb3Jcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5faGFuZGxlSW1hZ2VFcnJvciA9IGZ1bmN0aW9uIChzcmMpIHtcblx0XHR2YXIgZXJyb3JFdmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImVycm9yXCIpO1xuXHRcdGVycm9yRXZlbnQuc3JjID0gc3JjO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChlcnJvckV2ZW50KTtcblxuXHRcdC8vIENvbXBsZXRlIGlzIHN0aWxsIGRpc3BhdGNoZWQuXG5cdFx0aWYgKC0tdGhpcy5fbG9hZENvdW50ID09IDApIHtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfY2FsY3VsYXRlRnJhbWVzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9jYWxjdWxhdGVGcmFtZXMgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fZnJhbWVzIHx8IHRoaXMuX2ZyYW1lV2lkdGggPT0gMCkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2ZyYW1lcyA9IFtdO1xuXG5cdFx0dmFyIG1heEZyYW1lcyA9IHRoaXMuX251bUZyYW1lcyB8fCAxMDAwMDA7IC8vIGlmIHdlIGdvIG92ZXIgdGhpcywgc29tZXRoaW5nIGlzIHdyb25nLlxuXHRcdHZhciBmcmFtZUNvdW50ID0gMCwgZnJhbWVXaWR0aCA9IHRoaXMuX2ZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0ID0gdGhpcy5fZnJhbWVIZWlnaHQ7XG5cdFx0dmFyIHNwYWNpbmcgPSB0aGlzLl9zcGFjaW5nLCBtYXJnaW4gPSB0aGlzLl9tYXJnaW47XG5cdFx0XG5cdFx0aW1nTG9vcDpcblx0XHRmb3IgKHZhciBpPTAsIGltZ3M9dGhpcy5faW1hZ2VzOyBpPGltZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpbWcgPSBpbWdzW2ldLCBpbWdXID0gaW1nLndpZHRoLCBpbWdIID0gaW1nLmhlaWdodDtcblxuXHRcdFx0dmFyIHkgPSBtYXJnaW47XG5cdFx0XHR3aGlsZSAoeSA8PSBpbWdILW1hcmdpbi1mcmFtZUhlaWdodCkge1xuXHRcdFx0XHR2YXIgeCA9IG1hcmdpbjtcblx0XHRcdFx0d2hpbGUgKHggPD0gaW1nVy1tYXJnaW4tZnJhbWVXaWR0aCkge1xuXHRcdFx0XHRcdGlmIChmcmFtZUNvdW50ID49IG1heEZyYW1lcykgeyBicmVhayBpbWdMb29wOyB9XG5cdFx0XHRcdFx0ZnJhbWVDb3VudCsrO1xuXHRcdFx0XHRcdHRoaXMuX2ZyYW1lcy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0aW1hZ2U6IGltZyxcblx0XHRcdFx0XHRcdFx0cmVjdDogbmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSh4LCB5LCBmcmFtZVdpZHRoLCBmcmFtZUhlaWdodCksXG5cdFx0XHRcdFx0XHRcdHJlZ1g6IHRoaXMuX3JlZ1gsXG5cdFx0XHRcdFx0XHRcdHJlZ1k6IHRoaXMuX3JlZ1lcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHggKz0gZnJhbWVXaWR0aCtzcGFjaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHkgKz0gZnJhbWVIZWlnaHQrc3BhY2luZztcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fbnVtRnJhbWVzID0gZnJhbWVDb3VudDtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLlNwcml0ZVNoZWV0ID0gY3JlYXRlanMucHJvbW90ZShTcHJpdGVTaGVldCwgXCJFdmVudERpc3BhdGNoZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gR3JhcGhpY3MuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBUaGUgR3JhcGhpY3MgY2xhc3MgZXhwb3NlcyBhbiBlYXN5IHRvIHVzZSBBUEkgZm9yIGdlbmVyYXRpbmcgdmVjdG9yIGRyYXdpbmcgaW5zdHJ1Y3Rpb25zIGFuZCBkcmF3aW5nIHRoZW0gdG8gYVxuXHQgKiBzcGVjaWZpZWQgY29udGV4dC4gTm90ZSB0aGF0IHlvdSBjYW4gdXNlIEdyYXBoaWNzIHdpdGhvdXQgYW55IGRlcGVuZGVuY3kgb24gdGhlIEVhc2VsSlMgZnJhbWV3b3JrIGJ5IGNhbGxpbmcge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBkaXJlY3RseSwgb3IgaXQgY2FuIGJlIHVzZWQgd2l0aCB0aGUge3sjY3Jvc3NMaW5rIFwiU2hhcGVcIn19e3svY3Jvc3NMaW5rfX0gb2JqZWN0IHRvIGRyYXcgdmVjdG9yIGdyYXBoaWNzIHdpdGhpbiB0aGVcblx0ICogY29udGV4dCBvZiBhbiBFYXNlbEpTIGRpc3BsYXkgbGlzdC5cblx0ICpcblx0ICogVGhlcmUgYXJlIHR3byBhcHByb2FjaGVzIHRvIHdvcmtpbmcgd2l0aCBHcmFwaGljcyBvYmplY3Q6IGNhbGxpbmcgbWV0aG9kcyBvbiBhIEdyYXBoaWNzIGluc3RhbmNlICh0aGUgXCJHcmFwaGljcyBBUElcIiksIG9yXG5cdCAqIGluc3RhbnRpYXRpbmcgR3JhcGhpY3MgY29tbWFuZCBvYmplY3RzIGFuZCBhZGRpbmcgdGhlbSB0byB0aGUgZ3JhcGhpY3MgcXVldWUgdmlhIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogVGhlIGZvcm1lciBhYnN0cmFjdHMgdGhlIGxhdHRlciwgc2ltcGxpZnlpbmcgYmVnaW5uaW5nIGFuZCBlbmRpbmcgcGF0aHMsIGZpbGxzLCBhbmQgc3Ryb2tlcy5cblx0ICpcblx0ICogICAgICB2YXIgZyA9IG5ldyBjcmVhdGVqcy5HcmFwaGljcygpO1xuXHQgKiAgICAgIGcuc2V0U3Ryb2tlU3R5bGUoMSk7XG5cdCAqICAgICAgZy5iZWdpblN0cm9rZShcIiMwMDAwMDBcIik7XG5cdCAqICAgICAgZy5iZWdpbkZpbGwoXCJyZWRcIik7XG5cdCAqICAgICAgZy5kcmF3Q2lyY2xlKDAsMCwzMCk7XG5cdCAqXG5cdCAqIEFsbCBkcmF3aW5nIG1ldGhvZHMgaW4gR3JhcGhpY3MgcmV0dXJuIHRoZSBHcmFwaGljcyBpbnN0YW5jZSwgc28gdGhleSBjYW4gYmUgY2hhaW5lZCB0b2dldGhlci4gRm9yIGV4YW1wbGUsXG5cdCAqIHRoZSBmb2xsb3dpbmcgbGluZSBvZiBjb2RlIHdvdWxkIGdlbmVyYXRlIHRoZSBpbnN0cnVjdGlvbnMgdG8gZHJhdyBhIHJlY3RhbmdsZSB3aXRoIGEgcmVkIHN0cm9rZSBhbmQgYmx1ZSBmaWxsOlxuXHQgKlxuXHQgKiAgICAgIG15R3JhcGhpY3MuYmVnaW5TdHJva2UoXCJyZWRcIikuYmVnaW5GaWxsKFwiYmx1ZVwiKS5kcmF3UmVjdCgyMCwgMjAsIDEwMCwgNTApO1xuXHQgKlxuXHQgKiBFYWNoIGdyYXBoaWNzIEFQSSBjYWxsIGdlbmVyYXRlcyBhIGNvbW1hbmQgb2JqZWN0IChzZWUgYmVsb3cpLiBUaGUgbGFzdCBjb21tYW5kIHRvIGJlIGNyZWF0ZWQgY2FuIGJlIGFjY2Vzc2VkIHZpYVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9jb21tYW5kOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OlxuXHQgKlxuXHQgKiAgICAgIHZhciBmaWxsQ29tbWFuZCA9IG15R3JhcGhpY3MuYmVnaW5GaWxsKFwicmVkXCIpLmNvbW1hbmQ7XG5cdCAqICAgICAgLy8gLi4uIGxhdGVyLCB1cGRhdGUgdGhlIGZpbGwgc3R5bGUvY29sb3I6XG5cdCAqICAgICAgZmlsbENvbW1hbmQuc3R5bGUgPSBcImJsdWVcIjtcblx0ICogICAgICAvLyBvciBjaGFuZ2UgaXQgdG8gYSBiaXRtYXAgZmlsbDpcblx0ICogICAgICBmaWxsQ29tbWFuZC5iaXRtYXAobXlJbWFnZSk7XG5cdCAqXG5cdCAqIEZvciBtb3JlIGRpcmVjdCBjb250cm9sIG9mIHJlbmRlcmluZywgeW91IGNhbiBpbnN0YW50aWF0ZSBhbmQgYXBwZW5kIGNvbW1hbmQgb2JqZWN0cyB0byB0aGUgZ3JhcGhpY3MgcXVldWUgZGlyZWN0bHkuIEluIHRoaXMgY2FzZSwgeW91XG5cdCAqIG5lZWQgdG8gbWFuYWdlIHBhdGggY3JlYXRpb24gbWFudWFsbHksIGFuZCBlbnN1cmUgdGhhdCBmaWxsL3N0cm9rZSBpcyBhcHBsaWVkIHRvIGEgZGVmaW5lZCBwYXRoOlxuXHQgKlxuXHQgKiAgICAgIC8vIHN0YXJ0IGEgbmV3IHBhdGguIEdyYXBoaWNzLmJlZ2luQ21kIGlzIGEgcmV1c2FibGUgQmVnaW5QYXRoIGluc3RhbmNlOlxuXHQgKiAgICAgIG15R3JhcGhpY3MuYXBwZW5kKGNyZWF0ZWpzLkdyYXBoaWNzLmJlZ2luQ21kKTtcblx0ICogICAgICAvLyB3ZSBuZWVkIHRvIGRlZmluZSB0aGUgcGF0aCBiZWZvcmUgYXBwbHlpbmcgdGhlIGZpbGw6XG5cdCAqICAgICAgdmFyIGNpcmNsZSA9IG5ldyBjcmVhdGVqcy5HcmFwaGljcy5DaXJjbGUoMCwwLDMwKTtcblx0ICogICAgICBteUdyYXBoaWNzLmFwcGVuZChjaXJjbGUpO1xuXHQgKiAgICAgIC8vIGZpbGwgdGhlIHBhdGggd2UganVzdCBkZWZpbmVkOlxuXHQgKiAgICAgIHZhciBmaWxsID0gbmV3IGNyZWF0ZWpzLkdyYXBoaWNzLkZpbGwoXCJyZWRcIik7XG5cdCAqICAgICAgbXlHcmFwaGljcy5hcHBlbmQoZmlsbCk7XG5cdCAqXG5cdCAqIFRoZXNlIGFwcHJvYWNoZXMgY2FuIGJlIHVzZWQgdG9nZXRoZXIsIGZvciBleGFtcGxlIHRvIGluc2VydCBhIGN1c3RvbSBjb21tYW5kOlxuXHQgKlxuXHQgKiAgICAgIG15R3JhcGhpY3MuYmVnaW5GaWxsKFwicmVkXCIpO1xuXHQgKiAgICAgIHZhciBjdXN0b21Db21tYW5kID0gbmV3IEN1c3RvbVNwaXJhbENvbW1hbmQoZXRjKTtcblx0ICogICAgICBteUdyYXBoaWNzLmFwcGVuZChjdXN0b21Db21tYW5kKTtcblx0ICogICAgICBteUdyYXBoaWNzLmJlZ2luRmlsbChcImJsdWVcIik7XG5cdCAqICAgICAgbXlHcmFwaGljcy5kcmF3Q2lyY2xlKDAsIDAsIDMwKTtcblx0ICpcblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvIG9uIGNyZWF0aW5nIGN1c3RvbSBjb21tYW5kcy5cblx0ICpcblx0ICogPGg0PlRpbnkgQVBJPC9oND5cblx0ICogVGhlIEdyYXBoaWNzIGNsYXNzIGFsc28gaW5jbHVkZXMgYSBcInRpbnkgQVBJXCIsIHdoaWNoIGlzIG9uZSBvciB0d28tbGV0dGVyIG1ldGhvZHMgdGhhdCBhcmUgc2hvcnRjdXRzIGZvciBhbGwgb2YgdGhlXG5cdCAqIEdyYXBoaWNzIG1ldGhvZHMuIFRoZXNlIG1ldGhvZHMgYXJlIGdyZWF0IGZvciBjcmVhdGluZyBjb21wYWN0IGluc3RydWN0aW9ucywgYW5kIGlzIHVzZWQgYnkgdGhlIFRvb2xraXQgZm9yIENyZWF0ZUpTXG5cdCAqIHRvIGdlbmVyYXRlIHJlYWRhYmxlIGNvZGUuIEFsbCB0aW55IG1ldGhvZHMgYXJlIG1hcmtlZCBhcyBwcm90ZWN0ZWQsIHNvIHlvdSBjYW4gdmlldyB0aGVtIGJ5IGVuYWJsaW5nIHByb3RlY3RlZFxuXHQgKiBkZXNjcmlwdGlvbnMgaW4gdGhlIGRvY3MuXG5cdCAqXG5cdCAqIDx0YWJsZT5cblx0ICogICAgIDx0cj48dGQ+PGI+VGlueTwvYj48L3RkPjx0ZD48Yj5NZXRob2Q8L2I+PC90ZD48dGQ+PGI+VGlueTwvYj48L3RkPjx0ZD48Yj5NZXRob2Q8L2I+PC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5tdDwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL21vdmVUb1wifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPmx0PC90ZD4gPHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2xpbmVUb1wifX17ey9jcm9zc0xpbmt9fTwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+YS9hdDwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FyY1wifX17ey9jcm9zc0xpbmt9fSAvIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FyY1RvXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+YnQ8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZXppZXJDdXJ2ZVRvXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+cXQ8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9xdWFkcmF0aWNDdXJ2ZVRvXCJ9fXt7L2Nyb3NzTGlua319IChhbHNvIGN1cnZlVG8pPC90ZD5cblx0ICogICAgIDx0ZD5yPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvcmVjdFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPmNwPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvY2xvc2VQYXRoXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+YzwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2NsZWFyXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+ZjwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luRmlsbFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPmxmPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5MaW5lYXJHcmFkaWVudEZpbGxcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5yZjwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luUmFkaWFsR3JhZGllbnRGaWxsXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+YmY8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkJpdG1hcEZpbGxcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5lZjwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2VuZEZpbGxcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5zcyAvIHNkPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3Mvc2V0U3Ryb2tlU3R5bGVcIn19e3svY3Jvc3NMaW5rfX0gLyB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9zZXRTdHJva2VEYXNoXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+czwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luU3Ryb2tlXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+bHM8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkxpbmVhckdyYWRpZW50U3Ryb2tlXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+cnM8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpblJhZGlhbEdyYWRpZW50U3Ryb2tlXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+YnM8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkJpdG1hcFN0cm9rZVwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPmVzPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZW5kU3Ryb2tlXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+ZHI8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3UmVjdFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPnJyPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd1JvdW5kUmVjdFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPnJjPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd1JvdW5kUmVjdENvbXBsZXhcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5kYzwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdDaXJjbGVcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5kZTwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdFbGxpcHNlXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+ZHA8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3UG9seVN0YXJcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5wPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZGVjb2RlUGF0aFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqIDwvdGFibGU+XG5cdCAqXG5cdCAqIEhlcmUgaXMgdGhlIGFib3ZlIGV4YW1wbGUsIHVzaW5nIHRoZSB0aW55IEFQSSBpbnN0ZWFkLlxuXHQgKlxuXHQgKiAgICAgIG15R3JhcGhpY3MucyhcInJlZFwiKS5mKFwiYmx1ZVwiKS5yKDIwLCAyMCwgMTAwLCA1MCk7XG5cdCAqXG5cdCAqIEBjbGFzcyBHcmFwaGljc1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBHcmFwaGljcygpIHtcblxuXG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgYSByZWZlcmVuY2UgdG8gdGhlIGxhc3QgY29tbWFuZCB0aGF0IHdhcyBjcmVhdGVkIG9yIGFwcGVuZGVkLiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIHJldGFpbiBhIHJlZmVyZW5jZVxuXHRcdCAqIHRvIGEgRmlsbCBjb21tYW5kIGluIG9yZGVyIHRvIGR5bmFtaWNhbGx5IHVwZGF0ZSB0aGUgY29sb3IgbGF0ZXIgYnkgdXNpbmc6XG5cdFx0ICpcblx0XHQgKiBcdFx0dmFyIG15RmlsbCA9IG15R3JhcGhpY3MuYmVnaW5GaWxsKFwicmVkXCIpLmNvbW1hbmQ7XG5cdFx0ICogXHRcdC8vIHVwZGF0ZSBjb2xvciBsYXRlcjpcblx0XHQgKiBcdFx0bXlGaWxsLnN0eWxlID0gXCJ5ZWxsb3dcIjtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBjb21tYW5kXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICoqL1xuXHRcdHRoaXMuY29tbWFuZCA9IG51bGw7XG5cblxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3N0cm9rZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7U3Ryb2tlfVxuXHRcdCAqKi9cblx0XHR0aGlzLl9zdHJva2UgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9zdHJva2VTdHlsZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7U3Ryb2tlU3R5bGV9XG5cdFx0ICoqL1xuXHRcdHRoaXMuX3N0cm9rZVN0eWxlID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX29sZFN0cm9rZVN0eWxlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtTdHJva2VTdHlsZX1cblx0XHQgKiovXG5cdFx0dGhpcy5fb2xkU3Ryb2tlU3R5bGUgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfc3Ryb2tlRGFzaFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7U3Ryb2tlRGFzaH1cblx0XHQgKiovXG5cdFx0dGhpcy5fc3Ryb2tlRGFzaCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9vbGRTdHJva2VEYXNoXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtTdHJva2VEYXNofVxuXHRcdCAqKi9cblx0XHR0aGlzLl9vbGRTdHJva2VEYXNoID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfc3Ryb2tlSWdub3JlU2NhbGVcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqKi9cblx0XHR0aGlzLl9zdHJva2VJZ25vcmVTY2FsZSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9maWxsXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtGaWxsfVxuXHRcdCAqKi9cblx0XHR0aGlzLl9maWxsID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfaW5zdHJ1Y3Rpb25zXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiovXG5cdFx0dGhpcy5faW5zdHJ1Y3Rpb25zID0gW107XG5cblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgdGhlIGxhc3QgaW5zdHJ1Y3Rpb24gaW5kZXggdGhhdCB3YXMgY29tbWl0dGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfY29tbWl0SW5kZXhcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiovXG5cdFx0dGhpcy5fY29tbWl0SW5kZXggPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVW5jb21taXR0ZWQgaW5zdHJ1Y3Rpb25zLlxuXHRcdCAqIEBwcm9wZXJ0eSBfYWN0aXZlSW5zdHJ1Y3Rpb25zXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiovXG5cdFx0dGhpcy5fYWN0aXZlSW5zdHJ1Y3Rpb25zID0gW107XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGluZGljYXRlcyB0aGF0IHRoZXJlIGhhdmUgYmVlbiBjaGFuZ2VzIHRvIHRoZSBhY3RpdmVJbnN0cnVjdGlvbiBsaXN0IHNpbmNlIHRoZSBsYXN0IHVwZGF0ZUluc3RydWN0aW9ucyBjYWxsLlxuXHRcdCAqIEBwcm9wZXJ0eSBfZGlydHlcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiovXG5cdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEluZGV4IHRvIGRyYXcgZnJvbSBpZiBhIHN0b3JlIG9wZXJhdGlvbiBoYXMgaGFwcGVuZWQuXG5cdFx0ICogQHByb3BlcnR5IF9zdG9yZUluZGV4XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLl9zdG9yZUluZGV4ID0gMDtcblxuXHQvLyBzZXR1cDpcblx0XHR0aGlzLmNsZWFyKCk7XG5cdH1cblx0dmFyIHAgPSBHcmFwaGljcy5wcm90b3R5cGU7XG5cdHZhciBHID0gR3JhcGhpY3M7IC8vIHNob3J0Y3V0XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cbi8vIHN0YXRpYyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgYSBDU1MgY29tcGF0aWJsZSBjb2xvciBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBSR0IgbnVtZXJpYyBjb2xvciB2YWx1ZXMgaW4gdGhlIGZvcm1hdFxuXHQgKiBcInJnYmEoMjU1LDI1NSwyNTUsMS4wKVwiLCBvciBpZiBhbHBoYSBpcyBudWxsIHRoZW4gaW4gdGhlIGZvcm1hdCBcInJnYigyNTUsMjU1LDI1NSlcIi4gRm9yIGV4YW1wbGUsXG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuR3JhcGhpY3MuZ2V0UkdCKDUwLCAxMDAsIDE1MCwgMC41KTtcblx0ICogICAgICAvLyBSZXR1cm5zIFwicmdiYSg1MCwxMDAsMTUwLDAuNSlcIlxuXHQgKlxuXHQgKiBJdCBhbHNvIHN1cHBvcnRzIHBhc3NpbmcgYSBzaW5nbGUgaGV4IGNvbG9yIHZhbHVlIGFzIHRoZSBmaXJzdCBwYXJhbSwgYW5kIGFuIG9wdGlvbmFsIGFscGhhIHZhbHVlIGFzIHRoZSBzZWNvbmRcblx0ICogcGFyYW0uIEZvciBleGFtcGxlLFxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLkdyYXBoaWNzLmdldFJHQigweEZGMDBGRiwgMC4yKTtcblx0ICogICAgICAvLyBSZXR1cm5zIFwicmdiYSgyNTUsMCwyNTUsMC4yKVwiXG5cdCAqXG5cdCAqIEBtZXRob2QgZ2V0UkdCXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIgVGhlIHJlZCBjb21wb25lbnQgZm9yIHRoZSBjb2xvciwgYmV0d2VlbiAwIGFuZCAweEZGICgyNTUpLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZyBUaGUgZ3JlZW4gY29tcG9uZW50IGZvciB0aGUgY29sb3IsIGJldHdlZW4gMCBhbmQgMHhGRiAoMjU1KS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIGJsdWUgY29tcG9uZW50IGZvciB0aGUgY29sb3IsIGJldHdlZW4gMCBhbmQgMHhGRiAoMjU1KS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthbHBoYV0gVGhlIGFscGhhIGNvbXBvbmVudCBmb3IgdGhlIGNvbG9yIHdoZXJlIDAgaXMgZnVsbHkgdHJhbnNwYXJlbnQgYW5kIDEgaXMgZnVsbHkgb3BhcXVlLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IEEgQ1NTIGNvbXBhdGlibGUgY29sb3Igc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgUkdCIG51bWVyaWMgY29sb3IgdmFsdWVzIGluIHRoZSBmb3JtYXRcblx0ICogXCJyZ2JhKDI1NSwyNTUsMjU1LDEuMClcIiwgb3IgaWYgYWxwaGEgaXMgbnVsbCB0aGVuIGluIHRoZSBmb3JtYXQgXCJyZ2IoMjU1LDI1NSwyNTUpXCIuXG5cdCAqKi9cblx0R3JhcGhpY3MuZ2V0UkdCID0gZnVuY3Rpb24ociwgZywgYiwgYWxwaGEpIHtcblx0XHRpZiAociAhPSBudWxsICYmIGIgPT0gbnVsbCkge1xuXHRcdFx0YWxwaGEgPSBnO1xuXHRcdFx0YiA9IHImMHhGRjtcblx0XHRcdGcgPSByPj44JjB4RkY7XG5cdFx0XHRyID0gcj4+MTYmMHhGRjtcblx0XHR9XG5cdFx0aWYgKGFscGhhID09IG51bGwpIHtcblx0XHRcdHJldHVybiBcInJnYihcIityK1wiLFwiK2crXCIsXCIrYitcIilcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFwicmdiYShcIityK1wiLFwiK2crXCIsXCIrYitcIixcIithbHBoYStcIilcIjtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBDU1MgY29tcGF0aWJsZSBjb2xvciBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBIU0wgbnVtZXJpYyBjb2xvciB2YWx1ZXMgaW4gdGhlIGZvcm1hdCBcImhzbGEoMzYwLDEwMCwxMDAsMS4wKVwiLFxuXHQgKiBvciBpZiBhbHBoYSBpcyBudWxsIHRoZW4gaW4gdGhlIGZvcm1hdCBcImhzbCgzNjAsMTAwLDEwMClcIi5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5HcmFwaGljcy5nZXRIU0woMTUwLCAxMDAsIDcwKTtcblx0ICogICAgICAvLyBSZXR1cm5zIFwiaHNsKDE1MCwxMDAsNzApXCJcblx0ICpcblx0ICogQG1ldGhvZCBnZXRIU0xcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaHVlIFRoZSBodWUgY29tcG9uZW50IGZvciB0aGUgY29sb3IsIGJldHdlZW4gMCBhbmQgMzYwLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvbiBUaGUgc2F0dXJhdGlvbiBjb21wb25lbnQgZm9yIHRoZSBjb2xvciwgYmV0d2VlbiAwIGFuZCAxMDAuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsaWdodG5lc3MgVGhlIGxpZ2h0bmVzcyBjb21wb25lbnQgZm9yIHRoZSBjb2xvciwgYmV0d2VlbiAwIGFuZCAxMDAuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYWxwaGFdIFRoZSBhbHBoYSBjb21wb25lbnQgZm9yIHRoZSBjb2xvciB3aGVyZSAwIGlzIGZ1bGx5IHRyYW5zcGFyZW50IGFuZCAxIGlzIGZ1bGx5IG9wYXF1ZS5cblx0ICogQHJldHVybiB7U3RyaW5nfSBBIENTUyBjb21wYXRpYmxlIGNvbG9yIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIEhTTCBudW1lcmljIGNvbG9yIHZhbHVlcyBpbiB0aGUgZm9ybWF0XG5cdCAqIFwiaHNsYSgzNjAsMTAwLDEwMCwxLjApXCIsIG9yIGlmIGFscGhhIGlzIG51bGwgdGhlbiBpbiB0aGUgZm9ybWF0IFwiaHNsKDM2MCwxMDAsMTAwKVwiLlxuXHQgKiovXG5cdEdyYXBoaWNzLmdldEhTTCA9IGZ1bmN0aW9uKGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBhbHBoYSkge1xuXHRcdGlmIChhbHBoYSA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gXCJoc2woXCIrKGh1ZSUzNjApK1wiLFwiK3NhdHVyYXRpb24rXCIlLFwiK2xpZ2h0bmVzcytcIiUpXCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBcImhzbGEoXCIrKGh1ZSUzNjApK1wiLFwiK3NhdHVyYXRpb24rXCIlLFwiK2xpZ2h0bmVzcytcIiUsXCIrYWxwaGErXCIpXCI7XG5cdFx0fVxuXHR9O1xuXG5cbi8vIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQSByZXVzYWJsZSBpbnN0YW5jZSBvZiB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9CZWdpblBhdGhcIn19e3svY3Jvc3NMaW5rfX0gdG8gYXZvaWRcblx0ICogdW5uZWNlc3NhcnkgaW5zdGFudGlhdGlvbi5cblx0ICogQHByb3BlcnR5IGJlZ2luQ21kXG5cdCAqIEB0eXBlIHtHcmFwaGljcy5CZWdpblBhdGh9XG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHQgLy8gZGVmaW5lZCBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cblxuXHQvKipcblx0ICogTWFwIG9mIEJhc2U2NCBjaGFyYWN0ZXJzIHRvIHZhbHVlcy4gVXNlZCBieSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kZWNvZGVQYXRoXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAcHJvcGVydHkgQkFTRV82NFxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKiBAcmVhZG9ubHlcblx0ICogQHR5cGUge09iamVjdH1cblx0ICoqL1xuXHRHcmFwaGljcy5CQVNFXzY0ID0ge1wiQVwiOjAsXCJCXCI6MSxcIkNcIjoyLFwiRFwiOjMsXCJFXCI6NCxcIkZcIjo1LFwiR1wiOjYsXCJIXCI6NyxcIklcIjo4LFwiSlwiOjksXCJLXCI6MTAsXCJMXCI6MTEsXCJNXCI6MTIsXCJOXCI6MTMsXCJPXCI6MTQsXCJQXCI6MTUsXCJRXCI6MTYsXCJSXCI6MTcsXCJTXCI6MTgsXCJUXCI6MTksXCJVXCI6MjAsXCJWXCI6MjEsXCJXXCI6MjIsXCJYXCI6MjMsXCJZXCI6MjQsXCJaXCI6MjUsXCJhXCI6MjYsXCJiXCI6MjcsXCJjXCI6MjgsXCJkXCI6MjksXCJlXCI6MzAsXCJmXCI6MzEsXCJnXCI6MzIsXCJoXCI6MzMsXCJpXCI6MzQsXCJqXCI6MzUsXCJrXCI6MzYsXCJsXCI6MzcsXCJtXCI6MzgsXCJuXCI6MzksXCJvXCI6NDAsXCJwXCI6NDEsXCJxXCI6NDIsXCJyXCI6NDMsXCJzXCI6NDQsXCJ0XCI6NDUsXCJ1XCI6NDYsXCJ2XCI6NDcsXCJ3XCI6NDgsXCJ4XCI6NDksXCJ5XCI6NTAsXCJ6XCI6NTEsXCIwXCI6NTIsXCIxXCI6NTMsXCIyXCI6NTQsXCIzXCI6NTUsXCI0XCI6NTYsXCI1XCI6NTcsXCI2XCI6NTgsXCI3XCI6NTksXCI4XCI6NjAsXCI5XCI6NjEsXCIrXCI6NjIsXCIvXCI6NjN9O1xuXG5cdC8qKlxuXHQgKiBNYXBzIG51bWVyaWMgdmFsdWVzIGZvciB0aGUgY2FwcyBwYXJhbWV0ZXIgb2Yge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3Mvc2V0U3Ryb2tlU3R5bGVcIn19e3svY3Jvc3NMaW5rfX0gdG9cblx0ICogY29ycmVzcG9uZGluZyBzdHJpbmcgdmFsdWVzLiBUaGlzIGlzIHByaW1hcmlseSBmb3IgdXNlIHdpdGggdGhlIHRpbnkgQVBJLiBUaGUgbWFwcGluZ3MgYXJlIGFzIGZvbGxvd3M6IDAgdG9cblx0ICogXCJidXR0XCIsIDEgdG8gXCJyb3VuZFwiLCBhbmQgMiB0byBcInNxdWFyZVwiLlxuXHQgKiBGb3IgZXhhbXBsZSwgdG8gc2V0IHRoZSBsaW5lIGNhcHMgdG8gXCJzcXVhcmVcIjpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLnNzKDE2LCAyKTtcblx0ICpcblx0ICogQHByb3BlcnR5IFNUUk9LRV9DQVBTX01BUFxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKiBAcmVhZG9ubHlcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiovXG5cdEdyYXBoaWNzLlNUUk9LRV9DQVBTX01BUCA9IFtcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiXTtcblxuXHQvKipcblx0ICogTWFwcyBudW1lcmljIHZhbHVlcyBmb3IgdGhlIGpvaW50cyBwYXJhbWV0ZXIgb2Yge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3Mvc2V0U3Ryb2tlU3R5bGVcIn19e3svY3Jvc3NMaW5rfX0gdG9cblx0ICogY29ycmVzcG9uZGluZyBzdHJpbmcgdmFsdWVzLiBUaGlzIGlzIHByaW1hcmlseSBmb3IgdXNlIHdpdGggdGhlIHRpbnkgQVBJLiBUaGUgbWFwcGluZ3MgYXJlIGFzIGZvbGxvd3M6IDAgdG9cblx0ICogXCJtaXRlclwiLCAxIHRvIFwicm91bmRcIiwgYW5kIDIgdG8gXCJiZXZlbFwiLlxuXHQgKiBGb3IgZXhhbXBsZSwgdG8gc2V0IHRoZSBsaW5lIGpvaW50cyB0byBcImJldmVsXCI6XG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5zcygxNiwgMCwgMik7XG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBTVFJPS0VfSk9JTlRTX01BUFxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKiBAcmVhZG9ubHlcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiovXG5cdEdyYXBoaWNzLlNUUk9LRV9KT0lOVFNfTUFQID0gW1wibWl0ZXJcIiwgXCJyb3VuZFwiLCBcImJldmVsXCJdO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX2N0eFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cblx0ICoqL1xuXHR2YXIgY2FudmFzID0gKGNyZWF0ZWpzLmNyZWF0ZUNhbnZhcz9jcmVhdGVqcy5jcmVhdGVDYW52YXMoKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpKTtcblx0aWYgKGNhbnZhcy5nZXRDb250ZXh0KSB7XG5cdFx0R3JhcGhpY3MuX2N0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0Y2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDE7XG5cdH1cblxuXG4vLyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9pbnN0cnVjdGlvbnM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXRJbnN0cnVjdGlvbnNcblx0ICogQHJldHVybiB7QXJyYXl9XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0cC5nZXRJbnN0cnVjdGlvbnMgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnMoKTtcblx0XHRyZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBncmFwaGljcyBpbnN0cnVjdGlvbnMgYXJyYXkuIEVhY2ggZW50cnkgaXMgYSBncmFwaGljcyBjb21tYW5kIG9iamVjdCAoZXguIEdyYXBoaWNzLkZpbGwsIEdyYXBoaWNzLlJlY3QpXG5cdCAqIE1vZGlmeWluZyB0aGUgcmV0dXJuZWQgYXJyYXkgZGlyZWN0bHkgaXMgbm90IHJlY29tbWVuZGVkLCBhbmQgaXMgbGlrZWx5IHRvIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW91ci5cblx0ICpcblx0ICogVGhpcyBwcm9wZXJ0eSBpcyBtYWlubHkgaW50ZW5kZWQgZm9yIGludHJvc3BlY3Rpb24gb2YgdGhlIGluc3RydWN0aW9ucyAoZXguIGZvciBncmFwaGljcyBleHBvcnQpLlxuXHQgKiBAcHJvcGVydHkgaW5zdHJ1Y3Rpb25zXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cdFx0XHRpbnN0cnVjdGlvbnM6IHsgZ2V0OiBwLmdldEluc3RydWN0aW9ucyB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHt9XG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBHcmFwaGljcyBpbnN0YW5jZSBoYXMgbm8gZHJhd2luZyBjb21tYW5kcy5cblx0ICogQG1ldGhvZCBpc0VtcHR5XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGlzIEdyYXBoaWNzIGluc3RhbmNlIGhhcyBubyBkcmF3aW5nIGNvbW1hbmRzLlxuXHQgKiovXG5cdHAuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhKHRoaXMuX2luc3RydWN0aW9ucy5sZW5ndGggfHwgdGhpcy5fYWN0aXZlSW5zdHJ1Y3Rpb25zLmxlbmd0aCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS5cblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBkcmF3IHdhcyBoYW5kbGVkICh1c2VmdWwgZm9yIG92ZXJyaWRpbmcgZnVuY3Rpb25hbGl0eSkuXG5cdCAqXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBkcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIE9wdGlvbmFsIGRhdGEgdGhhdCBpcyBwYXNzZWQgdG8gZ3JhcGhpY3MgY29tbWFuZCBleGVjIG1ldGhvZHMuIFdoZW4gY2FsbGVkIGZyb20gYSBTaGFwZSBpbnN0YW5jZSwgdGhlIHNoYXBlIHBhc3NlcyBpdHNlbGYgYXMgdGhlIGRhdGEgcGFyYW1ldGVyLiBUaGlzIGNhbiBiZSB1c2VkIGJ5IGN1c3RvbSBncmFwaGljIGNvbW1hbmRzIHRvIGluc2VydCBjb250ZXh0dWFsIGRhdGEuXG5cdCAqKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBkYXRhKSB7XG5cdFx0dGhpcy5fdXBkYXRlSW5zdHJ1Y3Rpb25zKCk7XG5cdFx0dmFyIGluc3RyID0gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuXHRcdGZvciAodmFyIGk9dGhpcy5fc3RvcmVJbmRleCwgbD1pbnN0ci5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRpbnN0cltpXS5leGVjKGN0eCwgZGF0YSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBvbmx5IHRoZSBwYXRoIGRlc2NyaWJlZCBmb3IgdGhpcyBHcmFwaGljcyBpbnN0YW5jZSwgc2tpcHBpbmcgYW55IG5vbi1wYXRoIGluc3RydWN0aW9ucywgaW5jbHVkaW5nIGZpbGwgYW5kXG5cdCAqIHN0cm9rZSBkZXNjcmlwdGlvbnMuIFVzZWQgZm9yIDxjb2RlPkRpc3BsYXlPYmplY3QubWFzazwvY29kZT4gdG8gZHJhdyB0aGUgY2xpcHBpbmcgcGF0aCwgZm9yIGV4YW1wbGUuXG5cdCAqXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBkcmF3QXNQYXRoXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqKi9cblx0cC5kcmF3QXNQYXRoID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0dGhpcy5fdXBkYXRlSW5zdHJ1Y3Rpb25zKCk7XG5cdFx0dmFyIGluc3RyLCBpbnN0cnMgPSB0aGlzLl9pbnN0cnVjdGlvbnM7XG5cdFx0Zm9yICh2YXIgaT10aGlzLl9zdG9yZUluZGV4LCBsPWluc3Rycy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHQvLyB0aGUgZmlyc3QgY29tbWFuZCBpcyBhbHdheXMgYSBiZWdpblBhdGggY29tbWFuZC5cblx0XHRcdGlmICgoaW5zdHIgPSBpbnN0cnNbaV0pLnBhdGggIT09IGZhbHNlKSB7IGluc3RyLmV4ZWMoY3R4KTsgfVxuXHRcdH1cblx0fTtcblxuXG4vLyBwdWJsaWMgbWV0aG9kcyB0aGF0IG1hcCBkaXJlY3RseSB0byBjb250ZXh0IDJEIGNhbGxzOlxuXHQvKipcblx0ICogTW92ZXMgdGhlIGRyYXdpbmcgcG9pbnQgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbi4gQSB0aW55IEFQSSBtZXRob2QgXCJtdFwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIG1vdmVUb1xuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBtb3ZlIHRvLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBtb3ZlIHRvLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAubW92ZVRvID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5Nb3ZlVG8oeCx5KSwgdHJ1ZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgbGluZSBmcm9tIHRoZSBjdXJyZW50IGRyYXdpbmcgcG9pbnQgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbiwgd2hpY2ggYmVjb21lIHRoZSBuZXcgY3VycmVudCBkcmF3aW5nXG5cdCAqIHBvaW50LiBOb3RlIHRoYXQgeW91ICptdXN0KiBjYWxsIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL21vdmVUb1wifX17ey9jcm9zc0xpbmt9fSBiZWZvcmUgdGhlIGZpcnN0IGBsaW5lVG8oKWAuXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwibHRcIiBhbHNvIGV4aXN0cy5cblx0ICpcblx0ICogRm9yIGRldGFpbGVkIGluZm9ybWF0aW9uLCByZWFkIHRoZVxuXHQgKiA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjY29tcGxleC1zaGFwZXMtKHBhdGhzKVwiPlxuXHQgKiB3aGF0d2cgc3BlYzwvYT4uXG5cdCAqIEBtZXRob2QgbGluZVRvXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgdGhlIGRyYXdpbmcgcG9pbnQgc2hvdWxkIGRyYXcgdG8uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgdGhlIGRyYXdpbmcgcG9pbnQgc2hvdWxkIGRyYXcgdG8uXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5saW5lVG8gPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLkxpbmVUbyh4LHkpKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgYW4gYXJjIHdpdGggdGhlIHNwZWNpZmllZCBjb250cm9sIHBvaW50cyBhbmQgcmFkaXVzLiAgRm9yIGRldGFpbGVkIGluZm9ybWF0aW9uLCByZWFkIHRoZVxuXHQgKiA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjZG9tLWNvbnRleHQtMmQtYXJjdG9cIj5cblx0ICogd2hhdHdnIHNwZWM8L2E+LiBBIHRpbnkgQVBJIG1ldGhvZCBcImF0XCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYXJjVG9cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geDJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmFyY1RvID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5BcmNUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGFuIGFyYyBkZWZpbmVkIGJ5IHRoZSByYWRpdXMsIHN0YXJ0QW5nbGUgYW5kIGVuZEFuZ2xlIGFyZ3VtZW50cywgY2VudGVyZWQgYXQgdGhlIHBvc2l0aW9uICh4LCB5KS4gRm9yXG5cdCAqIGV4YW1wbGUsIHRvIGRyYXcgYSBmdWxsIGNpcmNsZSB3aXRoIGEgcmFkaXVzIG9mIDIwIGNlbnRlcmVkIGF0ICgxMDAsIDEwMCk6XG5cdCAqXG5cdCAqICAgICAgYXJjKDEwMCwgMTAwLCAyMCwgMCwgTWF0aC5QSSoyKTtcblx0ICpcblx0ICogRm9yIGRldGFpbGVkIGluZm9ybWF0aW9uLCByZWFkIHRoZVxuXHQgKiA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjZG9tLWNvbnRleHQtMmQtYXJjXCI+d2hhdHdnIHNwZWM8L2E+LlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImFcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBhcmNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRBbmdsZSBNZWFzdXJlZCBpbiByYWRpYW5zLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZW5kQW5nbGUgTWVhc3VyZWQgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtCb29sZWFufSBhbnRpY2xvY2t3aXNlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hcmMgPSBmdW5jdGlvbih4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLkFyYyh4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgcXVhZHJhdGljIGN1cnZlIGZyb20gdGhlIGN1cnJlbnQgZHJhd2luZyBwb2ludCB0byAoeCwgeSkgdXNpbmcgdGhlIGNvbnRyb2wgcG9pbnQgKGNweCwgY3B5KS4gRm9yIGRldGFpbGVkXG5cdCAqIGluZm9ybWF0aW9uLCByZWFkIHRoZSA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjZG9tLWNvbnRleHQtMmQtcXVhZHJhdGljY3VydmV0b1wiPlxuXHQgKiB3aGF0d2cgc3BlYzwvYT4uIEEgdGlueSBBUEkgbWV0aG9kIFwicXRcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBxdWFkcmF0aWNDdXJ2ZVRvXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNweVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAucXVhZHJhdGljQ3VydmVUbyA9IGZ1bmN0aW9uKGNweCwgY3B5LCB4LCB5KSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLlF1YWRyYXRpY0N1cnZlVG8oY3B4LCBjcHksIHgsIHkpKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgYSBiZXppZXIgY3VydmUgZnJvbSB0aGUgY3VycmVudCBkcmF3aW5nIHBvaW50IHRvICh4LCB5KSB1c2luZyB0aGUgY29udHJvbCBwb2ludHMgKGNwMXgsIGNwMXkpIGFuZCAoY3AyeCxcblx0ICogY3AyeSkuIEZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiwgcmVhZCB0aGVcblx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2RvbS1jb250ZXh0LTJkLWJlemllcmN1cnZldG9cIj5cblx0ICogd2hhdHdnIHNwZWM8L2E+LiBBIHRpbnkgQVBJIG1ldGhvZCBcImJ0XCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYmV6aWVyQ3VydmVUb1xuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AxeFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AxeVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AyeFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AyeVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuQmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgcmVjdGFuZ2xlIGF0ICh4LCB5KSB3aXRoIHRoZSBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodCB1c2luZyB0aGUgY3VycmVudCBmaWxsIGFuZC9vciBzdHJva2UuXG5cdCAqIEZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiwgcmVhZCB0aGVcblx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2RvbS1jb250ZXh0LTJkLXJlY3RcIj5cblx0ICogd2hhdHdnIHNwZWM8L2E+LiBBIHRpbnkgQVBJIG1ldGhvZCBcInJcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCByZWN0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFdpZHRoIG9mIHRoZSByZWN0YW5nbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGggSGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLnJlY3QgPSBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLlJlY3QoeCwgeSwgdywgaCkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbG9zZXMgdGhlIGN1cnJlbnQgcGF0aCwgZWZmZWN0aXZlbHkgZHJhd2luZyBhIGxpbmUgZnJvbSB0aGUgY3VycmVudCBkcmF3aW5nIHBvaW50IHRvIHRoZSBmaXJzdCBkcmF3aW5nIHBvaW50IHNwZWNpZmllZFxuXHQgKiBzaW5jZSB0aGUgZmlsbCBvciBzdHJva2Ugd2FzIGxhc3Qgc2V0LiBBIHRpbnkgQVBJIG1ldGhvZCBcImNwXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgY2xvc2VQYXRoXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5jbG9zZVBhdGggPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWN0aXZlSW5zdHJ1Y3Rpb25zLmxlbmd0aCA/IHRoaXMuYXBwZW5kKG5ldyBHLkNsb3NlUGF0aCgpKSA6IHRoaXM7XG5cdH07XG5cblxuLy8gcHVibGljIG1ldGhvZHMgdGhhdCByb3VnaGx5IG1hcCB0byBGbGFzaCBncmFwaGljcyBBUElzOlxuXHQvKipcblx0ICogQ2xlYXJzIGFsbCBkcmF3aW5nIGluc3RydWN0aW9ucywgZWZmZWN0aXZlbHkgcmVzZXR0aW5nIHRoaXMgR3JhcGhpY3MgaW5zdGFuY2UuIEFueSBsaW5lIGFuZCBmaWxsIHN0eWxlcyB3aWxsIG5lZWRcblx0ICogdG8gYmUgcmVkZWZpbmVkIHRvIGRyYXcgc2hhcGVzIGZvbGxvd2luZyBhIGNsZWFyIGNhbGwuIEEgdGlueSBBUEkgbWV0aG9kIFwiY1wiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGNsZWFyXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5jbGVhciA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2luc3RydWN0aW9ucy5sZW5ndGggPSB0aGlzLl9hY3RpdmVJbnN0cnVjdGlvbnMubGVuZ3RoID0gdGhpcy5fY29tbWl0SW5kZXggPSAwO1xuXHRcdHRoaXMuX3N0cm9rZVN0eWxlID0gdGhpcy5fb2xkU3Ryb2tlU3R5bGUgPSB0aGlzLl9zdHJva2UgPSB0aGlzLl9maWxsID0gdGhpcy5fc3Ryb2tlRGFzaCA9IHRoaXMuX29sZFN0cm9rZURhc2ggPSBudWxsO1xuXHRcdHRoaXMuX2RpcnR5ID0gdGhpcy5fc3Ryb2tlSWdub3JlU2NhbGUgPSBmYWxzZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW5zIGEgZmlsbCB3aXRoIHRoZSBzcGVjaWZpZWQgY29sb3IuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC4gQSB0aW55IEFQSSBtZXRob2QgXCJmXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYmVnaW5GaWxsXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBBIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlIChleC4gXCJyZWRcIiwgXCIjRkYwMDAwXCIsIG9yIFwicmdiYSgyNTUsMCwwLDAuNSlcIikuIFNldHRpbmcgdG9cblx0ICogbnVsbCB3aWxsIHJlc3VsdCBpbiBubyBmaWxsLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmVnaW5GaWxsID0gZnVuY3Rpb24oY29sb3IpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0RmlsbChjb2xvciA/IG5ldyBHLkZpbGwoY29sb3IpIDogbnVsbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2lucyBhIGxpbmVhciBncmFkaWVudCBmaWxsIGRlZmluZWQgYnkgdGhlIGxpbmUgKHgwLCB5MCkgdG8gKHgxLCB5MSkuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC4gRm9yXG5cdCAqIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgY29kZSBkZWZpbmVzIGEgYmxhY2sgdG8gd2hpdGUgdmVydGljYWwgZ3JhZGllbnQgcmFuZ2luZyBmcm9tIDIwcHggdG8gMTIwcHgsIGFuZCBkcmF3cyBhXG5cdCAqIHNxdWFyZSB0byBkaXNwbGF5IGl0OlxuXHQgKlxuXHQgKiAgICAgIG15R3JhcGhpY3MuYmVnaW5MaW5lYXJHcmFkaWVudEZpbGwoW1wiIzAwMFwiLFwiI0ZGRlwiXSwgWzAsIDFdLCAwLCAyMCwgMCwgMTIwKS5kcmF3UmVjdCgyMCwgMjAsIDEyMCwgMTIwKTtcblx0ICpcblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJsZlwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlZ2luTGluZWFyR3JhZGllbnRGaWxsXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBBbiBhcnJheSBvZiBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZXMuIEZvciBleGFtcGxlLCBbXCIjRjAwXCIsXCIjMDBGXCJdIHdvdWxkIGRlZmluZSBhIGdyYWRpZW50XG5cdCAqIGRyYXdpbmcgZnJvbSByZWQgdG8gYmx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zIEFuIGFycmF5IG9mIGdyYWRpZW50IHBvc2l0aW9ucyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjb2xvcnMuIEZvciBleGFtcGxlLCBbMC4xLCAwLjldIHdvdWxkIGRyYXdcblx0ICogdGhlIGZpcnN0IGNvbG9yIHRvIDEwJSB0aGVuIGludGVycG9sYXRpbmcgdG8gdGhlIHNlY29uZCBjb2xvciBhdCA5MCUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MCBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTAgVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTEgVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5iZWdpbkxpbmVhckdyYWRpZW50RmlsbCA9IGZ1bmN0aW9uKGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHgxLCB5MSkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRGaWxsKG5ldyBHLkZpbGwoKS5saW5lYXJHcmFkaWVudChjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCB4MSwgeTEpKTtcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW5zIGEgcmFkaWFsIGdyYWRpZW50IGZpbGwuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC4gRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgY29kZSBkZWZpbmVzIGEgcmVkIHRvXG5cdCAqIGJsdWUgcmFkaWFsIGdyYWRpZW50IGNlbnRlcmVkIGF0ICgxMDAsIDEwMCksIHdpdGggYSByYWRpdXMgb2YgNTAsIGFuZCBkcmF3cyBhIGNpcmNsZSB0byBkaXNwbGF5IGl0OlxuXHQgKlxuXHQgKiAgICAgIG15R3JhcGhpY3MuYmVnaW5SYWRpYWxHcmFkaWVudEZpbGwoW1wiI0YwMFwiLFwiIzAwRlwiXSwgWzAsIDFdLCAxMDAsIDEwMCwgMCwgMTAwLCAxMDAsIDUwKS5kcmF3Q2lyY2xlKDEwMCwgMTAwLCA1MCk7XG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwicmZcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBiZWdpblJhZGlhbEdyYWRpZW50RmlsbFxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnMgQW4gYXJyYXkgb2YgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWVzLiBGb3IgZXhhbXBsZSwgW1wiI0YwMFwiLFwiIzAwRlwiXSB3b3VsZCBkZWZpbmVcblx0ICogYSBncmFkaWVudCBkcmF3aW5nIGZyb20gcmVkIHRvIGJsdWUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvcyBBbiBhcnJheSBvZiBncmFkaWVudCBwb3NpdGlvbnMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgY29sb3JzLiBGb3IgZXhhbXBsZSwgWzAuMSxcblx0ICogMC45XSB3b3VsZCBkcmF3IHRoZSBmaXJzdCBjb2xvciB0byAxMCUgdGhlbiBpbnRlcnBvbGF0aW5nIHRvIHRoZSBzZWNvbmQgY29sb3IgYXQgOTAlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDAgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMCBSYWRpdXMgb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDEgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMSBSYWRpdXMgb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmVnaW5SYWRpYWxHcmFkaWVudEZpbGwgPSBmdW5jdGlvbihjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCByMCwgeDEsIHkxLCByMSkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRGaWxsKG5ldyBHLkZpbGwoKS5yYWRpYWxHcmFkaWVudChjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCByMCwgeDEsIHkxLCByMSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBCZWdpbnMgYSBwYXR0ZXJuIGZpbGwgdXNpbmcgdGhlIHNwZWNpZmllZCBpbWFnZS4gVGhpcyBlbmRzIHRoZSBjdXJyZW50IHN1Yi1wYXRoLiBBIHRpbnkgQVBJIG1ldGhvZCBcImJmXCIgYWxzb1xuXHQgKiBleGlzdHMuXG5cdCAqIEBtZXRob2QgYmVnaW5CaXRtYXBGaWxsXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudH0gaW1hZ2UgVGhlIEltYWdlLCBDYW52YXMsIG9yIFZpZGVvIG9iamVjdCB0byB1c2Vcblx0ICogYXMgdGhlIHBhdHRlcm4uIE11c3QgYmUgbG9hZGVkIHByaW9yIHRvIGNyZWF0aW5nIGEgYml0bWFwIGZpbGwsIG9yIHRoZSBmaWxsIHdpbGwgYmUgZW1wdHkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSByZXBldGl0aW9uIE9wdGlvbmFsLiBJbmRpY2F0ZXMgd2hldGhlciB0byByZXBlYXQgdGhlIGltYWdlIGluIHRoZSBmaWxsIGFyZWEuIE9uZSBvZiBcInJlcGVhdFwiLFxuXHQgKiBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gRGVmYXVsdHMgdG8gXCJyZXBlYXRcIi4gTm90ZSB0aGF0IEZpcmVmb3ggZG9lcyBub3Qgc3VwcG9ydCBcInJlcGVhdC14XCIgb3Jcblx0ICogXCJyZXBlYXQteVwiIChsYXRlc3QgdGVzdHMgd2VyZSBpbiBGRiAyMC4wKSwgYW5kIHdpbGwgZGVmYXVsdCB0byBcInJlcGVhdFwiLlxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXggT3B0aW9uYWwuIFNwZWNpZmllcyBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBmb3IgdGhlIGJpdG1hcCBmaWxsLiBUaGlzIHRyYW5zZm9ybWF0aW9uXG5cdCAqIHdpbGwgYmUgYXBwbGllZCByZWxhdGl2ZSB0byB0aGUgcGFyZW50IHRyYW5zZm9ybS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlZ2luQml0bWFwRmlsbCA9IGZ1bmN0aW9uKGltYWdlLCByZXBldGl0aW9uLCBtYXRyaXgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0RmlsbChuZXcgRy5GaWxsKG51bGwsbWF0cml4KS5iaXRtYXAoaW1hZ2UsIHJlcGV0aXRpb24pKTtcblx0fTtcblxuXHQvKipcblx0ICogRW5kcyB0aGUgY3VycmVudCBzdWItcGF0aCwgYW5kIGJlZ2lucyBhIG5ldyBvbmUgd2l0aCBubyBmaWxsLiBGdW5jdGlvbmFsbHkgaWRlbnRpY2FsIHRvIDxjb2RlPmJlZ2luRmlsbChudWxsKTwvY29kZT4uXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwiZWZcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBlbmRGaWxsXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5lbmRGaWxsID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYmVnaW5GaWxsKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHN0cm9rZSBzdHlsZS4gTGlrZSBhbGwgZHJhd2luZyBtZXRob2RzLCB0aGlzIGNhbiBiZSBjaGFpbmVkLCBzbyB5b3UgY2FuIGRlZmluZVxuXHQgKiB0aGUgc3Ryb2tlIHN0eWxlIGFuZCBjb2xvciBpbiBhIHNpbmdsZSBsaW5lIG9mIGNvZGUgbGlrZSBzbzpcblx0ICpcblx0ICogXHRteUdyYXBoaWNzLnNldFN0cm9rZVN0eWxlKDgsXCJyb3VuZFwiKS5iZWdpblN0cm9rZShcIiNGMDBcIik7XG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwic3NcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBzZXRTdHJva2VTdHlsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdGhpY2tuZXNzIFRoZSB3aWR0aCBvZiB0aGUgc3Ryb2tlLlxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gW2NhcHM9MF0gSW5kaWNhdGVzIHRoZSB0eXBlIG9mIGNhcHMgdG8gdXNlIGF0IHRoZSBlbmQgb2YgbGluZXMuIE9uZSBvZiBidXR0LFxuXHQgKiByb3VuZCwgb3Igc3F1YXJlLiBEZWZhdWx0cyB0byBcImJ1dHRcIi4gQWxzbyBhY2NlcHRzIHRoZSB2YWx1ZXMgMCAoYnV0dCksIDEgKHJvdW5kKSwgYW5kIDIgKHNxdWFyZSkgZm9yIHVzZSB3aXRoXG5cdCAqIHRoZSB0aW55IEFQSS5cblx0ICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IFtqb2ludHM9MF0gU3BlY2lmaWVzIHRoZSB0eXBlIG9mIGpvaW50cyB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZXJlIHR3byBsaW5lcyBtZWV0LlxuXHQgKiBPbmUgb2YgYmV2ZWwsIHJvdW5kLCBvciBtaXRlci4gRGVmYXVsdHMgdG8gXCJtaXRlclwiLiBBbHNvIGFjY2VwdHMgdGhlIHZhbHVlcyAwIChtaXRlciksIDEgKHJvdW5kKSwgYW5kIDIgKGJldmVsKVxuXHQgKiBmb3IgdXNlIHdpdGggdGhlIHRpbnkgQVBJLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW21pdGVyTGltaXQ9MTBdIElmIGpvaW50cyBpcyBzZXQgdG8gXCJtaXRlclwiLCB0aGVuIHlvdSBjYW4gc3BlY2lmeSBhIG1pdGVyIGxpbWl0IHJhdGlvIHdoaWNoXG5cdCAqIGNvbnRyb2xzIGF0IHdoYXQgcG9pbnQgYSBtaXRlcmVkIGpvaW50IHdpbGwgYmUgY2xpcHBlZC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbaWdub3JlU2NhbGU9ZmFsc2VdIElmIHRydWUsIHRoZSBzdHJva2Ugd2lsbCBiZSBkcmF3biBhdCB0aGUgc3BlY2lmaWVkIHRoaWNrbmVzcyByZWdhcmRsZXNzXG5cdCAqIG9mIGFjdGl2ZSB0cmFuc2Zvcm1hdGlvbnMuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5zZXRTdHJva2VTdHlsZSA9IGZ1bmN0aW9uKHRoaWNrbmVzcywgY2Fwcywgam9pbnRzLCBtaXRlckxpbWl0LCBpZ25vcmVTY2FsZSkge1xuXHRcdHRoaXMuX3VwZGF0ZUluc3RydWN0aW9ucyh0cnVlKTtcblx0XHR0aGlzLl9zdHJva2VTdHlsZSA9IHRoaXMuY29tbWFuZCA9IG5ldyBHLlN0cm9rZVN0eWxlKHRoaWNrbmVzcywgY2Fwcywgam9pbnRzLCBtaXRlckxpbWl0LCBpZ25vcmVTY2FsZSk7XG5cblx0XHQvLyBpZ25vcmVTY2FsZSBsaXZlcyBvbiBTdHJva2UsIG5vdCBTdHJva2VTdHlsZSwgc28gd2UgZG8gYSBsaXR0bGUgdHJpY2tlcnk6XG5cdFx0aWYgKHRoaXMuX3N0cm9rZSkgeyB0aGlzLl9zdHJva2UuaWdub3JlU2NhbGUgPSBpZ25vcmVTY2FsZTsgfVxuXHRcdHRoaXMuX3N0cm9rZUlnbm9yZVNjYWxlID0gaWdub3JlU2NhbGU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2V0cyBvciBjbGVhcnMgdGhlIHN0cm9rZSBkYXNoIHBhdHRlcm4uXG5cdCAqXG5cdCAqIFx0bXlHcmFwaGljcy5zZXRTdHJva2VEYXNoKFsyMCwgMTBdLCAwKTtcblx0ICpcblx0ICogQSB0aW55IEFQSSBtZXRob2QgYHNkYCBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBzZXRTdHJva2VEYXNoXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtzZWdtZW50c10gQW4gYXJyYXkgc3BlY2lmeWluZyB0aGUgZGFzaCBwYXR0ZXJuLCBhbHRlcm5hdGluZyBiZXR3ZWVuIGxpbmUgYW5kIGdhcC5cblx0ICogRm9yIGV4YW1wbGUsIGBbMjAsMTBdYCB3b3VsZCBjcmVhdGUgYSBwYXR0ZXJuIG9mIDIwIHBpeGVsIGxpbmVzIHdpdGggMTAgcGl4ZWwgZ2FwcyBiZXR3ZWVuIHRoZW0uXG5cdCAqIFBhc3NpbmcgbnVsbCBvciBhbiBlbXB0eSBhcnJheSB3aWxsIGNsZWFyIHRoZSBleGlzdGluZyBzdHJva2UgZGFzaC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXQ9MF0gVGhlIG9mZnNldCBvZiB0aGUgZGFzaCBwYXR0ZXJuLiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIGluY3JlbWVudCB0aGlzIHZhbHVlIHRvIGNyZWF0ZSBhIFwibWFyY2hpbmcgYW50c1wiIGVmZmVjdC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLnNldFN0cm9rZURhc2ggPSBmdW5jdGlvbihzZWdtZW50cywgb2Zmc2V0KSB7XG5cdFx0dGhpcy5fdXBkYXRlSW5zdHJ1Y3Rpb25zKHRydWUpO1xuXHRcdHRoaXMuX3N0cm9rZURhc2ggPSB0aGlzLmNvbW1hbmQgPSBuZXcgRy5TdHJva2VEYXNoKHNlZ21lbnRzLCBvZmZzZXQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBCZWdpbnMgYSBzdHJva2Ugd2l0aCB0aGUgc3BlY2lmaWVkIGNvbG9yLiBUaGlzIGVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGguIEEgdGlueSBBUEkgbWV0aG9kIFwic1wiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlZ2luU3Ryb2tlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBBIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlIChleC4gXCIjRkYwMDAwXCIsIFwicmVkXCIsIG9yIFwicmdiYSgyNTUsMCwwLDAuNSlcIikuIFNldHRpbmcgdG9cblx0ICogbnVsbCB3aWxsIHJlc3VsdCBpbiBubyBzdHJva2UuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5iZWdpblN0cm9rZSA9IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldFN0cm9rZShjb2xvciA/IG5ldyBHLlN0cm9rZShjb2xvcikgOiBudWxsKTtcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW5zIGEgbGluZWFyIGdyYWRpZW50IHN0cm9rZSBkZWZpbmVkIGJ5IHRoZSBsaW5lICh4MCwgeTApIHRvICh4MSwgeTEpLiBUaGlzIGVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGguIEZvclxuXHQgKiBleGFtcGxlLCB0aGUgZm9sbG93aW5nIGNvZGUgZGVmaW5lcyBhIGJsYWNrIHRvIHdoaXRlIHZlcnRpY2FsIGdyYWRpZW50IHJhbmdpbmcgZnJvbSAyMHB4IHRvIDEyMHB4LCBhbmQgZHJhd3MgYVxuXHQgKiBzcXVhcmUgdG8gZGlzcGxheSBpdDpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLnNldFN0cm9rZVN0eWxlKDEwKS5cblx0ICogICAgICAgICAgYmVnaW5MaW5lYXJHcmFkaWVudFN0cm9rZShbXCIjMDAwXCIsXCIjRkZGXCJdLCBbMCwgMV0sIDAsIDIwLCAwLCAxMjApLmRyYXdSZWN0KDIwLCAyMCwgMTIwLCAxMjApO1xuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImxzXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYmVnaW5MaW5lYXJHcmFkaWVudFN0cm9rZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnMgQW4gYXJyYXkgb2YgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWVzLiBGb3IgZXhhbXBsZSwgW1wiI0YwMFwiLFwiIzAwRlwiXSB3b3VsZCBkZWZpbmVcblx0ICogYSBncmFkaWVudCBkcmF3aW5nIGZyb20gcmVkIHRvIGJsdWUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvcyBBbiBhcnJheSBvZiBncmFkaWVudCBwb3NpdGlvbnMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgY29sb3JzLiBGb3IgZXhhbXBsZSwgWzAuMSxcblx0ICogMC45XSB3b3VsZCBkcmF3IHRoZSBmaXJzdCBjb2xvciB0byAxMCUgdGhlbiBpbnRlcnBvbGF0aW5nIHRvIHRoZSBzZWNvbmQgY29sb3IgYXQgOTAlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDAgVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwIFRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MSBUaGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmVnaW5MaW5lYXJHcmFkaWVudFN0cm9rZSA9IGZ1bmN0aW9uKGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHgxLCB5MSkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRTdHJva2UobmV3IEcuU3Ryb2tlKCkubGluZWFyR3JhZGllbnQoY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgeDEsIHkxKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2lucyBhIHJhZGlhbCBncmFkaWVudCBzdHJva2UuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC4gRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgY29kZSBkZWZpbmVzIGEgcmVkIHRvXG5cdCAqIGJsdWUgcmFkaWFsIGdyYWRpZW50IGNlbnRlcmVkIGF0ICgxMDAsIDEwMCksIHdpdGggYSByYWRpdXMgb2YgNTAsIGFuZCBkcmF3cyBhIHJlY3RhbmdsZSB0byBkaXNwbGF5IGl0OlxuXHQgKlxuXHQgKiAgICAgIG15R3JhcGhpY3Muc2V0U3Ryb2tlU3R5bGUoMTApXG5cdCAqICAgICAgICAgIC5iZWdpblJhZGlhbEdyYWRpZW50U3Ryb2tlKFtcIiNGMDBcIixcIiMwMEZcIl0sIFswLCAxXSwgMTAwLCAxMDAsIDAsIDEwMCwgMTAwLCA1MClcblx0ICogICAgICAgICAgLmRyYXdSZWN0KDUwLCA5MCwgMTUwLCAxMTApO1xuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcInJzXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYmVnaW5SYWRpYWxHcmFkaWVudFN0cm9rZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnMgQW4gYXJyYXkgb2YgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWVzLiBGb3IgZXhhbXBsZSwgW1wiI0YwMFwiLFwiIzAwRlwiXSB3b3VsZCBkZWZpbmVcblx0ICogYSBncmFkaWVudCBkcmF3aW5nIGZyb20gcmVkIHRvIGJsdWUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvcyBBbiBhcnJheSBvZiBncmFkaWVudCBwb3NpdGlvbnMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgY29sb3JzLiBGb3IgZXhhbXBsZSwgWzAuMSxcblx0ICogMC45XSB3b3VsZCBkcmF3IHRoZSBmaXJzdCBjb2xvciB0byAxMCUgdGhlbiBpbnRlcnBvbGF0aW5nIHRvIHRoZSBzZWNvbmQgY29sb3IgYXQgOTAlLCB0aGVuIGRyYXcgdGhlIHNlY29uZCBjb2xvclxuXHQgKiB0byAxMDAlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDAgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMCBSYWRpdXMgb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDEgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMSBSYWRpdXMgb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmVnaW5SYWRpYWxHcmFkaWVudFN0cm9rZSA9IGZ1bmN0aW9uKGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHIwLCB4MSwgeTEsIHIxKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldFN0cm9rZShuZXcgRy5TdHJva2UoKS5yYWRpYWxHcmFkaWVudChjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCByMCwgeDEsIHkxLCByMSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBCZWdpbnMgYSBwYXR0ZXJuIGZpbGwgdXNpbmcgdGhlIHNwZWNpZmllZCBpbWFnZS4gVGhpcyBlbmRzIHRoZSBjdXJyZW50IHN1Yi1wYXRoLiBOb3RlIHRoYXQgdW5saWtlIGJpdG1hcCBmaWxscyxcblx0ICogc3Ryb2tlcyBkbyBub3QgY3VycmVudGx5IHN1cHBvcnQgYSBtYXRyaXggcGFyYW1ldGVyIGR1ZSB0byBsaW1pdGF0aW9ucyBpbiB0aGUgY2FudmFzIEFQSS4gQSB0aW55IEFQSSBtZXRob2QgXCJic1wiXG5cdCAqIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlZ2luQml0bWFwU3Ryb2tlXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudH0gaW1hZ2UgVGhlIEltYWdlLCBDYW52YXMsIG9yIFZpZGVvIG9iamVjdCB0byB1c2Vcblx0ICogYXMgdGhlIHBhdHRlcm4uIE11c3QgYmUgbG9hZGVkIHByaW9yIHRvIGNyZWF0aW5nIGEgYml0bWFwIGZpbGwsIG9yIHRoZSBmaWxsIHdpbGwgYmUgZW1wdHkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcmVwZXRpdGlvbj1yZXBlYXRdIE9wdGlvbmFsLiBJbmRpY2F0ZXMgd2hldGhlciB0byByZXBlYXQgdGhlIGltYWdlIGluIHRoZSBmaWxsIGFyZWEuIE9uZSBvZlxuXHQgKiBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gRGVmYXVsdHMgdG8gXCJyZXBlYXRcIi5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlZ2luQml0bWFwU3Ryb2tlID0gZnVuY3Rpb24oaW1hZ2UsIHJlcGV0aXRpb24pIHtcblx0XHQvLyBOT1RFOiBtYXRyaXggaXMgbm90IHN1cHBvcnRlZCBmb3Igc3Ryb2tlIGJlY2F1c2UgdHJhbnNmb3JtcyBvbiBzdHJva2VzIGFsc28gYWZmZWN0IHRoZSBkcmF3biBzdHJva2Ugd2lkdGguXG5cdFx0cmV0dXJuIHRoaXMuX3NldFN0cm9rZShuZXcgRy5TdHJva2UoKS5iaXRtYXAoaW1hZ2UsIHJlcGV0aXRpb24pKTtcblx0fTtcblxuXHQvKipcblx0ICogRW5kcyB0aGUgY3VycmVudCBzdWItcGF0aCwgYW5kIGJlZ2lucyBhIG5ldyBvbmUgd2l0aCBubyBzdHJva2UuIEZ1bmN0aW9uYWxseSBpZGVudGljYWwgdG8gPGNvZGU+YmVnaW5TdHJva2UobnVsbCk8L2NvZGU+LlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImVzXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgZW5kU3Ryb2tlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5lbmRTdHJva2UgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5iZWdpblN0cm9rZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBNYXBzIHRoZSBmYW1pbGlhciBBY3Rpb25TY3JpcHQgPGNvZGU+Y3VydmVUbygpPC9jb2RlPiBtZXRob2QgdG8gdGhlIGZ1bmN0aW9uYWxseSBzaW1pbGFyIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3F1YWRyYXRpY0N1cnZlVG9cIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLlxuXHQgKiBAbWV0aG9kIHF1YWRyYXRpY0N1cnZlVG9cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNweFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3B5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5jdXJ2ZVRvID0gcC5xdWFkcmF0aWNDdXJ2ZVRvO1xuXG5cdC8qKlxuXHQgKlxuXHQgKiBNYXBzIHRoZSBmYW1pbGlhciBBY3Rpb25TY3JpcHQgPGNvZGU+ZHJhd1JlY3QoKTwvY29kZT4gbWV0aG9kIHRvIHRoZSBmdW5jdGlvbmFsbHkgc2ltaWxhciB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9yZWN0XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZC5cblx0ICogQG1ldGhvZCBkcmF3UmVjdFxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdyBXaWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoIEhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5kcmF3UmVjdCA9IHAucmVjdDtcblxuXHQvKipcblx0ICogRHJhd3MgYSByb3VuZGVkIHJlY3RhbmdsZSB3aXRoIGFsbCBjb3JuZXJzIHdpdGggdGhlIHNwZWNpZmllZCByYWRpdXMuXG5cdCAqIEBtZXRob2QgZHJhd1JvdW5kUmVjdFxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gd1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIENvcm5lciByYWRpdXMuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5kcmF3Um91bmRSZWN0ID0gZnVuY3Rpb24oeCwgeSwgdywgaCwgcmFkaXVzKSB7XG5cdFx0cmV0dXJuIHRoaXMuZHJhd1JvdW5kUmVjdENvbXBsZXgoeCwgeSwgdywgaCwgcmFkaXVzLCByYWRpdXMsIHJhZGl1cywgcmFkaXVzKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgYSByb3VuZGVkIHJlY3RhbmdsZSB3aXRoIGRpZmZlcmVudCBjb3JuZXIgcmFkaWkuIFN1cHBvcnRzIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSBjb3JuZXIgcmFkaWkuIEEgdGlueSBBUElcblx0ICogbWV0aG9kIFwicmNcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBkcmF3Um91bmRSZWN0Q29tcGxleFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlIHRvIGRyYXcgdGhlIHJvdW5kIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlIHRvIGRyYXcgdGhlIHJvdW5kIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFRoZSB3aWR0aCBvZiB0aGUgcm91bmQgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGggVGhlIGhlaWdodCBvZiB0aGUgcm91bmQgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1RMIFRvcCBsZWZ0IGNvcm5lciByYWRpdXMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUUiBUb3AgcmlnaHQgY29ybmVyIHJhZGl1cy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c0JSIEJvdHRvbSByaWdodCBjb3JuZXIgcmFkaXVzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzQkwgQm90dG9tIGxlZnQgY29ybmVyIHJhZGl1cy5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmRyYXdSb3VuZFJlY3RDb21wbGV4ID0gZnVuY3Rpb24oeCwgeSwgdywgaCwgcmFkaXVzVEwsIHJhZGl1c1RSLCByYWRpdXNCUiwgcmFkaXVzQkwpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuUm91bmRSZWN0KHgsIHksIHcsIGgsIHJhZGl1c1RMLCByYWRpdXNUUiwgcmFkaXVzQlIsIHJhZGl1c0JMKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgY2lyY2xlIHdpdGggdGhlIHNwZWNpZmllZCByYWRpdXMgYXQgKHgsIHkpLlxuXHQgKlxuXHQgKiAgICAgIHZhciBnID0gbmV3IGNyZWF0ZWpzLkdyYXBoaWNzKCk7XG5cdCAqXHQgICAgZy5zZXRTdHJva2VTdHlsZSgxKTtcblx0ICpcdCAgICBnLmJlZ2luU3Ryb2tlKGNyZWF0ZWpzLkdyYXBoaWNzLmdldFJHQigwLDAsMCkpO1xuXHQgKlx0ICAgIGcuYmVnaW5GaWxsKGNyZWF0ZWpzLkdyYXBoaWNzLmdldFJHQigyNTUsMCwwKSk7XG5cdCAqXHQgICAgZy5kcmF3Q2lyY2xlKDAsMCwzKTtcblx0ICpcblx0ICpcdCAgICB2YXIgcyA9IG5ldyBjcmVhdGVqcy5TaGFwZShnKTtcblx0ICpcdFx0cy54ID0gMTAwO1xuXHQgKlx0XHRzLnkgPSAxMDA7XG5cdCAqXG5cdCAqXHQgICAgc3RhZ2UuYWRkQ2hpbGQocyk7XG5cdCAqXHQgICAgc3RhZ2UudXBkYXRlKCk7XG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwiZGNcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBkcmF3Q2lyY2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IHggY29vcmRpbmF0ZSBjZW50ZXIgcG9pbnQgb2YgY2lyY2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSB5IGNvb3JkaW5hdGUgY2VudGVyIHBvaW50IG9mIGNpcmNsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgY2lyY2xlLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuZHJhd0NpcmNsZSA9IGZ1bmN0aW9uKHgsIHksIHJhZGl1cykge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5DaXJjbGUoeCwgeSwgcmFkaXVzKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGFuIGVsbGlwc2UgKG92YWwpIHdpdGggYSBzcGVjaWZpZWQgd2lkdGggKHcpIGFuZCBoZWlnaHQgKGgpLiBTaW1pbGFyIHRvIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdDaXJjbGVcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIGV4Y2VwdCB0aGUgd2lkdGggYW5kIGhlaWdodCBjYW4gYmUgZGlmZmVyZW50LiBBIHRpbnkgQVBJIG1ldGhvZCBcImRlXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgZHJhd0VsbGlwc2Vcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIGxlZnQgY29vcmRpbmF0ZSBwb2ludCBvZiB0aGUgZWxsaXBzZS4gTm90ZSB0aGF0IHRoaXMgaXMgZGlmZmVyZW50IGZyb20ge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd0NpcmNsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aGljaCBkcmF3cyBmcm9tIGNlbnRlci5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHRvcCBjb29yZGluYXRlIHBvaW50IG9mIHRoZSBlbGxpcHNlLiBOb3RlIHRoYXQgdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Q2lyY2xlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdoaWNoIGRyYXdzIGZyb20gdGhlIGNlbnRlci5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHcgVGhlIGhlaWdodCAoaG9yaXpvbnRhbCBkaWFtZXRlcikgb2YgdGhlIGVsbGlwc2UuIFRoZSBob3Jpem9udGFsIHJhZGl1cyB3aWxsIGJlIGhhbGYgb2YgdGhpc1xuXHQgKiBudW1iZXIuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoIFRoZSB3aWR0aCAodmVydGljYWwgZGlhbWV0ZXIpIG9mIHRoZSBlbGxpcHNlLiBUaGUgdmVydGljYWwgcmFkaXVzIHdpbGwgYmUgaGFsZiBvZiB0aGlzIG51bWJlci5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmRyYXdFbGxpcHNlID0gZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5FbGxpcHNlKHgsIHksIHcsIGgpKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgYSBzdGFyIGlmIHBvaW50U2l6ZSBpcyBncmVhdGVyIHRoYW4gMCwgb3IgYSByZWd1bGFyIHBvbHlnb24gaWYgcG9pbnRTaXplIGlzIDAgd2l0aCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZlxuXHQgKiBwb2ludHMuIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIGNvZGUgd2lsbCBkcmF3IGEgZmFtaWxpYXIgNSBwb2ludGVkIHN0YXIgc2hhcGUgY2VudGVyZWQgYXQgMTAwLCAxMDAgYW5kIHdpdGggYVxuXHQgKiByYWRpdXMgb2YgNTA6XG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5iZWdpbkZpbGwoXCIjRkYwXCIpLmRyYXdQb2x5U3RhcigxMDAsIDEwMCwgNTAsIDUsIDAuNiwgLTkwKTtcblx0ICogICAgICAvLyBOb3RlOiAtOTAgbWFrZXMgdGhlIGZpcnN0IHBvaW50IHZlcnRpY2FsXG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwiZHBcIiBhbHNvIGV4aXN0cy5cblx0ICpcblx0ICogQG1ldGhvZCBkcmF3UG9seVN0YXJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggUG9zaXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGUgc2hhcGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHNoYXBlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIHNoYXBlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2lkZXMgVGhlIG51bWJlciBvZiBwb2ludHMgb24gdGhlIHN0YXIgb3Igc2lkZXMgb24gdGhlIHBvbHlnb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludFNpemUgVGhlIGRlcHRoIG9yIFwicG9pbnR5LW5lc3NcIiBvZiB0aGUgc3RhciBwb2ludHMuIEEgcG9pbnRTaXplIG9mIDAgd2lsbCBkcmF3IGEgcmVndWxhclxuXHQgKiBwb2x5Z29uIChubyBwb2ludHMpLCBhIHBvaW50U2l6ZSBvZiAxIHdpbGwgZHJhdyBub3RoaW5nIGJlY2F1c2UgdGhlIHBvaW50cyBhcmUgaW5maW5pdGVseSBwb2ludHkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSBUaGUgYW5nbGUgb2YgdGhlIGZpcnN0IHBvaW50IC8gY29ybmVyLiBGb3IgZXhhbXBsZSBhIHZhbHVlIG9mIDAgd2lsbCBkcmF3IHRoZSBmaXJzdCBwb2ludFxuXHQgKiBkaXJlY3RseSB0byB0aGUgcmlnaHQgb2YgdGhlIGNlbnRlci5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmRyYXdQb2x5U3RhciA9IGZ1bmN0aW9uKHgsIHksIHJhZGl1cywgc2lkZXMsIHBvaW50U2l6ZSwgYW5nbGUpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuUG9seVN0YXIoeCwgeSwgcmFkaXVzLCBzaWRlcywgcG9pbnRTaXplLCBhbmdsZSkpO1xuXHR9O1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWQuXG5cdC8qKlxuXHQgKiBSZW1vdmVkIGluIGZhdm91ciBvZiB1c2luZyBjdXN0b20gY29tbWFuZCBvYmplY3RzIHdpdGgge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGluamVjdFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cblx0LyoqXG5cdCAqIEFwcGVuZHMgYSBncmFwaGljcyBjb21tYW5kIG9iamVjdCB0byB0aGUgZ3JhcGhpY3MgcXVldWUuIENvbW1hbmQgb2JqZWN0cyBleHBvc2UgYW4gXCJleGVjXCIgbWV0aG9kXG5cdCAqIHRoYXQgYWNjZXB0cyB0d28gcGFyYW1ldGVyczogdGhlIENvbnRleHQyRCB0byBvcGVyYXRlIG9uLCBhbmQgYW4gYXJiaXRyYXJ5IGRhdGEgb2JqZWN0IHBhc3NlZCBpbnRvXG5cdCAqIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdcIn19e3svY3Jvc3NMaW5rfX0uIFRoZSBsYXR0ZXIgd2lsbCB1c3VhbGx5IGJlIHRoZSBTaGFwZSBpbnN0YW5jZSB0aGF0IGNhbGxlZCBkcmF3LlxuXHQgKlxuXHQgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGludGVybmFsbHkgYnkgR3JhcGhpY3MgbWV0aG9kcywgc3VjaCBhcyBkcmF3Q2lyY2xlLCBidXQgY2FuIGFsc28gYmUgdXNlZCBkaXJlY3RseSB0byBpbnNlcnRcblx0ICogYnVpbHQtaW4gb3IgY3VzdG9tIGdyYXBoaWNzIGNvbW1hbmRzLiBGb3IgZXhhbXBsZTpcblx0ICpcblx0ICogXHRcdC8vIGF0dGFjaCBkYXRhIHRvIG91ciBzaGFwZSwgc28gd2UgY2FuIGFjY2VzcyBpdCBkdXJpbmcgdGhlIGRyYXc6XG5cdCAqIFx0XHRteVNoYXBlLmNvbG9yID0gXCJyZWRcIjtcblx0ICpcblx0ICogXHRcdC8vIGFwcGVuZCBhIENpcmNsZSBjb21tYW5kIG9iamVjdDpcblx0ICogXHRcdG15U2hhcGUuZ3JhcGhpY3MuYXBwZW5kKG5ldyBjcmVhdGVqcy5HcmFwaGljcy5DaXJjbGUoNTAsIDUwLCAzMCkpO1xuXHQgKlxuXHQgKiBcdFx0Ly8gYXBwZW5kIGEgY3VzdG9tIGNvbW1hbmQgb2JqZWN0IHdpdGggYW4gZXhlYyBtZXRob2QgdGhhdCBzZXRzIHRoZSBmaWxsIHN0eWxlXG5cdCAqIFx0XHQvLyBiYXNlZCBvbiB0aGUgc2hhcGUncyBkYXRhLCBhbmQgdGhlbiBmaWxscyB0aGUgY2lyY2xlLlxuXHQgKiBcdFx0bXlTaGFwZS5ncmFwaGljcy5hcHBlbmQoe2V4ZWM6ZnVuY3Rpb24oY3R4LCBzaGFwZSkge1xuXHQgKiBcdFx0XHRjdHguZmlsbFN0eWxlID0gc2hhcGUuY29sb3I7XG5cdCAqIFx0XHRcdGN0eC5maWxsKCk7XG5cdCAqIFx0XHR9fSk7XG5cdCAqXG5cdCAqIEBtZXRob2QgYXBwZW5kXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjb21tYW5kIEEgZ3JhcGhpY3MgY29tbWFuZCBvYmplY3QgZXhwb3NpbmcgYW4gXCJleGVjXCIgbWV0aG9kLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGNsZWFuIFRoZSBjbGVhbiBwYXJhbSBpcyBwcmltYXJpbHkgZm9yIGludGVybmFsIHVzZS4gQSB2YWx1ZSBvZiB0cnVlIGluZGljYXRlcyB0aGF0IGEgY29tbWFuZCBkb2VzIG5vdCBnZW5lcmF0ZSBhIHBhdGggdGhhdCBzaG91bGQgYmUgc3Ryb2tlZCBvciBmaWxsZWQuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hcHBlbmQgPSBmdW5jdGlvbihjb21tYW5kLCBjbGVhbikge1xuXHRcdHRoaXMuX2FjdGl2ZUluc3RydWN0aW9ucy5wdXNoKGNvbW1hbmQpO1xuXHRcdHRoaXMuY29tbWFuZCA9IGNvbW1hbmQ7XG5cdFx0aWYgKCFjbGVhbikgeyB0aGlzLl9kaXJ0eSA9IHRydWU7IH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogRGVjb2RlcyBhIGNvbXBhY3QgZW5jb2RlZCBwYXRoIHN0cmluZyBpbnRvIGEgc2VyaWVzIG9mIGRyYXcgaW5zdHJ1Y3Rpb25zLlxuXHQgKiBUaGlzIGZvcm1hdCBpcyBub3QgaW50ZW5kZWQgdG8gYmUgaHVtYW4gcmVhZGFibGUsIGFuZCBpcyBtZWFudCBmb3IgdXNlIGJ5IGF1dGhvcmluZyB0b29scy5cblx0ICogVGhlIGZvcm1hdCB1c2VzIGEgYmFzZTY0IGNoYXJhY3RlciBzZXQsIHdpdGggZWFjaCBjaGFyYWN0ZXIgcmVwcmVzZW50aW5nIDYgYml0cywgdG8gZGVmaW5lIGEgc2VyaWVzIG9mIGRyYXdcblx0ICogY29tbWFuZHMuXG5cdCAqXG5cdCAqIEVhY2ggY29tbWFuZCBpcyBjb21wcmlzZWQgb2YgYSBzaW5nbGUgXCJoZWFkZXJcIiBjaGFyYWN0ZXIgZm9sbG93ZWQgYnkgYSB2YXJpYWJsZSBudW1iZXIgb2YgYWx0ZXJuYXRpbmcgeCBhbmQgeVxuXHQgKiBwb3NpdGlvbiB2YWx1ZXMuIFJlYWRpbmcgdGhlIGhlYWRlciBiaXRzIGZyb20gbGVmdCB0byByaWdodCAobW9zdCB0byBsZWFzdCBzaWduaWZpY2FudCk6IGJpdHMgMSB0byAzIHNwZWNpZnkgdGhlXG5cdCAqIHR5cGUgb2Ygb3BlcmF0aW9uICgwLW1vdmVUbywgMS1saW5lVG8sIDItcXVhZHJhdGljQ3VydmVUbywgMy1iZXppZXJDdXJ2ZVRvLCA0LWNsb3NlUGF0aCwgNS03IHVudXNlZCkuIEJpdCA0XG5cdCAqIGluZGljYXRlcyB3aGV0aGVyIHBvc2l0aW9uIHZhbHVlcyB1c2UgMTIgYml0cyAoMiBjaGFyYWN0ZXJzKSBvciAxOCBiaXRzICgzIGNoYXJhY3RlcnMpLCB3aXRoIGEgb25lIGluZGljYXRpbmcgdGhlXG5cdCAqIGxhdHRlci4gQml0cyA1IGFuZCA2IGFyZSBjdXJyZW50bHkgdW51c2VkLlxuXHQgKlxuXHQgKiBGb2xsb3dpbmcgdGhlIGhlYWRlciBpcyBhIHNlcmllcyBvZiAwIChjbG9zZVBhdGgpLCAyIChtb3ZlVG8sIGxpbmVUbyksIDQgKHF1YWRyYXRpY0N1cnZlVG8pLCBvciA2IChiZXppZXJDdXJ2ZVRvKVxuXHQgKiBwYXJhbWV0ZXJzLiBUaGVzZSBwYXJhbWV0ZXJzIGFyZSBhbHRlcm5hdGluZyB4L3kgcG9zaXRpb25zIHJlcHJlc2VudGVkIGJ5IDIgb3IgMyBjaGFyYWN0ZXJzIChhcyBpbmRpY2F0ZWQgYnkgdGhlXG5cdCAqIDR0aCBiaXQgaW4gdGhlIGNvbW1hbmQgY2hhcikuIFRoZXNlIGNoYXJhY3RlcnMgY29uc2lzdCBvZiBhIDEgYml0IHNpZ24gKDEgaXMgbmVnYXRpdmUsIDAgaXMgcG9zaXRpdmUpLCBmb2xsb3dlZFxuXHQgKiBieSBhbiAxMSAoMiBjaGFyKSBvciAxNyAoMyBjaGFyKSBiaXQgaW50ZWdlciB2YWx1ZS4gQWxsIHBvc2l0aW9uIHZhbHVlcyBhcmUgaW4gdGVudGhzIG9mIGEgcGl4ZWwuIEV4Y2VwdCBpbiB0aGVcblx0ICogY2FzZSBvZiBtb3ZlIG9wZXJhdGlvbnMgd2hpY2ggYXJlIGFic29sdXRlLCB0aGlzIHZhbHVlIGlzIGEgZGVsdGEgZnJvbSB0aGUgcHJldmlvdXMgeCBvciB5IHBvc2l0aW9uIChhc1xuXHQgKiBhcHByb3ByaWF0ZSkuXG5cdCAqXG5cdCAqIEZvciBleGFtcGxlLCB0aGUgc3RyaW5nIFwiQTNjQUFNQXU0QUFBXCIgcmVwcmVzZW50cyBhIGxpbmUgc3RhcnRpbmcgYXQgLTE1MCwwIGFuZCBlbmRpbmcgYXQgMTUwLDAuXG5cdCAqIDxiciAvPkEgLSBiaXRzIDAwMDAwMC4gRmlyc3QgMyBiaXRzICgwMDApIGluZGljYXRlIGEgbW92ZVRvIG9wZXJhdGlvbi4gNHRoIGJpdCAoMCkgaW5kaWNhdGVzIDIgY2hhcnMgcGVyXG5cdCAqIHBhcmFtZXRlci5cblx0ICogPGJyIC8+bjAgLSAxMTAxMTEwMTExMDAuIEFic29sdXRlIHggcG9zaXRpb24gb2YgLTE1MC4wcHguIEZpcnN0IGJpdCBpbmRpY2F0ZXMgYSBuZWdhdGl2ZSB2YWx1ZSwgcmVtYWluaW5nIGJpdHNcblx0ICogaW5kaWNhdGUgMTUwMCB0ZW50aHMgb2YgYSBwaXhlbC5cblx0ICogPGJyIC8+QUEgLSAwMDAwMDAwMDAwMDAuIEFic29sdXRlIHkgcG9zaXRpb24gb2YgMC5cblx0ICogPGJyIC8+SSAtIDAwMTEwMC4gRmlyc3QgMyBiaXRzICgwMDEpIGluZGljYXRlIGEgbGluZVRvIG9wZXJhdGlvbi4gNHRoIGJpdCAoMSkgaW5kaWNhdGVzIDMgY2hhcnMgcGVyIHBhcmFtZXRlci5cblx0ICogPGJyIC8+QXU0IC0gMDAwMDAwMTAxMTEwMTExMDAwLiBBbiB4IGRlbHRhIG9mIDMwMC4wcHgsIHdoaWNoIGlzIGFkZGVkIHRvIHRoZSBwcmV2aW91cyB4IHZhbHVlIG9mIC0xNTAuMHB4IHRvXG5cdCAqIHByb3ZpZGUgYW4gYWJzb2x1dGUgcG9zaXRpb24gb2YgKzE1MC4wcHguXG5cdCAqIDxiciAvPkFBQSAtIDAwMDAwMDAwMDAwMDAwMDAwMC4gQSB5IGRlbHRhIHZhbHVlIG9mIDAuXG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwicFwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGRlY29kZVBhdGhcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgcGF0aCBzdHJpbmcgdG8gZGVjb2RlLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuZGVjb2RlUGF0aCA9IGZ1bmN0aW9uKHN0cikge1xuXHRcdHZhciBpbnN0cnVjdGlvbnMgPSBbdGhpcy5tb3ZlVG8sIHRoaXMubGluZVRvLCB0aGlzLnF1YWRyYXRpY0N1cnZlVG8sIHRoaXMuYmV6aWVyQ3VydmVUbywgdGhpcy5jbG9zZVBhdGhdO1xuXHRcdHZhciBwYXJhbUNvdW50ID0gWzIsIDIsIDQsIDYsIDBdO1xuXHRcdHZhciBpPTAsIGw9c3RyLmxlbmd0aDtcblx0XHR2YXIgcGFyYW1zID0gW107XG5cdFx0dmFyIHg9MCwgeT0wO1xuXHRcdHZhciBiYXNlNjQgPSBHcmFwaGljcy5CQVNFXzY0O1xuXG5cdFx0d2hpbGUgKGk8bCkge1xuXHRcdFx0dmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuXHRcdFx0dmFyIG4gPSBiYXNlNjRbY107XG5cdFx0XHR2YXIgZmkgPSBuPj4zOyAvLyBoaWdoZXN0IG9yZGVyIGJpdHMgMS0zIGNvZGUgZm9yIG9wZXJhdGlvbi5cblx0XHRcdHZhciBmID0gaW5zdHJ1Y3Rpb25zW2ZpXTtcblx0XHRcdC8vIGNoZWNrIHRoYXQgd2UgaGF2ZSBhIHZhbGlkIGluc3RydWN0aW9uICYgdGhhdCB0aGUgdW51c2VkIGJpdHMgYXJlIGVtcHR5OlxuXHRcdFx0aWYgKCFmIHx8IChuJjMpKSB7IHRocm93KFwiYmFkIHBhdGggZGF0YSAoQFwiK2krXCIpOiBcIitjKTsgfVxuXHRcdFx0dmFyIHBsID0gcGFyYW1Db3VudFtmaV07XG5cdFx0XHRpZiAoIWZpKSB7IHg9eT0wOyB9IC8vIG1vdmUgb3BlcmF0aW9ucyByZXNldCB0aGUgcG9zaXRpb24uXG5cdFx0XHRwYXJhbXMubGVuZ3RoID0gMDtcblx0XHRcdGkrKztcblx0XHRcdHZhciBjaGFyQ291bnQgPSAobj4+MiYxKSsyOyAgLy8gNHRoIGhlYWRlciBiaXQgaW5kaWNhdGVzIG51bWJlciBzaXplIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0XHRcdGZvciAodmFyIHA9MDsgcDxwbDsgcCsrKSB7XG5cdFx0XHRcdHZhciBudW0gPSBiYXNlNjRbc3RyLmNoYXJBdChpKV07XG5cdFx0XHRcdHZhciBzaWduID0gKG51bT4+NSkgPyAtMSA6IDE7XG5cdFx0XHRcdG51bSA9ICgobnVtJjMxKTw8Nil8KGJhc2U2NFtzdHIuY2hhckF0KGkrMSldKTtcblx0XHRcdFx0aWYgKGNoYXJDb3VudCA9PSAzKSB7IG51bSA9IChudW08PDYpfChiYXNlNjRbc3RyLmNoYXJBdChpKzIpXSk7IH1cblx0XHRcdFx0bnVtID0gc2lnbipudW0vMTA7XG5cdFx0XHRcdGlmIChwJTIpIHsgeCA9IChudW0gKz0geCk7IH1cblx0XHRcdFx0ZWxzZSB7IHkgPSAobnVtICs9IHkpOyB9XG5cdFx0XHRcdHBhcmFtc1twXSA9IG51bTtcblx0XHRcdFx0aSArPSBjaGFyQ291bnQ7XG5cdFx0XHR9XG5cdFx0XHRmLmFwcGx5KHRoaXMscGFyYW1zKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3JlcyBhbGwgZ3JhcGhpY3MgY29tbWFuZHMgc28gdGhleSB3b24ndCBiZSBleGVjdXRlZCBpbiBmdXR1cmUgZHJhd3MuIENhbGxpbmcgc3RvcmUoKSBhIHNlY29uZCB0aW1lIGFkZHMgdG9cblx0ICogdGhlIGV4aXN0aW5nIHN0b3JlLiBUaGlzIGFsc28gYWZmZWN0cyBgZHJhd0FzUGF0aCgpYC5cblx0ICpcblx0ICogVGhpcyBpcyB1c2VmdWwgaW4gY2FzZXMgd2hlcmUgeW91IGFyZSBjcmVhdGluZyB2ZWN0b3IgZ3JhcGhpY3MgaW4gYW4gaXRlcmF0aXZlIG1hbm5lciAoZXguIGdlbmVyYXRpdmUgYXJ0KSwgc29cblx0ICogdGhhdCBvbmx5IG5ldyBncmFwaGljcyBuZWVkIHRvIGJlIGRyYXduICh3aGljaCBjYW4gcHJvdmlkZSBodWdlIHBlcmZvcm1hbmNlIGJlbmVmaXRzKSwgYnV0IHlvdSB3aXNoIHRvIHJldGFpbiBhbGxcblx0ICogb2YgdGhlIHZlY3RvciBpbnN0cnVjdGlvbnMgZm9yIGxhdGVyIHVzZSAoZXguIHNjYWxpbmcsIG1vZGlmeWluZywgb3IgZXhwb3J0aW5nKS5cblx0ICpcblx0ICogTm90ZSB0aGF0IGNhbGxpbmcgc3RvcmUoKSB3aWxsIGZvcmNlIHRoZSBhY3RpdmUgcGF0aCAoaWYgYW55KSB0byBiZSBlbmRlZCBpbiBhIG1hbm5lciBzaW1pbGFyIHRvIGNoYW5naW5nXG5cdCAqIHRoZSBmaWxsIG9yIHN0cm9rZS5cblx0ICpcblx0ICogRm9yIGV4YW1wbGUsIGNvbnNpZGVyIGEgYXBwbGljYXRpb24gd2hlcmUgdGhlIHVzZXIgZHJhd3MgbGluZXMgd2l0aCB0aGUgbW91c2UuIEFzIGVhY2ggbGluZSBzZWdtZW50IChvciBjb2xsZWN0aW9uIG9mXG5cdCAqIHNlZ21lbnRzKSBhcmUgYWRkZWQgdG8gYSBTaGFwZSwgaXQgY2FuIGJlIHJhc3Rlcml6ZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC91cGRhdGVDYWNoZVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogYW5kIHRoZW4gc3RvcmVkLCBzbyB0aGF0IGl0IGNhbiBiZSByZWRyYXduIGF0IGEgZGlmZmVyZW50IHNjYWxlIHdoZW4gdGhlIGFwcGxpY2F0aW9uIGlzIHJlc2l6ZWQsIG9yIGV4cG9ydGVkIHRvIFNWRy5cblx0ICpcblx0ICogXHQvLyBzZXQgdXAgY2FjaGU6XG5cdCAqIFx0bXlTaGFwZS5jYWNoZSgwLDAsNTAwLDUwMCxzY2FsZSk7XG5cdCAqXG5cdCAqIFx0Ly8gd2hlbiB0aGUgdXNlciBkcmFncywgZHJhdyBhIG5ldyBsaW5lOlxuXHQgKiBcdG15U2hhcGUuZ3JhcGhpY3MubW92ZVRvKG9sZFgsb2xkWSkubGluZVRvKG5ld1gsbmV3WSk7XG5cdCAqIFx0Ly8gdGhlbiBkcmF3IGl0IGludG8gdGhlIGV4aXN0aW5nIGNhY2hlOlxuXHQgKiBcdG15U2hhcGUudXBkYXRlQ2FjaGUoXCJzb3VyY2Utb3ZlclwiKTtcblx0ICogXHQvLyBzdG9yZSB0aGUgbmV3IGxpbmUsIHNvIGl0IGlzbid0IHJlZHJhd24gbmV4dCB0aW1lOlxuXHQgKiBcdG15U2hhcGUuc3RvcmUoKTtcblx0ICpcblx0ICogXHQvLyB0aGVuLCB3aGVuIHRoZSB3aW5kb3cgcmVzaXplcywgd2UgY2FuIHJlLXJlbmRlciBhdCBhIGRpZmZlcmVudCBzY2FsZTpcblx0ICogXHQvLyBmaXJzdCwgdW5zdG9yZSBhbGwgb3VyIGxpbmVzOlxuXHQgKiBcdG15U2hhcGUudW5zdG9yZSgpO1xuXHQgKiBcdC8vIHRoZW4gY2FjaGUgdXNpbmcgdGhlIG5ldyBzY2FsZTpcblx0ICogXHRteVNoYXBlLmNhY2hlKDAsMCw1MDAsNTAwLG5ld1NjYWxlKTtcblx0ICogXHQvLyBmaW5hbGx5LCBzdG9yZSB0aGUgZXhpc3RpbmcgY29tbWFuZHMgYWdhaW46XG5cdCAqIFx0bXlTaGFwZS5zdG9yZSgpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHN0b3JlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5zdG9yZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3VwZGF0ZUluc3RydWN0aW9ucyh0cnVlKTtcblx0XHR0aGlzLl9zdG9yZUluZGV4ID0gdGhpcy5faW5zdHJ1Y3Rpb25zLmxlbmd0aDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogVW5zdG9yZXMgYW55IGdyYXBoaWNzIGNvbW1hbmRzIHRoYXQgd2VyZSBwcmV2aW91c2x5IHN0b3JlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9zdG9yZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBzbyB0aGF0IHRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiBzdWJzZXF1ZW50IGRyYXcgY2FsbHMuXG5cdCAqXG5cdCAqIEBtZXRob2QgdW5zdG9yZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAudW5zdG9yZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3N0b3JlSW5kZXggPSAwO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBHcmFwaGljcyBpbnN0YW5jZS4gTm90ZSB0aGF0IHRoZSBpbmRpdmlkdWFsIGNvbW1hbmQgb2JqZWN0cyBhcmUgbm90IGNsb25lZC5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gQSBjbG9uZSBvZiB0aGUgY3VycmVudCBHcmFwaGljcyBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG8gPSBuZXcgR3JhcGhpY3MoKTtcblx0XHRvLmNvbW1hbmQgPSB0aGlzLmNvbW1hbmQ7XG5cdFx0by5fc3Ryb2tlID0gdGhpcy5fc3Ryb2tlO1xuXHRcdG8uX3N0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlU3R5bGU7XG5cdFx0by5fc3Ryb2tlRGFzaCA9IHRoaXMuX3N0cm9rZURhc2g7XG5cdFx0by5fc3Ryb2tlSWdub3JlU2NhbGUgPSB0aGlzLl9zdHJva2VJZ25vcmVTY2FsZTtcblx0XHRvLl9maWxsID0gdGhpcy5fZmlsbDtcblx0XHRvLl9pbnN0cnVjdGlvbnMgPSB0aGlzLl9pbnN0cnVjdGlvbnMuc2xpY2UoKTtcblx0XHRvLl9jb21taXRJbmRleCA9IHRoaXMuX2NvbW1pdEluZGV4O1xuXHRcdG8uX2FjdGl2ZUluc3RydWN0aW9ucyA9IHRoaXMuX2FjdGl2ZUluc3RydWN0aW9ucy5zbGljZSgpO1xuXHRcdG8uX2RpcnR5ID0gdGhpcy5fZGlydHk7XG5cdFx0by5fc3RvcmVJbmRleCA9IHRoaXMuX3N0b3JlSW5kZXg7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltHcmFwaGljc11cIjtcblx0fTtcblxuXG4vLyB0aW55IEFQSTpcblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIG1vdmVUby5cblx0ICogQG1ldGhvZCBtdFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBtb3ZlIHRvLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBtb3ZlIHRvLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5tdCA9IHAubW92ZVRvO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBsaW5lVG8uXG5cdCAqIEBtZXRob2QgbHRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggY29vcmRpbmF0ZSB0aGUgZHJhd2luZyBwb2ludCBzaG91bGQgZHJhdyB0by5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29vcmRpbmF0ZSB0aGUgZHJhd2luZyBwb2ludCBzaG91bGQgZHJhdyB0by5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAubHQgPSBwLmxpbmVUbztcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gYXJjVG8uXG5cdCAqIEBtZXRob2QgYXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geDJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuYXQgPSBwLmFyY1RvO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZXppZXJDdXJ2ZVRvLlxuXHQgKiBAbWV0aG9kIGJ0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcDF4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcDF5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcDJ4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcDJ5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmJ0ID0gcC5iZXppZXJDdXJ2ZVRvO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBxdWFkcmF0aWNDdXJ2ZVRvIC8gY3VydmVUby5cblx0ICogQG1ldGhvZCBxdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3B4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5xdCA9IHAucXVhZHJhdGljQ3VydmVUbztcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gYXJjLlxuXHQgKiBAbWV0aG9kIGFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRBbmdsZSBNZWFzdXJlZCBpbiByYWRpYW5zLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZW5kQW5nbGUgTWVhc3VyZWQgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtCb29sZWFufSBhbnRpY2xvY2t3aXNlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmEgPSBwLmFyYztcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gcmVjdC5cblx0ICogQG1ldGhvZCByXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFdpZHRoIG9mIHRoZSByZWN0YW5nbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGggSGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuciA9IHAucmVjdDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gY2xvc2VQYXRoLlxuXHQgKiBAbWV0aG9kIGNwXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmNwID0gcC5jbG9zZVBhdGg7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGNsZWFyLlxuXHQgKiBAbWV0aG9kIGNcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuYyA9IHAuY2xlYXI7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlZ2luRmlsbC5cblx0ICogQG1ldGhvZCBmXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBBIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlIChleC4gXCJyZWRcIiwgXCIjRkYwMDAwXCIsIG9yIFwicmdiYSgyNTUsMCwwLDAuNSlcIikuIFNldHRpbmcgdG9cblx0ICogbnVsbCB3aWxsIHJlc3VsdCBpbiBubyBmaWxsLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5mID0gcC5iZWdpbkZpbGw7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlZ2luTGluZWFyR3JhZGllbnRGaWxsLlxuXHQgKiBAbWV0aG9kIGxmXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBBbiBhcnJheSBvZiBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZXMuIEZvciBleGFtcGxlLCBbXCIjRjAwXCIsXCIjMDBGXCJdIHdvdWxkIGRlZmluZSBhIGdyYWRpZW50XG5cdCAqIGRyYXdpbmcgZnJvbSByZWQgdG8gYmx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zIEFuIGFycmF5IG9mIGdyYWRpZW50IHBvc2l0aW9ucyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjb2xvcnMuIEZvciBleGFtcGxlLCBbMC4xLCAwLjldIHdvdWxkIGRyYXdcblx0ICogdGhlIGZpcnN0IGNvbG9yIHRvIDEwJSB0aGVuIGludGVycG9sYXRpbmcgdG8gdGhlIHNlY29uZCBjb2xvciBhdCA5MCUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MCBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTAgVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTEgVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmxmID0gcC5iZWdpbkxpbmVhckdyYWRpZW50RmlsbDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gYmVnaW5SYWRpYWxHcmFkaWVudEZpbGwuXG5cdCAqIEBtZXRob2QgcmZcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzIEFuIGFycmF5IG9mIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlcy4gRm9yIGV4YW1wbGUsIFtcIiNGMDBcIixcIiMwMEZcIl0gd291bGQgZGVmaW5lXG5cdCAqIGEgZ3JhZGllbnQgZHJhd2luZyBmcm9tIHJlZCB0byBibHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3MgQW4gYXJyYXkgb2YgZ3JhZGllbnQgcG9zaXRpb25zIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNvbG9ycy4gRm9yIGV4YW1wbGUsIFswLjEsXG5cdCAqIDAuOV0gd291bGQgZHJhdyB0aGUgZmlyc3QgY29sb3IgdG8gMTAlIHRoZW4gaW50ZXJwb2xhdGluZyB0byB0aGUgc2Vjb25kIGNvbG9yIGF0IDkwJS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MCBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjAgUmFkaXVzIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MSBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjEgUmFkaXVzIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAucmYgPSBwLmJlZ2luUmFkaWFsR3JhZGllbnRGaWxsO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZWdpbkJpdG1hcEZpbGwuXG5cdCAqIEBtZXRob2QgYmZcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50fSBpbWFnZSBUaGUgSW1hZ2UsIENhbnZhcywgb3IgVmlkZW8gb2JqZWN0IHRvIHVzZVxuXHQgKiBhcyB0aGUgcGF0dGVybi5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHJlcGV0aXRpb24gT3B0aW9uYWwuIEluZGljYXRlcyB3aGV0aGVyIHRvIHJlcGVhdCB0aGUgaW1hZ2UgaW4gdGhlIGZpbGwgYXJlYS4gT25lIG9mIFwicmVwZWF0XCIsXG5cdCAqIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiBEZWZhdWx0cyB0byBcInJlcGVhdFwiLiBOb3RlIHRoYXQgRmlyZWZveCBkb2VzIG5vdCBzdXBwb3J0IFwicmVwZWF0LXhcIiBvclxuXHQgKiBcInJlcGVhdC15XCIgKGxhdGVzdCB0ZXN0cyB3ZXJlIGluIEZGIDIwLjApLCBhbmQgd2lsbCBkZWZhdWx0IHRvIFwicmVwZWF0XCIuXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeCBPcHRpb25hbC4gU3BlY2lmaWVzIGEgdHJhbnNmb3JtYXRpb24gbWF0cml4IGZvciB0aGUgYml0bWFwIGZpbGwuIFRoaXMgdHJhbnNmb3JtYXRpb25cblx0ICogd2lsbCBiZSBhcHBsaWVkIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnQgdHJhbnNmb3JtLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5iZiA9IHAuYmVnaW5CaXRtYXBGaWxsO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBlbmRGaWxsLlxuXHQgKiBAbWV0aG9kIGVmXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmVmID0gcC5lbmRGaWxsO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBzZXRTdHJva2VTdHlsZS5cblx0ICogQG1ldGhvZCBzc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gdGhpY2tuZXNzIFRoZSB3aWR0aCBvZiB0aGUgc3Ryb2tlLlxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gW2NhcHM9MF0gSW5kaWNhdGVzIHRoZSB0eXBlIG9mIGNhcHMgdG8gdXNlIGF0IHRoZSBlbmQgb2YgbGluZXMuIE9uZSBvZiBidXR0LFxuXHQgKiByb3VuZCwgb3Igc3F1YXJlLiBEZWZhdWx0cyB0byBcImJ1dHRcIi4gQWxzbyBhY2NlcHRzIHRoZSB2YWx1ZXMgMCAoYnV0dCksIDEgKHJvdW5kKSwgYW5kIDIgKHNxdWFyZSkgZm9yIHVzZSB3aXRoXG5cdCAqIHRoZSB0aW55IEFQSS5cblx0ICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IFtqb2ludHM9MF0gU3BlY2lmaWVzIHRoZSB0eXBlIG9mIGpvaW50cyB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZXJlIHR3byBsaW5lcyBtZWV0LlxuXHQgKiBPbmUgb2YgYmV2ZWwsIHJvdW5kLCBvciBtaXRlci4gRGVmYXVsdHMgdG8gXCJtaXRlclwiLiBBbHNvIGFjY2VwdHMgdGhlIHZhbHVlcyAwIChtaXRlciksIDEgKHJvdW5kKSwgYW5kIDIgKGJldmVsKVxuXHQgKiBmb3IgdXNlIHdpdGggdGhlIHRpbnkgQVBJLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW21pdGVyTGltaXQ9MTBdIElmIGpvaW50cyBpcyBzZXQgdG8gXCJtaXRlclwiLCB0aGVuIHlvdSBjYW4gc3BlY2lmeSBhIG1pdGVyIGxpbWl0IHJhdGlvIHdoaWNoXG5cdCAqIGNvbnRyb2xzIGF0IHdoYXQgcG9pbnQgYSBtaXRlcmVkIGpvaW50IHdpbGwgYmUgY2xpcHBlZC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbaWdub3JlU2NhbGU9ZmFsc2VdIElmIHRydWUsIHRoZSBzdHJva2Ugd2lsbCBiZSBkcmF3biBhdCB0aGUgc3BlY2lmaWVkIHRoaWNrbmVzcyByZWdhcmRsZXNzXG5cdCAqIG9mIGFjdGl2ZSB0cmFuc2Zvcm1hdGlvbnMuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnNzID0gcC5zZXRTdHJva2VTdHlsZTtcblx0XG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBzZXRTdHJva2VEYXNoLlxuXHQgKiBAbWV0aG9kIHNkXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtzZWdtZW50c10gQW4gYXJyYXkgc3BlY2lmeWluZyB0aGUgZGFzaCBwYXR0ZXJuLCBhbHRlcm5hdGluZyBiZXR3ZWVuIGxpbmUgYW5kIGdhcC5cblx0ICogRm9yIGV4YW1wbGUsIFsyMCwxMF0gd291bGQgY3JlYXRlIGEgcGF0dGVybiBvZiAyMCBwaXhlbCBsaW5lcyB3aXRoIDEwIHBpeGVsIGdhcHMgYmV0d2VlbiB0aGVtLlxuXHQgKiBQYXNzaW5nIG51bGwgb3IgYW4gZW1wdHkgYXJyYXkgd2lsbCBjbGVhciBhbnkgZXhpc3RpbmcgZGFzaC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXQ9MF0gVGhlIG9mZnNldCBvZiB0aGUgZGFzaCBwYXR0ZXJuLiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIGluY3JlbWVudCB0aGlzIHZhbHVlIHRvIGNyZWF0ZSBhIFwibWFyY2hpbmcgYW50c1wiIGVmZmVjdC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuc2QgPSBwLnNldFN0cm9rZURhc2g7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlZ2luU3Ryb2tlLlxuXHQgKiBAbWV0aG9kIHNcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIEEgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWUgKGV4LiBcIiNGRjAwMDBcIiwgXCJyZWRcIiwgb3IgXCJyZ2JhKDI1NSwwLDAsMC41KVwiKS4gU2V0dGluZyB0b1xuXHQgKiBudWxsIHdpbGwgcmVzdWx0IGluIG5vIHN0cm9rZS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAucyA9IHAuYmVnaW5TdHJva2U7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlZ2luTGluZWFyR3JhZGllbnRTdHJva2UuXG5cdCAqIEBtZXRob2QgbHNcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzIEFuIGFycmF5IG9mIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlcy4gRm9yIGV4YW1wbGUsIFtcIiNGMDBcIixcIiMwMEZcIl0gd291bGQgZGVmaW5lXG5cdCAqIGEgZ3JhZGllbnQgZHJhd2luZyBmcm9tIHJlZCB0byBibHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3MgQW4gYXJyYXkgb2YgZ3JhZGllbnQgcG9zaXRpb25zIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNvbG9ycy4gRm9yIGV4YW1wbGUsIFswLjEsXG5cdCAqIDAuOV0gd291bGQgZHJhdyB0aGUgZmlyc3QgY29sb3IgdG8gMTAlIHRoZW4gaW50ZXJwb2xhdGluZyB0byB0aGUgc2Vjb25kIGNvbG9yIGF0IDkwJS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwIFRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MCBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDEgVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MSBUaGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAubHMgPSBwLmJlZ2luTGluZWFyR3JhZGllbnRTdHJva2U7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlZ2luUmFkaWFsR3JhZGllbnRTdHJva2UuXG5cdCAqIEBtZXRob2QgcnNcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzIEFuIGFycmF5IG9mIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlcy4gRm9yIGV4YW1wbGUsIFtcIiNGMDBcIixcIiMwMEZcIl0gd291bGQgZGVmaW5lXG5cdCAqIGEgZ3JhZGllbnQgZHJhd2luZyBmcm9tIHJlZCB0byBibHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3MgQW4gYXJyYXkgb2YgZ3JhZGllbnQgcG9zaXRpb25zIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNvbG9ycy4gRm9yIGV4YW1wbGUsIFswLjEsXG5cdCAqIDAuOV0gd291bGQgZHJhdyB0aGUgZmlyc3QgY29sb3IgdG8gMTAlIHRoZW4gaW50ZXJwb2xhdGluZyB0byB0aGUgc2Vjb25kIGNvbG9yIGF0IDkwJSwgdGhlbiBkcmF3IHRoZSBzZWNvbmQgY29sb3Jcblx0ICogdG8gMTAwJS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MCBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjAgUmFkaXVzIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MSBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjEgUmFkaXVzIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAucnMgPSBwLmJlZ2luUmFkaWFsR3JhZGllbnRTdHJva2U7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlZ2luQml0bWFwU3Ryb2tlLlxuXHQgKiBAbWV0aG9kIGJzXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudH0gaW1hZ2UgVGhlIEltYWdlLCBDYW52YXMsIG9yIFZpZGVvIG9iamVjdCB0byB1c2Vcblx0ICogYXMgdGhlIHBhdHRlcm4uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcmVwZXRpdGlvbj1yZXBlYXRdIE9wdGlvbmFsLiBJbmRpY2F0ZXMgd2hldGhlciB0byByZXBlYXQgdGhlIGltYWdlIGluIHRoZSBmaWxsIGFyZWEuIE9uZSBvZlxuXHQgKiBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gRGVmYXVsdHMgdG8gXCJyZXBlYXRcIi5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuYnMgPSBwLmJlZ2luQml0bWFwU3Ryb2tlO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBlbmRTdHJva2UuXG5cdCAqIEBtZXRob2QgZXNcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuZXMgPSBwLmVuZFN0cm9rZTtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gZHJhd1JlY3QuXG5cdCAqIEBtZXRob2QgZHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHcgV2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaCBIZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5kciA9IHAuZHJhd1JlY3Q7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGRyYXdSb3VuZFJlY3QuXG5cdCAqIEBtZXRob2QgcnJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBDb3JuZXIgcmFkaXVzLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5yciA9IHAuZHJhd1JvdW5kUmVjdDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gZHJhd1JvdW5kUmVjdENvbXBsZXguXG5cdCAqIEBtZXRob2QgcmNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZSB0byBkcmF3IHRoZSByb3VuZCByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgdmVydGljYWwgY29vcmRpbmF0ZSB0byBkcmF3IHRoZSByb3VuZCByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdyBUaGUgd2lkdGggb2YgdGhlIHJvdW5kIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoIFRoZSBoZWlnaHQgb2YgdGhlIHJvdW5kIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUTCBUb3AgbGVmdCBjb3JuZXIgcmFkaXVzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzVFIgVG9wIHJpZ2h0IGNvcm5lciByYWRpdXMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCUiBCb3R0b20gcmlnaHQgY29ybmVyIHJhZGl1cy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c0JMIEJvdHRvbSBsZWZ0IGNvcm5lciByYWRpdXMuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnJjID0gcC5kcmF3Um91bmRSZWN0Q29tcGxleDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gZHJhd0NpcmNsZS5cblx0ICogQG1ldGhvZCBkY1xuXHQgKiBAcGFyYW0ge051bWJlcn0geCB4IGNvb3JkaW5hdGUgY2VudGVyIHBvaW50IG9mIGNpcmNsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgeSBjb29yZGluYXRlIGNlbnRlciBwb2ludCBvZiBjaXJjbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgUmFkaXVzIG9mIGNpcmNsZS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuZGMgPSBwLmRyYXdDaXJjbGU7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGRyYXdFbGxpcHNlLlxuXHQgKiBAbWV0aG9kIGRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBsZWZ0IGNvb3JkaW5hdGUgcG9pbnQgb2YgdGhlIGVsbGlwc2UuIE5vdGUgdGhhdCB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdDaXJjbGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2hpY2ggZHJhd3MgZnJvbSBjZW50ZXIuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB0b3AgY29vcmRpbmF0ZSBwb2ludCBvZiB0aGUgZWxsaXBzZS4gTm90ZSB0aGF0IHRoaXMgaXMgZGlmZmVyZW50IGZyb20ge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd0NpcmNsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aGljaCBkcmF3cyBmcm9tIHRoZSBjZW50ZXIuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFRoZSBoZWlnaHQgKGhvcml6b250YWwgZGlhbWV0ZXIpIG9mIHRoZSBlbGxpcHNlLiBUaGUgaG9yaXpvbnRhbCByYWRpdXMgd2lsbCBiZSBoYWxmIG9mIHRoaXNcblx0ICogbnVtYmVyLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaCBUaGUgd2lkdGggKHZlcnRpY2FsIGRpYW1ldGVyKSBvZiB0aGUgZWxsaXBzZS4gVGhlIHZlcnRpY2FsIHJhZGl1cyB3aWxsIGJlIGhhbGYgb2YgdGhpcyBudW1iZXIuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmRlID0gcC5kcmF3RWxsaXBzZTtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gZHJhd1BvbHlTdGFyLlxuXHQgKiBAbWV0aG9kIGRwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHNoYXBlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBQb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoZSBzaGFwZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBzaGFwZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNpZGVzIFRoZSBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBzdGFyIG9yIHNpZGVzIG9uIHRoZSBwb2x5Z29uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9pbnRTaXplIFRoZSBkZXB0aCBvciBcInBvaW50eS1uZXNzXCIgb2YgdGhlIHN0YXIgcG9pbnRzLiBBIHBvaW50U2l6ZSBvZiAwIHdpbGwgZHJhdyBhIHJlZ3VsYXJcblx0ICogcG9seWdvbiAobm8gcG9pbnRzKSwgYSBwb2ludFNpemUgb2YgMSB3aWxsIGRyYXcgbm90aGluZyBiZWNhdXNlIHRoZSBwb2ludHMgYXJlIGluZmluaXRlbHkgcG9pbnR5LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgVGhlIGFuZ2xlIG9mIHRoZSBmaXJzdCBwb2ludCAvIGNvcm5lci4gRm9yIGV4YW1wbGUgYSB2YWx1ZSBvZiAwIHdpbGwgZHJhdyB0aGUgZmlyc3QgcG9pbnRcblx0ICogZGlyZWN0bHkgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjZW50ZXIuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmRwID0gcC5kcmF3UG9seVN0YXI7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGRlY29kZVBhdGguXG5cdCAqIEBtZXRob2QgcFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBwYXRoIHN0cmluZyB0byBkZWNvZGUuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnAgPSBwLmRlY29kZVBhdGg7XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfdXBkYXRlSW5zdHJ1Y3Rpb25zXG5cdCAqIEBwYXJhbSBjb21taXRcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3VwZGF0ZUluc3RydWN0aW9ucyA9IGZ1bmN0aW9uKGNvbW1pdCkge1xuXHRcdHZhciBpbnN0ciA9IHRoaXMuX2luc3RydWN0aW9ucywgYWN0aXZlID0gdGhpcy5fYWN0aXZlSW5zdHJ1Y3Rpb25zLCBjb21taXRJbmRleCA9IHRoaXMuX2NvbW1pdEluZGV4O1xuXG5cdFx0aWYgKHRoaXMuX2RpcnR5ICYmIGFjdGl2ZS5sZW5ndGgpIHtcblx0XHRcdGluc3RyLmxlbmd0aCA9IGNvbW1pdEluZGV4OyAvLyByZW1vdmUgb2xkLCB1bmNvbW1pdHRlZCBjb21tYW5kc1xuXHRcdFx0aW5zdHIucHVzaChHcmFwaGljcy5iZWdpbkNtZCk7XG5cblx0XHRcdHZhciBsID0gYWN0aXZlLmxlbmd0aCwgbGwgPSBpbnN0ci5sZW5ndGg7XG5cdFx0XHRpbnN0ci5sZW5ndGggPSBsbCtsO1xuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykgeyBpbnN0cltpK2xsXSA9IGFjdGl2ZVtpXTsgfVxuXG5cdFx0XHRpZiAodGhpcy5fZmlsbCkgeyBpbnN0ci5wdXNoKHRoaXMuX2ZpbGwpOyB9XG5cdFx0XHRpZiAodGhpcy5fc3Ryb2tlKSB7XG5cdFx0XHRcdC8vIGRvZXNuJ3QgbmVlZCB0byBiZSByZS1hcHBsaWVkIGlmIGl0IGhhc24ndCBjaGFuZ2VkLlxuXHRcdFx0XHRpZiAodGhpcy5fc3Ryb2tlRGFzaCAhPT0gdGhpcy5fb2xkU3Ryb2tlRGFzaCkge1xuXHRcdFx0XHRcdHRoaXMuX29sZFN0cm9rZURhc2ggPSB0aGlzLl9zdHJva2VEYXNoO1xuXHRcdFx0XHRcdGluc3RyLnB1c2godGhpcy5fc3Ryb2tlRGFzaCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX3N0cm9rZVN0eWxlICE9PSB0aGlzLl9vbGRTdHJva2VTdHlsZSkge1xuXHRcdFx0XHRcdHRoaXMuX29sZFN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlU3R5bGU7XG5cdFx0XHRcdFx0aW5zdHIucHVzaCh0aGlzLl9zdHJva2VTdHlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5zdHIucHVzaCh0aGlzLl9zdHJva2UpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChjb21taXQpIHtcblx0XHRcdGFjdGl2ZS5sZW5ndGggPSAwO1xuXHRcdFx0dGhpcy5fY29tbWl0SW5kZXggPSBpbnN0ci5sZW5ndGg7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9zZXRGaWxsXG5cdCAqIEBwYXJhbSBmaWxsXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9zZXRGaWxsID0gZnVuY3Rpb24oZmlsbCkge1xuXHRcdHRoaXMuX3VwZGF0ZUluc3RydWN0aW9ucyh0cnVlKTtcblx0XHR0aGlzLmNvbW1hbmQgPSB0aGlzLl9maWxsID0gZmlsbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfc2V0U3Ryb2tlXG5cdCAqIEBwYXJhbSBzdHJva2Vcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3NldFN0cm9rZSA9IGZ1bmN0aW9uKHN0cm9rZSkge1xuXHRcdHRoaXMuX3VwZGF0ZUluc3RydWN0aW9ucyh0cnVlKTtcblx0XHRpZiAodGhpcy5jb21tYW5kID0gdGhpcy5fc3Ryb2tlID0gc3Ryb2tlKSB7XG5cdFx0XHRzdHJva2UuaWdub3JlU2NhbGUgPSB0aGlzLl9zdHJva2VJZ25vcmVTY2FsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cbi8vIENvbW1hbmQgT2JqZWN0czpcblx0LyoqXG5cdCAqIEBuYW1lc3BhY2UgR3JhcGhpY3Ncblx0ICovXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2xpbmVUb1wifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3NcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIExpbmVUb1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdChHLkxpbmVUbyA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHgubGluZVRvKHRoaXMueCx0aGlzLnkpOyB9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL21vdmVUb1wifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgTW92ZVRvXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKi9cblx0KEcuTW92ZVRvID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7IGN0eC5tb3ZlVG8odGhpcy54LCB0aGlzLnkpOyB9O1xuXG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXJjVG9cIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIEFyY1RvXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0geDFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeDFcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHkxXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4MlxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeTJcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHJhZGl1c1xuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0KEcuQXJjVG8gPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKSB7XG5cdFx0dGhpcy54MSA9IHgxOyB0aGlzLnkxID0geTE7XG5cdFx0dGhpcy54MiA9IHgyOyB0aGlzLnkyID0geTI7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7IGN0eC5hcmNUbyh0aGlzLngxLCB0aGlzLnkxLCB0aGlzLngyLCB0aGlzLnkyLCB0aGlzLnJhZGl1cyk7IH07XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXJjXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBBcmNcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0QW5nbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGVuZEFuZ2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbnRpY2xvY2t3aXNlXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSByYWRpdXNcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHN0YXJ0QW5nbGVcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGVuZEFuZ2xlXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBhbnRpY2xvY2t3aXNlXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHQoRy5BcmMgPSBmdW5jdGlvbih4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKSB7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblx0XHR0aGlzLnN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlOyB0aGlzLmVuZEFuZ2xlID0gZW5kQW5nbGU7XG5cdFx0dGhpcy5hbnRpY2xvY2t3aXNlID0gISFhbnRpY2xvY2t3aXNlO1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHguYXJjKHRoaXMueCwgdGhpcy55LCB0aGlzLnJhZGl1cywgdGhpcy5zdGFydEFuZ2xlLCB0aGlzLmVuZEFuZ2xlLCB0aGlzLmFudGljbG9ja3dpc2UpOyB9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3F1YWRyYXRpY0N1cnZlVG9cIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIFF1YWRyYXRpY0N1cnZlVG9cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNweVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgY3B4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBjcHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdChHLlF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbihjcHgsIGNweSwgeCwgeSkge1xuXHRcdHRoaXMuY3B4ID0gY3B4OyB0aGlzLmNweSA9IGNweTtcblx0XHR0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHgucXVhZHJhdGljQ3VydmVUbyh0aGlzLmNweCwgdGhpcy5jcHksIHRoaXMueCwgdGhpcy55KTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZXppZXJDdXJ2ZVRvXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBCZXppZXJDdXJ2ZVRvXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AxeFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AxeVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AyeFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AyeVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgY3AxeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgY3AxeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgY3AyeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgY3AyeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0KEcuQmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcblx0XHR0aGlzLmNwMXggPSBjcDF4OyB0aGlzLmNwMXkgPSBjcDF5O1xuXHRcdHRoaXMuY3AyeCA9IGNwMng7IHRoaXMuY3AyeSA9IGNwMnk7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4LmJlemllckN1cnZlVG8odGhpcy5jcDF4LCB0aGlzLmNwMXksIHRoaXMuY3AyeCwgdGhpcy5jcDJ5LCB0aGlzLngsIHRoaXMueSk7IH07XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvcmVjdFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgUmVjdFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHdcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdChHLlJlY3QgPSBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0XHR0aGlzLncgPSB3OyB0aGlzLmggPSBoO1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHgucmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy53LCB0aGlzLmgpOyB9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2Nsb3NlUGF0aFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgQ2xvc2VQYXRoXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0KEcuQ2xvc2VQYXRoID0gZnVuY3Rpb24oKSB7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7IGN0eC5jbG9zZVBhdGgoKTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QgdG8gYmVnaW4gYSBuZXcgcGF0aC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBCZWdpblBhdGhcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHQoRy5CZWdpblBhdGggPSBmdW5jdGlvbigpIHtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4LmJlZ2luUGF0aCgpOyB9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luRmlsbFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgRmlsbFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IHN0eWxlIEEgdmFsaWQgQ29udGV4dDJEIGZpbGxTdHlsZS5cblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4XG5cdCAqKi9cblx0LyoqXG5cdCAqIEEgdmFsaWQgQ29udGV4dDJEIGZpbGxTdHlsZS5cblx0ICogQHByb3BlcnR5IHN0eWxlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBtYXRyaXhcblx0ICogQHR5cGUgTWF0cml4MkRcblx0ICovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0cCA9IChHLkZpbGwgPSBmdW5jdGlvbihzdHlsZSwgbWF0cml4KSB7XG5cdFx0dGhpcy5zdHlsZSA9IHN0eWxlO1xuXHRcdHRoaXMubWF0cml4ID0gbWF0cml4O1xuXHR9KS5wcm90b3R5cGU7XG5cdHAuZXhlYyA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGlmICghdGhpcy5zdHlsZSkgeyByZXR1cm47IH1cblx0XHRjdHguZmlsbFN0eWxlID0gdGhpcy5zdHlsZTtcblx0XHR2YXIgbXR4ID0gdGhpcy5tYXRyaXg7XG5cdFx0aWYgKG10eCkgeyBjdHguc2F2ZSgpOyBjdHgudHJhbnNmb3JtKG10eC5hLCBtdHguYiwgbXR4LmMsIG10eC5kLCBtdHgudHgsIG10eC50eSk7IH1cblx0XHRjdHguZmlsbCgpO1xuXHRcdGlmIChtdHgpIHsgY3R4LnJlc3RvcmUoKTsgfVxuXHR9O1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIGxpbmVhciBncmFkaWVudCBzdHlsZSBhbmQgYXNzaWducyBpdCB0byB7eyNjcm9zc0xpbmsgXCJGaWxsL3N0eWxlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5MaW5lYXJHcmFkaWVudEZpbGxcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBtZXRob2QgbGluZWFyR3JhZGllbnRcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvc1xuXHQgKiBAcGFyYW0ge051bWJlcn0geDBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geTFcblx0ICogQHJldHVybiB7RmlsbH0gUmV0dXJucyB0aGlzIEZpbGwgb2JqZWN0IGZvciBjaGFpbmluZyBvciBhc3NpZ25tZW50LlxuXHQgKi9cblx0cC5saW5lYXJHcmFkaWVudCA9IGZ1bmN0aW9uKGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHgxLCB5MSkge1xuXHRcdHZhciBvID0gdGhpcy5zdHlsZSA9ICBHcmFwaGljcy5fY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgwLCB5MCwgeDEsIHkxKTtcblx0XHRmb3IgKHZhciBpPTAsIGw9Y29sb3JzLmxlbmd0aDsgaTxsOyBpKyspIHsgby5hZGRDb2xvclN0b3AocmF0aW9zW2ldLCBjb2xvcnNbaV0pOyB9XG5cdFx0by5wcm9wcyA9IHtjb2xvcnM6Y29sb3JzLCByYXRpb3M6cmF0aW9zLCB4MDp4MCwgeTA6eTAsIHgxOngxLCB5MTp5MSwgdHlwZTpcImxpbmVhclwifTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSByYWRpYWwgZ3JhZGllbnQgc3R5bGUgYW5kIGFzc2lnbnMgaXQgdG8ge3sjY3Jvc3NMaW5rIFwiRmlsbC9zdHlsZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luUmFkaWFsR3JhZGllbnRGaWxsXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIHJhZGlhbEdyYWRpZW50XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9yc1xuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjFcblx0ICogQHJldHVybiB7RmlsbH0gUmV0dXJucyB0aGlzIEZpbGwgb2JqZWN0IGZvciBjaGFpbmluZyBvciBhc3NpZ25tZW50LlxuXHQgKi9cblx0cC5yYWRpYWxHcmFkaWVudCA9IGZ1bmN0aW9uKGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHIwLCB4MSwgeTEsIHIxKSB7XG5cdFx0dmFyIG8gPSB0aGlzLnN0eWxlID0gIEdyYXBoaWNzLl9jdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoeDAsIHkwLCByMCwgeDEsIHkxLCByMSk7XG5cdFx0Zm9yICh2YXIgaT0wLCBsPWNvbG9ycy5sZW5ndGg7IGk8bDsgaSsrKSB7IG8uYWRkQ29sb3JTdG9wKHJhdGlvc1tpXSwgY29sb3JzW2ldKTsgfVxuXHRcdG8ucHJvcHMgPSB7Y29sb3JzOmNvbG9ycywgcmF0aW9zOnJhdGlvcywgeDA6eDAsIHkwOnkwLCByMDpyMCwgeDE6eDEsIHkxOnkxLCByMTpyMSwgdHlwZTpcInJhZGlhbFwifTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBiaXRtYXAgZmlsbCBzdHlsZSBhbmQgYXNzaWducyBpdCB0byB0aGUge3sjY3Jvc3NMaW5rIFwiRmlsbC9zdHlsZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luQml0bWFwRmlsbFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQG1ldGhvZCBiaXRtYXBcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50fSBpbWFnZSAgTXVzdCBiZSBsb2FkZWQgcHJpb3IgdG8gY3JlYXRpbmcgYSBiaXRtYXAgZmlsbCwgb3IgdGhlIGZpbGwgd2lsbCBiZSBlbXB0eS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtyZXBldGl0aW9uXSBPbmUgb2Y6IHJlcGVhdCwgcmVwZWF0LXgsIHJlcGVhdC15LCBvciBuby1yZXBlYXQuXG5cdCAqIEByZXR1cm4ge0ZpbGx9IFJldHVybnMgdGhpcyBGaWxsIG9iamVjdCBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cblx0ICovXG5cdHAuYml0bWFwID0gZnVuY3Rpb24oaW1hZ2UsIHJlcGV0aXRpb24pIHtcblx0XHRpZiAoaW1hZ2UubmF0dXJhbFdpZHRoIHx8IGltYWdlLmdldENvbnRleHQgfHwgaW1hZ2UucmVhZHlTdGF0ZSA+PSAyKSB7XG5cdFx0XHR2YXIgbyA9IHRoaXMuc3R5bGUgPSBHcmFwaGljcy5fY3R4LmNyZWF0ZVBhdHRlcm4oaW1hZ2UsIHJlcGV0aXRpb24gfHwgXCJcIik7XG5cdFx0XHRvLnByb3BzID0ge2ltYWdlOiBpbWFnZSwgcmVwZXRpdGlvbjogcmVwZXRpdGlvbiwgdHlwZTogXCJiaXRtYXBcIn07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRwLnBhdGggPSBmYWxzZTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpblN0cm9rZVwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgU3Ryb2tlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3R5bGUgQSB2YWxpZCBDb250ZXh0MkQgZmlsbFN0eWxlLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZVNjYWxlXG5cdCAqKi9cblx0LyoqXG5cdCAqIEEgdmFsaWQgQ29udGV4dDJEIHN0cm9rZVN0eWxlLlxuXHQgKiBAcHJvcGVydHkgc3R5bGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGlnbm9yZVNjYWxlXG5cdCAqIEB0eXBlIEJvb2xlYW5cblx0ICovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0cCA9IChHLlN0cm9rZSA9IGZ1bmN0aW9uKHN0eWxlLCBpZ25vcmVTY2FsZSkge1xuXHRcdHRoaXMuc3R5bGUgPSBzdHlsZTtcblx0XHR0aGlzLmlnbm9yZVNjYWxlID0gaWdub3JlU2NhbGU7XG5cdH0pLnByb3RvdHlwZTtcblx0cC5leGVjID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0aWYgKCF0aGlzLnN0eWxlKSB7IHJldHVybjsgfVxuXHRcdGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc3R5bGU7XG5cdFx0aWYgKHRoaXMuaWdub3JlU2NhbGUpIHsgY3R4LnNhdmUoKTsgY3R4LnNldFRyYW5zZm9ybSgxLDAsMCwxLDAsMCk7IH1cblx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0aWYgKHRoaXMuaWdub3JlU2NhbGUpIHsgY3R4LnJlc3RvcmUoKTsgfVxuXHR9O1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIGxpbmVhciBncmFkaWVudCBzdHlsZSBhbmQgYXNzaWducyBpdCB0byB7eyNjcm9zc0xpbmsgXCJTdHJva2Uvc3R5bGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkxpbmVhckdyYWRpZW50U3Ryb2tlXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIGxpbmVhckdyYWRpZW50XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9yc1xuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MFxuXHQgKiBAcGFyYW0ge051bWJlcn0geDFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxXG5cdCAqIEByZXR1cm4ge0ZpbGx9IFJldHVybnMgdGhpcyBTdHJva2Ugb2JqZWN0IGZvciBjaGFpbmluZyBvciBhc3NpZ25tZW50LlxuXHQgKi9cblx0cC5saW5lYXJHcmFkaWVudCA9IEcuRmlsbC5wcm90b3R5cGUubGluZWFyR3JhZGllbnQ7XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgcmFkaWFsIGdyYWRpZW50IHN0eWxlIGFuZCBhc3NpZ25zIGl0IHRvIHt7I2Nyb3NzTGluayBcIlN0cm9rZS9zdHlsZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luUmFkaWFsR3JhZGllbnRTdHJva2VcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBtZXRob2QgcmFkaWFsR3JhZGllbnRcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvc1xuXHQgKiBAcGFyYW0ge051bWJlcn0geDBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMFxuXHQgKiBAcGFyYW0ge051bWJlcn0geDFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMVxuXHQgKiBAcmV0dXJuIHtGaWxsfSBSZXR1cm5zIHRoaXMgU3Ryb2tlIG9iamVjdCBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cblx0ICovXG5cdHAucmFkaWFsR3JhZGllbnQgPSBHLkZpbGwucHJvdG90eXBlLnJhZGlhbEdyYWRpZW50O1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIGJpdG1hcCBmaWxsIHN0eWxlIGFuZCBhc3NpZ25zIGl0IHRvIHt7I2Nyb3NzTGluayBcIlN0cm9rZS9zdHlsZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luQml0bWFwU3Ryb2tlXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIGJpdG1hcFxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IGltYWdlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcmVwZXRpdGlvbl0gT25lIG9mOiByZXBlYXQsIHJlcGVhdC14LCByZXBlYXQteSwgb3Igbm8tcmVwZWF0LlxuXHQgKiBAcmV0dXJuIHtGaWxsfSBSZXR1cm5zIHRoaXMgU3Ryb2tlIG9iamVjdCBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cblx0ICovXG5cdHAuYml0bWFwID0gRy5GaWxsLnByb3RvdHlwZS5iaXRtYXA7XG5cdHAucGF0aCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3NldFN0cm9rZVN0eWxlXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBTdHJva2VTdHlsZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbY2Fwcz1idXR0XVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2pvaW50cz1taXRlcl1cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttaXRlckxpbWl0PTEwXVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtpZ25vcmVTY2FsZT1mYWxzZV1cblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHdpZHRoXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIE9uZSBvZjogYnV0dCwgcm91bmQsIHNxdWFyZVxuXHQgKiBAcHJvcGVydHkgY2Fwc1xuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICovXG5cdC8qKlxuXHQgKiBPbmUgb2Y6IHJvdW5kLCBiZXZlbCwgbWl0ZXJcblx0ICogQHByb3BlcnR5IGpvaW50c1xuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgbWl0ZXJMaW1pdFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0cCA9IChHLlN0cm9rZVN0eWxlID0gZnVuY3Rpb24od2lkdGgsIGNhcHMsIGpvaW50cywgbWl0ZXJMaW1pdCwgaWdub3JlU2NhbGUpIHtcblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5jYXBzID0gY2Fwcztcblx0XHR0aGlzLmpvaW50cyA9IGpvaW50cztcblx0XHR0aGlzLm1pdGVyTGltaXQgPSBtaXRlckxpbWl0O1xuXHRcdHRoaXMuaWdub3JlU2NhbGUgPSBpZ25vcmVTY2FsZTtcblx0fSkucHJvdG90eXBlO1xuXHRwLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHtcblx0XHRjdHgubGluZVdpZHRoID0gKHRoaXMud2lkdGggPT0gbnVsbCA/IFwiMVwiIDogdGhpcy53aWR0aCk7XG5cdFx0Y3R4LmxpbmVDYXAgPSAodGhpcy5jYXBzID09IG51bGwgPyBcImJ1dHRcIiA6IChpc05hTih0aGlzLmNhcHMpID8gdGhpcy5jYXBzIDogR3JhcGhpY3MuU1RST0tFX0NBUFNfTUFQW3RoaXMuY2Fwc10pKTtcblx0XHRjdHgubGluZUpvaW4gPSAodGhpcy5qb2ludHMgPT0gbnVsbCA/IFwibWl0ZXJcIiA6IChpc05hTih0aGlzLmpvaW50cykgPyB0aGlzLmpvaW50cyA6IEdyYXBoaWNzLlNUUk9LRV9KT0lOVFNfTUFQW3RoaXMuam9pbnRzXSkpO1xuXHRcdGN0eC5taXRlckxpbWl0ID0gKHRoaXMubWl0ZXJMaW1pdCA9PSBudWxsID8gXCIxMFwiIDogdGhpcy5taXRlckxpbWl0KTtcblx0XHRjdHguaWdub3JlU2NhbGUgPSAodGhpcy5pZ25vcmVTY2FsZSA9PSBudWxsID8gZmFsc2UgOiB0aGlzLmlnbm9yZVNjYWxlKTtcblx0fTtcblx0cC5wYXRoID0gZmFsc2U7XG5cdFxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9zZXRTdHJva2VEYXNoXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBTdHJva2VEYXNoXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0FycmF5fSBbc2VnbWVudHNdXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0PTBdXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBzZWdtZW50c1xuXHQgKiBAdHlwZSBBcnJheVxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBvZmZzZXRcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdChHLlN0cm9rZURhc2ggPSBmdW5jdGlvbihzZWdtZW50cywgb2Zmc2V0KSB7XG5cdFx0dGhpcy5zZWdtZW50cyA9IHNlZ21lbnRzO1xuXHRcdHRoaXMub2Zmc2V0ID0gb2Zmc2V0fHwwO1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGlmIChjdHguc2V0TGluZURhc2gpIHsgLy8gZmVhdHVyZSBkZXRlY3Rpb24uXG5cdFx0XHRjdHguc2V0TGluZURhc2godGhpcy5zZWdtZW50c3x8IEcuU3Ryb2tlRGFzaC5FTVBUWV9TRUdNRU5UUyk7IC8vIGluc3RlYWQgb2YgW10gdG8gcmVkdWNlIGNodXJuLlxuXHRcdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gdGhpcy5vZmZzZXR8fDA7XG5cdFx0fVxuXHR9O1xuXHQvKipcblx0ICogVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHNlZ21lbnRzIChpZS4gbm8gZGFzaCkuXG5cdCAqIEBwcm9wZXJ0eSBFTVBUWV9TRUdNRU5UU1xuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKiBAcmVhZG9ubHlcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqKi9cblx0Ry5TdHJva2VEYXNoLkVNUFRZX1NFR01FTlRTID0gW107XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd1JvdW5kUmVjdENvbXBsZXhcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIFJvdW5kUmVjdFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1RMXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUUlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzQlJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c0JMXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB3XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBoXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSByYWRpdXNUTFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcmFkaXVzVFJcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHJhZGl1c0JSXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSByYWRpdXNCTFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0KEcuUm91bmRSZWN0ID0gZnVuY3Rpb24oeCwgeSwgdywgaCwgcmFkaXVzVEwsIHJhZGl1c1RSLCByYWRpdXNCUiwgcmFkaXVzQkwpIHtcblx0XHR0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuXHRcdHRoaXMudyA9IHc7IHRoaXMuaCA9IGg7XG5cdFx0dGhpcy5yYWRpdXNUTCA9IHJhZGl1c1RMOyB0aGlzLnJhZGl1c1RSID0gcmFkaXVzVFI7XG5cdFx0dGhpcy5yYWRpdXNCUiA9IHJhZGl1c0JSOyB0aGlzLnJhZGl1c0JMID0gcmFkaXVzQkw7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0dmFyIG1heCA9ICh3PGg/dzpoKS8yO1xuXHRcdHZhciBtVEw9MCwgbVRSPTAsIG1CUj0wLCBtQkw9MDtcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgdyA9IHRoaXMudywgaCA9IHRoaXMuaDtcblx0XHR2YXIgclRMID0gdGhpcy5yYWRpdXNUTCwgclRSID0gdGhpcy5yYWRpdXNUUiwgckJSID0gdGhpcy5yYWRpdXNCUiwgckJMID0gdGhpcy5yYWRpdXNCTDtcblxuXHRcdGlmIChyVEwgPCAwKSB7IHJUTCAqPSAobVRMPS0xKTsgfVxuXHRcdGlmIChyVEwgPiBtYXgpIHsgclRMID0gbWF4OyB9XG5cdFx0aWYgKHJUUiA8IDApIHsgclRSICo9IChtVFI9LTEpOyB9XG5cdFx0aWYgKHJUUiA+IG1heCkgeyByVFIgPSBtYXg7IH1cblx0XHRpZiAockJSIDwgMCkgeyByQlIgKj0gKG1CUj0tMSk7IH1cblx0XHRpZiAockJSID4gbWF4KSB7IHJCUiA9IG1heDsgfVxuXHRcdGlmIChyQkwgPCAwKSB7IHJCTCAqPSAobUJMPS0xKTsgfVxuXHRcdGlmIChyQkwgPiBtYXgpIHsgckJMID0gbWF4OyB9XG5cblx0XHRjdHgubW92ZVRvKHgrdy1yVFIsIHkpO1xuXHRcdGN0eC5hcmNUbyh4K3crclRSKm1UUiwgeS1yVFIqbVRSLCB4K3csIHkrclRSLCByVFIpO1xuXHRcdGN0eC5saW5lVG8oeCt3LCB5K2gtckJSKTtcblx0XHRjdHguYXJjVG8oeCt3K3JCUiptQlIsIHkraCtyQlIqbUJSLCB4K3ctckJSLCB5K2gsIHJCUik7XG5cdFx0Y3R4LmxpbmVUbyh4K3JCTCwgeStoKTtcblx0XHRjdHguYXJjVG8oeC1yQkwqbUJMLCB5K2grckJMKm1CTCwgeCwgeStoLXJCTCwgckJMKTtcblx0XHRjdHgubGluZVRvKHgsIHkrclRMKTtcblx0XHRjdHguYXJjVG8oeC1yVEwqbVRMLCB5LXJUTCptVEwsIHgrclRMLCB5LCByVEwpO1xuXHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0fTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Q2lyY2xlXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBDaXJjbGVcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHJhZGl1c1xuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0KEcuQ2lyY2xlID0gZnVuY3Rpb24oeCwgeSwgcmFkaXVzKSB7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4LmFyYyh0aGlzLngsIHRoaXMueSwgdGhpcy5yYWRpdXMsIDAsIE1hdGguUEkqMik7IH07XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd0VsbGlwc2VcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIEVsbGlwc2Vcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB3XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBoXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHQoRy5FbGxpcHNlID0gZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdFx0dGhpcy53ID0gdzsgdGhpcy5oID0gaDtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHtcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcblx0XHR2YXIgdyA9IHRoaXMudywgaCA9IHRoaXMuaDtcblxuXHRcdHZhciBrID0gMC41NTIyODQ4O1xuXHRcdHZhciBveCA9ICh3IC8gMikgKiBrO1xuXHRcdHZhciBveSA9IChoIC8gMikgKiBrO1xuXHRcdHZhciB4ZSA9IHggKyB3O1xuXHRcdHZhciB5ZSA9IHkgKyBoO1xuXHRcdHZhciB4bSA9IHggKyB3IC8gMjtcblx0XHR2YXIgeW0gPSB5ICsgaCAvIDI7XG5cblx0XHRjdHgubW92ZVRvKHgsIHltKTtcblx0XHRjdHguYmV6aWVyQ3VydmVUbyh4LCB5bS1veSwgeG0tb3gsIHksIHhtLCB5KTtcblx0XHRjdHguYmV6aWVyQ3VydmVUbyh4bStveCwgeSwgeGUsIHltLW95LCB4ZSwgeW0pO1xuXHRcdGN0eC5iZXppZXJDdXJ2ZVRvKHhlLCB5bStveSwgeG0rb3gsIHllLCB4bSwgeWUpO1xuXHRcdGN0eC5iZXppZXJDdXJ2ZVRvKHhtLW94LCB5ZSwgeCwgeW0rb3ksIHgsIHltKTtcblx0fTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3UG9seVN0YXJcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIFBvbHlTdGFyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzaWRlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9pbnRTaXplXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcmFkaXVzXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBzaWRlc1xuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcG9pbnRTaXplXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBhbmdsZVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0KEcuUG9seVN0YXIgPSBmdW5jdGlvbih4LCB5LCByYWRpdXMsIHNpZGVzLCBwb2ludFNpemUsIGFuZ2xlKSB7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblx0XHR0aGlzLnNpZGVzID0gc2lkZXM7XG5cdFx0dGhpcy5wb2ludFNpemUgPSBwb2ludFNpemU7XG5cdFx0dGhpcy5hbmdsZSA9IGFuZ2xlO1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55O1xuXHRcdHZhciByYWRpdXMgPSB0aGlzLnJhZGl1cztcblx0XHR2YXIgYW5nbGUgPSAodGhpcy5hbmdsZXx8MCkvMTgwKk1hdGguUEk7XG5cdFx0dmFyIHNpZGVzID0gdGhpcy5zaWRlcztcblx0XHR2YXIgcHMgPSAxLSh0aGlzLnBvaW50U2l6ZXx8MCk7XG5cdFx0dmFyIGEgPSBNYXRoLlBJL3NpZGVzO1xuXG5cdFx0Y3R4Lm1vdmVUbyh4K01hdGguY29zKGFuZ2xlKSpyYWRpdXMsIHkrTWF0aC5zaW4oYW5nbGUpKnJhZGl1cyk7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPHNpZGVzOyBpKyspIHtcblx0XHRcdGFuZ2xlICs9IGE7XG5cdFx0XHRpZiAocHMgIT0gMSkge1xuXHRcdFx0XHRjdHgubGluZVRvKHgrTWF0aC5jb3MoYW5nbGUpKnJhZGl1cypwcywgeStNYXRoLnNpbihhbmdsZSkqcmFkaXVzKnBzKTtcblx0XHRcdH1cblx0XHRcdGFuZ2xlICs9IGE7XG5cdFx0XHRjdHgubGluZVRvKHgrTWF0aC5jb3MoYW5nbGUpKnJhZGl1cywgeStNYXRoLnNpbihhbmdsZSkqcmFkaXVzKTtcblx0XHR9XG5cdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHR9O1xuXG5cdC8vIGRvY2NlZCBhYm92ZS5cblx0R3JhcGhpY3MuYmVnaW5DbWQgPSBuZXcgRy5CZWdpblBhdGgoKTsgLy8gc28gd2UgZG9uJ3QgaGF2ZSB0byBpbnN0YW50aWF0ZSBtdWx0aXBsZSBpbnN0YW5jZXMuXG5cblxuXHRjcmVhdGVqcy5HcmFwaGljcyA9IEdyYXBoaWNzO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIERpc3BsYXlPYmplY3QuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBEaXNwbGF5T2JqZWN0IGlzIGFuIGFic3RyYWN0IGNsYXNzIHRoYXQgc2hvdWxkIG5vdCBiZSBjb25zdHJ1Y3RlZCBkaXJlY3RseS4gSW5zdGVhZCBjb25zdHJ1Y3Qgc3ViY2xhc3NlcyBzdWNoIGFzXG5cdCAqIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiQml0bWFwXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQge3sjY3Jvc3NMaW5rIFwiU2hhcGVcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIERpc3BsYXlPYmplY3QgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBkaXNwbGF5IGNsYXNzZXMgaW4gdGhlIEVhc2VsSlMgbGlicmFyeS4gSXQgZGVmaW5lcyB0aGUgY29yZSBwcm9wZXJ0aWVzIGFuZFxuXHQgKiBtZXRob2RzIHRoYXQgYXJlIHNoYXJlZCBiZXR3ZWVuIGFsbCBkaXNwbGF5IG9iamVjdHMsIHN1Y2ggYXMgdHJhbnNmb3JtYXRpb24gcHJvcGVydGllcyAoeCwgeSwgc2NhbGVYLCBzY2FsZVksIGV0YyksXG5cdCAqIGNhY2hpbmcsIGFuZCBtb3VzZSBoYW5kbGVycy5cblx0ICogQGNsYXNzIERpc3BsYXlPYmplY3Rcblx0ICogQGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIERpc3BsYXlPYmplY3QoKSB7XG5cdFx0dGhpcy5FdmVudERpc3BhdGNoZXJfY29uc3RydWN0b3IoKTtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIGFscGhhICh0cmFuc3BhcmVuY3kpIGZvciB0aGlzIGRpc3BsYXkgb2JqZWN0LiAwIGlzIGZ1bGx5IHRyYW5zcGFyZW50LCAxIGlzIGZ1bGx5IG9wYXF1ZS5cblx0XHQgKiBAcHJvcGVydHkgYWxwaGFcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKiovXG5cdFx0dGhpcy5hbHBoYSA9IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIGEgY2FjaGUgaXMgYWN0aXZlLCB0aGlzIHJldHVybnMgdGhlIGNhbnZhcyB0aGF0IGhvbGRzIHRoZSBjYWNoZWQgdmVyc2lvbiBvZiB0aGlzIGRpc3BsYXkgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiY2FjaGVcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgY2FjaGVDYW52YXNcblx0XHQgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnQgfCBPYmplY3R9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLmNhY2hlQ2FudmFzID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhbiBJRCBudW1iZXIgdGhhdCB1bmlxdWVseSBpZGVudGlmaWVzIHRoZSBjdXJyZW50IGNhY2hlIGZvciB0aGlzIGRpc3BsYXkgb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VkIHRvXG5cdFx0ICogZGV0ZXJtaW5lIGlmIHRoZSBjYWNoZSBoYXMgY2hhbmdlZCBzaW5jZSBhIHByZXZpb3VzIGNoZWNrLlxuXHRcdCAqIEBwcm9wZXJ0eSBjYWNoZUlEXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5jYWNoZUlEID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVW5pcXVlIElEIGZvciB0aGlzIGRpc3BsYXkgb2JqZWN0LiBNYWtlcyBkaXNwbGF5IG9iamVjdHMgZWFzaWVyIGZvciBzb21lIHVzZXMuXG5cdFx0ICogQHByb3BlcnR5IGlkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAtMVxuXHRcdCAqKi9cblx0XHR0aGlzLmlkID0gY3JlYXRlanMuVUlELmdldCgpO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0byBpbmNsdWRlIHRoaXMgb2JqZWN0IHdoZW4gcnVubmluZyBtb3VzZSBpbnRlcmFjdGlvbnMuIFNldHRpbmcgdGhpcyB0byBgZmFsc2VgIGZvciBjaGlsZHJlblxuXHRcdCAqIG9mIGEge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyXCJ9fXt7L2Nyb3NzTGlua319IHdpbGwgY2F1c2UgZXZlbnRzIG9uIHRoZSBDb250YWluZXIgdG8gbm90IGZpcmUgd2hlbiB0aGF0IGNoaWxkIGlzXG5cdFx0ICogY2xpY2tlZC4gU2V0dGluZyB0aGlzIHByb3BlcnR5IHRvIGBmYWxzZWAgZG9lcyBub3QgcHJldmVudCB0aGUge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyL2dldE9iamVjdHNVbmRlclBvaW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogbWV0aG9kIGZyb20gcmV0dXJuaW5nIHRoZSBjaGlsZC5cblx0XHQgKlxuXHRcdCAqIDxzdHJvbmc+Tm90ZTo8L3N0cm9uZz4gSW4gRWFzZWxKUyAwLjcuMCwgdGhlIG1vdXNlRW5hYmxlZCBwcm9wZXJ0eSB3aWxsIG5vdCB3b3JrIHByb3Blcmx5IHdpdGggbmVzdGVkIENvbnRhaW5lcnMuIFBsZWFzZVxuXHRcdCAqIGNoZWNrIG91dCB0aGUgbGF0ZXN0IE5FWFQgdmVyc2lvbiBpbiA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL0NyZWF0ZUpTL0Vhc2VsSlMvdHJlZS9tYXN0ZXIvbGliXCI+R2l0SHViPC9hPiBmb3IgYW4gdXBkYXRlZCB2ZXJzaW9uIHdpdGggdGhpcyBpc3N1ZSByZXNvbHZlZC4gVGhlIGZpeCB3aWxsIGJlXG5cdFx0ICogcHJvdmlkZWQgaW4gdGhlIG5leHQgcmVsZWFzZSBvZiBFYXNlbEpTLlxuXHRcdCAqIEBwcm9wZXJ0eSBtb3VzZUVuYWJsZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICoqL1xuXHRcdHRoaXMubW91c2VFbmFibGVkID0gdHJ1ZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBJZiBmYWxzZSwgdGhlIHRpY2sgd2lsbCBub3QgcnVuIG9uIHRoaXMgZGlzcGxheSBvYmplY3QgKG9yIGl0cyBjaGlsZHJlbikuIFRoaXMgY2FuIHByb3ZpZGUgc29tZSBwZXJmb3JtYW5jZSBiZW5lZml0cy5cblx0XHQgKiBJbiBhZGRpdGlvbiB0byBwcmV2ZW50aW5nIHRoZSBcInRpY2tcIiBldmVudCBmcm9tIGJlaW5nIGRpc3BhdGNoZWQsIGl0IHdpbGwgYWxzbyBwcmV2ZW50IHRpY2sgcmVsYXRlZCB1cGRhdGVzXG5cdFx0ICogb24gc29tZSBkaXNwbGF5IG9iamVjdHMgKGV4LiBTcHJpdGUgJiBNb3ZpZUNsaXAgZnJhbWUgYWR2YW5jaW5nLCBET01FbGVtZW50IHZpc2liaWxpdHkgaGFuZGxpbmcpLlxuXHRcdCAqIEBwcm9wZXJ0eSB0aWNrRW5hYmxlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICoqL1xuXHRcdHRoaXMudGlja0VuYWJsZWQgPSB0cnVlO1xuXHRcblx0XHQvKipcblx0XHQgKiBBbiBvcHRpb25hbCBuYW1lIGZvciB0aGlzIGRpc3BsYXkgb2JqZWN0LiBJbmNsdWRlZCBpbiB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3RvU3RyaW5nXCJ9fXt7L2Nyb3NzTGlua319IC4gVXNlZnVsIGZvclxuXHRcdCAqIGRlYnVnZ2luZy5cblx0XHQgKiBAcHJvcGVydHkgbmFtZVxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqKi9cblx0XHR0aGlzLm5hbWUgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBBIHJlZmVyZW5jZSB0byB0aGUge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyXCJ9fXt7L2Nyb3NzTGlua319IG9yIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319IG9iamVjdCB0aGF0XG5cdFx0ICogY29udGFpbnMgdGhpcyBkaXNwbGF5IG9iamVjdCwgb3IgbnVsbCBpZiBpdCBoYXMgbm90IGJlZW4gYWRkZWRcblx0XHQgKiB0byBvbmUuXG5cdFx0ICogQHByb3BlcnR5IHBhcmVudFxuXHRcdCAqIEBmaW5hbFxuXHRcdCAqIEB0eXBlIHtDb250YWluZXJ9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLnBhcmVudCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsZWZ0IG9mZnNldCBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdCdzIHJlZ2lzdHJhdGlvbiBwb2ludC4gRm9yIGV4YW1wbGUsIHRvIG1ha2UgYSAxMDB4MTAwcHggQml0bWFwIHJvdGF0ZVxuXHRcdCAqIGFyb3VuZCBpdHMgY2VudGVyLCB5b3Ugd291bGQgc2V0IHJlZ1ggYW5kIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvcmVnWTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSB0byA1MC5cblx0XHQgKiBAcHJvcGVydHkgcmVnWFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLnJlZ1ggPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgeSBvZmZzZXQgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QncyByZWdpc3RyYXRpb24gcG9pbnQuIEZvciBleGFtcGxlLCB0byBtYWtlIGEgMTAweDEwMHB4IEJpdG1hcCByb3RhdGUgYXJvdW5kXG5cdFx0ICogaXRzIGNlbnRlciwgeW91IHdvdWxkIHNldCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3JlZ1g6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHJlZ1kgdG8gNTAuXG5cdFx0ICogQHByb3BlcnR5IHJlZ1lcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5yZWdZID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHJvdGF0aW9uIGluIGRlZ3JlZXMgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QuXG5cdFx0ICogQHByb3BlcnR5IHJvdGF0aW9uXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMucm90YXRpb24gPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgZmFjdG9yIHRvIHN0cmV0Y2ggdGhpcyBkaXNwbGF5IG9iamVjdCBob3Jpem9udGFsbHkuIEZvciBleGFtcGxlLCBzZXR0aW5nIHNjYWxlWCB0byAyIHdpbGwgc3RyZXRjaCB0aGUgZGlzcGxheVxuXHRcdCAqIG9iamVjdCB0byB0d2ljZSBpdHMgbm9taW5hbCB3aWR0aC4gVG8gaG9yaXpvbnRhbGx5IGZsaXAgYW4gb2JqZWN0LCBzZXQgdGhlIHNjYWxlIHRvIGEgbmVnYXRpdmUgbnVtYmVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBzY2FsZVhcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKiovXG5cdFx0dGhpcy5zY2FsZVggPSAxO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgZmFjdG9yIHRvIHN0cmV0Y2ggdGhpcyBkaXNwbGF5IG9iamVjdCB2ZXJ0aWNhbGx5LiBGb3IgZXhhbXBsZSwgc2V0dGluZyBzY2FsZVkgdG8gMC41IHdpbGwgc3RyZXRjaCB0aGUgZGlzcGxheVxuXHRcdCAqIG9iamVjdCB0byBoYWxmIGl0cyBub21pbmFsIGhlaWdodC4gVG8gdmVydGljYWxseSBmbGlwIGFuIG9iamVjdCwgc2V0IHRoZSBzY2FsZSB0byBhIG5lZ2F0aXZlIG51bWJlci5cblx0XHQgKiBAcHJvcGVydHkgc2NhbGVZXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICoqL1xuXHRcdHRoaXMuc2NhbGVZID0gMTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGZhY3RvciB0byBza2V3IHRoaXMgZGlzcGxheSBvYmplY3QgaG9yaXpvbnRhbGx5LlxuXHRcdCAqIEBwcm9wZXJ0eSBza2V3WFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLnNrZXdYID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGZhY3RvciB0byBza2V3IHRoaXMgZGlzcGxheSBvYmplY3QgdmVydGljYWxseS5cblx0XHQgKiBAcHJvcGVydHkgc2tld1lcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5za2V3WSA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEEgc2hhZG93IG9iamVjdCB0aGF0IGRlZmluZXMgdGhlIHNoYWRvdyB0byByZW5kZXIgb24gdGhpcyBkaXNwbGF5IG9iamVjdC4gU2V0IHRvIGBudWxsYCB0byByZW1vdmUgYSBzaGFkb3cuIElmXG5cdFx0ICogbnVsbCwgdGhpcyBwcm9wZXJ0eSBpcyBpbmhlcml0ZWQgZnJvbSB0aGUgcGFyZW50IGNvbnRhaW5lci5cblx0XHQgKiBAcHJvcGVydHkgc2hhZG93XG5cdFx0ICogQHR5cGUge1NoYWRvd31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMuc2hhZG93ID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBkaXNwbGF5IG9iamVjdCBzaG91bGQgYmUgcmVuZGVyZWQgdG8gdGhlIGNhbnZhcyBhbmQgaW5jbHVkZWQgd2hlbiBydW5uaW5nIHRoZSBTdGFnZVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIlN0YWdlL2dldE9iamVjdHNVbmRlclBvaW50XCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cblx0XHQgKiBAcHJvcGVydHkgdmlzaWJsZVxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKiovXG5cdFx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHggKGhvcml6b250YWwpIHBvc2l0aW9uIG9mIHRoZSBkaXNwbGF5IG9iamVjdCwgcmVsYXRpdmUgdG8gaXRzIHBhcmVudC5cblx0XHQgKiBAcHJvcGVydHkgeFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLnggPSAwO1xuXHRcblx0XHQvKiogVGhlIHkgKHZlcnRpY2FsKSBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheSBvYmplY3QsIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQuXG5cdFx0ICogQHByb3BlcnR5IHlcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy55ID0gMDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBJZiBzZXQsIGRlZmluZXMgdGhlIHRyYW5zZm9ybWF0aW9uIGZvciB0aGlzIGRpc3BsYXkgb2JqZWN0LCBvdmVycmlkaW5nIGFsbCBvdGhlciB0cmFuc2Zvcm1hdGlvbiBwcm9wZXJ0aWVzXG5cdFx0ICogKHgsIHksIHJvdGF0aW9uLCBzY2FsZSwgc2tldykuXG5cdFx0ICogQHByb3BlcnR5IHRyYW5zZm9ybU1hdHJpeFxuXHRcdCAqIEB0eXBlIHtNYXRyaXgyRH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMudHJhbnNmb3JtTWF0cml4ID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBUaGUgY29tcG9zaXRlIG9wZXJhdGlvbiBpbmRpY2F0ZXMgaG93IHRoZSBwaXhlbHMgb2YgdGhpcyBkaXNwbGF5IG9iamVjdCB3aWxsIGJlIGNvbXBvc2l0ZWQgd2l0aCB0aGUgZWxlbWVudHNcblx0XHQgKiBiZWhpbmQgaXQuIElmIGBudWxsYCwgdGhpcyBwcm9wZXJ0eSBpcyBpbmhlcml0ZWQgZnJvbSB0aGUgcGFyZW50IGNvbnRhaW5lci4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlYWQgdGhlXG5cdFx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2NvbXBvc2l0aW5nXCI+XG5cdFx0ICogd2hhdHdnIHNwZWMgb24gY29tcG9zaXRpbmc8L2E+LlxuXHRcdCAqIEBwcm9wZXJ0eSBjb21wb3NpdGVPcGVyYXRpb25cblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiovXG5cdFx0dGhpcy5jb21wb3NpdGVPcGVyYXRpb24gPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgc2hvdWxkIGJlIGRyYXduIHRvIGEgd2hvbGUgcGl4ZWwgd2hlblxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIlN0YWdlL3NuYXBUb1BpeGVsRW5hYmxlZFwifX17ey9jcm9zc0xpbmt9fSBpcyB0cnVlLiBUbyBlbmFibGUvZGlzYWJsZSBzbmFwcGluZyBvbiB3aG9sZVxuXHRcdCAqIGNhdGVnb3JpZXMgb2YgZGlzcGxheSBvYmplY3RzLCBzZXQgdGhpcyB2YWx1ZSBvbiB0aGUgcHJvdG90eXBlIChFeC4gVGV4dC5wcm90b3R5cGUuc25hcFRvUGl4ZWwgPSB0cnVlKS5cblx0XHQgKiBAcHJvcGVydHkgc25hcFRvUGl4ZWxcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICoqL1xuXHRcdHRoaXMuc25hcFRvUGl4ZWwgPSB0cnVlO1xuXHRcblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBvZiBGaWx0ZXIgb2JqZWN0cyB0byBhcHBseSB0byB0aGlzIGRpc3BsYXkgb2JqZWN0LiBGaWx0ZXJzIGFyZSBvbmx5IGFwcGxpZWQgLyB1cGRhdGVkIHdoZW4ge3sjY3Jvc3NMaW5rIFwiY2FjaGVcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBvciB7eyNjcm9zc0xpbmsgXCJ1cGRhdGVDYWNoZVwifX17ey9jcm9zc0xpbmt9fSBpcyBjYWxsZWQgb24gdGhlIGRpc3BsYXkgb2JqZWN0LCBhbmQgb25seSBhcHBseSB0byB0aGUgYXJlYSB0aGF0IGlzXG5cdFx0ICogY2FjaGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBmaWx0ZXJzXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiovXG5cdFx0dGhpcy5maWx0ZXJzID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBBIFNoYXBlIGluc3RhbmNlIHRoYXQgZGVmaW5lcyBhIHZlY3RvciBtYXNrIChjbGlwcGluZyBwYXRoKSBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdC4gIFRoZSBzaGFwZSdzIHRyYW5zZm9ybWF0aW9uXG5cdFx0ICogd2lsbCBiZSBhcHBsaWVkIHJlbGF0aXZlIHRvIHRoZSBkaXNwbGF5IG9iamVjdCdzIHBhcmVudCBjb29yZGluYXRlcyAoYXMgaWYgaXQgd2VyZSBhIGNoaWxkIG9mIHRoZSBwYXJlbnQpLlxuXHRcdCAqIEBwcm9wZXJ0eSBtYXNrXG5cdFx0ICogQHR5cGUge1NoYXBlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLm1hc2sgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEEgZGlzcGxheSBvYmplY3QgdGhhdCB3aWxsIGJlIHRlc3RlZCB3aGVuIGNoZWNraW5nIG1vdXNlIGludGVyYWN0aW9ucyBvciB0ZXN0aW5nIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lci9nZXRPYmplY3RzVW5kZXJQb2ludFwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBUaGUgaGl0IGFyZWEgd2lsbCBoYXZlIGl0cyB0cmFuc2Zvcm1hdGlvbiBhcHBsaWVkIHJlbGF0aXZlIHRvIHRoaXMgZGlzcGxheSBvYmplY3QncyBjb29yZGluYXRlIHNwYWNlIChhcyB0aG91Z2hcblx0XHQgKiB0aGUgaGl0IHRlc3Qgb2JqZWN0IHdlcmUgYSBjaGlsZCBvZiB0aGlzIGRpc3BsYXkgb2JqZWN0IGFuZCByZWxhdGl2ZSB0byBpdHMgcmVnWC9ZKS4gVGhlIGhpdEFyZWEgd2lsbCBiZSB0ZXN0ZWRcblx0XHQgKiB1c2luZyBvbmx5IGl0cyBvd24gYGFscGhhYCB2YWx1ZSByZWdhcmRsZXNzIG9mIHRoZSBhbHBoYSB2YWx1ZSBvbiB0aGUgdGFyZ2V0IGRpc3BsYXkgb2JqZWN0LCBvciB0aGUgdGFyZ2V0J3Ncblx0XHQgKiBhbmNlc3RvcnMgKHBhcmVudHMpLlxuXHRcdCAqIFxuXHRcdCAqIElmIHNldCBvbiBhIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fSwgY2hpbGRyZW4gb2YgdGhlIENvbnRhaW5lciB3aWxsIG5vdCByZWNlaXZlIG1vdXNlIGV2ZW50cy5cblx0XHQgKiBUaGlzIGlzIHNpbWlsYXIgdG8gc2V0dGluZyB7eyNjcm9zc0xpbmsgXCJtb3VzZUNoaWxkcmVuXCJ9fXt7L2Nyb3NzTGlua319IHRvIGZhbHNlLlxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IGhpdEFyZWEgaXMgTk9UIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBgaGl0VGVzdCgpYCBtZXRob2QsIG5vciBpcyBpdCBzdXBwb3J0ZWQgZm9yIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBoaXRBcmVhXG5cdFx0ICogQHR5cGUge0Rpc3BsYXlPYmplY3R9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuaGl0QXJlYSA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQSBDU1MgY3Vyc29yIChleC4gXCJwb2ludGVyXCIsIFwiaGVscFwiLCBcInRleHRcIiwgZXRjKSB0aGF0IHdpbGwgYmUgZGlzcGxheWVkIHdoZW4gdGhlIHVzZXIgaG92ZXJzIG92ZXIgdGhpcyBkaXNwbGF5XG5cdFx0ICogb2JqZWN0LiBZb3UgbXVzdCBlbmFibGUgbW91c2VvdmVyIGV2ZW50cyB1c2luZyB0aGUge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvZW5hYmxlTW91c2VPdmVyXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCB0b1xuXHRcdCAqIHVzZSB0aGlzIHByb3BlcnR5LiBTZXR0aW5nIGEgbm9uLW51bGwgY3Vyc29yIG9uIGEgQ29udGFpbmVyIHdpbGwgb3ZlcnJpZGUgdGhlIGN1cnNvciBzZXQgb24gaXRzIGRlc2NlbmRhbnRzLlxuXHRcdCAqIEBwcm9wZXJ0eSBjdXJzb3Jcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmN1cnNvciA9IG51bGw7XG5cdFxuXHRcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfY2FjaGVPZmZzZXRYXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLl9jYWNoZU9mZnNldFggPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2NhY2hlT2Zmc2V0WVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5fY2FjaGVPZmZzZXRZID0gMDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2ZpbHRlck9mZnNldFhcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2ZpbHRlck9mZnNldFggPSAwO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfZmlsdGVyT2Zmc2V0WVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5fZmlsdGVyT2Zmc2V0WSA9IDA7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9jYWNoZVNjYWxlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqKi9cblx0XHR0aGlzLl9jYWNoZVNjYWxlID0gMTtcblx0XG5cdFx0LyoqXG5cdFx0KiBAcHJvcGVydHkgX2NhY2hlRGF0YVVSTElEXG5cdFx0KiBAcHJvdGVjdGVkXG5cdFx0KiBAdHlwZSB7TnVtYmVyfVxuXHRcdCogQGRlZmF1bHQgMFxuXHRcdCovXG5cdFx0dGhpcy5fY2FjaGVEYXRhVVJMSUQgPSAwO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCogQHByb3BlcnR5IF9jYWNoZURhdGFVUkxcblx0XHQqIEBwcm90ZWN0ZWRcblx0XHQqIEB0eXBlIHtTdHJpbmd9XG5cdFx0KiBAZGVmYXVsdCBudWxsXG5cdFx0Ki9cblx0XHR0aGlzLl9jYWNoZURhdGFVUkwgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3Byb3BzXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtEaXNwbGF5T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiovXG5cdFx0dGhpcy5fcHJvcHMgPSBuZXcgY3JlYXRlanMuRGlzcGxheVByb3BzKCk7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmVjdGFuZ2xlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtSZWN0YW5nbGV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqKi9cblx0XHR0aGlzLl9yZWN0YW5nbGUgPSBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKCk7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfYm91bmRzXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtSZWN0YW5nbGV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqKi9cblx0XHR0aGlzLl9ib3VuZHMgPSBudWxsO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKERpc3BsYXlPYmplY3QsIGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cdFxuLy8gc3RhdGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBMaXN0aW5nIG9mIG1vdXNlIGV2ZW50IG5hbWVzLiBVc2VkIGluIF9oYXNNb3VzZUV2ZW50TGlzdGVuZXIuXG5cdCAqIEBwcm9wZXJ0eSBfTU9VU0VfRVZFTlRTXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqKi9cblx0RGlzcGxheU9iamVjdC5fTU9VU0VfRVZFTlRTID0gW1wiY2xpY2tcIixcImRibGNsaWNrXCIsXCJtb3VzZWRvd25cIixcIm1vdXNlb3V0XCIsXCJtb3VzZW92ZXJcIixcInByZXNzbW92ZVwiLFwicHJlc3N1cFwiLFwicm9sbG91dFwiLFwicm9sbG92ZXJcIl07XG5cblx0LyoqXG5cdCAqIFN1cHByZXNzZXMgZXJyb3JzIGdlbmVyYXRlZCB3aGVuIHVzaW5nIGZlYXR1cmVzIGxpa2UgaGl0VGVzdCwgbW91c2UgZXZlbnRzLCBhbmQge3sjY3Jvc3NMaW5rIFwiZ2V0T2JqZWN0c1VuZGVyUG9pbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2l0aCBjcm9zcyBkb21haW4gY29udGVudC5cblx0ICogQHByb3BlcnR5IHN1cHByZXNzQ3Jvc3NEb21haW5FcnJvcnNcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICoqL1xuXHREaXNwbGF5T2JqZWN0LnN1cHByZXNzQ3Jvc3NEb21haW5FcnJvcnMgPSBmYWxzZTtcblx0XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3NuYXBUb1BpeGVsRW5hYmxlZFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBkZWZhdWx0IGZhbHNlXG5cdCAqKi9cblx0RGlzcGxheU9iamVjdC5fc25hcFRvUGl4ZWxFbmFibGVkID0gZmFsc2U7IC8vIHN0YWdlLnNuYXBUb1BpeGVsRW5hYmxlZCBpcyB0ZW1wb3JhcmlseSBjb3BpZWQgaGVyZSBkdXJpbmcgYSBkcmF3IHRvIHByb3ZpZGUgZ2xvYmFsIGFjY2Vzcy5cblxuXHQvKipcblx0ICogQHByb3BlcnR5IF9oaXRUZXN0Q2FudmFzXG5cdCAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudCB8IE9iamVjdH1cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfaGl0VGVzdENvbnRleHRcblx0ICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0dmFyIGNhbnZhcyA9IGNyZWF0ZWpzLmNyZWF0ZUNhbnZhcz9jcmVhdGVqcy5jcmVhdGVDYW52YXMoKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpOyAvLyBwcmV2ZW50IGVycm9ycyBvbiBsb2FkIGluIGJyb3dzZXJzIHdpdGhvdXQgY2FudmFzLlxuXHRpZiAoY2FudmFzLmdldENvbnRleHQpIHtcblx0XHREaXNwbGF5T2JqZWN0Ll9oaXRUZXN0Q2FudmFzID0gY2FudmFzO1xuXHRcdERpc3BsYXlPYmplY3QuX2hpdFRlc3RDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHRjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX25leHRDYWNoZUlEXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdERpc3BsYXlPYmplY3QuX25leHRDYWNoZUlEID0gMTtcblxuXG4vLyBldmVudHM6XG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyB0aGVpciBsZWZ0IG1vdXNlIGJ1dHRvbiBvdmVyIHRoZSBkaXNwbGF5IG9iamVjdC4gU2VlIHRoZSBcblx0ICoge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXG5cdCAqIEBldmVudCBtb3VzZWRvd25cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyB0aGVpciBsZWZ0IG1vdXNlIGJ1dHRvbiBhbmQgdGhlbiByZWxlYXNlcyBpdCB3aGlsZSBvdmVyIHRoZSBkaXNwbGF5IG9iamVjdC5cblx0ICogU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cblx0ICogQGV2ZW50IGNsaWNrXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSB1c2VyIGRvdWJsZSBjbGlja3MgdGhlaXIgbGVmdCBtb3VzZSBidXR0b24gb3ZlciB0aGlzIGRpc3BsYXkgb2JqZWN0LlxuXHQgKiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxuXHQgKiBAZXZlbnQgZGJsY2xpY2tcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHVzZXIncyBtb3VzZSBlbnRlcnMgdGhpcyBkaXNwbGF5IG9iamVjdC4gVGhpcyBldmVudCBtdXN0IGJlIGVuYWJsZWQgdXNpbmcgXG5cdCAqIHt7I2Nyb3NzTGluayBcIlN0YWdlL2VuYWJsZU1vdXNlT3ZlclwifX17ey9jcm9zc0xpbmt9fS4gU2VlIGFsc28ge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9yb2xsb3ZlcjpldmVudFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cblx0ICogQGV2ZW50IG1vdXNlb3ZlclxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgdXNlcidzIG1vdXNlIGxlYXZlcyB0aGlzIGRpc3BsYXkgb2JqZWN0LiBUaGlzIGV2ZW50IG11c3QgYmUgZW5hYmxlZCB1c2luZyBcblx0ICoge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvZW5hYmxlTW91c2VPdmVyXCJ9fXt7L2Nyb3NzTGlua319LiBTZWUgYWxzbyB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3JvbGxvdXQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXG5cdCAqIEBldmVudCBtb3VzZW91dFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIFRoaXMgZXZlbnQgaXMgc2ltaWxhciB0byB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlb3ZlcjpldmVudFwifX17ey9jcm9zc0xpbmt9fSwgd2l0aCB0aGUgZm9sbG93aW5nXG5cdCAqIGRpZmZlcmVuY2VzOiBpdCBkb2VzIG5vdCBidWJibGUsIGFuZCBpdCBjb25zaWRlcnMge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlcyBhcyBhblxuXHQgKiBhZ2dyZWdhdGUgb2YgdGhlaXIgY29udGVudC5cblx0ICogXG5cdCAqIEZvciBleGFtcGxlLCBteUNvbnRhaW5lciBjb250YWlucyB0d28gb3ZlcmxhcHBpbmcgY2hpbGRyZW46IHNoYXBlQSBhbmQgc2hhcGVCLiBUaGUgdXNlciBtb3ZlcyB0aGVpciBtb3VzZSBvdmVyXG5cdCAqIHNoYXBlQSBhbmQgdGhlbiBkaXJlY3RseSBvbiB0byBzaGFwZUIuIFdpdGggYSBsaXN0ZW5lciBmb3Ige3sjY3Jvc3NMaW5rIFwibW91c2VvdmVyOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IG9uXG5cdCAqIG15Q29udGFpbmVyLCB0d28gZXZlbnRzIHdvdWxkIGJlIHJlY2VpdmVkLCBlYWNoIHRhcmdldGluZyBhIGNoaWxkIGVsZW1lbnQ6PE9MPlxuXHQgKiA8TEk+d2hlbiB0aGUgbW91c2UgZW50ZXJzIHNoYXBlQSAodGFyZ2V0PXNoYXBlQSk8L0xJPlxuXHQgKiA8TEk+d2hlbiB0aGUgbW91c2UgZW50ZXJzIHNoYXBlQiAodGFyZ2V0PXNoYXBlQik8L0xJPlxuXHQgKiA8L09MPlxuXHQgKiBIb3dldmVyLCB3aXRoIGEgbGlzdGVuZXIgZm9yIFwicm9sbG92ZXJcIiBpbnN0ZWFkLCBvbmx5IGEgc2luZ2xlIGV2ZW50IGlzIHJlY2VpdmVkIHdoZW4gdGhlIG1vdXNlIGZpcnN0IGVudGVyc1xuXHQgKiB0aGUgYWdncmVnYXRlIG15Q29udGFpbmVyIGNvbnRlbnQgKHRhcmdldD1teUNvbnRhaW5lcikuXG5cdCAqIFxuXHQgKiBUaGlzIGV2ZW50IG11c3QgYmUgZW5hYmxlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJTdGFnZS9lbmFibGVNb3VzZU92ZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXG5cdCAqIEBldmVudCByb2xsb3ZlclxuXHQgKiBAc2luY2UgMC43LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIFRoaXMgZXZlbnQgaXMgc2ltaWxhciB0byB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlb3V0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LCB3aXRoIHRoZSBmb2xsb3dpbmdcblx0ICogZGlmZmVyZW5jZXM6IGl0IGRvZXMgbm90IGJ1YmJsZSwgYW5kIGl0IGNvbnNpZGVycyB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2VzIGFzIGFuXG5cdCAqIGFnZ3JlZ2F0ZSBvZiB0aGVpciBjb250ZW50LlxuXHQgKiBcblx0ICogRm9yIGV4YW1wbGUsIG15Q29udGFpbmVyIGNvbnRhaW5zIHR3byBvdmVybGFwcGluZyBjaGlsZHJlbjogc2hhcGVBIGFuZCBzaGFwZUIuIFRoZSB1c2VyIG1vdmVzIHRoZWlyIG1vdXNlIG92ZXJcblx0ICogc2hhcGVBLCB0aGVuIGRpcmVjdGx5IG9uIHRvIHNoYXBlQiwgdGhlbiBvZmYgYm90aC4gV2l0aCBhIGxpc3RlbmVyIGZvciB7eyNjcm9zc0xpbmsgXCJtb3VzZW91dDpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvbiBteUNvbnRhaW5lciwgdHdvIGV2ZW50cyB3b3VsZCBiZSByZWNlaXZlZCwgZWFjaCB0YXJnZXRpbmcgYSBjaGlsZCBlbGVtZW50OjxPTD5cblx0ICogPExJPndoZW4gdGhlIG1vdXNlIGxlYXZlcyBzaGFwZUEgKHRhcmdldD1zaGFwZUEpPC9MST5cblx0ICogPExJPndoZW4gdGhlIG1vdXNlIGxlYXZlcyBzaGFwZUIgKHRhcmdldD1zaGFwZUIpPC9MST5cblx0ICogPC9PTD5cblx0ICogSG93ZXZlciwgd2l0aCBhIGxpc3RlbmVyIGZvciBcInJvbGxvdXRcIiBpbnN0ZWFkLCBvbmx5IGEgc2luZ2xlIGV2ZW50IGlzIHJlY2VpdmVkIHdoZW4gdGhlIG1vdXNlIGxlYXZlc1xuXHQgKiB0aGUgYWdncmVnYXRlIG15Q29udGFpbmVyIGNvbnRlbnQgKHRhcmdldD1teUNvbnRhaW5lcikuXG5cdCAqIFxuXHQgKiBUaGlzIGV2ZW50IG11c3QgYmUgZW5hYmxlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJTdGFnZS9lbmFibGVNb3VzZU92ZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXG5cdCAqIEBldmVudCByb2xsb3V0XG5cdCAqIEBzaW5jZSAwLjcuMFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogQWZ0ZXIgYSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlZG93bjpldmVudFwifX17ey9jcm9zc0xpbmt9fSBvY2N1cnMgb24gYSBkaXNwbGF5IG9iamVjdCwgYSBwcmVzc21vdmVcblx0ICogZXZlbnQgd2lsbCBiZSBnZW5lcmF0ZWQgb24gdGhhdCBvYmplY3Qgd2hlbmV2ZXIgdGhlIG1vdXNlIG1vdmVzIHVudGlsIHRoZSBtb3VzZSBwcmVzcyBpcyByZWxlYXNlZC4gVGhpcyBjYW4gYmVcblx0ICogdXNlZnVsIGZvciBkcmFnZ2luZyBhbmQgc2ltaWxhciBvcGVyYXRpb25zLlxuXHQgKiBAZXZlbnQgcHJlc3Ntb3ZlXG5cdCAqIEBzaW5jZSAwLjcuMFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogQWZ0ZXIgYSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlZG93bjpldmVudFwifX17ey9jcm9zc0xpbmt9fSBvY2N1cnMgb24gYSBkaXNwbGF5IG9iamVjdCwgYSBwcmVzc3VwIGV2ZW50XG5cdCAqIHdpbGwgYmUgZ2VuZXJhdGVkIG9uIHRoYXQgb2JqZWN0IHdoZW4gdGhhdCBtb3VzZSBwcmVzcyBpcyByZWxlYXNlZC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvciBkcmFnZ2luZyBhbmQgc2ltaWxhclxuXHQgKiBvcGVyYXRpb25zLlxuXHQgKiBAZXZlbnQgcHJlc3N1cFxuXHQgKiBAc2luY2UgMC43LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgZGlzcGxheSBvYmplY3QgaXMgYWRkZWQgdG8gYSBwYXJlbnQgY29udGFpbmVyLlxuXHQgKiBAZXZlbnQgYWRkZWRcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgZGlzcGxheSBvYmplY3QgaXMgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgY29udGFpbmVyLlxuXHQgKiBAZXZlbnQgcmVtb3ZlZFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCBvbiBlYWNoIGRpc3BsYXkgb2JqZWN0IG9uIGEgc3RhZ2Ugd2hlbmV2ZXIgdGhlIHN0YWdlIHVwZGF0ZXMuIFRoaXMgb2NjdXJzIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGVcblx0ICogcmVuZGVyaW5nIChkcmF3KSBwYXNzLiBXaGVuIHt7I2Nyb3NzTGluayBcIlN0YWdlL3VwZGF0ZVwifX17ey9jcm9zc0xpbmt9fSBpcyBjYWxsZWQsIGZpcnN0IGFsbCBkaXNwbGF5IG9iamVjdHMgb25cblx0ICogdGhlIHN0YWdlIGRpc3BhdGNoIHRoZSB0aWNrIGV2ZW50LCB0aGVuIGFsbCBvZiB0aGUgZGlzcGxheSBvYmplY3RzIGFyZSBkcmF3biB0byBzdGFnZS4gQ2hpbGRyZW4gd2lsbCBoYXZlIHRoZWlyXG5cdCAqIHt7I2Nyb3NzTGluayBcInRpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgZGlzcGF0Y2hlZCBpbiBvcmRlciBvZiB0aGVpciBkZXB0aCBwcmlvciB0byB0aGUgZXZlbnQgYmVpbmdcblx0ICogZGlzcGF0Y2hlZCBvbiB0aGVpciBwYXJlbnQuXG5cdCAqIEBldmVudCB0aWNrXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIEFuIGFycmF5IGNvbnRhaW5pbmcgYW55IGFyZ3VtZW50cyB0aGF0IHdlcmUgcGFzc2VkIHRvIHRoZSBTdGFnZS51cGRhdGUoKSBtZXRob2QuIEZvclxuXHQgKiAgICAgIGV4YW1wbGUgaWYgeW91IGNhbGxlZCBzdGFnZS51cGRhdGUoXCJoZWxsb1wiKSwgdGhlbiB0aGUgcGFyYW1zIHdvdWxkIGJlIFtcImhlbGxvXCJdLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdFxuXHRcbi8vIGdldHRlciAvIHNldHRlcnM6XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3Qvc3RhZ2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXRTdGFnZVxuXHQgKiBAcmV0dXJuIHtTdGFnZX1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRwLmdldFN0YWdlID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gdXNlcyBkeW5hbWljIGFjY2VzcyB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXM7XG5cdFx0dmFyIG8gPSB0aGlzLCBfU3RhZ2UgPSBjcmVhdGVqc1tcIlN0YWdlXCJdO1xuXHRcdHdoaWxlIChvLnBhcmVudCkgeyBvID0gby5wYXJlbnQ7IH1cblx0XHRpZiAobyBpbnN0YW5jZW9mIF9TdGFnZSkgeyByZXR1cm4gbzsgfVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBTdGFnZSBpbnN0YW5jZSB0aGF0IHRoaXMgZGlzcGxheSBvYmplY3Qgd2lsbCBiZSByZW5kZXJlZCBvbiwgb3IgbnVsbCBpZiBpdCBoYXMgbm90IGJlZW4gYWRkZWQgdG8gb25lLlxuXHQgKiBAcHJvcGVydHkgc3RhZ2Vcblx0ICogQHR5cGUge1N0YWdlfVxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcblx0XHRcdHN0YWdlOiB7IGdldDogcC5nZXRTdGFnZSB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHt9XG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxuXHQgKlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzXG5cdCAqKi9cblx0cC5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9IDAgJiYgdGhpcy5zY2FsZVkgIT0gMCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS5cblx0ICogUmV0dXJucyA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGUgZHJhdyB3YXMgaGFuZGxlZCAodXNlZnVsIGZvciBvdmVycmlkaW5nIGZ1bmN0aW9uYWxpdHkpLlxuXHQgKlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgZHJhd1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtpZ25vcmVDYWNoZT1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRyYXcgb3BlcmF0aW9uIHNob3VsZCBpZ25vcmUgYW55IGN1cnJlbnQgY2FjaGUuIEZvciBleGFtcGxlLFxuXHQgKiB1c2VkIGZvciBkcmF3aW5nIHRoZSBjYWNoZSAodG8gcHJldmVudCBpdCBmcm9tIHNpbXBseSBkcmF3aW5nIGFuIGV4aXN0aW5nIGNhY2hlIGJhY2sgaW50byBpdHNlbGYpLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiovXG5cdHAuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgaWdub3JlQ2FjaGUpIHtcblx0XHR2YXIgY2FjaGVDYW52YXMgPSB0aGlzLmNhY2hlQ2FudmFzO1xuXHRcdGlmIChpZ25vcmVDYWNoZSB8fCAhY2FjaGVDYW52YXMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fY2FjaGVTY2FsZTtcblx0XHRjdHguZHJhd0ltYWdlKGNhY2hlQ2FudmFzLCB0aGlzLl9jYWNoZU9mZnNldFgrdGhpcy5fZmlsdGVyT2Zmc2V0WCwgdGhpcy5fY2FjaGVPZmZzZXRZK3RoaXMuX2ZpbHRlck9mZnNldFksIGNhY2hlQ2FudmFzLndpZHRoL3NjYWxlLCBjYWNoZUNhbnZhcy5oZWlnaHQvc2NhbGUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEFwcGxpZXMgdGhpcyBkaXNwbGF5IG9iamVjdCdzIHRyYW5zZm9ybWF0aW9uLCBhbHBoYSwgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uLCBjbGlwcGluZyBwYXRoIChtYXNrKSwgYW5kIHNoYWRvd1xuXHQgKiB0byB0aGUgc3BlY2lmaWVkIGNvbnRleHQuIFRoaXMgaXMgdHlwaWNhbGx5IGNhbGxlZCBwcmlvciB0byB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2RyYXdcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgdXBkYXRlQ29udGV4dFxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgdG8gdXBkYXRlLlxuXHQgKiovXG5cdHAudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdHZhciBvPXRoaXMsIG1hc2s9by5tYXNrLCBtdHg9IG8uX3Byb3BzLm1hdHJpeDtcblx0XHRcblx0XHRpZiAobWFzayAmJiBtYXNrLmdyYXBoaWNzICYmICFtYXNrLmdyYXBoaWNzLmlzRW1wdHkoKSkge1xuXHRcdFx0bWFzay5nZXRNYXRyaXgobXR4KTtcblx0XHRcdGN0eC50cmFuc2Zvcm0obXR4LmEsICBtdHguYiwgbXR4LmMsIG10eC5kLCBtdHgudHgsIG10eC50eSk7XG5cdFx0XHRcblx0XHRcdG1hc2suZ3JhcGhpY3MuZHJhd0FzUGF0aChjdHgpO1xuXHRcdFx0Y3R4LmNsaXAoKTtcblx0XHRcdFxuXHRcdFx0bXR4LmludmVydCgpO1xuXHRcdFx0Y3R4LnRyYW5zZm9ybShtdHguYSwgIG10eC5iLCBtdHguYywgbXR4LmQsIG10eC50eCwgbXR4LnR5KTtcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5nZXRNYXRyaXgobXR4KTtcblx0XHR2YXIgdHggPSBtdHgudHgsIHR5ID0gbXR4LnR5O1xuXHRcdGlmIChEaXNwbGF5T2JqZWN0Ll9zbmFwVG9QaXhlbEVuYWJsZWQgJiYgby5zbmFwVG9QaXhlbCkge1xuXHRcdFx0dHggPSB0eCArICh0eCA8IDAgPyAtMC41IDogMC41KSB8IDA7XG5cdFx0XHR0eSA9IHR5ICsgKHR5IDwgMCA/IC0wLjUgOiAwLjUpIHwgMDtcblx0XHR9XG5cdFx0Y3R4LnRyYW5zZm9ybShtdHguYSwgIG10eC5iLCBtdHguYywgbXR4LmQsIHR4LCB0eSk7XG5cdFx0Y3R4Lmdsb2JhbEFscGhhICo9IG8uYWxwaGE7XG5cdFx0aWYgKG8uY29tcG9zaXRlT3BlcmF0aW9uKSB7IGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBvLmNvbXBvc2l0ZU9wZXJhdGlvbjsgfVxuXHRcdGlmIChvLnNoYWRvdykgeyB0aGlzLl9hcHBseVNoYWRvdyhjdHgsIG8uc2hhZG93KTsgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyB0aGUgZGlzcGxheSBvYmplY3QgaW50byBhIG5ldyBjYW52YXMsIHdoaWNoIGlzIHRoZW4gdXNlZCBmb3Igc3Vic2VxdWVudCBkcmF3cy4gRm9yIGNvbXBsZXggY29udGVudFxuXHQgKiB0aGF0IGRvZXMgbm90IGNoYW5nZSBmcmVxdWVudGx5IChleC4gYSBDb250YWluZXIgd2l0aCBtYW55IGNoaWxkcmVuIHRoYXQgZG8gbm90IG1vdmUsIG9yIGEgY29tcGxleCB2ZWN0b3IgU2hhcGUpLFxuXHQgKiB0aGlzIGNhbiBwcm92aWRlIGZvciBtdWNoIGZhc3RlciByZW5kZXJpbmcgYmVjYXVzZSB0aGUgY29udGVudCBkb2VzIG5vdCBuZWVkIHRvIGJlIHJlLXJlbmRlcmVkIGVhY2ggdGljay4gVGhlXG5cdCAqIGNhY2hlZCBkaXNwbGF5IG9iamVjdCBjYW4gYmUgbW92ZWQsIHJvdGF0ZWQsIGZhZGVkLCBldGMgZnJlZWx5LCBob3dldmVyIGlmIGl0cyBjb250ZW50IGNoYW5nZXMsIHlvdSBtdXN0XG5cdCAqIG1hbnVhbGx5IHVwZGF0ZSB0aGUgY2FjaGUgYnkgY2FsbGluZyA8Y29kZT51cGRhdGVDYWNoZSgpPC9jb2RlPiBvciA8Y29kZT5jYWNoZSgpPC9jb2RlPiBhZ2Fpbi4gWW91IG11c3Qgc3BlY2lmeVxuXHQgKiB0aGUgY2FjaGUgYXJlYSB2aWEgdGhlIHgsIHksIHcsIGFuZCBoIHBhcmFtZXRlcnMuIFRoaXMgZGVmaW5lcyB0aGUgcmVjdGFuZ2xlIHRoYXQgd2lsbCBiZSByZW5kZXJlZCBhbmQgY2FjaGVkXG5cdCAqIHVzaW5nIHRoaXMgZGlzcGxheSBvYmplY3QncyBjb29yZGluYXRlcy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBGb3IgZXhhbXBsZSBpZiB5b3UgZGVmaW5lZCBhIFNoYXBlIHRoYXQgZHJldyBhIGNpcmNsZSBhdCAwLCAwIHdpdGggYSByYWRpdXMgb2YgMjU6XG5cdCAqXG5cdCAqICAgICAgdmFyIHNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG5cdCAqICAgICAgc2hhcGUuZ3JhcGhpY3MuYmVnaW5GaWxsKFwiI2ZmMDAwMFwiKS5kcmF3Q2lyY2xlKDAsIDAsIDI1KTtcblx0ICogICAgICBteVNoYXBlLmNhY2hlKC0yNSwgLTI1LCA1MCwgNTApO1xuXHQgKlxuXHQgKiBOb3RlIHRoYXQgZmlsdGVycyBuZWVkIHRvIGJlIGRlZmluZWQgPGVtPmJlZm9yZTwvZW0+IHRoZSBjYWNoZSBpcyBhcHBsaWVkLiBDaGVjayBvdXQgdGhlIHt7I2Nyb3NzTGluayBcIkZpbHRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBjbGFzcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4gU29tZSBmaWx0ZXJzIChleC4gQmx1ckZpbHRlcikgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBzY2FsZSBwYXJhbS5cblx0ICogXG5cdCAqIFVzdWFsbHksIHRoZSByZXN1bHRpbmcgY2FjaGVDYW52YXMgd2lsbCBoYXZlIHRoZSBkaW1lbnNpb25zIHdpZHRoKnNjYWxlIGJ5IGhlaWdodCpzY2FsZSwgaG93ZXZlciBzb21lIGZpbHRlcnMgKGV4LiBCbHVyRmlsdGVyKVxuXHQgKiB3aWxsIGFkZCBwYWRkaW5nIHRvIHRoZSBjYW52YXMgZGltZW5zaW9ucy5cblx0ICpcblx0ICogQG1ldGhvZCBjYWNoZVxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb29yZGluYXRlIG9yaWdpbiBmb3IgdGhlIGNhY2hlIHJlZ2lvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29vcmRpbmF0ZSBvcmlnaW4gZm9yIHRoZSBjYWNoZSByZWdpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIGNhY2hlIHJlZ2lvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBjYWNoZSByZWdpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGU9MV0gVGhlIHNjYWxlIGF0IHdoaWNoIHRoZSBjYWNoZSB3aWxsIGJlIGNyZWF0ZWQuIEZvciBleGFtcGxlLCBpZiB5b3UgY2FjaGUgYSB2ZWN0b3Igc2hhcGUgdXNpbmdcblx0ICogXHRteVNoYXBlLmNhY2hlKDAsMCwxMDAsMTAwLDIpIHRoZW4gdGhlIHJlc3VsdGluZyBjYWNoZUNhbnZhcyB3aWxsIGJlIDIwMHgyMDAgcHguIFRoaXMgbGV0cyB5b3Ugc2NhbGUgYW5kIHJvdGF0ZVxuXHQgKiBcdGNhY2hlZCBlbGVtZW50cyB3aXRoIGdyZWF0ZXIgZmlkZWxpdHkuIERlZmF1bHQgaXMgMS5cblx0ICoqL1xuXHRwLmNhY2hlID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCwgc2NhbGUpIHtcblx0XHQvLyBkcmF3IHRvIGNhbnZhcy5cblx0XHRzY2FsZSA9IHNjYWxlfHwxO1xuXHRcdGlmICghdGhpcy5jYWNoZUNhbnZhcykgeyB0aGlzLmNhY2hlQ2FudmFzID0gY3JlYXRlanMuY3JlYXRlQ2FudmFzP2NyZWF0ZWpzLmNyZWF0ZUNhbnZhcygpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7IH1cblx0XHR0aGlzLl9jYWNoZVdpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5fY2FjaGVIZWlnaHQgPSBoZWlnaHQ7XG5cdFx0dGhpcy5fY2FjaGVPZmZzZXRYID0geDtcblx0XHR0aGlzLl9jYWNoZU9mZnNldFkgPSB5O1xuXHRcdHRoaXMuX2NhY2hlU2NhbGUgPSBzY2FsZTtcblx0XHR0aGlzLnVwZGF0ZUNhY2hlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlZHJhd3MgdGhlIGRpc3BsYXkgb2JqZWN0IHRvIGl0cyBjYWNoZS4gQ2FsbGluZyB1cGRhdGVDYWNoZSB3aXRob3V0IGFuIGFjdGl2ZSBjYWNoZSB3aWxsIHRocm93IGFuIGVycm9yLlxuXHQgKiBJZiBjb21wb3NpdGVPcGVyYXRpb24gaXMgbnVsbCB0aGUgY3VycmVudCBjYWNoZSB3aWxsIGJlIGNsZWFyZWQgcHJpb3IgdG8gZHJhd2luZy4gT3RoZXJ3aXNlIHRoZSBkaXNwbGF5IG9iamVjdFxuXHQgKiB3aWxsIGJlIGRyYXduIG92ZXIgdGhlIGV4aXN0aW5nIGNhY2hlIHVzaW5nIHRoZSBzcGVjaWZpZWQgY29tcG9zaXRlT3BlcmF0aW9uLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIENsZWFyIHRoZSBjdXJyZW50IGdyYXBoaWNzIG9mIGEgY2FjaGVkIHNoYXBlLCBkcmF3IHNvbWUgbmV3IGluc3RydWN0aW9ucywgYW5kIHRoZW4gdXBkYXRlIHRoZSBjYWNoZS4gVGhlIG5ldyBsaW5lXG5cdCAqIHdpbGwgYmUgZHJhd24gb24gdG9wIG9mIHRoZSBvbGQgb25lLlxuXHQgKlxuXHQgKiAgICAgIC8vIE5vdCBzaG93bjogQ3JlYXRpbmcgdGhlIHNoYXBlLCBhbmQgY2FjaGluZyBpdC5cblx0ICogICAgICBzaGFwZUluc3RhbmNlLmNsZWFyKCk7XG5cdCAqICAgICAgc2hhcGVJbnN0YW5jZS5zZXRTdHJva2VTdHlsZSgzKS5iZWdpblN0cm9rZShcIiNmZjAwMDBcIikubW92ZVRvKDEwMCwgMTAwKS5saW5lVG8oMjAwLDIwMCk7XG5cdCAqICAgICAgc2hhcGVJbnN0YW5jZS51cGRhdGVDYWNoZSgpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHVwZGF0ZUNhY2hlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb3NpdGVPcGVyYXRpb24gVGhlIGNvbXBvc2l0ZU9wZXJhdGlvbiB0byB1c2UsIG9yIG51bGwgdG8gY2xlYXIgdGhlIGNhY2hlIGFuZCByZWRyYXcgaXQuXG5cdCAqIDxhIGhyZWY9XCJodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCNjb21wb3NpdGluZ1wiPlxuXHQgKiB3aGF0d2cgc3BlYyBvbiBjb21wb3NpdGluZzwvYT4uXG5cdCAqKi9cblx0cC51cGRhdGVDYWNoZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZU9wZXJhdGlvbikge1xuXHRcdHZhciBjYWNoZUNhbnZhcyA9IHRoaXMuY2FjaGVDYW52YXM7XG5cdFx0aWYgKCFjYWNoZUNhbnZhcykgeyB0aHJvdyBcImNhY2hlKCkgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHVwZGF0ZUNhY2hlKClcIjsgfVxuXHRcdHZhciBzY2FsZSA9IHRoaXMuX2NhY2hlU2NhbGUsIG9mZlggPSB0aGlzLl9jYWNoZU9mZnNldFgqc2NhbGUsIG9mZlkgPSB0aGlzLl9jYWNoZU9mZnNldFkqc2NhbGU7XG5cdFx0dmFyIHcgPSB0aGlzLl9jYWNoZVdpZHRoLCBoID0gdGhpcy5fY2FjaGVIZWlnaHQsIGN0eCA9IGNhY2hlQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHRcblx0XHR2YXIgZkJvdW5kcyA9IHRoaXMuX2dldEZpbHRlckJvdW5kcygpO1xuXHRcdG9mZlggKz0gKHRoaXMuX2ZpbHRlck9mZnNldFggPSBmQm91bmRzLngpO1xuXHRcdG9mZlkgKz0gKHRoaXMuX2ZpbHRlck9mZnNldFkgPSBmQm91bmRzLnkpO1xuXHRcdFxuXHRcdHcgPSBNYXRoLmNlaWwodypzY2FsZSkgKyBmQm91bmRzLndpZHRoO1xuXHRcdGggPSBNYXRoLmNlaWwoaCpzY2FsZSkgKyBmQm91bmRzLmhlaWdodDtcblx0XHRpZiAodyAhPSBjYWNoZUNhbnZhcy53aWR0aCB8fCBoICE9IGNhY2hlQ2FudmFzLmhlaWdodCkge1xuXHRcdFx0Ly8gVE9ETzogaXQgd291bGQgYmUgbmljZSB0byBwcmVzZXJ2ZSB0aGUgY29udGVudCBpZiB0aGVyZSBpcyBhIGNvbXBvc2l0ZU9wZXJhdGlvbi5cblx0XHRcdGNhY2hlQ2FudmFzLndpZHRoID0gdztcblx0XHRcdGNhY2hlQ2FudmFzLmhlaWdodCA9IGg7XG5cdFx0fSBlbHNlIGlmICghY29tcG9zaXRlT3BlcmF0aW9uKSB7XG5cdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHcrMSwgaCsxKTtcblx0XHR9XG5cdFx0XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gY29tcG9zaXRlT3BlcmF0aW9uO1xuXHRcdGN0eC5zZXRUcmFuc2Zvcm0oc2NhbGUsIDAsIDAsIHNjYWxlLCAtb2ZmWCwgLW9mZlkpO1xuXHRcdHRoaXMuZHJhdyhjdHgsIHRydWUpO1xuXHRcdC8vIFRPRE86IGZpbHRlcnMgYW5kIGNhY2hlIHNjYWxlIGRvbid0IHBsYXkgd2VsbCB0b2dldGhlciBhdCBwcmVzZW50LlxuXHRcdHRoaXMuX2FwcGx5RmlsdGVycygpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0dGhpcy5jYWNoZUlEID0gRGlzcGxheU9iamVjdC5fbmV4dENhY2hlSUQrKztcblx0fTtcblxuXHQvKipcblx0ICogQ2xlYXJzIHRoZSBjdXJyZW50IGNhY2hlLiBTZWUge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9jYWNoZVwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQG1ldGhvZCB1bmNhY2hlXG5cdCAqKi9cblx0cC51bmNhY2hlID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fY2FjaGVEYXRhVVJMID0gdGhpcy5jYWNoZUNhbnZhcyA9IG51bGw7XG5cdFx0dGhpcy5jYWNoZUlEID0gdGhpcy5fY2FjaGVPZmZzZXRYID0gdGhpcy5fY2FjaGVPZmZzZXRZID0gdGhpcy5fZmlsdGVyT2Zmc2V0WCA9IHRoaXMuX2ZpbHRlck9mZnNldFkgPSAwO1xuXHRcdHRoaXMuX2NhY2hlU2NhbGUgPSAxO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBkYXRhIFVSTCBmb3IgdGhlIGNhY2hlLCBvciBudWxsIGlmIHRoaXMgZGlzcGxheSBvYmplY3QgaXMgbm90IGNhY2hlZC5cblx0ICogVXNlcyBjYWNoZUlEIHRvIGVuc3VyZSBhIG5ldyBkYXRhIFVSTCBpcyBub3QgZ2VuZXJhdGVkIGlmIHRoZSBjYWNoZSBoYXMgbm90IGNoYW5nZWQuXG5cdCAqIEBtZXRob2QgZ2V0Q2FjaGVEYXRhVVJMXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGltYWdlIGRhdGEgdXJsIGZvciB0aGUgY2FjaGUuXG5cdCAqKi9cblx0cC5nZXRDYWNoZURhdGFVUkwgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuY2FjaGVDYW52YXMpIHsgcmV0dXJuIG51bGw7IH1cblx0XHRpZiAodGhpcy5jYWNoZUlEICE9IHRoaXMuX2NhY2hlRGF0YVVSTElEKSB7IHRoaXMuX2NhY2hlRGF0YVVSTCA9IHRoaXMuY2FjaGVDYW52YXMudG9EYXRhVVJMKCk7IH1cblx0XHRyZXR1cm4gdGhpcy5fY2FjaGVEYXRhVVJMO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUcmFuc2Zvcm1zIHRoZSBzcGVjaWZpZWQgeCBhbmQgeSBwb3NpdGlvbiBmcm9tIHRoZSBjb29yZGluYXRlIHNwYWNlIG9mIHRoZSBkaXNwbGF5IG9iamVjdFxuXHQgKiB0byB0aGUgZ2xvYmFsIChzdGFnZSkgY29vcmRpbmF0ZSBzcGFjZS4gRm9yIGV4YW1wbGUsIHRoaXMgY291bGQgYmUgdXNlZCB0byBwb3NpdGlvbiBhbiBIVE1MIGxhYmVsXG5cdCAqIG92ZXIgYSBzcGVjaWZpYyBwb2ludCBvbiBhIG5lc3RlZCBkaXNwbGF5IG9iamVjdC4gUmV0dXJucyBhIFBvaW50IGluc3RhbmNlIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzXG5cdCAqIGNvcnJlbGF0aW5nIHRvIHRoZSB0cmFuc2Zvcm1lZCBjb29yZGluYXRlcyBvbiB0aGUgc3RhZ2UuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnggPSAzMDA7XG5cdCAqICAgICAgZGlzcGxheU9iamVjdC55ID0gMjAwO1xuXHQgKiAgICAgIHN0YWdlLmFkZENoaWxkKGRpc3BsYXlPYmplY3QpO1xuXHQgKiAgICAgIHZhciBwb2ludCA9IGRpc3BsYXlPYmplY3QubG9jYWxUb0dsb2JhbCgxMDAsIDEwMCk7XG5cdCAqICAgICAgLy8gUmVzdWx0cyBpbiB4PTQwMCwgeT0zMDBcblx0ICpcblx0ICogQG1ldGhvZCBsb2NhbFRvR2xvYmFsXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIGluIHRoZSBzb3VyY2UgZGlzcGxheSBvYmplY3QgdG8gdHJhbnNmb3JtLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiBpbiB0aGUgc291cmNlIGRpc3BsYXkgb2JqZWN0IHRvIHRyYW5zZm9ybS5cblx0ICogQHBhcmFtIHtQb2ludCB8IE9iamVjdH0gW3B0XSBBbiBvYmplY3QgdG8gY29weSB0aGUgcmVzdWx0IGludG8uIElmIG9taXR0ZWQgYSBuZXcgUG9pbnQgb2JqZWN0IHdpdGggeC95IHByb3BlcnRpZXMgd2lsbCBiZSByZXR1cm5lZC4gXG5cdCAqIEByZXR1cm4ge1BvaW50fSBBIFBvaW50IGluc3RhbmNlIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzIGNvcnJlbGF0aW5nIHRvIHRoZSB0cmFuc2Zvcm1lZCBjb29yZGluYXRlc1xuXHQgKiBvbiB0aGUgc3RhZ2UuXG5cdCAqKi9cblx0cC5sb2NhbFRvR2xvYmFsID0gZnVuY3Rpb24oeCwgeSwgcHQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDb25jYXRlbmF0ZWRNYXRyaXgodGhpcy5fcHJvcHMubWF0cml4KS50cmFuc2Zvcm1Qb2ludCh4LHksIHB0fHxuZXcgY3JlYXRlanMuUG9pbnQoKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRyYW5zZm9ybXMgdGhlIHNwZWNpZmllZCB4IGFuZCB5IHBvc2l0aW9uIGZyb20gdGhlIGdsb2JhbCAoc3RhZ2UpIGNvb3JkaW5hdGUgc3BhY2UgdG8gdGhlXG5cdCAqIGNvb3JkaW5hdGUgc3BhY2Ugb2YgdGhlIGRpc3BsYXkgb2JqZWN0LiBGb3IgZXhhbXBsZSwgdGhpcyBjb3VsZCBiZSB1c2VkIHRvIGRldGVybWluZVxuXHQgKiB0aGUgY3VycmVudCBtb3VzZSBwb3NpdGlvbiB3aXRoaW4gdGhlIGRpc3BsYXkgb2JqZWN0LiBSZXR1cm5zIGEgUG9pbnQgaW5zdGFuY2Ugd2l0aCB4IGFuZCB5IHByb3BlcnRpZXNcblx0ICogY29ycmVsYXRpbmcgdG8gdGhlIHRyYW5zZm9ybWVkIHBvc2l0aW9uIGluIHRoZSBkaXNwbGF5IG9iamVjdCdzIGNvb3JkaW5hdGUgc3BhY2UuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnggPSAzMDA7XG5cdCAqICAgICAgZGlzcGxheU9iamVjdC55ID0gMjAwO1xuXHQgKiAgICAgIHN0YWdlLmFkZENoaWxkKGRpc3BsYXlPYmplY3QpO1xuXHQgKiAgICAgIHZhciBwb2ludCA9IGRpc3BsYXlPYmplY3QuZ2xvYmFsVG9Mb2NhbCgxMDAsIDEwMCk7XG5cdCAqICAgICAgLy8gUmVzdWx0cyBpbiB4PS0yMDAsIHk9LTEwMFxuXHQgKlxuXHQgKiBAbWV0aG9kIGdsb2JhbFRvTG9jYWxcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gb24gdGhlIHN0YWdlIHRvIHRyYW5zZm9ybS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gb24gdGhlIHN0YWdlIHRvIHRyYW5zZm9ybS5cblx0ICogQHBhcmFtIHtQb2ludCB8IE9iamVjdH0gW3B0XSBBbiBvYmplY3QgdG8gY29weSB0aGUgcmVzdWx0IGludG8uIElmIG9taXR0ZWQgYSBuZXcgUG9pbnQgb2JqZWN0IHdpdGggeC95IHByb3BlcnRpZXMgd2lsbCBiZSByZXR1cm5lZC4gXG5cdCAqIEByZXR1cm4ge1BvaW50fSBBIFBvaW50IGluc3RhbmNlIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzIGNvcnJlbGF0aW5nIHRvIHRoZSB0cmFuc2Zvcm1lZCBwb3NpdGlvbiBpbiB0aGVcblx0ICogZGlzcGxheSBvYmplY3QncyBjb29yZGluYXRlIHNwYWNlLlxuXHQgKiovXG5cdHAuZ2xvYmFsVG9Mb2NhbCA9IGZ1bmN0aW9uKHgsIHksIHB0KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29uY2F0ZW5hdGVkTWF0cml4KHRoaXMuX3Byb3BzLm1hdHJpeCkuaW52ZXJ0KCkudHJhbnNmb3JtUG9pbnQoeCx5LCBwdHx8bmV3IGNyZWF0ZWpzLlBvaW50KCkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUcmFuc2Zvcm1zIHRoZSBzcGVjaWZpZWQgeCBhbmQgeSBwb3NpdGlvbiBmcm9tIHRoZSBjb29yZGluYXRlIHNwYWNlIG9mIHRoaXMgZGlzcGxheSBvYmplY3QgdG8gdGhlIGNvb3JkaW5hdGVcblx0ICogc3BhY2Ugb2YgdGhlIHRhcmdldCBkaXNwbGF5IG9iamVjdC4gUmV0dXJucyBhIFBvaW50IGluc3RhbmNlIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzIGNvcnJlbGF0aW5nIHRvIHRoZVxuXHQgKiB0cmFuc2Zvcm1lZCBwb3NpdGlvbiBpbiB0aGUgdGFyZ2V0J3MgY29vcmRpbmF0ZSBzcGFjZS4gRWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgdXNpbmcgdGhlIGZvbGxvd2luZyBjb2RlIHdpdGhcblx0ICoge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9sb2NhbFRvR2xvYmFsXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2dsb2JhbFRvTG9jYWxcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqICAgICAgdmFyIHB0ID0gdGhpcy5sb2NhbFRvR2xvYmFsKHgsIHkpO1xuXHQgKiAgICAgIHB0ID0gdGFyZ2V0Lmdsb2JhbFRvTG9jYWwocHQueCwgcHQueSk7XG5cdCAqXG5cdCAqIEBtZXRob2QgbG9jYWxUb0xvY2FsXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIGluIHRoZSBzb3VyY2UgZGlzcGxheSBvYmplY3QgdG8gdHJhbnNmb3JtLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiBvbiB0aGUgc291cmNlIGRpc3BsYXkgb2JqZWN0IHRvIHRyYW5zZm9ybS5cblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBkaXNwbGF5IG9iamVjdCB0byB3aGljaCB0aGUgY29vcmRpbmF0ZXMgd2lsbCBiZSB0cmFuc2Zvcm1lZC5cblx0ICogQHBhcmFtIHtQb2ludCB8IE9iamVjdH0gW3B0XSBBbiBvYmplY3QgdG8gY29weSB0aGUgcmVzdWx0IGludG8uIElmIG9taXR0ZWQgYSBuZXcgUG9pbnQgb2JqZWN0IHdpdGggeC95IHByb3BlcnRpZXMgd2lsbCBiZSByZXR1cm5lZC4gXG5cdCAqIEByZXR1cm4ge1BvaW50fSBSZXR1cm5zIGEgUG9pbnQgaW5zdGFuY2Ugd2l0aCB4IGFuZCB5IHByb3BlcnRpZXMgY29ycmVsYXRpbmcgdG8gdGhlIHRyYW5zZm9ybWVkIHBvc2l0aW9uXG5cdCAqIGluIHRoZSB0YXJnZXQncyBjb29yZGluYXRlIHNwYWNlLlxuXHQgKiovXG5cdHAubG9jYWxUb0xvY2FsID0gZnVuY3Rpb24oeCwgeSwgdGFyZ2V0LCBwdCkge1xuXHRcdHB0ID0gdGhpcy5sb2NhbFRvR2xvYmFsKHgsIHksIHB0KTtcblx0XHRyZXR1cm4gdGFyZ2V0Lmdsb2JhbFRvTG9jYWwocHQueCwgcHQueSwgcHQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCBtZXRob2QgdG8gcXVpY2tseSBzZXQgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0aWVzIG9uIHRoZSBkaXNwbGF5IG9iamVjdC4gQWxsIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsLlxuXHQgKiBPbWl0dGVkIHBhcmFtZXRlcnMgd2lsbCBoYXZlIHRoZSBkZWZhdWx0IHZhbHVlIHNldC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3Quc2V0VHJhbnNmb3JtKDEwMCwgMTAwLCAyLCAyKTtcblx0ICpcblx0ICogQG1ldGhvZCBzZXRUcmFuc2Zvcm1cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIFRoZSBob3Jpem9udGFsIHRyYW5zbGF0aW9uICh4IHBvc2l0aW9uKSBpbiBwaXhlbHNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIFRoZSB2ZXJ0aWNhbCB0cmFuc2xhdGlvbiAoeSBwb3NpdGlvbikgaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVYPTFdIFRoZSBob3Jpem9udGFsIHNjYWxlLCBhcyBhIHBlcmNlbnRhZ2Ugb2YgMVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlWT0xXSB0aGUgdmVydGljYWwgc2NhbGUsIGFzIGEgcGVyY2VudGFnZSBvZiAxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcm90YXRpb249MF0gVGhlIHJvdGF0aW9uLCBpbiBkZWdyZWVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2tld1g9MF0gVGhlIGhvcml6b250YWwgc2tldyBmYWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtza2V3WT0wXSBUaGUgdmVydGljYWwgc2tldyBmYWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtyZWdYPTBdIFRoZSBob3Jpem9udGFsIHJlZ2lzdHJhdGlvbiBwb2ludCBpbiBwaXhlbHNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtyZWdZPTBdIFRoZSB2ZXJ0aWNhbCByZWdpc3RyYXRpb24gcG9pbnQgaW4gcGl4ZWxzXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IFJldHVybnMgdGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBjb21tYW5kcy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uKHgsIHksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1gsIHNrZXdZLCByZWdYLCByZWdZKSB7XG5cdFx0dGhpcy54ID0geCB8fCAwO1xuXHRcdHRoaXMueSA9IHkgfHwgMDtcblx0XHR0aGlzLnNjYWxlWCA9IHNjYWxlWCA9PSBudWxsID8gMSA6IHNjYWxlWDtcblx0XHR0aGlzLnNjYWxlWSA9IHNjYWxlWSA9PSBudWxsID8gMSA6IHNjYWxlWTtcblx0XHR0aGlzLnJvdGF0aW9uID0gcm90YXRpb24gfHwgMDtcblx0XHR0aGlzLnNrZXdYID0gc2tld1ggfHwgMDtcblx0XHR0aGlzLnNrZXdZID0gc2tld1kgfHwgMDtcblx0XHR0aGlzLnJlZ1ggPSByZWdYIHx8IDA7XG5cdFx0dGhpcy5yZWdZID0gcmVnWSB8fCAwO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBtYXRyaXggYmFzZWQgb24gdGhpcyBvYmplY3QncyBjdXJyZW50IHRyYW5zZm9ybS5cblx0ICogQG1ldGhvZCBnZXRNYXRyaXhcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4IE9wdGlvbmFsLiBBIE1hdHJpeDJEIG9iamVjdCB0byBwb3B1bGF0ZSB3aXRoIHRoZSBjYWxjdWxhdGVkIHZhbHVlcy4gSWYgbnVsbCwgYSBuZXdcblx0ICogTWF0cml4IG9iamVjdCBpcyByZXR1cm5lZC5cblx0ICogQHJldHVybiB7TWF0cml4MkR9IEEgbWF0cml4IHJlcHJlc2VudGluZyB0aGlzIGRpc3BsYXkgb2JqZWN0J3MgdHJhbnNmb3JtLlxuXHQgKiovXG5cdHAuZ2V0TWF0cml4ID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0dmFyIG8gPSB0aGlzLCBtdHggPSBtYXRyaXgmJm1hdHJpeC5pZGVudGl0eSgpIHx8IG5ldyBjcmVhdGVqcy5NYXRyaXgyRCgpO1xuXHRcdHJldHVybiBvLnRyYW5zZm9ybU1hdHJpeCA/ICBtdHguY29weShvLnRyYW5zZm9ybU1hdHJpeCkgOiBtdHguYXBwZW5kVHJhbnNmb3JtKG8ueCwgby55LCBvLnNjYWxlWCwgby5zY2FsZVksIG8ucm90YXRpb24sIG8uc2tld1gsIG8uc2tld1ksIG8ucmVnWCwgby5yZWdZKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSBNYXRyaXgyRCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjb21iaW5lZCB0cmFuc2Zvcm0gb2YgdGhlIGRpc3BsYXkgb2JqZWN0IGFuZCBhbGwgb2YgaXRzXG5cdCAqIHBhcmVudCBDb250YWluZXJzIHVwIHRvIHRoZSBoaWdoZXN0IGxldmVsIGFuY2VzdG9yICh1c3VhbGx5IHRoZSB7eyNjcm9zc0xpbmsgXCJTdGFnZVwifX17ey9jcm9zc0xpbmt9fSkuIFRoaXMgY2FuXG5cdCAqIGJlIHVzZWQgdG8gdHJhbnNmb3JtIHBvc2l0aW9ucyBiZXR3ZWVuIGNvb3JkaW5hdGUgc3BhY2VzLCBzdWNoIGFzIHdpdGgge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9sb2NhbFRvR2xvYmFsXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGFuZCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2dsb2JhbFRvTG9jYWxcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgZ2V0Q29uY2F0ZW5hdGVkTWF0cml4XG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IFttYXRyaXhdIEEge3sjY3Jvc3NMaW5rIFwiTWF0cml4MkRcIn19e3svY3Jvc3NMaW5rfX0gb2JqZWN0IHRvIHBvcHVsYXRlIHdpdGggdGhlIGNhbGN1bGF0ZWQgdmFsdWVzLlxuXHQgKiBJZiBudWxsLCBhIG5ldyBNYXRyaXgyRCBvYmplY3QgaXMgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGUgY29tYmluZWQgbWF0cml4LlxuXHQgKiovXG5cdHAuZ2V0Q29uY2F0ZW5hdGVkTWF0cml4ID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0dmFyIG8gPSB0aGlzLCBtdHggPSB0aGlzLmdldE1hdHJpeChtYXRyaXgpO1xuXHRcdHdoaWxlIChvID0gby5wYXJlbnQpIHtcblx0XHRcdG10eC5wcmVwZW5kTWF0cml4KG8uZ2V0TWF0cml4KG8uX3Byb3BzLm1hdHJpeCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gbXR4O1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBhIERpc3BsYXlQcm9wcyBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjb21iaW5lZCBkaXNwbGF5IHByb3BlcnRpZXMgb2YgdGhlICBvYmplY3QgYW5kIGFsbCBvZiBpdHNcblx0ICogcGFyZW50IENvbnRhaW5lcnMgdXAgdG8gdGhlIGhpZ2hlc3QgbGV2ZWwgYW5jZXN0b3IgKHVzdWFsbHkgdGhlIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319KS5cblx0ICogQG1ldGhvZCBnZXRDb25jYXRlbmF0ZWREaXNwbGF5UHJvcHNcblx0ICogQHBhcmFtIHtEaXNwbGF5UHJvcHN9IFtwcm9wc10gQSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5UHJvcHNcIn19e3svY3Jvc3NMaW5rfX0gb2JqZWN0IHRvIHBvcHVsYXRlIHdpdGggdGhlIGNhbGN1bGF0ZWQgdmFsdWVzLlxuXHQgKiBJZiBudWxsLCBhIG5ldyBEaXNwbGF5UHJvcHMgb2JqZWN0IGlzIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5UHJvcHN9IFRoZSBjb21iaW5lZCBkaXNwbGF5IHByb3BlcnRpZXMuXG5cdCAqKi9cblx0cC5nZXRDb25jYXRlbmF0ZWREaXNwbGF5UHJvcHMgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdHByb3BzID0gcHJvcHMgPyBwcm9wcy5pZGVudGl0eSgpIDogbmV3IGNyZWF0ZWpzLkRpc3BsYXlQcm9wcygpO1xuXHRcdHZhciBvID0gdGhpcywgbXR4ID0gby5nZXRNYXRyaXgocHJvcHMubWF0cml4KTsgXG5cdFx0ZG8ge1xuXHRcdFx0cHJvcHMucHJlcGVuZChvLnZpc2libGUsIG8uYWxwaGEsIG8uc2hhZG93LCBvLmNvbXBvc2l0ZU9wZXJhdGlvbik7XG5cdFx0XHRcblx0XHRcdC8vIHdlIGRvIHRoaXMgdG8gYXZvaWQgcHJvYmxlbXMgd2l0aCB0aGUgbWF0cml4IGJlaW5nIHVzZWQgZm9yIGJvdGggb3BlcmF0aW9ucyB3aGVuIG8uX3Byb3BzLm1hdHJpeCBpcyBwYXNzZWQgaW4gYXMgdGhlIHByb3BzIHBhcmFtLlxuXHRcdFx0Ly8gdGhpcyBjb3VsZCBiZSBzaW1wbGlmaWVkIChpZS4ganVzdCBkb25lIGFzIHBhcnQgb2YgdGhlIHByZXBlbmQgYWJvdmUpIGlmIHdlIHN3aXRjaGVkIHRvIHVzaW5nIGEgcG9vbC5cblx0XHRcdGlmIChvICE9IHRoaXMpIHsgbXR4LnByZXBlbmRNYXRyaXgoby5nZXRNYXRyaXgoby5fcHJvcHMubWF0cml4KSk7IH1cblx0XHR9IHdoaWxlIChvID0gby5wYXJlbnQpO1xuXHRcdHJldHVybiBwcm9wcztcblx0fTtcblxuXHQvKipcblx0ICogVGVzdHMgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3QgaW50ZXJzZWN0cyB0aGUgc3BlY2lmaWVkIHBvaW50IGluIDxlbT5sb2NhbDwvZW0+IGNvb3JkaW5hdGVzIChpZS4gZHJhd3MgYSBwaXhlbFxuXHQgKiB3aXRoIGFscGhhID4gMCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uKS4gVGhpcyBpZ25vcmVzIHRoZSBhbHBoYSwgc2hhZG93LCBoaXRBcmVhLCBtYXNrLCBhbmQgY29tcG9zaXRlT3BlcmF0aW9uXG5cdCAqIG9mIHRoZSBkaXNwbGF5IG9iamVjdC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiBcdFx0dmFyIG15U2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcblx0ICogXHRcdG15U2hhcGUuZ3JhcGhpY3MuYmVnaW5GaWxsKFwicmVkXCIpLmRyYXdSZWN0KDEwMCwgMTAwLCAyMCwgNTApO1xuXHQgKlxuXHQgKiBcdFx0Y29uc29sZS5sb2cobXlTaGFwZS5oaXRUZXN0KDEwLDEwKTsgLy8gZmFsc2Vcblx0ICogXHRcdGNvbnNvbGUubG9nKG15U2hhcGUuaGl0VGVzdCgxMTAsIDI1KTsgLy8gdHJ1ZVxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdG8gdXNlIFN0YWdlIGNvb3JkaW5hdGVzIChzdWNoIGFzIHt7I2Nyb3NzTGluayBcIlN0YWdlL21vdXNlWDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSksIHRoZXkgbXVzdFxuXHQgKiBmaXJzdCBiZSBjb252ZXJ0ZWQgdG8gbG9jYWwgY29vcmRpbmF0ZXM6XG5cdCAqXG5cdCAqICAgICAgc3RhZ2UuYWRkRXZlbnRMaXN0ZW5lcihcInN0YWdlbW91c2Vkb3duXCIsIGhhbmRsZU1vdXNlRG93bik7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2ZW50KSB7XG5cdCAqICAgICAgXHR2YXIgcCA9IG15U2hhcGUuZ2xvYmFsVG9Mb2NhbChzdGFnZS5tb3VzZVgsIHN0YWdlLm1vdXNlWSk7XG5cdCAqICAgICAgICAgIHZhciBoaXQgPSBteVNoYXBlLmhpdFRlc3QocC54LCBwLnkpO1xuXHQgKiAgICAgIH1cblx0ICpcblx0ICogU2hhcGUtdG8tc2hhcGUgY29sbGlzaW9uIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IEVhc2VsSlMuXG5cdCAqXG5cdCAqIEBtZXRob2QgaGl0VGVzdFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvbiB0byBjaGVjayBpbiB0aGUgZGlzcGxheSBvYmplY3QncyBsb2NhbCBjb29yZGluYXRlcy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gdG8gY2hlY2sgaW4gdGhlIGRpc3BsYXkgb2JqZWN0J3MgbG9jYWwgY29vcmRpbmF0ZXMuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgYSB2aXNpYmxlIHBvcnRpb24gb2YgdGhlIERpc3BsYXlPYmplY3QgaW50ZXJzZWN0IHRoZSBzcGVjaWZpZWRcblx0ICogbG9jYWwgUG9pbnQuXG5cdCovXG5cdHAuaGl0VGVzdCA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR2YXIgY3R4ID0gRGlzcGxheU9iamVjdC5faGl0VGVzdENvbnRleHQ7XG5cdFx0Y3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAteCwgLXkpO1xuXHRcdHRoaXMuZHJhdyhjdHgpO1xuXG5cdFx0dmFyIGhpdCA9IHRoaXMuX3Rlc3RIaXQoY3R4KTtcblx0XHRjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgMiwgMik7XG5cdFx0cmV0dXJuIGhpdDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBQcm92aWRlcyBhIGNoYWluYWJsZSBzaG9ydGN1dCBtZXRob2QgZm9yIHNldHRpbmcgYSBudW1iZXIgb2YgcHJvcGVydGllcyBvbiB0aGUgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgbXlHcmFwaGljcyA9IG5ldyBjcmVhdGVqcy5HcmFwaGljcygpLmJlZ2luRmlsbChcIiNmZjAwMDBcIikuZHJhd0NpcmNsZSgwLCAwLCAyNSk7XG5cdCAqICAgICAgdmFyIHNoYXBlID0gc3RhZ2UuYWRkQ2hpbGQobmV3IGNyZWF0ZWpzLlNoYXBlKCkpLnNldCh7Z3JhcGhpY3M6bXlHcmFwaGljcywgeDoxMDAsIHk6MTAwLCBhbHBoYTowLjV9KTtcblx0ICpcblx0ICogQG1ldGhvZCBzZXRcblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEEgZ2VuZXJpYyBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRvIGNvcHkgdG8gdGhlIERpc3BsYXlPYmplY3QgaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IFJldHVybnMgdGhlIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLnNldCA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykgeyB0aGlzW25dID0gcHJvcHNbbl07IH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgcmVjdGFuZ2xlIHJlcHJlc2VudGluZyB0aGlzIG9iamVjdCdzIGJvdW5kcyBpbiBpdHMgbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW0gKGllLiB3aXRoIG5vIHRyYW5zZm9ybWF0aW9uKS5cblx0ICogT2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBjYWNoZWQgd2lsbCByZXR1cm4gdGhlIGJvdW5kcyBvZiB0aGUgY2FjaGUuXG5cdCAqIFxuXHQgKiBOb3QgYWxsIGRpc3BsYXkgb2JqZWN0cyBjYW4gY2FsY3VsYXRlIHRoZWlyIG93biBib3VuZHMgKGV4LiBTaGFwZSkuIEZvciB0aGVzZSBvYmplY3RzLCB5b3UgY2FuIHVzZSBcblx0ICoge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9zZXRCb3VuZHNcIn19e3svY3Jvc3NMaW5rfX0gc28gdGhhdCB0aGV5IGFyZSBpbmNsdWRlZCB3aGVuIGNhbGN1bGF0aW5nIENvbnRhaW5lclxuXHQgKiBib3VuZHMuXG5cdCAqIFxuXHQgKiA8dGFibGU+XG5cdCAqIFx0PHRyPjx0ZD48Yj5BbGw8L2I+PC90ZD48dGQ+XG5cdCAqIFx0XHRBbGwgZGlzcGxheSBvYmplY3RzIHN1cHBvcnQgc2V0dGluZyBib3VuZHMgbWFudWFsbHkgdXNpbmcgc2V0Qm91bmRzKCkuIExpa2V3aXNlLCBkaXNwbGF5IG9iamVjdHMgdGhhdFxuXHQgKiBcdFx0aGF2ZSBiZWVuIGNhY2hlZCB1c2luZyBjYWNoZSgpIHdpbGwgcmV0dXJuIHRoZSBib3VuZHMgb2YgdGhlaXIgY2FjaGUuIE1hbnVhbCBhbmQgY2FjaGUgYm91bmRzIHdpbGwgb3ZlcnJpZGVcblx0ICogXHRcdHRoZSBhdXRvbWF0aWMgY2FsY3VsYXRpb25zIGxpc3RlZCBiZWxvdy5cblx0ICogXHQ8L3RkPjwvdHI+XG5cdCAqIFx0PHRyPjx0ZD48Yj5CaXRtYXA8L2I+PC90ZD48dGQ+XG5cdCAqIFx0XHRSZXR1cm5zIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBzb3VyY2VSZWN0IChpZiBzcGVjaWZpZWQpIG9yIGltYWdlLCBleHRlbmRpbmcgZnJvbSAoeD0wLHk9MCkuXG5cdCAqIFx0PC90ZD48L3RyPlxuXHQgKiBcdDx0cj48dGQ+PGI+U3ByaXRlPC9iPjwvdGQ+PHRkPlxuXHQgKiBcdFx0UmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBjdXJyZW50IGZyYW1lLiBNYXkgaGF2ZSBub24temVybyB4L3kgaWYgYSBmcmFtZSByZWdpc3RyYXRpb24gcG9pbnQgd2FzIHNwZWNpZmllZFxuXHQgKiBcdFx0aW4gdGhlIHNwcml0ZXNoZWV0IGRhdGEuIFNlZSBhbHNvIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0L2dldEZyYW1lQm91bmRzXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIFx0PC90ZD48L3RyPlxuXHQgKiBcdDx0cj48dGQ+PGI+Q29udGFpbmVyPC9iPjwvdGQ+PHRkPlxuXHQgKiBcdFx0UmV0dXJucyB0aGUgYWdncmVnYXRlIChjb21iaW5lZCkgYm91bmRzIG9mIGFsbCBjaGlsZHJlbiB0aGF0IHJldHVybiBhIG5vbi1udWxsIHZhbHVlIGZyb20gZ2V0Qm91bmRzKCkuXG5cdCAqIFx0PC90ZD48L3RyPlxuXHQgKiBcdDx0cj48dGQ+PGI+U2hhcGU8L2I+PC90ZD48dGQ+XG5cdCAqIFx0XHREb2VzIG5vdCBjdXJyZW50bHkgc3VwcG9ydCBhdXRvbWF0aWMgYm91bmRzIGNhbGN1bGF0aW9ucy4gVXNlIHNldEJvdW5kcygpIHRvIG1hbnVhbGx5IGRlZmluZSBib3VuZHMuXG5cdCAqIFx0PC90ZD48L3RyPlxuXHQgKiBcdDx0cj48dGQ+PGI+VGV4dDwvYj48L3RkPjx0ZD5cblx0ICogXHRcdFJldHVybnMgYXBwcm94aW1hdGUgYm91bmRzLiBIb3Jpem9udGFsIHZhbHVlcyAoeC93aWR0aCkgYXJlIHF1aXRlIGFjY3VyYXRlLCBidXQgdmVydGljYWwgdmFsdWVzICh5L2hlaWdodCkgYXJlXG5cdCAqIFx0XHRub3QsIGVzcGVjaWFsbHkgd2hlbiB1c2luZyB0ZXh0QmFzZWxpbmUgdmFsdWVzIG90aGVyIHRoYW4gXCJ0b3BcIi5cblx0ICogXHQ8L3RkPjwvdHI+XG5cdCAqIFx0PHRyPjx0ZD48Yj5CaXRtYXBUZXh0PC9iPjwvdGQ+PHRkPlxuXHQgKiBcdFx0UmV0dXJucyBhcHByb3hpbWF0ZSBib3VuZHMuIFZhbHVlcyB3aWxsIGJlIG1vcmUgYWNjdXJhdGUgaWYgc3ByaXRlc2hlZXQgZnJhbWUgcmVnaXN0cmF0aW9uIHBvaW50cyBhcmUgY2xvc2Vcblx0ICogXHRcdHRvICh4PTAseT0wKS5cblx0ICogXHQ8L3RkPjwvdHI+XG5cdCogPC90YWJsZT5cblx0ICogXG5cdCAqIEJvdW5kcyBjYW4gYmUgZXhwZW5zaXZlIHRvIGNhbGN1bGF0ZSBmb3Igc29tZSBvYmplY3RzIChleC4gdGV4dCwgb3IgY29udGFpbmVycyB3aXRoIG1hbnkgY2hpbGRyZW4pLCBhbmRcblx0ICogYXJlIHJlY2FsY3VsYXRlZCBlYWNoIHRpbWUgeW91IGNhbGwgZ2V0Qm91bmRzKCkuIFlvdSBjYW4gcHJldmVudCByZWNhbGN1bGF0aW9uIG9uIHN0YXRpYyBvYmplY3RzIGJ5IHNldHRpbmcgdGhlXG5cdCAqIGJvdW5kcyBleHBsaWNpdGx5OlxuXHQgKiBcblx0ICogXHR2YXIgYm91bmRzID0gb2JqLmdldEJvdW5kcygpO1xuXHQgKiBcdG9iai5zZXRCb3VuZHMoYm91bmRzLngsIGJvdW5kcy55LCBib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpO1xuXHQgKiBcdC8vIGdldEJvdW5kcyB3aWxsIG5vdyB1c2UgdGhlIHNldCB2YWx1ZXMsIGluc3RlYWQgb2YgcmVjYWxjdWxhdGluZ1xuXHQgKiBcblx0ICogVG8gcmVkdWNlIG1lbW9yeSBpbXBhY3QsIHRoZSByZXR1cm5lZCBSZWN0YW5nbGUgaW5zdGFuY2UgbWF5IGJlIHJldXNlZCBpbnRlcm5hbGx5OyBjbG9uZSB0aGUgaW5zdGFuY2Ugb3IgY29weSBpdHNcblx0ICogdmFsdWVzIGlmIHlvdSBuZWVkIHRvIHJldGFpbiBpdC5cblx0ICogXG5cdCAqIFx0dmFyIG15Qm91bmRzID0gb2JqLmdldEJvdW5kcygpLmNsb25lKCk7XG5cdCAqIFx0Ly8gT1I6XG5cdCAqIFx0bXlSZWN0LmNvcHkob2JqLmdldEJvdW5kcygpKTtcblx0ICogXG5cdCAqIEBtZXRob2QgZ2V0Qm91bmRzXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gQSBSZWN0YW5nbGUgaW5zdGFuY2UgcmVwcmVzZW50aW5nIHRoZSBib3VuZHMsIG9yIG51bGwgaWYgYm91bmRzIGFyZSBub3QgYXZhaWxhYmxlIGZvciB0aGlzXG5cdCAqIG9iamVjdC5cblx0ICoqL1xuXHRwLmdldEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9ib3VuZHMpIHsgcmV0dXJuIHRoaXMuX3JlY3RhbmdsZS5jb3B5KHRoaXMuX2JvdW5kcyk7IH1cblx0XHR2YXIgY2FjaGVDYW52YXMgPSB0aGlzLmNhY2hlQ2FudmFzO1xuXHRcdGlmIChjYWNoZUNhbnZhcykge1xuXHRcdFx0dmFyIHNjYWxlID0gdGhpcy5fY2FjaGVTY2FsZTtcblx0XHRcdHJldHVybiB0aGlzLl9yZWN0YW5nbGUuc2V0VmFsdWVzKHRoaXMuX2NhY2hlT2Zmc2V0WCwgdGhpcy5fY2FjaGVPZmZzZXRZLCBjYWNoZUNhbnZhcy53aWR0aC9zY2FsZSwgY2FjaGVDYW52YXMuaGVpZ2h0L3NjYWxlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIHJlY3RhbmdsZSByZXByZXNlbnRpbmcgdGhpcyBvYmplY3QncyBib3VuZHMgaW4gaXRzIHBhcmVudCdzIGNvb3JkaW5hdGUgc3lzdGVtIChpZS4gd2l0aCB0cmFuc2Zvcm1hdGlvbnMgYXBwbGllZCkuXG5cdCAqIE9iamVjdHMgdGhhdCBoYXZlIGJlZW4gY2FjaGVkIHdpbGwgcmV0dXJuIHRoZSB0cmFuc2Zvcm1lZCBib3VuZHMgb2YgdGhlIGNhY2hlLlxuXHQgKiBcblx0ICogTm90IGFsbCBkaXNwbGF5IG9iamVjdHMgY2FuIGNhbGN1bGF0ZSB0aGVpciBvd24gYm91bmRzIChleC4gU2hhcGUpLiBGb3IgdGhlc2Ugb2JqZWN0cywgeW91IGNhbiB1c2UgXG5cdCAqIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3Qvc2V0Qm91bmRzXCJ9fXt7L2Nyb3NzTGlua319IHNvIHRoYXQgdGhleSBhcmUgaW5jbHVkZWQgd2hlbiBjYWxjdWxhdGluZyBDb250YWluZXJcblx0ICogYm91bmRzLlxuXHQgKiBcblx0ICogVG8gcmVkdWNlIG1lbW9yeSBpbXBhY3QsIHRoZSByZXR1cm5lZCBSZWN0YW5nbGUgaW5zdGFuY2UgbWF5IGJlIHJldXNlZCBpbnRlcm5hbGx5OyBjbG9uZSB0aGUgaW5zdGFuY2Ugb3IgY29weSBpdHNcblx0ICogdmFsdWVzIGlmIHlvdSBuZWVkIHRvIHJldGFpbiBpdC5cblx0ICogXG5cdCAqIENvbnRhaW5lciBpbnN0YW5jZXMgY2FsY3VsYXRlIGFnZ3JlZ2F0ZSBib3VuZHMgZm9yIGFsbCBjaGlsZHJlbiB0aGF0IHJldHVybiBib3VuZHMgdmlhIGdldEJvdW5kcy5cblx0ICogQG1ldGhvZCBnZXRUcmFuc2Zvcm1lZEJvdW5kc1xuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IEEgUmVjdGFuZ2xlIGluc3RhbmNlIHJlcHJlc2VudGluZyB0aGUgYm91bmRzLCBvciBudWxsIGlmIGJvdW5kcyBhcmUgbm90IGF2YWlsYWJsZSBmb3IgdGhpcyBvYmplY3QuXG5cdCAqKi9cblx0cC5nZXRUcmFuc2Zvcm1lZEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9nZXRCb3VuZHMoKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBbGxvd3MgeW91IHRvIG1hbnVhbGx5IHNwZWNpZnkgdGhlIGJvdW5kcyBvZiBhbiBvYmplY3QgdGhhdCBlaXRoZXIgY2Fubm90IGNhbGN1bGF0ZSB0aGVpciBvd24gYm91bmRzIChleC4gU2hhcGUgJlxuXHQgKiBUZXh0KSBmb3IgZnV0dXJlIHJlZmVyZW5jZSwgb3Igc28gdGhlIG9iamVjdCBjYW4gYmUgaW5jbHVkZWQgaW4gQ29udGFpbmVyIGJvdW5kcy4gTWFudWFsbHkgc2V0IGJvdW5kcyB3aWxsIGFsd2F5c1xuXHQgKiBvdmVycmlkZSBjYWxjdWxhdGVkIGJvdW5kcy5cblx0ICogXG5cdCAqIFRoZSBib3VuZHMgc2hvdWxkIGJlIHNwZWNpZmllZCBpbiB0aGUgb2JqZWN0J3MgbG9jYWwgKHVudHJhbnNmb3JtZWQpIGNvb3JkaW5hdGVzLiBGb3IgZXhhbXBsZSwgYSBTaGFwZSBpbnN0YW5jZVxuXHQgKiB3aXRoIGEgMjVweCByYWRpdXMgY2lyY2xlIGNlbnRlcmVkIGF0IDAsMCB3b3VsZCBoYXZlIGJvdW5kcyBvZiAoLTI1LCAtMjUsIDUwLCA1MCkuXG5cdCAqIEBtZXRob2Qgc2V0Qm91bmRzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IG9yaWdpbiBvZiB0aGUgYm91bmRzLiBQYXNzIG51bGwgdG8gcmVtb3ZlIHRoZSBtYW51YWwgYm91bmRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBvcmlnaW4gb2YgdGhlIGJvdW5kcy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgYm91bmRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGJvdW5kcy5cblx0ICoqL1xuXHRwLnNldEJvdW5kcyA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHRpZiAoeCA9PSBudWxsKSB7IHRoaXMuX2JvdW5kcyA9IHg7IH1cblx0XHR0aGlzLl9ib3VuZHMgPSAodGhpcy5fYm91bmRzIHx8IG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoKSkuc2V0VmFsdWVzKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBEaXNwbGF5T2JqZWN0LiBTb21lIHByb3BlcnRpZXMgdGhhdCBhcmUgc3BlY2lmaWMgdG8gdGhpcyBpbnN0YW5jZSdzIGN1cnJlbnQgY29udGV4dCBhcmVcblx0ICogcmV2ZXJ0ZWQgdG8gdGhlaXIgZGVmYXVsdHMgKGZvciBleGFtcGxlIC5wYXJlbnQpLiBDYWNoZXMgYXJlIG5vdCBtYWludGFpbmVkIGFjcm9zcyBjbG9uZXMsIGFuZCBzb21lIGVsZW1lbnRzXG5cdCAqIGFyZSBjb3BpZWQgYnkgcmVmZXJlbmNlIChtYXNrcywgaW5kaXZpZHVhbCBmaWx0ZXIgaW5zdGFuY2VzLCBoaXQgYXJlYSlcblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBBIGNsb25lIG9mIHRoZSBjdXJyZW50IERpc3BsYXlPYmplY3QgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZVByb3BzKG5ldyBEaXNwbGF5T2JqZWN0KCkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbRGlzcGxheU9iamVjdCAobmFtZT1cIisgIHRoaXMubmFtZSArXCIpXVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0Ly8gc2VwYXJhdGVkIHNvIGl0IGNhbiBiZSB1c2VkIG1vcmUgZWFzaWx5IGluIHN1YmNsYXNzZXM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9jbG9uZVByb3BzXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gbyBUaGUgRGlzcGxheU9iamVjdCBpbnN0YW5jZSB3aGljaCB3aWxsIGhhdmUgcHJvcGVydGllcyBmcm9tIHRoZSBjdXJyZW50IERpc3BsYXlPYmplY3Rcblx0ICogaW5zdGFuY2UgY29waWVkIGludG8uXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IG9cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2Nsb25lUHJvcHMgPSBmdW5jdGlvbihvKSB7XG5cdFx0by5hbHBoYSA9IHRoaXMuYWxwaGE7XG5cdFx0by5tb3VzZUVuYWJsZWQgPSB0aGlzLm1vdXNlRW5hYmxlZDtcblx0XHRvLnRpY2tFbmFibGVkID0gdGhpcy50aWNrRW5hYmxlZDtcblx0XHRvLm5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0by5yZWdYID0gdGhpcy5yZWdYO1xuXHRcdG8ucmVnWSA9IHRoaXMucmVnWTtcblx0XHRvLnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcblx0XHRvLnNjYWxlWCA9IHRoaXMuc2NhbGVYO1xuXHRcdG8uc2NhbGVZID0gdGhpcy5zY2FsZVk7XG5cdFx0by5zaGFkb3cgPSB0aGlzLnNoYWRvdztcblx0XHRvLnNrZXdYID0gdGhpcy5za2V3WDtcblx0XHRvLnNrZXdZID0gdGhpcy5za2V3WTtcblx0XHRvLnZpc2libGUgPSB0aGlzLnZpc2libGU7XG5cdFx0by54ICA9IHRoaXMueDtcblx0XHRvLnkgPSB0aGlzLnk7XG5cdFx0by5jb21wb3NpdGVPcGVyYXRpb24gPSB0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbjtcblx0XHRvLnNuYXBUb1BpeGVsID0gdGhpcy5zbmFwVG9QaXhlbDtcblx0XHRvLmZpbHRlcnMgPSB0aGlzLmZpbHRlcnM9PW51bGw/bnVsbDp0aGlzLmZpbHRlcnMuc2xpY2UoMCk7XG5cdFx0by5tYXNrID0gdGhpcy5tYXNrO1xuXHRcdG8uaGl0QXJlYSA9IHRoaXMuaGl0QXJlYTtcblx0XHRvLmN1cnNvciA9IHRoaXMuY3Vyc29yO1xuXHRcdG8uX2JvdW5kcyA9IHRoaXMuX2JvdW5kcztcblx0XHRyZXR1cm4gbztcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfYXBwbHlTaGFkb3dcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqIEBwYXJhbSB7U2hhZG93fSBzaGFkb3dcblx0ICoqL1xuXHRwLl9hcHBseVNoYWRvdyA9IGZ1bmN0aW9uKGN0eCwgc2hhZG93KSB7XG5cdFx0c2hhZG93ID0gc2hhZG93IHx8IFNoYWRvdy5pZGVudGl0eTtcblx0XHRjdHguc2hhZG93Q29sb3IgPSBzaGFkb3cuY29sb3I7XG5cdFx0Y3R4LnNoYWRvd09mZnNldFggPSBzaGFkb3cub2Zmc2V0WDtcblx0XHRjdHguc2hhZG93T2Zmc2V0WSA9IHNoYWRvdy5vZmZzZXRZO1xuXHRcdGN0eC5zaGFkb3dCbHVyID0gc2hhZG93LmJsdXI7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX3RpY2tcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2dE9iaiBBbiBldmVudCBvYmplY3QgdGhhdCB3aWxsIGJlIGRpc3BhdGNoZWQgdG8gYWxsIHRpY2sgbGlzdGVuZXJzLiBUaGlzIG9iamVjdCBpcyByZXVzZWQgYmV0d2VlbiBkaXNwYXRjaGVycyB0byByZWR1Y2UgY29uc3RydWN0aW9uICYgR0MgY29zdHMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl90aWNrID0gZnVuY3Rpb24oZXZ0T2JqKSB7XG5cdFx0Ly8gYmVjYXVzZSB0aWNrIGNhbiBiZSByZWFsbHkgcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLCBjaGVjayBmb3IgbGlzdGVuZXJzIGJlZm9yZSBjYWxsaW5nIGRpc3BhdGNoRXZlbnQuXG5cdFx0dmFyIGxzID0gdGhpcy5fbGlzdGVuZXJzO1xuXHRcdGlmIChscyAmJiBsc1tcInRpY2tcIl0pIHtcblx0XHRcdC8vIHJlc2V0ICYgcmV1c2UgdGhlIGV2ZW50IG9iamVjdCB0byBhdm9pZCBjb25zdHJ1Y3Rpb24gLyBHQyBjb3N0czpcblx0XHRcdGV2dE9iai50YXJnZXQgPSBudWxsO1xuXHRcdFx0ZXZ0T2JqLnByb3BhZ2F0aW9uU3RvcHBlZCA9IGV2dE9iai5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldnRPYmopO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfdGVzdEhpdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICoqL1xuXHRwLl90ZXN0SGl0ID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0dHJ5IHtcblx0XHRcdHZhciBoaXQgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGFbM10gPiAxO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGlmICghRGlzcGxheU9iamVjdC5zdXBwcmVzc0Nyb3NzRG9tYWluRXJyb3JzKSB7XG5cdFx0XHRcdHRocm93IFwiQW4gZXJyb3IgaGFzIG9jY3VycmVkLiBUaGlzIGlzIG1vc3QgbGlrZWx5IGR1ZSB0byBzZWN1cml0eSByZXN0cmljdGlvbnMgb24gcmVhZGluZyBjYW52YXMgcGl4ZWwgZGF0YSB3aXRoIGxvY2FsIG9yIGNyb3NzLWRvbWFpbiBpbWFnZXMuXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBoaXQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2FwcGx5RmlsdGVyc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fYXBwbHlGaWx0ZXJzID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmZpbHRlcnMgfHwgdGhpcy5maWx0ZXJzLmxlbmd0aCA9PSAwIHx8ICF0aGlzLmNhY2hlQ2FudmFzKSB7IHJldHVybjsgfVxuXHRcdHZhciBsID0gdGhpcy5maWx0ZXJzLmxlbmd0aDtcblx0XHR2YXIgY3R4ID0gdGhpcy5jYWNoZUNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0dmFyIHcgPSB0aGlzLmNhY2hlQ2FudmFzLndpZHRoO1xuXHRcdHZhciBoID0gdGhpcy5jYWNoZUNhbnZhcy5oZWlnaHQ7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykge1xuXHRcdFx0dGhpcy5maWx0ZXJzW2ldLmFwcGx5RmlsdGVyKGN0eCwgMCwgMCwgdywgaCk7XG5cdFx0fVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldEZpbHRlckJvdW5kc1xuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9nZXRGaWx0ZXJCb3VuZHMgPSBmdW5jdGlvbihyZWN0KSB7XG5cdFx0dmFyIGwsIGZpbHRlcnMgPSB0aGlzLmZpbHRlcnMsIGJvdW5kcyA9IHRoaXMuX3JlY3RhbmdsZS5zZXRWYWx1ZXMoMCwwLDAsMCk7XG5cdFx0aWYgKCFmaWx0ZXJzIHx8ICEobD1maWx0ZXJzLmxlbmd0aCkpIHsgcmV0dXJuIGJvdW5kczsgfVxuXHRcdFxuXHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKyspIHtcblx0XHRcdHZhciBmID0gdGhpcy5maWx0ZXJzW2ldO1xuXHRcdFx0Zi5nZXRCb3VuZHMmJmYuZ2V0Qm91bmRzKGJvdW5kcyk7XG5cdFx0fVxuXHRcdHJldHVybiBib3VuZHM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0Qm91bmRzXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZVRyYW5zZm9ybSBJZiB0cnVlLCBkb2VzIG5vdCBhcHBseSB0aGlzIG9iamVjdCdzIHRyYW5zZm9ybS5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ2V0Qm91bmRzID0gZnVuY3Rpb24obWF0cml4LCBpZ25vcmVUcmFuc2Zvcm0pe1xuXHRcdHJldHVybiB0aGlzLl90cmFuc2Zvcm1Cb3VuZHModGhpcy5nZXRCb3VuZHMoKSwgbWF0cml4LCBpZ25vcmVUcmFuc2Zvcm0pO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX3RyYW5zZm9ybUJvdW5kc1xuXHQgKiBAcGFyYW0ge1JlY3RhbmdsZX0gYm91bmRzXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZVRyYW5zZm9ybVxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl90cmFuc2Zvcm1Cb3VuZHMgPSBmdW5jdGlvbihib3VuZHMsIG1hdHJpeCwgaWdub3JlVHJhbnNmb3JtKSB7XG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGJvdW5kczsgfVxuXHRcdHZhciB4ID0gYm91bmRzLngsIHkgPSBib3VuZHMueSwgd2lkdGggPSBib3VuZHMud2lkdGgsIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQsIG10eCA9IHRoaXMuX3Byb3BzLm1hdHJpeDtcblx0XHRtdHggPSBpZ25vcmVUcmFuc2Zvcm0gPyBtdHguaWRlbnRpdHkoKSA6IHRoaXMuZ2V0TWF0cml4KG10eCk7XG5cdFx0XG5cdFx0aWYgKHggfHwgeSkgeyBtdHguYXBwZW5kVHJhbnNmb3JtKDAsMCwxLDEsMCwwLDAsLXgsLXkpOyB9IC8vIFRPRE86IHNpbXBsaWZ5IHRoaXMuXG5cdFx0aWYgKG1hdHJpeCkgeyBtdHgucHJlcGVuZE1hdHJpeChtYXRyaXgpOyB9XG5cdFx0XG5cdFx0dmFyIHhfYSA9IHdpZHRoKm10eC5hLCB4X2IgPSB3aWR0aCptdHguYjtcblx0XHR2YXIgeV9jID0gaGVpZ2h0Km10eC5jLCB5X2QgPSBoZWlnaHQqbXR4LmQ7XG5cdFx0dmFyIHR4ID0gbXR4LnR4LCB0eSA9IG10eC50eTtcblx0XHRcblx0XHR2YXIgbWluWCA9IHR4LCBtYXhYID0gdHgsIG1pblkgPSB0eSwgbWF4WSA9IHR5O1xuXG5cdFx0aWYgKCh4ID0geF9hICsgdHgpIDwgbWluWCkgeyBtaW5YID0geDsgfSBlbHNlIGlmICh4ID4gbWF4WCkgeyBtYXhYID0geDsgfVxuXHRcdGlmICgoeCA9IHhfYSArIHlfYyArIHR4KSA8IG1pblgpIHsgbWluWCA9IHg7IH0gZWxzZSBpZiAoeCA+IG1heFgpIHsgbWF4WCA9IHg7IH1cblx0XHRpZiAoKHggPSB5X2MgKyB0eCkgPCBtaW5YKSB7IG1pblggPSB4OyB9IGVsc2UgaWYgKHggPiBtYXhYKSB7IG1heFggPSB4OyB9XG5cdFx0XG5cdFx0aWYgKCh5ID0geF9iICsgdHkpIDwgbWluWSkgeyBtaW5ZID0geTsgfSBlbHNlIGlmICh5ID4gbWF4WSkgeyBtYXhZID0geTsgfVxuXHRcdGlmICgoeSA9IHhfYiArIHlfZCArIHR5KSA8IG1pblkpIHsgbWluWSA9IHk7IH0gZWxzZSBpZiAoeSA+IG1heFkpIHsgbWF4WSA9IHk7IH1cblx0XHRpZiAoKHkgPSB5X2QgKyB0eSkgPCBtaW5ZKSB7IG1pblkgPSB5OyB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7IG1heFkgPSB5OyB9XG5cdFx0XG5cdFx0cmV0dXJuIGJvdW5kcy5zZXRWYWx1ZXMobWluWCwgbWluWSwgbWF4WC1taW5YLCBtYXhZLW1pblkpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCBoYXMgYW55IG1vdXNlIGV2ZW50IGxpc3RlbmVycyBvciBhIGN1cnNvci5cblx0ICogQG1ldGhvZCBfaXNNb3VzZU9wYXF1ZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5faGFzTW91c2VFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGV2dHMgPSBEaXNwbGF5T2JqZWN0Ll9NT1VTRV9FVkVOVFM7XG5cdFx0Zm9yICh2YXIgaT0gMCwgbD1ldnRzLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLmhhc0V2ZW50TGlzdGVuZXIoZXZ0c1tpXSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHR9XG5cdFx0cmV0dXJuICEhdGhpcy5jdXJzb3I7XG5cdH07XG5cblx0Y3JlYXRlanMuRGlzcGxheU9iamVjdCA9IGNyZWF0ZWpzLnByb21vdGUoRGlzcGxheU9iamVjdCwgXCJFdmVudERpc3BhdGNoZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQ29udGFpbmVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRcblxuLy8gY29uc3RydWN0b3I6XG4vKipcbiAqIEEgQ29udGFpbmVyIGlzIGEgbmVzdGFibGUgZGlzcGxheSBsaXN0IHRoYXQgYWxsb3dzIHlvdSB0byB3b3JrIHdpdGggY29tcG91bmQgZGlzcGxheSBlbGVtZW50cy4gRm9yICBleGFtcGxlIHlvdSBjb3VsZFxuICogZ3JvdXAgYXJtLCBsZWcsIHRvcnNvIGFuZCBoZWFkIHt7I2Nyb3NzTGluayBcIkJpdG1hcFwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZXMgdG9nZXRoZXIgaW50byBhIFBlcnNvbiBDb250YWluZXIsIGFuZFxuICogdHJhbnNmb3JtIHRoZW0gYXMgYSBncm91cCwgd2hpbGUgc3RpbGwgYmVpbmcgYWJsZSB0byBtb3ZlIHRoZSBpbmRpdmlkdWFsIHBhcnRzIHJlbGF0aXZlIHRvIGVhY2ggb3RoZXIuIENoaWxkcmVuIG9mXG4gKiBjb250YWluZXJzIGhhdmUgdGhlaXIgPGNvZGU+dHJhbnNmb3JtPC9jb2RlPiBhbmQgPGNvZGU+YWxwaGE8L2NvZGU+IHByb3BlcnRpZXMgY29uY2F0ZW5hdGVkIHdpdGggdGhlaXIgcGFyZW50XG4gKiBDb250YWluZXIuXG4gKlxuICogRm9yIGV4YW1wbGUsIGEge3sjY3Jvc3NMaW5rIFwiU2hhcGVcIn19e3svY3Jvc3NMaW5rfX0gd2l0aCB4PTEwMCBhbmQgYWxwaGE9MC41LCBwbGFjZWQgaW4gYSBDb250YWluZXIgd2l0aCA8Y29kZT54PTUwPC9jb2RlPlxuICogYW5kIDxjb2RlPmFscGhhPTAuNzwvY29kZT4gd2lsbCBiZSByZW5kZXJlZCB0byB0aGUgY2FudmFzIGF0IDxjb2RlPng9MTUwPC9jb2RlPiBhbmQgPGNvZGU+YWxwaGE9MC4zNTwvY29kZT4uXG4gKiBDb250YWluZXJzIGhhdmUgc29tZSBvdmVyaGVhZCwgc28geW91IGdlbmVyYWxseSBzaG91bGRuJ3QgY3JlYXRlIGEgQ29udGFpbmVyIHRvIGhvbGQgYSBzaW5nbGUgY2hpbGQuXG4gKlxuICogPGg0PkV4YW1wbGU8L2g0PlxuICpcbiAqICAgICAgdmFyIGNvbnRhaW5lciA9IG5ldyBjcmVhdGVqcy5Db250YWluZXIoKTtcbiAqICAgICAgY29udGFpbmVyLmFkZENoaWxkKGJpdG1hcEluc3RhbmNlLCBzaGFwZUluc3RhbmNlKTtcbiAqICAgICAgY29udGFpbmVyLnggPSAxMDA7XG4gKlxuICogQGNsYXNzIENvbnRhaW5lclxuICogQGV4dGVuZHMgRGlzcGxheU9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKiovXG5cdGZ1bmN0aW9uIENvbnRhaW5lcigpIHtcblx0XHR0aGlzLkRpc3BsYXlPYmplY3RfY29uc3RydWN0b3IoKTtcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIGFycmF5IG9mIGNoaWxkcmVuIGluIHRoZSBkaXNwbGF5IGxpc3QuIFlvdSBzaG91bGQgdXN1YWxseSB1c2UgdGhlIGNoaWxkIG1hbmFnZW1lbnQgbWV0aG9kcyBzdWNoIGFzXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyL2FkZENoaWxkXCJ9fXt7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvcmVtb3ZlQ2hpbGRcIn19e3svY3Jvc3NMaW5rfX0sXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyL3N3YXBDaGlsZHJlblwifX17ey9jcm9zc0xpbmt9fSwgZXRjLCByYXRoZXIgdGhhbiBhY2Nlc3NpbmcgdGhpcyBkaXJlY3RseSwgYnV0IGl0IGlzXG5cdFx0ICogaW5jbHVkZWQgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdFx0ICogQHByb3BlcnR5IGNoaWxkcmVuXG5cdFx0ICogQHR5cGUgQXJyYXlcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMuY2hpbGRyZW4gPSBbXTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY2hpbGRyZW4gb2YgdGhpcyBjb250YWluZXIgYXJlIGluZGVwZW5kZW50bHkgZW5hYmxlZCBmb3IgbW91c2UvcG9pbnRlciBpbnRlcmFjdGlvbi5cblx0XHQgKiBJZiBmYWxzZSwgdGhlIGNoaWxkcmVuIHdpbGwgYmUgYWdncmVnYXRlZCB1bmRlciB0aGUgY29udGFpbmVyIC0gZm9yIGV4YW1wbGUsIGEgY2xpY2sgb24gYSBjaGlsZCBzaGFwZSB3b3VsZFxuXHRcdCAqIHRyaWdnZXIgYSBjbGljayBldmVudCBvbiB0aGUgY29udGFpbmVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBtb3VzZUNoaWxkcmVuXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKiovXG5cdFx0dGhpcy5tb3VzZUNoaWxkcmVuID0gdHJ1ZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBJZiBmYWxzZSwgdGhlIHRpY2sgd2lsbCBub3QgYmUgcHJvcGFnYXRlZCB0byBjaGlsZHJlbiBvZiB0aGlzIENvbnRhaW5lci4gVGhpcyBjYW4gcHJvdmlkZSBzb21lIHBlcmZvcm1hbmNlIGJlbmVmaXRzLlxuXHRcdCAqIEluIGFkZGl0aW9uIHRvIHByZXZlbnRpbmcgdGhlIFwidGlja1wiIGV2ZW50IGZyb20gYmVpbmcgZGlzcGF0Y2hlZCwgaXQgd2lsbCBhbHNvIHByZXZlbnQgdGljayByZWxhdGVkIHVwZGF0ZXNcblx0XHQgKiBvbiBzb21lIGRpc3BsYXkgb2JqZWN0cyAoZXguIFNwcml0ZSAmIE1vdmllQ2xpcCBmcmFtZSBhZHZhbmNpbmcsIERPTUVsZW1lbnQgdmlzaWJpbGl0eSBoYW5kbGluZykuXG5cdFx0ICogQHByb3BlcnR5IHRpY2tDaGlsZHJlblxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICoqL1xuXHRcdHRoaXMudGlja0NoaWxkcmVuID0gdHJ1ZTtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChDb250YWluZXIsIGNyZWF0ZWpzLkRpc3BsYXlPYmplY3QpO1xuXHRcblx0XG4vLyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvbnVtQ2hpbGRyZW46cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXROdW1DaGlsZHJlblxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0cC5nZXROdW1DaGlsZHJlbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoZSBjb250YWluZXIuXG5cdCAqIEBwcm9wZXJ0eSBudW1DaGlsZHJlblxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcblx0XHRcdG51bUNoaWxkcmVuOiB7IGdldDogcC5nZXROdW1DaGlsZHJlbiB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHt9XG5cdFxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIENvbnN0cnVjdG9yIGFsaWFzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gVGhpcyBtZXRob2Qgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucy5cblx0ICogU3ViY2xhc3NlcyBzaG91bGQgYmUgdXBkYXRlZCB0byB1c2Uge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZHNcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2YgYGNyZWF0ZWpzLnByb21vdGUoKWBcblx0ICoqL1xuXHRwLmluaXRpYWxpemUgPSBDb250YWluZXI7IC8vIFRPRE86IGRlcHJlY2F0ZWQuXG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhcy5cblx0ICogVGhpcyBkb2VzIG5vdCBhY2NvdW50IGZvciB3aGV0aGVyIGl0IHdvdWxkIGJlIHZpc2libGUgd2l0aGluIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBzdGFnZS5cblx0ICpcblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGlzVmlzaWJsZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhc1xuXHQgKiovXG5cdHAuaXNWaXNpYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhhc0NvbnRlbnQgPSB0aGlzLmNhY2hlQ2FudmFzIHx8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuXHRcdHJldHVybiAhISh0aGlzLnZpc2libGUgJiYgdGhpcy5hbHBoYSA+IDAgJiYgdGhpcy5zY2FsZVggIT0gMCAmJiB0aGlzLnNjYWxlWSAhPSAwICYmIGhhc0NvbnRlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyB0aGUgZGlzcGxheSBvYmplY3QgaW50byB0aGUgc3BlY2lmaWVkIGNvbnRleHQgaWdub3JpbmcgaXRzIHZpc2libGUsIGFscGhhLCBzaGFkb3csIGFuZCB0cmFuc2Zvcm0uXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZHJhdyB3YXMgaGFuZGxlZCAodXNlZnVsIGZvciBvdmVycmlkaW5nIGZ1bmN0aW9uYWxpdHkpLlxuXHQgKlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgZHJhd1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtpZ25vcmVDYWNoZT1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRyYXcgb3BlcmF0aW9uIHNob3VsZCBpZ25vcmUgYW55IGN1cnJlbnQgY2FjaGUuXG5cdCAqIEZvciBleGFtcGxlLCB1c2VkIGZvciBkcmF3aW5nIHRoZSBjYWNoZSAodG8gcHJldmVudCBpdCBmcm9tIHNpbXBseSBkcmF3aW5nIGFuIGV4aXN0aW5nIGNhY2hlIGJhY2tcblx0ICogaW50byBpdHNlbGYpLlxuXHQgKiovXG5cdHAuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgaWdub3JlQ2FjaGUpIHtcblx0XHRpZiAodGhpcy5EaXNwbGF5T2JqZWN0X2RyYXcoY3R4LCBpZ25vcmVDYWNoZSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcblx0XHQvLyB0aGlzIGVuc3VyZXMgd2UgZG9uJ3QgaGF2ZSBpc3N1ZXMgd2l0aCBkaXNwbGF5IGxpc3QgY2hhbmdlcyB0aGF0IG9jY3VyIGR1cmluZyBhIGRyYXc6XG5cdFx0dmFyIGxpc3QgPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XG5cdFx0Zm9yICh2YXIgaT0wLGw9bGlzdC5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSBsaXN0W2ldO1xuXHRcdFx0aWYgKCFjaGlsZC5pc1Zpc2libGUoKSkgeyBjb250aW51ZTsgfVxuXHRcdFx0XG5cdFx0XHQvLyBkcmF3IHRoZSBjaGlsZDpcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjaGlsZC51cGRhdGVDb250ZXh0KGN0eCk7XG5cdFx0XHRjaGlsZC5kcmF3KGN0eCk7XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBZGRzIGEgY2hpbGQgdG8gdGhlIHRvcCBvZiB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqIFx0XHRjb250YWluZXIuYWRkQ2hpbGQoYml0bWFwSW5zdGFuY2UpO1xuXHQgKlxuXHQgKiBZb3UgY2FuIGFsc28gYWRkIG11bHRpcGxlIGNoaWxkcmVuIGF0IG9uY2U6XG5cdCAqXG5cdCAqIFx0XHRjb250YWluZXIuYWRkQ2hpbGQoYml0bWFwSW5zdGFuY2UsIHNoYXBlSW5zdGFuY2UsIHRleHRJbnN0YW5jZSk7XG5cdCAqXG5cdCAqIEBtZXRob2QgYWRkQ2hpbGRcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBjaGlsZCBUaGUgZGlzcGxheSBvYmplY3QgdG8gYWRkLlxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgdGhhdCB3YXMgYWRkZWQsIG9yIHRoZSBsYXN0IGNoaWxkIGlmIG11bHRpcGxlIGNoaWxkcmVuIHdlcmUgYWRkZWQuXG5cdCAqKi9cblx0cC5hZGRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG5cdFx0aWYgKGNoaWxkID09IG51bGwpIHsgcmV0dXJuIGNoaWxkOyB9XG5cdFx0dmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdGlmIChsID4gMSkge1xuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykgeyB0aGlzLmFkZENoaWxkKGFyZ3VtZW50c1tpXSk7IH1cblx0XHRcdHJldHVybiBhcmd1bWVudHNbbC0xXTtcblx0XHR9XG5cdFx0aWYgKGNoaWxkLnBhcmVudCkgeyBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpOyB9XG5cdFx0Y2hpbGQucGFyZW50ID0gdGhpcztcblx0XHR0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuXHRcdGNoaWxkLmRpc3BhdGNoRXZlbnQoXCJhZGRlZFwiKTtcblx0XHRyZXR1cm4gY2hpbGQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBjaGlsZCB0byB0aGUgZGlzcGxheSBsaXN0IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXgsIGJ1bXBpbmcgY2hpbGRyZW4gYXQgZXF1YWwgb3IgZ3JlYXRlciBpbmRleGVzIHVwIG9uZSwgYW5kXG5cdCAqIHNldHRpbmcgaXRzIHBhcmVudCB0byB0aGlzIENvbnRhaW5lci5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGFkZENoaWxkQXQoY2hpbGQxLCBpbmRleCk7XG5cdCAqXG5cdCAqIFlvdSBjYW4gYWxzbyBhZGQgbXVsdGlwbGUgY2hpbGRyZW4sIHN1Y2ggYXM6XG5cdCAqXG5cdCAqICAgICAgYWRkQ2hpbGRBdChjaGlsZDEsIGNoaWxkMiwgLi4uLCBpbmRleCk7XG5cdCAqXG5cdCAqIFRoZSBpbmRleCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgbnVtQ2hpbGRyZW4uIEZvciBleGFtcGxlLCB0byBhZGQgbXlTaGFwZSB1bmRlciBvdGhlclNoYXBlIGluIHRoZSBkaXNwbGF5IGxpc3QsXG5cdCAqIHlvdSBjb3VsZCB1c2U6XG5cdCAqXG5cdCAqICAgICAgY29udGFpbmVyLmFkZENoaWxkQXQobXlTaGFwZSwgY29udGFpbmVyLmdldENoaWxkSW5kZXgob3RoZXJTaGFwZSkpO1xuXHQgKlxuXHQgKiBUaGlzIHdvdWxkIGFsc28gYnVtcCBvdGhlclNoYXBlJ3MgaW5kZXggdXAgYnkgb25lLiBGYWlscyBzaWxlbnRseSBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGFkZENoaWxkQXRcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBjaGlsZCBUaGUgZGlzcGxheSBvYmplY3QgdG8gYWRkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIGFkZCB0aGUgY2hpbGQgYXQuXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IFJldHVybnMgdGhlIGxhc3QgY2hpbGQgdGhhdCB3YXMgYWRkZWQsIG9yIHRoZSBsYXN0IGNoaWxkIGlmIG11bHRpcGxlIGNoaWxkcmVuIHdlcmUgYWRkZWQuXG5cdCAqKi9cblx0cC5hZGRDaGlsZEF0ID0gZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XG5cdFx0dmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdHZhciBpbmR4ID0gYXJndW1lbnRzW2wtMV07IC8vIGNhbid0IHVzZSB0aGUgc2FtZSBuYW1lIGFzIHRoZSBpbmRleCBwYXJhbSBvciBpdCByZXBsYWNlcyBhcmd1bWVudHNbMV1cblx0XHRpZiAoaW5keCA8IDAgfHwgaW5keCA+IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7IHJldHVybiBhcmd1bWVudHNbbC0yXTsgfVxuXHRcdGlmIChsID4gMikge1xuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGwtMTsgaSsrKSB7IHRoaXMuYWRkQ2hpbGRBdChhcmd1bWVudHNbaV0sIGluZHgraSk7IH1cblx0XHRcdHJldHVybiBhcmd1bWVudHNbbC0yXTtcblx0XHR9XG5cdFx0aWYgKGNoaWxkLnBhcmVudCkgeyBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpOyB9XG5cdFx0Y2hpbGQucGFyZW50ID0gdGhpcztcblx0XHR0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xuXHRcdGNoaWxkLmRpc3BhdGNoRXZlbnQoXCJhZGRlZFwiKTtcblx0XHRyZXR1cm4gY2hpbGQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBjaGlsZCBmcm9tIHRoZSBkaXNwbGF5IGxpc3QuIE5vdGUgdGhhdCBpdCBpcyBmYXN0ZXIgdG8gdXNlIHJlbW92ZUNoaWxkQXQoKSBpZiB0aGUgaW5kZXggaXNcblx0ICogYWxyZWFkeSBrbm93bi5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjaGlsZCk7XG5cdCAqXG5cdCAqIFlvdSBjYW4gYWxzbyByZW1vdmUgbXVsdGlwbGUgY2hpbGRyZW46XG5cdCAqXG5cdCAqICAgICAgcmVtb3ZlQ2hpbGQoY2hpbGQxLCBjaGlsZDIsIC4uLik7XG5cdCAqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2hpbGQgKG9yIGNoaWxkcmVuKSB3YXMgcmVtb3ZlZCwgb3IgZmFsc2UgaWYgaXQgd2FzIG5vdCBpbiB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKiBAbWV0aG9kIHJlbW92ZUNoaWxkXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gY2hpbGQgVGhlIGNoaWxkIHRvIHJlbW92ZS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2hpbGQgKG9yIGNoaWxkcmVuKSB3YXMgcmVtb3ZlZCwgb3IgZmFsc2UgaWYgaXQgd2FzIG5vdCBpbiB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKiovXG5cdHAucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbihjaGlsZCkge1xuXHRcdHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRpZiAobCA+IDEpIHtcblx0XHRcdHZhciBnb29kID0gdHJ1ZTtcblx0XHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKyspIHsgZ29vZCA9IGdvb2QgJiYgdGhpcy5yZW1vdmVDaGlsZChhcmd1bWVudHNbaV0pOyB9XG5cdFx0XHRyZXR1cm4gZ29vZDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlQ2hpbGRBdChjcmVhdGVqcy5pbmRleE9mKHRoaXMuY2hpbGRyZW4sIGNoaWxkKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIGNoaWxkIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggZnJvbSB0aGUgZGlzcGxheSBsaXN0LCBhbmQgc2V0cyBpdHMgcGFyZW50IHRvIG51bGwuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGRBdCgyKTtcblx0ICpcblx0ICogWW91IGNhbiBhbHNvIHJlbW92ZSBtdWx0aXBsZSBjaGlsZHJlbjpcblx0ICpcblx0ICogICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoMiwgNywgLi4uKVxuXHQgKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNoaWxkIChvciBjaGlsZHJlbikgd2FzIHJlbW92ZWQsIG9yIGZhbHNlIGlmIGFueSBpbmRleCB3YXMgb3V0IG9mIHJhbmdlLlxuXHQgKiBAbWV0aG9kIHJlbW92ZUNoaWxkQXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgY2hpbGQgdG8gcmVtb3ZlLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBjaGlsZCAob3IgY2hpbGRyZW4pIHdhcyByZW1vdmVkLCBvciBmYWxzZSBpZiBhbnkgaW5kZXggd2FzIG91dCBvZiByYW5nZS5cblx0ICoqL1xuXHRwLnJlbW92ZUNoaWxkQXQgPSBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRpZiAobCA+IDEpIHtcblx0XHRcdHZhciBhID0gW107XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7IGFbaV0gPSBhcmd1bWVudHNbaV07IH1cblx0XHRcdGEuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBiLWE7IH0pO1xuXHRcdFx0dmFyIGdvb2QgPSB0cnVlO1xuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykgeyBnb29kID0gZ29vZCAmJiB0aGlzLnJlbW92ZUNoaWxkQXQoYVtpXSk7IH1cblx0XHRcdHJldHVybiBnb29kO1xuXHRcdH1cblx0XHRpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGhpcy5jaGlsZHJlbi5sZW5ndGgtMSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2luZGV4XTtcblx0XHRpZiAoY2hpbGQpIHsgY2hpbGQucGFyZW50ID0gbnVsbDsgfVxuXHRcdHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcblx0XHRjaGlsZC5kaXNwYXRjaEV2ZW50KFwicmVtb3ZlZFwiKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwgY2hpbGRyZW4gZnJvbSB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqIFx0Y29udGFpbmVyLnJlbW92ZUFsbENoaWxkcmVuKCk7XG5cdCAqXG5cdCAqIEBtZXRob2QgcmVtb3ZlQWxsQ2hpbGRyZW5cblx0ICoqL1xuXHRwLnJlbW92ZUFsbENoaWxkcmVuID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGtpZHMgPSB0aGlzLmNoaWxkcmVuO1xuXHRcdHdoaWxlIChraWRzLmxlbmd0aCkgeyB0aGlzLnJlbW92ZUNoaWxkQXQoMCk7IH1cblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY2hpbGQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNvbnRhaW5lci5nZXRDaGlsZEF0KDIpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIGdldENoaWxkQXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgY2hpbGQgdG8gcmV0dXJuLlxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC4gUmV0dXJucyBudWxsIGlmIHRoZXJlIGlzIG5vIGNoaWxkIGF0IHRoZSBpbmRleC5cblx0ICoqL1xuXHRwLmdldENoaWxkQXQgPSBmdW5jdGlvbihpbmRleCkge1xuXHRcdHJldHVybiB0aGlzLmNoaWxkcmVuW2luZGV4XTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjaGlsZCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cblx0ICogQG1ldGhvZCBnZXRDaGlsZEJ5TmFtZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY2hpbGQgdG8gcmV0dXJuLlxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXG5cdCAqKi9cblx0cC5nZXRDaGlsZEJ5TmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR2YXIga2lkcyA9IHRoaXMuY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaT0wLGw9a2lkcy5sZW5ndGg7aTxsO2krKykge1xuXHRcdFx0aWYoa2lkc1tpXS5uYW1lID09IG5hbWUpIHsgcmV0dXJuIGtpZHNbaV07IH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBlcmZvcm1zIGFuIGFycmF5IHNvcnQgb3BlcmF0aW9uIG9uIHRoZSBjaGlsZCBsaXN0LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTogRGlzcGxheSBjaGlsZHJlbiB3aXRoIGEgaGlnaGVyIHkgaW4gZnJvbnQuPC9oND5cblx0ICogXG5cdCAqICAgICAgdmFyIHNvcnRGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iajEsIG9iajIsIG9wdGlvbnMpIHtcblx0ICogICAgICAgICAgaWYgKG9iajEueSA+IG9iajIueSkgeyByZXR1cm4gMTsgfVxuXHQgKiAgICAgICAgICBpZiAob2JqMS55IDwgb2JqMi55KSB7IHJldHVybiAtMTsgfVxuXHQgKiAgICAgICAgICByZXR1cm4gMDtcblx0ICogICAgICB9XG5cdCAqICAgICAgY29udGFpbmVyLnNvcnRDaGlsZHJlbihzb3J0RnVuY3Rpb24pO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHNvcnRDaGlsZHJlblxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzb3J0RnVuY3Rpb24gdGhlIGZ1bmN0aW9uIHRvIHVzZSB0byBzb3J0IHRoZSBjaGlsZCBsaXN0LiBTZWUgSmF2YVNjcmlwdCdzIDxjb2RlPkFycmF5LnNvcnQ8L2NvZGU+XG5cdCAqIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuXG5cdCAqKi9cblx0cC5zb3J0Q2hpbGRyZW4gPSBmdW5jdGlvbihzb3J0RnVuY3Rpb24pIHtcblx0XHR0aGlzLmNoaWxkcmVuLnNvcnQoc29ydEZ1bmN0aW9uKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIHNwZWNpZmllZCBjaGlsZCBpbiB0aGUgZGlzcGxheSBsaXN0LCBvciAtMSBpZiBpdCBpcyBub3QgaW4gdGhlIGRpc3BsYXkgbGlzdC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBpbmRleCA9IGNvbnRhaW5lci5nZXRDaGlsZEluZGV4KGNoaWxkKTtcblx0ICpcblx0ICogQG1ldGhvZCBnZXRDaGlsZEluZGV4XG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gY2hpbGQgVGhlIGNoaWxkIHRvIHJldHVybiB0aGUgaW5kZXggb2YuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBzcGVjaWZpZWQgY2hpbGQuIC0xIGlmIHRoZSBjaGlsZCBpcyBub3QgZm91bmQuXG5cdCAqKi9cblx0cC5nZXRDaGlsZEluZGV4ID0gZnVuY3Rpb24oY2hpbGQpIHtcblx0XHRyZXR1cm4gY3JlYXRlanMuaW5kZXhPZih0aGlzLmNoaWxkcmVuLCBjaGlsZCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU3dhcHMgdGhlIGNoaWxkcmVuIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlcy4gRmFpbHMgc2lsZW50bHkgaWYgZWl0aGVyIGluZGV4IGlzIG91dCBvZiByYW5nZS5cblx0ICogQG1ldGhvZCBzd2FwQ2hpbGRyZW5BdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXgxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleDJcblx0ICoqL1xuXHRwLnN3YXBDaGlsZHJlbkF0ID0gZnVuY3Rpb24oaW5kZXgxLCBpbmRleDIpIHtcblx0XHR2YXIga2lkcyA9IHRoaXMuY2hpbGRyZW47XG5cdFx0dmFyIG8xID0ga2lkc1tpbmRleDFdO1xuXHRcdHZhciBvMiA9IGtpZHNbaW5kZXgyXTtcblx0XHRpZiAoIW8xIHx8ICFvMikgeyByZXR1cm47IH1cblx0XHRraWRzW2luZGV4MV0gPSBvMjtcblx0XHRraWRzW2luZGV4Ml0gPSBvMTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBTd2FwcyB0aGUgc3BlY2lmaWVkIGNoaWxkcmVuJ3MgZGVwdGggaW4gdGhlIGRpc3BsYXkgbGlzdC4gRmFpbHMgc2lsZW50bHkgaWYgZWl0aGVyIGNoaWxkIGlzIG5vdCBhIGNoaWxkIG9mIHRoaXNcblx0ICogQ29udGFpbmVyLlxuXHQgKiBAbWV0aG9kIHN3YXBDaGlsZHJlblxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IGNoaWxkMVxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IGNoaWxkMlxuXHQgKiovXG5cdHAuc3dhcENoaWxkcmVuID0gZnVuY3Rpb24oY2hpbGQxLCBjaGlsZDIpIHtcblx0XHR2YXIga2lkcyA9IHRoaXMuY2hpbGRyZW47XG5cdFx0dmFyIGluZGV4MSxpbmRleDI7XG5cdFx0Zm9yICh2YXIgaT0wLGw9a2lkcy5sZW5ndGg7aTxsO2krKykge1xuXHRcdFx0aWYgKGtpZHNbaV0gPT0gY2hpbGQxKSB7IGluZGV4MSA9IGk7IH1cblx0XHRcdGlmIChraWRzW2ldID09IGNoaWxkMikgeyBpbmRleDIgPSBpOyB9XG5cdFx0XHRpZiAoaW5kZXgxICE9IG51bGwgJiYgaW5kZXgyICE9IG51bGwpIHsgYnJlYWs7IH1cblx0XHR9XG5cdFx0aWYgKGk9PWwpIHsgcmV0dXJuOyB9IC8vIFRPRE86IHRocm93IGVycm9yP1xuXHRcdGtpZHNbaW5kZXgxXSA9IGNoaWxkMjtcblx0XHRraWRzW2luZGV4Ml0gPSBjaGlsZDE7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2hhbmdlcyB0aGUgZGVwdGggb2YgdGhlIHNwZWNpZmllZCBjaGlsZC4gRmFpbHMgc2lsZW50bHkgaWYgdGhlIGNoaWxkIGlzIG5vdCBhIGNoaWxkIG9mIHRoaXMgY29udGFpbmVyLCBvciB0aGUgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IGNoaWxkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAgXG5cdCAqIEBtZXRob2Qgc2V0Q2hpbGRJbmRleFxuXHQgKiovXG5cdHAuc2V0Q2hpbGRJbmRleCA9IGZ1bmN0aW9uKGNoaWxkLCBpbmRleCkge1xuXHRcdHZhciBraWRzID0gdGhpcy5jaGlsZHJlbiwgbD1raWRzLmxlbmd0aDtcblx0XHRpZiAoY2hpbGQucGFyZW50ICE9IHRoaXMgfHwgaW5kZXggPCAwIHx8IGluZGV4ID49IGwpIHsgcmV0dXJuOyB9XG5cdFx0Zm9yICh2YXIgaT0wO2k8bDtpKyspIHtcblx0XHRcdGlmIChraWRzW2ldID09IGNoaWxkKSB7IGJyZWFrOyB9XG5cdFx0fVxuXHRcdGlmIChpPT1sIHx8IGkgPT0gaW5kZXgpIHsgcmV0dXJuOyB9XG5cdFx0a2lkcy5zcGxpY2UoaSwxKTtcblx0XHRraWRzLnNwbGljZShpbmRleCwwLGNoaWxkKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgZGlzcGxheSBvYmplY3QgZWl0aGVyIGlzIHRoaXMgY29udGFpbmVyIG9yIGlzIGEgZGVzY2VuZGVudCAoY2hpbGQsIGdyYW5kY2hpbGQsIGV0Yylcblx0ICogb2YgdGhpcyBjb250YWluZXIuXG5cdCAqIEBtZXRob2QgY29udGFpbnNcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBjaGlsZCBUaGUgRGlzcGxheU9iamVjdCB0byBiZSBjaGVja2VkLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgZGlzcGxheSBvYmplY3QgZWl0aGVyIGlzIHRoaXMgY29udGFpbmVyIG9yIGlzIGEgZGVzY2VuZGVudC5cblx0ICoqL1xuXHRwLmNvbnRhaW5zID0gZnVuY3Rpb24oY2hpbGQpIHtcblx0XHR3aGlsZSAoY2hpbGQpIHtcblx0XHRcdGlmIChjaGlsZCA9PSB0aGlzKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XHRjaGlsZCA9IGNoaWxkLnBhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUZXN0cyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRlcnNlY3RzIHRoZSBzcGVjaWZpZWQgbG9jYWwgcG9pbnQgKGllLiBkcmF3cyBhIHBpeGVsIHdpdGggYWxwaGEgPiAwIGF0IHRoZVxuXHQgKiBzcGVjaWZpZWQgcG9zaXRpb24pLiBUaGlzIGlnbm9yZXMgdGhlIGFscGhhLCBzaGFkb3cgYW5kIGNvbXBvc2l0ZU9wZXJhdGlvbiBvZiB0aGUgZGlzcGxheSBvYmplY3QsIGFuZCBhbGxcblx0ICogdHJhbnNmb3JtIHByb3BlcnRpZXMgaW5jbHVkaW5nIHJlZ1gvWS5cblx0ICogQG1ldGhvZCBoaXRUZXN0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIHRvIGNoZWNrIGluIHRoZSBkaXNwbGF5IG9iamVjdCdzIGxvY2FsIGNvb3JkaW5hdGVzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiB0byBjaGVjayBpbiB0aGUgZGlzcGxheSBvYmplY3QncyBsb2NhbCBjb29yZGluYXRlcy5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGVyZSBpcyBhIHZpc2libGUgc2VjdGlvbiBvZiBhIERpc3BsYXlPYmplY3QgdGhhdCBvdmVybGFwcyB0aGUgc3BlY2lmaWVkXG5cdCAqIGNvb3JkaW5hdGVzLlxuXHQgKiovXG5cdHAuaGl0VGVzdCA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHQvLyBUT0RPOiBvcHRpbWl6ZSB0byB1c2UgdGhlIGZhc3QgY2FjaGUgY2hlY2sgd2hlcmUgcG9zc2libGUuXG5cdFx0cmV0dXJuICh0aGlzLmdldE9iamVjdFVuZGVyUG9pbnQoeCwgeSkgIT0gbnVsbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIGRpc3BsYXkgb2JqZWN0cyB1bmRlciB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGVzIHRoYXQgYXJlIGluIHRoaXMgY29udGFpbmVyJ3MgZGlzcGxheVxuXHQgKiBsaXN0LiBUaGlzIHJvdXRpbmUgaWdub3JlcyBhbnkgZGlzcGxheSBvYmplY3RzIHdpdGgge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9tb3VzZUVuYWJsZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogc2V0IHRvIGBmYWxzZWAuIFRoZSBhcnJheSB3aWxsIGJlIHNvcnRlZCBpbiBvcmRlciBvZiB2aXN1YWwgZGVwdGgsIHdpdGggdGhlIHRvcC1tb3N0IGRpc3BsYXkgb2JqZWN0IGF0IGluZGV4IDAuXG5cdCAqIFRoaXMgdXNlcyBzaGFwZSBiYXNlZCBoaXQgZGV0ZWN0aW9uLCBhbmQgY2FuIGJlIGFuIGV4cGVuc2l2ZSBvcGVyYXRpb24gdG8gcnVuLCBzbyBpdCBpcyBiZXN0IHRvIHVzZSBpdCBjYXJlZnVsbHkuXG5cdCAqIEZvciBleGFtcGxlLCBpZiB0ZXN0aW5nIGZvciBvYmplY3RzIHVuZGVyIHRoZSBtb3VzZSwgdGVzdCBvbiB0aWNrIChpbnN0ZWFkIG9mIG9uIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2Vtb3ZlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319KSxcblx0ICogYW5kIG9ubHkgaWYgdGhlIG1vdXNlJ3MgcG9zaXRpb24gaGFzIGNoYW5nZWQuXG5cdCAqIFxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+QnkgZGVmYXVsdCAobW9kZT0wKSB0aGlzIG1ldGhvZCBldmFsdWF0ZXMgYWxsIGRpc3BsYXkgb2JqZWN0cy48L2xpPlxuXHQgKiAgICAgPGxpPkJ5IHNldHRpbmcgdGhlIGBtb2RlYCBwYXJhbWV0ZXIgdG8gYDFgLCB0aGUge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9tb3VzZUVuYWJsZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogXHRcdGFuZCB7eyNjcm9zc0xpbmsgXCJtb3VzZUNoaWxkcmVuOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnRpZXMgd2lsbCBiZSByZXNwZWN0ZWQuPC9saT5cblx0ICogXHQgICA8bGk+U2V0dGluZyB0aGUgYG1vZGVgIHRvIGAyYCBhZGRpdGlvbmFsbHkgZXhjbHVkZXMgZGlzcGxheSBvYmplY3RzIHRoYXQgZG8gbm90IGhhdmUgYWN0aXZlIG1vdXNlIGV2ZW50XG5cdCAqIFx0ICAgXHRsaXN0ZW5lcnMgb3IgYSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0OmN1cnNvcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eS4gVGhhdCBpcywgb25seSBvYmplY3RzXG5cdCAqIFx0ICAgXHR0aGF0IHdvdWxkIG5vcm1hbGx5IGludGVyY2VwdCBtb3VzZSBpbnRlcmFjdGlvbiB3aWxsIGJlIGluY2x1ZGVkLiBUaGlzIGNhbiBzaWduaWZpY2FudGx5IGltcHJvdmUgcGVyZm9ybWFuY2Vcblx0ICogXHQgICBcdGluIHNvbWUgY2FzZXMgYnkgcmVkdWNpbmcgdGhlIG51bWJlciBvZiBkaXNwbGF5IG9iamVjdHMgdGhhdCBuZWVkIHRvIGJlIHRlc3RlZC48L2xpPlxuXHQgKiA8L2xpPlxuXHQgKiBcblx0ICogVGhpcyBtZXRob2QgYWNjb3VudHMgZm9yIGJvdGgge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9oaXRBcmVhOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21hc2s6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgZ2V0T2JqZWN0c1VuZGVyUG9pbnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gaW4gdGhlIGNvbnRhaW5lciB0byB0ZXN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiBpbiB0aGUgY29udGFpbmVyIHRvIHRlc3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbbW9kZT0wXSBUaGUgbW9kZSB0byB1c2UgdG8gZGV0ZXJtaW5lIHdoaWNoIGRpc3BsYXkgb2JqZWN0cyB0byBpbmNsdWRlLiAwLWFsbCwgMS1yZXNwZWN0IG1vdXNlRW5hYmxlZC9tb3VzZUNoaWxkcmVuLCAyLW9ubHkgbW91c2Ugb3BhcXVlIG9iamVjdHMuXG5cdCAqIEByZXR1cm4ge0FycmF5fSBBbiBBcnJheSBvZiBEaXNwbGF5T2JqZWN0cyB1bmRlciB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGVzLlxuXHQgKiovXG5cdHAuZ2V0T2JqZWN0c1VuZGVyUG9pbnQgPSBmdW5jdGlvbih4LCB5LCBtb2RlKSB7XG5cdFx0dmFyIGFyciA9IFtdO1xuXHRcdHZhciBwdCA9IHRoaXMubG9jYWxUb0dsb2JhbCh4LCB5KTtcblx0XHR0aGlzLl9nZXRPYmplY3RzVW5kZXJQb2ludChwdC54LCBwdC55LCBhcnIsIG1vZGU+MCwgbW9kZT09MSk7XG5cdFx0cmV0dXJuIGFycjtcblx0fTtcblxuXHQvKipcblx0ICogU2ltaWxhciB0byB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvZ2V0T2JqZWN0c1VuZGVyUG9pbnRcIn19e3svY3Jvc3NMaW5rfX0sIGJ1dCByZXR1cm5zIG9ubHkgdGhlIHRvcC1tb3N0IGRpc3BsYXlcblx0ICogb2JqZWN0LiBUaGlzIHJ1bnMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgdGhhbiA8Y29kZT5nZXRPYmplY3RzVW5kZXJQb2ludCgpPC9jb2RlPiwgYnV0IGlzIHN0aWxsIHBvdGVudGlhbGx5IGFuIGV4cGVuc2l2ZVxuXHQgKiBvcGVyYXRpb24uIFNlZSB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvZ2V0T2JqZWN0c1VuZGVyUG9pbnRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBtZXRob2QgZ2V0T2JqZWN0VW5kZXJQb2ludFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvbiBpbiB0aGUgY29udGFpbmVyIHRvIHRlc3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uIGluIHRoZSBjb250YWluZXIgdG8gdGVzdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1vZGUgVGhlIG1vZGUgdG8gdXNlIHRvIGRldGVybWluZSB3aGljaCBkaXNwbGF5IG9iamVjdHMgdG8gaW5jbHVkZS4gIDAtYWxsLCAxLXJlc3BlY3QgbW91c2VFbmFibGVkL21vdXNlQ2hpbGRyZW4sIDItb25seSBtb3VzZSBvcGFxdWUgb2JqZWN0cy5cblx0ICogQHJldHVybiB7RGlzcGxheU9iamVjdH0gVGhlIHRvcC1tb3N0IGRpc3BsYXkgb2JqZWN0IHVuZGVyIHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZXMuXG5cdCAqKi9cblx0cC5nZXRPYmplY3RVbmRlclBvaW50ID0gZnVuY3Rpb24oeCwgeSwgbW9kZSkge1xuXHRcdHZhciBwdCA9IHRoaXMubG9jYWxUb0dsb2JhbCh4LCB5KTtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0T2JqZWN0c1VuZGVyUG9pbnQocHQueCwgcHQueSwgbnVsbCwgbW9kZT4wLCBtb2RlPT0xKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBEb2NjZWQgaW4gc3VwZXJjbGFzcy5cblx0ICovXG5cdHAuZ2V0Qm91bmRzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldEJvdW5kcyhudWxsLCB0cnVlKTtcblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogRG9jY2VkIGluIHN1cGVyY2xhc3MuXG5cdCAqL1xuXHRwLmdldFRyYW5zZm9ybWVkQm91bmRzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldEJvdW5kcygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBDb250YWluZXIuIFNvbWUgcHJvcGVydGllcyB0aGF0IGFyZSBzcGVjaWZpYyB0byB0aGlzIGluc3RhbmNlJ3MgY3VycmVudCBjb250ZXh0IGFyZVxuXHQgKiByZXZlcnRlZCB0byB0aGVpciBkZWZhdWx0cyAoZm9yIGV4YW1wbGUgLnBhcmVudCkuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHBhcmFtIHtCb29sZWFufSBbcmVjdXJzaXZlPWZhbHNlXSBJZiB0cnVlLCBhbGwgb2YgdGhlIGRlc2NlbmRhbnRzIG9mIHRoaXMgY29udGFpbmVyIHdpbGwgYmUgY2xvbmVkIHJlY3Vyc2l2ZWx5LiBJZiBmYWxzZSwgdGhlXG5cdCAqIHByb3BlcnRpZXMgb2YgdGhlIGNvbnRhaW5lciB3aWxsIGJlIGNsb25lZCwgYnV0IHRoZSBuZXcgaW5zdGFuY2Ugd2lsbCBub3QgaGF2ZSBhbnkgY2hpbGRyZW4uXG5cdCAqIEByZXR1cm4ge0NvbnRhaW5lcn0gQSBjbG9uZSBvZiB0aGUgY3VycmVudCBDb250YWluZXIgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKHJlY3Vyc2l2ZSkge1xuXHRcdHZhciBvID0gdGhpcy5fY2xvbmVQcm9wcyhuZXcgQ29udGFpbmVyKCkpO1xuXHRcdGlmIChyZWN1cnNpdmUpIHsgdGhpcy5fY2xvbmVDaGlsZHJlbihvKTsgfVxuXHRcdHJldHVybiBvO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbQ29udGFpbmVyIChuYW1lPVwiKyAgdGhpcy5uYW1lICtcIildXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfdGlja1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZ0T2JqIEFuIGV2ZW50IG9iamVjdCB0aGF0IHdpbGwgYmUgZGlzcGF0Y2hlZCB0byBhbGwgdGljayBsaXN0ZW5lcnMuIFRoaXMgb2JqZWN0IGlzIHJldXNlZCBiZXR3ZWVuIGRpc3BhdGNoZXJzIHRvIHJlZHVjZSBjb25zdHJ1Y3Rpb24gJiBHQyBjb3N0cy5cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3RpY2sgPSBmdW5jdGlvbihldnRPYmopIHtcblx0XHRpZiAodGhpcy50aWNrQ2hpbGRyZW4pIHtcblx0XHRcdGZvciAodmFyIGk9dGhpcy5jaGlsZHJlbi5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG5cdFx0XHRcdGlmIChjaGlsZC50aWNrRW5hYmxlZCAmJiBjaGlsZC5fdGljaykgeyBjaGlsZC5fdGljayhldnRPYmopOyB9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9fdGljayhldnRPYmopO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJlY3Vyc2l2ZWx5IGNsb25lcyBhbGwgY2hpbGRyZW4gb2YgdGhpcyBjb250YWluZXIsIGFuZCBhZGRzIHRoZW0gdG8gdGhlIHRhcmdldCBjb250YWluZXIuXG5cdCAqIEBtZXRob2QgY2xvbmVDaGlsZHJlblxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7Q29udGFpbmVyfSBvIFRoZSB0YXJnZXQgY29udGFpbmVyLlxuXHQgKiovXG5cdHAuX2Nsb25lQ2hpbGRyZW4gPSBmdW5jdGlvbihvKSB7XG5cdFx0aWYgKG8uY2hpbGRyZW4ubGVuZ3RoKSB7IG8ucmVtb3ZlQWxsQ2hpbGRyZW4oKTsgfVxuXHRcdHZhciBhcnIgPSBvLmNoaWxkcmVuO1xuXHRcdGZvciAodmFyIGk9MCwgbD10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdHZhciBjbG9uZSA9IHRoaXMuY2hpbGRyZW5baV0uY2xvbmUodHJ1ZSk7XG5cdFx0XHRjbG9uZS5wYXJlbnQgPSBvO1xuXHRcdFx0YXJyLnB1c2goY2xvbmUpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0T2JqZWN0c1VuZGVyUG9pbnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gbW91c2UgSWYgdHJ1ZSwgaXQgd2lsbCByZXNwZWN0IG1vdXNlIGludGVyYWN0aW9uIHByb3BlcnRpZXMgbGlrZSBtb3VzZUVuYWJsZWQsIG1vdXNlQ2hpbGRyZW4sIGFuZCBhY3RpdmUgbGlzdGVuZXJzLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGFjdGl2ZUxpc3RlbmVyIElmIHRydWUsIHRoZXJlIGlzIGFuIGFjdGl2ZSBtb3VzZSBldmVudCBsaXN0ZW5lciBvbiBhIHBhcmVudCBvYmplY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjdXJyZW50RGVwdGggSW5kaWNhdGVzIHRoZSBjdXJyZW50IGRlcHRoIG9mIHRoZSBzZWFyY2guXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9nZXRPYmplY3RzVW5kZXJQb2ludCA9IGZ1bmN0aW9uKHgsIHksIGFyciwgbW91c2UsIGFjdGl2ZUxpc3RlbmVyLCBjdXJyZW50RGVwdGgpIHtcblx0XHRjdXJyZW50RGVwdGggPSBjdXJyZW50RGVwdGggfHwgMDtcblx0XHRpZiAoIWN1cnJlbnREZXB0aCAmJiAhdGhpcy5fdGVzdE1hc2sodGhpcywgeCwgeSkpIHsgcmV0dXJuIG51bGw7IH1cblx0XHR2YXIgbXR4LCBjdHggPSBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0Ll9oaXRUZXN0Q29udGV4dDtcblx0XHRhY3RpdmVMaXN0ZW5lciA9IGFjdGl2ZUxpc3RlbmVyIHx8IChtb3VzZSYmdGhpcy5faGFzTW91c2VFdmVudExpc3RlbmVyKCkpO1xuXG5cdFx0Ly8gZHJhdyBjaGlsZHJlbiBvbmUgYXQgYSB0aW1lLCBhbmQgY2hlY2sgaWYgd2UgZ2V0IGEgaGl0OlxuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4sIGwgPSBjaGlsZHJlbi5sZW5ndGg7XG5cdFx0Zm9yICh2YXIgaT1sLTE7IGk+PTA7IGktLSkge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cdFx0XHR2YXIgaGl0QXJlYSA9IGNoaWxkLmhpdEFyZWE7XG5cdFx0XHRpZiAoIWNoaWxkLnZpc2libGUgfHwgKCFoaXRBcmVhICYmICFjaGlsZC5pc1Zpc2libGUoKSkgfHwgKG1vdXNlICYmICFjaGlsZC5tb3VzZUVuYWJsZWQpKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRpZiAoIWhpdEFyZWEgJiYgIXRoaXMuX3Rlc3RNYXNrKGNoaWxkLCB4LCB5KSkgeyBjb250aW51ZTsgfVxuXHRcdFx0XG5cdFx0XHQvLyBpZiBhIGNoaWxkIGNvbnRhaW5lciBoYXMgYSBoaXRBcmVhIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGl0cyBoaXRBcmVhLCBzbyB3ZSBjYW4gdHJlYXQgaXQgYXMgYSBub3JtYWwgRE86XG5cdFx0XHRpZiAoIWhpdEFyZWEgJiYgY2hpbGQgaW5zdGFuY2VvZiBDb250YWluZXIpIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IGNoaWxkLl9nZXRPYmplY3RzVW5kZXJQb2ludCh4LCB5LCBhcnIsIG1vdXNlLCBhY3RpdmVMaXN0ZW5lciwgY3VycmVudERlcHRoKzEpO1xuXHRcdFx0XHRpZiAoIWFyciAmJiByZXN1bHQpIHsgcmV0dXJuIChtb3VzZSAmJiAhdGhpcy5tb3VzZUNoaWxkcmVuKSA/IHRoaXMgOiByZXN1bHQ7IH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChtb3VzZSAmJiAhYWN0aXZlTGlzdGVuZXIgJiYgIWNoaWxkLl9oYXNNb3VzZUV2ZW50TGlzdGVuZXIoKSkgeyBjb250aW51ZTsgfVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gVE9ETzogY2FuIHdlIHBhc3MgZGlzcGxheVByb3BzIGZvcndhcmQsIHRvIGF2b2lkIGhhdmluZyB0byBjYWxjdWxhdGUgdGhpcyBiYWNrd2FyZHMgZXZlcnkgdGltZT8gSXQncyBraW5kIG9mIGEgbWl4ZWQgYmFnLiBXaGVuIHdlJ3JlIG9ubHkgaHVudGluZyBmb3IgRE9zIHdpdGggZXZlbnQgbGlzdGVuZXJzLCBpdCBtYXkgbm90IG1ha2Ugc2Vuc2UuXG5cdFx0XHRcdHZhciBwcm9wcyA9IGNoaWxkLmdldENvbmNhdGVuYXRlZERpc3BsYXlQcm9wcyhjaGlsZC5fcHJvcHMpO1xuXHRcdFx0XHRtdHggPSBwcm9wcy5tYXRyaXg7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoaGl0QXJlYSkge1xuXHRcdFx0XHRcdG10eC5hcHBlbmRNYXRyaXgoaGl0QXJlYS5nZXRNYXRyaXgoaGl0QXJlYS5fcHJvcHMubWF0cml4KSk7XG5cdFx0XHRcdFx0cHJvcHMuYWxwaGEgPSBoaXRBcmVhLmFscGhhO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBwcm9wcy5hbHBoYTtcblx0XHRcdFx0Y3R4LnNldFRyYW5zZm9ybShtdHguYSwgIG10eC5iLCBtdHguYywgbXR4LmQsIG10eC50eC14LCBtdHgudHkteSk7XG5cdFx0XHRcdChoaXRBcmVhfHxjaGlsZCkuZHJhdyhjdHgpO1xuXHRcdFx0XHRpZiAoIXRoaXMuX3Rlc3RIaXQoY3R4KSkgeyBjb250aW51ZTsgfVxuXHRcdFx0XHRjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIDIsIDIpO1xuXHRcdFx0XHRpZiAoYXJyKSB7IGFyci5wdXNoKGNoaWxkKTsgfVxuXHRcdFx0XHRlbHNlIHsgcmV0dXJuIChtb3VzZSAmJiAhdGhpcy5tb3VzZUNoaWxkcmVuKSA/IHRoaXMgOiBjaGlsZDsgfVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF90ZXN0TWFza1xuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IHRhcmdldFxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgeC95IGlzIHdpdGhpbiB0aGUgbWFza2VkIHJlZ2lvbi5cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3Rlc3RNYXNrID0gZnVuY3Rpb24odGFyZ2V0LCB4LCB5KSB7XG5cdFx0dmFyIG1hc2sgPSB0YXJnZXQubWFzaztcblx0XHRpZiAoIW1hc2sgfHwgIW1hc2suZ3JhcGhpY3MgfHwgbWFzay5ncmFwaGljcy5pc0VtcHR5KCkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcblx0XHR2YXIgbXR4ID0gdGhpcy5fcHJvcHMubWF0cml4LCBwYXJlbnQgPSB0YXJnZXQucGFyZW50O1xuXHRcdG10eCA9IHBhcmVudCA/IHBhcmVudC5nZXRDb25jYXRlbmF0ZWRNYXRyaXgobXR4KSA6IG10eC5pZGVudGl0eSgpO1xuXHRcdG10eCA9IG1hc2suZ2V0TWF0cml4KG1hc2suX3Byb3BzLm1hdHJpeCkucHJlcGVuZE1hdHJpeChtdHgpO1xuXHRcdFxuXHRcdHZhciBjdHggPSBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0Ll9oaXRUZXN0Q29udGV4dDtcblx0XHRjdHguc2V0VHJhbnNmb3JtKG10eC5hLCAgbXR4LmIsIG10eC5jLCBtdHguZCwgbXR4LnR4LXgsIG10eC50eS15KTtcblx0XHRcblx0XHQvLyBkcmF3IHRoZSBtYXNrIGFzIGEgc29saWQgZmlsbDpcblx0XHRtYXNrLmdyYXBoaWNzLmRyYXdBc1BhdGgoY3R4KTtcblx0XHRjdHguZmlsbFN0eWxlID0gXCIjMDAwXCI7XG5cdFx0Y3R4LmZpbGwoKTtcblx0XHRcblx0XHRpZiAoIXRoaXMuX3Rlc3RIaXQoY3R4KSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgMiwgMik7XG5cdFx0XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0Qm91bmRzXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZVRyYW5zZm9ybSBJZiB0cnVlLCBkb2VzIG5vdCBhcHBseSB0aGlzIG9iamVjdCdzIHRyYW5zZm9ybS5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ2V0Qm91bmRzID0gZnVuY3Rpb24obWF0cml4LCBpZ25vcmVUcmFuc2Zvcm0pIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5EaXNwbGF5T2JqZWN0X2dldEJvdW5kcygpO1xuXHRcdGlmIChib3VuZHMpIHsgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybUJvdW5kcyhib3VuZHMsIG1hdHJpeCwgaWdub3JlVHJhbnNmb3JtKTsgfVxuXHRcdFxuXHRcdHZhciBtdHggPSB0aGlzLl9wcm9wcy5tYXRyaXg7XG5cdFx0bXR4ID0gaWdub3JlVHJhbnNmb3JtID8gbXR4LmlkZW50aXR5KCkgOiB0aGlzLmdldE1hdHJpeChtdHgpO1xuXHRcdGlmIChtYXRyaXgpIHsgbXR4LnByZXBlbmRNYXRyaXgobWF0cml4KTsgfVxuXHRcdFxuXHRcdHZhciBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGgsIHJlY3Q9bnVsbDtcblx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKCFjaGlsZC52aXNpYmxlIHx8ICEoYm91bmRzID0gY2hpbGQuX2dldEJvdW5kcyhtdHgpKSkgeyBjb250aW51ZTsgfVxuXHRcdFx0aWYgKHJlY3QpIHsgcmVjdC5leHRlbmQoYm91bmRzLngsIGJvdW5kcy55LCBib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpOyB9XG5cdFx0XHRlbHNlIHsgcmVjdCA9IGJvdW5kcy5jbG9uZSgpOyB9XG5cdFx0fVxuXHRcdHJldHVybiByZWN0O1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuQ29udGFpbmVyID0gY3JlYXRlanMucHJvbW90ZShDb250YWluZXIsIFwiRGlzcGxheU9iamVjdFwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTdGFnZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEEgc3RhZ2UgaXMgdGhlIHJvb3QgbGV2ZWwge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhIGRpc3BsYXkgbGlzdC4gRWFjaCB0aW1lIGl0cyB7eyNjcm9zc0xpbmsgXCJTdGFnZS90aWNrXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZCBpcyBjYWxsZWQsIGl0IHdpbGwgcmVuZGVyIGl0cyBkaXNwbGF5IGxpc3QgdG8gaXRzIHRhcmdldCBjYW52YXMuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogVGhpcyBleGFtcGxlIGNyZWF0ZXMgYSBzdGFnZSwgYWRkcyBhIGNoaWxkIHRvIGl0LCB0aGVuIHVzZXMge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319IHRvIHVwZGF0ZSB0aGUgY2hpbGRcblx0ICogYW5kIHJlZHJhdyB0aGUgc3RhZ2UgdXNpbmcge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdXBkYXRlXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiAgICAgIHZhciBzdGFnZSA9IG5ldyBjcmVhdGVqcy5TdGFnZShcImNhbnZhc0VsZW1lbnRJZFwiKTtcblx0ICogICAgICB2YXIgaW1hZ2UgPSBuZXcgY3JlYXRlanMuQml0bWFwKFwiaW1hZ2VQYXRoLnBuZ1wiKTtcblx0ICogICAgICBzdGFnZS5hZGRDaGlsZChpbWFnZSk7XG5cdCAqICAgICAgY3JlYXRlanMuVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIGhhbmRsZVRpY2spO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZVRpY2soZXZlbnQpIHtcblx0ICogICAgICAgICAgaW1hZ2UueCArPSAxMDtcblx0ICogICAgICAgICAgc3RhZ2UudXBkYXRlKCk7XG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBAY2xhc3MgU3RhZ2Vcblx0ICogQGV4dGVuZHMgQ29udGFpbmVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50IHwgU3RyaW5nIHwgT2JqZWN0fSBjYW52YXMgQSBjYW52YXMgb2JqZWN0IHRoYXQgdGhlIFN0YWdlIHdpbGwgcmVuZGVyIHRvLCBvciB0aGUgc3RyaW5nIGlkXG5cdCAqIG9mIGEgY2FudmFzIG9iamVjdCBpbiB0aGUgY3VycmVudCBkb2N1bWVudC5cblx0ICoqL1xuXHRmdW5jdGlvbiBTdGFnZShjYW52YXMpIHtcblx0XHR0aGlzLkNvbnRhaW5lcl9jb25zdHJ1Y3RvcigpO1xuXHRcblx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdGFnZSBzaG91bGQgYXV0b21hdGljYWxseSBjbGVhciB0aGUgY2FudmFzIGJlZm9yZSBlYWNoIHJlbmRlci4gWW91IGNhbiBzZXQgdGhpcyB0byA8Y29kZT5mYWxzZTwvY29kZT5cblx0XHQgKiB0byBtYW51YWxseSBjb250cm9sIGNsZWFyaW5nIChmb3IgZ2VuZXJhdGl2ZSBhcnQsIG9yIHdoZW4gcG9pbnRpbmcgbXVsdGlwbGUgc3RhZ2VzIGF0IHRoZSBzYW1lIGNhbnZhcyBmb3Jcblx0XHQgKiBleGFtcGxlKS5cblx0XHQgKlxuXHRcdCAqIDxoND5FeGFtcGxlPC9oND5cblx0XHQgKlxuXHRcdCAqICAgICAgdmFyIHN0YWdlID0gbmV3IGNyZWF0ZWpzLlN0YWdlKFwiY2FudmFzSWRcIik7XG5cdFx0ICogICAgICBzdGFnZS5hdXRvQ2xlYXIgPSBmYWxzZTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBhdXRvQ2xlYXJcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqKi9cblx0XHR0aGlzLmF1dG9DbGVhciA9IHRydWU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjYW52YXMgdGhlIHN0YWdlIHdpbGwgcmVuZGVyIHRvLiBNdWx0aXBsZSBzdGFnZXMgY2FuIHNoYXJlIGEgc2luZ2xlIGNhbnZhcywgYnV0IHlvdSBtdXN0IGRpc2FibGUgYXV0b0NsZWFyIGZvciBhbGwgYnV0IHRoZVxuXHRcdCAqIGZpcnN0IHN0YWdlIHRoYXQgd2lsbCBiZSB0aWNrZWQgKG9yIHRoZXkgd2lsbCBjbGVhciBlYWNoIG90aGVyJ3MgcmVuZGVyKS5cblx0XHQgKlxuXHRcdCAqIFdoZW4gY2hhbmdpbmcgdGhlIGNhbnZhcyBwcm9wZXJ0eSB5b3UgbXVzdCBkaXNhYmxlIHRoZSBldmVudHMgb24gdGhlIG9sZCBjYW52YXMsIGFuZCBlbmFibGUgZXZlbnRzIG9uIHRoZVxuXHRcdCAqIG5ldyBjYW52YXMgb3IgbW91c2UgZXZlbnRzIHdpbGwgbm90IHdvcmsgYXMgZXhwZWN0ZWQuIEZvciBleGFtcGxlOlxuXHRcdCAqXG5cdFx0ICogICAgICBteVN0YWdlLmVuYWJsZURPTUV2ZW50cyhmYWxzZSk7XG5cdFx0ICogICAgICBteVN0YWdlLmNhbnZhcyA9IGFub3RoZXJDYW52YXM7XG5cdFx0ICogICAgICBteVN0YWdlLmVuYWJsZURPTUV2ZW50cyh0cnVlKTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBjYW52YXNcblx0XHQgKiBAdHlwZSBIVE1MQ2FudmFzRWxlbWVudCB8IE9iamVjdFxuXHRcdCAqKi9cblx0XHR0aGlzLmNhbnZhcyA9ICh0eXBlb2YgY2FudmFzID09IFwic3RyaW5nXCIpID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudmFzKSA6IGNhbnZhcztcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgbW91c2UgWCBwb3NpdGlvbiBvbiB0aGUgY2FudmFzLiBJZiB0aGUgbW91c2UgbGVhdmVzIHRoZSBjYW52YXMsIHRoaXMgd2lsbCBpbmRpY2F0ZSB0aGUgbW9zdCByZWNlbnRcblx0XHQgKiBwb3NpdGlvbiBvdmVyIHRoZSBjYW52YXMsIGFuZCBtb3VzZUluQm91bmRzIHdpbGwgYmUgc2V0IHRvIGZhbHNlLlxuXHRcdCAqIEBwcm9wZXJ0eSBtb3VzZVhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5tb3VzZVggPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY3VycmVudCBtb3VzZSBZIHBvc2l0aW9uIG9uIHRoZSBjYW52YXMuIElmIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIGNhbnZhcywgdGhpcyB3aWxsIGluZGljYXRlIHRoZSBtb3N0IHJlY2VudFxuXHRcdCAqIHBvc2l0aW9uIG92ZXIgdGhlIGNhbnZhcywgYW5kIG1vdXNlSW5Cb3VuZHMgd2lsbCBiZSBzZXQgdG8gZmFsc2UuXG5cdFx0ICogQHByb3BlcnR5IG1vdXNlWVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLm1vdXNlWSA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNwZWNpZmllcyB0aGUgYXJlYSBvZiB0aGUgc3RhZ2UgdG8gYWZmZWN0IHdoZW4gY2FsbGluZyB1cGRhdGUuIFRoaXMgY2FuIGJlIHVzZSB0byBzZWxlY3RpdmVseVxuXHRcdCAqIHJlLWRyYXcgc3BlY2lmaWMgcmVnaW9ucyBvZiB0aGUgY2FudmFzLiBJZiBudWxsLCB0aGUgd2hvbGUgY2FudmFzIGFyZWEgaXMgZHJhd24uXG5cdFx0ICogQHByb3BlcnR5IGRyYXdSZWN0XG5cdFx0ICogQHR5cGUge1JlY3RhbmdsZX1cblx0XHQgKi9cblx0XHR0aGlzLmRyYXdSZWN0ID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgZGlzcGxheSBvYmplY3RzIHNob3VsZCBiZSByZW5kZXJlZCBvbiB3aG9sZSBwaXhlbHMuIFlvdSBjYW4gc2V0IHRoZVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3Qvc25hcFRvUGl4ZWxcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgb2Zcblx0XHQgKiBkaXNwbGF5IG9iamVjdHMgdG8gZmFsc2UgdG8gZW5hYmxlL2Rpc2FibGUgdGhpcyBiZWhhdmlvdXIgb24gYSBwZXIgaW5zdGFuY2UgYmFzaXMuXG5cdFx0ICogQHByb3BlcnR5IHNuYXBUb1BpeGVsRW5hYmxlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqKi9cblx0XHR0aGlzLnNuYXBUb1BpeGVsRW5hYmxlZCA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbW91c2UgaXMgY3VycmVudGx5IHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoZSBjYW52YXMuXG5cdFx0ICogQHByb3BlcnR5IG1vdXNlSW5Cb3VuZHNcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiovXG5cdFx0dGhpcy5tb3VzZUluQm91bmRzID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIHRydWUsIHRpY2sgY2FsbGJhY2tzIHdpbGwgYmUgY2FsbGVkIG9uIGFsbCBkaXNwbGF5IG9iamVjdHMgb24gdGhlIHN0YWdlIHByaW9yIHRvIHJlbmRlcmluZyB0byB0aGUgY2FudmFzLlxuXHRcdCAqIEBwcm9wZXJ0eSB0aWNrT25VcGRhdGVcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqKi9cblx0XHR0aGlzLnRpY2tPblVwZGF0ZSA9IHRydWU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIHRydWUsIG1vdXNlIG1vdmUgZXZlbnRzIHdpbGwgY29udGludWUgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGUgdGFyZ2V0IGNhbnZhcy4gU2VlXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvbW91c2VJbkJvdW5kczpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiB4L3kvcmF3WC9yYXdZLlxuXHRcdCAqIEBwcm9wZXJ0eSBtb3VzZU1vdmVPdXRzaWRlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICoqL1xuXHRcdHRoaXMubW91c2VNb3ZlT3V0c2lkZSA9IGZhbHNlO1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFByZXZlbnRzIHNlbGVjdGlvbiBvZiBvdGhlciBlbGVtZW50cyBpbiB0aGUgaHRtbCBwYWdlIGlmIHRoZSB1c2VyIGNsaWNrcyBhbmQgZHJhZ3MsIG9yIGRvdWJsZSBjbGlja3Mgb24gdGhlIGNhbnZhcy5cblx0XHQgKiBUaGlzIHdvcmtzIGJ5IGNhbGxpbmcgYHByZXZlbnREZWZhdWx0KClgIG9uIGFueSBtb3VzZWRvd24gZXZlbnRzIChvciB0b3VjaCBlcXVpdmFsZW50KSBvcmlnaW5hdGluZyBvbiB0aGUgY2FudmFzLlxuXHRcdCAqIEBwcm9wZXJ0eSBwcmV2ZW50U2VsZWN0aW9uXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKiovXG5cdFx0dGhpcy5wcmV2ZW50U2VsZWN0aW9uID0gdHJ1ZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGhpdEFyZWEgcHJvcGVydHkgaXMgbm90IHN1cHBvcnRlZCBmb3IgU3RhZ2UuXG5cdFx0ICogQHByb3BlcnR5IGhpdEFyZWFcblx0XHQgKiBAdHlwZSB7RGlzcGxheU9iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0IFxuXHRcdCBcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIG9iamVjdHMgd2l0aCBkYXRhIGZvciBlYWNoIGFjdGl2ZSBwb2ludGVyIGlkLiBFYWNoIG9iamVjdCBoYXMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXHRcdCAqIHgsIHksIGV2ZW50LCB0YXJnZXQsIG92ZXJUYXJnZXQsIG92ZXJYLCBvdmVyWSwgaW5Cb3VuZHMsIHBvc0V2dE9iaiAobmF0aXZlIGV2ZW50IHRoYXQgbGFzdCB1cGRhdGVkIHBvc2l0aW9uKVxuXHRcdCAqIEBwcm9wZXJ0eSBfcG9pbnRlckRhdGFcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcG9pbnRlckRhdGEgPSB7fTtcblx0XG5cdFx0LyoqXG5cdFx0ICogTnVtYmVyIG9mIGFjdGl2ZSBwb2ludGVycy5cblx0XHQgKiBAcHJvcGVydHkgX3BvaW50ZXJDb3VudFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9wb2ludGVyQ291bnQgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgSUQgb2YgdGhlIHByaW1hcnkgcG9pbnRlci5cblx0XHQgKiBAcHJvcGVydHkgX3ByaW1hcnlQb2ludGVySURcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcHJpbWFyeVBvaW50ZXJJRCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbW91c2VPdmVySW50ZXJ2YWxJRFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fbW91c2VPdmVySW50ZXJ2YWxJRCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9uZXh0U3RhZ2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgU3RhZ2Vcblx0XHQgKiovXG5cdFx0dGhpcy5fbmV4dFN0YWdlID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3ByZXZTdGFnZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBTdGFnZVxuXHRcdCAqKi9cblx0XHR0aGlzLl9wcmV2U3RhZ2UgPSBudWxsO1xuXHRcdFxuXHRcdFxuXHQvLyBpbml0aWFsaXplOlxuXHRcdHRoaXMuZW5hYmxlRE9NRXZlbnRzKHRydWUpO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFN0YWdlLCBjcmVhdGVqcy5Db250YWluZXIpO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG4vLyBldmVudHM6XG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHVzZXIgbW92ZXMgdGhlIG1vdXNlIG92ZXIgdGhlIGNhbnZhcy5cblx0ICogU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cblx0ICogQGV2ZW50IHN0YWdlbW91c2Vtb3ZlXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgdGhlaXIgbGVmdCBtb3VzZSBidXR0b24gb24gdGhlIGNhbnZhcy4gU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cblx0ICogQGV2ZW50IHN0YWdlbW91c2Vkb3duXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSB1c2VyIHRoZSB1c2VyIHByZXNzZXMgc29tZXdoZXJlIG9uIHRoZSBzdGFnZSwgdGhlbiByZWxlYXNlcyB0aGUgbW91c2UgYnV0dG9uIGFueXdoZXJlIHRoYXQgdGhlIHBhZ2UgY2FuIGRldGVjdCBpdCAodGhpcyB2YXJpZXMgc2xpZ2h0bHkgYmV0d2VlbiBicm93c2VycykuXG5cdCAqIFlvdSBjYW4gdXNlIHt7I2Nyb3NzTGluayBcIlN0YWdlL21vdXNlSW5Cb3VuZHM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gdG8gY2hlY2sgd2hldGhlciB0aGUgbW91c2UgaXMgY3VycmVudGx5IHdpdGhpbiB0aGUgc3RhZ2UgYm91bmRzLlxuXHQgKiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxuXHQgKiBAZXZlbnQgc3RhZ2Vtb3VzZXVwXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBmcm9tIHdpdGhpbiB0aGUgY2FudmFzIGFyZWEgKG1vdXNlSW5Cb3VuZHMgPT0gdHJ1ZSkgdG8gb3V0c2lkZSBpdCAobW91c2VJbkJvdW5kcyA9PSBmYWxzZSkuXG5cdCAqIFRoaXMgaXMgY3VycmVudGx5IG9ubHkgZGlzcGF0Y2hlZCBmb3IgbW91c2UgaW5wdXQgKG5vdCB0b3VjaCkuIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXG5cdCAqIEBldmVudCBtb3VzZWxlYXZlXG5cdCAqIEBzaW5jZSAwLjcuMFxuXHQgKi9cblxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBpbnRvIHRoZSBjYW52YXMgYXJlYSAobW91c2VJbkJvdW5kcyA9PSBmYWxzZSkgZnJvbSBvdXRzaWRlIGl0IChtb3VzZUluQm91bmRzID09IHRydWUpLlxuXHQgKiBUaGlzIGlzIGN1cnJlbnRseSBvbmx5IGRpc3BhdGNoZWQgZm9yIG1vdXNlIGlucHV0IChub3QgdG91Y2gpLiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxuXHQgKiBAZXZlbnQgbW91c2VlbnRlclxuXHQgKiBAc2luY2UgMC43LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgZWFjaCB1cGRhdGUgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSB0aWNrIGV2ZW50IGlzIHByb3BhZ2F0ZWQgdGhyb3VnaCB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKiBZb3UgY2FuIGNhbGwgcHJldmVudERlZmF1bHQgb24gdGhlIGV2ZW50IG9iamVjdCB0byBjYW5jZWwgcHJvcGFnYXRpbmcgdGhlIHRpY2sgZXZlbnQuXG5cdCAqIEBldmVudCB0aWNrc3RhcnRcblx0ICogQHNpbmNlIDAuNy4wXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIGVhY2ggdXBkYXRlIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSB0aWNrIGV2ZW50IGlzIHByb3BhZ2F0ZWQgdGhyb3VnaCB0aGUgZGlzcGxheSBsaXN0LiBEb2VzIG5vdCBmaXJlIGlmXG5cdCAqIHRpY2tPblVwZGF0ZSBpcyBmYWxzZS4gUHJlY2VkZXMgdGhlIFwiZHJhd3N0YXJ0XCIgZXZlbnQuXG5cdCAqIEBldmVudCB0aWNrZW5kXG5cdCAqIEBzaW5jZSAwLjcuMFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCBlYWNoIHVwZGF0ZSBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGNhbnZhcyBpcyBjbGVhcmVkIGFuZCB0aGUgZGlzcGxheSBsaXN0IGlzIGRyYXduIHRvIGl0LlxuXHQgKiBZb3UgY2FuIGNhbGwgcHJldmVudERlZmF1bHQgb24gdGhlIGV2ZW50IG9iamVjdCB0byBjYW5jZWwgdGhlIGRyYXcuXG5cdCAqIEBldmVudCBkcmF3c3RhcnRcblx0ICogQHNpbmNlIDAuNy4wXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIGVhY2ggdXBkYXRlIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBkaXNwbGF5IGxpc3QgaXMgZHJhd24gdG8gdGhlIGNhbnZhcyBhbmQgdGhlIGNhbnZhcyBjb250ZXh0IGlzIHJlc3RvcmVkLlxuXHQgKiBAZXZlbnQgZHJhd2VuZFxuXHQgKiBAc2luY2UgMC43LjBcblx0ICovXG5cblx0IFxuLy8gZ2V0dGVyIC8gc2V0dGVyczpcblx0LyoqXG5cdCAqIFNwZWNpZmllcyBhIHRhcmdldCBzdGFnZSB0aGF0IHdpbGwgaGF2ZSBtb3VzZSAvIHRvdWNoIGludGVyYWN0aW9ucyByZWxheWVkIHRvIGl0IGFmdGVyIHRoaXMgc3RhZ2UgaGFuZGxlcyB0aGVtLlxuXHQgKiBUaGlzIGNhbiBiZSB1c2VmdWwgaW4gY2FzZXMgd2hlcmUgeW91IGhhdmUgbXVsdGlwbGUgbGF5ZXJlZCBjYW52YXNlcyBhbmQgd2FudCB1c2VyIGludGVyYWN0aW9uc1xuXHQgKiBldmVudHMgdG8gcGFzcyB0aHJvdWdoLiBGb3IgZXhhbXBsZSwgdGhpcyB3b3VsZCByZWxheSBtb3VzZSBldmVudHMgZnJvbSB0b3BTdGFnZSB0byBib3R0b21TdGFnZTpcblx0ICpcblx0ICogICAgICB0b3BTdGFnZS5uZXh0U3RhZ2UgPSBib3R0b21TdGFnZTtcblx0ICpcblx0ICogVG8gZGlzYWJsZSByZWxheWluZywgc2V0IG5leHRTdGFnZSB0byBudWxsLlxuXHQgKiBcblx0ICogTW91c2VPdmVyLCBNb3VzZU91dCwgUm9sbE92ZXIsIGFuZCBSb2xsT3V0IGludGVyYWN0aW9ucyBhcmUgYWxzbyBwYXNzZWQgdGhyb3VnaCB1c2luZyB0aGUgbW91c2Ugb3ZlciBzZXR0aW5nc1xuXHQgKiBvZiB0aGUgdG9wLW1vc3Qgc3RhZ2UsIGJ1dCBhcmUgb25seSBwcm9jZXNzZWQgaWYgdGhlIHRhcmdldCBzdGFnZSBoYXMgbW91c2Ugb3ZlciBpbnRlcmFjdGlvbnMgZW5hYmxlZC5cblx0ICogQ29uc2lkZXJhdGlvbnMgd2hlbiB1c2luZyByb2xsIG92ZXIgaW4gcmVsYXkgdGFyZ2V0czo8T0w+XG5cdCAqIDxMST4gVGhlIHRvcC1tb3N0IChmaXJzdCkgc3RhZ2UgbXVzdCBoYXZlIG1vdXNlIG92ZXIgaW50ZXJhY3Rpb25zIGVuYWJsZWQgKHZpYSBlbmFibGVNb3VzZU92ZXIpPC9MST5cblx0ICogPExJPiBBbGwgc3RhZ2VzIHRoYXQgd2lzaCB0byBwYXJ0aWNpcGF0ZSBpbiBtb3VzZSBvdmVyIGludGVyYWN0aW9uIG11c3QgZW5hYmxlIHRoZW0gdmlhIGVuYWJsZU1vdXNlT3ZlcjwvTEk+XG5cdCAqIDxMST4gQWxsIHJlbGF5IHRhcmdldHMgd2lsbCBzaGFyZSB0aGUgZnJlcXVlbmN5IHZhbHVlIG9mIHRoZSB0b3AtbW9zdCBzdGFnZTwvTEk+XG5cdCAqIDwvT0w+XG5cdCAqIFRvIGlsbHVzdHJhdGUsIGluIHRoaXMgZXhhbXBsZSB0aGUgdGFyZ2V0U3RhZ2Ugd291bGQgcHJvY2VzcyBtb3VzZSBvdmVyIGludGVyYWN0aW9ucyBhdCAxMGh6IChkZXNwaXRlIHBhc3Npbmdcblx0ICogMzAgYXMgaXQncyBkZXNpcmVkIGZyZXF1ZW5jeSk6XG5cdCAqIFx0dG9wU3RhZ2UubmV4dFN0YWdlID0gdGFyZ2V0U3RhZ2U7XG5cdCAqIFx0dG9wU3RhZ2UuZW5hYmxlTW91c2VPdmVyKDEwKTtcblx0ICogXHR0YXJnZXRTdGFnZS5lbmFibGVNb3VzZU92ZXIoMzApO1xuXHQgKiBcblx0ICogSWYgdGhlIHRhcmdldCBzdGFnZSdzIGNhbnZhcyBpcyBjb21wbGV0ZWx5IGNvdmVyZWQgYnkgdGhpcyBzdGFnZSdzIGNhbnZhcywgeW91IG1heSBhbHNvIHdhbnQgdG8gZGlzYWJsZSBpdHNcblx0ICogRE9NIGV2ZW50cyB1c2luZzpcblx0ICogXG5cdCAqXHR0YXJnZXRTdGFnZS5lbmFibGVET01FdmVudHMoZmFsc2UpO1xuXHQgKiBcblx0ICogQHByb3BlcnR5IG5leHRTdGFnZVxuXHQgKiBAdHlwZSB7U3RhZ2V9XG5cdCAqKi9cblx0cC5fZ2V0X25leHRTdGFnZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9uZXh0U3RhZ2U7XG5cdH07XG5cdHAuX3NldF9uZXh0U3RhZ2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh0aGlzLl9uZXh0U3RhZ2UpIHsgdGhpcy5fbmV4dFN0YWdlLl9wcmV2U3RhZ2UgPSBudWxsOyB9XG5cdFx0aWYgKHZhbHVlKSB7IHZhbHVlLl9wcmV2U3RhZ2UgPSB0aGlzOyB9XG5cdFx0dGhpcy5fbmV4dFN0YWdlID0gdmFsdWU7XG5cdH07XG5cdFxuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcblx0XHRcdG5leHRTdGFnZTogeyBnZXQ6IHAuX2dldF9uZXh0U3RhZ2UsIHNldDogcC5fc2V0X25leHRTdGFnZSB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHt9IC8vIFRPRE86IHVzZSBMb2dcblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEVhY2ggdGltZSB0aGUgdXBkYXRlIG1ldGhvZCBpcyBjYWxsZWQsIHRoZSBzdGFnZSB3aWxsIGNhbGwge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdGlja1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB1bmxlc3Mge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdGlja09uVXBkYXRlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlzIHNldCB0byBmYWxzZSxcblx0ICogYW5kIHRoZW4gcmVuZGVyIHRoZSBkaXNwbGF5IGxpc3QgdG8gdGhlIGNhbnZhcy5cblx0ICpcblx0ICogQG1ldGhvZCB1cGRhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gUHJvcHMgb2JqZWN0IHRvIHBhc3MgdG8gYHRpY2soKWAuIFNob3VsZCB1c3VhbGx5IGJlIGEge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IG9iamVjdCwgb3Igc2ltaWxhciBvYmplY3Qgd2l0aCBhIGRlbHRhIHByb3BlcnR5LlxuXHQgKiovXG5cdHAudXBkYXRlID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRpZiAoIXRoaXMuY2FudmFzKSB7IHJldHVybjsgfVxuXHRcdGlmICh0aGlzLnRpY2tPblVwZGF0ZSkgeyB0aGlzLnRpY2socHJvcHMpOyB9XG5cdFx0aWYgKHRoaXMuZGlzcGF0Y2hFdmVudChcImRyYXdzdGFydFwiLCBmYWxzZSwgdHJ1ZSkgPT09IGZhbHNlKSB7IHJldHVybjsgfVxuXHRcdGNyZWF0ZWpzLkRpc3BsYXlPYmplY3QuX3NuYXBUb1BpeGVsRW5hYmxlZCA9IHRoaXMuc25hcFRvUGl4ZWxFbmFibGVkO1xuXHRcdHZhciByID0gdGhpcy5kcmF3UmVjdCwgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cdFx0aWYgKHRoaXMuYXV0b0NsZWFyKSB7XG5cdFx0XHRpZiAocikgeyBjdHguY2xlYXJSZWN0KHIueCwgci55LCByLndpZHRoLCByLmhlaWdodCk7IH1cblx0XHRcdGVsc2UgeyBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoKzEsIHRoaXMuY2FudmFzLmhlaWdodCsxKTsgfVxuXHRcdH1cblx0XHRjdHguc2F2ZSgpO1xuXHRcdGlmICh0aGlzLmRyYXdSZWN0KSB7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHgucmVjdChyLngsIHIueSwgci53aWR0aCwgci5oZWlnaHQpO1xuXHRcdFx0Y3R4LmNsaXAoKTtcblx0XHR9XG5cdFx0dGhpcy51cGRhdGVDb250ZXh0KGN0eCk7XG5cdFx0dGhpcy5kcmF3KGN0eCwgZmFsc2UpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiZHJhd2VuZFwiKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBQcm9wYWdhdGVzIGEgdGljayBldmVudCB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuIFRoaXMgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgYnkge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdXBkYXRlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHVubGVzcyB7eyNjcm9zc0xpbmsgXCJTdGFnZS90aWNrT25VcGRhdGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaXMgc2V0IHRvIGZhbHNlLlxuXHQgKlxuXHQgKiBJZiBhIHByb3BzIG9iamVjdCBpcyBwYXNzZWQgdG8gYHRpY2soKWAsIHRoZW4gYWxsIG9mIGl0cyBwcm9wZXJ0aWVzIHdpbGwgYmUgY29waWVkIHRvIHRoZSBldmVudCBvYmplY3QgdGhhdCBpc1xuXHQgKiBwcm9wYWdhdGVkIHRvIGxpc3RlbmVycy5cblx0ICpcblx0ICogU29tZSB0aW1lLWJhc2VkIGZlYXR1cmVzIGluIEVhc2VsSlMgKGZvciBleGFtcGxlIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9mcmFtZXJhdGVcIn19e3svY3Jvc3NMaW5rfX0gcmVxdWlyZSB0aGF0XG5cdCAqIGEge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3RpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgb2JqZWN0IChvciBlcXVpdmFsZW50IG9iamVjdCB3aXRoIGEgZGVsdGEgcHJvcGVydHkpIGJlXG5cdCAqIHBhc3NlZCBhcyB0aGUgYHByb3BzYCBwYXJhbWV0ZXIgdG8gYHRpY2soKWAuIEZvciBleGFtcGxlOlxuXHQgKlxuXHQgKiBcdFRpY2tlci5vbihcInRpY2tcIiwgaGFuZGxlVGljayk7XG5cdCAqIFx0ZnVuY3Rpb24gaGFuZGxlVGljayhldnRPYmopIHtcblx0ICogXHRcdC8vIGNsb25lIHRoZSBldmVudCBvYmplY3QgZnJvbSBUaWNrZXIsIGFuZCBhZGQgc29tZSBjdXN0b20gZGF0YSB0byBpdDpcblx0ICogXHRcdHZhciBldnQgPSBldnRPYmouY2xvbmUoKS5zZXQoe2dyZWV0aW5nOlwiaGVsbG9cIiwgbmFtZTpcIndvcmxkXCJ9KTtcblx0ICogXHRcdFxuXHQgKiBcdFx0Ly8gcGFzcyBpdCB0byBzdGFnZS51cGRhdGUoKTpcblx0ICogXHRcdG15U3RhZ2UudXBkYXRlKGV2dCk7IC8vIHN1YnNlcXVlbnRseSBjYWxscyB0aWNrKCkgd2l0aCB0aGUgc2FtZSBwYXJhbVxuXHQgKiBcdH1cblx0ICogXHRcblx0ICogXHQvLyAuLi5cblx0ICogXHRteURpc3BsYXlPYmplY3Qub24oXCJ0aWNrXCIsIGhhbmRsZURpc3BsYXlPYmplY3RUaWNrKTtcblx0ICogXHRmdW5jdGlvbiBoYW5kbGVEaXNwbGF5T2JqZWN0VGljayhldnQpIHtcblx0ICogXHRcdGNvbnNvbGUubG9nKGV2dC5kZWx0YSk7IC8vIHRoZSBkZWx0YSBwcm9wZXJ0eSBmcm9tIHRoZSBUaWNrZXIgdGljayBldmVudCBvYmplY3Rcblx0ICogXHRcdGNvbnNvbGUubG9nKGV2dC5ncmVldGluZywgZXZ0Lm5hbWUpOyAvLyBjdXN0b20gZGF0YTogXCJoZWxsbyB3b3JsZFwiXG5cdCAqIFx0fVxuXHQgKiBcblx0ICogQG1ldGhvZCB0aWNrXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIEFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgY29waWVkIHRvIHRoZSBldmVudCBvYmplY3QuIFNob3VsZCB1c3VhbGx5IGJlIGEgVGlja2VyIGV2ZW50IG9iamVjdCwgb3Igc2ltaWxhciBvYmplY3Qgd2l0aCBhIGRlbHRhIHByb3BlcnR5LlxuXHQgKiovXG5cdHAudGljayA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0aWYgKCF0aGlzLnRpY2tFbmFibGVkIHx8IHRoaXMuZGlzcGF0Y2hFdmVudChcInRpY2tzdGFydFwiLCBmYWxzZSwgdHJ1ZSkgPT09IGZhbHNlKSB7IHJldHVybjsgfVxuXHRcdHZhciBldnRPYmogPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJ0aWNrXCIpO1xuXHRcdGlmIChwcm9wcykge1xuXHRcdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykge1xuXHRcdFx0XHRpZiAocHJvcHMuaGFzT3duUHJvcGVydHkobikpIHsgZXZ0T2JqW25dID0gcHJvcHNbbl07IH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fdGljayhldnRPYmopO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcInRpY2tlbmRcIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIERlZmF1bHQgZXZlbnQgaGFuZGxlciB0aGF0IGNhbGxzIHRoZSBTdGFnZSB7eyNjcm9zc0xpbmsgXCJTdGFnZS91cGRhdGVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIHdoZW4gYSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3RpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgaXMgcmVjZWl2ZWQuIFRoaXMgYWxsb3dzIHlvdSB0byByZWdpc3RlciBhIFN0YWdlIGluc3RhbmNlIGFzIGEgZXZlbnQgbGlzdGVuZXIgb24ge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGRpcmVjdGx5LCB1c2luZzpcblx0ICpcblx0ICogICAgICBUaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgbXlTdGFnZVwiKTtcblx0ICpcblx0ICogTm90ZSB0aGF0IGlmIHlvdSBzdWJzY3JpYmUgdG8gdGlja3MgdXNpbmcgdGhpcyBwYXR0ZXJuLCB0aGVuIHRoZSB0aWNrIGV2ZW50IG9iamVjdCB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHRvXG5cdCAqIGRpc3BsYXkgb2JqZWN0IHRpY2sgaGFuZGxlcnMsIGluc3RlYWQgb2YgPGNvZGU+ZGVsdGE8L2NvZGU+IGFuZCA8Y29kZT5wYXVzZWQ8L2NvZGU+IHBhcmFtZXRlcnMuXG5cdCAqIEBwcm9wZXJ0eSBoYW5kbGVFdmVudFxuXHQgKiBAdHlwZSBGdW5jdGlvblxuXHQgKiovXG5cdHAuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbihldnQpIHtcblx0XHRpZiAoZXZ0LnR5cGUgPT0gXCJ0aWNrXCIpIHsgdGhpcy51cGRhdGUoZXZ0KTsgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhcnMgdGhlIHRhcmdldCBjYW52YXMuIFVzZWZ1bCBpZiB7eyNjcm9zc0xpbmsgXCJTdGFnZS9hdXRvQ2xlYXI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaXMgc2V0IHRvIGBmYWxzZWAuXG5cdCAqIEBtZXRob2QgY2xlYXJcblx0ICoqL1xuXHRwLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmNhbnZhcykgeyByZXR1cm47IH1cblx0XHR2YXIgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCsxLCB0aGlzLmNhbnZhcy5oZWlnaHQrMSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBkYXRhIHVybCB0aGF0IGNvbnRhaW5zIGEgQmFzZTY0LWVuY29kZWQgaW1hZ2Ugb2YgdGhlIGNvbnRlbnRzIG9mIHRoZSBzdGFnZS4gVGhlIHJldHVybmVkIGRhdGEgdXJsIGNhblxuXHQgKiBiZSBzcGVjaWZpZWQgYXMgdGhlIHNyYyB2YWx1ZSBvZiBhbiBpbWFnZSBlbGVtZW50LlxuXHQgKiBAbWV0aG9kIHRvRGF0YVVSTFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2JhY2tncm91bmRDb2xvcl0gVGhlIGJhY2tncm91bmQgY29sb3IgdG8gYmUgdXNlZCBmb3IgdGhlIGdlbmVyYXRlZCBpbWFnZS4gQW55IHZhbGlkIENTUyBjb2xvclxuXHQgKiB2YWx1ZSBpcyBhbGxvd2VkLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBhIHRyYW5zcGFyZW50IGJhY2tncm91bmQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbbWltZVR5cGU9XCJpbWFnZS9wbmdcIl0gVGhlIE1JTUUgdHlwZSBvZiB0aGUgaW1hZ2UgZm9ybWF0IHRvIGJlIGNyZWF0ZS4gVGhlIGRlZmF1bHQgaXMgXCJpbWFnZS9wbmdcIi4gSWYgYW4gdW5rbm93biBNSU1FIHR5cGVcblx0ICogaXMgcGFzc2VkIGluLCBvciBpZiB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBzcGVjaWZpZWQgTUlNRSB0eXBlLCB0aGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBCYXNlNjQgZW5jb2RlZCBpbWFnZS5cblx0ICoqL1xuXHRwLnRvRGF0YVVSTCA9IGZ1bmN0aW9uKGJhY2tncm91bmRDb2xvciwgbWltZVR5cGUpIHtcblx0XHR2YXIgZGF0YSwgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKSwgdyA9IHRoaXMuY2FudmFzLndpZHRoLCBoID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuXG5cdFx0aWYgKGJhY2tncm91bmRDb2xvcikge1xuXHRcdFx0ZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdywgaCk7XG5cdFx0XHR2YXIgY29tcG9zaXRlT3BlcmF0aW9uID0gY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcblx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLW92ZXJcIjtcblx0XHRcdFxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcblx0XHRcdGN0eC5maWxsUmVjdCgwLCAwLCB3LCBoKTtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVVSTCA9IHRoaXMuY2FudmFzLnRvRGF0YVVSTChtaW1lVHlwZXx8XCJpbWFnZS9wbmdcIik7XG5cblx0XHRpZihiYWNrZ3JvdW5kQ29sb3IpIHtcblx0XHRcdGN0eC5wdXRJbWFnZURhdGEoZGF0YSwgMCwgMCk7XG5cdFx0XHRjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gY29tcG9zaXRlT3BlcmF0aW9uO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhVVJMO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbmFibGVzIG9yIGRpc2FibGVzIChieSBwYXNzaW5nIGEgZnJlcXVlbmN5IG9mIDApIG1vdXNlIG92ZXIgKHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2VvdmVyOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGFuZCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlb3V0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319KSBhbmQgcm9sbCBvdmVyIGV2ZW50cyAoe3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9yb2xsb3ZlcjpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBhbmQge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9yb2xsb3V0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319KSBmb3IgdGhpcyBzdGFnZSdzIGRpc3BsYXkgbGlzdC4gVGhlc2UgZXZlbnRzIGNhblxuXHQgKiBiZSBleHBlbnNpdmUgdG8gZ2VuZXJhdGUsIHNvIHRoZXkgYXJlIGRpc2FibGVkIGJ5IGRlZmF1bHQuIFRoZSBmcmVxdWVuY3kgb2YgdGhlIGV2ZW50cyBjYW4gYmUgY29udHJvbGxlZFxuXHQgKiBpbmRlcGVuZGVudGx5IG9mIG1vdXNlIG1vdmUgZXZlbnRzIHZpYSB0aGUgb3B0aW9uYWwgYGZyZXF1ZW5jeWAgcGFyYW1ldGVyLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIHN0YWdlID0gbmV3IGNyZWF0ZWpzLlN0YWdlKFwiY2FudmFzSWRcIik7XG5cdCAqICAgICAgc3RhZ2UuZW5hYmxlTW91c2VPdmVyKDEwKTsgLy8gMTAgdXBkYXRlcyBwZXIgc2Vjb25kXG5cdCAqXG5cdCAqIEBtZXRob2QgZW5hYmxlTW91c2VPdmVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZnJlcXVlbmN5PTIwXSBPcHRpb25hbCBwYXJhbSBzcGVjaWZ5aW5nIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyBwZXIgc2Vjb25kIHRvIGJyb2FkY2FzdFxuXHQgKiBtb3VzZSBvdmVyL291dCBldmVudHMuIFNldCB0byAwIHRvIGRpc2FibGUgbW91c2Ugb3ZlciBldmVudHMgY29tcGxldGVseS4gTWF4aW11bSBpcyA1MC4gQSBsb3dlciBmcmVxdWVuY3kgaXMgbGVzc1xuXHQgKiByZXNwb25zaXZlLCBidXQgdXNlcyBsZXNzIENQVS5cblx0ICoqL1xuXHRwLmVuYWJsZU1vdXNlT3ZlciA9IGZ1bmN0aW9uKGZyZXF1ZW5jeSkge1xuXHRcdGlmICh0aGlzLl9tb3VzZU92ZXJJbnRlcnZhbElEKSB7XG5cdFx0XHRjbGVhckludGVydmFsKHRoaXMuX21vdXNlT3ZlckludGVydmFsSUQpO1xuXHRcdFx0dGhpcy5fbW91c2VPdmVySW50ZXJ2YWxJRCA9IG51bGw7XG5cdFx0XHRpZiAoZnJlcXVlbmN5ID09IDApIHtcblx0XHRcdFx0dGhpcy5fdGVzdE1vdXNlT3Zlcih0cnVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGZyZXF1ZW5jeSA9PSBudWxsKSB7IGZyZXF1ZW5jeSA9IDIwOyB9XG5cdFx0ZWxzZSBpZiAoZnJlcXVlbmN5IDw9IDApIHsgcmV0dXJuOyB9XG5cdFx0dmFyIG8gPSB0aGlzO1xuXHRcdHRoaXMuX21vdXNlT3ZlckludGVydmFsSUQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpeyBvLl90ZXN0TW91c2VPdmVyKCk7IH0sIDEwMDAvTWF0aC5taW4oNTAsZnJlcXVlbmN5KSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHN0YWdlIGFkZHMgdG8gRE9NIGVsZW1lbnRzICh3aW5kb3csIGRvY3VtZW50IGFuZCBjYW52YXMpLiBJdCBpcyBnb29kXG5cdCAqIHByYWN0aWNlIHRvIGRpc2FibGUgZXZlbnRzIHdoZW4gZGlzcG9zaW5nIG9mIGEgU3RhZ2UgaW5zdGFuY2UsIG90aGVyd2lzZSB0aGUgc3RhZ2Ugd2lsbCBjb250aW51ZSB0byByZWNlaXZlXG5cdCAqIGV2ZW50cyBmcm9tIHRoZSBwYWdlLlxuXHQgKlxuXHQgKiBXaGVuIGNoYW5naW5nIHRoZSBjYW52YXMgcHJvcGVydHkgeW91IG11c3QgZGlzYWJsZSB0aGUgZXZlbnRzIG9uIHRoZSBvbGQgY2FudmFzLCBhbmQgZW5hYmxlIGV2ZW50cyBvbiB0aGVcblx0ICogbmV3IGNhbnZhcyBvciBtb3VzZSBldmVudHMgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZC4gRm9yIGV4YW1wbGU6XG5cdCAqXG5cdCAqICAgICAgbXlTdGFnZS5lbmFibGVET01FdmVudHMoZmFsc2UpO1xuXHQgKiAgICAgIG15U3RhZ2UuY2FudmFzID0gYW5vdGhlckNhbnZhcztcblx0ICogICAgICBteVN0YWdlLmVuYWJsZURPTUV2ZW50cyh0cnVlKTtcblx0ICpcblx0ICogQG1ldGhvZCBlbmFibGVET01FdmVudHNcblx0ICogQHBhcmFtIHtCb29sZWFufSBbZW5hYmxlPXRydWVdIEluZGljYXRlcyB3aGV0aGVyIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSBldmVudHMuIERlZmF1bHQgaXMgdHJ1ZS5cblx0ICoqL1xuXHRwLmVuYWJsZURPTUV2ZW50cyA9IGZ1bmN0aW9uKGVuYWJsZSkge1xuXHRcdGlmIChlbmFibGUgPT0gbnVsbCkgeyBlbmFibGUgPSB0cnVlOyB9XG5cdFx0dmFyIG4sIG8sIGxzID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnM7XG5cdFx0aWYgKCFlbmFibGUgJiYgbHMpIHtcblx0XHRcdGZvciAobiBpbiBscykge1xuXHRcdFx0XHRvID0gbHNbbl07XG5cdFx0XHRcdG8udC5yZW1vdmVFdmVudExpc3RlbmVyKG4sIG8uZiwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSBudWxsO1xuXHRcdH0gZWxzZSBpZiAoZW5hYmxlICYmICFscyAmJiB0aGlzLmNhbnZhcykge1xuXHRcdFx0dmFyIHQgPSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciA/IHdpbmRvdyA6IGRvY3VtZW50O1xuXHRcdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHRcdGxzID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSB7fTtcblx0XHRcdGxzW1wibW91c2V1cFwiXSA9IHt0OnQsIGY6ZnVuY3Rpb24oZSkgeyBfdGhpcy5faGFuZGxlTW91c2VVcChlKX0gfTtcblx0XHRcdGxzW1wibW91c2Vtb3ZlXCJdID0ge3Q6dCwgZjpmdW5jdGlvbihlKSB7IF90aGlzLl9oYW5kbGVNb3VzZU1vdmUoZSl9IH07XG5cdFx0XHRsc1tcImRibGNsaWNrXCJdID0ge3Q6dGhpcy5jYW52YXMsIGY6ZnVuY3Rpb24oZSkgeyBfdGhpcy5faGFuZGxlRG91YmxlQ2xpY2soZSl9IH07XG5cdFx0XHRsc1tcIm1vdXNlZG93blwiXSA9IHt0OnRoaXMuY2FudmFzLCBmOmZ1bmN0aW9uKGUpIHsgX3RoaXMuX2hhbmRsZU1vdXNlRG93bihlKX0gfTtcblxuXHRcdFx0Zm9yIChuIGluIGxzKSB7XG5cdFx0XHRcdG8gPSBsc1tuXTtcblx0XHRcdFx0by50LmFkZEV2ZW50TGlzdGVuZXIobiwgby5mLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdGFnZSBpbnN0YW5jZXMgY2Fubm90IGJlIGNsb25lZC5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyhcIlN0YWdlIGNhbm5vdCBiZSBjbG9uZWQuXCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbU3RhZ2UgKG5hbWU9XCIrICB0aGlzLm5hbWUgK1wiKV1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRFbGVtZW50UmVjdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVcblx0ICoqL1xuXHRwLl9nZXRFbGVtZW50UmVjdCA9IGZ1bmN0aW9uKGUpIHtcblx0XHR2YXIgYm91bmRzO1xuXHRcdHRyeSB7IGJvdW5kcyA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IH0gLy8gdGhpcyBjYW4gZmFpbCBvbiBkaXNjb25uZWN0ZWQgRE9NIGVsZW1lbnRzIGluIElFOVxuXHRcdGNhdGNoIChlcnIpIHsgYm91bmRzID0ge3RvcDogZS5vZmZzZXRUb3AsIGxlZnQ6IGUub2Zmc2V0TGVmdCwgd2lkdGg6ZS5vZmZzZXRXaWR0aCwgaGVpZ2h0OmUub2Zmc2V0SGVpZ2h0fTsgfVxuXG5cdFx0dmFyIG9mZlggPSAod2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LnNjcm9sbExlZnQgfHwgMCkgLSAoZG9jdW1lbnQuY2xpZW50TGVmdCB8fCBkb2N1bWVudC5ib2R5LmNsaWVudExlZnQgfHwgMCk7XG5cdFx0dmFyIG9mZlkgPSAod2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LnNjcm9sbFRvcCB8fCAwKSAtIChkb2N1bWVudC5jbGllbnRUb3AgIHx8IGRvY3VtZW50LmJvZHkuY2xpZW50VG9wICB8fCAwKTtcblxuXHRcdHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA/IGdldENvbXB1dGVkU3R5bGUoZSxudWxsKSA6IGUuY3VycmVudFN0eWxlOyAvLyBJRSA8OSBjb21wYXRpYmlsaXR5LlxuXHRcdHZhciBwYWRMID0gcGFyc2VJbnQoc3R5bGVzLnBhZGRpbmdMZWZ0KStwYXJzZUludChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoKTtcblx0XHR2YXIgcGFkVCA9IHBhcnNlSW50KHN0eWxlcy5wYWRkaW5nVG9wKStwYXJzZUludChzdHlsZXMuYm9yZGVyVG9wV2lkdGgpO1xuXHRcdHZhciBwYWRSID0gcGFyc2VJbnQoc3R5bGVzLnBhZGRpbmdSaWdodCkrcGFyc2VJbnQoc3R5bGVzLmJvcmRlclJpZ2h0V2lkdGgpO1xuXHRcdHZhciBwYWRCID0gcGFyc2VJbnQoc3R5bGVzLnBhZGRpbmdCb3R0b20pK3BhcnNlSW50KHN0eWxlcy5ib3JkZXJCb3R0b21XaWR0aCk7XG5cblx0XHQvLyBub3RlOiBpbiBzb21lIGJyb3dzZXJzIGJvdW5kcyBwcm9wZXJ0aWVzIGFyZSByZWFkIG9ubHkuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGxlZnQ6IGJvdW5kcy5sZWZ0K29mZlgrcGFkTCxcblx0XHRcdHJpZ2h0OiBib3VuZHMucmlnaHQrb2ZmWC1wYWRSLFxuXHRcdFx0dG9wOiBib3VuZHMudG9wK29mZlkrcGFkVCxcblx0XHRcdGJvdHRvbTogYm91bmRzLmJvdHRvbStvZmZZLXBhZEJcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldFBvaW50ZXJEYXRhXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGlkXG5cdCAqKi9cblx0cC5fZ2V0UG9pbnRlckRhdGEgPSBmdW5jdGlvbihpZCkge1xuXHRcdHZhciBkYXRhID0gdGhpcy5fcG9pbnRlckRhdGFbaWRdO1xuXHRcdGlmICghZGF0YSkgeyBkYXRhID0gdGhpcy5fcG9pbnRlckRhdGFbaWRdID0ge3g6MCx5OjB9OyB9XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1vdXNlTW92ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuXHQgKiovXG5cdHAuX2hhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uKGUpIHtcblx0XHRpZighZSl7IGUgPSB3aW5kb3cuZXZlbnQ7IH1cblx0XHR0aGlzLl9oYW5kbGVQb2ludGVyTW92ZSgtMSwgZSwgZS5wYWdlWCwgZS5wYWdlWSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZVBvaW50ZXJNb3ZlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGlkXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhZ2VYXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwYWdlWVxuXHQgKiBAcGFyYW0ge1N0YWdlfSBvd25lciBJbmRpY2F0ZXMgdGhhdCB0aGUgZXZlbnQgaGFzIGFscmVhZHkgYmVlbiBjYXB0dXJlZCAmIGhhbmRsZWQgYnkgdGhlIGluZGljYXRlZCBzdGFnZS5cblx0ICoqL1xuXHRwLl9oYW5kbGVQb2ludGVyTW92ZSA9IGZ1bmN0aW9uKGlkLCBlLCBwYWdlWCwgcGFnZVksIG93bmVyKSB7XG5cdFx0aWYgKHRoaXMuX3ByZXZTdGFnZSAmJiBvd25lciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybjsgfSAvLyByZWR1bmRhbnQgbGlzdGVuZXIuXG5cdFx0aWYgKCF0aGlzLmNhbnZhcykgeyByZXR1cm47IH1cblx0XHR2YXIgbmV4dFN0YWdlPXRoaXMuX25leHRTdGFnZSwgbz10aGlzLl9nZXRQb2ludGVyRGF0YShpZCk7XG5cblx0XHR2YXIgaW5Cb3VuZHMgPSBvLmluQm91bmRzO1xuXHRcdHRoaXMuX3VwZGF0ZVBvaW50ZXJQb3NpdGlvbihpZCwgZSwgcGFnZVgsIHBhZ2VZKTtcblx0XHRpZiAoaW5Cb3VuZHMgfHwgby5pbkJvdW5kcyB8fCB0aGlzLm1vdXNlTW92ZU91dHNpZGUpIHtcblx0XHRcdGlmIChpZCA9PT0gLTEgJiYgby5pbkJvdW5kcyA9PSAhaW5Cb3VuZHMpIHtcblx0XHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRoaXMsIChpbkJvdW5kcyA/IFwibW91c2VsZWF2ZVwiIDogXCJtb3VzZWVudGVyXCIpLCBmYWxzZSwgaWQsIG8sIGUpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQodGhpcywgXCJzdGFnZW1vdXNlbW92ZVwiLCBmYWxzZSwgaWQsIG8sIGUpO1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KG8udGFyZ2V0LCBcInByZXNzbW92ZVwiLCB0cnVlLCBpZCwgbywgZSk7XG5cdFx0fVxuXHRcdFxuXHRcdG5leHRTdGFnZSYmbmV4dFN0YWdlLl9oYW5kbGVQb2ludGVyTW92ZShpZCwgZSwgcGFnZVgsIHBhZ2VZLCBudWxsKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfdXBkYXRlUG9pbnRlclBvc2l0aW9uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGlkXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhZ2VYXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwYWdlWVxuXHQgKiovXG5cdHAuX3VwZGF0ZVBvaW50ZXJQb3NpdGlvbiA9IGZ1bmN0aW9uKGlkLCBlLCBwYWdlWCwgcGFnZVkpIHtcblx0XHR2YXIgcmVjdCA9IHRoaXMuX2dldEVsZW1lbnRSZWN0KHRoaXMuY2FudmFzKTtcblx0XHRwYWdlWCAtPSByZWN0LmxlZnQ7XG5cdFx0cGFnZVkgLT0gcmVjdC50b3A7XG5cblx0XHR2YXIgdyA9IHRoaXMuY2FudmFzLndpZHRoO1xuXHRcdHZhciBoID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuXHRcdHBhZ2VYIC89IChyZWN0LnJpZ2h0LXJlY3QubGVmdCkvdztcblx0XHRwYWdlWSAvPSAocmVjdC5ib3R0b20tcmVjdC50b3ApL2g7XG5cdFx0dmFyIG8gPSB0aGlzLl9nZXRQb2ludGVyRGF0YShpZCk7XG5cdFx0aWYgKG8uaW5Cb3VuZHMgPSAocGFnZVggPj0gMCAmJiBwYWdlWSA+PSAwICYmIHBhZ2VYIDw9IHctMSAmJiBwYWdlWSA8PSBoLTEpKSB7XG5cdFx0XHRvLnggPSBwYWdlWDtcblx0XHRcdG8ueSA9IHBhZ2VZO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5tb3VzZU1vdmVPdXRzaWRlKSB7XG5cdFx0XHRvLnggPSBwYWdlWCA8IDAgPyAwIDogKHBhZ2VYID4gdy0xID8gdy0xIDogcGFnZVgpO1xuXHRcdFx0by55ID0gcGFnZVkgPCAwID8gMCA6IChwYWdlWSA+IGgtMSA/IGgtMSA6IHBhZ2VZKTtcblx0XHR9XG5cblx0XHRvLnBvc0V2dE9iaiA9IGU7XG5cdFx0by5yYXdYID0gcGFnZVg7XG5cdFx0by5yYXdZID0gcGFnZVk7XG5cblx0XHRpZiAoaWQgPT09IHRoaXMuX3ByaW1hcnlQb2ludGVySUQgfHwgaWQgPT09IC0xKSB7XG5cdFx0XHR0aGlzLm1vdXNlWCA9IG8ueDtcblx0XHRcdHRoaXMubW91c2VZID0gby55O1xuXHRcdFx0dGhpcy5tb3VzZUluQm91bmRzID0gby5pbkJvdW5kcztcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1vdXNlVXBcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcblx0ICoqL1xuXHRwLl9oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24oZSkge1xuXHRcdHRoaXMuX2hhbmRsZVBvaW50ZXJVcCgtMSwgZSwgZmFsc2UpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVQb2ludGVyVXBcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaWRcblx0ICogQHBhcmFtIHtFdmVudH0gZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNsZWFyXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IG93bmVyIEluZGljYXRlcyB0aGF0IHRoZSBldmVudCBoYXMgYWxyZWFkeSBiZWVuIGNhcHR1cmVkICYgaGFuZGxlZCBieSB0aGUgaW5kaWNhdGVkIHN0YWdlLlxuXHQgKiovXG5cdHAuX2hhbmRsZVBvaW50ZXJVcCA9IGZ1bmN0aW9uKGlkLCBlLCBjbGVhciwgb3duZXIpIHtcblx0XHR2YXIgbmV4dFN0YWdlID0gdGhpcy5fbmV4dFN0YWdlLCBvID0gdGhpcy5fZ2V0UG9pbnRlckRhdGEoaWQpO1xuXHRcdGlmICh0aGlzLl9wcmV2U3RhZ2UgJiYgb3duZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm47IH0gLy8gcmVkdW5kYW50IGxpc3RlbmVyLlxuXHRcdFxuXHRcdHZhciB0YXJnZXQ9bnVsbCwgb1RhcmdldCA9IG8udGFyZ2V0O1xuXHRcdGlmICghb3duZXIgJiYgKG9UYXJnZXQgfHwgbmV4dFN0YWdlKSkgeyB0YXJnZXQgPSB0aGlzLl9nZXRPYmplY3RzVW5kZXJQb2ludChvLngsIG8ueSwgbnVsbCwgdHJ1ZSk7IH1cblx0XHRcblx0XHRpZiAoby5kb3duKSB7IHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudCh0aGlzLCBcInN0YWdlbW91c2V1cFwiLCBmYWxzZSwgaWQsIG8sIGUsIHRhcmdldCk7IG8uZG93biA9IGZhbHNlOyB9XG5cdFx0XG5cdFx0aWYgKHRhcmdldCA9PSBvVGFyZ2V0KSB7IHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudChvVGFyZ2V0LCBcImNsaWNrXCIsIHRydWUsIGlkLCBvLCBlKTsgfVxuXHRcdHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudChvVGFyZ2V0LCBcInByZXNzdXBcIiwgdHJ1ZSwgaWQsIG8sIGUpO1xuXHRcdFxuXHRcdGlmIChjbGVhcikge1xuXHRcdFx0aWYgKGlkPT10aGlzLl9wcmltYXJ5UG9pbnRlcklEKSB7IHRoaXMuX3ByaW1hcnlQb2ludGVySUQgPSBudWxsOyB9XG5cdFx0XHRkZWxldGUodGhpcy5fcG9pbnRlckRhdGFbaWRdKTtcblx0XHR9IGVsc2UgeyBvLnRhcmdldCA9IG51bGw7IH1cblx0XHRcblx0XHRuZXh0U3RhZ2UmJm5leHRTdGFnZS5faGFuZGxlUG9pbnRlclVwKGlkLCBlLCBjbGVhciwgb3duZXIgfHwgdGFyZ2V0ICYmIHRoaXMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNb3VzZURvd25cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcblx0ICoqL1xuXHRwLl9oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbihlKSB7XG5cdFx0dGhpcy5faGFuZGxlUG9pbnRlckRvd24oLTEsIGUsIGUucGFnZVgsIGUucGFnZVkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVQb2ludGVyRG93blxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwYWdlWFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcGFnZVlcblx0ICogQHBhcmFtIHtTdGFnZX0gb3duZXIgSW5kaWNhdGVzIHRoYXQgdGhlIGV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gY2FwdHVyZWQgJiBoYW5kbGVkIGJ5IHRoZSBpbmRpY2F0ZWQgc3RhZ2UuXG5cdCAqKi9cblx0cC5faGFuZGxlUG9pbnRlckRvd24gPSBmdW5jdGlvbihpZCwgZSwgcGFnZVgsIHBhZ2VZLCBvd25lcikge1xuXHRcdGlmICh0aGlzLnByZXZlbnRTZWxlY3Rpb24pIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG5cdFx0aWYgKHRoaXMuX3ByaW1hcnlQb2ludGVySUQgPT0gbnVsbCB8fCBpZCA9PT0gLTEpIHsgdGhpcy5fcHJpbWFyeVBvaW50ZXJJRCA9IGlkOyB9IC8vIG1vdXNlIGFsd2F5cyB0YWtlcyBvdmVyLlxuXHRcdFxuXHRcdGlmIChwYWdlWSAhPSBudWxsKSB7IHRoaXMuX3VwZGF0ZVBvaW50ZXJQb3NpdGlvbihpZCwgZSwgcGFnZVgsIHBhZ2VZKTsgfVxuXHRcdHZhciB0YXJnZXQgPSBudWxsLCBuZXh0U3RhZ2UgPSB0aGlzLl9uZXh0U3RhZ2UsIG8gPSB0aGlzLl9nZXRQb2ludGVyRGF0YShpZCk7XG5cdFx0aWYgKCFvd25lcikgeyB0YXJnZXQgPSBvLnRhcmdldCA9IHRoaXMuX2dldE9iamVjdHNVbmRlclBvaW50KG8ueCwgby55LCBudWxsLCB0cnVlKTsgfVxuXG5cdFx0aWYgKG8uaW5Cb3VuZHMpIHsgdGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRoaXMsIFwic3RhZ2Vtb3VzZWRvd25cIiwgZmFsc2UsIGlkLCBvLCBlLCB0YXJnZXQpOyBvLmRvd24gPSB0cnVlOyB9XG5cdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRhcmdldCwgXCJtb3VzZWRvd25cIiwgdHJ1ZSwgaWQsIG8sIGUpO1xuXHRcdFxuXHRcdG5leHRTdGFnZSYmbmV4dFN0YWdlLl9oYW5kbGVQb2ludGVyRG93bihpZCwgZSwgcGFnZVgsIHBhZ2VZLCBvd25lciB8fCB0YXJnZXQgJiYgdGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3Rlc3RNb3VzZU92ZXJcblx0ICogQHBhcmFtIHtCb29sZWFufSBjbGVhciBJZiB0cnVlLCBjbGVhcnMgdGhlIG1vdXNlb3ZlciAvIHJvbGxvdmVyIChpZS4gbm8gdGFyZ2V0KVxuXHQgKiBAcGFyYW0ge1N0YWdlfSBvd25lciBJbmRpY2F0ZXMgdGhhdCB0aGUgZXZlbnQgaGFzIGFscmVhZHkgYmVlbiBjYXB0dXJlZCAmIGhhbmRsZWQgYnkgdGhlIGluZGljYXRlZCBzdGFnZS5cblx0ICogQHBhcmFtIHtTdGFnZX0gZXZlbnRUYXJnZXQgVGhlIHN0YWdlIHRoYXQgdGhlIGN1cnNvciBpcyBhY3RpdmVseSBvdmVyLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fdGVzdE1vdXNlT3ZlciA9IGZ1bmN0aW9uKGNsZWFyLCBvd25lciwgZXZlbnRUYXJnZXQpIHtcblx0XHRpZiAodGhpcy5fcHJldlN0YWdlICYmIG93bmVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9IC8vIHJlZHVuZGFudCBsaXN0ZW5lci5cblx0XHRcblx0XHR2YXIgbmV4dFN0YWdlID0gdGhpcy5fbmV4dFN0YWdlO1xuXHRcdGlmICghdGhpcy5fbW91c2VPdmVySW50ZXJ2YWxJRCkge1xuXHRcdFx0Ly8gbm90IGVuYWJsZWQgZm9yIG1vdXNlb3ZlciwgYnV0IHNob3VsZCBzdGlsbCByZWxheSB0aGUgZXZlbnQuXG5cdFx0XHRuZXh0U3RhZ2UmJm5leHRTdGFnZS5fdGVzdE1vdXNlT3ZlcihjbGVhciwgb3duZXIsIGV2ZW50VGFyZ2V0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIG8gPSB0aGlzLl9nZXRQb2ludGVyRGF0YSgtMSk7XG5cdFx0Ly8gb25seSB1cGRhdGUgaWYgdGhlIG1vdXNlIHBvc2l0aW9uIGhhcyBjaGFuZ2VkLiBUaGlzIHByb3ZpZGVzIGEgbG90IG9mIG9wdGltaXphdGlvbiwgYnV0IGhhcyBzb21lIHRyYWRlLW9mZnMuXG5cdFx0aWYgKCFvIHx8ICghY2xlYXIgJiYgdGhpcy5tb3VzZVggPT0gdGhpcy5fbW91c2VPdmVyWCAmJiB0aGlzLm1vdXNlWSA9PSB0aGlzLl9tb3VzZU92ZXJZICYmIHRoaXMubW91c2VJbkJvdW5kcykpIHsgcmV0dXJuOyB9XG5cdFx0XG5cdFx0dmFyIGUgPSBvLnBvc0V2dE9iajtcblx0XHR2YXIgaXNFdmVudFRhcmdldCA9IGV2ZW50VGFyZ2V0IHx8IGUmJihlLnRhcmdldCA9PSB0aGlzLmNhbnZhcyk7XG5cdFx0dmFyIHRhcmdldD1udWxsLCBjb21tb24gPSAtMSwgY3Vyc29yPVwiXCIsIHQsIGksIGw7XG5cdFx0XG5cdFx0aWYgKCFvd25lciAmJiAoY2xlYXIgfHwgdGhpcy5tb3VzZUluQm91bmRzICYmIGlzRXZlbnRUYXJnZXQpKSB7XG5cdFx0XHR0YXJnZXQgPSB0aGlzLl9nZXRPYmplY3RzVW5kZXJQb2ludCh0aGlzLm1vdXNlWCwgdGhpcy5tb3VzZVksIG51bGwsIHRydWUpO1xuXHRcdFx0dGhpcy5fbW91c2VPdmVyWCA9IHRoaXMubW91c2VYO1xuXHRcdFx0dGhpcy5fbW91c2VPdmVyWSA9IHRoaXMubW91c2VZO1xuXHRcdH1cblxuXHRcdHZhciBvbGRMaXN0ID0gdGhpcy5fbW91c2VPdmVyVGFyZ2V0fHxbXTtcblx0XHR2YXIgb2xkVGFyZ2V0ID0gb2xkTGlzdFtvbGRMaXN0Lmxlbmd0aC0xXTtcblx0XHR2YXIgbGlzdCA9IHRoaXMuX21vdXNlT3ZlclRhcmdldCA9IFtdO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgYW5jZXN0b3IgbGlzdCBhbmQgY2hlY2sgZm9yIGN1cnNvcjpcblx0XHR0ID0gdGFyZ2V0O1xuXHRcdHdoaWxlICh0KSB7XG5cdFx0XHRsaXN0LnVuc2hpZnQodCk7XG5cdFx0XHRpZiAoIWN1cnNvcikgeyBjdXJzb3IgPSB0LmN1cnNvcjsgfVxuXHRcdFx0dCA9IHQucGFyZW50O1xuXHRcdH1cblx0XHR0aGlzLmNhbnZhcy5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG5cdFx0aWYgKCFvd25lciAmJiBldmVudFRhcmdldCkgeyBldmVudFRhcmdldC5jYW52YXMuc3R5bGUuY3Vyc29yID0gY3Vyc29yOyB9XG5cblx0XHQvLyBmaW5kIGNvbW1vbiBhbmNlc3Rvcjpcblx0XHRmb3IgKGk9MCxsPWxpc3QubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0aWYgKGxpc3RbaV0gIT0gb2xkTGlzdFtpXSkgeyBicmVhazsgfVxuXHRcdFx0Y29tbW9uID0gaTtcblx0XHR9XG5cblx0XHRpZiAob2xkVGFyZ2V0ICE9IHRhcmdldCkge1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KG9sZFRhcmdldCwgXCJtb3VzZW91dFwiLCB0cnVlLCAtMSwgbywgZSwgdGFyZ2V0KTtcblx0XHR9XG5cblx0XHRmb3IgKGk9b2xkTGlzdC5sZW5ndGgtMTsgaT5jb21tb247IGktLSkge1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KG9sZExpc3RbaV0sIFwicm9sbG91dFwiLCBmYWxzZSwgLTEsIG8sIGUsIHRhcmdldCk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpPWxpc3QubGVuZ3RoLTE7IGk+Y29tbW9uOyBpLS0pIHtcblx0XHRcdHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudChsaXN0W2ldLCBcInJvbGxvdmVyXCIsIGZhbHNlLCAtMSwgbywgZSwgb2xkVGFyZ2V0KTtcblx0XHR9XG5cblx0XHRpZiAob2xkVGFyZ2V0ICE9IHRhcmdldCkge1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRhcmdldCwgXCJtb3VzZW92ZXJcIiwgdHJ1ZSwgLTEsIG8sIGUsIG9sZFRhcmdldCk7XG5cdFx0fVxuXHRcdFxuXHRcdG5leHRTdGFnZSYmbmV4dFN0YWdlLl90ZXN0TW91c2VPdmVyKGNsZWFyLCBvd25lciB8fCB0YXJnZXQgJiYgdGhpcywgZXZlbnRUYXJnZXQgfHwgaXNFdmVudFRhcmdldCAmJiB0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlRG91YmxlQ2xpY2tcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcblx0ICogQHBhcmFtIHtTdGFnZX0gb3duZXIgSW5kaWNhdGVzIHRoYXQgdGhlIGV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gY2FwdHVyZWQgJiBoYW5kbGVkIGJ5IHRoZSBpbmRpY2F0ZWQgc3RhZ2UuXG5cdCAqKi9cblx0cC5faGFuZGxlRG91YmxlQ2xpY2sgPSBmdW5jdGlvbihlLCBvd25lcikge1xuXHRcdHZhciB0YXJnZXQ9bnVsbCwgbmV4dFN0YWdlPXRoaXMuX25leHRTdGFnZSwgbz10aGlzLl9nZXRQb2ludGVyRGF0YSgtMSk7XG5cdFx0aWYgKCFvd25lcikge1xuXHRcdFx0dGFyZ2V0ID0gdGhpcy5fZ2V0T2JqZWN0c1VuZGVyUG9pbnQoby54LCBvLnksIG51bGwsIHRydWUpO1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRhcmdldCwgXCJkYmxjbGlja1wiLCB0cnVlLCAtMSwgbywgZSk7XG5cdFx0fVxuXHRcdG5leHRTdGFnZSYmbmV4dFN0YWdlLl9oYW5kbGVEb3VibGVDbGljayhlLCBvd25lciB8fCB0YXJnZXQgJiYgdGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2Rpc3BhdGNoTW91c2VFdmVudFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gdGFyZ2V0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYnViYmxlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9pbnRlcklkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvXG5cdCAqIEBwYXJhbSB7TW91c2VFdmVudH0gW25hdGl2ZUV2ZW50XVxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IFtyZWxhdGVkVGFyZ2V0XVxuXHQgKiovXG5cdHAuX2Rpc3BhdGNoTW91c2VFdmVudCA9IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgYnViYmxlcywgcG9pbnRlcklkLCBvLCBuYXRpdmVFdmVudCwgcmVsYXRlZFRhcmdldCkge1xuXHRcdC8vIFRPRE86IG1pZ2h0IGJlIHdvcnRoIGVpdGhlciByZXVzaW5nIE1vdXNlRXZlbnQgaW5zdGFuY2VzLCBvciBhZGRpbmcgYSB3aWxsVHJpZ2dlciBtZXRob2QgdG8gYXZvaWQgR0MuXG5cdFx0aWYgKCF0YXJnZXQgfHwgKCFidWJibGVzICYmICF0YXJnZXQuaGFzRXZlbnRMaXN0ZW5lcih0eXBlKSkpIHsgcmV0dXJuOyB9XG5cdFx0Lypcblx0XHQvLyBUT0RPOiBhY2NvdW50IGZvciBzdGFnZSB0cmFuc2Zvcm1hdGlvbnM/XG5cdFx0dGhpcy5fbXR4ID0gdGhpcy5nZXRDb25jYXRlbmF0ZWRNYXRyaXgodGhpcy5fbXR4KS5pbnZlcnQoKTtcblx0XHR2YXIgcHQgPSB0aGlzLl9tdHgudHJhbnNmb3JtUG9pbnQoby54LCBvLnkpO1xuXHRcdHZhciBldnQgPSBuZXcgY3JlYXRlanMuTW91c2VFdmVudCh0eXBlLCBidWJibGVzLCBmYWxzZSwgcHQueCwgcHQueSwgbmF0aXZlRXZlbnQsIHBvaW50ZXJJZCwgcG9pbnRlcklkPT10aGlzLl9wcmltYXJ5UG9pbnRlcklEIHx8IHBvaW50ZXJJZD09LTEsIG8ucmF3WCwgby5yYXdZKTtcblx0XHQqL1xuXHRcdHZhciBldnQgPSBuZXcgY3JlYXRlanMuTW91c2VFdmVudCh0eXBlLCBidWJibGVzLCBmYWxzZSwgby54LCBvLnksIG5hdGl2ZUV2ZW50LCBwb2ludGVySWQsIHBvaW50ZXJJZCA9PT0gdGhpcy5fcHJpbWFyeVBvaW50ZXJJRCB8fCBwb2ludGVySWQgPT09IC0xLCBvLnJhd1gsIG8ucmF3WSwgcmVsYXRlZFRhcmdldCk7XG5cdFx0dGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZ0KTtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLlN0YWdlID0gY3JlYXRlanMucHJvbW90ZShTdGFnZSwgXCJDb250YWluZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQml0bWFwLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFxuXHQvKipcblx0ICogQSBCaXRtYXAgcmVwcmVzZW50cyBhbiBJbWFnZSwgQ2FudmFzLCBvciBWaWRlbyBpbiB0aGUgZGlzcGxheSBsaXN0LiBBIEJpdG1hcCBjYW4gYmUgaW5zdGFudGlhdGVkIHVzaW5nIGFuIGV4aXN0aW5nXG5cdCAqIEhUTUwgZWxlbWVudCwgb3IgYSBzdHJpbmcuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgYml0bWFwID0gbmV3IGNyZWF0ZWpzLkJpdG1hcChcImltYWdlUGF0aC5qcGdcIik7XG5cdCAqXG5cdCAqIDxzdHJvbmc+Tm90ZXM6PC9zdHJvbmc+XG5cdCAqIDxvbD5cblx0ICogICAgIDxsaT5XaGVuIGEgc3RyaW5nIHBhdGggb3IgaW1hZ2UgdGFnIHRoYXQgaXMgbm90IHlldCBsb2FkZWQgaXMgdXNlZCwgdGhlIHN0YWdlIG1heSBuZWVkIHRvIGJlIHJlZHJhd24gYmVmb3JlIGl0XG5cdCAqICAgICAgd2lsbCBiZSBkaXNwbGF5ZWQuPC9saT5cblx0ICogICAgIDxsaT5CaXRtYXBzIHdpdGggYW4gU1ZHIHNvdXJjZSBjdXJyZW50bHkgd2lsbCBub3QgcmVzcGVjdCBhbiBhbHBoYSB2YWx1ZSBvdGhlciB0aGFuIDAgb3IgMS4gVG8gZ2V0IGFyb3VuZCB0aGlzLFxuXHQgKiAgICAgdGhlIEJpdG1hcCBjYW4gYmUgY2FjaGVkLjwvbGk+XG5cdCAqICAgICA8bGk+Qml0bWFwcyB3aXRoIGFuIFNWRyBzb3VyY2Ugd2lsbCB0YWludCB0aGUgY2FudmFzIHdpdGggY3Jvc3Mtb3JpZ2luIGRhdGEsIHdoaWNoIHByZXZlbnRzIGludGVyYWN0aXZpdHkuIFRoaXNcblx0ICogICAgIGhhcHBlbnMgaW4gYWxsIGJyb3dzZXJzIGV4Y2VwdCByZWNlbnQgRmlyZWZveCBidWlsZHMuPC9saT5cblx0ICogICAgIDxsaT5JbWFnZXMgbG9hZGVkIGNyb3NzLW9yaWdpbiB3aWxsIHRocm93IGNyb3NzLW9yaWdpbiBzZWN1cml0eSBlcnJvcnMgd2hlbiBpbnRlcmFjdGVkIHdpdGggdXNpbmcgYSBtb3VzZSwgdXNpbmdcblx0ICogICAgIG1ldGhvZHMgc3VjaCBhcyBgZ2V0T2JqZWN0VW5kZXJQb2ludGAsIG9yIHVzaW5nIGZpbHRlcnMsIG9yIGNhY2hpbmcuIFlvdSBjYW4gZ2V0IGFyb3VuZCB0aGlzIGJ5IHNldHRpbmdcblx0ICogICAgIGBjcm9zc09yaWdpbmAgZmxhZ3Mgb24geW91ciBpbWFnZXMgYmVmb3JlIHBhc3NpbmcgdGhlbSB0byBFYXNlbEpTLCBlZzogYGltZy5jcm9zc09yaWdpbj1cIkFub255bW91c1wiO2A8L2xpPlxuXHQgKiA8L29sPlxuXHQgKlxuXHQgKiBAY2xhc3MgQml0bWFwXG5cdCAqIEBleHRlbmRzIERpc3BsYXlPYmplY3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudCB8IFN0cmluZ30gaW1hZ2VPclVyaSBUaGUgc291cmNlIG9iamVjdCBvciBVUkkgdG8gYW4gaW1hZ2UgdG9cblx0ICogZGlzcGxheS4gVGhpcyBjYW4gYmUgZWl0aGVyIGFuIEltYWdlLCBDYW52YXMsIG9yIFZpZGVvIG9iamVjdCwgb3IgYSBzdHJpbmcgVVJJIHRvIGFuIGltYWdlIGZpbGUgdG8gbG9hZCBhbmQgdXNlLlxuXHQgKiBJZiBpdCBpcyBhIFVSSSwgYSBuZXcgSW1hZ2Ugb2JqZWN0IHdpbGwgYmUgY29uc3RydWN0ZWQgYW5kIGFzc2lnbmVkIHRvIHRoZSAuaW1hZ2UgcHJvcGVydHkuXG5cdCAqKi9cblx0ZnVuY3Rpb24gQml0bWFwKGltYWdlT3JVcmkpIHtcblx0XHR0aGlzLkRpc3BsYXlPYmplY3RfY29uc3RydWN0b3IoKTtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIGltYWdlIHRvIHJlbmRlci4gVGhpcyBjYW4gYmUgYW4gSW1hZ2UsIGEgQ2FudmFzLCBvciBhIFZpZGVvLiBOb3QgYWxsIGJyb3dzZXJzIChlc3BlY2lhbGx5XG5cdFx0ICogbW9iaWxlIGJyb3dzZXJzKSBzdXBwb3J0IGRyYXdpbmcgdmlkZW8gdG8gYSBjYW52YXMuXG5cdFx0ICogQHByb3BlcnR5IGltYWdlXG5cdFx0ICogQHR5cGUgSFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudFxuXHRcdCAqKi9cblx0XHRpZiAodHlwZW9mIGltYWdlT3JVcmkgPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dGhpcy5pbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG5cdFx0XHR0aGlzLmltYWdlLnNyYyA9IGltYWdlT3JVcmk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuaW1hZ2UgPSBpbWFnZU9yVXJpO1xuXHRcdH1cblx0XG5cdFx0LyoqXG5cdFx0ICogU3BlY2lmaWVzIGFuIGFyZWEgb2YgdGhlIHNvdXJjZSBpbWFnZSB0byBkcmF3LiBJZiBvbWl0dGVkLCB0aGUgd2hvbGUgaW1hZ2Ugd2lsbCBiZSBkcmF3bi5cblx0XHQgKiBOb3RlIHRoYXQgdmlkZW8gc291cmNlcyBtdXN0IGhhdmUgYSB3aWR0aCAvIGhlaWdodCBzZXQgdG8gd29yayBjb3JyZWN0bHkgd2l0aCBgc291cmNlUmVjdGAuXG5cdFx0ICogQHByb3BlcnR5IHNvdXJjZVJlY3Rcblx0XHQgKiBAdHlwZSBSZWN0YW5nbGVcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5zb3VyY2VSZWN0ID0gbnVsbDtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChCaXRtYXAsIGNyZWF0ZWpzLkRpc3BsYXlPYmplY3QpO1xuXHRcblx0XG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIENvbnN0cnVjdG9yIGFsaWFzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gVGhpcyBtZXRob2Qgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucy5cblx0ICogU3ViY2xhc3NlcyBzaG91bGQgYmUgdXBkYXRlZCB0byB1c2Uge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZHNcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2YgYGNyZWF0ZWpzLnByb21vdGUoKWBcblx0ICoqL1xuXHRwLmluaXRpYWxpemUgPSBCaXRtYXA7IC8vIFRPRE86IGRlcHJlY2F0ZWQuXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXMuXG5cdCAqIFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3Igd2hldGhlciBpdCB3b3VsZCBiZSB2aXNpYmxlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgc3RhZ2UuXG5cdCAqXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBpc1Zpc2libGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXNcblx0ICoqL1xuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpbWFnZSA9IHRoaXMuaW1hZ2U7XG5cdFx0dmFyIGhhc0NvbnRlbnQgPSB0aGlzLmNhY2hlQ2FudmFzIHx8IChpbWFnZSAmJiAoaW1hZ2UubmF0dXJhbFdpZHRoIHx8IGltYWdlLmdldENvbnRleHQgfHwgaW1hZ2UucmVhZHlTdGF0ZSA+PSAyKSk7XG5cdFx0cmV0dXJuICEhKHRoaXMudmlzaWJsZSAmJiB0aGlzLmFscGhhID4gMCAmJiB0aGlzLnNjYWxlWCAhPSAwICYmIHRoaXMuc2NhbGVZICE9IDAgJiYgaGFzQ29udGVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS5cblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBkcmF3IHdhcyBoYW5kbGVkICh1c2VmdWwgZm9yIG92ZXJyaWRpbmcgZnVuY3Rpb25hbGl0eSkuXG5cdCAqXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBkcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZUNhY2hlPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZHJhdyBvcGVyYXRpb24gc2hvdWxkIGlnbm9yZSBhbnkgY3VycmVudCBjYWNoZS5cblx0ICogRm9yIGV4YW1wbGUsIHVzZWQgZm9yIGRyYXdpbmcgdGhlIGNhY2hlICh0byBwcmV2ZW50IGl0IGZyb20gc2ltcGx5IGRyYXdpbmcgYW4gZXhpc3RpbmcgY2FjaGUgYmFja1xuXHQgKiBpbnRvIGl0c2VsZikuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBpZ25vcmVDYWNoZSkge1xuXHRcdGlmICh0aGlzLkRpc3BsYXlPYmplY3RfZHJhdyhjdHgsIGlnbm9yZUNhY2hlKSB8fCAhdGhpcy5pbWFnZSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdHZhciBpbWcgPSB0aGlzLmltYWdlLCByZWN0ID0gdGhpcy5zb3VyY2VSZWN0O1xuXHRcdGlmIChyZWN0KSB7XG5cdFx0XHQvLyBzb21lIGJyb3dzZXJzIGNob2tlIG9uIG91dCBvZiBib3VuZCB2YWx1ZXMsIHNvIHdlJ2xsIGZpeCB0aGVtOlxuXHRcdFx0dmFyIHgxID0gcmVjdC54LCB5MSA9IHJlY3QueSwgeDIgPSB4MSArIHJlY3Qud2lkdGgsIHkyID0geTEgKyByZWN0LmhlaWdodCwgeCA9IDAsIHkgPSAwLCB3ID0gaW1nLndpZHRoLCBoID0gaW1nLmhlaWdodDtcblx0XHRcdGlmICh4MSA8IDApIHsgeCAtPSB4MTsgeDEgPSAwOyB9XG5cdFx0XHRpZiAoeDIgPiB3KSB7IHgyID0gdzsgfVxuXHRcdFx0aWYgKHkxIDwgMCkgeyB5IC09IHkxOyB5MSA9IDA7IH1cblx0XHRcdGlmICh5MiA+IGgpIHsgeTIgPSBoOyB9XG5cdFx0XHRjdHguZHJhd0ltYWdlKGltZywgeDEsIHkxLCB4Mi14MSwgeTIteTEsIHgsIHksIHgyLXgxLCB5Mi15MSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHQvL05vdGUsIHRoZSBkb2Mgc2VjdGlvbnMgYmVsb3cgZG9jdW1lbnQgdXNpbmcgdGhlIHNwZWNpZmllZCBBUElzIChmcm9tIERpc3BsYXlPYmplY3QpICBmcm9tXG5cdC8vQml0bWFwLiBUaGlzIGlzIHdoeSB0aGV5IGhhdmUgbm8gbWV0aG9kIGltcGxlbWVudGF0aW9ucy5cblx0XG5cdC8qKlxuXHQgKiBCZWNhdXNlIHRoZSBjb250ZW50IG9mIGEgQml0bWFwIGlzIGFscmVhZHkgaW4gYSBzaW1wbGUgZm9ybWF0LCBjYWNoZSBpcyB1bm5lY2Vzc2FyeSBmb3IgQml0bWFwIGluc3RhbmNlcy5cblx0ICogWW91IHNob3VsZCA8Yj5ub3Q8L2I+IGNhY2hlIEJpdG1hcCBpbnN0YW5jZXMgYXMgaXQgY2FuIGRlZ3JhZGUgcGVyZm9ybWFuY2UuXG5cdCAqXG5cdCAqIDxzdHJvbmc+SG93ZXZlcjogSWYgeW91IHdhbnQgdG8gdXNlIGEgZmlsdGVyIG9uIGEgQml0bWFwLCB5b3UgPGVtPk1VU1Q8L2VtPiBjYWNoZSBpdCwgb3IgaXQgd2lsbCBub3Qgd29yay48L3N0cm9uZz5cblx0ICogVG8gc2VlIHRoZSBBUEkgZm9yIGNhY2hpbmcsIHBsZWFzZSB2aXNpdCB0aGUgRGlzcGxheU9iamVjdCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2NhY2hlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZC5cblx0ICogQG1ldGhvZCBjYWNoZVxuXHQgKiovXG5cdFxuXHQvKipcblx0ICogQmVjYXVzZSB0aGUgY29udGVudCBvZiBhIEJpdG1hcCBpcyBhbHJlYWR5IGluIGEgc2ltcGxlIGZvcm1hdCwgY2FjaGUgaXMgdW5uZWNlc3NhcnkgZm9yIEJpdG1hcCBpbnN0YW5jZXMuXG5cdCAqIFlvdSBzaG91bGQgPGI+bm90PC9iPiBjYWNoZSBCaXRtYXAgaW5zdGFuY2VzIGFzIGl0IGNhbiBkZWdyYWRlIHBlcmZvcm1hbmNlLlxuXHQgKlxuXHQgKiA8c3Ryb25nPkhvd2V2ZXI6IElmIHlvdSB3YW50IHRvIHVzZSBhIGZpbHRlciBvbiBhIEJpdG1hcCwgeW91IDxlbT5NVVNUPC9lbT4gY2FjaGUgaXQsIG9yIGl0IHdpbGwgbm90IHdvcmsuPC9zdHJvbmc+XG5cdCAqIFRvIHNlZSB0aGUgQVBJIGZvciBjYWNoaW5nLCBwbGVhc2UgdmlzaXQgdGhlIERpc3BsYXlPYmplY3Qge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9jYWNoZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuXG5cdCAqIEBtZXRob2QgdXBkYXRlQ2FjaGVcblx0ICoqL1xuXHRcblx0LyoqXG5cdCAqIEJlY2F1c2UgdGhlIGNvbnRlbnQgb2YgYSBCaXRtYXAgaXMgYWxyZWFkeSBpbiBhIHNpbXBsZSBmb3JtYXQsIGNhY2hlIGlzIHVubmVjZXNzYXJ5IGZvciBCaXRtYXAgaW5zdGFuY2VzLlxuXHQgKiBZb3Ugc2hvdWxkIDxiPm5vdDwvYj4gY2FjaGUgQml0bWFwIGluc3RhbmNlcyBhcyBpdCBjYW4gZGVncmFkZSBwZXJmb3JtYW5jZS5cblx0ICpcblx0ICogPHN0cm9uZz5Ib3dldmVyOiBJZiB5b3Ugd2FudCB0byB1c2UgYSBmaWx0ZXIgb24gYSBCaXRtYXAsIHlvdSA8ZW0+TVVTVDwvZW0+IGNhY2hlIGl0LCBvciBpdCB3aWxsIG5vdCB3b3JrLjwvc3Ryb25nPlxuXHQgKiBUbyBzZWUgdGhlIEFQSSBmb3IgY2FjaGluZywgcGxlYXNlIHZpc2l0IHRoZSBEaXNwbGF5T2JqZWN0IHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvY2FjaGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLlxuXHQgKiBAbWV0aG9kIHVuY2FjaGVcblx0ICoqL1xuXG5cdC8qKlxuXHQgKiBEb2NjZWQgaW4gc3VwZXJjbGFzcy5cblx0ICovXG5cdHAuZ2V0Qm91bmRzID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSB0aGlzLkRpc3BsYXlPYmplY3RfZ2V0Qm91bmRzKCk7XG5cdFx0aWYgKHJlY3QpIHsgcmV0dXJuIHJlY3Q7IH1cblx0XHR2YXIgaW1hZ2UgPSB0aGlzLmltYWdlLCBvID0gdGhpcy5zb3VyY2VSZWN0IHx8IGltYWdlO1xuXHRcdHZhciBoYXNDb250ZW50ID0gKGltYWdlICYmIChpbWFnZS5uYXR1cmFsV2lkdGggfHwgaW1hZ2UuZ2V0Q29udGV4dCB8fCBpbWFnZS5yZWFkeVN0YXRlID49IDIpKTtcblx0XHRyZXR1cm4gaGFzQ29udGVudCA/IHRoaXMuX3JlY3RhbmdsZS5zZXRWYWx1ZXMoMCwgMCwgby53aWR0aCwgby5oZWlnaHQpIDogbnVsbDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIEJpdG1hcCBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtCaXRtYXB9IGEgY2xvbmUgb2YgdGhlIEJpdG1hcCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG8gPSBuZXcgQml0bWFwKHRoaXMuaW1hZ2UpO1xuXHRcdGlmICh0aGlzLnNvdXJjZVJlY3QpIHsgby5zb3VyY2VSZWN0ID0gdGhpcy5zb3VyY2VSZWN0LmNsb25lKCk7IH1cblx0XHR0aGlzLl9jbG9uZVByb3BzKG8pO1xuXHRcdHJldHVybiBvO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltCaXRtYXAgKG5hbWU9XCIrICB0aGlzLm5hbWUgK1wiKV1cIjtcblx0fTtcblxuXHRcblx0Y3JlYXRlanMuQml0bWFwID0gY3JlYXRlanMucHJvbW90ZShCaXRtYXAsIFwiRGlzcGxheU9iamVjdFwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTcHJpdGUuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBEaXNwbGF5cyBhIGZyYW1lIG9yIHNlcXVlbmNlIG9mIGZyYW1lcyAoaWUuIGFuIGFuaW1hdGlvbikgZnJvbSBhIFNwcml0ZVNoZWV0IGluc3RhbmNlLiBBIHNwcml0ZSBzaGVldCBpcyBhIHNlcmllcyBvZlxuXHQgKiBpbWFnZXMgKHVzdWFsbHkgYW5pbWF0aW9uIGZyYW1lcykgY29tYmluZWQgaW50byBhIHNpbmdsZSBpbWFnZS4gRm9yIGV4YW1wbGUsIGFuIGFuaW1hdGlvbiBjb25zaXN0aW5nIG9mIDggMTAweDEwMFxuXHQgKiBpbWFnZXMgY291bGQgYmUgY29tYmluZWQgaW50byBhIDQwMHgyMDAgc3ByaXRlIHNoZWV0ICg0IGZyYW1lcyBhY3Jvc3MgYnkgMiBoaWdoKS4gWW91IGNhbiBkaXNwbGF5IGluZGl2aWR1YWwgZnJhbWVzLFxuXHQgKiBwbGF5IGZyYW1lcyBhcyBhbiBhbmltYXRpb24sIGFuZCBldmVuIHNlcXVlbmNlIGFuaW1hdGlvbnMgdG9nZXRoZXIuXG5cdCAqXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gc2V0dGluZyB1cCBmcmFtZXMgYW5kIGFuaW1hdGlvbnMuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgY3JlYXRlanMuU3ByaXRlKHNwcml0ZVNoZWV0KTtcblx0ICogICAgICBpbnN0YW5jZS5nb3RvQW5kU3RvcChcImZyYW1lTmFtZVwiKTtcblx0ICpcblx0ICogVW50aWwge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRTdG9wXCJ9fXt7L2Nyb3NzTGlua319IG9yIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9nb3RvQW5kUGxheVwifX17ey9jcm9zc0xpbmt9fSBpcyBjYWxsZWQsXG5cdCAqIG9ubHkgdGhlIGZpcnN0IGRlZmluZWQgZnJhbWUgZGVmaW5lZCBpbiB0aGUgc3ByaXRlIHNoZWV0IHdpbGwgYmUgZGlzcGxheWVkLlxuXHQgKlxuXHQgKiBAY2xhc3MgU3ByaXRlXG5cdCAqIEBleHRlbmRzIERpc3BsYXlPYmplY3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IHNwcml0ZVNoZWV0IFRoZSBTcHJpdGVTaGVldCBpbnN0YW5jZSB0byBwbGF5IGJhY2suIFRoaXMgaW5jbHVkZXMgdGhlIHNvdXJjZSBpbWFnZShzKSwgZnJhbWVcblx0ICogZGltZW5zaW9ucywgYW5kIGZyYW1lIGRhdGEuIFNlZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBbZnJhbWVPckFuaW1hdGlvbl0gVGhlIGZyYW1lIG51bWJlciBvciBhbmltYXRpb24gdG8gcGxheSBpbml0aWFsbHkuXG5cdCAqKi9cblx0ZnVuY3Rpb24gU3ByaXRlKHNwcml0ZVNoZWV0LCBmcmFtZU9yQW5pbWF0aW9uKSB7XG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X2NvbnN0cnVjdG9yKCk7XG5cdFx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSBmcmFtZSBpbmRleCB0aGF0IHdpbGwgYmUgZHJhd24gd2hlbiBkcmF3IGlzIGNhbGxlZC4gTm90ZSB0aGF0IHdpdGggc29tZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIGRlZmluaXRpb25zLCB0aGlzIHdpbGwgYWR2YW5jZSBub24tc2VxdWVudGlhbGx5LiBUaGlzIHdpbGwgYWx3YXlzIGJlIGFuIGludGVnZXIgdmFsdWUuXG5cdFx0ICogQHByb3BlcnR5IGN1cnJlbnRGcmFtZVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBwbGF5aW5nIGFuaW1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgY3VycmVudEFuaW1hdGlvblxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGZpbmFsXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFByZXZlbnRzIHRoZSBhbmltYXRpb24gZnJvbSBhZHZhbmNpbmcgZWFjaCB0aWNrIGF1dG9tYXRpY2FsbHkuIEZvciBleGFtcGxlLCB5b3UgY291bGQgY3JlYXRlIGEgc3ByaXRlXG5cdFx0ICogc2hlZXQgb2YgaWNvbnMsIHNldCBwYXVzZWQgdG8gdHJ1ZSwgYW5kIGRpc3BsYXkgdGhlIGFwcHJvcHJpYXRlIGljb24gYnkgc2V0dGluZyA8Y29kZT5jdXJyZW50RnJhbWU8L2NvZGU+LlxuXHRcdCAqIEBwcm9wZXJ0eSBwYXVzZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqKi9cblx0XHR0aGlzLnBhdXNlZCA9IHRydWU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBTcHJpdGVTaGVldCBpbnN0YW5jZSB0byBwbGF5IGJhY2suIFRoaXMgaW5jbHVkZXMgdGhlIHNvdXJjZSBpbWFnZSwgZnJhbWUgZGltZW5zaW9ucywgYW5kIGZyYW1lXG5cdFx0ICogZGF0YS4gU2VlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBzcHJpdGVTaGVldFxuXHRcdCAqIEB0eXBlIHtTcHJpdGVTaGVldH1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5zcHJpdGVTaGVldCA9IHNwcml0ZVNoZWV0O1xuXHRcblx0XHQvKipcblx0XHQgKiBTcGVjaWZpZXMgdGhlIGN1cnJlbnQgZnJhbWUgaW5kZXggd2l0aGluIHRoZSBjdXJyZW50bHkgcGxheWluZyBhbmltYXRpb24uIFdoZW4gcGxheWluZyBub3JtYWxseSwgdGhpcyB3aWxsIGluY3JlYXNlXG5cdFx0ICogZnJvbSAwIHRvIG4tMSwgd2hlcmUgbiBpcyB0aGUgbnVtYmVyIG9mIGZyYW1lcyBpbiB0aGUgY3VycmVudCBhbmltYXRpb24uXG5cdFx0ICpcblx0XHQgKiBUaGlzIGNvdWxkIGJlIGEgbm9uLWludGVnZXIgdmFsdWUgaWZcblx0XHQgKiB1c2luZyB0aW1lLWJhc2VkIHBsYXliYWNrIChzZWUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2ZyYW1lcmF0ZVwifX17ey9jcm9zc0xpbmt9fSwgb3IgaWYgdGhlIGFuaW1hdGlvbidzIHNwZWVkIGlzXG5cdFx0ICogbm90IGFuIGludGVnZXIuXG5cdFx0ICogQHByb3BlcnR5IGN1cnJlbnRBbmltYXRpb25GcmFtZVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZSA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEJ5IGRlZmF1bHQgU3ByaXRlIGluc3RhbmNlcyBhZHZhbmNlIG9uZSBmcmFtZSBwZXIgdGljay4gU3BlY2lmeWluZyBhIGZyYW1lcmF0ZSBmb3IgdGhlIFNwcml0ZSAob3IgaXRzIHJlbGF0ZWRcblx0XHQgKiBTcHJpdGVTaGVldCkgd2lsbCBjYXVzZSBpdCB0byBhZHZhbmNlIGJhc2VkIG9uIGVsYXBzZWQgdGltZSBiZXR3ZWVuIHRpY2tzIGFzIGFwcHJvcHJpYXRlIHRvIG1haW50YWluIHRoZSB0YXJnZXRcblx0XHQgKiBmcmFtZXJhdGUuXG5cdFx0ICpcblx0XHQgKiBGb3IgZXhhbXBsZSwgaWYgYSBTcHJpdGUgd2l0aCBhIGZyYW1lcmF0ZSBvZiAxMCBpcyBwbGFjZWQgb24gYSBTdGFnZSBiZWluZyB1cGRhdGVkIGF0IDQwZnBzLCB0aGVuIHRoZSBTcHJpdGUgd2lsbFxuXHRcdCAqIGFkdmFuY2Ugcm91Z2hseSBvbmUgZnJhbWUgZXZlcnkgNCB0aWNrcy4gVGhpcyB3aWxsIG5vdCBiZSBleGFjdCwgYmVjYXVzZSB0aGUgdGltZSBiZXR3ZWVuIGVhY2ggdGljayB3aWxsXG5cdFx0ICogdmFyeSBzbGlnaHRseSBiZXR3ZWVuIGZyYW1lcy5cblx0XHQgKlxuXHRcdCAqIFRoaXMgZmVhdHVyZSBpcyBkZXBlbmRlbnQgb24gdGhlIHRpY2sgZXZlbnQgb2JqZWN0IChvciBhbiBvYmplY3Qgd2l0aCBhbiBhcHByb3ByaWF0ZSBcImRlbHRhXCIgcHJvcGVydHkpIGJlaW5nXG5cdFx0ICogcGFzc2VkIGludG8ge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdXBkYXRlXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBmcmFtZXJhdGVcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5mcmFtZXJhdGUgPSAwO1xuXHRcblx0XG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBDdXJyZW50IGFuaW1hdGlvbiBvYmplY3QuXG5cdFx0ICogQHByb3BlcnR5IF9hbmltYXRpb25cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2FuaW1hdGlvbiA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEN1cnJlbnQgZnJhbWUgaW5kZXguXG5cdFx0ICogQHByb3BlcnR5IF9jdXJyZW50RnJhbWVcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2N1cnJlbnRGcmFtZSA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2tpcHMgdGhlIG5leHQgYXV0byBhZHZhbmNlLiBVc2VkIGJ5IGdvdG9BbmRQbGF5IHRvIGF2b2lkIGltbWVkaWF0ZWx5IGp1bXBpbmcgdG8gdGhlIG5leHQgZnJhbWVcblx0XHQgKiBAcHJvcGVydHkgX3NraXBBZHZhbmNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3NraXBBZHZhbmNlID0gZmFsc2U7XG5cdFx0XG5cdFx0XG5cdFx0aWYgKGZyYW1lT3JBbmltYXRpb24gIT0gbnVsbCkgeyB0aGlzLmdvdG9BbmRQbGF5KGZyYW1lT3JBbmltYXRpb24pOyB9XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoU3ByaXRlLCBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0KTtcblxuXHQvKipcblx0ICogQ29uc3RydWN0b3IgYWxpYXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBUaGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zLlxuXHQgKiBTdWJjbGFzc2VzIHNob3VsZCBiZSB1cGRhdGVkIHRvIHVzZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kc1wifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBgY3JlYXRlanMucHJvbW90ZSgpYFxuXHQgKiovXG5cdHAuaW5pdGlhbGl6ZSA9IFNwcml0ZTsgLy8gVE9ETzogRGVwcmVjYXRlZC4gVGhpcyBpcyBmb3IgYmFja3dhcmRzIHN1cHBvcnQgb2YgRmxhc2hDQyBzcHJpdGVzaGVldCBleHBvcnQuXG5cblxuLy8gZXZlbnRzOlxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIGFuIGFuaW1hdGlvbiByZWFjaGVzIGl0cyBlbmRzLlxuXHQgKiBAZXZlbnQgYW5pbWF0aW9uZW5kXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0aGF0IGp1c3QgZW5kZWQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuZXh0IFRoZSBuYW1lIG9mIHRoZSBuZXh0IGFuaW1hdGlvbiB0aGF0IHdpbGwgYmUgcGxheWVkLCBvciBudWxsLiBUaGlzIHdpbGwgYmUgdGhlIHNhbWUgYXMgbmFtZSBpZiB0aGUgYW5pbWF0aW9uIGlzIGxvb3BpbmcuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCBhbnkgdGltZSB0aGUgY3VycmVudCBmcmFtZSBjaGFuZ2VzLiBGb3IgZXhhbXBsZSwgdGhpcyBjb3VsZCBiZSBkdWUgdG8gYXV0b21hdGljIGFkdmFuY2VtZW50IG9uIGEgdGljayxcblx0ICogb3IgY2FsbGluZyBnb3RvQW5kUGxheSgpIG9yIGdvdG9BbmRTdG9wKCkuXG5cdCAqIEBldmVudCBjaGFuZ2Vcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKi9cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXMuXG5cdCAqIFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3Igd2hldGhlciBpdCB3b3VsZCBiZSB2aXNpYmxlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgc3RhZ2UuXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBpc1Zpc2libGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXNcblx0ICoqL1xuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYXNDb250ZW50ID0gdGhpcy5jYWNoZUNhbnZhcyB8fCB0aGlzLnNwcml0ZVNoZWV0LmNvbXBsZXRlO1xuXHRcdHJldHVybiAhISh0aGlzLnZpc2libGUgJiYgdGhpcy5hbHBoYSA+IDAgJiYgdGhpcy5zY2FsZVggIT0gMCAmJiB0aGlzLnNjYWxlWSAhPSAwICYmIGhhc0NvbnRlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyB0aGUgZGlzcGxheSBvYmplY3QgaW50byB0aGUgc3BlY2lmaWVkIGNvbnRleHQgaWdub3JpbmcgaXRzIHZpc2libGUsIGFscGhhLCBzaGFkb3csIGFuZCB0cmFuc2Zvcm0uXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZHJhdyB3YXMgaGFuZGxlZCAodXNlZnVsIGZvciBvdmVycmlkaW5nIGZ1bmN0aW9uYWxpdHkpLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgZHJhd1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZUNhY2hlIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkcmF3IG9wZXJhdGlvbiBzaG91bGQgaWdub3JlIGFueSBjdXJyZW50IGNhY2hlLlxuXHQgKiBGb3IgZXhhbXBsZSwgdXNlZCBmb3IgZHJhd2luZyB0aGUgY2FjaGUgKHRvIHByZXZlbnQgaXQgZnJvbSBzaW1wbHkgZHJhd2luZyBhbiBleGlzdGluZyBjYWNoZSBiYWNrXG5cdCAqIGludG8gaXRzZWxmKS5cblx0ICoqL1xuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGlnbm9yZUNhY2hlKSB7XG5cdFx0aWYgKHRoaXMuRGlzcGxheU9iamVjdF9kcmF3KGN0eCwgaWdub3JlQ2FjaGUpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0dGhpcy5fbm9ybWFsaXplRnJhbWUoKTtcblx0XHR2YXIgbyA9IHRoaXMuc3ByaXRlU2hlZXQuZ2V0RnJhbWUodGhpcy5fY3VycmVudEZyYW1lfDApO1xuXHRcdGlmICghbykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR2YXIgcmVjdCA9IG8ucmVjdDtcblx0XHRpZiAocmVjdC53aWR0aCAmJiByZWN0LmhlaWdodCkgeyBjdHguZHJhd0ltYWdlKG8uaW1hZ2UsIHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCwgLW8ucmVnWCwgLW8ucmVnWSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpOyB9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0Ly9Ob3RlLCB0aGUgZG9jIHNlY3Rpb25zIGJlbG93IGRvY3VtZW50IHVzaW5nIHRoZSBzcGVjaWZpZWQgQVBJcyAoZnJvbSBEaXNwbGF5T2JqZWN0KSAgZnJvbVxuXHQvL0JpdG1hcC4gVGhpcyBpcyB3aHkgdGhleSBoYXZlIG5vIG1ldGhvZCBpbXBsZW1lbnRhdGlvbnMuXG5cblx0LyoqXG5cdCAqIEJlY2F1c2UgdGhlIGNvbnRlbnQgb2YgYSBTcHJpdGUgaXMgYWxyZWFkeSBpbiBhIHJhc3RlciBmb3JtYXQsIGNhY2hlIGlzIHVubmVjZXNzYXJ5IGZvciBTcHJpdGUgaW5zdGFuY2VzLlxuXHQgKiBZb3Ugc2hvdWxkIG5vdCBjYWNoZSBTcHJpdGUgaW5zdGFuY2VzIGFzIGl0IGNhbiBkZWdyYWRlIHBlcmZvcm1hbmNlLlxuXHQgKiBAbWV0aG9kIGNhY2hlXG5cdCAqKi9cblxuXHQvKipcblx0ICogQmVjYXVzZSB0aGUgY29udGVudCBvZiBhIFNwcml0ZSBpcyBhbHJlYWR5IGluIGEgcmFzdGVyIGZvcm1hdCwgY2FjaGUgaXMgdW5uZWNlc3NhcnkgZm9yIFNwcml0ZSBpbnN0YW5jZXMuXG5cdCAqIFlvdSBzaG91bGQgbm90IGNhY2hlIFNwcml0ZSBpbnN0YW5jZXMgYXMgaXQgY2FuIGRlZ3JhZGUgcGVyZm9ybWFuY2UuXG5cdCAqIEBtZXRob2QgdXBkYXRlQ2FjaGVcblx0ICoqL1xuXG5cdC8qKlxuXHQgKiBCZWNhdXNlIHRoZSBjb250ZW50IG9mIGEgU3ByaXRlIGlzIGFscmVhZHkgaW4gYSByYXN0ZXIgZm9ybWF0LCBjYWNoZSBpcyB1bm5lY2Vzc2FyeSBmb3IgU3ByaXRlIGluc3RhbmNlcy5cblx0ICogWW91IHNob3VsZCBub3QgY2FjaGUgU3ByaXRlIGluc3RhbmNlcyBhcyBpdCBjYW4gZGVncmFkZSBwZXJmb3JtYW5jZS5cblx0ICogQG1ldGhvZCB1bmNhY2hlXG5cdCAqKi9cblxuXHQvKipcblx0ICogUGxheSAodW5wYXVzZSkgdGhlIGN1cnJlbnQgYW5pbWF0aW9uLiBUaGUgU3ByaXRlIHdpbGwgYmUgcGF1c2VkIGlmIGVpdGhlciB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvc3RvcFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvciB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFN0b3BcIn19e3svY3Jvc3NMaW5rfX0gaXMgY2FsbGVkLiBTaW5nbGUgZnJhbWUgYW5pbWF0aW9ucyB3aWxsIHJlbWFpblxuXHQgKiB1bmNoYW5nZWQuXG5cdCAqIEBtZXRob2QgcGxheVxuXHQgKiovXG5cdHAucGxheSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucGF1c2VkID0gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3AgcGxheWluZyBhIHJ1bm5pbmcgYW5pbWF0aW9uLiBUaGUgU3ByaXRlIHdpbGwgYmUgcGxheWluZyBpZiB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaXMgY2FsbGVkLiBOb3RlIHRoYXQgY2FsbGluZyB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX0gb3Ige3sjY3Jvc3NMaW5rIFwiU3ByaXRlL3BsYXlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2lsbCByZXN1bWUgcGxheWJhY2suXG5cdCAqIEBtZXRob2Qgc3RvcFxuXHQgKiovXG5cdHAuc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyBwYXVzZWQgdG8gZmFsc2UgYW5kIHBsYXlzIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uIG5hbWUsIG5hbWVkIGZyYW1lLCBvciBmcmFtZSBudW1iZXIuXG5cdCAqIEBtZXRob2QgZ290b0FuZFBsYXlcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBmcmFtZU9yQW5pbWF0aW9uIFRoZSBmcmFtZSBudW1iZXIgb3IgYW5pbWF0aW9uIG5hbWUgdGhhdCB0aGUgcGxheWhlYWQgc2hvdWxkIG1vdmUgdG9cblx0ICogYW5kIGJlZ2luIHBsYXlpbmcuXG5cdCAqKi9cblx0cC5nb3RvQW5kUGxheSA9IGZ1bmN0aW9uKGZyYW1lT3JBbmltYXRpb24pIHtcblx0XHR0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3NraXBBZHZhbmNlID0gdHJ1ZTtcblx0XHR0aGlzLl9nb3RvKGZyYW1lT3JBbmltYXRpb24pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHBhdXNlZCB0byB0cnVlIGFuZCBzZWVrcyB0byB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbiBuYW1lLCBuYW1lZCBmcmFtZSwgb3IgZnJhbWUgbnVtYmVyLlxuXHQgKiBAbWV0aG9kIGdvdG9BbmRTdG9wXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gZnJhbWVPckFuaW1hdGlvbiBUaGUgZnJhbWUgbnVtYmVyIG9yIGFuaW1hdGlvbiBuYW1lIHRoYXQgdGhlIHBsYXloZWFkIHNob3VsZCBtb3ZlIHRvXG5cdCAqIGFuZCBzdG9wLlxuXHQgKiovXG5cdHAuZ290b0FuZFN0b3AgPSBmdW5jdGlvbihmcmFtZU9yQW5pbWF0aW9uKSB7XG5cdFx0dGhpcy5wYXVzZWQgPSB0cnVlO1xuXHRcdHRoaXMuX2dvdG8oZnJhbWVPckFuaW1hdGlvbik7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoZSBwbGF5aGVhZC4gVGhpcyBvY2N1cnMgYXV0b21hdGljYWxseSBlYWNoIHRpY2sgYnkgZGVmYXVsdC5cblx0ICogQHBhcmFtIFt0aW1lXSB7TnVtYmVyfSBUaGUgYW1vdW50IG9mIHRpbWUgaW4gbXMgdG8gYWR2YW5jZSBieS4gT25seSBhcHBsaWNhYmxlIGlmIGZyYW1lcmF0ZSBpcyBzZXQgb24gdGhlIFNwcml0ZVxuXHQgKiBvciBpdHMgU3ByaXRlU2hlZXQuXG5cdCAqIEBtZXRob2QgYWR2YW5jZVxuXHQqL1xuXHRwLmFkdmFuY2UgPSBmdW5jdGlvbih0aW1lKSB7XG5cdFx0dmFyIGZwcyA9IHRoaXMuZnJhbWVyYXRlIHx8IHRoaXMuc3ByaXRlU2hlZXQuZnJhbWVyYXRlO1xuXHRcdHZhciB0ID0gKGZwcyAmJiB0aW1lICE9IG51bGwpID8gdGltZS8oMTAwMC9mcHMpIDogMTtcblx0XHR0aGlzLl9ub3JtYWxpemVGcmFtZSh0KTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge3sjY3Jvc3NMaW5rIFwiUmVjdGFuZ2xlXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlIGRlZmluaW5nIHRoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnQgZnJhbWUgcmVsYXRpdmUgdG9cblx0ICogdGhlIG9yaWdpbi4gRm9yIGV4YW1wbGUsIGEgOTAgeCA3MCBmcmFtZSB3aXRoIDxjb2RlPnJlZ1g9NTA8L2NvZGU+IGFuZCA8Y29kZT5yZWdZPTQwPC9jb2RlPiB3b3VsZCByZXR1cm4gYVxuXHQgKiByZWN0YW5nbGUgd2l0aCBbeD0tNTAsIHk9LTQwLCB3aWR0aD05MCwgaGVpZ2h0PTcwXS4gVGhpcyBpZ25vcmVzIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgZGlzcGxheSBvYmplY3QuXG5cdCAqXG5cdCAqIEFsc28gc2VlIHRoZSBTcHJpdGVTaGVldCB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldC9nZXRGcmFtZUJvdW5kc1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG5cdCAqIEBtZXRob2QgZ2V0Qm91bmRzXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gQSBSZWN0YW5nbGUgaW5zdGFuY2UuIFJldHVybnMgbnVsbCBpZiB0aGUgZnJhbWUgZG9lcyBub3QgZXhpc3QsIG9yIHRoZSBpbWFnZSBpcyBub3QgZnVsbHlcblx0ICogbG9hZGVkLlxuXHQgKiovXG5cdHAuZ2V0Qm91bmRzID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gVE9ETzogc2hvdWxkIHRoaXMgbm9ybWFsaXplRnJhbWU/XG5cdFx0cmV0dXJuIHRoaXMuRGlzcGxheU9iamVjdF9nZXRCb3VuZHMoKSB8fCB0aGlzLnNwcml0ZVNoZWV0LmdldEZyYW1lQm91bmRzKHRoaXMuY3VycmVudEZyYW1lLCB0aGlzLl9yZWN0YW5nbGUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFNwcml0ZSBpbnN0YW5jZS4gTm90ZSB0aGF0IHRoZSBzYW1lIFNwcml0ZVNoZWV0IGlzIHNoYXJlZCBiZXR3ZWVuIGNsb25lZFxuXHQgKiBpbnN0YW5jZXMuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7U3ByaXRlfSBhIGNsb25lIG9mIHRoZSBTcHJpdGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZVByb3BzKG5ldyBTcHJpdGUodGhpcy5zcHJpdGVTaGVldCkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbU3ByaXRlIChuYW1lPVwiKyAgdGhpcy5uYW1lICtcIildXCI7XG5cdH07XG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX2Nsb25lUHJvcHNcblx0ICogQHBhcmFtIHtTcHJpdGV9IG9cblx0ICogQHJldHVybiB7U3ByaXRlfSBvXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9jbG9uZVByb3BzID0gZnVuY3Rpb24obykge1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9fY2xvbmVQcm9wcyhvKTtcblx0XHRvLmN1cnJlbnRGcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuXHRcdG8uY3VycmVudEFuaW1hdGlvbiA9IHRoaXMuY3VycmVudEFuaW1hdGlvbjtcblx0XHRvLnBhdXNlZCA9IHRoaXMucGF1c2VkO1xuXHRcdG8uY3VycmVudEFuaW1hdGlvbkZyYW1lID0gdGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWU7XG5cdFx0by5mcmFtZXJhdGUgPSB0aGlzLmZyYW1lcmF0ZTtcblx0XHRcblx0XHRvLl9hbmltYXRpb24gPSB0aGlzLl9hbmltYXRpb247XG5cdFx0by5fY3VycmVudEZyYW1lID0gdGhpcy5fY3VycmVudEZyYW1lO1xuXHRcdG8uX3NraXBBZHZhbmNlID0gdGhpcy5fc2tpcEFkdmFuY2U7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cdFxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhlIDxjb2RlPmN1cnJlbnRGcmFtZTwvY29kZT4gaWYgcGF1c2VkIGlzIG5vdCB0cnVlLiBUaGlzIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHRpY2tzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZ0T2JqIEFuIGV2ZW50IG9iamVjdCB0aGF0IHdpbGwgYmUgZGlzcGF0Y2hlZCB0byBhbGwgdGljayBsaXN0ZW5lcnMuIFRoaXMgb2JqZWN0IGlzIHJldXNlZCBiZXR3ZWVuIGRpc3BhdGNoZXJzIHRvIHJlZHVjZSBjb25zdHJ1Y3Rpb24gJiBHQyBjb3N0cy5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAbWV0aG9kIF90aWNrXG5cdCAqKi9cblx0cC5fdGljayA9IGZ1bmN0aW9uKGV2dE9iaikge1xuXHRcdGlmICghdGhpcy5wYXVzZWQpIHtcblx0XHRcdGlmICghdGhpcy5fc2tpcEFkdmFuY2UpIHsgdGhpcy5hZHZhbmNlKGV2dE9iaiYmZXZ0T2JqLmRlbHRhKTsgfVxuXHRcdFx0dGhpcy5fc2tpcEFkdmFuY2UgPSBmYWxzZTtcblx0XHR9XG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X190aWNrKGV2dE9iaik7XG5cdH07XG5cblxuXHQvKipcblx0ICogTm9ybWFsaXplcyB0aGUgY3VycmVudCBmcmFtZSwgYWR2YW5jaW5nIGFuaW1hdGlvbnMgYW5kIGRpc3BhdGNoaW5nIGNhbGxiYWNrcyBhcyBhcHByb3ByaWF0ZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAbWV0aG9kIF9ub3JtYWxpemVGcmFtZVxuXHQgKiovXG5cdHAuX25vcm1hbGl6ZUZyYW1lID0gZnVuY3Rpb24oZnJhbWVEZWx0YSkge1xuXHRcdGZyYW1lRGVsdGEgPSBmcmFtZURlbHRhIHx8IDA7XG5cdFx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuX2FuaW1hdGlvbjtcblx0XHR2YXIgcGF1c2VkID0gdGhpcy5wYXVzZWQ7XG5cdFx0dmFyIGZyYW1lID0gdGhpcy5fY3VycmVudEZyYW1lO1xuXHRcdHZhciBsO1xuXHRcdFxuXHRcdGlmIChhbmltYXRpb24pIHtcblx0XHRcdHZhciBzcGVlZCA9IGFuaW1hdGlvbi5zcGVlZCB8fCAxO1xuXHRcdFx0dmFyIGFuaW1GcmFtZSA9IHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lO1xuXHRcdFx0bCA9IGFuaW1hdGlvbi5mcmFtZXMubGVuZ3RoO1xuXHRcdFx0aWYgKGFuaW1GcmFtZSArIGZyYW1lRGVsdGEgKiBzcGVlZCA+PSBsKSB7XG5cdFx0XHRcdHZhciBuZXh0ID0gYW5pbWF0aW9uLm5leHQ7XG5cdFx0XHRcdGlmICh0aGlzLl9kaXNwYXRjaEFuaW1hdGlvbkVuZChhbmltYXRpb24sIGZyYW1lLCBwYXVzZWQsIG5leHQsIGwgLSAxKSkge1xuXHRcdFx0XHRcdC8vIHNvbWV0aGluZyBjaGFuZ2VkIGluIHRoZSBldmVudCBzdGFjaywgc28gd2Ugc2hvdWxkbid0IG1ha2UgYW55IG1vcmUgY2hhbmdlcyBoZXJlLlxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0Ly8gc2VxdWVuY2UuIEF1dG9tYXRpY2FsbHkgY2FsbHMgX25vcm1hbGl6ZUZyYW1lIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBmcmFtZXMuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2dvdG8obmV4dCwgZnJhbWVEZWx0YSAtIChsIC0gYW5pbUZyYW1lKSAvIHNwZWVkKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBlbmQuXG5cdFx0XHRcdFx0dGhpcy5wYXVzZWQgPSB0cnVlO1xuXHRcdFx0XHRcdGFuaW1GcmFtZSA9IGFuaW1hdGlvbi5mcmFtZXMubGVuZ3RoIC0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YW5pbUZyYW1lICs9IGZyYW1lRGVsdGEgKiBzcGVlZDtcblx0XHRcdH1cblx0XHRcdHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lID0gYW5pbUZyYW1lO1xuXHRcdFx0dGhpcy5fY3VycmVudEZyYW1lID0gYW5pbWF0aW9uLmZyYW1lc1thbmltRnJhbWUgfCAwXVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmcmFtZSA9ICh0aGlzLl9jdXJyZW50RnJhbWUgKz0gZnJhbWVEZWx0YSk7XG5cdFx0XHRsID0gdGhpcy5zcHJpdGVTaGVldC5nZXROdW1GcmFtZXMoKTtcblx0XHRcdGlmIChmcmFtZSA+PSBsICYmIGwgPiAwKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fZGlzcGF0Y2hBbmltYXRpb25FbmQoYW5pbWF0aW9uLCBmcmFtZSwgcGF1c2VkLCBsIC0gMSkpIHtcblx0XHRcdFx0XHQvLyBsb29wZWQuXG5cdFx0XHRcdFx0aWYgKCh0aGlzLl9jdXJyZW50RnJhbWUgLT0gbCkgPj0gbCkgeyByZXR1cm4gdGhpcy5fbm9ybWFsaXplRnJhbWUoKTsgfVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZyYW1lID0gdGhpcy5fY3VycmVudEZyYW1lIHwgMDtcblx0XHRpZiAodGhpcy5jdXJyZW50RnJhbWUgIT0gZnJhbWUpIHtcblx0XHRcdHRoaXMuY3VycmVudEZyYW1lID0gZnJhbWU7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJjaGFuZ2VcIik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVzIHRoZSBcImFuaW1hdGlvbmVuZFwiIGV2ZW50LiBSZXR1cm5zIHRydWUgaWYgYSBoYW5kbGVyIGNoYW5nZWQgdGhlIGFuaW1hdGlvbiAoZXguIGNhbGxpbmcge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL3N0b3BcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9nb3RvQW5kUGxheVwifX17ey9jcm9zc0xpbmt9fSwgZXRjLilcblx0ICogQHByb3BlcnR5IF9kaXNwYXRjaEFuaW1hdGlvbkVuZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdCAqKi9cblx0cC5fZGlzcGF0Y2hBbmltYXRpb25FbmQgPSBmdW5jdGlvbihhbmltYXRpb24sIGZyYW1lLCBwYXVzZWQsIG5leHQsIGVuZCkge1xuXHRcdHZhciBuYW1lID0gYW5pbWF0aW9uID8gYW5pbWF0aW9uLm5hbWUgOiBudWxsO1xuXHRcdGlmICh0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIikpIHtcblx0XHRcdHZhciBldnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJhbmltYXRpb25lbmRcIik7XG5cdFx0XHRldnQubmFtZSA9IG5hbWU7XG5cdFx0XHRldnQubmV4dCA9IG5leHQ7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblx0XHR9XG5cdFx0Ly8gZGlkIHRoZSBhbmltYXRpb24gZ2V0IGNoYW5nZWQgaW4gdGhlIGV2ZW50IHN0YWNrPzpcblx0XHR2YXIgY2hhbmdlZCA9ICh0aGlzLl9hbmltYXRpb24gIT0gYW5pbWF0aW9uIHx8IHRoaXMuX2N1cnJlbnRGcmFtZSAhPSBmcmFtZSk7XG5cdFx0Ly8gaWYgdGhlIGFuaW1hdGlvbiBoYXNuJ3QgY2hhbmdlZCwgYnV0IHRoZSBzcHJpdGUgd2FzIHBhdXNlZCwgdGhlbiB3ZSB3YW50IHRvIHN0aWNrIHRvIHRoZSBsYXN0IGZyYW1lOlxuXHRcdGlmICghY2hhbmdlZCAmJiAhcGF1c2VkICYmIHRoaXMucGF1c2VkKSB7IHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lID0gZW5kOyBjaGFuZ2VkID0gdHJ1ZTsgfVxuXHRcdHJldHVybiBjaGFuZ2VkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBNb3ZlcyB0aGUgcGxheWhlYWQgdG8gdGhlIHNwZWNpZmllZCBmcmFtZSBudW1iZXIgb3IgYW5pbWF0aW9uLlxuXHQgKiBAbWV0aG9kIF9nb3RvXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gZnJhbWVPckFuaW1hdGlvbiBUaGUgZnJhbWUgbnVtYmVyIG9yIGFuaW1hdGlvbiB0aGF0IHRoZSBwbGF5aGVhZCBzaG91bGQgbW92ZSB0by5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbZnJhbWVdIFRoZSBmcmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIGdvIHRvLiBEZWZhdWx0cyB0byAwLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ290byA9IGZ1bmN0aW9uKGZyYW1lT3JBbmltYXRpb24sIGZyYW1lKSB7XG5cdFx0dGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWUgPSAwO1xuXHRcdGlmIChpc05hTihmcmFtZU9yQW5pbWF0aW9uKSkge1xuXHRcdFx0dmFyIGRhdGEgPSB0aGlzLnNwcml0ZVNoZWV0LmdldEFuaW1hdGlvbihmcmFtZU9yQW5pbWF0aW9uKTtcblx0XHRcdGlmIChkYXRhKSB7XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvbiA9IGRhdGE7XG5cdFx0XHRcdHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IGZyYW1lT3JBbmltYXRpb247XG5cdFx0XHRcdHRoaXMuX25vcm1hbGl6ZUZyYW1lKGZyYW1lKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5jdXJyZW50QW5pbWF0aW9uID0gdGhpcy5fYW5pbWF0aW9uID0gbnVsbDtcblx0XHRcdHRoaXMuX2N1cnJlbnRGcmFtZSA9IGZyYW1lT3JBbmltYXRpb247XG5cdFx0XHR0aGlzLl9ub3JtYWxpemVGcmFtZSgpO1xuXHRcdH1cblx0fTtcblxuXG5cdGNyZWF0ZWpzLlNwcml0ZSA9IGNyZWF0ZWpzLnByb21vdGUoU3ByaXRlLCBcIkRpc3BsYXlPYmplY3RcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU2hhcGUuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBBIFNoYXBlIGFsbG93cyB5b3UgdG8gZGlzcGxheSB2ZWN0b3IgYXJ0IGluIHRoZSBkaXNwbGF5IGxpc3QuIEl0IGNvbXBvc2l0ZXMgYSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljc1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBpbnN0YW5jZSB3aGljaCBleHBvc2VzIGFsbCBvZiB0aGUgdmVjdG9yIGRyYXdpbmcgbWV0aG9kcy4gVGhlIEdyYXBoaWNzIGluc3RhbmNlIGNhbiBiZSBzaGFyZWQgYmV0d2VlbiBtdWx0aXBsZSBTaGFwZVxuXHQgKiBpbnN0YW5jZXMgdG8gZGlzcGxheSB0aGUgc2FtZSB2ZWN0b3IgZ3JhcGhpY3Mgd2l0aCBkaWZmZXJlbnQgcG9zaXRpb25zIG9yIHRyYW5zZm9ybXMuXG5cdCAqXG5cdCAqIElmIHRoZSB2ZWN0b3IgYXJ0IHdpbGwgbm90XG5cdCAqIGNoYW5nZSBiZXR3ZWVuIGRyYXdzLCB5b3UgbWF5IHdhbnQgdG8gdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2NhY2hlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCB0byByZWR1Y2UgdGhlXG5cdCAqIHJlbmRlcmluZyBjb3N0LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IGNyZWF0ZWpzLkdyYXBoaWNzKCkuYmVnaW5GaWxsKFwiI2ZmMDAwMFwiKS5kcmF3UmVjdCgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqICAgICAgdmFyIHNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKGdyYXBoaWNzKTtcblx0ICpcblx0ICogICAgICAvL0FsdGVybmF0aXZlbHkgdXNlIGNhbiBhbHNvIHVzZSB0aGUgZ3JhcGhpY3MgcHJvcGVydHkgb2YgdGhlIFNoYXBlIGNsYXNzIHRvIHJlbmRlcmVyIHRoZSBzYW1lIGFzIGFib3ZlLlxuXHQgKiAgICAgIHZhciBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuXHQgKiAgICAgIHNoYXBlLmdyYXBoaWNzLmJlZ2luRmlsbChcIiNmZjAwMDBcIikuZHJhd1JlY3QoMCwgMCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiBAY2xhc3MgU2hhcGVcblx0ICogQGV4dGVuZHMgRGlzcGxheU9iamVjdFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtHcmFwaGljc30gZ3JhcGhpY3MgT3B0aW9uYWwuIFRoZSBncmFwaGljcyBpbnN0YW5jZSB0byBkaXNwbGF5LiBJZiBudWxsLCBhIG5ldyBHcmFwaGljcyBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWQuXG5cdCAqKi9cblx0ZnVuY3Rpb24gU2hhcGUoZ3JhcGhpY3MpIHtcblx0XHR0aGlzLkRpc3BsYXlPYmplY3RfY29uc3RydWN0b3IoKTtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIGdyYXBoaWNzIGluc3RhbmNlIHRvIGRpc3BsYXkuXG5cdFx0ICogQHByb3BlcnR5IGdyYXBoaWNzXG5cdFx0ICogQHR5cGUgR3JhcGhpY3Ncblx0XHQgKiovXG5cdFx0dGhpcy5ncmFwaGljcyA9IGdyYXBoaWNzID8gZ3JhcGhpY3MgOiBuZXcgY3JlYXRlanMuR3JhcGhpY3MoKTtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChTaGFwZSwgY3JlYXRlanMuRGlzcGxheU9iamVjdCk7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBTaGFwZSB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBTaGFwZSB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzXG5cdCAqKi9cblx0cC5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFzQ29udGVudCA9IHRoaXMuY2FjaGVDYW52YXMgfHwgKHRoaXMuZ3JhcGhpY3MgJiYgIXRoaXMuZ3JhcGhpY3MuaXNFbXB0eSgpKTtcblx0XHRyZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9IDAgJiYgdGhpcy5zY2FsZVkgIT0gMCAmJiBoYXNDb250ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgdGhlIFNoYXBlIGludG8gdGhlIHNwZWNpZmllZCBjb250ZXh0IGlnbm9yaW5nIGl0cyB2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBhbmQgdHJhbnNmb3JtLiBSZXR1cm5zIHRydWUgaWZcblx0ICogdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cblx0ICpcblx0ICogPGk+Tk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLjwvaT5cblx0ICogQG1ldGhvZCBkcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZUNhY2hlPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZHJhdyBvcGVyYXRpb24gc2hvdWxkIGlnbm9yZSBhbnkgY3VycmVudCBjYWNoZS4gRm9yIGV4YW1wbGUsXG5cdCAqIHVzZWQgZm9yIGRyYXdpbmcgdGhlIGNhY2hlICh0byBwcmV2ZW50IGl0IGZyb20gc2ltcGx5IGRyYXdpbmcgYW4gZXhpc3RpbmcgY2FjaGUgYmFjayBpbnRvIGl0c2VsZikuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBpZ25vcmVDYWNoZSkge1xuXHRcdGlmICh0aGlzLkRpc3BsYXlPYmplY3RfZHJhdyhjdHgsIGlnbm9yZUNhY2hlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdHRoaXMuZ3JhcGhpY3MuZHJhdyhjdHgsIHRoaXMpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBTaGFwZS4gU29tZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIHNwZWNpZmljIHRvIHRoaXMgaW5zdGFuY2UncyBjdXJyZW50IGNvbnRleHQgYXJlIHJldmVydGVkIHRvXG5cdCAqIHRoZWlyIGRlZmF1bHRzIChmb3IgZXhhbXBsZSAucGFyZW50KS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJlY3Vyc2l2ZSBJZiB0cnVlLCB0aGlzIFNoYXBlJ3Mge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3NcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2Ugd2lsbCBhbHNvIGJlXG5cdCAqIGNsb25lZC4gSWYgZmFsc2UsIHRoZSBHcmFwaGljcyBpbnN0YW5jZSB3aWxsIGJlIHNoYXJlZCB3aXRoIHRoZSBuZXcgU2hhcGUuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKHJlY3Vyc2l2ZSkge1xuXHRcdHZhciBnID0gKHJlY3Vyc2l2ZSAmJiB0aGlzLmdyYXBoaWNzKSA/IHRoaXMuZ3JhcGhpY3MuY2xvbmUoKSA6IHRoaXMuZ3JhcGhpY3M7XG5cdFx0cmV0dXJuICB0aGlzLl9jbG9uZVByb3BzKG5ldyBTaGFwZShnKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltTaGFwZSAobmFtZT1cIisgIHRoaXMubmFtZSArXCIpXVwiO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuU2hhcGUgPSBjcmVhdGVqcy5wcm9tb3RlKFNoYXBlLCBcIkRpc3BsYXlPYmplY3RcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVGV4dC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIERpc3BsYXkgb25lIG9yIG1vcmUgbGluZXMgb2YgZHluYW1pYyB0ZXh0IChub3QgdXNlciBlZGl0YWJsZSkgaW4gdGhlIGRpc3BsYXkgbGlzdC4gTGluZSB3cmFwcGluZyBzdXBwb3J0ICh1c2luZyB0aGVcblx0ICogbGluZVdpZHRoKSBpcyB2ZXJ5IGJhc2ljLCB3cmFwcGluZyBvbiBzcGFjZXMgYW5kIHRhYnMgb25seS4gTm90ZSB0aGF0IGFzIGFuIGFsdGVybmF0aXZlIHRvIFRleHQsIHlvdSBjYW4gcG9zaXRpb24gSFRNTFxuXHQgKiB0ZXh0IGFib3ZlIG9yIGJlbG93IHRoZSBjYW52YXMgcmVsYXRpdmUgdG8gaXRlbXMgaW4gdGhlIGRpc3BsYXkgbGlzdCB1c2luZyB0aGUge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9sb2NhbFRvR2xvYmFsXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZCwgb3IgdXNpbmcge3sjY3Jvc3NMaW5rIFwiRE9NRWxlbWVudFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogPGI+UGxlYXNlIG5vdGUgdGhhdCBUZXh0IGRvZXMgbm90IHN1cHBvcnQgSFRNTCB0ZXh0LCBhbmQgY2FuIG9ubHkgZGlzcGxheSBvbmUgZm9udCBzdHlsZSBhdCBhIHRpbWUuPC9iPiBUbyB1c2Vcblx0ICogbXVsdGlwbGUgZm9udCBzdHlsZXMsIHlvdSB3aWxsIG5lZWQgdG8gY3JlYXRlIG11bHRpcGxlIHRleHQgaW5zdGFuY2VzLCBhbmQgcG9zaXRpb24gdGhlbSBtYW51YWxseS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciB0ZXh0ID0gbmV3IGNyZWF0ZWpzLlRleHQoXCJIZWxsbyBXb3JsZFwiLCBcIjIwcHggQXJpYWxcIiwgXCIjZmY3NzAwXCIpO1xuXHQgKiAgICAgIHRleHQueCA9IDEwMDtcblx0ICogICAgICB0ZXh0LnRleHRCYXNlbGluZSA9IFwiYWxwaGFiZXRpY1wiO1xuXHQgKlxuXHQgKiBDcmVhdGVKUyBUZXh0IHN1cHBvcnRzIHdlYiBmb250cyAodGhlIHNhbWUgcnVsZXMgYXMgQ2FudmFzKS4gVGhlIGZvbnQgbXVzdCBiZSBsb2FkZWQgYW5kIHN1cHBvcnRlZCBieSB0aGUgYnJvd3NlclxuXHQgKiBiZWZvcmUgaXQgY2FuIGJlIGRpc3BsYXllZC5cblx0ICpcblx0ICogPHN0cm9uZz5Ob3RlOjwvc3Ryb25nPiBUZXh0IGNhbiBiZSBleHBlbnNpdmUgdG8gZ2VuZXJhdGUsIHNvIGNhY2hlIGluc3RhbmNlcyB3aGVyZSBwb3NzaWJsZS4gQmUgYXdhcmUgdGhhdCBub3QgYWxsXG5cdCAqIGJyb3dzZXJzIHdpbGwgcmVuZGVyIFRleHQgZXhhY3RseSB0aGUgc2FtZS5cblx0ICogQGNsYXNzIFRleHRcblx0ICogQGV4dGVuZHMgRGlzcGxheU9iamVjdFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtTdHJpbmd9IFt0ZXh0XSBUaGUgdGV4dCB0byBkaXNwbGF5LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2ZvbnRdIFRoZSBmb250IHN0eWxlIHRvIHVzZS4gQW55IHZhbGlkIHZhbHVlIGZvciB0aGUgQ1NTIGZvbnQgYXR0cmlidXRlIGlzIGFjY2VwdGFibGUgKGV4LiBcImJvbGRcblx0ICogMzZweCBBcmlhbFwiKS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtjb2xvcl0gVGhlIGNvbG9yIHRvIGRyYXcgdGhlIHRleHQgaW4uIEFueSB2YWxpZCB2YWx1ZSBmb3IgdGhlIENTUyBjb2xvciBhdHRyaWJ1dGUgaXMgYWNjZXB0YWJsZSAoZXguXG5cdCAqIFwiI0YwMFwiLCBcInJlZFwiLCBvciBcIiNGRjAwMDBcIikuXG5cdCAqKi9cblx0ZnVuY3Rpb24gVGV4dCh0ZXh0LCBmb250LCBjb2xvcikge1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9jb25zdHJ1Y3RvcigpO1xuXHRcdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgdGV4dCB0byBkaXNwbGF5LlxuXHRcdCAqIEBwcm9wZXJ0eSB0ZXh0XG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICoqL1xuXHRcdHRoaXMudGV4dCA9IHRleHQ7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBmb250IHN0eWxlIHRvIHVzZS4gQW55IHZhbGlkIHZhbHVlIGZvciB0aGUgQ1NTIGZvbnQgYXR0cmlidXRlIGlzIGFjY2VwdGFibGUgKGV4LiBcImJvbGQgMzZweCBBcmlhbFwiKS5cblx0XHQgKiBAcHJvcGVydHkgZm9udFxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqKi9cblx0XHR0aGlzLmZvbnQgPSBmb250O1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY29sb3IgdG8gZHJhdyB0aGUgdGV4dCBpbi4gQW55IHZhbGlkIHZhbHVlIGZvciB0aGUgQ1NTIGNvbG9yIGF0dHJpYnV0ZSBpcyBhY2NlcHRhYmxlIChleC4gXCIjRjAwXCIpLiBEZWZhdWx0IGlzIFwiIzAwMFwiLlxuXHRcdCAqIEl0IHdpbGwgYWxzbyBhY2NlcHQgdmFsaWQgY2FudmFzIGZpbGxTdHlsZSB2YWx1ZXMuXG5cdFx0ICogQHByb3BlcnR5IGNvbG9yXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICoqL1xuXHRcdHRoaXMuY29sb3IgPSBjb2xvcjtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGhvcml6b250YWwgdGV4dCBhbGlnbm1lbnQuIEFueSBvZiBcInN0YXJ0XCIsIFwiZW5kXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIGFuZCBcImNlbnRlclwiLiBGb3IgZGV0YWlsZWRcblx0XHQgKiBpbmZvcm1hdGlvbiB2aWV3IHRoZVxuXHRcdCAqIDxhIGhyZWY9XCJodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCN0ZXh0LXN0eWxlc1wiPlxuXHRcdCAqIHdoYXR3ZyBzcGVjPC9hPi4gRGVmYXVsdCBpcyBcImxlZnRcIi5cblx0XHQgKiBAcHJvcGVydHkgdGV4dEFsaWduXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICoqL1xuXHRcdHRoaXMudGV4dEFsaWduID0gXCJsZWZ0XCI7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSB2ZXJ0aWNhbCBhbGlnbm1lbnQgcG9pbnQgb24gdGhlIGZvbnQuIEFueSBvZiBcInRvcFwiLCBcImhhbmdpbmdcIiwgXCJtaWRkbGVcIiwgXCJhbHBoYWJldGljXCIsIFwiaWRlb2dyYXBoaWNcIiwgb3Jcblx0XHQgKiBcImJvdHRvbVwiLiBGb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gdmlldyB0aGUgPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI3RleHQtc3R5bGVzXCI+XG5cdFx0ICogd2hhdHdnIHNwZWM8L2E+LiBEZWZhdWx0IGlzIFwidG9wXCIuXG5cdFx0ICogQHByb3BlcnR5IHRleHRCYXNlbGluZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCovXG5cdFx0dGhpcy50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgbWF4aW11bSB3aWR0aCB0byBkcmF3IHRoZSB0ZXh0LiBJZiBtYXhXaWR0aCBpcyBzcGVjaWZpZWQgKG5vdCBudWxsKSwgdGhlIHRleHQgd2lsbCBiZSBjb25kZW5zZWQgb3Jcblx0XHQgKiBzaHJ1bmsgdG8gbWFrZSBpdCBmaXQgaW4gdGhpcyB3aWR0aC4gRm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIHZpZXcgdGhlXG5cdFx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI3RleHQtc3R5bGVzXCI+XG5cdFx0ICogd2hhdHdnIHNwZWM8L2E+LlxuXHRcdCAqIEBwcm9wZXJ0eSBtYXhXaWR0aFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCovXG5cdFx0dGhpcy5tYXhXaWR0aCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIGdyZWF0ZXIgdGhhbiAwLCB0aGUgdGV4dCB3aWxsIGJlIGRyYXduIGFzIGEgc3Ryb2tlIChvdXRsaW5lKSBvZiB0aGUgc3BlY2lmaWVkIHdpZHRoLlxuXHRcdCAqIEBwcm9wZXJ0eSBvdXRsaW5lXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMub3V0bGluZSA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB0aGUgbGluZSBoZWlnaHQgKHZlcnRpY2FsIGRpc3RhbmNlIGJldHdlZW4gYmFzZWxpbmVzKSBmb3IgbXVsdGktbGluZSB0ZXh0LiBJZiBudWxsIG9yIDAsXG5cdFx0ICogdGhlIHZhbHVlIG9mIGdldE1lYXN1cmVkTGluZUhlaWdodCBpcyB1c2VkLlxuXHRcdCAqIEBwcm9wZXJ0eSBsaW5lSGVpZ2h0XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMubGluZUhlaWdodCA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB0aGUgbWF4aW11bSB3aWR0aCBmb3IgYSBsaW5lIG9mIHRleHQgYmVmb3JlIGl0IGlzIHdyYXBwZWQgdG8gbXVsdGlwbGUgbGluZXMuIElmIG51bGwsXG5cdFx0ICogdGhlIHRleHQgd2lsbCBub3QgYmUgd3JhcHBlZC5cblx0XHQgKiBAcHJvcGVydHkgbGluZVdpZHRoXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMubGluZVdpZHRoID0gbnVsbDtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChUZXh0LCBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0KTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXHRcbi8vIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQHByb3BlcnR5IF93b3JraW5nQ29udGV4dFxuXHQgKiBAdHlwZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcblx0ICogQHByaXZhdGVcblx0ICoqL1xuXHR2YXIgY2FudmFzID0gKGNyZWF0ZWpzLmNyZWF0ZUNhbnZhcz9jcmVhdGVqcy5jcmVhdGVDYW52YXMoKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpKTtcblx0aWYgKGNhbnZhcy5nZXRDb250ZXh0KSB7IFRleHQuX3dvcmtpbmdDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTsgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDE7IH1cblx0XG5cdFxuLy8gY29uc3RhbnRzOlxuXHQvKipcblx0ICogTG9va3VwIHRhYmxlIGZvciB0aGUgcmF0aW8gdG8gb2Zmc2V0IGJvdW5kcyB4IGNhbGN1bGF0aW9ucyBiYXNlZCBvbiB0aGUgdGV4dEFsaWduIHByb3BlcnR5LlxuXHQgKiBAcHJvcGVydHkgSF9PRkZTRVRTXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUZXh0LkhfT0ZGU0VUUyA9IHtzdGFydDogMCwgbGVmdDogMCwgY2VudGVyOiAtMC41LCBlbmQ6IC0xLCByaWdodDogLTF9O1xuXHRcblx0LyoqXG5cdCAqIExvb2t1cCB0YWJsZSBmb3IgdGhlIHJhdGlvIHRvIG9mZnNldCBib3VuZHMgeSBjYWxjdWxhdGlvbnMgYmFzZWQgb24gdGhlIHRleHRCYXNlbGluZSBwcm9wZXJ0eS5cblx0ICogQHByb3BlcnR5IEhfT0ZGU0VUU1xuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VGV4dC5WX09GRlNFVFMgPSB7dG9wOiAwLCBoYW5naW5nOiAtMC4wMSwgbWlkZGxlOiAtMC40LCBhbHBoYWJldGljOiAtMC44LCBpZGVvZ3JhcGhpYzogLTAuODUsIGJvdHRvbTogLTF9O1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhcy5cblx0ICogVGhpcyBkb2VzIG5vdCBhY2NvdW50IGZvciB3aGV0aGVyIGl0IHdvdWxkIGJlIHZpc2libGUgd2l0aGluIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBzdGFnZS5cblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGlzVmlzaWJsZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzXG5cdCAqKi9cblx0cC5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFzQ29udGVudCA9IHRoaXMuY2FjaGVDYW52YXMgfHwgKHRoaXMudGV4dCAhPSBudWxsICYmIHRoaXMudGV4dCAhPT0gXCJcIik7XG5cdFx0cmV0dXJuICEhKHRoaXMudmlzaWJsZSAmJiB0aGlzLmFscGhhID4gMCAmJiB0aGlzLnNjYWxlWCAhPSAwICYmIHRoaXMuc2NhbGVZICE9IDAgJiYgaGFzQ29udGVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIHRoZSBUZXh0IGludG8gdGhlIHNwZWNpZmllZCBjb250ZXh0IGlnbm9yaW5nIGl0cyB2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBhbmQgdHJhbnNmb3JtLlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGRyYXdcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cblx0ICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVDYWNoZSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZHJhdyBvcGVyYXRpb24gc2hvdWxkIGlnbm9yZSBhbnkgY3VycmVudCBjYWNoZS5cblx0ICogRm9yIGV4YW1wbGUsIHVzZWQgZm9yIGRyYXdpbmcgdGhlIGNhY2hlICh0byBwcmV2ZW50IGl0IGZyb20gc2ltcGx5IGRyYXdpbmcgYW4gZXhpc3RpbmcgY2FjaGUgYmFja1xuXHQgKiBpbnRvIGl0c2VsZikuXG5cdCAqKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBpZ25vcmVDYWNoZSkge1xuXHRcdGlmICh0aGlzLkRpc3BsYXlPYmplY3RfZHJhdyhjdHgsIGlnbm9yZUNhY2hlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0dmFyIGNvbCA9IHRoaXMuY29sb3IgfHwgXCIjMDAwXCI7XG5cdFx0aWYgKHRoaXMub3V0bGluZSkgeyBjdHguc3Ryb2tlU3R5bGUgPSBjb2w7IGN0eC5saW5lV2lkdGggPSB0aGlzLm91dGxpbmUqMTsgfVxuXHRcdGVsc2UgeyBjdHguZmlsbFN0eWxlID0gY29sOyB9XG5cdFx0XG5cdFx0dGhpcy5fZHJhd1RleHQodGhpcy5fcHJlcENvbnRleHQoY3R4KSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG1lYXN1cmVkLCB1bnRyYW5zZm9ybWVkIHdpZHRoIG9mIHRoZSB0ZXh0IHdpdGhvdXQgd3JhcHBpbmcuIFVzZSBnZXRCb3VuZHMgZm9yIGEgbW9yZSByb2J1c3QgdmFsdWUuXG5cdCAqIEBtZXRob2QgZ2V0TWVhc3VyZWRXaWR0aFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBtZWFzdXJlZCwgdW50cmFuc2Zvcm1lZCB3aWR0aCBvZiB0aGUgdGV4dC5cblx0ICoqL1xuXHRwLmdldE1lYXN1cmVkV2lkdGggPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0TWVhc3VyZWRXaWR0aCh0aGlzLnRleHQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFwcHJveGltYXRlIGxpbmUgaGVpZ2h0IG9mIHRoZSB0ZXh0LCBpZ25vcmluZyB0aGUgbGluZUhlaWdodCBwcm9wZXJ0eS4gVGhpcyBpcyBiYXNlZCBvbiB0aGUgbWVhc3VyZWRcblx0ICogd2lkdGggb2YgYSBcIk1cIiBjaGFyYWN0ZXIgbXVsdGlwbGllZCBieSAxLjIsIHdoaWNoIHByb3ZpZGVzIGFuIGFwcHJveGltYXRlIGxpbmUgaGVpZ2h0IGZvciBtb3N0IGZvbnRzLlxuXHQgKiBAbWV0aG9kIGdldE1lYXN1cmVkTGluZUhlaWdodFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IGFuIGFwcHJveGltYXRlIGxpbmUgaGVpZ2h0IG9mIHRoZSB0ZXh0LCBpZ25vcmluZyB0aGUgbGluZUhlaWdodCBwcm9wZXJ0eS4gVGhpcyBpc1xuXHQgKiBiYXNlZCBvbiB0aGUgbWVhc3VyZWQgd2lkdGggb2YgYSBcIk1cIiBjaGFyYWN0ZXIgbXVsdGlwbGllZCBieSAxLjIsIHdoaWNoIGFwcHJveGltYXRlcyBlbSBmb3IgbW9zdCBmb250cy5cblx0ICoqL1xuXHRwLmdldE1lYXN1cmVkTGluZUhlaWdodCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9nZXRNZWFzdXJlZFdpZHRoKFwiTVwiKSoxLjI7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGFwcHJveGltYXRlIGhlaWdodCBvZiBtdWx0aS1saW5lIHRleHQgYnkgbXVsdGlwbHlpbmcgdGhlIG51bWJlciBvZiBsaW5lcyBhZ2FpbnN0IGVpdGhlciB0aGVcblx0ICogPGNvZGU+bGluZUhlaWdodDwvY29kZT4gKGlmIHNwZWNpZmllZCkgb3Ige3sjY3Jvc3NMaW5rIFwiVGV4dC9nZXRNZWFzdXJlZExpbmVIZWlnaHRcIn19e3svY3Jvc3NMaW5rfX0uIE5vdGUgdGhhdFxuXHQgKiB0aGlzIG9wZXJhdGlvbiByZXF1aXJlcyB0aGUgdGV4dCBmbG93aW5nIGxvZ2ljIHRvIHJ1biwgd2hpY2ggaGFzIGFuIGFzc29jaWF0ZWQgQ1BVIGNvc3QuXG5cdCAqIEBtZXRob2QgZ2V0TWVhc3VyZWRIZWlnaHRcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgYXBwcm94aW1hdGUgaGVpZ2h0IG9mIHRoZSB1bnRyYW5zZm9ybWVkIG11bHRpLWxpbmUgdGV4dC5cblx0ICoqL1xuXHRwLmdldE1lYXN1cmVkSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYXdUZXh0KG51bGwse30pLmhlaWdodDtcblx0fTtcblxuXHQvKipcblx0ICogRG9jY2VkIGluIHN1cGVyY2xhc3MuXG5cdCAqL1xuXHRwLmdldEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gdGhpcy5EaXNwbGF5T2JqZWN0X2dldEJvdW5kcygpO1xuXHRcdGlmIChyZWN0KSB7IHJldHVybiByZWN0OyB9XG5cdFx0aWYgKHRoaXMudGV4dCA9PSBudWxsIHx8IHRoaXMudGV4dCA9PT0gXCJcIikgeyByZXR1cm4gbnVsbDsgfVxuXHRcdHZhciBvID0gdGhpcy5fZHJhd1RleHQobnVsbCwge30pO1xuXHRcdHZhciB3ID0gKHRoaXMubWF4V2lkdGggJiYgdGhpcy5tYXhXaWR0aCA8IG8ud2lkdGgpID8gdGhpcy5tYXhXaWR0aCA6IG8ud2lkdGg7XG5cdFx0dmFyIHggPSB3ICogVGV4dC5IX09GRlNFVFNbdGhpcy50ZXh0QWxpZ258fFwibGVmdFwiXTtcblx0XHR2YXIgbGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodHx8dGhpcy5nZXRNZWFzdXJlZExpbmVIZWlnaHQoKTtcblx0XHR2YXIgeSA9IGxpbmVIZWlnaHQgKiBUZXh0LlZfT0ZGU0VUU1t0aGlzLnRleHRCYXNlbGluZXx8XCJ0b3BcIl07XG5cdFx0cmV0dXJuIHRoaXMuX3JlY3RhbmdsZS5zZXRWYWx1ZXMoeCwgeSwgdywgby5oZWlnaHQpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggd2lkdGgsIGhlaWdodCwgYW5kIGxpbmVzIHByb3BlcnRpZXMuIFRoZSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSB0aGUgdmlzdWFsIHdpZHRoIGFuZCBoZWlnaHRcblx0ICogb2YgdGhlIGRyYXduIHRleHQuIFRoZSBsaW5lcyBwcm9wZXJ0eSBjb250YWlucyBhbiBhcnJheSBvZiBzdHJpbmdzLCBvbmUgZm9yXG5cdCAqIGVhY2ggbGluZSBvZiB0ZXh0IHRoYXQgd2lsbCBiZSBkcmF3biwgYWNjb3VudGluZyBmb3IgbGluZSBicmVha3MgYW5kIHdyYXBwaW5nLiBUaGVzZSBzdHJpbmdzIGhhdmUgdHJhaWxpbmdcblx0ICogd2hpdGVzcGFjZSByZW1vdmVkLlxuXHQgKiBAbWV0aG9kIGdldE1ldHJpY3Ncblx0ICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB3aWR0aCwgaGVpZ2h0LCBhbmQgbGluZXMgcHJvcGVydGllcy5cblx0ICoqL1xuXHRwLmdldE1ldHJpY3MgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbyA9IHtsaW5lczpbXX07XG5cdFx0by5saW5lSGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0IHx8IHRoaXMuZ2V0TWVhc3VyZWRMaW5lSGVpZ2h0KCk7XG5cdFx0by52T2Zmc2V0ID0gby5saW5lSGVpZ2h0ICogVGV4dC5WX09GRlNFVFNbdGhpcy50ZXh0QmFzZWxpbmV8fFwidG9wXCJdO1xuXHRcdHJldHVybiB0aGlzLl9kcmF3VGV4dChudWxsLCBvLCBvLmxpbmVzKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBUZXh0IGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge1RleHR9IGEgY2xvbmUgb2YgdGhlIFRleHQgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZVByb3BzKG5ldyBUZXh0KHRoaXMudGV4dCwgdGhpcy5mb250LCB0aGlzLmNvbG9yKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltUZXh0ICh0ZXh0PVwiKyAgKHRoaXMudGV4dC5sZW5ndGggPiAyMCA/IHRoaXMudGV4dC5zdWJzdHIoMCwgMTcpK1wiLi4uXCIgOiB0aGlzLnRleHQpICtcIildXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfY2xvbmVQcm9wc1xuXHQgKiBAcGFyYW0ge1RleHR9IG9cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtUZXh0fSBvXG5cdCAqKi9cblx0cC5fY2xvbmVQcm9wcyA9IGZ1bmN0aW9uKG8pIHtcblx0XHR0aGlzLkRpc3BsYXlPYmplY3RfX2Nsb25lUHJvcHMobyk7XG5cdFx0by50ZXh0QWxpZ24gPSB0aGlzLnRleHRBbGlnbjtcblx0XHRvLnRleHRCYXNlbGluZSA9IHRoaXMudGV4dEJhc2VsaW5lO1xuXHRcdG8ubWF4V2lkdGggPSB0aGlzLm1heFdpZHRoO1xuXHRcdG8ub3V0bGluZSA9IHRoaXMub3V0bGluZTtcblx0XHRvLmxpbmVIZWlnaHQgPSB0aGlzLmxpbmVIZWlnaHQ7XG5cdFx0by5saW5lV2lkdGggPSB0aGlzLmxpbmVXaWR0aDtcblx0XHRyZXR1cm4gbztcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0V29ya2luZ0NvbnRleHRcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9wcmVwQ29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGN0eC5mb250ID0gdGhpcy5mb250fHxcIjEwcHggc2Fucy1zZXJpZlwiO1xuXHRcdGN0eC50ZXh0QWxpZ24gPSB0aGlzLnRleHRBbGlnbnx8XCJsZWZ0XCI7XG5cdFx0Y3R4LnRleHRCYXNlbGluZSA9IHRoaXMudGV4dEJhc2VsaW5lfHxcInRvcFwiO1xuXHRcdHJldHVybiBjdHg7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIG11bHRpbGluZSB0ZXh0LlxuXHQgKiBAbWV0aG9kIF9kcmF3VGV4dFxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGxpbmVzXG5cdCAqIEByZXR1cm4ge09iamVjdH1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2RyYXdUZXh0ID0gZnVuY3Rpb24oY3R4LCBvLCBsaW5lcykge1xuXHRcdHZhciBwYWludCA9ICEhY3R4O1xuXHRcdGlmICghcGFpbnQpIHtcblx0XHRcdGN0eCA9IFRleHQuX3dvcmtpbmdDb250ZXh0O1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdHRoaXMuX3ByZXBDb250ZXh0KGN0eCk7XG5cdFx0fVxuXHRcdHZhciBsaW5lSGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0fHx0aGlzLmdldE1lYXN1cmVkTGluZUhlaWdodCgpO1xuXHRcdFxuXHRcdHZhciBtYXhXID0gMCwgY291bnQgPSAwO1xuXHRcdHZhciBoYXJkTGluZXMgPSBTdHJpbmcodGhpcy50ZXh0KS5zcGxpdCgvKD86XFxyXFxufFxccnxcXG4pLyk7XG5cdFx0Zm9yICh2YXIgaT0wLCBsPWhhcmRMaW5lcy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR2YXIgc3RyID0gaGFyZExpbmVzW2ldO1xuXHRcdFx0dmFyIHcgPSBudWxsO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5saW5lV2lkdGggIT0gbnVsbCAmJiAodyA9IGN0eC5tZWFzdXJlVGV4dChzdHIpLndpZHRoKSA+IHRoaXMubGluZVdpZHRoKSB7XG5cdFx0XHRcdC8vIHRleHQgd3JhcHBpbmc6XG5cdFx0XHRcdHZhciB3b3JkcyA9IHN0ci5zcGxpdCgvKFxccykvKTtcblx0XHRcdFx0c3RyID0gd29yZHNbMF07XG5cdFx0XHRcdHcgPSBjdHgubWVhc3VyZVRleHQoc3RyKS53aWR0aDtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAodmFyIGo9MSwgamw9d29yZHMubGVuZ3RoOyBqPGpsOyBqKz0yKSB7XG5cdFx0XHRcdFx0Ly8gTGluZSBuZWVkcyB0byB3cmFwOlxuXHRcdFx0XHRcdHZhciB3b3JkVyA9IGN0eC5tZWFzdXJlVGV4dCh3b3Jkc1tqXSArIHdvcmRzW2orMV0pLndpZHRoO1xuXHRcdFx0XHRcdGlmICh3ICsgd29yZFcgPiB0aGlzLmxpbmVXaWR0aCkge1xuXHRcdFx0XHRcdFx0aWYgKHBhaW50KSB7IHRoaXMuX2RyYXdUZXh0TGluZShjdHgsIHN0ciwgY291bnQqbGluZUhlaWdodCk7IH1cblx0XHRcdFx0XHRcdGlmIChsaW5lcykgeyBsaW5lcy5wdXNoKHN0cik7IH1cblx0XHRcdFx0XHRcdGlmICh3ID4gbWF4VykgeyBtYXhXID0gdzsgfVxuXHRcdFx0XHRcdFx0c3RyID0gd29yZHNbaisxXTtcblx0XHRcdFx0XHRcdHcgPSBjdHgubWVhc3VyZVRleHQoc3RyKS53aWR0aDtcblx0XHRcdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0ciArPSB3b3Jkc1tqXSArIHdvcmRzW2orMV07XG5cdFx0XHRcdFx0XHR3ICs9IHdvcmRXO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAocGFpbnQpIHsgdGhpcy5fZHJhd1RleHRMaW5lKGN0eCwgc3RyLCBjb3VudCpsaW5lSGVpZ2h0KTsgfVxuXHRcdFx0aWYgKGxpbmVzKSB7IGxpbmVzLnB1c2goc3RyKTsgfVxuXHRcdFx0aWYgKG8gJiYgdyA9PSBudWxsKSB7IHcgPSBjdHgubWVhc3VyZVRleHQoc3RyKS53aWR0aDsgfVxuXHRcdFx0aWYgKHcgPiBtYXhXKSB7IG1heFcgPSB3OyB9XG5cdFx0XHRjb3VudCsrO1xuXHRcdH1cblx0XHRcblx0XHRpZiAobykge1xuXHRcdFx0by53aWR0aCA9IG1heFc7XG5cdFx0XHRvLmhlaWdodCA9IGNvdW50KmxpbmVIZWlnaHQ7XG5cdFx0fVxuXHRcdGlmICghcGFpbnQpIHsgY3R4LnJlc3RvcmUoKTsgfVxuXHRcdHJldHVybiBvO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9kcmF3VGV4dExpbmVcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZHJhd1RleHRMaW5lID0gZnVuY3Rpb24oY3R4LCB0ZXh0LCB5KSB7XG5cdFx0Ly8gQ2hyb21lIDE3IHdpbGwgZmFpbCB0byBkcmF3IHRoZSB0ZXh0IGlmIHRoZSBsYXN0IHBhcmFtIGlzIGluY2x1ZGVkIGJ1dCBudWxsLCBzbyB3ZSBmZWVkIGl0IGEgbGFyZ2UgdmFsdWUgaW5zdGVhZDpcblx0XHRpZiAodGhpcy5vdXRsaW5lKSB7IGN0eC5zdHJva2VUZXh0KHRleHQsIDAsIHksIHRoaXMubWF4V2lkdGh8fDB4RkZGRik7IH1cblx0XHRlbHNlIHsgY3R4LmZpbGxUZXh0KHRleHQsIDAsIHksIHRoaXMubWF4V2lkdGh8fDB4RkZGRik7IH1cblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0TWVhc3VyZWRXaWR0aFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ2V0TWVhc3VyZWRXaWR0aCA9IGZ1bmN0aW9uKHRleHQpIHtcblx0XHR2YXIgY3R4ID0gVGV4dC5fd29ya2luZ0NvbnRleHQ7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHR2YXIgdyA9IHRoaXMuX3ByZXBDb250ZXh0KGN0eCkubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRyZXR1cm4gdztcblx0fTtcblxuXG5cdGNyZWF0ZWpzLlRleHQgPSBjcmVhdGVqcy5wcm9tb3RlKFRleHQsIFwiRGlzcGxheU9iamVjdFwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBCaXRtYXBUZXh0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIERpc3BsYXlzIHRleHQgdXNpbmcgYml0bWFwIGdseXBocyBkZWZpbmVkIGluIGEgc3ByaXRlIHNoZWV0LiBNdWx0aS1saW5lIHRleHQgaXMgc3VwcG9ydGVkXG5cdCAqIHVzaW5nIG5ldyBsaW5lIGNoYXJhY3RlcnMsIGJ1dCBhdXRvbWF0aWMgd3JhcHBpbmcgaXMgbm90IHN1cHBvcnRlZC4gU2VlIHRoZSBcblx0ICoge3sjY3Jvc3NMaW5rIFwiQml0bWFwVGV4dC9zcHJpdGVTaGVldDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBwcm9wZXJ0eSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBkZWZpbmluZyBnbHlwaHMuXG5cdCAqIFxuXHQgKiA8c3Ryb25nPkltcG9ydGFudDo8L3N0cm9uZz4gQml0bWFwVGV4dCBleHRlbmRzIENvbnRhaW5lciwgYnV0IGlzIG5vdCBkZXNpZ25lZCB0byBiZSB1c2VkIGFzIG9uZS5cblx0ICogQXMgc3VjaCwgbWV0aG9kcyBsaWtlIGFkZENoaWxkIGFuZCByZW1vdmVDaGlsZCBhcmUgZGlzYWJsZWQuXG5cdCAqIEBjbGFzcyBCaXRtYXBUZXh0XG5cdCAqIEBleHRlbmRzIERpc3BsYXlPYmplY3Rcblx0ICogQHBhcmFtIHtTdHJpbmd9IFt0ZXh0PVwiXCJdIFRoZSB0ZXh0IHRvIGRpc3BsYXkuXG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IFtzcHJpdGVTaGVldD1udWxsXSBUaGUgc3ByaXRlc2hlZXQgdGhhdCBkZWZpbmVzIHRoZSBjaGFyYWN0ZXIgZ2x5cGhzLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBCaXRtYXBUZXh0KHRleHQsIHNwcml0ZVNoZWV0KSB7XG5cdFx0dGhpcy5Db250YWluZXJfY29uc3RydWN0b3IoKTtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIHRleHQgdG8gZGlzcGxheS5cblx0XHQgKiBAcHJvcGVydHkgdGV4dFxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqIEBkZWZhdWx0IFwiXCJcblx0XHQgKiovXG5cdFx0dGhpcy50ZXh0ID0gdGV4dHx8XCJcIjtcblx0XHRcblx0XHQvKipcblx0XHQgKiBBIFNwcml0ZVNoZWV0IGluc3RhbmNlIHRoYXQgZGVmaW5lcyB0aGUgZ2x5cGhzIGZvciB0aGlzIGJpdG1hcCB0ZXh0LiBFYWNoIGdseXBoL2NoYXJhY3RlclxuXHRcdCAqIHNob3VsZCBoYXZlIGEgc2luZ2xlIGZyYW1lIGFuaW1hdGlvbiBkZWZpbmVkIGluIHRoZSBzcHJpdGUgc2hlZXQgbmFtZWQgdGhlIHNhbWUgYXNcblx0XHQgKiBjb3JyZXNwb25kaW5nIGNoYXJhY3Rlci4gRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgYW5pbWF0aW9uIGRlZmluaXRpb246XG5cdFx0ICpcblx0XHQgKiBcdFx0XCJBXCI6IHtmcmFtZXM6IFswXX1cblx0XHQgKlxuXHRcdCAqIHdvdWxkIGluZGljYXRlIHRoYXQgdGhlIGZyYW1lIGF0IGluZGV4IDAgb2YgdGhlIHNwcml0ZXNoZWV0IHNob3VsZCBiZSBkcmF3biBmb3IgdGhlIFwiQVwiIGNoYXJhY3Rlci4gVGhlIHNob3J0IGZvcm1cblx0XHQgKiBpcyBhbHNvIGFjY2VwdGFibGU6XG5cdFx0ICogXG5cdFx0ICogXHRcdFwiQVwiOiAwXG5cdFx0ICpcblx0XHQgKiBOb3RlIHRoYXQgaWYgYSBjaGFyYWN0ZXIgaW4gdGhlIHRleHQgaXMgbm90IGZvdW5kIGluIHRoZSBzcHJpdGUgc2hlZXQsIGl0IHdpbGwgYWxzb1xuXHRcdCAqIHRyeSB0byB1c2UgdGhlIGFsdGVybmF0ZSBjYXNlICh1cHBlciBvciBsb3dlcikuXG5cdFx0ICpcblx0XHQgKiBTZWUgU3ByaXRlU2hlZXQgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gZGVmaW5pbmcgc3ByaXRlIHNoZWV0IGRhdGEuXG5cdFx0ICogQHByb3BlcnR5IHNwcml0ZVNoZWV0XG5cdFx0ICogQHR5cGUgU3ByaXRlU2hlZXRcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMuc3ByaXRlU2hlZXQgPSBzcHJpdGVTaGVldDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGhlaWdodCBvZiBlYWNoIGxpbmUgb2YgdGV4dC4gSWYgMCwgdGhlbiBpdCB3aWxsIHVzZSBhIGxpbmUgaGVpZ2h0IGNhbGN1bGF0ZWRcblx0XHQgKiBieSBjaGVja2luZyBmb3IgdGhlIGhlaWdodCBvZiB0aGUgXCIxXCIsIFwiVFwiLCBvciBcIkxcIiBjaGFyYWN0ZXIgKGluIHRoYXQgb3JkZXIpLiBJZlxuXHRcdCAqIHRob3NlIGNoYXJhY3RlcnMgYXJlIG5vdCBkZWZpbmVkLCBpdCB3aWxsIHVzZSB0aGUgaGVpZ2h0IG9mIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGVcblx0XHQgKiBzcHJpdGUgc2hlZXQuXG5cdFx0ICogQHByb3BlcnR5IGxpbmVIZWlnaHRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMubGluZUhlaWdodCA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgc3BhY2luZyAoaW4gcGl4ZWxzKSB3aWxsIGJlIGFkZGVkIGFmdGVyIGVhY2ggY2hhcmFjdGVyIGluIHRoZSBvdXRwdXQuXG5cdFx0ICogQHByb3BlcnR5IGxldHRlclNwYWNpbmdcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMubGV0dGVyU3BhY2luZyA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIGEgc3BhY2UgY2hhcmFjdGVyIGlzIG5vdCBkZWZpbmVkIGluIHRoZSBzcHJpdGUgc2hlZXQsIHRoZW4gZW1wdHkgcGl4ZWxzIGVxdWFsIHRvXG5cdFx0ICogc3BhY2VXaWR0aCB3aWxsIGJlIGluc2VydGVkIGluc3RlYWQuIElmIDAsIHRoZW4gaXQgd2lsbCB1c2UgYSB2YWx1ZSBjYWxjdWxhdGVkXG5cdFx0ICogYnkgY2hlY2tpbmcgZm9yIHRoZSB3aWR0aCBvZiB0aGUgXCIxXCIsIFwibFwiLCBcIkVcIiwgb3IgXCJBXCIgY2hhcmFjdGVyIChpbiB0aGF0IG9yZGVyKS4gSWZcblx0XHQgKiB0aG9zZSBjaGFyYWN0ZXJzIGFyZSBub3QgZGVmaW5lZCwgaXQgd2lsbCB1c2UgdGhlIHdpZHRoIG9mIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGVcblx0XHQgKiBzcHJpdGUgc2hlZXQuXG5cdFx0ICogQHByb3BlcnR5IHNwYWNlV2lkdGhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMuc3BhY2VXaWR0aCA9IDA7XG5cdFx0XG5cdFx0XG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0IFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9vbGRQcm9wc1xuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5fb2xkUHJvcHMgPSB7dGV4dDowLHNwcml0ZVNoZWV0OjAsbGluZUhlaWdodDowLGxldHRlclNwYWNpbmc6MCxzcGFjZVdpZHRoOjB9O1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEJpdG1hcFRleHQsIGNyZWF0ZWpzLkNvbnRhaW5lcik7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG4vLyBzdGF0aWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIEJpdG1hcFRleHQgdXNlcyBTcHJpdGUgaW5zdGFuY2VzIHRvIGRyYXcgdGV4dC4gVG8gcmVkdWNlIHRoZSBjcmVhdGlvbiBhbmQgZGVzdHJ1Y3Rpb24gb2YgaW5zdGFuY2VzIChhbmQgdGh1cyBnYXJiYWdlIGNvbGxlY3Rpb24pLCBpdCBtYWludGFpbnNcblx0ICogYW4gaW50ZXJuYWwgb2JqZWN0IHBvb2wgb2Ygc3ByaXRlIGluc3RhbmNlcyB0byByZXVzZS4gSW5jcmVhc2luZyB0aGlzIHZhbHVlIGNhbiBjYXVzZSBtb3JlIHNwcml0ZXMgdG8gYmVcblx0ICogcmV0YWluZWQsIHNsaWdodGx5IGluY3JlYXNpbmcgbWVtb3J5IHVzZSwgYnV0IHJlZHVjaW5nIGluc3RhbnRpYXRpb24uXG5cdCAqIEBwcm9wZXJ0eSBtYXhQb29sU2l6ZVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVmYXVsdCAxMDBcblx0ICoqL1xuXHRCaXRtYXBUZXh0Lm1heFBvb2xTaXplID0gMTAwO1xuXHRcblx0LyoqXG5cdCAqIFNwcml0ZSBvYmplY3QgcG9vbC5cblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRCaXRtYXBUZXh0Ll9zcHJpdGVQb29sID0gW107XG5cblx0XG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIERvY2NlZCBpbiBzdXBlcmNsYXNzLlxuXHQgKiovXG5cdHAuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgaWdub3JlQ2FjaGUpIHtcblx0XHRpZiAodGhpcy5EaXNwbGF5T2JqZWN0X2RyYXcoY3R4LCBpZ25vcmVDYWNoZSkpIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5fdXBkYXRlVGV4dCgpO1xuXHRcdHRoaXMuQ29udGFpbmVyX2RyYXcoY3R4LCBpZ25vcmVDYWNoZSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogRG9jY2VkIGluIHN1cGVyY2xhc3MuXG5cdCAqKi9cblx0cC5nZXRCb3VuZHMgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl91cGRhdGVUZXh0KCk7XG5cdFx0cmV0dXJuIHRoaXMuQ29udGFpbmVyX2dldEJvdW5kcygpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXMuXG5cdCAqIFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3Igd2hldGhlciBpdCB3b3VsZCBiZSB2aXNpYmxlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgc3RhZ2UuXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBpc1Zpc2libGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXNcblx0ICoqL1xuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYXNDb250ZW50ID0gdGhpcy5jYWNoZUNhbnZhcyB8fCAodGhpcy5zcHJpdGVTaGVldCAmJiB0aGlzLnNwcml0ZVNoZWV0LmNvbXBsZXRlICYmIHRoaXMudGV4dCk7XG5cdFx0cmV0dXJuICEhKHRoaXMudmlzaWJsZSAmJiB0aGlzLmFscGhhID4gMCAmJiB0aGlzLnNjYWxlWCAhPT0gMCAmJiB0aGlzLnNjYWxlWSAhPT0gMCAmJiBoYXNDb250ZW50KTtcblx0fTtcblx0XG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmVQcm9wcyhuZXcgQml0bWFwVGV4dCh0aGlzLnRleHQsIHRoaXMuc3ByaXRlU2hlZXQpKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiA8c3Ryb25nPkRpc2FibGVkIGluIEJpdG1hcFRleHQuPC9zdHJvbmc+XG5cdCAqIEBtZXRob2QgYWRkQ2hpbGRcblx0ICoqL1xuXHQvKipcblx0ICogPHN0cm9uZz5EaXNhYmxlZCBpbiBCaXRtYXBUZXh0Ljwvc3Ryb25nPlxuXHQgKiBAbWV0aG9kIGFkZENoaWxkQXRcblx0ICoqL1xuXHQvKipcblx0ICogPHN0cm9uZz5EaXNhYmxlZCBpbiBCaXRtYXBUZXh0Ljwvc3Ryb25nPlxuXHQgKiBAbWV0aG9kIHJlbW92ZUNoaWxkXG5cdCAqKi9cblx0LyoqXG5cdCAqIDxzdHJvbmc+RGlzYWJsZWQgaW4gQml0bWFwVGV4dC48L3N0cm9uZz5cblx0ICogQG1ldGhvZCByZW1vdmVDaGlsZEF0XG5cdCAqKi9cblx0LyoqXG5cdCAqIDxzdHJvbmc+RGlzYWJsZWQgaW4gQml0bWFwVGV4dC48L3N0cm9uZz5cblx0ICogQG1ldGhvZCByZW1vdmVBbGxDaGlsZHJlblxuXHQgKiovXG5cdHAuYWRkQ2hpbGQgPSBwLmFkZENoaWxkQXQgPSBwLnJlbW92ZUNoaWxkID0gcC5yZW1vdmVDaGlsZEF0ID0gcC5yZW1vdmVBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uKCkge307XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuIFx0LyoqXG5cdCAqIEBtZXRob2QgX2Nsb25lUHJvcHNcblx0ICogQHBhcmFtIHtCaXRtYXBUZXh0fSBvXG5cdCAqIEByZXR1cm4ge0JpdG1hcFRleHR9IG9cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2Nsb25lUHJvcHMgPSBmdW5jdGlvbihvKSB7XG5cdFx0dGhpcy5Db250YWluZXJfX2Nsb25lUHJvcHMobyk7XG5cdFx0by5saW5lSGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0O1xuXHRcdG8ubGV0dGVyU3BhY2luZyA9IHRoaXMubGV0dGVyU3BhY2luZztcblx0XHRvLnNwYWNlV2lkdGggPSB0aGlzLnNwYWNlV2lkdGg7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0RnJhbWVJbmRleFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY2hhcmFjdGVyXG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IHNwcml0ZVNoZWV0XG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dldEZyYW1lSW5kZXggPSBmdW5jdGlvbihjaGFyYWN0ZXIsIHNwcml0ZVNoZWV0KSB7XG5cdFx0dmFyIGMsIG8gPSBzcHJpdGVTaGVldC5nZXRBbmltYXRpb24oY2hhcmFjdGVyKTtcblx0XHRpZiAoIW8pIHtcblx0XHRcdChjaGFyYWN0ZXIgIT0gKGMgPSBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKSkpIHx8IChjaGFyYWN0ZXIgIT0gKGMgPSBjaGFyYWN0ZXIudG9Mb3dlckNhc2UoKSkpIHx8IChjPW51bGwpO1xuXHRcdFx0aWYgKGMpIHsgbyA9IHNwcml0ZVNoZWV0LmdldEFuaW1hdGlvbihjKTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gbyAmJiBvLmZyYW1lc1swXTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRGcmFtZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY2hhcmFjdGVyXG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IHNwcml0ZVNoZWV0XG5cdCAqIEByZXR1cm4ge09iamVjdH1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dldEZyYW1lID0gZnVuY3Rpb24oY2hhcmFjdGVyLCBzcHJpdGVTaGVldCkge1xuXHRcdHZhciBpbmRleCA9IHRoaXMuX2dldEZyYW1lSW5kZXgoY2hhcmFjdGVyLCBzcHJpdGVTaGVldCk7XG5cdFx0cmV0dXJuIGluZGV4ID09IG51bGwgPyBpbmRleCA6IHNwcml0ZVNoZWV0LmdldEZyYW1lKGluZGV4KTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRMaW5lSGVpZ2h0XG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IHNzXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dldExpbmVIZWlnaHQgPSBmdW5jdGlvbihzcykge1xuXHRcdHZhciBmcmFtZSA9IHRoaXMuX2dldEZyYW1lKFwiMVwiLHNzKSB8fCB0aGlzLl9nZXRGcmFtZShcIlRcIixzcykgfHwgdGhpcy5fZ2V0RnJhbWUoXCJMXCIsc3MpIHx8IHNzLmdldEZyYW1lKDApO1xuXHRcdHJldHVybiBmcmFtZSA/IGZyYW1lLnJlY3QuaGVpZ2h0IDogMTtcblx0fTtcblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldFNwYWNlV2lkdGhcblx0ICogQHBhcmFtIHtTcHJpdGVTaGVldH0gc3Ncblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ2V0U3BhY2VXaWR0aCA9IGZ1bmN0aW9uKHNzKSB7XG5cdFx0dmFyIGZyYW1lID0gdGhpcy5fZ2V0RnJhbWUoXCIxXCIsc3MpIHx8IHRoaXMuX2dldEZyYW1lKFwibFwiLHNzKSB8fCB0aGlzLl9nZXRGcmFtZShcImVcIixzcykgfHwgdGhpcy5fZ2V0RnJhbWUoXCJhXCIsc3MpIHx8IHNzLmdldEZyYW1lKDApO1xuXHRcdHJldHVybiBmcmFtZSA/IGZyYW1lLnJlY3Qud2lkdGggOiAxO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2RyYXdUZXh0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl91cGRhdGVUZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHg9MCwgeT0wLCBvPXRoaXMuX29sZFByb3BzLCBjaGFuZ2U9ZmFsc2UsIHNwYWNlVz10aGlzLnNwYWNlV2lkdGgsIGxpbmVIPXRoaXMubGluZUhlaWdodCwgc3M9dGhpcy5zcHJpdGVTaGVldDtcblx0XHR2YXIgcG9vbD1CaXRtYXBUZXh0Ll9zcHJpdGVQb29sLCBraWRzPXRoaXMuY2hpbGRyZW4sIGNoaWxkSW5kZXg9MCwgbnVtS2lkcz1raWRzLmxlbmd0aCwgc3ByaXRlO1xuXHRcdFxuXHRcdGZvciAodmFyIG4gaW4gbykge1xuXHRcdFx0aWYgKG9bbl0gIT0gdGhpc1tuXSkge1xuXHRcdFx0XHRvW25dID0gdGhpc1tuXTtcblx0XHRcdFx0Y2hhbmdlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFjaGFuZ2UpIHsgcmV0dXJuOyB9XG5cdFx0XG5cdFx0dmFyIGhhc1NwYWNlID0gISF0aGlzLl9nZXRGcmFtZShcIiBcIiwgc3MpO1xuXHRcdGlmICghaGFzU3BhY2UgJiYgIXNwYWNlVykgeyBzcGFjZVcgPSB0aGlzLl9nZXRTcGFjZVdpZHRoKHNzKTsgfVxuXHRcdGlmICghbGluZUgpIHsgbGluZUggPSB0aGlzLl9nZXRMaW5lSGVpZ2h0KHNzKTsgfVxuXHRcdFxuXHRcdGZvcih2YXIgaT0wLCBsPXRoaXMudGV4dC5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hhcmFjdGVyID0gdGhpcy50ZXh0LmNoYXJBdChpKTtcblx0XHRcdGlmIChjaGFyYWN0ZXIgPT0gXCIgXCIgJiYgIWhhc1NwYWNlKSB7XG5cdFx0XHRcdHggKz0gc3BhY2VXO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSBpZiAoY2hhcmFjdGVyPT1cIlxcblwiIHx8IGNoYXJhY3Rlcj09XCJcXHJcIikge1xuXHRcdFx0XHRpZiAoY2hhcmFjdGVyPT1cIlxcclwiICYmIHRoaXMudGV4dC5jaGFyQXQoaSsxKSA9PSBcIlxcblwiKSB7IGkrKzsgfSAvLyBjcmxmXG5cdFx0XHRcdHggPSAwO1xuXHRcdFx0XHR5ICs9IGxpbmVIO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGluZGV4ID0gdGhpcy5fZ2V0RnJhbWVJbmRleChjaGFyYWN0ZXIsIHNzKTtcblx0XHRcdGlmIChpbmRleCA9PSBudWxsKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRcblx0XHRcdGlmIChjaGlsZEluZGV4IDwgbnVtS2lkcykge1xuXHRcdFx0XHRzcHJpdGUgPSBraWRzW2NoaWxkSW5kZXhdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2lkcy5wdXNoKHNwcml0ZSA9IHBvb2wubGVuZ3RoID8gcG9vbC5wb3AoKSA6IG5ldyBjcmVhdGVqcy5TcHJpdGUoKSk7XG5cdFx0XHRcdHNwcml0ZS5wYXJlbnQgPSB0aGlzO1xuXHRcdFx0XHRudW1LaWRzKys7XG5cdFx0XHR9XG5cdFx0XHRzcHJpdGUuc3ByaXRlU2hlZXQgPSBzcztcblx0XHRcdHNwcml0ZS5nb3RvQW5kU3RvcChpbmRleCk7XG5cdFx0XHRzcHJpdGUueCA9IHg7XG5cdFx0XHRzcHJpdGUueSA9IHk7XG5cdFx0XHRjaGlsZEluZGV4Kys7XG5cdFx0XHRcblx0XHRcdHggKz0gc3ByaXRlLmdldEJvdW5kcygpLndpZHRoICsgdGhpcy5sZXR0ZXJTcGFjaW5nO1xuXHRcdH1cblx0XHR3aGlsZSAobnVtS2lkcyA+IGNoaWxkSW5kZXgpIHtcblx0XHRcdCAvLyBmYXN0ZXIgdGhhbiByZW1vdmVDaGlsZC5cblx0XHRcdHBvb2wucHVzaChzcHJpdGUgPSBraWRzLnBvcCgpKTtcblx0XHRcdHNwcml0ZS5wYXJlbnQgPSBudWxsO1xuXHRcdFx0bnVtS2lkcy0tO1xuXHRcdH1cblx0XHRpZiAocG9vbC5sZW5ndGggPiBCaXRtYXBUZXh0Lm1heFBvb2xTaXplKSB7IHBvb2wubGVuZ3RoID0gQml0bWFwVGV4dC5tYXhQb29sU2l6ZTsgfVxuXHR9O1xuXG5cblx0Y3JlYXRlanMuQml0bWFwVGV4dCA9IGNyZWF0ZWpzLnByb21vdGUoQml0bWFwVGV4dCwgXCJDb250YWluZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gTW92aWVDbGlwLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogVGhlIE1vdmllQ2xpcCBjbGFzcyBhc3NvY2lhdGVzIGEgVHdlZW5KUyBUaW1lbGluZSB3aXRoIGFuIEVhc2VsSlMge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyXCJ9fXt7L2Nyb3NzTGlua319LiBJdCBhbGxvd3Ncblx0ICogeW91IHRvIGNyZWF0ZSBvYmplY3RzIHdoaWNoIGVuY2Fwc3VsYXRlIHRpbWVsaW5lIGFuaW1hdGlvbnMsIHN0YXRlIGNoYW5nZXMsIGFuZCBzeW5jaGVkIGFjdGlvbnMuIER1ZSB0byB0aGVcblx0ICogY29tcGxleGl0aWVzIGluaGVyZW50IGluIGNvcnJlY3RseSBzZXR0aW5nIHVwIGEgTW92aWVDbGlwLCBpdCBpcyBsYXJnZWx5IGludGVuZGVkIGZvciB0b29sIG91dHB1dCBhbmQgaXMgbm90IGluY2x1ZGVkXG5cdCAqIGluIHRoZSBtYWluIEVhc2VsSlMgbGlicmFyeS5cblx0ICpcblx0ICogQ3VycmVudGx5IE1vdmllQ2xpcCBvbmx5IHdvcmtzIHByb3Blcmx5IGlmIGl0IGlzIHRpY2sgYmFzZWQgKGFzIG9wcG9zZWQgdG8gdGltZSBiYXNlZCkgdGhvdWdoIHNvbWUgY29uY2Vzc2lvbnMgaGF2ZVxuXHQgKiBiZWVuIG1hZGUgdG8gc3VwcG9ydCB0aW1lLWJhc2VkIHRpbWVsaW5lcyBpbiB0aGUgZnV0dXJlLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIFRoaXMgZXhhbXBsZSBhbmltYXRlcyB0d28gc2hhcGVzIGJhY2sgYW5kIGZvcnRoLiBUaGUgZ3JleSBzaGFwZSBzdGFydHMgb24gdGhlIGxlZnQsIGJ1dCB3ZSBqdW1wIHRvIGEgbWlkLXBvaW50IGluXG5cdCAqIHRoZSBhbmltYXRpb24gdXNpbmcge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiAgICAgIHZhciBzdGFnZSA9IG5ldyBjcmVhdGVqcy5TdGFnZShcImNhbnZhc1wiKTtcblx0ICogICAgICBjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgc3RhZ2UpO1xuXHQgKlxuXHQgKiAgICAgIHZhciBtYyA9IG5ldyBjcmVhdGVqcy5Nb3ZpZUNsaXAobnVsbCwgMCwgdHJ1ZSwge3N0YXJ0OjIwfSk7XG5cdCAqICAgICAgc3RhZ2UuYWRkQ2hpbGQobWMpO1xuXHQgKlxuXHQgKiAgICAgIHZhciBjaGlsZDEgPSBuZXcgY3JlYXRlanMuU2hhcGUoXG5cdCAqICAgICAgICAgIG5ldyBjcmVhdGVqcy5HcmFwaGljcygpLmJlZ2luRmlsbChcIiM5OTk5OTlcIilcblx0ICogICAgICAgICAgICAgIC5kcmF3Q2lyY2xlKDMwLDMwLDMwKSk7XG5cdCAqICAgICAgdmFyIGNoaWxkMiA9IG5ldyBjcmVhdGVqcy5TaGFwZShcblx0ICogICAgICAgICAgbmV3IGNyZWF0ZWpzLkdyYXBoaWNzKCkuYmVnaW5GaWxsKFwiIzVhOWNmYlwiKVxuXHQgKiAgICAgICAgICAgICAgLmRyYXdDaXJjbGUoMzAsMzAsMzApKTtcblx0ICpcblx0ICogICAgICBtYy50aW1lbGluZS5hZGRUd2Vlbihcblx0ICogICAgICAgICAgY3JlYXRlanMuVHdlZW4uZ2V0KGNoaWxkMSlcblx0ICogICAgICAgICAgICAgIC50byh7eDowfSkudG8oe3g6NjB9LCA1MCkudG8oe3g6MH0sIDUwKSk7XG5cdCAqICAgICAgbWMudGltZWxpbmUuYWRkVHdlZW4oXG5cdCAqICAgICAgICAgIGNyZWF0ZWpzLlR3ZWVuLmdldChjaGlsZDIpXG5cdCAqICAgICAgICAgICAgICAudG8oe3g6NjB9KS50byh7eDowfSwgNTApLnRvKHt4OjYwfSwgNTApKTtcblx0ICpcblx0ICogICAgICBtYy5nb3RvQW5kUGxheShcInN0YXJ0XCIpO1xuXHQgKlxuXHQgKiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgPGNvZGU+dHdlZW4udG8oKTwvY29kZT4gdG8gYW5pbWF0ZSBhbmQgc2V0IHByb3BlcnRpZXMgKHVzZSBubyBkdXJhdGlvbiB0byBoYXZlIGl0IHNldFxuXHQgKiBpbW1lZGlhdGVseSksIGFuZCB0aGUgPGNvZGU+dHdlZW4ud2FpdCgpPC9jb2RlPiBtZXRob2QgdG8gY3JlYXRlIGRlbGF5cyBiZXR3ZWVuIGFuaW1hdGlvbnMuIE5vdGUgdGhhdCB1c2luZyB0aGVcblx0ICogPGNvZGU+dHdlZW4uc2V0KCk8L2NvZGU+IG1ldGhvZCB0byBhZmZlY3QgcHJvcGVydGllcyB3aWxsIGxpa2VseSBub3QgcHJvdmlkZSB0aGUgZGVzaXJlZCByZXN1bHQuXG5cdCAqXG5cdCAqIEBjbGFzcyBNb3ZpZUNsaXBcblx0ICogQG1haW4gTW92aWVDbGlwXG5cdCAqIEBleHRlbmRzIENvbnRhaW5lclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtTdHJpbmd9IFttb2RlPWluZGVwZW5kZW50XSBJbml0aWFsIHZhbHVlIGZvciB0aGUgbW9kZSBwcm9wZXJ0eS4gT25lIG9mIHt7I2Nyb3NzTGluayBcIk1vdmllQ2xpcC9JTkRFUEVOREVOVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICoge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwL1NJTkdMRV9GUkFNRTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSwgb3Ige3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwL1NZTkNIRUQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHt7I2Nyb3NzTGluayBcIk1vdmllQ2xpcC9JTkRFUEVOREVOVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydFBvc2l0aW9uPTBdIEluaXRpYWwgdmFsdWUgZm9yIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3ZpZUNsaXAvc3RhcnRQb3NpdGlvbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBwcm9wZXJ0eS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbbG9vcD10cnVlXSBJbml0aWFsIHZhbHVlIGZvciB0aGUge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwL2xvb3A6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogcHJvcGVydHkuIFRoZSBkZWZhdWx0IGlzIGB0cnVlYC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtsYWJlbHM9bnVsbF0gQSBoYXNoIG9mIGxhYmVscyB0byBwYXNzIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3ZpZUNsaXAvdGltZWxpbmU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaW5zdGFuY2UgYXNzb2NpYXRlZCB3aXRoIHRoaXMgTW92aWVDbGlwLiBMYWJlbHMgb25seSBuZWVkIHRvIGJlIHBhc3NlZCBpZiB0aGV5IG5lZWQgdG8gYmUgdXNlZC5cblx0ICoqL1xuXHRmdW5jdGlvbiBNb3ZpZUNsaXAobW9kZSwgc3RhcnRQb3NpdGlvbiwgbG9vcCwgbGFiZWxzKSB7XG5cdFx0dGhpcy5Db250YWluZXJfY29uc3RydWN0b3IoKTtcblx0XHQhTW92aWVDbGlwLmluaXRlZCYmTW92aWVDbGlwLmluaXQoKTsgLy8gc3RhdGljIGluaXRcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQ29udHJvbHMgaG93IHRoaXMgTW92aWVDbGlwIGFkdmFuY2VzIGl0cyB0aW1lLiBNdXN0IGJlIG9uZSBvZiAwIChJTkRFUEVOREVOVCksIDEgKFNJTkdMRV9GUkFNRSksIG9yIDIgKFNZTkNIRUQpLlxuXHRcdCAqIFNlZSBlYWNoIGNvbnN0YW50IGZvciBhIGRlc2NyaXB0aW9uIG9mIHRoZSBiZWhhdmlvdXIuXG5cdFx0ICogQHByb3BlcnR5IG1vZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMubW9kZSA9IG1vZGV8fE1vdmllQ2xpcC5JTkRFUEVOREVOVDtcblx0XG5cdFx0LyoqXG5cdFx0ICogU3BlY2lmaWVzIHdoYXQgdGhlIGZpcnN0IGZyYW1lIHRvIHBsYXkgaW4gdGhpcyBtb3ZpZWNsaXAsIG9yIHRoZSBvbmx5IGZyYW1lIHRvIGRpc3BsYXkgaWYgbW9kZSBpcyBTSU5HTEVfRlJBTUUuXG5cdFx0ICogQHByb3BlcnR5IHN0YXJ0UG9zaXRpb25cblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbiB8fCAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIE1vdmllQ2xpcCBzaG91bGQgbG9vcCB3aGVuIGl0IHJlYWNoZXMgdGhlIGVuZCBvZiBpdHMgdGltZWxpbmUuXG5cdFx0ICogQHByb3BlcnR5IGxvb3Bcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMubG9vcCA9IGxvb3A7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IGZyYW1lIG9mIHRoZSBtb3ZpZWNsaXAuXG5cdFx0ICogQHByb3BlcnR5IGN1cnJlbnRGcmFtZVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBUd2VlbkpTIFRpbWVsaW5lIHRoYXQgaXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgTW92aWVDbGlwLiBUaGlzIGlzIGNyZWF0ZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBNb3ZpZUNsaXBcblx0XHQgKiBpbnN0YW5jZSBpcyBpbml0aWFsaXplZC4gQW5pbWF0aW9ucyBhcmUgY3JlYXRlZCBieSBhZGRpbmcgPGEgaHJlZj1cImh0dHA6Ly90d2VlbmpzLmNvbVwiPlR3ZWVuSlM8L2E+IFR3ZWVuXG5cdFx0ICogaW5zdGFuY2VzIHRvIHRoZSB0aW1lbGluZS5cblx0XHQgKlxuXHRcdCAqIDxoND5FeGFtcGxlPC9oND5cblx0XHQgKlxuXHRcdCAqICAgICAgdmFyIHR3ZWVuID0gY3JlYXRlanMuVHdlZW4uZ2V0KHRhcmdldCkudG8oe3g6MH0pLnRvKHt4OjEwMH0sIDMwKTtcblx0XHQgKiAgICAgIHZhciBtYyA9IG5ldyBjcmVhdGVqcy5Nb3ZpZUNsaXAoKTtcblx0XHQgKiAgICAgIG1jLnRpbWVsaW5lLmFkZFR3ZWVuKHR3ZWVuKTtcblx0XHQgKlxuXHRcdCAqIEVsZW1lbnRzIGNhbiBiZSBhZGRlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZSB0aW1lbGluZSBieSB0b2dnbGluZyBhbiBcIl9vZmZcIiBwcm9wZXJ0eVxuXHRcdCAqIHVzaW5nIHRoZSA8Y29kZT50d2Vlbkluc3RhbmNlLnRvKCk8L2NvZGU+IG1ldGhvZC4gTm90ZSB0aGF0IHVzaW5nIDxjb2RlPlR3ZWVuLnNldDwvY29kZT4gaXMgbm90IHJlY29tbWVuZGVkIHRvXG5cdFx0ICogY3JlYXRlIE1vdmllQ2xpcCBhbmltYXRpb25zLiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgd2lsbCB0b2dnbGUgdGhlIHRhcmdldCBvZmYgb24gZnJhbWUgMCwgYW5kIHRoZW4gYmFjayBvbiBmb3Jcblx0XHQgKiBmcmFtZSAxLiBZb3UgY2FuIHVzZSB0aGUgXCJ2aXNpYmxlXCIgcHJvcGVydHkgdG8gYWNoaWV2ZSB0aGUgc2FtZSBlZmZlY3QuXG5cdFx0ICpcblx0XHQgKiAgICAgIHZhciB0d2VlbiA9IGNyZWF0ZWpzLlR3ZWVuLmdldCh0YXJnZXQpLnRvKHtfb2ZmOmZhbHNlfSlcblx0XHQgKiAgICAgICAgICAud2FpdCgxKS50byh7X29mZjp0cnVlfSlcblx0XHQgKiAgICAgICAgICAud2FpdCgxKS50byh7X29mZjpmYWxzZX0pO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHRpbWVsaW5lXG5cdFx0ICogQHR5cGUgVGltZWxpbmVcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy50aW1lbGluZSA9IG5ldyBjcmVhdGVqcy5UaW1lbGluZShudWxsLCBsYWJlbHMsIHtwYXVzZWQ6dHJ1ZSwgcG9zaXRpb246c3RhcnRQb3NpdGlvbiwgdXNlVGlja3M6dHJ1ZX0pO1xuXHRcblx0XHQvKipcblx0XHQgKiBJZiB0cnVlLCB0aGUgTW92aWVDbGlwJ3MgcG9zaXRpb24gd2lsbCBub3QgYWR2YW5jZSB3aGVuIHRpY2tlZC5cblx0XHQgKiBAcHJvcGVydHkgcGF1c2VkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgdHJ1ZSwgYWN0aW9ucyBpbiB0aGlzIE1vdmllQ2xpcCdzIHR3ZWVucyB3aWxsIGJlIHJ1biB3aGVuIHRoZSBwbGF5aGVhZCBhZHZhbmNlcy5cblx0XHQgKiBAcHJvcGVydHkgYWN0aW9uc0VuYWJsZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuYWN0aW9uc0VuYWJsZWQgPSB0cnVlO1xuXHRcblx0XHQvKipcblx0XHQgKiBJZiB0cnVlLCB0aGUgTW92aWVDbGlwIHdpbGwgYXV0b21hdGljYWxseSBiZSByZXNldCB0byBpdHMgZmlyc3QgZnJhbWUgd2hlbmV2ZXIgdGhlIHRpbWVsaW5lIGFkZHNcblx0XHQgKiBpdCBiYWNrIG9udG8gdGhlIGRpc3BsYXkgbGlzdC4gVGhpcyBvbmx5IGFwcGxpZXMgdG8gTW92aWVDbGlwIGluc3RhbmNlcyB3aXRoIG1vZGU9SU5ERVBFTkRFTlQuXG5cdFx0ICogPGJyPjxicj5cblx0XHQgKiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhZCBhIGNoYXJhY3RlciBhbmltYXRpb24gd2l0aCBhIFwiYm9keVwiIGNoaWxkIE1vdmllQ2xpcCBpbnN0YW5jZVxuXHRcdCAqIHdpdGggZGlmZmVyZW50IGNvc3R1bWVzIG9uIGVhY2ggZnJhbWUsIHlvdSBjb3VsZCBzZXQgYm9keS5hdXRvUmVzZXQgPSBmYWxzZSwgc28gdGhhdFxuXHRcdCAqIHlvdSBjYW4gbWFudWFsbHkgY2hhbmdlIHRoZSBmcmFtZSBpdCBpcyBvbiwgd2l0aG91dCB3b3JyeWluZyB0aGF0IGl0IHdpbGwgYmUgcmVzZXRcblx0XHQgKiBhdXRvbWF0aWNhbGx5LlxuXHRcdCAqIEBwcm9wZXJ0eSBhdXRvUmVzZXRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuYXV0b1Jlc2V0ID0gdHJ1ZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBvZiBib3VuZHMgZm9yIGVhY2ggZnJhbWUgaW4gdGhlIE1vdmllQ2xpcC4gVGhpcyBpcyBtYWlubHkgaW50ZW5kZWQgZm9yIHRvb2wgb3V0cHV0LlxuXHRcdCAqIEBwcm9wZXJ0eSBmcmFtZUJvdW5kc1xuXHRcdCAqIEB0eXBlIEFycmF5XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuZnJhbWVCb3VuZHMgPSB0aGlzLmZyYW1lQm91bmRzfHxudWxsOyAvLyBUT0RPOiBEZXByZWNhdGVkLiBUaGlzIGlzIGZvciBiYWNrd2FyZHMgc3VwcG9ydCBvZiBGbGFzaENDXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQnkgZGVmYXVsdCBNb3ZpZUNsaXAgaW5zdGFuY2VzIGFkdmFuY2Ugb25lIGZyYW1lIHBlciB0aWNrLiBTcGVjaWZ5aW5nIGEgZnJhbWVyYXRlIGZvciB0aGUgTW92aWVDbGlwXG5cdFx0ICogd2lsbCBjYXVzZSBpdCB0byBhZHZhbmNlIGJhc2VkIG9uIGVsYXBzZWQgdGltZSBiZXR3ZWVuIHRpY2tzIGFzIGFwcHJvcHJpYXRlIHRvIG1haW50YWluIHRoZSB0YXJnZXRcblx0XHQgKiBmcmFtZXJhdGUuXG5cdFx0ICpcblx0XHQgKiBGb3IgZXhhbXBsZSwgaWYgYSBNb3ZpZUNsaXAgd2l0aCBhIGZyYW1lcmF0ZSBvZiAxMCBpcyBwbGFjZWQgb24gYSBTdGFnZSBiZWluZyB1cGRhdGVkIGF0IDQwZnBzLCB0aGVuIHRoZSBNb3ZpZUNsaXAgd2lsbFxuXHRcdCAqIGFkdmFuY2Ugcm91Z2hseSBvbmUgZnJhbWUgZXZlcnkgNCB0aWNrcy4gVGhpcyB3aWxsIG5vdCBiZSBleGFjdCwgYmVjYXVzZSB0aGUgdGltZSBiZXR3ZWVuIGVhY2ggdGljayB3aWxsXG5cdFx0ICogdmFyeSBzbGlnaHRseSBiZXR3ZWVuIGZyYW1lcy5cblx0XHQgKlxuXHRcdCAqIFRoaXMgZmVhdHVyZSBpcyBkZXBlbmRlbnQgb24gdGhlIHRpY2sgZXZlbnQgb2JqZWN0IChvciBhbiBvYmplY3Qgd2l0aCBhbiBhcHByb3ByaWF0ZSBcImRlbHRhXCIgcHJvcGVydHkpIGJlaW5nXG5cdFx0ICogcGFzc2VkIGludG8ge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdXBkYXRlXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBmcmFtZXJhdGVcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiovXG5cdFx0dGhpcy5mcmFtZXJhdGUgPSBudWxsO1xuXHRcdFxuXHRcdFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9zeW5jaE9mZnNldFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3N5bmNoT2Zmc2V0ID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9wcmV2UG9zXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgLTFcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3ByZXZQb3MgPSAtMTsgLy8gVE9ETzogZXZhbHVhdGUgdXNpbmcgYSAuX3Jlc2V0IEJvb2xlYW4gcHJvcCBpbnN0ZWFkIG9mIC0xLlxuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3ByZXZQb3NpdGlvblxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3ByZXZQb3NpdGlvbiA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0aW1lIHJlbWFpbmluZyBmcm9tIHRoZSBwcmV2aW91cyB0aWNrLCBvbmx5IGFwcGxpY2FibGUgd2hlbiAuZnJhbWVyYXRlIGlzIHNldC5cblx0XHQgKiBAcHJvcGVydHkgX3Rcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3QgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBMaXN0IG9mIGRpc3BsYXkgb2JqZWN0cyB0aGF0IGFyZSBhY3RpdmVseSBiZWluZyBtYW5hZ2VkIGJ5IHRoZSBNb3ZpZUNsaXAuXG5cdFx0ICogQHByb3BlcnR5IF9tYW5hZ2VkXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9tYW5hZ2VkID0ge307XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoTW92aWVDbGlwLCBjcmVhdGVqcy5Db250YWluZXIpO1xuXG5cbi8vIGNvbnN0YW50czpcblx0LyoqXG5cdCAqIFRoZSBNb3ZpZUNsaXAgd2lsbCBhZHZhbmNlIGluZGVwZW5kZW50bHkgb2YgaXRzIHBhcmVudCwgZXZlbiBpZiBpdHMgcGFyZW50IGlzIHBhdXNlZC5cblx0ICogVGhpcyBpcyB0aGUgZGVmYXVsdCBtb2RlLlxuXHQgKiBAcHJvcGVydHkgSU5ERVBFTkRFTlRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICogQGRlZmF1bHQgXCJpbmRlcGVuZGVudFwiXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdE1vdmllQ2xpcC5JTkRFUEVOREVOVCA9IFwiaW5kZXBlbmRlbnRcIjtcblxuXHQvKipcblx0ICogVGhlIE1vdmllQ2xpcCB3aWxsIG9ubHkgZGlzcGxheSBhIHNpbmdsZSBmcmFtZSAoYXMgZGV0ZXJtaW5lZCBieSB0aGUgc3RhcnRQb3NpdGlvbiBwcm9wZXJ0eSkuXG5cdCAqIEBwcm9wZXJ0eSBTSU5HTEVfRlJBTUVcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICogQGRlZmF1bHQgXCJzaW5nbGVcIlxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRNb3ZpZUNsaXAuU0lOR0xFX0ZSQU1FID0gXCJzaW5nbGVcIjtcblxuXHQvKipcblx0ICogVGhlIE1vdmllQ2xpcCB3aWxsIGJlIGFkdmFuY2VkIG9ubHkgd2hlbiBpdHMgcGFyZW50IGFkdmFuY2VzIGFuZCB3aWxsIGJlIHN5bmNoZWQgdG8gdGhlIHBvc2l0aW9uIG9mXG5cdCAqIHRoZSBwYXJlbnQgTW92aWVDbGlwLlxuXHQgKiBAcHJvcGVydHkgU1lOQ0hFRFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIFN0cmluZ1xuXHQgKiBAZGVmYXVsdCBcInN5bmNoZWRcIlxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRNb3ZpZUNsaXAuU1lOQ0hFRCA9IFwic3luY2hlZFwiO1xuXHRcblx0XG4vLyBzdGF0aWMgcHJvcGVydGllczpcblx0TW92aWVDbGlwLmluaXRlZCA9IGZhbHNlO1xuXHRcblx0XG4vLyBzdGF0aWMgbWV0aG9kczpcblx0TW92aWVDbGlwLmluaXQgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoTW92aWVDbGlwLmluaXRlZCkgeyByZXR1cm47IH1cblx0XHQvLyBwbHVnaW5zIGludHJvZHVjZSBzb21lIG92ZXJoZWFkIHRvIFR3ZWVuLCBzbyB3ZSBvbmx5IGluc3RhbGwgdGhpcyBpZiBhbiBNQyBpcyBpbnN0YW50aWF0ZWQuXG5cdFx0TW92aWVDbGlwUGx1Z2luLmluc3RhbGwoKTtcblx0XHRNb3ZpZUNsaXAuaW5pdGVkID0gdHJ1ZTtcblx0fTtcblx0XG5cdFxuLy8gZ2V0dGVyIC8gc2V0dGVyczpcblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwL2xhYmVsczpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldExhYmVsc1xuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRwLmdldExhYmVscyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnRpbWVsaW5lLmdldExhYmVscygpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwL2N1cnJlbnRMYWJlbDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldEN1cnJlbnRMYWJlbFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0cC5nZXRDdXJyZW50TGFiZWwgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl91cGRhdGVUaW1lbGluZSgpO1xuXHRcdHJldHVybiB0aGlzLnRpbWVsaW5lLmdldEN1cnJlbnRMYWJlbCgpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwL2R1cmF0aW9uOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgZ2V0RHVyYXRpb25cblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5nZXREdXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnRpbWVsaW5lLmR1cmF0aW9uO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCBsYWJlbCBhbmQgcG9zaXRpb24gKGFrYSBmcmFtZSkgcHJvcGVydGllcywgc29ydGVkIGJ5IHBvc2l0aW9uLlxuXHQgKiBTaG9ydGN1dCB0byBUd2VlbkpTOiBUaW1lbGluZS5nZXRMYWJlbHMoKTtcblx0ICogQHByb3BlcnR5IGxhYmVsc1xuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgbGFiZWwgb24gb3IgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBjdXJyZW50IGZyYW1lLiBTZWUgVHdlZW5KUzogVGltZWxpbmUuZ2V0Q3VycmVudExhYmVsKClcblx0ICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBwcm9wZXJ0eSBjdXJyZW50TGFiZWxcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkdXJhdGlvbiBvZiB0aGlzIE1vdmllQ2xpcCBpbiBzZWNvbmRzIG9yIHRpY2tzLiBJZGVudGljYWwgdG8ge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwL2R1cmF0aW9uOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGFuZCBwcm92aWRlZCBmb3IgRmxhc2ggQVBJIGNvbXBhdGliaWxpdHkuXG5cdCAqIEBwcm9wZXJ0eSB0b3RhbEZyYW1lc1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGR1cmF0aW9uIG9mIHRoaXMgTW92aWVDbGlwIGluIHNlY29uZHMgb3IgdGlja3MuXG5cdCAqIEBwcm9wZXJ0eSBkdXJhdGlvblxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcblx0XHRcdGxhYmVsczogeyBnZXQ6IHAuZ2V0TGFiZWxzIH0sXG5cdFx0XHRjdXJyZW50TGFiZWw6IHsgZ2V0OiBwLmdldEN1cnJlbnRMYWJlbCB9LFxuXHRcdFx0dG90YWxGcmFtZXM6IHsgZ2V0OiBwLmdldER1cmF0aW9uIH0sXG5cdFx0XHRkdXJhdGlvbjogeyBnZXQ6IHAuZ2V0RHVyYXRpb24gfVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlKSB7fVxuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogQ29uc3RydWN0b3IgYWxpYXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBUaGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zLlxuXHQgKiBTdWJjbGFzc2VzIHNob3VsZCBiZSB1cGRhdGVkIHRvIHVzZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kc1wifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBgY3JlYXRlanMucHJvbW90ZSgpYFxuXHQgKiovXG5cdHAuaW5pdGlhbGl6ZSA9IE1vdmllQ2xpcDsgLy8gVE9ETzogRGVwcmVjYXRlZC4gVGhpcyBpcyBmb3IgYmFja3dhcmRzIHN1cHBvcnQgb2YgRmxhc2hDQ1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzXG5cdCAqKi9cblx0cC5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcblx0XHQvLyBjaGlsZHJlbiBhcmUgcGxhY2VkIGluIGRyYXcsIHNvIHdlIGNhbid0IGRldGVybWluZSBpZiB3ZSBoYXZlIGNvbnRlbnQuXG5cdFx0cmV0dXJuICEhKHRoaXMudmlzaWJsZSAmJiB0aGlzLmFscGhhID4gMCAmJiB0aGlzLnNjYWxlWCAhPSAwICYmIHRoaXMuc2NhbGVZICE9IDApO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyB0aGUgZGlzcGxheSBvYmplY3QgaW50byB0aGUgc3BlY2lmaWVkIGNvbnRleHQgaWdub3JpbmcgaXRzIHZpc2libGUsIGFscGhhLCBzaGFkb3csIGFuZCB0cmFuc2Zvcm0uXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZHJhdyB3YXMgaGFuZGxlZCAodXNlZnVsIGZvciBvdmVycmlkaW5nIGZ1bmN0aW9uYWxpdHkpLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgZHJhd1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZUNhY2hlIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkcmF3IG9wZXJhdGlvbiBzaG91bGQgaWdub3JlIGFueSBjdXJyZW50IGNhY2hlLlxuXHQgKiBGb3IgZXhhbXBsZSwgdXNlZCBmb3IgZHJhd2luZyB0aGUgY2FjaGUgKHRvIHByZXZlbnQgaXQgZnJvbSBzaW1wbHkgZHJhd2luZyBhbiBleGlzdGluZyBjYWNoZSBiYWNrXG5cdCAqIGludG8gaXRzZWxmKS5cblx0ICoqL1xuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGlnbm9yZUNhY2hlKSB7XG5cdFx0Ly8gZHJhdyB0byBjYWNoZSBmaXJzdDpcblx0XHRpZiAodGhpcy5EaXNwbGF5T2JqZWN0X2RyYXcoY3R4LCBpZ25vcmVDYWNoZSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHR0aGlzLl91cGRhdGVUaW1lbGluZSgpO1xuXHRcdHRoaXMuQ29udGFpbmVyX2RyYXcoY3R4LCBpZ25vcmVDYWNoZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2V0cyBwYXVzZWQgdG8gZmFsc2UuXG5cdCAqIEBtZXRob2QgcGxheVxuXHQgKiovXG5cdHAucGxheSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucGF1c2VkID0gZmFsc2U7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2V0cyBwYXVzZWQgdG8gdHJ1ZS5cblx0ICogQG1ldGhvZCBzdG9wXG5cdCAqKi9cblx0cC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5wYXVzZWQgPSB0cnVlO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoaXMgbW92aWUgY2xpcCB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIG9yIGxhYmVsIGFuZCBzZXRzIHBhdXNlZCB0byBmYWxzZS5cblx0ICogQG1ldGhvZCBnb3RvQW5kUGxheVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHBvc2l0aW9uT3JMYWJlbCBUaGUgYW5pbWF0aW9uIG5hbWUgb3IgZnJhbWUgbnVtYmVyIHRvIGdvIHRvLlxuXHQgKiovXG5cdHAuZ290b0FuZFBsYXkgPSBmdW5jdGlvbihwb3NpdGlvbk9yTGFiZWwpIHtcblx0XHR0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2dvdG8ocG9zaXRpb25PckxhYmVsKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBZHZhbmNlcyB0aGlzIG1vdmllIGNsaXAgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBvciBsYWJlbCBhbmQgc2V0cyBwYXVzZWQgdG8gdHJ1ZS5cblx0ICogQG1ldGhvZCBnb3RvQW5kU3RvcFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHBvc2l0aW9uT3JMYWJlbCBUaGUgYW5pbWF0aW9uIG9yIGZyYW1lIG5hbWUgdG8gZ28gdG8uXG5cdCAqKi9cblx0cC5nb3RvQW5kU3RvcCA9IGZ1bmN0aW9uKHBvc2l0aW9uT3JMYWJlbCkge1xuXHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcblx0XHR0aGlzLl9nb3RvKHBvc2l0aW9uT3JMYWJlbCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhlIHBsYXloZWFkLiBUaGlzIG9jY3VycyBhdXRvbWF0aWNhbGx5IGVhY2ggdGljayBieSBkZWZhdWx0LlxuXHQgKiBAcGFyYW0gW3RpbWVdIHtOdW1iZXJ9IFRoZSBhbW91bnQgb2YgdGltZSBpbiBtcyB0byBhZHZhbmNlIGJ5LiBPbmx5IGFwcGxpY2FibGUgaWYgZnJhbWVyYXRlIGlzIHNldC5cblx0ICogQG1ldGhvZCBhZHZhbmNlXG5cdCovXG5cdHAuYWR2YW5jZSA9IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHQvLyBUT0RPOiBzaG91bGQgd2Ugd29ycnkgYXQgYWxsIGFib3V0IGNsaXBzIHdobyBjaGFuZ2UgdGhlaXIgb3duIG1vZGVzIHZpYSBmcmFtZSBzY3JpcHRzP1xuXHRcdHZhciBpbmRlcGVuZGVudCA9IE1vdmllQ2xpcC5JTkRFUEVOREVOVDtcblx0XHRpZiAodGhpcy5tb2RlICE9IGluZGVwZW5kZW50KSB7IHJldHVybjsgfVxuXHRcdFxuXHRcdHZhciBvPXRoaXMsIGZwcyA9IG8uZnJhbWVyYXRlO1xuXHRcdHdoaWxlICgobyA9IG8ucGFyZW50KSAmJiBmcHMgPT0gbnVsbCkge1xuXHRcdFx0aWYgKG8ubW9kZSA9PSBpbmRlcGVuZGVudCkgeyBmcHMgPSBvLl9mcmFtZXJhdGU7IH1cblx0XHR9XG5cdFx0dGhpcy5fZnJhbWVyYXRlID0gZnBzO1xuXHRcdFxuXHRcdHZhciB0ID0gKGZwcyAhPSBudWxsICYmIGZwcyAhPSAtMSAmJiB0aW1lICE9IG51bGwpID8gdGltZS8oMTAwMC9mcHMpICsgdGhpcy5fdCA6IDE7XG5cdFx0dmFyIGZyYW1lcyA9IHR8MDtcblx0XHR0aGlzLl90ID0gdC1mcmFtZXM7IC8vIGxlZnRvdmVyIHRpbWVcblx0XHRcblx0XHR3aGlsZSAoIXRoaXMucGF1c2VkICYmIGZyYW1lcy0tKSB7XG5cdFx0XHR0aGlzLl9wcmV2UG9zaXRpb24gPSAodGhpcy5fcHJldlBvcyA8IDApID8gMCA6IHRoaXMuX3ByZXZQb3NpdGlvbisxO1xuXHRcdFx0dGhpcy5fdXBkYXRlVGltZWxpbmUoKTtcblx0XHR9XG5cdH07XG5cdFxuXHQvKipcblx0ICogTW92aWVDbGlwIGluc3RhbmNlcyBjYW5ub3QgYmUgY2xvbmVkLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciB0aGlzPyBOZWVkIHRvIGNsb25lIHRoZSBUaW1lbGluZSAmIHJldGFyZ2V0IHR3ZWVucyAtIHByZXR0eSBjb21wbGV4LlxuXHRcdHRocm93KFwiTW92aWVDbGlwIGNhbm5vdCBiZSBjbG9uZWQuXCIpXG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW01vdmllQ2xpcCAobmFtZT1cIisgIHRoaXMubmFtZSArXCIpXVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX3RpY2tcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2dE9iaiBBbiBldmVudCBvYmplY3QgdGhhdCB3aWxsIGJlIGRpc3BhdGNoZWQgdG8gYWxsIHRpY2sgbGlzdGVuZXJzLiBUaGlzIG9iamVjdCBpcyByZXVzZWQgYmV0d2VlbiBkaXNwYXRjaGVycyB0byByZWR1Y2UgY29uc3RydWN0aW9uICYgR0MgY29zdHMuXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fdGljayA9IGZ1bmN0aW9uKGV2dE9iaikge1xuXHRcdHRoaXMuYWR2YW5jZShldnRPYmomJmV2dE9iai5kZWx0YSk7XG5cdFx0dGhpcy5Db250YWluZXJfX3RpY2soZXZ0T2JqKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nb3RvXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gcG9zaXRpb25PckxhYmVsIFRoZSBhbmltYXRpb24gbmFtZSBvciBmcmFtZSBudW1iZXIgdG8gZ28gdG8uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9nb3RvID0gZnVuY3Rpb24ocG9zaXRpb25PckxhYmVsKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMudGltZWxpbmUucmVzb2x2ZShwb3NpdGlvbk9yTGFiZWwpO1xuXHRcdGlmIChwb3MgPT0gbnVsbCkgeyByZXR1cm47IH1cblx0XHQvLyBwcmV2ZW50IF91cGRhdGVUaW1lbGluZSBmcm9tIG92ZXJ3cml0aW5nIHRoZSBuZXcgcG9zaXRpb24gYmVjYXVzZSBvZiBhIHJlc2V0OlxuXHRcdGlmICh0aGlzLl9wcmV2UG9zID09IC0xKSB7IHRoaXMuX3ByZXZQb3MgPSBOYU47IH1cblx0XHR0aGlzLl9wcmV2UG9zaXRpb24gPSBwb3M7XG5cdFx0dGhpcy5fdCA9IDA7XG5cdFx0dGhpcy5fdXBkYXRlVGltZWxpbmUoKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9yZXNldFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiovXG5cdHAuX3Jlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fcHJldlBvcyA9IC0xO1xuXHRcdHRoaXMuX3QgPSB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XG5cdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF91cGRhdGVUaW1lbGluZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fdXBkYXRlVGltZWxpbmUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGwgPSB0aGlzLnRpbWVsaW5lO1xuXHRcdHZhciBzeW5jaGVkID0gdGhpcy5tb2RlICE9IE1vdmllQ2xpcC5JTkRFUEVOREVOVDtcblx0XHR0bC5sb29wID0gKHRoaXMubG9vcD09bnVsbCkgPyB0cnVlIDogdGhpcy5sb29wO1xuXHRcdFxuXHRcdHZhciBwb3MgPSBzeW5jaGVkID8gdGhpcy5zdGFydFBvc2l0aW9uICsgKHRoaXMubW9kZT09TW92aWVDbGlwLlNJTkdMRV9GUkFNRT8wOnRoaXMuX3N5bmNoT2Zmc2V0KSA6ICh0aGlzLl9wcmV2UG9zIDwgMCA/IDAgOiB0aGlzLl9wcmV2UG9zaXRpb24pO1xuXHRcdHZhciBtb2RlID0gc3luY2hlZCB8fCAhdGhpcy5hY3Rpb25zRW5hYmxlZCA/IGNyZWF0ZWpzLlR3ZWVuLk5PTkUgOiBudWxsO1xuXHRcdFxuXHRcdC8vIHByZS1hc3NpZ24gY3VycmVudEZyYW1lIHNvIGl0IGlzIGF2YWlsYWJsZSB0byBmcmFtZSBzY3JpcHRzOlxuXHRcdHRoaXMuY3VycmVudEZyYW1lID0gdGwuX2NhbGNQb3NpdGlvbihwb3MpO1xuXHRcdFxuXHRcdC8vIHVwZGF0ZSB0aW1lbGluZSBwb3NpdGlvbiwgaWdub3JpbmcgYWN0aW9ucyBpZiB0aGlzIGlzIGEgZ3JhcGhpYy5cblx0XHR0bC5zZXRQb3NpdGlvbihwb3MsIG1vZGUpO1xuXG5cdFx0dGhpcy5fcHJldlBvc2l0aW9uID0gdGwuX3ByZXZQb3NpdGlvbjtcblx0XHRpZiAodGhpcy5fcHJldlBvcyA9PSB0bC5fcHJldlBvcykgeyByZXR1cm47IH1cblx0XHR0aGlzLmN1cnJlbnRGcmFtZSA9IHRoaXMuX3ByZXZQb3MgPSB0bC5fcHJldlBvcztcblxuXHRcdGZvciAodmFyIG4gaW4gdGhpcy5fbWFuYWdlZCkgeyB0aGlzLl9tYW5hZ2VkW25dID0gMTsgfVxuXG5cdFx0dmFyIHR3ZWVucyA9IHRsLl90d2VlbnM7XG5cdFx0Zm9yICh2YXIgaT0wLCBsPXR3ZWVucy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0d2VlbnNbaV07XG5cdFx0XHR2YXIgdGFyZ2V0ID0gdHdlZW4uX3RhcmdldDtcblx0XHRcdGlmICh0YXJnZXQgPT0gdGhpcyB8fCB0d2Vlbi5wYXNzaXZlKSB7IGNvbnRpbnVlOyB9IC8vIFRPRE86IHRoaXMgYXNzdW1lcyBhY3Rpb25zIHR3ZWVuIGhhcyB0aGlzIGFzIHRoZSB0YXJnZXQuIFZhbGlkP1xuXHRcdFx0dmFyIG9mZnNldCA9IHR3ZWVuLl9zdGVwUG9zaXRpb247XG5cblx0XHRcdGlmICh0YXJnZXQgaW5zdGFuY2VvZiBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0KSB7XG5cdFx0XHRcdC8vIG1vdGlvbiB0d2Vlbi5cblx0XHRcdFx0dGhpcy5fYWRkTWFuYWdlZENoaWxkKHRhcmdldCwgb2Zmc2V0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHN0YXRlIHR3ZWVuLlxuXHRcdFx0XHR0aGlzLl9zZXRTdGF0ZSh0YXJnZXQuc3RhdGUsIG9mZnNldCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGtpZHMgPSB0aGlzLmNoaWxkcmVuO1xuXHRcdGZvciAoaT1raWRzLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcblx0XHRcdHZhciBpZCA9IGtpZHNbaV0uaWQ7XG5cdFx0XHRpZiAodGhpcy5fbWFuYWdlZFtpZF0gPT0gMSkge1xuXHRcdFx0XHR0aGlzLnJlbW92ZUNoaWxkQXQoaSk7XG5cdFx0XHRcdGRlbGV0ZSh0aGlzLl9tYW5hZ2VkW2lkXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9zZXRTdGF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBzdGF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9zZXRTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCBvZmZzZXQpIHtcblx0XHRpZiAoIXN0YXRlKSB7IHJldHVybjsgfVxuXHRcdGZvciAodmFyIGk9c3RhdGUubGVuZ3RoLTE7aT49MDtpLS0pIHtcblx0XHRcdHZhciBvID0gc3RhdGVbaV07XG5cdFx0XHR2YXIgdGFyZ2V0ID0gby50O1xuXHRcdFx0dmFyIHByb3BzID0gby5wO1xuXHRcdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykgeyB0YXJnZXRbbl0gPSBwcm9wc1tuXTsgfVxuXHRcdFx0dGhpcy5fYWRkTWFuYWdlZENoaWxkKHRhcmdldCwgb2Zmc2V0KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBjaGlsZCB0byB0aGUgdGltZWxpbmUsIGFuZCBzZXRzIGl0IHVwIGFzIGEgbWFuYWdlZCBjaGlsZC5cblx0ICogQG1ldGhvZCBfYWRkTWFuYWdlZENoaWxkXG5cdCAqIEBwYXJhbSB7TW92aWVDbGlwfSBjaGlsZCBUaGUgY2hpbGQgTW92aWVDbGlwIHRvIG1hbmFnZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG5cdCAqIEBwcml2YXRlXG5cdCAqKi9cblx0cC5fYWRkTWFuYWdlZENoaWxkID0gZnVuY3Rpb24oY2hpbGQsIG9mZnNldCkge1xuXHRcdGlmIChjaGlsZC5fb2ZmKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuYWRkQ2hpbGRBdChjaGlsZCwwKTtcblxuXHRcdGlmIChjaGlsZCBpbnN0YW5jZW9mIE1vdmllQ2xpcCkge1xuXHRcdFx0Y2hpbGQuX3N5bmNoT2Zmc2V0ID0gb2Zmc2V0O1xuXHRcdFx0Ly8gVE9ETzogdGhpcyBkb2VzIG5vdCBwcmVjaXNlbHkgbWF0Y2ggRmxhc2guIEZsYXNoIGxvc2VzIHRyYWNrIG9mIHRoZSBjbGlwIGlmIGl0IGlzIHJlbmFtZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZSB0aW1lbGluZSwgd2hpY2ggY2F1c2VzIGl0IHRvIHJlc2V0LlxuXHRcdFx0aWYgKGNoaWxkLm1vZGUgPT0gTW92aWVDbGlwLklOREVQRU5ERU5UICYmIGNoaWxkLmF1dG9SZXNldCAmJiAhdGhpcy5fbWFuYWdlZFtjaGlsZC5pZF0pIHsgY2hpbGQuX3Jlc2V0KCk7IH1cblx0XHR9XG5cdFx0dGhpcy5fbWFuYWdlZFtjaGlsZC5pZF0gPSAyO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldEJvdW5kc1xuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXhcblx0ICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVUcmFuc2Zvcm1cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ2V0Qm91bmRzID0gZnVuY3Rpb24obWF0cml4LCBpZ25vcmVUcmFuc2Zvcm0pIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5EaXNwbGF5T2JqZWN0X2dldEJvdW5kcygpO1xuXHRcdGlmICghYm91bmRzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVUaW1lbGluZSgpO1xuXHRcdFx0aWYgKHRoaXMuZnJhbWVCb3VuZHMpIHsgYm91bmRzID0gdGhpcy5fcmVjdGFuZ2xlLmNvcHkodGhpcy5mcmFtZUJvdW5kc1t0aGlzLmN1cnJlbnRGcmFtZV0pOyB9XG5cdFx0fVxuXHRcdGlmIChib3VuZHMpIHsgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybUJvdW5kcyhib3VuZHMsIG1hdHJpeCwgaWdub3JlVHJhbnNmb3JtKTsgfVxuXHRcdHJldHVybiB0aGlzLkNvbnRhaW5lcl9fZ2V0Qm91bmRzKG1hdHJpeCwgaWdub3JlVHJhbnNmb3JtKTtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLk1vdmllQ2xpcCA9IGNyZWF0ZWpzLnByb21vdGUoTW92aWVDbGlwLCBcIkNvbnRhaW5lclwiKTtcblxuXG5cbi8vIE1vdmllQ2xpcFBsdWdpbiBmb3IgVHdlZW5KUzpcblx0LyoqXG5cdCAqIFRoaXMgcGx1Z2luIHdvcmtzIHdpdGggPGEgaHJlZj1cImh0dHA6Ly90d2VlbmpzLmNvbVwiIHRhcmdldD1cIl9ibGFua1wiPlR3ZWVuSlM8L2E+IHRvIHByZXZlbnQgdGhlIHN0YXJ0UG9zaXRpb25cblx0ICogcHJvcGVydHkgZnJvbSB0d2VlbmluZy5cblx0ICogQHByaXZhdGVcblx0ICogQGNsYXNzIE1vdmllQ2xpcFBsdWdpblxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBNb3ZpZUNsaXBQbHVnaW4oKSB7XG5cdFx0dGhyb3coXCJNb3ZpZUNsaXBQbHVnaW4gY2Fubm90IGJlIGluc3RhbnRpYXRlZC5cIilcblx0fVxuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgcHJpb3JpdHlcblx0ICogQHByaXZhdGVcblx0ICoqL1xuXHRNb3ZpZUNsaXBQbHVnaW4ucHJpb3JpdHkgPSAxMDA7IC8vIHZlcnkgaGlnaCBwcmlvcml0eSwgc2hvdWxkIHJ1biBmaXJzdFxuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGluc3RhbGxcblx0ICogQHByaXZhdGVcblx0ICoqL1xuXHRNb3ZpZUNsaXBQbHVnaW4uaW5zdGFsbCA9IGZ1bmN0aW9uKCkge1xuXHRcdGNyZWF0ZWpzLlR3ZWVuLmluc3RhbGxQbHVnaW4oTW92aWVDbGlwUGx1Z2luLCBbXCJzdGFydFBvc2l0aW9uXCJdKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGluaXRcblx0ICogQHBhcmFtIHtUd2Vlbn0gdHdlZW5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3Bcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJvb2xlYW59IHZhbHVlXG5cdCAqIEBwcml2YXRlXG5cdCAqKi9cblx0TW92aWVDbGlwUGx1Z2luLmluaXQgPSBmdW5jdGlvbih0d2VlbiwgcHJvcCwgdmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBzdGVwXG5cdCAqIEBwcml2YXRlXG5cdCAqKi9cblx0TW92aWVDbGlwUGx1Z2luLnN0ZXAgPSBmdW5jdGlvbigpIHtcblx0XHQvLyB1bnVzZWQuXG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgdHdlZW5cblx0ICogQHBhcmFtIHtUd2Vlbn0gdHdlZW5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3Bcblx0ICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXIgfCBCb29sZWFufSB2YWx1ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBzdGFydFZhbHVlc1xuXHQgKiBAcGFyYW0ge0FycmF5fSBlbmRWYWx1ZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhdGlvXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB3YWl0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlbmRcblx0ICogQHJldHVybiB7Kn1cblx0ICovXG5cdE1vdmllQ2xpcFBsdWdpbi50d2VlbiA9IGZ1bmN0aW9uKHR3ZWVuLCBwcm9wLCB2YWx1ZSwgc3RhcnRWYWx1ZXMsIGVuZFZhbHVlcywgcmF0aW8sIHdhaXQsIGVuZCkge1xuXHRcdGlmICghKHR3ZWVuLnRhcmdldCBpbnN0YW5jZW9mIE1vdmllQ2xpcCkpIHsgcmV0dXJuIHZhbHVlOyB9XG5cdFx0cmV0dXJuIChyYXRpbyA9PSAxID8gZW5kVmFsdWVzW3Byb3BdIDogc3RhcnRWYWx1ZXNbcHJvcF0pO1xuXHR9O1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU3ByaXRlU2hlZXRVdGlscy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cdFxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBUaGUgU3ByaXRlU2hlZXRVdGlscyBjbGFzcyBpcyBhIGNvbGxlY3Rpb24gb2Ygc3RhdGljIG1ldGhvZHMgZm9yIHdvcmtpbmcgd2l0aCB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fXMuXG5cdCAqIEEgc3ByaXRlIHNoZWV0IGlzIGEgc2VyaWVzIG9mIGltYWdlcyAodXN1YWxseSBhbmltYXRpb24gZnJhbWVzKSBjb21iaW5lZCBpbnRvIGEgc2luZ2xlIGltYWdlIG9uIGEgcmVndWxhciBncmlkLiBGb3Jcblx0ICogZXhhbXBsZSwgYW4gYW5pbWF0aW9uIGNvbnNpc3Rpbmcgb2YgOCAxMDB4MTAwIGltYWdlcyBjb3VsZCBiZSBjb21iaW5lZCBpbnRvIGEgNDAweDIwMCBzcHJpdGUgc2hlZXQgKDQgZnJhbWVzIGFjcm9zc1xuXHQgKiBieSAyIGhpZ2gpLiBUaGUgU3ByaXRlU2hlZXRVdGlscyBjbGFzcyB1c2VzIGEgc3RhdGljIGludGVyZmFjZSBhbmQgc2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQuXG5cdCAqIEBjbGFzcyBTcHJpdGVTaGVldFV0aWxzXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRmdW5jdGlvbiBTcHJpdGVTaGVldFV0aWxzKCkge1xuXHRcdHRocm93IFwiU3ByaXRlU2hlZXRVdGlscyBjYW5ub3QgYmUgaW5zdGFudGlhdGVkXCI7XG5cdH1cblxuXG4vLyBwcml2YXRlIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQHByb3BlcnR5IF93b3JraW5nQ2FudmFzXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUgSFRNTENhbnZhc0VsZW1lbnQgfCBPYmplY3Rcblx0ICogQHByb3RlY3RlZFxuXHQqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IF93b3JraW5nQ29udGV4dFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFxuXHQgKiBAcHJvdGVjdGVkXG5cdCovXG5cdHZhciBjYW52YXMgPSAoY3JlYXRlanMuY3JlYXRlQ2FudmFzP2NyZWF0ZWpzLmNyZWF0ZUNhbnZhcygpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikpO1xuXHRpZiAoY2FudmFzLmdldENvbnRleHQpIHtcblx0XHRTcHJpdGVTaGVldFV0aWxzLl93b3JraW5nQ2FudmFzID0gY2FudmFzO1xuXHRcdFNwcml0ZVNoZWV0VXRpbHMuX3dvcmtpbmdDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHRjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMTtcblx0fVxuXG5cbi8vIHB1YmxpYyBzdGF0aWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIDxiPlRoaXMgaXMgYW4gZXhwZXJpbWVudGFsIG1ldGhvZCwgYW5kIG1heSBiZSBidWdneS4gUGxlYXNlIHJlcG9ydCBpc3N1ZXMuPC9iPjxici8+PGJyLz5cblx0ICogRXh0ZW5kcyB0aGUgZXhpc3Rpbmcgc3ByaXRlIHNoZWV0IGJ5IGZsaXBwaW5nIHRoZSBvcmlnaW5hbCBmcmFtZXMgaG9yaXpvbnRhbGx5LCB2ZXJ0aWNhbGx5LCBvciBib3RoLFxuXHQgKiBhbmQgYWRkaW5nIGFwcHJvcHJpYXRlIGFuaW1hdGlvbiAmIGZyYW1lIGRhdGEuIFRoZSBmbGlwcGVkIGFuaW1hdGlvbnMgd2lsbCBoYXZlIGEgc3VmZml4IGFkZGVkIHRvIHRoZWlyIG5hbWVzXG5cdCAqIChfaCwgX3YsIF9odiBhcyBhcHByb3ByaWF0ZSkuIE1ha2Ugc3VyZSB0aGUgc3ByaXRlIHNoZWV0IGltYWdlcyBhcmUgZnVsbHkgbG9hZGVkIGJlZm9yZSB1c2luZyB0aGlzIG1ldGhvZC5cblx0ICogPGJyLz48YnIvPlxuXHQgKiBGb3IgZXhhbXBsZTo8YnIvPlxuXHQgKiBTcHJpdGVTaGVldFV0aWxzLmFkZEZsaXBwZWRGcmFtZXMobXlTcHJpdGVTaGVldCwgdHJ1ZSwgdHJ1ZSk7XG5cdCAqIFRoZSBhYm92ZSB3b3VsZCBhZGQgZnJhbWVzIHRoYXQgYXJlIGZsaXBwZWQgaG9yaXpvbnRhbGx5IEFORCBmcmFtZXMgdGhhdCBhcmUgZmxpcHBlZCB2ZXJ0aWNhbGx5LlxuXHQgKiA8YnIvPjxici8+XG5cdCAqIE5vdGUgdGhhdCB5b3UgY2FuIGFsc28gZmxpcCBhbnkgZGlzcGxheSBvYmplY3QgYnkgc2V0dGluZyBpdHMgc2NhbGVYIG9yIHNjYWxlWSB0byBhIG5lZ2F0aXZlIHZhbHVlLiBPbiBzb21lXG5cdCAqIGJyb3dzZXJzIChlc3BlY2lhbGx5IHRob3NlIHdpdGhvdXQgaGFyZHdhcmUgYWNjZWxlcmF0ZWQgY2FudmFzKSB0aGlzIGNhbiByZXN1bHQgaW4gc2xpZ2h0bHkgZGVncmFkZWQgcGVyZm9ybWFuY2UsXG5cdCAqIHdoaWNoIGlzIHdoeSBhZGRGbGlwcGVkRnJhbWVzIGlzIGF2YWlsYWJsZS5cblx0ICogQG1ldGhvZCBhZGRGbGlwcGVkRnJhbWVzXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtTcHJpdGVTaGVldH0gc3ByaXRlU2hlZXRcblx0ICogQHBhcmFtIHtCb29sZWFufSBob3Jpem9udGFsIElmIHRydWUsIGhvcml6b250YWxseSBmbGlwcGVkIGZyYW1lcyB3aWxsIGJlIGFkZGVkLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZlcnRpY2FsIElmIHRydWUsIHZlcnRpY2FsbHkgZmxpcHBlZCBmcmFtZXMgd2lsbCBiZSBhZGRlZC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBib3RoIElmIHRydWUsIGZyYW1lcyB0aGF0IGFyZSBmbGlwcGVkIGJvdGggaG9yaXpvbnRhbGx5IGFuZCB2ZXJ0aWNhbGx5IHdpbGwgYmUgYWRkZWQuXG5cdCAqIEBkZXByZWNhdGVkIE1vZGVybiBicm93c2VycyBwZXJmb3JtIGJldHRlciB3aGVuIGZsaXBwaW5nIHZpYSBhIHRyYW5zZm9ybSAoZXguIHNjYWxlWD0tMSkgcmVuZGVyaW5nIHRoaXMgb2Jzb2xldGUuXG5cdCAqKi9cblx0U3ByaXRlU2hlZXRVdGlscy5hZGRGbGlwcGVkRnJhbWVzID0gZnVuY3Rpb24oc3ByaXRlU2hlZXQsIGhvcml6b250YWwsIHZlcnRpY2FsLCBib3RoKSB7XG5cdFx0aWYgKCFob3Jpem9udGFsICYmICF2ZXJ0aWNhbCAmJiAhYm90aCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBjb3VudCA9IDA7XG5cdFx0aWYgKGhvcml6b250YWwpIHsgU3ByaXRlU2hlZXRVdGlscy5fZmxpcChzcHJpdGVTaGVldCwrK2NvdW50LHRydWUsZmFsc2UpOyB9XG5cdFx0aWYgKHZlcnRpY2FsKSB7IFNwcml0ZVNoZWV0VXRpbHMuX2ZsaXAoc3ByaXRlU2hlZXQsKytjb3VudCxmYWxzZSx0cnVlKTsgfVxuXHRcdGlmIChib3RoKSB7IFNwcml0ZVNoZWV0VXRpbHMuX2ZsaXAoc3ByaXRlU2hlZXQsKytjb3VudCx0cnVlLHRydWUpOyB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzaW5nbGUgZnJhbWUgb2YgdGhlIHNwZWNpZmllZCBzcHJpdGUgc2hlZXQgYXMgYSBuZXcgUE5HIGltYWdlLiBBbiBleGFtcGxlIG9mIHdoZW4gdGhpcyBtYXkgYmUgdXNlZnVsIGlzXG5cdCAqIHRvIHVzZSBhIHNwcml0ZXNoZWV0IGZyYW1lIGFzIHRoZSBzb3VyY2UgZm9yIGEgYml0bWFwIGZpbGwuXG5cdCAqXG5cdCAqIDxzdHJvbmc+V0FSTklORzo8L3N0cm9uZz4gSW4gYWxtb3N0IGFsbCBjYXNlcyBpdCBpcyBiZXR0ZXIgdG8gZGlzcGxheSBhIHNpbmdsZSBmcmFtZSB1c2luZyBhIHt7I2Nyb3NzTGluayBcIlNwcml0ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aXRoIGEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRTdG9wXCJ9fXt7L2Nyb3NzTGlua319IGNhbGwgdGhhbiBpdCBpcyB0byBzbGljZSBvdXQgYSBmcmFtZSB1c2luZyB0aGlzXG5cdCAqIG1ldGhvZCBhbmQgZGlzcGxheSBpdCB3aXRoIGEgQml0bWFwIGluc3RhbmNlLiBZb3UgY2FuIGFsc28gY3JvcCBhbiBpbWFnZSB1c2luZyB0aGUge3sjY3Jvc3NMaW5rIFwiQml0bWFwL3NvdXJjZVJlY3RcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogcHJvcGVydHkgb2Yge3sjY3Jvc3NMaW5rIFwiQml0bWFwXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiBUaGUgZXh0cmFjdEZyYW1lIG1ldGhvZCBtYXkgY2F1c2UgY3Jvc3MtZG9tYWluIHdhcm5pbmdzIHNpbmNlIGl0IGFjY2Vzc2VzIHBpeGVscyBkaXJlY3RseSBvbiB0aGUgY2FudmFzLlxuXHQgKiBAbWV0aG9kIGV4dHJhY3RGcmFtZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IHNwcml0ZVNoZWV0IFRoZSBTcHJpdGVTaGVldCBpbnN0YW5jZSB0byBleHRyYWN0IGEgZnJhbWUgZnJvbS5cblx0ICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBmcmFtZU9yQW5pbWF0aW9uIFRoZSBmcmFtZSBudW1iZXIgb3IgYW5pbWF0aW9uIG5hbWUgdG8gZXh0cmFjdC4gSWYgYW4gYW5pbWF0aW9uXG5cdCAqIG5hbWUgaXMgc3BlY2lmaWVkLCBvbmx5IHRoZSBmaXJzdCBmcmFtZSBvZiB0aGUgYW5pbWF0aW9uIHdpbGwgYmUgZXh0cmFjdGVkLlxuXHQgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBhIHNpbmdsZSBmcmFtZSBvZiB0aGUgc3BlY2lmaWVkIHNwcml0ZSBzaGVldCBhcyBhIG5ldyBQTkcgaW1hZ2UuXG5cdCovXG5cdFNwcml0ZVNoZWV0VXRpbHMuZXh0cmFjdEZyYW1lID0gZnVuY3Rpb24oc3ByaXRlU2hlZXQsIGZyYW1lT3JBbmltYXRpb24pIHtcblx0XHRpZiAoaXNOYU4oZnJhbWVPckFuaW1hdGlvbikpIHtcblx0XHRcdGZyYW1lT3JBbmltYXRpb24gPSBzcHJpdGVTaGVldC5nZXRBbmltYXRpb24oZnJhbWVPckFuaW1hdGlvbikuZnJhbWVzWzBdO1xuXHRcdH1cblx0XHR2YXIgZGF0YSA9IHNwcml0ZVNoZWV0LmdldEZyYW1lKGZyYW1lT3JBbmltYXRpb24pO1xuXHRcdGlmICghZGF0YSkgeyByZXR1cm4gbnVsbDsgfVxuXHRcdHZhciByID0gZGF0YS5yZWN0O1xuXHRcdHZhciBjYW52YXMgPSBTcHJpdGVTaGVldFV0aWxzLl93b3JraW5nQ2FudmFzO1xuXHRcdGNhbnZhcy53aWR0aCA9IHIud2lkdGg7XG5cdFx0Y2FudmFzLmhlaWdodCA9IHIuaGVpZ2h0O1xuXHRcdFNwcml0ZVNoZWV0VXRpbHMuX3dvcmtpbmdDb250ZXh0LmRyYXdJbWFnZShkYXRhLmltYWdlLCByLngsIHIueSwgci53aWR0aCwgci5oZWlnaHQsIDAsIDAsIHIud2lkdGgsIHIuaGVpZ2h0KTtcblx0XHR2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcblx0XHRpbWcuc3JjID0gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcblx0XHRyZXR1cm4gaW1nO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBNZXJnZXMgdGhlIHJnYiBjaGFubmVscyBvZiBvbmUgaW1hZ2Ugd2l0aCB0aGUgYWxwaGEgY2hhbm5lbCBvZiBhbm90aGVyLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGNvbWJpbmUgYSBjb21wcmVzc2VkXG5cdCAqIEpQRUcgaW1hZ2UgY29udGFpbmluZyBjb2xvciBkYXRhIHdpdGggYSBQTkczMiBtb25vY2hyb21hdGljIGltYWdlIGNvbnRhaW5pbmcgYWxwaGEgZGF0YS4gV2l0aCBjZXJ0YWluIHR5cGVzIG9mXG5cdCAqIGltYWdlcyAodGhvc2Ugd2l0aCBkZXRhaWwgdGhhdCBsZW5kIGl0c2VsZiB0byBKUEVHIGNvbXByZXNzaW9uKSB0aGlzIGNhbiBwcm92aWRlIHNpZ25pZmljYW50IGZpbGUgc2l6ZSBzYXZpbmdzXG5cdCAqIHZlcnN1cyBhIHNpbmdsZSBSR0JBIFBORzMyLiBUaGlzIG1ldGhvZCBpcyB2ZXJ5IGZhc3QgKGdlbmVyYWxseSBvbiB0aGUgb3JkZXIgb2YgMS0yIG1zIHRvIHJ1bikuXG5cdCAqIEBtZXRob2QgbWVyZ2VBbHBoYVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gcmJnSW1hZ2UgVGhlIGltYWdlIChvciBjYW52YXMpIGNvbnRhaW5pbmcgdGhlIFJHQiBjaGFubmVscyB0byB1c2UuXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gYWxwaGFJbWFnZSBUaGUgaW1hZ2UgKG9yIGNhbnZhcykgY29udGFpbmluZyB0aGUgYWxwaGEgY2hhbm5lbCB0byB1c2UuXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyBPcHRpb25hbC4gSWYgc3BlY2lmaWVkLCB0aGlzIGNhbnZhcyB3aWxsIGJlIHVzZWQgYW5kIHJldHVybmVkLiBJZiBub3QsIGEgbmV3IGNhbnZhcyB3aWxsIGJlIGNyZWF0ZWQuXG5cdCAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBBIGNhbnZhcyB3aXRoIHRoZSBjb21iaW5lZCBpbWFnZSBkYXRhLiBUaGlzIGNhbiBiZSB1c2VkIGFzIGEgc291cmNlIGZvciBCaXRtYXAgb3IgU3ByaXRlU2hlZXQuXG5cdCAqIEBkZXByZWNhdGVkIFRvb2xzIHN1Y2ggYXMgSW1hZ2VBbHBoYSBnZW5lcmFsbHkgcHJvdmlkZSBiZXR0ZXIgcmVzdWx0cy4gVGhpcyB3aWxsIGJlIG1vdmVkIHRvIHNhbmRib3ggaW4gdGhlIGZ1dHVyZS5cblx0Ki9cblx0U3ByaXRlU2hlZXRVdGlscy5tZXJnZUFscGhhID0gZnVuY3Rpb24ocmdiSW1hZ2UsIGFscGhhSW1hZ2UsIGNhbnZhcykge1xuXHRcdGlmICghY2FudmFzKSB7IGNhbnZhcyA9IGNyZWF0ZWpzLmNyZWF0ZUNhbnZhcz9jcmVhdGVqcy5jcmVhdGVDYW52YXMoKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpOyB9XG5cdFx0Y2FudmFzLndpZHRoID0gTWF0aC5tYXgoYWxwaGFJbWFnZS53aWR0aCwgcmdiSW1hZ2Uud2lkdGgpO1xuXHRcdGNhbnZhcy5oZWlnaHQgPSBNYXRoLm1heChhbHBoYUltYWdlLmhlaWdodCwgcmdiSW1hZ2UuaGVpZ2h0KTtcblx0XHR2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdGN0eC5kcmF3SW1hZ2UocmdiSW1hZ2UsMCwwKTtcblx0XHRjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1pblwiO1xuXHRcdGN0eC5kcmF3SW1hZ2UoYWxwaGFJbWFnZSwwLDApO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0cmV0dXJuIGNhbnZhcztcblx0fTtcblxuXG4vLyBwcml2YXRlIHN0YXRpYyBtZXRob2RzOlxuXHRTcHJpdGVTaGVldFV0aWxzLl9mbGlwID0gZnVuY3Rpb24oc3ByaXRlU2hlZXQsIGNvdW50LCBoLCB2KSB7XG5cdFx0dmFyIGltZ3MgPSBzcHJpdGVTaGVldC5faW1hZ2VzO1xuXHRcdHZhciBjYW52YXMgPSBTcHJpdGVTaGVldFV0aWxzLl93b3JraW5nQ2FudmFzO1xuXHRcdHZhciBjdHggPSBTcHJpdGVTaGVldFV0aWxzLl93b3JraW5nQ29udGV4dDtcblx0XHR2YXIgaWwgPSBpbWdzLmxlbmd0aC9jb3VudDtcblx0XHRmb3IgKHZhciBpPTA7aTxpbDtpKyspIHtcblx0XHRcdHZhciBzcmMgPSBpbWdzW2ldO1xuXHRcdFx0c3JjLl9fdG1wID0gaTsgLy8gYSBiaXQgaGFja3ksIGJ1dCBmYXN0ZXIgdGhhbiBkb2luZyBpbmRleE9mIGJlbG93LlxuXHRcdFx0Y3R4LnNldFRyYW5zZm9ybSgxLDAsMCwxLDAsMCk7XG5cdFx0XHRjdHguY2xlYXJSZWN0KDAsMCxjYW52YXMud2lkdGgrMSxjYW52YXMuaGVpZ2h0KzEpO1xuXHRcdFx0Y2FudmFzLndpZHRoID0gc3JjLndpZHRoO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IHNyYy5oZWlnaHQ7XG5cdFx0XHRjdHguc2V0VHJhbnNmb3JtKGg/LTE6MSwgMCwgMCwgdj8tMToxLCBoP3NyYy53aWR0aDowLCB2P3NyYy5oZWlnaHQ6MCk7XG5cdFx0XHRjdHguZHJhd0ltYWdlKHNyYywwLDApO1xuXHRcdFx0dmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG5cdFx0XHRpbWcuc3JjID0gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcblx0XHRcdC8vIHdvcmsgYXJvdW5kIGEgc3RyYW5nZSBidWcgaW4gU2FmYXJpOlxuXHRcdFx0aW1nLndpZHRoID0gc3JjLndpZHRoO1xuXHRcdFx0aW1nLmhlaWdodCA9IHNyYy5oZWlnaHQ7XG5cdFx0XHRpbWdzLnB1c2goaW1nKTtcblx0XHR9XG5cblx0XHR2YXIgZnJhbWVzID0gc3ByaXRlU2hlZXQuX2ZyYW1lcztcblx0XHR2YXIgZmwgPSBmcmFtZXMubGVuZ3RoL2NvdW50O1xuXHRcdGZvciAoaT0wO2k8Zmw7aSsrKSB7XG5cdFx0XHRzcmMgPSBmcmFtZXNbaV07XG5cdFx0XHR2YXIgcmVjdCA9IHNyYy5yZWN0LmNsb25lKCk7XG5cdFx0XHRpbWcgPSBpbWdzW3NyYy5pbWFnZS5fX3RtcCtpbCpjb3VudF07XG5cblx0XHRcdHZhciBmcmFtZSA9IHtpbWFnZTppbWcscmVjdDpyZWN0LHJlZ1g6c3JjLnJlZ1gscmVnWTpzcmMucmVnWX07XG5cdFx0XHRpZiAoaCkge1xuXHRcdFx0XHRyZWN0LnggPSBpbWcud2lkdGgtcmVjdC54LXJlY3Qud2lkdGg7IC8vIHVwZGF0ZSByZWN0XG5cdFx0XHRcdGZyYW1lLnJlZ1ggPSByZWN0LndpZHRoLXNyYy5yZWdYOyAvLyB1cGRhdGUgcmVnaXN0cmF0aW9uIHBvaW50XG5cdFx0XHR9XG5cdFx0XHRpZiAodikge1xuXHRcdFx0XHRyZWN0LnkgPSBpbWcuaGVpZ2h0LXJlY3QueS1yZWN0LmhlaWdodDsgIC8vIHVwZGF0ZSByZWN0XG5cdFx0XHRcdGZyYW1lLnJlZ1kgPSByZWN0LmhlaWdodC1zcmMucmVnWTsgLy8gdXBkYXRlIHJlZ2lzdHJhdGlvbiBwb2ludFxuXHRcdFx0fVxuXHRcdFx0ZnJhbWVzLnB1c2goZnJhbWUpO1xuXHRcdH1cblxuXHRcdHZhciBzZnggPSBcIl9cIisoaD9cImhcIjpcIlwiKSsodj9cInZcIjpcIlwiKTtcblx0XHR2YXIgbmFtZXMgPSBzcHJpdGVTaGVldC5fYW5pbWF0aW9ucztcblx0XHR2YXIgZGF0YSA9IHNwcml0ZVNoZWV0Ll9kYXRhO1xuXHRcdHZhciBhbCA9IG5hbWVzLmxlbmd0aC9jb3VudDtcblx0XHRmb3IgKGk9MDtpPGFsO2krKykge1xuXHRcdFx0dmFyIG5hbWUgPSBuYW1lc1tpXTtcblx0XHRcdHNyYyA9IGRhdGFbbmFtZV07XG5cdFx0XHR2YXIgYW5pbSA9IHtuYW1lOm5hbWUrc2Z4LHNwZWVkOnNyYy5zcGVlZCxuZXh0OnNyYy5uZXh0LGZyYW1lczpbXX07XG5cdFx0XHRpZiAoc3JjLm5leHQpIHsgYW5pbS5uZXh0ICs9IHNmeDsgfVxuXHRcdFx0ZnJhbWVzID0gc3JjLmZyYW1lcztcblx0XHRcdGZvciAodmFyIGo9MCxsPWZyYW1lcy5sZW5ndGg7ajxsO2orKykge1xuXHRcdFx0XHRhbmltLmZyYW1lcy5wdXNoKGZyYW1lc1tqXStmbCpjb3VudCk7XG5cdFx0XHR9XG5cdFx0XHRkYXRhW2FuaW0ubmFtZV0gPSBhbmltO1xuXHRcdFx0bmFtZXMucHVzaChhbmltLm5hbWUpO1xuXHRcdH1cblx0fTtcblxuXG5cdGNyZWF0ZWpzLlNwcml0ZVNoZWV0VXRpbHMgPSBTcHJpdGVTaGVldFV0aWxzO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNwcml0ZVNoZWV0QnVpbGRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFRoZSBTcHJpdGVTaGVldEJ1aWxkZXIgYWxsb3dzIHlvdSB0byBnZW5lcmF0ZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZXMgYXQgcnVuIHRpbWVcblx0ICogZnJvbSBhbnkgZGlzcGxheSBvYmplY3QuIFRoaXMgY2FuIGFsbG93IHlvdSB0byBtYWludGFpbiB5b3VyIGFzc2V0cyBhcyB2ZWN0b3IgZ3JhcGhpY3MgKGZvciBsb3cgZmlsZSBzaXplKSwgYW5kXG5cdCAqIHJlbmRlciB0aGVtIGF0IHJ1biB0aW1lIGFzIFNwcml0ZVNoZWV0cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlxuXHQgKlxuXHQgKiBTcHJpdGVTaGVldHMgY2FuIGJlIGJ1aWx0IGVpdGhlciBzeW5jaHJvbm91c2x5LCBvciBhc3luY2hyb25vdXNseSwgc28gdGhhdCBsYXJnZSBTcHJpdGVTaGVldHMgY2FuIGJlIGdlbmVyYXRlZFxuXHQgKiB3aXRob3V0IGxvY2tpbmcgdGhlIFVJLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIFwiaW1hZ2VzXCIgdXNlZCBpbiB0aGUgZ2VuZXJhdGVkIFNwcml0ZVNoZWV0IGFyZSBhY3R1YWxseSBjYW52YXMgZWxlbWVudHMsIGFuZCB0aGF0IHRoZXkgd2lsbCBiZVxuXHQgKiBzaXplZCB0byB0aGUgbmVhcmVzdCBwb3dlciBvZiAyIHVwIHRvIHRoZSB2YWx1ZSBvZiB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldEJ1aWxkZXIvbWF4V2lkdGg6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogb3Ige3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRCdWlsZGVyL21heEhlaWdodDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQGNsYXNzIFNwcml0ZVNoZWV0QnVpbGRlclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2ZyYW1lcmF0ZT0wXSBUaGUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXQvZnJhbWVyYXRlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IG9mXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlcyB0aGF0IGFyZSBjcmVhdGVkLlxuXHQgKiBAZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gU3ByaXRlU2hlZXRCdWlsZGVyKGZyYW1lcmF0ZSkge1xuXHRcdHRoaXMuRXZlbnREaXNwYXRjaGVyX2NvbnN0cnVjdG9yKCk7XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSBtYXhpbXVtIHdpZHRoIGZvciB0aGUgaW1hZ2VzIChub3QgaW5kaXZpZHVhbCBmcmFtZXMpIGluIHRoZSBnZW5lcmF0ZWQgU3ByaXRlU2hlZXQuIEl0IGlzIHJlY29tbWVuZGVkIHRvXG5cdFx0ICogdXNlIGEgcG93ZXIgb2YgMiBmb3IgdGhpcyB2YWx1ZSAoZXguIDEwMjQsIDIwNDgsIDQwOTYpLiBJZiB0aGUgZnJhbWVzIGNhbm5vdCBhbGwgZml0IHdpdGhpbiB0aGUgbWF4XG5cdFx0ICogZGltZW5zaW9ucywgdGhlbiBhZGRpdGlvbmFsIGltYWdlcyB3aWxsIGJlIGNyZWF0ZWQgYXMgbmVlZGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBtYXhXaWR0aFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDIwNDhcblx0XHQqL1xuXHRcdHRoaXMubWF4V2lkdGggPSAyMDQ4O1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgbWF4aW11bSBoZWlnaHQgZm9yIHRoZSBpbWFnZXMgKG5vdCBpbmRpdmlkdWFsIGZyYW1lcykgaW4gdGhlIGdlbmVyYXRlZCBTcHJpdGVTaGVldC4gSXQgaXMgcmVjb21tZW5kZWQgdG9cblx0XHQgKiB1c2UgYSBwb3dlciBvZiAyIGZvciB0aGlzIHZhbHVlIChleC4gMTAyNCwgMjA0OCwgNDA5NikuIElmIHRoZSBmcmFtZXMgY2Fubm90IGFsbCBmaXQgd2l0aGluIHRoZSBtYXhcblx0XHQgKiBkaW1lbnNpb25zLCB0aGVuIGFkZGl0aW9uYWwgaW1hZ2VzIHdpbGwgYmUgY3JlYXRlZCBhcyBuZWVkZWQuXG5cdFx0ICogQHByb3BlcnR5IG1heEhlaWdodFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDIwNDhcblx0XHQgKiovXG5cdFx0dGhpcy5tYXhIZWlnaHQgPSAyMDQ4O1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgU3ByaXRlU2hlZXQgdGhhdCB3YXMgZ2VuZXJhdGVkLiBUaGlzIHdpbGwgYmUgbnVsbCBiZWZvcmUgYSBidWlsZCBpcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuXHRcdCAqIEBwcm9wZXJ0eSBzcHJpdGVTaGVldFxuXHRcdCAqIEB0eXBlIFNwcml0ZVNoZWV0XG5cdFx0ICoqL1xuXHRcdHRoaXMuc3ByaXRlU2hlZXQgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgc2NhbGUgdG8gYXBwbHkgd2hlbiBkcmF3aW5nIGFsbCBmcmFtZXMgdG8gdGhlIFNwcml0ZVNoZWV0LiBUaGlzIGlzIG11bHRpcGxpZWQgYWdhaW5zdCBhbnkgc2NhbGUgc3BlY2lmaWVkXG5cdFx0ICogaW4gdGhlIGFkZEZyYW1lIGNhbGwuIFRoaXMgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCB0byBnZW5lcmF0ZSBhIFNwcml0ZVNoZWV0IGF0IHJ1biB0aW1lIHRoYXQgaXMgdGFpbG9yZWRcblx0XHQgKiB0byB0aGUgYSBzcGVjaWZpYyBkZXZpY2UgcmVzb2x1dGlvbiAoZXguIHRhYmxldCB2cyBtb2JpbGUpLlxuXHRcdCAqIEBwcm9wZXJ0eSBzY2FsZVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKiovXG5cdFx0dGhpcy5zY2FsZSA9IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCogVGhlIHBhZGRpbmcgdG8gdXNlIGJldHdlZW4gZnJhbWVzLiBUaGlzIGlzIGhlbHBmdWwgdG8gcHJlc2VydmUgYW50aWFsaWFzaW5nIG9uIGRyYXduIHZlY3RvciBjb250ZW50LlxuXHRcdCogQHByb3BlcnR5IHBhZGRpbmdcblx0XHQqIEB0eXBlIE51bWJlclxuXHRcdCogQGRlZmF1bHQgMVxuXHRcdCoqL1xuXHRcdHRoaXMucGFkZGluZyA9IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEEgbnVtYmVyIGZyb20gMC4wMSB0byAwLjk5IHRoYXQgaW5kaWNhdGVzIHdoYXQgcGVyY2VudGFnZSBvZiB0aW1lIHRoZSBidWlsZGVyIGNhbiB1c2UuIFRoaXMgY2FuIGJlXG5cdFx0ICogdGhvdWdodCBvZiBhcyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgcGVyIHNlY29uZCB0aGUgYnVpbGRlciB3aWxsIHVzZS4gRm9yIGV4YW1wbGUsIHdpdGggYSB0aW1lU2xpY2UgdmFsdWUgb2YgMC4zLFxuXHRcdCAqIHRoZSBidWlsZGVyIHdpbGwgcnVuIDIwIHRpbWVzIHBlciBzZWNvbmQsIHVzaW5nIGFwcHJveGltYXRlbHkgMTVtcyBwZXIgYnVpbGQgKDMwJSBvZiBhdmFpbGFibGUgdGltZSwgb3IgMC4zcyBwZXIgc2Vjb25kKS5cblx0XHQgKiBEZWZhdWx0cyB0byAwLjMuXG5cdFx0ICogQHByb3BlcnR5IHRpbWVTbGljZVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDAuM1xuXHRcdCAqKi9cblx0XHR0aGlzLnRpbWVTbGljZSA9IDAuMztcblx0XG5cdFx0LyoqXG5cdFx0ICogQSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEgdGhhdCBpbmRpY2F0ZXMgdGhlIHByb2dyZXNzIG9mIGEgYnVpbGQsIG9yIC0xIGlmIGEgYnVpbGQgaGFzIG5vdFxuXHRcdCAqIGJlZW4gaW5pdGlhdGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBwcm9ncmVzc1xuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IC0xXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5wcm9ncmVzcyA9IC0xO1xuXG5cdFx0LyoqXG5cdFx0ICogQSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldC9mcmFtZXJhdGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gdmFsdWUgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byBuZXcge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2VzIHRoYXQgYXJlXG5cdFx0ICogY3JlYXRlZC4gSWYgbm8gZnJhbWVyYXRlIGlzIHNwZWNpZmllZCAob3IgaXQgaXMgMCksIHRoZW4gU3ByaXRlU2hlZXRzIHdpbGwgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBmcmFtZXJhdGUuXG5cdFx0ICogQHByb3BlcnR5IGZyYW1lcmF0ZVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmZyYW1lcmF0ZSA9IGZyYW1lcmF0ZSB8fCAwO1xuXHRcblx0XG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2ZyYW1lc1xuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBBcnJheVxuXHRcdCAqKi9cblx0XHR0aGlzLl9mcmFtZXMgPSBbXTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9hbmltYXRpb25zXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIEFycmF5XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2FuaW1hdGlvbnMgPSB7fTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9kYXRhXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIEFycmF5XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2RhdGEgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX25leHRGcmFtZUluZGV4XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9uZXh0RnJhbWVJbmRleCA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfaW5kZXhcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2luZGV4ID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF90aW1lcklEXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl90aW1lcklEID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9zY2FsZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fc2NhbGUgPSAxO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFNwcml0ZVNoZWV0QnVpbGRlciwgY3JlYXRlanMuRXZlbnREaXNwYXRjaGVyKTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblxuLy8gY29uc3RhbnRzOlxuXHRTcHJpdGVTaGVldEJ1aWxkZXIuRVJSX0RJTUVOU0lPTlMgPSBcImZyYW1lIGRpbWVuc2lvbnMgZXhjZWVkIG1heCBzcHJpdGVzaGVldCBkaW1lbnNpb25zXCI7XG5cdFNwcml0ZVNoZWV0QnVpbGRlci5FUlJfUlVOTklORyA9IFwiYSBidWlsZCBpcyBhbHJlYWR5IHJ1bm5pbmdcIjtcblxuLy8gZXZlbnRzOlxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIGEgYnVpbGQgY29tcGxldGVzLlxuXHQgKiBAZXZlbnQgY29tcGxldGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiBhbiBhc3luY2hyb25vdXMgYnVpbGQgaGFzIHByb2dyZXNzLlxuXHQgKiBAZXZlbnQgcHJvZ3Jlc3Ncblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcHJvZ3Jlc3MgVGhlIGN1cnJlbnQgcHJvZ3Jlc3MgdmFsdWUgKDAtMSkuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEFkZHMgYSBmcmFtZSB0byB0aGUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0uIE5vdGUgdGhhdCB0aGUgZnJhbWUgd2lsbCBub3QgYmUgZHJhd24gdW50aWwgeW91XG5cdCAqIGNhbGwge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRCdWlsZGVyL2J1aWxkXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC4gVGhlIG9wdGlvbmFsIHNldHVwIHBhcmFtcyBhbGxvdyB5b3UgdG8gaGF2ZVxuXHQgKiBhIGZ1bmN0aW9uIHJ1biBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRyYXcgb2NjdXJzLiBGb3IgZXhhbXBsZSwgdGhpcyBhbGxvd3MgeW91IHRvIGFkZCBhIHNpbmdsZSBzb3VyY2UgbXVsdGlwbGVcblx0ICogdGltZXMsIGJ1dCBtYW5pcHVsYXRlIGl0IG9yIGl0cyBjaGlsZHJlbiB0byBjaGFuZ2UgaXQgdG8gZ2VuZXJhdGUgZGlmZmVyZW50IGZyYW1lcy5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoZSBzb3VyY2UncyB0cmFuc2Zvcm1hdGlvbnMgKHgsIHksIHNjYWxlLCByb3RhdGUsIGFscGhhKSB3aWxsIGJlIGlnbm9yZWQsIGV4Y2VwdCBmb3IgcmVnWC9ZLiBUbyBhcHBseVxuXHQgKiB0cmFuc2Zvcm1zIHRvIGEgc291cmNlIG9iamVjdCBhbmQgaGF2ZSB0aGVtIGNhcHR1cmVkIGluIHRoZSBTcHJpdGVTaGVldCwgc2ltcGx5IHBsYWNlIGl0IGludG8gYSB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogYW5kIHBhc3MgaW4gdGhlIENvbnRhaW5lciBhcyB0aGUgc291cmNlLlxuXHQgKiBAbWV0aG9kIGFkZEZyYW1lXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gc291cmNlIFRoZSBzb3VyY2Uge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdFwifX17ey9jcm9zc0xpbmt9fSAgdG8gZHJhdyBhcyB0aGUgZnJhbWUuXG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBbc291cmNlUmVjdF0gQSB7eyNjcm9zc0xpbmsgXCJSZWN0YW5nbGVcIn19e3svY3Jvc3NMaW5rfX0gZGVmaW5pbmcgdGhlIHBvcnRpb24gb2YgdGhlXG5cdCAqIHNvdXJjZSB0byBkcmF3IHRvIHRoZSBmcmFtZS4gSWYgbm90IHNwZWNpZmllZCwgaXQgd2lsbCBsb29rIGZvciBhIGBnZXRCb3VuZHNgIG1ldGhvZCwgYm91bmRzIHByb3BlcnR5LCBvclxuXHQgKiBgbm9taW5hbEJvdW5kc2AgcHJvcGVydHkgb24gdGhlIHNvdXJjZSB0byB1c2UuIElmIG9uZSBpcyBub3QgZm91bmQsIHRoZSBmcmFtZSB3aWxsIGJlIHNraXBwZWQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGU9MV0gT3B0aW9uYWwuIFRoZSBzY2FsZSB0byBkcmF3IHRoaXMgZnJhbWUgYXQuIERlZmF1bHQgaXMgMS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW3NldHVwRnVuY3Rpb25dIEEgZnVuY3Rpb24gdG8gY2FsbCBpbW1lZGlhdGVseSBiZWZvcmUgZHJhd2luZyB0aGlzIGZyYW1lLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHR3byBwYXJhbWV0ZXJzOiB0aGUgc291cmNlLCBhbmQgc2V0dXBEYXRhLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3NldHVwRGF0YV0gQXJiaXRyYXJ5IHNldHVwIGRhdGEgdG8gcGFzcyB0byBzZXR1cEZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgZnJhbWUgdGhhdCB3YXMganVzdCBhZGRlZCwgb3IgbnVsbCBpZiBhIHNvdXJjZVJlY3QgY291bGQgbm90IGJlIGRldGVybWluZWQuXG5cdCAqKi9cblx0cC5hZGRGcmFtZSA9IGZ1bmN0aW9uKHNvdXJjZSwgc291cmNlUmVjdCwgc2NhbGUsIHNldHVwRnVuY3Rpb24sIHNldHVwRGF0YSkge1xuXHRcdGlmICh0aGlzLl9kYXRhKSB7IHRocm93IFNwcml0ZVNoZWV0QnVpbGRlci5FUlJfUlVOTklORzsgfVxuXHRcdHZhciByZWN0ID0gc291cmNlUmVjdHx8c291cmNlLmJvdW5kc3x8c291cmNlLm5vbWluYWxCb3VuZHM7XG5cdFx0aWYgKCFyZWN0JiZzb3VyY2UuZ2V0Qm91bmRzKSB7IHJlY3QgPSBzb3VyY2UuZ2V0Qm91bmRzKCk7IH1cblx0XHRpZiAoIXJlY3QpIHsgcmV0dXJuIG51bGw7IH1cblx0XHRzY2FsZSA9IHNjYWxlfHwxO1xuXHRcdHJldHVybiB0aGlzLl9mcmFtZXMucHVzaCh7c291cmNlOnNvdXJjZSwgc291cmNlUmVjdDpyZWN0LCBzY2FsZTpzY2FsZSwgZnVuY3Q6c2V0dXBGdW5jdGlvbiwgZGF0YTpzZXR1cERhdGEsIGluZGV4OnRoaXMuX2ZyYW1lcy5sZW5ndGgsIGhlaWdodDpyZWN0LmhlaWdodCpzY2FsZX0pLTE7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gYW5pbWF0aW9uIHRoYXQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgY3JlYXRlZCB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBhZGRBbmltYXRpb25cblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgZm9yIHRoZSBhbmltYXRpb24uXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGZyYW1lcyBBbiBhcnJheSBvZiBmcmFtZSBpbmRleGVzIHRoYXQgY29tcHJpc2UgdGhlIGFuaW1hdGlvbi4gRXguIFszLDYsNV0gd291bGQgZGVzY3JpYmUgYW4gYW5pbWF0aW9uXG5cdCAqIHRoYXQgcGxheWVkIGZyYW1lIGluZGV4ZXMgMywgNiwgYW5kIDUgaW4gdGhhdCBvcmRlci5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtuZXh0XSBTcGVjaWZpZXMgdGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBjb250aW51ZSB0byBhZnRlciB0aGlzIGFuaW1hdGlvbiBlbmRzLiBZb3UgY2FuXG5cdCAqIGFsc28gcGFzcyBmYWxzZSB0byBoYXZlIHRoZSBhbmltYXRpb24gc3RvcCB3aGVuIGl0IGVuZHMuIEJ5IGRlZmF1bHQgaXQgd2lsbCBsb29wIHRvIHRoZSBzdGFydCBvZiB0aGUgc2FtZSBhbmltYXRpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIFNwZWNpZmllcyBhIGZyYW1lIGFkdmFuY2Ugc3BlZWQgZm9yIHRoaXMgYW5pbWF0aW9uLiBGb3IgZXhhbXBsZSwgYSB2YWx1ZSBvZiAwLjUgd291bGRcblx0ICogY2F1c2UgdGhlIGFuaW1hdGlvbiB0byBhZHZhbmNlIGV2ZXJ5IHNlY29uZCB0aWNrLiBOb3RlIHRoYXQgZWFybGllciB2ZXJzaW9ucyB1c2VkIGBmcmVxdWVuY3lgIGluc3RlYWQsIHdoaWNoIGhhZFxuXHQgKiB0aGUgb3Bwb3NpdGUgZWZmZWN0LlxuXHQgKiovXG5cdHAuYWRkQW5pbWF0aW9uID0gZnVuY3Rpb24obmFtZSwgZnJhbWVzLCBuZXh0LCBzcGVlZCkge1xuXHRcdGlmICh0aGlzLl9kYXRhKSB7IHRocm93IFNwcml0ZVNoZWV0QnVpbGRlci5FUlJfUlVOTklORzsgfVxuXHRcdHRoaXMuX2FuaW1hdGlvbnNbbmFtZV0gPSB7ZnJhbWVzOmZyYW1lcywgbmV4dDpuZXh0LCBzcGVlZDpzcGVlZH07XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoaXMgd2lsbCB0YWtlIGEge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlLCBhbmQgYWRkIGl0cyBmcmFtZXMgYW5kIGxhYmVscyB0byB0aGlzXG5cdCAqIGJ1aWxkZXIuIExhYmVscyB3aWxsIGJlIGFkZGVkIGFzIGFuIGFuaW1hdGlvbiBydW5uaW5nIGZyb20gdGhlIGxhYmVsIGluZGV4IHRvIHRoZSBuZXh0IGxhYmVsLiBGb3IgZXhhbXBsZSwgaWZcblx0ICogdGhlcmUgaXMgYSBsYWJlbCBuYW1lZCBcImZvb1wiIGF0IGZyYW1lIDAgYW5kIGEgbGFiZWwgbmFtZWQgXCJiYXJcIiBhdCBmcmFtZSAxMCwgaW4gYSBNb3ZpZUNsaXAgd2l0aCAxNSBmcmFtZXMsIGl0XG5cdCAqIHdpbGwgYWRkIGFuIGFuaW1hdGlvbiBuYW1lZCBcImZvb1wiIHRoYXQgcnVucyBmcm9tIGZyYW1lIGluZGV4IDAgdG8gOSwgYW5kIGFuIGFuaW1hdGlvbiBuYW1lZCBcImJhclwiIHRoYXQgcnVucyBmcm9tXG5cdCAqIGZyYW1lIGluZGV4IDEwIHRvIDE0LlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIGl0ZXJhdGUgdGhyb3VnaCB0aGUgZnVsbCBNb3ZpZUNsaXAgd2l0aCB7eyNjcm9zc0xpbmsgXCJNb3ZpZUNsaXAvYWN0aW9uc0VuYWJsZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogc2V0IHRvIGBmYWxzZWAsIGVuZGluZyBvbiB0aGUgbGFzdCBmcmFtZS5cblx0ICogQG1ldGhvZCBhZGRNb3ZpZUNsaXBcblx0ICogQHBhcmFtIHtNb3ZpZUNsaXB9IHNvdXJjZSBUaGUgc291cmNlIE1vdmllQ2xpcCBpbnN0YW5jZSB0byBhZGQgdG8gdGhlIFNwcml0ZVNoZWV0LlxuXHQgKiBAcGFyYW0ge1JlY3RhbmdsZX0gW3NvdXJjZVJlY3RdIEEge3sjY3Jvc3NMaW5rIFwiUmVjdGFuZ2xlXCJ9fXt7L2Nyb3NzTGlua319IGRlZmluaW5nIHRoZSBwb3J0aW9uIG9mIHRoZSBzb3VyY2UgdG9cblx0ICogZHJhdyB0byB0aGUgZnJhbWUuIElmIG5vdCBzcGVjaWZpZWQsIGl0IHdpbGwgbG9vayBmb3IgYSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2dldEJvdW5kc1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QsIGBmcmFtZUJvdW5kc2AgQXJyYXksIGBib3VuZHNgIHByb3BlcnR5LCBvciBgbm9taW5hbEJvdW5kc2AgcHJvcGVydHkgb24gdGhlIHNvdXJjZSB0byB1c2UuIElmIG9uZSBpcyBub3Rcblx0ICogZm91bmQsIHRoZSBNb3ZpZUNsaXAgd2lsbCBiZSBza2lwcGVkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlPTFdIFRoZSBzY2FsZSB0byBkcmF3IHRoZSBtb3ZpZSBjbGlwIGF0LlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc2V0dXBGdW5jdGlvbl0gQSBmdW5jdGlvbiB0byBjYWxsIGltbWVkaWF0ZWx5IGJlZm9yZSBkcmF3aW5nIGVhY2ggZnJhbWUuIEl0IHdpbGwgYmUgY2FsbGVkXG5cdCAqIHdpdGggdGhyZWUgcGFyYW1ldGVyczogdGhlIHNvdXJjZSwgc2V0dXBEYXRhLCBhbmQgdGhlIGZyYW1lIGluZGV4LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3NldHVwRGF0YV0gQXJiaXRyYXJ5IHNldHVwIGRhdGEgdG8gcGFzcyB0byBzZXR1cEZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbGFiZWxGdW5jdGlvbl0gVGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggTW92aWVDbGlwIGxhYmVsIHRoYXQgaXMgYWRkZWQgd2l0aCBmb3VyXG5cdCAqIHBhcmFtZXRlcnM6IHRoZSBsYWJlbCBuYW1lLCB0aGUgc291cmNlIE1vdmllQ2xpcCBpbnN0YW5jZSwgdGhlIHN0YXJ0aW5nIGZyYW1lIGluZGV4IChpbiB0aGUgbW92aWVjbGlwIHRpbWVsaW5lKVxuXHQgKiBhbmQgdGhlIGVuZCBpbmRleC4gSXQgbXVzdCByZXR1cm4gYSBuZXcgbmFtZSBmb3IgdGhlIGxhYmVsL2FuaW1hdGlvbiwgb3IgYGZhbHNlYCB0byBleGNsdWRlIHRoZSBsYWJlbC5cblx0ICoqL1xuXHRwLmFkZE1vdmllQ2xpcCA9IGZ1bmN0aW9uKHNvdXJjZSwgc291cmNlUmVjdCwgc2NhbGUsIHNldHVwRnVuY3Rpb24sIHNldHVwRGF0YSwgbGFiZWxGdW5jdGlvbikge1xuXHRcdGlmICh0aGlzLl9kYXRhKSB7IHRocm93IFNwcml0ZVNoZWV0QnVpbGRlci5FUlJfUlVOTklORzsgfVxuXHRcdHZhciByZWN0cyA9IHNvdXJjZS5mcmFtZUJvdW5kcztcblx0XHR2YXIgcmVjdCA9IHNvdXJjZVJlY3R8fHNvdXJjZS5ib3VuZHN8fHNvdXJjZS5ub21pbmFsQm91bmRzO1xuXHRcdGlmICghcmVjdCYmc291cmNlLmdldEJvdW5kcykgeyByZWN0ID0gc291cmNlLmdldEJvdW5kcygpOyB9XG5cdFx0aWYgKCFyZWN0ICYmICFyZWN0cykgeyByZXR1cm47IH1cblxuXHRcdHZhciBpLCBsLCBiYXNlRnJhbWVJbmRleCA9IHRoaXMuX2ZyYW1lcy5sZW5ndGg7XG5cdFx0dmFyIGR1cmF0aW9uID0gc291cmNlLnRpbWVsaW5lLmR1cmF0aW9uO1xuXHRcdGZvciAoaT0wOyBpPGR1cmF0aW9uOyBpKyspIHtcblx0XHRcdHZhciByID0gKHJlY3RzJiZyZWN0c1tpXSkgPyByZWN0c1tpXSA6IHJlY3Q7XG5cdFx0XHR0aGlzLmFkZEZyYW1lKHNvdXJjZSwgciwgc2NhbGUsIHRoaXMuX3NldHVwTW92aWVDbGlwRnJhbWUsIHtpOmksIGY6c2V0dXBGdW5jdGlvbiwgZDpzZXR1cERhdGF9KTtcblx0XHR9XG5cdFx0dmFyIGxhYmVscyA9IHNvdXJjZS50aW1lbGluZS5fbGFiZWxzO1xuXHRcdHZhciBsYmxzID0gW107XG5cdFx0Zm9yICh2YXIgbiBpbiBsYWJlbHMpIHtcblx0XHRcdGxibHMucHVzaCh7aW5kZXg6bGFiZWxzW25dLCBsYWJlbDpufSk7XG5cdFx0fVxuXHRcdGlmIChsYmxzLmxlbmd0aCkge1xuXHRcdFx0bGJscy5zb3J0KGZ1bmN0aW9uKGEsYil7IHJldHVybiBhLmluZGV4LWIuaW5kZXg7IH0pO1xuXHRcdFx0Zm9yIChpPTAsbD1sYmxzLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdFx0dmFyIGxhYmVsID0gbGJsc1tpXS5sYWJlbDtcblx0XHRcdFx0dmFyIHN0YXJ0ID0gYmFzZUZyYW1lSW5kZXgrbGJsc1tpXS5pbmRleDtcblx0XHRcdFx0dmFyIGVuZCA9IGJhc2VGcmFtZUluZGV4KygoaSA9PSBsLTEpID8gZHVyYXRpb24gOiBsYmxzW2krMV0uaW5kZXgpO1xuXHRcdFx0XHR2YXIgZnJhbWVzID0gW107XG5cdFx0XHRcdGZvciAodmFyIGo9c3RhcnQ7IGo8ZW5kOyBqKyspIHsgZnJhbWVzLnB1c2goaik7IH1cblx0XHRcdFx0aWYgKGxhYmVsRnVuY3Rpb24pIHtcblx0XHRcdFx0XHRsYWJlbCA9IGxhYmVsRnVuY3Rpb24obGFiZWwsIHNvdXJjZSwgc3RhcnQsIGVuZCk7XG5cdFx0XHRcdFx0aWYgKCFsYWJlbCkgeyBjb250aW51ZTsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuYWRkQW5pbWF0aW9uKGxhYmVsLCBmcmFtZXMsIHRydWUpOyAvLyBmb3Igbm93LCB0aGlzIGxvb3BzIGFsbCBhbmltYXRpb25zLlxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQnVpbGRzIGEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZnJhbWVzLlxuXHQgKiBAbWV0aG9kIGJ1aWxkXG5cdCAqIEByZXR1cm4ge1Nwcml0ZVNoZWV0fSBUaGUgY3JlYXRlZCBTcHJpdGVTaGVldCBpbnN0YW5jZSwgb3IgbnVsbCBpZiBhIGJ1aWxkIGlzIGFscmVhZHkgcnVubmluZyBvciBhbiBlcnJvclxuXHQgKiBvY2N1cnJlZC5cblx0ICoqL1xuXHRwLmJ1aWxkID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2RhdGEpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9SVU5OSU5HOyB9XG5cdFx0dGhpcy5fc3RhcnRCdWlsZCgpO1xuXHRcdHdoaWxlICh0aGlzLl9kcmF3TmV4dCgpKSB7fVxuXHRcdHRoaXMuX2VuZEJ1aWxkKCk7XG5cdFx0cmV0dXJuIHRoaXMuc3ByaXRlU2hlZXQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFzeW5jaHJvbm91c2x5IGJ1aWxkcyBhIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGZyYW1lcy4gSXQgd2lsbFxuXHQgKiBydW4gMjAgdGltZXMgcGVyIHNlY29uZCwgdXNpbmcgYW4gYW1vdW50IG9mIHRpbWUgZGVmaW5lZCBieSBgdGltZVNsaWNlYC4gV2hlbiBpdCBpcyBjb21wbGV0ZSBpdCB3aWxsIGNhbGwgdGhlXG5cdCAqIHNwZWNpZmllZCBjYWxsYmFjay5cblx0ICogQG1ldGhvZCBidWlsZEFzeW5jXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZVNsaWNlXSBTZXRzIHRoZSB0aW1lU2xpY2UgcHJvcGVydHkgb24gdGhpcyBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmJ1aWxkQXN5bmMgPSBmdW5jdGlvbih0aW1lU2xpY2UpIHtcblx0XHRpZiAodGhpcy5fZGF0YSkgeyB0aHJvdyBTcHJpdGVTaGVldEJ1aWxkZXIuRVJSX1JVTk5JTkc7IH1cblx0XHR0aGlzLnRpbWVTbGljZSA9IHRpbWVTbGljZTtcblx0XHR0aGlzLl9zdGFydEJ1aWxkKCk7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR0aGlzLl90aW1lcklEID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgX3RoaXMuX3J1bigpOyB9LCA1MC1NYXRoLm1heCgwLjAxLCBNYXRoLm1pbigwLjk5LCB0aGlzLnRpbWVTbGljZXx8MC4zKSkqNTApO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdG9wcyB0aGUgY3VycmVudCBhc3luY2hyb25vdXMgYnVpbGQuXG5cdCAqIEBtZXRob2Qgc3RvcEFzeW5jXG5cdCAqKi9cblx0cC5zdG9wQXN5bmMgPSBmdW5jdGlvbigpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fdGltZXJJRCk7XG5cdFx0dGhpcy5fZGF0YSA9IG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNwcml0ZVNoZWV0QnVpbGRlciBpbnN0YW5jZXMgY2Fubm90IGJlIGNsb25lZC5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyhcIlNwcml0ZVNoZWV0QnVpbGRlciBjYW5ub3QgYmUgY2xvbmVkLlwiKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1Nwcml0ZVNoZWV0QnVpbGRlcl1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9zdGFydEJ1aWxkXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9zdGFydEJ1aWxkID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhZCA9IHRoaXMucGFkZGluZ3x8MDtcblx0XHR0aGlzLnByb2dyZXNzID0gMDtcblx0XHR0aGlzLnNwcml0ZVNoZWV0ID0gbnVsbDtcblx0XHR0aGlzLl9pbmRleCA9IDA7XG5cdFx0dGhpcy5fc2NhbGUgPSB0aGlzLnNjYWxlO1xuXHRcdHZhciBkYXRhRnJhbWVzID0gW107XG5cdFx0dGhpcy5fZGF0YSA9IHtcblx0XHRcdGltYWdlczogW10sXG5cdFx0XHRmcmFtZXM6IGRhdGFGcmFtZXMsXG5cdFx0XHRmcmFtZXJhdGU6IHRoaXMuZnJhbWVyYXRlLFxuXHRcdFx0YW5pbWF0aW9uczogdGhpcy5fYW5pbWF0aW9ucyAvLyBUT0RPOiBzaG91bGQgd2UgXCJjbG9uZVwiIF9hbmltYXRpb25zIGluIGNhc2Ugc29tZW9uZSBhZGRzIG1vcmUgYW5pbWF0aW9ucyBhZnRlciBhIGJ1aWxkP1xuXHRcdH07XG5cblx0XHR2YXIgZnJhbWVzID0gdGhpcy5fZnJhbWVzLnNsaWNlKCk7XG5cdFx0ZnJhbWVzLnNvcnQoZnVuY3Rpb24oYSxiKSB7IHJldHVybiAoYS5oZWlnaHQ8PWIuaGVpZ2h0KSA/IC0xIDogMTsgfSk7XG5cblx0XHRpZiAoZnJhbWVzW2ZyYW1lcy5sZW5ndGgtMV0uaGVpZ2h0K3BhZCoyID4gdGhpcy5tYXhIZWlnaHQpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9ESU1FTlNJT05TOyB9XG5cdFx0dmFyIHk9MCwgeD0wO1xuXHRcdHZhciBpbWcgPSAwO1xuXHRcdHdoaWxlIChmcmFtZXMubGVuZ3RoKSB7XG5cdFx0XHR2YXIgbyA9IHRoaXMuX2ZpbGxSb3coZnJhbWVzLCB5LCBpbWcsIGRhdGFGcmFtZXMsIHBhZCk7XG5cdFx0XHRpZiAoby53ID4geCkgeyB4ID0gby53OyB9XG5cdFx0XHR5ICs9IG8uaDtcblx0XHRcdGlmICghby5oIHx8ICFmcmFtZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBjYW52YXMgPSBjcmVhdGVqcy5jcmVhdGVDYW52YXM/Y3JlYXRlanMuY3JlYXRlQ2FudmFzKCk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcblx0XHRcdFx0Y2FudmFzLndpZHRoID0gdGhpcy5fZ2V0U2l6ZSh4LHRoaXMubWF4V2lkdGgpO1xuXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gdGhpcy5fZ2V0U2l6ZSh5LHRoaXMubWF4SGVpZ2h0KTtcblx0XHRcdFx0dGhpcy5fZGF0YS5pbWFnZXNbaW1nXSA9IGNhbnZhcztcblx0XHRcdFx0aWYgKCFvLmgpIHtcblx0XHRcdFx0XHR4PXk9MDtcblx0XHRcdFx0XHRpbWcrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9zZXR1cE1vdmllQ2xpcEZyYW1lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgd2lkdGggJiBoZWlnaHQgb2YgdGhlIHJvdy5cblx0ICoqL1xuXHRwLl9zZXR1cE1vdmllQ2xpcEZyYW1lID0gZnVuY3Rpb24oc291cmNlLCBkYXRhKSB7XG5cdFx0dmFyIGFlID0gc291cmNlLmFjdGlvbnNFbmFibGVkO1xuXHRcdHNvdXJjZS5hY3Rpb25zRW5hYmxlZCA9IGZhbHNlO1xuXHRcdHNvdXJjZS5nb3RvQW5kU3RvcChkYXRhLmkpO1xuXHRcdHNvdXJjZS5hY3Rpb25zRW5hYmxlZCA9IGFlO1xuXHRcdGRhdGEuZiYmZGF0YS5mKHNvdXJjZSwgZGF0YS5kLCBkYXRhLmkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRTaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgd2lkdGggJiBoZWlnaHQgb2YgdGhlIHJvdy5cblx0ICoqL1xuXHRwLl9nZXRTaXplID0gZnVuY3Rpb24oc2l6ZSxtYXgpIHtcblx0XHR2YXIgcG93ID0gNDtcblx0XHR3aGlsZSAoTWF0aC5wb3coMiwrK3BvdykgPCBzaXplKXt9XG5cdFx0cmV0dXJuIE1hdGgubWluKG1heCxNYXRoLnBvdygyLHBvdykpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9maWxsUm93XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGZyYW1lc1xuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IGltZ1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YUZyYW1lc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcGFkXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgd2lkdGggJiBoZWlnaHQgb2YgdGhlIHJvdy5cblx0ICoqL1xuXHRwLl9maWxsUm93ID0gZnVuY3Rpb24oZnJhbWVzLCB5LCBpbWcsIGRhdGFGcmFtZXMsIHBhZCkge1xuXHRcdHZhciB3ID0gdGhpcy5tYXhXaWR0aDtcblx0XHR2YXIgbWF4SCA9IHRoaXMubWF4SGVpZ2h0O1xuXHRcdHkgKz0gcGFkO1xuXHRcdHZhciBoID0gbWF4SC15O1xuXHRcdHZhciB4ID0gcGFkO1xuXHRcdHZhciBoZWlnaHQgPSAwO1xuXHRcdGZvciAodmFyIGk9ZnJhbWVzLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcblx0XHRcdHZhciBmcmFtZSA9IGZyYW1lc1tpXTtcblx0XHRcdHZhciBzYyA9IHRoaXMuX3NjYWxlKmZyYW1lLnNjYWxlO1xuXHRcdFx0dmFyIHJlY3QgPSBmcmFtZS5zb3VyY2VSZWN0O1xuXHRcdFx0dmFyIHNvdXJjZSA9IGZyYW1lLnNvdXJjZTtcblx0XHRcdHZhciByeCA9IE1hdGguZmxvb3Ioc2MqcmVjdC54LXBhZCk7XG5cdFx0XHR2YXIgcnkgPSBNYXRoLmZsb29yKHNjKnJlY3QueS1wYWQpO1xuXHRcdFx0dmFyIHJoID0gTWF0aC5jZWlsKHNjKnJlY3QuaGVpZ2h0K3BhZCoyKTtcblx0XHRcdHZhciBydyA9IE1hdGguY2VpbChzYypyZWN0LndpZHRoK3BhZCoyKTtcblx0XHRcdGlmIChydyA+IHcpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9ESU1FTlNJT05TOyB9XG5cdFx0XHRpZiAocmggPiBoIHx8IHgrcncgPiB3KSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRmcmFtZS5pbWcgPSBpbWc7XG5cdFx0XHRmcmFtZS5yZWN0ID0gbmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSh4LHkscncscmgpO1xuXHRcdFx0aGVpZ2h0ID0gaGVpZ2h0IHx8IHJoO1xuXHRcdFx0ZnJhbWVzLnNwbGljZShpLDEpO1xuXHRcdFx0ZGF0YUZyYW1lc1tmcmFtZS5pbmRleF0gPSBbeCx5LHJ3LHJoLGltZyxNYXRoLnJvdW5kKC1yeCtzYypzb3VyY2UucmVnWC1wYWQpLE1hdGgucm91bmQoLXJ5K3NjKnNvdXJjZS5yZWdZLXBhZCldO1xuXHRcdFx0eCArPSBydztcblx0XHR9XG5cdFx0cmV0dXJuIHt3OngsIGg6aGVpZ2h0fTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZW5kQnVpbGRcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2VuZEJ1aWxkID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zcHJpdGVTaGVldCA9IG5ldyBjcmVhdGVqcy5TcHJpdGVTaGVldCh0aGlzLl9kYXRhKTtcblx0XHR0aGlzLl9kYXRhID0gbnVsbDtcblx0XHR0aGlzLnByb2dyZXNzID0gMTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfcnVuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9ydW4gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdHMgPSBNYXRoLm1heCgwLjAxLCBNYXRoLm1pbigwLjk5LCB0aGlzLnRpbWVTbGljZXx8MC4zKSkqNTA7XG5cdFx0dmFyIHQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpK3RzO1xuXHRcdHZhciBjb21wbGV0ZSA9IGZhbHNlO1xuXHRcdHdoaWxlICh0ID4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSkge1xuXHRcdFx0aWYgKCF0aGlzLl9kcmF3TmV4dCgpKSB7IGNvbXBsZXRlID0gdHJ1ZTsgYnJlYWs7IH1cblx0XHR9XG5cdFx0aWYgKGNvbXBsZXRlKSB7XG5cdFx0XHR0aGlzLl9lbmRCdWlsZCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdFx0dGhpcy5fdGltZXJJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IF90aGlzLl9ydW4oKTsgfSwgNTAtdHMpO1xuXHRcdH1cblx0XHR2YXIgcCA9IHRoaXMucHJvZ3Jlc3MgPSB0aGlzLl9pbmRleC90aGlzLl9mcmFtZXMubGVuZ3RoO1xuXHRcdGlmICh0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiKSkge1xuXHRcdFx0dmFyIGV2dCA9IG5ldyBjcmVhdGVqcy5FdmVudChcInByb2dyZXNzXCIpO1xuXHRcdFx0ZXZ0LnByb2dyZXNzID0gcDtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZHJhd05leHRcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIEJvb2xlYW4gUmV0dXJucyBmYWxzZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGRyYXcuXG5cdCAqKi9cblx0cC5fZHJhd05leHQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgZnJhbWUgPSB0aGlzLl9mcmFtZXNbdGhpcy5faW5kZXhdO1xuXHRcdHZhciBzYyA9IGZyYW1lLnNjYWxlKnRoaXMuX3NjYWxlO1xuXHRcdHZhciByZWN0ID0gZnJhbWUucmVjdDtcblx0XHR2YXIgc291cmNlUmVjdCA9IGZyYW1lLnNvdXJjZVJlY3Q7XG5cdFx0dmFyIGNhbnZhcyA9IHRoaXMuX2RhdGEuaW1hZ2VzW2ZyYW1lLmltZ107XG5cdFx0dmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0ZnJhbWUuZnVuY3QmJmZyYW1lLmZ1bmN0KGZyYW1lLnNvdXJjZSwgZnJhbWUuZGF0YSk7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LnJlY3QocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcblx0XHRjdHguY2xpcCgpO1xuXHRcdGN0eC50cmFuc2xhdGUoTWF0aC5jZWlsKHJlY3QueC1zb3VyY2VSZWN0Lngqc2MpLCBNYXRoLmNlaWwocmVjdC55LXNvdXJjZVJlY3QueSpzYykpO1xuXHRcdGN0eC5zY2FsZShzYyxzYyk7XG5cdFx0ZnJhbWUuc291cmNlLmRyYXcoY3R4KTsgLy8gZGlzcGxheSBvYmplY3Qgd2lsbCBkcmF3IGl0c2VsZi5cblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdHJldHVybiAoKyt0aGlzLl9pbmRleCkgPCB0aGlzLl9mcmFtZXMubGVuZ3RoO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuU3ByaXRlU2hlZXRCdWlsZGVyID0gY3JlYXRlanMucHJvbW90ZShTcHJpdGVTaGVldEJ1aWxkZXIsIFwiRXZlbnREaXNwYXRjaGVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIERPTUVsZW1lbnQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiA8Yj5UaGlzIGNsYXNzIGlzIHN0aWxsIGV4cGVyaW1lbnRhbCwgYW5kIG1vcmUgYWR2YW5jZWQgdXNlIGlzIGxpa2VseSB0byBiZSBidWdneS4gUGxlYXNlIHJlcG9ydCBidWdzLjwvYj5cblx0ICpcblx0ICogQSBET01FbGVtZW50IGFsbG93cyB5b3UgdG8gYXNzb2NpYXRlIGEgSFRNTEVsZW1lbnQgd2l0aCB0aGUgZGlzcGxheSBsaXN0LiBJdCB3aWxsIGJlIHRyYW5zZm9ybWVkXG5cdCAqIHdpdGhpbiB0aGUgRE9NIGFzIHRob3VnaCBpdCBpcyBjaGlsZCBvZiB0aGUge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyXCJ9fXt7L2Nyb3NzTGlua319IGl0IGlzIGFkZGVkIHRvLiBIb3dldmVyLCBpdCBpc1xuXHQgKiBub3QgcmVuZGVyZWQgdG8gY2FudmFzLCBhbmQgYXMgc3VjaCB3aWxsIHJldGFpbiB3aGF0ZXZlciB6LWluZGV4IGl0IGhhcyByZWxhdGl2ZSB0byB0aGUgY2FudmFzIChpZS4gaXQgd2lsbCBiZVxuXHQgKiBkcmF3biBpbiBmcm9udCBvZiBvciBiZWhpbmQgdGhlIGNhbnZhcykuXG5cdCAqXG5cdCAqIFRoZSBwb3NpdGlvbiBvZiBhIERPTUVsZW1lbnQgaXMgcmVsYXRpdmUgdG8gdGhlaXIgcGFyZW50IG5vZGUgaW4gdGhlIERPTS4gSXQgaXMgcmVjb21tZW5kZWQgdGhhdFxuXHQgKiB0aGUgRE9NIE9iamVjdCBiZSBhZGRlZCB0byBhIGRpdiB0aGF0IGFsc28gY29udGFpbnMgdGhlIGNhbnZhcyBzbyB0aGF0IHRoZXkgc2hhcmUgdGhlIHNhbWUgcG9zaXRpb25cblx0ICogb24gdGhlIHBhZ2UuXG5cdCAqXG5cdCAqIERPTUVsZW1lbnQgaXMgdXNlZnVsIGZvciBwb3NpdGlvbmluZyBIVE1MIGVsZW1lbnRzIG92ZXIgdG9wIG9mIGNhbnZhcyBjb250ZW50LCBhbmQgZm9yIGVsZW1lbnRzXG5cdCAqIHRoYXQgeW91IHdhbnQgdG8gZGlzcGxheSBvdXRzaWRlIHRoZSBib3VuZHMgb2YgdGhlIGNhbnZhcy4gRm9yIGV4YW1wbGUsIGEgdG9vbHRpcCB3aXRoIHJpY2ggSFRNTFxuXHQgKiBjb250ZW50LlxuXHQgKlxuXHQgKiA8aDQ+TW91c2UgSW50ZXJhY3Rpb248L2g0PlxuXHQgKlxuXHQgKiBET01FbGVtZW50IGluc3RhbmNlcyBhcmUgbm90IGZ1bGwgRWFzZWxKUyBkaXNwbGF5IG9iamVjdHMsIGFuZCBkbyBub3QgcGFydGljaXBhdGUgaW4gRWFzZWxKUyBtb3VzZVxuXHQgKiBldmVudHMgb3Igc3VwcG9ydCBtZXRob2RzIGxpa2UgaGl0VGVzdC4gVG8gZ2V0IG1vdXNlIGV2ZW50cyBmcm9tIGEgRE9NRWxlbWVudCwgeW91IG11c3QgaW5zdGVhZCBhZGQgaGFuZGxlcnMgdG9cblx0ICogdGhlIGh0bWxFbGVtZW50IChub3RlLCB0aGlzIGRvZXMgbm90IHN1cHBvcnQgRXZlbnREaXNwYXRjaGVyKVxuXHQgKlxuXHQgKiAgICAgIHZhciBkb21FbGVtZW50ID0gbmV3IGNyZWF0ZWpzLkRPTUVsZW1lbnQoaHRtbEVsZW1lbnQpO1xuXHQgKiAgICAgIGRvbUVsZW1lbnQuaHRtbEVsZW1lbnQub25jbGljayA9IGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICAgICBjb25zb2xlLmxvZyhcImNsaWNrZWRcIik7XG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBAY2xhc3MgRE9NRWxlbWVudFxuXHQgKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBodG1sRWxlbWVudCBBIHJlZmVyZW5jZSBvciBpZCBmb3IgdGhlIERPTSBlbGVtZW50IHRvIG1hbmFnZS5cblx0ICovXG5cdGZ1bmN0aW9uIERPTUVsZW1lbnQoaHRtbEVsZW1lbnQpIHtcblx0XHR0aGlzLkRpc3BsYXlPYmplY3RfY29uc3RydWN0b3IoKTtcblx0XHRcblx0XHRpZiAodHlwZW9mKGh0bWxFbGVtZW50KT09XCJzdHJpbmdcIikgeyBodG1sRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGh0bWxFbGVtZW50KTsgfVxuXHRcdHRoaXMubW91c2VFbmFibGVkID0gZmFsc2U7XG5cdFx0XG5cdFx0dmFyIHN0eWxlID0gaHRtbEVsZW1lbnQuc3R5bGU7XG5cdFx0c3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0c3R5bGUudHJhbnNmb3JtT3JpZ2luID0gc3R5bGUuV2Via2l0VHJhbnNmb3JtT3JpZ2luID0gc3R5bGUubXNUcmFuc2Zvcm1PcmlnaW4gPSBzdHlsZS5Nb3pUcmFuc2Zvcm1PcmlnaW4gPSBzdHlsZS5PVHJhbnNmb3JtT3JpZ2luID0gXCIwJSAwJVwiO1xuXHRcdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgRE9NIG9iamVjdCB0byBtYW5hZ2UuXG5cdFx0ICogQHByb3BlcnR5IGh0bWxFbGVtZW50XG5cdFx0ICogQHR5cGUgSFRNTEVsZW1lbnRcblx0XHQgKi9cblx0XHR0aGlzLmh0bWxFbGVtZW50ID0gaHRtbEVsZW1lbnQ7XG5cdFxuXHRcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfb2xkTXR4XG5cdFx0ICogQHR5cGUgTWF0cml4MkRcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fb2xkUHJvcHMgPSBudWxsO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKERPTUVsZW1lbnQsIGNyZWF0ZWpzLkRpc3BsYXlPYmplY3QpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhcy5cblx0ICogVGhpcyBkb2VzIG5vdCBhY2NvdW50IGZvciB3aGV0aGVyIGl0IHdvdWxkIGJlIHZpc2libGUgd2l0aGluIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBzdGFnZS5cblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGlzVmlzaWJsZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhc1xuXHQgKi9cblx0cC5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5odG1sRWxlbWVudCAhPSBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyB0aGUgZGlzcGxheSBvYmplY3QgaW50byB0aGUgc3BlY2lmaWVkIGNvbnRleHQgaWdub3JpbmcgaXRzIHZpc2libGUsIGFscGhhLCBzaGFkb3csIGFuZCB0cmFuc2Zvcm0uXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZHJhdyB3YXMgaGFuZGxlZCAodXNlZnVsIGZvciBvdmVycmlkaW5nIGZ1bmN0aW9uYWxpdHkpLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgZHJhd1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZUNhY2hlIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkcmF3IG9wZXJhdGlvbiBzaG91bGQgaWdub3JlIGFueSBjdXJyZW50IGNhY2hlLlxuXHQgKiBGb3IgZXhhbXBsZSwgdXNlZCBmb3IgZHJhd2luZyB0aGUgY2FjaGUgKHRvIHByZXZlbnQgaXQgZnJvbSBzaW1wbHkgZHJhd2luZyBhbiBleGlzdGluZyBjYWNoZSBiYWNrXG5cdCAqIGludG8gaXRzZWxmKS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdHAuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgaWdub3JlQ2FjaGUpIHtcblx0XHQvLyB0aGlzIHJlbGllcyBvbiB0aGUgX3RpY2sgbWV0aG9kIGJlY2F1c2UgZHJhdyBpc24ndCBjYWxsZWQgaWYgdGhlIHBhcmVudCBpcyBub3QgdmlzaWJsZS5cblx0XHQvLyB0aGUgYWN0dWFsIHVwZGF0ZSBoYXBwZW5zIGluIF9oYW5kbGVEcmF3RW5kXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIE5vdCBhcHBsaWNhYmxlIHRvIERPTUVsZW1lbnQuXG5cdCAqIEBtZXRob2QgY2FjaGVcblx0ICovXG5cdHAuY2FjaGUgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qKlxuXHQgKiBOb3QgYXBwbGljYWJsZSB0byBET01FbGVtZW50LlxuXHQgKiBAbWV0aG9kIHVuY2FjaGVcblx0ICovXG5cdHAudW5jYWNoZSA9IGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIE5vdCBhcHBsaWNhYmxlIHRvIERPTUVsZW1lbnQuXG5cdCAqIEBtZXRob2QgdXBkYXRlQ2FjaGVcblx0ICovXG5cdHAudXBkYXRlQ2FjaGUgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qKlxuXHQgKiBOb3QgYXBwbGljYWJsZSB0byBET01FbGVtZW50LlxuXHQgKiBAbWV0aG9kIGhpdFRlc3Rcblx0ICovXG5cdHAuaGl0VGVzdCA9IGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIE5vdCBhcHBsaWNhYmxlIHRvIERPTUVsZW1lbnQuXG5cdCAqIEBtZXRob2QgbG9jYWxUb0dsb2JhbFxuXHQgKi9cblx0cC5sb2NhbFRvR2xvYmFsID0gZnVuY3Rpb24oKSB7fTtcblxuXHQvKipcblx0ICogTm90IGFwcGxpY2FibGUgdG8gRE9NRWxlbWVudC5cblx0ICogQG1ldGhvZCBnbG9iYWxUb0xvY2FsXG5cdCAqL1xuXHRwLmdsb2JhbFRvTG9jYWwgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qKlxuXHQgKiBOb3QgYXBwbGljYWJsZSB0byBET01FbGVtZW50LlxuXHQgKiBAbWV0aG9kIGxvY2FsVG9Mb2NhbFxuXHQgKi9cblx0cC5sb2NhbFRvTG9jYWwgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qKlxuXHQgKiBET01FbGVtZW50IGNhbm5vdCBiZSBjbG9uZWQuIFRocm93cyBhbiBlcnJvci5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRocm93KFwiRE9NRWxlbWVudCBjYW5ub3QgYmUgY2xvbmVkLlwiKVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltET01FbGVtZW50IChuYW1lPVwiKyAgdGhpcy5uYW1lICtcIildXCI7XG5cdH07XG5cblx0LyoqXG4gICAgICogSW50ZXJhY3Rpb24gZXZlbnRzIHNob3VsZCBiZSBhZGRlZCB0byBgaHRtbEVsZW1lbnRgLCBhbmQgbm90IHRoZSBET01FbGVtZW50IGluc3RhbmNlLCBzaW5jZSBET01FbGVtZW50IGluc3RhbmNlc1xuXHQgKiBhcmUgbm90IGZ1bGwgRWFzZWxKUyBkaXNwbGF5IG9iamVjdHMgYW5kIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBFYXNlbEpTIG1vdXNlIGV2ZW50cy5cblx0ICogQGV2ZW50IGNsaWNrXG5cdCAqL1xuXG4gICAgIC8qKlxuICAgICAqIEludGVyYWN0aW9uIGV2ZW50cyBzaG91bGQgYmUgYWRkZWQgdG8gYGh0bWxFbGVtZW50YCwgYW5kIG5vdCB0aGUgRE9NRWxlbWVudCBpbnN0YW5jZSwgc2luY2UgRE9NRWxlbWVudCBpbnN0YW5jZXNcbiBcdCAqIGFyZSBub3QgZnVsbCBFYXNlbEpTIGRpc3BsYXkgb2JqZWN0cyBhbmQgZG8gbm90IHBhcnRpY2lwYXRlIGluIEVhc2VsSlMgbW91c2UgZXZlbnRzLlxuXHQgKiBAZXZlbnQgZGJsQ2xpY2tcblx0ICovXG5cbiAgICAgLyoqXG4gICAgICAqIEludGVyYWN0aW9uIGV2ZW50cyBzaG91bGQgYmUgYWRkZWQgdG8gYGh0bWxFbGVtZW50YCwgYW5kIG5vdCB0aGUgRE9NRWxlbWVudCBpbnN0YW5jZSwgc2luY2UgRE9NRWxlbWVudCBpbnN0YW5jZXNcbiBcdCAgKiBhcmUgbm90IGZ1bGwgRWFzZWxKUyBkaXNwbGF5IG9iamVjdHMgYW5kIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBFYXNlbEpTIG1vdXNlIGV2ZW50cy5cblx0ICAqIEBldmVudCBtb3VzZWRvd25cblx0ICAqL1xuXG4gICAgIC8qKlxuICAgICAgKiBUaGUgSFRNTEVsZW1lbnQgY2FuIGxpc3RlbiBmb3IgdGhlIG1vdXNlb3ZlciBldmVudCwgbm90IHRoZSBET01FbGVtZW50IGluc3RhbmNlLlxuICAgICAgKiBTaW5jZSBET01FbGVtZW50IGluc3RhbmNlcyBhcmUgbm90IGZ1bGwgRWFzZWxKUyBkaXNwbGF5IG9iamVjdHMgYW5kIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBFYXNlbEpTIG1vdXNlIGV2ZW50cy5cbiAgICAgICogQGV2ZW50IG1vdXNlb3ZlclxuXHQgICovXG5cbiAgICAgLyoqXG4gICAgICAqIE5vdCBhcHBsaWNhYmxlIHRvIERPTUVsZW1lbnQuXG5cdCAgKiBAZXZlbnQgdGlja1xuXHQgICovXG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfdGlja1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZ0T2JqIEFuIGV2ZW50IG9iamVjdCB0aGF0IHdpbGwgYmUgZGlzcGF0Y2hlZCB0byBhbGwgdGljayBsaXN0ZW5lcnMuIFRoaXMgb2JqZWN0IGlzIHJldXNlZCBiZXR3ZWVuIGRpc3BhdGNoZXJzIHRvIHJlZHVjZSBjb25zdHJ1Y3Rpb24gJiBHQyBjb3N0cy5cblx0ICogZnVuY3Rpb24uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3RpY2sgPSBmdW5jdGlvbihldnRPYmopIHtcblx0XHR2YXIgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XG5cdFx0c3RhZ2UmJnN0YWdlLm9uKFwiZHJhd2VuZFwiLCB0aGlzLl9oYW5kbGVEcmF3RW5kLCB0aGlzLCB0cnVlKTtcblx0XHR0aGlzLkRpc3BsYXlPYmplY3RfX3RpY2soZXZ0T2JqKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVEcmF3RW5kXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2dFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9oYW5kbGVEcmF3RW5kID0gZnVuY3Rpb24oZXZ0KSB7XG5cdFx0dmFyIG8gPSB0aGlzLmh0bWxFbGVtZW50O1xuXHRcdGlmICghbykgeyByZXR1cm47IH1cblx0XHR2YXIgc3R5bGUgPSBvLnN0eWxlO1xuXHRcdFxuXHRcdHZhciBwcm9wcyA9IHRoaXMuZ2V0Q29uY2F0ZW5hdGVkRGlzcGxheVByb3BzKHRoaXMuX3Byb3BzKSwgbXR4ID0gcHJvcHMubWF0cml4O1xuXHRcdFxuXHRcdHZhciB2aXNpYmlsaXR5ID0gcHJvcHMudmlzaWJsZSA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIjtcblx0XHRpZiAodmlzaWJpbGl0eSAhPSBzdHlsZS52aXNpYmlsaXR5KSB7IHN0eWxlLnZpc2liaWxpdHkgPSB2aXNpYmlsaXR5OyB9XG5cdFx0aWYgKCFwcm9wcy52aXNpYmxlKSB7IHJldHVybjsgfVxuXHRcdFxuXHRcdHZhciBvbGRQcm9wcyA9IHRoaXMuX29sZFByb3BzLCBvbGRNdHggPSBvbGRQcm9wcyYmb2xkUHJvcHMubWF0cml4O1xuXHRcdHZhciBuID0gMTAwMDA7IC8vIHByZWNpc2lvblxuXHRcdFxuXHRcdGlmICghb2xkTXR4IHx8ICFvbGRNdHguZXF1YWxzKG10eCkpIHtcblx0XHRcdHZhciBzdHIgPSBcIm1hdHJpeChcIiArIChtdHguYSpufDApL24gK1wiLFwiKyAobXR4LmIqbnwwKS9uICtcIixcIisgKG10eC5jKm58MCkvbiArXCIsXCIrIChtdHguZCpufDApL24gK1wiLFwiKyAobXR4LnR4KzAuNXwwKTtcblx0XHRcdHN0eWxlLnRyYW5zZm9ybSA9IHN0eWxlLldlYmtpdFRyYW5zZm9ybSA9IHN0eWxlLk9UcmFuc2Zvcm0gPSBzdHlsZS5tc1RyYW5zZm9ybSA9IHN0ciArXCIsXCIrIChtdHgudHkrMC41fDApICtcIilcIjtcblx0XHRcdHN0eWxlLk1velRyYW5zZm9ybSA9IHN0ciArXCJweCxcIisgKG10eC50eSswLjV8MCkgK1wicHgpXCI7XG5cdFx0XHRpZiAoIW9sZFByb3BzKSB7IG9sZFByb3BzID0gdGhpcy5fb2xkUHJvcHMgPSBuZXcgY3JlYXRlanMuRGlzcGxheVByb3BzKHRydWUsIE5hTik7IH1cblx0XHRcdG9sZFByb3BzLm1hdHJpeC5jb3B5KG10eCk7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChvbGRQcm9wcy5hbHBoYSAhPSBwcm9wcy5hbHBoYSkge1xuXHRcdFx0c3R5bGUub3BhY2l0eSA9IFwiXCIrKHByb3BzLmFscGhhKm58MCkvbjtcblx0XHRcdG9sZFByb3BzLmFscGhhID0gcHJvcHMuYWxwaGE7XG5cdFx0fVxuXHR9O1xuXG5cblx0Y3JlYXRlanMuRE9NRWxlbWVudCA9IGNyZWF0ZWpzLnByb21vdGUoRE9NRWxlbWVudCwgXCJEaXNwbGF5T2JqZWN0XCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEZpbHRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEJhc2UgY2xhc3MgdGhhdCBhbGwgZmlsdGVycyBzaG91bGQgaW5oZXJpdCBmcm9tLiBGaWx0ZXJzIG5lZWQgdG8gYmUgYXBwbGllZCB0byBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIGNhY2hlZCB1c2luZ1xuXHQgKiB0aGUge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9jYWNoZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuIElmIGFuIG9iamVjdCBjaGFuZ2VzLCBwbGVhc2UgY2FjaGUgaXQgYWdhaW4sIG9yIHVzZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3VwZGF0ZUNhY2hlXCJ9fXt7L2Nyb3NzTGlua319LiBOb3RlIHRoYXQgdGhlIGZpbHRlcnMgbXVzdCBiZSBhcHBsaWVkIGJlZm9yZSBjYWNoaW5nLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgbXlJbnN0YW5jZS5maWx0ZXJzID0gW1xuXHQgKiAgICAgICAgICBuZXcgY3JlYXRlanMuQ29sb3JGaWx0ZXIoMCwgMCwgMCwgMSwgMjU1LCAwLCAwKSxcblx0ICogICAgICAgICAgbmV3IGNyZWF0ZWpzLkJsdXJGaWx0ZXIoNSwgNSwgMTApXG5cdCAqICAgICAgXTtcblx0ICogICAgICBteUluc3RhbmNlLmNhY2hlKDAsMCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiBOb3RlIHRoYXQgZWFjaCBmaWx0ZXIgY2FuIGltcGxlbWVudCBhIHt7I2Nyb3NzTGluayBcIkZpbHRlci9nZXRCb3VuZHNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLCB3aGljaCByZXR1cm5zIHRoZVxuXHQgKiBtYXJnaW5zIHRoYXQgbmVlZCB0byBiZSBhcHBsaWVkIGluIG9yZGVyIHRvIGZ1bGx5IGRpc3BsYXkgdGhlIGZpbHRlci4gRm9yIGV4YW1wbGUsIHRoZSB7eyNjcm9zc0xpbmsgXCJCbHVyRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdpbGwgY2F1c2UgYW4gb2JqZWN0IHRvIGZlYXRoZXIgb3V0d2FyZHMsIHJlc3VsdGluZyBpbiBhIG1hcmdpbiBhcm91bmQgdGhlIHNoYXBlLlxuXHQgKlxuXHQgKiA8aDQ+RWFzZWxKUyBGaWx0ZXJzPC9oND5cblx0ICogRWFzZWxKUyBjb21lcyB3aXRoIGEgbnVtYmVyIG9mIHByZS1idWlsdCBmaWx0ZXJzOlxuXHQgKiA8dWw+PGxpPnt7I2Nyb3NzTGluayBcIkFscGhhTWFwRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319IDogTWFwIGEgZ3JleXNjYWxlIGltYWdlIHRvIHRoZSBhbHBoYSBjaGFubmVsIG9mIGEgZGlzcGxheSBvYmplY3Q8L2xpPlxuXHQgKiAgICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBbHBoYU1hc2tGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX06IE1hcCBhbiBpbWFnZSdzIGFscGhhIGNoYW5uZWwgdG8gdGhlIGFscGhhIGNoYW5uZWwgb2YgYSBkaXNwbGF5IG9iamVjdDwvbGk+XG5cdCAqICAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkJsdXJGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX06IEFwcGx5IHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIGJsdXIgdG8gYSBkaXNwbGF5IG9iamVjdDwvbGk+XG5cdCAqICAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkNvbG9yRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319OiBDb2xvciB0cmFuc2Zvcm0gYSBkaXNwbGF5IG9iamVjdDwvbGk+XG5cdCAqICAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkNvbG9yTWF0cml4RmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319OiBUcmFuc2Zvcm0gYW4gaW1hZ2UgdXNpbmcgYSB7eyNjcm9zc0xpbmsgXCJDb2xvck1hdHJpeFwifX17ey9jcm9zc0xpbmt9fTwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqIEBjbGFzcyBGaWx0ZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gRmlsdGVyKCkge31cblx0dmFyIHAgPSBGaWx0ZXIucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFByb3ZpZGVzIHBhZGRpbmcgdmFsdWVzIGZvciB0aGlzIGZpbHRlci4gVGhhdCBpcywgaG93IG11Y2ggdGhlIGZpbHRlciB3aWxsIGV4dGVuZCB0aGUgdmlzdWFsIGJvdW5kcyBvZiBhbiBvYmplY3QgaXQgaXMgYXBwbGllZCB0by5cblx0ICogQG1ldGhvZCBnZXRCb3VuZHNcblx0ICogQHBhcmFtIHtSZWN0YW5nbGV9IFtyZWN0XSBJZiBzcGVjaWZpZWQsIHRoZSBwcm92aWRlZCBSZWN0YW5nbGUgaW5zdGFuY2Ugd2lsbCBiZSBleHBhbmRlZCBieSB0aGUgcGFkZGluZyBhbW91bnRzIGFuZCByZXR1cm5lZC5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBJZiBhIGByZWN0YCBwYXJhbSB3YXMgcHJvdmlkZWQsIGl0IGlzIHJldHVybmVkLiBJZiBub3QsIGVpdGhlciBhIG5ldyByZWN0YW5nbGUgd2l0aCB0aGUgcGFkZGluZyB2YWx1ZXMsIG9yIG51bGwgaWYgbm8gcGFkZGluZyBpcyByZXF1aXJlZCBmb3IgdGhpcyBmaWx0ZXIuXG5cdCAqKi9cblx0cC5nZXRCb3VuZHMgPSBmdW5jdGlvbihyZWN0KSB7XG5cdFx0cmV0dXJuIHJlY3Q7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgdGhlIGZpbHRlciB0byB0aGUgc3BlY2lmaWVkIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgYXBwbHlGaWx0ZXJcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgMkQgY29udGV4dCB0byB1c2UgYXMgdGhlIHNvdXJjZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gdG8gdXNlIGZvciB0aGUgc291cmNlIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uIHRvIHVzZSBmb3IgdGhlIHNvdXJjZSByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIHRvIHVzZSBmb3IgdGhlIHNvdXJjZSByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgdG8gdXNlIGZvciB0aGUgc291cmNlIHJlY3QuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBbdGFyZ2V0Q3R4XSBUaGUgMkQgY29udGV4dCB0byBkcmF3IHRoZSByZXN1bHQgdG8uIERlZmF1bHRzIHRvIHRoZSBjb250ZXh0IHBhc3NlZCB0byBjdHguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGFyZ2V0WF0gVGhlIHggcG9zaXRpb24gdG8gZHJhdyB0aGUgcmVzdWx0IHRvLiBEZWZhdWx0cyB0byB0aGUgdmFsdWUgcGFzc2VkIHRvIHguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGFyZ2V0WV0gVGhlIHkgcG9zaXRpb24gdG8gZHJhdyB0aGUgcmVzdWx0IHRvLiBEZWZhdWx0cyB0byB0aGUgdmFsdWUgcGFzc2VkIHRvIHkuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBmaWx0ZXIgd2FzIGFwcGxpZWQgc3VjY2Vzc2Z1bGx5LlxuXHQgKiovXG5cdHAuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbihjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHRhcmdldEN0eCwgdGFyZ2V0WCwgdGFyZ2V0WSkge1xuXHRcdC8vIHRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIGJlY2F1c2UgbW9zdCBmaWx0ZXJzIGFjY2VzcyBwaXhlbCBkYXRhLiBJdCBpcyBvdmVycmlkZGVuIHdoZW4gbm90IG5lZWRlZC5cblx0XHR0YXJnZXRDdHggPSB0YXJnZXRDdHggfHwgY3R4O1xuXHRcdGlmICh0YXJnZXRYID09IG51bGwpIHsgdGFyZ2V0WCA9IHg7IH1cblx0XHRpZiAodGFyZ2V0WSA9PSBudWxsKSB7IHRhcmdldFkgPSB5OyB9XG5cdFx0dHJ5IHtcblx0XHRcdHZhciBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX2FwcGx5RmlsdGVyKGltYWdlRGF0YSkpIHtcblx0XHRcdHRhcmdldEN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCB0YXJnZXRYLCB0YXJnZXRZKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltGaWx0ZXJdXCI7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGlzIEZpbHRlciBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtGaWx0ZXJ9IEEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgRmlsdGVyIGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEZpbHRlcigpO1xuXHR9O1xuXHRcbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX2FwcGx5RmlsdGVyXG5cdCAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBpbWFnZURhdGEgVGFyZ2V0IEltYWdlRGF0YSBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICoqL1xuXHRwLl9hcHBseUZpbHRlciA9IGZ1bmN0aW9uKGltYWdlRGF0YSkgeyByZXR1cm4gdHJ1ZTsgfTtcblxuXG5cdGNyZWF0ZWpzLkZpbHRlciA9IEZpbHRlcjtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBCbHVyRmlsdGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQXBwbGllcyBhIGJveCBibHVyIHRvIERpc3BsYXlPYmplY3RzLiBOb3RlIHRoYXQgdGhpcyBmaWx0ZXIgaXMgZmFpcmx5IENQVSBpbnRlbnNpdmUsIHBhcnRpY3VsYXJseSBpZiB0aGUgcXVhbGl0eSBpc1xuXHQgKiBzZXQgaGlnaGVyIHRoYW4gMS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBUaGlzIGV4YW1wbGUgY3JlYXRlcyBhIHJlZCBjaXJjbGUsIGFuZCB0aGVuIGFwcGxpZXMgYSA1IHBpeGVsIGJsdXIgdG8gaXQuIEl0IHVzZXMgdGhlIHt7I2Nyb3NzTGluayBcIkZpbHRlci9nZXRCb3VuZHNcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kIHRvIGFjY291bnQgZm9yIHRoZSBzcHJlYWQgdGhhdCB0aGUgYmx1ciBjYXVzZXMuXG5cdCAqXG5cdCAqICAgICAgdmFyIHNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCkuc2V0KHt4OjEwMCx5OjEwMH0pO1xuXHQgKiAgICAgIHNoYXBlLmdyYXBoaWNzLmJlZ2luRmlsbChcIiNmZjAwMDBcIikuZHJhd0NpcmNsZSgwLDAsNTApO1xuXHQgKlxuXHQgKiAgICAgIHZhciBibHVyRmlsdGVyID0gbmV3IGNyZWF0ZWpzLkJsdXJGaWx0ZXIoNSwgNSwgMSk7XG5cdCAqICAgICAgc2hhcGUuZmlsdGVycyA9IFtibHVyRmlsdGVyXTtcblx0ICogICAgICB2YXIgYm91bmRzID0gYmx1ckZpbHRlci5nZXRCb3VuZHMoKTtcblx0ICpcblx0ICogICAgICBzaGFwZS5jYWNoZSgtNTArYm91bmRzLngsIC01MCtib3VuZHMueSwgMTAwK2JvdW5kcy53aWR0aCwgMTAwK2JvdW5kcy5oZWlnaHQpO1xuXHQgKlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhbiBtb3JlIGluZm9ybWF0aW9uIG9uIGFwcGx5aW5nIGZpbHRlcnMuXG5cdCAqIEBjbGFzcyBCbHVyRmlsdGVyXG5cdCAqIEBleHRlbmRzIEZpbHRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtibHVyWD0wXSBUaGUgaG9yaXpvbnRhbCBibHVyIHJhZGl1cyBpbiBwaXhlbHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYmx1clk9MF0gVGhlIHZlcnRpY2FsIGJsdXIgcmFkaXVzIGluIHBpeGVscy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtxdWFsaXR5PTFdIFRoZSBudW1iZXIgb2YgYmx1ciBpdGVyYXRpb25zLlxuXHQgKiovXG5cdGZ1bmN0aW9uIEJsdXJGaWx0ZXIoIGJsdXJYLCBibHVyWSwgcXVhbGl0eSkge1xuXHRcdGlmICggaXNOYU4oYmx1clgpIHx8IGJsdXJYIDwgMCApIGJsdXJYID0gMDtcblx0XHRpZiAoIGlzTmFOKGJsdXJZKSB8fCBibHVyWSA8IDAgKSBibHVyWSA9IDA7XG5cdFx0aWYgKCBpc05hTihxdWFsaXR5KSB8fCBxdWFsaXR5IDwgMSAgKSBxdWFsaXR5ID0gMTtcblxuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogSG9yaXpvbnRhbCBibHVyIHJhZGl1cyBpbiBwaXhlbHNcblx0XHQgKiBAcHJvcGVydHkgYmx1clhcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuYmx1clggPSBibHVyWCB8IDA7XG5cblx0XHQvKipcblx0XHQgKiBWZXJ0aWNhbCBibHVyIHJhZGl1cyBpbiBwaXhlbHNcblx0XHQgKiBAcHJvcGVydHkgYmx1cllcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuYmx1clkgPSBibHVyWSB8IDA7XG5cblx0XHQvKipcblx0XHQgKiBOdW1iZXIgb2YgYmx1ciBpdGVyYXRpb25zLiBGb3IgZXhhbXBsZSwgYSB2YWx1ZSBvZiAxIHdpbGwgcHJvZHVjZSBhIHJvdWdoIGJsdXIuIEEgdmFsdWUgb2YgMiB3aWxsIHByb2R1Y2UgYVxuXHRcdCAqIHNtb290aGVyIGJsdXIsIGJ1dCB0YWtlIHR3aWNlIGFzIGxvbmcgdG8gcnVuLlxuXHRcdCAqIEBwcm9wZXJ0eSBxdWFsaXR5XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLnF1YWxpdHkgPSBxdWFsaXR5IHwgMDtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChCbHVyRmlsdGVyLCBjcmVhdGVqcy5GaWx0ZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cbi8vIGNvbnN0YW50czpcblx0LyoqXG5cdCAqIEFycmF5IG9mIG11bHRpcGx5IHZhbHVlcyBmb3IgYmx1ciBjYWxjdWxhdGlvbnMuXG5cdCAqIEBwcm9wZXJ0eSBNVUxfVEFCTEVcblx0ICogQHR5cGUgQXJyYXlcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0Qmx1ckZpbHRlci5NVUxfVEFCTEUgPSBbMSwgMTcxLCAyMDUsIDI5MywgNTcsIDM3MywgNzksIDEzNywgMjQxLCAyNywgMzkxLCAzNTcsIDQxLCAxOSwgMjgzLCAyNjUsIDQ5NywgNDY5LCA0NDMsIDQyMSwgMjUsIDE5MSwgMzY1LCAzNDksIDMzNSwgMTYxLCAxNTUsIDE0OSwgOSwgMjc4LCAyNjksIDI2MSwgNTA1LCAyNDUsIDQ3NSwgMjMxLCA0NDksIDQzNywgMjEzLCA0MTUsIDQwNSwgMzk1LCAxOTMsIDM3NywgMzY5LCAzNjEsIDM1MywgMzQ1LCAxNjksIDMzMSwgMzI1LCAzMTksIDMxMywgMzA3LCAzMDEsIDM3LCAxNDUsIDI4NSwgMjgxLCA2OSwgMjcxLCAyNjcsIDI2MywgMjU5LCA1MDksIDUwMSwgNDkzLCAyNDMsIDQ3OSwgMTE4LCA0NjUsIDQ1OSwgMTEzLCA0NDYsIDU1LCA0MzUsIDQyOSwgNDIzLCAyMDksIDQxMywgNTEsIDQwMywgMTk5LCAzOTMsIDk3LCAzLCAzNzksIDM3NSwgMzcxLCAzNjcsIDM2MywgMzU5LCAzNTUsIDM1MSwgMzQ3LCA0MywgODUsIDMzNywgMzMzLCAxNjUsIDMyNywgMzIzLCA1LCAzMTcsIDE1NywgMzExLCA3NywgMzA1LCAzMDMsIDc1LCAyOTcsIDI5NCwgNzMsIDI4OSwgMjg3LCA3MSwgMTQxLCAyNzksIDI3NywgMjc1LCA2OCwgMTM1LCA2NywgMTMzLCAzMywgMjYyLCAyNjAsIDEyOSwgNTExLCA1MDcsIDUwMywgNDk5LCA0OTUsIDQ5MSwgNjEsIDEyMSwgNDgxLCA0NzcsIDIzNywgMjM1LCA0NjcsIDIzMiwgMTE1LCA0NTcsIDIyNywgNDUxLCA3LCA0NDUsIDIyMSwgNDM5LCAyMTgsIDQzMywgMjE1LCA0MjcsIDQyNSwgMjExLCA0MTksIDQxNywgMjA3LCA0MTEsIDQwOSwgMjAzLCAyMDIsIDQwMSwgMzk5LCAzOTYsIDE5NywgNDksIDM4OSwgMzg3LCAzODUsIDM4MywgOTUsIDE4OSwgNDcsIDE4NywgOTMsIDE4NSwgMjMsIDE4MywgOTEsIDE4MSwgNDUsIDE3OSwgODksIDE3NywgMTEsIDE3NSwgODcsIDE3MywgMzQ1LCAzNDMsIDM0MSwgMzM5LCAzMzcsIDIxLCAxNjcsIDgzLCAzMzEsIDMyOSwgMzI3LCAxNjMsIDgxLCAzMjMsIDMyMSwgMzE5LCAxNTksIDc5LCAzMTUsIDMxMywgMzksIDE1NSwgMzA5LCAzMDcsIDE1MywgMzA1LCAzMDMsIDE1MSwgNzUsIDI5OSwgMTQ5LCAzNywgMjk1LCAxNDcsIDczLCAyOTEsIDE0NSwgMjg5LCAyODcsIDE0MywgMjg1LCA3MSwgMTQxLCAyODEsIDM1LCAyNzksIDEzOSwgNjksIDI3NSwgMTM3LCAyNzMsIDE3LCAyNzEsIDEzNSwgMjY5LCAyNjcsIDEzMywgMjY1LCAzMywgMjYzLCAxMzEsIDI2MSwgMTMwLCAyNTksIDEyOSwgMjU3LCAxXTtcblxuXHQvKipcblx0ICogQXJyYXkgb2Ygc2hpZnQgdmFsdWVzIGZvciBibHVyIGNhbGN1bGF0aW9ucy5cblx0ICogQHByb3BlcnR5IFNIR19UQUJMRVxuXHQgKiBAdHlwZSBBcnJheVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRCbHVyRmlsdGVyLlNIR19UQUJMRSA9IFswLCA5LCAxMCwgMTEsIDksIDEyLCAxMCwgMTEsIDEyLCA5LCAxMywgMTMsIDEwLCA5LCAxMywgMTMsIDE0LCAxNCwgMTQsIDE0LCAxMCwgMTMsIDE0LCAxNCwgMTQsIDEzLCAxMywgMTMsIDksIDE0LCAxNCwgMTQsIDE1LCAxNCwgMTUsIDE0LCAxNSwgMTUsIDE0LCAxNSwgMTUsIDE1LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTIsIDE0LCAxNSwgMTUsIDEzLCAxNSwgMTUsIDE1LCAxNSwgMTYsIDE2LCAxNiwgMTUsIDE2LCAxNCwgMTYsIDE2LCAxNCwgMTYsIDEzLCAxNiwgMTYsIDE2LCAxNSwgMTYsIDEzLCAxNiwgMTUsIDE2LCAxNCwgOSwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTMsIDE0LCAxNiwgMTYsIDE1LCAxNiwgMTYsIDEwLCAxNiwgMTUsIDE2LCAxNCwgMTYsIDE2LCAxNCwgMTYsIDE2LCAxNCwgMTYsIDE2LCAxNCwgMTUsIDE2LCAxNiwgMTYsIDE0LCAxNSwgMTQsIDE1LCAxMywgMTYsIDE2LCAxNSwgMTcsIDE3LCAxNywgMTcsIDE3LCAxNywgMTQsIDE1LCAxNywgMTcsIDE2LCAxNiwgMTcsIDE2LCAxNSwgMTcsIDE2LCAxNywgMTEsIDE3LCAxNiwgMTcsIDE2LCAxNywgMTYsIDE3LCAxNywgMTYsIDE3LCAxNywgMTYsIDE3LCAxNywgMTYsIDE2LCAxNywgMTcsIDE3LCAxNiwgMTQsIDE3LCAxNywgMTcsIDE3LCAxNSwgMTYsIDE0LCAxNiwgMTUsIDE2LCAxMywgMTYsIDE1LCAxNiwgMTQsIDE2LCAxNSwgMTYsIDEyLCAxNiwgMTUsIDE2LCAxNywgMTcsIDE3LCAxNywgMTcsIDEzLCAxNiwgMTUsIDE3LCAxNywgMTcsIDE2LCAxNSwgMTcsIDE3LCAxNywgMTYsIDE1LCAxNywgMTcsIDE0LCAxNiwgMTcsIDE3LCAxNiwgMTcsIDE3LCAxNiwgMTUsIDE3LCAxNiwgMTQsIDE3LCAxNiwgMTUsIDE3LCAxNiwgMTcsIDE3LCAxNiwgMTcsIDE1LCAxNiwgMTcsIDE0LCAxNywgMTYsIDE1LCAxNywgMTYsIDE3LCAxMywgMTcsIDE2LCAxNywgMTcsIDE2LCAxNywgMTQsIDE3LCAxNiwgMTcsIDE2LCAxNywgMTYsIDE3LCA5XTtcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKHJlY3QpIHtcblx0XHR2YXIgeCA9IHRoaXMuYmx1clh8MCwgeSA9IHRoaXMuYmx1cll8IDA7XG5cdFx0aWYgKHggPD0gMCAmJiB5IDw9IDApIHsgcmV0dXJuIHJlY3Q7IH1cblx0XHR2YXIgcSA9IE1hdGgucG93KHRoaXMucXVhbGl0eSwgMC4yKTtcblx0XHRyZXR1cm4gKHJlY3QgfHwgbmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSgpKS5wYWQoeCpxKzEseSpxKzEseCpxKzEseSpxKzEpO1xuXHR9O1xuXG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEJsdXJGaWx0ZXIodGhpcy5ibHVyWCwgdGhpcy5ibHVyWSwgdGhpcy5xdWFsaXR5KTtcblx0fTtcblxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0JsdXJGaWx0ZXJdXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuX2FwcGx5RmlsdGVyID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xuXG5cdFx0dmFyIHJhZGl1c1ggPSB0aGlzLmJsdXJYID4+IDE7XG5cdFx0aWYgKGlzTmFOKHJhZGl1c1gpIHx8IHJhZGl1c1ggPCAwKSByZXR1cm4gZmFsc2U7XG5cdFx0dmFyIHJhZGl1c1kgPSB0aGlzLmJsdXJZID4+IDE7XG5cdFx0aWYgKGlzTmFOKHJhZGl1c1kpIHx8IHJhZGl1c1kgPCAwKSByZXR1cm4gZmFsc2U7XG5cdFx0aWYgKHJhZGl1c1ggPT0gMCAmJiByYWRpdXNZID09IDApIHJldHVybiBmYWxzZTtcblxuXHRcdHZhciBpdGVyYXRpb25zID0gdGhpcy5xdWFsaXR5O1xuXHRcdGlmIChpc05hTihpdGVyYXRpb25zKSB8fCBpdGVyYXRpb25zIDwgMSkgaXRlcmF0aW9ucyA9IDE7XG5cdFx0aXRlcmF0aW9ucyB8PSAwO1xuXHRcdGlmIChpdGVyYXRpb25zID4gMykgaXRlcmF0aW9ucyA9IDM7XG5cdFx0aWYgKGl0ZXJhdGlvbnMgPCAxKSBpdGVyYXRpb25zID0gMTtcblxuXHRcdHZhciBweCA9IGltYWdlRGF0YS5kYXRhO1xuXHRcdHZhciB4PTAsIHk9MCwgaT0wLCBwPTAsIHlwPTAsIHlpPTAsIHl3PTAsIHI9MCwgZz0wLCBiPTAsIGE9MCwgcHI9MCwgcGc9MCwgcGI9MCwgcGE9MDtcblxuXHRcdHZhciBkaXZ4ID0gKHJhZGl1c1ggKyByYWRpdXNYICsgMSkgfCAwO1xuXHRcdHZhciBkaXZ5ID0gKHJhZGl1c1kgKyByYWRpdXNZICsgMSkgfCAwO1xuXHRcdHZhciB3ID0gaW1hZ2VEYXRhLndpZHRoIHwgMDtcblx0XHR2YXIgaCA9IGltYWdlRGF0YS5oZWlnaHQgfCAwO1xuXG5cdFx0dmFyIHcxID0gKHcgLSAxKSB8IDA7XG5cdFx0dmFyIGgxID0gKGggLSAxKSB8IDA7XG5cdFx0dmFyIHJ4cDEgPSAocmFkaXVzWCArIDEpIHwgMDtcblx0XHR2YXIgcnlwMSA9IChyYWRpdXNZICsgMSkgfCAwO1xuXG5cdFx0dmFyIHNzeCA9IHtyOjAsYjowLGc6MCxhOjB9O1xuXHRcdHZhciBzeCA9IHNzeDtcblx0XHRmb3IgKCBpID0gMTsgaSA8IGRpdng7IGkrKyApXG5cdFx0e1xuXHRcdFx0c3ggPSBzeC5uID0ge3I6MCxiOjAsZzowLGE6MH07XG5cdFx0fVxuXHRcdHN4Lm4gPSBzc3g7XG5cblx0XHR2YXIgc3N5ID0ge3I6MCxiOjAsZzowLGE6MH07XG5cdFx0dmFyIHN5ID0gc3N5O1xuXHRcdGZvciAoIGkgPSAxOyBpIDwgZGl2eTsgaSsrIClcblx0XHR7XG5cdFx0XHRzeSA9IHN5Lm4gPSB7cjowLGI6MCxnOjAsYTowfTtcblx0XHR9XG5cdFx0c3kubiA9IHNzeTtcblxuXHRcdHZhciBzaSA9IG51bGw7XG5cblxuXHRcdHZhciBtdHggPSBCbHVyRmlsdGVyLk1VTF9UQUJMRVtyYWRpdXNYXSB8IDA7XG5cdFx0dmFyIHN0eCA9IEJsdXJGaWx0ZXIuU0hHX1RBQkxFW3JhZGl1c1hdIHwgMDtcblx0XHR2YXIgbXR5ID0gQmx1ckZpbHRlci5NVUxfVEFCTEVbcmFkaXVzWV0gfCAwO1xuXHRcdHZhciBzdHkgPSBCbHVyRmlsdGVyLlNIR19UQUJMRVtyYWRpdXNZXSB8IDA7XG5cblx0XHR3aGlsZSAoaXRlcmF0aW9ucy0tID4gMCkge1xuXG5cdFx0XHR5dyA9IHlpID0gMDtcblx0XHRcdHZhciBtcyA9IG10eDtcblx0XHRcdHZhciBzcyA9IHN0eDtcblx0XHRcdGZvciAoeSA9IGg7IC0teSA+IC0xOykge1xuXHRcdFx0XHRyID0gcnhwMSAqIChwciA9IHB4Wyh5aSkgfCAwXSk7XG5cdFx0XHRcdGcgPSByeHAxICogKHBnID0gcHhbKHlpICsgMSkgfCAwXSk7XG5cdFx0XHRcdGIgPSByeHAxICogKHBiID0gcHhbKHlpICsgMikgfCAwXSk7XG5cdFx0XHRcdGEgPSByeHAxICogKHBhID0gcHhbKHlpICsgMykgfCAwXSk7XG5cblx0XHRcdFx0c3ggPSBzc3g7XG5cblx0XHRcdFx0Zm9yKCBpID0gcnhwMTsgLS1pID4gLTE7IClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHN4LnIgPSBwcjtcblx0XHRcdFx0XHRzeC5nID0gcGc7XG5cdFx0XHRcdFx0c3guYiA9IHBiO1xuXHRcdFx0XHRcdHN4LmEgPSBwYTtcblx0XHRcdFx0XHRzeCA9IHN4Lm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IoIGkgPSAxOyBpIDwgcnhwMTsgaSsrIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHAgPSAoeWkgKyAoKHcxIDwgaSA/IHcxIDogaSkgPDwgMikpIHwgMDtcblx0XHRcdFx0XHRyICs9ICggc3guciA9IHB4W3BdKTtcblx0XHRcdFx0XHRnICs9ICggc3guZyA9IHB4W3ArMV0pO1xuXHRcdFx0XHRcdGIgKz0gKCBzeC5iID0gcHhbcCsyXSk7XG5cdFx0XHRcdFx0YSArPSAoIHN4LmEgPSBweFtwKzNdKTtcblxuXHRcdFx0XHRcdHN4ID0gc3gubjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNpID0gc3N4O1xuXHRcdFx0XHRmb3IgKCB4ID0gMDsgeCA8IHc7IHgrKyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRweFt5aSsrXSA9IChyICogbXMpID4+PiBzcztcblx0XHRcdFx0XHRweFt5aSsrXSA9IChnICogbXMpID4+PiBzcztcblx0XHRcdFx0XHRweFt5aSsrXSA9IChiICogbXMpID4+PiBzcztcblx0XHRcdFx0XHRweFt5aSsrXSA9IChhICogbXMpID4+PiBzcztcblxuXHRcdFx0XHRcdHAgPSAoKHl3ICsgKChwID0geCArIHJhZGl1c1ggKyAxKSA8IHcxID8gcCA6IHcxKSkgPDwgMik7XG5cblx0XHRcdFx0XHRyIC09IHNpLnIgLSAoIHNpLnIgPSBweFtwXSk7XG5cdFx0XHRcdFx0ZyAtPSBzaS5nIC0gKCBzaS5nID0gcHhbcCsxXSk7XG5cdFx0XHRcdFx0YiAtPSBzaS5iIC0gKCBzaS5iID0gcHhbcCsyXSk7XG5cdFx0XHRcdFx0YSAtPSBzaS5hIC0gKCBzaS5hID0gcHhbcCszXSk7XG5cblx0XHRcdFx0XHRzaSA9IHNpLm47XG5cblx0XHRcdFx0fVxuXHRcdFx0XHR5dyArPSB3O1xuXHRcdFx0fVxuXG5cdFx0XHRtcyA9IG10eTtcblx0XHRcdHNzID0gc3R5O1xuXHRcdFx0Zm9yICh4ID0gMDsgeCA8IHc7IHgrKykge1xuXHRcdFx0XHR5aSA9ICh4IDw8IDIpIHwgMDtcblxuXHRcdFx0XHRyID0gKHJ5cDEgKiAocHIgPSBweFt5aV0pKSB8IDA7XG5cdFx0XHRcdGcgPSAocnlwMSAqIChwZyA9IHB4Wyh5aSArIDEpIHwgMF0pKSB8IDA7XG5cdFx0XHRcdGIgPSAocnlwMSAqIChwYiA9IHB4Wyh5aSArIDIpIHwgMF0pKSB8IDA7XG5cdFx0XHRcdGEgPSAocnlwMSAqIChwYSA9IHB4Wyh5aSArIDMpIHwgMF0pKSB8IDA7XG5cblx0XHRcdFx0c3kgPSBzc3k7XG5cdFx0XHRcdGZvciggaSA9IDA7IGkgPCByeXAxOyBpKysgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c3kuciA9IHByO1xuXHRcdFx0XHRcdHN5LmcgPSBwZztcblx0XHRcdFx0XHRzeS5iID0gcGI7XG5cdFx0XHRcdFx0c3kuYSA9IHBhO1xuXHRcdFx0XHRcdHN5ID0gc3kubjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHlwID0gdztcblxuXHRcdFx0XHRmb3IoIGkgPSAxOyBpIDw9IHJhZGl1c1k7IGkrKyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR5aSA9ICggeXAgKyB4ICkgPDwgMjtcblxuXHRcdFx0XHRcdHIgKz0gKCBzeS5yID0gcHhbeWldKTtcblx0XHRcdFx0XHRnICs9ICggc3kuZyA9IHB4W3lpKzFdKTtcblx0XHRcdFx0XHRiICs9ICggc3kuYiA9IHB4W3lpKzJdKTtcblx0XHRcdFx0XHRhICs9ICggc3kuYSA9IHB4W3lpKzNdKTtcblxuXHRcdFx0XHRcdHN5ID0gc3kubjtcblxuXHRcdFx0XHRcdGlmKCBpIDwgaDEgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHlwICs9IHc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0eWkgPSB4O1xuXHRcdFx0XHRzaSA9IHNzeTtcblx0XHRcdFx0aWYgKCBpdGVyYXRpb25zID4gMCApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmb3IgKCB5ID0gMDsgeSA8IGg7IHkrKyApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cCA9IHlpIDw8IDI7XG5cdFx0XHRcdFx0XHRweFtwKzNdID0gcGEgPShhICogbXMpID4+PiBzcztcblx0XHRcdFx0XHRcdGlmICggcGEgPiAwIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0cHhbcF0gICA9ICgociAqIG1zKSA+Pj4gc3MgKTtcblx0XHRcdFx0XHRcdFx0cHhbcCsxXSA9ICgoZyAqIG1zKSA+Pj4gc3MgKTtcblx0XHRcdFx0XHRcdFx0cHhbcCsyXSA9ICgoYiAqIG1zKSA+Pj4gc3MgKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHB4W3BdID0gcHhbcCsxXSA9IHB4W3ArMl0gPSAwXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHAgPSAoIHggKyAoKCAoIHAgPSB5ICsgcnlwMSkgPCBoMSA/IHAgOiBoMSApICogdyApKSA8PCAyO1xuXG5cdFx0XHRcdFx0XHRyIC09IHNpLnIgLSAoIHNpLnIgPSBweFtwXSk7XG5cdFx0XHRcdFx0XHRnIC09IHNpLmcgLSAoIHNpLmcgPSBweFtwKzFdKTtcblx0XHRcdFx0XHRcdGIgLT0gc2kuYiAtICggc2kuYiA9IHB4W3ArMl0pO1xuXHRcdFx0XHRcdFx0YSAtPSBzaS5hIC0gKCBzaS5hID0gcHhbcCszXSk7XG5cblx0XHRcdFx0XHRcdHNpID0gc2kubjtcblxuXHRcdFx0XHRcdFx0eWkgKz0gdztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Zm9yICggeSA9IDA7IHkgPCBoOyB5KysgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHAgPSB5aSA8PCAyO1xuXHRcdFx0XHRcdFx0cHhbcCszXSA9IHBhID0oYSAqIG1zKSA+Pj4gc3M7XG5cdFx0XHRcdFx0XHRpZiAoIHBhID4gMCApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHBhID0gMjU1IC8gcGE7XG5cdFx0XHRcdFx0XHRcdHB4W3BdICAgPSAoKHIgKiBtcykgPj4+IHNzICkgKiBwYTtcblx0XHRcdFx0XHRcdFx0cHhbcCsxXSA9ICgoZyAqIG1zKSA+Pj4gc3MgKSAqIHBhO1xuXHRcdFx0XHRcdFx0XHRweFtwKzJdID0gKChiICogbXMpID4+PiBzcyApICogcGE7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRweFtwXSA9IHB4W3ArMV0gPSBweFtwKzJdID0gMFxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRwID0gKCB4ICsgKCggKCBwID0geSArIHJ5cDEpIDwgaDEgPyBwIDogaDEgKSAqIHcgKSkgPDwgMjtcblxuXHRcdFx0XHRcdFx0ciAtPSBzaS5yIC0gKCBzaS5yID0gcHhbcF0pO1xuXHRcdFx0XHRcdFx0ZyAtPSBzaS5nIC0gKCBzaS5nID0gcHhbcCsxXSk7XG5cdFx0XHRcdFx0XHRiIC09IHNpLmIgLSAoIHNpLmIgPSBweFtwKzJdKTtcblx0XHRcdFx0XHRcdGEgLT0gc2kuYSAtICggc2kuYSA9IHB4W3ArM10pO1xuXG5cdFx0XHRcdFx0XHRzaSA9IHNpLm47XG5cblx0XHRcdFx0XHRcdHlpICs9IHc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0Y3JlYXRlanMuQmx1ckZpbHRlciA9IGNyZWF0ZWpzLnByb21vdGUoQmx1ckZpbHRlciwgXCJGaWx0ZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQWxwaGFNYXBGaWx0ZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRcblx0XG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEFwcGxpZXMgYSBncmV5c2NhbGUgYWxwaGEgbWFwIGltYWdlIChvciBjYW52YXMpIHRvIHRoZSB0YXJnZXQsIHN1Y2ggdGhhdCB0aGUgYWxwaGEgY2hhbm5lbCBvZiB0aGUgcmVzdWx0IHdpbGxcblx0ICogYmUgY29waWVkIGZyb20gdGhlIHJlZCBjaGFubmVsIG9mIHRoZSBtYXAsIGFuZCB0aGUgUkdCIGNoYW5uZWxzIHdpbGwgYmUgY29waWVkIGZyb20gdGhlIHRhcmdldC5cblx0ICpcblx0ICogR2VuZXJhbGx5LCBpdCBpcyByZWNvbW1lbmRlZCB0aGF0IHlvdSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWxwaGFNYXNrRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319LCBiZWNhdXNlIGl0IGhhcyBtdWNoXG5cdCAqIGJldHRlciBwZXJmb3JtYW5jZS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBUaGlzIGV4YW1wbGUgZHJhd3MgYSByZWQtPmJsdWUgYm94LCBjYWNoZXMgaXQsIGFuZCB0aGVuIHVzZXMgdGhlIGNhY2hlIGNhbnZhcyBhcyBhbiBhbHBoYSBtYXAgb24gYSAxMDB4MTAwIGltYWdlLlxuXHQgKlxuXHQgKiAgICAgICB2YXIgYm94ID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG5cdCAqICAgICAgIGJveC5ncmFwaGljcy5iZWdpbkxpbmVhckdyYWRpZW50RmlsbChbXCIjZmYwMDAwXCIsIFwiIzAwMDBmZlwiXSwgWzAsIDFdLCAwLCAwLCAwLCAxMDApXG5cdCAqICAgICAgIGJveC5ncmFwaGljcy5kcmF3UmVjdCgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqICAgICAgIGJveC5jYWNoZSgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqXG5cdCAqICAgICAgIHZhciBibXAgPSBuZXcgY3JlYXRlanMuQml0bWFwKFwicGF0aC90by9pbWFnZS5qcGdcIik7XG5cdCAqICAgICAgIGJtcC5maWx0ZXJzID0gW1xuXHQgKiAgICAgICAgICAgbmV3IGNyZWF0ZWpzLkFscGhhTWFwRmlsdGVyKGJveC5jYWNoZUNhbnZhcylcblx0ICogICAgICAgXTtcblx0ICogICAgICAgYm1wLmNhY2hlKDAsIDAsIDEwMCwgMTAwKTtcblx0ICogICAgICAgc3RhZ2UuYWRkQ2hpbGQoYm1wKTtcblx0ICpcblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkZpbHRlclwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBhcHBseWluZyBmaWx0ZXJzLlxuXHQgKiBAY2xhc3MgQWxwaGFNYXBGaWx0ZXJcblx0ICogQGV4dGVuZHMgRmlsdGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IGFscGhhTWFwIFRoZSBncmV5c2NhbGUgaW1hZ2UgKG9yIGNhbnZhcykgdG8gdXNlIGFzIHRoZSBhbHBoYSB2YWx1ZSBmb3IgdGhlXG5cdCAqIHJlc3VsdC4gVGhpcyBzaG91bGQgYmUgZXhhY3RseSB0aGUgc2FtZSBkaW1lbnNpb25zIGFzIHRoZSB0YXJnZXQuXG5cdCAqKi9cblx0ZnVuY3Rpb24gQWxwaGFNYXBGaWx0ZXIoYWxwaGFNYXApIHtcblx0XG5cdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgZ3JleXNjYWxlIGltYWdlIChvciBjYW52YXMpIHRvIHVzZSBhcyB0aGUgYWxwaGEgdmFsdWUgZm9yIHRoZSByZXN1bHQuIFRoaXMgc2hvdWxkIGJlIGV4YWN0bHkgdGhlIHNhbWVcblx0XHQgKiBkaW1lbnNpb25zIGFzIHRoZSB0YXJnZXQuXG5cdFx0ICogQHByb3BlcnR5IGFscGhhTWFwXG5cdFx0ICogQHR5cGUgSFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudFxuXHRcdCAqKi9cblx0XHR0aGlzLmFscGhhTWFwID0gYWxwaGFNYXA7XG5cdFx0XG5cdFx0XG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2FscGhhTWFwXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnRcblx0XHQgKiovXG5cdFx0dGhpcy5fYWxwaGFNYXAgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbWFwRGF0YVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBVaW50OENsYW1wZWRBcnJheVxuXHRcdCAqKi9cblx0XHR0aGlzLl9tYXBEYXRhID0gbnVsbDtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChBbHBoYU1hcEZpbHRlciwgY3JlYXRlanMuRmlsdGVyKTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbyA9IG5ldyBBbHBoYU1hcEZpbHRlcih0aGlzLmFscGhhTWFwKTtcblx0XHRvLl9hbHBoYU1hcCA9IHRoaXMuX2FscGhhTWFwO1xuXHRcdG8uX21hcERhdGEgPSB0aGlzLl9tYXBEYXRhO1xuXHRcdHJldHVybiBvO1xuXHR9O1xuXG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFwiW0FscGhhTWFwRmlsdGVyXVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5fYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG5cdFx0aWYgKCF0aGlzLmFscGhhTWFwKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0aWYgKCF0aGlzLl9wcmVwQWxwaGFNYXAoKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcblx0XHQvLyBUT0RPOiB1cGRhdGUgdG8gc3VwcG9ydCBzY2VuYXJpb3Mgd2hlcmUgdGhlIHRhcmdldCBoYXMgZGlmZmVyZW50IGRpbWVuc2lvbnMuXG5cdFx0dmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwRGF0YTtcblx0XHRmb3IodmFyIGk9MCwgbD1kYXRhLmxlbmd0aDsgaTxsOyBpICs9IDQpIHsgZGF0YVtpICsgM10gPSBtYXBbaV0gfHwgMDsgfVxuXHRcdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9wcmVwQWxwaGFNYXBcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3ByZXBBbHBoYU1hcCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuYWxwaGFNYXApIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKHRoaXMuYWxwaGFNYXAgPT0gdGhpcy5fYWxwaGFNYXAgJiYgdGhpcy5fbWFwRGF0YSkgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0dGhpcy5fbWFwRGF0YSA9IG51bGw7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX2FscGhhTWFwID0gdGhpcy5hbHBoYU1hcDtcblx0XHR2YXIgY2FudmFzID0gbWFwO1xuXHRcdHZhciBjdHg7XG5cdFx0aWYgKG1hcCBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG5cdFx0XHRjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYW52YXMgPSBjcmVhdGVqcy5jcmVhdGVDYW52YXMgPyBjcmVhdGVqcy5jcmVhdGVDYW52YXMoKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cdFx0XHRjYW52YXMud2lkdGggPSBtYXAud2lkdGg7XG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gbWFwLmhlaWdodDtcblx0XHRcdGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0XHRjdHguZHJhd0ltYWdlKG1hcCwgMCwgMCk7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciBpbWdEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBtYXAud2lkdGgsIG1hcC5oZWlnaHQpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vaWYgKCF0aGlzLnN1cHByZXNzQ3Jvc3NEb21haW5FcnJvcnMpIHRocm93IG5ldyBFcnJvcihcInVuYWJsZSB0byBhY2Nlc3MgbG9jYWwgaW1hZ2UgZGF0YTogXCIgKyBlKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5fbWFwRGF0YSA9IGltZ0RhdGEuZGF0YTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLkFscGhhTWFwRmlsdGVyID0gY3JlYXRlanMucHJvbW90ZShBbHBoYU1hcEZpbHRlciwgXCJGaWx0ZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQWxwaGFNYXNrRmlsdGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEFwcGxpZXMgdGhlIGFscGhhIGZyb20gdGhlIG1hc2sgaW1hZ2UgKG9yIGNhbnZhcykgdG8gdGhlIHRhcmdldCwgc3VjaCB0aGF0IHRoZSBhbHBoYSBjaGFubmVsIG9mIHRoZSByZXN1bHQgd2lsbFxuXHQgKiBiZSBkZXJpdmVkIGZyb20gdGhlIG1hc2ssIGFuZCB0aGUgUkdCIGNoYW5uZWxzIHdpbGwgYmUgY29waWVkIGZyb20gdGhlIHRhcmdldC4gVGhpcyBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIHRvXG5cdCAqIGFwcGx5IGFuIGFscGhhIG1hc2sgdG8gYSBkaXNwbGF5IG9iamVjdC4gVGhpcyBjYW4gYWxzbyBiZSB1c2VkIHRvIGNvbWJpbmUgYSBKUEcgY29tcHJlc3NlZCBSR0IgaW1hZ2Ugd2l0aCBhIFBORzMyXG5cdCAqIGFscGhhIG1hc2ssIHdoaWNoIGNhbiByZXN1bHQgaW4gYSBtdWNoIHNtYWxsZXIgZmlsZSBzaXplIHRoYW4gYSBzaW5nbGUgUE5HMzIgY29udGFpbmluZyBBUkdCLlxuXHQgKlxuXHQgKiA8Yj5JTVBPUlRBTlQgTk9URTogVGhpcyBmaWx0ZXIgY3VycmVudGx5IGRvZXMgbm90IHN1cHBvcnQgdGhlIHRhcmdldEN0eCwgb3IgdGFyZ2V0WC9ZIHBhcmFtZXRlcnMgY29ycmVjdGx5LjwvYj5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBUaGlzIGV4YW1wbGUgZHJhd3MgYSBncmFkaWVudCBib3gsIHRoZW4gY2FjaGVzIGl0IGFuZCB1c2VzIHRoZSBcImNhY2hlQ2FudmFzXCIgYXMgdGhlIGFscGhhIG1hc2sgb24gYSAxMDB4MTAwIGltYWdlLlxuXHQgKlxuXHQgKiAgICAgIHZhciBib3ggPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcblx0ICogICAgICBib3guZ3JhcGhpY3MuYmVnaW5MaW5lYXJHcmFkaWVudEZpbGwoW1wiIzAwMDAwMFwiLCBcInJnYmEoMCwgMCwgMCwgMClcIl0sIFswLCAxXSwgMCwgMCwgMTAwLCAxMDApXG5cdCAqICAgICAgYm94LmdyYXBoaWNzLmRyYXdSZWN0KDAsIDAsIDEwMCwgMTAwKTtcblx0ICogICAgICBib3guY2FjaGUoMCwgMCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiAgICAgIHZhciBibXAgPSBuZXcgY3JlYXRlanMuQml0bWFwKFwicGF0aC90by9pbWFnZS5qcGdcIik7XG5cdCAqICAgICAgYm1wLmZpbHRlcnMgPSBbXG5cdCAqICAgICAgICAgIG5ldyBjcmVhdGVqcy5BbHBoYU1hc2tGaWx0ZXIoYm94LmNhY2hlQ2FudmFzKVxuXHQgKiAgICAgIF07XG5cdCAqICAgICAgYm1wLmNhY2hlKDAsIDAsIDEwMCwgMTAwKTtcblx0ICpcblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkZpbHRlclwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBhcHBseWluZyBmaWx0ZXJzLlxuXHQgKiBAY2xhc3MgQWxwaGFNYXNrRmlsdGVyXG5cdCAqIEBleHRlbmRzIEZpbHRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBtYXNrXG5cdCAqKi9cblx0ZnVuY3Rpb24gQWxwaGFNYXNrRmlsdGVyKG1hc2spIHtcblx0XG5cdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgaW1hZ2UgKG9yIGNhbnZhcykgdG8gdXNlIGFzIHRoZSBtYXNrLlxuXHRcdCAqIEBwcm9wZXJ0eSBtYXNrXG5cdFx0ICogQHR5cGUgSFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudFxuXHRcdCAqKi9cblx0XHR0aGlzLm1hc2sgPSBtYXNrO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEFscGhhTWFza0ZpbHRlciwgY3JlYXRlanMuRmlsdGVyKTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblx0XG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogQXBwbGllcyB0aGUgZmlsdGVyIHRvIHRoZSBzcGVjaWZpZWQgY29udGV4dC5cblx0ICpcblx0ICogPHN0cm9uZz5JTVBPUlRBTlQgTk9URTogVGhpcyBmaWx0ZXIgY3VycmVudGx5IGRvZXMgbm90IHN1cHBvcnQgdGhlIHRhcmdldEN0eCwgb3IgdGFyZ2V0WC9ZIHBhcmFtZXRlcnNcblx0ICogY29ycmVjdGx5Ljwvc3Ryb25nPlxuXHQgKiBAbWV0aG9kIGFwcGx5RmlsdGVyXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIDJEIGNvbnRleHQgdG8gdXNlIGFzIHRoZSBzb3VyY2UuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIHRvIHVzZSBmb3IgdGhlIHNvdXJjZSByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiB0byB1c2UgZm9yIHRoZSBzb3VyY2UgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCB0byB1c2UgZm9yIHRoZSBzb3VyY2UgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IHRvIHVzZSBmb3IgdGhlIHNvdXJjZSByZWN0LlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gW3RhcmdldEN0eF0gTk9UIFNVUFBPUlRFRCBJTiBUSElTIEZJTFRFUi4gVGhlIDJEIGNvbnRleHQgdG8gZHJhdyB0aGUgcmVzdWx0IHRvLiBEZWZhdWx0cyB0byB0aGUgY29udGV4dCBwYXNzZWQgdG8gY3R4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RhcmdldFhdIE5PVCBTVVBQT1JURUQgSU4gVEhJUyBGSUxURVIuIFRoZSB4IHBvc2l0aW9uIHRvIGRyYXcgdGhlIHJlc3VsdCB0by4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIHBhc3NlZCB0byB4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RhcmdldFldIE5PVCBTVVBQT1JURUQgSU4gVEhJUyBGSUxURVIuIFRoZSB5IHBvc2l0aW9uIHRvIGRyYXcgdGhlIHJlc3VsdCB0by4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIHBhc3NlZCB0byB5LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgZmlsdGVyIHdhcyBhcHBsaWVkIHN1Y2Nlc3NmdWxseS5cblx0ICoqL1xuXHRwLmFwcGx5RmlsdGVyID0gZnVuY3Rpb24gKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgdGFyZ2V0Q3R4LCB0YXJnZXRYLCB0YXJnZXRZKSB7XG5cdFx0aWYgKCF0aGlzLm1hc2spIHsgcmV0dXJuIHRydWU7IH1cblx0XHR0YXJnZXRDdHggPSB0YXJnZXRDdHggfHwgY3R4O1xuXHRcdGlmICh0YXJnZXRYID09IG51bGwpIHsgdGFyZ2V0WCA9IHg7IH1cblx0XHRpZiAodGFyZ2V0WSA9PSBudWxsKSB7IHRhcmdldFkgPSB5OyB9XG5cblx0XHR0YXJnZXRDdHguc2F2ZSgpO1xuXHRcdGlmIChjdHggIT0gdGFyZ2V0Q3R4KSB7XG5cdFx0XHQvLyBUT0RPOiBzdXBwb3J0IHRhcmdldEN0eCBhbmQgdGFyZ2V0WC9ZXG5cdFx0XHQvLyBjbGVhclJlY3QsIHRoZW4gZHJhdyB0aGUgY3R4IGluP1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRhcmdldEN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLWluXCI7XG5cdFx0dGFyZ2V0Q3R4LmRyYXdJbWFnZSh0aGlzLm1hc2ssIHRhcmdldFgsIHRhcmdldFkpO1xuXHRcdHRhcmdldEN0eC5yZXN0b3JlKCk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbmV3IEFscGhhTWFza0ZpbHRlcih0aGlzLm1hc2spO1xuXHR9O1xuXG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFwiW0FscGhhTWFza0ZpbHRlcl1cIjtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLkFscGhhTWFza0ZpbHRlciA9IGNyZWF0ZWpzLnByb21vdGUoQWxwaGFNYXNrRmlsdGVyLCBcIkZpbHRlclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBDb2xvckZpbHRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEFwcGxpZXMgYSBjb2xvciB0cmFuc2Zvcm0gdG8gRGlzcGxheU9iamVjdHMuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogVGhpcyBleGFtcGxlIGRyYXdzIGEgcmVkIGNpcmNsZSwgYW5kIHRoZW4gdHJhbnNmb3JtcyBpdCB0byBCbHVlLiBUaGlzIGlzIGFjY29tcGxpc2hlZCBieSBtdWx0aXBseWluZyBhbGwgdGhlIGNoYW5uZWxzXG5cdCAqIHRvIDAgKGV4Y2VwdCBhbHBoYSwgd2hpY2ggaXMgc2V0IHRvIDEpLCBhbmQgdGhlbiBhZGRpbmcgMjU1IHRvIHRoZSBibHVlIGNoYW5uZWwuXG5cdCAqXG5cdCAqICAgICAgdmFyIHNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCkuc2V0KHt4OjEwMCx5OjEwMH0pO1xuXHQgKiAgICAgIHNoYXBlLmdyYXBoaWNzLmJlZ2luRmlsbChcIiNmZjAwMDBcIikuZHJhd0NpcmNsZSgwLDAsNTApO1xuXHQgKlxuXHQgKiAgICAgIHNoYXBlLmZpbHRlcnMgPSBbXG5cdCAqICAgICAgICAgIG5ldyBjcmVhdGVqcy5Db2xvckZpbHRlcigwLDAsMCwxLCAwLDAsMjU1LDApXG5cdCAqICAgICAgXTtcblx0ICogICAgICBzaGFwZS5jYWNoZSgtNTAsIC01MCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhbiBtb3JlIGluZm9ybWF0aW9uIG9uIGFwcGx5aW5nIGZpbHRlcnMuXG5cdCAqIEBjbGFzcyBDb2xvckZpbHRlclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3JlZE11bHRpcGxpZXI9MV0gVGhlIGFtb3VudCB0byBtdWx0aXBseSBhZ2FpbnN0IHRoZSByZWQgY2hhbm5lbC4gVGhpcyBpcyBhIHJhbmdlIGJldHdlZW4gMCBhbmQgMS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtncmVlbk11bHRpcGxpZXI9MV0gVGhlIGFtb3VudCB0byBtdWx0aXBseSBhZ2FpbnN0IHRoZSBncmVlbiBjaGFubmVsLiBUaGlzIGlzIGEgcmFuZ2UgYmV0d2VlbiAwIGFuZCAxLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2JsdWVNdWx0aXBsaWVyPTFdIFRoZSBhbW91bnQgdG8gbXVsdGlwbHkgYWdhaW5zdCB0aGUgYmx1ZSBjaGFubmVsLiBUaGlzIGlzIGEgcmFuZ2UgYmV0d2VlbiAwIGFuZCAxLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2FscGhhTXVsdGlwbGllcj0xXSBUaGUgYW1vdW50IHRvIG11bHRpcGx5IGFnYWluc3QgdGhlIGFscGhhIGNoYW5uZWwuIFRoaXMgaXMgYSByYW5nZSBiZXR3ZWVuIDAgYW5kIDEuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcmVkT2Zmc2V0PTBdIFRoZSBhbW91bnQgdG8gYWRkIHRvIHRoZSByZWQgY2hhbm5lbCBhZnRlciBpdCBoYXMgYmVlbiBtdWx0aXBsaWVkLiBUaGlzIGlzIGEgcmFuZ2Vcblx0ICogYmV0d2VlbiAtMjU1IGFuZCAyNTUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZ3JlZW5PZmZzZXQ9MF0gVGhlIGFtb3VudCB0byBhZGQgdG8gdGhlIGdyZWVuIGNoYW5uZWwgYWZ0ZXIgaXQgaGFzIGJlZW4gbXVsdGlwbGllZC4gVGhpcyBpcyBhIHJhbmdlXG5cdCAgKiBiZXR3ZWVuIC0yNTUgYW5kIDI1NS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtibHVlT2Zmc2V0PTBdIFRoZSBhbW91bnQgdG8gYWRkIHRvIHRoZSBibHVlIGNoYW5uZWwgYWZ0ZXIgaXQgaGFzIGJlZW4gbXVsdGlwbGllZC4gVGhpcyBpcyBhIHJhbmdlXG5cdCAgKiBiZXR3ZWVuIC0yNTUgYW5kIDI1NS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthbHBoYU9mZnNldD0wXSBUaGUgYW1vdW50IHRvIGFkZCB0byB0aGUgYWxwaGEgY2hhbm5lbCBhZnRlciBpdCBoYXMgYmVlbiBtdWx0aXBsaWVkLiBUaGlzIGlzIGEgcmFuZ2Vcblx0ICAqIGJldHdlZW4gLTI1NSBhbmQgMjU1LlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQGV4dGVuZHMgRmlsdGVyXG5cdCAqKi9cblx0ZnVuY3Rpb24gQ29sb3JGaWx0ZXIocmVkTXVsdGlwbGllciwgZ3JlZW5NdWx0aXBsaWVyLCBibHVlTXVsdGlwbGllciwgYWxwaGFNdWx0aXBsaWVyLCByZWRPZmZzZXQsIGdyZWVuT2Zmc2V0LCBibHVlT2Zmc2V0LCBhbHBoYU9mZnNldCkge1xuXHRcdFxuXHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogUmVkIGNoYW5uZWwgbXVsdGlwbGllci5cblx0XHQgKiBAcHJvcGVydHkgcmVkTXVsdGlwbGllclxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLnJlZE11bHRpcGxpZXIgPSByZWRNdWx0aXBsaWVyICE9IG51bGwgPyByZWRNdWx0aXBsaWVyIDogMTtcblx0XG5cdFx0LyoqXG5cdFx0ICogR3JlZW4gY2hhbm5lbCBtdWx0aXBsaWVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBncmVlbk11bHRpcGxpZXJcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5ncmVlbk11bHRpcGxpZXIgPSBncmVlbk11bHRpcGxpZXIgIT0gbnVsbCA/IGdyZWVuTXVsdGlwbGllciA6IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEJsdWUgY2hhbm5lbCBtdWx0aXBsaWVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBibHVlTXVsdGlwbGllclxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLmJsdWVNdWx0aXBsaWVyID0gYmx1ZU11bHRpcGxpZXIgIT0gbnVsbCA/IGJsdWVNdWx0aXBsaWVyIDogMTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQWxwaGEgY2hhbm5lbCBtdWx0aXBsaWVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBhbHBoYU11bHRpcGxpZXJcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5hbHBoYU11bHRpcGxpZXIgPSBhbHBoYU11bHRpcGxpZXIgIT0gbnVsbCA/IGFscGhhTXVsdGlwbGllciA6IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJlZCBjaGFubmVsIG9mZnNldCAoYWRkZWQgdG8gdmFsdWUpLlxuXHRcdCAqIEBwcm9wZXJ0eSByZWRPZmZzZXRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5yZWRPZmZzZXQgPSByZWRPZmZzZXQgfHwgMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogR3JlZW4gY2hhbm5lbCBvZmZzZXQgKGFkZGVkIHRvIHZhbHVlKS5cblx0XHQgKiBAcHJvcGVydHkgZ3JlZW5PZmZzZXRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5ncmVlbk9mZnNldCA9IGdyZWVuT2Zmc2V0IHx8IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEJsdWUgY2hhbm5lbCBvZmZzZXQgKGFkZGVkIHRvIHZhbHVlKS5cblx0XHQgKiBAcHJvcGVydHkgYmx1ZU9mZnNldFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLmJsdWVPZmZzZXQgPSBibHVlT2Zmc2V0IHx8IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFscGhhIGNoYW5uZWwgb2Zmc2V0IChhZGRlZCB0byB2YWx1ZSkuXG5cdFx0ICogQHByb3BlcnR5IGFscGhhT2Zmc2V0XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuYWxwaGFPZmZzZXQgPSBhbHBoYU9mZnNldCB8fCAwO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKENvbG9yRmlsdGVyLCBjcmVhdGVqcy5GaWx0ZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0NvbG9yRmlsdGVyXVwiO1xuXHR9O1xuXG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yRmlsdGVyKHRoaXMucmVkTXVsdGlwbGllciwgdGhpcy5ncmVlbk11bHRpcGxpZXIsIHRoaXMuYmx1ZU11bHRpcGxpZXIsIHRoaXMuYWxwaGFNdWx0aXBsaWVyLCB0aGlzLnJlZE9mZnNldCwgdGhpcy5ncmVlbk9mZnNldCwgdGhpcy5ibHVlT2Zmc2V0LCB0aGlzLmFscGhhT2Zmc2V0KTtcblx0fTtcblx0XG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5fYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcblx0XHR2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuXHRcdHZhciBsID0gZGF0YS5sZW5ndGg7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrPTQpIHtcblx0XHRcdGRhdGFbaV0gPSBkYXRhW2ldKnRoaXMucmVkTXVsdGlwbGllcit0aGlzLnJlZE9mZnNldDtcblx0XHRcdGRhdGFbaSsxXSA9IGRhdGFbaSsxXSp0aGlzLmdyZWVuTXVsdGlwbGllcit0aGlzLmdyZWVuT2Zmc2V0O1xuXHRcdFx0ZGF0YVtpKzJdID0gZGF0YVtpKzJdKnRoaXMuYmx1ZU11bHRpcGxpZXIrdGhpcy5ibHVlT2Zmc2V0O1xuXHRcdFx0ZGF0YVtpKzNdID0gZGF0YVtpKzNdKnRoaXMuYWxwaGFNdWx0aXBsaWVyK3RoaXMuYWxwaGFPZmZzZXQ7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuQ29sb3JGaWx0ZXIgPSBjcmVhdGVqcy5wcm9tb3RlKENvbG9yRmlsdGVyLCBcIkZpbHRlclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBDb2xvck1hdHJpeC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgZm9yIGFzc2VtYmxpbmcgYSBtYXRyaXggZm9yIHVzZSB3aXRoIHRoZSB7eyNjcm9zc0xpbmsgXCJDb2xvck1hdHJpeEZpbHRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogTW9zdCBtZXRob2RzIHJldHVybiB0aGUgaW5zdGFuY2UgdG8gZmFjaWxpdGF0ZSBjaGFpbmVkIGNhbGxzLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgbXlDb2xvck1hdHJpeC5hZGp1c3RIdWUoMjApLmFkanVzdEJyaWdodG5lc3MoNTApO1xuXHQgKlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhbiBleGFtcGxlIG9mIGhvdyB0byBhcHBseSBmaWx0ZXJzLCBvciB7eyNjcm9zc0xpbmsgXCJDb2xvck1hdHJpeEZpbHRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgYW4gZXhhbXBsZSBvZiBob3cgdG8gdXNlIENvbG9yTWF0cml4IHRvIGNoYW5nZSBhIERpc3BsYXlPYmplY3QncyBjb2xvci5cblx0ICogQGNsYXNzIENvbG9yTWF0cml4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBicmlnaHRuZXNzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb250cmFzdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gaHVlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIENvbG9yTWF0cml4KGJyaWdodG5lc3MsIGNvbnRyYXN0LCBzYXR1cmF0aW9uLCBodWUpIHtcblx0XHR0aGlzLnNldENvbG9yKGJyaWdodG5lc3MsIGNvbnRyYXN0LCBzYXR1cmF0aW9uLCBodWUpO1xuXHR9XG5cdHZhciBwID0gQ29sb3JNYXRyaXgucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG4vLyBjb25zdGFudHM6XG5cdC8qKlxuXHQgKiBBcnJheSBvZiBkZWx0YSB2YWx1ZXMgZm9yIGNvbnRyYXN0IGNhbGN1bGF0aW9ucy5cblx0ICogQHByb3BlcnR5IERFTFRBX0lOREVYXG5cdCAqIEB0eXBlIEFycmF5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdENvbG9yTWF0cml4LkRFTFRBX0lOREVYID0gW1xuXHRcdDAsICAgIDAuMDEsIDAuMDIsIDAuMDQsIDAuMDUsIDAuMDYsIDAuMDcsIDAuMDgsIDAuMSwgIDAuMTEsXG5cdFx0MC4xMiwgMC4xNCwgMC4xNSwgMC4xNiwgMC4xNywgMC4xOCwgMC4yMCwgMC4yMSwgMC4yMiwgMC4yNCxcblx0XHQwLjI1LCAwLjI3LCAwLjI4LCAwLjMwLCAwLjMyLCAwLjM0LCAwLjM2LCAwLjM4LCAwLjQwLCAwLjQyLFxuXHRcdDAuNDQsIDAuNDYsIDAuNDgsIDAuNSwgIDAuNTMsIDAuNTYsIDAuNTksIDAuNjIsIDAuNjUsIDAuNjgsXG5cdFx0MC43MSwgMC43NCwgMC43NywgMC44MCwgMC44MywgMC44NiwgMC44OSwgMC45MiwgMC45NSwgMC45OCxcblx0XHQxLjAsICAxLjA2LCAxLjEyLCAxLjE4LCAxLjI0LCAxLjMwLCAxLjM2LCAxLjQyLCAxLjQ4LCAxLjU0LFxuXHRcdDEuNjAsIDEuNjYsIDEuNzIsIDEuNzgsIDEuODQsIDEuOTAsIDEuOTYsIDIuMCwgIDIuMTIsIDIuMjUsXG5cdFx0Mi4zNywgMi41MCwgMi42MiwgMi43NSwgMi44NywgMy4wLCAgMy4yLCAgMy40LCAgMy42LCAgMy44LFxuXHRcdDQuMCwgIDQuMywgIDQuNywgIDQuOSwgIDUuMCwgIDUuNSwgIDYuMCwgIDYuNSwgIDYuOCwgIDcuMCxcblx0XHQ3LjMsICA3LjUsICA3LjgsICA4LjAsICA4LjQsICA4LjcsICA5LjAsICA5LjQsICA5LjYsICA5LjgsXG5cdFx0MTAuMFxuXHRdO1xuXG5cdC8qKlxuXHQgKiBJZGVudGl0eSBtYXRyaXggdmFsdWVzLlxuXHQgKiBAcHJvcGVydHkgSURFTlRJVFlfTUFUUklYXG5cdCAqIEB0eXBlIEFycmF5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdENvbG9yTWF0cml4LklERU5USVRZX01BVFJJWCA9IFtcblx0XHQxLDAsMCwwLDAsXG5cdFx0MCwxLDAsMCwwLFxuXHRcdDAsMCwxLDAsMCxcblx0XHQwLDAsMCwxLDAsXG5cdFx0MCwwLDAsMCwxXG5cdF07XG5cblx0LyoqXG5cdCAqIFRoZSBjb25zdGFudCBsZW5ndGggb2YgYSBjb2xvciBtYXRyaXguXG5cdCAqIEBwcm9wZXJ0eSBMRU5HVEhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdENvbG9yTWF0cml4LkxFTkdUSCA9IENvbG9yTWF0cml4LklERU5USVRZX01BVFJJWC5sZW5ndGg7XG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXNldHMgdGhlIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZXMuXG5cdCAqIEBtZXRob2Qgc2V0Q29sb3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGJyaWdodG5lc3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvbnRyYXN0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzYXR1cmF0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBodWVcblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHAuc2V0Q29sb3IgPSBmdW5jdGlvbihicmlnaHRuZXNzLGNvbnRyYXN0LHNhdHVyYXRpb24saHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVzZXQoKS5hZGp1c3RDb2xvcihicmlnaHRuZXNzLGNvbnRyYXN0LHNhdHVyYXRpb24saHVlKTtcblx0fTtcblxuXHQvKipcblx0ICogUmVzZXRzIHRoZSBtYXRyaXggdG8gaWRlbnRpdHkgdmFsdWVzLlxuXHQgKiBAbWV0aG9kIHJlc2V0XG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRwLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29weShDb2xvck1hdHJpeC5JREVOVElUWV9NQVRSSVgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCBtZXRob2QgdG8gYWRqdXN0IGJyaWdodG5lc3MsIGNvbnRyYXN0LCBzYXR1cmF0aW9uIGFuZCBodWUuXG5cdCAqIEVxdWl2YWxlbnQgdG8gY2FsbGluZyBhZGp1c3RIdWUoaHVlKSwgYWRqdXN0Q29udHJhc3QoY29udHJhc3QpLFxuXHQgKiBhZGp1c3RCcmlnaHRuZXNzKGJyaWdodG5lc3MpLCBhZGp1c3RTYXR1cmF0aW9uKHNhdHVyYXRpb24pLCBpbiB0aGF0IG9yZGVyLlxuXHQgKiBAbWV0aG9kIGFkanVzdENvbG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBicmlnaHRuZXNzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb250cmFzdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gaHVlXG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hZGp1c3RDb2xvciA9IGZ1bmN0aW9uKGJyaWdodG5lc3MsY29udHJhc3Qsc2F0dXJhdGlvbixodWUpIHtcblx0XHR0aGlzLmFkanVzdEh1ZShodWUpO1xuXHRcdHRoaXMuYWRqdXN0Q29udHJhc3QoY29udHJhc3QpO1xuXHRcdHRoaXMuYWRqdXN0QnJpZ2h0bmVzcyhicmlnaHRuZXNzKTtcblx0XHRyZXR1cm4gdGhpcy5hZGp1c3RTYXR1cmF0aW9uKHNhdHVyYXRpb24pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGp1c3RzIHRoZSBicmlnaHRuZXNzIG9mIHBpeGVsIGNvbG9yIGJ5IGFkZGluZyB0aGUgc3BlY2lmaWVkIHZhbHVlIHRvIHRoZSByZWQsIGdyZWVuIGFuZCBibHVlIGNoYW5uZWxzLlxuXHQgKiBQb3NpdGl2ZSB2YWx1ZXMgd2lsbCBtYWtlIHRoZSBpbWFnZSBicmlnaHRlciwgbmVnYXRpdmUgdmFsdWVzIHdpbGwgbWFrZSBpdCBkYXJrZXIuXG5cdCAqIEBtZXRob2QgYWRqdXN0QnJpZ2h0bmVzc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgQSB2YWx1ZSBiZXR3ZWVuIC0yNTUgJiAyNTUgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBSR0IgY2hhbm5lbHMuXG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hZGp1c3RCcmlnaHRuZXNzID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT0gMCB8fCBpc05hTih2YWx1ZSkpIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR2YWx1ZSA9IHRoaXMuX2NsZWFuVmFsdWUodmFsdWUsMjU1KTtcblx0XHR0aGlzLl9tdWx0aXBseU1hdHJpeChbXG5cdFx0XHQxLDAsMCwwLHZhbHVlLFxuXHRcdFx0MCwxLDAsMCx2YWx1ZSxcblx0XHRcdDAsMCwxLDAsdmFsdWUsXG5cdFx0XHQwLDAsMCwxLDAsXG5cdFx0XHQwLDAsMCwwLDFcblx0XHRdKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQWRqdXN0cyB0aGUgY29udHJhc3Qgb2YgcGl4ZWwgY29sb3IuXG5cdCAqIFBvc2l0aXZlIHZhbHVlcyB3aWxsIGluY3JlYXNlIGNvbnRyYXN0LCBuZWdhdGl2ZSB2YWx1ZXMgd2lsbCBkZWNyZWFzZSBjb250cmFzdC5cblx0ICogQG1ldGhvZCBhZGp1c3RDb250cmFzdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgQSB2YWx1ZSBiZXR3ZWVuIC0xMDAgJiAxMDAuXG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hZGp1c3RDb250cmFzdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09IDAgfHwgaXNOYU4odmFsdWUpKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dmFsdWUgPSB0aGlzLl9jbGVhblZhbHVlKHZhbHVlLDEwMCk7XG5cdFx0dmFyIHg7XG5cdFx0aWYgKHZhbHVlPDApIHtcblx0XHRcdHggPSAxMjcrdmFsdWUvMTAwKjEyNztcblx0XHR9IGVsc2Uge1xuXHRcdFx0eCA9IHZhbHVlJTE7XG5cdFx0XHRpZiAoeCA9PSAwKSB7XG5cdFx0XHRcdHggPSBDb2xvck1hdHJpeC5ERUxUQV9JTkRFWFt2YWx1ZV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR4ID0gQ29sb3JNYXRyaXguREVMVEFfSU5ERVhbKHZhbHVlPDwwKV0qKDEteCkrQ29sb3JNYXRyaXguREVMVEFfSU5ERVhbKHZhbHVlPDwwKSsxXSp4OyAvLyB1c2UgbGluZWFyIGludGVycG9sYXRpb24gZm9yIG1vcmUgZ3JhbnVsYXJpdHkuXG5cdFx0XHR9XG5cdFx0XHR4ID0geCoxMjcrMTI3O1xuXHRcdH1cblx0XHR0aGlzLl9tdWx0aXBseU1hdHJpeChbXG5cdFx0XHR4LzEyNywwLDAsMCwwLjUqKDEyNy14KSxcblx0XHRcdDAseC8xMjcsMCwwLDAuNSooMTI3LXgpLFxuXHRcdFx0MCwwLHgvMTI3LDAsMC41KigxMjcteCksXG5cdFx0XHQwLDAsMCwxLDAsXG5cdFx0XHQwLDAsMCwwLDFcblx0XHRdKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQWRqdXN0cyB0aGUgY29sb3Igc2F0dXJhdGlvbiBvZiB0aGUgcGl4ZWwuXG5cdCAqIFBvc2l0aXZlIHZhbHVlcyB3aWxsIGluY3JlYXNlIHNhdHVyYXRpb24sIG5lZ2F0aXZlIHZhbHVlcyB3aWxsIGRlY3JlYXNlIHNhdHVyYXRpb24gKHRyZW5kIHRvd2FyZHMgZ3JleXNjYWxlKS5cblx0ICogQG1ldGhvZCBhZGp1c3RTYXR1cmF0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBBIHZhbHVlIGJldHdlZW4gLTEwMCAmIDEwMC5cblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmFkanVzdFNhdHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PSAwIHx8IGlzTmFOKHZhbHVlKSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHZhbHVlID0gdGhpcy5fY2xlYW5WYWx1ZSh2YWx1ZSwxMDApO1xuXHRcdHZhciB4ID0gMSsoKHZhbHVlID4gMCkgPyAzKnZhbHVlLzEwMCA6IHZhbHVlLzEwMCk7XG5cdFx0dmFyIGx1bVIgPSAwLjMwODY7XG5cdFx0dmFyIGx1bUcgPSAwLjYwOTQ7XG5cdFx0dmFyIGx1bUIgPSAwLjA4MjA7XG5cdFx0dGhpcy5fbXVsdGlwbHlNYXRyaXgoW1xuXHRcdFx0bHVtUiooMS14KSt4LGx1bUcqKDEteCksbHVtQiooMS14KSwwLDAsXG5cdFx0XHRsdW1SKigxLXgpLGx1bUcqKDEteCkreCxsdW1CKigxLXgpLDAsMCxcblx0XHRcdGx1bVIqKDEteCksbHVtRyooMS14KSxsdW1CKigxLXgpK3gsMCwwLFxuXHRcdFx0MCwwLDAsMSwwLFxuXHRcdFx0MCwwLDAsMCwxXG5cdFx0XSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblxuXHQvKipcblx0ICogQWRqdXN0cyB0aGUgaHVlIG9mIHRoZSBwaXhlbCBjb2xvci5cblx0ICogQG1ldGhvZCBhZGp1c3RIdWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIEEgdmFsdWUgYmV0d2VlbiAtMTgwICYgMTgwLlxuXHQgKiBAcmV0dXJuIHtDb2xvck1hdHJpeH0gVGhlIENvbG9yTWF0cml4IGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYWRqdXN0SHVlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT0gMCB8fCBpc05hTih2YWx1ZSkpIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR2YWx1ZSA9IHRoaXMuX2NsZWFuVmFsdWUodmFsdWUsMTgwKS8xODAqTWF0aC5QSTtcblx0XHR2YXIgY29zVmFsID0gTWF0aC5jb3ModmFsdWUpO1xuXHRcdHZhciBzaW5WYWwgPSBNYXRoLnNpbih2YWx1ZSk7XG5cdFx0dmFyIGx1bVIgPSAwLjIxMztcblx0XHR2YXIgbHVtRyA9IDAuNzE1O1xuXHRcdHZhciBsdW1CID0gMC4wNzI7XG5cdFx0dGhpcy5fbXVsdGlwbHlNYXRyaXgoW1xuXHRcdFx0bHVtUitjb3NWYWwqKDEtbHVtUikrc2luVmFsKigtbHVtUiksbHVtRytjb3NWYWwqKC1sdW1HKStzaW5WYWwqKC1sdW1HKSxsdW1CK2Nvc1ZhbCooLWx1bUIpK3NpblZhbCooMS1sdW1CKSwwLDAsXG5cdFx0XHRsdW1SK2Nvc1ZhbCooLWx1bVIpK3NpblZhbCooMC4xNDMpLGx1bUcrY29zVmFsKigxLWx1bUcpK3NpblZhbCooMC4xNDApLGx1bUIrY29zVmFsKigtbHVtQikrc2luVmFsKigtMC4yODMpLDAsMCxcblx0XHRcdGx1bVIrY29zVmFsKigtbHVtUikrc2luVmFsKigtKDEtbHVtUikpLGx1bUcrY29zVmFsKigtbHVtRykrc2luVmFsKihsdW1HKSxsdW1CK2Nvc1ZhbCooMS1sdW1CKStzaW5WYWwqKGx1bUIpLDAsMCxcblx0XHRcdDAsMCwwLDEsMCxcblx0XHRcdDAsMCwwLDAsMVxuXHRcdF0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb25jYXRlbmF0ZXMgKG11bHRpcGxpZXMpIHRoZSBzcGVjaWZpZWQgbWF0cml4IHdpdGggdGhpcyBvbmUuXG5cdCAqIEBtZXRob2QgY29uY2F0XG5cdCAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeCBBbiBhcnJheSBvciBDb2xvck1hdHJpeCBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmNvbmNhdCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdG1hdHJpeCA9IHRoaXMuX2ZpeE1hdHJpeChtYXRyaXgpO1xuXHRcdGlmIChtYXRyaXgubGVuZ3RoICE9IENvbG9yTWF0cml4LkxFTkdUSCkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX211bHRpcGx5TWF0cml4KG1hdHJpeCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGlzIENvbG9yTWF0cml4LlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBBIGNsb25lIG9mIHRoaXMgQ29sb3JNYXRyaXguXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAobmV3IENvbG9yTWF0cml4KCkpLmNvcHkodGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybiBhIGxlbmd0aCAyNSAoNXg1KSBhcnJheSBpbnN0YW5jZSBjb250YWluaW5nIHRoaXMgbWF0cml4J3MgdmFsdWVzLlxuXHQgKiBAbWV0aG9kIHRvQXJyYXlcblx0ICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IGhvbGRpbmcgdGhpcyBtYXRyaXgncyB2YWx1ZXMuXG5cdCAqKi9cblx0cC50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyciA9IFtdO1xuXHRcdGZvciAodmFyIGk9IDAsIGw9Q29sb3JNYXRyaXguTEVOR1RIOyBpPGw7IGkrKykge1xuXHRcdFx0YXJyW2ldID0gdGhpc1tpXTtcblx0XHR9XG5cdFx0cmV0dXJuIGFycjtcblx0fTtcblxuXHQvKipcblx0ICogQ29weSB0aGUgc3BlY2lmaWVkIG1hdHJpeCdzIHZhbHVlcyB0byB0aGlzIG1hdHJpeC5cblx0ICogQG1ldGhvZCBjb3B5XG5cdCAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeCBBbiBhcnJheSBvciBDb2xvck1hdHJpeCBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmNvcHkgPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR2YXIgbCA9IENvbG9yTWF0cml4LkxFTkdUSDtcblx0XHRmb3IgKHZhciBpPTA7aTxsO2krKykge1xuXHRcdFx0dGhpc1tpXSA9IG1hdHJpeFtpXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0NvbG9yTWF0cml4XVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX211bHRpcGx5TWF0cml4XG5cdCAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fbXVsdGlwbHlNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR2YXIgaSwgaiwgaywgY29sID0gW107XG5cblx0XHRmb3IgKGk9MDtpPDU7aSsrKSB7XG5cdFx0XHRmb3IgKGo9MDtqPDU7aisrKSB7XG5cdFx0XHRcdGNvbFtqXSA9IHRoaXNbaitpKjVdO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChqPTA7ajw1O2orKykge1xuXHRcdFx0XHR2YXIgdmFsPTA7XG5cdFx0XHRcdGZvciAoaz0wO2s8NTtrKyspIHtcblx0XHRcdFx0XHR2YWwgKz0gbWF0cml4W2orayo1XSpjb2xba107XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpc1tqK2kqNV0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBNYWtlIHN1cmUgdmFsdWVzIGFyZSB3aXRoaW4gdGhlIHNwZWNpZmllZCByYW5nZSwgaHVlIGhhcyBhIGxpbWl0IG9mIDE4MCwgYnJpZ2h0bmVzcyBpcyAyNTUsIG90aGVycyBhcmUgMTAwLlxuXHQgKiBAbWV0aG9kIF9jbGVhblZhbHVlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgcmF3IG51bWJlclxuXHQgKiBAcGFyYW0ge051bWJlcn0gbGltaXQgVGhlIG1heGltdW0gdGhhdCB0aGUgbnVtYmVyIGNhbiBiZS4gVGhlIG1pbmltdW0gaXMgdGhlIGxpbWl0ICogLTEuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9jbGVhblZhbHVlID0gZnVuY3Rpb24odmFsdWUsIGxpbWl0KSB7XG5cdFx0cmV0dXJuIE1hdGgubWluKGxpbWl0LE1hdGgubWF4KC1saW1pdCx2YWx1ZSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBNYWtlcyBzdXJlIG1hdHJpeGVzIGFyZSA1eDUgKDI1IGxvbmcpLlxuXHQgKiBAbWV0aG9kIF9maXhNYXRyaXhcblx0ICogQHBhcmFtIHtBcnJheX0gbWF0cml4XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9maXhNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRpZiAobWF0cml4IGluc3RhbmNlb2YgQ29sb3JNYXRyaXgpIHsgbWF0cml4ID0gbWF0cml4LnRvQXJyYXkoKTsgfVxuXHRcdGlmIChtYXRyaXgubGVuZ3RoIDwgQ29sb3JNYXRyaXguTEVOR1RIKSB7XG5cdFx0XHRtYXRyaXggPSBtYXRyaXguc2xpY2UoMCxtYXRyaXgubGVuZ3RoKS5jb25jYXQoQ29sb3JNYXRyaXguSURFTlRJVFlfTUFUUklYLnNsaWNlKG1hdHJpeC5sZW5ndGgsQ29sb3JNYXRyaXguTEVOR1RIKSk7XG5cdFx0fSBlbHNlIGlmIChtYXRyaXgubGVuZ3RoID4gQ29sb3JNYXRyaXguTEVOR1RIKSB7XG5cdFx0XHRtYXRyaXggPSBtYXRyaXguc2xpY2UoMCxDb2xvck1hdHJpeC5MRU5HVEgpO1xuXHRcdH1cblx0XHRyZXR1cm4gbWF0cml4O1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuQ29sb3JNYXRyaXggPSBDb2xvck1hdHJpeDtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBDb2xvck1hdHJpeEZpbHRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEFsbG93cyB5b3UgdG8gY2Fycnkgb3V0IGNvbXBsZXggY29sb3Igb3BlcmF0aW9ucyBzdWNoIGFzIG1vZGlmeWluZyBzYXR1cmF0aW9uLCBicmlnaHRuZXNzLCBvciBpbnZlcnRpbmcuIFNlZSB0aGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQ29sb3JNYXRyaXhcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gY2hhbmdpbmcgY29sb3JzLiBGb3IgYW4gZWFzaWVyIGNvbG9yIHRyYW5zZm9ybSxcblx0ICogY29uc2lkZXIgdGhlIHt7I2Nyb3NzTGluayBcIkNvbG9yRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIFRoaXMgZXhhbXBsZSBjcmVhdGVzIGEgcmVkIGNpcmNsZSwgaW52ZXJ0cyBpdHMgaHVlLCBhbmQgdGhlbiBzYXR1cmF0ZXMgaXQgdG8gYnJpZ2h0ZW4gaXQgdXAuXG5cdCAqXG5cdCAqICAgICAgdmFyIHNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCkuc2V0KHt4OjEwMCx5OjEwMH0pO1xuXHQgKiAgICAgIHNoYXBlLmdyYXBoaWNzLmJlZ2luRmlsbChcIiNmZjAwMDBcIikuZHJhd0NpcmNsZSgwLDAsNTApO1xuXHQgKlxuXHQgKiAgICAgIHZhciBtYXRyaXggPSBuZXcgY3JlYXRlanMuQ29sb3JNYXRyaXgoKS5hZGp1c3RIdWUoMTgwKS5hZGp1c3RTYXR1cmF0aW9uKDEwMCk7XG5cdCAqICAgICAgc2hhcGUuZmlsdGVycyA9IFtcblx0ICogICAgICAgICAgbmV3IGNyZWF0ZWpzLkNvbG9yTWF0cml4RmlsdGVyKG1hdHJpeClcblx0ICogICAgICBdO1xuXHQgKlxuXHQgKiAgICAgIHNoYXBlLmNhY2hlKC01MCwgLTUwLCAxMDAsIDEwMCk7XG5cdCAqXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX0gZm9yIGFuIG1vcmUgaW5mb3JtYXRpb24gb24gYXBwbHlpbmcgZmlsdGVycy5cblx0ICogQGNsYXNzIENvbG9yTWF0cml4RmlsdGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAZXh0ZW5kcyBGaWx0ZXJcblx0ICogQHBhcmFtIHtBcnJheSB8IENvbG9yTWF0cml4fSBtYXRyaXggQSA0eDUgbWF0cml4IGRlc2NyaWJpbmcgdGhlIGNvbG9yIG9wZXJhdGlvbiB0byBwZXJmb3JtLiBTZWUgYWxzbyB0aGUge3sjY3Jvc3NMaW5rIFwiQ29sb3JNYXRyaXhcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogY2xhc3MuXG5cdCAqKi9cblx0ZnVuY3Rpb24gQ29sb3JNYXRyaXhGaWx0ZXIobWF0cml4KSB7XG5cdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBBIDR4NSBtYXRyaXggZGVzY3JpYmluZyB0aGUgY29sb3Igb3BlcmF0aW9uIHRvIHBlcmZvcm0uIFNlZSBhbHNvIHRoZSB7eyNjcm9zc0xpbmsgXCJDb2xvck1hdHJpeFwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIEBwcm9wZXJ0eSBtYXRyaXhcblx0XHQgKiBAdHlwZSBBcnJheSB8IENvbG9yTWF0cml4XG5cdFx0ICoqL1xuXHRcdHRoaXMubWF0cml4ID0gbWF0cml4O1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKENvbG9yTWF0cml4RmlsdGVyLCBjcmVhdGVqcy5GaWx0ZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXHRcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbQ29sb3JNYXRyaXhGaWx0ZXJdXCI7XG5cdH07XG5cblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgQ29sb3JNYXRyaXhGaWx0ZXIodGhpcy5tYXRyaXgpO1xuXHR9O1xuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuX2FwcGx5RmlsdGVyID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7IFxuXHRcdHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cdFx0dmFyIGwgPSBkYXRhLmxlbmd0aDtcblx0XHR2YXIgcixnLGIsYTtcblx0XHR2YXIgbXR4ID0gdGhpcy5tYXRyaXg7XG5cdFx0dmFyIG0wID0gIG10eFswXSwgIG0xID0gIG10eFsxXSwgIG0yID0gIG10eFsyXSwgIG0zID0gIG10eFszXSwgIG00ID0gIG10eFs0XTtcblx0XHR2YXIgbTUgPSAgbXR4WzVdLCAgbTYgPSAgbXR4WzZdLCAgbTcgPSAgbXR4WzddLCAgbTggPSAgbXR4WzhdLCAgbTkgPSAgbXR4WzldO1xuXHRcdHZhciBtMTAgPSBtdHhbMTBdLCBtMTEgPSBtdHhbMTFdLCBtMTIgPSBtdHhbMTJdLCBtMTMgPSBtdHhbMTNdLCBtMTQgPSBtdHhbMTRdO1xuXHRcdHZhciBtMTUgPSBtdHhbMTVdLCBtMTYgPSBtdHhbMTZdLCBtMTcgPSBtdHhbMTddLCBtMTggPSBtdHhbMThdLCBtMTkgPSBtdHhbMTldO1xuXG5cdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrPTQpIHtcblx0XHRcdHIgPSBkYXRhW2ldO1xuXHRcdFx0ZyA9IGRhdGFbaSsxXTtcblx0XHRcdGIgPSBkYXRhW2krMl07XG5cdFx0XHRhID0gZGF0YVtpKzNdO1xuXHRcdFx0ZGF0YVtpXSA9IHIqbTArZyptMStiKm0yK2EqbTMrbTQ7IC8vIHJlZFxuXHRcdFx0ZGF0YVtpKzFdID0gciptNStnKm02K2IqbTcrYSptOCttOTsgLy8gZ3JlZW5cblx0XHRcdGRhdGFbaSsyXSA9IHIqbTEwK2cqbTExK2IqbTEyK2EqbTEzK20xNDsgLy8gYmx1ZVxuXHRcdFx0ZGF0YVtpKzNdID0gciptMTUrZyptMTYrYiptMTcrYSptMTgrbTE5OyAvLyBhbHBoYVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLkNvbG9yTWF0cml4RmlsdGVyID0gY3JlYXRlanMucHJvbW90ZShDb2xvck1hdHJpeEZpbHRlciwgXCJGaWx0ZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVG91Y2guanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuICogR2xvYmFsIHV0aWxpdHkgZm9yIHdvcmtpbmcgd2l0aCBtdWx0aS10b3VjaCBlbmFibGVkIGRldmljZXMgaW4gRWFzZWxKUy4gQ3VycmVudGx5IHN1cHBvcnRzIFczQyBUb3VjaCBBUEkgKGlPUyBhbmRcbiAqIG1vZGVybiBBbmRyb2lkIGJyb3dzZXIpIGFuZCB0aGUgUG9pbnRlciBBUEkgKElFKSwgaW5jbHVkaW5nIG1zLXByZWZpeGVkIGV2ZW50cyBpbiBJRTEwLCBhbmQgdW5wcmVmaXhlZCBpbiBJRTExLlxuICpcbiAqIEVuc3VyZSB0aGF0IHlvdSB7eyNjcm9zc0xpbmsgXCJUb3VjaC9kaXNhYmxlXCJ9fXt7L2Nyb3NzTGlua319IHRvdWNoIHdoZW4gY2xlYW5pbmcgdXAgeW91ciBhcHBsaWNhdGlvbi4gWW91IGRvIG5vdCBoYXZlXG4gKiB0byBjaGVjayBpZiB0b3VjaCBpcyBzdXBwb3J0ZWQgdG8gZW5hYmxlIGl0LCBhcyBpdCB3aWxsIGZhaWwgZ3JhY2VmdWxseSBpZiBpdCBpcyBub3Qgc3VwcG9ydGVkLlxuICpcbiAqIDxoND5FeGFtcGxlPC9oND5cbiAqXG4gKiAgICAgIHZhciBzdGFnZSA9IG5ldyBjcmVhdGVqcy5TdGFnZShcImNhbnZhc0lkXCIpO1xuICogICAgICBjcmVhdGVqcy5Ub3VjaC5lbmFibGUoc3RhZ2UpO1xuICpcbiAqIDxzdHJvbmc+Tm90ZTo8L3N0cm9uZz4gSXQgaXMgaW1wb3J0YW50IHRvIGRpc2FibGUgVG91Y2ggb24gYSBzdGFnZSB0aGF0IHlvdSBhcmUgbm8gbG9uZ2VyIHVzaW5nOlxuICpcbiAqICAgICAgY3JlYXRlanMuVG91Y2guZGlzYWJsZShzdGFnZSk7XG4gKlxuICogQGNsYXNzIFRvdWNoXG4gKiBAc3RhdGljXG4gKiovXG5cdGZ1bmN0aW9uIFRvdWNoKCkge1xuXHRcdHRocm93IFwiVG91Y2ggY2Fubm90IGJlIGluc3RhbnRpYXRlZFwiO1xuXHR9XG5cblxuLy8gcHVibGljIHN0YXRpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdG91Y2ggaXMgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGJyb3dzZXIuXG5cdCAqIEBtZXRob2QgaXNTdXBwb3J0ZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSW5kaWNhdGVzIHdoZXRoZXIgdG91Y2ggaXMgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGJyb3dzZXIuXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVyblx0ISEoKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgLy8gaU9TICYgQW5kcm9pZFxuXHRcdFx0fHwgKHdpbmRvdy5uYXZpZ2F0b3JbJ21zUG9pbnRlckVuYWJsZWQnXSAmJiB3aW5kb3cubmF2aWdhdG9yWydtc01heFRvdWNoUG9pbnRzJ10gPiAwKSAvLyBJRTEwXG5cdFx0XHR8fCAod2luZG93Lm5hdmlnYXRvclsncG9pbnRlckVuYWJsZWQnXSAmJiB3aW5kb3cubmF2aWdhdG9yWydtYXhUb3VjaFBvaW50cyddID4gMCkpOyAvLyBJRTExK1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbmFibGVzIHRvdWNoIGludGVyYWN0aW9uIGZvciB0aGUgc3BlY2lmaWVkIEVhc2VsSlMge3sjY3Jvc3NMaW5rIFwiU3RhZ2VcIn19e3svY3Jvc3NMaW5rfX0uIEN1cnJlbnRseSBzdXBwb3J0cyBpT1Ncblx0ICogKGFuZCBjb21wYXRpYmxlIGJyb3dzZXJzLCBzdWNoIGFzIG1vZGVybiBBbmRyb2lkIGJyb3dzZXJzKSwgYW5kIElFMTAvMTEuIFN1cHBvcnRzIGJvdGggc2luZ2xlIHRvdWNoIGFuZFxuXHQgKiBtdWx0aS10b3VjaCBtb2Rlcy4gRXh0ZW5kcyB0aGUgRWFzZWxKUyB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IG1vZGVsLCBidXQgd2l0aG91dCBzdXBwb3J0IGZvclxuXHQgKiBkb3VibGUgY2xpY2sgb3Igb3Zlci9vdXQgZXZlbnRzLiBTZWUgdGhlIE1vdXNlRXZlbnQge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudC9wb2ludGVySWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBtZXRob2QgZW5hYmxlXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlIFRoZSB7eyNjcm9zc0xpbmsgXCJTdGFnZVwifX17ey9jcm9zc0xpbmt9fSB0byBlbmFibGUgdG91Y2ggb24uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbmdsZVRvdWNoPWZhbHNlXSBJZiBgdHJ1ZWAsIG9ubHkgYSBzaW5nbGUgdG91Y2ggd2lsbCBiZSBhY3RpdmUgYXQgYSB0aW1lLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFthbGxvd0RlZmF1bHQ9ZmFsc2VdIElmIGB0cnVlYCwgdGhlbiBkZWZhdWx0IGdlc3R1cmUgYWN0aW9ucyAoZXguIHNjcm9sbGluZywgem9vbWluZykgd2lsbCBiZVxuXHQgKiBhbGxvd2VkIHdoZW4gdGhlIHVzZXIgaXMgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgdGFyZ2V0IGNhbnZhcy5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdG91Y2ggd2FzIHN1Y2Nlc3NmdWxseSBlbmFibGVkIG9uIHRoZSB0YXJnZXQgc3RhZ2UuXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5lbmFibGUgPSBmdW5jdGlvbihzdGFnZSwgc2luZ2xlVG91Y2gsIGFsbG93RGVmYXVsdCkge1xuXHRcdGlmICghc3RhZ2UgfHwgIXN0YWdlLmNhbnZhcyB8fCAhVG91Y2guaXNTdXBwb3J0ZWQoKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAoc3RhZ2UuX190b3VjaCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0Ly8gaW5qZWN0IHJlcXVpcmVkIHByb3BlcnRpZXMgb24gc3RhZ2U6XG5cdFx0c3RhZ2UuX190b3VjaCA9IHtwb2ludGVyczp7fSwgbXVsdGl0b3VjaDohc2luZ2xlVG91Y2gsIHByZXZlbnREZWZhdWx0OiFhbGxvd0RlZmF1bHQsIGNvdW50OjB9O1xuXG5cdFx0Ly8gbm90ZSB0aGF0IGluIHRoZSBmdXR1cmUgd2UgbWF5IG5lZWQgdG8gZGlzYWJsZSB0aGUgc3RhbmRhcmQgbW91c2UgZXZlbnQgbW9kZWwgYmVmb3JlIGFkZGluZ1xuXHRcdC8vIHRoZXNlIHRvIHByZXZlbnQgZHVwbGljYXRlIGNhbGxzLiBJdCBkb2Vzbid0IHNlZW0gdG8gYmUgYW4gaXNzdWUgd2l0aCBpT1MgZGV2aWNlcyB0aG91Z2guXG5cdFx0aWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgeyBUb3VjaC5fSU9TX2VuYWJsZShzdGFnZSk7IH1cblx0XHRlbHNlIGlmICh3aW5kb3cubmF2aWdhdG9yWydtc1BvaW50ZXJFbmFibGVkJ10gfHwgd2luZG93Lm5hdmlnYXRvcltcInBvaW50ZXJFbmFibGVkXCJdKSB7IFRvdWNoLl9JRV9lbmFibGUoc3RhZ2UpOyB9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyB0aGF0IHdlcmUgc2V0IHVwIHdoZW4gY2FsbGluZyBgVG91Y2guZW5hYmxlKClgIG9uIGEgc3RhZ2UuXG5cdCAqIEBtZXRob2QgZGlzYWJsZVxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZSBUaGUge3sjY3Jvc3NMaW5rIFwiU3RhZ2VcIn19e3svY3Jvc3NMaW5rfX0gdG8gZGlzYWJsZSB0b3VjaCBvbi5cblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRvdWNoLmRpc2FibGUgPSBmdW5jdGlvbihzdGFnZSkge1xuXHRcdGlmICghc3RhZ2UpIHsgcmV0dXJuOyB9XG5cdFx0aWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgeyBUb3VjaC5fSU9TX2Rpc2FibGUoc3RhZ2UpOyB9XG5cdFx0ZWxzZSBpZiAod2luZG93Lm5hdmlnYXRvclsnbXNQb2ludGVyRW5hYmxlZCddIHx8IHdpbmRvdy5uYXZpZ2F0b3JbXCJwb2ludGVyRW5hYmxlZFwiXSkgeyBUb3VjaC5fSUVfZGlzYWJsZShzdGFnZSk7IH1cblx0XHRcblx0XHRkZWxldGUgc3RhZ2UuX190b3VjaDtcblx0fTtcblxuXG4vLyBQcml2YXRlIHN0YXRpYyBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfSU9TX2VuYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5fSU9TX2VuYWJsZSA9IGZ1bmN0aW9uKHN0YWdlKSB7XG5cdFx0dmFyIGNhbnZhcyA9IHN0YWdlLmNhbnZhcztcblx0XHR2YXIgZiA9IHN0YWdlLl9fdG91Y2guZiA9IGZ1bmN0aW9uKGUpIHsgVG91Y2guX0lPU19oYW5kbGVFdmVudChzdGFnZSxlKTsgfTtcblx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgZiwgZmFsc2UpO1xuXHRcdGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGYsIGZhbHNlKTtcblx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGYsIGZhbHNlKTtcblx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIGYsIGZhbHNlKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfSU9TX2Rpc2FibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZVxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guX0lPU19kaXNhYmxlID0gZnVuY3Rpb24oc3RhZ2UpIHtcblx0XHR2YXIgY2FudmFzID0gc3RhZ2UuY2FudmFzO1xuXHRcdGlmICghY2FudmFzKSB7IHJldHVybjsgfVxuXHRcdHZhciBmID0gc3RhZ2UuX190b3VjaC5mO1xuXHRcdGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBmLCBmYWxzZSk7XG5cdFx0Y2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgZiwgZmFsc2UpO1xuXHRcdGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgZiwgZmFsc2UpO1xuXHRcdGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgZiwgZmFsc2UpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9JT1NfaGFuZGxlRXZlbnRcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2Vcblx0ICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5fSU9TX2hhbmRsZUV2ZW50ID0gZnVuY3Rpb24oc3RhZ2UsIGUpIHtcblx0XHRpZiAoIXN0YWdlKSB7IHJldHVybjsgfVxuXHRcdGlmIChzdGFnZS5fX3RvdWNoLnByZXZlbnREZWZhdWx0KSB7IGUucHJldmVudERlZmF1bHQmJmUucHJldmVudERlZmF1bHQoKTsgfVxuXHRcdHZhciB0b3VjaGVzID0gZS5jaGFuZ2VkVG91Y2hlcztcblx0XHR2YXIgdHlwZSA9IGUudHlwZTtcblx0XHRmb3IgKHZhciBpPSAwLGw9dG91Y2hlcy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR2YXIgdG91Y2ggPSB0b3VjaGVzW2ldO1xuXHRcdFx0dmFyIGlkID0gdG91Y2guaWRlbnRpZmllcjtcblx0XHRcdGlmICh0b3VjaC50YXJnZXQgIT0gc3RhZ2UuY2FudmFzKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdGlmICh0eXBlID09IFwidG91Y2hzdGFydFwiKSB7XG5cdFx0XHRcdHRoaXMuX2hhbmRsZVN0YXJ0KHN0YWdlLCBpZCwgZSwgdG91Y2gucGFnZVgsIHRvdWNoLnBhZ2VZKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PSBcInRvdWNobW92ZVwiKSB7XG5cdFx0XHRcdHRoaXMuX2hhbmRsZU1vdmUoc3RhZ2UsIGlkLCBlLCB0b3VjaC5wYWdlWCwgdG91Y2gucGFnZVkpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09IFwidG91Y2hlbmRcIiB8fCB0eXBlID09IFwidG91Y2hjYW5jZWxcIikge1xuXHRcdFx0XHR0aGlzLl9oYW5kbGVFbmQoc3RhZ2UsIGlkLCBlKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX0lFX2VuYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5fSUVfZW5hYmxlID0gZnVuY3Rpb24oc3RhZ2UpIHtcblx0XHR2YXIgY2FudmFzID0gc3RhZ2UuY2FudmFzO1xuXHRcdHZhciBmID0gc3RhZ2UuX190b3VjaC5mID0gZnVuY3Rpb24oZSkgeyBUb3VjaC5fSUVfaGFuZGxlRXZlbnQoc3RhZ2UsZSk7IH07XG5cblx0XHRpZiAod2luZG93Lm5hdmlnYXRvcltcInBvaW50ZXJFbmFibGVkXCJdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyRG93blwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIk1TUG9pbnRlck1vdmVcIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJVcFwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIk1TUG9pbnRlckNhbmNlbFwiLCBmLCBmYWxzZSk7XG5cdFx0XHRpZiAoc3RhZ2UuX190b3VjaC5wcmV2ZW50RGVmYXVsdCkgeyBjYW52YXMuc3R5bGUubXNUb3VjaEFjdGlvbiA9IFwibm9uZVwiOyB9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJjYW5jZWxcIiwgZiwgZmFsc2UpO1xuXHRcdFx0aWYgKHN0YWdlLl9fdG91Y2gucHJldmVudERlZmF1bHQpIHsgY2FudmFzLnN0eWxlLnRvdWNoQWN0aW9uID0gXCJub25lXCI7IH1cblxuXHRcdH1cblx0XHRzdGFnZS5fX3RvdWNoLmFjdGl2ZUlEcyA9IHt9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9JRV9kaXNhYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2Vcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRvdWNoLl9JRV9kaXNhYmxlID0gZnVuY3Rpb24oc3RhZ2UpIHtcblx0XHR2YXIgZiA9IHN0YWdlLl9fdG91Y2guZjtcblxuXHRcdGlmICh3aW5kb3cubmF2aWdhdG9yW1wicG9pbnRlckVuYWJsZWRcIl0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJNb3ZlXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyVXBcIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJDYW5jZWxcIiwgZiwgZmFsc2UpO1xuXHRcdFx0aWYgKHN0YWdlLmNhbnZhcykge1xuXHRcdFx0XHRzdGFnZS5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIk1TUG9pbnRlckRvd25cIiwgZiwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBmLCBmYWxzZSk7XG5cdFx0XHRpZiAoc3RhZ2UuY2FudmFzKSB7XG5cdFx0XHRcdHN0YWdlLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZiwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfSUVfaGFuZGxlRXZlbnRcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2Vcblx0ICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGV2ZW50IHRvIGhhbmRsZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guX0lFX2hhbmRsZUV2ZW50ID0gZnVuY3Rpb24oc3RhZ2UsIGUpIHtcblx0XHRpZiAoIXN0YWdlKSB7IHJldHVybjsgfVxuXHRcdGlmIChzdGFnZS5fX3RvdWNoLnByZXZlbnREZWZhdWx0KSB7IGUucHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG5cdFx0dmFyIHR5cGUgPSBlLnR5cGU7XG5cdFx0dmFyIGlkID0gZS5wb2ludGVySWQ7XG5cdFx0dmFyIGlkcyA9IHN0YWdlLl9fdG91Y2guYWN0aXZlSURzO1xuXG5cdFx0aWYgKHR5cGUgPT0gXCJNU1BvaW50ZXJEb3duXCIgfHwgdHlwZSA9PSBcInBvaW50ZXJkb3duXCIpIHtcblx0XHRcdGlmIChlLnNyY0VsZW1lbnQgIT0gc3RhZ2UuY2FudmFzKSB7IHJldHVybjsgfVxuXHRcdFx0aWRzW2lkXSA9IHRydWU7XG5cdFx0XHR0aGlzLl9oYW5kbGVTdGFydChzdGFnZSwgaWQsIGUsIGUucGFnZVgsIGUucGFnZVkpO1xuXHRcdH0gZWxzZSBpZiAoaWRzW2lkXSkgeyAvLyBpdCdzIGFuIGlkIHdlJ3JlIHdhdGNoaW5nXG5cdFx0XHRpZiAodHlwZSA9PSBcIk1TUG9pbnRlck1vdmVcIiB8fCB0eXBlID09IFwicG9pbnRlcm1vdmVcIikge1xuXHRcdFx0XHR0aGlzLl9oYW5kbGVNb3ZlKHN0YWdlLCBpZCwgZSwgZS5wYWdlWCwgZS5wYWdlWSk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT0gXCJNU1BvaW50ZXJVcFwiIHx8IHR5cGUgPT0gXCJNU1BvaW50ZXJDYW5jZWxcIlxuXHRcdFx0XHRcdHx8IHR5cGUgPT0gXCJwb2ludGVydXBcIiB8fCB0eXBlID09IFwicG9pbnRlcmNhbmNlbFwiKSB7XG5cdFx0XHRcdGRlbGV0ZShpZHNbaWRdKTtcblx0XHRcdFx0dGhpcy5faGFuZGxlRW5kKHN0YWdlLCBpZCwgZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVTdGFydFxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGlkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUb3VjaC5faGFuZGxlU3RhcnQgPSBmdW5jdGlvbihzdGFnZSwgaWQsIGUsIHgsIHkpIHtcblx0XHR2YXIgcHJvcHMgPSBzdGFnZS5fX3RvdWNoO1xuXHRcdGlmICghcHJvcHMubXVsdGl0b3VjaCAmJiBwcm9wcy5jb3VudCkgeyByZXR1cm47IH1cblx0XHR2YXIgaWRzID0gcHJvcHMucG9pbnRlcnM7XG5cdFx0aWYgKGlkc1tpZF0pIHsgcmV0dXJuOyB9XG5cdFx0aWRzW2lkXSA9IHRydWU7XG5cdFx0cHJvcHMuY291bnQrKztcblx0XHRzdGFnZS5faGFuZGxlUG9pbnRlckRvd24oaWQsIGUsIHgsIHkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNb3ZlXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gaWRcblx0ICogQHBhcmFtIHtPYmplY3R9IGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRvdWNoLl9oYW5kbGVNb3ZlID0gZnVuY3Rpb24oc3RhZ2UsIGlkLCBlLCB4LCB5KSB7XG5cdFx0aWYgKCFzdGFnZS5fX3RvdWNoLnBvaW50ZXJzW2lkXSkgeyByZXR1cm47IH1cblx0XHRzdGFnZS5faGFuZGxlUG9pbnRlck1vdmUoaWQsIGUsIHgsIHkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVFbmRcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2Vcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBpZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VG91Y2guX2hhbmRsZUVuZCA9IGZ1bmN0aW9uKHN0YWdlLCBpZCwgZSkge1xuXHRcdC8vIFRPRE86IGNhbmNlbCBzaG91bGQgYmUgaGFuZGxlZCBkaWZmZXJlbnRseSBmb3IgcHJvcGVyIFVJIChleC4gYW4gdXAgd291bGQgdHJpZ2dlciBhIGNsaWNrLCBhIGNhbmNlbCB3b3VsZCBtb3JlIGNsb3NlbHkgcmVzZW1ibGUgYW4gb3V0KS5cblx0XHR2YXIgcHJvcHMgPSBzdGFnZS5fX3RvdWNoO1xuXHRcdHZhciBpZHMgPSBwcm9wcy5wb2ludGVycztcblx0XHRpZiAoIWlkc1tpZF0pIHsgcmV0dXJuOyB9XG5cdFx0cHJvcHMuY291bnQtLTtcblx0XHRzdGFnZS5faGFuZGxlUG9pbnRlclVwKGlkLCBlLCB0cnVlKTtcblx0XHRkZWxldGUoaWRzW2lkXSk7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5Ub3VjaCA9IFRvdWNoO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIHZlcnNpb24uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIFN0YXRpYyBjbGFzcyBob2xkaW5nIGxpYnJhcnkgc3BlY2lmaWMgaW5mb3JtYXRpb24gc3VjaCBhcyB0aGUgdmVyc2lvbiBhbmQgYnVpbGREYXRlIG9mXG5cdCAqIHRoZSBsaWJyYXJ5LlxuXHQgKiBAY2xhc3MgRWFzZWxKU1xuXHQgKiovXG5cdHZhciBzID0gY3JlYXRlanMuRWFzZWxKUyA9IGNyZWF0ZWpzLkVhc2VsSlMgfHwge307XG5cblx0LyoqXG5cdCAqIFRoZSB2ZXJzaW9uIHN0cmluZyBmb3IgdGhpcyByZWxlYXNlLlxuXHQgKiBAcHJvcGVydHkgdmVyc2lvblxuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdHMudmVyc2lvbiA9IC8qPXZlcnNpb24qL1wiMC44LjJcIjsgLy8gaW5qZWN0ZWQgYnkgYnVpbGQgcHJvY2Vzc1xuXG5cdC8qKlxuXHQgKiBUaGUgYnVpbGQgZGF0ZSBmb3IgdGhpcyByZWxlYXNlIGluIFVUQyBmb3JtYXQuXG5cdCAqIEBwcm9wZXJ0eSBidWlsZERhdGVcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRzLmJ1aWxkRGF0ZSA9IC8qPWRhdGUqL1wiVGh1LCAyNiBOb3YgMjAxNSAyMDo0NDozNCBHTVRcIjsgLy8gaW5qZWN0ZWQgYnkgYnVpbGQgcHJvY2Vzc1xuXG59KSgpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gdmVyc2lvbi5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIFN0YXRpYyBjbGFzcyBob2xkaW5nIGxpYnJhcnkgc3BlY2lmaWMgaW5mb3JtYXRpb24gc3VjaCBhcyB0aGUgdmVyc2lvbiBhbmQgYnVpbGREYXRlIG9mIHRoZSBsaWJyYXJ5LlxuXHQgKiBAY2xhc3MgUHJlbG9hZEpTXG5cdCAqKi9cblx0dmFyIHMgPSBjcmVhdGVqcy5QcmVsb2FkSlMgPSBjcmVhdGVqcy5QcmVsb2FkSlMgfHwge307XG5cblx0LyoqXG5cdCAqIFRoZSB2ZXJzaW9uIHN0cmluZyBmb3IgdGhpcyByZWxlYXNlLlxuXHQgKiBAcHJvcGVydHkgdmVyc2lvblxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0cy52ZXJzaW9uID0gLyo9dmVyc2lvbiovXCIwLjYuMlwiOyAvLyBpbmplY3RlZCBieSBidWlsZCBwcm9jZXNzXG5cblx0LyoqXG5cdCAqIFRoZSBidWlsZCBkYXRlIGZvciB0aGlzIHJlbGVhc2UgaW4gVVRDIGZvcm1hdC5cblx0ICogQHByb3BlcnR5IGJ1aWxkRGF0ZVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0cy5idWlsZERhdGUgPSAvKj1kYXRlKi9cIlRodSwgMjYgTm92IDIwMTUgMjA6NDQ6MzEgR01UXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxufSkoKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIHByb3h5LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4vKipcbiAqIFZhcmlvdXMgdXRpbGl0aWVzIHRoYXQgdGhlIENyZWF0ZUpTIFN1aXRlIHVzZXMuIFV0aWxpdGllcyBhcmUgY3JlYXRlZCBhcyBzZXBhcmF0ZSBmaWxlcywgYW5kIHdpbGwgYmUgYXZhaWxhYmxlIG9uIHRoZVxuICogY3JlYXRlanMgbmFtZXNwYWNlIGRpcmVjdGx5LlxuICpcbiAqIDxoND5FeGFtcGxlPC9oND5cbiAqXG4gKiAgICAgIG15T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgY3JlYXRlanMucHJveHkobXlNZXRob2QsIHNjb3BlKSk7XG4gKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICogQG1haW4gVXRpbGl0eSBNZXRob2RzXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogQSBmdW5jdGlvbiBwcm94eSBmb3IgbWV0aG9kcy4gQnkgZGVmYXVsdCwgSmF2YVNjcmlwdCBtZXRob2RzIGRvIG5vdCBtYWludGFpbiBzY29wZSwgc28gcGFzc2luZyBhIG1ldGhvZCBhcyBhXG5cdCAqIGNhbGxiYWNrIHdpbGwgcmVzdWx0IGluIHRoZSBtZXRob2QgZ2V0dGluZyBjYWxsZWQgaW4gdGhlIHNjb3BlIG9mIHRoZSBjYWxsZXIuIFVzaW5nIGEgcHJveHkgZW5zdXJlcyB0aGF0IHRoZVxuXHQgKiBtZXRob2QgZ2V0cyBjYWxsZWQgaW4gdGhlIGNvcnJlY3Qgc2NvcGUuXG5cdCAqXG5cdCAqIEFkZGl0aW9uYWwgYXJndW1lbnRzIGNhbiBiZSBwYXNzZWQgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGZ1bmN0aW9uIHdoZW4gaXQgaXMgY2FsbGVkLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgbXlPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcImV2ZW50XCIsIGNyZWF0ZWpzLnByb3h5KG15SGFuZGxlciwgdGhpcywgYXJnMSwgYXJnMikpO1xuXHQgKlxuXHQgKiAgICAgIGZ1bmN0aW9uIG15SGFuZGxlcihhcmcxLCBhcmcyKSB7XG5cdCAqICAgICAgICAgICAvLyBUaGlzIGdldHMgY2FsbGVkIHdoZW4gbXlPYmplY3QubXlDYWxsYmFjayBpcyBleGVjdXRlZC5cblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBtZXRob2QgcHJveHlcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIFRoZSBmdW5jdGlvbiB0byBjYWxsXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSBUaGUgc2NvcGUgdG8gY2FsbCB0aGUgbWV0aG9kIG5hbWUgb25cblx0ICogQHBhcmFtIHttaXhlZH0gW2FyZ10gKiBBcmd1bWVudHMgdGhhdCBhcmUgYXBwZW5kZWQgdG8gdGhlIGNhbGxiYWNrIGZvciBhZGRpdGlvbmFsIHBhcmFtcy5cblx0ICogQHB1YmxpY1xuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRjcmVhdGVqcy5wcm94eSA9IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlKSB7XG5cdFx0dmFyIGFBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIG1ldGhvZC5hcHBseShzY29wZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKS5jb25jYXQoYUFyZ3MpKTtcblx0XHR9O1xuXHR9XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBFcnJvckV2ZW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyYWwgZXJyb3Ige3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0sIHRoYXQgZGVzY3JpYmVzIGFuIGVycm9yIHRoYXQgb2NjdXJyZWQsIGFzIHdlbGwgYXMgYW55IGRldGFpbHMuXG5cdCAqIEBjbGFzcyBFcnJvckV2ZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbdGl0bGVdIFRoZSBlcnJvciB0aXRsZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIFRoZSBlcnJvciBkZXNjcmlwdGlvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIEFkZGl0aW9uYWwgZXJyb3IgZGF0YVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEVycm9yRXZlbnQodGl0bGUsIG1lc3NhZ2UsIGRhdGEpIHtcblx0XHR0aGlzLkV2ZW50X2NvbnN0cnVjdG9yKFwiZXJyb3JcIik7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgc2hvcnQgZXJyb3IgdGl0bGUsIHdoaWNoIGluZGljYXRlcyB0aGUgdHlwZSBvZiBlcnJvciB0aGF0IG9jY3VycmVkLlxuXHRcdCAqIEBwcm9wZXJ0eSB0aXRsZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdHRoaXMudGl0bGUgPSB0aXRsZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB2ZXJib3NlIGVycm9yIG1lc3NhZ2UsIGNvbnRhaW5pbmcgZGV0YWlscyBhYm91dCB0aGUgZXJyb3IuXG5cdFx0ICogQHByb3BlcnR5IG1lc3NhZ2Vcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXG5cdFx0LyoqXG5cdFx0ICogQWRkaXRpb25hbCBkYXRhIGF0dGFjaGVkIHRvIGFuIGVycm9yLlxuXHRcdCAqIEBwcm9wZXJ0eSBkYXRhXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLmRhdGEgPSBkYXRhO1xuXHR9XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoRXJyb3JFdmVudCwgY3JlYXRlanMuRXZlbnQpO1xuXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQodGhpcy50aXRsZSwgdGhpcy5tZXNzYWdlLCB0aGlzLmRhdGEpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkVycm9yRXZlbnQgPSBjcmVhdGVqcy5wcm9tb3RlKEVycm9yRXZlbnQsIFwiRXZlbnRcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBQcm9ncmVzc0V2ZW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKHNjb3BlKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIENyZWF0ZUpTIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZGlzcGF0Y2hlZCB3aGVuIHByb2dyZXNzIGNoYW5nZXMuXG5cdCAqIEBjbGFzcyBQcm9ncmVzc0V2ZW50XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsb2FkZWQgVGhlIGFtb3VudCB0aGF0IGhhcyBiZWVuIGxvYWRlZC4gVGhpcyBjYW4gYmUgYW55IG51bWJlciByZWxhdGl2ZSB0byB0aGUgdG90YWwuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdG90YWw9MV0gVGhlIHRvdGFsIGFtb3VudCB0aGF0IHdpbGwgbG9hZC4gVGhpcyB3aWxsIGRlZmF1bHQgdG8gMSwgc28gaWYgdGhlIGBsb2FkZWRgIHZhbHVlIGlzXG5cdCAqIGEgcGVyY2VudGFnZSAoYmV0d2VlbiAwIGFuZCAxKSwgaXQgY2FuIGJlIG9taXR0ZWQuXG5cdCAqIEB0b2RvIENvbnNpZGVyIGhhdmluZyB0aGlzIGV2ZW50IGJlIGEgXCJmaWxlcHJvZ3Jlc3NcIiBldmVudCBhcyB3ZWxsXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gUHJvZ3Jlc3NFdmVudChsb2FkZWQsIHRvdGFsKSB7XG5cdFx0dGhpcy5FdmVudF9jb25zdHJ1Y3RvcihcInByb2dyZXNzXCIpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGFtb3VudCB0aGF0IGhhcyBiZWVuIGxvYWRlZCAob3V0IG9mIGEgdG90YWwgYW1vdW50KVxuXHRcdCAqIEBwcm9wZXJ0eSBsb2FkZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMubG9hZGVkID0gbG9hZGVkO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRvdGFsIFwic2l6ZVwiIG9mIHRoZSBsb2FkLlxuXHRcdCAqIEBwcm9wZXJ0eSB0b3RhbFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMudG90YWwgPSAodG90YWwgPT0gbnVsbCkgPyAxIDogdG90YWw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcGVyY2VudGFnZSAob3V0IG9mIDEpIHRoYXQgdGhlIGxvYWQgaGFzIGJlZW4gY29tcGxldGVkLiBUaGlzIGlzIGNhbGN1bGF0ZWQgdXNpbmcgYGxvYWRlZC90b3RhbGAuXG5cdFx0ICogQHByb3BlcnR5IHByb2dyZXNzXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5wcm9ncmVzcyA9ICh0b3RhbCA9PSAwKSA/IDAgOiB0aGlzLmxvYWRlZCAvIHRoaXMudG90YWw7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoUHJvZ3Jlc3NFdmVudCwgY3JlYXRlanMuRXZlbnQpO1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFByb2dyZXNzRXZlbnQgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7UHJvZ3Jlc3NFdmVudH0gYSBjbG9uZSBvZiB0aGUgRXZlbnQgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgY3JlYXRlanMuUHJvZ3Jlc3NFdmVudCh0aGlzLmxvYWRlZCwgdGhpcy50b3RhbCk7XG5cdH07XG5cblx0Y3JlYXRlanMuUHJvZ3Jlc3NFdmVudCA9IGNyZWF0ZWpzLnByb21vdGUoUHJvZ3Jlc3NFdmVudCwgXCJFdmVudFwiKTtcblxufSh3aW5kb3cpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIGpzb24zLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4vKiEgSlNPTiB2My4zLjIgfCBodHRwOi8vYmVzdGllanMuZ2l0aHViLmlvL2pzb24zIHwgQ29weXJpZ2h0IDIwMTItMjAxNCwgS2l0IENhbWJyaWRnZSB8IGh0dHA6Ly9raXQubWl0LWxpY2Vuc2Uub3JnICovXG47KGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IHRoZSBgZGVmaW5lYCBmdW5jdGlvbiBleHBvc2VkIGJ5IGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy4gVGhlXG4gIC8vIHN0cmljdCBgZGVmaW5lYCBjaGVjayBpcyBuZWNlc3NhcnkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBgci5qc2AuXG4gIHZhciBpc0xvYWRlciA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kO1xuXG4gIC8vIEEgc2V0IG9mIHR5cGVzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggb2JqZWN0cyBmcm9tIHByaW1pdGl2ZXMuXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgXCJvYmplY3RcIjogdHJ1ZVxuICB9O1xuXG4gIC8vIERldGVjdCB0aGUgYGV4cG9ydHNgIG9iamVjdCBleHBvc2VkIGJ5IENvbW1vbkpTIGltcGxlbWVudGF0aW9ucy5cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvLyBVc2UgdGhlIGBnbG9iYWxgIG9iamVjdCBleHBvc2VkIGJ5IE5vZGUgKGluY2x1ZGluZyBCcm93c2VyaWZ5IHZpYVxuICAvLyBgaW5zZXJ0LW1vZHVsZS1nbG9iYWxzYCksIE5hcndoYWwsIGFuZCBSaW5nbyBhcyB0aGUgZGVmYXVsdCBjb250ZXh0LFxuICAvLyBhbmQgdGhlIGB3aW5kb3dgIG9iamVjdCBpbiBicm93c2Vycy4gUmhpbm8gZXhwb3J0cyBhIGBnbG9iYWxgIGZ1bmN0aW9uXG4gIC8vIGluc3RlYWQuXG4gIHZhciByb290ID0gb2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93IHx8IHRoaXMsXG4gICAgICBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgdHlwZW9mIGdsb2JhbCA9PSBcIm9iamVjdFwiICYmIGdsb2JhbDtcblxuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbFtcImdsb2JhbFwiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wid2luZG93XCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJzZWxmXCJdID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLy8gUHVibGljOiBJbml0aWFsaXplcyBKU09OIDMgdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QsIGF0dGFjaGluZyB0aGVcbiAgLy8gYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgZnVuY3Rpb25zIHRvIHRoZSBzcGVjaWZpZWQgYGV4cG9ydHNgIG9iamVjdC5cbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQsIGV4cG9ydHMpIHtcbiAgICBjb250ZXh0IHx8IChjb250ZXh0ID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcbiAgICBleHBvcnRzIHx8IChleHBvcnRzID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcblxuICAgIC8vIE5hdGl2ZSBjb25zdHJ1Y3RvciBhbGlhc2VzLlxuICAgIHZhciBOdW1iZXIgPSBjb250ZXh0W1wiTnVtYmVyXCJdIHx8IHJvb3RbXCJOdW1iZXJcIl0sXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHRbXCJTdHJpbmdcIl0gfHwgcm9vdFtcIlN0cmluZ1wiXSxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dFtcIk9iamVjdFwiXSB8fCByb290W1wiT2JqZWN0XCJdLFxuICAgICAgICBEYXRlID0gY29udGV4dFtcIkRhdGVcIl0gfHwgcm9vdFtcIkRhdGVcIl0sXG4gICAgICAgIFN5bnRheEVycm9yID0gY29udGV4dFtcIlN5bnRheEVycm9yXCJdIHx8IHJvb3RbXCJTeW50YXhFcnJvclwiXSxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dFtcIlR5cGVFcnJvclwiXSB8fCByb290W1wiVHlwZUVycm9yXCJdLFxuICAgICAgICBNYXRoID0gY29udGV4dFtcIk1hdGhcIl0gfHwgcm9vdFtcIk1hdGhcIl0sXG4gICAgICAgIG5hdGl2ZUpTT04gPSBjb250ZXh0W1wiSlNPTlwiXSB8fCByb290W1wiSlNPTlwiXTtcblxuICAgIC8vIERlbGVnYXRlIHRvIHRoZSBuYXRpdmUgYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgaW1wbGVtZW50YXRpb25zLlxuICAgIGlmICh0eXBlb2YgbmF0aXZlSlNPTiA9PSBcIm9iamVjdFwiICYmIG5hdGl2ZUpTT04pIHtcbiAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gbmF0aXZlSlNPTi5zdHJpbmdpZnk7XG4gICAgICBleHBvcnRzLnBhcnNlID0gbmF0aXZlSlNPTi5wYXJzZTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBhbGlhc2VzLlxuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIGdldENsYXNzID0gb2JqZWN0UHJvdG8udG9TdHJpbmcsXG4gICAgICAgIGlzUHJvcGVydHksIGZvckVhY2gsIHVuZGVmO1xuXG4gICAgLy8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxuICAgIHZhciBpc0V4dGVuZGVkID0gbmV3IERhdGUoLTM1MDk4MjczMzQ1NzMyOTIpO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxuICAgICAgLy8gcmVzdWx0cyBmb3IgY2VydGFpbiBkYXRlcyBpbiBPcGVyYSA+PSAxMC41My5cbiAgICAgIGlzRXh0ZW5kZWQgPSBpc0V4dGVuZGVkLmdldFVUQ0Z1bGxZZWFyKCkgPT0gLTEwOTI1MiAmJiBpc0V4dGVuZGVkLmdldFVUQ01vbnRoKCkgPT09IDAgJiYgaXNFeHRlbmRlZC5nZXRVVENEYXRlKCkgPT09IDEgJiZcbiAgICAgICAgLy8gU2FmYXJpIDwgMi4wLjIgc3RvcmVzIHRoZSBpbnRlcm5hbCBtaWxsaXNlY29uZCB0aW1lIHZhbHVlIGNvcnJlY3RseSxcbiAgICAgICAgLy8gYnV0IGNsaXBzIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGRhdGUgbWV0aG9kcyB0byB0aGUgcmFuZ2Ugb2ZcbiAgICAgICAgLy8gc2lnbmVkIDMyLWJpdCBpbnRlZ2VycyAoWy0yICoqIDMxLCAyICoqIDMxIC0gMV0pLlxuICAgICAgICBpc0V4dGVuZGVkLmdldFVUQ0hvdXJzKCkgPT0gMTAgJiYgaXNFeHRlbmRlZC5nZXRVVENNaW51dGVzKCkgPT0gMzcgJiYgaXNFeHRlbmRlZC5nZXRVVENTZWNvbmRzKCkgPT0gNiAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbGxpc2Vjb25kcygpID09IDcwODtcbiAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cbiAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBuYXRpdmUgYEpTT04uc3RyaW5naWZ5YCBhbmQgYHBhcnNlYFxuICAgIC8vIGltcGxlbWVudGF0aW9ucyBhcmUgc3BlYy1jb21wbGlhbnQuIEJhc2VkIG9uIHdvcmsgYnkgS2VuIFNueWRlci5cbiAgICBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgICAgaWYgKGhhc1tuYW1lXSAhPT0gdW5kZWYpIHtcbiAgICAgICAgLy8gUmV0dXJuIGNhY2hlZCBmZWF0dXJlIHRlc3QgcmVzdWx0LlxuICAgICAgICByZXR1cm4gaGFzW25hbWVdO1xuICAgICAgfVxuICAgICAgdmFyIGlzU3VwcG9ydGVkO1xuICAgICAgaWYgKG5hbWUgPT0gXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIikge1xuICAgICAgICAvLyBJRSA8PSA3IGRvZXNuJ3Qgc3VwcG9ydCBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgdXNpbmcgc3F1YXJlXG4gICAgICAgIC8vIGJyYWNrZXQgbm90YXRpb24uIElFIDggb25seSBzdXBwb3J0cyB0aGlzIGZvciBwcmltaXRpdmVzLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IFwiYVwiWzBdICE9IFwiYVwiO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwianNvblwiKSB7XG4gICAgICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIGJvdGggYEpTT04uc3RyaW5naWZ5YCBhbmQgYEpTT04ucGFyc2VgIGFyZVxuICAgICAgICAvLyBzdXBwb3J0ZWQuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gaGFzKFwianNvbi1zdHJpbmdpZnlcIikgJiYgaGFzKFwianNvbi1wYXJzZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSwgc2VyaWFsaXplZCA9ICd7XCJhXCI6WzEsdHJ1ZSxmYWxzZSxudWxsLFwiXFxcXHUwMDAwXFxcXGJcXFxcblxcXFxmXFxcXHJcXFxcdFwiXX0nO1xuICAgICAgICAvLyBUZXN0IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1zdHJpbmdpZnlcIikge1xuICAgICAgICAgIHZhciBzdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSwgc3RyaW5naWZ5U3VwcG9ydGVkID0gdHlwZW9mIHN0cmluZ2lmeSA9PSBcImZ1bmN0aW9uXCIgJiYgaXNFeHRlbmRlZDtcbiAgICAgICAgICBpZiAoc3RyaW5naWZ5U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAvLyBBIHRlc3QgZnVuY3Rpb24gb2JqZWN0IHdpdGggYSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kLlxuICAgICAgICAgICAgKHZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0pLnRvSlNPTiA9IHZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID1cbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDMuMWIxIGFuZCBiMiBzZXJpYWxpemUgc3RyaW5nLCBudW1iZXIsIGFuZCBib29sZWFuXG4gICAgICAgICAgICAgICAgLy8gcHJpbWl0aXZlcyBhcyBvYmplY3QgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KDApID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiwgYW5kIEpTT04gMiBzZXJpYWxpemUgd3JhcHBlZCBwcmltaXRpdmVzIGFzIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgTnVtYmVyKCkpID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgU3RyaW5nKCkpID09ICdcIlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAsIGB1bmRlZmluZWRgLCBvclxuICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IGRlZmluZSBhIGNhbm9uaWNhbCBKU09OIHJlcHJlc2VudGF0aW9uICh0aGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggYHRvSlNPTmAgcHJvcGVydGllcyBhcyB3ZWxsLCAqdW5sZXNzKiB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyB3aXRoaW4gYW4gb2JqZWN0IG9yIGFycmF5KS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoZ2V0Q2xhc3MpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIElFIDggc2VyaWFsaXplcyBgdW5kZWZpbmVkYCBhcyBgXCJ1bmRlZmluZWRcImAuIFNhZmFyaSA8PSA1LjEuNyBhbmRcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMyBwYXNzIHRoaXMgdGVzdC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodW5kZWYpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNyBhbmQgRkYgMy4xYjMgdGhyb3cgYEVycm9yYHMgYW5kIGBUeXBlRXJyb3JgcyxcbiAgICAgICAgICAgICAgICAvLyByZXNwZWN0aXZlbHksIGlmIHRoZSB2YWx1ZSBpcyBvbWl0dGVkIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBudW1iZXIsXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nLCBhcnJheSwgb2JqZWN0LCBCb29sZWFuLCBvciBgbnVsbGAgbGl0ZXJhbC4gVGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzIGFzIHdlbGwsIHVubGVzcyB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyBpbnNpZGUgb2JqZWN0IG9yIGFycmF5IGxpdGVyYWxzLiBZVUkgMy4wLjBiMSBpZ25vcmVzIGN1c3RvbSBgdG9KU09OYFxuICAgICAgICAgICAgICAgIC8vIG1ldGhvZHMgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3ZhbHVlXSkgPT0gXCJbMV1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBzZXJpYWxpemVzIGBbdW5kZWZpbmVkXWAgYXMgYFwiW11cImAgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgIC8vIGBcIltudWxsXVwiYC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmXSkgPT0gXCJbbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFlVSSAzLjAuMGIxIGZhaWxzIHRvIHNlcmlhbGl6ZSBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwpID09IFwibnVsbFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgaGFsdHMgc2VyaWFsaXphdGlvbiBpZiBhbiBhcnJheSBjb250YWlucyBhIGZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgIC8vIGBbMSwgdHJ1ZSwgZ2V0Q2xhc3MsIDFdYCBzZXJpYWxpemVzIGFzIFwiWzEsdHJ1ZSxdLFwiLiBGRiAzLjFiM1xuICAgICAgICAgICAgICAgIC8vIGVsaWRlcyBub24tSlNPTiB2YWx1ZXMgZnJvbSBvYmplY3RzIGFuZCBhcnJheXMsIHVubGVzcyB0aGV5XG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWYsIGdldENsYXNzLCBudWxsXSkgPT0gXCJbbnVsbCxudWxsLG51bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgc2VyaWFsaXphdGlvbiB0ZXN0LiBGRiAzLjFiMSB1c2VzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAgIC8vIHdoZXJlIGNoYXJhY3RlciBlc2NhcGUgY29kZXMgYXJlIGV4cGVjdGVkIChlLmcuLCBgXFxiYCA9PiBgXFx1MDAwOGApLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh7IFwiYVwiOiBbdmFsdWUsIHRydWUsIGZhbHNlLCBudWxsLCBcIlxceDAwXFxiXFxuXFxmXFxyXFx0XCJdIH0pID09IHNlcmlhbGl6ZWQgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSBhbmQgYjIgaWdub3JlIHRoZSBgZmlsdGVyYCBhbmQgYHdpZHRoYCBhcmd1bWVudHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwsIHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoWzEsIDJdLCBudWxsLCAxKSA9PSBcIltcXG4gMSxcXG4gMlxcbl1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIEpTT04gMiwgUHJvdG90eXBlIDw9IDEuNywgYW5kIG9sZGVyIFdlYktpdCBidWlsZHMgaW5jb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyBzZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC04LjY0ZTE1KSkgPT0gJ1wiLTI3MTgyMS0wNC0yMFQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gVGhlIG1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNSwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoOC42NGUxNSkpID09ICdcIisyNzU3NjAtMDktMTNUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggPD0gMTEuMCBpbmNvcnJlY3RseSBzZXJpYWxpemVzIHllYXJzIHByaW9yIHRvIDAgYXMgbmVnYXRpdmVcbiAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IHllYXJzIGluc3RlYWQgb2Ygc2l4LWRpZ2l0IHllYXJzLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtNjIxOTg3NTUyZTUpKSA9PSAnXCItMDAwMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjUgYW5kIE9wZXJhID49IDEwLjUzIGluY29ycmVjdGx5IHNlcmlhbGl6ZSBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBsZXNzIHRoYW4gMTAwMC4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTEpKSA9PSAnXCIxOTY5LTEyLTMxVDIzOjU5OjU5Ljk5OVpcIic7XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gc3RyaW5naWZ5U3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlc3QgYEpTT04ucGFyc2VgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tcGFyc2VcIikge1xuICAgICAgICAgIHZhciBwYXJzZSA9IGV4cG9ydHMucGFyc2U7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhIGJhcmUgbGl0ZXJhbCBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgLy8gQ29uZm9ybWluZyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGFsc28gY29lcmNlIHRoZSBpbml0aWFsIGFyZ3VtZW50IHRvXG4gICAgICAgICAgICAgIC8vIGEgc3RyaW5nIHByaW9yIHRvIHBhcnNpbmcuXG4gICAgICAgICAgICAgIGlmIChwYXJzZShcIjBcIikgPT09IDAgJiYgIXBhcnNlKGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBwYXJzaW5nIHRlc3QuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZShzZXJpYWxpemVkKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VTdXBwb3J0ZWQgPSB2YWx1ZVtcImFcIl0ubGVuZ3RoID09IDUgJiYgdmFsdWVbXCJhXCJdWzBdID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS4yIGFuZCBGRiAzLjFiMSBhbGxvdyB1bmVzY2FwZWQgdGFicyBpbiBzdHJpbmdzLlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9ICFwYXJzZSgnXCJcXHRcIicpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wIGFuZCA0LjAuMSBhbGxvdyBsZWFkaW5nIGArYCBzaWducyBhbmQgbGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY2ltYWwgcG9pbnRzLiBGRiA0LjAsIDQuMC4xLCBhbmQgSUUgOS0xMCBhbHNvIGFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMDFcIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCwgNC4wLjEsIGFuZCBSaGlubyAxLjdSMy1SNCBhbGxvdyB0cmFpbGluZyBkZWNpbWFsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRzLiBUaGVzZSBlbnZpcm9ubWVudHMsIGFsb25nIHdpdGggRkYgMy4xYjEgYW5kIDIsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyBhbGxvdyB0cmFpbGluZyBjb21tYXMgaW4gSlNPTiBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjEuXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBwYXJzZVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1tuYW1lXSA9ICEhaXNTdXBwb3J0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFoYXMoXCJqc29uXCIpKSB7XG4gICAgICAvLyBDb21tb24gYFtbQ2xhc3NdXWAgbmFtZSBhbGlhc2VzLlxuICAgICAgdmFyIGZ1bmN0aW9uQ2xhc3MgPSBcIltvYmplY3QgRnVuY3Rpb25dXCIsXG4gICAgICAgICAgZGF0ZUNsYXNzID0gXCJbb2JqZWN0IERhdGVdXCIsXG4gICAgICAgICAgbnVtYmVyQ2xhc3MgPSBcIltvYmplY3QgTnVtYmVyXVwiLFxuICAgICAgICAgIHN0cmluZ0NsYXNzID0gXCJbb2JqZWN0IFN0cmluZ11cIixcbiAgICAgICAgICBhcnJheUNsYXNzID0gXCJbb2JqZWN0IEFycmF5XVwiLFxuICAgICAgICAgIGJvb2xlYW5DbGFzcyA9IFwiW29iamVjdCBCb29sZWFuXVwiO1xuXG4gICAgICAvLyBEZXRlY3QgaW5jb21wbGV0ZSBzdXBwb3J0IGZvciBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgYnkgaW5kZXguXG4gICAgICB2YXIgY2hhckluZGV4QnVnZ3kgPSBoYXMoXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIik7XG5cbiAgICAgIC8vIERlZmluZSBhZGRpdGlvbmFsIHV0aWxpdHkgbWV0aG9kcyBpZiB0aGUgYERhdGVgIG1ldGhvZHMgYXJlIGJ1Z2d5LlxuICAgICAgaWYgKCFpc0V4dGVuZGVkKSB7XG4gICAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgICAgIC8vIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBtb250aHMgb2YgdGhlIHllYXIgYW5kIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuXG4gICAgICAgIC8vIEphbnVhcnkgMXN0IGFuZCB0aGUgZmlyc3Qgb2YgdGhlIHJlc3BlY3RpdmUgbW9udGguXG4gICAgICAgIHZhciBNb250aHMgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdO1xuICAgICAgICAvLyBJbnRlcm5hbDogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0aGUgVW5peCBlcG9jaCBhbmQgdGhlXG4gICAgICAgIC8vIGZpcnN0IGRheSBvZiB0aGUgZ2l2ZW4gbW9udGguXG4gICAgICAgIHZhciBnZXREYXkgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICByZXR1cm4gTW9udGhzW21vbnRoXSArIDM2NSAqICh5ZWFyIC0gMTk3MCkgKyBmbG9vcigoeWVhciAtIDE5NjkgKyAobW9udGggPSArKG1vbnRoID4gMSkpKSAvIDQpIC0gZmxvb3IoKHllYXIgLSAxOTAxICsgbW9udGgpIC8gMTAwKSArIGZsb29yKCh5ZWFyIC0gMTYwMSArIG1vbnRoKSAvIDQwMCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgdGhlIGdpdmVuXG4gICAgICAvLyBvYmplY3QuIERlbGVnYXRlcyB0byB0aGUgbmF0aXZlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIG1ldGhvZC5cbiAgICAgIGlmICghKGlzUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eSkpIHtcbiAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGNvbnN0cnVjdG9yO1xuICAgICAgICAgIGlmICgobWVtYmVycy5fX3Byb3RvX18gPSBudWxsLCBtZW1iZXJzLl9fcHJvdG9fXyA9IHtcbiAgICAgICAgICAgIC8vIFRoZSAqcHJvdG8qIHByb3BlcnR5IGNhbm5vdCBiZSBzZXQgbXVsdGlwbGUgdGltZXMgaW4gcmVjZW50XG4gICAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBGaXJlZm94IGFuZCBTZWFNb25rZXkuXG4gICAgICAgICAgICBcInRvU3RyaW5nXCI6IDFcbiAgICAgICAgICB9LCBtZW1iZXJzKS50b1N0cmluZyAhPSBnZXRDbGFzcykge1xuICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC4zIGRvZXNuJ3QgaW1wbGVtZW50IGBPYmplY3QjaGFzT3duUHJvcGVydHlgLCBidXRcbiAgICAgICAgICAgIC8vIHN1cHBvcnRzIHRoZSBtdXRhYmxlICpwcm90byogcHJvcGVydHkuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIC8vIENhcHR1cmUgYW5kIGJyZWFrIHRoZSBvYmplY3QncyBwcm90b3R5cGUgY2hhaW4gKHNlZSBzZWN0aW9uIDguNi4yXG4gICAgICAgICAgICAgIC8vIG9mIHRoZSBFUyA1LjEgc3BlYykuIFRoZSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb24gcHJldmVudHMgYW5cbiAgICAgICAgICAgICAgLy8gdW5zYWZlIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLl9fcHJvdG9fXywgcmVzdWx0ID0gcHJvcGVydHkgaW4gKHRoaXMuX19wcm90b19fID0gbnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENhcHR1cmUgYSByZWZlcmVuY2UgdG8gdGhlIHRvcC1sZXZlbCBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gbWVtYmVycy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSB0byBzaW11bGF0ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpblxuICAgICAgICAgICAgLy8gb3RoZXIgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuY29uc3RydWN0b3IgfHwgY29uc3RydWN0b3IpLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgIShwcm9wZXJ0eSBpbiBwYXJlbnQgJiYgdGhpc1twcm9wZXJ0eV0gPT09IHBhcmVudFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVtYmVycyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGlzUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBOb3JtYWxpemVzIHRoZSBgZm9yLi4uaW5gIGl0ZXJhdGlvbiBhbGdvcml0aG0gYWNyb3NzXG4gICAgICAvLyBlbnZpcm9ubWVudHMuIEVhY2ggZW51bWVyYXRlZCBrZXkgaXMgeWllbGRlZCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uXG4gICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNpemUgPSAwLCBQcm9wZXJ0aWVzLCBtZW1iZXJzLCBwcm9wZXJ0eTtcblxuICAgICAgICAvLyBUZXN0cyBmb3IgYnVncyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCdzIGBmb3IuLi5pbmAgYWxnb3JpdGhtLiBUaGVcbiAgICAgICAgLy8gYHZhbHVlT2ZgIHByb3BlcnR5IGluaGVyaXRzIHRoZSBub24tZW51bWVyYWJsZSBmbGFnIGZyb21cbiAgICAgICAgLy8gYE9iamVjdC5wcm90b3R5cGVgIGluIG9sZGVyIHZlcnNpb25zIG9mIElFLCBOZXRzY2FwZSwgYW5kIE1vemlsbGEuXG4gICAgICAgIChQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMudmFsdWVPZiA9IDA7XG4gICAgICAgIH0pLnByb3RvdHlwZS52YWx1ZU9mID0gMDtcblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cbiAgICAgICAgbWVtYmVycyA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gbWVtYmVycykge1xuICAgICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgaWYgKGlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUHJvcGVydGllcyA9IG1lbWJlcnMgPSBudWxsO1xuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgaXRlcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIG1lbWJlcnMgPSBbXCJ2YWx1ZU9mXCIsIFwidG9TdHJpbmdcIiwgXCJ0b0xvY2FsZVN0cmluZ1wiLCBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsIFwiaXNQcm90b3R5cGVPZlwiLCBcImhhc093blByb3BlcnR5XCIsIFwiY29uc3RydWN0b3JcIl07XG4gICAgICAgICAgLy8gSUUgPD0gOCwgTW96aWxsYSAxLjAsIGFuZCBOZXRzY2FwZSA2LjIgaWdub3JlIHNoYWRvd2VkIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgICAgLy8gcHJvcGVydGllcy5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBsZW5ndGg7XG4gICAgICAgICAgICB2YXIgaGFzUHJvcGVydHkgPSAhaXNGdW5jdGlvbiAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yICE9IFwiZnVuY3Rpb25cIiAmJiBvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5XSAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkgfHwgaXNQcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIEdlY2tvIDw9IDEuMCBlbnVtZXJhdGVzIHRoZSBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgdW5kZXJcbiAgICAgICAgICAgICAgLy8gY2VydGFpbiBjb25kaXRpb25zOyBJRSBkb2VzIG5vdC5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciBlYWNoIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiBjYWxsYmFjayhwcm9wZXJ0eSkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PSAyKSB7XG4gICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC40IGVudW1lcmF0ZXMgc2hhZG93ZWQgcHJvcGVydGllcyB0d2ljZS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIFN0b3JlIGVhY2ggcHJvcGVydHkgbmFtZSB0byBwcmV2ZW50IGRvdWJsZSBlbnVtZXJhdGlvbi4gVGhlXG4gICAgICAgICAgICAgIC8vIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBpcyBub3QgZW51bWVyYXRlZCBkdWUgdG8gY3Jvc3MtXG4gICAgICAgICAgICAgIC8vIGVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiAhaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSAmJiAobWVtYmVyc1twcm9wZXJ0eV0gPSAxKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIGJ1Z3MgZGV0ZWN0ZWQ7IHVzZSB0aGUgc3RhbmRhcmQgYGZvci4uLmluYCBhbGdvcml0aG0uXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgaXNDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmICEoaXNDb25zdHJ1Y3RvciA9IHByb3BlcnR5ID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBkdWUgdG9cbiAgICAgICAgICAgIC8vIGNyb3NzLWVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yIHx8IGlzUHJvcGVydHkuY2FsbChvYmplY3QsIChwcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIikpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spO1xuICAgICAgfTtcblxuICAgICAgLy8gUHVibGljOiBTZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBgdmFsdWVgIGFzIGEgSlNPTiBzdHJpbmcuIFRoZSBvcHRpb25hbFxuICAgICAgLy8gYGZpbHRlcmAgYXJndW1lbnQgbWF5IHNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgaG93IG9iamVjdCBhbmRcbiAgICAgIC8vIGFycmF5IG1lbWJlcnMgYXJlIHNlcmlhbGl6ZWQsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIG51bWJlcnMgdGhhdFxuICAgICAgLy8gaW5kaWNhdGVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSBvcHRpb25hbCBgd2lkdGhgXG4gICAgICAvLyBhcmd1bWVudCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAgIC8vIGxldmVsIG9mIHRoZSBvdXRwdXQuXG4gICAgICBpZiAoIWhhcyhcImpzb24tc3RyaW5naWZ5XCIpKSB7XG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBFc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcXFxcXCInLFxuICAgICAgICAgIDg6IFwiXFxcXGJcIixcbiAgICAgICAgICAxMjogXCJcXFxcZlwiLFxuICAgICAgICAgIDEwOiBcIlxcXFxuXCIsXG4gICAgICAgICAgMTM6IFwiXFxcXHJcIixcbiAgICAgICAgICA5OiBcIlxcXFx0XCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQ29udmVydHMgYHZhbHVlYCBpbnRvIGEgemVyby1wYWRkZWQgc3RyaW5nIHN1Y2ggdGhhdCBpdHNcbiAgICAgICAgLy8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cbiAgICAgICAgdmFyIGxlYWRpbmdaZXJvZXMgPSBcIjAwMDAwMFwiO1xuICAgICAgICB2YXIgdG9QYWRkZWRTdHJpbmcgPSBmdW5jdGlvbiAod2lkdGgsIHZhbHVlKSB7XG4gICAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiB3aGVyZSBgMCA9PSAtMGAsIGJ1dCBgU3RyaW5nKC0wKSAhPT0gXCIwXCJgLlxuICAgICAgICAgIHJldHVybiAobGVhZGluZ1plcm9lcyArICh2YWx1ZSB8fCAwKSkuc2xpY2UoLXdpZHRoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogRG91YmxlLXF1b3RlcyBhIHN0cmluZyBgdmFsdWVgLCByZXBsYWNpbmcgYWxsIEFTQ0lJIGNvbnRyb2xcbiAgICAgICAgLy8gY2hhcmFjdGVycyAoY2hhcmFjdGVycyB3aXRoIGNvZGUgdW5pdCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAzMSkgd2l0aFxuICAgICAgICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgUXVvdGUodmFsdWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICB2YXIgdW5pY29kZVByZWZpeCA9IFwiXFxcXHUwMFwiO1xuICAgICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJ1wiJywgaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsIHVzZUNoYXJJbmRleCA9ICFjaGFySW5kZXhCdWdneSB8fCBsZW5ndGggPiAxMDtcbiAgICAgICAgICB2YXIgc3ltYm9scyA9IHVzZUNoYXJJbmRleCAmJiAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5zcGxpdChcIlwiKSA6IHZhbHVlKTtcbiAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLCBhcHBlbmQgaXRzIFVuaWNvZGUgb3JcbiAgICAgICAgICAgIC8vIHNob3J0aGFuZCBlc2NhcGUgc2VxdWVuY2U7IG90aGVyd2lzZSwgYXBwZW5kIHRoZSBjaGFyYWN0ZXIgYXMtaXMuXG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgODogY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEyOiBjYXNlIDEzOiBjYXNlIDM0OiBjYXNlIDkyOlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBFc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVuaWNvZGVQcmVmaXggKyB0b1BhZGRlZFN0cmluZygyLCBjaGFyQ29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1c2VDaGFySW5kZXggPyBzeW1ib2xzW2luZGV4XSA6IHZhbHVlLmNoYXJBdChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXCInO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIGFuIG9iamVjdC4gSW1wbGVtZW50cyB0aGVcbiAgICAgICAgLy8gYFN0cihrZXksIGhvbGRlcilgLCBgSk8odmFsdWUpYCwgYW5kIGBKQSh2YWx1ZSlgIG9wZXJhdGlvbnMuXG4gICAgICAgIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAocHJvcGVydHksIG9iamVjdCwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSwgY2xhc3NOYW1lLCB5ZWFyLCBtb250aCwgZGF0ZSwgdGltZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgcmVzdWx0cywgZWxlbWVudCwgaW5kZXgsIGxlbmd0aCwgcHJlZml4LCByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5lY2Vzc2FyeSBmb3IgaG9zdCBvYmplY3Qgc3VwcG9ydC5cbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRGF0ZXMgYXJlIHNlcmlhbGl6ZWQgYWNjb3JkaW5nIHRvIHRoZSBgRGF0ZSN0b0pTT05gIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS45LjUuNDQuIFNlZSBzZWN0aW9uIDE1LjkuMS4xNVxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQuXG4gICAgICAgICAgICAgICAgaWYgKGdldERheSkge1xuICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgY29tcHV0ZSB0aGUgeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLFxuICAgICAgICAgICAgICAgICAgLy8gc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBpZiB0aGUgYGdldFVUQypgIG1ldGhvZHMgYXJlXG4gICAgICAgICAgICAgICAgICAvLyBidWdneS4gQWRhcHRlZCBmcm9tIEBZYWZmbGUncyBgZGF0ZS1zaGltYCBwcm9qZWN0LlxuICAgICAgICAgICAgICAgICAgZGF0ZSA9IGZsb29yKHZhbHVlIC8gODY0ZTUpO1xuICAgICAgICAgICAgICAgICAgZm9yICh5ZWFyID0gZmxvb3IoZGF0ZSAvIDM2NS4yNDI1KSArIDE5NzAgLSAxOyBnZXREYXkoeWVhciArIDEsIDApIDw9IGRhdGU7IHllYXIrKyk7XG4gICAgICAgICAgICAgICAgICBmb3IgKG1vbnRoID0gZmxvb3IoKGRhdGUgLSBnZXREYXkoeWVhciwgMCkpIC8gMzAuNDIpOyBnZXREYXkoeWVhciwgbW9udGggKyAxKSA8PSBkYXRlOyBtb250aCsrKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSAxICsgZGF0ZSAtIGdldERheSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgYHRpbWVgIHZhbHVlIHNwZWNpZmllcyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheSAoc2VlIEVTXG4gICAgICAgICAgICAgICAgICAvLyA1LjEgc2VjdGlvbiAxNS45LjEuMikuIFRoZSBmb3JtdWxhIGAoQSAlIEIgKyBCKSAlIEJgIGlzIHVzZWRcbiAgICAgICAgICAgICAgICAgIC8vIHRvIGNvbXB1dGUgYEEgbW9kdWxvIEJgLCBhcyB0aGUgYCVgIG9wZXJhdG9yIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kIHRvIHRoZSBgbW9kdWxvYCBvcGVyYXRpb24gZm9yIG5lZ2F0aXZlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgICB0aW1lID0gKHZhbHVlICUgODY0ZTUgKyA4NjRlNSkgJSA4NjRlNTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBhcmUgb2J0YWluZWQgYnlcbiAgICAgICAgICAgICAgICAgIC8vIGRlY29tcG9zaW5nIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5LiBTZWUgc2VjdGlvbiAxNS45LjEuMTAuXG4gICAgICAgICAgICAgICAgICBob3VycyA9IGZsb29yKHRpbWUgLyAzNmU1KSAlIDI0O1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IGZsb29yKHRpbWUgLyA2ZTQpICUgNjA7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gZmxvb3IodGltZSAvIDFlMykgJSA2MDtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRpbWUgJSAxZTM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHllYXIgPSB2YWx1ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgICAgbW9udGggPSB2YWx1ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IHZhbHVlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gdmFsdWUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSB2YWx1ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gdmFsdWUuZ2V0VVRDU2Vjb25kcygpO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoeWVhciA8PSAwIHx8IHllYXIgPj0gMWU0ID8gKHllYXIgPCAwID8gXCItXCIgOiBcIitcIikgKyB0b1BhZGRlZFN0cmluZyg2LCB5ZWFyIDwgMCA/IC15ZWFyIDogeWVhcikgOiB0b1BhZGRlZFN0cmluZyg0LCB5ZWFyKSkgK1xuICAgICAgICAgICAgICAgICAgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBtb250aCArIDEpICsgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBkYXRlKSArXG4gICAgICAgICAgICAgICAgICAvLyBNb250aHMsIGRhdGVzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgc2hvdWxkIGhhdmUgdHdvXG4gICAgICAgICAgICAgICAgICAvLyBkaWdpdHM7IG1pbGxpc2Vjb25kcyBzaG91bGQgaGF2ZSB0aHJlZS5cbiAgICAgICAgICAgICAgICAgIFwiVFwiICsgdG9QYWRkZWRTdHJpbmcoMiwgaG91cnMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBtaW51dGVzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgc2Vjb25kcykgK1xuICAgICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LjAsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgICBcIi5cIiArIHRvUGFkZGVkU3RyaW5nKDMsIG1pbGxpc2Vjb25kcykgKyBcIlpcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PSBcImZ1bmN0aW9uXCIgJiYgKChjbGFzc05hbWUgIT0gbnVtYmVyQ2xhc3MgJiYgY2xhc3NOYW1lICE9IHN0cmluZ0NsYXNzICYmIGNsYXNzTmFtZSAhPSBhcnJheUNsYXNzKSB8fCBpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSkge1xuICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcbiAgICAgICAgICAgICAgLy8gYE51bWJlcmAsIGBTdHJpbmdgLCBgRGF0ZWAsIGFuZCBgQXJyYXlgIHByb3RvdHlwZXMuIEpTT04gM1xuICAgICAgICAgICAgICAvLyBpZ25vcmVzIGFsbCBgdG9KU09OYCBtZXRob2RzIG9uIHRoZXNlIG9iamVjdHMgdW5sZXNzIHRoZXkgYXJlXG4gICAgICAgICAgICAgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHJlcGxhY2VtZW50IGZ1bmN0aW9uIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBvYnRhaW4gdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyBmb3Igc2VyaWFsaXphdGlvbi5cbiAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGJvb2xlYW5DbGFzcykge1xuICAgICAgICAgICAgLy8gQm9vbGVhbnMgYXJlIHJlcHJlc2VudGVkIGxpdGVyYWxseS5cbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gYEluZmluaXR5YCBhbmQgYE5hTmAgYXJlIHNlcmlhbGl6ZWQgYXNcbiAgICAgICAgICAgIC8vIGBcIm51bGxcImAuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCA/IFwiXCIgKyB2YWx1ZSA6IFwibnVsbFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoaXMgaXMgYSBsaW5lYXIgc2VhcmNoOyBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgLy8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gc3RhY2subGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgaWYgKHN0YWNrW2xlbmd0aF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3ljbGljIHN0cnVjdHVyZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRoZSBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsIGFuZCBpbmRlbnQgb25lIGFkZGl0aW9uYWwgbGV2ZWwuXG4gICAgICAgICAgICBwcmVmaXggPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIGFycmF5IGVsZW1lbnRzLlxuICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBzZXJpYWxpemUoaW5kZXgsIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbWVudCA9PT0gdW5kZWYgPyBcIm51bGxcIiA6IGVsZW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogKFwiW1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwiXVwiKSkgOiBcIltdXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0IG1lbWJlcnMuIE1lbWJlcnMgYXJlIHNlbGVjdGVkIGZyb21cbiAgICAgICAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuICAgICAgICAgICAgICAvLyBpdHNlbGYuXG4gICAgICAgICAgICAgIGZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzZXJpYWxpemUocHJvcGVydHksIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWYpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcIklmIGBnYXBgIHt3aGl0ZXNwYWNlfVxuICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCBgbWVtYmVyYCB7cXVvdGUocHJvcGVydHkpICsgXCI6XCJ9XG4gICAgICAgICAgICAgICAgICAvLyBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBgbWVtYmVyYCBhbmQgdGhlIGBzcGFjZWAgY2hhcmFjdGVyLlwiXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgXCJgc3BhY2VgIGNoYXJhY3RlclwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxuICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyLCBub3QgdGhlIGBzcGFjZWAge3dpZHRofSBhcmd1bWVudCBwcm92aWRlZCB0b1xuICAgICAgICAgICAgICAgICAgLy8gYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIiArICh3aGl0ZXNwYWNlID8gXCIgXCIgOiBcIlwiKSArIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIntcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwifVwiIDogKFwie1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwifVwiKSkgOiBcInt9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9iamVjdCBmcm9tIHRoZSB0cmF2ZXJzZWQgb2JqZWN0IHN0YWNrLlxuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbHRlciwgd2lkdGgpIHtcbiAgICAgICAgICB2YXIgd2hpdGVzcGFjZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIGNsYXNzTmFtZTtcbiAgICAgICAgICBpZiAob2JqZWN0VHlwZXNbdHlwZW9mIGZpbHRlcl0gJiYgZmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwoZmlsdGVyKSkgPT0gZnVuY3Rpb25DbGFzcykge1xuICAgICAgICAgICAgICBjYWxsYmFjayA9IGZpbHRlcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXG4gICAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBmaWx0ZXIubGVuZ3RoLCB2YWx1ZTsgaW5kZXggPCBsZW5ndGg7IHZhbHVlID0gZmlsdGVyW2luZGV4KytdLCAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpKSwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykgJiYgKHByb3BlcnRpZXNbdmFsdWVdID0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh3aWR0aCkpID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGB3aWR0aGAgdG8gYW4gaW50ZWdlciBhbmQgY3JlYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmdcbiAgICAgICAgICAgICAgLy8gYHdpZHRoYCBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgaWYgKCh3aWR0aCAtPSB3aWR0aCAlIDEpID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAod2hpdGVzcGFjZSA9IFwiXCIsIHdpZHRoID4gMTAgJiYgKHdpZHRoID0gMTApOyB3aGl0ZXNwYWNlLmxlbmd0aCA8IHdpZHRoOyB3aGl0ZXNwYWNlICs9IFwiIFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgICAgd2hpdGVzcGFjZSA9IHdpZHRoLmxlbmd0aCA8PSAxMCA/IHdpZHRoIDogd2lkdGguc2xpY2UoMCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgZGlzY2FyZHMgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggZW1wdHkgc3RyaW5nIGtleXNcbiAgICAgICAgICAvLyAoYFwiXCJgKSBvbmx5IGlmIHRoZXkgYXJlIHVzZWQgZGlyZWN0bHkgd2l0aGluIGFuIG9iamVjdCBtZW1iZXIgbGlzdFxuICAgICAgICAgIC8vIChlLmcuLCBgIShcIlwiIGluIHsgXCJcIjogMX0pYCkuXG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShcIlwiLCAodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSBzb3VyY2UsIHZhbHVlKSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIFwiXCIsIFtdKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gUHVibGljOiBQYXJzZXMgYSBKU09OIHNvdXJjZSBzdHJpbmcuXG4gICAgICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcbiAgICAgICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciB1bmVzY2FwZWRcbiAgICAgICAgLy8gZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBVbmVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXCInLFxuICAgICAgICAgIDQ3OiBcIi9cIixcbiAgICAgICAgICA5ODogXCJcXGJcIixcbiAgICAgICAgICAxMTY6IFwiXFx0XCIsXG4gICAgICAgICAgMTEwOiBcIlxcblwiLFxuICAgICAgICAgIDEwMjogXCJcXGZcIixcbiAgICAgICAgICAxMTQ6IFwiXFxyXCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogU3RvcmVzIHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgIHZhciBJbmRleCwgU291cmNlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXNldHMgdGhlIHBhcnNlciBzdGF0ZSBhbmQgdGhyb3dzIGEgYFN5bnRheEVycm9yYC5cbiAgICAgICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICB0aHJvdyBTeW50YXhFcnJvcigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXR1cm5zIHRoZSBuZXh0IHRva2VuLCBvciBgXCIkXCJgIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWRcbiAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgc291cmNlIHN0cmluZy4gQSB0b2tlbiBtYXkgYmUgYSBzdHJpbmcsIG51bWJlciwgYG51bGxgXG4gICAgICAgIC8vIGxpdGVyYWwsIG9yIEJvb2xlYW4gbGl0ZXJhbC5cbiAgICAgICAgdmFyIGxleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gU291cmNlLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLCB2YWx1ZSwgYmVnaW4sIHBvc2l0aW9uLCBpc1NpZ25lZCwgY2hhckNvZGU7XG4gICAgICAgICAgd2hpbGUgKEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEzOiBjYXNlIDMyOlxuICAgICAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZSB0b2tlbnMsIGluY2x1ZGluZyB0YWJzLCBjYXJyaWFnZSByZXR1cm5zLCBsaW5lXG4gICAgICAgICAgICAgICAgLy8gZmVlZHMsIGFuZCBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTIzOiBjYXNlIDEyNTogY2FzZSA5MTogY2FzZSA5MzogY2FzZSA1ODogY2FzZSA0NDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhIHB1bmN0dWF0b3IgdG9rZW4gKGB7YCwgYH1gLCBgW2AsIGBdYCwgYDpgLCBvciBgLGApIGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjaGFySW5kZXhCdWdneSA/IHNvdXJjZS5jaGFyQXQoSW5kZXgpIDogc291cmNlW0luZGV4XTtcbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgICAvLyBgXCJgIGRlbGltaXRzIGEgSlNPTiBzdHJpbmc7IGFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZFxuICAgICAgICAgICAgICAgIC8vIGJlZ2luIHBhcnNpbmcgdGhlIHN0cmluZy4gU3RyaW5nIHRva2VucyBhcmUgcHJlZml4ZWQgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZW50aW5lbCBgQGAgY2hhcmFjdGVyIHRvIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbSBwdW5jdHVhdG9ycyBhbmRcbiAgICAgICAgICAgICAgICAvLyBlbmQtb2Ytc3RyaW5nIHRva2Vucy5cbiAgICAgICAgICAgICAgICBmb3IgKHZhbHVlID0gXCJAXCIsIEluZGV4Kys7IEluZGV4IDwgbGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbmVzY2FwZWQgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzICh0aG9zZSB3aXRoIGEgY29kZSB1bml0XG4gICAgICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhhbiB0aGUgc3BhY2UgY2hhcmFjdGVyKSBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT0gOTIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSByZXZlcnNlIHNvbGlkdXMgKGBcXGApIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYW4gZXNjYXBlZFxuICAgICAgICAgICAgICAgICAgICAvLyBjb250cm9sIGNoYXJhY3RlciAoaW5jbHVkaW5nIGBcImAsIGBcXGAsIGFuZCBgL2ApIG9yIFVuaWNvZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA5MjogY2FzZSAzNDogY2FzZSA0NzogY2FzZSA5ODogY2FzZSAxMTY6IGNhc2UgMTEwOiBjYXNlIDEwMjogY2FzZSAxMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBVbmVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYFxcdWAgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCB2YWxpZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgY29kZSBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleCArIDQ7IEluZGV4IDwgcG9zaXRpb247IEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgdmFsaWQgc2VxdWVuY2UgY29tcHJpc2VzIGZvdXIgaGV4ZGlnaXRzIChjYXNlLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlbnNpdGl2ZSkgdGhhdCBmb3JtIGEgc2luZ2xlIGhleGFkZWNpbWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NyB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIgfHwgY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNoYXJDb2RlKFwiMHhcIiArIHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEFuIHVuZXNjYXBlZCBkb3VibGUtcXVvdGUgY2hhcmFjdGVyIG1hcmtzIHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZXJlIGEgc3RyaW5nIGlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckNvZGUgPj0gMzIgJiYgY2hhckNvZGUgIT0gOTIgJiYgY2hhckNvZGUgIT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc3RyaW5nIGFzLWlzLlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHJldHVybiB0aGUgcmV2aXZlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnRlcm1pbmF0ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgbnVtYmVycyBhbmQgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIG5lZ2F0aXZlIHNpZ24sIGlmIG9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhbiBpbnRlZ2VyIG9yIGZsb2F0aW5nLXBvaW50IHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xuICAgICAgICAgICAgICAgICAgLy8gTGVhZGluZyB6ZXJvZXMgYXJlIGludGVycHJldGVkIGFzIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ4ICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCArIDEpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgb2N0YWwgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgaW50ZWdlciBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICBmb3IgKDsgSW5kZXggPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgSW5kZXgrKyk7XG4gICAgICAgICAgICAgICAgICAvLyBGbG9hdHMgY2Fubm90IGNvbnRhaW4gYSBsZWFkaW5nIGRlY2ltYWwgcG9pbnQ7IGhvd2V2ZXIsIHRoaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UgaXMgYWxyZWFkeSBhY2NvdW50ZWQgZm9yIGJ5IHRoZSBwYXJzZXIuXG4gICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDQ2KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGRlY2ltYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgdHJhaWxpbmcgZGVjaW1hbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSBleHBvbmVudHMuIFRoZSBgZWAgZGVub3RpbmcgdGhlIGV4cG9uZW50IGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMTAxIHx8IGNoYXJDb2RlID09IDY5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcGFzdCB0aGUgc2lnbiBmb2xsb3dpbmcgdGhlIGV4cG9uZW50LCBpZiBvbmUgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDMgfHwgY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBleHBvbmVudGlhbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgZW1wdHkgZXhwb25lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gQ29lcmNlIHRoZSBwYXJzZWQgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICAgICAgICAgICAgICAgIHJldHVybiArc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEEgbmVnYXRpdmUgc2lnbiBtYXkgb25seSBwcmVjZWRlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgaWYgKGlzU2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBgdHJ1ZWAsIGBmYWxzZWAsIGFuZCBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDUpID09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcIm51bGxcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnJlY29nbml6ZWQgdG9rZW4uXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmV0dXJuIHRoZSBzZW50aW5lbCBgJGAgY2hhcmFjdGVyIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICAgIC8vIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLlxuICAgICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUGFyc2VzIGEgSlNPTiBgdmFsdWVgIHRva2VuLlxuICAgICAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdHMsIGhhc01lbWJlcnM7XG4gICAgICAgICAgaWYgKHZhbHVlID09IFwiJFwiKSB7XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSA9PSBcIkBcIikge1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcnNlIG9iamVjdCBhbmQgYXJyYXkgbGl0ZXJhbHMuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBhcnJheSwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgYXJyYXkuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBzcXVhcmUgYnJhY2tldCBtYXJrcyB0aGUgZW5kIG9mIHRoZSBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhcnJheSBsaXRlcmFsIGNvbnRhaW5zIGVsZW1lbnRzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRpbmcgdGhlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXh0LlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggYXJyYXkgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRWxpc2lvbnMgYW5kIGxlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGdldCh2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIntcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIG9iamVjdCwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAgICAgICByZXN1bHRzID0ge307XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3NpbmcgY3VybHkgYnJhY2UgbWFya3MgdGhlIGVuZCBvZiB0aGUgb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5zIG1lbWJlcnMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdG9yLlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIG9iamVjdCBtZW1iZXIuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLCBvYmplY3QgcHJvcGVydHkgbmFtZXMgbXVzdCBiZVxuICAgICAgICAgICAgICAgIC8vIGRvdWJsZS1xdW90ZWQgc3RyaW5ncywgYW5kIGEgYDpgIG11c3Qgc2VwYXJhdGUgZWFjaCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIC8vIG5hbWUgYW5kIHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIiB8fCB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIiB8fCAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgIT0gXCJAXCIgfHwgbGV4KCkgIT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHNbdmFsdWUuc2xpY2UoMSldID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdG9rZW4gZW5jb3VudGVyZWQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFVwZGF0ZXMgYSB0cmF2ZXJzZWQgb2JqZWN0IG1lbWJlci5cbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmKSB7XG4gICAgICAgICAgICBkZWxldGUgc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlW3Byb3BlcnR5XSA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSB0cmF2ZXJzZXMgYSBwYXJzZWQgSlNPTiBvYmplY3QsIGludm9raW5nIHRoZVxuICAgICAgICAvLyBgY2FsbGJhY2tgIGZ1bmN0aW9uIGZvciBlYWNoIHZhbHVlLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgV2Fsayhob2xkZXIsIG5hbWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICB2YXIgd2FsayA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0sIGxlbmd0aDtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGBmb3JFYWNoYCBjYW4ndCBiZSB1c2VkIHRvIHRyYXZlcnNlIGFuIGFycmF5IGluIE9wZXJhIDw9IDguNTRcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaXRzIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGltcGxlbWVudGF0aW9uIHJldHVybnMgYGZhbHNlYFxuICAgICAgICAgICAgLy8gZm9yIGFycmF5IGluZGljZXMgKGUuZy4sIGAhWzEsIDIsIDNdLmhhc093blByb3BlcnR5KFwiMFwiKWApLlxuICAgICAgICAgICAgaWYgKGdldENsYXNzLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgbGVuZ3RoLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHNvdXJjZSwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnBhcnNlYC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuICAgICAgICAgIEluZGV4ID0gMDtcbiAgICAgICAgICBTb3VyY2UgPSBcIlwiICsgc291cmNlO1xuICAgICAgICAgIHJlc3VsdCA9IGdldChsZXgoKSk7XG4gICAgICAgICAgLy8gSWYgYSBKU09OIHN0cmluZyBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMsIGl0IGlzIGludmFsaWQuXG4gICAgICAgICAgaWYgKGxleCgpICE9IFwiJFwiKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXNldCB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgZ2V0Q2xhc3MuY2FsbChjYWxsYmFjaykgPT0gZnVuY3Rpb25DbGFzcyA/IHdhbGsoKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gcmVzdWx0LCB2YWx1ZSksIFwiXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnRzW1wicnVuSW5Db250ZXh0XCJdID0gcnVuSW5Db250ZXh0O1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9XG5cbiAgaWYgKGZyZWVFeHBvcnRzICYmICFpc0xvYWRlcikge1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgZW52aXJvbm1lbnRzLlxuICAgIHJ1bkluQ29udGV4dChyb290LCBmcmVlRXhwb3J0cyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRXhwb3J0IGZvciB3ZWIgYnJvd3NlcnMgYW5kIEphdmFTY3JpcHQgZW5naW5lcy5cbiAgICB2YXIgbmF0aXZlSlNPTiA9IHJvb3QuSlNPTixcbiAgICAgICAgcHJldmlvdXNKU09OID0gcm9vdFtcIkpTT04zXCJdLFxuICAgICAgICBpc1Jlc3RvcmVkID0gZmFsc2U7XG5cbiAgICB2YXIgSlNPTjMgPSBydW5JbkNvbnRleHQocm9vdCwgKHJvb3RbXCJKU09OM1wiXSA9IHtcbiAgICAgIC8vIFB1YmxpYzogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBnbG9iYWwgYEpTT05gIG9iamVjdCBhbmRcbiAgICAgIC8vIHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBKU09OM2Agb2JqZWN0LlxuICAgICAgXCJub0NvbmZsaWN0XCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jlc3RvcmVkKSB7XG4gICAgICAgICAgaXNSZXN0b3JlZCA9IHRydWU7XG4gICAgICAgICAgcm9vdC5KU09OID0gbmF0aXZlSlNPTjtcbiAgICAgICAgICByb290W1wiSlNPTjNcIl0gPSBwcmV2aW91c0pTT047XG4gICAgICAgICAgbmF0aXZlSlNPTiA9IHByZXZpb3VzSlNPTiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04zO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJvb3QuSlNPTiA9IHtcbiAgICAgIFwicGFyc2VcIjogSlNPTjMucGFyc2UsXG4gICAgICBcInN0cmluZ2lmeVwiOiBKU09OMy5zdHJpbmdpZnlcbiAgICB9O1xuICB9XG5cbiAgLy8gRXhwb3J0IGZvciBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuXG4gIGlmIChpc0xvYWRlcikge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gSlNPTjM7XG4gICAgfSk7XG4gIH1cbn0pLmNhbGwodGhpcyk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBEb21VdGlscy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblxuXHQvKipcblx0ICogQSBmZXcgdXRpbGl0aWVzIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBkb20uXG5cdCAqIEBjbGFzcyBEb21VdGlsc1xuXHQgKi9cblx0dmFyIHMgPSB7fTtcblxuXHRzLmFwcGVuZFRvSGVhZCA9IGZ1bmN0aW9uIChlbCkge1xuXHRcdHMuZ2V0SGVhZCgpLmFwcGVuZENoaWxkKGVsKVxuXHR9XG5cblx0cy5nZXRIZWFkID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcblx0fVxuXG5cdHMuZ2V0Qm9keSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJvZHlcIilbMF07XG5cdH1cblxuXHRjcmVhdGVqcy5Eb21VdGlscyA9IHM7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBEYXRhVXRpbHMuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cblx0LyoqXG5cdCAqIEEgZmV3IGRhdGEgdXRpbGl0aWVzIGZvciBmb3JtYXR0aW5nIGRpZmZlcmVudCBkYXRhIHR5cGVzLlxuXHQgKiBAY2xhc3MgRGF0YVV0aWxzXG5cdCAqL1xuXHR2YXIgcyA9IHt9O1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBQYXJzZSBYTUwgdXNpbmcgdGhlIERPTS4gVGhpcyBpcyByZXF1aXJlZCB3aGVuIHByZWxvYWRpbmcgWE1MIG9yIFNWRy5cblx0ICogQG1ldGhvZCBwYXJzZVhNTFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgcmF3IHRleHQgb3IgWE1MIHRoYXQgaXMgbG9hZGVkIGJ5IFhIUi5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG1pbWUgdHlwZSBvZiB0aGUgWE1MLiBVc2UgXCJ0ZXh0L3htbFwiIGZvciBYTUwsIGFuZCAgXCJpbWFnZS9zdmcreG1sXCIgZm9yIFNWRyBwYXJzaW5nLlxuXHQgKiBAcmV0dXJuIHtYTUx9IEFuIFhNTCBkb2N1bWVudFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLnBhcnNlWE1MID0gZnVuY3Rpb24gKHRleHQsIHR5cGUpIHtcblx0XHR2YXIgeG1sID0gbnVsbDtcblx0XHQvLyBDb2Nvb25KUyBkb2VzIG5vdCBzdXBwb3J0IFhNTCBwYXJzaW5nIHdpdGggZWl0aGVyIG1ldGhvZC5cblxuXHRcdC8vIE1vc3QgYnJvd3NlcnMgd2lsbCB1c2UgRE9NUGFyc2VyXG5cdFx0Ly8gSUUgZmFpbHMgb24gY2VydGFpbiBTVkcgZmlsZXMsIHNvIHdlIGhhdmUgYSBmYWxsYmFjayBiZWxvdy5cblx0XHR0cnkge1xuXHRcdFx0aWYgKHdpbmRvdy5ET01QYXJzZXIpIHtcblx0XHRcdFx0dmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcblx0XHRcdFx0eG1sID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh0ZXh0LCB0eXBlKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgZm9yIElFIHN1cHBvcnQuXG5cdFx0aWYgKCF4bWwpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHhtbCA9IG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTERPTVwiKTtcblx0XHRcdFx0eG1sLmFzeW5jID0gZmFsc2U7XG5cdFx0XHRcdHhtbC5sb2FkWE1MKHRleHQpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHR4bWwgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB4bWw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhcnNlIGEgc3RyaW5nIGludG8gYW4gT2JqZWN0LlxuXHQgKiBAbWV0aG9kIHBhcnNlSlNPTlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIGxvYWRlZCBKU09OIHN0cmluZ1xuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBBIEphdmFTY3JpcHQgb2JqZWN0LlxuXHQgKi9cblx0cy5wYXJzZUpTT04gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHQvLyBUT0RPOyBIYW5kbGUgdGhpcyB3aXRoIGEgY3VzdG9tIGVycm9yP1xuXHRcdFx0dGhyb3cgZTtcblx0XHR9XG5cdH07XG5cblx0Y3JlYXRlanMuRGF0YVV0aWxzID0gcztcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIExvYWRJdGVtLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogQWxsIGxvYWRlcnMgYWNjZXB0IGFuIGl0ZW0gY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoaXMgY2xhc3MuIElmIGEgcmF3IG9iamVjdCBpcyBwYXNzZWQgaW5zdGVhZCxcblx0ICogaXQgd2lsbCBub3QgYmUgYWZmZWN0ZWQsIGJ1dCBpdCBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgYSB7eyNjcm9zc0xpbmsgXCJzcmM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkuIEFcblx0ICogc3RyaW5nIHBhdGggb3IgSFRNTCB0YWcgaXMgYWxzbyBhY2NlcHRhYmxlLCBidXQgaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhIExvYWRJdGVtIHVzaW5nIHRoZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJjcmVhdGVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGJ5IHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIEBjbGFzcyBMb2FkSXRlbVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRmdW5jdGlvbiBMb2FkSXRlbSgpIHtcblx0XHQvKipcblx0XHQgKiBUaGUgc291cmNlIG9mIHRoZSBmaWxlIHRoYXQgaXMgYmVpbmcgbG9hZGVkLiBUaGlzIHByb3BlcnR5IGlzIDxiPnJlcXVpcmVkPC9iPi4gVGhlIHNvdXJjZSBjYW4gZWl0aGVyIGJlIGFcblx0XHQgKiBzdHJpbmcgKHJlY29tbWVuZGVkKSwgb3IgYW4gSFRNTCB0YWcuXG5cdFx0ICogVGhpcyBjYW4gYWxzbyBiZSBhbiBvYmplY3QsIGJ1dCBpbiB0aGF0IGNhc2UgaXQgaGFzIHRvIGluY2x1ZGUgYSB0eXBlIGFuZCBiZSBoYW5kbGVkIGJ5IGEgcGx1Z2luLlxuXHRcdCAqIEBwcm9wZXJ0eSBzcmNcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnNyYyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdHlwZSBmaWxlIHRoYXQgaXMgYmVpbmcgbG9hZGVkLiBUaGUgdHlwZSBvZiB0aGUgZmlsZSBpcyB1c3VhbGx5IGluZmVycmVkIGJ5IHRoZSBleHRlbnNpb24sIGJ1dCBjYW4gYWxzb1xuXHRcdCAqIGJlIHNldCBtYW51YWxseS4gVGhpcyBpcyBoZWxwZnVsIGluIGNhc2VzIHdoZXJlIGEgZmlsZSBkb2VzIG5vdCBoYXZlIGFuIGV4dGVuc2lvbi5cblx0XHQgKiBAcHJvcGVydHkgdHlwZVxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMudHlwZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyBpZGVudGlmaWVyIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGUgbG9hZGVkIG9iamVjdC4gSWYgbm9uZSBpcyBwcm92aWRlZCwgdGhpcyB3aWxsIGJlXG5cdFx0ICogYXV0b21hdGljYWxseSBzZXQgdG8gdGhlIHt7I2Nyb3NzTGluayBcInNyYzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgaWRcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmlkID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZXMgaWYgYSBtYW5pZmVzdCB3aWxsIG1haW50YWluIHRoZSBvcmRlciBvZiB0aGlzIGl0ZW0sIGluIHJlbGF0aW9uIHRvIG90aGVyIGl0ZW1zIGluIHRoZSBtYW5pZmVzdFxuXHRcdCAqIHRoYXQgaGF2ZSBhbHNvIHNldCB0aGUgYG1haW50YWluT3JkZXJgIHByb3BlcnR5IHRvIGB0cnVlYC4gVGhpcyBvbmx5IGFwcGxpZXMgd2hlbiB0aGUgbWF4IGNvbm5lY3Rpb25zIGhhc1xuXHRcdCAqIGJlZW4gc2V0IGFib3ZlIDEgKHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRNYXhDb25uZWN0aW9uc1wifX17ey9jcm9zc0xpbmt9fSkuIEV2ZXJ5dGhpbmcgd2l0aCB0aGlzXG5cdFx0ICogcHJvcGVydHkgc2V0IHRvIGBmYWxzZWAgd2lsbCBmaW5pc2ggYXMgaXQgaXMgbG9hZGVkLiBPcmRlcmVkIGl0ZW1zIGFyZSBjb21iaW5lZCB3aXRoIHNjcmlwdCB0YWdzIGxvYWRpbmcgaW5cblx0XHQgKiBvcmRlciB3aGVuIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9tYWludGFpblNjcmlwdE9yZGVyOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlzIHNldCB0byBgdHJ1ZWAuXG5cdFx0ICogQHByb3BlcnR5IG1haW50YWluT3JkZXJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMubWFpbnRhaW5PcmRlciA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBjYWxsYmFjayB1c2VkIGJ5IEpTT05QIHJlcXVlc3RzIHRoYXQgZGVmaW5lcyB3aGF0IGdsb2JhbCBtZXRob2QgdG8gY2FsbCB3aGVuIHRoZSBKU09OUCBjb250ZW50IGlzIGxvYWRlZC5cblx0XHQgKiBAcHJvcGVydHkgY2FsbGJhY2tcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmNhbGxiYWNrID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGFyYml0cmFyeSBkYXRhIG9iamVjdCwgd2hpY2ggaXMgaW5jbHVkZWQgd2l0aCB0aGUgbG9hZGVkIG9iamVjdC5cblx0XHQgKiBAcHJvcGVydHkgZGF0YVxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuZGF0YSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcmVxdWVzdCBtZXRob2QgdXNlZCBmb3IgSFRUUCBjYWxscy4gQm90aCB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9HRVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9QT1NUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHJlcXVlc3QgdHlwZXMgYXJlIHN1cHBvcnRlZCwgYW5kIGFyZSBkZWZpbmVkIGFzXG5cdFx0ICogY29uc3RhbnRzIG9uIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBtZXRob2Rcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IGdldFxuXHRcdCAqL1xuXHRcdHRoaXMubWV0aG9kID0gY3JlYXRlanMuTG9hZEl0ZW0uR0VUO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IGhhc2ggb2YgbmFtZS92YWx1ZSBwYWlycyB0byBzZW5kIHRvIHRoZSBzZXJ2ZXIuXG5cdFx0ICogQHByb3BlcnR5IHZhbHVlc1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMudmFsdWVzID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBoYXNoIG9mIGhlYWRlcnMgdG8gYXR0YWNoIHRvIGFuIFhIUiByZXF1ZXN0LiBQcmVsb2FkSlMgd2lsbCBhdXRvbWF0aWNhbGx5IGF0dGFjaCBzb21lIGRlZmF1bHRcblx0XHQgKiBoZWFkZXJzIHdoZW4gcmVxdWlyZWQsIGluY2x1ZGluZyBcIk9yaWdpblwiLCBcIkNvbnRlbnQtVHlwZVwiLCBhbmQgXCJYLVJlcXVlc3RlZC1XaXRoXCIuIFlvdSBtYXkgb3ZlcnJpZGUgdGhlXG5cdFx0ICogZGVmYXVsdCBoZWFkZXJzIGJ5IGluY2x1ZGluZyB0aGVtIGluIHlvdXIgaGVhZGVycyBvYmplY3QuXG5cdFx0ICogQHByb3BlcnR5IGhlYWRlcnNcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmhlYWRlcnMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIGNyZWRlbnRpYWxzIGZvciBYSFIgcmVxdWVzdHMuXG5cdFx0ICogQHByb3BlcnR5IHdpdGhDcmVkZW50aWFsc1xuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgbWltZSB0eXBlIG9mIFhIUi1iYXNlZCByZXF1ZXN0cy4gVGhpcyBpcyBhdXRvbWF0aWNhbGx5IHNldCB0byBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIiBmb3IgdGV4dFxuXHRcdCAqIGJhc2VkIGZpbGVzIChqc29uLCB4bWwsIHRleHQsIGNzcywganMpLlxuXHRcdCAqIEBwcm9wZXJ0eSBtaW1lVHlwZVxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMubWltZVR5cGUgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogU2V0cyB0aGUgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIGZvciBDT1JTLWVuYWJsZWQgaW1hZ2VzIGxvYWRpbmcgY3Jvc3MtZG9tYWluLlxuXHRcdCAqIEBwcm9wZXJ0eSBjcm9zc09yaWdpblxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IEFub255bW91c1xuXHRcdCAqL1xuXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBhIHJlcXVlc3QgdGltZXMgb3V0LiBUaGlzIG9ubHkgYXBwbGllcyB0byB0YWctYmFzZWQgYW5kIGFuZCBYSFJcblx0XHQgKiAobGV2ZWwgb25lKSBsb2FkaW5nLCBhcyBYSFIgKGxldmVsIDIpIHByb3ZpZGVzIGl0cyBvd24gdGltZW91dCBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgbG9hZFRpbWVvdXRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDgwMDAgKDggc2Vjb25kcylcblx0XHQgKi9cblx0XHR0aGlzLmxvYWRUaW1lb3V0ID0gcy5MT0FEX1RJTUVPVVRfREVGQVVMVDtcblx0fTtcblxuXHR2YXIgcCA9IExvYWRJdGVtLnByb3RvdHlwZSA9IHt9O1xuXHR2YXIgcyA9IExvYWRJdGVtO1xuXG5cdC8qKlxuXHQgKiBEZWZhdWx0IGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBhIHJlcXVlc3QgdGltZXMgb3V0LiBUaGlzIG9ubHkgYXBwbGllcyB0byB0YWctYmFzZWQgYW5kIGFuZCBYSFJcblx0ICogKGxldmVsIG9uZSkgbG9hZGluZywgYXMgWEhSIChsZXZlbCAyKSBwcm92aWRlcyBpdHMgb3duIHRpbWVvdXQgZXZlbnQuXG5cdCAqIEBwcm9wZXJ0eSBMT0FEX1RJTUVPVVRfREVGQVVMVFxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLkxPQURfVElNRU9VVF9ERUZBVUxUID0gODAwMDtcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgTG9hZEl0ZW0uXG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5TdHJpbmctYmFzZWQgaXRlbXMgYXJlIGNvbnZlcnRlZCB0byBhIExvYWRJdGVtIHdpdGggYSBwb3B1bGF0ZWQge3sjY3Jvc3NMaW5rIFwic3JjOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LjwvbGk+XG5cdCAqICAgICA8bGk+TG9hZEl0ZW0gaW5zdGFuY2VzIGFyZSByZXR1cm5lZCBhcy1pczwvbGk+XG5cdCAqICAgICA8bGk+T2JqZWN0cyBhcmUgcmV0dXJuZWQgd2l0aCBhbnkgbmVlZGVkIHByb3BlcnRpZXMgYWRkZWQ8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBAbWV0aG9kIGNyZWF0ZVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfFN0cmluZ3xPYmplY3R9IHZhbHVlIFRoZSBsb2FkIGl0ZW0gdmFsdWVcblx0ICogQHJldHVybnMge0xvYWRJdGVtfE9iamVjdH1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jcmVhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZhciBpdGVtID0gbmV3IExvYWRJdGVtKCk7XG5cdFx0XHRpdGVtLnNyYyA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIHMpIHtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0ICYmIHZhbHVlLnNyYykge1xuXHRcdFx0aWYgKHZhbHVlLmxvYWRUaW1lb3V0ID09IG51bGwpIHtcblx0XHRcdFx0dmFsdWUubG9hZFRpbWVvdXQgPSBzLkxPQURfVElNRU9VVF9ERUZBVUxUO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUeXBlIG5vdCByZWNvZ25pemVkLlwiKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFByb3ZpZGVzIGEgY2hhaW5hYmxlIHNob3J0Y3V0IG1ldGhvZCBmb3Igc2V0dGluZyBhIG51bWJlciBvZiBwcm9wZXJ0aWVzIG9uIHRoZSBpbnN0YW5jZS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBsb2FkSXRlbSA9IG5ldyBjcmVhdGVqcy5Mb2FkSXRlbSgpLnNldCh7c3JjOlwiaW1hZ2UucG5nXCIsIG1haW50YWluT3JkZXI6dHJ1ZX0pO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHNldFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQSBnZW5lcmljIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gY29weSB0byB0aGUgTG9hZEl0ZW0gaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4ge0xvYWRJdGVtfSBSZXR1cm5zIHRoZSBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCovXG5cdHAuc2V0ID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRmb3IgKHZhciBuIGluIHByb3BzKSB7IHRoaXNbbl0gPSBwcm9wc1tuXTsgfVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkxvYWRJdGVtID0gcztcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFJlcXVlc3RVdGlscy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblxuXHQvKipcblx0ICogVXRpbGl0aWVzIHRoYXQgYXNzaXN0IHdpdGggcGFyc2luZyBsb2FkIGl0ZW1zLCBhbmQgZGV0ZXJtaW5pbmcgZmlsZSB0eXBlcywgZXRjLlxuXHQgKiBAY2xhc3MgUmVxdWVzdFV0aWxzXG5cdCAqL1xuXHR2YXIgcyA9IHt9O1xuXG5cdC8qKlxuXHQgKiBUaGUgUmVndWxhciBFeHByZXNzaW9uIHVzZWQgdG8gdGVzdCBmaWxlIFVSTFMgZm9yIGFuIGFic29sdXRlIHBhdGguXG5cdCAqIEBwcm9wZXJ0eSBBQlNPTFVURV9QQVRIXG5cdCAqIEB0eXBlIHtSZWdFeHB9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuQUJTT0xVVEVfUEFUVCA9IC9eKD86XFx3KzopP1xcL3syfS9pO1xuXG5cdC8qKlxuXHQgKiBUaGUgUmVndWxhciBFeHByZXNzaW9uIHVzZWQgdG8gdGVzdCBmaWxlIFVSTFMgZm9yIGEgcmVsYXRpdmUgcGF0aC5cblx0ICogQHByb3BlcnR5IFJFTEFUSVZFX1BBVEhcblx0ICogQHR5cGUge1JlZ0V4cH1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5SRUxBVElWRV9QQVRUID0gKC9eWy4vXSo/XFwvL2kpO1xuXG5cdC8qKlxuXHQgKiBUaGUgUmVndWxhciBFeHByZXNzaW9uIHVzZWQgdG8gdGVzdCBmaWxlIFVSTFMgZm9yIGFuIGV4dGVuc2lvbi4gTm90ZSB0aGF0IFVSSXMgbXVzdCBhbHJlYWR5IGhhdmUgdGhlIHF1ZXJ5IHN0cmluZ1xuXHQgKiByZW1vdmVkLlxuXHQgKiBAcHJvcGVydHkgRVhURU5TSU9OX1BBVFRcblx0ICogQHR5cGUge1JlZ0V4cH1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5FWFRFTlNJT05fUEFUVCA9IC9cXC8/W14vXStcXC4oXFx3ezEsNX0pJC9pO1xuXG5cdC8qKlxuXHQgKiBQYXJzZSBhIGZpbGUgcGF0aCB0byBkZXRlcm1pbmUgdGhlIGluZm9ybWF0aW9uIHdlIG5lZWQgdG8gd29yayB3aXRoIGl0LiBDdXJyZW50bHksIFByZWxvYWRKUyBuZWVkcyB0byBrbm93OlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+SWYgdGhlIHBhdGggaXMgYWJzb2x1dGUuIEFic29sdXRlIHBhdGhzIHN0YXJ0IHdpdGggYSBwcm90b2NvbCAoc3VjaCBhcyBgaHR0cDovL2AsIGBmaWxlOi8vYCwgb3Jcblx0ICogICAgIGAvL25ldHdvcmtQYXRoYCk8L2xpPlxuXHQgKiAgICAgPGxpPklmIHRoZSBwYXRoIGlzIHJlbGF0aXZlLiBSZWxhdGl2ZSBwYXRocyBzdGFydCB3aXRoIGAuLi9gIG9yIGAvcGF0aGAgKG9yIHNpbWlsYXIpPC9saT5cblx0ICogICAgIDxsaT5UaGUgZmlsZSBleHRlbnNpb24uIFRoaXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgZmlsZW5hbWUgd2l0aCBhbiBleHRlbnNpb24uIFF1ZXJ5IHN0cmluZ3MgYXJlIGRyb3BwZWQsIGFuZFxuXHQgKiAgICAgdGhlIGZpbGUgcGF0aCBpcyBleHBlY3RlZCB0byBmb2xsb3cgdGhlIGZvcm1hdCBgbmFtZS5leHRgLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIEBtZXRob2QgcGFyc2VVUklcblx0ICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcblx0ICogQHJldHVybnMge09iamVjdH0gQW4gT2JqZWN0IHdpdGggYW4gYGFic29sdXRlYCBhbmQgYHJlbGF0aXZlYCBCb29sZWFuIHZhbHVlcywgYXMgd2VsbCBhcyBhbiBvcHRpb25hbCAnZXh0ZW5zaW9uYFxuXHQgKiBwcm9wZXJ0eSwgd2hpY2ggaXMgdGhlIGxvd2VyY2FzZSBleHRlbnNpb24uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMucGFyc2VVUkkgPSBmdW5jdGlvbiAocGF0aCkge1xuXHRcdHZhciBpbmZvID0ge2Fic29sdXRlOiBmYWxzZSwgcmVsYXRpdmU6IGZhbHNlfTtcblx0XHRpZiAocGF0aCA9PSBudWxsKSB7IHJldHVybiBpbmZvOyB9XG5cblx0XHQvLyBEcm9wIHRoZSBxdWVyeSBzdHJpbmdcblx0XHR2YXIgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZihcIj9cIik7XG5cdFx0aWYgKHF1ZXJ5SW5kZXggPiAtMSkge1xuXHRcdFx0cGF0aCA9IHBhdGguc3Vic3RyKDAsIHF1ZXJ5SW5kZXgpO1xuXHRcdH1cblxuXHRcdC8vIEFic29sdXRlXG5cdFx0dmFyIG1hdGNoO1xuXHRcdGlmIChzLkFCU09MVVRFX1BBVFQudGVzdChwYXRoKSkge1xuXHRcdFx0aW5mby5hYnNvbHV0ZSA9IHRydWU7XG5cblx0XHRcdC8vIFJlbGF0aXZlXG5cdFx0fSBlbHNlIGlmIChzLlJFTEFUSVZFX1BBVFQudGVzdChwYXRoKSkge1xuXHRcdFx0aW5mby5yZWxhdGl2ZSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gRXh0ZW5zaW9uXG5cdFx0aWYgKG1hdGNoID0gcGF0aC5tYXRjaChzLkVYVEVOU0lPTl9QQVRUKSkge1xuXHRcdFx0aW5mby5leHRlbnNpb24gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gaW5mbztcblx0fTtcblxuXHQvKipcblx0ICogRm9ybWF0cyBhbiBvYmplY3QgaW50byBhIHF1ZXJ5IHN0cmluZyBmb3IgZWl0aGVyIGEgUE9TVCBvciBHRVQgcmVxdWVzdC5cblx0ICogQG1ldGhvZCBmb3JtYXRRdWVyeVN0cmluZ1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSB0byBjb252ZXJ0IHRvIGEgcXVlcnkgc3RyaW5nLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBbcXVlcnldIEV4aXN0aW5nIG5hbWUvdmFsdWUgcGFpcnMgdG8gYXBwZW5kIG9uIHRvIHRoaXMgcXVlcnkuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuZm9ybWF0UXVlcnlTdHJpbmcgPSBmdW5jdGlvbiAoZGF0YSwgcXVlcnkpIHtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHNwZWNpZnkgZGF0YS4nKTtcblx0XHR9XG5cdFx0dmFyIHBhcmFtcyA9IFtdO1xuXHRcdGZvciAodmFyIG4gaW4gZGF0YSkge1xuXHRcdFx0cGFyYW1zLnB1c2gobiArICc9JyArIGVzY2FwZShkYXRhW25dKSk7XG5cdFx0fVxuXHRcdGlmIChxdWVyeSkge1xuXHRcdFx0cGFyYW1zID0gcGFyYW1zLmNvbmNhdChxdWVyeSk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJhbXMuam9pbignJicpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBIHV0aWxpdHkgbWV0aG9kIHRoYXQgYnVpbGRzIGEgZmlsZSBwYXRoIHVzaW5nIGEgc291cmNlIGFuZCBhIGRhdGEgb2JqZWN0LCBhbmQgZm9ybWF0cyBpdCBpbnRvIGEgbmV3IHBhdGguXG5cdCAqIEBtZXRob2QgYnVpbGRQYXRoXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBwYXRoIHRvIGFkZCB2YWx1ZXMgdG8uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gT2JqZWN0IHVzZWQgdG8gYXBwZW5kIHZhbHVlcyB0byB0aGlzIHJlcXVlc3QgYXMgYSBxdWVyeSBzdHJpbmcuIEV4aXN0aW5nIHBhcmFtZXRlcnMgb24gdGhlXG5cdCAqIHBhdGggd2lsbCBiZSBwcmVzZXJ2ZWQuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IEEgZm9ybWF0dGVkIHN0cmluZyB0aGF0IGNvbnRhaW5zIHRoZSBwYXRoIGFuZCB0aGUgc3VwcGxpZWQgcGFyYW1ldGVycy5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5idWlsZFBhdGggPSBmdW5jdGlvbiAoc3JjLCBkYXRhKSB7XG5cdFx0aWYgKGRhdGEgPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIHNyYztcblx0XHR9XG5cblx0XHR2YXIgcXVlcnkgPSBbXTtcblx0XHR2YXIgaWR4ID0gc3JjLmluZGV4T2YoJz8nKTtcblxuXHRcdGlmIChpZHggIT0gLTEpIHtcblx0XHRcdHZhciBxID0gc3JjLnNsaWNlKGlkeCArIDEpO1xuXHRcdFx0cXVlcnkgPSBxdWVyeS5jb25jYXQocS5zcGxpdCgnJicpKTtcblx0XHR9XG5cblx0XHRpZiAoaWR4ICE9IC0xKSB7XG5cdFx0XHRyZXR1cm4gc3JjLnNsaWNlKDAsIGlkeCkgKyAnPycgKyB0aGlzLmZvcm1hdFF1ZXJ5U3RyaW5nKGRhdGEsIHF1ZXJ5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHNyYyArICc/JyArIHRoaXMuZm9ybWF0UXVlcnlTdHJpbmcoZGF0YSwgcXVlcnkpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBpc0Nyb3NzRG9tYWluXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIEEgbG9hZCBpdGVtIHdpdGggYSBgc3JjYCBwcm9wZXJ0eS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIGxvYWQgaXRlbSBpcyBsb2FkaW5nIGZyb20gYSBkaWZmZXJlbnQgZG9tYWluIHRoYW4gdGhlIGN1cnJlbnQgbG9jYXRpb24uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNDcm9zc0RvbWFpbiA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0dmFyIHRhcmdldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXHRcdHRhcmdldC5ocmVmID0gaXRlbS5zcmM7XG5cblx0XHR2YXIgaG9zdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXHRcdGhvc3QuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cblx0XHR2YXIgY3Jvc3Nkb21haW4gPSAodGFyZ2V0Lmhvc3RuYW1lICE9IFwiXCIpICYmXG5cdFx0XHRcdFx0XHQgICh0YXJnZXQucG9ydCAhPSBob3N0LnBvcnQgfHxcblx0XHRcdFx0XHRcdCAgIHRhcmdldC5wcm90b2NvbCAhPSBob3N0LnByb3RvY29sIHx8XG5cdFx0XHRcdFx0XHQgICB0YXJnZXQuaG9zdG5hbWUgIT0gaG9zdC5ob3N0bmFtZSk7XG5cdFx0cmV0dXJuIGNyb3NzZG9tYWluO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGlzTG9jYWxcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gQSBsb2FkIGl0ZW0gd2l0aCBhIGBzcmNgIHByb3BlcnR5XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBsb2FkIGl0ZW0gaXMgbG9hZGluZyBmcm9tIHRoZSBcImZpbGU6XCIgcHJvdG9jb2wuIEFzc3VtZSB0aGF0IHRoZSBob3N0IG11c3QgYmUgbG9jYWwgYXNcblx0ICogd2VsbC5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pc0xvY2FsID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHR2YXIgdGFyZ2V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG5cdFx0dGFyZ2V0LmhyZWYgPSBpdGVtLnNyYztcblx0XHRyZXR1cm4gdGFyZ2V0Lmhvc3RuYW1lID09IFwiXCIgJiYgdGFyZ2V0LnByb3RvY29sID09IFwiZmlsZTpcIjtcblx0fTtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgdHlwZSBzaG91bGQgYmUgbG9hZGVkIGFzIGEgYmluYXJ5IGZpbGUuIEN1cnJlbnRseSwgb25seSBpbWFnZXMgYW5kIGl0ZW1zIG1hcmtlZFxuXHQgKiBzcGVjaWZpY2FsbHkgYXMgXCJiaW5hcnlcIiBhcmUgbG9hZGVkIGFzIGJpbmFyeS4gTm90ZSB0aGF0IGF1ZGlvIGlzIDxiPm5vdDwvYj4gYSBiaW5hcnkgdHlwZSwgYXMgd2UgY2FuIG5vdCBwbGF5XG5cdCAqIGJhY2sgdXNpbmcgYW4gYXVkaW8gdGFnIGlmIGl0IGlzIGxvYWRlZCBhcyBiaW5hcnkuIFBsdWdpbnMgY2FuIGNoYW5nZSB0aGUgaXRlbSB0eXBlIHRvIGJpbmFyeSB0byBlbnN1cmUgdGhleSBnZXRcblx0ICogYSBiaW5hcnkgcmVzdWx0IHRvIHdvcmsgd2l0aC4gQmluYXJ5IGZpbGVzIGFyZSBsb2FkZWQgdXNpbmcgWEhSMi4gVHlwZXMgYXJlIGRlZmluZWQgYXMgc3RhdGljIGNvbnN0YW50cyBvblxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBpc0JpbmFyeVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgaXRlbSB0eXBlLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgc3BlY2lmaWVkIHR5cGUgaXMgYmluYXJ5LlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzQmluYXJ5ID0gZnVuY3Rpb24gKHR5cGUpIHtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSU1BR0U6XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkJJTkFSWTpcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBpdGVtIGlzIGEgdmFsaWQgSFRNTEltYWdlRWxlbWVudFxuXHQgKiBAbWV0aG9kIGlzSW1hZ2VUYWdcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cblx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNJbWFnZVRhZyA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIGl0ZW0gaXMgYSB2YWxpZCBIVE1MQXVkaW9FbGVtZW50XG5cdCAqIEBtZXRob2QgaXNBdWRpb1RhZ1xuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pc0F1ZGlvVGFnID0gZnVuY3Rpb24oaXRlbSkge1xuXHRcdGlmICh3aW5kb3cuSFRNTEF1ZGlvRWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIGl0ZW0gaW5zdGFuY2VvZiBIVE1MQXVkaW9FbGVtZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBpdGVtIGlzIGEgdmFsaWQgSFRNTFZpZGVvRWxlbWVudFxuXHQgKiBAbWV0aG9kIGlzVmlkZW9UYWdcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cblx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNWaWRlb1RhZyA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRpZiAod2luZG93LkhUTUxWaWRlb0VsZW1lbnQpIHtcblx0XHRcdHJldHVybiBpdGVtIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgdHlwZSBpcyBhIHRleHQtYmFzZWQgYXNzZXQsIGFuZCBzaG91bGQgYmUgbG9hZGVkIGFzIFVURi04LlxuXHQgKiBAbWV0aG9kIGlzVGV4dFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgaXRlbSB0eXBlLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgc3BlY2lmaWVkIHR5cGUgaXMgdGV4dC5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pc1RleHQgPSBmdW5jdGlvbiAodHlwZSkge1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5URVhUOlxuXHRcdFx0Y2FzZSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KU09OOlxuXHRcdFx0Y2FzZSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5NQU5JRkVTVDpcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuWE1MOlxuXHRcdFx0Y2FzZSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5DU1M6XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNWRzpcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSkFWQVNDUklQVDpcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU1BSSVRFU0hFRVQ6XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIHRoZSBvYmplY3QgdXNpbmcgY29tbW9uIGV4dGVuc2lvbnMuIE5vdGUgdGhhdCB0aGUgdHlwZSBjYW4gYmUgcGFzc2VkIGluIHdpdGggdGhlIGxvYWQgaXRlbVxuXHQgKiBpZiBpdCBpcyBhbiB1bnVzdWFsIGV4dGVuc2lvbi5cblx0ICogQG1ldGhvZCBnZXRUeXBlQnlFeHRlbnNpb25cblx0ICogQHBhcmFtIHtTdHJpbmd9IGV4dGVuc2lvbiBUaGUgZmlsZSBleHRlbnNpb24gdG8gdXNlIHRvIGRldGVybWluZSB0aGUgbG9hZCB0eXBlLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBkZXRlcm1pbmVkIGxvYWQgdHlwZSAoZm9yIGV4YW1wbGUsIDxjb2RlPkFic3RyYWN0TG9hZGVyLklNQUdFPC9jb2RlPikuIFdpbGwgcmV0dXJuIGBudWxsYCBpZlxuXHQgKiB0aGUgdHlwZSBjYW4gbm90IGJlIGRldGVybWluZWQgYnkgdGhlIGV4dGVuc2lvbi5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5nZXRUeXBlQnlFeHRlbnNpb24gPSBmdW5jdGlvbiAoZXh0ZW5zaW9uKSB7XG5cdFx0aWYgKGV4dGVuc2lvbiA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVEVYVDtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKGV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0XHRjYXNlIFwianBlZ1wiOlxuXHRcdFx0Y2FzZSBcImpwZ1wiOlxuXHRcdFx0Y2FzZSBcImdpZlwiOlxuXHRcdFx0Y2FzZSBcInBuZ1wiOlxuXHRcdFx0Y2FzZSBcIndlYnBcIjpcblx0XHRcdGNhc2UgXCJibXBcIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLklNQUdFO1xuXHRcdFx0Y2FzZSBcIm9nZ1wiOlxuXHRcdFx0Y2FzZSBcIm1wM1wiOlxuXHRcdFx0Y2FzZSBcIndlYm1cIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNPVU5EO1xuXHRcdFx0Y2FzZSBcIm1wNFwiOlxuXHRcdFx0Y2FzZSBcIndlYm1cIjpcblx0XHRcdGNhc2UgXCJ0c1wiOlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVklERU87XG5cdFx0XHRjYXNlIFwianNvblwiOlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSlNPTjtcblx0XHRcdGNhc2UgXCJ4bWxcIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlhNTDtcblx0XHRcdGNhc2UgXCJjc3NcIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkNTUztcblx0XHRcdGNhc2UgXCJqc1wiOlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSkFWQVNDUklQVDtcblx0XHRcdGNhc2UgJ3N2Zyc6XG5cdFx0XHRcdHJldHVybiBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TVkc7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVEVYVDtcblx0XHR9XG5cdH07XG5cblx0Y3JlYXRlanMuUmVxdWVzdFV0aWxzID0gcztcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEFic3RyYWN0TG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuLy8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIFRoZSBiYXNlIGxvYWRlciwgd2hpY2ggZGVmaW5lcyBhbGwgdGhlIGdlbmVyaWMgbWV0aG9kcywgcHJvcGVydGllcywgYW5kIGV2ZW50cy4gQWxsIGxvYWRlcnMgZXh0ZW5kIHRoaXMgY2xhc3MsXG5cdCAqIGluY2x1ZGluZyB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAY2xhc3MgQWJzdHJhY3RMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxvYmplY3R8c3RyaW5nfSBsb2FkSXRlbSBUaGUgaXRlbSB0byBiZSBsb2FkZWQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ByZWZlclhIUl0gRGV0ZXJtaW5lcyBpZiB0aGUgTG9hZEl0ZW0gc2hvdWxkIDxlbT50cnk8L2VtPiBhbmQgbG9hZCB1c2luZyBYSFIsIG9yIHRha2UgYVxuXHQgKiB0YWctYmFzZWQgYXBwcm9hY2gsIHdoaWNoIGNhbiBiZSBiZXR0ZXIgaW4gY3Jvc3MtZG9tYWluIHNpdHVhdGlvbnMuIE5vdCBhbGwgbG9hZGVycyBjYW4gbG9hZCB1c2luZyBvbmUgb3IgdGhlXG5cdCAqIG90aGVyLCBzbyB0aGlzIGlzIGEgc3VnZ2VzdGVkIGRpcmVjdGl2ZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSBUaGUgdHlwZSBvZiBsb2FkZXIuIExvYWRlciB0eXBlcyBhcmUgZGVmaW5lZCBhcyBjb25zdGFudHMgb24gdGhlIEFic3RyYWN0TG9hZGVyIGNsYXNzLFxuXHQgKiBzdWNoIGFzIHt7I2Nyb3NzTGluayBcIklNQUdFOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJDU1M6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0sIGV0Yy5cblx0ICogQGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXG5cdCAqL1xuXHRmdW5jdGlvbiBBYnN0cmFjdExvYWRlcihsb2FkSXRlbSwgcHJlZmVyWEhSLCB0eXBlKSB7XG5cdFx0dGhpcy5FdmVudERpc3BhdGNoZXJfY29uc3RydWN0b3IoKTtcblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogSWYgdGhlIGxvYWRlciBoYXMgY29tcGxldGVkIGxvYWRpbmcuIFRoaXMgcHJvdmlkZXMgYSBxdWljayBjaGVjaywgYnV0IGFsc28gZW5zdXJlcyB0aGF0IHRoZSBkaWZmZXJlbnQgYXBwcm9hY2hlc1xuXHRcdCAqIHVzZWQgZm9yIGxvYWRpbmcgZG8gbm90IHBpbGUgdXAgcmVzdWx0aW5nIGluIG1vcmUgdGhhbiBvbmUgYGNvbXBsZXRlYCB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgbG9hZGVkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmxvYWRlZCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lIGlmIHRoZSBsb2FkZXIgd2FzIGNhbmNlbGVkLiBDYW5jZWxlZCBsb2FkcyB3aWxsIG5vdCBmaXJlIGNvbXBsZXRlIGV2ZW50cy4gTm90ZSB0aGF0IHRoaXMgcHJvcGVydHlcblx0XHQgKiBpcyByZWFkb25seSwgc28ge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319IHF1ZXVlcyBzaG91bGQgYmUgY2xvc2VkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9jbG9zZVwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIGluc3RlYWQuXG5cdFx0ICogQHByb3BlcnR5IGNhbmNlbGVkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLmNhbmNlbGVkID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgY3VycmVudCBsb2FkIHByb2dyZXNzIChwZXJjZW50YWdlKSBmb3IgdGhpcyBpdGVtLiBUaGlzIHdpbGwgYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLlxuXHRcdCAqXG5cdFx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHRcdCAqXG5cdFx0ICogICAgIHZhciBxdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUoKTtcblx0XHQgKiAgICAgcXVldWUubG9hZEZpbGUoXCJsYXJnZUltYWdlLnBuZ1wiKTtcblx0XHQgKiAgICAgcXVldWUub24oXCJwcm9ncmVzc1wiLCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICAgIGNvbnNvbGUubG9nKFwiUHJvZ3Jlc3M6XCIsIHF1ZXVlLnByb2dyZXNzLCBldmVudC5wcm9ncmVzcyk7XG5cdFx0ICogICAgIH0pO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHByb2dyZXNzXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5wcm9ncmVzcyA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdHlwZSBvZiBpdGVtIHRoaXMgbG9hZGVyIHdpbGwgbG9hZC4gU2VlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhIGZ1bGwgbGlzdCBvZlxuXHRcdCAqIHN1cHBvcnRlZCB0eXBlcy5cblx0XHQgKiBAcHJvcGVydHkgdHlwZVxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblxuXHRcdC8qKlxuXHRcdCAqIEEgZm9ybWF0dGVyIGZ1bmN0aW9uIHRoYXQgY29udmVydHMgdGhlIGxvYWRlZCByYXcgcmVzdWx0IGludG8gdGhlIGZpbmFsIHJlc3VsdC4gRm9yIGV4YW1wbGUsIHRoZSBKU09OTG9hZGVyXG5cdFx0ICogY29udmVydHMgYSBzdHJpbmcgb2YgdGV4dCBpbnRvIGEgSmF2YVNjcmlwdCBvYmplY3QuIE5vdCBhbGwgbG9hZGVycyBoYXZlIGEgcmVzdWx0Rm9ybWF0dGVyLCBhbmQgdGhpcyBwcm9wZXJ0eVxuXHRcdCAqIGNhbiBiZSBvdmVycmlkZGVuIHRvIHByb3ZpZGUgY3VzdG9tIGZvcm1hdHRpbmcuXG5cdFx0ICpcblx0XHQgKiBPcHRpb25hbGx5LCBhIHJlc3VsdEZvcm1hdHRlciBjYW4gcmV0dXJuIGEgY2FsbGJhY2sgZnVuY3Rpb24gaW4gY2FzZXMgd2hlcmUgdGhlIGZvcm1hdHRpbmcgbmVlZHMgdG8gYmVcblx0XHQgKiBhc3luY2hyb25vdXMsIHN1Y2ggYXMgY3JlYXRpbmcgYSBuZXcgaW1hZ2UuIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBwYXNzZWQgMiBwYXJhbWV0ZXJzLCB3aGljaCBhcmUgY2FsbGJhY2tzXG5cdFx0ICogdG8gaGFuZGxlIHN1Y2Nlc3MgYW5kIGVycm9yIGNvbmRpdGlvbnMgaW4gdGhlIHJlc3VsdEZvcm1hdHRlci4gTm90ZSB0aGF0IHRoZSByZXN1bHRGb3JtYXR0ZXIgbWV0aG9kIGlzXG5cdFx0ICogY2FsbGVkIGluIHRoZSBjdXJyZW50IHNjb3BlLCBhcyB3ZWxsIGFzIHRoZSBzdWNjZXNzIGFuZCBlcnJvciBjYWxsYmFja3MuXG5cdFx0ICpcblx0XHQgKiA8aDQ+RXhhbXBsZSBhc3luY2hyb25vdXMgcmVzdWx0Rm9ybWF0dGVyPC9oND5cblx0XHQgKlxuXHRcdCAqIFx0ZnVuY3Rpb24gX2Zvcm1hdFJlc3VsdChsb2FkZXIpIHtcblx0XHQgKiBcdFx0cmV0dXJuIGZ1bmN0aW9uKHN1Y2Nlc3MsIGVycm9yKSB7XG5cdFx0ICogXHRcdFx0aWYgKGVycm9yQ29uZGl0aW9uKSB7IGVycm9yKGVycm9yRGV0YWlsRXZlbnQpOyB9XG5cdFx0ICogXHRcdFx0c3VjY2VzcyhyZXN1bHQpO1xuXHRcdCAqIFx0XHR9XG5cdFx0ICogXHR9XG5cdFx0ICogQHByb3BlcnR5IHJlc3VsdEZvcm1hdHRlclxuXHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5yZXN1bHRGb3JtYXR0ZXIgPSBudWxsO1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBUaGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0gdGhpcyBsb2FkZXIgcmVwcmVzZW50cy4gTm90ZSB0aGF0IHRoaXMgaXMgbnVsbCBpbiBhIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSxcblx0XHQgKiBidXQgd2lsbCBiZSBhdmFpbGFibGUgb24gbG9hZGVycyBzdWNoIGFzIHt7I2Nyb3NzTGluayBcIlhNTExvYWRlclwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiSW1hZ2VMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IF9pdGVtXG5cdFx0ICogQHR5cGUge0xvYWRJdGVtfE9iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGlmIChsb2FkSXRlbSkge1xuXHRcdFx0dGhpcy5faXRlbSA9IGNyZWF0ZWpzLkxvYWRJdGVtLmNyZWF0ZShsb2FkSXRlbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2l0ZW0gPSBudWxsO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdGhlIGxvYWRlciB3aWxsIHRyeSBhbmQgbG9hZCBjb250ZW50IHVzaW5nIFhIUiAodHJ1ZSkgb3IgSFRNTCB0YWdzIChmYWxzZSkuXG5cdFx0ICogQHByb3BlcnR5IF9wcmVmZXJYSFJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3ByZWZlclhIUiA9IHByZWZlclhIUjtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsb2FkZWQgcmVzdWx0IGFmdGVyIGl0IGlzIGZvcm1hdHRlZCBieSBhbiBvcHRpb25hbCB7eyNjcm9zc0xpbmsgXCJyZXN1bHRGb3JtYXR0ZXJcIn19e3svY3Jvc3NMaW5rfX0uIEZvclxuXHRcdCAqIGl0ZW1zIHRoYXQgYXJlIG5vdCBmb3JtYXR0ZWQsIHRoaXMgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUge3sjY3Jvc3NMaW5rIFwiX3Jhd1Jlc3VsdDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBUaGUgcmVzdWx0IGlzIGFjY2Vzc2VkIHVzaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJnZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmVzdWx0XG5cdFx0ICogQHR5cGUge09iamVjdHxTdHJpbmd9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9yZXN1bHQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxvYWRlZCByZXN1bHQgYmVmb3JlIGl0IGlzIGZvcm1hdHRlZC4gVGhlIHJhd1Jlc3VsdCBpcyBhY2Nlc3NlZCB1c2luZyB0aGUge3sjY3Jvc3NMaW5rIFwiZ2V0UmVzdWx0XCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogbWV0aG9kLCBhbmQgcGFzc2luZyBgdHJ1ZWAuXG5cdFx0ICogQHByb3BlcnR5IF9yYXdSZXN1bHRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fFN0cmluZ31cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3Jhd1Jlc3VsdCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBIGxpc3Qgb2YgaXRlbXMgdGhhdCBsb2FkZXJzIGxvYWQgYmVoaW5kIHRoZSBzY2VuZXMuIFRoaXMgZG9lcyBub3QgaW5jbHVkZSB0aGUgbWFpbiBpdGVtIHRoZSBsb2FkZXIgaXNcblx0XHQgKiByZXNwb25zaWJsZSBmb3IgbG9hZGluZy4gRXhhbXBsZXMgb2YgbG9hZGVycyB0aGF0IGhhdmUgc3ViLWl0ZW1zIGluY2x1ZGUgdGhlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGFuZFxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZEl0ZW1zXG5cdFx0ICogQHR5cGUge251bGx9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRlZEl0ZW1zID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBhdHRyaWJ1dGUgdGhlIGl0ZW1zIGxvYWRlZCB1c2luZyB0YWdzIHVzZSBmb3IgdGhlIHNvdXJjZS5cblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBbiBIVE1MIHRhZyAob3Igc2ltaWxhcikgdGhhdCBhIGxvYWRlciBtYXkgdXNlIHRvIGxvYWQgSFRNTCBjb250ZW50LCBzdWNoIGFzIGltYWdlcywgc2NyaXB0cywgZXRjLlxuXHRcdCAqIEBwcm9wZXJ0eSBfdGFnXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3RhZyA9IG51bGw7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQWJzdHJhY3RMb2FkZXIsIGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlcik7XG5cdHZhciBzID0gQWJzdHJhY3RMb2FkZXI7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuXHQvKipcblx0ICogRGVmaW5lcyBhIFBPU1QgcmVxdWVzdCwgdXNlIGZvciBhIG1ldGhvZCB2YWx1ZSB3aGVuIGxvYWRpbmcgZGF0YS5cblx0ICogQHByb3BlcnR5IFBPU1Rcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICogQGRlZmF1bHQgcG9zdFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLlBPU1QgPSBcIlBPU1RcIjtcblxuXHQvKipcblx0ICogRGVmaW5lcyBhIEdFVCByZXF1ZXN0LCB1c2UgZm9yIGEgbWV0aG9kIHZhbHVlIHdoZW4gbG9hZGluZyBkYXRhLlxuXHQgKiBAcHJvcGVydHkgR0VUXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGdldFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLkdFVCA9IFwiR0VUXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIGdlbmVyaWMgYmluYXJ5IHR5cGVzLiBOb3RlIHRoYXQgaW1hZ2VzIGFyZSBsb2FkZWQgYXMgYmluYXJ5IGZpbGVzIHdoZW4gdXNpbmcgWEhSLlxuXHQgKiBAcHJvcGVydHkgQklOQVJZXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGJpbmFyeVxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5CSU5BUlkgPSBcImJpbmFyeVwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBjc3MgZmlsZXMuIENTUyBmaWxlcyBhcmUgbG9hZGVkIHVzaW5nIGEgJmx0O2xpbmsmZ3Q7IHdoZW4gbG9hZGVkIHdpdGggWEhSLCBvciBhXG5cdCAqICZsdDtzdHlsZSZndDsgdGFnIHdoZW4gbG9hZGVkIHdpdGggdGFncy5cblx0ICogQHByb3BlcnR5IENTU1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBjc3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuQ1NTID0gXCJjc3NcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgaW1hZ2UgZmlsZXMsIHVzdWFsbHkgcG5nLCBnaWYsIG9yIGpwZy9qcGVnLiBJbWFnZXMgYXJlIGxvYWRlZCBpbnRvIGFuICZsdDtpbWFnZSZndDsgdGFnLlxuXHQgKiBAcHJvcGVydHkgSU1BR0Vcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgaW1hZ2Vcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuSU1BR0UgPSBcImltYWdlXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIGphdmFzY3JpcHQgZmlsZXMsIHVzdWFsbHkgd2l0aCB0aGUgXCJqc1wiIGZpbGUgZXh0ZW5zaW9uLiBKYXZhU2NyaXB0IGZpbGVzIGFyZSBsb2FkZWQgaW50byBhXG5cdCAqICZsdDtzY3JpcHQmZ3Q7IHRhZy5cblx0ICpcblx0ICogU2luY2UgdmVyc2lvbiAwLjQuMSssIGR1ZSB0byBob3cgdGFnLWxvYWRlZCBzY3JpcHRzIHdvcmssIGFsbCBKYXZhU2NyaXB0IGZpbGVzIGFyZSBhdXRvbWF0aWNhbGx5IGluamVjdGVkIGludG9cblx0ICogdGhlIGJvZHkgb2YgdGhlIGRvY3VtZW50IHRvIG1haW50YWluIHBhcml0eSBiZXR3ZWVuIFhIUiBhbmQgdGFnLWxvYWRlZCBzY3JpcHRzLiBJbiB2ZXJzaW9uIDAuNC4wIGFuZCBlYXJsaWVyLFxuXHQgKiBvbmx5IHRhZy1sb2FkZWQgc2NyaXB0cyBhcmUgaW5qZWN0ZWQuXG5cdCAqIEBwcm9wZXJ0eSBKQVZBU0NSSVBUXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGphdmFzY3JpcHRcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuSkFWQVNDUklQVCA9IFwiamF2YXNjcmlwdFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBqc29uIGZpbGVzLCB1c3VhbGx5IHdpdGggdGhlIFwianNvblwiIGZpbGUgZXh0ZW5zaW9uLiBKU09OIGRhdGEgaXMgbG9hZGVkIGFuZCBwYXJzZWQgaW50byBhXG5cdCAqIEphdmFTY3JpcHQgb2JqZWN0LiBOb3RlIHRoYXQgaWYgYSBgY2FsbGJhY2tgIGlzIHByZXNlbnQgb24gdGhlIGxvYWQgaXRlbSwgdGhlIGZpbGUgd2lsbCBiZSBsb2FkZWQgd2l0aCBKU09OUCxcblx0ICogbm8gbWF0dGVyIHdoYXQgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9wcmVmZXJYSFI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaXMgc2V0IHRvLCBhbmQgdGhlIEpTT05cblx0ICogbXVzdCBjb250YWluIGEgbWF0Y2hpbmcgd3JhcHBlciBmdW5jdGlvbi5cblx0ICogQHByb3BlcnR5IEpTT05cblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQganNvblxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5KU09OID0gXCJqc29uXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIGpzb25wIGZpbGVzLCB1c3VhbGx5IHdpdGggdGhlIFwianNvblwiIGZpbGUgZXh0ZW5zaW9uLiBKU09OIGRhdGEgaXMgbG9hZGVkIGFuZCBwYXJzZWQgaW50byBhXG5cdCAqIEphdmFTY3JpcHQgb2JqZWN0LiBZb3UgYXJlIHJlcXVpcmVkIHRvIHBhc3MgYSBjYWxsYmFjayBwYXJhbWV0ZXIgdGhhdCBtYXRjaGVzIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGluIHRoZSBKU09OLlxuXHQgKiBOb3RlIHRoYXQgSlNPTlAgd2lsbCBhbHdheXMgYmUgdXNlZCBpZiB0aGVyZSBpcyBhIGNhbGxiYWNrIHByZXNlbnQsIG5vIG1hdHRlciB3aGF0IHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvcHJlZmVyWEhSOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHByb3BlcnR5IGlzIHNldCB0by5cblx0ICogQHByb3BlcnR5IEpTT05QXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGpzb25wXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLkpTT05QID0gXCJqc29ucFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBqc29uLWJhc2VkIG1hbmlmZXN0IGZpbGVzLCB1c3VhbGx5IHdpdGggdGhlIFwianNvblwiIGZpbGUgZXh0ZW5zaW9uLiBUaGUgSlNPTiBkYXRhIGlzIGxvYWRlZFxuXHQgKiBhbmQgcGFyc2VkIGludG8gYSBKYXZhU2NyaXB0IG9iamVjdC4gUHJlbG9hZEpTIHdpbGwgdGhlbiBsb29rIGZvciBhIFwibWFuaWZlc3RcIiBwcm9wZXJ0eSBpbiB0aGUgSlNPTiwgd2hpY2ggaXMgYW5cblx0ICogQXJyYXkgb2YgZmlsZXMgdG8gbG9hZCwgZm9sbG93aW5nIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuIElmIGEgXCJjYWxsYmFja1wiIGlzIHNwZWNpZmllZCBvbiB0aGUgbWFuaWZlc3Qgb2JqZWN0LCB0aGVuIGl0IHdpbGwgYmUgbG9hZGVkIHVzaW5nIEpTT05QIGluc3RlYWQsXG5cdCAqIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3ByZWZlclhIUjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpcyBzZXQgdG8uXG5cdCAqIEBwcm9wZXJ0eSBNQU5JRkVTVFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBtYW5pZmVzdFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5NQU5JRkVTVCA9IFwibWFuaWZlc3RcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3Igc291bmQgZmlsZXMsIHVzdWFsbHkgbXAzLCBvZ2csIG9yIHdhdi4gV2hlbiBsb2FkaW5nIHZpYSB0YWdzLCBhdWRpbyBpcyBsb2FkZWQgaW50byBhblxuXHQgKiAmbHQ7YXVkaW8mZ3Q7IHRhZy5cblx0ICogQHByb3BlcnR5IFNPVU5EXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHNvdW5kXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLlNPVU5EID0gXCJzb3VuZFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciB2aWRlbyBmaWxlcywgdXN1YWxseSBtcDQsIHRzLCBvciBvZ2cuIFdoZW4gbG9hZGluZyB2aWEgdGFncywgdmlkZW8gaXMgbG9hZGVkIGludG8gYW5cblx0ICogJmx0O3ZpZGVvJmd0OyB0YWcuXG5cdCAqIEBwcm9wZXJ0eSBWSURFT1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCB2aWRlb1xuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5WSURFTyA9IFwidmlkZW9cIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgU3ByaXRlU2hlZXQgZmlsZXMuIFNwcml0ZVNoZWV0IGZpbGVzIGFyZSBKU09OIGZpbGVzIHRoYXQgY29udGFpbiBzdHJpbmcgaW1hZ2UgcGF0aHMuXG5cdCAqIEBwcm9wZXJ0eSBTUFJJVEVTSEVFVFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBzcHJpdGVzaGVldFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5TUFJJVEVTSEVFVCA9IFwic3ByaXRlc2hlZXRcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgU1ZHIGZpbGVzLlxuXHQgKiBAcHJvcGVydHkgU1ZHXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHN2Z1xuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5TVkcgPSBcInN2Z1wiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciB0ZXh0IGZpbGVzLCB3aGljaCBpcyBhbHNvIHRoZSBkZWZhdWx0IGZpbGUgdHlwZSBpZiB0aGUgdHlwZSBjYW4gbm90IGJlIGRldGVybWluZWQuIFRleHQgaXNcblx0ICogbG9hZGVkIGFzIHJhdyB0ZXh0LlxuXHQgKiBAcHJvcGVydHkgVEVYVFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCB0ZXh0XG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLlRFWFQgPSBcInRleHRcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgeG1sIGZpbGVzLiBYTUwgaXMgbG9hZGVkIGludG8gYW4gWE1MIGRvY3VtZW50LlxuXHQgKiBAcHJvcGVydHkgWE1MXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHhtbFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5YTUwgPSBcInhtbFwiO1xuXG4vLyBFdmVudHNcblx0LyoqXG5cdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJQcm9ncmVzc0V2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgd2hlbiB0aGUgb3ZlcmFsbCBwcm9ncmVzcyBjaGFuZ2VzLiBQcmlvciB0b1xuXHQgKiB2ZXJzaW9uIDAuNi4wLCB0aGlzIHdhcyBqdXN0IGEgcmVndWxhciB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQGV2ZW50IHByb2dyZXNzXG5cdCAqIEBzaW5jZSAwLjMuMFxuXHQgKi9cblxuXHQvKipcblx0ICogVGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgd2hlbiBhIGxvYWQgc3RhcnRzLlxuXHQgKiBAZXZlbnQgbG9hZHN0YXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHNpbmNlIDAuMy4xXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGUge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIHRoZSBlbnRpcmUgcXVldWUgaGFzIGJlZW4gbG9hZGVkLlxuXHQgKiBAZXZlbnQgY29tcGxldGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJFcnJvckV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgd2hlbiB0aGUgbG9hZGVyIGVuY291bnRlcnMgYW4gZXJyb3IuIElmIHRoZSBlcnJvciB3YXNcblx0ICogZW5jb3VudGVyZWQgYnkgYSBmaWxlLCB0aGUgZXZlbnQgd2lsbCBjb250YWluIHRoZSBpdGVtIHRoYXQgY2F1c2VkIHRoZSBlcnJvci4gUHJpb3IgdG8gdmVyc2lvbiAwLjYuMCwgdGhpcyB3YXNcblx0ICoganVzdCBhIHJlZ3VsYXIge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBldmVudCBlcnJvclxuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIHdoZW4gdGhlIGxvYWRlciBlbmNvdW50ZXJzIGFuIGludGVybmFsIGZpbGUgbG9hZCBlcnJvci5cblx0ICogVGhpcyBlbmFibGVzIGxvYWRlcnMgdG8gbWFpbnRhaW4gaW50ZXJuYWwgcXVldWVzLCBhbmQgc3VyZmFjZSBmaWxlIGxvYWQgZXJyb3JzLlxuXHQgKiBAZXZlbnQgZmlsZWVycm9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbiB0eXBlIChcImZpbGVlcnJvclwiKVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfG9iamVjdH0gVGhlIGl0ZW0gdGhhdCBlbmNvdW50ZXJlZCB0aGUgZXJyb3Jcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGUge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIGEgbG9hZGVyIGludGVybmFsbHkgbG9hZHMgYSBmaWxlLiBUaGlzIGVuYWJsZXNcblx0ICogbG9hZGVycyBzdWNoIGFzIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IHRvIG1haW50YWluIGludGVybmFsIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fXNcblx0ICogYW5kIG5vdGlmeSB3aGVuIHRoZXkgaGF2ZSBsb2FkZWQgYSBmaWxlLiBUaGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGRpc3BhdGNoZXMgYVxuXHQgKiBzbGlnaHRseSBkaWZmZXJlbnQge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50LlxuXHQgKiBAZXZlbnQgZmlsZWxvYWRcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlIChcImZpbGVsb2FkXCIpXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIFRoZSBmaWxlIGl0ZW0gd2hpY2ggd2FzIHNwZWNpZmllZCBpbiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG9yIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX0gY2FsbC4gSWYgb25seSBhIHN0cmluZyBwYXRoIG9yIHRhZyB3YXMgc3BlY2lmaWVkLCB0aGVcblx0ICogb2JqZWN0IHdpbGwgY29udGFpbiB0aGF0IHZhbHVlIGFzIGEgYHNyY2AgcHJvcGVydHkuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHQgVGhlIEhUTUwgdGFnIG9yIHBhcnNlZCByZXN1bHQgb2YgdGhlIGxvYWRlZCBpdGVtLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcmF3UmVzdWx0IFRoZSB1bnByb2Nlc3NlZCByZXN1bHQsIHVzdWFsbHkgdGhlIHJhdyB0ZXh0IG9yIGJpbmFyeSBkYXRhIGJlZm9yZSBpdCBpcyBjb252ZXJ0ZWRcblx0ICogdG8gYSB1c2FibGUgb2JqZWN0LlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIGFmdGVyIHRoZSBpbnRlcm5hbCByZXF1ZXN0IGlzIGNyZWF0ZWQsIGJ1dCBiZWZvcmUgYSBsb2FkLlxuXHQgKiBUaGlzIGFsbG93cyB1cGRhdGVzIHRvIHRoZSBsb2FkZXIgZm9yIHNwZWNpZmljIGxvYWRpbmcgbmVlZHMsIHN1Y2ggYXMgYmluYXJ5IG9yIFhIUiBpbWFnZSBsb2FkaW5nLlxuXHQgKiBAZXZlbnQgaW5pdGlhbGl6ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUgKFwiaW5pdGlhbGl6ZVwiKVxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXIgVGhlIGxvYWRlciB0aGF0IGhhcyBiZWVuIGluaXRpYWxpemVkLlxuXHQgKi9cblxuXG5cdC8qKlxuXHQgKiBHZXQgYSByZWZlcmVuY2UgdG8gdGhlIG1hbmlmZXN0IGl0ZW0gdGhhdCBpcyBsb2FkZWQgYnkgdGhpcyBsb2FkZXIuIEluIHNvbWUgY2FzZXMgdGhpcyB3aWxsIGJlIHRoZSB2YWx1ZSB0aGF0IHdhc1xuXHQgKiBwYXNzZWQgaW50byB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0gdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX0uIEhvd2V2ZXIgaWYgb25seSBhIFN0cmluZyBwYXRoIHdhcyBwYXNzZWQgaW4sIHRoZW4gaXQgd2lsbFxuXHQgKiBiZSBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGdldEl0ZW1cblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgbWFuaWZlc3QgaXRlbSB0aGF0IHRoaXMgbG9hZGVyIGlzIHJlc3BvbnNpYmxlIGZvciBsb2FkaW5nLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuZ2V0SXRlbSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5faXRlbTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBjb250ZW50IHRoYXQgd2FzIGxvYWRlZCBieSB0aGUgbG9hZGVyIChvbmx5IGF2YWlsYWJsZSBhZnRlciB0aGUge3sjY3Jvc3NMaW5rIFwiY29tcGxldGU6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgaXMgZGlzcGF0Y2hlZC5cblx0ICogQG1ldGhvZCBnZXRSZXN1bHRcblx0ICogQHBhcmFtIHtCb29sZWFufSBbcmF3PWZhbHNlXSBEZXRlcm1pbmVzIGlmIHRoZSByZXR1cm5lZCByZXN1bHQgd2lsbCBiZSB0aGUgZm9ybWF0dGVkIGNvbnRlbnQsIG9yIHRoZSByYXcgbG9hZGVkXG5cdCAqIGRhdGEgKGlmIGl0IGV4aXN0cykuXG5cdCAqIEByZXR1cm4ge09iamVjdH1cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmdldFJlc3VsdCA9IGZ1bmN0aW9uIChyYXcpIHtcblx0XHRyZXR1cm4gcmF3ID8gdGhpcy5fcmF3UmVzdWx0IDogdGhpcy5fcmVzdWx0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIGB0YWdgIHRoaXMgb2JqZWN0IGNyZWF0ZXMgb3IgdXNlcyBmb3IgbG9hZGluZy5cblx0ICogQG1ldGhvZCBnZXRUYWdcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgdGFnIGluc3RhbmNlXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5nZXRUYWcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RhZztcblx0fTtcblxuXHQvKipcblx0ICogU2V0IHRoZSBgdGFnYCB0aGlzIGl0ZW0gdXNlcyBmb3IgbG9hZGluZy5cblx0ICogQG1ldGhvZCBzZXRUYWdcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhZyBUaGUgdGFnIGluc3RhbmNlXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5zZXRUYWcgPSBmdW5jdGlvbih0YWcpIHtcblx0ICB0aGlzLl90YWcgPSB0YWc7XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2luIGxvYWRpbmcgdGhlIGl0ZW0uIFRoaXMgbWV0aG9kIGlzIHJlcXVpcmVkIHdoZW4gdXNpbmcgYSBsb2FkZXIgYnkgaXRzZWxmLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIHF1ZXVlID0gbmV3IGNyZWF0ZWpzLkxvYWRRdWV1ZSgpO1xuXHQgKiAgICAgIHF1ZXVlLm9uKFwiY29tcGxldGVcIiwgaGFuZGxlQ29tcGxldGUpO1xuXHQgKiAgICAgIHF1ZXVlLmxvYWRNYW5pZmVzdChmaWxlQXJyYXksIGZhbHNlKTsgLy8gTm90ZSB0aGUgMm5kIGFyZ3VtZW50IHRoYXQgdGVsbHMgdGhlIHF1ZXVlIG5vdCB0byBzdGFydCBsb2FkaW5nIHlldFxuXHQgKiAgICAgIHF1ZXVlLmxvYWQoKTtcblx0ICpcblx0ICogQG1ldGhvZCBsb2FkXG5cdCAqL1xuXHRwLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY3JlYXRlUmVxdWVzdCgpO1xuXG5cdFx0dGhpcy5fcmVxdWVzdC5vbihcImNvbXBsZXRlXCIsIHRoaXMsIHRoaXMpO1xuXHRcdHRoaXMuX3JlcXVlc3Qub24oXCJwcm9ncmVzc1wiLCB0aGlzLCB0aGlzKTtcblx0XHR0aGlzLl9yZXF1ZXN0Lm9uKFwibG9hZFN0YXJ0XCIsIHRoaXMsIHRoaXMpO1xuXHRcdHRoaXMuX3JlcXVlc3Qub24oXCJhYm9ydFwiLCB0aGlzLCB0aGlzKTtcblx0XHR0aGlzLl9yZXF1ZXN0Lm9uKFwidGltZW91dFwiLCB0aGlzLCB0aGlzKTtcblx0XHR0aGlzLl9yZXF1ZXN0Lm9uKFwiZXJyb3JcIiwgdGhpcywgdGhpcyk7XG5cblx0XHR2YXIgZXZ0ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiaW5pdGlhbGl6ZVwiKTtcblx0XHRldnQubG9hZGVyID0gdGhpcy5fcmVxdWVzdDtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuXHRcdHRoaXMuX3JlcXVlc3QubG9hZCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbG9zZSB0aGUgdGhlIGl0ZW0uIFRoaXMgd2lsbCBzdG9wIGFueSBvcGVuIHJlcXVlc3RzIChhbHRob3VnaCBkb3dubG9hZHMgdXNpbmcgSFRNTCB0YWdzIG1heSBzdGlsbCBjb250aW51ZSBpblxuXHQgKiB0aGUgYmFja2dyb3VuZCksIGJ1dCBldmVudHMgd2lsbCBub3QgbG9uZ2VyIGJlIGRpc3BhdGNoZWQuXG5cdCAqIEBtZXRob2QgY2FuY2VsXG5cdCAqL1xuXHRwLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmNhbmNlbGVkID0gdHJ1ZTtcblx0XHR0aGlzLmRlc3Ryb3koKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2xlYW4gdXAgdGhlIGxvYWRlci5cblx0ICogQG1ldGhvZCBkZXN0cm95XG5cdCAqL1xuXHRwLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fcmVxdWVzdCkge1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVBbGxFdmVudExpc3RlbmVycygpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5kZXN0cm95KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcmVxdWVzdCA9IG51bGw7XG5cblx0XHR0aGlzLl9pdGVtID0gbnVsbDtcblx0XHR0aGlzLl9yYXdSZXN1bHQgPSBudWxsO1xuXHRcdHRoaXMuX3Jlc3VsdCA9IG51bGw7XG5cblx0XHR0aGlzLl9sb2FkSXRlbXMgPSBudWxsO1xuXG5cdFx0dGhpcy5yZW1vdmVBbGxFdmVudExpc3RlbmVycygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgYW55IGl0ZW1zIGxvYWRlZCBpbnRlcm5hbGx5IGJ5IHRoZSBsb2FkZXIuIFRoZSBlbmFibGVzIGxvYWRlcnMgc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB0byBleHBvc2UgaXRlbXMgaXQgbG9hZHMgaW50ZXJuYWxseS5cblx0ICogQG1ldGhvZCBnZXRMb2FkZWRJdGVtc1xuXHQgKiBAcmV0dXJuIHtBcnJheX0gQSBsaXN0IG9mIHRoZSBpdGVtcyBsb2FkZWQgYnkgdGhlIGxvYWRlci5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmdldExvYWRlZEl0ZW1zID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sb2FkZWRJdGVtcztcblx0fTtcblxuXG5cdC8vIFByaXZhdGUgbWV0aG9kc1xuXHQvKipcblx0ICogQ3JlYXRlIGFuIGludGVybmFsIHJlcXVlc3QgdXNlZCBmb3IgbG9hZGluZy4gQnkgZGVmYXVsdCwgYW4ge3sjY3Jvc3NMaW5rIFwiWEhSUmVxdWVzdFwifX17ey9jcm9zc0xpbmt9fSBvclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJUYWdSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319IGlzIGNyZWF0ZWQsIGRlcGVuZGluZyBvbiB0aGUgdmFsdWUgb2Yge3sjY3Jvc3NMaW5rIFwicHJlZmVyWEhSOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBPdGhlciBsb2FkZXJzIG1heSBvdmVycmlkZSB0aGlzIHRvIHVzZSBkaWZmZXJlbnQgcmVxdWVzdCB0eXBlcywgc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogd2hpY2ggdXNlcyB7eyNjcm9zc0xpbmsgXCJKU09OTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IG9yIHt7I2Nyb3NzTGluayBcIkpTT05QTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IHVuZGVyIHRoZSBob29kLlxuXHQgKiBAbWV0aG9kIF9jcmVhdGVSZXF1ZXN0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2NyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX3ByZWZlclhIUikge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5UYWdSZXF1ZXN0KHRoaXMuX2l0ZW0sIHRoaXMuX3RhZyB8fCB0aGlzLl9jcmVhdGVUYWcoKSwgdGhpcy5fdGFnU3JjQXR0cmlidXRlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5YSFJSZXF1ZXN0KHRoaXMuX2l0ZW0pO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIHRoZSBIVE1MIHRhZyB1c2VkIGZvciBsb2FkaW5nLiBUaGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcgYnkgZGVmYXVsdCwgYW5kIG5lZWRzIHRvIGJlIGltcGxlbWVudGVkXG5cdCAqIGJ5IGxvYWRlcnMgdGhhdCByZXF1aXJlIHRhZyBsb2FkaW5nLlxuXHQgKiBAbWV0aG9kIF9jcmVhdGVUYWdcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgdGFnIHNvdXJjZVxuXHQgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gVGhlIHRhZyB0aGF0IHdhcyBjcmVhdGVkXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2NyZWF0ZVRhZyA9IGZ1bmN0aW9uKHNyYykgeyByZXR1cm4gbnVsbDsgfTtcblxuXHQvKipcblx0ICogRGlzcGF0Y2ggYSBsb2Fkc3RhcnQge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2xvYWRzdGFydDpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBmb3IgZGV0YWlscyBvbiB0aGUgZXZlbnQgcGF5bG9hZC5cblx0ICogQG1ldGhvZCBfc2VuZExvYWRTdGFydFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZW5kTG9hZFN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9pc0NhbmNlbGVkKCkpIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwibG9hZHN0YXJ0XCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhIHt7I2Nyb3NzTGluayBcIlByb2dyZXNzRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgX3NlbmRQcm9ncmVzc1xuXHQgKiBAcGFyYW0ge051bWJlciB8IE9iamVjdH0gdmFsdWUgVGhlIHByb2dyZXNzIG9mIHRoZSBsb2FkZWQgaXRlbSwgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcgPGNvZGU+bG9hZGVkPC9jb2RlPlxuXHQgKiBhbmQgPGNvZGU+dG90YWw8L2NvZGU+IHByb3BlcnRpZXMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3NlbmRQcm9ncmVzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmICh0aGlzLl9pc0NhbmNlbGVkKCkpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIGV2ZW50ID0gbnVsbDtcblx0XHRpZiAodHlwZW9mKHZhbHVlKSA9PSBcIm51bWJlclwiKSB7XG5cdFx0XHR0aGlzLnByb2dyZXNzID0gdmFsdWU7XG5cdFx0XHRldmVudCA9IG5ldyBjcmVhdGVqcy5Qcm9ncmVzc0V2ZW50KHRoaXMucHJvZ3Jlc3MpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRldmVudCA9IHZhbHVlO1xuXHRcdFx0dGhpcy5wcm9ncmVzcyA9IHZhbHVlLmxvYWRlZCAvIHZhbHVlLnRvdGFsO1xuXHRcdFx0ZXZlbnQucHJvZ3Jlc3MgPSB0aGlzLnByb2dyZXNzO1xuXHRcdFx0aWYgKGlzTmFOKHRoaXMucHJvZ3Jlc3MpIHx8IHRoaXMucHJvZ3Jlc3MgPT0gSW5maW5pdHkpIHsgdGhpcy5wcm9ncmVzcyA9IDA7IH1cblx0XHR9XG5cdFx0dGhpcy5oYXNFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIikgJiYgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRGlzcGF0Y2ggYSBjb21wbGV0ZSB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvY29tcGxldGU6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnRcblx0ICogQG1ldGhvZCBfc2VuZENvbXBsZXRlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3NlbmRDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5faXNDYW5jZWxlZCgpKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5sb2FkZWQgPSB0cnVlO1xuXG5cdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiY29tcGxldGVcIik7XG5cdFx0ZXZlbnQucmF3UmVzdWx0ID0gdGhpcy5fcmF3UmVzdWx0O1xuXG5cdFx0aWYgKHRoaXMuX3Jlc3VsdCAhPSBudWxsKSB7XG5cdFx0XHRldmVudC5yZXN1bHQgPSB0aGlzLl9yZXN1bHQ7XG5cdFx0fVxuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRGlzcGF0Y2ggYW4gZXJyb3Ige3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2Vycm9yOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IGZvciBkZXRhaWxzIG9uIHRoZSBldmVudCBwYXlsb2FkLlxuXHQgKiBAbWV0aG9kIF9zZW5kRXJyb3Jcblx0ICogQHBhcmFtIHtFcnJvckV2ZW50fSBldmVudCBUaGUgZXZlbnQgb2JqZWN0IGNvbnRhaW5pbmcgc3BlY2lmaWMgZXJyb3IgcHJvcGVydGllcy5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2VuZEVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuX2lzQ2FuY2VsZWQoKSB8fCAhdGhpcy5oYXNFdmVudExpc3RlbmVyKFwiZXJyb3JcIikpIHsgcmV0dXJuOyB9XG5cdFx0aWYgKGV2ZW50ID09IG51bGwpIHtcblx0XHRcdGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJQUkVMT0FEX0VSUk9SX0VNUFRZXCIpOyAvLyBUT0RPOiBQb3B1bGF0ZSBlcnJvclxuXHRcdH1cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgdGhlIGxvYWQgaGFzIGJlZW4gY2FuY2VsZWQuIFRoaXMgaXMgaW1wb3J0YW50IHRvIGVuc3VyZSB0aGF0IG1ldGhvZCBjYWxscyBvciBhc3luY2hyb25vdXMgZXZlbnRzXG5cdCAqIGRvIG5vdCBjYXVzZSBpc3N1ZXMgYWZ0ZXIgdGhlIHF1ZXVlIGhhcyBiZWVuIGNsZWFuZWQgdXAuXG5cdCAqIEBtZXRob2QgX2lzQ2FuY2VsZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIGxvYWRlciBoYXMgYmVlbiBjYW5jZWxlZC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5faXNDYW5jZWxlZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAod2luZG93LmNyZWF0ZWpzID09IG51bGwgfHwgdGhpcy5jYW5jZWxlZCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0ICogQSBjdXN0b20gcmVzdWx0IGZvcm1hdHRlciBmdW5jdGlvbiwgd2hpY2ggaXMgY2FsbGVkIGp1c3QgYmVmb3JlIGEgcmVxdWVzdCBkaXNwYXRjaGVzIGl0cyBjb21wbGV0ZSBldmVudC4gTW9zdFxuXHQgKiBsb2FkZXIgdHlwZXMgYWxyZWFkeSBoYXZlIGFuIGludGVybmFsIGZvcm1hdHRlciwgYnV0IHRoaXMgY2FuIGJlIHVzZXItb3ZlcnJpZGRlbiBmb3IgY3VzdG9tIGZvcm1hdHRpbmcuIFRoZVxuXHQgKiBmb3JtYXR0ZWQgcmVzdWx0IHdpbGwgYmUgYXZhaWxhYmxlIG9uIExvYWRlcnMgdXNpbmcge3sjY3Jvc3NMaW5rIFwiZ2V0UmVzdWx0XCJ9fXt7L2Nyb3NzTGlua319LCBhbmQgcGFzc2luZyBgdHJ1ZWAuXG5cdCAqIEBwcm9wZXJ0eSByZXN1bHRGb3JtYXR0ZXJcblx0ICogQHR5cGUgRnVuY3Rpb25cblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZm9ybWF0dGVkIHJlc3VsdFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAucmVzdWx0Rm9ybWF0dGVyID0gbnVsbDtcblxuXHQvKipcblx0ICogSGFuZGxlIGV2ZW50cyBmcm9tIGludGVybmFsIHJlcXVlc3RzLiBCeSBkZWZhdWx0LCBsb2FkZXJzIHdpbGwgaGFuZGxlLCBhbmQgcmVkaXNwYXRjaCB0aGUgbmVjZXNzYXJ5IGV2ZW50cywgYnV0XG5cdCAqIHRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIGZvciBjdXN0b20gYmVoYXZpb3Vycy5cblx0ICogQG1ldGhvZCBoYW5kbGVFdmVudFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdGhhdCB0aGUgaW50ZXJuYWwgcmVxdWVzdCBkaXNwYXRjaGVzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHN3aXRjaCAoZXZlbnQudHlwZSkge1xuXHRcdFx0Y2FzZSBcImNvbXBsZXRlXCI6XG5cdFx0XHRcdHRoaXMuX3Jhd1Jlc3VsdCA9IGV2ZW50LnRhcmdldC5fcmVzcG9uc2U7XG5cdFx0XHRcdHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdEZvcm1hdHRlciAmJiB0aGlzLnJlc3VsdEZvcm1hdHRlcih0aGlzKTtcblx0XHRcdFx0aWYgKHJlc3VsdCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRcdFx0cmVzdWx0LmNhbGwodGhpcyxcblx0XHRcdFx0XHRcdFx0Y3JlYXRlanMucHJveHkodGhpcy5fcmVzdWx0Rm9ybWF0U3VjY2VzcywgdGhpcyksXG5cdFx0XHRcdFx0XHRcdGNyZWF0ZWpzLnByb3h5KHRoaXMuX3Jlc3VsdEZvcm1hdEZhaWxlZCwgdGhpcylcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3Jlc3VsdCA9ICByZXN1bHQgfHwgdGhpcy5fcmF3UmVzdWx0O1xuXHRcdFx0XHRcdHRoaXMuX3NlbmRDb21wbGV0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInByb2dyZXNzXCI6XG5cdFx0XHRcdHRoaXMuX3NlbmRQcm9ncmVzcyhldmVudCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImVycm9yXCI6XG5cdFx0XHRcdHRoaXMuX3NlbmRFcnJvcihldmVudCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImxvYWRzdGFydFwiOlxuXHRcdFx0XHR0aGlzLl9zZW5kTG9hZFN0YXJ0KCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImFib3J0XCI6XG5cdFx0XHRjYXNlIFwidGltZW91dFwiOlxuXHRcdFx0XHRpZiAoIXRoaXMuX2lzQ2FuY2VsZWQoKSkge1xuXHRcdFx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlBSRUxPQURfXCIgKyBldmVudC50eXBlLnRvVXBwZXJDYXNlKCkgKyBcIl9FUlJPUlwiKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgXCJzdWNjZXNzXCIgY2FsbGJhY2sgcGFzc2VkIHRvIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL3Jlc3VsdEZvcm1hdHRlclwifX17ey9jcm9zc0xpbmt9fSBhc3luY2hyb25vdXNcblx0ICogZnVuY3Rpb25zLlxuXHQgKiBAbWV0aG9kIF9yZXN1bHRGb3JtYXRTdWNjZXNzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHQgVGhlIGZvcm1hdHRlZCByZXN1bHRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX3Jlc3VsdEZvcm1hdFN1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0dGhpcy5fcmVzdWx0ID0gcmVzdWx0O1xuXHRcdHRoaXMuX3NlbmRDb21wbGV0ZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgXCJlcnJvclwiIGNhbGxiYWNrIHBhc3NlZCB0byB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9yZXN1bHRGb3JtYXR0ZXJcIn19e3svY3Jvc3NMaW5rfX0gYXN5bmNocm9ub3VzXG5cdCAqIGZ1bmN0aW9ucy5cblx0ICogQG1ldGhvZCBfcmVzdWx0Rm9ybWF0U3VjY2Vzc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZXJyb3IgVGhlIGVycm9yIGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9yZXN1bHRGb3JtYXRGYWlsZWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLl9zZW5kRXJyb3IoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGJ1aWxkUGF0aFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiUmVxdWVzdFV0aWxzXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCB7eyNjcm9zc0xpbmsgXCJSZXF1ZXN0VXRpbHMvYnVpbGRQYXRoXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGluc3RlYWQuXG5cdCAqL1xuXHRwLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChzcmMsIGRhdGEpIHtcblx0XHRyZXR1cm4gY3JlYXRlanMuUmVxdWVzdFV0aWxzLmJ1aWxkUGF0aChzcmMsIGRhdGEpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbUHJlbG9hZEpTIEFic3RyYWN0TG9hZGVyXVwiO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShBYnN0cmFjdExvYWRlciwgXCJFdmVudERpc3BhdGNoZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBBYnN0cmFjdE1lZGlhTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogVGhlIEFic3RyYWN0TWVkaWFMb2FkZXIgaXMgYSBiYXNlIGNsYXNzIHRoYXQgaGFuZGxlcyBzb21lIG9mIHRoZSBzaGFyZWQgbWV0aG9kcyBhbmQgcHJvcGVydGllcyBvZiBsb2FkZXJzIHRoYXRcblx0ICogaGFuZGxlIEhUTUwgbWVkaWEgZWxlbWVudHMsIHN1Y2ggYXMgVmlkZW8gYW5kIEF1ZGlvLlxuXHQgKiBAY2xhc3MgQWJzdHJhY3RNZWRpYUxvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXJYSFJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgbWVkaWEgdG8gbG9hZC4gVXN1YWxseSBcInZpZGVvXCIgb3IgXCJhdWRpb1wiLlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEFic3RyYWN0TWVkaWFMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUiwgdHlwZSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgdHlwZSk7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBcInNyY1wiO1xuXG4gICAgICAgIHRoaXMub24oXCJpbml0aWFsaXplXCIsIHRoaXMuX3VwZGF0ZVhIUiwgdGhpcyk7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQWJzdHJhY3RNZWRpYUxvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXG5cdC8vIHN0YXRpYyBwcm9wZXJ0aWVzXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBUYWdSZXF1ZXN0IHdpbGwgaGFuZGxlIG1vc3Qgb2YgdGhpcywgYnV0IFNvdW5kIC8gVmlkZW8gbmVlZCBhIGZldyBjdXN0b20gcHJvcGVydGllcywgc28ganVzdCBoYW5kbGUgdGhlbSBoZXJlLlxuXHRcdGlmICghdGhpcy5fdGFnKSB7XG5cdFx0XHR0aGlzLl90YWcgPSB0aGlzLl9jcmVhdGVUYWcodGhpcy5faXRlbS5zcmMpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3RhZy5wcmVsb2FkID0gXCJhdXRvXCI7XG5cdFx0dGhpcy5fdGFnLmxvYWQoKTtcblxuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfbG9hZCgpO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHRhZyBmb3IgbG9hZGluZyBpZiBpdCBkb2Vzbid0IGV4aXN0IHlldC5cblx0ICogQG1ldGhvZCBfY3JlYXRlVGFnXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jcmVhdGVUYWcgPSBmdW5jdGlvbiAoKSB7fTtcblxuXG5cdHAuX2NyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX3ByZWZlclhIUikge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5NZWRpYVRhZ1JlcXVlc3QodGhpcy5faXRlbSwgdGhpcy5fdGFnIHx8IHRoaXMuX2NyZWF0ZVRhZygpLCB0aGlzLl90YWdTcmNBdHRyaWJ1dGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLlhIUlJlcXVlc3QodGhpcy5faXRlbSk7XG5cdFx0fVxuXHR9O1xuXG4gICAgLy8gcHJvdGVjdGVkIG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBCZWZvcmUgdGhlIGl0ZW0gbG9hZHMsIHNldCBpdHMgbWltZVR5cGUgYW5kIHJlc3BvbnNlVHlwZS5cbiAgICAgKiBAcHJvcGVydHkgX3VwZGF0ZVhIUlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl91cGRhdGVYSFIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gT25seSBleGlzdHMgZm9yIFhIUlxuICAgICAgICBpZiAoZXZlbnQubG9hZGVyLnNldFJlc3BvbnNlVHlwZSkge1xuICAgICAgICAgICAgZXZlbnQubG9hZGVyLnNldFJlc3BvbnNlVHlwZShcImJsb2JcIik7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cdC8qKlxuXHQgKiBUaGUgcmVzdWx0IGZvcm1hdHRlciBmb3IgbWVkaWEgZmlsZXMuXG5cdCAqIEBtZXRob2QgX2Zvcm1hdFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHJldHVybnMge0hUTUxWaWRlb0VsZW1lbnR8SFRNTEF1ZGlvRWxlbWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHR0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lciAmJiB0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNhbnBsYXl0aHJvdWdoXCIsIHRoaXMuX2xvYWRlZEhhbmRsZXIpO1xuXHRcdHRoaXMuX3RhZy5vbnN0YWxsZWQgPSBudWxsO1xuXHRcdGlmICh0aGlzLl9wcmVmZXJYSFIpIHtcbiAgICAgICAgICAgIHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbG9hZGVyLmdldFJlc3VsdCh0cnVlKTtcblxuXHRcdFx0bG9hZGVyLmdldFRhZygpLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwocmVzdWx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIGxvYWRlci5nZXRUYWcoKTtcblx0fTtcblxuXHRjcmVhdGVqcy5BYnN0cmFjdE1lZGlhTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShBYnN0cmFjdE1lZGlhTG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQWJzdHJhY3RSZXF1ZXN0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogQSBiYXNlIGNsYXNzIGZvciBhY3R1YWwgZGF0YSByZXF1ZXN0cywgc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJYSFJSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJUYWdSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBhbmQge3sjY3Jvc3NMaW5rIFwiTWVkaWFSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319LiBQcmVsb2FkSlMgbG9hZGVycyB3aWxsIHR5cGljYWxseSB1c2UgYSBkYXRhIGxvYWRlciB1bmRlciB0aGVcblx0ICogaG9vZCB0byBnZXQgZGF0YS5cblx0ICogQGNsYXNzIEFic3RyYWN0UmVxdWVzdFxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfSBpdGVtXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0dmFyIEFic3RyYWN0UmVxdWVzdCA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0dGhpcy5faXRlbSA9IGl0ZW07XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQWJzdHJhY3RSZXF1ZXN0LCBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIpO1xuXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBCZWdpbiBhIGxvYWQuXG5cdCAqIEBtZXRob2QgbG9hZFxuXHQgKi9cblx0cC5sb2FkID0gIGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIENsZWFuIHVwIGEgcmVxdWVzdC5cblx0ICogQG1ldGhvZCBkZXN0cm95XG5cdCAqL1xuXHRwLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qKlxuXHQgKiBDYW5jZWwgYW4gaW4tcHJvZ3Jlc3MgcmVxdWVzdC5cblx0ICogQG1ldGhvZCBjYW5jZWxcblx0ICovXG5cdHAuY2FuY2VsID0gZnVuY3Rpb24oKSB7fTtcblxuXHRjcmVhdGVqcy5BYnN0cmFjdFJlcXVlc3QgPSBjcmVhdGVqcy5wcm9tb3RlKEFic3RyYWN0UmVxdWVzdCwgXCJFdmVudERpc3BhdGNoZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUYWdSZXF1ZXN0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQW4ge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgbG9hZHMgSFRNTCB0YWdzLCBzdWNoIGFzIGltYWdlcyBhbmQgc2NyaXB0cy5cblx0ICogQGNsYXNzIFRhZ1JlcXVlc3Rcblx0ICogQHBhcmFtIHtMb2FkSXRlbX0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFnXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmNBdHRyaWJ1dGUgVGhlIHRhZyBhdHRyaWJ1dGUgdGhhdCBzcGVjaWZpZXMgdGhlIHNvdXJjZSwgc3VjaCBhcyBcInNyY1wiLCBcImhyZWZcIiwgZXRjLlxuXHQgKi9cblx0ZnVuY3Rpb24gVGFnUmVxdWVzdChsb2FkSXRlbSwgdGFnLCBzcmNBdHRyaWJ1dGUpIHtcblx0XHR0aGlzLkFic3RyYWN0UmVxdWVzdF9jb25zdHJ1Y3Rvcihsb2FkSXRlbSk7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBIVE1MIHRhZyBpbnN0YW5jZSB0aGF0IGlzIHVzZWQgdG8gbG9hZC5cblx0XHQgKiBAcHJvcGVydHkgX3RhZ1xuXHRcdCAqIEB0eXBlIHtIVE1MRWxlbWVudH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fdGFnID0gdGFnO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRhZyBhdHRyaWJ1dGUgdGhhdCBzcGVjaWZpZXMgdGhlIHNvdXJjZSwgc3VjaCBhcyBcInNyY1wiLCBcImhyZWZcIiwgZXRjLlxuXHRcdCAqIEBwcm9wZXJ0eSBfdGFnU3JjQXR0cmlidXRlXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fdGFnU3JjQXR0cmlidXRlID0gc3JjQXR0cmlidXRlO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBtZXRob2QgY2xvc3VyZSB1c2VkIGZvciBoYW5kbGluZyB0aGUgdGFnIGxvYWQgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkZWRIYW5kbGVyXG5cdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZGVkSGFuZGxlciA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRhZ0NvbXBsZXRlLCB0aGlzKTtcblxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZXMgaWYgdGhlIGVsZW1lbnQgd2FzIGFkZGVkIHRvIHRoZSBET00gYXV0b21hdGljYWxseSBieSBQcmVsb2FkSlMsIHNvIGl0IGNhbiBiZSBjbGVhbmVkIHVwIGFmdGVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBfYWRkZWRUb0RPTVxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fYWRkZWRUb0RPTSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lcyB3aGF0IHRoZSB0YWdzIGluaXRpYWwgc3R5bGUudmlzaWJpbGl0eSB3YXMsIHNvIHdlIGNhbiBzZXQgaXQgY29ycmVjdGx5IGFmdGVyIGEgbG9hZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudWxsfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fc3RhcnRUYWdWaXNpYmlsaXR5ID0gbnVsbDtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChUYWdSZXF1ZXN0LCBjcmVhdGVqcy5BYnN0cmFjdFJlcXVlc3QpO1xuXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl90YWcub25sb2FkID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlVGFnQ29tcGxldGUsIHRoaXMpO1xuXHRcdHRoaXMuX3RhZy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlLCB0aGlzKTtcblx0XHR0aGlzLl90YWcub25lcnJvciA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZUVycm9yLCB0aGlzKTtcblxuXHRcdHZhciBldnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJpbml0aWFsaXplXCIpO1xuXHRcdGV2dC5sb2FkZXIgPSB0aGlzLl90YWc7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuXHRcdHRoaXMuX2hpZGVUYWcoKTtcblxuXHRcdHRoaXMuX2xvYWRUaW1lb3V0ID0gc2V0VGltZW91dChjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUaW1lb3V0LCB0aGlzKSwgdGhpcy5faXRlbS5sb2FkVGltZW91dCk7XG5cblx0XHR0aGlzLl90YWdbdGhpcy5fdGFnU3JjQXR0cmlidXRlXSA9IHRoaXMuX2l0ZW0uc3JjO1xuXG5cdFx0Ly8gd2RnOjogQXBwZW5kIHRoZSB0YWcgQUZURVIgc2V0dGluZyB0aGUgc3JjLCBvciBTVkcgbG9hZGluZyBvbiBpT1Mgd2lsbCBmYWlsLlxuXHRcdGlmICh0aGlzLl90YWcucGFyZW50Tm9kZSA9PSBudWxsKSB7XG5cdFx0XHR3aW5kb3cuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl90YWcpO1xuXHRcdFx0dGhpcy5fYWRkZWRUb0RPTSA9IHRydWU7XG5cdFx0fVxuXHR9O1xuXG5cdHAuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2NsZWFuKCk7XG5cdFx0dGhpcy5fdGFnID0gbnVsbDtcblxuXHRcdHRoaXMuQWJzdHJhY3RSZXF1ZXN0X2Rlc3Ryb3koKTtcblx0fTtcblxuXHQvLyBwcml2YXRlIG1ldGhvZHNcblx0LyoqXG5cdCAqIEhhbmRsZSB0aGUgcmVhZHlTdGF0ZUNoYW5nZSBldmVudCBmcm9tIGEgdGFnLiBXZSBuZWVkIHRoaXMgaW4gcGxhY2Ugb2YgdGhlIGBvbmxvYWRgIGNhbGxiYWNrIChtYWlubHkgU0NSSVBUXG5cdCAqIGFuZCBMSU5LIHRhZ3MpLCBidXQgb3RoZXIgY2FzZXMgbWF5IGV4aXN0LlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9sb2FkVGltZW91dCk7XG5cdFx0Ly8gVGhpcyBpcyBzdHJpY3RseSBmb3IgdGFncyBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IG9ubG9hZC5cblx0XHR2YXIgdGFnID0gdGhpcy5fdGFnO1xuXG5cdFx0Ly8gQ29tcGxldGUgaXMgZm9yIG9sZCBJRSBzdXBwb3J0LlxuXHRcdGlmICh0YWcucmVhZHlTdGF0ZSA9PSBcImxvYWRlZFwiIHx8IHRhZy5yZWFkeVN0YXRlID09IFwiY29tcGxldGVcIikge1xuXHRcdFx0dGhpcy5faGFuZGxlVGFnQ29tcGxldGUoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZSBhbnkgZXJyb3IgZXZlbnRzIGZyb20gdGhlIHRhZy5cblx0ICogQG1ldGhvZCBfaGFuZGxlRXJyb3Jcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5faGFuZGxlRXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9jbGVhbigpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImVycm9yXCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBIYW5kbGUgdGhlIHRhZydzIG9ubG9hZCBjYWxsYmFjay5cblx0ICogQG1ldGhvZCBfaGFuZGxlVGFnQ29tcGxldGVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVRhZ0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3Jhd1Jlc3VsdCA9IHRoaXMuX3RhZztcblx0XHR0aGlzLl9yZXN1bHQgPSB0aGlzLnJlc3VsdEZvcm1hdHRlciAmJiB0aGlzLnJlc3VsdEZvcm1hdHRlcih0aGlzKSB8fCB0aGlzLl9yYXdSZXN1bHQ7XG5cblx0XHR0aGlzLl9jbGVhbigpO1xuXHRcdHRoaXMuX3Nob3dUYWcoKTtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgdGFnIHJlcXVlc3QgaGFzIG5vdCBsb2FkZWQgd2l0aGluIHRoZSB0aW1lIHNwZWNpZmllZCBpbiBsb2FkVGltZW91dC5cblx0ICogQG1ldGhvZCBfaGFuZGxlRXJyb3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgZXJyb3IgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NsZWFuKCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FdmVudChcInRpbWVvdXRcIikpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzLCBidXQgZG9uJ3QgZGVzdHJveSB0aGUgcmVxdWVzdCBvYmplY3Rcblx0ICogQG1ldGhvZCBfY2xlYW5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NsZWFuID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fdGFnLm9ubG9hZCA9IG51bGw7XG5cdFx0dGhpcy5fdGFnLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cdFx0dGhpcy5fdGFnLm9uZXJyb3IgPSBudWxsO1xuXHRcdGlmICh0aGlzLl9hZGRlZFRvRE9NICYmIHRoaXMuX3RhZy5wYXJlbnROb2RlICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3RhZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX3RhZyk7XG5cdFx0fVxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9sb2FkVGltZW91dCk7XG5cdH07XG5cblx0cC5faGlkZVRhZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3N0YXJ0VGFnVmlzaWJpbGl0eSA9IHRoaXMuX3RhZy5zdHlsZS52aXNpYmlsaXR5O1xuXHRcdHRoaXMuX3RhZy5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcblx0fTtcblxuXHRwLl9zaG93VGFnID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fdGFnLnN0eWxlLnZpc2liaWxpdHkgPSB0aGlzLl9zdGFydFRhZ1Zpc2liaWxpdHk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZSBhIHN0YWxsZWQgYXVkaW8gZXZlbnQuIFRoZSBtYWluIHBsYWNlIHRoaXMgaGFwcGVucyBpcyB3aXRoIEhUTUxBdWRpbyBpbiBDaHJvbWUgd2hlbiBwbGF5aW5nIGJhY2sgYXVkaW9cblx0ICogdGhhdCBpcyBhbHJlYWR5IGluIGEgbG9hZCwgYnV0IG5vdCBjb21wbGV0ZS5cblx0ICogQG1ldGhvZCBfaGFuZGxlU3RhbGxlZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlU3RhbGxlZCA9IGZ1bmN0aW9uICgpIHtcblx0XHQvL0lnbm9yZSwgbGV0IHRoZSB0aW1lb3V0IHRha2UgY2FyZSBvZiBpdC4gU29tZXRpbWVzIGl0cyBub3QgcmVhbGx5IHN0b3BwZWQuXG5cdH07XG5cblx0Y3JlYXRlanMuVGFnUmVxdWVzdCA9IGNyZWF0ZWpzLnByb21vdGUoVGFnUmVxdWVzdCwgXCJBYnN0cmFjdFJlcXVlc3RcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBNZWRpYVRhZ1JlcXVlc3QuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBbiB7eyNjcm9zc0xpbmsgXCJUYWdSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgbG9hZHMgSFRNTCB0YWdzIGZvciB2aWRlbyBhbmQgYXVkaW8uXG5cdCAqIEBjbGFzcyBNZWRpYVRhZ1JlcXVlc3Rcblx0ICogQHBhcmFtIHtMb2FkSXRlbX0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtIVE1MQXVkaW9FbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IHRhZ1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjQXR0cmlidXRlIFRoZSB0YWcgYXR0cmlidXRlIHRoYXQgc3BlY2lmaWVzIHRoZSBzb3VyY2UsIHN1Y2ggYXMgXCJzcmNcIiwgXCJocmVmXCIsIGV0Yy5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBNZWRpYVRhZ1JlcXVlc3QobG9hZEl0ZW0sIHRhZywgc3JjQXR0cmlidXRlKSB7XG5cdFx0dGhpcy5BYnN0cmFjdFJlcXVlc3RfY29uc3RydWN0b3IobG9hZEl0ZW0pO1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHR0aGlzLl90YWcgPSB0YWc7XG5cdFx0dGhpcy5fdGFnU3JjQXR0cmlidXRlID0gc3JjQXR0cmlidXRlO1xuXHRcdHRoaXMuX2xvYWRlZEhhbmRsZXIgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUYWdDb21wbGV0ZSwgdGhpcyk7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoTWVkaWFUYWdSZXF1ZXN0LCBjcmVhdGVqcy5UYWdSZXF1ZXN0KTtcblx0dmFyIHMgPSBNZWRpYVRhZ1JlcXVlc3Q7XG5cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzYyA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVN0YWxsZWQsIHRoaXMpO1xuXHRcdHRoaXMuX3N0YWxsZWRDYWxsYmFjayA9IHNjO1xuXG5cdFx0dmFyIHBjID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlUHJvZ3Jlc3MsIHRoaXMpO1xuXHRcdHRoaXMuX2hhbmRsZVByb2dyZXNzID0gcGM7XG5cblx0XHR0aGlzLl90YWcuYWRkRXZlbnRMaXN0ZW5lcihcInN0YWxsZWRcIiwgc2MpO1xuXHRcdHRoaXMuX3RhZy5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgcGMpO1xuXG5cdFx0Ly8gVGhpcyB3aWxsIHRlbGwgdXMgd2hlbiBhdWRpbyBpcyBidWZmZXJlZCBlbm91Z2ggdG8gcGxheSB0aHJvdWdoLCBidXQgbm90IHdoZW4gaXRzIGxvYWRlZC5cblx0XHQvLyBUaGUgdGFnIGRvZXNuJ3Qga2VlcCBsb2FkaW5nIGluIENocm9tZSBvbmNlIGVub3VnaCBoYXMgYnVmZmVyZWQsIGFuZCB3ZSBoYXZlIGRlY2lkZWQgdGhhdCBiZWhhdmlvdXIgaXMgc3VmZmljaWVudC5cblx0XHR0aGlzLl90YWcuYWRkRXZlbnRMaXN0ZW5lciAmJiB0aGlzLl90YWcuYWRkRXZlbnRMaXN0ZW5lcihcImNhbnBsYXl0aHJvdWdoXCIsIHRoaXMuX2xvYWRlZEhhbmRsZXIsIGZhbHNlKTsgLy8gY2FucGxheXRocm91Z2ggY2FsbGJhY2sgZG9lc24ndCB3b3JrIGluIENocm9tZSwgc28gd2UgdXNlIGFuIGV2ZW50LlxuXG5cdFx0dGhpcy5UYWdSZXF1ZXN0X2xvYWQoKTtcblx0fTtcblxuXHQvLyBwcml2YXRlIG1ldGhvZHNcblx0cC5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fbG9hZFRpbWVvdXQpO1xuXHRcdC8vIFRoaXMgaXMgc3RyaWN0bHkgZm9yIHRhZ3MgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBvbmxvYWQuXG5cdFx0dmFyIHRhZyA9IHRoaXMuX3RhZztcblxuXHRcdC8vIENvbXBsZXRlIGlzIGZvciBvbGQgSUUgc3VwcG9ydC5cblx0XHRpZiAodGFnLnJlYWR5U3RhdGUgPT0gXCJsb2FkZWRcIiB8fCB0YWcucmVhZHlTdGF0ZSA9PSBcImNvbXBsZXRlXCIpIHtcblx0XHRcdHRoaXMuX2hhbmRsZVRhZ0NvbXBsZXRlKCk7XG5cdFx0fVxuXHR9O1xuXG5cdHAuX2hhbmRsZVN0YWxsZWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly9JZ25vcmUsIGxldCB0aGUgdGltZW91dCB0YWtlIGNhcmUgb2YgaXQuIFNvbWV0aW1lcyBpdHMgbm90IHJlYWxseSBzdG9wcGVkLlxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbiBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgcHJvZ3Jlc3MuXG5cdCAqIEBtZXRob2QgX2hhbmRsZVByb2dyZXNzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIHByb2dyZXNzIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRpZiAoIWV2ZW50IHx8IGV2ZW50LmxvYWRlZCA+IDAgJiYgZXZlbnQudG90YWwgPT0gMCkge1xuXHRcdFx0cmV0dXJuOyAvLyBTb21ldGltZXMgd2UgZ2V0IG5vIFwidG90YWxcIiwgc28ganVzdCBpZ25vcmUgdGhlIHByb2dyZXNzIGV2ZW50LlxuXHRcdH1cblxuXHRcdHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5Qcm9ncmVzc0V2ZW50KGV2ZW50LmxvYWRlZCwgZXZlbnQudG90YWwpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0cC5fY2xlYW4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIgJiYgdGhpcy5fdGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5dGhyb3VnaFwiLCB0aGlzLl9sb2FkZWRIYW5kbGVyKTtcblx0XHR0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN0YWxsZWRcIiwgdGhpcy5fc3RhbGxlZENhbGxiYWNrKTtcblx0XHR0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIHRoaXMuX3Byb2dyZXNzQ2FsbGJhY2spO1xuXG5cdFx0dGhpcy5UYWdSZXF1ZXN0X19jbGVhbigpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLk1lZGlhVGFnUmVxdWVzdCA9IGNyZWF0ZWpzLnByb21vdGUoTWVkaWFUYWdSZXF1ZXN0LCBcIlRhZ1JlcXVlc3RcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBYSFJSZXF1ZXN0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuLy8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgcHJlbG9hZGVyIHRoYXQgbG9hZHMgaXRlbXMgdXNpbmcgWEhSIHJlcXVlc3RzLCB1c3VhbGx5IFhNTEh0dHBSZXF1ZXN0LiBIb3dldmVyIFhEb21haW5SZXF1ZXN0cyB3aWxsIGJlIHVzZWRcblx0ICogZm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cyBpZiBwb3NzaWJsZSwgYW5kIG9sZGVyIHZlcnNpb25zIG9mIElFIGZhbGwgYmFjayBvbiB0byBBY3RpdmVYIG9iamVjdHMgd2hlbiBuZWNlc3NhcnkuXG5cdCAqIFhIUiByZXF1ZXN0cyBsb2FkIHRoZSBjb250ZW50IGFzIHRleHQgb3IgYmluYXJ5IGRhdGEsIHByb3ZpZGUgcHJvZ3Jlc3MgYW5kIGNvbnNpc3RlbnQgY29tcGxldGlvbiBldmVudHMsIGFuZFxuXHQgKiBjYW4gYmUgY2FuY2VsZWQgZHVyaW5nIGxvYWQuIE5vdGUgdGhhdCBYSFIgaXMgbm90IHN1cHBvcnRlZCBpbiBJRSA2IG9yIGVhcmxpZXIsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yXG5cdCAqIGNyb3NzLWRvbWFpbiBsb2FkaW5nLlxuXHQgKiBAY2xhc3MgWEhSUmVxdWVzdFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIG9iamVjdCB0aGF0IGRlZmluZXMgdGhlIGZpbGUgdG8gbG9hZC4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBhbiBvdmVydmlldyBvZiBzdXBwb3J0ZWQgZmlsZSBwcm9wZXJ0aWVzLlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKi9cblx0ZnVuY3Rpb24gWEhSUmVxdWVzdCAoaXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RSZXF1ZXN0X2NvbnN0cnVjdG9yKGl0ZW0pO1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBBIHJlZmVyZW5jZSB0byB0aGUgWEhSIHJlcXVlc3QgdXNlZCB0byBsb2FkIHRoZSBjb250ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmVxdWVzdFxuXHRcdCAqIEB0eXBlIHtYTUxIdHRwUmVxdWVzdCB8IFhEb21haW5SZXF1ZXN0IHwgQWN0aXZlWC5YTUxIVFRQfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcmVxdWVzdCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBIG1hbnVhbCBsb2FkIHRpbWVvdXQgdGhhdCBpcyB1c2VkIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IHRoZSBvblRpbWVvdXQgZXZlbnQgb24gWEhSIChYSFIgbGV2ZWwgMSxcblx0XHQgKiB0eXBpY2FsbHkgSUU5KS5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRUaW1lb3V0XG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRUaW1lb3V0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBicm93c2VyJ3MgWEhSIChYTUxIVFRQUmVxdWVzdCkgdmVyc2lvbi4gU3VwcG9ydGVkIHZlcnNpb25zIGFyZSAxIGFuZCAyLiBUaGVyZSBpcyBubyBvZmZpY2lhbCB3YXkgdG8gZGV0ZWN0XG5cdFx0ICogdGhlIHZlcnNpb24sIHNvIHdlIHVzZSBjYXBhYmlsaXRpZXMgdG8gbWFrZSBhIGJlc3QgZ3Vlc3MuXG5cdFx0ICogQHByb3BlcnR5IF94aHJMZXZlbFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5feGhyTGV2ZWwgPSAxO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHJlc3BvbnNlIG9mIGEgbG9hZGVkIGZpbGUuIFRoaXMgaXMgc2V0IGJlY2F1c2UgaXQgaXMgZXhwZW5zaXZlIHRvIGxvb2sgdXAgY29uc3RhbnRseS4gVGhpcyBwcm9wZXJ0eSB3aWxsIGJlXG5cdFx0ICogbnVsbCB1bnRpbCB0aGUgZmlsZSBpcyBsb2FkZWQuXG5cdFx0ICogQHByb3BlcnR5IF9yZXNwb25zZVxuXHRcdCAqIEB0eXBlIHttaXhlZH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3Jlc3BvbnNlID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByZXNwb25zZSBvZiB0aGUgbG9hZGVkIGZpbGUgYmVmb3JlIGl0IGlzIG1vZGlmaWVkLiBJbiBtb3N0IGNhc2VzLCBjb250ZW50IGlzIGNvbnZlcnRlZCBmcm9tIHJhdyB0ZXh0IHRvXG5cdFx0ICogYW4gSFRNTCB0YWcgb3IgYSBmb3JtYXR0ZWQgb2JqZWN0IHdoaWNoIGlzIHNldCB0byB0aGUgPGNvZGU+cmVzdWx0PC9jb2RlPiBwcm9wZXJ0eSwgYnV0IHRoZSBkZXZlbG9wZXIgbWF5IHN0aWxsXG5cdFx0ICogd2FudCB0byBhY2Nlc3MgdGhlIHJhdyBjb250ZW50IGFzIGl0IHdhcyBsb2FkZWQuXG5cdFx0ICogQHByb3BlcnR5IF9yYXdSZXNwb25zZVxuXHRcdCAqIEB0eXBlIHtTdHJpbmd8T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcmF3UmVzcG9uc2UgPSBudWxsO1xuXG5cdFx0dGhpcy5fY2FuY2VsZWQgPSBmYWxzZTtcblxuXHRcdC8vIFNldHVwIG91ciBldmVudCBoYW5kbGVycyBub3cuXG5cdFx0dGhpcy5faGFuZGxlTG9hZFN0YXJ0UHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVMb2FkU3RhcnQsIHRoaXMpO1xuXHRcdHRoaXMuX2hhbmRsZVByb2dyZXNzUHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVQcm9ncmVzcywgdGhpcyk7XG5cdFx0dGhpcy5faGFuZGxlQWJvcnRQcm94eSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZUFib3J0LCB0aGlzKTtcblx0XHR0aGlzLl9oYW5kbGVFcnJvclByb3h5ID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlRXJyb3IsIHRoaXMpO1xuXHRcdHRoaXMuX2hhbmRsZVRpbWVvdXRQcm94eSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRpbWVvdXQsIHRoaXMpO1xuXHRcdHRoaXMuX2hhbmRsZUxvYWRQcm94eSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZUxvYWQsIHRoaXMpO1xuXHRcdHRoaXMuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2VQcm94eSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2UsIHRoaXMpO1xuXG5cdFx0aWYgKCF0aGlzLl9jcmVhdGVYSFIoaXRlbSkpIHtcblx0XHRcdC8vVE9ETzogVGhyb3cgZXJyb3I/XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFhIUlJlcXVlc3QsIGNyZWF0ZWpzLkFic3RyYWN0UmVxdWVzdCk7XG5cbi8vIHN0YXRpYyBwcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBBIGxpc3Qgb2YgWE1MSFRUUCBvYmplY3QgSURzIHRvIHRyeSB3aGVuIGJ1aWxkaW5nIGFuIEFjdGl2ZVggb2JqZWN0IGZvciBYSFIgcmVxdWVzdHMgaW4gZWFybGllciB2ZXJzaW9ucyBvZiBJRS5cblx0ICogQHByb3BlcnR5IEFDVElWRVhfVkVSU0lPTlNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAc2luY2UgMC40LjJcblx0ICogQHByaXZhdGVcblx0ICovXG5cdFhIUlJlcXVlc3QuQUNUSVZFWF9WRVJTSU9OUyA9IFtcblx0XHRcIk1zeG1sMi5YTUxIVFRQLjYuMFwiLFxuXHRcdFwiTXN4bWwyLlhNTEhUVFAuNS4wXCIsXG5cdFx0XCJNc3htbDIuWE1MSFRUUC40LjBcIixcblx0XHRcIk1TWE1MMi5YTUxIVFRQLjMuMFwiLFxuXHRcdFwiTVNYTUwyLlhNTEhUVFBcIixcblx0XHRcIk1pY3Jvc29mdC5YTUxIVFRQXCJcblx0XTtcblxuLy8gUHVibGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIExvb2sgdXAgdGhlIGxvYWRlZCByZXN1bHQuXG5cdCAqIEBtZXRob2QgZ2V0UmVzdWx0XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Jhdz1mYWxzZV0gUmV0dXJuIGEgcmF3IHJlc3VsdCBpbnN0ZWFkIG9mIGEgZm9ybWF0dGVkIHJlc3VsdC4gVGhpcyBhcHBsaWVzIHRvIGNvbnRlbnRcblx0ICogbG9hZGVkIHZpYSBYSFIgc3VjaCBhcyBzY3JpcHRzLCBYTUwsIENTUywgYW5kIEltYWdlcy4gSWYgdGhlcmUgaXMgbm8gcmF3IHJlc3VsdCwgdGhlIGZvcm1hdHRlZCByZXN1bHQgd2lsbCBiZVxuXHQgKiByZXR1cm5lZCBpbnN0ZWFkLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEEgcmVzdWx0IG9iamVjdCBjb250YWluaW5nIHRoZSBjb250ZW50IHRoYXQgd2FzIGxvYWRlZCwgc3VjaCBhczpcblx0ICogPHVsPlxuXHQgKiAgICAgIDxsaT5BbiBpbWFnZSB0YWcgKCZsdDtpbWFnZSAvJmd0OykgZm9yIGltYWdlczwvbGk+XG5cdCAqICAgICAgPGxpPkEgc2NyaXB0IHRhZyBmb3IgSmF2YVNjcmlwdCAoJmx0O3NjcmlwdCAvJmd0OykuIE5vdGUgdGhhdCBzY3JpcHRzIGxvYWRlZCB3aXRoIHRhZ3MgbWF5IGJlIGFkZGVkIHRvIHRoZVxuXHQgKiAgICAgIEhUTUwgaGVhZC48L2xpPlxuXHQgKiAgICAgIDxsaT5BIHN0eWxlIHRhZyBmb3IgQ1NTICgmbHQ7c3R5bGUgLyZndDspPC9saT5cblx0ICogICAgICA8bGk+UmF3IHRleHQgZm9yIFRFWFQ8L2xpPlxuXHQgKiAgICAgIDxsaT5BIGZvcm1hdHRlZCBKYXZhU2NyaXB0IG9iamVjdCBkZWZpbmVkIGJ5IEpTT048L2xpPlxuXHQgKiAgICAgIDxsaT5BbiBYTUwgZG9jdW1lbnQ8L2xpPlxuXHQgKiAgICAgIDxsaT5BbiBiaW5hcnkgYXJyYXlidWZmZXIgbG9hZGVkIGJ5IFhIUjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIE5vdGUgdGhhdCBpZiBhIHJhdyByZXN1bHQgaXMgcmVxdWVzdGVkLCBidXQgbm90IGZvdW5kLCB0aGUgcmVzdWx0IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZC5cblx0ICovXG5cdHAuZ2V0UmVzdWx0ID0gZnVuY3Rpb24gKHJhdykge1xuXHRcdGlmIChyYXcgJiYgdGhpcy5fcmF3UmVzcG9uc2UpIHtcblx0XHRcdHJldHVybiB0aGlzLl9yYXdSZXNwb25zZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3Jlc3BvbnNlO1xuXHR9O1xuXG5cdC8vIE92ZXJyaWRlcyBhYnN0cmFjdCBtZXRob2QgaW4gQWJzdHJhY3RSZXF1ZXN0XG5cdHAuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuY2FuY2VsZWQgPSB0cnVlO1xuXHRcdHRoaXMuX2NsZWFuKCk7XG5cdFx0dGhpcy5fcmVxdWVzdC5hYm9ydCgpO1xuXHR9O1xuXG5cdC8vIE92ZXJyaWRlcyBhYnN0cmFjdCBtZXRob2QgaW4gQWJzdHJhY3RMb2FkZXJcblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZXF1ZXN0ID09IG51bGwpIHtcblx0XHRcdHRoaXMuX2hhbmRsZUVycm9yKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly9FdmVudHNcblx0XHRpZiAodGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRzdGFydFwiLCB0aGlzLl9oYW5kbGVMb2FkU3RhcnRQcm94eSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgdGhpcy5faGFuZGxlUHJvZ3Jlc3NQcm94eSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgdGhpcy5faGFuZGxlQWJvcnRQcm94eSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5faGFuZGxlRXJyb3JQcm94eSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwidGltZW91dFwiLCB0aGlzLl9oYW5kbGVUaW1lb3V0UHJveHksIGZhbHNlKTtcblxuXHRcdFx0Ly8gTm90ZTogV2UgZG9uJ3QgZ2V0IG9ubG9hZCBpbiBhbGwgYnJvd3NlcnMgKGVhcmxpZXIgRkYgYW5kIElFKS4gb25SZWFkeVN0YXRlQ2hhbmdlIGhhbmRsZXMgdGhlc2UuXG5cdFx0XHR0aGlzLl9yZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHRoaXMuX2hhbmRsZUxvYWRQcm94eSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLCB0aGlzLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlUHJveHksIGZhbHNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gSUU5IHN1cHBvcnRcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25sb2Fkc3RhcnQgPSB0aGlzLl9oYW5kbGVMb2FkU3RhcnRQcm94eTtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25wcm9ncmVzcyA9IHRoaXMuX2hhbmRsZVByb2dyZXNzUHJveHk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9uYWJvcnQgPSB0aGlzLl9oYW5kbGVBYm9ydFByb3h5O1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbmVycm9yID0gdGhpcy5faGFuZGxlRXJyb3JQcm94eTtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub250aW1lb3V0ID0gdGhpcy5faGFuZGxlVGltZW91dFByb3h5O1xuXG5cdFx0XHQvLyBOb3RlOiBXZSBkb24ndCBnZXQgb25sb2FkIGluIGFsbCBicm93c2VycyAoZWFybGllciBGRiBhbmQgSUUpLiBvblJlYWR5U3RhdGVDaGFuZ2UgaGFuZGxlcyB0aGVzZS5cblx0XHRcdHRoaXMuX3JlcXVlc3Qub25sb2FkID0gdGhpcy5faGFuZGxlTG9hZFByb3h5O1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB0aGlzLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlUHJveHk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHVwIGEgdGltZW91dCBpZiB3ZSBkb24ndCBoYXZlIFhIUjJcblx0XHRpZiAodGhpcy5feGhyTGV2ZWwgPT0gMSkge1xuXHRcdFx0dGhpcy5fbG9hZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRpbWVvdXQsIHRoaXMpLCB0aGlzLl9pdGVtLmxvYWRUaW1lb3V0KTtcblx0XHR9XG5cblx0XHQvLyBTb21ldGltZXMgd2UgZ2V0IGJhY2sgNDA0cyBpbW1lZGlhdGVseSwgcGFydGljdWxhcmx5IHdoZW4gdGhlcmUgaXMgYSBjcm9zcyBvcmlnaW4gcmVxdWVzdC4gIC8vIG5vdGUgdGhpcyBkb2VzIG5vdCBjYXRjaCBpbiBDaHJvbWVcblx0XHR0cnkge1xuXHRcdFx0aWYgKCF0aGlzLl9pdGVtLnZhbHVlcyB8fCB0aGlzLl9pdGVtLm1ldGhvZCA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5HRVQpIHtcblx0XHRcdFx0dGhpcy5fcmVxdWVzdC5zZW5kKCk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2l0ZW0ubWV0aG9kID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlBPU1QpIHtcblx0XHRcdFx0dGhpcy5fcmVxdWVzdC5zZW5kKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5mb3JtYXRRdWVyeVN0cmluZyh0aGlzLl9pdGVtLnZhbHVlcykpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJYSFJfU0VORFwiLCBudWxsLCBlcnJvcikpO1xuXHRcdH1cblx0fTtcblxuXHRwLnNldFJlc3BvbnNlVHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG5cdFx0Ly8gU29tZSBvbGQgYnJvd3NlcnMgZG9lc24ndCBzdXBwb3J0IGJsb2IsIHNvIHdlIGNvbnZlcnQgYXJyYXlidWZmZXIgdG8gYmxvYiBhZnRlciByZXNwb25zZSBpcyBkb3dubG9hZGVkXG5cdFx0aWYgKHR5cGUgPT09ICdibG9iJykge1xuXHRcdFx0dHlwZSA9IHdpbmRvdy5VUkwgPyAnYmxvYicgOiAnYXJyYXlidWZmZXInO1xuXHRcdFx0dGhpcy5fcmVzcG9uc2VUeXBlID0gdHlwZTtcblx0XHR9XG5cdFx0dGhpcy5fcmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0eXBlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgYWxsIHRoZSByZXNwb25zZSBoZWFkZXJzIGZyb20gdGhlIFhtbEh0dHBSZXF1ZXN0LlxuXHQgKlxuXHQgKiA8c3Ryb25nPkZyb20gdGhlIGRvY3M6PC9zdHJvbmc+IFJldHVybiBhbGwgdGhlIEhUVFAgaGVhZGVycywgZXhjbHVkaW5nIGhlYWRlcnMgdGhhdCBhcmUgYSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoXG5cdCAqIGZvciBTZXQtQ29va2llIG9yIFNldC1Db29raWUyLCBhcyBhIHNpbmdsZSBzdHJpbmcsIHdpdGggZWFjaCBoZWFkZXIgbGluZSBzZXBhcmF0ZWQgYnkgYSBVKzAwMEQgQ1IgVSswMDBBIExGIHBhaXIsXG5cdCAqIGV4Y2x1ZGluZyB0aGUgc3RhdHVzIGxpbmUsIGFuZCB3aXRoIGVhY2ggaGVhZGVyIG5hbWUgYW5kIGhlYWRlciB2YWx1ZSBzZXBhcmF0ZWQgYnkgYSBVKzAwM0EgQ09MT04gVSswMDIwIFNQQUNFXG5cdCAqIHBhaXIuXG5cdCAqIEBtZXRob2QgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICogQHNpbmNlIDAuNC4xXG5cdCAqL1xuXHRwLmdldEFsbFJlc3BvbnNlSGVhZGVycyA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogR2V0IGEgc3BlY2lmaWMgcmVzcG9uc2UgaGVhZGVyIGZyb20gdGhlIFhtbEh0dHBSZXF1ZXN0LlxuXHQgKlxuXHQgKiA8c3Ryb25nPkZyb20gdGhlIGRvY3M6PC9zdHJvbmc+IFJldHVybnMgdGhlIGhlYWRlciBmaWVsZCB2YWx1ZSBmcm9tIHRoZSByZXNwb25zZSBvZiB3aGljaCB0aGUgZmllbGQgbmFtZSBtYXRjaGVzXG5cdCAqIGhlYWRlciwgdW5sZXNzIHRoZSBmaWVsZCBuYW1lIGlzIFNldC1Db29raWUgb3IgU2V0LUNvb2tpZTIuXG5cdCAqIEBtZXRob2QgZ2V0UmVzcG9uc2VIZWFkZXJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgaGVhZGVyIG5hbWUgdG8gcmV0cmlldmUuXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICogQHNpbmNlIDAuNC4xXG5cdCAqL1xuXHRwLmdldFJlc3BvbnNlSGVhZGVyID0gZnVuY3Rpb24gKGhlYWRlcikge1xuXHRcdGlmICh0aGlzLl9yZXF1ZXN0LmdldFJlc3BvbnNlSGVhZGVyIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXF1ZXN0LmdldFJlc3BvbnNlSGVhZGVyKGhlYWRlcik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fTtcblxuLy8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgcHJvZ3Jlc3MuXG5cdCAqIEBtZXRob2QgX2hhbmRsZVByb2dyZXNzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIHByb2dyZXNzIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRpZiAoIWV2ZW50IHx8IGV2ZW50LmxvYWRlZCA+IDAgJiYgZXZlbnQudG90YWwgPT0gMCkge1xuXHRcdFx0cmV0dXJuOyAvLyBTb21ldGltZXMgd2UgZ2V0IG5vIFwidG90YWxcIiwgc28ganVzdCBpZ25vcmUgdGhlIHByb2dyZXNzIGV2ZW50LlxuXHRcdH1cblxuXHRcdHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5Qcm9ncmVzc0V2ZW50KGV2ZW50LmxvYWRlZCwgZXZlbnQudG90YWwpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgYSBsb2FkIHN0YXJ0LlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVMb2FkU3RhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgbG9hZFN0YXJ0IGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTG9hZFN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2xvYWRUaW1lb3V0KTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJsb2Fkc3RhcnRcIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgYW4gYWJvcnQgZXZlbnQuXG5cdCAqIEBtZXRob2QgaGFuZGxlQWJvcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgYWJvcnQgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVBYm9ydCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMuX2NsZWFuKCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiWEhSX0FCT1JURURcIiwgbnVsbCwgZXZlbnQpKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIFhIUiByZXF1ZXN0IGhhcyByZXBvcnRlZCBhbiBlcnJvciBldmVudC5cblx0ICogQG1ldGhvZCBfaGFuZGxlRXJyb3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgZXJyb3IgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMuX2NsZWFuKCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KGV2ZW50Lm1lc3NhZ2UpKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIFhIUiByZXF1ZXN0IGhhcyByZXBvcnRlZCBhIHJlYWR5U3RhdGUgY2hhbmdlLiBOb3RlIHRoYXQgb2xkZXIgYnJvd3NlcnMgKElFIDcgJiA4KSBkbyBub3QgcHJvdmlkZSBhbiBvbmxvYWRcblx0ICogZXZlbnQsIHNvIHdlIG11c3QgbW9uaXRvciB0aGUgcmVhZHlTdGF0ZUNoYW5nZSB0byBkZXRlcm1pbmUgaWYgdGhlIGZpbGUgaXMgbG9hZGVkLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIHJlYWR5U3RhdGVDaGFuZ2UgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QucmVhZHlTdGF0ZSA9PSA0KSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVMb2FkKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgWEhSIHJlcXVlc3QgaGFzIGNvbXBsZXRlZC4gVGhpcyBpcyBjYWxsZWQgYnkgdGhlIFhIUiByZXF1ZXN0IGRpcmVjdGx5LCBvciBieSBhIHJlYWR5U3RhdGVDaGFuZ2UgdGhhdCBoYXNcblx0ICogPGNvZGU+cmVxdWVzdC5yZWFkeVN0YXRlID09IDQ8L2NvZGU+LiBPbmx5IHRoZSBmaXJzdCBjYWxsIHRvIHRoaXMgbWV0aG9kIHdpbGwgYmUgcHJvY2Vzc2VkLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVMb2FkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGxvYWQgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVMb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMubG9hZGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMubG9hZGVkID0gdHJ1ZTtcblxuXHRcdHZhciBlcnJvciA9IHRoaXMuX2NoZWNrRXJyb3IoKTtcblx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdHRoaXMuX2hhbmRsZUVycm9yKGVycm9yKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9yZXNwb25zZSA9IHRoaXMuX2dldFJlc3BvbnNlKCk7XG5cdFx0Ly8gQ29udmVydCBhcnJheWJ1ZmZlciBiYWNrIHRvIGJsb2Jcblx0XHRpZiAodGhpcy5fcmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0aGlzLl9yZXNwb25zZSA9IG5ldyBCbG9iKFt0aGlzLl9yZXNwb25zZV0pO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHQvLyBGYWxsYmFjayB0byB1c2UgQmxvYkJ1aWxkZXIgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdC8vIFRlc3RlZCBvbiBBbmRyb2lkIDIuMyB+IDQuMiBhbmQgaU9TNSBzYWZhcmlcblx0XHRcdFx0d2luZG93LkJsb2JCdWlsZGVyID0gd2luZG93LkJsb2JCdWlsZGVyIHx8IHdpbmRvdy5XZWJLaXRCbG9iQnVpbGRlciB8fCB3aW5kb3cuTW96QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1TQmxvYkJ1aWxkZXI7XG5cdFx0XHRcdGlmIChlLm5hbWUgPT09ICdUeXBlRXJyb3InICYmIHdpbmRvdy5CbG9iQnVpbGRlcikge1xuXHRcdFx0XHRcdHZhciBidWlsZGVyID0gbmV3IEJsb2JCdWlsZGVyKCk7XG5cdFx0XHRcdFx0YnVpbGRlci5hcHBlbmQodGhpcy5fcmVzcG9uc2UpO1xuXHRcdFx0XHRcdHRoaXMuX3Jlc3BvbnNlID0gYnVpbGRlci5nZXRCbG9iKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fY2xlYW4oKTtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXZlbnQoXCJjb21wbGV0ZVwiKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgdGltZWQgb3V0LiBUaGlzIGlzIGNhbGxlZCBieSB0aGUgWEhSIHJlcXVlc3QgZGlyZWN0bHksIG9yIHZpYSBhIDxjb2RlPnNldFRpbWVvdXQ8L2NvZGU+XG5cdCAqIGNhbGxiYWNrLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVUaW1lb3V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnRdIFRoZSBYSFIgdGltZW91dCBldmVudC4gVGhpcyBpcyBvY2Nhc2lvbmFsbHkgbnVsbCB3aGVuIGNhbGxlZCBieSB0aGUgYmFja3VwIHNldFRpbWVvdXQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVUaW1lb3V0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dGhpcy5fY2xlYW4oKTtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlBSRUxPQURfVElNRU9VVFwiLCBudWxsLCBldmVudCkpO1xuXHR9O1xuXG4vLyBQcm90ZWN0ZWRcblx0LyoqXG5cdCAqIERldGVybWluZSBpZiB0aGVyZSBpcyBhbiBlcnJvciBpbiB0aGUgY3VycmVudCBsb2FkLiBUaGlzIGNoZWNrcyB0aGUgc3RhdHVzIG9mIHRoZSByZXF1ZXN0IGZvciBwcm9ibGVtIGNvZGVzLiBOb3RlXG5cdCAqIHRoYXQgdGhpcyBkb2VzIG5vdCBjaGVjayBmb3IgYW4gYWN0dWFsIHJlc3BvbnNlLiBDdXJyZW50bHksIGl0IG9ubHkgY2hlY2tzIGZvciA0MDQgb3IgMCBlcnJvciBjb2RlLlxuXHQgKiBAbWV0aG9kIF9jaGVja0Vycm9yXG5cdCAqIEByZXR1cm4ge2ludH0gSWYgdGhlIHJlcXVlc3Qgc3RhdHVzIHJldHVybnMgYW4gZXJyb3IgY29kZS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NoZWNrRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly9MTTogUHJvYmFibHkgbmVlZCBhZGRpdGlvbmFsIGhhbmRsZXJzIGhlcmUsIG1heWJlIDUwMVxuXHRcdHZhciBzdGF0dXMgPSBwYXJzZUludCh0aGlzLl9yZXF1ZXN0LnN0YXR1cyk7XG5cblx0XHRzd2l0Y2ggKHN0YXR1cykge1xuXHRcdFx0Y2FzZSA0MDQ6ICAgLy8gTm90IEZvdW5kXG5cdFx0XHRjYXNlIDA6ICAgICAvLyBOb3QgTG9hZGVkXG5cdFx0XHRcdHJldHVybiBuZXcgRXJyb3Ioc3RhdHVzKTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFZhbGlkYXRlIHRoZSByZXNwb25zZS4gRGlmZmVyZW50IGJyb3dzZXJzIGhhdmUgZGlmZmVyZW50IGFwcHJvYWNoZXMsIHNvbWUgb2Ygd2hpY2ggdGhyb3cgZXJyb3JzIHdoZW4gYWNjZXNzZWRcblx0ICogaW4gb3RoZXIgYnJvd3NlcnMuIElmIHRoZXJlIGlzIG5vIHJlc3BvbnNlLCB0aGUgPGNvZGU+X3Jlc3BvbnNlPC9jb2RlPiBwcm9wZXJ0eSB3aWxsIHJlbWFpbiBudWxsLlxuXHQgKiBAbWV0aG9kIF9nZXRSZXNwb25zZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZ2V0UmVzcG9uc2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Jlc3BvbnNlICE9IG51bGwpIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXNwb25zZTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fcmVxdWVzdC5yZXNwb25zZSAhPSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVxdWVzdC5yZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBbmRyb2lkIDIuMiB1c2VzIC5yZXNwb25zZVRleHRcblx0XHR0cnkge1xuXHRcdFx0aWYgKHRoaXMuX3JlcXVlc3QucmVzcG9uc2VUZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JlcXVlc3QucmVzcG9uc2VUZXh0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHR9XG5cblx0XHQvLyBXaGVuIGxvYWRpbmcgWE1MLCBJRTkgZG9lcyBub3QgcmV0dXJuIC5yZXNwb25zZSwgaW5zdGVhZCBpdCByZXR1cm5zIHJlc3BvbnNlWE1MLnhtbFxuXHRcdHRyeSB7XG5cdFx0XHRpZiAodGhpcy5fcmVxdWVzdC5yZXNwb25zZVhNTCAhPSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXF1ZXN0LnJlc3BvbnNlWE1MO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIGFuIFhIUiByZXF1ZXN0LiBEZXBlbmRpbmcgb24gYSBudW1iZXIgb2YgZmFjdG9ycywgd2UgZ2V0IHRvdGFsbHkgZGlmZmVyZW50IHJlc3VsdHMuXG5cdCAqIDxvbD48bGk+U29tZSBicm93c2VycyBnZXQgYW4gPGNvZGU+WERvbWFpblJlcXVlc3Q8L2NvZGU+IHdoZW4gbG9hZGluZyBjcm9zcy1kb21haW4uPC9saT5cblx0ICogICAgICA8bGk+WE1MSHR0cFJlcXVlc3QgYXJlIGNyZWF0ZWQgd2hlbiBhdmFpbGFibGUuPC9saT5cblx0ICogICAgICA8bGk+QWN0aXZlWC5YTUxIVFRQIG9iamVjdHMgYXJlIHVzZWQgaW4gb2xkZXIgSUUgYnJvd3NlcnMuPC9saT5cblx0ICogICAgICA8bGk+VGV4dCByZXF1ZXN0cyBvdmVycmlkZSB0aGUgbWltZSB0eXBlIGlmIHBvc3NpYmxlPC9saT5cblx0ICogICAgICA8bGk+T3JpZ2luIGhlYWRlcnMgYXJlIHNlbnQgZm9yIGNyb3NzZG9tYWluIHJlcXVlc3RzIGluIHNvbWUgYnJvd3NlcnMuPC9saT5cblx0ICogICAgICA8bGk+QmluYXJ5IGxvYWRzIHNldCB0aGUgcmVzcG9uc2UgdHlwZSB0byBcImFycmF5YnVmZmVyXCI8L2xpPjwvb2w+XG5cdCAqIEBtZXRob2QgX2NyZWF0ZVhIUlxuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBUaGUgcmVxdWVzdGVkIGl0ZW0gdGhhdCBpcyBiZWluZyBsb2FkZWQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIGFuIFhIUiByZXF1ZXN0IG9yIGVxdWl2YWxlbnQgd2FzIHN1Y2Nlc3NmdWxseSBjcmVhdGVkLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY3JlYXRlWEhSID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHQvLyBDaGVjayBmb3IgY3Jvc3MtZG9tYWluIGxvYWRzLiBXZSBjYW4ndCBmdWxseSBzdXBwb3J0IHRoZW0sIGJ1dCB3ZSBjYW4gdHJ5LlxuXHRcdHZhciBjcm9zc2RvbWFpbiA9IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0Nyb3NzRG9tYWluKGl0ZW0pO1xuXHRcdHZhciBoZWFkZXJzID0ge307XG5cblx0XHQvLyBDcmVhdGUgdGhlIHJlcXVlc3QuIEZhbGxiYWNrIHRvIHdoYXRldmVyIHN1cHBvcnQgd2UgaGF2ZS5cblx0XHR2YXIgcmVxID0gbnVsbDtcblx0XHRpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG5cdFx0XHRyZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHRcdC8vIFRoaXMgaXMgOCBvciA5LCBzbyB1c2UgWERvbWFpblJlcXVlc3QgaW5zdGVhZC5cblx0XHRcdGlmIChjcm9zc2RvbWFpbiAmJiByZXEud2l0aENyZWRlbnRpYWxzID09PSB1bmRlZmluZWQgJiYgd2luZG93LlhEb21haW5SZXF1ZXN0KSB7XG5cdFx0XHRcdHJlcSA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7IC8vIE9sZCBJRSB2ZXJzaW9ucyB1c2UgYSBkaWZmZXJlbnQgYXBwcm9hY2hcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcy5BQ1RJVkVYX1ZFUlNJT05TLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgYXhWZXJzaW9uID0gcy5BQ1RJVkVYX1ZFUlNJT05TW2ldO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJlcSA9IG5ldyBBY3RpdmVYT2JqZWN0KGF4VmVyc2lvbik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHJlcSA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBEZWZhdWx0IHRvIHV0Zi04IGZvciBUZXh0IHJlcXVlc3RzLlxuXHRcdGlmIChpdGVtLm1pbWVUeXBlID09IG51bGwgJiYgY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzVGV4dChpdGVtLnR5cGUpKSB7XG5cdFx0XHRpdGVtLm1pbWVUeXBlID0gXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCI7XG5cdFx0fVxuXG5cdFx0Ly8gSUU5IGRvZXNuJ3Qgc3VwcG9ydCBvdmVycmlkZU1pbWVUeXBlKCksIHNvIHdlIG5lZWQgdG8gY2hlY2sgZm9yIGl0LlxuXHRcdGlmIChpdGVtLm1pbWVUeXBlICYmIHJlcS5vdmVycmlkZU1pbWVUeXBlKSB7XG5cdFx0XHRyZXEub3ZlcnJpZGVNaW1lVHlwZShpdGVtLm1pbWVUeXBlKTtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgdGhlIFhIUiBsZXZlbFxuXHRcdHRoaXMuX3hockxldmVsID0gKHR5cGVvZiByZXEucmVzcG9uc2VUeXBlID09PSBcInN0cmluZ1wiKSA/IDIgOiAxO1xuXG5cdFx0dmFyIHNyYyA9IG51bGw7XG5cdFx0aWYgKGl0ZW0ubWV0aG9kID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkdFVCkge1xuXHRcdFx0c3JjID0gY3JlYXRlanMuUmVxdWVzdFV0aWxzLmJ1aWxkUGF0aChpdGVtLnNyYywgaXRlbS52YWx1ZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcmMgPSBpdGVtLnNyYztcblx0XHR9XG5cblx0XHQvLyBPcGVuIHRoZSByZXF1ZXN0LiAgU2V0IGNyb3NzLWRvbWFpbiBmbGFncyBpZiBpdCBpcyBzdXBwb3J0ZWQgKFhIUiBsZXZlbCAxIG9ubHkpXG5cdFx0cmVxLm9wZW4oaXRlbS5tZXRob2QgfHwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuR0VULCBzcmMsIHRydWUpO1xuXG5cdFx0aWYgKGNyb3NzZG9tYWluICYmIHJlcSBpbnN0YW5jZW9mIFhNTEh0dHBSZXF1ZXN0ICYmIHRoaXMuX3hockxldmVsID09IDEpIHtcblx0XHRcdGhlYWRlcnNbXCJPcmlnaW5cIl0gPSBsb2NhdGlvbi5vcmlnaW47XG5cdFx0fVxuXG5cdFx0Ly8gVG8gc2VuZCBkYXRhIHdlIG5lZWQgdG8gc2V0IHRoZSBDb250ZW50LXR5cGUgaGVhZGVyKVxuXHRcdGlmIChpdGVtLnZhbHVlcyAmJiBpdGVtLm1ldGhvZCA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5QT1NUKSB7XG5cdFx0XHRoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcblx0XHR9XG5cblx0XHRpZiAoIWNyb3NzZG9tYWluICYmICFoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSkge1xuXHRcdFx0aGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0fVxuXG5cdFx0aWYgKGl0ZW0uaGVhZGVycykge1xuXHRcdFx0Zm9yICh2YXIgbiBpbiBpdGVtLmhlYWRlcnMpIHtcblx0XHRcdFx0aGVhZGVyc1tuXSA9IGl0ZW0uaGVhZGVyc1tuXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKG4gaW4gaGVhZGVycykge1xuXHRcdFx0cmVxLnNldFJlcXVlc3RIZWFkZXIobiwgaGVhZGVyc1tuXSlcblx0XHR9XG5cblx0XHRpZiAocmVxIGluc3RhbmNlb2YgWE1MSHR0cFJlcXVlc3QgJiYgaXRlbS53aXRoQ3JlZGVudGlhbHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmVxLndpdGhDcmVkZW50aWFscyA9IGl0ZW0ud2l0aENyZWRlbnRpYWxzO1xuXHRcdH1cblxuXHRcdHRoaXMuX3JlcXVlc3QgPSByZXE7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogQSByZXF1ZXN0IGhhcyBjb21wbGV0ZWQgKG9yIGZhaWxlZCBvciBjYW5jZWxlZCksIGFuZCBuZWVkcyB0byBiZSBkaXNwb3NlZC5cblx0ICogQG1ldGhvZCBfY2xlYW5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NsZWFuID0gZnVuY3Rpb24gKCkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9sb2FkVGltZW91dCk7XG5cblx0XHRpZiAodGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRzdGFydFwiLCB0aGlzLl9oYW5kbGVMb2FkU3RhcnRQcm94eSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCB0aGlzLl9oYW5kbGVQcm9ncmVzc1Byb3h5KTtcblx0XHRcdHRoaXMuX3JlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHRoaXMuX2hhbmRsZUFib3J0UHJveHkpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5faGFuZGxlRXJyb3JQcm94eSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0aW1lb3V0XCIsIHRoaXMuX2hhbmRsZVRpbWVvdXRQcm94eSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHRoaXMuX2hhbmRsZUxvYWRQcm94eSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsIHRoaXMuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2VQcm94eSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25sb2Fkc3RhcnQgPSBudWxsO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbnByb2dyZXNzID0gbnVsbDtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25hYm9ydCA9IG51bGw7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9uZXJyb3IgPSBudWxsO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbnRpbWVvdXQgPSBudWxsO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbmxvYWQgPSBudWxsO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXHRcdH1cblx0fTtcblxuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltQcmVsb2FkSlMgWEhSUmVxdWVzdF1cIjtcblx0fTtcblxuXHRjcmVhdGVqcy5YSFJSZXF1ZXN0ID0gY3JlYXRlanMucHJvbW90ZShYSFJSZXF1ZXN0LCBcIkFic3RyYWN0UmVxdWVzdFwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIExvYWRRdWV1ZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuLypcbiBUT0RPOiBXSU5ET1dTIElTU1VFU1xuICogTm8gZXJyb3IgZm9yIEhUTUwgYXVkaW8gaW4gSUUgNjc4XG4gKiBTVkcgbm8gZmFpbHVyZSBlcnJvciBpbiBJRSA2NyAobWF5YmUgOCkgVEFHUyBBTkQgWEhSXG4gKiBObyBzY3JpcHQgY29tcGxldGUgaGFuZGxlciBpbiBJRSA2NyBUQUdTIChYSFIgaXMgZmluZSlcbiAqIE5vIFhNTC9KU09OIGluIElFNiBUQUdTXG4gKiBOZWVkIHRvIGhpZGUgbG9hZGluZyBTVkcgaW4gT3BlcmEgVEFHU1xuICogTm8gQ1NTIG9ubG9hZC9yZWFkeXN0YXRlY2hhbmdlIGluIFNhZmFyaSBvciBBbmRyb2lkIFRBR1MgKHJlcXVpcmVzIHJ1bGUgY2hlY2tpbmcpXG4gKiBTVkcgbm8gbG9hZCBvciBmYWlsdXJlIGluIE9wZXJhIFhIUlxuICogUmVwb3J0ZWQgaXNzdWVzIHdpdGggSUU3LzhcbiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuLy8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIFRoZSBMb2FkUXVldWUgY2xhc3MgaXMgdGhlIG1haW4gQVBJIGZvciBwcmVsb2FkaW5nIGNvbnRlbnQuIExvYWRRdWV1ZSBpcyBhIGxvYWQgbWFuYWdlciwgd2hpY2ggY2FuIHByZWxvYWQgZWl0aGVyXG5cdCAqIGEgc2luZ2xlIGZpbGUsIG9yIHF1ZXVlIG9mIGZpbGVzLlxuXHQgKlxuXHQgKiA8Yj5DcmVhdGluZyBhIFF1ZXVlPC9iPjxiciAvPlxuXHQgKiBUbyB1c2UgTG9hZFF1ZXVlLCBjcmVhdGUgYSBMb2FkUXVldWUgaW5zdGFuY2UuIElmIHlvdSB3YW50IHRvIGZvcmNlIHRhZyBsb2FkaW5nIHdoZXJlIHBvc3NpYmxlLCBzZXQgdGhlIHByZWZlclhIUlxuXHQgKiBhcmd1bWVudCB0byBmYWxzZS5cblx0ICpcblx0ICogICAgICB2YXIgcXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKHRydWUpO1xuXHQgKlxuXHQgKiA8Yj5MaXN0ZW5pbmcgZm9yIEV2ZW50czwvYj48YnIgLz5cblx0ICogQWRkIGFueSBsaXN0ZW5lcnMgeW91IHdhbnQgdG8gdGhlIHF1ZXVlLiBTaW5jZSBQcmVsb2FkSlMgMC4zLjAsIHRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbGV0cyB5b3UgYWRkIGFzIG1hbnkgbGlzdGVuZXJzIGFzIHlvdSB3YW50IGZvciBldmVudHMuIFlvdSBjYW4gc3Vic2NyaWJlIHRvIHRoZSBmb2xsb3dpbmcgZXZlbnRzOjx1bD5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9jb21wbGV0ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fTogZmlyZWQgd2hlbiBhIHF1ZXVlIGNvbXBsZXRlcyBsb2FkaW5nIGFsbFxuXHQgKiAgICAgZmlsZXM8L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2Vycm9yOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319OiBmaXJlZCB3aGVuIHRoZSBxdWV1ZSBlbmNvdW50ZXJzIGFuIGVycm9yIHdpdGhcblx0ICogICAgIGFueSBmaWxlLjwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvcHJvZ3Jlc3M6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX06IFByb2dyZXNzIGZvciB0aGUgZW50aXJlIHF1ZXVlIGhhc1xuXHQgKiAgICAgY2hhbmdlZC48L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fTogQSBzaW5nbGUgZmlsZSBoYXMgY29tcGxldGVkIGxvYWRpbmcuPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZXByb2dyZXNzOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319OiBQcm9ncmVzcyBmb3IgYSBzaW5nbGUgZmlsZSBoYXMgY2hhbmdlcy4gTm90ZVxuXHQgKiAgICAgdGhhdCBvbmx5IGZpbGVzIGxvYWRlZCB3aXRoIFhIUiAob3IgcG9zc2libHkgYnkgcGx1Z2lucykgd2lsbCBmaXJlIHByb2dyZXNzIGV2ZW50cyBvdGhlciB0aGFuIDAgb3IgMTAwJS48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiAgICAgIHF1ZXVlLm9uKFwiZmlsZWxvYWRcIiwgaGFuZGxlRmlsZUxvYWQsIHRoaXMpO1xuXHQgKiAgICAgIHF1ZXVlLm9uKFwiY29tcGxldGVcIiwgaGFuZGxlQ29tcGxldGUsIHRoaXMpO1xuXHQgKlxuXHQgKiA8Yj5BZGRpbmcgZmlsZXMgYW5kIG1hbmlmZXN0czwvYj48YnIgLz5cblx0ICogQWRkIGZpbGVzIHlvdSB3YW50IHRvIGxvYWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319IG9yIGFkZCBtdWx0aXBsZSBmaWxlcyBhdCBhXG5cdCAqIHRpbWUgdXNpbmcgYSBsaXN0IG9yIGEgbWFuaWZlc3QgZGVmaW5pdGlvbiB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319LiBGaWxlcyBhcmVcblx0ICogYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgYWN0aXZlIHF1ZXVlLCBzbyB5b3UgY2FuIHVzZSB0aGVzZSBtZXRob2RzIGFzIG1hbnkgdGltZXMgYXMgeW91IGxpa2UsIHdoZW5ldmVyIHlvdVxuXHQgKiBsaWtlLlxuXHQgKlxuXHQgKiAgICAgIHF1ZXVlLmxvYWRGaWxlKFwiZmlsZVBhdGgvZmlsZS5qcGdcIik7XG5cdCAqICAgICAgcXVldWUubG9hZEZpbGUoe2lkOlwiaW1hZ2VcIiwgc3JjOlwiZmlsZVBhdGgvZmlsZS5qcGdcIn0pO1xuXHQgKiAgICAgIHF1ZXVlLmxvYWRNYW5pZmVzdChbXCJmaWxlUGF0aC9maWxlLmpwZ1wiLCB7aWQ6XCJpbWFnZVwiLCBzcmM6XCJmaWxlUGF0aC9maWxlLmpwZ1wifV0pO1xuXHQgKlxuXHQgKiAgICAgIC8vIFVzZSBhbiBleHRlcm5hbCBtYW5pZmVzdFxuXHQgKiAgICAgIHF1ZXVlLmxvYWRNYW5pZmVzdChcInBhdGgvdG8vbWFuaWZlc3QuanNvblwiKTtcblx0ICogICAgICBxdWV1ZS5sb2FkTWFuaWZlc3Qoe3NyYzpcIm1hbmlmZXN0Lmpzb25cIiwgdHlwZTpcIm1hbmlmZXN0XCJ9KTtcblx0ICpcblx0ICogSWYgeW91IHBhc3MgYGZhbHNlYCBhcyB0aGUgYGxvYWROb3dgIHBhcmFtZXRlciwgdGhlIHF1ZXVlIHdpbGwgbm90IGtpY2sgb2YgdGhlIGxvYWQgb2YgdGhlIGZpbGVzLCBidXQgaXQgd2lsbCBub3Rcblx0ICogc3RvcCBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQuIENhbGwgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2xvYWRcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIHRvIGJlZ2luXG5cdCAqIGEgcGF1c2VkIHF1ZXVlLiBOb3RlIHRoYXQgYSBwYXVzZWQgcXVldWUgd2lsbCBhdXRvbWF0aWNhbGx5IHJlc3VtZSB3aGVuIG5ldyBmaWxlcyBhcmUgYWRkZWQgdG8gaXQgd2l0aCBhXG5cdCAqIGBsb2FkTm93YCBhcmd1bWVudCBvZiBgdHJ1ZWAuXG5cdCAqXG5cdCAqICAgICAgcXVldWUubG9hZCgpO1xuXHQgKlxuXHQgKiA8Yj5GaWxlIFR5cGVzPC9iPjxiciAvPlxuXHQgKiBUaGUgZmlsZSB0eXBlIG9mIGEgbWFuaWZlc3QgaXRlbSBpcyBhdXRvLWRldGVybWluZWQgYnkgdGhlIGZpbGUgZXh0ZW5zaW9uLiBUaGUgcGF0dGVybiBtYXRjaGluZyBpbiBQcmVsb2FkSlNcblx0ICogc2hvdWxkIGhhbmRsZSB0aGUgbWFqb3JpdHkgb2Ygc3RhbmRhcmQgZmlsZSBhbmQgdXJsIGZvcm1hdHMsIGFuZCB3b3JrcyB3aXRoIGNvbW1vbiBmaWxlIGV4dGVuc2lvbnMuIElmIHlvdSBoYXZlXG5cdCAqIGVpdGhlciBhIG5vbi1zdGFuZGFyZCBmaWxlIGV4dGVuc2lvbiwgb3IgYXJlIHNlcnZpbmcgdGhlIGZpbGUgdXNpbmcgYSBwcm94eSBzY3JpcHQsIHRoZW4geW91IGNhbiBwYXNzIGluIGFcblx0ICogPGNvZGU+dHlwZTwvY29kZT4gcHJvcGVydHkgd2l0aCBhbnkgbWFuaWZlc3QgaXRlbS5cblx0ICpcblx0ICogICAgICBxdWV1ZS5sb2FkRmlsZSh7c3JjOlwicGF0aC90by9teUZpbGUubXAzeFwiLCB0eXBlOmNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNPVU5EfSk7XG5cdCAqXG5cdCAqICAgICAgLy8gTm90ZSB0aGF0IFByZWxvYWRKUyB3aWxsIG5vdCByZWFkIGEgZmlsZSBleHRlbnNpb24gZnJvbSB0aGUgcXVlcnkgc3RyaW5nXG5cdCAqICAgICAgcXVldWUubG9hZEZpbGUoe3NyYzpcImh0dHA6Ly9zZXJ2ZXIuY29tL3Byb3h5P2ZpbGU9aW1hZ2UuanBnXCIsIHR5cGU6Y3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSU1BR0V9KTtcblx0ICpcblx0ICogU3VwcG9ydGVkIHR5cGVzIGFyZSBkZWZpbmVkIG9uIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlclwifX17ey9jcm9zc0xpbmt9fSBjbGFzcywgYW5kIGluY2x1ZGU6XG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9CSU5BUlk6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IFJhdyBiaW5hcnkgZGF0YSB2aWEgWEhSPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9DU1M6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IENTUyBmaWxlczwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSU1BR0U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IENvbW1vbiBpbWFnZSBmb3JtYXRzPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9KQVZBU0NSSVBUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBKYXZhU2NyaXB0IGZpbGVzPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9KU09OOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBKU09OIGRhdGE8L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pTT05QOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBKU09OIGZpbGVzIGNyb3NzLWRvbWFpbjwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvTUFOSUZFU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IEEgbGlzdCBvZiBmaWxlcyB0byBsb2FkIGluIEpTT04gZm9ybWF0LCBzZWVcblx0ICogICAgIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fTwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvU09VTkQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IEF1ZGlvIGZpbGUgZm9ybWF0czwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvU1BSSVRFU0hFRVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IEpTT04gU3ByaXRlU2hlZXQgZGVmaW5pdGlvbnMuIFRoaXNcblx0ICogICAgIHdpbGwgYWxzbyBsb2FkIHN1Yi1pbWFnZXMsIGFuZCBwcm92aWRlIGEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UuPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TVkc6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IFNWRyBmaWxlczwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvVEVYVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogVGV4dCBmaWxlcyAtIFhIUiBvbmx5PC9saT5cbiAgICAgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1ZJREVPOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBWaWRlbyBvYmplY3RzPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9YTUw6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IFhNTCBkYXRhPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogPGVtPk5vdGU6IExvYWRlciB0eXBlcyB1c2VkIHRvIGJlIGRlZmluZWQgb24gTG9hZFF1ZXVlLCBidXQgaGF2ZSBiZWVuIG1vdmVkIHRvIEFic3RyYWN0TG9hZGVyIGZvciBiZXR0ZXJcblx0ICogcG9ydGFiaWxpdHkgb2YgbG9hZGVyIGNsYXNzZXMsIHdoaWNoIGNhbiBiZSB1c2VkIGluZGl2aWR1YWxseSBub3cuIFRoZSBwcm9wZXJ0aWVzIG9uIExvYWRRdWV1ZSBzdGlsbCBleGlzdCwgYnV0XG5cdCAqIGFyZSBkZXByZWNhdGVkLjwvZW0+XG5cdCAqXG5cdCAqIDxiPkhhbmRsaW5nIFJlc3VsdHM8L2I+PGJyIC8+XG5cdCAqIFdoZW4gYSBmaWxlIGlzIGZpbmlzaGVkIGRvd25sb2FkaW5nLCBhIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBpc1xuXHQgKiBkaXNwYXRjaGVkLiBJbiBhbiBleGFtcGxlIGFib3ZlLCB0aGVyZSBpcyBhbiBldmVudCBsaXN0ZW5lciBzbmlwcGV0IGZvciBmaWxlbG9hZC4gTG9hZGVkIGZpbGVzIGFyZSB1c3VhbGx5IGFcblx0ICogZm9ybWF0dGVkIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGltbWVkaWF0ZWx5LCBpbmNsdWRpbmc6XG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5CaW5hcnk6IFRoZSBiaW5hcnkgbG9hZGVkIHJlc3VsdDwvbGk+XG5cdCAqICAgICA8bGk+Q1NTOiBBICZsdDtsaW5rIC8mZ3Q7IHRhZzwvbGk+XG5cdCAqICAgICA8bGk+SW1hZ2U6IEFuICZsdDtpbWcgLyZndDsgdGFnPC9saT5cblx0ICogICAgIDxsaT5KYXZhU2NyaXB0OiBBICZsdDtzY3JpcHQgLyZndDsgdGFnPC9saT5cblx0ICogICAgIDxsaT5KU09OL0pTT05QOiBBIGZvcm1hdHRlZCBKYXZhU2NyaXB0IE9iamVjdDwvbGk+XG5cdCAqICAgICA8bGk+TWFuaWZlc3Q6IEEgSmF2YVNjcmlwdCBvYmplY3QuXG5cdCAqICAgICA8bGk+U291bmQ6IEFuICZsdDthdWRpbyAvJmd0OyB0YWc8L2E+XG5cdCAqICAgICA8bGk+U3ByaXRlU2hlZXQ6IEEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UsIGNvbnRhaW5pbmcgbG9hZGVkIGltYWdlcy5cblx0ICogICAgIDxsaT5TVkc6IEFuICZsdDtvYmplY3QgLyZndDsgdGFnPC9saT5cblx0ICogICAgIDxsaT5UZXh0OiBSYXcgdGV4dDwvbGk+XG4gICAgICogICAgIDxsaT5WaWRlbzogQSBWaWRlbyBET00gbm9kZTwvbGk+XG5cdCAqICAgICA8bGk+WE1MOiBBbiBYTUwgRE9NIG5vZGU8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZUZpbGVMb2FkKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIHZhciBpdGVtID0gZXZlbnQuaXRlbTsgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGl0ZW0gdGhhdCB3YXMgcGFzc2VkIGluIHRvIHRoZSBMb2FkUXVldWVcblx0ICogICAgICAgICAgdmFyIHR5cGUgPSBpdGVtLnR5cGU7XG5cdCAqXG5cdCAqICAgICAgICAgIC8vIEFkZCBhbnkgaW1hZ2VzIHRvIHRoZSBwYWdlIGJvZHkuXG5cdCAqICAgICAgICAgIGlmICh0eXBlID09IGNyZWF0ZWpzLkxvYWRRdWV1ZS5JTUFHRSkge1xuXHQgKiAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChldmVudC5yZXN1bHQpO1xuXHQgKiAgICAgICAgICB9XG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBBdCBhbnkgdGltZSBhZnRlciB0aGUgZmlsZSBoYXMgYmVlbiBsb2FkZWQgKHVzdWFsbHkgYWZ0ZXIgdGhlIHF1ZXVlIGhhcyBjb21wbGV0ZWQpLCBhbnkgcmVzdWx0IGNhbiBiZSBsb29rZWQgdXBcblx0ICogdmlhIGl0cyBcImlkXCIgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2dldFJlc3VsdFwifX17ey9jcm9zc0xpbmt9fS4gSWYgbm8gaWQgd2FzIHByb3ZpZGVkLCB0aGVuIHRoZVxuXHQgKiBcInNyY1wiIG9yIGZpbGUgcGF0aCBjYW4gYmUgdXNlZCBpbnN0ZWFkLCBpbmNsdWRpbmcgdGhlIGBwYXRoYCBkZWZpbmVkIGJ5IGEgbWFuaWZlc3QsIGJ1dCA8c3Ryb25nPm5vdCBpbmNsdWRpbmc8L3N0cm9uZz5cblx0ICogYSBiYXNlIHBhdGggZGVmaW5lZCBvbiB0aGUgTG9hZFF1ZXVlLiBJdCBpcyByZWNvbW1lbmRlZCB0byBhbHdheXMgcGFzcyBhbiBpZCBpZiB5b3Ugd2FudCB0byBsb29rIHVwIGNvbnRlbnQuXG5cdCAqXG5cdCAqICAgICAgdmFyIGltYWdlID0gcXVldWUuZ2V0UmVzdWx0KFwiaW1hZ2VcIik7XG5cdCAqICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbWFnZSk7XG5cdCAqXG5cdCAqIFJhdyBsb2FkZWQgY29udGVudCBjYW4gYmUgYWNjZXNzZWQgdXNpbmcgdGhlIDxjb2RlPnJhd1Jlc3VsdDwvY29kZT4gcHJvcGVydHkgb2YgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCwgb3IgY2FuIGJlIGxvb2tlZCB1cCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZ2V0UmVzdWx0XCJ9fXt7L2Nyb3NzTGlua319LCBwYXNzaW5nIGB0cnVlYCBhcyB0aGUgMm5kXG5cdCAqIGFyZ3VtZW50LiBUaGlzIGlzIG9ubHkgYXBwbGljYWJsZSBmb3IgY29udGVudCB0aGF0IGhhcyBiZWVuIHBhcnNlZCBmb3IgdGhlIGJyb3dzZXIsIHNwZWNpZmljYWxseTogSmF2YVNjcmlwdCxcblx0ICogQ1NTLCBYTUwsIFNWRywgYW5kIEpTT04gb2JqZWN0cywgb3IgYW55dGhpbmcgbG9hZGVkIHdpdGggWEhSLlxuXHQgKlxuXHQgKiAgICAgIHZhciBpbWFnZSA9IHF1ZXVlLmdldFJlc3VsdChcImltYWdlXCIsIHRydWUpOyAvLyBsb2FkIHRoZSBiaW5hcnkgaW1hZ2UgZGF0YSBsb2FkZWQgd2l0aCBYSFIuXG5cdCAqXG5cdCAqIDxiPlBsdWdpbnM8L2I+PGJyIC8+XG5cdCAqIExvYWRRdWV1ZSBoYXMgYSBzaW1wbGUgcGx1Z2luIGFyY2hpdGVjdHVyZSB0byBoZWxwIHByb2Nlc3MgYW5kIHByZWxvYWQgY29udGVudC4gRm9yIGV4YW1wbGUsIHRvIHByZWxvYWQgYXVkaW8sXG5cdCAqIG1ha2Ugc3VyZSB0byBpbnN0YWxsIHRoZSA8YSBocmVmPVwiaHR0cDovL3NvdW5kanMuY29tXCI+U291bmRKUzwvYT4gU291bmQgY2xhc3MsIHdoaWNoIHdpbGwgaGVscCBsb2FkIEhUTUwgYXVkaW8sXG5cdCAqIEZsYXNoIGF1ZGlvLCBhbmQgV2ViQXVkaW8gZmlsZXMuIFRoaXMgc2hvdWxkIGJlIGluc3RhbGxlZCA8c3Ryb25nPmJlZm9yZTwvc3Ryb25nPiBsb2FkaW5nIGFueSBhdWRpbyBmaWxlcy5cblx0ICpcblx0ICogICAgICBxdWV1ZS5pbnN0YWxsUGx1Z2luKGNyZWF0ZWpzLlNvdW5kKTtcblx0ICpcblx0ICogPGg0Pktub3duIEJyb3dzZXIgSXNzdWVzPC9oND5cblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPkJyb3dzZXJzIHdpdGhvdXQgYXVkaW8gc3VwcG9ydCBjYW4gbm90IGxvYWQgYXVkaW8gZmlsZXMuPC9saT5cblx0ICogICAgIDxsaT5TYWZhcmkgb24gTWFjIE9TIFggY2FuIG9ubHkgcGxheSBIVE1MIGF1ZGlvIGlmIFF1aWNrVGltZSBpcyBpbnN0YWxsZWQ8L2xpPlxuXHQgKiAgICAgPGxpPkhUTUwgQXVkaW8gdGFncyB3aWxsIG9ubHkgZG93bmxvYWQgdW50aWwgdGhlaXIgPGNvZGU+Y2FuUGxheVRocm91Z2g8L2NvZGU+IGV2ZW50IGlzIGZpcmVkLiBCcm93c2VycyBvdGhlclxuXHQgKiAgICAgdGhhbiBDaHJvbWUgd2lsbCBjb250aW51ZSB0byBkb3dubG9hZCBpbiB0aGUgYmFja2dyb3VuZC48L2xpPlxuXHQgKiAgICAgPGxpPldoZW4gbG9hZGluZyBzY3JpcHRzIHVzaW5nIHRhZ3MsIHRoZXkgYXJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gdGhlIGRvY3VtZW50LjwvbGk+XG5cdCAqICAgICA8bGk+U2NyaXB0cyBsb2FkZWQgdmlhIFhIUiBtYXkgbm90IGJlIHByb3Blcmx5IGluc3BlY3RhYmxlIHdpdGggYnJvd3NlciB0b29scy48L2xpPlxuXHQgKiAgICAgPGxpPklFNiBhbmQgSUU3IChhbmQgc29tZSBvdGhlciBicm93c2VycykgbWF5IG5vdCBiZSBhYmxlIHRvIGxvYWQgWE1MLCBUZXh0LCBvciBKU09OLCBzaW5jZSB0aGV5IHJlcXVpcmVcblx0ICogICAgIFhIUiB0byB3b3JrLjwvbGk+XG5cdCAqICAgICA8bGk+Q29udGVudCBsb2FkZWQgdmlhIHRhZ3Mgd2lsbCBub3Qgc2hvdyBwcm9ncmVzcywgYW5kIHdpbGwgY29udGludWUgdG8gZG93bmxvYWQgaW4gdGhlIGJhY2tncm91bmQgd2hlblxuXHQgKiAgICAgY2FuY2VsZWQsIGFsdGhvdWdoIG5vIGV2ZW50cyB3aWxsIGJlIGRpc3BhdGNoZWQuPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogQGNsYXNzIExvYWRRdWV1ZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmVmZXJYSFI9dHJ1ZV0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwcmVsb2FkIGluc3RhbmNlIHdpbGwgZmF2b3IgbG9hZGluZyB3aXRoIFhIUiAoWE1MIEhUVFBcblx0ICogUmVxdWVzdHMpLCBvciBIVE1MIHRhZ3MuIFdoZW4gdGhpcyBpcyBgZmFsc2VgLCB0aGUgcXVldWUgd2lsbCB1c2UgdGFnIGxvYWRpbmcgd2hlbiBwb3NzaWJsZSwgYW5kIGZhbGwgYmFjayBvbiBYSFJcblx0ICogd2hlbiBuZWNlc3NhcnkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbYmFzZVBhdGg9XCJcIl0gQSBwYXRoIHRoYXQgd2lsbCBiZSBwcmVwZW5kZWQgb24gdG8gdGhlIHNvdXJjZSBwYXJhbWV0ZXIgb2YgYWxsIGl0ZW1zIGluIHRoZSBxdWV1ZVxuXHQgKiBiZWZvcmUgdGhleSBhcmUgbG9hZGVkLiAgU291cmNlcyBiZWdpbm5pbmcgd2l0aCBhIHByb3RvY29sIHN1Y2ggYXMgYGh0dHA6Ly9gIG9yIGEgcmVsYXRpdmUgcGF0aCBzdWNoIGFzIGAuLi9gXG5cdCAqIHdpbGwgbm90IHJlY2VpdmUgYSBiYXNlIHBhdGguXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEJvb2xlYW59IFtjcm9zc09yaWdpbj1cIlwiXSBBbiBvcHRpb25hbCBmbGFnIHRvIHN1cHBvcnQgaW1hZ2VzIGxvYWRlZCBmcm9tIGEgQ09SUy1lbmFibGVkIHNlcnZlci4gVG9cblx0ICogdXNlIGl0LCBzZXQgdGhpcyB2YWx1ZSB0byBgdHJ1ZWAsIHdoaWNoIHdpbGwgZGVmYXVsdCB0aGUgY3Jvc3NPcmlnaW4gcHJvcGVydHkgb24gaW1hZ2VzIHRvIFwiQW5vbnltb3VzXCIuIEFueVxuXHQgKiBzdHJpbmcgdmFsdWUgd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCwgYnV0IG9ubHkgXCJcIiBhbmQgXCJBbm9ueW1vdXNcIiBhcmUgcmVjb21tZW5kZWQuIDxzdHJvbmc+Tm90ZTogVGhlIGNyb3NzT3JpZ2luXG5cdCAqIHBhcmFtZXRlciBpcyBkZXByZWNhdGVkLiBVc2UgTG9hZEl0ZW0uY3Jvc3NPcmlnaW4gaW5zdGVhZDwvc3Ryb25nPlxuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICovXG5cdGZ1bmN0aW9uIExvYWRRdWV1ZSAocHJlZmVyWEhSLCBiYXNlUGF0aCwgY3Jvc3NPcmlnaW4pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKCk7XG5cblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBvZiB0aGUgcGx1Z2lucyByZWdpc3RlcmVkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9pbnN0YWxsUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBfcGx1Z2luc1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBzaW5jZSAwLjYuMVxuXHRcdCAqL1xuXHRcdHRoaXMuX3BsdWdpbnMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBoYXNoIG9mIGNhbGxiYWNrcyB0aGF0IGFyZSBmaXJlZCBmb3IgZWFjaCBmaWxlIHR5cGUgYmVmb3JlIHRoZSBmaWxlIGlzIGxvYWRlZCwgZ2l2aW5nIHBsdWdpbnMgdGhlXG5cdFx0ICogYWJpbGl0eSB0byBvdmVycmlkZSBwcm9wZXJ0aWVzIG9mIHRoZSBsb2FkLiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvaW5zdGFsbFBsdWdpblwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIG1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgX3R5cGVDYWxsYmFja3Ncblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fdHlwZUNhbGxiYWNrcyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IGhhc2ggb2YgY2FsbGJhY2tzIHRoYXQgYXJlIGZpcmVkIGZvciBlYWNoIGZpbGUgZXh0ZW5zaW9uIGJlZm9yZSB0aGUgZmlsZSBpcyBsb2FkZWQsIGdpdmluZyBwbHVnaW5zIHRoZVxuXHRcdCAqIGFiaWxpdHkgdG8gb3ZlcnJpZGUgcHJvcGVydGllcyBvZiB0aGUgbG9hZC4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2luc3RhbGxQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBtZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdFx0ICogQHByb3BlcnR5IF9leHRlbnNpb25DYWxsYmFja3Ncblx0XHQgKiBAdHlwZSB7bnVsbH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2V4dGVuc2lvbkNhbGxiYWNrcyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG5leHQgcHJlbG9hZCBxdWV1ZSB0byBwcm9jZXNzIHdoZW4gdGhpcyBvbmUgaXMgY29tcGxldGUuIElmIGFuIGVycm9yIGlzIHRocm93biBpbiB0aGUgY3VycmVudCBxdWV1ZSwgYW5kXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3N0b3BPbkVycm9yOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlzIGB0cnVlYCwgdGhlIG5leHQgcXVldWUgd2lsbCBub3QgYmUgcHJvY2Vzc2VkLlxuXHRcdCAqIEBwcm9wZXJ0eSBuZXh0XG5cdFx0ICogQHR5cGUge0xvYWRRdWV1ZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5uZXh0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEVuc3VyZSBsb2FkZWQgc2NyaXB0cyBcImNvbXBsZXRlXCIgaW4gdGhlIG9yZGVyIHRoZXkgYXJlIHNwZWNpZmllZC4gTG9hZGVkIHNjcmlwdHMgYXJlIGFkZGVkIHRvIHRoZSBkb2N1bWVudCBoZWFkXG5cdFx0ICogb25jZSB0aGV5IGFyZSBsb2FkZWQuIFNjcmlwdHMgbG9hZGVkIHZpYSB0YWdzIHdpbGwgbG9hZCBvbmUtYXQtYS10aW1lIHdoZW4gdGhpcyBwcm9wZXJ0eSBpcyBgdHJ1ZWAsIHdoZXJlYXNcblx0XHQgKiBzY3JpcHRzIGxvYWRlZCB1c2luZyBYSFIgY2FuIGxvYWQgaW4gYW55IG9yZGVyLCBidXQgd2lsbCBcImZpbmlzaFwiIGFuZCBiZSBhZGRlZCB0byB0aGUgZG9jdW1lbnQgaW4gdGhlIG9yZGVyXG5cdFx0ICogc3BlY2lmaWVkLlxuXHRcdCAqXG5cdFx0ICogQW55IGl0ZW1zIGNhbiBiZSBzZXQgdG8gbG9hZCBpbiBvcmRlciBieSBzZXR0aW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJtYWludGFpbk9yZGVyOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogcHJvcGVydHkgb24gdGhlIGxvYWQgaXRlbSwgb3IgYnkgZW5zdXJpbmcgdGhhdCBvbmx5IG9uZSBjb25uZWN0aW9uIGNhbiBiZSBvcGVuIGF0IGEgdGltZSB1c2luZ1xuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRNYXhDb25uZWN0aW9uc1wifX17ey9jcm9zc0xpbmt9fS4gTm90ZSB0aGF0IHdoZW4gdGhlIGBtYWludGFpblNjcmlwdE9yZGVyYCBwcm9wZXJ0eVxuXHRcdCAqIGlzIHNldCB0byBgdHJ1ZWAsIHNjcmlwdHMgaXRlbXMgYXJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIGBtYWludGFpbk9yZGVyPXRydWVgLCBhbmQgY2hhbmdpbmcgdGhlXG5cdFx0ICogYG1haW50YWluU2NyaXB0T3JkZXJgIHRvIGBmYWxzZWAgZHVyaW5nIGEgbG9hZCB3aWxsIG5vdCBjaGFuZ2UgaXRlbXMgYWxyZWFkeSBpbiBhIHF1ZXVlLlxuXHRcdCAqXG5cdFx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHRcdCAqXG5cdFx0ICogICAgICB2YXIgcXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG5cdFx0ICogICAgICBxdWV1ZS5zZXRNYXhDb25uZWN0aW9ucygzKTsgLy8gU2V0IGEgaGlnaGVyIG51bWJlciB0byBsb2FkIG11bHRpcGxlIGl0ZW1zIGF0IG9uY2Vcblx0XHQgKiAgICAgIHF1ZXVlLm1haW50YWluU2NyaXB0T3JkZXIgPSB0cnVlOyAvLyBFbnN1cmUgc2NyaXB0cyBhcmUgbG9hZGVkIGluIG9yZGVyXG5cdFx0ICogICAgICBxdWV1ZS5sb2FkTWFuaWZlc3QoW1xuXHRcdCAqICAgICAgICAgIFwic2NyaXB0MS5qc1wiLFxuXHRcdCAqICAgICAgICAgIFwic2NyaXB0Mi5qc1wiLFxuXHRcdCAqICAgICAgICAgIFwiaW1hZ2UucG5nXCIsIC8vIExvYWQgYW55IHRpbWVcblx0XHQgKiAgICAgICAgICB7c3JjOiBcImltYWdlMi5wbmdcIiwgbWFpbnRhaW5PcmRlcjogdHJ1ZX0gLy8gV2lsbCB3YWl0IGZvciBzY3JpcHQyLmpzXG5cdFx0ICogICAgICAgICAgXCJpbWFnZTMucG5nXCIsXG5cdFx0ICogICAgICAgICAgXCJzY3JpcHQzLmpzXCIgLy8gV2lsbCB3YWl0IGZvciBpbWFnZTIucG5nIGJlZm9yZSBsb2FkaW5nIChvciBjb21wbGV0aW5nIHdoZW4gbG9hZGluZyB3aXRoIFhIUilcblx0XHQgKiAgICAgIF0pO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IG1haW50YWluU2NyaXB0T3JkZXJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5tYWludGFpblNjcmlwdE9yZGVyID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZXMgaWYgdGhlIExvYWRRdWV1ZSB3aWxsIHN0b3AgcHJvY2Vzc2luZyB0aGUgY3VycmVudCBxdWV1ZSB3aGVuIGFuIGVycm9yIGlzIGVuY291bnRlcmVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBzdG9wT25FcnJvclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5zdG9wT25FcnJvciA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBtYXhpbXVtIG9wZW4gY29ubmVjdGlvbnMgdGhhdCBhIGxvYWRRdWV1ZSB0cmllcyB0byBtYWludGFpbi4gUGxlYXNlIHNlZVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRNYXhDb25uZWN0aW9uc1wifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgX21heENvbm5lY3Rpb25zXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9tYXhDb25uZWN0aW9ucyA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBBbiBpbnRlcm5hbCBsaXN0IG9mIGFsbCB0aGUgZGVmYXVsdCBMb2FkZXJzIHRoYXQgYXJlIGluY2x1ZGVkIHdpdGggUHJlbG9hZEpTLiBCZWZvcmUgYW4gaXRlbSBpcyBsb2FkZWQsIHRoZVxuXHRcdCAqIGF2YWlsYWJsZSBsb2FkZXIgbGlzdCBpcyBpdGVyYXRlZCwgaW4gdGhlIG9yZGVyIHRoZXkgYXJlIGluY2x1ZGVkLCBhbmQgYXMgc29vbiBhcyBhIGxvYWRlciBpbmRpY2F0ZXMgaXQgY2FuXG5cdFx0ICogaGFuZGxlIHRoZSBjb250ZW50LCBpdCB3aWxsIGJlIHNlbGVjdGVkLiBUaGUgZGVmYXVsdCBsb2FkZXIsICh7eyNjcm9zc0xpbmsgXCJUZXh0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGlzXG5cdFx0ICogbGFzdCBpbiB0aGUgbGlzdCwgc28gaXQgd2lsbCBiZSB1c2VkIGlmIG5vIG90aGVyIG1hdGNoIGlzIGZvdW5kLiBUeXBpY2FsbHksIGxvYWRlcnMgd2lsbCBtYXRjaCBiYXNlZCBvbiB0aGVcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS90eXBlXCJ9fXt7L2Nyb3NzTGlua319LCB3aGljaCBpcyBhdXRvbWF0aWNhbGx5IGRldGVybWluZWQgdXNpbmcgdGhlIGZpbGUgZXh0ZW5zaW9uIG9mXG5cdFx0ICogdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL3NyYzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKlxuXHRcdCAqIExvYWRlcnMgY2FuIGJlIHJlbW92ZWQgZnJvbSBQcmVsb2FkSlMgYnkgc2ltcGx5IG5vdCBpbmNsdWRpbmcgdGhlbS5cblx0XHQgKlxuXHRcdCAqIEN1c3RvbSBsb2FkZXJzIGluc3RhbGxlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJyZWdpc3RlckxvYWRlclwifX17ey9jcm9zc0xpbmt9fSB3aWxsIGJlIHByZXBlbmRlZCB0byB0aGlzIGxpc3Rcblx0XHQgKiBzbyB0aGF0IHRoZXkgYXJlIGNoZWNrZWQgZmlyc3QuXG5cdFx0ICogQHByb3BlcnR5IF9hdmFpbGFibGVMb2FkZXJzXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHNpbmNlIDAuNi4wXG5cdFx0ICovXG5cdFx0dGhpcy5fYXZhaWxhYmxlTG9hZGVycyA9IFtcblx0XHRcdGNyZWF0ZWpzLkltYWdlTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuSmF2YVNjcmlwdExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLkNTU0xvYWRlcixcblx0XHRcdGNyZWF0ZWpzLkpTT05Mb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5KU09OUExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlNvdW5kTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuTWFuaWZlc3RMb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5TcHJpdGVTaGVldExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlhNTExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlNWR0xvYWRlcixcblx0XHRcdGNyZWF0ZWpzLkJpbmFyeUxvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlZpZGVvTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuVGV4dExvYWRlclxuXHRcdF07XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIGJ1aWx0IGluIGxvYWRlcnMsIHNvIHRoZXkgY2FuJ3QgYmUgcmVtb3ZlZCBieSB7eyNjcm9zc0xpbmsgXCJ1bnJlZ2lzdGVyTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua30uXG5cdFx0XHRcdCAqIEBwcm9wZXJ0eSBfZGVmYXVsdExvYWRlckxlbmd0aFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAc2luY2UgMC42LjBcblx0XHQgKi9cblx0XHR0aGlzLl9kZWZhdWx0TG9hZGVyTGVuZ3RoID0gdGhpcy5fYXZhaWxhYmxlTG9hZGVycy5sZW5ndGg7XG5cblx0XHR0aGlzLmluaXQocHJlZmVyWEhSLCBiYXNlUGF0aCwgY3Jvc3NPcmlnaW4pO1xuXHR9XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoTG9hZFF1ZXVlLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gTG9hZFF1ZXVlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXHQvKipcblx0ICogQW4gaW50ZXJuYWwgaW5pdGlhbGl6YXRpb24gbWV0aG9kLCB3aGljaCBpcyB1c2VkIGZvciBpbml0aWFsIHNldCB1cCwgYnV0IGFsc28gdG8gcmVzZXQgdGhlIExvYWRRdWV1ZS5cblx0ICogQG1ldGhvZCBpbml0XG5cdCAqIEBwYXJhbSBwcmVmZXJYSFJcblx0ICogQHBhcmFtIGJhc2VQYXRoXG5cdCAqIEBwYXJhbSBjcm9zc09yaWdpblxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5pbml0ID0gZnVuY3Rpb24gKHByZWZlclhIUiwgYmFzZVBhdGgsIGNyb3NzT3JpZ2luKSB7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSB1c2VYSFJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICogQGRlcHJlY2F0ZWQgVXNlIHByZWZlclhIUiBpbnN0ZWFkLlxuXHRcdCAqL1xuXHRcdHRoaXMudXNlWEhSID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRyeSBhbmQgdXNlIFhNTEh0dHBSZXF1ZXN0IChYSFIpIHdoZW4gcG9zc2libGUuIE5vdGUgdGhhdCBMb2FkUXVldWUgd2lsbCBkZWZhdWx0IHRvIHRhZyBsb2FkaW5nIG9yIFhIUlxuXHRcdCAqIGxvYWRpbmcgZGVwZW5kaW5nIG9uIHRoZSByZXF1aXJlbWVudHMgZm9yIGEgbWVkaWEgdHlwZS4gRm9yIGV4YW1wbGUsIEhUTUwgYXVkaW8gY2FuIG5vdCBiZSBsb2FkZWQgd2l0aCBYSFIsXG5cdFx0ICogYW5kIHBsYWluIHRleHQgY2FuIG5vdCBiZSBsb2FkZWQgd2l0aCB0YWdzLCBzbyBpdCB3aWxsIGRlZmF1bHQgdGhlIHRoZSBjb3JyZWN0IHR5cGUgaW5zdGVhZCBvZiB1c2luZyB0aGVcblx0XHQgKiB1c2VyLWRlZmluZWQgdHlwZS5cblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICogQHNpbmNlIDAuNi4wXG5cdFx0ICovXG5cdFx0dGhpcy5wcmVmZXJYSFIgPSB0cnVlOyAvL1RPRE86IEdldC9TZXRcblx0XHR0aGlzLl9wcmVmZXJYSFIgPSB0cnVlO1xuXHRcdHRoaXMuc2V0UHJlZmVyWEhSKHByZWZlclhIUik7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdGhlIHF1ZXVlIGlzIGN1cnJlbnRseSBwYXVzZWQgb3Igbm90LlxuXHRcdCAqIEBwcm9wZXJ0eSBfcGF1c2VkXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEEgcGF0aCB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIG9uIHRvIHRoZSBpdGVtJ3Mge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vc3JjOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LiBUaGVcblx0XHQgKiBgX2Jhc2VQYXRoYCBwcm9wZXJ0eSB3aWxsIG9ubHkgYmUgdXNlZCBpZiBhbiBpdGVtJ3Mgc291cmNlIGlzIHJlbGF0aXZlLCBhbmQgZG9lcyBub3QgaW5jbHVkZSBhIHByb3RvY29sIHN1Y2hcblx0XHQgKiBhcyBgaHR0cDovL2AsIG9yIGEgcmVsYXRpdmUgcGF0aCBzdWNoIGFzIGAuLi9gLlxuXHRcdCAqIEBwcm9wZXJ0eSBfYmFzZVBhdGhcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHNpbmNlIDAuMy4xXG5cdFx0ICovXG5cdFx0dGhpcy5fYmFzZVBhdGggPSBiYXNlUGF0aDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9wdGlvbmFsIGZsYWcgdG8gc2V0IG9uIGltYWdlcyB0aGF0IGFyZSBsb2FkZWQgdXNpbmcgUHJlbG9hZEpTLCB3aGljaCBlbmFibGVzIENPUlMgc3VwcG9ydC4gSW1hZ2VzIGxvYWRlZFxuXHRcdCAqIGNyb3NzLWRvbWFpbiBieSBzZXJ2ZXJzIHRoYXQgc3VwcG9ydCBDT1JTIHJlcXVpcmUgdGhlIGNyb3NzT3JpZ2luIGZsYWcgdG8gYmUgbG9hZGVkIGFuZCBpbnRlcmFjdGVkIHdpdGggYnlcblx0XHQgKiBhIGNhbnZhcy4gV2hlbiBsb2FkaW5nIGxvY2FsbHksIG9yIHdpdGggYSBzZXJ2ZXIgd2l0aCBubyBDT1JTIHN1cHBvcnQsIHRoaXMgZmxhZyBjYW4gY2F1c2Ugb3RoZXIgc2VjdXJpdHkgaXNzdWVzLFxuXHRcdCAqIHNvIGl0IGlzIHJlY29tbWVuZGVkIHRvIG9ubHkgc2V0IGl0IGlmIHlvdSBhcmUgc3VyZSB0aGUgc2VydmVyIHN1cHBvcnRzIGl0LiBDdXJyZW50bHksIHN1cHBvcnRlZCB2YWx1ZXMgYXJlIFwiXCJcblx0XHQgKiBhbmQgXCJBbm9ueW1vdXNcIi5cblx0XHQgKiBAcHJvcGVydHkgX2Nyb3NzT3JpZ2luXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBcIlwiXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAc2luY2UgMC40LjFcblx0XHQgKi9cblx0XHR0aGlzLl9jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZFN0YXJ0IGV2ZW50IHdhcyBkaXNwYXRjaGVkIGFscmVhZHkuIFRoaXMgZXZlbnQgaXMgb25seSBmaXJlZCBvbmUgdGltZSwgd2hlbiB0aGUgZmlyc3Rcblx0XHQgKiBmaWxlIGlzIHJlcXVlc3RlZC5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRTdGFydFdhc0Rpc3BhdGNoZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZFN0YXJ0V2FzRGlzcGF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBjdXJyZW50bHkgYSBzY3JpcHQgbG9hZGluZy4gVGhpcyBoZWxwcyBlbnN1cmUgdGhhdCBvbmx5IGEgc2luZ2xlIHNjcmlwdCBsb2FkcyBhdCBvbmNlIHdoZW5cblx0XHQgKiB1c2luZyBhIHNjcmlwdCB0YWcgdG8gZG8gcHJlbG9hZGluZy5cblx0XHQgKiBAcHJvcGVydHkgX2N1cnJlbnRseUxvYWRpbmdTY3JpcHRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2N1cnJlbnRseUxvYWRpbmdTY3JpcHQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgY29udGFpbmluZyB0aGUgY3VycmVudGx5IGRvd25sb2FkaW5nIGZpbGVzLlxuXHRcdCAqIEBwcm9wZXJ0eSBfY3VycmVudExvYWRzXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fY3VycmVudExvYWRzID0gW107XG5cblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBjb250YWluaW5nIHRoZSBxdWV1ZWQgaXRlbXMgdGhhdCBoYXZlIG5vdCB5ZXQgc3RhcnRlZCBkb3dubG9hZGluZy5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRRdWV1ZVxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRRdWV1ZSA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgY29udGFpbmluZyBkb3dubG9hZHMgdGhhdCBoYXZlIG5vdCBjb21wbGV0ZWQsIHNvIHRoYXQgdGhlIExvYWRRdWV1ZSBjYW4gYmUgcHJvcGVybHkgcmVzZXQuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkUXVldWVCYWNrdXBcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkUXVldWVCYWNrdXAgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBoYXNoIG9mIGl0ZW1zIHRoYXQgaGF2ZSBmaW5pc2hlZCBkb3dubG9hZGluZywgaW5kZXhlZCBieSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBpZC5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRJdGVtc0J5SWRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZEl0ZW1zQnlJZCA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IGhhc2ggb2YgaXRlbXMgdGhhdCBoYXZlIGZpbmlzaGVkIGRvd25sb2FkaW5nLCBpbmRleGVkIGJ5IHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogc291cmNlLlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZEl0ZW1zQnlTcmNcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZEl0ZW1zQnlTcmMgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBoYXNoIG9mIGxvYWRlZCBpdGVtcywgaW5kZXhlZCBieSB0aGUgSUQgb2YgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZGVkUmVzdWx0c1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkZWRSZXN1bHRzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgaGFzaCBvZiB1bi1wYXJzZWQgbG9hZGVkIGl0ZW1zLCBpbmRleGVkIGJ5IHRoZSBJRCBvZiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkZWRSYXdSZXN1bHRzXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRlZFJhd1Jlc3VsdHMgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBudW1iZXIgb2YgaXRlbXMgdGhhdCBoYXZlIGJlZW4gcmVxdWVzdGVkLiBUaGlzIGhlbHBzIG1hbmFnZSBhbiBvdmVyYWxsIHByb2dyZXNzIHdpdGhvdXQga25vd2luZyBob3cgbGFyZ2Vcblx0XHQgKiB0aGUgZmlsZXMgYXJlIGJlZm9yZSB0aGV5IGFyZSBkb3dubG9hZGVkLiBUaGlzIGRvZXMgbm90IGluY2x1ZGUgaXRlbXMgaW5zaWRlIG9mIGxvYWRlcnMgc3VjaCBhcyB0aGVcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgX251bUl0ZW1zXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9udW1JdGVtcyA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRoYXQgaGF2ZSBjb21wbGV0ZWQgbG9hZGVkLiBUaGlzIGhlbHBzIG1hbmFnZSBhbiBvdmVyYWxsIHByb2dyZXNzIHdpdGhvdXQga25vd2luZyBob3cgbGFyZ2Vcblx0XHQgKiB0aGUgZmlsZXMgYXJlIGJlZm9yZSB0aGV5IGFyZSBkb3dubG9hZGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfbnVtSXRlbXNMb2FkZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX251bUl0ZW1zTG9hZGVkID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEEgbGlzdCBvZiBzY3JpcHRzIGluIHRoZSBvcmRlciB0aGV5IHdlcmUgcmVxdWVzdGVkLiBUaGlzIGhlbHBzIGVuc3VyZSB0aGF0IHNjcmlwdHMgYXJlIFwiY29tcGxldGVkXCIgaW4gdGhlIHJpZ2h0XG5cdFx0ICogb3JkZXIuXG5cdFx0ICogQHByb3BlcnR5IF9zY3JpcHRPcmRlclxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3NjcmlwdE9yZGVyID0gW107XG5cblx0XHQvKipcblx0XHQgKiBBIGxpc3Qgb2Ygc2NyaXB0cyB0aGF0IGhhdmUgYmVlbiBsb2FkZWQuIEl0ZW1zIGFyZSBhZGRlZCB0byB0aGlzIGxpc3QgYXMgPGNvZGU+bnVsbDwvY29kZT4gd2hlbiB0aGV5IGFyZVxuXHRcdCAqIHJlcXVlc3RlZCwgY29udGFpbiB0aGUgbG9hZGVkIGl0ZW0gaWYgaXQgaGFzIGNvbXBsZXRlZCwgYnV0IG5vdCBiZWVuIGRpc3BhdGNoZWQgdG8gdGhlIHVzZXIsIGFuZCA8Y29kZT50cnVlPC90cnVlPlxuXHRcdCAqIG9uY2UgdGhleSBhcmUgY29tcGxldGUgYW5kIGhhdmUgYmVlbiBkaXNwYXRjaGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZGVkU2NyaXB0c1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRlZFNjcmlwdHMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsYXN0IHByb2dyZXNzIGFtb3VudC4gVGhpcyBpcyB1c2VkIHRvIHN1cHByZXNzIGR1cGxpY2F0ZSBwcm9ncmVzcyBldmVudHMuXG5cdFx0ICogQHByb3BlcnR5IF9sYXN0UHJvZ3Jlc3Ncblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHNpbmNlIDAuNi4wXG5cdFx0ICovXG5cdFx0dGhpcy5fbGFzdFByb2dyZXNzID0gTmFOO1xuXG5cdH07XG5cbi8vIHN0YXRpYyBwcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdG8gYXNzdW1lIGEgbG9hZCBoYXMgZmFpbGVkLiBBbiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9lcnJvcjpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBpcyBkaXNwYXRjaGVkIGlmIHRoZSB0aW1lb3V0IGlzIHJlYWNoZWQgYmVmb3JlIGFueSBkYXRhIGlzIHJlY2VpdmVkLlxuXHQgKiBAcHJvcGVydHkgbG9hZFRpbWVvdXRcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQGRlZmF1bHQgODAwMFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKiBAZGVwcmVjYXRlZCBJbiBmYXZvdXIgb2Yge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vTE9BRF9USU1FT1VUX0RFRkFVTFQ6cHJvcGVydHl9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5LlxuXHQgKi9cblx0cy5sb2FkVGltZW91dCA9IDgwMDA7XG5cblx0LyoqXG5cdCAqIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byBhc3N1bWUgYSBsb2FkIGhhcyBmYWlsZWQuXG5cdCAqIEBwcm9wZXJ0eSBMT0FEX1RJTUVPVVRcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQGRlZmF1bHQgMFxuXHQgKiBAZGVwcmVjYXRlZCBpbiBmYXZvciBvZiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRUaW1lb3V0OnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5LlxuXHQgKi9cblx0cy5MT0FEX1RJTUVPVVQgPSAwO1xuXG4vLyBQcmVsb2FkIFR5cGVzXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgQklOQVJZXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGJpbmFyeVxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvQklOQVJZOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLkJJTkFSWSA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkJJTkFSWTtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IENTU1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBjc3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0NTUzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5DU1MgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5DU1M7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBJTUFHRVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBpbWFnZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvQ1NTOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLklNQUdFID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSU1BR0U7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBKQVZBU0NSSVBUXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGphdmFzY3JpcHRcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pBVkFTQ1JJUFQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuSkFWQVNDUklQVCA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpBVkFTQ1JJUFQ7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBKU09OXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGpzb25cblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pTT046cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuSlNPTiA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpTT047XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBKU09OUFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBqc29ucFxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSlNPTlA6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuSlNPTlAgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KU09OUDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IE1BTklGRVNUXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IG1hbmlmZXN0XG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNC4xXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvTUFOSUZFU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuTUFOSUZFU1QgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5NQU5JRkVTVDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IFNPVU5EXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHNvdW5kXG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9KQVZBU0NSSVBUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLlNPVU5EID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU09VTkQ7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBWSURFT1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCB2aWRlb1xuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSkFWQVNDUklQVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5WSURFTyA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlZJREVPO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgU1ZHXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHN2Z1xuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvU1ZHOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLlNWRyA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNWRztcblxuXHQvKipcblx0ICogQHByb3BlcnR5IFRFWFRcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgdGV4dFxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvVEVYVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5URVhUID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVEVYVDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IFhNTFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCB4bWxcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1hNTDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5YTUwgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5YTUw7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBQT1NUXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvUE9TVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5QT1NUID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuUE9TVDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IEdFVFxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0dFVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5HRVQgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5HRVQ7XG5cbi8vIGV2ZW50c1xuXHQvKipcblx0ICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGFuIGluZGl2aWR1YWwgZmlsZSBoYXMgbG9hZGVkLCBhbmQgYmVlbiBwcm9jZXNzZWQuXG5cdCAqIEBldmVudCBmaWxlbG9hZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIFRoZSBmaWxlIGl0ZW0gd2hpY2ggd2FzIHNwZWNpZmllZCBpbiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG9yIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX0gY2FsbC4gSWYgb25seSBhIHN0cmluZyBwYXRoIG9yIHRhZyB3YXMgc3BlY2lmaWVkLCB0aGVcblx0ICogb2JqZWN0IHdpbGwgY29udGFpbiB0aGF0IHZhbHVlIGFzIGEgYHNyY2AgcHJvcGVydHkuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHQgVGhlIEhUTUwgdGFnIG9yIHBhcnNlZCByZXN1bHQgb2YgdGhlIGxvYWRlZCBpdGVtLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcmF3UmVzdWx0IFRoZSB1bnByb2Nlc3NlZCByZXN1bHQsIHVzdWFsbHkgdGhlIHJhdyB0ZXh0IG9yIGJpbmFyeSBkYXRhIGJlZm9yZSBpdCBpcyBjb252ZXJ0ZWRcblx0ICogdG8gYSB1c2FibGUgb2JqZWN0LlxuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoaXMge3sjY3Jvc3NMaW5rIFwiUHJvZ3Jlc3NFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIHdoZW4gYW4gYW4gaW5kaXZpZHVhbCBmaWxlJ3MgcHJvZ3Jlc3MgY2hhbmdlcy5cblx0ICogQGV2ZW50IGZpbGVwcm9ncmVzc1xuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhbiBpbmRpdmlkdWFsIGZpbGUgc3RhcnRzIHRvIGxvYWQuXG5cdCAqIEBldmVudCBmaWxlc3RhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIFRoZSBmaWxlIGl0ZW0gd2hpY2ggd2FzIHNwZWNpZmllZCBpbiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG9yIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX0gY2FsbC4gSWYgb25seSBhIHN0cmluZyBwYXRoIG9yIHRhZyB3YXMgc3BlY2lmaWVkLCB0aGVcblx0ICogb2JqZWN0IHdpbGwgY29udGFpbiB0aGF0IHZhbHVlIGFzIGEgcHJvcGVydHkuXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBBbHRob3VnaCBpdCBleHRlbmRzIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LCB0aGUgYGluaXRpYWxpemVgIGV2ZW50IGlzIG5ldmVyIGZpcmVkIGZyb21cblx0ICogYSBMb2FkUXVldWUgaW5zdGFuY2UuXG5cdCAqIEBldmVudCBpbml0aWFsaXplXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXG4vLyBwdWJsaWMgbWV0aG9kc1xuXHQvKipcblx0ICogUmVnaXN0ZXIgYSBjdXN0b20gbG9hZGVycyBjbGFzcy4gTmV3IGxvYWRlcnMgYXJlIGdpdmVuIHByZWNlZGVuY2Ugb3ZlciBsb2FkZXJzIGFkZGVkIGVhcmxpZXIgYW5kIGRlZmF1bHQgbG9hZGVycy5cblx0ICogSXQgaXMgcmVjb21tZW5kZWQgdGhhdCBsb2FkZXJzIGV4dGVuZCB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlclwifX17ey9jcm9zc0xpbmt9fS4gTG9hZGVycyBjYW4gb25seSBiZSBhZGRlZFxuXHQgKiBvbmNlLCBhbmQgd2lsbCBiZSBwcmVwZW5kZWQgdG8gdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGxvYWRlcnMuXG5cdCAqIEBtZXRob2QgcmVnaXN0ZXJMb2FkZXJcblx0ICogQHBhcmFtIHtGdW5jdGlvbnxBYnN0cmFjdExvYWRlcn0gbG9hZGVyIFRoZSBBYnN0cmFjdExvYWRlciBjbGFzcyB0byBhZGQuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5yZWdpc3RlckxvYWRlciA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHRpZiAoIWxvYWRlciB8fCAhbG9hZGVyLmNhbkxvYWRJdGVtKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJsb2FkZXIgaXMgb2YgYW4gaW5jb3JyZWN0IHR5cGUuXCIpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5fYXZhaWxhYmxlTG9hZGVycy5pbmRleE9mKGxvYWRlcikgIT0gLTEpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcImxvYWRlciBhbHJlYWR5IGV4aXN0cy5cIik7IC8vTE06IE1heWJlIGp1c3Qgc2lsZW50bHkgZmFpbCBoZXJlXG5cdFx0fVxuXG5cdFx0dGhpcy5fYXZhaWxhYmxlTG9hZGVycy51bnNoaWZ0KGxvYWRlcik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhIGN1c3RvbSBsb2FkZXIgYWRkZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwicmVnaXN0ZXJMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uIE9ubHkgY3VzdG9tIGxvYWRlcnMgY2FuIGJlXG5cdCAqIHVucmVnaXN0ZXJlZCwgdGhlIGRlZmF1bHQgbG9hZGVycyB3aWxsIGFsd2F5cyBiZSBhdmFpbGFibGUuXG5cdCAqIEBtZXRob2QgdW5yZWdpc3RlckxvYWRlclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufEFic3RyYWN0TG9hZGVyfSBsb2FkZXIgVGhlIEFic3RyYWN0TG9hZGVyIGNsYXNzIHRvIHJlbW92ZVxuXHQgKi9cblx0cC51bnJlZ2lzdGVyTG9hZGVyID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdHZhciBpZHggPSB0aGlzLl9hdmFpbGFibGVMb2FkZXJzLmluZGV4T2YobG9hZGVyKTtcblx0XHRpZiAoaWR4ICE9IC0xICYmIGlkeCA8IHRoaXMuX2RlZmF1bHRMb2FkZXJMZW5ndGggLSAxKSB7XG5cdFx0XHR0aGlzLl9hdmFpbGFibGVMb2FkZXJzLnNwbGljZShpZHgsIDEpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBzZXRVc2VYSFJcblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBUaGUgbmV3IHVzZVhIUiB2YWx1ZSB0byBzZXQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRoZSBuZXcgdXNlWEhSIHZhbHVlLiBJZiBYSFIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYnJvd3NlciwgdGhpcyB3aWxsIHJldHVybiBmYWxzZSwgZXZlbiBpZlxuXHQgKiB0aGUgcHJvdmlkZWQgdmFsdWUgYXJndW1lbnQgd2FzIHRydWUuXG5cdCAqIEBzaW5jZSAwLjMuMFxuXHQgKiBAZGVwcmVjYXRlZCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9wcmVmZXJYSFI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHksIG9yIHRoZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc2V0VXNlWEhSXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCBpbnN0ZWFkLlxuXHQgKi9cblx0cC5zZXRVc2VYSFIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRQcmVmZXJYSFIodmFsdWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGFuZ2UgdGhlIHt7I2Nyb3NzTGluayBcInByZWZlclhIUjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSB2YWx1ZS4gTm90ZSB0aGF0IGlmIHRoaXMgaXMgc2V0IHRvIGB0cnVlYCwgaXQgbWF5XG5cdCAqIGZhaWwsIG9yIGJlIGlnbm9yZWQgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyJ3MgY2FwYWJpbGl0aWVzIGFuZCB0aGUgbG9hZCB0eXBlLlxuXHQgKiBAbWV0aG9kIHNldFByZWZlclhIUlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBUaGUgdmFsdWUgb2Yge3sjY3Jvc3NMaW5rIFwicHJlZmVyWEhSXCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgd2FzIHN1Y2Nlc3NmdWxseSBzZXQuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5zZXRQcmVmZXJYSFIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHQvLyBEZXRlcm1pbmUgaWYgd2UgY2FuIHVzZSBYSFIuIFhIUiBkZWZhdWx0cyB0byBUUlVFLCBidXQgdGhlIGJyb3dzZXIgbWF5IG5vdCBzdXBwb3J0IGl0LlxuXHRcdC8vVE9ETzogU2hvdWxkIHdlIGJlIGNoZWNraW5nIGZvciB0aGUgb3RoZXIgWEhSIHR5cGVzPyBNaWdodCBoYXZlIHRvIGRvIGEgdHJ5L2NhdGNoIG9uIHRoZSBkaWZmZXJlbnQgdHlwZXMgc2ltaWxhciB0byBjcmVhdGVYSFIuXG5cdFx0dGhpcy5wcmVmZXJYSFIgPSAodmFsdWUgIT0gZmFsc2UgJiYgd2luZG93LlhNTEh0dHBSZXF1ZXN0ICE9IG51bGwpO1xuXHRcdHJldHVybiB0aGlzLnByZWZlclhIUjtcblx0fTtcblxuXHQvKipcblx0ICogU3RvcHMgYWxsIHF1ZXVlZCBhbmQgbG9hZGluZyBpdGVtcywgYW5kIGNsZWFycyB0aGUgcXVldWUuIFRoaXMgYWxzbyByZW1vdmVzIGFsbCBpbnRlcm5hbCByZWZlcmVuY2VzIHRvIGxvYWRlZFxuXHQgKiBjb250ZW50LCBhbmQgYWxsb3dzIHRoZSBxdWV1ZSB0byBiZSB1c2VkIGFnYWluLlxuXHQgKiBAbWV0aG9kIHJlbW92ZUFsbFxuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cdHAucmVtb3ZlQWxsID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMucmVtb3ZlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3BzIGFuIGl0ZW0gZnJvbSBiZWluZyBsb2FkZWQsIGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIHF1ZXVlLiBJZiBub3RoaW5nIGlzIHBhc3NlZCwgYWxsIGl0ZW1zIGFyZSByZW1vdmVkLlxuXHQgKiBUaGlzIGFsc28gcmVtb3ZlcyBpbnRlcm5hbCByZWZlcmVuY2VzIHRvIGxvYWRlZCBpdGVtKHMpLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgcXVldWUubG9hZE1hbmlmZXN0KFtcblx0ICogICAgICAgICAge3NyYzpcInRlc3QucG5nXCIsIGlkOlwicG5nXCJ9LFxuXHQgKiAgICAgICAgICB7c3JjOlwidGVzdC5qcGdcIiwgaWQ6XCJqcGdcIn0sXG5cdCAqICAgICAgICAgIHtzcmM6XCJ0ZXN0Lm1wM1wiLCBpZDpcIm1wM1wifVxuXHQgKiAgICAgIF0pO1xuXHQgKiAgICAgIHF1ZXVlLnJlbW92ZShcInBuZ1wiKTsgLy8gU2luZ2xlIGl0ZW0gYnkgSURcblx0ICogICAgICBxdWV1ZS5yZW1vdmUoXCJwbmdcIiwgXCJ0ZXN0LmpwZ1wiKTsgLy8gSXRlbXMgYXMgYXJndW1lbnRzLiBNaXhlZCBpZCBhbmQgc3JjLlxuXHQgKiAgICAgIHF1ZXVlLnJlbW92ZShbXCJ0ZXN0LnBuZ1wiLCBcImpwZ1wiXSk7IC8vIEl0ZW1zIGluIGFuIEFycmF5LiBNaXhlZCBpZCBhbmQgc3JjLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlbW92ZVxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IEFycmF5fSBpZHNPclVybHMqIFRoZSBpZCBvciBpZHMgdG8gcmVtb3ZlIGZyb20gdGhpcyBxdWV1ZS4gWW91IGNhbiBwYXNzIGFuIGl0ZW0sIGFuIGFycmF5IG9mXG5cdCAqIGl0ZW1zLCBvciBtdWx0aXBsZSBpdGVtcyBhcyBhcmd1bWVudHMuXG5cdCAqIEBzaW5jZSAwLjMuMFxuXHQgKi9cblx0cC5yZW1vdmUgPSBmdW5jdGlvbiAoaWRzT3JVcmxzKSB7XG5cdFx0dmFyIGFyZ3MgPSBudWxsO1xuXG5cdFx0aWYgKGlkc09yVXJscyAmJiAhQXJyYXkuaXNBcnJheShpZHNPclVybHMpKSB7XG5cdFx0XHRhcmdzID0gW2lkc09yVXJsc107XG5cdFx0fSBlbHNlIGlmIChpZHNPclVybHMpIHtcblx0XHRcdGFyZ3MgPSBpZHNPclVybHM7XG5cdFx0fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBpdGVtc1dlcmVSZW1vdmVkID0gZmFsc2U7XG5cblx0XHQvLyBEZXN0cm95IGV2ZXJ5dGhpbmdcblx0XHRpZiAoIWFyZ3MpIHtcblx0XHRcdHRoaXMuY2xvc2UoKTtcblx0XHRcdGZvciAodmFyIG4gaW4gdGhpcy5fbG9hZEl0ZW1zQnlJZCkge1xuXHRcdFx0XHR0aGlzLl9kaXNwb3NlSXRlbSh0aGlzLl9sb2FkSXRlbXNCeUlkW25dKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaW5pdCh0aGlzLnByZWZlclhIUiwgdGhpcy5fYmFzZVBhdGgpO1xuXG5cdFx0XHQvLyBSZW1vdmUgc3BlY2lmaWMgaXRlbXNcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2hpbGUgKGFyZ3MubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gYXJncy5wb3AoKTtcblx0XHRcdFx0dmFyIHIgPSB0aGlzLmdldFJlc3VsdChpdGVtKTtcblxuXHRcdFx0XHQvL1JlbW92ZSBmcm9tIHRoZSBtYWluIGxvYWQgUXVldWVcblx0XHRcdFx0Zm9yIChpID0gdGhpcy5fbG9hZFF1ZXVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0bG9hZEl0ZW0gPSB0aGlzLl9sb2FkUXVldWVbaV0uZ2V0SXRlbSgpO1xuXHRcdFx0XHRcdGlmIChsb2FkSXRlbS5pZCA9PSBpdGVtIHx8IGxvYWRJdGVtLnNyYyA9PSBpdGVtKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9sb2FkUXVldWUuc3BsaWNlKGksIDEpWzBdLmNhbmNlbCgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9SZW1vdmUgZnJvbSB0aGUgYmFja3VwIHF1ZXVlXG5cdFx0XHRcdGZvciAoaSA9IHRoaXMuX2xvYWRRdWV1ZUJhY2t1cC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdGxvYWRJdGVtID0gdGhpcy5fbG9hZFF1ZXVlQmFja3VwW2ldLmdldEl0ZW0oKTtcblx0XHRcdFx0XHRpZiAobG9hZEl0ZW0uaWQgPT0gaXRlbSB8fCBsb2FkSXRlbS5zcmMgPT0gaXRlbSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fbG9hZFF1ZXVlQmFja3VwLnNwbGljZShpLCAxKVswXS5jYW5jZWwoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChyKSB7XG5cdFx0XHRcdFx0dGhpcy5fZGlzcG9zZUl0ZW0odGhpcy5nZXRJdGVtKGl0ZW0pKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gdGhpcy5fY3VycmVudExvYWRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0XHR2YXIgbG9hZEl0ZW0gPSB0aGlzLl9jdXJyZW50TG9hZHNbaV0uZ2V0SXRlbSgpO1xuXHRcdFx0XHRcdFx0aWYgKGxvYWRJdGVtLmlkID09IGl0ZW0gfHwgbG9hZEl0ZW0uc3JjID09IGl0ZW0pIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fY3VycmVudExvYWRzLnNwbGljZShpLCAxKVswXS5jYW5jZWwoKTtcblx0XHRcdFx0XHRcdFx0aXRlbXNXZXJlUmVtb3ZlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBjYWxsZWQgZHVyaW5nIGEgbG9hZCwgdHJ5IHRvIGxvYWQgdGhlIG5leHQgaXRlbS5cblx0XHRcdGlmIChpdGVtc1dlcmVSZW1vdmVkKSB7XG5cdFx0XHRcdHRoaXMuX2xvYWROZXh0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdG9wcyBhbGwgb3BlbiBsb2FkcywgZGVzdHJveXMgYW55IGxvYWRlZCBpdGVtcywgYW5kIHJlc2V0cyB0aGUgcXVldWUsIHNvIGFsbCBpdGVtcyBjYW5cblx0ICogYmUgcmVsb2FkZWQgYWdhaW4gYnkgY2FsbGluZyB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9sb2FkXCJ9fXt7L2Nyb3NzTGlua319LiBJdGVtcyBhcmUgbm90IHJlbW92ZWQgZnJvbSB0aGVcblx0ICogcXVldWUuIFRvIHJlbW92ZSBpdGVtcyB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9yZW1vdmVcIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3JlbW92ZUFsbFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG5cdCAqIEBtZXRob2QgcmVzZXRcblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXHRwLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuY2xvc2UoKTtcblx0XHRmb3IgKHZhciBuIGluIHRoaXMuX2xvYWRJdGVtc0J5SWQpIHtcblx0XHRcdHRoaXMuX2Rpc3Bvc2VJdGVtKHRoaXMuX2xvYWRJdGVtc0J5SWRbbl0pO1xuXHRcdH1cblxuXHRcdC8vUmVzZXQgdGhlIHF1ZXVlIHRvIGl0cyBzdGFydCBzdGF0ZVxuXHRcdHZhciBhID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9sb2FkUXVldWVCYWNrdXAubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRhLnB1c2godGhpcy5fbG9hZFF1ZXVlQmFja3VwW2ldLmdldEl0ZW0oKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5sb2FkTWFuaWZlc3QoYSwgZmFsc2UpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZWdpc3RlciBhIHBsdWdpbi4gUGx1Z2lucyBjYW4gbWFwIHRvIGxvYWQgdHlwZXMgKHNvdW5kLCBpbWFnZSwgZXRjKSwgb3Igc3BlY2lmaWMgZXh0ZW5zaW9ucyAocG5nLCBtcDMsIGV0YykuXG5cdCAqIEN1cnJlbnRseSwgb25seSBvbmUgcGx1Z2luIGNhbiBleGlzdCBwZXIgdHlwZS9leHRlbnNpb24uXG5cdCAqXG5cdCAqIFdoZW4gYSBwbHVnaW4gaXMgaW5zdGFsbGVkLCBhIDxjb2RlPmdldFByZWxvYWRIYW5kbGVycygpPC9jb2RlPiBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgb24gaXQuIEZvciBtb3JlIGluZm9ybWF0aW9uXG5cdCAqIG9uIHRoaXMgbWV0aG9kLCBjaGVjayBvdXQgdGhlIHt7I2Nyb3NzTGluayBcIlNhbXBsZVBsdWdpbi9nZXRQcmVsb2FkSGFuZGxlcnNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGluIHRoZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTYW1wbGVQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MuXG5cdCAqXG5cdCAqIEJlZm9yZSBhIGZpbGUgaXMgbG9hZGVkLCBhIG1hdGNoaW5nIHBsdWdpbiBoYXMgYW4gb3Bwb3J0dW5pdHkgdG8gbW9kaWZ5IHRoZSBsb2FkLiBJZiBhIGBjYWxsYmFja2AgaXMgcmV0dXJuZWRcblx0ICogZnJvbSB0aGUge3sjY3Jvc3NMaW5rIFwiU2FtcGxlUGx1Z2luL2dldFByZWxvYWRIYW5kbGVyc1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2QsIGl0IHdpbGwgYmUgaW52b2tlZCBmaXJzdCwgYW5kIGl0c1xuXHQgKiByZXN1bHQgbWF5IGNhbmNlbCBvciBtb2RpZnkgdGhlIGl0ZW0uIFRoZSBjYWxsYmFjayBtZXRob2QgY2FuIGFsc28gcmV0dXJuIGEgYGNvbXBsZXRlSGFuZGxlcmAgdG8gYmUgZmlyZWQgd2hlblxuXHQgKiB0aGUgZmlsZSBpcyBsb2FkZWQsIG9yIGEgYHRhZ2Agb2JqZWN0LCB3aGljaCB3aWxsIG1hbmFnZSB0aGUgYWN0dWFsIGRvd25sb2FkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZVxuXHQgKiBtZXRob2RzLCBjaGVjayBvdXQgdGhlIHt7I2Nyb3NzTGluayBcIlNhbXBsZVBsdWdpbi9wcmVsb2FkSGFuZGxlclwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiU2FtcGxlUGx1Z2luL2ZpbGVMb2FkSGFuZGxlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2RzIG9uIHRoZSB7eyNjcm9zc0xpbmsgXCJTYW1wbGVQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5zdGFsbFBsdWdpblxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwbHVnaW4gVGhlIHBsdWdpbiBjbGFzcyB0byBpbnN0YWxsLlxuXHQgKi9cblx0cC5pbnN0YWxsUGx1Z2luID0gZnVuY3Rpb24gKHBsdWdpbikge1xuXHRcdGlmIChwbHVnaW4gPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChwbHVnaW4uZ2V0UHJlbG9hZEhhbmRsZXJzICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3BsdWdpbnMucHVzaChwbHVnaW4pO1xuXHRcdFx0dmFyIG1hcCA9IHBsdWdpbi5nZXRQcmVsb2FkSGFuZGxlcnMoKTtcblx0XHRcdG1hcC5zY29wZSA9IHBsdWdpbjtcblxuXHRcdFx0aWYgKG1hcC50eXBlcyAhPSBudWxsKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbWFwLnR5cGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHRoaXMuX3R5cGVDYWxsYmFja3NbbWFwLnR5cGVzW2ldXSA9IG1hcDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWFwLmV4dGVuc2lvbnMgIT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKGkgPSAwLCBsID0gbWFwLmV4dGVuc2lvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5fZXh0ZW5zaW9uQ2FsbGJhY2tzW21hcC5leHRlbnNpb25zW2ldXSA9IG1hcDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogU2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiBjb25jdXJyZW50IGNvbm5lY3Rpb25zLiBOb3RlIHRoYXQgYnJvd3NlcnMgYW5kIHNlcnZlcnMgbWF5IGhhdmUgYSBidWlsdC1pbiBtYXhpbXVtXG5cdCAqIG51bWJlciBvZiBvcGVuIGNvbm5lY3Rpb25zLCBzbyBhbnkgYWRkaXRpb25hbCBjb25uZWN0aW9ucyBtYXkgcmVtYWluIGluIGEgcGVuZGluZyBzdGF0ZSB1bnRpbCB0aGUgYnJvd3NlclxuXHQgKiBvcGVucyB0aGUgY29ubmVjdGlvbi4gV2hlbiBsb2FkaW5nIHNjcmlwdHMgdXNpbmcgdGFncywgYW5kIHdoZW4ge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL21haW50YWluU2NyaXB0T3JkZXI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaXMgYHRydWVgLCBvbmx5IG9uZSBzY3JpcHQgaXMgbG9hZGVkIGF0IGEgdGltZSBkdWUgdG8gYnJvd3NlciBsaW1pdGF0aW9ucy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBxdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUoKTtcblx0ICogICAgICBxdWV1ZS5zZXRNYXhDb25uZWN0aW9ucygxMCk7IC8vIEFsbG93IDEwIGNvbmN1cnJlbnQgbG9hZHNcblx0ICpcblx0ICogQG1ldGhvZCBzZXRNYXhDb25uZWN0aW9uc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIG51bWJlciBvZiBjb25jdXJyZW50IGxvYWRzIHRvIGFsbG93LiBCeSBkZWZhdWx0LCBvbmx5IGEgc2luZ2xlIGNvbm5lY3Rpb24gcGVyIExvYWRRdWV1ZVxuXHQgKiBpcyBvcGVuIGF0IGFueSB0aW1lLlxuXHQgKi9cblx0cC5zZXRNYXhDb25uZWN0aW9ucyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHRoaXMuX21heENvbm5lY3Rpb25zID0gdmFsdWU7XG5cdFx0aWYgKCF0aGlzLl9wYXVzZWQgJiYgdGhpcy5fbG9hZFF1ZXVlLmxlbmd0aCA+IDApIHtcblx0XHRcdHRoaXMuX2xvYWROZXh0KCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBMb2FkIGEgc2luZ2xlIGZpbGUuIFRvIGFkZCBtdWx0aXBsZSBmaWxlcyBhdCBvbmNlLCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLlxuXHQgKlxuXHQgKiBGaWxlcyBhcmUgYWx3YXlzIGFwcGVuZGVkIHRvIHRoZSBjdXJyZW50IHF1ZXVlLCBzbyB0aGlzIG1ldGhvZCBjYW4gYmUgdXNlZCBtdWx0aXBsZSB0aW1lcyB0byBhZGQgZmlsZXMuXG5cdCAqIFRvIGNsZWFyIHRoZSBxdWV1ZSBmaXJzdCwgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9jbG9zZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG5cdCAqIEBtZXRob2QgbG9hZEZpbGVcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R8U3RyaW5nfSBmaWxlIFRoZSBmaWxlIG9iamVjdCBvciBwYXRoIHRvIGxvYWQuIEEgZmlsZSBjYW4gYmUgZWl0aGVyXG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5BIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlPC9saT5cblx0ICogICAgIDxsaT5BbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGRlZmluZWQgYnkge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX08L2xpPlxuXHQgKiAgICAgPGxpPk9SIEEgc3RyaW5nIHBhdGggdG8gYSByZXNvdXJjZS4gTm90ZSB0aGF0IHRoaXMga2luZCBvZiBsb2FkIGl0ZW0gd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiAgICAgaW4gdGhlIGJhY2tncm91bmQuPC9saT5cblx0ICogPC91bD5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbbG9hZE5vdz10cnVlXSBLaWNrIG9mZiBhbiBpbW1lZGlhdGUgbG9hZCAodHJ1ZSkgb3Igd2FpdCBmb3IgYSBsb2FkIGNhbGwgKGZhbHNlKS4gVGhlIGRlZmF1bHRcblx0ICogdmFsdWUgaXMgdHJ1ZS4gSWYgdGhlIHF1ZXVlIGlzIHBhdXNlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc2V0UGF1c2VkXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQgdGhlIHZhbHVlIGlzXG5cdCAqIGB0cnVlYCwgdGhlIHF1ZXVlIHdpbGwgcmVzdW1lIGF1dG9tYXRpY2FsbHkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbYmFzZVBhdGhdIEEgYmFzZSBwYXRoIHRoYXQgd2lsbCBiZSBwcmVwZW5kZWQgdG8gZWFjaCBmaWxlLiBUaGUgYmFzZVBhdGggYXJndW1lbnQgb3ZlcnJpZGVzIHRoZVxuXHQgKiBwYXRoIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IuIE5vdGUgdGhhdCBpZiB5b3UgbG9hZCBhIG1hbmlmZXN0IHVzaW5nIGEgZmlsZSBvZiB0eXBlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL01BTklGRVNUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBpdHMgZmlsZXMgd2lsbCA8c3Ryb25nPk5PVDwvc3Ryb25nPiB1c2UgdGhlIGJhc2VQYXRoIHBhcmFtZXRlci4gPHN0cm9uZz5UaGUgYmFzZVBhdGggcGFyYW1ldGVyIGlzIGRlcHJlY2F0ZWQuPC9zdHJvbmc+XG5cdCAqIFRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLiBQbGVhc2UgZWl0aGVyIHVzZSB0aGUgYGJhc2VQYXRoYCBwYXJhbWV0ZXIgaW4gdGhlIExvYWRRdWV1ZVxuXHQgKiBjb25zdHJ1Y3Rvciwgb3IgYSBgcGF0aGAgcHJvcGVydHkgaW4gYSBtYW5pZmVzdCBkZWZpbml0aW9uLlxuXHQgKi9cblx0cC5sb2FkRmlsZSA9IGZ1bmN0aW9uIChmaWxlLCBsb2FkTm93LCBiYXNlUGF0aCkge1xuXHRcdGlmIChmaWxlID09IG51bGwpIHtcblx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9OT19GSUxFXCIpO1xuXHRcdFx0dGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5fYWRkSXRlbShmaWxlLCBudWxsLCBiYXNlUGF0aCk7XG5cblx0XHRpZiAobG9hZE5vdyAhPT0gZmFsc2UpIHtcblx0XHRcdHRoaXMuc2V0UGF1c2VkKGZhbHNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZXRQYXVzZWQodHJ1ZSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBMb2FkIGFuIGFycmF5IG9mIGZpbGVzLiBUbyBsb2FkIGEgc2luZ2xlIGZpbGUsIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cblx0ICogVGhlIGZpbGVzIGluIHRoZSBtYW5pZmVzdCBhcmUgcmVxdWVzdGVkIGluIHRoZSBzYW1lIG9yZGVyLCBidXQgbWF5IGNvbXBsZXRlIGluIGEgZGlmZmVyZW50IG9yZGVyIGlmIHRoZSBtYXhcblx0ICogY29ubmVjdGlvbnMgYXJlIHNldCBhYm92ZSAxIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRNYXhDb25uZWN0aW9uc1wifX17ey9jcm9zc0xpbmt9fS4gU2NyaXB0cyB3aWxsIGxvYWRcblx0ICogaW4gdGhlIHJpZ2h0IG9yZGVyIGFzIGxvbmcgYXMge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL21haW50YWluU2NyaXB0T3JkZXJcIn19e3svY3Jvc3NMaW5rfX0gaXMgdHJ1ZSAod2hpY2ggaXNcblx0ICogZGVmYXVsdCkuXG5cdCAqXG5cdCAqIEZpbGVzIGFyZSBhbHdheXMgYXBwZW5kZWQgdG8gdGhlIGN1cnJlbnQgcXVldWUsIHNvIHRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIG11bHRpcGxlIHRpbWVzIHRvIGFkZCBmaWxlcy5cblx0ICogVG8gY2xlYXIgdGhlIHF1ZXVlIGZpcnN0LCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2Nsb3NlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cblx0ICogQG1ldGhvZCBsb2FkTWFuaWZlc3Rcblx0ICogQHBhcmFtIHtBcnJheXxTdHJpbmd8T2JqZWN0fSBtYW5pZmVzdCBBbiBsaXN0IG9mIGZpbGVzIHRvIGxvYWQuIFRoZSBsb2FkTWFuaWZlc3QgY2FsbCBzdXBwb3J0cyBmb3VyIHR5cGVzIG9mXG5cdCAqIG1hbmlmZXN0czpcblx0ICogPG9sPlxuXHQgKiAgICAgPGxpPkEgc3RyaW5nIHBhdGgsIHdoaWNoIHBvaW50cyB0byBhIG1hbmlmZXN0IGZpbGUsIHdoaWNoIGlzIGEgSlNPTiBmaWxlIHRoYXQgY29udGFpbnMgYSBcIm1hbmlmZXN0XCIgcHJvcGVydHksXG5cdCAqICAgICB3aGljaCBkZWZpbmVzIHRoZSBsaXN0IG9mIGZpbGVzIHRvIGxvYWQsIGFuZCBjYW4gb3B0aW9uYWxseSBjb250YWluIGEgXCJwYXRoXCIgcHJvcGVydHksIHdoaWNoIHdpbGwgYmVcblx0ICogICAgIHByZXBlbmRlZCB0byBlYWNoIGZpbGUgaW4gdGhlIGxpc3QuPC9saT5cblx0ICogICAgIDxsaT5BbiBvYmplY3Qgd2hpY2ggZGVmaW5lcyBhIFwic3JjXCIsIHdoaWNoIGlzIGEgSlNPTiBvciBKU09OUCBmaWxlLiBBIFwiY2FsbGJhY2tcIiBjYW4gYmUgZGVmaW5lZCBmb3IgSlNPTlBcblx0ICogICAgIGZpbGUuIFRoZSBKU09OL0pTT05QIGZpbGUgc2hvdWxkIGNvbnRhaW4gYSBcIm1hbmlmZXN0XCIgcHJvcGVydHksIHdoaWNoIGRlZmluZXMgdGhlIGxpc3Qgb2YgZmlsZXMgdG8gbG9hZCxcblx0ICogICAgIGFuZCBjYW4gb3B0aW9uYWxseSBjb250YWluIGEgXCJwYXRoXCIgcHJvcGVydHksIHdoaWNoIHdpbGwgYmUgcHJlcGVuZGVkIHRvIGVhY2ggZmlsZSBpbiB0aGUgbGlzdC48L2xpPlxuXHQgKiAgICAgPGxpPkFuIG9iamVjdCB3aGljaCBjb250YWlucyBhIFwibWFuaWZlc3RcIiBwcm9wZXJ0eSwgd2hpY2ggZGVmaW5lcyB0aGUgbGlzdCBvZiBmaWxlcyB0byBsb2FkLCBhbmQgY2FuXG5cdCAqICAgICBvcHRpb25hbGx5IGNvbnRhaW4gYSBcInBhdGhcIiBwcm9wZXJ0eSwgd2hpY2ggd2lsbCBiZSBwcmVwZW5kZWQgdG8gZWFjaCBmaWxlIGluIHRoZSBsaXN0LjwvbGk+XG5cdCAqICAgICA8bGk+QW4gQXJyYXkgb2YgZmlsZXMgdG8gbG9hZC48L2xpPlxuXHQgKiA8L29sPlxuXHQgKlxuXHQgKiBFYWNoIFwiZmlsZVwiIGluIGEgbWFuaWZlc3QgY2FuIGJlIGVpdGhlcjpcblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPkEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2U8L2xpPlxuXHQgKiAgICAgPGxpPkFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgZGVmaW5lZCBieSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fTwvbGk+XG5cdCAqICAgICA8bGk+T1IgQSBzdHJpbmcgcGF0aCB0byBhIHJlc291cmNlLiBOb3RlIHRoYXQgdGhpcyBraW5kIG9mIGxvYWQgaXRlbSB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqICAgICBpbiB0aGUgYmFja2dyb3VuZC48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtsb2FkTm93PXRydWVdIEtpY2sgb2ZmIGFuIGltbWVkaWF0ZSBsb2FkICh0cnVlKSBvciB3YWl0IGZvciBhIGxvYWQgY2FsbCAoZmFsc2UpLiBUaGUgZGVmYXVsdFxuXHQgKiB2YWx1ZSBpcyB0cnVlLiBJZiB0aGUgcXVldWUgaXMgcGF1c2VkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRQYXVzZWRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHRoaXMgdmFsdWUgaXNcblx0ICogYHRydWVgLCB0aGUgcXVldWUgd2lsbCByZXN1bWUgYXV0b21hdGljYWxseS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtiYXNlUGF0aF0gQSBiYXNlIHBhdGggdGhhdCB3aWxsIGJlIHByZXBlbmRlZCB0byBlYWNoIGZpbGUuIFRoZSBiYXNlUGF0aCBhcmd1bWVudCBvdmVycmlkZXMgdGhlXG5cdCAqIHBhdGggc3BlY2lmaWVkIGluIHRoZSBjb25zdHJ1Y3Rvci4gTm90ZSB0aGF0IGlmIHlvdSBsb2FkIGEgbWFuaWZlc3QgdXNpbmcgYSBmaWxlIG9mIHR5cGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL01BTklGRVNUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBpdHMgZmlsZXMgd2lsbCA8c3Ryb25nPk5PVDwvc3Ryb25nPiB1c2UgdGhlIGJhc2VQYXRoIHBhcmFtZXRlci4gPHN0cm9uZz5UaGUgYmFzZVBhdGggcGFyYW1ldGVyIGlzIGRlcHJlY2F0ZWQuPC9zdHJvbmc+XG5cdCAqIFRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLiBQbGVhc2UgZWl0aGVyIHVzZSB0aGUgYGJhc2VQYXRoYCBwYXJhbWV0ZXIgaW4gdGhlIExvYWRRdWV1ZVxuXHQgKiBjb25zdHJ1Y3Rvciwgb3IgYSBgcGF0aGAgcHJvcGVydHkgaW4gYSBtYW5pZmVzdCBkZWZpbml0aW9uLlxuXHQgKi9cblx0cC5sb2FkTWFuaWZlc3QgPSBmdW5jdGlvbiAobWFuaWZlc3QsIGxvYWROb3csIGJhc2VQYXRoKSB7XG5cdFx0dmFyIGZpbGVMaXN0ID0gbnVsbDtcblx0XHR2YXIgcGF0aCA9IG51bGw7XG5cblx0XHQvLyBBcnJheS1iYXNlZCBsaXN0IG9mIGl0ZW1zXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkobWFuaWZlc3QpKSB7XG5cdFx0XHRpZiAobWFuaWZlc3QubGVuZ3RoID09IDApIHtcblx0XHRcdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJQUkVMT0FEX01BTklGRVNUX0VNUFRZXCIpO1xuXHRcdFx0XHR0aGlzLl9zZW5kRXJyb3IoZXZlbnQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRmaWxlTGlzdCA9IG1hbmlmZXN0O1xuXG5cdFx0XHQvLyBTdHJpbmctYmFzZWQuIE9ubHkgZmlsZSBtYW5pZmVzdHMgY2FuIGJlIHNwZWNpZmllZCB0aGlzIHdheS4gQW55IG90aGVyIHR5cGVzIHdpbGwgY2F1c2UgYW4gZXJyb3Igd2hlbiBsb2FkZWQuXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YobWFuaWZlc3QpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRmaWxlTGlzdCA9IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHNyYzogbWFuaWZlc3QsXG5cdFx0XHRcdFx0dHlwZTogcy5NQU5JRkVTVFxuXHRcdFx0XHR9XG5cdFx0XHRdO1xuXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YobWFuaWZlc3QpID09IFwib2JqZWN0XCIpIHtcblxuXHRcdFx0Ly8gQW4gb2JqZWN0IHRoYXQgZGVmaW5lcyBhIG1hbmlmZXN0IHBhdGhcblx0XHRcdGlmIChtYW5pZmVzdC5zcmMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAobWFuaWZlc3QudHlwZSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0bWFuaWZlc3QudHlwZSA9IHMuTUFOSUZFU1Q7XG5cdFx0XHRcdH0gZWxzZSBpZiAobWFuaWZlc3QudHlwZSAhPSBzLk1BTklGRVNUKSB7XG5cdFx0XHRcdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJQUkVMT0FEX01BTklGRVNUX1RZUEVcIik7XG5cdFx0XHRcdFx0dGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmaWxlTGlzdCA9IFttYW5pZmVzdF07XG5cblx0XHRcdFx0Ly8gQW4gb2JqZWN0IHRoYXQgZGVmaW5lcyBhIG1hbmlmZXN0XG5cdFx0XHR9IGVsc2UgaWYgKG1hbmlmZXN0Lm1hbmlmZXN0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZmlsZUxpc3QgPSBtYW5pZmVzdC5tYW5pZmVzdDtcblx0XHRcdFx0cGF0aCA9IG1hbmlmZXN0LnBhdGg7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVuc3VwcG9ydGVkLiBUaGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9NQU5JRkVTVF9OVUxMXCIpO1xuXHRcdFx0dGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGZpbGVMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dGhpcy5fYWRkSXRlbShmaWxlTGlzdFtpXSwgcGF0aCwgYmFzZVBhdGgpO1xuXHRcdH1cblxuXHRcdGlmIChsb2FkTm93ICE9PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5zZXRQYXVzZWQoZmFsc2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNldFBhdXNlZCh0cnVlKTtcblx0XHR9XG5cblx0fTtcblxuXHQvKipcblx0ICogU3RhcnQgYSBMb2FkUXVldWUgdGhhdCB3YXMgY3JlYXRlZCwgYnV0IG5vdCBhdXRvbWF0aWNhbGx5IHN0YXJ0ZWQuXG5cdCAqIEBtZXRob2QgbG9hZFxuXHQgKi9cblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuc2V0UGF1c2VkKGZhbHNlKTtcblx0fTtcblxuXHQvKipcblx0ICogTG9vayB1cCBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IHVzaW5nIGVpdGhlciB0aGUgXCJpZFwiIG9yIFwic3JjXCIgdGhhdCB3YXMgc3BlY2lmaWVkIHdoZW4gbG9hZGluZyBpdC4gTm90ZSB0aGF0IGlmIG5vIFwiaWRcIiB3YXNcblx0ICogc3VwcGxpZWQgd2l0aCB0aGUgbG9hZCBpdGVtLCB0aGUgSUQgd2lsbCBiZSB0aGUgXCJzcmNcIiwgaW5jbHVkaW5nIGEgYHBhdGhgIHByb3BlcnR5IGRlZmluZWQgYnkgYSBtYW5pZmVzdC4gVGhlXG5cdCAqIGBiYXNlUGF0aGAgd2lsbCBub3QgYmUgcGFydCBvZiB0aGUgSUQuXG5cdCAqIEBtZXRob2QgZ2V0SXRlbVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIDxjb2RlPmlkPC9jb2RlPiBvciA8Y29kZT5zcmM8L2NvZGU+IG9mIHRoZSBsb2FkIGl0ZW0uXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGxvYWQgaXRlbSB0aGF0IHdhcyBpbml0aWFsbHkgcmVxdWVzdGVkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvciB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319LiBUaGlzIG9iamVjdCBpcyBhbHNvIHJldHVybmVkIHZpYSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IGFzIHRoZSBgaXRlbWAgcGFyYW1ldGVyLlxuXHQgKi9cblx0cC5nZXRJdGVtID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRJdGVtc0J5SWRbdmFsdWVdIHx8IHRoaXMuX2xvYWRJdGVtc0J5U3JjW3ZhbHVlXTtcblx0fTtcblxuXHQvKipcblx0ICogTG9vayB1cCBhIGxvYWRlZCByZXN1bHQgdXNpbmcgZWl0aGVyIHRoZSBcImlkXCIgb3IgXCJzcmNcIiB0aGF0IHdhcyBzcGVjaWZpZWQgd2hlbiBsb2FkaW5nIGl0LiBOb3RlIHRoYXQgaWYgbm8gXCJpZFwiXG5cdCAqIHdhcyBzdXBwbGllZCB3aXRoIHRoZSBsb2FkIGl0ZW0sIHRoZSBJRCB3aWxsIGJlIHRoZSBcInNyY1wiLCBpbmNsdWRpbmcgYSBgcGF0aGAgcHJvcGVydHkgZGVmaW5lZCBieSBhIG1hbmlmZXN0LiBUaGVcblx0ICogYGJhc2VQYXRoYCB3aWxsIG5vdCBiZSBwYXJ0IG9mIHRoZSBJRC5cblx0ICogQG1ldGhvZCBnZXRSZXN1bHRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSA8Y29kZT5pZDwvY29kZT4gb3IgPGNvZGU+c3JjPC9jb2RlPiBvZiB0aGUgbG9hZCBpdGVtLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyYXdSZXN1bHQ9ZmFsc2VdIFJldHVybiBhIHJhdyByZXN1bHQgaW5zdGVhZCBvZiBhIGZvcm1hdHRlZCByZXN1bHQuIFRoaXMgYXBwbGllcyB0byBjb250ZW50XG5cdCAqIGxvYWRlZCB2aWEgWEhSIHN1Y2ggYXMgc2NyaXB0cywgWE1MLCBDU1MsIGFuZCBJbWFnZXMuIElmIHRoZXJlIGlzIG5vIHJhdyByZXN1bHQsIHRoZSBmb3JtYXR0ZWQgcmVzdWx0IHdpbGwgYmVcblx0ICogcmV0dXJuZWQgaW5zdGVhZC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBBIHJlc3VsdCBvYmplY3QgY29udGFpbmluZyB0aGUgY29udGVudCB0aGF0IHdhcyBsb2FkZWQsIHN1Y2ggYXM6XG5cdCAqIDx1bD5cblx0ICogICAgICA8bGk+QW4gaW1hZ2UgdGFnICgmbHQ7aW1hZ2UgLyZndDspIGZvciBpbWFnZXM8L2xpPlxuXHQgKiAgICAgIDxsaT5BIHNjcmlwdCB0YWcgZm9yIEphdmFTY3JpcHQgKCZsdDtzY3JpcHQgLyZndDspLiBOb3RlIHRoYXQgc2NyaXB0cyBhcmUgYXV0b21hdGljYWxseSBhZGRlZCB0byB0aGUgSFRNTFxuXHQgKiAgICAgIERPTS48L2xpPlxuXHQgKiAgICAgIDxsaT5BIHN0eWxlIHRhZyBmb3IgQ1NTICgmbHQ7c3R5bGUgLyZndDsgb3IgJmx0O2xpbmsgJmd0Oyk8L2xpPlxuXHQgKiAgICAgIDxsaT5SYXcgdGV4dCBmb3IgVEVYVDwvbGk+XG5cdCAqICAgICAgPGxpPkEgZm9ybWF0dGVkIEphdmFTY3JpcHQgb2JqZWN0IGRlZmluZWQgYnkgSlNPTjwvbGk+XG5cdCAqICAgICAgPGxpPkFuIFhNTCBkb2N1bWVudDwvbGk+XG5cdCAqICAgICAgPGxpPkEgYmluYXJ5IGFycmF5YnVmZmVyIGxvYWRlZCBieSBYSFI8L2xpPlxuXHQgKiAgICAgIDxsaT5BbiBhdWRpbyB0YWcgKCZsdDthdWRpbyAmZ3Q7KSBmb3IgSFRNTCBhdWRpby4gTm90ZSB0aGF0IGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBTb3VuZEpTIEFQSXMgdG8gcGxheVxuXHQgKiAgICAgIGxvYWRlZCBhdWRpby4gU3BlY2lmaWNhbGx5LCBhdWRpbyBsb2FkZWQgYnkgRmxhc2ggYW5kIFdlYkF1ZGlvIHdpbGwgcmV0dXJuIGEgbG9hZGVyIG9iamVjdCB1c2luZyB0aGlzIG1ldGhvZFxuXHQgKiAgICAgIHdoaWNoIGNhbiBub3QgYmUgdXNlZCB0byBwbGF5IGF1ZGlvIGJhY2suPC9saT5cblx0ICogPC91bD5cblx0ICogVGhpcyBvYmplY3QgaXMgYWxzbyByZXR1cm5lZCB2aWEgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBhcyB0aGUgJ2l0ZW1gXG5cdCAqIHBhcmFtZXRlci4gTm90ZSB0aGF0IGlmIGEgcmF3IHJlc3VsdCBpcyByZXF1ZXN0ZWQsIGJ1dCBub3QgZm91bmQsIHRoZSByZXN1bHQgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkLlxuXHQgKi9cblx0cC5nZXRSZXN1bHQgPSBmdW5jdGlvbiAodmFsdWUsIHJhd1Jlc3VsdCkge1xuXHRcdHZhciBpdGVtID0gdGhpcy5fbG9hZEl0ZW1zQnlJZFt2YWx1ZV0gfHwgdGhpcy5fbG9hZEl0ZW1zQnlTcmNbdmFsdWVdO1xuXHRcdGlmIChpdGVtID09IG51bGwpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHR2YXIgaWQgPSBpdGVtLmlkO1xuXHRcdGlmIChyYXdSZXN1bHQgJiYgdGhpcy5fbG9hZGVkUmF3UmVzdWx0c1tpZF0pIHtcblx0XHRcdHJldHVybiB0aGlzLl9sb2FkZWRSYXdSZXN1bHRzW2lkXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRlZFJlc3VsdHNbaWRdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBhbiBsaXN0IG9mIGl0ZW1zIGxvYWRlZCBieSB0aGlzIHF1ZXVlLlxuXHQgKiBAbWV0aG9kIGdldEl0ZW1zXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gbG9hZGVkIERldGVybWluZXMgaWYgb25seSBpdGVtcyB0aGF0IGhhdmUgYmVlbiBsb2FkZWQgc2hvdWxkIGJlIHJldHVybmVkLiBJZiBmYWxzZSwgaW4tcHJvZ3Jlc3Ncblx0ICogYW5kIGZhaWxlZCBsb2FkIGl0ZW1zIHdpbGwgYWxzbyBiZSBpbmNsdWRlZC5cblx0ICogQHJldHVybnMge0FycmF5fSBBIGxpc3Qgb2Ygb2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBsb2FkZWQuIEVhY2ggaXRlbSBpbmNsdWRlcyB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIHJlc3VsdCwgYW5kIHJhd1Jlc3VsdC5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmdldEl0ZW1zID0gZnVuY3Rpb24gKGxvYWRlZCkge1xuXHRcdHZhciBhcnIgPSBbXTtcblx0XHRmb3IgKHZhciBuIGluIHRoaXMuX2xvYWRJdGVtc0J5SWQpIHtcblx0XHRcdHZhciBpdGVtID0gdGhpcy5fbG9hZEl0ZW1zQnlJZFtuXTtcblx0XHRcdHZhciByZXN1bHQgPSB0aGlzLmdldFJlc3VsdChuKTtcblx0XHRcdGlmIChsb2FkZWQgPT09IHRydWUgJiYgcmVzdWx0ID09IG51bGwpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRhcnIucHVzaCh7XG5cdFx0XHRcdGl0ZW06IGl0ZW0sXG5cdFx0XHRcdHJlc3VsdDogcmVzdWx0LFxuXHRcdFx0XHRyYXdSZXN1bHQ6IHRoaXMuZ2V0UmVzdWx0KG4sIHRydWUpXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIGFycjtcblx0fTtcblxuXHQvKipcblx0ICogUGF1c2Ugb3IgcmVzdW1lIHRoZSBjdXJyZW50IGxvYWQuIEFjdGl2ZSBsb2FkcyB3aWxsIG5vdCBiZSBjYW5jZWxsZWQsIGJ1dCB0aGUgbmV4dCBpdGVtcyBpbiB0aGUgcXVldWUgd2lsbCBub3Rcblx0ICogYmUgcHJvY2Vzc2VkIHdoZW4gYWN0aXZlIGxvYWRzIGNvbXBsZXRlLiBMb2FkUXVldWVzIGFyZSBub3QgcGF1c2VkIGJ5IGRlZmF1bHQuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBpZiBuZXcgaXRlbXMgYXJlIGFkZGVkIHRvIHRoZSBxdWV1ZSB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fSwgYSBwYXVzZWQgcXVldWUgd2lsbCBiZSByZXN1bWVkLCB1bmxlc3MgdGhlIGBsb2FkTm93YFxuXHQgKiBhcmd1bWVudCBpcyBgZmFsc2VgLlxuXHQgKiBAbWV0aG9kIHNldFBhdXNlZFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIFdoZXRoZXIgdGhlIHF1ZXVlIHNob3VsZCBiZSBwYXVzZWQgb3Igbm90LlxuXHQgKi9cblx0cC5zZXRQYXVzZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR0aGlzLl9wYXVzZWQgPSB2YWx1ZTtcblx0XHRpZiAoIXRoaXMuX3BhdXNlZCkge1xuXHRcdFx0dGhpcy5fbG9hZE5leHQoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENsb3NlIHRoZSBhY3RpdmUgcXVldWUuIENsb3NpbmcgYSBxdWV1ZSBjb21wbGV0ZWx5IGVtcHRpZXMgdGhlIHF1ZXVlLCBhbmQgcHJldmVudHMgYW55IHJlbWFpbmluZyBpdGVtcyBmcm9tXG5cdCAqIHN0YXJ0aW5nIHRvIGRvd25sb2FkLiBOb3RlIHRoYXQgY3VycmVudGx5IGFueSBhY3RpdmUgbG9hZHMgd2lsbCByZW1haW4gb3BlbiwgYW5kIGV2ZW50cyBtYXkgYmUgcHJvY2Vzc2VkLlxuXHQgKlxuXHQgKiBUbyBzdG9wIGFuZCByZXN0YXJ0IGEgcXVldWUsIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldFBhdXNlZFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBjbG9zZVxuXHQgKi9cblx0cC5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR3aGlsZSAodGhpcy5fY3VycmVudExvYWRzLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5fY3VycmVudExvYWRzLnBvcCgpLmNhbmNlbCgpO1xuXHRcdH1cblx0XHR0aGlzLl9zY3JpcHRPcmRlci5sZW5ndGggPSAwO1xuXHRcdHRoaXMuX2xvYWRlZFNjcmlwdHMubGVuZ3RoID0gMDtcblx0XHR0aGlzLmxvYWRTdGFydFdhc0Rpc3BhdGNoZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9pdGVtQ291bnQgPSAwO1xuXHRcdHRoaXMuX2xhc3RQcm9ncmVzcyA9IE5hTjtcblx0fTtcblxuLy8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIEFkZCBhbiBpdGVtIHRvIHRoZSBxdWV1ZS4gSXRlbXMgYXJlIGZvcm1hdHRlZCBpbnRvIGEgdXNhYmxlIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgcHJvcGVydGllcyBuZWNlc3NhcnkgdG9cblx0ICogbG9hZCB0aGUgY29udGVudC4gVGhlIGxvYWQgcXVldWUgaXMgcG9wdWxhdGVkIHdpdGggdGhlIGxvYWRlciBpbnN0YW5jZSB0aGF0IGhhbmRsZXMgcHJlbG9hZGluZywgYW5kIG5vdCB0aGUgbG9hZFxuXHQgKiBpdGVtIHRoYXQgd2FzIHBhc3NlZCBpbiBieSB0aGUgdXNlci4gVG8gbG9vayB1cCB0aGUgbG9hZCBpdGVtIGJ5IGlkIG9yIHNyYywgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUuZ2V0SXRlbVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuXG5cdCAqIEBtZXRob2QgX2FkZEl0ZW1cblx0ICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB2YWx1ZSBUaGUgaXRlbSB0byBhZGQgdG8gdGhlIHF1ZXVlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdIEFuIG9wdGlvbmFsIHBhdGggcHJlcGVuZGVkIHRvIHRoZSBgc3JjYC4gVGhlIHBhdGggd2lsbCBvbmx5IGJlIHByZXBlbmRlZCBpZiB0aGUgc3JjIGlzXG5cdCAqIHJlbGF0aXZlLCBhbmQgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIHByb3RvY29sIHN1Y2ggYXMgYGh0dHA6Ly9gLCBvciBhIHBhdGggbGlrZSBgLi4vYC4gSWYgdGhlIExvYWRRdWV1ZSB3YXNcblx0ICogcHJvdmlkZWQgYSB7eyNjcm9zc0xpbmsgXCJfYmFzZVBhdGhcIn19e3svY3Jvc3NMaW5rfX0sIHRoZW4gaXQgd2lsbCBvcHRpb25hbGx5IGJlIHByZXBlbmRlZCBhZnRlci5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtiYXNlUGF0aF0gPHN0cm9uZz5EZXByZWNhdGVkPC9zdHJvbmc+QW4gb3B0aW9uYWwgYmFzZVBhdGggcGFzc2VkIGludG8gYSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG9yIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fSBjYWxsLiBUaGlzIHBhcmFtZXRlciB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdGFnZ2VkXG5cdCAqIHZlcnNpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9hZGRJdGVtID0gZnVuY3Rpb24gKHZhbHVlLCBwYXRoLCBiYXNlUGF0aCkge1xuXHRcdHZhciBpdGVtID0gdGhpcy5fY3JlYXRlTG9hZEl0ZW0odmFsdWUsIHBhdGgsIGJhc2VQYXRoKTsgLy8gYmFzZVBhdGggYW5kIG1hbmlmZXN0IHBhdGggYXJlIGFkZGVkIHRvIHRoZSBzcmMuXG5cdFx0aWYgKGl0ZW0gPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy8gU29tZXRpbWVzIHBsdWdpbnMgb3IgdHlwZXMgc2hvdWxkIGJlIHNraXBwZWQuXG5cdFx0dmFyIGxvYWRlciA9IHRoaXMuX2NyZWF0ZUxvYWRlcihpdGVtKTtcblx0XHRpZiAobG9hZGVyICE9IG51bGwpIHtcblx0XHRcdGlmIChcInBsdWdpbnNcIiBpbiBsb2FkZXIpIHtcblx0XHRcdFx0bG9hZGVyLnBsdWdpbnMgPSB0aGlzLl9wbHVnaW5zO1xuXHRcdFx0fVxuXHRcdFx0aXRlbS5fbG9hZGVyID0gbG9hZGVyO1xuXHRcdFx0dGhpcy5fbG9hZFF1ZXVlLnB1c2gobG9hZGVyKTtcblx0XHRcdHRoaXMuX2xvYWRRdWV1ZUJhY2t1cC5wdXNoKGxvYWRlcik7XG5cblx0XHRcdHRoaXMuX251bUl0ZW1zKys7XG5cdFx0XHR0aGlzLl91cGRhdGVQcm9ncmVzcygpO1xuXG5cdFx0XHQvLyBPbmx5IHdvcnJ5IGFib3V0IHNjcmlwdCBvcmRlciB3aGVuIHVzaW5nIFhIUiB0byBsb2FkIHNjcmlwdHMuIFRhZ3MgYXJlIG9ubHkgbG9hZGluZyBvbmUgYXQgYSB0aW1lLlxuXHRcdFx0aWYgKCh0aGlzLm1haW50YWluU2NyaXB0T3JkZXJcblx0XHRcdFx0XHQmJiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuTG9hZFF1ZXVlLkpBVkFTQ1JJUFRcblx0XHRcdFx0XHRcdC8vJiYgbG9hZGVyIGluc3RhbmNlb2YgY3JlYXRlanMuWEhSTG9hZGVyIC8vTk9URTogSGF2ZSB0byB0cmFjayBhbGwgSlMgZmlsZXMgdGhpcyB3YXlcblx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0fHwgaXRlbS5tYWludGFpbk9yZGVyID09PSB0cnVlKSB7XG5cdFx0XHRcdHRoaXMuX3NjcmlwdE9yZGVyLnB1c2goaXRlbSk7XG5cdFx0XHRcdHRoaXMuX2xvYWRlZFNjcmlwdHMucHVzaChudWxsKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIHJlZmluZWQge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0sIHdoaWNoIGNvbnRhaW5zIGFsbCB0aGUgcmVxdWlyZWQgcHJvcGVydGllcy4gVGhlIHR5cGUgb2Zcblx0ICogaXRlbSBpcyBkZXRlcm1pbmVkIGJ5IGJyb3dzZXIgc3VwcG9ydCwgcmVxdWlyZW1lbnRzIGJhc2VkIG9uIHRoZSBmaWxlIHR5cGUsIGFuZCBkZXZlbG9wZXIgc2V0dGluZ3MuIEZvciBleGFtcGxlLFxuXHQgKiBYSFIgaXMgb25seSB1c2VkIGZvciBmaWxlIHR5cGVzIHRoYXQgc3VwcG9ydCBpdCBpbiBuZXcgYnJvd3NlcnMuXG5cdCAqXG5cdCAqIEJlZm9yZSB0aGUgaXRlbSBpcyByZXR1cm5lZCwgYW55IHBsdWdpbnMgcmVnaXN0ZXJlZCB0byBoYW5kbGUgdGhlIHR5cGUgb3IgZXh0ZW5zaW9uIHdpbGwgYmUgZmlyZWQsIHdoaWNoIG1heVxuXHQgKiBhbHRlciB0aGUgbG9hZCBpdGVtLlxuXHQgKiBAbWV0aG9kIF9jcmVhdGVMb2FkSXRlbVxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE9iamVjdCB8IEhUTUxBdWRpb0VsZW1lbnQgfCBIVE1MSW1hZ2VFbGVtZW50fSB2YWx1ZSBUaGUgaXRlbSB0aGF0IG5lZWRzIHRvIGJlIHByZWxvYWRlZC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXSBBIHBhdGggdG8gcHJlcGVuZCB0byB0aGUgaXRlbSdzIHNvdXJjZS4gU291cmNlcyBiZWdpbm5pbmcgd2l0aCBodHRwOi8vIG9yIHNpbWlsYXIgd2lsbFxuXHQgKiBub3QgcmVjZWl2ZSBhIHBhdGguIFNpbmNlIFByZWxvYWRKUyAwLjQuMSwgdGhlIHNyYyB3aWxsIGJlIG1vZGlmaWVkIHRvIGluY2x1ZGUgdGhlIGBwYXRoYCBhbmQge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL19iYXNlUGF0aDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aGVuIGl0IGlzIGFkZGVkLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2Jhc2VQYXRoXSA8c3Ryb25nPkRlcHJlY3RhdGVkPC9zdHJvbmc+IEEgYmFzZSBwYXRoIHRvIHByZXBlbmQgdG8gdGhlIGl0ZW1zIHNvdXJjZSBpbiBhZGRpdGlvbiB0b1xuXHQgKiB0aGUgcGF0aCBhcmd1bWVudC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgbG9hZGVyIGluc3RhbmNlIHRoYXQgd2lsbCBiZSB1c2VkLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY3JlYXRlTG9hZEl0ZW0gPSBmdW5jdGlvbiAodmFsdWUsIHBhdGgsIGJhc2VQYXRoKSB7XG5cdFx0dmFyIGl0ZW0gPSBjcmVhdGVqcy5Mb2FkSXRlbS5jcmVhdGUodmFsdWUpO1xuXHRcdGlmIChpdGVtID09IG51bGwpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciBicCA9IFwiXCI7IC8vIFN0b3JlIHRoZSBnZW5lcmF0ZWQgYmFzZVBhdGhcblx0XHR2YXIgdXNlQmFzZVBhdGggPSBiYXNlUGF0aCB8fCB0aGlzLl9iYXNlUGF0aDtcblxuXHRcdGlmIChpdGVtLnNyYyBpbnN0YW5jZW9mIE9iamVjdCkge1xuXHRcdFx0aWYgKCFpdGVtLnR5cGUpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9IC8vIHRoZSB0aGUgc3JjIGlzIGFuIG9iamVjdCwgdHlwZSBpcyByZXF1aXJlZCB0byBwYXNzIG9mZiB0byBwbHVnaW5cblx0XHRcdGlmIChwYXRoKSB7XG5cdFx0XHRcdGJwID0gcGF0aDtcblx0XHRcdFx0dmFyIHBhdGhNYXRjaCA9IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5wYXJzZVVSSShwYXRoKTtcblx0XHRcdFx0Ly8gQWxzbyBhcHBlbmQgYmFzZVBhdGhcblx0XHRcdFx0aWYgKHVzZUJhc2VQYXRoICE9IG51bGwgJiYgIXBhdGhNYXRjaC5hYnNvbHV0ZSAmJiAhcGF0aE1hdGNoLnJlbGF0aXZlKSB7XG5cdFx0XHRcdFx0YnAgPSB1c2VCYXNlUGF0aCArIGJwO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHVzZUJhc2VQYXRoICE9IG51bGwpIHtcblx0XHRcdFx0YnAgPSB1c2VCYXNlUGF0aDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRGV0ZXJtaW5lIEV4dGVuc2lvbiwgZXRjLlxuXHRcdFx0dmFyIG1hdGNoID0gY3JlYXRlanMuUmVxdWVzdFV0aWxzLnBhcnNlVVJJKGl0ZW0uc3JjKTtcblx0XHRcdGlmIChtYXRjaC5leHRlbnNpb24pIHtcblx0XHRcdFx0aXRlbS5leHQgPSBtYXRjaC5leHRlbnNpb247XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXRlbS50eXBlID09IG51bGwpIHtcblx0XHRcdFx0aXRlbS50eXBlID0gY3JlYXRlanMuUmVxdWVzdFV0aWxzLmdldFR5cGVCeUV4dGVuc2lvbihpdGVtLmV4dCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluamVjdCBwYXRoICYgYmFzZVBhdGhcblx0XHRcdHZhciBhdXRvSWQgPSBpdGVtLnNyYztcblx0XHRcdGlmICghbWF0Y2guYWJzb2x1dGUgJiYgIW1hdGNoLnJlbGF0aXZlKSB7XG5cdFx0XHRcdGlmIChwYXRoKSB7XG5cdFx0XHRcdFx0YnAgPSBwYXRoO1xuXHRcdFx0XHRcdHZhciBwYXRoTWF0Y2ggPSBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMucGFyc2VVUkkocGF0aCk7XG5cdFx0XHRcdFx0YXV0b0lkID0gcGF0aCArIGF1dG9JZDtcblx0XHRcdFx0XHQvLyBBbHNvIGFwcGVuZCBiYXNlUGF0aFxuXHRcdFx0XHRcdGlmICh1c2VCYXNlUGF0aCAhPSBudWxsICYmICFwYXRoTWF0Y2guYWJzb2x1dGUgJiYgIXBhdGhNYXRjaC5yZWxhdGl2ZSkge1xuXHRcdFx0XHRcdFx0YnAgPSB1c2VCYXNlUGF0aCArIGJwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICh1c2VCYXNlUGF0aCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0YnAgPSB1c2VCYXNlUGF0aDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aXRlbS5zcmMgPSBicCArIGl0ZW0uc3JjO1xuXHRcdH1cblx0XHRpdGVtLnBhdGggPSBicDtcblxuXHRcdC8vIElmIHRoZXJlJ3Mgbm8gaWQsIHNldCBvbmUgbm93LlxuXHRcdGlmIChpdGVtLmlkID09PSB1bmRlZmluZWQgfHwgaXRlbS5pZCA9PT0gbnVsbCB8fCBpdGVtLmlkID09PSBcIlwiKSB7XG5cdFx0XHRpdGVtLmlkID0gYXV0b0lkO1xuXHRcdH1cblxuXHRcdC8vIEdpdmUgcGx1Z2lucyBhIGNoYW5jZSB0byBtb2RpZnkgdGhlIGxvYWRJdGVtOlxuXHRcdHZhciBjdXN0b21IYW5kbGVyID0gdGhpcy5fdHlwZUNhbGxiYWNrc1tpdGVtLnR5cGVdIHx8IHRoaXMuX2V4dGVuc2lvbkNhbGxiYWNrc1tpdGVtLmV4dF07XG5cdFx0aWYgKGN1c3RvbUhhbmRsZXIpIHtcblx0XHRcdC8vIFBsdWdpbnMgYXJlIG5vdyBwYXNzZWQgYm90aCB0aGUgZnVsbCBzb3VyY2UsIGFzIHdlbGwgYXMgYSBjb21iaW5lZCBwYXRoK2Jhc2VQYXRoIChhcHByb3ByaWF0ZWx5KVxuXHRcdFx0dmFyIHJlc3VsdCA9IGN1c3RvbUhhbmRsZXIuY2FsbGJhY2suY2FsbChjdXN0b21IYW5kbGVyLnNjb3BlLCBpdGVtLCB0aGlzKTtcblxuXHRcdFx0Ly8gVGhlIHBsdWdpbiB3aWxsIGhhbmRsZSB0aGUgbG9hZCwgb3IgaGFzIGNhbmNlbGVkIGl0LiBJZ25vcmUgaXQuXG5cdFx0XHRpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0XHQvLyBMb2FkIGFzIG5vcm1hbDpcblx0XHRcdH0gZWxzZSBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG5cdFx0XHRcdC8vIERvIE5vdGhpbmdcblxuXHRcdFx0XHQvLyBSZXN1bHQgaXMgYSBsb2FkZXIgY2xhc3M6XG5cdFx0XHR9IGVsc2UgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG5cdFx0XHRcdGl0ZW0uX2xvYWRlciA9IHJlc3VsdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXBkYXRlIHRoZSBleHRlbnNpb24gaW4gY2FzZSB0aGUgdHlwZSBjaGFuZ2VkOlxuXHRcdFx0bWF0Y2ggPSBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMucGFyc2VVUkkoaXRlbS5zcmMpO1xuXHRcdFx0aWYgKG1hdGNoLmV4dGVuc2lvbiAhPSBudWxsKSB7XG5cdFx0XHRcdGl0ZW0uZXh0ID0gbWF0Y2guZXh0ZW5zaW9uO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFN0b3JlIHRoZSBpdGVtIGZvciBsb29rdXAuIFRoaXMgYWxzbyBoZWxwcyBjbGVhbi11cCBsYXRlci5cblx0XHR0aGlzLl9sb2FkSXRlbXNCeUlkW2l0ZW0uaWRdID0gaXRlbTtcblx0XHR0aGlzLl9sb2FkSXRlbXNCeVNyY1tpdGVtLnNyY10gPSBpdGVtO1xuXG5cdFx0aWYgKGl0ZW0uY3Jvc3NPcmlnaW4gPT0gbnVsbCkge1xuXHRcdFx0aXRlbS5jcm9zc09yaWdpbiA9IHRoaXMuX2Nyb3NzT3JpZ2luO1xuXHRcdH1cblxuXHRcdHJldHVybiBpdGVtO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBsb2FkZXIgZm9yIGEgbG9hZCBpdGVtLlxuXHQgKiBAbWV0aG9kIF9jcmVhdGVMb2FkZXJcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gQSBmb3JtYXR0ZWQgbG9hZCBpdGVtIHRoYXQgY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgYSBsb2FkZXIuXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0TG9hZGVyfSBBIGxvYWRlciB0aGF0IGNhbiBiZSB1c2VkIHRvIGxvYWQgY29udGVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NyZWF0ZUxvYWRlciA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0aWYgKGl0ZW0uX2xvYWRlciAhPSBudWxsKSB7IC8vIEEgcGx1Z2luIGFscmVhZHkgc3BlY2lmaWVkIGEgbG9hZGVyXG5cdFx0XHRyZXR1cm4gaXRlbS5fbG9hZGVyO1xuXHRcdH1cblxuXHRcdC8vIEluaXRpYWxseSwgdHJ5IGFuZCB1c2UgdGhlIHByb3ZpZGVkL3N1cHBvcnRlZCBYSFIgbW9kZTpcblx0XHR2YXIgcHJlZmVyWEhSID0gdGhpcy5wcmVmZXJYSFI7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2F2YWlsYWJsZUxvYWRlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBsb2FkZXIgPSB0aGlzLl9hdmFpbGFibGVMb2FkZXJzW2ldO1xuXHRcdFx0aWYgKGxvYWRlciAmJiBsb2FkZXIuY2FuTG9hZEl0ZW0oaXRlbSkpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBsb2FkZXIoaXRlbSwgcHJlZmVyWEhSKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBUT0RPOiBMb2cgZXJyb3IgKHJlcXVpcmVzIGNyZWF0ZWpzLmxvZylcblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogTG9hZCB0aGUgbmV4dCBpdGVtIGluIHRoZSBxdWV1ZS4gSWYgdGhlIHF1ZXVlIGlzIGVtcHR5IChhbGwgaXRlbXMgaGF2ZSBiZWVuIGxvYWRlZCksIHRoZW4gdGhlIGNvbXBsZXRlIGV2ZW50XG5cdCAqIGlzIHByb2Nlc3NlZC4gVGhlIHF1ZXVlIHdpbGwgXCJmaWxsIHVwXCIgYW55IGVtcHR5IHNsb3RzLCB1cCB0byB0aGUgbWF4IGNvbm5lY3Rpb24gc3BlY2lmaWVkIHVzaW5nXG5cdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS5zZXRNYXhDb25uZWN0aW9uc1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuIFRoZSBvbmx5IGV4Y2VwdGlvbiBpcyBzY3JpcHRzIHRoYXQgYXJlIGxvYWRlZFxuXHQgKiB1c2luZyB0YWdzLCB3aGljaCBoYXZlIHRvIGJlIGxvYWRlZCBvbmUgYXQgYSB0aW1lIHRvIG1haW50YWluIGxvYWQgb3JkZXIuXG5cdCAqIEBtZXRob2QgX2xvYWROZXh0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9sb2FkTmV4dCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcGF1c2VkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25seSBkaXNwYXRjaCBsb2Fkc3RhcnQgZXZlbnQgd2hlbiB0aGUgZmlyc3QgZmlsZSBpcyBsb2FkZWQuXG5cdFx0aWYgKCF0aGlzLl9sb2FkU3RhcnRXYXNEaXNwYXRjaGVkKSB7XG5cdFx0XHR0aGlzLl9zZW5kTG9hZFN0YXJ0KCk7XG5cdFx0XHR0aGlzLl9sb2FkU3RhcnRXYXNEaXNwYXRjaGVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBUaGUgcXVldWUgaGFzIGNvbXBsZXRlZC5cblx0XHRpZiAodGhpcy5fbnVtSXRlbXMgPT0gdGhpcy5fbnVtSXRlbXNMb2FkZWQpIHtcblx0XHRcdHRoaXMubG9hZGVkID0gdHJ1ZTtcblx0XHRcdHRoaXMuX3NlbmRDb21wbGV0ZSgpO1xuXG5cdFx0XHQvLyBMb2FkIHRoZSBuZXh0IHF1ZXVlLCBpZiBpdCBoYXMgYmVlbiBkZWZpbmVkLlxuXHRcdFx0aWYgKHRoaXMubmV4dCAmJiB0aGlzLm5leHQubG9hZCkge1xuXHRcdFx0XHR0aGlzLm5leHQubG9hZCgpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmxvYWRlZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIE11c3QgaXRlcmF0ZSBmb3J3YXJkcyB0byBsb2FkIGluIHRoZSByaWdodCBvcmRlci5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xvYWRRdWV1ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuX2N1cnJlbnRMb2Fkcy5sZW5ndGggPj0gdGhpcy5fbWF4Q29ubmVjdGlvbnMpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbG9hZGVyID0gdGhpcy5fbG9hZFF1ZXVlW2ldO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIGJlIG9ubHkgbG9hZGluZyBvbmUgdGFnLXNjcmlwdCBhdCBhIHRpbWU6XG5cdFx0XHQvLyBOb3RlOiBtYWludGFpbk9yZGVyIGl0ZW1zIGRvbid0IGRvIGFueXRoaW5nIGhlcmUgYmVjYXVzZSB3ZSBjYW4gaG9sZCBvbnRvIHRoZWlyIGxvYWRlZCB2YWx1ZVxuXHRcdFx0aWYgKCF0aGlzLl9jYW5TdGFydExvYWQobG9hZGVyKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2xvYWRRdWV1ZS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRpLS07XG5cdFx0XHR0aGlzLl9sb2FkSXRlbShsb2FkZXIpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQmVnaW4gbG9hZGluZyBhbiBpdGVtLiBFdmVudCBsaXN0ZW5lcnMgYXJlIG5vdCBhZGRlZCB0byB0aGUgbG9hZGVycyB1bnRpbCB0aGUgbG9hZCBzdGFydHMuXG5cdCAqIEBtZXRob2QgX2xvYWRJdGVtXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlciBUaGUgbG9hZGVyIGluc3RhbmNlIHRvIHN0YXJ0LiBDdXJyZW50bHksIHRoaXMgd2lsbCBiZSBhbiBYSFJMb2FkZXIgb3IgVGFnTG9hZGVyLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fbG9hZEl0ZW0gPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0bG9hZGVyLm9uKFwiZmlsZWxvYWRcIiwgdGhpcy5faGFuZGxlRmlsZUxvYWQsIHRoaXMpO1xuXHRcdGxvYWRlci5vbihcInByb2dyZXNzXCIsIHRoaXMuX2hhbmRsZVByb2dyZXNzLCB0aGlzKTtcblx0XHRsb2FkZXIub24oXCJjb21wbGV0ZVwiLCB0aGlzLl9oYW5kbGVGaWxlQ29tcGxldGUsIHRoaXMpO1xuXHRcdGxvYWRlci5vbihcImVycm9yXCIsIHRoaXMuX2hhbmRsZUVycm9yLCB0aGlzKTtcblx0XHRsb2FkZXIub24oXCJmaWxlZXJyb3JcIiwgdGhpcy5faGFuZGxlRmlsZUVycm9yLCB0aGlzKTtcblx0XHR0aGlzLl9jdXJyZW50TG9hZHMucHVzaChsb2FkZXIpO1xuXHRcdHRoaXMuX3NlbmRGaWxlU3RhcnQobG9hZGVyLmdldEl0ZW0oKSk7XG5cdFx0bG9hZGVyLmxvYWQoKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIGNhbGxiYWNrIHRoYXQgaXMgZmlyZWQgd2hlbiBhIGxvYWRlciBsb2FkcyBhIGZpbGUuIFRoaXMgZW5hYmxlcyBsb2FkZXJzIGxpa2Uge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogdG8gbWFpbnRhaW4gaW50ZXJuYWwgcXVldWVzLCBidXQgZm9yIHRoaXMgcXVldWUgdG8gZGlzcGF0Y2ggdGhlIHt7I2Nyb3NzTGluayBcImZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50cy5cblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IGZyb20gdGhlIGxvYWRlci5cblx0ICogQHByaXZhdGVcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl9oYW5kbGVGaWxlTG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LnRhcmdldCA9IG51bGw7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIGNhbGxiYWNrIHRoYXQgaXMgZmlyZWQgd2hlbiBhIGxvYWRlciBlbmNvdW50ZXJzIGFuIGVycm9yIGZyb20gYW4gaW50ZXJuYWwgZmlsZSBsb2FkIG9wZXJhdGlvbi4gVGhpcyBlbmFibGVzXG5cdCAqIGxvYWRlcnMgbGlrZSBNXG5cdCAqIEBwYXJhbSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlRmlsZUVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIG5ld0V2ZW50ID0gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJGSUxFX0xPQURfRVJST1JcIiwgbnVsbCwgZXZlbnQuaXRlbSk7XG5cdFx0dGhpcy5fc2VuZEVycm9yKG5ld0V2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIGNhbGxiYWNrIHRoYXQgaXMgZmlyZWQgd2hlbiBhIGxvYWRlciBlbmNvdW50ZXJzIGFuIGVycm9yLiBUaGUgcXVldWUgd2lsbCBjb250aW51ZSBsb2FkaW5nIHVubGVzcyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc3RvcE9uRXJyb3I6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaXMgc2V0IHRvIGB0cnVlYC5cblx0ICogQG1ldGhvZCBfaGFuZGxlRXJyb3Jcblx0ICogQHBhcmFtIHtFcnJvckV2ZW50fSBldmVudCBUaGUgZXJyb3IgZXZlbnQsIGNvbnRhaW5pbmcgcmVsZXZhbnQgZXJyb3IgaW5mb3JtYXRpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBsb2FkZXIgPSBldmVudC50YXJnZXQ7XG5cdFx0dGhpcy5fbnVtSXRlbXNMb2FkZWQrKztcblxuXHRcdHRoaXMuX2ZpbmlzaE9yZGVyZWRJdGVtKGxvYWRlciwgdHJ1ZSk7XG5cdFx0dGhpcy5fdXBkYXRlUHJvZ3Jlc3MoKTtcblxuXHRcdHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiRklMRV9MT0FEX0VSUk9SXCIsIG51bGwsIGxvYWRlci5nZXRJdGVtKCkpO1xuXHRcdC8vIFRPRE86IFByb3BhZ2F0ZSBhY3R1YWwgZXJyb3IgbWVzc2FnZS5cblxuXHRcdHRoaXMuX3NlbmRFcnJvcihuZXdFdmVudCk7XG5cblx0XHRpZiAoIXRoaXMuc3RvcE9uRXJyb3IpIHtcblx0XHRcdHRoaXMuX3JlbW92ZUxvYWRJdGVtKGxvYWRlcik7XG5cdFx0XHR0aGlzLl9jbGVhbkxvYWRJdGVtKGxvYWRlcik7XG5cdFx0XHR0aGlzLl9sb2FkTmV4dCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNldFBhdXNlZCh0cnVlKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEFuIGl0ZW0gaGFzIGZpbmlzaGVkIGxvYWRpbmcuIFdlIGNhbiBhc3N1bWUgdGhhdCBpdCBpcyB0b3RhbGx5IGxvYWRlZCwgaGFzIGJlZW4gcGFyc2VkIGZvciBpbW1lZGlhdGUgdXNlLCBhbmRcblx0ICogaXMgYXZhaWxhYmxlIGFzIHRoZSBcInJlc3VsdFwiIHByb3BlcnR5IG9uIHRoZSBsb2FkIGl0ZW0uIFRoZSByYXcgdGV4dCByZXN1bHQgZm9yIGEgcGFyc2VkIGl0ZW0gKHN1Y2ggYXMgSlNPTiwgWE1MLFxuXHQgKiBDU1MsIEphdmFTY3JpcHQsIGV0YykgaXMgYXZhaWxhYmxlIGFzIHRoZSBcInJhd1Jlc3VsdFwiIHByb3BlcnR5LCBhbmQgY2FuIGFsc28gYmUgbG9va2VkIHVwIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9nZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgX2hhbmRsZUZpbGVDb21wbGV0ZVxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgb2JqZWN0IGZyb20gdGhlIGxvYWRlci5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZUZpbGVDb21wbGV0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBsb2FkZXIgPSBldmVudC50YXJnZXQ7XG5cdFx0dmFyIGl0ZW0gPSBsb2FkZXIuZ2V0SXRlbSgpO1xuXG5cdFx0dmFyIHJlc3VsdCA9IGxvYWRlci5nZXRSZXN1bHQoKTtcblx0XHR0aGlzLl9sb2FkZWRSZXN1bHRzW2l0ZW0uaWRdID0gcmVzdWx0O1xuXHRcdHZhciByYXdSZXN1bHQgPSBsb2FkZXIuZ2V0UmVzdWx0KHRydWUpO1xuXHRcdGlmIChyYXdSZXN1bHQgIT0gbnVsbCAmJiByYXdSZXN1bHQgIT09IHJlc3VsdCkge1xuXHRcdFx0dGhpcy5fbG9hZGVkUmF3UmVzdWx0c1tpdGVtLmlkXSA9IHJhd1Jlc3VsdDtcblx0XHR9XG5cblx0XHR0aGlzLl9zYXZlTG9hZGVkSXRlbXMobG9hZGVyKTtcblxuXHRcdC8vIFJlbW92ZSB0aGUgbG9hZCBpdGVtXG5cdFx0dGhpcy5fcmVtb3ZlTG9hZEl0ZW0obG9hZGVyKTtcblxuXHRcdGlmICghdGhpcy5fZmluaXNoT3JkZXJlZEl0ZW0obG9hZGVyKSkge1xuXHRcdFx0Ly8gVGhlIGl0ZW0gd2FzIE5PVCBtYW5hZ2VkLCBzbyBwcm9jZXNzIGl0IG5vd1xuXHRcdFx0dGhpcy5fcHJvY2Vzc0ZpbmlzaGVkTG9hZChpdGVtLCBsb2FkZXIpO1xuXHRcdH1cblxuXHRcdC8vIENsZWFuIHVwIHRoZSBsb2FkIGl0ZW1cblx0XHR0aGlzLl9jbGVhbkxvYWRJdGVtKGxvYWRlcik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNvbWUgbG9hZGVycyBtaWdodCBsb2FkIGFkZGl0aW9uYWwgY29udGVudCwgb3RoZXIgdGhhbiB0aGUgaXRlbSB0aGV5IHdlcmUgcGFzc2VkIChzdWNoIGFzIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319KS5cblx0ICogQW55IGl0ZW1zIGV4cG9zZWQgYnkgdGhlIGxvYWRlciB1c2luZyB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9nZXRMb2FkSXRlbXNcIn19e3svY3Jvc3NMaW5rfX0gYXJlIGFkZGVkIHRvIHRoZVxuXHQgKiBMb2FkUXVldWUncyBsb29rLXVwcywgaW5jbHVkaW5nIHt7I2Nyb3NzTGluayBcImdldEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcImdldFJlc3VsdFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2RzLlxuXHQgKiBAbWV0aG9kIF9zYXZlTG9hZGVkSXRlbXNcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl9zYXZlTG9hZGVkSXRlbXMgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0Ly8gVE9ETzogTm90IHN1cmUgaG93IHRvIGhhbmRsZSB0aGlzLiBXb3VsZCBiZSBuaWNlIHRvIGV4cG9zZSB0aGUgaXRlbXMuXG5cdFx0Ly8gTG9hZGVycyBtYXkgbG9hZCBzdWItaXRlbXMuIFRoaXMgYWRkcyB0aGVtIHRvIHRoaXMgcXVldWVcblx0XHR2YXIgbGlzdCA9IGxvYWRlci5nZXRMb2FkZWRJdGVtcygpO1xuXHRcdGlmIChsaXN0ID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IGxpc3RbaV0uaXRlbTtcblxuXHRcdFx0Ly8gU3RvcmUgaXRlbSBsb29rdXBzXG5cdFx0XHR0aGlzLl9sb2FkSXRlbXNCeVNyY1tpdGVtLnNyY10gPSBpdGVtO1xuXHRcdFx0dGhpcy5fbG9hZEl0ZW1zQnlJZFtpdGVtLmlkXSA9IGl0ZW07XG5cblx0XHRcdC8vIFN0b3JlIGxvYWRlZCBjb250ZW50XG5cdFx0XHR0aGlzLl9sb2FkZWRSZXN1bHRzW2l0ZW0uaWRdID0gbGlzdFtpXS5yZXN1bHQ7XG5cdFx0XHR0aGlzLl9sb2FkZWRSYXdSZXN1bHRzW2l0ZW0uaWRdID0gbGlzdFtpXS5yYXdSZXN1bHQ7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBGbGFnIGFuIGl0ZW0gYXMgZmluaXNoZWQuIElmIHRoZSBpdGVtJ3Mgb3JkZXIgaXMgYmVpbmcgbWFuYWdlZCwgdGhlbiBlbnN1cmUgdGhhdCBpdCBpcyBhbGxvd2VkIHRvIGZpbmlzaCwgYW5kIGlmXG5cdCAqIHNvLCB0cmlnZ2VyIHByaW9yIGl0ZW1zIHRvIHRyaWdnZXIgYXMgd2VsbC5cblx0ICogQG1ldGhvZCBfZmluaXNoT3JkZXJlZEl0ZW1cblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gbG9hZEZhaWxlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgaXRlbSdzIG9yZGVyIGlzIGJlaW5nIG1hbmFnZWQuIFRoaXMgYWxsb3dzIHRoZSBjYWxsZXIgdG8gdGFrZSBhbiBhbHRlcm5hdGVcblx0ICogYmVoYXZpb3VyIGlmIGl0IGlzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZmluaXNoT3JkZXJlZEl0ZW0gPSBmdW5jdGlvbiAobG9hZGVyLCBsb2FkRmFpbGVkKSB7XG5cdFx0dmFyIGl0ZW0gPSBsb2FkZXIuZ2V0SXRlbSgpO1xuXG5cdFx0aWYgKCh0aGlzLm1haW50YWluU2NyaXB0T3JkZXIgJiYgaXRlbS50eXBlID09IGNyZWF0ZWpzLkxvYWRRdWV1ZS5KQVZBU0NSSVBUKVxuXHRcdFx0XHR8fCBpdGVtLm1haW50YWluT3JkZXIpIHtcblxuXHRcdFx0Ly9UT0RPOiBFdmFsdWF0ZSByZW1vdmFsIG9mIHRoZSBfY3VycmVudGx5TG9hZGluZ1NjcmlwdFxuXHRcdFx0aWYgKGxvYWRlciBpbnN0YW5jZW9mIGNyZWF0ZWpzLkphdmFTY3JpcHRMb2FkZXIpIHtcblx0XHRcdFx0dGhpcy5fY3VycmVudGx5TG9hZGluZ1NjcmlwdCA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaW5kZXggPSBjcmVhdGVqcy5pbmRleE9mKHRoaXMuX3NjcmlwdE9yZGVyLCBpdGVtKTtcblx0XHRcdGlmIChpbmRleCA9PSAtMSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IC8vIFRoaXMgbG9hZGVyIG5vIGxvbmdlciBleGlzdHNcblx0XHRcdHRoaXMuX2xvYWRlZFNjcmlwdHNbaW5kZXhdID0gKGxvYWRGYWlsZWQgPT09IHRydWUpID8gdHJ1ZSA6IGl0ZW07XG5cblx0XHRcdHRoaXMuX2NoZWNrU2NyaXB0TG9hZE9yZGVyKCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuc3VyZSB0aGUgc2NyaXB0cyBsb2FkIGFuZCBkaXNwYXRjaCBpbiB0aGUgY29ycmVjdCBvcmRlci4gV2hlbiB1c2luZyBYSFIsIHNjcmlwdHMgYXJlIHN0b3JlZCBpbiBhbiBhcnJheSBpbiB0aGVcblx0ICogb3JkZXIgdGhleSB3ZXJlIGFkZGVkLCBidXQgd2l0aCBhIFwibnVsbFwiIHZhbHVlLiBXaGVuIHRoZXkgYXJlIGNvbXBsZXRlZCwgdGhlIHZhbHVlIGlzIHNldCB0byB0aGUgbG9hZCBpdGVtLFxuXHQgKiBhbmQgdGhlbiB3aGVuIHRoZXkgYXJlIHByb2Nlc3NlZCBhbmQgZGlzcGF0Y2hlZCwgdGhlIHZhbHVlIGlzIHNldCB0byBgdHJ1ZWAuIFRoaXMgbWV0aG9kIHNpbXBseVxuXHQgKiBpdGVyYXRlcyB0aGUgYXJyYXksIGFuZCBlbnN1cmVzIHRoYXQgYW55IGxvYWRlZCBpdGVtcyB0aGF0IGFyZSBub3QgcHJlY2VkZWQgYnkgYSBgbnVsbGAgdmFsdWUgYXJlXG5cdCAqIGRpc3BhdGNoZWQuXG5cdCAqIEBtZXRob2QgX2NoZWNrU2NyaXB0TG9hZE9yZGVyXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jaGVja1NjcmlwdExvYWRPcmRlciA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbCA9IHRoaXMuX2xvYWRlZFNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gdGhpcy5fbG9hZGVkU2NyaXB0c1tpXTtcblx0XHRcdGlmIChpdGVtID09PSBudWxsKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fSAvLyBUaGlzIGlzIHN0aWxsIGxvYWRpbmcuIERvIG5vdCBwcm9jZXNzIGZ1cnRoZXIuXG5cdFx0XHRpZiAoaXRlbSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gLy8gVGhpcyBoYXMgY29tcGxldGVkLCBhbmQgYmVlbiBwcm9jZXNzZWQuIE1vdmUgb24uXG5cblx0XHRcdHZhciBsb2FkSXRlbSA9IHRoaXMuX2xvYWRlZFJlc3VsdHNbaXRlbS5pZF07XG5cdFx0XHRpZiAoaXRlbS50eXBlID09IGNyZWF0ZWpzLkxvYWRRdWV1ZS5KQVZBU0NSSVBUKSB7XG5cdFx0XHRcdC8vIEFwcGVuZCBzY3JpcHQgdGFncyB0byB0aGUgaGVhZCBhdXRvbWF0aWNhbGx5LlxuXHRcdFx0XHRjcmVhdGVqcy5Eb21VdGlscy5hcHBlbmRUb0hlYWQobG9hZEl0ZW0pO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbG9hZGVyID0gaXRlbS5fbG9hZGVyO1xuXHRcdFx0dGhpcy5fcHJvY2Vzc0ZpbmlzaGVkTG9hZChpdGVtLCBsb2FkZXIpO1xuXHRcdFx0dGhpcy5fbG9hZGVkU2NyaXB0c1tpXSA9IHRydWU7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBIGZpbGUgaGFzIGNvbXBsZXRlZCBsb2FkaW5nLCBhbmQgdGhlIExvYWRRdWV1ZSBjYW4gbW92ZSBvbi4gVGhpcyB0cmlnZ2VycyB0aGUgY29tcGxldGUgZXZlbnQsIGFuZCBraWNrLXN0YXJ0c1xuXHQgKiB0aGUgbmV4dCBpdGVtLlxuXHQgKiBAbWV0aG9kIF9wcm9jZXNzRmluaXNoZWRMb2FkXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9wcm9jZXNzRmluaXNoZWRMb2FkID0gZnVuY3Rpb24gKGl0ZW0sIGxvYWRlcikge1xuXHRcdHRoaXMuX251bUl0ZW1zTG9hZGVkKys7XG5cblx0XHQvLyBTaW5jZSBMb2FkUXVldWUgbmVlZHMgbWFpbnRhaW4gb3JkZXIsIHdlIGNhbid0IGFwcGVuZCBzY3JpcHRzIGluIHRoZSBsb2FkZXIuXG5cdFx0Ly8gU28gd2UgZG8gaXQgaGVyZSBpbnN0ZWFkLiBPciBpbiBfY2hlY2tTY3JpcHRMb2FkT3JkZXIoKTtcblx0XHRpZiAoIXRoaXMubWFpbnRhaW5TY3JpcHRPcmRlciAmJiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuTG9hZFF1ZXVlLkpBVkFTQ1JJUFQpIHtcblx0XHRcdHZhciB0YWcgPSBsb2FkZXIuZ2V0VGFnKCk7XG5cdFx0XHRjcmVhdGVqcy5Eb21VdGlscy5hcHBlbmRUb0hlYWQodGFnKTtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVQcm9ncmVzcygpO1xuXHRcdHRoaXMuX3NlbmRGaWxlQ29tcGxldGUoaXRlbSwgbG9hZGVyKTtcblx0XHR0aGlzLl9sb2FkTmV4dCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbnN1cmUgaXRlbXMgd2l0aCBgbWFpbnRhaW5PcmRlcj10cnVlYCB0aGF0IGFyZSBiZWZvcmUgdGhlIHNwZWNpZmllZCBpdGVtIGhhdmUgbG9hZGVkLiBUaGlzIG9ubHkgYXBwbGllcyB0b1xuXHQgKiBKYXZhU2NyaXB0IGl0ZW1zIHRoYXQgYXJlIGJlaW5nIGxvYWRlZCB3aXRoIGEgVGFnTG9hZGVyLCBzaW5jZSB0aGV5IGhhdmUgdG8gYmUgbG9hZGVkIGFuZCBjb21wbGV0ZWQgPHN0cm9uZz5iZWZvcmU8L3N0cm9uZz5cblx0ICogdGhlIHNjcmlwdCBjYW4gZXZlbiBiZSBzdGFydGVkLCBzaW5jZSBpdCBleGlzdCBpbiB0aGUgRE9NIHdoaWxlIGxvYWRpbmcuXG5cdCAqIEBtZXRob2QgX2NhblN0YXJ0TG9hZFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXIgVGhlIGxvYWRlciBmb3IgdGhlIGl0ZW1cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgaXRlbSBjYW4gc3RhcnQgYSBsb2FkIG9yIG5vdC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NhblN0YXJ0TG9hZCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHRpZiAoIXRoaXMubWFpbnRhaW5TY3JpcHRPcmRlciB8fCBsb2FkZXIucHJlZmVyWEhSKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0dmFyIGl0ZW0gPSBsb2FkZXIuZ2V0SXRlbSgpO1xuXHRcdGlmIChpdGVtLnR5cGUgIT0gY3JlYXRlanMuTG9hZFF1ZXVlLkpBVkFTQ1JJUFQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRpZiAodGhpcy5fY3VycmVudGx5TG9hZGluZ1NjcmlwdCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciBpbmRleCA9IHRoaXMuX3NjcmlwdE9yZGVyLmluZGV4T2YoaXRlbSk7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHdoaWxlIChpIDwgaW5kZXgpIHtcblx0XHRcdHZhciBjaGVja0l0ZW0gPSB0aGlzLl9sb2FkZWRTY3JpcHRzW2ldO1xuXHRcdFx0aWYgKGNoZWNrSXRlbSA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGkrKztcblx0XHR9XG5cdFx0dGhpcy5fY3VycmVudGx5TG9hZGluZ1NjcmlwdCA9IHRydWU7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEEgbG9hZCBpdGVtIGlzIGNvbXBsZXRlZCBvciB3YXMgY2FuY2VsZWQsIGFuZCBuZWVkcyB0byBiZSByZW1vdmVkIGZyb20gdGhlIExvYWRRdWV1ZS5cblx0ICogQG1ldGhvZCBfcmVtb3ZlTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyIEEgbG9hZGVyIGluc3RhbmNlIHRvIHJlbW92ZS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX3JlbW92ZUxvYWRJdGVtID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdHZhciBsID0gdGhpcy5fY3VycmVudExvYWRzLmxlbmd0aDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuX2N1cnJlbnRMb2Fkc1tpXSA9PSBsb2FkZXIpIHtcblx0XHRcdFx0dGhpcy5fY3VycmVudExvYWRzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgdW5uZWVkZWQgcmVmZXJlbmNlcyBmcm9tIGEgbG9hZGVyLlxuXHQgKlxuXHQgKiBAcGFyYW0gbG9hZGVyXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jbGVhbkxvYWRJdGVtID0gZnVuY3Rpb24obG9hZGVyKSB7XG5cdFx0dmFyIGl0ZW0gPSBsb2FkZXIuZ2V0SXRlbSgpO1xuXHRcdGlmIChpdGVtKSB7XG5cdFx0XHRkZWxldGUgaXRlbS5fbG9hZGVyO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBbiBpdGVtIGhhcyBkaXNwYXRjaGVkIHByb2dyZXNzLiBQcm9wYWdhdGUgdGhhdCBwcm9ncmVzcywgYW5kIHVwZGF0ZSB0aGUgTG9hZFF1ZXVlJ3Mgb3ZlcmFsbCBwcm9ncmVzcy5cblx0ICogQG1ldGhvZCBfaGFuZGxlUHJvZ3Jlc3Ncblx0ICogQHBhcmFtIHtQcm9ncmVzc0V2ZW50fSBldmVudCBUaGUgcHJvZ3Jlc3MgZXZlbnQgZnJvbSB0aGUgaXRlbS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVByb2dyZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIGxvYWRlciA9IGV2ZW50LnRhcmdldDtcblx0XHR0aGlzLl9zZW5kRmlsZVByb2dyZXNzKGxvYWRlci5nZXRJdGVtKCksIGxvYWRlci5wcm9ncmVzcyk7XG5cdFx0dGhpcy5fdXBkYXRlUHJvZ3Jlc3MoKTtcblx0fTtcblxuXHQvKipcblx0ICogT3ZlcmFsbCBwcm9ncmVzcyBoYXMgY2hhbmdlZCwgc28gZGV0ZXJtaW5lIHRoZSBuZXcgcHJvZ3Jlc3MgYW1vdW50IGFuZCBkaXNwYXRjaCBpdC4gVGhpcyBjaGFuZ2VzIGFueSB0aW1lIGFuXG5cdCAqIGl0ZW0gZGlzcGF0Y2hlcyBwcm9ncmVzcyBvciBjb21wbGV0ZXMuIE5vdGUgdGhhdCBzaW5jZSB3ZSBkb24ndCBhbHdheXMga25vdyB0aGUgYWN0dWFsIGZpbGVzaXplIG9mIGl0ZW1zIGJlZm9yZVxuXHQgKiB0aGV5IGFyZSBsb2FkZWQuIEluIHRoaXMgY2FzZSwgd2UgZGVmaW5lIGEgXCJzbG90XCIgZm9yIGVhY2ggaXRlbSAoMSBpdGVtIGluIDEwIHdvdWxkIGdldCAxMCUpLCBhbmQgdGhlbiBhcHBlbmRcblx0ICogbG9hZGVkIHByb2dyZXNzIG9uIHRvcCBvZiB0aGUgYWxyZWFkeS1sb2FkZWQgaXRlbXMuXG5cdCAqXG5cdCAqIEZvciBleGFtcGxlLCBpZiA1LzEwIGl0ZW1zIGhhdmUgbG9hZGVkLCBhbmQgaXRlbSA2IGlzIDIwJSBsb2FkZWQsIHRoZSB0b3RhbCBwcm9ncmVzcyB3b3VsZCBiZTpcblx0ICogPHVsPlxuXHQgKiAgICAgIDxsaT41LzEwIG9mIHRoZSBpdGVtcyBpbiB0aGUgcXVldWUgKDUwJSk8L2xpPlxuXHQgKiAgICAgIDxsaT5wbHVzIDIwJSBvZiBpdGVtIDYncyBzbG90ICgyJSk8L2xpPlxuXHQgKiAgICAgIDxsaT5lcXVhbHMgNTIlPC9saT5cblx0ICogPC91bD5cblx0ICogQG1ldGhvZCBfdXBkYXRlUHJvZ3Jlc3Ncblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX3VwZGF0ZVByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBsb2FkZWQgPSB0aGlzLl9udW1JdGVtc0xvYWRlZCAvIHRoaXMuX251bUl0ZW1zOyAvLyBGdWxseSBMb2FkZWQgUHJvZ3Jlc3Ncblx0XHR2YXIgcmVtYWluaW5nID0gdGhpcy5fbnVtSXRlbXMgLSB0aGlzLl9udW1JdGVtc0xvYWRlZDtcblx0XHRpZiAocmVtYWluaW5nID4gMCkge1xuXHRcdFx0dmFyIGNodW5rID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY3VycmVudExvYWRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjaHVuayArPSB0aGlzLl9jdXJyZW50TG9hZHNbaV0ucHJvZ3Jlc3M7XG5cdFx0XHR9XG5cdFx0XHRsb2FkZWQgKz0gKGNodW5rIC8gcmVtYWluaW5nKSAqIChyZW1haW5pbmcgLyB0aGlzLl9udW1JdGVtcyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX2xhc3RQcm9ncmVzcyAhPSBsb2FkZWQpIHtcblx0XHRcdHRoaXMuX3NlbmRQcm9ncmVzcyhsb2FkZWQpO1xuXHRcdFx0dGhpcy5fbGFzdFByb2dyZXNzID0gbG9hZGVkO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ2xlYW4gb3V0IGl0ZW0gcmVzdWx0cywgdG8gZnJlZSB0aGVtIGZyb20gbWVtb3J5LiBNYWlubHksIHRoZSBsb2FkZWQgaXRlbSBhbmQgcmVzdWx0cyBhcmUgY2xlYXJlZCBmcm9tIGludGVybmFsXG5cdCAqIGhhc2hlcy5cblx0ICogQG1ldGhvZCBfZGlzcG9zZUl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIGl0ZW0gdGhhdCB3YXMgcGFzc2VkIGluIGZvciBwcmVsb2FkaW5nLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZGlzcG9zZUl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdGRlbGV0ZSB0aGlzLl9sb2FkZWRSZXN1bHRzW2l0ZW0uaWRdO1xuXHRcdGRlbGV0ZSB0aGlzLl9sb2FkZWRSYXdSZXN1bHRzW2l0ZW0uaWRdO1xuXHRcdGRlbGV0ZSB0aGlzLl9sb2FkSXRlbXNCeUlkW2l0ZW0uaWRdO1xuXHRcdGRlbGV0ZSB0aGlzLl9sb2FkSXRlbXNCeVNyY1tpdGVtLnNyY107XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoIGEgXCJmaWxlcHJvZ3Jlc3NcIiB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS4gUGxlYXNlIHNlZSB0aGUgTG9hZFF1ZXVlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlcHJvZ3Jlc3M6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgZm9yIGRldGFpbHMgb24gdGhlIGV2ZW50IHBheWxvYWQuXG5cdCAqIEBtZXRob2QgX3NlbmRGaWxlUHJvZ3Jlc3Ncblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIGl0ZW0gdGhhdCBpcyBiZWluZyBsb2FkZWQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwcm9ncmVzcyBUaGUgYW1vdW50IHRoZSBpdGVtIGhhcyBiZWVuIGxvYWRlZCAoYmV0d2VlbiAwIGFuZCAxKS5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2VuZEZpbGVQcm9ncmVzcyA9IGZ1bmN0aW9uIChpdGVtLCBwcm9ncmVzcykge1xuXHRcdGlmICh0aGlzLl9pc0NhbmNlbGVkKCkgfHwgdGhpcy5fcGF1c2VkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICghdGhpcy5oYXNFdmVudExpc3RlbmVyKFwiZmlsZXByb2dyZXNzXCIpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly9MTTogUmV3b3JrIFByb2dyZXNzRXZlbnQgdG8gc3VwcG9ydCB0aGlzP1xuXHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVwcm9ncmVzc1wiKTtcblx0XHRldmVudC5wcm9ncmVzcyA9IHByb2dyZXNzO1xuXHRcdGV2ZW50LmxvYWRlZCA9IHByb2dyZXNzO1xuXHRcdGV2ZW50LnRvdGFsID0gMTtcblx0XHRldmVudC5pdGVtID0gaXRlbTtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoIGEgZmlsZWxvYWQge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBmb3Jcblx0ICogZGV0YWlscyBvbiB0aGUgZXZlbnQgcGF5bG9hZC5cblx0ICogQG1ldGhvZCBfc2VuZEZpbGVDb21wbGV0ZVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtT2JqZWN0fSBpdGVtIFRoZSBpdGVtIHRoYXQgaXMgYmVpbmcgbG9hZGVkLlxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2VuZEZpbGVDb21wbGV0ZSA9IGZ1bmN0aW9uIChpdGVtLCBsb2FkZXIpIHtcblx0XHRpZiAodGhpcy5faXNDYW5jZWxlZCgpIHx8IHRoaXMuX3BhdXNlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVsb2FkXCIpO1xuXHRcdGV2ZW50LmxvYWRlciA9IGxvYWRlcjtcblx0XHRldmVudC5pdGVtID0gaXRlbTtcblx0XHRldmVudC5yZXN1bHQgPSB0aGlzLl9sb2FkZWRSZXN1bHRzW2l0ZW0uaWRdO1xuXHRcdGV2ZW50LnJhd1Jlc3VsdCA9IHRoaXMuX2xvYWRlZFJhd1Jlc3VsdHNbaXRlbS5pZF07XG5cblx0XHQvLyBUaGlzIGNhbGxzIGEgaGFuZGxlciBzcGVjaWZpZWQgb24gdGhlIGFjdHVhbCBsb2FkIGl0ZW0uIEN1cnJlbnRseSwgdGhlIFNvdW5kSlMgcGx1Z2luIHVzZXMgdGhpcy5cblx0XHRpZiAoaXRlbS5jb21wbGV0ZUhhbmRsZXIpIHtcblx0XHRcdGl0ZW0uY29tcGxldGVIYW5kbGVyKGV2ZW50KTtcblx0XHR9XG5cblx0XHR0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJmaWxlbG9hZFwiKSAmJiB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhIGZpbGVzdGFydCB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSBpbW1lZGlhdGVseSBiZWZvcmUgYSBmaWxlIHN0YXJ0cyB0byBsb2FkLiBQbGVhc2Ugc2VlXG5cdCAqIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZXN0YXJ0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IGZvciBkZXRhaWxzIG9uIHRoZSBldmVudCBwYXlsb2FkLlxuXHQgKiBAbWV0aG9kIF9zZW5kRmlsZVN0YXJ0XG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBpdGVtIHRoYXQgaXMgYmVpbmcgbG9hZGVkLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZW5kRmlsZVN0YXJ0ID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJmaWxlc3RhcnRcIik7XG5cdFx0ZXZlbnQuaXRlbSA9IGl0ZW07XG5cdFx0dGhpcy5oYXNFdmVudExpc3RlbmVyKFwiZmlsZXN0YXJ0XCIpICYmIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbUHJlbG9hZEpTIExvYWRRdWV1ZV1cIjtcblx0fTtcblxuXHRjcmVhdGVqcy5Mb2FkUXVldWUgPSBjcmVhdGVqcy5wcm9tb3RlKExvYWRRdWV1ZSwgXCJBYnN0cmFjdExvYWRlclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUZXh0TG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIFRleHQgZmlsZXMuXG5cdCAqIEBjbGFzcyBUZXh0TG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFRleHRMb2FkZXIobG9hZEl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCB0cnVlLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5URVhUKTtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChUZXh0TG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gVGV4dExvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgbG9hZHMgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9URVhUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBidXQgaXMgYWxzbyB0aGUgZGVmYXVsdCBsb2FkZXIgaWYgYSBmaWxlIHR5cGUgY2FuIG5vdCBiZSBkZXRlcm1pbmVkLlxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlRFWFQ7XG5cdH07XG5cblx0Y3JlYXRlanMuVGV4dExvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoVGV4dExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEJpbmFyeUxvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBiaW5hcnkgZmlsZXMuIFRoaXMgaXMgdXNlZnVsIGZvciBsb2FkaW5nIHdlYiBhdWRpbywgb3IgY29udGVudCB0aGF0IHJlcXVpcmVzIGFuIEFycmF5QnVmZmVyLlxuXHQgKiBAY2xhc3MgQmluYXJ5TG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEJpbmFyeUxvYWRlcihsb2FkSXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHRydWUsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkJJTkFSWSk7XG5cdFx0dGhpcy5vbihcImluaXRpYWxpemVcIiwgdGhpcy5fdXBkYXRlWEhSLCB0aGlzKTtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChCaW5hcnlMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBCaW5hcnlMb2FkZXI7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9CSU5BUlk6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5CSU5BUlk7XG5cdH07XG5cblx0Ly8gcHJpdmF0ZSBtZXRob2RzXG5cdC8qKlxuXHQgKiBCZWZvcmUgdGhlIGl0ZW0gbG9hZHMsIHNldCB0aGUgcmVzcG9uc2UgdHlwZSB0byBcImFycmF5YnVmZmVyXCJcblx0ICogQHByb3BlcnR5IF91cGRhdGVYSFJcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX3VwZGF0ZVhIUiA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LmxvYWRlci5zZXRSZXNwb25zZVR5cGUoXCJhcnJheWJ1ZmZlclwiKTtcblx0fTtcblxuXHRjcmVhdGVqcy5CaW5hcnlMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEJpbmFyeUxvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIENTU0xvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBDU1MgZmlsZXMuXG5cdCAqIEBjbGFzcyBDU1NMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZmVyWEhSXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gQ1NTTG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkNTUyk7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBcImhyZWZcIjtcblxuXHRcdGlmIChwcmVmZXJYSFIpIHtcblx0XHRcdHRoaXMuX3RhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdGFnLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXHRcdHRoaXMuX3RhZy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKENTU0xvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IENTU0xvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0NTUzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5DU1M7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBDU1MgZmlsZXMuXG5cdCAqIEBtZXRob2QgX2Zvcm1hdFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHJldHVybnMge0hUTUxMaW5rRWxlbWVudHxIVE1MU3R5bGVFbGVtZW50fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZm9ybWF0UmVzdWx0ID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdGlmICh0aGlzLl9wcmVmZXJYSFIpIHtcblx0XHRcdHZhciB0YWcgPSBsb2FkZXIuZ2V0VGFnKCk7XG5cblx0XHRcdGlmICh0YWcuc3R5bGVTaGVldCkgeyAvLyBJRVxuXHRcdFx0XHR0YWcuc3R5bGVTaGVldC5jc3NUZXh0ID0gbG9hZGVyLmdldFJlc3VsdCh0cnVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxvYWRlci5nZXRSZXN1bHQodHJ1ZSkpO1xuXHRcdFx0XHR0YWcuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YWcgPSB0aGlzLl90YWc7XG5cdFx0fVxuXG5cdFx0Y3JlYXRlanMuRG9tVXRpbHMuYXBwZW5kVG9IZWFkKHRhZyk7XG5cblx0XHRyZXR1cm4gdGFnO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkNTU0xvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoQ1NTTG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gSW1hZ2VMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgaW1hZ2UgZmlsZXMuXG5cdCAqIEBjbGFzcyBJbWFnZUxvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXJYSFJcblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBJbWFnZUxvYWRlciAobG9hZEl0ZW0sIHByZWZlclhIUikge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSU1BR0UpO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHR0aGlzLnJlc3VsdEZvcm1hdHRlciA9IHRoaXMuX2Zvcm1hdFJlc3VsdDtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5fdGFnU3JjQXR0cmlidXRlID0gXCJzcmNcIjtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBwcmVsb2FkIGl0ZW0gaXMgYWxyZWFkeSBhIHRhZy5cblx0XHRpZiAoY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzSW1hZ2VUYWcobG9hZEl0ZW0pKSB7XG5cdFx0XHR0aGlzLl90YWcgPSBsb2FkSXRlbTtcblx0XHR9IGVsc2UgaWYgKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0ltYWdlVGFnKGxvYWRJdGVtLnNyYykpIHtcblx0XHRcdHRoaXMuX3RhZyA9IGxvYWRJdGVtLnNyYztcblx0XHR9IGVsc2UgaWYgKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0ltYWdlVGFnKGxvYWRJdGVtLnRhZykpIHtcblx0XHRcdHRoaXMuX3RhZyA9IGxvYWRJdGVtLnRhZztcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fdGFnICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3ByZWZlclhIUiA9IGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl90YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuXHRcdH1cblxuXHRcdHRoaXMub24oXCJpbml0aWFsaXplXCIsIHRoaXMuX3VwZGF0ZVhIUiwgdGhpcyk7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoSW1hZ2VMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBJbWFnZUxvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0lNQUdFOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLklNQUdFO1xuXHR9O1xuXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdGFnLnNyYyAhPSBcIlwiICYmIHRoaXMuX3RhZy5jb21wbGV0ZSkge1xuXHRcdFx0dGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGNyb3NzT3JpZ2luID0gdGhpcy5faXRlbS5jcm9zc09yaWdpbjtcblx0XHRpZiAoY3Jvc3NPcmlnaW4gPT0gdHJ1ZSkgeyBjcm9zc09yaWdpbiA9IFwiQW5vbnltb3VzXCI7IH1cblx0XHRpZiAoY3Jvc3NPcmlnaW4gIT0gbnVsbCAmJiAhY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzTG9jYWwodGhpcy5faXRlbS5zcmMpKSB7XG5cdFx0XHR0aGlzLl90YWcuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblx0XHR9XG5cblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2xvYWQoKTtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogQmVmb3JlIHRoZSBpdGVtIGxvYWRzLCBzZXQgaXRzIG1pbWVUeXBlIGFuZCByZXNwb25zZVR5cGUuXG5cdCAqIEBwcm9wZXJ0eSBfdXBkYXRlWEhSXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl91cGRhdGVYSFIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC5sb2FkZXIubWltZVR5cGUgPSAndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZC1iaW5hcnknO1xuXG5cdFx0Ly8gT25seSBleGlzdHMgZm9yIFhIUlxuXHRcdGlmIChldmVudC5sb2FkZXIuc2V0UmVzcG9uc2VUeXBlKSB7XG5cdFx0XHRldmVudC5sb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYmxvYlwiKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBJbWFnZSBmaWxlcy5cblx0ICogQG1ldGhvZCBfZm9ybWF0UmVzdWx0XG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcmV0dXJucyB7SFRNTEltYWdlRWxlbWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5fZm9ybWF0SW1hZ2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBhc3luY2hyb25vdXMgaW1hZ2UgZm9ybWF0dGVyIGZ1bmN0aW9uLiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgaW1hZ2VzIGhhdmVcblx0ICogYSBzaG9ydCBkZWxheSBiZWZvcmUgdGhleSBhcmUgcmVhZHkuXG5cdCAqIEBtZXRob2QgX2Zvcm1hdEltYWdlXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3NDYWxsYmFjayBUaGUgbWV0aG9kIHRvIGNhbGwgd2hlbiB0aGUgcmVzdWx0IGhhcyBmaW5pc2hlZCBmb3JtYXR0aW5nXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yQ2FsbGJhY2sgVGhlIG1ldGhvZCB0byBjYWxsIGlmIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgZm9ybWF0dGluZ1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZm9ybWF0SW1hZ2UgPSBmdW5jdGlvbiAoc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG5cdFx0dmFyIHRhZyA9IHRoaXMuX3RhZztcblx0XHR2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xuXG5cdFx0aWYgKCF0aGlzLl9wcmVmZXJYSFIpIHtcblx0XHRcdC8vZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0YWcpO1xuXHRcdH0gZWxzZSBpZiAoVVJMKSB7XG5cdFx0XHR2YXIgb2JqVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh0aGlzLmdldFJlc3VsdCh0cnVlKSk7XG5cdFx0XHR0YWcuc3JjID0gb2JqVVJMO1xuXG5cdFx0XHR0YWcuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdGhpcy5fY2xlYW5VcFVSTCwgZmFsc2UpO1xuXHRcdFx0dGFnLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLl9jbGVhblVwVVJMLCBmYWxzZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhZy5zcmMgPSB0aGlzLl9pdGVtLnNyYztcblx0XHR9XG5cblx0XHRpZiAodGFnLmNvbXBsZXRlKSB7XG5cdFx0XHRzdWNjZXNzQ2FsbGJhY2sodGFnKTtcblx0XHR9IGVsc2Uge1xuICAgICAgICAgICAgdGFnLm9ubG9hZCA9IGNyZWF0ZWpzLnByb3h5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayh0aGlzLl90YWcpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHRhZy5vbmVycm9yID0gY3JlYXRlanMucHJveHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhfdGhpcy5fdGFnKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ2xlYW4gdXAgdGhlIE9iamVjdFVSTCwgdGhlIHRhZyBpcyBkb25lIHdpdGggaXQuIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIHJ1blxuXHQgKiBhcyBhbiBldmVudCBsaXN0ZW5lciB3aXRob3V0IGEgcHJveHkvY2xvc3VyZSwgYXMgaXQgZG9lc24ndCByZXF1aXJlIGl0IC0gc28gZG8gbm90XG5cdCAqIGluY2x1ZGUgYW55IGZ1bmN0aW9uYWxpdHkgdGhhdCByZXF1aXJlcyBzY29wZSB3aXRob3V0IGNoYW5naW5nIGl0LlxuXHQgKiBAbWV0aG9kIF9jbGVhblVwVVJMXG5cdCAqIEBwYXJhbSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY2xlYW5VcFVSTCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XG5cdFx0VVJMLnJldm9rZU9iamVjdFVSTChldmVudC50YXJnZXQuc3JjKTtcblx0fTtcblxuXHRjcmVhdGVqcy5JbWFnZUxvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoSW1hZ2VMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBKYXZhU2NyaXB0TG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIEphdmFTY3JpcHQgZmlsZXMuXG5cdCAqIEBjbGFzcyBKYXZhU2NyaXB0TG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZlclhIUlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEphdmFTY3JpcHRMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUikge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSkFWQVNDUklQVCk7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBcInNyY1wiO1xuXHRcdHRoaXMuc2V0VGFnKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEphdmFTY3JpcHRMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBKYXZhU2NyaXB0TG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSkFWQVNDUklQVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpBVkFTQ1JJUFQ7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBKYXZhU2NyaXB0IGZpbGVzLlxuXHQgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEByZXR1cm5zIHtIVE1MTGlua0VsZW1lbnR8SFRNTFN0eWxlRWxlbWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHR2YXIgdGFnID0gbG9hZGVyLmdldFRhZygpO1xuXHRcdGlmICh0aGlzLl9wcmVmZXJYSFIpIHtcblx0XHRcdHRhZy50ZXh0ID0gbG9hZGVyLmdldFJlc3VsdCh0cnVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRhZztcblx0fTtcblxuXHRjcmVhdGVqcy5KYXZhU2NyaXB0TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShKYXZhU2NyaXB0TG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gSlNPTkxvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBKU09OIGZpbGVzLiBUbyBsb2FkIEpTT04gY3Jvc3MtZG9tYWluLCB1c2UgSlNPTlAgYW5kIHRoZSB7eyNjcm9zc0xpbmsgXCJKU09OUExvYWRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBpbnN0ZWFkLiBUbyBsb2FkIEpTT04tZm9ybWF0dGVkIG1hbmlmZXN0cywgdXNlIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQgdG9cblx0ICogbG9hZCBFYXNlbEpTIFNwcml0ZVNoZWV0cywgdXNlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAY2xhc3MgSlNPTkxvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBKU09OTG9hZGVyKGxvYWRJdGVtKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgdHJ1ZSwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSlNPTik7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEpTT05Mb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBKU09OTG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSlNPTjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KU09OO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdC8qKlxuXHQgKiBUaGUgcmVzdWx0IGZvcm1hdHRlciBmb3IgSlNPTiBmaWxlcy5cblx0ICogQG1ldGhvZCBfZm9ybWF0UmVzdWx0XG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcmV0dXJucyB7SFRNTExpbmtFbGVtZW50fEhUTUxTdHlsZUVsZW1lbnR9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9mb3JtYXRSZXN1bHQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0dmFyIGpzb24gPSBudWxsO1xuXHRcdHRyeSB7XG5cdFx0XHRqc29uID0gY3JlYXRlanMuRGF0YVV0aWxzLnBhcnNlSlNPTihsb2FkZXIuZ2V0UmVzdWx0KHRydWUpKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIkpTT05fRk9STUFUXCIsIG51bGwsIGUpO1xuXHRcdFx0dGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcblx0XHRcdHJldHVybiBlO1xuXHRcdH1cblxuXHRcdHJldHVybiBqc29uO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkpTT05Mb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEpTT05Mb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBKU09OUExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBKU09OUCBmaWxlcywgd2hpY2ggYXJlIEpTT04tZm9ybWF0dGVkIHRleHQgZmlsZXMsIHdyYXBwZWQgaW4gYSBjYWxsYmFjay4gVG8gbG9hZCByZWd1bGFyIEpTT05cblx0ICogd2l0aG91dCBhIGNhbGxiYWNrIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiSlNPTkxvYWRlclwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLiBUbyBsb2FkIEpTT04tZm9ybWF0dGVkIG1hbmlmZXN0cyxcblx0ICogdXNlIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQgdG8gbG9hZCBFYXNlbEpTIFNwcml0ZVNoZWV0cywgdXNlXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiBKU09OUCBpcyBhIGZvcm1hdCB0aGF0IHByb3ZpZGVzIGEgc29sdXRpb24gZm9yIGxvYWRpbmcgSlNPTiBmaWxlcyBjcm9zcy1kb21haW4gPGVtPndpdGhvdXQ8L2VtPiByZXF1aXJpbmcgQ09SUy5cblx0ICogSlNPTlAgZmlsZXMgYXJlIGxvYWRlZCBhcyBKYXZhU2NyaXB0LCBhbmQgdGhlIFwiY2FsbGJhY2tcIiBpcyBleGVjdXRlZCBvbmNlIHRoZXkgYXJlIGxvYWRlZC4gVGhlIGNhbGxiYWNrIGluIHRoZVxuXHQgKiBKU09OUCBtdXN0IG1hdGNoIHRoZSBjYWxsYmFjayBwYXNzZWQgdG8gdGhlIGxvYWRJdGVtLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZSBKU09OUDwvaDQ+XG5cdCAqXG5cdCAqIFx0XHRjYWxsYmFja05hbWUoe1xuXHQgKiBcdFx0XHRcIm5hbWVcIjogXCJ2YWx1ZVwiLFxuXHQgKlx0IFx0XHRcIm51bVwiOiAzLFxuXHQgKlx0XHRcdFwib2JqXCI6IHsgXCJib29sXCI6dHJ1ZSB9XG5cdCAqIFx0XHR9KTtcblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiBcdFx0dmFyIGxvYWRJdGVtID0ge2lkOlwianNvblwiLCB0eXBlOlwianNvbnBcIiwgc3JjOlwiaHR0cDovL3NlcnZlci5jb20vdGV4dC5qc29uXCIsIGNhbGxiYWNrOlwiY2FsbGJhY2tOYW1lXCJ9XG5cdCAqIFx0XHR2YXIgcXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG5cdCAqIFx0XHRxdWV1ZS5vbihcImNvbXBsZXRlXCIsIGhhbmRsZUNvbXBsZXRlKTtcblx0ICogXHRcdHF1ZXVlLmxvYWRJdGVtKGxvYWRJdGVtKTtcblx0ICpcblx0ICogXHRcdGZ1bmN0aW9uIGhhbmRsZUNvbXBsZXRlKGV2ZW50KSB9XG5cdCAqIFx0XHRcdHZhciBqc29uID0gcXVldWUuZ2V0UmVzdWx0KFwianNvblwiKTtcblx0ICogXHRcdFx0Y29uc29sZS5sb2coanNvbi5vYmouYm9vbCk7IC8vIHRydWVcblx0ICogXHRcdH1cblx0ICpcblx0ICogTm90ZSB0aGF0IEpTT05QIGZpbGVzIGxvYWRlZCBjb25jdXJyZW50bHkgcmVxdWlyZSBhIDxlbT51bmlxdWU8L2VtPiBjYWxsYmFjay4gVG8gZW5zdXJlIEpTT05QIGZpbGVzIGFyZSBsb2FkZWRcblx0ICogaW4gb3JkZXIsIGVpdGhlciB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRNYXhDb25uZWN0aW9uc1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgKHNldCB0byAxKSxcblx0ICogb3Igc2V0IHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL21haW50YWluT3JkZXI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gb24gaXRlbXMgd2l0aCB0aGUgc2FtZSBjYWxsYmFjay5cblx0ICpcblx0ICogQGNsYXNzIEpTT05QTG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEpTT05QTG9hZGVyKGxvYWRJdGVtKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgZmFsc2UsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpTT05QKTtcblx0XHR0aGlzLnNldFRhZyhkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKTtcblx0XHR0aGlzLmdldFRhZygpLnR5cGUgPSBcInRleHQvamF2YXNjcmlwdFwiO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEpTT05QTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gSlNPTlBMb2FkZXI7XG5cblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pTT05QOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpTT05QO1xuXHR9O1xuXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdHAuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY2FuY2VsKCk7XG5cdFx0dGhpcy5fZGlzcG9zZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBMb2FkcyB0aGUgSlNPTnAgZmlsZS4gIEJlY2F1c2Ugb2YgdGhlIHVuaXF1ZSBsb2FkaW5nIG5lZWRzIG9mIEpTT05wXG5cdCAqIHdlIGRvbid0IHVzZSB0aGUgQWJzdHJhY3RMb2FkZXIubG9hZCgpIG1ldGhvZC5cblx0ICpcblx0ICogQG1ldGhvZCBsb2FkXG5cdCAqXG5cdCAqL1xuXHRwLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2l0ZW0uY2FsbGJhY2sgPT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdjYWxsYmFjayBpcyByZXF1aXJlZCBmb3IgbG9hZGluZyBKU09OUCByZXF1ZXN0cy4nKTtcblx0XHR9XG5cblx0XHQvLyBUT0RPOiBMb29rIGludG8gY3JlYXRpbmcgb3VyIG93biBpRnJhbWUgdG8gaGFuZGxlIHRoZSBsb2FkXG5cdFx0Ly8gSW4gdGhlIGZpcnN0IGF0dGVtcHQsIEZGIGRpZCBub3QgZ2V0IHRoZSByZXN1bHRcblx0XHQvLyAgIHJlc3VsdCBpbnN0YW5jZW9mIE9iamVjdCBkaWQgbm90IHdvcmsgZWl0aGVyXG5cdFx0Ly8gICBzbyB3ZSB3b3VsZCBuZWVkIHRvIGNsb25lIHRoZSByZXN1bHQuXG5cdFx0aWYgKHdpbmRvd1t0aGlzLl9pdGVtLmNhbGxiYWNrXSAhPSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFwiSlNPTlAgY2FsbGJhY2sgJ1wiICtcblx0XHRcdFx0dGhpcy5faXRlbS5jYWxsYmFjayArXG5cdFx0XHRcdFwiJyBhbHJlYWR5IGV4aXN0cyBvbiB3aW5kb3cuIFlvdSBuZWVkIHRvIHNwZWNpZnkgYSBkaWZmZXJlbnQgY2FsbGJhY2sgb3IgcmUtbmFtZSB0aGUgY3VycmVudCBvbmUuXCIpO1xuXHRcdH1cblxuXHRcdHdpbmRvd1t0aGlzLl9pdGVtLmNhbGxiYWNrXSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZUxvYWQsIHRoaXMpO1xuXHRcdHdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX3RhZyk7XG5cblx0XHR0aGlzLl9sb2FkVGltZW91dCA9IHNldFRpbWVvdXQoY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlVGltZW91dCwgdGhpcyksIHRoaXMuX2l0ZW0ubG9hZFRpbWVvdXQpO1xuXG5cdFx0Ly8gTG9hZCB0aGUgdGFnXG5cdFx0dGhpcy5fdGFnLnNyYyA9IHRoaXMuX2l0ZW0uc3JjO1xuXHR9O1xuXG5cdC8vIHByaXZhdGUgbWV0aG9kc1xuXHQvKipcblx0ICogSGFuZGxlIHRoZSBKU09OUCBjYWxsYmFjaywgd2hpY2ggaXMgYSBwdWJsaWMgbWV0aG9kIGRlZmluZWQgb24gYHdpbmRvd2AuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUxvYWRcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGZvcm1hdHRlZCBKU09OIGRhdGEuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVMb2FkID0gZnVuY3Rpb24gKGRhdGEpIHtcblx0XHR0aGlzLl9yZXN1bHQgPSB0aGlzLl9yYXdSZXN1bHQgPSBkYXRhO1xuXHRcdHRoaXMuX3NlbmRDb21wbGV0ZSgpO1xuXG5cdFx0dGhpcy5fZGlzcG9zZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgdGFnIHJlcXVlc3QgaGFzIG5vdCBsb2FkZWQgd2l0aGluIHRoZSB0aW1lIHNwZWNmaWVkIGluIGxvYWRUaW1lb3V0LlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVFcnJvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIFhIUiBlcnJvciBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZGlzcG9zZSgpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcInRpbWVvdXRcIikpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiB1cCB0aGUgSlNPTlAgbG9hZC4gVGhpcyBjbGVhcnMgb3V0IHRoZSBjYWxsYmFjayBhbmQgc2NyaXB0IHRhZyB0aGF0IHRoaXMgbG9hZGVyIGNyZWF0ZXMuXG5cdCAqIEBtZXRob2QgX2Rpc3Bvc2Vcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Rpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0d2luZG93LmRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5fdGFnKTtcblx0XHRkZWxldGUgd2luZG93W3RoaXMuX2l0ZW0uY2FsbGJhY2tdO1xuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2xvYWRUaW1lb3V0KTtcblx0fTtcblxuXHRjcmVhdGVqcy5KU09OUExvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoSlNPTlBMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBNYW5pZmVzdExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBKU09OIG1hbmlmZXN0cy4gSXRlbXMgaW5zaWRlIHRoZSBtYW5pZmVzdCBhcmUgbG9hZGVkIGJlZm9yZSB0aGUgbG9hZGVyIGNvbXBsZXRlcy4gVG8gbG9hZCBtYW5pZmVzdHNcblx0ICogdXNpbmcgSlNPTlAsIHNwZWNpZnkgYSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS9jYWxsYmFjazpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBhcyBwYXJ0IG9mIHRoZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogVGhlIGxpc3Qgb2YgZmlsZXMgaW4gdGhlIG1hbmlmZXN0IG11c3QgYmUgZGVmaW5lZCBvbiB0aGUgdG9wLWxldmVsIEpTT04gb2JqZWN0IGluIGEgYG1hbmlmZXN0YCBwcm9wZXJ0eS4gVGhpc1xuXHQgKiBleGFtcGxlIHNob3dzIGEgc2FtcGxlIG1hbmlmZXN0IGRlZmluaXRpb24sIGFzIHdlbGwgYXMgaG93IHRvIHRvIGluY2x1ZGUgYSBzdWItbWFuaWZlc3QuXG5cdCAqXG5cdCAqIFx0XHR7XG5cdCAqIFx0XHRcdFwicGF0aFwiOiBcImFzc2V0cy9cIixcblx0ICpcdCBcdCAgICBcIm1hbmlmZXN0XCI6IFtcblx0ICpcdFx0XHRcdFwiaW1hZ2UucG5nXCIsXG5cdCAqXHRcdFx0XHR7XCJzcmNcIjogXCJpbWFnZTIucG5nXCIsIFwiaWRcIjpcImltYWdlMlwifSxcblx0ICpcdFx0XHRcdHtcInNyY1wiOiBcInN1Yi1tYW5pZmVzdC5qc29uXCIsIFwidHlwZVwiOlwibWFuaWZlc3RcIiwgXCJjYWxsYmFja1wiOlwianNvbkNhbGxiYWNrXCJ9XG5cdCAqXHQgXHQgICAgXVxuXHQgKlx0IFx0fVxuXHQgKlxuXHQgKiBXaGVuIGEgTWFuaWZlc3RMb2FkZXIgaGFzIGNvbXBsZXRlZCBsb2FkaW5nLCB0aGUgcGFyZW50IGxvYWRlciAodXN1YWxseSBhIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogYnV0IGNvdWxkIGFsc28gYmUgYW5vdGhlciBNYW5pZmVzdExvYWRlcikgd2lsbCBpbmhlcml0IGFsbCB0aGUgbG9hZGVkIGl0ZW1zLCBzbyB5b3UgY2FuIGFjY2VzcyB0aGVtIGRpcmVjdGx5LlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIHt7I2Nyb3NzTGluayBcIkpTT05Mb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkpTT05QTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGFyZVxuXHQgKiBoaWdoZXIgcHJpb3JpdHkgbG9hZGVycywgc28gbWFuaWZlc3RzIDxzdHJvbmc+bXVzdDwvc3Ryb25nPiBzZXQgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL3R5cGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgdG8ge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvTUFOSUZFU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBjbGFzcyBNYW5pZmVzdExvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBNYW5pZmVzdExvYWRlcihsb2FkSXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIG51bGwsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLk1BTklGRVNUKTtcblxuXHQvLyBQdWJsaWMgUHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IG9mIHRoZSBwbHVnaW5zIHJlZ2lzdGVyZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2luc3RhbGxQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0sXG5cdFx0ICogdXNlZCB0byBwYXNzIHBsdWdpbnMgdG8gbmV3IExvYWRRdWV1ZXMgdGhhdCBtYXkgYmUgY3JlYXRlZC5cblx0XHQgKiBAcHJvcGVydHkgX3BsdWdpbnNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAc2luY2UgMC42LjFcblx0XHQgKi9cblx0XHR0aGlzLnBsdWdpbnMgPSBudWxsO1xuXG5cblx0Ly8gUHJvdGVjdGVkIFByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBBbiBpbnRlcm5hbCB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBsb2FkcyB0aGUgY29udGVudHMgb2YgdGhlIG1hbmlmZXN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBfbWFuaWZlc3RRdWV1ZVxuXHRcdCAqIEB0eXBlIHtMb2FkUXVldWV9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9tYW5pZmVzdFF1ZXVlID0gbnVsbDtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChNYW5pZmVzdExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IE1hbmlmZXN0TG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBwcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBUaGUgYW1vdW50IG9mIHByb2dyZXNzIHRoYXQgdGhlIG1hbmlmZXN0IGl0c2VsZiB0YWtlcyB1cC5cblx0ICogQHByb3BlcnR5IE1BTklGRVNUX1BST0dSRVNTXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDAuMjUgKDI1JSlcblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5NQU5JRkVTVF9QUk9HUkVTUyA9IDAuMjU7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9NQU5JRkVTVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLk1BTklGRVNUO1xuXHR9O1xuXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2xvYWQoKTtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHRwLl9jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gdGhpcy5faXRlbS5jYWxsYmFjaztcblx0XHRpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5KU09OUExvYWRlcih0aGlzLl9pdGVtKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5KU09OTG9hZGVyKHRoaXMuX2l0ZW0pO1xuXHRcdH1cblx0fTtcblxuXHRwLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0c3dpdGNoIChldmVudC50eXBlKSB7XG5cdFx0XHRjYXNlIFwiY29tcGxldGVcIjpcblx0XHRcdFx0dGhpcy5fcmF3UmVzdWx0ID0gZXZlbnQudGFyZ2V0LmdldFJlc3VsdCh0cnVlKTtcblx0XHRcdFx0dGhpcy5fcmVzdWx0ID0gZXZlbnQudGFyZ2V0LmdldFJlc3VsdCgpO1xuXHRcdFx0XHR0aGlzLl9zZW5kUHJvZ3Jlc3Mocy5NQU5JRkVTVF9QUk9HUkVTUyk7XG5cdFx0XHRcdHRoaXMuX2xvYWRNYW5pZmVzdCh0aGlzLl9yZXN1bHQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRjYXNlIFwicHJvZ3Jlc3NcIjpcblx0XHRcdFx0ZXZlbnQubG9hZGVkICo9IHMuTUFOSUZFU1RfUFJPR1JFU1M7XG5cdFx0XHRcdHRoaXMucHJvZ3Jlc3MgPSBldmVudC5sb2FkZWQgLyBldmVudC50b3RhbDtcblx0XHRcdFx0aWYgKGlzTmFOKHRoaXMucHJvZ3Jlc3MpIHx8IHRoaXMucHJvZ3Jlc3MgPT0gSW5maW5pdHkpIHsgdGhpcy5wcm9ncmVzcyA9IDA7IH1cblx0XHRcdFx0dGhpcy5fc2VuZFByb2dyZXNzKGV2ZW50KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2hhbmRsZUV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHRwLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2Rlc3Ryb3koKTtcblx0XHR0aGlzLl9tYW5pZmVzdFF1ZXVlLmNsb3NlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhbmQgbG9hZCB0aGUgbWFuaWZlc3QgaXRlbXMgb25jZSB0aGUgYWN0dWFsIG1hbmlmZXN0IGhhcyBiZWVuIGxvYWRlZC5cblx0ICogQG1ldGhvZCBfbG9hZE1hbmlmZXN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBqc29uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9sb2FkTWFuaWZlc3QgPSBmdW5jdGlvbiAoanNvbikge1xuXHRcdGlmIChqc29uICYmIGpzb24ubWFuaWZlc3QpIHtcblx0XHRcdHZhciBxdWV1ZSA9IHRoaXMuX21hbmlmZXN0UXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG5cdFx0XHRxdWV1ZS5vbihcImZpbGVsb2FkXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0RmlsZUxvYWQsIHRoaXMpO1xuXHRcdFx0cXVldWUub24oXCJwcm9ncmVzc1wiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdFByb2dyZXNzLCB0aGlzKTtcblx0XHRcdHF1ZXVlLm9uKFwiY29tcGxldGVcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RDb21wbGV0ZSwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRxdWV1ZS5vbihcImVycm9yXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0RXJyb3IsIHRoaXMsIHRydWUpO1xuXHRcdFx0Zm9yKHZhciBpID0gMCwgbCA9IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcdC8vIGNvbnNlcnZlIG9yZGVyIG9mIHBsdWdpbnNcblx0XHRcdFx0cXVldWUuaW5zdGFsbFBsdWdpbih0aGlzLnBsdWdpbnNbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cXVldWUubG9hZE1hbmlmZXN0KGpzb24pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zZW5kQ29tcGxldGUoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEFuIGl0ZW0gZnJvbSB0aGUge3sjY3Jvc3NMaW5rIFwiX21hbmlmZXN0UXVldWU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaGFzIGNvbXBsZXRlZC5cblx0ICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RGaWxlTG9hZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RGaWxlTG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LnRhcmdldCA9IG51bGw7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG1hbmlmZXN0IGhhcyBjb21wbGV0ZWQgbG9hZGluZy4gVGhpcyB0cmlnZ2VycyB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvY29tcGxldGU6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZnJvbSB0aGUgTWFuaWZlc3RMb2FkZXIuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0Q29tcGxldGVcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZU1hbmlmZXN0Q29tcGxldGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLl9sb2FkZWRJdGVtcyA9IHRoaXMuX21hbmlmZXN0UXVldWUuZ2V0SXRlbXModHJ1ZSk7XG5cdFx0dGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBtYW5pZmVzdCBoYXMgcmVwb3J0ZWQgcHJvZ3Jlc3MuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0UHJvZ3Jlc3Ncblx0ICogQHBhcmFtIHtQcm9ncmVzc0V2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RQcm9ncmVzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSBldmVudC5wcm9ncmVzcyAqICgxIC0gcy5NQU5JRkVTVF9QUk9HUkVTUykgKyBzLk1BTklGRVNUX1BST0dSRVNTO1xuXHRcdHRoaXMuX3NlbmRQcm9ncmVzcyh0aGlzLnByb2dyZXNzKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG1hbmlmZXN0IGhhcyByZXBvcnRlZCBhbiBlcnJvciB3aXRoIG9uZSBvZiB0aGUgZmlsZXMuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0RXJyb3Jcblx0ICogQHBhcmFtIHtFcnJvckV2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVlcnJvclwiKTtcblx0XHRuZXdFdmVudC5pdGVtID0gZXZlbnQuZGF0YTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLk1hbmlmZXN0TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShNYW5pZmVzdExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNvdW5kTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIEhUTUwgYXVkaW8gZmlsZXMuIFByZWxvYWRKUyBjYW4gbm90IGxvYWQgV2ViQXVkaW8gZmlsZXMsIGFzIGEgV2ViQXVkaW8gY29udGV4dCBpcyByZXF1aXJlZCwgd2hpY2hcblx0ICogc2hvdWxkIGJlIGNyZWF0ZWQgYnkgZWl0aGVyIGEgbGlicmFyeSBwbGF5aW5nIHRoZSBzb3VuZCAoc3VjaCBhcyA8YSBocmVmPVwiaHR0cDovL3NvdW5kanMuY29tXCI+U291bmRKUzwvYT4sIG9yIGFuXG5cdCAqIGV4dGVybmFsIGZyYW1ld29yayB0aGF0IGhhbmRsZXMgYXVkaW8gcGxheWJhY2suIFRvIGxvYWQgY29udGVudCB0aGF0IGNhbiBiZSBwbGF5ZWQgYnkgV2ViQXVkaW8sIHVzZSB0aGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQmluYXJ5TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQgaGFuZGxlIHRoZSBhdWRpbyBjb250ZXh0IGRlY29kaW5nIG1hbnVhbGx5LlxuXHQgKiBAY2xhc3MgU291bmRMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZmVyWEhSXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TWVkaWFMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBTb3VuZExvYWRlcihsb2FkSXRlbSwgcHJlZmVyWEhSKSB7XG5cdFx0dGhpcy5BYnN0cmFjdE1lZGlhTG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNPVU5EKTtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0aWYgKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0F1ZGlvVGFnKGxvYWRJdGVtKSkge1xuXHRcdFx0dGhpcy5fdGFnID0gbG9hZEl0ZW07XG5cdFx0fSBlbHNlIGlmIChjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNBdWRpb1RhZyhsb2FkSXRlbS5zcmMpKSB7XG5cdFx0XHR0aGlzLl90YWcgPSBsb2FkSXRlbTtcblx0XHR9IGVsc2UgaWYgKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0F1ZGlvVGFnKGxvYWRJdGVtLnRhZykpIHtcblx0XHRcdHRoaXMuX3RhZyA9IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0F1ZGlvVGFnKGxvYWRJdGVtKSA/IGxvYWRJdGVtIDogbG9hZEl0ZW0uc3JjO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl90YWcgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fcHJlZmVyWEhSID0gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFNvdW5kTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdE1lZGlhTG9hZGVyKTtcblx0dmFyIHMgPSBTb3VuZExvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1NPVU5EOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNPVU5EO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdHAuX2NyZWF0ZVRhZyA9IGZ1bmN0aW9uIChzcmMpIHtcblx0XHR2YXIgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImF1ZGlvXCIpO1xuXHRcdHRhZy5hdXRvcGxheSA9IGZhbHNlO1xuXHRcdHRhZy5wcmVsb2FkID0gXCJub25lXCI7XG5cblx0XHQvL0xNOiBGaXJlZm94IGZhaWxzIHdoZW4gdGhpcyB0aGUgcHJlbG9hZD1cIm5vbmVcIiBmb3Igb3RoZXIgdGFncywgYnV0IGl0IG5lZWRzIHRvIGJlIFwibm9uZVwiIHRvIGVuc3VyZSBQcmVsb2FkSlMgd29ya3MuXG5cdFx0dGFnLnNyYyA9IHNyYztcblx0XHRyZXR1cm4gdGFnO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLlNvdW5kTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShTb3VuZExvYWRlciwgXCJBYnN0cmFjdE1lZGlhTG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVmlkZW9Mb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgdmlkZW8gZmlsZXMuXG5cdCAqIEBjbGFzcyBWaWRlb0xvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXJYSFJcblx0ICogQGV4dGVuZHMgQWJzdHJhY3RNZWRpYUxvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFZpZGVvTG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIpIHtcblx0XHR0aGlzLkFic3RyYWN0TWVkaWFMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVklERU8pO1xuXG5cdFx0aWYgKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc1ZpZGVvVGFnKGxvYWRJdGVtKSB8fCBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNWaWRlb1RhZyhsb2FkSXRlbS5zcmMpKSB7XG5cdFx0XHR0aGlzLnNldFRhZyhjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNWaWRlb1RhZyhsb2FkSXRlbSk/bG9hZEl0ZW06bG9hZEl0ZW0uc3JjKTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3QgdXNlIFhIUiBmb3IgYSB0YWcgdGhhdCdzIHBhc3NlZCBpbi5cblx0XHRcdHRoaXMuX3ByZWZlclhIUiA9IGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNldFRhZyh0aGlzLl9jcmVhdGVUYWcoKSk7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFZpZGVvTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdE1lZGlhTG9hZGVyKTtcblx0dmFyIHMgPSBWaWRlb0xvYWRlcjtcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgbmV3IHZpZGVvIHRhZ1xuXHQgKlxuXHQgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jcmVhdGVUYWcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKTtcblx0fTtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1ZJREVPOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlZJREVPO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLlZpZGVvTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShWaWRlb0xvYWRlciwgXCJBYnN0cmFjdE1lZGlhTG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU3ByaXRlU2hlZXRMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgRWFzZWxKUyBTcHJpdGVTaGVldHMuIEltYWdlcyBpbnNpZGUgdGhlIHNwcml0ZXNoZWV0IGRlZmluaXRpb24gYXJlIGxvYWRlZCBiZWZvcmUgdGhlIGxvYWRlclxuXHQgKiBjb21wbGV0ZXMuIFRvIGxvYWQgU3ByaXRlU2hlZXRzIHVzaW5nIEpTT05QLCBzcGVjaWZ5IGEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vY2FsbGJhY2s6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogYXMgcGFydCBvZiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0uIE5vdGUgdGhhdCB0aGUge3sjY3Jvc3NMaW5rIFwiSlNPTkxvYWRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBhbmQge3sjY3Jvc3NMaW5rIFwiSlNPTlBMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gYXJlIGhpZ2hlciBwcmlvcml0eSBsb2FkZXJzLCBzbyBTcHJpdGVTaGVldHMgPHN0cm9uZz5tdXN0PC9zdHJvbmc+XG5cdCAqIHNldCB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0ge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vdHlwZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eVxuXHQgKiB0byB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TUFJJVEVTSEVFVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogVGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL2Nyb3NzT3JpZ2luOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGFzIHdlbGxcblx0ICogYXMgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZSdzXCJ9fXt7L2Nyb3NzTGlua319IGBiYXNlUGF0aGAgYXJndW1lbnQgYW5kIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9fcHJlZmVyWEhSXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHByb3BlcnR5IHN1cHBsaWVkIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0gYXJlIHBhc3NlZCBvbiB0byB0aGUgc3ViLW1hbmlmZXN0IHRoYXQgbG9hZHNcblx0ICogdGhlIFNwcml0ZVNoZWV0IGltYWdlcy5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoZSBTcHJpdGVTaGVldCBKU09OIGRvZXMgbm90IHJlc3BlY3QgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9fcHJlZmVyWEhSOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHByb3BlcnR5LCB3aGljaCBzaG91bGQgaW5zdGVhZCBiZSBkZXRlcm1pbmVkIGJ5IHRoZSBwcmVzZW5jZSBvZiBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL2NhbGxiYWNrOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHByb3BlcnR5IG9uIHRoZSBTcHJpdGVTaGVldCBsb2FkIGl0ZW0uIFRoaXMgaXMgYmVjYXVzZSB0aGUgSlNPTiBsb2FkZWQgd2lsbCBoYXZlIGEgZGlmZmVyZW50IGZvcm1hdCBkZXBlbmRpbmcgb25cblx0ICogaWYgaXQgaXMgbG9hZGVkIGFzIEpTT04sIHNvIGp1c3QgY2hhbmdpbmcgYHByZWZlclhIUmAgaXMgbm90IGVub3VnaCB0byBjaGFuZ2UgaG93IGl0IGlzIGxvYWRlZC5cblx0ICogQGNsYXNzIFNwcml0ZVNoZWV0TG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFNwcml0ZVNoZWV0TG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNQUklURVNIRUVUKTtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogQW4gaW50ZXJuYWwgcXVldWUgd2hpY2ggbG9hZHMgdGhlIFNwcml0ZVNoZWV0J3MgaW1hZ2VzLlxuXHRcdCAqIEBtZXRob2QgX21hbmlmZXN0UXVldWVcblx0XHQgKiBAdHlwZSB7TG9hZFF1ZXVlfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbWFuaWZlc3RRdWV1ZSA9IG51bGw7XG5cdH1cblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChTcHJpdGVTaGVldExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IFNwcml0ZVNoZWV0TG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBwcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBUaGUgYW1vdW50IG9mIHByb2dyZXNzIHRoYXQgdGhlIG1hbmlmZXN0IGl0c2VsZiB0YWtlcyB1cC5cblx0ICogQHByb3BlcnR5IFNQUklURVNIRUVUX1BST0dSRVNTXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDAuMjUgKDI1JSlcblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5TUFJJVEVTSEVFVF9QUk9HUkVTUyA9IDAuMjU7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TUFJJVEVTSEVFVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNQUklURVNIRUVUO1xuXHR9O1xuXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdHAuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfZGVzdHJveTtcblx0XHR0aGlzLl9tYW5pZmVzdFF1ZXVlLmNsb3NlKCk7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0cC5fY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IHRoaXMuX2l0ZW0uY2FsbGJhY2s7XG5cdFx0aWYgKGNhbGxiYWNrICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuSlNPTlBMb2FkZXIodGhpcy5faXRlbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuSlNPTkxvYWRlcih0aGlzLl9pdGVtKTtcblx0XHR9XG5cdH07XG5cblx0cC5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHN3aXRjaCAoZXZlbnQudHlwZSkge1xuXHRcdFx0Y2FzZSBcImNvbXBsZXRlXCI6XG5cdFx0XHRcdHRoaXMuX3Jhd1Jlc3VsdCA9IGV2ZW50LnRhcmdldC5nZXRSZXN1bHQodHJ1ZSk7XG5cdFx0XHRcdHRoaXMuX3Jlc3VsdCA9IGV2ZW50LnRhcmdldC5nZXRSZXN1bHQoKTtcblx0XHRcdFx0dGhpcy5fc2VuZFByb2dyZXNzKHMuU1BSSVRFU0hFRVRfUFJPR1JFU1MpO1xuXHRcdFx0XHR0aGlzLl9sb2FkTWFuaWZlc3QodGhpcy5fcmVzdWx0KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0Y2FzZSBcInByb2dyZXNzXCI6XG5cdFx0XHRcdGV2ZW50LmxvYWRlZCAqPSBzLlNQUklURVNIRUVUX1BST0dSRVNTO1xuXHRcdFx0XHR0aGlzLnByb2dyZXNzID0gZXZlbnQubG9hZGVkIC8gZXZlbnQudG90YWw7XG5cdFx0XHRcdGlmIChpc05hTih0aGlzLnByb2dyZXNzKSB8fCB0aGlzLnByb2dyZXNzID09IEluZmluaXR5KSB7IHRoaXMucHJvZ3Jlc3MgPSAwOyB9XG5cdFx0XHRcdHRoaXMuX3NlbmRQcm9ncmVzcyhldmVudCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9oYW5kbGVFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhbmQgbG9hZCB0aGUgaW1hZ2VzIG9uY2UgdGhlIFNwcml0ZVNoZWV0IEpTT04gaGFzIGJlZW4gbG9hZGVkLlxuXHQgKiBAbWV0aG9kIF9sb2FkTWFuaWZlc3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IGpzb25cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2xvYWRNYW5pZmVzdCA9IGZ1bmN0aW9uIChqc29uKSB7XG5cdFx0aWYgKGpzb24gJiYganNvbi5pbWFnZXMpIHtcblx0XHRcdHZhciBxdWV1ZSA9IHRoaXMuX21hbmlmZXN0UXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKHRoaXMuX3ByZWZlclhIUiwgdGhpcy5faXRlbS5wYXRoLCB0aGlzLl9pdGVtLmNyb3NzT3JpZ2luKTtcblx0XHRcdHF1ZXVlLm9uKFwiY29tcGxldGVcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RDb21wbGV0ZSwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRxdWV1ZS5vbihcImZpbGVsb2FkXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0RmlsZUxvYWQsIHRoaXMpO1xuXHRcdFx0cXVldWUub24oXCJwcm9ncmVzc1wiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdFByb2dyZXNzLCB0aGlzKTtcblx0XHRcdHF1ZXVlLm9uKFwiZXJyb3JcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RFcnJvciwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRxdWV1ZS5sb2FkTWFuaWZlc3QoanNvbi5pbWFnZXMpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQW4gaXRlbSBmcm9tIHRoZSB7eyNjcm9zc0xpbmsgXCJfbWFuaWZlc3RRdWV1ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBoYXMgY29tcGxldGVkLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNYW5pZmVzdEZpbGVMb2FkXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVNYW5pZmVzdEZpbGVMb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIGltYWdlID0gZXZlbnQucmVzdWx0O1xuXHRcdGlmIChpbWFnZSAhPSBudWxsKSB7XG5cdFx0XHR2YXIgaW1hZ2VzID0gdGhpcy5nZXRSZXN1bHQoKS5pbWFnZXM7XG5cdFx0XHR2YXIgcG9zID0gaW1hZ2VzLmluZGV4T2YoZXZlbnQuaXRlbS5zcmMpO1xuXHRcdFx0aW1hZ2VzW3Bvc10gPSBpbWFnZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBpbWFnZXMgaGF2ZSBjb21wbGV0ZWQgbG9hZGluZy4gVGhpcyB0cmlnZ2VycyB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvY29tcGxldGU6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZnJvbSB0aGUgU3ByaXRlU2hlZXRMb2FkZXIuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0Q29tcGxldGVcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZU1hbmlmZXN0Q29tcGxldGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLl9yZXN1bHQgPSBuZXcgY3JlYXRlanMuU3ByaXRlU2hlZXQodGhpcy5fcmVzdWx0KTtcblx0XHR0aGlzLl9sb2FkZWRJdGVtcyA9IHRoaXMuX21hbmlmZXN0UXVldWUuZ2V0SXRlbXModHJ1ZSk7XG5cdFx0dGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBpbWFnZXMge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319IGhhcyByZXBvcnRlZCBwcm9ncmVzcy5cblx0ICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RQcm9ncmVzc1xuXHQgKiBAcGFyYW0ge1Byb2dyZXNzRXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVNYW5pZmVzdFByb2dyZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dGhpcy5wcm9ncmVzcyA9IGV2ZW50LnByb2dyZXNzICogKDEgLSBzLlNQUklURVNIRUVUX1BST0dSRVNTKSArIHMuU1BSSVRFU0hFRVRfUFJPR1JFU1M7XG5cdFx0dGhpcy5fc2VuZFByb2dyZXNzKHRoaXMucHJvZ3Jlc3MpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbiBpbWFnZSBoYXMgcmVwb3J0ZWQgYW4gZXJyb3IuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0RXJyb3Jcblx0ICogQHBhcmFtIHtFcnJvckV2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVlcnJvclwiKTtcblx0XHRuZXdFdmVudC5pdGVtID0gZXZlbnQuZGF0YTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLlNwcml0ZVNoZWV0TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShTcHJpdGVTaGVldExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNWR0xvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBTVkcgZmlsZXMuXG5cdCAqIEBjbGFzcyBTVkdMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZmVyWEhSXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gU1ZHTG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNWRyk7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBcImRhdGFcIjtcblxuXHRcdGlmIChwcmVmZXJYSFIpIHtcblx0XHRcdHRoaXMuc2V0VGFnKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIikpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNldFRhZyhkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib2JqZWN0XCIpKTtcblx0XHRcdHRoaXMuZ2V0VGFnKCkudHlwZSA9IFwiaW1hZ2Uvc3ZnK3htbFwiO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChTVkdMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBTVkdMb2FkZXI7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TVkc6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TVkc7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBTVkcgZmlsZXMuXG5cdCAqIEBtZXRob2QgX2Zvcm1hdFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHJldHVybnMge09iamVjdH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHQvLyBtaW1lIHNob3VsZCBiZSBpbWFnZS9zdmcreG1sLCBidXQgT3BlcmEgcmVxdWlyZXMgdGV4dC94bWxcblx0XHR2YXIgeG1sID0gY3JlYXRlanMuRGF0YVV0aWxzLnBhcnNlWE1MKGxvYWRlci5nZXRSZXN1bHQodHJ1ZSksIFwidGV4dC94bWxcIik7XG5cdFx0dmFyIHRhZyA9IGxvYWRlci5nZXRUYWcoKTtcblxuXHRcdGlmICghdGhpcy5fcHJlZmVyWEhSICYmIGRvY3VtZW50LmJvZHkuY29udGFpbnModGFnKSkge1xuXHRcdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0YWcpO1xuXHRcdH1cblxuXHRcdGlmICh4bWwuZG9jdW1lbnRFbGVtZW50ICE9IG51bGwpIHtcblx0XHRcdHRhZy5hcHBlbmRDaGlsZCh4bWwuZG9jdW1lbnRFbGVtZW50KTtcblx0XHRcdHRhZy5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG5cdFx0XHRyZXR1cm4gdGFnO1xuXHRcdH0gZWxzZSB7IC8vIEZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgU1ZHLCBqdXN0IGdpdmUgdGhlbSB0aGUgWE1MLiAoSUUgOS04KVxuXHRcdFx0cmV0dXJuIHhtbDtcblx0XHR9XG5cdH07XG5cblx0Y3JlYXRlanMuU1ZHTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShTVkdMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBYTUxMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgQ1NTIGZpbGVzLlxuXHQgKiBAY2xhc3MgWE1MTG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFhNTExvYWRlcihsb2FkSXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHRydWUsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlhNTCk7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFhNTExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IFhNTExvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1hNTDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5YTUw7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBYTUwgZmlsZXMuXG5cdCAqIEBtZXRob2QgX2Zvcm1hdFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHJldHVybnMge1hNTERvY3VtZW50fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZm9ybWF0UmVzdWx0ID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdHJldHVybiBjcmVhdGVqcy5EYXRhVXRpbHMucGFyc2VYTUwobG9hZGVyLmdldFJlc3VsdCh0cnVlKSwgXCJ0ZXh0L3htbFwiKTtcblx0fTtcblxuXHRjcmVhdGVqcy5YTUxMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKFhNTExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIHZlcnNpb24uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cblx0LyoqXG5cdCAqIFN0YXRpYyBjbGFzcyBob2xkaW5nIGxpYnJhcnkgc3BlY2lmaWMgaW5mb3JtYXRpb24gc3VjaCBhcyB0aGUgdmVyc2lvbiBhbmQgYnVpbGREYXRlIG9mIHRoZSBsaWJyYXJ5LlxuXHQgKiBUaGUgU291bmRKUyBjbGFzcyBoYXMgYmVlbiByZW5hbWVkIHt7I2Nyb3NzTGluayBcIlNvdW5kXCJ9fXt7L2Nyb3NzTGlua319LiAgUGxlYXNlIHNlZSB7eyNjcm9zc0xpbmsgXCJTb3VuZFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgaW5mb3JtYXRpb24gb24gdXNpbmcgc291bmQuXG5cdCAqIEBjbGFzcyBTb3VuZEpTXG5cdCAqKi9cblx0dmFyIHMgPSBjcmVhdGVqcy5Tb3VuZEpTID0gY3JlYXRlanMuU291bmRKUyB8fCB7fTtcblxuXHQvKipcblx0ICogVGhlIHZlcnNpb24gc3RyaW5nIGZvciB0aGlzIHJlbGVhc2UuXG5cdCAqIEBwcm9wZXJ0eSB2ZXJzaW9uXG5cdCAqIEB0eXBlIFN0cmluZ1xuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0cy52ZXJzaW9uID0gLyo9dmVyc2lvbiovXCIwLjYuMlwiOyAvLyBpbmplY3RlZCBieSBidWlsZCBwcm9jZXNzXG5cblx0LyoqXG5cdCAqIFRoZSBidWlsZCBkYXRlIGZvciB0aGlzIHJlbGVhc2UgaW4gVVRDIGZvcm1hdC5cblx0ICogQHByb3BlcnR5IGJ1aWxkRGF0ZVxuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdHMuYnVpbGREYXRlID0gLyo9ZGF0ZSovXCJUaHUsIDI2IE5vdiAyMDE1IDIwOjQ0OjMxIEdNVFwiOyAvLyBpbmplY3RlZCBieSBidWlsZCBwcm9jZXNzXG5cbn0pKCk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBJbmRleE9mLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4vKipcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuXG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGEgc3BlY2lmaWVkIHZhbHVlIHNlYXJjaEVsZW1lbnQgaW4gdGhlIHBhc3NlZCBpbiBhcnJheSwgYW5kIHJldHVybnMgdGhlIGluZGV4IG9mXG4gKiB0aGF0IHZhbHVlLiAgUmV0dXJucyAtMSBpZiB2YWx1ZSBpcyBub3QgZm91bmQuXG4gKlxuICogICAgICB2YXIgaSA9IGNyZWF0ZWpzLmluZGV4T2YobXlBcnJheSwgbXlFbGVtZW50VG9GaW5kKTtcbiAqXG4gKiBAbWV0aG9kIGluZGV4T2ZcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIHNlYXJjaCBmb3Igc2VhcmNoRWxlbWVudFxuICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgRWxlbWVudCB0byBmaW5kIGluIGFycmF5LlxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgZmlyc3QgaW5kZXggb2Ygc2VhcmNoRWxlbWVudCBpbiBhcnJheS5cbiAqL1xuY3JlYXRlanMuaW5kZXhPZiA9IGZ1bmN0aW9uIChhcnJheSwgc2VhcmNoRWxlbWVudCl7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGZvciAodmFyIGkgPSAwLGw9YXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0aWYgKHNlYXJjaEVsZW1lbnQgPT09IGFycmF5W2ldKSB7XG5cdFx0XHRyZXR1cm4gaTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIC0xO1xufTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFByb3h5LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4vKipcbiAqIFZhcmlvdXMgdXRpbGl0aWVzIHRoYXQgdGhlIENyZWF0ZUpTIFN1aXRlIHVzZXMuIFV0aWxpdGllcyBhcmUgY3JlYXRlZCBhcyBzZXBhcmF0ZSBmaWxlcywgYW5kIHdpbGwgYmUgYXZhaWxhYmxlIG9uIHRoZVxuICogY3JlYXRlanMgbmFtZXNwYWNlIGRpcmVjdGx5LlxuICpcbiAqIDxoND5FeGFtcGxlPC9oND5cbiAqXG4gKiAgICAgIG15T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgY3JlYXRlanMucHJveHkobXlNZXRob2QsIHNjb3BlKSk7XG4gKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICogQG1haW4gVXRpbGl0eSBNZXRob2RzXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogQSBmdW5jdGlvbiBwcm94eSBmb3IgbWV0aG9kcy4gQnkgZGVmYXVsdCwgSmF2YVNjcmlwdCBtZXRob2RzIGRvIG5vdCBtYWludGFpbiBzY29wZSwgc28gcGFzc2luZyBhIG1ldGhvZCBhcyBhXG5cdCAqIGNhbGxiYWNrIHdpbGwgcmVzdWx0IGluIHRoZSBtZXRob2QgZ2V0dGluZyBjYWxsZWQgaW4gdGhlIHNjb3BlIG9mIHRoZSBjYWxsZXIuIFVzaW5nIGEgcHJveHkgZW5zdXJlcyB0aGF0IHRoZVxuXHQgKiBtZXRob2QgZ2V0cyBjYWxsZWQgaW4gdGhlIGNvcnJlY3Qgc2NvcGUuXG5cdCAqXG5cdCAqIEFkZGl0aW9uYWwgYXJndW1lbnRzIGNhbiBiZSBwYXNzZWQgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGZ1bmN0aW9uIHdoZW4gaXQgaXMgY2FsbGVkLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgbXlPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcImV2ZW50XCIsIGNyZWF0ZWpzLnByb3h5KG15SGFuZGxlciwgdGhpcywgYXJnMSwgYXJnMikpO1xuXHQgKlxuXHQgKiAgICAgIGZ1bmN0aW9uIG15SGFuZGxlcihhcmcxLCBhcmcyKSB7XG5cdCAqICAgICAgICAgICAvLyBUaGlzIGdldHMgY2FsbGVkIHdoZW4gbXlPYmplY3QubXlDYWxsYmFjayBpcyBleGVjdXRlZC5cblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBtZXRob2QgcHJveHlcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIFRoZSBmdW5jdGlvbiB0byBjYWxsXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSBUaGUgc2NvcGUgdG8gY2FsbCB0aGUgbWV0aG9kIG5hbWUgb25cblx0ICogQHBhcmFtIHttaXhlZH0gW2FyZ10gKiBBcmd1bWVudHMgdGhhdCBhcmUgYXBwZW5kZWQgdG8gdGhlIGNhbGxiYWNrIGZvciBhZGRpdGlvbmFsIHBhcmFtcy5cblx0ICogQHB1YmxpY1xuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRjcmVhdGVqcy5wcm94eSA9IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlKSB7XG5cdFx0dmFyIGFBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIG1ldGhvZC5hcHBseShzY29wZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKS5jb25jYXQoYUFyZ3MpKTtcblx0XHR9O1xuXHR9XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBCcm93c2VyRGV0ZWN0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4vKipcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogQW4gb2JqZWN0IHRoYXQgZGV0ZXJtaW5lcyB0aGUgY3VycmVudCBicm93c2VyLCB2ZXJzaW9uLCBvcGVyYXRpbmcgc3lzdGVtLCBhbmQgb3RoZXIgZW52aXJvbm1lbnRcblx0ICogdmFyaWFibGVzIHZpYSB1c2VyIGFnZW50IHN0cmluZy5cblx0ICpcblx0ICogVXNlZCBmb3IgYXVkaW8gYmVjYXVzZSBmZWF0dXJlIGRldGVjdGlvbiBpcyB1bmFibGUgdG8gZGV0ZWN0IHRoZSBtYW55IGxpbWl0YXRpb25zIG9mIG1vYmlsZSBkZXZpY2VzLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgaWYgKGNyZWF0ZWpzLkJyb3dzZXJEZXRlY3QuaXNJT1MpIHsgLy8gZG8gc3R1ZmYgfVxuXHQgKlxuXHQgKiBAcHJvcGVydHkgQnJvd3NlckRldGVjdFxuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRmlyZWZveCBUcnVlIGlmIG91ciBicm93c2VyIGlzIEZpcmVmb3guXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNPcGVyYSBUcnVlIGlmIG91ciBicm93c2VyIGlzIG9wZXJhLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQ2hyb21lIFRydWUgaWYgb3VyIGJyb3dzZXIgaXMgQ2hyb21lLiAgTm90ZSB0aGF0IENocm9tZSBmb3IgQW5kcm9pZCByZXR1cm5zIHRydWUsIGJ1dCBpcyBhXG5cdCAqIGNvbXBsZXRlbHkgZGlmZmVyZW50IGJyb3dzZXIgd2l0aCBkaWZmZXJlbnQgYWJpbGl0aWVzLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzSU9TIFRydWUgaWYgb3VyIGJyb3dzZXIgaXMgc2FmYXJpIGZvciBpT1MgZGV2aWNlcyAoaVBhZCwgaVBob25lLCBhbmQgaVBvZCkuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNBbmRyb2lkIFRydWUgaWYgb3VyIGJyb3dzZXIgaXMgQW5kcm9pZC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0JsYWNrYmVycnkgVHJ1ZSBpZiBvdXIgYnJvd3NlciBpcyBCbGFja2JlcnJ5LlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0ZnVuY3Rpb24gQnJvd3NlckRldGVjdCgpIHtcblx0XHR0aHJvdyBcIkJyb3dzZXJEZXRlY3QgY2Fubm90IGJlIGluc3RhbnRpYXRlZFwiO1xuXHR9O1xuXG5cdHZhciBhZ2VudCA9IEJyb3dzZXJEZXRlY3QuYWdlbnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblx0QnJvd3NlckRldGVjdC5pc1dpbmRvd1Bob25lID0gKGFnZW50LmluZGV4T2YoXCJJRU1vYmlsZVwiKSA+IC0xKSB8fCAoYWdlbnQuaW5kZXhPZihcIldpbmRvd3MgUGhvbmVcIikgPiAtMSk7XG5cdEJyb3dzZXJEZXRlY3QuaXNGaXJlZm94ID0gKGFnZW50LmluZGV4T2YoXCJGaXJlZm94XCIpID4gLTEpO1xuXHRCcm93c2VyRGV0ZWN0LmlzT3BlcmEgPSAod2luZG93Lm9wZXJhICE9IG51bGwpO1xuXHRCcm93c2VyRGV0ZWN0LmlzQ2hyb21lID0gKGFnZW50LmluZGV4T2YoXCJDaHJvbWVcIikgPiAtMSk7ICAvLyBOT1RFIHRoYXQgQ2hyb21lIG9uIEFuZHJvaWQgcmV0dXJucyB0cnVlIGJ1dCBpcyBhIGNvbXBsZXRlbHkgZGlmZmVyZW50IGJyb3dzZXIgd2l0aCBkaWZmZXJlbnQgYWJpbGl0aWVzXG5cdEJyb3dzZXJEZXRlY3QuaXNJT1MgPSAoYWdlbnQuaW5kZXhPZihcImlQb2RcIikgPiAtMSB8fCBhZ2VudC5pbmRleE9mKFwiaVBob25lXCIpID4gLTEgfHwgYWdlbnQuaW5kZXhPZihcImlQYWRcIikgPiAtMSkgJiYgIUJyb3dzZXJEZXRlY3QuaXNXaW5kb3dQaG9uZTtcblx0QnJvd3NlckRldGVjdC5pc0FuZHJvaWQgPSAoYWdlbnQuaW5kZXhPZihcIkFuZHJvaWRcIikgPiAtMSkgJiYgIUJyb3dzZXJEZXRlY3QuaXNXaW5kb3dQaG9uZTtcblx0QnJvd3NlckRldGVjdC5pc0JsYWNrYmVycnkgPSAoYWdlbnQuaW5kZXhPZihcIkJsYWNrYmVycnlcIikgPiAtMSk7XG5cblx0Y3JlYXRlanMuQnJvd3NlckRldGVjdCA9IEJyb3dzZXJEZXRlY3Q7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBBdWRpb1Nwcml0ZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuLy8gIE5PVEUgdGhpcyBpcyBcIkNsYXNzXCIgaXMgcHVyZWx5IHRvIGRvY3VtZW50IGF1ZGlvU3ByaXRlIFNldHVwIGFuZCB1c2FnZS5cblxuXG4vKipcbiAqIDxzdHJvbmc+Tm90ZTogQXVkaW9TcHJpdGUgaXMgbm90IGEgY2xhc3MsIGJ1dCBpdHMgdXNhZ2UgaXMgZWFzaWx5IGxvc3QgaW4gdGhlIGRvY3VtZW50YXRpb24sIHNvIGl0IGhhcyBiZWVuIGNhbGxlZFxuICogb3V0IGhlcmUgZm9yIHF1aWNrIHJlZmVyZW5jZS48L3N0cm9uZz5cbiAqXG4gKiBBdWRpbyBzcHJpdGVzIGFyZSBtdWNoIGxpa2UgQ1NTIHNwcml0ZXMgb3IgaW1hZ2Ugc3ByaXRlIHNoZWV0czogbXVsdGlwbGUgYXVkaW8gYXNzZXRzIGdyb3VwZWQgaW50byBhIHNpbmdsZSBmaWxlLlxuICogQXVkaW8gc3ByaXRlcyB3b3JrIGFyb3VuZCBsaW1pdGF0aW9ucyBpbiBjZXJ0YWluIGJyb3dzZXJzLCB3aGVyZSBvbmx5IGEgc2luZ2xlIHNvdW5kIGNhbiBiZSBsb2FkZWQgYW5kIHBsYXllZCBhdCBhXG4gKiB0aW1lLiBXZSByZWNvbW1lbmQgYXQgbGVhc3QgMzAwbXMgb2Ygc2lsZW5jZSBiZXR3ZWVuIGF1ZGlvIGNsaXBzIHRvIGRlYWwgd2l0aCBIVE1MIGF1ZGlvIHRhZyBpbmFjY3VyYWN5LCBhbmQgdG8gcHJldmVudFxuICogYWNjaWRlbnRhbGx5IHBsYXlpbmcgYml0cyBvZiB0aGUgbmVpZ2hib3VyaW5nIGNsaXBzLlxuICpcbiAqIDxzdHJvbmc+QmVuZWZpdHMgb2YgQXVkaW8gU3ByaXRlczo8L3N0cm9uZz5cbiAqIDx1bD5cbiAqICAgICA8bGk+TW9yZSByb2J1c3Qgc3VwcG9ydCBmb3Igb2xkZXIgYnJvd3NlcnMgYW5kIGRldmljZXMgdGhhdCBvbmx5IGFsbG93IGEgc2luZ2xlIGF1ZGlvIGluc3RhbmNlLCBzdWNoIGFzIGlPUyA1LjwvbGk+XG4gKiAgICAgPGxpPlRoZXkgcHJvdmlkZSBhIHdvcmsgYXJvdW5kIGZvciB0aGUgSW50ZXJuZXQgRXhwbG9yZXIgOSBhdWRpbyB0YWcgbGltaXQsIHdoaWNoIHJlc3RyaWN0cyBob3cgbWFueSBkaWZmZXJlbnRcbiAqICAgICBzb3VuZHMgdGhhdCBjb3VsZCBiZSBsb2FkZWQgYXQgb25jZS48L2xpPlxuICogICAgIDxsaT5GYXN0ZXIgbG9hZGluZyBieSBvbmx5IHJlcXVpcmluZyBhIHNpbmdsZSBuZXR3b3JrIHJlcXVlc3QgZm9yIHNldmVyYWwgc291bmRzLCBlc3BlY2lhbGx5IG9uIG1vYmlsZSBkZXZpY2VzXG4gKiB3aGVyZSB0aGUgbmV0d29yayByb3VuZCB0cmlwIGZvciBlYWNoIGZpbGUgY2FuIGFkZCBzaWduaWZpY2FudCBsYXRlbmN5LjwvbGk+XG4gKiA8L3VsPlxuICpcbiAqIDxzdHJvbmc+RHJhd2JhY2tzIG9mIEF1ZGlvIFNwcml0ZXM8L3N0cm9uZz5cbiAqIDx1bD5cbiAqICAgICA8bGk+Tm8gZ3VhcmFudGVlIG9mIHNtb290aCBsb29waW5nIHdoZW4gdXNpbmcgSFRNTCBvciBGbGFzaCBhdWRpby4gSWYgeW91IGhhdmUgYSB0cmFjayB0aGF0IG5lZWRzIHRvIGxvb3BcbiAqIFx0XHRzbW9vdGhseSBhbmQgeW91IGFyZSBzdXBwb3J0aW5nIG5vbi13ZWIgYXVkaW8gYnJvd3NlcnMsIGRvIG5vdCB1c2UgYXVkaW8gc3ByaXRlcyBmb3IgdGhhdCBzb3VuZCBpZiB5b3UgY2FuIGF2b2lkXG4gKiBcdFx0aXQuPC9saT5cbiAqICAgICA8bGk+Tm8gZ3VhcmFudGVlIHRoYXQgSFRNTCBhdWRpbyB3aWxsIHBsYXkgYmFjayBpbW1lZGlhdGVseSwgZXNwZWNpYWxseSB0aGUgZmlyc3QgdGltZS4gSW4gc29tZSBicm93c2Vyc1xuICogICAgIChDaHJvbWUhKSwgSFRNTCBhdWRpbyB3aWxsIG9ubHkgbG9hZCBlbm91Z2ggdG8gcGxheSB0aHJvdWdoIGF0IHRoZSBjdXJyZW50IGRvd25sb2FkIHNwZWVkIMOi4oKs4oCcIHNvIHdlIHJlbHkgb24gdGhlXG4gKiAgICAgYGNhbnBsYXl0aHJvdWdoYCBldmVudCB0byBkZXRlcm1pbmUgaWYgdGhlIGF1ZGlvIGlzIGxvYWRlZC4gU2luY2UgYXVkaW8gc3ByaXRlcyBtdXN0IGp1bXAgYWhlYWQgdG8gcGxheSBzcGVjaWZpY1xuICogICAgIHNvdW5kcywgdGhlIGF1ZGlvIG1heSBub3QgeWV0IGhhdmUgZG93bmxvYWRlZCBmdWxseS48L2xpPlxuICogICAgIDxsaT5BdWRpbyBzcHJpdGVzIHNoYXJlIHRoZSBzYW1lIGNvcmUgc291cmNlLCBzbyBpZiB5b3UgaGF2ZSBhIHNwcml0ZSB3aXRoIDUgc291bmRzIGFuZCBhcmUgbGltaXRlZCB0byAyXG4gKiBcdFx0Y29uY3VycmVudGx5IHBsYXlpbmcgaW5zdGFuY2VzLCB5b3UgY2FuIG9ubHkgcGxheSAyIG9mIHRoZSBzb3VuZHMgYXQgdGhlIHNhbWUgdGltZS48L2xpPlxuICogPC91bD5cbiAqXG4gKiA8aDQ+RXhhbXBsZTwvaDQ+XG4gKlxuICpcdFx0Y3JlYXRlanMuU291bmQuaW5pdGlhbGl6ZURlZmF1bHRQbHVnaW5zKCk7XG4gKlx0XHR2YXIgYXNzZXRzUGF0aCA9IFwiLi9hc3NldHMvXCI7XG4gKlx0XHR2YXIgc291bmRzID0gW3tcbiAqXHRcdFx0c3JjOlwiTXlBdWRpb1Nwcml0ZS5vZ2dcIiwgZGF0YToge1xuICpcdFx0XHRcdGF1ZGlvU3ByaXRlOiBbXG4gKlx0XHRcdFx0XHR7aWQ6XCJzb3VuZDFcIiwgc3RhcnRUaW1lOjAsIGR1cmF0aW9uOjUwMH0sXG4gKlx0XHRcdFx0XHR7aWQ6XCJzb3VuZDJcIiwgc3RhcnRUaW1lOjEwMDAsIGR1cmF0aW9uOjQwMH0sXG4gKlx0XHRcdFx0XHR7aWQ6XCJzb3VuZDNcIiwgc3RhcnRUaW1lOjE3MDAsIGR1cmF0aW9uOiAxMDAwfVxuICpcdFx0XHRcdF19XG4gKlx0XHRcdH1cbiAqXHRcdF07XG4gKlx0XHRjcmVhdGVqcy5Tb3VuZC5hbHRlcm5hdGVFeHRlbnNpb25zID0gW1wibXAzXCJdO1xuICpcdFx0Y3JlYXRlanMuU291bmQub24oXCJmaWxlbG9hZFwiLCBsb2FkU291bmQpO1xuICpcdFx0Y3JlYXRlanMuU291bmQucmVnaXN0ZXJTb3VuZHMoc291bmRzLCBhc3NldHNQYXRoKTtcbiAqXHRcdC8vIGFmdGVyIGxvYWQgaXMgY29tcGxldGVcbiAqXHRcdGNyZWF0ZWpzLlNvdW5kLnBsYXkoXCJzb3VuZDJcIik7XG4gKlxuICogWW91IGNhbiBhbHNvIGNyZWF0ZSBhdWRpbyBzcHJpdGVzIG9uIHRoZSBmbHkgYnkgc2V0dGluZyB0aGUgc3RhcnRUaW1lIGFuZCBkdXJhdGlvbiB3aGVuIGNyZWF0aW5nIGFuIG5ldyBBYnN0cmFjdFNvdW5kSW5zdGFuY2UuXG4gKlxuICogXHRcdGNyZWF0ZWpzLlNvdW5kLnBsYXkoXCJNeUF1ZGlvU3ByaXRlXCIsIHtzdGFydFRpbWU6IDEwMDAsIGR1cmF0aW9uOiA0MDB9KTtcbiAqXG4gKiBUaGUgZXhjZWxsZW50IENyZWF0ZUpTIGNvbW11bml0eSBoYXMgY3JlYXRlZCBhIHRvb2wgdG8gY3JlYXRlIGF1ZGlvIHNwcml0ZXMsIGF2YWlsYWJsZSBhdFxuICogPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS90b25pc3RpaWdpL2F1ZGlvc3ByaXRlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+aHR0cHM6Ly9naXRodWIuY29tL3RvbmlzdGlpZ2kvYXVkaW9zcHJpdGU8L2E+LFxuICogYXMgd2VsbCBhcyBhIDxhIGhyZWY9XCJodHRwOi8vanNmaWRkbGUubmV0L2JoYXJhdF9iYXR0dS9nOGZGUC8xMi9cIiB0YXJnZXQ9XCJfYmxhbmtcIj5qc2ZpZGRsZTwvYT4gdG8gY29udmVydCB0aGUgb3V0cHV0XG4gKiB0byBTb3VuZEpTIGZvcm1hdC5cbiAqXG4gKiBAY2xhc3MgQXVkaW9TcHJpdGVcbiAqIEBzaW5jZSAwLjYuMFxuICovXG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBQbGF5UHJvcHNDb25maWcuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKipcblx0ICogQSBjbGFzcyB0byBzdG9yZSB0aGUgb3B0aW9uYWwgcGxheSBwcm9wZXJ0aWVzIHBhc3NlZCBpbiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9wbGF5XCJ9fXt7L2Nyb3NzTGlua319IGFuZFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvcGxheVwifX17ey9jcm9zc0xpbmt9fSBjYWxscy5cblx0ICpcblx0ICogT3B0aW9uYWwgUGxheSBQcm9wZXJ0aWVzIEluY2x1ZGU6XG5cdCAqIDx1bD5cblx0ICogPGxpPmludGVycnVwdCAtIEhvdyB0byBpbnRlcnJ1cHQgYW55IGN1cnJlbnRseSBwbGF5aW5nIGluc3RhbmNlcyBvZiBhdWRpbyB3aXRoIHRoZSBzYW1lIHNvdXJjZSxcblx0ICogaWYgdGhlIG1heGltdW0gbnVtYmVyIG9mIGluc3RhbmNlcyBvZiB0aGUgc291bmQgYXJlIGFscmVhZHkgcGxheWluZy4gVmFsdWVzIGFyZSBkZWZpbmVkIGFzIDxjb2RlPklOVEVSUlVQVF9UWVBFPC9jb2RlPlxuXHQgKiBjb25zdGFudHMgb24gdGhlIFNvdW5kIGNsYXNzLCB3aXRoIHRoZSBkZWZhdWx0IGRlZmluZWQgYnkge3sjY3Jvc3NMaW5rIFwiU291bmQvZGVmYXVsdEludGVycnVwdEJlaGF2aW9yOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LjwvbGk+XG5cdCAqIDxsaT5kZWxheSAtIFRoZSBhbW91bnQgb2YgdGltZSB0byBkZWxheSB0aGUgc3RhcnQgb2YgYXVkaW8gcGxheWJhY2ssIGluIG1pbGxpc2Vjb25kcy48L2xpPlxuXHQgKiA8bGk+b2Zmc2V0IC0gVGhlIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgYXVkaW8gdG8gYmVnaW4gcGxheWJhY2ssIGluIG1pbGxpc2Vjb25kcy48L2xpPlxuXHQgKiA8bGk+bG9vcCAtIEhvdyBtYW55IHRpbWVzIHRoZSBhdWRpbyBsb29wcyB3aGVuIGl0IHJlYWNoZXMgdGhlIGVuZCBvZiBwbGF5YmFjay4gVGhlIGRlZmF1bHQgaXMgMCAobm9cblx0ICogbG9vcHMpLCBhbmQgLTEgY2FuIGJlIHVzZWQgZm9yIGluZmluaXRlIHBsYXliYWNrLjwvbGk+XG5cdCAqIDxsaT52b2x1bWUgLSBUaGUgdm9sdW1lIG9mIHRoZSBzb3VuZCwgYmV0d2VlbiAwIGFuZCAxLiBOb3RlIHRoYXQgdGhlIG1hc3RlciB2b2x1bWUgaXMgYXBwbGllZFxuXHQgKiBhZ2FpbnN0IHRoZSBpbmRpdmlkdWFsIHZvbHVtZS48L2xpPlxuXHQgKiA8bGk+cGFuIC0gVGhlIGxlZnQtcmlnaHQgcGFuIG9mIHRoZSBzb3VuZCAoaWYgc3VwcG9ydGVkKSwgYmV0d2VlbiAtMSAobGVmdCkgYW5kIDEgKHJpZ2h0KS48L2xpPlxuXHQgKiA8bGk+c3RhcnRUaW1lIC0gVG8gY3JlYXRlIGFuIGF1ZGlvIHNwcml0ZSAod2l0aCBkdXJhdGlvbiksIHRoZSBpbml0aWFsIG9mZnNldCB0byBzdGFydCBwbGF5YmFjayBhbmQgbG9vcCBmcm9tLCBpbiBtaWxsaXNlY29uZHMuPC9saT5cblx0ICogPGxpPmR1cmF0aW9uIC0gVG8gY3JlYXRlIGFuIGF1ZGlvIHNwcml0ZSAod2l0aCBzdGFydFRpbWUpLCB0aGUgYW1vdW50IG9mIHRpbWUgdG8gcGxheSB0aGUgY2xpcCBmb3IsIGluIG1pbGxpc2Vjb25kcy48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqIFx0dmFyIHBwYyA9IG5ldyBjcmVhdGVqcy5QbGF5UHJvcHNDb25maWcoKS5zZXQoe2ludGVycnVwdDogY3JlYXRlanMuU291bmQuSU5URVJSVVBUX0FOWSwgbG9vcDogLTEsIHZvbHVtZTogMC41fSlcblx0ICogXHRjcmVhdGVqcy5Tb3VuZC5wbGF5KFwibXlTb3VuZFwiLCBwcGMpO1xuXHQgKiBcdG15U291bmRJbnN0YW5jZS5wbGF5KHBwYyk7XG5cdCAqXG5cdCAqIEBjbGFzcyBQbGF5UHJvcHNDb25maWdcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBzaW5jZSAwLjYuMVxuXHQgKi9cblx0Ly8gVE9ETyB0aGluayBvZiBhIGJldHRlciBuYW1lIGZvciB0aGlzIGNsYXNzXG5cdHZhciBQbGF5UHJvcHNDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4vLyBQdWJsaWMgUHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEhvdyB0byBpbnRlcnJ1cHQgYW55IGN1cnJlbnRseSBwbGF5aW5nIGluc3RhbmNlcyBvZiBhdWRpbyB3aXRoIHRoZSBzYW1lIHNvdXJjZSxcblx0XHQgKiBpZiB0aGUgbWF4aW11bSBudW1iZXIgb2YgaW5zdGFuY2VzIG9mIHRoZSBzb3VuZCBhcmUgYWxyZWFkeSBwbGF5aW5nLiBWYWx1ZXMgYXJlIGRlZmluZWQgYXNcblx0XHQgKiA8Y29kZT5JTlRFUlJVUFRfVFlQRTwvY29kZT4gY29uc3RhbnRzIG9uIHRoZSBTb3VuZCBjbGFzcywgd2l0aCB0aGUgZGVmYXVsdCBkZWZpbmVkIGJ5XG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiU291bmQvZGVmYXVsdEludGVycnVwdEJlaGF2aW9yOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBpbnRlcnJ1cHRcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmludGVycnVwdCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgdGhlIHN0YXJ0IG9mIGF1ZGlvIHBsYXliYWNrLCBpbiBtaWxsaXNlY29uZHMuXG5cdFx0ICogQHByb3BlcnR5IGRlbGF5XG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5kZWxheSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBhdWRpbyB0byBiZWdpbiBwbGF5YmFjaywgaW4gbWlsbGlzZWNvbmRzLlxuXHRcdCAqIEBwcm9wZXJ0eSBvZmZzZXRcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLm9mZnNldCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBIb3cgbWFueSB0aW1lcyB0aGUgYXVkaW8gbG9vcHMgd2hlbiBpdCByZWFjaGVzIHRoZSBlbmQgb2YgcGxheWJhY2suIFRoZSBkZWZhdWx0IGlzIDAgKG5vXG5cdFx0ICogbG9vcHMpLCBhbmQgLTEgY2FuIGJlIHVzZWQgZm9yIGluZmluaXRlIHBsYXliYWNrLlxuXHRcdCAqIEBwcm9wZXJ0eSBsb29wXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5sb29wID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB2b2x1bWUgb2YgdGhlIHNvdW5kLCBiZXR3ZWVuIDAgYW5kIDEuIE5vdGUgdGhhdCB0aGUgbWFzdGVyIHZvbHVtZSBpcyBhcHBsaWVkXG5cdFx0ICogYWdhaW5zdCB0aGUgaW5kaXZpZHVhbCB2b2x1bWUuXG5cdFx0ICogQHByb3BlcnR5IHZvbHVtZVxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMudm9sdW1lID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsZWZ0LXJpZ2h0IHBhbiBvZiB0aGUgc291bmQgKGlmIHN1cHBvcnRlZCksIGJldHdlZW4gLTEgKGxlZnQpIGFuZCAxIChyaWdodCkuXG5cdFx0ICogQHByb3BlcnR5IHBhblxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMucGFuID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFVzZWQgdG8gY3JlYXRlIGFuIGF1ZGlvIHNwcml0ZSAod2l0aCBkdXJhdGlvbiksIHRoZSBpbml0aWFsIG9mZnNldCB0byBzdGFydCBwbGF5YmFjayBhbmQgbG9vcCBmcm9tLCBpbiBtaWxsaXNlY29uZHMuXG5cdFx0ICogQHByb3BlcnR5IHN0YXJ0VGltZVxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFVzZWQgdG8gY3JlYXRlIGFuIGF1ZGlvIHNwcml0ZSAod2l0aCBzdGFydFRpbWUpLCB0aGUgYW1vdW50IG9mIHRpbWUgdG8gcGxheSB0aGUgY2xpcCBmb3IsIGluIG1pbGxpc2Vjb25kcy5cblx0XHQgKiBAcHJvcGVydHkgZHVyYXRpb25cblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmR1cmF0aW9uID0gbnVsbDtcblx0fTtcblx0dmFyIHAgPSBQbGF5UHJvcHNDb25maWcucHJvdG90eXBlID0ge307XG5cdHZhciBzID0gUGxheVByb3BzQ29uZmlnO1xuXG5cbi8vIFN0YXRpYyBNZXRob2RzXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgUGxheVByb3BzQ29uZmlnIGZyb20gYW5vdGhlciBQbGF5UHJvcHNDb25maWcgb3IgYW4gT2JqZWN0LlxuXHQgKlxuXHQgKiBAbWV0aG9kIGNyZWF0ZVxuXHQgKiBAcGFyYW0ge1BsYXlQcm9wc0NvbmZpZ3xPYmplY3R9IHZhbHVlIFRoZSBwbGF5IHByb3BlcnRpZXNcblx0ICogQHJldHVybnMge1BsYXlQcm9wc0NvbmZpZ31cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jcmVhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBzIHx8IHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG5cdFx0XHR2YXIgcHBjID0gbmV3IGNyZWF0ZWpzLlBsYXlQcm9wc0NvbmZpZygpO1xuXHRcdFx0cHBjLnNldCh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gcHBjO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUeXBlIG5vdCByZWNvZ25pemVkLlwiKTtcblx0XHR9XG5cdH07XG5cbi8vIFB1YmxpYyBNZXRob2RzXG5cdC8qKlxuXHQgKiBQcm92aWRlcyBhIGNoYWluYWJsZSBzaG9ydGN1dCBtZXRob2QgZm9yIHNldHRpbmcgYSBudW1iZXIgb2YgcHJvcGVydGllcyBvbiB0aGUgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgUGxheVByb3BzQ29uZmlnID0gbmV3IGNyZWF0ZWpzLlBsYXlQcm9wc0NvbmZpZygpLnNldCh7bG9vcDotMSwgdm9sdW1lOjAuN30pO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHNldFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQSBnZW5lcmljIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gY29weSB0byB0aGUgUGxheVByb3BzQ29uZmlnIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtQbGF5UHJvcHNDb25maWd9IFJldHVybnMgdGhlIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0Ki9cblx0cC5zZXQgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdGZvciAodmFyIG4gaW4gcHJvcHMpIHsgdGhpc1tuXSA9IHByb3BzW25dOyB9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltQbGF5UHJvcHNDb25maWddXCI7XG5cdH07XG5cblx0Y3JlYXRlanMuUGxheVByb3BzQ29uZmlnID0gcztcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNvdW5kLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogVGhlIFNvdW5kIGNsYXNzIGlzIHRoZSBwdWJsaWMgQVBJIGZvciBjcmVhdGluZyBzb3VuZHMsIGNvbnRyb2xsaW5nIHRoZSBvdmVyYWxsIHNvdW5kIGxldmVscywgYW5kIG1hbmFnaW5nIHBsdWdpbnMuXG5cdCAqIEFsbCBTb3VuZCBBUElzIG9uIHRoaXMgY2xhc3MgYXJlIHN0YXRpYy5cblx0ICpcblx0ICogPGI+UmVnaXN0ZXJpbmcgYW5kIFByZWxvYWRpbmc8L2I+PGJyIC8+XG5cdCAqIEJlZm9yZSB5b3UgY2FuIHBsYXkgYSBzb3VuZCwgaXQgPGI+bXVzdDwvYj4gYmUgcmVnaXN0ZXJlZC4gWW91IGNhbiBkbyB0aGlzIHdpdGgge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVnaXN0ZXJTb3VuZFwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogb3IgcmVnaXN0ZXIgbXVsdGlwbGUgc291bmRzIHVzaW5nIHt7I2Nyb3NzTGluayBcIlNvdW5kL3JlZ2lzdGVyU291bmRzXCJ9fXt7L2Nyb3NzTGlua319LiBJZiB5b3UgZG9uJ3QgcmVnaXN0ZXIgYVxuXHQgKiBzb3VuZCBwcmlvciB0byBhdHRlbXB0aW5nIHRvIHBsYXkgaXQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiU291bmQvcGxheVwifX17ey9jcm9zc0xpbmt9fSBvciBjcmVhdGUgaXQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiU291bmQvY3JlYXRlSW5zdGFuY2VcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIHRoZSBzb3VuZCBzb3VyY2Ugd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHJlZ2lzdGVyZWQgYnV0IHBsYXliYWNrIHdpbGwgZmFpbCBhcyB0aGUgc291cmNlIHdpbGwgbm90IGJlIHJlYWR5LiBJZiB5b3UgdXNlXG5cdCAqIDxhIGhyZWY9XCJodHRwOi8vcHJlbG9hZGpzLmNvbVwiIHRhcmdldD1cIl9ibGFua1wiPlByZWxvYWRKUzwvYT4sIHJlZ2lzdHJhdGlvbiBpcyBoYW5kbGVkIGZvciB5b3Ugd2hlbiB0aGUgc291bmQgaXNcblx0ICogcHJlbG9hZGVkLiBJdCBpcyByZWNvbW1lbmRlZCB0byBwcmVsb2FkIHNvdW5kcyBlaXRoZXIgaW50ZXJuYWxseSB1c2luZyB0aGUgcmVnaXN0ZXIgZnVuY3Rpb25zIG9yIGV4dGVybmFsbHkgdXNpbmdcblx0ICogUHJlbG9hZEpTIHNvIHRoZXkgYXJlIHJlYWR5IHdoZW4geW91IHdhbnQgdG8gdXNlIHRoZW0uXG5cdCAqXG5cdCAqIDxiPlBsYXliYWNrPC9iPjxiciAvPlxuXHQgKiBUbyBwbGF5IGEgc291bmQgb25jZSBpdCdzIGJlZW4gcmVnaXN0ZXJlZCBhbmQgcHJlbG9hZGVkLCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIlNvdW5kL3BsYXlcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuXHQgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlXCJ9fXt7L2Nyb3NzTGlua319IHdoaWNoIGNhbiBiZSBwYXVzZWQsIHJlc3VtZWQsIG11dGVkLCBldGMuXG5cdCAqIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fSBkb2N1bWVudGF0aW9uIGZvciBtb3JlIG9uIHRoZSBpbnN0YW5jZSBjb250cm9sIEFQSXMuXG5cdCAqXG5cdCAqIDxiPlBsdWdpbnM8L2I+PGJyIC8+XG5cdCAqIEJ5IGRlZmF1bHQsIHRoZSB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fSBvciB0aGUge3sjY3Jvc3NMaW5rIFwiSFRNTEF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGFyZSB1c2VkICh3aGVuIGF2YWlsYWJsZSksIGFsdGhvdWdoIGRldmVsb3BlcnMgY2FuIGNoYW5nZSBwbHVnaW4gcHJpb3JpdHkgb3IgYWRkIG5ldyBwbHVnaW5zIChzdWNoIGFzIHRoZVxuXHQgKiBwcm92aWRlZCB7eyNjcm9zc0xpbmsgXCJGbGFzaEF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319KS4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiU291bmRcIn19e3svY3Jvc3NMaW5rfX0gQVBJXG5cdCAqIG1ldGhvZHMgZm9yIG1vcmUgb24gdGhlIHBsYXliYWNrIGFuZCBwbHVnaW4gQVBJcy4gVG8gaW5zdGFsbCBwbHVnaW5zLCBvciBzcGVjaWZ5IGEgZGlmZmVyZW50IHBsdWdpbiBvcmRlciwgc2VlXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNvdW5kL2luc3RhbGxQbHVnaW5zXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuRmxhc2hBdWRpb1BsdWdpbi5zd2ZQYXRoID0gXCIuLi9zcmMvc291bmRqcy9mbGFzaGF1ZGlvXCI7XG5cdCAqICAgICAgY3JlYXRlanMuU291bmQucmVnaXN0ZXJQbHVnaW5zKFtjcmVhdGVqcy5XZWJBdWRpb1BsdWdpbiwgY3JlYXRlanMuRmxhc2hBdWRpb1BsdWdpbl0pO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLmFsdGVybmF0ZUV4dGVuc2lvbnMgPSBbXCJtcDNcIl07XG5cdCAqICAgICAgY3JlYXRlanMuU291bmQub24oXCJmaWxlbG9hZFwiLCB0aGlzLmxvYWRIYW5kbGVyLCB0aGlzKTtcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5yZWdpc3RlclNvdW5kKFwicGF0aC90by9teVNvdW5kLm9nZ1wiLCBcInNvdW5kXCIpO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGxvYWRIYW5kbGVyKGV2ZW50KSB7XG4gICAgICogICAgICAgICAgLy8gVGhpcyBpcyBmaXJlZCBmb3IgZWFjaCBzb3VuZCB0aGF0IGlzIHJlZ2lzdGVyZWQuXG4gICAgICogICAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlanMuU291bmQucGxheShcInNvdW5kXCIpOyAgLy8gcGxheSB1c2luZyBpZC4gIENvdWxkIGFsc28gdXNlIGZ1bGwgc291cmNlIHBhdGggb3IgZXZlbnQuc3JjLlxuICAgICAqICAgICAgICAgIGluc3RhbmNlLm9uKFwiY29tcGxldGVcIiwgdGhpcy5oYW5kbGVDb21wbGV0ZSwgdGhpcyk7XG4gICAgICogICAgICAgICAgaW5zdGFuY2Uudm9sdW1lID0gMC41O1xuXHQgKiAgICAgIH1cblx0ICpcblx0ICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbmN1cnJlbnRseSBwbGF5aW5nIGluc3RhbmNlcyBvZiB0aGUgc2FtZSBzb3VuZCBjYW4gYmUgc3BlY2lmaWVkIGluIHRoZSBcImRhdGFcIiBhcmd1bWVudFxuXHQgKiBvZiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZWdpc3RlclNvdW5kXCJ9fXt7L2Nyb3NzTGlua319LiAgTm90ZSB0aGF0IGlmIG5vdCBzcGVjaWZpZWQsIHRoZSBhY3RpdmUgcGx1Z2luIHdpbGwgYXBwbHlcblx0ICogYSBkZWZhdWx0IGxpbWl0LiAgQ3VycmVudGx5IEhUTUxBdWRpb1BsdWdpbiBzZXRzIGEgZGVmYXVsdCBsaW1pdCBvZiAyLCB3aGlsZSBXZWJBdWRpb1BsdWdpbiBhbmQgRmxhc2hBdWRpb1BsdWdpbiBzZXQgYVxuXHQgKiBkZWZhdWx0IGxpbWl0IG9mIDEwMC5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5yZWdpc3RlclNvdW5kKFwic291bmQubXAzXCIsIFwic291bmRJZFwiLCA0KTtcblx0ICpcblx0ICogU291bmQgY2FuIGJlIHVzZWQgYXMgYSBwbHVnaW4gd2l0aCBQcmVsb2FkSlMgdG8gaGVscCBwcmVsb2FkIGF1ZGlvIHByb3Blcmx5LiBBdWRpbyBwcmVsb2FkZWQgd2l0aCBQcmVsb2FkSlMgaXNcblx0ICogYXV0b21hdGljYWxseSByZWdpc3RlcmVkIHdpdGggdGhlIFNvdW5kIGNsYXNzLiBXaGVuIGF1ZGlvIGlzIG5vdCBwcmVsb2FkZWQsIFNvdW5kIHdpbGwgZG8gYW4gYXV0b21hdGljIGludGVybmFsXG5cdCAqIGxvYWQuIEFzIGEgcmVzdWx0LCBpdCBtYXkgZmFpbCB0byBwbGF5IHRoZSBmaXJzdCB0aW1lIHBsYXkgaXMgY2FsbGVkIGlmIHRoZSBhdWRpbyBpcyBub3QgZmluaXNoZWQgbG9hZGluZy4gVXNlXG5cdCAqIHRoZSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCB0byBkZXRlcm1pbmUgd2hlbiBhIHNvdW5kIGhhcyBmaW5pc2hlZCBpbnRlcm5hbGx5XG5cdCAqIHByZWxvYWRpbmcuIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgYWxsIGF1ZGlvIGlzIHByZWxvYWRlZCBiZWZvcmUgaXQgaXMgcGxheWVkLlxuXHQgKlxuXHQgKiAgICAgIHZhciBxdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUoKTtcblx0ICpcdFx0cXVldWUuaW5zdGFsbFBsdWdpbihjcmVhdGVqcy5Tb3VuZCk7XG5cdCAqXG5cdCAqIDxiPkF1ZGlvIFNwcml0ZXM8L2I+PGJyIC8+XG5cdCAqIFNvdW5kSlMgaGFzIGFkZGVkIHN1cHBvcnQgZm9yIHt7I2Nyb3NzTGluayBcIkF1ZGlvU3ByaXRlXCJ9fXt7L2Nyb3NzTGlua319LCBhdmFpbGFibGUgYXMgb2YgdmVyc2lvbiAwLjYuMC5cblx0ICogRm9yIHRob3NlIHVuZmFtaWxpYXIgd2l0aCBhdWRpbyBzcHJpdGVzLCB0aGV5IGFyZSBtdWNoIGxpa2UgQ1NTIHNwcml0ZXMgb3Igc3ByaXRlIHNoZWV0czogbXVsdGlwbGUgYXVkaW8gYXNzZXRzXG5cdCAqIGdyb3VwZWQgaW50byBhIHNpbmdsZSBmaWxlLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqXHRcdHZhciBhc3NldHNQYXRoID0gXCIuL2Fzc2V0cy9cIjtcblx0ICpcdFx0dmFyIHNvdW5kcyA9IFt7XG5cdCAqXHRcdFx0c3JjOlwiTXlBdWRpb1Nwcml0ZS5vZ2dcIiwgZGF0YToge1xuXHQgKlx0XHRcdFx0YXVkaW9TcHJpdGU6IFtcblx0ICpcdFx0XHRcdFx0e2lkOlwic291bmQxXCIsIHN0YXJ0VGltZTowLCBkdXJhdGlvbjo1MDB9LFxuXHQgKlx0XHRcdFx0XHR7aWQ6XCJzb3VuZDJcIiwgc3RhcnRUaW1lOjEwMDAsIGR1cmF0aW9uOjQwMH0sXG5cdCAqXHRcdFx0XHRcdHtpZDpcInNvdW5kM1wiLCBzdGFydFRpbWU6MTcwMCwgZHVyYXRpb246IDEwMDB9XG5cdCAqXHRcdFx0XHRdfVxuIFx0ICpcdFx0XHR9XG5cdCAqXHRcdF07XG5cdCAqXHRcdGNyZWF0ZWpzLlNvdW5kLmFsdGVybmF0ZUV4dGVuc2lvbnMgPSBbXCJtcDNcIl07XG5cdCAqXHRcdGNyZWF0ZWpzLlNvdW5kLm9uKFwiZmlsZWxvYWRcIiwgbG9hZFNvdW5kKTtcblx0ICpcdFx0Y3JlYXRlanMuU291bmQucmVnaXN0ZXJTb3VuZHMoc291bmRzLCBhc3NldHNQYXRoKTtcblx0ICpcdFx0Ly8gYWZ0ZXIgbG9hZCBpcyBjb21wbGV0ZVxuXHQgKlx0XHRjcmVhdGVqcy5Tb3VuZC5wbGF5KFwic291bmQyXCIpO1xuXHQgKlxuXHQgKiA8Yj5Nb2JpbGUgUGxheWJhY2s8L2I+PGJyIC8+XG5cdCAqIERldmljZXMgcnVubmluZyBpT1MgcmVxdWlyZSB0aGUgV2ViQXVkaW8gY29udGV4dCB0byBiZSBcInVubG9ja2VkXCIgYnkgcGxheWluZyBhdCBsZWFzdCBvbmUgc291bmQgaW5zaWRlIG9mIGEgdXNlci1cblx0ICogaW5pdGlhdGVkIGV2ZW50IChzdWNoIGFzIHRvdWNoL2NsaWNrKS4gRWFybGllciB2ZXJzaW9ucyBvZiBTb3VuZEpTIGluY2x1ZGVkIGEgXCJNb2JpbGVTYWZlXCIgc2FtcGxlLCBidXQgdGhpcyBpcyBub1xuXHQgKiBsb25nZXIgbmVjZXNzYXJ5IGFzIG9mIFNvdW5kSlMgMC42LjIuXG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5cblx0ICogICAgICAgICBJbiBTb3VuZEpTIDAuNC4xIGFuZCBhYm92ZSwgeW91IGNhbiBlaXRoZXIgaW5pdGlhbGl6ZSBwbHVnaW5zIG9yIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9QbHVnaW4vcGxheUVtcHR5U291bmRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogICAgICAgICBtZXRob2QgaW4gdGhlIGNhbGwgc3RhY2sgb2YgYSB1c2VyIGlucHV0IGV2ZW50IHRvIG1hbnVhbGx5IHVubG9jayB0aGUgYXVkaW8gY29udGV4dC5cblx0ICogICAgIDwvbGk+XG5cdCAqICAgICA8bGk+XG5cdCAqICAgICAgICAgSW4gU291bmRKUyAwLjYuMiBhbmQgYWJvdmUsIFNvdW5kSlMgd2lsbCBhdXRvbWF0aWNhbGx5IGxpc3RlbiBmb3IgdGhlIGZpcnN0IGRvY3VtZW50LWxldmVsIFwibW91c2Vkb3duXCJcblx0ICogICAgICAgICBhbmQgXCJ0b3VjaGVuZFwiIGV2ZW50LCBhbmQgdW5sb2NrIFdlYkF1ZGlvLiBUaGlzIHdpbGwgY29udGludWUgdG8gY2hlY2sgdGhlc2UgZXZlbnRzIHVudGlsIHRoZSBXZWJBdWRpb1xuXHQgKiAgICAgICAgIGNvbnRleHQgYmVjb21lcyBcInVubG9ja2VkXCIgKGNoYW5nZXMgZnJvbSBcInN1c3BlbmRlZFwiIHRvIFwicnVubmluZ1wiKVxuXHQgKiAgICAgPC9saT5cblx0ICogICAgIDxsaT5cblx0ICogICAgICAgICBCb3RoIHRoZSBcIm1vdXNlZG93blwiIGFuZCBcInRvdWNoZW5kXCIgZXZlbnRzIGNhbiBiZSB1c2VkIHRvIHVubG9jayBhdWRpbyBpbiBpT1M5KywgdGhlIFwidG91Y2hzdGFydFwiIGV2ZW50XG5cdCAqICAgICAgICAgd2lsbCB3b3JrIGluIGlPUzggYW5kIGJlbG93LiBUaGUgXCJ0b3VjaGVuZFwiIGV2ZW50IHdpbGwgb25seSB3b3JrIGluIGlPUzkgd2hlbiB0aGUgZ2VzdHVyZSBpcyBpbnRlcnByZXRlZFxuXHQgKiAgICAgICAgIGFzIGEgXCJjbGlja1wiLCBzbyBpZiB0aGUgdXNlciBsb25nLXByZXNzZXMgdGhlIGJ1dHRvbiwgaXQgd2lsbCBubyBsb25nZXIgd29yay5cblx0ICogICAgIDwvbGk+XG5cdCAqICAgICA8bGk+XG5cdCAqICAgICAgICAgV2hlbiB1c2luZyB0aGUgPGEgaHJlZj1cImh0dHA6Ly93d3cuY3JlYXRlanMuY29tL2RvY3MvZWFzZWxqcy9jbGFzc2VzL1RvdWNoLmh0bWxcIj5FYXNlbEpTIFRvdWNoIGNsYXNzPC9hPixcblx0ICogICAgICAgICB0aGUgXCJtb3VzZWRvd25cIiBldmVudCB3aWxsIG5vdCBmaXJlIHdoZW4gYSBjYW52YXMgaXMgY2xpY2tlZCwgc2luY2UgTW91c2VFdmVudHMgYXJlIHByZXZlbnRlZCwgdG8gZW5zdXJlXG5cdCAqICAgICAgICAgb25seSB0b3VjaCBldmVudHMgZmlyZS4gVG8gZ2V0IGFyb3VuZCB0aGlzLCB5b3UgY2FuIGVpdGhlciByZWx5IG9uIFwidG91Y2hlbmRcIiwgb3I6XG5cdCAqICAgICAgICAgPG9sPlxuXHQgKiAgICAgICAgICAgICA8bGk+U2V0IHRoZSBgYWxsb3dEZWZhdWx0YCBwcm9wZXJ0eSBvbiB0aGUgVG91Y2ggY2xhc3MgY29uc3RydWN0b3IgdG8gYHRydWVgIChkZWZhdWx0cyB0byBgZmFsc2VgKS48L2xpPlxuXHQgKiAgICAgICAgICAgICA8bGk+U2V0IHRoZSBgcHJldmVudFNlbGVjdGlvbmAgcHJvcGVydHkgb24gdGhlIEVhc2VsSlMgYFN0YWdlYCB0byBgZmFsc2VgLjwvbGk+XG5cdCAqICAgICAgICAgPC9vbD5cblx0ICogICAgICAgICBUaGVzZSBzZXR0aW5ncyBtYXkgY2hhbmdlIGhvdyB5b3VyIGFwcGxpY2F0aW9uIGJlaGF2ZXMsIGFuZCBhcmUgbm90IHJlY29tbWVuZGVkLlxuXHQgKiAgICAgPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogPGI+TG9hZGluZyBBbHRlcm5hdGUgUGF0aHMgYW5kIEV4dGVuc2lvbi1sZXNzIEZpbGVzPC9iPjxiciAvPlxuXHQgKiBTb3VuZEpTIHN1cHBvcnRzIGxvYWRpbmcgYWx0ZXJuYXRlIHBhdGhzIGFuZCBleHRlbnNpb24tbGVzcyBmaWxlcyBieSBwYXNzaW5nIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGEgc3RyaW5nIGZvclxuXHQgKiB0aGUgYHNyY2AgcHJvcGVydHksIHdoaWNoIGlzIGEgaGFzaCB1c2luZyB0aGUgZm9ybWF0IGB7ZXh0ZW5zaW9uOlwicGF0aFwiLCBleHRlbnNpb24yOlwicGF0aDJcIn1gLiBUaGVzZSBsYWJlbHMgYXJlXG5cdCAqIGhvdyBTb3VuZEpTIGRldGVybWluZXMgaWYgdGhlIGJyb3dzZXIgd2lsbCBzdXBwb3J0IHRoZSBzb3VuZC4gVGhpcyBhbHNvIGVuYWJsZXMgbXVsdGlwbGUgZm9ybWF0cyB0byBsaXZlIGluXG5cdCAqIGRpZmZlcmVudCBmb2xkZXJzLCBvciBvbiBDRE5zLCB3aGljaCBvZnRlbiBoYXMgY29tcGxldGVseSBkaWZmZXJlbnQgZmlsZW5hbWVzIGZvciBlYWNoIGZpbGUuXG5cdCAqXG5cdCAqIFByaW9yaXR5IGlzIGRldGVybWluZWQgYnkgdGhlIHByb3BlcnR5IG9yZGVyIChmaXJzdCBwcm9wZXJ0eSBpcyB0cmllZCBmaXJzdCkuICBUaGlzIGlzIHN1cHBvcnRlZCBieSBib3RoIGludGVybmFsIGxvYWRpbmdcblx0ICogYW5kIGxvYWRpbmcgd2l0aCBQcmVsb2FkSlMuXG5cdCAqXG5cdCAqIDxlbT5Ob3RlOiBhbiBpZCBpcyByZXF1aXJlZCBmb3IgcGxheWJhY2suPC9lbT5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKlx0XHR2YXIgc291bmRzID0ge3BhdGg6XCIuL2F1ZGlvUGF0aC9cIixcblx0ICogXHRcdFx0XHRtYW5pZmVzdDogW1xuXHQgKlx0XHRcdFx0e2lkOiBcImNvb2xcIiwgc3JjOiB7bXAzOlwibXAzL2F3ZXNvbWUubXAzXCIsIG9nZzpcIm5vRXh0ZW5zaW9uT2dnRmlsZVwifX1cblx0ICpcdFx0XX07XG5cdCAqXG5cdCAqXHRcdGNyZWF0ZWpzLlNvdW5kLmFsdGVybmF0ZUV4dGVuc2lvbnMgPSBbXCJtcDNcIl07XG5cdCAqXHRcdGNyZWF0ZWpzLlNvdW5kLmFkZEV2ZW50TGlzdGVuZXIoXCJmaWxlbG9hZFwiLCBoYW5kbGVMb2FkKTtcblx0ICpcdFx0Y3JlYXRlanMuU291bmQucmVnaXN0ZXJTb3VuZHMoc291bmRzKTtcblx0ICpcblx0ICogPGgzPktub3duIEJyb3dzZXIgYW5kIE9TIGlzc3VlczwvaDM+XG5cdCAqIDxiPklFIDkgSFRNTCBBdWRpbyBsaW1pdGF0aW9uczwvYj48YnIgLz5cblx0ICogPHVsPjxsaT5UaGVyZSBpcyBhIGRlbGF5IGluIGFwcGx5aW5nIHZvbHVtZSBjaGFuZ2VzIHRvIHRhZ3MgdGhhdCBvY2N1cnMgb25jZSBwbGF5YmFjayBpcyBzdGFydGVkLiBTbyBpZiB5b3UgaGF2ZVxuXHQgKiBtdXRlZCBhbGwgc291bmRzLCB0aGV5IHdpbGwgYWxsIHBsYXkgZHVyaW5nIHRoaXMgZGVsYXkgdW50aWwgdGhlIG11dGUgYXBwbGllcyBpbnRlcm5hbGx5LiBUaGlzIGhhcHBlbnMgcmVnYXJkbGVzcyBvZlxuXHQgKiB3aGVuIG9yIGhvdyB5b3UgYXBwbHkgdGhlIHZvbHVtZSBjaGFuZ2UsIGFzIHRoZSB0YWcgc2VlbXMgdG8gbmVlZCB0byBwbGF5IHRvIGFwcGx5IGl0LjwvbGk+XG4gICAgICogPGxpPk1QMyBlbmNvZGluZyB3aWxsIG5vdCBhbHdheXMgd29yayBmb3IgYXVkaW8gdGFncywgcGFydGljdWxhcmx5IGluIEludGVybmV0IEV4cGxvcmVyLiBXZSd2ZSBmb3VuZCBkZWZhdWx0XG5cdCAqIGVuY29kaW5nIHdpdGggNjRrYnBzIHdvcmtzLjwvbGk+XG5cdCAqIDxsaT5PY2Nhc2lvbmFsbHkgdmVyeSBzaG9ydCBzYW1wbGVzIHdpbGwgZ2V0IGN1dCBvZmYuPC9saT5cblx0ICogPGxpPlRoZXJlIGlzIGEgbGltaXQgdG8gaG93IG1hbnkgYXVkaW8gdGFncyB5b3UgY2FuIGxvYWQgYW5kIHBsYXkgYXQgb25jZSwgd2hpY2ggYXBwZWFycyB0byBiZSBkZXRlcm1pbmVkIGJ5XG5cdCAqIGhhcmR3YXJlIGFuZCBicm93c2VyIHNldHRpbmdzLiAgU2VlIHt7I2Nyb3NzTGluayBcIkhUTUxBdWRpb1BsdWdpbi5NQVhfSU5TVEFOQ0VTXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhIHNhZmVcblx0ICogZXN0aW1hdGUuPC9saT48L3VsPlxuXHQgKlxuXHQgKiA8Yj5GaXJlZm94IDI1IFdlYiBBdWRpbyBsaW1pdGF0aW9uczwvYj5cblx0ICogPHVsPjxsaT5tcDMgYXVkaW8gZmlsZXMgZG8gbm90IGxvYWQgcHJvcGVybHkgb24gYWxsIHdpbmRvd3MgbWFjaGluZXMsIHJlcG9ydGVkXG5cdCAqIDxhIGhyZWY9XCJodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD05Mjk5NjlcIiB0YXJnZXQ9XCJfYmxhbmtcIj5oZXJlPC9hPi4gPC9icj5cblx0ICogRm9yIHRoaXMgcmVhc29uIGl0IGlzIHJlY29tbWVuZGVkIHRvIHBhc3MgYW5vdGhlciBGRiBzdXBwb3J0ZWQgdHlwZSAoaWUgb2dnKSBmaXJzdCB1bnRpbCB0aGlzIGJ1ZyBpcyByZXNvbHZlZCwgaWZcblx0ICogcG9zc2libGUuPC9saT48L3VsPlxuXG5cdCAqIDxiPlNhZmFyaSBsaW1pdGF0aW9uczwvYj48YnIgLz5cblx0ICogPHVsPjxsaT5TYWZhcmkgcmVxdWlyZXMgUXVpY2t0aW1lIHRvIGJlIGluc3RhbGxlZCBmb3IgYXVkaW8gcGxheWJhY2suPC9saT48L3VsPlxuXHQgKlxuXHQgKiA8Yj5pT1MgNiBXZWIgQXVkaW8gbGltaXRhdGlvbnM8L2I+PGJyIC8+XG5cdCAqIDx1bD48bGk+U291bmQgaXMgaW5pdGlhbGx5IGxvY2tlZCwgYW5kIG11c3QgYmUgdW5sb2NrZWQgdmlhIGEgdXNlci1pbml0aWF0ZWQgZXZlbnQuIFBsZWFzZSBzZWUgdGhlIHNlY3Rpb24gb25cblx0ICogTW9iaWxlIFBsYXliYWNrIGFib3ZlLjwvbGk+XG5cdCAqIDxsaT5BIGJ1ZyBleGlzdHMgdGhhdCB3aWxsIGRpc3RvcnQgdW4tY2FjaGVkIHdlYiBhdWRpbyB3aGVuIGEgdmlkZW8gZWxlbWVudCBpcyBwcmVzZW50IGluIHRoZSBET00gdGhhdCBoYXMgYXVkaW9cblx0ICogYXQgYSBkaWZmZXJlbnQgc2FtcGxlUmF0ZS48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiA8Yj5BbmRyb2lkIEhUTUwgQXVkaW8gbGltaXRhdGlvbnM8L2I+PGJyIC8+XG5cdCAqIDx1bD48bGk+V2UgaGF2ZSBubyBjb250cm9sIG92ZXIgYXVkaW8gdm9sdW1lLiBPbmx5IHRoZSB1c2VyIGNhbiBzZXQgdm9sdW1lIG9uIHRoZWlyIGRldmljZS48L2xpPlxuXHQgKiA8bGk+V2UgY2FuIG9ubHkgcGxheSBhdWRpbyBpbnNpZGUgYSB1c2VyIGV2ZW50ICh0b3VjaC9jbGljaykuICBUaGlzIGN1cnJlbnRseSBtZWFucyB5b3UgY2Fubm90IGxvb3Agc291bmQgb3IgdXNlXG5cdCAqIGEgZGVsYXkuPC9saT48L3VsPlxuXHQgKlxuXHQgKiA8Yj5XZWIgQXVkaW8gYW5kIFByZWxvYWRKUzwvYj48YnIgLz5cblx0ICogPHVsPjxsaT5XZWIgQXVkaW8gbXVzdCBiZSBsb2FkZWQgdGhyb3VnaCBYSFIsIHRoZXJlZm9yZSB3aGVuIHVzZWQgd2l0aCBQcmVsb2FkSlMsIHRhZyBsb2FkaW5nIGlzIG5vdCBwb3NzaWJsZS5cblx0ICogVGhpcyBtZWFucyB0aGF0IHRhZyBsb2FkaW5nIGNhbiBub3QgYmUgdXNlZCB0byBhdm9pZCBjcm9zcyBkb21haW4gaXNzdWVzLjwvbGk+PHVsPlxuXHQgKlxuXHQgKiBAY2xhc3MgU291bmRcblx0ICogQHN0YXRpY1xuXHQgKiBAdXNlcyBFdmVudERpc3BhdGNoZXJcblx0ICovXG5cdGZ1bmN0aW9uIFNvdW5kKCkge1xuXHRcdHRocm93IFwiU291bmQgY2Fubm90IGJlIGluc3RhbnRpYXRlZFwiO1xuXHR9XG5cblx0dmFyIHMgPSBTb3VuZDtcblxuXG4vLyBTdGF0aWMgUHJvcGVydGllc1xuXHQvKipcblx0ICogVGhlIGludGVycnVwdCB2YWx1ZSB0byBpbnRlcnJ1cHQgYW55IGN1cnJlbnRseSBwbGF5aW5nIGluc3RhbmNlIHdpdGggdGhlIHNhbWUgc291cmNlLCBpZiB0aGUgbWF4aW11bSBudW1iZXIgb2Zcblx0ICogaW5zdGFuY2VzIG9mIHRoZSBzb3VuZCBhcmUgYWxyZWFkeSBwbGF5aW5nLlxuXHQgKiBAcHJvcGVydHkgSU5URVJSVVBUX0FOWVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBhbnlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5JTlRFUlJVUFRfQU5ZID0gXCJhbnlcIjtcblxuXHQvKipcblx0ICogVGhlIGludGVycnVwdCB2YWx1ZSB0byBpbnRlcnJ1cHQgdGhlIGVhcmxpZXN0IGN1cnJlbnRseSBwbGF5aW5nIGluc3RhbmNlIHdpdGggdGhlIHNhbWUgc291cmNlIHRoYXQgcHJvZ3Jlc3NlZCB0aGVcblx0ICogbGVhc3QgZGlzdGFuY2UgaW4gdGhlIGF1ZGlvIHRyYWNrLCBpZiB0aGUgbWF4aW11bSBudW1iZXIgb2YgaW5zdGFuY2VzIG9mIHRoZSBzb3VuZCBhcmUgYWxyZWFkeSBwbGF5aW5nLlxuXHQgKiBAcHJvcGVydHkgSU5URVJSVVBUX0VBUkxZXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGVhcmx5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuSU5URVJSVVBUX0VBUkxZID0gXCJlYXJseVwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgaW50ZXJydXB0IHZhbHVlIHRvIGludGVycnVwdCB0aGUgY3VycmVudGx5IHBsYXlpbmcgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBzb3VyY2UgdGhhdCBwcm9ncmVzc2VkIHRoZSBtb3N0XG5cdCAqIGRpc3RhbmNlIGluIHRoZSBhdWRpbyB0cmFjaywgaWYgdGhlIG1heGltdW0gbnVtYmVyIG9mIGluc3RhbmNlcyBvZiB0aGUgc291bmQgYXJlIGFscmVhZHkgcGxheWluZy5cblx0ICogQHByb3BlcnR5IElOVEVSUlVQVF9MQVRFXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGxhdGVcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5JTlRFUlJVUFRfTEFURSA9IFwibGF0ZVwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgaW50ZXJydXB0IHZhbHVlIHRvIG5vdCBpbnRlcnJ1cHQgYW55IGN1cnJlbnRseSBwbGF5aW5nIGluc3RhbmNlcyB3aXRoIHRoZSBzYW1lIHNvdXJjZSwgaWYgdGhlIG1heGltdW0gbnVtYmVyIG9mXG5cdCAqIGluc3RhbmNlcyBvZiB0aGUgc291bmQgYXJlIGFscmVhZHkgcGxheWluZy5cblx0ICogQHByb3BlcnR5IElOVEVSUlVQVF9OT05FXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IG5vbmVcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5JTlRFUlJVUFRfTk9ORSA9IFwibm9uZVwiO1xuXG5cdC8qKlxuXHQgKiBEZWZpbmVzIHRoZSBwbGF5U3RhdGUgb2YgYW4gaW5zdGFuY2UgdGhhdCBpcyBzdGlsbCBpbml0aWFsaXppbmcuXG5cdCAqIEBwcm9wZXJ0eSBQTEFZX0lOSVRFRFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBwbGF5SW5pdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuUExBWV9JTklURUQgPSBcInBsYXlJbml0ZWRcIjtcblxuXHQvKipcblx0ICogRGVmaW5lcyB0aGUgcGxheVN0YXRlIG9mIGFuIGluc3RhbmNlIHRoYXQgaXMgY3VycmVudGx5IHBsYXlpbmcgb3IgcGF1c2VkLlxuXHQgKiBAcHJvcGVydHkgUExBWV9TVUNDRUVERURcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgcGxheVN1Y2NlZWRlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLlBMQVlfU1VDQ0VFREVEID0gXCJwbGF5U3VjY2VlZGVkXCI7XG5cblx0LyoqXG5cdCAqIERlZmluZXMgdGhlIHBsYXlTdGF0ZSBvZiBhbiBpbnN0YW5jZSB0aGF0IHdhcyBpbnRlcnJ1cHRlZCBieSBhbm90aGVyIGluc3RhbmNlLlxuXHQgKiBAcHJvcGVydHkgUExBWV9JTlRFUlJVUFRFRFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBwbGF5SW50ZXJydXB0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5QTEFZX0lOVEVSUlVQVEVEID0gXCJwbGF5SW50ZXJydXB0ZWRcIjtcblxuXHQvKipcblx0ICogRGVmaW5lcyB0aGUgcGxheVN0YXRlIG9mIGFuIGluc3RhbmNlIHRoYXQgY29tcGxldGVkIHBsYXliYWNrLlxuXHQgKiBAcHJvcGVydHkgUExBWV9GSU5JU0hFRFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBwbGF5RmluaXNoZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5QTEFZX0ZJTklTSEVEID0gXCJwbGF5RmluaXNoZWRcIjtcblxuXHQvKipcblx0ICogRGVmaW5lcyB0aGUgcGxheVN0YXRlIG9mIGFuIGluc3RhbmNlIHRoYXQgZmFpbGVkIHRvIHBsYXkuIFRoaXMgaXMgdXN1YWxseSBjYXVzZWQgYnkgYSBsYWNrIG9mIGF2YWlsYWJsZSBjaGFubmVsc1xuXHQgKiB3aGVuIHRoZSBpbnRlcnJ1cHQgbW9kZSB3YXMgXCJJTlRFUlJVUFRfTk9ORVwiLCB0aGUgcGxheWJhY2sgc3RhbGxlZCwgb3IgdGhlIHNvdW5kIGNvdWxkIG5vdCBiZSBmb3VuZC5cblx0ICogQHByb3BlcnR5IFBMQVlfRkFJTEVEXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHBsYXlGYWlsZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5QTEFZX0ZBSUxFRCA9IFwicGxheUZhaWxlZFwiO1xuXG5cdC8qKlxuXHQgKiBBIGxpc3Qgb2YgdGhlIGRlZmF1bHQgc3VwcG9ydGVkIGV4dGVuc2lvbnMgdGhhdCBTb3VuZCB3aWxsIDxpPnRyeTwvaT4gdG8gcGxheS4gUGx1Z2lucyB3aWxsIGNoZWNrIGlmIHRoZSBicm93c2VyXG5cdCAqIGNhbiBwbGF5IHRoZXNlIHR5cGVzLCBzbyBtb2RpZnlpbmcgdGhpcyBsaXN0IGJlZm9yZSBhIHBsdWdpbiBpcyBpbml0aWFsaXplZCB3aWxsIGFsbG93IHRoZSBwbHVnaW5zIHRvIHRyeSB0b1xuXHQgKiBzdXBwb3J0IGFkZGl0aW9uYWwgbWVkaWEgdHlwZXMuXG5cdCAqXG5cdCAqIE5PVEUgdGhpcyBkb2VzIG5vdCBjdXJyZW50bHkgd29yayBmb3Ige3sjY3Jvc3NMaW5rIFwiRmxhc2hBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogTW9yZSBkZXRhaWxzIG9uIGZpbGUgZm9ybWF0cyBjYW4gYmUgZm91bmQgYXQgPGEgaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQXVkaW9fZmlsZV9mb3JtYXRcIiB0YXJnZXQ9XCJfYmxhbmtcIj5odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0F1ZGlvX2ZpbGVfZm9ybWF0PC9hPi48YnIgLz5cblx0ICogQSB2ZXJ5IGRldGFpbGVkIGxpc3Qgb2YgZmlsZSBmb3JtYXRzIGNhbiBiZSBmb3VuZCBhdCA8YSBocmVmPVwiaHR0cDovL3d3dy5maWxlaW5mby5jb20vZmlsZXR5cGVzL2F1ZGlvXCIgdGFyZ2V0PVwiX2JsYW5rXCI+aHR0cDovL3d3dy5maWxlaW5mby5jb20vZmlsZXR5cGVzL2F1ZGlvPC9hPi5cblx0ICogQHByb3BlcnR5IFNVUFBPUlRFRF9FWFRFTlNJT05TXG5cdCAqIEB0eXBlIHtBcnJheVtTdHJpbmddfVxuXHQgKiBAZGVmYXVsdCBbXCJtcDNcIiwgXCJvZ2dcIiwgXCJvcHVzXCIsIFwibXBlZ1wiLCBcIndhdlwiLCBcIm00YVwiLCBcIm1wNFwiLCBcImFpZmZcIiwgXCJ3bWFcIiwgXCJtaWRcIl1cblx0ICogQHNpbmNlIDAuNC4wXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuU1VQUE9SVEVEX0VYVEVOU0lPTlMgPSBbXCJtcDNcIiwgXCJvZ2dcIiwgXCJvcHVzXCIsIFwibXBlZ1wiLCBcIndhdlwiLCBcIm00YVwiLCBcIm1wNFwiLCBcImFpZmZcIiwgXCJ3bWFcIiwgXCJtaWRcIl07XG5cblx0LyoqXG5cdCAqIFNvbWUgZXh0ZW5zaW9ucyB1c2UgYW5vdGhlciB0eXBlIG9mIGV4dGVuc2lvbiBzdXBwb3J0IHRvIHBsYXkgKG9uZSBvZiB0aGVtIGlzIGEgY29kZXgpLiAgVGhpcyBhbGxvd3MgeW91IHRvIG1hcFxuXHQgKiB0aGF0IHN1cHBvcnQgc28gcGx1Z2lucyBjYW4gYWNjdXJhdGVseSBkZXRlcm1pbmUgaWYgYW4gZXh0ZW5zaW9uIGlzIHN1cHBvcnRlZC4gIEFkZGluZyB0byB0aGlzIGxpc3QgY2FuIGhlbHBcblx0ICogcGx1Z2lucyBkZXRlcm1pbmUgbW9yZSBhY2N1cmF0ZWx5IGlmIGFuIGV4dGVuc2lvbiBpcyBzdXBwb3J0ZWQuXG5cdCAqXG4gXHQgKiBBIHVzZWZ1bCBsaXN0IG9mIGV4dGVuc2lvbnMgZm9yIGVhY2ggZm9ybWF0IGNhbiBiZSBmb3VuZCBhdCA8YSBocmVmPVwiaHR0cDovL2h0bWw1ZG9jdG9yLmNvbS9odG1sNS1hdWRpby10aGUtc3RhdGUtb2YtcGxheS9cIiB0YXJnZXQ9XCJfYmxhbmtcIj5odHRwOi8vaHRtbDVkb2N0b3IuY29tL2h0bWw1LWF1ZGlvLXRoZS1zdGF0ZS1vZi1wbGF5LzwvYT4uXG5cdCAqIEBwcm9wZXJ0eSBFWFRFTlNJT05fTUFQXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqIEBzaW5jZSAwLjQuMFxuXHQgKiBAZGVmYXVsdCB7bTRhOlwibXA0XCJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuRVhURU5TSU9OX01BUCA9IHtcblx0XHRtNGE6XCJtcDRcIlxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgUmVnRXhwIHBhdHRlcm4gdXNlZCB0byBwYXJzZSBmaWxlIFVSSXMuIFRoaXMgc3VwcG9ydHMgc2ltcGxlIGZpbGUgbmFtZXMsIGFzIHdlbGwgYXMgZnVsbCBkb21haW4gVVJJcyB3aXRoXG5cdCAqIHF1ZXJ5IHN0cmluZ3MuIFRoZSByZXN1bHRpbmcgbWF0Y2ggaXM6IHByb3RvY29sOiQxIGRvbWFpbjokMiBwYXRoOiQzIGZpbGU6JDQgZXh0ZW5zaW9uOiQ1IHF1ZXJ5OiQ2LlxuXHQgKiBAcHJvcGVydHkgRklMRV9QQVRURVJOXG5cdCAqIEB0eXBlIHtSZWdFeHB9XG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cy5GSUxFX1BBVFRFUk4gPSAvXig/OihcXHcrOilcXC97Mn0oXFx3Kyg/OlxcLlxcdyspKlxcLz8pKT8oWy8uXSo/KD86W14/XSspP1xcLyk/KCg/OlteLz9dKylcXC4oXFx3KykpKD86XFw/KFxcUyspPyk/JC87XG5cblxuLy8gQ2xhc3MgUHVibGljIHByb3BlcnRpZXNcblx0LyoqXG5cdCAqIERldGVybWluZXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IgZm9yIGludGVycnVwdGluZyBvdGhlciBjdXJyZW50bHkgcGxheWluZyBpbnN0YW5jZXMgd2l0aCB0aGUgc2FtZSBzb3VyY2UsIGlmIHRoZVxuXHQgKiBtYXhpbXVtIG51bWJlciBvZiBpbnN0YW5jZXMgb2YgdGhlIHNvdW5kIGFyZSBhbHJlYWR5IHBsYXlpbmcuICBDdXJyZW50bHkgdGhlIGRlZmF1bHQgaXMge3sjY3Jvc3NMaW5rIFwiU291bmQvSU5URVJSVVBUX05PTkU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogYnV0IHRoaXMgY2FuIGJlIHNldCBhbmQgd2lsbCBjaGFuZ2UgcGxheWJhY2sgYmVoYXZpb3IgYWNjb3JkaW5nbHkuICBUaGlzIGlzIG9ubHkgdXNlZCB3aGVuIHt7I2Nyb3NzTGluayBcIlNvdW5kL3BsYXlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaXMgY2FsbGVkIHdpdGhvdXQgcGFzc2luZyBhIHZhbHVlIGZvciBpbnRlcnJ1cHQuXG5cdCAqIEBwcm9wZXJ0eSBkZWZhdWx0SW50ZXJydXB0QmVoYXZpb3Jcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgU291bmQuSU5URVJSVVBUX05PTkUsIG9yIFwibm9uZVwiXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNC4wXG5cdCAqL1xuXHRzLmRlZmF1bHRJbnRlcnJ1cHRCZWhhdmlvciA9IHMuSU5URVJSVVBUX05PTkU7ICAvLyBPSlIgZG9lcyBzLklOVEVSUlVQVF9BTlkgbWFrZSBtb3JlIHNlbnNlIGFzIGRlZmF1bHQ/ICBOZWVkcyBnYW1lIGRldiB0ZXN0aW5nIHRvIHNlZSB3aGljaCBjYXNlIG1ha2VzIG1vcmUgc2Vuc2UuXG5cblx0LyoqXG5cdCAqIEFuIGFycmF5IG9mIGV4dGVuc2lvbnMgdG8gYXR0ZW1wdCB0byB1c2Ugd2hlbiBsb2FkaW5nIHNvdW5kLCBpZiB0aGUgZGVmYXVsdCBpcyB1bnN1cHBvcnRlZCBieSB0aGUgYWN0aXZlIHBsdWdpbi5cblx0ICogVGhlc2UgYXJlIGFwcGxpZWQgaW4gb3JkZXIsIHNvIGlmIHlvdSB0cnkgdG8gTG9hZCBUaHVuZGVyLm9nZyBpbiBhIGJyb3dzZXIgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IG9nZywgYW5kIHlvdXJcblx0ICogZXh0ZW5zaW9ucyBhcnJheSBpcyBbXCJtcDNcIiwgXCJtNGFcIiwgXCJ3YXZcIl0gaXQgd2lsbCBjaGVjayBtcDMgc3VwcG9ydCwgdGhlbiBtNGEsIHRoZW4gd2F2LiBUaGUgYXVkaW8gZmlsZXMgbmVlZFxuXHQgKiB0byBleGlzdCBpbiB0aGUgc2FtZSBsb2NhdGlvbiwgYXMgb25seSB0aGUgZXh0ZW5zaW9uIGlzIGFsdGVyZWQuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCByZWdhcmRsZXNzIG9mIHdoaWNoIGZpbGUgaXMgbG9hZGVkLCB5b3UgY2FuIGNhbGwge3sjY3Jvc3NMaW5rIFwiU291bmQvY3JlYXRlSW5zdGFuY2VcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogYW5kIHt7I2Nyb3NzTGluayBcIlNvdW5kL3BsYXlcIn19e3svY3Jvc3NMaW5rfX0gdXNpbmcgdGhlIHNhbWUgaWQgb3IgZnVsbCBzb3VyY2UgcGF0aCBwYXNzZWQgZm9yIGxvYWRpbmcuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICpcdHZhciBzb3VuZHMgPSBbXG5cdCAqXHRcdHtzcmM6XCJteVBhdGgvbXlTb3VuZC5vZ2dcIiwgaWQ6XCJleGFtcGxlXCJ9LFxuXHQgKlx0XTtcblx0ICpcdGNyZWF0ZWpzLlNvdW5kLmFsdGVybmF0ZUV4dGVuc2lvbnMgPSBbXCJtcDNcIl07IC8vIG5vdyBpZiBvZ2cgaXMgbm90IHN1cHBvcnRlZCwgU291bmRKUyB3aWxsIHRyeSBhc3NldDAubXAzXG5cdCAqXHRjcmVhdGVqcy5Tb3VuZC5vbihcImZpbGVsb2FkXCIsIGhhbmRsZUxvYWQpOyAvLyBjYWxsIGhhbmRsZUxvYWQgd2hlbiBlYWNoIHNvdW5kIGxvYWRzXG5cdCAqXHRjcmVhdGVqcy5Tb3VuZC5yZWdpc3RlclNvdW5kcyhzb3VuZHMsIGFzc2V0UGF0aCk7XG5cdCAqXHQvLyAuLi5cblx0ICpcdGNyZWF0ZWpzLlNvdW5kLnBsYXkoXCJteVBhdGgvbXlTb3VuZC5vZ2dcIik7IC8vIHdvcmtzIHJlZ2FyZGxlc3Mgb2Ygd2hhdCBleHRlbnNpb24gaXMgc3VwcG9ydGVkLiAgTm90ZSBjYWxsaW5nIHdpdGggSUQgaXMgYSBiZXR0ZXIgYXBwcm9hY2hcblx0ICpcblx0ICogQHByb3BlcnR5IGFsdGVybmF0ZUV4dGVuc2lvbnNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAc2luY2UgMC41LjJcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5hbHRlcm5hdGVFeHRlbnNpb25zID0gW107XG5cblx0LyoqXG5cdCAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIHBsdWdpbi4gSWYgdGhpcyBpcyBudWxsLCB0aGVuIG5vIHBsdWdpbiBjb3VsZCBiZSBpbml0aWFsaXplZC4gSWYgbm8gcGx1Z2luIHdhcyBzcGVjaWZpZWQsXG5cdCAqIFNvdW5kIGF0dGVtcHRzIHRvIGFwcGx5IHRoZSBkZWZhdWx0IHBsdWdpbnM6IHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319LCBmb2xsb3dlZCBieVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJIVE1MQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBwcm9wZXJ0eSBhY3RpdmVQbHVnaW5cblx0ICogQHR5cGUge09iamVjdH1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgICBzLmFjdGl2ZVBsdWdpbiA9IG51bGw7XG5cblxuLy8gY2xhc3MgZ2V0dGVyIC8gc2V0dGVyIHByb3BlcnRpZXNcblx0LyoqXG5cdCAqIFNldCB0aGUgbWFzdGVyIHZvbHVtZSBvZiBTb3VuZC4gVGhlIG1hc3RlciB2b2x1bWUgaXMgbXVsdGlwbGllZCBhZ2FpbnN0IGVhY2ggc291bmQncyBpbmRpdmlkdWFsIHZvbHVtZS4gIEZvclxuXHQgKiBleGFtcGxlLCBpZiBtYXN0ZXIgdm9sdW1lIGlzIDAuNSBhbmQgYSBzb3VuZCdzIHZvbHVtZSBpcyAwLjUsIHRoZSByZXN1bHRpbmcgdm9sdW1lIGlzIDAuMjUuIFRvIHNldCBpbmRpdmlkdWFsXG5cdCAqIHNvdW5kIHZvbHVtZSwgdXNlIEFic3RyYWN0U291bmRJbnN0YW5jZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2Uvdm9sdW1lOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgIGNyZWF0ZWpzLlNvdW5kLnZvbHVtZSA9IDAuNTtcblx0ICpcblx0ICpcblx0ICogQHByb3BlcnR5IHZvbHVtZVxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAxXG5cdCAqIEBzaW5jZSAwLjYuMVxuXHQgKi9cblx0cy5fbWFzdGVyVm9sdW1lID0gMTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHMsIFwidm9sdW1lXCIsIHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtyZXR1cm4gdGhpcy5fbWFzdGVyVm9sdW1lO30sXG5cdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0aWYgKE51bWJlcih2YWx1ZSkgPT0gbnVsbCkge3JldHVybiBmYWxzZTt9XG5cdFx0XHRcdHZhbHVlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdmFsdWUpKTtcblx0XHRcdFx0cy5fbWFzdGVyVm9sdW1lID0gdmFsdWU7XG5cdFx0XHRcdGlmICghdGhpcy5hY3RpdmVQbHVnaW4gfHwgIXRoaXMuYWN0aXZlUGx1Z2luLnNldFZvbHVtZSB8fCAhdGhpcy5hY3RpdmVQbHVnaW4uc2V0Vm9sdW1lKHZhbHVlKSkge1xuXHRcdFx0XHRcdHZhciBpbnN0YW5jZXMgPSB0aGlzLl9pbnN0YW5jZXM7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBpbnN0YW5jZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpbnN0YW5jZXNbaV0uc2V0TWFzdGVyVm9sdW1lKHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIE11dGUvVW5tdXRlIGFsbCBhdWRpby4gTm90ZSB0aGF0IG11dGVkIGF1ZGlvIHN0aWxsIHBsYXlzIGF0IDAgdm9sdW1lLiBUaGlzIGdsb2JhbCBtdXRlIHZhbHVlIGlzIG1haW50YWluZWRcblx0ICogc2VwYXJhdGVseSBhbmQgd2hlbiBzZXQgd2lsbCBvdmVycmlkZSwgYnV0IG5vdCBjaGFuZ2UgdGhlIG11dGUgcHJvcGVydHkgb2YgaW5kaXZpZHVhbCBpbnN0YW5jZXMuIFRvIG11dGUgYW4gaW5kaXZpZHVhbFxuXHQgKiBpbnN0YW5jZSwgdXNlIEFic3RyYWN0U291bmRJbnN0YW5jZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvbXV0ZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgY3JlYXRlanMuU291bmQubXV0ZWQgPSB0cnVlO1xuXHQgKlxuXHQgKlxuXHQgKiBAcHJvcGVydHkgbXV0ZWRcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBkZWZhdWx0IGZhbHNlXG5cdCAqIEBzaW5jZSAwLjYuMVxuXHQgKi9cblx0cy5fbWFzdGVyTXV0ZSA9IGZhbHNlO1xuXHQvLyBPSlIgcmVmZXJlbmNlcyB0byB0aGUgbWV0aG9kcyB3ZXJlIG5vdCB3b3JraW5nLCBzbyB0aGUgY29kZSBoYWQgdG8gYmUgZHVwbGljYXRlZCBoZXJlXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLCBcIm11dGVkXCIsIHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtyZXR1cm4gdGhpcy5fbWFzdGVyTXV0ZTt9LFxuXHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGlmICh2YWx1ZSA9PSBudWxsKSB7cmV0dXJuIGZhbHNlO31cblxuXHRcdFx0XHR0aGlzLl9tYXN0ZXJNdXRlID0gdmFsdWU7XG5cdFx0XHRcdGlmICghdGhpcy5hY3RpdmVQbHVnaW4gfHwgIXRoaXMuYWN0aXZlUGx1Z2luLnNldE11dGUgfHwgIXRoaXMuYWN0aXZlUGx1Z2luLnNldE11dGUodmFsdWUpKSB7XG5cdFx0XHRcdFx0dmFyIGluc3RhbmNlcyA9IHRoaXMuX2luc3RhbmNlcztcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGluc3RhbmNlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdGluc3RhbmNlc1tpXS5zZXRNYXN0ZXJNdXRlKHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGFjdGl2ZSBwbHVnaW5zIGNhcGFiaWxpdGllcywgd2hpY2ggaGVscCBkZXRlcm1pbmUgaWYgYSBwbHVnaW4gY2FuIGJlIHVzZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQsXG5cdCAqIG9yIGlmIHRoZSBwbHVnaW4gc3VwcG9ydHMgYSBzcGVjaWZpYyBmZWF0dXJlLiBDYXBhYmlsaXRpZXMgaW5jbHVkZTpcblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPjxiPnBhbm5pbmc6PC9iPiBJZiB0aGUgcGx1Z2luIGNhbiBwYW4gYXVkaW8gZnJvbSBsZWZ0IHRvIHJpZ2h0PC9saT5cblx0ICogICAgIDxsaT48Yj52b2x1bWU7PC9iPiBJZiB0aGUgcGx1Z2luIGNhbiBjb250cm9sIGF1ZGlvIHZvbHVtZS48L2xpPlxuXHQgKiAgICAgPGxpPjxiPnRyYWNrczo8L2I+IFRoZSBtYXhpbXVtIG51bWJlciBvZiBhdWRpbyB0cmFja3MgdGhhdCBjYW4gYmUgcGxheWVkIGJhY2sgYXQgYSB0aW1lLiBUaGlzIHdpbGwgYmUgLTFcblx0ICogICAgIGlmIHRoZXJlIGlzIG5vIGtub3duIGxpbWl0LjwvbGk+XG5cdCAqIDxiciAvPkFuIGVudHJ5IGZvciBlYWNoIGZpbGUgdHlwZSBpbiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9TVVBQT1JURURfRVhURU5TSU9OUzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTpcblx0ICogICAgIDxsaT48Yj5tcDM6PC9iPiBJZiBNUDMgYXVkaW8gaXMgc3VwcG9ydGVkLjwvbGk+XG5cdCAqICAgICA8bGk+PGI+b2dnOjwvYj4gSWYgT0dHIGF1ZGlvIGlzIHN1cHBvcnRlZC48L2xpPlxuXHQgKiAgICAgPGxpPjxiPndhdjo8L2I+IElmIFdBViBhdWRpbyBpcyBzdXBwb3J0ZWQuPC9saT5cblx0ICogICAgIDxsaT48Yj5tcGVnOjwvYj4gSWYgTVBFRyBhdWRpbyBpcyBzdXBwb3J0ZWQuPC9saT5cblx0ICogICAgIDxsaT48Yj5tNGE6PC9iPiBJZiBNNEEgYXVkaW8gaXMgc3VwcG9ydGVkLjwvbGk+XG5cdCAqICAgICA8bGk+PGI+bXA0OjwvYj4gSWYgTVA0IGF1ZGlvIGlzIHN1cHBvcnRlZC48L2xpPlxuXHQgKiAgICAgPGxpPjxiPmFpZmY6PC9iPiBJZiBhaWZmIGF1ZGlvIGlzIHN1cHBvcnRlZC48L2xpPlxuXHQgKiAgICAgPGxpPjxiPndtYTo8L2I+IElmIHdtYSBhdWRpbyBpcyBzdXBwb3J0ZWQuPC9saT5cblx0ICogICAgIDxsaT48Yj5taWQ6PC9iPiBJZiBtaWQgYXVkaW8gaXMgc3VwcG9ydGVkLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqIFlvdSBjYW4gZ2V0IGEgc3BlY2lmaWMgY2FwYWJpbGl0eSBvZiB0aGUgYWN0aXZlIHBsdWdpbiB1c2luZyBzdGFuZGFyZCBvYmplY3Qgbm90YXRpb25cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBtcDMgPSBjcmVhdGVqcy5Tb3VuZC5jYXBhYmlsaXRpZXMubXAzO1xuXHQgKlxuXHQgKiBOb3RlIHRoaXMgcHJvcGVydHkgaXMgcmVhZCBvbmx5LlxuXHQgKlxuXHQgKiBAcHJvcGVydHkgY2FwYWJpbGl0aWVzXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqIEBzdGF0aWNcblx0ICogQHJlYWRPbmx5XG5cdCAqIEBzaW5jZSAwLjYuMVxuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHMsIFwiY2FwYWJpbGl0aWVzXCIsIHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAocy5hY3RpdmVQbHVnaW4gPT0gbnVsbCkge3JldHVybiBudWxsO31cblx0XHRcdFx0XHRyZXR1cm4gcy5hY3RpdmVQbHVnaW4uX2NhcGFiaWxpdGllcztcblx0XHRcdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gZmFsc2U7fVxuXHR9KTtcblxuXG4vLyBDbGFzcyBQcml2YXRlIHByb3BlcnRpZXNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIHBsdWdpbnMgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQuIElmIGZhbHNlLCB0aGUgZmlyc3QgY2FsbCB0byBwbGF5KCkgd2lsbCBpbnN0YW50aWF0ZSB0aGUgZGVmYXVsdFxuXHQgKiBwbHVnaW5zICh7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fSwgZm9sbG93ZWQgYnkge3sjY3Jvc3NMaW5rIFwiSFRNTEF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319KS5cblx0ICogSWYgcGx1Z2lucyBoYXZlIGJlZW4gcmVnaXN0ZXJlZCwgYnV0IG5vbmUgYXJlIGFwcGxpY2FibGUsIHRoZW4gc291bmQgcGxheWJhY2sgd2lsbCBmYWlsLlxuXHQgKiBAcHJvcGVydHkgX3BsdWdpbnNSZWdpc3RlcmVkXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAZGVmYXVsdCBmYWxzZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHMuX3BsdWdpbnNSZWdpc3RlcmVkID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIFVzZWQgaW50ZXJuYWxseSB0byBhc3NpZ24gdW5pcXVlIElEcyB0byBlYWNoIEFic3RyYWN0U291bmRJbnN0YW5jZS5cblx0ICogQHByb3BlcnR5IF9sYXN0SURcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzLl9sYXN0SUQgPSAwO1xuXG5cdC8qKlxuXHQgKiBBbiBhcnJheSBjb250YWluaW5nIGFsbCBjdXJyZW50bHkgcGxheWluZyBpbnN0YW5jZXMuIFRoaXMgYWxsb3dzIFNvdW5kIHRvIGNvbnRyb2wgdGhlIHZvbHVtZSwgbXV0ZSwgYW5kIHBsYXliYWNrIG9mXG5cdCAqIGFsbCBpbnN0YW5jZXMgd2hlbiB1c2luZyBzdGF0aWMgQVBJcyBsaWtlIHt7I2Nyb3NzTGluayBcIlNvdW5kL3N0b3BcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlNvdW5kL3NldFZvbHVtZVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogV2hlbiBhbiBpbnN0YW5jZSBoYXMgZmluaXNoZWQgcGxheWJhY2ssIGl0IGdldHMgcmVtb3ZlZCB2aWEgdGhlIHt7I2Nyb3NzTGluayBcIlNvdW5kL2ZpbmlzaGVkUGxheWluZ1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuIElmIHRoZSB1c2VyIHJlcGxheXMgYW4gaW5zdGFuY2UsIGl0IGdldHMgYWRkZWQgYmFjayBpbiB2aWEgdGhlIHt7I2Nyb3NzTGluayBcIlNvdW5kL19iZWdpblBsYXlpbmdcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLlxuXHQgKiBAcHJvcGVydHkgX2luc3RhbmNlc1xuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5faW5zdGFuY2VzID0gW107XG5cblx0LyoqXG5cdCAqIEFuIG9iamVjdCBoYXNoIHN0b3Jpbmcgb2JqZWN0cyB3aXRoIHNvdW5kIHNvdXJjZXMsIHN0YXJ0VGltZSwgYW5kIGR1cmF0aW9uIHZpYSB0aGVyZSBjb3JyZXNwb25kaW5nIElELlxuXHQgKiBAcHJvcGVydHkgX2lkSGFzaFxuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuX2lkSGFzaCA9IHt9O1xuXG5cdC8qKlxuXHQgKiBBbiBvYmplY3QgaGFzaCB0aGF0IHN0b3JlcyBwcmVsb2FkaW5nIHNvdW5kIHNvdXJjZXMgdmlhIHRoZSBwYXJzZWQgc291cmNlIHRoYXQgaXMgcGFzc2VkIHRvIHRoZSBwbHVnaW4uICBDb250YWlucyB0aGVcblx0ICogc291cmNlLCBpZCwgYW5kIGRhdGEgdGhhdCB3YXMgcGFzc2VkIGluIGJ5IHRoZSB1c2VyLiAgUGFyc2VkIHNvdXJjZXMgY2FuIGNvbnRhaW4gbXVsdGlwbGUgaW5zdGFuY2VzIG9mIHNvdXJjZSwgaWQsXG5cdCAqIGFuZCBkYXRhLlxuXHQgKiBAcHJvcGVydHkgX3ByZWxvYWRIYXNoXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5fcHJlbG9hZEhhc2ggPSB7fTtcblxuXHQvKipcblx0ICogQW4gb2JqZWN0IGhhc2ggc3RvcmluZyB7eyNjcm9zc0xpbmsgXCJQbGF5UHJvcHNDb25maWdcIn19e3svY3Jvc3NMaW5rfX0gdmlhIHRoZSBwYXJzZWQgc291cmNlIHRoYXQgaXMgcGFzc2VkIGFzIGRlZmF1bHRQbGF5UHJvcHMgaW5cblx0ICoge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVnaXN0ZXJTb3VuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVnaXN0ZXJTb3VuZHNcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBwcm9wZXJ0eSBfZGVmYXVsdFBsYXlQcm9wc0hhc2hcblx0ICogQHR5cGUge09iamVjdH1cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMVxuXHQgKi9cblx0cy5fZGVmYXVsdFBsYXlQcm9wc0hhc2ggPSB7fTtcblxuXG4vLyBFdmVudERpc3BhdGNoZXIgbWV0aG9kczpcblx0cy5hZGRFdmVudExpc3RlbmVyID0gbnVsbDtcblx0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gbnVsbDtcblx0cy5yZW1vdmVBbGxFdmVudExpc3RlbmVycyA9IG51bGw7XG5cdHMuZGlzcGF0Y2hFdmVudCA9IG51bGw7XG5cdHMuaGFzRXZlbnRMaXN0ZW5lciA9IG51bGw7XG5cdHMuX2xpc3RlbmVycyA9IG51bGw7XG5cblx0Y3JlYXRlanMuRXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUocyk7IC8vIGluamVjdCBFdmVudERpc3BhdGNoZXIgbWV0aG9kcy5cblxuXG4vLyBFdmVudHNcblx0LyoqXG5cdCAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIGZpbGUgZmluaXNoZXMgbG9hZGluZyBpbnRlcm5hbGx5LiBUaGlzIGV2ZW50IGlzIGZpcmVkIGZvciBlYWNoIGxvYWRlZCBzb3VuZCxcblx0ICogc28gYW55IGhhbmRsZXIgbWV0aG9kcyBzaG91bGQgbG9vayB1cCB0aGUgPGNvZGU+ZXZlbnQuc3JjPC9jb2RlPiB0byBoYW5kbGUgYSBwYXJ0aWN1bGFyIHNvdW5kLlxuXHQgKiBAZXZlbnQgZmlsZWxvYWRcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VyY2Ugb2YgdGhlIHNvdW5kIHRoYXQgd2FzIGxvYWRlZC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtpZF0gVGhlIGlkIHBhc3NlZCBpbiB3aGVuIHRoZSBzb3VuZCB3YXMgcmVnaXN0ZXJlZC4gSWYgb25lIHdhcyBub3QgcHJvdmlkZWQsIGl0IHdpbGwgYmUgbnVsbC5cblx0ICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBbZGF0YV0gQW55IGFkZGl0aW9uYWwgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGl0ZW0uIElmIG5vdCBwcm92aWRlZCwgaXQgd2lsbCBiZSB1bmRlZmluZWQuXG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKi9cblxuXHQvKipcblx0ICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGEgZmlsZSBmYWlscyBsb2FkaW5nIGludGVybmFsbHkuIFRoaXMgZXZlbnQgaXMgZmlyZWQgZm9yIGVhY2ggbG9hZGVkIHNvdW5kLFxuXHQgKiBzbyBhbnkgaGFuZGxlciBtZXRob2RzIHNob3VsZCBsb29rIHVwIHRoZSA8Y29kZT5ldmVudC5zcmM8L2NvZGU+IHRvIGhhbmRsZSBhIHBhcnRpY3VsYXIgc291bmQuXG5cdCAqIEBldmVudCBmaWxlZXJyb3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VyY2Ugb2YgdGhlIHNvdW5kIHRoYXQgd2FzIGxvYWRlZC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtpZF0gVGhlIGlkIHBhc3NlZCBpbiB3aGVuIHRoZSBzb3VuZCB3YXMgcmVnaXN0ZXJlZC4gSWYgb25lIHdhcyBub3QgcHJvdmlkZWQsIGl0IHdpbGwgYmUgbnVsbC5cblx0ICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBbZGF0YV0gQW55IGFkZGl0aW9uYWwgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGl0ZW0uIElmIG5vdCBwcm92aWRlZCwgaXQgd2lsbCBiZSB1bmRlZmluZWQuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXG4vLyBDbGFzcyBQdWJsaWMgTWV0aG9kc1xuXHQvKipcblx0ICogR2V0IHRoZSBwcmVsb2FkIHJ1bGVzIHRvIGFsbG93IFNvdW5kIHRvIGJlIHVzZWQgYXMgYSBwbHVnaW4gYnkgPGEgaHJlZj1cImh0dHA6Ly9wcmVsb2FkanMuY29tXCIgdGFyZ2V0PVwiX2JsYW5rXCI+UHJlbG9hZEpTPC9hPi5cblx0ICogQW55IGxvYWQgY2FsbHMgdGhhdCBoYXZlIHRoZSBtYXRjaGluZyB0eXBlIG9yIGV4dGVuc2lvbiB3aWxsIGZpcmUgdGhlIGNhbGxiYWNrIG1ldGhvZCwgYW5kIHVzZSB0aGUgcmVzdWx0aW5nXG5cdCAqIG9iamVjdCwgd2hpY2ggaXMgcG90ZW50aWFsbHkgbW9kaWZpZWQgYnkgU291bmQuIFRoaXMgaGVscHMgd2hlbiBkZXRlcm1pbmluZyB0aGUgY29ycmVjdCBwYXRoLCBhcyB3ZWxsIGFzXG5cdCAqIHJlZ2lzdGVyaW5nIHRoZSBhdWRpbyBpbnN0YW5jZShzKSB3aXRoIFNvdW5kLiBUaGlzIG1ldGhvZCBzaG91bGQgbm90IGJlIGNhbGxlZCwgZXhjZXB0IGJ5IFByZWxvYWRKUy5cblx0ICogQG1ldGhvZCBnZXRQcmVsb2FkSGFuZGxlcnNcblx0ICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZzpcblx0ICogPHVsPjxsaT5jYWxsYmFjazogQSBwcmVsb2FkIGNhbGxiYWNrIHRoYXQgaXMgZmlyZWQgd2hlbiBhIGZpbGUgaXMgYWRkZWQgdG8gUHJlbG9hZEpTLCB3aGljaCBwcm92aWRlc1xuXHQgKiAgICAgIFNvdW5kIGEgbWVjaGFuaXNtIHRvIG1vZGlmeSB0aGUgbG9hZCBwYXJhbWV0ZXJzLCBzZWxlY3QgdGhlIGNvcnJlY3QgZmlsZSBmb3JtYXQsIHJlZ2lzdGVyIHRoZSBzb3VuZCwgZXRjLjwvbGk+XG5cdCAqICAgICAgPGxpPnR5cGVzOiBBIGxpc3Qgb2YgZmlsZSB0eXBlcyB0aGF0IGFyZSBzdXBwb3J0ZWQgYnkgU291bmQgKGN1cnJlbnRseSBzdXBwb3J0cyBcInNvdW5kXCIpLjwvbGk+XG5cdCAqICAgICAgPGxpPmV4dGVuc2lvbnM6IEEgbGlzdCBvZiBmaWxlIGV4dGVuc2lvbnMgdGhhdCBhcmUgc3VwcG9ydGVkIGJ5IFNvdW5kIChzZWUge3sjY3Jvc3NMaW5rIFwiU291bmQvU1VQUE9SVEVEX0VYVEVOU0lPTlM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0pLjwvbGk+PC91bD5cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzLmdldFByZWxvYWRIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Y2FsbGJhY2s6Y3JlYXRlanMucHJveHkocy5pbml0TG9hZCwgcyksXG5cdFx0XHR0eXBlczpbXCJzb3VuZFwiXSxcblx0XHRcdGV4dGVuc2lvbnM6cy5TVVBQT1JURURfRVhURU5TSU9OU1xuXHRcdH07XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZWQgdG8gZGlzcGF0Y2ggZmlsZWxvYWQgZXZlbnRzIGZyb20gaW50ZXJuYWwgbG9hZGluZy5cblx0ICogQG1ldGhvZCBfaGFuZGxlTG9hZENvbXBsZXRlXG5cdCAqIEBwYXJhbSBldmVudCBBIGxvYWRlciBldmVudC5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5faGFuZGxlTG9hZENvbXBsZXRlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgc3JjID0gZXZlbnQudGFyZ2V0LmdldEl0ZW0oKS5zcmM7XG5cdFx0aWYgKCFzLl9wcmVsb2FkSGFzaFtzcmNdKSB7cmV0dXJuO31cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gcy5fcHJlbG9hZEhhc2hbc3JjXS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gcy5fcHJlbG9hZEhhc2hbc3JjXVtpXTtcblx0XHRcdHMuX3ByZWxvYWRIYXNoW3NyY11baV0gPSB0cnVlO1xuXG5cdFx0XHRpZiAoIXMuaGFzRXZlbnRMaXN0ZW5lcihcImZpbGVsb2FkXCIpKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVsb2FkXCIpO1xuXHRcdFx0ZXZlbnQuc3JjID0gaXRlbS5zcmM7XG5cdFx0XHRldmVudC5pZCA9IGl0ZW0uaWQ7XG5cdFx0XHRldmVudC5kYXRhID0gaXRlbS5kYXRhO1xuXHRcdFx0ZXZlbnQuc3ByaXRlID0gaXRlbS5zcHJpdGU7XG5cblx0XHRcdHMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2VkIHRvIGRpc3BhdGNoIGVycm9yIGV2ZW50cyBmcm9tIGludGVybmFsIHByZWxvYWRpbmcuXG5cdCAqIEBwYXJhbSBldmVudFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLl9oYW5kbGVMb2FkRXJyb3IgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBzcmMgPSBldmVudC50YXJnZXQuZ2V0SXRlbSgpLnNyYztcblx0XHRpZiAoIXMuX3ByZWxvYWRIYXNoW3NyY10pIHtyZXR1cm47fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzLl9wcmVsb2FkSGFzaFtzcmNdLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzLl9wcmVsb2FkSGFzaFtzcmNdW2ldO1xuXHRcdFx0cy5fcHJlbG9hZEhhc2hbc3JjXVtpXSA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoIXMuaGFzRXZlbnRMaXN0ZW5lcihcImZpbGVlcnJvclwiKSkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJmaWxlZXJyb3JcIik7XG5cdFx0XHRldmVudC5zcmMgPSBpdGVtLnNyYztcblx0XHRcdGV2ZW50LmlkID0gaXRlbS5pZDtcblx0XHRcdGV2ZW50LmRhdGEgPSBpdGVtLmRhdGE7XG5cdFx0XHRldmVudC5zcHJpdGUgPSBpdGVtLnNwcml0ZTtcblxuXHRcdFx0cy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZWQgYnkge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVnaXN0ZXJQbHVnaW5zXCJ9fXt7L2Nyb3NzTGlua319IHRvIHJlZ2lzdGVyIGEgU291bmQgcGx1Z2luLlxuXHQgKlxuXHQgKiBAbWV0aG9kIF9yZWdpc3RlclBsdWdpblxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luIFRoZSBwbHVnaW4gY2xhc3MgdG8gaW5zdGFsbC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgcGx1Z2luIHdhcyBzdWNjZXNzZnVsbHkgaW5pdGlhbGl6ZWQuXG5cdCAqIEBzdGF0aWNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHMuX3JlZ2lzdGVyUGx1Z2luID0gZnVuY3Rpb24gKHBsdWdpbikge1xuXHRcdC8vIE5vdGU6IEVhY2ggcGx1Z2luIGlzIHBhc3NlZCBpbiBhcyBhIGNsYXNzIHJlZmVyZW5jZSwgYnV0IHdlIHN0b3JlIHRoZSBhY3RpdmVQbHVnaW4gYXMgYW4gaW5zdGFuY2Vcblx0XHRpZiAocGx1Z2luLmlzU3VwcG9ydGVkKCkpIHtcblx0XHRcdHMuYWN0aXZlUGx1Z2luID0gbmV3IHBsdWdpbigpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0ICogUmVnaXN0ZXIgYSBsaXN0IG9mIFNvdW5kIHBsdWdpbnMsIGluIG9yZGVyIG9mIHByZWNlZGVuY2UuIFRvIHJlZ2lzdGVyIGEgc2luZ2xlIHBsdWdpbiwgcGFzcyBhIHNpbmdsZSBlbGVtZW50IGluIHRoZSBhcnJheS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLkZsYXNoQXVkaW9QbHVnaW4uc3dmUGF0aCA9IFwiLi4vc3JjL3NvdW5kanMvZmxhc2hhdWRpby9cIjtcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5yZWdpc3RlclBsdWdpbnMoW2NyZWF0ZWpzLldlYkF1ZGlvUGx1Z2luLCBjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4sIGNyZWF0ZWpzLkZsYXNoQXVkaW9QbHVnaW5dKTtcblx0ICpcblx0ICogQG1ldGhvZCByZWdpc3RlclBsdWdpbnNcblx0ICogQHBhcmFtIHtBcnJheX0gcGx1Z2lucyBBbiBhcnJheSBvZiBwbHVnaW5zIGNsYXNzZXMgdG8gaW5zdGFsbC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBhIHBsdWdpbiB3YXMgc3VjY2Vzc2Z1bGx5IGluaXRpYWxpemVkLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLnJlZ2lzdGVyUGx1Z2lucyA9IGZ1bmN0aW9uIChwbHVnaW5zKSB7XG5cdFx0cy5fcGx1Z2luc1JlZ2lzdGVyZWQgPSB0cnVlO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGx1Z2lucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmIChzLl9yZWdpc3RlclBsdWdpbihwbHVnaW5zW2ldKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIHRoZSBkZWZhdWx0IHBsdWdpbnMuIFRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIHdoZW4gYW55IGF1ZGlvIGlzIHBsYXllZCBvciByZWdpc3RlcmVkIGJlZm9yZVxuXHQgKiB0aGUgdXNlciBoYXMgbWFudWFsbHkgcmVnaXN0ZXJlZCBwbHVnaW5zLCBhbmQgZW5hYmxlcyBTb3VuZCB0byB3b3JrIHdpdGhvdXQgbWFudWFsIHBsdWdpbiBzZXR1cC4gQ3VycmVudGx5LCB0aGVcblx0ICogZGVmYXVsdCBwbHVnaW5zIGFyZSB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fSBmb2xsb3dlZCBieSB7eyNjcm9zc0xpbmsgXCJIVE1MQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogXHRpZiAoIWNyZWF0ZWpzLmluaXRpYWxpemVEZWZhdWx0UGx1Z2lucygpKSB7IHJldHVybjsgfVxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVEZWZhdWx0UGx1Z2luc1xuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiBhIHBsdWdpbiB3YXMgaW5pdGlhbGl6ZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0ICogQHNpbmNlIDAuNC4wXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaW5pdGlhbGl6ZURlZmF1bHRQbHVnaW5zID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmIChzLmFjdGl2ZVBsdWdpbiAhPSBudWxsKSB7cmV0dXJuIHRydWU7fVxuXHRcdGlmIChzLl9wbHVnaW5zUmVnaXN0ZXJlZCkge3JldHVybiBmYWxzZTt9XG5cdFx0aWYgKHMucmVnaXN0ZXJQbHVnaW5zKFtjcmVhdGVqcy5XZWJBdWRpb1BsdWdpbiwgY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luXSkpIHtyZXR1cm4gdHJ1ZTt9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIFNvdW5kIGhhcyBiZWVuIGluaXRpYWxpemVkLCBhbmQgYSBwbHVnaW4gaGFzIGJlZW4gYWN0aXZhdGVkLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIFRoaXMgZXhhbXBsZSBzZXRzIHVwIGEgRmxhc2ggZmFsbGJhY2ssIGJ1dCBvbmx5IGlmIHRoZXJlIGlzIG5vIHBsdWdpbiBzcGVjaWZpZWQgeWV0LlxuXHQgKlxuXHQgKiBcdGlmICghY3JlYXRlanMuU291bmQuaXNSZWFkeSgpKSB7XG5cdCAqXHRcdGNyZWF0ZWpzLkZsYXNoQXVkaW9QbHVnaW4uc3dmUGF0aCA9IFwiLi4vc3JjL3NvdW5kanMvZmxhc2hhdWRpby9cIjtcblx0ICogXHRcdGNyZWF0ZWpzLlNvdW5kLnJlZ2lzdGVyUGx1Z2lucyhbY3JlYXRlanMuV2ViQXVkaW9QbHVnaW4sIGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbiwgY3JlYXRlanMuRmxhc2hBdWRpb1BsdWdpbl0pO1xuXHQgKlx0fVxuXHQgKlxuXHQgKiBAbWV0aG9kIGlzUmVhZHlcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgU291bmQgaGFzIGluaXRpYWxpemVkIGEgcGx1Z2luLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIChzLmFjdGl2ZVBsdWdpbiAhPSBudWxsKTtcblx0fTtcblxuXHQvKipcblx0ICogRGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9jYXBhYmlsaXRpZXM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICpcblx0ICogQG1ldGhvZCBnZXRDYXBhYmlsaXRpZXNcblx0ICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgY2FwYWJpbGl0aWVzIG9mIHRoZSBhY3RpdmUgcGx1Z2luLlxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHRzLmdldENhcGFiaWxpdGllcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAocy5hY3RpdmVQbHVnaW4gPT0gbnVsbCkge3JldHVybiBudWxsO31cblx0XHRyZXR1cm4gcy5hY3RpdmVQbHVnaW4uX2NhcGFiaWxpdGllcztcblx0fTtcblxuXHQvKipcblx0ICogRGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9jYXBhYmlsaXRpZXM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICpcblx0ICogQG1ldGhvZCBnZXRDYXBhYmlsaXR5XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIGNhcGFiaWxpdHkgdG8gcmV0cmlldmVcblx0ICogQHJldHVybiB7TnVtYmVyfEJvb2xlYW59IFRoZSB2YWx1ZSBvZiB0aGUgY2FwYWJpbGl0eS5cblx0ICogQHN0YXRpY1xuXHQgKiBAc2VlIGdldENhcGFiaWxpdGllc1xuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0cy5nZXRDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKGtleSkge1xuXHRcdGlmIChzLmFjdGl2ZVBsdWdpbiA9PSBudWxsKSB7cmV0dXJuIG51bGw7fVxuXHRcdHJldHVybiBzLmFjdGl2ZVBsdWdpbi5fY2FwYWJpbGl0aWVzW2tleV07XG5cdH07XG5cblx0LyoqXG5cdCAqIFByb2Nlc3MgbWFuaWZlc3QgaXRlbXMgZnJvbSA8YSBocmVmPVwiaHR0cDovL3ByZWxvYWRqcy5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIj5QcmVsb2FkSlM8L2E+LiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZFxuXHQgKiBmb3IgdXNhZ2UgYnkgYSBwbHVnaW4sIGFuZCBub3QgZm9yIGRpcmVjdCBpbnRlcmFjdGlvbi5cblx0ICogQG1ldGhvZCBpbml0TG9hZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3JjIFRoZSBvYmplY3QgdG8gbG9hZC5cblx0ICogQHJldHVybiB7T2JqZWN0fEFic3RyYWN0TG9hZGVyfSBBbiBpbnN0YW5jZSBvZiBBYnN0cmFjdExvYWRlci5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmluaXRMb2FkID0gZnVuY3Rpb24gKGxvYWRJdGVtKSB7XG5cdFx0cmV0dXJuIHMuX3JlZ2lzdGVyU291bmQobG9hZEl0ZW0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBtZXRob2QgZm9yIGxvYWRpbmcgc291bmRzLiAgVGhpcyBzaG91bGQgbm90IGJlIGNhbGxlZCBkaXJlY3RseS5cblx0ICpcblx0ICogQG1ldGhvZCBfcmVnaXN0ZXJTb3VuZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3JjIFRoZSBvYmplY3QgdG8gbG9hZCwgY29udGFpbmluZyBzcmMgcHJvcGVydHkgYW5kIG9wdGlvbmFsbHkgY29udGFpbmluZyBpZCBhbmQgZGF0YS5cblx0ICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgbW9kaWZpZWQgdmFsdWVzIHRoYXQgd2VyZSBwYXNzZWQgaW4sIHdoaWNoIGRlZmluZXMgdGhlIHNvdW5kLlxuXHQgKiBSZXR1cm5zIGZhbHNlIGlmIHRoZSBzb3VyY2UgY2Fubm90IGJlIHBhcnNlZCBvciBubyBwbHVnaW5zIGNhbiBiZSBpbml0aWFsaXplZC5cblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBzb3VyY2UgaXMgYWxyZWFkeSBsb2FkZWQuXG5cdCAqIEBzdGF0aWNcblx0ICogQHByaXZhdGVcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cdHMuX3JlZ2lzdGVyU291bmQgPSBmdW5jdGlvbiAobG9hZEl0ZW0pIHtcblx0XHRpZiAoIXMuaW5pdGlhbGl6ZURlZmF1bHRQbHVnaW5zKCkpIHtyZXR1cm4gZmFsc2U7fVxuXG5cdFx0dmFyIGRldGFpbHM7XG5cdFx0aWYgKGxvYWRJdGVtLnNyYyBpbnN0YW5jZW9mIE9iamVjdCkge1xuXHRcdFx0ZGV0YWlscyA9IHMuX3BhcnNlU3JjKGxvYWRJdGVtLnNyYyk7XG5cdFx0XHRkZXRhaWxzLnNyYyA9IGxvYWRJdGVtLnBhdGggKyBkZXRhaWxzLnNyYztcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGV0YWlscyA9IHMuX3BhcnNlUGF0aChsb2FkSXRlbS5zcmMpO1xuXHRcdH1cblx0XHRpZiAoZGV0YWlscyA9PSBudWxsKSB7cmV0dXJuIGZhbHNlO31cblx0XHRsb2FkSXRlbS5zcmMgPSBkZXRhaWxzLnNyYztcblx0XHRsb2FkSXRlbS50eXBlID0gXCJzb3VuZFwiO1xuXG5cdFx0dmFyIGRhdGEgPSBsb2FkSXRlbS5kYXRhO1xuXHRcdHZhciBudW1DaGFubmVscyA9IG51bGw7XG5cdFx0aWYgKGRhdGEgIT0gbnVsbCkge1xuXHRcdFx0aWYgKCFpc05hTihkYXRhLmNoYW5uZWxzKSkge1xuXHRcdFx0XHRudW1DaGFubmVscyA9IHBhcnNlSW50KGRhdGEuY2hhbm5lbHMpO1xuXHRcdFx0fSBlbHNlIGlmICghaXNOYU4oZGF0YSkpIHtcblx0XHRcdFx0bnVtQ2hhbm5lbHMgPSBwYXJzZUludChkYXRhKTtcblx0XHRcdH1cblxuXHRcdFx0aWYoZGF0YS5hdWRpb1Nwcml0ZSkge1xuXHRcdFx0XHR2YXIgc3A7XG5cdFx0XHRcdGZvcih2YXIgaSA9IGRhdGEuYXVkaW9TcHJpdGUubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0XHRcdHNwID0gZGF0YS5hdWRpb1Nwcml0ZVtpXTtcblx0XHRcdFx0XHRzLl9pZEhhc2hbc3AuaWRdID0ge3NyYzogbG9hZEl0ZW0uc3JjLCBzdGFydFRpbWU6IHBhcnNlSW50KHNwLnN0YXJ0VGltZSksIGR1cmF0aW9uOiBwYXJzZUludChzcC5kdXJhdGlvbil9O1xuXG5cdFx0XHRcdFx0aWYgKHNwLmRlZmF1bHRQbGF5UHJvcHMpIHtcblx0XHRcdFx0XHRcdHMuX2RlZmF1bHRQbGF5UHJvcHNIYXNoW3NwLmlkXSA9IGNyZWF0ZWpzLlBsYXlQcm9wc0NvbmZpZy5jcmVhdGUoc3AuZGVmYXVsdFBsYXlQcm9wcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChsb2FkSXRlbS5pZCAhPSBudWxsKSB7cy5faWRIYXNoW2xvYWRJdGVtLmlkXSA9IHtzcmM6IGxvYWRJdGVtLnNyY319O1xuXHRcdHZhciBsb2FkZXIgPSBzLmFjdGl2ZVBsdWdpbi5yZWdpc3Rlcihsb2FkSXRlbSk7XG5cblx0XHRTb3VuZENoYW5uZWwuY3JlYXRlKGxvYWRJdGVtLnNyYywgbnVtQ2hhbm5lbHMpO1xuXG5cdFx0Ly8gcmV0dXJuIHRoZSBudW1iZXIgb2YgaW5zdGFuY2VzIHRvIHRoZSB1c2VyLiAgVGhpcyB3aWxsIGFsc28gYmUgcmV0dXJuZWQgaW4gdGhlIGxvYWQgZXZlbnQuXG5cdFx0aWYgKGRhdGEgPT0gbnVsbCB8fCAhaXNOYU4oZGF0YSkpIHtcblx0XHRcdGxvYWRJdGVtLmRhdGEgPSBudW1DaGFubmVscyB8fCBTb3VuZENoYW5uZWwubWF4UGVyQ2hhbm5lbCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsb2FkSXRlbS5kYXRhLmNoYW5uZWxzID0gbnVtQ2hhbm5lbHMgfHwgU291bmRDaGFubmVsLm1heFBlckNoYW5uZWwoKTtcblx0XHR9XG5cblx0XHRpZiAobG9hZGVyLnR5cGUpIHtsb2FkSXRlbS50eXBlID0gbG9hZGVyLnR5cGU7fVxuXG5cdFx0aWYgKGxvYWRJdGVtLmRlZmF1bHRQbGF5UHJvcHMpIHtcblx0XHRcdHMuX2RlZmF1bHRQbGF5UHJvcHNIYXNoW2xvYWRJdGVtLnNyY10gPSBjcmVhdGVqcy5QbGF5UHJvcHNDb25maWcuY3JlYXRlKGxvYWRJdGVtLmRlZmF1bHRQbGF5UHJvcHMpO1xuXHRcdH1cblx0XHRyZXR1cm4gbG9hZGVyO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZWdpc3RlciBhbiBhdWRpbyBmaWxlIGZvciBsb2FkaW5nIGFuZCBmdXR1cmUgcGxheWJhY2sgaW4gU291bmQuIFRoaXMgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgd2hlbiB1c2luZ1xuXHQgKiA8YSBocmVmPVwiaHR0cDovL3ByZWxvYWRqcy5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIj5QcmVsb2FkSlM8L2E+LiAgSXQgaXMgcmVjb21tZW5kZWQgdG8gcmVnaXN0ZXIgYWxsIHNvdW5kcyB0aGF0XG5cdCAqIG5lZWQgdG8gYmUgcGxheWVkIGJhY2sgaW4gb3JkZXIgdG8gcHJvcGVybHkgcHJlcGFyZSBhbmQgcHJlbG9hZCB0aGVtLiBTb3VuZCBkb2VzIGludGVybmFsIHByZWxvYWRpbmcgd2hlbiByZXF1aXJlZC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLmFsdGVybmF0ZUV4dGVuc2lvbnMgPSBbXCJtcDNcIl07XG5cdCAqICAgICAgY3JlYXRlanMuU291bmQub24oXCJmaWxlbG9hZFwiLCBoYW5kbGVMb2FkKTsgLy8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB3aGVuIGxvYWQgaXMgY29tcGxldGVkXG5cdCAqICAgICAgY3JlYXRlanMuU291bmQucmVnaXN0ZXJTb3VuZChcIm15QXVkaW9QYXRoL215U291bmQub2dnXCIsIFwibXlJRFwiLCAzKTtcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5yZWdpc3RlclNvdW5kKHtvZ2c6XCJwYXRoMS9teVNvdW5kLm9nZ1wiLCBtcDM6XCJwYXRoMi9teVNvdW5kTm9FeHRlbnNpb25cIn0sIFwibXlJRFwiLCAzKTtcblx0ICpcblx0ICpcblx0ICogQG1ldGhvZCByZWdpc3RlclNvdW5kXG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgT2JqZWN0fSBzcmMgVGhlIHNvdXJjZSBvciBhbiBPYmplY3Qgd2l0aCBhIFwic3JjXCIgcHJvcGVydHkgb3IgYW4gT2JqZWN0IHdpdGggbXVsdGlwbGUgZXh0ZW5zaW9uIGxhYmVsZWQgc3JjIHByb3BlcnRpZXMuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbaWRdIEFuIGlkIHNwZWNpZmllZCBieSB0aGUgdXNlciB0byBwbGF5IHRoZSBzb3VuZCBsYXRlci4gIE5vdGUgaWQgaXMgcmVxdWlyZWQgZm9yIHdoZW4gc3JjIGlzIG11bHRpcGxlIGV4dGVuc2lvbiBsYWJlbGVkIHNyYyBwcm9wZXJ0aWVzLlxuXHQgKiBAcGFyYW0ge051bWJlciB8IE9iamVjdH0gW2RhdGFdIERhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBpdGVtLiBTb3VuZCB1c2VzIHRoZSBkYXRhIHBhcmFtZXRlciBhcyB0aGUgbnVtYmVyIG9mXG5cdCAqIGNoYW5uZWxzIGZvciBhbiBhdWRpbyBpbnN0YW5jZSwgaG93ZXZlciBhIFwiY2hhbm5lbHNcIiBwcm9wZXJ0eSBjYW4gYmUgYXBwZW5kZWQgdG8gdGhlIGRhdGEgb2JqZWN0IGlmIGl0IGlzIHVzZWRcblx0ICogZm9yIG90aGVyIGluZm9ybWF0aW9uLiBUaGUgYXVkaW8gY2hhbm5lbHMgd2lsbCBzZXQgYSBkZWZhdWx0IGJhc2VkIG9uIHBsdWdpbiBpZiBubyB2YWx1ZSBpcyBmb3VuZC5cblx0ICogU291bmQgYWxzbyB1c2VzIHRoZSBkYXRhIHByb3BlcnR5IHRvIGhvbGQgYW4ge3sjY3Jvc3NMaW5rIFwiQXVkaW9TcHJpdGVcIn19e3svY3Jvc3NMaW5rfX0gYXJyYXkgb2Ygb2JqZWN0cyBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdCB7aWQsIHN0YXJ0VGltZSwgZHVyYXRpb259Ljxici8+XG5cdCAqICAgaWQgdXNlZCB0byBwbGF5IHRoZSBzb3VuZCBsYXRlciwgaW4gdGhlIHNhbWUgbWFubmVyIGFzIGEgc291bmQgc3JjIHdpdGggYW4gaWQuPGJyLz5cblx0ICogICBzdGFydFRpbWUgaXMgdGhlIGluaXRpYWwgb2Zmc2V0IHRvIHN0YXJ0IHBsYXliYWNrIGFuZCBsb29wIGZyb20sIGluIG1pbGxpc2Vjb25kcy48YnIvPlxuXHQgKiAgIGR1cmF0aW9uIGlzIHRoZSBhbW91bnQgb2YgdGltZSB0byBwbGF5IHRoZSBjbGlwIGZvciwgaW4gbWlsbGlzZWNvbmRzLjxici8+XG5cdCAqIFRoaXMgYWxsb3dzIFNvdW5kIHRvIHN1cHBvcnQgYXVkaW8gc3ByaXRlcyB0aGF0IGFyZSBwbGF5ZWQgYmFjayBieSBpZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGJhc2VQYXRoIFNldCBhIHBhdGggdGhhdCB3aWxsIGJlIHByZXBlbmRlZCB0byBzcmMgZm9yIGxvYWRpbmcuXG5cdCAqIEBwYXJhbSB7T2JqZWN0IHwgUGxheVByb3BzQ29uZmlnfSBkZWZhdWx0UGxheVByb3BzIE9wdGlvbmFsIFBsYXliYWNrIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIHNldCBhcyB0aGUgZGVmYXVsdHMgb24gYW55IG5ldyBBYnN0cmFjdFNvdW5kSW5zdGFuY2UuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJQbGF5UHJvcHNDb25maWdcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG9wdGlvbnMuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIG1vZGlmaWVkIHZhbHVlcyB0aGF0IHdlcmUgcGFzc2VkIGluLCB3aGljaCBkZWZpbmVzIHRoZSBzb3VuZC5cblx0ICogUmV0dXJucyBmYWxzZSBpZiB0aGUgc291cmNlIGNhbm5vdCBiZSBwYXJzZWQgb3Igbm8gcGx1Z2lucyBjYW4gYmUgaW5pdGlhbGl6ZWQuXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc291cmNlIGlzIGFscmVhZHkgbG9hZGVkLlxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMFxuXHQgKi9cblx0cy5yZWdpc3RlclNvdW5kID0gZnVuY3Rpb24gKHNyYywgaWQsIGRhdGEsIGJhc2VQYXRoLCBkZWZhdWx0UGxheVByb3BzKSB7XG5cdFx0dmFyIGxvYWRJdGVtID0ge3NyYzogc3JjLCBpZDogaWQsIGRhdGE6ZGF0YSwgZGVmYXVsdFBsYXlQcm9wczpkZWZhdWx0UGxheVByb3BzfTtcblx0XHRpZiAoc3JjIGluc3RhbmNlb2YgT2JqZWN0ICYmIHNyYy5zcmMpIHtcblx0XHRcdGJhc2VQYXRoID0gaWQ7XG5cdFx0XHRsb2FkSXRlbSA9IHNyYztcblx0XHR9XG5cdFx0bG9hZEl0ZW0gPSBjcmVhdGVqcy5Mb2FkSXRlbS5jcmVhdGUobG9hZEl0ZW0pO1xuXHRcdGxvYWRJdGVtLnBhdGggPSBiYXNlUGF0aDtcblxuXHRcdGlmIChiYXNlUGF0aCAhPSBudWxsICYmICEobG9hZEl0ZW0uc3JjIGluc3RhbmNlb2YgT2JqZWN0KSkge2xvYWRJdGVtLnNyYyA9IGJhc2VQYXRoICsgc3JjO31cblxuXHRcdHZhciBsb2FkZXIgPSBzLl9yZWdpc3RlclNvdW5kKGxvYWRJdGVtKTtcblx0XHRpZighbG9hZGVyKSB7cmV0dXJuIGZhbHNlO31cblxuXHRcdGlmICghcy5fcHJlbG9hZEhhc2hbbG9hZEl0ZW0uc3JjXSkgeyBzLl9wcmVsb2FkSGFzaFtsb2FkSXRlbS5zcmNdID0gW107fVxuXHRcdHMuX3ByZWxvYWRIYXNoW2xvYWRJdGVtLnNyY10ucHVzaChsb2FkSXRlbSk7XG5cdFx0aWYgKHMuX3ByZWxvYWRIYXNoW2xvYWRJdGVtLnNyY10ubGVuZ3RoID09IDEpIHtcblx0XHRcdC8vIE9KUiBub3RlIHRoaXMgd2lsbCBkaXNhbGxvdyByZWxvYWRpbmcgYSBzb3VuZCBpZiBsb2FkaW5nIGZhaWxzIG9yIHRoZSBzb3VyY2UgY2hhbmdlc1xuXHRcdFx0bG9hZGVyLm9uKFwiY29tcGxldGVcIiwgY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlTG9hZENvbXBsZXRlLCB0aGlzKSk7XG5cdFx0XHRsb2FkZXIub24oXCJlcnJvclwiLCBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVMb2FkRXJyb3IsIHRoaXMpKTtcblx0XHRcdHMuYWN0aXZlUGx1Z2luLnByZWxvYWQobG9hZGVyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHMuX3ByZWxvYWRIYXNoW2xvYWRJdGVtLnNyY11bMF0gPT0gdHJ1ZSkge3JldHVybiB0cnVlO31cblx0XHR9XG5cblx0XHRyZXR1cm4gbG9hZEl0ZW07XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVyIGFuIGFycmF5IG9mIGF1ZGlvIGZpbGVzIGZvciBsb2FkaW5nIGFuZCBmdXR1cmUgcGxheWJhY2sgaW4gU291bmQuIEl0IGlzIHJlY29tbWVuZGVkIHRvIHJlZ2lzdGVyIGFsbFxuXHQgKiBzb3VuZHMgdGhhdCBuZWVkIHRvIGJlIHBsYXllZCBiYWNrIGluIG9yZGVyIHRvIHByb3Blcmx5IHByZXBhcmUgYW5kIHByZWxvYWQgdGhlbS4gU291bmQgZG9lcyBpbnRlcm5hbCBwcmVsb2FkaW5nXG5cdCAqIHdoZW4gcmVxdWlyZWQuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogXHRcdHZhciBhc3NldFBhdGggPSBcIi4vbXlBdWRpb1BhdGgvXCI7XG5cdCAqICAgICAgdmFyIHNvdW5kcyA9IFtcblx0ICogICAgICAgICAge3NyYzpcImFzc2V0MC5vZ2dcIiwgaWQ6XCJleGFtcGxlXCJ9LFxuXHQgKiAgICAgICAgICB7c3JjOlwiYXNzZXQxLm9nZ1wiLCBpZDpcIjFcIiwgZGF0YTo2fSxcblx0ICogICAgICAgICAge3NyYzpcImFzc2V0Mi5tcDNcIiwgaWQ6XCJ3b3Jrc1wifVxuXHQgKiAgICAgICAgICB7c3JjOnttcDM6XCJwYXRoMS9hc3NldDMubXAzXCIsIG9nZzpcInBhdGgyL2Fzc2V0M05vRXh0ZW5zaW9ufSwgaWQ6XCJiZXR0ZXJcIn1cblx0ICogICAgICBdO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLmFsdGVybmF0ZUV4dGVuc2lvbnMgPSBbXCJtcDNcIl07XHQvLyBpZiB0aGUgcGFzc2VkIGV4dGVuc2lvbiBpcyBub3Qgc3VwcG9ydGVkLCB0cnkgdGhpcyBleHRlbnNpb25cblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5vbihcImZpbGVsb2FkXCIsIGhhbmRsZUxvYWQpOyAvLyBjYWxsIGhhbmRsZUxvYWQgd2hlbiBlYWNoIHNvdW5kIGxvYWRzXG5cdCAqICAgICAgY3JlYXRlanMuU291bmQucmVnaXN0ZXJTb3VuZHMoc291bmRzLCBhc3NldFBhdGgpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHJlZ2lzdGVyU291bmRzXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHNvdW5kcyBBbiBhcnJheSBvZiBvYmplY3RzIHRvIGxvYWQuIE9iamVjdHMgYXJlIGV4cGVjdGVkIHRvIGJlIGluIHRoZSBmb3JtYXQgbmVlZGVkIGZvclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZWdpc3RlclNvdW5kXCJ9fXt7L2Nyb3NzTGlua319OiA8Y29kZT57c3JjOnNyY1VSSSwgaWQ6SUQsIGRhdGE6RGF0YX08L2NvZGU+XG5cdCAqIHdpdGggXCJpZFwiIGFuZCBcImRhdGFcIiBiZWluZyBvcHRpb25hbC5cblx0ICogWW91IGNhbiBhbHNvIHBhc3MgYW4gb2JqZWN0IHdpdGggcGF0aCBhbmQgbWFuaWZlc3QgcHJvcGVydGllcywgd2hlcmUgcGF0aCBpcyBhIGJhc2VQYXRoIGFuZCBtYW5pZmVzdCBpcyBhbiBhcnJheSBvZiBvYmplY3RzIHRvIGxvYWQuXG5cdCAqIE5vdGUgaWQgaXMgcmVxdWlyZWQgaWYgc3JjIGlzIGFuIG9iamVjdCB3aXRoIGV4dGVuc2lvbiBsYWJlbGVkIHNyYyBwcm9wZXJ0aWVzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVBhdGggU2V0IGEgcGF0aCB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIHRvIGVhY2ggc3JjIHdoZW4gbG9hZGluZy4gIFdoZW4gY3JlYXRpbmcsIHBsYXlpbmcsIG9yIHJlbW92aW5nXG5cdCAqIGF1ZGlvIHRoYXQgd2FzIGxvYWRlZCB3aXRoIGEgYmFzZVBhdGggYnkgc3JjLCB0aGUgYmFzZVBhdGggbXVzdCBiZSBpbmNsdWRlZC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBBbiBhcnJheSBvZiBvYmplY3RzIHdpdGggdGhlIG1vZGlmaWVkIHZhbHVlcyB0aGF0IHdlcmUgcGFzc2VkIGluLCB3aGljaCBkZWZpbmVzIGVhY2ggc291bmQuXG5cdCAqIExpa2UgcmVnaXN0ZXJTb3VuZCwgaXQgd2lsbCByZXR1cm4gZmFsc2UgZm9yIGFueSB2YWx1ZXMgd2hlbiB0aGUgc291cmNlIGNhbm5vdCBiZSBwYXJzZWQgb3IgaWYgbm8gcGx1Z2lucyBjYW4gYmUgaW5pdGlhbGl6ZWQuXG5cdCAqIEFsc28sIGl0IHdpbGwgcmV0dXJuIHRydWUgZm9yIGFueSB2YWx1ZXMgd2hlbiB0aGUgc291cmNlIGlzIGFscmVhZHkgbG9hZGVkLlxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5yZWdpc3RlclNvdW5kcyA9IGZ1bmN0aW9uIChzb3VuZHMsIGJhc2VQYXRoKSB7XG5cdFx0dmFyIHJldHVyblZhbHVlcyA9IFtdO1xuXHRcdGlmIChzb3VuZHMucGF0aCkge1xuXHRcdFx0aWYgKCFiYXNlUGF0aCkge1xuXHRcdFx0XHRiYXNlUGF0aCA9IHNvdW5kcy5wYXRoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YmFzZVBhdGggPSBiYXNlUGF0aCArIHNvdW5kcy5wYXRoO1xuXHRcdFx0fVxuXHRcdFx0c291bmRzID0gc291bmRzLm1hbmlmZXN0O1xuXHRcdFx0Ly8gVE9ETyBkb2N1bWVudCB0aGlzIGZlYXR1cmVcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzb3VuZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRyZXR1cm5WYWx1ZXNbaV0gPSBjcmVhdGVqcy5Tb3VuZC5yZWdpc3RlclNvdW5kKHNvdW5kc1tpXS5zcmMsIHNvdW5kc1tpXS5pZCwgc291bmRzW2ldLmRhdGEsIGJhc2VQYXRoLCBzb3VuZHNbaV0uZGVmYXVsdFBsYXlQcm9wcyk7XG5cdFx0fVxuXHRcdHJldHVybiByZXR1cm5WYWx1ZXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhIHNvdW5kIHRoYXQgaGFzIGJlZW4gcmVnaXN0ZXJlZCB3aXRoIHt7I2Nyb3NzTGluayBcIlNvdW5kL3JlZ2lzdGVyU291bmRcIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0ICoge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVnaXN0ZXJTb3VuZHNcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIDxiciAvPk5vdGUgdGhpcyB3aWxsIHN0b3AgcGxheWJhY2sgb24gYWN0aXZlIGluc3RhbmNlcyBwbGF5aW5nIHRoaXMgc291bmQgYmVmb3JlIGRlbGV0aW5nIHRoZW0uXG5cdCAqIDxiciAvPk5vdGUgaWYgeW91IHBhc3NlZCBpbiBhIGJhc2VQYXRoLCB5b3UgbmVlZCB0byBwYXNzIGl0IG9yIHByZXBlbmQgaXQgdG8gdGhlIHNyYyBoZXJlLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuU291bmQucmVtb3ZlU291bmQoXCJteUlEXCIpO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLnJlbW92ZVNvdW5kKFwibXlBdWRpb0Jhc2VQYXRoL215U291bmQub2dnXCIpO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLnJlbW92ZVNvdW5kKFwibXlQYXRoL215T3RoZXJTb3VuZC5tcDNcIiwgXCJteUJhc2VQYXRoL1wiKTtcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5yZW1vdmVTb3VuZCh7bXAzOlwibXVzaWNOb0V4dGVuc2lvblwiLCBvZ2c6XCJtdXNpYy5vZ2dcIn0sIFwibXlCYXNlUGF0aC9cIik7XG5cdCAqXG5cdCAqIEBtZXRob2QgcmVtb3ZlU291bmRcblx0ICogQHBhcmFtIHtTdHJpbmcgfCBPYmplY3R9IHNyYyBUaGUgc3JjIG9yIElEIG9mIHRoZSBhdWRpbywgb3IgYW4gT2JqZWN0IHdpdGggYSBcInNyY1wiIHByb3BlcnR5LCBvciBhbiBPYmplY3Qgd2l0aCBtdWx0aXBsZSBleHRlbnNpb24gbGFiZWxlZCBzcmMgcHJvcGVydGllcy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGJhc2VQYXRoIFNldCBhIHBhdGggdGhhdCB3aWxsIGJlIHByZXBlbmRlZCB0byBlYWNoIHNyYyB3aGVuIHJlbW92aW5nLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHNvdW5kIGlzIHN1Y2Nlc3NmdWxseSByZW1vdmVkLlxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKi9cblx0cy5yZW1vdmVTb3VuZCA9IGZ1bmN0aW9uKHNyYywgYmFzZVBhdGgpIHtcblx0XHRpZiAocy5hY3RpdmVQbHVnaW4gPT0gbnVsbCkge3JldHVybiBmYWxzZTt9XG5cblx0XHRpZiAoc3JjIGluc3RhbmNlb2YgT2JqZWN0ICYmIHNyYy5zcmMpIHtzcmMgPSBzcmMuc3JjO31cblxuXHRcdHZhciBkZXRhaWxzO1xuXHRcdGlmIChzcmMgaW5zdGFuY2VvZiBPYmplY3QpIHtcblx0XHRcdGRldGFpbHMgPSBzLl9wYXJzZVNyYyhzcmMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcmMgPSBzLl9nZXRTcmNCeUlkKHNyYykuc3JjO1xuXHRcdFx0ZGV0YWlscyA9IHMuX3BhcnNlUGF0aChzcmMpO1xuXHRcdH1cblx0XHRpZiAoZGV0YWlscyA9PSBudWxsKSB7cmV0dXJuIGZhbHNlO31cblx0XHRzcmMgPSBkZXRhaWxzLnNyYztcblx0XHRpZiAoYmFzZVBhdGggIT0gbnVsbCkge3NyYyA9IGJhc2VQYXRoICsgc3JjO31cblxuXHRcdGZvcih2YXIgcHJvcCBpbiBzLl9pZEhhc2gpe1xuXHRcdFx0aWYocy5faWRIYXNoW3Byb3BdLnNyYyA9PSBzcmMpIHtcblx0XHRcdFx0ZGVsZXRlKHMuX2lkSGFzaFtwcm9wXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gY2xlYXIgZnJvbSBTb3VuZENoYW5uZWwsIHdoaWNoIGFsc28gc3RvcHMgYW5kIGRlbGV0ZXMgYWxsIGluc3RhbmNlc1xuXHRcdFNvdW5kQ2hhbm5lbC5yZW1vdmVTcmMoc3JjKTtcblxuXHRcdGRlbGV0ZShzLl9wcmVsb2FkSGFzaFtzcmNdKTtcblxuXHRcdHMuYWN0aXZlUGx1Z2luLnJlbW92ZVNvdW5kKHNyYyk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlIGFuIGFycmF5IG9mIGF1ZGlvIGZpbGVzIHRoYXQgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQgd2l0aCB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZWdpc3RlclNvdW5kXCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNvdW5kL3JlZ2lzdGVyU291bmRzXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiA8YnIgLz5Ob3RlIHRoaXMgd2lsbCBzdG9wIHBsYXliYWNrIG9uIGFjdGl2ZSBpbnN0YW5jZXMgcGxheWluZyB0aGlzIGF1ZGlvIGJlZm9yZSBkZWxldGluZyB0aGVtLlxuXHQgKiA8YnIgLz5Ob3RlIGlmIHlvdSBwYXNzZWQgaW4gYSBiYXNlUGF0aCwgeW91IG5lZWQgdG8gcGFzcyBpdCBvciBwcmVwZW5kIGl0IHRvIHRoZSBzcmMgaGVyZS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiBcdFx0YXNzZXRQYXRoID0gXCIuL215UGF0aC9cIjtcblx0ICogICAgICB2YXIgc291bmRzID0gW1xuXHQgKiAgICAgICAgICB7c3JjOlwiYXNzZXQwLm9nZ1wiLCBpZDpcImV4YW1wbGVcIn0sXG5cdCAqICAgICAgICAgIHtzcmM6XCJhc3NldDEub2dnXCIsIGlkOlwiMVwiLCBkYXRhOjZ9LFxuXHQgKiAgICAgICAgICB7c3JjOlwiYXNzZXQyLm1wM1wiLCBpZDpcIndvcmtzXCJ9XG5cdCAqICAgICAgXTtcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5yZW1vdmVTb3VuZHMoc291bmRzLCBhc3NldFBhdGgpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHJlbW92ZVNvdW5kc1xuXHQgKiBAcGFyYW0ge0FycmF5fSBzb3VuZHMgQW4gYXJyYXkgb2Ygb2JqZWN0cyB0byByZW1vdmUuIE9iamVjdHMgYXJlIGV4cGVjdGVkIHRvIGJlIGluIHRoZSBmb3JtYXQgbmVlZGVkIGZvclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZW1vdmVTb3VuZFwifX17ey9jcm9zc0xpbmt9fTogPGNvZGU+e3NyY09ySUQ6c3JjVVJJb3JJRH08L2NvZGU+LlxuXHQgKiBZb3UgY2FuIGFsc28gcGFzcyBhbiBvYmplY3Qgd2l0aCBwYXRoIGFuZCBtYW5pZmVzdCBwcm9wZXJ0aWVzLCB3aGVyZSBwYXRoIGlzIGEgYmFzZVBhdGggYW5kIG1hbmlmZXN0IGlzIGFuIGFycmF5IG9mIG9iamVjdHMgdG8gcmVtb3ZlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVBhdGggU2V0IGEgcGF0aCB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIHRvIGVhY2ggc3JjIHdoZW4gcmVtb3ZpbmcuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQW4gYXJyYXkgb2YgQm9vbGVhbiB2YWx1ZXMgcmVwcmVzZW50aW5nIGlmIHRoZSBzb3VuZHMgd2l0aCB0aGUgc2FtZSBhcnJheSBpbmRleCB3ZXJlXG5cdCAqIHN1Y2Nlc3NmdWxseSByZW1vdmVkLlxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKi9cblx0cy5yZW1vdmVTb3VuZHMgPSBmdW5jdGlvbiAoc291bmRzLCBiYXNlUGF0aCkge1xuXHRcdHZhciByZXR1cm5WYWx1ZXMgPSBbXTtcblx0XHRpZiAoc291bmRzLnBhdGgpIHtcblx0XHRcdGlmICghYmFzZVBhdGgpIHtcblx0XHRcdFx0YmFzZVBhdGggPSBzb3VuZHMucGF0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJhc2VQYXRoID0gYmFzZVBhdGggKyBzb3VuZHMucGF0aDtcblx0XHRcdH1cblx0XHRcdHNvdW5kcyA9IHNvdW5kcy5tYW5pZmVzdDtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzb3VuZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRyZXR1cm5WYWx1ZXNbaV0gPSBjcmVhdGVqcy5Tb3VuZC5yZW1vdmVTb3VuZChzb3VuZHNbaV0uc3JjLCBiYXNlUGF0aCk7XG5cdFx0fVxuXHRcdHJldHVybiByZXR1cm5WYWx1ZXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbGwgc291bmRzIHRoYXQgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQgd2l0aCB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZWdpc3RlclNvdW5kXCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNvdW5kL3JlZ2lzdGVyU291bmRzXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiA8YnIgLz5Ob3RlIHRoaXMgd2lsbCBzdG9wIHBsYXliYWNrIG9uIGFsbCBhY3RpdmUgc291bmQgaW5zdGFuY2VzIGJlZm9yZSBkZWxldGluZyB0aGVtLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICBjcmVhdGVqcy5Tb3VuZC5yZW1vdmVBbGxTb3VuZHMoKTtcblx0ICpcblx0ICogQG1ldGhvZCByZW1vdmVBbGxTb3VuZHNcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC40LjFcblx0ICovXG5cdHMucmVtb3ZlQWxsU291bmRzID0gZnVuY3Rpb24oKSB7XG5cdFx0cy5faWRIYXNoID0ge307XG5cdFx0cy5fcHJlbG9hZEhhc2ggPSB7fTtcblx0XHRTb3VuZENoYW5uZWwucmVtb3ZlQWxsKCk7XG5cdFx0aWYgKHMuYWN0aXZlUGx1Z2luKSB7cy5hY3RpdmVQbHVnaW4ucmVtb3ZlQWxsU291bmRzKCk7fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBhIHNvdXJjZSBoYXMgYmVlbiBsb2FkZWQgYnkgaW50ZXJuYWwgcHJlbG9hZGVycy4gVGhpcyBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIHRoYXQgc291bmRzIHRoYXQgYXJlXG5cdCAqIG5vdCBjb21wbGV0ZWQgcHJlbG9hZGluZyB3aWxsIG5vdCBraWNrIG9mZiBhIG5ldyBpbnRlcm5hbCBwcmVsb2FkIGlmIHRoZXkgYXJlIHBsYXllZC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgdmFyIG15U291bmQgPSBcImFzc2V0UGF0aC9hc3NldDAub2dnXCI7XG5cdCAqICAgICBpZihjcmVhdGVqcy5Tb3VuZC5sb2FkQ29tcGxldGUobXlTb3VuZCkge1xuXHQgKiAgICAgICAgIGNyZWF0ZWpzLlNvdW5kLnBsYXkobXlTb3VuZCk7XG5cdCAqICAgICB9XG5cdCAqXG5cdCAqIEBtZXRob2QgbG9hZENvbXBsZXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNyYyBvciBpZCB0aGF0IGlzIGJlaW5nIGxvYWRlZC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIHNyYyBpcyBhbHJlYWR5IGxvYWRlZC5cblx0ICogQHNpbmNlIDAuNC4wXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMubG9hZENvbXBsZXRlID0gZnVuY3Rpb24gKHNyYykge1xuXHRcdGlmICghcy5pc1JlYWR5KCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dmFyIGRldGFpbHMgPSBzLl9wYXJzZVBhdGgoc3JjKTtcblx0XHRpZiAoZGV0YWlscykge1xuXHRcdFx0c3JjID0gcy5fZ2V0U3JjQnlJZChkZXRhaWxzLnNyYykuc3JjO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcmMgPSBzLl9nZXRTcmNCeUlkKHNyYykuc3JjO1xuXHRcdH1cblx0XHRpZihzLl9wcmVsb2FkSGFzaFtzcmNdID09IHVuZGVmaW5lZCkge3JldHVybiBmYWxzZTt9XG5cdFx0cmV0dXJuIChzLl9wcmVsb2FkSGFzaFtzcmNdWzBdID09IHRydWUpOyAgLy8gc3JjIG9ubHkgbG9hZHMgb25jZSwgc28gaWYgaXQncyB0cnVlIGZvciB0aGUgZmlyc3QgaXQncyB0cnVlIGZvciBhbGxcblx0fTtcblxuXHQvKipcblx0ICogUGFyc2UgdGhlIHBhdGggb2YgYSBzb3VuZC4gQWx0ZXJuYXRlIGV4dGVuc2lvbnMgd2lsbCBiZSBhdHRlbXB0ZWQgaW4gb3JkZXIgaWYgdGhlXG5cdCAqIGN1cnJlbnQgZXh0ZW5zaW9uIGlzIG5vdCBzdXBwb3J0ZWRcblx0ICogQG1ldGhvZCBfcGFyc2VQYXRoXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgcGF0aCB0byBhbiBhdWRpbyBzb3VyY2UuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQSBmb3JtYXR0ZWQgb2JqZWN0IHRoYXQgY2FuIGJlIHJlZ2lzdGVyZWQgd2l0aCB0aGUge3sjY3Jvc3NMaW5rIFwiU291bmQvYWN0aXZlUGx1Z2luOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGFuZCByZXR1cm5lZCB0byBhIHByZWxvYWRlciBsaWtlIDxhIGhyZWY9XCJodHRwOi8vcHJlbG9hZGpzLmNvbVwiIHRhcmdldD1cIl9ibGFua1wiPlByZWxvYWRKUzwvYT4uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5fcGFyc2VQYXRoID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHR5cGVvZih2YWx1ZSkgIT0gXCJzdHJpbmdcIikge3ZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTt9XG5cblx0XHR2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaChzLkZJTEVfUEFUVEVSTik7XG5cdFx0aWYgKG1hdGNoID09IG51bGwpIHtyZXR1cm4gZmFsc2U7fVxuXG5cdFx0dmFyIG5hbWUgPSBtYXRjaFs0XTtcblx0XHR2YXIgZXh0ID0gbWF0Y2hbNV07XG5cdFx0dmFyIGMgPSBzLmNhcGFiaWxpdGllcztcblx0XHR2YXIgaSA9IDA7XG5cdFx0d2hpbGUgKCFjW2V4dF0pIHtcblx0XHRcdGV4dCA9IHMuYWx0ZXJuYXRlRXh0ZW5zaW9uc1tpKytdO1xuXHRcdFx0aWYgKGkgPiBzLmFsdGVybmF0ZUV4dGVuc2lvbnMubGVuZ3RoKSB7IHJldHVybiBudWxsO31cdC8vIG5vIGV4dGVuc2lvbnMgYXJlIHN1cHBvcnRlZFxuXHRcdH1cblx0XHR2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoXCIuXCIrbWF0Y2hbNV0sIFwiLlwiK2V4dCk7XG5cblx0XHR2YXIgcmV0ID0ge25hbWU6bmFtZSwgc3JjOnZhbHVlLCBleHRlbnNpb246ZXh0fTtcblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXJzZSB0aGUgcGF0aCBvZiBhIHNvdW5kIGJhc2VkIG9uIHByb3BlcnRpZXMgb2Ygc3JjIG1hdGNoaW5nIHdpdGggc3VwcG9ydGVkIGV4dGVuc2lvbnMuXG5cdCAqIFJldHVybnMgZmFsc2UgaWYgbm9uZSBvZiB0aGUgcHJvcGVydGllcyBhcmUgc3VwcG9ydGVkXG5cdCAqIEBtZXRob2QgX3BhcnNlU3JjXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgcGF0aHMgdG8gYW4gYXVkaW8gc291cmNlLCBpbmRleGVkIGJ5IGV4dGVuc2lvbiB0eXBlLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEEgZm9ybWF0dGVkIG9iamVjdCB0aGF0IGNhbiBiZSByZWdpc3RlcmVkIHdpdGggdGhlIHt7I2Nyb3NzTGluayBcIlNvdW5kL2FjdGl2ZVBsdWdpbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBhbmQgcmV0dXJuZWQgdG8gYSBwcmVsb2FkZXIgbGlrZSA8YSBocmVmPVwiaHR0cDovL3ByZWxvYWRqcy5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIj5QcmVsb2FkSlM8L2E+LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuX3BhcnNlU3JjID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dmFyIHJldCA9IHtuYW1lOnVuZGVmaW5lZCwgc3JjOnVuZGVmaW5lZCwgZXh0ZW5zaW9uOnVuZGVmaW5lZH07XG5cdFx0dmFyIGMgPSBzLmNhcGFiaWxpdGllcztcblxuXHRcdGZvciAodmFyIHByb3AgaW4gdmFsdWUpIHtcblx0XHQgIGlmKHZhbHVlLmhhc093blByb3BlcnR5KHByb3ApICYmIGNbcHJvcF0pIHtcblx0XHRcdFx0cmV0LnNyYyA9IHZhbHVlW3Byb3BdO1xuXHRcdFx0XHRyZXQuZXh0ZW5zaW9uID0gcHJvcDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0ICB9XG5cdFx0fVxuXHRcdGlmICghcmV0LnNyYykge3JldHVybiBmYWxzZTt9XHQvLyBubyBtYXRjaGVzXG5cblx0XHR2YXIgaSA9IHJldC5zcmMubGFzdEluZGV4T2YoXCIvXCIpO1xuXHRcdGlmIChpICE9IC0xKSB7XG5cdFx0XHRyZXQubmFtZSA9IHJldC5zcmMuc2xpY2UoaSsxKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0Lm5hbWUgPSByZXQuc3JjO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH07XG5cblx0LyogLS0tLS0tLS0tLS0tLS0tXG5cdCBTdGF0aWMgQVBJLlxuXHQgLS0tLS0tLS0tLS0tLS0tICovXG5cdC8qKlxuXHQgKiBQbGF5IGEgc291bmQgYW5kIGdldCBhIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fSB0byBjb250cm9sLiBJZiB0aGUgc291bmQgZmFpbHMgdG8gcGxheSwgYVxuXHQgKiBBYnN0cmFjdFNvdW5kSW5zdGFuY2Ugd2lsbCBzdGlsbCBiZSByZXR1cm5lZCwgYW5kIGhhdmUgYSBwbGF5U3RhdGUgb2Yge3sjY3Jvc3NMaW5rIFwiU291bmQvUExBWV9GQUlMRUQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIE5vdGUgdGhhdCBldmVuIG9uIHNvdW5kcyB3aXRoIGZhaWxlZCBwbGF5YmFjaywgeW91IG1heSBzdGlsbCBiZSBhYmxlIHRvIGNhbGwgQWJzdHJhY3RTb3VuZEluc3RhbmNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9wbGF5XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBzaW5jZSB0aGUgZmFpbHVyZSBjb3VsZCBiZSBkdWUgdG8gbGFjayBvZiBhdmFpbGFibGUgY2hhbm5lbHMuIElmIHRoZSBzcmMgZG9lcyBub3QgaGF2ZSBhIHN1cHBvcnRlZCBleHRlbnNpb24gb3Jcblx0ICogaWYgdGhlcmUgaXMgbm8gYXZhaWxhYmxlIHBsdWdpbiwgYSBkZWZhdWx0IEFic3RyYWN0U291bmRJbnN0YW5jZSB3aWxsIGJlIHJldHVybmVkIHdoaWNoIHdpbGwgbm90IHBsYXkgYW55IGF1ZGlvLCBidXQgd2lsbCBub3QgZ2VuZXJhdGUgZXJyb3JzLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuU291bmQub24oXCJmaWxlbG9hZFwiLCBoYW5kbGVMb2FkKTtcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5yZWdpc3RlclNvdW5kKFwibXlBdWRpb1BhdGgvbXlTb3VuZC5tcDNcIiwgXCJteUlEXCIsIDMpO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZUxvYWQoZXZlbnQpIHtcblx0ICogICAgICBcdGNyZWF0ZWpzLlNvdW5kLnBsYXkoXCJteUlEXCIpO1xuXHQgKiAgICAgIFx0Ly8gc3RvcmUgb2ZmIEFic3RyYWN0U291bmRJbnN0YW5jZSBmb3IgY29udHJvbGxpbmdcblx0ICogICAgICBcdHZhciBteUluc3RhbmNlID0gY3JlYXRlanMuU291bmQucGxheShcIm15SURcIiwge2ludGVycnVwdDogY3JlYXRlanMuU291bmQuSU5URVJSVVBUX0FOWSwgbG9vcDotMX0pO1xuXHQgKiAgICAgIH1cblx0ICpcblx0ICogTk9URSB0byBjcmVhdGUgYW4gYXVkaW8gc3ByaXRlIHRoYXQgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCwgYm90aCBzdGFydFRpbWUgYW5kIGR1cmF0aW9uIG5lZWQgdG8gYmUgc2V0LlxuXHQgKiBUaGlzIGlzIG9ubHkgd2hlbiBjcmVhdGluZyBhIG5ldyBhdWRpbyBzcHJpdGUsIG5vdCB3aGVuIHBsYXlpbmcgdXNpbmcgdGhlIGlkIG9mIGFuIGFscmVhZHkgcmVnaXN0ZXJlZCBhdWRpbyBzcHJpdGUuXG5cdCAqXG5cdCAqIDxiPlBhcmFtZXRlcnMgRGVwcmVjYXRlZDwvYj48YnIgLz5cblx0ICogVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgbWV0aG9kIGFyZSBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGEgc2luZ2xlIHBhcmFtZXRlciB0aGF0IGlzIGFuIE9iamVjdCBvciB7eyNjcm9zc0xpbmsgXCJQbGF5UHJvcHNDb25maWdcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIEBtZXRob2QgcGxheVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzcmMgb3IgSUQgb2YgdGhlIGF1ZGlvLlxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE9iamVjdH0gW2ludGVycnVwdD1cIm5vbmVcInxvcHRpb25zXSA8Yj5UaGlzIHBhcmFtZXRlciB3aWxsIGJlIHJlbmFtZWQgcGxheVByb3BzIGluIHRoZSBuZXh0IHJlbGVhc2UuPC9iPjxiciAvPlxuXHQgKiBUaGlzIHBhcmFtZXRlciBjYW4gYmUgYW4gaW5zdGFuY2Ugb2Yge3sjY3Jvc3NMaW5rIFwiUGxheVByb3BzQ29uZmlnXCJ9fXt7L2Nyb3NzTGlua319IG9yIGFuIE9iamVjdCB0aGF0IGNvbnRhaW5zIGFueSBvciBhbGwgb3B0aW9uYWwgcHJvcGVydGllcyBieSBuYW1lLFxuXHQgKiBpbmNsdWRpbmc6IGludGVycnVwdCwgZGVsYXksIG9mZnNldCwgbG9vcCwgdm9sdW1lLCBwYW4sIHN0YXJ0VGltZSwgYW5kIGR1cmF0aW9uIChzZWUgdGhlIGFib3ZlIGNvZGUgc2FtcGxlKS5cblx0ICogPGJyIC8+PHN0cm9uZz5PUjwvc3Ryb25nPjxiciAvPlxuXHQgKiA8Yj5EZXByZWNhdGVkPC9iPiBIb3cgdG8gaW50ZXJydXB0IGFueSBjdXJyZW50bHkgcGxheWluZyBpbnN0YW5jZXMgb2YgYXVkaW8gd2l0aCB0aGUgc2FtZSBzb3VyY2UsXG5cdCAqIGlmIHRoZSBtYXhpbXVtIG51bWJlciBvZiBpbnN0YW5jZXMgb2YgdGhlIHNvdW5kIGFyZSBhbHJlYWR5IHBsYXlpbmcuIFZhbHVlcyBhcmUgZGVmaW5lZCBhcyA8Y29kZT5JTlRFUlJVUFRfVFlQRTwvY29kZT5cblx0ICogY29uc3RhbnRzIG9uIHRoZSBTb3VuZCBjbGFzcywgd2l0aCB0aGUgZGVmYXVsdCBkZWZpbmVkIGJ5IHt7I2Nyb3NzTGluayBcIlNvdW5kL2RlZmF1bHRJbnRlcnJ1cHRCZWhhdmlvcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtkZWxheT0wXSA8Yj5EZXByZWNhdGVkPC9iPiBUaGUgYW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgdGhlIHN0YXJ0IG9mIGF1ZGlvIHBsYXliYWNrLCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0PTBdIDxiPkRlcHJlY2F0ZWQ8L2I+IFRoZSBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGF1ZGlvIHRvIGJlZ2luIHBsYXliYWNrLCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbbG9vcD0wXSA8Yj5EZXByZWNhdGVkPC9iPiBIb3cgbWFueSB0aW1lcyB0aGUgYXVkaW8gbG9vcHMgd2hlbiBpdCByZWFjaGVzIHRoZSBlbmQgb2YgcGxheWJhY2suIFRoZSBkZWZhdWx0IGlzIDAgKG5vXG5cdCAqIGxvb3BzKSwgYW5kIC0xIGNhbiBiZSB1c2VkIGZvciBpbmZpbml0ZSBwbGF5YmFjay5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt2b2x1bWU9MV0gPGI+RGVwcmVjYXRlZDwvYj4gVGhlIHZvbHVtZSBvZiB0aGUgc291bmQsIGJldHdlZW4gMCBhbmQgMS4gTm90ZSB0aGF0IHRoZSBtYXN0ZXIgdm9sdW1lIGlzIGFwcGxpZWRcblx0ICogYWdhaW5zdCB0aGUgaW5kaXZpZHVhbCB2b2x1bWUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcGFuPTBdIDxiPkRlcHJlY2F0ZWQ8L2I+IFRoZSBsZWZ0LXJpZ2h0IHBhbiBvZiB0aGUgc291bmQgKGlmIHN1cHBvcnRlZCksIGJldHdlZW4gLTEgKGxlZnQpIGFuZCAxIChyaWdodCkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRUaW1lPW51bGxdIDxiPkRlcHJlY2F0ZWQ8L2I+IFRvIGNyZWF0ZSBhbiBhdWRpbyBzcHJpdGUgKHdpdGggZHVyYXRpb24pLCB0aGUgaW5pdGlhbCBvZmZzZXQgdG8gc3RhcnQgcGxheWJhY2sgYW5kIGxvb3AgZnJvbSwgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2R1cmF0aW9uPW51bGxdIDxiPkRlcHJlY2F0ZWQ8L2I+IFRvIGNyZWF0ZSBhbiBhdWRpbyBzcHJpdGUgKHdpdGggc3RhcnRUaW1lKSwgdGhlIGFtb3VudCBvZiB0aW1lIHRvIHBsYXkgdGhlIGNsaXAgZm9yLCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gQSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2VcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBjYW4gYmUgY29udHJvbGxlZCBhZnRlciBpdCBpcyBjcmVhdGVkLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLnBsYXkgPSBmdW5jdGlvbiAoc3JjLCBpbnRlcnJ1cHQsIGRlbGF5LCBvZmZzZXQsIGxvb3AsIHZvbHVtZSwgcGFuLCBzdGFydFRpbWUsIGR1cmF0aW9uKSB7XG5cdFx0dmFyIHBsYXlQcm9wcztcblx0XHRpZiAoaW50ZXJydXB0IGluc3RhbmNlb2YgT2JqZWN0IHx8IGludGVycnVwdCBpbnN0YW5jZW9mIGNyZWF0ZWpzLlBsYXlQcm9wc0NvbmZpZykge1xuXHRcdFx0cGxheVByb3BzID0gY3JlYXRlanMuUGxheVByb3BzQ29uZmlnLmNyZWF0ZShpbnRlcnJ1cHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwbGF5UHJvcHMgPSBjcmVhdGVqcy5QbGF5UHJvcHNDb25maWcuY3JlYXRlKHtpbnRlcnJ1cHQ6aW50ZXJydXB0LCBkZWxheTpkZWxheSwgb2Zmc2V0Om9mZnNldCwgbG9vcDpsb29wLCB2b2x1bWU6dm9sdW1lLCBwYW46cGFuLCBzdGFydFRpbWU6c3RhcnRUaW1lLCBkdXJhdGlvbjpkdXJhdGlvbn0pO1xuXHRcdH1cblx0XHR2YXIgaW5zdGFuY2UgPSBzLmNyZWF0ZUluc3RhbmNlKHNyYywgcGxheVByb3BzLnN0YXJ0VGltZSwgcGxheVByb3BzLmR1cmF0aW9uKTtcblx0XHR2YXIgb2sgPSBzLl9wbGF5SW5zdGFuY2UoaW5zdGFuY2UsIHBsYXlQcm9wcyk7XG5cdFx0aWYgKCFvaykge2luc3RhbmNlLl9wbGF5RmFpbGVkKCk7fVxuXHRcdHJldHVybiBpbnN0YW5jZTtcblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fSB1c2luZyB0aGUgcGFzc2VkIGluIHNyYy4gSWYgdGhlIHNyYyBkb2VzIG5vdCBoYXZlIGFcblx0ICogc3VwcG9ydGVkIGV4dGVuc2lvbiBvciBpZiB0aGVyZSBpcyBubyBhdmFpbGFibGUgcGx1Z2luLCBhIGRlZmF1bHQgQWJzdHJhY3RTb3VuZEluc3RhbmNlIHdpbGwgYmUgcmV0dXJuZWQgdGhhdCBjYW4gYmVcblx0ICogY2FsbGVkIHNhZmVseSBidXQgZG9lcyBub3RoaW5nLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIG15SW5zdGFuY2UgPSBudWxsO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLm9uKFwiZmlsZWxvYWRcIiwgaGFuZGxlTG9hZCk7XG5cdCAqICAgICAgY3JlYXRlanMuU291bmQucmVnaXN0ZXJTb3VuZChcIm15QXVkaW9QYXRoL215U291bmQubXAzXCIsIFwibXlJRFwiLCAzKTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVMb2FkKGV2ZW50KSB7XG5cdCAqICAgICAgXHRteUluc3RhbmNlID0gY3JlYXRlanMuU291bmQuY3JlYXRlSW5zdGFuY2UoXCJteUlEXCIpO1xuXHQgKiAgICAgIFx0Ly8gYWx0ZXJuYXRlbHkgd2UgY291bGQgY2FsbCB0aGUgZm9sbG93aW5nXG5cdCAqICAgICAgXHRteUluc3RhbmNlID0gY3JlYXRlanMuU291bmQuY3JlYXRlSW5zdGFuY2UoXCJteUF1ZGlvUGF0aC9teVNvdW5kLm1wM1wiKTtcblx0ICogICAgICB9XG5cdCAqXG5cdCAqIE5PVEUgdG8gY3JlYXRlIGFuIGF1ZGlvIHNwcml0ZSB0aGF0IGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQsIGJvdGggc3RhcnRUaW1lIGFuZCBkdXJhdGlvbiBuZWVkIHRvIGJlIHNldC5cblx0ICogVGhpcyBpcyBvbmx5IHdoZW4gY3JlYXRpbmcgYSBuZXcgYXVkaW8gc3ByaXRlLCBub3Qgd2hlbiBwbGF5aW5nIHVzaW5nIHRoZSBpZCBvZiBhbiBhbHJlYWR5IHJlZ2lzdGVyZWQgYXVkaW8gc3ByaXRlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGNyZWF0ZUluc3RhbmNlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNyYyBvciBJRCBvZiB0aGUgYXVkaW8uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRUaW1lPW51bGxdIFRvIGNyZWF0ZSBhbiBhdWRpbyBzcHJpdGUgKHdpdGggZHVyYXRpb24pLCB0aGUgaW5pdGlhbCBvZmZzZXQgdG8gc3RhcnQgcGxheWJhY2sgYW5kIGxvb3AgZnJvbSwgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2R1cmF0aW9uPW51bGxdIFRvIGNyZWF0ZSBhbiBhdWRpbyBzcHJpdGUgKHdpdGggc3RhcnRUaW1lKSwgdGhlIGFtb3VudCBvZiB0aW1lIHRvIHBsYXkgdGhlIGNsaXAgZm9yLCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gQSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2VcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBjYW4gYmUgY29udHJvbGxlZCBhZnRlciBpdCBpcyBjcmVhdGVkLlxuXHQgKiBVbnN1cHBvcnRlZCBleHRlbnNpb25zIHdpbGwgcmV0dXJuIHRoZSBkZWZhdWx0IEFic3RyYWN0U291bmRJbnN0YW5jZS5cblx0ICogQHNpbmNlIDAuNC4wXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY3JlYXRlSW5zdGFuY2UgPSBmdW5jdGlvbiAoc3JjLCBzdGFydFRpbWUsIGR1cmF0aW9uKSB7XG5cdFx0aWYgKCFzLmluaXRpYWxpemVEZWZhdWx0UGx1Z2lucygpKSB7cmV0dXJuIG5ldyBjcmVhdGVqcy5EZWZhdWx0U291bmRJbnN0YW5jZShzcmMsIHN0YXJ0VGltZSwgZHVyYXRpb24pO31cblxuXHRcdHZhciBkZWZhdWx0UGxheVByb3BzID0gcy5fZGVmYXVsdFBsYXlQcm9wc0hhc2hbc3JjXTtcdC8vIGZvciBhdWRpbyBzcHJpdGVzLCB3aGljaCBjcmVhdGUgYW5kIHN0b3JlIGRlZmF1bHRzIGJ5IGlkXG5cdFx0c3JjID0gcy5fZ2V0U3JjQnlJZChzcmMpO1xuXG5cdFx0dmFyIGRldGFpbHMgPSBzLl9wYXJzZVBhdGgoc3JjLnNyYyk7XG5cblx0XHR2YXIgaW5zdGFuY2UgPSBudWxsO1xuXHRcdGlmIChkZXRhaWxzICE9IG51bGwgJiYgZGV0YWlscy5zcmMgIT0gbnVsbCkge1xuXHRcdFx0U291bmRDaGFubmVsLmNyZWF0ZShkZXRhaWxzLnNyYyk7XG5cdFx0XHRpZiAoc3RhcnRUaW1lID09IG51bGwpIHtzdGFydFRpbWUgPSBzcmMuc3RhcnRUaW1lO31cblx0XHRcdGluc3RhbmNlID0gcy5hY3RpdmVQbHVnaW4uY3JlYXRlKGRldGFpbHMuc3JjLCBzdGFydFRpbWUsIGR1cmF0aW9uIHx8IHNyYy5kdXJhdGlvbik7XG5cblx0XHRcdGRlZmF1bHRQbGF5UHJvcHMgPSBkZWZhdWx0UGxheVByb3BzIHx8IHMuX2RlZmF1bHRQbGF5UHJvcHNIYXNoW2RldGFpbHMuc3JjXTtcblx0XHRcdGlmKGRlZmF1bHRQbGF5UHJvcHMpIHtcblx0XHRcdFx0aW5zdGFuY2UuYXBwbHlQbGF5UHJvcHMoZGVmYXVsdFBsYXlQcm9wcyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGluc3RhbmNlID0gbmV3IGNyZWF0ZWpzLkRlZmF1bHRTb3VuZEluc3RhbmNlKHNyYywgc3RhcnRUaW1lLCBkdXJhdGlvbik7XG5cdFx0fVxuXG5cdFx0aW5zdGFuY2UudW5pcXVlSWQgPSBzLl9sYXN0SUQrKztcblxuXHRcdHJldHVybiBpbnN0YW5jZTtcblx0fTtcblxuXHQvKipcblx0ICogU3RvcCBhbGwgYXVkaW8gKGdsb2JhbCBzdG9wKS4gU3RvcHBlZCBhdWRpbyBpcyByZXNldCwgYW5kIG5vdCBwYXVzZWQuIFRvIHBsYXkgYXVkaW8gdGhhdCBoYXMgYmVlbiBzdG9wcGVkLFxuXHQgKiBjYWxsIEFic3RyYWN0U291bmRJbnN0YW5jZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvcGxheVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgY3JlYXRlanMuU291bmQuc3RvcCgpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHN0b3Bcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5zdG9wID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpbnN0YW5jZXMgPSB0aGlzLl9pbnN0YW5jZXM7XG5cdFx0Zm9yICh2YXIgaSA9IGluc3RhbmNlcy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRpbnN0YW5jZXNbaV0uc3RvcCgpOyAgLy8gTk9URSBzdG9wIHJlbW92ZXMgaW5zdGFuY2UgZnJvbSB0aGlzLl9pbnN0YW5jZXNcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIERlcHJlY2F0ZWQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiU291bmQvdm9sdW1lOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqXG5cdCAqIEBtZXRob2Qgc2V0Vm9sdW1lXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgbWFzdGVyIHZvbHVtZSB2YWx1ZS4gVGhlIGFjY2VwdGFibGUgcmFuZ2UgaXMgMC0xLlxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHRzLnNldFZvbHVtZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmIChOdW1iZXIodmFsdWUpID09IG51bGwpIHtyZXR1cm4gZmFsc2U7fVxuXHRcdHZhbHVlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdmFsdWUpKTtcblx0XHRzLl9tYXN0ZXJWb2x1bWUgPSB2YWx1ZTtcblx0XHRpZiAoIXRoaXMuYWN0aXZlUGx1Z2luIHx8ICF0aGlzLmFjdGl2ZVBsdWdpbi5zZXRWb2x1bWUgfHwgIXRoaXMuYWN0aXZlUGx1Z2luLnNldFZvbHVtZSh2YWx1ZSkpIHtcblx0XHRcdHZhciBpbnN0YW5jZXMgPSB0aGlzLl9pbnN0YW5jZXM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGluc3RhbmNlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aW5zdGFuY2VzW2ldLnNldE1hc3RlclZvbHVtZSh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXByZWNhdGVkLCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIlNvdW5kL3ZvbHVtZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGdldFZvbHVtZVxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBtYXN0ZXIgdm9sdW1lLCBpbiBhIHJhbmdlIG9mIDAtMS5cblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0cy5nZXRWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hc3RlclZvbHVtZTtcblx0fTtcblxuXHQvKipcblx0ICogRGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9tdXRlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHNldE11dGVcblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBXaGV0aGVyIHRoZSBhdWRpbyBzaG91bGQgYmUgbXV0ZWQgb3Igbm90LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgbXV0ZSB3YXMgc2V0LlxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0cy5zZXRNdXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09IG51bGwpIHtyZXR1cm4gZmFsc2U7fVxuXG5cdFx0dGhpcy5fbWFzdGVyTXV0ZSA9IHZhbHVlO1xuXHRcdGlmICghdGhpcy5hY3RpdmVQbHVnaW4gfHwgIXRoaXMuYWN0aXZlUGx1Z2luLnNldE11dGUgfHwgIXRoaXMuYWN0aXZlUGx1Z2luLnNldE11dGUodmFsdWUpKSB7XG5cdFx0XHR2YXIgaW5zdGFuY2VzID0gdGhpcy5faW5zdGFuY2VzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBpbnN0YW5jZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGluc3RhbmNlc1tpXS5zZXRNYXN0ZXJNdXRlKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIERlcHJlY2F0ZWQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiU291bmQvbXV0ZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICpcblx0ICogQG1ldGhvZCBnZXRNdXRlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRoZSBtdXRlIHZhbHVlIG9mIFNvdW5kLlxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0cy5nZXRNdXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXN0ZXJNdXRlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGRlZmF1bHQgcGxheWJhY2sgcHJvcGVydGllcyBmb3IgYWxsIG5ldyBTb3VuZEluc3RhbmNlcyBvZiB0aGUgcGFzc2VkIGluIHNyYyBvciBJRC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlBsYXlQcm9wc0NvbmZpZ1wifX17ey9jcm9zc0xpbmt9fSBmb3IgYXZhaWxhYmxlIHByb3BlcnRpZXMuXG5cdCAqXG5cdCAqIEBtZXRob2Qgc2V0RGVmYXVsdFBsYXlQcm9wc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzcmMgb3IgSUQgdXNlZCB0byByZWdpc3RlciB0aGUgYXVkaW8uXG5cdCAqIEBwYXJhbSB7T2JqZWN0IHwgUGxheVByb3BzQ29uZmlnfSBwbGF5UHJvcHMgVGhlIHBsYXliYWNrIHByb3BlcnRpZXMgeW91IHdvdWxkIGxpa2UgdG8gc2V0LlxuXHQgKiBAc2luY2UgMC42LjFcblx0ICovXG5cdHMuc2V0RGVmYXVsdFBsYXlQcm9wcyA9IGZ1bmN0aW9uKHNyYywgcGxheVByb3BzKSB7XG5cdFx0c3JjID0gcy5fZ2V0U3JjQnlJZChzcmMpO1xuXHRcdHMuX2RlZmF1bHRQbGF5UHJvcHNIYXNoW3MuX3BhcnNlUGF0aChzcmMuc3JjKS5zcmNdID0gY3JlYXRlanMuUGxheVByb3BzQ29uZmlnLmNyZWF0ZShwbGF5UHJvcHMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGRlZmF1bHQgcGxheWJhY2sgcHJvcGVydGllcyBmb3IgdGhlIHBhc3NlZCBpbiBzcmMgb3IgSUQuICBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBhcHBsaWVkIHRvIGFsbFxuXHQgKiBuZXcgU291bmRJbnN0YW5jZXMuICBSZXR1cm5zIG51bGwgaWYgZGVmYXVsdCBkb2VzIG5vdCBleGlzdC5cblx0ICpcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UGxheVByb3BzXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNyYyBvciBJRCB1c2VkIHRvIHJlZ2lzdGVyIHRoZSBhdWRpby5cblx0ICogQHJldHVybnMge1BsYXlQcm9wc0NvbmZpZ30gcmV0dXJucyBhbiBleGlzdGluZyBQbGF5UHJvcHNDb25maWcgb3IgbnVsbCBpZiBvbmUgZG9lcyBub3QgZXhpc3Rcblx0ICogQHNpbmNlIDAuNi4xXG5cdCAqL1xuXHRzLmdldERlZmF1bHRQbGF5UHJvcHMgPSBmdW5jdGlvbihzcmMpIHtcblx0XHRzcmMgPSBzLl9nZXRTcmNCeUlkKHNyYyk7XG5cdFx0cmV0dXJuIHMuX2RlZmF1bHRQbGF5UHJvcHNIYXNoW3MuX3BhcnNlUGF0aChzcmMuc3JjKS5zcmNdO1xuXHR9O1xuXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tXG5cdCBJbnRlcm5hbCBtZXRob2RzXG5cdCAtLS0tLS0tLS0tLS0tLS0gKi9cblx0LyoqXG5cdCAqIFBsYXkgYW4gaW5zdGFuY2UuIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSBzdGF0aWMgQVBJLCBhcyB3ZWxsIGFzIGZyb20gcGx1Z2lucy4gVGhpcyBhbGxvd3MgdGhlIGNvcmUgY2xhc3MgdG9cblx0ICogY29udHJvbCBkZWxheXMuXG5cdCAqIEBtZXRob2QgX3BsYXlJbnN0YW5jZVxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gaW5zdGFuY2UgVGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fSB0byBzdGFydCBwbGF5aW5nLlxuXHQgKiBAcGFyYW0ge1BsYXlQcm9wc0NvbmZpZ30gcGxheVByb3BzIEEgUGxheVByb3BzQ29uZmlnIG9iamVjdC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIHNvdW5kIGNhbiBzdGFydCBwbGF5aW5nLiBTb3VuZHMgdGhhdCBmYWlsIGltbWVkaWF0ZWx5IHdpbGwgcmV0dXJuIGZhbHNlLiBTb3VuZHMgdGhhdFxuXHQgKiBoYXZlIGEgZGVsYXkgd2lsbCByZXR1cm4gdHJ1ZSwgYnV0IG1heSBzdGlsbCBmYWlsIHRvIHBsYXkuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5fcGxheUluc3RhbmNlID0gZnVuY3Rpb24gKGluc3RhbmNlLCBwbGF5UHJvcHMpIHtcblx0XHR2YXIgZGVmYXVsdFBsYXlQcm9wcyA9IHMuX2RlZmF1bHRQbGF5UHJvcHNIYXNoW2luc3RhbmNlLnNyY10gfHwge307XG5cdFx0aWYgKHBsYXlQcm9wcy5pbnRlcnJ1cHQgPT0gbnVsbCkge3BsYXlQcm9wcy5pbnRlcnJ1cHQgPSBkZWZhdWx0UGxheVByb3BzLmludGVycnVwdCB8fCBzLmRlZmF1bHRJbnRlcnJ1cHRCZWhhdmlvcn07XG5cdFx0aWYgKHBsYXlQcm9wcy5kZWxheSA9PSBudWxsKSB7cGxheVByb3BzLmRlbGF5ID0gZGVmYXVsdFBsYXlQcm9wcy5kZWxheSB8fCAwO31cblx0XHRpZiAocGxheVByb3BzLm9mZnNldCA9PSBudWxsKSB7cGxheVByb3BzLm9mZnNldCA9IGluc3RhbmNlLmdldFBvc2l0aW9uKCk7fVxuXHRcdGlmIChwbGF5UHJvcHMubG9vcCA9PSBudWxsKSB7cGxheVByb3BzLmxvb3AgPSBpbnN0YW5jZS5sb29wO31cblx0XHRpZiAocGxheVByb3BzLnZvbHVtZSA9PSBudWxsKSB7cGxheVByb3BzLnZvbHVtZSA9IGluc3RhbmNlLnZvbHVtZTt9XG5cdFx0aWYgKHBsYXlQcm9wcy5wYW4gPT0gbnVsbCkge3BsYXlQcm9wcy5wYW4gPSBpbnN0YW5jZS5wYW47fVxuXG5cdFx0aWYgKHBsYXlQcm9wcy5kZWxheSA9PSAwKSB7XG5cdFx0XHR2YXIgb2sgPSBzLl9iZWdpblBsYXlpbmcoaW5zdGFuY2UsIHBsYXlQcm9wcyk7XG5cdFx0XHRpZiAoIW9rKSB7cmV0dXJuIGZhbHNlO31cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly9Ob3RlIHRoYXQgd2UgY2FuJ3QgcGFzcyBhcmd1bWVudHMgdG8gcHJveHkgT1Igc2V0VGltZW91dCAoSUUgb25seSksIHNvIGp1c3Qgd3JhcCB0aGUgZnVuY3Rpb24gY2FsbC5cblx0XHRcdC8vIE9KUiBXZWJBdWRpbyBtYXkgd2FudCB0byBoYW5kbGUgdGhpcyBkaWZmZXJlbnRseSwgc28gaXQgbWlnaHQgbWFrZSBzZW5zZSB0byBtb3ZlIHRoaXMgZnVuY3Rpb25hbGl0eSBpbnRvIHRoZSBwbHVnaW5zIGluIHRoZSBmdXR1cmVcblx0XHRcdHZhciBkZWxheVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzLl9iZWdpblBsYXlpbmcoaW5zdGFuY2UsIHBsYXlQcm9wcyk7XG5cdFx0XHR9LCBwbGF5UHJvcHMuZGVsYXkpO1xuXHRcdFx0aW5zdGFuY2UuZGVsYXlUaW1lb3V0SWQgPSBkZWxheVRpbWVvdXRJZDtcblx0XHR9XG5cblx0XHR0aGlzLl9pbnN0YW5jZXMucHVzaChpbnN0YW5jZSk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW4gcGxheWJhY2suIFRoaXMgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IG9yIGFmdGVyIGRlbGF5IGJ5IHt7I2Nyb3NzTGluayBcIlNvdW5kL3BsYXlJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBfYmVnaW5QbGF5aW5nXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBpbnN0YW5jZSBBIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fSB0byBiZWdpbiBwbGF5YmFjay5cblx0ICogQHBhcmFtIHtQbGF5UHJvcHNDb25maWd9IHBsYXlQcm9wcyBBIFBsYXlQcm9wc0NvbmZpZyBvYmplY3QuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBzb3VuZCBjYW4gc3RhcnQgcGxheWluZy4gSWYgdGhlcmUgYXJlIG5vIGF2YWlsYWJsZSBjaGFubmVscywgb3IgdGhlIGluc3RhbmNlIGZhaWxzIHRvXG5cdCAqIHN0YXJ0LCB0aGlzIHdpbGwgcmV0dXJuIGZhbHNlLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuX2JlZ2luUGxheWluZyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgcGxheVByb3BzKSB7XG5cdFx0aWYgKCFTb3VuZENoYW5uZWwuYWRkKGluc3RhbmNlLCBwbGF5UHJvcHMuaW50ZXJydXB0KSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHR2YXIgcmVzdWx0ID0gaW5zdGFuY2UuX2JlZ2luUGxheWluZyhwbGF5UHJvcHMpO1xuXHRcdGlmICghcmVzdWx0KSB7XG5cdFx0XHR2YXIgaW5kZXggPSBjcmVhdGVqcy5pbmRleE9mKHRoaXMuX2luc3RhbmNlcywgaW5zdGFuY2UpO1xuXHRcdFx0aWYgKGluZGV4ID4gLTEpIHt0aGlzLl9pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTt9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHNvdXJjZSBvZiBhIHNvdW5kIHZpYSB0aGUgSUQgcGFzc2VkIGluIHdpdGggYSByZWdpc3RlciBjYWxsLiBJZiBubyBJRCBpcyBmb3VuZCB0aGUgdmFsdWUgaXMgcmV0dXJuZWRcblx0ICogaW5zdGVhZC5cblx0ICogQG1ldGhvZCBfZ2V0U3JjQnlJZFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIElEIHRoZSBzb3VuZCB3YXMgcmVnaXN0ZXJlZCB3aXRoLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBzb3VyY2Ugb2YgdGhlIHNvdW5kIGlmIGl0IGhhcyBiZWVuIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIElEIG9yIHRoZSB2YWx1ZSB0aGF0IHdhcyBwYXNzZWQgaW4uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5fZ2V0U3JjQnlJZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHJldHVybiBzLl9pZEhhc2hbdmFsdWVdIHx8IHtzcmM6IHZhbHVlfTtcblx0fTtcblxuXHQvKipcblx0ICogQSBzb3VuZCBoYXMgY29tcGxldGVkIHBsYXliYWNrLCBiZWVuIGludGVycnVwdGVkLCBmYWlsZWQsIG9yIGJlZW4gc3RvcHBlZC4gVGhpcyBtZXRob2QgcmVtb3ZlcyB0aGUgaW5zdGFuY2UgZnJvbVxuXHQgKiBTb3VuZCBtYW5hZ2VtZW50LiBJdCB3aWxsIGJlIGFkZGVkIGFnYWluLCBpZiB0aGUgc291bmQgcmUtcGxheXMuIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgZnJvbSB0aGVcblx0ICogaW5zdGFuY2VzIHRoZW1zZWx2ZXMuXG5cdCAqIEBtZXRob2QgX3BsYXlGaW5pc2hlZFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gaW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgZmluaXNoZWQgcGxheWJhY2suXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5fcGxheUZpbmlzaGVkID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG5cdFx0U291bmRDaGFubmVsLnJlbW92ZShpbnN0YW5jZSk7XG5cdFx0dmFyIGluZGV4ID0gY3JlYXRlanMuaW5kZXhPZih0aGlzLl9pbnN0YW5jZXMsIGluc3RhbmNlKTtcblx0XHRpZiAoaW5kZXggPiAtMSkge3RoaXMuX2luc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO31cdC8vIE9KUiB0aGlzIHdpbGwgYWx3YXlzIGJlID4gLTEsIHRoZXJlIGlzIG5vIHdheSBmb3IgYW4gaW5zdGFuY2UgdG8gZXhpc3Qgd2l0aG91dCBiZWluZyBhZGRlZCB0byB0aGlzLl9pbnN0YW5jZXNcblx0fTtcblxuXHRjcmVhdGVqcy5Tb3VuZCA9IFNvdW5kO1xuXG5cdC8qKlxuXHQgKiBBbiBpbnRlcm5hbCBjbGFzcyB0aGF0IG1hbmFnZXMgdGhlIG51bWJlciBvZiBhY3RpdmUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlcyBmb3Jcblx0ICogZWFjaCBzb3VuZCB0eXBlLiBUaGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgaW50ZXJuYWxseSBieSB0aGUge3sjY3Jvc3NMaW5rIFwiU291bmRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MuXG5cdCAqXG5cdCAqIFRoZSBudW1iZXIgb2Ygc291bmRzIGlzIGFydGlmaWNpYWxseSBsaW1pdGVkIGJ5IFNvdW5kIGluIG9yZGVyIHRvIHByZXZlbnQgb3Zlci1zYXR1cmF0aW9uIG9mIGFcblx0ICogc2luZ2xlIHNvdW5kLCBhcyB3ZWxsIGFzIHRvIHN0YXkgd2l0aGluIGhhcmR3YXJlIGxpbWl0YXRpb25zLCBhbHRob3VnaCB0aGUgbGF0dGVyIG1heSBkaXNhcHBlYXIgd2l0aCBiZXR0ZXJcblx0ICogYnJvd3NlciBzdXBwb3J0LlxuXHQgKlxuXHQgKiBXaGVuIGEgc291bmQgaXMgcGxheWVkLCB0aGlzIGNsYXNzIGVuc3VyZXMgdGhhdCB0aGVyZSBpcyBhbiBhdmFpbGFibGUgaW5zdGFuY2UsIG9yIGludGVycnVwdHMgYW4gYXBwcm9wcmlhdGVcblx0ICogc291bmQgdGhhdCBpcyBhbHJlYWR5IHBsYXlpbmcuXG5cdCAqICNjbGFzcyBTb3VuZENoYW5uZWxcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291cmNlIG9mIHRoZSBpbnN0YW5jZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttYXg9MV0gVGhlIG51bWJlciBvZiBpbnN0YW5jZXMgYWxsb3dlZFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0ZnVuY3Rpb24gU291bmRDaGFubmVsKHNyYywgbWF4KSB7XG5cdFx0dGhpcy5pbml0KHNyYywgbWF4KTtcblx0fVxuXG5cdC8qIC0tLS0tLS0tLS0tLVxuXHQgU3RhdGljIEFQSVxuXHQgLS0tLS0tLS0tLS0tICovXG5cdC8qKlxuXHQgKiBBIGhhc2ggb2YgY2hhbm5lbCBpbnN0YW5jZXMgaW5kZXhlZCBieSBzb3VyY2UuXG5cdCAqICNwcm9wZXJ0eSBjaGFubmVsc1xuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRTb3VuZENoYW5uZWwuY2hhbm5lbHMgPSB7fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgc291bmQgY2hhbm5lbC4gTm90ZSB0aGF0IGlmIHRoZSBzb3VuZCBjaGFubmVsIGFscmVhZHkgZXhpc3RzLCB0aGlzIHdpbGwgZmFpbC5cblx0ICogI21ldGhvZCBjcmVhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291cmNlIGZvciB0aGUgY2hhbm5lbFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbWF4IFRoZSBtYXhpbXVtIGFtb3VudCB0aGlzIGNoYW5uZWwgaG9sZHMuIFRoZSBkZWZhdWx0IGlzIHt7I2Nyb3NzTGluayBcIlNvdW5kQ2hhbm5lbC5tYXhEZWZhdWx0XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgY2hhbm5lbHMgd2VyZSBjcmVhdGVkLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRTb3VuZENoYW5uZWwuY3JlYXRlID0gZnVuY3Rpb24gKHNyYywgbWF4KSB7XG5cdFx0dmFyIGNoYW5uZWwgPSBTb3VuZENoYW5uZWwuZ2V0KHNyYyk7XG5cdFx0aWYgKGNoYW5uZWwgPT0gbnVsbCkge1xuXHRcdFx0U291bmRDaGFubmVsLmNoYW5uZWxzW3NyY10gPSBuZXcgU291bmRDaGFubmVsKHNyYywgbWF4KTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cdC8qKlxuXHQgKiBEZWxldGUgYSBzb3VuZCBjaGFubmVsLCBzdG9wIGFuZCBkZWxldGUgYWxsIHJlbGF0ZWQgaW5zdGFuY2VzLiBOb3RlIHRoYXQgaWYgdGhlIHNvdW5kIGNoYW5uZWwgZG9lcyBub3QgZXhpc3QsIHRoaXMgd2lsbCBmYWlsLlxuXHQgKiAjbWV0aG9kIHJlbW92ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VyY2UgZm9yIHRoZSBjaGFubmVsXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBjaGFubmVscyB3ZXJlIGRlbGV0ZWQuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFNvdW5kQ2hhbm5lbC5yZW1vdmVTcmMgPSBmdW5jdGlvbiAoc3JjKSB7XG5cdFx0dmFyIGNoYW5uZWwgPSBTb3VuZENoYW5uZWwuZ2V0KHNyYyk7XG5cdFx0aWYgKGNoYW5uZWwgPT0gbnVsbCkge3JldHVybiBmYWxzZTt9XG5cdFx0Y2hhbm5lbC5fcmVtb3ZlQWxsKCk7XHQvLyB0aGlzIHN0b3BzIGFuZCByZW1vdmVzIGFsbCBhY3RpdmUgaW5zdGFuY2VzXG5cdFx0ZGVsZXRlKFNvdW5kQ2hhbm5lbC5jaGFubmVsc1tzcmNdKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0LyoqXG5cdCAqIERlbGV0ZSBhbGwgc291bmQgY2hhbm5lbHMsIHN0b3AgYW5kIGRlbGV0ZSBhbGwgcmVsYXRlZCBpbnN0YW5jZXMuXG5cdCAqICNtZXRob2QgcmVtb3ZlQWxsXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFNvdW5kQ2hhbm5lbC5yZW1vdmVBbGwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yKHZhciBjaGFubmVsIGluIFNvdW5kQ2hhbm5lbC5jaGFubmVscykge1xuXHRcdFx0U291bmRDaGFubmVsLmNoYW5uZWxzW2NoYW5uZWxdLl9yZW1vdmVBbGwoKTtcdC8vIHRoaXMgc3RvcHMgYW5kIHJlbW92ZXMgYWxsIGFjdGl2ZSBpbnN0YW5jZXNcblx0XHR9XG5cdFx0U291bmRDaGFubmVsLmNoYW5uZWxzID0ge307XG5cdH07XG5cdC8qKlxuXHQgKiBBZGQgYW4gaW5zdGFuY2UgdG8gYSBzb3VuZCBjaGFubmVsLlxuXHQgKiAjbWV0aG9kIGFkZFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gaW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIGFkZCB0byB0aGUgY2hhbm5lbFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW50ZXJydXB0IFRoZSBpbnRlcnJ1cHQgdmFsdWUgdG8gdXNlLiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9wbGF5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzIG9uIGludGVycnVwdCBtb2Rlcy5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVGhlIHN1Y2Nlc3Mgb2YgdGhlIG1ldGhvZCBjYWxsLiBJZiB0aGUgY2hhbm5lbCBpcyBmdWxsLCBpdCB3aWxsIHJldHVybiBmYWxzZS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0U291bmRDaGFubmVsLmFkZCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgaW50ZXJydXB0KSB7XG5cdFx0dmFyIGNoYW5uZWwgPSBTb3VuZENoYW5uZWwuZ2V0KGluc3RhbmNlLnNyYyk7XG5cdFx0aWYgKGNoYW5uZWwgPT0gbnVsbCkge3JldHVybiBmYWxzZTt9XG5cdFx0cmV0dXJuIGNoYW5uZWwuX2FkZChpbnN0YW5jZSwgaW50ZXJydXB0KTtcblx0fTtcblx0LyoqXG5cdCAqIFJlbW92ZSBhbiBpbnN0YW5jZSBmcm9tIHRoZSBjaGFubmVsLlxuXHQgKiAjbWV0aG9kIHJlbW92ZVxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gaW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHJlbW92ZSBmcm9tIHRoZSBjaGFubmVsXG5cdCAqIEByZXR1cm4gVGhlIHN1Y2Nlc3Mgb2YgdGhlIG1ldGhvZCBjYWxsLiBJZiB0aGVyZSBpcyBubyBjaGFubmVsLCBpdCB3aWxsIHJldHVybiBmYWxzZS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0U291bmRDaGFubmVsLnJlbW92ZSA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuXHRcdHZhciBjaGFubmVsID0gU291bmRDaGFubmVsLmdldChpbnN0YW5jZS5zcmMpO1xuXHRcdGlmIChjaGFubmVsID09IG51bGwpIHtyZXR1cm4gZmFsc2U7fVxuXHRcdGNoYW5uZWwuX3JlbW92ZShpbnN0YW5jZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdC8qKlxuXHQgKiBHZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHNvdW5kcyB5b3UgY2FuIGhhdmUgaW4gYSBjaGFubmVsLlxuXHQgKiAjbWV0aG9kIG1heFBlckNoYW5uZWxcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc291bmRzIHlvdSBjYW4gaGF2ZSBpbiBhIGNoYW5uZWwuXG5cdCAqL1xuXHRTb3VuZENoYW5uZWwubWF4UGVyQ2hhbm5lbCA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gcC5tYXhEZWZhdWx0O1xuXHR9O1xuXHQvKipcblx0ICogR2V0IGEgY2hhbm5lbCBpbnN0YW5jZSBieSBpdHMgc3JjLlxuXHQgKiAjbWV0aG9kIGdldFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzcmMgdG8gdXNlIHRvIGxvb2sgdXAgdGhlIGNoYW5uZWxcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0U291bmRDaGFubmVsLmdldCA9IGZ1bmN0aW9uIChzcmMpIHtcblx0XHRyZXR1cm4gU291bmRDaGFubmVsLmNoYW5uZWxzW3NyY107XG5cdH07XG5cblx0dmFyIHAgPSBTb3VuZENoYW5uZWwucHJvdG90eXBlO1xuXHRwLmNvbnN0cnVjdG9yID0gU291bmRDaGFubmVsO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG5cdC8qKlxuXHQgKiBUaGUgc291cmNlIG9mIHRoZSBjaGFubmVsLlxuXHQgKiAjcHJvcGVydHkgc3JjXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqL1xuXHRwLnNyYyA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBpbnN0YW5jZXMgaW4gdGhpcyBjaGFubmVsLiAgLTEgaW5kaWNhdGVzIG5vIGxpbWl0XG5cdCAqICNwcm9wZXJ0eSBtYXhcblx0ICogQHR5cGUge051bWJlcn1cblx0ICovXG5cdHAubWF4ID0gbnVsbDtcblxuXHQvKipcblx0ICogVGhlIGRlZmF1bHQgdmFsdWUgdG8gc2V0IGZvciBtYXgsIGlmIGl0IGlzbid0IHBhc3NlZCBpbi4gIEFsc28gdXNlZCBpZiAtMSBpcyBwYXNzZWQuXG5cdCAqICNwcm9wZXJ0eSBtYXhEZWZhdWx0XG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDEwMFxuXHQgKiBAc2luY2UgMC40LjBcblx0ICovXG5cdHAubWF4RGVmYXVsdCA9IDEwMDtcblxuXHQvKipcblx0ICogVGhlIGN1cnJlbnQgbnVtYmVyIG9mIGFjdGl2ZSBpbnN0YW5jZXMuXG5cdCAqICNwcm9wZXJ0eSBsZW5ndGhcblx0ICogQHR5cGUge051bWJlcn1cblx0ICovXG5cdHAubGVuZ3RoID0gMDtcblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSB0aGUgY2hhbm5lbC5cblx0ICogI21ldGhvZCBpbml0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBvZiB0aGUgY2hhbm5lbFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbWF4IFRoZSBtYXhpbXVtIG51bWJlciBvZiBpbnN0YW5jZXMgaW4gdGhlIGNoYW5uZWxcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5pbml0ID0gZnVuY3Rpb24gKHNyYywgbWF4KSB7XG5cdFx0dGhpcy5zcmMgPSBzcmM7XG5cdFx0dGhpcy5tYXggPSBtYXggfHwgdGhpcy5tYXhEZWZhdWx0O1xuXHRcdGlmICh0aGlzLm1heCA9PSAtMSkge3RoaXMubWF4ID0gdGhpcy5tYXhEZWZhdWx0O31cblx0XHR0aGlzLl9pbnN0YW5jZXMgPSBbXTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IGFuIGluc3RhbmNlIGJ5IGluZGV4LlxuXHQgKiAjbWV0aG9kIGdldFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIHJldHVybi5cblx0ICogQHJldHVybiB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBUaGUgQWJzdHJhY3RTb3VuZEluc3RhbmNlIGF0IGEgc3BlY2lmaWMgaW5zdGFuY2UuXG5cdCAqL1xuXHRwLl9nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5zdGFuY2VzW2luZGV4XTtcblx0fTtcblxuXHQvKipcblx0ICogQWRkIGEgbmV3IGluc3RhbmNlIHRvIHRoZSBjaGFubmVsLlxuXHQgKiAjbWV0aG9kIGFkZFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gaW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIGFkZC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVGhlIHN1Y2Nlc3Mgb2YgdGhlIG1ldGhvZCBjYWxsLiBJZiB0aGUgY2hhbm5lbCBpcyBmdWxsLCBpdCB3aWxsIHJldHVybiBmYWxzZS5cblx0ICovXG5cdHAuX2FkZCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgaW50ZXJydXB0KSB7XG5cdFx0aWYgKCF0aGlzLl9nZXRTbG90KGludGVycnVwdCwgaW5zdGFuY2UpKSB7cmV0dXJuIGZhbHNlO31cblx0XHR0aGlzLl9pbnN0YW5jZXMucHVzaChpbnN0YW5jZSk7XG5cdFx0dGhpcy5sZW5ndGgrKztcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlIGFuIGluc3RhbmNlIGZyb20gdGhlIGNoYW5uZWwsIGVpdGhlciB3aGVuIGl0IGhhcyBmaW5pc2hlZCBwbGF5aW5nLCBvciBpdCBoYXMgYmVlbiBpbnRlcnJ1cHRlZC5cblx0ICogI21ldGhvZCByZW1vdmVcblx0ICogQHBhcmFtIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IGluc3RhbmNlIFRoZSBpbnN0YW5jZSB0byByZW1vdmVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVGhlIHN1Y2Nlc3Mgb2YgdGhlIHJlbW92ZSBjYWxsLiBJZiB0aGUgaW5zdGFuY2UgaXMgbm90IGZvdW5kIGluIHRoaXMgY2hhbm5lbCwgaXQgd2lsbFxuXHQgKiByZXR1cm4gZmFsc2UuXG5cdCAqL1xuXHRwLl9yZW1vdmUgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcblx0XHR2YXIgaW5kZXggPSBjcmVhdGVqcy5pbmRleE9mKHRoaXMuX2luc3RhbmNlcywgaW5zdGFuY2UpO1xuXHRcdGlmIChpbmRleCA9PSAtMSkge3JldHVybiBmYWxzZTt9XG5cdFx0dGhpcy5faW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0dGhpcy5sZW5ndGgtLTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogU3RvcCBwbGF5YmFjayBhbmQgcmVtb3ZlIGFsbCBpbnN0YW5jZXMgZnJvbSB0aGUgY2hhbm5lbC4gIFVzdWFsbHkgaW4gcmVzcG9uc2UgdG8gYSBkZWxldGUgY2FsbC5cblx0ICogI21ldGhvZCByZW1vdmVBbGxcblx0ICovXG5cdHAuX3JlbW92ZUFsbCA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBOb3RlIHRoYXQgc3RvcCgpIHJlbW92ZXMgdGhlIGl0ZW0gZnJvbSB0aGUgbGlzdFxuXHRcdGZvciAodmFyIGk9dGhpcy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG5cdFx0XHR0aGlzLl9pbnN0YW5jZXNbaV0uc3RvcCgpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogR2V0IGFuIGF2YWlsYWJsZSBzbG90IGRlcGVuZGluZyBvbiBpbnRlcnJ1cHQgdmFsdWUgYW5kIGlmIHNsb3RzIGFyZSBhdmFpbGFibGUuXG5cdCAqICNtZXRob2QgZ2V0U2xvdFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW50ZXJydXB0IFRoZSBpbnRlcnJ1cHQgdmFsdWUgdG8gdXNlLlxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gaW5zdGFuY2UgVGhlIHNvdW5kIGluc3RhbmNlIHRoYXQgd2lsbCBnbyBpbiB0aGUgY2hhbm5lbCBpZiBzdWNjZXNzZnVsLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBEZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGF2YWlsYWJsZSBzbG90LiBEZXBlbmRpbmcgb24gdGhlIGludGVycnVwdCBtb2RlLCBpZiB0aGVyZSBhcmUgbm8gc2xvdHMsXG5cdCAqIGFuIGV4aXN0aW5nIEFic3RyYWN0U291bmRJbnN0YW5jZSBtYXkgYmUgaW50ZXJydXB0ZWQuIElmIHRoZXJlIGFyZSBubyBzbG90cywgdGhpcyBtZXRob2QgcmV0dXJucyBmYWxzZS5cblx0ICovXG5cdHAuX2dldFNsb3QgPSBmdW5jdGlvbiAoaW50ZXJydXB0LCBpbnN0YW5jZSkge1xuXHRcdHZhciB0YXJnZXQsIHJlcGxhY2VtZW50O1xuXG5cdFx0aWYgKGludGVycnVwdCAhPSBTb3VuZC5JTlRFUlJVUFRfTk9ORSkge1xuXHRcdFx0Ly8gRmlyc3QgcmVwbGFjZW1lbnQgY2FuZGlkYXRlXG5cdFx0XHRyZXBsYWNlbWVudCA9IHRoaXMuX2dldCgwKTtcblx0XHRcdGlmIChyZXBsYWNlbWVudCA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5tYXg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHRhcmdldCA9IHRoaXMuX2dldChpKTtcblxuXHRcdFx0Ly8gQXZhaWxhYmxlIFNwYWNlXG5cdFx0XHRpZiAodGFyZ2V0ID09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEF1ZGlvIGlzIGNvbXBsZXRlIG9yIG5vdCBwbGF5aW5nXG5cdFx0XHRpZiAodGFyZ2V0LnBsYXlTdGF0ZSA9PSBTb3VuZC5QTEFZX0ZJTklTSEVEIHx8XG5cdFx0XHRcdHRhcmdldC5wbGF5U3RhdGUgPT0gU291bmQuUExBWV9JTlRFUlJVUFRFRCB8fFxuXHRcdFx0XHR0YXJnZXQucGxheVN0YXRlID09IFNvdW5kLlBMQVlfRkFJTEVEKSB7XG5cdFx0XHRcdHJlcGxhY2VtZW50ID0gdGFyZ2V0O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0aWYgKGludGVycnVwdCA9PSBTb3VuZC5JTlRFUlJVUFRfTk9ORSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXVkaW8gaXMgYSBiZXR0ZXIgY2FuZGlkYXRlIHRoYW4gdGhlIGN1cnJlbnQgdGFyZ2V0LCBhY2NvcmRpbmcgdG8gcGxheWhlYWRcblx0XHRcdGlmICgoaW50ZXJydXB0ID09IFNvdW5kLklOVEVSUlVQVF9FQVJMWSAmJiB0YXJnZXQuZ2V0UG9zaXRpb24oKSA8IHJlcGxhY2VtZW50LmdldFBvc2l0aW9uKCkpIHx8XG5cdFx0XHRcdChpbnRlcnJ1cHQgPT0gU291bmQuSU5URVJSVVBUX0xBVEUgJiYgdGFyZ2V0LmdldFBvc2l0aW9uKCkgPiByZXBsYWNlbWVudC5nZXRQb3NpdGlvbigpKSkge1xuXHRcdFx0XHRcdHJlcGxhY2VtZW50ID0gdGFyZ2V0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChyZXBsYWNlbWVudCAhPSBudWxsKSB7XG5cdFx0XHRyZXBsYWNlbWVudC5faW50ZXJydXB0KCk7XG5cdFx0XHR0aGlzLl9yZW1vdmUocmVwbGFjZW1lbnQpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltTb3VuZCBTb3VuZENoYW5uZWxdXCI7XG5cdH07XG5cdC8vIGRvIG5vdCBhZGQgU291bmRDaGFubmVsIHRvIG5hbWVzcGFjZVxuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQWJzdHJhY3RTb3VuZEluc3RhbmNlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4vKipcbiAqIEEgQWJzdHJhY3RTb3VuZEluc3RhbmNlIGlzIGNyZWF0ZWQgd2hlbiBhbnkgY2FsbHMgdG8gdGhlIFNvdW5kIEFQSSBtZXRob2Qge3sjY3Jvc3NMaW5rIFwiU291bmQvcGxheVwifX17ey9jcm9zc0xpbmt9fSBvclxuICoge3sjY3Jvc3NMaW5rIFwiU291bmQvY3JlYXRlSW5zdGFuY2VcIn19e3svY3Jvc3NMaW5rfX0gYXJlIG1hZGUuIFRoZSBBYnN0cmFjdFNvdW5kSW5zdGFuY2UgaXMgcmV0dXJuZWQgYnkgdGhlIGFjdGl2ZSBwbHVnaW5cbiAqIGZvciBjb250cm9sIGJ5IHRoZSB1c2VyLlxuICpcbiAqIDxoND5FeGFtcGxlPC9oND5cbiAqXG4gKiAgICAgIHZhciBteUluc3RhbmNlID0gY3JlYXRlanMuU291bmQucGxheShcIm15QXNzZXRQYXRoL215U3JjRmlsZS5tcDNcIik7XG4gKlxuICogQSBudW1iZXIgb2YgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIHByb3ZpZGUgYSBxdWljayB3YXkgdG8gZGV0ZXJtaW5lIGhvdyBhIHNvdW5kIGlzIHBsYXllZC4gUGxlYXNlIHNlZSB0aGUgU291bmRcbiAqIEFQSSBtZXRob2Qge3sjY3Jvc3NMaW5rIFwiU291bmQvcGxheVwifX17ey9jcm9zc0xpbmt9fSBmb3IgYSBsaXN0IG9mIGFyZ3VtZW50cy5cbiAqXG4gKiBPbmNlIGEgQWJzdHJhY3RTb3VuZEluc3RhbmNlIGlzIGNyZWF0ZWQsIGEgcmVmZXJlbmNlIGNhbiBiZSBzdG9yZWQgdGhhdCBjYW4gYmUgdXNlZCB0byBjb250cm9sIHRoZSBhdWRpbyBkaXJlY3RseSB0aHJvdWdoXG4gKiB0aGUgQWJzdHJhY3RTb3VuZEluc3RhbmNlLiBJZiB0aGUgcmVmZXJlbmNlIGlzIG5vdCBzdG9yZWQsIHRoZSBBYnN0cmFjdFNvdW5kSW5zdGFuY2Ugd2lsbCBwbGF5IG91dCBpdHMgYXVkaW8gKGFuZCBhbnkgbG9vcHMpLCBhbmRcbiAqIGlzIHRoZW4gZGUtcmVmZXJlbmNlZCBmcm9tIHRoZSB7eyNjcm9zc0xpbmsgXCJTb3VuZFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBzbyB0aGF0IGl0IGNhbiBiZSBjbGVhbmVkIHVwLiBJZiBhdWRpb1xuICogcGxheWJhY2sgaGFzIGNvbXBsZXRlZCwgYSBzaW1wbGUgY2FsbCB0byB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3BsYXlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UgbWV0aG9kXG4gKiB3aWxsIHJlYnVpbGQgdGhlIHJlZmVyZW5jZXMgdGhlIFNvdW5kIGNsYXNzIG5lZWQgdG8gY29udHJvbCBpdC5cbiAqXG4gKiAgICAgIHZhciBteUluc3RhbmNlID0gY3JlYXRlanMuU291bmQucGxheShcIm15QXNzZXRQYXRoL215U3JjRmlsZS5tcDNcIiwge2xvb3A6Mn0pO1xuICogICAgICBteUluc3RhbmNlLm9uKFwibG9vcFwiLCBoYW5kbGVMb29wKTtcbiAqICAgICAgZnVuY3Rpb24gaGFuZGxlTG9vcChldmVudCkge1xuICogICAgICAgICAgbXlJbnN0YW5jZS52b2x1bWUgPSBteUluc3RhbmNlLnZvbHVtZSAqIDAuNTtcbiAqICAgICAgfVxuICpcbiAqIEV2ZW50cyBhcmUgZGlzcGF0Y2hlZCBmcm9tIHRoZSBpbnN0YW5jZSB0byBub3RpZnkgd2hlbiB0aGUgc291bmQgaGFzIGNvbXBsZXRlZCwgbG9vcGVkLCBvciB3aGVuIHBsYXliYWNrIGZhaWxzXG4gKlxuICogICAgICB2YXIgbXlJbnN0YW5jZSA9IGNyZWF0ZWpzLlNvdW5kLnBsYXkoXCJteUFzc2V0UGF0aC9teVNyY0ZpbGUubXAzXCIpO1xuICogICAgICBteUluc3RhbmNlLm9uKFwiY29tcGxldGVcIiwgaGFuZGxlQ29tcGxldGUpO1xuICogICAgICBteUluc3RhbmNlLm9uKFwibG9vcFwiLCBoYW5kbGVMb29wKTtcbiAqICAgICAgbXlJbnN0YW5jZS5vbihcImZhaWxlZFwiLCBoYW5kbGVGYWlsZWQpO1xuICpcbiAqXG4gKiBAY2xhc3MgQWJzdHJhY3RTb3VuZEluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBwYXRoIHRvIGFuZCBmaWxlIG5hbWUgb2YgdGhlIHNvdW5kLlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0VGltZSBBdWRpbyBzcHJpdGUgcHJvcGVydHkgdXNlZCB0byBhcHBseSBhbiBvZmZzZXQsIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBBdWRpbyBzcHJpdGUgcHJvcGVydHkgdXNlZCB0byBzZXQgdGhlIHRpbWUgdGhlIGNsaXAgcGxheXMgZm9yLCBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcGFyYW0ge09iamVjdH0gcGxheWJhY2tSZXNvdXJjZSBBbnkgcmVzb3VyY2UgbmVlZGVkIGJ5IHBsdWdpbiB0byBzdXBwb3J0IGF1ZGlvIHBsYXliYWNrLlxuICogQGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBDb25zdHJ1Y3Rvcjpcblx0dmFyIEFic3RyYWN0U291bmRJbnN0YW5jZSA9IGZ1bmN0aW9uIChzcmMsIHN0YXJ0VGltZSwgZHVyYXRpb24sIHBsYXliYWNrUmVzb3VyY2UpIHtcblx0XHR0aGlzLkV2ZW50RGlzcGF0Y2hlcl9jb25zdHJ1Y3RvcigpO1xuXG5cblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIHNvdXJjZSBvZiB0aGUgc291bmQuXG5cdFx0ICogQHByb3BlcnR5IHNyY1xuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuc3JjID0gc3JjO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgaW5zdGFuY2UuIFRoaXMgaXMgc2V0IGJ5IHt7I2Nyb3NzTGluayBcIlNvdW5kXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSB1bmlxdWVJZFxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9IHwgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgLTFcblx0XHQgKi9cblx0XHR0aGlzLnVuaXF1ZUlkID0gLTE7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcGxheSBzdGF0ZSBvZiB0aGUgc291bmQuIFBsYXkgc3RhdGVzIGFyZSBkZWZpbmVkIGFzIGNvbnN0YW50cyBvbiB7eyNjcm9zc0xpbmsgXCJTb3VuZFwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgcGxheVN0YXRlXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5wbGF5U3RhdGUgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBUaW1lb3V0IGNyZWF0ZWQgYnkge3sjY3Jvc3NMaW5rIFwiU291bmRcIn19e3svY3Jvc3NMaW5rfX0gd2hlbiB0aGlzIEFic3RyYWN0U291bmRJbnN0YW5jZSBpcyBwbGF5ZWQgd2l0aCBhIGRlbGF5LlxuXHRcdCAqIFRoaXMgYWxsb3dzIEFic3RyYWN0U291bmRJbnN0YW5jZSB0byByZW1vdmUgdGhlIGRlbGF5IGlmIHN0b3AsIHBhdXNlLCBvciBjbGVhbnVwIGFyZSBjYWxsZWQgYmVmb3JlIHBsYXliYWNrIGJlZ2lucy5cblx0XHQgKiBAcHJvcGVydHkgZGVsYXlUaW1lb3V0SWRcblx0XHQgKiBAdHlwZSB7dGltZW91dFZhcmlhYmxlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHNpbmNlIDAuNC4wXG5cdFx0ICovXG5cdFx0dGhpcy5kZWxheVRpbWVvdXRJZCA9IG51bGw7XG5cdFx0Ly8gVE9ETyBjb25zaWRlciBtb3ZpbmcgZGVsYXkgaW50byBBYnN0cmFjdFNvdW5kSW5zdGFuY2Ugc28gaXQgY2FuIGJlIGhhbmRsZWQgYnkgcGx1Z2luc1xuXG5cblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzXG5cdC8vIEdldHRlciAvIFNldHRlciBQcm9wZXJ0aWVzXG5cdFx0Ly8gT0pSIFRPRE8gZmluZCBvcmlnaW5hbCByZWFzb24gdGhhdCB3ZSBkaWRuJ3QgdXNlIGRlZmluZWQgZnVuY3Rpb25zLiAgSSB0aGluayBpdCB3YXMgcGVyZm9ybWFuY2UgcmVsYXRlZFxuXHRcdC8qKlxuXHRcdCAqIFRoZSB2b2x1bWUgb2YgdGhlIHNvdW5kLCBiZXR3ZWVuIDAgYW5kIDEuXG5cdFx0ICpcblx0XHQgKiBUaGUgYWN0dWFsIG91dHB1dCB2b2x1bWUgb2YgYSBzb3VuZCBjYW4gYmUgY2FsY3VsYXRlZCB1c2luZzpcblx0XHQgKiA8Y29kZT5teUluc3RhbmNlLnZvbHVtZSAqIGNyZWF0ZWpzLlNvdW5kLmdldFZvbHVtZSgpOzwvY29kZT5cblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSB2b2x1bWVcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLl92b2x1bWUgPSAgMTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2b2x1bWVcIiwge1xuXHRcdFx0Z2V0OiB0aGlzLmdldFZvbHVtZSxcblx0XHRcdHNldDogdGhpcy5zZXRWb2x1bWVcblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBwYW4gb2YgdGhlIHNvdW5kLCBiZXR3ZWVuIC0xIChsZWZ0KSBhbmQgMSAocmlnaHQpLiBOb3RlIHRoYXQgcGFuIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSFRNTCBBdWRpby5cblx0XHQgKlxuXHRcdCAqIDxiciAvPk5vdGUgaW4gV2ViQXVkaW9QbHVnaW4gdGhpcyBvbmx5IGdpdmVzIHVzIHRoZSBcInhcIiB2YWx1ZSBvZiB3aGF0IGlzIGFjdHVhbGx5IDNEIGF1ZGlvLlxuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHBhblxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuX3BhbiA9ICAwO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhblwiLCB7XG5cdFx0XHRnZXQ6IHRoaXMuZ2V0UGFuLFxuXHRcdFx0c2V0OiB0aGlzLnNldFBhblxuXHRcdH0pO1xuXG5cdFx0LyoqXG5cdFx0ICogQXVkaW8gc3ByaXRlIHByb3BlcnR5IHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBzdGFydGluZyBvZmZzZXQuXG5cdFx0ICogQHByb3BlcnR5IHN0YXJ0VGltZVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEBzaW5jZSAwLjYuMVxuXHRcdCAqL1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IE1hdGgubWF4KDAsIHN0YXJ0VGltZSB8fCAwKTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGFydFRpbWVcIiwge1xuXHRcdFx0Z2V0OiB0aGlzLmdldFN0YXJ0VGltZSxcblx0XHRcdHNldDogdGhpcy5zZXRTdGFydFRpbWVcblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIFNldHMgb3IgZ2V0cyB0aGUgbGVuZ3RoIG9mIHRoZSBhdWRpbyBjbGlwLCB2YWx1ZSBpcyBpbiBtaWxsaXNlY29uZHMuXG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgZHVyYXRpb25cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAc2luY2UgMC42LjBcblx0XHQgKi9cblx0XHR0aGlzLl9kdXJhdGlvbiA9IE1hdGgubWF4KDAsIGR1cmF0aW9uIHx8IDApO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImR1cmF0aW9uXCIsIHtcblx0XHRcdGdldDogdGhpcy5nZXREdXJhdGlvbixcblx0XHRcdHNldDogdGhpcy5zZXREdXJhdGlvblxuXHRcdH0pO1xuXG5cdFx0LyoqXG5cdFx0ICogT2JqZWN0IHRoYXQgaG9sZHMgcGx1Z2luIHNwZWNpZmljIHJlc291cmNlIG5lZWQgZm9yIGF1ZGlvIHBsYXliYWNrLlxuXHRcdCAqIFRoaXMgaXMgc2V0IGludGVybmFsbHkgYnkgdGhlIHBsdWdpbi4gIEZvciBleGFtcGxlLCBXZWJBdWRpb1BsdWdpbiB3aWxsIHNldCBhbiBhcnJheSBidWZmZXIsXG5cdFx0ICogSFRNTEF1ZGlvUGx1Z2luIHdpbGwgc2V0IGEgdGFnLCBGbGFzaEF1ZGlvUGx1Z2luIHdpbGwgc2V0IGEgZmxhc2ggcmVmZXJlbmNlLlxuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHBsYXliYWNrUmVzb3VyY2Vcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlID0gbnVsbDtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwbGF5YmFja1Jlc291cmNlXCIsIHtcblx0XHRcdGdldDogdGhpcy5nZXRQbGF5YmFja1Jlc291cmNlLFxuXHRcdFx0c2V0OiB0aGlzLnNldFBsYXliYWNrUmVzb3VyY2Vcblx0XHR9KTtcblx0XHRpZihwbGF5YmFja1Jlc291cmNlICE9PSBmYWxzZSAmJiBwbGF5YmFja1Jlc291cmNlICE9PSB0cnVlKSB7IHRoaXMuc2V0UGxheWJhY2tSZXNvdXJjZShwbGF5YmFja1Jlc291cmNlKTsgfVxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHBvc2l0aW9uIG9mIHRoZSBwbGF5aGVhZCBpbiBtaWxsaXNlY29uZHMuIFRoaXMgY2FuIGJlIHNldCB3aGlsZSBhIHNvdW5kIGlzIHBsYXlpbmcsIHBhdXNlZCwgb3Igc3RvcHBlZC5cblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBwb3NpdGlvblxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEBzaW5jZSAwLjYuMFxuXHRcdCAqL1xuXHRcdHRoaXMuX3Bvc2l0aW9uID0gMDtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwb3NpdGlvblwiLCB7XG5cdFx0XHRnZXQ6IHRoaXMuZ2V0UG9zaXRpb24sXG5cdFx0XHRzZXQ6IHRoaXMuc2V0UG9zaXRpb25cblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBudW1iZXIgb2YgcGxheSBsb29wcyByZW1haW5pbmcuIE5lZ2F0aXZlIHZhbHVlcyB3aWxsIGxvb3AgaW5maW5pdGVseS5cblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBsb29wXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqIEBzaW5jZSAwLjYuMFxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvb3AgPSAwO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxvb3BcIiwge1xuXHRcdFx0Z2V0OiB0aGlzLmdldExvb3AsXG5cdFx0XHRzZXQ6IHRoaXMuc2V0TG9vcFxuXHRcdH0pO1xuXG5cdFx0LyoqXG5cdFx0ICogTXV0ZXMgb3IgdW5tdXRlcyB0aGUgY3VycmVudCBhdWRpbyBpbnN0YW5jZS5cblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBtdXRlZFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHNpbmNlIDAuNi4wXG5cdFx0ICovXG5cdFx0dGhpcy5fbXV0ZWQgPSBmYWxzZTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtdXRlZFwiLCB7XG5cdFx0XHRnZXQ6IHRoaXMuZ2V0TXV0ZWQsXG5cdFx0XHRzZXQ6IHRoaXMuc2V0TXV0ZWRcblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIFBhdXNlcyBvciByZXN1bWVzIHRoZSBjdXJyZW50IGF1ZGlvIGluc3RhbmNlLlxuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHBhdXNlZFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhdXNlZFwiLCB7XG5cdFx0XHRnZXQ6IHRoaXMuZ2V0UGF1c2VkLFxuXHRcdFx0c2V0OiB0aGlzLnNldFBhdXNlZFxuXHRcdH0pO1xuXG5cblx0Ly8gRXZlbnRzXG5cdFx0LyoqXG5cdFx0ICogVGhlIGV2ZW50IHRoYXQgaXMgZmlyZWQgd2hlbiBwbGF5YmFjayBoYXMgc3RhcnRlZCBzdWNjZXNzZnVsbHkuXG5cdFx0ICogQGV2ZW50IHN1Y2NlZWRlZFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHRcdCAqIEBzaW5jZSAwLjQuMFxuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGV2ZW50IHRoYXQgaXMgZmlyZWQgd2hlbiBwbGF5YmFjayBpcyBpbnRlcnJ1cHRlZC4gVGhpcyBoYXBwZW5zIHdoZW4gYW5vdGhlciBzb3VuZCB3aXRoIHRoZSBzYW1lXG5cdFx0ICogc3JjIHByb3BlcnR5IGlzIHBsYXllZCB1c2luZyBhbiBpbnRlcnJ1cHQgdmFsdWUgdGhhdCBjYXVzZXMgdGhpcyBpbnN0YW5jZSB0byBzdG9wIHBsYXlpbmcuXG5cdFx0ICogQGV2ZW50IGludGVycnVwdGVkXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdFx0ICogQHNpbmNlIDAuNC4wXG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiBUaGUgZXZlbnQgdGhhdCBpcyBmaXJlZCB3aGVuIHBsYXliYWNrIGhhcyBmYWlsZWQuIFRoaXMgaGFwcGVucyB3aGVuIHRoZXJlIGFyZSB0b28gbWFueSBjaGFubmVscyB3aXRoIHRoZSBzYW1lXG5cdFx0ICogc3JjIHByb3BlcnR5IGFscmVhZHkgcGxheWluZyAoYW5kIHRoZSBpbnRlcnJ1cHQgdmFsdWUgZG9lc24ndCBjYXVzZSBhbiBpbnRlcnJ1cHQgb2YgYW5vdGhlciBpbnN0YW5jZSksIG9yXG5cdFx0ICogdGhlIHNvdW5kIGNvdWxkIG5vdCBiZSBwbGF5ZWQsIHBlcmhhcHMgZHVlIHRvIGEgNDA0IGVycm9yLlxuXHRcdCAqIEBldmVudCBmYWlsZWRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0XHQgKiBAc2luY2UgMC40LjBcblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBldmVudCB0aGF0IGlzIGZpcmVkIHdoZW4gYSBzb3VuZCBoYXMgY29tcGxldGVkIHBsYXlpbmcgYnV0IGhhcyBsb29wcyByZW1haW5pbmcuXG5cdFx0ICogQGV2ZW50IGxvb3Bcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0XHQgKiBAc2luY2UgMC40LjBcblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBldmVudCB0aGF0IGlzIGZpcmVkIHdoZW4gcGxheWJhY2sgY29tcGxldGVzLiBUaGlzIG1lYW5zIHRoYXQgdGhlIHNvdW5kIGhhcyBmaW5pc2hlZCBwbGF5aW5nIGluIGl0c1xuXHRcdCAqIGVudGlyZXR5LCBpbmNsdWRpbmcgaXRzIGxvb3AgaXRlcmF0aW9ucy5cblx0XHQgKiBAZXZlbnQgY29tcGxldGVcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0XHQgKiBAc2luY2UgMC40LjBcblx0XHQgKi9cblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChBYnN0cmFjdFNvdW5kSW5zdGFuY2UsIGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuLy8gUHVibGljIE1ldGhvZHM6XG5cdC8qKlxuXHQgKiBQbGF5IGFuIGluc3RhbmNlLiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCB0byBiZSBjYWxsZWQgb24gU291bmRJbnN0YW5jZXMgdGhhdCBhbHJlYWR5IGV4aXN0IChjcmVhdGVkXG5cdCAqIHdpdGggdGhlIFNvdW5kIEFQSSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9jcmVhdGVJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fSBvciB7eyNjcm9zc0xpbmsgXCJTb3VuZC9wbGF5XCJ9fXt7L2Nyb3NzTGlua319KS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBteUluc3RhbmNlID0gY3JlYXRlanMuU291bmQuY3JlYXRlSW5zdGFuY2UobXlTcmMpO1xuXHQgKiAgICAgIG15SW5zdGFuY2UucGxheSh7aW50ZXJydXB0OmNyZWF0ZWpzLlNvdW5kLklOVEVSUlVQVF9BTlksIGxvb3A6MiwgcGFuOjAuNX0pO1xuXHQgKlxuXHQgKiBOb3RlIHRoYXQgaWYgdGhpcyBzb3VuZCBpcyBhbHJlYWR5IHBsYXlpbmcsIHRoaXMgY2FsbCB3aWxsIHN0aWxsIHNldCB0aGUgcGFzc2VkIGluIHBhcmFtZXRlcnMuXG5cblx0ICogPGI+UGFyYW1ldGVycyBEZXByZWNhdGVkPC9iPjxiciAvPlxuXHQgKiBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBtZXRob2QgYXJlIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgYSBzaW5nbGUgcGFyYW1ldGVyIHRoYXQgaXMgYW4gT2JqZWN0IG9yIHt7I2Nyb3NzTGluayBcIlBsYXlQcm9wc0NvbmZpZ1wifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogQG1ldGhvZCBwbGF5XG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgT2JqZWN0fSBbaW50ZXJydXB0PVwibm9uZVwifG9wdGlvbnNdIDxiPlRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgcmVuYW1lZCBwbGF5UHJvcHMgaW4gdGhlIG5leHQgcmVsZWFzZS48L2I+PGJyIC8+XG5cdCAqIFRoaXMgcGFyYW1ldGVyIGNhbiBiZSBhbiBpbnN0YW5jZSBvZiB7eyNjcm9zc0xpbmsgXCJQbGF5UHJvcHNDb25maWdcIn19e3svY3Jvc3NMaW5rfX0gb3IgYW4gT2JqZWN0IHRoYXQgY29udGFpbnMgYW55IG9yIGFsbCBvcHRpb25hbCBwcm9wZXJ0aWVzIGJ5IG5hbWUsXG5cdCAqIGluY2x1ZGluZzogaW50ZXJydXB0LCBkZWxheSwgb2Zmc2V0LCBsb29wLCB2b2x1bWUsIHBhbiwgc3RhcnRUaW1lLCBhbmQgZHVyYXRpb24gKHNlZSB0aGUgYWJvdmUgY29kZSBzYW1wbGUpLlxuXHQgKiA8YnIgLz48c3Ryb25nPk9SPC9zdHJvbmc+PGJyIC8+XG5cdCAqIDxiPkRlcHJlY2F0ZWQ8L2I+IEhvdyB0byBpbnRlcnJ1cHQgYW55IGN1cnJlbnRseSBwbGF5aW5nIGluc3RhbmNlcyBvZiBhdWRpbyB3aXRoIHRoZSBzYW1lIHNvdXJjZSxcblx0ICogaWYgdGhlIG1heGltdW0gbnVtYmVyIG9mIGluc3RhbmNlcyBvZiB0aGUgc291bmQgYXJlIGFscmVhZHkgcGxheWluZy4gVmFsdWVzIGFyZSBkZWZpbmVkIGFzIDxjb2RlPklOVEVSUlVQVF9UWVBFPC9jb2RlPlxuXHQgKiBjb25zdGFudHMgb24gdGhlIFNvdW5kIGNsYXNzLCB3aXRoIHRoZSBkZWZhdWx0IGRlZmluZWQgYnkge3sjY3Jvc3NMaW5rIFwiU291bmQvZGVmYXVsdEludGVycnVwdEJlaGF2aW9yOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2RlbGF5PTBdIDxiPkRlcHJlY2F0ZWQ8L2I+IFRoZSBhbW91bnQgb2YgdGltZSB0byBkZWxheSB0aGUgc3RhcnQgb2YgYXVkaW8gcGxheWJhY2ssIGluIG1pbGxpc2Vjb25kcy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXQ9MF0gPGI+RGVwcmVjYXRlZDwvYj4gVGhlIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgYXVkaW8gdG8gYmVnaW4gcGxheWJhY2ssIGluIG1pbGxpc2Vjb25kcy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtsb29wPTBdIDxiPkRlcHJlY2F0ZWQ8L2I+IEhvdyBtYW55IHRpbWVzIHRoZSBhdWRpbyBsb29wcyB3aGVuIGl0IHJlYWNoZXMgdGhlIGVuZCBvZiBwbGF5YmFjay4gVGhlIGRlZmF1bHQgaXMgMCAobm9cblx0ICogbG9vcHMpLCBhbmQgLTEgY2FuIGJlIHVzZWQgZm9yIGluZmluaXRlIHBsYXliYWNrLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3ZvbHVtZT0xXSA8Yj5EZXByZWNhdGVkPC9iPiBUaGUgdm9sdW1lIG9mIHRoZSBzb3VuZCwgYmV0d2VlbiAwIGFuZCAxLiBOb3RlIHRoYXQgdGhlIG1hc3RlciB2b2x1bWUgaXMgYXBwbGllZFxuXHQgKiBhZ2FpbnN0IHRoZSBpbmRpdmlkdWFsIHZvbHVtZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtwYW49MF0gPGI+RGVwcmVjYXRlZDwvYj4gVGhlIGxlZnQtcmlnaHQgcGFuIG9mIHRoZSBzb3VuZCAoaWYgc3VwcG9ydGVkKSwgYmV0d2VlbiAtMSAobGVmdCkgYW5kIDEgKHJpZ2h0KS5cblx0ICogTm90ZSB0aGF0IHBhbiBpcyBub3Qgc3VwcG9ydGVkIGZvciBIVE1MIEF1ZGlvLlxuXHQgKiBAcmV0dXJuIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IEEgcmVmZXJlbmNlIHRvIGl0c2VsZiwgaW50ZW5kZWQgZm9yIGNoYWluaW5nIGNhbGxzLlxuXHQgKi9cblx0cC5wbGF5ID0gZnVuY3Rpb24gKGludGVycnVwdCwgZGVsYXksIG9mZnNldCwgbG9vcCwgdm9sdW1lLCBwYW4pIHtcblx0XHR2YXIgcGxheVByb3BzO1xuXHRcdGlmIChpbnRlcnJ1cHQgaW5zdGFuY2VvZiBPYmplY3QgfHwgaW50ZXJydXB0IGluc3RhbmNlb2YgY3JlYXRlanMuUGxheVByb3BzQ29uZmlnKSB7XG5cdFx0XHRwbGF5UHJvcHMgPSBjcmVhdGVqcy5QbGF5UHJvcHNDb25maWcuY3JlYXRlKGludGVycnVwdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBsYXlQcm9wcyA9IGNyZWF0ZWpzLlBsYXlQcm9wc0NvbmZpZy5jcmVhdGUoe2ludGVycnVwdDppbnRlcnJ1cHQsIGRlbGF5OmRlbGF5LCBvZmZzZXQ6b2Zmc2V0LCBsb29wOmxvb3AsIHZvbHVtZTp2b2x1bWUsIHBhbjpwYW59KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5wbGF5U3RhdGUgPT0gY3JlYXRlanMuU291bmQuUExBWV9TVUNDRUVERUQpIHtcblx0XHRcdHRoaXMuYXBwbHlQbGF5UHJvcHMocGxheVByb3BzKTtcblx0XHRcdGlmICh0aGlzLl9wYXVzZWQpIHtcdHRoaXMuc2V0UGF1c2VkKGZhbHNlKTsgfVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9jbGVhblVwKCk7XG5cdFx0Y3JlYXRlanMuU291bmQuX3BsYXlJbnN0YW5jZSh0aGlzLCBwbGF5UHJvcHMpO1x0Ly8gbWFrZSB0aGlzIGFuIGV2ZW50IGRpc3BhdGNoPz9cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogU3RvcCBwbGF5YmFjayBvZiB0aGUgaW5zdGFuY2UuIFN0b3BwZWQgc291bmRzIHdpbGwgcmVzZXQgdGhlaXIgcG9zaXRpb24gdG8gMCwgYW5kIGNhbGxzIHRvIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9yZXN1bWVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2lsbCBmYWlsLiBUbyBzdGFydCBwbGF5YmFjayBhZ2FpbiwgY2FsbCB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvcGxheVwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgKlxuICAgICAqIElmIHlvdSBkb24ndCB3YW50IHRvIGxvc2UgeW91ciBwb3NpdGlvbiB1c2UgeW91clNvdW5kSW5zdGFuY2UucGF1c2VkID0gdHJ1ZSBpbnN0ZWFkLiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvcGF1c2VkXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICBteUluc3RhbmNlLnN0b3AoKTtcblx0ICpcblx0ICogQG1ldGhvZCBzdG9wXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gQSByZWZlcmVuY2UgdG8gaXRzZWxmLCBpbnRlbmRlZCBmb3IgY2hhaW5pbmcgY2FsbHMuXG5cdCAqL1xuXHRwLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcG9zaXRpb24gPSAwO1xuXHRcdHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2hhbmRsZVN0b3AoKTtcblx0XHR0aGlzLl9jbGVhblVwKCk7XG5cdFx0dGhpcy5wbGF5U3RhdGUgPSBjcmVhdGVqcy5Tb3VuZC5QTEFZX0ZJTklTSEVEO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIGV4dGVybmFsIHJlZmVyZW5jZXMgYW5kIHJlc291cmNlcyBmcm9tIEFic3RyYWN0U291bmRJbnN0YW5jZS4gIE5vdGUgdGhpcyBpcyBpcnJldmVyc2libGUgYW5kIEFic3RyYWN0U291bmRJbnN0YW5jZSB3aWxsIG5vIGxvbmdlciB3b3JrXG5cdCAqIEBtZXRob2QgZGVzdHJveVxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2NsZWFuVXAoKTtcblx0XHR0aGlzLnNyYyA9IG51bGw7XG5cdFx0dGhpcy5wbGF5YmFja1Jlc291cmNlID0gbnVsbDtcblxuXHRcdHRoaXMucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoKTtcblx0fTtcblxuXHQvKipcblx0ICogVGFrZXMgYW4gUGxheVByb3BzQ29uZmlnIG9yIE9iamVjdCB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgYW5kIHNldHMgdGhlbSBvbiB0aGlzIGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGFwcGx5UGxheVByb3BzXG5cdCAqIEBwYXJhbSB7UGxheVByb3BzQ29uZmlnIHwgT2JqZWN0fSBwbGF5UHJvcHMgQSBQbGF5UHJvcHNDb25maWcgb3Igb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgcHJvcGVydGllcy5cblx0ICogQHNpbmNlIDAuNi4xXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gQSByZWZlcmVuY2UgdG8gaXRzZWxmLCBpbnRlbmRlZCBmb3IgY2hhaW5pbmcgY2FsbHMuXG5cdCAqL1xuXHRwLmFwcGx5UGxheVByb3BzID0gZnVuY3Rpb24ocGxheVByb3BzKSB7XG5cdFx0aWYgKHBsYXlQcm9wcy5vZmZzZXQgIT0gbnVsbCkgeyB0aGlzLnNldFBvc2l0aW9uKHBsYXlQcm9wcy5vZmZzZXQpIH1cblx0XHRpZiAocGxheVByb3BzLmxvb3AgIT0gbnVsbCkgeyB0aGlzLnNldExvb3AocGxheVByb3BzLmxvb3ApOyB9XG5cdFx0aWYgKHBsYXlQcm9wcy52b2x1bWUgIT0gbnVsbCkgeyB0aGlzLnNldFZvbHVtZShwbGF5UHJvcHMudm9sdW1lKTsgfVxuXHRcdGlmIChwbGF5UHJvcHMucGFuICE9IG51bGwpIHsgdGhpcy5zZXRQYW4ocGxheVByb3BzLnBhbik7IH1cblx0XHRpZiAocGxheVByb3BzLnN0YXJ0VGltZSAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLnNldFN0YXJ0VGltZShwbGF5UHJvcHMuc3RhcnRUaW1lKTtcblx0XHRcdHRoaXMuc2V0RHVyYXRpb24ocGxheVByb3BzLmR1cmF0aW9uKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbQWJzdHJhY3RTb3VuZEluc3RhbmNlXVwiO1xuXHR9O1xuXG4vLyBnZXQvc2V0IG1ldGhvZHMgdGhhdCBhbGxvdyBzdXBwb3J0IGZvciBJRThcblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3BhdXNlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBkaXJlY3RseSBhcyBhIHByb3BlcnR5LFxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIGdldFBhdXNlZFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgdGhlIGluc3RhbmNlIGlzIGN1cnJlbnRseSBwYXVzZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmdldFBhdXNlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXVzZWQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3BhdXNlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBkaXJlY3RseSBhcyBhIHByb3BlcnR5XG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqIEBtZXRob2Qgc2V0UGF1c2VkXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gQSByZWZlcmVuY2UgdG8gaXRzZWxmLCBpbnRlbmRlZCBmb3IgY2hhaW5pbmcgY2FsbHMuXG5cdCAqL1xuXHRwLnNldFBhdXNlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmICgodmFsdWUgIT09IHRydWUgJiYgdmFsdWUgIT09IGZhbHNlKSB8fCB0aGlzLl9wYXVzZWQgPT0gdmFsdWUpIHtyZXR1cm47fVxuXHRcdGlmICh2YWx1ZSA9PSB0cnVlICYmIHRoaXMucGxheVN0YXRlICE9IGNyZWF0ZWpzLlNvdW5kLlBMQVlfU1VDQ0VFREVEKSB7cmV0dXJuO31cblx0XHR0aGlzLl9wYXVzZWQgPSB2YWx1ZTtcblx0XHRpZih2YWx1ZSkge1xuXHRcdFx0dGhpcy5fcGF1c2UoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmVzdW1lKCk7XG5cdFx0fVxuXHRcdGNsZWFyVGltZW91dCh0aGlzLmRlbGF5VGltZW91dElkKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2Uvdm9sdW1lOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBzZXRWb2x1bWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSB2b2x1bWUgdG8gc2V0LCBiZXR3ZWVuIDAgYW5kIDEuXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gQSByZWZlcmVuY2UgdG8gaXRzZWxmLCBpbnRlbmRlZCBmb3IgY2hhaW5pbmcgY2FsbHMuXG5cdCAqL1xuXHRwLnNldFZvbHVtZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PSB0aGlzLl92b2x1bWUpIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR0aGlzLl92b2x1bWUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB2YWx1ZSkpO1xuXHRcdGlmICghdGhpcy5fbXV0ZWQpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZVZvbHVtZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2Uvdm9sdW1lOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBnZXRWb2x1bWVcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgY3VycmVudCB2b2x1bWUgb2YgdGhlIHNvdW5kIGluc3RhbmNlLlxuXHQgKi9cblx0cC5nZXRWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZvbHVtZTtcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvbXV0ZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIHNldE11dGVkXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgSWYgdGhlIHNvdW5kIHNob3VsZCBiZSBtdXRlZC5cblx0ICogQHJldHVybiB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBBIHJlZmVyZW5jZSB0byBpdHNlbGYsIGludGVuZGVkIGZvciBjaGFpbmluZyBjYWxscy5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLnNldE11dGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlICE9PSB0cnVlICYmIHZhbHVlICE9PSBmYWxzZSkge3JldHVybjt9XG5cdFx0dGhpcy5fbXV0ZWQgPSB2YWx1ZTtcblx0XHR0aGlzLl91cGRhdGVWb2x1bWUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvbXV0ZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIGdldE11dGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBzb3VuZCBpcyBtdXRlZC5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmdldE11dGVkID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tdXRlZDtcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvcGFuOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBzZXRQYW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSBwYW4gdmFsdWUsIGJldHdlZW4gLTEgKGxlZnQpIGFuZCAxIChyaWdodCkuXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gUmV0dXJucyByZWZlcmVuY2UgdG8gaXRzZWxmIGZvciBjaGFpbmluZyBjYWxsc1xuXHQgKi9cblx0cC5zZXRQYW4gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRpZih2YWx1ZSA9PSB0aGlzLl9wYW4pIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR0aGlzLl9wYW4gPSBNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgdmFsdWUpKTtcblx0XHR0aGlzLl91cGRhdGVQYW4oKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvcGFuOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBnZXRQYW5cblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgdmFsdWUgb2YgdGhlIHBhbiwgYmV0d2VlbiAtMSAobGVmdCkgYW5kIDEgKHJpZ2h0KS5cblx0ICovXG5cdHAuZ2V0UGFuID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYW47XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3Bvc2l0aW9uOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBnZXRQb3NpdGlvblxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBwb3NpdGlvbiBvZiB0aGUgcGxheWhlYWQgaW4gdGhlIHNvdW5kLCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqL1xuXHRwLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fcGF1c2VkICYmIHRoaXMucGxheVN0YXRlID09IGNyZWF0ZWpzLlNvdW5kLlBMQVlfU1VDQ0VFREVEKSB7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX2NhbGN1bGF0ZUN1cnJlbnRQb3NpdGlvbigpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fcG9zaXRpb247XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3Bvc2l0aW9uOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBzZXRQb3NpdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIHBvc2l0aW9uIHRvIHBsYWNlIHRoZSBwbGF5aGVhZCwgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKiBAcmV0dXJuIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IFJldHVybnMgcmVmZXJlbmNlIHRvIGl0c2VsZiBmb3IgY2hhaW5pbmcgY2FsbHNcblx0ICovXG5cdHAuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR0aGlzLl9wb3NpdGlvbiA9IE1hdGgubWF4KDAsIHZhbHVlKTtcblx0XHRpZiAodGhpcy5wbGF5U3RhdGUgPT0gY3JlYXRlanMuU291bmQuUExBWV9TVUNDRUVERUQpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9zdGFydFRpbWU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIGdldFN0YXJ0VGltZVxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzdGFydFRpbWUgb2YgdGhlIHNvdW5kIGluc3RhbmNlIGluIG1pbGxpc2Vjb25kcy5cblx0ICovXG5cdHAuZ2V0U3RhcnRUaW1lID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9zdGFydFRpbWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3N0YXJ0VGltZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBkaXJlY3RseSBhcyBhIHByb3BlcnR5XG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqIEBtZXRob2Qgc2V0U3RhcnRUaW1lXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbmV3IHN0YXJ0VGltZSB0aW1lIGluIG1pbGxpIHNlY29uZHMuXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gUmV0dXJucyByZWZlcmVuY2UgdG8gaXRzZWxmIGZvciBjaGFpbmluZyBjYWxsc1xuXHQgKi9cblx0cC5zZXRTdGFydFRpbWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT0gdGhpcy5fc3RhcnRUaW1lKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gTWF0aC5tYXgoMCwgdmFsdWUgfHwgMCk7XG5cdFx0dGhpcy5fdXBkYXRlU3RhcnRUaW1lKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL2R1cmF0aW9uOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBnZXREdXJhdGlvblxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBkdXJhdGlvbiBvZiB0aGUgc291bmQgaW5zdGFuY2UgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKi9cblx0cC5nZXREdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHVyYXRpb247XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL2R1cmF0aW9uOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBzZXREdXJhdGlvblxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG5ldyBkdXJhdGlvbiB0aW1lIGluIG1pbGxpIHNlY29uZHMuXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gUmV0dXJucyByZWZlcmVuY2UgdG8gaXRzZWxmIGZvciBjaGFpbmluZyBjYWxsc1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuc2V0RHVyYXRpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT0gdGhpcy5fZHVyYXRpb24pIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR0aGlzLl9kdXJhdGlvbiA9IE1hdGgubWF4KDAsIHZhbHVlIHx8IDApO1xuXHRcdHRoaXMuX3VwZGF0ZUR1cmF0aW9uKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3BsYXliYWNrUmVzb3VyY2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIHNldFBsYXliYWNrXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgbmV3IHBsYXliYWNrIHJlc291cmNlLlxuXHQgKiBAcmV0dXJuIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IFJldHVybnMgcmVmZXJlbmNlIHRvIGl0c2VsZiBmb3IgY2hhaW5pbmcgY2FsbHNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqKi9cblx0cC5zZXRQbGF5YmFja1Jlc291cmNlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZSA9IHZhbHVlO1xuXHRcdGlmICh0aGlzLl9kdXJhdGlvbiA9PSAwKSB7IHRoaXMuX3NldER1cmF0aW9uRnJvbVNvdXJjZSgpOyB9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3BsYXliYWNrUmVzb3VyY2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIHNldFBsYXliYWNrXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgbmV3IHBsYXliYWNrIHJlc291cmNlLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IHBsYXliYWNrIHJlc291cmNlIHVzZWQgZm9yIHBsYXlpbmcgYXVkaW9cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqKi9cblx0cC5nZXRQbGF5YmFja1Jlc291cmNlID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9wbGF5YmFja1Jlc291cmNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9sb29wOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBnZXRMb29wXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqKi9cblx0cC5nZXRMb29wID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sb29wO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9sb29wOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHksXG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqIEBtZXRob2Qgc2V0TG9vcFxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG51bWJlciBvZiB0aW1lcyB0byBsb29wIGFmdGVyIHBsYXkuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5zZXRMb29wID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYodGhpcy5fcGxheWJhY2tSZXNvdXJjZSAhPSBudWxsKSB7XG5cdFx0XHQvLyByZW1vdmUgbG9vcGluZ1xuXHRcdFx0aWYgKHRoaXMuX2xvb3AgIT0gMCAmJiB2YWx1ZSA9PSAwKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUxvb3BpbmcodmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWRkIGxvb3Bpbmdcblx0XHRcdGVsc2UgaWYgKHRoaXMuX2xvb3AgPT0gMCAmJiB2YWx1ZSAhPSAwKSB7XG5cdFx0XHRcdHRoaXMuX2FkZExvb3BpbmcodmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9sb29wID0gdmFsdWU7XG5cdH07XG5cblxuLy8gUHJpdmF0ZSBNZXRob2RzOlxuXHQvKipcblx0ICogQSBoZWxwZXIgbWV0aG9kIHRoYXQgZGlzcGF0Y2hlcyBhbGwgZXZlbnRzIGZvciBBYnN0cmFjdFNvdW5kSW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgX3NlbmRFdmVudFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZW5kRXZlbnQgPSBmdW5jdGlvbiAodHlwZSkge1xuXHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudCh0eXBlKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiB1cCB0aGUgaW5zdGFuY2UuIFJlbW92ZSByZWZlcmVuY2VzIGFuZCBjbGVhbiB1cCBhbnkgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHN1Y2ggYXMgdGltZXJzLlxuXHQgKiBAbWV0aG9kIF9jbGVhblVwXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2NsZWFuVXAgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuZGVsYXlUaW1lb3V0SWQpOyAvLyBjbGVhciB0aW1lb3V0IHRoYXQgcGxheXMgZGVsYXllZCBzb3VuZFxuXHRcdHRoaXMuX2hhbmRsZUNsZWFuVXAoKTtcblx0XHR0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblxuXHRcdGNyZWF0ZWpzLlNvdW5kLl9wbGF5RmluaXNoZWQodGhpcyk7XHQvLyBUT0RPIGNoYW5nZSB0byBhbiBldmVudFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgc291bmQgaGFzIGJlZW4gaW50ZXJydXB0ZWQuXG5cdCAqIEBtZXRob2QgX2ludGVycnVwdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9pbnRlcnJ1cHQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY2xlYW5VcCgpO1xuXHRcdHRoaXMucGxheVN0YXRlID0gY3JlYXRlanMuU291bmQuUExBWV9JTlRFUlJVUFRFRDtcblx0XHR0aGlzLl9zZW5kRXZlbnQoXCJpbnRlcnJ1cHRlZFwiKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIGJ5IHRoZSBTb3VuZCBjbGFzcyB3aGVuIHRoZSBhdWRpbyBpcyByZWFkeSB0byBwbGF5IChkZWxheSBoYXMgY29tcGxldGVkKS4gU3RhcnRzIHNvdW5kIHBsYXlpbmcgaWYgdGhlXG5cdCAqIHNyYyBpcyBsb2FkZWQsIG90aGVyd2lzZSBwbGF5YmFjayB3aWxsIGZhaWwuXG5cdCAqIEBtZXRob2QgX2JlZ2luUGxheWluZ1xuXHQgKiBAcGFyYW0ge1BsYXlQcm9wc0NvbmZpZ30gcGxheVByb3BzIEEgUGxheVByb3BzQ29uZmlnIG9iamVjdC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgcGxheWJhY2sgc3VjY2VlZGVkLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHQvLyBPSlIgRmxhc2hBdWRpb1NvdW5kSW5zdGFuY2Ugb3ZlcndyaXRlc1xuXHRwLl9iZWdpblBsYXlpbmcgPSBmdW5jdGlvbiAocGxheVByb3BzKSB7XG5cdFx0dGhpcy5zZXRQb3NpdGlvbihwbGF5UHJvcHMub2Zmc2V0KTtcblx0XHR0aGlzLnNldExvb3AocGxheVByb3BzLmxvb3ApO1xuXHRcdHRoaXMuc2V0Vm9sdW1lKHBsYXlQcm9wcy52b2x1bWUpO1xuXHRcdHRoaXMuc2V0UGFuKHBsYXlQcm9wcy5wYW4pO1xuXHRcdGlmIChwbGF5UHJvcHMuc3RhcnRUaW1lICE9IG51bGwpIHtcblx0XHRcdHRoaXMuc2V0U3RhcnRUaW1lKHBsYXlQcm9wcy5zdGFydFRpbWUpO1xuXHRcdFx0dGhpcy5zZXREdXJhdGlvbihwbGF5UHJvcHMuZHVyYXRpb24pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9wbGF5YmFja1Jlc291cmNlICE9IG51bGwgJiYgdGhpcy5fcG9zaXRpb24gPCB0aGlzLl9kdXJhdGlvbikge1xuXHRcdFx0dGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9oYW5kbGVTb3VuZFJlYWR5KCk7XG5cdFx0XHR0aGlzLnBsYXlTdGF0ZSA9IGNyZWF0ZWpzLlNvdW5kLlBMQVlfU1VDQ0VFREVEO1xuXHRcdFx0dGhpcy5fc2VuZEV2ZW50KFwic3VjY2VlZGVkXCIpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3BsYXlGYWlsZWQoKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFBsYXkgaGFzIGZhaWxlZCwgd2hpY2ggY2FuIGhhcHBlbiBmb3IgYSB2YXJpZXR5IG9mIHJlYXNvbnMuXG5cdCAqIENsZWFucyB1cCBpbnN0YW5jZSBhbmQgZGlzcGF0Y2hlcyBmYWlsZWQgZXZlbnRcblx0ICogQG1ldGhvZCBfcGxheUZhaWxlZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fcGxheUZhaWxlZCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jbGVhblVwKCk7XG5cdFx0dGhpcy5wbGF5U3RhdGUgPSBjcmVhdGVqcy5Tb3VuZC5QTEFZX0ZBSUxFRDtcblx0XHR0aGlzLl9zZW5kRXZlbnQoXCJmYWlsZWRcIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIEF1ZGlvIGhhcyBmaW5pc2hlZCBwbGF5aW5nLiBNYW51YWxseSBsb29wIGl0IGlmIHJlcXVpcmVkLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVTb3VuZENvbXBsZXRlXG5cdCAqIEBwYXJhbSBldmVudFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9oYW5kbGVTb3VuZENvbXBsZXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dGhpcy5fcG9zaXRpb24gPSAwOyAgLy8gaGF2ZSB0byBzZXQgdGhpcyBhcyBpdCBjYW4gYmUgc2V0IGJ5IHBhdXNlIGR1cmluZyBwbGF5YmFja1xuXG5cdFx0aWYgKHRoaXMuX2xvb3AgIT0gMCkge1xuXHRcdFx0dGhpcy5fbG9vcC0tOyAgLy8gTk9URSB0aGlzIGludHJvZHVjZXMgYSB0aGVvcmV0aWNhbCBsaW1pdCBvbiBsb29wcyA9IGZsb2F0IG1heCBzaXplIHggMiAtIDFcblx0XHRcdHRoaXMuX2hhbmRsZUxvb3AoKTtcblx0XHRcdHRoaXMuX3NlbmRFdmVudChcImxvb3BcIik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fY2xlYW5VcCgpO1xuXHRcdHRoaXMucGxheVN0YXRlID0gY3JlYXRlanMuU291bmQuUExBWV9GSU5JU0hFRDtcblx0XHR0aGlzLl9zZW5kRXZlbnQoXCJjb21wbGV0ZVwiKTtcblx0fTtcblxuLy8gUGx1Z2luIHNwZWNpZmljIGNvZGVcblx0LyoqXG5cdCAqIEhhbmRsZXMgc3RhcnRpbmcgcGxheWJhY2sgd2hlbiB0aGUgc291bmQgaXMgcmVhZHkgZm9yIHBsYXlpbmcuXG5cdCAqIEBtZXRob2QgX2hhbmRsZVNvdW5kUmVhZHlcblx0ICogQHByb3RlY3RlZFxuIFx0ICovXG5cdHAuX2hhbmRsZVNvdW5kUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcGx1Z2luIHNwZWNpZmljIGNvZGVcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZnVuY3Rpb24gdXNlZCB0byB1cGRhdGUgdGhlIHZvbHVtZSBiYXNlZCBvbiB0aGUgaW5zdGFuY2Ugdm9sdW1lLCBtYXN0ZXIgdm9sdW1lLCBpbnN0YW5jZSBtdXRlIHZhbHVlLFxuXHQgKiBhbmQgbWFzdGVyIG11dGUgdmFsdWUuXG5cdCAqIEBtZXRob2QgX3VwZGF0ZVZvbHVtZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl91cGRhdGVWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcGx1Z2luIHNwZWNpZmljIGNvZGVcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZnVuY3Rpb24gdXNlZCB0byB1cGRhdGUgdGhlIHBhblxuXHQgKiBAbWV0aG9kIF91cGRhdGVQYW5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuX3VwZGF0ZVBhbiA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwbHVnaW4gc3BlY2lmaWMgY29kZVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBmdW5jdGlvbiB1c2VkIHRvIHVwZGF0ZSB0aGUgc3RhcnRUaW1lIG9mIHRoZSBhdWRpby5cblx0ICogQG1ldGhvZCBfdXBkYXRlU3RhcnRUaW1lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4xXG5cdCAqL1xuXHRwLl91cGRhdGVTdGFydFRpbWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcGx1Z2luIHNwZWNpZmljIGNvZGVcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZnVuY3Rpb24gdXNlZCB0byB1cGRhdGUgdGhlIGR1cmF0aW9uIG9mIHRoZSBhdWRpby5cblx0ICogQG1ldGhvZCBfdXBkYXRlRHVyYXRpb25cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuX3VwZGF0ZUR1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIHBsdWdpbiBzcGVjaWZpYyBjb2RlXG5cdH07XG5cblx0LyoqXG5cdCAqIEludGVybmFsIGZ1bmN0aW9uIHVzZWQgdG8gZ2V0IHRoZSBkdXJhdGlvbiBvZiB0aGUgYXVkaW8gZnJvbSB0aGUgc291cmNlIHdlJ2xsIGJlIHBsYXlpbmcuXG5cdCAqIEBtZXRob2QgX3VwZGF0ZUR1cmF0aW9uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl9zZXREdXJhdGlvbkZyb21Tb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcGx1Z2luIHNwZWNpZmljIGNvZGVcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZnVuY3Rpb24gdGhhdCBjYWxjdWxhdGVzIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwbGF5aGVhZCBhbmQgc2V0cyB0aGlzLl9wb3NpdGlvbiB0byB0aGF0IHZhbHVlXG5cdCAqIEBtZXRob2QgX2NhbGN1bGF0ZUN1cnJlbnRQb3NpdGlvblxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5fY2FsY3VsYXRlQ3VycmVudFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIHBsdWdpbiBzcGVjaWZpYyBjb2RlIHRoYXQgc2V0cyB0aGlzLnBvc2l0aW9uXG5cdH07XG5cblx0LyoqXG5cdCAqIEludGVybmFsIGZ1bmN0aW9uIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgcGxheWhlYWQuXG5cdCAqIEBtZXRob2QgX3VwZGF0ZVBvc2l0aW9uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl91cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwbHVnaW4gc3BlY2lmaWMgY29kZVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBmdW5jdGlvbiBjYWxsZWQgd2hlbiBsb29waW5nIGlzIHJlbW92ZWQgZHVyaW5nIHBsYXliYWNrLlxuXHQgKiBAbWV0aG9kIF9yZW1vdmVMb29waW5nXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGxvb3AgYWZ0ZXIgcGxheS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuX3JlbW92ZUxvb3BpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHQvLyBwbHVnaW4gc3BlY2lmaWMgY29kZVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBmdW5jdGlvbiBjYWxsZWQgd2hlbiBsb29waW5nIGlzIGFkZGVkIGR1cmluZyBwbGF5YmFjay5cblx0ICogQG1ldGhvZCBfYWRkTG9vcGluZ1xuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG51bWJlciBvZiB0aW1lcyB0byBsb29wIGFmdGVyIHBsYXkuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl9hZGRMb29waW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0Ly8gcGx1Z2luIHNwZWNpZmljIGNvZGVcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZnVuY3Rpb24gY2FsbGVkIHdoZW4gcGF1c2luZyBwbGF5YmFja1xuXHQgKiBAbWV0aG9kIF9wYXVzZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5fcGF1c2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcGx1Z2luIHNwZWNpZmljIGNvZGVcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZnVuY3Rpb24gY2FsbGVkIHdoZW4gcmVzdW1pbmcgcGxheWJhY2tcblx0ICogQG1ldGhvZCBfcmVzdW1lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl9yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcGx1Z2luIHNwZWNpZmljIGNvZGVcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZnVuY3Rpb24gY2FsbGVkIHdoZW4gc3RvcHBpbmcgcGxheWJhY2tcblx0ICogQG1ldGhvZCBfaGFuZGxlU3RvcFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5faGFuZGxlU3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHBsdWdpbiBzcGVjaWZpYyBjb2RlXG5cdH07XG5cblx0LyoqXG5cdCAqIEludGVybmFsIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIEFic3RyYWN0U291bmRJbnN0YW5jZSBpcyBiZWluZyBjbGVhbmVkIHVwXG5cdCAqIEBtZXRob2QgX2hhbmRsZUNsZWFuVXBcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuX2hhbmRsZUNsZWFuVXAgPSBmdW5jdGlvbigpIHtcblx0XHQvLyBwbHVnaW4gc3BlY2lmaWMgY29kZVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBmdW5jdGlvbiBjYWxsZWQgd2hlbiBBYnN0cmFjdFNvdW5kSW5zdGFuY2UgaGFzIHBsYXllZCB0byBlbmQgYW5kIGlzIGxvb3Bpbmdcblx0ICogQG1ldGhvZCBfaGFuZGxlTG9vcFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5faGFuZGxlTG9vcCA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwbHVnaW4gc3BlY2lmaWMgY29kZVxuXHR9O1xuXG5cdGNyZWF0ZWpzLkFic3RyYWN0U291bmRJbnN0YW5jZSA9IGNyZWF0ZWpzLnByb21vdGUoQWJzdHJhY3RTb3VuZEluc3RhbmNlLCBcIkV2ZW50RGlzcGF0Y2hlclwiKTtcblx0Y3JlYXRlanMuRGVmYXVsdFNvdW5kSW5zdGFuY2UgPSBjcmVhdGVqcy5BYnN0cmFjdFNvdW5kSW5zdGFuY2U7XHQvLyB1c2VkIHdoZW4gbm8gcGx1Z2luIGlzIHN1cHBvcnRlZFxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEFic3RyYWN0UGx1Z2luLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3RvcjpcbiBcdC8qKlxuXHQgKiBBIGRlZmF1bHQgcGx1Z2luIGNsYXNzIHVzZWQgYXMgYSBiYXNlIGZvciBhbGwgb3RoZXIgcGx1Z2lucy5cblx0ICogQGNsYXNzIEFic3RyYWN0UGx1Z2luXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblx0dmFyIEFic3RyYWN0UGx1Z2luID0gZnVuY3Rpb24gKCkge1xuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIGNhcGFiaWxpdGllcyBvZiB0aGUgcGx1Z2luLlxuXHRcdCAqIG1ldGhvZCBhbmQgaXMgdXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcm9wZXJ0eSBfY2FwYWJpbGl0aWVzXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBzdGF0aWNcblx0XHQgKi9cblx0XHR0aGlzLl9jYXBhYmlsaXRpZXMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogT2JqZWN0IGhhc2ggaW5kZXhlZCBieSB0aGUgc291cmNlIFVSSSBvZiBhbGwgY3JlYXRlZCBsb2FkZXJzLCB1c2VkIHRvIHByb3Blcmx5IGRlc3Ryb3kgdGhlbSBpZiBzb3VyY2VzIGFyZSByZW1vdmVkLlxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRlcnMgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIE9iamVjdCBoYXNoIGluZGV4ZWQgYnkgdGhlIHNvdXJjZSBVUkkgb2YgZWFjaCBmaWxlIHRvIGluZGljYXRlIGlmIGFuIGF1ZGlvIHNvdXJjZSBoYXMgYmVndW4gbG9hZGluZyxcblx0XHQgKiBpcyBjdXJyZW50bHkgbG9hZGluZywgb3IgaGFzIGNvbXBsZXRlZCBsb2FkaW5nLiAgQ2FuIGJlIHVzZWQgdG8gc3RvcmUgbm9uIGJvb2xlYW4gZGF0YSBhZnRlciBsb2FkaW5nXG5cdFx0ICogaXMgY29tcGxldGUgKGZvciBleGFtcGxlIGFycmF5QnVmZmVycyBmb3Igd2ViIGF1ZGlvKS5cblx0XHQgKiBAcHJvcGVydHkgX2F1ZGlvU291cmNlc1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX2F1ZGlvU291cmNlcyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogT2JqZWN0IGhhc2ggaW5kZXhlZCBieSB0aGUgc291cmNlIFVSSSBvZiBhbGwgY3JlYXRlZCBTb3VuZEluc3RhbmNlcywgdXBkYXRlcyB0aGUgcGxheWJhY2tSZXNvdXJjZSBpZiBpdCBsb2FkcyBhZnRlciB0aGV5IGFyZSBjcmVhdGVkLFxuXHRcdCAqIGFuZCBwcm9wZXJseSBkZXN0cm95IHRoZW0gaWYgc291cmNlcyBhcmUgcmVtb3ZlZFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3NvdW5kSW5zdGFuY2VzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBUaGUgaW50ZXJuYWwgbWFzdGVyIHZvbHVtZSB2YWx1ZSBvZiB0aGUgcGx1Z2luLlxuXHRcdCAqIEBwcm9wZXJ0eSBfdm9sdW1lXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3ZvbHVtZSA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBBIHJlZmVyZW5jZSB0byBhIGxvYWRlciBjbGFzcyB1c2VkIGJ5IGEgcGx1Z2luIHRoYXQgbXVzdCBiZSBzZXQuXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZGVyQ2xhc3M7XG5cblx0XHQvKipcblx0XHQgKiBBIHJlZmVyZW5jZSB0byBhbiBBYnN0cmFjdFNvdW5kSW5zdGFuY2UgY2xhc3MgdXNlZCBieSBhIHBsdWdpbiB0aGF0IG11c3QgYmUgc2V0LlxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByb3RlY3RlZDtcblx0XHQgKi9cblx0XHR0aGlzLl9zb3VuZEluc3RhbmNlQ2xhc3M7XG5cdH07XG5cdHZhciBwID0gQWJzdHJhY3RQbHVnaW4ucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG4vLyBTdGF0aWMgUHJvcGVydGllczpcbi8vIE5PVEUgVEhFU0UgUFJPUEVSVElFUyBORUVEIFRPIEJFIEFEREVEIFRPIEVBQ0ggUExVR0lOXG5cdC8qKlxuXHQgKiBUaGUgY2FwYWJpbGl0aWVzIG9mIHRoZSBwbHVnaW4uIFRoaXMgaXMgZ2VuZXJhdGVkIHZpYSB0aGUgX2dlbmVyYXRlQ2FwYWJpbGl0aWVzIG1ldGhvZCBhbmQgaXMgdXNlZCBpbnRlcm5hbGx5LlxuXHQgKiBAcHJvcGVydHkgX2NhcGFiaWxpdGllc1xuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKiBAZGVmYXVsdCBudWxsXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0QWJzdHJhY3RQbHVnaW4uX2NhcGFiaWxpdGllcyA9IG51bGw7XG5cblx0LyoqXG5cdCAqIERldGVybWluZSBpZiB0aGUgcGx1Z2luIGNhbiBiZSB1c2VkIGluIHRoZSBjdXJyZW50IGJyb3dzZXIvT1MuXG5cdCAqIEBtZXRob2QgaXNTdXBwb3J0ZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIHBsdWdpbiBjYW4gYmUgaW5pdGlhbGl6ZWQuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdEFic3RyYWN0UGx1Z2luLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUHJlLXJlZ2lzdGVyIGEgc291bmQgZm9yIHByZWxvYWRpbmcgYW5kIHNldHVwLiBUaGlzIGlzIGNhbGxlZCBieSB7eyNjcm9zc0xpbmsgXCJTb3VuZFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogTm90ZSBhbGwgcGx1Z2lucyBwcm92aWRlIGEgPGNvZGU+TG9hZGVyPC9jb2RlPiBpbnN0YW5jZSwgd2hpY2ggPGEgaHJlZj1cImh0dHA6Ly9wcmVsb2FkanMuY29tXCIgdGFyZ2V0PVwiX2JsYW5rXCI+UHJlbG9hZEpTPC9hPlxuXHQgKiBjYW4gdXNlIHRvIGFzc2lzdCB3aXRoIHByZWxvYWRpbmcuXG5cdCAqIEBtZXRob2QgcmVnaXN0ZXJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGxvYWRJdGVtIEFuIE9iamVjdCBjb250YWluaW5nIHRoZSBzb3VyY2Ugb2YgdGhlIGF1ZGlvXG5cdCAqIE5vdGUgdGhhdCBub3QgZXZlcnkgcGx1Z2luIHdpbGwgbWFuYWdlIHRoaXMgdmFsdWUuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQSByZXN1bHQgb2JqZWN0LCBjb250YWluaW5nIGEgXCJ0YWdcIiBmb3IgcHJlbG9hZGluZyBwdXJwb3Nlcy5cblx0ICovXG5cdHAucmVnaXN0ZXIgPSBmdW5jdGlvbiAobG9hZEl0ZW0pIHtcblx0XHR2YXIgbG9hZGVyID0gdGhpcy5fbG9hZGVyc1tsb2FkSXRlbS5zcmNdO1xuXHRcdGlmKGxvYWRlciAmJiAhbG9hZGVyLmNhbmNlbGVkKSB7cmV0dXJuIHRoaXMuX2xvYWRlcnNbbG9hZEl0ZW0uc3JjXTt9XHQvLyBhbHJlYWR5IGxvYWRpbmcvbG9hZGVkIHRoaXMsIHNvIGRvbid0IGxvYWQgdHdpY2Vcblx0XHQvLyBPSlIgcG90ZW50aWFsIGlzc3VlIHRoYXQgd2Ugd29uJ3QgYmUgZmlyaW5nIGxvYWRlZCBldmVudCwgbWlnaHQgbmVlZCB0byB0cmlnZ2VyIGlmIHRoaXMgaXMgYWxyZWFkeSBsb2FkZWQ/XG5cdFx0dGhpcy5fYXVkaW9Tb3VyY2VzW2xvYWRJdGVtLnNyY10gPSB0cnVlO1xuXHRcdHRoaXMuX3NvdW5kSW5zdGFuY2VzW2xvYWRJdGVtLnNyY10gPSBbXTtcblx0XHRsb2FkZXIgPSBuZXcgdGhpcy5fbG9hZGVyQ2xhc3MobG9hZEl0ZW0pO1xuXHRcdGxvYWRlci5vbihcImNvbXBsZXRlXCIsIHRoaXMuX2hhbmRsZVByZWxvYWRDb21wbGV0ZSwgdGhpcyk7XG5cdFx0dGhpcy5fbG9hZGVyc1tsb2FkSXRlbS5zcmNdID0gbG9hZGVyO1xuXHRcdHJldHVybiBsb2FkZXI7XG5cdH07XG5cblx0Ly8gbm90ZSBzb3VuZCBjYWxscyByZWdpc3RlciBiZWZvcmUgY2FsbGluZyBwcmVsb2FkXG5cdC8qKlxuXHQgKiBJbnRlcm5hbGx5IHByZWxvYWQgYSBzb3VuZC5cblx0ICogQG1ldGhvZCBwcmVsb2FkXG5cdCAqIEBwYXJhbSB7TG9hZGVyfSBsb2FkZXIgVGhlIHNvdW5kIFVSSSB0byBsb2FkLlxuXHQgKi9cblx0cC5wcmVsb2FkID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdGxvYWRlci5vbihcImVycm9yXCIsIHRoaXMuX2hhbmRsZVByZWxvYWRFcnJvciwgdGhpcyk7XG5cdFx0bG9hZGVyLmxvYWQoKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHByZWxvYWRpbmcgaGFzIHN0YXJ0ZWQgZm9yIGEgc3BlY2lmaWMgc291cmNlLiBJZiB0aGUgc291cmNlIGlzIGZvdW5kLCB3ZSBjYW4gYXNzdW1lIGl0IGlzIGxvYWRpbmcsXG5cdCAqIG9yIGhhcyBhbHJlYWR5IGZpbmlzaGVkIGxvYWRpbmcuXG5cdCAqIEBtZXRob2QgaXNQcmVsb2FkU3RhcnRlZFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VuZCBVUkkgdG8gY2hlY2suXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRwLmlzUHJlbG9hZFN0YXJ0ZWQgPSBmdW5jdGlvbiAoc3JjKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9hdWRpb1NvdXJjZXNbc3JjXSAhPSBudWxsKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHByZWxvYWRpbmcgaGFzIGZpbmlzaGVkIGZvciBhIHNwZWNpZmljIHNvdXJjZS5cblx0ICogQG1ldGhvZCBpc1ByZWxvYWRDb21wbGV0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VuZCBVUkkgdG8gbG9hZC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdHAuaXNQcmVsb2FkQ29tcGxldGUgPSBmdW5jdGlvbiAoc3JjKSB7XG5cdFx0cmV0dXJuICghKHRoaXMuX2F1ZGlvU291cmNlc1tzcmNdID09IG51bGwgfHwgdGhpcy5fYXVkaW9Tb3VyY2VzW3NyY10gPT0gdHJ1ZSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYSBzb3VuZCBhZGRlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpbi9yZWdpc3RlclwifX17ey9jcm9zc0xpbmt9fS4gTm90ZSB0aGlzIGRvZXMgbm90IGNhbmNlbCBhIHByZWxvYWQuXG5cdCAqIEBtZXRob2QgcmVtb3ZlU291bmRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291bmQgVVJJIHRvIHVubG9hZC5cblx0ICovXG5cdHAucmVtb3ZlU291bmQgPSBmdW5jdGlvbiAoc3JjKSB7XG5cdFx0aWYgKCF0aGlzLl9zb3VuZEluc3RhbmNlc1tzcmNdKSB7IHJldHVybjsgfVxuXHRcdGZvciAodmFyIGkgPSB0aGlzLl9zb3VuZEluc3RhbmNlc1tzcmNdLmxlbmd0aDsgaS0tOyApIHtcblx0XHRcdHZhciBpdGVtID0gdGhpcy5fc291bmRJbnN0YW5jZXNbc3JjXVtpXTtcblx0XHRcdGl0ZW0uZGVzdHJveSgpO1xuXHRcdH1cblx0XHRkZWxldGUodGhpcy5fc291bmRJbnN0YW5jZXNbc3JjXSk7XG5cdFx0ZGVsZXRlKHRoaXMuX2F1ZGlvU291cmNlc1tzcmNdKTtcblx0XHRpZih0aGlzLl9sb2FkZXJzW3NyY10pIHsgdGhpcy5fbG9hZGVyc1tzcmNdLmRlc3Ryb3koKTsgfVxuXHRcdGRlbGV0ZSh0aGlzLl9sb2FkZXJzW3NyY10pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIHNvdW5kcyBhZGRlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpbi9yZWdpc3RlclwifX17ey9jcm9zc0xpbmt9fS4gTm90ZSB0aGlzIGRvZXMgbm90IGNhbmNlbCBhIHByZWxvYWQuXG5cdCAqIEBtZXRob2QgcmVtb3ZlQWxsU291bmRzXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdW5kIFVSSSB0byB1bmxvYWQuXG5cdCAqL1xuXHRwLnJlbW92ZUFsbFNvdW5kcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IodmFyIGtleSBpbiB0aGlzLl9hdWRpb1NvdXJjZXMpIHtcblx0XHRcdHRoaXMucmVtb3ZlU291bmQoa2V5KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIHNvdW5kIGluc3RhbmNlLiBJZiB0aGUgc291bmQgaGFzIG5vdCBiZWVuIHByZWxvYWRlZCwgaXQgaXMgaW50ZXJuYWxseSBwcmVsb2FkZWQgaGVyZS5cblx0ICogQG1ldGhvZCBjcmVhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291bmQgc291cmNlIHRvIHVzZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0VGltZSBBdWRpbyBzcHJpdGUgcHJvcGVydHkgdXNlZCB0byBhcHBseSBhbiBvZmZzZXQsIGluIG1pbGxpc2Vjb25kcy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIEF1ZGlvIHNwcml0ZSBwcm9wZXJ0eSB1c2VkIHRvIHNldCB0aGUgdGltZSB0aGUgY2xpcCBwbGF5cyBmb3IsIGluIG1pbGxpc2Vjb25kcy5cblx0ICogQHJldHVybiB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBBIHNvdW5kIGluc3RhbmNlIGZvciBwbGF5YmFjayBhbmQgY29udHJvbC5cblx0ICovXG5cdHAuY3JlYXRlID0gZnVuY3Rpb24gKHNyYywgc3RhcnRUaW1lLCBkdXJhdGlvbikge1xuXHRcdGlmICghdGhpcy5pc1ByZWxvYWRTdGFydGVkKHNyYykpIHtcblx0XHRcdHRoaXMucHJlbG9hZCh0aGlzLnJlZ2lzdGVyKHNyYykpO1xuXHRcdH1cblx0XHR2YXIgc2kgPSBuZXcgdGhpcy5fc291bmRJbnN0YW5jZUNsYXNzKHNyYywgc3RhcnRUaW1lLCBkdXJhdGlvbiwgdGhpcy5fYXVkaW9Tb3VyY2VzW3NyY10pO1xuXHRcdHRoaXMuX3NvdW5kSW5zdGFuY2VzW3NyY10ucHVzaChzaSk7XG5cdFx0cmV0dXJuIHNpO1xuXHR9O1xuXG5cdC8vIGlmIGEgcGx1Z2luIGRvZXMgbm90IHN1cHBvcnQgdm9sdW1lIGFuZCBtdXRlLCBpdCBzaG91bGQgc2V0IHRoZXNlIHRvIG51bGxcblx0LyoqXG5cdCAqIFNldCB0aGUgbWFzdGVyIHZvbHVtZSBvZiB0aGUgcGx1Z2luLCB3aGljaCBhZmZlY3RzIGFsbCBTb3VuZEluc3RhbmNlcy5cblx0ICogQG1ldGhvZCBzZXRWb2x1bWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSB2b2x1bWUgdG8gc2V0LCBiZXR3ZWVuIDAgYW5kIDEuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBwbHVnaW4gcHJvY2Vzc2VzIHRoZSBzZXRWb2x1bWUgY2FsbCAodHJ1ZSkuIFRoZSBTb3VuZCBjbGFzcyB3aWxsIGFmZmVjdCBhbGwgdGhlXG5cdCAqIGluc3RhbmNlcyBtYW51YWxseSBvdGhlcndpc2UuXG5cdCAqL1xuXHRwLnNldFZvbHVtZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHRoaXMuX3ZvbHVtZSA9IHZhbHVlO1xuXHRcdHRoaXMuX3VwZGF0ZVZvbHVtZSgpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIG1hc3RlciB2b2x1bWUgb2YgdGhlIHBsdWdpbiwgd2hpY2ggYWZmZWN0cyBhbGwgU291bmRJbnN0YW5jZXMuXG5cdCAqIEBtZXRob2QgZ2V0Vm9sdW1lXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIHZvbHVtZSBsZXZlbCwgYmV0d2VlbiAwIGFuZCAxLlxuXHQgKi9cblx0cC5nZXRWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZvbHVtZTtcblx0fTtcblxuXHQvKipcblx0ICogTXV0ZSBhbGwgc291bmRzIHZpYSB0aGUgcGx1Z2luLlxuXHQgKiBAbWV0aG9kIHNldE11dGVcblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBJZiBhbGwgc291bmQgc2hvdWxkIGJlIG11dGVkIG9yIG5vdC4gTm90ZSB0aGF0IHBsdWdpbi1sZXZlbCBtdXRpbmcganVzdCBsb29rcyB1cFxuXHQgKiB0aGUgbXV0ZSB2YWx1ZSBvZiBTb3VuZCB7eyNjcm9zc0xpbmsgXCJTb3VuZC9nZXRNdXRlXCJ9fXt7L2Nyb3NzTGlua319LCBzbyB0aGlzIHByb3BlcnR5IGlzIG5vdCB1c2VkIGhlcmUuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBtdXRlIGNhbGwgc3VjY2VlZHMuXG5cdCAqL1xuXHRwLnNldE11dGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR0aGlzLl91cGRhdGVWb2x1bWUoKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvLyBwbHVnaW5zIHNob3VsZCBvdmVyd3JpdGUgdGhpcyBtZXRob2Rcblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbQWJzdHJhY3RQbHVnaW5dXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogSGFuZGxlcyBpbnRlcm5hbCBwcmVsb2FkIGNvbXBsZXRpb24uXG5cdCAqIEBtZXRob2QgX2hhbmRsZVByZWxvYWRDb21wbGV0ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9oYW5kbGVQcmVsb2FkQ29tcGxldGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgc3JjID0gZXZlbnQudGFyZ2V0LmdldEl0ZW0oKS5zcmM7XG5cdFx0dGhpcy5fYXVkaW9Tb3VyY2VzW3NyY10gPSBldmVudC5yZXN1bHQ7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zb3VuZEluc3RhbmNlc1tzcmNdLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzLl9zb3VuZEluc3RhbmNlc1tzcmNdW2ldO1xuXHRcdFx0aXRlbS5zZXRQbGF5YmFja1Jlc291cmNlKHRoaXMuX2F1ZGlvU291cmNlc1tzcmNdKTtcblx0XHRcdC8vIFRvRG8gY29uc2lkZXIgYWRkaW5nIHBsYXkgY2FsbCBoZXJlIGlmIHBsYXlzdGF0ZSA9PSBwbGF5ZmFpbGVkXG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIGludGVybmFsIHByZWxvYWQgZXJyb3Ncblx0ICogQG1ldGhvZCBfaGFuZGxlUHJlbG9hZEVycm9yXG5cdCAqIEBwYXJhbSBldmVudFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9oYW5kbGVQcmVsb2FkRXJyb3IgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdC8vZGVsZXRlKHRoaXMuX2F1ZGlvU291cmNlc1tzcmNdKTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0IHRoZSBnYWluIHZhbHVlIGZvciBtYXN0ZXIgYXVkaW8uIFNob3VsZCBub3QgYmUgY2FsbGVkIGV4dGVybmFsbHkuXG5cdCAqIEBtZXRob2QgX3VwZGF0ZVZvbHVtZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl91cGRhdGVWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gUGx1Z2luIFNwZWNpZmljIGNvZGVcblx0fTtcblxuXHRjcmVhdGVqcy5BYnN0cmFjdFBsdWdpbiA9IEFic3RyYWN0UGx1Z2luO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFdlYkF1ZGlvTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogTG9hZGVyIHByb3ZpZGVzIGEgbWVjaGFuaXNtIHRvIHByZWxvYWQgV2ViIEF1ZGlvIGNvbnRlbnQgdmlhIFByZWxvYWRKUyBvciBpbnRlcm5hbGx5LiBJbnN0YW5jZXMgYXJlIHJldHVybmVkIHRvXG5cdCAqIHRoZSBwcmVsb2FkZXIsIGFuZCB0aGUgbG9hZCBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIGFzc2V0IG5lZWRzIHRvIGJlIHJlcXVlc3RlZC5cblx0ICpcblx0ICogQGNsYXNzIFdlYkF1ZGlvTG9hZGVyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBsb2FkSXRlbSBUaGUgaXRlbSB0byBiZSBsb2FkZWRcblx0ICogQGV4dGVuZHMgWEhSUmVxdWVzdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRmdW5jdGlvbiBMb2FkZXIobG9hZEl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCB0cnVlLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TT1VORCk7XG5cblx0fTtcblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuXHQvKipcblx0ICogd2ViIGF1ZGlvIGNvbnRleHQgcmVxdWlyZWQgZm9yIGRlY29kaW5nIGF1ZGlvXG5cdCAqIEBwcm9wZXJ0eSBjb250ZXh0XG5cdCAqIEB0eXBlIHtBdWRpb0NvbnRleHR9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdExvYWRlci5jb250ZXh0ID0gbnVsbDtcblxuXG4vLyBwdWJsaWMgbWV0aG9kc1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltXZWJBdWRpb0xvYWRlcl1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHNcblx0cC5fY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuWEhSUmVxdWVzdCh0aGlzLl9pdGVtLCBmYWxzZSk7XG5cdFx0dGhpcy5fcmVxdWVzdC5zZXRSZXNwb25zZVR5cGUoXCJhcnJheWJ1ZmZlclwiKTtcblx0fTtcblxuXHRwLl9zZW5kQ29tcGxldGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQvLyBPSlIgd2UgbGVhdmUgdGhpcyB3cmFwcGVkIGluIExvYWRlciBiZWNhdXNlIHdlIG5lZWQgdG8gcmVmZXJlbmNlIHNyYyBhbmQgdGhlIGhhbmRsZXIgb25seSByZWNlaXZlcyBhIHNpbmdsZSBhcmd1bWVudCwgdGhlIGRlY29kZWRBdWRpb1xuXHRcdExvYWRlci5jb250ZXh0LmRlY29kZUF1ZGlvRGF0YSh0aGlzLl9yYXdSZXN1bHQsXG5cdCAgICAgICAgIGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZUF1ZGlvRGVjb2RlZCwgdGhpcyksXG5cdCAgICAgICAgIGNyZWF0ZWpzLnByb3h5KHRoaXMuX3NlbmRFcnJvciwgdGhpcykpO1xuXHR9O1xuXG5cblx0LyoqXG5cdCogVGhlIGF1ZGlvIGhhcyBiZWVuIGRlY29kZWQuXG5cdCogQG1ldGhvZCBoYW5kbGVBdWRpb0RlY29kZWRcblx0KiBAcGFyYW0gZGVjb2RlZFxuXHQqIEBwcm90ZWN0ZWRcblx0Ki9cblx0cC5faGFuZGxlQXVkaW9EZWNvZGVkID0gZnVuY3Rpb24gKGRlY29kZWRBdWRpbykge1xuXHRcdHRoaXMuX3Jlc3VsdCA9IGRlY29kZWRBdWRpbztcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX19zZW5kQ29tcGxldGUoKTtcblx0fTtcblxuXHRjcmVhdGVqcy5XZWJBdWRpb0xvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoTG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFdlYkF1ZGlvU291bmRJbnN0YW5jZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuLyoqXG4gKiBXZWJBdWRpb1NvdW5kSW5zdGFuY2UgZXh0ZW5kcyB0aGUgYmFzZSBhcGkgb2Yge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlXCJ9fXt7L2Nyb3NzTGlua319IGFuZCBpcyB1c2VkIGJ5XG4gKiB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fS5cbiAqXG4gKiBXZWJBdWRpb1NvdW5kSW5zdGFuY2UgZXhwb3NlcyBhdWRpb05vZGVzIGZvciBhZHZhbmNlZCB1c2Vycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBwYXRoIHRvIGFuZCBmaWxlIG5hbWUgb2YgdGhlIHNvdW5kLlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0VGltZSBBdWRpbyBzcHJpdGUgcHJvcGVydHkgdXNlZCB0byBhcHBseSBhbiBvZmZzZXQsIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBBdWRpbyBzcHJpdGUgcHJvcGVydHkgdXNlZCB0byBzZXQgdGhlIHRpbWUgdGhlIGNsaXAgcGxheXMgZm9yLCBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcGFyYW0ge09iamVjdH0gcGxheWJhY2tSZXNvdXJjZSBBbnkgcmVzb3VyY2UgbmVlZGVkIGJ5IHBsdWdpbiB0byBzdXBwb3J0IGF1ZGlvIHBsYXliYWNrLlxuICogQGNsYXNzIFdlYkF1ZGlvU291bmRJbnN0YW5jZVxuICogQGV4dGVuZHMgQWJzdHJhY3RTb3VuZEluc3RhbmNlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0ZnVuY3Rpb24gV2ViQXVkaW9Tb3VuZEluc3RhbmNlKHNyYywgc3RhcnRUaW1lLCBkdXJhdGlvbiwgcGxheWJhY2tSZXNvdXJjZSkge1xuXHRcdHRoaXMuQWJzdHJhY3RTb3VuZEluc3RhbmNlX2NvbnN0cnVjdG9yKHNyYywgc3RhcnRUaW1lLCBkdXJhdGlvbiwgcGxheWJhY2tSZXNvdXJjZSk7XG5cblxuLy8gcHVibGljIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBOT1RFIHRoaXMgaXMgb25seSBpbnRlbmRlZCBmb3IgdXNlIGJ5IGFkdmFuY2VkIHVzZXJzLlxuXHRcdCAqIDxiciAvPkdhaW5Ob2RlIGZvciBjb250cm9sbGluZyA8Y29kZT5XZWJBdWRpb1NvdW5kSW5zdGFuY2U8L2NvZGU+IHZvbHVtZS4gQ29ubmVjdGVkIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1NvdW5kSW5zdGFuY2UvZGVzdGluYXRpb25Ob2RlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBnYWluTm9kZVxuXHRcdCAqIEB0eXBlIHtBdWRpb0dhaW5Ob2RlfVxuXHRcdCAqIEBzaW5jZSAwLjQuMFxuXHRcdCAqXG5cdFx0ICovXG5cdFx0dGhpcy5nYWluTm9kZSA9IHMuY29udGV4dC5jcmVhdGVHYWluKCk7XG5cblx0XHQvKipcblx0XHQgKiBOT1RFIHRoaXMgaXMgb25seSBpbnRlbmRlZCBmb3IgdXNlIGJ5IGFkdmFuY2VkIHVzZXJzLlxuXHRcdCAqIDxiciAvPkEgcGFuTm9kZSBhbGxvd2luZyBsZWZ0IGFuZCByaWdodCBhdWRpbyBjaGFubmVsIHBhbm5pbmcgb25seS4gQ29ubmVjdGVkIHRvIFdlYkF1ZGlvU291bmRJbnN0YW5jZSB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1NvdW5kSW5zdGFuY2UvZ2Fpbk5vZGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IHBhbk5vZGVcblx0XHQgKiBAdHlwZSB7QXVkaW9QYW5uZXJOb2RlfVxuXHRcdCAqIEBzaW5jZSAwLjQuMFxuXHRcdCAqL1xuXHRcdHRoaXMucGFuTm9kZSA9IHMuY29udGV4dC5jcmVhdGVQYW5uZXIoKTtcblx0XHR0aGlzLnBhbk5vZGUucGFubmluZ01vZGVsID0gcy5fcGFubmluZ01vZGVsO1xuXHRcdHRoaXMucGFuTm9kZS5jb25uZWN0KHRoaXMuZ2Fpbk5vZGUpO1xuXHRcdHRoaXMuX3VwZGF0ZVBhbigpO1xuXG5cdFx0LyoqXG5cdFx0ICogTk9URSB0aGlzIGlzIG9ubHkgaW50ZW5kZWQgZm9yIHVzZSBieSBhZHZhbmNlZCB1c2Vycy5cblx0XHQgKiA8YnIgLz5zb3VyY2VOb2RlIGlzIHRoZSBhdWRpbyBzb3VyY2UuIENvbm5lY3RlZCB0byBXZWJBdWRpb1NvdW5kSW5zdGFuY2Uge3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9Tb3VuZEluc3RhbmNlL3Bhbk5vZGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IHNvdXJjZU5vZGVcblx0XHQgKiBAdHlwZSB7QXVkaW9Ob2RlfVxuXHRcdCAqIEBzaW5jZSAwLjQuMFxuXHRcdCAqXG5cdFx0ICovXG5cdFx0dGhpcy5zb3VyY2VOb2RlID0gbnVsbDtcblxuXG4vLyBwcml2YXRlIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBUaW1lb3V0IHRoYXQgaXMgY3JlYXRlZCBpbnRlcm5hbGx5IHRvIGhhbmRsZSBzb3VuZCBwbGF5aW5nIHRvIGNvbXBsZXRpb24uXG5cdFx0ICogU3RvcmVkIHNvIHdlIGNhbiByZW1vdmUgaXQgd2hlbiBzdG9wLCBwYXVzZSwgb3IgY2xlYW51cCBhcmUgY2FsbGVkXG5cdFx0ICogQHByb3BlcnR5IF9zb3VuZENvbXBsZXRlVGltZW91dFxuXHRcdCAqIEB0eXBlIHt0aW1lb3V0VmFyaWFibGV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAc2luY2UgMC40LjBcblx0XHQgKi9cblx0XHR0aGlzLl9zb3VuZENvbXBsZXRlVGltZW91dCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBOT1RFIHRoaXMgaXMgb25seSBpbnRlbmRlZCBmb3IgdXNlIGJ5IHZlcnkgYWR2YW5jZWQgdXNlcnMuXG5cdFx0ICogX3NvdXJjZU5vZGVOZXh0IGlzIHRoZSBhdWRpbyBzb3VyY2UgZm9yIHRoZSBuZXh0IGxvb3AsIGluc2VydGVkIGluIGEgbG9vayBhaGVhZCBhcHByb2FjaCB0byBhbGxvdyBmb3Igc21vb3RoXG5cdFx0ICogbG9vcGluZy4gQ29ubmVjdGVkIHRvIHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvU291bmRJbnN0YW5jZS9nYWluTm9kZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgX3NvdXJjZU5vZGVOZXh0XG5cdFx0ICogQHR5cGUge0F1ZGlvTm9kZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBzaW5jZSAwLjQuMVxuXHRcdCAqXG5cdFx0ICovXG5cdFx0dGhpcy5fc291cmNlTm9kZU5leHQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGltZSBhdWRpbyBzdGFydGVkIHBsYXliYWNrLCBpbiBzZWNvbmRzLiBVc2VkIHRvIGhhbmRsZSBzZXQgcG9zaXRpb24sIGdldCBwb3NpdGlvbiwgYW5kIHJlc3VtaW5nIGZyb20gcGF1c2VkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcGxheWJhY2tTdGFydFRpbWVcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHNpbmNlIDAuNC4wXG5cdFx0ICovXG5cdFx0dGhpcy5fcGxheWJhY2tTdGFydFRpbWUgPSAwO1xuXG5cdFx0Ly8gUHJveGllcywgbWFrZSByZW1vdmluZyBsaXN0ZW5lcnMgZWFzaWVyLlxuXHRcdHRoaXMuX2VuZGVkSGFuZGxlciA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVNvdW5kQ29tcGxldGUsIHRoaXMpO1xuXHR9O1xuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChXZWJBdWRpb1NvdW5kSW5zdGFuY2UsIGNyZWF0ZWpzLkFic3RyYWN0U291bmRJbnN0YW5jZSk7XG5cdHZhciBzID0gV2ViQXVkaW9Tb3VuZEluc3RhbmNlO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cblx0LyoqXG5cdCAqIE5vdGUgdGhpcyBpcyBvbmx5IGludGVuZGVkIGZvciB1c2UgYnkgYWR2YW5jZWQgdXNlcnMuXG5cdCAqIDxiciAvPkF1ZGlvIGNvbnRleHQgdXNlZCB0byBjcmVhdGUgbm9kZXMuICBUaGlzIGlzIGFuZCBuZWVkcyB0byBiZSB0aGUgc2FtZSBjb250ZXh0IHVzZWQgYnkge3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0uXG4gIFx0ICogQHByb3BlcnR5IGNvbnRleHRcblx0ICogQHR5cGUge0F1ZGlvQ29udGV4dH1cblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuY29udGV4dCA9IG51bGw7XG5cblx0LyoqXG5cdCAqIE5vdGUgdGhpcyBpcyBvbmx5IGludGVuZGVkIGZvciB1c2UgYnkgYWR2YW5jZWQgdXNlcnMuXG5cdCAqIDxiciAvPlRoZSBzY3JhdGNoIGJ1ZmZlciB0aGF0IHdpbGwgYmUgYXNzaWduZWQgdG8gdGhlIGJ1ZmZlciBwcm9wZXJ0eSBvZiBhIHNvdXJjZSBub2RlIG9uIGNsb3NlLiAgXG5cdCAqIFRoaXMgaXMgYW5kIHNob3VsZCBiZSB0aGUgc2FtZSBzY3JhdGNoIGJ1ZmZlciByZWZlcmVuY2VkIGJ5IHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319LlxuICBcdCAqIEBwcm9wZXJ0eSBfc2NyYXRjaEJ1ZmZlclxuXHQgKiBAdHlwZSB7QXVkaW9CdWZmZXJTb3VyY2VOb2RlfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLl9zY3JhdGNoQnVmZmVyID0gbnVsbDtcblxuXHQvKipcblx0ICogTm90ZSB0aGlzIGlzIG9ubHkgaW50ZW5kZWQgZm9yIHVzZSBieSBhZHZhbmNlZCB1c2Vycy5cblx0ICogPGJyIC8+IEF1ZGlvIG5vZGUgZnJvbSBXZWJBdWRpb1BsdWdpbiB0aGF0IHNlcXVlbmNlcyB0byA8Y29kZT5jb250ZXh0LmRlc3RpbmF0aW9uPC9jb2RlPlxuXHQgKiBAcHJvcGVydHkgZGVzdGluYXRpb25Ob2RlXG5cdCAqIEB0eXBlIHtBdWRpb05vZGV9XG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLmRlc3RpbmF0aW9uTm9kZSA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFZhbHVlIHRvIHNldCBwYW5uaW5nIG1vZGVsIHRvIGVxdWFsIHBvd2VyIGZvciBXZWJBdWRpb1NvdW5kSW5zdGFuY2UuICBDYW4gYmUgXCJlcXVhbHBvd2VyXCIgb3IgMCBkZXBlbmRpbmcgb24gYnJvd3NlciBpbXBsZW1lbnRhdGlvbi5cblx0ICogQHByb3BlcnR5IF9wYW5uaW5nTW9kZWxcblx0ICogQHR5cGUge051bWJlciAvIFN0cmluZ31cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5fcGFubmluZ01vZGVsID0gXCJlcXVhbHBvd2VyXCI7XG5cblxuLy8gUHVibGljIG1ldGhvZHNcblx0cC5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5BYnN0cmFjdFNvdW5kSW5zdGFuY2VfZGVzdHJveSgpO1xuXG5cdFx0dGhpcy5wYW5Ob2RlLmRpc2Nvbm5lY3QoMCk7XG5cdFx0dGhpcy5wYW5Ob2RlID0gbnVsbDtcblx0XHR0aGlzLmdhaW5Ob2RlLmRpc2Nvbm5lY3QoMCk7XG5cdFx0dGhpcy5nYWluTm9kZSA9IG51bGw7XG5cdH07XG5cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbV2ViQXVkaW9Tb3VuZEluc3RhbmNlXVwiO1xuXHR9O1xuXG5cbi8vIFByaXZhdGUgTWV0aG9kc1xuXHRwLl91cGRhdGVQYW4gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnBhbk5vZGUuc2V0UG9zaXRpb24odGhpcy5fcGFuLCAwLCAtMC41KTtcblx0XHQvLyB6IG5lZWQgdG8gYmUgLTAuNSBvdGhlcndpc2UgdGhlIHNvdW5kIG9ubHkgcGxheXMgaW4gbGVmdCwgcmlnaHQsIG9yIGNlbnRlclxuXHR9O1xuXG5cdHAuX3JlbW92ZUxvb3BpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHRoaXMuX3NvdXJjZU5vZGVOZXh0ID0gdGhpcy5fY2xlYW5VcEF1ZGlvTm9kZSh0aGlzLl9zb3VyY2VOb2RlTmV4dCk7XG5cdH07XG5cblx0cC5fYWRkTG9vcGluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMucGxheVN0YXRlICE9IGNyZWF0ZWpzLlNvdW5kLlBMQVlfU1VDQ0VFREVEKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuX3NvdXJjZU5vZGVOZXh0ID0gdGhpcy5fY3JlYXRlQW5kUGxheUF1ZGlvTm9kZSh0aGlzLl9wbGF5YmFja1N0YXJ0VGltZSwgMCk7XG5cdH07XG5cblx0cC5fc2V0RHVyYXRpb25Gcm9tU291cmNlID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gdGhpcy5wbGF5YmFja1Jlc291cmNlLmR1cmF0aW9uICogMTAwMDtcblx0fTtcblxuXHRwLl9oYW5kbGVDbGVhblVwID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLnNvdXJjZU5vZGUgJiYgdGhpcy5wbGF5U3RhdGUgPT0gY3JlYXRlanMuU291bmQuUExBWV9TVUNDRUVERUQpIHtcblx0XHRcdHRoaXMuc291cmNlTm9kZSA9IHRoaXMuX2NsZWFuVXBBdWRpb05vZGUodGhpcy5zb3VyY2VOb2RlKTtcblx0XHRcdHRoaXMuX3NvdXJjZU5vZGVOZXh0ID0gdGhpcy5fY2xlYW5VcEF1ZGlvTm9kZSh0aGlzLl9zb3VyY2VOb2RlTmV4dCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuZ2Fpbk5vZGUubnVtYmVyT2ZPdXRwdXRzICE9IDApIHt0aGlzLmdhaW5Ob2RlLmRpc2Nvbm5lY3QoMCk7fVxuXHRcdC8vIE9KUiB0aGVyZSBhcHBlYXJzIHRvIGJlIGEgYnVnIHRoYXQgdGhpcyBkb2Vzbid0IGFsd2F5cyB3b3JrIGluIHdlYmtpdCAoQ2hyb21lIGFuZCBTYWZhcmkpLiBBY2NvcmRpbmcgdG8gdGhlIGRvY3VtZW50YXRpb24sIHRoaXMgc2hvdWxkIHdvcmsuXG5cblx0XHRjbGVhclRpbWVvdXQodGhpcy5fc291bmRDb21wbGV0ZVRpbWVvdXQpO1xuXG5cdFx0dGhpcy5fcGxheWJhY2tTdGFydFRpbWUgPSAwO1x0Ly8gVGhpcyBpcyB1c2VkIGJ5IGdldFBvc2l0aW9uXG5cdH07XG5cblx0LyoqXG5cdCAqIFR1cm4gb2ZmIGFuZCBkaXNjb25uZWN0IGFuIGF1ZGlvTm9kZSwgdGhlbiBzZXQgcmVmZXJlbmNlIHRvIG51bGwgdG8gcmVsZWFzZSBpdCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdCAqIEBtZXRob2QgX2NsZWFuVXBBdWRpb05vZGVcblx0ICogQHBhcmFtIGF1ZGlvTm9kZVxuXHQgKiBAcmV0dXJuIHthdWRpb05vZGV9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNC4xXG5cdCAqL1xuXHRwLl9jbGVhblVwQXVkaW9Ob2RlID0gZnVuY3Rpb24oYXVkaW9Ob2RlKSB7XG5cdFx0aWYoYXVkaW9Ob2RlKSB7XG5cdFx0XHRhdWRpb05vZGUuc3RvcCgwKTtcblx0XHRcdGF1ZGlvTm9kZS5kaXNjb25uZWN0KDApO1xuXHRcdFx0Ly8gbmVjZXNzYXJ5IHRvIHByZXZlbnQgbGVhayBvbiBpT1MgU2FmYXJpIDctOS4gd2lsbCB0aHJvdyBpbiBhbG1vc3QgYWxsIG90aGVyXG5cdFx0XHQvLyBicm93c2VyIGltcGxlbWVudGF0aW9ucy5cblx0XHRcdHRyeSB7IGF1ZGlvTm9kZS5idWZmZXIgPSBzLl9zY3JhdGNoQnVmZmVyOyB9IGNhdGNoKGUpIHt9XG5cdFx0XHRhdWRpb05vZGUgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gYXVkaW9Ob2RlO1xuXHR9O1xuXG5cdHAuX2hhbmRsZVNvdW5kUmVhZHkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLmdhaW5Ob2RlLmNvbm5lY3Qocy5kZXN0aW5hdGlvbk5vZGUpOyAgLy8gdGhpcyBsaW5lIGNhbiBjYXVzZSBhIG1lbW9yeSBsZWFrLiAgTm9kZXMgbmVlZCB0byBiZSBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgYXVkaW9EZXN0aW5hdGlvbiBvciBhbnkgc2VxdWVuY2UgdGhhdCBsZWFkcyB0byBpdC5cblxuXHRcdHZhciBkdXIgPSB0aGlzLl9kdXJhdGlvbiAqIDAuMDAxO1xuXHRcdHZhciBwb3MgPSB0aGlzLl9wb3NpdGlvbiAqIDAuMDAxO1xuXHRcdGlmIChwb3MgPiBkdXIpIHtwb3MgPSBkdXI7fVxuXHRcdHRoaXMuc291cmNlTm9kZSA9IHRoaXMuX2NyZWF0ZUFuZFBsYXlBdWRpb05vZGUoKHMuY29udGV4dC5jdXJyZW50VGltZSAtIGR1ciksIHBvcyk7XG5cdFx0dGhpcy5fcGxheWJhY2tTdGFydFRpbWUgPSB0aGlzLnNvdXJjZU5vZGUuc3RhcnRUaW1lIC0gcG9zO1xuXG5cdFx0dGhpcy5fc291bmRDb21wbGV0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuX2VuZGVkSGFuZGxlciwgKGR1ciAtIHBvcykgKiAxMDAwKTtcblxuXHRcdGlmKHRoaXMuX2xvb3AgIT0gMCkge1xuXHRcdFx0dGhpcy5fc291cmNlTm9kZU5leHQgPSB0aGlzLl9jcmVhdGVBbmRQbGF5QXVkaW9Ob2RlKHRoaXMuX3BsYXliYWNrU3RhcnRUaW1lLCAwKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXVkaW8gbm9kZSB1c2luZyB0aGUgY3VycmVudCBzcmMgYW5kIGNvbnRleHQsIGNvbm5lY3RzIGl0IHRvIHRoZSBnYWluIG5vZGUsIGFuZCBzdGFydHMgcGxheWJhY2suXG5cdCAqIEBtZXRob2QgX2NyZWF0ZUFuZFBsYXlBdWRpb05vZGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0VGltZSBUaGUgdGltZSB0byBhZGQgdGhpcyB0byB0aGUgd2ViIGF1ZGlvIGNvbnRleHQsIGluIHNlY29uZHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGhlIGFtb3VudCBvZiB0aW1lIGludG8gdGhlIHNyYyBhdWRpbyB0byBzdGFydCBwbGF5YmFjaywgaW4gc2Vjb25kcy5cblx0ICogQHJldHVybiB7YXVkaW9Ob2RlfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKi9cblx0cC5fY3JlYXRlQW5kUGxheUF1ZGlvTm9kZSA9IGZ1bmN0aW9uKHN0YXJ0VGltZSwgb2Zmc2V0KSB7XG5cdFx0dmFyIGF1ZGlvTm9kZSA9IHMuY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcblx0XHRhdWRpb05vZGUuYnVmZmVyID0gdGhpcy5wbGF5YmFja1Jlc291cmNlO1xuXHRcdGF1ZGlvTm9kZS5jb25uZWN0KHRoaXMucGFuTm9kZSk7XG5cdFx0dmFyIGR1ciA9IHRoaXMuX2R1cmF0aW9uICogMC4wMDE7XG5cdFx0YXVkaW9Ob2RlLnN0YXJ0VGltZSA9IHN0YXJ0VGltZSArIGR1cjtcblx0XHRhdWRpb05vZGUuc3RhcnQoYXVkaW9Ob2RlLnN0YXJ0VGltZSwgb2Zmc2V0Kyh0aGlzLl9zdGFydFRpbWUqMC4wMDEpLCBkdXIgLSBvZmZzZXQpO1xuXHRcdHJldHVybiBhdWRpb05vZGU7XG5cdH07XG5cblx0cC5fcGF1c2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcG9zaXRpb24gPSAocy5jb250ZXh0LmN1cnJlbnRUaW1lIC0gdGhpcy5fcGxheWJhY2tTdGFydFRpbWUpICogMTAwMDsgIC8vICogMTAwMCB0byBnaXZlIG1pbGxpc2Vjb25kcywgbGV0cyB1cyByZXN0YXJ0IGF0IHNhbWUgcG9pbnRcblx0XHR0aGlzLnNvdXJjZU5vZGUgPSB0aGlzLl9jbGVhblVwQXVkaW9Ob2RlKHRoaXMuc291cmNlTm9kZSk7XG5cdFx0dGhpcy5fc291cmNlTm9kZU5leHQgPSB0aGlzLl9jbGVhblVwQXVkaW9Ob2RlKHRoaXMuX3NvdXJjZU5vZGVOZXh0KTtcblxuXHRcdGlmICh0aGlzLmdhaW5Ob2RlLm51bWJlck9mT3V0cHV0cyAhPSAwKSB7dGhpcy5nYWluTm9kZS5kaXNjb25uZWN0KDApO31cblxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9zb3VuZENvbXBsZXRlVGltZW91dCk7XG5cdH07XG5cblx0cC5fcmVzdW1lID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2hhbmRsZVNvdW5kUmVhZHkoKTtcblx0fTtcblxuXHQvKlxuXHRwLl9oYW5kbGVTdG9wID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIHdlYiBhdWRpbyBkb2VzIG5vdCBuZWVkIHRvIGRvIGFueXRoaW5nIGV4dHJhXG5cdH07XG5cdCovXG5cblx0cC5fdXBkYXRlVm9sdW1lID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBuZXdWb2x1bWUgPSB0aGlzLl9tdXRlZCA/IDAgOiB0aGlzLl92b2x1bWU7XG5cdCAgXHRpZiAobmV3Vm9sdW1lICE9IHRoaXMuZ2Fpbk5vZGUuZ2Fpbi52YWx1ZSkge1xuXHRcdCAgdGhpcy5nYWluTm9kZS5nYWluLnZhbHVlID0gbmV3Vm9sdW1lO1xuICBcdFx0fVxuXHR9O1xuXG5cdHAuX2NhbGN1bGF0ZUN1cnJlbnRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gKChzLmNvbnRleHQuY3VycmVudFRpbWUgLSB0aGlzLl9wbGF5YmFja1N0YXJ0VGltZSkgKiAxMDAwKTsgLy8gcG9zIGluIHNlY29uZHMgKiAxMDAwIHRvIGdpdmUgbWlsbGlzZWNvbmRzXG5cdH07XG5cblx0cC5fdXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5zb3VyY2VOb2RlID0gdGhpcy5fY2xlYW5VcEF1ZGlvTm9kZSh0aGlzLnNvdXJjZU5vZGUpO1xuXHRcdHRoaXMuX3NvdXJjZU5vZGVOZXh0ID0gdGhpcy5fY2xlYW5VcEF1ZGlvTm9kZSh0aGlzLl9zb3VyY2VOb2RlTmV4dCk7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NvdW5kQ29tcGxldGVUaW1lb3V0KTtcblxuXHRcdGlmICghdGhpcy5fcGF1c2VkKSB7dGhpcy5faGFuZGxlU291bmRSZWFkeSgpO31cblx0fTtcblxuXHQvLyBPSlIgd2UgYXJlIHVzaW5nIGEgbG9vayBhaGVhZCBhcHByb2FjaCB0byBlbnN1cmUgc21vb3RoIGxvb3BpbmcuXG5cdC8vIFdlIGFkZCBfc291cmNlTm9kZU5leHQgdG8gdGhlIGF1ZGlvIGNvbnRleHQgc28gdGhhdCBpdCBzdGFydHMgcGxheWluZyBldmVuIGlmIHRoaXMgY2FsbGJhY2sgaXMgZGVsYXllZC5cblx0Ly8gVGhpcyB0ZWNobmlxdWUgaXMgZGVzY3JpYmVkIGhlcmU6ICBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9hdWRpby9zY2hlZHVsaW5nL1xuXHQvLyBOT1RFIHRoZSBjb3N0IG9mIHRoaXMgaXMgdGhhdCBvdXIgYXVkaW8gbG9vcCBtYXkgbm90IGFsd2F5cyBtYXRjaCB0aGUgbG9vcCBldmVudCB0aW1pbmcgcHJlY2lzZWx5LlxuXHRwLl9oYW5kbGVMb29wID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NsZWFuVXBBdWRpb05vZGUodGhpcy5zb3VyY2VOb2RlKTtcblx0XHR0aGlzLnNvdXJjZU5vZGUgPSB0aGlzLl9zb3VyY2VOb2RlTmV4dDtcblx0XHR0aGlzLl9wbGF5YmFja1N0YXJ0VGltZSA9IHRoaXMuc291cmNlTm9kZS5zdGFydFRpbWU7XG5cdFx0dGhpcy5fc291cmNlTm9kZU5leHQgPSB0aGlzLl9jcmVhdGVBbmRQbGF5QXVkaW9Ob2RlKHRoaXMuX3BsYXliYWNrU3RhcnRUaW1lLCAwKTtcblx0XHR0aGlzLl9zb3VuZENvbXBsZXRlVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5fZW5kZWRIYW5kbGVyLCB0aGlzLl9kdXJhdGlvbik7XG5cdH07XG5cblx0cC5fdXBkYXRlRHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYodGhpcy5wbGF5U3RhdGUgPT0gY3JlYXRlanMuU291bmQuUExBWV9TVUNDRUVERUQpIHtcblx0XHRcdHRoaXMuX3BhdXNlKCk7XG5cdFx0XHR0aGlzLl9yZXN1bWUoKTtcblx0XHR9XG5cdH07XG5cblx0Y3JlYXRlanMuV2ViQXVkaW9Tb3VuZEluc3RhbmNlID0gY3JlYXRlanMucHJvbW90ZShXZWJBdWRpb1NvdW5kSW5zdGFuY2UsIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFdlYkF1ZGlvUGx1Z2luLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBQbGF5IHNvdW5kcyB1c2luZyBXZWIgQXVkaW8gaW4gdGhlIGJyb3dzZXIuIFRoZSBXZWJBdWRpb1BsdWdpbiBpcyBjdXJyZW50bHkgdGhlIGRlZmF1bHQgcGx1Z2luLCBhbmQgd2lsbCBiZSB1c2VkXG5cdCAqIGFueXdoZXJlIHRoYXQgaXQgaXMgc3VwcG9ydGVkLiBUbyBjaGFuZ2UgcGx1Z2luIHByaW9yaXR5LCBjaGVjayBvdXQgdGhlIFNvdW5kIEFQSVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZWdpc3RlclBsdWdpbnNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuXG5cdCAqIDxoND5Lbm93biBCcm93c2VyIGFuZCBPUyBpc3N1ZXMgZm9yIFdlYiBBdWRpbzwvaDQ+XG5cdCAqIDxiPkZpcmVmb3ggMjU8L2I+XG5cdCAqIDxsaT5cblx0ICogICAgIG1wMyBhdWRpbyBmaWxlcyBkbyBub3QgbG9hZCBwcm9wZXJseSBvbiBhbGwgd2luZG93cyBtYWNoaW5lcywgcmVwb3J0ZWQgPGEgaHJlZj1cImh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTkyOTk2OVwiIHRhcmdldD1cIl9ibGFua1wiPmhlcmU8L2E+LlxuXHQgKiAgICAgPGJyIC8+Rm9yIHRoaXMgcmVhc29uIGl0IGlzIHJlY29tbWVuZGVkIHRvIHBhc3MgYW5vdGhlciBGaXJlRm94LXN1cHBvcnRlZCB0eXBlIChpLmUuIG9nZykgYXMgdGhlIGRlZmF1bHRcblx0ICogICAgIGV4dGVuc2lvbiwgdW50aWwgdGhpcyBidWcgaXMgcmVzb2x2ZWRcblx0ICogPC9saT5cblx0ICpcblx0ICogPGI+V2Via2l0IChDaHJvbWUgYW5kIFNhZmFyaSk8L2I+XG5cdCAqIDxsaT5cblx0ICogICAgIEF1ZGlvTm9kZS5kaXNjb25uZWN0IGRvZXMgbm90IGFsd2F5cyBzZWVtIHRvIHdvcmsuICBUaGlzIGNhbiBjYXVzZSB0aGUgZmlsZSBzaXplIHRvIGdyb3cgb3ZlciB0aW1lIGlmIHlvdVxuXHQgKiBcdCAgIGFyZSBwbGF5aW5nIGEgbG90IG9mIGF1ZGlvIGZpbGVzLlxuXHQgKiA8L2xpPlxuXHQgKlxuXHQgKiA8Yj5pT1MgNiBsaW1pdGF0aW9uczwvYj5cblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPlxuXHQgKiAgICAgICAgIFNvdW5kIGlzIGluaXRpYWxseSBtdXRlZCBhbmQgd2lsbCBvbmx5IHVubXV0ZSB0aHJvdWdoIHBsYXkgYmVpbmcgY2FsbGVkIGluc2lkZSBhIHVzZXIgaW5pdGlhdGVkIGV2ZW50XG5cdCAqICAgICAgICAgKHRvdWNoL2NsaWNrKS4gUGxlYXNlIHJlYWQgdGhlIG1vYmlsZSBwbGF5YmFjayBub3RlcyBpbiB0aGUgdGhlIHt7I2Nyb3NzTGluayBcIlNvdW5kXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqICAgICAgICAgY2xhc3MgZm9yIGEgZnVsbCBvdmVydmlldyBvZiB0aGUgbGltaXRhdGlvbnMsIGFuZCBob3cgdG8gZ2V0IGFyb3VuZCB0aGVtLlxuXHQgKiAgICAgPC9saT5cblx0ICpcdCAgIDxsaT5cblx0ICpcdCAgICAgICBBIGJ1ZyBleGlzdHMgdGhhdCB3aWxsIGRpc3RvcnQgdW4tY2FjaGVkIGF1ZGlvIHdoZW4gYSB2aWRlbyBlbGVtZW50IGlzIHByZXNlbnQgaW4gdGhlIERPTS4gWW91IGNhbiBhdm9pZFxuXHQgKlx0ICAgICAgIHRoaXMgYnVnIGJ5IGVuc3VyaW5nIHRoZSBhdWRpbyBhbmQgdmlkZW8gYXVkaW8gc2hhcmUgdGhlIHNhbWUgc2FtcGxlIHJhdGUuXG5cdCAqXHQgICA8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBAY2xhc3MgV2ViQXVkaW9QbHVnaW5cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RQbHVnaW5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBzaW5jZSAwLjQuMFxuXHQgKi9cblx0ZnVuY3Rpb24gV2ViQXVkaW9QbHVnaW4oKSB7XG5cdFx0dGhpcy5BYnN0cmFjdFBsdWdpbl9jb25zdHJ1Y3RvcigpO1xuXG5cbi8vIFByaXZhdGUgUHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIFZhbHVlIHRvIHNldCBwYW5uaW5nIG1vZGVsIHRvIGVxdWFsIHBvd2VyIGZvciBXZWJBdWRpb1NvdW5kSW5zdGFuY2UuICBDYW4gYmUgXCJlcXVhbHBvd2VyXCIgb3IgMCBkZXBlbmRpbmcgb24gYnJvd3NlciBpbXBsZW1lbnRhdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgX3Bhbm5pbmdNb2RlbFxuXHRcdCAqIEB0eXBlIHtOdW1iZXIgLyBTdHJpbmd9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3Bhbm5pbmdNb2RlbCA9IHMuX3Bhbm5pbmdNb2RlbDs7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgd2ViIGF1ZGlvIGNvbnRleHQsIHdoaWNoIFdlYkF1ZGlvIHVzZXMgdG8gcGxheSBhdWRpby4gQWxsIG5vZGVzIHRoYXQgaW50ZXJhY3Qgd2l0aCB0aGUgV2ViQXVkaW9QbHVnaW5cblx0XHQgKiBuZWVkIHRvIGJlIGNyZWF0ZWQgd2l0aGluIHRoaXMgY29udGV4dC5cblx0XHQgKiBAcHJvcGVydHkgY29udGV4dFxuXHRcdCAqIEB0eXBlIHtBdWRpb0NvbnRleHR9XG5cdFx0ICovXG5cdFx0dGhpcy5jb250ZXh0ID0gcy5jb250ZXh0O1xuXG5cdFx0LyoqXG5cdFx0ICogQSBEeW5hbWljc0NvbXByZXNzb3JOb2RlLCB3aGljaCBpcyB1c2VkIHRvIGltcHJvdmUgc291bmQgcXVhbGl0eSBhbmQgcHJldmVudCBhdWRpbyBkaXN0b3J0aW9uLlxuXHRcdCAqIEl0IGlzIGNvbm5lY3RlZCB0byA8Y29kZT5jb250ZXh0LmRlc3RpbmF0aW9uPC9jb2RlPi5cblx0XHQgKlxuXHRcdCAqIENhbiBiZSBhY2Nlc3NlZCBieSBhZHZhbmNlZCB1c2VycyB0aHJvdWdoIGNyZWF0ZWpzLlNvdW5kLmFjdGl2ZVBsdWdpbi5keW5hbWljc0NvbXByZXNzb3JOb2RlLlxuXHRcdCAqIEBwcm9wZXJ0eSBkeW5hbWljc0NvbXByZXNzb3JOb2RlXG5cdFx0ICogQHR5cGUge0F1ZGlvTm9kZX1cblx0XHQgKi9cblx0XHR0aGlzLmR5bmFtaWNzQ29tcHJlc3Nvck5vZGUgPSB0aGlzLmNvbnRleHQuY3JlYXRlRHluYW1pY3NDb21wcmVzc29yKCk7XG5cdFx0dGhpcy5keW5hbWljc0NvbXByZXNzb3JOb2RlLmNvbm5lY3QodGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKTtcblxuXHRcdC8qKlxuXHRcdCAqIEEgR2Fpbk5vZGUgZm9yIGNvbnRyb2xsaW5nIG1hc3RlciB2b2x1bWUuIEl0IGlzIGNvbm5lY3RlZCB0byB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpbi9keW5hbWljc0NvbXByZXNzb3JOb2RlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqXG5cdFx0ICogQ2FuIGJlIGFjY2Vzc2VkIGJ5IGFkdmFuY2VkIHVzZXJzIHRocm91Z2ggY3JlYXRlanMuU291bmQuYWN0aXZlUGx1Z2luLmdhaW5Ob2RlLlxuXHRcdCAqIEBwcm9wZXJ0eSBnYWluTm9kZVxuXHRcdCAqIEB0eXBlIHtBdWRpb0dhaW5Ob2RlfVxuXHRcdCAqL1xuXHRcdHRoaXMuZ2Fpbk5vZGUgPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuXHRcdHRoaXMuZ2Fpbk5vZGUuY29ubmVjdCh0aGlzLmR5bmFtaWNzQ29tcHJlc3Nvck5vZGUpO1xuXHRcdGNyZWF0ZWpzLldlYkF1ZGlvU291bmRJbnN0YW5jZS5kZXN0aW5hdGlvbk5vZGUgPSB0aGlzLmdhaW5Ob2RlO1xuXG5cdFx0dGhpcy5fY2FwYWJpbGl0aWVzID0gcy5fY2FwYWJpbGl0aWVzO1xuXG5cdFx0dGhpcy5fbG9hZGVyQ2xhc3MgPSBjcmVhdGVqcy5XZWJBdWRpb0xvYWRlcjtcblx0XHR0aGlzLl9zb3VuZEluc3RhbmNlQ2xhc3MgPSBjcmVhdGVqcy5XZWJBdWRpb1NvdW5kSW5zdGFuY2U7XG5cblx0XHR0aGlzLl9hZGRQcm9wc1RvQ2xhc3NlcygpO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFdlYkF1ZGlvUGx1Z2luLCBjcmVhdGVqcy5BYnN0cmFjdFBsdWdpbik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuLy8gU3RhdGljIFByb3BlcnRpZXNcblx0dmFyIHMgPSBXZWJBdWRpb1BsdWdpbjtcblx0LyoqXG5cdCAqIFRoZSBjYXBhYmlsaXRpZXMgb2YgdGhlIHBsdWdpbi4gVGhpcyBpcyBnZW5lcmF0ZWQgdmlhIHRoZSB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpbi9fZ2VuZXJhdGVDYXBhYmlsaXRpZXM6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZCBhbmQgaXMgdXNlZCBpbnRlcm5hbGx5LlxuXHQgKiBAcHJvcGVydHkgX2NhcGFiaWxpdGllc1xuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKiBAZGVmYXVsdCBudWxsXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5fY2FwYWJpbGl0aWVzID0gbnVsbDtcblxuXHQvKipcblx0ICogVmFsdWUgdG8gc2V0IHBhbm5pbmcgbW9kZWwgdG8gZXF1YWwgcG93ZXIgZm9yIFdlYkF1ZGlvU291bmRJbnN0YW5jZS4gIENhbiBiZSBcImVxdWFscG93ZXJcIiBvciAwIGRlcGVuZGluZyBvbiBicm93c2VyIGltcGxlbWVudGF0aW9uLlxuXHQgKiBAcHJvcGVydHkgX3Bhbm5pbmdNb2RlbFxuXHQgKiBAdHlwZSB7TnVtYmVyIC8gU3RyaW5nfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuX3Bhbm5pbmdNb2RlbCA9IFwiZXF1YWxwb3dlclwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgd2ViIGF1ZGlvIGNvbnRleHQsIHdoaWNoIFdlYkF1ZGlvIHVzZXMgdG8gcGxheSBhdWRpby4gQWxsIG5vZGVzIHRoYXQgaW50ZXJhY3Qgd2l0aCB0aGUgV2ViQXVkaW9QbHVnaW5cblx0ICogbmVlZCB0byBiZSBjcmVhdGVkIHdpdGhpbiB0aGlzIGNvbnRleHQuXG5cdCAqXG5cdCAqIEFkdmFuY2VkIHVzZXJzIGNhbiBzZXQgdGhpcyB0byBhbiBleGlzdGluZyBjb250ZXh0LCBidXQgPGI+bXVzdDwvYj4gZG8gc28gYmVmb3JlIHRoZXkgY2FsbFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZWdpc3RlclBsdWdpbnNcIn19e3svY3Jvc3NMaW5rfX0gb3Ige3sjY3Jvc3NMaW5rIFwiU291bmQvaW5pdGlhbGl6ZURlZmF1bHRQbHVnaW5zXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiBAcHJvcGVydHkgY29udGV4dFxuXHQgKiBAdHlwZSB7QXVkaW9Db250ZXh0fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNvbnRleHQgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBUaGUgc2NyYXRjaCBidWZmZXIgdGhhdCB3aWxsIGJlIGFzc2lnbmVkIHRvIHRoZSBidWZmZXIgcHJvcGVydHkgb2YgYSBzb3VyY2Ugbm9kZSBvbiBjbG9zZS5cblx0ICogV29ya3MgYXJvdW5kIGFuIGlPUyBTYWZhcmkgYnVnOiBodHRwczovL2dpdGh1Yi5jb20vQ3JlYXRlSlMvU291bmRKUy9pc3N1ZXMvMTAyXG5cdCAqXG5cdCAqIEFkdmFuY2VkIHVzZXJzIGNhbiBzZXQgdGhpcyB0byBhbiBleGlzdGluZyBzb3VyY2Ugbm9kZSwgYnV0IDxiPm11c3Q8L2I+IGRvIHNvIGJlZm9yZSB0aGV5IGNhbGxcblx0ICoge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVnaXN0ZXJQbHVnaW5zXCJ9fXt7L2Nyb3NzTGlua319IG9yIHt7I2Nyb3NzTGluayBcIlNvdW5kL2luaXRpYWxpemVEZWZhdWx0UGx1Z2luc1wifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogQHByb3BlcnR5IF9zY3JhdGNoQnVmZmVyXG5cdCAqIEB0eXBlIHtBdWRpb0J1ZmZlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHQgcy5fc2NyYXRjaEJ1ZmZlciA9IG51bGw7XG5cblx0LyoqXG5cdCAqIEluZGljYXRlZCB3aGV0aGVyIGF1ZGlvIG9uIGlPUyBoYXMgYmVlbiB1bmxvY2tlZCwgd2hpY2ggcmVxdWlyZXMgYSB0b3VjaGVuZC9tb3VzZWRvd24gZXZlbnQgdGhhdCBwbGF5cyBhblxuXHQgKiBlbXB0eSBzb3VuZC5cblx0ICogQHByb3BlcnR5IF91bmxvY2tlZFxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0ICogQHNpbmNlIDAuNi4yXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzLl91bmxvY2tlZCA9IGZhbHNlO1xuXG5cbi8vIFN0YXRpYyBQdWJsaWMgTWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIHRoZSBwbHVnaW4gY2FuIGJlIHVzZWQgaW4gdGhlIGN1cnJlbnQgYnJvd3Nlci9PUy5cblx0ICogQG1ldGhvZCBpc1N1cHBvcnRlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgcGx1Z2luIGNhbiBiZSBpbml0aWFsaXplZC5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBjaGVjayBpZiB0aGlzIGlzIHNvbWUga2luZCBvZiBtb2JpbGUgZGV2aWNlLCBXZWIgQXVkaW8gd29ya3Mgd2l0aCBsb2NhbCBwcm90b2NvbCB1bmRlciBQaG9uZUdhcCBhbmQgaXQgaXMgdW5saWtlbHkgc29tZW9uZSBpcyB0cnlpbmcgdG8gcnVuIGEgbG9jYWwgZmlsZVxuXHRcdHZhciBpc01vYmlsZVBob25lR2FwID0gY3JlYXRlanMuQnJvd3NlckRldGVjdC5pc0lPUyB8fCBjcmVhdGVqcy5Ccm93c2VyRGV0ZWN0LmlzQW5kcm9pZCB8fCBjcmVhdGVqcy5Ccm93c2VyRGV0ZWN0LmlzQmxhY2tiZXJyeTtcblx0XHQvLyBPSlIgaXNNb2JpbGUgbWF5IGJlIHJlZHVuZGFudCB3aXRoIF9pc0ZpbGVYSFJTdXBwb3J0ZWQgYXZhaWxhYmxlLiAgQ29uc2lkZXIgcmVtb3ZpbmcuXG5cdFx0aWYgKGxvY2F0aW9uLnByb3RvY29sID09IFwiZmlsZTpcIiAmJiAhaXNNb2JpbGVQaG9uZUdhcCAmJiAhdGhpcy5faXNGaWxlWEhSU3VwcG9ydGVkKCkpIHsgcmV0dXJuIGZhbHNlOyB9ICAvLyBXZWIgQXVkaW8gcmVxdWlyZXMgWEhSLCB3aGljaCBpcyBub3QgdXN1YWxseSBhdmFpbGFibGUgbG9jYWxseVxuXHRcdHMuX2dlbmVyYXRlQ2FwYWJpbGl0aWVzKCk7XG5cdFx0aWYgKHMuY29udGV4dCA9PSBudWxsKSB7cmV0dXJuIGZhbHNlO31cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogUGxheXMgYW4gZW1wdHkgc291bmQgaW4gdGhlIHdlYiBhdWRpbyBjb250ZXh0LiAgVGhpcyBpcyB1c2VkIHRvIGVuYWJsZSB3ZWIgYXVkaW8gb24gaU9TIGRldmljZXMsIGFzIHRoZXlcblx0ICogcmVxdWlyZSB0aGUgZmlyc3Qgc291bmQgdG8gYmUgcGxheWVkIGluc2lkZSBvZiBhIHVzZXIgaW5pdGlhdGVkIGV2ZW50ICh0b3VjaC9jbGljaykuICBUaGlzIGlzIGNhbGxlZCB3aGVuXG5cdCAqIHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319IGlzIGluaXRpYWxpemVkIChieSBTb3VuZCB7eyNjcm9zc0xpbmsgXCJTb3VuZC9pbml0aWFsaXplRGVmYXVsdFBsdWdpbnNcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGV4YW1wbGUpLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaChldmVudCkge1xuXHQgKiAgICAgICAgIGNyZWF0ZWpzLldlYkF1ZGlvUGx1Z2luLnBsYXlFbXB0eVNvdW5kKCk7XG5cdCAqICAgICB9XG5cdCAqXG5cdCAqIEBtZXRob2QgcGxheUVtcHR5U291bmRcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC40LjFcblx0ICovXG5cdHMucGxheUVtcHR5U291bmQgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAocy5jb250ZXh0ID09IG51bGwpIHtyZXR1cm47fVxuXHRcdHZhciBzb3VyY2UgPSBzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cdFx0c291cmNlLmJ1ZmZlciA9IHMuX3NjcmF0Y2hCdWZmZXI7XG5cdFx0c291cmNlLmNvbm5lY3Qocy5jb250ZXh0LmRlc3RpbmF0aW9uKTtcblx0XHRzb3VyY2Uuc3RhcnQoMCwgMCwgMCk7XG5cdH07XG5cblxuLy8gU3RhdGljIFByaXZhdGUgTWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIFhIUiBpcyBzdXBwb3J0ZWQsIHdoaWNoIGlzIG5lY2Vzc2FyeSBmb3Igd2ViIGF1ZGlvLlxuXHQgKiBAbWV0aG9kIF9pc0ZpbGVYSFJTdXBwb3J0ZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgWEhSIGlzIHN1cHBvcnRlZC5cblx0ICogQHNpbmNlIDAuNC4yXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5faXNGaWxlWEhSU3VwcG9ydGVkID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gaXQncyBtdWNoIGVhc2llciB0byBkZXRlY3Qgd2hlbiBzb21ldGhpbmcgZ29lcyB3cm9uZywgc28gbGV0J3Mgc3RhcnQgb3B0aW1pc3RpY2FsbHlcblx0XHR2YXIgc3VwcG9ydGVkID0gdHJ1ZTtcblxuXHRcdHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHR0cnkge1xuXHRcdFx0eGhyLm9wZW4oXCJHRVRcIiwgXCJXZWJBdWRpb1BsdWdpblRlc3QuZmFpbFwiLCBmYWxzZSk7IC8vIGxvYWRpbmcgbm9uLWV4aXN0YW50IGZpbGUgdHJpZ2dlcnMgNDA0IG9ubHkgaWYgaXQgY291bGQgbG9hZCAoc3luY2hyb25vdXMgY2FsbClcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Ly8gY2F0Y2ggZXJyb3JzIGluIGNhc2VzIHdoZXJlIHRoZSBvbmVycm9yIGlzIHBhc3NlZCBieVxuXHRcdFx0c3VwcG9ydGVkID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gc3VwcG9ydGVkO1xuXHRcdH1cblx0XHR4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkgeyBzdXBwb3J0ZWQgPSBmYWxzZTsgfTsgLy8gY2F1c2UgaXJyZWxldmFudFxuXHRcdC8vIHdpdGggc2VjdXJpdHkgdHVybmVkIG9mZiwgd2UgY2FuIGdldCBlbXB0eSBzdWNjZXNzIHJlc3VsdHMsIHdoaWNoIGlzIGFjdHVhbGx5IGEgZmFpbGVkIHJlYWQgKHN0YXR1cyBjb2RlIDA/KVxuXHRcdHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHsgc3VwcG9ydGVkID0gdGhpcy5zdGF0dXMgPT0gNDA0IHx8ICh0aGlzLnN0YXR1cyA9PSAyMDAgfHwgKHRoaXMuc3RhdHVzID09IDAgJiYgdGhpcy5yZXNwb25zZSAhPSBcIlwiKSk7IH07XG5cdFx0dHJ5IHtcblx0XHRcdHhoci5zZW5kKCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdC8vIGNhdGNoIGVycm9ycyBpbiBjYXNlcyB3aGVyZSB0aGUgb25lcnJvciBpcyBwYXNzZWQgYnlcblx0XHRcdHN1cHBvcnRlZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdXBwb3J0ZWQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSB0aGUgY2FwYWJpbGl0aWVzIG9mIHRoZSBwbHVnaW4uIFVzZWQgaW50ZXJuYWxseS4gUGxlYXNlIHNlZSB0aGUgU291bmQgQVBJIHt7I2Nyb3NzTGluayBcIlNvdW5kL2dldENhcGFiaWxpdGllc1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QgZm9yIGFuIG92ZXJ2aWV3IG9mIHBsdWdpbiBjYXBhYmlsaXRpZXMuXG5cdCAqIEBtZXRob2QgX2dlbmVyYXRlQ2FwYWJpbGl0aWVzXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cy5fZ2VuZXJhdGVDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHMuX2NhcGFiaWxpdGllcyAhPSBudWxsKSB7cmV0dXJuO31cblx0XHQvLyBXZWIgQXVkaW8gY2FuIGJlIGluIGFueSBmb3JtYXRzIHN1cHBvcnRlZCBieSB0aGUgYXVkaW8gZWxlbWVudCwgZnJvbSBodHRwOi8vd3d3LnczLm9yZy9UUi93ZWJhdWRpby8jQXVkaW9Db250ZXh0LXNlY3Rpb25cblx0XHR2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhdWRpb1wiKTtcblx0XHRpZiAodC5jYW5QbGF5VHlwZSA9PSBudWxsKSB7cmV0dXJuIG51bGw7fVxuXG5cdFx0aWYgKHMuY29udGV4dCA9PSBudWxsKSB7XG5cdFx0XHRpZiAod2luZG93LkF1ZGlvQ29udGV4dCkge1xuXHRcdFx0XHRzLmNvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XG5cdFx0XHR9IGVsc2UgaWYgKHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpIHtcblx0XHRcdFx0cy5jb250ZXh0ID0gbmV3IHdlYmtpdEF1ZGlvQ29udGV4dCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChzLl9zY3JhdGNoQnVmZmVyID09IG51bGwpIHtcblx0XHRcdHMuX3NjcmF0Y2hCdWZmZXIgPSBzLmNvbnRleHQuY3JlYXRlQnVmZmVyKDEsIDEsIDIyMDUwKTtcblx0XHR9XG5cblx0XHRzLl9jb21wYXRpYmlsaXR5U2V0VXAoKTtcblxuXHRcdC8vIExpc3RlbiBmb3IgZG9jdW1lbnQgbGV2ZWwgY2xpY2tzIHRvIHVubG9jayBXZWJBdWRpbyBvbiBpT1MuIFNlZSB0aGUgX3VubG9jayBtZXRob2QuXG5cdFx0aWYgKFwib250b3VjaHN0YXJ0XCIgaW4gd2luZG93ICYmIHMuY29udGV4dC5zdGF0ZSAhPSBcInJ1bm5pbmdcIikge1xuXHRcdFx0cy5fdW5sb2NrKCk7IC8vIFdoZW4gcGxheWVkIGluc2lkZSBvZiBhIHRvdWNoIGV2ZW50LCB0aGlzIHdpbGwgZW5hYmxlIGF1ZGlvIG9uIGlPUyBpbW1lZGlhdGVseS5cblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgcy5fdW5sb2NrLCB0cnVlKTtcblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBzLl91bmxvY2ssIHRydWUpO1xuXHRcdH1cblxuXG5cdFx0cy5fY2FwYWJpbGl0aWVzID0ge1xuXHRcdFx0cGFubmluZzp0cnVlLFxuXHRcdFx0dm9sdW1lOnRydWUsXG5cdFx0XHR0cmFja3M6LTFcblx0XHR9O1xuXG5cdFx0Ly8gZGV0ZXJtaW5lIHdoaWNoIGV4dGVuc2lvbnMgb3VyIGJyb3dzZXIgc3VwcG9ydHMgZm9yIHRoaXMgcGx1Z2luIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIFNvdW5kLlNVUFBPUlRFRF9FWFRFTlNJT05TXG5cdFx0dmFyIHN1cHBvcnRlZEV4dGVuc2lvbnMgPSBjcmVhdGVqcy5Tb3VuZC5TVVBQT1JURURfRVhURU5TSU9OUztcblx0XHR2YXIgZXh0ZW5zaW9uTWFwID0gY3JlYXRlanMuU291bmQuRVhURU5TSU9OX01BUDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHN1cHBvcnRlZEV4dGVuc2lvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgZXh0ID0gc3VwcG9ydGVkRXh0ZW5zaW9uc1tpXTtcblx0XHRcdHZhciBwbGF5VHlwZSA9IGV4dGVuc2lvbk1hcFtleHRdIHx8IGV4dDtcblx0XHRcdHMuX2NhcGFiaWxpdGllc1tleHRdID0gKHQuY2FuUGxheVR5cGUoXCJhdWRpby9cIiArIGV4dCkgIT0gXCJub1wiICYmIHQuY2FuUGxheVR5cGUoXCJhdWRpby9cIiArIGV4dCkgIT0gXCJcIikgfHwgKHQuY2FuUGxheVR5cGUoXCJhdWRpby9cIiArIHBsYXlUeXBlKSAhPSBcIm5vXCIgJiYgdC5jYW5QbGF5VHlwZShcImF1ZGlvL1wiICsgcGxheVR5cGUpICE9IFwiXCIpO1xuXHRcdH0gIC8vIE9KUiBhbm90aGVyIHdheSB0byBkbyB0aGlzIG1pZ2h0IGJlIGNhblBsYXlUeXBlOlwibTRhXCIsIGNvZGV4OiBtcDRcblxuXHRcdC8vIDA9bm8gb3V0cHV0LCAxPW1vbm8sIDI9c3RlcmVvLCA0PXN1cnJvdW5kLCA2PTUuMSBzdXJyb3VuZC5cblx0XHQvLyBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvd2ViYXVkaW8vI0F1ZGlvQ2hhbm5lbFNwbGl0dGVyIGZvciBtb3JlIGRldGFpbHMgb24gY2hhbm5lbHMuXG5cdFx0aWYgKHMuY29udGV4dC5kZXN0aW5hdGlvbi5udW1iZXJPZkNoYW5uZWxzIDwgMikge1xuXHRcdFx0cy5fY2FwYWJpbGl0aWVzLnBhbm5pbmcgPSBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldCB1cCBjb21wYXRpYmlsaXR5IGlmIG9ubHkgZGVwcmVjYXRlZCB3ZWIgYXVkaW8gY2FsbHMgYXJlIHN1cHBvcnRlZC5cblx0ICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3dlYmF1ZGlvLyNEZXByZWNhdGlvbk5vdGVzXG5cdCAqIE5lZWRlZCBzbyB3ZSBjYW4gc3VwcG9ydCBuZXcgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGRlcHJlY2F0ZWQgY2FsbHMgKEZpcmVmb3gpIGFzIHdlbGwgYXMgb2xkIGJyb3dzZXJzIHRoYXRcblx0ICogZG9uJ3Qgc3VwcG9ydCBuZXcgY2FsbHMuXG5cdCAqXG5cdCAqIEBtZXRob2QgX2NvbXBhdGliaWxpdHlTZXRVcFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNC4yXG5cdCAqL1xuXHRzLl9jb21wYXRpYmlsaXR5U2V0VXAgPSBmdW5jdGlvbigpIHtcblx0XHRzLl9wYW5uaW5nTW9kZWwgPSBcImVxdWFscG93ZXJcIjtcblx0XHQvL2Fzc3VtZSB0aGF0IGlmIG9uZSBuZXcgY2FsbCBpcyBzdXBwb3J0ZWQsIHRoZXkgYWxsIGFyZVxuXHRcdGlmIChzLmNvbnRleHQuY3JlYXRlR2FpbikgeyByZXR1cm47IH1cblxuXHRcdC8vIHNpbXBsZSBuYW1lIGNoYW5nZSwgZnVuY3Rpb25hbGl0eSB0aGUgc2FtZVxuXHRcdHMuY29udGV4dC5jcmVhdGVHYWluID0gcy5jb250ZXh0LmNyZWF0ZUdhaW5Ob2RlO1xuXG5cdFx0Ly8gc291cmNlIG5vZGUsIGFkZCB0byBwcm90b3R5cGVcblx0XHR2YXIgYXVkaW9Ob2RlID0gcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuXHRcdGF1ZGlvTm9kZS5fX3Byb3RvX18uc3RhcnQgPSBhdWRpb05vZGUuX19wcm90b19fLm5vdGVHcmFpbk9uO1x0Ly8gbm90ZSB0aGF0IG5vdGVHcmFpbk9uIHJlcXVpcmVzIGFsbCAzIHBhcmFtZXRlcnNcblx0XHRhdWRpb05vZGUuX19wcm90b19fLnN0b3AgPSBhdWRpb05vZGUuX19wcm90b19fLm5vdGVPZmY7XG5cblx0XHQvLyBwYW5uaW5nTW9kZWxcblx0XHRzLl9wYW5uaW5nTW9kZWwgPSAwO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUcnkgdG8gdW5sb2NrIGF1ZGlvIG9uIGlPUy4gVGhpcyBpcyB0cmlnZ2VyZWQgZnJvbSBlaXRoZXIgV2ViQXVkaW8gcGx1Z2luIHNldHVwICh3aGljaCB3aWxsIHdvcmsgaWYgaW5zaWRlIG9mXG5cdCAqIGEgYG1vdXNlZG93bmAgb3IgYHRvdWNoZW5kYCBldmVudCBzdGFjayksIG9yIHRoZSBmaXJzdCBkb2N1bWVudCB0b3VjaGVuZC9tb3VzZWRvd24gZXZlbnQuIElmIGl0IGZhaWxzICh0b3VjaGVuZFxuXHQgKiB3aWxsIGZhaWwgaWYgdGhlIHVzZXIgcHJlc3NlcyBmb3IgdG9vIGxvbmcsIGluZGljYXRpbmcgYSBzY3JvbGwgZXZlbnQgaW5zdGVhZCBvZiBhIGNsaWNrIGV2ZW50LlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgZWFybGllciB2ZXJzaW9ucyBvZiBpT1Mgc3VwcG9ydGVkIGB0b3VjaHN0YXJ0YCBmb3IgdGhpcywgYnV0IGlPUzkgcmVtb3ZlZCB0aGlzIGZ1bmN0aW9uYWxpdHkuIEFkZGluZ1xuXHQgKiBhIGB0b3VjaHN0YXJ0YCBldmVudCB0byBzdXBwb3J0IG9sZGVyIHBsYXRmb3JtcyBtYXkgcHJlY2x1ZGUgYSBgbW91c2Vkb3duYCBldmVuIGZyb20gZ2V0dGluZyBmaXJlZCBvbiBpT1M5LCBzbyB3ZVxuXHQgKiBzdGljayB3aXRoIGBtb3VzZWRvd25gIGFuZCBgdG91Y2hlbmRgLlxuXHQgKiBAbWV0aG9kIF91bmxvY2tcblx0ICogQHNpbmNlIDAuNi4yXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzLl91bmxvY2sgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAocy5fdW5sb2NrZWQpIHsgcmV0dXJuOyB9XG5cdFx0cy5wbGF5RW1wdHlTb3VuZCgpO1xuXHRcdGlmIChzLmNvbnRleHQuc3RhdGUgPT0gXCJydW5uaW5nXCIpIHtcblx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgcy5fdW5sb2NrLCB0cnVlKTtcblx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBzLl91bmxvY2ssIHRydWUpO1xuXHRcdFx0cy5fdW5sb2NrZWQgPSB0cnVlO1xuXHRcdH1cblx0fTtcblxuXG4vLyBQdWJsaWMgTWV0aG9kc1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltXZWJBdWRpb1BsdWdpbl1cIjtcblx0fTtcblxuXG4vLyBQcml2YXRlIE1ldGhvZHNcblx0LyoqXG5cdCAqIFNldCB1cCBuZWVkZWQgcHJvcGVydGllcyBvbiBzdXBwb3J0ZWQgY2xhc3NlcyBXZWJBdWRpb1NvdW5kSW5zdGFuY2UgYW5kIFdlYkF1ZGlvTG9hZGVyLlxuXHQgKiBAbWV0aG9kIF9hZGRQcm9wc1RvQ2xhc3Nlc1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl9hZGRQcm9wc1RvQ2xhc3NlcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjID0gdGhpcy5fc291bmRJbnN0YW5jZUNsYXNzO1xuXHRcdGMuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblx0XHRjLl9zY3JhdGNoQnVmZmVyID0gcy5fc2NyYXRjaEJ1ZmZlcjtcblx0XHRjLmRlc3RpbmF0aW9uTm9kZSA9IHRoaXMuZ2Fpbk5vZGU7XG5cdFx0Yy5fcGFubmluZ01vZGVsID0gdGhpcy5fcGFubmluZ01vZGVsO1xuXG5cdFx0dGhpcy5fbG9hZGVyQ2xhc3MuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGdhaW4gdmFsdWUgZm9yIG1hc3RlciBhdWRpby4gU2hvdWxkIG5vdCBiZSBjYWxsZWQgZXh0ZXJuYWxseS5cblx0ICogQG1ldGhvZCBfdXBkYXRlVm9sdW1lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3VwZGF0ZVZvbHVtZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbmV3Vm9sdW1lID0gY3JlYXRlanMuU291bmQuX21hc3Rlck11dGUgPyAwIDogdGhpcy5fdm9sdW1lO1xuXHRcdGlmIChuZXdWb2x1bWUgIT0gdGhpcy5nYWluTm9kZS5nYWluLnZhbHVlKSB7XG5cdFx0XHR0aGlzLmdhaW5Ob2RlLmdhaW4udmFsdWUgPSBuZXdWb2x1bWU7XG5cdFx0fVxuXHR9O1xuXG5cdGNyZWF0ZWpzLldlYkF1ZGlvUGx1Z2luID0gY3JlYXRlanMucHJvbW90ZShXZWJBdWRpb1BsdWdpbiwgXCJBYnN0cmFjdFBsdWdpblwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBIVE1MQXVkaW9UYWdQb29sLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogSFRNTEF1ZGlvVGFnUG9vbCBpcyBhbiBvYmplY3QgcG9vbCBmb3IgSFRNTEF1ZGlvIHRhZyBpbnN0YW5jZXMuXG5cdCAqIEBjbGFzcyBIVE1MQXVkaW9UYWdQb29sXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBvZiB0aGUgY2hhbm5lbC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0ZnVuY3Rpb24gSFRNTEF1ZGlvVGFnUG9vbCgpIHtcblx0XHRcdHRocm93IFwiSFRNTEF1ZGlvVGFnUG9vbCBjYW5ub3QgYmUgaW5zdGFudGlhdGVkXCI7XG5cdH1cblxuXHR2YXIgcyA9IEhUTUxBdWRpb1RhZ1Bvb2w7XG5cbi8vIFN0YXRpYyBQcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBBIGhhc2ggbG9va3VwIG9mIGVhY2ggYmFzZSBhdWRpbyB0YWcsIGluZGV4ZWQgYnkgdGhlIGF1ZGlvIHNvdXJjZS5cblx0ICogQHByb3BlcnR5IF90YWdzXG5cdCAqIEB0eXBlIHt7fX1cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzLl90YWdzID0ge307XG5cblx0LyoqXG5cdCAqIEFuIG9iamVjdCBwb29sIGZvciBodG1sIGF1ZGlvIHRhZ3Ncblx0ICogQHByb3BlcnR5IF90YWdQb29sXG5cdCAqIEB0eXBlIHtUYWdQb29sfVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHMuX3RhZ1Bvb2wgPSBuZXcgVGFnUG9vbCgpO1xuXG5cdC8qKlxuXHQgKiBBIGhhc2ggbG9va3VwIG9mIGlmIGEgYmFzZSBhdWRpbyB0YWcgaXMgYXZhaWxhYmxlLCBpbmRleGVkIGJ5IHRoZSBhdWRpbyBzb3VyY2Vcblx0ICogQHByb3BlcnR5IF90YWdzVXNlZFxuXHQgKiBAdHlwZSB7e319XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5fdGFnVXNlZCA9IHt9O1xuXG4vLyBTdGF0aWMgTWV0aG9kc1xuXHQvKipcblx0ICAqIEdldCBhbiBhdWRpbyB0YWcgd2l0aCB0aGUgZ2l2ZW4gc291cmNlLlxuXHQgICogQG1ldGhvZCBnZXRcblx0ICAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBmaWxlIHVzZWQgYnkgdGhlIGF1ZGlvIHRhZy5cblx0ICAqIEBzdGF0aWNcblx0ICAqL1xuXHQgcy5nZXQgPSBmdW5jdGlvbiAoc3JjKSB7XG5cdFx0dmFyIHQgPSBzLl90YWdzW3NyY107XG5cdFx0aWYgKHQgPT0gbnVsbCkge1xuXHRcdFx0Ly8gY3JlYXRlIG5ldyBiYXNlIHRhZ1xuXHRcdFx0dCA9IHMuX3RhZ3Nbc3JjXSA9IHMuX3RhZ1Bvb2wuZ2V0KCk7XG5cdFx0XHR0LnNyYyA9IHNyYztcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gZ2V0IGJhc2Ugb3IgcG9vbFxuXHRcdFx0aWYgKHMuX3RhZ1VzZWRbc3JjXSkge1xuXHRcdFx0XHR0ID0gcy5fdGFnUG9vbC5nZXQoKTtcblx0XHRcdFx0dC5zcmMgPSBzcmM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzLl90YWdVc2VkW3NyY10gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdDtcblx0IH07XG5cblx0IC8qKlxuXHQgICogUmV0dXJuIGFuIGF1ZGlvIHRhZyB0byB0aGUgcG9vbC5cblx0ICAqIEBtZXRob2Qgc2V0XG5cdCAgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VyY2UgZmlsZSB1c2VkIGJ5IHRoZSBhdWRpbyB0YWcuXG5cdCAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YWcgQXVkaW8gdGFnIHRvIHNldC5cblx0ICAqIEBzdGF0aWNcblx0ICAqL1xuXHQgcy5zZXQgPSBmdW5jdGlvbiAoc3JjLCB0YWcpIHtcblx0XHQgLy8gY2hlY2sgaWYgdGhpcyBpcyBiYXNlLCBpZiB5ZXMgc2V0IGJvb2xlYW4gaWYgbm90IHJldHVybiB0byBwb29sXG5cdFx0IGlmKHRhZyA9PSBzLl90YWdzW3NyY10pIHtcblx0XHRcdCBzLl90YWdVc2VkW3NyY10gPSBmYWxzZTtcblx0XHQgfSBlbHNlIHtcblx0XHRcdCBzLl90YWdQb29sLnNldCh0YWcpO1xuXHRcdCB9XG5cdCB9O1xuXG5cdC8qKlxuXHQgKiBEZWxldGUgc3RvcmVkIHRhZyByZWZlcmVuY2UgYW5kIHJldHVybiB0aGVtIHRvIHBvb2wuIE5vdGUgdGhhdCBpZiB0aGUgdGFnIHJlZmVyZW5jZSBkb2VzIG5vdCBleGlzdCwgdGhpcyB3aWxsIGZhaWwuXG5cdCAqIEBtZXRob2QgcmVtb3ZlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBmb3IgdGhlIHRhZ1xuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgVGFnUG9vbCB3YXMgZGVsZXRlZC5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5yZW1vdmUgPSBmdW5jdGlvbiAoc3JjKSB7XG5cdFx0dmFyIHRhZyA9IHMuX3RhZ3Nbc3JjXTtcblx0XHRpZiAodGFnID09IG51bGwpIHtyZXR1cm4gZmFsc2U7fVxuXHRcdHMuX3RhZ1Bvb2wuc2V0KHRhZyk7XG5cdFx0ZGVsZXRlKHMuX3RhZ3Nbc3JjXSk7XG5cdFx0ZGVsZXRlKHMuX3RhZ1VzZWRbc3JjXSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGR1cmF0aW9uIG9mIHRoZSBzcmMgYXVkaW8gaW4gbWlsbGlzZWNvbmRzXG5cdCAqIEBtZXRob2QgZ2V0RHVyYXRpb25cblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291cmNlIGZpbGUgdXNlZCBieSB0aGUgYXVkaW8gdGFnLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IER1cmF0aW9uIG9mIHNyYyBpbiBtaWxsaXNlY29uZHNcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5nZXREdXJhdGlvbj0gZnVuY3Rpb24gKHNyYykge1xuXHRcdHZhciB0ID0gcy5fdGFnc1tzcmNdO1xuXHRcdGlmICh0ID09IG51bGwgfHwgIXQuZHVyYXRpb24pIHtyZXR1cm4gMDt9XHQvLyBPSlIgZHVyYXRpb24gaXMgTmFOIGlmIGxvYWRpbmcgaGFzIG5vdCBjb21wbGV0ZWRcblx0XHRyZXR1cm4gdC5kdXJhdGlvbiAqIDEwMDA7XG5cdH07XG5cblx0Y3JlYXRlanMuSFRNTEF1ZGlvVGFnUG9vbCA9IEhUTUxBdWRpb1RhZ1Bvb2w7XG5cblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdC8qKlxuXHQgKiBUaGUgVGFnUG9vbCBpcyBhbiBvYmplY3QgcG9vbCBmb3IgSFRNTEF1ZGlvIHRhZyBpbnN0YW5jZXMuXG5cdCAqICNjbGFzcyBUYWdQb29sXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBvZiB0aGUgY2hhbm5lbC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0ZnVuY3Rpb24gVGFnUG9vbChzcmMpIHtcblxuLy8gUHVibGljIFByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBBIGxpc3Qgb2YgYWxsIGF2YWlsYWJsZSB0YWdzIGluIHRoZSBwb29sLlxuXHRcdCAqICNwcm9wZXJ0eSB0YWdzXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl90YWdzID0gW107XG5cdH07XG5cblx0dmFyIHAgPSBUYWdQb29sLnByb3RvdHlwZTtcblx0cC5jb25zdHJ1Y3RvciA9IFRhZ1Bvb2w7XG5cblxuLy8gUHVibGljIE1ldGhvZHNcblx0LyoqXG5cdCAqIEdldCBhbiBIVE1MQXVkaW9FbGVtZW50IGZvciBpbW1lZGlhdGUgcGxheWJhY2suIFRoaXMgdGFrZXMgaXQgb3V0IG9mIHRoZSBwb29sLlxuXHQgKiAjbWV0aG9kIGdldFxuXHQgKiBAcmV0dXJuIHtIVE1MQXVkaW9FbGVtZW50fSBBbiBIVE1MIGF1ZGlvIHRhZy5cblx0ICovXG5cdHAuZ2V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0YWc7XG5cdFx0aWYgKHRoaXMuX3RhZ3MubGVuZ3RoID09IDApIHtcblx0XHRcdHRhZyA9IHRoaXMuX2NyZWF0ZVRhZygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YWcgPSB0aGlzLl90YWdzLnBvcCgpO1xuXHRcdH1cblx0XHRpZiAodGFnLnBhcmVudE5vZGUgPT0gbnVsbCkge2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGFnKTt9XG5cdFx0cmV0dXJuIHRhZztcblx0fTtcblxuXHQvKipcblx0ICogUHV0IGFuIEhUTUxBdWRpb0VsZW1lbnQgYmFjayBpbiB0aGUgcG9vbCBmb3IgdXNlLlxuXHQgKiAjbWV0aG9kIHNldFxuXHQgKiBAcGFyYW0ge0hUTUxBdWRpb0VsZW1lbnR9IHRhZyBIVE1MIGF1ZGlvIHRhZ1xuXHQgKi9cblx0cC5zZXQgPSBmdW5jdGlvbiAodGFnKSB7XG5cdFx0Ly8gT0pSIHRoaXMgZmlyc3Qgc3RlcCBzZWVtcyB1bm5lY2Vzc2FyeVxuXHRcdHZhciBpbmRleCA9IGNyZWF0ZWpzLmluZGV4T2YodGhpcy5fdGFncywgdGFnKTtcblx0XHRpZiAoaW5kZXggPT0gLTEpIHtcblx0XHRcdHRoaXMuX3RhZ3Muc3JjID0gbnVsbDtcblx0XHRcdHRoaXMuX3RhZ3MucHVzaCh0YWcpO1xuXHRcdH1cblx0fTtcblxuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltUYWdQb29sXVwiO1xuXHR9O1xuXG5cbi8vIFByaXZhdGUgTWV0aG9kc1xuXHQvKipcblx0ICogQ3JlYXRlIGFuIEhUTUwgYXVkaW8gdGFnLlxuXHQgKiAjbWV0aG9kIF9jcmVhdGVUYWdcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291cmNlIGZpbGUgdG8gc2V0IGZvciB0aGUgYXVkaW8gdGFnLlxuXHQgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gUmV0dXJucyBhbiBIVE1MIGF1ZGlvIHRhZy5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fY3JlYXRlVGFnID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYXVkaW9cIik7XG5cdFx0dGFnLmF1dG9wbGF5ID0gZmFsc2U7XG5cdFx0dGFnLnByZWxvYWQgPSBcIm5vbmVcIjtcblx0XHQvL0xNOiBGaXJlZm94IGZhaWxzIHdoZW4gdGhpcyB0aGUgcHJlbG9hZD1cIm5vbmVcIiBmb3Igb3RoZXIgdGFncywgYnV0IGl0IG5lZWRzIHRvIGJlIFwibm9uZVwiIHRvIGVuc3VyZSBQcmVsb2FkSlMgd29ya3MuXG5cdFx0cmV0dXJuIHRhZztcblx0fTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEhUTUxBdWRpb1NvdW5kSW5zdGFuY2UuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBIVE1MQXVkaW9Tb3VuZEluc3RhbmNlIGV4dGVuZHMgdGhlIGJhc2UgYXBpIG9mIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fSBhbmQgaXMgdXNlZCBieVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJIVE1MQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHBhdGggdG8gYW5kIGZpbGUgbmFtZSBvZiB0aGUgc291bmQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFRpbWUgQXVkaW8gc3ByaXRlIHByb3BlcnR5IHVzZWQgdG8gYXBwbHkgYW4gb2Zmc2V0LCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBBdWRpbyBzcHJpdGUgcHJvcGVydHkgdXNlZCB0byBzZXQgdGhlIHRpbWUgdGhlIGNsaXAgcGxheXMgZm9yLCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5YmFja1Jlc291cmNlIEFueSByZXNvdXJjZSBuZWVkZWQgYnkgcGx1Z2luIHRvIHN1cHBvcnQgYXVkaW8gcGxheWJhY2suXG5cdCAqIEBjbGFzcyBIVE1MQXVkaW9Tb3VuZEluc3RhbmNlXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0U291bmRJbnN0YW5jZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEhUTUxBdWRpb1NvdW5kSW5zdGFuY2Uoc3JjLCBzdGFydFRpbWUsIGR1cmF0aW9uLCBwbGF5YmFja1Jlc291cmNlKSB7XG5cdFx0dGhpcy5BYnN0cmFjdFNvdW5kSW5zdGFuY2VfY29uc3RydWN0b3Ioc3JjLCBzdGFydFRpbWUsIGR1cmF0aW9uLCBwbGF5YmFja1Jlc291cmNlKTtcblxuXG4vLyBQcml2YXRlIFByb3BlcnRpZXNcblx0XHR0aGlzLl9hdWRpb1Nwcml0ZVN0b3BUaW1lID0gbnVsbDtcblx0XHR0aGlzLl9kZWxheVRpbWVvdXRJZCA9IG51bGw7XG5cblx0XHQvLyBQcm94aWVzLCBtYWtlIHJlbW92aW5nIGxpc3RlbmVycyBlYXNpZXIuXG5cdFx0dGhpcy5fZW5kZWRIYW5kbGVyID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlU291bmRDb21wbGV0ZSwgdGhpcyk7XG5cdFx0dGhpcy5fcmVhZHlIYW5kbGVyID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlVGFnUmVhZHksIHRoaXMpO1xuXHRcdHRoaXMuX3N0YWxsZWRIYW5kbGVyID0gY3JlYXRlanMucHJveHkodGhpcy5fcGxheUZhaWxlZCwgdGhpcyk7XG5cdFx0dGhpcy5fYXVkaW9TcHJpdGVFbmRIYW5kbGVyID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlQXVkaW9TcHJpdGVMb29wLCB0aGlzKTtcblx0XHR0aGlzLl9sb29wSGFuZGxlciA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVNvdW5kQ29tcGxldGUsIHRoaXMpO1xuXG5cdFx0aWYgKGR1cmF0aW9uKSB7XG5cdFx0XHR0aGlzLl9hdWRpb1Nwcml0ZVN0b3BUaW1lID0gKHN0YXJ0VGltZSArIGR1cmF0aW9uKSAqIDAuMDAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9kdXJhdGlvbiA9IGNyZWF0ZWpzLkhUTUxBdWRpb1RhZ1Bvb2wuZ2V0RHVyYXRpb24odGhpcy5zcmMpO1xuXHRcdH1cblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChIVE1MQXVkaW9Tb3VuZEluc3RhbmNlLCBjcmVhdGVqcy5BYnN0cmFjdFNvdW5kSW5zdGFuY2UpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cbi8vIFB1YmxpYyBNZXRob2RzXG5cdC8qKlxuXHQgKiBDYWxsZWQgYnkge3sjY3Jvc3NMaW5rIFwiU291bmRcIn19e3svY3Jvc3NMaW5rfX0gd2hlbiBwbHVnaW4gZG9lcyBub3QgaGFuZGxlIG1hc3RlciB2b2x1bWUuXG5cdCAqIHVuZG9jJ2QgYmVjYXVzZSBpdCBpcyBub3QgbWVhbnQgdG8gYmUgdXNlZCBvdXRzaWRlIG9mIFNvdW5kXG5cdCAqICNtZXRob2Qgc2V0TWFzdGVyVm9sdW1lXG5cdCAqIEBwYXJhbSB2YWx1ZVxuXHQgKi9cblx0cC5zZXRNYXN0ZXJWb2x1bWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR0aGlzLl91cGRhdGVWb2x1bWUoKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIGJ5IHt7I2Nyb3NzTGluayBcIlNvdW5kXCJ9fXt7L2Nyb3NzTGlua319IHdoZW4gcGx1Z2luIGRvZXMgbm90IGhhbmRsZSBtYXN0ZXIgbXV0ZS5cblx0ICogdW5kb2MnZCBiZWNhdXNlIGl0IGlzIG5vdCBtZWFudCB0byBiZSB1c2VkIG91dHNpZGUgb2YgU291bmRcblx0ICogI21ldGhvZCBzZXRNYXN0ZXJNdXRlXG5cdCAqIEBwYXJhbSB2YWx1ZVxuXHQgKi9cblx0cC5zZXRNYXN0ZXJNdXRlID0gZnVuY3Rpb24gKGlzTXV0ZWQpIHtcblx0XHR0aGlzLl91cGRhdGVWb2x1bWUoKTtcblx0fTtcblxuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltIVE1MQXVkaW9Tb3VuZEluc3RhbmNlXVwiO1xuXHR9O1xuXG4vL1ByaXZhdGUgTWV0aG9kc1xuXHRwLl9yZW1vdmVMb29waW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYodGhpcy5fcGxheWJhY2tSZXNvdXJjZSA9PSBudWxsKSB7cmV0dXJuO31cblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLmxvb3AgPSBmYWxzZTtcblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19TRUVLRUQsIHRoaXMuX2xvb3BIYW5kbGVyLCBmYWxzZSk7XG5cdH07XG5cblx0cC5fYWRkTG9vcGluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmKHRoaXMuX3BsYXliYWNrUmVzb3VyY2UgPT0gbnVsbCAgfHwgdGhpcy5fYXVkaW9TcHJpdGVTdG9wVGltZSkge3JldHVybjt9XG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5hZGRFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fU0VFS0VELCB0aGlzLl9sb29wSGFuZGxlciwgZmFsc2UpO1xuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UubG9vcCA9IHRydWU7XG5cdH07XG5cblx0cC5faGFuZGxlQ2xlYW5VcCA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdGFnID0gdGhpcy5fcGxheWJhY2tSZXNvdXJjZTtcblx0XHRpZiAodGFnICE9IG51bGwpIHtcblx0XHRcdHRhZy5wYXVzZSgpO1xuXHRcdFx0dGFnLmxvb3AgPSBmYWxzZTtcblx0XHRcdHRhZy5yZW1vdmVFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fRU5ERUQsIHRoaXMuX2VuZGVkSGFuZGxlciwgZmFsc2UpO1xuXHRcdFx0dGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19SRUFEWSwgdGhpcy5fcmVhZHlIYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHR0YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX1NUQUxMRUQsIHRoaXMuX3N0YWxsZWRIYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHR0YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX1NFRUtFRCwgdGhpcy5fbG9vcEhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdHRhZy5yZW1vdmVFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fVElNRV9VUERBVEUsIHRoaXMuX2F1ZGlvU3ByaXRlRW5kSGFuZGxlciwgZmFsc2UpO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0YWcuY3VycmVudFRpbWUgPSB0aGlzLl9zdGFydFRpbWU7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHR9IC8vIFJlc2V0IFBvc2l0aW9uXG5cdFx0XHRjcmVhdGVqcy5IVE1MQXVkaW9UYWdQb29sLnNldCh0aGlzLnNyYywgdGFnKTtcblx0XHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UgPSBudWxsO1xuXHRcdH1cblx0fTtcblxuXHRwLl9iZWdpblBsYXlpbmcgPSBmdW5jdGlvbiAocGxheVByb3BzKSB7XG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZSA9IGNyZWF0ZWpzLkhUTUxBdWRpb1RhZ1Bvb2wuZ2V0KHRoaXMuc3JjKTtcblx0XHRyZXR1cm4gdGhpcy5BYnN0cmFjdFNvdW5kSW5zdGFuY2VfX2JlZ2luUGxheWluZyhwbGF5UHJvcHMpO1xuXHR9O1xuXG5cdHAuX2hhbmRsZVNvdW5kUmVhZHkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRpZiAodGhpcy5fcGxheWJhY2tSZXNvdXJjZS5yZWFkeVN0YXRlICE9PSA0KSB7XG5cdFx0XHR2YXIgdGFnID0gdGhpcy5fcGxheWJhY2tSZXNvdXJjZTtcblx0XHRcdHRhZy5hZGRFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fUkVBRFksIHRoaXMuX3JlYWR5SGFuZGxlciwgZmFsc2UpO1xuXHRcdFx0dGFnLmFkZEV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19TVEFMTEVELCB0aGlzLl9zdGFsbGVkSGFuZGxlciwgZmFsc2UpO1xuXHRcdFx0dGFnLnByZWxvYWQgPSBcImF1dG9cIjsgLy8gVGhpcyBpcyBuZWNlc3NhcnkgZm9yIEZpcmVmb3gsIGFzIGl0IHdvbid0IGV2ZXIgXCJsb2FkXCIgdW50aWwgdGhpcyBpcyBzZXQuXG5cdFx0XHR0YWcubG9hZCgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZVZvbHVtZSgpO1xuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UuY3VycmVudFRpbWUgPSAodGhpcy5fc3RhcnRUaW1lICsgdGhpcy5fcG9zaXRpb24pICogMC4wMDE7XG5cdFx0aWYgKHRoaXMuX2F1ZGlvU3ByaXRlU3RvcFRpbWUpIHtcblx0XHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX1RJTUVfVVBEQVRFLCB0aGlzLl9hdWRpb1Nwcml0ZUVuZEhhbmRsZXIsIGZhbHNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5hZGRFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fRU5ERUQsIHRoaXMuX2VuZGVkSGFuZGxlciwgZmFsc2UpO1xuXHRcdFx0aWYodGhpcy5fbG9vcCAhPSAwKSB7XG5cdFx0XHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX1NFRUtFRCwgdGhpcy5fbG9vcEhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5sb29wID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLnBsYXkoKTtcblx0fTtcblxuXHQvKipcblx0ICogVXNlZCB0byBoYW5kbGUgd2hlbiBhIHRhZyBpcyBub3QgcmVhZHkgZm9yIGltbWVkaWF0ZSBwbGF5YmFjayB3aGVuIGl0IGlzIHJldHVybmVkIGZyb20gdGhlIEhUTUxBdWRpb1RhZ1Bvb2wuXG5cdCAqIEBtZXRob2QgX2hhbmRsZVRhZ1JlYWR5XG5cdCAqIEBwYXJhbSBldmVudFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9oYW5kbGVUYWdSZWFkeSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX1JFQURZLCB0aGlzLl9yZWFkeUhhbmRsZXIsIGZhbHNlKTtcblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19TVEFMTEVELCB0aGlzLl9zdGFsbGVkSGFuZGxlciwgZmFsc2UpO1xuXG5cdFx0dGhpcy5faGFuZGxlU291bmRSZWFkeSgpO1xuXHR9O1xuXG5cdHAuX3BhdXNlID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UucGF1c2UoKTtcblx0fTtcblxuXHRwLl9yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5wbGF5KCk7XG5cdH07XG5cblx0cC5fdXBkYXRlVm9sdW1lID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9wbGF5YmFja1Jlc291cmNlICE9IG51bGwpIHtcblx0XHRcdHZhciBuZXdWb2x1bWUgPSAodGhpcy5fbXV0ZWQgfHwgY3JlYXRlanMuU291bmQuX21hc3Rlck11dGUpID8gMCA6IHRoaXMuX3ZvbHVtZSAqIGNyZWF0ZWpzLlNvdW5kLl9tYXN0ZXJWb2x1bWU7XG5cdFx0XHRpZiAobmV3Vm9sdW1lICE9IHRoaXMuX3BsYXliYWNrUmVzb3VyY2Uudm9sdW1lKSB7dGhpcy5fcGxheWJhY2tSZXNvdXJjZS52b2x1bWUgPSBuZXdWb2x1bWU7fVxuXHRcdH1cblx0fTtcblxuXHRwLl9jYWxjdWxhdGVDdXJyZW50UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKHRoaXMuX3BsYXliYWNrUmVzb3VyY2UuY3VycmVudFRpbWUgKiAxMDAwKSAtIHRoaXMuX3N0YXJ0VGltZTtcblx0fTtcblxuXHRwLl91cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX1NFRUtFRCwgdGhpcy5fbG9vcEhhbmRsZXIsIGZhbHNlKTtcblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19TRUVLRUQsIHRoaXMuX2hhbmRsZVNldFBvc2l0aW9uU2VlaywgZmFsc2UpO1xuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLmN1cnJlbnRUaW1lID0gKHRoaXMuX3Bvc2l0aW9uICsgdGhpcy5fc3RhcnRUaW1lKSAqIDAuMDAxO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7IC8vIE91dCBvZiByYW5nZVxuXHRcdFx0dGhpcy5faGFuZGxlU2V0UG9zaXRpb25TZWVrKG51bGwpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVXNlZCB0byBlbmFibGUgc2V0dGluZyBwb3NpdGlvbiwgYXMgd2UgbmVlZCB0byB3YWl0IGZvciB0aGF0IHNlZWsgdG8gYmUgZG9uZSBiZWZvcmUgd2UgYWRkIGJhY2sgb3VyIGxvb3AgaGFuZGxpbmcgc2VlayBsaXN0ZW5lclxuXHQgKiBAbWV0aG9kIF9oYW5kbGVTZXRQb3NpdGlvblNlZWtcblx0ICogQHBhcmFtIGV2ZW50XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2hhbmRsZVNldFBvc2l0aW9uU2VlayA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuX3BsYXliYWNrUmVzb3VyY2UgPT0gbnVsbCkgeyByZXR1cm47IH1cblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19TRUVLRUQsIHRoaXMuX2hhbmRsZVNldFBvc2l0aW9uU2VlaywgZmFsc2UpO1xuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX1NFRUtFRCwgdGhpcy5fbG9vcEhhbmRsZXIsIGZhbHNlKTtcblx0fTtcblxuXHQvKipcblx0ICogVGltZXIgdXNlZCB0byBsb29wIGF1ZGlvIHNwcml0ZXMuXG5cdCAqIE5PVEUgYmVjYXVzZSBvZiB0aGUgaW5hY2N1cmFjaWVzIGluIHRoZSB0aW1ldXBkYXRlIGV2ZW50ICgxNSAtIDI1MG1zKSBhbmQgaW4gc2V0dGluZyB0aGUgdGFnIHRvIHRoZSBkZXNpcmVkIHRpbWVkXG5cdCAqICh1cCB0byAzMDBtcyksIGl0IGlzIHN0cm9uZ2x5IHJlY29tbWVuZGVkIG5vdCB0byBsb29wIGF1ZGlvIHNwcml0ZXMgd2l0aCBIVE1MIEF1ZGlvIGlmIHNtb290aCBsb29waW5nIGlzIGRlc2lyZWRcblx0ICpcblx0ICogQG1ldGhvZCBfaGFuZGxlQXVkaW9TcHJpdGVMb29wXG5cdCAqIEBwYXJhbSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlQXVkaW9TcHJpdGVMb29wID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYodGhpcy5fcGxheWJhY2tSZXNvdXJjZS5jdXJyZW50VGltZSA8PSB0aGlzLl9hdWRpb1Nwcml0ZVN0b3BUaW1lKSB7cmV0dXJuO31cblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLnBhdXNlKCk7XG5cdFx0aWYodGhpcy5fbG9vcCA9PSAwKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVTb3VuZENvbXBsZXRlKG51bGwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbiA9IDA7XG5cdFx0XHR0aGlzLl9sb29wLS07XG5cdFx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLmN1cnJlbnRUaW1lID0gdGhpcy5fc3RhcnRUaW1lICogMC4wMDE7XG5cdFx0XHRpZighdGhpcy5fcGF1c2VkKSB7dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5wbGF5KCk7fVxuXHRcdFx0dGhpcy5fc2VuZEV2ZW50KFwibG9vcFwiKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gTk9URSB3aXRoIHRoaXMgYXBwcm9hY2ggYXVkaW8gd2lsbCBsb29wIGFzIHJlbGlhYmx5IGFzIHRoZSBicm93c2VyIGFsbG93c1xuXHQvLyBidXQgd2UgY291bGQgZW5kIHVwIHNlbmRpbmcgdGhlIGxvb3AgZXZlbnQgYWZ0ZXIgbmV4dCBsb29wIHBsYXliYWNrIGJlZ2luc1xuXHRwLl9oYW5kbGVMb29wID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYodGhpcy5fbG9vcCA9PSAwKSB7XG5cdFx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLmxvb3AgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX1NFRUtFRCwgdGhpcy5fbG9vcEhhbmRsZXIsIGZhbHNlKTtcblx0XHR9XG5cdH07XG5cblx0cC5fdXBkYXRlU3RhcnRUaW1lID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2F1ZGlvU3ByaXRlU3RvcFRpbWUgPSAodGhpcy5fc3RhcnRUaW1lICsgdGhpcy5fZHVyYXRpb24pICogMC4wMDE7XG5cblx0XHRpZih0aGlzLnBsYXlTdGF0ZSA9PSBjcmVhdGVqcy5Tb3VuZC5QTEFZX1NVQ0NFRURFRCkge1xuXHRcdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fRU5ERUQsIHRoaXMuX2VuZGVkSGFuZGxlciwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5hZGRFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fVElNRV9VUERBVEUsIHRoaXMuX2F1ZGlvU3ByaXRlRW5kSGFuZGxlciwgZmFsc2UpO1xuXHRcdH1cblx0fTtcblxuXHRwLl91cGRhdGVEdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9hdWRpb1Nwcml0ZVN0b3BUaW1lID0gKHRoaXMuX3N0YXJ0VGltZSArIHRoaXMuX2R1cmF0aW9uKSAqIDAuMDAxO1xuXG5cdFx0aWYodGhpcy5wbGF5U3RhdGUgPT0gY3JlYXRlanMuU291bmQuUExBWV9TVUNDRUVERUQpIHtcblx0XHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX0VOREVELCB0aGlzLl9lbmRlZEhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX1RJTUVfVVBEQVRFLCB0aGlzLl9hdWRpb1Nwcml0ZUVuZEhhbmRsZXIsIGZhbHNlKTtcblx0XHR9XG5cdH07XG5cblx0cC5fc2V0RHVyYXRpb25Gcm9tU291cmNlID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gY3JlYXRlanMuSFRNTEF1ZGlvVGFnUG9vbC5nZXREdXJhdGlvbih0aGlzLnNyYyk7XG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZSA9IG51bGw7XG5cdH07XG5cblx0Y3JlYXRlanMuSFRNTEF1ZGlvU291bmRJbnN0YW5jZSA9IGNyZWF0ZWpzLnByb21vdGUoSFRNTEF1ZGlvU291bmRJbnN0YW5jZSwgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2VcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gSFRNTEF1ZGlvUGx1Z2luLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBQbGF5IHNvdW5kcyB1c2luZyBIVE1MICZsdDthdWRpbyZndDsgdGFncyBpbiB0aGUgYnJvd3Nlci4gVGhpcyBwbHVnaW4gaXMgdGhlIHNlY29uZCBwcmlvcml0eSBwbHVnaW4gaW5zdGFsbGVkXG5cdCAqIGJ5IGRlZmF1bHQsIGFmdGVyIHRoZSB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fS4gIEZvciBvbGRlciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGh0bWxcblx0ICogYXVkaW8sIGluY2x1ZGUgYW5kIGluc3RhbGwgdGhlIHt7I2Nyb3NzTGluayBcIkZsYXNoQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIDxoND5Lbm93biBCcm93c2VyIGFuZCBPUyBpc3N1ZXMgZm9yIEhUTUwgQXVkaW88L2g0PlxuXHQgKiA8Yj5BbGwgYnJvd3NlcnM8L2I+PGJyIC8+XG5cdCAqIFRlc3RpbmcgaGFzIHNob3duIGluIGFsbCBicm93c2VycyB0aGVyZSBpcyBhIGxpbWl0IHRvIGhvdyBtYW55IGF1ZGlvIHRhZyBpbnN0YW5jZXMgeW91IGFyZSBhbGxvd2VkLiAgSWYgeW91IGV4Y2VlZFxuXHQgKiB0aGlzIGxpbWl0LCB5b3UgY2FuIGV4cGVjdCB0byBzZWUgdW5wcmVkaWN0YWJsZSByZXN1bHRzLiBQbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIlNvdW5kLk1BWF9JTlNUQU5DRVNcIn19e3svY3Jvc3NMaW5rfX0gYXNcblx0ICogYSBndWlkZSB0byBob3cgbWFueSB0b3RhbCBhdWRpbyB0YWdzIHlvdSBjYW4gc2FmZWx5IHVzZSBpbiBhbGwgYnJvd3NlcnMuICBUaGlzIGlzc3VlIGlzIHByaW1hcmlseSBsaW1pdGVkIHRvIElFOS5cblx0ICpcbiAgICAgKiA8Yj5JRSBodG1sIGxpbWl0YXRpb25zPC9iPjxiciAvPlxuICAgICAqIDx1bD48bGk+VGhlcmUgaXMgYSBkZWxheSBpbiBhcHBseWluZyB2b2x1bWUgY2hhbmdlcyB0byB0YWdzIHRoYXQgb2NjdXJzIG9uY2UgcGxheWJhY2sgaXMgc3RhcnRlZC4gU28gaWYgeW91IGhhdmVcbiAgICAgKiBtdXRlZCBhbGwgc291bmRzLCB0aGV5IHdpbGwgYWxsIHBsYXkgZHVyaW5nIHRoaXMgZGVsYXkgdW50aWwgdGhlIG11dGUgYXBwbGllcyBpbnRlcm5hbGx5LiBUaGlzIGhhcHBlbnMgcmVnYXJkbGVzcyBvZlxuICAgICAqIHdoZW4gb3IgaG93IHlvdSBhcHBseSB0aGUgdm9sdW1lIGNoYW5nZSwgYXMgdGhlIHRhZyBzZWVtcyB0byBuZWVkIHRvIHBsYXkgdG8gYXBwbHkgaXQuPC9saT5cbiAgICAgKiA8bGk+TVAzIGVuY29kaW5nIHdpbGwgbm90IGFsd2F5cyB3b3JrIGZvciBhdWRpbyB0YWdzIGlmIGl0J3Mgbm90IGRlZmF1bHQuICBXZSd2ZSBmb3VuZCBkZWZhdWx0IGVuY29kaW5nIHdpdGhcbiAgICAgKiA2NGticHMgd29ya3MuPC9saT5cblx0ICogPGxpPk9jY2FzaW9uYWxseSB2ZXJ5IHNob3J0IHNhbXBsZXMgd2lsbCBnZXQgY3V0IG9mZi48L2xpPlxuXHQgKiA8bGk+VGhlcmUgaXMgYSBsaW1pdCB0byBob3cgbWFueSBhdWRpbyB0YWdzIHlvdSBjYW4gbG9hZCBvciBwbGF5IGF0IG9uY2UsIHdoaWNoIGFwcGVhcnMgdG8gYmUgZGV0ZXJtaW5lZCBieVxuXHQgKiBoYXJkd2FyZSBhbmQgYnJvd3NlciBzZXR0aW5ncy4gIFNlZSB7eyNjcm9zc0xpbmsgXCJIVE1MQXVkaW9QbHVnaW4uTUFYX0lOU1RBTkNFU1wifX17ey9jcm9zc0xpbmt9fSBmb3IgYSBzYWZlIGVzdGltYXRlLlxuXHQgKiBOb3RlIHRoYXQgYXVkaW8gc3ByaXRlcyBjYW4gYmUgdXNlZCBhcyBhIHNvbHV0aW9uIHRvIHRoaXMgaXNzdWUuPC9saT48L3VsPlxuXHQgKlxuXHQgKiA8Yj5TYWZhcmkgbGltaXRhdGlvbnM8L2I+PGJyIC8+XG5cdCAqIDx1bD48bGk+U2FmYXJpIHJlcXVpcmVzIFF1aWNrdGltZSB0byBiZSBpbnN0YWxsZWQgZm9yIGF1ZGlvIHBsYXliYWNrLjwvbGk+PC91bD5cblx0ICpcblx0ICogPGI+aU9TIDYgbGltaXRhdGlvbnM8L2I+PGJyIC8+XG5cdCAqIDx1bD48bGk+Y2FuIG9ubHkgaGF2ZSBvbmUgJmx0O2F1ZGlvJmd0OyB0YWc8L2xpPlxuXHQgKiBcdFx0PGxpPmNhbiBub3QgcHJlbG9hZCBvciBhdXRvcGxheSB0aGUgYXVkaW88L2xpPlxuXHQgKiBcdFx0PGxpPmNhbiBub3QgY2FjaGUgdGhlIGF1ZGlvPC9saT5cblx0ICogXHRcdDxsaT5jYW4gbm90IHBsYXkgdGhlIGF1ZGlvIGV4Y2VwdCBpbnNpZGUgYSB1c2VyIGluaXRpYXRlZCBldmVudC48L2xpPlxuXHQgKlx0XHQ8bGk+Tm90ZSBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2Uge3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0gZm9yIGlPUyAoNispPC9saT5cblx0ICogXHRcdDxsaT5hdWRpbyBzcHJpdGVzIGNhbiBiZSB1c2VkIHRvIG1pdGlnYXRlIHNvbWUgb2YgdGhlc2UgaXNzdWVzIGFuZCBhcmUgc3Ryb25nbHkgcmVjb21tZW5kZWQgb24gaU9TPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogPGI+QW5kcm9pZCBOYXRpdmUgQnJvd3NlciBsaW1pdGF0aW9uczwvYj48YnIgLz5cblx0ICogPHVsPjxsaT5XZSBoYXZlIG5vIGNvbnRyb2wgb3ZlciBhdWRpbyB2b2x1bWUuIE9ubHkgdGhlIHVzZXIgY2FuIHNldCB2b2x1bWUgb24gdGhlaXIgZGV2aWNlLjwvbGk+XG5cdCAqICAgICAgPGxpPldlIGNhbiBvbmx5IHBsYXkgYXVkaW8gaW5zaWRlIGEgdXNlciBldmVudCAodG91Y2gvY2xpY2spLiAgVGhpcyBjdXJyZW50bHkgbWVhbnMgeW91IGNhbm5vdCBsb29wIHNvdW5kIG9yIHVzZSBhIGRlbGF5LjwvbGk+PC91bD5cblx0ICogPGI+IEFuZHJvaWQgQ2hyb21lIDI2LjAuMTQxMC41OCBzcGVjaWZpYyBsaW1pdGF0aW9uczwvYj48YnIgLz5cblx0ICogPHVsPiA8bGk+Q2FuIG9ubHkgcGxheSAxIHNvdW5kIGF0IGEgdGltZS48L2xpPlxuXHQgKiAgICAgIDxsaT5Tb3VuZCBpcyBub3QgY2FjaGVkLjwvbGk+XG5cdCAqICAgICAgPGxpPlNvdW5kIGNhbiBvbmx5IGJlIGxvYWRlZCBpbiBhIHVzZXIgaW5pdGlhdGVkIHRvdWNoL2NsaWNrIGV2ZW50LjwvbGk+XG5cdCAqICAgICAgPGxpPlRoZXJlIGlzIGEgZGVsYXkgYmVmb3JlIGEgc291bmQgaXMgcGxheWVkLCBwcmVzdW1hYmx5IHdoaWxlIHRoZSBzcmMgaXMgbG9hZGVkLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJTb3VuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgZ2VuZXJhbCBub3RlcyBvbiBrbm93biBpc3N1ZXMuXG5cdCAqXG5cdCAqIEBjbGFzcyBIVE1MQXVkaW9QbHVnaW5cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RQbHVnaW5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBIVE1MQXVkaW9QbHVnaW4oKSB7XG5cdFx0dGhpcy5BYnN0cmFjdFBsdWdpbl9jb25zdHJ1Y3RvcigpO1xuXG5cblx0Ly8gUHVibGljIFByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBUaGlzIGlzIG5vIGxvbmdlciBuZWVkZWQgYXMgd2UgYXJlIG5vdyB1c2luZyBvYmplY3QgcG9vbGluZyBmb3IgdGFncy5cblx0XHQgKlxuXHRcdCAqIDxiPk5PVEUgdGhpcyBwcm9wZXJ0eSBvbmx5IGV4aXN0cyBhcyBhIGxpbWl0YXRpb24gb2YgSFRNTCBhdWRpby48L2I+XG5cdFx0ICogQHByb3BlcnR5IGRlZmF1bHROdW1DaGFubmVsc1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMlxuXHRcdCAqIEBzaW5jZSAwLjQuMFxuXHRcdCAqIEBkZXByZWNhdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5kZWZhdWx0TnVtQ2hhbm5lbHMgPSAyO1xuXG5cdFx0dGhpcy5fY2FwYWJpbGl0aWVzID0gcy5fY2FwYWJpbGl0aWVzO1xuXG5cdFx0dGhpcy5fbG9hZGVyQ2xhc3MgPSBjcmVhdGVqcy5Tb3VuZExvYWRlcjtcblx0XHR0aGlzLl9zb3VuZEluc3RhbmNlQ2xhc3MgPSBjcmVhdGVqcy5IVE1MQXVkaW9Tb3VuZEluc3RhbmNlO1xuXHR9XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoSFRNTEF1ZGlvUGx1Z2luLCBjcmVhdGVqcy5BYnN0cmFjdFBsdWdpbik7XG5cdHZhciBzID0gSFRNTEF1ZGlvUGx1Z2luO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cbi8vIFN0YXRpYyBQcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgaW5zdGFuY2VzIHRoYXQgY2FuIGJlIGxvYWRlZCBvciBwbGF5ZWQuIFRoaXMgaXMgYSBicm93c2VyIGxpbWl0YXRpb24sIHByaW1hcmlseSBsaW1pdGVkIHRvIElFOS5cblx0ICogVGhlIGFjdHVhbCBudW1iZXIgdmFyaWVzIGZyb20gYnJvd3NlciB0byBicm93c2VyIChhbmQgaXMgbGFyZ2VseSBoYXJkd2FyZSBkZXBlbmRhbnQpLCBidXQgdGhpcyBpcyBhIHNhZmUgZXN0aW1hdGUuXG5cdCAqIEF1ZGlvIHNwcml0ZXMgd29yayBhcm91bmQgdGhpcyBsaW1pdGF0aW9uLlxuXHQgKiBAcHJvcGVydHkgTUFYX0lOU1RBTkNFU1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAzMFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLk1BWF9JTlNUQU5DRVMgPSAzMDtcblxuXHQvKipcblx0ICogRXZlbnQgY29uc3RhbnQgZm9yIHRoZSBcImNhblBsYXlUaHJvdWdoXCIgZXZlbnQgZm9yIGNsZWFuZXIgY29kZS5cblx0ICogQHByb3BlcnR5IF9BVURJT19SRUFEWVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBjYW5wbGF5dGhyb3VnaFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHMuX0FVRElPX1JFQURZID0gXCJjYW5wbGF5dGhyb3VnaFwiO1xuXG5cdC8qKlxuXHQgKiBFdmVudCBjb25zdGFudCBmb3IgdGhlIFwiZW5kZWRcIiBldmVudCBmb3IgY2xlYW5lciBjb2RlLlxuXHQgKiBAcHJvcGVydHkgX0FVRElPX0VOREVEXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGVuZGVkXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cy5fQVVESU9fRU5ERUQgPSBcImVuZGVkXCI7XG5cblx0LyoqXG5cdCAqIEV2ZW50IGNvbnN0YW50IGZvciB0aGUgXCJzZWVrZWRcIiBldmVudCBmb3IgY2xlYW5lciBjb2RlLiAgV2UgdXRpbGl6ZSB0aGlzIGV2ZW50IGZvciBtYWludGFpbmluZyBsb29wIGV2ZW50cy5cblx0ICogQHByb3BlcnR5IF9BVURJT19TRUVLRURcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgc2Vla2VkXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cy5fQVVESU9fU0VFS0VEID0gXCJzZWVrZWRcIjtcblxuXHQvKipcblx0ICogRXZlbnQgY29uc3RhbnQgZm9yIHRoZSBcInN0YWxsZWRcIiBldmVudCBmb3IgY2xlYW5lciBjb2RlLlxuXHQgKiBAcHJvcGVydHkgX0FVRElPX1NUQUxMRURcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgc3RhbGxlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHMuX0FVRElPX1NUQUxMRUQgPSBcInN0YWxsZWRcIjtcblxuXHQvKipcblx0ICogRXZlbnQgY29uc3RhbnQgZm9yIHRoZSBcInRpbWV1cGRhdGVcIiBldmVudCBmb3IgY2xlYW5lciBjb2RlLiAgVXRpbGl6ZWQgZm9yIGxvb3BpbmcgYXVkaW8gc3ByaXRlcy5cblx0ICogVGhpcyBldmVudCBjYWxsc2JhY2sgZXZlciAxNSB0byAyNTBtcyBhbmQgY2FuIGJlIGRyb3BwZWQgYnkgdGhlIGJyb3dzZXIgZm9yIHBlcmZvcm1hbmNlLlxuXHQgKiBAcHJvcGVydHkgX1RJTUVfVVBEQVRFXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHRpbWV1cGRhdGVcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzLl9USU1FX1VQREFURSA9IFwidGltZXVwZGF0ZVwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgY2FwYWJpbGl0aWVzIG9mIHRoZSBwbHVnaW4uIFRoaXMgaXMgZ2VuZXJhdGVkIHZpYSB0aGUge3sjY3Jvc3NMaW5rIFwiSFRNTEF1ZGlvUGx1Z2luL19nZW5lcmF0ZUNhcGFiaWxpdGllc1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuIFBsZWFzZSBzZWUgdGhlIFNvdW5kIHt7I2Nyb3NzTGluayBcIlNvdW5kL2dldENhcGFiaWxpdGllc1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgZm9yIGFuIG92ZXJ2aWV3IG9mIGFsbFxuXHQgKiBvZiB0aGUgYXZhaWxhYmxlIHByb3BlcnRpZXMuXG5cdCAqIEBwcm9wZXJ0eSBfY2FwYWJpbGl0aWVzXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5fY2FwYWJpbGl0aWVzID0gbnVsbDtcblxuXG4vLyBTdGF0aWMgTWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIHRoZSBwbHVnaW4gY2FuIGJlIHVzZWQgaW4gdGhlIGN1cnJlbnQgYnJvd3Nlci9PUy4gTm90ZSB0aGF0IEhUTUwgYXVkaW8gaXMgYXZhaWxhYmxlIGluIG1vc3QgbW9kZXJuXG5cdCAqIGJyb3dzZXJzLCBidXQgaXMgZGlzYWJsZWQgaW4gaU9TIGJlY2F1c2Ugb2YgaXRzIGxpbWl0YXRpb25zLlxuXHQgKiBAbWV0aG9kIGlzU3VwcG9ydGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBwbHVnaW4gY2FuIGJlIGluaXRpYWxpemVkLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuXHRcdHMuX2dlbmVyYXRlQ2FwYWJpbGl0aWVzKCk7XG5cdFx0cmV0dXJuIChzLl9jYXBhYmlsaXRpZXMgIT0gbnVsbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSB0aGUgY2FwYWJpbGl0aWVzIG9mIHRoZSBwbHVnaW4uIFVzZWQgaW50ZXJuYWxseS4gUGxlYXNlIHNlZSB0aGUgU291bmQgQVBJIHt7I2Nyb3NzTGluayBcIlNvdW5kL2dldENhcGFiaWxpdGllc1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QgZm9yIGFuIG92ZXJ2aWV3IG9mIHBsdWdpbiBjYXBhYmlsaXRpZXMuXG5cdCAqIEBtZXRob2QgX2dlbmVyYXRlQ2FwYWJpbGl0aWVzXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cy5fZ2VuZXJhdGVDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHMuX2NhcGFiaWxpdGllcyAhPSBudWxsKSB7cmV0dXJuO31cblx0XHR2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhdWRpb1wiKTtcblx0XHRpZiAodC5jYW5QbGF5VHlwZSA9PSBudWxsKSB7cmV0dXJuIG51bGw7fVxuXG5cdFx0cy5fY2FwYWJpbGl0aWVzID0ge1xuXHRcdFx0cGFubmluZzpmYWxzZSxcblx0XHRcdHZvbHVtZTp0cnVlLFxuXHRcdFx0dHJhY2tzOi0xXG5cdFx0fTtcblxuXHRcdC8vIGRldGVybWluZSB3aGljaCBleHRlbnNpb25zIG91ciBicm93c2VyIHN1cHBvcnRzIGZvciB0aGlzIHBsdWdpbiBieSBpdGVyYXRpbmcgdGhyb3VnaCBTb3VuZC5TVVBQT1JURURfRVhURU5TSU9OU1xuXHRcdHZhciBzdXBwb3J0ZWRFeHRlbnNpb25zID0gY3JlYXRlanMuU291bmQuU1VQUE9SVEVEX0VYVEVOU0lPTlM7XG5cdFx0dmFyIGV4dGVuc2lvbk1hcCA9IGNyZWF0ZWpzLlNvdW5kLkVYVEVOU0lPTl9NQVA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzdXBwb3J0ZWRFeHRlbnNpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGV4dCA9IHN1cHBvcnRlZEV4dGVuc2lvbnNbaV07XG5cdFx0XHR2YXIgcGxheVR5cGUgPSBleHRlbnNpb25NYXBbZXh0XSB8fCBleHQ7XG5cdFx0XHRzLl9jYXBhYmlsaXRpZXNbZXh0XSA9ICh0LmNhblBsYXlUeXBlKFwiYXVkaW8vXCIgKyBleHQpICE9IFwibm9cIiAmJiB0LmNhblBsYXlUeXBlKFwiYXVkaW8vXCIgKyBleHQpICE9IFwiXCIpIHx8ICh0LmNhblBsYXlUeXBlKFwiYXVkaW8vXCIgKyBwbGF5VHlwZSkgIT0gXCJub1wiICYmIHQuY2FuUGxheVR5cGUoXCJhdWRpby9cIiArIHBsYXlUeXBlKSAhPSBcIlwiKTtcblx0XHR9ICAvLyBPSlIgYW5vdGhlciB3YXkgdG8gZG8gdGhpcyBtaWdodCBiZSBjYW5QbGF5VHlwZTpcIm00YVwiLCBjb2RleDogbXA0XG5cdH07XG5cblxuLy8gcHVibGljIG1ldGhvZHNcblx0cC5yZWdpc3RlciA9IGZ1bmN0aW9uIChsb2FkSXRlbSkge1xuXHRcdHZhciB0YWcgPSBjcmVhdGVqcy5IVE1MQXVkaW9UYWdQb29sLmdldChsb2FkSXRlbS5zcmMpO1xuXHRcdHZhciBsb2FkZXIgPSB0aGlzLkFic3RyYWN0UGx1Z2luX3JlZ2lzdGVyKGxvYWRJdGVtKTtcblx0XHRsb2FkZXIuc2V0VGFnKHRhZyk7XG5cblx0XHRyZXR1cm4gbG9hZGVyO1xuXHR9O1xuXG5cdHAucmVtb3ZlU291bmQgPSBmdW5jdGlvbiAoc3JjKSB7XG5cdFx0dGhpcy5BYnN0cmFjdFBsdWdpbl9yZW1vdmVTb3VuZChzcmMpO1xuXHRcdGNyZWF0ZWpzLkhUTUxBdWRpb1RhZ1Bvb2wucmVtb3ZlKHNyYyk7XG5cdH07XG5cblx0cC5jcmVhdGUgPSBmdW5jdGlvbiAoc3JjLCBzdGFydFRpbWUsIGR1cmF0aW9uKSB7XG5cdFx0dmFyIHNpID0gdGhpcy5BYnN0cmFjdFBsdWdpbl9jcmVhdGUoc3JjLCBzdGFydFRpbWUsIGR1cmF0aW9uKTtcblx0XHRzaS5zZXRQbGF5YmFja1Jlc291cmNlKG51bGwpO1xuXHRcdHJldHVybiBzaTtcblx0fTtcblxuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltIVE1MQXVkaW9QbHVnaW5dXCI7XG5cdH07XG5cblx0Ly8gcGx1Z2luIGRvZXMgbm90IHN1cHBvcnQgdGhlc2Vcblx0cC5zZXRWb2x1bWUgPSBwLmdldFZvbHVtZSA9IHAuc2V0TXV0ZSA9IG51bGw7XG5cblxuXHRjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4gPSBjcmVhdGVqcy5wcm9tb3RlKEhUTUxBdWRpb1BsdWdpbiwgXCJBYnN0cmFjdFBsdWdpblwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUd2Vlbi5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuLy8gVE9ETzogcG9zc2libHkgYWRkIGEgRU5EIGFjdGlvbnNNb2RlIChvbmx5IHJ1bnMgYWN0aW9ucyB0aGF0ID09IHBvc2l0aW9uKT9cbi8vIFRPRE86IGV2YWx1YXRlIGEgd2F5IHRvIGRlY291cGxlIHBhdXNlZCBmcm9tIHRpY2sgcmVnaXN0cmF0aW9uLlxuXG5cblxuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIFR3ZWVuIGluc3RhbmNlIHR3ZWVucyBwcm9wZXJ0aWVzIGZvciBhIHNpbmdsZSB0YXJnZXQuIEluc3RhbmNlIG1ldGhvZHMgY2FuIGJlIGNoYWluZWQgZm9yIGVhc3kgY29uc3RydWN0aW9uIGFuZCBzZXF1ZW5jaW5nOlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdGFyZ2V0LmFscGhhID0gMTtcblx0ICpcdCAgICBjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0KVxuXHQgKlx0ICAgICAgICAgLndhaXQoNTAwKVxuXHQgKlx0ICAgICAgICAgLnRvKHthbHBoYTowLCB2aXNpYmxlOmZhbHNlfSwgMTAwMClcblx0ICpcdCAgICAgICAgIC5jYWxsKGhhbmRsZUNvbXBsZXRlKTtcblx0ICpcdCAgICBmdW5jdGlvbiBoYW5kbGVDb21wbGV0ZSgpIHtcblx0ICpcdCAgICBcdC8vVHdlZW4gY29tcGxldGVcblx0ICpcdCAgICB9XG5cdCAqXG5cdCAqIE11bHRpcGxlIHR3ZWVucyBjYW4gcG9pbnQgdG8gdGhlIHNhbWUgaW5zdGFuY2UsIGhvd2V2ZXIgaWYgdGhleSBhZmZlY3QgdGhlIHNhbWUgcHJvcGVydGllcyB0aGVyZSBjb3VsZCBiZSB1bmV4cGVjdGVkXG5cdCAqIGJlaGF2aW91ci4gVG8gc3RvcCBhbGwgdHdlZW5zIG9uIGFuIG9iamVjdCwgdXNlIHt7I2Nyb3NzTGluayBcIlR3ZWVuL3JlbW92ZVR3ZWVuc1wifX17ey9jcm9zc0xpbmt9fSBvciBwYXNzIGBvdmVycmlkZTp0cnVlYFxuXHQgKiBpbiB0aGUgcHJvcHMgYXJndW1lbnQuXG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuVHdlZW4uZ2V0KHRhcmdldCwge292ZXJyaWRlOnRydWV9KS50byh7eDoxMDB9KTtcblx0ICpcblx0ICogU3Vic2NyaWJlIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9jaGFuZ2U6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgdG8gZ2V0IG5vdGlmaWVkIHdoZW4gYSBwcm9wZXJ0eSBvZiB0aGVcblx0ICogdGFyZ2V0IGlzIGNoYW5nZWQuXG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuVHdlZW4uZ2V0KHRhcmdldCwge292ZXJyaWRlOnRydWV9KS50byh7eDoxMDB9KS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZUNoYW5nZSk7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIC8vIFRoZSB0d2VlbiBjaGFuZ2VkLlxuXHQgKiAgICAgIH1cblx0ICpcblx0ICogU2VlIHRoZSBUd2VlbiB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9nZXRcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGZvciBhZGRpdGlvbmFsIHBhcmFtIGRvY3VtZW50YXRpb24uXG5cdCAqIEBjbGFzcyBUd2VlblxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IHRoYXQgd2lsbCBoYXZlIGl0cyBwcm9wZXJ0aWVzIHR3ZWVuZWQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIFRoZSBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgdG8gYXBwbHkgdG8gdGhpcyB0d2VlbiBpbnN0YW5jZSAoZXguIGB7bG9vcDp0cnVlLCBwYXVzZWQ6dHJ1ZX1gLlxuXHQgKiBBbGwgcHJvcGVydGllcyBkZWZhdWx0IHRvIGZhbHNlLiBTdXBwb3J0ZWQgcHJvcHMgYXJlOjxVTD5cblx0ICogICAgPExJPiBsb29wOiBzZXRzIHRoZSBsb29wIHByb3BlcnR5IG9uIHRoaXMgdHdlZW4uPC9MST5cblx0ICogICAgPExJPiB1c2VUaWNrczogdXNlcyB0aWNrcyBmb3IgYWxsIGR1cmF0aW9ucyBpbnN0ZWFkIG9mIG1pbGxpc2Vjb25kcy48L0xJPlxuXHQgKiAgICA8TEk+IGlnbm9yZUdsb2JhbFBhdXNlOiBzZXRzIHRoZSB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9pZ25vcmVHbG9iYWxQYXVzZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBvbiB0aGlzIHR3ZWVuLjwvTEk+XG5cdCAqICAgIDxMST4gb3ZlcnJpZGU6IGlmIHRydWUsIGBUd2Vlbi5yZW1vdmVUd2VlbnModGFyZ2V0KWAgd2lsbCBiZSBjYWxsZWQgdG8gcmVtb3ZlIGFueSBvdGhlciB0d2VlbnMgd2l0aCB0aGUgc2FtZSB0YXJnZXQuXG5cdCAqICAgIDxMST4gcGF1c2VkOiBpbmRpY2F0ZXMgd2hldGhlciB0byBzdGFydCB0aGUgdHdlZW4gcGF1c2VkLjwvTEk+XG5cdCAqICAgIDxMST4gcG9zaXRpb246IGluZGljYXRlcyB0aGUgaW5pdGlhbCBwb3NpdGlvbiBmb3IgdGhpcyB0d2Vlbi48L0xJPlxuXHQgKiAgICA8TEk+IG9uQ2hhbmdlOiBzcGVjaWZpZXMgYSBsaXN0ZW5lciBmb3IgdGhlIFwiY2hhbmdlXCIgZXZlbnQuPC9MST5cblx0ICogPC9VTD5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtwbHVnaW5EYXRhXSBBbiBvYmplY3QgY29udGFpbmluZyBkYXRhIGZvciB1c2UgYnkgaW5zdGFsbGVkIHBsdWdpbnMuIFNlZSBpbmRpdmlkdWFsXG5cdCAqIHBsdWdpbnMnIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuXG5cdCAqIEBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFR3ZWVuKHRhcmdldCwgcHJvcHMsIHBsdWdpbkRhdGEpIHtcblxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBDYXVzZXMgdGhpcyB0d2VlbiB0byBjb250aW51ZSBwbGF5aW5nIHdoZW4gYSBnbG9iYWwgcGF1c2UgaXMgYWN0aXZlLiBGb3IgZXhhbXBsZSwgaWYgVHdlZW5KUyBpcyB1c2luZyB7eyNjcm9zc0xpbmsgXCJUaWNrZXJcIn19e3svY3Jvc3NMaW5rfX0sXG5cdFx0ICogdGhlbiBzZXR0aW5nIHRoaXMgdG8gdHJ1ZSAodGhlIGRlZmF1bHQpIHdpbGwgY2F1c2UgdGhpcyB0d2VlbiB0byBiZSBwYXVzZWQgd2hlbiA8Y29kZT5UaWNrZXIuc2V0UGF1c2VkKHRydWUpPC9jb2RlPlxuXHRcdCAqIGlzIGNhbGxlZC4gU2VlIHRoZSBUd2VlbiB7eyNjcm9zc0xpbmsgXCJUd2Vlbi90aWNrXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCBmb3IgbW9yZSBpbmZvLiBDYW4gYmUgc2V0IHZpYSB0aGUgcHJvcHNcblx0XHQgKiBwYXJhbWV0ZXIuXG5cdFx0ICogQHByb3BlcnR5IGlnbm9yZUdsb2JhbFBhdXNlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5pZ25vcmVHbG9iYWxQYXVzZSA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBJZiB0cnVlLCB0aGUgdHdlZW4gd2lsbCBsb29wIHdoZW4gaXQgcmVhY2hlcyB0aGUgZW5kLiBDYW4gYmUgc2V0IHZpYSB0aGUgcHJvcHMgcGFyYW0uXG5cdFx0ICogQHByb3BlcnR5IGxvb3Bcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMubG9vcCA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBTcGVjaWZpZXMgdGhlIHRvdGFsIGR1cmF0aW9uIG9mIHRoaXMgdHdlZW4gaW4gbWlsbGlzZWNvbmRzIChvciB0aWNrcyBpZiB1c2VUaWNrcyBpcyB0cnVlKS5cblx0XHQgKiBUaGlzIHZhbHVlIGlzIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCBhcyB5b3UgbW9kaWZ5IHRoZSB0d2Vlbi4gQ2hhbmdpbmcgaXQgZGlyZWN0bHkgY291bGQgcmVzdWx0IGluIHVuZXhwZWN0ZWRcblx0XHQgKiBiZWhhdmlvdXIuXG5cdFx0ICogQHByb3BlcnR5IGR1cmF0aW9uXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5kdXJhdGlvbiA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFsbG93cyB5b3UgdG8gc3BlY2lmeSBkYXRhIHRoYXQgd2lsbCBiZSB1c2VkIGJ5IGluc3RhbGxlZCBwbHVnaW5zLiBFYWNoIHBsdWdpbiB1c2VzIHRoaXMgZGlmZmVyZW50bHksIGJ1dCBpbiBnZW5lcmFsXG5cdFx0ICogeW91IHNwZWNpZnkgZGF0YSBieSBzZXR0aW5nIGl0IHRvIGEgcHJvcGVydHkgb2YgcGx1Z2luRGF0YSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIHBsdWdpbiBjbGFzcy5cblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqXHRteVR3ZWVuLnBsdWdpbkRhdGEuUGx1Z2luQ2xhc3NOYW1lID0gZGF0YTtcblx0XHQgKiA8YnIvPlxuXHRcdCAqIEFsc28sIG1vc3QgcGx1Z2lucyBzdXBwb3J0IGEgcHJvcGVydHkgdG8gZW5hYmxlIG9yIGRpc2FibGUgdGhlbS4gVGhpcyBpcyB0eXBpY2FsbHkgdGhlIHBsdWdpbiBjbGFzcyBuYW1lIGZvbGxvd2VkIGJ5IFwiX2VuYWJsZWRcIi48YnIvPlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICpcdG15VHdlZW4ucGx1Z2luRGF0YS5QbHVnaW5DbGFzc05hbWVfZW5hYmxlZCA9IGZhbHNlOzxici8+XG5cdFx0ICogPGJyLz5cblx0XHQgKiBTb21lIHBsdWdpbnMgYWxzbyBzdG9yZSBpbnN0YW5jZSBkYXRhIGluIHRoaXMgb2JqZWN0LCB1c3VhbGx5IGluIGEgcHJvcGVydHkgbmFtZWQgX1BsdWdpbkNsYXNzTmFtZS5cblx0XHQgKiBTZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIGluZGl2aWR1YWwgcGx1Z2lucyBmb3IgbW9yZSBkZXRhaWxzLlxuXHRcdCAqIEBwcm9wZXJ0eSBwbHVnaW5EYXRhXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLnBsdWdpbkRhdGEgPSBwbHVnaW5EYXRhIHx8IHt9O1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgdGFyZ2V0IG9mIHRoaXMgdHdlZW4uIFRoaXMgaXMgdGhlIG9iamVjdCBvbiB3aGljaCB0aGUgdHdlZW5lZCBwcm9wZXJ0aWVzIHdpbGwgYmUgY2hhbmdlZC4gQ2hhbmdpbmdcblx0XHQgKiB0aGlzIHByb3BlcnR5IGFmdGVyIHRoZSB0d2VlbiBpcyBjcmVhdGVkIHdpbGwgbm90IGhhdmUgYW55IGVmZmVjdC5cblx0XHQgKiBAcHJvcGVydHkgdGFyZ2V0XG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLnRhcmdldCA9IHRhcmdldDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgbm9ybWFsaXplZCBwb3NpdGlvbiBvZiB0aGUgdHdlZW4uIFRoaXMgd2lsbCBhbHdheXMgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIGR1cmF0aW9uLlxuXHRcdCAqIENoYW5naW5nIHRoaXMgcHJvcGVydHkgZGlyZWN0bHkgd2lsbCBoYXZlIG5vIGVmZmVjdC5cblx0XHQgKiBAcHJvcGVydHkgcG9zaXRpb25cblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMucG9zaXRpb24gPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgdGhlIHR3ZWVuJ3MgY3VycmVudCBwb3NpdGlvbiBpcyB3aXRoaW4gYSBwYXNzaXZlIHdhaXQuXG5cdFx0ICogQHByb3BlcnR5IHBhc3NpdmVcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLnBhc3NpdmUgPSBmYWxzZTtcblx0XG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfcGF1c2VkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfY3VyUXVldWVQcm9wc1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX2N1clF1ZXVlUHJvcHMgPSB7fTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9pbml0UXVldWVQcm9wc1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX2luaXRRdWV1ZVByb3BzID0ge307XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfc3RlcHNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3N0ZXBzID0gW107XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfYWN0aW9uc1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fYWN0aW9ucyA9IFtdO1xuXHRcblx0XHQvKipcblx0XHQgKiBSYXcgcG9zaXRpb24uXG5cdFx0ICogQHByb3BlcnR5IF9wcmV2UG9zaXRpb25cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fcHJldlBvc2l0aW9uID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHBvc2l0aW9uIHdpdGhpbiB0aGUgY3VycmVudCBzdGVwLlxuXHRcdCAqIEBwcm9wZXJ0eSBfc3RlcFBvc2l0aW9uXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3N0ZXBQb3NpdGlvbiA9IDA7IC8vIHRoaXMgaXMgbmVlZGVkIGJ5IE1vdmllQ2xpcC5cblx0XG5cdFx0LyoqXG5cdFx0ICogTm9ybWFsaXplZCBwb3NpdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgX3ByZXZQb3Ncblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IC0xXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3ByZXZQb3MgPSAtMTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF90YXJnZXRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfdXNlVGlja3Ncblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl91c2VUaWNrcyA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2luaXRlZFxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX2luaXRlZCA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0d2VlbiBpcyBjdXJyZW50bHkgcmVnaXN0ZXJlZCB3aXRoIFR3ZWVuLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmVnaXN0ZXJlZFxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3JlZ2lzdGVyZWQgPSBmYWxzZTtcblxuXG5cdFx0aWYgKHByb3BzKSB7XG5cdFx0XHR0aGlzLl91c2VUaWNrcyA9IHByb3BzLnVzZVRpY2tzO1xuXHRcdFx0dGhpcy5pZ25vcmVHbG9iYWxQYXVzZSA9IHByb3BzLmlnbm9yZUdsb2JhbFBhdXNlO1xuXHRcdFx0dGhpcy5sb29wID0gcHJvcHMubG9vcDtcblx0XHRcdHByb3BzLm9uQ2hhbmdlICYmIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBwcm9wcy5vbkNoYW5nZSk7XG5cdFx0XHRpZiAocHJvcHMub3ZlcnJpZGUpIHsgVHdlZW4ucmVtb3ZlVHdlZW5zKHRhcmdldCk7IH1cblx0XHR9XG5cdFx0aWYgKHByb3BzJiZwcm9wcy5wYXVzZWQpIHsgdGhpcy5fcGF1c2VkPXRydWU7IH1cblx0XHRlbHNlIHsgY3JlYXRlanMuVHdlZW4uX3JlZ2lzdGVyKHRoaXMsdHJ1ZSk7IH1cblx0XHRpZiAocHJvcHMmJnByb3BzLnBvc2l0aW9uIT1udWxsKSB7IHRoaXMuc2V0UG9zaXRpb24ocHJvcHMucG9zaXRpb24sIFR3ZWVuLk5PTkUpOyB9XG5cblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChUd2VlbiwgY3JlYXRlanMuRXZlbnREaXNwYXRjaGVyKTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblx0XG5cbi8vIHN0YXRpYyBwcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBDb25zdGFudCBkZWZpbmluZyB0aGUgbm9uZSBhY3Rpb25zTW9kZSBmb3IgdXNlIHdpdGggc2V0UG9zaXRpb24uXG5cdCAqIEBwcm9wZXJ0eSBOT05FXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKiBAZGVmYXVsdCAwXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFR3ZWVuLk5PTkUgPSAwO1xuXG5cdC8qKlxuXHQgKiBDb25zdGFudCBkZWZpbmluZyB0aGUgbG9vcCBhY3Rpb25zTW9kZSBmb3IgdXNlIHdpdGggc2V0UG9zaXRpb24uXG5cdCAqIEBwcm9wZXJ0eSBMT09QXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKiBAZGVmYXVsdCAxXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFR3ZWVuLkxPT1AgPSAxO1xuXG5cdC8qKlxuXHQgKiBDb25zdGFudCBkZWZpbmluZyB0aGUgcmV2ZXJzZSBhY3Rpb25zTW9kZSBmb3IgdXNlIHdpdGggc2V0UG9zaXRpb24uXG5cdCAqIEBwcm9wZXJ0eSBSRVZFUlNFXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKiBAZGVmYXVsdCAyXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFR3ZWVuLlJFVkVSU0UgPSAyO1xuXG5cdC8qKlxuXHQgKiBDb25zdGFudCByZXR1cm5lZCBieSBwbHVnaW5zIHRvIHRlbGwgdGhlIHR3ZWVuIG5vdCB0byB1c2UgZGVmYXVsdCBhc3NpZ25tZW50LlxuXHQgKiBAcHJvcGVydHkgSUdOT1JFXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUd2Vlbi5JR05PUkUgPSB7fTtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IF9saXN0ZW5lcnNcblx0ICogQHR5cGUgQXJyYXlbVHdlZW5dXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0VHdlZW4uX3R3ZWVucyA9IFtdO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3BsdWdpbnNcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0VHdlZW4uX3BsdWdpbnMgPSB7fTtcblxuXG4vLyBzdGF0aWMgbWV0aG9kc1x0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IHR3ZWVuIGluc3RhbmNlLiBUaGlzIGlzIGZ1bmN0aW9uYWxseSBpZGVudGljYWwgdG8gdXNpbmcgXCJuZXcgVHdlZW4oLi4uKVwiLCBidXQgbG9va3MgY2xlYW5lclxuXHQgKiB3aXRoIHRoZSBjaGFpbmVkIHN5bnRheCBvZiBUd2VlbkpTLlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqXHRcdHZhciB0d2VlbiA9IGNyZWF0ZWpzLlR3ZWVuLmdldCh0YXJnZXQpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIGdldFxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IHRoYXQgd2lsbCBoYXZlIGl0cyBwcm9wZXJ0aWVzIHR3ZWVuZWQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIFRoZSBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgdG8gYXBwbHkgdG8gdGhpcyB0d2VlbiBpbnN0YW5jZSAoZXguIGB7bG9vcDp0cnVlLCBwYXVzZWQ6dHJ1ZX1gKS5cblx0ICogQWxsIHByb3BlcnRpZXMgZGVmYXVsdCB0byBgZmFsc2VgLiBTdXBwb3J0ZWQgcHJvcHMgYXJlOlxuXHQgKiA8VUw+XG5cdCAqICAgIDxMST4gbG9vcDogc2V0cyB0aGUgbG9vcCBwcm9wZXJ0eSBvbiB0aGlzIHR3ZWVuLjwvTEk+XG5cdCAqICAgIDxMST4gdXNlVGlja3M6IHVzZXMgdGlja3MgZm9yIGFsbCBkdXJhdGlvbnMgaW5zdGVhZCBvZiBtaWxsaXNlY29uZHMuPC9MST5cblx0ICogICAgPExJPiBpZ25vcmVHbG9iYWxQYXVzZTogc2V0cyB0aGUge3sjY3Jvc3NMaW5rIFwiVHdlZW4vaWdub3JlR2xvYmFsUGF1c2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgb25cblx0ICogICAgdGhpcyB0d2Vlbi48L0xJPlxuXHQgKiAgICA8TEk+IG92ZXJyaWRlOiBpZiB0cnVlLCBgY3JlYXRlanMuVHdlZW4ucmVtb3ZlVHdlZW5zKHRhcmdldClgIHdpbGwgYmUgY2FsbGVkIHRvIHJlbW92ZSBhbnkgb3RoZXIgdHdlZW5zIHdpdGhcblx0ICogICAgdGhlIHNhbWUgdGFyZ2V0LlxuXHQgKiAgICA8TEk+IHBhdXNlZDogaW5kaWNhdGVzIHdoZXRoZXIgdG8gc3RhcnQgdGhlIHR3ZWVuIHBhdXNlZC48L0xJPlxuXHQgKiAgICA8TEk+IHBvc2l0aW9uOiBpbmRpY2F0ZXMgdGhlIGluaXRpYWwgcG9zaXRpb24gZm9yIHRoaXMgdHdlZW4uPC9MST5cblx0ICogICAgPExJPiBvbkNoYW5nZTogc3BlY2lmaWVzIGEgbGlzdGVuZXIgZm9yIHRoZSB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9jaGFuZ2U6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQuPC9MST5cblx0ICogPC9VTD5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtwbHVnaW5EYXRhXSBBbiBvYmplY3QgY29udGFpbmluZyBkYXRhIGZvciB1c2UgYnkgaW5zdGFsbGVkIHBsdWdpbnMuIFNlZSBpbmRpdmlkdWFsIHBsdWdpbnMnXG5cdCAqIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW292ZXJyaWRlPWZhbHNlXSBJZiB0cnVlLCBhbnkgcHJldmlvdXMgdHdlZW5zIG9uIHRoZSBzYW1lIHRhcmdldCB3aWxsIGJlIHJlbW92ZWQuIFRoaXMgaXMgdGhlXG5cdCAqIHNhbWUgYXMgY2FsbGluZyBgVHdlZW4ucmVtb3ZlVHdlZW5zKHRhcmdldClgLlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gQSByZWZlcmVuY2UgdG8gdGhlIGNyZWF0ZWQgdHdlZW4uIEFkZGl0aW9uYWwgY2hhaW5lZCB0d2VlbnMsIG1ldGhvZCBjYWxscywgb3IgY2FsbGJhY2tzIGNhbiBiZVxuXHQgKiBhcHBsaWVkIHRvIHRoZSByZXR1cm5lZCB0d2VlbiBpbnN0YW5jZS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VHdlZW4uZ2V0ID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wcywgcGx1Z2luRGF0YSwgb3ZlcnJpZGUpIHtcblx0XHRpZiAob3ZlcnJpZGUpIHsgVHdlZW4ucmVtb3ZlVHdlZW5zKHRhcmdldCk7IH1cblx0XHRyZXR1cm4gbmV3IFR3ZWVuKHRhcmdldCwgcHJvcHMsIHBsdWdpbkRhdGEpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZHZhbmNlcyBhbGwgdHdlZW5zLiBUaGlzIHR5cGljYWxseSB1c2VzIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXJcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MsIGJ1dCB5b3UgY2FuIGNhbGwgaXRcblx0ICogbWFudWFsbHkgaWYgeW91IHByZWZlciB0byB1c2UgeW91ciBvd24gXCJoZWFydGJlYXRcIiBpbXBsZW1lbnRhdGlvbi5cblx0ICogQG1ldGhvZCB0aWNrXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YSBUaGUgY2hhbmdlIGluIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IHRpY2suIFJlcXVpcmVkIHVubGVzcyBhbGwgdHdlZW5zIGhhdmVcblx0ICogYHVzZVRpY2tzYCBzZXQgdG8gdHJ1ZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBwYXVzZWQgSW5kaWNhdGVzIHdoZXRoZXIgYSBnbG9iYWwgcGF1c2UgaXMgaW4gZWZmZWN0LiBUd2VlbnMgd2l0aCB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9pZ25vcmVHbG9iYWxQYXVzZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aWxsIGlnbm9yZSB0aGlzLCBidXQgYWxsIG90aGVycyB3aWxsIHBhdXNlIGlmIHRoaXMgaXMgYHRydWVgLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUd2Vlbi50aWNrID0gZnVuY3Rpb24oZGVsdGEsIHBhdXNlZCkge1xuXHRcdHZhciB0d2VlbnMgPSBUd2Vlbi5fdHdlZW5zLnNsaWNlKCk7IC8vIHRvIGF2b2lkIHJhY2UgY29uZGl0aW9ucy5cblx0XHRmb3IgKHZhciBpPXR3ZWVucy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0d2VlbnNbaV07XG5cdFx0XHRpZiAoKHBhdXNlZCAmJiAhdHdlZW4uaWdub3JlR2xvYmFsUGF1c2UpIHx8IHR3ZWVuLl9wYXVzZWQpIHsgY29udGludWU7IH1cblx0XHRcdHR3ZWVuLnRpY2sodHdlZW4uX3VzZVRpY2tzPzE6ZGVsdGEpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlIGV2ZW50cyB0aGF0IHJlc3VsdCBmcm9tIFR3ZWVuIGJlaW5nIHVzZWQgYXMgYW4gZXZlbnQgaGFuZGxlci4gVGhpcyBpcyBpbmNsdWRlZCB0byBhbGxvdyBUd2VlbiB0byBoYW5kbGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3RpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnRzIGZyb20gdGhlIGNyZWF0ZWpzIHt7I2Nyb3NzTGluayBcIlRpY2tlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogTm8gb3RoZXIgZXZlbnRzIGFyZSBoYW5kbGVkIGluIFR3ZWVuLlxuXHQgKiBAbWV0aG9kIGhhbmRsZUV2ZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBBbiBldmVudCBvYmplY3QgcGFzc2VkIGluIGJ5IHRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXJcIn19e3svY3Jvc3NMaW5rfX0uIFdpbGxcblx0ICogdXN1YWxseSBiZSBvZiB0eXBlIFwidGlja1wiLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMlxuXHQgKi9cblx0VHdlZW4uaGFuZGxlRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdGlmIChldmVudC50eXBlID09IFwidGlja1wiKSB7XG5cdFx0XHR0aGlzLnRpY2soZXZlbnQuZGVsdGEsIGV2ZW50LnBhdXNlZCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFsbCBleGlzdGluZyB0d2VlbnMgZm9yIGEgdGFyZ2V0LiBUaGlzIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IG5ldyB0d2VlbnMgaWYgdGhlIGBvdmVycmlkZWBcblx0ICogcHJvcGVydHkgaXMgYHRydWVgLlxuXHQgKiBAbWV0aG9kIHJlbW92ZVR3ZWVuc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IHRvIHJlbW92ZSBleGlzdGluZyB0d2VlbnMgZnJvbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VHdlZW4ucmVtb3ZlVHdlZW5zID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0aWYgKCF0YXJnZXQudHdlZW5qc19jb3VudCkgeyByZXR1cm47IH1cblx0XHR2YXIgdHdlZW5zID0gVHdlZW4uX3R3ZWVucztcblx0XHRmb3IgKHZhciBpPXR3ZWVucy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0d2VlbnNbaV07XG5cdFx0XHRpZiAodHdlZW4uX3RhcmdldCA9PSB0YXJnZXQpIHtcblx0XHRcdFx0dHdlZW4uX3BhdXNlZCA9IHRydWU7XG5cdFx0XHRcdHR3ZWVucy5zcGxpY2UoaSwgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRhcmdldC50d2VlbmpzX2NvdW50ID0gMDtcblx0fTtcblxuXHQvKipcblx0ICogU3RvcCBhbmQgcmVtb3ZlIGFsbCBleGlzdGluZyB0d2VlbnMuXG5cdCAqIEBtZXRob2QgcmVtb3ZlQWxsVHdlZW5zXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNC4xXG5cdCAqL1xuXHRUd2Vlbi5yZW1vdmVBbGxUd2VlbnMgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdHdlZW5zID0gVHdlZW4uX3R3ZWVucztcblx0XHRmb3IgKHZhciBpPSAwLCBsPXR3ZWVucy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0d2VlbnNbaV07XG5cdFx0XHR0d2Vlbi5fcGF1c2VkID0gdHJ1ZTtcblx0XHRcdHR3ZWVuLnRhcmdldCYmKHR3ZWVuLnRhcmdldC50d2VlbmpzX2NvdW50ID0gMCk7XG5cdFx0fVxuXHRcdHR3ZWVucy5sZW5ndGggPSAwO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGVyZSBhcmUgYW55IGFjdGl2ZSB0d2VlbnMgKGFuZCBob3cgbWFueSkgb24gdGhlIHRhcmdldCBvYmplY3QgKGlmIHNwZWNpZmllZCkgb3IgaW4gZ2VuZXJhbC5cblx0ICogQG1ldGhvZCBoYXNBY3RpdmVUd2VlbnNcblx0ICogQHBhcmFtIHtPYmplY3R9IFt0YXJnZXRdIFRoZSB0YXJnZXQgdG8gY2hlY2sgZm9yIGFjdGl2ZSB0d2VlbnMuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBpbmRpY2F0ZVxuXHQgKiBpZiB0aGVyZSBhcmUgYW55IGFjdGl2ZSB0d2VlbnMgb24gYW55IHRhcmdldC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlcmUgYXJlIGFjdGl2ZSB0d2VlbnMuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFR3ZWVuLmhhc0FjdGl2ZVR3ZWVucyA9IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdGlmICh0YXJnZXQpIHsgcmV0dXJuIHRhcmdldC50d2VlbmpzX2NvdW50ICE9IG51bGwgJiYgISF0YXJnZXQudHdlZW5qc19jb3VudDsgfVxuXHRcdHJldHVybiBUd2Vlbi5fdHdlZW5zICYmICEhVHdlZW4uX3R3ZWVucy5sZW5ndGg7XG5cdH07XG5cblx0LyoqXG5cdCAqIEluc3RhbGxzIGEgcGx1Z2luLCB3aGljaCBjYW4gbW9kaWZ5IGhvdyBjZXJ0YWluIHByb3BlcnRpZXMgYXJlIGhhbmRsZWQgd2hlbiB0d2VlbmVkLiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIkNTU1BsdWdpblwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgYW4gZXhhbXBsZSBvZiBob3cgdG8gd3JpdGUgVHdlZW5KUyBwbHVnaW5zLlxuXHQgKiBAbWV0aG9kIGluc3RhbGxQbHVnaW5cblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luIFRoZSBwbHVnaW4gY2xhc3MgdG8gaW5zdGFsbFxuXHQgKiBAcGFyYW0ge0FycmF5fSBwcm9wZXJ0aWVzIEFuIGFycmF5IG9mIHByb3BlcnRpZXMgdGhhdCB0aGUgcGx1Z2luIHdpbGwgaGFuZGxlLlxuXHQgKi9cblx0VHdlZW4uaW5zdGFsbFBsdWdpbiA9IGZ1bmN0aW9uKHBsdWdpbiwgcHJvcGVydGllcykge1xuXHRcdHZhciBwcmlvcml0eSA9IHBsdWdpbi5wcmlvcml0eTtcblx0XHRpZiAocHJpb3JpdHkgPT0gbnVsbCkgeyBwbHVnaW4ucHJpb3JpdHkgPSBwcmlvcml0eSA9IDA7IH1cblx0XHRmb3IgKHZhciBpPTAsbD1wcm9wZXJ0aWVzLmxlbmd0aCxwPVR3ZWVuLl9wbHVnaW5zO2k8bDtpKyspIHtcblx0XHRcdHZhciBuID0gcHJvcGVydGllc1tpXTtcblx0XHRcdGlmICghcFtuXSkgeyBwW25dID0gW3BsdWdpbl07IH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR2YXIgYXJyID0gcFtuXTtcblx0XHRcdFx0Zm9yICh2YXIgaj0wLGpsPWFyci5sZW5ndGg7ajxqbDtqKyspIHtcblx0XHRcdFx0XHRpZiAocHJpb3JpdHkgPCBhcnJbal0ucHJpb3JpdHkpIHsgYnJlYWs7IH1cblx0XHRcdFx0fVxuXHRcdFx0XHRwW25dLnNwbGljZShqLDAscGx1Z2luKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBvciB1bnJlZ2lzdGVycyBhIHR3ZWVuIHdpdGggdGhlIHRpY2tpbmcgc3lzdGVtLlxuXHQgKiBAbWV0aG9kIF9yZWdpc3RlclxuXHQgKiBAcGFyYW0ge1R3ZWVufSB0d2VlbiBUaGUgdHdlZW4gaW5zdGFuY2UgdG8gcmVnaXN0ZXIgb3IgdW5yZWdpc3Rlci5cblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBJZiBgdHJ1ZWAsIHRoZSB0d2VlbiBpcyByZWdpc3RlcmVkLiBJZiBgZmFsc2VgIHRoZSB0d2VlbiBpcyB1bnJlZ2lzdGVyZWQuXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0VHdlZW4uX3JlZ2lzdGVyID0gZnVuY3Rpb24odHdlZW4sIHZhbHVlKSB7XG5cdFx0dmFyIHRhcmdldCA9IHR3ZWVuLl90YXJnZXQ7XG5cdFx0dmFyIHR3ZWVucyA9IFR3ZWVuLl90d2VlbnM7XG5cdFx0aWYgKHZhbHVlICYmICF0d2Vlbi5fcmVnaXN0ZXJlZCkge1xuXHRcdFx0Ly8gVE9ETzogdGhpcyBhcHByb2FjaCBtaWdodCBmYWlsIGlmIGEgZGV2IGlzIHVzaW5nIHNlYWxlZCBvYmplY3RzIGluIEVTNVxuXHRcdFx0aWYgKHRhcmdldCkgeyB0YXJnZXQudHdlZW5qc19jb3VudCA9IHRhcmdldC50d2VlbmpzX2NvdW50ID8gdGFyZ2V0LnR3ZWVuanNfY291bnQrMSA6IDE7IH1cblx0XHRcdHR3ZWVucy5wdXNoKHR3ZWVuKTtcblx0XHRcdGlmICghVHdlZW4uX2luaXRlZCAmJiBjcmVhdGVqcy5UaWNrZXIpIHsgY3JlYXRlanMuVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIFR3ZWVuKTsgVHdlZW4uX2luaXRlZCA9IHRydWU7IH1cblx0XHR9IGVsc2UgaWYgKCF2YWx1ZSAmJiB0d2Vlbi5fcmVnaXN0ZXJlZCkge1xuXHRcdFx0aWYgKHRhcmdldCkgeyB0YXJnZXQudHdlZW5qc19jb3VudC0tOyB9XG5cdFx0XHR2YXIgaSA9IHR3ZWVucy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdGlmICh0d2VlbnNbaV0gPT0gdHdlZW4pIHtcblx0XHRcdFx0XHR0d2VlbnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHR3ZWVuLl9yZWdpc3RlcmVkID0gdmFsdWU7XG5cdH07XG5cblxuLy8gZXZlbnRzOlxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW5ldmVyIHRoZSB0d2VlbidzIHBvc2l0aW9uIGNoYW5nZXMuXG5cdCAqIEBldmVudCBjaGFuZ2Vcblx0ICogQHNpbmNlIDAuNC4wXG5cdCAqKi9cblx0XG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUXVldWVzIGEgd2FpdCAoZXNzZW50aWFsbHkgYW4gZW1wdHkgdHdlZW4pLlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqXHRcdC8vVGhpcyB0d2VlbiB3aWxsIHdhaXQgMXMgYmVmb3JlIGFscGhhIGlzIGZhZGVkIHRvIDAuXG5cdCAqXHRcdGNyZWF0ZWpzLlR3ZWVuLmdldCh0YXJnZXQpLndhaXQoMTAwMCkudG8oe2FscGhhOjB9LCAxMDAwKTtcblx0ICpcblx0ICogQG1ldGhvZCB3YWl0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBUaGUgZHVyYXRpb24gb2YgdGhlIHdhaXQgaW4gbWlsbGlzZWNvbmRzIChvciBpbiB0aWNrcyBpZiBgdXNlVGlja3NgIGlzIHRydWUpLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXNzaXZlXSBUd2VlbiBwcm9wZXJ0aWVzIHdpbGwgbm90IGJlIHVwZGF0ZWQgZHVyaW5nIGEgcGFzc2l2ZSB3YWl0LiBUaGlzXG5cdCAqIGlzIG1vc3RseSB1c2VmdWwgZm9yIHVzZSB3aXRoIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlcyB0aGF0IGNvbnRhaW4gbXVsdGlwbGUgdHdlZW5zXG5cdCAqIGFmZmVjdGluZyB0aGUgc2FtZSB0YXJnZXQgYXQgZGlmZmVyZW50IHRpbWVzLlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhpcyB0d2VlbiBpbnN0YW5jZSAoZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICoqL1xuXHRwLndhaXQgPSBmdW5jdGlvbihkdXJhdGlvbiwgcGFzc2l2ZSkge1xuXHRcdGlmIChkdXJhdGlvbiA9PSBudWxsIHx8IGR1cmF0aW9uIDw9IDApIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR2YXIgbyA9IHRoaXMuX2Nsb25lUHJvcHModGhpcy5fY3VyUXVldWVQcm9wcyk7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZFN0ZXAoe2Q6ZHVyYXRpb24sIHAwOm8sIGU6dGhpcy5fbGluZWFyRWFzZSwgcDE6bywgdjpwYXNzaXZlfSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFF1ZXVlcyBhIHR3ZWVuIGZyb20gdGhlIGN1cnJlbnQgdmFsdWVzIHRvIHRoZSB0YXJnZXQgcHJvcGVydGllcy4gU2V0IGR1cmF0aW9uIHRvIDAgdG8ganVtcCB0byB0aGVzZSB2YWx1ZS5cblx0ICogTnVtZXJpYyBwcm9wZXJ0aWVzIHdpbGwgYmUgdHdlZW5lZCBmcm9tIHRoZWlyIGN1cnJlbnQgdmFsdWUgaW4gdGhlIHR3ZWVuIHRvIHRoZSB0YXJnZXQgdmFsdWUuIE5vbi1udW1lcmljXG5cdCAqIHByb3BlcnRpZXMgd2lsbCBiZSBzZXQgYXQgdGhlIGVuZCBvZiB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uLlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqXHRcdGNyZWF0ZWpzLlR3ZWVuLmdldCh0YXJnZXQpLnRvKHthbHBoYTowfSwgMTAwMCk7XG5cdCAqXG5cdCAqIEBtZXRob2QgdG9cblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEFuIG9iamVjdCBzcGVjaWZ5aW5nIHByb3BlcnR5IHRhcmdldCB2YWx1ZXMgZm9yIHRoaXMgdHdlZW4gKEV4LiBge3g6MzAwfWAgd291bGQgdHdlZW4gdGhlIHhcblx0ICogcHJvcGVydHkgb2YgdGhlIHRhcmdldCB0byAzMDApLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2R1cmF0aW9uPTBdIFRoZSBkdXJhdGlvbiBvZiB0aGUgd2FpdCBpbiBtaWxsaXNlY29uZHMgKG9yIGluIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgdHJ1ZSkuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtlYXNlPVwibGluZWFyXCJdIFRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIGZvciB0aGlzIHR3ZWVuLiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIkVhc2VcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogY2xhc3MgZm9yIGEgbGlzdCBvZiBidWlsdC1pbiBlYXNlIGZ1bmN0aW9ucy5cblx0ICogQHJldHVybiB7VHdlZW59IFRoaXMgdHdlZW4gaW5zdGFuY2UgKGZvciBjaGFpbmluZyBjYWxscykuXG5cdCAqL1xuXHRwLnRvID0gZnVuY3Rpb24ocHJvcHMsIGR1cmF0aW9uLCBlYXNlKSB7XG5cdFx0aWYgKGlzTmFOKGR1cmF0aW9uKSB8fCBkdXJhdGlvbiA8IDApIHsgZHVyYXRpb24gPSAwOyB9XG5cdFx0cmV0dXJuIHRoaXMuX2FkZFN0ZXAoe2Q6ZHVyYXRpb258fDAsIHAwOnRoaXMuX2Nsb25lUHJvcHModGhpcy5fY3VyUXVldWVQcm9wcyksIGU6ZWFzZSwgcDE6dGhpcy5fY2xvbmVQcm9wcyh0aGlzLl9hcHBlbmRRdWV1ZVByb3BzKHByb3BzKSl9KTtcblx0fTtcblxuXHQvKipcblx0ICogUXVldWVzIGFuIGFjdGlvbiB0byBjYWxsIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24uXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICBcdC8vd291bGQgY2FsbCBteUZ1bmN0aW9uKCkgYWZ0ZXIgMSBzZWNvbmQuXG5cdCAqICAgXHRteVR3ZWVuLndhaXQoMTAwMCkuY2FsbChteUZ1bmN0aW9uKTtcblx0ICpcblx0ICogQG1ldGhvZCBjYWxsXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBbcGFyYW1zXS4gVGhlIHBhcmFtZXRlcnMgdG8gY2FsbCB0aGUgZnVuY3Rpb24gd2l0aC4gSWYgdGhpcyBpcyBvbWl0dGVkLCB0aGVuIHRoZSBmdW5jdGlvblxuXHQgKiAgICAgIHdpbGwgYmUgY2FsbGVkIHdpdGggYSBzaW5nbGUgcGFyYW0gcG9pbnRpbmcgdG8gdGhpcyB0d2Vlbi5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0uIFRoZSBzY29wZSB0byBjYWxsIHRoZSBmdW5jdGlvbiBpbi4gSWYgb21pdHRlZCwgaXQgd2lsbCBiZSBjYWxsZWQgaW4gdGhlIHRhcmdldCdzXG5cdCAqICAgICAgc2NvcGUuXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBUaGlzIHR3ZWVuIGluc3RhbmNlIChmb3IgY2hhaW5pbmcgY2FsbHMpLlxuXHQgKi9cblx0cC5jYWxsID0gZnVuY3Rpb24oY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkQWN0aW9uKHtmOmNhbGxiYWNrLCBwOnBhcmFtcyA/IHBhcmFtcyA6IFt0aGlzXSwgbzpzY29wZSA/IHNjb3BlIDogdGhpcy5fdGFyZ2V0fSk7XG5cdH07XG5cblx0Ly8gVE9ETzogYWRkIGNsYXJpZmljYXRpb24gYmV0d2VlbiB0aGlzIGFuZCBhIDAgZHVyYXRpb24gLnRvOlxuXHQvKipcblx0ICogUXVldWVzIGFuIGFjdGlvbiB0byBzZXQgdGhlIHNwZWNpZmllZCBwcm9wcyBvbiB0aGUgc3BlY2lmaWVkIHRhcmdldC4gSWYgdGFyZ2V0IGlzIG51bGwsIGl0IHdpbGwgdXNlIHRoaXMgdHdlZW4nc1xuXHQgKiB0YXJnZXQuXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICpcdFx0bXlUd2Vlbi53YWl0KDEwMDApLnNldCh7dmlzaWJsZTpmYWxzZX0sZm9vKTtcblx0ICpcblx0ICogQG1ldGhvZCBzZXRcblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFRoZSBwcm9wZXJ0aWVzIHRvIHNldCAoZXguIGB7dmlzaWJsZTpmYWxzZX1gKS5cblx0ICogQHBhcmFtIHtPYmplY3R9IFt0YXJnZXRdIFRoZSB0YXJnZXQgdG8gc2V0IHRoZSBwcm9wZXJ0aWVzIG9uLiBJZiBvbWl0dGVkLCB0aGV5IHdpbGwgYmUgc2V0IG9uIHRoZSB0d2VlbidzIHRhcmdldC5cblx0ICogQHJldHVybiB7VHdlZW59IFRoaXMgdHdlZW4gaW5zdGFuY2UgKGZvciBjaGFpbmluZyBjYWxscykuXG5cdCAqL1xuXHRwLnNldCA9IGZ1bmN0aW9uKHByb3BzLCB0YXJnZXQpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkQWN0aW9uKHtmOnRoaXMuX3NldCwgbzp0aGlzLCBwOltwcm9wcywgdGFyZ2V0ID8gdGFyZ2V0IDogdGhpcy5fdGFyZ2V0XX0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBRdWV1ZXMgYW4gYWN0aW9uIHRvIHBsYXkgKHVucGF1c2UpIHRoZSBzcGVjaWZpZWQgdHdlZW4uIFRoaXMgZW5hYmxlcyB5b3UgdG8gc2VxdWVuY2UgbXVsdGlwbGUgdHdlZW5zLlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqXHRcdG15VHdlZW4udG8oe3g6MTAwfSw1MDApLnBsYXkob3RoZXJUd2Vlbik7XG5cdCAqXG5cdCAqIEBtZXRob2QgcGxheVxuXHQgKiBAcGFyYW0ge1R3ZWVufSB0d2VlbiBUaGUgdHdlZW4gdG8gcGxheS5cblx0ICogQHJldHVybiB7VHdlZW59IFRoaXMgdHdlZW4gaW5zdGFuY2UgKGZvciBjaGFpbmluZyBjYWxscykuXG5cdCAqL1xuXHRwLnBsYXkgPSBmdW5jdGlvbih0d2Vlbikge1xuXHRcdGlmICghdHdlZW4pIHsgdHdlZW4gPSB0aGlzOyB9XG5cdFx0cmV0dXJuIHRoaXMuY2FsbCh0d2Vlbi5zZXRQYXVzZWQsIFtmYWxzZV0sIHR3ZWVuKTtcblx0fTtcblxuXHQvKipcblx0ICogUXVldWVzIGFuIGFjdGlvbiB0byBwYXVzZSB0aGUgc3BlY2lmaWVkIHR3ZWVuLlxuXHQgKiBAbWV0aG9kIHBhdXNlXG5cdCAqIEBwYXJhbSB7VHdlZW59IHR3ZWVuIFRoZSB0d2VlbiB0byBwYXVzZS4gSWYgbnVsbCwgaXQgcGF1c2VzIHRoaXMgdHdlZW4uXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBUaGlzIHR3ZWVuIGluc3RhbmNlIChmb3IgY2hhaW5pbmcgY2FsbHMpXG5cdCAqL1xuXHRwLnBhdXNlID0gZnVuY3Rpb24odHdlZW4pIHtcblx0XHRpZiAoIXR3ZWVuKSB7IHR3ZWVuID0gdGhpczsgfVxuXHRcdHJldHVybiB0aGlzLmNhbGwodHdlZW4uc2V0UGF1c2VkLCBbdHJ1ZV0sIHR3ZWVuKTtcblx0fTtcblxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhlIHR3ZWVuIHRvIGEgc3BlY2lmaWVkIHBvc2l0aW9uLlxuXHQgKiBAbWV0aG9kIHNldFBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgcG9zaXRpb24gdG8gc2VlayB0byBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIHVzZVRpY2tzIGlzIHRydWUpLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2FjdGlvbnNNb2RlPTFdIFNwZWNpZmllcyBob3cgYWN0aW9ucyBhcmUgaGFuZGxlZCAoaWUuIGNhbGwsIHNldCwgcGxheSwgcGF1c2UpOlxuXHQgKiA8dWw+XG5cdCAqICAgICAgPGxpPnt7I2Nyb3NzTGluayBcIlR3ZWVuL05PTkU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gKDApIC0gcnVuIG5vIGFjdGlvbnMuPC9saT5cblx0ICogICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiVHdlZW4vTE9PUDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSAoMSkgLSBpZiBuZXcgcG9zaXRpb24gaXMgbGVzcyB0aGFuIG9sZCwgdGhlbiBydW4gYWxsXG5cdCAqICAgICAgYWN0aW9ucyBiZXR3ZWVuIG9sZCBhbmQgZHVyYXRpb24sIHRoZW4gYWxsIGFjdGlvbnMgYmV0d2VlbiAwIGFuZCBuZXcuPC9saT5cblx0ICogICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiVHdlZW4vUkVWRVJTRTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSAoMikgLSBpZiBuZXcgcG9zaXRpb24gaXMgbGVzcyB0aGFuIG9sZCwgcnVuIGFsbFxuXHQgKiAgICAgIGFjdGlvbnMgYmV0d2VlbiB0aGVtIGluIHJldmVyc2UuPC9saT5cblx0ICogPC91bD5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHR3ZWVuIGlzIGNvbXBsZXRlIChpZS4gdGhlIGZ1bGwgdHdlZW4gaGFzIHJ1biAmIHt7I2Nyb3NzTGluayBcIlR3ZWVuL2xvb3A6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaXMgYGZhbHNlYCkuXG5cdCAqL1xuXHRwLnNldFBvc2l0aW9uID0gZnVuY3Rpb24odmFsdWUsIGFjdGlvbnNNb2RlKSB7XG5cdFx0aWYgKHZhbHVlIDwgMCkgeyB2YWx1ZSA9IDA7IH1cblx0XHRpZiAoYWN0aW9uc01vZGUgPT0gbnVsbCkgeyBhY3Rpb25zTW9kZSA9IDE7IH1cblxuXHRcdC8vIG5vcm1hbGl6ZSBwb3NpdGlvbjpcblx0XHR2YXIgdCA9IHZhbHVlO1xuXHRcdHZhciBlbmQgPSBmYWxzZTtcblx0XHRpZiAodCA+PSB0aGlzLmR1cmF0aW9uKSB7XG5cdFx0XHRpZiAodGhpcy5sb29wKSB7IHQgPSB0JXRoaXMuZHVyYXRpb247IH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0ID0gdGhpcy5kdXJhdGlvbjtcblx0XHRcdFx0ZW5kID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHQgPT0gdGhpcy5fcHJldlBvcykgeyByZXR1cm4gZW5kOyB9XG5cblxuXHRcdHZhciBwcmV2UG9zID0gdGhpcy5fcHJldlBvcztcblx0XHR0aGlzLnBvc2l0aW9uID0gdGhpcy5fcHJldlBvcyA9IHQ7IC8vIHNldCB0aGlzIGluIGFkdmFuY2UgaW4gY2FzZSBhbiBhY3Rpb24gbW9kaWZpZXMgcG9zaXRpb24uXG5cdFx0dGhpcy5fcHJldlBvc2l0aW9uID0gdmFsdWU7XG5cblx0XHQvLyBoYW5kbGUgdHdlZW5zOlxuXHRcdGlmICh0aGlzLl90YXJnZXQpIHtcblx0XHRcdGlmIChlbmQpIHtcblx0XHRcdFx0Ly8gYWRkcmVzc2VzIHByb2JsZW1zIHdpdGggYW4gZW5kaW5nIHplcm8gbGVuZ3RoIHN0ZXAuXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVRhcmdldFByb3BzKG51bGwsMSk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3N0ZXBzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Ly8gZmluZCBvdXIgbmV3IHR3ZWVuIGluZGV4OlxuXHRcdFx0XHRmb3IgKHZhciBpPTAsIGw9dGhpcy5fc3RlcHMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9zdGVwc1tpXS50ID4gdCkgeyBicmVhazsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBzdGVwID0gdGhpcy5fc3RlcHNbaS0xXTtcblx0XHRcdFx0dGhpcy5fdXBkYXRlVGFyZ2V0UHJvcHMoc3RlcCwodGhpcy5fc3RlcFBvc2l0aW9uID0gdC1zdGVwLnQpL3N0ZXAuZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gcnVuIGFjdGlvbnM6XG5cdFx0aWYgKGFjdGlvbnNNb2RlICE9IDAgJiYgdGhpcy5fYWN0aW9ucy5sZW5ndGggPiAwKSB7XG5cdFx0XHRpZiAodGhpcy5fdXNlVGlja3MpIHtcblx0XHRcdFx0Ly8gb25seSBydW4gdGhlIGFjdGlvbnMgd2UgbGFuZGVkIG9uLlxuXHRcdFx0XHR0aGlzLl9ydW5BY3Rpb25zKHQsdCk7XG5cdFx0XHR9IGVsc2UgaWYgKGFjdGlvbnNNb2RlID09IDEgJiYgdDxwcmV2UG9zKSB7XG5cdFx0XHRcdGlmIChwcmV2UG9zICE9IHRoaXMuZHVyYXRpb24pIHsgdGhpcy5fcnVuQWN0aW9ucyhwcmV2UG9zLCB0aGlzLmR1cmF0aW9uKTsgfVxuXHRcdFx0XHR0aGlzLl9ydW5BY3Rpb25zKDAsIHQsIHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fcnVuQWN0aW9ucyhwcmV2UG9zLCB0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZW5kKSB7IHRoaXMuc2V0UGF1c2VkKHRydWUpOyB9XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiY2hhbmdlXCIpO1xuXHRcdHJldHVybiBlbmQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoaXMgdHdlZW4gYnkgdGhlIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZSBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmYHVzZVRpY2tzYCBpcyBgdHJ1ZWApLlxuXHQgKiBUaGlzIGlzIG5vcm1hbGx5IGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBUd2VlbiBlbmdpbmUgKHZpYSB7eyNjcm9zc0xpbmsgXCJUd2Vlbi90aWNrXCJ9fXt7L2Nyb3NzTGlua319KSwgYnV0IGlzXG5cdCAqIGV4cG9zZWQgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgdGlja1xuXHQgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgVGhlIHRpbWUgdG8gYWR2YW5jZSBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgYHRydWVgKS5cblx0ICovXG5cdHAudGljayA9IGZ1bmN0aW9uKGRlbHRhKSB7XG5cdFx0aWYgKHRoaXMuX3BhdXNlZCkgeyByZXR1cm47IH1cblx0XHR0aGlzLnNldFBvc2l0aW9uKHRoaXMuX3ByZXZQb3NpdGlvbitkZWx0YSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhdXNlcyBvciBwbGF5cyB0aGlzIHR3ZWVuLlxuXHQgKiBAbWV0aG9kIHNldFBhdXNlZFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt2YWx1ZT10cnVlXSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdHdlZW4gc2hvdWxkIGJlIHBhdXNlZCAoYHRydWVgKSBvciBwbGF5ZWQgKGBmYWxzZWApLlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhpcyB0d2VlbiBpbnN0YW5jZSAoZm9yIGNoYWluaW5nIGNhbGxzKVxuXHQgKi9cblx0cC5zZXRQYXVzZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh0aGlzLl9wYXVzZWQgPT09ICEhdmFsdWUpIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR0aGlzLl9wYXVzZWQgPSAhIXZhbHVlO1xuXHRcdFR3ZWVuLl9yZWdpc3Rlcih0aGlzLCAhdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8vIHRpbnkgYXBpIChwcmltYXJpbHkgZm9yIHRvb2wgb3V0cHV0KTpcblx0cC53ID0gcC53YWl0O1xuXHRwLnQgPSBwLnRvO1xuXHRwLmMgPSBwLmNhbGw7XG5cdHAucyA9IHAuc2V0O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltUd2Vlbl1cIjtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3coXCJUd2VlbiBjYW4gbm90IGJlIGNsb25lZC5cIilcblx0fTtcblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfdXBkYXRlVGFyZ2V0UHJvcHNcblx0ICogQHBhcmFtIHtPYmplY3R9IHN0ZXBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhdGlvXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3VwZGF0ZVRhcmdldFByb3BzID0gZnVuY3Rpb24oc3RlcCwgcmF0aW8pIHtcblx0XHR2YXIgcDAscDEsdix2MCx2MSxhcnI7XG5cdFx0aWYgKCFzdGVwICYmIHJhdGlvID09IDEpIHtcblx0XHRcdC8vIEdEUzogd2hlbiBkb2VzIHRoaXMgcnVuPyBKdXN0IGF0IHRoZSB2ZXJ5IGVuZD8gU2hvdWxkbid0LlxuXHRcdFx0dGhpcy5wYXNzaXZlID0gZmFsc2U7XG5cdFx0XHRwMCA9IHAxID0gdGhpcy5fY3VyUXVldWVQcm9wcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wYXNzaXZlID0gISFzdGVwLnY7XG5cdFx0XHRpZiAodGhpcy5wYXNzaXZlKSB7IHJldHVybjsgfSAvLyBkb24ndCB1cGRhdGUgcHJvcHMuXG5cdFx0XHQvLyBhcHBseSBlYXNlIHRvIHJhdGlvLlxuXHRcdFx0aWYgKHN0ZXAuZSkgeyByYXRpbyA9IHN0ZXAuZShyYXRpbywwLDEsMSk7IH1cblx0XHRcdHAwID0gc3RlcC5wMDtcblx0XHRcdHAxID0gc3RlcC5wMTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBuIGluIHRoaXMuX2luaXRRdWV1ZVByb3BzKSB7XG5cdFx0XHRpZiAoKHYwID0gcDBbbl0pID09IG51bGwpIHsgcDBbbl0gPSB2MCA9IHRoaXMuX2luaXRRdWV1ZVByb3BzW25dOyB9XG5cdFx0XHRpZiAoKHYxID0gcDFbbl0pID09IG51bGwpIHsgcDFbbl0gPSB2MSA9IHYwOyB9XG5cdFx0XHRpZiAodjAgPT0gdjEgfHwgcmF0aW8gPT0gMCB8fCByYXRpbyA9PSAxIHx8ICh0eXBlb2YodjApICE9IFwibnVtYmVyXCIpKSB7XG5cdFx0XHRcdC8vIG5vIGludGVycG9sYXRpb24gLSBlaXRoZXIgYXQgc3RhcnQsIGVuZCwgdmFsdWVzIGRvbid0IGNoYW5nZSwgb3IgdGhlIHZhbHVlIGlzIG5vbi1udW1lcmljLlxuXHRcdFx0XHR2ID0gcmF0aW8gPT0gMSA/IHYxIDogdjA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2ID0gdjArKHYxLXYwKSpyYXRpbztcblx0XHRcdH1cblxuXHRcdFx0dmFyIGlnbm9yZSA9IGZhbHNlO1xuXHRcdFx0aWYgKGFyciA9IFR3ZWVuLl9wbHVnaW5zW25dKSB7XG5cdFx0XHRcdGZvciAodmFyIGk9MCxsPWFyci5sZW5ndGg7aTxsO2krKykge1xuXHRcdFx0XHRcdHZhciB2MiA9IGFycltpXS50d2Vlbih0aGlzLCBuLCB2LCBwMCwgcDEsIHJhdGlvLCAhIXN0ZXAmJnAwPT1wMSwgIXN0ZXApO1xuXHRcdFx0XHRcdGlmICh2MiA9PSBUd2Vlbi5JR05PUkUpIHsgaWdub3JlID0gdHJ1ZTsgfVxuXHRcdFx0XHRcdGVsc2UgeyB2ID0gdjI7IH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFpZ25vcmUpIHsgdGhpcy5fdGFyZ2V0W25dID0gdjsgfVxuXHRcdH1cblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9ydW5BY3Rpb25zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFBvc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gZW5kUG9zXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jbHVkZVN0YXJ0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3J1bkFjdGlvbnMgPSBmdW5jdGlvbihzdGFydFBvcywgZW5kUG9zLCBpbmNsdWRlU3RhcnQpIHtcblx0XHR2YXIgc1BvcyA9IHN0YXJ0UG9zO1xuXHRcdHZhciBlUG9zID0gZW5kUG9zO1xuXHRcdHZhciBpID0gLTE7XG5cdFx0dmFyIGogPSB0aGlzLl9hY3Rpb25zLmxlbmd0aDtcblx0XHR2YXIgayA9IDE7XG5cdFx0aWYgKHN0YXJ0UG9zID4gZW5kUG9zKSB7XG5cdFx0XHQvLyBydW5uaW5nIGJhY2t3YXJkcywgZmxpcCBldmVyeXRoaW5nOlxuXHRcdFx0c1BvcyA9IGVuZFBvcztcblx0XHRcdGVQb3MgPSBzdGFydFBvcztcblx0XHRcdGkgPSBqO1xuXHRcdFx0aiA9IGsgPSAtMTtcblx0XHR9XG5cdFx0d2hpbGUgKChpKz1rKSAhPSBqKSB7XG5cdFx0XHR2YXIgYWN0aW9uID0gdGhpcy5fYWN0aW9uc1tpXTtcblx0XHRcdHZhciBwb3MgPSBhY3Rpb24udDtcblx0XHRcdGlmIChwb3MgPT0gZVBvcyB8fCAocG9zID4gc1BvcyAmJiBwb3MgPCBlUG9zKSB8fCAoaW5jbHVkZVN0YXJ0ICYmIHBvcyA9PSBzdGFydFBvcykgKSB7XG5cdFx0XHRcdGFjdGlvbi5mLmFwcGx5KGFjdGlvbi5vLCBhY3Rpb24ucCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9hcHBlbmRRdWV1ZVByb3BzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2FwcGVuZFF1ZXVlUHJvcHMgPSBmdW5jdGlvbihvKSB7XG5cdFx0dmFyIGFycixvbGRWYWx1ZSxpLCBsLCBpbmplY3RQcm9wcztcblx0XHRmb3IgKHZhciBuIGluIG8pIHtcblx0XHRcdGlmICh0aGlzLl9pbml0UXVldWVQcm9wc1tuXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG9sZFZhbHVlID0gdGhpcy5fdGFyZ2V0W25dO1xuXG5cdFx0XHRcdC8vIGluaXQgcGx1Z2luczpcblx0XHRcdFx0aWYgKGFyciA9IFR3ZWVuLl9wbHVnaW5zW25dKSB7XG5cdFx0XHRcdFx0Zm9yIChpPTAsbD1hcnIubGVuZ3RoO2k8bDtpKyspIHtcblx0XHRcdFx0XHRcdG9sZFZhbHVlID0gYXJyW2ldLmluaXQodGhpcywgbiwgb2xkVmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9pbml0UXVldWVQcm9wc1tuXSA9IHRoaXMuX2N1clF1ZXVlUHJvcHNbbl0gPSAob2xkVmFsdWU9PT11bmRlZmluZWQpID8gbnVsbCA6IG9sZFZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2xkVmFsdWUgPSB0aGlzLl9jdXJRdWV1ZVByb3BzW25dO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIG4gaW4gbykge1xuXHRcdFx0b2xkVmFsdWUgPSB0aGlzLl9jdXJRdWV1ZVByb3BzW25dO1xuXHRcdFx0aWYgKGFyciA9IFR3ZWVuLl9wbHVnaW5zW25dKSB7XG5cdFx0XHRcdGluamVjdFByb3BzID0gaW5qZWN0UHJvcHN8fHt9O1xuXHRcdFx0XHRmb3IgKGk9MCwgbD1hcnIubGVuZ3RoO2k8bDtpKyspIHtcblx0XHRcdFx0XHQvLyBUT0RPOiByZW1vdmUgdGhlIGNoZWNrIGZvciAuc3RlcCBpbiB0aGUgbmV4dCB2ZXJzaW9uLiBJdCdzIGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXHRcdFx0XHRcdGlmIChhcnJbaV0uc3RlcCkgeyBhcnJbaV0uc3RlcCh0aGlzLCBuLCBvbGRWYWx1ZSwgb1tuXSwgaW5qZWN0UHJvcHMpOyB9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2N1clF1ZXVlUHJvcHNbbl0gPSBvW25dO1xuXHRcdH1cblx0XHRpZiAoaW5qZWN0UHJvcHMpIHsgdGhpcy5fYXBwZW5kUXVldWVQcm9wcyhpbmplY3RQcm9wcyk7IH1cblx0XHRyZXR1cm4gdGhpcy5fY3VyUXVldWVQcm9wcztcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfY2xvbmVQcm9wc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fY2xvbmVQcm9wcyA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0dmFyIG8gPSB7fTtcblx0XHRmb3IgKHZhciBuIGluIHByb3BzKSB7XG5cdFx0XHRvW25dID0gcHJvcHNbbl07XG5cdFx0fVxuXHRcdHJldHVybiBvO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9hZGRTdGVwXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2FkZFN0ZXAgPSBmdW5jdGlvbihvKSB7XG5cdFx0aWYgKG8uZCA+IDApIHtcblx0XHRcdHRoaXMuX3N0ZXBzLnB1c2gobyk7XG5cdFx0XHRvLnQgPSB0aGlzLmR1cmF0aW9uO1xuXHRcdFx0dGhpcy5kdXJhdGlvbiArPSBvLmQ7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9hZGRBY3Rpb25cblx0ICogQHBhcmFtIHtPYmplY3R9IG9cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fYWRkQWN0aW9uID0gZnVuY3Rpb24obykge1xuXHRcdG8udCA9IHRoaXMuZHVyYXRpb247XG5cdFx0dGhpcy5fYWN0aW9ucy5wdXNoKG8pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9zZXRcblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3NldCA9IGZ1bmN0aW9uKHByb3BzLCBvKSB7XG5cdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykge1xuXHRcdFx0b1tuXSA9IHByb3BzW25dO1xuXHRcdH1cblx0fTtcblxuXHRjcmVhdGVqcy5Ud2VlbiA9IGNyZWF0ZWpzLnByb21vdGUoVHdlZW4sIFwiRXZlbnREaXNwYXRjaGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVGltZWxpbmUuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFxuXG4vLyBjb25zdHJ1Y3Rvclx0XG5cdC8qKlxuXHQgKiBUaGUgVGltZWxpbmUgY2xhc3Mgc3luY2hyb25pemVzIG11bHRpcGxlIHR3ZWVucyBhbmQgYWxsb3dzIHRoZW0gdG8gYmUgY29udHJvbGxlZCBhcyBhIGdyb3VwLiBQbGVhc2Ugbm90ZSB0aGF0IGlmIGFcblx0ICogdGltZWxpbmUgaXMgbG9vcGluZywgdGhlIHR3ZWVucyBvbiBpdCBtYXkgYXBwZWFyIHRvIGxvb3AgZXZlbiBpZiB0aGUgXCJsb29wXCIgcHJvcGVydHkgb2YgdGhlIHR3ZWVuIGlzIGZhbHNlLlxuXHQgKiBAY2xhc3MgVGltZWxpbmVcblx0ICogQHBhcmFtIHtBcnJheX0gdHdlZW5zIEFuIGFycmF5IG9mIFR3ZWVucyB0byBhZGQgdG8gdGhpcyB0aW1lbGluZS4gU2VlIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2FkZFR3ZWVuXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBtb3JlIGluZm8uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBsYWJlbHMgQW4gb2JqZWN0IGRlZmluaW5nIGxhYmVscyBmb3IgdXNpbmcge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX0ve3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvZ290b0FuZFN0b3BcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZS9zZXRMYWJlbHNcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBUaGUgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIHRvIGFwcGx5IHRvIHRoaXMgdHdlZW4gaW5zdGFuY2UgKGV4LiBge2xvb3A6dHJ1ZX1gKS4gQWxsIHByb3BlcnRpZXNcblx0ICogZGVmYXVsdCB0byBmYWxzZS4gU3VwcG9ydGVkIHByb3BzIGFyZTo8VUw+XG5cdCAqICAgIDxMST4gbG9vcDogc2V0cyB0aGUgbG9vcCBwcm9wZXJ0eSBvbiB0aGlzIHR3ZWVuLjwvTEk+XG5cdCAqICAgIDxMST4gdXNlVGlja3M6IHVzZXMgdGlja3MgZm9yIGFsbCBkdXJhdGlvbnMgaW5zdGVhZCBvZiBtaWxsaXNlY29uZHMuPC9MST5cblx0ICogICAgPExJPiBpZ25vcmVHbG9iYWxQYXVzZTogc2V0cyB0aGUgaWdub3JlR2xvYmFsUGF1c2UgcHJvcGVydHkgb24gdGhpcyB0d2Vlbi48L0xJPlxuXHQgKiAgICA8TEk+IHBhdXNlZDogaW5kaWNhdGVzIHdoZXRoZXIgdG8gc3RhcnQgdGhlIHR3ZWVuIHBhdXNlZC48L0xJPlxuXHQgKiAgICA8TEk+IHBvc2l0aW9uOiBpbmRpY2F0ZXMgdGhlIGluaXRpYWwgcG9zaXRpb24gZm9yIHRoaXMgdGltZWxpbmUuPC9MST5cblx0ICogICAgPExJPiBvbkNoYW5nZTogc3BlY2lmaWVzIGEgbGlzdGVuZXIgdG8gYWRkIGZvciB0aGUge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvY2hhbmdlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50LjwvTEk+XG5cdCAqIDwvVUw+XG5cdCAqIEBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBUaW1lbGluZSh0d2VlbnMsIGxhYmVscywgcHJvcHMpIHtcblx0XHR0aGlzLkV2ZW50RGlzcGF0Y2hlcl9jb25zdHJ1Y3RvcigpO1xuXG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIENhdXNlcyB0aGlzIHRpbWVsaW5lIHRvIGNvbnRpbnVlIHBsYXlpbmcgd2hlbiBhIGdsb2JhbCBwYXVzZSBpcyBhY3RpdmUuXG5cdFx0ICogQHByb3BlcnR5IGlnbm9yZUdsb2JhbFBhdXNlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqKi9cblx0XHR0aGlzLmlnbm9yZUdsb2JhbFBhdXNlID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdG90YWwgZHVyYXRpb24gb2YgdGhpcyB0aW1lbGluZSBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIGB1c2VUaWNrcyBgaXMgYHRydWVgKS4gVGhpcyB2YWx1ZSBpcyB1c3VhbGx5XG5cdFx0ICogYXV0b21hdGljYWxseSB1cGRhdGVkIGFzIHlvdSBtb2RpZnkgdGhlIHRpbWVsaW5lLiBTZWUge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvdXBkYXRlRHVyYXRpb25cIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgZHVyYXRpb25cblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMuZHVyYXRpb24gPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogSWYgdHJ1ZSwgdGhlIHRpbWVsaW5lIHdpbGwgbG9vcCB3aGVuIGl0IHJlYWNoZXMgdGhlIGVuZC4gQ2FuIGJlIHNldCB2aWEgdGhlIHByb3BzIHBhcmFtLlxuXHRcdCAqIEBwcm9wZXJ0eSBsb29wXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqKi9cblx0XHR0aGlzLmxvb3AgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IG5vcm1hbGl6ZWQgcG9zaXRpb24gb2YgdGhlIHRpbWVsaW5lLiBUaGlzIHdpbGwgYWx3YXlzIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZFxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2R1cmF0aW9uOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIENoYW5naW5nIHRoaXMgcHJvcGVydHkgZGlyZWN0bHkgd2lsbCBoYXZlIG5vIGVmZmVjdC5cblx0XHQgKiBAcHJvcGVydHkgcG9zaXRpb25cblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5wb3NpdGlvbiA9IG51bGw7XG5cblx0XHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9wYXVzZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfdHdlZW5zXG5cdFx0ICogQHR5cGUgQXJyYXlbVHdlZW5dXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl90d2VlbnMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbGFiZWxzXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9sYWJlbHMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9sYWJlbExpc3Rcblx0XHQgKiBAdHlwZSBBcnJheVtPYmplY3RdXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9sYWJlbExpc3QgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9wcmV2UG9zaXRpb25cblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9wcmV2UG9zaXRpb24gPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9wcmV2UG9zXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgLTFcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3ByZXZQb3MgPSAtMTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfdXNlVGlja3Ncblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3VzZVRpY2tzID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRpbWVsaW5lIGlzIGN1cnJlbnRseSByZWdpc3RlcmVkIHdpdGggVHdlZW4uXG5cdFx0ICogQHByb3BlcnR5IF9yZWdpc3RlcmVkXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fcmVnaXN0ZXJlZCA9IGZhbHNlO1xuXG5cblx0XHRpZiAocHJvcHMpIHtcblx0XHRcdHRoaXMuX3VzZVRpY2tzID0gcHJvcHMudXNlVGlja3M7XG5cdFx0XHR0aGlzLmxvb3AgPSBwcm9wcy5sb29wO1xuXHRcdFx0dGhpcy5pZ25vcmVHbG9iYWxQYXVzZSA9IHByb3BzLmlnbm9yZUdsb2JhbFBhdXNlO1xuXHRcdFx0cHJvcHMub25DaGFuZ2UmJnRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBwcm9wcy5vbkNoYW5nZSk7XG5cdFx0fVxuXHRcdGlmICh0d2VlbnMpIHsgdGhpcy5hZGRUd2Vlbi5hcHBseSh0aGlzLCB0d2VlbnMpOyB9XG5cdFx0dGhpcy5zZXRMYWJlbHMobGFiZWxzKTtcblx0XHRpZiAocHJvcHMmJnByb3BzLnBhdXNlZCkgeyB0aGlzLl9wYXVzZWQ9dHJ1ZTsgfVxuXHRcdGVsc2UgeyBjcmVhdGVqcy5Ud2Vlbi5fcmVnaXN0ZXIodGhpcyx0cnVlKTsgfVxuXHRcdGlmIChwcm9wcyYmcHJvcHMucG9zaXRpb24hPW51bGwpIHsgdGhpcy5zZXRQb3NpdGlvbihwcm9wcy5wb3NpdGlvbiwgY3JlYXRlanMuVHdlZW4uTk9ORSk7IH1cblx0XHRcblx0fTtcblx0XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFRpbWVsaW5lLCBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cdFxuLy8gZXZlbnRzOlxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW5ldmVyIHRoZSB0aW1lbGluZSdzIHBvc2l0aW9uIGNoYW5nZXMuXG5cdCAqIEBldmVudCBjaGFuZ2Vcblx0ICogQHNpbmNlIDAuNS4wXG5cdCAqKi9cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEFkZHMgb25lIG9yIG1vcmUgdHdlZW5zIChvciB0aW1lbGluZXMpIHRvIHRoaXMgdGltZWxpbmUuIFRoZSB0d2VlbnMgd2lsbCBiZSBwYXVzZWQgKHRvIHJlbW92ZSB0aGVtIGZyb20gdGhlXG5cdCAqIG5vcm1hbCB0aWNraW5nIHN5c3RlbSkgYW5kIG1hbmFnZWQgYnkgdGhpcyB0aW1lbGluZS4gQWRkaW5nIGEgdHdlZW4gdG8gbXVsdGlwbGUgdGltZWxpbmVzIHdpbGwgcmVzdWx0IGluXG5cdCAqIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLlxuXHQgKiBAbWV0aG9kIGFkZFR3ZWVuXG5cdCAqIEBwYXJhbSB7VHdlZW59IC4uLnR3ZWVuIFRoZSB0d2VlbihzKSB0byBhZGQuIEFjY2VwdHMgbXVsdGlwbGUgYXJndW1lbnRzLlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhlIGZpcnN0IHR3ZWVuIHRoYXQgd2FzIHBhc3NlZCBpbi5cblx0ICoqL1xuXHRwLmFkZFR3ZWVuID0gZnVuY3Rpb24odHdlZW4pIHtcblx0XHR2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0aWYgKGwgPiAxKSB7XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7IHRoaXMuYWRkVHdlZW4oYXJndW1lbnRzW2ldKTsgfVxuXHRcdFx0cmV0dXJuIGFyZ3VtZW50c1swXTtcblx0XHR9IGVsc2UgaWYgKGwgPT0gMCkgeyByZXR1cm4gbnVsbDsgfVxuXHRcdHRoaXMucmVtb3ZlVHdlZW4odHdlZW4pO1xuXHRcdHRoaXMuX3R3ZWVucy5wdXNoKHR3ZWVuKTtcblx0XHR0d2Vlbi5zZXRQYXVzZWQodHJ1ZSk7XG5cdFx0dHdlZW4uX3BhdXNlZCA9IGZhbHNlO1xuXHRcdHR3ZWVuLl91c2VUaWNrcyA9IHRoaXMuX3VzZVRpY2tzO1xuXHRcdGlmICh0d2Vlbi5kdXJhdGlvbiA+IHRoaXMuZHVyYXRpb24pIHsgdGhpcy5kdXJhdGlvbiA9IHR3ZWVuLmR1cmF0aW9uOyB9XG5cdFx0aWYgKHRoaXMuX3ByZXZQb3MgPj0gMCkgeyB0d2Vlbi5zZXRQb3NpdGlvbih0aGlzLl9wcmV2UG9zLCBjcmVhdGVqcy5Ud2Vlbi5OT05FKTsgfVxuXHRcdHJldHVybiB0d2Vlbjtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyBvbmUgb3IgbW9yZSB0d2VlbnMgZnJvbSB0aGlzIHRpbWVsaW5lLlxuXHQgKiBAbWV0aG9kIHJlbW92ZVR3ZWVuXG5cdCAqIEBwYXJhbSB7VHdlZW59IC4uLnR3ZWVuIFRoZSB0d2VlbihzKSB0byByZW1vdmUuIEFjY2VwdHMgbXVsdGlwbGUgYXJndW1lbnRzLlxuXHQgKiBAcmV0dXJuIEJvb2xlYW4gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIG9mIHRoZSB0d2VlbnMgd2VyZSBzdWNjZXNzZnVsbHkgcmVtb3ZlZC5cblx0ICoqL1xuXHRwLnJlbW92ZVR3ZWVuID0gZnVuY3Rpb24odHdlZW4pIHtcblx0XHR2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0aWYgKGwgPiAxKSB7XG5cdFx0XHR2YXIgZ29vZCA9IHRydWU7XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7IGdvb2QgPSBnb29kICYmIHRoaXMucmVtb3ZlVHdlZW4oYXJndW1lbnRzW2ldKTsgfVxuXHRcdFx0cmV0dXJuIGdvb2Q7XG5cdFx0fSBlbHNlIGlmIChsID09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHR2YXIgdHdlZW5zID0gdGhpcy5fdHdlZW5zO1xuXHRcdHZhciBpID0gdHdlZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRpZiAodHdlZW5zW2ldID09IHR3ZWVuKSB7XG5cdFx0XHRcdHR3ZWVucy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdGlmICh0d2Vlbi5kdXJhdGlvbiA+PSB0aGlzLmR1cmF0aW9uKSB7IHRoaXMudXBkYXRlRHVyYXRpb24oKTsgfVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGRzIGEgbGFiZWwgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319L3t7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2dvdG9BbmRTdG9wXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGFkZExhYmVsXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBUaGUgbGFiZWwgbmFtZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0aGlzIGxhYmVsIHJlcHJlc2VudHMuXG5cdCAqKi9cblx0cC5hZGRMYWJlbCA9IGZ1bmN0aW9uKGxhYmVsLCBwb3NpdGlvbikge1xuXHRcdHRoaXMuX2xhYmVsc1tsYWJlbF0gPSBwb3NpdGlvbjtcblx0XHR2YXIgbGlzdCA9IHRoaXMuX2xhYmVsTGlzdDtcblx0XHRpZiAobGlzdCkge1xuXHRcdFx0Zm9yICh2YXIgaT0gMCxsPWxpc3QubGVuZ3RoOyBpPGw7IGkrKykgeyBpZiAocG9zaXRpb24gPCBsaXN0W2ldLnBvc2l0aW9uKSB7IGJyZWFrOyB9IH1cblx0XHRcdGxpc3Quc3BsaWNlKGksIDAsIHtsYWJlbDpsYWJlbCwgcG9zaXRpb246cG9zaXRpb259KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIERlZmluZXMgbGFiZWxzIGZvciB1c2Ugd2l0aCBnb3RvQW5kUGxheS9TdG9wLiBPdmVyd3JpdGVzIGFueSBwcmV2aW91c2x5IHNldCBsYWJlbHMuXG5cdCAqIEBtZXRob2Qgc2V0TGFiZWxzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvIEFuIG9iamVjdCBkZWZpbmluZyBsYWJlbHMgZm9yIHVzaW5nIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319L3t7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2dvdG9BbmRTdG9wXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGluIHRoZSBmb3JtIGB7bGFiZWxOYW1lOnRpbWV9YCB3aGVyZSB0aW1lIGlzIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgYHVzZVRpY2tzYCBpcyBgdHJ1ZWApLlxuXHQgKiovXG5cdHAuc2V0TGFiZWxzID0gZnVuY3Rpb24obykge1xuXHRcdHRoaXMuX2xhYmVscyA9IG8gPyAgbyA6IHt9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGxhYmVscyBkZWZpbmVkIG9uIHRoaXMgdGltZWxpbmUuXG5cdCAqIEBtZXRob2QgZ2V0TGFiZWxzXG5cdCAqIEByZXR1cm4ge0FycmF5W09iamVjdF19IEEgc29ydGVkIGFycmF5IG9mIG9iamVjdHMgd2l0aCBsYWJlbCBhbmQgcG9zaXRpb24gcHJvcGVydGllcy5cblx0ICoqL1xuXHRwLmdldExhYmVscyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsaXN0ID0gdGhpcy5fbGFiZWxMaXN0O1xuXHRcdGlmICghbGlzdCkge1xuXHRcdFx0bGlzdCA9IHRoaXMuX2xhYmVsTGlzdCA9IFtdO1xuXHRcdFx0dmFyIGxhYmVscyA9IHRoaXMuX2xhYmVscztcblx0XHRcdGZvciAodmFyIG4gaW4gbGFiZWxzKSB7XG5cdFx0XHRcdGxpc3QucHVzaCh7bGFiZWw6biwgcG9zaXRpb246bGFiZWxzW25dfSk7XG5cdFx0XHR9XG5cdFx0XHRsaXN0LnNvcnQoZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYS5wb3NpdGlvbi0gYi5wb3NpdGlvbjsgfSk7XG5cdFx0fVxuXHRcdHJldHVybiBsaXN0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBsYWJlbCBvbiBvciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGN1cnJlbnQgcG9zaXRpb24uIEZvciBleGFtcGxlLCBnaXZlbiBhIHRpbWVsaW5lIHdpdGhcblx0ICogdHdvIGxhYmVscywgXCJmaXJzdFwiIG9uIGZyYW1lIGluZGV4IDQsIGFuZCBcInNlY29uZFwiIG9uIGZyYW1lIDgsIGdldEN1cnJlbnRMYWJlbCB3b3VsZCByZXR1cm46XG5cdCAqIDxVTD5cblx0ICogXHRcdDxMST5udWxsIGlmIHRoZSBjdXJyZW50IHBvc2l0aW9uIGlzIDIuPC9MST5cblx0ICogXHRcdDxMST5cImZpcnN0XCIgaWYgdGhlIGN1cnJlbnQgcG9zaXRpb24gaXMgNC48L0xJPlxuXHQgKiBcdFx0PExJPlwiZmlyc3RcIiBpZiB0aGUgY3VycmVudCBwb3NpdGlvbiBpcyA3LjwvTEk+XG5cdCAqIFx0XHQ8TEk+XCJzZWNvbmRcIiBpZiB0aGUgY3VycmVudCBwb3NpdGlvbiBpcyAxNS48L0xJPlxuXHQgKiA8L1VMPlxuXHQgKiBAbWV0aG9kIGdldEN1cnJlbnRMYWJlbFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IGxhYmVsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gbGFiZWxcblx0ICoqL1xuXHRwLmdldEN1cnJlbnRMYWJlbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuXHRcdHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uO1xuXHRcdHZhciBsID0gbGFiZWxzLmxlbmd0aDtcblx0XHRpZiAobCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGk8bDsgaSsrKSB7IGlmIChwb3MgPCBsYWJlbHNbaV0ucG9zaXRpb24pIHsgYnJlYWs7IH0gfVxuXHRcdFx0cmV0dXJuIChpPT0wKSA/IG51bGwgOiBsYWJlbHNbaS0xXS5sYWJlbDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVucGF1c2VzIHRoaXMgdGltZWxpbmUgYW5kIGp1bXBzIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gb3IgbGFiZWwuXG5cdCAqIEBtZXRob2QgZ290b0FuZFBsYXlcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBwb3NpdGlvbk9yTGFiZWwgVGhlIHBvc2l0aW9uIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgYHVzZVRpY2tzYCBpcyBgdHJ1ZWApXG5cdCAqIG9yIGxhYmVsIHRvIGp1bXAgdG8uXG5cdCAqKi9cblx0cC5nb3RvQW5kUGxheSA9IGZ1bmN0aW9uKHBvc2l0aW9uT3JMYWJlbCkge1xuXHRcdHRoaXMuc2V0UGF1c2VkKGZhbHNlKTtcblx0XHR0aGlzLl9nb3RvKHBvc2l0aW9uT3JMYWJlbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhdXNlcyB0aGlzIHRpbWVsaW5lIGFuZCBqdW1wcyB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIG9yIGxhYmVsLlxuXHQgKiBAbWV0aG9kIGdvdG9BbmRTdG9wXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gcG9zaXRpb25PckxhYmVsIFRoZSBwb3NpdGlvbiBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgYHRydWVgKSBvciBsYWJlbFxuXHQgKiB0byBqdW1wIHRvLlxuXHQgKiovXG5cdHAuZ290b0FuZFN0b3AgPSBmdW5jdGlvbihwb3NpdGlvbk9yTGFiZWwpIHtcblx0XHR0aGlzLnNldFBhdXNlZCh0cnVlKTtcblx0XHR0aGlzLl9nb3RvKHBvc2l0aW9uT3JMYWJlbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoZSB0aW1lbGluZSB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuXHQgKiBAbWV0aG9kIHNldFBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgcG9zaXRpb24gdG8gc2VlayB0byBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgYHRydWVgKS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthY3Rpb25zTW9kZV0gcGFyYW1ldGVyIHNwZWNpZnlpbmcgaG93IGFjdGlvbnMgYXJlIGhhbmRsZWQuIFNlZSB0aGUgVHdlZW4ge3sjY3Jvc3NMaW5rIFwiVHdlZW4vc2V0UG9zaXRpb25cIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kIGZvciBtb3JlIGRldGFpbHMuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB0aW1lbGluZSBpcyBjb21wbGV0ZSAoaWUuIHRoZSBmdWxsIHRpbWVsaW5lIGhhcyBydW4gJiB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZS9sb29wOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGlzIGBmYWxzZWApLlxuXHQgKiovXG5cdHAuc2V0UG9zaXRpb24gPSBmdW5jdGlvbih2YWx1ZSwgYWN0aW9uc01vZGUpIHtcblx0XHR2YXIgdCA9IHRoaXMuX2NhbGNQb3NpdGlvbih2YWx1ZSk7XG5cdFx0dmFyIGVuZCA9ICF0aGlzLmxvb3AgJiYgdmFsdWUgPj0gdGhpcy5kdXJhdGlvbjtcblx0XHRpZiAodCA9PSB0aGlzLl9wcmV2UG9zKSB7IHJldHVybiBlbmQ7IH1cblx0XHR0aGlzLl9wcmV2UG9zaXRpb24gPSB2YWx1ZTtcblx0XHR0aGlzLnBvc2l0aW9uID0gdGhpcy5fcHJldlBvcyA9IHQ7IC8vIGluIGNhc2UgYW4gYWN0aW9uIGNoYW5nZXMgdGhlIGN1cnJlbnQgZnJhbWUuXG5cdFx0Zm9yICh2YXIgaT0wLCBsPXRoaXMuX3R3ZWVucy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR0aGlzLl90d2VlbnNbaV0uc2V0UG9zaXRpb24odCwgYWN0aW9uc01vZGUpO1xuXHRcdFx0aWYgKHQgIT0gdGhpcy5fcHJldlBvcykgeyByZXR1cm4gZmFsc2U7IH0gLy8gYW4gYWN0aW9uIGNoYW5nZWQgdGhpcyB0aW1lbGluZSdzIHBvc2l0aW9uLlxuXHRcdH1cblx0XHRpZiAoZW5kKSB7IHRoaXMuc2V0UGF1c2VkKHRydWUpOyB9XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiY2hhbmdlXCIpO1xuXHRcdHJldHVybiBlbmQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhdXNlcyBvciBwbGF5cyB0aGlzIHRpbWVsaW5lLlxuXHQgKiBAbWV0aG9kIHNldFBhdXNlZFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0d2VlbiBzaG91bGQgYmUgcGF1c2VkIChgdHJ1ZWApIG9yIHBsYXllZCAoYGZhbHNlYCkuXG5cdCAqKi9cblx0cC5zZXRQYXVzZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHRoaXMuX3BhdXNlZCA9ICEhdmFsdWU7IFxuXHRcdGNyZWF0ZWpzLlR3ZWVuLl9yZWdpc3Rlcih0aGlzLCAhdmFsdWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZWNhbGN1bGF0ZXMgdGhlIGR1cmF0aW9uIG9mIHRoZSB0aW1lbGluZS4gVGhlIGR1cmF0aW9uIGlzIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCB3aGVuIHR3ZWVucyBhcmUgYWRkZWQgb3IgcmVtb3ZlZCxcblx0ICogYnV0IHRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBpZiB5b3UgbW9kaWZ5IGEgdHdlZW4gYWZ0ZXIgaXQgd2FzIGFkZGVkIHRvIHRoZSB0aW1lbGluZS5cblx0ICogQG1ldGhvZCB1cGRhdGVEdXJhdGlvblxuXHQgKiovXG5cdHAudXBkYXRlRHVyYXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmR1cmF0aW9uID0gMDtcblx0XHRmb3IgKHZhciBpPTAsbD10aGlzLl90d2VlbnMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fdHdlZW5zW2ldO1xuXHRcdFx0aWYgKHR3ZWVuLmR1cmF0aW9uID4gdGhpcy5kdXJhdGlvbikgeyB0aGlzLmR1cmF0aW9uID0gdHdlZW4uZHVyYXRpb247IH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoaXMgdGltZWxpbmUgYnkgdGhlIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZSBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgYHRydWVgKS5cblx0ICogVGhpcyBpcyBub3JtYWxseSBjYWxsZWQgYXV0b21hdGljYWxseSBieSB0aGUgVHdlZW4gZW5naW5lICh2aWEgdGhlIHt7I2Nyb3NzTGluayBcIlR3ZWVuL3RpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQpLCBidXQgaXMgZXhwb3NlZCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCB0aWNrXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YSBUaGUgdGltZSB0byBhZHZhbmNlIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgdXNlVGlja3MgaXMgdHJ1ZSkuXG5cdCAqKi9cblx0cC50aWNrID0gZnVuY3Rpb24oZGVsdGEpIHtcblx0XHR0aGlzLnNldFBvc2l0aW9uKHRoaXMuX3ByZXZQb3NpdGlvbitkZWx0YSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIElmIGEgbnVtZXJpYyBwb3NpdGlvbiBpcyBwYXNzZWQsIGl0IGlzIHJldHVybmVkIHVuY2hhbmdlZC4gSWYgYSBzdHJpbmcgaXMgcGFzc2VkLCB0aGUgcG9zaXRpb24gb2YgdGhlXG5cdCAqIGNvcnJlc3BvbmRpbmcgZnJhbWUgbGFiZWwgd2lsbCBiZSByZXR1cm5lZCwgb3IgYG51bGxgIGlmIGEgbWF0Y2hpbmcgbGFiZWwgaXMgbm90IGRlZmluZWQuXG5cdCAqIEBtZXRob2QgcmVzb2x2ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHBvc2l0aW9uT3JMYWJlbCBBIG51bWVyaWMgcG9zaXRpb24gdmFsdWUgb3IgbGFiZWwgc3RyaW5nLlxuXHQgKiovXG5cdHAucmVzb2x2ZSA9IGZ1bmN0aW9uKHBvc2l0aW9uT3JMYWJlbCkge1xuXHRcdHZhciBwb3MgPSBOdW1iZXIocG9zaXRpb25PckxhYmVsKTtcblx0XHRpZiAoaXNOYU4ocG9zKSkgeyBwb3MgPSB0aGlzLl9sYWJlbHNbcG9zaXRpb25PckxhYmVsXTsgfVxuXHRcdHJldHVybiBwb3M7XG5cdH07XG5cblx0LyoqXG5cdCogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0KiBAbWV0aG9kIHRvU3RyaW5nXG5cdCogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1RpbWVsaW5lXVwiO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3coXCJUaW1lbGluZSBjYW4gbm90IGJlIGNsb25lZC5cIilcblx0fTtcblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfZ290b1xuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gcG9zaXRpb25PckxhYmVsXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9nb3RvID0gZnVuY3Rpb24ocG9zaXRpb25PckxhYmVsKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMucmVzb2x2ZShwb3NpdGlvbk9yTGFiZWwpO1xuXHRcdGlmIChwb3MgIT0gbnVsbCkgeyB0aGlzLnNldFBvc2l0aW9uKHBvcyk7IH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9jYWxjUG9zaXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2NhbGNQb3NpdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlIDwgMCkgeyByZXR1cm4gMDsgfVxuXHRcdGlmICh2YWx1ZSA8IHRoaXMuZHVyYXRpb24pIHsgcmV0dXJuIHZhbHVlOyB9XG5cdFx0cmV0dXJuIHRoaXMubG9vcCA/IHZhbHVlJXRoaXMuZHVyYXRpb24gOiB0aGlzLmR1cmF0aW9uO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLlRpbWVsaW5lID0gY3JlYXRlanMucHJvbW90ZShUaW1lbGluZSwgXCJFdmVudERpc3BhdGNoZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBFYXNlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgRWFzZSBjbGFzcyBwcm92aWRlcyBhIGNvbGxlY3Rpb24gb2YgZWFzaW5nIGZ1bmN0aW9ucyBmb3IgdXNlIHdpdGggVHdlZW5KUy4gSXQgZG9lcyBub3QgdXNlIHRoZSBzdGFuZGFyZCA0IHBhcmFtXG5cdCAqIGVhc2luZyBzaWduYXR1cmUuIEluc3RlYWQgaXQgdXNlcyBhIHNpbmdsZSBwYXJhbSB3aGljaCBpbmRpY2F0ZXMgdGhlIGN1cnJlbnQgbGluZWFyIHJhdGlvICgwIHRvIDEpIG9mIHRoZSB0d2Vlbi5cblx0ICpcblx0ICogTW9zdCBtZXRob2RzIG9uIEVhc2UgY2FuIGJlIHBhc3NlZCBkaXJlY3RseSBhcyBlYXNpbmcgZnVuY3Rpb25zOlxuXHQgKlxuXHQgKiAgICAgIFR3ZWVuLmdldCh0YXJnZXQpLnRvKHt4OjEwMH0sIDUwMCwgRWFzZS5saW5lYXIpO1xuXHQgKlxuXHQgKiBIb3dldmVyLCBtZXRob2RzIGJlZ2lubmluZyB3aXRoIFwiZ2V0XCIgd2lsbCByZXR1cm4gYW4gZWFzaW5nIGZ1bmN0aW9uIGJhc2VkIG9uIHBhcmFtZXRlciB2YWx1ZXM6XG5cdCAqXG5cdCAqICAgICAgVHdlZW4uZ2V0KHRhcmdldCkudG8oe3k6MjAwfSwgNTAwLCBFYXNlLmdldFBvd0luKDIuMikpO1xuXHQgKlxuXHQgKiBQbGVhc2Ugc2VlIHRoZSA8YSBocmVmPVwiaHR0cDovL3d3dy5jcmVhdGVqcy5jb20vRGVtb3MvVHdlZW5KUy9Ud2Vlbl9TcGFya1RhYmxlXCI+c3BhcmsgdGFibGUgZGVtbzwvYT4gZm9yIGFuXG5cdCAqIG92ZXJ2aWV3IG9mIHRoZSBkaWZmZXJlbnQgZWFzZSB0eXBlcyBvbiA8YSBocmVmPVwiaHR0cDovL3R3ZWVuanMuY29tXCI+VHdlZW5KUy5jb208L2E+LlxuXHQgKlxuXHQgKiA8ZW0+RXF1YXRpb25zIGRlcml2ZWQgZnJvbSB3b3JrIGJ5IFJvYmVydCBQZW5uZXIuPC9lbT5cblx0ICogQGNsYXNzIEVhc2Vcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdGZ1bmN0aW9uIEVhc2UoKSB7XG5cdFx0dGhyb3cgXCJFYXNlIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWQuXCI7XG5cdH1cblxuXG4vLyBzdGF0aWMgbWV0aG9kcyBhbmQgcHJvcGVydGllc1xuXHQvKipcblx0ICogQG1ldGhvZCBsaW5lYXJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5saW5lYXIgPSBmdW5jdGlvbih0KSB7IHJldHVybiB0OyB9O1xuXG5cdC8qKlxuXHQgKiBJZGVudGljYWwgdG8gbGluZWFyLlxuXHQgKiBAbWV0aG9kIG5vbmVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5ub25lID0gRWFzZS5saW5lYXI7XG5cblx0LyoqXG5cdCAqIE1pbWljcyB0aGUgc2ltcGxlIC0xMDAgdG8gMTAwIGVhc2luZyBpbiBGbGFzaCBQcm8uXG5cdCAqIEBtZXRob2QgZ2V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgQSB2YWx1ZSBmcm9tIC0xIChlYXNlIGluKSB0byAxIChlYXNlIG91dCkgaW5kaWNhdGluZyB0aGUgc3RyZW5ndGggYW5kIGRpcmVjdGlvbiBvZiB0aGUgZWFzZS5cblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldCA9IGZ1bmN0aW9uKGFtb3VudCkge1xuXHRcdGlmIChhbW91bnQgPCAtMSkgeyBhbW91bnQgPSAtMTsgfVxuXHRcdGlmIChhbW91bnQgPiAxKSB7IGFtb3VudCA9IDE7IH1cblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0aWYgKGFtb3VudD09MCkgeyByZXR1cm4gdDsgfVxuXHRcdFx0aWYgKGFtb3VudDwwKSB7IHJldHVybiB0Kih0Ki1hbW91bnQrMSthbW91bnQpOyB9XG5cdFx0XHRyZXR1cm4gdCooKDItdCkqYW1vdW50KygxLWFtb3VudCkpO1xuXHRcdH07XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBleHBvbmVudGlhbCBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldFBvd0luXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3cgVGhlIGV4cG9uZW50IHRvIHVzZSAoZXguIDMgd291bGQgcmV0dXJuIGEgY3ViaWMgZWFzZSkuXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRQb3dJbiA9IGZ1bmN0aW9uKHBvdykge1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5wb3codCxwb3cpO1xuXHRcdH07XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBleHBvbmVudGlhbCBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldFBvd091dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG93IFRoZSBleHBvbmVudCB0byB1c2UgKGV4LiAzIHdvdWxkIHJldHVybiBhIGN1YmljIGVhc2UpLlxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0UG93T3V0ID0gZnVuY3Rpb24ocG93KSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiAxLU1hdGgucG93KDEtdCxwb3cpO1xuXHRcdH07XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBleHBvbmVudGlhbCBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldFBvd0luT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3cgVGhlIGV4cG9uZW50IHRvIHVzZSAoZXguIDMgd291bGQgcmV0dXJuIGEgY3ViaWMgZWFzZSkuXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRQb3dJbk91dCA9IGZ1bmN0aW9uKHBvdykge1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRpZiAoKHQqPTIpPDEpIHJldHVybiAwLjUqTWF0aC5wb3codCxwb3cpO1xuXHRcdFx0cmV0dXJuIDEtMC41Kk1hdGguYWJzKE1hdGgucG93KDItdCxwb3cpKTtcblx0XHR9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1YWRJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1YWRJbiA9IEVhc2UuZ2V0UG93SW4oMik7XG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1YWRPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWFkT3V0ID0gRWFzZS5nZXRQb3dPdXQoMik7XG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1YWRJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1YWRJbk91dCA9IEVhc2UuZ2V0UG93SW5PdXQoMik7XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgY3ViaWNJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmN1YmljSW4gPSBFYXNlLmdldFBvd0luKDMpO1xuXHQvKipcblx0ICogQG1ldGhvZCBjdWJpY091dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmN1YmljT3V0ID0gRWFzZS5nZXRQb3dPdXQoMyk7XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGN1YmljSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5jdWJpY0luT3V0ID0gRWFzZS5nZXRQb3dJbk91dCgzKTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBxdWFydEluXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVhcnRJbiA9IEVhc2UuZ2V0UG93SW4oNCk7XG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1YXJ0T3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVhcnRPdXQgPSBFYXNlLmdldFBvd091dCg0KTtcblx0LyoqXG5cdCAqIEBtZXRob2QgcXVhcnRJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1YXJ0SW5PdXQgPSBFYXNlLmdldFBvd0luT3V0KDQpO1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1aW50SW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWludEluID0gRWFzZS5nZXRQb3dJbig1KTtcblx0LyoqXG5cdCAqIEBtZXRob2QgcXVpbnRPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWludE91dCA9IEVhc2UuZ2V0UG93T3V0KDUpO1xuXHQvKipcblx0ICogQG1ldGhvZCBxdWludEluT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVpbnRJbk91dCA9IEVhc2UuZ2V0UG93SW5PdXQoNSk7XG5cblx0LyoqXG5cdCAqIEBtZXRob2Qgc2luZUluXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2Uuc2luZUluID0gZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAxLU1hdGguY29zKHQqTWF0aC5QSS8yKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBzaW5lT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2Uuc2luZU91dCA9IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gTWF0aC5zaW4odCpNYXRoLlBJLzIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHNpbmVJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnNpbmVJbk91dCA9IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLTAuNSooTWF0aC5jb3MoTWF0aC5QSSp0KSAtIDEpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb25maWd1cmFibGUgXCJiYWNrIGluXCIgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRCYWNrSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCBUaGUgc3RyZW5ndGggb2YgdGhlIGVhc2UuXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRCYWNrSW4gPSBmdW5jdGlvbihhbW91bnQpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0cmV0dXJuIHQqdCooKGFtb3VudCsxKSp0LWFtb3VudCk7XG5cdFx0fTtcblx0fTtcblx0LyoqXG5cdCAqIEBtZXRob2QgYmFja0luXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuYmFja0luID0gRWFzZS5nZXRCYWNrSW4oMS43KTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIFwiYmFjayBvdXRcIiBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldEJhY2tPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCBUaGUgc3RyZW5ndGggb2YgdGhlIGVhc2UuXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRCYWNrT3V0ID0gZnVuY3Rpb24oYW1vdW50KSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiAoLS10KnQqKChhbW91bnQrMSkqdCArIGFtb3VudCkgKyAxKTtcblx0XHR9O1xuXHR9O1xuXHQvKipcblx0ICogQG1ldGhvZCBiYWNrT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuYmFja091dCA9IEVhc2UuZ2V0QmFja091dCgxLjcpO1xuXG5cdC8qKlxuXHQgKiBDb25maWd1cmFibGUgXCJiYWNrIGluIG91dFwiIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0QmFja0luT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgVGhlIHN0cmVuZ3RoIG9mIHRoZSBlYXNlLlxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0QmFja0luT3V0ID0gZnVuY3Rpb24oYW1vdW50KSB7XG5cdFx0YW1vdW50Kj0xLjUyNTtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0aWYgKCh0Kj0yKTwxKSByZXR1cm4gMC41Kih0KnQqKChhbW91bnQrMSkqdC1hbW91bnQpKTtcblx0XHRcdHJldHVybiAwLjUqKCh0LT0yKSp0KigoYW1vdW50KzEpKnQrYW1vdW50KSsyKTtcblx0XHR9O1xuXHR9O1xuXHQvKipcblx0ICogQG1ldGhvZCBiYWNrSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5iYWNrSW5PdXQgPSBFYXNlLmdldEJhY2tJbk91dCgxLjcpO1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGNpcmNJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmNpcmNJbiA9IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLShNYXRoLnNxcnQoMS10KnQpLSAxKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBjaXJjT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuY2lyY091dCA9IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KDEtKC0tdCkqdCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgY2lyY0luT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuY2lyY0luT3V0ID0gZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCo9MikgPCAxKSByZXR1cm4gLTAuNSooTWF0aC5zcXJ0KDEtdCp0KS0xKTtcblx0XHRyZXR1cm4gMC41KihNYXRoLnNxcnQoMS0odC09MikqdCkrMSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgYm91bmNlSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5ib3VuY2VJbiA9IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gMS1FYXNlLmJvdW5jZU91dCgxLXQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGJvdW5jZU91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmJvdW5jZU91dCA9IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodCA8IDEvMi43NSkge1xuXHRcdFx0cmV0dXJuICg3LjU2MjUqdCp0KTtcblx0XHR9IGVsc2UgaWYgKHQgPCAyLzIuNzUpIHtcblx0XHRcdHJldHVybiAoNy41NjI1Kih0LT0xLjUvMi43NSkqdCswLjc1KTtcblx0XHR9IGVsc2UgaWYgKHQgPCAyLjUvMi43NSkge1xuXHRcdFx0cmV0dXJuICg3LjU2MjUqKHQtPTIuMjUvMi43NSkqdCswLjkzNzUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gKDcuNTYyNSoodC09Mi42MjUvMi43NSkqdCArMC45ODQzNzUpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBib3VuY2VJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmJvdW5jZUluT3V0ID0gZnVuY3Rpb24odCkge1xuXHRcdGlmICh0PDAuNSkgcmV0dXJuIEVhc2UuYm91bmNlSW4gKHQqMikgKiAuNTtcblx0XHRyZXR1cm4gRWFzZS5ib3VuY2VPdXQodCoyLTEpKjAuNSswLjU7XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBlbGFzdGljIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0RWxhc3RpY0luXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbXBsaXR1ZGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBlcmlvZFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0RWxhc3RpY0luID0gZnVuY3Rpb24oYW1wbGl0dWRlLHBlcmlvZCkge1xuXHRcdHZhciBwaTIgPSBNYXRoLlBJKjI7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdGlmICh0PT0wIHx8IHQ9PTEpIHJldHVybiB0O1xuXHRcdFx0dmFyIHMgPSBwZXJpb2QvcGkyKk1hdGguYXNpbigxL2FtcGxpdHVkZSk7XG5cdFx0XHRyZXR1cm4gLShhbXBsaXR1ZGUqTWF0aC5wb3coMiwxMCoodC09MSkpKk1hdGguc2luKCh0LXMpKnBpMi9wZXJpb2QpKTtcblx0XHR9O1xuXHR9O1xuXHQvKipcblx0ICogQG1ldGhvZCBlbGFzdGljSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5lbGFzdGljSW4gPSBFYXNlLmdldEVsYXN0aWNJbigxLDAuMyk7XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBlbGFzdGljIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0RWxhc3RpY091dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW1wbGl0dWRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwZXJpb2Rcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldEVsYXN0aWNPdXQgPSBmdW5jdGlvbihhbXBsaXR1ZGUscGVyaW9kKSB7XG5cdFx0dmFyIHBpMiA9IE1hdGguUEkqMjtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0aWYgKHQ9PTAgfHwgdD09MSkgcmV0dXJuIHQ7XG5cdFx0XHR2YXIgcyA9IHBlcmlvZC9waTIgKiBNYXRoLmFzaW4oMS9hbXBsaXR1ZGUpO1xuXHRcdFx0cmV0dXJuIChhbXBsaXR1ZGUqTWF0aC5wb3coMiwtMTAqdCkqTWF0aC5zaW4oKHQtcykqcGkyL3BlcmlvZCApKzEpO1xuXHRcdH07XG5cdH07XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGVsYXN0aWNPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5lbGFzdGljT3V0ID0gRWFzZS5nZXRFbGFzdGljT3V0KDEsMC4zKTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIGVsYXN0aWMgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRFbGFzdGljSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFtcGxpdHVkZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcGVyaW9kXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRFbGFzdGljSW5PdXQgPSBmdW5jdGlvbihhbXBsaXR1ZGUscGVyaW9kKSB7XG5cdFx0dmFyIHBpMiA9IE1hdGguUEkqMjtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0dmFyIHMgPSBwZXJpb2QvcGkyICogTWF0aC5hc2luKDEvYW1wbGl0dWRlKTtcblx0XHRcdGlmICgodCo9Mik8MSkgcmV0dXJuIC0wLjUqKGFtcGxpdHVkZSpNYXRoLnBvdygyLDEwKih0LT0xKSkqTWF0aC5zaW4oICh0LXMpKnBpMi9wZXJpb2QgKSk7XG5cdFx0XHRyZXR1cm4gYW1wbGl0dWRlKk1hdGgucG93KDIsLTEwKih0LT0xKSkqTWF0aC5zaW4oKHQtcykqcGkyL3BlcmlvZCkqMC41KzE7XG5cdFx0fTtcblx0fTtcblx0LyoqXG5cdCAqIEBtZXRob2QgZWxhc3RpY0luT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuZWxhc3RpY0luT3V0ID0gRWFzZS5nZXRFbGFzdGljSW5PdXQoMSwwLjMqMS41KTtcblxuXHRjcmVhdGVqcy5FYXNlID0gRWFzZTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIE1vdGlvbkd1aWRlUGx1Z2luLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBBIFR3ZWVuSlMgcGx1Z2luIGZvciB3b3JraW5nIHdpdGggbW90aW9uIGd1aWRlcy5cblx0ICpcblx0ICogVG8gdXNlLCBpbnN0YWxsIHRoZSBwbHVnaW4gYWZ0ZXIgVHdlZW5KUyBoYXMgbG9hZGVkLiBOZXh0IHR3ZWVuIHRoZSAnZ3VpZGUnIHByb3BlcnR5IHdpdGggYW4gb2JqZWN0IGFzIGRldGFpbGVkIGJlbG93LlxuXHQgKlxuXHQgKiAgICAgICBjcmVhdGVqcy5Nb3Rpb25HdWlkZVBsdWdpbi5pbnN0YWxsKCk7XG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICAvLyBVc2luZyBhIE1vdGlvbiBHdWlkZVxuXHQgKlx0ICAgIGNyZWF0ZWpzLlR3ZWVuLmdldCh0YXJnZXQpLnRvKHtndWlkZTp7IHBhdGg6WzAsMCwgMCwyMDAsMjAwLDIwMCwgMjAwLDAsMCwwXSB9fSw3MDAwKTtcblx0ICpcdCAgICAvLyBWaXN1YWxpemluZyB0aGUgbGluZVxuXHQgKlx0ICAgIGdyYXBoaWNzLm1vdmVUbygwLDApLmN1cnZlVG8oMCwyMDAsMjAwLDIwMCkuY3VydmVUbygyMDAsMCwwLDApO1xuXHQgKlxuXHQgKiBFYWNoIHBhdGggbmVlZHMgcHJlLWNvbXB1dGF0aW9uIHRvIGVuc3VyZSB0aGVyZSdzIGZhc3QgcGVyZm9ybWFuY2UuIEJlY2F1c2Ugb2YgdGhlIHByZS1jb21wdXRhdGlvbiB0aGVyZSdzIG5vXG5cdCAqIGJ1aWx0IGluIHN1cHBvcnQgZm9yIHBhdGggY2hhbmdlcyBtaWQgdHdlZW4uIFRoZXNlIGFyZSB0aGUgR3VpZGUgT2JqZWN0J3MgcHJvcGVydGllczo8VUw+XG5cdCAqICAgICAgPExJPiBwYXRoOiBSZXF1aXJlZCwgQXJyYXkgOiBUaGUgeC95IHBvaW50cyB1c2VkIHRvIGRyYXcgdGhlIHBhdGggd2l0aCBhIG1vdmVUbyBhbmQgMSB0byBuIGN1cnZlVG8gY2FsbHMuPC9MST5cblx0ICogICAgICA8TEk+IHN0YXJ0OiBPcHRpb25hbCwgMC0xIDogSW5pdGlhbCBwb3NpdGlvbiwgZGVmYXVsdCAwIGV4Y2VwdCBmb3Igd2hlbiBjb250aW51aW5nIGFsb25nIHRoZSBzYW1lIHBhdGguPC9MST5cblx0ICogICAgICA8TEk+IGVuZDogT3B0aW9uYWwsIDAtMSA6IEZpbmFsIHBvc2l0aW9uLCBkZWZhdWx0IDEgaWYgbm90IHNwZWNpZmllZC48L0xJPlxuXHQgKiAgICAgIDxMST4gb3JpZW50OiBPcHRpb25hbCwgc3RyaW5nIDogXCJmaXhlZFwiL1wiYXV0b1wiL1wiY3dcIi9cImNjd1wiPFVMPlxuXHQgKlx0XHRcdFx0PExJPlwiZml4ZWRcIiBmb3JjZXMgdGhlIG9iamVjdCB0byBmYWNlIGRvd24gdGhlIHBhdGggYWxsIG1vdmVtZW50IChyZWxhdGl2ZSB0byBzdGFydCByb3RhdGlvbiksPC9MST5cblx0ICogICAgICBcdFx0PExJPlwiYXV0b1wiIHJvdGF0ZXMgdGhlIG9iamVjdCBhbG9uZyB0aGUgcGF0aCByZWxhdGl2ZSB0byB0aGUgbGluZS48L0xJPlxuXHQgKiAgICAgIFx0XHQ8TEk+XCJjd1wiL1wiY2N3XCIgZm9yY2UgY2xvY2t3aXNlIG9yIGNvdW50ZXIgY2xvY2t3aXNlIHJvdGF0aW9ucyBpbmNsdWRpbmcgZmxhc2ggbGlrZSBiZWhhdmlvdXI8L0xJPlxuXHQgKiBcdFx0PC9VTD48L0xJPlxuXHQgKiA8L1VMPlxuXHQgKiBHdWlkZSBvYmplY3RzIHNob3VsZCBub3QgYmUgc2hhcmVkIGJldHdlZW4gdHdlZW5zIGV2ZW4gaWYgYWxsIHByb3BlcnRpZXMgYXJlIGlkZW50aWNhbCwgdGhlIGxpYnJhcnkgc3RvcmVzXG5cdCAqIGluZm9ybWF0aW9uIG9uIHRoZXNlIG9iamVjdHMgaW4gdGhlIGJhY2tncm91bmQgYW5kIHNoYXJpbmcgdGhlbSBjYW4gY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvdXIuIFZhbHVlc1xuXHQgKiBvdXRzaWRlIDAtMSByYW5nZSBvZiB0d2VlbnMgd2lsbCBiZSBhIFwiYmVzdCBndWVzc1wiIGZyb20gdGhlIGFwcHJvcHJpYXRlIHBhcnQgb2YgdGhlIGRlZmluZWQgY3VydmUuXG5cdCAqXG5cdCAqIEBjbGFzcyBNb3Rpb25HdWlkZVBsdWdpblxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBNb3Rpb25HdWlkZVBsdWdpbigpIHtcblx0XHR0aHJvdyhcIk1vdGlvbkd1aWRlUGx1Z2luIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWQuXCIpXG5cdH07XG5cblxuLy8gc3RhdGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcHJpb3JpdHlcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0TW90aW9uR3VpZGVQbHVnaW4ucHJpb3JpdHkgPSAwOyAvLyBoaWdoIHByaW9yaXR5LCBzaG91bGQgcnVuIHNvb25lclxuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgdGVtcG9yYXJ5IHZhcmlhYmxlIHN0b3JhZ2Vcblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0TW90aW9uR3VpZGVQbHVnaW4uX3JvdE9mZlM7XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgdGVtcG9yYXJ5IHZhcmlhYmxlIHN0b3JhZ2Vcblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0TW90aW9uR3VpZGVQbHVnaW4uX3JvdE9mZkU7XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgdGVtcG9yYXJ5IHZhcmlhYmxlIHN0b3JhZ2Vcblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0TW90aW9uR3VpZGVQbHVnaW4uX3JvdE5vcm1TO1xuXHQvKipcblx0ICogQHByb3BlcnR5IHRlbXBvcmFyeSB2YXJpYWJsZSBzdG9yYWdlXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLl9yb3ROb3JtRTtcblxuXG4vLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogSW5zdGFsbHMgdGhpcyBwbHVnaW4gZm9yIHVzZSB3aXRoIFR3ZWVuSlMuIENhbGwgdGhpcyBvbmNlIGFmdGVyIFR3ZWVuSlMgaXMgbG9hZGVkIHRvIGVuYWJsZSB0aGlzIHBsdWdpbi5cblx0ICogQG1ldGhvZCBpbnN0YWxsXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRNb3Rpb25HdWlkZVBsdWdpbi5pbnN0YWxsID0gZnVuY3Rpb24oKSB7XG5cdFx0Y3JlYXRlanMuVHdlZW4uaW5zdGFsbFBsdWdpbihNb3Rpb25HdWlkZVBsdWdpbiwgW1wiZ3VpZGVcIiwgXCJ4XCIsIFwieVwiLCBcInJvdGF0aW9uXCJdKTtcblx0XHRyZXR1cm4gY3JlYXRlanMuVHdlZW4uSUdOT1JFO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGluaXRcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0TW90aW9uR3VpZGVQbHVnaW4uaW5pdCA9IGZ1bmN0aW9uKHR3ZWVuLCBwcm9wLCB2YWx1ZSkge1xuXHRcdHZhciB0YXJnZXQgPSB0d2Vlbi50YXJnZXQ7XG5cdFx0aWYoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShcInhcIikpeyB0YXJnZXQueCA9IDA7IH1cblx0XHRpZighdGFyZ2V0Lmhhc093blByb3BlcnR5KFwieVwiKSl7IHRhcmdldC55ID0gMDsgfVxuXHRcdGlmKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoXCJyb3RhdGlvblwiKSl7IHRhcmdldC5yb3RhdGlvbiA9IDA7IH1cblxuXHRcdGlmKHByb3A9PVwicm90YXRpb25cIil7IHR3ZWVuLl9fbmVlZHNSb3QgPSB0cnVlOyB9XG5cdFx0cmV0dXJuIHByb3A9PVwiZ3VpZGVcIj9udWxsOnZhbHVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHN0ZXBcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0TW90aW9uR3VpZGVQbHVnaW4uc3RlcCA9IGZ1bmN0aW9uKHR3ZWVuLCBwcm9wLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgaW5qZWN0UHJvcHMpIHtcblx0XHQvLyBvdGhlciBwcm9wc1xuXHRcdGlmKHByb3AgPT0gXCJyb3RhdGlvblwiKXtcblx0XHRcdHR3ZWVuLl9fcm90R2xvYmFsUyA9IHN0YXJ0VmFsdWU7XG5cdFx0XHR0d2Vlbi5fX3JvdEdsb2JhbEUgPSBlbmRWYWx1ZTtcblx0XHRcdE1vdGlvbkd1aWRlUGx1Z2luLnRlc3RSb3REYXRhKHR3ZWVuLCBpbmplY3RQcm9wcyk7XG5cdFx0fVxuXHRcdGlmKHByb3AgIT0gXCJndWlkZVwiKXsgcmV0dXJuIGVuZFZhbHVlOyB9XG5cblx0XHQvLyBndWlkZSBvbmx5IGluZm9ybWF0aW9uIC0gU3RhcnQgLVxuXHRcdHZhciB0ZW1wLCBkYXRhID0gZW5kVmFsdWU7XG5cdFx0aWYoIWRhdGEuaGFzT3duUHJvcGVydHkoXCJwYXRoXCIpKXsgZGF0YS5wYXRoID0gW107IH1cblx0XHR2YXIgcGF0aCA9IGRhdGEucGF0aDtcblx0XHRpZighZGF0YS5oYXNPd25Qcm9wZXJ0eShcImVuZFwiKSl7IGRhdGEuZW5kID0gMTsgfVxuXHRcdGlmKCFkYXRhLmhhc093blByb3BlcnR5KFwic3RhcnRcIikpe1xuXHRcdFx0ZGF0YS5zdGFydCA9IChzdGFydFZhbHVlJiZzdGFydFZhbHVlLmhhc093blByb3BlcnR5KFwiZW5kXCIpJiZzdGFydFZhbHVlLnBhdGg9PT1wYXRoKT9zdGFydFZhbHVlLmVuZDowO1xuXHRcdH1cblxuXHRcdC8vIEZpZ3VyZSBvdXQgc3VibGluZSBpbmZvcm1hdGlvblxuXHRcdGlmKGRhdGEuaGFzT3duUHJvcGVydHkoXCJfc2VnbWVudHNcIikgJiYgZGF0YS5fbGVuZ3RoKXsgcmV0dXJuIGVuZFZhbHVlOyB9XG5cdFx0dmFyIGwgPSBwYXRoLmxlbmd0aDtcblx0XHR2YXIgYWNjdXJhY3kgPSAxMDtcdFx0Ly8gQWRqdXN0IHRvIGltcHJvdmUgbGluZSBmb2xsb3dpbmcgcHJlY2lzaW9uIGJ1dCBzYWNyaWZpY2UgcGVyZm9ybWFuY2UgKCMgb2Ygc2VnKVxuXHRcdGlmKGwgPj0gNiAmJiAobC0yKSAlIDQgPT0gMCl7XHQvLyBFbm91Z2ggcG9pbnRzICYmIGNvbnRhaW5zIGNvcnJlY3QgbnVtYmVyIHBlciBlbnRyeSBpZ25vcmluZyBzdGFydFxuXHRcdFx0ZGF0YS5fc2VnbWVudHMgPSBbXTtcblx0XHRcdGRhdGEuX2xlbmd0aCA9IDA7XG5cdFx0XHRmb3IodmFyIGk9MjsgaTxsOyBpKz00KXtcblx0XHRcdFx0dmFyIHN4ID0gcGF0aFtpLTJdLCBzeSA9IHBhdGhbaS0xXTtcblx0XHRcdFx0dmFyIGN4ID0gcGF0aFtpKzBdLCBjeSA9IHBhdGhbaSsxXTtcblx0XHRcdFx0dmFyIGV4ID0gcGF0aFtpKzJdLCBleSA9IHBhdGhbaSszXTtcblx0XHRcdFx0dmFyIG9sZFggPSBzeCwgb2xkWSA9IHN5O1xuXHRcdFx0XHR2YXIgdGVtcFgsIHRlbXBZLCB0b3RhbCA9IDA7XG5cdFx0XHRcdHZhciBzdWJsaW5lcyA9IFtdO1xuXHRcdFx0XHRmb3IodmFyIGo9MTsgajw9YWNjdXJhY3k7IGorKyl7XG5cdFx0XHRcdFx0dmFyIHQgPSBqL2FjY3VyYWN5O1xuXHRcdFx0XHRcdHZhciBpbnYgPSAxIC0gdDtcblx0XHRcdFx0XHR0ZW1wWCA9IGludippbnYgKiBzeCArIDIgKiBpbnYgKiB0ICogY3ggKyB0KnQgKiBleDtcblx0XHRcdFx0XHR0ZW1wWSA9IGludippbnYgKiBzeSArIDIgKiBpbnYgKiB0ICogY3kgKyB0KnQgKiBleTtcblx0XHRcdFx0XHR0b3RhbCArPSBzdWJsaW5lc1tzdWJsaW5lcy5wdXNoKE1hdGguc3FydCgodGVtcD10ZW1wWC1vbGRYKSp0ZW1wICsgKHRlbXA9dGVtcFktb2xkWSkqdGVtcCkpLTFdO1xuXHRcdFx0XHRcdG9sZFggPSB0ZW1wWDtcblx0XHRcdFx0XHRvbGRZID0gdGVtcFk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YS5fc2VnbWVudHMucHVzaCh0b3RhbCk7XG5cdFx0XHRcdGRhdGEuX3NlZ21lbnRzLnB1c2goc3VibGluZXMpO1xuXHRcdFx0XHRkYXRhLl9sZW5ndGggKz0gdG90YWw7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93KFwiaW52YWxpZCAncGF0aCcgZGF0YSwgcGxlYXNlIHNlZSBkb2N1bWVudGF0aW9uIGZvciB2YWxpZCBwYXRoc1wiKTtcblx0XHR9XG5cblx0XHQvLyBTZXR1cCB4L3kgdHdlZW5zXG5cdFx0dGVtcCA9IGRhdGEub3JpZW50O1xuXHRcdGRhdGEub3JpZW50ID0gdHJ1ZTtcblx0XHR2YXIgbyA9IHt9O1xuXHRcdE1vdGlvbkd1aWRlUGx1Z2luLmNhbGMoZGF0YSwgZGF0YS5zdGFydCwgbyk7XG5cdFx0dHdlZW4uX19yb3RQYXRoUyA9IE51bWJlcihvLnJvdGF0aW9uLnRvRml4ZWQoNSkpO1xuXHRcdE1vdGlvbkd1aWRlUGx1Z2luLmNhbGMoZGF0YSwgZGF0YS5lbmQsIG8pO1xuXHRcdHR3ZWVuLl9fcm90UGF0aEUgPSBOdW1iZXIoby5yb3RhdGlvbi50b0ZpeGVkKDUpKTtcblx0XHRkYXRhLm9yaWVudCA9IGZhbHNlO1x0Ly9oZXJlIGFuZCBub3cgd2UgZG9uJ3Qga25vdyBpZiB3ZSBuZWVkIHRvXG5cdFx0TW90aW9uR3VpZGVQbHVnaW4uY2FsYyhkYXRhLCBkYXRhLmVuZCwgaW5qZWN0UHJvcHMpO1xuXHRcdGRhdGEub3JpZW50ID0gdGVtcDtcblxuXHRcdC8vIFNldHVwIHJvdGF0aW9uIHByb3BlcnRpZXNcblx0XHRpZighZGF0YS5vcmllbnQpeyByZXR1cm4gZW5kVmFsdWU7IH1cblx0XHR0d2Vlbi5fX2d1aWRlRGF0YSA9IGRhdGE7XG5cdFx0TW90aW9uR3VpZGVQbHVnaW4udGVzdFJvdERhdGEodHdlZW4sIGluamVjdFByb3BzKTtcblx0XHRyZXR1cm4gZW5kVmFsdWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgdGVzdFJvdERhdGFcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0TW90aW9uR3VpZGVQbHVnaW4udGVzdFJvdERhdGEgPSBmdW5jdGlvbih0d2VlbiwgaW5qZWN0UHJvcHMpe1xuXG5cdFx0Ly8gbm8gcm90YXRpb24gaW5mb3JtYXQ/IGlmIHdlIG5lZWQgaXQgY29tZSBiYWNrLCBpZiB3ZSBkb24ndCB1c2UgMCAmIGVuc3VyZSB3ZSBoYXZlIGd1aWRlIGRhdGFcblx0XHRpZih0d2Vlbi5fX3JvdEdsb2JhbFMgPT09IHVuZGVmaW5lZCB8fCB0d2Vlbi5fX3JvdEdsb2JhbEUgPT09IHVuZGVmaW5lZCl7XG5cdFx0XHRpZih0d2Vlbi5fX25lZWRzUm90KXsgcmV0dXJuOyB9XG5cdFx0XHRpZih0d2Vlbi5fY3VyUXVldWVQcm9wcy5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkKXtcblx0XHRcdFx0dHdlZW4uX19yb3RHbG9iYWxTID0gdHdlZW4uX19yb3RHbG9iYWxFID0gdHdlZW4uX2N1clF1ZXVlUHJvcHMucm90YXRpb247XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5fX3JvdEdsb2JhbFMgPSB0d2Vlbi5fX3JvdEdsb2JhbEUgPSBpbmplY3RQcm9wcy5yb3RhdGlvbiA9IHR3ZWVuLnRhcmdldC5yb3RhdGlvbiB8fCAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZih0d2Vlbi5fX2d1aWRlRGF0YSA9PT0gdW5kZWZpbmVkKXsgcmV0dXJuOyB9XG5cblx0XHQvLyBQcm9jZXNzIHJvdGF0aW9uIHByb3BlcnRpZXNcblx0XHR2YXIgZGF0YSA9IHR3ZWVuLl9fZ3VpZGVEYXRhO1xuXHRcdHZhciByb3RHbG9iYWxEID0gdHdlZW4uX19yb3RHbG9iYWxFIC0gdHdlZW4uX19yb3RHbG9iYWxTO1xuXHRcdHZhciByb3RQYXRoRCA9IHR3ZWVuLl9fcm90UGF0aEUgLSB0d2Vlbi5fX3JvdFBhdGhTO1xuXHRcdHZhciByb3QgPSByb3RHbG9iYWxEIC0gcm90UGF0aEQ7XG5cblx0XHRpZihkYXRhLm9yaWVudCA9PSBcImF1dG9cIil7XG5cdFx0XHRpZihyb3QgPiAxODApe1x0XHRcdHJvdCAtPSAzNjA7IH1cblx0XHRcdGVsc2UgaWYocm90IDwgLTE4MCl7XHRyb3QgKz0gMzYwOyB9XG5cblx0XHR9IGVsc2UgaWYoZGF0YS5vcmllbnQgPT0gXCJjd1wiKXtcblx0XHRcdHdoaWxlKHJvdCA8IDApeyByb3QgKz0gMzYwOyB9XG5cdFx0XHRpZihyb3QgPT0gMCAmJiByb3RHbG9iYWxEID4gMCAmJiByb3RHbG9iYWxEICE9IDE4MCl7IHJvdCArPSAzNjA7IH1cblxuXHRcdH0gZWxzZSBpZihkYXRhLm9yaWVudCA9PSBcImNjd1wiKXtcblx0XHRcdHJvdCA9IHJvdEdsb2JhbEQgLSAoKHJvdFBhdGhEID4gMTgwKT8oMzYwLXJvdFBhdGhEKToocm90UGF0aEQpKTtcdC8vIHNpZ24gZmxpcHBpbmcgb24gcGF0aFxuXHRcdFx0d2hpbGUocm90ID4gMCl7IHJvdCAtPSAzNjA7IH1cblx0XHRcdGlmKHJvdCA9PSAwICYmIHJvdEdsb2JhbEQgPCAwICYmIHJvdEdsb2JhbEQgIT0gLTE4MCl7IHJvdCAtPSAzNjA7IH1cblx0XHR9XG5cblx0XHRkYXRhLnJvdERlbHRhID0gcm90O1xuXHRcdGRhdGEucm90T2ZmUyA9IHR3ZWVuLl9fcm90R2xvYmFsUyAtIHR3ZWVuLl9fcm90UGF0aFM7XG5cblx0XHQvLyByZXNldFxuXHRcdHR3ZWVuLl9fcm90R2xvYmFsUyA9IHR3ZWVuLl9fcm90R2xvYmFsRSA9IHR3ZWVuLl9fZ3VpZGVEYXRhID0gdHdlZW4uX19uZWVkc1JvdCA9IHVuZGVmaW5lZDtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCB0d2VlblxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRNb3Rpb25HdWlkZVBsdWdpbi50d2VlbiA9IGZ1bmN0aW9uKHR3ZWVuLCBwcm9wLCB2YWx1ZSwgc3RhcnRWYWx1ZXMsIGVuZFZhbHVlcywgcmF0aW8sIHdhaXQsIGVuZCkge1xuXHRcdHZhciBkYXRhID0gZW5kVmFsdWVzLmd1aWRlO1xuXHRcdGlmKGRhdGEgPT0gdW5kZWZpbmVkIHx8IGRhdGEgPT09IHN0YXJ0VmFsdWVzLmd1aWRlKXsgcmV0dXJuIHZhbHVlOyB9XG5cdFx0aWYoZGF0YS5sYXN0UmF0aW8gIT0gcmF0aW8pe1xuXHRcdFx0Ly8gZmlyc3QgdGltZSB0aHJvdWdoIHNvIGNhbGN1bGF0ZSB3aGF0IEkgbmVlZCB0b1xuXHRcdFx0dmFyIHQgPSAoKGRhdGEuZW5kLWRhdGEuc3RhcnQpKih3YWl0P2RhdGEuZW5kOnJhdGlvKStkYXRhLnN0YXJ0KTtcblx0XHRcdE1vdGlvbkd1aWRlUGx1Z2luLmNhbGMoZGF0YSwgdCwgdHdlZW4udGFyZ2V0KTtcblx0XHRcdHN3aXRjaChkYXRhLm9yaWVudCl7XG5cdFx0XHRcdGNhc2UgXCJjd1wiOlx0XHQvLyBtaXggaW4gdGhlIG9yaWdpbmFsIHJvdGF0aW9uXG5cdFx0XHRcdGNhc2UgXCJjY3dcIjpcblx0XHRcdFx0Y2FzZSBcImF1dG9cIjogdHdlZW4udGFyZ2V0LnJvdGF0aW9uICs9IGRhdGEucm90T2ZmUyArIGRhdGEucm90RGVsdGEqcmF0aW87IGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZml4ZWRcIjpcdC8vIGZvbGxvdyBmaXhlZCBiZWhhdmlvdXIgdG8gc29sdmUgcG90ZW50aWFsIGlzc3Vlc1xuXHRcdFx0XHRkZWZhdWx0OiB0d2Vlbi50YXJnZXQucm90YXRpb24gKz0gZGF0YS5yb3RPZmZTOyBicmVhaztcblx0XHRcdH1cblx0XHRcdGRhdGEubGFzdFJhdGlvID0gcmF0aW87XG5cdFx0fVxuXHRcdGlmKHByb3AgPT0gXCJyb3RhdGlvblwiICYmICgoIWRhdGEub3JpZW50KSB8fCBkYXRhLm9yaWVudCA9PSBcImZhbHNlXCIpKXsgcmV0dXJuIHZhbHVlOyB9XG5cdFx0cmV0dXJuIHR3ZWVuLnRhcmdldFtwcm9wXTtcblx0fTtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSB4L3kvcm90YXRpb24gaW5mb3JtYXRpb24gYWJvdXQgYSBwYXRoIGZvciBhIGdpdmVuIHJhdGlvIGFsb25nIHRoZSBwYXRoLlxuXHQgKiBBc3N1bWVzIGEgcGF0aCBvYmplY3Qgd2l0aCBhbGwgb3B0aW9uYWwgcGFyYW1ldGVycyBzcGVjaWZpZWQuXG5cdCAqIEBwYXJhbSBkYXRhIERhdGEgb2JqZWN0IHlvdSB3b3VsZCBwYXNzIHRvIHRoZSBcImd1aWRlOlwiIHByb3BlcnR5IGluIGEgVHdlZW5cblx0ICogQHBhcmFtIHJhdGlvIDAtMSBEaXN0YW5jZSBhbG9uZyBwYXRoLCB2YWx1ZXMgb3V0c2lkZSAwLTEgYXJlIFwiYmVzdCBndWVzc1wiXG5cdCAqIEBwYXJhbSB0YXJnZXQgT2JqZWN0IHRvIGNvcHkgdGhlIHJlc3VsdHMgb250bywgd2lsbCB1c2UgYSBuZXcgb2JqZWN0IGlmIG5vdCBzdXBwbGllZC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgdGFyZ2V0IG9iamVjdCBvciBhIG5ldyBvYmplY3Qgdy8gdGhlIHR3ZWVuZWQgcHJvcGVydGllc1xuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRNb3Rpb25HdWlkZVBsdWdpbi5jYWxjID0gZnVuY3Rpb24oZGF0YSwgcmF0aW8sIHRhcmdldCkge1xuXHRcdGlmKGRhdGEuX3NlZ21lbnRzID09IHVuZGVmaW5lZCl7IHRocm93KFwiTWlzc2luZyBjcml0aWNhbCBwcmUtY2FsY3VsYXRlZCBpbmZvcm1hdGlvbiwgcGxlYXNlIGZpbGUgYSBidWdcIik7IH1cblx0XHRpZih0YXJnZXQgPT0gdW5kZWZpbmVkKXsgdGFyZ2V0ID0ge3g6MCwgeTowLCByb3RhdGlvbjowfTsgfVxuXHRcdHZhciBzZWcgPSBkYXRhLl9zZWdtZW50cztcblx0XHR2YXIgcGF0aCA9IGRhdGEucGF0aDtcblxuXHRcdC8vIGZpbmQgc2VnbWVudFxuXHRcdHZhciBwb3MgPSBkYXRhLl9sZW5ndGggKiByYXRpbztcblx0XHR2YXIgY2FwID0gc2VnLmxlbmd0aCAtIDI7XG5cdFx0dmFyIG4gPSAwO1xuXHRcdHdoaWxlKHBvcyA+IHNlZ1tuXSAmJiBuIDwgY2FwKXtcblx0XHRcdHBvcyAtPSBzZWdbbl07XG5cdFx0XHRuKz0yO1xuXHRcdH1cblxuXHRcdC8vIGZpbmQgc3VibGluZVxuXHRcdHZhciBzdWJsaW5lcyA9IHNlZ1tuKzFdO1xuXHRcdHZhciBpID0gMDtcblx0XHRjYXAgPSBzdWJsaW5lcy5sZW5ndGgtMTtcblx0XHR3aGlsZShwb3MgPiBzdWJsaW5lc1tpXSAmJiBpIDwgY2FwKXtcblx0XHRcdHBvcyAtPSBzdWJsaW5lc1tpXTtcblx0XHRcdGkrKztcblx0XHR9XG5cdFx0dmFyIHQgPSAoaS8rK2NhcCkrKHBvcy8oY2FwKnN1YmxpbmVzW2ldKSk7XG5cblx0XHQvLyBmaW5kIHgveVxuXHRcdG4gPSAobioyKSsyO1xuXHRcdHZhciBpbnYgPSAxIC0gdDtcblx0XHR0YXJnZXQueCA9IGludippbnYgKiBwYXRoW24tMl0gKyAyICogaW52ICogdCAqIHBhdGhbbiswXSArIHQqdCAqIHBhdGhbbisyXTtcblx0XHR0YXJnZXQueSA9IGludippbnYgKiBwYXRoW24tMV0gKyAyICogaW52ICogdCAqIHBhdGhbbisxXSArIHQqdCAqIHBhdGhbbiszXTtcblxuXHRcdC8vIG9yaWVudGF0aW9uXG5cdFx0aWYoZGF0YS5vcmllbnQpe1xuXHRcdFx0dGFyZ2V0LnJvdGF0aW9uID0gNTcuMjk1Nzc5NSAqIE1hdGguYXRhbjIoXG5cdFx0XHRcdChwYXRoW24rMV0tcGF0aFtuLTFdKSppbnYgKyAocGF0aFtuKzNdLXBhdGhbbisxXSkqdCxcblx0XHRcdFx0KHBhdGhbbiswXS1wYXRoW24tMl0pKmludiArIChwYXRoW24rMl0tcGF0aFtuKzBdKSp0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9O1xuXG5cdGNyZWF0ZWpzLk1vdGlvbkd1aWRlUGx1Z2luID0gTW90aW9uR3VpZGVQbHVnaW47XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyB2ZXJzaW9uLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBTdGF0aWMgY2xhc3MgaG9sZGluZyBsaWJyYXJ5IHNwZWNpZmljIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHZlcnNpb24gYW5kIGJ1aWxkRGF0ZSBvZlxuXHQgKiB0aGUgbGlicmFyeS5cblx0ICogQGNsYXNzIFR3ZWVuSlNcblx0ICoqL1xuXHR2YXIgcyA9IGNyZWF0ZWpzLlR3ZWVuSlMgPSBjcmVhdGVqcy5Ud2VlbkpTIHx8IHt9O1xuXG5cdC8qKlxuXHQgKiBUaGUgdmVyc2lvbiBzdHJpbmcgZm9yIHRoaXMgcmVsZWFzZS5cblx0ICogQHByb3BlcnR5IHZlcnNpb25cblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRzLnZlcnNpb24gPSAvKj12ZXJzaW9uKi9cIjAuNi4yXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxuXHQvKipcblx0ICogVGhlIGJ1aWxkIGRhdGUgZm9yIHRoaXMgcmVsZWFzZSBpbiBVVEMgZm9ybWF0LlxuXHQgKiBAcHJvcGVydHkgYnVpbGREYXRlXG5cdCAqIEB0eXBlIFN0cmluZ1xuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0cy5idWlsZERhdGUgPSAvKj1kYXRlKi9cIlRodSwgMjYgTm92IDIwMTUgMjA6NDQ6MzEgR01UXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxufSkoKTtcbmlmKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSBtb2R1bGUuZXhwb3J0cyA9IHRoaXMuY3JlYXRlanM7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///ZWlK\n");

/***/ })

}]);