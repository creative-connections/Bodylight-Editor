(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~e1c0d02b"],{

/***/ "AVA3":
/*!***********************************************!*\
  !*** ./node_modules/latest-createjs/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./lib/easeljs/easeljs.js */ \"8PJA\")\n__webpack_require__(/*! ./lib/tweenjs/tweenjs.js */ \"qE/h\")\n__webpack_require__(/*! ./lib/soundjs/soundjs.js */ \"3ri2\")\n__webpack_require__(/*! ./lib/preloadjs/preloadjs.js */ \"aaSZ\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQVZBMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sYXRlc3QtY3JlYXRlanMvaW5kZXguanM/MDE1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL2xpYi9lYXNlbGpzL2Vhc2VsanMuanMnKVxucmVxdWlyZSgnLi9saWIvdHdlZW5qcy90d2VlbmpzLmpzJylcbnJlcXVpcmUoJy4vbGliL3NvdW5kanMvc291bmRqcy5qcycpXG5yZXF1aXJlKCcuL2xpYi9wcmVsb2FkanMvcHJlbG9hZGpzLmpzJylcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///AVA3\n");

/***/ }),

/***/ "qE/h":
/*!*************************************************************!*\
  !*** ./node_modules/latest-createjs/lib/tweenjs/tweenjs.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n* TweenJS\n* Visit http://createjs.com/ for documentation, updates and examples.\n*\n* Copyright (c) 2010 gskinner.com, inc.\n*\n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n//##############################################################################\n// extend.js\n//##############################################################################\n\nwindow.createjs = window.createjs||{};\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Sets up the prototype chain and constructor property for a new class.\n *\n * This should be called right after creating the class constructor.\n *\n * \tfunction MySubClass() {}\n * \tcreatejs.extend(MySubClass, MySuperClass);\n * \tMySubClass.prototype.doSomething = function() { }\n *\n * \tvar foo = new MySubClass();\n * \tconsole.log(foo instanceof MySuperClass); // true\n * \tconsole.log(foo.prototype.constructor === MySubClass); // true\n *\n * @method extend\n * @param {Function} subclass The subclass.\n * @param {Function} superclass The superclass to extend.\n * @return {Function} Returns the subclass's new prototype.\n */\ncreatejs.extend = function(subclass, superclass) {\n\t\"use strict\";\n\n\tfunction o() { this.constructor = subclass; }\n\to.prototype = superclass.prototype;\n\treturn (subclass.prototype = new o());\n};\n\n//##############################################################################\n// promote.js\n//##############################################################################\n\nwindow.createjs = window.createjs||{};\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Promotes any methods on the super class that were overridden, by creating an alias in the format `prefix_methodName`.\n * It is recommended to use the super class's name as the prefix.\n * An alias to the super class's constructor is always added in the format `prefix_constructor`.\n * This allows the subclass to call super class methods without using `function.call`, providing better performance.\n *\n * For example, if `MySubClass` extends `MySuperClass`, and both define a `draw` method, then calling `promote(MySubClass, \"MySuperClass\")`\n * would add a `MySuperClass_constructor` method to MySubClass and promote the `draw` method on `MySuperClass` to the\n * prototype of `MySubClass` as `MySuperClass_draw`.\n *\n * This should be called after the class's prototype is fully defined.\n *\n * \tfunction ClassA(name) {\n * \t\tthis.name = name;\n * \t}\n * \tClassA.prototype.greet = function() {\n * \t\treturn \"Hello \"+this.name;\n * \t}\n *\n * \tfunction ClassB(name, punctuation) {\n * \t\tthis.ClassA_constructor(name);\n * \t\tthis.punctuation = punctuation;\n * \t}\n * \tcreatejs.extend(ClassB, ClassA);\n * \tClassB.prototype.greet = function() {\n * \t\treturn this.ClassA_greet()+this.punctuation;\n * \t}\n * \tcreatejs.promote(ClassB, \"ClassA\");\n *\n * \tvar foo = new ClassB(\"World\", \"!?!\");\n * \tconsole.log(foo.greet()); // Hello World!?!\n *\n * @method promote\n * @param {Function} subclass The class to promote super class methods on.\n * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.\n * @return {Function} Returns the subclass.\n */\ncreatejs.promote = function(subclass, prefix) {\n\t\"use strict\";\n\n\tvar subP = subclass.prototype, supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;\n\tif (supP) {\n\t\tsubP[(prefix+=\"_\") + \"constructor\"] = supP.constructor; // constructor is not always innumerable\n\t\tfor (var n in supP) {\n\t\t\tif (subP.hasOwnProperty(n) && (typeof supP[n] == \"function\")) { subP[prefix + n] = supP[n]; }\n\t\t}\n\t}\n\treturn subclass;\n};\n\n//##############################################################################\n// deprecate.js\n//##############################################################################\n\nwindow.createjs = window.createjs||{};\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Wraps deprecated methods so they still be used, but throw warnings to developers.\n *\n *\tobj.deprecatedMethod = createjs.deprecate(\"Old Method Name\", obj._fallbackMethod);\n *\n * The recommended approach for deprecated properties is:\n *\n *\ttry {\n *\t\tObj\tect.defineProperties(object, {\n *\t\t\treadyOnlyProp: { get: createjs.deprecate(\"readOnlyProp\", function() { return this.alternateProp; }) },\n *\t\t\treadWriteProp: {\n *\t\t\t\tget: createjs.deprecate(\"readOnlyProp\", function() { return this.alternateProp; }),\n *\t\t\t\tset: createjs.deprecate(\"readOnlyProp\", function(val) { this.alternateProp = val; })\n *\t\t});\n *\t} catch (e) {}\n *\n * @method deprecate\n * @param {Function} [fallbackMethod=null] A method to call when the deprecated method is used. See the example for how\n * @param {String} [name=null] The name of the method or property to display in the console warning.\n * to deprecate properties.\n * @return {Function} If a fallbackMethod is supplied, returns a closure that will call the fallback method after\n * logging the warning in the console.\n */\ncreatejs.deprecate = function(fallbackMethod, name) {\n\t\"use strict\";\n\treturn function() {\n\t\tvar msg = \"Deprecated property or method '\"+name+\"'. See docs for info.\";\n\t\tconsole && (console.warn ? console.warn(msg) : console.log(msg));\n\t\treturn fallbackMethod && fallbackMethod.apply(this, arguments);\n\t}\n};\n\n//##############################################################################\n// Event.js\n//##############################################################################\n\nwindow.createjs = window.createjs||{};\n\n(function() {\n\t\"use strict\";\n\n// constructor:\n\t/**\n\t * Contains properties and methods shared by all events for use with\n\t * {{#crossLink \"EventDispatcher\"}}{{/crossLink}}.\n\t * \n\t * Note that Event objects are often reused, so you should never\n\t * rely on an event object's state outside of the call stack it was received in.\n\t * @class Event\n\t * @param {String} type The event type.\n\t * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.\n\t * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.\n\t * @constructor\n\t **/\n\tfunction Event(type, bubbles, cancelable) {\n\t\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * The type of event.\n\t\t * @property type\n\t\t * @type String\n\t\t **/\n\t\tthis.type = type;\n\t\n\t\t/**\n\t\t * The object that generated an event.\n\t\t * @property target\n\t\t * @type Object\n\t\t * @default null\n\t\t * @readonly\n\t\t*/\n\t\tthis.target = null;\n\t\n\t\t/**\n\t\t * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will\n\t\t * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event\n\t\t * is generated from childObj, then a listener on parentObj would receive the event with\n\t\t * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).\n\t\t * @property currentTarget\n\t\t * @type Object\n\t\t * @default null\n\t\t * @readonly\n\t\t*/\n\t\tthis.currentTarget = null;\n\t\n\t\t/**\n\t\t * For bubbling events, this indicates the current event phase:<OL>\n\t\t * \t<LI> capture phase: starting from the top parent to the target</LI>\n\t\t * \t<LI> at target phase: currently being dispatched from the target</LI>\n\t\t * \t<LI> bubbling phase: from the target to the top parent</LI>\n\t\t * </OL>\n\t\t * @property eventPhase\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @readonly\n\t\t*/\n\t\tthis.eventPhase = 0;\n\t\n\t\t/**\n\t\t * Indicates whether the event will bubble through the display list.\n\t\t * @property bubbles\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.bubbles = !!bubbles;\n\t\n\t\t/**\n\t\t * Indicates whether the default behaviour of this event can be cancelled via\n\t\t * {{#crossLink \"Event/preventDefault\"}}{{/crossLink}}. This is set via the Event constructor.\n\t\t * @property cancelable\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.cancelable = !!cancelable;\n\t\n\t\t/**\n\t\t * The epoch time at which this event was created.\n\t\t * @property timeStamp\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @readonly\n\t\t*/\n\t\tthis.timeStamp = (new Date()).getTime();\n\t\n\t\t/**\n\t\t * Indicates if {{#crossLink \"Event/preventDefault\"}}{{/crossLink}} has been called\n\t\t * on this event.\n\t\t * @property defaultPrevented\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.defaultPrevented = false;\n\t\n\t\t/**\n\t\t * Indicates if {{#crossLink \"Event/stopPropagation\"}}{{/crossLink}} or\n\t\t * {{#crossLink \"Event/stopImmediatePropagation\"}}{{/crossLink}} has been called on this event.\n\t\t * @property propagationStopped\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.propagationStopped = false;\n\t\n\t\t/**\n\t\t * Indicates if {{#crossLink \"Event/stopImmediatePropagation\"}}{{/crossLink}} has been called\n\t\t * on this event.\n\t\t * @property immediatePropagationStopped\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.immediatePropagationStopped = false;\n\t\t\n\t\t/**\n\t\t * Indicates if {{#crossLink \"Event/remove\"}}{{/crossLink}} has been called on this event.\n\t\t * @property removed\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.removed = false;\n\t}\n\tvar p = Event.prototype;\n\n// public methods:\n\t/**\n\t * Sets {{#crossLink \"Event/defaultPrevented\"}}{{/crossLink}} to true if the event is cancelable.\n\t * Mirrors the DOM level 2 event standard. In general, cancelable events that have `preventDefault()` called will\n\t * cancel the default behaviour associated with the event.\n\t * @method preventDefault\n\t **/\n\tp.preventDefault = function() {\n\t\tthis.defaultPrevented = this.cancelable&&true;\n\t};\n\n\t/**\n\t * Sets {{#crossLink \"Event/propagationStopped\"}}{{/crossLink}} to true.\n\t * Mirrors the DOM event standard.\n\t * @method stopPropagation\n\t **/\n\tp.stopPropagation = function() {\n\t\tthis.propagationStopped = true;\n\t};\n\n\t/**\n\t * Sets {{#crossLink \"Event/propagationStopped\"}}{{/crossLink}} and\n\t * {{#crossLink \"Event/immediatePropagationStopped\"}}{{/crossLink}} to true.\n\t * Mirrors the DOM event standard.\n\t * @method stopImmediatePropagation\n\t **/\n\tp.stopImmediatePropagation = function() {\n\t\tthis.immediatePropagationStopped = this.propagationStopped = true;\n\t};\n\t\n\t/**\n\t * Causes the active listener to be removed via removeEventListener();\n\t * \n\t * \t\tmyBtn.addEventListener(\"click\", function(evt) {\n\t * \t\t\t// do stuff...\n\t * \t\t\tevt.remove(); // removes this listener.\n\t * \t\t});\n\t * \n\t * @method remove\n\t **/\n\tp.remove = function() {\n\t\tthis.removed = true;\n\t};\n\t\n\t/**\n\t * Returns a clone of the Event instance.\n\t * @method clone\n\t * @return {Event} a clone of the Event instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Event(this.type, this.bubbles, this.cancelable);\n\t};\n\t\n\t/**\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\n\t *\n\t * @method set\n\t * @param {Object} props A generic object containing properties to copy to the instance.\n\t * @return {Event} Returns the instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t*/\n\tp.set = function(props) {\n\t\tfor (var n in props) { this[n] = props[n]; }\n\t\treturn this;\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Event (type=\"+this.type+\")]\";\n\t};\n\n\tcreatejs.Event = Event;\n}());\n\n//##############################################################################\n// EventDispatcher.js\n//##############################################################################\n\nwindow.createjs = window.createjs||{};\r\n\r\n(function() {\r\n\t\"use strict\";\r\n\r\n\r\n// constructor:\r\n\t/**\r\n\t * EventDispatcher provides methods for managing queues of event listeners and dispatching events.\r\n\t *\r\n\t * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the\r\n\t * EventDispatcher {{#crossLink \"EventDispatcher/initialize\"}}{{/crossLink}} method.\r\n\t * \r\n\t * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the\r\n\t * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports\r\n\t * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.\r\n\t * \r\n\t * EventDispatcher also exposes a {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}} method, which makes it easier\r\n\t * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The \r\n\t * {{#crossLink \"EventDispatcher/off\"}}{{/crossLink}} method is merely an alias to\r\n\t * {{#crossLink \"EventDispatcher/removeEventListener\"}}{{/crossLink}}.\r\n\t * \r\n\t * Another addition to the DOM Level 2 model is the {{#crossLink \"EventDispatcher/removeAllEventListeners\"}}{{/crossLink}}\r\n\t * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also \r\n\t * includes a {{#crossLink \"Event/remove\"}}{{/crossLink}} method which removes the active listener.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t * Add EventDispatcher capabilities to the \"MyClass\" class.\r\n\t *\r\n\t *      EventDispatcher.initialize(MyClass.prototype);\r\n\t *\r\n\t * Add an event (see {{#crossLink \"EventDispatcher/addEventListener\"}}{{/crossLink}}).\r\n\t *\r\n\t *      instance.addEventListener(\"eventName\", handlerMethod);\r\n\t *      function handlerMethod(event) {\r\n\t *          console.log(event.target + \" Was Clicked\");\r\n\t *      }\r\n\t *\r\n\t * <b>Maintaining proper scope</b><br />\r\n\t * Scope (ie. \"this\") can be be a challenge with events. Using the {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}}\r\n\t * method to subscribe to events simplifies this.\r\n\t *\r\n\t *      instance.addEventListener(\"click\", function(event) {\r\n\t *          console.log(instance == this); // false, scope is ambiguous.\r\n\t *      });\r\n\t *      \r\n\t *      instance.on(\"click\", function(event) {\r\n\t *          console.log(instance == this); // true, \"on\" uses dispatcher scope by default.\r\n\t *      });\r\n\t * \r\n\t * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage\r\n\t * scope.\r\n\t *\r\n\t * <b>Browser support</b>\r\n\t * The event model in CreateJS can be used separately from the suite in any project, however the inheritance model\r\n\t * requires modern browsers (IE9+).\r\n\t *      \r\n\t *\r\n\t * @class EventDispatcher\r\n\t * @constructor\r\n\t **/\r\n\tfunction EventDispatcher() {\r\n\t\r\n\t\r\n\t// private properties:\r\n\t\t/**\r\n\t\t * @protected\r\n\t\t * @property _listeners\r\n\t\t * @type Object\r\n\t\t **/\r\n\t\tthis._listeners = null;\r\n\t\t\r\n\t\t/**\r\n\t\t * @protected\r\n\t\t * @property _captureListeners\r\n\t\t * @type Object\r\n\t\t **/\r\n\t\tthis._captureListeners = null;\r\n\t}\r\n\tvar p = EventDispatcher.prototype;\r\n\r\n// static public methods:\r\n\t/**\r\n\t * Static initializer to mix EventDispatcher methods into a target object or prototype.\r\n\t * \r\n\t * \t\tEventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class\r\n\t * \t\tEventDispatcher.initialize(myObject); // add to a specific instance\r\n\t * \r\n\t * @method initialize\r\n\t * @static\r\n\t * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a\r\n\t * prototype.\r\n\t **/\r\n\tEventDispatcher.initialize = function(target) {\r\n\t\ttarget.addEventListener = p.addEventListener;\r\n\t\ttarget.on = p.on;\r\n\t\ttarget.removeEventListener = target.off =  p.removeEventListener;\r\n\t\ttarget.removeAllEventListeners = p.removeAllEventListeners;\r\n\t\ttarget.hasEventListener = p.hasEventListener;\r\n\t\ttarget.dispatchEvent = p.dispatchEvent;\r\n\t\ttarget._dispatchEvent = p._dispatchEvent;\r\n\t\ttarget.willTrigger = p.willTrigger;\r\n\t};\r\n\t\r\n\r\n// public methods:\r\n\t/**\r\n\t * Adds the specified event listener. Note that adding multiple listeners to the same function will result in\r\n\t * multiple callbacks getting fired.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      displayObject.addEventListener(\"click\", handleClick);\r\n\t *      function handleClick(event) {\r\n\t *         // Click happened.\r\n\t *      }\r\n\t *\r\n\t * @method addEventListener\r\n\t * @param {String} type The string type of the event.\r\n\t * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when\r\n\t * the event is dispatched.\r\n\t * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\r\n\t * @return {Function | Object} Returns the listener for chaining or assignment.\r\n\t **/\r\n\tp.addEventListener = function(type, listener, useCapture) {\r\n\t\tvar listeners;\r\n\t\tif (useCapture) {\r\n\t\t\tlisteners = this._captureListeners = this._captureListeners||{};\r\n\t\t} else {\r\n\t\t\tlisteners = this._listeners = this._listeners||{};\r\n\t\t}\r\n\t\tvar arr = listeners[type];\r\n\t\tif (arr) { this.removeEventListener(type, listener, useCapture); }\r\n\t\tarr = listeners[type]; // remove may have deleted the array\r\n\t\tif (!arr) { listeners[type] = [listener];  }\r\n\t\telse { arr.push(listener); }\r\n\t\treturn listener;\r\n\t};\r\n\t\r\n\t/**\r\n\t * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener\r\n\t * only run once, associate arbitrary data with the listener, and remove the listener.\r\n\t * \r\n\t * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.\r\n\t * The wrapper function is returned for use with `removeEventListener` (or `off`).\r\n\t * \r\n\t * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener, or use\r\n\t * {{#crossLink \"Event/remove\"}}{{/crossLink}}. Likewise, each time you call `on` a NEW wrapper function is subscribed, so multiple calls\r\n\t * to `on` with the same params will create multiple listeners.\r\n\t * \r\n\t * <h4>Example</h4>\r\n\t * \r\n\t * \t\tvar listener = myBtn.on(\"click\", handleClick, null, false, {count:3});\r\n\t * \t\tfunction handleClick(evt, data) {\r\n\t * \t\t\tdata.count -= 1;\r\n\t * \t\t\tconsole.log(this == myBtn); // true - scope defaults to the dispatcher\r\n\t * \t\t\tif (data.count == 0) {\r\n\t * \t\t\t\talert(\"clicked 3 times!\");\r\n\t * \t\t\t\tmyBtn.off(\"click\", listener);\r\n\t * \t\t\t\t// alternately: evt.remove();\r\n\t * \t\t\t}\r\n\t * \t\t}\r\n\t * \r\n\t * @method on\r\n\t * @param {String} type The string type of the event.\r\n\t * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when\r\n\t * the event is dispatched.\r\n\t * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).\r\n\t * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.\r\n\t * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.\r\n\t * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\r\n\t * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.\r\n\t **/\r\n\tp.on = function(type, listener, scope, once, data, useCapture) {\r\n\t\tif (listener.handleEvent) {\r\n\t\t\tscope = scope||listener;\r\n\t\t\tlistener = listener.handleEvent;\r\n\t\t}\r\n\t\tscope = scope||this;\r\n\t\treturn this.addEventListener(type, function(evt) {\r\n\t\t\t\tlistener.call(scope, evt, data);\r\n\t\t\t\tonce&&evt.remove();\r\n\t\t\t}, useCapture);\r\n\t};\r\n\r\n\t/**\r\n\t * Removes the specified event listener.\r\n\t *\r\n\t * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy\r\n\t * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or\r\n\t * closure will not work.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      displayObject.removeEventListener(\"click\", handleClick);\r\n\t *\r\n\t * @method removeEventListener\r\n\t * @param {String} type The string type of the event.\r\n\t * @param {Function | Object} listener The listener function or object.\r\n\t * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\r\n\t **/\r\n\tp.removeEventListener = function(type, listener, useCapture) {\r\n\t\tvar listeners = useCapture ? this._captureListeners : this._listeners;\r\n\t\tif (!listeners) { return; }\r\n\t\tvar arr = listeners[type];\r\n\t\tif (!arr) { return; }\r\n\t\tfor (var i=0,l=arr.length; i<l; i++) {\r\n\t\t\tif (arr[i] == listener) {\r\n\t\t\t\tif (l==1) { delete(listeners[type]); } // allows for faster checks.\r\n\t\t\t\telse { arr.splice(i,1); }\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\t/**\r\n\t * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the\r\n\t * .on method.\r\n\t * \r\n\t * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener. See \r\n\t * {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}} for an example.\r\n\t *\r\n\t * @method off\r\n\t * @param {String} type The string type of the event.\r\n\t * @param {Function | Object} listener The listener function or object.\r\n\t * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\r\n\t **/\r\n\tp.off = p.removeEventListener;\r\n\r\n\t/**\r\n\t * Removes all listeners for the specified type, or all listeners of all types.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      // Remove all listeners\r\n\t *      displayObject.removeAllEventListeners();\r\n\t *\r\n\t *      // Remove all click listeners\r\n\t *      displayObject.removeAllEventListeners(\"click\");\r\n\t *\r\n\t * @method removeAllEventListeners\r\n\t * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.\r\n\t **/\r\n\tp.removeAllEventListeners = function(type) {\r\n\t\tif (!type) { this._listeners = this._captureListeners = null; }\r\n\t\telse {\r\n\t\t\tif (this._listeners) { delete(this._listeners[type]); }\r\n\t\t\tif (this._captureListeners) { delete(this._captureListeners[type]); }\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Dispatches the specified event to all listeners.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      // Use a string event\r\n\t *      this.dispatchEvent(\"complete\");\r\n\t *\r\n\t *      // Use an Event instance\r\n\t *      var event = new createjs.Event(\"progress\");\r\n\t *      this.dispatchEvent(event);\r\n\t *\r\n\t * @method dispatchEvent\r\n\t * @param {Object | String | Event} eventObj An object with a \"type\" property, or a string type.\r\n\t * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,\r\n\t * dispatchEvent will construct an Event instance if necessary with the specified type. This latter approach can\r\n\t * be used to avoid event object instantiation for non-bubbling events that may not have any listeners.\r\n\t * @param {Boolean} [bubbles] Specifies the `bubbles` value when a string was passed to eventObj.\r\n\t * @param {Boolean} [cancelable] Specifies the `cancelable` value when a string was passed to eventObj.\r\n\t * @return {Boolean} Returns false if `preventDefault()` was called on a cancelable event, true otherwise.\r\n\t **/\r\n\tp.dispatchEvent = function(eventObj, bubbles, cancelable) {\r\n\t\tif (typeof eventObj == \"string\") {\r\n\t\t\t// skip everything if there's no listeners and it doesn't bubble:\r\n\t\t\tvar listeners = this._listeners;\r\n\t\t\tif (!bubbles && (!listeners || !listeners[eventObj])) { return true; }\r\n\t\t\teventObj = new createjs.Event(eventObj, bubbles, cancelable);\r\n\t\t} else if (eventObj.target && eventObj.clone) {\r\n\t\t\t// redispatching an active event object, so clone it:\r\n\t\t\teventObj = eventObj.clone();\r\n\t\t}\r\n\t\t\r\n\t\t// TODO: it would be nice to eliminate this. Maybe in favour of evtObj instanceof Event? Or !!evtObj.createEvent\r\n\t\ttry { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events\r\n\r\n\t\tif (!eventObj.bubbles || !this.parent) {\r\n\t\t\tthis._dispatchEvent(eventObj, 2);\r\n\t\t} else {\r\n\t\t\tvar top=this, list=[top];\r\n\t\t\twhile (top.parent) { list.push(top = top.parent); }\r\n\t\t\tvar i, l=list.length;\r\n\r\n\t\t\t// capture & atTarget\r\n\t\t\tfor (i=l-1; i>=0 && !eventObj.propagationStopped; i--) {\r\n\t\t\t\tlist[i]._dispatchEvent(eventObj, 1+(i==0));\r\n\t\t\t}\r\n\t\t\t// bubbling\r\n\t\t\tfor (i=1; i<l && !eventObj.propagationStopped; i++) {\r\n\t\t\t\tlist[i]._dispatchEvent(eventObj, 3);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn !eventObj.defaultPrevented;\r\n\t};\r\n\r\n\t/**\r\n\t * Indicates whether there is at least one listener for the specified event type.\r\n\t * @method hasEventListener\r\n\t * @param {String} type The string type of the event.\r\n\t * @return {Boolean} Returns true if there is at least one listener for the specified event.\r\n\t **/\r\n\tp.hasEventListener = function(type) {\r\n\t\tvar listeners = this._listeners, captureListeners = this._captureListeners;\r\n\t\treturn !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));\r\n\t};\r\n\t\r\n\t/**\r\n\t * Indicates whether there is at least one listener for the specified event type on this object or any of its\r\n\t * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the\r\n\t * specified type is dispatched from this object, it will trigger at least one listener.\r\n\t * \r\n\t * This is similar to {{#crossLink \"EventDispatcher/hasEventListener\"}}{{/crossLink}}, but it searches the entire\r\n\t * event flow for a listener, not just this object.\r\n\t * @method willTrigger\r\n\t * @param {String} type The string type of the event.\r\n\t * @return {Boolean} Returns `true` if there is at least one listener for the specified event.\r\n\t **/\r\n\tp.willTrigger = function(type) {\r\n\t\tvar o = this;\r\n\t\twhile (o) {\r\n\t\t\tif (o.hasEventListener(type)) { return true; }\r\n\t\t\to = o.parent;\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\r\n\t/**\r\n\t * @method toString\r\n\t * @return {String} a string representation of the instance.\r\n\t **/\r\n\tp.toString = function() {\r\n\t\treturn \"[EventDispatcher]\";\r\n\t};\r\n\r\n\r\n// private methods:\r\n\t/**\r\n\t * @method _dispatchEvent\r\n\t * @param {Object | Event} eventObj\r\n\t * @param {Object} eventPhase\r\n\t * @protected\r\n\t **/\r\n\tp._dispatchEvent = function(eventObj, eventPhase) {\r\n\t\tvar l, arr, listeners = (eventPhase <= 2) ? this._captureListeners : this._listeners;\r\n\t\tif (eventObj && listeners && (arr = listeners[eventObj.type]) && (l=arr.length)) {\r\n\t\t\ttry { eventObj.currentTarget = this; } catch (e) {}\r\n\t\t\ttry { eventObj.eventPhase = eventPhase|0; } catch (e) {}\r\n\t\t\teventObj.removed = false;\r\n\t\t\t\r\n\t\t\tarr = arr.slice(); // to avoid issues with items being removed or added during the dispatch\r\n\t\t\tfor (var i=0; i<l && !eventObj.immediatePropagationStopped; i++) {\r\n\t\t\t\tvar o = arr[i];\r\n\t\t\t\tif (o.handleEvent) { o.handleEvent(eventObj); }\r\n\t\t\t\telse { o(eventObj); }\r\n\t\t\t\tif (eventObj.removed) {\r\n\t\t\t\t\tthis.off(eventObj.type, o, eventPhase==1);\r\n\t\t\t\t\teventObj.removed = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (eventPhase === 2) { this._dispatchEvent(eventObj, 2.1); }\r\n\t};\r\n\r\n\r\n\tcreatejs.EventDispatcher = EventDispatcher;\r\n}());\n\n//##############################################################################\n// Ticker.js\n//##############################################################################\n\nwindow.createjs = window.createjs||{};\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * The Ticker provides a centralized tick or heartbeat broadcast at a set interval. Listeners can subscribe to the tick\n\t * event to be notified when a set time interval has elapsed.\n\t *\n\t * Note that the interval that the tick event is called is a target interval, and may be broadcast at a slower interval\n\t * when under high CPU load. The Ticker class uses a static interface (ex. `Ticker.framerate = 30;`) and\n\t * can not be instantiated.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n\t *      function handleTick(event) {\n\t *          // Actions carried out each tick (aka frame)\n\t *          if (!event.paused) {\n\t *              // Actions carried out when the Ticker is not paused.\n\t *          }\n\t *      }\n\t *\n\t * @class Ticker\n\t * @uses EventDispatcher\n\t * @static\n\t **/\n\tfunction Ticker() {\n\t\tthrow \"Ticker cannot be instantiated.\";\n\t}\n\n\n// constants:\n\t/**\n\t * In this mode, Ticker uses the requestAnimationFrame API, but attempts to synch the ticks to target framerate. It\n\t * uses a simple heuristic that compares the time of the RAF return to the target time for the current frame and\n\t * dispatches the tick when the time is within a certain threshold.\n\t *\n\t * This mode has a higher variance for time between frames than {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}},\n\t * but does not require that content be time based as with {{#crossLink \"Ticker/RAF:property\"}}{{/crossLink}} while\n\t * gaining the benefits of that API (screen synch, background throttling).\n\t *\n\t * Variance is usually lowest for framerates that are a divisor of the RAF frequency. This is usually 60, so\n\t * framerates of 10, 12, 15, 20, and 30 work well.\n\t *\n\t * Falls back to {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}} if the requestAnimationFrame API is not\n\t * supported.\n\t * @property RAF_SYNCHED\n\t * @static\n\t * @type {String}\n\t * @default \"synched\"\n\t * @readonly\n\t **/\n\tTicker.RAF_SYNCHED = \"synched\";\n\n\t/**\n\t * In this mode, Ticker passes through the requestAnimationFrame heartbeat, ignoring the target framerate completely.\n\t * Because requestAnimationFrame frequency is not deterministic, any content using this mode should be time based.\n\t * You can leverage {{#crossLink \"Ticker/getTime\"}}{{/crossLink}} and the {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}}\n\t * event object's \"delta\" properties to make this easier.\n\t *\n\t * Falls back on {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}} if the requestAnimationFrame API is not\n\t * supported.\n\t * @property RAF\n\t * @static\n\t * @type {String}\n\t * @default \"raf\"\n\t * @readonly\n\t **/\n\tTicker.RAF = \"raf\";\n\n\t/**\n\t * In this mode, Ticker uses the setTimeout API. This provides predictable, adaptive frame timing, but does not\n\t * provide the benefits of requestAnimationFrame (screen synch, background throttling).\n\t * @property TIMEOUT\n\t * @static\n\t * @type {String}\n\t * @default \"timeout\"\n\t * @readonly\n\t **/\n\tTicker.TIMEOUT = \"timeout\";\n\n\n// static events:\n\t/**\n\t * Dispatched each tick. The event will be dispatched to each listener even when the Ticker has been paused using\n\t * {{#crossLink \"Ticker/paused:property\"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n\t *      function handleTick(event) {\n\t *          console.log(\"Paused:\", event.paused, event.delta);\n\t *      }\n\t *\n\t * @event tick\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Boolean} paused Indicates whether the ticker is currently paused.\n\t * @param {Number} delta The time elapsed in ms since the last tick.\n\t * @param {Number} time The total time in ms since Ticker was initialized.\n\t * @param {Number} runTime The total time in ms that Ticker was not paused since it was initialized. For example,\n\t * \tyou could determine the amount of time that the Ticker has been paused since initialization with `time-runTime`.\n\t * @since 0.6.0\n\t */\n\n\n// public static properties:\n\t/**\n\t * Specifies the timing api (setTimeout or requestAnimationFrame) and mode to use. See\n\t * {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}}, {{#crossLink \"Ticker/RAF:property\"}}{{/crossLink}}, and\n\t * {{#crossLink \"Ticker/RAF_SYNCHED:property\"}}{{/crossLink}} for mode details.\n\t * @property timingMode\n\t * @static\n\t * @type {String}\n\t * @default Ticker.TIMEOUT\n\t **/\n\tTicker.timingMode = null;\n\n\t/**\n\t * Specifies a maximum value for the delta property in the tick event object. This is useful when building time\n\t * based animations and systems to prevent issues caused by large time gaps caused by background tabs, system sleep,\n\t * alert dialogs, or other blocking routines. Double the expected frame duration is often an effective value\n\t * (ex. maxDelta=50 when running at 40fps).\n\t * \n\t * This does not impact any other values (ex. time, runTime, etc), so you may experience issues if you enable maxDelta\n\t * when using both delta and other values.\n\t * \n\t * If 0, there is no maximum.\n\t * @property maxDelta\n\t * @static\n\t * @type {number}\n\t * @default 0\n\t */\n\tTicker.maxDelta = 0;\n\t\n\t/**\n\t * When the ticker is paused, all listeners will still receive a tick event, but the <code>paused</code> property\n\t * of the event will be `true`. Also, while paused the `runTime` will not increase. See {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}},\n\t * {{#crossLink \"Ticker/getTime\"}}{{/crossLink}}, and {{#crossLink \"Ticker/getEventTime\"}}{{/crossLink}} for more\n\t * info.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n\t *      createjs.Ticker.paused = true;\n\t *      function handleTick(event) {\n\t *          console.log(event.paused,\n\t *          \tcreatejs.Ticker.getTime(false),\n\t *          \tcreatejs.Ticker.getTime(true));\n\t *      }\n\t *\n\t * @property paused\n\t * @static\n\t * @type {Boolean}\n\t * @default false\n\t **/\n\tTicker.paused = false;\n\n\n// mix-ins:\n\t// EventDispatcher methods:\n\tTicker.removeEventListener = null;\n\tTicker.removeAllEventListeners = null;\n\tTicker.dispatchEvent = null;\n\tTicker.hasEventListener = null;\n\tTicker._listeners = null;\n\tcreatejs.EventDispatcher.initialize(Ticker); // inject EventDispatcher methods.\n\tTicker._addEventListener = Ticker.addEventListener;\n\tTicker.addEventListener = function() {\n\t\t!Ticker._inited&&Ticker.init();\n\t\treturn Ticker._addEventListener.apply(Ticker, arguments);\n\t};\n\n\n// private static properties:\n\t/**\n\t * @property _inited\n\t * @static\n\t * @type {Boolean}\n\t * @private\n\t **/\n\tTicker._inited = false;\n\n\t/**\n\t * @property _startTime\n\t * @static\n\t * @type {Number}\n\t * @private\n\t **/\n\tTicker._startTime = 0;\n\n\t/**\n\t * @property _pausedTime\n\t * @static\n\t * @type {Number}\n\t * @private\n\t **/\n\tTicker._pausedTime=0;\n\n\t/**\n\t * The number of ticks that have passed\n\t * @property _ticks\n\t * @static\n\t * @type {Number}\n\t * @private\n\t **/\n\tTicker._ticks = 0;\n\n\t/**\n\t * The number of ticks that have passed while Ticker has been paused\n\t * @property _pausedTicks\n\t * @static\n\t * @type {Number}\n\t * @private\n\t **/\n\tTicker._pausedTicks = 0;\n\n\t/**\n\t * @property _interval\n\t * @static\n\t * @type {Number}\n\t * @private\n\t **/\n\tTicker._interval = 50;\n\n\t/**\n\t * @property _lastTime\n\t * @static\n\t * @type {Number}\n\t * @private\n\t **/\n\tTicker._lastTime = 0;\n\n\t/**\n\t * @property _times\n\t * @static\n\t * @type {Array}\n\t * @private\n\t **/\n\tTicker._times = null;\n\n\t/**\n\t * @property _tickTimes\n\t * @static\n\t * @type {Array}\n\t * @private\n\t **/\n\tTicker._tickTimes = null;\n\n\t/**\n\t * Stores the timeout or requestAnimationFrame id.\n\t * @property _timerId\n\t * @static\n\t * @type {Number}\n\t * @private\n\t **/\n\tTicker._timerId = null;\n\t\n\t/**\n\t * True if currently using requestAnimationFrame, false if using setTimeout. This may be different than timingMode\n\t * if that property changed and a tick hasn't fired.\n\t * @property _raf\n\t * @static\n\t * @type {Boolean}\n\t * @private\n\t **/\n\tTicker._raf = true;\n\t\n\n// static getter / setters:\n\t/**\n\t * Use the {{#crossLink \"Ticker/interval:property\"}}{{/crossLink}} property instead.\n\t * @method _setInterval\n\t * @private\n\t * @static\n\t * @param {Number} interval\n\t **/\n\tTicker._setInterval = function(interval) {\n\t\tTicker._interval = interval;\n\t\tif (!Ticker._inited) { return; }\n\t\tTicker._setupTick();\n\t};\n\t// Ticker.setInterval is @deprecated. Remove for 1.1+\n\tTicker.setInterval = createjs.deprecate(Ticker._setInterval, \"Ticker.setInterval\");\n\n\t/**\n\t * Use the {{#crossLink \"Ticker/interval:property\"}}{{/crossLink}} property instead.\n\t * @method _getInterval\n\t * @private\n\t * @static\n\t * @return {Number}\n\t **/\n\tTicker._getInterval = function() {\n\t\treturn Ticker._interval;\n\t};\n\t// Ticker.getInterval is @deprecated. Remove for 1.1+\n\tTicker.getInterval = createjs.deprecate(Ticker._getInterval, \"Ticker.getInterval\");\n\n\t/**\n\t * Use the {{#crossLink \"Ticker/framerate:property\"}}{{/crossLink}} property instead.\n\t * @method _setFPS\n\t * @private\n\t * @static\n\t * @param {Number} value\n\t **/\n\tTicker._setFPS = function(value) {\n\t\tTicker._setInterval(1000/value);\n\t};\n\t// Ticker.setFPS is @deprecated. Remove for 1.1+\n\tTicker.setFPS = createjs.deprecate(Ticker._setFPS, \"Ticker.setFPS\");\n\n\t/**\n\t * Use the {{#crossLink \"Ticker/framerate:property\"}}{{/crossLink}} property instead.\n\t * @method _getFPS\n\t * @static\n\t * @private\n\t * @return {Number}\n\t **/\n\tTicker._getFPS = function() {\n\t\treturn 1000/Ticker._interval;\n\t};\n\t// Ticker.getFPS is @deprecated. Remove for 1.1+\n\tTicker.getFPS = createjs.deprecate(Ticker._getFPS, \"Ticker.getFPS\");\n\n\t/**\n\t * Indicates the target time (in milliseconds) between ticks. Default is 50 (20 FPS).\n\t * Note that actual time between ticks may be more than specified depending on CPU load.\n\t * This property is ignored if the ticker is using the `RAF` timing mode.\n\t * @property interval\n\t * @static\n\t * @type {Number}\n\t **/\n\t \n\t/**\n\t * Indicates the target frame rate in frames per second (FPS). Effectively just a shortcut to `interval`, where\n\t * `framerate == 1000/interval`.\n\t * @property framerate\n\t * @static\n\t * @type {Number}\n\t **/\n\ttry {\n\t\tObject.defineProperties(Ticker, {\n\t\t\tinterval: { get: Ticker._getInterval, set: Ticker._setInterval },\n\t\t\tframerate: { get: Ticker._getFPS, set: Ticker._setFPS }\n\t\t});\n\t} catch (e) { console.log(e); }\n\n\n// public static methods:\n\t/**\n\t * Starts the tick. This is called automatically when the first listener is added.\n\t * @method init\n\t * @static\n\t **/\n\tTicker.init = function() {\n\t\tif (Ticker._inited) { return; }\n\t\tTicker._inited = true;\n\t\tTicker._times = [];\n\t\tTicker._tickTimes = [];\n\t\tTicker._startTime = Ticker._getTime();\n\t\tTicker._times.push(Ticker._lastTime = 0);\n\t\tTicker.interval = Ticker._interval;\n\t};\n\t\n\t/**\n\t * Stops the Ticker and removes all listeners. Use init() to restart the Ticker.\n\t * @method reset\n\t * @static\n\t **/\n\tTicker.reset = function() {\n\t\tif (Ticker._raf) {\n\t\t\tvar f = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;\n\t\t\tf&&f(Ticker._timerId);\n\t\t} else {\n\t\t\tclearTimeout(Ticker._timerId);\n\t\t}\n\t\tTicker.removeAllEventListeners(\"tick\");\n\t\tTicker._timerId = Ticker._times = Ticker._tickTimes = null;\n\t\tTicker._startTime = Ticker._lastTime = Ticker._ticks = Ticker._pausedTime = 0;\n\t\tTicker._inited = false;\n\t};\n\n\t/**\n\t * Returns the average time spent within a tick. This can vary significantly from the value provided by getMeasuredFPS\n\t * because it only measures the time spent within the tick execution stack. \n\t * \n\t * Example 1: With a target FPS of 20, getMeasuredFPS() returns 20fps, which indicates an average of 50ms between \n\t * the end of one tick and the end of the next. However, getMeasuredTickTime() returns 15ms. This indicates that \n\t * there may be up to 35ms of \"idle\" time between the end of one tick and the start of the next.\n\t *\n\t * Example 2: With a target FPS of 30, {{#crossLink \"Ticker/framerate:property\"}}{{/crossLink}} returns 10fps, which\n\t * indicates an average of 100ms between the end of one tick and the end of the next. However, {{#crossLink \"Ticker/getMeasuredTickTime\"}}{{/crossLink}}\n\t * returns 20ms. This would indicate that something other than the tick is using ~80ms (another script, DOM\n\t * rendering, etc).\n\t * @method getMeasuredTickTime\n\t * @static\n\t * @param {Number} [ticks] The number of previous ticks over which to measure the average time spent in a tick.\n\t * Defaults to the number of ticks per second. To get only the last tick's time, pass in 1.\n\t * @return {Number} The average time spent in a tick in milliseconds.\n\t **/\n\tTicker.getMeasuredTickTime = function(ticks) {\n\t\tvar ttl=0, times=Ticker._tickTimes;\n\t\tif (!times || times.length < 1) { return -1; }\n\n\t\t// by default, calculate average for the past ~1 second:\n\t\tticks = Math.min(times.length, ticks||(Ticker._getFPS()|0));\n\t\tfor (var i=0; i<ticks; i++) { ttl += times[i]; }\n\t\treturn ttl/ticks;\n\t};\n\n\t/**\n\t * Returns the actual frames / ticks per second.\n\t * @method getMeasuredFPS\n\t * @static\n\t * @param {Number} [ticks] The number of previous ticks over which to measure the actual frames / ticks per second.\n\t * Defaults to the number of ticks per second.\n\t * @return {Number} The actual frames / ticks per second. Depending on performance, this may differ\n\t * from the target frames per second.\n\t **/\n\tTicker.getMeasuredFPS = function(ticks) {\n\t\tvar times = Ticker._times;\n\t\tif (!times || times.length < 2) { return -1; }\n\n\t\t// by default, calculate fps for the past ~1 second:\n\t\tticks = Math.min(times.length-1, ticks||(Ticker._getFPS()|0));\n\t\treturn 1000/((times[0]-times[ticks])/ticks);\n\t};\n\n\t/**\n\t * Returns the number of milliseconds that have elapsed since Ticker was initialized via {{#crossLink \"Ticker/init\"}}.\n\t * Returns -1 if Ticker has not been initialized. For example, you could use\n\t * this in a time synchronized animation to determine the exact amount of time that has elapsed.\n\t * @method getTime\n\t * @static\n\t * @param {Boolean} [runTime=false] If true only time elapsed while Ticker was not paused will be returned.\n\t * If false, the value returned will be total time elapsed since the first tick event listener was added.\n\t * @return {Number} Number of milliseconds that have elapsed since Ticker was initialized or -1.\n\t **/\n\tTicker.getTime = function(runTime) {\n\t\treturn Ticker._startTime ? Ticker._getTime() - (runTime ? Ticker._pausedTime : 0) : -1;\n\t};\n\n\t/**\n\t * Similar to the {{#crossLink \"Ticker/getTime\"}}{{/crossLink}} method, but returns the time on the most recent {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}}\n\t * event object.\n\t * @method getEventTime\n\t * @static\n\t * @param runTime {Boolean} [runTime=false] If true, the runTime property will be returned instead of time.\n\t * @returns {number} The time or runTime property from the most recent tick event or -1.\n\t */\n\tTicker.getEventTime = function(runTime) {\n\t\treturn Ticker._startTime ? (Ticker._lastTime || Ticker._startTime) - (runTime ? Ticker._pausedTime : 0) : -1;\n\t};\n\t\n\t/**\n\t * Returns the number of ticks that have been broadcast by Ticker.\n\t * @method getTicks\n\t * @static\n\t * @param {Boolean} pauseable Indicates whether to include ticks that would have been broadcast\n\t * while Ticker was paused. If true only tick events broadcast while Ticker is not paused will be returned.\n\t * If false, tick events that would have been broadcast while Ticker was paused will be included in the return\n\t * value. The default value is false.\n\t * @return {Number} of ticks that have been broadcast.\n\t **/\n\tTicker.getTicks = function(pauseable) {\n\t\treturn  Ticker._ticks - (pauseable ? Ticker._pausedTicks : 0);\n\t};\n\n\n// private static methods:\n\t/**\n\t * @method _handleSynch\n\t * @static\n\t * @private\n\t **/\n\tTicker._handleSynch = function() {\n\t\tTicker._timerId = null;\n\t\tTicker._setupTick();\n\n\t\t// run if enough time has elapsed, with a little bit of flexibility to be early:\n\t\tif (Ticker._getTime() - Ticker._lastTime >= (Ticker._interval-1)*0.97) {\n\t\t\tTicker._tick();\n\t\t}\n\t};\n\n\t/**\n\t * @method _handleRAF\n\t * @static\n\t * @private\n\t **/\n\tTicker._handleRAF = function() {\n\t\tTicker._timerId = null;\n\t\tTicker._setupTick();\n\t\tTicker._tick();\n\t};\n\n\t/**\n\t * @method _handleTimeout\n\t * @static\n\t * @private\n\t **/\n\tTicker._handleTimeout = function() {\n\t\tTicker._timerId = null;\n\t\tTicker._setupTick();\n\t\tTicker._tick();\n\t};\n\n\t/**\n\t * @method _setupTick\n\t * @static\n\t * @private\n\t **/\n\tTicker._setupTick = function() {\n\t\tif (Ticker._timerId != null) { return; } // avoid duplicates\n\n\t\tvar mode = Ticker.timingMode;\n\t\tif (mode == Ticker.RAF_SYNCHED || mode == Ticker.RAF) {\n\t\t\tvar f = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;\n\t\t\tif (f) {\n\t\t\t\tTicker._timerId = f(mode == Ticker.RAF ? Ticker._handleRAF : Ticker._handleSynch);\n\t\t\t\tTicker._raf = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tTicker._raf = false;\n\t\tTicker._timerId = setTimeout(Ticker._handleTimeout, Ticker._interval);\n\t};\n\n\t/**\n\t * @method _tick\n\t * @static\n\t * @private\n\t **/\n\tTicker._tick = function() {\n\t\tvar paused = Ticker.paused;\n\t\tvar time = Ticker._getTime();\n\t\tvar elapsedTime = time-Ticker._lastTime;\n\t\tTicker._lastTime = time;\n\t\tTicker._ticks++;\n\t\t\n\t\tif (paused) {\n\t\t\tTicker._pausedTicks++;\n\t\t\tTicker._pausedTime += elapsedTime;\n\t\t}\n\t\t\n\t\tif (Ticker.hasEventListener(\"tick\")) {\n\t\t\tvar event = new createjs.Event(\"tick\");\n\t\t\tvar maxDelta = Ticker.maxDelta;\n\t\t\tevent.delta = (maxDelta && elapsedTime > maxDelta) ? maxDelta : elapsedTime;\n\t\t\tevent.paused = paused;\n\t\t\tevent.time = time;\n\t\t\tevent.runTime = time-Ticker._pausedTime;\n\t\t\tTicker.dispatchEvent(event);\n\t\t}\n\t\t\n\t\tTicker._tickTimes.unshift(Ticker._getTime()-time);\n\t\twhile (Ticker._tickTimes.length > 100) { Ticker._tickTimes.pop(); }\n\n\t\tTicker._times.unshift(time);\n\t\twhile (Ticker._times.length > 100) { Ticker._times.pop(); }\n\t};\n\n\t/**\n\t * @method _getTime\n\t * @static\n\t * @private\n\t **/\n\tvar w=window, now=w.performance.now || w.performance.mozNow || w.performance.msNow || w.performance.oNow || w.performance.webkitNow;\n\tTicker._getTime = function() {\n\t\treturn ((now&&now.call(w.performance))||(new Date().getTime())) - Ticker._startTime;\n\t};\n\n\n\tcreatejs.Ticker = Ticker;\n}());\n\n//##############################################################################\n// AbstractTween.js\n//##############################################################################\n\nwindow.createjs = window.createjs||{};\n\n(function() {\n\t\"use strict\";\n\n\n// constructor\n\t/**\n\t * Base class that both {{#crossLink \"Tween\"}}{{/crossLink}} and {{#crossLink \"Timeline\"}}{{/crossLink}} extend. Should not be instantiated directly.\n\t * @class AbstractTween\n\t * @param {Object} [props] The configuration properties to apply to this instance (ex. `{loop:-1, paused:true}`).\n\t * Supported props are listed below. These props are set on the corresponding instance properties except where\n\t * specified.\n\t * @param {boolean} [props.useTicks=false]  See the {{#crossLink \"AbstractTween/useTicks:property\"}}{{/crossLink}} property for more information.\n\t * @param {boolean} [props.ignoreGlobalPause=false] See the {{#crossLink \"AbstractTween/ignoreGlobalPause:property\"}}{{/crossLink}} for more information.\n\t * @param {number|boolean} [props.loop=0] See the {{#crossLink \"AbstractTween/loop:property\"}}{{/crossLink}} for more information.\n\t * @param {boolean} [props.reversed=false] See the {{#crossLink \"AbstractTween/reversed:property\"}}{{/crossLink}} for more information.\n\t * @param {boolean} [props.bounce=false] See the {{#crossLink \"AbstractTween/bounce:property\"}}{{/crossLink}} for more information.\n\t * @param {number} [props.timeScale=1] See the {{#crossLink \"AbstractTween/timeScale:property\"}}{{/crossLink}} for more information.\n\t * @param {Function} [props.onChange] Adds the specified function as a listener to the {{#crossLink \"AbstractTween/change:event\"}}{{/crossLink}} event\n\t * @param {Function} [props.onComplete] Adds the specified function as a listener to the {{#crossLink \"AbstractTween/complete:event\"}}{{/crossLink}} event\n\t * @extends EventDispatcher\n\t * @constructor\n\t */\n\tfunction AbstractTween(props) {\n\t\tthis.EventDispatcher_constructor();\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * Causes this tween to continue playing when a global pause is active. For example, if TweenJS is using {{#crossLink \"Ticker\"}}{{/crossLink}},\n\t\t * then setting this to false (the default) will cause this tween to be paused when `Ticker.paused` is set to\n\t\t * `true`. See the {{#crossLink \"Tween/tick\"}}{{/crossLink}} method for more info. Can be set via the `props`\n\t\t * parameter.\n\t\t * @property ignoreGlobalPause\n\t\t * @type Boolean\n\t\t * @default false\n\t\t */\n\t\tthis.ignoreGlobalPause = false;\n\t\n\t\t/**\n\t\t * Indicates the number of times to loop. If set to -1, the tween will loop continuously.\n\t\t *\n\t\t * Note that a tween must loop at _least_ once to see it play in both directions when `{{#crossLink \"AbstractTween/bounce:property\"}}{{/crossLink}}`\n\t\t * is set to `true`.\n\t\t * @property loop\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.loop = 0;\n\t\n\t\t/**\n\t\t * Uses ticks for all durations instead of milliseconds. This also changes the behaviour of some actions (such as `call`).\n\t\t * Changing this value on a running tween could have unexpected results.\n\t\t * @property useTicks\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @readonly\n\t\t */\n\t\tthis.useTicks = false;\n\t\t\n\t\t/**\n\t\t * Causes the tween to play in reverse.\n\t\t * @property reversed\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.reversed = false;\n\t\t\n\t\t/**\n\t\t * Causes the tween to reverse direction at the end of each loop. Each single-direction play-through of the\n\t\t * tween counts as a single bounce. For example, to play a tween once forward, and once back, set the\n\t\t * `{{#crossLink \"AbstractTween/loop:property\"}}{{/crossLink}}` to `1`.\n\t\t * @property bounce\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.bounce = false;\n\t\t\n\t\t/**\n\t\t * Changes the rate at which the tween advances. For example, a `timeScale` value of `2` will double the\n\t\t * playback speed, a value of `0.5` would halve it.\n\t\t * @property timeScale\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.timeScale = 1;\n\t\n\t\t/**\n\t\t * Indicates the duration of this tween in milliseconds (or ticks if `useTicks` is true), irrespective of `loops`.\n\t\t * This value is automatically updated as you modify the tween. Changing it directly could result in unexpected\n\t\t * behaviour.\n\t\t * @property duration\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @readonly\n\t\t */\n\t\tthis.duration = 0;\n\t\n\t\t/**\n\t\t * The current normalized position of the tween. This will always be a value between 0 and `duration`.\n\t\t * Changing this property directly will have unexpected results, use {{#crossLink \"Tween/setPosition\"}}{{/crossLink}}.\n\t\t * @property position\n\t\t * @type {Object}\n\t\t * @default 0\n\t\t * @readonly\n\t\t */\n\t\tthis.position = 0;\n\t\t\n\t\t/**\n\t\t * The raw tween position. This value will be between `0` and `loops * duration` while the tween is active, or -1 before it activates.\n\t\t * @property rawPosition\n\t\t * @type {Number}\n\t\t * @default -1\n\t\t * @readonly\n\t\t */\n\t\tthis.rawPosition = -1;\n\t\t\n\t\t\n\t// private properties:\n\t\t/**\n\t\t * @property _paused\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis._paused = true;\n\t\t\n\t\t/**\n\t\t * @property _next\n\t\t * @type {Tween}\n\t\t * @default null\n\t\t * @protected\n\t\t */\n\t\tthis._next = null;\n\t\t\n\t\t/**\n\t\t * @property _prev\n\t\t * @type {Tween}\n\t\t * @default null\n\t\t * @protected\n\t\t */\n\t\tthis._prev = null;\n\t\t\n\t\t/**\n\t\t * @property _parent\n\t\t * @type {Object}\n\t\t * @default null\n\t\t * @protected\n\t\t */\n\t\tthis._parent = null;\n\n\t\t/**\n\t\t * @property _labels\n\t\t * @type Object\n\t\t * @protected\n\t\t **/\n\t\tthis._labels = null;\n\n\t\t/**\n\t\t * @property _labelList\n\t\t * @type Array[Object]\n\t\t * @protected\n\t\t **/\n\t\tthis._labelList = null;\n\n\t\tif (props) {\n\t\t\tthis.useTicks = !!props.useTicks;\n\t\t\tthis.ignoreGlobalPause = !!props.ignoreGlobalPause;\n\t\t\tthis.loop = props.loop === true ? -1 : (props.loop||0);\n\t\t\tthis.reversed = !!props.reversed;\n\t\t\tthis.bounce = !!props.bounce;\n\t\t\tthis.timeScale = props.timeScale||1;\n\t\t\tprops.onChange && this.addEventListener(\"change\", props.onChange);\n\t\t\tprops.onComplete && this.addEventListener(\"complete\", props.onComplete);\n\t\t}\n\t\t\n\t\t// while `position` is shared, it needs to happen after ALL props are set, so it's handled in _init()\n\t};\n\n\tvar p = createjs.extend(AbstractTween, createjs.EventDispatcher);\n\n// events:\n\t/**\n\t * Dispatched whenever the tween's position changes. It occurs after all tweened properties are updated and actions\n\t * are executed.\n\t * @event change\n\t **/\n\t \n\t/**\n\t * Dispatched when the tween reaches its end and has paused itself. This does not fire until all loops are complete;\n\t * tweens that loop continuously will never fire a complete event.\n\t * @event complete\n\t **/\n\t\n// getter / setters:\n\t\n\t/**\n\t * Use the {{#crossLink \"AbstractTween/paused:property\"}}{{/crossLink}} property instead.\n\t * @method _setPaused\n\t * @param {Boolean} [value=true] Indicates whether the tween should be paused (`true`) or played (`false`).\n\t * @return {AbstractTween} This tween instance (for chaining calls)\n\t * @protected\n\t * @chainable\n\t */\n\tp._setPaused = function(value) {\n\t\tcreatejs.Tween._register(this, value);\n\t\treturn this;\n\t};\n\tp.setPaused = createjs.deprecate(p._setPaused, \"AbstractTween.setPaused\");\n\t\n\t/**\n\t * Use the {{#crossLink \"AbstractTween/paused:property\"}}{{/crossLink}} property instead.\n\t * @method _getPaused\n\t * @protected\n\t */\n\tp._getPaused = function() {\n\t\treturn this._paused;\n\t};\n\tp.getPaused = createjs.deprecate(p._getPaused, \"AbstactTween.getPaused\");\n\t\n\t/**\n\t * Use the {{#crossLink \"AbstractTween/currentLabel:property\"}}{{/crossLink}} property instead.\n\t * @method _getCurrentLabel\n\t * @protected\n\t * @return {String} The name of the current label or null if there is no label\n\t **/\n\tp._getCurrentLabel = function(pos) {\n\t\tvar labels = this.getLabels();\n\t\tif (pos == null) { pos = this.position; }\n\t\tfor (var i = 0, l = labels.length; i<l; i++) { if (pos < labels[i].position) { break; } }\n\t\treturn (i===0) ? null : labels[i-1].label;\n\t};\n\tp.getCurrentLabel = createjs.deprecate(p._getCurrentLabel, \"AbstractTween.getCurrentLabel\");\n\t\n\t/**\n\t * Pauses or unpauses the tween. A paused tween is removed from the global registry and is eligible for garbage\n\t * collection if no other references to it exist.\n\t * @property paused\n\t * @type Boolean\n\t * @readonly\n\t **/\n\t \n\t/**\n\t * Returns the name of the label on or immediately before the current position. For example, given a tween with\n\t * two labels, \"first\" on frame index 4, and \"second\" on frame 8, `currentLabel` would return:\n\t * <UL>\n\t * \t\t<LI>null if the current position is 2.</LI>\n\t * \t\t<LI>\"first\" if the current position is 4.</LI>\n\t * \t\t<LI>\"first\" if the current position is 7.</LI>\n\t * \t\t<LI>\"second\" if the current position is 15.</LI>\n\t * </UL>\n\t * @property currentLabel\n\t * @type String\n\t * @readonly\n\t **/\n\t \n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tpaused: { set: p._setPaused, get: p._getPaused },\n\t\t\tcurrentLabel: { get: p._getCurrentLabel }\n\t\t});\n\t} catch (e) {}\n\n// public methods:\n\t/**\n\t * Advances the tween by a specified amount.\n\t * @method advance\n\t * @param {Number} delta The amount to advance in milliseconds (or ticks if useTicks is true). Negative values are supported.\n\t * @param {Number} [ignoreActions=false] If true, actions will not be executed due to this change in position.\n\t */\n\tp.advance = function(delta, ignoreActions) {\n\t\tthis.setPosition(this.rawPosition+delta*this.timeScale, ignoreActions);\n\t};\n\t\n\t/**\n\t * Advances the tween to a specified position.\n\t * @method setPosition\n\t * @param {Number} rawPosition The raw position to seek to in milliseconds (or ticks if useTicks is true).\n\t * @param {Boolean} [ignoreActions=false] If true, do not run any actions that would be triggered by this operation.\n\t * @param {Boolean} [jump=false] If true, only actions at the new position will be run. If false, actions between the old and new position are run.\n\t * @param {Function} [callback] Primarily for use with MovieClip, this callback is called after properties are updated, but before actions are run.\n\t */\n\tp.setPosition = function(rawPosition, ignoreActions, jump, callback) {\n\t\tvar d=this.duration, loopCount=this.loop, prevRawPos = this.rawPosition;\n\t\tvar loop=0, t=0, end=false;\n\t\t\n\t\t// normalize position:\n\t\tif (rawPosition < 0) { rawPosition = 0; }\n\t\t\n\t\tif (d === 0) {\n\t\t\t// deal with 0 length tweens.\n\t\t\tend = true;\n\t\t\tif (prevRawPos !== -1) { return end; } // we can avoid doing anything else if we're already at 0.\n\t\t} else {\n\t\t\tloop = rawPosition/d|0;\n\t\t\tt = rawPosition-loop*d;\n\t\t\t\n\t\t\tend = (loopCount !== -1 && rawPosition >= loopCount*d+d);\n\t\t\tif (end) { rawPosition = (t=d)*(loop=loopCount)+d; }\n\t\t\tif (rawPosition === prevRawPos) { return end; } // no need to update\n\t\t\t\n\t\t\tvar rev = !this.reversed !== !(this.bounce && loop%2); // current loop is reversed\n\t\t\tif (rev) { t = d-t; }\n\t\t}\n\t\t\n\t\t// set this in advance in case an action modifies position:\n\t\tthis.position = t;\n\t\tthis.rawPosition = rawPosition;\n\t\t\n\t\tthis._updatePosition(jump, end);\n\t\tif (end) { this.paused = true; }\n\t\t\n\t\tcallback&&callback(this);\n\t\t\n\t\tif (!ignoreActions) { this._runActions(prevRawPos, rawPosition, jump, !jump && prevRawPos === -1); }\n\t\t\n\t\tthis.dispatchEvent(\"change\");\n\t\tif (end) { this.dispatchEvent(\"complete\"); }\n\t};\n\t\n\t/**\n\t * Calculates a normalized position based on a raw position. For example, given a tween with a duration of 3000ms set to loop:\n\t * \tconsole.log(myTween.calculatePosition(3700); // 700\n\t * @method calculatePosition\n\t * @param {Number} rawPosition A raw position.\n\t */\n\tp.calculatePosition = function(rawPosition) {\n\t\t// largely duplicated from setPosition, but necessary to avoid having to instantiate generic objects to pass values (end, loop, position) back.\n\t\tvar d=this.duration, loopCount=this.loop, loop=0, t=0;\n\t\t\n\t\tif (d===0) { return 0; }\n\t\tif (loopCount !== -1 && rawPosition >= loopCount*d+d) { t = d; loop = loopCount } // end\n\t\telse if (rawPosition < 0) { t = 0; }\n\t\telse { loop = rawPosition/d|0; t = rawPosition-loop*d;  }\n\t\t\n\t\tvar rev = !this.reversed !== !(this.bounce && loop%2); // current loop is reversed\n\t\treturn rev ? d-t : t;\n\t};\n\t\n\t/**\n\t * Returns a list of the labels defined on this tween sorted by position.\n\t * @method getLabels\n\t * @return {Array[Object]} A sorted array of objects with label and position properties.\n\t **/\n\tp.getLabels = function() {\n\t\tvar list = this._labelList;\n\t\tif (!list) {\n\t\t\tlist = this._labelList = [];\n\t\t\tvar labels = this._labels;\n\t\t\tfor (var n in labels) {\n\t\t\t\tlist.push({label:n, position:labels[n]});\n\t\t\t}\n\t\t\tlist.sort(function (a,b) { return a.position- b.position; });\n\t\t}\n\t\treturn list;\n\t};\n\t\n\n\t/**\n\t * Defines labels for use with gotoAndPlay/Stop. Overwrites any previously set labels.\n\t * @method setLabels\n\t * @param {Object} labels An object defining labels for using {{#crossLink \"Timeline/gotoAndPlay\"}}{{/crossLink}}/{{#crossLink \"Timeline/gotoAndStop\"}}{{/crossLink}}\n\t * in the form `{myLabelName:time}` where time is in milliseconds (or ticks if `useTicks` is `true`).\n\t **/\n\tp.setLabels = function(labels) {\n\t\tthis._labels = labels;\n\t\tthis._labelList = null;\n\t};\n\n\t/**\n\t * Adds a label that can be used with {{#crossLink \"Timeline/gotoAndPlay\"}}{{/crossLink}}/{{#crossLink \"Timeline/gotoAndStop\"}}{{/crossLink}}.\n\t * @method addLabel\n\t * @param {String} label The label name.\n\t * @param {Number} position The position this label represents.\n\t **/\n\tp.addLabel = function(label, position) {\n\t\tif (!this._labels) { this._labels = {}; }\n\t\tthis._labels[label] = position;\n\t\tvar list = this._labelList;\n\t\tif (list) {\n\t\t\tfor (var i= 0,l=list.length; i<l; i++) { if (position < list[i].position) { break; } }\n\t\t\tlist.splice(i, 0, {label:label, position:position});\n\t\t}\n\t};\n\t\n\t/**\n\t * Unpauses this timeline and jumps to the specified position or label.\n\t * @method gotoAndPlay\n\t * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`)\n\t * or label to jump to.\n\t **/\n\tp.gotoAndPlay = function(positionOrLabel) {\n\t\tthis.paused = false;\n\t\tthis._goto(positionOrLabel);\n\t};\n\n\t/**\n\t * Pauses this timeline and jumps to the specified position or label.\n\t * @method gotoAndStop\n\t * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`) or label\n\t * to jump to.\n\t **/\n\tp.gotoAndStop = function(positionOrLabel) {\n\t\tthis.paused = true;\n\t\tthis._goto(positionOrLabel);\n\t};\n\t\n\t/**\n\t * If a numeric position is passed, it is returned unchanged. If a string is passed, the position of the\n\t * corresponding frame label will be returned, or `null` if a matching label is not defined.\n\t * @method resolve\n\t * @param {String|Number} positionOrLabel A numeric position value or label string.\n\t **/\n\tp.resolve = function(positionOrLabel) {\n\t\tvar pos = Number(positionOrLabel);\n\t\tif (isNaN(pos)) { pos = this._labels && this._labels[positionOrLabel]; }\n\t\treturn pos;\n\t};\n\t\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t */\n\tp.toString = function() {\n\t\treturn \"[AbstractTween]\";\n\t};\n\n\t/**\n\t * @method clone\n\t * @protected\n\t */\n\tp.clone = function() {\n\t\tthrow(\"AbstractTween can not be cloned.\")\n\t};\n\n\n// private methods:\n\t/**\n\t * Shared logic that executes at the end of the subclass constructor.\n\t * @method _init\n\t * @protected\n\t */\n\tp._init = function(props) {\n\t\tif (!props || !props.paused) { this.paused = false; }\n\t\tif (props&&(props.position!=null)) { this.setPosition(props.position); }\n\t};\n\n\t/**\n\t * @method _updatePosition\n\t * @protected\n\t */\n\tp._updatePosition = function(jump, end) {\n\t\t// abstract.\n\t};\n\t\n\t/**\n\t * @method _goto\n\t * @protected\n\t **/\n\tp._goto = function(positionOrLabel) {\n\t\tvar pos = this.resolve(positionOrLabel);\n\t\tif (pos != null) { this.setPosition(pos, false, true); }\n\t};\n\t\n\t/**\n\t * @method _runActions\n\t * @protected\n\t */\n\tp._runActions = function(startRawPos, endRawPos, jump, includeStart) {\n\t\t// runs actions between startPos & endPos. Separated to support action deferral.\n\t\t\n\t\t//console.log(this.passive === false ? \" > Tween\" : \"Timeline\", \"run\", startRawPos, endRawPos, jump, includeStart);\n\t\t\n\t\t// if we don't have any actions, and we're not a Timeline, then return:\n\t\t// TODO: a cleaner way to handle this would be to override this method in Tween, but I'm not sure it's worth the overhead.\n\t\tif (!this._actionHead && !this.tweens) { return; } \n\t\t\n\t\tvar d=this.duration, reversed=this.reversed, bounce=this.bounce, loopCount=this.loop;\n\t\tvar loop0, loop1, t0, t1;\n\t\t\n\t\tif (d === 0) {\n\t\t\t// deal with 0 length tweens:\n\t\t\tloop0 = loop1 = t0 = t1 = 0;\n\t\t\treversed = bounce = false;\n\t\t} else {\n\t\t\tloop0=startRawPos/d|0;\n\t\t\tloop1=endRawPos/d|0;\n\t\t\tt0=startRawPos-loop0*d;\n\t\t\tt1=endRawPos-loop1*d;\n\t\t}\n\t\t\n\t\t// catch positions that are past the end:\n\t\tif (loopCount !== -1) {\n\t\t\tif (loop1 > loopCount) { t1=d; loop1=loopCount; }\n\t\t\tif (loop0 > loopCount) { t0=d; loop0=loopCount; }\n\t\t}\n\t\t\n\t\t// special cases:\n\t\tif (jump) { return this._runActionsRange(t1, t1, jump, includeStart); } // jump.\n\t\telse if (loop0 === loop1 && t0 === t1 && !jump && !includeStart) { return; } // no actions if the position is identical and we aren't including the start\n\t\telse if (loop0 === -1) { loop0 = t0 = 0; } // correct the -1 value for first advance, important with useTicks.\n\t\t\n\t\tvar dir = (startRawPos <= endRawPos), loop = loop0;\n\t\tdo {\n\t\t\tvar rev = !reversed !== !(bounce && loop % 2);\n\n\t\t\tvar start = (loop === loop0) ? t0 : dir ? 0 : d;\n\t\t\tvar end = (loop === loop1) ? t1 : dir ? d : 0;\n\t\t\t\n\t\t\tif (rev) {\n\t\t\t\tstart = d - start;\n\t\t\t\tend = d - end;\n\t\t\t}\n\t\t\t\n\t\t\tif (bounce && loop !== loop0 && start === end) { /* bounced onto the same time/frame, don't re-execute end actions */ }\n\t\t\telse if (this._runActionsRange(start, end, jump, includeStart || (loop !== loop0 && !bounce))) { return true; }\n\t\t\t\t\n\t\t\tincludeStart = false;\n\t\t} while ((dir && ++loop <= loop1) || (!dir && --loop >= loop1));\n\t};\n\t\n\tp._runActionsRange = function(startPos, endPos, jump, includeStart) {\n\t\t// abstract\n\t};\n\n\tcreatejs.AbstractTween = createjs.promote(AbstractTween, \"EventDispatcher\");\n}());\n\n//##############################################################################\n// Tween.js\n//##############################################################################\n\nwindow.createjs = window.createjs||{};\n\n(function() {\n\t\"use strict\";\n\n\n// constructor\n\t/**\n\t * Tweens properties for a single target. Methods can be chained to create complex animation sequences:\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *\tcreatejs.Tween.get(target)\n\t *\t\t.wait(500)\n\t *\t\t.to({alpha:0, visible:false}, 1000)\n\t *\t\t.call(handleComplete);\n\t *\n\t * Multiple tweens can share a target, however if they affect the same properties there could be unexpected\n\t * behaviour. To stop all tweens on an object, use {{#crossLink \"Tween/removeTweens\"}}{{/crossLink}} or pass `override:true`\n\t * in the props argument.\n\t *\n\t * \tcreatejs.Tween.get(target, {override:true}).to({x:100});\n\t *\n\t * Subscribe to the {{#crossLink \"Tween/change:event\"}}{{/crossLink}} event to be notified when the tween position changes.\n\t *\n\t * \tcreatejs.Tween.get(target, {override:true}).to({x:100}).addEventListener(\"change\", handleChange);\n\t * \tfunction handleChange(event) {\n\t * \t\t// The tween changed.\n\t * \t}\n\t *\n\t * See the {{#crossLink \"Tween/get\"}}{{/crossLink}} method also.\n\t * @class Tween\n\t * @param {Object} target The target object that will have its properties tweened.\n\t * @param {Object} [props] The configuration properties to apply to this instance (ex. `{loop:-1, paused:true}`).\n\t * Supported props are listed below. These props are set on the corresponding instance properties except where\n\t * specified.\n\t * @param {boolean} [props.useTicks=false]  See the {{#crossLink \"AbstractTween/useTicks:property\"}}{{/crossLink}} property for more information.\n\t * @param {boolean} [props.ignoreGlobalPause=false] See the {{#crossLink \"AbstractTween/ignoreGlobalPause:property\"}}{{/crossLink}} for more information.\n\t * @param {number|boolean} [props.loop=0] See the {{#crossLink \"AbstractTween/loop:property\"}}{{/crossLink}} for more information.\n\t * @param {boolean} [props.reversed=false] See the {{#crossLink \"AbstractTween/reversed:property\"}}{{/crossLink}} for more information.\n\t * @param {boolean} [props.bounce=false] See the {{#crossLink \"AbstractTween/bounce:property\"}}{{/crossLink}} for more information.\n\t * @param {number} [props.timeScale=1] See the {{#crossLink \"AbstractTween/timeScale:property\"}}{{/crossLink}} for more information.\n\t * @param {object} [props.pluginData] See the {{#crossLink \"Tween/pluginData:property\"}}{{/crossLink}} for more information.\n\t * @param {boolean} [props.paused=false] See the {{#crossLink \"AbstractTween/paused:property\"}}{{/crossLink}} for more information.\n\t * @param {number} [props.position=0] The initial position for this tween. See {{#crossLink \"AbstractTween/position:property\"}}{{/crossLink}}\n\t * @param {Function} [props.onChange] Adds the specified function as a listener to the {{#crossLink \"AbstractTween/change:event\"}}{{/crossLink}} event\n\t * @param {Function} [props.onComplete] Adds the specified function as a listener to the {{#crossLink \"AbstractTween/complete:event\"}}{{/crossLink}} event\n\t * @param {boolean} [props.override=false] Removes all existing tweens for the target when set to `true`.\n\t * </UL>\n\t * @extends AbstractTween\n\t * @constructor\n\t */\n\tfunction Tween(target, props) {\n\t\tthis.AbstractTween_constructor(props);\n\t\t\n\t// public properties:\n\t\n\t\t/**\n\t\t * Allows you to specify data that will be used by installed plugins. Each plugin uses this differently, but in general\n\t\t * you specify data by assigning it to a property of `pluginData` with the same name as the plugin.\n\t\t * Note that in many cases, this data is used as soon as the plugin initializes itself for the tween.\n\t\t * As such, this data should be set before the first `to` call in most cases.\n\t\t * @example\n\t\t *\tmyTween.pluginData.SmartRotation = data;\n\t\t * \n\t\t * Most plugins also support a property to disable them for a specific tween. This is typically the plugin name followed by \"_disabled\".\n\t\t * @example\n\t\t *\tmyTween.pluginData.SmartRotation_disabled = true;\n\t\t * \n\t\t * Some plugins also store working data in this object, usually in a property named `_PluginClassName`.\n\t\t * See the documentation for individual plugins for more details.\n\t\t * @property pluginData\n\t\t * @type {Object}\n\t\t */\n\t\tthis.pluginData = null;\n\t\n\t\t/**\n\t\t * The target of this tween. This is the object on which the tweened properties will be changed.\n\t\t * @property target\n\t\t * @type {Object}\n\t\t * @readonly\n\t\t */\n\t\tthis.target = target;\n\t\n\t\t/**\n\t\t * Indicates the tween's current position is within a passive wait.\n\t\t * @property passive\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @readonly\n\t\t **/\n\t\tthis.passive = false;\n\t\t\n\t\t\n\t// private properties:\n\t\n\t\t/**\n\t\t * @property _stepHead\n\t\t * @type {TweenStep}\n\t\t * @protected\n\t\t */\n\t\tthis._stepHead = new TweenStep(null, 0, 0, {}, null, true);\n\t\t\n\t\t/**\n\t\t * @property _stepTail\n\t\t * @type {TweenStep}\n\t\t * @protected\n\t\t */\n\t\tthis._stepTail = this._stepHead;\n\t\t\n\t\t/**\n\t\t * The position within the current step. Used by MovieClip.\n\t\t * @property _stepPosition\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @protected\n\t\t */\n\t\tthis._stepPosition = 0;\n\t\t\n\t\t/**\n\t\t * @property _actionHead\n\t\t * @type {TweenAction}\n\t\t * @protected\n\t\t */\n\t\tthis._actionHead = null;\n\t\t\n\t\t/**\n\t\t * @property _actionTail\n\t\t * @type {TweenAction}\n\t\t * @protected\n\t\t */\n\t\tthis._actionTail = null;\n\t\t\n\t\t/**\n\t\t * Plugins added to this tween instance.\n\t\t * @property _plugins\n\t\t * @type Array[Object]\n\t\t * @default null\n\t\t * @protected\n\t\t */\n\t\tthis._plugins = null;\n\t\t\n\t\t/**\n\t\t * Hash for quickly looking up added plugins. Null until a plugin is added.\n\t\t * @property _plugins\n\t\t * @type Object\n\t\t * @default null\n\t\t * @protected\n\t\t */\n\t\tthis._pluginIds = null;\n\t\t\n\t\t/**\n\t\t * Used by plugins to inject new properties.\n\t\t * @property _injected\n\t\t * @type {Object}\n\t\t * @default null\n\t\t * @protected\n\t\t */\n\t\tthis._injected = null;\n\n\t\tif (props) {\n\t\t\tthis.pluginData = props.pluginData;\n\t\t\tif (props.override) { Tween.removeTweens(target); }\n\t\t}\n\t\tif (!this.pluginData) { this.pluginData = {}; }\n\t\t\n\t\tthis._init(props);\n\t};\n\n\tvar p = createjs.extend(Tween, createjs.AbstractTween);\n\n// static properties\n\n\t/**\n\t * Constant returned by plugins to tell the tween not to use default assignment.\n\t * @property IGNORE\n\t * @type Object\n\t * @static\n\t */\n\tTween.IGNORE = {};\n\n\t/**\n\t * @property _listeners\n\t * @type Array[Tween]\n\t * @static\n\t * @protected\n\t */\n\tTween._tweens = [];\n\n\t/**\n\t * @property _plugins\n\t * @type Object\n\t * @static\n\t * @protected\n\t */\n\tTween._plugins = null;\n\t\n\t/**\n\t * @property _tweenHead\n\t * @type Tween\n\t * @static\n\t * @protected\n\t */\n\tTween._tweenHead = null;\n\t\n\t/**\n\t * @property _tweenTail\n\t * @type Tween\n\t * @static\n\t * @protected\n\t */\n\tTween._tweenTail = null;\n\n\n// static methods\t\n\t/**\n\t * Returns a new tween instance. This is functionally identical to using `new Tween(...)`, but may look cleaner\n\t * with the chained syntax of TweenJS.\n\t * <h4>Example</h4>\n\t *\n\t *\tvar tween = createjs.Tween.get(target).to({x:100}, 500);\n\t *\t// equivalent to:\n\t *\tvar tween = new createjs.Tween(target).to({x:100}, 500);\n\t *\n\t * @method get\n\t * @param {Object} target The target object that will have its properties tweened.\n\t * @param {Object} [props] The configuration properties to apply to this instance (ex. `{loop:-1, paused:true}`).\n\t * Supported props are listed below. These props are set on the corresponding instance properties except where\n\t * specified.\n\t * @param {boolean} [props.useTicks=false]  See the {{#crossLink \"AbstractTween/useTicks:property\"}}{{/crossLink}} property for more information.\n\t * @param {boolean} [props.ignoreGlobalPause=false] See the {{#crossLink \"AbstractTween/ignoreGlobalPause:property\"}}{{/crossLink}} for more information.\n\t * @param {number|boolean} [props.loop=0] See the {{#crossLink \"AbstractTween/loop:property\"}}{{/crossLink}} for more information.\n\t * @param {boolean} [props.reversed=false] See the {{#crossLink \"AbstractTween/reversed:property\"}}{{/crossLink}} for more information.\n\t * @param {boolean} [props.bounce=false] See the {{#crossLink \"AbstractTween/bounce:property\"}}{{/crossLink}} for more information.\n\t * @param {number} [props.timeScale=1] See the {{#crossLink \"AbstractTween/timeScale:property\"}}{{/crossLink}} for more information.\n\t * @param {object} [props.pluginData] See the {{#crossLink \"Tween/pluginData:property\"}}{{/crossLink}} for more information.\n\t * @param {boolean} [props.paused=false] See the {{#crossLink \"AbstractTween/paused:property\"}}{{/crossLink}} for more information.\n\t * @param {number} [props.position=0] The initial position for this tween. See {{#crossLink \"AbstractTween/position:property\"}}{{/crossLink}}\n\t * @param {Function} [props.onChange] Adds the specified function as a listener to the {{#crossLink \"AbstractTween/change:event\"}}{{/crossLink}} event\n\t * @param {Function} [props.onComplete] Adds the specified function as a listener to the {{#crossLink \"AbstractTween/complete:event\"}}{{/crossLink}} event\n\t * @param {boolean} [props.override=false] Removes all existing tweens for the target when set to `true`.\n\t * @return {Tween} A reference to the created tween.\n\t * @static\n\t */\n\tTween.get = function(target, props) {\n\t\treturn new Tween(target, props);\n\t};\n\n\t/**\n\t * Advances all tweens. This typically uses the {{#crossLink \"Ticker\"}}{{/crossLink}} class, but you can call it\n\t * manually if you prefer to use your own \"heartbeat\" implementation.\n\t * @method tick\n\t * @param {Number} delta The change in time in milliseconds since the last tick. Required unless all tweens have\n\t * `useTicks` set to true.\n\t * @param {Boolean} paused Indicates whether a global pause is in effect. Tweens with {{#crossLink \"Tween/ignoreGlobalPause:property\"}}{{/crossLink}}\n\t * will ignore this, but all others will pause if this is `true`.\n\t * @static\n\t */\n\tTween.tick = function(delta, paused) {\n\t\tvar tween = Tween._tweenHead;\n\t\twhile (tween) {\n\t\t\tvar next = tween._next; // in case it completes and wipes its _next property\n\t\t\tif ((paused && !tween.ignoreGlobalPause) || tween._paused) { /* paused */ }\n\t\t\telse { tween.advance(tween.useTicks?1:delta); }\n\t\t\ttween = next;\n\t\t}\n\t};\n\n\t/**\n\t * Handle events that result from Tween being used as an event handler. This is included to allow Tween to handle\n\t * {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}} events from the createjs {{#crossLink \"Ticker\"}}{{/crossLink}}.\n\t * No other events are handled in Tween.\n\t * @method handleEvent\n\t * @param {Object} event An event object passed in by the {{#crossLink \"EventDispatcher\"}}{{/crossLink}}. Will\n\t * usually be of type \"tick\".\n\t * @private\n\t * @static\n\t * @since 0.4.2\n\t */\n\tTween.handleEvent = function(event) {\n\t\tif (event.type === \"tick\") {\n\t\t\tthis.tick(event.delta, event.paused);\n\t\t}\n\t};\n\n\t/**\n\t * Removes all existing tweens for a target. This is called automatically by new tweens if the `override`\n\t * property is `true`.\n\t * @method removeTweens\n\t * @param {Object} target The target object to remove existing tweens from.\n\t * @static\n\t */\n\tTween.removeTweens = function(target) {\n\t\tif (!target.tweenjs_count) { return; }\n\t\tvar tween = Tween._tweenHead;\n\t\twhile (tween) {\n\t\t\tvar next = tween._next;\n\t\t\tif (tween.target === target) { Tween._register(tween, true); }\n\t\t\ttween = next;\n\t\t}\n\t\ttarget.tweenjs_count = 0;\n\t};\n\n\t/**\n\t * Stop and remove all existing tweens.\n\t * @method removeAllTweens\n\t * @static\n\t * @since 0.4.1\n\t */\n\tTween.removeAllTweens = function() {\n\t\tvar tween = Tween._tweenHead;\n\t\twhile (tween) {\n\t\t\tvar next = tween._next;\n\t\t\ttween._paused = true;\n\t\t\ttween.target&&(tween.target.tweenjs_count = 0);\n\t\t\ttween._next = tween._prev = null;\n\t\t\ttween = next;\n\t\t}\n\t\tTween._tweenHead = Tween._tweenTail = null;\n\t};\n\n\t/**\n\t * Indicates whether there are any active tweens on the target object (if specified) or in general.\n\t * @method hasActiveTweens\n\t * @param {Object} [target] The target to check for active tweens. If not specified, the return value will indicate\n\t * if there are any active tweens on any target.\n\t * @return {Boolean} Indicates if there are active tweens.\n\t * @static\n\t */\n\tTween.hasActiveTweens = function(target) {\n\t\tif (target) { return !!target.tweenjs_count; }\n\t\treturn !!Tween._tweenHead;\n\t};\n\n\t/**\n\t * Installs a plugin, which can modify how certain properties are handled when tweened. See the {{#crossLink \"SamplePlugin\"}}{{/crossLink}}\n\t * for an example of how to write TweenJS plugins. Plugins should generally be installed via their own `install` method, in order to provide\n\t * the plugin with an opportunity to configure itself.\n\t * @method _installPlugin\n\t * @param {Object} plugin The plugin to install\n\t * @static\n\t * @protected\n\t */\n\tTween._installPlugin = function(plugin) {\n\t\tvar priority = (plugin.priority = plugin.priority||0), arr = (Tween._plugins = Tween._plugins || []);\n\t\tfor (var i=0,l=arr.length;i<l;i++) {\n\t\t\tif (priority < arr[i].priority) { break; }\n\t\t}\n\t\tarr.splice(i,0,plugin);\n\t};\n\n\t/**\n\t * Registers or unregisters a tween with the ticking system.\n\t * @method _register\n\t * @param {Tween} tween The tween instance to register or unregister.\n\t * @param {Boolean} paused If `false`, the tween is registered. If `true` the tween is unregistered.\n\t * @static\n\t * @protected\n\t */\n\tTween._register = function(tween, paused) {\n\t\tvar target = tween.target;\n\t\tif (!paused && tween._paused) {\n\t\t\t// TODO: this approach might fail if a dev is using sealed objects\n\t\t\tif (target) { target.tweenjs_count = target.tweenjs_count ? target.tweenjs_count+1 : 1; }\n\t\t\tvar tail = Tween._tweenTail;\n\t\t\tif (!tail) { Tween._tweenHead = Tween._tweenTail = tween; }\n\t\t\telse {\n\t\t\t\tTween._tweenTail = tail._next = tween;\n\t\t\t\ttween._prev = tail;\n\t\t\t}\n\t\t\tif (!Tween._inited && createjs.Ticker) { createjs.Ticker.addEventListener(\"tick\", Tween); Tween._inited = true; }\n\t\t} else if (paused && !tween._paused) {\n\t\t\tif (target) { target.tweenjs_count--; }\n\t\t\tvar next = tween._next, prev = tween._prev;\n\t\t\t\n\t\t\tif (next) { next._prev = prev; }\n\t\t\telse { Tween._tweenTail = prev; } // was tail\n\t\t\tif (prev) { prev._next = next; }\n\t\t\telse { Tween._tweenHead = next; } // was head.\n\t\t\t\n\t\t\ttween._next = tween._prev = null;\n\t\t}\n\t\ttween._paused = paused;\n\t};\n\n\n// events:\n\n// public methods:\n\t/**\n\t * Adds a wait (essentially an empty tween).\n\t * <h4>Example</h4>\n\t *\n\t *\t//This tween will wait 1s before alpha is faded to 0.\n\t *\tcreatejs.Tween.get(target).wait(1000).to({alpha:0}, 1000);\n\t *\n\t * @method wait\n\t * @param {Number} duration The duration of the wait in milliseconds (or in ticks if `useTicks` is true).\n\t * @param {Boolean} [passive=false] Tween properties will not be updated during a passive wait. This\n\t * is mostly useful for use with {{#crossLink \"Timeline\"}}{{/crossLink}} instances that contain multiple tweens\n\t * affecting the same target at different times.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t * @chainable\n\t **/\n\tp.wait = function(duration, passive) {\n\t\tif (duration > 0) { this._addStep(+duration, this._stepTail.props, null, passive); }\n\t\treturn this;\n\t};\n\n\t/**\n\t * Adds a tween from the current values to the specified properties. Set duration to 0 to jump to these value.\n\t * Numeric properties will be tweened from their current value in the tween to the target value. Non-numeric\n\t * properties will be set at the end of the specified duration.\n\t * <h4>Example</h4>\n\t *\n\t *\tcreatejs.Tween.get(target).to({alpha:0, visible:false}, 1000);\n\t *\n\t * @method to\n\t * @param {Object} props An object specifying property target values for this tween (Ex. `{x:300}` would tween the x\n\t * property of the target to 300).\n\t * @param {Number} [duration=0] The duration of the tween in milliseconds (or in ticks if `useTicks` is true).\n\t * @param {Function} [ease=\"linear\"] The easing function to use for this tween. See the {{#crossLink \"Ease\"}}{{/crossLink}}\n\t * class for a list of built-in ease functions.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t * @chainable\n\t */\n\tp.to = function(props, duration, ease) {\n\t\tif (duration == null || duration < 0) { duration = 0; }\n\t\tvar step = this._addStep(+duration, null, ease);\n\t\tthis._appendProps(props, step);\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Adds a label that can be used with {{#crossLink \"Tween/gotoAndPlay\"}}{{/crossLink}}/{{#crossLink \"Tween/gotoAndStop\"}}{{/crossLink}}\n\t * at the current point in the tween. For example:\n\t * \n\t * \tvar tween = createjs.Tween.get(foo)\n\t * \t\t\t\t\t.to({x:100}, 1000)\n\t * \t\t\t\t\t.label(\"myLabel\")\n\t * \t\t\t\t\t.to({x:200}, 1000);\n\t * // ...\n\t * tween.gotoAndPlay(\"myLabel\"); // would play from 1000ms in.\n\t * \n\t * @method addLabel\n\t * @param {String} label The label name.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t * @chainable\n\t **/\n\tp.label = function(name) {\n\t\tthis.addLabel(name, this.duration);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Adds an action to call the specified function.\n\t * <h4>Example</h4>\n\t *\n\t * \t//would call myFunction() after 1 second.\n\t * \tcreatejs.Tween.get().wait(1000).call(myFunction);\n\t *\n\t * @method call\n\t * @param {Function} callback The function to call.\n\t * @param {Array} [params]. The parameters to call the function with. If this is omitted, then the function\n\t * will be called with a single param pointing to this tween.\n\t * @param {Object} [scope]. The scope to call the function in. If omitted, it will be called in the target's scope.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t * @chainable\n\t */\n\tp.call = function(callback, params, scope) {\n\t\treturn this._addAction(scope||this.target, callback, params||[this]);\n\t};\n\n\t/**\n\t * Adds an action to set the specified props on the specified target. If `target` is null, it will use this tween's\n\t * target. Note that for properties on the target object, you should consider using a zero duration {{#crossLink \"Tween/to\"}}{{/crossLink}}\n\t * operation instead so the values are registered as tweened props.\n\t * <h4>Example</h4>\n\t *\n\t *\tmyTween.wait(1000).set({visible:false}, foo);\n\t *\n\t * @method set\n\t * @param {Object} props The properties to set (ex. `{visible:false}`).\n\t * @param {Object} [target] The target to set the properties on. If omitted, they will be set on the tween's target.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t * @chainable\n\t */\n\tp.set = function(props, target) {\n\t\treturn this._addAction(target||this.target, this._set, [props]);\n\t};\n\n\t/**\n\t * Adds an action to play (unpause) the specified tween. This enables you to sequence multiple tweens.\n\t * <h4>Example</h4>\n\t *\n\t *\tmyTween.to({x:100}, 500).play(otherTween);\n\t *\n\t * @method play\n\t * @param {Tween} [tween] The tween to play. Defaults to this tween.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t * @chainable\n\t */\n\tp.play = function(tween) {\n\t\treturn this._addAction(tween||this, this._set, [{paused:false}]);\n\t};\n\n\t/**\n\t * Adds an action to pause the specified tween.\n\t * \n\t * \tmyTween.pause(otherTween).to({alpha:1}, 1000).play(otherTween);\n\t * \n\t * Note that this executes at the end of a tween update, so the tween may advance beyond the time the pause\n\t * action was inserted at. For example:\n\t * \n\t * myTween.to({foo:0}, 1000).pause().to({foo:1}, 1000);\n\t * \n\t * At 60fps the tween will advance by ~16ms per tick, if the tween above was at 999ms prior to the current tick, it\n\t * will advance to 1015ms (15ms into the second \"step\") and then pause.\n\t * \n\t * @method pause\n\t * @param {Tween} [tween] The tween to pause. Defaults to this tween.\n\t * @return {Tween} This tween instance (for chaining calls)\n\t * @chainable\n\t */\n\tp.pause = function(tween) {\n\t\treturn this._addAction(tween||this, this._set, [{paused:true}]);\n\t};\n\n\t// tiny api (primarily for tool output):\n\tp.w = p.wait;\n\tp.t = p.to;\n\tp.c = p.call;\n\tp.s = p.set;\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t */\n\tp.toString = function() {\n\t\treturn \"[Tween]\";\n\t};\n\n\t/**\n\t * @method clone\n\t * @protected\n\t */\n\tp.clone = function() {\n\t\tthrow(\"Tween can not be cloned.\")\n\t};\n\n\n// private methods:\n\t/**\n\t * Adds a plugin to this tween.\n\t * @method _addPlugin\n\t * @param {Object} plugin\n\t * @protected\n\t */\n\tp._addPlugin = function(plugin) {\n\t\tvar ids = this._pluginIds || (this._pluginIds = {}), id = plugin.ID;\n\t\tif (!id || ids[id]) { return; } // already added\n\t\t\n\t\tids[id] = true;\n\t\tvar plugins = this._plugins || (this._plugins = []), priority = plugin.priority || 0;\n\t\tfor (var i=0,l=plugins.length; i<l; i++) {\n\t\t\tif (priority < plugins[i].priority) {\n\t\t\t\tplugins.splice(i,0,plugin);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tplugins.push(plugin);\n\t};\n\t\n\t// Docced in AbstractTween\n\tp._updatePosition = function(jump, end) {\n\t\tvar step = this._stepHead.next, t=this.position, d=this.duration;\n\t\tif (this.target && step) {\n\t\t\t// find our new step index:\n\t\t\tvar stepNext = step.next;\n\t\t\twhile (stepNext && stepNext.t <= t) { step = step.next; stepNext = step.next; }\n\t\t\tvar ratio = end ? d === 0 ? 1 : t/d : (t-step.t)/step.d; // TODO: revisit this.\n\t\t\tthis._updateTargetProps(step, ratio, end);\n\t\t}\n\t\tthis._stepPosition = step ? t-step.t : 0;\n\t};\n\t\n\t/**\n\t * @method _updateTargetProps\n\t * @param {Object} step\n\t * @param {Number} ratio\n\t * @param {Boolean} end Indicates to plugins that the full tween has ended.\n\t * @protected\n\t */\n\tp._updateTargetProps = function(step, ratio, end) {\n\t\tif (this.passive = !!step.passive) { return; } // don't update props.\n\t\t\n\t\tvar v, v0, v1, ease;\n\t\tvar p0 = step.prev.props;\n\t\tvar p1 = step.props;\n\t\tif (ease = step.ease) { ratio = ease(ratio,0,1,1); }\n\t\t\n\t\tvar plugins = this._plugins;\n\t\tproploop : for (var n in p0) {\n\t\t\tv0 = p0[n];\n\t\t\tv1 = p1[n];\n\t\t\t\n\t\t\t// values are different & it is numeric then interpolate:\n\t\t\tif (v0 !== v1 && (typeof(v0) === \"number\")) {\n\t\t\t\tv = v0+(v1-v0)*ratio;\n\t\t\t} else {\n\t\t\t\tv = ratio >= 1 ? v1 : v0;\n\t\t\t}\n\t\t\t\n\t\t\tif (plugins) {\n\t\t\t\tfor (var i=0,l=plugins.length;i<l;i++) {\n\t\t\t\t\tvar value = plugins[i].change(this, step, n, v, ratio, end);\n\t\t\t\t\tif (value === Tween.IGNORE) { continue proploop; }\n\t\t\t\t\tif (value !== undefined) { v = value; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.target[n] = v;\n\t\t}\n\n\t};\n\t\n\t/**\n\t * @method _runActionsRange\n\t * @param {Number} startPos\n\t * @param {Number} endPos\n\t * @param {Boolean} includeStart\n\t * @protected\n\t */\n\tp._runActionsRange = function(startPos, endPos, jump, includeStart) {\n\t\tvar rev = startPos > endPos;\n\t\tvar action = rev ? this._actionTail : this._actionHead;\n\t\tvar ePos = endPos, sPos = startPos;\n\t\tif (rev) { ePos=startPos; sPos=endPos; }\n\t\tvar t = this.position;\n\t\twhile (action) {\n\t\t\tvar pos = action.t;\n\t\t\tif (pos === endPos || (pos > sPos && pos < ePos) || (includeStart && pos === startPos)) {\n\t\t\t\taction.funct.apply(action.scope, action.params);\n\t\t\t\tif (t !== this.position) { return true; }\n\t\t\t}\n\t\t\taction = rev ? action.prev : action.next;\n\t\t}\n\t};\n\n\t/**\n\t * @method _appendProps\n\t * @param {Object} props\n\t * @protected\n\t */\n\tp._appendProps = function(props, step, stepPlugins) {\n\t\tvar initProps = this._stepHead.props, target = this.target, plugins = Tween._plugins;\n\t\tvar n, i, value, initValue, inject;\n\t\tvar oldStep = step.prev, oldProps = oldStep.props;\n\t\tvar stepProps = step.props || (step.props = this._cloneProps(oldProps));\n\t\tvar cleanProps = {}; // TODO: is there some way to avoid this additional object?\n\n\t\tfor (n in props) {\n\t\t\tif (!props.hasOwnProperty(n)) { continue; }\n\t\t\tcleanProps[n] = stepProps[n] = props[n];\n\n\t\t\tif (initProps[n] !== undefined) { continue; }\n\n\t\t\tinitValue = undefined; // accessing missing properties on DOMElements when using CSSPlugin is INSANELY expensive, so we let the plugin take a first swing at it.\n\t\t\tif (plugins) {\n\t\t\t\tfor (i = plugins.length-1; i >= 0; i--) {\n\t\t\t\t\tvalue = plugins[i].init(this, n, initValue);\n\t\t\t\t\tif (value !== undefined) { initValue = value; }\n\t\t\t\t\tif (initValue === Tween.IGNORE) {\n\t\t\t\t\t\tdelete(stepProps[n]);\n\t\t\t\t\t\tdelete(cleanProps[n]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (initValue !== Tween.IGNORE) {\n\t\t\t\tif (initValue === undefined) { initValue = target[n]; }\n\t\t\t\toldProps[n] = (initValue === undefined) ? null : initValue;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (n in cleanProps) {\n\t\t\tvalue = props[n];\n\n\t\t\t// propagate old value to previous steps:\n\t\t\tvar o, prev=oldStep;\n\t\t\twhile ((o = prev) && (prev = o.prev)) {\n\t\t\t\tif (prev.props === o.props) { continue; } // wait step\n\t\t\t\tif (prev.props[n] !== undefined) { break; } // already has a value, we're done.\n\t\t\t\tprev.props[n] = oldProps[n];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (stepPlugins !== false && (plugins = this._plugins)) {\n\t\t\tfor (i = plugins.length-1; i >= 0; i--) {\n\t\t\t\tplugins[i].step(this, step, cleanProps);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (inject = this._injected) {\n\t\t\tthis._injected = null;\n\t\t\tthis._appendProps(inject, step, false);\n\t\t}\n\t};\n\t\n\t/**\n\t * Used by plugins to inject properties onto the current step. Called from within `Plugin.step` calls.\n\t * For example, a plugin dealing with color, could read a hex color, and inject red, green, and blue props into the tween.\n\t * See the SamplePlugin for more info.\n\t * @method _injectProp\n\t * @param {String} name\n\t * @param {Object} value\n\t * @protected\n\t */\n\tp._injectProp = function(name, value) {\n\t\tvar o = this._injected || (this._injected = {});\n\t\to[name] = value;\n\t};\n\n\t/**\n\t * @method _addStep\n\t * @param {Number} duration\n\t * @param {Object} props\n\t * @param {Function} ease\n\t * @param {Boolean} passive\n\t * @protected\n\t */\n\tp._addStep = function(duration, props, ease, passive) {\n\t\tvar step = new TweenStep(this._stepTail, this.duration, duration, props, ease, passive||false);\n\t\tthis.duration += duration;\n\t\treturn this._stepTail = (this._stepTail.next = step);\n\t};\n\n\t/**\n\t * @method _addAction\n\t * @param {Object} scope\n\t * @param {Function} funct\n\t * @param {Array} params\n\t * @protected\n\t */\n\tp._addAction = function(scope, funct, params) {\n\t\tvar action = new TweenAction(this._actionTail, this.duration, scope, funct, params);\n\t\tif (this._actionTail) { this._actionTail.next = action; }\n\t\telse { this._actionHead = action; }\n\t\tthis._actionTail = action;\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method _set\n\t * @param {Object} props\n\t * @protected\n\t */\n\tp._set = function(props) {\n\t\tfor (var n in props) {\n\t\t\tthis[n] = props[n];\n\t\t}\n\t};\n\n\t/**\n\t * @method _cloneProps\n\t * @param {Object} props\n\t * @protected\n\t */\n\tp._cloneProps = function(props) {\n\t\tvar o = {};\n\t\tfor (var n in props) { o[n] = props[n]; }\n\t\treturn o;\n\t};\n\n\tcreatejs.Tween = createjs.promote(Tween, \"AbstractTween\");\n\t\n\tfunction TweenStep(prev, t, d, props, ease, passive) {\n\t\tthis.next = null;\n\t\tthis.prev = prev;\n\t\tthis.t = t;\n\t\tthis.d = d;\n\t\tthis.props = props;\n\t\tthis.ease = ease;\n\t\tthis.passive = passive;\n\t\tthis.index = prev ? prev.index+1 : 0;\n\t};\n\t\n\tfunction TweenAction(prev, t, scope, funct, params) {\n\t\tthis.next = null;\n\t\tthis.prev = prev;\n\t\tthis.t = t;\n\t\tthis.d = 0;\n\t\tthis.scope = scope;\n\t\tthis.funct = funct;\n\t\tthis.params = params;\n\t};\n}());\n\n//##############################################################################\n// Timeline.js\n//##############################################################################\n\nwindow.createjs = window.createjs||{};\n\n\n(function() {\n\t\"use strict\";\n\t\n\n// constructor\t\n\t/**\n\t * The Timeline class synchronizes multiple tweens and allows them to be controlled as a group. Please note that if a\n\t * timeline is looping, the tweens on it may appear to loop even if the \"loop\" property of the tween is false.\n\t * \n\t * NOTE: Timeline currently also accepts a param list in the form: `tweens, labels, props`. This is for backwards\n\t * compatibility only and will be removed in the future. Include tweens and labels as properties on the props object.\n\t * @class Timeline\n\t * @param {Object} [props] The configuration properties to apply to this instance (ex. `{loop:-1, paused:true}`).\n\t * Supported props are listed below. These props are set on the corresponding instance properties except where\n\t * specified.<UL>\n\t *    <LI> `useTicks`</LI>\n\t *    <LI> `ignoreGlobalPause`</LI>\n\t *    <LI> `loop`</LI>\n\t *    <LI> `reversed`</LI>\n\t *    <LI> `bounce`</LI>\n\t *    <LI> `timeScale`</LI>\n\t *    <LI> `paused`</LI>\n\t *    <LI> `position`: indicates the initial position for this tween.</LI>\n\t *    <LI> `onChange`: adds the specified function as a listener to the `change` event</LI>\n\t *    <LI> `onComplete`: adds the specified function as a listener to the `complete` event</LI>\n\t * </UL>\n\t * @extends AbstractTween\n\t * @constructor\n\t **/\n\tfunction Timeline(props) {\n\t\tvar tweens, labels;\n\t\t// handle old params (tweens, labels, props):\n\t\t// TODO: deprecated.\n\t\tif (props instanceof Array || (props == null && arguments.length > 1)) {\n\t\t\ttweens = props;\n\t\t\tlabels = arguments[1];\n\t\t\tprops = arguments[2];\n\t\t} else if (props) {\n\t\t\ttweens = props.tweens;\n\t\t\tlabels = props.labels;\n\t\t}\n\t\t\n\t\tthis.AbstractTween_constructor(props);\n\n\t// private properties:\n\t\t/**\n\t\t * The array of tweens in the timeline. It is *strongly* recommended that you use\n\t\t * {{#crossLink \"Tween/addTween\"}}{{/crossLink}} and {{#crossLink \"Tween/removeTween\"}}{{/crossLink}},\n\t\t * rather than accessing this directly, but it is included for advanced uses.\n\t\t * @property tweens\n\t\t * @type Array\n\t\t **/\n\t\tthis.tweens = [];\n\t\t\n\t\tif (tweens) { this.addTween.apply(this, tweens); }\n\t\tthis.setLabels(labels);\n\t\t\n\t\tthis._init(props);\n\t};\n\t\n\tvar p = createjs.extend(Timeline, createjs.AbstractTween);\n\n\t\n// events:\n\t// docced in AbstractTween.\n\n\n// public methods:\n\t/**\n\t * Adds one or more tweens (or timelines) to this timeline. The tweens will be paused (to remove them from the\n\t * normal ticking system) and managed by this timeline. Adding a tween to multiple timelines will result in\n\t * unexpected behaviour.\n\t * @method addTween\n\t * @param {Tween} ...tween The tween(s) to add. Accepts multiple arguments.\n\t * @return {Tween} The first tween that was passed in.\n\t **/\n\tp.addTween = function(tween) {\n\t\tif (tween._parent) { tween._parent.removeTween(tween); }\n\t\t\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tfor (var i=0; i<l; i++) { this.addTween(arguments[i]); }\n\t\t\treturn arguments[l-1];\n\t\t} else if (l === 0) { return null; }\n\t\t\n\t\tthis.tweens.push(tween);\n\t\ttween._parent = this;\n\t\ttween.paused = true;\n\t\tvar d = tween.duration;\n\t\tif (tween.loop > 0) { d *= tween.loop+1; }\n\t\tif (d > this.duration) { this.duration = d; }\n\t\t\n\t\tif (this.rawPosition >= 0) { tween.setPosition(this.rawPosition); }\n\t\treturn tween;\n\t};\n\n\t/**\n\t * Removes one or more tweens from this timeline.\n\t * @method removeTween\n\t * @param {Tween} ...tween The tween(s) to remove. Accepts multiple arguments.\n\t * @return Boolean Returns `true` if all of the tweens were successfully removed.\n\t **/\n\tp.removeTween = function(tween) {\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tvar good = true;\n\t\t\tfor (var i=0; i<l; i++) { good = good && this.removeTween(arguments[i]); }\n\t\t\treturn good;\n\t\t} else if (l === 0) { return true; }\n\n\t\tvar tweens = this.tweens;\n\t\tvar i = tweens.length;\n\t\twhile (i--) {\n\t\t\tif (tweens[i] === tween) {\n\t\t\t\ttweens.splice(i, 1);\n\t\t\t\ttween._parent = null;\n\t\t\t\tif (tween.duration >= this.duration) { this.updateDuration(); }\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Recalculates the duration of the timeline. The duration is automatically updated when tweens are added or removed,\n\t * but this method is useful if you modify a tween after it was added to the timeline.\n\t * @method updateDuration\n\t **/\n\tp.updateDuration = function() {\n\t\tthis.duration = 0;\n\t\tfor (var i=0,l=this.tweens.length; i<l; i++) {\n\t\t\tvar tween = this.tweens[i];\n\t\t\tvar d = tween.duration;\n\t\t\tif (tween.loop > 0) { d *= tween.loop+1; }\n\t\t\tif (d > this.duration) { this.duration = d; }\n\t\t}\n\t};\n\n\t/**\n\t* Returns a string representation of this object.\n\t* @method toString\n\t* @return {String} a string representation of the instance.\n\t**/\n\tp.toString = function() {\n\t\treturn \"[Timeline]\";\n\t};\n\n\t/**\n\t * @method clone\n\t * @protected\n\t **/\n\tp.clone = function() {\n\t\tthrow(\"Timeline can not be cloned.\")\n\t};\n\n// private methods:\n\t\n\t// Docced in AbstractTween\n\tp._updatePosition = function(jump, end) {\n\t\tvar t = this.position;\n\t\tfor (var i=0, l=this.tweens.length; i<l; i++) {\n\t\t\tthis.tweens[i].setPosition(t, true, jump); // actions will run after all the tweens update.\n\t\t}\n\t};\n\t\n\t// Docced in AbstractTween\n\tp._runActionsRange = function(startPos, endPos, jump, includeStart) {\n\t\t//console.log(\"\trange\", startPos, endPos, jump, includeStart);\n\t\tvar t = this.position;\n\t\tfor (var i=0, l=this.tweens.length; i<l; i++) {\n\t\t\tthis.tweens[i]._runActions(startPos, endPos, jump, includeStart);\n\t\t\tif (t !== this.position) { return true; } // an action changed this timeline's position.\n\t\t}\n\t};\n\n\n\tcreatejs.Timeline = createjs.promote(Timeline, \"AbstractTween\");\n\n}());\n\n//##############################################################################\n// Ease.js\n//##############################################################################\n\nwindow.createjs = window.createjs||{};\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * The Ease class provides a collection of easing functions for use with TweenJS. It does not use the standard 4 param\n\t * easing signature. Instead it uses a single param which indicates the current linear ratio (0 to 1) of the tween.\n\t *\n\t * Most methods on Ease can be passed directly as easing functions:\n\t *\n\t *      Tween.get(target).to({x:100}, 500, Ease.linear);\n\t *\n\t * However, methods beginning with \"get\" will return an easing function based on parameter values:\n\t *\n\t *      Tween.get(target).to({y:200}, 500, Ease.getPowIn(2.2));\n\t *\n\t * Please see the <a href=\"http://www.createjs.com/Demos/TweenJS/Tween_SparkTable\">spark table demo</a> for an\n\t * overview of the different ease types on <a href=\"http://tweenjs.com\">TweenJS.com</a>.\n\t *\n\t * <em>Equations derived from work by Robert Penner.</em>\n\t * @class Ease\n\t * @static\n\t **/\n\tfunction Ease() {\n\t\tthrow \"Ease cannot be instantiated.\";\n\t}\n\n\n// static methods and properties\n\t/**\n\t * @method linear\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.linear = function(t) { return t; };\n\n\t/**\n\t * Identical to linear.\n\t * @method none\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.none = Ease.linear;\n\n\t/**\n\t * Mimics the simple -100 to 100 easing in Adobe Flash/Animate.\n\t * @method get\n\t * @param {Number} amount A value from -1 (ease in) to 1 (ease out) indicating the strength and direction of the ease.\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.get = function(amount) {\n\t\tif (amount < -1) { amount = -1; }\n\t\telse if (amount > 1) { amount = 1; }\n\t\treturn function(t) {\n\t\t\tif (amount==0) { return t; }\n\t\t\tif (amount<0) { return t*(t*-amount+1+amount); }\n\t\t\treturn t*((2-t)*amount+(1-amount));\n\t\t};\n\t};\n\n\t/**\n\t * Configurable exponential ease.\n\t * @method getPowIn\n\t * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getPowIn = function(pow) {\n\t\treturn function(t) {\n\t\t\treturn Math.pow(t,pow);\n\t\t};\n\t};\n\n\t/**\n\t * Configurable exponential ease.\n\t * @method getPowOut\n\t * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getPowOut = function(pow) {\n\t\treturn function(t) {\n\t\t\treturn 1-Math.pow(1-t,pow);\n\t\t};\n\t};\n\n\t/**\n\t * Configurable exponential ease.\n\t * @method getPowInOut\n\t * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getPowInOut = function(pow) {\n\t\treturn function(t) {\n\t\t\tif ((t*=2)<1) return 0.5*Math.pow(t,pow);\n\t\t\treturn 1-0.5*Math.abs(Math.pow(2-t,pow));\n\t\t};\n\t};\n\n\t/**\n\t * @method quadIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quadIn = Ease.getPowIn(2);\n\t/**\n\t * @method quadOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quadOut = Ease.getPowOut(2);\n\t/**\n\t * @method quadInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quadInOut = Ease.getPowInOut(2);\n\n\t/**\n\t * @method cubicIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.cubicIn = Ease.getPowIn(3);\n\t/**\n\t * @method cubicOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.cubicOut = Ease.getPowOut(3);\n\t/**\n\t * @method cubicInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.cubicInOut = Ease.getPowInOut(3);\n\n\t/**\n\t * @method quartIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quartIn = Ease.getPowIn(4);\n\t/**\n\t * @method quartOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quartOut = Ease.getPowOut(4);\n\t/**\n\t * @method quartInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quartInOut = Ease.getPowInOut(4);\n\n\t/**\n\t * @method quintIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quintIn = Ease.getPowIn(5);\n\t/**\n\t * @method quintOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quintOut = Ease.getPowOut(5);\n\t/**\n\t * @method quintInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quintInOut = Ease.getPowInOut(5);\n\n\t/**\n\t * @method sineIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.sineIn = function(t) {\n\t\treturn 1-Math.cos(t*Math.PI/2);\n\t};\n\n\t/**\n\t * @method sineOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.sineOut = function(t) {\n\t\treturn Math.sin(t*Math.PI/2);\n\t};\n\n\t/**\n\t * @method sineInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.sineInOut = function(t) {\n\t\treturn -0.5*(Math.cos(Math.PI*t) - 1);\n\t};\n\n\t/**\n\t * Configurable \"back in\" ease.\n\t * @method getBackIn\n\t * @param {Number} amount The strength of the ease.\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getBackIn = function(amount) {\n\t\treturn function(t) {\n\t\t\treturn t*t*((amount+1)*t-amount);\n\t\t};\n\t};\n\t/**\n\t * @method backIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.backIn = Ease.getBackIn(1.7);\n\n\t/**\n\t * Configurable \"back out\" ease.\n\t * @method getBackOut\n\t * @param {Number} amount The strength of the ease.\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getBackOut = function(amount) {\n\t\treturn function(t) {\n\t\t\treturn (--t*t*((amount+1)*t + amount) + 1);\n\t\t};\n\t};\n\t/**\n\t * @method backOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.backOut = Ease.getBackOut(1.7);\n\n\t/**\n\t * Configurable \"back in out\" ease.\n\t * @method getBackInOut\n\t * @param {Number} amount The strength of the ease.\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getBackInOut = function(amount) {\n\t\tamount*=1.525;\n\t\treturn function(t) {\n\t\t\tif ((t*=2)<1) return 0.5*(t*t*((amount+1)*t-amount));\n\t\t\treturn 0.5*((t-=2)*t*((amount+1)*t+amount)+2);\n\t\t};\n\t};\n\t/**\n\t * @method backInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.backInOut = Ease.getBackInOut(1.7);\n\n\t/**\n\t * @method circIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.circIn = function(t) {\n\t\treturn -(Math.sqrt(1-t*t)- 1);\n\t};\n\n\t/**\n\t * @method circOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.circOut = function(t) {\n\t\treturn Math.sqrt(1-(--t)*t);\n\t};\n\n\t/**\n\t * @method circInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.circInOut = function(t) {\n\t\tif ((t*=2) < 1) return -0.5*(Math.sqrt(1-t*t)-1);\n\t\treturn 0.5*(Math.sqrt(1-(t-=2)*t)+1);\n\t};\n\n\t/**\n\t * @method bounceIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.bounceIn = function(t) {\n\t\treturn 1-Ease.bounceOut(1-t);\n\t};\n\n\t/**\n\t * @method bounceOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.bounceOut = function(t) {\n\t\tif (t < 1/2.75) {\n\t\t\treturn (7.5625*t*t);\n\t\t} else if (t < 2/2.75) {\n\t\t\treturn (7.5625*(t-=1.5/2.75)*t+0.75);\n\t\t} else if (t < 2.5/2.75) {\n\t\t\treturn (7.5625*(t-=2.25/2.75)*t+0.9375);\n\t\t} else {\n\t\t\treturn (7.5625*(t-=2.625/2.75)*t +0.984375);\n\t\t}\n\t};\n\n\t/**\n\t * @method bounceInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.bounceInOut = function(t) {\n\t\tif (t<0.5) return Ease.bounceIn (t*2) * .5;\n\t\treturn Ease.bounceOut(t*2-1)*0.5+0.5;\n\t};\n\n\t/**\n\t * Configurable elastic ease.\n\t * @method getElasticIn\n\t * @param {Number} amplitude\n\t * @param {Number} period\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getElasticIn = function(amplitude,period) {\n\t\tvar pi2 = Math.PI*2;\n\t\treturn function(t) {\n\t\t\tif (t==0 || t==1) return t;\n\t\t\tvar s = period/pi2*Math.asin(1/amplitude);\n\t\t\treturn -(amplitude*Math.pow(2,10*(t-=1))*Math.sin((t-s)*pi2/period));\n\t\t};\n\t};\n\t/**\n\t * @method elasticIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.elasticIn = Ease.getElasticIn(1,0.3);\n\n\t/**\n\t * Configurable elastic ease.\n\t * @method getElasticOut\n\t * @param {Number} amplitude\n\t * @param {Number} period\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getElasticOut = function(amplitude,period) {\n\t\tvar pi2 = Math.PI*2;\n\t\treturn function(t) {\n\t\t\tif (t==0 || t==1) return t;\n\t\t\tvar s = period/pi2 * Math.asin(1/amplitude);\n\t\t\treturn (amplitude*Math.pow(2,-10*t)*Math.sin((t-s)*pi2/period )+1);\n\t\t};\n\t};\n\t/**\n\t * @method elasticOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.elasticOut = Ease.getElasticOut(1,0.3);\n\n\t/**\n\t * Configurable elastic ease.\n\t * @method getElasticInOut\n\t * @param {Number} amplitude\n\t * @param {Number} period\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getElasticInOut = function(amplitude,period) {\n\t\tvar pi2 = Math.PI*2;\n\t\treturn function(t) {\n\t\t\tvar s = period/pi2 * Math.asin(1/amplitude);\n\t\t\tif ((t*=2)<1) return -0.5*(amplitude*Math.pow(2,10*(t-=1))*Math.sin( (t-s)*pi2/period ));\n\t\t\treturn amplitude*Math.pow(2,-10*(t-=1))*Math.sin((t-s)*pi2/period)*0.5+1;\n\t\t};\n\t};\n\t/**\n\t * @method elasticInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.elasticInOut = Ease.getElasticInOut(1,0.3*1.5);\n\n\tcreatejs.Ease = Ease;\n\n}());\n\n//##############################################################################\n// MotionGuidePlugin.js\n//##############################################################################\n\nwindow.createjs = window.createjs||{};\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * A TweenJS plugin for working with motion guides. Defined paths which objects can follow or orient along.\n\t *\n\t * To use the plugin, install the plugin after TweenJS has loaded. To define a path, add\n\t *\n\t * \t\tcreatejs.MotionGuidePlugin.install();\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \t\t// Using a Motion Guide\n\t * \t\tcreatejs.Tween.get(target).to({guide:{ path:[0,0, 0,200,200,200, 200,0,0,0] }},7000);\n\t * \t\t// Visualizing the line\n\t * \t\tgraphics.moveTo(0,0).curveTo(0,200,200,200).curveTo(200,0,0,0);\n\t *\n\t * Each path needs pre-computation to ensure there's fast performance. Because of the pre-computation there's no\n\t * built in support for path changes mid tween. These are the Guide Object's properties:<UL>\n\t * \t\t<LI> path: Required, Array : The x/y points used to draw the path with a moveTo and 1 to n curveTo calls.</LI>\n\t * \t\t<LI> start: Optional, 0-1 : Initial position, default 0 except for when continuing along the same path.</LI>\n\t * \t\t<LI> end: Optional, 0-1 : Final position, default 1 if not specified.</LI>\n\t * \t\t<LI> orient: Optional, string : \"fixed\"/\"auto\"/\"cw\"/\"ccw\"<UL>\n\t *\t\t\t\t<LI>\"fixed\" forces the object to face down the path all movement (relative to start rotation),</LI>\n\t * \t\t\t\t<LI>\"auto\" rotates the object along the path relative to the line.</LI>\n\t * \t\t\t\t<LI>\"cw\"/\"ccw\" force clockwise or counter clockwise rotations including Adobe Flash/Animate-like\n\t * \t\t\t\tbehaviour. This may override your end rotation value.</LI>\n\t * \t\t</UL></LI>\n\t * </UL>\n\t * Guide objects should not be shared between tweens even if all properties are identical, the library stores\n\t * information on these objects in the background and sharing them can cause unexpected behaviour. Values\n\t * outside 0-1 range of tweens will be a \"best guess\" from the appropriate part of the defined curve.\n\t *\n\t * @class MotionGuidePlugin\n\t * @constructor\n\t */\n\tfunction MotionGuidePlugin() {\n\t\tthrow(\"MotionGuidePlugin cannot be instantiated.\")\n\t}\n\tvar s = MotionGuidePlugin;\n\n\n// static properties:\n\t/**\n\t * @property priority\n\t * @protected\n\t * @static\n\t */\n\ts.priority = 0; // high priority, should run sooner\n\n\t/**\n\t * READ-ONLY. A unique identifying string for this plugin. Used by TweenJS to ensure duplicate plugins are not installed on a tween.\n\t * @property ID\n\t * @type {String}\n\t * @static\n\t * @readonly\n\t */\n\ts.ID = \"MotionGuide\";\n\n// static methods\n\t/**\n\t * Installs this plugin for use with TweenJS. Call this once after TweenJS is loaded to enable this plugin.\n\t * @method install\n\t * @static\n\t */\n\ts.install = function() {\n\t\tcreatejs.Tween._installPlugin(MotionGuidePlugin);\n\t\treturn createjs.Tween.IGNORE;\n\t};\n\n\t/**\n\t * Called by TweenJS when a new property initializes on a tween.\n\t * See {{#crossLink \"SamplePlugin/init\"}}{{/crossLink}} for more info.\n\t * @method init\n\t * @param {Tween} tween\n\t * @param {String} prop\n\t * @param {any} value\n\t * @return {any}\n\t * @static\n\t */\n\ts.init = function(tween, prop, value) {\n\t\tif(prop == \"guide\") {\n\t\t\ttween._addPlugin(s);\n\t\t}\n\t};\n\n\t/**\n\t * Called when a new step is added to a tween (ie. a new \"to\" action is added to a tween).\n\t * See {{#crossLink \"SamplePlugin/step\"}}{{/crossLink}} for more info.\n\t * @method step\n\t * @param {Tween} tween\n\t * @param {TweenStep} step\n\t * @param {Object} props\n\t * @static\n\t */\n\ts.step = function(tween, step, props) {\n\t\tfor (var n in props) {\n\t\t\tif(n !== \"guide\") { continue; }\n\n\t\t\tvar guideData = step.props.guide;\n\t\t\tvar error = s._solveGuideData(props.guide, guideData);\n\t\t\tguideData.valid = !error;\n\n\t\t\tvar end = guideData.endData;\n\t\t\ttween._injectProp(\"x\", end.x);\n\t\t\ttween._injectProp(\"y\", end.y);\n\n\t\t\tif(error || !guideData.orient) { break; }\n\n\t\t\tvar initRot = step.prev.props.rotation === undefined ? (tween.target.rotation || 0) : step.prev.props.rotation;\n\n\t\t\tguideData.startOffsetRot = initRot - guideData.startData.rotation;\n\n\t\t\tif(guideData.orient == \"fixed\") {\n\t\t\t\t// controlled rotation\n\t\t\t\tguideData.endAbsRot = end.rotation + guideData.startOffsetRot;\n\t\t\t\tguideData.deltaRotation = 0;\n\t\t\t} else {\n\t\t\t\t// interpreted rotation\n\n\t\t\t\tvar finalRot = props.rotation === undefined ? (tween.target.rotation || 0) : props.rotation;\n\t\t\t\tvar deltaRot = (finalRot - guideData.endData.rotation) - guideData.startOffsetRot;\n\t\t\t\tvar modRot = deltaRot % 360;\n\n\t\t\t\tguideData.endAbsRot = finalRot;\n\n\t\t\t\tswitch(guideData.orient) {\n\t\t\t\t\tcase \"auto\":\n\t\t\t\t\t\tguideData.deltaRotation = deltaRot;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"cw\":\n\t\t\t\t\t\tguideData.deltaRotation = ((modRot + 360) % 360) + (360 * Math.abs((deltaRot/360) |0));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"ccw\":\n\t\t\t\t\t\tguideData.deltaRotation = ((modRot - 360) % 360) + (-360 * Math.abs((deltaRot/360) |0));\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttween._injectProp(\"rotation\", guideData.endAbsRot);\n\t\t}\n\t};\n\n\t/**\n\t * Called before a property is updated by the tween.\n\t * See {{#crossLink \"SamplePlugin/change\"}}{{/crossLink}} for more info.\n\t * @method change\n\t * @param {Tween} tween\n\t * @param {TweenStep} step\n\t * @param {String} prop\n\t * @param {any} value\n\t * @param {Number} ratio\n\t * @param {Boolean} end\n\t * @return {any}\n\t * @static\n\t */\n\ts.change = function(tween, step, prop, value, ratio, end) {\n\t\tvar guideData = step.props.guide;\n\n\t\tif(\n\t\t\t\t!guideData ||\t\t\t\t\t\t\t// Missing data\n\t\t\t\t(step.props === step.prev.props) || \t// In a wait()\n\t\t\t\t(guideData === step.prev.props.guide) \t// Guide hasn't changed\n\t\t) {\n\t\t\treturn; // have no business making decisions\n\t\t}\n\t\tif(\n\t\t\t\t(prop === \"guide\" && !guideData.valid) ||\t\t// this data is broken\n\t\t\t\t(prop == \"x\" || prop == \"y\") ||\t\t\t\t\t// these always get over-written\n\t\t\t\t(prop === \"rotation\" && guideData.orient)\t\t// currently over-written\n\t\t){\n\t\t\treturn createjs.Tween.IGNORE;\n\t\t}\n\n\t\ts._ratioToPositionData(ratio, guideData, tween.target);\n\t};\n\n// public methods\n\t/**\n\t * Provide potentially useful debugging information, like running the error detection system, and rendering the path\n\t * defined in the guide data.\n\t *\n\t * NOTE: you will need to transform your context 2D to the local space of the guide if you wish to line it up.\n\t * @param {Object} guideData All the information describing the guide to be followed.\n\t * @param {DrawingContext2D} [ctx=undefined] The context to draw the object into.\n\t * @param {Array} [higlight=undefined] Array of ratio positions to highlight\n\t * @returns {undefined|String}\n\t */\n\ts.debug = function(guideData, ctx, higlight) {\n\t\tguideData = guideData.guide || guideData;\n\n\t\t// errors\n\t\tvar err = s._findPathProblems(guideData);\n\t\tif(err) {\n\t\t\tconsole.error(\"MotionGuidePlugin Error found: \\n\" + err);\n\t\t}\n\n\t\t// drawing\n\t\tif(!ctx){ return err; }\n\n\t\tvar i;\n\t\tvar path = guideData.path;\n\t\tvar pathLength = path.length;\n\t\tvar width = 3;\n\t\tvar length = 9;\n\n\t\tctx.save();\n\t\t//ctx.resetTransform();\n\n\t\tctx.lineCap = \"round\";\n\t\tctx.lineJoin = \"miter\";\n\t\tctx.beginPath();\n\n\t\t// curve\n\t\tctx.moveTo(path[0], path[1]);\n\t\tfor(i=2; i < pathLength; i+=4) {\n\t\t\tctx.quadraticCurveTo(\n\t\t\t\tpath[i], path[i+1],\n\t\t\t\tpath[i+2], path[i+3]\n\t\t\t);\n\t\t}\n\n\t\tctx.strokeStyle = \"black\";\n\t\tctx.lineWidth = width*1.5;\n\t\tctx.stroke();\n\t\tctx.strokeStyle = \"white\";\n\t\tctx.lineWidth = width;\n\t\tctx.stroke();\n\t\tctx.closePath();\n\n\t\t// highlights\n\t\tvar hiCount = higlight.length;\n\t\tif(higlight && hiCount) {\n\t\t\tvar tempStore = {};\n\t\t\tvar tempLook = {};\n\t\t\ts._solveGuideData(guideData, tempStore);\n\n\t\t\tfor(var i=0; i<hiCount; i++){\n\t\t\t\ttempStore.orient = \"fixed\";\n\t\t\t\ts._ratioToPositionData(higlight[i], tempStore, tempLook);\n\n\t\t\t\tctx.beginPath();\n\n\t\t\t\tctx.moveTo(tempLook.x, tempLook.y);\n\t\t\t\tctx.lineTo(\n\t\t\t\t\ttempLook.x + Math.cos(tempLook.rotation * 0.0174533) * length,\n\t\t\t\t\ttempLook.y + Math.sin(tempLook.rotation * 0.0174533) * length\n\t\t\t\t);\n\n\t\t\t\tctx.strokeStyle = \"black\";\n\t\t\t\tctx.lineWidth = width*1.5;\n\t\t\t\tctx.stroke();\n\t\t\t\tctx.strokeStyle = \"red\";\n\t\t\t\tctx.lineWidth = width;\n\t\t\t\tctx.stroke();\n\t\t\t\tctx.closePath();\n\t\t\t}\n\t\t}\n\n\t\t// end draw\n\t\tctx.restore();\n\n\t\treturn err;\n\t};\n\n// private methods\n\t/**\n\t * Calculate and store optimization data about the desired path to improve performance and accuracy of positions.\n\t * @param {Object} source The guide data provided to the tween call\n\t * @param {Object} storage the guide data used by the step calls and plugin to do the job, will be overwritten\n\t * @returns {undefined|String} Can return an error if unable to generate the data.\n\t * @private\n\t */\n\ts._solveGuideData = function(source, storage) {\n\t\tvar err = undefined;\n\t\tif(err = s.debug(source)) { return err; }\n\n\t\tvar path = storage.path = source.path;\n\t\tvar orient = storage.orient = source.orient;\n\t\tstorage.subLines = [];\n\t\tstorage.totalLength = 0;\n\t\tstorage.startOffsetRot = 0;\n\t\tstorage.deltaRotation = 0;\n\t\tstorage.startData = {ratio: 0};\n\t\tstorage.endData = {ratio: 1};\n\t\tstorage.animSpan = 1;\n\n\t\tvar pathLength = path.length;\n\n\t\tvar precision = 10;\n\t\tvar sx,sy, cx,cy, ex,ey, i,j, len, temp = {};\n\n\t\tsx = path[0];\t\tsy = path[1];\n\n\t\t// get the data for each curve\n\t\tfor(i=2; i < pathLength; i+=4) {\n\t\t\tcx = path[i];\t\t\tcy = path[i+1];\n\t\t\tex = path[i+2];\t\t\tey = path[i+3];\n\n\t\t\tvar subLine = {\n\t\t\t\tweightings: [],\n\t\t\t\testLength: 0,\n\t\t\t\tportion: 0\n\t\t\t};\n\n\t\t\tvar subX = sx, subY = sy;\n\t\t\t// get the distance data for each point\n\t\t\tfor(j=1; j <= precision;j++) {\t// we need to evaluate t = 1 not t = 0\n\t\t\t\ts._getParamsForCurve(sx,sy, cx,cy, ex,ey, j/precision, false, temp);\n\n\t\t\t\tvar dx = temp.x - subX, dy = temp.y - subY;\n\t\t\t\tlen = Math.sqrt(dx*dx + dy*dy);\n\t\t\t\tsubLine.weightings.push(len);\n\t\t\t\tsubLine.estLength += len;\n\n\t\t\t\tsubX = temp.x;\n\t\t\t\tsubY = temp.y;\n\t\t\t}\n\n\t\t\t// figure out full lengths\n\t\t\tstorage.totalLength += subLine.estLength;\n\n\t\t\t// use length to figure out proportional weightings\n\t\t\tfor(j=0; j < precision; j++) {\n\t\t\t\tlen = subLine.estLength;\n\t\t\t\tsubLine.weightings[j] = subLine.weightings[j] / len;\n\t\t\t}\n\n\t\t\tstorage.subLines.push(subLine);\n\t\t\tsx = ex;\n\t\t\tsy = ey;\n\t\t}\n\n\t\t// use length to figure out proportional weightings\n\t\tlen = storage.totalLength;\n\t\tvar l = storage.subLines.length;\n\t\tfor(i=0; i<l; i++) {\n\t\t\tstorage.subLines[i].portion = storage.subLines[i].estLength / len;\n\t\t}\n\n\t\t// determine start and end data\n\t\tvar startRatio = isNaN(source.start) ? 0 : source.start;\n\t\tvar endRatio = isNaN(source.end) ? 1 : source.end;\n\t\ts._ratioToPositionData(startRatio, storage, storage.startData);\n\t\ts._ratioToPositionData(endRatio, storage, storage.endData);\n\n\t\t// this has to be done last else the prev ratios will be out of place\n\t\tstorage.startData.ratio = startRatio;\n\t\tstorage.endData.ratio = endRatio;\n\t\tstorage.animSpan = storage.endData.ratio - storage.startData.ratio;\n\t};\n\n\t/**\n\t * Convert a percentage along the line into, a local line (start, control, end) t-value for calculation.\n\t * @param {Number} ratio The (euclidean distance) percentage into the whole curve.\n\t * @param {Object} guideData All the information describing the guide to be followed.\n\t * @param {Object} output Object to save output properties of x,y, and rotation onto.\n\t * @returns {Object} The output object, useful for isolated calls.\n\t * @private\n\t */\n\ts._ratioToPositionData = function(ratio, guideData, output) {\n\t\tvar lineSegments = guideData.subLines;\n\n\t\tvar i,l, t, test, target;\n\n\t\tvar look = 0;\n\t\tvar precision = 10;\n\t\tvar effRatio = (ratio * guideData.animSpan) + guideData.startData.ratio;\n\n\t\t// find subline\n\t\tl = lineSegments.length;\n\t\tfor(i=0; i<l; i++) {\n\t\t\ttest = lineSegments[i].portion;\n\t\t\tif(look + test >= effRatio){ target = i; break; }\n\t\t\tlook += test;\n\t\t}\n\t\tif(target === undefined) { target = l-1;  look -= test; }\n\n\t\t// find midline weighting\n\t\tvar subLines = lineSegments[target].weightings;\n\t\tvar portion = test;\n\t\tl = subLines.length;\n\t\tfor(i=0; i<l; i++) {\n\t\t\ttest = subLines[i] * portion;\n\t\t\tif(look + test >= effRatio){ break; }\n\t\t\tlook += test;\n\t\t}\n\n\t\t// translate the subline index into a position in the path data\n\t\ttarget = (target*4) + 2;\n\t\t// take the distance we've covered in our ratio, and scale it to distance into the weightings\n\t\tt = (i/precision) + (((effRatio-look) / test) * (1/precision));\n\n\t\t// position\n\t\tvar pathData = guideData.path;\n\t\ts._getParamsForCurve(\n\t\t\tpathData[target-2],\t\t\tpathData[target-1],\n\t\t\tpathData[target],\t\t\tpathData[target+1],\n\t\t\tpathData[target+2],\t\t\tpathData[target+3],\n\t\t\tt,\n\t\t\tguideData.orient,\n\t\t\toutput\n\t\t);\n\n\t\tif(guideData.orient) {\n\t\t\tif(ratio >= 0.99999 && ratio <= 1.00001 && guideData.endAbsRot !== undefined) {\n\t\t\t\toutput.rotation = guideData.endAbsRot;\n\t\t\t} else {\n\t\t\t\toutput.rotation += guideData.startOffsetRot + (ratio * guideData.deltaRotation);\n\t\t\t}\n\t\t}\n\n\t\treturn output;\n\t};\n\n\t/**\n\t * For a given quadratic bezier t-value, what is the position and rotation. Save it onto the output object.\n\t * @param {Number} sx Start x.\n\t * @param {Number} sy Start y.\n\t * @param {Number} cx Control x.\n\t * @param {Number} cy Control y.\n\t * @param {Number} ex End x.\n\t * @param {Number} ey End y.\n\t * @param {Number} t T value (parametric distance into curve).\n\t * @param {Boolean} orient Save rotation data.\n\t * @param {Object} output Object to save output properties of x,y, and rotation onto.\n\t * @private\n\t */\n\ts._getParamsForCurve = function(sx,sy, cx,cy, ex,ey, t, orient, output) {\n\t\tvar inv = 1 - t;\n\n\t\t// finding a point on a bezier curve\n\t\toutput.x =\tinv*inv * sx + 2 * inv * t * cx + t*t * ex;\n\t\toutput.y =\tinv*inv * sy + 2 * inv * t * cy + t*t * ey;\n\n\t\t// finding an angle on a bezier curve\n\t\tif(orient) {\n\t\t\t// convert from radians back to degrees\n\t\t\toutput.rotation = 57.2957795 * Math.atan2(\n\t\t\t\t(cy - sy)*inv + (ey - cy)*t,\n\t\t\t\t(cx - sx)*inv + (ex - cx)*t\n\t\t\t);\n\t\t}\n\t};\n\n\t/**\n\t * Perform a check to validate path information so plugin can avoid later error checking.\n\t * @param {Object} guideData All the information describing the guide to be followed.\n\t * @returns {undefined|String} The problem found, or undefined if no problems.\n\t * @private\n\t */\n\ts._findPathProblems = function(guideData) {\n\t\tvar path = guideData.path;\n\t\tvar valueCount = (path && path.length) || 0;\t// ensure this is a number to simplify later logic\n\t\tif(valueCount < 6 || (valueCount-2) % 4) {\n\t\t\tvar message =\t\"\\tCannot parse 'path' array due to invalid number of entries in path. \";\n\t\t\tmessage +=\t\t\"There should be an odd number of points, at least 3 points, and 2 entries per point (x & y). \";\n\t\t\tmessage +=\t\t\"See 'CanvasRenderingContext2D.quadraticCurveTo' for details as 'path' models a quadratic bezier.\\n\\n\";\n\t\t\tmessage +=\t\t\"Only [ \"+ valueCount +\" ] values found. Expected: \"+ Math.max(Math.ceil((valueCount-2)/4)*4+2, 6); //6, 10, 14,...\n\t\t\treturn message;\n\t\t}\n\n\t\tfor(var i=0; i<valueCount; i++) {\n\t\t\tif(isNaN(path[i])){\n\t\t\t\treturn \"All data in path array must be numeric\";\n\t\t\t}\n\t\t}\n\n\t\tvar start = guideData.start;\n\t\tif(isNaN(start) && !(start === undefined)/* || start < 0 || start > 1*/) {\t// outside 0-1 is unpredictable, but not breaking\n\t\t\treturn \"'start' out of bounds. Expected 0 to 1, got: \"+ start;\n\t\t}\n\t\tvar end = guideData.end;\n\t\tif(isNaN(end) && (end !== undefined)/* || end < 0 || end > 1*/) {\t// outside 0-1 is unpredictable, but not breaking\n\t\t\treturn \"'end' out of bounds. Expected 0 to 1, got: \"+ end;\n\t\t}\n\n\t\tvar orient = guideData.orient;\n\t\tif(orient) { // mirror the check used elsewhere\n\t\t\tif(orient != \"fixed\" && orient != \"auto\" && orient != \"cw\" && orient != \"ccw\") {\n\t\t\t\treturn 'Invalid orientation value. Expected [\"fixed\", \"auto\", \"cw\", \"ccw\", undefined], got: '+ orient;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t};\n\n\tcreatejs.MotionGuidePlugin = MotionGuidePlugin;\n\n}());\n\n//##############################################################################\n// version.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * Static class holding library specific information such as the version and buildDate of\n\t * the library.\n\t * @class TweenJS\n\t **/\n\tvar s = createjs.TweenJS = createjs.TweenJS || {};\n\n\t/**\n\t * The version string for this release.\n\t * @property version\n\t * @type String\n\t * @static\n\t **/\n\ts.version = /*=version*/\"1.0.0\"; // injected by build process\n\n\t/**\n\t * The build date for this release in UTC format.\n\t * @property buildDate\n\t * @type String\n\t * @static\n\t **/\n\ts.buildDate = /*=date*/\"Thu, 14 Sep 2017 19:47:47 GMT\"; // injected by build process\n\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicUUvaC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sYXRlc3QtY3JlYXRlanMvbGliL3R3ZWVuanMvdHdlZW5qcy5qcz9hODRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuKiBUd2VlbkpTXG4qIFZpc2l0IGh0dHA6Ly9jcmVhdGVqcy5jb20vIGZvciBkb2N1bWVudGF0aW9uLCB1cGRhdGVzIGFuZCBleGFtcGxlcy5cbipcbiogQ29weXJpZ2h0IChjKSAyMDEwIGdza2lubmVyLmNvbSwgaW5jLlxuKlxuKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4qIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4qIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuKiBjb25kaXRpb25zOlxuKlxuKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbipcbiogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4qIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4qIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4qIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBleHRlbmQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbndpbmRvdy5jcmVhdGVqcyA9IHdpbmRvdy5jcmVhdGVqc3x8e307XG5cbi8qKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbi8qKlxuICogU2V0cyB1cCB0aGUgcHJvdG90eXBlIGNoYWluIGFuZCBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBmb3IgYSBuZXcgY2xhc3MuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIHJpZ2h0IGFmdGVyIGNyZWF0aW5nIHRoZSBjbGFzcyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBcdGZ1bmN0aW9uIE15U3ViQ2xhc3MoKSB7fVxuICogXHRjcmVhdGVqcy5leHRlbmQoTXlTdWJDbGFzcywgTXlTdXBlckNsYXNzKTtcbiAqIFx0TXlTdWJDbGFzcy5wcm90b3R5cGUuZG9Tb21ldGhpbmcgPSBmdW5jdGlvbigpIHsgfVxuICpcbiAqIFx0dmFyIGZvbyA9IG5ldyBNeVN1YkNsYXNzKCk7XG4gKiBcdGNvbnNvbGUubG9nKGZvbyBpbnN0YW5jZW9mIE15U3VwZXJDbGFzcyk7IC8vIHRydWVcbiAqIFx0Y29uc29sZS5sb2coZm9vLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9PT0gTXlTdWJDbGFzcyk7IC8vIHRydWVcbiAqXG4gKiBAbWV0aG9kIGV4dGVuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ViY2xhc3MgVGhlIHN1YmNsYXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJjbGFzcyBUaGUgc3VwZXJjbGFzcyB0byBleHRlbmQuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgc3ViY2xhc3MncyBuZXcgcHJvdG90eXBlLlxuICovXG5jcmVhdGVqcy5leHRlbmQgPSBmdW5jdGlvbihzdWJjbGFzcywgc3VwZXJjbGFzcykge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRmdW5jdGlvbiBvKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gc3ViY2xhc3M7IH1cblx0by5wcm90b3R5cGUgPSBzdXBlcmNsYXNzLnByb3RvdHlwZTtcblx0cmV0dXJuIChzdWJjbGFzcy5wcm90b3R5cGUgPSBuZXcgbygpKTtcbn07XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBwcm9tb3RlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG53aW5kb3cuY3JlYXRlanMgPSB3aW5kb3cuY3JlYXRlanN8fHt9O1xuXG4vKipcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuXG4vKipcbiAqIFByb21vdGVzIGFueSBtZXRob2RzIG9uIHRoZSBzdXBlciBjbGFzcyB0aGF0IHdlcmUgb3ZlcnJpZGRlbiwgYnkgY3JlYXRpbmcgYW4gYWxpYXMgaW4gdGhlIGZvcm1hdCBgcHJlZml4X21ldGhvZE5hbWVgLlxuICogSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSBzdXBlciBjbGFzcydzIG5hbWUgYXMgdGhlIHByZWZpeC5cbiAqIEFuIGFsaWFzIHRvIHRoZSBzdXBlciBjbGFzcydzIGNvbnN0cnVjdG9yIGlzIGFsd2F5cyBhZGRlZCBpbiB0aGUgZm9ybWF0IGBwcmVmaXhfY29uc3RydWN0b3JgLlxuICogVGhpcyBhbGxvd3MgdGhlIHN1YmNsYXNzIHRvIGNhbGwgc3VwZXIgY2xhc3MgbWV0aG9kcyB3aXRob3V0IHVzaW5nIGBmdW5jdGlvbi5jYWxsYCwgcHJvdmlkaW5nIGJldHRlciBwZXJmb3JtYW5jZS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgYE15U3ViQ2xhc3NgIGV4dGVuZHMgYE15U3VwZXJDbGFzc2AsIGFuZCBib3RoIGRlZmluZSBhIGBkcmF3YCBtZXRob2QsIHRoZW4gY2FsbGluZyBgcHJvbW90ZShNeVN1YkNsYXNzLCBcIk15U3VwZXJDbGFzc1wiKWBcbiAqIHdvdWxkIGFkZCBhIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgIG1ldGhvZCB0byBNeVN1YkNsYXNzIGFuZCBwcm9tb3RlIHRoZSBgZHJhd2AgbWV0aG9kIG9uIGBNeVN1cGVyQ2xhc3NgIHRvIHRoZVxuICogcHJvdG90eXBlIG9mIGBNeVN1YkNsYXNzYCBhcyBgTXlTdXBlckNsYXNzX2RyYXdgLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciB0aGUgY2xhc3MncyBwcm90b3R5cGUgaXMgZnVsbHkgZGVmaW5lZC5cbiAqXG4gKiBcdGZ1bmN0aW9uIENsYXNzQShuYW1lKSB7XG4gKiBcdFx0dGhpcy5uYW1lID0gbmFtZTtcbiAqIFx0fVxuICogXHRDbGFzc0EucHJvdG90eXBlLmdyZWV0ID0gZnVuY3Rpb24oKSB7XG4gKiBcdFx0cmV0dXJuIFwiSGVsbG8gXCIrdGhpcy5uYW1lO1xuICogXHR9XG4gKlxuICogXHRmdW5jdGlvbiBDbGFzc0IobmFtZSwgcHVuY3R1YXRpb24pIHtcbiAqIFx0XHR0aGlzLkNsYXNzQV9jb25zdHJ1Y3RvcihuYW1lKTtcbiAqIFx0XHR0aGlzLnB1bmN0dWF0aW9uID0gcHVuY3R1YXRpb247XG4gKiBcdH1cbiAqIFx0Y3JlYXRlanMuZXh0ZW5kKENsYXNzQiwgQ2xhc3NBKTtcbiAqIFx0Q2xhc3NCLnByb3RvdHlwZS5ncmVldCA9IGZ1bmN0aW9uKCkge1xuICogXHRcdHJldHVybiB0aGlzLkNsYXNzQV9ncmVldCgpK3RoaXMucHVuY3R1YXRpb247XG4gKiBcdH1cbiAqIFx0Y3JlYXRlanMucHJvbW90ZShDbGFzc0IsIFwiQ2xhc3NBXCIpO1xuICpcbiAqIFx0dmFyIGZvbyA9IG5ldyBDbGFzc0IoXCJXb3JsZFwiLCBcIiE/IVwiKTtcbiAqIFx0Y29uc29sZS5sb2coZm9vLmdyZWV0KCkpOyAvLyBIZWxsbyBXb3JsZCE/IVxuICpcbiAqIEBtZXRob2QgcHJvbW90ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ViY2xhc3MgVGhlIGNsYXNzIHRvIHByb21vdGUgc3VwZXIgY2xhc3MgbWV0aG9kcyBvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggVGhlIHByZWZpeCB0byBhZGQgdG8gdGhlIHByb21vdGVkIG1ldGhvZCBuYW1lcy4gVXN1YWxseSB0aGUgbmFtZSBvZiB0aGUgc3VwZXJjbGFzcy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBzdWJjbGFzcy5cbiAqL1xuY3JlYXRlanMucHJvbW90ZSA9IGZ1bmN0aW9uKHN1YmNsYXNzLCBwcmVmaXgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIHN1YlAgPSBzdWJjbGFzcy5wcm90b3R5cGUsIHN1cFAgPSAoT2JqZWN0LmdldFByb3RvdHlwZU9mJiZPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc3ViUCkpfHxzdWJQLl9fcHJvdG9fXztcblx0aWYgKHN1cFApIHtcblx0XHRzdWJQWyhwcmVmaXgrPVwiX1wiKSArIFwiY29uc3RydWN0b3JcIl0gPSBzdXBQLmNvbnN0cnVjdG9yOyAvLyBjb25zdHJ1Y3RvciBpcyBub3QgYWx3YXlzIGlubnVtZXJhYmxlXG5cdFx0Zm9yICh2YXIgbiBpbiBzdXBQKSB7XG5cdFx0XHRpZiAoc3ViUC5oYXNPd25Qcm9wZXJ0eShuKSAmJiAodHlwZW9mIHN1cFBbbl0gPT0gXCJmdW5jdGlvblwiKSkgeyBzdWJQW3ByZWZpeCArIG5dID0gc3VwUFtuXTsgfVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gc3ViY2xhc3M7XG59O1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gZGVwcmVjYXRlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG53aW5kb3cuY3JlYXRlanMgPSB3aW5kb3cuY3JlYXRlanN8fHt9O1xuXG4vKipcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuXG4vKipcbiAqIFdyYXBzIGRlcHJlY2F0ZWQgbWV0aG9kcyBzbyB0aGV5IHN0aWxsIGJlIHVzZWQsIGJ1dCB0aHJvdyB3YXJuaW5ncyB0byBkZXZlbG9wZXJzLlxuICpcbiAqXHRvYmouZGVwcmVjYXRlZE1ldGhvZCA9IGNyZWF0ZWpzLmRlcHJlY2F0ZShcIk9sZCBNZXRob2QgTmFtZVwiLCBvYmouX2ZhbGxiYWNrTWV0aG9kKTtcbiAqXG4gKiBUaGUgcmVjb21tZW5kZWQgYXBwcm9hY2ggZm9yIGRlcHJlY2F0ZWQgcHJvcGVydGllcyBpczpcbiAqXG4gKlx0dHJ5IHtcbiAqXHRcdE9ialx0ZWN0LmRlZmluZVByb3BlcnRpZXMob2JqZWN0LCB7XG4gKlx0XHRcdHJlYWR5T25seVByb3A6IHsgZ2V0OiBjcmVhdGVqcy5kZXByZWNhdGUoXCJyZWFkT25seVByb3BcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmFsdGVybmF0ZVByb3A7IH0pIH0sXG4gKlx0XHRcdHJlYWRXcml0ZVByb3A6IHtcbiAqXHRcdFx0XHRnZXQ6IGNyZWF0ZWpzLmRlcHJlY2F0ZShcInJlYWRPbmx5UHJvcFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuYWx0ZXJuYXRlUHJvcDsgfSksXG4gKlx0XHRcdFx0c2V0OiBjcmVhdGVqcy5kZXByZWNhdGUoXCJyZWFkT25seVByb3BcIiwgZnVuY3Rpb24odmFsKSB7IHRoaXMuYWx0ZXJuYXRlUHJvcCA9IHZhbDsgfSlcbiAqXHRcdH0pO1xuICpcdH0gY2F0Y2ggKGUpIHt9XG4gKlxuICogQG1ldGhvZCBkZXByZWNhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmYWxsYmFja01ldGhvZD1udWxsXSBBIG1ldGhvZCB0byBjYWxsIHdoZW4gdGhlIGRlcHJlY2F0ZWQgbWV0aG9kIGlzIHVzZWQuIFNlZSB0aGUgZXhhbXBsZSBmb3IgaG93XG4gKiBAcGFyYW0ge1N0cmluZ30gW25hbWU9bnVsbF0gVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCBvciBwcm9wZXJ0eSB0byBkaXNwbGF5IGluIHRoZSBjb25zb2xlIHdhcm5pbmcuXG4gKiB0byBkZXByZWNhdGUgcHJvcGVydGllcy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBJZiBhIGZhbGxiYWNrTWV0aG9kIGlzIHN1cHBsaWVkLCByZXR1cm5zIGEgY2xvc3VyZSB0aGF0IHdpbGwgY2FsbCB0aGUgZmFsbGJhY2sgbWV0aG9kIGFmdGVyXG4gKiBsb2dnaW5nIHRoZSB3YXJuaW5nIGluIHRoZSBjb25zb2xlLlxuICovXG5jcmVhdGVqcy5kZXByZWNhdGUgPSBmdW5jdGlvbihmYWxsYmFja01ldGhvZCwgbmFtZSkge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtc2cgPSBcIkRlcHJlY2F0ZWQgcHJvcGVydHkgb3IgbWV0aG9kICdcIituYW1lK1wiJy4gU2VlIGRvY3MgZm9yIGluZm8uXCI7XG5cdFx0Y29uc29sZSAmJiAoY29uc29sZS53YXJuID8gY29uc29sZS53YXJuKG1zZykgOiBjb25zb2xlLmxvZyhtc2cpKTtcblx0XHRyZXR1cm4gZmFsbGJhY2tNZXRob2QgJiYgZmFsbGJhY2tNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fVxufTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEV2ZW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG53aW5kb3cuY3JlYXRlanMgPSB3aW5kb3cuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIENvbnRhaW5zIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgc2hhcmVkIGJ5IGFsbCBldmVudHMgZm9yIHVzZSB3aXRoXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogXG5cdCAqIE5vdGUgdGhhdCBFdmVudCBvYmplY3RzIGFyZSBvZnRlbiByZXVzZWQsIHNvIHlvdSBzaG91bGQgbmV2ZXJcblx0ICogcmVseSBvbiBhbiBldmVudCBvYmplY3QncyBzdGF0ZSBvdXRzaWRlIG9mIHRoZSBjYWxsIHN0YWNrIGl0IHdhcyByZWNlaXZlZCBpbi5cblx0ICogQGNsYXNzIEV2ZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGJ1YmJsZXMgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50IHdpbGwgYnViYmxlIHRocm91Z2ggdGhlIGRpc3BsYXkgbGlzdC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBjYW5jZWxhYmxlIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiB0aGlzIGV2ZW50IGNhbiBiZSBjYW5jZWxsZWQuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIEV2ZW50KHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUpIHtcblx0XHRcblx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSB0eXBlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICoqL1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBvYmplY3QgdGhhdCBnZW5lcmF0ZWQgYW4gZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IHRhcmdldFxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMudGFyZ2V0ID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgdGFyZ2V0IHRoYXQgYSBidWJibGluZyBldmVudCBpcyBiZWluZyBkaXNwYXRjaGVkIGZyb20uIEZvciBub24tYnViYmxpbmcgZXZlbnRzLCB0aGlzIHdpbGxcblx0XHQgKiBhbHdheXMgYmUgdGhlIHNhbWUgYXMgdGFyZ2V0LiBGb3IgZXhhbXBsZSwgaWYgY2hpbGRPYmoucGFyZW50ID0gcGFyZW50T2JqLCBhbmQgYSBidWJibGluZyBldmVudFxuXHRcdCAqIGlzIGdlbmVyYXRlZCBmcm9tIGNoaWxkT2JqLCB0aGVuIGEgbGlzdGVuZXIgb24gcGFyZW50T2JqIHdvdWxkIHJlY2VpdmUgdGhlIGV2ZW50IHdpdGhcblx0XHQgKiB0YXJnZXQ9Y2hpbGRPYmogKHRoZSBvcmlnaW5hbCB0YXJnZXQpIGFuZCBjdXJyZW50VGFyZ2V0PXBhcmVudE9iaiAod2hlcmUgdGhlIGxpc3RlbmVyIHdhcyBhZGRlZCkuXG5cdFx0ICogQHByb3BlcnR5IGN1cnJlbnRUYXJnZXRcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBGb3IgYnViYmxpbmcgZXZlbnRzLCB0aGlzIGluZGljYXRlcyB0aGUgY3VycmVudCBldmVudCBwaGFzZTo8T0w+XG5cdFx0ICogXHQ8TEk+IGNhcHR1cmUgcGhhc2U6IHN0YXJ0aW5nIGZyb20gdGhlIHRvcCBwYXJlbnQgdG8gdGhlIHRhcmdldDwvTEk+XG5cdFx0ICogXHQ8TEk+IGF0IHRhcmdldCBwaGFzZTogY3VycmVudGx5IGJlaW5nIGRpc3BhdGNoZWQgZnJvbSB0aGUgdGFyZ2V0PC9MST5cblx0XHQgKiBcdDxMST4gYnViYmxpbmcgcGhhc2U6IGZyb20gdGhlIHRhcmdldCB0byB0aGUgdG9wIHBhcmVudDwvTEk+XG5cdFx0ICogPC9PTD5cblx0XHQgKiBAcHJvcGVydHkgZXZlbnRQaGFzZVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuZXZlbnRQaGFzZSA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBldmVudCB3aWxsIGJ1YmJsZSB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuXG5cdFx0ICogQHByb3BlcnR5IGJ1YmJsZXNcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuYnViYmxlcyA9ICEhYnViYmxlcztcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mIHRoaXMgZXZlbnQgY2FuIGJlIGNhbmNlbGxlZCB2aWFcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudC9wcmV2ZW50RGVmYXVsdFwifX17ey9jcm9zc0xpbmt9fS4gVGhpcyBpcyBzZXQgdmlhIHRoZSBFdmVudCBjb25zdHJ1Y3Rvci5cblx0XHQgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5jYW5jZWxhYmxlID0gISFjYW5jZWxhYmxlO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgZXBvY2ggdGltZSBhdCB3aGljaCB0aGlzIGV2ZW50IHdhcyBjcmVhdGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSB0aW1lU3RhbXBcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLnRpbWVTdGFtcCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB7eyNjcm9zc0xpbmsgXCJFdmVudC9wcmV2ZW50RGVmYXVsdFwifX17ey9jcm9zc0xpbmt9fSBoYXMgYmVlbiBjYWxsZWRcblx0XHQgKiBvbiB0aGlzIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBkZWZhdWx0UHJldmVudGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHt7I2Nyb3NzTGluayBcIkV2ZW50L3N0b3BQcm9wYWdhdGlvblwifX17ey9jcm9zc0xpbmt9fSBvclxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50L3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwifX17ey9jcm9zc0xpbmt9fSBoYXMgYmVlbiBjYWxsZWQgb24gdGhpcyBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgcHJvcGFnYXRpb25TdG9wcGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYge3sjY3Jvc3NMaW5rIFwiRXZlbnQvc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXCJ9fXt7L2Nyb3NzTGlua319IGhhcyBiZWVuIGNhbGxlZFxuXHRcdCAqIG9uIHRoaXMgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IGltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcmVtb3ZlXCJ9fXt7L2Nyb3NzTGlua319IGhhcyBiZWVuIGNhbGxlZCBvbiB0aGlzIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSByZW1vdmVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLnJlbW92ZWQgPSBmYWxzZTtcblx0fVxuXHR2YXIgcCA9IEV2ZW50LnByb3RvdHlwZTtcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBTZXRzIHt7I2Nyb3NzTGluayBcIkV2ZW50L2RlZmF1bHRQcmV2ZW50ZWRcIn19e3svY3Jvc3NMaW5rfX0gdG8gdHJ1ZSBpZiB0aGUgZXZlbnQgaXMgY2FuY2VsYWJsZS5cblx0ICogTWlycm9ycyB0aGUgRE9NIGxldmVsIDIgZXZlbnQgc3RhbmRhcmQuIEluIGdlbmVyYWwsIGNhbmNlbGFibGUgZXZlbnRzIHRoYXQgaGF2ZSBgcHJldmVudERlZmF1bHQoKWAgY2FsbGVkIHdpbGxcblx0ICogY2FuY2VsIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50LlxuXHQgKiBAbWV0aG9kIHByZXZlbnREZWZhdWx0XG5cdCAqKi9cblx0cC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRoaXMuY2FuY2VsYWJsZSYmdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB7eyNjcm9zc0xpbmsgXCJFdmVudC9wcm9wYWdhdGlvblN0b3BwZWRcIn19e3svY3Jvc3NMaW5rfX0gdG8gdHJ1ZS5cblx0ICogTWlycm9ycyB0aGUgRE9NIGV2ZW50IHN0YW5kYXJkLlxuXHQgKiBAbWV0aG9kIHN0b3BQcm9wYWdhdGlvblxuXHQgKiovXG5cdHAuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHt7I2Nyb3NzTGluayBcIkV2ZW50L3Byb3BhZ2F0aW9uU3RvcHBlZFwifX17ey9jcm9zc0xpbmt9fSBhbmRcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkXCJ9fXt7L2Nyb3NzTGlua319IHRvIHRydWUuXG5cdCAqIE1pcnJvcnMgdGhlIERPTSBldmVudCBzdGFuZGFyZC5cblx0ICogQG1ldGhvZCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cblx0ICoqL1xuXHRwLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhdXNlcyB0aGUgYWN0aXZlIGxpc3RlbmVyIHRvIGJlIHJlbW92ZWQgdmlhIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcblx0ICogXG5cdCAqIFx0XHRteUJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZ0KSB7XG5cdCAqIFx0XHRcdC8vIGRvIHN0dWZmLi4uXG5cdCAqIFx0XHRcdGV2dC5yZW1vdmUoKTsgLy8gcmVtb3ZlcyB0aGlzIGxpc3RlbmVyLlxuXHQgKiBcdFx0fSk7XG5cdCAqIFxuXHQgKiBAbWV0aG9kIHJlbW92ZVxuXHQgKiovXG5cdHAucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZW1vdmVkID0gdHJ1ZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIEV2ZW50IGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge0V2ZW50fSBhIGNsb25lIG9mIHRoZSBFdmVudCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBFdmVudCh0aGlzLnR5cGUsIHRoaXMuYnViYmxlcywgdGhpcy5jYW5jZWxhYmxlKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBQcm92aWRlcyBhIGNoYWluYWJsZSBzaG9ydGN1dCBtZXRob2QgZm9yIHNldHRpbmcgYSBudW1iZXIgb2YgcHJvcGVydGllcyBvbiB0aGUgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2Qgc2V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBBIGdlbmVyaWMgb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBjb3B5IHRvIHRoZSBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7RXZlbnR9IFJldHVybnMgdGhlIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLnNldCA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykgeyB0aGlzW25dID0gcHJvcHNbbl07IH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0V2ZW50ICh0eXBlPVwiK3RoaXMudHlwZStcIildXCI7XG5cdH07XG5cblx0Y3JlYXRlanMuRXZlbnQgPSBFdmVudDtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBFdmVudERpc3BhdGNoZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbndpbmRvdy5jcmVhdGVqcyA9IHdpbmRvdy5jcmVhdGVqc3x8e307XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuLy8gY29uc3RydWN0b3I6XHJcblx0LyoqXHJcblx0ICogRXZlbnREaXNwYXRjaGVyIHByb3ZpZGVzIG1ldGhvZHMgZm9yIG1hbmFnaW5nIHF1ZXVlcyBvZiBldmVudCBsaXN0ZW5lcnMgYW5kIGRpc3BhdGNoaW5nIGV2ZW50cy5cclxuXHQgKlxyXG5cdCAqIFlvdSBjYW4gZWl0aGVyIGV4dGVuZCBFdmVudERpc3BhdGNoZXIgb3IgbWl4IGl0cyBtZXRob2RzIGludG8gYW4gZXhpc3RpbmcgcHJvdG90eXBlIG9yIGluc3RhbmNlIGJ5IHVzaW5nIHRoZVxyXG5cdCAqIEV2ZW50RGlzcGF0Y2hlciB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvaW5pdGlhbGl6ZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXHJcblx0ICogXHJcblx0ICogVG9nZXRoZXIgd2l0aCB0aGUgQ3JlYXRlSlMgRXZlbnQgY2xhc3MsIEV2ZW50RGlzcGF0Y2hlciBwcm92aWRlcyBhbiBleHRlbmRlZCBldmVudCBtb2RlbCB0aGF0IGlzIGJhc2VkIG9uIHRoZVxyXG5cdCAqIERPTSBMZXZlbCAyIGV2ZW50IG1vZGVsLCBpbmNsdWRpbmcgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciwgYW5kIGRpc3BhdGNoRXZlbnQuIEl0IHN1cHBvcnRzXHJcblx0ICogYnViYmxpbmcgLyBjYXB0dXJlLCBwcmV2ZW50RGVmYXVsdCwgc3RvcFByb3BhZ2F0aW9uLCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24sIGFuZCBoYW5kbGVFdmVudC5cclxuXHQgKiBcclxuXHQgKiBFdmVudERpc3BhdGNoZXIgYWxzbyBleHBvc2VzIGEge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL29uXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCwgd2hpY2ggbWFrZXMgaXQgZWFzaWVyXHJcblx0ICogdG8gY3JlYXRlIHNjb3BlZCBsaXN0ZW5lcnMsIGxpc3RlbmVycyB0aGF0IG9ubHkgcnVuIG9uY2UsIGFuZCBsaXN0ZW5lcnMgd2l0aCBhc3NvY2lhdGVkIGFyYml0cmFyeSBkYXRhLiBUaGUgXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL29mZlwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgaXMgbWVyZWx5IGFuIGFsaWFzIHRvXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL3JlbW92ZUV2ZW50TGlzdGVuZXJcIn19e3svY3Jvc3NMaW5rfX0uXHJcblx0ICogXHJcblx0ICogQW5vdGhlciBhZGRpdGlvbiB0byB0aGUgRE9NIExldmVsIDIgbW9kZWwgaXMgdGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9yZW1vdmVBbGxFdmVudExpc3RlbmVyc1wifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIG1ldGhvZCwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbGlzdGVuZXJzIGZvciBhbGwgZXZlbnRzLCBvciBsaXN0ZW5lcnMgZm9yIGEgc3BlY2lmaWMgZXZlbnQuIFRoZSBFdmVudCBvYmplY3QgYWxzbyBcclxuXHQgKiBpbmNsdWRlcyBhIHt7I2Nyb3NzTGluayBcIkV2ZW50L3JlbW92ZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2Qgd2hpY2ggcmVtb3ZlcyB0aGUgYWN0aXZlIGxpc3RlbmVyLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqIEFkZCBFdmVudERpc3BhdGNoZXIgY2FwYWJpbGl0aWVzIHRvIHRoZSBcIk15Q2xhc3NcIiBjbGFzcy5cclxuXHQgKlxyXG5cdCAqICAgICAgRXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUoTXlDbGFzcy5wcm90b3R5cGUpO1xyXG5cdCAqXHJcblx0ICogQWRkIGFuIGV2ZW50IChzZWUge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL2FkZEV2ZW50TGlzdGVuZXJcIn19e3svY3Jvc3NMaW5rfX0pLlxyXG5cdCAqXHJcblx0ICogICAgICBpbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKFwiZXZlbnROYW1lXCIsIGhhbmRsZXJNZXRob2QpO1xyXG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlck1ldGhvZChldmVudCkge1xyXG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LnRhcmdldCArIFwiIFdhcyBDbGlja2VkXCIpO1xyXG5cdCAqICAgICAgfVxyXG5cdCAqXHJcblx0ICogPGI+TWFpbnRhaW5pbmcgcHJvcGVyIHNjb3BlPC9iPjxiciAvPlxyXG5cdCAqIFNjb3BlIChpZS4gXCJ0aGlzXCIpIGNhbiBiZSBiZSBhIGNoYWxsZW5nZSB3aXRoIGV2ZW50cy4gVXNpbmcgdGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9vblwifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIG1ldGhvZCB0byBzdWJzY3JpYmUgdG8gZXZlbnRzIHNpbXBsaWZpZXMgdGhpcy5cclxuXHQgKlxyXG5cdCAqICAgICAgaW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0ICogICAgICAgICAgY29uc29sZS5sb2coaW5zdGFuY2UgPT0gdGhpcyk7IC8vIGZhbHNlLCBzY29wZSBpcyBhbWJpZ3VvdXMuXHJcblx0ICogICAgICB9KTtcclxuXHQgKiAgICAgIFxyXG5cdCAqICAgICAgaW5zdGFuY2Uub24oXCJjbGlja1wiLCBmdW5jdGlvbihldmVudCkge1xyXG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKGluc3RhbmNlID09IHRoaXMpOyAvLyB0cnVlLCBcIm9uXCIgdXNlcyBkaXNwYXRjaGVyIHNjb3BlIGJ5IGRlZmF1bHQuXHJcblx0ICogICAgICB9KTtcclxuXHQgKiBcclxuXHQgKiBJZiB5b3Ugd2FudCB0byB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpbnN0ZWFkLCB5b3UgbWF5IHdhbnQgdG8gdXNlIGZ1bmN0aW9uLmJpbmQoKSBvciBhIHNpbWlsYXIgcHJveHkgdG8gbWFuYWdlXHJcblx0ICogc2NvcGUuXHJcblx0ICpcclxuXHQgKiA8Yj5Ccm93c2VyIHN1cHBvcnQ8L2I+XHJcblx0ICogVGhlIGV2ZW50IG1vZGVsIGluIENyZWF0ZUpTIGNhbiBiZSB1c2VkIHNlcGFyYXRlbHkgZnJvbSB0aGUgc3VpdGUgaW4gYW55IHByb2plY3QsIGhvd2V2ZXIgdGhlIGluaGVyaXRhbmNlIG1vZGVsXHJcblx0ICogcmVxdWlyZXMgbW9kZXJuIGJyb3dzZXJzIChJRTkrKS5cclxuXHQgKiAgICAgIFxyXG5cdCAqXHJcblx0ICogQGNsYXNzIEV2ZW50RGlzcGF0Y2hlclxyXG5cdCAqIEBjb25zdHJ1Y3RvclxyXG5cdCAqKi9cclxuXHRmdW5jdGlvbiBFdmVudERpc3BhdGNoZXIoKSB7XHJcblx0XHJcblx0XHJcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAcHJvcGVydHkgX2xpc3RlbmVyc1xyXG5cdFx0ICogQHR5cGUgT2JqZWN0XHJcblx0XHQgKiovXHJcblx0XHR0aGlzLl9saXN0ZW5lcnMgPSBudWxsO1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIEBwcm90ZWN0ZWRcclxuXHRcdCAqIEBwcm9wZXJ0eSBfY2FwdHVyZUxpc3RlbmVyc1xyXG5cdFx0ICogQHR5cGUgT2JqZWN0XHJcblx0XHQgKiovXHJcblx0XHR0aGlzLl9jYXB0dXJlTGlzdGVuZXJzID0gbnVsbDtcclxuXHR9XHJcblx0dmFyIHAgPSBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlO1xyXG5cclxuLy8gc3RhdGljIHB1YmxpYyBtZXRob2RzOlxyXG5cdC8qKlxyXG5cdCAqIFN0YXRpYyBpbml0aWFsaXplciB0byBtaXggRXZlbnREaXNwYXRjaGVyIG1ldGhvZHMgaW50byBhIHRhcmdldCBvYmplY3Qgb3IgcHJvdG90eXBlLlxyXG5cdCAqIFxyXG5cdCAqIFx0XHRFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShNeUNsYXNzLnByb3RvdHlwZSk7IC8vIGFkZCB0byB0aGUgcHJvdG90eXBlIG9mIHRoZSBjbGFzc1xyXG5cdCAqIFx0XHRFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShteU9iamVjdCk7IC8vIGFkZCB0byBhIHNwZWNpZmljIGluc3RhbmNlXHJcblx0ICogXHJcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXHJcblx0ICogQHN0YXRpY1xyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QgdG8gaW5qZWN0IEV2ZW50RGlzcGF0Y2hlciBtZXRob2RzIGludG8uIFRoaXMgY2FuIGJlIGFuIGluc3RhbmNlIG9yIGFcclxuXHQgKiBwcm90b3R5cGUuXHJcblx0ICoqL1xyXG5cdEV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplID0gZnVuY3Rpb24odGFyZ2V0KSB7XHJcblx0XHR0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lciA9IHAuYWRkRXZlbnRMaXN0ZW5lcjtcclxuXHRcdHRhcmdldC5vbiA9IHAub247XHJcblx0XHR0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHRhcmdldC5vZmYgPSAgcC5yZW1vdmVFdmVudExpc3RlbmVyO1xyXG5cdFx0dGFyZ2V0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gcC5yZW1vdmVBbGxFdmVudExpc3RlbmVycztcclxuXHRcdHRhcmdldC5oYXNFdmVudExpc3RlbmVyID0gcC5oYXNFdmVudExpc3RlbmVyO1xyXG5cdFx0dGFyZ2V0LmRpc3BhdGNoRXZlbnQgPSBwLmRpc3BhdGNoRXZlbnQ7XHJcblx0XHR0YXJnZXQuX2Rpc3BhdGNoRXZlbnQgPSBwLl9kaXNwYXRjaEV2ZW50O1xyXG5cdFx0dGFyZ2V0LndpbGxUcmlnZ2VyID0gcC53aWxsVHJpZ2dlcjtcclxuXHR9O1xyXG5cdFxyXG5cclxuLy8gcHVibGljIG1ldGhvZHM6XHJcblx0LyoqXHJcblx0ICogQWRkcyB0aGUgc3BlY2lmaWVkIGV2ZW50IGxpc3RlbmVyLiBOb3RlIHRoYXQgYWRkaW5nIG11bHRpcGxlIGxpc3RlbmVycyB0byB0aGUgc2FtZSBmdW5jdGlvbiB3aWxsIHJlc3VsdCBpblxyXG5cdCAqIG11bHRpcGxlIGNhbGxiYWNrcyBnZXR0aW5nIGZpcmVkLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGljayk7XHJcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xyXG5cdCAqICAgICAgICAgLy8gQ2xpY2sgaGFwcGVuZWQuXHJcblx0ICogICAgICB9XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXJcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb24gfCBPYmplY3R9IGxpc3RlbmVyIEFuIG9iamVjdCB3aXRoIGEgaGFuZGxlRXZlbnQgbWV0aG9kLCBvciBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlblxyXG5cdCAqIHRoZSBldmVudCBpcyBkaXNwYXRjaGVkLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdIEZvciBldmVudHMgdGhhdCBidWJibGUsIGluZGljYXRlcyB3aGV0aGVyIHRvIGxpc3RlbiBmb3IgdGhlIGV2ZW50IGluIHRoZSBjYXB0dXJlIG9yIGJ1YmJsaW5nL3RhcmdldCBwaGFzZS5cclxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbiB8IE9iamVjdH0gUmV0dXJucyB0aGUgbGlzdGVuZXIgZm9yIGNoYWluaW5nIG9yIGFzc2lnbm1lbnQuXHJcblx0ICoqL1xyXG5cdHAuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzO1xyXG5cdFx0aWYgKHVzZUNhcHR1cmUpIHtcclxuXHRcdFx0bGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnN8fHt9O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzfHx7fTtcclxuXHRcdH1cclxuXHRcdHZhciBhcnIgPSBsaXN0ZW5lcnNbdHlwZV07XHJcblx0XHRpZiAoYXJyKSB7IHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7IH1cclxuXHRcdGFyciA9IGxpc3RlbmVyc1t0eXBlXTsgLy8gcmVtb3ZlIG1heSBoYXZlIGRlbGV0ZWQgdGhlIGFycmF5XHJcblx0XHRpZiAoIWFycikgeyBsaXN0ZW5lcnNbdHlwZV0gPSBbbGlzdGVuZXJdOyAgfVxyXG5cdFx0ZWxzZSB7IGFyci5wdXNoKGxpc3RlbmVyKTsgfVxyXG5cdFx0cmV0dXJuIGxpc3RlbmVyO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogQSBzaG9ydGN1dCBtZXRob2QgZm9yIHVzaW5nIGFkZEV2ZW50TGlzdGVuZXIgdGhhdCBtYWtlcyBpdCBlYXNpZXIgdG8gc3BlY2lmeSBhbiBleGVjdXRpb24gc2NvcGUsIGhhdmUgYSBsaXN0ZW5lclxyXG5cdCAqIG9ubHkgcnVuIG9uY2UsIGFzc29jaWF0ZSBhcmJpdHJhcnkgZGF0YSB3aXRoIHRoZSBsaXN0ZW5lciwgYW5kIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblx0ICogXHJcblx0ICogVGhpcyBtZXRob2Qgd29ya3MgYnkgY3JlYXRpbmcgYW4gYW5vbnltb3VzIHdyYXBwZXIgZnVuY3Rpb24gYW5kIHN1YnNjcmliaW5nIGl0IHdpdGggYWRkRXZlbnRMaXN0ZW5lci5cclxuXHQgKiBUaGUgd3JhcHBlciBmdW5jdGlvbiBpcyByZXR1cm5lZCBmb3IgdXNlIHdpdGggYHJlbW92ZUV2ZW50TGlzdGVuZXJgIChvciBgb2ZmYCkuXHJcblx0ICogXHJcblx0ICogPGI+SU1QT1JUQU5UOjwvYj4gVG8gcmVtb3ZlIGEgbGlzdGVuZXIgYWRkZWQgd2l0aCBgb25gLCB5b3UgbXVzdCBwYXNzIGluIHRoZSByZXR1cm5lZCB3cmFwcGVyIGZ1bmN0aW9uIGFzIHRoZSBsaXN0ZW5lciwgb3IgdXNlXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcmVtb3ZlXCJ9fXt7L2Nyb3NzTGlua319LiBMaWtld2lzZSwgZWFjaCB0aW1lIHlvdSBjYWxsIGBvbmAgYSBORVcgd3JhcHBlciBmdW5jdGlvbiBpcyBzdWJzY3JpYmVkLCBzbyBtdWx0aXBsZSBjYWxsc1xyXG5cdCAqIHRvIGBvbmAgd2l0aCB0aGUgc2FtZSBwYXJhbXMgd2lsbCBjcmVhdGUgbXVsdGlwbGUgbGlzdGVuZXJzLlxyXG5cdCAqIFxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKiBcclxuXHQgKiBcdFx0dmFyIGxpc3RlbmVyID0gbXlCdG4ub24oXCJjbGlja1wiLCBoYW5kbGVDbGljaywgbnVsbCwgZmFsc2UsIHtjb3VudDozfSk7XHJcblx0ICogXHRcdGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2dCwgZGF0YSkge1xyXG5cdCAqIFx0XHRcdGRhdGEuY291bnQgLT0gMTtcclxuXHQgKiBcdFx0XHRjb25zb2xlLmxvZyh0aGlzID09IG15QnRuKTsgLy8gdHJ1ZSAtIHNjb3BlIGRlZmF1bHRzIHRvIHRoZSBkaXNwYXRjaGVyXHJcblx0ICogXHRcdFx0aWYgKGRhdGEuY291bnQgPT0gMCkge1xyXG5cdCAqIFx0XHRcdFx0YWxlcnQoXCJjbGlja2VkIDMgdGltZXMhXCIpO1xyXG5cdCAqIFx0XHRcdFx0bXlCdG4ub2ZmKFwiY2xpY2tcIiwgbGlzdGVuZXIpO1xyXG5cdCAqIFx0XHRcdFx0Ly8gYWx0ZXJuYXRlbHk6IGV2dC5yZW1vdmUoKTtcclxuXHQgKiBcdFx0XHR9XHJcblx0ICogXHRcdH1cclxuXHQgKiBcclxuXHQgKiBAbWV0aG9kIG9uXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBBbiBvYmplY3Qgd2l0aCBhIGhhbmRsZUV2ZW50IG1ldGhvZCwgb3IgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5cclxuXHQgKiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZC5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSBUaGUgc2NvcGUgdG8gZXhlY3V0ZSB0aGUgbGlzdGVuZXIgaW4uIERlZmF1bHRzIHRvIHRoZSBkaXNwYXRjaGVyL2N1cnJlbnRUYXJnZXQgZm9yIGZ1bmN0aW9uIGxpc3RlbmVycywgYW5kIHRvIHRoZSBsaXN0ZW5lciBpdHNlbGYgZm9yIG9iamVjdCBsaXN0ZW5lcnMgKGllLiB1c2luZyBoYW5kbGVFdmVudCkuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gSWYgdHJ1ZSwgdGhlIGxpc3RlbmVyIHdpbGwgcmVtb3ZlIGl0c2VsZiBhZnRlciB0aGUgZmlyc3QgdGltZSBpdCBpcyB0cmlnZ2VyZWQuXHJcblx0ICogQHBhcmFtIHsqfSBbZGF0YV0gQXJiaXRyYXJ5IGRhdGEgdGhhdCB3aWxsIGJlIGluY2x1ZGVkIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHdoZW4gdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlPWZhbHNlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXHJcblx0ICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgdGhlIGFub255bW91cyBmdW5jdGlvbiB0aGF0IHdhcyBjcmVhdGVkIGFuZCBhc3NpZ25lZCBhcyB0aGUgbGlzdGVuZXIuIFRoaXMgaXMgbmVlZGVkIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIgbGF0ZXIgdXNpbmcgLnJlbW92ZUV2ZW50TGlzdGVuZXIuXHJcblx0ICoqL1xyXG5cdHAub24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgc2NvcGUsIG9uY2UsIGRhdGEsIHVzZUNhcHR1cmUpIHtcclxuXHRcdGlmIChsaXN0ZW5lci5oYW5kbGVFdmVudCkge1xyXG5cdFx0XHRzY29wZSA9IHNjb3BlfHxsaXN0ZW5lcjtcclxuXHRcdFx0bGlzdGVuZXIgPSBsaXN0ZW5lci5oYW5kbGVFdmVudDtcclxuXHRcdH1cclxuXHRcdHNjb3BlID0gc2NvcGV8fHRoaXM7XHJcblx0XHRyZXR1cm4gdGhpcy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmN0aW9uKGV2dCkge1xyXG5cdFx0XHRcdGxpc3RlbmVyLmNhbGwoc2NvcGUsIGV2dCwgZGF0YSk7XHJcblx0XHRcdFx0b25jZSYmZXZ0LnJlbW92ZSgpO1xyXG5cdFx0XHR9LCB1c2VDYXB0dXJlKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgZXZlbnQgbGlzdGVuZXIuXHJcblx0ICpcclxuXHQgKiA8Yj5JbXBvcnRhbnQgTm90ZTo8L2I+IHRoYXQgeW91IG11c3QgcGFzcyB0aGUgZXhhY3QgZnVuY3Rpb24gcmVmZXJlbmNlIHVzZWQgd2hlbiB0aGUgZXZlbnQgd2FzIGFkZGVkLiBJZiBhIHByb3h5XHJcblx0ICogZnVuY3Rpb24sIG9yIGZ1bmN0aW9uIGNsb3N1cmUgaXMgdXNlZCBhcyB0aGUgY2FsbGJhY2ssIHRoZSBwcm94eS9jbG9zdXJlIHJlZmVyZW5jZSBtdXN0IGJlIHVzZWQgLSBhIG5ldyBwcm94eSBvclxyXG5cdCAqIGNsb3N1cmUgd2lsbCBub3Qgd29yay5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gb3Igb2JqZWN0LlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdIEZvciBldmVudHMgdGhhdCBidWJibGUsIGluZGljYXRlcyB3aGV0aGVyIHRvIGxpc3RlbiBmb3IgdGhlIGV2ZW50IGluIHRoZSBjYXB0dXJlIG9yIGJ1YmJsaW5nL3RhcmdldCBwaGFzZS5cclxuXHQgKiovXHJcblx0cC5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB1c2VDYXB0dXJlID8gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA6IHRoaXMuX2xpc3RlbmVycztcclxuXHRcdGlmICghbGlzdGVuZXJzKSB7IHJldHVybjsgfVxyXG5cdFx0dmFyIGFyciA9IGxpc3RlbmVyc1t0eXBlXTtcclxuXHRcdGlmICghYXJyKSB7IHJldHVybjsgfVxyXG5cdFx0Zm9yICh2YXIgaT0wLGw9YXJyLmxlbmd0aDsgaTxsOyBpKyspIHtcclxuXHRcdFx0aWYgKGFycltpXSA9PSBsaXN0ZW5lcikge1xyXG5cdFx0XHRcdGlmIChsPT0xKSB7IGRlbGV0ZShsaXN0ZW5lcnNbdHlwZV0pOyB9IC8vIGFsbG93cyBmb3IgZmFzdGVyIGNoZWNrcy5cclxuXHRcdFx0XHRlbHNlIHsgYXJyLnNwbGljZShpLDEpOyB9XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEEgc2hvcnRjdXQgdG8gdGhlIHJlbW92ZUV2ZW50TGlzdGVuZXIgbWV0aG9kLCB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMgYW5kIHJldHVybiB2YWx1ZS4gVGhpcyBpcyBhIGNvbXBhbmlvbiB0byB0aGVcclxuXHQgKiAub24gbWV0aG9kLlxyXG5cdCAqIFxyXG5cdCAqIDxiPklNUE9SVEFOVDo8L2I+IFRvIHJlbW92ZSBhIGxpc3RlbmVyIGFkZGVkIHdpdGggYG9uYCwgeW91IG11c3QgcGFzcyBpbiB0aGUgcmV0dXJuZWQgd3JhcHBlciBmdW5jdGlvbiBhcyB0aGUgbGlzdGVuZXIuIFNlZSBcclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvb25cIn19e3svY3Jvc3NMaW5rfX0gZm9yIGFuIGV4YW1wbGUuXHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIG9mZlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbiB8IE9iamVjdH0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIG9yIG9iamVjdC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXHJcblx0ICoqL1xyXG5cdHAub2ZmID0gcC5yZW1vdmVFdmVudExpc3RlbmVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgdHlwZSwgb3IgYWxsIGxpc3RlbmVycyBvZiBhbGwgdHlwZXMuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzXHJcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XHJcblx0ICpcclxuXHQgKiAgICAgIC8vIFJlbW92ZSBhbGwgY2xpY2sgbGlzdGVuZXJzXHJcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKFwiY2xpY2tcIik7XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIHJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LiBJZiBvbWl0dGVkLCBhbGwgbGlzdGVuZXJzIGZvciBhbGwgdHlwZXMgd2lsbCBiZSByZW1vdmVkLlxyXG5cdCAqKi9cclxuXHRwLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xyXG5cdFx0aWYgKCF0eXBlKSB7IHRoaXMuX2xpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgPSBudWxsOyB9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0aWYgKHRoaXMuX2xpc3RlbmVycykgeyBkZWxldGUodGhpcy5fbGlzdGVuZXJzW3R5cGVdKTsgfVxyXG5cdFx0XHRpZiAodGhpcy5fY2FwdHVyZUxpc3RlbmVycykgeyBkZWxldGUodGhpcy5fY2FwdHVyZUxpc3RlbmVyc1t0eXBlXSk7IH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBEaXNwYXRjaGVzIHRoZSBzcGVjaWZpZWQgZXZlbnQgdG8gYWxsIGxpc3RlbmVycy5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgLy8gVXNlIGEgc3RyaW5nIGV2ZW50XHJcblx0ICogICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKTtcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gVXNlIGFuIEV2ZW50IGluc3RhbmNlXHJcblx0ICogICAgICB2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJwcm9ncmVzc1wiKTtcclxuXHQgKiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGRpc3BhdGNoRXZlbnRcclxuXHQgKiBAcGFyYW0ge09iamVjdCB8IFN0cmluZyB8IEV2ZW50fSBldmVudE9iaiBBbiBvYmplY3Qgd2l0aCBhIFwidHlwZVwiIHByb3BlcnR5LCBvciBhIHN0cmluZyB0eXBlLlxyXG5cdCAqIFdoaWxlIGEgZ2VuZXJpYyBvYmplY3Qgd2lsbCB3b3JrLCBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYSBDcmVhdGVKUyBFdmVudCBpbnN0YW5jZS4gSWYgYSBzdHJpbmcgaXMgdXNlZCxcclxuXHQgKiBkaXNwYXRjaEV2ZW50IHdpbGwgY29uc3RydWN0IGFuIEV2ZW50IGluc3RhbmNlIGlmIG5lY2Vzc2FyeSB3aXRoIHRoZSBzcGVjaWZpZWQgdHlwZS4gVGhpcyBsYXR0ZXIgYXBwcm9hY2ggY2FuXHJcblx0ICogYmUgdXNlZCB0byBhdm9pZCBldmVudCBvYmplY3QgaW5zdGFudGlhdGlvbiBmb3Igbm9uLWJ1YmJsaW5nIGV2ZW50cyB0aGF0IG1heSBub3QgaGF2ZSBhbnkgbGlzdGVuZXJzLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZXNdIFNwZWNpZmllcyB0aGUgYGJ1YmJsZXNgIHZhbHVlIHdoZW4gYSBzdHJpbmcgd2FzIHBhc3NlZCB0byBldmVudE9iai5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYW5jZWxhYmxlXSBTcGVjaWZpZXMgdGhlIGBjYW5jZWxhYmxlYCB2YWx1ZSB3aGVuIGEgc3RyaW5nIHdhcyBwYXNzZWQgdG8gZXZlbnRPYmouXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBmYWxzZSBpZiBgcHJldmVudERlZmF1bHQoKWAgd2FzIGNhbGxlZCBvbiBhIGNhbmNlbGFibGUgZXZlbnQsIHRydWUgb3RoZXJ3aXNlLlxyXG5cdCAqKi9cclxuXHRwLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudE9iaiwgYnViYmxlcywgY2FuY2VsYWJsZSkge1xyXG5cdFx0aWYgKHR5cGVvZiBldmVudE9iaiA9PSBcInN0cmluZ1wiKSB7XHJcblx0XHRcdC8vIHNraXAgZXZlcnl0aGluZyBpZiB0aGVyZSdzIG5vIGxpc3RlbmVycyBhbmQgaXQgZG9lc24ndCBidWJibGU6XHJcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcblx0XHRcdGlmICghYnViYmxlcyAmJiAoIWxpc3RlbmVycyB8fCAhbGlzdGVuZXJzW2V2ZW50T2JqXSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0ZXZlbnRPYmogPSBuZXcgY3JlYXRlanMuRXZlbnQoZXZlbnRPYmosIGJ1YmJsZXMsIGNhbmNlbGFibGUpO1xyXG5cdFx0fSBlbHNlIGlmIChldmVudE9iai50YXJnZXQgJiYgZXZlbnRPYmouY2xvbmUpIHtcclxuXHRcdFx0Ly8gcmVkaXNwYXRjaGluZyBhbiBhY3RpdmUgZXZlbnQgb2JqZWN0LCBzbyBjbG9uZSBpdDpcclxuXHRcdFx0ZXZlbnRPYmogPSBldmVudE9iai5jbG9uZSgpO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHQvLyBUT0RPOiBpdCB3b3VsZCBiZSBuaWNlIHRvIGVsaW1pbmF0ZSB0aGlzLiBNYXliZSBpbiBmYXZvdXIgb2YgZXZ0T2JqIGluc3RhbmNlb2YgRXZlbnQ/IE9yICEhZXZ0T2JqLmNyZWF0ZUV2ZW50XHJcblx0XHR0cnkgeyBldmVudE9iai50YXJnZXQgPSB0aGlzOyB9IGNhdGNoIChlKSB7fSAvLyB0cnkvY2F0Y2ggYWxsb3dzIHJlZGlzcGF0Y2hpbmcgb2YgbmF0aXZlIGV2ZW50c1xyXG5cclxuXHRcdGlmICghZXZlbnRPYmouYnViYmxlcyB8fCAhdGhpcy5wYXJlbnQpIHtcclxuXHRcdFx0dGhpcy5fZGlzcGF0Y2hFdmVudChldmVudE9iaiwgMik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgdG9wPXRoaXMsIGxpc3Q9W3RvcF07XHJcblx0XHRcdHdoaWxlICh0b3AucGFyZW50KSB7IGxpc3QucHVzaCh0b3AgPSB0b3AucGFyZW50KTsgfVxyXG5cdFx0XHR2YXIgaSwgbD1saXN0Lmxlbmd0aDtcclxuXHJcblx0XHRcdC8vIGNhcHR1cmUgJiBhdFRhcmdldFxyXG5cdFx0XHRmb3IgKGk9bC0xOyBpPj0wICYmICFldmVudE9iai5wcm9wYWdhdGlvblN0b3BwZWQ7IGktLSkge1xyXG5cdFx0XHRcdGxpc3RbaV0uX2Rpc3BhdGNoRXZlbnQoZXZlbnRPYmosIDErKGk9PTApKTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBidWJibGluZ1xyXG5cdFx0XHRmb3IgKGk9MTsgaTxsICYmICFldmVudE9iai5wcm9wYWdhdGlvblN0b3BwZWQ7IGkrKykge1xyXG5cdFx0XHRcdGxpc3RbaV0uX2Rpc3BhdGNoRXZlbnQoZXZlbnRPYmosIDMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gIWV2ZW50T2JqLmRlZmF1bHRQcmV2ZW50ZWQ7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXHJcblx0ICogQG1ldGhvZCBoYXNFdmVudExpc3RlbmVyXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxyXG5cdCAqKi9cclxuXHRwLmhhc0V2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLCBjYXB0dXJlTGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVycztcclxuXHRcdHJldHVybiAhISgobGlzdGVuZXJzICYmIGxpc3RlbmVyc1t0eXBlXSkgfHwgKGNhcHR1cmVMaXN0ZW5lcnMgJiYgY2FwdHVyZUxpc3RlbmVyc1t0eXBlXSkpO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUgb24gdGhpcyBvYmplY3Qgb3IgYW55IG9mIGl0c1xyXG5cdCAqIGFuY2VzdG9ycyAocGFyZW50LCBwYXJlbnQncyBwYXJlbnQsIGV0YykuIEEgcmV0dXJuIHZhbHVlIG9mIHRydWUgaW5kaWNhdGVzIHRoYXQgaWYgYSBidWJibGluZyBldmVudCBvZiB0aGVcclxuXHQgKiBzcGVjaWZpZWQgdHlwZSBpcyBkaXNwYXRjaGVkIGZyb20gdGhpcyBvYmplY3QsIGl0IHdpbGwgdHJpZ2dlciBhdCBsZWFzdCBvbmUgbGlzdGVuZXIuXHJcblx0ICogXHJcblx0ICogVGhpcyBpcyBzaW1pbGFyIHRvIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9oYXNFdmVudExpc3RlbmVyXCJ9fXt7L2Nyb3NzTGlua319LCBidXQgaXQgc2VhcmNoZXMgdGhlIGVudGlyZVxyXG5cdCAqIGV2ZW50IGZsb3cgZm9yIGEgbGlzdGVuZXIsIG5vdCBqdXN0IHRoaXMgb2JqZWN0LlxyXG5cdCAqIEBtZXRob2Qgd2lsbFRyaWdnZXJcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cclxuXHQgKiovXHJcblx0cC53aWxsVHJpZ2dlciA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRcdHZhciBvID0gdGhpcztcclxuXHRcdHdoaWxlIChvKSB7XHJcblx0XHRcdGlmIChvLmhhc0V2ZW50TGlzdGVuZXIodHlwZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0byA9IG8ucGFyZW50O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cclxuXHQgKiovXHJcblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIFwiW0V2ZW50RGlzcGF0Y2hlcl1cIjtcclxuXHR9O1xyXG5cclxuXHJcbi8vIHByaXZhdGUgbWV0aG9kczpcclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIF9kaXNwYXRjaEV2ZW50XHJcblx0ICogQHBhcmFtIHtPYmplY3QgfCBFdmVudH0gZXZlbnRPYmpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRQaGFzZVxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiovXHJcblx0cC5fZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50T2JqLCBldmVudFBoYXNlKSB7XHJcblx0XHR2YXIgbCwgYXJyLCBsaXN0ZW5lcnMgPSAoZXZlbnRQaGFzZSA8PSAyKSA/IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgOiB0aGlzLl9saXN0ZW5lcnM7XHJcblx0XHRpZiAoZXZlbnRPYmogJiYgbGlzdGVuZXJzICYmIChhcnIgPSBsaXN0ZW5lcnNbZXZlbnRPYmoudHlwZV0pICYmIChsPWFyci5sZW5ndGgpKSB7XHJcblx0XHRcdHRyeSB7IGV2ZW50T2JqLmN1cnJlbnRUYXJnZXQgPSB0aGlzOyB9IGNhdGNoIChlKSB7fVxyXG5cdFx0XHR0cnkgeyBldmVudE9iai5ldmVudFBoYXNlID0gZXZlbnRQaGFzZXwwOyB9IGNhdGNoIChlKSB7fVxyXG5cdFx0XHRldmVudE9iai5yZW1vdmVkID0gZmFsc2U7XHJcblx0XHRcdFxyXG5cdFx0XHRhcnIgPSBhcnIuc2xpY2UoKTsgLy8gdG8gYXZvaWQgaXNzdWVzIHdpdGggaXRlbXMgYmVpbmcgcmVtb3ZlZCBvciBhZGRlZCBkdXJpbmcgdGhlIGRpc3BhdGNoXHJcblx0XHRcdGZvciAodmFyIGk9MDsgaTxsICYmICFldmVudE9iai5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ7IGkrKykge1xyXG5cdFx0XHRcdHZhciBvID0gYXJyW2ldO1xyXG5cdFx0XHRcdGlmIChvLmhhbmRsZUV2ZW50KSB7IG8uaGFuZGxlRXZlbnQoZXZlbnRPYmopOyB9XHJcblx0XHRcdFx0ZWxzZSB7IG8oZXZlbnRPYmopOyB9XHJcblx0XHRcdFx0aWYgKGV2ZW50T2JqLnJlbW92ZWQpIHtcclxuXHRcdFx0XHRcdHRoaXMub2ZmKGV2ZW50T2JqLnR5cGUsIG8sIGV2ZW50UGhhc2U9PTEpO1xyXG5cdFx0XHRcdFx0ZXZlbnRPYmoucmVtb3ZlZCA9IGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKGV2ZW50UGhhc2UgPT09IDIpIHsgdGhpcy5fZGlzcGF0Y2hFdmVudChldmVudE9iaiwgMi4xKTsgfVxyXG5cdH07XHJcblxyXG5cclxuXHRjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIgPSBFdmVudERpc3BhdGNoZXI7XHJcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUaWNrZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbndpbmRvdy5jcmVhdGVqcyA9IHdpbmRvdy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBUaGUgVGlja2VyIHByb3ZpZGVzIGEgY2VudHJhbGl6ZWQgdGljayBvciBoZWFydGJlYXQgYnJvYWRjYXN0IGF0IGEgc2V0IGludGVydmFsLiBMaXN0ZW5lcnMgY2FuIHN1YnNjcmliZSB0byB0aGUgdGlja1xuXHQgKiBldmVudCB0byBiZSBub3RpZmllZCB3aGVuIGEgc2V0IHRpbWUgaW50ZXJ2YWwgaGFzIGVsYXBzZWQuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgaW50ZXJ2YWwgdGhhdCB0aGUgdGljayBldmVudCBpcyBjYWxsZWQgaXMgYSB0YXJnZXQgaW50ZXJ2YWwsIGFuZCBtYXkgYmUgYnJvYWRjYXN0IGF0IGEgc2xvd2VyIGludGVydmFsXG5cdCAqIHdoZW4gdW5kZXIgaGlnaCBDUFUgbG9hZC4gVGhlIFRpY2tlciBjbGFzcyB1c2VzIGEgc3RhdGljIGludGVyZmFjZSAoZXguIGBUaWNrZXIuZnJhbWVyYXRlID0gMzA7YCkgYW5kXG5cdCAqIGNhbiBub3QgYmUgaW5zdGFudGlhdGVkLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIGhhbmRsZVRpY2spO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZVRpY2soZXZlbnQpIHtcblx0ICogICAgICAgICAgLy8gQWN0aW9ucyBjYXJyaWVkIG91dCBlYWNoIHRpY2sgKGFrYSBmcmFtZSlcblx0ICogICAgICAgICAgaWYgKCFldmVudC5wYXVzZWQpIHtcblx0ICogICAgICAgICAgICAgIC8vIEFjdGlvbnMgY2FycmllZCBvdXQgd2hlbiB0aGUgVGlja2VyIGlzIG5vdCBwYXVzZWQuXG5cdCAqICAgICAgICAgIH1cblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBjbGFzcyBUaWNrZXJcblx0ICogQHVzZXMgRXZlbnREaXNwYXRjaGVyXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRmdW5jdGlvbiBUaWNrZXIoKSB7XG5cdFx0dGhyb3cgXCJUaWNrZXIgY2Fubm90IGJlIGluc3RhbnRpYXRlZC5cIjtcblx0fVxuXG5cbi8vIGNvbnN0YW50czpcblx0LyoqXG5cdCAqIEluIHRoaXMgbW9kZSwgVGlja2VyIHVzZXMgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBBUEksIGJ1dCBhdHRlbXB0cyB0byBzeW5jaCB0aGUgdGlja3MgdG8gdGFyZ2V0IGZyYW1lcmF0ZS4gSXRcblx0ICogdXNlcyBhIHNpbXBsZSBoZXVyaXN0aWMgdGhhdCBjb21wYXJlcyB0aGUgdGltZSBvZiB0aGUgUkFGIHJldHVybiB0byB0aGUgdGFyZ2V0IHRpbWUgZm9yIHRoZSBjdXJyZW50IGZyYW1lIGFuZFxuXHQgKiBkaXNwYXRjaGVzIHRoZSB0aWNrIHdoZW4gdGhlIHRpbWUgaXMgd2l0aGluIGEgY2VydGFpbiB0aHJlc2hvbGQuXG5cdCAqXG5cdCAqIFRoaXMgbW9kZSBoYXMgYSBoaWdoZXIgdmFyaWFuY2UgZm9yIHRpbWUgYmV0d2VlbiBmcmFtZXMgdGhhbiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvVElNRU9VVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogYnV0IGRvZXMgbm90IHJlcXVpcmUgdGhhdCBjb250ZW50IGJlIHRpbWUgYmFzZWQgYXMgd2l0aCB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvUkFGOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHdoaWxlXG5cdCAqIGdhaW5pbmcgdGhlIGJlbmVmaXRzIG9mIHRoYXQgQVBJIChzY3JlZW4gc3luY2gsIGJhY2tncm91bmQgdGhyb3R0bGluZykuXG5cdCAqXG5cdCAqIFZhcmlhbmNlIGlzIHVzdWFsbHkgbG93ZXN0IGZvciBmcmFtZXJhdGVzIHRoYXQgYXJlIGEgZGl2aXNvciBvZiB0aGUgUkFGIGZyZXF1ZW5jeS4gVGhpcyBpcyB1c3VhbGx5IDYwLCBzb1xuXHQgKiBmcmFtZXJhdGVzIG9mIDEwLCAxMiwgMTUsIDIwLCBhbmQgMzAgd29yayB3ZWxsLlxuXHQgKlxuXHQgKiBGYWxscyBiYWNrIHRvIHt7I2Nyb3NzTGluayBcIlRpY2tlci9USU1FT1VUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlmIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgQVBJIGlzIG5vdFxuXHQgKiBzdXBwb3J0ZWQuXG5cdCAqIEBwcm9wZXJ0eSBSQUZfU1lOQ0hFRFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IFwic3luY2hlZFwiXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdFRpY2tlci5SQUZfU1lOQ0hFRCA9IFwic3luY2hlZFwiO1xuXG5cdC8qKlxuXHQgKiBJbiB0aGlzIG1vZGUsIFRpY2tlciBwYXNzZXMgdGhyb3VnaCB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGhlYXJ0YmVhdCwgaWdub3JpbmcgdGhlIHRhcmdldCBmcmFtZXJhdGUgY29tcGxldGVseS5cblx0ICogQmVjYXVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZnJlcXVlbmN5IGlzIG5vdCBkZXRlcm1pbmlzdGljLCBhbnkgY29udGVudCB1c2luZyB0aGlzIG1vZGUgc2hvdWxkIGJlIHRpbWUgYmFzZWQuXG5cdCAqIFlvdSBjYW4gbGV2ZXJhZ2Uge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2dldFRpbWVcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBvYmplY3QncyBcImRlbHRhXCIgcHJvcGVydGllcyB0byBtYWtlIHRoaXMgZWFzaWVyLlxuXHQgKlxuXHQgKiBGYWxscyBiYWNrIG9uIHt7I2Nyb3NzTGluayBcIlRpY2tlci9USU1FT1VUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlmIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgQVBJIGlzIG5vdFxuXHQgKiBzdXBwb3J0ZWQuXG5cdCAqIEBwcm9wZXJ0eSBSQUZcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBcInJhZlwiXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdFRpY2tlci5SQUYgPSBcInJhZlwiO1xuXG5cdC8qKlxuXHQgKiBJbiB0aGlzIG1vZGUsIFRpY2tlciB1c2VzIHRoZSBzZXRUaW1lb3V0IEFQSS4gVGhpcyBwcm92aWRlcyBwcmVkaWN0YWJsZSwgYWRhcHRpdmUgZnJhbWUgdGltaW5nLCBidXQgZG9lcyBub3Rcblx0ICogcHJvdmlkZSB0aGUgYmVuZWZpdHMgb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIChzY3JlZW4gc3luY2gsIGJhY2tncm91bmQgdGhyb3R0bGluZykuXG5cdCAqIEBwcm9wZXJ0eSBUSU1FT1VUXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgXCJ0aW1lb3V0XCJcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0VGlja2VyLlRJTUVPVVQgPSBcInRpbWVvdXRcIjtcblxuXG4vLyBzdGF0aWMgZXZlbnRzOlxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCBlYWNoIHRpY2suIFRoZSBldmVudCB3aWxsIGJlIGRpc3BhdGNoZWQgdG8gZWFjaCBsaXN0ZW5lciBldmVuIHdoZW4gdGhlIFRpY2tlciBoYXMgYmVlbiBwYXVzZWQgdXNpbmdcblx0ICoge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3BhdXNlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLlRpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBoYW5kbGVUaWNrKTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVUaWNrKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKFwiUGF1c2VkOlwiLCBldmVudC5wYXVzZWQsIGV2ZW50LmRlbHRhKTtcblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBldmVudCB0aWNrXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBwYXVzZWQgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRpY2tlciBpcyBjdXJyZW50bHkgcGF1c2VkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgVGhlIHRpbWUgZWxhcHNlZCBpbiBtcyBzaW5jZSB0aGUgbGFzdCB0aWNrLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgdG90YWwgdGltZSBpbiBtcyBzaW5jZSBUaWNrZXIgd2FzIGluaXRpYWxpemVkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcnVuVGltZSBUaGUgdG90YWwgdGltZSBpbiBtcyB0aGF0IFRpY2tlciB3YXMgbm90IHBhdXNlZCBzaW5jZSBpdCB3YXMgaW5pdGlhbGl6ZWQuIEZvciBleGFtcGxlLFxuXHQgKiBcdHlvdSBjb3VsZCBkZXRlcm1pbmUgdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgdGhlIFRpY2tlciBoYXMgYmVlbiBwYXVzZWQgc2luY2UgaW5pdGlhbGl6YXRpb24gd2l0aCBgdGltZS1ydW5UaW1lYC5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cbi8vIHB1YmxpYyBzdGF0aWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIFNwZWNpZmllcyB0aGUgdGltaW5nIGFwaSAoc2V0VGltZW91dCBvciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIGFuZCBtb2RlIHRvIHVzZS4gU2VlXG5cdCAqIHt7I2Nyb3NzTGluayBcIlRpY2tlci9USU1FT1VUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvUkFGOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LCBhbmRcblx0ICoge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1JBRl9TWU5DSEVEOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb2RlIGRldGFpbHMuXG5cdCAqIEBwcm9wZXJ0eSB0aW1pbmdNb2RlXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgVGlja2VyLlRJTUVPVVRcblx0ICoqL1xuXHRUaWNrZXIudGltaW5nTW9kZSA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFNwZWNpZmllcyBhIG1heGltdW0gdmFsdWUgZm9yIHRoZSBkZWx0YSBwcm9wZXJ0eSBpbiB0aGUgdGljayBldmVudCBvYmplY3QuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYnVpbGRpbmcgdGltZVxuXHQgKiBiYXNlZCBhbmltYXRpb25zIGFuZCBzeXN0ZW1zIHRvIHByZXZlbnQgaXNzdWVzIGNhdXNlZCBieSBsYXJnZSB0aW1lIGdhcHMgY2F1c2VkIGJ5IGJhY2tncm91bmQgdGFicywgc3lzdGVtIHNsZWVwLFxuXHQgKiBhbGVydCBkaWFsb2dzLCBvciBvdGhlciBibG9ja2luZyByb3V0aW5lcy4gRG91YmxlIHRoZSBleHBlY3RlZCBmcmFtZSBkdXJhdGlvbiBpcyBvZnRlbiBhbiBlZmZlY3RpdmUgdmFsdWVcblx0ICogKGV4LiBtYXhEZWx0YT01MCB3aGVuIHJ1bm5pbmcgYXQgNDBmcHMpLlxuXHQgKiBcblx0ICogVGhpcyBkb2VzIG5vdCBpbXBhY3QgYW55IG90aGVyIHZhbHVlcyAoZXguIHRpbWUsIHJ1blRpbWUsIGV0YyksIHNvIHlvdSBtYXkgZXhwZXJpZW5jZSBpc3N1ZXMgaWYgeW91IGVuYWJsZSBtYXhEZWx0YVxuXHQgKiB3aGVuIHVzaW5nIGJvdGggZGVsdGEgYW5kIG90aGVyIHZhbHVlcy5cblx0ICogXG5cdCAqIElmIDAsIHRoZXJlIGlzIG5vIG1heGltdW0uXG5cdCAqIEBwcm9wZXJ0eSBtYXhEZWx0YVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDBcblx0ICovXG5cdFRpY2tlci5tYXhEZWx0YSA9IDA7XG5cdFxuXHQvKipcblx0ICogV2hlbiB0aGUgdGlja2VyIGlzIHBhdXNlZCwgYWxsIGxpc3RlbmVycyB3aWxsIHN0aWxsIHJlY2VpdmUgYSB0aWNrIGV2ZW50LCBidXQgdGhlIDxjb2RlPnBhdXNlZDwvY29kZT4gcHJvcGVydHlcblx0ICogb2YgdGhlIGV2ZW50IHdpbGwgYmUgYHRydWVgLiBBbHNvLCB3aGlsZSBwYXVzZWQgdGhlIGBydW5UaW1lYCB3aWxsIG5vdCBpbmNyZWFzZS4gU2VlIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aWNrOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvZ2V0VGltZVwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHt7I2Nyb3NzTGluayBcIlRpY2tlci9nZXRFdmVudFRpbWVcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmVcblx0ICogaW5mby5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLlRpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBoYW5kbGVUaWNrKTtcblx0ICogICAgICBjcmVhdGVqcy5UaWNrZXIucGF1c2VkID0gdHJ1ZTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVUaWNrKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LnBhdXNlZCxcblx0ICogICAgICAgICAgXHRjcmVhdGVqcy5UaWNrZXIuZ2V0VGltZShmYWxzZSksXG5cdCAqICAgICAgICAgIFx0Y3JlYXRlanMuVGlja2VyLmdldFRpbWUodHJ1ZSkpO1xuXHQgKiAgICAgIH1cblx0ICpcblx0ICogQHByb3BlcnR5IHBhdXNlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAZGVmYXVsdCBmYWxzZVxuXHQgKiovXG5cdFRpY2tlci5wYXVzZWQgPSBmYWxzZTtcblxuXG4vLyBtaXgtaW5zOlxuXHQvLyBFdmVudERpc3BhdGNoZXIgbWV0aG9kczpcblx0VGlja2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBudWxsO1xuXHRUaWNrZXIucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMgPSBudWxsO1xuXHRUaWNrZXIuZGlzcGF0Y2hFdmVudCA9IG51bGw7XG5cdFRpY2tlci5oYXNFdmVudExpc3RlbmVyID0gbnVsbDtcblx0VGlja2VyLl9saXN0ZW5lcnMgPSBudWxsO1xuXHRjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShUaWNrZXIpOyAvLyBpbmplY3QgRXZlbnREaXNwYXRjaGVyIG1ldGhvZHMuXG5cdFRpY2tlci5fYWRkRXZlbnRMaXN0ZW5lciA9IFRpY2tlci5hZGRFdmVudExpc3RlbmVyO1xuXHRUaWNrZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuXHRcdCFUaWNrZXIuX2luaXRlZCYmVGlja2VyLmluaXQoKTtcblx0XHRyZXR1cm4gVGlja2VyLl9hZGRFdmVudExpc3RlbmVyLmFwcGx5KFRpY2tlciwgYXJndW1lbnRzKTtcblx0fTtcblxuXG4vLyBwcml2YXRlIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQHByb3BlcnR5IF9pbml0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQHByaXZhdGVcblx0ICoqL1xuXHRUaWNrZXIuX2luaXRlZCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3N0YXJ0VGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqKi9cblx0VGlja2VyLl9zdGFydFRpbWUgPSAwO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3BhdXNlZFRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiovXG5cdFRpY2tlci5fcGF1c2VkVGltZT0wO1xuXG5cdC8qKlxuXHQgKiBUaGUgbnVtYmVyIG9mIHRpY2tzIHRoYXQgaGF2ZSBwYXNzZWRcblx0ICogQHByb3BlcnR5IF90aWNrc1xuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqKi9cblx0VGlja2VyLl90aWNrcyA9IDA7XG5cblx0LyoqXG5cdCAqIFRoZSBudW1iZXIgb2YgdGlja3MgdGhhdCBoYXZlIHBhc3NlZCB3aGlsZSBUaWNrZXIgaGFzIGJlZW4gcGF1c2VkXG5cdCAqIEBwcm9wZXJ0eSBfcGF1c2VkVGlja3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiovXG5cdFRpY2tlci5fcGF1c2VkVGlja3MgPSAwO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX2ludGVydmFsXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHByaXZhdGVcblx0ICoqL1xuXHRUaWNrZXIuX2ludGVydmFsID0gNTA7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfbGFzdFRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiovXG5cdFRpY2tlci5fbGFzdFRpbWUgPSAwO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3RpbWVzXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiovXG5cdFRpY2tlci5fdGltZXMgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3RpY2tUaW1lc1xuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQHByaXZhdGVcblx0ICoqL1xuXHRUaWNrZXIuX3RpY2tUaW1lcyA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFN0b3JlcyB0aGUgdGltZW91dCBvciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgaWQuXG5cdCAqIEBwcm9wZXJ0eSBfdGltZXJJZFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqKi9cblx0VGlja2VyLl90aW1lcklkID0gbnVsbDtcblx0XG5cdC8qKlxuXHQgKiBUcnVlIGlmIGN1cnJlbnRseSB1c2luZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGZhbHNlIGlmIHVzaW5nIHNldFRpbWVvdXQuIFRoaXMgbWF5IGJlIGRpZmZlcmVudCB0aGFuIHRpbWluZ01vZGVcblx0ICogaWYgdGhhdCBwcm9wZXJ0eSBjaGFuZ2VkIGFuZCBhIHRpY2sgaGFzbid0IGZpcmVkLlxuXHQgKiBAcHJvcGVydHkgX3JhZlxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiovXG5cdFRpY2tlci5fcmFmID0gdHJ1ZTtcblx0XG5cbi8vIHN0YXRpYyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvaW50ZXJ2YWw6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBfc2V0SW50ZXJ2YWxcblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaW50ZXJ2YWxcblx0ICoqL1xuXHRUaWNrZXIuX3NldEludGVydmFsID0gZnVuY3Rpb24oaW50ZXJ2YWwpIHtcblx0XHRUaWNrZXIuX2ludGVydmFsID0gaW50ZXJ2YWw7XG5cdFx0aWYgKCFUaWNrZXIuX2luaXRlZCkgeyByZXR1cm47IH1cblx0XHRUaWNrZXIuX3NldHVwVGljaygpO1xuXHR9O1xuXHQvLyBUaWNrZXIuc2V0SW50ZXJ2YWwgaXMgQGRlcHJlY2F0ZWQuIFJlbW92ZSBmb3IgMS4xK1xuXHRUaWNrZXIuc2V0SW50ZXJ2YWwgPSBjcmVhdGVqcy5kZXByZWNhdGUoVGlja2VyLl9zZXRJbnRlcnZhbCwgXCJUaWNrZXIuc2V0SW50ZXJ2YWxcIik7XG5cblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2ludGVydmFsOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgX2dldEludGVydmFsXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdFRpY2tlci5fZ2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gVGlja2VyLl9pbnRlcnZhbDtcblx0fTtcblx0Ly8gVGlja2VyLmdldEludGVydmFsIGlzIEBkZXByZWNhdGVkLiBSZW1vdmUgZm9yIDEuMStcblx0VGlja2VyLmdldEludGVydmFsID0gY3JlYXRlanMuZGVwcmVjYXRlKFRpY2tlci5fZ2V0SW50ZXJ2YWwsIFwiVGlja2VyLmdldEludGVydmFsXCIpO1xuXG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9mcmFtZXJhdGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBfc2V0RlBTXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG5cdCAqKi9cblx0VGlja2VyLl9zZXRGUFMgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFRpY2tlci5fc2V0SW50ZXJ2YWwoMTAwMC92YWx1ZSk7XG5cdH07XG5cdC8vIFRpY2tlci5zZXRGUFMgaXMgQGRlcHJlY2F0ZWQuIFJlbW92ZSBmb3IgMS4xK1xuXHRUaWNrZXIuc2V0RlBTID0gY3JlYXRlanMuZGVwcmVjYXRlKFRpY2tlci5fc2V0RlBTLCBcIlRpY2tlci5zZXRGUFNcIik7XG5cblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2ZyYW1lcmF0ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIF9nZXRGUFNcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0VGlja2VyLl9nZXRGUFMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gMTAwMC9UaWNrZXIuX2ludGVydmFsO1xuXHR9O1xuXHQvLyBUaWNrZXIuZ2V0RlBTIGlzIEBkZXByZWNhdGVkLiBSZW1vdmUgZm9yIDEuMStcblx0VGlja2VyLmdldEZQUyA9IGNyZWF0ZWpzLmRlcHJlY2F0ZShUaWNrZXIuX2dldEZQUywgXCJUaWNrZXIuZ2V0RlBTXCIpO1xuXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgdGhlIHRhcmdldCB0aW1lIChpbiBtaWxsaXNlY29uZHMpIGJldHdlZW4gdGlja3MuIERlZmF1bHQgaXMgNTAgKDIwIEZQUykuXG5cdCAqIE5vdGUgdGhhdCBhY3R1YWwgdGltZSBiZXR3ZWVuIHRpY2tzIG1heSBiZSBtb3JlIHRoYW4gc3BlY2lmaWVkIGRlcGVuZGluZyBvbiBDUFUgbG9hZC5cblx0ICogVGhpcyBwcm9wZXJ0eSBpcyBpZ25vcmVkIGlmIHRoZSB0aWNrZXIgaXMgdXNpbmcgdGhlIGBSQUZgIHRpbWluZyBtb2RlLlxuXHQgKiBAcHJvcGVydHkgaW50ZXJ2YWxcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiovXG5cdCBcblx0LyoqXG5cdCAqIEluZGljYXRlcyB0aGUgdGFyZ2V0IGZyYW1lIHJhdGUgaW4gZnJhbWVzIHBlciBzZWNvbmQgKEZQUykuIEVmZmVjdGl2ZWx5IGp1c3QgYSBzaG9ydGN1dCB0byBgaW50ZXJ2YWxgLCB3aGVyZVxuXHQgKiBgZnJhbWVyYXRlID09IDEwMDAvaW50ZXJ2YWxgLlxuXHQgKiBAcHJvcGVydHkgZnJhbWVyYXRlXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICoqL1xuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRpY2tlciwge1xuXHRcdFx0aW50ZXJ2YWw6IHsgZ2V0OiBUaWNrZXIuX2dldEludGVydmFsLCBzZXQ6IFRpY2tlci5fc2V0SW50ZXJ2YWwgfSxcblx0XHRcdGZyYW1lcmF0ZTogeyBnZXQ6IFRpY2tlci5fZ2V0RlBTLCBzZXQ6IFRpY2tlci5fc2V0RlBTIH1cblx0XHR9KTtcblx0fSBjYXRjaCAoZSkgeyBjb25zb2xlLmxvZyhlKTsgfVxuXG5cbi8vIHB1YmxpYyBzdGF0aWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFN0YXJ0cyB0aGUgdGljay4gVGhpcyBpcyBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBmaXJzdCBsaXN0ZW5lciBpcyBhZGRlZC5cblx0ICogQG1ldGhvZCBpbml0XG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUaWNrZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChUaWNrZXIuX2luaXRlZCkgeyByZXR1cm47IH1cblx0XHRUaWNrZXIuX2luaXRlZCA9IHRydWU7XG5cdFx0VGlja2VyLl90aW1lcyA9IFtdO1xuXHRcdFRpY2tlci5fdGlja1RpbWVzID0gW107XG5cdFx0VGlja2VyLl9zdGFydFRpbWUgPSBUaWNrZXIuX2dldFRpbWUoKTtcblx0XHRUaWNrZXIuX3RpbWVzLnB1c2goVGlja2VyLl9sYXN0VGltZSA9IDApO1xuXHRcdFRpY2tlci5pbnRlcnZhbCA9IFRpY2tlci5faW50ZXJ2YWw7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU3RvcHMgdGhlIFRpY2tlciBhbmQgcmVtb3ZlcyBhbGwgbGlzdGVuZXJzLiBVc2UgaW5pdCgpIHRvIHJlc3RhcnQgdGhlIFRpY2tlci5cblx0ICogQG1ldGhvZCByZXNldFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VGlja2VyLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKFRpY2tlci5fcmFmKSB7XG5cdFx0XHR2YXIgZiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5vQ2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cdFx0XHRmJiZmKFRpY2tlci5fdGltZXJJZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNsZWFyVGltZW91dChUaWNrZXIuX3RpbWVySWQpO1xuXHRcdH1cblx0XHRUaWNrZXIucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoXCJ0aWNrXCIpO1xuXHRcdFRpY2tlci5fdGltZXJJZCA9IFRpY2tlci5fdGltZXMgPSBUaWNrZXIuX3RpY2tUaW1lcyA9IG51bGw7XG5cdFx0VGlja2VyLl9zdGFydFRpbWUgPSBUaWNrZXIuX2xhc3RUaW1lID0gVGlja2VyLl90aWNrcyA9IFRpY2tlci5fcGF1c2VkVGltZSA9IDA7XG5cdFx0VGlja2VyLl9pbml0ZWQgPSBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYXZlcmFnZSB0aW1lIHNwZW50IHdpdGhpbiBhIHRpY2suIFRoaXMgY2FuIHZhcnkgc2lnbmlmaWNhbnRseSBmcm9tIHRoZSB2YWx1ZSBwcm92aWRlZCBieSBnZXRNZWFzdXJlZEZQU1xuXHQgKiBiZWNhdXNlIGl0IG9ubHkgbWVhc3VyZXMgdGhlIHRpbWUgc3BlbnQgd2l0aGluIHRoZSB0aWNrIGV4ZWN1dGlvbiBzdGFjay4gXG5cdCAqIFxuXHQgKiBFeGFtcGxlIDE6IFdpdGggYSB0YXJnZXQgRlBTIG9mIDIwLCBnZXRNZWFzdXJlZEZQUygpIHJldHVybnMgMjBmcHMsIHdoaWNoIGluZGljYXRlcyBhbiBhdmVyYWdlIG9mIDUwbXMgYmV0d2VlbiBcblx0ICogdGhlIGVuZCBvZiBvbmUgdGljayBhbmQgdGhlIGVuZCBvZiB0aGUgbmV4dC4gSG93ZXZlciwgZ2V0TWVhc3VyZWRUaWNrVGltZSgpIHJldHVybnMgMTVtcy4gVGhpcyBpbmRpY2F0ZXMgdGhhdCBcblx0ICogdGhlcmUgbWF5IGJlIHVwIHRvIDM1bXMgb2YgXCJpZGxlXCIgdGltZSBiZXR3ZWVuIHRoZSBlbmQgb2Ygb25lIHRpY2sgYW5kIHRoZSBzdGFydCBvZiB0aGUgbmV4dC5cblx0ICpcblx0ICogRXhhbXBsZSAyOiBXaXRoIGEgdGFyZ2V0IEZQUyBvZiAzMCwge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2ZyYW1lcmF0ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSByZXR1cm5zIDEwZnBzLCB3aGljaFxuXHQgKiBpbmRpY2F0ZXMgYW4gYXZlcmFnZSBvZiAxMDBtcyBiZXR3ZWVuIHRoZSBlbmQgb2Ygb25lIHRpY2sgYW5kIHRoZSBlbmQgb2YgdGhlIG5leHQuIEhvd2V2ZXIsIHt7I2Nyb3NzTGluayBcIlRpY2tlci9nZXRNZWFzdXJlZFRpY2tUaW1lXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHJldHVybnMgMjBtcy4gVGhpcyB3b3VsZCBpbmRpY2F0ZSB0aGF0IHNvbWV0aGluZyBvdGhlciB0aGFuIHRoZSB0aWNrIGlzIHVzaW5nIH44MG1zIChhbm90aGVyIHNjcmlwdCwgRE9NXG5cdCAqIHJlbmRlcmluZywgZXRjKS5cblx0ICogQG1ldGhvZCBnZXRNZWFzdXJlZFRpY2tUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0aWNrc10gVGhlIG51bWJlciBvZiBwcmV2aW91cyB0aWNrcyBvdmVyIHdoaWNoIHRvIG1lYXN1cmUgdGhlIGF2ZXJhZ2UgdGltZSBzcGVudCBpbiBhIHRpY2suXG5cdCAqIERlZmF1bHRzIHRvIHRoZSBudW1iZXIgb2YgdGlja3MgcGVyIHNlY29uZC4gVG8gZ2V0IG9ubHkgdGhlIGxhc3QgdGljaydzIHRpbWUsIHBhc3MgaW4gMS5cblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgYXZlcmFnZSB0aW1lIHNwZW50IGluIGEgdGljayBpbiBtaWxsaXNlY29uZHMuXG5cdCAqKi9cblx0VGlja2VyLmdldE1lYXN1cmVkVGlja1RpbWUgPSBmdW5jdGlvbih0aWNrcykge1xuXHRcdHZhciB0dGw9MCwgdGltZXM9VGlja2VyLl90aWNrVGltZXM7XG5cdFx0aWYgKCF0aW1lcyB8fCB0aW1lcy5sZW5ndGggPCAxKSB7IHJldHVybiAtMTsgfVxuXG5cdFx0Ly8gYnkgZGVmYXVsdCwgY2FsY3VsYXRlIGF2ZXJhZ2UgZm9yIHRoZSBwYXN0IH4xIHNlY29uZDpcblx0XHR0aWNrcyA9IE1hdGgubWluKHRpbWVzLmxlbmd0aCwgdGlja3N8fChUaWNrZXIuX2dldEZQUygpfDApKTtcblx0XHRmb3IgKHZhciBpPTA7IGk8dGlja3M7IGkrKykgeyB0dGwgKz0gdGltZXNbaV07IH1cblx0XHRyZXR1cm4gdHRsL3RpY2tzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhY3R1YWwgZnJhbWVzIC8gdGlja3MgcGVyIHNlY29uZC5cblx0ICogQG1ldGhvZCBnZXRNZWFzdXJlZEZQU1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGlja3NdIFRoZSBudW1iZXIgb2YgcHJldmlvdXMgdGlja3Mgb3ZlciB3aGljaCB0byBtZWFzdXJlIHRoZSBhY3R1YWwgZnJhbWVzIC8gdGlja3MgcGVyIHNlY29uZC5cblx0ICogRGVmYXVsdHMgdG8gdGhlIG51bWJlciBvZiB0aWNrcyBwZXIgc2Vjb25kLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBhY3R1YWwgZnJhbWVzIC8gdGlja3MgcGVyIHNlY29uZC4gRGVwZW5kaW5nIG9uIHBlcmZvcm1hbmNlLCB0aGlzIG1heSBkaWZmZXJcblx0ICogZnJvbSB0aGUgdGFyZ2V0IGZyYW1lcyBwZXIgc2Vjb25kLlxuXHQgKiovXG5cdFRpY2tlci5nZXRNZWFzdXJlZEZQUyA9IGZ1bmN0aW9uKHRpY2tzKSB7XG5cdFx0dmFyIHRpbWVzID0gVGlja2VyLl90aW1lcztcblx0XHRpZiAoIXRpbWVzIHx8IHRpbWVzLmxlbmd0aCA8IDIpIHsgcmV0dXJuIC0xOyB9XG5cblx0XHQvLyBieSBkZWZhdWx0LCBjYWxjdWxhdGUgZnBzIGZvciB0aGUgcGFzdCB+MSBzZWNvbmQ6XG5cdFx0dGlja3MgPSBNYXRoLm1pbih0aW1lcy5sZW5ndGgtMSwgdGlja3N8fChUaWNrZXIuX2dldEZQUygpfDApKTtcblx0XHRyZXR1cm4gMTAwMC8oKHRpbWVzWzBdLXRpbWVzW3RpY2tzXSkvdGlja3MpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlIFRpY2tlciB3YXMgaW5pdGlhbGl6ZWQgdmlhIHt7I2Nyb3NzTGluayBcIlRpY2tlci9pbml0XCJ9fS5cblx0ICogUmV0dXJucyAtMSBpZiBUaWNrZXIgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkLiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIHVzZVxuXHQgKiB0aGlzIGluIGEgdGltZSBzeW5jaHJvbml6ZWQgYW5pbWF0aW9uIHRvIGRldGVybWluZSB0aGUgZXhhY3QgYW1vdW50IG9mIHRpbWUgdGhhdCBoYXMgZWxhcHNlZC5cblx0ICogQG1ldGhvZCBnZXRUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtCb29sZWFufSBbcnVuVGltZT1mYWxzZV0gSWYgdHJ1ZSBvbmx5IHRpbWUgZWxhcHNlZCB3aGlsZSBUaWNrZXIgd2FzIG5vdCBwYXVzZWQgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogSWYgZmFsc2UsIHRoZSB2YWx1ZSByZXR1cm5lZCB3aWxsIGJlIHRvdGFsIHRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgZmlyc3QgdGljayBldmVudCBsaXN0ZW5lciB3YXMgYWRkZWQuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZSBUaWNrZXIgd2FzIGluaXRpYWxpemVkIG9yIC0xLlxuXHQgKiovXG5cdFRpY2tlci5nZXRUaW1lID0gZnVuY3Rpb24ocnVuVGltZSkge1xuXHRcdHJldHVybiBUaWNrZXIuX3N0YXJ0VGltZSA/IFRpY2tlci5fZ2V0VGltZSgpIC0gKHJ1blRpbWUgPyBUaWNrZXIuX3BhdXNlZFRpbWUgOiAwKSA6IC0xO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTaW1pbGFyIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvZ2V0VGltZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QsIGJ1dCByZXR1cm5zIHRoZSB0aW1lIG9uIHRoZSBtb3N0IHJlY2VudCB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBvYmplY3QuXG5cdCAqIEBtZXRob2QgZ2V0RXZlbnRUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHJ1blRpbWUge0Jvb2xlYW59IFtydW5UaW1lPWZhbHNlXSBJZiB0cnVlLCB0aGUgcnVuVGltZSBwcm9wZXJ0eSB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQgb2YgdGltZS5cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHRpbWUgb3IgcnVuVGltZSBwcm9wZXJ0eSBmcm9tIHRoZSBtb3N0IHJlY2VudCB0aWNrIGV2ZW50IG9yIC0xLlxuXHQgKi9cblx0VGlja2VyLmdldEV2ZW50VGltZSA9IGZ1bmN0aW9uKHJ1blRpbWUpIHtcblx0XHRyZXR1cm4gVGlja2VyLl9zdGFydFRpbWUgPyAoVGlja2VyLl9sYXN0VGltZSB8fCBUaWNrZXIuX3N0YXJ0VGltZSkgLSAocnVuVGltZSA/IFRpY2tlci5fcGF1c2VkVGltZSA6IDApIDogLTE7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRpY2tzIHRoYXQgaGF2ZSBiZWVuIGJyb2FkY2FzdCBieSBUaWNrZXIuXG5cdCAqIEBtZXRob2QgZ2V0VGlja3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHBhdXNlYWJsZSBJbmRpY2F0ZXMgd2hldGhlciB0byBpbmNsdWRlIHRpY2tzIHRoYXQgd291bGQgaGF2ZSBiZWVuIGJyb2FkY2FzdFxuXHQgKiB3aGlsZSBUaWNrZXIgd2FzIHBhdXNlZC4gSWYgdHJ1ZSBvbmx5IHRpY2sgZXZlbnRzIGJyb2FkY2FzdCB3aGlsZSBUaWNrZXIgaXMgbm90IHBhdXNlZCB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBJZiBmYWxzZSwgdGljayBldmVudHMgdGhhdCB3b3VsZCBoYXZlIGJlZW4gYnJvYWRjYXN0IHdoaWxlIFRpY2tlciB3YXMgcGF1c2VkIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHJldHVyblxuXHQgKiB2YWx1ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgZmFsc2UuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gb2YgdGlja3MgdGhhdCBoYXZlIGJlZW4gYnJvYWRjYXN0LlxuXHQgKiovXG5cdFRpY2tlci5nZXRUaWNrcyA9IGZ1bmN0aW9uKHBhdXNlYWJsZSkge1xuXHRcdHJldHVybiAgVGlja2VyLl90aWNrcyAtIChwYXVzZWFibGUgPyBUaWNrZXIuX3BhdXNlZFRpY2tzIDogMCk7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBzdGF0aWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZVN5bmNoXG5cdCAqIEBzdGF0aWNcblx0ICogQHByaXZhdGVcblx0ICoqL1xuXHRUaWNrZXIuX2hhbmRsZVN5bmNoID0gZnVuY3Rpb24oKSB7XG5cdFx0VGlja2VyLl90aW1lcklkID0gbnVsbDtcblx0XHRUaWNrZXIuX3NldHVwVGljaygpO1xuXG5cdFx0Ly8gcnVuIGlmIGVub3VnaCB0aW1lIGhhcyBlbGFwc2VkLCB3aXRoIGEgbGl0dGxlIGJpdCBvZiBmbGV4aWJpbGl0eSB0byBiZSBlYXJseTpcblx0XHRpZiAoVGlja2VyLl9nZXRUaW1lKCkgLSBUaWNrZXIuX2xhc3RUaW1lID49IChUaWNrZXIuX2ludGVydmFsLTEpKjAuOTcpIHtcblx0XHRcdFRpY2tlci5fdGljaygpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlUkFGXG5cdCAqIEBzdGF0aWNcblx0ICogQHByaXZhdGVcblx0ICoqL1xuXHRUaWNrZXIuX2hhbmRsZVJBRiA9IGZ1bmN0aW9uKCkge1xuXHRcdFRpY2tlci5fdGltZXJJZCA9IG51bGw7XG5cdFx0VGlja2VyLl9zZXR1cFRpY2soKTtcblx0XHRUaWNrZXIuX3RpY2soKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlVGltZW91dFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcml2YXRlXG5cdCAqKi9cblx0VGlja2VyLl9oYW5kbGVUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0VGlja2VyLl90aW1lcklkID0gbnVsbDtcblx0XHRUaWNrZXIuX3NldHVwVGljaygpO1xuXHRcdFRpY2tlci5fdGljaygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9zZXR1cFRpY2tcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJpdmF0ZVxuXHQgKiovXG5cdFRpY2tlci5fc2V0dXBUaWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKFRpY2tlci5fdGltZXJJZCAhPSBudWxsKSB7IHJldHVybjsgfSAvLyBhdm9pZCBkdXBsaWNhdGVzXG5cblx0XHR2YXIgbW9kZSA9IFRpY2tlci50aW1pbmdNb2RlO1xuXHRcdGlmIChtb2RlID09IFRpY2tlci5SQUZfU1lOQ0hFRCB8fCBtb2RlID09IFRpY2tlci5SQUYpIHtcblx0XHRcdHZhciBmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXHRcdFx0aWYgKGYpIHtcblx0XHRcdFx0VGlja2VyLl90aW1lcklkID0gZihtb2RlID09IFRpY2tlci5SQUYgPyBUaWNrZXIuX2hhbmRsZVJBRiA6IFRpY2tlci5faGFuZGxlU3luY2gpO1xuXHRcdFx0XHRUaWNrZXIuX3JhZiA9IHRydWU7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdFx0VGlja2VyLl9yYWYgPSBmYWxzZTtcblx0XHRUaWNrZXIuX3RpbWVySWQgPSBzZXRUaW1lb3V0KFRpY2tlci5faGFuZGxlVGltZW91dCwgVGlja2VyLl9pbnRlcnZhbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3RpY2tcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJpdmF0ZVxuXHQgKiovXG5cdFRpY2tlci5fdGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXVzZWQgPSBUaWNrZXIucGF1c2VkO1xuXHRcdHZhciB0aW1lID0gVGlja2VyLl9nZXRUaW1lKCk7XG5cdFx0dmFyIGVsYXBzZWRUaW1lID0gdGltZS1UaWNrZXIuX2xhc3RUaW1lO1xuXHRcdFRpY2tlci5fbGFzdFRpbWUgPSB0aW1lO1xuXHRcdFRpY2tlci5fdGlja3MrKztcblx0XHRcblx0XHRpZiAocGF1c2VkKSB7XG5cdFx0XHRUaWNrZXIuX3BhdXNlZFRpY2tzKys7XG5cdFx0XHRUaWNrZXIuX3BhdXNlZFRpbWUgKz0gZWxhcHNlZFRpbWU7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChUaWNrZXIuaGFzRXZlbnRMaXN0ZW5lcihcInRpY2tcIikpIHtcblx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcInRpY2tcIik7XG5cdFx0XHR2YXIgbWF4RGVsdGEgPSBUaWNrZXIubWF4RGVsdGE7XG5cdFx0XHRldmVudC5kZWx0YSA9IChtYXhEZWx0YSAmJiBlbGFwc2VkVGltZSA+IG1heERlbHRhKSA/IG1heERlbHRhIDogZWxhcHNlZFRpbWU7XG5cdFx0XHRldmVudC5wYXVzZWQgPSBwYXVzZWQ7XG5cdFx0XHRldmVudC50aW1lID0gdGltZTtcblx0XHRcdGV2ZW50LnJ1blRpbWUgPSB0aW1lLVRpY2tlci5fcGF1c2VkVGltZTtcblx0XHRcdFRpY2tlci5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0XHR9XG5cdFx0XG5cdFx0VGlja2VyLl90aWNrVGltZXMudW5zaGlmdChUaWNrZXIuX2dldFRpbWUoKS10aW1lKTtcblx0XHR3aGlsZSAoVGlja2VyLl90aWNrVGltZXMubGVuZ3RoID4gMTAwKSB7IFRpY2tlci5fdGlja1RpbWVzLnBvcCgpOyB9XG5cblx0XHRUaWNrZXIuX3RpbWVzLnVuc2hpZnQodGltZSk7XG5cdFx0d2hpbGUgKFRpY2tlci5fdGltZXMubGVuZ3RoID4gMTAwKSB7IFRpY2tlci5fdGltZXMucG9wKCk7IH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0VGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcml2YXRlXG5cdCAqKi9cblx0dmFyIHc9d2luZG93LCBub3c9dy5wZXJmb3JtYW5jZS5ub3cgfHwgdy5wZXJmb3JtYW5jZS5tb3pOb3cgfHwgdy5wZXJmb3JtYW5jZS5tc05vdyB8fCB3LnBlcmZvcm1hbmNlLm9Ob3cgfHwgdy5wZXJmb3JtYW5jZS53ZWJraXROb3c7XG5cdFRpY2tlci5fZ2V0VGltZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAoKG5vdyYmbm93LmNhbGwody5wZXJmb3JtYW5jZSkpfHwobmV3IERhdGUoKS5nZXRUaW1lKCkpKSAtIFRpY2tlci5fc3RhcnRUaW1lO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuVGlja2VyID0gVGlja2VyO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEFic3RyYWN0VHdlZW4uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbndpbmRvdy5jcmVhdGVqcyA9IHdpbmRvdy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEJhc2UgY2xhc3MgdGhhdCBib3RoIHt7I2Nyb3NzTGluayBcIlR3ZWVuXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZVwifX17ey9jcm9zc0xpbmt9fSBleHRlbmQuIFNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuXHQgKiBAY2xhc3MgQWJzdHJhY3RUd2VlblxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzXSBUaGUgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIHRvIGFwcGx5IHRvIHRoaXMgaW5zdGFuY2UgKGV4LiBge2xvb3A6LTEsIHBhdXNlZDp0cnVlfWApLlxuXHQgKiBTdXBwb3J0ZWQgcHJvcHMgYXJlIGxpc3RlZCBiZWxvdy4gVGhlc2UgcHJvcHMgYXJlIHNldCBvbiB0aGUgY29ycmVzcG9uZGluZyBpbnN0YW5jZSBwcm9wZXJ0aWVzIGV4Y2VwdCB3aGVyZVxuXHQgKiBzcGVjaWZpZWQuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLnVzZVRpY2tzPWZhbHNlXSAgU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFR3ZWVuL3VzZVRpY2tzOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5pZ25vcmVHbG9iYWxQYXVzZT1mYWxzZV0gU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFR3ZWVuL2lnbm9yZUdsb2JhbFBhdXNlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAcGFyYW0ge251bWJlcnxib29sZWFufSBbcHJvcHMubG9vcD0wXSBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0VHdlZW4vbG9vcDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQHBhcmFtIHtib29sZWFufSBbcHJvcHMucmV2ZXJzZWQ9ZmFsc2VdIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RUd2Vlbi9yZXZlcnNlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQHBhcmFtIHtib29sZWFufSBbcHJvcHMuYm91bmNlPWZhbHNlXSBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0VHdlZW4vYm91bmNlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3Byb3BzLnRpbWVTY2FsZT0xXSBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0VHdlZW4vdGltZVNjYWxlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcHMub25DaGFuZ2VdIEFkZHMgdGhlIHNwZWNpZmllZCBmdW5jdGlvbiBhcyBhIGxpc3RlbmVyIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFR3ZWVuL2NoYW5nZTpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcHMub25Db21wbGV0ZV0gQWRkcyB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIGFzIGEgbGlzdGVuZXIgdG8gdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0VHdlZW4vY29tcGxldGU6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnRcblx0ICogQGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gQWJzdHJhY3RUd2Vlbihwcm9wcykge1xuXHRcdHRoaXMuRXZlbnREaXNwYXRjaGVyX2NvbnN0cnVjdG9yKCk7XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIENhdXNlcyB0aGlzIHR3ZWVuIHRvIGNvbnRpbnVlIHBsYXlpbmcgd2hlbiBhIGdsb2JhbCBwYXVzZSBpcyBhY3RpdmUuIEZvciBleGFtcGxlLCBpZiBUd2VlbkpTIGlzIHVzaW5nIHt7I2Nyb3NzTGluayBcIlRpY2tlclwifX17ey9jcm9zc0xpbmt9fSxcblx0XHQgKiB0aGVuIHNldHRpbmcgdGhpcyB0byBmYWxzZSAodGhlIGRlZmF1bHQpIHdpbGwgY2F1c2UgdGhpcyB0d2VlbiB0byBiZSBwYXVzZWQgd2hlbiBgVGlja2VyLnBhdXNlZGAgaXMgc2V0IHRvXG5cdFx0ICogYHRydWVgLiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIlR3ZWVuL3RpY2tcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGZvciBtb3JlIGluZm8uIENhbiBiZSBzZXQgdmlhIHRoZSBgcHJvcHNgXG5cdFx0ICogcGFyYW1ldGVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBpZ25vcmVHbG9iYWxQYXVzZVxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMuaWdub3JlR2xvYmFsUGF1c2UgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHRoZSBudW1iZXIgb2YgdGltZXMgdG8gbG9vcC4gSWYgc2V0IHRvIC0xLCB0aGUgdHdlZW4gd2lsbCBsb29wIGNvbnRpbnVvdXNseS5cblx0XHQgKlxuXHRcdCAqIE5vdGUgdGhhdCBhIHR3ZWVuIG11c3QgbG9vcCBhdCBfbGVhc3RfIG9uY2UgdG8gc2VlIGl0IHBsYXkgaW4gYm90aCBkaXJlY3Rpb25zIHdoZW4gYHt7I2Nyb3NzTGluayBcIkFic3RyYWN0VHdlZW4vYm91bmNlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319YFxuXHRcdCAqIGlzIHNldCB0byBgdHJ1ZWAuXG5cdFx0ICogQHByb3BlcnR5IGxvb3Bcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmxvb3AgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBVc2VzIHRpY2tzIGZvciBhbGwgZHVyYXRpb25zIGluc3RlYWQgb2YgbWlsbGlzZWNvbmRzLiBUaGlzIGFsc28gY2hhbmdlcyB0aGUgYmVoYXZpb3VyIG9mIHNvbWUgYWN0aW9ucyAoc3VjaCBhcyBgY2FsbGApLlxuXHRcdCAqIENoYW5naW5nIHRoaXMgdmFsdWUgb24gYSBydW5uaW5nIHR3ZWVuIGNvdWxkIGhhdmUgdW5leHBlY3RlZCByZXN1bHRzLlxuXHRcdCAqIEBwcm9wZXJ0eSB1c2VUaWNrc1xuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy51c2VUaWNrcyA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENhdXNlcyB0aGUgdHdlZW4gdG8gcGxheSBpbiByZXZlcnNlLlxuXHRcdCAqIEBwcm9wZXJ0eSByZXZlcnNlZFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5yZXZlcnNlZCA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENhdXNlcyB0aGUgdHdlZW4gdG8gcmV2ZXJzZSBkaXJlY3Rpb24gYXQgdGhlIGVuZCBvZiBlYWNoIGxvb3AuIEVhY2ggc2luZ2xlLWRpcmVjdGlvbiBwbGF5LXRocm91Z2ggb2YgdGhlXG5cdFx0ICogdHdlZW4gY291bnRzIGFzIGEgc2luZ2xlIGJvdW5jZS4gRm9yIGV4YW1wbGUsIHRvIHBsYXkgYSB0d2VlbiBvbmNlIGZvcndhcmQsIGFuZCBvbmNlIGJhY2ssIHNldCB0aGVcblx0XHQgKiBge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RUd2Vlbi9sb29wOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319YCB0byBgMWAuXG5cdFx0ICogQHByb3BlcnR5IGJvdW5jZVxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5ib3VuY2UgPSBmYWxzZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBDaGFuZ2VzIHRoZSByYXRlIGF0IHdoaWNoIHRoZSB0d2VlbiBhZHZhbmNlcy4gRm9yIGV4YW1wbGUsIGEgYHRpbWVTY2FsZWAgdmFsdWUgb2YgYDJgIHdpbGwgZG91YmxlIHRoZVxuXHRcdCAqIHBsYXliYWNrIHNwZWVkLCBhIHZhbHVlIG9mIGAwLjVgIHdvdWxkIGhhbHZlIGl0LlxuXHRcdCAqIEBwcm9wZXJ0eSB0aW1lU2NhbGVcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLnRpbWVTY2FsZSA9IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB0aGUgZHVyYXRpb24gb2YgdGhpcyB0d2VlbiBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgdHJ1ZSksIGlycmVzcGVjdGl2ZSBvZiBgbG9vcHNgLlxuXHRcdCAqIFRoaXMgdmFsdWUgaXMgYXV0b21hdGljYWxseSB1cGRhdGVkIGFzIHlvdSBtb2RpZnkgdGhlIHR3ZWVuLiBDaGFuZ2luZyBpdCBkaXJlY3RseSBjb3VsZCByZXN1bHQgaW4gdW5leHBlY3RlZFxuXHRcdCAqIGJlaGF2aW91ci5cblx0XHQgKiBAcHJvcGVydHkgZHVyYXRpb25cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLmR1cmF0aW9uID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgbm9ybWFsaXplZCBwb3NpdGlvbiBvZiB0aGUgdHdlZW4uIFRoaXMgd2lsbCBhbHdheXMgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIGBkdXJhdGlvbmAuXG5cdFx0ICogQ2hhbmdpbmcgdGhpcyBwcm9wZXJ0eSBkaXJlY3RseSB3aWxsIGhhdmUgdW5leHBlY3RlZCByZXN1bHRzLCB1c2Uge3sjY3Jvc3NMaW5rIFwiVHdlZW4vc2V0UG9zaXRpb25cIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IHBvc2l0aW9uXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5wb3NpdGlvbiA9IDA7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHJhdyB0d2VlbiBwb3NpdGlvbi4gVGhpcyB2YWx1ZSB3aWxsIGJlIGJldHdlZW4gYDBgIGFuZCBgbG9vcHMgKiBkdXJhdGlvbmAgd2hpbGUgdGhlIHR3ZWVuIGlzIGFjdGl2ZSwgb3IgLTEgYmVmb3JlIGl0IGFjdGl2YXRlcy5cblx0XHQgKiBAcHJvcGVydHkgcmF3UG9zaXRpb25cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IC0xXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5yYXdQb3NpdGlvbiA9IC0xO1xuXHRcdFxuXHRcdFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9wYXVzZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9wYXVzZWQgPSB0cnVlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbmV4dFxuXHRcdCAqIEB0eXBlIHtUd2Vlbn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX25leHQgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfcHJldlxuXHRcdCAqIEB0eXBlIHtUd2Vlbn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3ByZXYgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfcGFyZW50XG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3BhcmVudCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2xhYmVsc1xuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5fbGFiZWxzID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbGFiZWxMaXN0XG5cdFx0ICogQHR5cGUgQXJyYXlbT2JqZWN0XVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5fbGFiZWxMaXN0ID0gbnVsbDtcblxuXHRcdGlmIChwcm9wcykge1xuXHRcdFx0dGhpcy51c2VUaWNrcyA9ICEhcHJvcHMudXNlVGlja3M7XG5cdFx0XHR0aGlzLmlnbm9yZUdsb2JhbFBhdXNlID0gISFwcm9wcy5pZ25vcmVHbG9iYWxQYXVzZTtcblx0XHRcdHRoaXMubG9vcCA9IHByb3BzLmxvb3AgPT09IHRydWUgPyAtMSA6IChwcm9wcy5sb29wfHwwKTtcblx0XHRcdHRoaXMucmV2ZXJzZWQgPSAhIXByb3BzLnJldmVyc2VkO1xuXHRcdFx0dGhpcy5ib3VuY2UgPSAhIXByb3BzLmJvdW5jZTtcblx0XHRcdHRoaXMudGltZVNjYWxlID0gcHJvcHMudGltZVNjYWxlfHwxO1xuXHRcdFx0cHJvcHMub25DaGFuZ2UgJiYgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHByb3BzLm9uQ2hhbmdlKTtcblx0XHRcdHByb3BzLm9uQ29tcGxldGUgJiYgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwiY29tcGxldGVcIiwgcHJvcHMub25Db21wbGV0ZSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIHdoaWxlIGBwb3NpdGlvbmAgaXMgc2hhcmVkLCBpdCBuZWVkcyB0byBoYXBwZW4gYWZ0ZXIgQUxMIHByb3BzIGFyZSBzZXQsIHNvIGl0J3MgaGFuZGxlZCBpbiBfaW5pdCgpXG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQWJzdHJhY3RUd2VlbiwgY3JlYXRlanMuRXZlbnREaXNwYXRjaGVyKTtcblxuLy8gZXZlbnRzOlxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuZXZlciB0aGUgdHdlZW4ncyBwb3NpdGlvbiBjaGFuZ2VzLiBJdCBvY2N1cnMgYWZ0ZXIgYWxsIHR3ZWVuZWQgcHJvcGVydGllcyBhcmUgdXBkYXRlZCBhbmQgYWN0aW9uc1xuXHQgKiBhcmUgZXhlY3V0ZWQuXG5cdCAqIEBldmVudCBjaGFuZ2Vcblx0ICoqL1xuXHQgXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHR3ZWVuIHJlYWNoZXMgaXRzIGVuZCBhbmQgaGFzIHBhdXNlZCBpdHNlbGYuIFRoaXMgZG9lcyBub3QgZmlyZSB1bnRpbCBhbGwgbG9vcHMgYXJlIGNvbXBsZXRlO1xuXHQgKiB0d2VlbnMgdGhhdCBsb29wIGNvbnRpbnVvdXNseSB3aWxsIG5ldmVyIGZpcmUgYSBjb21wbGV0ZSBldmVudC5cblx0ICogQGV2ZW50IGNvbXBsZXRlXG5cdCAqKi9cblx0XG4vLyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHRcblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RUd2Vlbi9wYXVzZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBfc2V0UGF1c2VkXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ZhbHVlPXRydWVdIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0d2VlbiBzaG91bGQgYmUgcGF1c2VkIChgdHJ1ZWApIG9yIHBsYXllZCAoYGZhbHNlYCkuXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0VHdlZW59IFRoaXMgdHdlZW4gaW5zdGFuY2UgKGZvciBjaGFpbmluZyBjYWxscylcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRwLl9zZXRQYXVzZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGNyZWF0ZWpzLlR3ZWVuLl9yZWdpc3Rlcih0aGlzLCB2YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdHAuc2V0UGF1c2VkID0gY3JlYXRlanMuZGVwcmVjYXRlKHAuX3NldFBhdXNlZCwgXCJBYnN0cmFjdFR3ZWVuLnNldFBhdXNlZFwiKTtcblx0XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0VHdlZW4vcGF1c2VkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgX2dldFBhdXNlZFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9nZXRQYXVzZWQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF1c2VkO1xuXHR9O1xuXHRwLmdldFBhdXNlZCA9IGNyZWF0ZWpzLmRlcHJlY2F0ZShwLl9nZXRQYXVzZWQsIFwiQWJzdGFjdFR3ZWVuLmdldFBhdXNlZFwiKTtcblx0XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0VHdlZW4vY3VycmVudExhYmVsOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgX2dldEN1cnJlbnRMYWJlbFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgbGFiZWwgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBsYWJlbFxuXHQgKiovXG5cdHAuX2dldEN1cnJlbnRMYWJlbCA9IGZ1bmN0aW9uKHBvcykge1xuXHRcdHZhciBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuXHRcdGlmIChwb3MgPT0gbnVsbCkgeyBwb3MgPSB0aGlzLnBvc2l0aW9uOyB9XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsYWJlbHMubGVuZ3RoOyBpPGw7IGkrKykgeyBpZiAocG9zIDwgbGFiZWxzW2ldLnBvc2l0aW9uKSB7IGJyZWFrOyB9IH1cblx0XHRyZXR1cm4gKGk9PT0wKSA/IG51bGwgOiBsYWJlbHNbaS0xXS5sYWJlbDtcblx0fTtcblx0cC5nZXRDdXJyZW50TGFiZWwgPSBjcmVhdGVqcy5kZXByZWNhdGUocC5fZ2V0Q3VycmVudExhYmVsLCBcIkFic3RyYWN0VHdlZW4uZ2V0Q3VycmVudExhYmVsXCIpO1xuXHRcblx0LyoqXG5cdCAqIFBhdXNlcyBvciB1bnBhdXNlcyB0aGUgdHdlZW4uIEEgcGF1c2VkIHR3ZWVuIGlzIHJlbW92ZWQgZnJvbSB0aGUgZ2xvYmFsIHJlZ2lzdHJ5IGFuZCBpcyBlbGlnaWJsZSBmb3IgZ2FyYmFnZVxuXHQgKiBjb2xsZWN0aW9uIGlmIG5vIG90aGVyIHJlZmVyZW5jZXMgdG8gaXQgZXhpc3QuXG5cdCAqIEBwcm9wZXJ0eSBwYXVzZWRcblx0ICogQHR5cGUgQm9vbGVhblxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHQgXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBsYWJlbCBvbiBvciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGN1cnJlbnQgcG9zaXRpb24uIEZvciBleGFtcGxlLCBnaXZlbiBhIHR3ZWVuIHdpdGhcblx0ICogdHdvIGxhYmVscywgXCJmaXJzdFwiIG9uIGZyYW1lIGluZGV4IDQsIGFuZCBcInNlY29uZFwiIG9uIGZyYW1lIDgsIGBjdXJyZW50TGFiZWxgIHdvdWxkIHJldHVybjpcblx0ICogPFVMPlxuXHQgKiBcdFx0PExJPm51bGwgaWYgdGhlIGN1cnJlbnQgcG9zaXRpb24gaXMgMi48L0xJPlxuXHQgKiBcdFx0PExJPlwiZmlyc3RcIiBpZiB0aGUgY3VycmVudCBwb3NpdGlvbiBpcyA0LjwvTEk+XG5cdCAqIFx0XHQ8TEk+XCJmaXJzdFwiIGlmIHRoZSBjdXJyZW50IHBvc2l0aW9uIGlzIDcuPC9MST5cblx0ICogXHRcdDxMST5cInNlY29uZFwiIGlmIHRoZSBjdXJyZW50IHBvc2l0aW9uIGlzIDE1LjwvTEk+XG5cdCAqIDwvVUw+XG5cdCAqIEBwcm9wZXJ0eSBjdXJyZW50TGFiZWxcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdCBcblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cdFx0XHRwYXVzZWQ6IHsgc2V0OiBwLl9zZXRQYXVzZWQsIGdldDogcC5fZ2V0UGF1c2VkIH0sXG5cdFx0XHRjdXJyZW50TGFiZWw6IHsgZ2V0OiBwLl9nZXRDdXJyZW50TGFiZWwgfVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlKSB7fVxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoZSB0d2VlbiBieSBhIHNwZWNpZmllZCBhbW91bnQuXG5cdCAqIEBtZXRob2QgYWR2YW5jZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgVGhlIGFtb3VudCB0byBhZHZhbmNlIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgdXNlVGlja3MgaXMgdHJ1ZSkuIE5lZ2F0aXZlIHZhbHVlcyBhcmUgc3VwcG9ydGVkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2lnbm9yZUFjdGlvbnM9ZmFsc2VdIElmIHRydWUsIGFjdGlvbnMgd2lsbCBub3QgYmUgZXhlY3V0ZWQgZHVlIHRvIHRoaXMgY2hhbmdlIGluIHBvc2l0aW9uLlxuXHQgKi9cblx0cC5hZHZhbmNlID0gZnVuY3Rpb24oZGVsdGEsIGlnbm9yZUFjdGlvbnMpIHtcblx0XHR0aGlzLnNldFBvc2l0aW9uKHRoaXMucmF3UG9zaXRpb24rZGVsdGEqdGhpcy50aW1lU2NhbGUsIGlnbm9yZUFjdGlvbnMpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoZSB0d2VlbiB0byBhIHNwZWNpZmllZCBwb3NpdGlvbi5cblx0ICogQG1ldGhvZCBzZXRQb3NpdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmF3UG9zaXRpb24gVGhlIHJhdyBwb3NpdGlvbiB0byBzZWVrIHRvIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgdXNlVGlja3MgaXMgdHJ1ZSkuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZUFjdGlvbnM9ZmFsc2VdIElmIHRydWUsIGRvIG5vdCBydW4gYW55IGFjdGlvbnMgdGhhdCB3b3VsZCBiZSB0cmlnZ2VyZWQgYnkgdGhpcyBvcGVyYXRpb24uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2p1bXA9ZmFsc2VdIElmIHRydWUsIG9ubHkgYWN0aW9ucyBhdCB0aGUgbmV3IHBvc2l0aW9uIHdpbGwgYmUgcnVuLiBJZiBmYWxzZSwgYWN0aW9ucyBiZXR3ZWVuIHRoZSBvbGQgYW5kIG5ldyBwb3NpdGlvbiBhcmUgcnVuLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFByaW1hcmlseSBmb3IgdXNlIHdpdGggTW92aWVDbGlwLCB0aGlzIGNhbGxiYWNrIGlzIGNhbGxlZCBhZnRlciBwcm9wZXJ0aWVzIGFyZSB1cGRhdGVkLCBidXQgYmVmb3JlIGFjdGlvbnMgYXJlIHJ1bi5cblx0ICovXG5cdHAuc2V0UG9zaXRpb24gPSBmdW5jdGlvbihyYXdQb3NpdGlvbiwgaWdub3JlQWN0aW9ucywganVtcCwgY2FsbGJhY2spIHtcblx0XHR2YXIgZD10aGlzLmR1cmF0aW9uLCBsb29wQ291bnQ9dGhpcy5sb29wLCBwcmV2UmF3UG9zID0gdGhpcy5yYXdQb3NpdGlvbjtcblx0XHR2YXIgbG9vcD0wLCB0PTAsIGVuZD1mYWxzZTtcblx0XHRcblx0XHQvLyBub3JtYWxpemUgcG9zaXRpb246XG5cdFx0aWYgKHJhd1Bvc2l0aW9uIDwgMCkgeyByYXdQb3NpdGlvbiA9IDA7IH1cblx0XHRcblx0XHRpZiAoZCA9PT0gMCkge1xuXHRcdFx0Ly8gZGVhbCB3aXRoIDAgbGVuZ3RoIHR3ZWVucy5cblx0XHRcdGVuZCA9IHRydWU7XG5cdFx0XHRpZiAocHJldlJhd1BvcyAhPT0gLTEpIHsgcmV0dXJuIGVuZDsgfSAvLyB3ZSBjYW4gYXZvaWQgZG9pbmcgYW55dGhpbmcgZWxzZSBpZiB3ZSdyZSBhbHJlYWR5IGF0IDAuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGxvb3AgPSByYXdQb3NpdGlvbi9kfDA7XG5cdFx0XHR0ID0gcmF3UG9zaXRpb24tbG9vcCpkO1xuXHRcdFx0XG5cdFx0XHRlbmQgPSAobG9vcENvdW50ICE9PSAtMSAmJiByYXdQb3NpdGlvbiA+PSBsb29wQ291bnQqZCtkKTtcblx0XHRcdGlmIChlbmQpIHsgcmF3UG9zaXRpb24gPSAodD1kKSoobG9vcD1sb29wQ291bnQpK2Q7IH1cblx0XHRcdGlmIChyYXdQb3NpdGlvbiA9PT0gcHJldlJhd1BvcykgeyByZXR1cm4gZW5kOyB9IC8vIG5vIG5lZWQgdG8gdXBkYXRlXG5cdFx0XHRcblx0XHRcdHZhciByZXYgPSAhdGhpcy5yZXZlcnNlZCAhPT0gISh0aGlzLmJvdW5jZSAmJiBsb29wJTIpOyAvLyBjdXJyZW50IGxvb3AgaXMgcmV2ZXJzZWRcblx0XHRcdGlmIChyZXYpIHsgdCA9IGQtdDsgfVxuXHRcdH1cblx0XHRcblx0XHQvLyBzZXQgdGhpcyBpbiBhZHZhbmNlIGluIGNhc2UgYW4gYWN0aW9uIG1vZGlmaWVzIHBvc2l0aW9uOlxuXHRcdHRoaXMucG9zaXRpb24gPSB0O1xuXHRcdHRoaXMucmF3UG9zaXRpb24gPSByYXdQb3NpdGlvbjtcblx0XHRcblx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbihqdW1wLCBlbmQpO1xuXHRcdGlmIChlbmQpIHsgdGhpcy5wYXVzZWQgPSB0cnVlOyB9XG5cdFx0XG5cdFx0Y2FsbGJhY2smJmNhbGxiYWNrKHRoaXMpO1xuXHRcdFxuXHRcdGlmICghaWdub3JlQWN0aW9ucykgeyB0aGlzLl9ydW5BY3Rpb25zKHByZXZSYXdQb3MsIHJhd1Bvc2l0aW9uLCBqdW1wLCAhanVtcCAmJiBwcmV2UmF3UG9zID09PSAtMSk7IH1cblx0XHRcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJjaGFuZ2VcIik7XG5cdFx0aWYgKGVuZCkgeyB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKTsgfVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGN1bGF0ZXMgYSBub3JtYWxpemVkIHBvc2l0aW9uIGJhc2VkIG9uIGEgcmF3IHBvc2l0aW9uLiBGb3IgZXhhbXBsZSwgZ2l2ZW4gYSB0d2VlbiB3aXRoIGEgZHVyYXRpb24gb2YgMzAwMG1zIHNldCB0byBsb29wOlxuXHQgKiBcdGNvbnNvbGUubG9nKG15VHdlZW4uY2FsY3VsYXRlUG9zaXRpb24oMzcwMCk7IC8vIDcwMFxuXHQgKiBAbWV0aG9kIGNhbGN1bGF0ZVBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYXdQb3NpdGlvbiBBIHJhdyBwb3NpdGlvbi5cblx0ICovXG5cdHAuY2FsY3VsYXRlUG9zaXRpb24gPSBmdW5jdGlvbihyYXdQb3NpdGlvbikge1xuXHRcdC8vIGxhcmdlbHkgZHVwbGljYXRlZCBmcm9tIHNldFBvc2l0aW9uLCBidXQgbmVjZXNzYXJ5IHRvIGF2b2lkIGhhdmluZyB0byBpbnN0YW50aWF0ZSBnZW5lcmljIG9iamVjdHMgdG8gcGFzcyB2YWx1ZXMgKGVuZCwgbG9vcCwgcG9zaXRpb24pIGJhY2suXG5cdFx0dmFyIGQ9dGhpcy5kdXJhdGlvbiwgbG9vcENvdW50PXRoaXMubG9vcCwgbG9vcD0wLCB0PTA7XG5cdFx0XG5cdFx0aWYgKGQ9PT0wKSB7IHJldHVybiAwOyB9XG5cdFx0aWYgKGxvb3BDb3VudCAhPT0gLTEgJiYgcmF3UG9zaXRpb24gPj0gbG9vcENvdW50KmQrZCkgeyB0ID0gZDsgbG9vcCA9IGxvb3BDb3VudCB9IC8vIGVuZFxuXHRcdGVsc2UgaWYgKHJhd1Bvc2l0aW9uIDwgMCkgeyB0ID0gMDsgfVxuXHRcdGVsc2UgeyBsb29wID0gcmF3UG9zaXRpb24vZHwwOyB0ID0gcmF3UG9zaXRpb24tbG9vcCpkOyAgfVxuXHRcdFxuXHRcdHZhciByZXYgPSAhdGhpcy5yZXZlcnNlZCAhPT0gISh0aGlzLmJvdW5jZSAmJiBsb29wJTIpOyAvLyBjdXJyZW50IGxvb3AgaXMgcmV2ZXJzZWRcblx0XHRyZXR1cm4gcmV2ID8gZC10IDogdDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbGlzdCBvZiB0aGUgbGFiZWxzIGRlZmluZWQgb24gdGhpcyB0d2VlbiBzb3J0ZWQgYnkgcG9zaXRpb24uXG5cdCAqIEBtZXRob2QgZ2V0TGFiZWxzXG5cdCAqIEByZXR1cm4ge0FycmF5W09iamVjdF19IEEgc29ydGVkIGFycmF5IG9mIG9iamVjdHMgd2l0aCBsYWJlbCBhbmQgcG9zaXRpb24gcHJvcGVydGllcy5cblx0ICoqL1xuXHRwLmdldExhYmVscyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsaXN0ID0gdGhpcy5fbGFiZWxMaXN0O1xuXHRcdGlmICghbGlzdCkge1xuXHRcdFx0bGlzdCA9IHRoaXMuX2xhYmVsTGlzdCA9IFtdO1xuXHRcdFx0dmFyIGxhYmVscyA9IHRoaXMuX2xhYmVscztcblx0XHRcdGZvciAodmFyIG4gaW4gbGFiZWxzKSB7XG5cdFx0XHRcdGxpc3QucHVzaCh7bGFiZWw6biwgcG9zaXRpb246bGFiZWxzW25dfSk7XG5cdFx0XHR9XG5cdFx0XHRsaXN0LnNvcnQoZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYS5wb3NpdGlvbi0gYi5wb3NpdGlvbjsgfSk7XG5cdFx0fVxuXHRcdHJldHVybiBsaXN0O1xuXHR9O1xuXHRcblxuXHQvKipcblx0ICogRGVmaW5lcyBsYWJlbHMgZm9yIHVzZSB3aXRoIGdvdG9BbmRQbGF5L1N0b3AuIE92ZXJ3cml0ZXMgYW55IHByZXZpb3VzbHkgc2V0IGxhYmVscy5cblx0ICogQG1ldGhvZCBzZXRMYWJlbHNcblx0ICogQHBhcmFtIHtPYmplY3R9IGxhYmVscyBBbiBvYmplY3QgZGVmaW5pbmcgbGFiZWxzIGZvciB1c2luZyB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZS9nb3RvQW5kUGxheVwifX17ey9jcm9zc0xpbmt9fS97eyNjcm9zc0xpbmsgXCJUaW1lbGluZS9nb3RvQW5kU3RvcFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBpbiB0aGUgZm9ybSBge215TGFiZWxOYW1lOnRpbWV9YCB3aGVyZSB0aW1lIGlzIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgYHVzZVRpY2tzYCBpcyBgdHJ1ZWApLlxuXHQgKiovXG5cdHAuc2V0TGFiZWxzID0gZnVuY3Rpb24obGFiZWxzKSB7XG5cdFx0dGhpcy5fbGFiZWxzID0gbGFiZWxzO1xuXHRcdHRoaXMuX2xhYmVsTGlzdCA9IG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBsYWJlbCB0aGF0IGNhbiBiZSB1c2VkIHdpdGgge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX0ve3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvZ290b0FuZFN0b3BcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgYWRkTGFiZWxcblx0ICogQHBhcmFtIHtTdHJpbmd9IGxhYmVsIFRoZSBsYWJlbCBuYW1lLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRoaXMgbGFiZWwgcmVwcmVzZW50cy5cblx0ICoqL1xuXHRwLmFkZExhYmVsID0gZnVuY3Rpb24obGFiZWwsIHBvc2l0aW9uKSB7XG5cdFx0aWYgKCF0aGlzLl9sYWJlbHMpIHsgdGhpcy5fbGFiZWxzID0ge307IH1cblx0XHR0aGlzLl9sYWJlbHNbbGFiZWxdID0gcG9zaXRpb247XG5cdFx0dmFyIGxpc3QgPSB0aGlzLl9sYWJlbExpc3Q7XG5cdFx0aWYgKGxpc3QpIHtcblx0XHRcdGZvciAodmFyIGk9IDAsbD1saXN0Lmxlbmd0aDsgaTxsOyBpKyspIHsgaWYgKHBvc2l0aW9uIDwgbGlzdFtpXS5wb3NpdGlvbikgeyBicmVhazsgfSB9XG5cdFx0XHRsaXN0LnNwbGljZShpLCAwLCB7bGFiZWw6bGFiZWwsIHBvc2l0aW9uOnBvc2l0aW9ufSk7XG5cdFx0fVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFVucGF1c2VzIHRoaXMgdGltZWxpbmUgYW5kIGp1bXBzIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gb3IgbGFiZWwuXG5cdCAqIEBtZXRob2QgZ290b0FuZFBsYXlcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBwb3NpdGlvbk9yTGFiZWwgVGhlIHBvc2l0aW9uIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgYHVzZVRpY2tzYCBpcyBgdHJ1ZWApXG5cdCAqIG9yIGxhYmVsIHRvIGp1bXAgdG8uXG5cdCAqKi9cblx0cC5nb3RvQW5kUGxheSA9IGZ1bmN0aW9uKHBvc2l0aW9uT3JMYWJlbCkge1xuXHRcdHRoaXMucGF1c2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fZ290byhwb3NpdGlvbk9yTGFiZWwpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXVzZXMgdGhpcyB0aW1lbGluZSBhbmQganVtcHMgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBvciBsYWJlbC5cblx0ICogQG1ldGhvZCBnb3RvQW5kU3RvcFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHBvc2l0aW9uT3JMYWJlbCBUaGUgcG9zaXRpb24gaW4gbWlsbGlzZWNvbmRzIChvciB0aWNrcyBpZiBgdXNlVGlja3NgIGlzIGB0cnVlYCkgb3IgbGFiZWxcblx0ICogdG8ganVtcCB0by5cblx0ICoqL1xuXHRwLmdvdG9BbmRTdG9wID0gZnVuY3Rpb24ocG9zaXRpb25PckxhYmVsKSB7XG5cdFx0dGhpcy5wYXVzZWQgPSB0cnVlO1xuXHRcdHRoaXMuX2dvdG8ocG9zaXRpb25PckxhYmVsKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBJZiBhIG51bWVyaWMgcG9zaXRpb24gaXMgcGFzc2VkLCBpdCBpcyByZXR1cm5lZCB1bmNoYW5nZWQuIElmIGEgc3RyaW5nIGlzIHBhc3NlZCwgdGhlIHBvc2l0aW9uIG9mIHRoZVxuXHQgKiBjb3JyZXNwb25kaW5nIGZyYW1lIGxhYmVsIHdpbGwgYmUgcmV0dXJuZWQsIG9yIGBudWxsYCBpZiBhIG1hdGNoaW5nIGxhYmVsIGlzIG5vdCBkZWZpbmVkLlxuXHQgKiBAbWV0aG9kIHJlc29sdmVcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBwb3NpdGlvbk9yTGFiZWwgQSBudW1lcmljIHBvc2l0aW9uIHZhbHVlIG9yIGxhYmVsIHN0cmluZy5cblx0ICoqL1xuXHRwLnJlc29sdmUgPSBmdW5jdGlvbihwb3NpdGlvbk9yTGFiZWwpIHtcblx0XHR2YXIgcG9zID0gTnVtYmVyKHBvc2l0aW9uT3JMYWJlbCk7XG5cdFx0aWYgKGlzTmFOKHBvcykpIHsgcG9zID0gdGhpcy5fbGFiZWxzICYmIHRoaXMuX2xhYmVsc1twb3NpdGlvbk9yTGFiZWxdOyB9XG5cdFx0cmV0dXJuIHBvcztcblx0fTtcblx0XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0Fic3RyYWN0VHdlZW5dXCI7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRocm93KFwiQWJzdHJhY3RUd2VlbiBjYW4gbm90IGJlIGNsb25lZC5cIilcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBTaGFyZWQgbG9naWMgdGhhdCBleGVjdXRlcyBhdCB0aGUgZW5kIG9mIHRoZSBzdWJjbGFzcyBjb25zdHJ1Y3Rvci5cblx0ICogQG1ldGhvZCBfaW5pdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9pbml0ID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRpZiAoIXByb3BzIHx8ICFwcm9wcy5wYXVzZWQpIHsgdGhpcy5wYXVzZWQgPSBmYWxzZTsgfVxuXHRcdGlmIChwcm9wcyYmKHByb3BzLnBvc2l0aW9uIT1udWxsKSkgeyB0aGlzLnNldFBvc2l0aW9uKHByb3BzLnBvc2l0aW9uKTsgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF91cGRhdGVQb3NpdGlvblxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl91cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uKGp1bXAsIGVuZCkge1xuXHRcdC8vIGFic3RyYWN0LlxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2dvdG9cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dvdG8gPSBmdW5jdGlvbihwb3NpdGlvbk9yTGFiZWwpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5yZXNvbHZlKHBvc2l0aW9uT3JMYWJlbCk7XG5cdFx0aWYgKHBvcyAhPSBudWxsKSB7IHRoaXMuc2V0UG9zaXRpb24ocG9zLCBmYWxzZSwgdHJ1ZSk7IH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9ydW5BY3Rpb25zXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3J1bkFjdGlvbnMgPSBmdW5jdGlvbihzdGFydFJhd1BvcywgZW5kUmF3UG9zLCBqdW1wLCBpbmNsdWRlU3RhcnQpIHtcblx0XHQvLyBydW5zIGFjdGlvbnMgYmV0d2VlbiBzdGFydFBvcyAmIGVuZFBvcy4gU2VwYXJhdGVkIHRvIHN1cHBvcnQgYWN0aW9uIGRlZmVycmFsLlxuXHRcdFxuXHRcdC8vY29uc29sZS5sb2codGhpcy5wYXNzaXZlID09PSBmYWxzZSA/IFwiID4gVHdlZW5cIiA6IFwiVGltZWxpbmVcIiwgXCJydW5cIiwgc3RhcnRSYXdQb3MsIGVuZFJhd1BvcywganVtcCwgaW5jbHVkZVN0YXJ0KTtcblx0XHRcblx0XHQvLyBpZiB3ZSBkb24ndCBoYXZlIGFueSBhY3Rpb25zLCBhbmQgd2UncmUgbm90IGEgVGltZWxpbmUsIHRoZW4gcmV0dXJuOlxuXHRcdC8vIFRPRE86IGEgY2xlYW5lciB3YXkgdG8gaGFuZGxlIHRoaXMgd291bGQgYmUgdG8gb3ZlcnJpZGUgdGhpcyBtZXRob2QgaW4gVHdlZW4sIGJ1dCBJJ20gbm90IHN1cmUgaXQncyB3b3J0aCB0aGUgb3ZlcmhlYWQuXG5cdFx0aWYgKCF0aGlzLl9hY3Rpb25IZWFkICYmICF0aGlzLnR3ZWVucykgeyByZXR1cm47IH0gXG5cdFx0XG5cdFx0dmFyIGQ9dGhpcy5kdXJhdGlvbiwgcmV2ZXJzZWQ9dGhpcy5yZXZlcnNlZCwgYm91bmNlPXRoaXMuYm91bmNlLCBsb29wQ291bnQ9dGhpcy5sb29wO1xuXHRcdHZhciBsb29wMCwgbG9vcDEsIHQwLCB0MTtcblx0XHRcblx0XHRpZiAoZCA9PT0gMCkge1xuXHRcdFx0Ly8gZGVhbCB3aXRoIDAgbGVuZ3RoIHR3ZWVuczpcblx0XHRcdGxvb3AwID0gbG9vcDEgPSB0MCA9IHQxID0gMDtcblx0XHRcdHJldmVyc2VkID0gYm91bmNlID0gZmFsc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxvb3AwPXN0YXJ0UmF3UG9zL2R8MDtcblx0XHRcdGxvb3AxPWVuZFJhd1Bvcy9kfDA7XG5cdFx0XHR0MD1zdGFydFJhd1Bvcy1sb29wMCpkO1xuXHRcdFx0dDE9ZW5kUmF3UG9zLWxvb3AxKmQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIGNhdGNoIHBvc2l0aW9ucyB0aGF0IGFyZSBwYXN0IHRoZSBlbmQ6XG5cdFx0aWYgKGxvb3BDb3VudCAhPT0gLTEpIHtcblx0XHRcdGlmIChsb29wMSA+IGxvb3BDb3VudCkgeyB0MT1kOyBsb29wMT1sb29wQ291bnQ7IH1cblx0XHRcdGlmIChsb29wMCA+IGxvb3BDb3VudCkgeyB0MD1kOyBsb29wMD1sb29wQ291bnQ7IH1cblx0XHR9XG5cdFx0XG5cdFx0Ly8gc3BlY2lhbCBjYXNlczpcblx0XHRpZiAoanVtcCkgeyByZXR1cm4gdGhpcy5fcnVuQWN0aW9uc1JhbmdlKHQxLCB0MSwganVtcCwgaW5jbHVkZVN0YXJ0KTsgfSAvLyBqdW1wLlxuXHRcdGVsc2UgaWYgKGxvb3AwID09PSBsb29wMSAmJiB0MCA9PT0gdDEgJiYgIWp1bXAgJiYgIWluY2x1ZGVTdGFydCkgeyByZXR1cm47IH0gLy8gbm8gYWN0aW9ucyBpZiB0aGUgcG9zaXRpb24gaXMgaWRlbnRpY2FsIGFuZCB3ZSBhcmVuJ3QgaW5jbHVkaW5nIHRoZSBzdGFydFxuXHRcdGVsc2UgaWYgKGxvb3AwID09PSAtMSkgeyBsb29wMCA9IHQwID0gMDsgfSAvLyBjb3JyZWN0IHRoZSAtMSB2YWx1ZSBmb3IgZmlyc3QgYWR2YW5jZSwgaW1wb3J0YW50IHdpdGggdXNlVGlja3MuXG5cdFx0XG5cdFx0dmFyIGRpciA9IChzdGFydFJhd1BvcyA8PSBlbmRSYXdQb3MpLCBsb29wID0gbG9vcDA7XG5cdFx0ZG8ge1xuXHRcdFx0dmFyIHJldiA9ICFyZXZlcnNlZCAhPT0gIShib3VuY2UgJiYgbG9vcCAlIDIpO1xuXG5cdFx0XHR2YXIgc3RhcnQgPSAobG9vcCA9PT0gbG9vcDApID8gdDAgOiBkaXIgPyAwIDogZDtcblx0XHRcdHZhciBlbmQgPSAobG9vcCA9PT0gbG9vcDEpID8gdDEgOiBkaXIgPyBkIDogMDtcblx0XHRcdFxuXHRcdFx0aWYgKHJldikge1xuXHRcdFx0XHRzdGFydCA9IGQgLSBzdGFydDtcblx0XHRcdFx0ZW5kID0gZCAtIGVuZDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKGJvdW5jZSAmJiBsb29wICE9PSBsb29wMCAmJiBzdGFydCA9PT0gZW5kKSB7IC8qIGJvdW5jZWQgb250byB0aGUgc2FtZSB0aW1lL2ZyYW1lLCBkb24ndCByZS1leGVjdXRlIGVuZCBhY3Rpb25zICovIH1cblx0XHRcdGVsc2UgaWYgKHRoaXMuX3J1bkFjdGlvbnNSYW5nZShzdGFydCwgZW5kLCBqdW1wLCBpbmNsdWRlU3RhcnQgfHwgKGxvb3AgIT09IGxvb3AwICYmICFib3VuY2UpKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdFx0XHRcblx0XHRcdGluY2x1ZGVTdGFydCA9IGZhbHNlO1xuXHRcdH0gd2hpbGUgKChkaXIgJiYgKytsb29wIDw9IGxvb3AxKSB8fCAoIWRpciAmJiAtLWxvb3AgPj0gbG9vcDEpKTtcblx0fTtcblx0XG5cdHAuX3J1bkFjdGlvbnNSYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBlbmRQb3MsIGp1bXAsIGluY2x1ZGVTdGFydCkge1xuXHRcdC8vIGFic3RyYWN0XG5cdH07XG5cblx0Y3JlYXRlanMuQWJzdHJhY3RUd2VlbiA9IGNyZWF0ZWpzLnByb21vdGUoQWJzdHJhY3RUd2VlbiwgXCJFdmVudERpc3BhdGNoZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVHdlZW4uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbndpbmRvdy5jcmVhdGVqcyA9IHdpbmRvdy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIFR3ZWVucyBwcm9wZXJ0aWVzIGZvciBhIHNpbmdsZSB0YXJnZXQuIE1ldGhvZHMgY2FuIGJlIGNoYWluZWQgdG8gY3JlYXRlIGNvbXBsZXggYW5pbWF0aW9uIHNlcXVlbmNlczpcblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKlx0Y3JlYXRlanMuVHdlZW4uZ2V0KHRhcmdldClcblx0ICpcdFx0LndhaXQoNTAwKVxuXHQgKlx0XHQudG8oe2FscGhhOjAsIHZpc2libGU6ZmFsc2V9LCAxMDAwKVxuXHQgKlx0XHQuY2FsbChoYW5kbGVDb21wbGV0ZSk7XG5cdCAqXG5cdCAqIE11bHRpcGxlIHR3ZWVucyBjYW4gc2hhcmUgYSB0YXJnZXQsIGhvd2V2ZXIgaWYgdGhleSBhZmZlY3QgdGhlIHNhbWUgcHJvcGVydGllcyB0aGVyZSBjb3VsZCBiZSB1bmV4cGVjdGVkXG5cdCAqIGJlaGF2aW91ci4gVG8gc3RvcCBhbGwgdHdlZW5zIG9uIGFuIG9iamVjdCwgdXNlIHt7I2Nyb3NzTGluayBcIlR3ZWVuL3JlbW92ZVR3ZWVuc1wifX17ey9jcm9zc0xpbmt9fSBvciBwYXNzIGBvdmVycmlkZTp0cnVlYFxuXHQgKiBpbiB0aGUgcHJvcHMgYXJndW1lbnQuXG5cdCAqXG5cdCAqIFx0Y3JlYXRlanMuVHdlZW4uZ2V0KHRhcmdldCwge292ZXJyaWRlOnRydWV9KS50byh7eDoxMDB9KTtcblx0ICpcblx0ICogU3Vic2NyaWJlIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9jaGFuZ2U6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgdHdlZW4gcG9zaXRpb24gY2hhbmdlcy5cblx0ICpcblx0ICogXHRjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0LCB7b3ZlcnJpZGU6dHJ1ZX0pLnRvKHt4OjEwMH0pLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlQ2hhbmdlKTtcblx0ICogXHRmdW5jdGlvbiBoYW5kbGVDaGFuZ2UoZXZlbnQpIHtcblx0ICogXHRcdC8vIFRoZSB0d2VlbiBjaGFuZ2VkLlxuXHQgKiBcdH1cblx0ICpcblx0ICogU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9nZXRcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGFsc28uXG5cdCAqIEBjbGFzcyBUd2VlblxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IHRoYXQgd2lsbCBoYXZlIGl0cyBwcm9wZXJ0aWVzIHR3ZWVuZWQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIFRoZSBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgdG8gYXBwbHkgdG8gdGhpcyBpbnN0YW5jZSAoZXguIGB7bG9vcDotMSwgcGF1c2VkOnRydWV9YCkuXG5cdCAqIFN1cHBvcnRlZCBwcm9wcyBhcmUgbGlzdGVkIGJlbG93LiBUaGVzZSBwcm9wcyBhcmUgc2V0IG9uIHRoZSBjb3JyZXNwb25kaW5nIGluc3RhbmNlIHByb3BlcnRpZXMgZXhjZXB0IHdoZXJlXG5cdCAqIHNwZWNpZmllZC5cblx0ICogQHBhcmFtIHtib29sZWFufSBbcHJvcHMudXNlVGlja3M9ZmFsc2VdICBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0VHdlZW4vdXNlVGlja3M6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLmlnbm9yZUdsb2JhbFBhdXNlPWZhbHNlXSBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0VHdlZW4vaWdub3JlR2xvYmFsUGF1c2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfGJvb2xlYW59IFtwcm9wcy5sb29wPTBdIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RUd2Vlbi9sb29wOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5yZXZlcnNlZD1mYWxzZV0gU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFR3ZWVuL3JldmVyc2VkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5ib3VuY2U9ZmFsc2VdIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RUd2Vlbi9ib3VuY2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMudGltZVNjYWxlPTFdIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RUd2Vlbi90aW1lU2NhbGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbcHJvcHMucGx1Z2luRGF0YV0gU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9wbHVnaW5EYXRhOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5wYXVzZWQ9ZmFsc2VdIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RUd2Vlbi9wYXVzZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMucG9zaXRpb249MF0gVGhlIGluaXRpYWwgcG9zaXRpb24gZm9yIHRoaXMgdHdlZW4uIFNlZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFR3ZWVuL3Bvc2l0aW9uOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wcy5vbkNoYW5nZV0gQWRkcyB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIGFzIGEgbGlzdGVuZXIgdG8gdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0VHdlZW4vY2hhbmdlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wcy5vbkNvbXBsZXRlXSBBZGRzIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gYXMgYSBsaXN0ZW5lciB0byB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RUd2Vlbi9jb21wbGV0ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vdmVycmlkZT1mYWxzZV0gUmVtb3ZlcyBhbGwgZXhpc3RpbmcgdHdlZW5zIGZvciB0aGUgdGFyZ2V0IHdoZW4gc2V0IHRvIGB0cnVlYC5cblx0ICogPC9VTD5cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RUd2VlblxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFR3ZWVuKHRhcmdldCwgcHJvcHMpIHtcblx0XHR0aGlzLkFic3RyYWN0VHdlZW5fY29uc3RydWN0b3IocHJvcHMpO1xuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XG5cdFx0LyoqXG5cdFx0ICogQWxsb3dzIHlvdSB0byBzcGVjaWZ5IGRhdGEgdGhhdCB3aWxsIGJlIHVzZWQgYnkgaW5zdGFsbGVkIHBsdWdpbnMuIEVhY2ggcGx1Z2luIHVzZXMgdGhpcyBkaWZmZXJlbnRseSwgYnV0IGluIGdlbmVyYWxcblx0XHQgKiB5b3Ugc3BlY2lmeSBkYXRhIGJ5IGFzc2lnbmluZyBpdCB0byBhIHByb3BlcnR5IG9mIGBwbHVnaW5EYXRhYCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIHBsdWdpbi5cblx0XHQgKiBOb3RlIHRoYXQgaW4gbWFueSBjYXNlcywgdGhpcyBkYXRhIGlzIHVzZWQgYXMgc29vbiBhcyB0aGUgcGx1Z2luIGluaXRpYWxpemVzIGl0c2VsZiBmb3IgdGhlIHR3ZWVuLlxuXHRcdCAqIEFzIHN1Y2gsIHRoaXMgZGF0YSBzaG91bGQgYmUgc2V0IGJlZm9yZSB0aGUgZmlyc3QgYHRvYCBjYWxsIGluIG1vc3QgY2FzZXMuXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKlx0bXlUd2Vlbi5wbHVnaW5EYXRhLlNtYXJ0Um90YXRpb24gPSBkYXRhO1xuXHRcdCAqIFxuXHRcdCAqIE1vc3QgcGx1Z2lucyBhbHNvIHN1cHBvcnQgYSBwcm9wZXJ0eSB0byBkaXNhYmxlIHRoZW0gZm9yIGEgc3BlY2lmaWMgdHdlZW4uIFRoaXMgaXMgdHlwaWNhbGx5IHRoZSBwbHVnaW4gbmFtZSBmb2xsb3dlZCBieSBcIl9kaXNhYmxlZFwiLlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICpcdG15VHdlZW4ucGx1Z2luRGF0YS5TbWFydFJvdGF0aW9uX2Rpc2FibGVkID0gdHJ1ZTtcblx0XHQgKiBcblx0XHQgKiBTb21lIHBsdWdpbnMgYWxzbyBzdG9yZSB3b3JraW5nIGRhdGEgaW4gdGhpcyBvYmplY3QsIHVzdWFsbHkgaW4gYSBwcm9wZXJ0eSBuYW1lZCBgX1BsdWdpbkNsYXNzTmFtZWAuXG5cdFx0ICogU2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciBpbmRpdmlkdWFsIHBsdWdpbnMgZm9yIG1vcmUgZGV0YWlscy5cblx0XHQgKiBAcHJvcGVydHkgcGx1Z2luRGF0YVxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5wbHVnaW5EYXRhID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHRhcmdldCBvZiB0aGlzIHR3ZWVuLiBUaGlzIGlzIHRoZSBvYmplY3Qgb24gd2hpY2ggdGhlIHR3ZWVuZWQgcHJvcGVydGllcyB3aWxsIGJlIGNoYW5nZWQuXG5cdFx0ICogQHByb3BlcnR5IHRhcmdldFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB0aGUgdHdlZW4ncyBjdXJyZW50IHBvc2l0aW9uIGlzIHdpdGhpbiBhIHBhc3NpdmUgd2FpdC5cblx0XHQgKiBAcHJvcGVydHkgcGFzc2l2ZVxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMucGFzc2l2ZSA9IGZhbHNlO1xuXHRcdFxuXHRcdFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfc3RlcEhlYWRcblx0XHQgKiBAdHlwZSB7VHdlZW5TdGVwfVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9zdGVwSGVhZCA9IG5ldyBUd2VlblN0ZXAobnVsbCwgMCwgMCwge30sIG51bGwsIHRydWUpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfc3RlcFRhaWxcblx0XHQgKiBAdHlwZSB7VHdlZW5TdGVwfVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9zdGVwVGFpbCA9IHRoaXMuX3N0ZXBIZWFkO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBwb3NpdGlvbiB3aXRoaW4gdGhlIGN1cnJlbnQgc3RlcC4gVXNlZCBieSBNb3ZpZUNsaXAuXG5cdFx0ICogQHByb3BlcnR5IF9zdGVwUG9zaXRpb25cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fc3RlcFBvc2l0aW9uID0gMDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2FjdGlvbkhlYWRcblx0XHQgKiBAdHlwZSB7VHdlZW5BY3Rpb259XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX2FjdGlvbkhlYWQgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfYWN0aW9uVGFpbFxuXHRcdCAqIEB0eXBlIHtUd2VlbkFjdGlvbn1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fYWN0aW9uVGFpbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUGx1Z2lucyBhZGRlZCB0byB0aGlzIHR3ZWVuIGluc3RhbmNlLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcGx1Z2luc1xuXHRcdCAqIEB0eXBlIEFycmF5W09iamVjdF1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3BsdWdpbnMgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEhhc2ggZm9yIHF1aWNrbHkgbG9va2luZyB1cCBhZGRlZCBwbHVnaW5zLiBOdWxsIHVudGlsIGEgcGx1Z2luIGlzIGFkZGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcGx1Z2luc1xuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fcGx1Z2luSWRzID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBVc2VkIGJ5IHBsdWdpbnMgdG8gaW5qZWN0IG5ldyBwcm9wZXJ0aWVzLlxuXHRcdCAqIEBwcm9wZXJ0eSBfaW5qZWN0ZWRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5faW5qZWN0ZWQgPSBudWxsO1xuXG5cdFx0aWYgKHByb3BzKSB7XG5cdFx0XHR0aGlzLnBsdWdpbkRhdGEgPSBwcm9wcy5wbHVnaW5EYXRhO1xuXHRcdFx0aWYgKHByb3BzLm92ZXJyaWRlKSB7IFR3ZWVuLnJlbW92ZVR3ZWVucyh0YXJnZXQpOyB9XG5cdFx0fVxuXHRcdGlmICghdGhpcy5wbHVnaW5EYXRhKSB7IHRoaXMucGx1Z2luRGF0YSA9IHt9OyB9XG5cdFx0XG5cdFx0dGhpcy5faW5pdChwcm9wcyk7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoVHdlZW4sIGNyZWF0ZWpzLkFic3RyYWN0VHdlZW4pO1xuXG4vLyBzdGF0aWMgcHJvcGVydGllc1xuXG5cdC8qKlxuXHQgKiBDb25zdGFudCByZXR1cm5lZCBieSBwbHVnaW5zIHRvIHRlbGwgdGhlIHR3ZWVuIG5vdCB0byB1c2UgZGVmYXVsdCBhc3NpZ25tZW50LlxuXHQgKiBAcHJvcGVydHkgSUdOT1JFXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUd2Vlbi5JR05PUkUgPSB7fTtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IF9saXN0ZW5lcnNcblx0ICogQHR5cGUgQXJyYXlbVHdlZW5dXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0VHdlZW4uX3R3ZWVucyA9IFtdO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3BsdWdpbnNcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0VHdlZW4uX3BsdWdpbnMgPSBudWxsO1xuXHRcblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfdHdlZW5IZWFkXG5cdCAqIEB0eXBlIFR3ZWVuXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0VHdlZW4uX3R3ZWVuSGVhZCA9IG51bGw7XG5cdFxuXHQvKipcblx0ICogQHByb3BlcnR5IF90d2VlblRhaWxcblx0ICogQHR5cGUgVHdlZW5cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRUd2Vlbi5fdHdlZW5UYWlsID0gbnVsbDtcblxuXG4vLyBzdGF0aWMgbWV0aG9kc1x0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IHR3ZWVuIGluc3RhbmNlLiBUaGlzIGlzIGZ1bmN0aW9uYWxseSBpZGVudGljYWwgdG8gdXNpbmcgYG5ldyBUd2VlbiguLi4pYCwgYnV0IG1heSBsb29rIGNsZWFuZXJcblx0ICogd2l0aCB0aGUgY2hhaW5lZCBzeW50YXggb2YgVHdlZW5KUy5cblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKlx0dmFyIHR3ZWVuID0gY3JlYXRlanMuVHdlZW4uZ2V0KHRhcmdldCkudG8oe3g6MTAwfSwgNTAwKTtcblx0ICpcdC8vIGVxdWl2YWxlbnQgdG86XG5cdCAqXHR2YXIgdHdlZW4gPSBuZXcgY3JlYXRlanMuVHdlZW4odGFyZ2V0KS50byh7eDoxMDB9LCA1MDApO1xuXHQgKlxuXHQgKiBAbWV0aG9kIGdldFxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IHRoYXQgd2lsbCBoYXZlIGl0cyBwcm9wZXJ0aWVzIHR3ZWVuZWQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIFRoZSBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgdG8gYXBwbHkgdG8gdGhpcyBpbnN0YW5jZSAoZXguIGB7bG9vcDotMSwgcGF1c2VkOnRydWV9YCkuXG5cdCAqIFN1cHBvcnRlZCBwcm9wcyBhcmUgbGlzdGVkIGJlbG93LiBUaGVzZSBwcm9wcyBhcmUgc2V0IG9uIHRoZSBjb3JyZXNwb25kaW5nIGluc3RhbmNlIHByb3BlcnRpZXMgZXhjZXB0IHdoZXJlXG5cdCAqIHNwZWNpZmllZC5cblx0ICogQHBhcmFtIHtib29sZWFufSBbcHJvcHMudXNlVGlja3M9ZmFsc2VdICBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0VHdlZW4vdXNlVGlja3M6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLmlnbm9yZUdsb2JhbFBhdXNlPWZhbHNlXSBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0VHdlZW4vaWdub3JlR2xvYmFsUGF1c2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfGJvb2xlYW59IFtwcm9wcy5sb29wPTBdIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RUd2Vlbi9sb29wOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5yZXZlcnNlZD1mYWxzZV0gU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFR3ZWVuL3JldmVyc2VkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5ib3VuY2U9ZmFsc2VdIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RUd2Vlbi9ib3VuY2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMudGltZVNjYWxlPTFdIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RUd2Vlbi90aW1lU2NhbGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbcHJvcHMucGx1Z2luRGF0YV0gU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9wbHVnaW5EYXRhOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5wYXVzZWQ9ZmFsc2VdIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RUd2Vlbi9wYXVzZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMucG9zaXRpb249MF0gVGhlIGluaXRpYWwgcG9zaXRpb24gZm9yIHRoaXMgdHdlZW4uIFNlZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFR3ZWVuL3Bvc2l0aW9uOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wcy5vbkNoYW5nZV0gQWRkcyB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIGFzIGEgbGlzdGVuZXIgdG8gdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0VHdlZW4vY2hhbmdlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wcy5vbkNvbXBsZXRlXSBBZGRzIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gYXMgYSBsaXN0ZW5lciB0byB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RUd2Vlbi9jb21wbGV0ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vdmVycmlkZT1mYWxzZV0gUmVtb3ZlcyBhbGwgZXhpc3RpbmcgdHdlZW5zIGZvciB0aGUgdGFyZ2V0IHdoZW4gc2V0IHRvIGB0cnVlYC5cblx0ICogQHJldHVybiB7VHdlZW59IEEgcmVmZXJlbmNlIHRvIHRoZSBjcmVhdGVkIHR3ZWVuLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUd2Vlbi5nZXQgPSBmdW5jdGlvbih0YXJnZXQsIHByb3BzKSB7XG5cdFx0cmV0dXJuIG5ldyBUd2Vlbih0YXJnZXQsIHByb3BzKTtcblx0fTtcblxuXHQvKipcblx0ICogQWR2YW5jZXMgYWxsIHR3ZWVucy4gVGhpcyB0eXBpY2FsbHkgdXNlcyB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzLCBidXQgeW91IGNhbiBjYWxsIGl0XG5cdCAqIG1hbnVhbGx5IGlmIHlvdSBwcmVmZXIgdG8gdXNlIHlvdXIgb3duIFwiaGVhcnRiZWF0XCIgaW1wbGVtZW50YXRpb24uXG5cdCAqIEBtZXRob2QgdGlja1xuXHQgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgVGhlIGNoYW5nZSBpbiB0aW1lIGluIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCB0aWNrLiBSZXF1aXJlZCB1bmxlc3MgYWxsIHR3ZWVucyBoYXZlXG5cdCAqIGB1c2VUaWNrc2Agc2V0IHRvIHRydWUuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcGF1c2VkIEluZGljYXRlcyB3aGV0aGVyIGEgZ2xvYmFsIHBhdXNlIGlzIGluIGVmZmVjdC4gVHdlZW5zIHdpdGgge3sjY3Jvc3NMaW5rIFwiVHdlZW4vaWdub3JlR2xvYmFsUGF1c2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2lsbCBpZ25vcmUgdGhpcywgYnV0IGFsbCBvdGhlcnMgd2lsbCBwYXVzZSBpZiB0aGlzIGlzIGB0cnVlYC5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VHdlZW4udGljayA9IGZ1bmN0aW9uKGRlbHRhLCBwYXVzZWQpIHtcblx0XHR2YXIgdHdlZW4gPSBUd2Vlbi5fdHdlZW5IZWFkO1xuXHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0dmFyIG5leHQgPSB0d2Vlbi5fbmV4dDsgLy8gaW4gY2FzZSBpdCBjb21wbGV0ZXMgYW5kIHdpcGVzIGl0cyBfbmV4dCBwcm9wZXJ0eVxuXHRcdFx0aWYgKChwYXVzZWQgJiYgIXR3ZWVuLmlnbm9yZUdsb2JhbFBhdXNlKSB8fCB0d2Vlbi5fcGF1c2VkKSB7IC8qIHBhdXNlZCAqLyB9XG5cdFx0XHRlbHNlIHsgdHdlZW4uYWR2YW5jZSh0d2Vlbi51c2VUaWNrcz8xOmRlbHRhKTsgfVxuXHRcdFx0dHdlZW4gPSBuZXh0O1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlIGV2ZW50cyB0aGF0IHJlc3VsdCBmcm9tIFR3ZWVuIGJlaW5nIHVzZWQgYXMgYW4gZXZlbnQgaGFuZGxlci4gVGhpcyBpcyBpbmNsdWRlZCB0byBhbGxvdyBUd2VlbiB0byBoYW5kbGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3RpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnRzIGZyb20gdGhlIGNyZWF0ZWpzIHt7I2Nyb3NzTGluayBcIlRpY2tlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogTm8gb3RoZXIgZXZlbnRzIGFyZSBoYW5kbGVkIGluIFR3ZWVuLlxuXHQgKiBAbWV0aG9kIGhhbmRsZUV2ZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBBbiBldmVudCBvYmplY3QgcGFzc2VkIGluIGJ5IHRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXJcIn19e3svY3Jvc3NMaW5rfX0uIFdpbGxcblx0ICogdXN1YWxseSBiZSBvZiB0eXBlIFwidGlja1wiLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMlxuXHQgKi9cblx0VHdlZW4uaGFuZGxlRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdGlmIChldmVudC50eXBlID09PSBcInRpY2tcIikge1xuXHRcdFx0dGhpcy50aWNrKGV2ZW50LmRlbHRhLCBldmVudC5wYXVzZWQpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwgZXhpc3RpbmcgdHdlZW5zIGZvciBhIHRhcmdldC4gVGhpcyBpcyBjYWxsZWQgYXV0b21hdGljYWxseSBieSBuZXcgdHdlZW5zIGlmIHRoZSBgb3ZlcnJpZGVgXG5cdCAqIHByb3BlcnR5IGlzIGB0cnVlYC5cblx0ICogQG1ldGhvZCByZW1vdmVUd2VlbnNcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCB0byByZW1vdmUgZXhpc3RpbmcgdHdlZW5zIGZyb20uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFR3ZWVuLnJlbW92ZVR3ZWVucyA9IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdGlmICghdGFyZ2V0LnR3ZWVuanNfY291bnQpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIHR3ZWVuID0gVHdlZW4uX3R3ZWVuSGVhZDtcblx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdHZhciBuZXh0ID0gdHdlZW4uX25leHQ7XG5cdFx0XHRpZiAodHdlZW4udGFyZ2V0ID09PSB0YXJnZXQpIHsgVHdlZW4uX3JlZ2lzdGVyKHR3ZWVuLCB0cnVlKTsgfVxuXHRcdFx0dHdlZW4gPSBuZXh0O1xuXHRcdH1cblx0XHR0YXJnZXQudHdlZW5qc19jb3VudCA9IDA7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3AgYW5kIHJlbW92ZSBhbGwgZXhpc3RpbmcgdHdlZW5zLlxuXHQgKiBAbWV0aG9kIHJlbW92ZUFsbFR3ZWVuc1xuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKi9cblx0VHdlZW4ucmVtb3ZlQWxsVHdlZW5zID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHR3ZWVuID0gVHdlZW4uX3R3ZWVuSGVhZDtcblx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdHZhciBuZXh0ID0gdHdlZW4uX25leHQ7XG5cdFx0XHR0d2Vlbi5fcGF1c2VkID0gdHJ1ZTtcblx0XHRcdHR3ZWVuLnRhcmdldCYmKHR3ZWVuLnRhcmdldC50d2VlbmpzX2NvdW50ID0gMCk7XG5cdFx0XHR0d2Vlbi5fbmV4dCA9IHR3ZWVuLl9wcmV2ID0gbnVsbDtcblx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHR9XG5cdFx0VHdlZW4uX3R3ZWVuSGVhZCA9IFR3ZWVuLl90d2VlblRhaWwgPSBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGVyZSBhcmUgYW55IGFjdGl2ZSB0d2VlbnMgb24gdGhlIHRhcmdldCBvYmplY3QgKGlmIHNwZWNpZmllZCkgb3IgaW4gZ2VuZXJhbC5cblx0ICogQG1ldGhvZCBoYXNBY3RpdmVUd2VlbnNcblx0ICogQHBhcmFtIHtPYmplY3R9IFt0YXJnZXRdIFRoZSB0YXJnZXQgdG8gY2hlY2sgZm9yIGFjdGl2ZSB0d2VlbnMuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBpbmRpY2F0ZVxuXHQgKiBpZiB0aGVyZSBhcmUgYW55IGFjdGl2ZSB0d2VlbnMgb24gYW55IHRhcmdldC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSW5kaWNhdGVzIGlmIHRoZXJlIGFyZSBhY3RpdmUgdHdlZW5zLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUd2Vlbi5oYXNBY3RpdmVUd2VlbnMgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRpZiAodGFyZ2V0KSB7IHJldHVybiAhIXRhcmdldC50d2VlbmpzX2NvdW50OyB9XG5cdFx0cmV0dXJuICEhVHdlZW4uX3R3ZWVuSGVhZDtcblx0fTtcblxuXHQvKipcblx0ICogSW5zdGFsbHMgYSBwbHVnaW4sIHdoaWNoIGNhbiBtb2RpZnkgaG93IGNlcnRhaW4gcHJvcGVydGllcyBhcmUgaGFuZGxlZCB3aGVuIHR3ZWVuZWQuIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiU2FtcGxlUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBhbiBleGFtcGxlIG9mIGhvdyB0byB3cml0ZSBUd2VlbkpTIHBsdWdpbnMuIFBsdWdpbnMgc2hvdWxkIGdlbmVyYWxseSBiZSBpbnN0YWxsZWQgdmlhIHRoZWlyIG93biBgaW5zdGFsbGAgbWV0aG9kLCBpbiBvcmRlciB0byBwcm92aWRlXG5cdCAqIHRoZSBwbHVnaW4gd2l0aCBhbiBvcHBvcnR1bml0eSB0byBjb25maWd1cmUgaXRzZWxmLlxuXHQgKiBAbWV0aG9kIF9pbnN0YWxsUGx1Z2luXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gVGhlIHBsdWdpbiB0byBpbnN0YWxsXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0VHdlZW4uX2luc3RhbGxQbHVnaW4gPSBmdW5jdGlvbihwbHVnaW4pIHtcblx0XHR2YXIgcHJpb3JpdHkgPSAocGx1Z2luLnByaW9yaXR5ID0gcGx1Z2luLnByaW9yaXR5fHwwKSwgYXJyID0gKFR3ZWVuLl9wbHVnaW5zID0gVHdlZW4uX3BsdWdpbnMgfHwgW10pO1xuXHRcdGZvciAodmFyIGk9MCxsPWFyci5sZW5ndGg7aTxsO2krKykge1xuXHRcdFx0aWYgKHByaW9yaXR5IDwgYXJyW2ldLnByaW9yaXR5KSB7IGJyZWFrOyB9XG5cdFx0fVxuXHRcdGFyci5zcGxpY2UoaSwwLHBsdWdpbik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBvciB1bnJlZ2lzdGVycyBhIHR3ZWVuIHdpdGggdGhlIHRpY2tpbmcgc3lzdGVtLlxuXHQgKiBAbWV0aG9kIF9yZWdpc3RlclxuXHQgKiBAcGFyYW0ge1R3ZWVufSB0d2VlbiBUaGUgdHdlZW4gaW5zdGFuY2UgdG8gcmVnaXN0ZXIgb3IgdW5yZWdpc3Rlci5cblx0ICogQHBhcmFtIHtCb29sZWFufSBwYXVzZWQgSWYgYGZhbHNlYCwgdGhlIHR3ZWVuIGlzIHJlZ2lzdGVyZWQuIElmIGB0cnVlYCB0aGUgdHdlZW4gaXMgdW5yZWdpc3RlcmVkLlxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdFR3ZWVuLl9yZWdpc3RlciA9IGZ1bmN0aW9uKHR3ZWVuLCBwYXVzZWQpIHtcblx0XHR2YXIgdGFyZ2V0ID0gdHdlZW4udGFyZ2V0O1xuXHRcdGlmICghcGF1c2VkICYmIHR3ZWVuLl9wYXVzZWQpIHtcblx0XHRcdC8vIFRPRE86IHRoaXMgYXBwcm9hY2ggbWlnaHQgZmFpbCBpZiBhIGRldiBpcyB1c2luZyBzZWFsZWQgb2JqZWN0c1xuXHRcdFx0aWYgKHRhcmdldCkgeyB0YXJnZXQudHdlZW5qc19jb3VudCA9IHRhcmdldC50d2VlbmpzX2NvdW50ID8gdGFyZ2V0LnR3ZWVuanNfY291bnQrMSA6IDE7IH1cblx0XHRcdHZhciB0YWlsID0gVHdlZW4uX3R3ZWVuVGFpbDtcblx0XHRcdGlmICghdGFpbCkgeyBUd2Vlbi5fdHdlZW5IZWFkID0gVHdlZW4uX3R3ZWVuVGFpbCA9IHR3ZWVuOyB9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0VHdlZW4uX3R3ZWVuVGFpbCA9IHRhaWwuX25leHQgPSB0d2Vlbjtcblx0XHRcdFx0dHdlZW4uX3ByZXYgPSB0YWlsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFUd2Vlbi5faW5pdGVkICYmIGNyZWF0ZWpzLlRpY2tlcikgeyBjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgVHdlZW4pOyBUd2Vlbi5faW5pdGVkID0gdHJ1ZTsgfVxuXHRcdH0gZWxzZSBpZiAocGF1c2VkICYmICF0d2Vlbi5fcGF1c2VkKSB7XG5cdFx0XHRpZiAodGFyZ2V0KSB7IHRhcmdldC50d2VlbmpzX2NvdW50LS07IH1cblx0XHRcdHZhciBuZXh0ID0gdHdlZW4uX25leHQsIHByZXYgPSB0d2Vlbi5fcHJldjtcblx0XHRcdFxuXHRcdFx0aWYgKG5leHQpIHsgbmV4dC5fcHJldiA9IHByZXY7IH1cblx0XHRcdGVsc2UgeyBUd2Vlbi5fdHdlZW5UYWlsID0gcHJldjsgfSAvLyB3YXMgdGFpbFxuXHRcdFx0aWYgKHByZXYpIHsgcHJldi5fbmV4dCA9IG5leHQ7IH1cblx0XHRcdGVsc2UgeyBUd2Vlbi5fdHdlZW5IZWFkID0gbmV4dDsgfSAvLyB3YXMgaGVhZC5cblx0XHRcdFxuXHRcdFx0dHdlZW4uX25leHQgPSB0d2Vlbi5fcHJldiA9IG51bGw7XG5cdFx0fVxuXHRcdHR3ZWVuLl9wYXVzZWQgPSBwYXVzZWQ7XG5cdH07XG5cblxuLy8gZXZlbnRzOlxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEFkZHMgYSB3YWl0IChlc3NlbnRpYWxseSBhbiBlbXB0eSB0d2VlbikuXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICpcdC8vVGhpcyB0d2VlbiB3aWxsIHdhaXQgMXMgYmVmb3JlIGFscGhhIGlzIGZhZGVkIHRvIDAuXG5cdCAqXHRjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0KS53YWl0KDEwMDApLnRvKHthbHBoYTowfSwgMTAwMCk7XG5cdCAqXG5cdCAqIEBtZXRob2Qgd2FpdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gVGhlIGR1cmF0aW9uIG9mIHRoZSB3YWl0IGluIG1pbGxpc2Vjb25kcyAob3IgaW4gdGlja3MgaWYgYHVzZVRpY2tzYCBpcyB0cnVlKS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcGFzc2l2ZT1mYWxzZV0gVHdlZW4gcHJvcGVydGllcyB3aWxsIG5vdCBiZSB1cGRhdGVkIGR1cmluZyBhIHBhc3NpdmUgd2FpdC4gVGhpc1xuXHQgKiBpcyBtb3N0bHkgdXNlZnVsIGZvciB1c2Ugd2l0aCB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZVwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZXMgdGhhdCBjb250YWluIG11bHRpcGxlIHR3ZWVuc1xuXHQgKiBhZmZlY3RpbmcgdGhlIHNhbWUgdGFyZ2V0IGF0IGRpZmZlcmVudCB0aW1lcy5cblx0ICogQHJldHVybiB7VHdlZW59IFRoaXMgdHdlZW4gaW5zdGFuY2UgKGZvciBjaGFpbmluZyBjYWxscykuXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLndhaXQgPSBmdW5jdGlvbihkdXJhdGlvbiwgcGFzc2l2ZSkge1xuXHRcdGlmIChkdXJhdGlvbiA+IDApIHsgdGhpcy5fYWRkU3RlcCgrZHVyYXRpb24sIHRoaXMuX3N0ZXBUYWlsLnByb3BzLCBudWxsLCBwYXNzaXZlKTsgfVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGRzIGEgdHdlZW4gZnJvbSB0aGUgY3VycmVudCB2YWx1ZXMgdG8gdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLiBTZXQgZHVyYXRpb24gdG8gMCB0byBqdW1wIHRvIHRoZXNlIHZhbHVlLlxuXHQgKiBOdW1lcmljIHByb3BlcnRpZXMgd2lsbCBiZSB0d2VlbmVkIGZyb20gdGhlaXIgY3VycmVudCB2YWx1ZSBpbiB0aGUgdHdlZW4gdG8gdGhlIHRhcmdldCB2YWx1ZS4gTm9uLW51bWVyaWNcblx0ICogcHJvcGVydGllcyB3aWxsIGJlIHNldCBhdCB0aGUgZW5kIG9mIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24uXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICpcdGNyZWF0ZWpzLlR3ZWVuLmdldCh0YXJnZXQpLnRvKHthbHBoYTowLCB2aXNpYmxlOmZhbHNlfSwgMTAwMCk7XG5cdCAqXG5cdCAqIEBtZXRob2QgdG9cblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEFuIG9iamVjdCBzcGVjaWZ5aW5nIHByb3BlcnR5IHRhcmdldCB2YWx1ZXMgZm9yIHRoaXMgdHdlZW4gKEV4LiBge3g6MzAwfWAgd291bGQgdHdlZW4gdGhlIHhcblx0ICogcHJvcGVydHkgb2YgdGhlIHRhcmdldCB0byAzMDApLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2R1cmF0aW9uPTBdIFRoZSBkdXJhdGlvbiBvZiB0aGUgdHdlZW4gaW4gbWlsbGlzZWNvbmRzIChvciBpbiB0aWNrcyBpZiBgdXNlVGlja3NgIGlzIHRydWUpLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZWFzZT1cImxpbmVhclwiXSBUaGUgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSBmb3IgdGhpcyB0d2Vlbi4gU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJFYXNlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGNsYXNzIGZvciBhIGxpc3Qgb2YgYnVpbHQtaW4gZWFzZSBmdW5jdGlvbnMuXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBUaGlzIHR3ZWVuIGluc3RhbmNlIChmb3IgY2hhaW5pbmcgY2FsbHMpLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRwLnRvID0gZnVuY3Rpb24ocHJvcHMsIGR1cmF0aW9uLCBlYXNlKSB7XG5cdFx0aWYgKGR1cmF0aW9uID09IG51bGwgfHwgZHVyYXRpb24gPCAwKSB7IGR1cmF0aW9uID0gMDsgfVxuXHRcdHZhciBzdGVwID0gdGhpcy5fYWRkU3RlcCgrZHVyYXRpb24sIG51bGwsIGVhc2UpO1xuXHRcdHRoaXMuX2FwcGVuZFByb3BzKHByb3BzLCBzdGVwKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBZGRzIGEgbGFiZWwgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHt7I2Nyb3NzTGluayBcIlR3ZWVuL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319L3t7I2Nyb3NzTGluayBcIlR3ZWVuL2dvdG9BbmRTdG9wXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGF0IHRoZSBjdXJyZW50IHBvaW50IGluIHRoZSB0d2Vlbi4gRm9yIGV4YW1wbGU6XG5cdCAqIFxuXHQgKiBcdHZhciB0d2VlbiA9IGNyZWF0ZWpzLlR3ZWVuLmdldChmb28pXG5cdCAqIFx0XHRcdFx0XHQudG8oe3g6MTAwfSwgMTAwMClcblx0ICogXHRcdFx0XHRcdC5sYWJlbChcIm15TGFiZWxcIilcblx0ICogXHRcdFx0XHRcdC50byh7eDoyMDB9LCAxMDAwKTtcblx0ICogLy8gLi4uXG5cdCAqIHR3ZWVuLmdvdG9BbmRQbGF5KFwibXlMYWJlbFwiKTsgLy8gd291bGQgcGxheSBmcm9tIDEwMDBtcyBpbi5cblx0ICogXG5cdCAqIEBtZXRob2QgYWRkTGFiZWxcblx0ICogQHBhcmFtIHtTdHJpbmd9IGxhYmVsIFRoZSBsYWJlbCBuYW1lLlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhpcyB0d2VlbiBpbnN0YW5jZSAoZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAubGFiZWwgPSBmdW5jdGlvbihuYW1lKSB7XG5cdFx0dGhpcy5hZGRMYWJlbChuYW1lLCB0aGlzLmR1cmF0aW9uKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQWRkcyBhbiBhY3Rpb24gdG8gY2FsbCB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqIFx0Ly93b3VsZCBjYWxsIG15RnVuY3Rpb24oKSBhZnRlciAxIHNlY29uZC5cblx0ICogXHRjcmVhdGVqcy5Ud2Vlbi5nZXQoKS53YWl0KDEwMDApLmNhbGwobXlGdW5jdGlvbik7XG5cdCAqXG5cdCAqIEBtZXRob2QgY2FsbFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cblx0ICogQHBhcmFtIHtBcnJheX0gW3BhcmFtc10uIFRoZSBwYXJhbWV0ZXJzIHRvIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGguIElmIHRoaXMgaXMgb21pdHRlZCwgdGhlbiB0aGUgZnVuY3Rpb25cblx0ICogd2lsbCBiZSBjYWxsZWQgd2l0aCBhIHNpbmdsZSBwYXJhbSBwb2ludGluZyB0byB0aGlzIHR3ZWVuLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXS4gVGhlIHNjb3BlIHRvIGNhbGwgdGhlIGZ1bmN0aW9uIGluLiBJZiBvbWl0dGVkLCBpdCB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgdGFyZ2V0J3Mgc2NvcGUuXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBUaGlzIHR3ZWVuIGluc3RhbmNlIChmb3IgY2hhaW5pbmcgY2FsbHMpLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRwLmNhbGwgPSBmdW5jdGlvbihjYWxsYmFjaywgcGFyYW1zLCBzY29wZSkge1xuXHRcdHJldHVybiB0aGlzLl9hZGRBY3Rpb24oc2NvcGV8fHRoaXMudGFyZ2V0LCBjYWxsYmFjaywgcGFyYW1zfHxbdGhpc10pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGFjdGlvbiB0byBzZXQgdGhlIHNwZWNpZmllZCBwcm9wcyBvbiB0aGUgc3BlY2lmaWVkIHRhcmdldC4gSWYgYHRhcmdldGAgaXMgbnVsbCwgaXQgd2lsbCB1c2UgdGhpcyB0d2VlbidzXG5cdCAqIHRhcmdldC4gTm90ZSB0aGF0IGZvciBwcm9wZXJ0aWVzIG9uIHRoZSB0YXJnZXQgb2JqZWN0LCB5b3Ugc2hvdWxkIGNvbnNpZGVyIHVzaW5nIGEgemVybyBkdXJhdGlvbiB7eyNjcm9zc0xpbmsgXCJUd2Vlbi90b1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvcGVyYXRpb24gaW5zdGVhZCBzbyB0aGUgdmFsdWVzIGFyZSByZWdpc3RlcmVkIGFzIHR3ZWVuZWQgcHJvcHMuXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICpcdG15VHdlZW4ud2FpdCgxMDAwKS5zZXQoe3Zpc2libGU6ZmFsc2V9LCBmb28pO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHNldFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgVGhlIHByb3BlcnRpZXMgdG8gc2V0IChleC4gYHt2aXNpYmxlOmZhbHNlfWApLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3RhcmdldF0gVGhlIHRhcmdldCB0byBzZXQgdGhlIHByb3BlcnRpZXMgb24uIElmIG9taXR0ZWQsIHRoZXkgd2lsbCBiZSBzZXQgb24gdGhlIHR3ZWVuJ3MgdGFyZ2V0LlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhpcyB0d2VlbiBpbnN0YW5jZSAoZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0cC5zZXQgPSBmdW5jdGlvbihwcm9wcywgdGFyZ2V0KSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZEFjdGlvbih0YXJnZXR8fHRoaXMudGFyZ2V0LCB0aGlzLl9zZXQsIFtwcm9wc10pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGFjdGlvbiB0byBwbGF5ICh1bnBhdXNlKSB0aGUgc3BlY2lmaWVkIHR3ZWVuLiBUaGlzIGVuYWJsZXMgeW91IHRvIHNlcXVlbmNlIG11bHRpcGxlIHR3ZWVucy5cblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKlx0bXlUd2Vlbi50byh7eDoxMDB9LCA1MDApLnBsYXkob3RoZXJUd2Vlbik7XG5cdCAqXG5cdCAqIEBtZXRob2QgcGxheVxuXHQgKiBAcGFyYW0ge1R3ZWVufSBbdHdlZW5dIFRoZSB0d2VlbiB0byBwbGF5LiBEZWZhdWx0cyB0byB0aGlzIHR3ZWVuLlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhpcyB0d2VlbiBpbnN0YW5jZSAoZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0cC5wbGF5ID0gZnVuY3Rpb24odHdlZW4pIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkQWN0aW9uKHR3ZWVufHx0aGlzLCB0aGlzLl9zZXQsIFt7cGF1c2VkOmZhbHNlfV0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGFjdGlvbiB0byBwYXVzZSB0aGUgc3BlY2lmaWVkIHR3ZWVuLlxuXHQgKiBcblx0ICogXHRteVR3ZWVuLnBhdXNlKG90aGVyVHdlZW4pLnRvKHthbHBoYToxfSwgMTAwMCkucGxheShvdGhlclR3ZWVuKTtcblx0ICogXG5cdCAqIE5vdGUgdGhhdCB0aGlzIGV4ZWN1dGVzIGF0IHRoZSBlbmQgb2YgYSB0d2VlbiB1cGRhdGUsIHNvIHRoZSB0d2VlbiBtYXkgYWR2YW5jZSBiZXlvbmQgdGhlIHRpbWUgdGhlIHBhdXNlXG5cdCAqIGFjdGlvbiB3YXMgaW5zZXJ0ZWQgYXQuIEZvciBleGFtcGxlOlxuXHQgKiBcblx0ICogbXlUd2Vlbi50byh7Zm9vOjB9LCAxMDAwKS5wYXVzZSgpLnRvKHtmb286MX0sIDEwMDApO1xuXHQgKiBcblx0ICogQXQgNjBmcHMgdGhlIHR3ZWVuIHdpbGwgYWR2YW5jZSBieSB+MTZtcyBwZXIgdGljaywgaWYgdGhlIHR3ZWVuIGFib3ZlIHdhcyBhdCA5OTltcyBwcmlvciB0byB0aGUgY3VycmVudCB0aWNrLCBpdFxuXHQgKiB3aWxsIGFkdmFuY2UgdG8gMTAxNW1zICgxNW1zIGludG8gdGhlIHNlY29uZCBcInN0ZXBcIikgYW5kIHRoZW4gcGF1c2UuXG5cdCAqIFxuXHQgKiBAbWV0aG9kIHBhdXNlXG5cdCAqIEBwYXJhbSB7VHdlZW59IFt0d2Vlbl0gVGhlIHR3ZWVuIHRvIHBhdXNlLiBEZWZhdWx0cyB0byB0aGlzIHR3ZWVuLlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhpcyB0d2VlbiBpbnN0YW5jZSAoZm9yIGNoYWluaW5nIGNhbGxzKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRwLnBhdXNlID0gZnVuY3Rpb24odHdlZW4pIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkQWN0aW9uKHR3ZWVufHx0aGlzLCB0aGlzLl9zZXQsIFt7cGF1c2VkOnRydWV9XSk7XG5cdH07XG5cblx0Ly8gdGlueSBhcGkgKHByaW1hcmlseSBmb3IgdG9vbCBvdXRwdXQpOlxuXHRwLncgPSBwLndhaXQ7XG5cdHAudCA9IHAudG87XG5cdHAuYyA9IHAuY2FsbDtcblx0cC5zID0gcC5zZXQ7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1R3ZWVuXVwiO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyhcIlR3ZWVuIGNhbiBub3QgYmUgY2xvbmVkLlwiKVxuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEFkZHMgYSBwbHVnaW4gdG8gdGhpcyB0d2Vlbi5cblx0ICogQG1ldGhvZCBfYWRkUGx1Z2luXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fYWRkUGx1Z2luID0gZnVuY3Rpb24ocGx1Z2luKSB7XG5cdFx0dmFyIGlkcyA9IHRoaXMuX3BsdWdpbklkcyB8fCAodGhpcy5fcGx1Z2luSWRzID0ge30pLCBpZCA9IHBsdWdpbi5JRDtcblx0XHRpZiAoIWlkIHx8IGlkc1tpZF0pIHsgcmV0dXJuOyB9IC8vIGFscmVhZHkgYWRkZWRcblx0XHRcblx0XHRpZHNbaWRdID0gdHJ1ZTtcblx0XHR2YXIgcGx1Z2lucyA9IHRoaXMuX3BsdWdpbnMgfHwgKHRoaXMuX3BsdWdpbnMgPSBbXSksIHByaW9yaXR5ID0gcGx1Z2luLnByaW9yaXR5IHx8IDA7XG5cdFx0Zm9yICh2YXIgaT0wLGw9cGx1Z2lucy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRpZiAocHJpb3JpdHkgPCBwbHVnaW5zW2ldLnByaW9yaXR5KSB7XG5cdFx0XHRcdHBsdWdpbnMuc3BsaWNlKGksMCxwbHVnaW4pO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHBsdWdpbnMucHVzaChwbHVnaW4pO1xuXHR9O1xuXHRcblx0Ly8gRG9jY2VkIGluIEFic3RyYWN0VHdlZW5cblx0cC5fdXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbihqdW1wLCBlbmQpIHtcblx0XHR2YXIgc3RlcCA9IHRoaXMuX3N0ZXBIZWFkLm5leHQsIHQ9dGhpcy5wb3NpdGlvbiwgZD10aGlzLmR1cmF0aW9uO1xuXHRcdGlmICh0aGlzLnRhcmdldCAmJiBzdGVwKSB7XG5cdFx0XHQvLyBmaW5kIG91ciBuZXcgc3RlcCBpbmRleDpcblx0XHRcdHZhciBzdGVwTmV4dCA9IHN0ZXAubmV4dDtcblx0XHRcdHdoaWxlIChzdGVwTmV4dCAmJiBzdGVwTmV4dC50IDw9IHQpIHsgc3RlcCA9IHN0ZXAubmV4dDsgc3RlcE5leHQgPSBzdGVwLm5leHQ7IH1cblx0XHRcdHZhciByYXRpbyA9IGVuZCA/IGQgPT09IDAgPyAxIDogdC9kIDogKHQtc3RlcC50KS9zdGVwLmQ7IC8vIFRPRE86IHJldmlzaXQgdGhpcy5cblx0XHRcdHRoaXMuX3VwZGF0ZVRhcmdldFByb3BzKHN0ZXAsIHJhdGlvLCBlbmQpO1xuXHRcdH1cblx0XHR0aGlzLl9zdGVwUG9zaXRpb24gPSBzdGVwID8gdC1zdGVwLnQgOiAwO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX3VwZGF0ZVRhcmdldFByb3BzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdGVwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYXRpb1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGVuZCBJbmRpY2F0ZXMgdG8gcGx1Z2lucyB0aGF0IHRoZSBmdWxsIHR3ZWVuIGhhcyBlbmRlZC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fdXBkYXRlVGFyZ2V0UHJvcHMgPSBmdW5jdGlvbihzdGVwLCByYXRpbywgZW5kKSB7XG5cdFx0aWYgKHRoaXMucGFzc2l2ZSA9ICEhc3RlcC5wYXNzaXZlKSB7IHJldHVybjsgfSAvLyBkb24ndCB1cGRhdGUgcHJvcHMuXG5cdFx0XG5cdFx0dmFyIHYsIHYwLCB2MSwgZWFzZTtcblx0XHR2YXIgcDAgPSBzdGVwLnByZXYucHJvcHM7XG5cdFx0dmFyIHAxID0gc3RlcC5wcm9wcztcblx0XHRpZiAoZWFzZSA9IHN0ZXAuZWFzZSkgeyByYXRpbyA9IGVhc2UocmF0aW8sMCwxLDEpOyB9XG5cdFx0XG5cdFx0dmFyIHBsdWdpbnMgPSB0aGlzLl9wbHVnaW5zO1xuXHRcdHByb3Bsb29wIDogZm9yICh2YXIgbiBpbiBwMCkge1xuXHRcdFx0djAgPSBwMFtuXTtcblx0XHRcdHYxID0gcDFbbl07XG5cdFx0XHRcblx0XHRcdC8vIHZhbHVlcyBhcmUgZGlmZmVyZW50ICYgaXQgaXMgbnVtZXJpYyB0aGVuIGludGVycG9sYXRlOlxuXHRcdFx0aWYgKHYwICE9PSB2MSAmJiAodHlwZW9mKHYwKSA9PT0gXCJudW1iZXJcIikpIHtcblx0XHRcdFx0diA9IHYwKyh2MS12MCkqcmF0aW87XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2ID0gcmF0aW8gPj0gMSA/IHYxIDogdjA7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChwbHVnaW5zKSB7XG5cdFx0XHRcdGZvciAodmFyIGk9MCxsPXBsdWdpbnMubGVuZ3RoO2k8bDtpKyspIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBwbHVnaW5zW2ldLmNoYW5nZSh0aGlzLCBzdGVwLCBuLCB2LCByYXRpbywgZW5kKTtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IFR3ZWVuLklHTk9SRSkgeyBjb250aW51ZSBwcm9wbG9vcDsgfVxuXHRcdFx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7IHYgPSB2YWx1ZTsgfVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnRhcmdldFtuXSA9IHY7XG5cdFx0fVxuXG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfcnVuQWN0aW9uc1JhbmdlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFBvc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gZW5kUG9zXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jbHVkZVN0YXJ0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3J1bkFjdGlvbnNSYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBlbmRQb3MsIGp1bXAsIGluY2x1ZGVTdGFydCkge1xuXHRcdHZhciByZXYgPSBzdGFydFBvcyA+IGVuZFBvcztcblx0XHR2YXIgYWN0aW9uID0gcmV2ID8gdGhpcy5fYWN0aW9uVGFpbCA6IHRoaXMuX2FjdGlvbkhlYWQ7XG5cdFx0dmFyIGVQb3MgPSBlbmRQb3MsIHNQb3MgPSBzdGFydFBvcztcblx0XHRpZiAocmV2KSB7IGVQb3M9c3RhcnRQb3M7IHNQb3M9ZW5kUG9zOyB9XG5cdFx0dmFyIHQgPSB0aGlzLnBvc2l0aW9uO1xuXHRcdHdoaWxlIChhY3Rpb24pIHtcblx0XHRcdHZhciBwb3MgPSBhY3Rpb24udDtcblx0XHRcdGlmIChwb3MgPT09IGVuZFBvcyB8fCAocG9zID4gc1BvcyAmJiBwb3MgPCBlUG9zKSB8fCAoaW5jbHVkZVN0YXJ0ICYmIHBvcyA9PT0gc3RhcnRQb3MpKSB7XG5cdFx0XHRcdGFjdGlvbi5mdW5jdC5hcHBseShhY3Rpb24uc2NvcGUsIGFjdGlvbi5wYXJhbXMpO1xuXHRcdFx0XHRpZiAodCAhPT0gdGhpcy5wb3NpdGlvbikgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdFx0fVxuXHRcdFx0YWN0aW9uID0gcmV2ID8gYWN0aW9uLnByZXYgOiBhY3Rpb24ubmV4dDtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2FwcGVuZFByb3BzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9hcHBlbmRQcm9wcyA9IGZ1bmN0aW9uKHByb3BzLCBzdGVwLCBzdGVwUGx1Z2lucykge1xuXHRcdHZhciBpbml0UHJvcHMgPSB0aGlzLl9zdGVwSGVhZC5wcm9wcywgdGFyZ2V0ID0gdGhpcy50YXJnZXQsIHBsdWdpbnMgPSBUd2Vlbi5fcGx1Z2lucztcblx0XHR2YXIgbiwgaSwgdmFsdWUsIGluaXRWYWx1ZSwgaW5qZWN0O1xuXHRcdHZhciBvbGRTdGVwID0gc3RlcC5wcmV2LCBvbGRQcm9wcyA9IG9sZFN0ZXAucHJvcHM7XG5cdFx0dmFyIHN0ZXBQcm9wcyA9IHN0ZXAucHJvcHMgfHwgKHN0ZXAucHJvcHMgPSB0aGlzLl9jbG9uZVByb3BzKG9sZFByb3BzKSk7XG5cdFx0dmFyIGNsZWFuUHJvcHMgPSB7fTsgLy8gVE9ETzogaXMgdGhlcmUgc29tZSB3YXkgdG8gYXZvaWQgdGhpcyBhZGRpdGlvbmFsIG9iamVjdD9cblxuXHRcdGZvciAobiBpbiBwcm9wcykge1xuXHRcdFx0aWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShuKSkgeyBjb250aW51ZTsgfVxuXHRcdFx0Y2xlYW5Qcm9wc1tuXSA9IHN0ZXBQcm9wc1tuXSA9IHByb3BzW25dO1xuXG5cdFx0XHRpZiAoaW5pdFByb3BzW25dICE9PSB1bmRlZmluZWQpIHsgY29udGludWU7IH1cblxuXHRcdFx0aW5pdFZhbHVlID0gdW5kZWZpbmVkOyAvLyBhY2Nlc3NpbmcgbWlzc2luZyBwcm9wZXJ0aWVzIG9uIERPTUVsZW1lbnRzIHdoZW4gdXNpbmcgQ1NTUGx1Z2luIGlzIElOU0FORUxZIGV4cGVuc2l2ZSwgc28gd2UgbGV0IHRoZSBwbHVnaW4gdGFrZSBhIGZpcnN0IHN3aW5nIGF0IGl0LlxuXHRcdFx0aWYgKHBsdWdpbnMpIHtcblx0XHRcdFx0Zm9yIChpID0gcGx1Z2lucy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHBsdWdpbnNbaV0uaW5pdCh0aGlzLCBuLCBpbml0VmFsdWUpO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7IGluaXRWYWx1ZSA9IHZhbHVlOyB9XG5cdFx0XHRcdFx0aWYgKGluaXRWYWx1ZSA9PT0gVHdlZW4uSUdOT1JFKSB7XG5cdFx0XHRcdFx0XHRkZWxldGUoc3RlcFByb3BzW25dKTtcblx0XHRcdFx0XHRcdGRlbGV0ZShjbGVhblByb3BzW25dKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaW5pdFZhbHVlICE9PSBUd2Vlbi5JR05PUkUpIHtcblx0XHRcdFx0aWYgKGluaXRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7IGluaXRWYWx1ZSA9IHRhcmdldFtuXTsgfVxuXHRcdFx0XHRvbGRQcm9wc1tuXSA9IChpbml0VmFsdWUgPT09IHVuZGVmaW5lZCkgPyBudWxsIDogaW5pdFZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRmb3IgKG4gaW4gY2xlYW5Qcm9wcykge1xuXHRcdFx0dmFsdWUgPSBwcm9wc1tuXTtcblxuXHRcdFx0Ly8gcHJvcGFnYXRlIG9sZCB2YWx1ZSB0byBwcmV2aW91cyBzdGVwczpcblx0XHRcdHZhciBvLCBwcmV2PW9sZFN0ZXA7XG5cdFx0XHR3aGlsZSAoKG8gPSBwcmV2KSAmJiAocHJldiA9IG8ucHJldikpIHtcblx0XHRcdFx0aWYgKHByZXYucHJvcHMgPT09IG8ucHJvcHMpIHsgY29udGludWU7IH0gLy8gd2FpdCBzdGVwXG5cdFx0XHRcdGlmIChwcmV2LnByb3BzW25dICE9PSB1bmRlZmluZWQpIHsgYnJlYWs7IH0gLy8gYWxyZWFkeSBoYXMgYSB2YWx1ZSwgd2UncmUgZG9uZS5cblx0XHRcdFx0cHJldi5wcm9wc1tuXSA9IG9sZFByb3BzW25dO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRpZiAoc3RlcFBsdWdpbnMgIT09IGZhbHNlICYmIChwbHVnaW5zID0gdGhpcy5fcGx1Z2lucykpIHtcblx0XHRcdGZvciAoaSA9IHBsdWdpbnMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdHBsdWdpbnNbaV0uc3RlcCh0aGlzLCBzdGVwLCBjbGVhblByb3BzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0aWYgKGluamVjdCA9IHRoaXMuX2luamVjdGVkKSB7XG5cdFx0XHR0aGlzLl9pbmplY3RlZCA9IG51bGw7XG5cdFx0XHR0aGlzLl9hcHBlbmRQcm9wcyhpbmplY3QsIHN0ZXAsIGZhbHNlKTtcblx0XHR9XG5cdH07XG5cdFxuXHQvKipcblx0ICogVXNlZCBieSBwbHVnaW5zIHRvIGluamVjdCBwcm9wZXJ0aWVzIG9udG8gdGhlIGN1cnJlbnQgc3RlcC4gQ2FsbGVkIGZyb20gd2l0aGluIGBQbHVnaW4uc3RlcGAgY2FsbHMuXG5cdCAqIEZvciBleGFtcGxlLCBhIHBsdWdpbiBkZWFsaW5nIHdpdGggY29sb3IsIGNvdWxkIHJlYWQgYSBoZXggY29sb3IsIGFuZCBpbmplY3QgcmVkLCBncmVlbiwgYW5kIGJsdWUgcHJvcHMgaW50byB0aGUgdHdlZW4uXG5cdCAqIFNlZSB0aGUgU2FtcGxlUGx1Z2luIGZvciBtb3JlIGluZm8uXG5cdCAqIEBtZXRob2QgX2luamVjdFByb3Bcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0ICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2luamVjdFByb3AgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuXHRcdHZhciBvID0gdGhpcy5faW5qZWN0ZWQgfHwgKHRoaXMuX2luamVjdGVkID0ge30pO1xuXHRcdG9bbmFtZV0gPSB2YWx1ZTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfYWRkU3RlcFxuXHQgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb25cblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGVhc2Vcblx0ICogQHBhcmFtIHtCb29sZWFufSBwYXNzaXZlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2FkZFN0ZXAgPSBmdW5jdGlvbihkdXJhdGlvbiwgcHJvcHMsIGVhc2UsIHBhc3NpdmUpIHtcblx0XHR2YXIgc3RlcCA9IG5ldyBUd2VlblN0ZXAodGhpcy5fc3RlcFRhaWwsIHRoaXMuZHVyYXRpb24sIGR1cmF0aW9uLCBwcm9wcywgZWFzZSwgcGFzc2l2ZXx8ZmFsc2UpO1xuXHRcdHRoaXMuZHVyYXRpb24gKz0gZHVyYXRpb247XG5cdFx0cmV0dXJuIHRoaXMuX3N0ZXBUYWlsID0gKHRoaXMuX3N0ZXBUYWlsLm5leHQgPSBzdGVwKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfYWRkQWN0aW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdFxuXHQgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fYWRkQWN0aW9uID0gZnVuY3Rpb24oc2NvcGUsIGZ1bmN0LCBwYXJhbXMpIHtcblx0XHR2YXIgYWN0aW9uID0gbmV3IFR3ZWVuQWN0aW9uKHRoaXMuX2FjdGlvblRhaWwsIHRoaXMuZHVyYXRpb24sIHNjb3BlLCBmdW5jdCwgcGFyYW1zKTtcblx0XHRpZiAodGhpcy5fYWN0aW9uVGFpbCkgeyB0aGlzLl9hY3Rpb25UYWlsLm5leHQgPSBhY3Rpb247IH1cblx0XHRlbHNlIHsgdGhpcy5fYWN0aW9uSGVhZCA9IGFjdGlvbjsgfVxuXHRcdHRoaXMuX2FjdGlvblRhaWwgPSBhY3Rpb247XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3NldFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2V0ID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRmb3IgKHZhciBuIGluIHByb3BzKSB7XG5cdFx0XHR0aGlzW25dID0gcHJvcHNbbl07XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9jbG9uZVByb3BzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9jbG9uZVByb3BzID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHR2YXIgbyA9IHt9O1xuXHRcdGZvciAodmFyIG4gaW4gcHJvcHMpIHsgb1tuXSA9IHByb3BzW25dOyB9XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cblx0Y3JlYXRlanMuVHdlZW4gPSBjcmVhdGVqcy5wcm9tb3RlKFR3ZWVuLCBcIkFic3RyYWN0VHdlZW5cIik7XG5cdFxuXHRmdW5jdGlvbiBUd2VlblN0ZXAocHJldiwgdCwgZCwgcHJvcHMsIGVhc2UsIHBhc3NpdmUpIHtcblx0XHR0aGlzLm5leHQgPSBudWxsO1xuXHRcdHRoaXMucHJldiA9IHByZXY7XG5cdFx0dGhpcy50ID0gdDtcblx0XHR0aGlzLmQgPSBkO1xuXHRcdHRoaXMucHJvcHMgPSBwcm9wcztcblx0XHR0aGlzLmVhc2UgPSBlYXNlO1xuXHRcdHRoaXMucGFzc2l2ZSA9IHBhc3NpdmU7XG5cdFx0dGhpcy5pbmRleCA9IHByZXYgPyBwcmV2LmluZGV4KzEgOiAwO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gVHdlZW5BY3Rpb24ocHJldiwgdCwgc2NvcGUsIGZ1bmN0LCBwYXJhbXMpIHtcblx0XHR0aGlzLm5leHQgPSBudWxsO1xuXHRcdHRoaXMucHJldiA9IHByZXY7XG5cdFx0dGhpcy50ID0gdDtcblx0XHR0aGlzLmQgPSAwO1xuXHRcdHRoaXMuc2NvcGUgPSBzY29wZTtcblx0XHR0aGlzLmZ1bmN0ID0gZnVuY3Q7XG5cdFx0dGhpcy5wYXJhbXMgPSBwYXJhbXM7XG5cdH07XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVGltZWxpbmUuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbndpbmRvdy5jcmVhdGVqcyA9IHdpbmRvdy5jcmVhdGVqc3x8e307XG5cblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cbi8vIGNvbnN0cnVjdG9yXHRcblx0LyoqXG5cdCAqIFRoZSBUaW1lbGluZSBjbGFzcyBzeW5jaHJvbml6ZXMgbXVsdGlwbGUgdHdlZW5zIGFuZCBhbGxvd3MgdGhlbSB0byBiZSBjb250cm9sbGVkIGFzIGEgZ3JvdXAuIFBsZWFzZSBub3RlIHRoYXQgaWYgYVxuXHQgKiB0aW1lbGluZSBpcyBsb29waW5nLCB0aGUgdHdlZW5zIG9uIGl0IG1heSBhcHBlYXIgdG8gbG9vcCBldmVuIGlmIHRoZSBcImxvb3BcIiBwcm9wZXJ0eSBvZiB0aGUgdHdlZW4gaXMgZmFsc2UuXG5cdCAqIFxuXHQgKiBOT1RFOiBUaW1lbGluZSBjdXJyZW50bHkgYWxzbyBhY2NlcHRzIGEgcGFyYW0gbGlzdCBpbiB0aGUgZm9ybTogYHR3ZWVucywgbGFiZWxzLCBwcm9wc2AuIFRoaXMgaXMgZm9yIGJhY2t3YXJkc1xuXHQgKiBjb21wYXRpYmlsaXR5IG9ubHkgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLiBJbmNsdWRlIHR3ZWVucyBhbmQgbGFiZWxzIGFzIHByb3BlcnRpZXMgb24gdGhlIHByb3BzIG9iamVjdC5cblx0ICogQGNsYXNzIFRpbWVsaW5lXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIFRoZSBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgdG8gYXBwbHkgdG8gdGhpcyBpbnN0YW5jZSAoZXguIGB7bG9vcDotMSwgcGF1c2VkOnRydWV9YCkuXG5cdCAqIFN1cHBvcnRlZCBwcm9wcyBhcmUgbGlzdGVkIGJlbG93LiBUaGVzZSBwcm9wcyBhcmUgc2V0IG9uIHRoZSBjb3JyZXNwb25kaW5nIGluc3RhbmNlIHByb3BlcnRpZXMgZXhjZXB0IHdoZXJlXG5cdCAqIHNwZWNpZmllZC48VUw+XG5cdCAqICAgIDxMST4gYHVzZVRpY2tzYDwvTEk+XG5cdCAqICAgIDxMST4gYGlnbm9yZUdsb2JhbFBhdXNlYDwvTEk+XG5cdCAqICAgIDxMST4gYGxvb3BgPC9MST5cblx0ICogICAgPExJPiBgcmV2ZXJzZWRgPC9MST5cblx0ICogICAgPExJPiBgYm91bmNlYDwvTEk+XG5cdCAqICAgIDxMST4gYHRpbWVTY2FsZWA8L0xJPlxuXHQgKiAgICA8TEk+IGBwYXVzZWRgPC9MST5cblx0ICogICAgPExJPiBgcG9zaXRpb25gOiBpbmRpY2F0ZXMgdGhlIGluaXRpYWwgcG9zaXRpb24gZm9yIHRoaXMgdHdlZW4uPC9MST5cblx0ICogICAgPExJPiBgb25DaGFuZ2VgOiBhZGRzIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gYXMgYSBsaXN0ZW5lciB0byB0aGUgYGNoYW5nZWAgZXZlbnQ8L0xJPlxuXHQgKiAgICA8TEk+IGBvbkNvbXBsZXRlYDogYWRkcyB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIGFzIGEgbGlzdGVuZXIgdG8gdGhlIGBjb21wbGV0ZWAgZXZlbnQ8L0xJPlxuXHQgKiA8L1VMPlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdFR3ZWVuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIFRpbWVsaW5lKHByb3BzKSB7XG5cdFx0dmFyIHR3ZWVucywgbGFiZWxzO1xuXHRcdC8vIGhhbmRsZSBvbGQgcGFyYW1zICh0d2VlbnMsIGxhYmVscywgcHJvcHMpOlxuXHRcdC8vIFRPRE86IGRlcHJlY2F0ZWQuXG5cdFx0aWYgKHByb3BzIGluc3RhbmNlb2YgQXJyYXkgfHwgKHByb3BzID09IG51bGwgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDEpKSB7XG5cdFx0XHR0d2VlbnMgPSBwcm9wcztcblx0XHRcdGxhYmVscyA9IGFyZ3VtZW50c1sxXTtcblx0XHRcdHByb3BzID0gYXJndW1lbnRzWzJdO1xuXHRcdH0gZWxzZSBpZiAocHJvcHMpIHtcblx0XHRcdHR3ZWVucyA9IHByb3BzLnR3ZWVucztcblx0XHRcdGxhYmVscyA9IHByb3BzLmxhYmVscztcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5BYnN0cmFjdFR3ZWVuX2NvbnN0cnVjdG9yKHByb3BzKTtcblxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIGFycmF5IG9mIHR3ZWVucyBpbiB0aGUgdGltZWxpbmUuIEl0IGlzICpzdHJvbmdseSogcmVjb21tZW5kZWQgdGhhdCB5b3UgdXNlXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiVHdlZW4vYWRkVHdlZW5cIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlR3ZWVuL3JlbW92ZVR3ZWVuXCJ9fXt7L2Nyb3NzTGlua319LFxuXHRcdCAqIHJhdGhlciB0aGFuIGFjY2Vzc2luZyB0aGlzIGRpcmVjdGx5LCBidXQgaXQgaXMgaW5jbHVkZWQgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdFx0ICogQHByb3BlcnR5IHR3ZWVuc1xuXHRcdCAqIEB0eXBlIEFycmF5XG5cdFx0ICoqL1xuXHRcdHRoaXMudHdlZW5zID0gW107XG5cdFx0XG5cdFx0aWYgKHR3ZWVucykgeyB0aGlzLmFkZFR3ZWVuLmFwcGx5KHRoaXMsIHR3ZWVucyk7IH1cblx0XHR0aGlzLnNldExhYmVscyhsYWJlbHMpO1xuXHRcdFxuXHRcdHRoaXMuX2luaXQocHJvcHMpO1xuXHR9O1xuXHRcblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoVGltZWxpbmUsIGNyZWF0ZWpzLkFic3RyYWN0VHdlZW4pO1xuXG5cdFxuLy8gZXZlbnRzOlxuXHQvLyBkb2NjZWQgaW4gQWJzdHJhY3RUd2Vlbi5cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEFkZHMgb25lIG9yIG1vcmUgdHdlZW5zIChvciB0aW1lbGluZXMpIHRvIHRoaXMgdGltZWxpbmUuIFRoZSB0d2VlbnMgd2lsbCBiZSBwYXVzZWQgKHRvIHJlbW92ZSB0aGVtIGZyb20gdGhlXG5cdCAqIG5vcm1hbCB0aWNraW5nIHN5c3RlbSkgYW5kIG1hbmFnZWQgYnkgdGhpcyB0aW1lbGluZS4gQWRkaW5nIGEgdHdlZW4gdG8gbXVsdGlwbGUgdGltZWxpbmVzIHdpbGwgcmVzdWx0IGluXG5cdCAqIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLlxuXHQgKiBAbWV0aG9kIGFkZFR3ZWVuXG5cdCAqIEBwYXJhbSB7VHdlZW59IC4uLnR3ZWVuIFRoZSB0d2VlbihzKSB0byBhZGQuIEFjY2VwdHMgbXVsdGlwbGUgYXJndW1lbnRzLlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhlIGZpcnN0IHR3ZWVuIHRoYXQgd2FzIHBhc3NlZCBpbi5cblx0ICoqL1xuXHRwLmFkZFR3ZWVuID0gZnVuY3Rpb24odHdlZW4pIHtcblx0XHRpZiAodHdlZW4uX3BhcmVudCkgeyB0d2Vlbi5fcGFyZW50LnJlbW92ZVR3ZWVuKHR3ZWVuKTsgfVxuXHRcdFxuXHRcdHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRpZiAobCA+IDEpIHtcblx0XHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKyspIHsgdGhpcy5hZGRUd2Vlbihhcmd1bWVudHNbaV0pOyB9XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzW2wtMV07XG5cdFx0fSBlbHNlIGlmIChsID09PSAwKSB7IHJldHVybiBudWxsOyB9XG5cdFx0XG5cdFx0dGhpcy50d2VlbnMucHVzaCh0d2Vlbik7XG5cdFx0dHdlZW4uX3BhcmVudCA9IHRoaXM7XG5cdFx0dHdlZW4ucGF1c2VkID0gdHJ1ZTtcblx0XHR2YXIgZCA9IHR3ZWVuLmR1cmF0aW9uO1xuXHRcdGlmICh0d2Vlbi5sb29wID4gMCkgeyBkICo9IHR3ZWVuLmxvb3ArMTsgfVxuXHRcdGlmIChkID4gdGhpcy5kdXJhdGlvbikgeyB0aGlzLmR1cmF0aW9uID0gZDsgfVxuXHRcdFxuXHRcdGlmICh0aGlzLnJhd1Bvc2l0aW9uID49IDApIHsgdHdlZW4uc2V0UG9zaXRpb24odGhpcy5yYXdQb3NpdGlvbik7IH1cblx0XHRyZXR1cm4gdHdlZW47XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgb25lIG9yIG1vcmUgdHdlZW5zIGZyb20gdGhpcyB0aW1lbGluZS5cblx0ICogQG1ldGhvZCByZW1vdmVUd2VlblxuXHQgKiBAcGFyYW0ge1R3ZWVufSAuLi50d2VlbiBUaGUgdHdlZW4ocykgdG8gcmVtb3ZlLiBBY2NlcHRzIG11bHRpcGxlIGFyZ3VtZW50cy5cblx0ICogQHJldHVybiBCb29sZWFuIFJldHVybnMgYHRydWVgIGlmIGFsbCBvZiB0aGUgdHdlZW5zIHdlcmUgc3VjY2Vzc2Z1bGx5IHJlbW92ZWQuXG5cdCAqKi9cblx0cC5yZW1vdmVUd2VlbiA9IGZ1bmN0aW9uKHR3ZWVuKSB7XG5cdFx0dmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdGlmIChsID4gMSkge1xuXHRcdFx0dmFyIGdvb2QgPSB0cnVlO1xuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykgeyBnb29kID0gZ29vZCAmJiB0aGlzLnJlbW92ZVR3ZWVuKGFyZ3VtZW50c1tpXSk7IH1cblx0XHRcdHJldHVybiBnb29kO1xuXHRcdH0gZWxzZSBpZiAobCA9PT0gMCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0dmFyIHR3ZWVucyA9IHRoaXMudHdlZW5zO1xuXHRcdHZhciBpID0gdHdlZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRpZiAodHdlZW5zW2ldID09PSB0d2Vlbikge1xuXHRcdFx0XHR0d2VlbnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR0d2Vlbi5fcGFyZW50ID0gbnVsbDtcblx0XHRcdFx0aWYgKHR3ZWVuLmR1cmF0aW9uID49IHRoaXMuZHVyYXRpb24pIHsgdGhpcy51cGRhdGVEdXJhdGlvbigpOyB9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlY2FsY3VsYXRlcyB0aGUgZHVyYXRpb24gb2YgdGhlIHRpbWVsaW5lLiBUaGUgZHVyYXRpb24gaXMgYXV0b21hdGljYWxseSB1cGRhdGVkIHdoZW4gdHdlZW5zIGFyZSBhZGRlZCBvciByZW1vdmVkLFxuXHQgKiBidXQgdGhpcyBtZXRob2QgaXMgdXNlZnVsIGlmIHlvdSBtb2RpZnkgYSB0d2VlbiBhZnRlciBpdCB3YXMgYWRkZWQgdG8gdGhlIHRpbWVsaW5lLlxuXHQgKiBAbWV0aG9kIHVwZGF0ZUR1cmF0aW9uXG5cdCAqKi9cblx0cC51cGRhdGVEdXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZHVyYXRpb24gPSAwO1xuXHRcdGZvciAodmFyIGk9MCxsPXRoaXMudHdlZW5zLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMudHdlZW5zW2ldO1xuXHRcdFx0dmFyIGQgPSB0d2Vlbi5kdXJhdGlvbjtcblx0XHRcdGlmICh0d2Vlbi5sb29wID4gMCkgeyBkICo9IHR3ZWVuLmxvb3ArMTsgfVxuXHRcdFx0aWYgKGQgPiB0aGlzLmR1cmF0aW9uKSB7IHRoaXMuZHVyYXRpb24gPSBkOyB9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCogQG1ldGhvZCB0b1N0cmluZ1xuXHQqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltUaW1lbGluZV1cIjtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRocm93KFwiVGltZWxpbmUgY2FuIG5vdCBiZSBjbG9uZWQuXCIpXG5cdH07XG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0XG5cdC8vIERvY2NlZCBpbiBBYnN0cmFjdFR3ZWVuXG5cdHAuX3VwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24oanVtcCwgZW5kKSB7XG5cdFx0dmFyIHQgPSB0aGlzLnBvc2l0aW9uO1xuXHRcdGZvciAodmFyIGk9MCwgbD10aGlzLnR3ZWVucy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR0aGlzLnR3ZWVuc1tpXS5zZXRQb3NpdGlvbih0LCB0cnVlLCBqdW1wKTsgLy8gYWN0aW9ucyB3aWxsIHJ1biBhZnRlciBhbGwgdGhlIHR3ZWVucyB1cGRhdGUuXG5cdFx0fVxuXHR9O1xuXHRcblx0Ly8gRG9jY2VkIGluIEFic3RyYWN0VHdlZW5cblx0cC5fcnVuQWN0aW9uc1JhbmdlID0gZnVuY3Rpb24oc3RhcnRQb3MsIGVuZFBvcywganVtcCwgaW5jbHVkZVN0YXJ0KSB7XG5cdFx0Ly9jb25zb2xlLmxvZyhcIlx0cmFuZ2VcIiwgc3RhcnRQb3MsIGVuZFBvcywganVtcCwgaW5jbHVkZVN0YXJ0KTtcblx0XHR2YXIgdCA9IHRoaXMucG9zaXRpb247XG5cdFx0Zm9yICh2YXIgaT0wLCBsPXRoaXMudHdlZW5zLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdHRoaXMudHdlZW5zW2ldLl9ydW5BY3Rpb25zKHN0YXJ0UG9zLCBlbmRQb3MsIGp1bXAsIGluY2x1ZGVTdGFydCk7XG5cdFx0XHRpZiAodCAhPT0gdGhpcy5wb3NpdGlvbikgeyByZXR1cm4gdHJ1ZTsgfSAvLyBhbiBhY3Rpb24gY2hhbmdlZCB0aGlzIHRpbWVsaW5lJ3MgcG9zaXRpb24uXG5cdFx0fVxuXHR9O1xuXG5cblx0Y3JlYXRlanMuVGltZWxpbmUgPSBjcmVhdGVqcy5wcm9tb3RlKFRpbWVsaW5lLCBcIkFic3RyYWN0VHdlZW5cIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBFYXNlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG53aW5kb3cuY3JlYXRlanMgPSB3aW5kb3cuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgRWFzZSBjbGFzcyBwcm92aWRlcyBhIGNvbGxlY3Rpb24gb2YgZWFzaW5nIGZ1bmN0aW9ucyBmb3IgdXNlIHdpdGggVHdlZW5KUy4gSXQgZG9lcyBub3QgdXNlIHRoZSBzdGFuZGFyZCA0IHBhcmFtXG5cdCAqIGVhc2luZyBzaWduYXR1cmUuIEluc3RlYWQgaXQgdXNlcyBhIHNpbmdsZSBwYXJhbSB3aGljaCBpbmRpY2F0ZXMgdGhlIGN1cnJlbnQgbGluZWFyIHJhdGlvICgwIHRvIDEpIG9mIHRoZSB0d2Vlbi5cblx0ICpcblx0ICogTW9zdCBtZXRob2RzIG9uIEVhc2UgY2FuIGJlIHBhc3NlZCBkaXJlY3RseSBhcyBlYXNpbmcgZnVuY3Rpb25zOlxuXHQgKlxuXHQgKiAgICAgIFR3ZWVuLmdldCh0YXJnZXQpLnRvKHt4OjEwMH0sIDUwMCwgRWFzZS5saW5lYXIpO1xuXHQgKlxuXHQgKiBIb3dldmVyLCBtZXRob2RzIGJlZ2lubmluZyB3aXRoIFwiZ2V0XCIgd2lsbCByZXR1cm4gYW4gZWFzaW5nIGZ1bmN0aW9uIGJhc2VkIG9uIHBhcmFtZXRlciB2YWx1ZXM6XG5cdCAqXG5cdCAqICAgICAgVHdlZW4uZ2V0KHRhcmdldCkudG8oe3k6MjAwfSwgNTAwLCBFYXNlLmdldFBvd0luKDIuMikpO1xuXHQgKlxuXHQgKiBQbGVhc2Ugc2VlIHRoZSA8YSBocmVmPVwiaHR0cDovL3d3dy5jcmVhdGVqcy5jb20vRGVtb3MvVHdlZW5KUy9Ud2Vlbl9TcGFya1RhYmxlXCI+c3BhcmsgdGFibGUgZGVtbzwvYT4gZm9yIGFuXG5cdCAqIG92ZXJ2aWV3IG9mIHRoZSBkaWZmZXJlbnQgZWFzZSB0eXBlcyBvbiA8YSBocmVmPVwiaHR0cDovL3R3ZWVuanMuY29tXCI+VHdlZW5KUy5jb208L2E+LlxuXHQgKlxuXHQgKiA8ZW0+RXF1YXRpb25zIGRlcml2ZWQgZnJvbSB3b3JrIGJ5IFJvYmVydCBQZW5uZXIuPC9lbT5cblx0ICogQGNsYXNzIEVhc2Vcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdGZ1bmN0aW9uIEVhc2UoKSB7XG5cdFx0dGhyb3cgXCJFYXNlIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWQuXCI7XG5cdH1cblxuXG4vLyBzdGF0aWMgbWV0aG9kcyBhbmQgcHJvcGVydGllc1xuXHQvKipcblx0ICogQG1ldGhvZCBsaW5lYXJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5saW5lYXIgPSBmdW5jdGlvbih0KSB7IHJldHVybiB0OyB9O1xuXG5cdC8qKlxuXHQgKiBJZGVudGljYWwgdG8gbGluZWFyLlxuXHQgKiBAbWV0aG9kIG5vbmVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5ub25lID0gRWFzZS5saW5lYXI7XG5cblx0LyoqXG5cdCAqIE1pbWljcyB0aGUgc2ltcGxlIC0xMDAgdG8gMTAwIGVhc2luZyBpbiBBZG9iZSBGbGFzaC9BbmltYXRlLlxuXHQgKiBAbWV0aG9kIGdldFxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IEEgdmFsdWUgZnJvbSAtMSAoZWFzZSBpbikgdG8gMSAoZWFzZSBvdXQpIGluZGljYXRpbmcgdGhlIHN0cmVuZ3RoIGFuZCBkaXJlY3Rpb24gb2YgdGhlIGVhc2UuXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXQgPSBmdW5jdGlvbihhbW91bnQpIHtcblx0XHRpZiAoYW1vdW50IDwgLTEpIHsgYW1vdW50ID0gLTE7IH1cblx0XHRlbHNlIGlmIChhbW91bnQgPiAxKSB7IGFtb3VudCA9IDE7IH1cblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0aWYgKGFtb3VudD09MCkgeyByZXR1cm4gdDsgfVxuXHRcdFx0aWYgKGFtb3VudDwwKSB7IHJldHVybiB0Kih0Ki1hbW91bnQrMSthbW91bnQpOyB9XG5cdFx0XHRyZXR1cm4gdCooKDItdCkqYW1vdW50KygxLWFtb3VudCkpO1xuXHRcdH07XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBleHBvbmVudGlhbCBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldFBvd0luXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3cgVGhlIGV4cG9uZW50IHRvIHVzZSAoZXguIDMgd291bGQgcmV0dXJuIGEgY3ViaWMgZWFzZSkuXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRQb3dJbiA9IGZ1bmN0aW9uKHBvdykge1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5wb3codCxwb3cpO1xuXHRcdH07XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBleHBvbmVudGlhbCBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldFBvd091dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG93IFRoZSBleHBvbmVudCB0byB1c2UgKGV4LiAzIHdvdWxkIHJldHVybiBhIGN1YmljIGVhc2UpLlxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0UG93T3V0ID0gZnVuY3Rpb24ocG93KSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiAxLU1hdGgucG93KDEtdCxwb3cpO1xuXHRcdH07XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBleHBvbmVudGlhbCBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldFBvd0luT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3cgVGhlIGV4cG9uZW50IHRvIHVzZSAoZXguIDMgd291bGQgcmV0dXJuIGEgY3ViaWMgZWFzZSkuXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRQb3dJbk91dCA9IGZ1bmN0aW9uKHBvdykge1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRpZiAoKHQqPTIpPDEpIHJldHVybiAwLjUqTWF0aC5wb3codCxwb3cpO1xuXHRcdFx0cmV0dXJuIDEtMC41Kk1hdGguYWJzKE1hdGgucG93KDItdCxwb3cpKTtcblx0XHR9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1YWRJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1YWRJbiA9IEVhc2UuZ2V0UG93SW4oMik7XG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1YWRPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWFkT3V0ID0gRWFzZS5nZXRQb3dPdXQoMik7XG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1YWRJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1YWRJbk91dCA9IEVhc2UuZ2V0UG93SW5PdXQoMik7XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgY3ViaWNJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmN1YmljSW4gPSBFYXNlLmdldFBvd0luKDMpO1xuXHQvKipcblx0ICogQG1ldGhvZCBjdWJpY091dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmN1YmljT3V0ID0gRWFzZS5nZXRQb3dPdXQoMyk7XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGN1YmljSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5jdWJpY0luT3V0ID0gRWFzZS5nZXRQb3dJbk91dCgzKTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBxdWFydEluXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVhcnRJbiA9IEVhc2UuZ2V0UG93SW4oNCk7XG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1YXJ0T3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVhcnRPdXQgPSBFYXNlLmdldFBvd091dCg0KTtcblx0LyoqXG5cdCAqIEBtZXRob2QgcXVhcnRJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1YXJ0SW5PdXQgPSBFYXNlLmdldFBvd0luT3V0KDQpO1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1aW50SW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWludEluID0gRWFzZS5nZXRQb3dJbig1KTtcblx0LyoqXG5cdCAqIEBtZXRob2QgcXVpbnRPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWludE91dCA9IEVhc2UuZ2V0UG93T3V0KDUpO1xuXHQvKipcblx0ICogQG1ldGhvZCBxdWludEluT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVpbnRJbk91dCA9IEVhc2UuZ2V0UG93SW5PdXQoNSk7XG5cblx0LyoqXG5cdCAqIEBtZXRob2Qgc2luZUluXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2Uuc2luZUluID0gZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAxLU1hdGguY29zKHQqTWF0aC5QSS8yKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBzaW5lT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2Uuc2luZU91dCA9IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gTWF0aC5zaW4odCpNYXRoLlBJLzIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHNpbmVJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnNpbmVJbk91dCA9IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLTAuNSooTWF0aC5jb3MoTWF0aC5QSSp0KSAtIDEpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb25maWd1cmFibGUgXCJiYWNrIGluXCIgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRCYWNrSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCBUaGUgc3RyZW5ndGggb2YgdGhlIGVhc2UuXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRCYWNrSW4gPSBmdW5jdGlvbihhbW91bnQpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0cmV0dXJuIHQqdCooKGFtb3VudCsxKSp0LWFtb3VudCk7XG5cdFx0fTtcblx0fTtcblx0LyoqXG5cdCAqIEBtZXRob2QgYmFja0luXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuYmFja0luID0gRWFzZS5nZXRCYWNrSW4oMS43KTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIFwiYmFjayBvdXRcIiBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldEJhY2tPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCBUaGUgc3RyZW5ndGggb2YgdGhlIGVhc2UuXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRCYWNrT3V0ID0gZnVuY3Rpb24oYW1vdW50KSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiAoLS10KnQqKChhbW91bnQrMSkqdCArIGFtb3VudCkgKyAxKTtcblx0XHR9O1xuXHR9O1xuXHQvKipcblx0ICogQG1ldGhvZCBiYWNrT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuYmFja091dCA9IEVhc2UuZ2V0QmFja091dCgxLjcpO1xuXG5cdC8qKlxuXHQgKiBDb25maWd1cmFibGUgXCJiYWNrIGluIG91dFwiIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0QmFja0luT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgVGhlIHN0cmVuZ3RoIG9mIHRoZSBlYXNlLlxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0QmFja0luT3V0ID0gZnVuY3Rpb24oYW1vdW50KSB7XG5cdFx0YW1vdW50Kj0xLjUyNTtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0aWYgKCh0Kj0yKTwxKSByZXR1cm4gMC41Kih0KnQqKChhbW91bnQrMSkqdC1hbW91bnQpKTtcblx0XHRcdHJldHVybiAwLjUqKCh0LT0yKSp0KigoYW1vdW50KzEpKnQrYW1vdW50KSsyKTtcblx0XHR9O1xuXHR9O1xuXHQvKipcblx0ICogQG1ldGhvZCBiYWNrSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5iYWNrSW5PdXQgPSBFYXNlLmdldEJhY2tJbk91dCgxLjcpO1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGNpcmNJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmNpcmNJbiA9IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLShNYXRoLnNxcnQoMS10KnQpLSAxKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBjaXJjT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuY2lyY091dCA9IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KDEtKC0tdCkqdCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgY2lyY0luT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuY2lyY0luT3V0ID0gZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCo9MikgPCAxKSByZXR1cm4gLTAuNSooTWF0aC5zcXJ0KDEtdCp0KS0xKTtcblx0XHRyZXR1cm4gMC41KihNYXRoLnNxcnQoMS0odC09MikqdCkrMSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgYm91bmNlSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5ib3VuY2VJbiA9IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gMS1FYXNlLmJvdW5jZU91dCgxLXQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGJvdW5jZU91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmJvdW5jZU91dCA9IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodCA8IDEvMi43NSkge1xuXHRcdFx0cmV0dXJuICg3LjU2MjUqdCp0KTtcblx0XHR9IGVsc2UgaWYgKHQgPCAyLzIuNzUpIHtcblx0XHRcdHJldHVybiAoNy41NjI1Kih0LT0xLjUvMi43NSkqdCswLjc1KTtcblx0XHR9IGVsc2UgaWYgKHQgPCAyLjUvMi43NSkge1xuXHRcdFx0cmV0dXJuICg3LjU2MjUqKHQtPTIuMjUvMi43NSkqdCswLjkzNzUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gKDcuNTYyNSoodC09Mi42MjUvMi43NSkqdCArMC45ODQzNzUpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBib3VuY2VJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmJvdW5jZUluT3V0ID0gZnVuY3Rpb24odCkge1xuXHRcdGlmICh0PDAuNSkgcmV0dXJuIEVhc2UuYm91bmNlSW4gKHQqMikgKiAuNTtcblx0XHRyZXR1cm4gRWFzZS5ib3VuY2VPdXQodCoyLTEpKjAuNSswLjU7XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBlbGFzdGljIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0RWxhc3RpY0luXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbXBsaXR1ZGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBlcmlvZFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0RWxhc3RpY0luID0gZnVuY3Rpb24oYW1wbGl0dWRlLHBlcmlvZCkge1xuXHRcdHZhciBwaTIgPSBNYXRoLlBJKjI7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdGlmICh0PT0wIHx8IHQ9PTEpIHJldHVybiB0O1xuXHRcdFx0dmFyIHMgPSBwZXJpb2QvcGkyKk1hdGguYXNpbigxL2FtcGxpdHVkZSk7XG5cdFx0XHRyZXR1cm4gLShhbXBsaXR1ZGUqTWF0aC5wb3coMiwxMCoodC09MSkpKk1hdGguc2luKCh0LXMpKnBpMi9wZXJpb2QpKTtcblx0XHR9O1xuXHR9O1xuXHQvKipcblx0ICogQG1ldGhvZCBlbGFzdGljSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5lbGFzdGljSW4gPSBFYXNlLmdldEVsYXN0aWNJbigxLDAuMyk7XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBlbGFzdGljIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0RWxhc3RpY091dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW1wbGl0dWRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwZXJpb2Rcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldEVsYXN0aWNPdXQgPSBmdW5jdGlvbihhbXBsaXR1ZGUscGVyaW9kKSB7XG5cdFx0dmFyIHBpMiA9IE1hdGguUEkqMjtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0aWYgKHQ9PTAgfHwgdD09MSkgcmV0dXJuIHQ7XG5cdFx0XHR2YXIgcyA9IHBlcmlvZC9waTIgKiBNYXRoLmFzaW4oMS9hbXBsaXR1ZGUpO1xuXHRcdFx0cmV0dXJuIChhbXBsaXR1ZGUqTWF0aC5wb3coMiwtMTAqdCkqTWF0aC5zaW4oKHQtcykqcGkyL3BlcmlvZCApKzEpO1xuXHRcdH07XG5cdH07XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGVsYXN0aWNPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5lbGFzdGljT3V0ID0gRWFzZS5nZXRFbGFzdGljT3V0KDEsMC4zKTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIGVsYXN0aWMgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRFbGFzdGljSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFtcGxpdHVkZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcGVyaW9kXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRFbGFzdGljSW5PdXQgPSBmdW5jdGlvbihhbXBsaXR1ZGUscGVyaW9kKSB7XG5cdFx0dmFyIHBpMiA9IE1hdGguUEkqMjtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0dmFyIHMgPSBwZXJpb2QvcGkyICogTWF0aC5hc2luKDEvYW1wbGl0dWRlKTtcblx0XHRcdGlmICgodCo9Mik8MSkgcmV0dXJuIC0wLjUqKGFtcGxpdHVkZSpNYXRoLnBvdygyLDEwKih0LT0xKSkqTWF0aC5zaW4oICh0LXMpKnBpMi9wZXJpb2QgKSk7XG5cdFx0XHRyZXR1cm4gYW1wbGl0dWRlKk1hdGgucG93KDIsLTEwKih0LT0xKSkqTWF0aC5zaW4oKHQtcykqcGkyL3BlcmlvZCkqMC41KzE7XG5cdFx0fTtcblx0fTtcblx0LyoqXG5cdCAqIEBtZXRob2QgZWxhc3RpY0luT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuZWxhc3RpY0luT3V0ID0gRWFzZS5nZXRFbGFzdGljSW5PdXQoMSwwLjMqMS41KTtcblxuXHRjcmVhdGVqcy5FYXNlID0gRWFzZTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIE1vdGlvbkd1aWRlUGx1Z2luLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG53aW5kb3cuY3JlYXRlanMgPSB3aW5kb3cuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBBIFR3ZWVuSlMgcGx1Z2luIGZvciB3b3JraW5nIHdpdGggbW90aW9uIGd1aWRlcy4gRGVmaW5lZCBwYXRocyB3aGljaCBvYmplY3RzIGNhbiBmb2xsb3cgb3Igb3JpZW50IGFsb25nLlxuXHQgKlxuXHQgKiBUbyB1c2UgdGhlIHBsdWdpbiwgaW5zdGFsbCB0aGUgcGx1Z2luIGFmdGVyIFR3ZWVuSlMgaGFzIGxvYWRlZC4gVG8gZGVmaW5lIGEgcGF0aCwgYWRkXG5cdCAqXG5cdCAqIFx0XHRjcmVhdGVqcy5Nb3Rpb25HdWlkZVBsdWdpbi5pbnN0YWxsKCk7XG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogXHRcdC8vIFVzaW5nIGEgTW90aW9uIEd1aWRlXG5cdCAqIFx0XHRjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0KS50byh7Z3VpZGU6eyBwYXRoOlswLDAsIDAsMjAwLDIwMCwyMDAsIDIwMCwwLDAsMF0gfX0sNzAwMCk7XG5cdCAqIFx0XHQvLyBWaXN1YWxpemluZyB0aGUgbGluZVxuXHQgKiBcdFx0Z3JhcGhpY3MubW92ZVRvKDAsMCkuY3VydmVUbygwLDIwMCwyMDAsMjAwKS5jdXJ2ZVRvKDIwMCwwLDAsMCk7XG5cdCAqXG5cdCAqIEVhY2ggcGF0aCBuZWVkcyBwcmUtY29tcHV0YXRpb24gdG8gZW5zdXJlIHRoZXJlJ3MgZmFzdCBwZXJmb3JtYW5jZS4gQmVjYXVzZSBvZiB0aGUgcHJlLWNvbXB1dGF0aW9uIHRoZXJlJ3Mgbm9cblx0ICogYnVpbHQgaW4gc3VwcG9ydCBmb3IgcGF0aCBjaGFuZ2VzIG1pZCB0d2Vlbi4gVGhlc2UgYXJlIHRoZSBHdWlkZSBPYmplY3QncyBwcm9wZXJ0aWVzOjxVTD5cblx0ICogXHRcdDxMST4gcGF0aDogUmVxdWlyZWQsIEFycmF5IDogVGhlIHgveSBwb2ludHMgdXNlZCB0byBkcmF3IHRoZSBwYXRoIHdpdGggYSBtb3ZlVG8gYW5kIDEgdG8gbiBjdXJ2ZVRvIGNhbGxzLjwvTEk+XG5cdCAqIFx0XHQ8TEk+IHN0YXJ0OiBPcHRpb25hbCwgMC0xIDogSW5pdGlhbCBwb3NpdGlvbiwgZGVmYXVsdCAwIGV4Y2VwdCBmb3Igd2hlbiBjb250aW51aW5nIGFsb25nIHRoZSBzYW1lIHBhdGguPC9MST5cblx0ICogXHRcdDxMST4gZW5kOiBPcHRpb25hbCwgMC0xIDogRmluYWwgcG9zaXRpb24sIGRlZmF1bHQgMSBpZiBub3Qgc3BlY2lmaWVkLjwvTEk+XG5cdCAqIFx0XHQ8TEk+IG9yaWVudDogT3B0aW9uYWwsIHN0cmluZyA6IFwiZml4ZWRcIi9cImF1dG9cIi9cImN3XCIvXCJjY3dcIjxVTD5cblx0ICpcdFx0XHRcdDxMST5cImZpeGVkXCIgZm9yY2VzIHRoZSBvYmplY3QgdG8gZmFjZSBkb3duIHRoZSBwYXRoIGFsbCBtb3ZlbWVudCAocmVsYXRpdmUgdG8gc3RhcnQgcm90YXRpb24pLDwvTEk+XG5cdCAqIFx0XHRcdFx0PExJPlwiYXV0b1wiIHJvdGF0ZXMgdGhlIG9iamVjdCBhbG9uZyB0aGUgcGF0aCByZWxhdGl2ZSB0byB0aGUgbGluZS48L0xJPlxuXHQgKiBcdFx0XHRcdDxMST5cImN3XCIvXCJjY3dcIiBmb3JjZSBjbG9ja3dpc2Ugb3IgY291bnRlciBjbG9ja3dpc2Ugcm90YXRpb25zIGluY2x1ZGluZyBBZG9iZSBGbGFzaC9BbmltYXRlLWxpa2Vcblx0ICogXHRcdFx0XHRiZWhhdmlvdXIuIFRoaXMgbWF5IG92ZXJyaWRlIHlvdXIgZW5kIHJvdGF0aW9uIHZhbHVlLjwvTEk+XG5cdCAqIFx0XHQ8L1VMPjwvTEk+XG5cdCAqIDwvVUw+XG5cdCAqIEd1aWRlIG9iamVjdHMgc2hvdWxkIG5vdCBiZSBzaGFyZWQgYmV0d2VlbiB0d2VlbnMgZXZlbiBpZiBhbGwgcHJvcGVydGllcyBhcmUgaWRlbnRpY2FsLCB0aGUgbGlicmFyeSBzdG9yZXNcblx0ICogaW5mb3JtYXRpb24gb24gdGhlc2Ugb2JqZWN0cyBpbiB0aGUgYmFja2dyb3VuZCBhbmQgc2hhcmluZyB0aGVtIGNhbiBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW91ci4gVmFsdWVzXG5cdCAqIG91dHNpZGUgMC0xIHJhbmdlIG9mIHR3ZWVucyB3aWxsIGJlIGEgXCJiZXN0IGd1ZXNzXCIgZnJvbSB0aGUgYXBwcm9wcmlhdGUgcGFydCBvZiB0aGUgZGVmaW5lZCBjdXJ2ZS5cblx0ICpcblx0ICogQGNsYXNzIE1vdGlvbkd1aWRlUGx1Z2luXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gTW90aW9uR3VpZGVQbHVnaW4oKSB7XG5cdFx0dGhyb3coXCJNb3Rpb25HdWlkZVBsdWdpbiBjYW5ub3QgYmUgaW5zdGFudGlhdGVkLlwiKVxuXHR9XG5cdHZhciBzID0gTW90aW9uR3VpZGVQbHVnaW47XG5cblxuLy8gc3RhdGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcHJpb3JpdHlcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLnByaW9yaXR5ID0gMDsgLy8gaGlnaCBwcmlvcml0eSwgc2hvdWxkIHJ1biBzb29uZXJcblxuXHQvKipcblx0ICogUkVBRC1PTkxZLiBBIHVuaXF1ZSBpZGVudGlmeWluZyBzdHJpbmcgZm9yIHRoaXMgcGx1Z2luLiBVc2VkIGJ5IFR3ZWVuSlMgdG8gZW5zdXJlIGR1cGxpY2F0ZSBwbHVnaW5zIGFyZSBub3QgaW5zdGFsbGVkIG9uIGEgdHdlZW4uXG5cdCAqIEBwcm9wZXJ0eSBJRFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAc3RhdGljXG5cdCAqIEByZWFkb25seVxuXHQgKi9cblx0cy5JRCA9IFwiTW90aW9uR3VpZGVcIjtcblxuLy8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIEluc3RhbGxzIHRoaXMgcGx1Z2luIGZvciB1c2Ugd2l0aCBUd2VlbkpTLiBDYWxsIHRoaXMgb25jZSBhZnRlciBUd2VlbkpTIGlzIGxvYWRlZCB0byBlbmFibGUgdGhpcyBwbHVnaW4uXG5cdCAqIEBtZXRob2QgaW5zdGFsbFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmluc3RhbGwgPSBmdW5jdGlvbigpIHtcblx0XHRjcmVhdGVqcy5Ud2Vlbi5faW5zdGFsbFBsdWdpbihNb3Rpb25HdWlkZVBsdWdpbik7XG5cdFx0cmV0dXJuIGNyZWF0ZWpzLlR3ZWVuLklHTk9SRTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIGJ5IFR3ZWVuSlMgd2hlbiBhIG5ldyBwcm9wZXJ0eSBpbml0aWFsaXplcyBvbiBhIHR3ZWVuLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiU2FtcGxlUGx1Z2luL2luaXRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mby5cblx0ICogQG1ldGhvZCBpbml0XG5cdCAqIEBwYXJhbSB7VHdlZW59IHR3ZWVuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG5cdCAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuXHQgKiBAcmV0dXJuIHthbnl9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaW5pdCA9IGZ1bmN0aW9uKHR3ZWVuLCBwcm9wLCB2YWx1ZSkge1xuXHRcdGlmKHByb3AgPT0gXCJndWlkZVwiKSB7XG5cdFx0XHR0d2Vlbi5fYWRkUGx1Z2luKHMpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gYSBuZXcgc3RlcCBpcyBhZGRlZCB0byBhIHR3ZWVuIChpZS4gYSBuZXcgXCJ0b1wiIGFjdGlvbiBpcyBhZGRlZCB0byBhIHR3ZWVuKS5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlNhbXBsZVBsdWdpbi9zdGVwXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm8uXG5cdCAqIEBtZXRob2Qgc3RlcFxuXHQgKiBAcGFyYW0ge1R3ZWVufSB0d2VlblxuXHQgKiBAcGFyYW0ge1R3ZWVuU3RlcH0gc3RlcFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5zdGVwID0gZnVuY3Rpb24odHdlZW4sIHN0ZXAsIHByb3BzKSB7XG5cdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykge1xuXHRcdFx0aWYobiAhPT0gXCJndWlkZVwiKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdHZhciBndWlkZURhdGEgPSBzdGVwLnByb3BzLmd1aWRlO1xuXHRcdFx0dmFyIGVycm9yID0gcy5fc29sdmVHdWlkZURhdGEocHJvcHMuZ3VpZGUsIGd1aWRlRGF0YSk7XG5cdFx0XHRndWlkZURhdGEudmFsaWQgPSAhZXJyb3I7XG5cblx0XHRcdHZhciBlbmQgPSBndWlkZURhdGEuZW5kRGF0YTtcblx0XHRcdHR3ZWVuLl9pbmplY3RQcm9wKFwieFwiLCBlbmQueCk7XG5cdFx0XHR0d2Vlbi5faW5qZWN0UHJvcChcInlcIiwgZW5kLnkpO1xuXG5cdFx0XHRpZihlcnJvciB8fCAhZ3VpZGVEYXRhLm9yaWVudCkgeyBicmVhazsgfVxuXG5cdFx0XHR2YXIgaW5pdFJvdCA9IHN0ZXAucHJldi5wcm9wcy5yb3RhdGlvbiA9PT0gdW5kZWZpbmVkID8gKHR3ZWVuLnRhcmdldC5yb3RhdGlvbiB8fCAwKSA6IHN0ZXAucHJldi5wcm9wcy5yb3RhdGlvbjtcblxuXHRcdFx0Z3VpZGVEYXRhLnN0YXJ0T2Zmc2V0Um90ID0gaW5pdFJvdCAtIGd1aWRlRGF0YS5zdGFydERhdGEucm90YXRpb247XG5cblx0XHRcdGlmKGd1aWRlRGF0YS5vcmllbnQgPT0gXCJmaXhlZFwiKSB7XG5cdFx0XHRcdC8vIGNvbnRyb2xsZWQgcm90YXRpb25cblx0XHRcdFx0Z3VpZGVEYXRhLmVuZEFic1JvdCA9IGVuZC5yb3RhdGlvbiArIGd1aWRlRGF0YS5zdGFydE9mZnNldFJvdDtcblx0XHRcdFx0Z3VpZGVEYXRhLmRlbHRhUm90YXRpb24gPSAwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gaW50ZXJwcmV0ZWQgcm90YXRpb25cblxuXHRcdFx0XHR2YXIgZmluYWxSb3QgPSBwcm9wcy5yb3RhdGlvbiA9PT0gdW5kZWZpbmVkID8gKHR3ZWVuLnRhcmdldC5yb3RhdGlvbiB8fCAwKSA6IHByb3BzLnJvdGF0aW9uO1xuXHRcdFx0XHR2YXIgZGVsdGFSb3QgPSAoZmluYWxSb3QgLSBndWlkZURhdGEuZW5kRGF0YS5yb3RhdGlvbikgLSBndWlkZURhdGEuc3RhcnRPZmZzZXRSb3Q7XG5cdFx0XHRcdHZhciBtb2RSb3QgPSBkZWx0YVJvdCAlIDM2MDtcblxuXHRcdFx0XHRndWlkZURhdGEuZW5kQWJzUm90ID0gZmluYWxSb3Q7XG5cblx0XHRcdFx0c3dpdGNoKGd1aWRlRGF0YS5vcmllbnQpIHtcblx0XHRcdFx0XHRjYXNlIFwiYXV0b1wiOlxuXHRcdFx0XHRcdFx0Z3VpZGVEYXRhLmRlbHRhUm90YXRpb24gPSBkZWx0YVJvdDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJjd1wiOlxuXHRcdFx0XHRcdFx0Z3VpZGVEYXRhLmRlbHRhUm90YXRpb24gPSAoKG1vZFJvdCArIDM2MCkgJSAzNjApICsgKDM2MCAqIE1hdGguYWJzKChkZWx0YVJvdC8zNjApIHwwKSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiY2N3XCI6XG5cdFx0XHRcdFx0XHRndWlkZURhdGEuZGVsdGFSb3RhdGlvbiA9ICgobW9kUm90IC0gMzYwKSAlIDM2MCkgKyAoLTM2MCAqIE1hdGguYWJzKChkZWx0YVJvdC8zNjApIHwwKSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0d2Vlbi5faW5qZWN0UHJvcChcInJvdGF0aW9uXCIsIGd1aWRlRGF0YS5lbmRBYnNSb3QpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIGJlZm9yZSBhIHByb3BlcnR5IGlzIHVwZGF0ZWQgYnkgdGhlIHR3ZWVuLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiU2FtcGxlUGx1Z2luL2NoYW5nZVwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvLlxuXHQgKiBAbWV0aG9kIGNoYW5nZVxuXHQgKiBAcGFyYW0ge1R3ZWVufSB0d2VlblxuXHQgKiBAcGFyYW0ge1R3ZWVuU3RlcH0gc3RlcFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuXHQgKiBAcGFyYW0ge2FueX0gdmFsdWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhdGlvXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5kXG5cdCAqIEByZXR1cm4ge2FueX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jaGFuZ2UgPSBmdW5jdGlvbih0d2Vlbiwgc3RlcCwgcHJvcCwgdmFsdWUsIHJhdGlvLCBlbmQpIHtcblx0XHR2YXIgZ3VpZGVEYXRhID0gc3RlcC5wcm9wcy5ndWlkZTtcblxuXHRcdGlmKFxuXHRcdFx0XHQhZ3VpZGVEYXRhIHx8XHRcdFx0XHRcdFx0XHQvLyBNaXNzaW5nIGRhdGFcblx0XHRcdFx0KHN0ZXAucHJvcHMgPT09IHN0ZXAucHJldi5wcm9wcykgfHwgXHQvLyBJbiBhIHdhaXQoKVxuXHRcdFx0XHQoZ3VpZGVEYXRhID09PSBzdGVwLnByZXYucHJvcHMuZ3VpZGUpIFx0Ly8gR3VpZGUgaGFzbid0IGNoYW5nZWRcblx0XHQpIHtcblx0XHRcdHJldHVybjsgLy8gaGF2ZSBubyBidXNpbmVzcyBtYWtpbmcgZGVjaXNpb25zXG5cdFx0fVxuXHRcdGlmKFxuXHRcdFx0XHQocHJvcCA9PT0gXCJndWlkZVwiICYmICFndWlkZURhdGEudmFsaWQpIHx8XHRcdC8vIHRoaXMgZGF0YSBpcyBicm9rZW5cblx0XHRcdFx0KHByb3AgPT0gXCJ4XCIgfHwgcHJvcCA9PSBcInlcIikgfHxcdFx0XHRcdFx0Ly8gdGhlc2UgYWx3YXlzIGdldCBvdmVyLXdyaXR0ZW5cblx0XHRcdFx0KHByb3AgPT09IFwicm90YXRpb25cIiAmJiBndWlkZURhdGEub3JpZW50KVx0XHQvLyBjdXJyZW50bHkgb3Zlci13cml0dGVuXG5cdFx0KXtcblx0XHRcdHJldHVybiBjcmVhdGVqcy5Ud2Vlbi5JR05PUkU7XG5cdFx0fVxuXG5cdFx0cy5fcmF0aW9Ub1Bvc2l0aW9uRGF0YShyYXRpbywgZ3VpZGVEYXRhLCB0d2Vlbi50YXJnZXQpO1xuXHR9O1xuXG4vLyBwdWJsaWMgbWV0aG9kc1xuXHQvKipcblx0ICogUHJvdmlkZSBwb3RlbnRpYWxseSB1c2VmdWwgZGVidWdnaW5nIGluZm9ybWF0aW9uLCBsaWtlIHJ1bm5pbmcgdGhlIGVycm9yIGRldGVjdGlvbiBzeXN0ZW0sIGFuZCByZW5kZXJpbmcgdGhlIHBhdGhcblx0ICogZGVmaW5lZCBpbiB0aGUgZ3VpZGUgZGF0YS5cblx0ICpcblx0ICogTk9URTogeW91IHdpbGwgbmVlZCB0byB0cmFuc2Zvcm0geW91ciBjb250ZXh0IDJEIHRvIHRoZSBsb2NhbCBzcGFjZSBvZiB0aGUgZ3VpZGUgaWYgeW91IHdpc2ggdG8gbGluZSBpdCB1cC5cblx0ICogQHBhcmFtIHtPYmplY3R9IGd1aWRlRGF0YSBBbGwgdGhlIGluZm9ybWF0aW9uIGRlc2NyaWJpbmcgdGhlIGd1aWRlIHRvIGJlIGZvbGxvd2VkLlxuXHQgKiBAcGFyYW0ge0RyYXdpbmdDb250ZXh0MkR9IFtjdHg9dW5kZWZpbmVkXSBUaGUgY29udGV4dCB0byBkcmF3IHRoZSBvYmplY3QgaW50by5cblx0ICogQHBhcmFtIHtBcnJheX0gW2hpZ2xpZ2h0PXVuZGVmaW5lZF0gQXJyYXkgb2YgcmF0aW8gcG9zaXRpb25zIHRvIGhpZ2hsaWdodFxuXHQgKiBAcmV0dXJucyB7dW5kZWZpbmVkfFN0cmluZ31cblx0ICovXG5cdHMuZGVidWcgPSBmdW5jdGlvbihndWlkZURhdGEsIGN0eCwgaGlnbGlnaHQpIHtcblx0XHRndWlkZURhdGEgPSBndWlkZURhdGEuZ3VpZGUgfHwgZ3VpZGVEYXRhO1xuXG5cdFx0Ly8gZXJyb3JzXG5cdFx0dmFyIGVyciA9IHMuX2ZpbmRQYXRoUHJvYmxlbXMoZ3VpZGVEYXRhKTtcblx0XHRpZihlcnIpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJNb3Rpb25HdWlkZVBsdWdpbiBFcnJvciBmb3VuZDogXFxuXCIgKyBlcnIpO1xuXHRcdH1cblxuXHRcdC8vIGRyYXdpbmdcblx0XHRpZighY3R4KXsgcmV0dXJuIGVycjsgfVxuXG5cdFx0dmFyIGk7XG5cdFx0dmFyIHBhdGggPSBndWlkZURhdGEucGF0aDtcblx0XHR2YXIgcGF0aExlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXHRcdHZhciB3aWR0aCA9IDM7XG5cdFx0dmFyIGxlbmd0aCA9IDk7XG5cblx0XHRjdHguc2F2ZSgpO1xuXHRcdC8vY3R4LnJlc2V0VHJhbnNmb3JtKCk7XG5cblx0XHRjdHgubGluZUNhcCA9IFwicm91bmRcIjtcblx0XHRjdHgubGluZUpvaW4gPSBcIm1pdGVyXCI7XG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0Ly8gY3VydmVcblx0XHRjdHgubW92ZVRvKHBhdGhbMF0sIHBhdGhbMV0pO1xuXHRcdGZvcihpPTI7IGkgPCBwYXRoTGVuZ3RoOyBpKz00KSB7XG5cdFx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyhcblx0XHRcdFx0cGF0aFtpXSwgcGF0aFtpKzFdLFxuXHRcdFx0XHRwYXRoW2krMl0sIHBhdGhbaSszXVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRjdHguc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCI7XG5cdFx0Y3R4LmxpbmVXaWR0aCA9IHdpZHRoKjEuNTtcblx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gXCJ3aGl0ZVwiO1xuXHRcdGN0eC5saW5lV2lkdGggPSB3aWR0aDtcblx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXG5cdFx0Ly8gaGlnaGxpZ2h0c1xuXHRcdHZhciBoaUNvdW50ID0gaGlnbGlnaHQubGVuZ3RoO1xuXHRcdGlmKGhpZ2xpZ2h0ICYmIGhpQ291bnQpIHtcblx0XHRcdHZhciB0ZW1wU3RvcmUgPSB7fTtcblx0XHRcdHZhciB0ZW1wTG9vayA9IHt9O1xuXHRcdFx0cy5fc29sdmVHdWlkZURhdGEoZ3VpZGVEYXRhLCB0ZW1wU3RvcmUpO1xuXG5cdFx0XHRmb3IodmFyIGk9MDsgaTxoaUNvdW50OyBpKyspe1xuXHRcdFx0XHR0ZW1wU3RvcmUub3JpZW50ID0gXCJmaXhlZFwiO1xuXHRcdFx0XHRzLl9yYXRpb1RvUG9zaXRpb25EYXRhKGhpZ2xpZ2h0W2ldLCB0ZW1wU3RvcmUsIHRlbXBMb29rKTtcblxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRcdFx0Y3R4Lm1vdmVUbyh0ZW1wTG9vay54LCB0ZW1wTG9vay55KTtcblx0XHRcdFx0Y3R4LmxpbmVUbyhcblx0XHRcdFx0XHR0ZW1wTG9vay54ICsgTWF0aC5jb3ModGVtcExvb2sucm90YXRpb24gKiAwLjAxNzQ1MzMpICogbGVuZ3RoLFxuXHRcdFx0XHRcdHRlbXBMb29rLnkgKyBNYXRoLnNpbih0ZW1wTG9vay5yb3RhdGlvbiAqIDAuMDE3NDUzMykgKiBsZW5ndGhcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCI7XG5cdFx0XHRcdGN0eC5saW5lV2lkdGggPSB3aWR0aCoxLjU7XG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gXCJyZWRcIjtcblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHdpZHRoO1xuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBlbmQgZHJhd1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cblx0XHRyZXR1cm4gZXJyO1xuXHR9O1xuXG4vLyBwcml2YXRlIG1ldGhvZHNcblx0LyoqXG5cdCAqIENhbGN1bGF0ZSBhbmQgc3RvcmUgb3B0aW1pemF0aW9uIGRhdGEgYWJvdXQgdGhlIGRlc2lyZWQgcGF0aCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlIGFuZCBhY2N1cmFjeSBvZiBwb3NpdGlvbnMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIGd1aWRlIGRhdGEgcHJvdmlkZWQgdG8gdGhlIHR3ZWVuIGNhbGxcblx0ICogQHBhcmFtIHtPYmplY3R9IHN0b3JhZ2UgdGhlIGd1aWRlIGRhdGEgdXNlZCBieSB0aGUgc3RlcCBjYWxscyBhbmQgcGx1Z2luIHRvIGRvIHRoZSBqb2IsIHdpbGwgYmUgb3ZlcndyaXR0ZW5cblx0ICogQHJldHVybnMge3VuZGVmaW5lZHxTdHJpbmd9IENhbiByZXR1cm4gYW4gZXJyb3IgaWYgdW5hYmxlIHRvIGdlbmVyYXRlIHRoZSBkYXRhLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cy5fc29sdmVHdWlkZURhdGEgPSBmdW5jdGlvbihzb3VyY2UsIHN0b3JhZ2UpIHtcblx0XHR2YXIgZXJyID0gdW5kZWZpbmVkO1xuXHRcdGlmKGVyciA9IHMuZGVidWcoc291cmNlKSkgeyByZXR1cm4gZXJyOyB9XG5cblx0XHR2YXIgcGF0aCA9IHN0b3JhZ2UucGF0aCA9IHNvdXJjZS5wYXRoO1xuXHRcdHZhciBvcmllbnQgPSBzdG9yYWdlLm9yaWVudCA9IHNvdXJjZS5vcmllbnQ7XG5cdFx0c3RvcmFnZS5zdWJMaW5lcyA9IFtdO1xuXHRcdHN0b3JhZ2UudG90YWxMZW5ndGggPSAwO1xuXHRcdHN0b3JhZ2Uuc3RhcnRPZmZzZXRSb3QgPSAwO1xuXHRcdHN0b3JhZ2UuZGVsdGFSb3RhdGlvbiA9IDA7XG5cdFx0c3RvcmFnZS5zdGFydERhdGEgPSB7cmF0aW86IDB9O1xuXHRcdHN0b3JhZ2UuZW5kRGF0YSA9IHtyYXRpbzogMX07XG5cdFx0c3RvcmFnZS5hbmltU3BhbiA9IDE7XG5cblx0XHR2YXIgcGF0aExlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG5cdFx0dmFyIHByZWNpc2lvbiA9IDEwO1xuXHRcdHZhciBzeCxzeSwgY3gsY3ksIGV4LGV5LCBpLGosIGxlbiwgdGVtcCA9IHt9O1xuXG5cdFx0c3ggPSBwYXRoWzBdO1x0XHRzeSA9IHBhdGhbMV07XG5cblx0XHQvLyBnZXQgdGhlIGRhdGEgZm9yIGVhY2ggY3VydmVcblx0XHRmb3IoaT0yOyBpIDwgcGF0aExlbmd0aDsgaSs9NCkge1xuXHRcdFx0Y3ggPSBwYXRoW2ldO1x0XHRcdGN5ID0gcGF0aFtpKzFdO1xuXHRcdFx0ZXggPSBwYXRoW2krMl07XHRcdFx0ZXkgPSBwYXRoW2krM107XG5cblx0XHRcdHZhciBzdWJMaW5lID0ge1xuXHRcdFx0XHR3ZWlnaHRpbmdzOiBbXSxcblx0XHRcdFx0ZXN0TGVuZ3RoOiAwLFxuXHRcdFx0XHRwb3J0aW9uOiAwXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgc3ViWCA9IHN4LCBzdWJZID0gc3k7XG5cdFx0XHQvLyBnZXQgdGhlIGRpc3RhbmNlIGRhdGEgZm9yIGVhY2ggcG9pbnRcblx0XHRcdGZvcihqPTE7IGogPD0gcHJlY2lzaW9uO2orKykge1x0Ly8gd2UgbmVlZCB0byBldmFsdWF0ZSB0ID0gMSBub3QgdCA9IDBcblx0XHRcdFx0cy5fZ2V0UGFyYW1zRm9yQ3VydmUoc3gsc3ksIGN4LGN5LCBleCxleSwgai9wcmVjaXNpb24sIGZhbHNlLCB0ZW1wKTtcblxuXHRcdFx0XHR2YXIgZHggPSB0ZW1wLnggLSBzdWJYLCBkeSA9IHRlbXAueSAtIHN1Ylk7XG5cdFx0XHRcdGxlbiA9IE1hdGguc3FydChkeCpkeCArIGR5KmR5KTtcblx0XHRcdFx0c3ViTGluZS53ZWlnaHRpbmdzLnB1c2gobGVuKTtcblx0XHRcdFx0c3ViTGluZS5lc3RMZW5ndGggKz0gbGVuO1xuXG5cdFx0XHRcdHN1YlggPSB0ZW1wLng7XG5cdFx0XHRcdHN1YlkgPSB0ZW1wLnk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGZpZ3VyZSBvdXQgZnVsbCBsZW5ndGhzXG5cdFx0XHRzdG9yYWdlLnRvdGFsTGVuZ3RoICs9IHN1YkxpbmUuZXN0TGVuZ3RoO1xuXG5cdFx0XHQvLyB1c2UgbGVuZ3RoIHRvIGZpZ3VyZSBvdXQgcHJvcG9ydGlvbmFsIHdlaWdodGluZ3Ncblx0XHRcdGZvcihqPTA7IGogPCBwcmVjaXNpb247IGorKykge1xuXHRcdFx0XHRsZW4gPSBzdWJMaW5lLmVzdExlbmd0aDtcblx0XHRcdFx0c3ViTGluZS53ZWlnaHRpbmdzW2pdID0gc3ViTGluZS53ZWlnaHRpbmdzW2pdIC8gbGVuO1xuXHRcdFx0fVxuXG5cdFx0XHRzdG9yYWdlLnN1YkxpbmVzLnB1c2goc3ViTGluZSk7XG5cdFx0XHRzeCA9IGV4O1xuXHRcdFx0c3kgPSBleTtcblx0XHR9XG5cblx0XHQvLyB1c2UgbGVuZ3RoIHRvIGZpZ3VyZSBvdXQgcHJvcG9ydGlvbmFsIHdlaWdodGluZ3Ncblx0XHRsZW4gPSBzdG9yYWdlLnRvdGFsTGVuZ3RoO1xuXHRcdHZhciBsID0gc3RvcmFnZS5zdWJMaW5lcy5sZW5ndGg7XG5cdFx0Zm9yKGk9MDsgaTxsOyBpKyspIHtcblx0XHRcdHN0b3JhZ2Uuc3ViTGluZXNbaV0ucG9ydGlvbiA9IHN0b3JhZ2Uuc3ViTGluZXNbaV0uZXN0TGVuZ3RoIC8gbGVuO1xuXHRcdH1cblxuXHRcdC8vIGRldGVybWluZSBzdGFydCBhbmQgZW5kIGRhdGFcblx0XHR2YXIgc3RhcnRSYXRpbyA9IGlzTmFOKHNvdXJjZS5zdGFydCkgPyAwIDogc291cmNlLnN0YXJ0O1xuXHRcdHZhciBlbmRSYXRpbyA9IGlzTmFOKHNvdXJjZS5lbmQpID8gMSA6IHNvdXJjZS5lbmQ7XG5cdFx0cy5fcmF0aW9Ub1Bvc2l0aW9uRGF0YShzdGFydFJhdGlvLCBzdG9yYWdlLCBzdG9yYWdlLnN0YXJ0RGF0YSk7XG5cdFx0cy5fcmF0aW9Ub1Bvc2l0aW9uRGF0YShlbmRSYXRpbywgc3RvcmFnZSwgc3RvcmFnZS5lbmREYXRhKTtcblxuXHRcdC8vIHRoaXMgaGFzIHRvIGJlIGRvbmUgbGFzdCBlbHNlIHRoZSBwcmV2IHJhdGlvcyB3aWxsIGJlIG91dCBvZiBwbGFjZVxuXHRcdHN0b3JhZ2Uuc3RhcnREYXRhLnJhdGlvID0gc3RhcnRSYXRpbztcblx0XHRzdG9yYWdlLmVuZERhdGEucmF0aW8gPSBlbmRSYXRpbztcblx0XHRzdG9yYWdlLmFuaW1TcGFuID0gc3RvcmFnZS5lbmREYXRhLnJhdGlvIC0gc3RvcmFnZS5zdGFydERhdGEucmF0aW87XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgYSBwZXJjZW50YWdlIGFsb25nIHRoZSBsaW5lIGludG8sIGEgbG9jYWwgbGluZSAoc3RhcnQsIGNvbnRyb2wsIGVuZCkgdC12YWx1ZSBmb3IgY2FsY3VsYXRpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYXRpbyBUaGUgKGV1Y2xpZGVhbiBkaXN0YW5jZSkgcGVyY2VudGFnZSBpbnRvIHRoZSB3aG9sZSBjdXJ2ZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IGd1aWRlRGF0YSBBbGwgdGhlIGluZm9ybWF0aW9uIGRlc2NyaWJpbmcgdGhlIGd1aWRlIHRvIGJlIGZvbGxvd2VkLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3V0cHV0IE9iamVjdCB0byBzYXZlIG91dHB1dCBwcm9wZXJ0aWVzIG9mIHgseSwgYW5kIHJvdGF0aW9uIG9udG8uXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBvdXRwdXQgb2JqZWN0LCB1c2VmdWwgZm9yIGlzb2xhdGVkIGNhbGxzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cy5fcmF0aW9Ub1Bvc2l0aW9uRGF0YSA9IGZ1bmN0aW9uKHJhdGlvLCBndWlkZURhdGEsIG91dHB1dCkge1xuXHRcdHZhciBsaW5lU2VnbWVudHMgPSBndWlkZURhdGEuc3ViTGluZXM7XG5cblx0XHR2YXIgaSxsLCB0LCB0ZXN0LCB0YXJnZXQ7XG5cblx0XHR2YXIgbG9vayA9IDA7XG5cdFx0dmFyIHByZWNpc2lvbiA9IDEwO1xuXHRcdHZhciBlZmZSYXRpbyA9IChyYXRpbyAqIGd1aWRlRGF0YS5hbmltU3BhbikgKyBndWlkZURhdGEuc3RhcnREYXRhLnJhdGlvO1xuXG5cdFx0Ly8gZmluZCBzdWJsaW5lXG5cdFx0bCA9IGxpbmVTZWdtZW50cy5sZW5ndGg7XG5cdFx0Zm9yKGk9MDsgaTxsOyBpKyspIHtcblx0XHRcdHRlc3QgPSBsaW5lU2VnbWVudHNbaV0ucG9ydGlvbjtcblx0XHRcdGlmKGxvb2sgKyB0ZXN0ID49IGVmZlJhdGlvKXsgdGFyZ2V0ID0gaTsgYnJlYWs7IH1cblx0XHRcdGxvb2sgKz0gdGVzdDtcblx0XHR9XG5cdFx0aWYodGFyZ2V0ID09PSB1bmRlZmluZWQpIHsgdGFyZ2V0ID0gbC0xOyAgbG9vayAtPSB0ZXN0OyB9XG5cblx0XHQvLyBmaW5kIG1pZGxpbmUgd2VpZ2h0aW5nXG5cdFx0dmFyIHN1YkxpbmVzID0gbGluZVNlZ21lbnRzW3RhcmdldF0ud2VpZ2h0aW5ncztcblx0XHR2YXIgcG9ydGlvbiA9IHRlc3Q7XG5cdFx0bCA9IHN1YkxpbmVzLmxlbmd0aDtcblx0XHRmb3IoaT0wOyBpPGw7IGkrKykge1xuXHRcdFx0dGVzdCA9IHN1YkxpbmVzW2ldICogcG9ydGlvbjtcblx0XHRcdGlmKGxvb2sgKyB0ZXN0ID49IGVmZlJhdGlvKXsgYnJlYWs7IH1cblx0XHRcdGxvb2sgKz0gdGVzdDtcblx0XHR9XG5cblx0XHQvLyB0cmFuc2xhdGUgdGhlIHN1YmxpbmUgaW5kZXggaW50byBhIHBvc2l0aW9uIGluIHRoZSBwYXRoIGRhdGFcblx0XHR0YXJnZXQgPSAodGFyZ2V0KjQpICsgMjtcblx0XHQvLyB0YWtlIHRoZSBkaXN0YW5jZSB3ZSd2ZSBjb3ZlcmVkIGluIG91ciByYXRpbywgYW5kIHNjYWxlIGl0IHRvIGRpc3RhbmNlIGludG8gdGhlIHdlaWdodGluZ3Ncblx0XHR0ID0gKGkvcHJlY2lzaW9uKSArICgoKGVmZlJhdGlvLWxvb2spIC8gdGVzdCkgKiAoMS9wcmVjaXNpb24pKTtcblxuXHRcdC8vIHBvc2l0aW9uXG5cdFx0dmFyIHBhdGhEYXRhID0gZ3VpZGVEYXRhLnBhdGg7XG5cdFx0cy5fZ2V0UGFyYW1zRm9yQ3VydmUoXG5cdFx0XHRwYXRoRGF0YVt0YXJnZXQtMl0sXHRcdFx0cGF0aERhdGFbdGFyZ2V0LTFdLFxuXHRcdFx0cGF0aERhdGFbdGFyZ2V0XSxcdFx0XHRwYXRoRGF0YVt0YXJnZXQrMV0sXG5cdFx0XHRwYXRoRGF0YVt0YXJnZXQrMl0sXHRcdFx0cGF0aERhdGFbdGFyZ2V0KzNdLFxuXHRcdFx0dCxcblx0XHRcdGd1aWRlRGF0YS5vcmllbnQsXG5cdFx0XHRvdXRwdXRcblx0XHQpO1xuXG5cdFx0aWYoZ3VpZGVEYXRhLm9yaWVudCkge1xuXHRcdFx0aWYocmF0aW8gPj0gMC45OTk5OSAmJiByYXRpbyA8PSAxLjAwMDAxICYmIGd1aWRlRGF0YS5lbmRBYnNSb3QgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRvdXRwdXQucm90YXRpb24gPSBndWlkZURhdGEuZW5kQWJzUm90O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnJvdGF0aW9uICs9IGd1aWRlRGF0YS5zdGFydE9mZnNldFJvdCArIChyYXRpbyAqIGd1aWRlRGF0YS5kZWx0YVJvdGF0aW9uKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBGb3IgYSBnaXZlbiBxdWFkcmF0aWMgYmV6aWVyIHQtdmFsdWUsIHdoYXQgaXMgdGhlIHBvc2l0aW9uIGFuZCByb3RhdGlvbi4gU2F2ZSBpdCBvbnRvIHRoZSBvdXRwdXQgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc3ggU3RhcnQgeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN5IFN0YXJ0IHkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjeCBDb250cm9sIHguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjeSBDb250cm9sIHkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBleCBFbmQgeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGV5IEVuZCB5LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdCBUIHZhbHVlIChwYXJhbWV0cmljIGRpc3RhbmNlIGludG8gY3VydmUpLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IG9yaWVudCBTYXZlIHJvdGF0aW9uIGRhdGEuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdXRwdXQgT2JqZWN0IHRvIHNhdmUgb3V0cHV0IHByb3BlcnRpZXMgb2YgeCx5LCBhbmQgcm90YXRpb24gb250by5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHMuX2dldFBhcmFtc0ZvckN1cnZlID0gZnVuY3Rpb24oc3gsc3ksIGN4LGN5LCBleCxleSwgdCwgb3JpZW50LCBvdXRwdXQpIHtcblx0XHR2YXIgaW52ID0gMSAtIHQ7XG5cblx0XHQvLyBmaW5kaW5nIGEgcG9pbnQgb24gYSBiZXppZXIgY3VydmVcblx0XHRvdXRwdXQueCA9XHRpbnYqaW52ICogc3ggKyAyICogaW52ICogdCAqIGN4ICsgdCp0ICogZXg7XG5cdFx0b3V0cHV0LnkgPVx0aW52KmludiAqIHN5ICsgMiAqIGludiAqIHQgKiBjeSArIHQqdCAqIGV5O1xuXG5cdFx0Ly8gZmluZGluZyBhbiBhbmdsZSBvbiBhIGJlemllciBjdXJ2ZVxuXHRcdGlmKG9yaWVudCkge1xuXHRcdFx0Ly8gY29udmVydCBmcm9tIHJhZGlhbnMgYmFjayB0byBkZWdyZWVzXG5cdFx0XHRvdXRwdXQucm90YXRpb24gPSA1Ny4yOTU3Nzk1ICogTWF0aC5hdGFuMihcblx0XHRcdFx0KGN5IC0gc3kpKmludiArIChleSAtIGN5KSp0LFxuXHRcdFx0XHQoY3ggLSBzeCkqaW52ICsgKGV4IC0gY3gpKnRcblx0XHRcdCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBQZXJmb3JtIGEgY2hlY2sgdG8gdmFsaWRhdGUgcGF0aCBpbmZvcm1hdGlvbiBzbyBwbHVnaW4gY2FuIGF2b2lkIGxhdGVyIGVycm9yIGNoZWNraW5nLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZ3VpZGVEYXRhIEFsbCB0aGUgaW5mb3JtYXRpb24gZGVzY3JpYmluZyB0aGUgZ3VpZGUgdG8gYmUgZm9sbG93ZWQuXG5cdCAqIEByZXR1cm5zIHt1bmRlZmluZWR8U3RyaW5nfSBUaGUgcHJvYmxlbSBmb3VuZCwgb3IgdW5kZWZpbmVkIGlmIG5vIHByb2JsZW1zLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cy5fZmluZFBhdGhQcm9ibGVtcyA9IGZ1bmN0aW9uKGd1aWRlRGF0YSkge1xuXHRcdHZhciBwYXRoID0gZ3VpZGVEYXRhLnBhdGg7XG5cdFx0dmFyIHZhbHVlQ291bnQgPSAocGF0aCAmJiBwYXRoLmxlbmd0aCkgfHwgMDtcdC8vIGVuc3VyZSB0aGlzIGlzIGEgbnVtYmVyIHRvIHNpbXBsaWZ5IGxhdGVyIGxvZ2ljXG5cdFx0aWYodmFsdWVDb3VudCA8IDYgfHwgKHZhbHVlQ291bnQtMikgJSA0KSB7XG5cdFx0XHR2YXIgbWVzc2FnZSA9XHRcIlxcdENhbm5vdCBwYXJzZSAncGF0aCcgYXJyYXkgZHVlIHRvIGludmFsaWQgbnVtYmVyIG9mIGVudHJpZXMgaW4gcGF0aC4gXCI7XG5cdFx0XHRtZXNzYWdlICs9XHRcdFwiVGhlcmUgc2hvdWxkIGJlIGFuIG9kZCBudW1iZXIgb2YgcG9pbnRzLCBhdCBsZWFzdCAzIHBvaW50cywgYW5kIDIgZW50cmllcyBwZXIgcG9pbnQgKHggJiB5KS4gXCI7XG5cdFx0XHRtZXNzYWdlICs9XHRcdFwiU2VlICdDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucXVhZHJhdGljQ3VydmVUbycgZm9yIGRldGFpbHMgYXMgJ3BhdGgnIG1vZGVscyBhIHF1YWRyYXRpYyBiZXppZXIuXFxuXFxuXCI7XG5cdFx0XHRtZXNzYWdlICs9XHRcdFwiT25seSBbIFwiKyB2YWx1ZUNvdW50ICtcIiBdIHZhbHVlcyBmb3VuZC4gRXhwZWN0ZWQ6IFwiKyBNYXRoLm1heChNYXRoLmNlaWwoKHZhbHVlQ291bnQtMikvNCkqNCsyLCA2KTsgLy82LCAxMCwgMTQsLi4uXG5cdFx0XHRyZXR1cm4gbWVzc2FnZTtcblx0XHR9XG5cblx0XHRmb3IodmFyIGk9MDsgaTx2YWx1ZUNvdW50OyBpKyspIHtcblx0XHRcdGlmKGlzTmFOKHBhdGhbaV0pKXtcblx0XHRcdFx0cmV0dXJuIFwiQWxsIGRhdGEgaW4gcGF0aCBhcnJheSBtdXN0IGJlIG51bWVyaWNcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgc3RhcnQgPSBndWlkZURhdGEuc3RhcnQ7XG5cdFx0aWYoaXNOYU4oc3RhcnQpICYmICEoc3RhcnQgPT09IHVuZGVmaW5lZCkvKiB8fCBzdGFydCA8IDAgfHwgc3RhcnQgPiAxKi8pIHtcdC8vIG91dHNpZGUgMC0xIGlzIHVucHJlZGljdGFibGUsIGJ1dCBub3QgYnJlYWtpbmdcblx0XHRcdHJldHVybiBcIidzdGFydCcgb3V0IG9mIGJvdW5kcy4gRXhwZWN0ZWQgMCB0byAxLCBnb3Q6IFwiKyBzdGFydDtcblx0XHR9XG5cdFx0dmFyIGVuZCA9IGd1aWRlRGF0YS5lbmQ7XG5cdFx0aWYoaXNOYU4oZW5kKSAmJiAoZW5kICE9PSB1bmRlZmluZWQpLyogfHwgZW5kIDwgMCB8fCBlbmQgPiAxKi8pIHtcdC8vIG91dHNpZGUgMC0xIGlzIHVucHJlZGljdGFibGUsIGJ1dCBub3QgYnJlYWtpbmdcblx0XHRcdHJldHVybiBcIidlbmQnIG91dCBvZiBib3VuZHMuIEV4cGVjdGVkIDAgdG8gMSwgZ290OiBcIisgZW5kO1xuXHRcdH1cblxuXHRcdHZhciBvcmllbnQgPSBndWlkZURhdGEub3JpZW50O1xuXHRcdGlmKG9yaWVudCkgeyAvLyBtaXJyb3IgdGhlIGNoZWNrIHVzZWQgZWxzZXdoZXJlXG5cdFx0XHRpZihvcmllbnQgIT0gXCJmaXhlZFwiICYmIG9yaWVudCAhPSBcImF1dG9cIiAmJiBvcmllbnQgIT0gXCJjd1wiICYmIG9yaWVudCAhPSBcImNjd1wiKSB7XG5cdFx0XHRcdHJldHVybiAnSW52YWxpZCBvcmllbnRhdGlvbiB2YWx1ZS4gRXhwZWN0ZWQgW1wiZml4ZWRcIiwgXCJhdXRvXCIsIFwiY3dcIiwgXCJjY3dcIiwgdW5kZWZpbmVkXSwgZ290OiAnKyBvcmllbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fTtcblxuXHRjcmVhdGVqcy5Nb3Rpb25HdWlkZVBsdWdpbiA9IE1vdGlvbkd1aWRlUGx1Z2luO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gdmVyc2lvbi5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxud2luZG93LmNyZWF0ZWpzID0gd2luZG93LmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBTdGF0aWMgY2xhc3MgaG9sZGluZyBsaWJyYXJ5IHNwZWNpZmljIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHZlcnNpb24gYW5kIGJ1aWxkRGF0ZSBvZlxuXHQgKiB0aGUgbGlicmFyeS5cblx0ICogQGNsYXNzIFR3ZWVuSlNcblx0ICoqL1xuXHR2YXIgcyA9IGNyZWF0ZWpzLlR3ZWVuSlMgPSBjcmVhdGVqcy5Ud2VlbkpTIHx8IHt9O1xuXG5cdC8qKlxuXHQgKiBUaGUgdmVyc2lvbiBzdHJpbmcgZm9yIHRoaXMgcmVsZWFzZS5cblx0ICogQHByb3BlcnR5IHZlcnNpb25cblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRzLnZlcnNpb24gPSAvKj12ZXJzaW9uKi9cIjEuMC4wXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxuXHQvKipcblx0ICogVGhlIGJ1aWxkIGRhdGUgZm9yIHRoaXMgcmVsZWFzZSBpbiBVVEMgZm9ybWF0LlxuXHQgKiBAcHJvcGVydHkgYnVpbGREYXRlXG5cdCAqIEB0eXBlIFN0cmluZ1xuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0cy5idWlsZERhdGUgPSAvKj1kYXRlKi9cIlRodSwgMTQgU2VwIDIwMTcgMTk6NDc6NDcgR01UXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxufSkoKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///qE/h\n");

/***/ })

}]);