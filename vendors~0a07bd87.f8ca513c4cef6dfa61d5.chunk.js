(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~0a07bd87"],{

/***/ "aurelia-bodylight-plugin/elements/chartjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.Chartjs = void 0;\n\nvar _chart = _interopRequireDefault(__webpack_require__(/*! chart.js */ \"MO+k\"));\n\nvar _chartjsPluginDatalabels = _interopRequireDefault(__webpack_require__(/*! chartjs-plugin-datalabels */ \"qb46\"));\n\nvar _aureliaFramework = __webpack_require__(/*! aurelia-framework */ \"aurelia-framework\");\n\nvar _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16, _descriptor17, _descriptor18, _descriptor19;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\n//returns array of numbers if contains comma, or number - int\nfunction myParseInt(str, raddix) {\n  if (str.lastIndexOf(',') > 0) return str.split(',').map(function (x) {\n    return parseInt(x, raddix);\n  });else return parseInt(str, raddix);\n}\n\nvar Chartjs = (_class = /*#__PURE__*/function () {\n  //id to listen addsection event\n  //false - to keep width and height, true - to rescale\n  //may be configured by subclasses\n\n  /**\n   * initializes handlers for event processing - this is recommended way\n   */\n  function Chartjs() {\n    var _this = this;\n\n    _initializerDefineProperty(this, \"fromid\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"labels\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"refindex\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"refvalues\", _descriptor4, this);\n\n    _initializerDefineProperty(this, \"type\", _descriptor5, this);\n\n    _initializerDefineProperty(this, \"maxdata\", _descriptor6, this);\n\n    _initializerDefineProperty(this, \"initialdata\", _descriptor7, this);\n\n    _initializerDefineProperty(this, \"width\", _descriptor8, this);\n\n    _initializerDefineProperty(this, \"height\", _descriptor9, this);\n\n    _initializerDefineProperty(this, \"animate\", _descriptor10, this);\n\n    _initializerDefineProperty(this, \"id\", _descriptor11, this);\n\n    _initializerDefineProperty(this, \"ylabel\", _descriptor12, this);\n\n    _initializerDefineProperty(this, \"xlabel\", _descriptor13, this);\n\n    _initializerDefineProperty(this, \"convertors\", _descriptor14, this);\n\n    _initializerDefineProperty(this, \"verticalline\", _descriptor15, this);\n\n    _initializerDefineProperty(this, \"generatelabels\", _descriptor16, this);\n\n    _initializerDefineProperty(this, \"sectionid\", _descriptor17, this);\n\n    _initializerDefineProperty(this, \"responsive\", _descriptor18, this);\n\n    _initializerDefineProperty(this, \"canvasobj\", _descriptor19, this);\n\n    this.indexsection = 0;\n    this.datalabels = false;\n\n    this.handleValueChange = function (e) {\n      //sets data to dataset\n      //apply value convert among all data\n      var rawdata = e.detail.data.slice(_this.refindex, _this.refendindex); //if convert operation is defined as array\n\n      if (_this.operation) {\n        for (var i = 0; i < rawdata.length; i++) {\n          //if particular operation is defined\n          if (_this.operation[i]) rawdata[i] = _this.operation[i](rawdata[i]);\n        }\n      }\n\n      _this.chart.data.datasets[0].data = rawdata;\n\n      _this.chart.update();\n    };\n\n    this.handleReset = function (e) {\n      //console.log('handlereset');\n      _this.resetdata();\n\n      _this.chart.update();\n    };\n\n    this.handleAddSection = function (e) {\n      _this.addSection(e.detail.label);\n    };\n  }\n  /**\n   * empties data in every dataset and empties section\n   */\n\n\n  var _proto = Chartjs.prototype;\n\n  _proto.resetdata = function resetdata() {\n    //fix TypeError: o is undefined\n    for (var _iterator = _createForOfIteratorHelperLoose(this.chart.data.dataset), _step; !(_step = _iterator()).done;) {\n      var dataset = _step.value;\n      if (dataset && dataset.data) dataset.data = [];\n    }\n\n    if (this.sectionid) this.chart.config.options.section = [];\n  }\n  /**\n   * Returns unique color per index- neighbouring colors are different using golden angle approximation\n   * @param index\n   * @returns {string} usable by CSS or DOM elements\n   */\n  //  const hue = (i - 1) * 137.508; // use golden angle approximation\n  //  var color = `hsl(${hue},85%,91%)`;\n  ;\n\n  _proto.selectColor = function selectColor(index, saturation, lightness) {\n    if (saturation === void 0) {\n      saturation = 55;\n    }\n\n    if (lightness === void 0) {\n      lightness = 55;\n    }\n\n    var hue = (index - 1) * 137.508; // use golden angle approximation\n\n    return \"hsl(\" + hue + \",\" + saturation + \"%,\" + lightness + \"%)\";\n  }\n  /**\n   * process all attributes of <bdl-chart> component and sets appropriate settings of subesquent chartjs\n   */\n  ;\n\n  _proto.bind = function bind() {\n    var _this2 = this;\n\n    //console.log('chartjs bind');\n    this.refindex = myParseInt(this.refindex, 10);\n    this.refvalues = parseInt(this.refvalues, 10);\n    this.refendindex = this.refindex + this.refvalues; //empty plugins by default\n\n    this.plugins = []; //configure convertors - used to convert units received from fmi\n\n    if (this.convertors) {\n      var convertvalues = this.convertors.split(';');\n\n      var identity = function identity(x) {\n        return x;\n      };\n\n      this.operation = [];\n\n      for (var i = 0; i < convertvalues.length; i++) {\n        if (convertvalues[i].includes(',')) {\n          //convert values are in form numerator,denominator contains comma ','\n          var convertitems = convertvalues[i].split(',');\n          if (convertitems[0] === '1' && convertitems[1] === '1') this.operation.push(identity);else {\n            (function () {\n              var numerator = parseFloat(convertitems[0]);\n              var denominator = parseFloat(convertitems[1]);\n\n              _this2.operation.push(function (x) {\n                return x * numerator / denominator;\n              });\n            })();\n          }\n        } else {\n          //convert values are in form of expression, do not contain comma\n          if (convertvalues === '1/x') this.operation.push(function (x) {\n            return 1 / x;\n          });else {\n            (function () {\n              // for eval() security filter only allowed characters:\n              // algebraic, digits, e, dot, modulo, parenthesis and 'x' and 'e' is allowed\n              var expression = convertvalues[i].replace(/[^-\\d/*+.()%xe]/g, '');\n              console.log('chartjs bind(), evaluating expression:' + convertvalues[i] + ' securely filtered to :' + expression); // eslint-disable-next-line no-eval\n\n              _this2.operation.push(function (x) {\n                return eval(expression);\n              });\n            })();\n          }\n        }\n      }\n    } //sets boolean value - if verticalline attribute is set\n\n\n    if (typeof this.generatelabels === 'string') {\n      this.generatelabels = this.generatelabels === 'true';\n    } //sets color of each dataset as different as possible\n    //and set initial data in chart\n    //set labels - separated by comma\n\n\n    if (this.labels) this.chlabels = this.labels.split(','); //else generate labels as 'variable 1' ...\n    else {\n      //this.chlabels = [...Array(this.refvalues)].map((_, i) => this.generatelabels ? `variable ${i}` : '');\n      //this seems not to be correctly transpilled to ES5, therefore following generator ->\n      this.chlabels = [];\n\n      for (var _i = 0; _i < this.refvalues; _i++) {\n        var ilabel = this.generatelabels ? 'variable ' + _i : '';\n        this.chlabels.push(ilabel);\n      }\n    }\n    this.colors = [];\n    var mydatastr = this.initialdata.split(',');\n    this.mydata = mydatastr.map(function (x) {\n      return parseFloat(x);\n    });\n\n    for (var _i2 = 0; _i2 < this.refvalues; _i2++) {\n      if (!this.mydata[_i2]) {//this.mydata.push(0);\n        //console.log('chartjs no data');\n      }\n\n      this.colors.push(this.selectColor(_i2));\n    }\n\n    var datasets = [{\n      data: this.mydata,\n      backgroundColor: this.colors\n    }];\n    this.data = {\n      labels: this.chlabels,\n      datasets: datasets\n    }; //bind - string value to boolean\n\n    if (typeof this.animate === 'string') {\n      this.animate = this.animate === 'true';\n    }\n\n    if (typeof this.responsive === 'string') {\n      this.responsive = this.responsive === 'true';\n    } //set animation options\n\n\n    var animopts1 = {\n      animateScale: true,\n      animateRotate: true,\n      duration: 500\n    };\n    var animopts2 = {\n      duration: 0\n    }; //select options based on attribute value - whether to animate or not\n\n    var animopts = this.animate ? animopts1 : animopts2; //set labels for axes in chartjs opts\n\n    var axisopts = {};\n\n    if (this.ylabel) {\n      axisopts.yAxes = [{\n        scaleLabel: {\n          display: true,\n          labelString: this.ylabel\n        }\n      }];\n    }\n\n    if (this.xlabel) {\n      axisopts.xAxes = [{\n        scaleLabel: {\n          display: true,\n          labelString: this.xlabel\n        }\n      }];\n    } //initialize options - used later by chartjs instance\n\n\n    this.options = {\n      live: true,\n      responsive: this.responsive,\n      //true - rescale, false - will keep canvas width and height\n      legend: {\n        //display: false,\n        position: 'top'\n      },\n      animation: animopts,\n      tooltips: {\n        position: 'nearest',\n        mode: 'index',\n        intersect: false,\n        titleFontFamily: 'Open Sans',\n        backgroundColor: 'rgba(0,0,0,0.3)',\n        //titleFontColor: 'red',\n        caretSize: 5,\n        cornerRadius: 4,\n        xPadding: 3,\n        yPadding: 3\n      },\n      hover: {\n        animationDuration: 0 //disable animation on hover - e.g. for tooltips\n\n      },\n      scales: axisopts\n    }; //sets boolean value - if verticalline attribute is set\n\n    if (typeof this.verticalline === 'string') {\n      this.verticalline = this.verticalline === 'true';\n    }\n\n    if (typeof this.maxdata === 'string') {\n      this.maxdata = parseInt(this.maxdata, 10);\n    } //if sections are requested - define chartjs plugin to draw it in background\n\n\n    if (this.sectionid) {\n      this.options.section = [];\n    }\n\n    this.tooltips = ['mousemove', 'touchstart', 'touchmove', 'click'];\n  }\n  /**\n   * this is called when the DOM is attached to view - instantiate the chartjs and sets all necesary binding\n   */\n  ;\n\n  _proto.attached = function attached() {\n    //console.log('chartjs attached');\n    //listening to custom event fmidata and fmireset\n    var fromel = document.getElementById(this.fromid);\n\n    if (fromel) {\n      fromel.addEventListener('fmidata', this.handleValueChange);\n      fromel.addEventListener('fmireset', this.handleReset);\n    } else {\n      console.log('chartjs WARNING, null fromid element');\n    }\n\n    if (this.sectionid) {\n      var sectionel = document.getElementById(this.sectionid);\n      if (sectionel) sectionel.addEventListener('addsection', this.handleAddSection);else console.log('chartjs WARNING, null sectionid element');\n    } //unregister\n\n\n    _chart.default.plugins.unregister(_chartjsPluginDatalabels.default); //for verticalline option - register controller for BdlChartjs\n\n\n    if (this.verticalline) {\n      _chart.default.defaults.LineWithLine = _chart.default.defaults.line;\n      _chart.default.controllers.LineWithLine = _chart.default.controllers.line.extend({\n        draw: function draw(ease) {\n          _chart.default.controllers.line.prototype.draw.call(this, ease);\n\n          if (this.chart.tooltip._active && this.chart.tooltip._active.length) {\n            var activePoint = this.chart.tooltip._active[0];\n            var _ctx = this.chart.ctx;\n            var x = activePoint.tooltipPosition().x;\n            var topY = this.chart.legend.bottom;\n            var bottomY = this.chart.chartArea.bottom; // draw line\n\n            _ctx.save();\n\n            _ctx.beginPath();\n\n            _ctx.moveTo(x, topY);\n\n            _ctx.lineTo(x, bottomY);\n\n            _ctx.lineWidth = 1;\n            _ctx.strokeStyle = '#555';\n\n            _ctx.stroke();\n\n            _ctx.restore();\n          }\n        }\n      });\n    } //for sections register chartjs plugin\n\n\n    if (this.sectionid) {\n      _chart.default.pluginService.register({\n        beforeDraw: function beforeDraw(chart, easing) {\n          if (chart.config.options.section && chart.config.options.section.length > 0) {\n            var _ctx2 = chart.chart.ctx;\n            var chartArea = chart.chartArea;\n            var meta = chart.getDatasetMeta(0);\n            var i;\n\n            _ctx2.save(); //console.log('chartjs sections', chart.config.options.section);\n\n\n            for (i = 1; i < chart.config.options.section.length; i++) {\n              //console.log('chartjs sectionplugin:i, section[i-1], section[1],start,stop)', i, chart.config.options.section[i - 1],chart.config.options.section[i]);\n              var start = meta.data[chart.config.options.section[i - 1].index]._model.x;\n              var stop = meta.data[chart.config.options.section[i].index]._model.x;\n              /*const hue = (i - 1) * 137.508; // use golden angle approximation\n              ctx.fillStyle = `hsl(${hue},85%,91%)`;\n               */\n              //bar\n\n              _ctx2.fillStyle = chart.config.options.section[i - 1].color;\n\n              _ctx2.fillRect(start, chartArea.top, stop - start, chartArea.bottom - chartArea.top); //label\n              //ctx.translate(start, chartArea.top);\n              //ctx.rotate(Math.PI / 2);\n\n\n              _ctx2.save();\n\n              _ctx2.translate(start, chartArea.top);\n\n              _ctx2.rotate(90 * Math.PI / 180);\n\n              _ctx2.fillStyle = '#aaa';\n              _ctx2.font = '12px Helvetica';\n\n              _ctx2.fillText(chart.config.options.section[i - 1].label, 5, -5); //start, chartArea.top);\n\n\n              _ctx2.restore();\n            }\n\n            _ctx2.restore(); //console.log('last i',i);\n            //last section\n\n\n            i = chart.config.options.section.length;\n\n            if (i > 0 && chart.config.options.section[i - 1].index < meta.data.length - 1) {\n              //draw last section\n              var _start = meta.data[chart.config.options.section[i - 1].index]._model.x;\n              var _stop = meta.data[meta.data.length - 1]._model.x; //console.log (start,stop);\n\n              /*\n              const hue = (i - 1) * 137.508; // use golden angle approximation\n              var color = `hsl(${hue},85%,91%)`;\n               */\n\n              _ctx2.fillStyle = chart.config.options.section[i - 1].color; //console.log (chartArea);\n\n              _ctx2.fillRect(_start, chartArea.top, _stop - _start, chartArea.bottom - chartArea.top);\n\n              _ctx2.save();\n\n              _ctx2.translate(_start, chartArea.top);\n\n              _ctx2.rotate(90 * Math.PI / 180);\n\n              _ctx2.fillStyle = '#aaa';\n              _ctx2.font = '12px Helvetica';\n\n              _ctx2.fillText(chart.config.options.section[i - 1].label, 5, -5); //start, chartArea.top);\n\n\n              _ctx2.restore();\n            }\n          }\n        }\n      });\n    }\n\n    if (this.datalabels) {\n      console.log('datalabels true ,setting plugin', this.datalabels);\n\n      _chart.default.pluginService.register({\n        afterDatasetsDraw: function afterDatasetsDraw(chartInstance, easing) {\n          // To only draw at the end of animation, check for easing === 1\n          //if (dataset && dataset.datalabels) {\n          var ctx = chartInstance.chart.ctx;\n          chartInstance.data.datasets.forEach(function (dataset, i) {\n            if (dataset && dataset.datalabels) {\n              var meta = chartInstance.getDatasetMeta(i);\n\n              if (!meta.hidden) {\n                meta.data.forEach(function (element, index) {\n                  if (dataset.datalabels[index].length > 0) {\n                    // Draw the text in black, with the specified font\n                    ctx.fillStyle = '#aaa';\n                    ctx.font = '12px Helvetica'; // Just naively convert to string for now\n\n                    var dataString = dataset.datalabels[index]; // Make sure alignment settings are correct\n\n                    ctx.textAlign = 'center';\n                    ctx.textBaseline = 'middle';\n                    var padding = 5;\n                    var position = element.tooltipPosition();\n                    ctx.fillText(dataString, position.x, position.y - 12 / 2 - padding);\n                  }\n                });\n              }\n            }\n          });\n        }\n      });\n    } //canvasobj - if defined then use this object name to get canvas object -  otherwise the one from template\n\n\n    var ctx = this.canvasobj ? window[this.canvasobj] : this.chartcanvas.getContext('2d'); //ctx may be null if canvasobj is not yet initialized.\n\n    if (ctx) this.initChart(ctx); //init chart only if ctx is ready\n    else window.lazyInitChart = this;\n  };\n\n  _proto.initChart = function initChart(ctx) {\n    var that = this;\n\n    if (window.lazyInitChart) {\n      var _that = window.lazyInitChart;\n    }\n\n    that.chart = new _chart.default(ctx, {\n      plugins: that.plugins,\n      type: that.type,\n      data: that.data,\n      options: that.options,\n      tooltipEvents: that.tooltips\n    }); // console.log('chartjs data', this.data);\n  }\n  /**\n   * called when component is detached from view - remove event listeners - no need to update chart\n   */\n  ;\n\n  _proto.detached = function detached() {\n    if (document.getElementById(this.fromid)) {\n      document.getElementById(this.fromid).removeEventListener('fmidata', this.handleValueChange);\n      document.getElementById(this.fromid).removeEventListener('fmireset', this.handleReset);\n\n      if (this.sectionid) {\n        document.getElementById(this.sectionid).removeEventListener('addsection', this.handleAddSection);\n      }\n    }\n  }\n  /**\n   * asks for filename and creates blob with CSV data from chart which initiates web browser download dialog.\n   * CSV -  time point per row\n   */\n  ;\n\n  _proto.download = function download() {\n    //ask for filename\n    var filename = prompt('File name (*.csv):', 'data.csv');\n\n    if (filename) {\n      //adds csv as extension\n      if (!filename.endsWith('.csv')) filename = filename.concat('.csv'); //labels first row\n\n      var content = 'Time,' + this.labels + '\\n'; //transpose each row = variable in specific time\n\n      for (var i = 0; i < this.chart.data.labels.length; i++) {\n        var row = this.chart.data.labels[i];\n\n        for (var j = 0; j < this.chart.data.datasets.length; j++) {\n          row += ',' + this.chart.data.datasets[j].data[i];\n        }\n\n        content += row + '\\n';\n      }\n\n      var blob = new Blob([content], {\n        type: 'text/csv;charset=utf-8;'\n      });\n      saveAs(blob, filename);\n    }\n  }\n  /**\n   * asks for filename and creates blob with CSV data from chart which initiates web browser download dialog\n   * CSV - variable values per row\n   */\n  ;\n\n  _proto.downloadflat = function downloadflat() {\n    //ask for filename\n    var filename = prompt('File name (*.csv):', 'data.csv');\n\n    if (filename) {\n      //adds csv as extension\n      if (!filename.endsWith('.csv')) filename = filename.concat('.csv'); //labels first row - each row is then all data per variable - transposition might be needed\n\n      var content = 'variable name,values ...' + '\\n';\n      var labels = this.labels.split(','); // variable per row\n      //chart labels - usually time\n\n      content = content + 'Time,' + this.chart.data.labels.join(',') + '\\n'; //dataset data on other rows\n\n      for (var i = 0; i < this.chart.data.datasets.length; i++) {\n        content = content + labels[i] + ',' + this.chart.data.datasets[i].data.join(',') + '\\n';\n      }\n\n      var blob = new Blob([content], {\n        type: 'text/csv;charset=utf-8;'\n      });\n      saveAs(blob, filename);\n    }\n  }\n  /**\n   * Adds new section in chartarea - current last data in dataset\n   */\n  ;\n\n  _proto.addSection = function addSection(label) {\n    if (label === void 0) {\n      label = '';\n    }\n\n    this.indexsection++;\n    if (!label) label = '';\n    console.log('chartjs.addsection()', this.chart.data.labels.length - 1);\n    this.chart.config.options.section.push({\n      index: this.chart.data.labels.length - 1,\n      color: this.selectColor(this.indexsection, 85, 91),\n      label: label\n    });\n  };\n\n  return Chartjs;\n}(), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"fromid\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"labels\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"refindex\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, \"refvalues\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, \"type\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 'doughnut';\n  }\n}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, \"maxdata\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 256;\n  }\n}), _descriptor7 = _applyDecoratedDescriptor(_class.prototype, \"initialdata\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return '';\n  }\n}), _descriptor8 = _applyDecoratedDescriptor(_class.prototype, \"width\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 300;\n  }\n}), _descriptor9 = _applyDecoratedDescriptor(_class.prototype, \"height\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 200;\n  }\n}), _descriptor10 = _applyDecoratedDescriptor(_class.prototype, \"animate\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return false;\n  }\n}), _descriptor11 = _applyDecoratedDescriptor(_class.prototype, \"id\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor12 = _applyDecoratedDescriptor(_class.prototype, \"ylabel\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor13 = _applyDecoratedDescriptor(_class.prototype, \"xlabel\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor14 = _applyDecoratedDescriptor(_class.prototype, \"convertors\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor15 = _applyDecoratedDescriptor(_class.prototype, \"verticalline\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return false;\n  }\n}), _descriptor16 = _applyDecoratedDescriptor(_class.prototype, \"generatelabels\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return false;\n  }\n}), _descriptor17 = _applyDecoratedDescriptor(_class.prototype, \"sectionid\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor18 = _applyDecoratedDescriptor(_class.prototype, \"responsive\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return false;\n  }\n}), _descriptor19 = _applyDecoratedDescriptor(_class.prototype, \"canvasobj\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class);\nexports.Chartjs = Chartjs;\n//# sourceMappingURL=chartjs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2Rpc3QvbmF0aXZlLW1vZHVsZXMvZWxlbWVudHMvY2hhcnRqcy5qcz9lOWFmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5DaGFydGpzID0gdm9pZCAwO1xuXG52YXIgX2NoYXJ0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2hhcnQuanNcIikpO1xuXG52YXIgX2NoYXJ0anNQbHVnaW5EYXRhbGFiZWxzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVsc1wiKSk7XG5cbnZhciBfYXVyZWxpYUZyYW1ld29yayA9IHJlcXVpcmUoXCJhdXJlbGlhLWZyYW1ld29ya1wiKTtcblxudmFyIF9jbGFzcywgX2Rlc2NyaXB0b3IsIF9kZXNjcmlwdG9yMiwgX2Rlc2NyaXB0b3IzLCBfZGVzY3JpcHRvcjQsIF9kZXNjcmlwdG9yNSwgX2Rlc2NyaXB0b3I2LCBfZGVzY3JpcHRvcjcsIF9kZXNjcmlwdG9yOCwgX2Rlc2NyaXB0b3I5LCBfZGVzY3JpcHRvcjEwLCBfZGVzY3JpcHRvcjExLCBfZGVzY3JpcHRvcjEyLCBfZGVzY3JpcHRvcjEzLCBfZGVzY3JpcHRvcjE0LCBfZGVzY3JpcHRvcjE1LCBfZGVzY3JpcHRvcjE2LCBfZGVzY3JpcHRvcjE3LCBfZGVzY3JpcHRvcjE4LCBfZGVzY3JpcHRvcjE5O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoaXQpIHJldHVybiAoaXQgPSBpdC5jYWxsKG8pKS5uZXh0LmJpbmQoaXQpOyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHJldHVybiBmdW5jdGlvbiAoKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvciwgY29udGV4dCkgeyBpZiAoIWRlc2NyaXB0b3IpIHJldHVybjsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHsgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLCBjb25maWd1cmFibGU6IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlLCB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSwgdmFsdWU6IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIgPyBkZXNjcmlwdG9yLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDAgfSk7IH1cblxuZnVuY3Rpb24gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5LCBkZWNvcmF0b3JzLCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7IHZhciBkZXNjID0ge307IE9iamVjdC5rZXlzKGRlc2NyaXB0b3IpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBkZXNjW2tleV0gPSBkZXNjcmlwdG9yW2tleV07IH0pOyBkZXNjLmVudW1lcmFibGUgPSAhIWRlc2MuZW51bWVyYWJsZTsgZGVzYy5jb25maWd1cmFibGUgPSAhIWRlc2MuY29uZmlndXJhYmxlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjIHx8IGRlc2MuaW5pdGlhbGl6ZXIpIHsgZGVzYy53cml0YWJsZSA9IHRydWU7IH0gZGVzYyA9IGRlY29yYXRvcnMuc2xpY2UoKS5yZXZlcnNlKCkucmVkdWNlKGZ1bmN0aW9uIChkZXNjLCBkZWNvcmF0b3IpIHsgcmV0dXJuIGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5LCBkZXNjKSB8fCBkZXNjOyB9LCBkZXNjKTsgaWYgKGNvbnRleHQgJiYgZGVzYy5pbml0aWFsaXplciAhPT0gdm9pZCAwKSB7IGRlc2MudmFsdWUgPSBkZXNjLmluaXRpYWxpemVyID8gZGVzYy5pbml0aWFsaXplci5jYWxsKGNvbnRleHQpIDogdm9pZCAwOyBkZXNjLmluaXRpYWxpemVyID0gdW5kZWZpbmVkOyB9IGlmIChkZXNjLmluaXRpYWxpemVyID09PSB2b2lkIDApIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2MpOyBkZXNjID0gbnVsbDsgfSByZXR1cm4gZGVzYzsgfVxuXG5mdW5jdGlvbiBfaW5pdGlhbGl6ZXJXYXJuaW5nSGVscGVyKGRlc2NyaXB0b3IsIGNvbnRleHQpIHsgdGhyb3cgbmV3IEVycm9yKCdEZWNvcmF0aW5nIGNsYXNzIHByb3BlcnR5IGZhaWxlZC4gUGxlYXNlIGVuc3VyZSB0aGF0ICcgKyAncHJvcG9zYWwtY2xhc3MtcHJvcGVydGllcyBpcyBlbmFibGVkIGFuZCBydW5zIGFmdGVyIHRoZSBkZWNvcmF0b3JzIHRyYW5zZm9ybS4nKTsgfVxuXG4vL3JldHVybnMgYXJyYXkgb2YgbnVtYmVycyBpZiBjb250YWlucyBjb21tYSwgb3IgbnVtYmVyIC0gaW50XG5mdW5jdGlvbiBteVBhcnNlSW50KHN0ciwgcmFkZGl4KSB7XG4gIGlmIChzdHIubGFzdEluZGV4T2YoJywnKSA+IDApIHJldHVybiBzdHIuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoeCwgcmFkZGl4KTtcbiAgfSk7ZWxzZSByZXR1cm4gcGFyc2VJbnQoc3RyLCByYWRkaXgpO1xufVxuXG52YXIgQ2hhcnRqcyA9IChfY2xhc3MgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvL2lkIHRvIGxpc3RlbiBhZGRzZWN0aW9uIGV2ZW50XG4gIC8vZmFsc2UgLSB0byBrZWVwIHdpZHRoIGFuZCBoZWlnaHQsIHRydWUgLSB0byByZXNjYWxlXG4gIC8vbWF5IGJlIGNvbmZpZ3VyZWQgYnkgc3ViY2xhc3Nlc1xuXG4gIC8qKlxuICAgKiBpbml0aWFsaXplcyBoYW5kbGVycyBmb3IgZXZlbnQgcHJvY2Vzc2luZyAtIHRoaXMgaXMgcmVjb21tZW5kZWQgd2F5XG4gICAqL1xuICBmdW5jdGlvbiBDaGFydGpzKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZyb21pZFwiLCBfZGVzY3JpcHRvciwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxhYmVsc1wiLCBfZGVzY3JpcHRvcjIsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWZpbmRleFwiLCBfZGVzY3JpcHRvcjMsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWZ2YWx1ZXNcIiwgX2Rlc2NyaXB0b3I0LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBfZGVzY3JpcHRvcjUsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhkYXRhXCIsIF9kZXNjcmlwdG9yNiwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaXRpYWxkYXRhXCIsIF9kZXNjcmlwdG9yNywgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndpZHRoXCIsIF9kZXNjcmlwdG9yOCwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhlaWdodFwiLCBfZGVzY3JpcHRvcjksIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJhbmltYXRlXCIsIF9kZXNjcmlwdG9yMTAsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCBfZGVzY3JpcHRvcjExLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwieWxhYmVsXCIsIF9kZXNjcmlwdG9yMTIsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJ4bGFiZWxcIiwgX2Rlc2NyaXB0b3IxMywgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnZlcnRvcnNcIiwgX2Rlc2NyaXB0b3IxNCwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcnRpY2FsbGluZVwiLCBfZGVzY3JpcHRvcjE1LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2VuZXJhdGVsYWJlbHNcIiwgX2Rlc2NyaXB0b3IxNiwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlY3Rpb25pZFwiLCBfZGVzY3JpcHRvcjE3LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzcG9uc2l2ZVwiLCBfZGVzY3JpcHRvcjE4LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FudmFzb2JqXCIsIF9kZXNjcmlwdG9yMTksIHRoaXMpO1xuXG4gICAgdGhpcy5pbmRleHNlY3Rpb24gPSAwO1xuICAgIHRoaXMuZGF0YWxhYmVscyA9IGZhbHNlO1xuXG4gICAgdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAvL3NldHMgZGF0YSB0byBkYXRhc2V0XG4gICAgICAvL2FwcGx5IHZhbHVlIGNvbnZlcnQgYW1vbmcgYWxsIGRhdGFcbiAgICAgIHZhciByYXdkYXRhID0gZS5kZXRhaWwuZGF0YS5zbGljZShfdGhpcy5yZWZpbmRleCwgX3RoaXMucmVmZW5kaW5kZXgpOyAvL2lmIGNvbnZlcnQgb3BlcmF0aW9uIGlzIGRlZmluZWQgYXMgYXJyYXlcblxuICAgICAgaWYgKF90aGlzLm9wZXJhdGlvbikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd2RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAvL2lmIHBhcnRpY3VsYXIgb3BlcmF0aW9uIGlzIGRlZmluZWRcbiAgICAgICAgICBpZiAoX3RoaXMub3BlcmF0aW9uW2ldKSByYXdkYXRhW2ldID0gX3RoaXMub3BlcmF0aW9uW2ldKHJhd2RhdGFbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YSA9IHJhd2RhdGE7XG5cbiAgICAgIF90aGlzLmNoYXJ0LnVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICB0aGlzLmhhbmRsZVJlc2V0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vY29uc29sZS5sb2coJ2hhbmRsZXJlc2V0Jyk7XG4gICAgICBfdGhpcy5yZXNldGRhdGEoKTtcblxuICAgICAgX3RoaXMuY2hhcnQudXBkYXRlKCk7XG4gICAgfTtcblxuICAgIHRoaXMuaGFuZGxlQWRkU2VjdGlvbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBfdGhpcy5hZGRTZWN0aW9uKGUuZGV0YWlsLmxhYmVsKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBlbXB0aWVzIGRhdGEgaW4gZXZlcnkgZGF0YXNldCBhbmQgZW1wdGllcyBzZWN0aW9uXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IENoYXJ0anMucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZXNldGRhdGEgPSBmdW5jdGlvbiByZXNldGRhdGEoKSB7XG4gICAgLy9maXggVHlwZUVycm9yOiBvIGlzIHVuZGVmaW5lZFxuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodGhpcy5jaGFydC5kYXRhLmRhdGFzZXQpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgdmFyIGRhdGFzZXQgPSBfc3RlcC52YWx1ZTtcbiAgICAgIGlmIChkYXRhc2V0ICYmIGRhdGFzZXQuZGF0YSkgZGF0YXNldC5kYXRhID0gW107XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2VjdGlvbmlkKSB0aGlzLmNoYXJ0LmNvbmZpZy5vcHRpb25zLnNlY3Rpb24gPSBbXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB1bmlxdWUgY29sb3IgcGVyIGluZGV4LSBuZWlnaGJvdXJpbmcgY29sb3JzIGFyZSBkaWZmZXJlbnQgdXNpbmcgZ29sZGVuIGFuZ2xlIGFwcHJveGltYXRpb25cbiAgICogQHBhcmFtIGluZGV4XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHVzYWJsZSBieSBDU1Mgb3IgRE9NIGVsZW1lbnRzXG4gICAqL1xuICAvLyAgY29uc3QgaHVlID0gKGkgLSAxKSAqIDEzNy41MDg7IC8vIHVzZSBnb2xkZW4gYW5nbGUgYXBwcm94aW1hdGlvblxuICAvLyAgdmFyIGNvbG9yID0gYGhzbCgke2h1ZX0sODUlLDkxJSlgO1xuICA7XG5cbiAgX3Byb3RvLnNlbGVjdENvbG9yID0gZnVuY3Rpb24gc2VsZWN0Q29sb3IoaW5kZXgsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcykge1xuICAgIGlmIChzYXR1cmF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIHNhdHVyYXRpb24gPSA1NTtcbiAgICB9XG5cbiAgICBpZiAobGlnaHRuZXNzID09PSB2b2lkIDApIHtcbiAgICAgIGxpZ2h0bmVzcyA9IDU1O1xuICAgIH1cblxuICAgIHZhciBodWUgPSAoaW5kZXggLSAxKSAqIDEzNy41MDg7IC8vIHVzZSBnb2xkZW4gYW5nbGUgYXBwcm94aW1hdGlvblxuXG4gICAgcmV0dXJuIFwiaHNsKFwiICsgaHVlICsgXCIsXCIgKyBzYXR1cmF0aW9uICsgXCIlLFwiICsgbGlnaHRuZXNzICsgXCIlKVwiO1xuICB9XG4gIC8qKlxuICAgKiBwcm9jZXNzIGFsbCBhdHRyaWJ1dGVzIG9mIDxiZGwtY2hhcnQ+IGNvbXBvbmVudCBhbmQgc2V0cyBhcHByb3ByaWF0ZSBzZXR0aW5ncyBvZiBzdWJlc3F1ZW50IGNoYXJ0anNcbiAgICovXG4gIDtcblxuICBfcHJvdG8uYmluZCA9IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAvL2NvbnNvbGUubG9nKCdjaGFydGpzIGJpbmQnKTtcbiAgICB0aGlzLnJlZmluZGV4ID0gbXlQYXJzZUludCh0aGlzLnJlZmluZGV4LCAxMCk7XG4gICAgdGhpcy5yZWZ2YWx1ZXMgPSBwYXJzZUludCh0aGlzLnJlZnZhbHVlcywgMTApO1xuICAgIHRoaXMucmVmZW5kaW5kZXggPSB0aGlzLnJlZmluZGV4ICsgdGhpcy5yZWZ2YWx1ZXM7IC8vZW1wdHkgcGx1Z2lucyBieSBkZWZhdWx0XG5cbiAgICB0aGlzLnBsdWdpbnMgPSBbXTsgLy9jb25maWd1cmUgY29udmVydG9ycyAtIHVzZWQgdG8gY29udmVydCB1bml0cyByZWNlaXZlZCBmcm9tIGZtaVxuXG4gICAgaWYgKHRoaXMuY29udmVydG9ycykge1xuICAgICAgdmFyIGNvbnZlcnR2YWx1ZXMgPSB0aGlzLmNvbnZlcnRvcnMuc3BsaXQoJzsnKTtcblxuICAgICAgdmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMub3BlcmF0aW9uID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udmVydHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY29udmVydHZhbHVlc1tpXS5pbmNsdWRlcygnLCcpKSB7XG4gICAgICAgICAgLy9jb252ZXJ0IHZhbHVlcyBhcmUgaW4gZm9ybSBudW1lcmF0b3IsZGVub21pbmF0b3IgY29udGFpbnMgY29tbWEgJywnXG4gICAgICAgICAgdmFyIGNvbnZlcnRpdGVtcyA9IGNvbnZlcnR2YWx1ZXNbaV0uc3BsaXQoJywnKTtcbiAgICAgICAgICBpZiAoY29udmVydGl0ZW1zWzBdID09PSAnMScgJiYgY29udmVydGl0ZW1zWzFdID09PSAnMScpIHRoaXMub3BlcmF0aW9uLnB1c2goaWRlbnRpdHkpO2Vsc2Uge1xuICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIG51bWVyYXRvciA9IHBhcnNlRmxvYXQoY29udmVydGl0ZW1zWzBdKTtcbiAgICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gcGFyc2VGbG9hdChjb252ZXJ0aXRlbXNbMV0pO1xuXG4gICAgICAgICAgICAgIF90aGlzMi5vcGVyYXRpb24ucHVzaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4ICogbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9jb252ZXJ0IHZhbHVlcyBhcmUgaW4gZm9ybSBvZiBleHByZXNzaW9uLCBkbyBub3QgY29udGFpbiBjb21tYVxuICAgICAgICAgIGlmIChjb252ZXJ0dmFsdWVzID09PSAnMS94JykgdGhpcy5vcGVyYXRpb24ucHVzaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIDEgLyB4O1xuICAgICAgICAgIH0pO2Vsc2Uge1xuICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgLy8gZm9yIGV2YWwoKSBzZWN1cml0eSBmaWx0ZXIgb25seSBhbGxvd2VkIGNoYXJhY3RlcnM6XG4gICAgICAgICAgICAgIC8vIGFsZ2VicmFpYywgZGlnaXRzLCBlLCBkb3QsIG1vZHVsbywgcGFyZW50aGVzaXMgYW5kICd4JyBhbmQgJ2UnIGlzIGFsbG93ZWRcbiAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBjb252ZXJ0dmFsdWVzW2ldLnJlcGxhY2UoL1teLVxcZC8qKy4oKSV4ZV0vZywgJycpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnY2hhcnRqcyBiaW5kKCksIGV2YWx1YXRpbmcgZXhwcmVzc2lvbjonICsgY29udmVydHZhbHVlc1tpXSArICcgc2VjdXJlbHkgZmlsdGVyZWQgdG8gOicgKyBleHByZXNzaW9uKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV2YWxcblxuICAgICAgICAgICAgICBfdGhpczIub3BlcmF0aW9uLnB1c2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZhbChleHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy9zZXRzIGJvb2xlYW4gdmFsdWUgLSBpZiB2ZXJ0aWNhbGxpbmUgYXR0cmlidXRlIGlzIHNldFxuXG5cbiAgICBpZiAodHlwZW9mIHRoaXMuZ2VuZXJhdGVsYWJlbHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmdlbmVyYXRlbGFiZWxzID0gdGhpcy5nZW5lcmF0ZWxhYmVscyA9PT0gJ3RydWUnO1xuICAgIH0gLy9zZXRzIGNvbG9yIG9mIGVhY2ggZGF0YXNldCBhcyBkaWZmZXJlbnQgYXMgcG9zc2libGVcbiAgICAvL2FuZCBzZXQgaW5pdGlhbCBkYXRhIGluIGNoYXJ0XG4gICAgLy9zZXQgbGFiZWxzIC0gc2VwYXJhdGVkIGJ5IGNvbW1hXG5cblxuICAgIGlmICh0aGlzLmxhYmVscykgdGhpcy5jaGxhYmVscyA9IHRoaXMubGFiZWxzLnNwbGl0KCcsJyk7IC8vZWxzZSBnZW5lcmF0ZSBsYWJlbHMgYXMgJ3ZhcmlhYmxlIDEnIC4uLlxuICAgIGVsc2Uge1xuICAgICAgLy90aGlzLmNobGFiZWxzID0gWy4uLkFycmF5KHRoaXMucmVmdmFsdWVzKV0ubWFwKChfLCBpKSA9PiB0aGlzLmdlbmVyYXRlbGFiZWxzID8gYHZhcmlhYmxlICR7aX1gIDogJycpO1xuICAgICAgLy90aGlzIHNlZW1zIG5vdCB0byBiZSBjb3JyZWN0bHkgdHJhbnNwaWxsZWQgdG8gRVM1LCB0aGVyZWZvcmUgZm9sbG93aW5nIGdlbmVyYXRvciAtPlxuICAgICAgdGhpcy5jaGxhYmVscyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy5yZWZ2YWx1ZXM7IF9pKyspIHtcbiAgICAgICAgdmFyIGlsYWJlbCA9IHRoaXMuZ2VuZXJhdGVsYWJlbHMgPyAndmFyaWFibGUgJyArIF9pIDogJyc7XG4gICAgICAgIHRoaXMuY2hsYWJlbHMucHVzaChpbGFiZWwpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbG9ycyA9IFtdO1xuICAgIHZhciBteWRhdGFzdHIgPSB0aGlzLmluaXRpYWxkYXRhLnNwbGl0KCcsJyk7XG4gICAgdGhpcy5teWRhdGEgPSBteWRhdGFzdHIubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdCh4KTtcbiAgICB9KTtcblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHRoaXMucmVmdmFsdWVzOyBfaTIrKykge1xuICAgICAgaWYgKCF0aGlzLm15ZGF0YVtfaTJdKSB7Ly90aGlzLm15ZGF0YS5wdXNoKDApO1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdjaGFydGpzIG5vIGRhdGEnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb2xvcnMucHVzaCh0aGlzLnNlbGVjdENvbG9yKF9pMikpO1xuICAgIH1cblxuICAgIHZhciBkYXRhc2V0cyA9IFt7XG4gICAgICBkYXRhOiB0aGlzLm15ZGF0YSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5jb2xvcnNcbiAgICB9XTtcbiAgICB0aGlzLmRhdGEgPSB7XG4gICAgICBsYWJlbHM6IHRoaXMuY2hsYWJlbHMsXG4gICAgICBkYXRhc2V0czogZGF0YXNldHNcbiAgICB9OyAvL2JpbmQgLSBzdHJpbmcgdmFsdWUgdG8gYm9vbGVhblxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLmFuaW1hdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmFuaW1hdGUgPSB0aGlzLmFuaW1hdGUgPT09ICd0cnVlJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMucmVzcG9uc2l2ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMucmVzcG9uc2l2ZSA9IHRoaXMucmVzcG9uc2l2ZSA9PT0gJ3RydWUnO1xuICAgIH0gLy9zZXQgYW5pbWF0aW9uIG9wdGlvbnNcblxuXG4gICAgdmFyIGFuaW1vcHRzMSA9IHtcbiAgICAgIGFuaW1hdGVTY2FsZTogdHJ1ZSxcbiAgICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgICBkdXJhdGlvbjogNTAwXG4gICAgfTtcbiAgICB2YXIgYW5pbW9wdHMyID0ge1xuICAgICAgZHVyYXRpb246IDBcbiAgICB9OyAvL3NlbGVjdCBvcHRpb25zIGJhc2VkIG9uIGF0dHJpYnV0ZSB2YWx1ZSAtIHdoZXRoZXIgdG8gYW5pbWF0ZSBvciBub3RcblxuICAgIHZhciBhbmltb3B0cyA9IHRoaXMuYW5pbWF0ZSA/IGFuaW1vcHRzMSA6IGFuaW1vcHRzMjsgLy9zZXQgbGFiZWxzIGZvciBheGVzIGluIGNoYXJ0anMgb3B0c1xuXG4gICAgdmFyIGF4aXNvcHRzID0ge307XG5cbiAgICBpZiAodGhpcy55bGFiZWwpIHtcbiAgICAgIGF4aXNvcHRzLnlBeGVzID0gW3tcbiAgICAgICAgc2NhbGVMYWJlbDoge1xuICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgbGFiZWxTdHJpbmc6IHRoaXMueWxhYmVsXG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnhsYWJlbCkge1xuICAgICAgYXhpc29wdHMueEF4ZXMgPSBbe1xuICAgICAgICBzY2FsZUxhYmVsOiB7XG4gICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICBsYWJlbFN0cmluZzogdGhpcy54bGFiZWxcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfSAvL2luaXRpYWxpemUgb3B0aW9ucyAtIHVzZWQgbGF0ZXIgYnkgY2hhcnRqcyBpbnN0YW5jZVxuXG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBsaXZlOiB0cnVlLFxuICAgICAgcmVzcG9uc2l2ZTogdGhpcy5yZXNwb25zaXZlLFxuICAgICAgLy90cnVlIC0gcmVzY2FsZSwgZmFsc2UgLSB3aWxsIGtlZXAgY2FudmFzIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICAvL2Rpc3BsYXk6IGZhbHNlLFxuICAgICAgICBwb3NpdGlvbjogJ3RvcCdcbiAgICAgIH0sXG4gICAgICBhbmltYXRpb246IGFuaW1vcHRzLFxuICAgICAgdG9vbHRpcHM6IHtcbiAgICAgICAgcG9zaXRpb246ICduZWFyZXN0JyxcbiAgICAgICAgbW9kZTogJ2luZGV4JyxcbiAgICAgICAgaW50ZXJzZWN0OiBmYWxzZSxcbiAgICAgICAgdGl0bGVGb250RmFtaWx5OiAnT3BlbiBTYW5zJyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjMpJyxcbiAgICAgICAgLy90aXRsZUZvbnRDb2xvcjogJ3JlZCcsXG4gICAgICAgIGNhcmV0U2l6ZTogNSxcbiAgICAgICAgY29ybmVyUmFkaXVzOiA0LFxuICAgICAgICB4UGFkZGluZzogMyxcbiAgICAgICAgeVBhZGRpbmc6IDNcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogMCAvL2Rpc2FibGUgYW5pbWF0aW9uIG9uIGhvdmVyIC0gZS5nLiBmb3IgdG9vbHRpcHNcblxuICAgICAgfSxcbiAgICAgIHNjYWxlczogYXhpc29wdHNcbiAgICB9OyAvL3NldHMgYm9vbGVhbiB2YWx1ZSAtIGlmIHZlcnRpY2FsbGluZSBhdHRyaWJ1dGUgaXMgc2V0XG5cbiAgICBpZiAodHlwZW9mIHRoaXMudmVydGljYWxsaW5lID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy52ZXJ0aWNhbGxpbmUgPSB0aGlzLnZlcnRpY2FsbGluZSA9PT0gJ3RydWUnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5tYXhkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5tYXhkYXRhID0gcGFyc2VJbnQodGhpcy5tYXhkYXRhLCAxMCk7XG4gICAgfSAvL2lmIHNlY3Rpb25zIGFyZSByZXF1ZXN0ZWQgLSBkZWZpbmUgY2hhcnRqcyBwbHVnaW4gdG8gZHJhdyBpdCBpbiBiYWNrZ3JvdW5kXG5cblxuICAgIGlmICh0aGlzLnNlY3Rpb25pZCkge1xuICAgICAgdGhpcy5vcHRpb25zLnNlY3Rpb24gPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLnRvb2x0aXBzID0gWydtb3VzZW1vdmUnLCAndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAnY2xpY2snXTtcbiAgfVxuICAvKipcbiAgICogdGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgRE9NIGlzIGF0dGFjaGVkIHRvIHZpZXcgLSBpbnN0YW50aWF0ZSB0aGUgY2hhcnRqcyBhbmQgc2V0cyBhbGwgbmVjZXNhcnkgYmluZGluZ1xuICAgKi9cbiAgO1xuXG4gIF9wcm90by5hdHRhY2hlZCA9IGZ1bmN0aW9uIGF0dGFjaGVkKCkge1xuICAgIC8vY29uc29sZS5sb2coJ2NoYXJ0anMgYXR0YWNoZWQnKTtcbiAgICAvL2xpc3RlbmluZyB0byBjdXN0b20gZXZlbnQgZm1pZGF0YSBhbmQgZm1pcmVzZXRcbiAgICB2YXIgZnJvbWVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5mcm9taWQpO1xuXG4gICAgaWYgKGZyb21lbCkge1xuICAgICAgZnJvbWVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ZtaWRhdGEnLCB0aGlzLmhhbmRsZVZhbHVlQ2hhbmdlKTtcbiAgICAgIGZyb21lbC5hZGRFdmVudExpc3RlbmVyKCdmbWlyZXNldCcsIHRoaXMuaGFuZGxlUmVzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnY2hhcnRqcyBXQVJOSU5HLCBudWxsIGZyb21pZCBlbGVtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2VjdGlvbmlkKSB7XG4gICAgICB2YXIgc2VjdGlvbmVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5zZWN0aW9uaWQpO1xuICAgICAgaWYgKHNlY3Rpb25lbCkgc2VjdGlvbmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHNlY3Rpb24nLCB0aGlzLmhhbmRsZUFkZFNlY3Rpb24pO2Vsc2UgY29uc29sZS5sb2coJ2NoYXJ0anMgV0FSTklORywgbnVsbCBzZWN0aW9uaWQgZWxlbWVudCcpO1xuICAgIH0gLy91bnJlZ2lzdGVyXG5cblxuICAgIF9jaGFydC5kZWZhdWx0LnBsdWdpbnMudW5yZWdpc3RlcihfY2hhcnRqc1BsdWdpbkRhdGFsYWJlbHMuZGVmYXVsdCk7IC8vZm9yIHZlcnRpY2FsbGluZSBvcHRpb24gLSByZWdpc3RlciBjb250cm9sbGVyIGZvciBCZGxDaGFydGpzXG5cblxuICAgIGlmICh0aGlzLnZlcnRpY2FsbGluZSkge1xuICAgICAgX2NoYXJ0LmRlZmF1bHQuZGVmYXVsdHMuTGluZVdpdGhMaW5lID0gX2NoYXJ0LmRlZmF1bHQuZGVmYXVsdHMubGluZTtcbiAgICAgIF9jaGFydC5kZWZhdWx0LmNvbnRyb2xsZXJzLkxpbmVXaXRoTGluZSA9IF9jaGFydC5kZWZhdWx0LmNvbnRyb2xsZXJzLmxpbmUuZXh0ZW5kKHtcbiAgICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdyhlYXNlKSB7XG4gICAgICAgICAgX2NoYXJ0LmRlZmF1bHQuY29udHJvbGxlcnMubGluZS5wcm90b3R5cGUuZHJhdy5jYWxsKHRoaXMsIGVhc2UpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuY2hhcnQudG9vbHRpcC5fYWN0aXZlICYmIHRoaXMuY2hhcnQudG9vbHRpcC5fYWN0aXZlLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGFjdGl2ZVBvaW50ID0gdGhpcy5jaGFydC50b29sdGlwLl9hY3RpdmVbMF07XG4gICAgICAgICAgICB2YXIgX2N0eCA9IHRoaXMuY2hhcnQuY3R4O1xuICAgICAgICAgICAgdmFyIHggPSBhY3RpdmVQb2ludC50b29sdGlwUG9zaXRpb24oKS54O1xuICAgICAgICAgICAgdmFyIHRvcFkgPSB0aGlzLmNoYXJ0LmxlZ2VuZC5ib3R0b207XG4gICAgICAgICAgICB2YXIgYm90dG9tWSA9IHRoaXMuY2hhcnQuY2hhcnRBcmVhLmJvdHRvbTsgLy8gZHJhdyBsaW5lXG5cbiAgICAgICAgICAgIF9jdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICBfY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgICBfY3R4Lm1vdmVUbyh4LCB0b3BZKTtcblxuICAgICAgICAgICAgX2N0eC5saW5lVG8oeCwgYm90dG9tWSk7XG5cbiAgICAgICAgICAgIF9jdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgIF9jdHguc3Ryb2tlU3R5bGUgPSAnIzU1NSc7XG5cbiAgICAgICAgICAgIF9jdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgIF9jdHgucmVzdG9yZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSAvL2ZvciBzZWN0aW9ucyByZWdpc3RlciBjaGFydGpzIHBsdWdpblxuXG5cbiAgICBpZiAodGhpcy5zZWN0aW9uaWQpIHtcbiAgICAgIF9jaGFydC5kZWZhdWx0LnBsdWdpblNlcnZpY2UucmVnaXN0ZXIoe1xuICAgICAgICBiZWZvcmVEcmF3OiBmdW5jdGlvbiBiZWZvcmVEcmF3KGNoYXJ0LCBlYXNpbmcpIHtcbiAgICAgICAgICBpZiAoY2hhcnQuY29uZmlnLm9wdGlvbnMuc2VjdGlvbiAmJiBjaGFydC5jb25maWcub3B0aW9ucy5zZWN0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBfY3R4MiA9IGNoYXJ0LmNoYXJ0LmN0eDtcbiAgICAgICAgICAgIHZhciBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgICAgICAgICB2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuICAgICAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgICAgIF9jdHgyLnNhdmUoKTsgLy9jb25zb2xlLmxvZygnY2hhcnRqcyBzZWN0aW9ucycsIGNoYXJ0LmNvbmZpZy5vcHRpb25zLnNlY3Rpb24pO1xuXG5cbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBjaGFydC5jb25maWcub3B0aW9ucy5zZWN0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NoYXJ0anMgc2VjdGlvbnBsdWdpbjppLCBzZWN0aW9uW2ktMV0sIHNlY3Rpb25bMV0sc3RhcnQsc3RvcCknLCBpLCBjaGFydC5jb25maWcub3B0aW9ucy5zZWN0aW9uW2kgLSAxXSxjaGFydC5jb25maWcub3B0aW9ucy5zZWN0aW9uW2ldKTtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbWV0YS5kYXRhW2NoYXJ0LmNvbmZpZy5vcHRpb25zLnNlY3Rpb25baSAtIDFdLmluZGV4XS5fbW9kZWwueDtcbiAgICAgICAgICAgICAgdmFyIHN0b3AgPSBtZXRhLmRhdGFbY2hhcnQuY29uZmlnLm9wdGlvbnMuc2VjdGlvbltpXS5pbmRleF0uX21vZGVsLng7XG4gICAgICAgICAgICAgIC8qY29uc3QgaHVlID0gKGkgLSAxKSAqIDEzNy41MDg7IC8vIHVzZSBnb2xkZW4gYW5nbGUgYXBwcm94aW1hdGlvblxuICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYGhzbCgke2h1ZX0sODUlLDkxJSlgO1xuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgLy9iYXJcblxuICAgICAgICAgICAgICBfY3R4Mi5maWxsU3R5bGUgPSBjaGFydC5jb25maWcub3B0aW9ucy5zZWN0aW9uW2kgLSAxXS5jb2xvcjtcblxuICAgICAgICAgICAgICBfY3R4Mi5maWxsUmVjdChzdGFydCwgY2hhcnRBcmVhLnRvcCwgc3RvcCAtIHN0YXJ0LCBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcCk7IC8vbGFiZWxcbiAgICAgICAgICAgICAgLy9jdHgudHJhbnNsYXRlKHN0YXJ0LCBjaGFydEFyZWEudG9wKTtcbiAgICAgICAgICAgICAgLy9jdHgucm90YXRlKE1hdGguUEkgLyAyKTtcblxuXG4gICAgICAgICAgICAgIF9jdHgyLnNhdmUoKTtcblxuICAgICAgICAgICAgICBfY3R4Mi50cmFuc2xhdGUoc3RhcnQsIGNoYXJ0QXJlYS50b3ApO1xuXG4gICAgICAgICAgICAgIF9jdHgyLnJvdGF0ZSg5MCAqIE1hdGguUEkgLyAxODApO1xuXG4gICAgICAgICAgICAgIF9jdHgyLmZpbGxTdHlsZSA9ICcjYWFhJztcbiAgICAgICAgICAgICAgX2N0eDIuZm9udCA9ICcxMnB4IEhlbHZldGljYSc7XG5cbiAgICAgICAgICAgICAgX2N0eDIuZmlsbFRleHQoY2hhcnQuY29uZmlnLm9wdGlvbnMuc2VjdGlvbltpIC0gMV0ubGFiZWwsIDUsIC01KTsgLy9zdGFydCwgY2hhcnRBcmVhLnRvcCk7XG5cblxuICAgICAgICAgICAgICBfY3R4Mi5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jdHgyLnJlc3RvcmUoKTsgLy9jb25zb2xlLmxvZygnbGFzdCBpJyxpKTtcbiAgICAgICAgICAgIC8vbGFzdCBzZWN0aW9uXG5cblxuICAgICAgICAgICAgaSA9IGNoYXJ0LmNvbmZpZy5vcHRpb25zLnNlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoaSA+IDAgJiYgY2hhcnQuY29uZmlnLm9wdGlvbnMuc2VjdGlvbltpIC0gMV0uaW5kZXggPCBtZXRhLmRhdGEubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAvL2RyYXcgbGFzdCBzZWN0aW9uXG4gICAgICAgICAgICAgIHZhciBfc3RhcnQgPSBtZXRhLmRhdGFbY2hhcnQuY29uZmlnLm9wdGlvbnMuc2VjdGlvbltpIC0gMV0uaW5kZXhdLl9tb2RlbC54O1xuICAgICAgICAgICAgICB2YXIgX3N0b3AgPSBtZXRhLmRhdGFbbWV0YS5kYXRhLmxlbmd0aCAtIDFdLl9tb2RlbC54OyAvL2NvbnNvbGUubG9nIChzdGFydCxzdG9wKTtcblxuICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICBjb25zdCBodWUgPSAoaSAtIDEpICogMTM3LjUwODsgLy8gdXNlIGdvbGRlbiBhbmdsZSBhcHByb3hpbWF0aW9uXG4gICAgICAgICAgICAgIHZhciBjb2xvciA9IGBoc2woJHtodWV9LDg1JSw5MSUpYDtcbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgX2N0eDIuZmlsbFN0eWxlID0gY2hhcnQuY29uZmlnLm9wdGlvbnMuc2VjdGlvbltpIC0gMV0uY29sb3I7IC8vY29uc29sZS5sb2cgKGNoYXJ0QXJlYSk7XG5cbiAgICAgICAgICAgICAgX2N0eDIuZmlsbFJlY3QoX3N0YXJ0LCBjaGFydEFyZWEudG9wLCBfc3RvcCAtIF9zdGFydCwgY2hhcnRBcmVhLmJvdHRvbSAtIGNoYXJ0QXJlYS50b3ApO1xuXG4gICAgICAgICAgICAgIF9jdHgyLnNhdmUoKTtcblxuICAgICAgICAgICAgICBfY3R4Mi50cmFuc2xhdGUoX3N0YXJ0LCBjaGFydEFyZWEudG9wKTtcblxuICAgICAgICAgICAgICBfY3R4Mi5yb3RhdGUoOTAgKiBNYXRoLlBJIC8gMTgwKTtcblxuICAgICAgICAgICAgICBfY3R4Mi5maWxsU3R5bGUgPSAnI2FhYSc7XG4gICAgICAgICAgICAgIF9jdHgyLmZvbnQgPSAnMTJweCBIZWx2ZXRpY2EnO1xuXG4gICAgICAgICAgICAgIF9jdHgyLmZpbGxUZXh0KGNoYXJ0LmNvbmZpZy5vcHRpb25zLnNlY3Rpb25baSAtIDFdLmxhYmVsLCA1LCAtNSk7IC8vc3RhcnQsIGNoYXJ0QXJlYS50b3ApO1xuXG5cbiAgICAgICAgICAgICAgX2N0eDIucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGF0YWxhYmVscykge1xuICAgICAgY29uc29sZS5sb2coJ2RhdGFsYWJlbHMgdHJ1ZSAsc2V0dGluZyBwbHVnaW4nLCB0aGlzLmRhdGFsYWJlbHMpO1xuXG4gICAgICBfY2hhcnQuZGVmYXVsdC5wbHVnaW5TZXJ2aWNlLnJlZ2lzdGVyKHtcbiAgICAgICAgYWZ0ZXJEYXRhc2V0c0RyYXc6IGZ1bmN0aW9uIGFmdGVyRGF0YXNldHNEcmF3KGNoYXJ0SW5zdGFuY2UsIGVhc2luZykge1xuICAgICAgICAgIC8vIFRvIG9ubHkgZHJhdyBhdCB0aGUgZW5kIG9mIGFuaW1hdGlvbiwgY2hlY2sgZm9yIGVhc2luZyA9PT0gMVxuICAgICAgICAgIC8vaWYgKGRhdGFzZXQgJiYgZGF0YXNldC5kYXRhbGFiZWxzKSB7XG4gICAgICAgICAgdmFyIGN0eCA9IGNoYXJ0SW5zdGFuY2UuY2hhcnQuY3R4O1xuICAgICAgICAgIGNoYXJ0SW5zdGFuY2UuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhc2V0LCBpKSB7XG4gICAgICAgICAgICBpZiAoZGF0YXNldCAmJiBkYXRhc2V0LmRhdGFsYWJlbHMpIHtcbiAgICAgICAgICAgICAgdmFyIG1ldGEgPSBjaGFydEluc3RhbmNlLmdldERhdGFzZXRNZXRhKGkpO1xuXG4gICAgICAgICAgICAgIGlmICghbWV0YS5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICBtZXRhLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChkYXRhc2V0LmRhdGFsYWJlbHNbaW5kZXhdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRHJhdyB0aGUgdGV4dCBpbiBibGFjaywgd2l0aCB0aGUgc3BlY2lmaWVkIGZvbnRcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjYWFhJztcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZvbnQgPSAnMTJweCBIZWx2ZXRpY2EnOyAvLyBKdXN0IG5haXZlbHkgY29udmVydCB0byBzdHJpbmcgZm9yIG5vd1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhU3RyaW5nID0gZGF0YXNldC5kYXRhbGFiZWxzW2luZGV4XTsgLy8gTWFrZSBzdXJlIGFsaWdubWVudCBzZXR0aW5ncyBhcmUgY29ycmVjdFxuXG4gICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFkZGluZyA9IDU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGVsZW1lbnQudG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChkYXRhU3RyaW5nLCBwb3NpdGlvbi54LCBwb3NpdGlvbi55IC0gMTIgLyAyIC0gcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSAvL2NhbnZhc29iaiAtIGlmIGRlZmluZWQgdGhlbiB1c2UgdGhpcyBvYmplY3QgbmFtZSB0byBnZXQgY2FudmFzIG9iamVjdCAtICBvdGhlcndpc2UgdGhlIG9uZSBmcm9tIHRlbXBsYXRlXG5cblxuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhc29iaiA/IHdpbmRvd1t0aGlzLmNhbnZhc29ial0gOiB0aGlzLmNoYXJ0Y2FudmFzLmdldENvbnRleHQoJzJkJyk7IC8vY3R4IG1heSBiZSBudWxsIGlmIGNhbnZhc29iaiBpcyBub3QgeWV0IGluaXRpYWxpemVkLlxuXG4gICAgaWYgKGN0eCkgdGhpcy5pbml0Q2hhcnQoY3R4KTsgLy9pbml0IGNoYXJ0IG9ubHkgaWYgY3R4IGlzIHJlYWR5XG4gICAgZWxzZSB3aW5kb3cubGF6eUluaXRDaGFydCA9IHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmluaXRDaGFydCA9IGZ1bmN0aW9uIGluaXRDaGFydChjdHgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICBpZiAod2luZG93LmxhenlJbml0Q2hhcnQpIHtcbiAgICAgIHZhciBfdGhhdCA9IHdpbmRvdy5sYXp5SW5pdENoYXJ0O1xuICAgIH1cblxuICAgIHRoYXQuY2hhcnQgPSBuZXcgX2NoYXJ0LmRlZmF1bHQoY3R4LCB7XG4gICAgICBwbHVnaW5zOiB0aGF0LnBsdWdpbnMsXG4gICAgICB0eXBlOiB0aGF0LnR5cGUsXG4gICAgICBkYXRhOiB0aGF0LmRhdGEsXG4gICAgICBvcHRpb25zOiB0aGF0Lm9wdGlvbnMsXG4gICAgICB0b29sdGlwRXZlbnRzOiB0aGF0LnRvb2x0aXBzXG4gICAgfSk7IC8vIGNvbnNvbGUubG9nKCdjaGFydGpzIGRhdGEnLCB0aGlzLmRhdGEpO1xuICB9XG4gIC8qKlxuICAgKiBjYWxsZWQgd2hlbiBjb21wb25lbnQgaXMgZGV0YWNoZWQgZnJvbSB2aWV3IC0gcmVtb3ZlIGV2ZW50IGxpc3RlbmVycyAtIG5vIG5lZWQgdG8gdXBkYXRlIGNoYXJ0XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRldGFjaGVkID0gZnVuY3Rpb24gZGV0YWNoZWQoKSB7XG4gICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZnJvbWlkKSkge1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5mcm9taWQpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZtaWRhdGEnLCB0aGlzLmhhbmRsZVZhbHVlQ2hhbmdlKTtcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZnJvbWlkKS5yZW1vdmVFdmVudExpc3RlbmVyKCdmbWlyZXNldCcsIHRoaXMuaGFuZGxlUmVzZXQpO1xuXG4gICAgICBpZiAodGhpcy5zZWN0aW9uaWQpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5zZWN0aW9uaWQpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZHNlY3Rpb24nLCB0aGlzLmhhbmRsZUFkZFNlY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogYXNrcyBmb3IgZmlsZW5hbWUgYW5kIGNyZWF0ZXMgYmxvYiB3aXRoIENTViBkYXRhIGZyb20gY2hhcnQgd2hpY2ggaW5pdGlhdGVzIHdlYiBicm93c2VyIGRvd25sb2FkIGRpYWxvZy5cbiAgICogQ1NWIC0gIHRpbWUgcG9pbnQgcGVyIHJvd1xuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kb3dubG9hZCA9IGZ1bmN0aW9uIGRvd25sb2FkKCkge1xuICAgIC8vYXNrIGZvciBmaWxlbmFtZVxuICAgIHZhciBmaWxlbmFtZSA9IHByb21wdCgnRmlsZSBuYW1lICgqLmNzdik6JywgJ2RhdGEuY3N2Jyk7XG5cbiAgICBpZiAoZmlsZW5hbWUpIHtcbiAgICAgIC8vYWRkcyBjc3YgYXMgZXh0ZW5zaW9uXG4gICAgICBpZiAoIWZpbGVuYW1lLmVuZHNXaXRoKCcuY3N2JykpIGZpbGVuYW1lID0gZmlsZW5hbWUuY29uY2F0KCcuY3N2Jyk7IC8vbGFiZWxzIGZpcnN0IHJvd1xuXG4gICAgICB2YXIgY29udGVudCA9ICdUaW1lLCcgKyB0aGlzLmxhYmVscyArICdcXG4nOyAvL3RyYW5zcG9zZSBlYWNoIHJvdyA9IHZhcmlhYmxlIGluIHNwZWNpZmljIHRpbWVcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoYXJ0LmRhdGEubGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLmNoYXJ0LmRhdGEubGFiZWxzW2ldO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgcm93ICs9ICcsJyArIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tqXS5kYXRhW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGVudCArPSByb3cgKyAnXFxuJztcbiAgICAgIH1cblxuICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbY29udGVudF0sIHtcbiAgICAgICAgdHlwZTogJ3RleHQvY3N2O2NoYXJzZXQ9dXRmLTg7J1xuICAgICAgfSk7XG4gICAgICBzYXZlQXMoYmxvYiwgZmlsZW5hbWUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogYXNrcyBmb3IgZmlsZW5hbWUgYW5kIGNyZWF0ZXMgYmxvYiB3aXRoIENTViBkYXRhIGZyb20gY2hhcnQgd2hpY2ggaW5pdGlhdGVzIHdlYiBicm93c2VyIGRvd25sb2FkIGRpYWxvZ1xuICAgKiBDU1YgLSB2YXJpYWJsZSB2YWx1ZXMgcGVyIHJvd1xuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kb3dubG9hZGZsYXQgPSBmdW5jdGlvbiBkb3dubG9hZGZsYXQoKSB7XG4gICAgLy9hc2sgZm9yIGZpbGVuYW1lXG4gICAgdmFyIGZpbGVuYW1lID0gcHJvbXB0KCdGaWxlIG5hbWUgKCouY3N2KTonLCAnZGF0YS5jc3YnKTtcblxuICAgIGlmIChmaWxlbmFtZSkge1xuICAgICAgLy9hZGRzIGNzdiBhcyBleHRlbnNpb25cbiAgICAgIGlmICghZmlsZW5hbWUuZW5kc1dpdGgoJy5jc3YnKSkgZmlsZW5hbWUgPSBmaWxlbmFtZS5jb25jYXQoJy5jc3YnKTsgLy9sYWJlbHMgZmlyc3Qgcm93IC0gZWFjaCByb3cgaXMgdGhlbiBhbGwgZGF0YSBwZXIgdmFyaWFibGUgLSB0cmFuc3Bvc2l0aW9uIG1pZ2h0IGJlIG5lZWRlZFxuXG4gICAgICB2YXIgY29udGVudCA9ICd2YXJpYWJsZSBuYW1lLHZhbHVlcyAuLi4nICsgJ1xcbic7XG4gICAgICB2YXIgbGFiZWxzID0gdGhpcy5sYWJlbHMuc3BsaXQoJywnKTsgLy8gdmFyaWFibGUgcGVyIHJvd1xuICAgICAgLy9jaGFydCBsYWJlbHMgLSB1c3VhbGx5IHRpbWVcblxuICAgICAgY29udGVudCA9IGNvbnRlbnQgKyAnVGltZSwnICsgdGhpcy5jaGFydC5kYXRhLmxhYmVscy5qb2luKCcsJykgKyAnXFxuJzsgLy9kYXRhc2V0IGRhdGEgb24gb3RoZXIgcm93c1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb250ZW50ID0gY29udGVudCArIGxhYmVsc1tpXSArICcsJyArIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tpXS5kYXRhLmpvaW4oJywnKSArICdcXG4nO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtjb250ZW50XSwge1xuICAgICAgICB0eXBlOiAndGV4dC9jc3Y7Y2hhcnNldD11dGYtODsnXG4gICAgICB9KTtcbiAgICAgIHNhdmVBcyhibG9iLCBmaWxlbmFtZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBZGRzIG5ldyBzZWN0aW9uIGluIGNoYXJ0YXJlYSAtIGN1cnJlbnQgbGFzdCBkYXRhIGluIGRhdGFzZXRcbiAgICovXG4gIDtcblxuICBfcHJvdG8uYWRkU2VjdGlvbiA9IGZ1bmN0aW9uIGFkZFNlY3Rpb24obGFiZWwpIHtcbiAgICBpZiAobGFiZWwgPT09IHZvaWQgMCkge1xuICAgICAgbGFiZWwgPSAnJztcbiAgICB9XG5cbiAgICB0aGlzLmluZGV4c2VjdGlvbisrO1xuICAgIGlmICghbGFiZWwpIGxhYmVsID0gJyc7XG4gICAgY29uc29sZS5sb2coJ2NoYXJ0anMuYWRkc2VjdGlvbigpJywgdGhpcy5jaGFydC5kYXRhLmxhYmVscy5sZW5ndGggLSAxKTtcbiAgICB0aGlzLmNoYXJ0LmNvbmZpZy5vcHRpb25zLnNlY3Rpb24ucHVzaCh7XG4gICAgICBpbmRleDogdGhpcy5jaGFydC5kYXRhLmxhYmVscy5sZW5ndGggLSAxLFxuICAgICAgY29sb3I6IHRoaXMuc2VsZWN0Q29sb3IodGhpcy5pbmRleHNlY3Rpb24sIDg1LCA5MSksXG4gICAgICBsYWJlbDogbGFiZWxcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQ2hhcnRqcztcbn0oKSwgKF9kZXNjcmlwdG9yID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImZyb21pZFwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3IyID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImxhYmVsc1wiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3IzID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcInJlZmluZGV4XCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjQgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwicmVmdmFsdWVzXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjUgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwidHlwZVwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiBpbml0aWFsaXplcigpIHtcbiAgICByZXR1cm4gJ2RvdWdobnV0JztcbiAgfVxufSksIF9kZXNjcmlwdG9yNiA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJtYXhkYXRhXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uIGluaXRpYWxpemVyKCkge1xuICAgIHJldHVybiAyNTY7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjcgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiaW5pdGlhbGRhdGFcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gaW5pdGlhbGl6ZXIoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59KSwgX2Rlc2NyaXB0b3I4ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcIndpZHRoXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uIGluaXRpYWxpemVyKCkge1xuICAgIHJldHVybiAzMDA7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjkgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uIGluaXRpYWxpemVyKCkge1xuICAgIHJldHVybiAyMDA7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjEwID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImFuaW1hdGVcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gaW5pdGlhbGl6ZXIoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSwgX2Rlc2NyaXB0b3IxMSA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJpZFwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3IxMiA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJ5bGFiZWxcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMTMgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwieGxhYmVsXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjE0ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImNvbnZlcnRvcnNcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMTUgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwidmVydGljYWxsaW5lXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uIGluaXRpYWxpemVyKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSksIF9kZXNjcmlwdG9yMTYgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiZ2VuZXJhdGVsYWJlbHNcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gaW5pdGlhbGl6ZXIoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSwgX2Rlc2NyaXB0b3IxNyA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJzZWN0aW9uaWRcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMTggPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwicmVzcG9uc2l2ZVwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiBpbml0aWFsaXplcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjE5ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImNhbnZhc29ialwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSksIF9jbGFzcyk7XG5leHBvcnRzLkNoYXJ0anMgPSBDaGFydGpzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhcnRqcy5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-barplot":
/*!***********************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-barplot.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.ChartjsBarplot = void 0;\n\nvar _chartjs = __webpack_require__(/*! ./chartjs */ \"aurelia-bodylight-plugin/elements/chartjs\");\n\nvar _chartjsPluginDatalabels = _interopRequireDefault(__webpack_require__(/*! chartjs-plugin-datalabels */ \"qb46\"));\n\nvar _aureliaTemplating = __webpack_require__(/*! aurelia-templating */ \"hij8\");\n\nvar _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\n//import {PLATFORM} from 'aurelia-pal';\n//@useView(PLATFORM.moduleName('./bdl-chartjs.html'))\n//@useView('./chartjs.html')\nvar ChartjsBarplot = (_class = /*#__PURE__*/function (_Chartjs) {\n  _inheritsLoose(ChartjsBarplot, _Chartjs);\n\n  //csv limits of chart min and max\n  //='';//0.25,0.75'; //csv normal limits inside chart\n  //sets precision to floor/round\n  //whether click will create event 'change'\n  function ChartjsBarplot() {\n    var _this;\n\n    _this = _Chartjs.call(this) || this;\n\n    _initializerDefineProperty(_this, \"id\", _descriptor, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"fromid\", _descriptor2, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"labels\", _descriptor3, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"refindex\", _descriptor4, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"refvalues\", _descriptor5, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"extremelimits\", _descriptor6, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"normallimits\", _descriptor7, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"initialdata\", _descriptor8, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"width\", _descriptor9, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"height\", _descriptor10, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"nominal\", _descriptor11, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"twoway\", _descriptor12, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"responsive\", _descriptor13, _assertThisInitialized(_this));\n\n    _this.handleValueChange = function (e) {\n      //sets data to dataset\n      //apply value convert among all data\n      var rawdata = e.detail.data.slice(_this.refindex, _this.refendindex); //if convert operation is defined as array\n\n      if (_this.operation) {\n        for (var i = 0; i < rawdata.length; i++) {\n          //if particular operation is defined\n          if (_this.operation[i]) rawdata[i] = _this.operation[i](rawdata[i]);\n        }\n      }\n\n      _this.chart.data.datasets[0].data = rawdata; //now decide whether datalabel is right or left\n\n      if ((_this.elimits[1] - rawdata) / (_this.elimits[1] - _this.elimits[0]) < 0.05) {\n        _this.options.plugins.datalabels.align = 'left';\n        _this.options.plugins.datalabels.color = 'white';\n      } else {\n        _this.options.plugins.datalabels.align = 'right';\n        _this.options.plugins.datalabels.color = 'black';\n      }\n\n      _this.chart.update();\n    };\n\n    return _this;\n  }\n\n  var _proto = ChartjsBarplot.prototype;\n\n  _proto.bind = function bind() {\n    _Chartjs.prototype.bind.call(this);\n\n    this.plugins = [_chartjsPluginDatalabels.default];\n\n    if (this.extremelimits) {\n      this.elimits = this.extremelimits.split(','); //split by comma\n\n      for (var i = 0; i < this.elimits.length; i++) {\n        this.elimits[i] = parseFloat(this.elimits[i]);\n      }\n    }\n\n    if (this.normallimits) {\n      this.nlimits = this.normallimits.split(',');\n\n      for (var _i = 0; _i < this.nlimits.length; _i++) {\n        this.nlimits[_i] = parseFloat(this.nlimits[_i]);\n      }\n    }\n\n    if (this.nominal) {\n      if (typeof this.nominal === 'string') this.nominal = parseFloat(this.nominal);\n      this.options.nominal = this.nominal;\n    }\n\n    if (this.twoway && typeof this.twoway === 'string') {\n      this.twoway = this.twoway === 'true';\n    } //chartjs type horizontal bar\n\n\n    this.type = 'horizontalBar'; // no legend and no labels\n    //this.chlabels = [];\n\n    this.options.legend.display = false; //sets xaxis limits to extremelimits\n\n    if (!this.options.scales.xAxes) this.options.scales.xAxes = [{}];\n    this.options.scales.xAxes[0].ticks = {\n      autoSkip: true,\n      min: this.elimits[0],\n      max: this.elimits[1],\n      fontSize: 8,\n      callback: function callback(value, index, values) {\n        //count relative distance to last tick value\n        var reldistance = (values[3] - value) / (values[3] - values[0]); // do not display tick label if too close to extreme limit (<5% of length)\n\n        if (index === 2 && reldistance < 0.05) return '';\n        return value;\n      }\n    }; //set ticks to extreme and normal limits only\n\n    var myticks = this.normallimits ? [this.elimits[0], this.nlimits[0], this.nlimits[1], this.elimits[1]] : [this.elimits[0], this.elimits[1]]; //console.log('charjs barplot myticks', myticks);\n\n    this.options.scales.xAxes[0].afterBuildTicks = function (scale) {\n      scale.ticks = myticks;\n      return;\n    };\n\n    this.options.scales.xAxes[0].beforeUpdate = function (oScale) {\n      return;\n    }; //datalabel plugin shows value right of the bar\n\n\n    this.options.plugins = {\n      datalabels: {\n        align: 'right',\n        anchor: 'end',\n        formatter: function formatter(value, context) {\n          return value.toPrecision(3);\n        },\n        font: {\n          size: 8\n        },\n        padding: {\n          top: 0,\n          right: 0,\n          bottom: 0,\n          left: 1\n        }\n      }\n    }; //now decide whether datalabel is right or left\n    //TODO eliminate duplicate in handlevaluechange\n\n    if ((this.elimits[1] - parseFloat(this.initialdata)) / (this.elimits[1] - this.elimits[0]) < 0.05) {\n      this.options.plugins.datalabels.align = 'left';\n      this.options.plugins.datalabels.color = 'white';\n    } else {\n      this.options.plugins.datalabels.align = 'right';\n      this.options.plugins.datalabels.color = 'black';\n    } //if the component is twoway - on click shows second bar with desired value and triggers 'change' event\n\n\n    if (this.twoway) {\n      //sets options for chart\n      this.options.events = ['click'];\n      this.options.parentId = this.id; //this.options.parentvm = this;\n\n      this.options.onClick = function (c, i) {\n        //note this - refers now to chart, not to webcomponent - shared properties are via options.nominal and options.parentid\n        //console.log('chartjs barplot click,', c, i, 'this:', this);\n        //let scaler = this.chart.scales['y-axis-0'];\n        var xscaler = this.chart.scales['x-axis-0']; //let y = c.clientY - this.canvas.getBoundingClientRect().top - scaler.top;\n\n        var x = c.clientX - this.canvas.getBoundingClientRect().left - xscaler.left; //let yval = scaler.max - y / scaler.height * (scaler.max - scaler.min);\n\n        var xval = xscaler.min + x / xscaler.width * (xscaler.max - xscaler.min);\n\n        if (this.options.nominal) {\n          //nominal is defined - floor xval to nominal\n          xval = Math.floor(xval / this.options.nominal) * this.options.nominal;\n        } //console.log('value clicked: %o, ypx: %o', yval, y);\n        //console.log('value clicked: %o, xpx: %o', xval, x);\n        //this.trigger('onTickerXClick', xval);\n\n\n        if (this.data.datasets.length < 2) {\n          this.data.datasets.push({\n            data: [xval],\n            backgroundColor: '#ff0000',\n            label: 'new value'\n          });\n        } else this.data.datasets[1].data = [xval];\n\n        this.update(); //create and dispatch change event\n\n        var event = new CustomEvent('change', {\n          detail: {\n            value: xval,\n            id: this.options.parentId\n          }\n        }); //dispatch event - it should be listened by some other component\n\n        document.getElementById(this.options.parentId).dispatchEvent(event); //this.parentvm.valueChanged(xval);\n      };\n    }\n\n    this.options.tooltips = {\n      enabled: false\n    };\n    this.tooltips = [];\n    /*if (!this.options.scales.yAxes) this.options.scales.yAxes = [{}];\n    this.options.scales.yAxes[0].ticks = {\n      max: 5,\n      min: 0,\n      stepSize: 0.5\n    };*/\n  };\n\n  _proto.valueChanged = function valueChanged(value) {\n    console.log('chartjs barplot valuechanged:', value);\n  };\n\n  return ChartjsBarplot;\n}(_chartjs.Chartjs), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"id\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"fromid\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"labels\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, \"refindex\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, \"refvalues\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 1;\n  }\n}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, \"extremelimits\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return '0,1';\n  }\n}), _descriptor7 = _applyDecoratedDescriptor(_class.prototype, \"normallimits\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor8 = _applyDecoratedDescriptor(_class.prototype, \"initialdata\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return '7.5';\n  }\n}), _descriptor9 = _applyDecoratedDescriptor(_class.prototype, \"width\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return '500';\n  }\n}), _descriptor10 = _applyDecoratedDescriptor(_class.prototype, \"height\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return '50';\n  }\n}), _descriptor11 = _applyDecoratedDescriptor(_class.prototype, \"nominal\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 0.01;\n  }\n}), _descriptor12 = _applyDecoratedDescriptor(_class.prototype, \"twoway\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return false;\n  }\n}), _descriptor13 = _applyDecoratedDescriptor(_class.prototype, \"responsive\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class);\nexports.ChartjsBarplot = ChartjsBarplot;\n//# sourceMappingURL=chartjs-barplot.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMtYmFycGxvdC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLWJvZHlsaWdodC1wbHVnaW4vZGlzdC9uYXRpdmUtbW9kdWxlcy9lbGVtZW50cy9jaGFydGpzLWJhcnBsb3QuanM/MjFjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQ2hhcnRqc0JhcnBsb3QgPSB2b2lkIDA7XG5cbnZhciBfY2hhcnRqcyA9IHJlcXVpcmUoXCIuL2NoYXJ0anNcIik7XG5cbnZhciBfY2hhcnRqc1BsdWdpbkRhdGFsYWJlbHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzXCIpKTtcblxudmFyIF9hdXJlbGlhVGVtcGxhdGluZyA9IHJlcXVpcmUoXCJhdXJlbGlhLXRlbXBsYXRpbmdcIik7XG5cbnZhciBfY2xhc3MsIF9kZXNjcmlwdG9yLCBfZGVzY3JpcHRvcjIsIF9kZXNjcmlwdG9yMywgX2Rlc2NyaXB0b3I0LCBfZGVzY3JpcHRvcjUsIF9kZXNjcmlwdG9yNiwgX2Rlc2NyaXB0b3I3LCBfZGVzY3JpcHRvcjgsIF9kZXNjcmlwdG9yOSwgX2Rlc2NyaXB0b3IxMCwgX2Rlc2NyaXB0b3IxMSwgX2Rlc2NyaXB0b3IxMiwgX2Rlc2NyaXB0b3IxMztcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvciwgY29udGV4dCkgeyBpZiAoIWRlc2NyaXB0b3IpIHJldHVybjsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHsgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLCBjb25maWd1cmFibGU6IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlLCB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSwgdmFsdWU6IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIgPyBkZXNjcmlwdG9yLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDAgfSk7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHksIGRlY29yYXRvcnMsIGRlc2NyaXB0b3IsIGNvbnRleHQpIHsgdmFyIGRlc2MgPSB7fTsgT2JqZWN0LmtleXMoZGVzY3JpcHRvcikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGRlc2Nba2V5XSA9IGRlc2NyaXB0b3Jba2V5XTsgfSk7IGRlc2MuZW51bWVyYWJsZSA9ICEhZGVzYy5lbnVtZXJhYmxlOyBkZXNjLmNvbmZpZ3VyYWJsZSA9ICEhZGVzYy5jb25maWd1cmFibGU7IGlmICgndmFsdWUnIGluIGRlc2MgfHwgZGVzYy5pbml0aWFsaXplcikgeyBkZXNjLndyaXRhYmxlID0gdHJ1ZTsgfSBkZXNjID0gZGVjb3JhdG9ycy5zbGljZSgpLnJldmVyc2UoKS5yZWR1Y2UoZnVuY3Rpb24gKGRlc2MsIGRlY29yYXRvcikgeyByZXR1cm4gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHksIGRlc2MpIHx8IGRlc2M7IH0sIGRlc2MpOyBpZiAoY29udGV4dCAmJiBkZXNjLmluaXRpYWxpemVyICE9PSB2b2lkIDApIHsgZGVzYy52YWx1ZSA9IGRlc2MuaW5pdGlhbGl6ZXIgPyBkZXNjLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDA7IGRlc2MuaW5pdGlhbGl6ZXIgPSB1bmRlZmluZWQ7IH0gaWYgKGRlc2MuaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYyk7IGRlc2MgPSBudWxsOyB9IHJldHVybiBkZXNjOyB9XG5cbmZ1bmN0aW9uIF9pbml0aWFsaXplcldhcm5pbmdIZWxwZXIoZGVzY3JpcHRvciwgY29udGV4dCkgeyB0aHJvdyBuZXcgRXJyb3IoJ0RlY29yYXRpbmcgY2xhc3MgcHJvcGVydHkgZmFpbGVkLiBQbGVhc2UgZW5zdXJlIHRoYXQgJyArICdwcm9wb3NhbC1jbGFzcy1wcm9wZXJ0aWVzIGlzIGVuYWJsZWQgYW5kIHJ1bnMgYWZ0ZXIgdGhlIGRlY29yYXRvcnMgdHJhbnNmb3JtLicpOyB9XG5cbi8vaW1wb3J0IHtQTEFURk9STX0gZnJvbSAnYXVyZWxpYS1wYWwnO1xuLy9AdXNlVmlldyhQTEFURk9STS5tb2R1bGVOYW1lKCcuL2JkbC1jaGFydGpzLmh0bWwnKSlcbi8vQHVzZVZpZXcoJy4vY2hhcnRqcy5odG1sJylcbnZhciBDaGFydGpzQmFycGxvdCA9IChfY2xhc3MgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DaGFydGpzKSB7XG4gIF9pbmhlcml0c0xvb3NlKENoYXJ0anNCYXJwbG90LCBfQ2hhcnRqcyk7XG5cbiAgLy9jc3YgbGltaXRzIG9mIGNoYXJ0IG1pbiBhbmQgbWF4XG4gIC8vPScnOy8vMC4yNSwwLjc1JzsgLy9jc3Ygbm9ybWFsIGxpbWl0cyBpbnNpZGUgY2hhcnRcbiAgLy9zZXRzIHByZWNpc2lvbiB0byBmbG9vci9yb3VuZFxuICAvL3doZXRoZXIgY2xpY2sgd2lsbCBjcmVhdGUgZXZlbnQgJ2NoYW5nZSdcbiAgZnVuY3Rpb24gQ2hhcnRqc0JhcnBsb3QoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQ2hhcnRqcy5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJpZFwiLCBfZGVzY3JpcHRvciwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZnJvbWlkXCIsIF9kZXNjcmlwdG9yMiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibGFiZWxzXCIsIF9kZXNjcmlwdG9yMywgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicmVmaW5kZXhcIiwgX2Rlc2NyaXB0b3I0LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJyZWZ2YWx1ZXNcIiwgX2Rlc2NyaXB0b3I1LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJleHRyZW1lbGltaXRzXCIsIF9kZXNjcmlwdG9yNiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibm9ybWFsbGltaXRzXCIsIF9kZXNjcmlwdG9yNywgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaW5pdGlhbGRhdGFcIiwgX2Rlc2NyaXB0b3I4LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ3aWR0aFwiLCBfZGVzY3JpcHRvcjksIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcImhlaWdodFwiLCBfZGVzY3JpcHRvcjEwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJub21pbmFsXCIsIF9kZXNjcmlwdG9yMTEsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcInR3b3dheVwiLCBfZGVzY3JpcHRvcjEyLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJyZXNwb25zaXZlXCIsIF9kZXNjcmlwdG9yMTMsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF90aGlzLmhhbmRsZVZhbHVlQ2hhbmdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vc2V0cyBkYXRhIHRvIGRhdGFzZXRcbiAgICAgIC8vYXBwbHkgdmFsdWUgY29udmVydCBhbW9uZyBhbGwgZGF0YVxuICAgICAgdmFyIHJhd2RhdGEgPSBlLmRldGFpbC5kYXRhLnNsaWNlKF90aGlzLnJlZmluZGV4LCBfdGhpcy5yZWZlbmRpbmRleCk7IC8vaWYgY29udmVydCBvcGVyYXRpb24gaXMgZGVmaW5lZCBhcyBhcnJheVxuXG4gICAgICBpZiAoX3RoaXMub3BlcmF0aW9uKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIC8vaWYgcGFydGljdWxhciBvcGVyYXRpb24gaXMgZGVmaW5lZFxuICAgICAgICAgIGlmIChfdGhpcy5vcGVyYXRpb25baV0pIHJhd2RhdGFbaV0gPSBfdGhpcy5vcGVyYXRpb25baV0ocmF3ZGF0YVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX3RoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhID0gcmF3ZGF0YTsgLy9ub3cgZGVjaWRlIHdoZXRoZXIgZGF0YWxhYmVsIGlzIHJpZ2h0IG9yIGxlZnRcblxuICAgICAgaWYgKChfdGhpcy5lbGltaXRzWzFdIC0gcmF3ZGF0YSkgLyAoX3RoaXMuZWxpbWl0c1sxXSAtIF90aGlzLmVsaW1pdHNbMF0pIDwgMC4wNSkge1xuICAgICAgICBfdGhpcy5vcHRpb25zLnBsdWdpbnMuZGF0YWxhYmVscy5hbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgX3RoaXMub3B0aW9ucy5wbHVnaW5zLmRhdGFsYWJlbHMuY29sb3IgPSAnd2hpdGUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMub3B0aW9ucy5wbHVnaW5zLmRhdGFsYWJlbHMuYWxpZ24gPSAncmlnaHQnO1xuICAgICAgICBfdGhpcy5vcHRpb25zLnBsdWdpbnMuZGF0YWxhYmVscy5jb2xvciA9ICdibGFjayc7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmNoYXJ0LnVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ2hhcnRqc0JhcnBsb3QucHJvdG90eXBlO1xuXG4gIF9wcm90by5iaW5kID0gZnVuY3Rpb24gYmluZCgpIHtcbiAgICBfQ2hhcnRqcy5wcm90b3R5cGUuYmluZC5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5wbHVnaW5zID0gW19jaGFydGpzUGx1Z2luRGF0YWxhYmVscy5kZWZhdWx0XTtcblxuICAgIGlmICh0aGlzLmV4dHJlbWVsaW1pdHMpIHtcbiAgICAgIHRoaXMuZWxpbWl0cyA9IHRoaXMuZXh0cmVtZWxpbWl0cy5zcGxpdCgnLCcpOyAvL3NwbGl0IGJ5IGNvbW1hXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lbGltaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZWxpbWl0c1tpXSA9IHBhcnNlRmxvYXQodGhpcy5lbGltaXRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ub3JtYWxsaW1pdHMpIHtcbiAgICAgIHRoaXMubmxpbWl0cyA9IHRoaXMubm9ybWFsbGltaXRzLnNwbGl0KCcsJyk7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLm5saW1pdHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHRoaXMubmxpbWl0c1tfaV0gPSBwYXJzZUZsb2F0KHRoaXMubmxpbWl0c1tfaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm5vbWluYWwpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5ub21pbmFsID09PSAnc3RyaW5nJykgdGhpcy5ub21pbmFsID0gcGFyc2VGbG9hdCh0aGlzLm5vbWluYWwpO1xuICAgICAgdGhpcy5vcHRpb25zLm5vbWluYWwgPSB0aGlzLm5vbWluYWw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHdvd2F5ICYmIHR5cGVvZiB0aGlzLnR3b3dheSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMudHdvd2F5ID0gdGhpcy50d293YXkgPT09ICd0cnVlJztcbiAgICB9IC8vY2hhcnRqcyB0eXBlIGhvcml6b250YWwgYmFyXG5cblxuICAgIHRoaXMudHlwZSA9ICdob3Jpem9udGFsQmFyJzsgLy8gbm8gbGVnZW5kIGFuZCBubyBsYWJlbHNcbiAgICAvL3RoaXMuY2hsYWJlbHMgPSBbXTtcblxuICAgIHRoaXMub3B0aW9ucy5sZWdlbmQuZGlzcGxheSA9IGZhbHNlOyAvL3NldHMgeGF4aXMgbGltaXRzIHRvIGV4dHJlbWVsaW1pdHNcblxuICAgIGlmICghdGhpcy5vcHRpb25zLnNjYWxlcy54QXhlcykgdGhpcy5vcHRpb25zLnNjYWxlcy54QXhlcyA9IFt7fV07XG4gICAgdGhpcy5vcHRpb25zLnNjYWxlcy54QXhlc1swXS50aWNrcyA9IHtcbiAgICAgIGF1dG9Ta2lwOiB0cnVlLFxuICAgICAgbWluOiB0aGlzLmVsaW1pdHNbMF0sXG4gICAgICBtYXg6IHRoaXMuZWxpbWl0c1sxXSxcbiAgICAgIGZvbnRTaXplOiA4LFxuICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgdmFsdWVzKSB7XG4gICAgICAgIC8vY291bnQgcmVsYXRpdmUgZGlzdGFuY2UgdG8gbGFzdCB0aWNrIHZhbHVlXG4gICAgICAgIHZhciByZWxkaXN0YW5jZSA9ICh2YWx1ZXNbM10gLSB2YWx1ZSkgLyAodmFsdWVzWzNdIC0gdmFsdWVzWzBdKTsgLy8gZG8gbm90IGRpc3BsYXkgdGljayBsYWJlbCBpZiB0b28gY2xvc2UgdG8gZXh0cmVtZSBsaW1pdCAoPDUlIG9mIGxlbmd0aClcblxuICAgICAgICBpZiAoaW5kZXggPT09IDIgJiYgcmVsZGlzdGFuY2UgPCAwLjA1KSByZXR1cm4gJyc7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9OyAvL3NldCB0aWNrcyB0byBleHRyZW1lIGFuZCBub3JtYWwgbGltaXRzIG9ubHlcblxuICAgIHZhciBteXRpY2tzID0gdGhpcy5ub3JtYWxsaW1pdHMgPyBbdGhpcy5lbGltaXRzWzBdLCB0aGlzLm5saW1pdHNbMF0sIHRoaXMubmxpbWl0c1sxXSwgdGhpcy5lbGltaXRzWzFdXSA6IFt0aGlzLmVsaW1pdHNbMF0sIHRoaXMuZWxpbWl0c1sxXV07IC8vY29uc29sZS5sb2coJ2NoYXJqcyBiYXJwbG90IG15dGlja3MnLCBteXRpY2tzKTtcblxuICAgIHRoaXMub3B0aW9ucy5zY2FsZXMueEF4ZXNbMF0uYWZ0ZXJCdWlsZFRpY2tzID0gZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgICBzY2FsZS50aWNrcyA9IG15dGlja3M7XG4gICAgICByZXR1cm47XG4gICAgfTtcblxuICAgIHRoaXMub3B0aW9ucy5zY2FsZXMueEF4ZXNbMF0uYmVmb3JlVXBkYXRlID0gZnVuY3Rpb24gKG9TY2FsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH07IC8vZGF0YWxhYmVsIHBsdWdpbiBzaG93cyB2YWx1ZSByaWdodCBvZiB0aGUgYmFyXG5cblxuICAgIHRoaXMub3B0aW9ucy5wbHVnaW5zID0ge1xuICAgICAgZGF0YWxhYmVsczoge1xuICAgICAgICBhbGlnbjogJ3JpZ2h0JyxcbiAgICAgICAgYW5jaG9yOiAnZW5kJyxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUudG9QcmVjaXNpb24oMyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICBzaXplOiA4XG4gICAgICAgIH0sXG4gICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgIGxlZnQ6IDFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07IC8vbm93IGRlY2lkZSB3aGV0aGVyIGRhdGFsYWJlbCBpcyByaWdodCBvciBsZWZ0XG4gICAgLy9UT0RPIGVsaW1pbmF0ZSBkdXBsaWNhdGUgaW4gaGFuZGxldmFsdWVjaGFuZ2VcblxuICAgIGlmICgodGhpcy5lbGltaXRzWzFdIC0gcGFyc2VGbG9hdCh0aGlzLmluaXRpYWxkYXRhKSkgLyAodGhpcy5lbGltaXRzWzFdIC0gdGhpcy5lbGltaXRzWzBdKSA8IDAuMDUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5wbHVnaW5zLmRhdGFsYWJlbHMuYWxpZ24gPSAnbGVmdCc7XG4gICAgICB0aGlzLm9wdGlvbnMucGx1Z2lucy5kYXRhbGFiZWxzLmNvbG9yID0gJ3doaXRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcHRpb25zLnBsdWdpbnMuZGF0YWxhYmVscy5hbGlnbiA9ICdyaWdodCc7XG4gICAgICB0aGlzLm9wdGlvbnMucGx1Z2lucy5kYXRhbGFiZWxzLmNvbG9yID0gJ2JsYWNrJztcbiAgICB9IC8vaWYgdGhlIGNvbXBvbmVudCBpcyB0d293YXkgLSBvbiBjbGljayBzaG93cyBzZWNvbmQgYmFyIHdpdGggZGVzaXJlZCB2YWx1ZSBhbmQgdHJpZ2dlcnMgJ2NoYW5nZScgZXZlbnRcblxuXG4gICAgaWYgKHRoaXMudHdvd2F5KSB7XG4gICAgICAvL3NldHMgb3B0aW9ucyBmb3IgY2hhcnRcbiAgICAgIHRoaXMub3B0aW9ucy5ldmVudHMgPSBbJ2NsaWNrJ107XG4gICAgICB0aGlzLm9wdGlvbnMucGFyZW50SWQgPSB0aGlzLmlkOyAvL3RoaXMub3B0aW9ucy5wYXJlbnR2bSA9IHRoaXM7XG5cbiAgICAgIHRoaXMub3B0aW9ucy5vbkNsaWNrID0gZnVuY3Rpb24gKGMsIGkpIHtcbiAgICAgICAgLy9ub3RlIHRoaXMgLSByZWZlcnMgbm93IHRvIGNoYXJ0LCBub3QgdG8gd2ViY29tcG9uZW50IC0gc2hhcmVkIHByb3BlcnRpZXMgYXJlIHZpYSBvcHRpb25zLm5vbWluYWwgYW5kIG9wdGlvbnMucGFyZW50aWRcbiAgICAgICAgLy9jb25zb2xlLmxvZygnY2hhcnRqcyBiYXJwbG90IGNsaWNrLCcsIGMsIGksICd0aGlzOicsIHRoaXMpO1xuICAgICAgICAvL2xldCBzY2FsZXIgPSB0aGlzLmNoYXJ0LnNjYWxlc1sneS1heGlzLTAnXTtcbiAgICAgICAgdmFyIHhzY2FsZXIgPSB0aGlzLmNoYXJ0LnNjYWxlc1sneC1heGlzLTAnXTsgLy9sZXQgeSA9IGMuY2xpZW50WSAtIHRoaXMuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtIHNjYWxlci50b3A7XG5cbiAgICAgICAgdmFyIHggPSBjLmNsaWVudFggLSB0aGlzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC0geHNjYWxlci5sZWZ0OyAvL2xldCB5dmFsID0gc2NhbGVyLm1heCAtIHkgLyBzY2FsZXIuaGVpZ2h0ICogKHNjYWxlci5tYXggLSBzY2FsZXIubWluKTtcblxuICAgICAgICB2YXIgeHZhbCA9IHhzY2FsZXIubWluICsgeCAvIHhzY2FsZXIud2lkdGggKiAoeHNjYWxlci5tYXggLSB4c2NhbGVyLm1pbik7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ub21pbmFsKSB7XG4gICAgICAgICAgLy9ub21pbmFsIGlzIGRlZmluZWQgLSBmbG9vciB4dmFsIHRvIG5vbWluYWxcbiAgICAgICAgICB4dmFsID0gTWF0aC5mbG9vcih4dmFsIC8gdGhpcy5vcHRpb25zLm5vbWluYWwpICogdGhpcy5vcHRpb25zLm5vbWluYWw7XG4gICAgICAgIH0gLy9jb25zb2xlLmxvZygndmFsdWUgY2xpY2tlZDogJW8sIHlweDogJW8nLCB5dmFsLCB5KTtcbiAgICAgICAgLy9jb25zb2xlLmxvZygndmFsdWUgY2xpY2tlZDogJW8sIHhweDogJW8nLCB4dmFsLCB4KTtcbiAgICAgICAgLy90aGlzLnRyaWdnZXIoJ29uVGlja2VyWENsaWNrJywgeHZhbCk7XG5cblxuICAgICAgICBpZiAodGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICB0aGlzLmRhdGEuZGF0YXNldHMucHVzaCh7XG4gICAgICAgICAgICBkYXRhOiBbeHZhbF0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZmYwMDAwJyxcbiAgICAgICAgICAgIGxhYmVsOiAnbmV3IHZhbHVlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgdGhpcy5kYXRhLmRhdGFzZXRzWzFdLmRhdGEgPSBbeHZhbF07XG5cbiAgICAgICAgdGhpcy51cGRhdGUoKTsgLy9jcmVhdGUgYW5kIGRpc3BhdGNoIGNoYW5nZSBldmVudFxuXG4gICAgICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnY2hhbmdlJywge1xuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgdmFsdWU6IHh2YWwsXG4gICAgICAgICAgICBpZDogdGhpcy5vcHRpb25zLnBhcmVudElkXG4gICAgICAgICAgfVxuICAgICAgICB9KTsgLy9kaXNwYXRjaCBldmVudCAtIGl0IHNob3VsZCBiZSBsaXN0ZW5lZCBieSBzb21lIG90aGVyIGNvbXBvbmVudFxuXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMub3B0aW9ucy5wYXJlbnRJZCkuZGlzcGF0Y2hFdmVudChldmVudCk7IC8vdGhpcy5wYXJlbnR2bS52YWx1ZUNoYW5nZWQoeHZhbCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucy50b29sdGlwcyA9IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLnRvb2x0aXBzID0gW107XG4gICAgLyppZiAoIXRoaXMub3B0aW9ucy5zY2FsZXMueUF4ZXMpIHRoaXMub3B0aW9ucy5zY2FsZXMueUF4ZXMgPSBbe31dO1xuICAgIHRoaXMub3B0aW9ucy5zY2FsZXMueUF4ZXNbMF0udGlja3MgPSB7XG4gICAgICBtYXg6IDUsXG4gICAgICBtaW46IDAsXG4gICAgICBzdGVwU2l6ZTogMC41XG4gICAgfTsqL1xuICB9O1xuXG4gIF9wcm90by52YWx1ZUNoYW5nZWQgPSBmdW5jdGlvbiB2YWx1ZUNoYW5nZWQodmFsdWUpIHtcbiAgICBjb25zb2xlLmxvZygnY2hhcnRqcyBiYXJwbG90IHZhbHVlY2hhbmdlZDonLCB2YWx1ZSk7XG4gIH07XG5cbiAgcmV0dXJuIENoYXJ0anNCYXJwbG90O1xufShfY2hhcnRqcy5DaGFydGpzKSwgKF9kZXNjcmlwdG9yID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImlkXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3IyID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImZyb21pZFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMyA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJsYWJlbHNcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjQgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwicmVmaW5kZXhcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjUgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwicmVmdmFsdWVzXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiBpbml0aWFsaXplcigpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxufSksIF9kZXNjcmlwdG9yNiA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJleHRyZW1lbGltaXRzXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiBpbml0aWFsaXplcigpIHtcbiAgICByZXR1cm4gJzAsMSc7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjcgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwibm9ybWFsbGltaXRzXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I4ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImluaXRpYWxkYXRhXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiBpbml0aWFsaXplcigpIHtcbiAgICByZXR1cm4gJzcuNSc7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjkgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwid2lkdGhcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uIGluaXRpYWxpemVyKCkge1xuICAgIHJldHVybiAnNTAwJztcbiAgfVxufSksIF9kZXNjcmlwdG9yMTAgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiBpbml0aWFsaXplcigpIHtcbiAgICByZXR1cm4gJzUwJztcbiAgfVxufSksIF9kZXNjcmlwdG9yMTEgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwibm9taW5hbFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gaW5pdGlhbGl6ZXIoKSB7XG4gICAgcmV0dXJuIDAuMDE7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjEyID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcInR3b3dheVwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gaW5pdGlhbGl6ZXIoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSwgX2Rlc2NyaXB0b3IxMyA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJyZXNwb25zaXZlXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSksIF9jbGFzcyk7XG5leHBvcnRzLkNoYXJ0anNCYXJwbG90ID0gQ2hhcnRqc0JhcnBsb3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFydGpzLWJhcnBsb3QuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-barplot\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-barplot.html":
/*!*************************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-barplot.html ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template bindable=\\\"width,height\\\">\\n    <div id=\\\"canvas-holder\\\">\\n        <canvas id=\\\"${id}-canvas\\\" ref=\\\"chartcanvas\\\" width=\\\"${width}\\\" height=\\\"${height}\\\"></canvas>\\n    </div>\\n</template>\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMtYmFycGxvdC5odG1sLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F1cmVsaWEtYm9keWxpZ2h0LXBsdWdpbi9kaXN0L25hdGl2ZS1tb2R1bGVzL2VsZW1lbnRzL2NoYXJ0anMtYmFycGxvdC5odG1sP2M3OWYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIjx0ZW1wbGF0ZSBiaW5kYWJsZT1cXFwid2lkdGgsaGVpZ2h0XFxcIj5cXG4gICAgPGRpdiBpZD1cXFwiY2FudmFzLWhvbGRlclxcXCI+XFxuICAgICAgICA8Y2FudmFzIGlkPVxcXCIke2lkfS1jYW52YXNcXFwiIHJlZj1cXFwiY2hhcnRjYW52YXNcXFwiIHdpZHRoPVxcXCIke3dpZHRofVxcXCIgaGVpZ2h0PVxcXCIke2hlaWdodH1cXFwiPjwvY2FudmFzPlxcbiAgICA8L2Rpdj5cXG48L3RlbXBsYXRlPlwiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-barplot.html\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-fixed":
/*!*********************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-fixed.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.ChartjsFixed = void 0;\n\nvar _aureliaTemplating = __webpack_require__(/*! aurelia-templating */ \"hij8\");\n\nvar _chartjs = __webpack_require__(/*! ./chartjs */ \"aurelia-bodylight-plugin/elements/chartjs\");\n\nvar _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8;\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\n/**\n * shows fixed curve at time -\n * on X is 0,1,2,3,4,5,6,7,8,9\n * on Y is values from FMU variables from refindex to refvalues\n */\nvar ChartjsFixed = (_dec = (0, _aureliaTemplating.useView)('./chartjs.html'), _dec(_class = (_class2 = /*#__PURE__*/function (_Chartjs) {\n  _inheritsLoose(ChartjsFixed, _Chartjs);\n\n  //@bindable cachesize;\n  function ChartjsFixed() {\n    var _this;\n\n    _this = _Chartjs.call(this) || this;\n\n    _initializerDefineProperty(_this, \"fromid\", _descriptor, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"labels\", _descriptor2, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"refindex\", _descriptor3, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"refvalues\", _descriptor4, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"type\", _descriptor5, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"min\", _descriptor6, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"max\", _descriptor7, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"maxdata\", _descriptor8, _assertThisInitialized(_this));\n\n    _this.currentdataset = 0;\n\n    _this.handleValueChange = function (e) {\n      var j = _this.currentdataset; //all values from refindex to one dataset - as one curve\n\n      if (!_this.chart.data.datasets[j]) {\n        //do initialize dataset first\n        _this.chart.data.datasets.push({\n          data: e.detail.data.slice(_this.refindex, _this.refindex + _this.refvalues),\n          label: \"\",\n          backgroundColor: _this.selectColor(0),\n          borderColor: _this.selectColor(0),\n          borderWidth: 1,\n          pointRadius: 1,\n          fill: false\n        });\n      } else {\n        _this.chart.data.datasets[j].data = e.detail.data.slice(_this.refindex, _this.refindex + _this.refvalues);\n      } //do apply operation on each element of array\n\n\n      if (_this.operation && _this.operation[0]) _this.chart.data.datasets[j].data.map(function (item) {\n        return _this.operation[0](item);\n      });\n      if (_this.currentdataset >= _this.maxdata) _this.currentdataset = 0;else _this.currentdataset++;\n\n      _this.chart.update();\n    };\n\n    return _this;\n  }\n\n  var _proto = ChartjsFixed.prototype;\n\n  _proto.bind = function bind() {\n    _Chartjs.prototype.bind.call(this);\n\n    this.type = 'line';\n    this.options.legend.display = false;\n    var dataset = [];\n    dataset.push({\n      data: [],\n      label: \"\",\n      backgroundColor: this.selectColor(0),\n      borderColor: this.selectColor(0),\n      borderWidth: 1,\n      pointRadius: 1,\n      fill: false\n    });\n    this.data = {\n      labels: Array.from(Array(this.refvalues), function (_, x) {\n        return x + 1;\n      }),\n      //returns [1,2,3,..,refvalues]\n      datasets: dataset\n    }; //initialize colors for each dataset\n  };\n\n  _proto.attached = function attached() {\n    _Chartjs.prototype.attached.call(this);\n  };\n\n  return ChartjsFixed;\n}(_chartjs.Chartjs), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"fromid\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"labels\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, \"refindex\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, \"refvalues\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, \"type\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, \"min\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, \"max\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, \"maxdata\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 3;\n  }\n})), _class2)) || _class);\nexports.ChartjsFixed = ChartjsFixed;\n//# sourceMappingURL=chartjs-fixed.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMtZml4ZWQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2Rpc3QvbmF0aXZlLW1vZHVsZXMvZWxlbWVudHMvY2hhcnRqcy1maXhlZC5qcz81OWEzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5DaGFydGpzRml4ZWQgPSB2b2lkIDA7XG5cbnZhciBfYXVyZWxpYVRlbXBsYXRpbmcgPSByZXF1aXJlKFwiYXVyZWxpYS10ZW1wbGF0aW5nXCIpO1xuXG52YXIgX2NoYXJ0anMgPSByZXF1aXJlKFwiLi9jaGFydGpzXCIpO1xuXG52YXIgX2RlYywgX2NsYXNzLCBfY2xhc3MyLCBfZGVzY3JpcHRvciwgX2Rlc2NyaXB0b3IyLCBfZGVzY3JpcHRvcjMsIF9kZXNjcmlwdG9yNCwgX2Rlc2NyaXB0b3I1LCBfZGVzY3JpcHRvcjYsIF9kZXNjcmlwdG9yNywgX2Rlc2NyaXB0b3I4O1xuXG5mdW5jdGlvbiBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7IGlmICghZGVzY3JpcHRvcikgcmV0dXJuOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgeyBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsIHdyaXRhYmxlOiBkZXNjcmlwdG9yLndyaXRhYmxlLCB2YWx1ZTogZGVzY3JpcHRvci5pbml0aWFsaXplciA/IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMCB9KTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVjb3JhdG9ycywgZGVzY3JpcHRvciwgY29udGV4dCkgeyB2YXIgZGVzYyA9IHt9OyBPYmplY3Qua2V5cyhkZXNjcmlwdG9yKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZGVzY1trZXldID0gZGVzY3JpcHRvcltrZXldOyB9KTsgZGVzYy5lbnVtZXJhYmxlID0gISFkZXNjLmVudW1lcmFibGU7IGRlc2MuY29uZmlndXJhYmxlID0gISFkZXNjLmNvbmZpZ3VyYWJsZTsgaWYgKCd2YWx1ZScgaW4gZGVzYyB8fCBkZXNjLmluaXRpYWxpemVyKSB7IGRlc2Mud3JpdGFibGUgPSB0cnVlOyB9IGRlc2MgPSBkZWNvcmF0b3JzLnNsaWNlKCkucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbiAoZGVzYywgZGVjb3JhdG9yKSB7IHJldHVybiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYykgfHwgZGVzYzsgfSwgZGVzYyk7IGlmIChjb250ZXh0ICYmIGRlc2MuaW5pdGlhbGl6ZXIgIT09IHZvaWQgMCkgeyBkZXNjLnZhbHVlID0gZGVzYy5pbml0aWFsaXplciA/IGRlc2MuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMDsgZGVzYy5pbml0aWFsaXplciA9IHVuZGVmaW5lZDsgfSBpZiAoZGVzYy5pbml0aWFsaXplciA9PT0gdm9pZCAwKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjKTsgZGVzYyA9IG51bGw7IH0gcmV0dXJuIGRlc2M7IH1cblxuZnVuY3Rpb24gX2luaXRpYWxpemVyV2FybmluZ0hlbHBlcihkZXNjcmlwdG9yLCBjb250ZXh0KSB7IHRocm93IG5ldyBFcnJvcignRGVjb3JhdGluZyBjbGFzcyBwcm9wZXJ0eSBmYWlsZWQuIFBsZWFzZSBlbnN1cmUgdGhhdCAnICsgJ3Byb3Bvc2FsLWNsYXNzLXByb3BlcnRpZXMgaXMgZW5hYmxlZCBhbmQgcnVucyBhZnRlciB0aGUgZGVjb3JhdG9ycyB0cmFuc2Zvcm0uJyk7IH1cblxuLyoqXG4gKiBzaG93cyBmaXhlZCBjdXJ2ZSBhdCB0aW1lIC1cbiAqIG9uIFggaXMgMCwxLDIsMyw0LDUsNiw3LDgsOVxuICogb24gWSBpcyB2YWx1ZXMgZnJvbSBGTVUgdmFyaWFibGVzIGZyb20gcmVmaW5kZXggdG8gcmVmdmFsdWVzXG4gKi9cbnZhciBDaGFydGpzRml4ZWQgPSAoX2RlYyA9ICgwLCBfYXVyZWxpYVRlbXBsYXRpbmcudXNlVmlldykoJy4vY2hhcnRqcy5odG1sJyksIF9kZWMoX2NsYXNzID0gKF9jbGFzczIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DaGFydGpzKSB7XG4gIF9pbmhlcml0c0xvb3NlKENoYXJ0anNGaXhlZCwgX0NoYXJ0anMpO1xuXG4gIC8vQGJpbmRhYmxlIGNhY2hlc2l6ZTtcbiAgZnVuY3Rpb24gQ2hhcnRqc0ZpeGVkKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0NoYXJ0anMuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZnJvbWlkXCIsIF9kZXNjcmlwdG9yLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJsYWJlbHNcIiwgX2Rlc2NyaXB0b3IyLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJyZWZpbmRleFwiLCBfZGVzY3JpcHRvcjMsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcInJlZnZhbHVlc1wiLCBfZGVzY3JpcHRvcjQsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcInR5cGVcIiwgX2Rlc2NyaXB0b3I1LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJtaW5cIiwgX2Rlc2NyaXB0b3I2LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJtYXhcIiwgX2Rlc2NyaXB0b3I3LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJtYXhkYXRhXCIsIF9kZXNjcmlwdG9yOCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX3RoaXMuY3VycmVudGRhdGFzZXQgPSAwO1xuXG4gICAgX3RoaXMuaGFuZGxlVmFsdWVDaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGogPSBfdGhpcy5jdXJyZW50ZGF0YXNldDsgLy9hbGwgdmFsdWVzIGZyb20gcmVmaW5kZXggdG8gb25lIGRhdGFzZXQgLSBhcyBvbmUgY3VydmVcblxuICAgICAgaWYgKCFfdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2pdKSB7XG4gICAgICAgIC8vZG8gaW5pdGlhbGl6ZSBkYXRhc2V0IGZpcnN0XG4gICAgICAgIF90aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMucHVzaCh7XG4gICAgICAgICAgZGF0YTogZS5kZXRhaWwuZGF0YS5zbGljZShfdGhpcy5yZWZpbmRleCwgX3RoaXMucmVmaW5kZXggKyBfdGhpcy5yZWZ2YWx1ZXMpLFxuICAgICAgICAgIGxhYmVsOiBcIlwiLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogX3RoaXMuc2VsZWN0Q29sb3IoMCksXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IF90aGlzLnNlbGVjdENvbG9yKDApLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgICAgIHBvaW50UmFkaXVzOiAxLFxuICAgICAgICAgIGZpbGw6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tqXS5kYXRhID0gZS5kZXRhaWwuZGF0YS5zbGljZShfdGhpcy5yZWZpbmRleCwgX3RoaXMucmVmaW5kZXggKyBfdGhpcy5yZWZ2YWx1ZXMpO1xuICAgICAgfSAvL2RvIGFwcGx5IG9wZXJhdGlvbiBvbiBlYWNoIGVsZW1lbnQgb2YgYXJyYXlcblxuXG4gICAgICBpZiAoX3RoaXMub3BlcmF0aW9uICYmIF90aGlzLm9wZXJhdGlvblswXSkgX3RoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tqXS5kYXRhLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gX3RoaXMub3BlcmF0aW9uWzBdKGl0ZW0pO1xuICAgICAgfSk7XG4gICAgICBpZiAoX3RoaXMuY3VycmVudGRhdGFzZXQgPj0gX3RoaXMubWF4ZGF0YSkgX3RoaXMuY3VycmVudGRhdGFzZXQgPSAwO2Vsc2UgX3RoaXMuY3VycmVudGRhdGFzZXQrKztcblxuICAgICAgX3RoaXMuY2hhcnQudXBkYXRlKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDaGFydGpzRml4ZWQucHJvdG90eXBlO1xuXG4gIF9wcm90by5iaW5kID0gZnVuY3Rpb24gYmluZCgpIHtcbiAgICBfQ2hhcnRqcy5wcm90b3R5cGUuYmluZC5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy50eXBlID0gJ2xpbmUnO1xuICAgIHRoaXMub3B0aW9ucy5sZWdlbmQuZGlzcGxheSA9IGZhbHNlO1xuICAgIHZhciBkYXRhc2V0ID0gW107XG4gICAgZGF0YXNldC5wdXNoKHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWw6IFwiXCIsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuc2VsZWN0Q29sb3IoMCksXG4gICAgICBib3JkZXJDb2xvcjogdGhpcy5zZWxlY3RDb2xvcigwKSxcbiAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgcG9pbnRSYWRpdXM6IDEsXG4gICAgICBmaWxsOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgIGxhYmVsczogQXJyYXkuZnJvbShBcnJheSh0aGlzLnJlZnZhbHVlcyksIGZ1bmN0aW9uIChfLCB4KSB7XG4gICAgICAgIHJldHVybiB4ICsgMTtcbiAgICAgIH0pLFxuICAgICAgLy9yZXR1cm5zIFsxLDIsMywuLixyZWZ2YWx1ZXNdXG4gICAgICBkYXRhc2V0czogZGF0YXNldFxuICAgIH07IC8vaW5pdGlhbGl6ZSBjb2xvcnMgZm9yIGVhY2ggZGF0YXNldFxuICB9O1xuXG4gIF9wcm90by5hdHRhY2hlZCA9IGZ1bmN0aW9uIGF0dGFjaGVkKCkge1xuICAgIF9DaGFydGpzLnByb3RvdHlwZS5hdHRhY2hlZC5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBDaGFydGpzRml4ZWQ7XG59KF9jaGFydGpzLkNoYXJ0anMpLCAoX2Rlc2NyaXB0b3IgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcImZyb21pZFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMiA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwibGFiZWxzXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3IzID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJyZWZpbmRleFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yNCA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwicmVmdmFsdWVzXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I1ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJ0eXBlXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I2ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJtaW5cIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjcgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcIm1heFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yOCA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwibWF4ZGF0YVwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gaW5pdGlhbGl6ZXIoKSB7XG4gICAgcmV0dXJuIDM7XG4gIH1cbn0pKSwgX2NsYXNzMikpIHx8IF9jbGFzcyk7XG5leHBvcnRzLkNoYXJ0anNGaXhlZCA9IENoYXJ0anNGaXhlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYXJ0anMtZml4ZWQuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-fixed\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-fixed-xy":
/*!************************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-fixed-xy.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.ChartjsFixedXy = void 0;\n\nvar _aureliaTemplating = __webpack_require__(/*! aurelia-templating */ \"hij8\");\n\nvar _chartjsFixed = __webpack_require__(/*! ./chartjs-fixed */ \"aurelia-bodylight-plugin/elements/chartjs-fixed\");\n\nvar _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11;\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\n/**\n * shows fixed curve at time -\n * on X is 0,1,2,3,4,5,6,7,8,9\n * on Y is values from FMU variables from refindex to refvalues\n * convertors for x and y axis separated by ;\n * refindex, refvalues for y values\n * xrefindex,xrefvalues for x values\n */\nvar ChartjsFixedXy = (_dec = (0, _aureliaTemplating.useView)('./chartjs.html'), _dec(_class = (_class2 = /*#__PURE__*/function (_ChartjsFixed) {\n  _inheritsLoose(ChartjsFixedXy, _ChartjsFixed);\n\n  //@bindable cachesize;\n  function ChartjsFixedXy() {\n    var _this;\n\n    _this = _ChartjsFixed.call(this) || this;\n\n    _initializerDefineProperty(_this, \"fromid\", _descriptor, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"labels\", _descriptor2, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"refindex\", _descriptor3, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"refvalues\", _descriptor4, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"type\", _descriptor5, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"min\", _descriptor6, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"max\", _descriptor7, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"maxdata\", _descriptor8, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"xrefindex\", _descriptor9, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"xrefvalues\", _descriptor10, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"xtofixed\", _descriptor11, _assertThisInitialized(_this));\n\n    _this.currentdataset = 0;\n\n    _this.handleValueChange = function (e) {\n      var j = _this.currentdataset; //all values from refindex to one dataset - as one curve\n\n      var ydata = e.detail.data.slice(_this.refindex, _this.refindex + _this.refvalues);\n      var xdata = e.detail.data.slice(_this.xrefindex, _this.xrefindex + _this.xrefvalues); //\n\n      var data = [];\n\n      for (var i = 0; i < ydata.length; i++) {\n        if (_this.operation && _this.operation[0] && _this.operation[1]) data.push({\n          x: _this.operation[0](xdata[i]),\n          y: _this.operation[1](ydata[i])\n        });else data.push({\n          x: xdata[i],\n          y: ydata[i]\n        });\n      } //set labels to x axis\n\n\n      if (_this.xtofixed >= 0) _this.chart.data.labels = xdata.map(function (x) {\n        return x.toFixed(_this.xtofixed);\n      }); //set data xy to chart struct\n\n      if (!_this.chart.data.datasets[j]) {\n        //do initialize dataset first\n        _this.chart.data.datasets.push({\n          data: data,\n          label: \"\",\n          backgroundColor: _this.selectColor(0),\n          borderColor: _this.selectColor(0),\n          borderWidth: 1,\n          pointRadius: 1,\n          fill: false\n        });\n      } else {\n        _this.chart.data.datasets[j].data = data;\n      } //do apply operation on each element of array\n\n      /*if (this.operation && this.operation[0])\n          this.chart.data.datasets[j].data.map(item => {return {x:item.x,y:this.operation[0](item.y)}}); //operation on y\n       */\n\n\n      if (_this.currentdataset >= _this.maxdata) _this.currentdataset = 0;else _this.currentdataset++;\n\n      _this.chart.update();\n    };\n\n    return _this;\n  }\n\n  var _proto = ChartjsFixedXy.prototype;\n\n  _proto.bind = function bind() {\n    _ChartjsFixed.prototype.bind.call(this);\n\n    this.xrefindex = parseInt(this.xrefindex, 10);\n    if (!this.xrefindex) console.warn('xrefindex is not specified');\n    this.xrefvalues = parseInt(this.xrefvalues, 10);\n    if (this.xrefvalues !== this.refvalues) console.warn('xrefvalues must be equal to refvalues');\n  };\n\n  _proto.attached = function attached() {\n    _ChartjsFixed.prototype.attached.call(this);\n  };\n\n  return ChartjsFixedXy;\n}(_chartjsFixed.ChartjsFixed), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"fromid\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"labels\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, \"refindex\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, \"refvalues\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, \"type\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, \"min\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, \"max\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, \"maxdata\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 3;\n  }\n}), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, \"xrefindex\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, \"xrefvalues\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, \"xtofixed\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return -1;\n  }\n})), _class2)) || _class);\nexports.ChartjsFixedXy = ChartjsFixedXy;\n//# sourceMappingURL=chartjs-fixed-xy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMtZml4ZWQteHkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2Rpc3QvbmF0aXZlLW1vZHVsZXMvZWxlbWVudHMvY2hhcnRqcy1maXhlZC14eS5qcz9mZGZkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5DaGFydGpzRml4ZWRYeSA9IHZvaWQgMDtcblxudmFyIF9hdXJlbGlhVGVtcGxhdGluZyA9IHJlcXVpcmUoXCJhdXJlbGlhLXRlbXBsYXRpbmdcIik7XG5cbnZhciBfY2hhcnRqc0ZpeGVkID0gcmVxdWlyZShcIi4vY2hhcnRqcy1maXhlZFwiKTtcblxudmFyIF9kZWMsIF9jbGFzcywgX2NsYXNzMiwgX2Rlc2NyaXB0b3IsIF9kZXNjcmlwdG9yMiwgX2Rlc2NyaXB0b3IzLCBfZGVzY3JpcHRvcjQsIF9kZXNjcmlwdG9yNSwgX2Rlc2NyaXB0b3I2LCBfZGVzY3JpcHRvcjcsIF9kZXNjcmlwdG9yOCwgX2Rlc2NyaXB0b3I5LCBfZGVzY3JpcHRvcjEwLCBfZGVzY3JpcHRvcjExO1xuXG5mdW5jdGlvbiBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7IGlmICghZGVzY3JpcHRvcikgcmV0dXJuOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgeyBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsIHdyaXRhYmxlOiBkZXNjcmlwdG9yLndyaXRhYmxlLCB2YWx1ZTogZGVzY3JpcHRvci5pbml0aWFsaXplciA/IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMCB9KTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVjb3JhdG9ycywgZGVzY3JpcHRvciwgY29udGV4dCkgeyB2YXIgZGVzYyA9IHt9OyBPYmplY3Qua2V5cyhkZXNjcmlwdG9yKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZGVzY1trZXldID0gZGVzY3JpcHRvcltrZXldOyB9KTsgZGVzYy5lbnVtZXJhYmxlID0gISFkZXNjLmVudW1lcmFibGU7IGRlc2MuY29uZmlndXJhYmxlID0gISFkZXNjLmNvbmZpZ3VyYWJsZTsgaWYgKCd2YWx1ZScgaW4gZGVzYyB8fCBkZXNjLmluaXRpYWxpemVyKSB7IGRlc2Mud3JpdGFibGUgPSB0cnVlOyB9IGRlc2MgPSBkZWNvcmF0b3JzLnNsaWNlKCkucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbiAoZGVzYywgZGVjb3JhdG9yKSB7IHJldHVybiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYykgfHwgZGVzYzsgfSwgZGVzYyk7IGlmIChjb250ZXh0ICYmIGRlc2MuaW5pdGlhbGl6ZXIgIT09IHZvaWQgMCkgeyBkZXNjLnZhbHVlID0gZGVzYy5pbml0aWFsaXplciA/IGRlc2MuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMDsgZGVzYy5pbml0aWFsaXplciA9IHVuZGVmaW5lZDsgfSBpZiAoZGVzYy5pbml0aWFsaXplciA9PT0gdm9pZCAwKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjKTsgZGVzYyA9IG51bGw7IH0gcmV0dXJuIGRlc2M7IH1cblxuZnVuY3Rpb24gX2luaXRpYWxpemVyV2FybmluZ0hlbHBlcihkZXNjcmlwdG9yLCBjb250ZXh0KSB7IHRocm93IG5ldyBFcnJvcignRGVjb3JhdGluZyBjbGFzcyBwcm9wZXJ0eSBmYWlsZWQuIFBsZWFzZSBlbnN1cmUgdGhhdCAnICsgJ3Byb3Bvc2FsLWNsYXNzLXByb3BlcnRpZXMgaXMgZW5hYmxlZCBhbmQgcnVucyBhZnRlciB0aGUgZGVjb3JhdG9ycyB0cmFuc2Zvcm0uJyk7IH1cblxuLyoqXG4gKiBzaG93cyBmaXhlZCBjdXJ2ZSBhdCB0aW1lIC1cbiAqIG9uIFggaXMgMCwxLDIsMyw0LDUsNiw3LDgsOVxuICogb24gWSBpcyB2YWx1ZXMgZnJvbSBGTVUgdmFyaWFibGVzIGZyb20gcmVmaW5kZXggdG8gcmVmdmFsdWVzXG4gKiBjb252ZXJ0b3JzIGZvciB4IGFuZCB5IGF4aXMgc2VwYXJhdGVkIGJ5IDtcbiAqIHJlZmluZGV4LCByZWZ2YWx1ZXMgZm9yIHkgdmFsdWVzXG4gKiB4cmVmaW5kZXgseHJlZnZhbHVlcyBmb3IgeCB2YWx1ZXNcbiAqL1xudmFyIENoYXJ0anNGaXhlZFh5ID0gKF9kZWMgPSAoMCwgX2F1cmVsaWFUZW1wbGF0aW5nLnVzZVZpZXcpKCcuL2NoYXJ0anMuaHRtbCcpLCBfZGVjKF9jbGFzcyA9IChfY2xhc3MyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ2hhcnRqc0ZpeGVkKSB7XG4gIF9pbmhlcml0c0xvb3NlKENoYXJ0anNGaXhlZFh5LCBfQ2hhcnRqc0ZpeGVkKTtcblxuICAvL0BiaW5kYWJsZSBjYWNoZXNpemU7XG4gIGZ1bmN0aW9uIENoYXJ0anNGaXhlZFh5KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0NoYXJ0anNGaXhlZC5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJmcm9taWRcIiwgX2Rlc2NyaXB0b3IsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcImxhYmVsc1wiLCBfZGVzY3JpcHRvcjIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcInJlZmluZGV4XCIsIF9kZXNjcmlwdG9yMywgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicmVmdmFsdWVzXCIsIF9kZXNjcmlwdG9yNCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkoX3RoaXMsIFwidHlwZVwiLCBfZGVzY3JpcHRvcjUsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcIm1pblwiLCBfZGVzY3JpcHRvcjYsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcIm1heFwiLCBfZGVzY3JpcHRvcjcsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcIm1heGRhdGFcIiwgX2Rlc2NyaXB0b3I4LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ4cmVmaW5kZXhcIiwgX2Rlc2NyaXB0b3I5LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ4cmVmdmFsdWVzXCIsIF9kZXNjcmlwdG9yMTAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcInh0b2ZpeGVkXCIsIF9kZXNjcmlwdG9yMTEsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF90aGlzLmN1cnJlbnRkYXRhc2V0ID0gMDtcblxuICAgIF90aGlzLmhhbmRsZVZhbHVlQ2hhbmdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBqID0gX3RoaXMuY3VycmVudGRhdGFzZXQ7IC8vYWxsIHZhbHVlcyBmcm9tIHJlZmluZGV4IHRvIG9uZSBkYXRhc2V0IC0gYXMgb25lIGN1cnZlXG5cbiAgICAgIHZhciB5ZGF0YSA9IGUuZGV0YWlsLmRhdGEuc2xpY2UoX3RoaXMucmVmaW5kZXgsIF90aGlzLnJlZmluZGV4ICsgX3RoaXMucmVmdmFsdWVzKTtcbiAgICAgIHZhciB4ZGF0YSA9IGUuZGV0YWlsLmRhdGEuc2xpY2UoX3RoaXMueHJlZmluZGV4LCBfdGhpcy54cmVmaW5kZXggKyBfdGhpcy54cmVmdmFsdWVzKTsgLy9cblxuICAgICAgdmFyIGRhdGEgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB5ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoX3RoaXMub3BlcmF0aW9uICYmIF90aGlzLm9wZXJhdGlvblswXSAmJiBfdGhpcy5vcGVyYXRpb25bMV0pIGRhdGEucHVzaCh7XG4gICAgICAgICAgeDogX3RoaXMub3BlcmF0aW9uWzBdKHhkYXRhW2ldKSxcbiAgICAgICAgICB5OiBfdGhpcy5vcGVyYXRpb25bMV0oeWRhdGFbaV0pXG4gICAgICAgIH0pO2Vsc2UgZGF0YS5wdXNoKHtcbiAgICAgICAgICB4OiB4ZGF0YVtpXSxcbiAgICAgICAgICB5OiB5ZGF0YVtpXVxuICAgICAgICB9KTtcbiAgICAgIH0gLy9zZXQgbGFiZWxzIHRvIHggYXhpc1xuXG5cbiAgICAgIGlmIChfdGhpcy54dG9maXhlZCA+PSAwKSBfdGhpcy5jaGFydC5kYXRhLmxhYmVscyA9IHhkYXRhLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC50b0ZpeGVkKF90aGlzLnh0b2ZpeGVkKTtcbiAgICAgIH0pOyAvL3NldCBkYXRhIHh5IHRvIGNoYXJ0IHN0cnVjdFxuXG4gICAgICBpZiAoIV90aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbal0pIHtcbiAgICAgICAgLy9kbyBpbml0aWFsaXplIGRhdGFzZXQgZmlyc3RcbiAgICAgICAgX3RoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5wdXNoKHtcbiAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgIGxhYmVsOiBcIlwiLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogX3RoaXMuc2VsZWN0Q29sb3IoMCksXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IF90aGlzLnNlbGVjdENvbG9yKDApLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgICAgIHBvaW50UmFkaXVzOiAxLFxuICAgICAgICAgIGZpbGw6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tqXS5kYXRhID0gZGF0YTtcbiAgICAgIH0gLy9kbyBhcHBseSBvcGVyYXRpb24gb24gZWFjaCBlbGVtZW50IG9mIGFycmF5XG5cbiAgICAgIC8qaWYgKHRoaXMub3BlcmF0aW9uICYmIHRoaXMub3BlcmF0aW9uWzBdKVxuICAgICAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tqXS5kYXRhLm1hcChpdGVtID0+IHtyZXR1cm4ge3g6aXRlbS54LHk6dGhpcy5vcGVyYXRpb25bMF0oaXRlbS55KX19KTsgLy9vcGVyYXRpb24gb24geVxuICAgICAgICovXG5cblxuICAgICAgaWYgKF90aGlzLmN1cnJlbnRkYXRhc2V0ID49IF90aGlzLm1heGRhdGEpIF90aGlzLmN1cnJlbnRkYXRhc2V0ID0gMDtlbHNlIF90aGlzLmN1cnJlbnRkYXRhc2V0Kys7XG5cbiAgICAgIF90aGlzLmNoYXJ0LnVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ2hhcnRqc0ZpeGVkWHkucHJvdG90eXBlO1xuXG4gIF9wcm90by5iaW5kID0gZnVuY3Rpb24gYmluZCgpIHtcbiAgICBfQ2hhcnRqc0ZpeGVkLnByb3RvdHlwZS5iaW5kLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnhyZWZpbmRleCA9IHBhcnNlSW50KHRoaXMueHJlZmluZGV4LCAxMCk7XG4gICAgaWYgKCF0aGlzLnhyZWZpbmRleCkgY29uc29sZS53YXJuKCd4cmVmaW5kZXggaXMgbm90IHNwZWNpZmllZCcpO1xuICAgIHRoaXMueHJlZnZhbHVlcyA9IHBhcnNlSW50KHRoaXMueHJlZnZhbHVlcywgMTApO1xuICAgIGlmICh0aGlzLnhyZWZ2YWx1ZXMgIT09IHRoaXMucmVmdmFsdWVzKSBjb25zb2xlLndhcm4oJ3hyZWZ2YWx1ZXMgbXVzdCBiZSBlcXVhbCB0byByZWZ2YWx1ZXMnKTtcbiAgfTtcblxuICBfcHJvdG8uYXR0YWNoZWQgPSBmdW5jdGlvbiBhdHRhY2hlZCgpIHtcbiAgICBfQ2hhcnRqc0ZpeGVkLnByb3RvdHlwZS5hdHRhY2hlZC5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBDaGFydGpzRml4ZWRYeTtcbn0oX2NoYXJ0anNGaXhlZC5DaGFydGpzRml4ZWQpLCAoX2Rlc2NyaXB0b3IgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcImZyb21pZFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMiA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwibGFiZWxzXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3IzID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJyZWZpbmRleFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yNCA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwicmVmdmFsdWVzXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I1ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJ0eXBlXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I2ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJtaW5cIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjcgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcIm1heFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yOCA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwibWF4ZGF0YVwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gaW5pdGlhbGl6ZXIoKSB7XG4gICAgcmV0dXJuIDM7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjkgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcInhyZWZpbmRleFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMTAgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcInhyZWZ2YWx1ZXNcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjExID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJ4dG9maXhlZFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gaW5pdGlhbGl6ZXIoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59KSksIF9jbGFzczIpKSB8fCBfY2xhc3MpO1xuZXhwb3J0cy5DaGFydGpzRml4ZWRYeSA9IENoYXJ0anNGaXhlZFh5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhcnRqcy1maXhlZC14eS5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-fixed-xy\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-fixed-xy.html":
/*!**************************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-fixed-xy.html ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template></template>\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMtZml4ZWQteHkuaHRtbC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLWJvZHlsaWdodC1wbHVnaW4vZGlzdC9uYXRpdmUtbW9kdWxlcy9lbGVtZW50cy9jaGFydGpzLWZpeGVkLXh5Lmh0bWw/YTIyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiPHRlbXBsYXRlPjwvdGVtcGxhdGU+XFxuXCI7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-fixed-xy.html\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-fixed.html":
/*!***********************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-fixed.html ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template></template>\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMtZml4ZWQuaHRtbC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLWJvZHlsaWdodC1wbHVnaW4vZGlzdC9uYXRpdmUtbW9kdWxlcy9lbGVtZW50cy9jaGFydGpzLWZpeGVkLmh0bWw/NTc1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiPHRlbXBsYXRlPjwvdGVtcGxhdGU+XFxuXCI7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-fixed.html\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-stacked":
/*!***********************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-stacked.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.ChartjsStacked = void 0;\n\nvar _aureliaTemplating = __webpack_require__(/*! aurelia-templating */ \"hij8\");\n\nvar _chartjs = __webpack_require__(/*! ./chartjs */ \"aurelia-bodylight-plugin/elements/chartjs\");\n\nvar _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9;\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\n/**\n * shows stacked box -\n * on X is group stack 0 or stack 1\n * on Y is values from FMU variables from refindexes\n */\nvar ChartjsStacked = (_dec = (0, _aureliaTemplating.useView)('./chartjs.html'), _dec(_class = (_class2 = /*#__PURE__*/function (_Chartjs) {\n  _inheritsLoose(ChartjsStacked, _Chartjs);\n\n  function ChartjsStacked() {\n    var _this;\n\n    _this = _Chartjs.call(this) || this; //stacked box contains data, each box in different dataset, group is\n\n    _initializerDefineProperty(_this, \"fromid\", _descriptor, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"labels\", _descriptor2, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"refindex\", _descriptor3, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"refvalues\", _descriptor4, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"type\", _descriptor5, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"min\", _descriptor6, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"max\", _descriptor7, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"maxdata\", _descriptor8, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"stacks\", _descriptor9, _assertThisInitialized(_this));\n\n    _this.handleValueChange = function (e) {\n      for (var j = 0; j < _this.refindices.length; j++) {\n        if (!_this.chart.data.datasets[j]) {\n          //do initialize dataset first\n          _this.chart.data.datasets.push({\n            data: [e.detail.data[_this.refindices[j]]],\n            //data is array\n            label: _this.chlabels[j],\n            backgroundColor: _this.selectColor(j),\n            stack: _this.stack[j]\n          });\n        } else {\n          _this.chart.data.datasets[j].data[0] = e.detail.data[_this.refindices[j]]; //data is array 0 item\n        }\n      }\n\n      _this.chart.update();\n    };\n\n    return _this;\n  }\n\n  var _proto = ChartjsStacked.prototype;\n\n  _proto.bind = function bind() {\n    _Chartjs.prototype.bind.call(this);\n\n    this.type = \"bar\";\n    this.options.scales.xAxes = [{\n      stacked: true\n    }];\n    this.options.scales.yAxes = [{\n      stacked: true\n    }]; //reset labels\n\n    this.data.labels = [\"data\"]; //allows refindices to be defined in refindex separated by comma ,\n\n    if (Array.isArray(this.refindex)) {\n      this.refindices = this.refindex; //define stack array for groups, contains descriptive string for group\n    } else {\n      //or refindices will be refindex, refindex+1, ...\n      this.refindices = [];\n\n      for (var i = 0; i < this.refvalues; i++) {\n        this.refindices.push(this.refindex + i);\n      }\n    }\n\n    if (this.stacks) {\n      this.stack = this.stacks.split(',');\n    } else {\n      this.stack = new Array(this.refindices.length).fill('stack 0');\n    } //init dataset data and labels = 0\n\n\n    this.data.datasets = [];\n\n    for (var j = 0; j < this.refindices.length; j++) {\n      //do initialize dataset first\n      this.data.datasets.push({\n        data: [0],\n        //data is array\n        label: this.chlabels[j],\n        backgroundColor: this.selectColor(j),\n        stack: this.stack[j]\n      });\n    }\n  };\n\n  _proto.attached = function attached() {\n    _Chartjs.prototype.attached.call(this);\n  };\n\n  return ChartjsStacked;\n}(_chartjs.Chartjs), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"fromid\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"labels\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, \"refindex\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, \"refvalues\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, \"type\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, \"min\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, \"max\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, \"maxdata\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 3;\n  }\n}), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, \"stacks\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);\nexports.ChartjsStacked = ChartjsStacked;\n//# sourceMappingURL=chartjs-stacked.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMtc3RhY2tlZC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLWJvZHlsaWdodC1wbHVnaW4vZGlzdC9uYXRpdmUtbW9kdWxlcy9lbGVtZW50cy9jaGFydGpzLXN0YWNrZWQuanM/YzViMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQ2hhcnRqc1N0YWNrZWQgPSB2b2lkIDA7XG5cbnZhciBfYXVyZWxpYVRlbXBsYXRpbmcgPSByZXF1aXJlKFwiYXVyZWxpYS10ZW1wbGF0aW5nXCIpO1xuXG52YXIgX2NoYXJ0anMgPSByZXF1aXJlKFwiLi9jaGFydGpzXCIpO1xuXG52YXIgX2RlYywgX2NsYXNzLCBfY2xhc3MyLCBfZGVzY3JpcHRvciwgX2Rlc2NyaXB0b3IyLCBfZGVzY3JpcHRvcjMsIF9kZXNjcmlwdG9yNCwgX2Rlc2NyaXB0b3I1LCBfZGVzY3JpcHRvcjYsIF9kZXNjcmlwdG9yNywgX2Rlc2NyaXB0b3I4LCBfZGVzY3JpcHRvcjk7XG5cbmZ1bmN0aW9uIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2NyaXB0b3IsIGNvbnRleHQpIHsgaWYgKCFkZXNjcmlwdG9yKSByZXR1cm47IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCB7IGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSwgY29uZmlndXJhYmxlOiBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSwgd3JpdGFibGU6IGRlc2NyaXB0b3Iud3JpdGFibGUsIHZhbHVlOiBkZXNjcmlwdG9yLmluaXRpYWxpemVyID8gZGVzY3JpcHRvci5pbml0aWFsaXplci5jYWxsKGNvbnRleHQpIDogdm9pZCAwIH0pOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5LCBkZWNvcmF0b3JzLCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7IHZhciBkZXNjID0ge307IE9iamVjdC5rZXlzKGRlc2NyaXB0b3IpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBkZXNjW2tleV0gPSBkZXNjcmlwdG9yW2tleV07IH0pOyBkZXNjLmVudW1lcmFibGUgPSAhIWRlc2MuZW51bWVyYWJsZTsgZGVzYy5jb25maWd1cmFibGUgPSAhIWRlc2MuY29uZmlndXJhYmxlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjIHx8IGRlc2MuaW5pdGlhbGl6ZXIpIHsgZGVzYy53cml0YWJsZSA9IHRydWU7IH0gZGVzYyA9IGRlY29yYXRvcnMuc2xpY2UoKS5yZXZlcnNlKCkucmVkdWNlKGZ1bmN0aW9uIChkZXNjLCBkZWNvcmF0b3IpIHsgcmV0dXJuIGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5LCBkZXNjKSB8fCBkZXNjOyB9LCBkZXNjKTsgaWYgKGNvbnRleHQgJiYgZGVzYy5pbml0aWFsaXplciAhPT0gdm9pZCAwKSB7IGRlc2MudmFsdWUgPSBkZXNjLmluaXRpYWxpemVyID8gZGVzYy5pbml0aWFsaXplci5jYWxsKGNvbnRleHQpIDogdm9pZCAwOyBkZXNjLmluaXRpYWxpemVyID0gdW5kZWZpbmVkOyB9IGlmIChkZXNjLmluaXRpYWxpemVyID09PSB2b2lkIDApIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2MpOyBkZXNjID0gbnVsbDsgfSByZXR1cm4gZGVzYzsgfVxuXG5mdW5jdGlvbiBfaW5pdGlhbGl6ZXJXYXJuaW5nSGVscGVyKGRlc2NyaXB0b3IsIGNvbnRleHQpIHsgdGhyb3cgbmV3IEVycm9yKCdEZWNvcmF0aW5nIGNsYXNzIHByb3BlcnR5IGZhaWxlZC4gUGxlYXNlIGVuc3VyZSB0aGF0ICcgKyAncHJvcG9zYWwtY2xhc3MtcHJvcGVydGllcyBpcyBlbmFibGVkIGFuZCBydW5zIGFmdGVyIHRoZSBkZWNvcmF0b3JzIHRyYW5zZm9ybS4nKTsgfVxuXG4vKipcbiAqIHNob3dzIHN0YWNrZWQgYm94IC1cbiAqIG9uIFggaXMgZ3JvdXAgc3RhY2sgMCBvciBzdGFjayAxXG4gKiBvbiBZIGlzIHZhbHVlcyBmcm9tIEZNVSB2YXJpYWJsZXMgZnJvbSByZWZpbmRleGVzXG4gKi9cbnZhciBDaGFydGpzU3RhY2tlZCA9IChfZGVjID0gKDAsIF9hdXJlbGlhVGVtcGxhdGluZy51c2VWaWV3KSgnLi9jaGFydGpzLmh0bWwnKSwgX2RlYyhfY2xhc3MgPSAoX2NsYXNzMiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NoYXJ0anMpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ2hhcnRqc1N0YWNrZWQsIF9DaGFydGpzKTtcblxuICBmdW5jdGlvbiBDaGFydGpzU3RhY2tlZCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9DaGFydGpzLmNhbGwodGhpcykgfHwgdGhpczsgLy9zdGFja2VkIGJveCBjb250YWlucyBkYXRhLCBlYWNoIGJveCBpbiBkaWZmZXJlbnQgZGF0YXNldCwgZ3JvdXAgaXNcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcImZyb21pZFwiLCBfZGVzY3JpcHRvciwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibGFiZWxzXCIsIF9kZXNjcmlwdG9yMiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicmVmaW5kZXhcIiwgX2Rlc2NyaXB0b3IzLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJyZWZ2YWx1ZXNcIiwgX2Rlc2NyaXB0b3I0LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ0eXBlXCIsIF9kZXNjcmlwdG9yNSwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibWluXCIsIF9kZXNjcmlwdG9yNiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibWF4XCIsIF9kZXNjcmlwdG9yNywgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibWF4ZGF0YVwiLCBfZGVzY3JpcHRvcjgsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcInN0YWNrc1wiLCBfZGVzY3JpcHRvcjksIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF90aGlzLmhhbmRsZVZhbHVlQ2hhbmdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgX3RoaXMucmVmaW5kaWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoIV90aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbal0pIHtcbiAgICAgICAgICAvL2RvIGluaXRpYWxpemUgZGF0YXNldCBmaXJzdFxuICAgICAgICAgIF90aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMucHVzaCh7XG4gICAgICAgICAgICBkYXRhOiBbZS5kZXRhaWwuZGF0YVtfdGhpcy5yZWZpbmRpY2VzW2pdXV0sXG4gICAgICAgICAgICAvL2RhdGEgaXMgYXJyYXlcbiAgICAgICAgICAgIGxhYmVsOiBfdGhpcy5jaGxhYmVsc1tqXSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogX3RoaXMuc2VsZWN0Q29sb3IoaiksXG4gICAgICAgICAgICBzdGFjazogX3RoaXMuc3RhY2tbal1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2pdLmRhdGFbMF0gPSBlLmRldGFpbC5kYXRhW190aGlzLnJlZmluZGljZXNbal1dOyAvL2RhdGEgaXMgYXJyYXkgMCBpdGVtXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX3RoaXMuY2hhcnQudXBkYXRlKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDaGFydGpzU3RhY2tlZC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmJpbmQgPSBmdW5jdGlvbiBiaW5kKCkge1xuICAgIF9DaGFydGpzLnByb3RvdHlwZS5iaW5kLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnR5cGUgPSBcImJhclwiO1xuICAgIHRoaXMub3B0aW9ucy5zY2FsZXMueEF4ZXMgPSBbe1xuICAgICAgc3RhY2tlZDogdHJ1ZVxuICAgIH1dO1xuICAgIHRoaXMub3B0aW9ucy5zY2FsZXMueUF4ZXMgPSBbe1xuICAgICAgc3RhY2tlZDogdHJ1ZVxuICAgIH1dOyAvL3Jlc2V0IGxhYmVsc1xuXG4gICAgdGhpcy5kYXRhLmxhYmVscyA9IFtcImRhdGFcIl07IC8vYWxsb3dzIHJlZmluZGljZXMgdG8gYmUgZGVmaW5lZCBpbiByZWZpbmRleCBzZXBhcmF0ZWQgYnkgY29tbWEgLFxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5yZWZpbmRleCkpIHtcbiAgICAgIHRoaXMucmVmaW5kaWNlcyA9IHRoaXMucmVmaW5kZXg7IC8vZGVmaW5lIHN0YWNrIGFycmF5IGZvciBncm91cHMsIGNvbnRhaW5zIGRlc2NyaXB0aXZlIHN0cmluZyBmb3IgZ3JvdXBcbiAgICB9IGVsc2Uge1xuICAgICAgLy9vciByZWZpbmRpY2VzIHdpbGwgYmUgcmVmaW5kZXgsIHJlZmluZGV4KzEsIC4uLlxuICAgICAgdGhpcy5yZWZpbmRpY2VzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWZ2YWx1ZXM7IGkrKykge1xuICAgICAgICB0aGlzLnJlZmluZGljZXMucHVzaCh0aGlzLnJlZmluZGV4ICsgaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhY2tzKSB7XG4gICAgICB0aGlzLnN0YWNrID0gdGhpcy5zdGFja3Muc3BsaXQoJywnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFjayA9IG5ldyBBcnJheSh0aGlzLnJlZmluZGljZXMubGVuZ3RoKS5maWxsKCdzdGFjayAwJyk7XG4gICAgfSAvL2luaXQgZGF0YXNldCBkYXRhIGFuZCBsYWJlbHMgPSAwXG5cblxuICAgIHRoaXMuZGF0YS5kYXRhc2V0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnJlZmluZGljZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIC8vZG8gaW5pdGlhbGl6ZSBkYXRhc2V0IGZpcnN0XG4gICAgICB0aGlzLmRhdGEuZGF0YXNldHMucHVzaCh7XG4gICAgICAgIGRhdGE6IFswXSxcbiAgICAgICAgLy9kYXRhIGlzIGFycmF5XG4gICAgICAgIGxhYmVsOiB0aGlzLmNobGFiZWxzW2pdLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuc2VsZWN0Q29sb3IoaiksXG4gICAgICAgIHN0YWNrOiB0aGlzLnN0YWNrW2pdXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmF0dGFjaGVkID0gZnVuY3Rpb24gYXR0YWNoZWQoKSB7XG4gICAgX0NoYXJ0anMucHJvdG90eXBlLmF0dGFjaGVkLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIENoYXJ0anNTdGFja2VkO1xufShfY2hhcnRqcy5DaGFydGpzKSwgKF9kZXNjcmlwdG9yID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJmcm9taWRcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjIgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcImxhYmVsc1wiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMyA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwicmVmaW5kZXhcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjQgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcInJlZnZhbHVlc1wiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yNSA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwidHlwZVwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yNiA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwibWluXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I3ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJtYXhcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjggPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcIm1heGRhdGFcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uIGluaXRpYWxpemVyKCkge1xuICAgIHJldHVybiAzO1xuICB9XG59KSwgX2Rlc2NyaXB0b3I5ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJzdGFja3NcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pKSwgX2NsYXNzMikpIHx8IF9jbGFzcyk7XG5leHBvcnRzLkNoYXJ0anNTdGFja2VkID0gQ2hhcnRqc1N0YWNrZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFydGpzLXN0YWNrZWQuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-stacked\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-stacked.html":
/*!*************************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-stacked.html ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template></template>\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMtc3RhY2tlZC5odG1sLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F1cmVsaWEtYm9keWxpZ2h0LXBsdWdpbi9kaXN0L25hdGl2ZS1tb2R1bGVzL2VsZW1lbnRzL2NoYXJ0anMtc3RhY2tlZC5odG1sPzUyM2EiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIjx0ZW1wbGF0ZT48L3RlbXBsYXRlPlxcblwiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-stacked.html\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-time":
/*!********************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-time.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.ChartjsTime = void 0;\n\nvar _aureliaTemplating = __webpack_require__(/*! aurelia-templating */ \"hij8\");\n\nvar _chartjs = __webpack_require__(/*! ./chartjs */ \"aurelia-bodylight-plugin/elements/chartjs\");\n\nvar _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7;\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\n//import {PLATFORM} from 'aurelia-pal';\n//@customElement\n//@useView(PLATFORM.moduleName('./bdl-chartjs.html'))\nvar ChartjsTime = (_dec = (0, _aureliaTemplating.useView)('./chartjs.html'), _dec(_class = (_class2 = /*#__PURE__*/function (_Chartjs) {\n  _inheritsLoose(ChartjsTime, _Chartjs);\n\n  function ChartjsTime() {\n    var _this;\n\n    _this = _Chartjs.call(this) || this; //this.type = 'line';\n\n    _initializerDefineProperty(_this, \"fromid\", _descriptor, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"labels\", _descriptor2, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"refindex\", _descriptor3, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"refvalues\", _descriptor4, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"type\", _descriptor5, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"min\", _descriptor6, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"max\", _descriptor7, _assertThisInitialized(_this));\n\n    _this.handleValueChange = function (e) {\n      //e.detail do not reallocate - using same buffer, thus slicing to append to data array\n      //let datapoints =e.detail.data.slice(this.refindex, this.refendindex);\n      var j = 0;\n\n      for (var i = _this.refindex; i < _this.refindex + _this.refvalues; i++) {\n        //adds data to datasets\n        //if convert operation is defined as array then convert\n        if (_this.operation && _this.operation[j]) _this.chart.data.datasets[j].data.push(_this.operation[j](e.detail.data[i])); //else push data directly\n        else _this.chart.data.datasets[j].data.push(e.detail.data[i]);\n\n        if (_this.chart.data.datasets[j].data.length > _this.maxdata) {\n          //console.log('shifting dataset chartjs-time', this.chart.data.datasets[j].data);\n          _this.chart.data.datasets[j].data.shift();\n        }\n\n        j++;\n      }\n\n      _this.chart.data.labels.push(e.detail.time);\n\n      if (_this.chart.data.labels.length > _this.maxdata) {\n        _this.chart.data.labels.shift();\n\n        if (_this.sectionid) {\n          //shift sections\n          if (_this.chart.config.options.section[0].index === 0) _this.chart.config.options.section.shift(); //decrement all indices in sections\n\n          for (var _i = 0; _i < _this.chart.config.options.section.length; _i++) {\n            _this.chart.config.options.section[_i].index -= 1;\n          }\n        }\n      } //shift - remove first element if data is too big\n      //console.log('chartjs handlevaluechange() chart.data.datasets[0].data', this.chart.data.datasets[0].data);\n\n\n      _this.chart.update();\n    };\n\n    return _this;\n  }\n  /**\n   * sets all tim-series specific options for chartjs\n   */\n\n\n  var _proto = ChartjsTime.prototype;\n\n  _proto.bind = function bind() {\n    _Chartjs.prototype.bind.call(this); //done in super\n    //this.chlabels = this.labels.split(','); //labels for each dataset\n    //this.colors = [];\n\n\n    var datasets = [];\n    var mydata1 = this.initialdata.split(';');\n\n    for (var i = 0; i < this.refvalues + 1; i++) {\n      //mydata[0] == timelabels in x axis, mydata[1..n] ar in y axis\n      var mydata2 = mydata1[i] ? mydata1[i].split(',') : [];\n      this.mydata[i] = mydata2.map(function (x) {\n        return parseFloat(x);\n      }); //console.log('chartjstime mydata i',this.mydata[i]);\n    } //initialize colors for each dataset\n\n\n    for (var _i2 = 0; _i2 < this.refvalues; _i2++) {\n      //this.colors.push(this.selectColor(i));\n      datasets.push({\n        data: this.mydata[_i2 + 1],\n        label: this.chlabels[_i2],\n        backgroundColor: this.selectColor(_i2),\n        borderColor: this.selectColor(_i2),\n        borderWidth: 1,\n        pointRadius: 1,\n        fill: false\n      }); //timelabels.push(i);\n    }\n\n    this.data = {\n      labels: this.mydata[0],\n      datasets: datasets\n    };\n    if (this.verticalline) this.type = 'LineWithLine';else this.type = 'line';\n\n    if (this.min) {\n      //sets yscale min\n      if (!this.options) this.options = {};\n      if (!this.options.scales) this.options.scales = {};\n      if (!this.options.scales.yAxes) this.options.scales.yAxes = [{}]; //chartjs 2.9.4\n\n      if (!this.options.scales.yAxes[0].ticks) this.options.scales.yAxes[0].ticks = {}; //chartjs 2.9.4\n\n      this.options.scales.yAxes[0].ticks.min = parseFloat(this.min);\n    }\n\n    if (this.max) {\n      //sets yscale max\n      if (!this.options) this.options = {};\n      if (!this.options.scales) this.options.scales = {};\n      if (!this.options.scales.yAxes) this.options.scales.yAxes = [{}]; //chartjs 2.9.4\n\n      if (!this.options.scales.yAxes[0].ticks) this.options.scales.yAxes[0].ticks = {}; //chartjs 2.9.4\n\n      this.options.scales.yAxes[0].ticks.max = parseFloat(this.max); //if (this.min) this.options.scales.yAxes[0].ticks.stepSize = (this.options.scales.yAxes[0].ticks.max - this.options.scales.yAxes[0].ticks.min) / 10;\n    }\n  };\n\n  _proto.resetdata = function resetdata() {\n    //super.resetdata();\n    for (var j = 0; j < this.refvalues; j++) {\n      this.chart.data.datasets[j].data = [];\n    }\n\n    this.chart.data.labels = [];\n    this.chart.update();\n  };\n\n  return ChartjsTime;\n}(_chartjs.Chartjs), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"fromid\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"labels\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, \"refindex\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, \"refvalues\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, \"type\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, \"min\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, \"max\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);\nexports.ChartjsTime = ChartjsTime;\n//# sourceMappingURL=chartjs-time.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMtdGltZS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLWJvZHlsaWdodC1wbHVnaW4vZGlzdC9uYXRpdmUtbW9kdWxlcy9lbGVtZW50cy9jaGFydGpzLXRpbWUuanM/MTg4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQ2hhcnRqc1RpbWUgPSB2b2lkIDA7XG5cbnZhciBfYXVyZWxpYVRlbXBsYXRpbmcgPSByZXF1aXJlKFwiYXVyZWxpYS10ZW1wbGF0aW5nXCIpO1xuXG52YXIgX2NoYXJ0anMgPSByZXF1aXJlKFwiLi9jaGFydGpzXCIpO1xuXG52YXIgX2RlYywgX2NsYXNzLCBfY2xhc3MyLCBfZGVzY3JpcHRvciwgX2Rlc2NyaXB0b3IyLCBfZGVzY3JpcHRvcjMsIF9kZXNjcmlwdG9yNCwgX2Rlc2NyaXB0b3I1LCBfZGVzY3JpcHRvcjYsIF9kZXNjcmlwdG9yNztcblxuZnVuY3Rpb24gX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvciwgY29udGV4dCkgeyBpZiAoIWRlc2NyaXB0b3IpIHJldHVybjsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHsgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLCBjb25maWd1cmFibGU6IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlLCB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSwgdmFsdWU6IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIgPyBkZXNjcmlwdG9yLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDAgfSk7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHksIGRlY29yYXRvcnMsIGRlc2NyaXB0b3IsIGNvbnRleHQpIHsgdmFyIGRlc2MgPSB7fTsgT2JqZWN0LmtleXMoZGVzY3JpcHRvcikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGRlc2Nba2V5XSA9IGRlc2NyaXB0b3Jba2V5XTsgfSk7IGRlc2MuZW51bWVyYWJsZSA9ICEhZGVzYy5lbnVtZXJhYmxlOyBkZXNjLmNvbmZpZ3VyYWJsZSA9ICEhZGVzYy5jb25maWd1cmFibGU7IGlmICgndmFsdWUnIGluIGRlc2MgfHwgZGVzYy5pbml0aWFsaXplcikgeyBkZXNjLndyaXRhYmxlID0gdHJ1ZTsgfSBkZXNjID0gZGVjb3JhdG9ycy5zbGljZSgpLnJldmVyc2UoKS5yZWR1Y2UoZnVuY3Rpb24gKGRlc2MsIGRlY29yYXRvcikgeyByZXR1cm4gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHksIGRlc2MpIHx8IGRlc2M7IH0sIGRlc2MpOyBpZiAoY29udGV4dCAmJiBkZXNjLmluaXRpYWxpemVyICE9PSB2b2lkIDApIHsgZGVzYy52YWx1ZSA9IGRlc2MuaW5pdGlhbGl6ZXIgPyBkZXNjLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDA7IGRlc2MuaW5pdGlhbGl6ZXIgPSB1bmRlZmluZWQ7IH0gaWYgKGRlc2MuaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYyk7IGRlc2MgPSBudWxsOyB9IHJldHVybiBkZXNjOyB9XG5cbmZ1bmN0aW9uIF9pbml0aWFsaXplcldhcm5pbmdIZWxwZXIoZGVzY3JpcHRvciwgY29udGV4dCkgeyB0aHJvdyBuZXcgRXJyb3IoJ0RlY29yYXRpbmcgY2xhc3MgcHJvcGVydHkgZmFpbGVkLiBQbGVhc2UgZW5zdXJlIHRoYXQgJyArICdwcm9wb3NhbC1jbGFzcy1wcm9wZXJ0aWVzIGlzIGVuYWJsZWQgYW5kIHJ1bnMgYWZ0ZXIgdGhlIGRlY29yYXRvcnMgdHJhbnNmb3JtLicpOyB9XG5cbi8vaW1wb3J0IHtQTEFURk9STX0gZnJvbSAnYXVyZWxpYS1wYWwnO1xuLy9AY3VzdG9tRWxlbWVudFxuLy9AdXNlVmlldyhQTEFURk9STS5tb2R1bGVOYW1lKCcuL2JkbC1jaGFydGpzLmh0bWwnKSlcbnZhciBDaGFydGpzVGltZSA9IChfZGVjID0gKDAsIF9hdXJlbGlhVGVtcGxhdGluZy51c2VWaWV3KSgnLi9jaGFydGpzLmh0bWwnKSwgX2RlYyhfY2xhc3MgPSAoX2NsYXNzMiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NoYXJ0anMpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ2hhcnRqc1RpbWUsIF9DaGFydGpzKTtcblxuICBmdW5jdGlvbiBDaGFydGpzVGltZSgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9DaGFydGpzLmNhbGwodGhpcykgfHwgdGhpczsgLy90aGlzLnR5cGUgPSAnbGluZSc7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJmcm9taWRcIiwgX2Rlc2NyaXB0b3IsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcImxhYmVsc1wiLCBfZGVzY3JpcHRvcjIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcInJlZmluZGV4XCIsIF9kZXNjcmlwdG9yMywgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicmVmdmFsdWVzXCIsIF9kZXNjcmlwdG9yNCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkoX3RoaXMsIFwidHlwZVwiLCBfZGVzY3JpcHRvcjUsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcIm1pblwiLCBfZGVzY3JpcHRvcjYsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcIm1heFwiLCBfZGVzY3JpcHRvcjcsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF90aGlzLmhhbmRsZVZhbHVlQ2hhbmdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vZS5kZXRhaWwgZG8gbm90IHJlYWxsb2NhdGUgLSB1c2luZyBzYW1lIGJ1ZmZlciwgdGh1cyBzbGljaW5nIHRvIGFwcGVuZCB0byBkYXRhIGFycmF5XG4gICAgICAvL2xldCBkYXRhcG9pbnRzID1lLmRldGFpbC5kYXRhLnNsaWNlKHRoaXMucmVmaW5kZXgsIHRoaXMucmVmZW5kaW5kZXgpO1xuICAgICAgdmFyIGogPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gX3RoaXMucmVmaW5kZXg7IGkgPCBfdGhpcy5yZWZpbmRleCArIF90aGlzLnJlZnZhbHVlczsgaSsrKSB7XG4gICAgICAgIC8vYWRkcyBkYXRhIHRvIGRhdGFzZXRzXG4gICAgICAgIC8vaWYgY29udmVydCBvcGVyYXRpb24gaXMgZGVmaW5lZCBhcyBhcnJheSB0aGVuIGNvbnZlcnRcbiAgICAgICAgaWYgKF90aGlzLm9wZXJhdGlvbiAmJiBfdGhpcy5vcGVyYXRpb25bal0pIF90aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbal0uZGF0YS5wdXNoKF90aGlzLm9wZXJhdGlvbltqXShlLmRldGFpbC5kYXRhW2ldKSk7IC8vZWxzZSBwdXNoIGRhdGEgZGlyZWN0bHlcbiAgICAgICAgZWxzZSBfdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2pdLmRhdGEucHVzaChlLmRldGFpbC5kYXRhW2ldKTtcblxuICAgICAgICBpZiAoX3RoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tqXS5kYXRhLmxlbmd0aCA+IF90aGlzLm1heGRhdGEpIHtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzaGlmdGluZyBkYXRhc2V0IGNoYXJ0anMtdGltZScsIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tqXS5kYXRhKTtcbiAgICAgICAgICBfdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2pdLmRhdGEuc2hpZnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGorKztcbiAgICAgIH1cblxuICAgICAgX3RoaXMuY2hhcnQuZGF0YS5sYWJlbHMucHVzaChlLmRldGFpbC50aW1lKTtcblxuICAgICAgaWYgKF90aGlzLmNoYXJ0LmRhdGEubGFiZWxzLmxlbmd0aCA+IF90aGlzLm1heGRhdGEpIHtcbiAgICAgICAgX3RoaXMuY2hhcnQuZGF0YS5sYWJlbHMuc2hpZnQoKTtcblxuICAgICAgICBpZiAoX3RoaXMuc2VjdGlvbmlkKSB7XG4gICAgICAgICAgLy9zaGlmdCBzZWN0aW9uc1xuICAgICAgICAgIGlmIChfdGhpcy5jaGFydC5jb25maWcub3B0aW9ucy5zZWN0aW9uWzBdLmluZGV4ID09PSAwKSBfdGhpcy5jaGFydC5jb25maWcub3B0aW9ucy5zZWN0aW9uLnNoaWZ0KCk7IC8vZGVjcmVtZW50IGFsbCBpbmRpY2VzIGluIHNlY3Rpb25zXG5cbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgX3RoaXMuY2hhcnQuY29uZmlnLm9wdGlvbnMuc2VjdGlvbi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIF90aGlzLmNoYXJ0LmNvbmZpZy5vcHRpb25zLnNlY3Rpb25bX2ldLmluZGV4IC09IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vc2hpZnQgLSByZW1vdmUgZmlyc3QgZWxlbWVudCBpZiBkYXRhIGlzIHRvbyBiaWdcbiAgICAgIC8vY29uc29sZS5sb2coJ2NoYXJ0anMgaGFuZGxldmFsdWVjaGFuZ2UoKSBjaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGEnLCB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YSk7XG5cblxuICAgICAgX3RoaXMuY2hhcnQudXBkYXRlKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogc2V0cyBhbGwgdGltLXNlcmllcyBzcGVjaWZpYyBvcHRpb25zIGZvciBjaGFydGpzXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IENoYXJ0anNUaW1lLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYmluZCA9IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgX0NoYXJ0anMucHJvdG90eXBlLmJpbmQuY2FsbCh0aGlzKTsgLy9kb25lIGluIHN1cGVyXG4gICAgLy90aGlzLmNobGFiZWxzID0gdGhpcy5sYWJlbHMuc3BsaXQoJywnKTsgLy9sYWJlbHMgZm9yIGVhY2ggZGF0YXNldFxuICAgIC8vdGhpcy5jb2xvcnMgPSBbXTtcblxuXG4gICAgdmFyIGRhdGFzZXRzID0gW107XG4gICAgdmFyIG15ZGF0YTEgPSB0aGlzLmluaXRpYWxkYXRhLnNwbGl0KCc7Jyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVmdmFsdWVzICsgMTsgaSsrKSB7XG4gICAgICAvL215ZGF0YVswXSA9PSB0aW1lbGFiZWxzIGluIHggYXhpcywgbXlkYXRhWzEuLm5dIGFyIGluIHkgYXhpc1xuICAgICAgdmFyIG15ZGF0YTIgPSBteWRhdGExW2ldID8gbXlkYXRhMVtpXS5zcGxpdCgnLCcpIDogW107XG4gICAgICB0aGlzLm15ZGF0YVtpXSA9IG15ZGF0YTIubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHgpO1xuICAgICAgfSk7IC8vY29uc29sZS5sb2coJ2NoYXJ0anN0aW1lIG15ZGF0YSBpJyx0aGlzLm15ZGF0YVtpXSk7XG4gICAgfSAvL2luaXRpYWxpemUgY29sb3JzIGZvciBlYWNoIGRhdGFzZXRcblxuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdGhpcy5yZWZ2YWx1ZXM7IF9pMisrKSB7XG4gICAgICAvL3RoaXMuY29sb3JzLnB1c2godGhpcy5zZWxlY3RDb2xvcihpKSk7XG4gICAgICBkYXRhc2V0cy5wdXNoKHtcbiAgICAgICAgZGF0YTogdGhpcy5teWRhdGFbX2kyICsgMV0sXG4gICAgICAgIGxhYmVsOiB0aGlzLmNobGFiZWxzW19pMl0sXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5zZWxlY3RDb2xvcihfaTIpLFxuICAgICAgICBib3JkZXJDb2xvcjogdGhpcy5zZWxlY3RDb2xvcihfaTIpLFxuICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgcG9pbnRSYWRpdXM6IDEsXG4gICAgICAgIGZpbGw6IGZhbHNlXG4gICAgICB9KTsgLy90aW1lbGFiZWxzLnB1c2goaSk7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhID0ge1xuICAgICAgbGFiZWxzOiB0aGlzLm15ZGF0YVswXSxcbiAgICAgIGRhdGFzZXRzOiBkYXRhc2V0c1xuICAgIH07XG4gICAgaWYgKHRoaXMudmVydGljYWxsaW5lKSB0aGlzLnR5cGUgPSAnTGluZVdpdGhMaW5lJztlbHNlIHRoaXMudHlwZSA9ICdsaW5lJztcblxuICAgIGlmICh0aGlzLm1pbikge1xuICAgICAgLy9zZXRzIHlzY2FsZSBtaW5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zKSB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNjYWxlcykgdGhpcy5vcHRpb25zLnNjYWxlcyA9IHt9O1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2NhbGVzLnlBeGVzKSB0aGlzLm9wdGlvbnMuc2NhbGVzLnlBeGVzID0gW3t9XTsgLy9jaGFydGpzIDIuOS40XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNjYWxlcy55QXhlc1swXS50aWNrcykgdGhpcy5vcHRpb25zLnNjYWxlcy55QXhlc1swXS50aWNrcyA9IHt9OyAvL2NoYXJ0anMgMi45LjRcblxuICAgICAgdGhpcy5vcHRpb25zLnNjYWxlcy55QXhlc1swXS50aWNrcy5taW4gPSBwYXJzZUZsb2F0KHRoaXMubWluKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXgpIHtcbiAgICAgIC8vc2V0cyB5c2NhbGUgbWF4XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucykgdGhpcy5vcHRpb25zID0ge307XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zY2FsZXMpIHRoaXMub3B0aW9ucy5zY2FsZXMgPSB7fTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNjYWxlcy55QXhlcykgdGhpcy5vcHRpb25zLnNjYWxlcy55QXhlcyA9IFt7fV07IC8vY2hhcnRqcyAyLjkuNFxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zY2FsZXMueUF4ZXNbMF0udGlja3MpIHRoaXMub3B0aW9ucy5zY2FsZXMueUF4ZXNbMF0udGlja3MgPSB7fTsgLy9jaGFydGpzIDIuOS40XG5cbiAgICAgIHRoaXMub3B0aW9ucy5zY2FsZXMueUF4ZXNbMF0udGlja3MubWF4ID0gcGFyc2VGbG9hdCh0aGlzLm1heCk7IC8vaWYgKHRoaXMubWluKSB0aGlzLm9wdGlvbnMuc2NhbGVzLnlBeGVzWzBdLnRpY2tzLnN0ZXBTaXplID0gKHRoaXMub3B0aW9ucy5zY2FsZXMueUF4ZXNbMF0udGlja3MubWF4IC0gdGhpcy5vcHRpb25zLnNjYWxlcy55QXhlc1swXS50aWNrcy5taW4pIC8gMTA7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZXNldGRhdGEgPSBmdW5jdGlvbiByZXNldGRhdGEoKSB7XG4gICAgLy9zdXBlci5yZXNldGRhdGEoKTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMucmVmdmFsdWVzOyBqKyspIHtcbiAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tqXS5kYXRhID0gW107XG4gICAgfVxuXG4gICAgdGhpcy5jaGFydC5kYXRhLmxhYmVscyA9IFtdO1xuICAgIHRoaXMuY2hhcnQudXBkYXRlKCk7XG4gIH07XG5cbiAgcmV0dXJuIENoYXJ0anNUaW1lO1xufShfY2hhcnRqcy5DaGFydGpzKSwgKF9kZXNjcmlwdG9yID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJmcm9taWRcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjIgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcImxhYmVsc1wiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMyA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwicmVmaW5kZXhcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjQgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcInJlZnZhbHVlc1wiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yNSA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwidHlwZVwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yNiA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwibWluXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I3ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJtYXhcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pKSwgX2NsYXNzMikpIHx8IF9jbGFzcyk7XG5leHBvcnRzLkNoYXJ0anNUaW1lID0gQ2hhcnRqc1RpbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFydGpzLXRpbWUuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-time\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-time.html":
/*!**********************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-time.html ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template><!-- not used, inherited from chartjs--></template>\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMtdGltZS5odG1sLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F1cmVsaWEtYm9keWxpZ2h0LXBsdWdpbi9kaXN0L25hdGl2ZS1tb2R1bGVzL2VsZW1lbnRzL2NoYXJ0anMtdGltZS5odG1sPzZjNzIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIjx0ZW1wbGF0ZT48IS0tIG5vdCB1c2VkLCBpbmhlcml0ZWQgZnJvbSBjaGFydGpzLS0+PC90ZW1wbGF0ZT5cXG5cIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-time.html\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-xy":
/*!******************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-xy.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.ChartjsXy = void 0;\n\nvar _chartjsTime = __webpack_require__(/*! ./chartjs-time */ \"aurelia-bodylight-plugin/elements/chartjs-time\");\n\nvar _aureliaTemplating = __webpack_require__(/*! aurelia-templating */ \"hij8\");\n\nvar _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5;\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\n//import {PLATFORM} from 'aurelia-pal';\n//@useView(PLATFORM.moduleName('./bdl-chartjs.html'))\nvar ChartjsXy = (_dec = (0, _aureliaTemplating.useView)('./chartjs.html'), _dec(_class = (_class2 = /*#__PURE__*/function (_ChartjsTime) {\n  _inheritsLoose(ChartjsXy, _ChartjsTime);\n\n  function ChartjsXy() {\n    var _this;\n\n    _this = _ChartjsTime.call(this) || this;\n\n    _initializerDefineProperty(_this, \"fromid\", _descriptor, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"labels\", _descriptor2, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"refindex\", _descriptor3, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"refvalues\", _descriptor4, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"type\", _descriptor5, _assertThisInitialized(_this));\n\n    _this.showlines = true;\n\n    _this.handleValueChange = function (e) {\n      //e.detail do not reallocate - using same buffer, thus slicing to append to data array\n      //let datapoints =e.detail.data.slice(this.refindex, this.refendindex);\n      var j = 0; //put first value on x axis, others on y axis other values\n\n      for (var i = _this.refindex + 1; i < _this.refindex + _this.refvalues; i++) {\n        _this.chart.data.datasets[j].data.push({\n          x: e.detail.data[_this.refindex],\n          y: e.detail.data[i]\n        }); //console.log('adding from data[], i, data[i]', e.detail.data, i, e.detail.data[i]);\n\n\n        if (_this.chart.data.datasets[j].data.length > _this.maxdata) {\n          //console.log('shifting dataset chartjs-xy', this.chart.data.datasets[j].data);\n          _this.chart.data.datasets[j].data.shift();\n        }\n\n        j++;\n      } //console.log('chartjs-xy handlevaluechange datasets, e.detail.data',this.chart.data.datasets, e.detail.data);\n\n\n      _this.chart.update();\n    };\n\n    return _this;\n  }\n\n  var _proto = ChartjsXy.prototype;\n\n  _proto.bind = function bind() {\n    var _this2 = this;\n\n    _ChartjsTime.prototype.bind.call(this);\n\n    var datasets = [];\n    var mydata1 = this.initialdata.split(';'); //initialize x and y, x is first dataset, y is al the rest\n\n    this.mydata = [];\n\n    for (var i = 0; i < this.refvalues; i++) {\n      var mydata2 = mydata1[i] ? mydata1[i].split(',') : [];\n\n      if (i === 0) {\n        //parse x\n        this.mydata[0] = mydata2.map(function (x, index) {\n          return parseFloat(x);\n        });\n      } else {\n        //parse all y\n        this.mydata[i] = mydata2.map(function (yy, index) {\n          return {\n            x: _this2.mydata[0][index],\n            y: parseFloat(yy)\n          };\n        });\n      }\n    } //this.colors already set in super()\n\n\n    for (var _i = 1; _i < this.refvalues; _i++) {\n      datasets.push({\n        data: this.mydata[_i],\n        label: this.chlabels[_i],\n        backgroundColor: this.colors[_i - 1],\n        borderColor: this.colors[_i - 1],\n        fill: false,\n        showLine: this.showlines,\n        borderWidth: 1,\n        refvalues: this.refvalues\n      });\n    } //add additional data, all after ; is taken as x values separated by , of initial curve,\n    // after ; is y values of initial curve separated by ,\n    // if more curves then another ;. E.g. initialdata=\";;0,0.00015;0,28000;0,0.00015;0,1400\"\n    // -> line from 0 0 to 0.0015 28000 and from 0 0 to 00015 1400\n\n\n    if (mydata1.length > this.refvalues) {\n      var j = this.refvalues;\n\n      var _loop = function _loop(_i2) {\n        var mydata2 = mydata1[_i2].split(',');\n\n        var mydata3 = mydata1[_i2 + 1].split(',');\n\n        _this2.mydata[j] = mydata3.map(function (yy, index) {\n          return {\n            x: parseFloat(mydata2[index]),\n            y: parseFloat(yy)\n          };\n        });\n        datasets.push({\n          data: _this2.mydata[j],\n          backgroundColor: _this2.selectColor(_i2),\n          borderColor: _this2.selectColor(_i2),\n          fill: false,\n          showLine: _this2.showlines\n        });\n        j++;\n      };\n\n      for (var _i2 = this.refvalues; _i2 < mydata1.length; _i2 += 2) {\n        _loop(_i2);\n      }\n    }\n\n    this.data = {\n      datasets: datasets\n    };\n    this.type = 'scatter';\n    this.options.tooltips.mode = 'nearest';\n    this.options.elements = {\n      point: {\n        radius: this.customRadius,\n        display: true\n      }\n    };\n  };\n\n  _proto.customRadius = function customRadius(context) {\n    var last = context.dataIndex === context.dataset.data.length - 1;\n    var inrefvalues = context.datasetIndex < context.dataset.refvalues; //dataset is in refvalues - changed by simulator\n\n    if (inrefvalues) return last ? 3 : 1;\n    return 1; //dataset is fixed - background borders\n  };\n\n  _proto.resetdata = function resetdata() {\n    var j = 0;\n\n    for (var i = this.refindex + 1; i < this.refindex + this.refvalues; i++) {\n      this.chart.data.datasets[j].data = [];\n      j++;\n    }\n  };\n\n  return ChartjsXy;\n}(_chartjsTime.ChartjsTime), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"fromid\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"labels\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, \"refindex\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, \"refvalues\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, \"type\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);\nexports.ChartjsXy = ChartjsXy;\n//# sourceMappingURL=chartjs-xy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMteHkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2Rpc3QvbmF0aXZlLW1vZHVsZXMvZWxlbWVudHMvY2hhcnRqcy14eS5qcz84OGMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5DaGFydGpzWHkgPSB2b2lkIDA7XG5cbnZhciBfY2hhcnRqc1RpbWUgPSByZXF1aXJlKFwiLi9jaGFydGpzLXRpbWVcIik7XG5cbnZhciBfYXVyZWxpYVRlbXBsYXRpbmcgPSByZXF1aXJlKFwiYXVyZWxpYS10ZW1wbGF0aW5nXCIpO1xuXG52YXIgX2RlYywgX2NsYXNzLCBfY2xhc3MyLCBfZGVzY3JpcHRvciwgX2Rlc2NyaXB0b3IyLCBfZGVzY3JpcHRvcjMsIF9kZXNjcmlwdG9yNCwgX2Rlc2NyaXB0b3I1O1xuXG5mdW5jdGlvbiBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7IGlmICghZGVzY3JpcHRvcikgcmV0dXJuOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgeyBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsIHdyaXRhYmxlOiBkZXNjcmlwdG9yLndyaXRhYmxlLCB2YWx1ZTogZGVzY3JpcHRvci5pbml0aWFsaXplciA/IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMCB9KTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVjb3JhdG9ycywgZGVzY3JpcHRvciwgY29udGV4dCkgeyB2YXIgZGVzYyA9IHt9OyBPYmplY3Qua2V5cyhkZXNjcmlwdG9yKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZGVzY1trZXldID0gZGVzY3JpcHRvcltrZXldOyB9KTsgZGVzYy5lbnVtZXJhYmxlID0gISFkZXNjLmVudW1lcmFibGU7IGRlc2MuY29uZmlndXJhYmxlID0gISFkZXNjLmNvbmZpZ3VyYWJsZTsgaWYgKCd2YWx1ZScgaW4gZGVzYyB8fCBkZXNjLmluaXRpYWxpemVyKSB7IGRlc2Mud3JpdGFibGUgPSB0cnVlOyB9IGRlc2MgPSBkZWNvcmF0b3JzLnNsaWNlKCkucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbiAoZGVzYywgZGVjb3JhdG9yKSB7IHJldHVybiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYykgfHwgZGVzYzsgfSwgZGVzYyk7IGlmIChjb250ZXh0ICYmIGRlc2MuaW5pdGlhbGl6ZXIgIT09IHZvaWQgMCkgeyBkZXNjLnZhbHVlID0gZGVzYy5pbml0aWFsaXplciA/IGRlc2MuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMDsgZGVzYy5pbml0aWFsaXplciA9IHVuZGVmaW5lZDsgfSBpZiAoZGVzYy5pbml0aWFsaXplciA9PT0gdm9pZCAwKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjKTsgZGVzYyA9IG51bGw7IH0gcmV0dXJuIGRlc2M7IH1cblxuZnVuY3Rpb24gX2luaXRpYWxpemVyV2FybmluZ0hlbHBlcihkZXNjcmlwdG9yLCBjb250ZXh0KSB7IHRocm93IG5ldyBFcnJvcignRGVjb3JhdGluZyBjbGFzcyBwcm9wZXJ0eSBmYWlsZWQuIFBsZWFzZSBlbnN1cmUgdGhhdCAnICsgJ3Byb3Bvc2FsLWNsYXNzLXByb3BlcnRpZXMgaXMgZW5hYmxlZCBhbmQgcnVucyBhZnRlciB0aGUgZGVjb3JhdG9ycyB0cmFuc2Zvcm0uJyk7IH1cblxuLy9pbXBvcnQge1BMQVRGT1JNfSBmcm9tICdhdXJlbGlhLXBhbCc7XG4vL0B1c2VWaWV3KFBMQVRGT1JNLm1vZHVsZU5hbWUoJy4vYmRsLWNoYXJ0anMuaHRtbCcpKVxudmFyIENoYXJ0anNYeSA9IChfZGVjID0gKDAsIF9hdXJlbGlhVGVtcGxhdGluZy51c2VWaWV3KSgnLi9jaGFydGpzLmh0bWwnKSwgX2RlYyhfY2xhc3MgPSAoX2NsYXNzMiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NoYXJ0anNUaW1lKSB7XG4gIF9pbmhlcml0c0xvb3NlKENoYXJ0anNYeSwgX0NoYXJ0anNUaW1lKTtcblxuICBmdW5jdGlvbiBDaGFydGpzWHkoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQ2hhcnRqc1RpbWUuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZnJvbWlkXCIsIF9kZXNjcmlwdG9yLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJsYWJlbHNcIiwgX2Rlc2NyaXB0b3IyLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJyZWZpbmRleFwiLCBfZGVzY3JpcHRvcjMsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcInJlZnZhbHVlc1wiLCBfZGVzY3JpcHRvcjQsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcInR5cGVcIiwgX2Rlc2NyaXB0b3I1LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICBfdGhpcy5zaG93bGluZXMgPSB0cnVlO1xuXG4gICAgX3RoaXMuaGFuZGxlVmFsdWVDaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgLy9lLmRldGFpbCBkbyBub3QgcmVhbGxvY2F0ZSAtIHVzaW5nIHNhbWUgYnVmZmVyLCB0aHVzIHNsaWNpbmcgdG8gYXBwZW5kIHRvIGRhdGEgYXJyYXlcbiAgICAgIC8vbGV0IGRhdGFwb2ludHMgPWUuZGV0YWlsLmRhdGEuc2xpY2UodGhpcy5yZWZpbmRleCwgdGhpcy5yZWZlbmRpbmRleCk7XG4gICAgICB2YXIgaiA9IDA7IC8vcHV0IGZpcnN0IHZhbHVlIG9uIHggYXhpcywgb3RoZXJzIG9uIHkgYXhpcyBvdGhlciB2YWx1ZXNcblxuICAgICAgZm9yICh2YXIgaSA9IF90aGlzLnJlZmluZGV4ICsgMTsgaSA8IF90aGlzLnJlZmluZGV4ICsgX3RoaXMucmVmdmFsdWVzOyBpKyspIHtcbiAgICAgICAgX3RoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tqXS5kYXRhLnB1c2goe1xuICAgICAgICAgIHg6IGUuZGV0YWlsLmRhdGFbX3RoaXMucmVmaW5kZXhdLFxuICAgICAgICAgIHk6IGUuZGV0YWlsLmRhdGFbaV1cbiAgICAgICAgfSk7IC8vY29uc29sZS5sb2coJ2FkZGluZyBmcm9tIGRhdGFbXSwgaSwgZGF0YVtpXScsIGUuZGV0YWlsLmRhdGEsIGksIGUuZGV0YWlsLmRhdGFbaV0pO1xuXG5cbiAgICAgICAgaWYgKF90aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbal0uZGF0YS5sZW5ndGggPiBfdGhpcy5tYXhkYXRhKSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZygnc2hpZnRpbmcgZGF0YXNldCBjaGFydGpzLXh5JywgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2pdLmRhdGEpO1xuICAgICAgICAgIF90aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbal0uZGF0YS5zaGlmdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaisrO1xuICAgICAgfSAvL2NvbnNvbGUubG9nKCdjaGFydGpzLXh5IGhhbmRsZXZhbHVlY2hhbmdlIGRhdGFzZXRzLCBlLmRldGFpbC5kYXRhJyx0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMsIGUuZGV0YWlsLmRhdGEpO1xuXG5cbiAgICAgIF90aGlzLmNoYXJ0LnVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ2hhcnRqc1h5LnByb3RvdHlwZTtcblxuICBfcHJvdG8uYmluZCA9IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBfQ2hhcnRqc1RpbWUucHJvdG90eXBlLmJpbmQuY2FsbCh0aGlzKTtcblxuICAgIHZhciBkYXRhc2V0cyA9IFtdO1xuICAgIHZhciBteWRhdGExID0gdGhpcy5pbml0aWFsZGF0YS5zcGxpdCgnOycpOyAvL2luaXRpYWxpemUgeCBhbmQgeSwgeCBpcyBmaXJzdCBkYXRhc2V0LCB5IGlzIGFsIHRoZSByZXN0XG5cbiAgICB0aGlzLm15ZGF0YSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZnZhbHVlczsgaSsrKSB7XG4gICAgICB2YXIgbXlkYXRhMiA9IG15ZGF0YTFbaV0gPyBteWRhdGExW2ldLnNwbGl0KCcsJykgOiBbXTtcblxuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgLy9wYXJzZSB4XG4gICAgICAgIHRoaXMubXlkYXRhWzBdID0gbXlkYXRhMi5tYXAoZnVuY3Rpb24gKHgsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoeCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9wYXJzZSBhbGwgeVxuICAgICAgICB0aGlzLm15ZGF0YVtpXSA9IG15ZGF0YTIubWFwKGZ1bmN0aW9uICh5eSwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogX3RoaXMyLm15ZGF0YVswXVtpbmRleF0sXG4gICAgICAgICAgICB5OiBwYXJzZUZsb2F0KHl5KVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gLy90aGlzLmNvbG9ycyBhbHJlYWR5IHNldCBpbiBzdXBlcigpXG5cblxuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCB0aGlzLnJlZnZhbHVlczsgX2krKykge1xuICAgICAgZGF0YXNldHMucHVzaCh7XG4gICAgICAgIGRhdGE6IHRoaXMubXlkYXRhW19pXSxcbiAgICAgICAgbGFiZWw6IHRoaXMuY2hsYWJlbHNbX2ldLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuY29sb3JzW19pIC0gMV0sXG4gICAgICAgIGJvcmRlckNvbG9yOiB0aGlzLmNvbG9yc1tfaSAtIDFdLFxuICAgICAgICBmaWxsOiBmYWxzZSxcbiAgICAgICAgc2hvd0xpbmU6IHRoaXMuc2hvd2xpbmVzLFxuICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgcmVmdmFsdWVzOiB0aGlzLnJlZnZhbHVlc1xuICAgICAgfSk7XG4gICAgfSAvL2FkZCBhZGRpdGlvbmFsIGRhdGEsIGFsbCBhZnRlciA7IGlzIHRha2VuIGFzIHggdmFsdWVzIHNlcGFyYXRlZCBieSAsIG9mIGluaXRpYWwgY3VydmUsXG4gICAgLy8gYWZ0ZXIgOyBpcyB5IHZhbHVlcyBvZiBpbml0aWFsIGN1cnZlIHNlcGFyYXRlZCBieSAsXG4gICAgLy8gaWYgbW9yZSBjdXJ2ZXMgdGhlbiBhbm90aGVyIDsuIEUuZy4gaW5pdGlhbGRhdGE9XCI7OzAsMC4wMDAxNTswLDI4MDAwOzAsMC4wMDAxNTswLDE0MDBcIlxuICAgIC8vIC0+IGxpbmUgZnJvbSAwIDAgdG8gMC4wMDE1IDI4MDAwIGFuZCBmcm9tIDAgMCB0byAwMDAxNSAxNDAwXG5cblxuICAgIGlmIChteWRhdGExLmxlbmd0aCA+IHRoaXMucmVmdmFsdWVzKSB7XG4gICAgICB2YXIgaiA9IHRoaXMucmVmdmFsdWVzO1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaTIpIHtcbiAgICAgICAgdmFyIG15ZGF0YTIgPSBteWRhdGExW19pMl0uc3BsaXQoJywnKTtcblxuICAgICAgICB2YXIgbXlkYXRhMyA9IG15ZGF0YTFbX2kyICsgMV0uc3BsaXQoJywnKTtcblxuICAgICAgICBfdGhpczIubXlkYXRhW2pdID0gbXlkYXRhMy5tYXAoZnVuY3Rpb24gKHl5LCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBwYXJzZUZsb2F0KG15ZGF0YTJbaW5kZXhdKSxcbiAgICAgICAgICAgIHk6IHBhcnNlRmxvYXQoeXkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRhdGFzZXRzLnB1c2goe1xuICAgICAgICAgIGRhdGE6IF90aGlzMi5teWRhdGFbal0sXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBfdGhpczIuc2VsZWN0Q29sb3IoX2kyKSxcbiAgICAgICAgICBib3JkZXJDb2xvcjogX3RoaXMyLnNlbGVjdENvbG9yKF9pMiksXG4gICAgICAgICAgZmlsbDogZmFsc2UsXG4gICAgICAgICAgc2hvd0xpbmU6IF90aGlzMi5zaG93bGluZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGorKztcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IHRoaXMucmVmdmFsdWVzOyBfaTIgPCBteWRhdGExLmxlbmd0aDsgX2kyICs9IDIpIHtcbiAgICAgICAgX2xvb3AoX2kyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRhdGEgPSB7XG4gICAgICBkYXRhc2V0czogZGF0YXNldHNcbiAgICB9O1xuICAgIHRoaXMudHlwZSA9ICdzY2F0dGVyJztcbiAgICB0aGlzLm9wdGlvbnMudG9vbHRpcHMubW9kZSA9ICduZWFyZXN0JztcbiAgICB0aGlzLm9wdGlvbnMuZWxlbWVudHMgPSB7XG4gICAgICBwb2ludDoge1xuICAgICAgICByYWRpdXM6IHRoaXMuY3VzdG9tUmFkaXVzLFxuICAgICAgICBkaXNwbGF5OiB0cnVlXG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uY3VzdG9tUmFkaXVzID0gZnVuY3Rpb24gY3VzdG9tUmFkaXVzKGNvbnRleHQpIHtcbiAgICB2YXIgbGFzdCA9IGNvbnRleHQuZGF0YUluZGV4ID09PSBjb250ZXh0LmRhdGFzZXQuZGF0YS5sZW5ndGggLSAxO1xuICAgIHZhciBpbnJlZnZhbHVlcyA9IGNvbnRleHQuZGF0YXNldEluZGV4IDwgY29udGV4dC5kYXRhc2V0LnJlZnZhbHVlczsgLy9kYXRhc2V0IGlzIGluIHJlZnZhbHVlcyAtIGNoYW5nZWQgYnkgc2ltdWxhdG9yXG5cbiAgICBpZiAoaW5yZWZ2YWx1ZXMpIHJldHVybiBsYXN0ID8gMyA6IDE7XG4gICAgcmV0dXJuIDE7IC8vZGF0YXNldCBpcyBmaXhlZCAtIGJhY2tncm91bmQgYm9yZGVyc1xuICB9O1xuXG4gIF9wcm90by5yZXNldGRhdGEgPSBmdW5jdGlvbiByZXNldGRhdGEoKSB7XG4gICAgdmFyIGogPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IHRoaXMucmVmaW5kZXggKyAxOyBpIDwgdGhpcy5yZWZpbmRleCArIHRoaXMucmVmdmFsdWVzOyBpKyspIHtcbiAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tqXS5kYXRhID0gW107XG4gICAgICBqKys7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDaGFydGpzWHk7XG59KF9jaGFydGpzVGltZS5DaGFydGpzVGltZSksIChfZGVzY3JpcHRvciA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwiZnJvbWlkXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3IyID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJsYWJlbHNcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjMgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcInJlZmluZGV4XCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I0ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJyZWZ2YWx1ZXNcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjUgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcInR5cGVcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pKSwgX2NsYXNzMikpIHx8IF9jbGFzcyk7XG5leHBvcnRzLkNoYXJ0anNYeSA9IENoYXJ0anNYeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYXJ0anMteHkuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-xy\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-xy-points":
/*!*************************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-xy-points.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.ChartjsXyPoints = void 0;\n\nvar _chartjsXy = __webpack_require__(/*! ./chartjs-xy */ \"aurelia-bodylight-plugin/elements/chartjs-xy\");\n\nvar _aureliaTemplating = __webpack_require__(/*! aurelia-templating */ \"hij8\");\n\nvar _chart = _interopRequireDefault(__webpack_require__(/*! chart.js */ \"MO+k\"));\n\nvar _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\n//import {PLATFORM} from 'aurelia-pal';\n//@useView(PLATFORM.moduleName('./bdl-chartjs.html'))\n//modified simple implementation of throttle from https://jsfiddle.net/jonathansampson/m7G64/\nfunction throttle(callback, limit) {\n  var wait = false; // Initially, we're not waiting\n\n  return function () {\n    // We return a throttled function\n    if (!wait) {\n      // If we're not waiting\n      callback.call(); // Execute users function\n\n      wait = true; // Prevent future invocations\n\n      setTimeout(function () {\n        // After a period of time\n        wait = false; // And allow future invocations\n      }, limit);\n    }\n  };\n}\n\nvar ChartjsXyPoints = (_dec = (0, _aureliaTemplating.useView)('./chartjs-xy-points.html'), _dec(_class = (_class2 = /*#__PURE__*/function (_ChartjsXy) {\n  _inheritsLoose(ChartjsXyPoints, _ChartjsXy);\n\n  function ChartjsXyPoints() {\n    var _this;\n\n    _this = _ChartjsXy.call(this) || this;\n\n    _initializerDefineProperty(_this, \"fromid\", _descriptor, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"labels\", _descriptor2, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"refindex\", _descriptor3, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"refvalues\", _descriptor4, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"min\", _descriptor5, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"max\", _descriptor6, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"xmin\", _descriptor7, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"xmax\", _descriptor8, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"atitle\", _descriptor9, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"rtitle\", _descriptor10, _assertThisInitialized(_this));\n\n    _this.showlines = false;\n\n    _initializerDefineProperty(_this, \"convertors\", _descriptor11, _assertThisInitialized(_this));\n\n    _this.index = 0;\n\n    _this.handleValueChange = function (e) {\n      //e.detail do not reallocate - using same buffer, thus slicing to append to data array\n      var rawdata = e.detail.data.slice(_this.refindex, _this.refendindex); //do value conversion based on convertors\n\n      if (_this.operation) {\n        for (var i = 0; i < rawdata.length; i++) {\n          //if particular operation is defined\n          if (_this.operation[i]) rawdata[i] = _this.operation[i](rawdata[i]);\n        }\n      }\n\n      var j = 0; //put each first value on x axis, second on y axis\n\n      for (var _i = 1; _i < _this.refvalues; _i = _i + 2) {\n        //remember only current x,y value - on the index\n        _this.chart.data.datasets[j].data[_this.index] = {\n          x: rawdata[_i - 1],\n          y: rawdata[_i]\n        }; //increment dataset - if more dataset are available\n\n        j++;\n      } //throttle - update values every 1 s only\n\n\n      throttle(_this.chart.update(), 1000);\n    };\n\n    return _this;\n  }\n\n  var _proto = ChartjsXyPoints.prototype;\n\n  _proto.bind = function bind() {\n    _ChartjsXy.prototype.bind.call(this);\n\n    console.log('chartjs xy point bind()');\n\n    if (this.xmin) {\n      //sets yscale min\n      if (!this.options) this.options = {};\n      if (!this.options.scales) this.options.scales = {};\n      if (!this.options.scales.xAxes) this.options.scales.xAxes = [{}]; //chartjs 2.9.4\n\n      if (!this.options.scales.xAxes[0].ticks) this.options.scales.xAxes[0].ticks = {}; //chartjs 2.9.4\n\n      this.options.scales.xAxes[0].ticks.min = parseFloat(this.xmin);\n    }\n\n    if (this.xmax) {\n      //sets yscale max\n      if (!this.options) this.options = {};\n      if (!this.options.scales) this.options.scales = {};\n      if (!this.options.scales.xAxes) this.options.scales.xAxes = [{}]; //chartjs 2.9.4\n\n      if (!this.options.scales.xAxes[0].ticks) this.options.scales.xAxes[0].ticks = {}; //chartjs 2.9.4\n\n      this.options.scales.xAxes[0].ticks.max = parseFloat(this.xmax); //if (this.min) this.options.scales.yAxes[0].ticks.stepSize = (this.options.scales.yAxes[0].ticks.max - this.options.scales.yAxes[0].ticks.min) / 10;\n    } //customize tooltip display\n\n\n    this.options.tooltips.callbacks = {\n      label: function label(tooltipItem, data) {\n        var label = data.datasets[tooltipItem.datasetIndex].label || '';\n\n        if (label) {\n          label += ': ';\n        }\n\n        label += '(' + tooltipItem.xLabel.toPrecision(3) + ',' + tooltipItem.yLabel.toPrecision(3) + ')';\n        return label;\n      },\n      footer: function footer(tooltipItem, data) {\n        if (data.datasets.length < 2) return tooltipItem[0].yLabel;\n        var label = []; //label.push('| ' + data.datasets[0].data[tooltipItem[0].index].y.toPrecision(3) + ' - ' + data.datasets[1].data[tooltipItem[0].index].y.toPrecision(3) + ' |');\n\n        label.push('Δ ' + Math.abs(data.datasets[0].data[tooltipItem[0].index].y - data.datasets[1].data[tooltipItem[0].index].y).toPrecision(3));\n        return label;\n      }\n    };\n    this.type = 'scatter';\n    this.plugins = null;\n    this.options.XYPlugin = true;\n  };\n\n  _proto.attached = function attached() {\n    //register horizontal line drawing, shows difference line between appropriate points from dataset0 and dataset1\n    _chart.default.pluginService.register({\n      beforeDraw: function beforeDraw(chart, ease) {\n        if (chart.config.options.XYPlugin && chart.tooltip._active && chart.tooltip._active.length) {\n          var activePoint = chart.tooltip._active[0]; //console.log('chart horizontal line debug chart activepoint:', activePoint);\n\n          var ctx = chart.ctx;\n          var y = activePoint.tooltipPosition().y; //let topY = this.chart.legend.bottom;\n\n          var leftX = chart.chartArea.left; //let bottomY = this.chart.chartArea.bottom;\n\n          var rightX = chart.chartArea.right; // draw line\n\n          ctx.save();\n          ctx.beginPath();\n          ctx.moveTo(leftX, y);\n          ctx.lineTo(rightX, y);\n          ctx.lineWidth = 1;\n          ctx.strokeStyle = '#ff9c9c';\n          ctx.stroke();\n          var meta1 = chart.getDatasetMeta(0);\n          var meta2 = chart.getDatasetMeta(1);\n\n          if (meta1) {\n            //draw second line\n            //console.log('plugin meta', chart, meta);\n            var secondy2 = meta1.data[activePoint._index]._model.y;\n            var secondy = secondy2 !== y ? secondy2 : meta2.data[activePoint._index]._model.y; //let stop  = meta.data[chart.config.options.section[i].index]._model.x;\n\n            ctx.beginPath();\n            ctx.moveTo(leftX, secondy);\n            ctx.lineTo(rightX, secondy);\n            ctx.lineWidth = 1;\n            ctx.strokeStyle = '#ff9c9c';\n            ctx.stroke();\n            var x = activePoint.tooltipPosition().x;\n            ctx.beginPath();\n            ctx.moveTo(x, y);\n            var sy = y > secondy ? 3 : -3; //small arrow up\n\n            ctx.lineTo(x - sy, y - sy);\n            ctx.lineTo(x + sy, y - sy); //line\n\n            ctx.lineTo(x, y);\n            ctx.lineTo(x, secondy); //small arrow down\n\n            ctx.lineTo(x - sy, secondy + sy);\n            ctx.lineTo(x + sy, secondy + sy);\n            ctx.lineTo(x, secondy);\n            ctx.lineWidth = 1;\n            ctx.strokeStyle = '#7b7bff';\n            ctx.stroke();\n          }\n\n          ctx.restore();\n        }\n      }\n    });\n\n    _ChartjsXy.prototype.attached.call(this);\n  };\n\n  _proto.addpoint = function addpoint() {\n    this.index++;\n  };\n\n  _proto.removepoint = function removepoint() {\n    if (this.index > 0) this.index--;\n  };\n\n  return ChartjsXyPoints;\n}(_chartjsXy.ChartjsXy), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"fromid\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"labels\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, \"refindex\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, \"refvalues\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, \"min\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, \"max\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, \"xmin\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, \"xmax\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, \"atitle\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 'Add Point';\n  }\n}), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, \"rtitle\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 'Remove Point';\n  }\n}), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, \"convertors\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);\nexports.ChartjsXyPoints = ChartjsXyPoints;\n//# sourceMappingURL=chartjs-xy-points.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMteHktcG9pbnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F1cmVsaWEtYm9keWxpZ2h0LXBsdWdpbi9kaXN0L25hdGl2ZS1tb2R1bGVzL2VsZW1lbnRzL2NoYXJ0anMteHktcG9pbnRzLmpzP2M2YjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkNoYXJ0anNYeVBvaW50cyA9IHZvaWQgMDtcblxudmFyIF9jaGFydGpzWHkgPSByZXF1aXJlKFwiLi9jaGFydGpzLXh5XCIpO1xuXG52YXIgX2F1cmVsaWFUZW1wbGF0aW5nID0gcmVxdWlyZShcImF1cmVsaWEtdGVtcGxhdGluZ1wiKTtcblxudmFyIF9jaGFydCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNoYXJ0LmpzXCIpKTtcblxudmFyIF9kZWMsIF9jbGFzcywgX2NsYXNzMiwgX2Rlc2NyaXB0b3IsIF9kZXNjcmlwdG9yMiwgX2Rlc2NyaXB0b3IzLCBfZGVzY3JpcHRvcjQsIF9kZXNjcmlwdG9yNSwgX2Rlc2NyaXB0b3I2LCBfZGVzY3JpcHRvcjcsIF9kZXNjcmlwdG9yOCwgX2Rlc2NyaXB0b3I5LCBfZGVzY3JpcHRvcjEwLCBfZGVzY3JpcHRvcjExO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7IGlmICghZGVzY3JpcHRvcikgcmV0dXJuOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgeyBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsIHdyaXRhYmxlOiBkZXNjcmlwdG9yLndyaXRhYmxlLCB2YWx1ZTogZGVzY3JpcHRvci5pbml0aWFsaXplciA/IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMCB9KTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVjb3JhdG9ycywgZGVzY3JpcHRvciwgY29udGV4dCkgeyB2YXIgZGVzYyA9IHt9OyBPYmplY3Qua2V5cyhkZXNjcmlwdG9yKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZGVzY1trZXldID0gZGVzY3JpcHRvcltrZXldOyB9KTsgZGVzYy5lbnVtZXJhYmxlID0gISFkZXNjLmVudW1lcmFibGU7IGRlc2MuY29uZmlndXJhYmxlID0gISFkZXNjLmNvbmZpZ3VyYWJsZTsgaWYgKCd2YWx1ZScgaW4gZGVzYyB8fCBkZXNjLmluaXRpYWxpemVyKSB7IGRlc2Mud3JpdGFibGUgPSB0cnVlOyB9IGRlc2MgPSBkZWNvcmF0b3JzLnNsaWNlKCkucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbiAoZGVzYywgZGVjb3JhdG9yKSB7IHJldHVybiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYykgfHwgZGVzYzsgfSwgZGVzYyk7IGlmIChjb250ZXh0ICYmIGRlc2MuaW5pdGlhbGl6ZXIgIT09IHZvaWQgMCkgeyBkZXNjLnZhbHVlID0gZGVzYy5pbml0aWFsaXplciA/IGRlc2MuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMDsgZGVzYy5pbml0aWFsaXplciA9IHVuZGVmaW5lZDsgfSBpZiAoZGVzYy5pbml0aWFsaXplciA9PT0gdm9pZCAwKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjKTsgZGVzYyA9IG51bGw7IH0gcmV0dXJuIGRlc2M7IH1cblxuZnVuY3Rpb24gX2luaXRpYWxpemVyV2FybmluZ0hlbHBlcihkZXNjcmlwdG9yLCBjb250ZXh0KSB7IHRocm93IG5ldyBFcnJvcignRGVjb3JhdGluZyBjbGFzcyBwcm9wZXJ0eSBmYWlsZWQuIFBsZWFzZSBlbnN1cmUgdGhhdCAnICsgJ3Byb3Bvc2FsLWNsYXNzLXByb3BlcnRpZXMgaXMgZW5hYmxlZCBhbmQgcnVucyBhZnRlciB0aGUgZGVjb3JhdG9ycyB0cmFuc2Zvcm0uJyk7IH1cblxuLy9pbXBvcnQge1BMQVRGT1JNfSBmcm9tICdhdXJlbGlhLXBhbCc7XG4vL0B1c2VWaWV3KFBMQVRGT1JNLm1vZHVsZU5hbWUoJy4vYmRsLWNoYXJ0anMuaHRtbCcpKVxuLy9tb2RpZmllZCBzaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgdGhyb3R0bGUgZnJvbSBodHRwczovL2pzZmlkZGxlLm5ldC9qb25hdGhhbnNhbXBzb24vbTdHNjQvXG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjaywgbGltaXQpIHtcbiAgdmFyIHdhaXQgPSBmYWxzZTsgLy8gSW5pdGlhbGx5LCB3ZSdyZSBub3Qgd2FpdGluZ1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gV2UgcmV0dXJuIGEgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gICAgaWYgKCF3YWl0KSB7XG4gICAgICAvLyBJZiB3ZSdyZSBub3Qgd2FpdGluZ1xuICAgICAgY2FsbGJhY2suY2FsbCgpOyAvLyBFeGVjdXRlIHVzZXJzIGZ1bmN0aW9uXG5cbiAgICAgIHdhaXQgPSB0cnVlOyAvLyBQcmV2ZW50IGZ1dHVyZSBpbnZvY2F0aW9uc1xuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQWZ0ZXIgYSBwZXJpb2Qgb2YgdGltZVxuICAgICAgICB3YWl0ID0gZmFsc2U7IC8vIEFuZCBhbGxvdyBmdXR1cmUgaW52b2NhdGlvbnNcbiAgICAgIH0sIGxpbWl0KTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBDaGFydGpzWHlQb2ludHMgPSAoX2RlYyA9ICgwLCBfYXVyZWxpYVRlbXBsYXRpbmcudXNlVmlldykoJy4vY2hhcnRqcy14eS1wb2ludHMuaHRtbCcpLCBfZGVjKF9jbGFzcyA9IChfY2xhc3MyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ2hhcnRqc1h5KSB7XG4gIF9pbmhlcml0c0xvb3NlKENoYXJ0anNYeVBvaW50cywgX0NoYXJ0anNYeSk7XG5cbiAgZnVuY3Rpb24gQ2hhcnRqc1h5UG9pbnRzKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0NoYXJ0anNYeS5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJmcm9taWRcIiwgX2Rlc2NyaXB0b3IsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcImxhYmVsc1wiLCBfZGVzY3JpcHRvcjIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcInJlZmluZGV4XCIsIF9kZXNjcmlwdG9yMywgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicmVmdmFsdWVzXCIsIF9kZXNjcmlwdG9yNCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibWluXCIsIF9kZXNjcmlwdG9yNSwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibWF4XCIsIF9kZXNjcmlwdG9yNiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkoX3RoaXMsIFwieG1pblwiLCBfZGVzY3JpcHRvcjcsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcInhtYXhcIiwgX2Rlc2NyaXB0b3I4LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJhdGl0bGVcIiwgX2Rlc2NyaXB0b3I5LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJydGl0bGVcIiwgX2Rlc2NyaXB0b3IxMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX3RoaXMuc2hvd2xpbmVzID0gZmFsc2U7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJjb252ZXJ0b3JzXCIsIF9kZXNjcmlwdG9yMTEsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF90aGlzLmluZGV4ID0gMDtcblxuICAgIF90aGlzLmhhbmRsZVZhbHVlQ2hhbmdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vZS5kZXRhaWwgZG8gbm90IHJlYWxsb2NhdGUgLSB1c2luZyBzYW1lIGJ1ZmZlciwgdGh1cyBzbGljaW5nIHRvIGFwcGVuZCB0byBkYXRhIGFycmF5XG4gICAgICB2YXIgcmF3ZGF0YSA9IGUuZGV0YWlsLmRhdGEuc2xpY2UoX3RoaXMucmVmaW5kZXgsIF90aGlzLnJlZmVuZGluZGV4KTsgLy9kbyB2YWx1ZSBjb252ZXJzaW9uIGJhc2VkIG9uIGNvbnZlcnRvcnNcblxuICAgICAgaWYgKF90aGlzLm9wZXJhdGlvbikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd2RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAvL2lmIHBhcnRpY3VsYXIgb3BlcmF0aW9uIGlzIGRlZmluZWRcbiAgICAgICAgICBpZiAoX3RoaXMub3BlcmF0aW9uW2ldKSByYXdkYXRhW2ldID0gX3RoaXMub3BlcmF0aW9uW2ldKHJhd2RhdGFbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBqID0gMDsgLy9wdXQgZWFjaCBmaXJzdCB2YWx1ZSBvbiB4IGF4aXMsIHNlY29uZCBvbiB5IGF4aXNcblxuICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IF90aGlzLnJlZnZhbHVlczsgX2kgPSBfaSArIDIpIHtcbiAgICAgICAgLy9yZW1lbWJlciBvbmx5IGN1cnJlbnQgeCx5IHZhbHVlIC0gb24gdGhlIGluZGV4XG4gICAgICAgIF90aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbal0uZGF0YVtfdGhpcy5pbmRleF0gPSB7XG4gICAgICAgICAgeDogcmF3ZGF0YVtfaSAtIDFdLFxuICAgICAgICAgIHk6IHJhd2RhdGFbX2ldXG4gICAgICAgIH07IC8vaW5jcmVtZW50IGRhdGFzZXQgLSBpZiBtb3JlIGRhdGFzZXQgYXJlIGF2YWlsYWJsZVxuXG4gICAgICAgIGorKztcbiAgICAgIH0gLy90aHJvdHRsZSAtIHVwZGF0ZSB2YWx1ZXMgZXZlcnkgMSBzIG9ubHlcblxuXG4gICAgICB0aHJvdHRsZShfdGhpcy5jaGFydC51cGRhdGUoKSwgMTAwMCk7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDaGFydGpzWHlQb2ludHMucHJvdG90eXBlO1xuXG4gIF9wcm90by5iaW5kID0gZnVuY3Rpb24gYmluZCgpIHtcbiAgICBfQ2hhcnRqc1h5LnByb3RvdHlwZS5iaW5kLmNhbGwodGhpcyk7XG5cbiAgICBjb25zb2xlLmxvZygnY2hhcnRqcyB4eSBwb2ludCBiaW5kKCknKTtcblxuICAgIGlmICh0aGlzLnhtaW4pIHtcbiAgICAgIC8vc2V0cyB5c2NhbGUgbWluXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucykgdGhpcy5vcHRpb25zID0ge307XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zY2FsZXMpIHRoaXMub3B0aW9ucy5zY2FsZXMgPSB7fTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNjYWxlcy54QXhlcykgdGhpcy5vcHRpb25zLnNjYWxlcy54QXhlcyA9IFt7fV07IC8vY2hhcnRqcyAyLjkuNFxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zY2FsZXMueEF4ZXNbMF0udGlja3MpIHRoaXMub3B0aW9ucy5zY2FsZXMueEF4ZXNbMF0udGlja3MgPSB7fTsgLy9jaGFydGpzIDIuOS40XG5cbiAgICAgIHRoaXMub3B0aW9ucy5zY2FsZXMueEF4ZXNbMF0udGlja3MubWluID0gcGFyc2VGbG9hdCh0aGlzLnhtaW4pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnhtYXgpIHtcbiAgICAgIC8vc2V0cyB5c2NhbGUgbWF4XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucykgdGhpcy5vcHRpb25zID0ge307XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zY2FsZXMpIHRoaXMub3B0aW9ucy5zY2FsZXMgPSB7fTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNjYWxlcy54QXhlcykgdGhpcy5vcHRpb25zLnNjYWxlcy54QXhlcyA9IFt7fV07IC8vY2hhcnRqcyAyLjkuNFxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zY2FsZXMueEF4ZXNbMF0udGlja3MpIHRoaXMub3B0aW9ucy5zY2FsZXMueEF4ZXNbMF0udGlja3MgPSB7fTsgLy9jaGFydGpzIDIuOS40XG5cbiAgICAgIHRoaXMub3B0aW9ucy5zY2FsZXMueEF4ZXNbMF0udGlja3MubWF4ID0gcGFyc2VGbG9hdCh0aGlzLnhtYXgpOyAvL2lmICh0aGlzLm1pbikgdGhpcy5vcHRpb25zLnNjYWxlcy55QXhlc1swXS50aWNrcy5zdGVwU2l6ZSA9ICh0aGlzLm9wdGlvbnMuc2NhbGVzLnlBeGVzWzBdLnRpY2tzLm1heCAtIHRoaXMub3B0aW9ucy5zY2FsZXMueUF4ZXNbMF0udGlja3MubWluKSAvIDEwO1xuICAgIH0gLy9jdXN0b21pemUgdG9vbHRpcCBkaXNwbGF5XG5cblxuICAgIHRoaXMub3B0aW9ucy50b29sdGlwcy5jYWxsYmFja3MgPSB7XG4gICAgICBsYWJlbDogZnVuY3Rpb24gbGFiZWwodG9vbHRpcEl0ZW0sIGRhdGEpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gZGF0YS5kYXRhc2V0c1t0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXhdLmxhYmVsIHx8ICcnO1xuXG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgIGxhYmVsICs9ICc6ICc7XG4gICAgICAgIH1cblxuICAgICAgICBsYWJlbCArPSAnKCcgKyB0b29sdGlwSXRlbS54TGFiZWwudG9QcmVjaXNpb24oMykgKyAnLCcgKyB0b29sdGlwSXRlbS55TGFiZWwudG9QcmVjaXNpb24oMykgKyAnKSc7XG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgIH0sXG4gICAgICBmb290ZXI6IGZ1bmN0aW9uIGZvb3Rlcih0b29sdGlwSXRlbSwgZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5kYXRhc2V0cy5sZW5ndGggPCAyKSByZXR1cm4gdG9vbHRpcEl0ZW1bMF0ueUxhYmVsO1xuICAgICAgICB2YXIgbGFiZWwgPSBbXTsgLy9sYWJlbC5wdXNoKCd8ICcgKyBkYXRhLmRhdGFzZXRzWzBdLmRhdGFbdG9vbHRpcEl0ZW1bMF0uaW5kZXhdLnkudG9QcmVjaXNpb24oMykgKyAnIC0gJyArIGRhdGEuZGF0YXNldHNbMV0uZGF0YVt0b29sdGlwSXRlbVswXS5pbmRleF0ueS50b1ByZWNpc2lvbigzKSArICcgfCcpO1xuXG4gICAgICAgIGxhYmVsLnB1c2goJ86UICcgKyBNYXRoLmFicyhkYXRhLmRhdGFzZXRzWzBdLmRhdGFbdG9vbHRpcEl0ZW1bMF0uaW5kZXhdLnkgLSBkYXRhLmRhdGFzZXRzWzFdLmRhdGFbdG9vbHRpcEl0ZW1bMF0uaW5kZXhdLnkpLnRvUHJlY2lzaW9uKDMpKTtcbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy50eXBlID0gJ3NjYXR0ZXInO1xuICAgIHRoaXMucGx1Z2lucyA9IG51bGw7XG4gICAgdGhpcy5vcHRpb25zLlhZUGx1Z2luID0gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8uYXR0YWNoZWQgPSBmdW5jdGlvbiBhdHRhY2hlZCgpIHtcbiAgICAvL3JlZ2lzdGVyIGhvcml6b250YWwgbGluZSBkcmF3aW5nLCBzaG93cyBkaWZmZXJlbmNlIGxpbmUgYmV0d2VlbiBhcHByb3ByaWF0ZSBwb2ludHMgZnJvbSBkYXRhc2V0MCBhbmQgZGF0YXNldDFcbiAgICBfY2hhcnQuZGVmYXVsdC5wbHVnaW5TZXJ2aWNlLnJlZ2lzdGVyKHtcbiAgICAgIGJlZm9yZURyYXc6IGZ1bmN0aW9uIGJlZm9yZURyYXcoY2hhcnQsIGVhc2UpIHtcbiAgICAgICAgaWYgKGNoYXJ0LmNvbmZpZy5vcHRpb25zLlhZUGx1Z2luICYmIGNoYXJ0LnRvb2x0aXAuX2FjdGl2ZSAmJiBjaGFydC50b29sdGlwLl9hY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGFjdGl2ZVBvaW50ID0gY2hhcnQudG9vbHRpcC5fYWN0aXZlWzBdOyAvL2NvbnNvbGUubG9nKCdjaGFydCBob3Jpem9udGFsIGxpbmUgZGVidWcgY2hhcnQgYWN0aXZlcG9pbnQ6JywgYWN0aXZlUG9pbnQpO1xuXG4gICAgICAgICAgdmFyIGN0eCA9IGNoYXJ0LmN0eDtcbiAgICAgICAgICB2YXIgeSA9IGFjdGl2ZVBvaW50LnRvb2x0aXBQb3NpdGlvbigpLnk7IC8vbGV0IHRvcFkgPSB0aGlzLmNoYXJ0LmxlZ2VuZC5ib3R0b207XG5cbiAgICAgICAgICB2YXIgbGVmdFggPSBjaGFydC5jaGFydEFyZWEubGVmdDsgLy9sZXQgYm90dG9tWSA9IHRoaXMuY2hhcnQuY2hhcnRBcmVhLmJvdHRvbTtcblxuICAgICAgICAgIHZhciByaWdodFggPSBjaGFydC5jaGFydEFyZWEucmlnaHQ7IC8vIGRyYXcgbGluZVxuXG4gICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4Lm1vdmVUbyhsZWZ0WCwgeSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyhyaWdodFgsIHkpO1xuICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjZmY5YzljJztcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgdmFyIG1ldGExID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgdmFyIG1ldGEyID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMSk7XG5cbiAgICAgICAgICBpZiAobWV0YTEpIHtcbiAgICAgICAgICAgIC8vZHJhdyBzZWNvbmQgbGluZVxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncGx1Z2luIG1ldGEnLCBjaGFydCwgbWV0YSk7XG4gICAgICAgICAgICB2YXIgc2Vjb25keTIgPSBtZXRhMS5kYXRhW2FjdGl2ZVBvaW50Ll9pbmRleF0uX21vZGVsLnk7XG4gICAgICAgICAgICB2YXIgc2Vjb25keSA9IHNlY29uZHkyICE9PSB5ID8gc2Vjb25keTIgOiBtZXRhMi5kYXRhW2FjdGl2ZVBvaW50Ll9pbmRleF0uX21vZGVsLnk7IC8vbGV0IHN0b3AgID0gbWV0YS5kYXRhW2NoYXJ0LmNvbmZpZy5vcHRpb25zLnNlY3Rpb25baV0uaW5kZXhdLl9tb2RlbC54O1xuXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGxlZnRYLCBzZWNvbmR5KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocmlnaHRYLCBzZWNvbmR5KTtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyNmZjljOWMnO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgdmFyIHggPSBhY3RpdmVQb2ludC50b29sdGlwUG9zaXRpb24oKS54O1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICAgIHZhciBzeSA9IHkgPiBzZWNvbmR5ID8gMyA6IC0zOyAvL3NtYWxsIGFycm93IHVwXG5cbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCAtIHN5LCB5IC0gc3kpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgc3ksIHkgLSBzeSk7IC8vbGluZVxuXG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCBzZWNvbmR5KTsgLy9zbWFsbCBhcnJvdyBkb3duXG5cbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCAtIHN5LCBzZWNvbmR5ICsgc3kpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgc3ksIHNlY29uZHkgKyBzeSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHNlY29uZHkpO1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnIzdiN2JmZic7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX0NoYXJ0anNYeS5wcm90b3R5cGUuYXR0YWNoZWQuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uYWRkcG9pbnQgPSBmdW5jdGlvbiBhZGRwb2ludCgpIHtcbiAgICB0aGlzLmluZGV4Kys7XG4gIH07XG5cbiAgX3Byb3RvLnJlbW92ZXBvaW50ID0gZnVuY3Rpb24gcmVtb3ZlcG9pbnQoKSB7XG4gICAgaWYgKHRoaXMuaW5kZXggPiAwKSB0aGlzLmluZGV4LS07XG4gIH07XG5cbiAgcmV0dXJuIENoYXJ0anNYeVBvaW50cztcbn0oX2NoYXJ0anNYeS5DaGFydGpzWHkpLCAoX2Rlc2NyaXB0b3IgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcImZyb21pZFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMiA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwibGFiZWxzXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3IzID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJyZWZpbmRleFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yNCA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwicmVmdmFsdWVzXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I1ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJtaW5cIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjYgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcIm1heFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yNyA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwieG1pblwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yOCA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwieG1heFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yOSA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwiYXRpdGxlXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiBpbml0aWFsaXplcigpIHtcbiAgICByZXR1cm4gJ0FkZCBQb2ludCc7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjEwID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJydGl0bGVcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uIGluaXRpYWxpemVyKCkge1xuICAgIHJldHVybiAnUmVtb3ZlIFBvaW50JztcbiAgfVxufSksIF9kZXNjcmlwdG9yMTEgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcImNvbnZlcnRvcnNcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pKSwgX2NsYXNzMikpIHx8IF9jbGFzcyk7XG5leHBvcnRzLkNoYXJ0anNYeVBvaW50cyA9IENoYXJ0anNYeVBvaW50cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYXJ0anMteHktcG9pbnRzLmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-xy-points\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-xy-points.html":
/*!***************************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-xy-points.html ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template bindable=\\\"width,height\\\">\\n    <div id=\\\"canvas-holder\\\">\\n        <div class=\\\"w3-small\\\">\\n            <i class=\\\"fa fa-download fa-flip-horizontal\\\" title=\\\"download csv data, row=data in time point\\\"\\n               click.delegate=\\\"download()\\\"> </i>\\n            <i class=\\\"fa fa-download fa-rotate-270\\\" title=\\\"download flat csv data, row=all data for variable\\\"\\n               click.delegate=\\\"downloadflat()\\\"> </i>\\n\\n        </div>\\n        <div style=\\\"margin-top: -1.5em\\\">\\n            <canvas id=\\\"${id}-canvas\\\" ref=\\\"chartcanvas\\\" width=\\\"${width}\\\" height=\\\"${height}\\\"></canvas>\\n        </div>\\n        <button click.delegate=\\\"addpoint()\\\">${atitle}</button><button click.delegate=\\\"removepoint()\\\">${rtitle}</button>\\n    </div>\\n</template>\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMteHktcG9pbnRzLmh0bWwuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2Rpc3QvbmF0aXZlLW1vZHVsZXMvZWxlbWVudHMvY2hhcnRqcy14eS1wb2ludHMuaHRtbD8xNDMyIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCI8dGVtcGxhdGUgYmluZGFibGU9XFxcIndpZHRoLGhlaWdodFxcXCI+XFxuICAgIDxkaXYgaWQ9XFxcImNhbnZhcy1ob2xkZXJcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidzMtc21hbGxcXFwiPlxcbiAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1kb3dubG9hZCBmYS1mbGlwLWhvcml6b250YWxcXFwiIHRpdGxlPVxcXCJkb3dubG9hZCBjc3YgZGF0YSwgcm93PWRhdGEgaW4gdGltZSBwb2ludFxcXCJcXG4gICAgICAgICAgICAgICBjbGljay5kZWxlZ2F0ZT1cXFwiZG93bmxvYWQoKVxcXCI+IDwvaT5cXG4gICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtZG93bmxvYWQgZmEtcm90YXRlLTI3MFxcXCIgdGl0bGU9XFxcImRvd25sb2FkIGZsYXQgY3N2IGRhdGEsIHJvdz1hbGwgZGF0YSBmb3IgdmFyaWFibGVcXFwiXFxuICAgICAgICAgICAgICAgY2xpY2suZGVsZWdhdGU9XFxcImRvd25sb2FkZmxhdCgpXFxcIj4gPC9pPlxcblxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IHN0eWxlPVxcXCJtYXJnaW4tdG9wOiAtMS41ZW1cXFwiPlxcbiAgICAgICAgICAgIDxjYW52YXMgaWQ9XFxcIiR7aWR9LWNhbnZhc1xcXCIgcmVmPVxcXCJjaGFydGNhbnZhc1xcXCIgd2lkdGg9XFxcIiR7d2lkdGh9XFxcIiBoZWlnaHQ9XFxcIiR7aGVpZ2h0fVxcXCI+PC9jYW52YXM+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxidXR0b24gY2xpY2suZGVsZWdhdGU9XFxcImFkZHBvaW50KClcXFwiPiR7YXRpdGxlfTwvYnV0dG9uPjxidXR0b24gY2xpY2suZGVsZWdhdGU9XFxcInJlbW92ZXBvaW50KClcXFwiPiR7cnRpdGxlfTwvYnV0dG9uPlxcbiAgICA8L2Rpdj5cXG48L3RlbXBsYXRlPlwiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-xy-points.html\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-xy.html":
/*!********************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-xy.html ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template><!-- not used, inherited from chartjs--></template>\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMteHkuaHRtbC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLWJvZHlsaWdodC1wbHVnaW4vZGlzdC9uYXRpdmUtbW9kdWxlcy9lbGVtZW50cy9jaGFydGpzLXh5Lmh0bWw/ZDFmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiPHRlbXBsYXRlPjwhLS0gbm90IHVzZWQsIGluaGVyaXRlZCBmcm9tIGNoYXJ0anMtLT48L3RlbXBsYXRlPlxcblwiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-xy.html\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs.html":
/*!*****************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs.html ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template bindable=\\\"width,height\\\">\\n    <div id=\\\"canvas-holder\\\">\\n        <div class=\\\"w3-small\\\">\\n            <i class=\\\"fa fa-download fa-flip-horizontal\\\" title=\\\"download csv data, row=data in time point\\\"\\n               click.delegate=\\\"download()\\\"> </i>\\n            <i class=\\\"fa fa-download fa-rotate-270\\\" title=\\\"download flat csv data, row=all data for variable\\\"\\n               click.delegate=\\\"downloadflat()\\\"> </i>\\n        </div>\\n        <div style=\\\"margin-top: -1.5em\\\">\\n            <canvas id=\\\"${id}-canvas\\\" ref=\\\"chartcanvas\\\" width=\\\"${width}\\\" height=\\\"${height}\\\"></canvas>\\n        </div>\\n    </div>\\n</template>\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMuaHRtbC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLWJvZHlsaWdodC1wbHVnaW4vZGlzdC9uYXRpdmUtbW9kdWxlcy9lbGVtZW50cy9jaGFydGpzLmh0bWw/MmNiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiPHRlbXBsYXRlIGJpbmRhYmxlPVxcXCJ3aWR0aCxoZWlnaHRcXFwiPlxcbiAgICA8ZGl2IGlkPVxcXCJjYW52YXMtaG9sZGVyXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInczLXNtYWxsXFxcIj5cXG4gICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtZG93bmxvYWQgZmEtZmxpcC1ob3Jpem9udGFsXFxcIiB0aXRsZT1cXFwiZG93bmxvYWQgY3N2IGRhdGEsIHJvdz1kYXRhIGluIHRpbWUgcG9pbnRcXFwiXFxuICAgICAgICAgICAgICAgY2xpY2suZGVsZWdhdGU9XFxcImRvd25sb2FkKClcXFwiPiA8L2k+XFxuICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWRvd25sb2FkIGZhLXJvdGF0ZS0yNzBcXFwiIHRpdGxlPVxcXCJkb3dubG9hZCBmbGF0IGNzdiBkYXRhLCByb3c9YWxsIGRhdGEgZm9yIHZhcmlhYmxlXFxcIlxcbiAgICAgICAgICAgICAgIGNsaWNrLmRlbGVnYXRlPVxcXCJkb3dubG9hZGZsYXQoKVxcXCI+IDwvaT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBzdHlsZT1cXFwibWFyZ2luLXRvcDogLTEuNWVtXFxcIj5cXG4gICAgICAgICAgICA8Y2FudmFzIGlkPVxcXCIke2lkfS1jYW52YXNcXFwiIHJlZj1cXFwiY2hhcnRjYW52YXNcXFwiIHdpZHRoPVxcXCIke3dpZHRofVxcXCIgaGVpZ2h0PVxcXCIke2hlaWdodH1cXFwiPjwvY2FudmFzPlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuXCI7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs.html\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/checkbox":
/*!****************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/checkbox.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.Checkbox = void 0;\n\nvar _aureliaFramework = __webpack_require__(/*! aurelia-framework */ \"aurelia-framework\");\n\nvar _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6;\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\nvar Checkbox = (_class = /*#__PURE__*/function () {\n  function Checkbox() {\n    _initializerDefineProperty(this, \"min\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"max\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"title\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"titlemax\", _descriptor4, this);\n\n    _initializerDefineProperty(this, \"titlemin\", _descriptor5, this);\n\n    _initializerDefineProperty(this, \"default\", _descriptor6, this);\n\n    this.value = void 0;\n    this.isChecked = false;\n  }\n\n  var _proto = Checkbox.prototype;\n\n  _proto.bind = function bind() {\n    if (this.default) {\n      //console.log('checkbox default,', this.default);\n      this.isChecked = this.default === 'true';\n    }\n\n    if (!this.titlemax) this.titlemax = this.title;\n    if (!this.titlemin) this.titlemin = this.title; //console.log('checkbox bind() min:' + this.min + ' max:' + this.max + ' default:' + this.default + ' ischecked' + this.isChecked);\n  };\n\n  return Checkbox;\n}(), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"min\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 0;\n  }\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"max\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 1;\n  }\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"title\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return '';\n  }\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, \"titlemax\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, \"titlemin\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, \"default\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class);\nexports.Checkbox = Checkbox;\n//# sourceMappingURL=checkbox.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoZWNrYm94LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F1cmVsaWEtYm9keWxpZ2h0LXBsdWdpbi9kaXN0L25hdGl2ZS1tb2R1bGVzL2VsZW1lbnRzL2NoZWNrYm94LmpzP2QwNDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkNoZWNrYm94ID0gdm9pZCAwO1xuXG52YXIgX2F1cmVsaWFGcmFtZXdvcmsgPSByZXF1aXJlKFwiYXVyZWxpYS1mcmFtZXdvcmtcIik7XG5cbnZhciBfY2xhc3MsIF9kZXNjcmlwdG9yLCBfZGVzY3JpcHRvcjIsIF9kZXNjcmlwdG9yMywgX2Rlc2NyaXB0b3I0LCBfZGVzY3JpcHRvcjUsIF9kZXNjcmlwdG9yNjtcblxuZnVuY3Rpb24gX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvciwgY29udGV4dCkgeyBpZiAoIWRlc2NyaXB0b3IpIHJldHVybjsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHsgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLCBjb25maWd1cmFibGU6IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlLCB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSwgdmFsdWU6IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIgPyBkZXNjcmlwdG9yLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDAgfSk7IH1cblxuZnVuY3Rpb24gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5LCBkZWNvcmF0b3JzLCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7IHZhciBkZXNjID0ge307IE9iamVjdC5rZXlzKGRlc2NyaXB0b3IpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBkZXNjW2tleV0gPSBkZXNjcmlwdG9yW2tleV07IH0pOyBkZXNjLmVudW1lcmFibGUgPSAhIWRlc2MuZW51bWVyYWJsZTsgZGVzYy5jb25maWd1cmFibGUgPSAhIWRlc2MuY29uZmlndXJhYmxlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjIHx8IGRlc2MuaW5pdGlhbGl6ZXIpIHsgZGVzYy53cml0YWJsZSA9IHRydWU7IH0gZGVzYyA9IGRlY29yYXRvcnMuc2xpY2UoKS5yZXZlcnNlKCkucmVkdWNlKGZ1bmN0aW9uIChkZXNjLCBkZWNvcmF0b3IpIHsgcmV0dXJuIGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5LCBkZXNjKSB8fCBkZXNjOyB9LCBkZXNjKTsgaWYgKGNvbnRleHQgJiYgZGVzYy5pbml0aWFsaXplciAhPT0gdm9pZCAwKSB7IGRlc2MudmFsdWUgPSBkZXNjLmluaXRpYWxpemVyID8gZGVzYy5pbml0aWFsaXplci5jYWxsKGNvbnRleHQpIDogdm9pZCAwOyBkZXNjLmluaXRpYWxpemVyID0gdW5kZWZpbmVkOyB9IGlmIChkZXNjLmluaXRpYWxpemVyID09PSB2b2lkIDApIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2MpOyBkZXNjID0gbnVsbDsgfSByZXR1cm4gZGVzYzsgfVxuXG5mdW5jdGlvbiBfaW5pdGlhbGl6ZXJXYXJuaW5nSGVscGVyKGRlc2NyaXB0b3IsIGNvbnRleHQpIHsgdGhyb3cgbmV3IEVycm9yKCdEZWNvcmF0aW5nIGNsYXNzIHByb3BlcnR5IGZhaWxlZC4gUGxlYXNlIGVuc3VyZSB0aGF0ICcgKyAncHJvcG9zYWwtY2xhc3MtcHJvcGVydGllcyBpcyBlbmFibGVkIGFuZCBydW5zIGFmdGVyIHRoZSBkZWNvcmF0b3JzIHRyYW5zZm9ybS4nKTsgfVxuXG52YXIgQ2hlY2tib3ggPSAoX2NsYXNzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2hlY2tib3goKSB7XG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJtaW5cIiwgX2Rlc2NyaXB0b3IsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhcIiwgX2Rlc2NyaXB0b3IyLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwidGl0bGVcIiwgX2Rlc2NyaXB0b3IzLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwidGl0bGVtYXhcIiwgX2Rlc2NyaXB0b3I0LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwidGl0bGVtaW5cIiwgX2Rlc2NyaXB0b3I1LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVmYXVsdFwiLCBfZGVzY3JpcHRvcjYsIHRoaXMpO1xuXG4gICAgdGhpcy52YWx1ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmlzQ2hlY2tlZCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENoZWNrYm94LnByb3RvdHlwZTtcblxuICBfcHJvdG8uYmluZCA9IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgaWYgKHRoaXMuZGVmYXVsdCkge1xuICAgICAgLy9jb25zb2xlLmxvZygnY2hlY2tib3ggZGVmYXVsdCwnLCB0aGlzLmRlZmF1bHQpO1xuICAgICAgdGhpcy5pc0NoZWNrZWQgPSB0aGlzLmRlZmF1bHQgPT09ICd0cnVlJztcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudGl0bGVtYXgpIHRoaXMudGl0bGVtYXggPSB0aGlzLnRpdGxlO1xuICAgIGlmICghdGhpcy50aXRsZW1pbikgdGhpcy50aXRsZW1pbiA9IHRoaXMudGl0bGU7IC8vY29uc29sZS5sb2coJ2NoZWNrYm94IGJpbmQoKSBtaW46JyArIHRoaXMubWluICsgJyBtYXg6JyArIHRoaXMubWF4ICsgJyBkZWZhdWx0OicgKyB0aGlzLmRlZmF1bHQgKyAnIGlzY2hlY2tlZCcgKyB0aGlzLmlzQ2hlY2tlZCk7XG4gIH07XG5cbiAgcmV0dXJuIENoZWNrYm94O1xufSgpLCAoX2Rlc2NyaXB0b3IgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwibWluXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uIGluaXRpYWxpemVyKCkge1xuICAgIHJldHVybiAwO1xuICB9XG59KSwgX2Rlc2NyaXB0b3IyID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcIm1heFwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiBpbml0aWFsaXplcigpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxufSksIF9kZXNjcmlwdG9yMyA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiBpbml0aWFsaXplcigpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjQgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwidGl0bGVtYXhcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yNSA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJ0aXRsZW1pblwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I2ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImRlZmF1bHRcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSkpLCBfY2xhc3MpO1xuZXhwb3J0cy5DaGVja2JveCA9IENoZWNrYm94O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tib3guanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/checkbox\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/checkbox.html":
/*!******************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/checkbox.html ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template bindable=\\\"default,title,min,max,titlemin,titlemax\\\">\\n    <div class=\\\"slidecontainer\\\">\\n        <input class=\\\"w3-check\\\" type=\\\"checkbox\\\" checked.two-way=\\\"isChecked\\\" value.bind=\\\"isChecked?max:min\\\"/> <label>${isChecked?titlemax:titlemin}</label>\\n    </div>\\n</template>\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoZWNrYm94Lmh0bWwuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2Rpc3QvbmF0aXZlLW1vZHVsZXMvZWxlbWVudHMvY2hlY2tib3guaHRtbD9lMjUwIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCI8dGVtcGxhdGUgYmluZGFibGU9XFxcImRlZmF1bHQsdGl0bGUsbWluLG1heCx0aXRsZW1pbix0aXRsZW1heFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNsaWRlY29udGFpbmVyXFxcIj5cXG4gICAgICAgIDxpbnB1dCBjbGFzcz1cXFwidzMtY2hlY2tcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIiBjaGVja2VkLnR3by13YXk9XFxcImlzQ2hlY2tlZFxcXCIgdmFsdWUuYmluZD1cXFwiaXNDaGVja2VkP21heDptaW5cXFwiLz4gPGxhYmVsPiR7aXNDaGVja2VkP3RpdGxlbWF4OnRpdGxlbWlufTwvbGFiZWw+XFxuICAgIDwvZGl2PlxcbjwvdGVtcGxhdGU+XCI7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/checkbox.html\n");

/***/ })

}]);