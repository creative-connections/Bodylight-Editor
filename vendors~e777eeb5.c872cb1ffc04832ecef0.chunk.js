(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~e777eeb5"],{

/***/ "aaSZ":
/*!*****************************************************************!*\
  !*** ./node_modules/latest-createjs/lib/preloadjs/preloadjs.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n* PreloadJS\n* Visit http://createjs.com/ for documentation, updates and examples.\n*\n* Copyright (c) 2010 gskinner.com, inc.\n*\n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n//##############################################################################\n// version.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * Static class holding library specific information such as the version and buildDate of the library.\n\t * @class PreloadJS\n\t **/\n\tvar s = createjs.PreloadJS = createjs.PreloadJS || {};\n\n\t/**\n\t * The version string for this release.\n\t * @property version\n\t * @type {String}\n\t * @static\n\t **/\n\ts.version = /*=version*/\"1.0.0\"; // injected by build process\n\n\t/**\n\t * The build date for this release in UTC format.\n\t * @property buildDate\n\t * @type {String}\n\t * @static\n\t **/\n\ts.buildDate = /*=date*/\"Thu, 14 Sep 2017 19:47:47 GMT\"; // injected by build process\n\n})();\n\n//##############################################################################\n// extend.js\n//##############################################################################\n\nwindow.createjs = window.createjs||{};\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Sets up the prototype chain and constructor property for a new class.\n *\n * This should be called right after creating the class constructor.\n *\n * \tfunction MySubClass() {}\n * \tcreatejs.extend(MySubClass, MySuperClass);\n * \tMySubClass.prototype.doSomething = function() { }\n *\n * \tvar foo = new MySubClass();\n * \tconsole.log(foo instanceof MySuperClass); // true\n * \tconsole.log(foo.prototype.constructor === MySubClass); // true\n *\n * @method extend\n * @param {Function} subclass The subclass.\n * @param {Function} superclass The superclass to extend.\n * @return {Function} Returns the subclass's new prototype.\n */\ncreatejs.extend = function(subclass, superclass) {\n\t\"use strict\";\n\n\tfunction o() { this.constructor = subclass; }\n\to.prototype = superclass.prototype;\n\treturn (subclass.prototype = new o());\n};\n\n//##############################################################################\n// promote.js\n//##############################################################################\n\nwindow.createjs = window.createjs||{};\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Promotes any methods on the super class that were overridden, by creating an alias in the format `prefix_methodName`.\n * It is recommended to use the super class's name as the prefix.\n * An alias to the super class's constructor is always added in the format `prefix_constructor`.\n * This allows the subclass to call super class methods without using `function.call`, providing better performance.\n *\n * For example, if `MySubClass` extends `MySuperClass`, and both define a `draw` method, then calling `promote(MySubClass, \"MySuperClass\")`\n * would add a `MySuperClass_constructor` method to MySubClass and promote the `draw` method on `MySuperClass` to the\n * prototype of `MySubClass` as `MySuperClass_draw`.\n *\n * This should be called after the class's prototype is fully defined.\n *\n * \tfunction ClassA(name) {\n * \t\tthis.name = name;\n * \t}\n * \tClassA.prototype.greet = function() {\n * \t\treturn \"Hello \"+this.name;\n * \t}\n *\n * \tfunction ClassB(name, punctuation) {\n * \t\tthis.ClassA_constructor(name);\n * \t\tthis.punctuation = punctuation;\n * \t}\n * \tcreatejs.extend(ClassB, ClassA);\n * \tClassB.prototype.greet = function() {\n * \t\treturn this.ClassA_greet()+this.punctuation;\n * \t}\n * \tcreatejs.promote(ClassB, \"ClassA\");\n *\n * \tvar foo = new ClassB(\"World\", \"!?!\");\n * \tconsole.log(foo.greet()); // Hello World!?!\n *\n * @method promote\n * @param {Function} subclass The class to promote super class methods on.\n * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.\n * @return {Function} Returns the subclass.\n */\ncreatejs.promote = function(subclass, prefix) {\n\t\"use strict\";\n\n\tvar subP = subclass.prototype, supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;\n\tif (supP) {\n\t\tsubP[(prefix+=\"_\") + \"constructor\"] = supP.constructor; // constructor is not always innumerable\n\t\tfor (var n in supP) {\n\t\t\tif (subP.hasOwnProperty(n) && (typeof supP[n] == \"function\")) { subP[prefix + n] = supP[n]; }\n\t\t}\n\t}\n\treturn subclass;\n};\n\n//##############################################################################\n// deprecate.js\n//##############################################################################\n\nwindow.createjs = window.createjs||{};\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Wraps deprecated methods so they still be used, but throw warnings to developers.\n *\n *\tobj.deprecatedMethod = createjs.deprecate(\"Old Method Name\", obj._fallbackMethod);\n *\n * The recommended approach for deprecated properties is:\n *\n *\ttry {\n *\t\tObj\tect.defineProperties(object, {\n *\t\t\treadyOnlyProp: { get: createjs.deprecate(\"readOnlyProp\", function() { return this.alternateProp; }) },\n *\t\t\treadWriteProp: {\n *\t\t\t\tget: createjs.deprecate(\"readOnlyProp\", function() { return this.alternateProp; }),\n *\t\t\t\tset: createjs.deprecate(\"readOnlyProp\", function(val) { this.alternateProp = val; })\n *\t\t});\n *\t} catch (e) {}\n *\n * @method deprecate\n * @param {Function} [fallbackMethod=null] A method to call when the deprecated method is used. See the example for how\n * @param {String} [name=null] The name of the method or property to display in the console warning.\n * to deprecate properties.\n * @return {Function} If a fallbackMethod is supplied, returns a closure that will call the fallback method after\n * logging the warning in the console.\n */\ncreatejs.deprecate = function(fallbackMethod, name) {\n\t\"use strict\";\n\treturn function() {\n\t\tvar msg = \"Deprecated property or method '\"+name+\"'. See docs for info.\";\n\t\tconsole && (console.warn ? console.warn(msg) : console.log(msg));\n\t\treturn fallbackMethod && fallbackMethod.apply(this, arguments);\n\t}\n};\n\n//##############################################################################\n// proxy.js\n//##############################################################################\n\nwindow.createjs = window.createjs||{};\n\n/**\n * Various utilities that the CreateJS Suite uses. Utilities are created as separate files, and will be available on the\n * createjs namespace directly.\n *\n * <h4>Example</h4>\n *\n *      myObject.addEventListener(\"change\", createjs.proxy(myMethod, scope));\n *\n * @class Utility Methods\n * @main Utility Methods\n */\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * A function proxy for methods. By default, JavaScript methods do not maintain scope, so passing a method as a\n\t * callback will result in the method getting called in the scope of the caller. Using a proxy ensures that the\n\t * method gets called in the correct scope.\n\t *\n\t * Additional arguments can be passed that will be applied to the function when it is called.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      myObject.addEventListener(\"event\", createjs.proxy(myHandler, this, arg1, arg2));\n\t *\n\t *      function myHandler(arg1, arg2) {\n\t *           // This gets called when myObject.myCallback is executed.\n\t *      }\n\t *\n\t * @method proxy\n\t * @param {Function} method The function to call\n\t * @param {Object} scope The scope to call the method name on\n\t * @param {mixed} [arg] * Arguments that are appended to the callback for additional params.\n\t * @public\n\t * @static\n\t */\n\tcreatejs.proxy = function (method, scope) {\n\t\tvar aArgs = Array.prototype.slice.call(arguments, 2);\n\t\treturn function () {\n\t\t\treturn method.apply(scope, Array.prototype.slice.call(arguments, 0).concat(aArgs));\n\t\t};\n\t}\n\n}());\n\n//##############################################################################\n// indexOf.js\n//##############################################################################\n\nwindow.createjs = window.createjs||{};\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of\n * that value.  Returns -1 if value is not found.\n *\n *      var i = createjs.indexOf(myArray, myElementToFind);\n *\n * @method indexOf\n * @param {Array} array Array to search for searchElement\n * @param searchElement Element to find in array.\n * @return {Number} The first index of searchElement in array.\n */\ncreatejs.indexOf = function (array, searchElement){\n\t\"use strict\";\n\n\tfor (var i = 0,l=array.length; i < l; i++) {\n\t\tif (searchElement === array[i]) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\n//##############################################################################\n// Event.js\n//##############################################################################\n\nwindow.createjs = window.createjs||{};\n\n(function() {\n\t\"use strict\";\n\n// constructor:\n\t/**\n\t * Contains properties and methods shared by all events for use with\n\t * {{#crossLink \"EventDispatcher\"}}{{/crossLink}}.\n\t * \n\t * Note that Event objects are often reused, so you should never\n\t * rely on an event object's state outside of the call stack it was received in.\n\t * @class Event\n\t * @param {String} type The event type.\n\t * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.\n\t * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.\n\t * @constructor\n\t **/\n\tfunction Event(type, bubbles, cancelable) {\n\t\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * The type of event.\n\t\t * @property type\n\t\t * @type String\n\t\t **/\n\t\tthis.type = type;\n\t\n\t\t/**\n\t\t * The object that generated an event.\n\t\t * @property target\n\t\t * @type Object\n\t\t * @default null\n\t\t * @readonly\n\t\t*/\n\t\tthis.target = null;\n\t\n\t\t/**\n\t\t * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will\n\t\t * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event\n\t\t * is generated from childObj, then a listener on parentObj would receive the event with\n\t\t * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).\n\t\t * @property currentTarget\n\t\t * @type Object\n\t\t * @default null\n\t\t * @readonly\n\t\t*/\n\t\tthis.currentTarget = null;\n\t\n\t\t/**\n\t\t * For bubbling events, this indicates the current event phase:<OL>\n\t\t * \t<LI> capture phase: starting from the top parent to the target</LI>\n\t\t * \t<LI> at target phase: currently being dispatched from the target</LI>\n\t\t * \t<LI> bubbling phase: from the target to the top parent</LI>\n\t\t * </OL>\n\t\t * @property eventPhase\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @readonly\n\t\t*/\n\t\tthis.eventPhase = 0;\n\t\n\t\t/**\n\t\t * Indicates whether the event will bubble through the display list.\n\t\t * @property bubbles\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.bubbles = !!bubbles;\n\t\n\t\t/**\n\t\t * Indicates whether the default behaviour of this event can be cancelled via\n\t\t * {{#crossLink \"Event/preventDefault\"}}{{/crossLink}}. This is set via the Event constructor.\n\t\t * @property cancelable\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.cancelable = !!cancelable;\n\t\n\t\t/**\n\t\t * The epoch time at which this event was created.\n\t\t * @property timeStamp\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @readonly\n\t\t*/\n\t\tthis.timeStamp = (new Date()).getTime();\n\t\n\t\t/**\n\t\t * Indicates if {{#crossLink \"Event/preventDefault\"}}{{/crossLink}} has been called\n\t\t * on this event.\n\t\t * @property defaultPrevented\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.defaultPrevented = false;\n\t\n\t\t/**\n\t\t * Indicates if {{#crossLink \"Event/stopPropagation\"}}{{/crossLink}} or\n\t\t * {{#crossLink \"Event/stopImmediatePropagation\"}}{{/crossLink}} has been called on this event.\n\t\t * @property propagationStopped\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.propagationStopped = false;\n\t\n\t\t/**\n\t\t * Indicates if {{#crossLink \"Event/stopImmediatePropagation\"}}{{/crossLink}} has been called\n\t\t * on this event.\n\t\t * @property immediatePropagationStopped\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.immediatePropagationStopped = false;\n\t\t\n\t\t/**\n\t\t * Indicates if {{#crossLink \"Event/remove\"}}{{/crossLink}} has been called on this event.\n\t\t * @property removed\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.removed = false;\n\t}\n\tvar p = Event.prototype;\n\n// public methods:\n\t/**\n\t * Sets {{#crossLink \"Event/defaultPrevented\"}}{{/crossLink}} to true if the event is cancelable.\n\t * Mirrors the DOM level 2 event standard. In general, cancelable events that have `preventDefault()` called will\n\t * cancel the default behaviour associated with the event.\n\t * @method preventDefault\n\t **/\n\tp.preventDefault = function() {\n\t\tthis.defaultPrevented = this.cancelable&&true;\n\t};\n\n\t/**\n\t * Sets {{#crossLink \"Event/propagationStopped\"}}{{/crossLink}} to true.\n\t * Mirrors the DOM event standard.\n\t * @method stopPropagation\n\t **/\n\tp.stopPropagation = function() {\n\t\tthis.propagationStopped = true;\n\t};\n\n\t/**\n\t * Sets {{#crossLink \"Event/propagationStopped\"}}{{/crossLink}} and\n\t * {{#crossLink \"Event/immediatePropagationStopped\"}}{{/crossLink}} to true.\n\t * Mirrors the DOM event standard.\n\t * @method stopImmediatePropagation\n\t **/\n\tp.stopImmediatePropagation = function() {\n\t\tthis.immediatePropagationStopped = this.propagationStopped = true;\n\t};\n\t\n\t/**\n\t * Causes the active listener to be removed via removeEventListener();\n\t * \n\t * \t\tmyBtn.addEventListener(\"click\", function(evt) {\n\t * \t\t\t// do stuff...\n\t * \t\t\tevt.remove(); // removes this listener.\n\t * \t\t});\n\t * \n\t * @method remove\n\t **/\n\tp.remove = function() {\n\t\tthis.removed = true;\n\t};\n\t\n\t/**\n\t * Returns a clone of the Event instance.\n\t * @method clone\n\t * @return {Event} a clone of the Event instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Event(this.type, this.bubbles, this.cancelable);\n\t};\n\t\n\t/**\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\n\t *\n\t * @method set\n\t * @param {Object} props A generic object containing properties to copy to the instance.\n\t * @return {Event} Returns the instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t*/\n\tp.set = function(props) {\n\t\tfor (var n in props) { this[n] = props[n]; }\n\t\treturn this;\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Event (type=\"+this.type+\")]\";\n\t};\n\n\tcreatejs.Event = Event;\n}());\n\n//##############################################################################\n// ErrorEvent.js\n//##############################################################################\n\nwindow.createjs = window.createjs||{};\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * A general error {{#crossLink \"Event\"}}{{/crossLink}}, that describes an error that occurred, as well as any details.\n\t * @class ErrorEvent\n\t * @param {String} [title] The error title\n\t * @param {String} [message] The error description\n\t * @param {Object} [data] Additional error data\n\t * @constructor\n\t */\n\tfunction ErrorEvent(title, message, data) {\n\t\tthis.Event_constructor(\"error\");\n\n\t\t/**\n\t\t * The short error title, which indicates the type of error that occurred.\n\t\t * @property title\n\t\t * @type String\n\t\t */\n\t\tthis.title = title;\n\n\t\t/**\n\t\t * The verbose error message, containing details about the error.\n\t\t * @property message\n\t\t * @type String\n\t\t */\n\t\tthis.message = message;\n\n\t\t/**\n\t\t * Additional data attached to an error.\n\t\t * @property data\n\t\t * @type {Object}\n\t\t */\n\t\tthis.data = data;\n\t}\n\n\tvar p = createjs.extend(ErrorEvent, createjs.Event);\n\n\tp.clone = function() {\n\t\treturn new createjs.ErrorEvent(this.title, this.message, this.data);\n\t};\n\n\tcreatejs.ErrorEvent = createjs.promote(ErrorEvent, \"Event\");\n\n}());\n\n//##############################################################################\n// EventDispatcher.js\n//##############################################################################\n\nwindow.createjs = window.createjs||{};\r\n\r\n(function() {\r\n\t\"use strict\";\r\n\r\n\r\n// constructor:\r\n\t/**\r\n\t * EventDispatcher provides methods for managing queues of event listeners and dispatching events.\r\n\t *\r\n\t * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the\r\n\t * EventDispatcher {{#crossLink \"EventDispatcher/initialize\"}}{{/crossLink}} method.\r\n\t * \r\n\t * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the\r\n\t * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports\r\n\t * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.\r\n\t * \r\n\t * EventDispatcher also exposes a {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}} method, which makes it easier\r\n\t * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The \r\n\t * {{#crossLink \"EventDispatcher/off\"}}{{/crossLink}} method is merely an alias to\r\n\t * {{#crossLink \"EventDispatcher/removeEventListener\"}}{{/crossLink}}.\r\n\t * \r\n\t * Another addition to the DOM Level 2 model is the {{#crossLink \"EventDispatcher/removeAllEventListeners\"}}{{/crossLink}}\r\n\t * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also \r\n\t * includes a {{#crossLink \"Event/remove\"}}{{/crossLink}} method which removes the active listener.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t * Add EventDispatcher capabilities to the \"MyClass\" class.\r\n\t *\r\n\t *      EventDispatcher.initialize(MyClass.prototype);\r\n\t *\r\n\t * Add an event (see {{#crossLink \"EventDispatcher/addEventListener\"}}{{/crossLink}}).\r\n\t *\r\n\t *      instance.addEventListener(\"eventName\", handlerMethod);\r\n\t *      function handlerMethod(event) {\r\n\t *          console.log(event.target + \" Was Clicked\");\r\n\t *      }\r\n\t *\r\n\t * <b>Maintaining proper scope</b><br />\r\n\t * Scope (ie. \"this\") can be be a challenge with events. Using the {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}}\r\n\t * method to subscribe to events simplifies this.\r\n\t *\r\n\t *      instance.addEventListener(\"click\", function(event) {\r\n\t *          console.log(instance == this); // false, scope is ambiguous.\r\n\t *      });\r\n\t *      \r\n\t *      instance.on(\"click\", function(event) {\r\n\t *          console.log(instance == this); // true, \"on\" uses dispatcher scope by default.\r\n\t *      });\r\n\t * \r\n\t * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage\r\n\t * scope.\r\n\t *\r\n\t * <b>Browser support</b>\r\n\t * The event model in CreateJS can be used separately from the suite in any project, however the inheritance model\r\n\t * requires modern browsers (IE9+).\r\n\t *      \r\n\t *\r\n\t * @class EventDispatcher\r\n\t * @constructor\r\n\t **/\r\n\tfunction EventDispatcher() {\r\n\t\r\n\t\r\n\t// private properties:\r\n\t\t/**\r\n\t\t * @protected\r\n\t\t * @property _listeners\r\n\t\t * @type Object\r\n\t\t **/\r\n\t\tthis._listeners = null;\r\n\t\t\r\n\t\t/**\r\n\t\t * @protected\r\n\t\t * @property _captureListeners\r\n\t\t * @type Object\r\n\t\t **/\r\n\t\tthis._captureListeners = null;\r\n\t}\r\n\tvar p = EventDispatcher.prototype;\r\n\r\n// static public methods:\r\n\t/**\r\n\t * Static initializer to mix EventDispatcher methods into a target object or prototype.\r\n\t * \r\n\t * \t\tEventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class\r\n\t * \t\tEventDispatcher.initialize(myObject); // add to a specific instance\r\n\t * \r\n\t * @method initialize\r\n\t * @static\r\n\t * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a\r\n\t * prototype.\r\n\t **/\r\n\tEventDispatcher.initialize = function(target) {\r\n\t\ttarget.addEventListener = p.addEventListener;\r\n\t\ttarget.on = p.on;\r\n\t\ttarget.removeEventListener = target.off =  p.removeEventListener;\r\n\t\ttarget.removeAllEventListeners = p.removeAllEventListeners;\r\n\t\ttarget.hasEventListener = p.hasEventListener;\r\n\t\ttarget.dispatchEvent = p.dispatchEvent;\r\n\t\ttarget._dispatchEvent = p._dispatchEvent;\r\n\t\ttarget.willTrigger = p.willTrigger;\r\n\t};\r\n\t\r\n\r\n// public methods:\r\n\t/**\r\n\t * Adds the specified event listener. Note that adding multiple listeners to the same function will result in\r\n\t * multiple callbacks getting fired.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      displayObject.addEventListener(\"click\", handleClick);\r\n\t *      function handleClick(event) {\r\n\t *         // Click happened.\r\n\t *      }\r\n\t *\r\n\t * @method addEventListener\r\n\t * @param {String} type The string type of the event.\r\n\t * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when\r\n\t * the event is dispatched.\r\n\t * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\r\n\t * @return {Function | Object} Returns the listener for chaining or assignment.\r\n\t **/\r\n\tp.addEventListener = function(type, listener, useCapture) {\r\n\t\tvar listeners;\r\n\t\tif (useCapture) {\r\n\t\t\tlisteners = this._captureListeners = this._captureListeners||{};\r\n\t\t} else {\r\n\t\t\tlisteners = this._listeners = this._listeners||{};\r\n\t\t}\r\n\t\tvar arr = listeners[type];\r\n\t\tif (arr) { this.removeEventListener(type, listener, useCapture); }\r\n\t\tarr = listeners[type]; // remove may have deleted the array\r\n\t\tif (!arr) { listeners[type] = [listener];  }\r\n\t\telse { arr.push(listener); }\r\n\t\treturn listener;\r\n\t};\r\n\t\r\n\t/**\r\n\t * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener\r\n\t * only run once, associate arbitrary data with the listener, and remove the listener.\r\n\t * \r\n\t * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.\r\n\t * The wrapper function is returned for use with `removeEventListener` (or `off`).\r\n\t * \r\n\t * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener, or use\r\n\t * {{#crossLink \"Event/remove\"}}{{/crossLink}}. Likewise, each time you call `on` a NEW wrapper function is subscribed, so multiple calls\r\n\t * to `on` with the same params will create multiple listeners.\r\n\t * \r\n\t * <h4>Example</h4>\r\n\t * \r\n\t * \t\tvar listener = myBtn.on(\"click\", handleClick, null, false, {count:3});\r\n\t * \t\tfunction handleClick(evt, data) {\r\n\t * \t\t\tdata.count -= 1;\r\n\t * \t\t\tconsole.log(this == myBtn); // true - scope defaults to the dispatcher\r\n\t * \t\t\tif (data.count == 0) {\r\n\t * \t\t\t\talert(\"clicked 3 times!\");\r\n\t * \t\t\t\tmyBtn.off(\"click\", listener);\r\n\t * \t\t\t\t// alternately: evt.remove();\r\n\t * \t\t\t}\r\n\t * \t\t}\r\n\t * \r\n\t * @method on\r\n\t * @param {String} type The string type of the event.\r\n\t * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when\r\n\t * the event is dispatched.\r\n\t * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).\r\n\t * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.\r\n\t * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.\r\n\t * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\r\n\t * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.\r\n\t **/\r\n\tp.on = function(type, listener, scope, once, data, useCapture) {\r\n\t\tif (listener.handleEvent) {\r\n\t\t\tscope = scope||listener;\r\n\t\t\tlistener = listener.handleEvent;\r\n\t\t}\r\n\t\tscope = scope||this;\r\n\t\treturn this.addEventListener(type, function(evt) {\r\n\t\t\t\tlistener.call(scope, evt, data);\r\n\t\t\t\tonce&&evt.remove();\r\n\t\t\t}, useCapture);\r\n\t};\r\n\r\n\t/**\r\n\t * Removes the specified event listener.\r\n\t *\r\n\t * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy\r\n\t * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or\r\n\t * closure will not work.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      displayObject.removeEventListener(\"click\", handleClick);\r\n\t *\r\n\t * @method removeEventListener\r\n\t * @param {String} type The string type of the event.\r\n\t * @param {Function | Object} listener The listener function or object.\r\n\t * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\r\n\t **/\r\n\tp.removeEventListener = function(type, listener, useCapture) {\r\n\t\tvar listeners = useCapture ? this._captureListeners : this._listeners;\r\n\t\tif (!listeners) { return; }\r\n\t\tvar arr = listeners[type];\r\n\t\tif (!arr) { return; }\r\n\t\tfor (var i=0,l=arr.length; i<l; i++) {\r\n\t\t\tif (arr[i] == listener) {\r\n\t\t\t\tif (l==1) { delete(listeners[type]); } // allows for faster checks.\r\n\t\t\t\telse { arr.splice(i,1); }\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\t/**\r\n\t * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the\r\n\t * .on method.\r\n\t * \r\n\t * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener. See \r\n\t * {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}} for an example.\r\n\t *\r\n\t * @method off\r\n\t * @param {String} type The string type of the event.\r\n\t * @param {Function | Object} listener The listener function or object.\r\n\t * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\r\n\t **/\r\n\tp.off = p.removeEventListener;\r\n\r\n\t/**\r\n\t * Removes all listeners for the specified type, or all listeners of all types.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      // Remove all listeners\r\n\t *      displayObject.removeAllEventListeners();\r\n\t *\r\n\t *      // Remove all click listeners\r\n\t *      displayObject.removeAllEventListeners(\"click\");\r\n\t *\r\n\t * @method removeAllEventListeners\r\n\t * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.\r\n\t **/\r\n\tp.removeAllEventListeners = function(type) {\r\n\t\tif (!type) { this._listeners = this._captureListeners = null; }\r\n\t\telse {\r\n\t\t\tif (this._listeners) { delete(this._listeners[type]); }\r\n\t\t\tif (this._captureListeners) { delete(this._captureListeners[type]); }\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Dispatches the specified event to all listeners.\r\n\t *\r\n\t * <h4>Example</h4>\r\n\t *\r\n\t *      // Use a string event\r\n\t *      this.dispatchEvent(\"complete\");\r\n\t *\r\n\t *      // Use an Event instance\r\n\t *      var event = new createjs.Event(\"progress\");\r\n\t *      this.dispatchEvent(event);\r\n\t *\r\n\t * @method dispatchEvent\r\n\t * @param {Object | String | Event} eventObj An object with a \"type\" property, or a string type.\r\n\t * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,\r\n\t * dispatchEvent will construct an Event instance if necessary with the specified type. This latter approach can\r\n\t * be used to avoid event object instantiation for non-bubbling events that may not have any listeners.\r\n\t * @param {Boolean} [bubbles] Specifies the `bubbles` value when a string was passed to eventObj.\r\n\t * @param {Boolean} [cancelable] Specifies the `cancelable` value when a string was passed to eventObj.\r\n\t * @return {Boolean} Returns false if `preventDefault()` was called on a cancelable event, true otherwise.\r\n\t **/\r\n\tp.dispatchEvent = function(eventObj, bubbles, cancelable) {\r\n\t\tif (typeof eventObj == \"string\") {\r\n\t\t\t// skip everything if there's no listeners and it doesn't bubble:\r\n\t\t\tvar listeners = this._listeners;\r\n\t\t\tif (!bubbles && (!listeners || !listeners[eventObj])) { return true; }\r\n\t\t\teventObj = new createjs.Event(eventObj, bubbles, cancelable);\r\n\t\t} else if (eventObj.target && eventObj.clone) {\r\n\t\t\t// redispatching an active event object, so clone it:\r\n\t\t\teventObj = eventObj.clone();\r\n\t\t}\r\n\t\t\r\n\t\t// TODO: it would be nice to eliminate this. Maybe in favour of evtObj instanceof Event? Or !!evtObj.createEvent\r\n\t\ttry { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events\r\n\r\n\t\tif (!eventObj.bubbles || !this.parent) {\r\n\t\t\tthis._dispatchEvent(eventObj, 2);\r\n\t\t} else {\r\n\t\t\tvar top=this, list=[top];\r\n\t\t\twhile (top.parent) { list.push(top = top.parent); }\r\n\t\t\tvar i, l=list.length;\r\n\r\n\t\t\t// capture & atTarget\r\n\t\t\tfor (i=l-1; i>=0 && !eventObj.propagationStopped; i--) {\r\n\t\t\t\tlist[i]._dispatchEvent(eventObj, 1+(i==0));\r\n\t\t\t}\r\n\t\t\t// bubbling\r\n\t\t\tfor (i=1; i<l && !eventObj.propagationStopped; i++) {\r\n\t\t\t\tlist[i]._dispatchEvent(eventObj, 3);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn !eventObj.defaultPrevented;\r\n\t};\r\n\r\n\t/**\r\n\t * Indicates whether there is at least one listener for the specified event type.\r\n\t * @method hasEventListener\r\n\t * @param {String} type The string type of the event.\r\n\t * @return {Boolean} Returns true if there is at least one listener for the specified event.\r\n\t **/\r\n\tp.hasEventListener = function(type) {\r\n\t\tvar listeners = this._listeners, captureListeners = this._captureListeners;\r\n\t\treturn !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));\r\n\t};\r\n\t\r\n\t/**\r\n\t * Indicates whether there is at least one listener for the specified event type on this object or any of its\r\n\t * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the\r\n\t * specified type is dispatched from this object, it will trigger at least one listener.\r\n\t * \r\n\t * This is similar to {{#crossLink \"EventDispatcher/hasEventListener\"}}{{/crossLink}}, but it searches the entire\r\n\t * event flow for a listener, not just this object.\r\n\t * @method willTrigger\r\n\t * @param {String} type The string type of the event.\r\n\t * @return {Boolean} Returns `true` if there is at least one listener for the specified event.\r\n\t **/\r\n\tp.willTrigger = function(type) {\r\n\t\tvar o = this;\r\n\t\twhile (o) {\r\n\t\t\tif (o.hasEventListener(type)) { return true; }\r\n\t\t\to = o.parent;\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\r\n\t/**\r\n\t * @method toString\r\n\t * @return {String} a string representation of the instance.\r\n\t **/\r\n\tp.toString = function() {\r\n\t\treturn \"[EventDispatcher]\";\r\n\t};\r\n\r\n\r\n// private methods:\r\n\t/**\r\n\t * @method _dispatchEvent\r\n\t * @param {Object | Event} eventObj\r\n\t * @param {Object} eventPhase\r\n\t * @protected\r\n\t **/\r\n\tp._dispatchEvent = function(eventObj, eventPhase) {\r\n\t\tvar l, arr, listeners = (eventPhase <= 2) ? this._captureListeners : this._listeners;\r\n\t\tif (eventObj && listeners && (arr = listeners[eventObj.type]) && (l=arr.length)) {\r\n\t\t\ttry { eventObj.currentTarget = this; } catch (e) {}\r\n\t\t\ttry { eventObj.eventPhase = eventPhase|0; } catch (e) {}\r\n\t\t\teventObj.removed = false;\r\n\t\t\t\r\n\t\t\tarr = arr.slice(); // to avoid issues with items being removed or added during the dispatch\r\n\t\t\tfor (var i=0; i<l && !eventObj.immediatePropagationStopped; i++) {\r\n\t\t\t\tvar o = arr[i];\r\n\t\t\t\tif (o.handleEvent) { o.handleEvent(eventObj); }\r\n\t\t\t\telse { o(eventObj); }\r\n\t\t\t\tif (eventObj.removed) {\r\n\t\t\t\t\tthis.off(eventObj.type, o, eventPhase==1);\r\n\t\t\t\t\teventObj.removed = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (eventPhase === 2) { this._dispatchEvent(eventObj, 2.1); }\r\n\t};\r\n\r\n\r\n\tcreatejs.EventDispatcher = EventDispatcher;\r\n}());\n\n//##############################################################################\n// ProgressEvent.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function (scope) {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A CreateJS {{#crossLink \"Event\"}}{{/crossLink}} that is dispatched when progress changes.\n\t * @class ProgressEvent\n\t * @param {Number} loaded The amount that has been loaded. This can be any number relative to the total.\n\t * @param {Number} [total=1] The total amount that will load. This will default to 1, so if the `loaded` value is\n\t * a percentage (between 0 and 1), it can be omitted.\n\t * @todo Consider having this event be a \"fileprogress\" event as well\n\t * @constructor\n\t */\n\tfunction ProgressEvent(loaded, total) {\n\t\tthis.Event_constructor(\"progress\");\n\n\t\t/**\n\t\t * The amount that has been loaded (out of a total amount)\n\t\t * @property loaded\n\t\t * @type {Number}\n\t\t */\n\t\tthis.loaded = loaded;\n\n\t\t/**\n\t\t * The total \"size\" of the load.\n\t\t * @property total\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.total = (total == null) ? 1 : total;\n\n\t\t/**\n\t\t * The percentage (out of 1) that the load has been completed. This is calculated using `loaded/total`.\n\t\t * @property progress\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.progress = (total == 0) ? 0 : this.loaded / this.total;\n\t};\n\n\tvar p = createjs.extend(ProgressEvent, createjs.Event);\n\n\t/**\n\t * Returns a clone of the ProgressEvent instance.\n\t * @method clone\n\t * @return {ProgressEvent} a clone of the Event instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new createjs.ProgressEvent(this.loaded, this.total);\n\t};\n\n\tcreatejs.ProgressEvent = createjs.promote(ProgressEvent, \"Event\");\n\n}(window));\n\n//##############################################################################\n// json3.js\n//##############################################################################\n\n/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */\n;(function () {\n  // Detect the `define` function exposed by asynchronous module loaders. The\n  // strict `define` check is necessary for compatibility with `r.js`.\n  var isLoader =  true && __webpack_require__(/*! !webpack amd options */ \"PDX0\");\n\n  // A set of types used to distinguish objects from primitives.\n  var objectTypes = {\n    \"function\": true,\n    \"object\": true\n  };\n\n  // Detect the `exports` object exposed by CommonJS implementations.\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n  // Use the `global` object exposed by Node (including Browserify via\n  // `insert-module-globals`), Narwhal, and Ringo as the default context,\n  // and the `window` object in browsers. Rhino exports a `global` function\n  // instead.\n  var root = objectTypes[typeof window] && window || this,\n      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == \"object\" && global;\n\n  if (freeGlobal && (freeGlobal[\"global\"] === freeGlobal || freeGlobal[\"window\"] === freeGlobal || freeGlobal[\"self\"] === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  // Public: Initializes JSON 3 using the given `context` object, attaching the\n  // `stringify` and `parse` functions to the specified `exports` object.\n  function runInContext(context, exports) {\n    context || (context = root[\"Object\"]());\n    exports || (exports = root[\"Object\"]());\n\n    // Native constructor aliases.\n    var Number = context[\"Number\"] || root[\"Number\"],\n        String = context[\"String\"] || root[\"String\"],\n        Object = context[\"Object\"] || root[\"Object\"],\n        Date = context[\"Date\"] || root[\"Date\"],\n        SyntaxError = context[\"SyntaxError\"] || root[\"SyntaxError\"],\n        TypeError = context[\"TypeError\"] || root[\"TypeError\"],\n        Math = context[\"Math\"] || root[\"Math\"],\n        nativeJSON = context[\"JSON\"] || root[\"JSON\"];\n\n    // Delegate to the native `stringify` and `parse` implementations.\n    if (typeof nativeJSON == \"object\" && nativeJSON) {\n      exports.stringify = nativeJSON.stringify;\n      exports.parse = nativeJSON.parse;\n    }\n\n    // Convenience aliases.\n    var objectProto = Object.prototype,\n        getClass = objectProto.toString,\n        isProperty, forEach, undef;\n\n    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\n    var isExtended = new Date(-3509827334573292);\n    try {\n      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\n      // results for certain dates in Opera >= 10.53.\n      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\n        // Safari < 2.0.2 stores the internal millisecond time value correctly,\n        // but clips the values returned by the date methods to the range of\n        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\n        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\n    } catch (exception) {}\n\n    // Internal: Determines whether the native `JSON.stringify` and `parse`\n    // implementations are spec-compliant. Based on work by Ken Snyder.\n    function has(name) {\n      if (has[name] !== undef) {\n        // Return cached feature test result.\n        return has[name];\n      }\n      var isSupported;\n      if (name == \"bug-string-char-index\") {\n        // IE <= 7 doesn't support accessing string characters using square\n        // bracket notation. IE 8 only supports this for primitives.\n        isSupported = \"a\"[0] != \"a\";\n      } else if (name == \"json\") {\n        // Indicates whether both `JSON.stringify` and `JSON.parse` are\n        // supported.\n        isSupported = has(\"json-stringify\") && has(\"json-parse\");\n      } else {\n        var value, serialized = '{\"a\":[1,true,false,null,\"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t\"]}';\n        // Test `JSON.stringify`.\n        if (name == \"json-stringify\") {\n          var stringify = exports.stringify, stringifySupported = typeof stringify == \"function\" && isExtended;\n          if (stringifySupported) {\n            // A test function object with a custom `toJSON` method.\n            (value = function () {\n              return 1;\n            }).toJSON = value;\n            try {\n              stringifySupported =\n                // Firefox 3.1b1 and b2 serialize string, number, and boolean\n                // primitives as object literals.\n                stringify(0) === \"0\" &&\n                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\n                // literals.\n                stringify(new Number()) === \"0\" &&\n                stringify(new String()) == '\"\"' &&\n                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\n                // does not define a canonical JSON representation (this applies to\n                // objects with `toJSON` properties as well, *unless* they are nested\n                // within an object or array).\n                stringify(getClass) === undef &&\n                // IE 8 serializes `undefined` as `\"undefined\"`. Safari <= 5.1.7 and\n                // FF 3.1b3 pass this test.\n                stringify(undef) === undef &&\n                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\n                // respectively, if the value is omitted entirely.\n                stringify() === undef &&\n                // FF 3.1b1, 2 throw an error if the given value is not a number,\n                // string, array, object, Boolean, or `null` literal. This applies to\n                // objects with custom `toJSON` methods as well, unless they are nested\n                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\n                // methods entirely.\n                stringify(value) === \"1\" &&\n                stringify([value]) == \"[1]\" &&\n                // Prototype <= 1.6.1 serializes `[undefined]` as `\"[]\"` instead of\n                // `\"[null]\"`.\n                stringify([undef]) == \"[null]\" &&\n                // YUI 3.0.0b1 fails to serialize `null` literals.\n                stringify(null) == \"null\" &&\n                // FF 3.1b1, 2 halts serialization if an array contains a function:\n                // `[1, true, getClass, 1]` serializes as \"[1,true,],\". FF 3.1b3\n                // elides non-JSON values from objects and arrays, unless they\n                // define custom `toJSON` methods.\n                stringify([undef, getClass, null]) == \"[null,null,null]\" &&\n                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\n                // where character escape codes are expected (e.g., `\\b` => `\\u0008`).\n                stringify({ \"a\": [value, true, false, null, \"\\x00\\b\\n\\f\\r\\t\"] }) == serialized &&\n                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\n                stringify(null, value) === \"1\" &&\n                stringify([1, 2], null, 1) == \"[\\n 1,\\n 2\\n]\" &&\n                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\n                // serialize extended years.\n                stringify(new Date(-8.64e15)) == '\"-271821-04-20T00:00:00.000Z\"' &&\n                // The milliseconds are optional in ES 5, but required in 5.1.\n                stringify(new Date(8.64e15)) == '\"+275760-09-13T00:00:00.000Z\"' &&\n                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\n                // four-digit years instead of six-digit years. Credits: @Yaffle.\n                stringify(new Date(-621987552e5)) == '\"-000001-01-01T00:00:00.000Z\"' &&\n                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\n                // values less than 1000. Credits: @Yaffle.\n                stringify(new Date(-1)) == '\"1969-12-31T23:59:59.999Z\"';\n            } catch (exception) {\n              stringifySupported = false;\n            }\n          }\n          isSupported = stringifySupported;\n        }\n        // Test `JSON.parse`.\n        if (name == \"json-parse\") {\n          var parse = exports.parse;\n          if (typeof parse == \"function\") {\n            try {\n              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\n              // Conforming implementations should also coerce the initial argument to\n              // a string prior to parsing.\n              if (parse(\"0\") === 0 && !parse(false)) {\n                // Simple parsing test.\n                value = parse(serialized);\n                var parseSupported = value[\"a\"].length == 5 && value[\"a\"][0] === 1;\n                if (parseSupported) {\n                  try {\n                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\n                    parseSupported = !parse('\"\\t\"');\n                  } catch (exception) {}\n                  if (parseSupported) {\n                    try {\n                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading\n                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\n                      // certain octal literals.\n                      parseSupported = parse(\"01\") !== 1;\n                    } catch (exception) {}\n                  }\n                  if (parseSupported) {\n                    try {\n                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\n                      // points. These environments, along with FF 3.1b1 and 2,\n                      // also allow trailing commas in JSON objects and arrays.\n                      parseSupported = parse(\"1.\") !== 1;\n                    } catch (exception) {}\n                  }\n                }\n              }\n            } catch (exception) {\n              parseSupported = false;\n            }\n          }\n          isSupported = parseSupported;\n        }\n      }\n      return has[name] = !!isSupported;\n    }\n\n    if (!has(\"json\")) {\n      // Common `[[Class]]` name aliases.\n      var functionClass = \"[object Function]\",\n          dateClass = \"[object Date]\",\n          numberClass = \"[object Number]\",\n          stringClass = \"[object String]\",\n          arrayClass = \"[object Array]\",\n          booleanClass = \"[object Boolean]\";\n\n      // Detect incomplete support for accessing string characters by index.\n      var charIndexBuggy = has(\"bug-string-char-index\");\n\n      // Define additional utility methods if the `Date` methods are buggy.\n      if (!isExtended) {\n        var floor = Math.floor;\n        // A mapping between the months of the year and the number of days between\n        // January 1st and the first of the respective month.\n        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n        // Internal: Calculates the number of days between the Unix epoch and the\n        // first day of the given month.\n        var getDay = function (year, month) {\n          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\n        };\n      }\n\n      // Internal: Determines if a property is a direct property of the given\n      // object. Delegates to the native `Object#hasOwnProperty` method.\n      if (!(isProperty = objectProto.hasOwnProperty)) {\n        isProperty = function (property) {\n          var members = {}, constructor;\n          if ((members.__proto__ = null, members.__proto__ = {\n            // The *proto* property cannot be set multiple times in recent\n            // versions of Firefox and SeaMonkey.\n            \"toString\": 1\n          }, members).toString != getClass) {\n            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but\n            // supports the mutable *proto* property.\n            isProperty = function (property) {\n              // Capture and break the object's prototype chain (see section 8.6.2\n              // of the ES 5.1 spec). The parenthesized expression prevents an\n              // unsafe transformation by the Closure Compiler.\n              var original = this.__proto__, result = property in (this.__proto__ = null, this);\n              // Restore the original prototype chain.\n              this.__proto__ = original;\n              return result;\n            };\n          } else {\n            // Capture a reference to the top-level `Object` constructor.\n            constructor = members.constructor;\n            // Use the `constructor` property to simulate `Object#hasOwnProperty` in\n            // other environments.\n            isProperty = function (property) {\n              var parent = (this.constructor || constructor).prototype;\n              return property in this && !(property in parent && this[property] === parent[property]);\n            };\n          }\n          members = null;\n          return isProperty.call(this, property);\n        };\n      }\n\n      // Internal: Normalizes the `for...in` iteration algorithm across\n      // environments. Each enumerated key is yielded to a `callback` function.\n      forEach = function (object, callback) {\n        var size = 0, Properties, members, property;\n\n        // Tests for bugs in the current environment's `for...in` algorithm. The\n        // `valueOf` property inherits the non-enumerable flag from\n        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\n        (Properties = function () {\n          this.valueOf = 0;\n        }).prototype.valueOf = 0;\n\n        // Iterate over a new instance of the `Properties` class.\n        members = new Properties();\n        for (property in members) {\n          // Ignore all properties inherited from `Object.prototype`.\n          if (isProperty.call(members, property)) {\n            size++;\n          }\n        }\n        Properties = members = null;\n\n        // Normalize the iteration algorithm.\n        if (!size) {\n          // A list of non-enumerable properties inherited from `Object.prototype`.\n          members = [\"valueOf\", \"toString\", \"toLocaleString\", \"propertyIsEnumerable\", \"isPrototypeOf\", \"hasOwnProperty\", \"constructor\"];\n          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\n          // properties.\n          forEach = function (object, callback) {\n            var isFunction = getClass.call(object) == functionClass, property, length;\n            var hasProperty = !isFunction && typeof object.constructor != \"function\" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;\n            for (property in object) {\n              // Gecko <= 1.0 enumerates the `prototype` property of functions under\n              // certain conditions; IE does not.\n              if (!(isFunction && property == \"prototype\") && hasProperty.call(object, property)) {\n                callback(property);\n              }\n            }\n            // Manually invoke the callback for each non-enumerable property.\n            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));\n          };\n        } else if (size == 2) {\n          // Safari <= 2.0.4 enumerates shadowed properties twice.\n          forEach = function (object, callback) {\n            // Create a set of iterated properties.\n            var members = {}, isFunction = getClass.call(object) == functionClass, property;\n            for (property in object) {\n              // Store each property name to prevent double enumeration. The\n              // `prototype` property of functions is not enumerated due to cross-\n              // environment inconsistencies.\n              if (!(isFunction && property == \"prototype\") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\n                callback(property);\n              }\n            }\n          };\n        } else {\n          // No bugs detected; use the standard `for...in` algorithm.\n          forEach = function (object, callback) {\n            var isFunction = getClass.call(object) == functionClass, property, isConstructor;\n            for (property in object) {\n              if (!(isFunction && property == \"prototype\") && isProperty.call(object, property) && !(isConstructor = property === \"constructor\")) {\n                callback(property);\n              }\n            }\n            // Manually invoke the callback for the `constructor` property due to\n            // cross-environment inconsistencies.\n            if (isConstructor || isProperty.call(object, (property = \"constructor\"))) {\n              callback(property);\n            }\n          };\n        }\n        return forEach(object, callback);\n      };\n\n      // Public: Serializes a JavaScript `value` as a JSON string. The optional\n      // `filter` argument may specify either a function that alters how object and\n      // array members are serialized, or an array of strings and numbers that\n      // indicates which properties should be serialized. The optional `width`\n      // argument may be either a string or number that specifies the indentation\n      // level of the output.\n      if (!has(\"json-stringify\")) {\n        // Internal: A map of control characters and their escaped equivalents.\n        var Escapes = {\n          92: \"\\\\\\\\\",\n          34: '\\\\\"',\n          8: \"\\\\b\",\n          12: \"\\\\f\",\n          10: \"\\\\n\",\n          13: \"\\\\r\",\n          9: \"\\\\t\"\n        };\n\n        // Internal: Converts `value` into a zero-padded string such that its\n        // length is at least equal to `width`. The `width` must be <= 6.\n        var leadingZeroes = \"000000\";\n        var toPaddedString = function (width, value) {\n          // The `|| 0` expression is necessary to work around a bug in\n          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== \"0\"`.\n          return (leadingZeroes + (value || 0)).slice(-width);\n        };\n\n        // Internal: Double-quotes a string `value`, replacing all ASCII control\n        // characters (characters with code unit values between 0 and 31) with\n        // their escaped equivalents. This is an implementation of the\n        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\n        var unicodePrefix = \"\\\\u00\";\n        var quote = function (value) {\n          var result = '\"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;\n          var symbols = useCharIndex && (charIndexBuggy ? value.split(\"\") : value);\n          for (; index < length; index++) {\n            var charCode = value.charCodeAt(index);\n            // If the character is a control character, append its Unicode or\n            // shorthand escape sequence; otherwise, append the character as-is.\n            switch (charCode) {\n              case 8: case 9: case 10: case 12: case 13: case 34: case 92:\n                result += Escapes[charCode];\n                break;\n              default:\n                if (charCode < 32) {\n                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));\n                  break;\n                }\n                result += useCharIndex ? symbols[index] : value.charAt(index);\n            }\n          }\n          return result + '\"';\n        };\n\n        // Internal: Recursively serializes an object. Implements the\n        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\n        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\n          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\n          try {\n            // Necessary for host object support.\n            value = object[property];\n          } catch (exception) {}\n          if (typeof value == \"object\" && value) {\n            className = getClass.call(value);\n            if (className == dateClass && !isProperty.call(value, \"toJSON\")) {\n              if (value > -1 / 0 && value < 1 / 0) {\n                // Dates are serialized according to the `Date#toJSON` method\n                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\n                // for the ISO 8601 date time string format.\n                if (getDay) {\n                  // Manually compute the year, month, date, hours, minutes,\n                  // seconds, and milliseconds if the `getUTC*` methods are\n                  // buggy. Adapted from @Yaffle's `date-shim` project.\n                  date = floor(value / 864e5);\n                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\n                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\n                  date = 1 + date - getDay(year, month);\n                  // The `time` value specifies the time within the day (see ES\n                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\n                  // to compute `A modulo B`, as the `%` operator does not\n                  // correspond to the `modulo` operation for negative numbers.\n                  time = (value % 864e5 + 864e5) % 864e5;\n                  // The hours, minutes, seconds, and milliseconds are obtained by\n                  // decomposing the time within the day. See section 15.9.1.10.\n                  hours = floor(time / 36e5) % 24;\n                  minutes = floor(time / 6e4) % 60;\n                  seconds = floor(time / 1e3) % 60;\n                  milliseconds = time % 1e3;\n                } else {\n                  year = value.getUTCFullYear();\n                  month = value.getUTCMonth();\n                  date = value.getUTCDate();\n                  hours = value.getUTCHours();\n                  minutes = value.getUTCMinutes();\n                  seconds = value.getUTCSeconds();\n                  milliseconds = value.getUTCMilliseconds();\n                }\n                // Serialize extended years correctly.\n                value = (year <= 0 || year >= 1e4 ? (year < 0 ? \"-\" : \"+\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +\n                  \"-\" + toPaddedString(2, month + 1) + \"-\" + toPaddedString(2, date) +\n                  // Months, dates, hours, minutes, and seconds should have two\n                  // digits; milliseconds should have three.\n                  \"T\" + toPaddedString(2, hours) + \":\" + toPaddedString(2, minutes) + \":\" + toPaddedString(2, seconds) +\n                  // Milliseconds are optional in ES 5.0, but required in 5.1.\n                  \".\" + toPaddedString(3, milliseconds) + \"Z\";\n              } else {\n                value = null;\n              }\n            } else if (typeof value.toJSON == \"function\" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, \"toJSON\"))) {\n              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\n              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\n              // ignores all `toJSON` methods on these objects unless they are\n              // defined directly on an instance.\n              value = value.toJSON(property);\n            }\n          }\n          if (callback) {\n            // If a replacement function was provided, call it to obtain the value\n            // for serialization.\n            value = callback.call(object, property, value);\n          }\n          if (value === null) {\n            return \"null\";\n          }\n          className = getClass.call(value);\n          if (className == booleanClass) {\n            // Booleans are represented literally.\n            return \"\" + value;\n          } else if (className == numberClass) {\n            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\n            // `\"null\"`.\n            return value > -1 / 0 && value < 1 / 0 ? \"\" + value : \"null\";\n          } else if (className == stringClass) {\n            // Strings are double-quoted and escaped.\n            return quote(\"\" + value);\n          }\n          // Recursively serialize objects and arrays.\n          if (typeof value == \"object\") {\n            // Check for cyclic structures. This is a linear search; performance\n            // is inversely proportional to the number of unique nested objects.\n            for (length = stack.length; length--;) {\n              if (stack[length] === value) {\n                // Cyclic structures cannot be serialized by `JSON.stringify`.\n                throw TypeError();\n              }\n            }\n            // Add the object to the stack of traversed objects.\n            stack.push(value);\n            results = [];\n            // Save the current indentation level and indent one additional level.\n            prefix = indentation;\n            indentation += whitespace;\n            if (className == arrayClass) {\n              // Recursively serialize array elements.\n              for (index = 0, length = value.length; index < length; index++) {\n                element = serialize(index, value, callback, properties, whitespace, indentation, stack);\n                results.push(element === undef ? \"null\" : element);\n              }\n              result = results.length ? (whitespace ? \"[\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"]\" : (\"[\" + results.join(\",\") + \"]\")) : \"[]\";\n            } else {\n              // Recursively serialize object members. Members are selected from\n              // either a user-specified list of property names, or the object\n              // itself.\n              forEach(properties || value, function (property) {\n                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\n                if (element !== undef) {\n                  // According to ES 5.1 section 15.12.3: \"If `gap` {whitespace}\n                  // is not the empty string, let `member` {quote(property) + \":\"}\n                  // be the concatenation of `member` and the `space` character.\"\n                  // The \"`space` character\" refers to the literal space\n                  // character, not the `space` {width} argument provided to\n                  // `JSON.stringify`.\n                  results.push(quote(property) + \":\" + (whitespace ? \" \" : \"\") + element);\n                }\n              });\n              result = results.length ? (whitespace ? \"{\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"}\" : (\"{\" + results.join(\",\") + \"}\")) : \"{}\";\n            }\n            // Remove the object from the traversed object stack.\n            stack.pop();\n            return result;\n          }\n        };\n\n        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\n        exports.stringify = function (source, filter, width) {\n          var whitespace, callback, properties, className;\n          if (objectTypes[typeof filter] && filter) {\n            if ((className = getClass.call(filter)) == functionClass) {\n              callback = filter;\n            } else if (className == arrayClass) {\n              // Convert the property names array into a makeshift set.\n              properties = {};\n              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));\n            }\n          }\n          if (width) {\n            if ((className = getClass.call(width)) == numberClass) {\n              // Convert the `width` to an integer and create a string containing\n              // `width` number of space characters.\n              if ((width -= width % 1) > 0) {\n                for (whitespace = \"\", width > 10 && (width = 10); whitespace.length < width; whitespace += \" \");\n              }\n            } else if (className == stringClass) {\n              whitespace = width.length <= 10 ? width : width.slice(0, 10);\n            }\n          }\n          // Opera <= 7.54u2 discards the values associated with empty string keys\n          // (`\"\"`) only if they are used directly within an object member list\n          // (e.g., `!(\"\" in { \"\": 1})`).\n          return serialize(\"\", (value = {}, value[\"\"] = source, value), callback, properties, whitespace, \"\", []);\n        };\n      }\n\n      // Public: Parses a JSON source string.\n      if (!has(\"json-parse\")) {\n        var fromCharCode = String.fromCharCode;\n\n        // Internal: A map of escaped control characters and their unescaped\n        // equivalents.\n        var Unescapes = {\n          92: \"\\\\\",\n          34: '\"',\n          47: \"/\",\n          98: \"\\b\",\n          116: \"\\t\",\n          110: \"\\n\",\n          102: \"\\f\",\n          114: \"\\r\"\n        };\n\n        // Internal: Stores the parser state.\n        var Index, Source;\n\n        // Internal: Resets the parser state and throws a `SyntaxError`.\n        var abort = function () {\n          Index = Source = null;\n          throw SyntaxError();\n        };\n\n        // Internal: Returns the next token, or `\"$\"` if the parser has reached\n        // the end of the source string. A token may be a string, number, `null`\n        // literal, or Boolean literal.\n        var lex = function () {\n          var source = Source, length = source.length, value, begin, position, isSigned, charCode;\n          while (Index < length) {\n            charCode = source.charCodeAt(Index);\n            switch (charCode) {\n              case 9: case 10: case 13: case 32:\n                // Skip whitespace tokens, including tabs, carriage returns, line\n                // feeds, and space characters.\n                Index++;\n                break;\n              case 123: case 125: case 91: case 93: case 58: case 44:\n                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\n                // the current position.\n                value = charIndexBuggy ? source.charAt(Index) : source[Index];\n                Index++;\n                return value;\n              case 34:\n                // `\"` delimits a JSON string; advance to the next character and\n                // begin parsing the string. String tokens are prefixed with the\n                // sentinel `@` character to distinguish them from punctuators and\n                // end-of-string tokens.\n                for (value = \"@\", Index++; Index < length;) {\n                  charCode = source.charCodeAt(Index);\n                  if (charCode < 32) {\n                    // Unescaped ASCII control characters (those with a code unit\n                    // less than the space character) are not permitted.\n                    abort();\n                  } else if (charCode == 92) {\n                    // A reverse solidus (`\\`) marks the beginning of an escaped\n                    // control character (including `\"`, `\\`, and `/`) or Unicode\n                    // escape sequence.\n                    charCode = source.charCodeAt(++Index);\n                    switch (charCode) {\n                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:\n                        // Revive escaped control characters.\n                        value += Unescapes[charCode];\n                        Index++;\n                        break;\n                      case 117:\n                        // `\\u` marks the beginning of a Unicode escape sequence.\n                        // Advance to the first character and validate the\n                        // four-digit code point.\n                        begin = ++Index;\n                        for (position = Index + 4; Index < position; Index++) {\n                          charCode = source.charCodeAt(Index);\n                          // A valid sequence comprises four hexdigits (case-\n                          // insensitive) that form a single hexadecimal value.\n                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\n                            // Invalid Unicode escape sequence.\n                            abort();\n                          }\n                        }\n                        // Revive the escaped character.\n                        value += fromCharCode(\"0x\" + source.slice(begin, Index));\n                        break;\n                      default:\n                        // Invalid escape sequence.\n                        abort();\n                    }\n                  } else {\n                    if (charCode == 34) {\n                      // An unescaped double-quote character marks the end of the\n                      // string.\n                      break;\n                    }\n                    charCode = source.charCodeAt(Index);\n                    begin = Index;\n                    // Optimize for the common case where a string is valid.\n                    while (charCode >= 32 && charCode != 92 && charCode != 34) {\n                      charCode = source.charCodeAt(++Index);\n                    }\n                    // Append the string as-is.\n                    value += source.slice(begin, Index);\n                  }\n                }\n                if (source.charCodeAt(Index) == 34) {\n                  // Advance to the next character and return the revived string.\n                  Index++;\n                  return value;\n                }\n                // Unterminated string.\n                abort();\n              default:\n                // Parse numbers and literals.\n                begin = Index;\n                // Advance past the negative sign, if one is specified.\n                if (charCode == 45) {\n                  isSigned = true;\n                  charCode = source.charCodeAt(++Index);\n                }\n                // Parse an integer or floating-point value.\n                if (charCode >= 48 && charCode <= 57) {\n                  // Leading zeroes are interpreted as octal literals.\n                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {\n                    // Illegal octal literal.\n                    abort();\n                  }\n                  isSigned = false;\n                  // Parse the integer component.\n                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);\n                  // Floats cannot contain a leading decimal point; however, this\n                  // case is already accounted for by the parser.\n                  if (source.charCodeAt(Index) == 46) {\n                    position = ++Index;\n                    // Parse the decimal component.\n                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                    if (position == Index) {\n                      // Illegal trailing decimal.\n                      abort();\n                    }\n                    Index = position;\n                  }\n                  // Parse exponents. The `e` denoting the exponent is\n                  // case-insensitive.\n                  charCode = source.charCodeAt(Index);\n                  if (charCode == 101 || charCode == 69) {\n                    charCode = source.charCodeAt(++Index);\n                    // Skip past the sign following the exponent, if one is\n                    // specified.\n                    if (charCode == 43 || charCode == 45) {\n                      Index++;\n                    }\n                    // Parse the exponential component.\n                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                    if (position == Index) {\n                      // Illegal empty exponent.\n                      abort();\n                    }\n                    Index = position;\n                  }\n                  // Coerce the parsed value to a JavaScript number.\n                  return +source.slice(begin, Index);\n                }\n                // A negative sign may only precede numbers.\n                if (isSigned) {\n                  abort();\n                }\n                // `true`, `false`, and `null` literals.\n                if (source.slice(Index, Index + 4) == \"true\") {\n                  Index += 4;\n                  return true;\n                } else if (source.slice(Index, Index + 5) == \"false\") {\n                  Index += 5;\n                  return false;\n                } else if (source.slice(Index, Index + 4) == \"null\") {\n                  Index += 4;\n                  return null;\n                }\n                // Unrecognized token.\n                abort();\n            }\n          }\n          // Return the sentinel `$` character if the parser has reached the end\n          // of the source string.\n          return \"$\";\n        };\n\n        // Internal: Parses a JSON `value` token.\n        var get = function (value) {\n          var results, hasMembers;\n          if (value == \"$\") {\n            // Unexpected end of input.\n            abort();\n          }\n          if (typeof value == \"string\") {\n            if ((charIndexBuggy ? value.charAt(0) : value[0]) == \"@\") {\n              // Remove the sentinel `@` character.\n              return value.slice(1);\n            }\n            // Parse object and array literals.\n            if (value == \"[\") {\n              // Parses a JSON array, returning a new JavaScript array.\n              results = [];\n              for (;; hasMembers || (hasMembers = true)) {\n                value = lex();\n                // A closing square bracket marks the end of the array literal.\n                if (value == \"]\") {\n                  break;\n                }\n                // If the array literal contains elements, the current token\n                // should be a comma separating the previous element from the\n                // next.\n                if (hasMembers) {\n                  if (value == \",\") {\n                    value = lex();\n                    if (value == \"]\") {\n                      // Unexpected trailing `,` in array literal.\n                      abort();\n                    }\n                  } else {\n                    // A `,` must separate each array element.\n                    abort();\n                  }\n                }\n                // Elisions and leading commas are not permitted.\n                if (value == \",\") {\n                  abort();\n                }\n                results.push(get(value));\n              }\n              return results;\n            } else if (value == \"{\") {\n              // Parses a JSON object, returning a new JavaScript object.\n              results = {};\n              for (;; hasMembers || (hasMembers = true)) {\n                value = lex();\n                // A closing curly brace marks the end of the object literal.\n                if (value == \"}\") {\n                  break;\n                }\n                // If the object literal contains members, the current token\n                // should be a comma separator.\n                if (hasMembers) {\n                  if (value == \",\") {\n                    value = lex();\n                    if (value == \"}\") {\n                      // Unexpected trailing `,` in object literal.\n                      abort();\n                    }\n                  } else {\n                    // A `,` must separate each object member.\n                    abort();\n                  }\n                }\n                // Leading commas are not permitted, object property names must be\n                // double-quoted strings, and a `:` must separate each property\n                // name and value.\n                if (value == \",\" || typeof value != \"string\" || (charIndexBuggy ? value.charAt(0) : value[0]) != \"@\" || lex() != \":\") {\n                  abort();\n                }\n                results[value.slice(1)] = get(lex());\n              }\n              return results;\n            }\n            // Unexpected token encountered.\n            abort();\n          }\n          return value;\n        };\n\n        // Internal: Updates a traversed object member.\n        var update = function (source, property, callback) {\n          var element = walk(source, property, callback);\n          if (element === undef) {\n            delete source[property];\n          } else {\n            source[property] = element;\n          }\n        };\n\n        // Internal: Recursively traverses a parsed JSON object, invoking the\n        // `callback` function for each value. This is an implementation of the\n        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\n        var walk = function (source, property, callback) {\n          var value = source[property], length;\n          if (typeof value == \"object\" && value) {\n            // `forEach` can't be used to traverse an array in Opera <= 8.54\n            // because its `Object#hasOwnProperty` implementation returns `false`\n            // for array indices (e.g., `![1, 2, 3].hasOwnProperty(\"0\")`).\n            if (getClass.call(value) == arrayClass) {\n              for (length = value.length; length--;) {\n                update(value, length, callback);\n              }\n            } else {\n              forEach(value, function (property) {\n                update(value, property, callback);\n              });\n            }\n          }\n          return callback.call(source, property, value);\n        };\n\n        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\n        exports.parse = function (source, callback) {\n          var result, value;\n          Index = 0;\n          Source = \"\" + source;\n          result = get(lex());\n          // If a JSON string contains multiple tokens, it is invalid.\n          if (lex() != \"$\") {\n            abort();\n          }\n          // Reset the parser state.\n          Index = Source = null;\n          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\"\"] = result, value), \"\", callback) : result;\n        };\n      }\n    }\n\n    exports[\"runInContext\"] = runInContext;\n    return exports;\n  }\n\n  if (freeExports && !isLoader) {\n    // Export for CommonJS environments.\n    runInContext(root, freeExports);\n  } else {\n    // Export for web browsers and JavaScript engines.\n    var nativeJSON = root.JSON,\n        previousJSON = root[\"JSON3\"],\n        isRestored = false;\n\n    var JSON3 = runInContext(root, (root[\"JSON3\"] = {\n      // Public: Restores the original value of the global `JSON` object and\n      // returns a reference to the `JSON3` object.\n      \"noConflict\": function () {\n        if (!isRestored) {\n          isRestored = true;\n          root.JSON = nativeJSON;\n          root[\"JSON3\"] = previousJSON;\n          nativeJSON = previousJSON = null;\n        }\n        return JSON3;\n      }\n    }));\n\n    root.JSON = {\n      \"parse\": JSON3.parse,\n      \"stringify\": JSON3.stringify\n    };\n  }\n\n  // Export for asynchronous module loaders.\n  if (isLoader) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return JSON3;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n}).call(this);\n\n//##############################################################################\n// Elements.js\n//##############################################################################\n\n(function () {\n\n\t/**\n\t * Convenience methods for creating various elements used by PrelaodJS.\n\t *\n\t * @class DomUtils\n\t */\n\tvar s = {};\n\n\ts.a = function() {\n\t\treturn s.el(\"a\");\n\t}\n\n\ts.svg = function() {\n\t\treturn s.el(\"svg\");\n\t}\n\n\ts.object = function() {\n\t\treturn s.el(\"object\");\n\t}\n\n\ts.image = function() {\n\t\treturn s.el(\"image\");\n\t}\n\n\ts.img = function() {\n\t\treturn s.el(\"img\");\n\t}\n\n\ts.style = function() {\n\t\treturn s.el(\"style\");\n\t}\n\n\ts.link = function() {\n\t\treturn s.el(\"link\");\n\t}\n\n\ts.script = function() {\n\t\treturn s.el(\"script\");\n\t}\n\n\ts.audio = function() {\n\t\treturn s.el(\"audio\");\n\t}\n\n\ts.video = function() {\n\t\treturn s.el(\"video\");\n\t}\n\n\ts.text = function(value) {\n\t\treturn document.createTextNode(value);\n\t}\n\n\ts.el = function(name) {\n\t\treturn document.createElement(name);\n\t}\n\n\tcreatejs.Elements = s;\n\n}());\n\n//##############################################################################\n// URLUtils.js\n//##############################################################################\n\n(function () {\n\n\t/**\n\t * Utilities that assist with parsing load items, and determining file types, etc.\n\t * @class URLUtils\n\t */\n\tvar s = {};\n\n\t/**\n\t * The Regular Expression used to test file URLS for an absolute path.\n\t * @property ABSOLUTE_PATH\n\t * @type {RegExp}\n\t * @static\n\t */\n\ts.ABSOLUTE_PATT = /^(?:\\w+:)?\\/{2}/i;\n\n\t/**\n\t * The Regular Expression used to test file URLS for a relative path.\n\t * @property RELATIVE_PATH\n\t * @type {RegExp}\n\t * @static\n\t */\n\ts.RELATIVE_PATT = (/^[./]*?\\//i);\n\n\t/**\n\t * The Regular Expression used to test file URLS for an extension. Note that URIs must already have the query string\n\t * removed.\n\t * @property EXTENSION_PATT\n\t * @type {RegExp}\n\t * @static\n\t */\n\ts.EXTENSION_PATT = /\\/?[^/]+\\.(\\w{1,5})$/i;\n\n\t/**\n\t * Parse a file path to determine the information we need to work with it. Currently, PreloadJS needs to know:\n\t * <ul>\n\t *     <li>If the path is absolute. Absolute paths start with a protocol (such as `http://`, `file://`, or\n\t *     `//networkPath`)</li>\n\t *     <li>If the path is relative. Relative paths start with `../` or `/path` (or similar)</li>\n\t *     <li>The file extension. This is determined by the filename with an extension. Query strings are dropped, and\n\t *     the file path is expected to follow the format `name.ext`.</li>\n\t * </ul>\n\t *\n\t * @method parseURI\n\t * @param {String} path\n\t * @returns {Object} An Object with an `absolute` and `relative` Boolean values,\n\t * \tthe pieces of the path (protocol, hostname, port, pathname, search, hash, host)\n\t * \tas well as an optional 'extension` property, which is the lowercase extension.\n\t *\n\t * @static\n\t */\n\ts.parseURI = function (path) {\n\t\tvar info = {\n\t\t\tabsolute: false,\n\t\t\trelative: false,\n\t\t\tprotocol: null,\n\t\t\thostname: null,\n\t\t\tport: null,\n\t\t\tpathname: null,\n\t\t\tsearch: null,\n\t\t\thash: null,\n\t\t\thost: null\n\t\t};\n\n\t\tif (path == null) { return info; }\n\n\t\t// Inject the path parts.\n\t\tvar parser = createjs.Elements.a();\n\t\tparser.href = path;\n\n\t\tfor (var n in info) {\n\t\t\tif (n in parser) {\n\t\t\t\tinfo[n] = parser[n];\n\t\t\t}\n\t\t}\n\n\t\t// Drop the query string\n\t\tvar queryIndex = path.indexOf(\"?\");\n\t\tif (queryIndex > -1) {\n\t\t\tpath = path.substr(0, queryIndex);\n\t\t}\n\n\t\t// Absolute\n\t\tvar match;\n\t\tif (s.ABSOLUTE_PATT.test(path)) {\n\t\t\tinfo.absolute = true;\n\n\t\t\t// Relative\n\t\t} else if (s.RELATIVE_PATT.test(path)) {\n\t\t\tinfo.relative = true;\n\t\t}\n\n\t\t// Extension\n\t\tif (match = path.match(s.EXTENSION_PATT)) {\n\t\t\tinfo.extension = match[1].toLowerCase();\n\t\t}\n\n\t\treturn info;\n\t};\n\n\t/**\n\t * Formats an object into a query string for either a POST or GET request.\n\t * @method formatQueryString\n\t * @param {Object} data The data to convert to a query string.\n\t * @param {Array} [query] Existing name/value pairs to append on to this query.\n\t * @static\n\t */\n\ts.formatQueryString = function (data, query) {\n\t\tif (data == null) {\n\t\t\tthrow new Error(\"You must specify data.\");\n\t\t}\n\t\tvar params = [];\n\t\tfor (var n in data) {\n\t\t\tparams.push(n + \"=\" + escape(data[n]));\n\t\t}\n\t\tif (query) {\n\t\t\tparams = params.concat(query);\n\t\t}\n\t\treturn params.join(\"&\");\n\t};\n\n\t/**\n\t * A utility method that builds a file path using a source and a data object, and formats it into a new path.\n\t * @method buildURI\n\t * @param {String} src The source path to add values to.\n\t * @param {Object} [data] Object used to append values to this request as a query string. Existing parameters on the\n\t * path will be preserved.\n\t * @returns {string} A formatted string that contains the path and the supplied parameters.\n\t * @static\n\t */\n\ts.buildURI = function (src, data) {\n\t\tif (data == null) {\n\t\t\treturn src;\n\t\t}\n\n\t\tvar query = [];\n\t\tvar idx = src.indexOf(\"?\");\n\n\t\tif (idx != -1) {\n\t\t\tvar q = src.slice(idx + 1);\n\t\t\tquery = query.concat(q.split(\"&\"));\n\t\t}\n\n\t\tif (idx != -1) {\n\t\t\treturn src.slice(0, idx) + \"?\" + this.formatQueryString(data, query);\n\t\t} else {\n\t\t\treturn src + \"?\" + this.formatQueryString(data, query);\n\t\t}\n\t};\n\n\t/**\n\t * @method isCrossDomain\n\t * @param {LoadItem|Object} item A load item with a `src` property.\n\t * @return {Boolean} If the load item is loading from a different domain than the current location.\n\t * @static\n\t */\n\ts.isCrossDomain = function (item) {\n\t\tvar target = createjs.Elements.a();\n\t\ttarget.href = item.src;\n\n\t\tvar host = createjs.Elements.a();\n\t\thost.href = location.href;\n\n\t\tvar crossdomain = (target.hostname != \"\") &&\n\t\t\t(target.port != host.port ||\n\t\t\ttarget.protocol != host.protocol ||\n\t\t\ttarget.hostname != host.hostname);\n\t\treturn crossdomain;\n\t};\n\n\t/**\n\t * @method isLocal\n\t * @param {LoadItem|Object} item A load item with a `src` property\n\t * @return {Boolean} If the load item is loading from the \"file:\" protocol. Assume that the host must be local as\n\t * well.\n\t * @static\n\t */\n\ts.isLocal = function (item) {\n\t\tvar target = createjs.Elements.a();\n\t\ttarget.href = item.src;\n\t\treturn target.hostname == \"\" && target.protocol == \"file:\";\n\t};\n\n\tcreatejs.URLUtils = s;\n\n}());\n\n//##############################################################################\n// DomUtils.js\n//##############################################################################\n\n(function () {\n\n\t/**\n\t * A few utilities for interacting with the dom.\n\t * @class DomUtils\n\t */\n\tvar s = {\n\t\tcontainer: null\n\t};\n\n\ts.appendToHead = function (el) {\n\t\ts.getHead().appendChild(el);\n\t}\n\n\ts.appendToBody = function (el) {\n\t\tif (s.container == null) {\n\t\t\ts.container = document.createElement(\"div\");\n\t\t\ts.container.id = \"preloadjs-container\";\n\t\t\tvar style = s.container.style;\n\t\t\tstyle.visibility = \"hidden\";\n\t\t\tstyle.position = \"absolute\";\n\t\t\tstyle.width = s.container.style.height = \"10px\";\n\t\t\tstyle.overflow = \"hidden\";\n\t\t\tstyle.transform = style.msTransform = style.webkitTransform = style.oTransform = \"translate(-10px, -10px)\"; //LM: Not working\n\t\t\ts.getBody().appendChild(s.container);\n\t\t}\n\t\ts.container.appendChild(el);\n\t}\n\n\ts.getHead = function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}\n\n\ts.getBody = function () {\n\t\treturn document.body || document.getElementsByTagName(\"body\")[0];\n\t}\n\n\ts.removeChild = function(el) {\n\t\tif (el.parent) {\n\t\t\tel.parent.removeChild(el);\n\t\t}\n\t}\n\n\t/**\n\t * Check if item is a valid HTMLImageElement\n\t * @method isImageTag\n\t * @param {Object} item\n\t * @returns {Boolean}\n\t * @static\n\t */\n\ts.isImageTag = function(item) {\n\t\treturn item instanceof HTMLImageElement;\n\t};\n\n\t/**\n\t * Check if item is a valid HTMLAudioElement\n\t * @method isAudioTag\n\t * @param {Object} item\n\t * @returns {Boolean}\n\t * @static\n\t */\n\ts.isAudioTag = function(item) {\n\t\tif (window.HTMLAudioElement) {\n\t\t\treturn item instanceof HTMLAudioElement;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Check if item is a valid HTMLVideoElement\n\t * @method isVideoTag\n\t * @param {Object} item\n\t * @returns {Boolean}\n\t * @static\n\t */\n\ts.isVideoTag = function(item) {\n\t\tif (window.HTMLVideoElement) {\n\t\t\treturn item instanceof HTMLVideoElement;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tcreatejs.DomUtils = s;\n\n}());\n\n//##############################################################################\n// DataUtils.js\n//##############################################################################\n\n(function () {\n\n\t/**\n\t * A few data utilities for formatting different data types.\n\t * @class DataUtils\n\t */\n\tvar s = {};\n\n\t// static methods\n\t/**\n\t * Parse XML using the DOM. This is required when preloading XML or SVG.\n\t * @method parseXML\n\t * @param {String} text The raw text or XML that is loaded by XHR.\n\t * @return {XML} An XML document\n\t * @static\n\t */\n\ts.parseXML = function (text) {\n\t\tvar xml = null;\n\t\t// CocoonJS does not support XML parsing with either method.\n\n\t\t// Most browsers will use DOMParser\n\t\t// IE fails on certain SVG files, so we have a fallback below.\n\t\ttry {\n\t\t\tif (window.DOMParser) {\n\t\t\t\tvar parser = new DOMParser();\n\t\t\t\txml = parser.parseFromString(text, \"text/xml\");\n\t\t\t}\n\t\t} catch (e) {\n\t\t}\n\n\t\t// Fallback for IE support.\n\t\tif (!xml) {\n\t\t\ttry {\n\t\t\t\txml = new ActiveXObject(\"Microsoft.XMLDOM\");\n\t\t\t\txml.async = false;\n\t\t\t\txml.loadXML(text);\n\t\t\t} catch (e) {\n\t\t\t\txml = null;\n\t\t\t}\n\t\t}\n\n\t\treturn xml;\n\t};\n\n\t/**\n\t * Parse a string into an Object.\n\t * @method parseJSON\n\t * @param {String} value The loaded JSON string\n\t * @returns {Object} A JavaScript object.\n\t */\n\ts.parseJSON = function (value) {\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\treturn JSON.parse(value);\n\t\t} catch (e) {\n\t\t\t// TODO; Handle this with a custom error?\n\t\t\tthrow e;\n\t\t}\n\t};\n\n\tcreatejs.DataUtils = s;\n\n}());\n\n//##############################################################################\n// Types.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function() {\n\tvar s = {};\n\n\t/**\n\t * The preload type for generic binary types. Note that images are loaded as binary files when using XHR.\n\t * @property BINARY\n\t * @type {String}\n\t * @default binary\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.BINARY = \"binary\";\n\n\t/**\n\t * The preload type for css files. CSS files are loaded using a &lt;link&gt; when loaded with XHR, or a\n\t * &lt;style&gt; tag when loaded with tags.\n\t * @property CSS\n\t * @type {String}\n\t * @default css\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.CSS = \"css\";\n\n\t/**\n\t * The preload type for font files.\n\t * @property FONT\n\t * @type {String}\n\t * @default font\n\t * @static\n\t * @since 0.9.0\n\t */\n\ts.FONT = \"font\";\n\n\t/**\n\t * The preload type for fonts specified with CSS (such as Google fonts)\n\t * @property FONTCSS\n\t * @type {String}\n\t * @default fontcss\n\t * @static\n\t * @since 0.9.0\n\t */\n\ts.FONTCSS = \"fontcss\";\n\n\t/**\n\t * The preload type for image files, usually png, gif, or jpg/jpeg. Images are loaded into an &lt;image&gt; tag.\n\t * @property IMAGE\n\t * @type {String}\n\t * @default image\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.IMAGE = \"image\";\n\n\t/**\n\t * The preload type for javascript files, usually with the \"js\" file extension. JavaScript files are loaded into a\n\t * &lt;script&gt; tag.\n\t *\n\t * Since version 0.4.1+, due to how tag-loaded scripts work, all JavaScript files are automatically injected into\n\t * the body of the document to maintain parity between XHR and tag-loaded scripts. In version 0.4.0 and earlier,\n\t * only tag-loaded scripts are injected.\n\t * @property JAVASCRIPT\n\t * @type {String}\n\t * @default javascript\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.JAVASCRIPT = \"javascript\";\n\n\t/**\n\t * The preload type for json files, usually with the \"json\" file extension. JSON data is loaded and parsed into a\n\t * JavaScript object. Note that if a `callback` is present on the load item, the file will be loaded with JSONP,\n\t * no matter what the {{#crossLink \"LoadQueue/preferXHR:property\"}}{{/crossLink}} property is set to, and the JSON\n\t * must contain a matching wrapper function.\n\t * @property JSON\n\t * @type {String}\n\t * @default json\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.JSON = \"json\";\n\n\t/**\n\t * The preload type for jsonp files, usually with the \"json\" file extension. JSON data is loaded and parsed into a\n\t * JavaScript object. You are required to pass a callback parameter that matches the function wrapper in the JSON.\n\t * Note that JSONP will always be used if there is a callback present, no matter what the {{#crossLink \"LoadQueue/preferXHR:property\"}}{{/crossLink}}\n\t * property is set to.\n\t * @property JSONP\n\t * @type {String}\n\t * @default jsonp\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.JSONP = \"jsonp\";\n\n\t/**\n\t * The preload type for json-based manifest files, usually with the \"json\" file extension. The JSON data is loaded\n\t * and parsed into a JavaScript object. PreloadJS will then look for a \"manifest\" property in the JSON, which is an\n\t * Array of files to load, following the same format as the {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}\n\t * method. If a \"callback\" is specified on the manifest object, then it will be loaded using JSONP instead,\n\t * regardless of what the {{#crossLink \"LoadQueue/preferXHR:property\"}}{{/crossLink}} property is set to.\n\t * @property MANIFEST\n\t * @type {String}\n\t * @default manifest\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.MANIFEST = \"manifest\";\n\n\t/**\n\t * The preload type for sound files, usually mp3, ogg, or wav. When loading via tags, audio is loaded into an\n\t * &lt;audio&gt; tag.\n\t * @property SOUND\n\t * @type {String}\n\t * @default sound\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.SOUND = \"sound\";\n\n\t/**\n\t * The preload type for video files, usually mp4, ts, or ogg. When loading via tags, video is loaded into an\n\t * &lt;video&gt; tag.\n\t * @property VIDEO\n\t * @type {String}\n\t * @default video\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.VIDEO = \"video\";\n\n\t/**\n\t * The preload type for SpriteSheet files. SpriteSheet files are JSON files that contain string image paths.\n\t * @property SPRITESHEET\n\t * @type {String}\n\t * @default spritesheet\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.SPRITESHEET = \"spritesheet\";\n\n\t/**\n\t * The preload type for SVG files.\n\t * @property SVG\n\t * @type {String}\n\t * @default svg\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.SVG = \"svg\";\n\n\t/**\n\t * The preload type for text files, which is also the default file type if the type can not be determined. Text is\n\t * loaded as raw text.\n\t * @property TEXT\n\t * @type {String}\n\t * @default text\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.TEXT = \"text\";\n\n\t/**\n\t * The preload type for xml files. XML is loaded into an XML document.\n\t * @property XML\n\t * @type {String}\n\t * @default xml\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.XML = \"xml\";\n\n\tcreatejs.Types = s;\n}());\n\n//##############################################################################\n// Methods.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function() {\n\tvar s = {};\n\n\t/**\n\t * Defines a POST request, use for a method value when loading data.\n\t * @property POST\n\t * @type {string}\n\t * @default post\n\t * @static\n\t */\n\ts.POST = \"POST\";\n\n\t/**\n\t * Defines a GET request, use for a method value when loading data.\n\t * @property GET\n\t * @type {string}\n\t * @default get\n\t * @static\n\t */\n\ts.GET = \"GET\";\n\n\tcreatejs.Methods = s;\n}());\n\n//##############################################################################\n// LoadItem.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * All loaders accept an item containing the properties defined in this class. If a raw object is passed instead,\n\t * it will not be affected, but it must contain at least a {{#crossLink \"src:property\"}}{{/crossLink}} property. A\n\t * string path or HTML tag is also acceptable, but it will be automatically converted to a LoadItem using the\n\t * {{#crossLink \"create\"}}{{/crossLink}} method by {{#crossLink \"AbstractLoader\"}}{{/crossLink}}\n\t * @class LoadItem\n\t * @constructor\n\t * @since 0.6.0\n\t */\n\tfunction LoadItem() {\n\t\t/**\n\t\t * The source of the file that is being loaded. This property is <b>required</b>. The source can either be a\n\t\t * string (recommended), or an HTML tag.\n\t\t * This can also be an object, but in that case it has to include a type and be handled by a plugin.\n\t\t * @property src\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.src = null;\n\n\t\t/**\n\t\t * The type file that is being loaded. The type of the file is usually inferred by the extension, but can also\n\t\t * be set manually. This is helpful in cases where a file does not have an extension.\n\t\t * @property type\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.type = null;\n\n\t\t/**\n\t\t * A string identifier which can be used to reference the loaded object. If none is provided, this will be\n\t\t * automatically set to the {{#crossLink \"src:property\"}}{{/crossLink}}.\n\t\t * @property id\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.id = null;\n\n\t\t/**\n\t\t * Determines if a manifest will maintain the order of this item, in relation to other items in the manifest\n\t\t * that have also set the `maintainOrder` property to `true`. This only applies when the max connections has\n\t\t * been set above 1 (using {{#crossLink \"LoadQueue/setMaxConnections\"}}{{/crossLink}}). Everything with this\n\t\t * property set to `false` will finish as it is loaded. Ordered items are combined with script tags loading in\n\t\t * order when {{#crossLink \"LoadQueue/maintainScriptOrder:property\"}}{{/crossLink}} is set to `true`.\n\t\t * @property maintainOrder\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.maintainOrder = false;\n\n\t\t/**\n\t\t * A callback used by JSONP requests that defines what global method to call when the JSONP content is loaded.\n\t\t * @property callback\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.callback = null;\n\n\t\t/**\n\t\t * An arbitrary data object, which is included with the loaded object.\n\t\t * @property data\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis.data = null;\n\n\t\t/**\n\t\t * The request method used for HTTP calls. Both {{#crossLink \"Methods/GET:property\"}}{{/crossLink}} or\n\t\t * {{#crossLink \"Methods/POST:property\"}}{{/crossLink}} request types are supported, and are defined as\n\t\t * constants on {{#crossLink \"AbstractLoader\"}}{{/crossLink}}.\n\t\t * @property method\n\t\t * @type {String}\n\t\t * @default GET\n\t\t */\n\t\tthis.method = createjs.Methods.GET;\n\n\t\t/**\n\t\t * An object hash of name/value pairs to send to the server.\n\t\t * @property values\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis.values = null;\n\n\t\t/**\n\t\t * An object hash of headers to attach to an XHR request. PreloadJS will automatically attach some default\n\t\t * headers when required, including \"Origin\", \"Content-Type\", and \"X-Requested-With\". You may override the\n\t\t * default headers by including them in your headers object.\n\t\t * @property headers\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis.headers = null;\n\n\t\t/**\n\t\t * Enable credentials for XHR requests.\n\t\t * @property withCredentials\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.withCredentials = false;\n\n\t\t/**\n\t\t * Set the mime type of XHR-based requests. This is automatically set to \"text/plain; charset=utf-8\" for text\n\t\t * based files (json, xml, text, css, js).\n\t\t * @property mimeType\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.mimeType = null;\n\n\t\t/**\n\t\t * Sets the crossOrigin attribute for CORS-enabled images loading cross-domain.\n\t\t * @property crossOrigin\n\t\t * @type {boolean}\n\t\t * @default Anonymous\n\t\t */\n\t\tthis.crossOrigin = null;\n\n\t\t/**\n\t\t * The duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR\n\t\t * (level one) loading, as XHR (level 2) provides its own timeout event.\n\t\t * @property loadTimeout\n\t\t * @type {Number}\n\t\t * @default 8000 (8 seconds)\n\t\t */\n\t\tthis.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;\n\t};\n\n\tvar p = LoadItem.prototype = {};\n\tvar s = LoadItem;\n\n\t/**\n\t * Default duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR\n\t * (level one) loading, as XHR (level 2) provides its own timeout event.\n\t * @property LOAD_TIMEOUT_DEFAULT\n\t * @type {number}\n\t * @static\n\t */\n\ts.LOAD_TIMEOUT_DEFAULT = 8000;\n\n\t/**\n\t * Create a LoadItem.\n\t * <ul>\n\t *     <li>String-based items are converted to a LoadItem with a populated {{#crossLink \"src:property\"}}{{/crossLink}}.</li>\n\t *     <li>LoadItem instances are returned as-is</li>\n\t *     <li>Objects are returned with any needed properties added</li>\n\t * </ul>\n\t * @method create\n\t * @param {LoadItem|String|Object} value The load item value\n\t * @returns {LoadItem|Object}\n\t * @static\n\t */\n\ts.create = function (value) {\n\t\tif (typeof value == \"string\") {\n\t\t\tvar item = new LoadItem();\n\t\t\titem.src = value;\n\t\t\treturn item;\n\t\t} else if (value instanceof s) {\n\t\t\treturn value;\n\t\t} else if (value instanceof Object && value.src) {\n\t\t\tif (value.loadTimeout == null) {\n\t\t\t\tvalue.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;\n\t\t\t}\n\t\t\treturn value;\n\t\t} else {\n\t\t\tthrow new Error(\"Type not recognized.\");\n\t\t}\n\t};\n\n\t/**\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var loadItem = new createjs.LoadItem().set({src:\"image.png\", maintainOrder:true});\n\t *\n\t * @method set\n\t * @param {Object} props A generic object containing properties to copy to the LoadItem instance.\n\t * @return {LoadItem} Returns the instance the method is called on (useful for chaining calls.)\n\t*/\n\tp.set = function(props) {\n\t\tfor (var n in props) { this[n] = props[n]; }\n\t\treturn this;\n\t};\n\n\tcreatejs.LoadItem = s;\n\n}());\n\n//##############################################################################\n// RequestUtils.js\n//##############################################################################\n\n(function () {\n\n\t/**\n\t * Utilities that assist with parsing load items, and determining file types, etc.\n\t * @class RequestUtils\n\t */\n\tvar s = {};\n\n\t/**\n\t * Determine if a specific type should be loaded as a binary file. Currently, only images and items marked\n\t * specifically as \"binary\" are loaded as binary. Note that audio is <b>not</b> a binary type, as we can not play\n\t * back using an audio tag if it is loaded as binary. Plugins can change the item type to binary to ensure they get\n\t * a binary result to work with. Binary files are loaded using XHR2. Types are defined as static constants on\n\t * {{#crossLink \"AbstractLoader\"}}{{/crossLink}}.\n\t * @method isBinary\n\t * @param {String} type The item type.\n\t * @return {Boolean} If the specified type is binary.\n\t * @static\n\t */\n\ts.isBinary = function (type) {\n\t\tswitch (type) {\n\t\t\tcase createjs.Types.IMAGE:\n\t\t\tcase createjs.Types.BINARY:\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Determine if a specific type is a text-based asset, and should be loaded as UTF-8.\n\t * @method isText\n\t * @param {String} type The item type.\n\t * @return {Boolean} If the specified type is text.\n\t * @static\n\t */\n\ts.isText = function (type) {\n\t\tswitch (type) {\n\t\t\tcase createjs.Types.TEXT:\n\t\t\tcase createjs.Types.JSON:\n\t\t\tcase createjs.Types.MANIFEST:\n\t\t\tcase createjs.Types.XML:\n\t\t\tcase createjs.Types.CSS:\n\t\t\tcase createjs.Types.SVG:\n\t\t\tcase createjs.Types.JAVASCRIPT:\n\t\t\tcase createjs.Types.SPRITESHEET:\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Determine the type of the object using common extensions. Note that the type can be passed in with the load item\n\t * if it is an unusual extension.\n\t * @method getTypeByExtension\n\t * @param {String} extension The file extension to use to determine the load type.\n\t * @return {String} The determined load type (for example, `createjs.Types.IMAGE`). Will return `null` if\n\t * the type can not be determined by the extension.\n\t * @static\n\t */\n\ts.getTypeByExtension = function (extension) {\n\t\tif (extension == null) {\n\t\t\treturn createjs.Types.TEXT;\n\t\t}\n\n\t\tswitch (extension.toLowerCase()) {\n\t\t\tcase \"jpeg\":\n\t\t\tcase \"jpg\":\n\t\t\tcase \"gif\":\n\t\t\tcase \"png\":\n\t\t\tcase \"webp\":\n\t\t\tcase \"bmp\":\n\t\t\t\treturn createjs.Types.IMAGE;\n\t\t\tcase \"ogg\":\n\t\t\tcase \"mp3\":\n\t\t\tcase \"webm\":\n\t\t\t\treturn createjs.Types.SOUND;\n\t\t\tcase \"mp4\":\n\t\t\tcase \"webm\":\n\t\t\tcase \"ts\":\n\t\t\t\treturn createjs.Types.VIDEO;\n\t\t\tcase \"json\":\n\t\t\t\treturn createjs.Types.JSON;\n\t\t\tcase \"xml\":\n\t\t\t\treturn createjs.Types.XML;\n\t\t\tcase \"css\":\n\t\t\t\treturn createjs.Types.CSS;\n\t\t\tcase \"js\":\n\t\t\t\treturn createjs.Types.JAVASCRIPT;\n\t\t\tcase 'svg':\n\t\t\t\treturn createjs.Types.SVG;\n\t\t\tdefault:\n\t\t\t\treturn createjs.Types.TEXT;\n\t\t}\n\t};\n\n\tcreatejs.RequestUtils = s;\n\n}());\n\n//##############################################################################\n// AbstractLoader.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function () {\n\t\"use strict\";\n\n// constructor\n\t/**\n\t * The base loader, which defines all the generic methods, properties, and events. All loaders extend this class,\n\t * including the {{#crossLink \"LoadQueue\"}}{{/crossLink}}.\n\t * @class AbstractLoader\n\t * @param {LoadItem|object|string} loadItem The item to be loaded.\n\t * @param {Boolean} [preferXHR] Determines if the LoadItem should <em>try</em> and load using XHR, or take a\n\t * tag-based approach, which can be better in cross-domain situations. Not all loaders can load using one or the\n\t * other, so this is a suggested directive.\n\t * @param {String} [type] The type of loader. Loader types are defined as constants on the AbstractLoader class,\n\t * such as {{#crossLink \"IMAGE:property\"}}{{/crossLink}}, {{#crossLink \"CSS:property\"}}{{/crossLink}}, etc.\n\t * @extends EventDispatcher\n\t */\n\tfunction AbstractLoader(loadItem, preferXHR, type) {\n\t\tthis.EventDispatcher_constructor();\n\n\t\t// public properties\n\t\t/**\n\t\t * If the loader has completed loading. This provides a quick check, but also ensures that the different approaches\n\t\t * used for loading do not pile up resulting in more than one `complete` {{#crossLink \"Event\"}}{{/crossLink}}.\n\t\t * @property loaded\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.loaded = false;\n\n\t\t/**\n\t\t * Determine if the loader was canceled. Canceled loads will not fire complete events. Note that this property\n\t\t * is readonly, so {{#crossLink \"LoadQueue\"}}{{/crossLink}} queues should be closed using {{#crossLink \"LoadQueue/close\"}}{{/crossLink}}\n\t\t * instead.\n\t\t * @property canceled\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @readonly\n\t\t */\n\t\tthis.canceled = false;\n\n\t\t/**\n\t\t * The current load progress (percentage) for this item. This will be a number between 0 and 1.\n\t\t *\n\t\t * <h4>Example</h4>\n\t\t *\n\t\t *     var queue = new createjs.LoadQueue();\n\t\t *     queue.loadFile(\"largeImage.png\");\n\t\t *     queue.on(\"progress\", function() {\n\t\t *         console.log(\"Progress:\", queue.progress, event.progress);\n\t\t *     });\n\t\t *\n\t\t * @property progress\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.progress = 0;\n\n\t\t/**\n\t\t * The type of item this loader will load. See {{#crossLink \"AbstractLoader\"}}{{/crossLink}} for a full list of\n\t\t * supported types.\n\t\t * @property type\n\t\t * @type {String}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * A formatter function that converts the loaded raw result into the final result. For example, the JSONLoader\n\t\t * converts a string of text into a JavaScript object. Not all loaders have a resultFormatter, and this property\n\t\t * can be overridden to provide custom formatting.\n\t\t *\n\t\t * Optionally, a resultFormatter can return a callback function in cases where the formatting needs to be\n\t\t * asynchronous, such as creating a new image. The callback function is passed 2 parameters, which are callbacks\n\t\t * to handle success and error conditions in the resultFormatter. Note that the resultFormatter method is\n\t\t * called in the current scope, as well as the success and error callbacks.\n\t\t *\n\t\t * <h4>Example asynchronous resultFormatter</h4>\n\t\t *\n\t\t * \tfunction _formatResult(loader) {\n\t\t * \t\treturn function(success, error) {\n\t\t * \t\t\tif (errorCondition) { error(errorDetailEvent); }\n\t\t * \t\t\tsuccess(result);\n\t\t * \t\t}\n\t\t * \t}\n\t\t * @property resultFormatter\n\t\t * @type {Function}\n\t\t * @default null\n\t\t */\n\t\tthis.resultFormatter = null;\n\n\t\t// protected properties\n\t\t/**\n\t\t * The {{#crossLink \"LoadItem\"}}{{/crossLink}} this loader represents. Note that this is null in a {{#crossLink \"LoadQueue\"}}{{/crossLink}},\n\t\t * but will be available on loaders such as {{#crossLink \"XMLLoader\"}}{{/crossLink}} and {{#crossLink \"ImageLoader\"}}{{/crossLink}}.\n\t\t * @property _item\n\t\t * @type {LoadItem|Object}\n\t\t * @private\n\t\t */\n\t\tif (loadItem) {\n\t\t\tthis._item = createjs.LoadItem.create(loadItem);\n\t\t} else {\n\t\t\tthis._item = null;\n\t\t}\n\n\t\t/**\n\t\t * Whether the loader will try and load content using XHR (true) or HTML tags (false).\n\t\t * @property _preferXHR\n\t\t * @type {Boolean}\n\t\t * @private\n\t\t */\n\t\tthis._preferXHR = preferXHR;\n\n\t\t/**\n\t\t * The loaded result after it is formatted by an optional {{#crossLink \"resultFormatter\"}}{{/crossLink}}. For\n\t\t * items that are not formatted, this will be the same as the {{#crossLink \"_rawResult:property\"}}{{/crossLink}}.\n\t\t * The result is accessed using the {{#crossLink \"getResult\"}}{{/crossLink}} method.\n\t\t * @property _result\n\t\t * @type {Object|String}\n\t\t * @private\n\t\t */\n\t\tthis._result = null;\n\n\t\t/**\n\t\t * The loaded result before it is formatted. The rawResult is accessed using the {{#crossLink \"getResult\"}}{{/crossLink}}\n\t\t * method, and passing `true`.\n\t\t * @property _rawResult\n\t\t * @type {Object|String}\n\t\t * @private\n\t\t */\n\t\tthis._rawResult = null;\n\n\t\t/**\n\t\t * A list of items that loaders load behind the scenes. This does not include the main item the loader is\n\t\t * responsible for loading. Examples of loaders that have sub-items include the {{#crossLink \"SpriteSheetLoader\"}}{{/crossLink}} and\n\t\t * {{#crossLink \"ManifestLoader\"}}{{/crossLink}}.\n\t\t * @property _loadItems\n\t\t * @type {null}\n\t\t * @protected\n\t\t */\n\t\tthis._loadedItems = null;\n\n\t\t/**\n\t\t * The attribute the items loaded using tags use for the source.\n\t\t * @type {string}\n\t\t * @default null\n\t\t * @private\n\t\t */\n\t\tthis._tagSrcAttribute = null;\n\n\t\t/**\n\t\t * An HTML tag (or similar) that a loader may use to load HTML content, such as images, scripts, etc.\n\t\t * @property _tag\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._tag = null;\n\t};\n\n\tvar p = createjs.extend(AbstractLoader, createjs.EventDispatcher);\n\tvar s = AbstractLoader;\n\n\t// Remove these @deprecated properties after 1.0\n\ttry {\n\t\tObject.defineProperties(s, {\n\t\t\tPOST: { get: createjs.deprecate(function() { return createjs.Methods.POST; }, \"AbstractLoader.POST\") },\n\t\t\tGET: { get: createjs.deprecate(function() { return createjs.Methods.GET; }, \"AbstractLoader.GET\") },\n\n\t\t\tBINARY: { get: createjs.deprecate(function() { return createjs.Types.BINARY; }, \"AbstractLoader.BINARY\") },\n\t\t\tCSS: { get: createjs.deprecate(function() { return createjs.Types.CSS; }, \"AbstractLoader.CSS\") },\n\t\t\tFONT: { get: createjs.deprecate(function() { return createjs.Types.FONT; }, \"AbstractLoader.FONT\") },\n\t\t\tFONTCSS: { get: createjs.deprecate(function() { return createjs.Types.FONTCSS; }, \"AbstractLoader.FONTCSS\") },\n\t\t\tIMAGE: { get: createjs.deprecate(function() { return createjs.Types.IMAGE; }, \"AbstractLoader.IMAGE\") },\n\t\t\tJAVASCRIPT: { get: createjs.deprecate(function() { return createjs.Types.JAVASCRIPT; }, \"AbstractLoader.JAVASCRIPT\") },\n\t\t\tJSON: { get: createjs.deprecate(function() { return createjs.Types.JSON; }, \"AbstractLoader.JSON\") },\n\t\t\tJSONP: { get: createjs.deprecate(function() { return createjs.Types.JSONP; }, \"AbstractLoader.JSONP\") },\n\t\t\tMANIFEST: { get: createjs.deprecate(function() { return createjs.Types.MANIFEST; }, \"AbstractLoader.MANIFEST\") },\n\t\t\tSOUND: { get: createjs.deprecate(function() { return createjs.Types.SOUND; }, \"AbstractLoader.SOUND\") },\n\t\t\tVIDEO: { get: createjs.deprecate(function() { return createjs.Types.VIDEO; }, \"AbstractLoader.VIDEO\") },\n\t\t\tSPRITESHEET: { get: createjs.deprecate(function() { return createjs.Types.SPRITESHEET; }, \"AbstractLoader.SPRITESHEET\") },\n\t\t\tSVG: { get: createjs.deprecate(function() { return createjs.Types.SVG; }, \"AbstractLoader.SVG\") },\n\t\t\tTEXT: { get: createjs.deprecate(function() { return createjs.Types.TEXT; }, \"AbstractLoader.TEXT\") },\n\t\t\tXML: { get: createjs.deprecate(function() { return createjs.Types.XML; }, \"AbstractLoader.XML\") }\n\t\t});\n\t} catch (e) {}\n\n// Events\n\t/**\n\t * The {{#crossLink \"ProgressEvent\"}}{{/crossLink}} that is fired when the overall progress changes. Prior to\n\t * version 0.6.0, this was just a regular {{#crossLink \"Event\"}}{{/crossLink}}.\n\t * @event progress\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * The {{#crossLink \"Event\"}}{{/crossLink}} that is fired when a load starts.\n\t * @event loadstart\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @since 0.3.1\n\t */\n\n\t/**\n\t * The {{#crossLink \"Event\"}}{{/crossLink}} that is fired when the entire queue has been loaded.\n\t * @event complete\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * The {{#crossLink \"ErrorEvent\"}}{{/crossLink}} that is fired when the loader encounters an error. If the error was\n\t * encountered by a file, the event will contain the item that caused the error. Prior to version 0.6.0, this was\n\t * just a regular {{#crossLink \"Event\"}}{{/crossLink}}.\n\t * @event error\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * The {{#crossLink \"Event\"}}{{/crossLink}} that is fired when the loader encounters an internal file load error.\n\t * This enables loaders to maintain internal queues, and surface file load errors.\n\t * @event fileerror\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type (\"fileerror\")\n\t * @param {LoadItem|object} The item that encountered the error\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * The {{#crossLink \"Event\"}}{{/crossLink}} that is fired when a loader internally loads a file. This enables\n\t * loaders such as {{#crossLink \"ManifestLoader\"}}{{/crossLink}} to maintain internal {{#crossLink \"LoadQueue\"}}{{/crossLink}}s\n\t * and notify when they have loaded a file. The {{#crossLink \"LoadQueue\"}}{{/crossLink}} class dispatches a\n\t * slightly different {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}} event.\n\t * @event fileload\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type (\"fileload\")\n\t * @param {Object} item The file item which was specified in the {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}}\n\t * or {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}} call. If only a string path or tag was specified, the\n\t * object will contain that value as a `src` property.\n\t * @param {Object} result The HTML tag or parsed result of the loaded item.\n\t * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted\n\t * to a usable object.\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * The {{#crossLink \"Event\"}}{{/crossLink}} that is fired after the internal request is created, but before a load.\n\t * This allows updates to the loader for specific loading needs, such as binary or XHR image loading.\n\t * @event initialize\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type (\"initialize\")\n\t * @param {AbstractLoader} loader The loader that has been initialized.\n\t */\n\n\n\t/**\n\t * Get a reference to the manifest item that is loaded by this loader. In some cases this will be the value that was\n\t * passed into {{#crossLink \"LoadQueue\"}}{{/crossLink}} using {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}} or\n\t * {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}. However if only a String path was passed in, then it will\n\t * be a {{#crossLink \"LoadItem\"}}{{/crossLink}}.\n\t * @method getItem\n\t * @return {Object} The manifest item that this loader is responsible for loading.\n\t * @since 0.6.0\n\t */\n\tp.getItem = function () {\n\t\treturn this._item;\n\t};\n\n\t/**\n\t * Get a reference to the content that was loaded by the loader (only available after the {{#crossLink \"complete:event\"}}{{/crossLink}}\n\t * event is dispatched.\n\t * @method getResult\n\t * @param {Boolean} [raw=false] Determines if the returned result will be the formatted content, or the raw loaded\n\t * data (if it exists).\n\t * @return {Object}\n\t * @since 0.6.0\n\t */\n\tp.getResult = function (raw) {\n\t\treturn raw ? this._rawResult : this._result;\n\t};\n\n\t/**\n\t * Return the `tag` this object creates or uses for loading.\n\t * @method getTag\n\t * @return {Object} The tag instance\n\t * @since 0.6.0\n\t */\n\tp.getTag = function () {\n\t\treturn this._tag;\n\t};\n\n\t/**\n\t * Set the `tag` this item uses for loading.\n\t * @method setTag\n\t * @param {Object} tag The tag instance\n\t * @since 0.6.0\n\t */\n\tp.setTag = function(tag) {\n\t  this._tag = tag;\n\t};\n\n\t/**\n\t * Begin loading the item. This method is required when using a loader by itself.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var queue = new createjs.LoadQueue();\n\t *      queue.on(\"complete\", handleComplete);\n\t *      queue.loadManifest(fileArray, false); // Note the 2nd argument that tells the queue not to start loading yet\n\t *      queue.load();\n\t *\n\t * @method load\n\t */\n\tp.load = function () {\n\t\tthis._createRequest();\n\n\t\tthis._request.on(\"complete\", this, this);\n\t\tthis._request.on(\"progress\", this, this);\n\t\tthis._request.on(\"loadStart\", this, this);\n\t\tthis._request.on(\"abort\", this, this);\n\t\tthis._request.on(\"timeout\", this, this);\n\t\tthis._request.on(\"error\", this, this);\n\n\t\tvar evt = new createjs.Event(\"initialize\");\n\t\tevt.loader = this._request;\n\t\tthis.dispatchEvent(evt);\n\n\t\tthis._request.load();\n\t};\n\n\t/**\n\t * Close the the item. This will stop any open requests (although downloads using HTML tags may still continue in\n\t * the background), but events will not longer be dispatched.\n\t * @method cancel\n\t */\n\tp.cancel = function () {\n\t\tthis.canceled = true;\n\t\tthis.destroy();\n\t};\n\n\t/**\n\t * Clean up the loader.\n\t * @method destroy\n\t */\n\tp.destroy = function() {\n\t\tif (this._request) {\n\t\t\tthis._request.removeAllEventListeners();\n\t\t\tthis._request.destroy();\n\t\t}\n\n\t\tthis._request = null;\n\n\t\tthis._item = null;\n\t\tthis._rawResult = null;\n\t\tthis._result = null;\n\n\t\tthis._loadItems = null;\n\n\t\tthis.removeAllEventListeners();\n\t};\n\n\t/**\n\t * Get any items loaded internally by the loader. The enables loaders such as {{#crossLink \"ManifestLoader\"}}{{/crossLink}}\n\t * to expose items it loads internally.\n\t * @method getLoadedItems\n\t * @return {Array} A list of the items loaded by the loader.\n\t * @since 0.6.0\n\t */\n\tp.getLoadedItems = function () {\n\t\treturn this._loadedItems;\n\t};\n\n\n\t// Private methods\n\t/**\n\t * Create an internal request used for loading. By default, an {{#crossLink \"XHRRequest\"}}{{/crossLink}} or\n\t * {{#crossLink \"TagRequest\"}}{{/crossLink}} is created, depending on the value of {{#crossLink \"preferXHR:property\"}}{{/crossLink}}.\n\t * Other loaders may override this to use different request types, such as {{#crossLink \"ManifestLoader\"}}{{/crossLink}},\n\t * which uses {{#crossLink \"JSONLoader\"}}{{/crossLink}} or {{#crossLink \"JSONPLoader\"}}{{/crossLink}} under the hood.\n\t * @method _createRequest\n\t * @protected\n\t */\n\tp._createRequest = function() {\n\t\tif (!this._preferXHR) {\n\t\t\tthis._request = new createjs.TagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);\n\t\t} else {\n\t\t\tthis._request = new createjs.XHRRequest(this._item);\n\t\t}\n\t};\n\n\t/**\n\t * Create the HTML tag used for loading. This method does nothing by default, and needs to be implemented\n\t * by loaders that require tag loading.\n\t * @method _createTag\n\t * @param {String} src The tag source\n\t * @return {HTMLElement} The tag that was created\n\t * @protected\n\t */\n\tp._createTag = function(src) { return null; };\n\n\t/**\n\t * Dispatch a loadstart {{#crossLink \"Event\"}}{{/crossLink}}. Please see the {{#crossLink \"AbstractLoader/loadstart:event\"}}{{/crossLink}}\n\t * event for details on the event payload.\n\t * @method _sendLoadStart\n\t * @protected\n\t */\n\tp._sendLoadStart = function () {\n\t\tif (this._isCanceled()) { return; }\n\t\tthis.dispatchEvent(\"loadstart\");\n\t};\n\n\t/**\n\t * Dispatch a {{#crossLink \"ProgressEvent\"}}{{/crossLink}}.\n\t * @method _sendProgress\n\t * @param {Number | Object} value The progress of the loaded item, or an object containing <code>loaded</code>\n\t * and <code>total</code> properties.\n\t * @protected\n\t */\n\tp._sendProgress = function (value) {\n\t\tif (this._isCanceled()) { return; }\n\t\tvar event = null;\n\t\tif (typeof(value) == \"number\") {\n\t\t\tthis.progress = value;\n\t\t\tevent = new createjs.ProgressEvent(this.progress);\n\t\t} else {\n\t\t\tevent = value;\n\t\t\tthis.progress = value.loaded / value.total;\n\t\t\tevent.progress = this.progress;\n\t\t\tif (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }\n\t\t}\n\t\tthis.hasEventListener(\"progress\") && this.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Dispatch a complete {{#crossLink \"Event\"}}{{/crossLink}}. Please see the {{#crossLink \"AbstractLoader/complete:event\"}}{{/crossLink}} event\n\t * @method _sendComplete\n\t * @protected\n\t */\n\tp._sendComplete = function () {\n\t\tif (this._isCanceled()) { return; }\n\n\t\tthis.loaded = true;\n\n\t\tvar event = new createjs.Event(\"complete\");\n\t\tevent.rawResult = this._rawResult;\n\n\t\tif (this._result != null) {\n\t\t\tevent.result = this._result;\n\t\t}\n\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Dispatch an error {{#crossLink \"Event\"}}{{/crossLink}}. Please see the {{#crossLink \"AbstractLoader/error:event\"}}{{/crossLink}}\n\t * event for details on the event payload.\n\t * @method _sendError\n\t * @param {ErrorEvent} event The event object containing specific error properties.\n\t * @protected\n\t */\n\tp._sendError = function (event) {\n\t\tif (this._isCanceled() || !this.hasEventListener(\"error\")) { return; }\n\t\tif (event == null) {\n\t\t\tevent = new createjs.ErrorEvent(\"PRELOAD_ERROR_EMPTY\"); // TODO: Populate error\n\t\t}\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Determine if the load has been canceled. This is important to ensure that method calls or asynchronous events\n\t * do not cause issues after the queue has been cleaned up.\n\t * @method _isCanceled\n\t * @return {Boolean} If the loader has been canceled.\n\t * @protected\n\t */\n\tp._isCanceled = function () {\n\t\tif (window.createjs == null || this.canceled) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * A custom result formatter function, which is called just before a request dispatches its complete event. Most\n\t * loader types already have an internal formatter, but this can be user-overridden for custom formatting. The\n\t * formatted result will be available on Loaders using {{#crossLink \"getResult\"}}{{/crossLink}}, and passing `true`.\n\t * @property resultFormatter\n\t * @type Function\n\t * @return {Object} The formatted result\n\t * @since 0.6.0\n\t */\n\tp.resultFormatter = null;\n\n\t/**\n\t * Handle events from internal requests. By default, loaders will handle, and redispatch the necessary events, but\n\t * this method can be overridden for custom behaviours.\n\t * @method handleEvent\n\t * @param {Event} event The event that the internal request dispatches.\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp.handleEvent = function (event) {\n\t\tswitch (event.type) {\n\t\t\tcase \"complete\":\n\t\t\t\tthis._rawResult = event.target._response;\n\t\t\t\tvar result = this.resultFormatter && this.resultFormatter(this);\n\t\t\t\t// The resultFormatter is asynchronous\n\t\t\t\tif (result instanceof Function) {\n\t\t\t\t\tresult.call(this,\n\t\t\t\t\t\t\tcreatejs.proxy(this._resultFormatSuccess, this),\n\t\t\t\t\t\t\tcreatejs.proxy(this._resultFormatFailed, this)\n\t\t\t\t\t);\n\t\t\t\t// The result formatter is synchronous\n\t\t\t\t} else {\n\t\t\t\t\tthis._result =  result || this._rawResult;\n\t\t\t\t\tthis._sendComplete();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"progress\":\n\t\t\t\tthis._sendProgress(event);\n\t\t\t\tbreak;\n\t\t\tcase \"error\":\n\t\t\t\tthis._sendError(event);\n\t\t\t\tbreak;\n\t\t\tcase \"loadstart\":\n\t\t\t\tthis._sendLoadStart();\n\t\t\t\tbreak;\n\t\t\tcase \"abort\":\n\t\t\tcase \"timeout\":\n\t\t\t\tif (!this._isCanceled()) {\n\t\t\t\t\tthis.dispatchEvent(new createjs.ErrorEvent(\"PRELOAD_\" + event.type.toUpperCase() + \"_ERROR\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\t/**\n\t * The \"success\" callback passed to {{#crossLink \"AbstractLoader/resultFormatter\"}}{{/crossLink}} asynchronous\n\t * functions.\n\t * @method _resultFormatSuccess\n\t * @param {Object} result The formatted result\n\t * @private\n\t */\n\tp._resultFormatSuccess = function (result) {\n\t\tthis._result = result;\n\t\tthis._sendComplete();\n\t};\n\n\t/**\n\t * The \"error\" callback passed to {{#crossLink \"AbstractLoader/resultFormatter\"}}{{/crossLink}} asynchronous\n\t * functions.\n\t * @method _resultFormatSuccess\n\t * @param {Object} error The error event\n\t * @private\n\t */\n\tp._resultFormatFailed = function (event) {\n\t\tthis._sendError(event);\n\t};\n\n\t/**\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t */\n\tp.toString = function () {\n\t\treturn \"[PreloadJS AbstractLoader]\";\n\t};\n\n\tcreatejs.AbstractLoader = createjs.promote(AbstractLoader, \"EventDispatcher\");\n\n}());\n\n//##############################################################################\n// AbstractMediaLoader.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * The AbstractMediaLoader is a base class that handles some of the shared methods and properties of loaders that\n\t * handle HTML media elements, such as Video and Audio.\n\t * @class AbstractMediaLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @param {String} type The type of media to load. Usually \"video\" or \"audio\".\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction AbstractMediaLoader(loadItem, preferXHR, type) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, type);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = \"src\";\n\n        this.on(\"initialize\", this._updateXHR, this);\n\t};\n\n\tvar p = createjs.extend(AbstractMediaLoader, createjs.AbstractLoader);\n\n\t// static properties\n\t// public methods\n\tp.load = function () {\n\t\t// TagRequest will handle most of this, but Sound / Video need a few custom properties, so just handle them here.\n\t\tif (!this._tag) {\n\t\t\tthis._tag = this._createTag(this._item.src);\n\t\t}\n\n\t\tthis._tag.preload = \"auto\";\n\t\tthis._tag.load();\n\n\t\tthis.AbstractLoader_load();\n\t};\n\n\t// protected methods\n\t/**\n\t * Creates a new tag for loading if it doesn't exist yet.\n\t * @method _createTag\n\t * @private\n\t */\n\tp._createTag = function () {};\n\n\n\tp._createRequest = function() {\n\t\tif (!this._preferXHR) {\n\t\t\tthis._request = new createjs.MediaTagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);\n\t\t} else {\n\t\t\tthis._request = new createjs.XHRRequest(this._item);\n\t\t}\n\t};\n\n    // protected methods\n    /**\n     * Before the item loads, set its mimeType and responseType.\n     * @property _updateXHR\n     * @param {Event} event\n     * @private\n     */\n    p._updateXHR = function (event) {\n        // Only exists for XHR\n        if (event.loader.setResponseType) {\n            event.loader.setResponseType(\"blob\");\n        }\n    };\n\n\t/**\n\t * The result formatter for media files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLVideoElement|HTMLAudioElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\tthis._tag.removeEventListener && this._tag.removeEventListener(\"canplaythrough\", this._loadedHandler);\n\t\tthis._tag.onstalled = null;\n\t\tif (this._preferXHR) {\n            var URL = window.URL || window.webkitURL;\n            var result = loader.getResult(true);\n\n\t\t\tloader.getTag().src = URL.createObjectURL(result);\n\t\t}\n\t\treturn loader.getTag();\n\t};\n\n\tcreatejs.AbstractMediaLoader = createjs.promote(AbstractMediaLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// AbstractRequest.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * A base class for actual data requests, such as {{#crossLink \"XHRRequest\"}}{{/crossLink}}, {{#crossLink \"TagRequest\"}}{{/crossLink}},\n\t * and {{#crossLink \"MediaRequest\"}}{{/crossLink}}. PreloadJS loaders will typically use a data loader under the\n\t * hood to get data.\n\t * @class AbstractRequest\n\t * @param {LoadItem} item\n\t * @constructor\n\t */\n\tvar AbstractRequest = function (item) {\n\t\tthis._item = item;\n\t};\n\n\tvar p = createjs.extend(AbstractRequest, createjs.EventDispatcher);\n\n\t// public methods\n\t/**\n\t * Begin a load.\n\t * @method load\n\t */\n\tp.load =  function() {};\n\n\t/**\n\t * Clean up a request.\n\t * @method destroy\n\t */\n\tp.destroy = function() {};\n\n\t/**\n\t * Cancel an in-progress request.\n\t * @method cancel\n\t */\n\tp.cancel = function() {};\n\n\tcreatejs.AbstractRequest = createjs.promote(AbstractRequest, \"EventDispatcher\");\n\n}());\n\n//##############################################################################\n// TagRequest.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * An {{#crossLink \"AbstractRequest\"}}{{/crossLink}} that loads HTML tags, such as images and scripts.\n\t * @class TagRequest\n\t * @param {LoadItem} loadItem\n\t * @param {HTMLElement} tag\n\t * @param {String} srcAttribute The tag attribute that specifies the source, such as \"src\", \"href\", etc.\n\t */\n\tfunction TagRequest(loadItem, tag, srcAttribute) {\n\t\tthis.AbstractRequest_constructor(loadItem);\n\n\t\t// protected properties\n\t\t/**\n\t\t * The HTML tag instance that is used to load.\n\t\t * @property _tag\n\t\t * @type {HTMLElement}\n\t\t * @protected\n\t\t */\n\t\tthis._tag = tag;\n\n\t\t/**\n\t\t * The tag attribute that specifies the source, such as \"src\", \"href\", etc.\n\t\t * @property _tagSrcAttribute\n\t\t * @type {String}\n\t\t * @protected\n\t\t */\n\t\tthis._tagSrcAttribute = srcAttribute;\n\n\t\t/**\n\t\t * A method closure used for handling the tag load event.\n\t\t * @property _loadedHandler\n\t\t * @type {Function}\n\t\t * @private\n\t\t */\n\t\tthis._loadedHandler = createjs.proxy(this._handleTagComplete, this);\n\n\t\t/**\n\t\t * Determines if the element was added to the DOM automatically by PreloadJS, so it can be cleaned up after.\n\t\t * @property _addedToDOM\n\t\t * @type {Boolean}\n\t\t * @private\n\t\t */\n\t\tthis._addedToDOM = false;\n\n\t};\n\n\tvar p = createjs.extend(TagRequest, createjs.AbstractRequest);\n\n\t// public methods\n\tp.load = function () {\n\t\tthis._tag.onload = createjs.proxy(this._handleTagComplete, this);\n\t\tthis._tag.onreadystatechange = createjs.proxy(this._handleReadyStateChange, this);\n\t\tthis._tag.onerror = createjs.proxy(this._handleError, this);\n\n\t\tvar evt = new createjs.Event(\"initialize\");\n\t\tevt.loader = this._tag;\n\n\t\tthis.dispatchEvent(evt);\n\n\t\tthis._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);\n\n\t\tthis._tag[this._tagSrcAttribute] = this._item.src;\n\n\t\t// wdg:: Append the tag AFTER setting the src, or SVG loading on iOS will fail.\n\t\tif (this._tag.parentNode == null) {\n\t\t\tcreatejs.DomUtils.appendToBody(this._tag);\n\t\t\tthis._addedToDOM = true;\n\t\t}\n\t};\n\n\tp.destroy = function() {\n\t\tthis._clean();\n\t\tthis._tag = null;\n\n\t\tthis.AbstractRequest_destroy();\n\t};\n\n\t// private methods\n\t/**\n\t * Handle the readyStateChange event from a tag. We need this in place of the `onload` callback (mainly SCRIPT\n\t * and LINK tags), but other cases may exist.\n\t * @method _handleReadyStateChange\n\t * @private\n\t */\n\tp._handleReadyStateChange = function () {\n\t\tclearTimeout(this._loadTimeout);\n\t\t// This is strictly for tags in browsers that do not support onload.\n\t\tvar tag = this._tag;\n\n\t\t// Complete is for old IE support.\n\t\tif (tag.readyState == \"loaded\" || tag.readyState == \"complete\") {\n\t\t\tthis._handleTagComplete();\n\t\t}\n\t};\n\n\t/**\n\t * Handle any error events from the tag.\n\t * @method _handleError\n\t * @protected\n\t */\n\tp._handleError = function() {\n\t\tthis._clean();\n\t\tthis.dispatchEvent(\"error\");\n\t};\n\n\t/**\n\t * Handle the tag's onload callback.\n\t * @method _handleTagComplete\n\t * @private\n\t */\n\tp._handleTagComplete = function () {\n\t\tthis._rawResult = this._tag;\n\t\tthis._result = this.resultFormatter && this.resultFormatter(this) || this._rawResult;\n\n\t\tthis._clean();\n\n\t\tthis.dispatchEvent(\"complete\");\n\t};\n\n\t/**\n\t * The tag request has not loaded within the time specified in loadTimeout.\n\t * @method _handleError\n\t * @param {Object} event The XHR error event.\n\t * @private\n\t */\n\tp._handleTimeout = function () {\n\t\tthis._clean();\n\t\tthis.dispatchEvent(new createjs.Event(\"timeout\"));\n\t};\n\n\t/**\n\t * Remove event listeners, but don't destroy the request object\n\t * @method _clean\n\t * @private\n\t */\n\tp._clean = function() {\n\t\tthis._tag.onload = null;\n\t\tthis._tag.onreadystatechange = null;\n\t\tthis._tag.onerror = null;\n\t\tif (this._addedToDOM && this._tag.parentNode != null) {\n\t\t\tthis._tag.parentNode.removeChild(this._tag);\n\t\t}\n\t\tclearTimeout(this._loadTimeout);\n\t};\n\n\t/**\n\t * Handle a stalled audio event. The main place this happens is with HTMLAudio in Chrome when playing back audio\n\t * that is already in a load, but not complete.\n\t * @method _handleStalled\n\t * @private\n\t */\n\tp._handleStalled = function () {\n\t\t//Ignore, let the timeout take care of it. Sometimes its not really stopped.\n\t};\n\n\tcreatejs.TagRequest = createjs.promote(TagRequest, \"AbstractRequest\");\n\n}());\n\n//##############################################################################\n// MediaTagRequest.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * An {{#crossLink \"TagRequest\"}}{{/crossLink}} that loads HTML tags for video and audio.\n\t * @class MediaTagRequest\n\t * @param {LoadItem} loadItem\n\t * @param {HTMLAudioElement|HTMLVideoElement} tag\n\t * @param {String} srcAttribute The tag attribute that specifies the source, such as \"src\", \"href\", etc.\n\t * @constructor\n\t */\n\tfunction MediaTagRequest(loadItem, tag, srcAttribute) {\n\t\tthis.AbstractRequest_constructor(loadItem);\n\n\t\t// protected properties\n\t\tthis._tag = tag;\n\t\tthis._tagSrcAttribute = srcAttribute;\n\t\tthis._loadedHandler = createjs.proxy(this._handleTagComplete, this);\n\t};\n\n\tvar p = createjs.extend(MediaTagRequest, createjs.TagRequest);\n\tvar s = MediaTagRequest;\n\n\t// public methods\n\tp.load = function () {\n\t\tvar sc = createjs.proxy(this._handleStalled, this);\n\t\tthis._stalledCallback = sc;\n\n\t\tvar pc = createjs.proxy(this._handleProgress, this);\n\t\tthis._handleProgress = pc;\n\n\t\tthis._tag.addEventListener(\"stalled\", sc);\n\t\tthis._tag.addEventListener(\"progress\", pc);\n\n\t\t// This will tell us when audio is buffered enough to play through, but not when its loaded.\n\t\t// The tag doesn't keep loading in Chrome once enough has buffered, and we have decided that behaviour is sufficient.\n\t\tthis._tag.addEventListener && this._tag.addEventListener(\"canplaythrough\", this._loadedHandler, false); // canplaythrough callback doesn't work in Chrome, so we use an event.\n\n\t\tthis.TagRequest_load();\n\t};\n\n\t// private methods\n\tp._handleReadyStateChange = function () {\n\t\tclearTimeout(this._loadTimeout);\n\t\t// This is strictly for tags in browsers that do not support onload.\n\t\tvar tag = this._tag;\n\n\t\t// Complete is for old IE support.\n\t\tif (tag.readyState == \"loaded\" || tag.readyState == \"complete\") {\n\t\t\tthis._handleTagComplete();\n\t\t}\n\t};\n\n\tp._handleStalled = function () {\n\t\t//Ignore, let the timeout take care of it. Sometimes its not really stopped.\n\t};\n\n\t/**\n\t * An XHR request has reported progress.\n\t * @method _handleProgress\n\t * @param {Object} event The XHR progress event.\n\t * @private\n\t */\n\tp._handleProgress = function (event) {\n\t\tif (!event || event.loaded > 0 && event.total == 0) {\n\t\t\treturn; // Sometimes we get no \"total\", so just ignore the progress event.\n\t\t}\n\n\t\tvar newEvent = new createjs.ProgressEvent(event.loaded, event.total);\n\t\tthis.dispatchEvent(newEvent);\n\t};\n\n\t// protected methods\n\tp._clean = function () {\n\t\tthis._tag.removeEventListener && this._tag.removeEventListener(\"canplaythrough\", this._loadedHandler);\n\t\tthis._tag.removeEventListener(\"stalled\", this._stalledCallback);\n\t\tthis._tag.removeEventListener(\"progress\", this._progressCallback);\n\n\t\tthis.TagRequest__clean();\n\t};\n\n\tcreatejs.MediaTagRequest = createjs.promote(MediaTagRequest, \"TagRequest\");\n\n}());\n\n//##############################################################################\n// XHRRequest.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function () {\n\t\"use strict\";\n\n// constructor\n\t/**\n\t * A preloader that loads items using XHR requests, usually XMLHttpRequest. However XDomainRequests will be used\n\t * for cross-domain requests if possible, and older versions of IE fall back on to ActiveX objects when necessary.\n\t * XHR requests load the content as text or binary data, provide progress and consistent completion events, and\n\t * can be canceled during load. Note that XHR is not supported in IE 6 or earlier, and is not recommended for\n\t * cross-domain loading.\n\t * @class XHRRequest\n\t * @constructor\n\t * @param {Object} item The object that defines the file to load. Please see the {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}}\n\t * for an overview of supported file properties.\n\t * @extends AbstractLoader\n\t */\n\tfunction XHRRequest (item) {\n\t\tthis.AbstractRequest_constructor(item);\n\n\t\t// protected properties\n\t\t/**\n\t\t * A reference to the XHR request used to load the content.\n\t\t * @property _request\n\t\t * @type {XMLHttpRequest | XDomainRequest | ActiveX.XMLHTTP}\n\t\t * @private\n\t\t */\n\t\tthis._request = null;\n\n\t\t/**\n\t\t * A manual load timeout that is used for browsers that do not support the onTimeout event on XHR (XHR level 1,\n\t\t * typically IE9).\n\t\t * @property _loadTimeout\n\t\t * @type {Number}\n\t\t * @private\n\t\t */\n\t\tthis._loadTimeout = null;\n\n\t\t/**\n\t\t * The browser's XHR (XMLHTTPRequest) version. Supported versions are 1 and 2. There is no official way to detect\n\t\t * the version, so we use capabilities to make a best guess.\n\t\t * @property _xhrLevel\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t * @private\n\t\t */\n\t\tthis._xhrLevel = 1;\n\n\t\t/**\n\t\t * The response of a loaded file. This is set because it is expensive to look up constantly. This property will be\n\t\t * null until the file is loaded.\n\t\t * @property _response\n\t\t * @type {mixed}\n\t\t * @private\n\t\t */\n\t\tthis._response = null;\n\n\t\t/**\n\t\t * The response of the loaded file before it is modified. In most cases, content is converted from raw text to\n\t\t * an HTML tag or a formatted object which is set to the <code>result</code> property, but the developer may still\n\t\t * want to access the raw content as it was loaded.\n\t\t * @property _rawResponse\n\t\t * @type {String|Object}\n\t\t * @private\n\t\t */\n\t\tthis._rawResponse = null;\n\n\t\tthis._canceled = false;\n\n\t\t// Setup our event handlers now.\n\t\tthis._handleLoadStartProxy = createjs.proxy(this._handleLoadStart, this);\n\t\tthis._handleProgressProxy = createjs.proxy(this._handleProgress, this);\n\t\tthis._handleAbortProxy = createjs.proxy(this._handleAbort, this);\n\t\tthis._handleErrorProxy = createjs.proxy(this._handleError, this);\n\t\tthis._handleTimeoutProxy = createjs.proxy(this._handleTimeout, this);\n\t\tthis._handleLoadProxy = createjs.proxy(this._handleLoad, this);\n\t\tthis._handleReadyStateChangeProxy = createjs.proxy(this._handleReadyStateChange, this);\n\n\t\tif (!this._createXHR(item)) {\n\t\t\t//TODO: Throw error?\n\t\t}\n\t};\n\n\tvar p = createjs.extend(XHRRequest, createjs.AbstractRequest);\n\n// static properties\n\t/**\n\t * A list of XMLHTTP object IDs to try when building an ActiveX object for XHR requests in earlier versions of IE.\n\t * @property ACTIVEX_VERSIONS\n\t * @type {Array}\n\t * @since 0.4.2\n\t * @private\n\t */\n\tXHRRequest.ACTIVEX_VERSIONS = [\n\t\t\"Msxml2.XMLHTTP.6.0\",\n\t\t\"Msxml2.XMLHTTP.5.0\",\n\t\t\"Msxml2.XMLHTTP.4.0\",\n\t\t\"MSXML2.XMLHTTP.3.0\",\n\t\t\"MSXML2.XMLHTTP\",\n\t\t\"Microsoft.XMLHTTP\"\n\t];\n\n// Public methods\n\t/**\n\t * Look up the loaded result.\n\t * @method getResult\n\t * @param {Boolean} [raw=false] Return a raw result instead of a formatted result. This applies to content\n\t * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be\n\t * returned instead.\n\t * @return {Object} A result object containing the content that was loaded, such as:\n\t * <ul>\n\t *      <li>An image tag (&lt;image /&gt;) for images</li>\n\t *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts loaded with tags may be added to the\n\t *      HTML head.</li>\n\t *      <li>A style tag for CSS (&lt;style /&gt;)</li>\n\t *      <li>Raw text for TEXT</li>\n\t *      <li>A formatted JavaScript object defined by JSON</li>\n\t *      <li>An XML document</li>\n\t *      <li>An binary arraybuffer loaded by XHR</li>\n\t * </ul>\n\t * Note that if a raw result is requested, but not found, the result will be returned instead.\n\t */\n\tp.getResult = function (raw) {\n\t\tif (raw && this._rawResponse) {\n\t\t\treturn this._rawResponse;\n\t\t}\n\t\treturn this._response;\n\t};\n\n\t// Overrides abstract method in AbstractRequest\n\tp.cancel = function () {\n\t\tthis.canceled = true;\n\t\tthis._clean();\n\t\tthis._request.abort();\n\t};\n\n\t// Overrides abstract method in AbstractLoader\n\tp.load = function () {\n\t\tif (this._request == null) {\n\t\t\tthis._handleError();\n\t\t\treturn;\n\t\t}\n\n\t\t//Events\n\t\tif (this._request.addEventListener != null) {\n\t\t\tthis._request.addEventListener(\"loadstart\", this._handleLoadStartProxy, false);\n\t\t\tthis._request.addEventListener(\"progress\", this._handleProgressProxy, false);\n\t\t\tthis._request.addEventListener(\"abort\", this._handleAbortProxy, false);\n\t\t\tthis._request.addEventListener(\"error\", this._handleErrorProxy, false);\n\t\t\tthis._request.addEventListener(\"timeout\", this._handleTimeoutProxy, false);\n\n\t\t\t// Note: We don't get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.\n\t\t\tthis._request.addEventListener(\"load\", this._handleLoadProxy, false);\n\t\t\tthis._request.addEventListener(\"readystatechange\", this._handleReadyStateChangeProxy, false);\n\t\t} else {\n\t\t\t// IE9 support\n\t\t\tthis._request.onloadstart = this._handleLoadStartProxy;\n\t\t\tthis._request.onprogress = this._handleProgressProxy;\n\t\t\tthis._request.onabort = this._handleAbortProxy;\n\t\t\tthis._request.onerror = this._handleErrorProxy;\n\t\t\tthis._request.ontimeout = this._handleTimeoutProxy;\n\n\t\t\t// Note: We don't get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.\n\t\t\tthis._request.onload = this._handleLoadProxy;\n\t\t\tthis._request.onreadystatechange = this._handleReadyStateChangeProxy;\n\t\t}\n\n\t\t// Set up a timeout if we don't have XHR2\n\t\tif (this._xhrLevel == 1) {\n\t\t\tthis._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);\n\t\t}\n\n\t\t// Sometimes we get back 404s immediately, particularly when there is a cross origin request.  // note this does not catch in Chrome\n\t\ttry {\n\t\t\tif (!this._item.values) {\n\t\t\t\tthis._request.send();\n\t\t\t} else {\n\t\t\t\tthis._request.send(createjs.URLUtils.formatQueryString(this._item.values));\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.dispatchEvent(new createjs.ErrorEvent(\"XHR_SEND\", null, error));\n\t\t}\n\t};\n\n\tp.setResponseType = function (type) {\n\t\t// Some old browsers doesn't support blob, so we convert arraybuffer to blob after response is downloaded\n\t\tif (type === 'blob') {\n\t\t\ttype = window.URL ? 'blob' : 'arraybuffer';\n\t\t\tthis._responseType = type;\n\t\t}\n\t\tthis._request.responseType = type;\n\t};\n\n\t/**\n\t * Get all the response headers from the XmlHttpRequest.\n\t *\n\t * <strong>From the docs:</strong> Return all the HTTP headers, excluding headers that are a case-insensitive match\n\t * for Set-Cookie or Set-Cookie2, as a single string, with each header line separated by a U+000D CR U+000A LF pair,\n\t * excluding the status line, and with each header name and header value separated by a U+003A COLON U+0020 SPACE\n\t * pair.\n\t * @method getAllResponseHeaders\n\t * @return {String}\n\t * @since 0.4.1\n\t */\n\tp.getAllResponseHeaders = function () {\n\t\tif (this._request.getAllResponseHeaders instanceof Function) {\n\t\t\treturn this._request.getAllResponseHeaders();\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t};\n\n\t/**\n\t * Get a specific response header from the XmlHttpRequest.\n\t *\n\t * <strong>From the docs:</strong> Returns the header field value from the response of which the field name matches\n\t * header, unless the field name is Set-Cookie or Set-Cookie2.\n\t * @method getResponseHeader\n\t * @param {String} header The header name to retrieve.\n\t * @return {String}\n\t * @since 0.4.1\n\t */\n\tp.getResponseHeader = function (header) {\n\t\tif (this._request.getResponseHeader instanceof Function) {\n\t\t\treturn this._request.getResponseHeader(header);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t};\n\n// protected methods\n\t/**\n\t * The XHR request has reported progress.\n\t * @method _handleProgress\n\t * @param {Object} event The XHR progress event.\n\t * @private\n\t */\n\tp._handleProgress = function (event) {\n\t\tif (!event || event.loaded > 0 && event.total == 0) {\n\t\t\treturn; // Sometimes we get no \"total\", so just ignore the progress event.\n\t\t}\n\n\t\tvar newEvent = new createjs.ProgressEvent(event.loaded, event.total);\n\t\tthis.dispatchEvent(newEvent);\n\t};\n\n\t/**\n\t * The XHR request has reported a load start.\n\t * @method _handleLoadStart\n\t * @param {Object} event The XHR loadStart event.\n\t * @private\n\t */\n\tp._handleLoadStart = function (event) {\n\t\tclearTimeout(this._loadTimeout);\n\t\tthis.dispatchEvent(\"loadstart\");\n\t};\n\n\t/**\n\t * The XHR request has reported an abort event.\n\t * @method handleAbort\n\t * @param {Object} event The XHR abort event.\n\t * @private\n\t */\n\tp._handleAbort = function (event) {\n\t\tthis._clean();\n\t\tthis.dispatchEvent(new createjs.ErrorEvent(\"XHR_ABORTED\", null, event));\n\t};\n\n\t/**\n\t * The XHR request has reported an error event.\n\t * @method _handleError\n\t * @param {Object} event The XHR error event.\n\t * @private\n\t */\n\tp._handleError = function (event) {\n\t\tthis._clean();\n\t\tthis.dispatchEvent(new createjs.ErrorEvent(event.message));\n\t};\n\n\t/**\n\t * The XHR request has reported a readyState change. Note that older browsers (IE 7 & 8) do not provide an onload\n\t * event, so we must monitor the readyStateChange to determine if the file is loaded.\n\t * @method _handleReadyStateChange\n\t * @param {Object} event The XHR readyStateChange event.\n\t * @private\n\t */\n\tp._handleReadyStateChange = function (event) {\n\t\tif (this._request.readyState == 4) {\n\t\t\tthis._handleLoad();\n\t\t}\n\t};\n\n\t/**\n\t * The XHR request has completed. This is called by the XHR request directly, or by a readyStateChange that has\n\t * <code>request.readyState == 4</code>. Only the first call to this method will be processed.\n\t *\n\t * Note that This method uses {{#crossLink \"_checkError\"}}{{/crossLink}} to determine if the server has returned an\n\t * error code.\n\t * @method _handleLoad\n\t * @param {Object} event The XHR load event.\n\t * @private\n\t */\n\tp._handleLoad = function (event) {\n\t\tif (this.loaded) {\n\t\t\treturn;\n\t\t}\n\t\tthis.loaded = true;\n\n\t\tvar error = this._checkError();\n\t\tif (error) {\n\t\t\tthis._handleError(error);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._response = this._getResponse();\n\t\t// Convert arraybuffer back to blob\n\t\tif (this._responseType === 'arraybuffer') {\n\t\t\ttry {\n\t\t\t\tthis._response = new Blob([this._response]);\n\t\t\t} catch (e) {\n\t\t\t\t// Fallback to use BlobBuilder if Blob constructor is not supported\n\t\t\t\t// Tested on Android 2.3 ~ 4.2 and iOS5 safari\n\t\t\t\twindow.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\t\t\t\tif (e.name === 'TypeError' && window.BlobBuilder) {\n\t\t\t\t\tvar builder = new BlobBuilder();\n\t\t\t\t\tbuilder.append(this._response);\n\t\t\t\t\tthis._response = builder.getBlob();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._clean();\n\n\t\tthis.dispatchEvent(new createjs.Event(\"complete\"));\n\t};\n\n\t/**\n\t * The XHR request has timed out. This is called by the XHR request directly, or via a <code>setTimeout</code>\n\t * callback.\n\t * @method _handleTimeout\n\t * @param {Object} [event] The XHR timeout event. This is occasionally null when called by the backup setTimeout.\n\t * @private\n\t */\n\tp._handleTimeout = function (event) {\n\t\tthis._clean();\n\t\tthis.dispatchEvent(new createjs.ErrorEvent(\"PRELOAD_TIMEOUT\", null, event));\n\t};\n\n// Protected\n\t/**\n\t * Determine if there is an error in the current load.\n\t * Currently this checks the status of the request for problem codes, and not actual response content:\n\t * <ul>\n\t *     <li>Status codes between 400 and 599 (HTTP error range)</li>\n\t *     <li>A status of 0, but *only when the application is running on a server*. If the application is running\n\t *     on `file:`, then it may incorrectly treat an error on local (or embedded applications) as a successful\n\t *     load.</li>\n\t * </ul>\n\t * @method _checkError\n\t * @return {Error} An error with the status code in the `message` argument.\n\t * @private\n\t */\n\tp._checkError = function () {\n\t\tvar status = parseInt(this._request.status);\n\t\tif (status >= 400 && status <= 599) {\n\t\t\treturn new Error(status);\n\t\t} else if (status == 0) {\n\t\t\tif ((/^https?:/).test(location.protocol)) { return new Error(0); }\n\t\t\treturn null; // Likely an embedded app.\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t};\n\n\n\t/**\n\t * Validate the response. Different browsers have different approaches, some of which throw errors when accessed\n\t * in other browsers. If there is no response, the <code>_response</code> property will remain null.\n\t * @method _getResponse\n\t * @private\n\t */\n\tp._getResponse = function () {\n\t\tif (this._response != null) {\n\t\t\treturn this._response;\n\t\t}\n\n\t\tif (this._request.response != null) {\n\t\t\treturn this._request.response;\n\t\t}\n\n\t\t// Android 2.2 uses .responseText\n\t\ttry {\n\t\t\tif (this._request.responseText != null) {\n\t\t\t\treturn this._request.responseText;\n\t\t\t}\n\t\t} catch (e) {\n\t\t}\n\n\t\t// When loading XML, IE9 does not return .response, instead it returns responseXML.xml\n\t\ttry {\n\t\t\tif (this._request.responseXML != null) {\n\t\t\t\treturn this._request.responseXML;\n\t\t\t}\n\t\t} catch (e) {\n\t\t}\n\n\t\treturn null;\n\t};\n\n\t/**\n\t * Create an XHR request. Depending on a number of factors, we get totally different results.\n\t * <ol><li>Some browsers get an <code>XDomainRequest</code> when loading cross-domain.</li>\n\t *      <li>XMLHttpRequest are created when available.</li>\n\t *      <li>ActiveX.XMLHTTP objects are used in older IE browsers.</li>\n\t *      <li>Text requests override the mime type if possible</li>\n\t *      <li>Origin headers are sent for crossdomain requests in some browsers.</li>\n\t *      <li>Binary loads set the response type to \"arraybuffer\"</li></ol>\n\t * @method _createXHR\n\t * @param {Object} item The requested item that is being loaded.\n\t * @return {Boolean} If an XHR request or equivalent was successfully created.\n\t * @private\n\t */\n\tp._createXHR = function (item) {\n\t\t// Check for cross-domain loads. We can't fully support them, but we can try.\n\t\tvar crossdomain = createjs.URLUtils.isCrossDomain(item);\n\t\tvar headers = {};\n\n\t\t// Create the request. Fallback to whatever support we have.\n\t\tvar req = null;\n\t\tif (window.XMLHttpRequest) {\n\t\t\treq = new XMLHttpRequest();\n\t\t\t// This is 8 or 9, so use XDomainRequest instead.\n\t\t\tif (crossdomain && req.withCredentials === undefined && window.XDomainRequest) {\n\t\t\t\treq = new XDomainRequest();\n\t\t\t}\n\t\t} else { // Old IE versions use a different approach\n\t\t\tfor (var i = 0, l = s.ACTIVEX_VERSIONS.length; i < l; i++) {\n\t\t\t\tvar axVersion = s.ACTIVEX_VERSIONS[i];\n\t\t\t\ttry {\n\t\t\t\t\treq = new ActiveXObject(axVersion);\n\t\t\t\t\tbreak;\n\t\t\t\t} catch (e) {\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (req == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Default to utf-8 for Text requests.\n\t\tif (item.mimeType == null && createjs.RequestUtils.isText(item.type)) {\n\t\t\titem.mimeType = \"text/plain; charset=utf-8\";\n\t\t}\n\n\t\t// IE9 doesn't support overrideMimeType(), so we need to check for it.\n\t\tif (item.mimeType && req.overrideMimeType) {\n\t\t\treq.overrideMimeType(item.mimeType);\n\t\t}\n\n\t\t// Determine the XHR level\n\t\tthis._xhrLevel = (typeof req.responseType === \"string\") ? 2 : 1;\n\n\t\tvar src = null;\n\t\tif (item.method == createjs.Methods.GET) {\n\t\t\tsrc = createjs.URLUtils.buildURI(item.src, item.values);\n\t\t} else {\n\t\t\tsrc = item.src;\n\t\t}\n\n\t\t// Open the request.  Set cross-domain flags if it is supported (XHR level 1 only)\n\t\treq.open(item.method || createjs.Methods.GET, src, true);\n\n\t\tif (crossdomain && req instanceof XMLHttpRequest && this._xhrLevel == 1) {\n\t\t\theaders[\"Origin\"] = location.origin;\n\t\t}\n\n\t\t// To send data we need to set the Content-type header)\n\t\tif (item.values && item.method == createjs.Methods.POST) {\n\t\t\theaders[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n\t\t}\n\n\t\tif (!crossdomain && !headers[\"X-Requested-With\"]) {\n\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t}\n\n\t\tif (item.headers) {\n\t\t\tfor (var n in item.headers) {\n\t\t\t\theaders[n] = item.headers[n];\n\t\t\t}\n\t\t}\n\n\t\tfor (n in headers) {\n\t\t\treq.setRequestHeader(n, headers[n])\n\t\t}\n\n\t\tif (req instanceof XMLHttpRequest && item.withCredentials !== undefined) {\n\t\t\treq.withCredentials = item.withCredentials;\n\t\t}\n\n\t\tthis._request = req;\n\n\t\treturn true;\n\t};\n\n\t/**\n\t * A request has completed (or failed or canceled), and needs to be disposed.\n\t * @method _clean\n\t * @private\n\t */\n\tp._clean = function () {\n\t\tclearTimeout(this._loadTimeout);\n\n\t\tif (this._request.removeEventListener != null) {\n\t\t\tthis._request.removeEventListener(\"loadstart\", this._handleLoadStartProxy);\n\t\t\tthis._request.removeEventListener(\"progress\", this._handleProgressProxy);\n\t\t\tthis._request.removeEventListener(\"abort\", this._handleAbortProxy);\n\t\t\tthis._request.removeEventListener(\"error\", this._handleErrorProxy);\n\t\t\tthis._request.removeEventListener(\"timeout\", this._handleTimeoutProxy);\n\t\t\tthis._request.removeEventListener(\"load\", this._handleLoadProxy);\n\t\t\tthis._request.removeEventListener(\"readystatechange\", this._handleReadyStateChangeProxy);\n\t\t} else {\n\t\t\tthis._request.onloadstart = null;\n\t\t\tthis._request.onprogress = null;\n\t\t\tthis._request.onabort = null;\n\t\t\tthis._request.onerror = null;\n\t\t\tthis._request.ontimeout = null;\n\t\t\tthis._request.onload = null;\n\t\t\tthis._request.onreadystatechange = null;\n\t\t}\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[PreloadJS XHRRequest]\";\n\t};\n\n\tcreatejs.XHRRequest = createjs.promote(XHRRequest, \"AbstractRequest\");\n\n}());\n\n//##############################################################################\n// LoadQueue.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n/*\n TODO: WINDOWS ISSUES\n * No error for HTML audio in IE 678\n * SVG no failure error in IE 67 (maybe 8) TAGS AND XHR\n * No script complete handler in IE 67 TAGS (XHR is fine)\n * No XML/JSON in IE6 TAGS\n * Need to hide loading SVG in Opera TAGS\n * No CSS onload/readystatechange in Safari or Android TAGS (requires rule checking)\n * SVG no load or failure in Opera XHR\n * Reported issues with IE7/8\n */\n\n(function () {\n\t\"use strict\";\n\n// constructor\n\t/**\n\t * The LoadQueue class is the main API for preloading content. LoadQueue is a load manager, which can preload either\n\t * a single file, or queue of files.\n\t *\n\t * <b>Creating a Queue</b><br />\n\t * To use LoadQueue, create a LoadQueue instance. If you want to force tag loading where possible, set the preferXHR\n\t * argument to false.\n\t *\n\t *      var queue = new createjs.LoadQueue(true);\n\t *\n\t * <b>Listening for Events</b><br />\n\t * Add any listeners you want to the queue. Since PreloadJS 0.3.0, the {{#crossLink \"EventDispatcher\"}}{{/crossLink}}\n\t * lets you add as many listeners as you want for events. You can subscribe to the following events:<ul>\n\t *     <li>{{#crossLink \"AbstractLoader/complete:event\"}}{{/crossLink}}: fired when a queue completes loading all\n\t *     files</li>\n\t *     <li>{{#crossLink \"AbstractLoader/error:event\"}}{{/crossLink}}: fired when the queue encounters an error with\n\t *     any file.</li>\n\t *     <li>{{#crossLink \"AbstractLoader/progress:event\"}}{{/crossLink}}: Progress for the entire queue has\n\t *     changed.</li>\n\t *     <li>{{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}}: A single file has completed loading.</li>\n\t *     <li>{{#crossLink \"LoadQueue/fileprogress:event\"}}{{/crossLink}}: Progress for a single file has changes. Note\n\t *     that only files loaded with XHR (or possibly by plugins) will fire progress events other than 0 or 100%.</li>\n\t * </ul>\n\t *\n\t *      queue.on(\"fileload\", handleFileLoad, this);\n\t *      queue.on(\"complete\", handleComplete, this);\n\t *\n\t * <b>Adding files and manifests</b><br />\n\t * Add files you want to load using {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}} or add multiple files at a\n\t * time using a list or a manifest definition using {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}. Files are\n\t * appended to the end of the active queue, so you can use these methods as many times as you like, whenever you\n\t * like.\n\t *\n\t *      queue.loadFile(\"filePath/file.jpg\");\n\t *      queue.loadFile({id:\"image\", src:\"filePath/file.jpg\"});\n\t *      queue.loadManifest([\"filePath/file.jpg\", {id:\"image\", src:\"filePath/file.jpg\"}]);\n\t *\n\t *      // Use an external manifest\n\t *      queue.loadManifest(\"path/to/manifest.json\");\n\t *      queue.loadManifest({src:\"manifest.json\", type:\"manifest\"});\n\t *\n\t * If you pass `false` as the `loadNow` parameter, the queue will not kick of the load of the files, but it will not\n\t * stop if it has already been started. Call the {{#crossLink \"AbstractLoader/load\"}}{{/crossLink}} method to begin\n\t * a paused queue. Note that a paused queue will automatically resume when new files are added to it with a\n\t * `loadNow` argument of `true`.\n\t *\n\t *      queue.load();\n\t *\n\t * <b>File Types</b><br />\n\t * The file type of a manifest item is auto-determined by the file extension. The pattern matching in PreloadJS\n\t * should handle the majority of standard file and url formats, and works with common file extensions. If you have\n\t * either a non-standard file extension, or are serving the file using a proxy script, then you can pass in a\n\t * <code>type</code> property with any manifest item.\n\t *\n\t *      queue.loadFile({src:\"path/to/myFile.mp3x\", type:createjs.Types.SOUND});\n\t *\n\t *      // Note that PreloadJS will not read a file extension from the query string\n\t *      queue.loadFile({src:\"http://server.com/proxy?file=image.jpg\", type:createjs.Types.IMAGE});\n\t *\n\t * Supported types are defined on the {{#crossLink \"AbstractLoader\"}}{{/crossLink}} class, and include:\n\t * <ul>\n\t *     <li>{{#crossLink \"Types/BINARY:property\"}}{{/crossLink}}: Raw binary data via XHR</li>\n\t *     <li>{{#crossLink \"Types/CSS:property\"}}{{/crossLink}}: CSS files</li>\n\t *     <li>{{#crossLink \"Types/IMAGE:property\"}}{{/crossLink}}: Common image formats</li>\n\t *     <li>{{#crossLink \"Types/JAVASCRIPT:property\"}}{{/crossLink}}: JavaScript files</li>\n\t *     <li>{{#crossLink \"Types/JSON:property\"}}{{/crossLink}}: JSON data</li>\n\t *     <li>{{#crossLink \"Types/JSONP:property\"}}{{/crossLink}}: JSON files cross-domain</li>\n\t *     <li>{{#crossLink \"Types/MANIFEST:property\"}}{{/crossLink}}: A list of files to load in JSON format, see\n\t *     {{#crossLink \"AbstractLoader/loadManifest\"}}{{/crossLink}}</li>\n\t *     <li>{{#crossLink \"Types/SOUND:property\"}}{{/crossLink}}: Audio file formats</li>\n\t *     <li>{{#crossLink \"Types/SPRITESHEET:property\"}}{{/crossLink}}: JSON SpriteSheet definitions. This\n\t *     will also load sub-images, and provide a {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instance.</li>\n\t *     <li>{{#crossLink \"Types/SVG:property\"}}{{/crossLink}}: SVG files</li>\n\t *     <li>{{#crossLink \"Types/TEXT:property\"}}{{/crossLink}}: Text files - XHR only</li>\n     *     <li>{{#crossLink \"Types/VIDEO:property\"}}{{/crossLink}}: Video objects</li>\n\t *     <li>{{#crossLink \"Types/XML:property\"}}{{/crossLink}}: XML data</li>\n\t * </ul>\n\t *\n\t * <em>Note: Loader types used to be defined on LoadQueue, but have been moved to the Types class</em>\n\t *\n\t * <b>Handling Results</b><br />\n\t * When a file is finished downloading, a {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}} event is\n\t * dispatched. In an example above, there is an event listener snippet for fileload. Loaded files are usually a\n\t * formatted object that can be used immediately, including:\n\t * <ul>\n\t *     <li>Binary: The binary loaded result</li>\n\t *     <li>CSS: A &lt;link /&gt; tag</li>\n\t *     <li>Image: An &lt;img /&gt; tag</li>\n\t *     <li>JavaScript: A &lt;script /&gt; tag</li>\n\t *     <li>JSON/JSONP: A formatted JavaScript Object</li>\n\t *     <li>Manifest: A JavaScript object.\n\t *     <li>Sound: An &lt;audio /&gt; tag</a>\n\t *     <li>SpriteSheet: A {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instance, containing loaded images.\n\t *     <li>SVG: An &lt;object /&gt; tag</li>\n\t *     <li>Text: Raw text</li>\n     *     <li>Video: A Video DOM node</li>\n\t *     <li>XML: An XML DOM node</li>\n\t * </ul>\n\t *\n\t *      function handleFileLoad(event) {\n\t *          var item = event.item; // A reference to the item that was passed in to the LoadQueue\n\t *          var type = item.type;\n\t *\n\t *          // Add any images to the page body.\n\t *          if (type == createjs.Types.IMAGE) {\n\t *              document.body.appendChild(event.result);\n\t *          }\n\t *      }\n\t *\n\t * At any time after the file has been loaded (usually after the queue has completed), any result can be looked up\n\t * via its \"id\" using {{#crossLink \"LoadQueue/getResult\"}}{{/crossLink}}. If no id was provided, then the\n\t * \"src\" or file path can be used instead, including the `path` defined by a manifest, but <strong>not including</strong>\n\t * a base path defined on the LoadQueue. It is recommended to always pass an id if you want to look up content.\n\t *\n\t *      var image = queue.getResult(\"image\");\n\t *      document.body.appendChild(image);\n\t *\n\t * Raw loaded content can be accessed using the <code>rawResult</code> property of the {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}}\n\t * event, or can be looked up using {{#crossLink \"LoadQueue/getResult\"}}{{/crossLink}}, passing `true` as the 2nd\n\t * argument. This is only applicable for content that has been parsed for the browser, specifically: JavaScript,\n\t * CSS, XML, SVG, and JSON objects, or anything loaded with XHR.\n\t *\n\t *      var image = queue.getResult(\"image\", true); // load the binary image data loaded with XHR.\n\t *\n\t * <b>Plugins</b><br />\n\t * LoadQueue has a simple plugin architecture to help process and preload content. For example, to preload audio,\n\t * make sure to install the <a href=\"http://soundjs.com\">SoundJS</a> Sound class, which will help load HTML audio,\n\t * Flash audio, and WebAudio files. This should be installed <strong>before</strong> loading any audio files.\n\t *\n\t *      queue.installPlugin(createjs.Sound);\n\t *\n\t * <h4>Known Browser Issues</h4>\n\t * <ul>\n\t *     <li>Browsers without audio support can not load audio files.</li>\n\t *     <li>Safari on Mac OS X can only play HTML audio if QuickTime is installed</li>\n\t *     <li>HTML Audio tags will only download until their <code>canPlayThrough</code> event is fired. Browsers other\n\t *     than Chrome will continue to download in the background.</li>\n\t *     <li>When loading scripts using tags, they are automatically added to the document.</li>\n\t *     <li>Scripts loaded via XHR may not be properly inspectable with browser tools.</li>\n\t *     <li>IE6 and IE7 (and some other browsers) may not be able to load XML, Text, or JSON, since they require\n\t *     XHR to work.</li>\n\t *     <li>Content loaded via tags will not show progress, and will continue to download in the background when\n\t *     canceled, although no events will be dispatched.</li>\n\t * </ul>\n\t *\n\t * @class LoadQueue\n\t * @param {Boolean} [preferXHR=true] Determines whether the preload instance will favor loading with XHR (XML HTTP\n\t * Requests), or HTML tags. When this is `false`, the queue will use tag loading when possible, and fall back on XHR\n\t * when necessary.\n\t * @param {String} [basePath=\"\"] A path that will be prepended on to the source parameter of all items in the queue\n\t * before they are loaded.  Sources beginning with a protocol such as `http://` or a relative path such as `../`\n\t * will not receive a base path.\n\t * @param {String|Boolean} [crossOrigin=\"\"] An optional flag to support images loaded from a CORS-enabled server. To\n\t * use it, set this value to `true`, which will default the crossOrigin property on images to \"Anonymous\". Any\n\t * string value will be passed through, but only \"\" and \"Anonymous\" are recommended. <strong>Note: The crossOrigin\n\t * parameter is deprecated. Use LoadItem.crossOrigin instead</strong>\n\t *\n\t * @constructor\n\t * @extends AbstractLoader\n\t */\n\tfunction LoadQueue (preferXHR, basePath, crossOrigin) {\n\t\tthis.AbstractLoader_constructor();\n\n\t\t/**\n\t\t * An array of the plugins registered using {{#crossLink \"LoadQueue/installPlugin\"}}{{/crossLink}}.\n\t\t * @property _plugins\n\t\t * @type {Array}\n\t\t * @private\n\t\t * @since 0.6.1\n\t\t */\n\t\tthis._plugins = [];\n\n\t\t/**\n\t\t * An object hash of callbacks that are fired for each file type before the file is loaded, giving plugins the\n\t\t * ability to override properties of the load. Please see the {{#crossLink \"LoadQueue/installPlugin\"}}{{/crossLink}}\n\t\t * method for more information.\n\t\t * @property _typeCallbacks\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._typeCallbacks = {};\n\n\t\t/**\n\t\t * An object hash of callbacks that are fired for each file extension before the file is loaded, giving plugins the\n\t\t * ability to override properties of the load. Please see the {{#crossLink \"LoadQueue/installPlugin\"}}{{/crossLink}}\n\t\t * method for more information.\n\t\t * @property _extensionCallbacks\n\t\t * @type {null}\n\t\t * @private\n\t\t */\n\t\tthis._extensionCallbacks = {};\n\n\t\t/**\n\t\t * The next preload queue to process when this one is complete. If an error is thrown in the current queue, and\n\t\t * {{#crossLink \"LoadQueue/stopOnError:property\"}}{{/crossLink}} is `true`, the next queue will not be processed.\n\t\t * @property next\n\t\t * @type {LoadQueue}\n\t\t * @default null\n\t\t */\n\t\tthis.next = null;\n\n\t\t/**\n\t\t * Ensure loaded scripts \"complete\" in the order they are specified. Loaded scripts are added to the document head\n\t\t * once they are loaded. Scripts loaded via tags will load one-at-a-time when this property is `true`, whereas\n\t\t * scripts loaded using XHR can load in any order, but will \"finish\" and be added to the document in the order\n\t\t * specified.\n\t\t *\n\t\t * Any items can be set to load in order by setting the {{#crossLink \"maintainOrder:property\"}}{{/crossLink}}\n\t\t * property on the load item, or by ensuring that only one connection can be open at a time using\n\t\t * {{#crossLink \"LoadQueue/setMaxConnections\"}}{{/crossLink}}. Note that when the `maintainScriptOrder` property\n\t\t * is set to `true`, scripts items are automatically set to `maintainOrder=true`, and changing the\n\t\t * `maintainScriptOrder` to `false` during a load will not change items already in a queue.\n\t\t *\n\t\t * <h4>Example</h4>\n\t\t *\n\t\t *      var queue = new createjs.LoadQueue();\n\t\t *      queue.setMaxConnections(3); // Set a higher number to load multiple items at once\n\t\t *      queue.maintainScriptOrder = true; // Ensure scripts are loaded in order\n\t\t *      queue.loadManifest([\n\t\t *          \"script1.js\",\n\t\t *          \"script2.js\",\n\t\t *          \"image.png\", // Load any time\n\t\t *          {src: \"image2.png\", maintainOrder: true} // Will wait for script2.js\n\t\t *          \"image3.png\",\n\t\t *          \"script3.js\" // Will wait for image2.png before loading (or completing when loading with XHR)\n\t\t *      ]);\n\t\t *\n\t\t * @property maintainScriptOrder\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.maintainScriptOrder = true;\n\n\t\t/**\n\t\t * Determines if the LoadQueue will stop processing the current queue when an error is encountered.\n\t\t * @property stopOnError\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.stopOnError = false;\n\n\t\t/**\n\t\t * The number of maximum open connections that a loadQueue tries to maintain. Please see\n\t\t * {{#crossLink \"LoadQueue/setMaxConnections\"}}{{/crossLink}} for more information.\n\t\t * @property _maxConnections\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t * @private\n\t\t */\n\t\tthis._maxConnections = 1;\n\n\t\t/**\n\t\t * An internal list of all the default Loaders that are included with PreloadJS. Before an item is loaded, the\n\t\t * available loader list is iterated, in the order they are included, and as soon as a loader indicates it can\n\t\t * handle the content, it will be selected. The default loader, ({{#crossLink \"TextLoader\"}}{{/crossLink}} is\n\t\t * last in the list, so it will be used if no other match is found. Typically, loaders will match based on the\n\t\t * {{#crossLink \"LoadItem/type\"}}{{/crossLink}}, which is automatically determined using the file extension of\n\t\t * the {{#crossLink \"LoadItem/src:property\"}}{{/crossLink}}.\n\t\t *\n\t\t * Loaders can be removed from PreloadJS by simply not including them.\n\t\t *\n\t\t * Custom loaders installed using {{#crossLink \"registerLoader\"}}{{/crossLink}} will be prepended to this list\n\t\t * so that they are checked first.\n\t\t * @property _availableLoaders\n\t\t * @type {Array}\n\t\t * @private\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._availableLoaders = [\n            createjs.FontLoader,\n\t\t\tcreatejs.ImageLoader,\n\t\t\tcreatejs.JavaScriptLoader,\n\t\t\tcreatejs.CSSLoader,\n\t\t\tcreatejs.JSONLoader,\n\t\t\tcreatejs.JSONPLoader,\n\t\t\tcreatejs.SoundLoader,\n\t\t\tcreatejs.ManifestLoader,\n\t\t\tcreatejs.SpriteSheetLoader,\n\t\t\tcreatejs.XMLLoader,\n\t\t\tcreatejs.SVGLoader,\n\t\t\tcreatejs.BinaryLoader,\n\t\t\tcreatejs.VideoLoader,\n\t\t\tcreatejs.TextLoader\n\t\t];\n\n\t\t/**\n\t\t * The number of built in loaders, so they can't be removed by {{#crossLink \"unregisterLoader\"}}{{/crossLink}.\n\t\t\t\t * @property _defaultLoaderLength\n\t\t * @type {Number}\n\t\t * @private\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._defaultLoaderLength = this._availableLoaders.length;\n\n\t\tthis.init(preferXHR, basePath, crossOrigin);\n\t}\n\n\tvar p = createjs.extend(LoadQueue, createjs.AbstractLoader);\n\tvar s = LoadQueue;\n\n\t// Remove these @deprecated properties after 1.0\n\ttry {\n\t\tObject.defineProperties(s, {\n\t\t\tPOST: { get: createjs.deprecate(function() { return createjs.Methods.POST; }, \"AbstractLoader.POST\") },\n\t\t\tGET: { get: createjs.deprecate(function() { return createjs.Methods.GET; }, \"AbstractLoader.GET\") },\n\n\t\t\tBINARY: { get: createjs.deprecate(function() { return createjs.Types.BINARY; }, \"AbstractLoader.BINARY\") },\n\t\t\tCSS: { get: createjs.deprecate(function() { return createjs.Types.CSS; }, \"AbstractLoader.CSS\") },\n\t\t\tFONT: { get: createjs.deprecate(function() { return createjs.Types.FONT; }, \"AbstractLoader.FONT\") },\n\t\t\tFONTCSS: { get: createjs.deprecate(function() { return createjs.Types.FONTCSS; }, \"AbstractLoader.FONTCSS\") },\n\t\t\tIMAGE: { get: createjs.deprecate(function() { return createjs.Types.IMAGE; }, \"AbstractLoader.IMAGE\") },\n\t\t\tJAVASCRIPT: { get: createjs.deprecate(function() { return createjs.Types.JAVASCRIPT; }, \"AbstractLoader.JAVASCRIPT\") },\n\t\t\tJSON: { get: createjs.deprecate(function() { return createjs.Types.JSON; }, \"AbstractLoader.JSON\") },\n\t\t\tJSONP: { get: createjs.deprecate(function() { return createjs.Types.JSONP; }, \"AbstractLoader.JSONP\") },\n\t\t\tMANIFEST: { get: createjs.deprecate(function() { return createjs.Types.MANIFEST; }, \"AbstractLoader.MANIFEST\") },\n\t\t\tSOUND: { get: createjs.deprecate(function() { return createjs.Types.SOUND; }, \"AbstractLoader.SOUND\") },\n\t\t\tVIDEO: { get: createjs.deprecate(function() { return createjs.Types.VIDEO; }, \"AbstractLoader.VIDEO\") },\n\t\t\tSPRITESHEET: { get: createjs.deprecate(function() { return createjs.Types.SPRITESHEET; }, \"AbstractLoader.SPRITESHEET\") },\n\t\t\tSVG: { get: createjs.deprecate(function() { return createjs.Types.SVG; }, \"AbstractLoader.SVG\") },\n\t\t\tTEXT: { get: createjs.deprecate(function() { return createjs.Types.TEXT; }, \"AbstractLoader.TEXT\") },\n\t\t\tXML: { get: createjs.deprecate(function() { return createjs.Types.XML; }, \"AbstractLoader.XML\") }\n\t\t});\n\t} catch (e) {}\n\n\t/**\n\t * An internal initialization method, which is used for initial set up, but also to reset the LoadQueue.\n\t * @method init\n\t * @param preferXHR\n\t * @param basePath\n\t * @param crossOrigin\n\t * @private\n\t */\n\tp.init = function (preferXHR, basePath, crossOrigin) {\n\n\t\t// public properties\n\n\t\t/**\n\t\t * Try and use XMLHttpRequest (XHR) when possible. Note that LoadQueue will default to tag loading or XHR\n\t\t * loading depending on the requirements for a media type. For example, HTML audio can not be loaded with XHR,\n\t\t * and plain text can not be loaded with tags, so it will default the the correct type instead of using the\n\t\t * user-defined type.\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis.preferXHR = true; //TODO: Get/Set\n\t\tthis._preferXHR = true;\n\t\tthis.setPreferXHR(preferXHR);\n\n\t\t// protected properties\n\t\t/**\n\t\t * Whether the queue is currently paused or not.\n\t\t * @property _paused\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis._paused = false;\n\n\t\t/**\n\t\t * A path that will be prepended on to the item's {{#crossLink \"LoadItem/src:property\"}}{{/crossLink}}. The\n\t\t * `_basePath` property will only be used if an item's source is relative, and does not include a protocol such\n\t\t * as `http://`, or a relative path such as `../`.\n\t\t * @property _basePath\n\t\t * @type {String}\n\t\t * @private\n\t\t * @since 0.3.1\n\t\t */\n\t\tthis._basePath = basePath;\n\n\t\t/**\n\t\t * An optional flag to set on images that are loaded using PreloadJS, which enables CORS support. Images loaded\n\t\t * cross-domain by servers that support CORS require the crossOrigin flag to be loaded and interacted with by\n\t\t * a canvas. When loading locally, or with a server with no CORS support, this flag can cause other security issues,\n\t\t * so it is recommended to only set it if you are sure the server supports it. Currently, supported values are \"\"\n\t\t * and \"Anonymous\".\n\t\t * @property _crossOrigin\n\t\t * @type {String}\n\t\t * @default \"\"\n\t\t * @private\n\t\t * @since 0.4.1\n\t\t */\n\t\tthis._crossOrigin = crossOrigin;\n\n\t\t/**\n\t\t * Determines if the loadStart event was dispatched already. This event is only fired one time, when the first\n\t\t * file is requested.\n\t\t * @property _loadStartWasDispatched\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @private\n\t\t */\n\t\tthis._loadStartWasDispatched = false;\n\n\t\t/**\n\t\t * Determines if there is currently a script loading. This helps ensure that only a single script loads at once when\n\t\t * using a script tag to do preloading.\n\t\t * @property _currentlyLoadingScript\n\t\t * @type {Boolean}\n\t\t * @private\n\t\t */\n\t\tthis._currentlyLoadingScript = null;\n\n\t\t/**\n\t\t * An array containing the currently downloading files.\n\t\t * @property _currentLoads\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._currentLoads = [];\n\n\t\t/**\n\t\t * An array containing the queued items that have not yet started downloading.\n\t\t * @property _loadQueue\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._loadQueue = [];\n\n\t\t/**\n\t\t * An array containing downloads that have not completed, so that the LoadQueue can be properly reset.\n\t\t * @property _loadQueueBackup\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._loadQueueBackup = [];\n\n\t\t/**\n\t\t * An object hash of items that have finished downloading, indexed by the {{#crossLink \"LoadItem\"}}{{/crossLink}}\n\t\t * id.\n\t\t * @property _loadItemsById\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._loadItemsById = {};\n\n\t\t/**\n\t\t * An object hash of items that have finished downloading, indexed by {{#crossLink \"LoadItem\"}}{{/crossLink}}\n\t\t * source.\n\t\t * @property _loadItemsBySrc\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._loadItemsBySrc = {};\n\n\t\t/**\n\t\t * An object hash of loaded items, indexed by the ID of the {{#crossLink \"LoadItem\"}}{{/crossLink}}.\n\t\t * @property _loadedResults\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._loadedResults = {};\n\n\t\t/**\n\t\t * An object hash of un-parsed loaded items, indexed by the ID of the {{#crossLink \"LoadItem\"}}{{/crossLink}}.\n\t\t * @property _loadedRawResults\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._loadedRawResults = {};\n\n\t\t/**\n\t\t * The number of items that have been requested. This helps manage an overall progress without knowing how large\n\t\t * the files are before they are downloaded. This does not include items inside of loaders such as the\n\t\t * {{#crossLink \"ManifestLoader\"}}{{/crossLink}}.\n\t\t * @property _numItems\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @private\n\t\t */\n\t\tthis._numItems = 0;\n\n\t\t/**\n\t\t * The number of items that have completed loaded. This helps manage an overall progress without knowing how large\n\t\t * the files are before they are downloaded.\n\t\t * @property _numItemsLoaded\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @private\n\t\t */\n\t\tthis._numItemsLoaded = 0;\n\n\t\t/**\n\t\t * A list of scripts in the order they were requested. This helps ensure that scripts are \"completed\" in the right\n\t\t * order.\n\t\t * @property _scriptOrder\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._scriptOrder = [];\n\n\t\t/**\n\t\t * A list of scripts that have been loaded. Items are added to this list as <code>null</code> when they are\n\t\t * requested, contain the loaded item if it has completed, but not been dispatched to the user, and <code>true</true>\n\t\t * once they are complete and have been dispatched.\n\t\t * @property _loadedScripts\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._loadedScripts = [];\n\n\t\t/**\n\t\t * The last progress amount. This is used to suppress duplicate progress events.\n\t\t * @property _lastProgress\n\t\t * @type {Number}\n\t\t * @private\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._lastProgress = NaN;\n\n\t};\n\n// static properties\n\n// events\n\t/**\n\t * This event is fired when an individual file has loaded, and been processed.\n\t * @event fileload\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Object} item The file item which was specified in the {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}}\n\t * or {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}} call. If only a string path or tag was specified, the\n\t * object will contain that value as a `src` property.\n\t * @param {Object} result The HTML tag or parsed result of the loaded item.\n\t * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted\n\t * to a usable object.\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * This {{#crossLink \"ProgressEvent\"}}{{/crossLink}} that is fired when an an individual file's progress changes.\n\t * @event fileprogress\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * This event is fired when an individual file starts to load.\n\t * @event filestart\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Object} item The file item which was specified in the {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}}\n\t * or {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}} call. If only a string path or tag was specified, the\n\t * object will contain that value as a property.\n\t */\n\n\t/**\n\t * Although it extends {{#crossLink \"AbstractLoader\"}}{{/crossLink}}, the `initialize` event is never fired from\n\t * a LoadQueue instance.\n\t * @event initialize\n\t * @private\n\t */\n\n// public methods\n\t/**\n\t * Register a custom loaders class. New loaders are given precedence over loaders added earlier and default loaders.\n\t * It is recommended that loaders extend {{#crossLink \"AbstractLoader\"}}{{/crossLink}}. Loaders can only be added\n\t * once, and will be prepended to the list of available loaders.\n\t * @method registerLoader\n\t * @param {Function|AbstractLoader} loader The AbstractLoader class to add.\n\t * @since 0.6.0\n\t */\n\tp.registerLoader = function (loader) {\n\t\tif (!loader || !loader.canLoadItem) {\n\t\t\tthrow new Error(\"loader is of an incorrect type.\");\n\t\t} else if (this._availableLoaders.indexOf(loader) != -1) {\n\t\t\tthrow new Error(\"loader already exists.\"); //LM: Maybe just silently fail here\n\t\t}\n\n\t\tthis._availableLoaders.unshift(loader);\n\t};\n\n\t/**\n\t * Remove a custom loader added using {{#crossLink \"registerLoader\"}}{{/crossLink}}. Only custom loaders can be\n\t * unregistered, the default loaders will always be available.\n\t * @method unregisterLoader\n\t * @param {Function|AbstractLoader} loader The AbstractLoader class to remove\n\t */\n\tp.unregisterLoader = function (loader) {\n\t\tvar idx = this._availableLoaders.indexOf(loader);\n\t\tif (idx != -1 && idx < this._defaultLoaderLength - 1) {\n\t\t\tthis._availableLoaders.splice(idx, 1);\n\t\t}\n\t};\n\n\t/**\n\t * Change the {{#crossLink \"preferXHR:property\"}}{{/crossLink}} value. Note that if this is set to `true`, it may\n\t * fail, or be ignored depending on the browser's capabilities and the load type.\n\t * @method setPreferXHR\n\t * @param {Boolean} value\n\t * @returns {Boolean} The value of {{#crossLink \"preferXHR\"}}{{/crossLink}} that was successfully set.\n\t * @since 0.6.0\n\t */\n\tp.setPreferXHR = function (value) {\n\t\t// Determine if we can use XHR. XHR defaults to TRUE, but the browser may not support it.\n\t\t//TODO: Should we be checking for the other XHR types? Might have to do a try/catch on the different types similar to createXHR.\n\t\tthis.preferXHR = (value != false && window.XMLHttpRequest != null);\n\t\treturn this.preferXHR;\n\t};\n\n\t/**\n\t * Stops all queued and loading items, and clears the queue. This also removes all internal references to loaded\n\t * content, and allows the queue to be used again.\n\t * @method removeAll\n\t * @since 0.3.0\n\t */\n\tp.removeAll = function () {\n\t\tthis.remove();\n\t};\n\n\t/**\n\t * Stops an item from being loaded, and removes it from the queue. If nothing is passed, all items are removed.\n\t * This also removes internal references to loaded item(s).\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      queue.loadManifest([\n\t *          {src:\"test.png\", id:\"png\"},\n\t *          {src:\"test.jpg\", id:\"jpg\"},\n\t *          {src:\"test.mp3\", id:\"mp3\"}\n\t *      ]);\n\t *      queue.remove(\"png\"); // Single item by ID\n\t *      queue.remove(\"png\", \"test.jpg\"); // Items as arguments. Mixed id and src.\n\t *      queue.remove([\"test.png\", \"jpg\"]); // Items in an Array. Mixed id and src.\n\t *\n\t * @method remove\n\t * @param {String | Array} idsOrUrls* The id or ids to remove from this queue. You can pass an item, an array of\n\t * items, or multiple items as arguments.\n\t * @since 0.3.0\n\t */\n\tp.remove = function (idsOrUrls) {\n\t\tvar args = null;\n\n\t\tif (idsOrUrls && !Array.isArray(idsOrUrls)) {\n\t\t\targs = [idsOrUrls];\n\t\t} else if (idsOrUrls) {\n\t\t\targs = idsOrUrls;\n\t\t} else if (arguments.length > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar itemsWereRemoved = false;\n\n\t\t// Destroy everything\n\t\tif (!args) {\n\t\t\tthis.close();\n\t\t\tfor (var n in this._loadItemsById) {\n\t\t\t\tthis._disposeItem(this._loadItemsById[n]);\n\t\t\t}\n\t\t\tthis.init(this.preferXHR, this._basePath);\n\n\t\t\t// Remove specific items\n\t\t} else {\n\t\t\twhile (args.length) {\n\t\t\t\tvar item = args.pop();\n\t\t\t\tvar r = this.getResult(item);\n\n\t\t\t\t//Remove from the main load Queue\n\t\t\t\tfor (i = this._loadQueue.length - 1; i >= 0; i--) {\n\t\t\t\t\tloadItem = this._loadQueue[i].getItem();\n\t\t\t\t\tif (loadItem.id == item || loadItem.src == item) {\n\t\t\t\t\t\tthis._loadQueue.splice(i, 1)[0].cancel();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//Remove from the backup queue\n\t\t\t\tfor (i = this._loadQueueBackup.length - 1; i >= 0; i--) {\n\t\t\t\t\tloadItem = this._loadQueueBackup[i].getItem();\n\t\t\t\t\tif (loadItem.id == item || loadItem.src == item) {\n\t\t\t\t\t\tthis._loadQueueBackup.splice(i, 1)[0].cancel();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (r) {\n\t\t\t\t\tthis._disposeItem(this.getItem(item));\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i = this._currentLoads.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tvar loadItem = this._currentLoads[i].getItem();\n\t\t\t\t\t\tif (loadItem.id == item || loadItem.src == item) {\n\t\t\t\t\t\t\tthis._currentLoads.splice(i, 1)[0].cancel();\n\t\t\t\t\t\t\titemsWereRemoved = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If this was called during a load, try to load the next item.\n\t\t\tif (itemsWereRemoved) {\n\t\t\t\tthis._loadNext();\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Stops all open loads, destroys any loaded items, and resets the queue, so all items can\n\t * be reloaded again by calling {{#crossLink \"AbstractLoader/load\"}}{{/crossLink}}. Items are not removed from the\n\t * queue. To remove items use the {{#crossLink \"LoadQueue/remove\"}}{{/crossLink}} or\n\t * {{#crossLink \"LoadQueue/removeAll\"}}{{/crossLink}} method.\n\t * @method reset\n\t * @since 0.3.0\n\t */\n\tp.reset = function () {\n\t\tthis.close();\n\t\tfor (var n in this._loadItemsById) {\n\t\t\tthis._disposeItem(this._loadItemsById[n]);\n\t\t}\n\n\t\t//Reset the queue to its start state\n\t\tvar a = [];\n\t\tfor (var i = 0, l = this._loadQueueBackup.length; i < l; i++) {\n\t\t\ta.push(this._loadQueueBackup[i].getItem());\n\t\t}\n\n\t\tthis.loadManifest(a, false);\n\t};\n\n\t/**\n\t * Register a plugin. Plugins can map to load types (sound, image, etc), or specific extensions (png, mp3, etc).\n\t * Currently, only one plugin can exist per type/extension.\n\t *\n\t * When a plugin is installed, a <code>getPreloadHandlers()</code> method will be called on it. For more information\n\t * on this method, check out the {{#crossLink \"SamplePlugin/getPreloadHandlers\"}}{{/crossLink}} method in the\n\t * {{#crossLink \"SamplePlugin\"}}{{/crossLink}} class.\n\t *\n\t * Before a file is loaded, a matching plugin has an opportunity to modify the load. If a `callback` is returned\n\t * from the {{#crossLink \"SamplePlugin/getPreloadHandlers\"}}{{/crossLink}} method, it will be invoked first, and its\n\t * result may cancel or modify the item. The callback method can also return a `completeHandler` to be fired when\n\t * the file is loaded, or a `tag` object, which will manage the actual download. For more information on these\n\t * methods, check out the {{#crossLink \"SamplePlugin/preloadHandler\"}}{{/crossLink}} and {{#crossLink \"SamplePlugin/fileLoadHandler\"}}{{/crossLink}}\n\t * methods on the {{#crossLink \"SamplePlugin\"}}{{/crossLink}}.\n\t *\n\t * @method installPlugin\n\t * @param {Function} plugin The plugin class to install.\n\t */\n\tp.installPlugin = function (plugin) {\n\t\tif (plugin == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (plugin.getPreloadHandlers != null) {\n\t\t\tthis._plugins.push(plugin);\n\t\t\tvar map = plugin.getPreloadHandlers();\n\t\t\tmap.scope = plugin;\n\n\t\t\tif (map.types != null) {\n\t\t\t\tfor (var i = 0, l = map.types.length; i < l; i++) {\n\t\t\t\t\tthis._typeCallbacks[map.types[i]] = map;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (map.extensions != null) {\n\t\t\t\tfor (i = 0, l = map.extensions.length; i < l; i++) {\n\t\t\t\t\tthis._extensionCallbacks[map.extensions[i]] = map;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Set the maximum number of concurrent connections. Note that browsers and servers may have a built-in maximum\n\t * number of open connections, so any additional connections may remain in a pending state until the browser\n\t * opens the connection. When loading scripts using tags, and when {{#crossLink \"LoadQueue/maintainScriptOrder:property\"}}{{/crossLink}}\n\t * is `true`, only one script is loaded at a time due to browser limitations.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var queue = new createjs.LoadQueue();\n\t *      queue.setMaxConnections(10); // Allow 10 concurrent loads\n\t *\n\t * @method setMaxConnections\n\t * @param {Number} value The number of concurrent loads to allow. By default, only a single connection per LoadQueue\n\t * is open at any time.\n\t */\n\tp.setMaxConnections = function (value) {\n\t\tthis._maxConnections = value;\n\t\tif (!this._paused && this._loadQueue.length > 0) {\n\t\t\tthis._loadNext();\n\t\t}\n\t};\n\n\t/**\n\t * Load a single file. To add multiple files at once, use the {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}\n\t * method.\n\t *\n\t * Files are always appended to the current queue, so this method can be used multiple times to add files.\n\t * To clear the queue first, use the {{#crossLink \"AbstractLoader/close\"}}{{/crossLink}} method.\n\t * @method loadFile\n\t * @param {LoadItem|Object|String} file The file object or path to load. A file can be either\n\t * <ul>\n\t *     <li>A {{#crossLink \"LoadItem\"}}{{/crossLink}} instance</li>\n\t *     <li>An object containing properties defined by {{#crossLink \"LoadItem\"}}{{/crossLink}}</li>\n\t *     <li>OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink \"LoadItem\"}}{{/crossLink}}\n\t *     in the background.</li>\n\t * </ul>\n\t * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default\n\t * value is true. If the queue is paused using {{#crossLink \"LoadQueue/setPaused\"}}{{/crossLink}}, and the value is\n\t * `true`, the queue will resume automatically.\n\t * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the\n\t * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink \"Types/MANIFEST:property\"}}{{/crossLink}},\n\t * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>\n\t * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue\n\t * constructor, or a `path` property in a manifest definition.\n\t */\n\tp.loadFile = function (file, loadNow, basePath) {\n\t\tif (file == null) {\n\t\t\tvar event = new createjs.ErrorEvent(\"PRELOAD_NO_FILE\");\n\t\t\tthis._sendError(event);\n\t\t\treturn;\n\t\t}\n\t\tthis._addItem(file, null, basePath);\n\n\t\tif (loadNow !== false) {\n\t\t\tthis.setPaused(false);\n\t\t} else {\n\t\t\tthis.setPaused(true);\n\t\t}\n\t};\n\n\t/**\n\t * Load an array of files. To load a single file, use the {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}} method.\n\t * The files in the manifest are requested in the same order, but may complete in a different order if the max\n\t * connections are set above 1 using {{#crossLink \"LoadQueue/setMaxConnections\"}}{{/crossLink}}. Scripts will load\n\t * in the right order as long as {{#crossLink \"LoadQueue/maintainScriptOrder\"}}{{/crossLink}} is true (which is\n\t * default).\n\t *\n\t * Files are always appended to the current queue, so this method can be used multiple times to add files.\n\t * To clear the queue first, use the {{#crossLink \"AbstractLoader/close\"}}{{/crossLink}} method.\n\t * @method loadManifest\n\t * @param {Array|String|Object} manifest An list of files to load. The loadManifest call supports four types of\n\t * manifests:\n\t * <ol>\n\t *     <li>A string path, which points to a manifest file, which is a JSON file that contains a \"manifest\" property,\n\t *     which defines the list of files to load, and can optionally contain a \"path\" property, which will be\n\t *     prepended to each file in the list.</li>\n\t *     <li>An object which defines a \"src\", which is a JSON or JSONP file. A \"callback\" can be defined for JSONP\n\t *     file. The JSON/JSONP file should contain a \"manifest\" property, which defines the list of files to load,\n\t *     and can optionally contain a \"path\" property, which will be prepended to each file in the list.</li>\n\t *     <li>An object which contains a \"manifest\" property, which defines the list of files to load, and can\n\t *     optionally contain a \"path\" property, which will be prepended to each file in the list.</li>\n\t *     <li>An Array of files to load.</li>\n\t * </ol>\n\t *\n\t * Each \"file\" in a manifest can be either:\n\t * <ul>\n\t *     <li>A {{#crossLink \"LoadItem\"}}{{/crossLink}} instance</li>\n\t *     <li>An object containing properties defined by {{#crossLink \"LoadItem\"}}{{/crossLink}}</li>\n\t *     <li>OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink \"LoadItem\"}}{{/crossLink}}\n\t *     in the background.</li>\n\t * </ul>\n\t *\n\t * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default\n\t * value is true. If the queue is paused using {{#crossLink \"LoadQueue/setPaused\"}}{{/crossLink}} and this value is\n\t * `true`, the queue will resume automatically.\n\t * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the\n\t * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink \"LoadQueue/MANIFEST:property\"}}{{/crossLink}},\n\t * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>\n\t * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue\n\t * constructor, or a `path` property in a manifest definition.\n\t */\n\tp.loadManifest = function (manifest, loadNow, basePath) {\n\t\tvar fileList = null;\n\t\tvar path = null;\n\n\t\t// Array-based list of items\n\t\tif (Array.isArray(manifest)) {\n\t\t\tif (manifest.length == 0) {\n\t\t\t\tvar event = new createjs.ErrorEvent(\"PRELOAD_MANIFEST_EMPTY\");\n\t\t\t\tthis._sendError(event);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfileList = manifest;\n\n\t\t\t// String-based. Only file manifests can be specified this way. Any other types will cause an error when loaded.\n\t\t} else if (typeof(manifest) === \"string\") {\n\t\t\tfileList = [\n\t\t\t\t{\n\t\t\t\t\tsrc: manifest,\n\t\t\t\t\ttype: s.MANIFEST\n\t\t\t\t}\n\t\t\t];\n\n\t\t} else if (typeof(manifest) == \"object\") {\n\n\t\t\t// An object that defines a manifest path\n\t\t\tif (manifest.src !== undefined) {\n\t\t\t\tif (manifest.type == null) {\n\t\t\t\t\tmanifest.type = s.MANIFEST;\n\t\t\t\t} else if (manifest.type != s.MANIFEST) {\n\t\t\t\t\tvar event = new createjs.ErrorEvent(\"PRELOAD_MANIFEST_TYPE\");\n\t\t\t\t\tthis._sendError(event);\n\t\t\t\t}\n\t\t\t\tfileList = [manifest];\n\n\t\t\t\t// An object that defines a manifest\n\t\t\t} else if (manifest.manifest !== undefined) {\n\t\t\t\tfileList = manifest.manifest;\n\t\t\t\tpath = manifest.path;\n\t\t\t}\n\n\t\t\t// Unsupported. This will throw an error.\n\t\t} else {\n\t\t\tvar event = new createjs.ErrorEvent(\"PRELOAD_MANIFEST_NULL\");\n\t\t\tthis._sendError(event);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var i = 0, l = fileList.length; i < l; i++) {\n\t\t\tthis._addItem(fileList[i], path, basePath);\n\t\t}\n\n\t\tif (loadNow !== false) {\n\t\t\tthis.setPaused(false);\n\t\t} else {\n\t\t\tthis.setPaused(true);\n\t\t}\n\n\t};\n\n\t/**\n\t * Start a LoadQueue that was created, but not automatically started.\n\t * @method load\n\t */\n\tp.load = function () {\n\t\tthis.setPaused(false);\n\t};\n\n\t/**\n\t * Look up a {{#crossLink \"LoadItem\"}}{{/crossLink}} using either the \"id\" or \"src\" that was specified when loading it. Note that if no \"id\" was\n\t * supplied with the load item, the ID will be the \"src\", including a `path` property defined by a manifest. The\n\t * `basePath` will not be part of the ID.\n\t * @method getItem\n\t * @param {String} value The <code>id</code> or <code>src</code> of the load item.\n\t * @return {Object} The load item that was initially requested using {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}}\n\t * or {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}. This object is also returned via the {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}}\n\t * event as the `item` parameter.\n\t */\n\tp.getItem = function (value) {\n\t\treturn this._loadItemsById[value] || this._loadItemsBySrc[value];\n\t};\n\n\t/**\n\t * Look up a loaded result using either the \"id\" or \"src\" that was specified when loading it. Note that if no \"id\"\n\t * was supplied with the load item, the ID will be the \"src\", including a `path` property defined by a manifest. The\n\t * `basePath` will not be part of the ID.\n\t * @method getResult\n\t * @param {String} value The <code>id</code> or <code>src</code> of the load item.\n\t * @param {Boolean} [rawResult=false] Return a raw result instead of a formatted result. This applies to content\n\t * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be\n\t * returned instead.\n\t * @return {Object} A result object containing the content that was loaded, such as:\n\t * <ul>\n\t *      <li>An image tag (&lt;image /&gt;) for images</li>\n\t *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts are automatically added to the HTML\n\t *      DOM.</li>\n\t *      <li>A style tag for CSS (&lt;style /&gt; or &lt;link &gt;)</li>\n\t *      <li>Raw text for TEXT</li>\n\t *      <li>A formatted JavaScript object defined by JSON</li>\n\t *      <li>An XML document</li>\n\t *      <li>A binary arraybuffer loaded by XHR</li>\n\t *      <li>An audio tag (&lt;audio &gt;) for HTML audio. Note that it is recommended to use SoundJS APIs to play\n\t *      loaded audio. Specifically, audio loaded by Flash and WebAudio will return a loader object using this method\n\t *      which can not be used to play audio back.</li>\n\t * </ul>\n\t * This object is also returned via the {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}} event as the 'item`\n\t * parameter. Note that if a raw result is requested, but not found, the result will be returned instead.\n\t */\n\tp.getResult = function (value, rawResult) {\n\t\tvar item = this._loadItemsById[value] || this._loadItemsBySrc[value];\n\t\tif (item == null) {\n\t\t\treturn null;\n\t\t}\n\t\tvar id = item.id;\n\t\tif (rawResult && this._loadedRawResults[id]) {\n\t\t\treturn this._loadedRawResults[id];\n\t\t}\n\t\treturn this._loadedResults[id];\n\t};\n\n\t/**\n\t * Generate an list of items loaded by this queue.\n\t * @method getItems\n\t * @param {Boolean} loaded Determines if only items that have been loaded should be returned. If false, in-progress\n\t * and failed load items will also be included.\n\t * @returns {Array} A list of objects that have been loaded. Each item includes the {{#crossLink \"LoadItem\"}}{{/crossLink}},\n\t * result, and rawResult.\n\t * @since 0.6.0\n\t */\n\tp.getItems = function (loaded) {\n\t\tvar arr = [];\n\t\tfor (var n in this._loadItemsById) {\n\t\t\tvar item = this._loadItemsById[n];\n\t\t\tvar result = this.getResult(n);\n\t\t\tif (loaded === true && result == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tarr.push({\n\t\t\t\titem: item,\n\t\t\t\tresult: result,\n\t\t\t\trawResult: this.getResult(n, true)\n\t\t\t});\n\t\t}\n\t\treturn arr;\n\t};\n\n\t/**\n\t * Pause or resume the current load. Active loads will not be cancelled, but the next items in the queue will not\n\t * be processed when active loads complete. LoadQueues are not paused by default.\n\t *\n\t * Note that if new items are added to the queue using {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}} or\n\t * {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}, a paused queue will be resumed, unless the `loadNow`\n\t * argument is `false`.\n\t * @method setPaused\n\t * @param {Boolean} value Whether the queue should be paused or not.\n\t */\n\tp.setPaused = function (value) {\n\t\tthis._paused = value;\n\t\tif (!this._paused) {\n\t\t\tthis._loadNext();\n\t\t}\n\t};\n\n\t/**\n\t * Close the active queue. Closing a queue completely empties the queue, and prevents any remaining items from\n\t * starting to download. Note that currently any active loads will remain open, and events may be processed.\n\t *\n\t * To stop and restart a queue, use the {{#crossLink \"LoadQueue/setPaused\"}}{{/crossLink}} method instead.\n\t * @method close\n\t */\n\tp.close = function () {\n\t\twhile (this._currentLoads.length) {\n\t\t\tthis._currentLoads.pop().cancel();\n\t\t}\n\t\tthis._scriptOrder.length = 0;\n\t\tthis._loadedScripts.length = 0;\n\t\tthis.loadStartWasDispatched = false;\n\t\tthis._itemCount = 0;\n\t\tthis._lastProgress = NaN;\n\t};\n\n// protected methods\n\t/**\n\t * Add an item to the queue. Items are formatted into a usable object containing all the properties necessary to\n\t * load the content. The load queue is populated with the loader instance that handles preloading, and not the load\n\t * item that was passed in by the user. To look up the load item by id or src, use the {{#crossLink \"LoadQueue.getItem\"}}{{/crossLink}}\n\t * method.\n\t * @method _addItem\n\t * @param {String|Object} value The item to add to the queue.\n\t * @param {String} [path] An optional path prepended to the `src`. The path will only be prepended if the src is\n\t * relative, and does not start with a protocol such as `http://`, or a path like `../`. If the LoadQueue was\n\t * provided a {{#crossLink \"_basePath\"}}{{/crossLink}}, then it will optionally be prepended after.\n\t * @param {String} [basePath] <strong>Deprecated</strong>An optional basePath passed into a {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}\n\t * or {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}} call. This parameter will be removed in a future tagged\n\t * version.\n\t * @private\n\t */\n\tp._addItem = function (value, path, basePath) {\n\t\tvar item = this._createLoadItem(value, path, basePath); // basePath and manifest path are added to the src.\n\t\tif (item == null) {\n\t\t\treturn;\n\t\t} // Sometimes plugins or types should be skipped.\n\t\tvar loader = this._createLoader(item);\n\t\tif (loader != null) {\n\t\t\tif (\"plugins\" in loader) {\n\t\t\t\tloader.plugins = this._plugins;\n\t\t\t}\n\t\t\titem._loader = loader;\n\t\t\tthis._loadQueue.push(loader);\n\t\t\tthis._loadQueueBackup.push(loader);\n\n\t\t\tthis._numItems++;\n\t\t\tthis._updateProgress();\n\n\t\t\t// Only worry about script order when using XHR to load scripts. Tags are only loading one at a time.\n\t\t\tif ((this.maintainScriptOrder\n\t\t\t\t\t&& item.type == createjs.Types.JAVASCRIPT\n\t\t\t\t\t\t//&& loader instanceof createjs.XHRLoader //NOTE: Have to track all JS files this way\n\t\t\t\t\t)\n\t\t\t\t\t|| item.maintainOrder === true) {\n\t\t\t\tthis._scriptOrder.push(item);\n\t\t\t\tthis._loadedScripts.push(null);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Create a refined {{#crossLink \"LoadItem\"}}{{/crossLink}}, which contains all the required properties. The type of\n\t * item is determined by browser support, requirements based on the file type, and developer settings. For example,\n\t * XHR is only used for file types that support it in new browsers.\n\t *\n\t * Before the item is returned, any plugins registered to handle the type or extension will be fired, which may\n\t * alter the load item.\n\t * @method _createLoadItem\n\t * @param {String | Object | HTMLAudioElement | HTMLImageElement} value The item that needs to be preloaded.\n\t * @param {String} [path] A path to prepend to the item's source. Sources beginning with http:// or similar will\n\t * not receive a path. Since PreloadJS 0.4.1, the src will be modified to include the `path` and {{#crossLink \"LoadQueue/_basePath:property\"}}{{/crossLink}}\n\t * when it is added.\n\t * @param {String} [basePath] <strong>Deprectated</strong> A base path to prepend to the items source in addition to\n\t * the path argument.\n\t * @return {Object} The loader instance that will be used.\n\t * @private\n\t */\n\tp._createLoadItem = function (value, path, basePath) {\n\t\tvar item = createjs.LoadItem.create(value);\n\t\tif (item == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar bp = \"\"; // Store the generated basePath\n\t\tvar useBasePath = basePath || this._basePath;\n\n\t\tif (item.src instanceof Object) {\n\t\t\tif (!item.type) {\n\t\t\t\treturn null;\n\t\t\t} // the the src is an object, type is required to pass off to plugin\n\t\t\tif (path) {\n\t\t\t\tbp = path;\n\t\t\t\tvar pathMatch = createjs.URLUtils.parseURI(path);\n\t\t\t\t// Also append basePath\n\t\t\t\tif (useBasePath != null && !pathMatch.absolute && !pathMatch.relative) {\n\t\t\t\t\tbp = useBasePath + bp;\n\t\t\t\t}\n\t\t\t} else if (useBasePath != null) {\n\t\t\t\tbp = useBasePath;\n\t\t\t}\n\t\t} else {\n\t\t\t// Determine Extension, etc.\n\t\t\tvar match = createjs.URLUtils.parseURI(item.src);\n\t\t\tif (match.extension) {\n\t\t\t\titem.ext = match.extension;\n\t\t\t}\n\t\t\tif (item.type == null) {\n\t\t\t\titem.type = createjs.RequestUtils.getTypeByExtension(item.ext);\n\t\t\t}\n\n\t\t\t// Inject path & basePath\n\t\t\tvar autoId = item.src;\n\t\t\tif (!match.absolute && !match.relative) {\n\t\t\t\tif (path) {\n\t\t\t\t\tbp = path;\n\t\t\t\t\tvar pathMatch = createjs.URLUtils.parseURI(path);\n\t\t\t\t\tautoId = path + autoId;\n\t\t\t\t\t// Also append basePath\n\t\t\t\t\tif (useBasePath != null && !pathMatch.absolute && !pathMatch.relative) {\n\t\t\t\t\t\tbp = useBasePath + bp;\n\t\t\t\t\t}\n\t\t\t\t} else if (useBasePath != null) {\n\t\t\t\t\tbp = useBasePath;\n\t\t\t\t}\n\t\t\t}\n\t\t\titem.src = bp + item.src;\n\t\t}\n\t\titem.path = bp;\n\n\t\t// If there's no id, set one now.\n\t\tif (item.id === undefined || item.id === null || item.id === \"\") {\n\t\t\titem.id = autoId;\n\t\t}\n\n\t\t// Give plugins a chance to modify the loadItem:\n\t\tvar customHandler = this._typeCallbacks[item.type] || this._extensionCallbacks[item.ext];\n\t\tif (customHandler) {\n\t\t\t// Plugins are now passed both the full source, as well as a combined path+basePath (appropriately)\n\t\t\tvar result = customHandler.callback.call(customHandler.scope, item, this);\n\n\t\t\t// The plugin will handle the load, or has canceled it. Ignore it.\n\t\t\tif (result === false) {\n\t\t\t\treturn null;\n\n\t\t\t\t// Load as normal:\n\t\t\t} else if (result === true) {\n\t\t\t\t// Do Nothing\n\n\t\t\t\t// Result is a loader class:\n\t\t\t} else if (result != null) {\n\t\t\t\titem._loader = result;\n\t\t\t}\n\n\t\t\t// Update the extension in case the type changed:\n\t\t\tmatch = createjs.URLUtils.parseURI(item.src);\n\t\t\tif (match.extension != null) {\n\t\t\t\titem.ext = match.extension;\n\t\t\t}\n\t\t}\n\n\t\t// Store the item for lookup. This also helps clean-up later.\n\t\tthis._loadItemsById[item.id] = item;\n\t\tthis._loadItemsBySrc[item.src] = item;\n\n\t\tif (item.crossOrigin == null) {\n\t\t\titem.crossOrigin = this._crossOrigin;\n\t\t}\n\n\t\treturn item;\n\t};\n\n\t/**\n\t * Create a loader for a load item.\n\t * @method _createLoader\n\t * @param {Object} item A formatted load item that can be used to generate a loader.\n\t * @return {AbstractLoader} A loader that can be used to load content.\n\t * @private\n\t */\n\tp._createLoader = function (item) {\n\t\tif (item._loader != null) { // A plugin already specified a loader\n\t\t\treturn item._loader;\n\t\t}\n\n\t\t// Initially, try and use the provided/supported XHR mode:\n\t\tvar preferXHR = this.preferXHR;\n\n\t\tfor (var i = 0; i < this._availableLoaders.length; i++) {\n\t\t\tvar loader = this._availableLoaders[i];\n\t\t\tif (loader && loader.canLoadItem(item)) {\n\t\t\t\treturn new loader(item, preferXHR);\n\t\t\t}\n\t\t}\n\n\t\t// TODO: Log error (requires createjs.log)\n\t\treturn null;\n\t};\n\n\t/**\n\t * Load the next item in the queue. If the queue is empty (all items have been loaded), then the complete event\n\t * is processed. The queue will \"fill up\" any empty slots, up to the max connection specified using\n\t * {{#crossLink \"LoadQueue.setMaxConnections\"}}{{/crossLink}} method. The only exception is scripts that are loaded\n\t * using tags, which have to be loaded one at a time to maintain load order.\n\t * @method _loadNext\n\t * @private\n\t */\n\tp._loadNext = function () {\n\t\tif (this._paused) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Only dispatch loadstart event when the first file is loaded.\n\t\tif (!this._loadStartWasDispatched) {\n\t\t\tthis._sendLoadStart();\n\t\t\tthis._loadStartWasDispatched = true;\n\t\t}\n\n\t\t// The queue has completed.\n\t\tif (this._numItems == this._numItemsLoaded) {\n\t\t\tthis.loaded = true;\n\t\t\tthis._sendComplete();\n\n\t\t\t// Load the next queue, if it has been defined.\n\t\t\tif (this.next && this.next.load) {\n\t\t\t\tthis.next.load();\n\t\t\t}\n\t\t} else {\n\t\t\tthis.loaded = false;\n\t\t}\n\n\t\t// Must iterate forwards to load in the right order.\n\t\tfor (var i = 0; i < this._loadQueue.length; i++) {\n\t\t\tif (this._currentLoads.length >= this._maxConnections) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar loader = this._loadQueue[i];\n\n\t\t\t// Determine if we should be only loading one tag-script at a time:\n\t\t\t// Note: maintainOrder items don't do anything here because we can hold onto their loaded value\n\t\t\tif (!this._canStartLoad(loader)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._loadQueue.splice(i, 1);\n\t\t\ti--;\n\t\t\tthis._loadItem(loader);\n\t\t}\n\t};\n\n\t/**\n\t * Begin loading an item. Event listeners are not added to the loaders until the load starts.\n\t * @method _loadItem\n\t * @param {AbstractLoader} loader The loader instance to start. Currently, this will be an XHRLoader or TagLoader.\n\t * @private\n\t */\n\tp._loadItem = function (loader) {\n\t\tloader.on(\"fileload\", this._handleFileLoad, this);\n\t\tloader.on(\"progress\", this._handleProgress, this);\n\t\tloader.on(\"complete\", this._handleFileComplete, this);\n\t\tloader.on(\"error\", this._handleError, this);\n\t\tloader.on(\"fileerror\", this._handleFileError, this);\n\t\tthis._currentLoads.push(loader);\n\t\tthis._sendFileStart(loader.getItem());\n\t\tloader.load();\n\t};\n\n\t/**\n\t * The callback that is fired when a loader loads a file. This enables loaders like {{#crossLink \"ManifestLoader\"}}{{/crossLink}}\n\t * to maintain internal queues, but for this queue to dispatch the {{#crossLink \"fileload:event\"}}{{/crossLink}}\n\t * events.\n\t * @param {Event} event The {{#crossLink \"AbstractLoader/fileload:event\"}}{{/crossLink}} event from the loader.\n\t * @private\n\t * @since 0.6.0\n\t */\n\tp._handleFileLoad = function (event) {\n\t\tevent.target = null;\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * The callback that is fired when a loader encounters an error from an internal file load operation. This enables\n\t * loaders like M\n\t * @param event\n\t * @private\n\t */\n\tp._handleFileError = function (event) {\n\t\tvar newEvent = new createjs.ErrorEvent(\"FILE_LOAD_ERROR\", null, event.item);\n\t\tthis._sendError(newEvent);\n\t};\n\n\t/**\n\t * The callback that is fired when a loader encounters an error. The queue will continue loading unless {{#crossLink \"LoadQueue/stopOnError:property\"}}{{/crossLink}}\n\t * is set to `true`.\n\t * @method _handleError\n\t * @param {ErrorEvent} event The error event, containing relevant error information.\n\t * @private\n\t */\n\tp._handleError = function (event) {\n\t\tvar loader = event.target;\n\t\tthis._numItemsLoaded++;\n\n\t\tthis._finishOrderedItem(loader, true);\n\t\tthis._updateProgress();\n\n\t\tvar newEvent = new createjs.ErrorEvent(\"FILE_LOAD_ERROR\", null, loader.getItem());\n\t\t// TODO: Propagate actual error message.\n\n\t\tthis._sendError(newEvent);\n\n\t\tif (!this.stopOnError) {\n\t\t\tthis._removeLoadItem(loader);\n\t\t\tthis._cleanLoadItem(loader);\n\t\t\tthis._loadNext();\n\t\t} else {\n\t\t\tthis.setPaused(true);\n\t\t}\n\t};\n\n\t/**\n\t * An item has finished loading. We can assume that it is totally loaded, has been parsed for immediate use, and\n\t * is available as the \"result\" property on the load item. The raw text result for a parsed item (such as JSON, XML,\n\t * CSS, JavaScript, etc) is available as the \"rawResult\" property, and can also be looked up using {{#crossLink \"LoadQueue/getResult\"}}{{/crossLink}}.\n\t * @method _handleFileComplete\n\t * @param {Event} event The event object from the loader.\n\t * @private\n\t */\n\tp._handleFileComplete = function (event) {\n\t\tvar loader = event.target;\n\t\tvar item = loader.getItem();\n\n\t\tvar result = loader.getResult();\n\t\tthis._loadedResults[item.id] = result;\n\t\tvar rawResult = loader.getResult(true);\n\t\tif (rawResult != null && rawResult !== result) {\n\t\t\tthis._loadedRawResults[item.id] = rawResult;\n\t\t}\n\n\t\tthis._saveLoadedItems(loader);\n\n\t\t// Remove the load item\n\t\tthis._removeLoadItem(loader);\n\n\t\tif (!this._finishOrderedItem(loader)) {\n\t\t\t// The item was NOT managed, so process it now\n\t\t\tthis._processFinishedLoad(item, loader);\n\t\t}\n\n\t\t// Clean up the load item\n\t\tthis._cleanLoadItem(loader);\n\t};\n\n\t/**\n\t * Some loaders might load additional content, other than the item they were passed (such as {{#crossLink \"ManifestLoader\"}}{{/crossLink}}).\n\t * Any items exposed by the loader using {{#crossLink \"AbstractLoader/getLoadItems\"}}{{/crossLink}} are added to the\n\t * LoadQueue's look-ups, including {{#crossLink \"getItem\"}}{{/crossLink}} and {{#crossLink \"getResult\"}}{{/crossLink}}\n\t * methods.\n\t * @method _saveLoadedItems\n\t * @param {AbstractLoader} loader\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._saveLoadedItems = function (loader) {\n\t\t// TODO: Not sure how to handle this. Would be nice to expose the items.\n\t\t// Loaders may load sub-items. This adds them to this queue\n\t\tvar list = loader.getLoadedItems();\n\t\tif (list === null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tvar item = list[i].item;\n\n\t\t\t// Store item lookups\n\t\t\tthis._loadItemsBySrc[item.src] = item;\n\t\t\tthis._loadItemsById[item.id] = item;\n\n\t\t\t// Store loaded content\n\t\t\tthis._loadedResults[item.id] = list[i].result;\n\t\t\tthis._loadedRawResults[item.id] = list[i].rawResult;\n\t\t}\n\t};\n\n\t/**\n\t * Flag an item as finished. If the item's order is being managed, then ensure that it is allowed to finish, and if\n\t * so, trigger prior items to trigger as well.\n\t * @method _finishOrderedItem\n\t * @param {AbstractLoader} loader\n\t * @param {Boolean} loadFailed\n\t * @return {Boolean} If the item's order is being managed. This allows the caller to take an alternate\n\t * behaviour if it is.\n\t * @private\n\t */\n\tp._finishOrderedItem = function (loader, loadFailed) {\n\t\tvar item = loader.getItem();\n\n\t\tif ((this.maintainScriptOrder && item.type == createjs.Types.JAVASCRIPT)\n\t\t\t\t|| item.maintainOrder) {\n\n\t\t\t//TODO: Evaluate removal of the _currentlyLoadingScript\n\t\t\tif (loader instanceof createjs.JavaScriptLoader) {\n\t\t\t\tthis._currentlyLoadingScript = false;\n\t\t\t}\n\n\t\t\tvar index = createjs.indexOf(this._scriptOrder, item);\n\t\t\tif (index == -1) {\n\t\t\t\treturn false;\n\t\t\t} // This loader no longer exists\n\t\t\tthis._loadedScripts[index] = (loadFailed === true) ? true : item;\n\n\t\t\tthis._checkScriptLoadOrder();\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t};\n\n\t/**\n\t * Ensure the scripts load and dispatch in the correct order. When using XHR, scripts are stored in an array in the\n\t * order they were added, but with a \"null\" value. When they are completed, the value is set to the load item,\n\t * and then when they are processed and dispatched, the value is set to `true`. This method simply\n\t * iterates the array, and ensures that any loaded items that are not preceded by a `null` value are\n\t * dispatched.\n\t * @method _checkScriptLoadOrder\n\t * @private\n\t */\n\tp._checkScriptLoadOrder = function () {\n\t\tvar l = this._loadedScripts.length;\n\n\t\tfor (var i = 0; i < l; i++) {\n\t\t\tvar item = this._loadedScripts[i];\n\t\t\tif (item === null) {\n\t\t\t\tbreak;\n\t\t\t} // This is still loading. Do not process further.\n\t\t\tif (item === true) {\n\t\t\t\tcontinue;\n\t\t\t} // This has completed, and been processed. Move on.\n\n\t\t\tvar loadItem = this._loadedResults[item.id];\n\t\t\tif (item.type == createjs.Types.JAVASCRIPT) {\n\t\t\t\t// Append script tags to the head automatically.\n\t\t\t\tcreatejs.DomUtils.appendToHead(loadItem);\n\t\t\t}\n\n\t\t\tvar loader = item._loader;\n\t\t\tthis._processFinishedLoad(item, loader);\n\t\t\tthis._loadedScripts[i] = true;\n\t\t}\n\t};\n\n\t/**\n\t * A file has completed loading, and the LoadQueue can move on. This triggers the complete event, and kick-starts\n\t * the next item.\n\t * @method _processFinishedLoad\n\t * @param {LoadItem|Object} item\n\t * @param {AbstractLoader} loader\n\t * @protected\n\t */\n\tp._processFinishedLoad = function (item, loader) {\n\t\tthis._numItemsLoaded++;\n\n\t\t// Since LoadQueue needs maintain order, we can't append scripts in the loader.\n\t\t// So we do it here instead. Or in _checkScriptLoadOrder();\n\t\tif (!this.maintainScriptOrder && item.type == createjs.Types.JAVASCRIPT) {\n\t\t\tvar tag = loader.getTag();\n\t\t\tcreatejs.DomUtils.appendToHead(tag);\n\t\t}\n\n\t\tthis._updateProgress();\n\t\tthis._sendFileComplete(item, loader);\n\t\tthis._loadNext();\n\t};\n\n\t/**\n\t * Ensure items with `maintainOrder=true` that are before the specified item have loaded. This only applies to\n\t * JavaScript items that are being loaded with a TagLoader, since they have to be loaded and completed <strong>before</strong>\n\t * the script can even be started, since it exist in the DOM while loading.\n\t * @method _canStartLoad\n\t * @param {AbstractLoader} loader The loader for the item\n\t * @return {Boolean} Whether the item can start a load or not.\n\t * @private\n\t */\n\tp._canStartLoad = function (loader) {\n\t\tif (!this.maintainScriptOrder || loader.preferXHR) {\n\t\t\treturn true;\n\t\t}\n\t\tvar item = loader.getItem();\n\t\tif (item.type != createjs.Types.JAVASCRIPT) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this._currentlyLoadingScript) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar index = this._scriptOrder.indexOf(item);\n\t\tvar i = 0;\n\t\twhile (i < index) {\n\t\t\tvar checkItem = this._loadedScripts[i];\n\t\t\tif (checkItem == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tthis._currentlyLoadingScript = true;\n\t\treturn true;\n\t};\n\n\t/**\n\t * A load item is completed or was canceled, and needs to be removed from the LoadQueue.\n\t * @method _removeLoadItem\n\t * @param {AbstractLoader} loader A loader instance to remove.\n\t * @private\n\t */\n\tp._removeLoadItem = function (loader) {\n\t\tvar l = this._currentLoads.length;\n\t\tfor (var i = 0; i < l; i++) {\n\t\t\tif (this._currentLoads[i] == loader) {\n\t\t\t\tthis._currentLoads.splice(i, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Remove unneeded references from a loader.\n\t *\n\t * @param loader\n\t * @private\n\t */\n\tp._cleanLoadItem = function(loader) {\n\t\tvar item = loader.getItem();\n\t\tif (item) {\n\t\t\tdelete item._loader;\n\t\t}\n\t}\n\n\t/**\n\t * An item has dispatched progress. Propagate that progress, and update the LoadQueue's overall progress.\n\t * @method _handleProgress\n\t * @param {ProgressEvent} event The progress event from the item.\n\t * @private\n\t */\n\tp._handleProgress = function (event) {\n\t\tvar loader = event.target;\n\t\tthis._sendFileProgress(loader.getItem(), loader.progress);\n\t\tthis._updateProgress();\n\t};\n\n\t/**\n\t * Overall progress has changed, so determine the new progress amount and dispatch it. This changes any time an\n\t * item dispatches progress or completes. Note that since we don't always know the actual filesize of items before\n\t * they are loaded. In this case, we define a \"slot\" for each item (1 item in 10 would get 10%), and then append\n\t * loaded progress on top of the already-loaded items.\n\t *\n\t * For example, if 5/10 items have loaded, and item 6 is 20% loaded, the total progress would be:\n\t * <ul>\n\t *      <li>5/10 of the items in the queue (50%)</li>\n\t *      <li>plus 20% of item 6's slot (2%)</li>\n\t *      <li>equals 52%</li>\n\t * </ul>\n\t * @method _updateProgress\n\t * @private\n\t */\n\tp._updateProgress = function () {\n\t\tvar loaded = this._numItemsLoaded / this._numItems; // Fully Loaded Progress\n\t\tvar remaining = this._numItems - this._numItemsLoaded;\n\t\tif (remaining > 0) {\n\t\t\tvar chunk = 0;\n\t\t\tfor (var i = 0, l = this._currentLoads.length; i < l; i++) {\n\t\t\t\tchunk += this._currentLoads[i].progress;\n\t\t\t}\n\t\t\tloaded += (chunk / remaining) * (remaining / this._numItems);\n\t\t}\n\n\t\tif (this._lastProgress != loaded) {\n\t\t\tthis._sendProgress(loaded);\n\t\t\tthis._lastProgress = loaded;\n\t\t}\n\t};\n\n\t/**\n\t * Clean out item results, to free them from memory. Mainly, the loaded item and results are cleared from internal\n\t * hashes.\n\t * @method _disposeItem\n\t * @param {LoadItem|Object} item The item that was passed in for preloading.\n\t * @private\n\t */\n\tp._disposeItem = function (item) {\n\t\tdelete this._loadedResults[item.id];\n\t\tdelete this._loadedRawResults[item.id];\n\t\tdelete this._loadItemsById[item.id];\n\t\tdelete this._loadItemsBySrc[item.src];\n\t};\n\n\t/**\n\t * Dispatch a \"fileprogress\" {{#crossLink \"Event\"}}{{/crossLink}}. Please see the LoadQueue {{#crossLink \"LoadQueue/fileprogress:event\"}}{{/crossLink}}\n\t * event for details on the event payload.\n\t * @method _sendFileProgress\n\t * @param {LoadItem|Object} item The item that is being loaded.\n\t * @param {Number} progress The amount the item has been loaded (between 0 and 1).\n\t * @protected\n\t */\n\tp._sendFileProgress = function (item, progress) {\n\t\tif (this._isCanceled() || this._paused) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this.hasEventListener(\"fileprogress\")) {\n\t\t\treturn;\n\t\t}\n\n\t\t//LM: Rework ProgressEvent to support this?\n\t\tvar event = new createjs.Event(\"fileprogress\");\n\t\tevent.progress = progress;\n\t\tevent.loaded = progress;\n\t\tevent.total = 1;\n\t\tevent.item = item;\n\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Dispatch a fileload {{#crossLink \"Event\"}}{{/crossLink}}. Please see the {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}} event for\n\t * details on the event payload.\n\t * @method _sendFileComplete\n\t * @param {LoadItemObject} item The item that is being loaded.\n\t * @param {AbstractLoader} loader\n\t * @protected\n\t */\n\tp._sendFileComplete = function (item, loader) {\n\t\tif (this._isCanceled() || this._paused) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar event = new createjs.Event(\"fileload\");\n\t\tevent.loader = loader;\n\t\tevent.item = item;\n\t\tevent.result = this._loadedResults[item.id];\n\t\tevent.rawResult = this._loadedRawResults[item.id];\n\n\t\t// This calls a handler specified on the actual load item. Currently, the SoundJS plugin uses this.\n\t\tif (item.completeHandler) {\n\t\t\titem.completeHandler(event);\n\t\t}\n\n\t\tthis.hasEventListener(\"fileload\") && this.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Dispatch a filestart {{#crossLink \"Event\"}}{{/crossLink}} immediately before a file starts to load. Please see\n\t * the {{#crossLink \"LoadQueue/filestart:event\"}}{{/crossLink}} event for details on the event payload.\n\t * @method _sendFileStart\n\t * @param {LoadItem|Object} item The item that is being loaded.\n\t * @protected\n\t */\n\tp._sendFileStart = function (item) {\n\t\tvar event = new createjs.Event(\"filestart\");\n\t\tevent.item = item;\n\t\tthis.hasEventListener(\"filestart\") && this.dispatchEvent(event);\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[PreloadJS LoadQueue]\";\n\t};\n\n\tcreatejs.LoadQueue = createjs.promote(LoadQueue, \"AbstractLoader\");\n}());\n\n//##############################################################################\n// TextLoader.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for Text files.\n\t * @class TextLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction TextLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.Types.TEXT);\n\t};\n\n\tvar p = createjs.extend(TextLoader, createjs.AbstractLoader);\n\tvar s = TextLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader loads items that are of type {{#crossLink \"Types/TEXT:property\"}}{{/crossLink}},\n\t * but is also the default loader if a file type can not be determined.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.Types.TEXT;\n\t};\n\n\tcreatejs.TextLoader = createjs.promote(TextLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// BinaryLoader.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for binary files. This is useful for loading web audio, or content that requires an ArrayBuffer.\n\t * @class BinaryLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction BinaryLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.Types.BINARY);\n\t\tthis.on(\"initialize\", this._updateXHR, this);\n\t};\n\n\tvar p = createjs.extend(BinaryLoader, createjs.AbstractLoader);\n\tvar s = BinaryLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"Types/BINARY:property\"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.Types.BINARY;\n\t};\n\n\t// private methods\n\t/**\n\t * Before the item loads, set the response type to \"arraybuffer\"\n\t * @property _updateXHR\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._updateXHR = function (event) {\n\t\tevent.loader.setResponseType(\"arraybuffer\");\n\t};\n\n\tcreatejs.BinaryLoader = createjs.promote(BinaryLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// CSSLoader.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for CSS files.\n\t * @class CSSLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction CSSLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.Types.CSS);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = \"href\";\n\n\t\tif (preferXHR) {\n\t\t\tthis._tag = createjs.Elements.style();\n\t\t} else {\n\t\t\tthis._tag = createjs.Elements.link();\n\t\t}\n\n\t\tthis._tag.rel = \"stylesheet\";\n\t\tthis._tag.type = \"text/css\";\n\t};\n\n\tvar p = createjs.extend(CSSLoader, createjs.AbstractLoader);\n\tvar s = CSSLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"Types/CSS:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.Types.CSS;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for CSS files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLLinkElement|HTMLStyleElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\tif (this._preferXHR) {\n\t\t\tvar tag = loader.getTag();\n\n\t\t\tif (tag.styleSheet) { // IE\n\t\t\t\ttag.styleSheet.cssText = loader.getResult(true);\n\t\t\t} else {\n\t\t\t\tvar textNode = createjs.Elements.text(loader.getResult(true));\n\t\t\t\ttag.appendChild(textNode);\n\t\t\t}\n\t\t} else {\n\t\t\ttag = this._tag;\n\t\t}\n\n\t\tcreatejs.DomUtils.appendToHead(tag);\n\n\t\treturn tag;\n\t};\n\n\tcreatejs.CSSLoader = createjs.promote(CSSLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// FontLoader.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function () {\n\t\"use strict\";\n\n// constructor:\n\t/**\n\t * A loader that handles font files, CSS definitions, and CSS paths. FontLoader doesn't actually preload fonts\n\t * themselves, but rather generates CSS definitions, and then tests the size changes on an HTML5 Canvas element.\n\t *\n\t * Note that FontLoader does not support tag-based loading due to the requirement that CSS be read to determine the\n\t * font definitions to test for.\n\t * @class FontLoader\n\t * @param {LoadItem|object|string} loadItem The item to be loaded.\n\t * @extends AbstractLoader\n\t * @constructor\n\t **/\n\tfunction FontLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, loadItem.type);\n\n\t\t// private properties:\n\t\t/**\n\t\t * A lookup of font faces to load.\n\t\t * @property _faces\n\t\t * @protected\n\t\t * @type Object\n\t\t **/\n\t\tthis._faces = {};\n\n\t\t/**\n\t\t * A list of font faces currently being \"watched\". Watched fonts will be tested on a regular interval, and be\n\t\t * removed from this list when they are complete.\n\t\t * @oroperty _watched\n\t\t * @type {Array}\n\t\t * @protected\n\t\t */\n\t\tthis._watched = [];\n\n\t\t/**\n\t\t * A count of the total font faces to load.\n\t\t * @property _count\n\t\t * @type {number}\n\t\t * @protected\n\t\t * @default 0\n\t\t */\n\t\tthis._count = 0;\n\n\t\t/**\n\t\t * The interval for checking if fonts have been loaded.\n\t\t * @property _watchInterval\n\t\t * @type {Number}\n\t\t * @protected\n\t\t */\n\t\tthis._watchInterval = null;\n\n\t\t/**\n\t\t * The timeout for determining if a font can't be loaded. Uses the LoadItem {{#crossLink \"LoadImte/timeout:property\"}}{{/crossLink}}\n\t\t * value.\n\t\t * @property _loadTimeout\n\t\t * @type {Number}\n\t\t * @protected\n\t\t */\n\t\tthis._loadTimeout = null;\n\t\t/**\n\t\t * Determines if generated CSS should be injected into the document.\n\t\t * @property _injectCSS\n\t\t * @type {boolean}\n\t\t * @protected\n\t\t */\n\t\tthis._injectCSS = (loadItem.injectCSS === undefined) ? true : loadItem.injectCSS;\n\n\t\tthis.dispatchEvent(\"initialize\");\n\t}\n\tvar p = createjs.extend(FontLoader, createjs.AbstractLoader);\n    \n    /**\n     * Determines if the loader can load a specific item. This loader can only load items that are of type\n     * {{#crossLink \"Types/FONT:property\"}}{{/crossLink}}.\n     * @method canLoadItem\n     * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n     * @returns {Boolean} Whether the loader can load the item.\n     * @static\n     */\n    FontLoader.canLoadItem = function (item) {\n        return item.type == createjs.Types.FONT || item.type == createjs.Types.FONTCSS;\n    };\n\n// static properties:\n\t/**\n\t * Sample text used by the FontLoader to determine if the font has been loaded. The sample text size is compared\n\t * to the loaded font size, and a change indicates that the font has completed.\n\t * @property sampleText\n\t * @type {String}\n\t * @default abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ\n\t * @static\n\t * @private\n\t */\n\tFontLoader.sampleText = \"abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n\t/**\n\t * The canvas context used to test the font size. Note that this currently requires an HTML DOM.\n\t * @property _ctx\n\t * @type {CanvasRenderingContext2D}\n\t * @static\n\t * @private\n\t */\n\tFontLoader._ctx = document.createElement(\"canvas\").getContext(\"2d\"); // TODO: Consider a method to do this like EaselJS Stage has.\n\n\t/**\n\t * A list of reference fonts to test. Multiple faces are tested to address the rare case of a loaded font being the\n\t * exact same dimensions as the test font.\n\t * @property _referenceFonts\n\t * @type {Array}\n\t * @default [\"serif\", \"monospace\"]\n\t * @private\n\t */\n\tFontLoader._referenceFonts = [\"serif\",\"monospace\"];\n\n\t/**\n\t * A regular expression that pulls out possible style values from the font name.\n\t * <ul>\n\t *     <li>This includes font names that include thin, normal, book, regular, medium, black, and heavy (such as\n\t *     \"Arial Black\")</li>\n\t *     <li>Weight modifiers including extra, ultra, semi, demi, light, and bold (such as \"WorkSans SemiBold\")</li>\n\t * </ul>\n\t *\n\t * Weight descriptions map to font weight values by default using the following (from\n\t * http://www.w3.org/TR/css3-fonts/#font-weight-numeric-values):\n\t * <ul>\n\t *     <li>100 - Thin</li>\n\t * \t   <li>200 - Extra Light, Ultra Light</li>\n\t *     <li>300 - Light, Semi Light, Demi Light</li>\n\t *     <li>400 - Normal, Book, Regular</li>\n\t *     <li>500 - Medium</li>\n\t *     <li>600 - Semi Bold, Demi Bold</li>\n\t *     <li>700 - Bold</li>\n\t *     <li>800 - Extra Bold, Ultra Bold</li>\n\t *     <li>900 - Black, Heavy</li>\n\t * </ul>\n\t * @property WEIGHT_REGEX\n\t * @type {RegExp}\n\t * @static\n\t */\n\tFontLoader.WEIGHT_REGEX = /[- ._]*(thin|normal|book|regular|medium|black|heavy|[1-9]00|(?:extra|ultra|semi|demi)?[- ._]*(?:light|bold))[- ._]*/ig;\n\n\t/**\n\t * A regular expression that pulls out possible style values from the font name. These include \"italic\"\n\t * and \"oblique\".\n\t * @property STYLE_REGEX\n\t * @type {RegExp}\n\t * @static\n\t */\n\tFontLoader.STYLE_REGEX = /[- ._]*(italic|oblique)[- ._]*/ig;\n\n\t/**\n\t * A lookup of font types for generating a CSS definition. For example, TTF fonts requires a \"truetype\" type.\n\t * @property FONT_FORMAT\n\t * @type {Object}\n\t * @static\n\t */\n\tFontLoader.FONT_FORMAT = {woff2:\"woff2\", woff:\"woff\", ttf:\"truetype\", otf:\"truetype\"};\n\n\t/**\n\t * A lookup of font weights based on a name. These values are from http://www.w3.org/TR/css3-fonts/#font-weight-numeric-values.\n\t * @property FONT_WEIGHT\n\t * @type {Object}\n\t * @static\n\t */\n\tFontLoader.FONT_WEIGHT = {thin:100, extralight:200, ultralight:200, light:300, semilight:300, demilight:300, book:\"normal\", regular:\"normal\", semibold:600, demibold:600, extrabold:800, ultrabold:800, black:900, heavy:900};\n\n\t/**\n\t * The frequency in milliseconds to check for loaded fonts.\n\t * @property WATCH_DURATION\n\t * @type {number}\n\t * @default 10\n\t * @static\n\t */\n\tFontLoader.WATCH_DURATION = 10;\n// public methods:\n\tp.load = function() {\n\t\tif (this.type == createjs.Types.FONTCSS) {\n\t\t\tvar loaded = this._watchCSS();\n\n\t\t\t// If the CSS is not ready, it will create a request, which AbstractLoader can handle.\n\t\t\tif (!loaded) {\n\t\t\t\tthis.AbstractLoader_load();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t} else if (this._item.src instanceof Array) {\n\t\t\tthis._watchFontArray();\n\t\t} else {\n\t\t\tvar def = this._defFromSrc(this._item.src);\n\t\t\tthis._watchFont(def);\n\t\t\tthis._injectStyleTag(this._cssFromDef(def));\n\t\t}\n\n\t\tthis._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);\n\n\t\tthis.dispatchEvent(\"loadstart\");\n\t};\n\n\t/**\n\t * The font load has timed out. This is called via a <code>setTimeout</code>.\n\t * callback.\n\t * @method _handleTimeout\n\t * @protected\n\t */\n\tp._handleTimeout = function () {\n\t\tthis._stopWatching();\n\t\tthis.dispatchEvent(new createjs.ErrorEvent(\"PRELOAD_TIMEOUT\"));\n\t};\n\n\t// WatchCSS does the work for us, and provides a modified src.\n\tp._createRequest = function() {\n\t\treturn this._request;\n\t};\n\n\t// Events come from the internal XHR loader.\n\tp.handleEvent = function (event) {\n\t\tswitch (event.type) {\n\t\t\tcase \"complete\":\n\t\t\t\tthis._rawResult = event.target._response;\n\t\t\t\tthis._result = true;\n\t\t\t\tthis._parseCSS(this._rawResult);\n\t\t\t\tbreak;\n\n\t\t\tcase \"error\":\n\t\t\t\tthis._stopWatching();\n\t\t\t\tthis.AbstractLoader_handleEvent(event);\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n// private methods:\n\t/**\n\t * Determine if the provided CSS is a string definition, CSS HTML element, or a CSS file URI. Depending on the\n\t * format, the CSS will be parsed, or loaded.\n\t * @method _watchCSS\n\t * @returns {boolean} Whether or not the CSS is ready\n\t * @protected\n\t */\n\tp._watchCSS = function() {\n\t\tvar src = this._item.src;\n\n\t\t// An HTMLElement was passed in. Just use it.\n\t\tif (src instanceof HTMLStyleElement) {\n\t\t\tif (this._injectCSS && !src.parentNode) { (document.head || document.getElementsByTagName('head')[0]).appendChild(src); }\n\t\t\tthis._injectCSS = false;\n\t\t\tsrc = \"\\n\"+src.textContent;\n\t\t}\n\n\t\t// A CSS string was passed in. Parse and use it\n\t\tif (src.search(/\\n|\\r|@font-face/i) !== -1) { // css string.\n\t\t\tthis._parseCSS(src);\n\t\t\treturn true;\n\t\t}\n\n\t\t// Load a CSS Path. Note that we CAN NOT load it without XHR because we need to read the CSS definition\n\t\tthis._request = new createjs.XHRRequest(this._item);\n\t\treturn false;\n\t};\n\n\t/**\n\t * Parse a CSS string to determine the fonts to load.\n\t * @method _parseCSS\n\t * @param {String} css The CSS string to parse\n\t * @protected\n\t */\n\tp._parseCSS = function(css) {\n\t\tvar regex = /@font-face\\s*\\{([^}]+)}/g\n\t\twhile (true) {\n\t\t\tvar result = regex.exec(css);\n\t\t\tif (!result) { break; }\n\t\t\tthis._watchFont(this._parseFontFace(result[1]));\n\t\t}\n\t\tthis._injectStyleTag(css);\n\t};\n\n\t/**\n\t * The provided fonts were an array of object or string definitions. Parse them, and inject any that are ready.\n\t * @method _watchFontArray\n\t * @protected\n\t */\n\tp._watchFontArray = function() {\n\t\tvar arr = this._item.src, css = \"\", def;\n\t\tfor (var i=arr.length-1; i>=0; i--) {\n\t\t\tvar o = arr[i];\n\t\t\tif (typeof o === \"string\") { def = this._defFromSrc(o) }\n\t\t\telse { def = this._defFromObj(o); }\n\t\t\tthis._watchFont(def);\n\t\t\tcss += this._cssFromDef(def)+\"\\n\";\n\t\t}\n\t\tthis._injectStyleTag(css);\n\t};\n\n\t/**\n\t * Inject any style definitions into the document head. This is necessary when the definition is just a string or\n\t * object definition in order for the styles to be applied to the document. If the loaded fonts are already HTML CSS\n\t * elements, they don't need to be appended again.\n\t * @method _injectStyleTag\n\t * @param {String} css The CSS string content to be appended to the\n\t * @protected\n\t */\n\tp._injectStyleTag = function(css) {\n\t\tif (!this._injectCSS) { return; }\n\t\tvar head = document.head || document.getElementsByTagName('head')[0];\n\t\tvar styleTag = document.createElement(\"style\");\n\t\tstyleTag.type = \"text/css\";\n\t\tif (styleTag.styleSheet){\n\t\t\tstyleTag.styleSheet.cssText = css;\n\t\t} else {\n\t\t\tstyleTag.appendChild(document.createTextNode(css));\n\t\t}\n\t\thead.appendChild(styleTag);\n\t};\n\n\t/**\n\t * Determine the font face from a CSS definition.\n\t * @method _parseFontFace\n\t * @param {String} str The CSS string definition\n\t * @protected\n\t * @return {String} A modified CSS object containing family name, src, style, and weight\n\t */\n\tp._parseFontFace = function(str) {\n\t\tvar family = this._getCSSValue(str, \"font-family\"), src = this._getCSSValue(str, \"src\");\n\t\tif (!family || !src) { return null; }\n\t\treturn this._defFromObj({\n\t\t\tfamily: family,\n\t\t\tsrc: src,\n\t\t\tstyle: this._getCSSValue(str, \"font-style\"),\n\t\t\tweight: this._getCSSValue(str, \"font-weight\")\n\t\t});\n\t};\n\n\t/**\n\t * Add a font to the list of fonts currently being watched. If the font is already watched or loaded, it won't be\n\t * added again.\n\t * @method _watchFont\n\t * @param {Object} def The font definition\n\t * @protected\n\t */\n\tp._watchFont = function(def) {\n\t\tif (!def || this._faces[def.id]) { return; }\n\t\tthis._faces[def.id] = def;\n\t\tthis._watched.push(def);\n\t\tthis._count++;\n\n\t\tthis._calculateReferenceSizes(def);\n\t\tthis._startWatching();\n\t};\n\n\t/**\n\t * Create a interval to check for loaded fonts. Only one interval is used for all fonts. The fonts are checked based\n\t * on the {{#crossLink \"FontLoader/WATCH_DURATION:property\"}}{{/crossLink}}.\n\t * @method _startWatching\n\t * @protected\n\t */\n\tp._startWatching = function() {\n\t\tif (this._watchInterval != null) { return; }\n\t\tthis._watchInterval = setInterval(createjs.proxy(this._watch, this), FontLoader.WATCH_DURATION);\n\t};\n\n\t/**\n\t * Clear the interval used to check fonts. This happens when all fonts are loaded, or an error occurs, such as a\n\t * CSS file error, or a load timeout.\n\t * @method _stopWatching\n\t * @protected\n\t */\n\tp._stopWatching = function() {\n\t\tclearInterval(this._watchInterval);\n\t\tclearTimeout(this._loadTimeout);\n\t\tthis._watchInterval = null;\n\t};\n\n\t/**\n\t * Check all the fonts that have not been loaded. The fonts are drawn to a canvas in memory, and if their font size\n\t * varies from the default text size, then the font is considered loaded.\n\t *\n\t * A {{#crossLink \"AbstractLoader/fileload\"}}{{/crossLink}} event will be dispatched when each file is loaded, along\n\t * with the font family name as the `item` value. A {{#crossLink \"ProgressEvent\"}}{{/crossLink}} is dispatched a\n\t * maximum of one time per check when any fonts are loaded, with the {{#crossLink \"ProgressEvent/progress:property\"}}{{/crossLink}}\n\t * value showing the percentage of fonts that have loaded.\n\t * @method _watch\n\t * @protected\n\t */\n\tp._watch = function() {\n\t\tvar defs = this._watched, refFonts = FontLoader._referenceFonts, l = defs.length;\n\t\tfor (var i = l - 1; i >= 0; i--) {\n\t\t\tvar def = defs[i], refs = def.refs;\n\t\t\tfor (var j = refs.length - 1; j >= 0; j--) {\n\t\t\t\tvar w = this._getTextWidth(def.family + \",\" + refFonts[j], def.weight, def.style);\n\t\t\t\tif (w != refs[j]) {\n\t\t\t\t\tvar event = new createjs.Event(\"fileload\");\n\t\t\t\t\tdef.type = \"font-family\";\n\t\t\t\t\tevent.item = def;\n\t\t\t\t\tthis.dispatchEvent(event);\n\t\t\t\t\tdefs.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (l !== defs.length) {\n\t\t\tvar event = new createjs.ProgressEvent(this._count-defs.length, this._count);\n\t\t\tthis.dispatchEvent(event);\n\t\t}\n\t\tif (l === 0) {\n\t\t\tthis._stopWatching();\n\t\t\tthis._sendComplete();\n\t\t}\n\t};\n\n\t/**\n\t * Determine the default size of the reference fonts used to compare against loaded fonts.\n\t * @method _calculateReferenceSizes\n\t * @param {Object} def The font definition to get the size of.\n\t * @protected\n\t */\n\tp._calculateReferenceSizes = function(def) {\n\t\tvar refFonts = FontLoader._referenceFonts;\n\t\tvar refs = def.refs = [];\n\t\tfor (var i=0; i<refFonts.length; i++) {\n\t\t\trefs[i] = this._getTextWidth(refFonts[i], def.weight, def.style);\n\t\t}\n\t};\n\n\t/**\n\t * Get a CSS definition from a font source and name.\n\t * @method _defFromSrc\n\t * @param {String} src The font source\n\t * @protected\n\t */\n\tp._defFromSrc = function(src) {\n\t\tvar re = /[- ._]+/g, name = src, ext = null, index;\n\t\t\n\t\tindex = name.search(/[?#]/);\n\t\tif (index !== -1) {\n\t\t\tname = name.substr(0,index);\n\t\t}\n\t\tindex = name.lastIndexOf(\".\");\n\t\tif (index !== -1) {\n\t\t\text = name.substr(index+1);\n\t\t\tname = name.substr(0,index);\n\t\t}\n\t\tindex = name.lastIndexOf(\"/\");\n\t\tif (index !== -1) {\n\t\t\tname = name.substr(index+1);\n\t\t}\n\t\t\n\t\tvar family = name,\n\t\t\t\tweight = family.match(FontLoader.WEIGHT_REGEX);\n\t\tif (weight) {\n\t\t\tweight = weight[0];\n\t\t\tfamily = family.replace(weight, \"\");\n\t\t\tweight = weight.replace(re, \"\").toLowerCase();\n\t\t}\n\t\tvar style = name.match(FontLoader.STYLE_REGEX);\n\t\tif (style) {\n\t\t\tfamily = family.replace(style[0], \"\");\n\t\t\tstyle = \"italic\";\n\t\t}\n\t\tfamily = family.replace(re, \"\");\n\t\t\n\t\tvar cssSrc = \"local('\"+name.replace(re,\" \")+\"'), url('\"+src+\"')\";\n\t\tvar format = FontLoader.FONT_FORMAT[ext];\n\t\tif (format) { cssSrc += \" format('\"+format+\"')\"; }\n\t\t\n\t\treturn this._defFromObj({\n\t\t\tfamily: family,\n\t\t\tweight: FontLoader.FONT_WEIGHT[weight]||weight,\n\t\t\tstyle: style,\n\t\t\tsrc: cssSrc\n\t\t});\n\t};\n\n\t/**\n\t * Get a font definition from a raw font object.\n\t * @method _defFromObj\n\t * @param {Object} o A raw object provided to the FontLoader\n\t * @returns {Object} A standard font object that the FontLoader understands\n\t * @protected\n\t */\n\tp._defFromObj = function(o) {\n\t\tvar def = {\n\t\t\tfamily: o.family,\n\t\t\tsrc: o.src,\n\t\t\tstyle: o.style || \"normal\",\n\t\t\tweight: o.weight || \"normal\"\n\t\t};\n\t\tdef.id = def.family + \";\" + def.style + \";\" + def.weight;\n\t\treturn def;\n\t};\n\n\t/**\n\t * Get CSS from a font definition.\n\t * @method _cssFromDef\n\t * @param {Object} def A font definition\n\t * @returns {string} A CSS string representing the object\n\t * @protected\n\t */\n\tp._cssFromDef = function(def) {\n\t\treturn \"@font-face {\\n\" +\n\t\t\t\"\\tfont-family: '\"+def.family+\"';\\n\" +\n\t\t\t\"\\tfont-style: \"+def.style+\";\\n\" +\n\t\t\t\"\\tfont-weight: \"+def.weight+\";\\n\" +\n\t\t\t\"\\tsrc: \"+def.src+\";\\n\" +\n\t\t\t\"}\";\n\t};\n\n\t/**\n\t * Get the text width of text using the family, weight, and style\n\t * @method _getTextWidth\n\t * @param {String} family The font family\n\t * @param {String} weight The font weight\n\t * @param {String} style The font style\n\t * @returns {Number} The pixel measurement of the font.\n\t * @protected\n\t */\n\tp._getTextWidth = function(family, weight, style) {\n\t\tvar ctx = FontLoader._ctx;\n\t\tctx.font = style+\" \"+weight+\" 72px \"+family;\n\t\treturn ctx.measureText(FontLoader.sampleText).width;\n\t};\n\n\t/**\n\t * Get the value of a property from a CSS string. For example, searches a CSS string for the value of the\n\t * \"font-family\" property.\n\t * @method _getCSSValue\n\t * @param {String} str The CSS string to search\n\t * @param {String} propName The property name to get the value for\n\t * @returns {String} The value in the CSS for the provided property name\n\t * @protected\n\t */\n\tp._getCSSValue = function(str, propName) {\n\t\tvar regex = new RegExp(propName+\":\\s*([^;}]+?)\\s*[;}]\");\n\t\tvar result = regex.exec(str);\n\t\tif (!result || !result[1]) { return null; }\n\t\treturn result[1];\n\t};\n\n\tcreatejs.FontLoader = createjs.promote(FontLoader, \"AbstractLoader\");\n\n})();\n\n//##############################################################################\n// ImageLoader.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for image files.\n\t * @class ImageLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction ImageLoader (loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.Types.IMAGE);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = \"src\";\n\n\t\t// Check if the preload item is already a tag.\n\t\tif (createjs.DomUtils.isImageTag(loadItem)) {\n\t\t\tthis._tag = loadItem;\n\t\t} else if (createjs.DomUtils.isImageTag(loadItem.src)) {\n\t\t\tthis._tag = loadItem.src;\n\t\t} else if (createjs.DomUtils.isImageTag(loadItem.tag)) {\n\t\t\tthis._tag = loadItem.tag;\n\t\t}\n\n\t\tif (this._tag != null) {\n\t\t\tthis._preferXHR = false;\n\t\t} else {\n\t\t\tthis._tag = createjs.Elements.img();\n\t\t}\n\n\t\tthis.on(\"initialize\", this._updateXHR, this);\n\t};\n\n\tvar p = createjs.extend(ImageLoader, createjs.AbstractLoader);\n\tvar s = ImageLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"Types/IMAGE:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.Types.IMAGE;\n\t};\n\n\t// public methods\n\tp.load = function () {\n\t\tif (this._tag.src != \"\" && this._tag.complete) {\n\t\t\tthis._sendComplete();\n\t\t\treturn;\n\t\t}\n\n\t\tvar crossOrigin = this._item.crossOrigin;\n\t\tif (crossOrigin == true) { crossOrigin = \"Anonymous\"; }\n\t\tif (crossOrigin != null && !createjs.URLUtils.isLocal(this._item)) {\n\t\t\tthis._tag.crossOrigin = crossOrigin;\n\t\t}\n\n\t\tthis.AbstractLoader_load();\n\t};\n\n\t// protected methods\n\t/**\n\t * Before the item loads, set its mimeType and responseType.\n\t * @property _updateXHR\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._updateXHR = function (event) {\n\t\tevent.loader.mimeType = 'text/plain; charset=x-user-defined-binary';\n\n\t\t// Only exists for XHR\n\t\tif (event.loader.setResponseType) {\n\t\t\tevent.loader.setResponseType(\"blob\");\n\t\t}\n\t};\n\n\t/**\n\t * The result formatter for Image files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLImageElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\treturn this._formatImage;\n\t};\n\n\t/**\n\t * The asynchronous image formatter function. This is required because images have\n\t * a short delay before they are ready.\n\t * @method _formatImage\n\t * @param {Function} successCallback The method to call when the result has finished formatting\n\t * @param {Function} errorCallback The method to call if an error occurs during formatting\n\t * @private\n\t */\n\tp._formatImage = function (successCallback, errorCallback) {\n\t\tvar tag = this._tag;\n\t\tvar URL = window.URL || window.webkitURL;\n\n\t\tif (!this._preferXHR) {\n\n\t\t\t//document.body.removeChild(tag);\n\t\t} else if (URL) {\n\t\t\tvar objURL = URL.createObjectURL(this.getResult(true));\n\t\t\ttag.src = objURL;\n\n\t\t\ttag.addEventListener(\"load\", this._cleanUpURL, false);\n\t\t\ttag.addEventListener(\"error\", this._cleanUpURL, false);\n\t\t} else {\n\t\t\ttag.src = this._item.src;\n\t\t}\n\n\t\tif (tag.complete) {\n\t\t\tsuccessCallback(tag);\n\t\t} else {\n            tag.onload = createjs.proxy(function() {\n                successCallback(this._tag);\n                tag.onload = tag.onerror = null;\n            }, this);\n\n            tag.onerror = createjs.proxy(function(event) {\n                errorCallback(new createjs.ErrorEvent('IMAGE_FORMAT', null, event));\n                tag.onload = tag.onerror = null;\n            }, this);\n\t\t}\n\t};\n\n\t/**\n\t * Clean up the ObjectURL, the tag is done with it. Note that this function is run\n\t * as an event listener without a proxy/closure, as it doesn't require it - so do not\n\t * include any functionality that requires scope without changing it.\n\t * @method _cleanUpURL\n\t * @param event\n\t * @private\n\t */\n\tp._cleanUpURL = function (event) {\n\t\tvar URL = window.URL || window.webkitURL;\n\t\tURL.revokeObjectURL(event.target.src);\n\t};\n\n\tcreatejs.ImageLoader = createjs.promote(ImageLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// JavaScriptLoader.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for JavaScript files.\n\t * @class JavaScriptLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction JavaScriptLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.Types.JAVASCRIPT);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = \"src\";\n\t\tthis.setTag(createjs.Elements.script());\n\t};\n\n\tvar p = createjs.extend(JavaScriptLoader, createjs.AbstractLoader);\n\tvar s = JavaScriptLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"Types/JAVASCRIPT:property\"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.Types.JAVASCRIPT;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for JavaScript files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLLinkElement|HTMLStyleElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\tvar tag = loader.getTag();\n\t\tif (this._preferXHR) {\n\t\t\ttag.text = loader.getResult(true);\n\t\t}\n\t\treturn tag;\n\t};\n\n\tcreatejs.JavaScriptLoader = createjs.promote(JavaScriptLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// JSONLoader.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for JSON files. To load JSON cross-domain, use JSONP and the {{#crossLink \"JSONPLoader\"}}{{/crossLink}}\n\t * instead. To load JSON-formatted manifests, use {{#crossLink \"ManifestLoader\"}}{{/crossLink}}, and to\n\t * load EaselJS SpriteSheets, use {{#crossLink \"SpriteSheetLoader\"}}{{/crossLink}}.\n\t * @class JSONLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction JSONLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.Types.JSON);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\t};\n\n\tvar p = createjs.extend(JSONLoader, createjs.AbstractLoader);\n\tvar s = JSONLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"Types/JSON:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.Types.JSON;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for JSON files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLLinkElement|HTMLStyleElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\tvar json = null;\n\t\ttry {\n\t\t\tjson = createjs.DataUtils.parseJSON(loader.getResult(true));\n\t\t} catch (e) {\n\t\t\tvar event = new createjs.ErrorEvent(\"JSON_FORMAT\", null, e);\n\t\t\tthis._sendError(event);\n\t\t\treturn e;\n\t\t}\n\n\t\treturn json;\n\t};\n\n\tcreatejs.JSONLoader = createjs.promote(JSONLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// JSONPLoader.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for JSONP files, which are JSON-formatted text files, wrapped in a callback. To load regular JSON\n\t * without a callback use the {{#crossLink \"JSONLoader\"}}{{/crossLink}} instead. To load JSON-formatted manifests,\n\t * use {{#crossLink \"ManifestLoader\"}}{{/crossLink}}, and to load EaselJS SpriteSheets, use\n\t * {{#crossLink \"SpriteSheetLoader\"}}{{/crossLink}}.\n\t *\n\t * JSONP is a format that provides a solution for loading JSON files cross-domain <em>without</em> requiring CORS.\n\t * JSONP files are loaded as JavaScript, and the \"callback\" is executed once they are loaded. The callback in the\n\t * JSONP must match the callback passed to the loadItem.\n\t *\n\t * <h4>Example JSONP</h4>\n\t *\n\t * \t\tcallbackName({\n\t * \t\t\t\"name\": \"value\",\n\t *\t \t\t\"num\": 3,\n\t *\t\t\t\"obj\": { \"bool\":true }\n\t * \t\t});\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \t\tvar loadItem = {id:\"json\", type:\"jsonp\", src:\"http://server.com/text.json\", callback:\"callbackName\"}\n\t * \t\tvar queue = new createjs.LoadQueue();\n\t * \t\tqueue.on(\"complete\", handleComplete);\n\t * \t\tqueue.loadItem(loadItem);\n\t *\n\t * \t\tfunction handleComplete(event) }\n\t * \t\t\tvar json = queue.getResult(\"json\");\n\t * \t\t\tconsole.log(json.obj.bool); // true\n\t * \t\t}\n\t *\n\t * JSONP files loaded concurrently require a <em>unique</em> callback. To ensure JSONP files are loaded in order,\n\t * either use the {{#crossLink \"LoadQueue/setMaxConnections\"}}{{/crossLink}} method (set to 1), or set\n\t * {{#crossLink \"LoadItem/maintainOrder:property\"}}{{/crossLink}} on items with the same callback.\n\t *\n\t * Important note: Some browsers will prevent JSONP from firing the callback if the file was loaded as JSON, and not\n\t * JavaScript. You may have to have your server give you a JavaScript mime-type for this to work.\n\t *\n\t * @class JSONPLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction JSONPLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, false, createjs.Types.JSONP);\n\t\tthis.setTag(createjs.Elements.script());\n\t\tthis.getTag().type = \"text/javascript\";\n\t};\n\n\tvar p = createjs.extend(JSONPLoader, createjs.AbstractLoader);\n\tvar s = JSONPLoader;\n\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"Types/JSONP:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.Types.JSONP;\n\t};\n\n\t// public methods\n\tp.cancel = function () {\n\t\tthis.AbstractLoader_cancel();\n\t\tthis._dispose();\n\t};\n\n\t/**\n\t * Loads the JSONp file.  Because of the unique loading needs of JSONp\n\t * we don't use the AbstractLoader.load() method.\n\t *\n\t * @method load\n\t *\n\t */\n\tp.load = function () {\n\t\tif (this._item.callback == null) {\n\t\t\tthrow new Error('callback is required for loading JSONP requests.');\n\t\t}\n\n\t\t// TODO: Look into creating our own iFrame to handle the load\n\t\t// In the first attempt, FF did not get the result\n\t\t//   result instanceof Object did not work either\n\t\t//   so we would need to clone the result.\n\t\tif (window[this._item.callback] != null) {\n\t\t\tthrow new Error(\n\t\t\t\t\"JSONP callback '\" +\n\t\t\t\tthis._item.callback +\n\t\t\t\t\"' already exists on window. You need to specify a different callback or re-name the current one.\");\n\t\t}\n\n\t\twindow[this._item.callback] = createjs.proxy(this._handleLoad, this);\n\t\tcreatejs.DomUtils.appendToBody(this._tag);\n\n\t\tthis._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);\n\n\t\t// Load the tag\n\t\tthis._tag.src = this._item.src;\n\t};\n\n\t// private methods\n\t/**\n\t * Handle the JSONP callback, which is a public method defined on `window`.\n\t * @method _handleLoad\n\t * @param {Object} data The formatted JSON data.\n\t * @private\n\t */\n\tp._handleLoad = function (data) {\n\t\tthis._result = this._rawResult = data;\n\t\tthis._sendComplete();\n\n\t\tthis._dispose();\n\t};\n\n\t/**\n\t * The tag request has not loaded within the time specfied in loadTimeout.\n\t * @method _handleError\n\t * @param {Object} event The XHR error event.\n\t * @private\n\t */\n\tp._handleTimeout = function () {\n\t\tthis._dispose();\n\t\tthis.dispatchEvent(new createjs.ErrorEvent(\"timeout\"));\n\t};\n\n\t/**\n\t * Clean up the JSONP load. This clears out the callback and script tag that this loader creates.\n\t * @method _dispose\n\t * @private\n\t */\n\tp._dispose = function () {\n\t\tcreatejs.DomUtils.removeChild(this._tag);\n\t\tdelete window[this._item.callback];\n\n\t\tclearTimeout(this._loadTimeout);\n\t};\n\n\tcreatejs.JSONPLoader = createjs.promote(JSONPLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// ManifestLoader.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for JSON manifests. Items inside the manifest are loaded before the loader completes. To load manifests\n\t * using JSONP, specify a {{#crossLink \"LoadItem/callback:property\"}}{{/crossLink}} as part of the\n\t * {{#crossLink \"LoadItem\"}}{{/crossLink}}.\n\t *\n\t * The list of files in the manifest must be defined on the top-level JSON object in a `manifest` property. This\n\t * example shows a sample manifest definition, as well as how to to include a sub-manifest.\n\t *\n\t * \t\t{\n\t * \t\t\t\"path\": \"assets/\",\n\t *\t \t    \"manifest\": [\n\t *\t\t\t\t\"image.png\",\n\t *\t\t\t\t{\"src\": \"image2.png\", \"id\":\"image2\"},\n\t *\t\t\t\t{\"src\": \"sub-manifest.json\", \"type\":\"manifest\", \"callback\":\"jsonCallback\"}\n\t *\t \t    ]\n\t *\t \t}\n\t *\n\t * When a ManifestLoader has completed loading, the parent loader (usually a {{#crossLink \"LoadQueue\"}}{{/crossLink}},\n\t * but could also be another ManifestLoader) will inherit all the loaded items, so you can access them directly.\n\t *\n\t * Note that the {{#crossLink \"JSONLoader\"}}{{/crossLink}} and {{#crossLink \"JSONPLoader\"}}{{/crossLink}} are\n\t * higher priority loaders, so manifests <strong>must</strong> set the {{#crossLink \"LoadItem\"}}{{/crossLink}}\n\t * {{#crossLink \"LoadItem/type:property\"}}{{/crossLink}} property to {{#crossLink \"Types/MANIFEST:property\"}}{{/crossLink}}.\n\t *\n\t * Additionally, some browsers require the server to serve a JavaScript mime-type for JSONP, so it may not work in\n\t * some conditions.\n\t * @class ManifestLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction ManifestLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.Types.MANIFEST);\n\n\t// Public Properties\n\t\t/**\n\t\t * An array of the plugins registered using {{#crossLink \"LoadQueue/installPlugin\"}}{{/crossLink}},\n\t\t * used to pass plugins to new LoadQueues that may be created.\n\t\t * @property _plugins\n\t\t * @type {Array}\n\t\t * @private\n\t\t * @since 0.6.1\n\t\t */\n\t\tthis.plugins = null;\n\n\n\t// Protected Properties\n\t\t/**\n\t\t * An internal {{#crossLink \"LoadQueue\"}}{{/crossLink}} that loads the contents of the manifest.\n\t\t * @property _manifestQueue\n\t\t * @type {LoadQueue}\n\t\t * @private\n\t\t */\n\t\tthis._manifestQueue = null;\n\t};\n\n\tvar p = createjs.extend(ManifestLoader, createjs.AbstractLoader);\n\tvar s = ManifestLoader;\n\n\t// static properties\n\t/**\n\t * The amount of progress that the manifest itself takes up.\n\t * @property MANIFEST_PROGRESS\n\t * @type {number}\n\t * @default 0.25 (25%)\n\t * @private\n\t * @static\n\t */\n\ts.MANIFEST_PROGRESS = 0.25;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"Types/MANIFEST:property\"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.Types.MANIFEST;\n\t};\n\n\t// public methods\n\tp.load = function () {\n\t\tthis.AbstractLoader_load();\n\t};\n\n\t// protected methods\n\tp._createRequest = function() {\n\t\tvar callback = this._item.callback;\n\t\tif (callback != null) {\n\t\t\tthis._request = new createjs.JSONPLoader(this._item);\n\t\t} else {\n\t\t\tthis._request = new createjs.JSONLoader(this._item);\n\t\t}\n\t};\n\n\tp.handleEvent = function (event) {\n\t\tswitch (event.type) {\n\t\t\tcase \"complete\":\n\t\t\t\tthis._rawResult = event.target.getResult(true);\n\t\t\t\tthis._result = event.target.getResult();\n\t\t\t\tthis._sendProgress(s.MANIFEST_PROGRESS);\n\t\t\t\tthis._loadManifest(this._result);\n\t\t\t\treturn;\n\t\t\tcase \"progress\":\n\t\t\t\tevent.loaded *= s.MANIFEST_PROGRESS;\n\t\t\t\tthis.progress = event.loaded / event.total;\n\t\t\t\tif (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }\n\t\t\t\tthis._sendProgress(event);\n\t\t\t\treturn;\n\t\t}\n\t\tthis.AbstractLoader_handleEvent(event);\n\t};\n\n\tp.destroy = function() {\n\t\tthis.AbstractLoader_destroy();\n\t\tthis._manifestQueue.close();\n\t};\n\n\t/**\n\t * Create and load the manifest items once the actual manifest has been loaded.\n\t * @method _loadManifest\n\t * @param {Object} json\n\t * @private\n\t */\n\tp._loadManifest = function (json) {\n\t\tif (json && json.manifest) {\n\t\t\tvar queue = this._manifestQueue = new createjs.LoadQueue(this._preferXHR);\n\t\t\tqueue.on(\"fileload\", this._handleManifestFileLoad, this);\n\t\t\tqueue.on(\"progress\", this._handleManifestProgress, this);\n\t\t\tqueue.on(\"complete\", this._handleManifestComplete, this, true);\n\t\t\tqueue.on(\"error\", this._handleManifestError, this, true);\n\t\t\tfor(var i = 0, l = this.plugins.length; i < l; i++) {\t// conserve order of plugins\n\t\t\t\tqueue.installPlugin(this.plugins[i]);\n\t\t\t}\n\t\t\tqueue.loadManifest(json);\n\t\t} else {\n\t\t\tthis._sendComplete();\n\t\t}\n\t};\n\n\t/**\n\t * An item from the {{#crossLink \"_manifestQueue:property\"}}{{/crossLink}} has completed.\n\t * @method _handleManifestFileLoad\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._handleManifestFileLoad = function (event) {\n\t\tevent.target = null;\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * The manifest has completed loading. This triggers the {{#crossLink \"AbstractLoader/complete:event\"}}{{/crossLink}}\n\t * {{#crossLink \"Event\"}}{{/crossLink}} from the ManifestLoader.\n\t * @method _handleManifestComplete\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._handleManifestComplete = function (event) {\n\t\tthis._loadedItems = this._manifestQueue.getItems(true);\n\t\tthis._sendComplete();\n\t};\n\n\t/**\n\t * The manifest has reported progress.\n\t * @method _handleManifestProgress\n\t * @param {ProgressEvent} event\n\t * @private\n\t */\n\tp._handleManifestProgress = function (event) {\n\t\tthis.progress = event.progress * (1 - s.MANIFEST_PROGRESS) + s.MANIFEST_PROGRESS;\n\t\tthis._sendProgress(this.progress);\n\t};\n\n\t/**\n\t * The manifest has reported an error with one of the files.\n\t * @method _handleManifestError\n\t * @param {ErrorEvent} event\n\t * @private\n\t */\n\tp._handleManifestError = function (event) {\n\t\tvar newEvent = new createjs.Event(\"fileerror\");\n\t\tnewEvent.item = event.data;\n\t\tthis.dispatchEvent(newEvent);\n\t};\n\n\tcreatejs.ManifestLoader = createjs.promote(ManifestLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// SoundLoader.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for HTML audio files. PreloadJS can not load WebAudio files, as a WebAudio context is required, which\n\t * should be created by either a library playing the sound (such as <a href=\"http://soundjs.com\">SoundJS</a>, or an\n\t * external framework that handles audio playback. To load content that can be played by WebAudio, use the\n\t * {{#crossLink \"BinaryLoader\"}}{{/crossLink}}, and handle the audio context decoding manually.\n\t * @class SoundLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractMediaLoader\n\t * @constructor\n\t */\n\tfunction SoundLoader(loadItem, preferXHR) {\n\t\tthis.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.Types.SOUND);\n\n\t\t// protected properties\n\t\tif (createjs.DomUtils.isAudioTag(loadItem)) {\n\t\t\tthis._tag = loadItem;\n\t\t} else if (createjs.DomUtils.isAudioTag(loadItem.src)) {\n\t\t\tthis._tag = loadItem;\n\t\t} else if (createjs.DomUtils.isAudioTag(loadItem.tag)) {\n\t\t\tthis._tag = createjs.DomUtils.isAudioTag(loadItem) ? loadItem : loadItem.src;\n\t\t}\n\n\t\tif (this._tag != null) {\n\t\t\tthis._preferXHR = false;\n\t\t}\n\t};\n\n\tvar p = createjs.extend(SoundLoader, createjs.AbstractMediaLoader);\n\tvar s = SoundLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"Types/SOUND:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.Types.SOUND;\n\t};\n\n\t// protected methods\n\tp._createTag = function (src) {\n\t\tvar tag = createjs.Elements.audio();\n\t\ttag.autoplay = false;\n\t\ttag.preload = \"none\";\n\n\t\t//LM: Firefox fails when this the preload=\"none\" for other tags, but it needs to be \"none\" to ensure PreloadJS works.\n\t\ttag.src = src;\n\t\treturn tag;\n\t};\n\n\tcreatejs.SoundLoader = createjs.promote(SoundLoader, \"AbstractMediaLoader\");\n\n}());\n\n//##############################################################################\n// VideoLoader.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for video files.\n\t * @class VideoLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractMediaLoader\n\t * @constructor\n\t */\n\tfunction VideoLoader(loadItem, preferXHR) {\n\t\tthis.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.Types.VIDEO);\n\n\t\tif (createjs.DomUtils.isVideoTag(loadItem) || createjs.DomUtils.isVideoTag(loadItem.src)) {\n\t\t\tthis.setTag(createjs.DomUtils.isVideoTag(loadItem)?loadItem:loadItem.src);\n\n\t\t\t// We can't use XHR for a tag that's passed in.\n\t\t\tthis._preferXHR = false;\n\t\t} else {\n\t\t\tthis.setTag(this._createTag());\n\t\t}\n\t};\n\n\tvar p = createjs.extend(VideoLoader, createjs.AbstractMediaLoader);\n\tvar s = VideoLoader;\n\n\t/**\n\t * Create a new video tag\n\t *\n\t * @returns {HTMLElement}\n\t * @private\n\t */\n\tp._createTag = function () {\n\t\treturn createjs.Elements.video();\n\t};\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"Types/VIDEO:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.Types.VIDEO;\n\t};\n\n\tcreatejs.VideoLoader = createjs.promote(VideoLoader, \"AbstractMediaLoader\");\n\n}());\n\n//##############################################################################\n// SpriteSheetLoader.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for EaselJS SpriteSheets. Images inside the spritesheet definition are loaded before the loader\n\t * completes. To load SpriteSheets using JSONP, specify a {{#crossLink \"LoadItem/callback:property\"}}{{/crossLink}}\n\t * as part of the {{#crossLink \"LoadItem\"}}{{/crossLink}}. Note that the {{#crossLink \"JSONLoader\"}}{{/crossLink}}\n\t * and {{#crossLink \"JSONPLoader\"}}{{/crossLink}} are higher priority loaders, so SpriteSheets <strong>must</strong>\n\t * set the {{#crossLink \"LoadItem\"}}{{/crossLink}} {{#crossLink \"LoadItem/type:property\"}}{{/crossLink}} property\n\t * to {{#crossLink \"Types/SPRITESHEET:property\"}}{{/crossLink}}.\n\t *\n\t * The {{#crossLink \"LoadItem\"}}{{/crossLink}} {{#crossLink \"LoadItem/crossOrigin:property\"}}{{/crossLink}} as well\n\t * as the {{#crossLink \"LoadQueue's\"}}{{/crossLink}} `basePath` argument and {{#crossLink \"LoadQueue/_preferXHR\"}}{{/crossLink}}\n\t * property supplied to the {{#crossLink \"LoadQueue\"}}{{/crossLink}} are passed on to the sub-manifest that loads\n\t * the SpriteSheet images.\n\t *\n\t * Note that the SpriteSheet JSON does not respect the {{#crossLink \"LoadQueue/_preferXHR:property\"}}{{/crossLink}}\n\t * property, which should instead be determined by the presence of a {{#crossLink \"LoadItem/callback:property\"}}{{/crossLink}}\n\t * property on the SpriteSheet load item. This is because the JSON loaded will have a different format depending on\n\t * if it is loaded as JSON, so just changing `preferXHR` is not enough to change how it is loaded.\n\t * @class SpriteSheetLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction SpriteSheetLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.Types.SPRITESHEET);\n\n\t\t// protected properties\n\t\t/**\n\t\t * An internal queue which loads the SpriteSheet's images.\n\t\t * @method _manifestQueue\n\t\t * @type {LoadQueue}\n\t\t * @private\n\t\t */\n\t\tthis._manifestQueue = null;\n\t}\n\n\tvar p = createjs.extend(SpriteSheetLoader, createjs.AbstractLoader);\n\tvar s = SpriteSheetLoader;\n\n\t// static properties\n\t/**\n\t * The amount of progress that the manifest itself takes up.\n\t * @property SPRITESHEET_PROGRESS\n\t * @type {number}\n\t * @default 0.25 (25%)\n\t * @private\n\t * @static\n\t */\n\ts.SPRITESHEET_PROGRESS = 0.25;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"Types/SPRITESHEET:property\"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.Types.SPRITESHEET;\n\t};\n\n\t// public methods\n\tp.destroy = function() {\n\t\tthis.AbstractLoader_destroy();\n\t\tthis._manifestQueue.close();\n\t};\n\n\t// protected methods\n\tp._createRequest = function() {\n\t\tvar callback = this._item.callback;\n\t\tif (callback != null) {\n\t\t\tthis._request = new createjs.JSONPLoader(this._item);\n\t\t} else {\n\t\t\tthis._request = new createjs.JSONLoader(this._item);\n\t\t}\n\t};\n\n\tp.handleEvent = function (event) {\n\t\tswitch (event.type) {\n\t\t\tcase \"complete\":\n\t\t\t\tthis._rawResult = event.target.getResult(true);\n\t\t\t\tthis._result = event.target.getResult();\n\t\t\t\tthis._sendProgress(s.SPRITESHEET_PROGRESS);\n\t\t\t\tthis._loadManifest(this._result);\n\t\t\t\treturn;\n\t\t\tcase \"progress\":\n\t\t\t\tevent.loaded *= s.SPRITESHEET_PROGRESS;\n\t\t\t\tthis.progress = event.loaded / event.total;\n\t\t\t\tif (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }\n\t\t\t\tthis._sendProgress(event);\n\t\t\t\treturn;\n\t\t}\n\t\tthis.AbstractLoader_handleEvent(event);\n\t};\n\n\t/**\n\t * Create and load the images once the SpriteSheet JSON has been loaded.\n\t * @method _loadManifest\n\t * @param {Object} json\n\t * @private\n\t */\n\tp._loadManifest = function (json) {\n\t\tif (json && json.images) {\n\t\t\tvar queue = this._manifestQueue = new createjs.LoadQueue(this._preferXHR, this._item.path, this._item.crossOrigin);\n\t\t\tqueue.on(\"complete\", this._handleManifestComplete, this, true);\n\t\t\tqueue.on(\"fileload\", this._handleManifestFileLoad, this);\n\t\t\tqueue.on(\"progress\", this._handleManifestProgress, this);\n\t\t\tqueue.on(\"error\", this._handleManifestError, this, true);\n\t\t\tqueue.loadManifest(json.images);\n\t\t}\n\t};\n\n\t/**\n\t * An item from the {{#crossLink \"_manifestQueue:property\"}}{{/crossLink}} has completed.\n\t * @method _handleManifestFileLoad\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._handleManifestFileLoad = function (event) {\n\t\tvar image = event.result;\n\t\tif (image != null) {\n\t\t\tvar images = this.getResult().images;\n\t\t\tvar pos = images.indexOf(event.item.src);\n\t\t\timages[pos] = image;\n\t\t}\n\t};\n\n\t/**\n\t * The images have completed loading. This triggers the {{#crossLink \"AbstractLoader/complete:event\"}}{{/crossLink}}\n\t * {{#crossLink \"Event\"}}{{/crossLink}} from the SpriteSheetLoader.\n\t * @method _handleManifestComplete\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._handleManifestComplete = function (event) {\n\t\tthis._result = new createjs.SpriteSheet(this._result);\n\t\tthis._loadedItems = this._manifestQueue.getItems(true);\n\t\tthis._sendComplete();\n\t};\n\n\t/**\n\t * The images {{#crossLink \"LoadQueue\"}}{{/crossLink}} has reported progress.\n\t * @method _handleManifestProgress\n\t * @param {ProgressEvent} event\n\t * @private\n\t */\n\tp._handleManifestProgress = function (event) {\n\t\tthis.progress = event.progress * (1 - s.SPRITESHEET_PROGRESS) + s.SPRITESHEET_PROGRESS;\n\t\tthis._sendProgress(this.progress);\n\t};\n\n\t/**\n\t * An image has reported an error.\n\t * @method _handleManifestError\n\t * @param {ErrorEvent} event\n\t * @private\n\t */\n\tp._handleManifestError = function (event) {\n\t\tvar newEvent = new createjs.Event(\"fileerror\");\n\t\tnewEvent.item = event.data;\n\t\tthis.dispatchEvent(newEvent);\n\t};\n\n\tcreatejs.SpriteSheetLoader = createjs.promote(SpriteSheetLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// SVGLoader.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for SVG files.\n\t * @class SVGLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction SVGLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.Types.SVG);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = \"data\";\n\n\t\tif (preferXHR) {\n\t\t\tthis.setTag(createjs.Elements.svg());\n\t\t} else {\n\t\t\tthis.setTag(createjs.Elements.object());\n\t\t\tthis.getTag().type = \"image/svg+xml\";\n\t\t}\n\t};\n\n\tvar p = createjs.extend(SVGLoader, createjs.AbstractLoader);\n\tvar s = SVGLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"Types/SVG:property\"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.Types.SVG;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for SVG files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {Object}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\t// mime should be image/svg+xml, but Opera requires text/xml\n\t\tvar xml = createjs.DataUtils.parseXML(loader.getResult(true));\n\t\tvar tag = loader.getTag();\n\n\t\tif (!this._preferXHR && document.body.contains(tag)) {\n\t\t\tdocument.body.removeChild(tag);\n\t\t}\n\n\t\tif (xml.documentElement != null) {\n\t\t\tvar element = xml.documentElement;\n\t\t\t// Support loading an SVG from a different domain in ID\n\t\t\tif (document.importNode) {\n\t\t\t\telement = document.importNode(element, true);\n\t\t\t}\n\t\t\ttag.appendChild(element);\n\t\t\treturn tag;\n\t\t} else { // For browsers that don't support SVG, just give them the XML. (IE 9-8)\n\t\t\treturn xml;\n\t\t}\n\t};\n\n\tcreatejs.SVGLoader = createjs.promote(SVGLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// XMLLoader.js\n//##############################################################################\n\nwindow.createjs = window.createjs || {};\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for CSS files.\n\t * @class XMLLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction XMLLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.Types.XML);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\t};\n\n\tvar p = createjs.extend(XMLLoader, createjs.AbstractLoader);\n\tvar s = XMLLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"Types/XML:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.Types.XML;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for XML files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {XMLDocument}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\treturn createjs.DataUtils.parseXML(loader.getResult(true));\n\t};\n\n\tcreatejs.XMLLoader = createjs.promote(XMLLoader, \"AbstractLoader\");\n\n}());\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ \"YuTi\")(module), __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"yLpj\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWFTWi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sYXRlc3QtY3JlYXRlanMvbGliL3ByZWxvYWRqcy9wcmVsb2FkanMuanM/NjlhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiogUHJlbG9hZEpTXG4qIFZpc2l0IGh0dHA6Ly9jcmVhdGVqcy5jb20vIGZvciBkb2N1bWVudGF0aW9uLCB1cGRhdGVzIGFuZCBleGFtcGxlcy5cbipcbiogQ29weXJpZ2h0IChjKSAyMDEwIGdza2lubmVyLmNvbSwgaW5jLlxuKlxuKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4qIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4qIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuKiBjb25kaXRpb25zOlxuKlxuKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbipcbiogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4qIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4qIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4qIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyB2ZXJzaW9uLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG53aW5kb3cuY3JlYXRlanMgPSB3aW5kb3cuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBTdGF0aWMgY2xhc3MgaG9sZGluZyBsaWJyYXJ5IHNwZWNpZmljIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHZlcnNpb24gYW5kIGJ1aWxkRGF0ZSBvZiB0aGUgbGlicmFyeS5cblx0ICogQGNsYXNzIFByZWxvYWRKU1xuXHQgKiovXG5cdHZhciBzID0gY3JlYXRlanMuUHJlbG9hZEpTID0gY3JlYXRlanMuUHJlbG9hZEpTIHx8IHt9O1xuXG5cdC8qKlxuXHQgKiBUaGUgdmVyc2lvbiBzdHJpbmcgZm9yIHRoaXMgcmVsZWFzZS5cblx0ICogQHByb3BlcnR5IHZlcnNpb25cblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdHMudmVyc2lvbiA9IC8qPXZlcnNpb24qL1wiMS4wLjBcIjsgLy8gaW5qZWN0ZWQgYnkgYnVpbGQgcHJvY2Vzc1xuXG5cdC8qKlxuXHQgKiBUaGUgYnVpbGQgZGF0ZSBmb3IgdGhpcyByZWxlYXNlIGluIFVUQyBmb3JtYXQuXG5cdCAqIEBwcm9wZXJ0eSBidWlsZERhdGVcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdHMuYnVpbGREYXRlID0gLyo9ZGF0ZSovXCJUaHUsIDE0IFNlcCAyMDE3IDE5OjQ3OjQ3IEdNVFwiOyAvLyBpbmplY3RlZCBieSBidWlsZCBwcm9jZXNzXG5cbn0pKCk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBleHRlbmQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbndpbmRvdy5jcmVhdGVqcyA9IHdpbmRvdy5jcmVhdGVqc3x8e307XG5cbi8qKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbi8qKlxuICogU2V0cyB1cCB0aGUgcHJvdG90eXBlIGNoYWluIGFuZCBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBmb3IgYSBuZXcgY2xhc3MuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIHJpZ2h0IGFmdGVyIGNyZWF0aW5nIHRoZSBjbGFzcyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBcdGZ1bmN0aW9uIE15U3ViQ2xhc3MoKSB7fVxuICogXHRjcmVhdGVqcy5leHRlbmQoTXlTdWJDbGFzcywgTXlTdXBlckNsYXNzKTtcbiAqIFx0TXlTdWJDbGFzcy5wcm90b3R5cGUuZG9Tb21ldGhpbmcgPSBmdW5jdGlvbigpIHsgfVxuICpcbiAqIFx0dmFyIGZvbyA9IG5ldyBNeVN1YkNsYXNzKCk7XG4gKiBcdGNvbnNvbGUubG9nKGZvbyBpbnN0YW5jZW9mIE15U3VwZXJDbGFzcyk7IC8vIHRydWVcbiAqIFx0Y29uc29sZS5sb2coZm9vLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9PT0gTXlTdWJDbGFzcyk7IC8vIHRydWVcbiAqXG4gKiBAbWV0aG9kIGV4dGVuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ViY2xhc3MgVGhlIHN1YmNsYXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJjbGFzcyBUaGUgc3VwZXJjbGFzcyB0byBleHRlbmQuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgc3ViY2xhc3MncyBuZXcgcHJvdG90eXBlLlxuICovXG5jcmVhdGVqcy5leHRlbmQgPSBmdW5jdGlvbihzdWJjbGFzcywgc3VwZXJjbGFzcykge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRmdW5jdGlvbiBvKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gc3ViY2xhc3M7IH1cblx0by5wcm90b3R5cGUgPSBzdXBlcmNsYXNzLnByb3RvdHlwZTtcblx0cmV0dXJuIChzdWJjbGFzcy5wcm90b3R5cGUgPSBuZXcgbygpKTtcbn07XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBwcm9tb3RlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG53aW5kb3cuY3JlYXRlanMgPSB3aW5kb3cuY3JlYXRlanN8fHt9O1xuXG4vKipcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuXG4vKipcbiAqIFByb21vdGVzIGFueSBtZXRob2RzIG9uIHRoZSBzdXBlciBjbGFzcyB0aGF0IHdlcmUgb3ZlcnJpZGRlbiwgYnkgY3JlYXRpbmcgYW4gYWxpYXMgaW4gdGhlIGZvcm1hdCBgcHJlZml4X21ldGhvZE5hbWVgLlxuICogSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSBzdXBlciBjbGFzcydzIG5hbWUgYXMgdGhlIHByZWZpeC5cbiAqIEFuIGFsaWFzIHRvIHRoZSBzdXBlciBjbGFzcydzIGNvbnN0cnVjdG9yIGlzIGFsd2F5cyBhZGRlZCBpbiB0aGUgZm9ybWF0IGBwcmVmaXhfY29uc3RydWN0b3JgLlxuICogVGhpcyBhbGxvd3MgdGhlIHN1YmNsYXNzIHRvIGNhbGwgc3VwZXIgY2xhc3MgbWV0aG9kcyB3aXRob3V0IHVzaW5nIGBmdW5jdGlvbi5jYWxsYCwgcHJvdmlkaW5nIGJldHRlciBwZXJmb3JtYW5jZS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgYE15U3ViQ2xhc3NgIGV4dGVuZHMgYE15U3VwZXJDbGFzc2AsIGFuZCBib3RoIGRlZmluZSBhIGBkcmF3YCBtZXRob2QsIHRoZW4gY2FsbGluZyBgcHJvbW90ZShNeVN1YkNsYXNzLCBcIk15U3VwZXJDbGFzc1wiKWBcbiAqIHdvdWxkIGFkZCBhIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgIG1ldGhvZCB0byBNeVN1YkNsYXNzIGFuZCBwcm9tb3RlIHRoZSBgZHJhd2AgbWV0aG9kIG9uIGBNeVN1cGVyQ2xhc3NgIHRvIHRoZVxuICogcHJvdG90eXBlIG9mIGBNeVN1YkNsYXNzYCBhcyBgTXlTdXBlckNsYXNzX2RyYXdgLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciB0aGUgY2xhc3MncyBwcm90b3R5cGUgaXMgZnVsbHkgZGVmaW5lZC5cbiAqXG4gKiBcdGZ1bmN0aW9uIENsYXNzQShuYW1lKSB7XG4gKiBcdFx0dGhpcy5uYW1lID0gbmFtZTtcbiAqIFx0fVxuICogXHRDbGFzc0EucHJvdG90eXBlLmdyZWV0ID0gZnVuY3Rpb24oKSB7XG4gKiBcdFx0cmV0dXJuIFwiSGVsbG8gXCIrdGhpcy5uYW1lO1xuICogXHR9XG4gKlxuICogXHRmdW5jdGlvbiBDbGFzc0IobmFtZSwgcHVuY3R1YXRpb24pIHtcbiAqIFx0XHR0aGlzLkNsYXNzQV9jb25zdHJ1Y3RvcihuYW1lKTtcbiAqIFx0XHR0aGlzLnB1bmN0dWF0aW9uID0gcHVuY3R1YXRpb247XG4gKiBcdH1cbiAqIFx0Y3JlYXRlanMuZXh0ZW5kKENsYXNzQiwgQ2xhc3NBKTtcbiAqIFx0Q2xhc3NCLnByb3RvdHlwZS5ncmVldCA9IGZ1bmN0aW9uKCkge1xuICogXHRcdHJldHVybiB0aGlzLkNsYXNzQV9ncmVldCgpK3RoaXMucHVuY3R1YXRpb247XG4gKiBcdH1cbiAqIFx0Y3JlYXRlanMucHJvbW90ZShDbGFzc0IsIFwiQ2xhc3NBXCIpO1xuICpcbiAqIFx0dmFyIGZvbyA9IG5ldyBDbGFzc0IoXCJXb3JsZFwiLCBcIiE/IVwiKTtcbiAqIFx0Y29uc29sZS5sb2coZm9vLmdyZWV0KCkpOyAvLyBIZWxsbyBXb3JsZCE/IVxuICpcbiAqIEBtZXRob2QgcHJvbW90ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ViY2xhc3MgVGhlIGNsYXNzIHRvIHByb21vdGUgc3VwZXIgY2xhc3MgbWV0aG9kcyBvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggVGhlIHByZWZpeCB0byBhZGQgdG8gdGhlIHByb21vdGVkIG1ldGhvZCBuYW1lcy4gVXN1YWxseSB0aGUgbmFtZSBvZiB0aGUgc3VwZXJjbGFzcy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBzdWJjbGFzcy5cbiAqL1xuY3JlYXRlanMucHJvbW90ZSA9IGZ1bmN0aW9uKHN1YmNsYXNzLCBwcmVmaXgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIHN1YlAgPSBzdWJjbGFzcy5wcm90b3R5cGUsIHN1cFAgPSAoT2JqZWN0LmdldFByb3RvdHlwZU9mJiZPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc3ViUCkpfHxzdWJQLl9fcHJvdG9fXztcblx0aWYgKHN1cFApIHtcblx0XHRzdWJQWyhwcmVmaXgrPVwiX1wiKSArIFwiY29uc3RydWN0b3JcIl0gPSBzdXBQLmNvbnN0cnVjdG9yOyAvLyBjb25zdHJ1Y3RvciBpcyBub3QgYWx3YXlzIGlubnVtZXJhYmxlXG5cdFx0Zm9yICh2YXIgbiBpbiBzdXBQKSB7XG5cdFx0XHRpZiAoc3ViUC5oYXNPd25Qcm9wZXJ0eShuKSAmJiAodHlwZW9mIHN1cFBbbl0gPT0gXCJmdW5jdGlvblwiKSkgeyBzdWJQW3ByZWZpeCArIG5dID0gc3VwUFtuXTsgfVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gc3ViY2xhc3M7XG59O1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gZGVwcmVjYXRlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG53aW5kb3cuY3JlYXRlanMgPSB3aW5kb3cuY3JlYXRlanN8fHt9O1xuXG4vKipcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuXG4vKipcbiAqIFdyYXBzIGRlcHJlY2F0ZWQgbWV0aG9kcyBzbyB0aGV5IHN0aWxsIGJlIHVzZWQsIGJ1dCB0aHJvdyB3YXJuaW5ncyB0byBkZXZlbG9wZXJzLlxuICpcbiAqXHRvYmouZGVwcmVjYXRlZE1ldGhvZCA9IGNyZWF0ZWpzLmRlcHJlY2F0ZShcIk9sZCBNZXRob2QgTmFtZVwiLCBvYmouX2ZhbGxiYWNrTWV0aG9kKTtcbiAqXG4gKiBUaGUgcmVjb21tZW5kZWQgYXBwcm9hY2ggZm9yIGRlcHJlY2F0ZWQgcHJvcGVydGllcyBpczpcbiAqXG4gKlx0dHJ5IHtcbiAqXHRcdE9ialx0ZWN0LmRlZmluZVByb3BlcnRpZXMob2JqZWN0LCB7XG4gKlx0XHRcdHJlYWR5T25seVByb3A6IHsgZ2V0OiBjcmVhdGVqcy5kZXByZWNhdGUoXCJyZWFkT25seVByb3BcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmFsdGVybmF0ZVByb3A7IH0pIH0sXG4gKlx0XHRcdHJlYWRXcml0ZVByb3A6IHtcbiAqXHRcdFx0XHRnZXQ6IGNyZWF0ZWpzLmRlcHJlY2F0ZShcInJlYWRPbmx5UHJvcFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuYWx0ZXJuYXRlUHJvcDsgfSksXG4gKlx0XHRcdFx0c2V0OiBjcmVhdGVqcy5kZXByZWNhdGUoXCJyZWFkT25seVByb3BcIiwgZnVuY3Rpb24odmFsKSB7IHRoaXMuYWx0ZXJuYXRlUHJvcCA9IHZhbDsgfSlcbiAqXHRcdH0pO1xuICpcdH0gY2F0Y2ggKGUpIHt9XG4gKlxuICogQG1ldGhvZCBkZXByZWNhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmYWxsYmFja01ldGhvZD1udWxsXSBBIG1ldGhvZCB0byBjYWxsIHdoZW4gdGhlIGRlcHJlY2F0ZWQgbWV0aG9kIGlzIHVzZWQuIFNlZSB0aGUgZXhhbXBsZSBmb3IgaG93XG4gKiBAcGFyYW0ge1N0cmluZ30gW25hbWU9bnVsbF0gVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCBvciBwcm9wZXJ0eSB0byBkaXNwbGF5IGluIHRoZSBjb25zb2xlIHdhcm5pbmcuXG4gKiB0byBkZXByZWNhdGUgcHJvcGVydGllcy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBJZiBhIGZhbGxiYWNrTWV0aG9kIGlzIHN1cHBsaWVkLCByZXR1cm5zIGEgY2xvc3VyZSB0aGF0IHdpbGwgY2FsbCB0aGUgZmFsbGJhY2sgbWV0aG9kIGFmdGVyXG4gKiBsb2dnaW5nIHRoZSB3YXJuaW5nIGluIHRoZSBjb25zb2xlLlxuICovXG5jcmVhdGVqcy5kZXByZWNhdGUgPSBmdW5jdGlvbihmYWxsYmFja01ldGhvZCwgbmFtZSkge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtc2cgPSBcIkRlcHJlY2F0ZWQgcHJvcGVydHkgb3IgbWV0aG9kICdcIituYW1lK1wiJy4gU2VlIGRvY3MgZm9yIGluZm8uXCI7XG5cdFx0Y29uc29sZSAmJiAoY29uc29sZS53YXJuID8gY29uc29sZS53YXJuKG1zZykgOiBjb25zb2xlLmxvZyhtc2cpKTtcblx0XHRyZXR1cm4gZmFsbGJhY2tNZXRob2QgJiYgZmFsbGJhY2tNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fVxufTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIHByb3h5LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG53aW5kb3cuY3JlYXRlanMgPSB3aW5kb3cuY3JlYXRlanN8fHt9O1xuXG4vKipcbiAqIFZhcmlvdXMgdXRpbGl0aWVzIHRoYXQgdGhlIENyZWF0ZUpTIFN1aXRlIHVzZXMuIFV0aWxpdGllcyBhcmUgY3JlYXRlZCBhcyBzZXBhcmF0ZSBmaWxlcywgYW5kIHdpbGwgYmUgYXZhaWxhYmxlIG9uIHRoZVxuICogY3JlYXRlanMgbmFtZXNwYWNlIGRpcmVjdGx5LlxuICpcbiAqIDxoND5FeGFtcGxlPC9oND5cbiAqXG4gKiAgICAgIG15T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgY3JlYXRlanMucHJveHkobXlNZXRob2QsIHNjb3BlKSk7XG4gKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICogQG1haW4gVXRpbGl0eSBNZXRob2RzXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogQSBmdW5jdGlvbiBwcm94eSBmb3IgbWV0aG9kcy4gQnkgZGVmYXVsdCwgSmF2YVNjcmlwdCBtZXRob2RzIGRvIG5vdCBtYWludGFpbiBzY29wZSwgc28gcGFzc2luZyBhIG1ldGhvZCBhcyBhXG5cdCAqIGNhbGxiYWNrIHdpbGwgcmVzdWx0IGluIHRoZSBtZXRob2QgZ2V0dGluZyBjYWxsZWQgaW4gdGhlIHNjb3BlIG9mIHRoZSBjYWxsZXIuIFVzaW5nIGEgcHJveHkgZW5zdXJlcyB0aGF0IHRoZVxuXHQgKiBtZXRob2QgZ2V0cyBjYWxsZWQgaW4gdGhlIGNvcnJlY3Qgc2NvcGUuXG5cdCAqXG5cdCAqIEFkZGl0aW9uYWwgYXJndW1lbnRzIGNhbiBiZSBwYXNzZWQgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGZ1bmN0aW9uIHdoZW4gaXQgaXMgY2FsbGVkLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgbXlPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcImV2ZW50XCIsIGNyZWF0ZWpzLnByb3h5KG15SGFuZGxlciwgdGhpcywgYXJnMSwgYXJnMikpO1xuXHQgKlxuXHQgKiAgICAgIGZ1bmN0aW9uIG15SGFuZGxlcihhcmcxLCBhcmcyKSB7XG5cdCAqICAgICAgICAgICAvLyBUaGlzIGdldHMgY2FsbGVkIHdoZW4gbXlPYmplY3QubXlDYWxsYmFjayBpcyBleGVjdXRlZC5cblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBtZXRob2QgcHJveHlcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIFRoZSBmdW5jdGlvbiB0byBjYWxsXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSBUaGUgc2NvcGUgdG8gY2FsbCB0aGUgbWV0aG9kIG5hbWUgb25cblx0ICogQHBhcmFtIHttaXhlZH0gW2FyZ10gKiBBcmd1bWVudHMgdGhhdCBhcmUgYXBwZW5kZWQgdG8gdGhlIGNhbGxiYWNrIGZvciBhZGRpdGlvbmFsIHBhcmFtcy5cblx0ICogQHB1YmxpY1xuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRjcmVhdGVqcy5wcm94eSA9IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlKSB7XG5cdFx0dmFyIGFBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIG1ldGhvZC5hcHBseShzY29wZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKS5jb25jYXQoYUFyZ3MpKTtcblx0XHR9O1xuXHR9XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBpbmRleE9mLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG53aW5kb3cuY3JlYXRlanMgPSB3aW5kb3cuY3JlYXRlanN8fHt9O1xuXG4vKipcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuXG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGEgc3BlY2lmaWVkIHZhbHVlIHNlYXJjaEVsZW1lbnQgaW4gdGhlIHBhc3NlZCBpbiBhcnJheSwgYW5kIHJldHVybnMgdGhlIGluZGV4IG9mXG4gKiB0aGF0IHZhbHVlLiAgUmV0dXJucyAtMSBpZiB2YWx1ZSBpcyBub3QgZm91bmQuXG4gKlxuICogICAgICB2YXIgaSA9IGNyZWF0ZWpzLmluZGV4T2YobXlBcnJheSwgbXlFbGVtZW50VG9GaW5kKTtcbiAqXG4gKiBAbWV0aG9kIGluZGV4T2ZcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIHNlYXJjaCBmb3Igc2VhcmNoRWxlbWVudFxuICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgRWxlbWVudCB0byBmaW5kIGluIGFycmF5LlxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgZmlyc3QgaW5kZXggb2Ygc2VhcmNoRWxlbWVudCBpbiBhcnJheS5cbiAqL1xuY3JlYXRlanMuaW5kZXhPZiA9IGZ1bmN0aW9uIChhcnJheSwgc2VhcmNoRWxlbWVudCl7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGZvciAodmFyIGkgPSAwLGw9YXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0aWYgKHNlYXJjaEVsZW1lbnQgPT09IGFycmF5W2ldKSB7XG5cdFx0XHRyZXR1cm4gaTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIC0xO1xufTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEV2ZW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG53aW5kb3cuY3JlYXRlanMgPSB3aW5kb3cuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIENvbnRhaW5zIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgc2hhcmVkIGJ5IGFsbCBldmVudHMgZm9yIHVzZSB3aXRoXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogXG5cdCAqIE5vdGUgdGhhdCBFdmVudCBvYmplY3RzIGFyZSBvZnRlbiByZXVzZWQsIHNvIHlvdSBzaG91bGQgbmV2ZXJcblx0ICogcmVseSBvbiBhbiBldmVudCBvYmplY3QncyBzdGF0ZSBvdXRzaWRlIG9mIHRoZSBjYWxsIHN0YWNrIGl0IHdhcyByZWNlaXZlZCBpbi5cblx0ICogQGNsYXNzIEV2ZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGJ1YmJsZXMgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50IHdpbGwgYnViYmxlIHRocm91Z2ggdGhlIGRpc3BsYXkgbGlzdC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBjYW5jZWxhYmxlIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiB0aGlzIGV2ZW50IGNhbiBiZSBjYW5jZWxsZWQuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIEV2ZW50KHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUpIHtcblx0XHRcblx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSB0eXBlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICoqL1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBvYmplY3QgdGhhdCBnZW5lcmF0ZWQgYW4gZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IHRhcmdldFxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMudGFyZ2V0ID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgdGFyZ2V0IHRoYXQgYSBidWJibGluZyBldmVudCBpcyBiZWluZyBkaXNwYXRjaGVkIGZyb20uIEZvciBub24tYnViYmxpbmcgZXZlbnRzLCB0aGlzIHdpbGxcblx0XHQgKiBhbHdheXMgYmUgdGhlIHNhbWUgYXMgdGFyZ2V0LiBGb3IgZXhhbXBsZSwgaWYgY2hpbGRPYmoucGFyZW50ID0gcGFyZW50T2JqLCBhbmQgYSBidWJibGluZyBldmVudFxuXHRcdCAqIGlzIGdlbmVyYXRlZCBmcm9tIGNoaWxkT2JqLCB0aGVuIGEgbGlzdGVuZXIgb24gcGFyZW50T2JqIHdvdWxkIHJlY2VpdmUgdGhlIGV2ZW50IHdpdGhcblx0XHQgKiB0YXJnZXQ9Y2hpbGRPYmogKHRoZSBvcmlnaW5hbCB0YXJnZXQpIGFuZCBjdXJyZW50VGFyZ2V0PXBhcmVudE9iaiAod2hlcmUgdGhlIGxpc3RlbmVyIHdhcyBhZGRlZCkuXG5cdFx0ICogQHByb3BlcnR5IGN1cnJlbnRUYXJnZXRcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBGb3IgYnViYmxpbmcgZXZlbnRzLCB0aGlzIGluZGljYXRlcyB0aGUgY3VycmVudCBldmVudCBwaGFzZTo8T0w+XG5cdFx0ICogXHQ8TEk+IGNhcHR1cmUgcGhhc2U6IHN0YXJ0aW5nIGZyb20gdGhlIHRvcCBwYXJlbnQgdG8gdGhlIHRhcmdldDwvTEk+XG5cdFx0ICogXHQ8TEk+IGF0IHRhcmdldCBwaGFzZTogY3VycmVudGx5IGJlaW5nIGRpc3BhdGNoZWQgZnJvbSB0aGUgdGFyZ2V0PC9MST5cblx0XHQgKiBcdDxMST4gYnViYmxpbmcgcGhhc2U6IGZyb20gdGhlIHRhcmdldCB0byB0aGUgdG9wIHBhcmVudDwvTEk+XG5cdFx0ICogPC9PTD5cblx0XHQgKiBAcHJvcGVydHkgZXZlbnRQaGFzZVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuZXZlbnRQaGFzZSA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBldmVudCB3aWxsIGJ1YmJsZSB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuXG5cdFx0ICogQHByb3BlcnR5IGJ1YmJsZXNcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuYnViYmxlcyA9ICEhYnViYmxlcztcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mIHRoaXMgZXZlbnQgY2FuIGJlIGNhbmNlbGxlZCB2aWFcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudC9wcmV2ZW50RGVmYXVsdFwifX17ey9jcm9zc0xpbmt9fS4gVGhpcyBpcyBzZXQgdmlhIHRoZSBFdmVudCBjb25zdHJ1Y3Rvci5cblx0XHQgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5jYW5jZWxhYmxlID0gISFjYW5jZWxhYmxlO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgZXBvY2ggdGltZSBhdCB3aGljaCB0aGlzIGV2ZW50IHdhcyBjcmVhdGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSB0aW1lU3RhbXBcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLnRpbWVTdGFtcCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB7eyNjcm9zc0xpbmsgXCJFdmVudC9wcmV2ZW50RGVmYXVsdFwifX17ey9jcm9zc0xpbmt9fSBoYXMgYmVlbiBjYWxsZWRcblx0XHQgKiBvbiB0aGlzIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBkZWZhdWx0UHJldmVudGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHt7I2Nyb3NzTGluayBcIkV2ZW50L3N0b3BQcm9wYWdhdGlvblwifX17ey9jcm9zc0xpbmt9fSBvclxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50L3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwifX17ey9jcm9zc0xpbmt9fSBoYXMgYmVlbiBjYWxsZWQgb24gdGhpcyBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgcHJvcGFnYXRpb25TdG9wcGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYge3sjY3Jvc3NMaW5rIFwiRXZlbnQvc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXCJ9fXt7L2Nyb3NzTGlua319IGhhcyBiZWVuIGNhbGxlZFxuXHRcdCAqIG9uIHRoaXMgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IGltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcmVtb3ZlXCJ9fXt7L2Nyb3NzTGlua319IGhhcyBiZWVuIGNhbGxlZCBvbiB0aGlzIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSByZW1vdmVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLnJlbW92ZWQgPSBmYWxzZTtcblx0fVxuXHR2YXIgcCA9IEV2ZW50LnByb3RvdHlwZTtcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBTZXRzIHt7I2Nyb3NzTGluayBcIkV2ZW50L2RlZmF1bHRQcmV2ZW50ZWRcIn19e3svY3Jvc3NMaW5rfX0gdG8gdHJ1ZSBpZiB0aGUgZXZlbnQgaXMgY2FuY2VsYWJsZS5cblx0ICogTWlycm9ycyB0aGUgRE9NIGxldmVsIDIgZXZlbnQgc3RhbmRhcmQuIEluIGdlbmVyYWwsIGNhbmNlbGFibGUgZXZlbnRzIHRoYXQgaGF2ZSBgcHJldmVudERlZmF1bHQoKWAgY2FsbGVkIHdpbGxcblx0ICogY2FuY2VsIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50LlxuXHQgKiBAbWV0aG9kIHByZXZlbnREZWZhdWx0XG5cdCAqKi9cblx0cC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRoaXMuY2FuY2VsYWJsZSYmdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB7eyNjcm9zc0xpbmsgXCJFdmVudC9wcm9wYWdhdGlvblN0b3BwZWRcIn19e3svY3Jvc3NMaW5rfX0gdG8gdHJ1ZS5cblx0ICogTWlycm9ycyB0aGUgRE9NIGV2ZW50IHN0YW5kYXJkLlxuXHQgKiBAbWV0aG9kIHN0b3BQcm9wYWdhdGlvblxuXHQgKiovXG5cdHAuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHt7I2Nyb3NzTGluayBcIkV2ZW50L3Byb3BhZ2F0aW9uU3RvcHBlZFwifX17ey9jcm9zc0xpbmt9fSBhbmRcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkXCJ9fXt7L2Nyb3NzTGlua319IHRvIHRydWUuXG5cdCAqIE1pcnJvcnMgdGhlIERPTSBldmVudCBzdGFuZGFyZC5cblx0ICogQG1ldGhvZCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cblx0ICoqL1xuXHRwLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhdXNlcyB0aGUgYWN0aXZlIGxpc3RlbmVyIHRvIGJlIHJlbW92ZWQgdmlhIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcblx0ICogXG5cdCAqIFx0XHRteUJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZ0KSB7XG5cdCAqIFx0XHRcdC8vIGRvIHN0dWZmLi4uXG5cdCAqIFx0XHRcdGV2dC5yZW1vdmUoKTsgLy8gcmVtb3ZlcyB0aGlzIGxpc3RlbmVyLlxuXHQgKiBcdFx0fSk7XG5cdCAqIFxuXHQgKiBAbWV0aG9kIHJlbW92ZVxuXHQgKiovXG5cdHAucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZW1vdmVkID0gdHJ1ZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIEV2ZW50IGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge0V2ZW50fSBhIGNsb25lIG9mIHRoZSBFdmVudCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBFdmVudCh0aGlzLnR5cGUsIHRoaXMuYnViYmxlcywgdGhpcy5jYW5jZWxhYmxlKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBQcm92aWRlcyBhIGNoYWluYWJsZSBzaG9ydGN1dCBtZXRob2QgZm9yIHNldHRpbmcgYSBudW1iZXIgb2YgcHJvcGVydGllcyBvbiB0aGUgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2Qgc2V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBBIGdlbmVyaWMgb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBjb3B5IHRvIHRoZSBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7RXZlbnR9IFJldHVybnMgdGhlIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLnNldCA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykgeyB0aGlzW25dID0gcHJvcHNbbl07IH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0V2ZW50ICh0eXBlPVwiK3RoaXMudHlwZStcIildXCI7XG5cdH07XG5cblx0Y3JlYXRlanMuRXZlbnQgPSBFdmVudDtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBFcnJvckV2ZW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG53aW5kb3cuY3JlYXRlanMgPSB3aW5kb3cuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyYWwgZXJyb3Ige3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0sIHRoYXQgZGVzY3JpYmVzIGFuIGVycm9yIHRoYXQgb2NjdXJyZWQsIGFzIHdlbGwgYXMgYW55IGRldGFpbHMuXG5cdCAqIEBjbGFzcyBFcnJvckV2ZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbdGl0bGVdIFRoZSBlcnJvciB0aXRsZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIFRoZSBlcnJvciBkZXNjcmlwdGlvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIEFkZGl0aW9uYWwgZXJyb3IgZGF0YVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEVycm9yRXZlbnQodGl0bGUsIG1lc3NhZ2UsIGRhdGEpIHtcblx0XHR0aGlzLkV2ZW50X2NvbnN0cnVjdG9yKFwiZXJyb3JcIik7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgc2hvcnQgZXJyb3IgdGl0bGUsIHdoaWNoIGluZGljYXRlcyB0aGUgdHlwZSBvZiBlcnJvciB0aGF0IG9jY3VycmVkLlxuXHRcdCAqIEBwcm9wZXJ0eSB0aXRsZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdHRoaXMudGl0bGUgPSB0aXRsZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB2ZXJib3NlIGVycm9yIG1lc3NhZ2UsIGNvbnRhaW5pbmcgZGV0YWlscyBhYm91dCB0aGUgZXJyb3IuXG5cdFx0ICogQHByb3BlcnR5IG1lc3NhZ2Vcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXG5cdFx0LyoqXG5cdFx0ICogQWRkaXRpb25hbCBkYXRhIGF0dGFjaGVkIHRvIGFuIGVycm9yLlxuXHRcdCAqIEBwcm9wZXJ0eSBkYXRhXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLmRhdGEgPSBkYXRhO1xuXHR9XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoRXJyb3JFdmVudCwgY3JlYXRlanMuRXZlbnQpO1xuXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQodGhpcy50aXRsZSwgdGhpcy5tZXNzYWdlLCB0aGlzLmRhdGEpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkVycm9yRXZlbnQgPSBjcmVhdGVqcy5wcm9tb3RlKEVycm9yRXZlbnQsIFwiRXZlbnRcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBFdmVudERpc3BhdGNoZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbndpbmRvdy5jcmVhdGVqcyA9IHdpbmRvdy5jcmVhdGVqc3x8e307XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuLy8gY29uc3RydWN0b3I6XHJcblx0LyoqXHJcblx0ICogRXZlbnREaXNwYXRjaGVyIHByb3ZpZGVzIG1ldGhvZHMgZm9yIG1hbmFnaW5nIHF1ZXVlcyBvZiBldmVudCBsaXN0ZW5lcnMgYW5kIGRpc3BhdGNoaW5nIGV2ZW50cy5cclxuXHQgKlxyXG5cdCAqIFlvdSBjYW4gZWl0aGVyIGV4dGVuZCBFdmVudERpc3BhdGNoZXIgb3IgbWl4IGl0cyBtZXRob2RzIGludG8gYW4gZXhpc3RpbmcgcHJvdG90eXBlIG9yIGluc3RhbmNlIGJ5IHVzaW5nIHRoZVxyXG5cdCAqIEV2ZW50RGlzcGF0Y2hlciB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvaW5pdGlhbGl6ZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXHJcblx0ICogXHJcblx0ICogVG9nZXRoZXIgd2l0aCB0aGUgQ3JlYXRlSlMgRXZlbnQgY2xhc3MsIEV2ZW50RGlzcGF0Y2hlciBwcm92aWRlcyBhbiBleHRlbmRlZCBldmVudCBtb2RlbCB0aGF0IGlzIGJhc2VkIG9uIHRoZVxyXG5cdCAqIERPTSBMZXZlbCAyIGV2ZW50IG1vZGVsLCBpbmNsdWRpbmcgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciwgYW5kIGRpc3BhdGNoRXZlbnQuIEl0IHN1cHBvcnRzXHJcblx0ICogYnViYmxpbmcgLyBjYXB0dXJlLCBwcmV2ZW50RGVmYXVsdCwgc3RvcFByb3BhZ2F0aW9uLCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24sIGFuZCBoYW5kbGVFdmVudC5cclxuXHQgKiBcclxuXHQgKiBFdmVudERpc3BhdGNoZXIgYWxzbyBleHBvc2VzIGEge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL29uXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCwgd2hpY2ggbWFrZXMgaXQgZWFzaWVyXHJcblx0ICogdG8gY3JlYXRlIHNjb3BlZCBsaXN0ZW5lcnMsIGxpc3RlbmVycyB0aGF0IG9ubHkgcnVuIG9uY2UsIGFuZCBsaXN0ZW5lcnMgd2l0aCBhc3NvY2lhdGVkIGFyYml0cmFyeSBkYXRhLiBUaGUgXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL29mZlwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgaXMgbWVyZWx5IGFuIGFsaWFzIHRvXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL3JlbW92ZUV2ZW50TGlzdGVuZXJcIn19e3svY3Jvc3NMaW5rfX0uXHJcblx0ICogXHJcblx0ICogQW5vdGhlciBhZGRpdGlvbiB0byB0aGUgRE9NIExldmVsIDIgbW9kZWwgaXMgdGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9yZW1vdmVBbGxFdmVudExpc3RlbmVyc1wifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIG1ldGhvZCwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbGlzdGVuZXJzIGZvciBhbGwgZXZlbnRzLCBvciBsaXN0ZW5lcnMgZm9yIGEgc3BlY2lmaWMgZXZlbnQuIFRoZSBFdmVudCBvYmplY3QgYWxzbyBcclxuXHQgKiBpbmNsdWRlcyBhIHt7I2Nyb3NzTGluayBcIkV2ZW50L3JlbW92ZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2Qgd2hpY2ggcmVtb3ZlcyB0aGUgYWN0aXZlIGxpc3RlbmVyLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqIEFkZCBFdmVudERpc3BhdGNoZXIgY2FwYWJpbGl0aWVzIHRvIHRoZSBcIk15Q2xhc3NcIiBjbGFzcy5cclxuXHQgKlxyXG5cdCAqICAgICAgRXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUoTXlDbGFzcy5wcm90b3R5cGUpO1xyXG5cdCAqXHJcblx0ICogQWRkIGFuIGV2ZW50IChzZWUge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL2FkZEV2ZW50TGlzdGVuZXJcIn19e3svY3Jvc3NMaW5rfX0pLlxyXG5cdCAqXHJcblx0ICogICAgICBpbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKFwiZXZlbnROYW1lXCIsIGhhbmRsZXJNZXRob2QpO1xyXG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlck1ldGhvZChldmVudCkge1xyXG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LnRhcmdldCArIFwiIFdhcyBDbGlja2VkXCIpO1xyXG5cdCAqICAgICAgfVxyXG5cdCAqXHJcblx0ICogPGI+TWFpbnRhaW5pbmcgcHJvcGVyIHNjb3BlPC9iPjxiciAvPlxyXG5cdCAqIFNjb3BlIChpZS4gXCJ0aGlzXCIpIGNhbiBiZSBiZSBhIGNoYWxsZW5nZSB3aXRoIGV2ZW50cy4gVXNpbmcgdGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9vblwifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIG1ldGhvZCB0byBzdWJzY3JpYmUgdG8gZXZlbnRzIHNpbXBsaWZpZXMgdGhpcy5cclxuXHQgKlxyXG5cdCAqICAgICAgaW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0ICogICAgICAgICAgY29uc29sZS5sb2coaW5zdGFuY2UgPT0gdGhpcyk7IC8vIGZhbHNlLCBzY29wZSBpcyBhbWJpZ3VvdXMuXHJcblx0ICogICAgICB9KTtcclxuXHQgKiAgICAgIFxyXG5cdCAqICAgICAgaW5zdGFuY2Uub24oXCJjbGlja1wiLCBmdW5jdGlvbihldmVudCkge1xyXG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKGluc3RhbmNlID09IHRoaXMpOyAvLyB0cnVlLCBcIm9uXCIgdXNlcyBkaXNwYXRjaGVyIHNjb3BlIGJ5IGRlZmF1bHQuXHJcblx0ICogICAgICB9KTtcclxuXHQgKiBcclxuXHQgKiBJZiB5b3Ugd2FudCB0byB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpbnN0ZWFkLCB5b3UgbWF5IHdhbnQgdG8gdXNlIGZ1bmN0aW9uLmJpbmQoKSBvciBhIHNpbWlsYXIgcHJveHkgdG8gbWFuYWdlXHJcblx0ICogc2NvcGUuXHJcblx0ICpcclxuXHQgKiA8Yj5Ccm93c2VyIHN1cHBvcnQ8L2I+XHJcblx0ICogVGhlIGV2ZW50IG1vZGVsIGluIENyZWF0ZUpTIGNhbiBiZSB1c2VkIHNlcGFyYXRlbHkgZnJvbSB0aGUgc3VpdGUgaW4gYW55IHByb2plY3QsIGhvd2V2ZXIgdGhlIGluaGVyaXRhbmNlIG1vZGVsXHJcblx0ICogcmVxdWlyZXMgbW9kZXJuIGJyb3dzZXJzIChJRTkrKS5cclxuXHQgKiAgICAgIFxyXG5cdCAqXHJcblx0ICogQGNsYXNzIEV2ZW50RGlzcGF0Y2hlclxyXG5cdCAqIEBjb25zdHJ1Y3RvclxyXG5cdCAqKi9cclxuXHRmdW5jdGlvbiBFdmVudERpc3BhdGNoZXIoKSB7XHJcblx0XHJcblx0XHJcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAcHJvcGVydHkgX2xpc3RlbmVyc1xyXG5cdFx0ICogQHR5cGUgT2JqZWN0XHJcblx0XHQgKiovXHJcblx0XHR0aGlzLl9saXN0ZW5lcnMgPSBudWxsO1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIEBwcm90ZWN0ZWRcclxuXHRcdCAqIEBwcm9wZXJ0eSBfY2FwdHVyZUxpc3RlbmVyc1xyXG5cdFx0ICogQHR5cGUgT2JqZWN0XHJcblx0XHQgKiovXHJcblx0XHR0aGlzLl9jYXB0dXJlTGlzdGVuZXJzID0gbnVsbDtcclxuXHR9XHJcblx0dmFyIHAgPSBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlO1xyXG5cclxuLy8gc3RhdGljIHB1YmxpYyBtZXRob2RzOlxyXG5cdC8qKlxyXG5cdCAqIFN0YXRpYyBpbml0aWFsaXplciB0byBtaXggRXZlbnREaXNwYXRjaGVyIG1ldGhvZHMgaW50byBhIHRhcmdldCBvYmplY3Qgb3IgcHJvdG90eXBlLlxyXG5cdCAqIFxyXG5cdCAqIFx0XHRFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShNeUNsYXNzLnByb3RvdHlwZSk7IC8vIGFkZCB0byB0aGUgcHJvdG90eXBlIG9mIHRoZSBjbGFzc1xyXG5cdCAqIFx0XHRFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShteU9iamVjdCk7IC8vIGFkZCB0byBhIHNwZWNpZmljIGluc3RhbmNlXHJcblx0ICogXHJcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXHJcblx0ICogQHN0YXRpY1xyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QgdG8gaW5qZWN0IEV2ZW50RGlzcGF0Y2hlciBtZXRob2RzIGludG8uIFRoaXMgY2FuIGJlIGFuIGluc3RhbmNlIG9yIGFcclxuXHQgKiBwcm90b3R5cGUuXHJcblx0ICoqL1xyXG5cdEV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplID0gZnVuY3Rpb24odGFyZ2V0KSB7XHJcblx0XHR0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lciA9IHAuYWRkRXZlbnRMaXN0ZW5lcjtcclxuXHRcdHRhcmdldC5vbiA9IHAub247XHJcblx0XHR0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHRhcmdldC5vZmYgPSAgcC5yZW1vdmVFdmVudExpc3RlbmVyO1xyXG5cdFx0dGFyZ2V0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gcC5yZW1vdmVBbGxFdmVudExpc3RlbmVycztcclxuXHRcdHRhcmdldC5oYXNFdmVudExpc3RlbmVyID0gcC5oYXNFdmVudExpc3RlbmVyO1xyXG5cdFx0dGFyZ2V0LmRpc3BhdGNoRXZlbnQgPSBwLmRpc3BhdGNoRXZlbnQ7XHJcblx0XHR0YXJnZXQuX2Rpc3BhdGNoRXZlbnQgPSBwLl9kaXNwYXRjaEV2ZW50O1xyXG5cdFx0dGFyZ2V0LndpbGxUcmlnZ2VyID0gcC53aWxsVHJpZ2dlcjtcclxuXHR9O1xyXG5cdFxyXG5cclxuLy8gcHVibGljIG1ldGhvZHM6XHJcblx0LyoqXHJcblx0ICogQWRkcyB0aGUgc3BlY2lmaWVkIGV2ZW50IGxpc3RlbmVyLiBOb3RlIHRoYXQgYWRkaW5nIG11bHRpcGxlIGxpc3RlbmVycyB0byB0aGUgc2FtZSBmdW5jdGlvbiB3aWxsIHJlc3VsdCBpblxyXG5cdCAqIG11bHRpcGxlIGNhbGxiYWNrcyBnZXR0aW5nIGZpcmVkLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGljayk7XHJcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xyXG5cdCAqICAgICAgICAgLy8gQ2xpY2sgaGFwcGVuZWQuXHJcblx0ICogICAgICB9XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXJcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb24gfCBPYmplY3R9IGxpc3RlbmVyIEFuIG9iamVjdCB3aXRoIGEgaGFuZGxlRXZlbnQgbWV0aG9kLCBvciBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlblxyXG5cdCAqIHRoZSBldmVudCBpcyBkaXNwYXRjaGVkLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdIEZvciBldmVudHMgdGhhdCBidWJibGUsIGluZGljYXRlcyB3aGV0aGVyIHRvIGxpc3RlbiBmb3IgdGhlIGV2ZW50IGluIHRoZSBjYXB0dXJlIG9yIGJ1YmJsaW5nL3RhcmdldCBwaGFzZS5cclxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbiB8IE9iamVjdH0gUmV0dXJucyB0aGUgbGlzdGVuZXIgZm9yIGNoYWluaW5nIG9yIGFzc2lnbm1lbnQuXHJcblx0ICoqL1xyXG5cdHAuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzO1xyXG5cdFx0aWYgKHVzZUNhcHR1cmUpIHtcclxuXHRcdFx0bGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnN8fHt9O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzfHx7fTtcclxuXHRcdH1cclxuXHRcdHZhciBhcnIgPSBsaXN0ZW5lcnNbdHlwZV07XHJcblx0XHRpZiAoYXJyKSB7IHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7IH1cclxuXHRcdGFyciA9IGxpc3RlbmVyc1t0eXBlXTsgLy8gcmVtb3ZlIG1heSBoYXZlIGRlbGV0ZWQgdGhlIGFycmF5XHJcblx0XHRpZiAoIWFycikgeyBsaXN0ZW5lcnNbdHlwZV0gPSBbbGlzdGVuZXJdOyAgfVxyXG5cdFx0ZWxzZSB7IGFyci5wdXNoKGxpc3RlbmVyKTsgfVxyXG5cdFx0cmV0dXJuIGxpc3RlbmVyO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogQSBzaG9ydGN1dCBtZXRob2QgZm9yIHVzaW5nIGFkZEV2ZW50TGlzdGVuZXIgdGhhdCBtYWtlcyBpdCBlYXNpZXIgdG8gc3BlY2lmeSBhbiBleGVjdXRpb24gc2NvcGUsIGhhdmUgYSBsaXN0ZW5lclxyXG5cdCAqIG9ubHkgcnVuIG9uY2UsIGFzc29jaWF0ZSBhcmJpdHJhcnkgZGF0YSB3aXRoIHRoZSBsaXN0ZW5lciwgYW5kIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblx0ICogXHJcblx0ICogVGhpcyBtZXRob2Qgd29ya3MgYnkgY3JlYXRpbmcgYW4gYW5vbnltb3VzIHdyYXBwZXIgZnVuY3Rpb24gYW5kIHN1YnNjcmliaW5nIGl0IHdpdGggYWRkRXZlbnRMaXN0ZW5lci5cclxuXHQgKiBUaGUgd3JhcHBlciBmdW5jdGlvbiBpcyByZXR1cm5lZCBmb3IgdXNlIHdpdGggYHJlbW92ZUV2ZW50TGlzdGVuZXJgIChvciBgb2ZmYCkuXHJcblx0ICogXHJcblx0ICogPGI+SU1QT1JUQU5UOjwvYj4gVG8gcmVtb3ZlIGEgbGlzdGVuZXIgYWRkZWQgd2l0aCBgb25gLCB5b3UgbXVzdCBwYXNzIGluIHRoZSByZXR1cm5lZCB3cmFwcGVyIGZ1bmN0aW9uIGFzIHRoZSBsaXN0ZW5lciwgb3IgdXNlXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcmVtb3ZlXCJ9fXt7L2Nyb3NzTGlua319LiBMaWtld2lzZSwgZWFjaCB0aW1lIHlvdSBjYWxsIGBvbmAgYSBORVcgd3JhcHBlciBmdW5jdGlvbiBpcyBzdWJzY3JpYmVkLCBzbyBtdWx0aXBsZSBjYWxsc1xyXG5cdCAqIHRvIGBvbmAgd2l0aCB0aGUgc2FtZSBwYXJhbXMgd2lsbCBjcmVhdGUgbXVsdGlwbGUgbGlzdGVuZXJzLlxyXG5cdCAqIFxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKiBcclxuXHQgKiBcdFx0dmFyIGxpc3RlbmVyID0gbXlCdG4ub24oXCJjbGlja1wiLCBoYW5kbGVDbGljaywgbnVsbCwgZmFsc2UsIHtjb3VudDozfSk7XHJcblx0ICogXHRcdGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2dCwgZGF0YSkge1xyXG5cdCAqIFx0XHRcdGRhdGEuY291bnQgLT0gMTtcclxuXHQgKiBcdFx0XHRjb25zb2xlLmxvZyh0aGlzID09IG15QnRuKTsgLy8gdHJ1ZSAtIHNjb3BlIGRlZmF1bHRzIHRvIHRoZSBkaXNwYXRjaGVyXHJcblx0ICogXHRcdFx0aWYgKGRhdGEuY291bnQgPT0gMCkge1xyXG5cdCAqIFx0XHRcdFx0YWxlcnQoXCJjbGlja2VkIDMgdGltZXMhXCIpO1xyXG5cdCAqIFx0XHRcdFx0bXlCdG4ub2ZmKFwiY2xpY2tcIiwgbGlzdGVuZXIpO1xyXG5cdCAqIFx0XHRcdFx0Ly8gYWx0ZXJuYXRlbHk6IGV2dC5yZW1vdmUoKTtcclxuXHQgKiBcdFx0XHR9XHJcblx0ICogXHRcdH1cclxuXHQgKiBcclxuXHQgKiBAbWV0aG9kIG9uXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBBbiBvYmplY3Qgd2l0aCBhIGhhbmRsZUV2ZW50IG1ldGhvZCwgb3IgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5cclxuXHQgKiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZC5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSBUaGUgc2NvcGUgdG8gZXhlY3V0ZSB0aGUgbGlzdGVuZXIgaW4uIERlZmF1bHRzIHRvIHRoZSBkaXNwYXRjaGVyL2N1cnJlbnRUYXJnZXQgZm9yIGZ1bmN0aW9uIGxpc3RlbmVycywgYW5kIHRvIHRoZSBsaXN0ZW5lciBpdHNlbGYgZm9yIG9iamVjdCBsaXN0ZW5lcnMgKGllLiB1c2luZyBoYW5kbGVFdmVudCkuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gSWYgdHJ1ZSwgdGhlIGxpc3RlbmVyIHdpbGwgcmVtb3ZlIGl0c2VsZiBhZnRlciB0aGUgZmlyc3QgdGltZSBpdCBpcyB0cmlnZ2VyZWQuXHJcblx0ICogQHBhcmFtIHsqfSBbZGF0YV0gQXJiaXRyYXJ5IGRhdGEgdGhhdCB3aWxsIGJlIGluY2x1ZGVkIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHdoZW4gdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlPWZhbHNlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXHJcblx0ICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgdGhlIGFub255bW91cyBmdW5jdGlvbiB0aGF0IHdhcyBjcmVhdGVkIGFuZCBhc3NpZ25lZCBhcyB0aGUgbGlzdGVuZXIuIFRoaXMgaXMgbmVlZGVkIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIgbGF0ZXIgdXNpbmcgLnJlbW92ZUV2ZW50TGlzdGVuZXIuXHJcblx0ICoqL1xyXG5cdHAub24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgc2NvcGUsIG9uY2UsIGRhdGEsIHVzZUNhcHR1cmUpIHtcclxuXHRcdGlmIChsaXN0ZW5lci5oYW5kbGVFdmVudCkge1xyXG5cdFx0XHRzY29wZSA9IHNjb3BlfHxsaXN0ZW5lcjtcclxuXHRcdFx0bGlzdGVuZXIgPSBsaXN0ZW5lci5oYW5kbGVFdmVudDtcclxuXHRcdH1cclxuXHRcdHNjb3BlID0gc2NvcGV8fHRoaXM7XHJcblx0XHRyZXR1cm4gdGhpcy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmN0aW9uKGV2dCkge1xyXG5cdFx0XHRcdGxpc3RlbmVyLmNhbGwoc2NvcGUsIGV2dCwgZGF0YSk7XHJcblx0XHRcdFx0b25jZSYmZXZ0LnJlbW92ZSgpO1xyXG5cdFx0XHR9LCB1c2VDYXB0dXJlKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgZXZlbnQgbGlzdGVuZXIuXHJcblx0ICpcclxuXHQgKiA8Yj5JbXBvcnRhbnQgTm90ZTo8L2I+IHRoYXQgeW91IG11c3QgcGFzcyB0aGUgZXhhY3QgZnVuY3Rpb24gcmVmZXJlbmNlIHVzZWQgd2hlbiB0aGUgZXZlbnQgd2FzIGFkZGVkLiBJZiBhIHByb3h5XHJcblx0ICogZnVuY3Rpb24sIG9yIGZ1bmN0aW9uIGNsb3N1cmUgaXMgdXNlZCBhcyB0aGUgY2FsbGJhY2ssIHRoZSBwcm94eS9jbG9zdXJlIHJlZmVyZW5jZSBtdXN0IGJlIHVzZWQgLSBhIG5ldyBwcm94eSBvclxyXG5cdCAqIGNsb3N1cmUgd2lsbCBub3Qgd29yay5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gb3Igb2JqZWN0LlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdIEZvciBldmVudHMgdGhhdCBidWJibGUsIGluZGljYXRlcyB3aGV0aGVyIHRvIGxpc3RlbiBmb3IgdGhlIGV2ZW50IGluIHRoZSBjYXB0dXJlIG9yIGJ1YmJsaW5nL3RhcmdldCBwaGFzZS5cclxuXHQgKiovXHJcblx0cC5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB1c2VDYXB0dXJlID8gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA6IHRoaXMuX2xpc3RlbmVycztcclxuXHRcdGlmICghbGlzdGVuZXJzKSB7IHJldHVybjsgfVxyXG5cdFx0dmFyIGFyciA9IGxpc3RlbmVyc1t0eXBlXTtcclxuXHRcdGlmICghYXJyKSB7IHJldHVybjsgfVxyXG5cdFx0Zm9yICh2YXIgaT0wLGw9YXJyLmxlbmd0aDsgaTxsOyBpKyspIHtcclxuXHRcdFx0aWYgKGFycltpXSA9PSBsaXN0ZW5lcikge1xyXG5cdFx0XHRcdGlmIChsPT0xKSB7IGRlbGV0ZShsaXN0ZW5lcnNbdHlwZV0pOyB9IC8vIGFsbG93cyBmb3IgZmFzdGVyIGNoZWNrcy5cclxuXHRcdFx0XHRlbHNlIHsgYXJyLnNwbGljZShpLDEpOyB9XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEEgc2hvcnRjdXQgdG8gdGhlIHJlbW92ZUV2ZW50TGlzdGVuZXIgbWV0aG9kLCB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMgYW5kIHJldHVybiB2YWx1ZS4gVGhpcyBpcyBhIGNvbXBhbmlvbiB0byB0aGVcclxuXHQgKiAub24gbWV0aG9kLlxyXG5cdCAqIFxyXG5cdCAqIDxiPklNUE9SVEFOVDo8L2I+IFRvIHJlbW92ZSBhIGxpc3RlbmVyIGFkZGVkIHdpdGggYG9uYCwgeW91IG11c3QgcGFzcyBpbiB0aGUgcmV0dXJuZWQgd3JhcHBlciBmdW5jdGlvbiBhcyB0aGUgbGlzdGVuZXIuIFNlZSBcclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvb25cIn19e3svY3Jvc3NMaW5rfX0gZm9yIGFuIGV4YW1wbGUuXHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIG9mZlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbiB8IE9iamVjdH0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIG9yIG9iamVjdC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXHJcblx0ICoqL1xyXG5cdHAub2ZmID0gcC5yZW1vdmVFdmVudExpc3RlbmVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgdHlwZSwgb3IgYWxsIGxpc3RlbmVycyBvZiBhbGwgdHlwZXMuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzXHJcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XHJcblx0ICpcclxuXHQgKiAgICAgIC8vIFJlbW92ZSBhbGwgY2xpY2sgbGlzdGVuZXJzXHJcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKFwiY2xpY2tcIik7XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIHJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LiBJZiBvbWl0dGVkLCBhbGwgbGlzdGVuZXJzIGZvciBhbGwgdHlwZXMgd2lsbCBiZSByZW1vdmVkLlxyXG5cdCAqKi9cclxuXHRwLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xyXG5cdFx0aWYgKCF0eXBlKSB7IHRoaXMuX2xpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgPSBudWxsOyB9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0aWYgKHRoaXMuX2xpc3RlbmVycykgeyBkZWxldGUodGhpcy5fbGlzdGVuZXJzW3R5cGVdKTsgfVxyXG5cdFx0XHRpZiAodGhpcy5fY2FwdHVyZUxpc3RlbmVycykgeyBkZWxldGUodGhpcy5fY2FwdHVyZUxpc3RlbmVyc1t0eXBlXSk7IH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBEaXNwYXRjaGVzIHRoZSBzcGVjaWZpZWQgZXZlbnQgdG8gYWxsIGxpc3RlbmVycy5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgLy8gVXNlIGEgc3RyaW5nIGV2ZW50XHJcblx0ICogICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKTtcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gVXNlIGFuIEV2ZW50IGluc3RhbmNlXHJcblx0ICogICAgICB2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJwcm9ncmVzc1wiKTtcclxuXHQgKiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGRpc3BhdGNoRXZlbnRcclxuXHQgKiBAcGFyYW0ge09iamVjdCB8IFN0cmluZyB8IEV2ZW50fSBldmVudE9iaiBBbiBvYmplY3Qgd2l0aCBhIFwidHlwZVwiIHByb3BlcnR5LCBvciBhIHN0cmluZyB0eXBlLlxyXG5cdCAqIFdoaWxlIGEgZ2VuZXJpYyBvYmplY3Qgd2lsbCB3b3JrLCBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYSBDcmVhdGVKUyBFdmVudCBpbnN0YW5jZS4gSWYgYSBzdHJpbmcgaXMgdXNlZCxcclxuXHQgKiBkaXNwYXRjaEV2ZW50IHdpbGwgY29uc3RydWN0IGFuIEV2ZW50IGluc3RhbmNlIGlmIG5lY2Vzc2FyeSB3aXRoIHRoZSBzcGVjaWZpZWQgdHlwZS4gVGhpcyBsYXR0ZXIgYXBwcm9hY2ggY2FuXHJcblx0ICogYmUgdXNlZCB0byBhdm9pZCBldmVudCBvYmplY3QgaW5zdGFudGlhdGlvbiBmb3Igbm9uLWJ1YmJsaW5nIGV2ZW50cyB0aGF0IG1heSBub3QgaGF2ZSBhbnkgbGlzdGVuZXJzLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZXNdIFNwZWNpZmllcyB0aGUgYGJ1YmJsZXNgIHZhbHVlIHdoZW4gYSBzdHJpbmcgd2FzIHBhc3NlZCB0byBldmVudE9iai5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYW5jZWxhYmxlXSBTcGVjaWZpZXMgdGhlIGBjYW5jZWxhYmxlYCB2YWx1ZSB3aGVuIGEgc3RyaW5nIHdhcyBwYXNzZWQgdG8gZXZlbnRPYmouXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBmYWxzZSBpZiBgcHJldmVudERlZmF1bHQoKWAgd2FzIGNhbGxlZCBvbiBhIGNhbmNlbGFibGUgZXZlbnQsIHRydWUgb3RoZXJ3aXNlLlxyXG5cdCAqKi9cclxuXHRwLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudE9iaiwgYnViYmxlcywgY2FuY2VsYWJsZSkge1xyXG5cdFx0aWYgKHR5cGVvZiBldmVudE9iaiA9PSBcInN0cmluZ1wiKSB7XHJcblx0XHRcdC8vIHNraXAgZXZlcnl0aGluZyBpZiB0aGVyZSdzIG5vIGxpc3RlbmVycyBhbmQgaXQgZG9lc24ndCBidWJibGU6XHJcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcblx0XHRcdGlmICghYnViYmxlcyAmJiAoIWxpc3RlbmVycyB8fCAhbGlzdGVuZXJzW2V2ZW50T2JqXSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0ZXZlbnRPYmogPSBuZXcgY3JlYXRlanMuRXZlbnQoZXZlbnRPYmosIGJ1YmJsZXMsIGNhbmNlbGFibGUpO1xyXG5cdFx0fSBlbHNlIGlmIChldmVudE9iai50YXJnZXQgJiYgZXZlbnRPYmouY2xvbmUpIHtcclxuXHRcdFx0Ly8gcmVkaXNwYXRjaGluZyBhbiBhY3RpdmUgZXZlbnQgb2JqZWN0LCBzbyBjbG9uZSBpdDpcclxuXHRcdFx0ZXZlbnRPYmogPSBldmVudE9iai5jbG9uZSgpO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHQvLyBUT0RPOiBpdCB3b3VsZCBiZSBuaWNlIHRvIGVsaW1pbmF0ZSB0aGlzLiBNYXliZSBpbiBmYXZvdXIgb2YgZXZ0T2JqIGluc3RhbmNlb2YgRXZlbnQ/IE9yICEhZXZ0T2JqLmNyZWF0ZUV2ZW50XHJcblx0XHR0cnkgeyBldmVudE9iai50YXJnZXQgPSB0aGlzOyB9IGNhdGNoIChlKSB7fSAvLyB0cnkvY2F0Y2ggYWxsb3dzIHJlZGlzcGF0Y2hpbmcgb2YgbmF0aXZlIGV2ZW50c1xyXG5cclxuXHRcdGlmICghZXZlbnRPYmouYnViYmxlcyB8fCAhdGhpcy5wYXJlbnQpIHtcclxuXHRcdFx0dGhpcy5fZGlzcGF0Y2hFdmVudChldmVudE9iaiwgMik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgdG9wPXRoaXMsIGxpc3Q9W3RvcF07XHJcblx0XHRcdHdoaWxlICh0b3AucGFyZW50KSB7IGxpc3QucHVzaCh0b3AgPSB0b3AucGFyZW50KTsgfVxyXG5cdFx0XHR2YXIgaSwgbD1saXN0Lmxlbmd0aDtcclxuXHJcblx0XHRcdC8vIGNhcHR1cmUgJiBhdFRhcmdldFxyXG5cdFx0XHRmb3IgKGk9bC0xOyBpPj0wICYmICFldmVudE9iai5wcm9wYWdhdGlvblN0b3BwZWQ7IGktLSkge1xyXG5cdFx0XHRcdGxpc3RbaV0uX2Rpc3BhdGNoRXZlbnQoZXZlbnRPYmosIDErKGk9PTApKTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBidWJibGluZ1xyXG5cdFx0XHRmb3IgKGk9MTsgaTxsICYmICFldmVudE9iai5wcm9wYWdhdGlvblN0b3BwZWQ7IGkrKykge1xyXG5cdFx0XHRcdGxpc3RbaV0uX2Rpc3BhdGNoRXZlbnQoZXZlbnRPYmosIDMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gIWV2ZW50T2JqLmRlZmF1bHRQcmV2ZW50ZWQ7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXHJcblx0ICogQG1ldGhvZCBoYXNFdmVudExpc3RlbmVyXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxyXG5cdCAqKi9cclxuXHRwLmhhc0V2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLCBjYXB0dXJlTGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVycztcclxuXHRcdHJldHVybiAhISgobGlzdGVuZXJzICYmIGxpc3RlbmVyc1t0eXBlXSkgfHwgKGNhcHR1cmVMaXN0ZW5lcnMgJiYgY2FwdHVyZUxpc3RlbmVyc1t0eXBlXSkpO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUgb24gdGhpcyBvYmplY3Qgb3IgYW55IG9mIGl0c1xyXG5cdCAqIGFuY2VzdG9ycyAocGFyZW50LCBwYXJlbnQncyBwYXJlbnQsIGV0YykuIEEgcmV0dXJuIHZhbHVlIG9mIHRydWUgaW5kaWNhdGVzIHRoYXQgaWYgYSBidWJibGluZyBldmVudCBvZiB0aGVcclxuXHQgKiBzcGVjaWZpZWQgdHlwZSBpcyBkaXNwYXRjaGVkIGZyb20gdGhpcyBvYmplY3QsIGl0IHdpbGwgdHJpZ2dlciBhdCBsZWFzdCBvbmUgbGlzdGVuZXIuXHJcblx0ICogXHJcblx0ICogVGhpcyBpcyBzaW1pbGFyIHRvIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9oYXNFdmVudExpc3RlbmVyXCJ9fXt7L2Nyb3NzTGlua319LCBidXQgaXQgc2VhcmNoZXMgdGhlIGVudGlyZVxyXG5cdCAqIGV2ZW50IGZsb3cgZm9yIGEgbGlzdGVuZXIsIG5vdCBqdXN0IHRoaXMgb2JqZWN0LlxyXG5cdCAqIEBtZXRob2Qgd2lsbFRyaWdnZXJcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cclxuXHQgKiovXHJcblx0cC53aWxsVHJpZ2dlciA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRcdHZhciBvID0gdGhpcztcclxuXHRcdHdoaWxlIChvKSB7XHJcblx0XHRcdGlmIChvLmhhc0V2ZW50TGlzdGVuZXIodHlwZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0byA9IG8ucGFyZW50O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cclxuXHQgKiovXHJcblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIFwiW0V2ZW50RGlzcGF0Y2hlcl1cIjtcclxuXHR9O1xyXG5cclxuXHJcbi8vIHByaXZhdGUgbWV0aG9kczpcclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIF9kaXNwYXRjaEV2ZW50XHJcblx0ICogQHBhcmFtIHtPYmplY3QgfCBFdmVudH0gZXZlbnRPYmpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRQaGFzZVxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiovXHJcblx0cC5fZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50T2JqLCBldmVudFBoYXNlKSB7XHJcblx0XHR2YXIgbCwgYXJyLCBsaXN0ZW5lcnMgPSAoZXZlbnRQaGFzZSA8PSAyKSA/IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgOiB0aGlzLl9saXN0ZW5lcnM7XHJcblx0XHRpZiAoZXZlbnRPYmogJiYgbGlzdGVuZXJzICYmIChhcnIgPSBsaXN0ZW5lcnNbZXZlbnRPYmoudHlwZV0pICYmIChsPWFyci5sZW5ndGgpKSB7XHJcblx0XHRcdHRyeSB7IGV2ZW50T2JqLmN1cnJlbnRUYXJnZXQgPSB0aGlzOyB9IGNhdGNoIChlKSB7fVxyXG5cdFx0XHR0cnkgeyBldmVudE9iai5ldmVudFBoYXNlID0gZXZlbnRQaGFzZXwwOyB9IGNhdGNoIChlKSB7fVxyXG5cdFx0XHRldmVudE9iai5yZW1vdmVkID0gZmFsc2U7XHJcblx0XHRcdFxyXG5cdFx0XHRhcnIgPSBhcnIuc2xpY2UoKTsgLy8gdG8gYXZvaWQgaXNzdWVzIHdpdGggaXRlbXMgYmVpbmcgcmVtb3ZlZCBvciBhZGRlZCBkdXJpbmcgdGhlIGRpc3BhdGNoXHJcblx0XHRcdGZvciAodmFyIGk9MDsgaTxsICYmICFldmVudE9iai5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ7IGkrKykge1xyXG5cdFx0XHRcdHZhciBvID0gYXJyW2ldO1xyXG5cdFx0XHRcdGlmIChvLmhhbmRsZUV2ZW50KSB7IG8uaGFuZGxlRXZlbnQoZXZlbnRPYmopOyB9XHJcblx0XHRcdFx0ZWxzZSB7IG8oZXZlbnRPYmopOyB9XHJcblx0XHRcdFx0aWYgKGV2ZW50T2JqLnJlbW92ZWQpIHtcclxuXHRcdFx0XHRcdHRoaXMub2ZmKGV2ZW50T2JqLnR5cGUsIG8sIGV2ZW50UGhhc2U9PTEpO1xyXG5cdFx0XHRcdFx0ZXZlbnRPYmoucmVtb3ZlZCA9IGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKGV2ZW50UGhhc2UgPT09IDIpIHsgdGhpcy5fZGlzcGF0Y2hFdmVudChldmVudE9iaiwgMi4xKTsgfVxyXG5cdH07XHJcblxyXG5cclxuXHRjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIgPSBFdmVudERpc3BhdGNoZXI7XHJcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBQcm9ncmVzc0V2ZW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG53aW5kb3cuY3JlYXRlanMgPSB3aW5kb3cuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoc2NvcGUpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgQ3JlYXRlSlMge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBkaXNwYXRjaGVkIHdoZW4gcHJvZ3Jlc3MgY2hhbmdlcy5cblx0ICogQGNsYXNzIFByb2dyZXNzRXZlbnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGxvYWRlZCBUaGUgYW1vdW50IHRoYXQgaGFzIGJlZW4gbG9hZGVkLiBUaGlzIGNhbiBiZSBhbnkgbnVtYmVyIHJlbGF0aXZlIHRvIHRoZSB0b3RhbC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0b3RhbD0xXSBUaGUgdG90YWwgYW1vdW50IHRoYXQgd2lsbCBsb2FkLiBUaGlzIHdpbGwgZGVmYXVsdCB0byAxLCBzbyBpZiB0aGUgYGxvYWRlZGAgdmFsdWUgaXNcblx0ICogYSBwZXJjZW50YWdlIChiZXR3ZWVuIDAgYW5kIDEpLCBpdCBjYW4gYmUgb21pdHRlZC5cblx0ICogQHRvZG8gQ29uc2lkZXIgaGF2aW5nIHRoaXMgZXZlbnQgYmUgYSBcImZpbGVwcm9ncmVzc1wiIGV2ZW50IGFzIHdlbGxcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBQcm9ncmVzc0V2ZW50KGxvYWRlZCwgdG90YWwpIHtcblx0XHR0aGlzLkV2ZW50X2NvbnN0cnVjdG9yKFwicHJvZ3Jlc3NcIik7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYW1vdW50IHRoYXQgaGFzIGJlZW4gbG9hZGVkIChvdXQgb2YgYSB0b3RhbCBhbW91bnQpXG5cdFx0ICogQHByb3BlcnR5IGxvYWRlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5sb2FkZWQgPSBsb2FkZWQ7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdG90YWwgXCJzaXplXCIgb2YgdGhlIGxvYWQuXG5cdFx0ICogQHByb3BlcnR5IHRvdGFsXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy50b3RhbCA9ICh0b3RhbCA9PSBudWxsKSA/IDEgOiB0b3RhbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBwZXJjZW50YWdlIChvdXQgb2YgMSkgdGhhdCB0aGUgbG9hZCBoYXMgYmVlbiBjb21wbGV0ZWQuIFRoaXMgaXMgY2FsY3VsYXRlZCB1c2luZyBgbG9hZGVkL3RvdGFsYC5cblx0XHQgKiBAcHJvcGVydHkgcHJvZ3Jlc3Ncblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLnByb2dyZXNzID0gKHRvdGFsID09IDApID8gMCA6IHRoaXMubG9hZGVkIC8gdGhpcy50b3RhbDtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChQcm9ncmVzc0V2ZW50LCBjcmVhdGVqcy5FdmVudCk7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgUHJvZ3Jlc3NFdmVudCBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtQcm9ncmVzc0V2ZW50fSBhIGNsb25lIG9mIHRoZSBFdmVudCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBjcmVhdGVqcy5Qcm9ncmVzc0V2ZW50KHRoaXMubG9hZGVkLCB0aGlzLnRvdGFsKTtcblx0fTtcblxuXHRjcmVhdGVqcy5Qcm9ncmVzc0V2ZW50ID0gY3JlYXRlanMucHJvbW90ZShQcm9ncmVzc0V2ZW50LCBcIkV2ZW50XCIpO1xuXG59KHdpbmRvdykpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8ganNvbjMuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbi8qISBKU09OIHYzLjMuMiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDE0LCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cbjsoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgdGhlIGBkZWZpbmVgIGZ1bmN0aW9uIGV4cG9zZWQgYnkgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLiBUaGVcbiAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cbiAgdmFyIGlzTG9hZGVyID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQ7XG5cbiAgLy8gQSBzZXQgb2YgdHlwZXMgdXNlZCB0byBkaXN0aW5ndWlzaCBvYmplY3RzIGZyb20gcHJpbWl0aXZlcy5cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICBcIm9iamVjdFwiOiB0cnVlXG4gIH07XG5cbiAgLy8gRGV0ZWN0IHRoZSBgZXhwb3J0c2Agb2JqZWN0IGV4cG9zZWQgYnkgQ29tbW9uSlMgaW1wbGVtZW50YXRpb25zLlxuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8vIFVzZSB0aGUgYGdsb2JhbGAgb2JqZWN0IGV4cG9zZWQgYnkgTm9kZSAoaW5jbHVkaW5nIEJyb3dzZXJpZnkgdmlhXG4gIC8vIGBpbnNlcnQtbW9kdWxlLWdsb2JhbHNgKSwgTmFyd2hhbCwgYW5kIFJpbmdvIGFzIHRoZSBkZWZhdWx0IGNvbnRleHQsXG4gIC8vIGFuZCB0aGUgYHdpbmRvd2Agb2JqZWN0IGluIGJyb3dzZXJzLiBSaGlubyBleHBvcnRzIGEgYGdsb2JhbGAgZnVuY3Rpb25cbiAgLy8gaW5zdGVhZC5cbiAgdmFyIHJvb3QgPSBvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cgfHwgdGhpcyxcbiAgICAgIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiB0eXBlb2YgZ2xvYmFsID09IFwib2JqZWN0XCIgJiYgZ2xvYmFsO1xuXG4gIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsW1wiZ2xvYmFsXCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJ3aW5kb3dcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcInNlbGZcIl0gPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvLyBQdWJsaWM6IEluaXRpYWxpemVzIEpTT04gMyB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdCwgYXR0YWNoaW5nIHRoZVxuICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCwgZXhwb3J0cykge1xuICAgIGNvbnRleHQgfHwgKGNvbnRleHQgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuICAgIGV4cG9ydHMgfHwgKGV4cG9ydHMgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuXG4gICAgLy8gTmF0aXZlIGNvbnN0cnVjdG9yIGFsaWFzZXMuXG4gICAgdmFyIE51bWJlciA9IGNvbnRleHRbXCJOdW1iZXJcIl0gfHwgcm9vdFtcIk51bWJlclwiXSxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dFtcIlN0cmluZ1wiXSB8fCByb290W1wiU3RyaW5nXCJdLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0W1wiT2JqZWN0XCJdIHx8IHJvb3RbXCJPYmplY3RcIl0sXG4gICAgICAgIERhdGUgPSBjb250ZXh0W1wiRGF0ZVwiXSB8fCByb290W1wiRGF0ZVwiXSxcbiAgICAgICAgU3ludGF4RXJyb3IgPSBjb250ZXh0W1wiU3ludGF4RXJyb3JcIl0gfHwgcm9vdFtcIlN5bnRheEVycm9yXCJdLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0W1wiVHlwZUVycm9yXCJdIHx8IHJvb3RbXCJUeXBlRXJyb3JcIl0sXG4gICAgICAgIE1hdGggPSBjb250ZXh0W1wiTWF0aFwiXSB8fCByb290W1wiTWF0aFwiXSxcbiAgICAgICAgbmF0aXZlSlNPTiA9IGNvbnRleHRbXCJKU09OXCJdIHx8IHJvb3RbXCJKU09OXCJdO1xuXG4gICAgLy8gRGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbnMuXG4gICAgaWYgKHR5cGVvZiBuYXRpdmVKU09OID09IFwib2JqZWN0XCIgJiYgbmF0aXZlSlNPTikge1xuICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcbiAgICAgIGV4cG9ydHMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgZ2V0Q2xhc3MgPSBvYmplY3RQcm90by50b1N0cmluZyxcbiAgICAgICAgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XG5cbiAgICAvLyBUZXN0IHRoZSBgRGF0ZSNnZXRVVEMqYCBtZXRob2RzLiBCYXNlZCBvbiB3b3JrIGJ5IEBZYWZmbGUuXG4gICAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZSBgZ2V0VVRDRnVsbFllYXJgLCBgTW9udGhgLCBhbmQgYERhdGVgIG1ldGhvZHMgcmV0dXJuIG5vbnNlbnNpY2FsXG4gICAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxuICAgICAgaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKSA9PSAtMTA5MjUyICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKSA9PT0gMCAmJiBpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKSA9PT0gMSAmJlxuICAgICAgICAvLyBTYWZhcmkgPCAyLjAuMiBzdG9yZXMgdGhlIGludGVybmFsIG1pbGxpc2Vjb25kIHRpbWUgdmFsdWUgY29ycmVjdGx5LFxuICAgICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuICAgICAgICAvLyBzaWduZWQgMzItYml0IGludGVnZXJzIChbLTIgKiogMzEsIDIgKiogMzEgLSAxXSkuXG4gICAgICAgIGlzRXh0ZW5kZWQuZ2V0VVRDSG91cnMoKSA9PSAxMCAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbnV0ZXMoKSA9PSAzNyAmJiBpc0V4dGVuZGVkLmdldFVUQ1NlY29uZHMoKSA9PSA2ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgPT0gNzA4O1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGFyZSBzcGVjLWNvbXBsaWFudC4gQmFzZWQgb24gd29yayBieSBLZW4gU255ZGVyLlxuICAgIGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGZlYXR1cmUgdGVzdCByZXN1bHQuXG4gICAgICAgIHJldHVybiBoYXNbbmFtZV07XG4gICAgICB9XG4gICAgICB2YXIgaXNTdXBwb3J0ZWQ7XG4gICAgICBpZiAobmFtZSA9PSBcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKSB7XG4gICAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcbiAgICAgICAgLy8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gXCJhXCJbMF0gIT0gXCJhXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcbiAgICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXG4gICAgICAgIC8vIHN1cHBvcnRlZC5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlLCBzZXJpYWxpemVkID0gJ3tcImFcIjpbMSx0cnVlLGZhbHNlLG51bGwsXCJcXFxcdTAwMDBcXFxcYlxcXFxuXFxcXGZcXFxcclxcXFx0XCJdfSc7XG4gICAgICAgIC8vIFRlc3QgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XG4gICAgICAgICAgdmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5LCBzdHJpbmdpZnlTdXBwb3J0ZWQgPSB0eXBlb2Ygc3RyaW5naWZ5ID09IFwiZnVuY3Rpb25cIiAmJiBpc0V4dGVuZGVkO1xuICAgICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIC8vIEEgdGVzdCBmdW5jdGlvbiBvYmplY3Qgd2l0aCBhIGN1c3RvbSBgdG9KU09OYCBtZXRob2QuXG4gICAgICAgICAgICAodmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSkudG9KU09OID0gdmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggMy4xYjEgYW5kIGIyIHNlcmlhbGl6ZSBzdHJpbmcsIG51bWJlciwgYW5kIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoMCkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyLCBhbmQgSlNPTiAyIHNlcmlhbGl6ZSB3cmFwcGVkIHByaW1pdGl2ZXMgYXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBOdW1iZXIoKSkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxuICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdmFsdWVdKSA9PSBcIlsxXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXCJbXVwiYCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgLy8gYFwiW251bGxdXCJgLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWZdKSA9PSBcIltudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiBoYWx0cyBzZXJpYWxpemF0aW9uIGlmIGFuIGFycmF5IGNvbnRhaW5zIGEgZnVuY3Rpb246XG4gICAgICAgICAgICAgICAgLy8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXCJbMSx0cnVlLF0sXCIuIEZGIDMuMWIzXG4gICAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmUgY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZiwgZ2V0Q2xhc3MsIG51bGxdKSA9PSBcIltudWxsLG51bGwsbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgY2hhcmFjdGVyIGVzY2FwZSBjb2RlcyBhcmUgZXhwZWN0ZWQgKGUuZy4sIGBcXGJgID0+IGBcXHUwMDA4YCkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHsgXCJhXCI6IFt2YWx1ZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIFwiXFx4MDBcXGJcXG5cXGZcXHJcXHRcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCwgdmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSg4LjY0ZTE1KSkgPT0gJ1wiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgeWVhcnMgaW5zdGVhZCBvZiBzaXgtZGlnaXQgeWVhcnMuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpID09ICdcIi0wMDAwMDEtMDEtMDFUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpID09ICdcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlwiJztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCBgSlNPTi5wYXJzZWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG4gICAgICAgICAgdmFyIHBhcnNlID0gZXhwb3J0cy5wYXJzZTtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAvLyBDb25mb3JtaW5nIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYWxzbyBjb2VyY2UgdGhlIGluaXRpYWwgYXJndW1lbnQgdG9cbiAgICAgICAgICAgICAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cbiAgICAgICAgICAgICAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gIXBhcnNlKCdcIlxcdFwiJyk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIwMVwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMuIFRoZXNlIGVudmlyb25tZW50cywgYWxvbmcgd2l0aCBGRiAzLjFiMSBhbmQgMixcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMS5cIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoIWhhcyhcImpzb25cIikpIHtcbiAgICAgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXG4gICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcbiAgICAgICAgICBkYXRlQ2xhc3MgPSBcIltvYmplY3QgRGF0ZV1cIixcbiAgICAgICAgICBudW1iZXJDbGFzcyA9IFwiW29iamVjdCBOdW1iZXJdXCIsXG4gICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxuICAgICAgICAgIGFycmF5Q2xhc3MgPSBcIltvYmplY3QgQXJyYXldXCIsXG4gICAgICAgICAgYm9vbGVhbkNsYXNzID0gXCJbb2JqZWN0IEJvb2xlYW5dXCI7XG5cbiAgICAgIC8vIERldGVjdCBpbmNvbXBsZXRlIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cbiAgICAgIHZhciBjaGFySW5kZXhCdWdneSA9IGhhcyhcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKTtcblxuICAgICAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG4gICAgICBpZiAoIWlzRXh0ZW5kZWQpIHtcbiAgICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cbiAgICAgICAgLy8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cbiAgICAgICAgdmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG4gICAgICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcbiAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cbiAgICAgICAgdmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuICAgICAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cbiAgICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxuICAgICAgaWYgKCEoaXNQcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5KSkge1xuICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgY29uc3RydWN0b3I7XG4gICAgICAgICAgaWYgKChtZW1iZXJzLl9fcHJvdG9fXyA9IG51bGwsIG1lbWJlcnMuX19wcm90b19fID0ge1xuICAgICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIFNlYU1vbmtleS5cbiAgICAgICAgICAgIFwidG9TdHJpbmdcIjogMVxuICAgICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxuICAgICAgICAgICAgLy8gc3VwcG9ydHMgdGhlIG11dGFibGUgKnByb3RvKiBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcbiAgICAgICAgICAgICAgLy8gb2YgdGhlIEVTIDUuMSBzcGVjKS4gVGhlIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbiBwcmV2ZW50cyBhblxuICAgICAgICAgICAgICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcbiAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG4gICAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZW1iZXJzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IE5vcm1hbGl6ZXMgdGhlIGBmb3IuLi5pbmAgaXRlcmF0aW9uIGFsZ29yaXRobSBhY3Jvc3NcbiAgICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cbiAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2l6ZSA9IDAsIFByb3BlcnRpZXMsIG1lbWJlcnMsIHByb3BlcnR5O1xuXG4gICAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuICAgICAgICAvLyBgdmFsdWVPZmAgcHJvcGVydHkgaW5oZXJpdHMgdGhlIG5vbi1lbnVtZXJhYmxlIGZsYWcgZnJvbVxuICAgICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cbiAgICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZU9mID0gMDtcbiAgICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuICAgICAgICBtZW1iZXJzID0gbmV3IFByb3BlcnRpZXMoKTtcbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBpZiAoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBQcm9wZXJ0aWVzID0gbWVtYmVycyA9IG51bGw7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAvLyBBIGxpc3Qgb2Ygbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcbiAgICAgICAgICAvLyBJRSA8PSA4LCBNb3ppbGxhIDEuMCwgYW5kIE5ldHNjYXBlIDYuMiBpZ25vcmUgc2hhZG93ZWQgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGxlbmd0aDtcbiAgICAgICAgICAgIHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gXCJmdW5jdGlvblwiICYmIG9iamVjdFR5cGVzW3R5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHldICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBpc1Byb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxuICAgICAgICAgICAgICAvLyBjZXJ0YWluIGNvbmRpdGlvbnM7IElFIGRvZXMgbm90LlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggbm9uLWVudW1lcmFibGUgcHJvcGVydHkuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IG1lbWJlcnMubGVuZ3RoOyBwcm9wZXJ0eSA9IG1lbWJlcnNbLS1sZW5ndGhdOyBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmIGNhbGxiYWNrKHByb3BlcnR5KSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzaXplID09IDIpIHtcbiAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjQgZW51bWVyYXRlcyBzaGFkb3dlZCBwcm9wZXJ0aWVzIHR3aWNlLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2V0IG9mIGl0ZXJhdGVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gU3RvcmUgZWFjaCBwcm9wZXJ0eSBuYW1lIHRvIHByZXZlbnQgZG91YmxlIGVudW1lcmF0aW9uLiBUaGVcbiAgICAgICAgICAgICAgLy8gYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIG5vdCBlbnVtZXJhdGVkIGR1ZSB0byBjcm9zcy1cbiAgICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmICFpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpICYmIChtZW1iZXJzW3Byb3BlcnR5XSA9IDEpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gYnVncyBkZXRlY3RlZDsgdXNlIHRoZSBzdGFuZGFyZCBgZm9yLi4uaW5gIGFsZ29yaXRobS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgIShpc0NvbnN0cnVjdG9yID0gcHJvcGVydHkgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xuICAgICAgICAgICAgLy8gY3Jvc3MtZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IgfHwgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgKHByb3BlcnR5ID0gXCJjb25zdHJ1Y3RvclwiKSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvckVhY2gob2JqZWN0LCBjYWxsYmFjayk7XG4gICAgICB9O1xuXG4gICAgICAvLyBQdWJsaWM6IFNlcmlhbGl6ZXMgYSBKYXZhU2NyaXB0IGB2YWx1ZWAgYXMgYSBKU09OIHN0cmluZy4gVGhlIG9wdGlvbmFsXG4gICAgICAvLyBgZmlsdGVyYCBhcmd1bWVudCBtYXkgc3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiB0aGF0IGFsdGVycyBob3cgb2JqZWN0IGFuZFxuICAgICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XG4gICAgICAvLyBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIG9wdGlvbmFsIGB3aWR0aGBcbiAgICAgIC8vIGFyZ3VtZW50IG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAgICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cbiAgICAgIGlmICghaGFzKFwianNvbi1zdHJpbmdpZnlcIikpIHtcbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIEVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFxcXFxcIixcbiAgICAgICAgICAzNDogJ1xcXFxcIicsXG4gICAgICAgICAgODogXCJcXFxcYlwiLFxuICAgICAgICAgIDEyOiBcIlxcXFxmXCIsXG4gICAgICAgICAgMTA6IFwiXFxcXG5cIixcbiAgICAgICAgICAxMzogXCJcXFxcclwiLFxuICAgICAgICAgIDk6IFwiXFxcXHRcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xuICAgICAgICAvLyBsZW5ndGggaXMgYXQgbGVhc3QgZXF1YWwgdG8gYHdpZHRoYC4gVGhlIGB3aWR0aGAgbXVzdCBiZSA8PSA2LlxuICAgICAgICB2YXIgbGVhZGluZ1plcm9lcyA9IFwiMDAwMDAwXCI7XG4gICAgICAgIHZhciB0b1BhZGRlZFN0cmluZyA9IGZ1bmN0aW9uICh3aWR0aCwgdmFsdWUpIHtcbiAgICAgICAgICAvLyBUaGUgYHx8IDBgIGV4cHJlc3Npb24gaXMgbmVjZXNzYXJ5IHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluXG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcIjBcImAuXG4gICAgICAgICAgcmV0dXJuIChsZWFkaW5nWmVyb2VzICsgKHZhbHVlIHx8IDApKS5zbGljZSgtd2lkdGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBEb3VibGUtcXVvdGVzIGEgc3RyaW5nIGB2YWx1ZWAsIHJlcGxhY2luZyBhbGwgQVNDSUkgY29udHJvbFxuICAgICAgICAvLyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggY29kZSB1bml0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDMxKSB3aXRoXG4gICAgICAgIC8vIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBRdW90ZSh2YWx1ZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIHZhciB1bmljb2RlUHJlZml4ID0gXCJcXFxcdTAwXCI7XG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSAnXCInLCBpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCwgdXNlQ2hhckluZGV4ID0gIWNoYXJJbmRleEJ1Z2d5IHx8IGxlbmd0aCA+IDEwO1xuICAgICAgICAgIHZhciBzeW1ib2xzID0gdXNlQ2hhckluZGV4ICYmIChjaGFySW5kZXhCdWdneSA/IHZhbHVlLnNwbGl0KFwiXCIpIDogdmFsdWUpO1xuICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIsIGFwcGVuZCBpdHMgVW5pY29kZSBvclxuICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA4OiBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTI6IGNhc2UgMTM6IGNhc2UgMzQ6IGNhc2UgOTI6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdW5pY29kZVByZWZpeCArIHRvUGFkZGVkU3RyaW5nKDIsIGNoYXJDb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVzZUNoYXJJbmRleCA/IHN5bWJvbHNbaW5kZXhdIDogdmFsdWUuY2hhckF0KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdcIic7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgYW4gb2JqZWN0LiBJbXBsZW1lbnRzIHRoZVxuICAgICAgICAvLyBgU3RyKGtleSwgaG9sZGVyKWAsIGBKTyh2YWx1ZSlgLCBhbmQgYEpBKHZhbHVlKWAgb3BlcmF0aW9ucy5cbiAgICAgICAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgb2JqZWN0LCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBob3N0IG9iamVjdCBzdXBwb3J0LlxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBkYXRlQ2xhc3MgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDApIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjkuNS40NC4gU2VlIHNlY3Rpb24gMTUuOS4xLjE1XG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nIGZvcm1hdC5cbiAgICAgICAgICAgICAgICBpZiAoZ2V0RGF5KSB7XG4gICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjb21wdXRlIHRoZSB5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsXG4gICAgICAgICAgICAgICAgICAvLyBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGlmIHRoZSBgZ2V0VVRDKmAgbWV0aG9kcyBhcmVcbiAgICAgICAgICAgICAgICAgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXG4gICAgICAgICAgICAgICAgICBkYXRlID0gZmxvb3IodmFsdWUgLyA4NjRlNSk7XG4gICAgICAgICAgICAgICAgICBmb3IgKHllYXIgPSBmbG9vcihkYXRlIC8gMzY1LjI0MjUpICsgMTk3MCAtIDE7IGdldERheSh5ZWFyICsgMSwgMCkgPD0gZGF0ZTsgeWVhcisrKTtcbiAgICAgICAgICAgICAgICAgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBgdGltZWAgdmFsdWUgc3BlY2lmaWVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5IChzZWUgRVNcbiAgICAgICAgICAgICAgICAgIC8vIDUuMSBzZWN0aW9uIDE1LjkuMS4yKS4gVGhlIGZvcm11bGEgYChBICUgQiArIEIpICUgQmAgaXMgdXNlZFxuICAgICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAgIC8vIGNvcnJlc3BvbmQgdG8gdGhlIGBtb2R1bG9gIG9wZXJhdGlvbiBmb3IgbmVnYXRpdmUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgIHRpbWUgPSAodmFsdWUgJSA4NjRlNSArIDg2NGU1KSAlIDg2NGU1O1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuICAgICAgICAgICAgICAgICAgLy8gZGVjb21wb3NpbmcgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkuIFNlZSBzZWN0aW9uIDE1LjkuMS4xMC5cbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gZmxvb3IodGltZSAvIDM2ZTUpICUgMjQ7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBmbG9vcih0aW1lIC8gMWUzKSAlIDYwO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGltZSAlIDFlMztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgeWVhciA9IHZhbHVlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgaG91cnMgPSB2YWx1ZS5nZXRVVENIb3VycygpO1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IHZhbHVlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh5ZWFyIDw9IDAgfHwgeWVhciA+PSAxZTQgPyAoeWVhciA8IDAgPyBcIi1cIiA6IFwiK1wiKSArIHRvUGFkZGVkU3RyaW5nKDYsIHllYXIgPCAwID8gLXllYXIgOiB5ZWFyKSA6IHRvUGFkZGVkU3RyaW5nKDQsIHllYXIpKSArXG4gICAgICAgICAgICAgICAgICBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1vbnRocywgZGF0ZXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyBzaG91bGQgaGF2ZSB0d29cbiAgICAgICAgICAgICAgICAgIC8vIGRpZ2l0czsgbWlsbGlzZWNvbmRzIHNob3VsZCBoYXZlIHRocmVlLlxuICAgICAgICAgICAgICAgICAgXCJUXCIgKyB0b1BhZGRlZFN0cmluZygyLCBob3VycykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXG4gICAgICAgICAgICAgICAgICAvLyBNaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUuMCwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICAgIFwiLlwiICsgdG9QYWRkZWRTdHJpbmcoMywgbWlsbGlzZWNvbmRzKSArIFwiWlwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFwiZnVuY3Rpb25cIiAmJiAoKGNsYXNzTmFtZSAhPSBudW1iZXJDbGFzcyAmJiBjbGFzc05hbWUgIT0gc3RyaW5nQ2xhc3MgJiYgY2xhc3NOYW1lICE9IGFycmF5Q2xhc3MpIHx8IGlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpKSB7XG4gICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBhZGRzIG5vbi1zdGFuZGFyZCBgdG9KU09OYCBtZXRob2RzIHRvIHRoZVxuICAgICAgICAgICAgICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXG4gICAgICAgICAgICAgIC8vIGlnbm9yZXMgYWxsIGB0b0pTT05gIG1ldGhvZHMgb24gdGhlc2Ugb2JqZWN0cyB1bmxlc3MgdGhleSBhcmVcbiAgICAgICAgICAgICAgLy8gZGVmaW5lZCBkaXJlY3RseSBvbiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIElmIGEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gd2FzIHByb3ZpZGVkLCBjYWxsIGl0IHRvIG9idGFpbiB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vIGZvciBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYm9vbGVhbkNsYXNzKSB7XG4gICAgICAgICAgICAvLyBCb29sZWFucyBhcmUgcmVwcmVzZW50ZWQgbGl0ZXJhbGx5LlxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBgSW5maW5pdHlgIGFuZCBgTmFOYCBhcmUgc2VyaWFsaXplZCBhc1xuICAgICAgICAgICAgLy8gYFwibnVsbFwiYC5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwID8gXCJcIiArIHZhbHVlIDogXCJudWxsXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFN0cmluZ3MgYXJlIGRvdWJsZS1xdW90ZWQgYW5kIGVzY2FwZWQuXG4gICAgICAgICAgICByZXR1cm4gcXVvdGUoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAvLyBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBzdGFjay5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgYW5kIGluZGVudCBvbmUgYWRkaXRpb25hbCBsZXZlbC5cbiAgICAgICAgICAgIHByZWZpeCA9IGluZGVudGF0aW9uO1xuICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXG4gICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHNlcmlhbGl6ZShpbmRleCwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwiW1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJdXCIgOiAoXCJbXCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJdXCIpKSA6IFwiW11cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxuICAgICAgICAgICAgICAvLyBlaXRoZXIgYSB1c2VyLXNwZWNpZmllZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLCBvciB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgIC8vIGl0c2VsZi5cbiAgICAgICAgICAgICAgZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNlcmlhbGl6ZShwcm9wZXJ0eSwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xuICAgICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XG4gICAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IGBtZW1iZXJgIHtxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIn1cbiAgICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXCJcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBcImBzcGFjZWAgY2hhcmFjdGVyXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXG4gICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIsIG5vdCB0aGUgYHNwYWNlYCB7d2lkdGh9IGFyZ3VtZW50IHByb3ZpZGVkIHRvXG4gICAgICAgICAgICAgICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFwiOlwiICsgKHdoaXRlc3BhY2UgPyBcIiBcIiA6IFwiXCIpICsgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwie1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJ9XCIgOiAoXCJ7XCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJ9XCIpKSA6IFwie31cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhlIHRyYXZlcnNlZCBvYmplY3Qgc3RhY2suXG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04uc3RyaW5naWZ5YC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcywgY2xhc3NOYW1lO1xuICAgICAgICAgIGlmIChvYmplY3RUeXBlc1t0eXBlb2YgZmlsdGVyXSAmJiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbChmaWx0ZXIpKSA9PSBmdW5jdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBwcm9wZXJ0eSBuYW1lcyBhcnJheSBpbnRvIGEgbWFrZXNoaWZ0IHNldC5cbiAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGZpbHRlci5sZW5ndGgsIHZhbHVlOyBpbmRleCA8IGxlbmd0aDsgdmFsdWUgPSBmaWx0ZXJbaW5kZXgrK10sICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkpLCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSAmJiAocHJvcGVydGllc1t2YWx1ZV0gPSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHdpZHRoKSkgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xuICAgICAgICAgICAgICAvLyBgd2lkdGhgIG51bWJlciBvZiBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICBpZiAoKHdpZHRoIC09IHdpZHRoICUgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuICAgICAgICAgIC8vIChgXCJcImApIG9ubHkgaWYgdGhleSBhcmUgdXNlZCBkaXJlY3RseSB3aXRoaW4gYW4gb2JqZWN0IG1lbWJlciBsaXN0XG4gICAgICAgICAgLy8gKGUuZy4sIGAhKFwiXCIgaW4geyBcIlwiOiAxfSlgKS5cbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBQdWJsaWM6IFBhcnNlcyBhIEpTT04gc291cmNlIHN0cmluZy5cbiAgICAgIGlmICghaGFzKFwianNvbi1wYXJzZVwiKSkge1xuICAgICAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxuICAgICAgICAvLyBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIFVuZXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcIicsXG4gICAgICAgICAgNDc6IFwiL1wiLFxuICAgICAgICAgIDk4OiBcIlxcYlwiLFxuICAgICAgICAgIDExNjogXCJcXHRcIixcbiAgICAgICAgICAxMTA6IFwiXFxuXCIsXG4gICAgICAgICAgMTAyOiBcIlxcZlwiLFxuICAgICAgICAgIDExNDogXCJcXHJcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgdmFyIEluZGV4LCBTb3VyY2U7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxuICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxuICAgICAgICAvLyB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLiBBIHRva2VuIG1heSBiZSBhIHN0cmluZywgbnVtYmVyLCBgbnVsbGBcbiAgICAgICAgLy8gbGl0ZXJhbCwgb3IgQm9vbGVhbiBsaXRlcmFsLlxuICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBTb3VyY2UsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsIHZhbHVlLCBiZWdpbiwgcG9zaXRpb24sIGlzU2lnbmVkLCBjaGFyQ29kZTtcbiAgICAgICAgICB3aGlsZSAoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTM6IGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcbiAgICAgICAgICAgICAgICAvLyBmZWVkcywgYW5kIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjM6IGNhc2UgMTI1OiBjYXNlIDkxOiBjYXNlIDkzOiBjYXNlIDU4OiBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcHVuY3R1YXRvciB0b2tlbiAoYHtgLCBgfWAsIGBbYCwgYF1gLCBgOmAsIG9yIGAsYCkgYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoYXJJbmRleEJ1Z2d5ID8gc291cmNlLmNoYXJBdChJbmRleCkgOiBzb3VyY2VbSW5kZXhdO1xuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAgIC8vIGBcImAgZGVsaW1pdHMgYSBKU09OIHN0cmluZzsgYWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gcGFyc2luZyB0aGUgc3RyaW5nLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzIGFuZFxuICAgICAgICAgICAgICAgIC8vIGVuZC1vZi1zdHJpbmcgdG9rZW5zLlxuICAgICAgICAgICAgICAgIGZvciAodmFsdWUgPSBcIkBcIiwgSW5kZXgrKzsgSW5kZXggPCBsZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGFuIHRoZSBzcGFjZSBjaGFyYWN0ZXIpIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PSA5Mikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHJldmVyc2Ugc29saWR1cyAoYFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRyb2wgY2hhcmFjdGVyIChpbmNsdWRpbmcgYFwiYCwgYFxcYCwgYW5kIGAvYCkgb3IgVW5pY29kZVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkyOiBjYXNlIDM0OiBjYXNlIDQ3OiBjYXNlIDk4OiBjYXNlIDExNjogY2FzZSAxMTA6IGNhc2UgMTAyOiBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFVuZXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIHZhbGlkYXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCBjb2RlIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4ICsgNDsgSW5kZXggPCBwb3NpdGlvbjsgSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2Vuc2l0aXZlKSB0aGF0IGZvcm0gYSBzaW5nbGUgaGV4YWRlY2ltYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3IHx8IGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEwMiB8fCBjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA3MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBmcm9tQ2hhckNvZGUoXCIweFwiICsgc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQW4gdW5lc2NhcGVkIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXIgbWFya3MgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlcmUgYSBzdHJpbmcgaXMgdmFsaWQuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyQ29kZSA+PSAzMiAmJiBjaGFyQ29kZSAhPSA5MiAmJiBjaGFyQ29kZSAhPSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzdHJpbmcgYXMtaXMuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmQgcmV0dXJuIHRoZSByZXZpdmVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVudGVybWluYXRlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBudW1iZXJzIGFuZCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgbmVnYXRpdmUgc2lnbiwgaWYgb25lIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHplcm9lcyBhcmUgaW50ZXJwcmV0ZWQgYXMgb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBpbnRlZ2VyIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgIGZvciAoOyBJbmRleCA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBJbmRleCsrKTtcbiAgICAgICAgICAgICAgICAgIC8vIEZsb2F0cyBjYW5ub3QgY29udGFpbiBhIGxlYWRpbmcgZGVjaW1hbCBwb2ludDsgaG93ZXZlciwgdGhpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZSBpcyBhbHJlYWR5IGFjY291bnRlZCBmb3IgYnkgdGhlIHBhcnNlci5cbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gNDYpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZGVjaW1hbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCB0cmFpbGluZyBkZWNpbWFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGV4cG9uZW50cy4gVGhlIGBlYCBkZW5vdGluZyB0aGUgZXhwb25lbnQgaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAxMDEgfHwgY2hhckNvZGUgPT0gNjkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0MyB8fCBjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGV4cG9uZW50aWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBlbXB0eSBleHBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdGhlIHBhcnNlZCB2YWx1ZSB0byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICtzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQSBuZWdhdGl2ZSBzaWduIG1heSBvbmx5IHByZWNlZGUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICBpZiAoaXNTaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGB0cnVlYCwgYGZhbHNlYCwgYW5kIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNSkgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA1O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVucmVjb2duaXplZCB0b2tlbi5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNlbnRpbmVsIGAkYCBjaGFyYWN0ZXIgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXG4gICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBQYXJzZXMgYSBKU09OIGB2YWx1ZWAgdG9rZW4uXG4gICAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cywgaGFzTWVtYmVycztcbiAgICAgICAgICBpZiAodmFsdWUgPT0gXCIkXCIpIHtcbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0LlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFwiQFwiKSB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VudGluZWwgYEBgIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyc2Ugb2JqZWN0IGFuZCBhcnJheSBsaXRlcmFscy5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIltcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IG1hcmtzIHRoZSBlbmQgb2YgdGhlIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5leHQuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBhcnJheSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbGlzaW9ucyBhbmQgbGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwie1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBjdXJseSBicmFjZSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgbWVtYmVycywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0b3IuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggb2JqZWN0IG1lbWJlci5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlZCBzdHJpbmdzLCBhbmQgYSBgOmAgbXVzdCBzZXBhcmF0ZSBlYWNoIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gbmFtZSBhbmQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiIHx8IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1t2YWx1ZS5zbGljZSgxKV0gPSBnZXQobGV4KCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0b2tlbiBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxuICAgICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB3YWxrKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXG4gICAgICAgIC8vIGBjYWxsYmFja2AgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBXYWxrKGhvbGRlciwgbmFtZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XSwgbGVuZ3RoO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gYGZvckVhY2hgIGNhbid0IGJlIHVzZWQgdG8gdHJhdmVyc2UgYW4gYXJyYXkgaW4gT3BlcmEgPD0gOC41NFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgXG4gICAgICAgICAgICAvLyBmb3IgYXJyYXkgaW5kaWNlcyAoZS5nLiwgYCFbMSwgMiwgM10uaGFzT3duUHJvcGVydHkoXCIwXCIpYCkuXG4gICAgICAgICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBsZW5ndGgsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gICAgICAgICAgSW5kZXggPSAwO1xuICAgICAgICAgIFNvdXJjZSA9IFwiXCIgKyBzb3VyY2U7XG4gICAgICAgICAgcmVzdWx0ID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAvLyBJZiBhIEpTT04gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cbiAgICAgICAgICBpZiAobGV4KCkgIT0gXCIkXCIpIHtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSByZXN1bHQsIHZhbHVlKSwgXCJcIiwgY2FsbGJhY2spIDogcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHNbXCJydW5JbkNvbnRleHRcIl0gPSBydW5JbkNvbnRleHQ7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH1cblxuICBpZiAoZnJlZUV4cG9ydHMgJiYgIWlzTG9hZGVyKSB7XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBlbnZpcm9ubWVudHMuXG4gICAgcnVuSW5Db250ZXh0KHJvb3QsIGZyZWVFeHBvcnRzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFeHBvcnQgZm9yIHdlYiBicm93c2VycyBhbmQgSmF2YVNjcmlwdCBlbmdpbmVzLlxuICAgIHZhciBuYXRpdmVKU09OID0gcm9vdC5KU09OLFxuICAgICAgICBwcmV2aW91c0pTT04gPSByb290W1wiSlNPTjNcIl0sXG4gICAgICAgIGlzUmVzdG9yZWQgPSBmYWxzZTtcblxuICAgIHZhciBKU09OMyA9IHJ1bkluQ29udGV4dChyb290LCAocm9vdFtcIkpTT04zXCJdID0ge1xuICAgICAgLy8gUHVibGljOiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGFuZFxuICAgICAgLy8gcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEpTT04zYCBvYmplY3QuXG4gICAgICBcIm5vQ29uZmxpY3RcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUmVzdG9yZWQpIHtcbiAgICAgICAgICBpc1Jlc3RvcmVkID0gdHJ1ZTtcbiAgICAgICAgICByb290LkpTT04gPSBuYXRpdmVKU09OO1xuICAgICAgICAgIHJvb3RbXCJKU09OM1wiXSA9IHByZXZpb3VzSlNPTjtcbiAgICAgICAgICBuYXRpdmVKU09OID0gcHJldmlvdXNKU09OID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTjM7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgcm9vdC5KU09OID0ge1xuICAgICAgXCJwYXJzZVwiOiBKU09OMy5wYXJzZSxcbiAgICAgIFwic3RyaW5naWZ5XCI6IEpTT04zLnN0cmluZ2lmeVxuICAgIH07XG4gIH1cblxuICAvLyBFeHBvcnQgZm9yIGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy5cbiAgaWYgKGlzTG9hZGVyKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBKU09OMztcbiAgICB9KTtcbiAgfVxufSkuY2FsbCh0aGlzKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEVsZW1lbnRzLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXG5cdC8qKlxuXHQgKiBDb252ZW5pZW5jZSBtZXRob2RzIGZvciBjcmVhdGluZyB2YXJpb3VzIGVsZW1lbnRzIHVzZWQgYnkgUHJlbGFvZEpTLlxuXHQgKlxuXHQgKiBAY2xhc3MgRG9tVXRpbHNcblx0ICovXG5cdHZhciBzID0ge307XG5cblx0cy5hID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHMuZWwoXCJhXCIpO1xuXHR9XG5cblx0cy5zdmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gcy5lbChcInN2Z1wiKTtcblx0fVxuXG5cdHMub2JqZWN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHMuZWwoXCJvYmplY3RcIik7XG5cdH1cblxuXHRzLmltYWdlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHMuZWwoXCJpbWFnZVwiKTtcblx0fVxuXG5cdHMuaW1nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHMuZWwoXCJpbWdcIik7XG5cdH1cblxuXHRzLnN0eWxlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHMuZWwoXCJzdHlsZVwiKTtcblx0fVxuXG5cdHMubGluayA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzLmVsKFwibGlua1wiKTtcblx0fVxuXG5cdHMuc2NyaXB0ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHMuZWwoXCJzY3JpcHRcIik7XG5cdH1cblxuXHRzLmF1ZGlvID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHMuZWwoXCJhdWRpb1wiKTtcblx0fVxuXG5cdHMudmlkZW8gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gcy5lbChcInZpZGVvXCIpO1xuXHR9XG5cblx0cy50ZXh0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUpO1xuXHR9XG5cblx0cy5lbCA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcblx0fVxuXG5cdGNyZWF0ZWpzLkVsZW1lbnRzID0gcztcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFVSTFV0aWxzLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXG5cdC8qKlxuXHQgKiBVdGlsaXRpZXMgdGhhdCBhc3Npc3Qgd2l0aCBwYXJzaW5nIGxvYWQgaXRlbXMsIGFuZCBkZXRlcm1pbmluZyBmaWxlIHR5cGVzLCBldGMuXG5cdCAqIEBjbGFzcyBVUkxVdGlsc1xuXHQgKi9cblx0dmFyIHMgPSB7fTtcblxuXHQvKipcblx0ICogVGhlIFJlZ3VsYXIgRXhwcmVzc2lvbiB1c2VkIHRvIHRlc3QgZmlsZSBVUkxTIGZvciBhbiBhYnNvbHV0ZSBwYXRoLlxuXHQgKiBAcHJvcGVydHkgQUJTT0xVVEVfUEFUSFxuXHQgKiBAdHlwZSB7UmVnRXhwfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLkFCU09MVVRFX1BBVFQgPSAvXig/Olxcdys6KT9cXC97Mn0vaTtcblxuXHQvKipcblx0ICogVGhlIFJlZ3VsYXIgRXhwcmVzc2lvbiB1c2VkIHRvIHRlc3QgZmlsZSBVUkxTIGZvciBhIHJlbGF0aXZlIHBhdGguXG5cdCAqIEBwcm9wZXJ0eSBSRUxBVElWRV9QQVRIXG5cdCAqIEB0eXBlIHtSZWdFeHB9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuUkVMQVRJVkVfUEFUVCA9ICgvXlsuL10qP1xcLy9pKTtcblxuXHQvKipcblx0ICogVGhlIFJlZ3VsYXIgRXhwcmVzc2lvbiB1c2VkIHRvIHRlc3QgZmlsZSBVUkxTIGZvciBhbiBleHRlbnNpb24uIE5vdGUgdGhhdCBVUklzIG11c3QgYWxyZWFkeSBoYXZlIHRoZSBxdWVyeSBzdHJpbmdcblx0ICogcmVtb3ZlZC5cblx0ICogQHByb3BlcnR5IEVYVEVOU0lPTl9QQVRUXG5cdCAqIEB0eXBlIHtSZWdFeHB9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuRVhURU5TSU9OX1BBVFQgPSAvXFwvP1teL10rXFwuKFxcd3sxLDV9KSQvaTtcblxuXHQvKipcblx0ICogUGFyc2UgYSBmaWxlIHBhdGggdG8gZGV0ZXJtaW5lIHRoZSBpbmZvcm1hdGlvbiB3ZSBuZWVkIHRvIHdvcmsgd2l0aCBpdC4gQ3VycmVudGx5LCBQcmVsb2FkSlMgbmVlZHMgdG8ga25vdzpcblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPklmIHRoZSBwYXRoIGlzIGFic29sdXRlLiBBYnNvbHV0ZSBwYXRocyBzdGFydCB3aXRoIGEgcHJvdG9jb2wgKHN1Y2ggYXMgYGh0dHA6Ly9gLCBgZmlsZTovL2AsIG9yXG5cdCAqICAgICBgLy9uZXR3b3JrUGF0aGApPC9saT5cblx0ICogICAgIDxsaT5JZiB0aGUgcGF0aCBpcyByZWxhdGl2ZS4gUmVsYXRpdmUgcGF0aHMgc3RhcnQgd2l0aCBgLi4vYCBvciBgL3BhdGhgIChvciBzaW1pbGFyKTwvbGk+XG5cdCAqICAgICA8bGk+VGhlIGZpbGUgZXh0ZW5zaW9uLiBUaGlzIGlzIGRldGVybWluZWQgYnkgdGhlIGZpbGVuYW1lIHdpdGggYW4gZXh0ZW5zaW9uLiBRdWVyeSBzdHJpbmdzIGFyZSBkcm9wcGVkLCBhbmRcblx0ICogICAgIHRoZSBmaWxlIHBhdGggaXMgZXhwZWN0ZWQgdG8gZm9sbG93IHRoZSBmb3JtYXQgYG5hbWUuZXh0YC48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiBAbWV0aG9kIHBhcnNlVVJJXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IEFuIE9iamVjdCB3aXRoIGFuIGBhYnNvbHV0ZWAgYW5kIGByZWxhdGl2ZWAgQm9vbGVhbiB2YWx1ZXMsXG5cdCAqIFx0dGhlIHBpZWNlcyBvZiB0aGUgcGF0aCAocHJvdG9jb2wsIGhvc3RuYW1lLCBwb3J0LCBwYXRobmFtZSwgc2VhcmNoLCBoYXNoLCBob3N0KVxuXHQgKiBcdGFzIHdlbGwgYXMgYW4gb3B0aW9uYWwgJ2V4dGVuc2lvbmAgcHJvcGVydHksIHdoaWNoIGlzIHRoZSBsb3dlcmNhc2UgZXh0ZW5zaW9uLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLnBhcnNlVVJJID0gZnVuY3Rpb24gKHBhdGgpIHtcblx0XHR2YXIgaW5mbyA9IHtcblx0XHRcdGFic29sdXRlOiBmYWxzZSxcblx0XHRcdHJlbGF0aXZlOiBmYWxzZSxcblx0XHRcdHByb3RvY29sOiBudWxsLFxuXHRcdFx0aG9zdG5hbWU6IG51bGwsXG5cdFx0XHRwb3J0OiBudWxsLFxuXHRcdFx0cGF0aG5hbWU6IG51bGwsXG5cdFx0XHRzZWFyY2g6IG51bGwsXG5cdFx0XHRoYXNoOiBudWxsLFxuXHRcdFx0aG9zdDogbnVsbFxuXHRcdH07XG5cblx0XHRpZiAocGF0aCA9PSBudWxsKSB7IHJldHVybiBpbmZvOyB9XG5cblx0XHQvLyBJbmplY3QgdGhlIHBhdGggcGFydHMuXG5cdFx0dmFyIHBhcnNlciA9IGNyZWF0ZWpzLkVsZW1lbnRzLmEoKTtcblx0XHRwYXJzZXIuaHJlZiA9IHBhdGg7XG5cblx0XHRmb3IgKHZhciBuIGluIGluZm8pIHtcblx0XHRcdGlmIChuIGluIHBhcnNlcikge1xuXHRcdFx0XHRpbmZvW25dID0gcGFyc2VyW25dO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIERyb3AgdGhlIHF1ZXJ5IHN0cmluZ1xuXHRcdHZhciBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKFwiP1wiKTtcblx0XHRpZiAocXVlcnlJbmRleCA+IC0xKSB7XG5cdFx0XHRwYXRoID0gcGF0aC5zdWJzdHIoMCwgcXVlcnlJbmRleCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJzb2x1dGVcblx0XHR2YXIgbWF0Y2g7XG5cdFx0aWYgKHMuQUJTT0xVVEVfUEFUVC50ZXN0KHBhdGgpKSB7XG5cdFx0XHRpbmZvLmFic29sdXRlID0gdHJ1ZTtcblxuXHRcdFx0Ly8gUmVsYXRpdmVcblx0XHR9IGVsc2UgaWYgKHMuUkVMQVRJVkVfUEFUVC50ZXN0KHBhdGgpKSB7XG5cdFx0XHRpbmZvLnJlbGF0aXZlID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBFeHRlbnNpb25cblx0XHRpZiAobWF0Y2ggPSBwYXRoLm1hdGNoKHMuRVhURU5TSU9OX1BBVFQpKSB7XG5cdFx0XHRpbmZvLmV4dGVuc2lvbiA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGluZm87XG5cdH07XG5cblx0LyoqXG5cdCAqIEZvcm1hdHMgYW4gb2JqZWN0IGludG8gYSBxdWVyeSBzdHJpbmcgZm9yIGVpdGhlciBhIFBPU1Qgb3IgR0VUIHJlcXVlc3QuXG5cdCAqIEBtZXRob2QgZm9ybWF0UXVlcnlTdHJpbmdcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgdG8gY29udmVydCB0byBhIHF1ZXJ5IHN0cmluZy5cblx0ICogQHBhcmFtIHtBcnJheX0gW3F1ZXJ5XSBFeGlzdGluZyBuYW1lL3ZhbHVlIHBhaXJzIHRvIGFwcGVuZCBvbiB0byB0aGlzIHF1ZXJ5LlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmZvcm1hdFF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24gKGRhdGEsIHF1ZXJ5KSB7XG5cdFx0aWYgKGRhdGEgPT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3Qgc3BlY2lmeSBkYXRhLlwiKTtcblx0XHR9XG5cdFx0dmFyIHBhcmFtcyA9IFtdO1xuXHRcdGZvciAodmFyIG4gaW4gZGF0YSkge1xuXHRcdFx0cGFyYW1zLnB1c2gobiArIFwiPVwiICsgZXNjYXBlKGRhdGFbbl0pKTtcblx0XHR9XG5cdFx0aWYgKHF1ZXJ5KSB7XG5cdFx0XHRwYXJhbXMgPSBwYXJhbXMuY29uY2F0KHF1ZXJ5KTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcmFtcy5qb2luKFwiJlwiKTtcblx0fTtcblxuXHQvKipcblx0ICogQSB1dGlsaXR5IG1ldGhvZCB0aGF0IGJ1aWxkcyBhIGZpbGUgcGF0aCB1c2luZyBhIHNvdXJjZSBhbmQgYSBkYXRhIG9iamVjdCwgYW5kIGZvcm1hdHMgaXQgaW50byBhIG5ldyBwYXRoLlxuXHQgKiBAbWV0aG9kIGJ1aWxkVVJJXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBwYXRoIHRvIGFkZCB2YWx1ZXMgdG8uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gT2JqZWN0IHVzZWQgdG8gYXBwZW5kIHZhbHVlcyB0byB0aGlzIHJlcXVlc3QgYXMgYSBxdWVyeSBzdHJpbmcuIEV4aXN0aW5nIHBhcmFtZXRlcnMgb24gdGhlXG5cdCAqIHBhdGggd2lsbCBiZSBwcmVzZXJ2ZWQuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IEEgZm9ybWF0dGVkIHN0cmluZyB0aGF0IGNvbnRhaW5zIHRoZSBwYXRoIGFuZCB0aGUgc3VwcGxpZWQgcGFyYW1ldGVycy5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5idWlsZFVSSSA9IGZ1bmN0aW9uIChzcmMsIGRhdGEpIHtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gc3JjO1xuXHRcdH1cblxuXHRcdHZhciBxdWVyeSA9IFtdO1xuXHRcdHZhciBpZHggPSBzcmMuaW5kZXhPZihcIj9cIik7XG5cblx0XHRpZiAoaWR4ICE9IC0xKSB7XG5cdFx0XHR2YXIgcSA9IHNyYy5zbGljZShpZHggKyAxKTtcblx0XHRcdHF1ZXJ5ID0gcXVlcnkuY29uY2F0KHEuc3BsaXQoXCImXCIpKTtcblx0XHR9XG5cblx0XHRpZiAoaWR4ICE9IC0xKSB7XG5cdFx0XHRyZXR1cm4gc3JjLnNsaWNlKDAsIGlkeCkgKyBcIj9cIiArIHRoaXMuZm9ybWF0UXVlcnlTdHJpbmcoZGF0YSwgcXVlcnkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gc3JjICsgXCI/XCIgKyB0aGlzLmZvcm1hdFF1ZXJ5U3RyaW5nKGRhdGEsIHF1ZXJ5KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgaXNDcm9zc0RvbWFpblxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBBIGxvYWQgaXRlbSB3aXRoIGEgYHNyY2AgcHJvcGVydHkuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBsb2FkIGl0ZW0gaXMgbG9hZGluZyBmcm9tIGEgZGlmZmVyZW50IGRvbWFpbiB0aGFuIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzQ3Jvc3NEb21haW4gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHZhciB0YXJnZXQgPSBjcmVhdGVqcy5FbGVtZW50cy5hKCk7XG5cdFx0dGFyZ2V0LmhyZWYgPSBpdGVtLnNyYztcblxuXHRcdHZhciBob3N0ID0gY3JlYXRlanMuRWxlbWVudHMuYSgpO1xuXHRcdGhvc3QuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cblx0XHR2YXIgY3Jvc3Nkb21haW4gPSAodGFyZ2V0Lmhvc3RuYW1lICE9IFwiXCIpICYmXG5cdFx0XHQodGFyZ2V0LnBvcnQgIT0gaG9zdC5wb3J0IHx8XG5cdFx0XHR0YXJnZXQucHJvdG9jb2wgIT0gaG9zdC5wcm90b2NvbCB8fFxuXHRcdFx0dGFyZ2V0Lmhvc3RuYW1lICE9IGhvc3QuaG9zdG5hbWUpO1xuXHRcdHJldHVybiBjcm9zc2RvbWFpbjtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBpc0xvY2FsXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIEEgbG9hZCBpdGVtIHdpdGggYSBgc3JjYCBwcm9wZXJ0eVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgbG9hZCBpdGVtIGlzIGxvYWRpbmcgZnJvbSB0aGUgXCJmaWxlOlwiIHByb3RvY29sLiBBc3N1bWUgdGhhdCB0aGUgaG9zdCBtdXN0IGJlIGxvY2FsIGFzXG5cdCAqIHdlbGwuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNMb2NhbCA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0dmFyIHRhcmdldCA9IGNyZWF0ZWpzLkVsZW1lbnRzLmEoKTtcblx0XHR0YXJnZXQuaHJlZiA9IGl0ZW0uc3JjO1xuXHRcdHJldHVybiB0YXJnZXQuaG9zdG5hbWUgPT0gXCJcIiAmJiB0YXJnZXQucHJvdG9jb2wgPT0gXCJmaWxlOlwiO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLlVSTFV0aWxzID0gcztcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIERvbVV0aWxzLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXG5cdC8qKlxuXHQgKiBBIGZldyB1dGlsaXRpZXMgZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIGRvbS5cblx0ICogQGNsYXNzIERvbVV0aWxzXG5cdCAqL1xuXHR2YXIgcyA9IHtcblx0XHRjb250YWluZXI6IG51bGxcblx0fTtcblxuXHRzLmFwcGVuZFRvSGVhZCA9IGZ1bmN0aW9uIChlbCkge1xuXHRcdHMuZ2V0SGVhZCgpLmFwcGVuZENoaWxkKGVsKTtcblx0fVxuXG5cdHMuYXBwZW5kVG9Cb2R5ID0gZnVuY3Rpb24gKGVsKSB7XG5cdFx0aWYgKHMuY29udGFpbmVyID09IG51bGwpIHtcblx0XHRcdHMuY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRcdHMuY29udGFpbmVyLmlkID0gXCJwcmVsb2FkanMtY29udGFpbmVyXCI7XG5cdFx0XHR2YXIgc3R5bGUgPSBzLmNvbnRhaW5lci5zdHlsZTtcblx0XHRcdHN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuXHRcdFx0c3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0XHRzdHlsZS53aWR0aCA9IHMuY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IFwiMTBweFwiO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdFx0c3R5bGUudHJhbnNmb3JtID0gc3R5bGUubXNUcmFuc2Zvcm0gPSBzdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBzdHlsZS5vVHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoLTEwcHgsIC0xMHB4KVwiOyAvL0xNOiBOb3Qgd29ya2luZ1xuXHRcdFx0cy5nZXRCb2R5KCkuYXBwZW5kQ2hpbGQocy5jb250YWluZXIpO1xuXHRcdH1cblx0XHRzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG5cdH1cblxuXHRzLmdldEhlYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuXHR9XG5cblx0cy5nZXRCb2R5ID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXTtcblx0fVxuXG5cdHMucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbihlbCkge1xuXHRcdGlmIChlbC5wYXJlbnQpIHtcblx0XHRcdGVsLnBhcmVudC5yZW1vdmVDaGlsZChlbCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIGl0ZW0gaXMgYSB2YWxpZCBIVE1MSW1hZ2VFbGVtZW50XG5cdCAqIEBtZXRob2QgaXNJbWFnZVRhZ1xuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pc0ltYWdlVGFnID0gZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBpdGVtIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudDtcblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgaXRlbSBpcyBhIHZhbGlkIEhUTUxBdWRpb0VsZW1lbnRcblx0ICogQG1ldGhvZCBpc0F1ZGlvVGFnXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzQXVkaW9UYWcgPSBmdW5jdGlvbihpdGVtKSB7XG5cdFx0aWYgKHdpbmRvdy5IVE1MQXVkaW9FbGVtZW50KSB7XG5cdFx0XHRyZXR1cm4gaXRlbSBpbnN0YW5jZW9mIEhUTUxBdWRpb0VsZW1lbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIGl0ZW0gaXMgYSB2YWxpZCBIVE1MVmlkZW9FbGVtZW50XG5cdCAqIEBtZXRob2QgaXNWaWRlb1RhZ1xuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pc1ZpZGVvVGFnID0gZnVuY3Rpb24oaXRlbSkge1xuXHRcdGlmICh3aW5kb3cuSFRNTFZpZGVvRWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIGl0ZW0gaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdGNyZWF0ZWpzLkRvbVV0aWxzID0gcztcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIERhdGFVdGlscy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblxuXHQvKipcblx0ICogQSBmZXcgZGF0YSB1dGlsaXRpZXMgZm9yIGZvcm1hdHRpbmcgZGlmZmVyZW50IGRhdGEgdHlwZXMuXG5cdCAqIEBjbGFzcyBEYXRhVXRpbHNcblx0ICovXG5cdHZhciBzID0ge307XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIFBhcnNlIFhNTCB1c2luZyB0aGUgRE9NLiBUaGlzIGlzIHJlcXVpcmVkIHdoZW4gcHJlbG9hZGluZyBYTUwgb3IgU1ZHLlxuXHQgKiBAbWV0aG9kIHBhcnNlWE1MXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSByYXcgdGV4dCBvciBYTUwgdGhhdCBpcyBsb2FkZWQgYnkgWEhSLlxuXHQgKiBAcmV0dXJuIHtYTUx9IEFuIFhNTCBkb2N1bWVudFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLnBhcnNlWE1MID0gZnVuY3Rpb24gKHRleHQpIHtcblx0XHR2YXIgeG1sID0gbnVsbDtcblx0XHQvLyBDb2Nvb25KUyBkb2VzIG5vdCBzdXBwb3J0IFhNTCBwYXJzaW5nIHdpdGggZWl0aGVyIG1ldGhvZC5cblxuXHRcdC8vIE1vc3QgYnJvd3NlcnMgd2lsbCB1c2UgRE9NUGFyc2VyXG5cdFx0Ly8gSUUgZmFpbHMgb24gY2VydGFpbiBTVkcgZmlsZXMsIHNvIHdlIGhhdmUgYSBmYWxsYmFjayBiZWxvdy5cblx0XHR0cnkge1xuXHRcdFx0aWYgKHdpbmRvdy5ET01QYXJzZXIpIHtcblx0XHRcdFx0dmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcblx0XHRcdFx0eG1sID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh0ZXh0LCBcInRleHQveG1sXCIpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayBmb3IgSUUgc3VwcG9ydC5cblx0XHRpZiAoIXhtbCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0eG1sID0gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MRE9NXCIpO1xuXHRcdFx0XHR4bWwuYXN5bmMgPSBmYWxzZTtcblx0XHRcdFx0eG1sLmxvYWRYTUwodGV4dCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHhtbCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHhtbDtcblx0fTtcblxuXHQvKipcblx0ICogUGFyc2UgYSBzdHJpbmcgaW50byBhbiBPYmplY3QuXG5cdCAqIEBtZXRob2QgcGFyc2VKU09OXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgbG9hZGVkIEpTT04gc3RyaW5nXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IEEgSmF2YVNjcmlwdCBvYmplY3QuXG5cdCAqL1xuXHRzLnBhcnNlSlNPTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vIFRPRE87IEhhbmRsZSB0aGlzIHdpdGggYSBjdXN0b20gZXJyb3I/XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH1cblx0fTtcblxuXHRjcmVhdGVqcy5EYXRhVXRpbHMgPSBzO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVHlwZXMuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbndpbmRvdy5jcmVhdGVqcyA9IHdpbmRvdy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHR2YXIgcyA9IHt9O1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBnZW5lcmljIGJpbmFyeSB0eXBlcy4gTm90ZSB0aGF0IGltYWdlcyBhcmUgbG9hZGVkIGFzIGJpbmFyeSBmaWxlcyB3aGVuIHVzaW5nIFhIUi5cblx0ICogQHByb3BlcnR5IEJJTkFSWVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBiaW5hcnlcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuQklOQVJZID0gXCJiaW5hcnlcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgY3NzIGZpbGVzLiBDU1MgZmlsZXMgYXJlIGxvYWRlZCB1c2luZyBhICZsdDtsaW5rJmd0OyB3aGVuIGxvYWRlZCB3aXRoIFhIUiwgb3IgYVxuXHQgKiAmbHQ7c3R5bGUmZ3Q7IHRhZyB3aGVuIGxvYWRlZCB3aXRoIHRhZ3MuXG5cdCAqIEBwcm9wZXJ0eSBDU1Ncblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgY3NzXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLkNTUyA9IFwiY3NzXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIGZvbnQgZmlsZXMuXG5cdCAqIEBwcm9wZXJ0eSBGT05UXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGZvbnRcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC45LjBcblx0ICovXG5cdHMuRk9OVCA9IFwiZm9udFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBmb250cyBzcGVjaWZpZWQgd2l0aCBDU1MgKHN1Y2ggYXMgR29vZ2xlIGZvbnRzKVxuXHQgKiBAcHJvcGVydHkgRk9OVENTU1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBmb250Y3NzXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuOS4wXG5cdCAqL1xuXHRzLkZPTlRDU1MgPSBcImZvbnRjc3NcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgaW1hZ2UgZmlsZXMsIHVzdWFsbHkgcG5nLCBnaWYsIG9yIGpwZy9qcGVnLiBJbWFnZXMgYXJlIGxvYWRlZCBpbnRvIGFuICZsdDtpbWFnZSZndDsgdGFnLlxuXHQgKiBAcHJvcGVydHkgSU1BR0Vcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgaW1hZ2Vcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuSU1BR0UgPSBcImltYWdlXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIGphdmFzY3JpcHQgZmlsZXMsIHVzdWFsbHkgd2l0aCB0aGUgXCJqc1wiIGZpbGUgZXh0ZW5zaW9uLiBKYXZhU2NyaXB0IGZpbGVzIGFyZSBsb2FkZWQgaW50byBhXG5cdCAqICZsdDtzY3JpcHQmZ3Q7IHRhZy5cblx0ICpcblx0ICogU2luY2UgdmVyc2lvbiAwLjQuMSssIGR1ZSB0byBob3cgdGFnLWxvYWRlZCBzY3JpcHRzIHdvcmssIGFsbCBKYXZhU2NyaXB0IGZpbGVzIGFyZSBhdXRvbWF0aWNhbGx5IGluamVjdGVkIGludG9cblx0ICogdGhlIGJvZHkgb2YgdGhlIGRvY3VtZW50IHRvIG1haW50YWluIHBhcml0eSBiZXR3ZWVuIFhIUiBhbmQgdGFnLWxvYWRlZCBzY3JpcHRzLiBJbiB2ZXJzaW9uIDAuNC4wIGFuZCBlYXJsaWVyLFxuXHQgKiBvbmx5IHRhZy1sb2FkZWQgc2NyaXB0cyBhcmUgaW5qZWN0ZWQuXG5cdCAqIEBwcm9wZXJ0eSBKQVZBU0NSSVBUXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGphdmFzY3JpcHRcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuSkFWQVNDUklQVCA9IFwiamF2YXNjcmlwdFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBqc29uIGZpbGVzLCB1c3VhbGx5IHdpdGggdGhlIFwianNvblwiIGZpbGUgZXh0ZW5zaW9uLiBKU09OIGRhdGEgaXMgbG9hZGVkIGFuZCBwYXJzZWQgaW50byBhXG5cdCAqIEphdmFTY3JpcHQgb2JqZWN0LiBOb3RlIHRoYXQgaWYgYSBgY2FsbGJhY2tgIGlzIHByZXNlbnQgb24gdGhlIGxvYWQgaXRlbSwgdGhlIGZpbGUgd2lsbCBiZSBsb2FkZWQgd2l0aCBKU09OUCxcblx0ICogbm8gbWF0dGVyIHdoYXQgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9wcmVmZXJYSFI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaXMgc2V0IHRvLCBhbmQgdGhlIEpTT05cblx0ICogbXVzdCBjb250YWluIGEgbWF0Y2hpbmcgd3JhcHBlciBmdW5jdGlvbi5cblx0ICogQHByb3BlcnR5IEpTT05cblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQganNvblxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5KU09OID0gXCJqc29uXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIGpzb25wIGZpbGVzLCB1c3VhbGx5IHdpdGggdGhlIFwianNvblwiIGZpbGUgZXh0ZW5zaW9uLiBKU09OIGRhdGEgaXMgbG9hZGVkIGFuZCBwYXJzZWQgaW50byBhXG5cdCAqIEphdmFTY3JpcHQgb2JqZWN0LiBZb3UgYXJlIHJlcXVpcmVkIHRvIHBhc3MgYSBjYWxsYmFjayBwYXJhbWV0ZXIgdGhhdCBtYXRjaGVzIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGluIHRoZSBKU09OLlxuXHQgKiBOb3RlIHRoYXQgSlNPTlAgd2lsbCBhbHdheXMgYmUgdXNlZCBpZiB0aGVyZSBpcyBhIGNhbGxiYWNrIHByZXNlbnQsIG5vIG1hdHRlciB3aGF0IHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvcHJlZmVyWEhSOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHByb3BlcnR5IGlzIHNldCB0by5cblx0ICogQHByb3BlcnR5IEpTT05QXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGpzb25wXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLkpTT05QID0gXCJqc29ucFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBqc29uLWJhc2VkIG1hbmlmZXN0IGZpbGVzLCB1c3VhbGx5IHdpdGggdGhlIFwianNvblwiIGZpbGUgZXh0ZW5zaW9uLiBUaGUgSlNPTiBkYXRhIGlzIGxvYWRlZFxuXHQgKiBhbmQgcGFyc2VkIGludG8gYSBKYXZhU2NyaXB0IG9iamVjdC4gUHJlbG9hZEpTIHdpbGwgdGhlbiBsb29rIGZvciBhIFwibWFuaWZlc3RcIiBwcm9wZXJ0eSBpbiB0aGUgSlNPTiwgd2hpY2ggaXMgYW5cblx0ICogQXJyYXkgb2YgZmlsZXMgdG8gbG9hZCwgZm9sbG93aW5nIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuIElmIGEgXCJjYWxsYmFja1wiIGlzIHNwZWNpZmllZCBvbiB0aGUgbWFuaWZlc3Qgb2JqZWN0LCB0aGVuIGl0IHdpbGwgYmUgbG9hZGVkIHVzaW5nIEpTT05QIGluc3RlYWQsXG5cdCAqIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3ByZWZlclhIUjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpcyBzZXQgdG8uXG5cdCAqIEBwcm9wZXJ0eSBNQU5JRkVTVFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBtYW5pZmVzdFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5NQU5JRkVTVCA9IFwibWFuaWZlc3RcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3Igc291bmQgZmlsZXMsIHVzdWFsbHkgbXAzLCBvZ2csIG9yIHdhdi4gV2hlbiBsb2FkaW5nIHZpYSB0YWdzLCBhdWRpbyBpcyBsb2FkZWQgaW50byBhblxuXHQgKiAmbHQ7YXVkaW8mZ3Q7IHRhZy5cblx0ICogQHByb3BlcnR5IFNPVU5EXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHNvdW5kXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLlNPVU5EID0gXCJzb3VuZFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciB2aWRlbyBmaWxlcywgdXN1YWxseSBtcDQsIHRzLCBvciBvZ2cuIFdoZW4gbG9hZGluZyB2aWEgdGFncywgdmlkZW8gaXMgbG9hZGVkIGludG8gYW5cblx0ICogJmx0O3ZpZGVvJmd0OyB0YWcuXG5cdCAqIEBwcm9wZXJ0eSBWSURFT1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCB2aWRlb1xuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5WSURFTyA9IFwidmlkZW9cIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgU3ByaXRlU2hlZXQgZmlsZXMuIFNwcml0ZVNoZWV0IGZpbGVzIGFyZSBKU09OIGZpbGVzIHRoYXQgY29udGFpbiBzdHJpbmcgaW1hZ2UgcGF0aHMuXG5cdCAqIEBwcm9wZXJ0eSBTUFJJVEVTSEVFVFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBzcHJpdGVzaGVldFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5TUFJJVEVTSEVFVCA9IFwic3ByaXRlc2hlZXRcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgU1ZHIGZpbGVzLlxuXHQgKiBAcHJvcGVydHkgU1ZHXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHN2Z1xuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5TVkcgPSBcInN2Z1wiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciB0ZXh0IGZpbGVzLCB3aGljaCBpcyBhbHNvIHRoZSBkZWZhdWx0IGZpbGUgdHlwZSBpZiB0aGUgdHlwZSBjYW4gbm90IGJlIGRldGVybWluZWQuIFRleHQgaXNcblx0ICogbG9hZGVkIGFzIHJhdyB0ZXh0LlxuXHQgKiBAcHJvcGVydHkgVEVYVFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCB0ZXh0XG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLlRFWFQgPSBcInRleHRcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgeG1sIGZpbGVzLiBYTUwgaXMgbG9hZGVkIGludG8gYW4gWE1MIGRvY3VtZW50LlxuXHQgKiBAcHJvcGVydHkgWE1MXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHhtbFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5YTUwgPSBcInhtbFwiO1xuXG5cdGNyZWF0ZWpzLlR5cGVzID0gcztcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBNZXRob2RzLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG53aW5kb3cuY3JlYXRlanMgPSB3aW5kb3cuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbigpIHtcblx0dmFyIHMgPSB7fTtcblxuXHQvKipcblx0ICogRGVmaW5lcyBhIFBPU1QgcmVxdWVzdCwgdXNlIGZvciBhIG1ldGhvZCB2YWx1ZSB3aGVuIGxvYWRpbmcgZGF0YS5cblx0ICogQHByb3BlcnR5IFBPU1Rcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICogQGRlZmF1bHQgcG9zdFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLlBPU1QgPSBcIlBPU1RcIjtcblxuXHQvKipcblx0ICogRGVmaW5lcyBhIEdFVCByZXF1ZXN0LCB1c2UgZm9yIGEgbWV0aG9kIHZhbHVlIHdoZW4gbG9hZGluZyBkYXRhLlxuXHQgKiBAcHJvcGVydHkgR0VUXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGdldFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLkdFVCA9IFwiR0VUXCI7XG5cblx0Y3JlYXRlanMuTWV0aG9kcyA9IHM7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gTG9hZEl0ZW0uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbndpbmRvdy5jcmVhdGVqcyA9IHdpbmRvdy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIEFsbCBsb2FkZXJzIGFjY2VwdCBhbiBpdGVtIGNvbnRhaW5pbmcgdGhlIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGlzIGNsYXNzLiBJZiBhIHJhdyBvYmplY3QgaXMgcGFzc2VkIGluc3RlYWQsXG5cdCAqIGl0IHdpbGwgbm90IGJlIGFmZmVjdGVkLCBidXQgaXQgbXVzdCBjb250YWluIGF0IGxlYXN0IGEge3sjY3Jvc3NMaW5rIFwic3JjOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5LiBBXG5cdCAqIHN0cmluZyBwYXRoIG9yIEhUTUwgdGFnIGlzIGFsc28gYWNjZXB0YWJsZSwgYnV0IGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYSBMb2FkSXRlbSB1c2luZyB0aGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiY3JlYXRlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCBieSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBAY2xhc3MgTG9hZEl0ZW1cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0ZnVuY3Rpb24gTG9hZEl0ZW0oKSB7XG5cdFx0LyoqXG5cdFx0ICogVGhlIHNvdXJjZSBvZiB0aGUgZmlsZSB0aGF0IGlzIGJlaW5nIGxvYWRlZC4gVGhpcyBwcm9wZXJ0eSBpcyA8Yj5yZXF1aXJlZDwvYj4uIFRoZSBzb3VyY2UgY2FuIGVpdGhlciBiZSBhXG5cdFx0ICogc3RyaW5nIChyZWNvbW1lbmRlZCksIG9yIGFuIEhUTUwgdGFnLlxuXHRcdCAqIFRoaXMgY2FuIGFsc28gYmUgYW4gb2JqZWN0LCBidXQgaW4gdGhhdCBjYXNlIGl0IGhhcyB0byBpbmNsdWRlIGEgdHlwZSBhbmQgYmUgaGFuZGxlZCBieSBhIHBsdWdpbi5cblx0XHQgKiBAcHJvcGVydHkgc3JjXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5zcmMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHR5cGUgZmlsZSB0aGF0IGlzIGJlaW5nIGxvYWRlZC4gVGhlIHR5cGUgb2YgdGhlIGZpbGUgaXMgdXN1YWxseSBpbmZlcnJlZCBieSB0aGUgZXh0ZW5zaW9uLCBidXQgY2FuIGFsc29cblx0XHQgKiBiZSBzZXQgbWFudWFsbHkuIFRoaXMgaXMgaGVscGZ1bCBpbiBjYXNlcyB3aGVyZSBhIGZpbGUgZG9lcyBub3QgaGF2ZSBhbiBleHRlbnNpb24uXG5cdFx0ICogQHByb3BlcnR5IHR5cGVcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnR5cGUgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgaWRlbnRpZmllciB3aGljaCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhlIGxvYWRlZCBvYmplY3QuIElmIG5vbmUgaXMgcHJvdmlkZWQsIHRoaXMgd2lsbCBiZVxuXHRcdCAqIGF1dG9tYXRpY2FsbHkgc2V0IHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJzcmM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IGlkXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5pZCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBEZXRlcm1pbmVzIGlmIGEgbWFuaWZlc3Qgd2lsbCBtYWludGFpbiB0aGUgb3JkZXIgb2YgdGhpcyBpdGVtLCBpbiByZWxhdGlvbiB0byBvdGhlciBpdGVtcyBpbiB0aGUgbWFuaWZlc3Rcblx0XHQgKiB0aGF0IGhhdmUgYWxzbyBzZXQgdGhlIGBtYWludGFpbk9yZGVyYCBwcm9wZXJ0eSB0byBgdHJ1ZWAuIFRoaXMgb25seSBhcHBsaWVzIHdoZW4gdGhlIG1heCBjb25uZWN0aW9ucyBoYXNcblx0XHQgKiBiZWVuIHNldCBhYm92ZSAxICh1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc2V0TWF4Q29ubmVjdGlvbnNcIn19e3svY3Jvc3NMaW5rfX0pLiBFdmVyeXRoaW5nIHdpdGggdGhpc1xuXHRcdCAqIHByb3BlcnR5IHNldCB0byBgZmFsc2VgIHdpbGwgZmluaXNoIGFzIGl0IGlzIGxvYWRlZC4gT3JkZXJlZCBpdGVtcyBhcmUgY29tYmluZWQgd2l0aCBzY3JpcHQgdGFncyBsb2FkaW5nIGluXG5cdFx0ICogb3JkZXIgd2hlbiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbWFpbnRhaW5TY3JpcHRPcmRlcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpcyBzZXQgdG8gYHRydWVgLlxuXHRcdCAqIEBwcm9wZXJ0eSBtYWludGFpbk9yZGVyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLm1haW50YWluT3JkZXIgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEEgY2FsbGJhY2sgdXNlZCBieSBKU09OUCByZXF1ZXN0cyB0aGF0IGRlZmluZXMgd2hhdCBnbG9iYWwgbWV0aG9kIHRvIGNhbGwgd2hlbiB0aGUgSlNPTlAgY29udGVudCBpcyBsb2FkZWQuXG5cdFx0ICogQHByb3BlcnR5IGNhbGxiYWNrXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5jYWxsYmFjayA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBbiBhcmJpdHJhcnkgZGF0YSBvYmplY3QsIHdoaWNoIGlzIGluY2x1ZGVkIHdpdGggdGhlIGxvYWRlZCBvYmplY3QuXG5cdFx0ICogQHByb3BlcnR5IGRhdGFcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmRhdGEgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHJlcXVlc3QgbWV0aG9kIHVzZWQgZm9yIEhUVFAgY2FsbHMuIEJvdGgge3sjY3Jvc3NMaW5rIFwiTWV0aG9kcy9HRVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJNZXRob2RzL1BPU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcmVxdWVzdCB0eXBlcyBhcmUgc3VwcG9ydGVkLCBhbmQgYXJlIGRlZmluZWQgYXNcblx0XHQgKiBjb25zdGFudHMgb24ge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IG1ldGhvZFxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgR0VUXG5cdFx0ICovXG5cdFx0dGhpcy5tZXRob2QgPSBjcmVhdGVqcy5NZXRob2RzLkdFVDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBoYXNoIG9mIG5hbWUvdmFsdWUgcGFpcnMgdG8gc2VuZCB0byB0aGUgc2VydmVyLlxuXHRcdCAqIEBwcm9wZXJ0eSB2YWx1ZXNcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnZhbHVlcyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgaGFzaCBvZiBoZWFkZXJzIHRvIGF0dGFjaCB0byBhbiBYSFIgcmVxdWVzdC4gUHJlbG9hZEpTIHdpbGwgYXV0b21hdGljYWxseSBhdHRhY2ggc29tZSBkZWZhdWx0XG5cdFx0ICogaGVhZGVycyB3aGVuIHJlcXVpcmVkLCBpbmNsdWRpbmcgXCJPcmlnaW5cIiwgXCJDb250ZW50LVR5cGVcIiwgYW5kIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiLiBZb3UgbWF5IG92ZXJyaWRlIHRoZVxuXHRcdCAqIGRlZmF1bHQgaGVhZGVycyBieSBpbmNsdWRpbmcgdGhlbSBpbiB5b3VyIGhlYWRlcnMgb2JqZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBoZWFkZXJzXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5oZWFkZXJzID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBjcmVkZW50aWFscyBmb3IgWEhSIHJlcXVlc3RzLlxuXHRcdCAqIEBwcm9wZXJ0eSB3aXRoQ3JlZGVudGlhbHNcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIG1pbWUgdHlwZSBvZiBYSFItYmFzZWQgcmVxdWVzdHMuIFRoaXMgaXMgYXV0b21hdGljYWxseSBzZXQgdG8gXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIgZm9yIHRleHRcblx0XHQgKiBiYXNlZCBmaWxlcyAoanNvbiwgeG1sLCB0ZXh0LCBjc3MsIGpzKS5cblx0XHQgKiBAcHJvcGVydHkgbWltZVR5cGVcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLm1pbWVUeXBlID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFNldHMgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBmb3IgQ09SUy1lbmFibGVkIGltYWdlcyBsb2FkaW5nIGNyb3NzLWRvbWFpbi5cblx0XHQgKiBAcHJvcGVydHkgY3Jvc3NPcmlnaW5cblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBBbm9ueW1vdXNcblx0XHQgKi9cblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgYSByZXF1ZXN0IHRpbWVzIG91dC4gVGhpcyBvbmx5IGFwcGxpZXMgdG8gdGFnLWJhc2VkIGFuZCBhbmQgWEhSXG5cdFx0ICogKGxldmVsIG9uZSkgbG9hZGluZywgYXMgWEhSIChsZXZlbCAyKSBwcm92aWRlcyBpdHMgb3duIHRpbWVvdXQgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IGxvYWRUaW1lb3V0XG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCA4MDAwICg4IHNlY29uZHMpXG5cdFx0ICovXG5cdFx0dGhpcy5sb2FkVGltZW91dCA9IHMuTE9BRF9USU1FT1VUX0RFRkFVTFQ7XG5cdH07XG5cblx0dmFyIHAgPSBMb2FkSXRlbS5wcm90b3R5cGUgPSB7fTtcblx0dmFyIHMgPSBMb2FkSXRlbTtcblxuXHQvKipcblx0ICogRGVmYXVsdCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgYSByZXF1ZXN0IHRpbWVzIG91dC4gVGhpcyBvbmx5IGFwcGxpZXMgdG8gdGFnLWJhc2VkIGFuZCBhbmQgWEhSXG5cdCAqIChsZXZlbCBvbmUpIGxvYWRpbmcsIGFzIFhIUiAobGV2ZWwgMikgcHJvdmlkZXMgaXRzIG93biB0aW1lb3V0IGV2ZW50LlxuXHQgKiBAcHJvcGVydHkgTE9BRF9USU1FT1VUX0RFRkFVTFRcblx0ICogQHR5cGUge251bWJlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5MT0FEX1RJTUVPVVRfREVGQVVMVCA9IDgwMDA7XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIExvYWRJdGVtLlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+U3RyaW5nLWJhc2VkIGl0ZW1zIGFyZSBjb252ZXJ0ZWQgdG8gYSBMb2FkSXRlbSB3aXRoIGEgcG9wdWxhdGVkIHt7I2Nyb3NzTGluayBcInNyYzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS48L2xpPlxuXHQgKiAgICAgPGxpPkxvYWRJdGVtIGluc3RhbmNlcyBhcmUgcmV0dXJuZWQgYXMtaXM8L2xpPlxuXHQgKiAgICAgPGxpPk9iamVjdHMgYXJlIHJldHVybmVkIHdpdGggYW55IG5lZWRlZCBwcm9wZXJ0aWVzIGFkZGVkPC9saT5cblx0ICogPC91bD5cblx0ICogQG1ldGhvZCBjcmVhdGVcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxTdHJpbmd8T2JqZWN0fSB2YWx1ZSBUaGUgbG9hZCBpdGVtIHZhbHVlXG5cdCAqIEByZXR1cm5zIHtMb2FkSXRlbXxPYmplY3R9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY3JlYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG5ldyBMb2FkSXRlbSgpO1xuXHRcdFx0aXRlbS5zcmMgPSB2YWx1ZTtcblx0XHRcdHJldHVybiBpdGVtO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBzKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCAmJiB2YWx1ZS5zcmMpIHtcblx0XHRcdGlmICh2YWx1ZS5sb2FkVGltZW91dCA9PSBudWxsKSB7XG5cdFx0XHRcdHZhbHVlLmxvYWRUaW1lb3V0ID0gcy5MT0FEX1RJTUVPVVRfREVGQVVMVDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVHlwZSBub3QgcmVjb2duaXplZC5cIik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBQcm92aWRlcyBhIGNoYWluYWJsZSBzaG9ydGN1dCBtZXRob2QgZm9yIHNldHRpbmcgYSBudW1iZXIgb2YgcHJvcGVydGllcyBvbiB0aGUgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgbG9hZEl0ZW0gPSBuZXcgY3JlYXRlanMuTG9hZEl0ZW0oKS5zZXQoe3NyYzpcImltYWdlLnBuZ1wiLCBtYWludGFpbk9yZGVyOnRydWV9KTtcblx0ICpcblx0ICogQG1ldGhvZCBzZXRcblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEEgZ2VuZXJpYyBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRvIGNvcHkgdG8gdGhlIExvYWRJdGVtIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtMb2FkSXRlbX0gUmV0dXJucyB0aGUgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQqL1xuXHRwLnNldCA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykgeyB0aGlzW25dID0gcHJvcHNbbl07IH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHRjcmVhdGVqcy5Mb2FkSXRlbSA9IHM7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBSZXF1ZXN0VXRpbHMuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cblx0LyoqXG5cdCAqIFV0aWxpdGllcyB0aGF0IGFzc2lzdCB3aXRoIHBhcnNpbmcgbG9hZCBpdGVtcywgYW5kIGRldGVybWluaW5nIGZpbGUgdHlwZXMsIGV0Yy5cblx0ICogQGNsYXNzIFJlcXVlc3RVdGlsc1xuXHQgKi9cblx0dmFyIHMgPSB7fTtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgdHlwZSBzaG91bGQgYmUgbG9hZGVkIGFzIGEgYmluYXJ5IGZpbGUuIEN1cnJlbnRseSwgb25seSBpbWFnZXMgYW5kIGl0ZW1zIG1hcmtlZFxuXHQgKiBzcGVjaWZpY2FsbHkgYXMgXCJiaW5hcnlcIiBhcmUgbG9hZGVkIGFzIGJpbmFyeS4gTm90ZSB0aGF0IGF1ZGlvIGlzIDxiPm5vdDwvYj4gYSBiaW5hcnkgdHlwZSwgYXMgd2UgY2FuIG5vdCBwbGF5XG5cdCAqIGJhY2sgdXNpbmcgYW4gYXVkaW8gdGFnIGlmIGl0IGlzIGxvYWRlZCBhcyBiaW5hcnkuIFBsdWdpbnMgY2FuIGNoYW5nZSB0aGUgaXRlbSB0eXBlIHRvIGJpbmFyeSB0byBlbnN1cmUgdGhleSBnZXRcblx0ICogYSBiaW5hcnkgcmVzdWx0IHRvIHdvcmsgd2l0aC4gQmluYXJ5IGZpbGVzIGFyZSBsb2FkZWQgdXNpbmcgWEhSMi4gVHlwZXMgYXJlIGRlZmluZWQgYXMgc3RhdGljIGNvbnN0YW50cyBvblxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBpc0JpbmFyeVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgaXRlbSB0eXBlLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgc3BlY2lmaWVkIHR5cGUgaXMgYmluYXJ5LlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzQmluYXJ5ID0gZnVuY3Rpb24gKHR5cGUpIHtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgY3JlYXRlanMuVHlwZXMuSU1BR0U6XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLlR5cGVzLkJJTkFSWTpcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgYSBzcGVjaWZpYyB0eXBlIGlzIGEgdGV4dC1iYXNlZCBhc3NldCwgYW5kIHNob3VsZCBiZSBsb2FkZWQgYXMgVVRGLTguXG5cdCAqIEBtZXRob2QgaXNUZXh0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBpdGVtIHR5cGUuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBzcGVjaWZpZWQgdHlwZSBpcyB0ZXh0LlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzVGV4dCA9IGZ1bmN0aW9uICh0eXBlKSB7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLlR5cGVzLlRFWFQ6XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLlR5cGVzLkpTT046XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLlR5cGVzLk1BTklGRVNUOlxuXHRcdFx0Y2FzZSBjcmVhdGVqcy5UeXBlcy5YTUw6XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLlR5cGVzLkNTUzpcblx0XHRcdGNhc2UgY3JlYXRlanMuVHlwZXMuU1ZHOlxuXHRcdFx0Y2FzZSBjcmVhdGVqcy5UeXBlcy5KQVZBU0NSSVBUOlxuXHRcdFx0Y2FzZSBjcmVhdGVqcy5UeXBlcy5TUFJJVEVTSEVFVDpcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgdGhlIHR5cGUgb2YgdGhlIG9iamVjdCB1c2luZyBjb21tb24gZXh0ZW5zaW9ucy4gTm90ZSB0aGF0IHRoZSB0eXBlIGNhbiBiZSBwYXNzZWQgaW4gd2l0aCB0aGUgbG9hZCBpdGVtXG5cdCAqIGlmIGl0IGlzIGFuIHVudXN1YWwgZXh0ZW5zaW9uLlxuXHQgKiBAbWV0aG9kIGdldFR5cGVCeUV4dGVuc2lvblxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXh0ZW5zaW9uIFRoZSBmaWxlIGV4dGVuc2lvbiB0byB1c2UgdG8gZGV0ZXJtaW5lIHRoZSBsb2FkIHR5cGUuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGRldGVybWluZWQgbG9hZCB0eXBlIChmb3IgZXhhbXBsZSwgYGNyZWF0ZWpzLlR5cGVzLklNQUdFYCkuIFdpbGwgcmV0dXJuIGBudWxsYCBpZlxuXHQgKiB0aGUgdHlwZSBjYW4gbm90IGJlIGRldGVybWluZWQgYnkgdGhlIGV4dGVuc2lvbi5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5nZXRUeXBlQnlFeHRlbnNpb24gPSBmdW5jdGlvbiAoZXh0ZW5zaW9uKSB7XG5cdFx0aWYgKGV4dGVuc2lvbiA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gY3JlYXRlanMuVHlwZXMuVEVYVDtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKGV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0XHRjYXNlIFwianBlZ1wiOlxuXHRcdFx0Y2FzZSBcImpwZ1wiOlxuXHRcdFx0Y2FzZSBcImdpZlwiOlxuXHRcdFx0Y2FzZSBcInBuZ1wiOlxuXHRcdFx0Y2FzZSBcIndlYnBcIjpcblx0XHRcdGNhc2UgXCJibXBcIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLlR5cGVzLklNQUdFO1xuXHRcdFx0Y2FzZSBcIm9nZ1wiOlxuXHRcdFx0Y2FzZSBcIm1wM1wiOlxuXHRcdFx0Y2FzZSBcIndlYm1cIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLlR5cGVzLlNPVU5EO1xuXHRcdFx0Y2FzZSBcIm1wNFwiOlxuXHRcdFx0Y2FzZSBcIndlYm1cIjpcblx0XHRcdGNhc2UgXCJ0c1wiOlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuVHlwZXMuVklERU87XG5cdFx0XHRjYXNlIFwianNvblwiOlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuVHlwZXMuSlNPTjtcblx0XHRcdGNhc2UgXCJ4bWxcIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLlR5cGVzLlhNTDtcblx0XHRcdGNhc2UgXCJjc3NcIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLlR5cGVzLkNTUztcblx0XHRcdGNhc2UgXCJqc1wiOlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuVHlwZXMuSkFWQVNDUklQVDtcblx0XHRcdGNhc2UgJ3N2Zyc6XG5cdFx0XHRcdHJldHVybiBjcmVhdGVqcy5UeXBlcy5TVkc7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuVHlwZXMuVEVYVDtcblx0XHR9XG5cdH07XG5cblx0Y3JlYXRlanMuUmVxdWVzdFV0aWxzID0gcztcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEFic3RyYWN0TG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG53aW5kb3cuY3JlYXRlanMgPSB3aW5kb3cuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG4vLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogVGhlIGJhc2UgbG9hZGVyLCB3aGljaCBkZWZpbmVzIGFsbCB0aGUgZ2VuZXJpYyBtZXRob2RzLCBwcm9wZXJ0aWVzLCBhbmQgZXZlbnRzLiBBbGwgbG9hZGVycyBleHRlbmQgdGhpcyBjbGFzcyxcblx0ICogaW5jbHVkaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBjbGFzcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfG9iamVjdHxzdHJpbmd9IGxvYWRJdGVtIFRoZSBpdGVtIHRvIGJlIGxvYWRlZC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcHJlZmVyWEhSXSBEZXRlcm1pbmVzIGlmIHRoZSBMb2FkSXRlbSBzaG91bGQgPGVtPnRyeTwvZW0+IGFuZCBsb2FkIHVzaW5nIFhIUiwgb3IgdGFrZSBhXG5cdCAqIHRhZy1iYXNlZCBhcHByb2FjaCwgd2hpY2ggY2FuIGJlIGJldHRlciBpbiBjcm9zcy1kb21haW4gc2l0dWF0aW9ucy4gTm90IGFsbCBsb2FkZXJzIGNhbiBsb2FkIHVzaW5nIG9uZSBvciB0aGVcblx0ICogb3RoZXIsIHNvIHRoaXMgaXMgYSBzdWdnZXN0ZWQgZGlyZWN0aXZlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3R5cGVdIFRoZSB0eXBlIG9mIGxvYWRlci4gTG9hZGVyIHR5cGVzIGFyZSBkZWZpbmVkIGFzIGNvbnN0YW50cyBvbiB0aGUgQWJzdHJhY3RMb2FkZXIgY2xhc3MsXG5cdCAqIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiSU1BR0U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIkNTUzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSwgZXRjLlxuXHQgKiBAZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJcblx0ICovXG5cdGZ1bmN0aW9uIEFic3RyYWN0TG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIsIHR5cGUpIHtcblx0XHR0aGlzLkV2ZW50RGlzcGF0Y2hlcl9jb25zdHJ1Y3RvcigpO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBJZiB0aGUgbG9hZGVyIGhhcyBjb21wbGV0ZWQgbG9hZGluZy4gVGhpcyBwcm92aWRlcyBhIHF1aWNrIGNoZWNrLCBidXQgYWxzbyBlbnN1cmVzIHRoYXQgdGhlIGRpZmZlcmVudCBhcHByb2FjaGVzXG5cdFx0ICogdXNlZCBmb3IgbG9hZGluZyBkbyBub3QgcGlsZSB1cCByZXN1bHRpbmcgaW4gbW9yZSB0aGFuIG9uZSBgY29tcGxldGVgIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBsb2FkZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMubG9hZGVkID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBEZXRlcm1pbmUgaWYgdGhlIGxvYWRlciB3YXMgY2FuY2VsZWQuIENhbmNlbGVkIGxvYWRzIHdpbGwgbm90IGZpcmUgY29tcGxldGUgZXZlbnRzLiBOb3RlIHRoYXQgdGhpcyBwcm9wZXJ0eVxuXHRcdCAqIGlzIHJlYWRvbmx5LCBzbyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0gcXVldWVzIHNob3VsZCBiZSBjbG9zZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2Nsb3NlXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogaW5zdGVhZC5cblx0XHQgKiBAcHJvcGVydHkgY2FuY2VsZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMuY2FuY2VsZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IGxvYWQgcHJvZ3Jlc3MgKHBlcmNlbnRhZ2UpIGZvciB0aGlzIGl0ZW0uIFRoaXMgd2lsbCBiZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXG5cdFx0ICpcblx0XHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdFx0ICpcblx0XHQgKiAgICAgdmFyIHF1ZXVlID0gbmV3IGNyZWF0ZWpzLkxvYWRRdWV1ZSgpO1xuXHRcdCAqICAgICBxdWV1ZS5sb2FkRmlsZShcImxhcmdlSW1hZ2UucG5nXCIpO1xuXHRcdCAqICAgICBxdWV1ZS5vbihcInByb2dyZXNzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgICAgY29uc29sZS5sb2coXCJQcm9ncmVzczpcIiwgcXVldWUucHJvZ3Jlc3MsIGV2ZW50LnByb2dyZXNzKTtcblx0XHQgKiAgICAgfSk7XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgcHJvZ3Jlc3Ncblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLnByb2dyZXNzID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIGl0ZW0gdGhpcyBsb2FkZXIgd2lsbCBsb2FkLiBTZWUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gZm9yIGEgZnVsbCBsaXN0IG9mXG5cdFx0ICogc3VwcG9ydGVkIHR5cGVzLlxuXHRcdCAqIEBwcm9wZXJ0eSB0eXBlXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKi9cblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBmb3JtYXR0ZXIgZnVuY3Rpb24gdGhhdCBjb252ZXJ0cyB0aGUgbG9hZGVkIHJhdyByZXN1bHQgaW50byB0aGUgZmluYWwgcmVzdWx0LiBGb3IgZXhhbXBsZSwgdGhlIEpTT05Mb2FkZXJcblx0XHQgKiBjb252ZXJ0cyBhIHN0cmluZyBvZiB0ZXh0IGludG8gYSBKYXZhU2NyaXB0IG9iamVjdC4gTm90IGFsbCBsb2FkZXJzIGhhdmUgYSByZXN1bHRGb3JtYXR0ZXIsIGFuZCB0aGlzIHByb3BlcnR5XG5cdFx0ICogY2FuIGJlIG92ZXJyaWRkZW4gdG8gcHJvdmlkZSBjdXN0b20gZm9ybWF0dGluZy5cblx0XHQgKlxuXHRcdCAqIE9wdGlvbmFsbHksIGEgcmVzdWx0Rm9ybWF0dGVyIGNhbiByZXR1cm4gYSBjYWxsYmFjayBmdW5jdGlvbiBpbiBjYXNlcyB3aGVyZSB0aGUgZm9ybWF0dGluZyBuZWVkcyB0byBiZVxuXHRcdCAqIGFzeW5jaHJvbm91cywgc3VjaCBhcyBjcmVhdGluZyBhIG5ldyBpbWFnZS4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHBhc3NlZCAyIHBhcmFtZXRlcnMsIHdoaWNoIGFyZSBjYWxsYmFja3Ncblx0XHQgKiB0byBoYW5kbGUgc3VjY2VzcyBhbmQgZXJyb3IgY29uZGl0aW9ucyBpbiB0aGUgcmVzdWx0Rm9ybWF0dGVyLiBOb3RlIHRoYXQgdGhlIHJlc3VsdEZvcm1hdHRlciBtZXRob2QgaXNcblx0XHQgKiBjYWxsZWQgaW4gdGhlIGN1cnJlbnQgc2NvcGUsIGFzIHdlbGwgYXMgdGhlIHN1Y2Nlc3MgYW5kIGVycm9yIGNhbGxiYWNrcy5cblx0XHQgKlxuXHRcdCAqIDxoND5FeGFtcGxlIGFzeW5jaHJvbm91cyByZXN1bHRGb3JtYXR0ZXI8L2g0PlxuXHRcdCAqXG5cdFx0ICogXHRmdW5jdGlvbiBfZm9ybWF0UmVzdWx0KGxvYWRlcikge1xuXHRcdCAqIFx0XHRyZXR1cm4gZnVuY3Rpb24oc3VjY2VzcywgZXJyb3IpIHtcblx0XHQgKiBcdFx0XHRpZiAoZXJyb3JDb25kaXRpb24pIHsgZXJyb3IoZXJyb3JEZXRhaWxFdmVudCk7IH1cblx0XHQgKiBcdFx0XHRzdWNjZXNzKHJlc3VsdCk7XG5cdFx0ICogXHRcdH1cblx0XHQgKiBcdH1cblx0XHQgKiBAcHJvcGVydHkgcmVzdWx0Rm9ybWF0dGVyXG5cdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnJlc3VsdEZvcm1hdHRlciA9IG51bGw7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSB0aGlzIGxvYWRlciByZXByZXNlbnRzLiBOb3RlIHRoYXQgdGhpcyBpcyBudWxsIGluIGEge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319LFxuXHRcdCAqIGJ1dCB3aWxsIGJlIGF2YWlsYWJsZSBvbiBsb2FkZXJzIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiWE1MTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJJbWFnZUxvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgX2l0ZW1cblx0XHQgKiBAdHlwZSB7TG9hZEl0ZW18T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0aWYgKGxvYWRJdGVtKSB7XG5cdFx0XHR0aGlzLl9pdGVtID0gY3JlYXRlanMuTG9hZEl0ZW0uY3JlYXRlKGxvYWRJdGVtKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5faXRlbSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0aGUgbG9hZGVyIHdpbGwgdHJ5IGFuZCBsb2FkIGNvbnRlbnQgdXNpbmcgWEhSICh0cnVlKSBvciBIVE1MIHRhZ3MgKGZhbHNlKS5cblx0XHQgKiBAcHJvcGVydHkgX3ByZWZlclhIUlxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcHJlZmVyWEhSID0gcHJlZmVyWEhSO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxvYWRlZCByZXN1bHQgYWZ0ZXIgaXQgaXMgZm9ybWF0dGVkIGJ5IGFuIG9wdGlvbmFsIHt7I2Nyb3NzTGluayBcInJlc3VsdEZvcm1hdHRlclwifX17ey9jcm9zc0xpbmt9fS4gRm9yXG5cdFx0ICogaXRlbXMgdGhhdCBhcmUgbm90IGZvcm1hdHRlZCwgdGhpcyB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSB7eyNjcm9zc0xpbmsgXCJfcmF3UmVzdWx0OnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIFRoZSByZXN1bHQgaXMgYWNjZXNzZWQgdXNpbmcgdGhlIHt7I2Nyb3NzTGluayBcImdldFJlc3VsdFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG5cdFx0ICogQHByb3BlcnR5IF9yZXN1bHRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fFN0cmluZ31cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3Jlc3VsdCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbG9hZGVkIHJlc3VsdCBiZWZvcmUgaXQgaXMgZm9ybWF0dGVkLiBUaGUgcmF3UmVzdWx0IGlzIGFjY2Vzc2VkIHVzaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJnZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBtZXRob2QsIGFuZCBwYXNzaW5nIGB0cnVlYC5cblx0XHQgKiBAcHJvcGVydHkgX3Jhd1Jlc3VsdFxuXHRcdCAqIEB0eXBlIHtPYmplY3R8U3RyaW5nfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcmF3UmVzdWx0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEEgbGlzdCBvZiBpdGVtcyB0aGF0IGxvYWRlcnMgbG9hZCBiZWhpbmQgdGhlIHNjZW5lcy4gVGhpcyBkb2VzIG5vdCBpbmNsdWRlIHRoZSBtYWluIGl0ZW0gdGhlIGxvYWRlciBpc1xuXHRcdCAqIHJlc3BvbnNpYmxlIGZvciBsb2FkaW5nLiBFeGFtcGxlcyBvZiBsb2FkZXJzIHRoYXQgaGF2ZSBzdWItaXRlbXMgaW5jbHVkZSB0aGUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gYW5kXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkSXRlbXNcblx0XHQgKiBAdHlwZSB7bnVsbH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZGVkSXRlbXMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGF0dHJpYnV0ZSB0aGUgaXRlbXMgbG9hZGVkIHVzaW5nIHRhZ3MgdXNlIGZvciB0aGUgc291cmNlLlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fdGFnU3JjQXR0cmlidXRlID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIEhUTUwgdGFnIChvciBzaW1pbGFyKSB0aGF0IGEgbG9hZGVyIG1heSB1c2UgdG8gbG9hZCBIVE1MIGNvbnRlbnQsIHN1Y2ggYXMgaW1hZ2VzLCBzY3JpcHRzLCBldGMuXG5cdFx0ICogQHByb3BlcnR5IF90YWdcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fdGFnID0gbnVsbDtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChBYnN0cmFjdExvYWRlciwgY3JlYXRlanMuRXZlbnREaXNwYXRjaGVyKTtcblx0dmFyIHMgPSBBYnN0cmFjdExvYWRlcjtcblxuXHQvLyBSZW1vdmUgdGhlc2UgQGRlcHJlY2F0ZWQgcHJvcGVydGllcyBhZnRlciAxLjBcblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzLCB7XG5cdFx0XHRQT1NUOiB7IGdldDogY3JlYXRlanMuZGVwcmVjYXRlKGZ1bmN0aW9uKCkgeyByZXR1cm4gY3JlYXRlanMuTWV0aG9kcy5QT1NUOyB9LCBcIkFic3RyYWN0TG9hZGVyLlBPU1RcIikgfSxcblx0XHRcdEdFVDogeyBnZXQ6IGNyZWF0ZWpzLmRlcHJlY2F0ZShmdW5jdGlvbigpIHsgcmV0dXJuIGNyZWF0ZWpzLk1ldGhvZHMuR0VUOyB9LCBcIkFic3RyYWN0TG9hZGVyLkdFVFwiKSB9LFxuXG5cdFx0XHRCSU5BUlk6IHsgZ2V0OiBjcmVhdGVqcy5kZXByZWNhdGUoZnVuY3Rpb24oKSB7IHJldHVybiBjcmVhdGVqcy5UeXBlcy5CSU5BUlk7IH0sIFwiQWJzdHJhY3RMb2FkZXIuQklOQVJZXCIpIH0sXG5cdFx0XHRDU1M6IHsgZ2V0OiBjcmVhdGVqcy5kZXByZWNhdGUoZnVuY3Rpb24oKSB7IHJldHVybiBjcmVhdGVqcy5UeXBlcy5DU1M7IH0sIFwiQWJzdHJhY3RMb2FkZXIuQ1NTXCIpIH0sXG5cdFx0XHRGT05UOiB7IGdldDogY3JlYXRlanMuZGVwcmVjYXRlKGZ1bmN0aW9uKCkgeyByZXR1cm4gY3JlYXRlanMuVHlwZXMuRk9OVDsgfSwgXCJBYnN0cmFjdExvYWRlci5GT05UXCIpIH0sXG5cdFx0XHRGT05UQ1NTOiB7IGdldDogY3JlYXRlanMuZGVwcmVjYXRlKGZ1bmN0aW9uKCkgeyByZXR1cm4gY3JlYXRlanMuVHlwZXMuRk9OVENTUzsgfSwgXCJBYnN0cmFjdExvYWRlci5GT05UQ1NTXCIpIH0sXG5cdFx0XHRJTUFHRTogeyBnZXQ6IGNyZWF0ZWpzLmRlcHJlY2F0ZShmdW5jdGlvbigpIHsgcmV0dXJuIGNyZWF0ZWpzLlR5cGVzLklNQUdFOyB9LCBcIkFic3RyYWN0TG9hZGVyLklNQUdFXCIpIH0sXG5cdFx0XHRKQVZBU0NSSVBUOiB7IGdldDogY3JlYXRlanMuZGVwcmVjYXRlKGZ1bmN0aW9uKCkgeyByZXR1cm4gY3JlYXRlanMuVHlwZXMuSkFWQVNDUklQVDsgfSwgXCJBYnN0cmFjdExvYWRlci5KQVZBU0NSSVBUXCIpIH0sXG5cdFx0XHRKU09OOiB7IGdldDogY3JlYXRlanMuZGVwcmVjYXRlKGZ1bmN0aW9uKCkgeyByZXR1cm4gY3JlYXRlanMuVHlwZXMuSlNPTjsgfSwgXCJBYnN0cmFjdExvYWRlci5KU09OXCIpIH0sXG5cdFx0XHRKU09OUDogeyBnZXQ6IGNyZWF0ZWpzLmRlcHJlY2F0ZShmdW5jdGlvbigpIHsgcmV0dXJuIGNyZWF0ZWpzLlR5cGVzLkpTT05QOyB9LCBcIkFic3RyYWN0TG9hZGVyLkpTT05QXCIpIH0sXG5cdFx0XHRNQU5JRkVTVDogeyBnZXQ6IGNyZWF0ZWpzLmRlcHJlY2F0ZShmdW5jdGlvbigpIHsgcmV0dXJuIGNyZWF0ZWpzLlR5cGVzLk1BTklGRVNUOyB9LCBcIkFic3RyYWN0TG9hZGVyLk1BTklGRVNUXCIpIH0sXG5cdFx0XHRTT1VORDogeyBnZXQ6IGNyZWF0ZWpzLmRlcHJlY2F0ZShmdW5jdGlvbigpIHsgcmV0dXJuIGNyZWF0ZWpzLlR5cGVzLlNPVU5EOyB9LCBcIkFic3RyYWN0TG9hZGVyLlNPVU5EXCIpIH0sXG5cdFx0XHRWSURFTzogeyBnZXQ6IGNyZWF0ZWpzLmRlcHJlY2F0ZShmdW5jdGlvbigpIHsgcmV0dXJuIGNyZWF0ZWpzLlR5cGVzLlZJREVPOyB9LCBcIkFic3RyYWN0TG9hZGVyLlZJREVPXCIpIH0sXG5cdFx0XHRTUFJJVEVTSEVFVDogeyBnZXQ6IGNyZWF0ZWpzLmRlcHJlY2F0ZShmdW5jdGlvbigpIHsgcmV0dXJuIGNyZWF0ZWpzLlR5cGVzLlNQUklURVNIRUVUOyB9LCBcIkFic3RyYWN0TG9hZGVyLlNQUklURVNIRUVUXCIpIH0sXG5cdFx0XHRTVkc6IHsgZ2V0OiBjcmVhdGVqcy5kZXByZWNhdGUoZnVuY3Rpb24oKSB7IHJldHVybiBjcmVhdGVqcy5UeXBlcy5TVkc7IH0sIFwiQWJzdHJhY3RMb2FkZXIuU1ZHXCIpIH0sXG5cdFx0XHRURVhUOiB7IGdldDogY3JlYXRlanMuZGVwcmVjYXRlKGZ1bmN0aW9uKCkgeyByZXR1cm4gY3JlYXRlanMuVHlwZXMuVEVYVDsgfSwgXCJBYnN0cmFjdExvYWRlci5URVhUXCIpIH0sXG5cdFx0XHRYTUw6IHsgZ2V0OiBjcmVhdGVqcy5kZXByZWNhdGUoZnVuY3Rpb24oKSB7IHJldHVybiBjcmVhdGVqcy5UeXBlcy5YTUw7IH0sIFwiQWJzdHJhY3RMb2FkZXIuWE1MXCIpIH1cblx0XHR9KTtcblx0fSBjYXRjaCAoZSkge31cblxuLy8gRXZlbnRzXG5cdC8qKlxuXHQgKiBUaGUge3sjY3Jvc3NMaW5rIFwiUHJvZ3Jlc3NFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIHdoZW4gdGhlIG92ZXJhbGwgcHJvZ3Jlc3MgY2hhbmdlcy4gUHJpb3IgdG9cblx0ICogdmVyc2lvbiAwLjYuMCwgdGhpcyB3YXMganVzdCBhIHJlZ3VsYXIge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBldmVudCBwcm9ncmVzc1xuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIHdoZW4gYSBsb2FkIHN0YXJ0cy5cblx0ICogQGV2ZW50IGxvYWRzdGFydFxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBzaW5jZSAwLjMuMVxuXHQgKi9cblxuXHQvKipcblx0ICogVGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgd2hlbiB0aGUgZW50aXJlIHF1ZXVlIGhhcyBiZWVuIGxvYWRlZC5cblx0ICogQGV2ZW50IGNvbXBsZXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGUge3sjY3Jvc3NMaW5rIFwiRXJyb3JFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIHdoZW4gdGhlIGxvYWRlciBlbmNvdW50ZXJzIGFuIGVycm9yLiBJZiB0aGUgZXJyb3Igd2FzXG5cdCAqIGVuY291bnRlcmVkIGJ5IGEgZmlsZSwgdGhlIGV2ZW50IHdpbGwgY29udGFpbiB0aGUgaXRlbSB0aGF0IGNhdXNlZCB0aGUgZXJyb3IuIFByaW9yIHRvIHZlcnNpb24gMC42LjAsIHRoaXMgd2FzXG5cdCAqIGp1c3QgYSByZWd1bGFyIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAZXZlbnQgZXJyb3Jcblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGUge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIHRoZSBsb2FkZXIgZW5jb3VudGVycyBhbiBpbnRlcm5hbCBmaWxlIGxvYWQgZXJyb3IuXG5cdCAqIFRoaXMgZW5hYmxlcyBsb2FkZXJzIHRvIG1haW50YWluIGludGVybmFsIHF1ZXVlcywgYW5kIHN1cmZhY2UgZmlsZSBsb2FkIGVycm9ycy5cblx0ICogQGV2ZW50IGZpbGVlcnJvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUgKFwiZmlsZWVycm9yXCIpXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18b2JqZWN0fSBUaGUgaXRlbSB0aGF0IGVuY291bnRlcmVkIHRoZSBlcnJvclxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIHdoZW4gYSBsb2FkZXIgaW50ZXJuYWxseSBsb2FkcyBhIGZpbGUuIFRoaXMgZW5hYmxlc1xuXHQgKiBsb2FkZXJzIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gdG8gbWFpbnRhaW4gaW50ZXJuYWwge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319c1xuXHQgKiBhbmQgbm90aWZ5IHdoZW4gdGhleSBoYXZlIGxvYWRlZCBhIGZpbGUuIFRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZGlzcGF0Y2hlcyBhXG5cdCAqIHNsaWdodGx5IGRpZmZlcmVudCB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZWxvYWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQuXG5cdCAqIEBldmVudCBmaWxlbG9hZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUgKFwiZmlsZWxvYWRcIilcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIGZpbGUgaXRlbSB3aGljaCB3YXMgc3BlY2lmaWVkIGluIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogb3Ige3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fSBjYWxsLiBJZiBvbmx5IGEgc3RyaW5nIHBhdGggb3IgdGFnIHdhcyBzcGVjaWZpZWQsIHRoZVxuXHQgKiBvYmplY3Qgd2lsbCBjb250YWluIHRoYXQgdmFsdWUgYXMgYSBgc3JjYCBwcm9wZXJ0eS5cblx0ICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdCBUaGUgSFRNTCB0YWcgb3IgcGFyc2VkIHJlc3VsdCBvZiB0aGUgbG9hZGVkIGl0ZW0uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByYXdSZXN1bHQgVGhlIHVucHJvY2Vzc2VkIHJlc3VsdCwgdXN1YWxseSB0aGUgcmF3IHRleHQgb3IgYmluYXJ5IGRhdGEgYmVmb3JlIGl0IGlzIGNvbnZlcnRlZFxuXHQgKiB0byBhIHVzYWJsZSBvYmplY3QuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHQvKipcblx0ICogVGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgYWZ0ZXIgdGhlIGludGVybmFsIHJlcXVlc3QgaXMgY3JlYXRlZCwgYnV0IGJlZm9yZSBhIGxvYWQuXG5cdCAqIFRoaXMgYWxsb3dzIHVwZGF0ZXMgdG8gdGhlIGxvYWRlciBmb3Igc3BlY2lmaWMgbG9hZGluZyBuZWVkcywgc3VjaCBhcyBiaW5hcnkgb3IgWEhSIGltYWdlIGxvYWRpbmcuXG5cdCAqIEBldmVudCBpbml0aWFsaXplXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZSAoXCJpbml0aWFsaXplXCIpXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlciBUaGUgbG9hZGVyIHRoYXQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG5cdCAqL1xuXG5cblx0LyoqXG5cdCAqIEdldCBhIHJlZmVyZW5jZSB0byB0aGUgbWFuaWZlc3QgaXRlbSB0aGF0IGlzIGxvYWRlZCBieSB0aGlzIGxvYWRlci4gSW4gc29tZSBjYXNlcyB0aGlzIHdpbGwgYmUgdGhlIHZhbHVlIHRoYXQgd2FzXG5cdCAqIHBhc3NlZCBpbnRvIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fS4gSG93ZXZlciBpZiBvbmx5IGEgU3RyaW5nIHBhdGggd2FzIHBhc3NlZCBpbiwgdGhlbiBpdCB3aWxsXG5cdCAqIGJlIGEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgZ2V0SXRlbVxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBtYW5pZmVzdCBpdGVtIHRoYXQgdGhpcyBsb2FkZXIgaXMgcmVzcG9uc2libGUgZm9yIGxvYWRpbmcuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5nZXRJdGVtID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9pdGVtO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgYSByZWZlcmVuY2UgdG8gdGhlIGNvbnRlbnQgdGhhdCB3YXMgbG9hZGVkIGJ5IHRoZSBsb2FkZXIgKG9ubHkgYXZhaWxhYmxlIGFmdGVyIHRoZSB7eyNjcm9zc0xpbmsgXCJjb21wbGV0ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBpcyBkaXNwYXRjaGVkLlxuXHQgKiBAbWV0aG9kIGdldFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyYXc9ZmFsc2VdIERldGVybWluZXMgaWYgdGhlIHJldHVybmVkIHJlc3VsdCB3aWxsIGJlIHRoZSBmb3JtYXR0ZWQgY29udGVudCwgb3IgdGhlIHJhdyBsb2FkZWRcblx0ICogZGF0YSAoaWYgaXQgZXhpc3RzKS5cblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuZ2V0UmVzdWx0ID0gZnVuY3Rpb24gKHJhdykge1xuXHRcdHJldHVybiByYXcgPyB0aGlzLl9yYXdSZXN1bHQgOiB0aGlzLl9yZXN1bHQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgYHRhZ2AgdGhpcyBvYmplY3QgY3JlYXRlcyBvciB1c2VzIGZvciBsb2FkaW5nLlxuXHQgKiBAbWV0aG9kIGdldFRhZ1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB0YWcgaW5zdGFuY2Vcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmdldFRhZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdGFnO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGB0YWdgIHRoaXMgaXRlbSB1c2VzIGZvciBsb2FkaW5nLlxuXHQgKiBAbWV0aG9kIHNldFRhZ1xuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFnIFRoZSB0YWcgaW5zdGFuY2Vcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLnNldFRhZyA9IGZ1bmN0aW9uKHRhZykge1xuXHQgIHRoaXMuX3RhZyA9IHRhZztcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW4gbG9hZGluZyB0aGUgaXRlbS4gVGhpcyBtZXRob2QgaXMgcmVxdWlyZWQgd2hlbiB1c2luZyBhIGxvYWRlciBieSBpdHNlbGYuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgcXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG5cdCAqICAgICAgcXVldWUub24oXCJjb21wbGV0ZVwiLCBoYW5kbGVDb21wbGV0ZSk7XG5cdCAqICAgICAgcXVldWUubG9hZE1hbmlmZXN0KGZpbGVBcnJheSwgZmFsc2UpOyAvLyBOb3RlIHRoZSAybmQgYXJndW1lbnQgdGhhdCB0ZWxscyB0aGUgcXVldWUgbm90IHRvIHN0YXJ0IGxvYWRpbmcgeWV0XG5cdCAqICAgICAgcXVldWUubG9hZCgpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIGxvYWRcblx0ICovXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jcmVhdGVSZXF1ZXN0KCk7XG5cblx0XHR0aGlzLl9yZXF1ZXN0Lm9uKFwiY29tcGxldGVcIiwgdGhpcywgdGhpcyk7XG5cdFx0dGhpcy5fcmVxdWVzdC5vbihcInByb2dyZXNzXCIsIHRoaXMsIHRoaXMpO1xuXHRcdHRoaXMuX3JlcXVlc3Qub24oXCJsb2FkU3RhcnRcIiwgdGhpcywgdGhpcyk7XG5cdFx0dGhpcy5fcmVxdWVzdC5vbihcImFib3J0XCIsIHRoaXMsIHRoaXMpO1xuXHRcdHRoaXMuX3JlcXVlc3Qub24oXCJ0aW1lb3V0XCIsIHRoaXMsIHRoaXMpO1xuXHRcdHRoaXMuX3JlcXVlc3Qub24oXCJlcnJvclwiLCB0aGlzLCB0aGlzKTtcblxuXHRcdHZhciBldnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJpbml0aWFsaXplXCIpO1xuXHRcdGV2dC5sb2FkZXIgPSB0aGlzLl9yZXF1ZXN0O1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuXG5cdFx0dGhpcy5fcmVxdWVzdC5sb2FkKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENsb3NlIHRoZSB0aGUgaXRlbS4gVGhpcyB3aWxsIHN0b3AgYW55IG9wZW4gcmVxdWVzdHMgKGFsdGhvdWdoIGRvd25sb2FkcyB1c2luZyBIVE1MIHRhZ3MgbWF5IHN0aWxsIGNvbnRpbnVlIGluXG5cdCAqIHRoZSBiYWNrZ3JvdW5kKSwgYnV0IGV2ZW50cyB3aWxsIG5vdCBsb25nZXIgYmUgZGlzcGF0Y2hlZC5cblx0ICogQG1ldGhvZCBjYW5jZWxcblx0ICovXG5cdHAuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuY2FuY2VsZWQgPSB0cnVlO1xuXHRcdHRoaXMuZGVzdHJveSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiB1cCB0aGUgbG9hZGVyLlxuXHQgKiBAbWV0aG9kIGRlc3Ryb3lcblx0ICovXG5cdHAuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9yZXF1ZXN0KSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LmRlc3Ryb3koKTtcblx0XHR9XG5cblx0XHR0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcblxuXHRcdHRoaXMuX2l0ZW0gPSBudWxsO1xuXHRcdHRoaXMuX3Jhd1Jlc3VsdCA9IG51bGw7XG5cdFx0dGhpcy5fcmVzdWx0ID0gbnVsbDtcblxuXHRcdHRoaXMuX2xvYWRJdGVtcyA9IG51bGw7XG5cblx0XHR0aGlzLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCBhbnkgaXRlbXMgbG9hZGVkIGludGVybmFsbHkgYnkgdGhlIGxvYWRlci4gVGhlIGVuYWJsZXMgbG9hZGVycyBzdWNoIGFzIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHRvIGV4cG9zZSBpdGVtcyBpdCBsb2FkcyBpbnRlcm5hbGx5LlxuXHQgKiBAbWV0aG9kIGdldExvYWRlZEl0ZW1zXG5cdCAqIEByZXR1cm4ge0FycmF5fSBBIGxpc3Qgb2YgdGhlIGl0ZW1zIGxvYWRlZCBieSB0aGUgbG9hZGVyLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuZ2V0TG9hZGVkSXRlbXMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRlZEl0ZW1zO1xuXHR9O1xuXG5cblx0Ly8gUHJpdmF0ZSBtZXRob2RzXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW4gaW50ZXJuYWwgcmVxdWVzdCB1c2VkIGZvciBsb2FkaW5nLiBCeSBkZWZhdWx0LCBhbiB7eyNjcm9zc0xpbmsgXCJYSFJSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdCAqIHt7I2Nyb3NzTGluayBcIlRhZ1JlcXVlc3RcIn19e3svY3Jvc3NMaW5rfX0gaXMgY3JlYXRlZCwgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiB7eyNjcm9zc0xpbmsgXCJwcmVmZXJYSFI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIE90aGVyIGxvYWRlcnMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gdXNlIGRpZmZlcmVudCByZXF1ZXN0IHR5cGVzLCBzdWNoIGFzIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiB3aGljaCB1c2VzIHt7I2Nyb3NzTGluayBcIkpTT05Mb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gb3Ige3sjY3Jvc3NMaW5rIFwiSlNPTlBMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gdW5kZXIgdGhlIGhvb2QuXG5cdCAqIEBtZXRob2QgX2NyZWF0ZVJlcXVlc3Rcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fcHJlZmVyWEhSKSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLlRhZ1JlcXVlc3QodGhpcy5faXRlbSwgdGhpcy5fdGFnIHx8IHRoaXMuX2NyZWF0ZVRhZygpLCB0aGlzLl90YWdTcmNBdHRyaWJ1dGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLlhIUlJlcXVlc3QodGhpcy5faXRlbSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgdGhlIEhUTUwgdGFnIHVzZWQgZm9yIGxvYWRpbmcuIFRoaXMgbWV0aG9kIGRvZXMgbm90aGluZyBieSBkZWZhdWx0LCBhbmQgbmVlZHMgdG8gYmUgaW1wbGVtZW50ZWRcblx0ICogYnkgbG9hZGVycyB0aGF0IHJlcXVpcmUgdGFnIGxvYWRpbmcuXG5cdCAqIEBtZXRob2QgX2NyZWF0ZVRhZ1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSB0YWcgc291cmNlXG5cdCAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBUaGUgdGFnIHRoYXQgd2FzIGNyZWF0ZWRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fY3JlYXRlVGFnID0gZnVuY3Rpb24oc3JjKSB7IHJldHVybiBudWxsOyB9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhIGxvYWRzdGFydCB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvbG9hZHN0YXJ0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IGZvciBkZXRhaWxzIG9uIHRoZSBldmVudCBwYXlsb2FkLlxuXHQgKiBAbWV0aG9kIF9zZW5kTG9hZFN0YXJ0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3NlbmRMb2FkU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2lzQ2FuY2VsZWQoKSkgeyByZXR1cm47IH1cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJsb2Fkc3RhcnRcIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoIGEge3sjY3Jvc3NMaW5rIFwiUHJvZ3Jlc3NFdmVudFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBfc2VuZFByb2dyZXNzXG5cdCAqIEBwYXJhbSB7TnVtYmVyIHwgT2JqZWN0fSB2YWx1ZSBUaGUgcHJvZ3Jlc3Mgb2YgdGhlIGxvYWRlZCBpdGVtLCBvciBhbiBvYmplY3QgY29udGFpbmluZyA8Y29kZT5sb2FkZWQ8L2NvZGU+XG5cdCAqIGFuZCA8Y29kZT50b3RhbDwvY29kZT4gcHJvcGVydGllcy5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2VuZFByb2dyZXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMuX2lzQ2FuY2VsZWQoKSkgeyByZXR1cm47IH1cblx0XHR2YXIgZXZlbnQgPSBudWxsO1xuXHRcdGlmICh0eXBlb2YodmFsdWUpID09IFwibnVtYmVyXCIpIHtcblx0XHRcdHRoaXMucHJvZ3Jlc3MgPSB2YWx1ZTtcblx0XHRcdGV2ZW50ID0gbmV3IGNyZWF0ZWpzLlByb2dyZXNzRXZlbnQodGhpcy5wcm9ncmVzcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV2ZW50ID0gdmFsdWU7XG5cdFx0XHR0aGlzLnByb2dyZXNzID0gdmFsdWUubG9hZGVkIC8gdmFsdWUudG90YWw7XG5cdFx0XHRldmVudC5wcm9ncmVzcyA9IHRoaXMucHJvZ3Jlc3M7XG5cdFx0XHRpZiAoaXNOYU4odGhpcy5wcm9ncmVzcykgfHwgdGhpcy5wcm9ncmVzcyA9PSBJbmZpbml0eSkgeyB0aGlzLnByb2dyZXNzID0gMDsgfVxuXHRcdH1cblx0XHR0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiKSAmJiB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhIGNvbXBsZXRlIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9jb21wbGV0ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudFxuXHQgKiBAbWV0aG9kIF9zZW5kQ29tcGxldGVcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2VuZENvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9pc0NhbmNlbGVkKCkpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLmxvYWRlZCA9IHRydWU7XG5cblx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJjb21wbGV0ZVwiKTtcblx0XHRldmVudC5yYXdSZXN1bHQgPSB0aGlzLl9yYXdSZXN1bHQ7XG5cblx0XHRpZiAodGhpcy5fcmVzdWx0ICE9IG51bGwpIHtcblx0XHRcdGV2ZW50LnJlc3VsdCA9IHRoaXMuX3Jlc3VsdDtcblx0XHR9XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhbiBlcnJvciB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvZXJyb3I6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgZm9yIGRldGFpbHMgb24gdGhlIGV2ZW50IHBheWxvYWQuXG5cdCAqIEBtZXRob2QgX3NlbmRFcnJvclxuXHQgKiBAcGFyYW0ge0Vycm9yRXZlbnR9IGV2ZW50IFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBzcGVjaWZpYyBlcnJvciBwcm9wZXJ0aWVzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZW5kRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRpZiAodGhpcy5faXNDYW5jZWxlZCgpIHx8ICF0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJlcnJvclwiKSkgeyByZXR1cm47IH1cblx0XHRpZiAoZXZlbnQgPT0gbnVsbCkge1xuXHRcdFx0ZXZlbnQgPSBuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlBSRUxPQURfRVJST1JfRU1QVFlcIik7IC8vIFRPRE86IFBvcHVsYXRlIGVycm9yXG5cdFx0fVxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSBpZiB0aGUgbG9hZCBoYXMgYmVlbiBjYW5jZWxlZC4gVGhpcyBpcyBpbXBvcnRhbnQgdG8gZW5zdXJlIHRoYXQgbWV0aG9kIGNhbGxzIG9yIGFzeW5jaHJvbm91cyBldmVudHNcblx0ICogZG8gbm90IGNhdXNlIGlzc3VlcyBhZnRlciB0aGUgcXVldWUgaGFzIGJlZW4gY2xlYW5lZCB1cC5cblx0ICogQG1ldGhvZCBfaXNDYW5jZWxlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgbG9hZGVyIGhhcyBiZWVuIGNhbmNlbGVkLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9pc0NhbmNlbGVkID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh3aW5kb3cuY3JlYXRlanMgPT0gbnVsbCB8fCB0aGlzLmNhbmNlbGVkKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBIGN1c3RvbSByZXN1bHQgZm9ybWF0dGVyIGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWQganVzdCBiZWZvcmUgYSByZXF1ZXN0IGRpc3BhdGNoZXMgaXRzIGNvbXBsZXRlIGV2ZW50LiBNb3N0XG5cdCAqIGxvYWRlciB0eXBlcyBhbHJlYWR5IGhhdmUgYW4gaW50ZXJuYWwgZm9ybWF0dGVyLCBidXQgdGhpcyBjYW4gYmUgdXNlci1vdmVycmlkZGVuIGZvciBjdXN0b20gZm9ybWF0dGluZy4gVGhlXG5cdCAqIGZvcm1hdHRlZCByZXN1bHQgd2lsbCBiZSBhdmFpbGFibGUgb24gTG9hZGVycyB1c2luZyB7eyNjcm9zc0xpbmsgXCJnZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCBwYXNzaW5nIGB0cnVlYC5cblx0ICogQHByb3BlcnR5IHJlc3VsdEZvcm1hdHRlclxuXHQgKiBAdHlwZSBGdW5jdGlvblxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBmb3JtYXR0ZWQgcmVzdWx0XG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5yZXN1bHRGb3JtYXR0ZXIgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBIYW5kbGUgZXZlbnRzIGZyb20gaW50ZXJuYWwgcmVxdWVzdHMuIEJ5IGRlZmF1bHQsIGxvYWRlcnMgd2lsbCBoYW5kbGUsIGFuZCByZWRpc3BhdGNoIHRoZSBuZWNlc3NhcnkgZXZlbnRzLCBidXRcblx0ICogdGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gZm9yIGN1c3RvbSBiZWhhdmlvdXJzLlxuXHQgKiBAbWV0aG9kIGhhbmRsZUV2ZW50XG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0aGF0IHRoZSBpbnRlcm5hbCByZXF1ZXN0IGRpc3BhdGNoZXMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0c3dpdGNoIChldmVudC50eXBlKSB7XG5cdFx0XHRjYXNlIFwiY29tcGxldGVcIjpcblx0XHRcdFx0dGhpcy5fcmF3UmVzdWx0ID0gZXZlbnQudGFyZ2V0Ll9yZXNwb25zZTtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0Rm9ybWF0dGVyICYmIHRoaXMucmVzdWx0Rm9ybWF0dGVyKHRoaXMpO1xuXHRcdFx0XHQvLyBUaGUgcmVzdWx0Rm9ybWF0dGVyIGlzIGFzeW5jaHJvbm91c1xuXHRcdFx0XHRpZiAocmVzdWx0IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdFx0XHRyZXN1bHQuY2FsbCh0aGlzLFxuXHRcdFx0XHRcdFx0XHRjcmVhdGVqcy5wcm94eSh0aGlzLl9yZXN1bHRGb3JtYXRTdWNjZXNzLCB0aGlzKSxcblx0XHRcdFx0XHRcdFx0Y3JlYXRlanMucHJveHkodGhpcy5fcmVzdWx0Rm9ybWF0RmFpbGVkLCB0aGlzKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdC8vIFRoZSByZXN1bHQgZm9ybWF0dGVyIGlzIHN5bmNocm9ub3VzXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fcmVzdWx0ID0gIHJlc3VsdCB8fCB0aGlzLl9yYXdSZXN1bHQ7XG5cdFx0XHRcdFx0dGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwicHJvZ3Jlc3NcIjpcblx0XHRcdFx0dGhpcy5fc2VuZFByb2dyZXNzKGV2ZW50KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwiZXJyb3JcIjpcblx0XHRcdFx0dGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwibG9hZHN0YXJ0XCI6XG5cdFx0XHRcdHRoaXMuX3NlbmRMb2FkU3RhcnQoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwiYWJvcnRcIjpcblx0XHRcdGNhc2UgXCJ0aW1lb3V0XCI6XG5cdFx0XHRcdGlmICghdGhpcy5faXNDYW5jZWxlZCgpKSB7XG5cdFx0XHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9cIiArIGV2ZW50LnR5cGUudG9VcHBlckNhc2UoKSArIFwiX0VSUk9SXCIpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBcInN1Y2Nlc3NcIiBjYWxsYmFjayBwYXNzZWQgdG8ge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvcmVzdWx0Rm9ybWF0dGVyXCJ9fXt7L2Nyb3NzTGlua319IGFzeW5jaHJvbm91c1xuXHQgKiBmdW5jdGlvbnMuXG5cdCAqIEBtZXRob2QgX3Jlc3VsdEZvcm1hdFN1Y2Nlc3Ncblx0ICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdCBUaGUgZm9ybWF0dGVkIHJlc3VsdFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fcmVzdWx0Rm9ybWF0U3VjY2VzcyA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHR0aGlzLl9yZXN1bHQgPSByZXN1bHQ7XG5cdFx0dGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBcImVycm9yXCIgY2FsbGJhY2sgcGFzc2VkIHRvIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL3Jlc3VsdEZvcm1hdHRlclwifX17ey9jcm9zc0xpbmt9fSBhc3luY2hyb25vdXNcblx0ICogZnVuY3Rpb25zLlxuXHQgKiBAbWV0aG9kIF9yZXN1bHRGb3JtYXRTdWNjZXNzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlcnJvciBUaGUgZXJyb3IgZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX3Jlc3VsdEZvcm1hdEZhaWxlZCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMuX3NlbmRFcnJvcihldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltQcmVsb2FkSlMgQWJzdHJhY3RMb2FkZXJdXCI7XG5cdH07XG5cblx0Y3JlYXRlanMuQWJzdHJhY3RMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEFic3RyYWN0TG9hZGVyLCBcIkV2ZW50RGlzcGF0Y2hlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEFic3RyYWN0TWVkaWFMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbndpbmRvdy5jcmVhdGVqcyA9IHdpbmRvdy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIFRoZSBBYnN0cmFjdE1lZGlhTG9hZGVyIGlzIGEgYmFzZSBjbGFzcyB0aGF0IGhhbmRsZXMgc29tZSBvZiB0aGUgc2hhcmVkIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgb2YgbG9hZGVycyB0aGF0XG5cdCAqIGhhbmRsZSBIVE1MIG1lZGlhIGVsZW1lbnRzLCBzdWNoIGFzIFZpZGVvIGFuZCBBdWRpby5cblx0ICogQGNsYXNzIEFic3RyYWN0TWVkaWFMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZmVyWEhSXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIG1lZGlhIHRvIGxvYWQuIFVzdWFsbHkgXCJ2aWRlb1wiIG9yIFwiYXVkaW9cIi5cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBBYnN0cmFjdE1lZGlhTG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIsIHR5cGUpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIHR5cGUpO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHR0aGlzLnJlc3VsdEZvcm1hdHRlciA9IHRoaXMuX2Zvcm1hdFJlc3VsdDtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5fdGFnU3JjQXR0cmlidXRlID0gXCJzcmNcIjtcblxuICAgICAgICB0aGlzLm9uKFwiaW5pdGlhbGl6ZVwiLCB0aGlzLl91cGRhdGVYSFIsIHRoaXMpO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEFic3RyYWN0TWVkaWFMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblxuXHQvLyBzdGF0aWMgcHJvcGVydGllc1xuXHQvLyBwdWJsaWMgbWV0aG9kc1xuXHRwLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVGFnUmVxdWVzdCB3aWxsIGhhbmRsZSBtb3N0IG9mIHRoaXMsIGJ1dCBTb3VuZCAvIFZpZGVvIG5lZWQgYSBmZXcgY3VzdG9tIHByb3BlcnRpZXMsIHNvIGp1c3QgaGFuZGxlIHRoZW0gaGVyZS5cblx0XHRpZiAoIXRoaXMuX3RhZykge1xuXHRcdFx0dGhpcy5fdGFnID0gdGhpcy5fY3JlYXRlVGFnKHRoaXMuX2l0ZW0uc3JjKTtcblx0XHR9XG5cblx0XHR0aGlzLl90YWcucHJlbG9hZCA9IFwiYXV0b1wiO1xuXHRcdHRoaXMuX3RhZy5sb2FkKCk7XG5cblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2xvYWQoKTtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyB0YWcgZm9yIGxvYWRpbmcgaWYgaXQgZG9lc24ndCBleGlzdCB5ZXQuXG5cdCAqIEBtZXRob2QgX2NyZWF0ZVRhZ1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY3JlYXRlVGFnID0gZnVuY3Rpb24gKCkge307XG5cblxuXHRwLl9jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9wcmVmZXJYSFIpIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuTWVkaWFUYWdSZXF1ZXN0KHRoaXMuX2l0ZW0sIHRoaXMuX3RhZyB8fCB0aGlzLl9jcmVhdGVUYWcoKSwgdGhpcy5fdGFnU3JjQXR0cmlidXRlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5YSFJSZXF1ZXN0KHRoaXMuX2l0ZW0pO1xuXHRcdH1cblx0fTtcblxuICAgIC8vIHByb3RlY3RlZCBtZXRob2RzXG4gICAgLyoqXG4gICAgICogQmVmb3JlIHRoZSBpdGVtIGxvYWRzLCBzZXQgaXRzIG1pbWVUeXBlIGFuZCByZXNwb25zZVR5cGUuXG4gICAgICogQHByb3BlcnR5IF91cGRhdGVYSFJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcC5fdXBkYXRlWEhSID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIE9ubHkgZXhpc3RzIGZvciBYSFJcbiAgICAgICAgaWYgKGV2ZW50LmxvYWRlci5zZXRSZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgIGV2ZW50LmxvYWRlci5zZXRSZXNwb25zZVR5cGUoXCJibG9iXCIpO1xuICAgICAgICB9XG4gICAgfTtcblxuXHQvKipcblx0ICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIG1lZGlhIGZpbGVzLlxuXHQgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEByZXR1cm5zIHtIVE1MVmlkZW9FbGVtZW50fEhUTUxBdWRpb0VsZW1lbnR9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9mb3JtYXRSZXN1bHQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0dGhpcy5fdGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIgJiYgdGhpcy5fdGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5dGhyb3VnaFwiLCB0aGlzLl9sb2FkZWRIYW5kbGVyKTtcblx0XHR0aGlzLl90YWcub25zdGFsbGVkID0gbnVsbDtcblx0XHRpZiAodGhpcy5fcHJlZmVyWEhSKSB7XG4gICAgICAgICAgICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGxvYWRlci5nZXRSZXN1bHQodHJ1ZSk7XG5cblx0XHRcdGxvYWRlci5nZXRUYWcoKS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHJlc3VsdCk7XG5cdFx0fVxuXHRcdHJldHVybiBsb2FkZXIuZ2V0VGFnKCk7XG5cdH07XG5cblx0Y3JlYXRlanMuQWJzdHJhY3RNZWRpYUxvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoQWJzdHJhY3RNZWRpYUxvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEFic3RyYWN0UmVxdWVzdC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxud2luZG93LmNyZWF0ZWpzID0gd2luZG93LmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogQSBiYXNlIGNsYXNzIGZvciBhY3R1YWwgZGF0YSByZXF1ZXN0cywgc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJYSFJSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJUYWdSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBhbmQge3sjY3Jvc3NMaW5rIFwiTWVkaWFSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319LiBQcmVsb2FkSlMgbG9hZGVycyB3aWxsIHR5cGljYWxseSB1c2UgYSBkYXRhIGxvYWRlciB1bmRlciB0aGVcblx0ICogaG9vZCB0byBnZXQgZGF0YS5cblx0ICogQGNsYXNzIEFic3RyYWN0UmVxdWVzdFxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfSBpdGVtXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0dmFyIEFic3RyYWN0UmVxdWVzdCA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0dGhpcy5faXRlbSA9IGl0ZW07XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQWJzdHJhY3RSZXF1ZXN0LCBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIpO1xuXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBCZWdpbiBhIGxvYWQuXG5cdCAqIEBtZXRob2QgbG9hZFxuXHQgKi9cblx0cC5sb2FkID0gIGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIENsZWFuIHVwIGEgcmVxdWVzdC5cblx0ICogQG1ldGhvZCBkZXN0cm95XG5cdCAqL1xuXHRwLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qKlxuXHQgKiBDYW5jZWwgYW4gaW4tcHJvZ3Jlc3MgcmVxdWVzdC5cblx0ICogQG1ldGhvZCBjYW5jZWxcblx0ICovXG5cdHAuY2FuY2VsID0gZnVuY3Rpb24oKSB7fTtcblxuXHRjcmVhdGVqcy5BYnN0cmFjdFJlcXVlc3QgPSBjcmVhdGVqcy5wcm9tb3RlKEFic3RyYWN0UmVxdWVzdCwgXCJFdmVudERpc3BhdGNoZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUYWdSZXF1ZXN0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG53aW5kb3cuY3JlYXRlanMgPSB3aW5kb3cuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBbiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFJlcXVlc3RcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBsb2FkcyBIVE1MIHRhZ3MsIHN1Y2ggYXMgaW1hZ2VzIGFuZCBzY3JpcHRzLlxuXHQgKiBAY2xhc3MgVGFnUmVxdWVzdFxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YWdcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyY0F0dHJpYnV0ZSBUaGUgdGFnIGF0dHJpYnV0ZSB0aGF0IHNwZWNpZmllcyB0aGUgc291cmNlLCBzdWNoIGFzIFwic3JjXCIsIFwiaHJlZlwiLCBldGMuXG5cdCAqL1xuXHRmdW5jdGlvbiBUYWdSZXF1ZXN0KGxvYWRJdGVtLCB0YWcsIHNyY0F0dHJpYnV0ZSkge1xuXHRcdHRoaXMuQWJzdHJhY3RSZXF1ZXN0X2NvbnN0cnVjdG9yKGxvYWRJdGVtKTtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogVGhlIEhUTUwgdGFnIGluc3RhbmNlIHRoYXQgaXMgdXNlZCB0byBsb2FkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfdGFnXG5cdFx0ICogQHR5cGUge0hUTUxFbGVtZW50fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl90YWcgPSB0YWc7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdGFnIGF0dHJpYnV0ZSB0aGF0IHNwZWNpZmllcyB0aGUgc291cmNlLCBzdWNoIGFzIFwic3JjXCIsIFwiaHJlZlwiLCBldGMuXG5cdFx0ICogQHByb3BlcnR5IF90YWdTcmNBdHRyaWJ1dGVcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBzcmNBdHRyaWJ1dGU7XG5cblx0XHQvKipcblx0XHQgKiBBIG1ldGhvZCBjbG9zdXJlIHVzZWQgZm9yIGhhbmRsaW5nIHRoZSB0YWcgbG9hZCBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRlZEhhbmRsZXJcblx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkZWRIYW5kbGVyID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlVGFnQ29tcGxldGUsIHRoaXMpO1xuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgZWxlbWVudCB3YXMgYWRkZWQgdG8gdGhlIERPTSBhdXRvbWF0aWNhbGx5IGJ5IFByZWxvYWRKUywgc28gaXQgY2FuIGJlIGNsZWFuZWQgdXAgYWZ0ZXIuXG5cdFx0ICogQHByb3BlcnR5IF9hZGRlZFRvRE9NXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9hZGRlZFRvRE9NID0gZmFsc2U7XG5cblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChUYWdSZXF1ZXN0LCBjcmVhdGVqcy5BYnN0cmFjdFJlcXVlc3QpO1xuXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl90YWcub25sb2FkID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlVGFnQ29tcGxldGUsIHRoaXMpO1xuXHRcdHRoaXMuX3RhZy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlLCB0aGlzKTtcblx0XHR0aGlzLl90YWcub25lcnJvciA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZUVycm9yLCB0aGlzKTtcblxuXHRcdHZhciBldnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJpbml0aWFsaXplXCIpO1xuXHRcdGV2dC5sb2FkZXIgPSB0aGlzLl90YWc7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuXHRcdHRoaXMuX2xvYWRUaW1lb3V0ID0gc2V0VGltZW91dChjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUaW1lb3V0LCB0aGlzKSwgdGhpcy5faXRlbS5sb2FkVGltZW91dCk7XG5cblx0XHR0aGlzLl90YWdbdGhpcy5fdGFnU3JjQXR0cmlidXRlXSA9IHRoaXMuX2l0ZW0uc3JjO1xuXG5cdFx0Ly8gd2RnOjogQXBwZW5kIHRoZSB0YWcgQUZURVIgc2V0dGluZyB0aGUgc3JjLCBvciBTVkcgbG9hZGluZyBvbiBpT1Mgd2lsbCBmYWlsLlxuXHRcdGlmICh0aGlzLl90YWcucGFyZW50Tm9kZSA9PSBudWxsKSB7XG5cdFx0XHRjcmVhdGVqcy5Eb21VdGlscy5hcHBlbmRUb0JvZHkodGhpcy5fdGFnKTtcblx0XHRcdHRoaXMuX2FkZGVkVG9ET00gPSB0cnVlO1xuXHRcdH1cblx0fTtcblxuXHRwLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9jbGVhbigpO1xuXHRcdHRoaXMuX3RhZyA9IG51bGw7XG5cblx0XHR0aGlzLkFic3RyYWN0UmVxdWVzdF9kZXN0cm95KCk7XG5cdH07XG5cblx0Ly8gcHJpdmF0ZSBtZXRob2RzXG5cdC8qKlxuXHQgKiBIYW5kbGUgdGhlIHJlYWR5U3RhdGVDaGFuZ2UgZXZlbnQgZnJvbSBhIHRhZy4gV2UgbmVlZCB0aGlzIGluIHBsYWNlIG9mIHRoZSBgb25sb2FkYCBjYWxsYmFjayAobWFpbmx5IFNDUklQVFxuXHQgKiBhbmQgTElOSyB0YWdzKSwgYnV0IG90aGVyIGNhc2VzIG1heSBleGlzdC5cblx0ICogQG1ldGhvZCBfaGFuZGxlUmVhZHlTdGF0ZUNoYW5nZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fbG9hZFRpbWVvdXQpO1xuXHRcdC8vIFRoaXMgaXMgc3RyaWN0bHkgZm9yIHRhZ3MgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBvbmxvYWQuXG5cdFx0dmFyIHRhZyA9IHRoaXMuX3RhZztcblxuXHRcdC8vIENvbXBsZXRlIGlzIGZvciBvbGQgSUUgc3VwcG9ydC5cblx0XHRpZiAodGFnLnJlYWR5U3RhdGUgPT0gXCJsb2FkZWRcIiB8fCB0YWcucmVhZHlTdGF0ZSA9PSBcImNvbXBsZXRlXCIpIHtcblx0XHRcdHRoaXMuX2hhbmRsZVRhZ0NvbXBsZXRlKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBIYW5kbGUgYW55IGVycm9yIGV2ZW50cyBmcm9tIHRoZSB0YWcuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUVycm9yXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2hhbmRsZUVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fY2xlYW4oKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJlcnJvclwiKTtcblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlIHRoZSB0YWcncyBvbmxvYWQgY2FsbGJhY2suXG5cdCAqIEBtZXRob2QgX2hhbmRsZVRhZ0NvbXBsZXRlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVUYWdDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yYXdSZXN1bHQgPSB0aGlzLl90YWc7XG5cdFx0dGhpcy5fcmVzdWx0ID0gdGhpcy5yZXN1bHRGb3JtYXR0ZXIgJiYgdGhpcy5yZXN1bHRGb3JtYXR0ZXIodGhpcykgfHwgdGhpcy5fcmF3UmVzdWx0O1xuXG5cdFx0dGhpcy5fY2xlYW4oKTtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgdGFnIHJlcXVlc3QgaGFzIG5vdCBsb2FkZWQgd2l0aGluIHRoZSB0aW1lIHNwZWNpZmllZCBpbiBsb2FkVGltZW91dC5cblx0ICogQG1ldGhvZCBfaGFuZGxlRXJyb3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgZXJyb3IgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NsZWFuKCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FdmVudChcInRpbWVvdXRcIikpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzLCBidXQgZG9uJ3QgZGVzdHJveSB0aGUgcmVxdWVzdCBvYmplY3Rcblx0ICogQG1ldGhvZCBfY2xlYW5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NsZWFuID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fdGFnLm9ubG9hZCA9IG51bGw7XG5cdFx0dGhpcy5fdGFnLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cdFx0dGhpcy5fdGFnLm9uZXJyb3IgPSBudWxsO1xuXHRcdGlmICh0aGlzLl9hZGRlZFRvRE9NICYmIHRoaXMuX3RhZy5wYXJlbnROb2RlICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3RhZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX3RhZyk7XG5cdFx0fVxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9sb2FkVGltZW91dCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZSBhIHN0YWxsZWQgYXVkaW8gZXZlbnQuIFRoZSBtYWluIHBsYWNlIHRoaXMgaGFwcGVucyBpcyB3aXRoIEhUTUxBdWRpbyBpbiBDaHJvbWUgd2hlbiBwbGF5aW5nIGJhY2sgYXVkaW9cblx0ICogdGhhdCBpcyBhbHJlYWR5IGluIGEgbG9hZCwgYnV0IG5vdCBjb21wbGV0ZS5cblx0ICogQG1ldGhvZCBfaGFuZGxlU3RhbGxlZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlU3RhbGxlZCA9IGZ1bmN0aW9uICgpIHtcblx0XHQvL0lnbm9yZSwgbGV0IHRoZSB0aW1lb3V0IHRha2UgY2FyZSBvZiBpdC4gU29tZXRpbWVzIGl0cyBub3QgcmVhbGx5IHN0b3BwZWQuXG5cdH07XG5cblx0Y3JlYXRlanMuVGFnUmVxdWVzdCA9IGNyZWF0ZWpzLnByb21vdGUoVGFnUmVxdWVzdCwgXCJBYnN0cmFjdFJlcXVlc3RcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBNZWRpYVRhZ1JlcXVlc3QuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbndpbmRvdy5jcmVhdGVqcyA9IHdpbmRvdy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEFuIHt7I2Nyb3NzTGluayBcIlRhZ1JlcXVlc3RcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBsb2FkcyBIVE1MIHRhZ3MgZm9yIHZpZGVvIGFuZCBhdWRpby5cblx0ICogQGNsYXNzIE1lZGlhVGFnUmVxdWVzdFxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0hUTUxBdWRpb0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gdGFnXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmNBdHRyaWJ1dGUgVGhlIHRhZyBhdHRyaWJ1dGUgdGhhdCBzcGVjaWZpZXMgdGhlIHNvdXJjZSwgc3VjaCBhcyBcInNyY1wiLCBcImhyZWZcIiwgZXRjLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIE1lZGlhVGFnUmVxdWVzdChsb2FkSXRlbSwgdGFnLCBzcmNBdHRyaWJ1dGUpIHtcblx0XHR0aGlzLkFic3RyYWN0UmVxdWVzdF9jb25zdHJ1Y3Rvcihsb2FkSXRlbSk7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdHRoaXMuX3RhZyA9IHRhZztcblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBzcmNBdHRyaWJ1dGU7XG5cdFx0dGhpcy5fbG9hZGVkSGFuZGxlciA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRhZ0NvbXBsZXRlLCB0aGlzKTtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChNZWRpYVRhZ1JlcXVlc3QsIGNyZWF0ZWpzLlRhZ1JlcXVlc3QpO1xuXHR2YXIgcyA9IE1lZGlhVGFnUmVxdWVzdDtcblxuXHQvLyBwdWJsaWMgbWV0aG9kc1xuXHRwLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNjID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlU3RhbGxlZCwgdGhpcyk7XG5cdFx0dGhpcy5fc3RhbGxlZENhbGxiYWNrID0gc2M7XG5cblx0XHR2YXIgcGMgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVQcm9ncmVzcywgdGhpcyk7XG5cdFx0dGhpcy5faGFuZGxlUHJvZ3Jlc3MgPSBwYztcblxuXHRcdHRoaXMuX3RhZy5hZGRFdmVudExpc3RlbmVyKFwic3RhbGxlZFwiLCBzYyk7XG5cdFx0dGhpcy5fdGFnLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCBwYyk7XG5cblx0XHQvLyBUaGlzIHdpbGwgdGVsbCB1cyB3aGVuIGF1ZGlvIGlzIGJ1ZmZlcmVkIGVub3VnaCB0byBwbGF5IHRocm91Z2gsIGJ1dCBub3Qgd2hlbiBpdHMgbG9hZGVkLlxuXHRcdC8vIFRoZSB0YWcgZG9lc24ndCBrZWVwIGxvYWRpbmcgaW4gQ2hyb21lIG9uY2UgZW5vdWdoIGhhcyBidWZmZXJlZCwgYW5kIHdlIGhhdmUgZGVjaWRlZCB0aGF0IGJlaGF2aW91ciBpcyBzdWZmaWNpZW50LlxuXHRcdHRoaXMuX3RhZy5hZGRFdmVudExpc3RlbmVyICYmIHRoaXMuX3RhZy5hZGRFdmVudExpc3RlbmVyKFwiY2FucGxheXRocm91Z2hcIiwgdGhpcy5fbG9hZGVkSGFuZGxlciwgZmFsc2UpOyAvLyBjYW5wbGF5dGhyb3VnaCBjYWxsYmFjayBkb2Vzbid0IHdvcmsgaW4gQ2hyb21lLCBzbyB3ZSB1c2UgYW4gZXZlbnQuXG5cblx0XHR0aGlzLlRhZ1JlcXVlc3RfbG9hZCgpO1xuXHR9O1xuXG5cdC8vIHByaXZhdGUgbWV0aG9kc1xuXHRwLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9sb2FkVGltZW91dCk7XG5cdFx0Ly8gVGhpcyBpcyBzdHJpY3RseSBmb3IgdGFncyBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IG9ubG9hZC5cblx0XHR2YXIgdGFnID0gdGhpcy5fdGFnO1xuXG5cdFx0Ly8gQ29tcGxldGUgaXMgZm9yIG9sZCBJRSBzdXBwb3J0LlxuXHRcdGlmICh0YWcucmVhZHlTdGF0ZSA9PSBcImxvYWRlZFwiIHx8IHRhZy5yZWFkeVN0YXRlID09IFwiY29tcGxldGVcIikge1xuXHRcdFx0dGhpcy5faGFuZGxlVGFnQ29tcGxldGUoKTtcblx0XHR9XG5cdH07XG5cblx0cC5faGFuZGxlU3RhbGxlZCA9IGZ1bmN0aW9uICgpIHtcblx0XHQvL0lnbm9yZSwgbGV0IHRoZSB0aW1lb3V0IHRha2UgY2FyZSBvZiBpdC4gU29tZXRpbWVzIGl0cyBub3QgcmVhbGx5IHN0b3BwZWQuXG5cdH07XG5cblx0LyoqXG5cdCAqIEFuIFhIUiByZXF1ZXN0IGhhcyByZXBvcnRlZCBwcm9ncmVzcy5cblx0ICogQG1ldGhvZCBfaGFuZGxlUHJvZ3Jlc3Ncblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgcHJvZ3Jlc3MgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVQcm9ncmVzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGlmICghZXZlbnQgfHwgZXZlbnQubG9hZGVkID4gMCAmJiBldmVudC50b3RhbCA9PSAwKSB7XG5cdFx0XHRyZXR1cm47IC8vIFNvbWV0aW1lcyB3ZSBnZXQgbm8gXCJ0b3RhbFwiLCBzbyBqdXN0IGlnbm9yZSB0aGUgcHJvZ3Jlc3MgZXZlbnQuXG5cdFx0fVxuXG5cdFx0dmFyIG5ld0V2ZW50ID0gbmV3IGNyZWF0ZWpzLlByb2dyZXNzRXZlbnQoZXZlbnQubG9hZGVkLCBldmVudC50b3RhbCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHRwLl9jbGVhbiA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lciAmJiB0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNhbnBsYXl0aHJvdWdoXCIsIHRoaXMuX2xvYWRlZEhhbmRsZXIpO1xuXHRcdHRoaXMuX3RhZy5yZW1vdmVFdmVudExpc3RlbmVyKFwic3RhbGxlZFwiLCB0aGlzLl9zdGFsbGVkQ2FsbGJhY2spO1xuXHRcdHRoaXMuX3RhZy5yZW1vdmVFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgdGhpcy5fcHJvZ3Jlc3NDYWxsYmFjayk7XG5cblx0XHR0aGlzLlRhZ1JlcXVlc3RfX2NsZWFuKCk7XG5cdH07XG5cblx0Y3JlYXRlanMuTWVkaWFUYWdSZXF1ZXN0ID0gY3JlYXRlanMucHJvbW90ZShNZWRpYVRhZ1JlcXVlc3QsIFwiVGFnUmVxdWVzdFwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFhIUlJlcXVlc3QuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbndpbmRvdy5jcmVhdGVqcyA9IHdpbmRvdy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIHByZWxvYWRlciB0aGF0IGxvYWRzIGl0ZW1zIHVzaW5nIFhIUiByZXF1ZXN0cywgdXN1YWxseSBYTUxIdHRwUmVxdWVzdC4gSG93ZXZlciBYRG9tYWluUmVxdWVzdHMgd2lsbCBiZSB1c2VkXG5cdCAqIGZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMgaWYgcG9zc2libGUsIGFuZCBvbGRlciB2ZXJzaW9ucyBvZiBJRSBmYWxsIGJhY2sgb24gdG8gQWN0aXZlWCBvYmplY3RzIHdoZW4gbmVjZXNzYXJ5LlxuXHQgKiBYSFIgcmVxdWVzdHMgbG9hZCB0aGUgY29udGVudCBhcyB0ZXh0IG9yIGJpbmFyeSBkYXRhLCBwcm92aWRlIHByb2dyZXNzIGFuZCBjb25zaXN0ZW50IGNvbXBsZXRpb24gZXZlbnRzLCBhbmRcblx0ICogY2FuIGJlIGNhbmNlbGVkIGR1cmluZyBsb2FkLiBOb3RlIHRoYXQgWEhSIGlzIG5vdCBzdXBwb3J0ZWQgaW4gSUUgNiBvciBlYXJsaWVyLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvclxuXHQgKiBjcm9zcy1kb21haW4gbG9hZGluZy5cblx0ICogQGNsYXNzIFhIUlJlcXVlc3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIFRoZSBvYmplY3QgdGhhdCBkZWZpbmVzIHRoZSBmaWxlIHRvIGxvYWQuIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgYW4gb3ZlcnZpZXcgb2Ygc3VwcG9ydGVkIGZpbGUgcHJvcGVydGllcy5cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICovXG5cdGZ1bmN0aW9uIFhIUlJlcXVlc3QgKGl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0UmVxdWVzdF9jb25zdHJ1Y3RvcihpdGVtKTtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogQSByZWZlcmVuY2UgdG8gdGhlIFhIUiByZXF1ZXN0IHVzZWQgdG8gbG9hZCB0aGUgY29udGVudC5cblx0XHQgKiBAcHJvcGVydHkgX3JlcXVlc3Rcblx0XHQgKiBAdHlwZSB7WE1MSHR0cFJlcXVlc3QgfCBYRG9tYWluUmVxdWVzdCB8IEFjdGl2ZVguWE1MSFRUUH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBtYW51YWwgbG9hZCB0aW1lb3V0IHRoYXQgaXMgdXNlZCBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCB0aGUgb25UaW1lb3V0IGV2ZW50IG9uIFhIUiAoWEhSIGxldmVsIDEsXG5cdFx0ICogdHlwaWNhbGx5IElFOSkuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkVGltZW91dFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkVGltZW91dCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYnJvd3NlcidzIFhIUiAoWE1MSFRUUFJlcXVlc3QpIHZlcnNpb24uIFN1cHBvcnRlZCB2ZXJzaW9ucyBhcmUgMSBhbmQgMi4gVGhlcmUgaXMgbm8gb2ZmaWNpYWwgd2F5IHRvIGRldGVjdFxuXHRcdCAqIHRoZSB2ZXJzaW9uLCBzbyB3ZSB1c2UgY2FwYWJpbGl0aWVzIHRvIG1ha2UgYSBiZXN0IGd1ZXNzLlxuXHRcdCAqIEBwcm9wZXJ0eSBfeGhyTGV2ZWxcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3hockxldmVsID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByZXNwb25zZSBvZiBhIGxvYWRlZCBmaWxlLiBUaGlzIGlzIHNldCBiZWNhdXNlIGl0IGlzIGV4cGVuc2l2ZSB0byBsb29rIHVwIGNvbnN0YW50bHkuIFRoaXMgcHJvcGVydHkgd2lsbCBiZVxuXHRcdCAqIG51bGwgdW50aWwgdGhlIGZpbGUgaXMgbG9hZGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmVzcG9uc2Vcblx0XHQgKiBAdHlwZSB7bWl4ZWR9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9yZXNwb25zZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcmVzcG9uc2Ugb2YgdGhlIGxvYWRlZCBmaWxlIGJlZm9yZSBpdCBpcyBtb2RpZmllZC4gSW4gbW9zdCBjYXNlcywgY29udGVudCBpcyBjb252ZXJ0ZWQgZnJvbSByYXcgdGV4dCB0b1xuXHRcdCAqIGFuIEhUTUwgdGFnIG9yIGEgZm9ybWF0dGVkIG9iamVjdCB3aGljaCBpcyBzZXQgdG8gdGhlIDxjb2RlPnJlc3VsdDwvY29kZT4gcHJvcGVydHksIGJ1dCB0aGUgZGV2ZWxvcGVyIG1heSBzdGlsbFxuXHRcdCAqIHdhbnQgdG8gYWNjZXNzIHRoZSByYXcgY29udGVudCBhcyBpdCB3YXMgbG9hZGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmF3UmVzcG9uc2Vcblx0XHQgKiBAdHlwZSB7U3RyaW5nfE9iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3Jhd1Jlc3BvbnNlID0gbnVsbDtcblxuXHRcdHRoaXMuX2NhbmNlbGVkID0gZmFsc2U7XG5cblx0XHQvLyBTZXR1cCBvdXIgZXZlbnQgaGFuZGxlcnMgbm93LlxuXHRcdHRoaXMuX2hhbmRsZUxvYWRTdGFydFByb3h5ID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlTG9hZFN0YXJ0LCB0aGlzKTtcblx0XHR0aGlzLl9oYW5kbGVQcm9ncmVzc1Byb3h5ID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlUHJvZ3Jlc3MsIHRoaXMpO1xuXHRcdHRoaXMuX2hhbmRsZUFib3J0UHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVBYm9ydCwgdGhpcyk7XG5cdFx0dGhpcy5faGFuZGxlRXJyb3JQcm94eSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZUVycm9yLCB0aGlzKTtcblx0XHR0aGlzLl9oYW5kbGVUaW1lb3V0UHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUaW1lb3V0LCB0aGlzKTtcblx0XHR0aGlzLl9oYW5kbGVMb2FkUHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVMb2FkLCB0aGlzKTtcblx0XHR0aGlzLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlUHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlLCB0aGlzKTtcblxuXHRcdGlmICghdGhpcy5fY3JlYXRlWEhSKGl0ZW0pKSB7XG5cdFx0XHQvL1RPRE86IFRocm93IGVycm9yP1xuXHRcdH1cblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChYSFJSZXF1ZXN0LCBjcmVhdGVqcy5BYnN0cmFjdFJlcXVlc3QpO1xuXG4vLyBzdGF0aWMgcHJvcGVydGllc1xuXHQvKipcblx0ICogQSBsaXN0IG9mIFhNTEhUVFAgb2JqZWN0IElEcyB0byB0cnkgd2hlbiBidWlsZGluZyBhbiBBY3RpdmVYIG9iamVjdCBmb3IgWEhSIHJlcXVlc3RzIGluIGVhcmxpZXIgdmVyc2lvbnMgb2YgSUUuXG5cdCAqIEBwcm9wZXJ0eSBBQ1RJVkVYX1ZFUlNJT05TXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQHNpbmNlIDAuNC4yXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRYSFJSZXF1ZXN0LkFDVElWRVhfVkVSU0lPTlMgPSBbXG5cdFx0XCJNc3htbDIuWE1MSFRUUC42LjBcIixcblx0XHRcIk1zeG1sMi5YTUxIVFRQLjUuMFwiLFxuXHRcdFwiTXN4bWwyLlhNTEhUVFAuNC4wXCIsXG5cdFx0XCJNU1hNTDIuWE1MSFRUUC4zLjBcIixcblx0XHRcIk1TWE1MMi5YTUxIVFRQXCIsXG5cdFx0XCJNaWNyb3NvZnQuWE1MSFRUUFwiXG5cdF07XG5cbi8vIFB1YmxpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBMb29rIHVwIHRoZSBsb2FkZWQgcmVzdWx0LlxuXHQgKiBAbWV0aG9kIGdldFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyYXc9ZmFsc2VdIFJldHVybiBhIHJhdyByZXN1bHQgaW5zdGVhZCBvZiBhIGZvcm1hdHRlZCByZXN1bHQuIFRoaXMgYXBwbGllcyB0byBjb250ZW50XG5cdCAqIGxvYWRlZCB2aWEgWEhSIHN1Y2ggYXMgc2NyaXB0cywgWE1MLCBDU1MsIGFuZCBJbWFnZXMuIElmIHRoZXJlIGlzIG5vIHJhdyByZXN1bHQsIHRoZSBmb3JtYXR0ZWQgcmVzdWx0IHdpbGwgYmVcblx0ICogcmV0dXJuZWQgaW5zdGVhZC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBBIHJlc3VsdCBvYmplY3QgY29udGFpbmluZyB0aGUgY29udGVudCB0aGF0IHdhcyBsb2FkZWQsIHN1Y2ggYXM6XG5cdCAqIDx1bD5cblx0ICogICAgICA8bGk+QW4gaW1hZ2UgdGFnICgmbHQ7aW1hZ2UgLyZndDspIGZvciBpbWFnZXM8L2xpPlxuXHQgKiAgICAgIDxsaT5BIHNjcmlwdCB0YWcgZm9yIEphdmFTY3JpcHQgKCZsdDtzY3JpcHQgLyZndDspLiBOb3RlIHRoYXQgc2NyaXB0cyBsb2FkZWQgd2l0aCB0YWdzIG1heSBiZSBhZGRlZCB0byB0aGVcblx0ICogICAgICBIVE1MIGhlYWQuPC9saT5cblx0ICogICAgICA8bGk+QSBzdHlsZSB0YWcgZm9yIENTUyAoJmx0O3N0eWxlIC8mZ3Q7KTwvbGk+XG5cdCAqICAgICAgPGxpPlJhdyB0ZXh0IGZvciBURVhUPC9saT5cblx0ICogICAgICA8bGk+QSBmb3JtYXR0ZWQgSmF2YVNjcmlwdCBvYmplY3QgZGVmaW5lZCBieSBKU09OPC9saT5cblx0ICogICAgICA8bGk+QW4gWE1MIGRvY3VtZW50PC9saT5cblx0ICogICAgICA8bGk+QW4gYmluYXJ5IGFycmF5YnVmZmVyIGxvYWRlZCBieSBYSFI8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBOb3RlIHRoYXQgaWYgYSByYXcgcmVzdWx0IGlzIHJlcXVlc3RlZCwgYnV0IG5vdCBmb3VuZCwgdGhlIHJlc3VsdCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQuXG5cdCAqL1xuXHRwLmdldFJlc3VsdCA9IGZ1bmN0aW9uIChyYXcpIHtcblx0XHRpZiAocmF3ICYmIHRoaXMuX3Jhd1Jlc3BvbnNlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmF3UmVzcG9uc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9yZXNwb25zZTtcblx0fTtcblxuXHQvLyBPdmVycmlkZXMgYWJzdHJhY3QgbWV0aG9kIGluIEFic3RyYWN0UmVxdWVzdFxuXHRwLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmNhbmNlbGVkID0gdHJ1ZTtcblx0XHR0aGlzLl9jbGVhbigpO1xuXHRcdHRoaXMuX3JlcXVlc3QuYWJvcnQoKTtcblx0fTtcblxuXHQvLyBPdmVycmlkZXMgYWJzdHJhY3QgbWV0aG9kIGluIEFic3RyYWN0TG9hZGVyXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVxdWVzdCA9PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVFcnJvcigpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vRXZlbnRzXG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2Fkc3RhcnRcIiwgdGhpcy5faGFuZGxlTG9hZFN0YXJ0UHJveHksIGZhbHNlKTtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIHRoaXMuX2hhbmRsZVByb2dyZXNzUHJveHksIGZhbHNlKTtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHRoaXMuX2hhbmRsZUFib3J0UHJveHksIGZhbHNlKTtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHRoaXMuX2hhbmRsZUVycm9yUHJveHksIGZhbHNlKTtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcInRpbWVvdXRcIiwgdGhpcy5faGFuZGxlVGltZW91dFByb3h5LCBmYWxzZSk7XG5cblx0XHRcdC8vIE5vdGU6IFdlIGRvbid0IGdldCBvbmxvYWQgaW4gYWxsIGJyb3dzZXJzIChlYXJsaWVyIEZGIGFuZCBJRSkuIG9uUmVhZHlTdGF0ZUNoYW5nZSBoYW5kbGVzIHRoZXNlLlxuXHRcdFx0dGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCB0aGlzLl9oYW5kbGVMb2FkUHJveHksIGZhbHNlKTtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIiwgdGhpcy5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZVByb3h5LCBmYWxzZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIElFOSBzdXBwb3J0XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9ubG9hZHN0YXJ0ID0gdGhpcy5faGFuZGxlTG9hZFN0YXJ0UHJveHk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSB0aGlzLl9oYW5kbGVQcm9ncmVzc1Byb3h5O1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbmFib3J0ID0gdGhpcy5faGFuZGxlQWJvcnRQcm94eTtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25lcnJvciA9IHRoaXMuX2hhbmRsZUVycm9yUHJveHk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9udGltZW91dCA9IHRoaXMuX2hhbmRsZVRpbWVvdXRQcm94eTtcblxuXHRcdFx0Ly8gTm90ZTogV2UgZG9uJ3QgZ2V0IG9ubG9hZCBpbiBhbGwgYnJvd3NlcnMgKGVhcmxpZXIgRkYgYW5kIElFKS4gb25SZWFkeVN0YXRlQ2hhbmdlIGhhbmRsZXMgdGhlc2UuXG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9ubG9hZCA9IHRoaXMuX2hhbmRsZUxvYWRQcm94eTtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZVByb3h5O1xuXHRcdH1cblxuXHRcdC8vIFNldCB1cCBhIHRpbWVvdXQgaWYgd2UgZG9uJ3QgaGF2ZSBYSFIyXG5cdFx0aWYgKHRoaXMuX3hockxldmVsID09IDEpIHtcblx0XHRcdHRoaXMuX2xvYWRUaW1lb3V0ID0gc2V0VGltZW91dChjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUaW1lb3V0LCB0aGlzKSwgdGhpcy5faXRlbS5sb2FkVGltZW91dCk7XG5cdFx0fVxuXG5cdFx0Ly8gU29tZXRpbWVzIHdlIGdldCBiYWNrIDQwNHMgaW1tZWRpYXRlbHksIHBhcnRpY3VsYXJseSB3aGVuIHRoZXJlIGlzIGEgY3Jvc3Mgb3JpZ2luIHJlcXVlc3QuICAvLyBub3RlIHRoaXMgZG9lcyBub3QgY2F0Y2ggaW4gQ2hyb21lXG5cdFx0dHJ5IHtcblx0XHRcdGlmICghdGhpcy5faXRlbS52YWx1ZXMpIHtcblx0XHRcdFx0dGhpcy5fcmVxdWVzdC5zZW5kKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9yZXF1ZXN0LnNlbmQoY3JlYXRlanMuVVJMVXRpbHMuZm9ybWF0UXVlcnlTdHJpbmcodGhpcy5faXRlbS52YWx1ZXMpKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiWEhSX1NFTkRcIiwgbnVsbCwgZXJyb3IpKTtcblx0XHR9XG5cdH07XG5cblx0cC5zZXRSZXNwb25zZVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuXHRcdC8vIFNvbWUgb2xkIGJyb3dzZXJzIGRvZXNuJ3Qgc3VwcG9ydCBibG9iLCBzbyB3ZSBjb252ZXJ0IGFycmF5YnVmZmVyIHRvIGJsb2IgYWZ0ZXIgcmVzcG9uc2UgaXMgZG93bmxvYWRlZFxuXHRcdGlmICh0eXBlID09PSAnYmxvYicpIHtcblx0XHRcdHR5cGUgPSB3aW5kb3cuVVJMID8gJ2Jsb2InIDogJ2FycmF5YnVmZmVyJztcblx0XHRcdHRoaXMuX3Jlc3BvbnNlVHlwZSA9IHR5cGU7XG5cdFx0fVxuXHRcdHRoaXMuX3JlcXVlc3QucmVzcG9uc2VUeXBlID0gdHlwZTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IGFsbCB0aGUgcmVzcG9uc2UgaGVhZGVycyBmcm9tIHRoZSBYbWxIdHRwUmVxdWVzdC5cblx0ICpcblx0ICogPHN0cm9uZz5Gcm9tIHRoZSBkb2NzOjwvc3Ryb25nPiBSZXR1cm4gYWxsIHRoZSBIVFRQIGhlYWRlcnMsIGV4Y2x1ZGluZyBoZWFkZXJzIHRoYXQgYXJlIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaFxuXHQgKiBmb3IgU2V0LUNvb2tpZSBvciBTZXQtQ29va2llMiwgYXMgYSBzaW5nbGUgc3RyaW5nLCB3aXRoIGVhY2ggaGVhZGVyIGxpbmUgc2VwYXJhdGVkIGJ5IGEgVSswMDBEIENSIFUrMDAwQSBMRiBwYWlyLFxuXHQgKiBleGNsdWRpbmcgdGhlIHN0YXR1cyBsaW5lLCBhbmQgd2l0aCBlYWNoIGhlYWRlciBuYW1lIGFuZCBoZWFkZXIgdmFsdWUgc2VwYXJhdGVkIGJ5IGEgVSswMDNBIENPTE9OIFUrMDAyMCBTUEFDRVxuXHQgKiBwYWlyLlxuXHQgKiBAbWV0aG9kIGdldEFsbFJlc3BvbnNlSGVhZGVyc1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKi9cblx0cC5nZXRBbGxSZXNwb25zZUhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCBhIHNwZWNpZmljIHJlc3BvbnNlIGhlYWRlciBmcm9tIHRoZSBYbWxIdHRwUmVxdWVzdC5cblx0ICpcblx0ICogPHN0cm9uZz5Gcm9tIHRoZSBkb2NzOjwvc3Ryb25nPiBSZXR1cm5zIHRoZSBoZWFkZXIgZmllbGQgdmFsdWUgZnJvbSB0aGUgcmVzcG9uc2Ugb2Ygd2hpY2ggdGhlIGZpZWxkIG5hbWUgbWF0Y2hlc1xuXHQgKiBoZWFkZXIsIHVubGVzcyB0aGUgZmllbGQgbmFtZSBpcyBTZXQtQ29va2llIG9yIFNldC1Db29raWUyLlxuXHQgKiBAbWV0aG9kIGdldFJlc3BvbnNlSGVhZGVyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGhlYWRlciBuYW1lIHRvIHJldHJpZXZlLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKi9cblx0cC5nZXRSZXNwb25zZUhlYWRlciA9IGZ1bmN0aW9uIChoZWFkZXIpIHtcblx0XHRpZiAodGhpcy5fcmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlciBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlcihoZWFkZXIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH07XG5cbi8vIHByb3RlY3RlZCBtZXRob2RzXG5cdC8qKlxuXHQgKiBUaGUgWEhSIHJlcXVlc3QgaGFzIHJlcG9ydGVkIHByb2dyZXNzLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVQcm9ncmVzc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIFhIUiBwcm9ncmVzcyBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVByb2dyZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYgKCFldmVudCB8fCBldmVudC5sb2FkZWQgPiAwICYmIGV2ZW50LnRvdGFsID09IDApIHtcblx0XHRcdHJldHVybjsgLy8gU29tZXRpbWVzIHdlIGdldCBubyBcInRvdGFsXCIsIHNvIGp1c3QgaWdub3JlIHRoZSBwcm9ncmVzcyBldmVudC5cblx0XHR9XG5cblx0XHR2YXIgbmV3RXZlbnQgPSBuZXcgY3JlYXRlanMuUHJvZ3Jlc3NFdmVudChldmVudC5sb2FkZWQsIGV2ZW50LnRvdGFsKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgWEhSIHJlcXVlc3QgaGFzIHJlcG9ydGVkIGEgbG9hZCBzdGFydC5cblx0ICogQG1ldGhvZCBfaGFuZGxlTG9hZFN0YXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGxvYWRTdGFydCBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZUxvYWRTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9sb2FkVGltZW91dCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwibG9hZHN0YXJ0XCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgWEhSIHJlcXVlc3QgaGFzIHJlcG9ydGVkIGFuIGFib3J0IGV2ZW50LlxuXHQgKiBAbWV0aG9kIGhhbmRsZUFib3J0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGFib3J0IGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlQWJvcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLl9jbGVhbigpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlhIUl9BQk9SVEVEXCIsIG51bGwsIGV2ZW50KSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgYW4gZXJyb3IgZXZlbnQuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUVycm9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGVycm9yIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLl9jbGVhbigpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXJyb3JFdmVudChldmVudC5tZXNzYWdlKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgYSByZWFkeVN0YXRlIGNoYW5nZS4gTm90ZSB0aGF0IG9sZGVyIGJyb3dzZXJzIChJRSA3ICYgOCkgZG8gbm90IHByb3ZpZGUgYW4gb25sb2FkXG5cdCAqIGV2ZW50LCBzbyB3ZSBtdXN0IG1vbml0b3IgdGhlIHJlYWR5U3RhdGVDaGFuZ2UgdG8gZGV0ZXJtaW5lIGlmIHRoZSBmaWxlIGlzIGxvYWRlZC5cblx0ICogQG1ldGhvZCBfaGFuZGxlUmVhZHlTdGF0ZUNoYW5nZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIFhIUiByZWFkeVN0YXRlQ2hhbmdlIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGlmICh0aGlzLl9yZXF1ZXN0LnJlYWR5U3RhdGUgPT0gNCkge1xuXHRcdFx0dGhpcy5faGFuZGxlTG9hZCgpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVGhlIFhIUiByZXF1ZXN0IGhhcyBjb21wbGV0ZWQuIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSBYSFIgcmVxdWVzdCBkaXJlY3RseSwgb3IgYnkgYSByZWFkeVN0YXRlQ2hhbmdlIHRoYXQgaGFzXG5cdCAqIDxjb2RlPnJlcXVlc3QucmVhZHlTdGF0ZSA9PSA0PC9jb2RlPi4gT25seSB0aGUgZmlyc3QgY2FsbCB0byB0aGlzIG1ldGhvZCB3aWxsIGJlIHByb2Nlc3NlZC5cblx0ICpcblx0ICogTm90ZSB0aGF0IFRoaXMgbWV0aG9kIHVzZXMge3sjY3Jvc3NMaW5rIFwiX2NoZWNrRXJyb3JcIn19e3svY3Jvc3NMaW5rfX0gdG8gZGV0ZXJtaW5lIGlmIHRoZSBzZXJ2ZXIgaGFzIHJldHVybmVkIGFuXG5cdCAqIGVycm9yIGNvZGUuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUxvYWRcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgbG9hZCBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZUxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRpZiAodGhpcy5sb2FkZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5sb2FkZWQgPSB0cnVlO1xuXG5cdFx0dmFyIGVycm9yID0gdGhpcy5fY2hlY2tFcnJvcigpO1xuXHRcdGlmIChlcnJvcikge1xuXHRcdFx0dGhpcy5faGFuZGxlRXJyb3IoZXJyb3IpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3Jlc3BvbnNlID0gdGhpcy5fZ2V0UmVzcG9uc2UoKTtcblx0XHQvLyBDb252ZXJ0IGFycmF5YnVmZmVyIGJhY2sgdG8gYmxvYlxuXHRcdGlmICh0aGlzLl9yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMuX3Jlc3BvbnNlID0gbmV3IEJsb2IoW3RoaXMuX3Jlc3BvbnNlXSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHVzZSBCbG9iQnVpbGRlciBpZiBCbG9iIGNvbnN0cnVjdG9yIGlzIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0Ly8gVGVzdGVkIG9uIEFuZHJvaWQgMi4zIH4gNC4yIGFuZCBpT1M1IHNhZmFyaVxuXHRcdFx0XHR3aW5kb3cuQmxvYkJ1aWxkZXIgPSB3aW5kb3cuQmxvYkJ1aWxkZXIgfHwgd2luZG93LldlYktpdEJsb2JCdWlsZGVyIHx8IHdpbmRvdy5Nb3pCbG9iQnVpbGRlciB8fCB3aW5kb3cuTVNCbG9iQnVpbGRlcjtcblx0XHRcdFx0aWYgKGUubmFtZSA9PT0gJ1R5cGVFcnJvcicgJiYgd2luZG93LkJsb2JCdWlsZGVyKSB7XG5cdFx0XHRcdFx0dmFyIGJ1aWxkZXIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcblx0XHRcdFx0XHRidWlsZGVyLmFwcGVuZCh0aGlzLl9yZXNwb25zZSk7XG5cdFx0XHRcdFx0dGhpcy5fcmVzcG9uc2UgPSBidWlsZGVyLmdldEJsb2IoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9jbGVhbigpO1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FdmVudChcImNvbXBsZXRlXCIpKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIFhIUiByZXF1ZXN0IGhhcyB0aW1lZCBvdXQuIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSBYSFIgcmVxdWVzdCBkaXJlY3RseSwgb3IgdmlhIGEgPGNvZGU+c2V0VGltZW91dDwvY29kZT5cblx0ICogY2FsbGJhY2suXG5cdCAqIEBtZXRob2QgX2hhbmRsZVRpbWVvdXRcblx0ICogQHBhcmFtIHtPYmplY3R9IFtldmVudF0gVGhlIFhIUiB0aW1lb3V0IGV2ZW50LiBUaGlzIGlzIG9jY2FzaW9uYWxseSBudWxsIHdoZW4gY2FsbGVkIGJ5IHRoZSBiYWNrdXAgc2V0VGltZW91dC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVRpbWVvdXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLl9jbGVhbigpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlBSRUxPQURfVElNRU9VVFwiLCBudWxsLCBldmVudCkpO1xuXHR9O1xuXG4vLyBQcm90ZWN0ZWRcblx0LyoqXG5cdCAqIERldGVybWluZSBpZiB0aGVyZSBpcyBhbiBlcnJvciBpbiB0aGUgY3VycmVudCBsb2FkLlxuXHQgKiBDdXJyZW50bHkgdGhpcyBjaGVja3MgdGhlIHN0YXR1cyBvZiB0aGUgcmVxdWVzdCBmb3IgcHJvYmxlbSBjb2RlcywgYW5kIG5vdCBhY3R1YWwgcmVzcG9uc2UgY29udGVudDpcblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPlN0YXR1cyBjb2RlcyBiZXR3ZWVuIDQwMCBhbmQgNTk5IChIVFRQIGVycm9yIHJhbmdlKTwvbGk+XG5cdCAqICAgICA8bGk+QSBzdGF0dXMgb2YgMCwgYnV0ICpvbmx5IHdoZW4gdGhlIGFwcGxpY2F0aW9uIGlzIHJ1bm5pbmcgb24gYSBzZXJ2ZXIqLiBJZiB0aGUgYXBwbGljYXRpb24gaXMgcnVubmluZ1xuXHQgKiAgICAgb24gYGZpbGU6YCwgdGhlbiBpdCBtYXkgaW5jb3JyZWN0bHkgdHJlYXQgYW4gZXJyb3Igb24gbG9jYWwgKG9yIGVtYmVkZGVkIGFwcGxpY2F0aW9ucykgYXMgYSBzdWNjZXNzZnVsXG5cdCAqICAgICBsb2FkLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIEBtZXRob2QgX2NoZWNrRXJyb3Jcblx0ICogQHJldHVybiB7RXJyb3J9IEFuIGVycm9yIHdpdGggdGhlIHN0YXR1cyBjb2RlIGluIHRoZSBgbWVzc2FnZWAgYXJndW1lbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jaGVja0Vycm9yID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzdGF0dXMgPSBwYXJzZUludCh0aGlzLl9yZXF1ZXN0LnN0YXR1cyk7XG5cdFx0aWYgKHN0YXR1cyA+PSA0MDAgJiYgc3RhdHVzIDw9IDU5OSkge1xuXHRcdFx0cmV0dXJuIG5ldyBFcnJvcihzdGF0dXMpO1xuXHRcdH0gZWxzZSBpZiAoc3RhdHVzID09IDApIHtcblx0XHRcdGlmICgoL15odHRwcz86LykudGVzdChsb2NhdGlvbi5wcm90b2NvbCkpIHsgcmV0dXJuIG5ldyBFcnJvcigwKTsgfVxuXHRcdFx0cmV0dXJuIG51bGw7IC8vIExpa2VseSBhbiBlbWJlZGRlZCBhcHAuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fTtcblxuXG5cdC8qKlxuXHQgKiBWYWxpZGF0ZSB0aGUgcmVzcG9uc2UuIERpZmZlcmVudCBicm93c2VycyBoYXZlIGRpZmZlcmVudCBhcHByb2FjaGVzLCBzb21lIG9mIHdoaWNoIHRocm93IGVycm9ycyB3aGVuIGFjY2Vzc2VkXG5cdCAqIGluIG90aGVyIGJyb3dzZXJzLiBJZiB0aGVyZSBpcyBubyByZXNwb25zZSwgdGhlIDxjb2RlPl9yZXNwb25zZTwvY29kZT4gcHJvcGVydHkgd2lsbCByZW1haW4gbnVsbC5cblx0ICogQG1ldGhvZCBfZ2V0UmVzcG9uc2Vcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2dldFJlc3BvbnNlID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZXNwb25zZSAhPSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QucmVzcG9uc2UgIT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JlcXVlc3QucmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQW5kcm9pZCAyLjIgdXNlcyAucmVzcG9uc2VUZXh0XG5cdFx0dHJ5IHtcblx0XHRcdGlmICh0aGlzLl9yZXF1ZXN0LnJlc3BvbnNlVGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXF1ZXN0LnJlc3BvbnNlVGV4dDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiBsb2FkaW5nIFhNTCwgSUU5IGRvZXMgbm90IHJldHVybiAucmVzcG9uc2UsIGluc3RlYWQgaXQgcmV0dXJucyByZXNwb25zZVhNTC54bWxcblx0XHR0cnkge1xuXHRcdFx0aWYgKHRoaXMuX3JlcXVlc3QucmVzcG9uc2VYTUwgIT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVxdWVzdC5yZXNwb25zZVhNTDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhbiBYSFIgcmVxdWVzdC4gRGVwZW5kaW5nIG9uIGEgbnVtYmVyIG9mIGZhY3RvcnMsIHdlIGdldCB0b3RhbGx5IGRpZmZlcmVudCByZXN1bHRzLlxuXHQgKiA8b2w+PGxpPlNvbWUgYnJvd3NlcnMgZ2V0IGFuIDxjb2RlPlhEb21haW5SZXF1ZXN0PC9jb2RlPiB3aGVuIGxvYWRpbmcgY3Jvc3MtZG9tYWluLjwvbGk+XG5cdCAqICAgICAgPGxpPlhNTEh0dHBSZXF1ZXN0IGFyZSBjcmVhdGVkIHdoZW4gYXZhaWxhYmxlLjwvbGk+XG5cdCAqICAgICAgPGxpPkFjdGl2ZVguWE1MSFRUUCBvYmplY3RzIGFyZSB1c2VkIGluIG9sZGVyIElFIGJyb3dzZXJzLjwvbGk+XG5cdCAqICAgICAgPGxpPlRleHQgcmVxdWVzdHMgb3ZlcnJpZGUgdGhlIG1pbWUgdHlwZSBpZiBwb3NzaWJsZTwvbGk+XG5cdCAqICAgICAgPGxpPk9yaWdpbiBoZWFkZXJzIGFyZSBzZW50IGZvciBjcm9zc2RvbWFpbiByZXF1ZXN0cyBpbiBzb21lIGJyb3dzZXJzLjwvbGk+XG5cdCAqICAgICAgPGxpPkJpbmFyeSBsb2FkcyBzZXQgdGhlIHJlc3BvbnNlIHR5cGUgdG8gXCJhcnJheWJ1ZmZlclwiPC9saT48L29sPlxuXHQgKiBAbWV0aG9kIF9jcmVhdGVYSFJcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIHJlcXVlc3RlZCBpdGVtIHRoYXQgaXMgYmVpbmcgbG9hZGVkLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiBhbiBYSFIgcmVxdWVzdCBvciBlcXVpdmFsZW50IHdhcyBzdWNjZXNzZnVsbHkgY3JlYXRlZC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NyZWF0ZVhIUiA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0Ly8gQ2hlY2sgZm9yIGNyb3NzLWRvbWFpbiBsb2Fkcy4gV2UgY2FuJ3QgZnVsbHkgc3VwcG9ydCB0aGVtLCBidXQgd2UgY2FuIHRyeS5cblx0XHR2YXIgY3Jvc3Nkb21haW4gPSBjcmVhdGVqcy5VUkxVdGlscy5pc0Nyb3NzRG9tYWluKGl0ZW0pO1xuXHRcdHZhciBoZWFkZXJzID0ge307XG5cblx0XHQvLyBDcmVhdGUgdGhlIHJlcXVlc3QuIEZhbGxiYWNrIHRvIHdoYXRldmVyIHN1cHBvcnQgd2UgaGF2ZS5cblx0XHR2YXIgcmVxID0gbnVsbDtcblx0XHRpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG5cdFx0XHRyZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHRcdC8vIFRoaXMgaXMgOCBvciA5LCBzbyB1c2UgWERvbWFpblJlcXVlc3QgaW5zdGVhZC5cblx0XHRcdGlmIChjcm9zc2RvbWFpbiAmJiByZXEud2l0aENyZWRlbnRpYWxzID09PSB1bmRlZmluZWQgJiYgd2luZG93LlhEb21haW5SZXF1ZXN0KSB7XG5cdFx0XHRcdHJlcSA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7IC8vIE9sZCBJRSB2ZXJzaW9ucyB1c2UgYSBkaWZmZXJlbnQgYXBwcm9hY2hcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcy5BQ1RJVkVYX1ZFUlNJT05TLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgYXhWZXJzaW9uID0gcy5BQ1RJVkVYX1ZFUlNJT05TW2ldO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJlcSA9IG5ldyBBY3RpdmVYT2JqZWN0KGF4VmVyc2lvbik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHJlcSA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBEZWZhdWx0IHRvIHV0Zi04IGZvciBUZXh0IHJlcXVlc3RzLlxuXHRcdGlmIChpdGVtLm1pbWVUeXBlID09IG51bGwgJiYgY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzVGV4dChpdGVtLnR5cGUpKSB7XG5cdFx0XHRpdGVtLm1pbWVUeXBlID0gXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCI7XG5cdFx0fVxuXG5cdFx0Ly8gSUU5IGRvZXNuJ3Qgc3VwcG9ydCBvdmVycmlkZU1pbWVUeXBlKCksIHNvIHdlIG5lZWQgdG8gY2hlY2sgZm9yIGl0LlxuXHRcdGlmIChpdGVtLm1pbWVUeXBlICYmIHJlcS5vdmVycmlkZU1pbWVUeXBlKSB7XG5cdFx0XHRyZXEub3ZlcnJpZGVNaW1lVHlwZShpdGVtLm1pbWVUeXBlKTtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgdGhlIFhIUiBsZXZlbFxuXHRcdHRoaXMuX3hockxldmVsID0gKHR5cGVvZiByZXEucmVzcG9uc2VUeXBlID09PSBcInN0cmluZ1wiKSA/IDIgOiAxO1xuXG5cdFx0dmFyIHNyYyA9IG51bGw7XG5cdFx0aWYgKGl0ZW0ubWV0aG9kID09IGNyZWF0ZWpzLk1ldGhvZHMuR0VUKSB7XG5cdFx0XHRzcmMgPSBjcmVhdGVqcy5VUkxVdGlscy5idWlsZFVSSShpdGVtLnNyYywgaXRlbS52YWx1ZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcmMgPSBpdGVtLnNyYztcblx0XHR9XG5cblx0XHQvLyBPcGVuIHRoZSByZXF1ZXN0LiAgU2V0IGNyb3NzLWRvbWFpbiBmbGFncyBpZiBpdCBpcyBzdXBwb3J0ZWQgKFhIUiBsZXZlbCAxIG9ubHkpXG5cdFx0cmVxLm9wZW4oaXRlbS5tZXRob2QgfHwgY3JlYXRlanMuTWV0aG9kcy5HRVQsIHNyYywgdHJ1ZSk7XG5cblx0XHRpZiAoY3Jvc3Nkb21haW4gJiYgcmVxIGluc3RhbmNlb2YgWE1MSHR0cFJlcXVlc3QgJiYgdGhpcy5feGhyTGV2ZWwgPT0gMSkge1xuXHRcdFx0aGVhZGVyc1tcIk9yaWdpblwiXSA9IGxvY2F0aW9uLm9yaWdpbjtcblx0XHR9XG5cblx0XHQvLyBUbyBzZW5kIGRhdGEgd2UgbmVlZCB0byBzZXQgdGhlIENvbnRlbnQtdHlwZSBoZWFkZXIpXG5cdFx0aWYgKGl0ZW0udmFsdWVzICYmIGl0ZW0ubWV0aG9kID09IGNyZWF0ZWpzLk1ldGhvZHMuUE9TVCkge1xuXHRcdFx0aGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI7XG5cdFx0fVxuXG5cdFx0aWYgKCFjcm9zc2RvbWFpbiAmJiAhaGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl0pIHtcblx0XHRcdGhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdH1cblxuXHRcdGlmIChpdGVtLmhlYWRlcnMpIHtcblx0XHRcdGZvciAodmFyIG4gaW4gaXRlbS5oZWFkZXJzKSB7XG5cdFx0XHRcdGhlYWRlcnNbbl0gPSBpdGVtLmhlYWRlcnNbbl07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChuIGluIGhlYWRlcnMpIHtcblx0XHRcdHJlcS5zZXRSZXF1ZXN0SGVhZGVyKG4sIGhlYWRlcnNbbl0pXG5cdFx0fVxuXG5cdFx0aWYgKHJlcSBpbnN0YW5jZW9mIFhNTEh0dHBSZXF1ZXN0ICYmIGl0ZW0ud2l0aENyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJlcS53aXRoQ3JlZGVudGlhbHMgPSBpdGVtLndpdGhDcmVkZW50aWFscztcblx0XHR9XG5cblx0XHR0aGlzLl9yZXF1ZXN0ID0gcmVxO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEEgcmVxdWVzdCBoYXMgY29tcGxldGVkIChvciBmYWlsZWQgb3IgY2FuY2VsZWQpLCBhbmQgbmVlZHMgdG8gYmUgZGlzcG9zZWQuXG5cdCAqIEBtZXRob2QgX2NsZWFuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jbGVhbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fbG9hZFRpbWVvdXQpO1xuXG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lciAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2Fkc3RhcnRcIiwgdGhpcy5faGFuZGxlTG9hZFN0YXJ0UHJveHkpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgdGhpcy5faGFuZGxlUHJvZ3Jlc3NQcm94eSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCB0aGlzLl9oYW5kbGVBYm9ydFByb3h5KTtcblx0XHRcdHRoaXMuX3JlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHRoaXMuX2hhbmRsZUVycm9yUHJveHkpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwidGltZW91dFwiLCB0aGlzLl9oYW5kbGVUaW1lb3V0UHJveHkpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCB0aGlzLl9oYW5kbGVMb2FkUHJveHkpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLCB0aGlzLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlUHJveHkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9ubG9hZHN0YXJ0ID0gbnVsbDtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25wcm9ncmVzcyA9IG51bGw7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9uYWJvcnQgPSBudWxsO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbmVycm9yID0gbnVsbDtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub250aW1lb3V0ID0gbnVsbDtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25sb2FkID0gbnVsbDtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbUHJlbG9hZEpTIFhIUlJlcXVlc3RdXCI7XG5cdH07XG5cblx0Y3JlYXRlanMuWEhSUmVxdWVzdCA9IGNyZWF0ZWpzLnByb21vdGUoWEhSUmVxdWVzdCwgXCJBYnN0cmFjdFJlcXVlc3RcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBMb2FkUXVldWUuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbndpbmRvdy5jcmVhdGVqcyA9IHdpbmRvdy5jcmVhdGVqcyB8fCB7fTtcblxuLypcbiBUT0RPOiBXSU5ET1dTIElTU1VFU1xuICogTm8gZXJyb3IgZm9yIEhUTUwgYXVkaW8gaW4gSUUgNjc4XG4gKiBTVkcgbm8gZmFpbHVyZSBlcnJvciBpbiBJRSA2NyAobWF5YmUgOCkgVEFHUyBBTkQgWEhSXG4gKiBObyBzY3JpcHQgY29tcGxldGUgaGFuZGxlciBpbiBJRSA2NyBUQUdTIChYSFIgaXMgZmluZSlcbiAqIE5vIFhNTC9KU09OIGluIElFNiBUQUdTXG4gKiBOZWVkIHRvIGhpZGUgbG9hZGluZyBTVkcgaW4gT3BlcmEgVEFHU1xuICogTm8gQ1NTIG9ubG9hZC9yZWFkeXN0YXRlY2hhbmdlIGluIFNhZmFyaSBvciBBbmRyb2lkIFRBR1MgKHJlcXVpcmVzIHJ1bGUgY2hlY2tpbmcpXG4gKiBTVkcgbm8gbG9hZCBvciBmYWlsdXJlIGluIE9wZXJhIFhIUlxuICogUmVwb3J0ZWQgaXNzdWVzIHdpdGggSUU3LzhcbiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuLy8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIFRoZSBMb2FkUXVldWUgY2xhc3MgaXMgdGhlIG1haW4gQVBJIGZvciBwcmVsb2FkaW5nIGNvbnRlbnQuIExvYWRRdWV1ZSBpcyBhIGxvYWQgbWFuYWdlciwgd2hpY2ggY2FuIHByZWxvYWQgZWl0aGVyXG5cdCAqIGEgc2luZ2xlIGZpbGUsIG9yIHF1ZXVlIG9mIGZpbGVzLlxuXHQgKlxuXHQgKiA8Yj5DcmVhdGluZyBhIFF1ZXVlPC9iPjxiciAvPlxuXHQgKiBUbyB1c2UgTG9hZFF1ZXVlLCBjcmVhdGUgYSBMb2FkUXVldWUgaW5zdGFuY2UuIElmIHlvdSB3YW50IHRvIGZvcmNlIHRhZyBsb2FkaW5nIHdoZXJlIHBvc3NpYmxlLCBzZXQgdGhlIHByZWZlclhIUlxuXHQgKiBhcmd1bWVudCB0byBmYWxzZS5cblx0ICpcblx0ICogICAgICB2YXIgcXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKHRydWUpO1xuXHQgKlxuXHQgKiA8Yj5MaXN0ZW5pbmcgZm9yIEV2ZW50czwvYj48YnIgLz5cblx0ICogQWRkIGFueSBsaXN0ZW5lcnMgeW91IHdhbnQgdG8gdGhlIHF1ZXVlLiBTaW5jZSBQcmVsb2FkSlMgMC4zLjAsIHRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbGV0cyB5b3UgYWRkIGFzIG1hbnkgbGlzdGVuZXJzIGFzIHlvdSB3YW50IGZvciBldmVudHMuIFlvdSBjYW4gc3Vic2NyaWJlIHRvIHRoZSBmb2xsb3dpbmcgZXZlbnRzOjx1bD5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9jb21wbGV0ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fTogZmlyZWQgd2hlbiBhIHF1ZXVlIGNvbXBsZXRlcyBsb2FkaW5nIGFsbFxuXHQgKiAgICAgZmlsZXM8L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2Vycm9yOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319OiBmaXJlZCB3aGVuIHRoZSBxdWV1ZSBlbmNvdW50ZXJzIGFuIGVycm9yIHdpdGhcblx0ICogICAgIGFueSBmaWxlLjwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvcHJvZ3Jlc3M6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX06IFByb2dyZXNzIGZvciB0aGUgZW50aXJlIHF1ZXVlIGhhc1xuXHQgKiAgICAgY2hhbmdlZC48L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fTogQSBzaW5nbGUgZmlsZSBoYXMgY29tcGxldGVkIGxvYWRpbmcuPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZXByb2dyZXNzOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319OiBQcm9ncmVzcyBmb3IgYSBzaW5nbGUgZmlsZSBoYXMgY2hhbmdlcy4gTm90ZVxuXHQgKiAgICAgdGhhdCBvbmx5IGZpbGVzIGxvYWRlZCB3aXRoIFhIUiAob3IgcG9zc2libHkgYnkgcGx1Z2lucykgd2lsbCBmaXJlIHByb2dyZXNzIGV2ZW50cyBvdGhlciB0aGFuIDAgb3IgMTAwJS48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiAgICAgIHF1ZXVlLm9uKFwiZmlsZWxvYWRcIiwgaGFuZGxlRmlsZUxvYWQsIHRoaXMpO1xuXHQgKiAgICAgIHF1ZXVlLm9uKFwiY29tcGxldGVcIiwgaGFuZGxlQ29tcGxldGUsIHRoaXMpO1xuXHQgKlxuXHQgKiA8Yj5BZGRpbmcgZmlsZXMgYW5kIG1hbmlmZXN0czwvYj48YnIgLz5cblx0ICogQWRkIGZpbGVzIHlvdSB3YW50IHRvIGxvYWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319IG9yIGFkZCBtdWx0aXBsZSBmaWxlcyBhdCBhXG5cdCAqIHRpbWUgdXNpbmcgYSBsaXN0IG9yIGEgbWFuaWZlc3QgZGVmaW5pdGlvbiB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319LiBGaWxlcyBhcmVcblx0ICogYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgYWN0aXZlIHF1ZXVlLCBzbyB5b3UgY2FuIHVzZSB0aGVzZSBtZXRob2RzIGFzIG1hbnkgdGltZXMgYXMgeW91IGxpa2UsIHdoZW5ldmVyIHlvdVxuXHQgKiBsaWtlLlxuXHQgKlxuXHQgKiAgICAgIHF1ZXVlLmxvYWRGaWxlKFwiZmlsZVBhdGgvZmlsZS5qcGdcIik7XG5cdCAqICAgICAgcXVldWUubG9hZEZpbGUoe2lkOlwiaW1hZ2VcIiwgc3JjOlwiZmlsZVBhdGgvZmlsZS5qcGdcIn0pO1xuXHQgKiAgICAgIHF1ZXVlLmxvYWRNYW5pZmVzdChbXCJmaWxlUGF0aC9maWxlLmpwZ1wiLCB7aWQ6XCJpbWFnZVwiLCBzcmM6XCJmaWxlUGF0aC9maWxlLmpwZ1wifV0pO1xuXHQgKlxuXHQgKiAgICAgIC8vIFVzZSBhbiBleHRlcm5hbCBtYW5pZmVzdFxuXHQgKiAgICAgIHF1ZXVlLmxvYWRNYW5pZmVzdChcInBhdGgvdG8vbWFuaWZlc3QuanNvblwiKTtcblx0ICogICAgICBxdWV1ZS5sb2FkTWFuaWZlc3Qoe3NyYzpcIm1hbmlmZXN0Lmpzb25cIiwgdHlwZTpcIm1hbmlmZXN0XCJ9KTtcblx0ICpcblx0ICogSWYgeW91IHBhc3MgYGZhbHNlYCBhcyB0aGUgYGxvYWROb3dgIHBhcmFtZXRlciwgdGhlIHF1ZXVlIHdpbGwgbm90IGtpY2sgb2YgdGhlIGxvYWQgb2YgdGhlIGZpbGVzLCBidXQgaXQgd2lsbCBub3Rcblx0ICogc3RvcCBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQuIENhbGwgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2xvYWRcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIHRvIGJlZ2luXG5cdCAqIGEgcGF1c2VkIHF1ZXVlLiBOb3RlIHRoYXQgYSBwYXVzZWQgcXVldWUgd2lsbCBhdXRvbWF0aWNhbGx5IHJlc3VtZSB3aGVuIG5ldyBmaWxlcyBhcmUgYWRkZWQgdG8gaXQgd2l0aCBhXG5cdCAqIGBsb2FkTm93YCBhcmd1bWVudCBvZiBgdHJ1ZWAuXG5cdCAqXG5cdCAqICAgICAgcXVldWUubG9hZCgpO1xuXHQgKlxuXHQgKiA8Yj5GaWxlIFR5cGVzPC9iPjxiciAvPlxuXHQgKiBUaGUgZmlsZSB0eXBlIG9mIGEgbWFuaWZlc3QgaXRlbSBpcyBhdXRvLWRldGVybWluZWQgYnkgdGhlIGZpbGUgZXh0ZW5zaW9uLiBUaGUgcGF0dGVybiBtYXRjaGluZyBpbiBQcmVsb2FkSlNcblx0ICogc2hvdWxkIGhhbmRsZSB0aGUgbWFqb3JpdHkgb2Ygc3RhbmRhcmQgZmlsZSBhbmQgdXJsIGZvcm1hdHMsIGFuZCB3b3JrcyB3aXRoIGNvbW1vbiBmaWxlIGV4dGVuc2lvbnMuIElmIHlvdSBoYXZlXG5cdCAqIGVpdGhlciBhIG5vbi1zdGFuZGFyZCBmaWxlIGV4dGVuc2lvbiwgb3IgYXJlIHNlcnZpbmcgdGhlIGZpbGUgdXNpbmcgYSBwcm94eSBzY3JpcHQsIHRoZW4geW91IGNhbiBwYXNzIGluIGFcblx0ICogPGNvZGU+dHlwZTwvY29kZT4gcHJvcGVydHkgd2l0aCBhbnkgbWFuaWZlc3QgaXRlbS5cblx0ICpcblx0ICogICAgICBxdWV1ZS5sb2FkRmlsZSh7c3JjOlwicGF0aC90by9teUZpbGUubXAzeFwiLCB0eXBlOmNyZWF0ZWpzLlR5cGVzLlNPVU5EfSk7XG5cdCAqXG5cdCAqICAgICAgLy8gTm90ZSB0aGF0IFByZWxvYWRKUyB3aWxsIG5vdCByZWFkIGEgZmlsZSBleHRlbnNpb24gZnJvbSB0aGUgcXVlcnkgc3RyaW5nXG5cdCAqICAgICAgcXVldWUubG9hZEZpbGUoe3NyYzpcImh0dHA6Ly9zZXJ2ZXIuY29tL3Byb3h5P2ZpbGU9aW1hZ2UuanBnXCIsIHR5cGU6Y3JlYXRlanMuVHlwZXMuSU1BR0V9KTtcblx0ICpcblx0ICogU3VwcG9ydGVkIHR5cGVzIGFyZSBkZWZpbmVkIG9uIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlclwifX17ey9jcm9zc0xpbmt9fSBjbGFzcywgYW5kIGluY2x1ZGU6XG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJUeXBlcy9CSU5BUlk6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IFJhdyBiaW5hcnkgZGF0YSB2aWEgWEhSPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJUeXBlcy9DU1M6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IENTUyBmaWxlczwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiVHlwZXMvSU1BR0U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IENvbW1vbiBpbWFnZSBmb3JtYXRzPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJUeXBlcy9KQVZBU0NSSVBUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBKYXZhU2NyaXB0IGZpbGVzPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJUeXBlcy9KU09OOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBKU09OIGRhdGE8L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIlR5cGVzL0pTT05QOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBKU09OIGZpbGVzIGNyb3NzLWRvbWFpbjwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiVHlwZXMvTUFOSUZFU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IEEgbGlzdCBvZiBmaWxlcyB0byBsb2FkIGluIEpTT04gZm9ybWF0LCBzZWVcblx0ICogICAgIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fTwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiVHlwZXMvU09VTkQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IEF1ZGlvIGZpbGUgZm9ybWF0czwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiVHlwZXMvU1BSSVRFU0hFRVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IEpTT04gU3ByaXRlU2hlZXQgZGVmaW5pdGlvbnMuIFRoaXNcblx0ICogICAgIHdpbGwgYWxzbyBsb2FkIHN1Yi1pbWFnZXMsIGFuZCBwcm92aWRlIGEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UuPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJUeXBlcy9TVkc6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IFNWRyBmaWxlczwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiVHlwZXMvVEVYVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogVGV4dCBmaWxlcyAtIFhIUiBvbmx5PC9saT5cbiAgICAgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIlR5cGVzL1ZJREVPOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBWaWRlbyBvYmplY3RzPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJUeXBlcy9YTUw6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IFhNTCBkYXRhPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogPGVtPk5vdGU6IExvYWRlciB0eXBlcyB1c2VkIHRvIGJlIGRlZmluZWQgb24gTG9hZFF1ZXVlLCBidXQgaGF2ZSBiZWVuIG1vdmVkIHRvIHRoZSBUeXBlcyBjbGFzczwvZW0+XG5cdCAqXG5cdCAqIDxiPkhhbmRsaW5nIFJlc3VsdHM8L2I+PGJyIC8+XG5cdCAqIFdoZW4gYSBmaWxlIGlzIGZpbmlzaGVkIGRvd25sb2FkaW5nLCBhIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBpc1xuXHQgKiBkaXNwYXRjaGVkLiBJbiBhbiBleGFtcGxlIGFib3ZlLCB0aGVyZSBpcyBhbiBldmVudCBsaXN0ZW5lciBzbmlwcGV0IGZvciBmaWxlbG9hZC4gTG9hZGVkIGZpbGVzIGFyZSB1c3VhbGx5IGFcblx0ICogZm9ybWF0dGVkIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGltbWVkaWF0ZWx5LCBpbmNsdWRpbmc6XG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5CaW5hcnk6IFRoZSBiaW5hcnkgbG9hZGVkIHJlc3VsdDwvbGk+XG5cdCAqICAgICA8bGk+Q1NTOiBBICZsdDtsaW5rIC8mZ3Q7IHRhZzwvbGk+XG5cdCAqICAgICA8bGk+SW1hZ2U6IEFuICZsdDtpbWcgLyZndDsgdGFnPC9saT5cblx0ICogICAgIDxsaT5KYXZhU2NyaXB0OiBBICZsdDtzY3JpcHQgLyZndDsgdGFnPC9saT5cblx0ICogICAgIDxsaT5KU09OL0pTT05QOiBBIGZvcm1hdHRlZCBKYXZhU2NyaXB0IE9iamVjdDwvbGk+XG5cdCAqICAgICA8bGk+TWFuaWZlc3Q6IEEgSmF2YVNjcmlwdCBvYmplY3QuXG5cdCAqICAgICA8bGk+U291bmQ6IEFuICZsdDthdWRpbyAvJmd0OyB0YWc8L2E+XG5cdCAqICAgICA8bGk+U3ByaXRlU2hlZXQ6IEEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UsIGNvbnRhaW5pbmcgbG9hZGVkIGltYWdlcy5cblx0ICogICAgIDxsaT5TVkc6IEFuICZsdDtvYmplY3QgLyZndDsgdGFnPC9saT5cblx0ICogICAgIDxsaT5UZXh0OiBSYXcgdGV4dDwvbGk+XG4gICAgICogICAgIDxsaT5WaWRlbzogQSBWaWRlbyBET00gbm9kZTwvbGk+XG5cdCAqICAgICA8bGk+WE1MOiBBbiBYTUwgRE9NIG5vZGU8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZUZpbGVMb2FkKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIHZhciBpdGVtID0gZXZlbnQuaXRlbTsgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGl0ZW0gdGhhdCB3YXMgcGFzc2VkIGluIHRvIHRoZSBMb2FkUXVldWVcblx0ICogICAgICAgICAgdmFyIHR5cGUgPSBpdGVtLnR5cGU7XG5cdCAqXG5cdCAqICAgICAgICAgIC8vIEFkZCBhbnkgaW1hZ2VzIHRvIHRoZSBwYWdlIGJvZHkuXG5cdCAqICAgICAgICAgIGlmICh0eXBlID09IGNyZWF0ZWpzLlR5cGVzLklNQUdFKSB7XG5cdCAqICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGV2ZW50LnJlc3VsdCk7XG5cdCAqICAgICAgICAgIH1cblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEF0IGFueSB0aW1lIGFmdGVyIHRoZSBmaWxlIGhhcyBiZWVuIGxvYWRlZCAodXN1YWxseSBhZnRlciB0aGUgcXVldWUgaGFzIGNvbXBsZXRlZCksIGFueSByZXN1bHQgY2FuIGJlIGxvb2tlZCB1cFxuXHQgKiB2aWEgaXRzIFwiaWRcIiB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZ2V0UmVzdWx0XCJ9fXt7L2Nyb3NzTGlua319LiBJZiBubyBpZCB3YXMgcHJvdmlkZWQsIHRoZW4gdGhlXG5cdCAqIFwic3JjXCIgb3IgZmlsZSBwYXRoIGNhbiBiZSB1c2VkIGluc3RlYWQsIGluY2x1ZGluZyB0aGUgYHBhdGhgIGRlZmluZWQgYnkgYSBtYW5pZmVzdCwgYnV0IDxzdHJvbmc+bm90IGluY2x1ZGluZzwvc3Ryb25nPlxuXHQgKiBhIGJhc2UgcGF0aCBkZWZpbmVkIG9uIHRoZSBMb2FkUXVldWUuIEl0IGlzIHJlY29tbWVuZGVkIHRvIGFsd2F5cyBwYXNzIGFuIGlkIGlmIHlvdSB3YW50IHRvIGxvb2sgdXAgY29udGVudC5cblx0ICpcblx0ICogICAgICB2YXIgaW1hZ2UgPSBxdWV1ZS5nZXRSZXN1bHQoXCJpbWFnZVwiKTtcblx0ICogICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGltYWdlKTtcblx0ICpcblx0ICogUmF3IGxvYWRlZCBjb250ZW50IGNhbiBiZSBhY2Nlc3NlZCB1c2luZyB0aGUgPGNvZGU+cmF3UmVzdWx0PC9jb2RlPiBwcm9wZXJ0eSBvZiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50LCBvciBjYW4gYmUgbG9va2VkIHVwIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9nZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX0sIHBhc3NpbmcgYHRydWVgIGFzIHRoZSAybmRcblx0ICogYXJndW1lbnQuIFRoaXMgaXMgb25seSBhcHBsaWNhYmxlIGZvciBjb250ZW50IHRoYXQgaGFzIGJlZW4gcGFyc2VkIGZvciB0aGUgYnJvd3Nlciwgc3BlY2lmaWNhbGx5OiBKYXZhU2NyaXB0LFxuXHQgKiBDU1MsIFhNTCwgU1ZHLCBhbmQgSlNPTiBvYmplY3RzLCBvciBhbnl0aGluZyBsb2FkZWQgd2l0aCBYSFIuXG5cdCAqXG5cdCAqICAgICAgdmFyIGltYWdlID0gcXVldWUuZ2V0UmVzdWx0KFwiaW1hZ2VcIiwgdHJ1ZSk7IC8vIGxvYWQgdGhlIGJpbmFyeSBpbWFnZSBkYXRhIGxvYWRlZCB3aXRoIFhIUi5cblx0ICpcblx0ICogPGI+UGx1Z2luczwvYj48YnIgLz5cblx0ICogTG9hZFF1ZXVlIGhhcyBhIHNpbXBsZSBwbHVnaW4gYXJjaGl0ZWN0dXJlIHRvIGhlbHAgcHJvY2VzcyBhbmQgcHJlbG9hZCBjb250ZW50LiBGb3IgZXhhbXBsZSwgdG8gcHJlbG9hZCBhdWRpbyxcblx0ICogbWFrZSBzdXJlIHRvIGluc3RhbGwgdGhlIDxhIGhyZWY9XCJodHRwOi8vc291bmRqcy5jb21cIj5Tb3VuZEpTPC9hPiBTb3VuZCBjbGFzcywgd2hpY2ggd2lsbCBoZWxwIGxvYWQgSFRNTCBhdWRpbyxcblx0ICogRmxhc2ggYXVkaW8sIGFuZCBXZWJBdWRpbyBmaWxlcy4gVGhpcyBzaG91bGQgYmUgaW5zdGFsbGVkIDxzdHJvbmc+YmVmb3JlPC9zdHJvbmc+IGxvYWRpbmcgYW55IGF1ZGlvIGZpbGVzLlxuXHQgKlxuXHQgKiAgICAgIHF1ZXVlLmluc3RhbGxQbHVnaW4oY3JlYXRlanMuU291bmQpO1xuXHQgKlxuXHQgKiA8aDQ+S25vd24gQnJvd3NlciBJc3N1ZXM8L2g0PlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+QnJvd3NlcnMgd2l0aG91dCBhdWRpbyBzdXBwb3J0IGNhbiBub3QgbG9hZCBhdWRpbyBmaWxlcy48L2xpPlxuXHQgKiAgICAgPGxpPlNhZmFyaSBvbiBNYWMgT1MgWCBjYW4gb25seSBwbGF5IEhUTUwgYXVkaW8gaWYgUXVpY2tUaW1lIGlzIGluc3RhbGxlZDwvbGk+XG5cdCAqICAgICA8bGk+SFRNTCBBdWRpbyB0YWdzIHdpbGwgb25seSBkb3dubG9hZCB1bnRpbCB0aGVpciA8Y29kZT5jYW5QbGF5VGhyb3VnaDwvY29kZT4gZXZlbnQgaXMgZmlyZWQuIEJyb3dzZXJzIG90aGVyXG5cdCAqICAgICB0aGFuIENocm9tZSB3aWxsIGNvbnRpbnVlIHRvIGRvd25sb2FkIGluIHRoZSBiYWNrZ3JvdW5kLjwvbGk+XG5cdCAqICAgICA8bGk+V2hlbiBsb2FkaW5nIHNjcmlwdHMgdXNpbmcgdGFncywgdGhleSBhcmUgYXV0b21hdGljYWxseSBhZGRlZCB0byB0aGUgZG9jdW1lbnQuPC9saT5cblx0ICogICAgIDxsaT5TY3JpcHRzIGxvYWRlZCB2aWEgWEhSIG1heSBub3QgYmUgcHJvcGVybHkgaW5zcGVjdGFibGUgd2l0aCBicm93c2VyIHRvb2xzLjwvbGk+XG5cdCAqICAgICA8bGk+SUU2IGFuZCBJRTcgKGFuZCBzb21lIG90aGVyIGJyb3dzZXJzKSBtYXkgbm90IGJlIGFibGUgdG8gbG9hZCBYTUwsIFRleHQsIG9yIEpTT04sIHNpbmNlIHRoZXkgcmVxdWlyZVxuXHQgKiAgICAgWEhSIHRvIHdvcmsuPC9saT5cblx0ICogICAgIDxsaT5Db250ZW50IGxvYWRlZCB2aWEgdGFncyB3aWxsIG5vdCBzaG93IHByb2dyZXNzLCBhbmQgd2lsbCBjb250aW51ZSB0byBkb3dubG9hZCBpbiB0aGUgYmFja2dyb3VuZCB3aGVuXG5cdCAqICAgICBjYW5jZWxlZCwgYWx0aG91Z2ggbm8gZXZlbnRzIHdpbGwgYmUgZGlzcGF0Y2hlZC48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiBAY2xhc3MgTG9hZFF1ZXVlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ByZWZlclhIUj10cnVlXSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHByZWxvYWQgaW5zdGFuY2Ugd2lsbCBmYXZvciBsb2FkaW5nIHdpdGggWEhSIChYTUwgSFRUUFxuXHQgKiBSZXF1ZXN0cyksIG9yIEhUTUwgdGFncy4gV2hlbiB0aGlzIGlzIGBmYWxzZWAsIHRoZSBxdWV1ZSB3aWxsIHVzZSB0YWcgbG9hZGluZyB3aGVuIHBvc3NpYmxlLCBhbmQgZmFsbCBiYWNrIG9uIFhIUlxuXHQgKiB3aGVuIG5lY2Vzc2FyeS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtiYXNlUGF0aD1cIlwiXSBBIHBhdGggdGhhdCB3aWxsIGJlIHByZXBlbmRlZCBvbiB0byB0aGUgc291cmNlIHBhcmFtZXRlciBvZiBhbGwgaXRlbXMgaW4gdGhlIHF1ZXVlXG5cdCAqIGJlZm9yZSB0aGV5IGFyZSBsb2FkZWQuICBTb3VyY2VzIGJlZ2lubmluZyB3aXRoIGEgcHJvdG9jb2wgc3VjaCBhcyBgaHR0cDovL2Agb3IgYSByZWxhdGl2ZSBwYXRoIHN1Y2ggYXMgYC4uL2Bcblx0ICogd2lsbCBub3QgcmVjZWl2ZSBhIGJhc2UgcGF0aC5cblx0ICogQHBhcmFtIHtTdHJpbmd8Qm9vbGVhbn0gW2Nyb3NzT3JpZ2luPVwiXCJdIEFuIG9wdGlvbmFsIGZsYWcgdG8gc3VwcG9ydCBpbWFnZXMgbG9hZGVkIGZyb20gYSBDT1JTLWVuYWJsZWQgc2VydmVyLiBUb1xuXHQgKiB1c2UgaXQsIHNldCB0aGlzIHZhbHVlIHRvIGB0cnVlYCwgd2hpY2ggd2lsbCBkZWZhdWx0IHRoZSBjcm9zc09yaWdpbiBwcm9wZXJ0eSBvbiBpbWFnZXMgdG8gXCJBbm9ueW1vdXNcIi4gQW55XG5cdCAqIHN0cmluZyB2YWx1ZSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoLCBidXQgb25seSBcIlwiIGFuZCBcIkFub255bW91c1wiIGFyZSByZWNvbW1lbmRlZC4gPHN0cm9uZz5Ob3RlOiBUaGUgY3Jvc3NPcmlnaW5cblx0ICogcGFyYW1ldGVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBMb2FkSXRlbS5jcm9zc09yaWdpbiBpbnN0ZWFkPC9zdHJvbmc+XG5cdCAqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKi9cblx0ZnVuY3Rpb24gTG9hZFF1ZXVlIChwcmVmZXJYSFIsIGJhc2VQYXRoLCBjcm9zc09yaWdpbikge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IoKTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IG9mIHRoZSBwbHVnaW5zIHJlZ2lzdGVyZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2luc3RhbGxQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IF9wbHVnaW5zXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHNpbmNlIDAuNi4xXG5cdFx0ICovXG5cdFx0dGhpcy5fcGx1Z2lucyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IGhhc2ggb2YgY2FsbGJhY2tzIHRoYXQgYXJlIGZpcmVkIGZvciBlYWNoIGZpbGUgdHlwZSBiZWZvcmUgdGhlIGZpbGUgaXMgbG9hZGVkLCBnaXZpbmcgcGx1Z2lucyB0aGVcblx0XHQgKiBhYmlsaXR5IHRvIG92ZXJyaWRlIHByb3BlcnRpZXMgb2YgdGhlIGxvYWQuIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9pbnN0YWxsUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogbWV0aG9kIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBfdHlwZUNhbGxiYWNrc1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl90eXBlQ2FsbGJhY2tzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgaGFzaCBvZiBjYWxsYmFja3MgdGhhdCBhcmUgZmlyZWQgZm9yIGVhY2ggZmlsZSBleHRlbnNpb24gYmVmb3JlIHRoZSBmaWxlIGlzIGxvYWRlZCwgZ2l2aW5nIHBsdWdpbnMgdGhlXG5cdFx0ICogYWJpbGl0eSB0byBvdmVycmlkZSBwcm9wZXJ0aWVzIG9mIHRoZSBsb2FkLiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvaW5zdGFsbFBsdWdpblwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIG1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgX2V4dGVuc2lvbkNhbGxiYWNrc1xuXHRcdCAqIEB0eXBlIHtudWxsfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fZXh0ZW5zaW9uQ2FsbGJhY2tzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbmV4dCBwcmVsb2FkIHF1ZXVlIHRvIHByb2Nlc3Mgd2hlbiB0aGlzIG9uZSBpcyBjb21wbGV0ZS4gSWYgYW4gZXJyb3IgaXMgdGhyb3duIGluIHRoZSBjdXJyZW50IHF1ZXVlLCBhbmRcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc3RvcE9uRXJyb3I6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaXMgYHRydWVgLCB0aGUgbmV4dCBxdWV1ZSB3aWxsIG5vdCBiZSBwcm9jZXNzZWQuXG5cdFx0ICogQHByb3BlcnR5IG5leHRcblx0XHQgKiBAdHlwZSB7TG9hZFF1ZXVlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLm5leHQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogRW5zdXJlIGxvYWRlZCBzY3JpcHRzIFwiY29tcGxldGVcIiBpbiB0aGUgb3JkZXIgdGhleSBhcmUgc3BlY2lmaWVkLiBMb2FkZWQgc2NyaXB0cyBhcmUgYWRkZWQgdG8gdGhlIGRvY3VtZW50IGhlYWRcblx0XHQgKiBvbmNlIHRoZXkgYXJlIGxvYWRlZC4gU2NyaXB0cyBsb2FkZWQgdmlhIHRhZ3Mgd2lsbCBsb2FkIG9uZS1hdC1hLXRpbWUgd2hlbiB0aGlzIHByb3BlcnR5IGlzIGB0cnVlYCwgd2hlcmVhc1xuXHRcdCAqIHNjcmlwdHMgbG9hZGVkIHVzaW5nIFhIUiBjYW4gbG9hZCBpbiBhbnkgb3JkZXIsIGJ1dCB3aWxsIFwiZmluaXNoXCIgYW5kIGJlIGFkZGVkIHRvIHRoZSBkb2N1bWVudCBpbiB0aGUgb3JkZXJcblx0XHQgKiBzcGVjaWZpZWQuXG5cdFx0ICpcblx0XHQgKiBBbnkgaXRlbXMgY2FuIGJlIHNldCB0byBsb2FkIGluIG9yZGVyIGJ5IHNldHRpbmcgdGhlIHt7I2Nyb3NzTGluayBcIm1haW50YWluT3JkZXI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBwcm9wZXJ0eSBvbiB0aGUgbG9hZCBpdGVtLCBvciBieSBlbnN1cmluZyB0aGF0IG9ubHkgb25lIGNvbm5lY3Rpb24gY2FuIGJlIG9wZW4gYXQgYSB0aW1lIHVzaW5nXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldE1heENvbm5lY3Rpb25zXCJ9fXt7L2Nyb3NzTGlua319LiBOb3RlIHRoYXQgd2hlbiB0aGUgYG1haW50YWluU2NyaXB0T3JkZXJgIHByb3BlcnR5XG5cdFx0ICogaXMgc2V0IHRvIGB0cnVlYCwgc2NyaXB0cyBpdGVtcyBhcmUgYXV0b21hdGljYWxseSBzZXQgdG8gYG1haW50YWluT3JkZXI9dHJ1ZWAsIGFuZCBjaGFuZ2luZyB0aGVcblx0XHQgKiBgbWFpbnRhaW5TY3JpcHRPcmRlcmAgdG8gYGZhbHNlYCBkdXJpbmcgYSBsb2FkIHdpbGwgbm90IGNoYW5nZSBpdGVtcyBhbHJlYWR5IGluIGEgcXVldWUuXG5cdFx0ICpcblx0XHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdFx0ICpcblx0XHQgKiAgICAgIHZhciBxdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUoKTtcblx0XHQgKiAgICAgIHF1ZXVlLnNldE1heENvbm5lY3Rpb25zKDMpOyAvLyBTZXQgYSBoaWdoZXIgbnVtYmVyIHRvIGxvYWQgbXVsdGlwbGUgaXRlbXMgYXQgb25jZVxuXHRcdCAqICAgICAgcXVldWUubWFpbnRhaW5TY3JpcHRPcmRlciA9IHRydWU7IC8vIEVuc3VyZSBzY3JpcHRzIGFyZSBsb2FkZWQgaW4gb3JkZXJcblx0XHQgKiAgICAgIHF1ZXVlLmxvYWRNYW5pZmVzdChbXG5cdFx0ICogICAgICAgICAgXCJzY3JpcHQxLmpzXCIsXG5cdFx0ICogICAgICAgICAgXCJzY3JpcHQyLmpzXCIsXG5cdFx0ICogICAgICAgICAgXCJpbWFnZS5wbmdcIiwgLy8gTG9hZCBhbnkgdGltZVxuXHRcdCAqICAgICAgICAgIHtzcmM6IFwiaW1hZ2UyLnBuZ1wiLCBtYWludGFpbk9yZGVyOiB0cnVlfSAvLyBXaWxsIHdhaXQgZm9yIHNjcmlwdDIuanNcblx0XHQgKiAgICAgICAgICBcImltYWdlMy5wbmdcIixcblx0XHQgKiAgICAgICAgICBcInNjcmlwdDMuanNcIiAvLyBXaWxsIHdhaXQgZm9yIGltYWdlMi5wbmcgYmVmb3JlIGxvYWRpbmcgKG9yIGNvbXBsZXRpbmcgd2hlbiBsb2FkaW5nIHdpdGggWEhSKVxuXHRcdCAqICAgICAgXSk7XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgbWFpbnRhaW5TY3JpcHRPcmRlclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLm1haW50YWluU2NyaXB0T3JkZXIgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgTG9hZFF1ZXVlIHdpbGwgc3RvcCBwcm9jZXNzaW5nIHRoZSBjdXJyZW50IHF1ZXVlIHdoZW4gYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQuXG5cdFx0ICogQHByb3BlcnR5IHN0b3BPbkVycm9yXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLnN0b3BPbkVycm9yID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIG1heGltdW0gb3BlbiBjb25uZWN0aW9ucyB0aGF0IGEgbG9hZFF1ZXVlIHRyaWVzIHRvIG1haW50YWluLiBQbGVhc2Ugc2VlXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldE1heENvbm5lY3Rpb25zXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBfbWF4Q29ubmVjdGlvbnNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX21heENvbm5lY3Rpb25zID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGludGVybmFsIGxpc3Qgb2YgYWxsIHRoZSBkZWZhdWx0IExvYWRlcnMgdGhhdCBhcmUgaW5jbHVkZWQgd2l0aCBQcmVsb2FkSlMuIEJlZm9yZSBhbiBpdGVtIGlzIGxvYWRlZCwgdGhlXG5cdFx0ICogYXZhaWxhYmxlIGxvYWRlciBsaXN0IGlzIGl0ZXJhdGVkLCBpbiB0aGUgb3JkZXIgdGhleSBhcmUgaW5jbHVkZWQsIGFuZCBhcyBzb29uIGFzIGEgbG9hZGVyIGluZGljYXRlcyBpdCBjYW5cblx0XHQgKiBoYW5kbGUgdGhlIGNvbnRlbnQsIGl0IHdpbGwgYmUgc2VsZWN0ZWQuIFRoZSBkZWZhdWx0IGxvYWRlciwgKHt7I2Nyb3NzTGluayBcIlRleHRMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gaXNcblx0XHQgKiBsYXN0IGluIHRoZSBsaXN0LCBzbyBpdCB3aWxsIGJlIHVzZWQgaWYgbm8gb3RoZXIgbWF0Y2ggaXMgZm91bmQuIFR5cGljYWxseSwgbG9hZGVycyB3aWxsIG1hdGNoIGJhc2VkIG9uIHRoZVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL3R5cGVcIn19e3svY3Jvc3NMaW5rfX0sIHdoaWNoIGlzIGF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lZCB1c2luZyB0aGUgZmlsZSBleHRlbnNpb24gb2Zcblx0XHQgKiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vc3JjOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqXG5cdFx0ICogTG9hZGVycyBjYW4gYmUgcmVtb3ZlZCBmcm9tIFByZWxvYWRKUyBieSBzaW1wbHkgbm90IGluY2x1ZGluZyB0aGVtLlxuXHRcdCAqXG5cdFx0ICogQ3VzdG9tIGxvYWRlcnMgaW5zdGFsbGVkIHVzaW5nIHt7I2Nyb3NzTGluayBcInJlZ2lzdGVyTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IHdpbGwgYmUgcHJlcGVuZGVkIHRvIHRoaXMgbGlzdFxuXHRcdCAqIHNvIHRoYXQgdGhleSBhcmUgY2hlY2tlZCBmaXJzdC5cblx0XHQgKiBAcHJvcGVydHkgX2F2YWlsYWJsZUxvYWRlcnNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAc2luY2UgMC42LjBcblx0XHQgKi9cblx0XHR0aGlzLl9hdmFpbGFibGVMb2FkZXJzID0gW1xuICAgICAgICAgICAgY3JlYXRlanMuRm9udExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLkltYWdlTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuSmF2YVNjcmlwdExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLkNTU0xvYWRlcixcblx0XHRcdGNyZWF0ZWpzLkpTT05Mb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5KU09OUExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlNvdW5kTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuTWFuaWZlc3RMb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5TcHJpdGVTaGVldExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlhNTExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlNWR0xvYWRlcixcblx0XHRcdGNyZWF0ZWpzLkJpbmFyeUxvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlZpZGVvTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuVGV4dExvYWRlclxuXHRcdF07XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIGJ1aWx0IGluIGxvYWRlcnMsIHNvIHRoZXkgY2FuJ3QgYmUgcmVtb3ZlZCBieSB7eyNjcm9zc0xpbmsgXCJ1bnJlZ2lzdGVyTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua30uXG5cdFx0XHRcdCAqIEBwcm9wZXJ0eSBfZGVmYXVsdExvYWRlckxlbmd0aFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAc2luY2UgMC42LjBcblx0XHQgKi9cblx0XHR0aGlzLl9kZWZhdWx0TG9hZGVyTGVuZ3RoID0gdGhpcy5fYXZhaWxhYmxlTG9hZGVycy5sZW5ndGg7XG5cblx0XHR0aGlzLmluaXQocHJlZmVyWEhSLCBiYXNlUGF0aCwgY3Jvc3NPcmlnaW4pO1xuXHR9XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoTG9hZFF1ZXVlLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gTG9hZFF1ZXVlO1xuXG5cdC8vIFJlbW92ZSB0aGVzZSBAZGVwcmVjYXRlZCBwcm9wZXJ0aWVzIGFmdGVyIDEuMFxuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHMsIHtcblx0XHRcdFBPU1Q6IHsgZ2V0OiBjcmVhdGVqcy5kZXByZWNhdGUoZnVuY3Rpb24oKSB7IHJldHVybiBjcmVhdGVqcy5NZXRob2RzLlBPU1Q7IH0sIFwiQWJzdHJhY3RMb2FkZXIuUE9TVFwiKSB9LFxuXHRcdFx0R0VUOiB7IGdldDogY3JlYXRlanMuZGVwcmVjYXRlKGZ1bmN0aW9uKCkgeyByZXR1cm4gY3JlYXRlanMuTWV0aG9kcy5HRVQ7IH0sIFwiQWJzdHJhY3RMb2FkZXIuR0VUXCIpIH0sXG5cblx0XHRcdEJJTkFSWTogeyBnZXQ6IGNyZWF0ZWpzLmRlcHJlY2F0ZShmdW5jdGlvbigpIHsgcmV0dXJuIGNyZWF0ZWpzLlR5cGVzLkJJTkFSWTsgfSwgXCJBYnN0cmFjdExvYWRlci5CSU5BUllcIikgfSxcblx0XHRcdENTUzogeyBnZXQ6IGNyZWF0ZWpzLmRlcHJlY2F0ZShmdW5jdGlvbigpIHsgcmV0dXJuIGNyZWF0ZWpzLlR5cGVzLkNTUzsgfSwgXCJBYnN0cmFjdExvYWRlci5DU1NcIikgfSxcblx0XHRcdEZPTlQ6IHsgZ2V0OiBjcmVhdGVqcy5kZXByZWNhdGUoZnVuY3Rpb24oKSB7IHJldHVybiBjcmVhdGVqcy5UeXBlcy5GT05UOyB9LCBcIkFic3RyYWN0TG9hZGVyLkZPTlRcIikgfSxcblx0XHRcdEZPTlRDU1M6IHsgZ2V0OiBjcmVhdGVqcy5kZXByZWNhdGUoZnVuY3Rpb24oKSB7IHJldHVybiBjcmVhdGVqcy5UeXBlcy5GT05UQ1NTOyB9LCBcIkFic3RyYWN0TG9hZGVyLkZPTlRDU1NcIikgfSxcblx0XHRcdElNQUdFOiB7IGdldDogY3JlYXRlanMuZGVwcmVjYXRlKGZ1bmN0aW9uKCkgeyByZXR1cm4gY3JlYXRlanMuVHlwZXMuSU1BR0U7IH0sIFwiQWJzdHJhY3RMb2FkZXIuSU1BR0VcIikgfSxcblx0XHRcdEpBVkFTQ1JJUFQ6IHsgZ2V0OiBjcmVhdGVqcy5kZXByZWNhdGUoZnVuY3Rpb24oKSB7IHJldHVybiBjcmVhdGVqcy5UeXBlcy5KQVZBU0NSSVBUOyB9LCBcIkFic3RyYWN0TG9hZGVyLkpBVkFTQ1JJUFRcIikgfSxcblx0XHRcdEpTT046IHsgZ2V0OiBjcmVhdGVqcy5kZXByZWNhdGUoZnVuY3Rpb24oKSB7IHJldHVybiBjcmVhdGVqcy5UeXBlcy5KU09OOyB9LCBcIkFic3RyYWN0TG9hZGVyLkpTT05cIikgfSxcblx0XHRcdEpTT05QOiB7IGdldDogY3JlYXRlanMuZGVwcmVjYXRlKGZ1bmN0aW9uKCkgeyByZXR1cm4gY3JlYXRlanMuVHlwZXMuSlNPTlA7IH0sIFwiQWJzdHJhY3RMb2FkZXIuSlNPTlBcIikgfSxcblx0XHRcdE1BTklGRVNUOiB7IGdldDogY3JlYXRlanMuZGVwcmVjYXRlKGZ1bmN0aW9uKCkgeyByZXR1cm4gY3JlYXRlanMuVHlwZXMuTUFOSUZFU1Q7IH0sIFwiQWJzdHJhY3RMb2FkZXIuTUFOSUZFU1RcIikgfSxcblx0XHRcdFNPVU5EOiB7IGdldDogY3JlYXRlanMuZGVwcmVjYXRlKGZ1bmN0aW9uKCkgeyByZXR1cm4gY3JlYXRlanMuVHlwZXMuU09VTkQ7IH0sIFwiQWJzdHJhY3RMb2FkZXIuU09VTkRcIikgfSxcblx0XHRcdFZJREVPOiB7IGdldDogY3JlYXRlanMuZGVwcmVjYXRlKGZ1bmN0aW9uKCkgeyByZXR1cm4gY3JlYXRlanMuVHlwZXMuVklERU87IH0sIFwiQWJzdHJhY3RMb2FkZXIuVklERU9cIikgfSxcblx0XHRcdFNQUklURVNIRUVUOiB7IGdldDogY3JlYXRlanMuZGVwcmVjYXRlKGZ1bmN0aW9uKCkgeyByZXR1cm4gY3JlYXRlanMuVHlwZXMuU1BSSVRFU0hFRVQ7IH0sIFwiQWJzdHJhY3RMb2FkZXIuU1BSSVRFU0hFRVRcIikgfSxcblx0XHRcdFNWRzogeyBnZXQ6IGNyZWF0ZWpzLmRlcHJlY2F0ZShmdW5jdGlvbigpIHsgcmV0dXJuIGNyZWF0ZWpzLlR5cGVzLlNWRzsgfSwgXCJBYnN0cmFjdExvYWRlci5TVkdcIikgfSxcblx0XHRcdFRFWFQ6IHsgZ2V0OiBjcmVhdGVqcy5kZXByZWNhdGUoZnVuY3Rpb24oKSB7IHJldHVybiBjcmVhdGVqcy5UeXBlcy5URVhUOyB9LCBcIkFic3RyYWN0TG9hZGVyLlRFWFRcIikgfSxcblx0XHRcdFhNTDogeyBnZXQ6IGNyZWF0ZWpzLmRlcHJlY2F0ZShmdW5jdGlvbigpIHsgcmV0dXJuIGNyZWF0ZWpzLlR5cGVzLlhNTDsgfSwgXCJBYnN0cmFjdExvYWRlci5YTUxcIikgfVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlKSB7fVxuXG5cdC8qKlxuXHQgKiBBbiBpbnRlcm5hbCBpbml0aWFsaXphdGlvbiBtZXRob2QsIHdoaWNoIGlzIHVzZWQgZm9yIGluaXRpYWwgc2V0IHVwLCBidXQgYWxzbyB0byByZXNldCB0aGUgTG9hZFF1ZXVlLlxuXHQgKiBAbWV0aG9kIGluaXRcblx0ICogQHBhcmFtIHByZWZlclhIUlxuXHQgKiBAcGFyYW0gYmFzZVBhdGhcblx0ICogQHBhcmFtIGNyb3NzT3JpZ2luXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLmluaXQgPSBmdW5jdGlvbiAocHJlZmVyWEhSLCBiYXNlUGF0aCwgY3Jvc3NPcmlnaW4pIHtcblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cblx0XHQvKipcblx0XHQgKiBUcnkgYW5kIHVzZSBYTUxIdHRwUmVxdWVzdCAoWEhSKSB3aGVuIHBvc3NpYmxlLiBOb3RlIHRoYXQgTG9hZFF1ZXVlIHdpbGwgZGVmYXVsdCB0byB0YWcgbG9hZGluZyBvciBYSFJcblx0XHQgKiBsb2FkaW5nIGRlcGVuZGluZyBvbiB0aGUgcmVxdWlyZW1lbnRzIGZvciBhIG1lZGlhIHR5cGUuIEZvciBleGFtcGxlLCBIVE1MIGF1ZGlvIGNhbiBub3QgYmUgbG9hZGVkIHdpdGggWEhSLFxuXHRcdCAqIGFuZCBwbGFpbiB0ZXh0IGNhbiBub3QgYmUgbG9hZGVkIHdpdGggdGFncywgc28gaXQgd2lsbCBkZWZhdWx0IHRoZSB0aGUgY29ycmVjdCB0eXBlIGluc3RlYWQgb2YgdXNpbmcgdGhlXG5cdFx0ICogdXNlci1kZWZpbmVkIHR5cGUuXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqIEBzaW5jZSAwLjYuMFxuXHRcdCAqL1xuXHRcdHRoaXMucHJlZmVyWEhSID0gdHJ1ZTsgLy9UT0RPOiBHZXQvU2V0XG5cdFx0dGhpcy5fcHJlZmVyWEhSID0gdHJ1ZTtcblx0XHR0aGlzLnNldFByZWZlclhIUihwcmVmZXJYSFIpO1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRoZSBxdWV1ZSBpcyBjdXJyZW50bHkgcGF1c2VkIG9yIG5vdC5cblx0XHQgKiBAcHJvcGVydHkgX3BhdXNlZFxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBBIHBhdGggdGhhdCB3aWxsIGJlIHByZXBlbmRlZCBvbiB0byB0aGUgaXRlbSdzIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL3NyYzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS4gVGhlXG5cdFx0ICogYF9iYXNlUGF0aGAgcHJvcGVydHkgd2lsbCBvbmx5IGJlIHVzZWQgaWYgYW4gaXRlbSdzIHNvdXJjZSBpcyByZWxhdGl2ZSwgYW5kIGRvZXMgbm90IGluY2x1ZGUgYSBwcm90b2NvbCBzdWNoXG5cdFx0ICogYXMgYGh0dHA6Ly9gLCBvciBhIHJlbGF0aXZlIHBhdGggc3VjaCBhcyBgLi4vYC5cblx0XHQgKiBAcHJvcGVydHkgX2Jhc2VQYXRoXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBzaW5jZSAwLjMuMVxuXHRcdCAqL1xuXHRcdHRoaXMuX2Jhc2VQYXRoID0gYmFzZVBhdGg7XG5cblx0XHQvKipcblx0XHQgKiBBbiBvcHRpb25hbCBmbGFnIHRvIHNldCBvbiBpbWFnZXMgdGhhdCBhcmUgbG9hZGVkIHVzaW5nIFByZWxvYWRKUywgd2hpY2ggZW5hYmxlcyBDT1JTIHN1cHBvcnQuIEltYWdlcyBsb2FkZWRcblx0XHQgKiBjcm9zcy1kb21haW4gYnkgc2VydmVycyB0aGF0IHN1cHBvcnQgQ09SUyByZXF1aXJlIHRoZSBjcm9zc09yaWdpbiBmbGFnIHRvIGJlIGxvYWRlZCBhbmQgaW50ZXJhY3RlZCB3aXRoIGJ5XG5cdFx0ICogYSBjYW52YXMuIFdoZW4gbG9hZGluZyBsb2NhbGx5LCBvciB3aXRoIGEgc2VydmVyIHdpdGggbm8gQ09SUyBzdXBwb3J0LCB0aGlzIGZsYWcgY2FuIGNhdXNlIG90aGVyIHNlY3VyaXR5IGlzc3Vlcyxcblx0XHQgKiBzbyBpdCBpcyByZWNvbW1lbmRlZCB0byBvbmx5IHNldCBpdCBpZiB5b3UgYXJlIHN1cmUgdGhlIHNlcnZlciBzdXBwb3J0cyBpdC4gQ3VycmVudGx5LCBzdXBwb3J0ZWQgdmFsdWVzIGFyZSBcIlwiXG5cdFx0ICogYW5kIFwiQW5vbnltb3VzXCIuXG5cdFx0ICogQHByb3BlcnR5IF9jcm9zc09yaWdpblxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgXCJcIlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHNpbmNlIDAuNC4xXG5cdFx0ICovXG5cdFx0dGhpcy5fY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRTdGFydCBldmVudCB3YXMgZGlzcGF0Y2hlZCBhbHJlYWR5LiBUaGlzIGV2ZW50IGlzIG9ubHkgZmlyZWQgb25lIHRpbWUsIHdoZW4gdGhlIGZpcnN0XG5cdFx0ICogZmlsZSBpcyByZXF1ZXN0ZWQuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkU3RhcnRXYXNEaXNwYXRjaGVkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRTdGFydFdhc0Rpc3BhdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZXMgaWYgdGhlcmUgaXMgY3VycmVudGx5IGEgc2NyaXB0IGxvYWRpbmcuIFRoaXMgaGVscHMgZW5zdXJlIHRoYXQgb25seSBhIHNpbmdsZSBzY3JpcHQgbG9hZHMgYXQgb25jZSB3aGVuXG5cdFx0ICogdXNpbmcgYSBzY3JpcHQgdGFnIHRvIGRvIHByZWxvYWRpbmcuXG5cdFx0ICogQHByb3BlcnR5IF9jdXJyZW50bHlMb2FkaW5nU2NyaXB0XG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9jdXJyZW50bHlMb2FkaW5nU2NyaXB0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGN1cnJlbnRseSBkb3dubG9hZGluZyBmaWxlcy5cblx0XHQgKiBAcHJvcGVydHkgX2N1cnJlbnRMb2Fkc1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2N1cnJlbnRMb2FkcyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgY29udGFpbmluZyB0aGUgcXVldWVkIGl0ZW1zIHRoYXQgaGF2ZSBub3QgeWV0IHN0YXJ0ZWQgZG93bmxvYWRpbmcuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkUXVldWVcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkUXVldWUgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IGNvbnRhaW5pbmcgZG93bmxvYWRzIHRoYXQgaGF2ZSBub3QgY29tcGxldGVkLCBzbyB0aGF0IHRoZSBMb2FkUXVldWUgY2FuIGJlIHByb3Blcmx5IHJlc2V0LlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZFF1ZXVlQmFja3VwXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZFF1ZXVlQmFja3VwID0gW107XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgaGFzaCBvZiBpdGVtcyB0aGF0IGhhdmUgZmluaXNoZWQgZG93bmxvYWRpbmcsIGluZGV4ZWQgYnkgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogaWQuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkSXRlbXNCeUlkXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRJdGVtc0J5SWQgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBoYXNoIG9mIGl0ZW1zIHRoYXQgaGF2ZSBmaW5pc2hlZCBkb3dubG9hZGluZywgaW5kZXhlZCBieSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIHNvdXJjZS5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRJdGVtc0J5U3JjXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRJdGVtc0J5U3JjID0ge307XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgaGFzaCBvZiBsb2FkZWQgaXRlbXMsIGluZGV4ZWQgYnkgdGhlIElEIG9mIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRlZFJlc3VsdHNcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZGVkUmVzdWx0cyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IGhhc2ggb2YgdW4tcGFyc2VkIGxvYWRlZCBpdGVtcywgaW5kZXhlZCBieSB0aGUgSUQgb2YgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZGVkUmF3UmVzdWx0c1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkZWRSYXdSZXN1bHRzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRoYXQgaGF2ZSBiZWVuIHJlcXVlc3RlZC4gVGhpcyBoZWxwcyBtYW5hZ2UgYW4gb3ZlcmFsbCBwcm9ncmVzcyB3aXRob3V0IGtub3dpbmcgaG93IGxhcmdlXG5cdFx0ICogdGhlIGZpbGVzIGFyZSBiZWZvcmUgdGhleSBhcmUgZG93bmxvYWRlZC4gVGhpcyBkb2VzIG5vdCBpbmNsdWRlIGl0ZW1zIGluc2lkZSBvZiBsb2FkZXJzIHN1Y2ggYXMgdGhlXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IF9udW1JdGVtc1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbnVtSXRlbXMgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBpdGVtcyB0aGF0IGhhdmUgY29tcGxldGVkIGxvYWRlZC4gVGhpcyBoZWxwcyBtYW5hZ2UgYW4gb3ZlcmFsbCBwcm9ncmVzcyB3aXRob3V0IGtub3dpbmcgaG93IGxhcmdlXG5cdFx0ICogdGhlIGZpbGVzIGFyZSBiZWZvcmUgdGhleSBhcmUgZG93bmxvYWRlZC5cblx0XHQgKiBAcHJvcGVydHkgX251bUl0ZW1zTG9hZGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9udW1JdGVtc0xvYWRlZCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBBIGxpc3Qgb2Ygc2NyaXB0cyBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIHJlcXVlc3RlZC4gVGhpcyBoZWxwcyBlbnN1cmUgdGhhdCBzY3JpcHRzIGFyZSBcImNvbXBsZXRlZFwiIGluIHRoZSByaWdodFxuXHRcdCAqIG9yZGVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBfc2NyaXB0T3JkZXJcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9zY3JpcHRPcmRlciA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBsaXN0IG9mIHNjcmlwdHMgdGhhdCBoYXZlIGJlZW4gbG9hZGVkLiBJdGVtcyBhcmUgYWRkZWQgdG8gdGhpcyBsaXN0IGFzIDxjb2RlPm51bGw8L2NvZGU+IHdoZW4gdGhleSBhcmVcblx0XHQgKiByZXF1ZXN0ZWQsIGNvbnRhaW4gdGhlIGxvYWRlZCBpdGVtIGlmIGl0IGhhcyBjb21wbGV0ZWQsIGJ1dCBub3QgYmVlbiBkaXNwYXRjaGVkIHRvIHRoZSB1c2VyLCBhbmQgPGNvZGU+dHJ1ZTwvdHJ1ZT5cblx0XHQgKiBvbmNlIHRoZXkgYXJlIGNvbXBsZXRlIGFuZCBoYXZlIGJlZW4gZGlzcGF0Y2hlZC5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRlZFNjcmlwdHNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkZWRTY3JpcHRzID0gW107XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGFzdCBwcm9ncmVzcyBhbW91bnQuIFRoaXMgaXMgdXNlZCB0byBzdXBwcmVzcyBkdXBsaWNhdGUgcHJvZ3Jlc3MgZXZlbnRzLlxuXHRcdCAqIEBwcm9wZXJ0eSBfbGFzdFByb2dyZXNzXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBzaW5jZSAwLjYuMFxuXHRcdCAqL1xuXHRcdHRoaXMuX2xhc3RQcm9ncmVzcyA9IE5hTjtcblxuXHR9O1xuXG4vLyBzdGF0aWMgcHJvcGVydGllc1xuXG4vLyBldmVudHNcblx0LyoqXG5cdCAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhbiBpbmRpdmlkdWFsIGZpbGUgaGFzIGxvYWRlZCwgYW5kIGJlZW4gcHJvY2Vzc2VkLlxuXHQgKiBAZXZlbnQgZmlsZWxvYWRcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBUaGUgZmlsZSBpdGVtIHdoaWNoIHdhcyBzcGVjaWZpZWQgaW4gdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvciB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319IGNhbGwuIElmIG9ubHkgYSBzdHJpbmcgcGF0aCBvciB0YWcgd2FzIHNwZWNpZmllZCwgdGhlXG5cdCAqIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhhdCB2YWx1ZSBhcyBhIGBzcmNgIHByb3BlcnR5LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0IFRoZSBIVE1MIHRhZyBvciBwYXJzZWQgcmVzdWx0IG9mIHRoZSBsb2FkZWQgaXRlbS5cblx0ICogQHBhcmFtIHtPYmplY3R9IHJhd1Jlc3VsdCBUaGUgdW5wcm9jZXNzZWQgcmVzdWx0LCB1c3VhbGx5IHRoZSByYXcgdGV4dCBvciBiaW5hcnkgZGF0YSBiZWZvcmUgaXQgaXMgY29udmVydGVkXG5cdCAqIHRvIGEgdXNhYmxlIG9iamVjdC5cblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGlzIHt7I2Nyb3NzTGluayBcIlByb2dyZXNzRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIGFuIGFuIGluZGl2aWR1YWwgZmlsZSdzIHByb2dyZXNzIGNoYW5nZXMuXG5cdCAqIEBldmVudCBmaWxlcHJvZ3Jlc3Ncblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gYW4gaW5kaXZpZHVhbCBmaWxlIHN0YXJ0cyB0byBsb2FkLlxuXHQgKiBAZXZlbnQgZmlsZXN0YXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIGZpbGUgaXRlbSB3aGljaCB3YXMgc3BlY2lmaWVkIGluIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogb3Ige3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fSBjYWxsLiBJZiBvbmx5IGEgc3RyaW5nIHBhdGggb3IgdGFnIHdhcyBzcGVjaWZpZWQsIHRoZVxuXHQgKiBvYmplY3Qgd2lsbCBjb250YWluIHRoYXQgdmFsdWUgYXMgYSBwcm9wZXJ0eS5cblx0ICovXG5cblx0LyoqXG5cdCAqIEFsdGhvdWdoIGl0IGV4dGVuZHMge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0sIHRoZSBgaW5pdGlhbGl6ZWAgZXZlbnQgaXMgbmV2ZXIgZmlyZWQgZnJvbVxuXHQgKiBhIExvYWRRdWV1ZSBpbnN0YW5jZS5cblx0ICogQGV2ZW50IGluaXRpYWxpemVcblx0ICogQHByaXZhdGVcblx0ICovXG5cbi8vIHB1YmxpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBSZWdpc3RlciBhIGN1c3RvbSBsb2FkZXJzIGNsYXNzLiBOZXcgbG9hZGVycyBhcmUgZ2l2ZW4gcHJlY2VkZW5jZSBvdmVyIGxvYWRlcnMgYWRkZWQgZWFybGllciBhbmQgZGVmYXVsdCBsb2FkZXJzLlxuXHQgKiBJdCBpcyByZWNvbW1lbmRlZCB0aGF0IGxvYWRlcnMgZXh0ZW5kIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LiBMb2FkZXJzIGNhbiBvbmx5IGJlIGFkZGVkXG5cdCAqIG9uY2UsIGFuZCB3aWxsIGJlIHByZXBlbmRlZCB0byB0aGUgbGlzdCBvZiBhdmFpbGFibGUgbG9hZGVycy5cblx0ICogQG1ldGhvZCByZWdpc3RlckxvYWRlclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufEFic3RyYWN0TG9hZGVyfSBsb2FkZXIgVGhlIEFic3RyYWN0TG9hZGVyIGNsYXNzIHRvIGFkZC5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLnJlZ2lzdGVyTG9hZGVyID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdGlmICghbG9hZGVyIHx8ICFsb2FkZXIuY2FuTG9hZEl0ZW0pIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcImxvYWRlciBpcyBvZiBhbiBpbmNvcnJlY3QgdHlwZS5cIik7XG5cdFx0fSBlbHNlIGlmICh0aGlzLl9hdmFpbGFibGVMb2FkZXJzLmluZGV4T2YobG9hZGVyKSAhPSAtMSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibG9hZGVyIGFscmVhZHkgZXhpc3RzLlwiKTsgLy9MTTogTWF5YmUganVzdCBzaWxlbnRseSBmYWlsIGhlcmVcblx0XHR9XG5cblx0XHR0aGlzLl9hdmFpbGFibGVMb2FkZXJzLnVuc2hpZnQobG9hZGVyKTtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlIGEgY3VzdG9tIGxvYWRlciBhZGRlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJyZWdpc3RlckxvYWRlclwifX17ey9jcm9zc0xpbmt9fS4gT25seSBjdXN0b20gbG9hZGVycyBjYW4gYmVcblx0ICogdW5yZWdpc3RlcmVkLCB0aGUgZGVmYXVsdCBsb2FkZXJzIHdpbGwgYWx3YXlzIGJlIGF2YWlsYWJsZS5cblx0ICogQG1ldGhvZCB1bnJlZ2lzdGVyTG9hZGVyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb258QWJzdHJhY3RMb2FkZXJ9IGxvYWRlciBUaGUgQWJzdHJhY3RMb2FkZXIgY2xhc3MgdG8gcmVtb3ZlXG5cdCAqL1xuXHRwLnVucmVnaXN0ZXJMb2FkZXIgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0dmFyIGlkeCA9IHRoaXMuX2F2YWlsYWJsZUxvYWRlcnMuaW5kZXhPZihsb2FkZXIpO1xuXHRcdGlmIChpZHggIT0gLTEgJiYgaWR4IDwgdGhpcy5fZGVmYXVsdExvYWRlckxlbmd0aCAtIDEpIHtcblx0XHRcdHRoaXMuX2F2YWlsYWJsZUxvYWRlcnMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGFuZ2UgdGhlIHt7I2Nyb3NzTGluayBcInByZWZlclhIUjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSB2YWx1ZS4gTm90ZSB0aGF0IGlmIHRoaXMgaXMgc2V0IHRvIGB0cnVlYCwgaXQgbWF5XG5cdCAqIGZhaWwsIG9yIGJlIGlnbm9yZWQgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyJ3MgY2FwYWJpbGl0aWVzIGFuZCB0aGUgbG9hZCB0eXBlLlxuXHQgKiBAbWV0aG9kIHNldFByZWZlclhIUlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBUaGUgdmFsdWUgb2Yge3sjY3Jvc3NMaW5rIFwicHJlZmVyWEhSXCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgd2FzIHN1Y2Nlc3NmdWxseSBzZXQuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5zZXRQcmVmZXJYSFIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHQvLyBEZXRlcm1pbmUgaWYgd2UgY2FuIHVzZSBYSFIuIFhIUiBkZWZhdWx0cyB0byBUUlVFLCBidXQgdGhlIGJyb3dzZXIgbWF5IG5vdCBzdXBwb3J0IGl0LlxuXHRcdC8vVE9ETzogU2hvdWxkIHdlIGJlIGNoZWNraW5nIGZvciB0aGUgb3RoZXIgWEhSIHR5cGVzPyBNaWdodCBoYXZlIHRvIGRvIGEgdHJ5L2NhdGNoIG9uIHRoZSBkaWZmZXJlbnQgdHlwZXMgc2ltaWxhciB0byBjcmVhdGVYSFIuXG5cdFx0dGhpcy5wcmVmZXJYSFIgPSAodmFsdWUgIT0gZmFsc2UgJiYgd2luZG93LlhNTEh0dHBSZXF1ZXN0ICE9IG51bGwpO1xuXHRcdHJldHVybiB0aGlzLnByZWZlclhIUjtcblx0fTtcblxuXHQvKipcblx0ICogU3RvcHMgYWxsIHF1ZXVlZCBhbmQgbG9hZGluZyBpdGVtcywgYW5kIGNsZWFycyB0aGUgcXVldWUuIFRoaXMgYWxzbyByZW1vdmVzIGFsbCBpbnRlcm5hbCByZWZlcmVuY2VzIHRvIGxvYWRlZFxuXHQgKiBjb250ZW50LCBhbmQgYWxsb3dzIHRoZSBxdWV1ZSB0byBiZSB1c2VkIGFnYWluLlxuXHQgKiBAbWV0aG9kIHJlbW92ZUFsbFxuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cdHAucmVtb3ZlQWxsID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMucmVtb3ZlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3BzIGFuIGl0ZW0gZnJvbSBiZWluZyBsb2FkZWQsIGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIHF1ZXVlLiBJZiBub3RoaW5nIGlzIHBhc3NlZCwgYWxsIGl0ZW1zIGFyZSByZW1vdmVkLlxuXHQgKiBUaGlzIGFsc28gcmVtb3ZlcyBpbnRlcm5hbCByZWZlcmVuY2VzIHRvIGxvYWRlZCBpdGVtKHMpLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgcXVldWUubG9hZE1hbmlmZXN0KFtcblx0ICogICAgICAgICAge3NyYzpcInRlc3QucG5nXCIsIGlkOlwicG5nXCJ9LFxuXHQgKiAgICAgICAgICB7c3JjOlwidGVzdC5qcGdcIiwgaWQ6XCJqcGdcIn0sXG5cdCAqICAgICAgICAgIHtzcmM6XCJ0ZXN0Lm1wM1wiLCBpZDpcIm1wM1wifVxuXHQgKiAgICAgIF0pO1xuXHQgKiAgICAgIHF1ZXVlLnJlbW92ZShcInBuZ1wiKTsgLy8gU2luZ2xlIGl0ZW0gYnkgSURcblx0ICogICAgICBxdWV1ZS5yZW1vdmUoXCJwbmdcIiwgXCJ0ZXN0LmpwZ1wiKTsgLy8gSXRlbXMgYXMgYXJndW1lbnRzLiBNaXhlZCBpZCBhbmQgc3JjLlxuXHQgKiAgICAgIHF1ZXVlLnJlbW92ZShbXCJ0ZXN0LnBuZ1wiLCBcImpwZ1wiXSk7IC8vIEl0ZW1zIGluIGFuIEFycmF5LiBNaXhlZCBpZCBhbmQgc3JjLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlbW92ZVxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IEFycmF5fSBpZHNPclVybHMqIFRoZSBpZCBvciBpZHMgdG8gcmVtb3ZlIGZyb20gdGhpcyBxdWV1ZS4gWW91IGNhbiBwYXNzIGFuIGl0ZW0sIGFuIGFycmF5IG9mXG5cdCAqIGl0ZW1zLCBvciBtdWx0aXBsZSBpdGVtcyBhcyBhcmd1bWVudHMuXG5cdCAqIEBzaW5jZSAwLjMuMFxuXHQgKi9cblx0cC5yZW1vdmUgPSBmdW5jdGlvbiAoaWRzT3JVcmxzKSB7XG5cdFx0dmFyIGFyZ3MgPSBudWxsO1xuXG5cdFx0aWYgKGlkc09yVXJscyAmJiAhQXJyYXkuaXNBcnJheShpZHNPclVybHMpKSB7XG5cdFx0XHRhcmdzID0gW2lkc09yVXJsc107XG5cdFx0fSBlbHNlIGlmIChpZHNPclVybHMpIHtcblx0XHRcdGFyZ3MgPSBpZHNPclVybHM7XG5cdFx0fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBpdGVtc1dlcmVSZW1vdmVkID0gZmFsc2U7XG5cblx0XHQvLyBEZXN0cm95IGV2ZXJ5dGhpbmdcblx0XHRpZiAoIWFyZ3MpIHtcblx0XHRcdHRoaXMuY2xvc2UoKTtcblx0XHRcdGZvciAodmFyIG4gaW4gdGhpcy5fbG9hZEl0ZW1zQnlJZCkge1xuXHRcdFx0XHR0aGlzLl9kaXNwb3NlSXRlbSh0aGlzLl9sb2FkSXRlbXNCeUlkW25dKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaW5pdCh0aGlzLnByZWZlclhIUiwgdGhpcy5fYmFzZVBhdGgpO1xuXG5cdFx0XHQvLyBSZW1vdmUgc3BlY2lmaWMgaXRlbXNcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2hpbGUgKGFyZ3MubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gYXJncy5wb3AoKTtcblx0XHRcdFx0dmFyIHIgPSB0aGlzLmdldFJlc3VsdChpdGVtKTtcblxuXHRcdFx0XHQvL1JlbW92ZSBmcm9tIHRoZSBtYWluIGxvYWQgUXVldWVcblx0XHRcdFx0Zm9yIChpID0gdGhpcy5fbG9hZFF1ZXVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0bG9hZEl0ZW0gPSB0aGlzLl9sb2FkUXVldWVbaV0uZ2V0SXRlbSgpO1xuXHRcdFx0XHRcdGlmIChsb2FkSXRlbS5pZCA9PSBpdGVtIHx8IGxvYWRJdGVtLnNyYyA9PSBpdGVtKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9sb2FkUXVldWUuc3BsaWNlKGksIDEpWzBdLmNhbmNlbCgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9SZW1vdmUgZnJvbSB0aGUgYmFja3VwIHF1ZXVlXG5cdFx0XHRcdGZvciAoaSA9IHRoaXMuX2xvYWRRdWV1ZUJhY2t1cC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdGxvYWRJdGVtID0gdGhpcy5fbG9hZFF1ZXVlQmFja3VwW2ldLmdldEl0ZW0oKTtcblx0XHRcdFx0XHRpZiAobG9hZEl0ZW0uaWQgPT0gaXRlbSB8fCBsb2FkSXRlbS5zcmMgPT0gaXRlbSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fbG9hZFF1ZXVlQmFja3VwLnNwbGljZShpLCAxKVswXS5jYW5jZWwoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChyKSB7XG5cdFx0XHRcdFx0dGhpcy5fZGlzcG9zZUl0ZW0odGhpcy5nZXRJdGVtKGl0ZW0pKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gdGhpcy5fY3VycmVudExvYWRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0XHR2YXIgbG9hZEl0ZW0gPSB0aGlzLl9jdXJyZW50TG9hZHNbaV0uZ2V0SXRlbSgpO1xuXHRcdFx0XHRcdFx0aWYgKGxvYWRJdGVtLmlkID09IGl0ZW0gfHwgbG9hZEl0ZW0uc3JjID09IGl0ZW0pIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fY3VycmVudExvYWRzLnNwbGljZShpLCAxKVswXS5jYW5jZWwoKTtcblx0XHRcdFx0XHRcdFx0aXRlbXNXZXJlUmVtb3ZlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBjYWxsZWQgZHVyaW5nIGEgbG9hZCwgdHJ5IHRvIGxvYWQgdGhlIG5leHQgaXRlbS5cblx0XHRcdGlmIChpdGVtc1dlcmVSZW1vdmVkKSB7XG5cdFx0XHRcdHRoaXMuX2xvYWROZXh0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdG9wcyBhbGwgb3BlbiBsb2FkcywgZGVzdHJveXMgYW55IGxvYWRlZCBpdGVtcywgYW5kIHJlc2V0cyB0aGUgcXVldWUsIHNvIGFsbCBpdGVtcyBjYW5cblx0ICogYmUgcmVsb2FkZWQgYWdhaW4gYnkgY2FsbGluZyB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9sb2FkXCJ9fXt7L2Nyb3NzTGlua319LiBJdGVtcyBhcmUgbm90IHJlbW92ZWQgZnJvbSB0aGVcblx0ICogcXVldWUuIFRvIHJlbW92ZSBpdGVtcyB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9yZW1vdmVcIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3JlbW92ZUFsbFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG5cdCAqIEBtZXRob2QgcmVzZXRcblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXHRwLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuY2xvc2UoKTtcblx0XHRmb3IgKHZhciBuIGluIHRoaXMuX2xvYWRJdGVtc0J5SWQpIHtcblx0XHRcdHRoaXMuX2Rpc3Bvc2VJdGVtKHRoaXMuX2xvYWRJdGVtc0J5SWRbbl0pO1xuXHRcdH1cblxuXHRcdC8vUmVzZXQgdGhlIHF1ZXVlIHRvIGl0cyBzdGFydCBzdGF0ZVxuXHRcdHZhciBhID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9sb2FkUXVldWVCYWNrdXAubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRhLnB1c2godGhpcy5fbG9hZFF1ZXVlQmFja3VwW2ldLmdldEl0ZW0oKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5sb2FkTWFuaWZlc3QoYSwgZmFsc2UpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZWdpc3RlciBhIHBsdWdpbi4gUGx1Z2lucyBjYW4gbWFwIHRvIGxvYWQgdHlwZXMgKHNvdW5kLCBpbWFnZSwgZXRjKSwgb3Igc3BlY2lmaWMgZXh0ZW5zaW9ucyAocG5nLCBtcDMsIGV0YykuXG5cdCAqIEN1cnJlbnRseSwgb25seSBvbmUgcGx1Z2luIGNhbiBleGlzdCBwZXIgdHlwZS9leHRlbnNpb24uXG5cdCAqXG5cdCAqIFdoZW4gYSBwbHVnaW4gaXMgaW5zdGFsbGVkLCBhIDxjb2RlPmdldFByZWxvYWRIYW5kbGVycygpPC9jb2RlPiBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgb24gaXQuIEZvciBtb3JlIGluZm9ybWF0aW9uXG5cdCAqIG9uIHRoaXMgbWV0aG9kLCBjaGVjayBvdXQgdGhlIHt7I2Nyb3NzTGluayBcIlNhbXBsZVBsdWdpbi9nZXRQcmVsb2FkSGFuZGxlcnNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGluIHRoZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTYW1wbGVQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MuXG5cdCAqXG5cdCAqIEJlZm9yZSBhIGZpbGUgaXMgbG9hZGVkLCBhIG1hdGNoaW5nIHBsdWdpbiBoYXMgYW4gb3Bwb3J0dW5pdHkgdG8gbW9kaWZ5IHRoZSBsb2FkLiBJZiBhIGBjYWxsYmFja2AgaXMgcmV0dXJuZWRcblx0ICogZnJvbSB0aGUge3sjY3Jvc3NMaW5rIFwiU2FtcGxlUGx1Z2luL2dldFByZWxvYWRIYW5kbGVyc1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2QsIGl0IHdpbGwgYmUgaW52b2tlZCBmaXJzdCwgYW5kIGl0c1xuXHQgKiByZXN1bHQgbWF5IGNhbmNlbCBvciBtb2RpZnkgdGhlIGl0ZW0uIFRoZSBjYWxsYmFjayBtZXRob2QgY2FuIGFsc28gcmV0dXJuIGEgYGNvbXBsZXRlSGFuZGxlcmAgdG8gYmUgZmlyZWQgd2hlblxuXHQgKiB0aGUgZmlsZSBpcyBsb2FkZWQsIG9yIGEgYHRhZ2Agb2JqZWN0LCB3aGljaCB3aWxsIG1hbmFnZSB0aGUgYWN0dWFsIGRvd25sb2FkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZVxuXHQgKiBtZXRob2RzLCBjaGVjayBvdXQgdGhlIHt7I2Nyb3NzTGluayBcIlNhbXBsZVBsdWdpbi9wcmVsb2FkSGFuZGxlclwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiU2FtcGxlUGx1Z2luL2ZpbGVMb2FkSGFuZGxlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2RzIG9uIHRoZSB7eyNjcm9zc0xpbmsgXCJTYW1wbGVQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5zdGFsbFBsdWdpblxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwbHVnaW4gVGhlIHBsdWdpbiBjbGFzcyB0byBpbnN0YWxsLlxuXHQgKi9cblx0cC5pbnN0YWxsUGx1Z2luID0gZnVuY3Rpb24gKHBsdWdpbikge1xuXHRcdGlmIChwbHVnaW4gPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChwbHVnaW4uZ2V0UHJlbG9hZEhhbmRsZXJzICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3BsdWdpbnMucHVzaChwbHVnaW4pO1xuXHRcdFx0dmFyIG1hcCA9IHBsdWdpbi5nZXRQcmVsb2FkSGFuZGxlcnMoKTtcblx0XHRcdG1hcC5zY29wZSA9IHBsdWdpbjtcblxuXHRcdFx0aWYgKG1hcC50eXBlcyAhPSBudWxsKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbWFwLnR5cGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHRoaXMuX3R5cGVDYWxsYmFja3NbbWFwLnR5cGVzW2ldXSA9IG1hcDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWFwLmV4dGVuc2lvbnMgIT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKGkgPSAwLCBsID0gbWFwLmV4dGVuc2lvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5fZXh0ZW5zaW9uQ2FsbGJhY2tzW21hcC5leHRlbnNpb25zW2ldXSA9IG1hcDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogU2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiBjb25jdXJyZW50IGNvbm5lY3Rpb25zLiBOb3RlIHRoYXQgYnJvd3NlcnMgYW5kIHNlcnZlcnMgbWF5IGhhdmUgYSBidWlsdC1pbiBtYXhpbXVtXG5cdCAqIG51bWJlciBvZiBvcGVuIGNvbm5lY3Rpb25zLCBzbyBhbnkgYWRkaXRpb25hbCBjb25uZWN0aW9ucyBtYXkgcmVtYWluIGluIGEgcGVuZGluZyBzdGF0ZSB1bnRpbCB0aGUgYnJvd3NlclxuXHQgKiBvcGVucyB0aGUgY29ubmVjdGlvbi4gV2hlbiBsb2FkaW5nIHNjcmlwdHMgdXNpbmcgdGFncywgYW5kIHdoZW4ge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL21haW50YWluU2NyaXB0T3JkZXI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaXMgYHRydWVgLCBvbmx5IG9uZSBzY3JpcHQgaXMgbG9hZGVkIGF0IGEgdGltZSBkdWUgdG8gYnJvd3NlciBsaW1pdGF0aW9ucy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBxdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUoKTtcblx0ICogICAgICBxdWV1ZS5zZXRNYXhDb25uZWN0aW9ucygxMCk7IC8vIEFsbG93IDEwIGNvbmN1cnJlbnQgbG9hZHNcblx0ICpcblx0ICogQG1ldGhvZCBzZXRNYXhDb25uZWN0aW9uc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIG51bWJlciBvZiBjb25jdXJyZW50IGxvYWRzIHRvIGFsbG93LiBCeSBkZWZhdWx0LCBvbmx5IGEgc2luZ2xlIGNvbm5lY3Rpb24gcGVyIExvYWRRdWV1ZVxuXHQgKiBpcyBvcGVuIGF0IGFueSB0aW1lLlxuXHQgKi9cblx0cC5zZXRNYXhDb25uZWN0aW9ucyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHRoaXMuX21heENvbm5lY3Rpb25zID0gdmFsdWU7XG5cdFx0aWYgKCF0aGlzLl9wYXVzZWQgJiYgdGhpcy5fbG9hZFF1ZXVlLmxlbmd0aCA+IDApIHtcblx0XHRcdHRoaXMuX2xvYWROZXh0KCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBMb2FkIGEgc2luZ2xlIGZpbGUuIFRvIGFkZCBtdWx0aXBsZSBmaWxlcyBhdCBvbmNlLCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLlxuXHQgKlxuXHQgKiBGaWxlcyBhcmUgYWx3YXlzIGFwcGVuZGVkIHRvIHRoZSBjdXJyZW50IHF1ZXVlLCBzbyB0aGlzIG1ldGhvZCBjYW4gYmUgdXNlZCBtdWx0aXBsZSB0aW1lcyB0byBhZGQgZmlsZXMuXG5cdCAqIFRvIGNsZWFyIHRoZSBxdWV1ZSBmaXJzdCwgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9jbG9zZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG5cdCAqIEBtZXRob2QgbG9hZEZpbGVcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R8U3RyaW5nfSBmaWxlIFRoZSBmaWxlIG9iamVjdCBvciBwYXRoIHRvIGxvYWQuIEEgZmlsZSBjYW4gYmUgZWl0aGVyXG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5BIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlPC9saT5cblx0ICogICAgIDxsaT5BbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGRlZmluZWQgYnkge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX08L2xpPlxuXHQgKiAgICAgPGxpPk9SIEEgc3RyaW5nIHBhdGggdG8gYSByZXNvdXJjZS4gTm90ZSB0aGF0IHRoaXMga2luZCBvZiBsb2FkIGl0ZW0gd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiAgICAgaW4gdGhlIGJhY2tncm91bmQuPC9saT5cblx0ICogPC91bD5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbbG9hZE5vdz10cnVlXSBLaWNrIG9mZiBhbiBpbW1lZGlhdGUgbG9hZCAodHJ1ZSkgb3Igd2FpdCBmb3IgYSBsb2FkIGNhbGwgKGZhbHNlKS4gVGhlIGRlZmF1bHRcblx0ICogdmFsdWUgaXMgdHJ1ZS4gSWYgdGhlIHF1ZXVlIGlzIHBhdXNlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc2V0UGF1c2VkXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQgdGhlIHZhbHVlIGlzXG5cdCAqIGB0cnVlYCwgdGhlIHF1ZXVlIHdpbGwgcmVzdW1lIGF1dG9tYXRpY2FsbHkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbYmFzZVBhdGhdIEEgYmFzZSBwYXRoIHRoYXQgd2lsbCBiZSBwcmVwZW5kZWQgdG8gZWFjaCBmaWxlLiBUaGUgYmFzZVBhdGggYXJndW1lbnQgb3ZlcnJpZGVzIHRoZVxuXHQgKiBwYXRoIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IuIE5vdGUgdGhhdCBpZiB5b3UgbG9hZCBhIG1hbmlmZXN0IHVzaW5nIGEgZmlsZSBvZiB0eXBlIHt7I2Nyb3NzTGluayBcIlR5cGVzL01BTklGRVNUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBpdHMgZmlsZXMgd2lsbCA8c3Ryb25nPk5PVDwvc3Ryb25nPiB1c2UgdGhlIGJhc2VQYXRoIHBhcmFtZXRlci4gPHN0cm9uZz5UaGUgYmFzZVBhdGggcGFyYW1ldGVyIGlzIGRlcHJlY2F0ZWQuPC9zdHJvbmc+XG5cdCAqIFRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLiBQbGVhc2UgZWl0aGVyIHVzZSB0aGUgYGJhc2VQYXRoYCBwYXJhbWV0ZXIgaW4gdGhlIExvYWRRdWV1ZVxuXHQgKiBjb25zdHJ1Y3Rvciwgb3IgYSBgcGF0aGAgcHJvcGVydHkgaW4gYSBtYW5pZmVzdCBkZWZpbml0aW9uLlxuXHQgKi9cblx0cC5sb2FkRmlsZSA9IGZ1bmN0aW9uIChmaWxlLCBsb2FkTm93LCBiYXNlUGF0aCkge1xuXHRcdGlmIChmaWxlID09IG51bGwpIHtcblx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9OT19GSUxFXCIpO1xuXHRcdFx0dGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5fYWRkSXRlbShmaWxlLCBudWxsLCBiYXNlUGF0aCk7XG5cblx0XHRpZiAobG9hZE5vdyAhPT0gZmFsc2UpIHtcblx0XHRcdHRoaXMuc2V0UGF1c2VkKGZhbHNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZXRQYXVzZWQodHJ1ZSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBMb2FkIGFuIGFycmF5IG9mIGZpbGVzLiBUbyBsb2FkIGEgc2luZ2xlIGZpbGUsIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cblx0ICogVGhlIGZpbGVzIGluIHRoZSBtYW5pZmVzdCBhcmUgcmVxdWVzdGVkIGluIHRoZSBzYW1lIG9yZGVyLCBidXQgbWF5IGNvbXBsZXRlIGluIGEgZGlmZmVyZW50IG9yZGVyIGlmIHRoZSBtYXhcblx0ICogY29ubmVjdGlvbnMgYXJlIHNldCBhYm92ZSAxIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRNYXhDb25uZWN0aW9uc1wifX17ey9jcm9zc0xpbmt9fS4gU2NyaXB0cyB3aWxsIGxvYWRcblx0ICogaW4gdGhlIHJpZ2h0IG9yZGVyIGFzIGxvbmcgYXMge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL21haW50YWluU2NyaXB0T3JkZXJcIn19e3svY3Jvc3NMaW5rfX0gaXMgdHJ1ZSAod2hpY2ggaXNcblx0ICogZGVmYXVsdCkuXG5cdCAqXG5cdCAqIEZpbGVzIGFyZSBhbHdheXMgYXBwZW5kZWQgdG8gdGhlIGN1cnJlbnQgcXVldWUsIHNvIHRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIG11bHRpcGxlIHRpbWVzIHRvIGFkZCBmaWxlcy5cblx0ICogVG8gY2xlYXIgdGhlIHF1ZXVlIGZpcnN0LCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2Nsb3NlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cblx0ICogQG1ldGhvZCBsb2FkTWFuaWZlc3Rcblx0ICogQHBhcmFtIHtBcnJheXxTdHJpbmd8T2JqZWN0fSBtYW5pZmVzdCBBbiBsaXN0IG9mIGZpbGVzIHRvIGxvYWQuIFRoZSBsb2FkTWFuaWZlc3QgY2FsbCBzdXBwb3J0cyBmb3VyIHR5cGVzIG9mXG5cdCAqIG1hbmlmZXN0czpcblx0ICogPG9sPlxuXHQgKiAgICAgPGxpPkEgc3RyaW5nIHBhdGgsIHdoaWNoIHBvaW50cyB0byBhIG1hbmlmZXN0IGZpbGUsIHdoaWNoIGlzIGEgSlNPTiBmaWxlIHRoYXQgY29udGFpbnMgYSBcIm1hbmlmZXN0XCIgcHJvcGVydHksXG5cdCAqICAgICB3aGljaCBkZWZpbmVzIHRoZSBsaXN0IG9mIGZpbGVzIHRvIGxvYWQsIGFuZCBjYW4gb3B0aW9uYWxseSBjb250YWluIGEgXCJwYXRoXCIgcHJvcGVydHksIHdoaWNoIHdpbGwgYmVcblx0ICogICAgIHByZXBlbmRlZCB0byBlYWNoIGZpbGUgaW4gdGhlIGxpc3QuPC9saT5cblx0ICogICAgIDxsaT5BbiBvYmplY3Qgd2hpY2ggZGVmaW5lcyBhIFwic3JjXCIsIHdoaWNoIGlzIGEgSlNPTiBvciBKU09OUCBmaWxlLiBBIFwiY2FsbGJhY2tcIiBjYW4gYmUgZGVmaW5lZCBmb3IgSlNPTlBcblx0ICogICAgIGZpbGUuIFRoZSBKU09OL0pTT05QIGZpbGUgc2hvdWxkIGNvbnRhaW4gYSBcIm1hbmlmZXN0XCIgcHJvcGVydHksIHdoaWNoIGRlZmluZXMgdGhlIGxpc3Qgb2YgZmlsZXMgdG8gbG9hZCxcblx0ICogICAgIGFuZCBjYW4gb3B0aW9uYWxseSBjb250YWluIGEgXCJwYXRoXCIgcHJvcGVydHksIHdoaWNoIHdpbGwgYmUgcHJlcGVuZGVkIHRvIGVhY2ggZmlsZSBpbiB0aGUgbGlzdC48L2xpPlxuXHQgKiAgICAgPGxpPkFuIG9iamVjdCB3aGljaCBjb250YWlucyBhIFwibWFuaWZlc3RcIiBwcm9wZXJ0eSwgd2hpY2ggZGVmaW5lcyB0aGUgbGlzdCBvZiBmaWxlcyB0byBsb2FkLCBhbmQgY2FuXG5cdCAqICAgICBvcHRpb25hbGx5IGNvbnRhaW4gYSBcInBhdGhcIiBwcm9wZXJ0eSwgd2hpY2ggd2lsbCBiZSBwcmVwZW5kZWQgdG8gZWFjaCBmaWxlIGluIHRoZSBsaXN0LjwvbGk+XG5cdCAqICAgICA8bGk+QW4gQXJyYXkgb2YgZmlsZXMgdG8gbG9hZC48L2xpPlxuXHQgKiA8L29sPlxuXHQgKlxuXHQgKiBFYWNoIFwiZmlsZVwiIGluIGEgbWFuaWZlc3QgY2FuIGJlIGVpdGhlcjpcblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPkEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2U8L2xpPlxuXHQgKiAgICAgPGxpPkFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgZGVmaW5lZCBieSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fTwvbGk+XG5cdCAqICAgICA8bGk+T1IgQSBzdHJpbmcgcGF0aCB0byBhIHJlc291cmNlLiBOb3RlIHRoYXQgdGhpcyBraW5kIG9mIGxvYWQgaXRlbSB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqICAgICBpbiB0aGUgYmFja2dyb3VuZC48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtsb2FkTm93PXRydWVdIEtpY2sgb2ZmIGFuIGltbWVkaWF0ZSBsb2FkICh0cnVlKSBvciB3YWl0IGZvciBhIGxvYWQgY2FsbCAoZmFsc2UpLiBUaGUgZGVmYXVsdFxuXHQgKiB2YWx1ZSBpcyB0cnVlLiBJZiB0aGUgcXVldWUgaXMgcGF1c2VkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRQYXVzZWRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHRoaXMgdmFsdWUgaXNcblx0ICogYHRydWVgLCB0aGUgcXVldWUgd2lsbCByZXN1bWUgYXV0b21hdGljYWxseS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtiYXNlUGF0aF0gQSBiYXNlIHBhdGggdGhhdCB3aWxsIGJlIHByZXBlbmRlZCB0byBlYWNoIGZpbGUuIFRoZSBiYXNlUGF0aCBhcmd1bWVudCBvdmVycmlkZXMgdGhlXG5cdCAqIHBhdGggc3BlY2lmaWVkIGluIHRoZSBjb25zdHJ1Y3Rvci4gTm90ZSB0aGF0IGlmIHlvdSBsb2FkIGEgbWFuaWZlc3QgdXNpbmcgYSBmaWxlIG9mIHR5cGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL01BTklGRVNUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBpdHMgZmlsZXMgd2lsbCA8c3Ryb25nPk5PVDwvc3Ryb25nPiB1c2UgdGhlIGJhc2VQYXRoIHBhcmFtZXRlci4gPHN0cm9uZz5UaGUgYmFzZVBhdGggcGFyYW1ldGVyIGlzIGRlcHJlY2F0ZWQuPC9zdHJvbmc+XG5cdCAqIFRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLiBQbGVhc2UgZWl0aGVyIHVzZSB0aGUgYGJhc2VQYXRoYCBwYXJhbWV0ZXIgaW4gdGhlIExvYWRRdWV1ZVxuXHQgKiBjb25zdHJ1Y3Rvciwgb3IgYSBgcGF0aGAgcHJvcGVydHkgaW4gYSBtYW5pZmVzdCBkZWZpbml0aW9uLlxuXHQgKi9cblx0cC5sb2FkTWFuaWZlc3QgPSBmdW5jdGlvbiAobWFuaWZlc3QsIGxvYWROb3csIGJhc2VQYXRoKSB7XG5cdFx0dmFyIGZpbGVMaXN0ID0gbnVsbDtcblx0XHR2YXIgcGF0aCA9IG51bGw7XG5cblx0XHQvLyBBcnJheS1iYXNlZCBsaXN0IG9mIGl0ZW1zXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkobWFuaWZlc3QpKSB7XG5cdFx0XHRpZiAobWFuaWZlc3QubGVuZ3RoID09IDApIHtcblx0XHRcdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJQUkVMT0FEX01BTklGRVNUX0VNUFRZXCIpO1xuXHRcdFx0XHR0aGlzLl9zZW5kRXJyb3IoZXZlbnQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRmaWxlTGlzdCA9IG1hbmlmZXN0O1xuXG5cdFx0XHQvLyBTdHJpbmctYmFzZWQuIE9ubHkgZmlsZSBtYW5pZmVzdHMgY2FuIGJlIHNwZWNpZmllZCB0aGlzIHdheS4gQW55IG90aGVyIHR5cGVzIHdpbGwgY2F1c2UgYW4gZXJyb3Igd2hlbiBsb2FkZWQuXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YobWFuaWZlc3QpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRmaWxlTGlzdCA9IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHNyYzogbWFuaWZlc3QsXG5cdFx0XHRcdFx0dHlwZTogcy5NQU5JRkVTVFxuXHRcdFx0XHR9XG5cdFx0XHRdO1xuXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YobWFuaWZlc3QpID09IFwib2JqZWN0XCIpIHtcblxuXHRcdFx0Ly8gQW4gb2JqZWN0IHRoYXQgZGVmaW5lcyBhIG1hbmlmZXN0IHBhdGhcblx0XHRcdGlmIChtYW5pZmVzdC5zcmMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAobWFuaWZlc3QudHlwZSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0bWFuaWZlc3QudHlwZSA9IHMuTUFOSUZFU1Q7XG5cdFx0XHRcdH0gZWxzZSBpZiAobWFuaWZlc3QudHlwZSAhPSBzLk1BTklGRVNUKSB7XG5cdFx0XHRcdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJQUkVMT0FEX01BTklGRVNUX1RZUEVcIik7XG5cdFx0XHRcdFx0dGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmaWxlTGlzdCA9IFttYW5pZmVzdF07XG5cblx0XHRcdFx0Ly8gQW4gb2JqZWN0IHRoYXQgZGVmaW5lcyBhIG1hbmlmZXN0XG5cdFx0XHR9IGVsc2UgaWYgKG1hbmlmZXN0Lm1hbmlmZXN0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZmlsZUxpc3QgPSBtYW5pZmVzdC5tYW5pZmVzdDtcblx0XHRcdFx0cGF0aCA9IG1hbmlmZXN0LnBhdGg7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVuc3VwcG9ydGVkLiBUaGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9NQU5JRkVTVF9OVUxMXCIpO1xuXHRcdFx0dGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGZpbGVMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dGhpcy5fYWRkSXRlbShmaWxlTGlzdFtpXSwgcGF0aCwgYmFzZVBhdGgpO1xuXHRcdH1cblxuXHRcdGlmIChsb2FkTm93ICE9PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5zZXRQYXVzZWQoZmFsc2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNldFBhdXNlZCh0cnVlKTtcblx0XHR9XG5cblx0fTtcblxuXHQvKipcblx0ICogU3RhcnQgYSBMb2FkUXVldWUgdGhhdCB3YXMgY3JlYXRlZCwgYnV0IG5vdCBhdXRvbWF0aWNhbGx5IHN0YXJ0ZWQuXG5cdCAqIEBtZXRob2QgbG9hZFxuXHQgKi9cblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuc2V0UGF1c2VkKGZhbHNlKTtcblx0fTtcblxuXHQvKipcblx0ICogTG9vayB1cCBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IHVzaW5nIGVpdGhlciB0aGUgXCJpZFwiIG9yIFwic3JjXCIgdGhhdCB3YXMgc3BlY2lmaWVkIHdoZW4gbG9hZGluZyBpdC4gTm90ZSB0aGF0IGlmIG5vIFwiaWRcIiB3YXNcblx0ICogc3VwcGxpZWQgd2l0aCB0aGUgbG9hZCBpdGVtLCB0aGUgSUQgd2lsbCBiZSB0aGUgXCJzcmNcIiwgaW5jbHVkaW5nIGEgYHBhdGhgIHByb3BlcnR5IGRlZmluZWQgYnkgYSBtYW5pZmVzdC4gVGhlXG5cdCAqIGBiYXNlUGF0aGAgd2lsbCBub3QgYmUgcGFydCBvZiB0aGUgSUQuXG5cdCAqIEBtZXRob2QgZ2V0SXRlbVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIDxjb2RlPmlkPC9jb2RlPiBvciA8Y29kZT5zcmM8L2NvZGU+IG9mIHRoZSBsb2FkIGl0ZW0uXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGxvYWQgaXRlbSB0aGF0IHdhcyBpbml0aWFsbHkgcmVxdWVzdGVkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvciB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319LiBUaGlzIG9iamVjdCBpcyBhbHNvIHJldHVybmVkIHZpYSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IGFzIHRoZSBgaXRlbWAgcGFyYW1ldGVyLlxuXHQgKi9cblx0cC5nZXRJdGVtID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRJdGVtc0J5SWRbdmFsdWVdIHx8IHRoaXMuX2xvYWRJdGVtc0J5U3JjW3ZhbHVlXTtcblx0fTtcblxuXHQvKipcblx0ICogTG9vayB1cCBhIGxvYWRlZCByZXN1bHQgdXNpbmcgZWl0aGVyIHRoZSBcImlkXCIgb3IgXCJzcmNcIiB0aGF0IHdhcyBzcGVjaWZpZWQgd2hlbiBsb2FkaW5nIGl0LiBOb3RlIHRoYXQgaWYgbm8gXCJpZFwiXG5cdCAqIHdhcyBzdXBwbGllZCB3aXRoIHRoZSBsb2FkIGl0ZW0sIHRoZSBJRCB3aWxsIGJlIHRoZSBcInNyY1wiLCBpbmNsdWRpbmcgYSBgcGF0aGAgcHJvcGVydHkgZGVmaW5lZCBieSBhIG1hbmlmZXN0LiBUaGVcblx0ICogYGJhc2VQYXRoYCB3aWxsIG5vdCBiZSBwYXJ0IG9mIHRoZSBJRC5cblx0ICogQG1ldGhvZCBnZXRSZXN1bHRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSA8Y29kZT5pZDwvY29kZT4gb3IgPGNvZGU+c3JjPC9jb2RlPiBvZiB0aGUgbG9hZCBpdGVtLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyYXdSZXN1bHQ9ZmFsc2VdIFJldHVybiBhIHJhdyByZXN1bHQgaW5zdGVhZCBvZiBhIGZvcm1hdHRlZCByZXN1bHQuIFRoaXMgYXBwbGllcyB0byBjb250ZW50XG5cdCAqIGxvYWRlZCB2aWEgWEhSIHN1Y2ggYXMgc2NyaXB0cywgWE1MLCBDU1MsIGFuZCBJbWFnZXMuIElmIHRoZXJlIGlzIG5vIHJhdyByZXN1bHQsIHRoZSBmb3JtYXR0ZWQgcmVzdWx0IHdpbGwgYmVcblx0ICogcmV0dXJuZWQgaW5zdGVhZC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBBIHJlc3VsdCBvYmplY3QgY29udGFpbmluZyB0aGUgY29udGVudCB0aGF0IHdhcyBsb2FkZWQsIHN1Y2ggYXM6XG5cdCAqIDx1bD5cblx0ICogICAgICA8bGk+QW4gaW1hZ2UgdGFnICgmbHQ7aW1hZ2UgLyZndDspIGZvciBpbWFnZXM8L2xpPlxuXHQgKiAgICAgIDxsaT5BIHNjcmlwdCB0YWcgZm9yIEphdmFTY3JpcHQgKCZsdDtzY3JpcHQgLyZndDspLiBOb3RlIHRoYXQgc2NyaXB0cyBhcmUgYXV0b21hdGljYWxseSBhZGRlZCB0byB0aGUgSFRNTFxuXHQgKiAgICAgIERPTS48L2xpPlxuXHQgKiAgICAgIDxsaT5BIHN0eWxlIHRhZyBmb3IgQ1NTICgmbHQ7c3R5bGUgLyZndDsgb3IgJmx0O2xpbmsgJmd0Oyk8L2xpPlxuXHQgKiAgICAgIDxsaT5SYXcgdGV4dCBmb3IgVEVYVDwvbGk+XG5cdCAqICAgICAgPGxpPkEgZm9ybWF0dGVkIEphdmFTY3JpcHQgb2JqZWN0IGRlZmluZWQgYnkgSlNPTjwvbGk+XG5cdCAqICAgICAgPGxpPkFuIFhNTCBkb2N1bWVudDwvbGk+XG5cdCAqICAgICAgPGxpPkEgYmluYXJ5IGFycmF5YnVmZmVyIGxvYWRlZCBieSBYSFI8L2xpPlxuXHQgKiAgICAgIDxsaT5BbiBhdWRpbyB0YWcgKCZsdDthdWRpbyAmZ3Q7KSBmb3IgSFRNTCBhdWRpby4gTm90ZSB0aGF0IGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBTb3VuZEpTIEFQSXMgdG8gcGxheVxuXHQgKiAgICAgIGxvYWRlZCBhdWRpby4gU3BlY2lmaWNhbGx5LCBhdWRpbyBsb2FkZWQgYnkgRmxhc2ggYW5kIFdlYkF1ZGlvIHdpbGwgcmV0dXJuIGEgbG9hZGVyIG9iamVjdCB1c2luZyB0aGlzIG1ldGhvZFxuXHQgKiAgICAgIHdoaWNoIGNhbiBub3QgYmUgdXNlZCB0byBwbGF5IGF1ZGlvIGJhY2suPC9saT5cblx0ICogPC91bD5cblx0ICogVGhpcyBvYmplY3QgaXMgYWxzbyByZXR1cm5lZCB2aWEgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBhcyB0aGUgJ2l0ZW1gXG5cdCAqIHBhcmFtZXRlci4gTm90ZSB0aGF0IGlmIGEgcmF3IHJlc3VsdCBpcyByZXF1ZXN0ZWQsIGJ1dCBub3QgZm91bmQsIHRoZSByZXN1bHQgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkLlxuXHQgKi9cblx0cC5nZXRSZXN1bHQgPSBmdW5jdGlvbiAodmFsdWUsIHJhd1Jlc3VsdCkge1xuXHRcdHZhciBpdGVtID0gdGhpcy5fbG9hZEl0ZW1zQnlJZFt2YWx1ZV0gfHwgdGhpcy5fbG9hZEl0ZW1zQnlTcmNbdmFsdWVdO1xuXHRcdGlmIChpdGVtID09IG51bGwpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHR2YXIgaWQgPSBpdGVtLmlkO1xuXHRcdGlmIChyYXdSZXN1bHQgJiYgdGhpcy5fbG9hZGVkUmF3UmVzdWx0c1tpZF0pIHtcblx0XHRcdHJldHVybiB0aGlzLl9sb2FkZWRSYXdSZXN1bHRzW2lkXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRlZFJlc3VsdHNbaWRdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBhbiBsaXN0IG9mIGl0ZW1zIGxvYWRlZCBieSB0aGlzIHF1ZXVlLlxuXHQgKiBAbWV0aG9kIGdldEl0ZW1zXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gbG9hZGVkIERldGVybWluZXMgaWYgb25seSBpdGVtcyB0aGF0IGhhdmUgYmVlbiBsb2FkZWQgc2hvdWxkIGJlIHJldHVybmVkLiBJZiBmYWxzZSwgaW4tcHJvZ3Jlc3Ncblx0ICogYW5kIGZhaWxlZCBsb2FkIGl0ZW1zIHdpbGwgYWxzbyBiZSBpbmNsdWRlZC5cblx0ICogQHJldHVybnMge0FycmF5fSBBIGxpc3Qgb2Ygb2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBsb2FkZWQuIEVhY2ggaXRlbSBpbmNsdWRlcyB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIHJlc3VsdCwgYW5kIHJhd1Jlc3VsdC5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmdldEl0ZW1zID0gZnVuY3Rpb24gKGxvYWRlZCkge1xuXHRcdHZhciBhcnIgPSBbXTtcblx0XHRmb3IgKHZhciBuIGluIHRoaXMuX2xvYWRJdGVtc0J5SWQpIHtcblx0XHRcdHZhciBpdGVtID0gdGhpcy5fbG9hZEl0ZW1zQnlJZFtuXTtcblx0XHRcdHZhciByZXN1bHQgPSB0aGlzLmdldFJlc3VsdChuKTtcblx0XHRcdGlmIChsb2FkZWQgPT09IHRydWUgJiYgcmVzdWx0ID09IG51bGwpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRhcnIucHVzaCh7XG5cdFx0XHRcdGl0ZW06IGl0ZW0sXG5cdFx0XHRcdHJlc3VsdDogcmVzdWx0LFxuXHRcdFx0XHRyYXdSZXN1bHQ6IHRoaXMuZ2V0UmVzdWx0KG4sIHRydWUpXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIGFycjtcblx0fTtcblxuXHQvKipcblx0ICogUGF1c2Ugb3IgcmVzdW1lIHRoZSBjdXJyZW50IGxvYWQuIEFjdGl2ZSBsb2FkcyB3aWxsIG5vdCBiZSBjYW5jZWxsZWQsIGJ1dCB0aGUgbmV4dCBpdGVtcyBpbiB0aGUgcXVldWUgd2lsbCBub3Rcblx0ICogYmUgcHJvY2Vzc2VkIHdoZW4gYWN0aXZlIGxvYWRzIGNvbXBsZXRlLiBMb2FkUXVldWVzIGFyZSBub3QgcGF1c2VkIGJ5IGRlZmF1bHQuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBpZiBuZXcgaXRlbXMgYXJlIGFkZGVkIHRvIHRoZSBxdWV1ZSB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fSwgYSBwYXVzZWQgcXVldWUgd2lsbCBiZSByZXN1bWVkLCB1bmxlc3MgdGhlIGBsb2FkTm93YFxuXHQgKiBhcmd1bWVudCBpcyBgZmFsc2VgLlxuXHQgKiBAbWV0aG9kIHNldFBhdXNlZFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIFdoZXRoZXIgdGhlIHF1ZXVlIHNob3VsZCBiZSBwYXVzZWQgb3Igbm90LlxuXHQgKi9cblx0cC5zZXRQYXVzZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR0aGlzLl9wYXVzZWQgPSB2YWx1ZTtcblx0XHRpZiAoIXRoaXMuX3BhdXNlZCkge1xuXHRcdFx0dGhpcy5fbG9hZE5leHQoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENsb3NlIHRoZSBhY3RpdmUgcXVldWUuIENsb3NpbmcgYSBxdWV1ZSBjb21wbGV0ZWx5IGVtcHRpZXMgdGhlIHF1ZXVlLCBhbmQgcHJldmVudHMgYW55IHJlbWFpbmluZyBpdGVtcyBmcm9tXG5cdCAqIHN0YXJ0aW5nIHRvIGRvd25sb2FkLiBOb3RlIHRoYXQgY3VycmVudGx5IGFueSBhY3RpdmUgbG9hZHMgd2lsbCByZW1haW4gb3BlbiwgYW5kIGV2ZW50cyBtYXkgYmUgcHJvY2Vzc2VkLlxuXHQgKlxuXHQgKiBUbyBzdG9wIGFuZCByZXN0YXJ0IGEgcXVldWUsIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldFBhdXNlZFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBjbG9zZVxuXHQgKi9cblx0cC5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR3aGlsZSAodGhpcy5fY3VycmVudExvYWRzLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5fY3VycmVudExvYWRzLnBvcCgpLmNhbmNlbCgpO1xuXHRcdH1cblx0XHR0aGlzLl9zY3JpcHRPcmRlci5sZW5ndGggPSAwO1xuXHRcdHRoaXMuX2xvYWRlZFNjcmlwdHMubGVuZ3RoID0gMDtcblx0XHR0aGlzLmxvYWRTdGFydFdhc0Rpc3BhdGNoZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9pdGVtQ291bnQgPSAwO1xuXHRcdHRoaXMuX2xhc3RQcm9ncmVzcyA9IE5hTjtcblx0fTtcblxuLy8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIEFkZCBhbiBpdGVtIHRvIHRoZSBxdWV1ZS4gSXRlbXMgYXJlIGZvcm1hdHRlZCBpbnRvIGEgdXNhYmxlIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgcHJvcGVydGllcyBuZWNlc3NhcnkgdG9cblx0ICogbG9hZCB0aGUgY29udGVudC4gVGhlIGxvYWQgcXVldWUgaXMgcG9wdWxhdGVkIHdpdGggdGhlIGxvYWRlciBpbnN0YW5jZSB0aGF0IGhhbmRsZXMgcHJlbG9hZGluZywgYW5kIG5vdCB0aGUgbG9hZFxuXHQgKiBpdGVtIHRoYXQgd2FzIHBhc3NlZCBpbiBieSB0aGUgdXNlci4gVG8gbG9vayB1cCB0aGUgbG9hZCBpdGVtIGJ5IGlkIG9yIHNyYywgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUuZ2V0SXRlbVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuXG5cdCAqIEBtZXRob2QgX2FkZEl0ZW1cblx0ICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB2YWx1ZSBUaGUgaXRlbSB0byBhZGQgdG8gdGhlIHF1ZXVlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdIEFuIG9wdGlvbmFsIHBhdGggcHJlcGVuZGVkIHRvIHRoZSBgc3JjYC4gVGhlIHBhdGggd2lsbCBvbmx5IGJlIHByZXBlbmRlZCBpZiB0aGUgc3JjIGlzXG5cdCAqIHJlbGF0aXZlLCBhbmQgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIHByb3RvY29sIHN1Y2ggYXMgYGh0dHA6Ly9gLCBvciBhIHBhdGggbGlrZSBgLi4vYC4gSWYgdGhlIExvYWRRdWV1ZSB3YXNcblx0ICogcHJvdmlkZWQgYSB7eyNjcm9zc0xpbmsgXCJfYmFzZVBhdGhcIn19e3svY3Jvc3NMaW5rfX0sIHRoZW4gaXQgd2lsbCBvcHRpb25hbGx5IGJlIHByZXBlbmRlZCBhZnRlci5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtiYXNlUGF0aF0gPHN0cm9uZz5EZXByZWNhdGVkPC9zdHJvbmc+QW4gb3B0aW9uYWwgYmFzZVBhdGggcGFzc2VkIGludG8gYSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG9yIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fSBjYWxsLiBUaGlzIHBhcmFtZXRlciB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdGFnZ2VkXG5cdCAqIHZlcnNpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9hZGRJdGVtID0gZnVuY3Rpb24gKHZhbHVlLCBwYXRoLCBiYXNlUGF0aCkge1xuXHRcdHZhciBpdGVtID0gdGhpcy5fY3JlYXRlTG9hZEl0ZW0odmFsdWUsIHBhdGgsIGJhc2VQYXRoKTsgLy8gYmFzZVBhdGggYW5kIG1hbmlmZXN0IHBhdGggYXJlIGFkZGVkIHRvIHRoZSBzcmMuXG5cdFx0aWYgKGl0ZW0gPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy8gU29tZXRpbWVzIHBsdWdpbnMgb3IgdHlwZXMgc2hvdWxkIGJlIHNraXBwZWQuXG5cdFx0dmFyIGxvYWRlciA9IHRoaXMuX2NyZWF0ZUxvYWRlcihpdGVtKTtcblx0XHRpZiAobG9hZGVyICE9IG51bGwpIHtcblx0XHRcdGlmIChcInBsdWdpbnNcIiBpbiBsb2FkZXIpIHtcblx0XHRcdFx0bG9hZGVyLnBsdWdpbnMgPSB0aGlzLl9wbHVnaW5zO1xuXHRcdFx0fVxuXHRcdFx0aXRlbS5fbG9hZGVyID0gbG9hZGVyO1xuXHRcdFx0dGhpcy5fbG9hZFF1ZXVlLnB1c2gobG9hZGVyKTtcblx0XHRcdHRoaXMuX2xvYWRRdWV1ZUJhY2t1cC5wdXNoKGxvYWRlcik7XG5cblx0XHRcdHRoaXMuX251bUl0ZW1zKys7XG5cdFx0XHR0aGlzLl91cGRhdGVQcm9ncmVzcygpO1xuXG5cdFx0XHQvLyBPbmx5IHdvcnJ5IGFib3V0IHNjcmlwdCBvcmRlciB3aGVuIHVzaW5nIFhIUiB0byBsb2FkIHNjcmlwdHMuIFRhZ3MgYXJlIG9ubHkgbG9hZGluZyBvbmUgYXQgYSB0aW1lLlxuXHRcdFx0aWYgKCh0aGlzLm1haW50YWluU2NyaXB0T3JkZXJcblx0XHRcdFx0XHQmJiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuVHlwZXMuSkFWQVNDUklQVFxuXHRcdFx0XHRcdFx0Ly8mJiBsb2FkZXIgaW5zdGFuY2VvZiBjcmVhdGVqcy5YSFJMb2FkZXIgLy9OT1RFOiBIYXZlIHRvIHRyYWNrIGFsbCBKUyBmaWxlcyB0aGlzIHdheVxuXHRcdFx0XHRcdClcblx0XHRcdFx0XHR8fCBpdGVtLm1haW50YWluT3JkZXIgPT09IHRydWUpIHtcblx0XHRcdFx0dGhpcy5fc2NyaXB0T3JkZXIucHVzaChpdGVtKTtcblx0XHRcdFx0dGhpcy5fbG9hZGVkU2NyaXB0cy5wdXNoKG51bGwpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgcmVmaW5lZCB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSwgd2hpY2ggY29udGFpbnMgYWxsIHRoZSByZXF1aXJlZCBwcm9wZXJ0aWVzLiBUaGUgdHlwZSBvZlxuXHQgKiBpdGVtIGlzIGRldGVybWluZWQgYnkgYnJvd3NlciBzdXBwb3J0LCByZXF1aXJlbWVudHMgYmFzZWQgb24gdGhlIGZpbGUgdHlwZSwgYW5kIGRldmVsb3BlciBzZXR0aW5ncy4gRm9yIGV4YW1wbGUsXG5cdCAqIFhIUiBpcyBvbmx5IHVzZWQgZm9yIGZpbGUgdHlwZXMgdGhhdCBzdXBwb3J0IGl0IGluIG5ldyBicm93c2Vycy5cblx0ICpcblx0ICogQmVmb3JlIHRoZSBpdGVtIGlzIHJldHVybmVkLCBhbnkgcGx1Z2lucyByZWdpc3RlcmVkIHRvIGhhbmRsZSB0aGUgdHlwZSBvciBleHRlbnNpb24gd2lsbCBiZSBmaXJlZCwgd2hpY2ggbWF5XG5cdCAqIGFsdGVyIHRoZSBsb2FkIGl0ZW0uXG5cdCAqIEBtZXRob2QgX2NyZWF0ZUxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgT2JqZWN0IHwgSFRNTEF1ZGlvRWxlbWVudCB8IEhUTUxJbWFnZUVsZW1lbnR9IHZhbHVlIFRoZSBpdGVtIHRoYXQgbmVlZHMgdG8gYmUgcHJlbG9hZGVkLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdIEEgcGF0aCB0byBwcmVwZW5kIHRvIHRoZSBpdGVtJ3Mgc291cmNlLiBTb3VyY2VzIGJlZ2lubmluZyB3aXRoIGh0dHA6Ly8gb3Igc2ltaWxhciB3aWxsXG5cdCAqIG5vdCByZWNlaXZlIGEgcGF0aC4gU2luY2UgUHJlbG9hZEpTIDAuNC4xLCB0aGUgc3JjIHdpbGwgYmUgbW9kaWZpZWQgdG8gaW5jbHVkZSB0aGUgYHBhdGhgIGFuZCB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvX2Jhc2VQYXRoOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdoZW4gaXQgaXMgYWRkZWQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbYmFzZVBhdGhdIDxzdHJvbmc+RGVwcmVjdGF0ZWQ8L3N0cm9uZz4gQSBiYXNlIHBhdGggdG8gcHJlcGVuZCB0byB0aGUgaXRlbXMgc291cmNlIGluIGFkZGl0aW9uIHRvXG5cdCAqIHRoZSBwYXRoIGFyZ3VtZW50LlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBsb2FkZXIgaW5zdGFuY2UgdGhhdCB3aWxsIGJlIHVzZWQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jcmVhdGVMb2FkSXRlbSA9IGZ1bmN0aW9uICh2YWx1ZSwgcGF0aCwgYmFzZVBhdGgpIHtcblx0XHR2YXIgaXRlbSA9IGNyZWF0ZWpzLkxvYWRJdGVtLmNyZWF0ZSh2YWx1ZSk7XG5cdFx0aWYgKGl0ZW0gPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dmFyIGJwID0gXCJcIjsgLy8gU3RvcmUgdGhlIGdlbmVyYXRlZCBiYXNlUGF0aFxuXHRcdHZhciB1c2VCYXNlUGF0aCA9IGJhc2VQYXRoIHx8IHRoaXMuX2Jhc2VQYXRoO1xuXG5cdFx0aWYgKGl0ZW0uc3JjIGluc3RhbmNlb2YgT2JqZWN0KSB7XG5cdFx0XHRpZiAoIWl0ZW0udHlwZSkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0gLy8gdGhlIHRoZSBzcmMgaXMgYW4gb2JqZWN0LCB0eXBlIGlzIHJlcXVpcmVkIHRvIHBhc3Mgb2ZmIHRvIHBsdWdpblxuXHRcdFx0aWYgKHBhdGgpIHtcblx0XHRcdFx0YnAgPSBwYXRoO1xuXHRcdFx0XHR2YXIgcGF0aE1hdGNoID0gY3JlYXRlanMuVVJMVXRpbHMucGFyc2VVUkkocGF0aCk7XG5cdFx0XHRcdC8vIEFsc28gYXBwZW5kIGJhc2VQYXRoXG5cdFx0XHRcdGlmICh1c2VCYXNlUGF0aCAhPSBudWxsICYmICFwYXRoTWF0Y2guYWJzb2x1dGUgJiYgIXBhdGhNYXRjaC5yZWxhdGl2ZSkge1xuXHRcdFx0XHRcdGJwID0gdXNlQmFzZVBhdGggKyBicDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh1c2VCYXNlUGF0aCAhPSBudWxsKSB7XG5cdFx0XHRcdGJwID0gdXNlQmFzZVBhdGg7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIERldGVybWluZSBFeHRlbnNpb24sIGV0Yy5cblx0XHRcdHZhciBtYXRjaCA9IGNyZWF0ZWpzLlVSTFV0aWxzLnBhcnNlVVJJKGl0ZW0uc3JjKTtcblx0XHRcdGlmIChtYXRjaC5leHRlbnNpb24pIHtcblx0XHRcdFx0aXRlbS5leHQgPSBtYXRjaC5leHRlbnNpb247XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXRlbS50eXBlID09IG51bGwpIHtcblx0XHRcdFx0aXRlbS50eXBlID0gY3JlYXRlanMuUmVxdWVzdFV0aWxzLmdldFR5cGVCeUV4dGVuc2lvbihpdGVtLmV4dCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluamVjdCBwYXRoICYgYmFzZVBhdGhcblx0XHRcdHZhciBhdXRvSWQgPSBpdGVtLnNyYztcblx0XHRcdGlmICghbWF0Y2guYWJzb2x1dGUgJiYgIW1hdGNoLnJlbGF0aXZlKSB7XG5cdFx0XHRcdGlmIChwYXRoKSB7XG5cdFx0XHRcdFx0YnAgPSBwYXRoO1xuXHRcdFx0XHRcdHZhciBwYXRoTWF0Y2ggPSBjcmVhdGVqcy5VUkxVdGlscy5wYXJzZVVSSShwYXRoKTtcblx0XHRcdFx0XHRhdXRvSWQgPSBwYXRoICsgYXV0b0lkO1xuXHRcdFx0XHRcdC8vIEFsc28gYXBwZW5kIGJhc2VQYXRoXG5cdFx0XHRcdFx0aWYgKHVzZUJhc2VQYXRoICE9IG51bGwgJiYgIXBhdGhNYXRjaC5hYnNvbHV0ZSAmJiAhcGF0aE1hdGNoLnJlbGF0aXZlKSB7XG5cdFx0XHRcdFx0XHRicCA9IHVzZUJhc2VQYXRoICsgYnA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHVzZUJhc2VQYXRoICE9IG51bGwpIHtcblx0XHRcdFx0XHRicCA9IHVzZUJhc2VQYXRoO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpdGVtLnNyYyA9IGJwICsgaXRlbS5zcmM7XG5cdFx0fVxuXHRcdGl0ZW0ucGF0aCA9IGJwO1xuXG5cdFx0Ly8gSWYgdGhlcmUncyBubyBpZCwgc2V0IG9uZSBub3cuXG5cdFx0aWYgKGl0ZW0uaWQgPT09IHVuZGVmaW5lZCB8fCBpdGVtLmlkID09PSBudWxsIHx8IGl0ZW0uaWQgPT09IFwiXCIpIHtcblx0XHRcdGl0ZW0uaWQgPSBhdXRvSWQ7XG5cdFx0fVxuXG5cdFx0Ly8gR2l2ZSBwbHVnaW5zIGEgY2hhbmNlIHRvIG1vZGlmeSB0aGUgbG9hZEl0ZW06XG5cdFx0dmFyIGN1c3RvbUhhbmRsZXIgPSB0aGlzLl90eXBlQ2FsbGJhY2tzW2l0ZW0udHlwZV0gfHwgdGhpcy5fZXh0ZW5zaW9uQ2FsbGJhY2tzW2l0ZW0uZXh0XTtcblx0XHRpZiAoY3VzdG9tSGFuZGxlcikge1xuXHRcdFx0Ly8gUGx1Z2lucyBhcmUgbm93IHBhc3NlZCBib3RoIHRoZSBmdWxsIHNvdXJjZSwgYXMgd2VsbCBhcyBhIGNvbWJpbmVkIHBhdGgrYmFzZVBhdGggKGFwcHJvcHJpYXRlbHkpXG5cdFx0XHR2YXIgcmVzdWx0ID0gY3VzdG9tSGFuZGxlci5jYWxsYmFjay5jYWxsKGN1c3RvbUhhbmRsZXIuc2NvcGUsIGl0ZW0sIHRoaXMpO1xuXG5cdFx0XHQvLyBUaGUgcGx1Z2luIHdpbGwgaGFuZGxlIHRoZSBsb2FkLCBvciBoYXMgY2FuY2VsZWQgaXQuIElnbm9yZSBpdC5cblx0XHRcdGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHRcdC8vIExvYWQgYXMgbm9ybWFsOlxuXHRcdFx0fSBlbHNlIGlmIChyZXN1bHQgPT09IHRydWUpIHtcblx0XHRcdFx0Ly8gRG8gTm90aGluZ1xuXG5cdFx0XHRcdC8vIFJlc3VsdCBpcyBhIGxvYWRlciBjbGFzczpcblx0XHRcdH0gZWxzZSBpZiAocmVzdWx0ICE9IG51bGwpIHtcblx0XHRcdFx0aXRlbS5fbG9hZGVyID0gcmVzdWx0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVcGRhdGUgdGhlIGV4dGVuc2lvbiBpbiBjYXNlIHRoZSB0eXBlIGNoYW5nZWQ6XG5cdFx0XHRtYXRjaCA9IGNyZWF0ZWpzLlVSTFV0aWxzLnBhcnNlVVJJKGl0ZW0uc3JjKTtcblx0XHRcdGlmIChtYXRjaC5leHRlbnNpb24gIT0gbnVsbCkge1xuXHRcdFx0XHRpdGVtLmV4dCA9IG1hdGNoLmV4dGVuc2lvbjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdG9yZSB0aGUgaXRlbSBmb3IgbG9va3VwLiBUaGlzIGFsc28gaGVscHMgY2xlYW4tdXAgbGF0ZXIuXG5cdFx0dGhpcy5fbG9hZEl0ZW1zQnlJZFtpdGVtLmlkXSA9IGl0ZW07XG5cdFx0dGhpcy5fbG9hZEl0ZW1zQnlTcmNbaXRlbS5zcmNdID0gaXRlbTtcblxuXHRcdGlmIChpdGVtLmNyb3NzT3JpZ2luID09IG51bGwpIHtcblx0XHRcdGl0ZW0uY3Jvc3NPcmlnaW4gPSB0aGlzLl9jcm9zc09yaWdpbjtcblx0XHR9XG5cblx0XHRyZXR1cm4gaXRlbTtcblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgbG9hZGVyIGZvciBhIGxvYWQgaXRlbS5cblx0ICogQG1ldGhvZCBfY3JlYXRlTG9hZGVyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIEEgZm9ybWF0dGVkIGxvYWQgaXRlbSB0aGF0IGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIGEgbG9hZGVyLlxuXHQgKiBAcmV0dXJuIHtBYnN0cmFjdExvYWRlcn0gQSBsb2FkZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBsb2FkIGNvbnRlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jcmVhdGVMb2FkZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdGlmIChpdGVtLl9sb2FkZXIgIT0gbnVsbCkgeyAvLyBBIHBsdWdpbiBhbHJlYWR5IHNwZWNpZmllZCBhIGxvYWRlclxuXHRcdFx0cmV0dXJuIGl0ZW0uX2xvYWRlcjtcblx0XHR9XG5cblx0XHQvLyBJbml0aWFsbHksIHRyeSBhbmQgdXNlIHRoZSBwcm92aWRlZC9zdXBwb3J0ZWQgWEhSIG1vZGU6XG5cdFx0dmFyIHByZWZlclhIUiA9IHRoaXMucHJlZmVyWEhSO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9hdmFpbGFibGVMb2FkZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgbG9hZGVyID0gdGhpcy5fYXZhaWxhYmxlTG9hZGVyc1tpXTtcblx0XHRcdGlmIChsb2FkZXIgJiYgbG9hZGVyLmNhbkxvYWRJdGVtKGl0ZW0pKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgbG9hZGVyKGl0ZW0sIHByZWZlclhIUik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gVE9ETzogTG9nIGVycm9yIChyZXF1aXJlcyBjcmVhdGVqcy5sb2cpXG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIExvYWQgdGhlIG5leHQgaXRlbSBpbiB0aGUgcXVldWUuIElmIHRoZSBxdWV1ZSBpcyBlbXB0eSAoYWxsIGl0ZW1zIGhhdmUgYmVlbiBsb2FkZWQpLCB0aGVuIHRoZSBjb21wbGV0ZSBldmVudFxuXHQgKiBpcyBwcm9jZXNzZWQuIFRoZSBxdWV1ZSB3aWxsIFwiZmlsbCB1cFwiIGFueSBlbXB0eSBzbG90cywgdXAgdG8gdGhlIG1heCBjb25uZWN0aW9uIHNwZWNpZmllZCB1c2luZ1xuXHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUuc2V0TWF4Q29ubmVjdGlvbnNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLiBUaGUgb25seSBleGNlcHRpb24gaXMgc2NyaXB0cyB0aGF0IGFyZSBsb2FkZWRcblx0ICogdXNpbmcgdGFncywgd2hpY2ggaGF2ZSB0byBiZSBsb2FkZWQgb25lIGF0IGEgdGltZSB0byBtYWludGFpbiBsb2FkIG9yZGVyLlxuXHQgKiBAbWV0aG9kIF9sb2FkTmV4dFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fbG9hZE5leHQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3BhdXNlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9ubHkgZGlzcGF0Y2ggbG9hZHN0YXJ0IGV2ZW50IHdoZW4gdGhlIGZpcnN0IGZpbGUgaXMgbG9hZGVkLlxuXHRcdGlmICghdGhpcy5fbG9hZFN0YXJ0V2FzRGlzcGF0Y2hlZCkge1xuXHRcdFx0dGhpcy5fc2VuZExvYWRTdGFydCgpO1xuXHRcdFx0dGhpcy5fbG9hZFN0YXJ0V2FzRGlzcGF0Y2hlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHF1ZXVlIGhhcyBjb21wbGV0ZWQuXG5cdFx0aWYgKHRoaXMuX251bUl0ZW1zID09IHRoaXMuX251bUl0ZW1zTG9hZGVkKSB7XG5cdFx0XHR0aGlzLmxvYWRlZCA9IHRydWU7XG5cdFx0XHR0aGlzLl9zZW5kQ29tcGxldGUoKTtcblxuXHRcdFx0Ly8gTG9hZCB0aGUgbmV4dCBxdWV1ZSwgaWYgaXQgaGFzIGJlZW4gZGVmaW5lZC5cblx0XHRcdGlmICh0aGlzLm5leHQgJiYgdGhpcy5uZXh0LmxvYWQpIHtcblx0XHRcdFx0dGhpcy5uZXh0LmxvYWQoKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5sb2FkZWQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBNdXN0IGl0ZXJhdGUgZm9yd2FyZHMgdG8gbG9hZCBpbiB0aGUgcmlnaHQgb3JkZXIuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sb2FkUXVldWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLl9jdXJyZW50TG9hZHMubGVuZ3RoID49IHRoaXMuX21heENvbm5lY3Rpb25zKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGxvYWRlciA9IHRoaXMuX2xvYWRRdWV1ZVtpXTtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBiZSBvbmx5IGxvYWRpbmcgb25lIHRhZy1zY3JpcHQgYXQgYSB0aW1lOlxuXHRcdFx0Ly8gTm90ZTogbWFpbnRhaW5PcmRlciBpdGVtcyBkb24ndCBkbyBhbnl0aGluZyBoZXJlIGJlY2F1c2Ugd2UgY2FuIGhvbGQgb250byB0aGVpciBsb2FkZWQgdmFsdWVcblx0XHRcdGlmICghdGhpcy5fY2FuU3RhcnRMb2FkKGxvYWRlcikpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9sb2FkUXVldWUuc3BsaWNlKGksIDEpO1xuXHRcdFx0aS0tO1xuXHRcdFx0dGhpcy5fbG9hZEl0ZW0obG9hZGVyKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2luIGxvYWRpbmcgYW4gaXRlbS4gRXZlbnQgbGlzdGVuZXJzIGFyZSBub3QgYWRkZWQgdG8gdGhlIGxvYWRlcnMgdW50aWwgdGhlIGxvYWQgc3RhcnRzLlxuXHQgKiBAbWV0aG9kIF9sb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXIgVGhlIGxvYWRlciBpbnN0YW5jZSB0byBzdGFydC4gQ3VycmVudGx5LCB0aGlzIHdpbGwgYmUgYW4gWEhSTG9hZGVyIG9yIFRhZ0xvYWRlci5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2xvYWRJdGVtID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdGxvYWRlci5vbihcImZpbGVsb2FkXCIsIHRoaXMuX2hhbmRsZUZpbGVMb2FkLCB0aGlzKTtcblx0XHRsb2FkZXIub24oXCJwcm9ncmVzc1wiLCB0aGlzLl9oYW5kbGVQcm9ncmVzcywgdGhpcyk7XG5cdFx0bG9hZGVyLm9uKFwiY29tcGxldGVcIiwgdGhpcy5faGFuZGxlRmlsZUNvbXBsZXRlLCB0aGlzKTtcblx0XHRsb2FkZXIub24oXCJlcnJvclwiLCB0aGlzLl9oYW5kbGVFcnJvciwgdGhpcyk7XG5cdFx0bG9hZGVyLm9uKFwiZmlsZWVycm9yXCIsIHRoaXMuX2hhbmRsZUZpbGVFcnJvciwgdGhpcyk7XG5cdFx0dGhpcy5fY3VycmVudExvYWRzLnB1c2gobG9hZGVyKTtcblx0XHR0aGlzLl9zZW5kRmlsZVN0YXJ0KGxvYWRlci5nZXRJdGVtKCkpO1xuXHRcdGxvYWRlci5sb2FkKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBjYWxsYmFjayB0aGF0IGlzIGZpcmVkIHdoZW4gYSBsb2FkZXIgbG9hZHMgYSBmaWxlLiBUaGlzIGVuYWJsZXMgbG9hZGVycyBsaWtlIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHRvIG1haW50YWluIGludGVybmFsIHF1ZXVlcywgYnV0IGZvciB0aGlzIHF1ZXVlIHRvIGRpc3BhdGNoIHRoZSB7eyNjcm9zc0xpbmsgXCJmaWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudHMuXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBmcm9tIHRoZSBsb2FkZXIuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5faGFuZGxlRmlsZUxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC50YXJnZXQgPSBudWxsO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBjYWxsYmFjayB0aGF0IGlzIGZpcmVkIHdoZW4gYSBsb2FkZXIgZW5jb3VudGVycyBhbiBlcnJvciBmcm9tIGFuIGludGVybmFsIGZpbGUgbG9hZCBvcGVyYXRpb24uIFRoaXMgZW5hYmxlc1xuXHQgKiBsb2FkZXJzIGxpa2UgTVxuXHQgKiBAcGFyYW0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZUZpbGVFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiRklMRV9MT0FEX0VSUk9SXCIsIG51bGwsIGV2ZW50Lml0ZW0pO1xuXHRcdHRoaXMuX3NlbmRFcnJvcihuZXdFdmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBjYWxsYmFjayB0aGF0IGlzIGZpcmVkIHdoZW4gYSBsb2FkZXIgZW5jb3VudGVycyBhbiBlcnJvci4gVGhlIHF1ZXVlIHdpbGwgY29udGludWUgbG9hZGluZyB1bmxlc3Mge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3N0b3BPbkVycm9yOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGlzIHNldCB0byBgdHJ1ZWAuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUVycm9yXG5cdCAqIEBwYXJhbSB7RXJyb3JFdmVudH0gZXZlbnQgVGhlIGVycm9yIGV2ZW50LCBjb250YWluaW5nIHJlbGV2YW50IGVycm9yIGluZm9ybWF0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgbG9hZGVyID0gZXZlbnQudGFyZ2V0O1xuXHRcdHRoaXMuX251bUl0ZW1zTG9hZGVkKys7XG5cblx0XHR0aGlzLl9maW5pc2hPcmRlcmVkSXRlbShsb2FkZXIsIHRydWUpO1xuXHRcdHRoaXMuX3VwZGF0ZVByb2dyZXNzKCk7XG5cblx0XHR2YXIgbmV3RXZlbnQgPSBuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIkZJTEVfTE9BRF9FUlJPUlwiLCBudWxsLCBsb2FkZXIuZ2V0SXRlbSgpKTtcblx0XHQvLyBUT0RPOiBQcm9wYWdhdGUgYWN0dWFsIGVycm9yIG1lc3NhZ2UuXG5cblx0XHR0aGlzLl9zZW5kRXJyb3IobmV3RXZlbnQpO1xuXG5cdFx0aWYgKCF0aGlzLnN0b3BPbkVycm9yKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVMb2FkSXRlbShsb2FkZXIpO1xuXHRcdFx0dGhpcy5fY2xlYW5Mb2FkSXRlbShsb2FkZXIpO1xuXHRcdFx0dGhpcy5fbG9hZE5leHQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZXRQYXVzZWQodHJ1ZSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbiBpdGVtIGhhcyBmaW5pc2hlZCBsb2FkaW5nLiBXZSBjYW4gYXNzdW1lIHRoYXQgaXQgaXMgdG90YWxseSBsb2FkZWQsIGhhcyBiZWVuIHBhcnNlZCBmb3IgaW1tZWRpYXRlIHVzZSwgYW5kXG5cdCAqIGlzIGF2YWlsYWJsZSBhcyB0aGUgXCJyZXN1bHRcIiBwcm9wZXJ0eSBvbiB0aGUgbG9hZCBpdGVtLiBUaGUgcmF3IHRleHQgcmVzdWx0IGZvciBhIHBhcnNlZCBpdGVtIChzdWNoIGFzIEpTT04sIFhNTCxcblx0ICogQ1NTLCBKYXZhU2NyaXB0LCBldGMpIGlzIGF2YWlsYWJsZSBhcyB0aGUgXCJyYXdSZXN1bHRcIiBwcm9wZXJ0eSwgYW5kIGNhbiBhbHNvIGJlIGxvb2tlZCB1cCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZ2V0UmVzdWx0XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVGaWxlQ29tcGxldGVcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IG9iamVjdCBmcm9tIHRoZSBsb2FkZXIuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVGaWxlQ29tcGxldGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgbG9hZGVyID0gZXZlbnQudGFyZ2V0O1xuXHRcdHZhciBpdGVtID0gbG9hZGVyLmdldEl0ZW0oKTtcblxuXHRcdHZhciByZXN1bHQgPSBsb2FkZXIuZ2V0UmVzdWx0KCk7XG5cdFx0dGhpcy5fbG9hZGVkUmVzdWx0c1tpdGVtLmlkXSA9IHJlc3VsdDtcblx0XHR2YXIgcmF3UmVzdWx0ID0gbG9hZGVyLmdldFJlc3VsdCh0cnVlKTtcblx0XHRpZiAocmF3UmVzdWx0ICE9IG51bGwgJiYgcmF3UmVzdWx0ICE9PSByZXN1bHQpIHtcblx0XHRcdHRoaXMuX2xvYWRlZFJhd1Jlc3VsdHNbaXRlbS5pZF0gPSByYXdSZXN1bHQ7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2F2ZUxvYWRlZEl0ZW1zKGxvYWRlcik7XG5cblx0XHQvLyBSZW1vdmUgdGhlIGxvYWQgaXRlbVxuXHRcdHRoaXMuX3JlbW92ZUxvYWRJdGVtKGxvYWRlcik7XG5cblx0XHRpZiAoIXRoaXMuX2ZpbmlzaE9yZGVyZWRJdGVtKGxvYWRlcikpIHtcblx0XHRcdC8vIFRoZSBpdGVtIHdhcyBOT1QgbWFuYWdlZCwgc28gcHJvY2VzcyBpdCBub3dcblx0XHRcdHRoaXMuX3Byb2Nlc3NGaW5pc2hlZExvYWQoaXRlbSwgbG9hZGVyKTtcblx0XHR9XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgbG9hZCBpdGVtXG5cdFx0dGhpcy5fY2xlYW5Mb2FkSXRlbShsb2FkZXIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTb21lIGxvYWRlcnMgbWlnaHQgbG9hZCBhZGRpdGlvbmFsIGNvbnRlbnQsIG90aGVyIHRoYW4gdGhlIGl0ZW0gdGhleSB3ZXJlIHBhc3NlZCAoc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fSkuXG5cdCAqIEFueSBpdGVtcyBleHBvc2VkIGJ5IHRoZSBsb2FkZXIgdXNpbmcge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvZ2V0TG9hZEl0ZW1zXCJ9fXt7L2Nyb3NzTGlua319IGFyZSBhZGRlZCB0byB0aGVcblx0ICogTG9hZFF1ZXVlJ3MgbG9vay11cHMsIGluY2x1ZGluZyB7eyNjcm9zc0xpbmsgXCJnZXRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJnZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kcy5cblx0ICogQG1ldGhvZCBfc2F2ZUxvYWRlZEl0ZW1zXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5fc2F2ZUxvYWRlZEl0ZW1zID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdC8vIFRPRE86IE5vdCBzdXJlIGhvdyB0byBoYW5kbGUgdGhpcy4gV291bGQgYmUgbmljZSB0byBleHBvc2UgdGhlIGl0ZW1zLlxuXHRcdC8vIExvYWRlcnMgbWF5IGxvYWQgc3ViLWl0ZW1zLiBUaGlzIGFkZHMgdGhlbSB0byB0aGlzIHF1ZXVlXG5cdFx0dmFyIGxpc3QgPSBsb2FkZXIuZ2V0TG9hZGVkSXRlbXMoKTtcblx0XHRpZiAobGlzdCA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBsaXN0W2ldLml0ZW07XG5cblx0XHRcdC8vIFN0b3JlIGl0ZW0gbG9va3Vwc1xuXHRcdFx0dGhpcy5fbG9hZEl0ZW1zQnlTcmNbaXRlbS5zcmNdID0gaXRlbTtcblx0XHRcdHRoaXMuX2xvYWRJdGVtc0J5SWRbaXRlbS5pZF0gPSBpdGVtO1xuXG5cdFx0XHQvLyBTdG9yZSBsb2FkZWQgY29udGVudFxuXHRcdFx0dGhpcy5fbG9hZGVkUmVzdWx0c1tpdGVtLmlkXSA9IGxpc3RbaV0ucmVzdWx0O1xuXHRcdFx0dGhpcy5fbG9hZGVkUmF3UmVzdWx0c1tpdGVtLmlkXSA9IGxpc3RbaV0ucmF3UmVzdWx0O1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRmxhZyBhbiBpdGVtIGFzIGZpbmlzaGVkLiBJZiB0aGUgaXRlbSdzIG9yZGVyIGlzIGJlaW5nIG1hbmFnZWQsIHRoZW4gZW5zdXJlIHRoYXQgaXQgaXMgYWxsb3dlZCB0byBmaW5pc2gsIGFuZCBpZlxuXHQgKiBzbywgdHJpZ2dlciBwcmlvciBpdGVtcyB0byB0cmlnZ2VyIGFzIHdlbGwuXG5cdCAqIEBtZXRob2QgX2ZpbmlzaE9yZGVyZWRJdGVtXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGxvYWRGYWlsZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIGl0ZW0ncyBvcmRlciBpcyBiZWluZyBtYW5hZ2VkLiBUaGlzIGFsbG93cyB0aGUgY2FsbGVyIHRvIHRha2UgYW4gYWx0ZXJuYXRlXG5cdCAqIGJlaGF2aW91ciBpZiBpdCBpcy5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2ZpbmlzaE9yZGVyZWRJdGVtID0gZnVuY3Rpb24gKGxvYWRlciwgbG9hZEZhaWxlZCkge1xuXHRcdHZhciBpdGVtID0gbG9hZGVyLmdldEl0ZW0oKTtcblxuXHRcdGlmICgodGhpcy5tYWludGFpblNjcmlwdE9yZGVyICYmIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5UeXBlcy5KQVZBU0NSSVBUKVxuXHRcdFx0XHR8fCBpdGVtLm1haW50YWluT3JkZXIpIHtcblxuXHRcdFx0Ly9UT0RPOiBFdmFsdWF0ZSByZW1vdmFsIG9mIHRoZSBfY3VycmVudGx5TG9hZGluZ1NjcmlwdFxuXHRcdFx0aWYgKGxvYWRlciBpbnN0YW5jZW9mIGNyZWF0ZWpzLkphdmFTY3JpcHRMb2FkZXIpIHtcblx0XHRcdFx0dGhpcy5fY3VycmVudGx5TG9hZGluZ1NjcmlwdCA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaW5kZXggPSBjcmVhdGVqcy5pbmRleE9mKHRoaXMuX3NjcmlwdE9yZGVyLCBpdGVtKTtcblx0XHRcdGlmIChpbmRleCA9PSAtMSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IC8vIFRoaXMgbG9hZGVyIG5vIGxvbmdlciBleGlzdHNcblx0XHRcdHRoaXMuX2xvYWRlZFNjcmlwdHNbaW5kZXhdID0gKGxvYWRGYWlsZWQgPT09IHRydWUpID8gdHJ1ZSA6IGl0ZW07XG5cblx0XHRcdHRoaXMuX2NoZWNrU2NyaXB0TG9hZE9yZGVyKCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuc3VyZSB0aGUgc2NyaXB0cyBsb2FkIGFuZCBkaXNwYXRjaCBpbiB0aGUgY29ycmVjdCBvcmRlci4gV2hlbiB1c2luZyBYSFIsIHNjcmlwdHMgYXJlIHN0b3JlZCBpbiBhbiBhcnJheSBpbiB0aGVcblx0ICogb3JkZXIgdGhleSB3ZXJlIGFkZGVkLCBidXQgd2l0aCBhIFwibnVsbFwiIHZhbHVlLiBXaGVuIHRoZXkgYXJlIGNvbXBsZXRlZCwgdGhlIHZhbHVlIGlzIHNldCB0byB0aGUgbG9hZCBpdGVtLFxuXHQgKiBhbmQgdGhlbiB3aGVuIHRoZXkgYXJlIHByb2Nlc3NlZCBhbmQgZGlzcGF0Y2hlZCwgdGhlIHZhbHVlIGlzIHNldCB0byBgdHJ1ZWAuIFRoaXMgbWV0aG9kIHNpbXBseVxuXHQgKiBpdGVyYXRlcyB0aGUgYXJyYXksIGFuZCBlbnN1cmVzIHRoYXQgYW55IGxvYWRlZCBpdGVtcyB0aGF0IGFyZSBub3QgcHJlY2VkZWQgYnkgYSBgbnVsbGAgdmFsdWUgYXJlXG5cdCAqIGRpc3BhdGNoZWQuXG5cdCAqIEBtZXRob2QgX2NoZWNrU2NyaXB0TG9hZE9yZGVyXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jaGVja1NjcmlwdExvYWRPcmRlciA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbCA9IHRoaXMuX2xvYWRlZFNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gdGhpcy5fbG9hZGVkU2NyaXB0c1tpXTtcblx0XHRcdGlmIChpdGVtID09PSBudWxsKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fSAvLyBUaGlzIGlzIHN0aWxsIGxvYWRpbmcuIERvIG5vdCBwcm9jZXNzIGZ1cnRoZXIuXG5cdFx0XHRpZiAoaXRlbSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gLy8gVGhpcyBoYXMgY29tcGxldGVkLCBhbmQgYmVlbiBwcm9jZXNzZWQuIE1vdmUgb24uXG5cblx0XHRcdHZhciBsb2FkSXRlbSA9IHRoaXMuX2xvYWRlZFJlc3VsdHNbaXRlbS5pZF07XG5cdFx0XHRpZiAoaXRlbS50eXBlID09IGNyZWF0ZWpzLlR5cGVzLkpBVkFTQ1JJUFQpIHtcblx0XHRcdFx0Ly8gQXBwZW5kIHNjcmlwdCB0YWdzIHRvIHRoZSBoZWFkIGF1dG9tYXRpY2FsbHkuXG5cdFx0XHRcdGNyZWF0ZWpzLkRvbVV0aWxzLmFwcGVuZFRvSGVhZChsb2FkSXRlbSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBsb2FkZXIgPSBpdGVtLl9sb2FkZXI7XG5cdFx0XHR0aGlzLl9wcm9jZXNzRmluaXNoZWRMb2FkKGl0ZW0sIGxvYWRlcik7XG5cdFx0XHR0aGlzLl9sb2FkZWRTY3JpcHRzW2ldID0gdHJ1ZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEEgZmlsZSBoYXMgY29tcGxldGVkIGxvYWRpbmcsIGFuZCB0aGUgTG9hZFF1ZXVlIGNhbiBtb3ZlIG9uLiBUaGlzIHRyaWdnZXJzIHRoZSBjb21wbGV0ZSBldmVudCwgYW5kIGtpY2stc3RhcnRzXG5cdCAqIHRoZSBuZXh0IGl0ZW0uXG5cdCAqIEBtZXRob2QgX3Byb2Nlc3NGaW5pc2hlZExvYWRcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW1cblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3Byb2Nlc3NGaW5pc2hlZExvYWQgPSBmdW5jdGlvbiAoaXRlbSwgbG9hZGVyKSB7XG5cdFx0dGhpcy5fbnVtSXRlbXNMb2FkZWQrKztcblxuXHRcdC8vIFNpbmNlIExvYWRRdWV1ZSBuZWVkcyBtYWludGFpbiBvcmRlciwgd2UgY2FuJ3QgYXBwZW5kIHNjcmlwdHMgaW4gdGhlIGxvYWRlci5cblx0XHQvLyBTbyB3ZSBkbyBpdCBoZXJlIGluc3RlYWQuIE9yIGluIF9jaGVja1NjcmlwdExvYWRPcmRlcigpO1xuXHRcdGlmICghdGhpcy5tYWludGFpblNjcmlwdE9yZGVyICYmIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5UeXBlcy5KQVZBU0NSSVBUKSB7XG5cdFx0XHR2YXIgdGFnID0gbG9hZGVyLmdldFRhZygpO1xuXHRcdFx0Y3JlYXRlanMuRG9tVXRpbHMuYXBwZW5kVG9IZWFkKHRhZyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlUHJvZ3Jlc3MoKTtcblx0XHR0aGlzLl9zZW5kRmlsZUNvbXBsZXRlKGl0ZW0sIGxvYWRlcik7XG5cdFx0dGhpcy5fbG9hZE5leHQoKTtcblx0fTtcblxuXHQvKipcblx0ICogRW5zdXJlIGl0ZW1zIHdpdGggYG1haW50YWluT3JkZXI9dHJ1ZWAgdGhhdCBhcmUgYmVmb3JlIHRoZSBzcGVjaWZpZWQgaXRlbSBoYXZlIGxvYWRlZC4gVGhpcyBvbmx5IGFwcGxpZXMgdG9cblx0ICogSmF2YVNjcmlwdCBpdGVtcyB0aGF0IGFyZSBiZWluZyBsb2FkZWQgd2l0aCBhIFRhZ0xvYWRlciwgc2luY2UgdGhleSBoYXZlIHRvIGJlIGxvYWRlZCBhbmQgY29tcGxldGVkIDxzdHJvbmc+YmVmb3JlPC9zdHJvbmc+XG5cdCAqIHRoZSBzY3JpcHQgY2FuIGV2ZW4gYmUgc3RhcnRlZCwgc2luY2UgaXQgZXhpc3QgaW4gdGhlIERPTSB3aGlsZSBsb2FkaW5nLlxuXHQgKiBAbWV0aG9kIF9jYW5TdGFydExvYWRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyIFRoZSBsb2FkZXIgZm9yIHRoZSBpdGVtXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGl0ZW0gY2FuIHN0YXJ0IGEgbG9hZCBvciBub3QuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jYW5TdGFydExvYWQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0aWYgKCF0aGlzLm1haW50YWluU2NyaXB0T3JkZXIgfHwgbG9hZGVyLnByZWZlclhIUikge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHZhciBpdGVtID0gbG9hZGVyLmdldEl0ZW0oKTtcblx0XHRpZiAoaXRlbS50eXBlICE9IGNyZWF0ZWpzLlR5cGVzLkpBVkFTQ1JJUFQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRpZiAodGhpcy5fY3VycmVudGx5TG9hZGluZ1NjcmlwdCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciBpbmRleCA9IHRoaXMuX3NjcmlwdE9yZGVyLmluZGV4T2YoaXRlbSk7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHdoaWxlIChpIDwgaW5kZXgpIHtcblx0XHRcdHZhciBjaGVja0l0ZW0gPSB0aGlzLl9sb2FkZWRTY3JpcHRzW2ldO1xuXHRcdFx0aWYgKGNoZWNrSXRlbSA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGkrKztcblx0XHR9XG5cdFx0dGhpcy5fY3VycmVudGx5TG9hZGluZ1NjcmlwdCA9IHRydWU7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEEgbG9hZCBpdGVtIGlzIGNvbXBsZXRlZCBvciB3YXMgY2FuY2VsZWQsIGFuZCBuZWVkcyB0byBiZSByZW1vdmVkIGZyb20gdGhlIExvYWRRdWV1ZS5cblx0ICogQG1ldGhvZCBfcmVtb3ZlTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyIEEgbG9hZGVyIGluc3RhbmNlIHRvIHJlbW92ZS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX3JlbW92ZUxvYWRJdGVtID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdHZhciBsID0gdGhpcy5fY3VycmVudExvYWRzLmxlbmd0aDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuX2N1cnJlbnRMb2Fkc1tpXSA9PSBsb2FkZXIpIHtcblx0XHRcdFx0dGhpcy5fY3VycmVudExvYWRzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgdW5uZWVkZWQgcmVmZXJlbmNlcyBmcm9tIGEgbG9hZGVyLlxuXHQgKlxuXHQgKiBAcGFyYW0gbG9hZGVyXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jbGVhbkxvYWRJdGVtID0gZnVuY3Rpb24obG9hZGVyKSB7XG5cdFx0dmFyIGl0ZW0gPSBsb2FkZXIuZ2V0SXRlbSgpO1xuXHRcdGlmIChpdGVtKSB7XG5cdFx0XHRkZWxldGUgaXRlbS5fbG9hZGVyO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBbiBpdGVtIGhhcyBkaXNwYXRjaGVkIHByb2dyZXNzLiBQcm9wYWdhdGUgdGhhdCBwcm9ncmVzcywgYW5kIHVwZGF0ZSB0aGUgTG9hZFF1ZXVlJ3Mgb3ZlcmFsbCBwcm9ncmVzcy5cblx0ICogQG1ldGhvZCBfaGFuZGxlUHJvZ3Jlc3Ncblx0ICogQHBhcmFtIHtQcm9ncmVzc0V2ZW50fSBldmVudCBUaGUgcHJvZ3Jlc3MgZXZlbnQgZnJvbSB0aGUgaXRlbS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVByb2dyZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIGxvYWRlciA9IGV2ZW50LnRhcmdldDtcblx0XHR0aGlzLl9zZW5kRmlsZVByb2dyZXNzKGxvYWRlci5nZXRJdGVtKCksIGxvYWRlci5wcm9ncmVzcyk7XG5cdFx0dGhpcy5fdXBkYXRlUHJvZ3Jlc3MoKTtcblx0fTtcblxuXHQvKipcblx0ICogT3ZlcmFsbCBwcm9ncmVzcyBoYXMgY2hhbmdlZCwgc28gZGV0ZXJtaW5lIHRoZSBuZXcgcHJvZ3Jlc3MgYW1vdW50IGFuZCBkaXNwYXRjaCBpdC4gVGhpcyBjaGFuZ2VzIGFueSB0aW1lIGFuXG5cdCAqIGl0ZW0gZGlzcGF0Y2hlcyBwcm9ncmVzcyBvciBjb21wbGV0ZXMuIE5vdGUgdGhhdCBzaW5jZSB3ZSBkb24ndCBhbHdheXMga25vdyB0aGUgYWN0dWFsIGZpbGVzaXplIG9mIGl0ZW1zIGJlZm9yZVxuXHQgKiB0aGV5IGFyZSBsb2FkZWQuIEluIHRoaXMgY2FzZSwgd2UgZGVmaW5lIGEgXCJzbG90XCIgZm9yIGVhY2ggaXRlbSAoMSBpdGVtIGluIDEwIHdvdWxkIGdldCAxMCUpLCBhbmQgdGhlbiBhcHBlbmRcblx0ICogbG9hZGVkIHByb2dyZXNzIG9uIHRvcCBvZiB0aGUgYWxyZWFkeS1sb2FkZWQgaXRlbXMuXG5cdCAqXG5cdCAqIEZvciBleGFtcGxlLCBpZiA1LzEwIGl0ZW1zIGhhdmUgbG9hZGVkLCBhbmQgaXRlbSA2IGlzIDIwJSBsb2FkZWQsIHRoZSB0b3RhbCBwcm9ncmVzcyB3b3VsZCBiZTpcblx0ICogPHVsPlxuXHQgKiAgICAgIDxsaT41LzEwIG9mIHRoZSBpdGVtcyBpbiB0aGUgcXVldWUgKDUwJSk8L2xpPlxuXHQgKiAgICAgIDxsaT5wbHVzIDIwJSBvZiBpdGVtIDYncyBzbG90ICgyJSk8L2xpPlxuXHQgKiAgICAgIDxsaT5lcXVhbHMgNTIlPC9saT5cblx0ICogPC91bD5cblx0ICogQG1ldGhvZCBfdXBkYXRlUHJvZ3Jlc3Ncblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX3VwZGF0ZVByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBsb2FkZWQgPSB0aGlzLl9udW1JdGVtc0xvYWRlZCAvIHRoaXMuX251bUl0ZW1zOyAvLyBGdWxseSBMb2FkZWQgUHJvZ3Jlc3Ncblx0XHR2YXIgcmVtYWluaW5nID0gdGhpcy5fbnVtSXRlbXMgLSB0aGlzLl9udW1JdGVtc0xvYWRlZDtcblx0XHRpZiAocmVtYWluaW5nID4gMCkge1xuXHRcdFx0dmFyIGNodW5rID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY3VycmVudExvYWRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjaHVuayArPSB0aGlzLl9jdXJyZW50TG9hZHNbaV0ucHJvZ3Jlc3M7XG5cdFx0XHR9XG5cdFx0XHRsb2FkZWQgKz0gKGNodW5rIC8gcmVtYWluaW5nKSAqIChyZW1haW5pbmcgLyB0aGlzLl9udW1JdGVtcyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX2xhc3RQcm9ncmVzcyAhPSBsb2FkZWQpIHtcblx0XHRcdHRoaXMuX3NlbmRQcm9ncmVzcyhsb2FkZWQpO1xuXHRcdFx0dGhpcy5fbGFzdFByb2dyZXNzID0gbG9hZGVkO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ2xlYW4gb3V0IGl0ZW0gcmVzdWx0cywgdG8gZnJlZSB0aGVtIGZyb20gbWVtb3J5LiBNYWlubHksIHRoZSBsb2FkZWQgaXRlbSBhbmQgcmVzdWx0cyBhcmUgY2xlYXJlZCBmcm9tIGludGVybmFsXG5cdCAqIGhhc2hlcy5cblx0ICogQG1ldGhvZCBfZGlzcG9zZUl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIGl0ZW0gdGhhdCB3YXMgcGFzc2VkIGluIGZvciBwcmVsb2FkaW5nLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZGlzcG9zZUl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdGRlbGV0ZSB0aGlzLl9sb2FkZWRSZXN1bHRzW2l0ZW0uaWRdO1xuXHRcdGRlbGV0ZSB0aGlzLl9sb2FkZWRSYXdSZXN1bHRzW2l0ZW0uaWRdO1xuXHRcdGRlbGV0ZSB0aGlzLl9sb2FkSXRlbXNCeUlkW2l0ZW0uaWRdO1xuXHRcdGRlbGV0ZSB0aGlzLl9sb2FkSXRlbXNCeVNyY1tpdGVtLnNyY107XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoIGEgXCJmaWxlcHJvZ3Jlc3NcIiB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS4gUGxlYXNlIHNlZSB0aGUgTG9hZFF1ZXVlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlcHJvZ3Jlc3M6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgZm9yIGRldGFpbHMgb24gdGhlIGV2ZW50IHBheWxvYWQuXG5cdCAqIEBtZXRob2QgX3NlbmRGaWxlUHJvZ3Jlc3Ncblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIGl0ZW0gdGhhdCBpcyBiZWluZyBsb2FkZWQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwcm9ncmVzcyBUaGUgYW1vdW50IHRoZSBpdGVtIGhhcyBiZWVuIGxvYWRlZCAoYmV0d2VlbiAwIGFuZCAxKS5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2VuZEZpbGVQcm9ncmVzcyA9IGZ1bmN0aW9uIChpdGVtLCBwcm9ncmVzcykge1xuXHRcdGlmICh0aGlzLl9pc0NhbmNlbGVkKCkgfHwgdGhpcy5fcGF1c2VkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICghdGhpcy5oYXNFdmVudExpc3RlbmVyKFwiZmlsZXByb2dyZXNzXCIpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly9MTTogUmV3b3JrIFByb2dyZXNzRXZlbnQgdG8gc3VwcG9ydCB0aGlzP1xuXHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVwcm9ncmVzc1wiKTtcblx0XHRldmVudC5wcm9ncmVzcyA9IHByb2dyZXNzO1xuXHRcdGV2ZW50LmxvYWRlZCA9IHByb2dyZXNzO1xuXHRcdGV2ZW50LnRvdGFsID0gMTtcblx0XHRldmVudC5pdGVtID0gaXRlbTtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoIGEgZmlsZWxvYWQge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBmb3Jcblx0ICogZGV0YWlscyBvbiB0aGUgZXZlbnQgcGF5bG9hZC5cblx0ICogQG1ldGhvZCBfc2VuZEZpbGVDb21wbGV0ZVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtT2JqZWN0fSBpdGVtIFRoZSBpdGVtIHRoYXQgaXMgYmVpbmcgbG9hZGVkLlxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2VuZEZpbGVDb21wbGV0ZSA9IGZ1bmN0aW9uIChpdGVtLCBsb2FkZXIpIHtcblx0XHRpZiAodGhpcy5faXNDYW5jZWxlZCgpIHx8IHRoaXMuX3BhdXNlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVsb2FkXCIpO1xuXHRcdGV2ZW50LmxvYWRlciA9IGxvYWRlcjtcblx0XHRldmVudC5pdGVtID0gaXRlbTtcblx0XHRldmVudC5yZXN1bHQgPSB0aGlzLl9sb2FkZWRSZXN1bHRzW2l0ZW0uaWRdO1xuXHRcdGV2ZW50LnJhd1Jlc3VsdCA9IHRoaXMuX2xvYWRlZFJhd1Jlc3VsdHNbaXRlbS5pZF07XG5cblx0XHQvLyBUaGlzIGNhbGxzIGEgaGFuZGxlciBzcGVjaWZpZWQgb24gdGhlIGFjdHVhbCBsb2FkIGl0ZW0uIEN1cnJlbnRseSwgdGhlIFNvdW5kSlMgcGx1Z2luIHVzZXMgdGhpcy5cblx0XHRpZiAoaXRlbS5jb21wbGV0ZUhhbmRsZXIpIHtcblx0XHRcdGl0ZW0uY29tcGxldGVIYW5kbGVyKGV2ZW50KTtcblx0XHR9XG5cblx0XHR0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJmaWxlbG9hZFwiKSAmJiB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhIGZpbGVzdGFydCB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSBpbW1lZGlhdGVseSBiZWZvcmUgYSBmaWxlIHN0YXJ0cyB0byBsb2FkLiBQbGVhc2Ugc2VlXG5cdCAqIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZXN0YXJ0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IGZvciBkZXRhaWxzIG9uIHRoZSBldmVudCBwYXlsb2FkLlxuXHQgKiBAbWV0aG9kIF9zZW5kRmlsZVN0YXJ0XG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBpdGVtIHRoYXQgaXMgYmVpbmcgbG9hZGVkLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZW5kRmlsZVN0YXJ0ID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJmaWxlc3RhcnRcIik7XG5cdFx0ZXZlbnQuaXRlbSA9IGl0ZW07XG5cdFx0dGhpcy5oYXNFdmVudExpc3RlbmVyKFwiZmlsZXN0YXJ0XCIpICYmIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbUHJlbG9hZEpTIExvYWRRdWV1ZV1cIjtcblx0fTtcblxuXHRjcmVhdGVqcy5Mb2FkUXVldWUgPSBjcmVhdGVqcy5wcm9tb3RlKExvYWRRdWV1ZSwgXCJBYnN0cmFjdExvYWRlclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUZXh0TG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG53aW5kb3cuY3JlYXRlanMgPSB3aW5kb3cuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgVGV4dCBmaWxlcy5cblx0ICogQGNsYXNzIFRleHRMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gVGV4dExvYWRlcihsb2FkSXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHRydWUsIGNyZWF0ZWpzLlR5cGVzLlRFWFQpO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFRleHRMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBUZXh0TG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBsb2FkcyBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlIHt7I2Nyb3NzTGluayBcIlR5cGVzL1RFWFQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIGJ1dCBpcyBhbHNvIHRoZSBkZWZhdWx0IGxvYWRlciBpZiBhIGZpbGUgdHlwZSBjYW4gbm90IGJlIGRldGVybWluZWQuXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuVHlwZXMuVEVYVDtcblx0fTtcblxuXHRjcmVhdGVqcy5UZXh0TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShUZXh0TG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQmluYXJ5TG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG53aW5kb3cuY3JlYXRlanMgPSB3aW5kb3cuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgYmluYXJ5IGZpbGVzLiBUaGlzIGlzIHVzZWZ1bCBmb3IgbG9hZGluZyB3ZWIgYXVkaW8sIG9yIGNvbnRlbnQgdGhhdCByZXF1aXJlcyBhbiBBcnJheUJ1ZmZlci5cblx0ICogQGNsYXNzIEJpbmFyeUxvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBCaW5hcnlMb2FkZXIobG9hZEl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCB0cnVlLCBjcmVhdGVqcy5UeXBlcy5CSU5BUlkpO1xuXHRcdHRoaXMub24oXCJpbml0aWFsaXplXCIsIHRoaXMuX3VwZGF0ZVhIUiwgdGhpcyk7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQmluYXJ5TG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gQmluYXJ5TG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiVHlwZXMvQklOQVJZOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuVHlwZXMuQklOQVJZO1xuXHR9O1xuXG5cdC8vIHByaXZhdGUgbWV0aG9kc1xuXHQvKipcblx0ICogQmVmb3JlIHRoZSBpdGVtIGxvYWRzLCBzZXQgdGhlIHJlc3BvbnNlIHR5cGUgdG8gXCJhcnJheWJ1ZmZlclwiXG5cdCAqIEBwcm9wZXJ0eSBfdXBkYXRlWEhSXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl91cGRhdGVYSFIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC5sb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7XG5cdH07XG5cblx0Y3JlYXRlanMuQmluYXJ5TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShCaW5hcnlMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBDU1NMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbndpbmRvdy5jcmVhdGVqcyA9IHdpbmRvdy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBDU1MgZmlsZXMuXG5cdCAqIEBjbGFzcyBDU1NMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZmVyWEhSXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gQ1NTTG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLlR5cGVzLkNTUyk7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBcImhyZWZcIjtcblxuXHRcdGlmIChwcmVmZXJYSFIpIHtcblx0XHRcdHRoaXMuX3RhZyA9IGNyZWF0ZWpzLkVsZW1lbnRzLnN0eWxlKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3RhZyA9IGNyZWF0ZWpzLkVsZW1lbnRzLmxpbmsoKTtcblx0XHR9XG5cblx0XHR0aGlzLl90YWcucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cdFx0dGhpcy5fdGFnLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQ1NTTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gQ1NTTG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiVHlwZXMvQ1NTOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLlR5cGVzLkNTUztcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIENTUyBmaWxlcy5cblx0ICogQG1ldGhvZCBfZm9ybWF0UmVzdWx0XG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcmV0dXJucyB7SFRNTExpbmtFbGVtZW50fEhUTUxTdHlsZUVsZW1lbnR9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9mb3JtYXRSZXN1bHQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0aWYgKHRoaXMuX3ByZWZlclhIUikge1xuXHRcdFx0dmFyIHRhZyA9IGxvYWRlci5nZXRUYWcoKTtcblxuXHRcdFx0aWYgKHRhZy5zdHlsZVNoZWV0KSB7IC8vIElFXG5cdFx0XHRcdHRhZy5zdHlsZVNoZWV0LmNzc1RleHQgPSBsb2FkZXIuZ2V0UmVzdWx0KHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHRleHROb2RlID0gY3JlYXRlanMuRWxlbWVudHMudGV4dChsb2FkZXIuZ2V0UmVzdWx0KHRydWUpKTtcblx0XHRcdFx0dGFnLmFwcGVuZENoaWxkKHRleHROb2RlKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFnID0gdGhpcy5fdGFnO1xuXHRcdH1cblxuXHRcdGNyZWF0ZWpzLkRvbVV0aWxzLmFwcGVuZFRvSGVhZCh0YWcpO1xuXG5cdFx0cmV0dXJuIHRhZztcblx0fTtcblxuXHRjcmVhdGVqcy5DU1NMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKENTU0xvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEZvbnRMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbndpbmRvdy5jcmVhdGVqcyA9IHdpbmRvdy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQSBsb2FkZXIgdGhhdCBoYW5kbGVzIGZvbnQgZmlsZXMsIENTUyBkZWZpbml0aW9ucywgYW5kIENTUyBwYXRocy4gRm9udExvYWRlciBkb2Vzbid0IGFjdHVhbGx5IHByZWxvYWQgZm9udHNcblx0ICogdGhlbXNlbHZlcywgYnV0IHJhdGhlciBnZW5lcmF0ZXMgQ1NTIGRlZmluaXRpb25zLCBhbmQgdGhlbiB0ZXN0cyB0aGUgc2l6ZSBjaGFuZ2VzIG9uIGFuIEhUTUw1IENhbnZhcyBlbGVtZW50LlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgRm9udExvYWRlciBkb2VzIG5vdCBzdXBwb3J0IHRhZy1iYXNlZCBsb2FkaW5nIGR1ZSB0byB0aGUgcmVxdWlyZW1lbnQgdGhhdCBDU1MgYmUgcmVhZCB0byBkZXRlcm1pbmUgdGhlXG5cdCAqIGZvbnQgZGVmaW5pdGlvbnMgdG8gdGVzdCBmb3IuXG5cdCAqIEBjbGFzcyBGb250TG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18b2JqZWN0fHN0cmluZ30gbG9hZEl0ZW0gVGhlIGl0ZW0gdG8gYmUgbG9hZGVkLlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBGb250TG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGxvYWRJdGVtLnR5cGUpO1xuXG5cdFx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEEgbG9va3VwIG9mIGZvbnQgZmFjZXMgdG8gbG9hZC5cblx0XHQgKiBAcHJvcGVydHkgX2ZhY2VzXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqKi9cblx0XHR0aGlzLl9mYWNlcyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogQSBsaXN0IG9mIGZvbnQgZmFjZXMgY3VycmVudGx5IGJlaW5nIFwid2F0Y2hlZFwiLiBXYXRjaGVkIGZvbnRzIHdpbGwgYmUgdGVzdGVkIG9uIGEgcmVndWxhciBpbnRlcnZhbCwgYW5kIGJlXG5cdFx0ICogcmVtb3ZlZCBmcm9tIHRoaXMgbGlzdCB3aGVuIHRoZXkgYXJlIGNvbXBsZXRlLlxuXHRcdCAqIEBvcm9wZXJ0eSBfd2F0Y2hlZFxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fd2F0Y2hlZCA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBjb3VudCBvZiB0aGUgdG90YWwgZm9udCBmYWNlcyB0byBsb2FkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfY291bnRcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5fY291bnQgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGludGVydmFsIGZvciBjaGVja2luZyBpZiBmb250cyBoYXZlIGJlZW4gbG9hZGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfd2F0Y2hJbnRlcnZhbFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3dhdGNoSW50ZXJ2YWwgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRpbWVvdXQgZm9yIGRldGVybWluaW5nIGlmIGEgZm9udCBjYW4ndCBiZSBsb2FkZWQuIFVzZXMgdGhlIExvYWRJdGVtIHt7I2Nyb3NzTGluayBcIkxvYWRJbXRlL3RpbWVvdXQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiB2YWx1ZS5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRUaW1lb3V0XG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZFRpbWVvdXQgPSBudWxsO1xuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZXMgaWYgZ2VuZXJhdGVkIENTUyBzaG91bGQgYmUgaW5qZWN0ZWQgaW50byB0aGUgZG9jdW1lbnQuXG5cdFx0ICogQHByb3BlcnR5IF9pbmplY3RDU1Ncblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5faW5qZWN0Q1NTID0gKGxvYWRJdGVtLmluamVjdENTUyA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiBsb2FkSXRlbS5pbmplY3RDU1M7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJpbml0aWFsaXplXCIpO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEZvbnRMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcbiAgICAgKiB7eyNjcm9zc0xpbmsgXCJUeXBlcy9GT05UOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cbiAgICAgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBGb250TG9hZGVyLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5UeXBlcy5GT05UIHx8IGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5UeXBlcy5GT05UQ1NTO1xuICAgIH07XG5cbi8vIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogU2FtcGxlIHRleHQgdXNlZCBieSB0aGUgRm9udExvYWRlciB0byBkZXRlcm1pbmUgaWYgdGhlIGZvbnQgaGFzIGJlZW4gbG9hZGVkLiBUaGUgc2FtcGxlIHRleHQgc2l6ZSBpcyBjb21wYXJlZFxuXHQgKiB0byB0aGUgbG9hZGVkIGZvbnQgc2l6ZSwgYW5kIGEgY2hhbmdlIGluZGljYXRlcyB0aGF0IHRoZSBmb250IGhhcyBjb21wbGV0ZWQuXG5cdCAqIEBwcm9wZXJ0eSBzYW1wbGVUZXh0XG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXG5cdCAqIEBzdGF0aWNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdEZvbnRMb2FkZXIuc2FtcGxlVGV4dCA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXogQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIjtcblxuXHQvKipcblx0ICogVGhlIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gdGVzdCB0aGUgZm9udCBzaXplLiBOb3RlIHRoYXQgdGhpcyBjdXJyZW50bHkgcmVxdWlyZXMgYW4gSFRNTCBET00uXG5cdCAqIEBwcm9wZXJ0eSBfY3R4XG5cdCAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG5cdCAqIEBzdGF0aWNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdEZvbnRMb2FkZXIuX2N0eCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpOyAvLyBUT0RPOiBDb25zaWRlciBhIG1ldGhvZCB0byBkbyB0aGlzIGxpa2UgRWFzZWxKUyBTdGFnZSBoYXMuXG5cblx0LyoqXG5cdCAqIEEgbGlzdCBvZiByZWZlcmVuY2UgZm9udHMgdG8gdGVzdC4gTXVsdGlwbGUgZmFjZXMgYXJlIHRlc3RlZCB0byBhZGRyZXNzIHRoZSByYXJlIGNhc2Ugb2YgYSBsb2FkZWQgZm9udCBiZWluZyB0aGVcblx0ICogZXhhY3Qgc2FtZSBkaW1lbnNpb25zIGFzIHRoZSB0ZXN0IGZvbnQuXG5cdCAqIEBwcm9wZXJ0eSBfcmVmZXJlbmNlRm9udHNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAZGVmYXVsdCBbXCJzZXJpZlwiLCBcIm1vbm9zcGFjZVwiXVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Rm9udExvYWRlci5fcmVmZXJlbmNlRm9udHMgPSBbXCJzZXJpZlwiLFwibW9ub3NwYWNlXCJdO1xuXG5cdC8qKlxuXHQgKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IHB1bGxzIG91dCBwb3NzaWJsZSBzdHlsZSB2YWx1ZXMgZnJvbSB0aGUgZm9udCBuYW1lLlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+VGhpcyBpbmNsdWRlcyBmb250IG5hbWVzIHRoYXQgaW5jbHVkZSB0aGluLCBub3JtYWwsIGJvb2ssIHJlZ3VsYXIsIG1lZGl1bSwgYmxhY2ssIGFuZCBoZWF2eSAoc3VjaCBhc1xuXHQgKiAgICAgXCJBcmlhbCBCbGFja1wiKTwvbGk+XG5cdCAqICAgICA8bGk+V2VpZ2h0IG1vZGlmaWVycyBpbmNsdWRpbmcgZXh0cmEsIHVsdHJhLCBzZW1pLCBkZW1pLCBsaWdodCwgYW5kIGJvbGQgKHN1Y2ggYXMgXCJXb3JrU2FucyBTZW1pQm9sZFwiKTwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqIFdlaWdodCBkZXNjcmlwdGlvbnMgbWFwIHRvIGZvbnQgd2VpZ2h0IHZhbHVlcyBieSBkZWZhdWx0IHVzaW5nIHRoZSBmb2xsb3dpbmcgKGZyb21cblx0ICogaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1mb250cy8jZm9udC13ZWlnaHQtbnVtZXJpYy12YWx1ZXMpOlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+MTAwIC0gVGhpbjwvbGk+XG5cdCAqIFx0ICAgPGxpPjIwMCAtIEV4dHJhIExpZ2h0LCBVbHRyYSBMaWdodDwvbGk+XG5cdCAqICAgICA8bGk+MzAwIC0gTGlnaHQsIFNlbWkgTGlnaHQsIERlbWkgTGlnaHQ8L2xpPlxuXHQgKiAgICAgPGxpPjQwMCAtIE5vcm1hbCwgQm9vaywgUmVndWxhcjwvbGk+XG5cdCAqICAgICA8bGk+NTAwIC0gTWVkaXVtPC9saT5cblx0ICogICAgIDxsaT42MDAgLSBTZW1pIEJvbGQsIERlbWkgQm9sZDwvbGk+XG5cdCAqICAgICA8bGk+NzAwIC0gQm9sZDwvbGk+XG5cdCAqICAgICA8bGk+ODAwIC0gRXh0cmEgQm9sZCwgVWx0cmEgQm9sZDwvbGk+XG5cdCAqICAgICA8bGk+OTAwIC0gQmxhY2ssIEhlYXZ5PC9saT5cblx0ICogPC91bD5cblx0ICogQHByb3BlcnR5IFdFSUdIVF9SRUdFWFxuXHQgKiBAdHlwZSB7UmVnRXhwfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRGb250TG9hZGVyLldFSUdIVF9SRUdFWCA9IC9bLSAuX10qKHRoaW58bm9ybWFsfGJvb2t8cmVndWxhcnxtZWRpdW18YmxhY2t8aGVhdnl8WzEtOV0wMHwoPzpleHRyYXx1bHRyYXxzZW1pfGRlbWkpP1stIC5fXSooPzpsaWdodHxib2xkKSlbLSAuX10qL2lnO1xuXG5cdC8qKlxuXHQgKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IHB1bGxzIG91dCBwb3NzaWJsZSBzdHlsZSB2YWx1ZXMgZnJvbSB0aGUgZm9udCBuYW1lLiBUaGVzZSBpbmNsdWRlIFwiaXRhbGljXCJcblx0ICogYW5kIFwib2JsaXF1ZVwiLlxuXHQgKiBAcHJvcGVydHkgU1RZTEVfUkVHRVhcblx0ICogQHR5cGUge1JlZ0V4cH1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0Rm9udExvYWRlci5TVFlMRV9SRUdFWCA9IC9bLSAuX10qKGl0YWxpY3xvYmxpcXVlKVstIC5fXSovaWc7XG5cblx0LyoqXG5cdCAqIEEgbG9va3VwIG9mIGZvbnQgdHlwZXMgZm9yIGdlbmVyYXRpbmcgYSBDU1MgZGVmaW5pdGlvbi4gRm9yIGV4YW1wbGUsIFRURiBmb250cyByZXF1aXJlcyBhIFwidHJ1ZXR5cGVcIiB0eXBlLlxuXHQgKiBAcHJvcGVydHkgRk9OVF9GT1JNQVRcblx0ICogQHR5cGUge09iamVjdH1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0Rm9udExvYWRlci5GT05UX0ZPUk1BVCA9IHt3b2ZmMjpcIndvZmYyXCIsIHdvZmY6XCJ3b2ZmXCIsIHR0ZjpcInRydWV0eXBlXCIsIG90ZjpcInRydWV0eXBlXCJ9O1xuXG5cdC8qKlxuXHQgKiBBIGxvb2t1cCBvZiBmb250IHdlaWdodHMgYmFzZWQgb24gYSBuYW1lLiBUaGVzZSB2YWx1ZXMgYXJlIGZyb20gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1mb250cy8jZm9udC13ZWlnaHQtbnVtZXJpYy12YWx1ZXMuXG5cdCAqIEBwcm9wZXJ0eSBGT05UX1dFSUdIVFxuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRGb250TG9hZGVyLkZPTlRfV0VJR0hUID0ge3RoaW46MTAwLCBleHRyYWxpZ2h0OjIwMCwgdWx0cmFsaWdodDoyMDAsIGxpZ2h0OjMwMCwgc2VtaWxpZ2h0OjMwMCwgZGVtaWxpZ2h0OjMwMCwgYm9vazpcIm5vcm1hbFwiLCByZWd1bGFyOlwibm9ybWFsXCIsIHNlbWlib2xkOjYwMCwgZGVtaWJvbGQ6NjAwLCBleHRyYWJvbGQ6ODAwLCB1bHRyYWJvbGQ6ODAwLCBibGFjazo5MDAsIGhlYXZ5OjkwMH07XG5cblx0LyoqXG5cdCAqIFRoZSBmcmVxdWVuY3kgaW4gbWlsbGlzZWNvbmRzIHRvIGNoZWNrIGZvciBsb2FkZWQgZm9udHMuXG5cdCAqIEBwcm9wZXJ0eSBXQVRDSF9EVVJBVElPTlxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAxMFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRGb250TG9hZGVyLldBVENIX0RVUkFUSU9OID0gMTA7XG4vLyBwdWJsaWMgbWV0aG9kczpcblx0cC5sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMudHlwZSA9PSBjcmVhdGVqcy5UeXBlcy5GT05UQ1NTKSB7XG5cdFx0XHR2YXIgbG9hZGVkID0gdGhpcy5fd2F0Y2hDU1MoKTtcblxuXHRcdFx0Ly8gSWYgdGhlIENTUyBpcyBub3QgcmVhZHksIGl0IHdpbGwgY3JlYXRlIGEgcmVxdWVzdCwgd2hpY2ggQWJzdHJhY3RMb2FkZXIgY2FuIGhhbmRsZS5cblx0XHRcdGlmICghbG9hZGVkKSB7XG5cdFx0XHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfbG9hZCgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKHRoaXMuX2l0ZW0uc3JjIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdHRoaXMuX3dhdGNoRm9udEFycmF5KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBkZWYgPSB0aGlzLl9kZWZGcm9tU3JjKHRoaXMuX2l0ZW0uc3JjKTtcblx0XHRcdHRoaXMuX3dhdGNoRm9udChkZWYpO1xuXHRcdFx0dGhpcy5faW5qZWN0U3R5bGVUYWcodGhpcy5fY3NzRnJvbURlZihkZWYpKTtcblx0XHR9XG5cblx0XHR0aGlzLl9sb2FkVGltZW91dCA9IHNldFRpbWVvdXQoY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlVGltZW91dCwgdGhpcyksIHRoaXMuX2l0ZW0ubG9hZFRpbWVvdXQpO1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwibG9hZHN0YXJ0XCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgZm9udCBsb2FkIGhhcyB0aW1lZCBvdXQuIFRoaXMgaXMgY2FsbGVkIHZpYSBhIDxjb2RlPnNldFRpbWVvdXQ8L2NvZGU+LlxuXHQgKiBjYWxsYmFjay5cblx0ICogQG1ldGhvZCBfaGFuZGxlVGltZW91dFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9oYW5kbGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3N0b3BXYXRjaGluZygpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlBSRUxPQURfVElNRU9VVFwiKSk7XG5cdH07XG5cblx0Ly8gV2F0Y2hDU1MgZG9lcyB0aGUgd29yayBmb3IgdXMsIGFuZCBwcm92aWRlcyBhIG1vZGlmaWVkIHNyYy5cblx0cC5fY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9yZXF1ZXN0O1xuXHR9O1xuXG5cdC8vIEV2ZW50cyBjb21lIGZyb20gdGhlIGludGVybmFsIFhIUiBsb2FkZXIuXG5cdHAuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcblx0XHRcdGNhc2UgXCJjb21wbGV0ZVwiOlxuXHRcdFx0XHR0aGlzLl9yYXdSZXN1bHQgPSBldmVudC50YXJnZXQuX3Jlc3BvbnNlO1xuXHRcdFx0XHR0aGlzLl9yZXN1bHQgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLl9wYXJzZUNTUyh0aGlzLl9yYXdSZXN1bHQpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcImVycm9yXCI6XG5cdFx0XHRcdHRoaXMuX3N0b3BXYXRjaGluZygpO1xuXHRcdFx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2hhbmRsZUV2ZW50KGV2ZW50KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9O1xuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgdGhlIHByb3ZpZGVkIENTUyBpcyBhIHN0cmluZyBkZWZpbml0aW9uLCBDU1MgSFRNTCBlbGVtZW50LCBvciBhIENTUyBmaWxlIFVSSS4gRGVwZW5kaW5nIG9uIHRoZVxuXHQgKiBmb3JtYXQsIHRoZSBDU1Mgd2lsbCBiZSBwYXJzZWQsIG9yIGxvYWRlZC5cblx0ICogQG1ldGhvZCBfd2F0Y2hDU1Ncblx0ICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBDU1MgaXMgcmVhZHlcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fd2F0Y2hDU1MgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgc3JjID0gdGhpcy5faXRlbS5zcmM7XG5cblx0XHQvLyBBbiBIVE1MRWxlbWVudCB3YXMgcGFzc2VkIGluLiBKdXN0IHVzZSBpdC5cblx0XHRpZiAoc3JjIGluc3RhbmNlb2YgSFRNTFN0eWxlRWxlbWVudCkge1xuXHRcdFx0aWYgKHRoaXMuX2luamVjdENTUyAmJiAhc3JjLnBhcmVudE5vZGUpIHsgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSkuYXBwZW5kQ2hpbGQoc3JjKTsgfVxuXHRcdFx0dGhpcy5faW5qZWN0Q1NTID0gZmFsc2U7XG5cdFx0XHRzcmMgPSBcIlxcblwiK3NyYy50ZXh0Q29udGVudDtcblx0XHR9XG5cblx0XHQvLyBBIENTUyBzdHJpbmcgd2FzIHBhc3NlZCBpbi4gUGFyc2UgYW5kIHVzZSBpdFxuXHRcdGlmIChzcmMuc2VhcmNoKC9cXG58XFxyfEBmb250LWZhY2UvaSkgIT09IC0xKSB7IC8vIGNzcyBzdHJpbmcuXG5cdFx0XHR0aGlzLl9wYXJzZUNTUyhzcmMpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gTG9hZCBhIENTUyBQYXRoLiBOb3RlIHRoYXQgd2UgQ0FOIE5PVCBsb2FkIGl0IHdpdGhvdXQgWEhSIGJlY2F1c2Ugd2UgbmVlZCB0byByZWFkIHRoZSBDU1MgZGVmaW5pdGlvblxuXHRcdHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuWEhSUmVxdWVzdCh0aGlzLl9pdGVtKTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhcnNlIGEgQ1NTIHN0cmluZyB0byBkZXRlcm1pbmUgdGhlIGZvbnRzIHRvIGxvYWQuXG5cdCAqIEBtZXRob2QgX3BhcnNlQ1NTXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjc3MgVGhlIENTUyBzdHJpbmcgdG8gcGFyc2Vcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fcGFyc2VDU1MgPSBmdW5jdGlvbihjc3MpIHtcblx0XHR2YXIgcmVnZXggPSAvQGZvbnQtZmFjZVxccypcXHsoW159XSspfS9nXG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdHZhciByZXN1bHQgPSByZWdleC5leGVjKGNzcyk7XG5cdFx0XHRpZiAoIXJlc3VsdCkgeyBicmVhazsgfVxuXHRcdFx0dGhpcy5fd2F0Y2hGb250KHRoaXMuX3BhcnNlRm9udEZhY2UocmVzdWx0WzFdKSk7XG5cdFx0fVxuXHRcdHRoaXMuX2luamVjdFN0eWxlVGFnKGNzcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBwcm92aWRlZCBmb250cyB3ZXJlIGFuIGFycmF5IG9mIG9iamVjdCBvciBzdHJpbmcgZGVmaW5pdGlvbnMuIFBhcnNlIHRoZW0sIGFuZCBpbmplY3QgYW55IHRoYXQgYXJlIHJlYWR5LlxuXHQgKiBAbWV0aG9kIF93YXRjaEZvbnRBcnJheVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl93YXRjaEZvbnRBcnJheSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcnIgPSB0aGlzLl9pdGVtLnNyYywgY3NzID0gXCJcIiwgZGVmO1xuXHRcdGZvciAodmFyIGk9YXJyLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcblx0XHRcdHZhciBvID0gYXJyW2ldO1xuXHRcdFx0aWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSB7IGRlZiA9IHRoaXMuX2RlZkZyb21TcmMobykgfVxuXHRcdFx0ZWxzZSB7IGRlZiA9IHRoaXMuX2RlZkZyb21PYmoobyk7IH1cblx0XHRcdHRoaXMuX3dhdGNoRm9udChkZWYpO1xuXHRcdFx0Y3NzICs9IHRoaXMuX2Nzc0Zyb21EZWYoZGVmKStcIlxcblwiO1xuXHRcdH1cblx0XHR0aGlzLl9pbmplY3RTdHlsZVRhZyhjc3MpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbmplY3QgYW55IHN0eWxlIGRlZmluaXRpb25zIGludG8gdGhlIGRvY3VtZW50IGhlYWQuIFRoaXMgaXMgbmVjZXNzYXJ5IHdoZW4gdGhlIGRlZmluaXRpb24gaXMganVzdCBhIHN0cmluZyBvclxuXHQgKiBvYmplY3QgZGVmaW5pdGlvbiBpbiBvcmRlciBmb3IgdGhlIHN0eWxlcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBkb2N1bWVudC4gSWYgdGhlIGxvYWRlZCBmb250cyBhcmUgYWxyZWFkeSBIVE1MIENTU1xuXHQgKiBlbGVtZW50cywgdGhleSBkb24ndCBuZWVkIHRvIGJlIGFwcGVuZGVkIGFnYWluLlxuXHQgKiBAbWV0aG9kIF9pbmplY3RTdHlsZVRhZ1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gY3NzIFRoZSBDU1Mgc3RyaW5nIGNvbnRlbnQgdG8gYmUgYXBwZW5kZWQgdG8gdGhlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2luamVjdFN0eWxlVGFnID0gZnVuY3Rpb24oY3NzKSB7XG5cdFx0aWYgKCF0aGlzLl9pbmplY3RDU1MpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG5cdFx0dmFyIHN0eWxlVGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXHRcdHN0eWxlVGFnLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdFx0aWYgKHN0eWxlVGFnLnN0eWxlU2hlZXQpe1xuXHRcdFx0c3R5bGVUYWcuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZVRhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0XHR9XG5cdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZVRhZyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSB0aGUgZm9udCBmYWNlIGZyb20gYSBDU1MgZGVmaW5pdGlvbi5cblx0ICogQG1ldGhvZCBfcGFyc2VGb250RmFjZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBDU1Mgc3RyaW5nIGRlZmluaXRpb25cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IEEgbW9kaWZpZWQgQ1NTIG9iamVjdCBjb250YWluaW5nIGZhbWlseSBuYW1lLCBzcmMsIHN0eWxlLCBhbmQgd2VpZ2h0XG5cdCAqL1xuXHRwLl9wYXJzZUZvbnRGYWNlID0gZnVuY3Rpb24oc3RyKSB7XG5cdFx0dmFyIGZhbWlseSA9IHRoaXMuX2dldENTU1ZhbHVlKHN0ciwgXCJmb250LWZhbWlseVwiKSwgc3JjID0gdGhpcy5fZ2V0Q1NTVmFsdWUoc3RyLCBcInNyY1wiKTtcblx0XHRpZiAoIWZhbWlseSB8fCAhc3JjKSB7IHJldHVybiBudWxsOyB9XG5cdFx0cmV0dXJuIHRoaXMuX2RlZkZyb21PYmooe1xuXHRcdFx0ZmFtaWx5OiBmYW1pbHksXG5cdFx0XHRzcmM6IHNyYyxcblx0XHRcdHN0eWxlOiB0aGlzLl9nZXRDU1NWYWx1ZShzdHIsIFwiZm9udC1zdHlsZVwiKSxcblx0XHRcdHdlaWdodDogdGhpcy5fZ2V0Q1NTVmFsdWUoc3RyLCBcImZvbnQtd2VpZ2h0XCIpXG5cdFx0fSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZCBhIGZvbnQgdG8gdGhlIGxpc3Qgb2YgZm9udHMgY3VycmVudGx5IGJlaW5nIHdhdGNoZWQuIElmIHRoZSBmb250IGlzIGFscmVhZHkgd2F0Y2hlZCBvciBsb2FkZWQsIGl0IHdvbid0IGJlXG5cdCAqIGFkZGVkIGFnYWluLlxuXHQgKiBAbWV0aG9kIF93YXRjaEZvbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGRlZiBUaGUgZm9udCBkZWZpbml0aW9uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3dhdGNoRm9udCA9IGZ1bmN0aW9uKGRlZikge1xuXHRcdGlmICghZGVmIHx8IHRoaXMuX2ZhY2VzW2RlZi5pZF0pIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5fZmFjZXNbZGVmLmlkXSA9IGRlZjtcblx0XHR0aGlzLl93YXRjaGVkLnB1c2goZGVmKTtcblx0XHR0aGlzLl9jb3VudCsrO1xuXG5cdFx0dGhpcy5fY2FsY3VsYXRlUmVmZXJlbmNlU2l6ZXMoZGVmKTtcblx0XHR0aGlzLl9zdGFydFdhdGNoaW5nKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIGludGVydmFsIHRvIGNoZWNrIGZvciBsb2FkZWQgZm9udHMuIE9ubHkgb25lIGludGVydmFsIGlzIHVzZWQgZm9yIGFsbCBmb250cy4gVGhlIGZvbnRzIGFyZSBjaGVja2VkIGJhc2VkXG5cdCAqIG9uIHRoZSB7eyNjcm9zc0xpbmsgXCJGb250TG9hZGVyL1dBVENIX0RVUkFUSU9OOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIF9zdGFydFdhdGNoaW5nXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3N0YXJ0V2F0Y2hpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fd2F0Y2hJbnRlcnZhbCAhPSBudWxsKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuX3dhdGNoSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChjcmVhdGVqcy5wcm94eSh0aGlzLl93YXRjaCwgdGhpcyksIEZvbnRMb2FkZXIuV0FUQ0hfRFVSQVRJT04pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhciB0aGUgaW50ZXJ2YWwgdXNlZCB0byBjaGVjayBmb250cy4gVGhpcyBoYXBwZW5zIHdoZW4gYWxsIGZvbnRzIGFyZSBsb2FkZWQsIG9yIGFuIGVycm9yIG9jY3Vycywgc3VjaCBhcyBhXG5cdCAqIENTUyBmaWxlIGVycm9yLCBvciBhIGxvYWQgdGltZW91dC5cblx0ICogQG1ldGhvZCBfc3RvcFdhdGNoaW5nXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3N0b3BXYXRjaGluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdGNsZWFySW50ZXJ2YWwodGhpcy5fd2F0Y2hJbnRlcnZhbCk7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2xvYWRUaW1lb3V0KTtcblx0XHR0aGlzLl93YXRjaEludGVydmFsID0gbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2sgYWxsIHRoZSBmb250cyB0aGF0IGhhdmUgbm90IGJlZW4gbG9hZGVkLiBUaGUgZm9udHMgYXJlIGRyYXduIHRvIGEgY2FudmFzIGluIG1lbW9yeSwgYW5kIGlmIHRoZWlyIGZvbnQgc2l6ZVxuXHQgKiB2YXJpZXMgZnJvbSB0aGUgZGVmYXVsdCB0ZXh0IHNpemUsIHRoZW4gdGhlIGZvbnQgaXMgY29uc2lkZXJlZCBsb2FkZWQuXG5cdCAqXG5cdCAqIEEge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvZmlsZWxvYWRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgd2lsbCBiZSBkaXNwYXRjaGVkIHdoZW4gZWFjaCBmaWxlIGlzIGxvYWRlZCwgYWxvbmdcblx0ICogd2l0aCB0aGUgZm9udCBmYW1pbHkgbmFtZSBhcyB0aGUgYGl0ZW1gIHZhbHVlLiBBIHt7I2Nyb3NzTGluayBcIlByb2dyZXNzRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gaXMgZGlzcGF0Y2hlZCBhXG5cdCAqIG1heGltdW0gb2Ygb25lIHRpbWUgcGVyIGNoZWNrIHdoZW4gYW55IGZvbnRzIGFyZSBsb2FkZWQsIHdpdGggdGhlIHt7I2Nyb3NzTGluayBcIlByb2dyZXNzRXZlbnQvcHJvZ3Jlc3M6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogdmFsdWUgc2hvd2luZyB0aGUgcGVyY2VudGFnZSBvZiBmb250cyB0aGF0IGhhdmUgbG9hZGVkLlxuXHQgKiBAbWV0aG9kIF93YXRjaFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl93YXRjaCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZWZzID0gdGhpcy5fd2F0Y2hlZCwgcmVmRm9udHMgPSBGb250TG9hZGVyLl9yZWZlcmVuY2VGb250cywgbCA9IGRlZnMubGVuZ3RoO1xuXHRcdGZvciAodmFyIGkgPSBsIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBkZWYgPSBkZWZzW2ldLCByZWZzID0gZGVmLnJlZnM7XG5cdFx0XHRmb3IgKHZhciBqID0gcmVmcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0XHR2YXIgdyA9IHRoaXMuX2dldFRleHRXaWR0aChkZWYuZmFtaWx5ICsgXCIsXCIgKyByZWZGb250c1tqXSwgZGVmLndlaWdodCwgZGVmLnN0eWxlKTtcblx0XHRcdFx0aWYgKHcgIT0gcmVmc1tqXSkge1xuXHRcdFx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVsb2FkXCIpO1xuXHRcdFx0XHRcdGRlZi50eXBlID0gXCJmb250LWZhbWlseVwiO1xuXHRcdFx0XHRcdGV2ZW50Lml0ZW0gPSBkZWY7XG5cdFx0XHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0XHRcdFx0XHRkZWZzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobCAhPT0gZGVmcy5sZW5ndGgpIHtcblx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5Qcm9ncmVzc0V2ZW50KHRoaXMuX2NvdW50LWRlZnMubGVuZ3RoLCB0aGlzLl9jb3VudCk7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHRcdH1cblx0XHRpZiAobCA9PT0gMCkge1xuXHRcdFx0dGhpcy5fc3RvcFdhdGNoaW5nKCk7XG5cdFx0XHR0aGlzLl9zZW5kQ29tcGxldGUoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSB0aGUgZGVmYXVsdCBzaXplIG9mIHRoZSByZWZlcmVuY2UgZm9udHMgdXNlZCB0byBjb21wYXJlIGFnYWluc3QgbG9hZGVkIGZvbnRzLlxuXHQgKiBAbWV0aG9kIF9jYWxjdWxhdGVSZWZlcmVuY2VTaXplc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZGVmIFRoZSBmb250IGRlZmluaXRpb24gdG8gZ2V0IHRoZSBzaXplIG9mLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9jYWxjdWxhdGVSZWZlcmVuY2VTaXplcyA9IGZ1bmN0aW9uKGRlZikge1xuXHRcdHZhciByZWZGb250cyA9IEZvbnRMb2FkZXIuX3JlZmVyZW5jZUZvbnRzO1xuXHRcdHZhciByZWZzID0gZGVmLnJlZnMgPSBbXTtcblx0XHRmb3IgKHZhciBpPTA7IGk8cmVmRm9udHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHJlZnNbaV0gPSB0aGlzLl9nZXRUZXh0V2lkdGgocmVmRm9udHNbaV0sIGRlZi53ZWlnaHQsIGRlZi5zdHlsZSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgYSBDU1MgZGVmaW5pdGlvbiBmcm9tIGEgZm9udCBzb3VyY2UgYW5kIG5hbWUuXG5cdCAqIEBtZXRob2QgX2RlZkZyb21TcmNcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgZm9udCBzb3VyY2Vcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fZGVmRnJvbVNyYyA9IGZ1bmN0aW9uKHNyYykge1xuXHRcdHZhciByZSA9IC9bLSAuX10rL2csIG5hbWUgPSBzcmMsIGV4dCA9IG51bGwsIGluZGV4O1xuXHRcdFxuXHRcdGluZGV4ID0gbmFtZS5zZWFyY2goL1s/I10vKTtcblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRuYW1lID0gbmFtZS5zdWJzdHIoMCxpbmRleCk7XG5cdFx0fVxuXHRcdGluZGV4ID0gbmFtZS5sYXN0SW5kZXhPZihcIi5cIik7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0ZXh0ID0gbmFtZS5zdWJzdHIoaW5kZXgrMSk7XG5cdFx0XHRuYW1lID0gbmFtZS5zdWJzdHIoMCxpbmRleCk7XG5cdFx0fVxuXHRcdGluZGV4ID0gbmFtZS5sYXN0SW5kZXhPZihcIi9cIik7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0bmFtZSA9IG5hbWUuc3Vic3RyKGluZGV4KzEpO1xuXHRcdH1cblx0XHRcblx0XHR2YXIgZmFtaWx5ID0gbmFtZSxcblx0XHRcdFx0d2VpZ2h0ID0gZmFtaWx5Lm1hdGNoKEZvbnRMb2FkZXIuV0VJR0hUX1JFR0VYKTtcblx0XHRpZiAod2VpZ2h0KSB7XG5cdFx0XHR3ZWlnaHQgPSB3ZWlnaHRbMF07XG5cdFx0XHRmYW1pbHkgPSBmYW1pbHkucmVwbGFjZSh3ZWlnaHQsIFwiXCIpO1xuXHRcdFx0d2VpZ2h0ID0gd2VpZ2h0LnJlcGxhY2UocmUsIFwiXCIpLnRvTG93ZXJDYXNlKCk7XG5cdFx0fVxuXHRcdHZhciBzdHlsZSA9IG5hbWUubWF0Y2goRm9udExvYWRlci5TVFlMRV9SRUdFWCk7XG5cdFx0aWYgKHN0eWxlKSB7XG5cdFx0XHRmYW1pbHkgPSBmYW1pbHkucmVwbGFjZShzdHlsZVswXSwgXCJcIik7XG5cdFx0XHRzdHlsZSA9IFwiaXRhbGljXCI7XG5cdFx0fVxuXHRcdGZhbWlseSA9IGZhbWlseS5yZXBsYWNlKHJlLCBcIlwiKTtcblx0XHRcblx0XHR2YXIgY3NzU3JjID0gXCJsb2NhbCgnXCIrbmFtZS5yZXBsYWNlKHJlLFwiIFwiKStcIicpLCB1cmwoJ1wiK3NyYytcIicpXCI7XG5cdFx0dmFyIGZvcm1hdCA9IEZvbnRMb2FkZXIuRk9OVF9GT1JNQVRbZXh0XTtcblx0XHRpZiAoZm9ybWF0KSB7IGNzc1NyYyArPSBcIiBmb3JtYXQoJ1wiK2Zvcm1hdCtcIicpXCI7IH1cblx0XHRcblx0XHRyZXR1cm4gdGhpcy5fZGVmRnJvbU9iaih7XG5cdFx0XHRmYW1pbHk6IGZhbWlseSxcblx0XHRcdHdlaWdodDogRm9udExvYWRlci5GT05UX1dFSUdIVFt3ZWlnaHRdfHx3ZWlnaHQsXG5cdFx0XHRzdHlsZTogc3R5bGUsXG5cdFx0XHRzcmM6IGNzc1NyY1xuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgYSBmb250IGRlZmluaXRpb24gZnJvbSBhIHJhdyBmb250IG9iamVjdC5cblx0ICogQG1ldGhvZCBfZGVmRnJvbU9ialxuXHQgKiBAcGFyYW0ge09iamVjdH0gbyBBIHJhdyBvYmplY3QgcHJvdmlkZWQgdG8gdGhlIEZvbnRMb2FkZXJcblx0ICogQHJldHVybnMge09iamVjdH0gQSBzdGFuZGFyZCBmb250IG9iamVjdCB0aGF0IHRoZSBGb250TG9hZGVyIHVuZGVyc3RhbmRzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2RlZkZyb21PYmogPSBmdW5jdGlvbihvKSB7XG5cdFx0dmFyIGRlZiA9IHtcblx0XHRcdGZhbWlseTogby5mYW1pbHksXG5cdFx0XHRzcmM6IG8uc3JjLFxuXHRcdFx0c3R5bGU6IG8uc3R5bGUgfHwgXCJub3JtYWxcIixcblx0XHRcdHdlaWdodDogby53ZWlnaHQgfHwgXCJub3JtYWxcIlxuXHRcdH07XG5cdFx0ZGVmLmlkID0gZGVmLmZhbWlseSArIFwiO1wiICsgZGVmLnN0eWxlICsgXCI7XCIgKyBkZWYud2VpZ2h0O1xuXHRcdHJldHVybiBkZWY7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCBDU1MgZnJvbSBhIGZvbnQgZGVmaW5pdGlvbi5cblx0ICogQG1ldGhvZCBfY3NzRnJvbURlZlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGVmIEEgZm9udCBkZWZpbml0aW9uXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IEEgQ1NTIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG9iamVjdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9jc3NGcm9tRGVmID0gZnVuY3Rpb24oZGVmKSB7XG5cdFx0cmV0dXJuIFwiQGZvbnQtZmFjZSB7XFxuXCIgK1xuXHRcdFx0XCJcXHRmb250LWZhbWlseTogJ1wiK2RlZi5mYW1pbHkrXCInO1xcblwiICtcblx0XHRcdFwiXFx0Zm9udC1zdHlsZTogXCIrZGVmLnN0eWxlK1wiO1xcblwiICtcblx0XHRcdFwiXFx0Zm9udC13ZWlnaHQ6IFwiK2RlZi53ZWlnaHQrXCI7XFxuXCIgK1xuXHRcdFx0XCJcXHRzcmM6IFwiK2RlZi5zcmMrXCI7XFxuXCIgK1xuXHRcdFx0XCJ9XCI7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgdGV4dCB3aWR0aCBvZiB0ZXh0IHVzaW5nIHRoZSBmYW1pbHksIHdlaWdodCwgYW5kIHN0eWxlXG5cdCAqIEBtZXRob2QgX2dldFRleHRXaWR0aFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZmFtaWx5IFRoZSBmb250IGZhbWlseVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gd2VpZ2h0IFRoZSBmb250IHdlaWdodFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3R5bGUgVGhlIGZvbnQgc3R5bGVcblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIHBpeGVsIG1lYXN1cmVtZW50IG9mIHRoZSBmb250LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9nZXRUZXh0V2lkdGggPSBmdW5jdGlvbihmYW1pbHksIHdlaWdodCwgc3R5bGUpIHtcblx0XHR2YXIgY3R4ID0gRm9udExvYWRlci5fY3R4O1xuXHRcdGN0eC5mb250ID0gc3R5bGUrXCIgXCIrd2VpZ2h0K1wiIDcycHggXCIrZmFtaWx5O1xuXHRcdHJldHVybiBjdHgubWVhc3VyZVRleHQoRm9udExvYWRlci5zYW1wbGVUZXh0KS53aWR0aDtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGZyb20gYSBDU1Mgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc2VhcmNoZXMgYSBDU1Mgc3RyaW5nIGZvciB0aGUgdmFsdWUgb2YgdGhlXG5cdCAqIFwiZm9udC1mYW1pbHlcIiBwcm9wZXJ0eS5cblx0ICogQG1ldGhvZCBfZ2V0Q1NTVmFsdWVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgQ1NTIHN0cmluZyB0byBzZWFyY2hcblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lIFRoZSBwcm9wZXJ0eSBuYW1lIHRvIGdldCB0aGUgdmFsdWUgZm9yXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB2YWx1ZSBpbiB0aGUgQ1NTIGZvciB0aGUgcHJvdmlkZWQgcHJvcGVydHkgbmFtZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9nZXRDU1NWYWx1ZSA9IGZ1bmN0aW9uKHN0ciwgcHJvcE5hbWUpIHtcblx0XHR2YXIgcmVnZXggPSBuZXcgUmVnRXhwKHByb3BOYW1lK1wiOlxccyooW147fV0rPylcXHMqWzt9XVwiKTtcblx0XHR2YXIgcmVzdWx0ID0gcmVnZXguZXhlYyhzdHIpO1xuXHRcdGlmICghcmVzdWx0IHx8ICFyZXN1bHRbMV0pIHsgcmV0dXJuIG51bGw7IH1cblx0XHRyZXR1cm4gcmVzdWx0WzFdO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkZvbnRMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEZvbnRMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0pKCk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBJbWFnZUxvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxud2luZG93LmNyZWF0ZWpzID0gd2luZG93LmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIGltYWdlIGZpbGVzLlxuXHQgKiBAY2xhc3MgSW1hZ2VMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZmVyWEhSXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gSW1hZ2VMb2FkZXIgKGxvYWRJdGVtLCBwcmVmZXJYSFIpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLlR5cGVzLklNQUdFKTtcblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5yZXN1bHRGb3JtYXR0ZXIgPSB0aGlzLl9mb3JtYXRSZXN1bHQ7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSA9IFwic3JjXCI7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgcHJlbG9hZCBpdGVtIGlzIGFscmVhZHkgYSB0YWcuXG5cdFx0aWYgKGNyZWF0ZWpzLkRvbVV0aWxzLmlzSW1hZ2VUYWcobG9hZEl0ZW0pKSB7XG5cdFx0XHR0aGlzLl90YWcgPSBsb2FkSXRlbTtcblx0XHR9IGVsc2UgaWYgKGNyZWF0ZWpzLkRvbVV0aWxzLmlzSW1hZ2VUYWcobG9hZEl0ZW0uc3JjKSkge1xuXHRcdFx0dGhpcy5fdGFnID0gbG9hZEl0ZW0uc3JjO1xuXHRcdH0gZWxzZSBpZiAoY3JlYXRlanMuRG9tVXRpbHMuaXNJbWFnZVRhZyhsb2FkSXRlbS50YWcpKSB7XG5cdFx0XHR0aGlzLl90YWcgPSBsb2FkSXRlbS50YWc7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3RhZyAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl9wcmVmZXJYSFIgPSBmYWxzZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fdGFnID0gY3JlYXRlanMuRWxlbWVudHMuaW1nKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5vbihcImluaXRpYWxpemVcIiwgdGhpcy5fdXBkYXRlWEhSLCB0aGlzKTtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChJbWFnZUxvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IEltYWdlTG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiVHlwZXMvSU1BR0U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuVHlwZXMuSU1BR0U7XG5cdH07XG5cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90YWcuc3JjICE9IFwiXCIgJiYgdGhpcy5fdGFnLmNvbXBsZXRlKSB7XG5cdFx0XHR0aGlzLl9zZW5kQ29tcGxldGUoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgY3Jvc3NPcmlnaW4gPSB0aGlzLl9pdGVtLmNyb3NzT3JpZ2luO1xuXHRcdGlmIChjcm9zc09yaWdpbiA9PSB0cnVlKSB7IGNyb3NzT3JpZ2luID0gXCJBbm9ueW1vdXNcIjsgfVxuXHRcdGlmIChjcm9zc09yaWdpbiAhPSBudWxsICYmICFjcmVhdGVqcy5VUkxVdGlscy5pc0xvY2FsKHRoaXMuX2l0ZW0pKSB7XG5cdFx0XHR0aGlzLl90YWcuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblx0XHR9XG5cblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2xvYWQoKTtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogQmVmb3JlIHRoZSBpdGVtIGxvYWRzLCBzZXQgaXRzIG1pbWVUeXBlIGFuZCByZXNwb25zZVR5cGUuXG5cdCAqIEBwcm9wZXJ0eSBfdXBkYXRlWEhSXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl91cGRhdGVYSFIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC5sb2FkZXIubWltZVR5cGUgPSAndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZC1iaW5hcnknO1xuXG5cdFx0Ly8gT25seSBleGlzdHMgZm9yIFhIUlxuXHRcdGlmIChldmVudC5sb2FkZXIuc2V0UmVzcG9uc2VUeXBlKSB7XG5cdFx0XHRldmVudC5sb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYmxvYlwiKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBJbWFnZSBmaWxlcy5cblx0ICogQG1ldGhvZCBfZm9ybWF0UmVzdWx0XG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcmV0dXJucyB7SFRNTEltYWdlRWxlbWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5fZm9ybWF0SW1hZ2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBhc3luY2hyb25vdXMgaW1hZ2UgZm9ybWF0dGVyIGZ1bmN0aW9uLiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgaW1hZ2VzIGhhdmVcblx0ICogYSBzaG9ydCBkZWxheSBiZWZvcmUgdGhleSBhcmUgcmVhZHkuXG5cdCAqIEBtZXRob2QgX2Zvcm1hdEltYWdlXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3NDYWxsYmFjayBUaGUgbWV0aG9kIHRvIGNhbGwgd2hlbiB0aGUgcmVzdWx0IGhhcyBmaW5pc2hlZCBmb3JtYXR0aW5nXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yQ2FsbGJhY2sgVGhlIG1ldGhvZCB0byBjYWxsIGlmIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgZm9ybWF0dGluZ1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZm9ybWF0SW1hZ2UgPSBmdW5jdGlvbiAoc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG5cdFx0dmFyIHRhZyA9IHRoaXMuX3RhZztcblx0XHR2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xuXG5cdFx0aWYgKCF0aGlzLl9wcmVmZXJYSFIpIHtcblxuXHRcdFx0Ly9kb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRhZyk7XG5cdFx0fSBlbHNlIGlmIChVUkwpIHtcblx0XHRcdHZhciBvYmpVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHRoaXMuZ2V0UmVzdWx0KHRydWUpKTtcblx0XHRcdHRhZy5zcmMgPSBvYmpVUkw7XG5cblx0XHRcdHRhZy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCB0aGlzLl9jbGVhblVwVVJMLCBmYWxzZSk7XG5cdFx0XHR0YWcuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHRoaXMuX2NsZWFuVXBVUkwsIGZhbHNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFnLnNyYyA9IHRoaXMuX2l0ZW0uc3JjO1xuXHRcdH1cblxuXHRcdGlmICh0YWcuY29tcGxldGUpIHtcblx0XHRcdHN1Y2Nlc3NDYWxsYmFjayh0YWcpO1xuXHRcdH0gZWxzZSB7XG4gICAgICAgICAgICB0YWcub25sb2FkID0gY3JlYXRlanMucHJveHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHRoaXMuX3RhZyk7XG4gICAgICAgICAgICAgICAgdGFnLm9ubG9hZCA9IHRhZy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICB0YWcub25lcnJvciA9IGNyZWF0ZWpzLnByb3h5KGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhuZXcgY3JlYXRlanMuRXJyb3JFdmVudCgnSU1BR0VfRk9STUFUJywgbnVsbCwgZXZlbnQpKTtcbiAgICAgICAgICAgICAgICB0YWcub25sb2FkID0gdGFnLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiB1cCB0aGUgT2JqZWN0VVJMLCB0aGUgdGFnIGlzIGRvbmUgd2l0aCBpdC4gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgcnVuXG5cdCAqIGFzIGFuIGV2ZW50IGxpc3RlbmVyIHdpdGhvdXQgYSBwcm94eS9jbG9zdXJlLCBhcyBpdCBkb2Vzbid0IHJlcXVpcmUgaXQgLSBzbyBkbyBub3Rcblx0ICogaW5jbHVkZSBhbnkgZnVuY3Rpb25hbGl0eSB0aGF0IHJlcXVpcmVzIHNjb3BlIHdpdGhvdXQgY2hhbmdpbmcgaXQuXG5cdCAqIEBtZXRob2QgX2NsZWFuVXBVUkxcblx0ICogQHBhcmFtIGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jbGVhblVwVVJMID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcblx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKGV2ZW50LnRhcmdldC5zcmMpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkltYWdlTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShJbWFnZUxvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEphdmFTY3JpcHRMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbndpbmRvdy5jcmVhdGVqcyA9IHdpbmRvdy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBKYXZhU2NyaXB0IGZpbGVzLlxuXHQgKiBAY2xhc3MgSmF2YVNjcmlwdExvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXJYSFJcblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBKYXZhU2NyaXB0TG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLlR5cGVzLkpBVkFTQ1JJUFQpO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHR0aGlzLnJlc3VsdEZvcm1hdHRlciA9IHRoaXMuX2Zvcm1hdFJlc3VsdDtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5fdGFnU3JjQXR0cmlidXRlID0gXCJzcmNcIjtcblx0XHR0aGlzLnNldFRhZyhjcmVhdGVqcy5FbGVtZW50cy5zY3JpcHQoKSk7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoSmF2YVNjcmlwdExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IEphdmFTY3JpcHRMb2FkZXI7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJUeXBlcy9KQVZBU0NSSVBUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuVHlwZXMuSkFWQVNDUklQVDtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIEphdmFTY3JpcHQgZmlsZXMuXG5cdCAqIEBtZXRob2QgX2Zvcm1hdFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHJldHVybnMge0hUTUxMaW5rRWxlbWVudHxIVE1MU3R5bGVFbGVtZW50fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZm9ybWF0UmVzdWx0ID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdHZhciB0YWcgPSBsb2FkZXIuZ2V0VGFnKCk7XG5cdFx0aWYgKHRoaXMuX3ByZWZlclhIUikge1xuXHRcdFx0dGFnLnRleHQgPSBsb2FkZXIuZ2V0UmVzdWx0KHRydWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGFnO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkphdmFTY3JpcHRMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEphdmFTY3JpcHRMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBKU09OTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG53aW5kb3cuY3JlYXRlanMgPSB3aW5kb3cuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgSlNPTiBmaWxlcy4gVG8gbG9hZCBKU09OIGNyb3NzLWRvbWFpbiwgdXNlIEpTT05QIGFuZCB0aGUge3sjY3Jvc3NMaW5rIFwiSlNPTlBMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaW5zdGVhZC4gVG8gbG9hZCBKU09OLWZvcm1hdHRlZCBtYW5pZmVzdHMsIHVzZSB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHRvXG5cdCAqIGxvYWQgRWFzZWxKUyBTcHJpdGVTaGVldHMsIHVzZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldExvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQGNsYXNzIEpTT05Mb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gSlNPTkxvYWRlcihsb2FkSXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHRydWUsIGNyZWF0ZWpzLlR5cGVzLkpTT04pO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHR0aGlzLnJlc3VsdEZvcm1hdHRlciA9IHRoaXMuX2Zvcm1hdFJlc3VsdDtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChKU09OTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gSlNPTkxvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIlR5cGVzL0pTT046cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuVHlwZXMuSlNPTjtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIEpTT04gZmlsZXMuXG5cdCAqIEBtZXRob2QgX2Zvcm1hdFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHJldHVybnMge0hUTUxMaW5rRWxlbWVudHxIVE1MU3R5bGVFbGVtZW50fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZm9ybWF0UmVzdWx0ID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdHZhciBqc29uID0gbnVsbDtcblx0XHR0cnkge1xuXHRcdFx0anNvbiA9IGNyZWF0ZWpzLkRhdGFVdGlscy5wYXJzZUpTT04obG9hZGVyLmdldFJlc3VsdCh0cnVlKSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJKU09OX0ZPUk1BVFwiLCBudWxsLCBlKTtcblx0XHRcdHRoaXMuX3NlbmRFcnJvcihldmVudCk7XG5cdFx0XHRyZXR1cm4gZTtcblx0XHR9XG5cblx0XHRyZXR1cm4ganNvbjtcblx0fTtcblxuXHRjcmVhdGVqcy5KU09OTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShKU09OTG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gSlNPTlBMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbndpbmRvdy5jcmVhdGVqcyA9IHdpbmRvdy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBKU09OUCBmaWxlcywgd2hpY2ggYXJlIEpTT04tZm9ybWF0dGVkIHRleHQgZmlsZXMsIHdyYXBwZWQgaW4gYSBjYWxsYmFjay4gVG8gbG9hZCByZWd1bGFyIEpTT05cblx0ICogd2l0aG91dCBhIGNhbGxiYWNrIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiSlNPTkxvYWRlclwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLiBUbyBsb2FkIEpTT04tZm9ybWF0dGVkIG1hbmlmZXN0cyxcblx0ICogdXNlIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQgdG8gbG9hZCBFYXNlbEpTIFNwcml0ZVNoZWV0cywgdXNlXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiBKU09OUCBpcyBhIGZvcm1hdCB0aGF0IHByb3ZpZGVzIGEgc29sdXRpb24gZm9yIGxvYWRpbmcgSlNPTiBmaWxlcyBjcm9zcy1kb21haW4gPGVtPndpdGhvdXQ8L2VtPiByZXF1aXJpbmcgQ09SUy5cblx0ICogSlNPTlAgZmlsZXMgYXJlIGxvYWRlZCBhcyBKYXZhU2NyaXB0LCBhbmQgdGhlIFwiY2FsbGJhY2tcIiBpcyBleGVjdXRlZCBvbmNlIHRoZXkgYXJlIGxvYWRlZC4gVGhlIGNhbGxiYWNrIGluIHRoZVxuXHQgKiBKU09OUCBtdXN0IG1hdGNoIHRoZSBjYWxsYmFjayBwYXNzZWQgdG8gdGhlIGxvYWRJdGVtLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZSBKU09OUDwvaDQ+XG5cdCAqXG5cdCAqIFx0XHRjYWxsYmFja05hbWUoe1xuXHQgKiBcdFx0XHRcIm5hbWVcIjogXCJ2YWx1ZVwiLFxuXHQgKlx0IFx0XHRcIm51bVwiOiAzLFxuXHQgKlx0XHRcdFwib2JqXCI6IHsgXCJib29sXCI6dHJ1ZSB9XG5cdCAqIFx0XHR9KTtcblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiBcdFx0dmFyIGxvYWRJdGVtID0ge2lkOlwianNvblwiLCB0eXBlOlwianNvbnBcIiwgc3JjOlwiaHR0cDovL3NlcnZlci5jb20vdGV4dC5qc29uXCIsIGNhbGxiYWNrOlwiY2FsbGJhY2tOYW1lXCJ9XG5cdCAqIFx0XHR2YXIgcXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG5cdCAqIFx0XHRxdWV1ZS5vbihcImNvbXBsZXRlXCIsIGhhbmRsZUNvbXBsZXRlKTtcblx0ICogXHRcdHF1ZXVlLmxvYWRJdGVtKGxvYWRJdGVtKTtcblx0ICpcblx0ICogXHRcdGZ1bmN0aW9uIGhhbmRsZUNvbXBsZXRlKGV2ZW50KSB9XG5cdCAqIFx0XHRcdHZhciBqc29uID0gcXVldWUuZ2V0UmVzdWx0KFwianNvblwiKTtcblx0ICogXHRcdFx0Y29uc29sZS5sb2coanNvbi5vYmouYm9vbCk7IC8vIHRydWVcblx0ICogXHRcdH1cblx0ICpcblx0ICogSlNPTlAgZmlsZXMgbG9hZGVkIGNvbmN1cnJlbnRseSByZXF1aXJlIGEgPGVtPnVuaXF1ZTwvZW0+IGNhbGxiYWNrLiBUbyBlbnN1cmUgSlNPTlAgZmlsZXMgYXJlIGxvYWRlZCBpbiBvcmRlcixcblx0ICogZWl0aGVyIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldE1heENvbm5lY3Rpb25zXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCAoc2V0IHRvIDEpLCBvciBzZXRcblx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vbWFpbnRhaW5PcmRlcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBvbiBpdGVtcyB3aXRoIHRoZSBzYW1lIGNhbGxiYWNrLlxuXHQgKlxuXHQgKiBJbXBvcnRhbnQgbm90ZTogU29tZSBicm93c2VycyB3aWxsIHByZXZlbnQgSlNPTlAgZnJvbSBmaXJpbmcgdGhlIGNhbGxiYWNrIGlmIHRoZSBmaWxlIHdhcyBsb2FkZWQgYXMgSlNPTiwgYW5kIG5vdFxuXHQgKiBKYXZhU2NyaXB0LiBZb3UgbWF5IGhhdmUgdG8gaGF2ZSB5b3VyIHNlcnZlciBnaXZlIHlvdSBhIEphdmFTY3JpcHQgbWltZS10eXBlIGZvciB0aGlzIHRvIHdvcmsuXG5cdCAqXG5cdCAqIEBjbGFzcyBKU09OUExvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBKU09OUExvYWRlcihsb2FkSXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIGZhbHNlLCBjcmVhdGVqcy5UeXBlcy5KU09OUCk7XG5cdFx0dGhpcy5zZXRUYWcoY3JlYXRlanMuRWxlbWVudHMuc2NyaXB0KCkpO1xuXHRcdHRoaXMuZ2V0VGFnKCkudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoSlNPTlBMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBKU09OUExvYWRlcjtcblxuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiVHlwZXMvSlNPTlA6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuVHlwZXMuSlNPTlA7XG5cdH07XG5cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0cC5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jYW5jZWwoKTtcblx0XHR0aGlzLl9kaXNwb3NlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIExvYWRzIHRoZSBKU09OcCBmaWxlLiAgQmVjYXVzZSBvZiB0aGUgdW5pcXVlIGxvYWRpbmcgbmVlZHMgb2YgSlNPTnBcblx0ICogd2UgZG9uJ3QgdXNlIHRoZSBBYnN0cmFjdExvYWRlci5sb2FkKCkgbWV0aG9kLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGxvYWRcblx0ICpcblx0ICovXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5faXRlbS5jYWxsYmFjayA9PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2NhbGxiYWNrIGlzIHJlcXVpcmVkIGZvciBsb2FkaW5nIEpTT05QIHJlcXVlc3RzLicpO1xuXHRcdH1cblxuXHRcdC8vIFRPRE86IExvb2sgaW50byBjcmVhdGluZyBvdXIgb3duIGlGcmFtZSB0byBoYW5kbGUgdGhlIGxvYWRcblx0XHQvLyBJbiB0aGUgZmlyc3QgYXR0ZW1wdCwgRkYgZGlkIG5vdCBnZXQgdGhlIHJlc3VsdFxuXHRcdC8vICAgcmVzdWx0IGluc3RhbmNlb2YgT2JqZWN0IGRpZCBub3Qgd29yayBlaXRoZXJcblx0XHQvLyAgIHNvIHdlIHdvdWxkIG5lZWQgdG8gY2xvbmUgdGhlIHJlc3VsdC5cblx0XHRpZiAod2luZG93W3RoaXMuX2l0ZW0uY2FsbGJhY2tdICE9IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XCJKU09OUCBjYWxsYmFjayAnXCIgK1xuXHRcdFx0XHR0aGlzLl9pdGVtLmNhbGxiYWNrICtcblx0XHRcdFx0XCInIGFscmVhZHkgZXhpc3RzIG9uIHdpbmRvdy4gWW91IG5lZWQgdG8gc3BlY2lmeSBhIGRpZmZlcmVudCBjYWxsYmFjayBvciByZS1uYW1lIHRoZSBjdXJyZW50IG9uZS5cIik7XG5cdFx0fVxuXG5cdFx0d2luZG93W3RoaXMuX2l0ZW0uY2FsbGJhY2tdID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlTG9hZCwgdGhpcyk7XG5cdFx0Y3JlYXRlanMuRG9tVXRpbHMuYXBwZW5kVG9Cb2R5KHRoaXMuX3RhZyk7XG5cblx0XHR0aGlzLl9sb2FkVGltZW91dCA9IHNldFRpbWVvdXQoY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlVGltZW91dCwgdGhpcyksIHRoaXMuX2l0ZW0ubG9hZFRpbWVvdXQpO1xuXG5cdFx0Ly8gTG9hZCB0aGUgdGFnXG5cdFx0dGhpcy5fdGFnLnNyYyA9IHRoaXMuX2l0ZW0uc3JjO1xuXHR9O1xuXG5cdC8vIHByaXZhdGUgbWV0aG9kc1xuXHQvKipcblx0ICogSGFuZGxlIHRoZSBKU09OUCBjYWxsYmFjaywgd2hpY2ggaXMgYSBwdWJsaWMgbWV0aG9kIGRlZmluZWQgb24gYHdpbmRvd2AuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUxvYWRcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGZvcm1hdHRlZCBKU09OIGRhdGEuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVMb2FkID0gZnVuY3Rpb24gKGRhdGEpIHtcblx0XHR0aGlzLl9yZXN1bHQgPSB0aGlzLl9yYXdSZXN1bHQgPSBkYXRhO1xuXHRcdHRoaXMuX3NlbmRDb21wbGV0ZSgpO1xuXG5cdFx0dGhpcy5fZGlzcG9zZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgdGFnIHJlcXVlc3QgaGFzIG5vdCBsb2FkZWQgd2l0aGluIHRoZSB0aW1lIHNwZWNmaWVkIGluIGxvYWRUaW1lb3V0LlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVFcnJvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIFhIUiBlcnJvciBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZGlzcG9zZSgpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcInRpbWVvdXRcIikpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiB1cCB0aGUgSlNPTlAgbG9hZC4gVGhpcyBjbGVhcnMgb3V0IHRoZSBjYWxsYmFjayBhbmQgc2NyaXB0IHRhZyB0aGF0IHRoaXMgbG9hZGVyIGNyZWF0ZXMuXG5cdCAqIEBtZXRob2QgX2Rpc3Bvc2Vcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Rpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y3JlYXRlanMuRG9tVXRpbHMucmVtb3ZlQ2hpbGQodGhpcy5fdGFnKTtcblx0XHRkZWxldGUgd2luZG93W3RoaXMuX2l0ZW0uY2FsbGJhY2tdO1xuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2xvYWRUaW1lb3V0KTtcblx0fTtcblxuXHRjcmVhdGVqcy5KU09OUExvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoSlNPTlBMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBNYW5pZmVzdExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxud2luZG93LmNyZWF0ZWpzID0gd2luZG93LmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIEpTT04gbWFuaWZlc3RzLiBJdGVtcyBpbnNpZGUgdGhlIG1hbmlmZXN0IGFyZSBsb2FkZWQgYmVmb3JlIHRoZSBsb2FkZXIgY29tcGxldGVzLiBUbyBsb2FkIG1hbmlmZXN0c1xuXHQgKiB1c2luZyBKU09OUCwgc3BlY2lmeSBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL2NhbGxiYWNrOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGFzIHBhcnQgb2YgdGhlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiBUaGUgbGlzdCBvZiBmaWxlcyBpbiB0aGUgbWFuaWZlc3QgbXVzdCBiZSBkZWZpbmVkIG9uIHRoZSB0b3AtbGV2ZWwgSlNPTiBvYmplY3QgaW4gYSBgbWFuaWZlc3RgIHByb3BlcnR5LiBUaGlzXG5cdCAqIGV4YW1wbGUgc2hvd3MgYSBzYW1wbGUgbWFuaWZlc3QgZGVmaW5pdGlvbiwgYXMgd2VsbCBhcyBob3cgdG8gdG8gaW5jbHVkZSBhIHN1Yi1tYW5pZmVzdC5cblx0ICpcblx0ICogXHRcdHtcblx0ICogXHRcdFx0XCJwYXRoXCI6IFwiYXNzZXRzL1wiLFxuXHQgKlx0IFx0ICAgIFwibWFuaWZlc3RcIjogW1xuXHQgKlx0XHRcdFx0XCJpbWFnZS5wbmdcIixcblx0ICpcdFx0XHRcdHtcInNyY1wiOiBcImltYWdlMi5wbmdcIiwgXCJpZFwiOlwiaW1hZ2UyXCJ9LFxuXHQgKlx0XHRcdFx0e1wic3JjXCI6IFwic3ViLW1hbmlmZXN0Lmpzb25cIiwgXCJ0eXBlXCI6XCJtYW5pZmVzdFwiLCBcImNhbGxiYWNrXCI6XCJqc29uQ2FsbGJhY2tcIn1cblx0ICpcdCBcdCAgICBdXG5cdCAqXHQgXHR9XG5cdCAqXG5cdCAqIFdoZW4gYSBNYW5pZmVzdExvYWRlciBoYXMgY29tcGxldGVkIGxvYWRpbmcsIHRoZSBwYXJlbnQgbG9hZGVyICh1c3VhbGx5IGEge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBidXQgY291bGQgYWxzbyBiZSBhbm90aGVyIE1hbmlmZXN0TG9hZGVyKSB3aWxsIGluaGVyaXQgYWxsIHRoZSBsb2FkZWQgaXRlbXMsIHNvIHlvdSBjYW4gYWNjZXNzIHRoZW0gZGlyZWN0bHkuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUge3sjY3Jvc3NMaW5rIFwiSlNPTkxvYWRlclwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiSlNPTlBMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gYXJlXG5cdCAqIGhpZ2hlciBwcmlvcml0eSBsb2FkZXJzLCBzbyBtYW5pZmVzdHMgPHN0cm9uZz5tdXN0PC9zdHJvbmc+IHNldCB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX1cblx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vdHlwZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSB0byB7eyNjcm9zc0xpbmsgXCJUeXBlcy9NQU5JRkVTVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogQWRkaXRpb25hbGx5LCBzb21lIGJyb3dzZXJzIHJlcXVpcmUgdGhlIHNlcnZlciB0byBzZXJ2ZSBhIEphdmFTY3JpcHQgbWltZS10eXBlIGZvciBKU09OUCwgc28gaXQgbWF5IG5vdCB3b3JrIGluXG5cdCAqIHNvbWUgY29uZGl0aW9ucy5cblx0ICogQGNsYXNzIE1hbmlmZXN0TG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIE1hbmlmZXN0TG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLlR5cGVzLk1BTklGRVNUKTtcblxuXHQvLyBQdWJsaWMgUHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IG9mIHRoZSBwbHVnaW5zIHJlZ2lzdGVyZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2luc3RhbGxQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0sXG5cdFx0ICogdXNlZCB0byBwYXNzIHBsdWdpbnMgdG8gbmV3IExvYWRRdWV1ZXMgdGhhdCBtYXkgYmUgY3JlYXRlZC5cblx0XHQgKiBAcHJvcGVydHkgX3BsdWdpbnNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAc2luY2UgMC42LjFcblx0XHQgKi9cblx0XHR0aGlzLnBsdWdpbnMgPSBudWxsO1xuXG5cblx0Ly8gUHJvdGVjdGVkIFByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBBbiBpbnRlcm5hbCB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBsb2FkcyB0aGUgY29udGVudHMgb2YgdGhlIG1hbmlmZXN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBfbWFuaWZlc3RRdWV1ZVxuXHRcdCAqIEB0eXBlIHtMb2FkUXVldWV9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9tYW5pZmVzdFF1ZXVlID0gbnVsbDtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChNYW5pZmVzdExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IE1hbmlmZXN0TG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBwcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBUaGUgYW1vdW50IG9mIHByb2dyZXNzIHRoYXQgdGhlIG1hbmlmZXN0IGl0c2VsZiB0YWtlcyB1cC5cblx0ICogQHByb3BlcnR5IE1BTklGRVNUX1BST0dSRVNTXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDAuMjUgKDI1JSlcblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5NQU5JRkVTVF9QUk9HUkVTUyA9IDAuMjU7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJUeXBlcy9NQU5JRkVTVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLlR5cGVzLk1BTklGRVNUO1xuXHR9O1xuXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2xvYWQoKTtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHRwLl9jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gdGhpcy5faXRlbS5jYWxsYmFjaztcblx0XHRpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5KU09OUExvYWRlcih0aGlzLl9pdGVtKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5KU09OTG9hZGVyKHRoaXMuX2l0ZW0pO1xuXHRcdH1cblx0fTtcblxuXHRwLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0c3dpdGNoIChldmVudC50eXBlKSB7XG5cdFx0XHRjYXNlIFwiY29tcGxldGVcIjpcblx0XHRcdFx0dGhpcy5fcmF3UmVzdWx0ID0gZXZlbnQudGFyZ2V0LmdldFJlc3VsdCh0cnVlKTtcblx0XHRcdFx0dGhpcy5fcmVzdWx0ID0gZXZlbnQudGFyZ2V0LmdldFJlc3VsdCgpO1xuXHRcdFx0XHR0aGlzLl9zZW5kUHJvZ3Jlc3Mocy5NQU5JRkVTVF9QUk9HUkVTUyk7XG5cdFx0XHRcdHRoaXMuX2xvYWRNYW5pZmVzdCh0aGlzLl9yZXN1bHQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRjYXNlIFwicHJvZ3Jlc3NcIjpcblx0XHRcdFx0ZXZlbnQubG9hZGVkICo9IHMuTUFOSUZFU1RfUFJPR1JFU1M7XG5cdFx0XHRcdHRoaXMucHJvZ3Jlc3MgPSBldmVudC5sb2FkZWQgLyBldmVudC50b3RhbDtcblx0XHRcdFx0aWYgKGlzTmFOKHRoaXMucHJvZ3Jlc3MpIHx8IHRoaXMucHJvZ3Jlc3MgPT0gSW5maW5pdHkpIHsgdGhpcy5wcm9ncmVzcyA9IDA7IH1cblx0XHRcdFx0dGhpcy5fc2VuZFByb2dyZXNzKGV2ZW50KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2hhbmRsZUV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHRwLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2Rlc3Ryb3koKTtcblx0XHR0aGlzLl9tYW5pZmVzdFF1ZXVlLmNsb3NlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhbmQgbG9hZCB0aGUgbWFuaWZlc3QgaXRlbXMgb25jZSB0aGUgYWN0dWFsIG1hbmlmZXN0IGhhcyBiZWVuIGxvYWRlZC5cblx0ICogQG1ldGhvZCBfbG9hZE1hbmlmZXN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBqc29uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9sb2FkTWFuaWZlc3QgPSBmdW5jdGlvbiAoanNvbikge1xuXHRcdGlmIChqc29uICYmIGpzb24ubWFuaWZlc3QpIHtcblx0XHRcdHZhciBxdWV1ZSA9IHRoaXMuX21hbmlmZXN0UXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKHRoaXMuX3ByZWZlclhIUik7XG5cdFx0XHRxdWV1ZS5vbihcImZpbGVsb2FkXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0RmlsZUxvYWQsIHRoaXMpO1xuXHRcdFx0cXVldWUub24oXCJwcm9ncmVzc1wiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdFByb2dyZXNzLCB0aGlzKTtcblx0XHRcdHF1ZXVlLm9uKFwiY29tcGxldGVcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RDb21wbGV0ZSwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRxdWV1ZS5vbihcImVycm9yXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0RXJyb3IsIHRoaXMsIHRydWUpO1xuXHRcdFx0Zm9yKHZhciBpID0gMCwgbCA9IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcdC8vIGNvbnNlcnZlIG9yZGVyIG9mIHBsdWdpbnNcblx0XHRcdFx0cXVldWUuaW5zdGFsbFBsdWdpbih0aGlzLnBsdWdpbnNbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cXVldWUubG9hZE1hbmlmZXN0KGpzb24pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zZW5kQ29tcGxldGUoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEFuIGl0ZW0gZnJvbSB0aGUge3sjY3Jvc3NMaW5rIFwiX21hbmlmZXN0UXVldWU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaGFzIGNvbXBsZXRlZC5cblx0ICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RGaWxlTG9hZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RGaWxlTG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LnRhcmdldCA9IG51bGw7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG1hbmlmZXN0IGhhcyBjb21wbGV0ZWQgbG9hZGluZy4gVGhpcyB0cmlnZ2VycyB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvY29tcGxldGU6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZnJvbSB0aGUgTWFuaWZlc3RMb2FkZXIuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0Q29tcGxldGVcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZU1hbmlmZXN0Q29tcGxldGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLl9sb2FkZWRJdGVtcyA9IHRoaXMuX21hbmlmZXN0UXVldWUuZ2V0SXRlbXModHJ1ZSk7XG5cdFx0dGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBtYW5pZmVzdCBoYXMgcmVwb3J0ZWQgcHJvZ3Jlc3MuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0UHJvZ3Jlc3Ncblx0ICogQHBhcmFtIHtQcm9ncmVzc0V2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RQcm9ncmVzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSBldmVudC5wcm9ncmVzcyAqICgxIC0gcy5NQU5JRkVTVF9QUk9HUkVTUykgKyBzLk1BTklGRVNUX1BST0dSRVNTO1xuXHRcdHRoaXMuX3NlbmRQcm9ncmVzcyh0aGlzLnByb2dyZXNzKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG1hbmlmZXN0IGhhcyByZXBvcnRlZCBhbiBlcnJvciB3aXRoIG9uZSBvZiB0aGUgZmlsZXMuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0RXJyb3Jcblx0ICogQHBhcmFtIHtFcnJvckV2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVlcnJvclwiKTtcblx0XHRuZXdFdmVudC5pdGVtID0gZXZlbnQuZGF0YTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLk1hbmlmZXN0TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShNYW5pZmVzdExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNvdW5kTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG53aW5kb3cuY3JlYXRlanMgPSB3aW5kb3cuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgSFRNTCBhdWRpbyBmaWxlcy4gUHJlbG9hZEpTIGNhbiBub3QgbG9hZCBXZWJBdWRpbyBmaWxlcywgYXMgYSBXZWJBdWRpbyBjb250ZXh0IGlzIHJlcXVpcmVkLCB3aGljaFxuXHQgKiBzaG91bGQgYmUgY3JlYXRlZCBieSBlaXRoZXIgYSBsaWJyYXJ5IHBsYXlpbmcgdGhlIHNvdW5kIChzdWNoIGFzIDxhIGhyZWY9XCJodHRwOi8vc291bmRqcy5jb21cIj5Tb3VuZEpTPC9hPiwgb3IgYW5cblx0ICogZXh0ZXJuYWwgZnJhbWV3b3JrIHRoYXQgaGFuZGxlcyBhdWRpbyBwbGF5YmFjay4gVG8gbG9hZCBjb250ZW50IHRoYXQgY2FuIGJlIHBsYXllZCBieSBXZWJBdWRpbywgdXNlIHRoZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJCaW5hcnlMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCBoYW5kbGUgdGhlIGF1ZGlvIGNvbnRleHQgZGVjb2RpbmcgbWFudWFsbHkuXG5cdCAqIEBjbGFzcyBTb3VuZExvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXJYSFJcblx0ICogQGV4dGVuZHMgQWJzdHJhY3RNZWRpYUxvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFNvdW5kTG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIpIHtcblx0XHR0aGlzLkFic3RyYWN0TWVkaWFMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgY3JlYXRlanMuVHlwZXMuU09VTkQpO1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHRpZiAoY3JlYXRlanMuRG9tVXRpbHMuaXNBdWRpb1RhZyhsb2FkSXRlbSkpIHtcblx0XHRcdHRoaXMuX3RhZyA9IGxvYWRJdGVtO1xuXHRcdH0gZWxzZSBpZiAoY3JlYXRlanMuRG9tVXRpbHMuaXNBdWRpb1RhZyhsb2FkSXRlbS5zcmMpKSB7XG5cdFx0XHR0aGlzLl90YWcgPSBsb2FkSXRlbTtcblx0XHR9IGVsc2UgaWYgKGNyZWF0ZWpzLkRvbVV0aWxzLmlzQXVkaW9UYWcobG9hZEl0ZW0udGFnKSkge1xuXHRcdFx0dGhpcy5fdGFnID0gY3JlYXRlanMuRG9tVXRpbHMuaXNBdWRpb1RhZyhsb2FkSXRlbSkgPyBsb2FkSXRlbSA6IGxvYWRJdGVtLnNyYztcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fdGFnICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3ByZWZlclhIUiA9IGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChTb3VuZExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RNZWRpYUxvYWRlcik7XG5cdHZhciBzID0gU291bmRMb2FkZXI7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJUeXBlcy9TT1VORDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5UeXBlcy5TT1VORDtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHRwLl9jcmVhdGVUYWcgPSBmdW5jdGlvbiAoc3JjKSB7XG5cdFx0dmFyIHRhZyA9IGNyZWF0ZWpzLkVsZW1lbnRzLmF1ZGlvKCk7XG5cdFx0dGFnLmF1dG9wbGF5ID0gZmFsc2U7XG5cdFx0dGFnLnByZWxvYWQgPSBcIm5vbmVcIjtcblxuXHRcdC8vTE06IEZpcmVmb3ggZmFpbHMgd2hlbiB0aGlzIHRoZSBwcmVsb2FkPVwibm9uZVwiIGZvciBvdGhlciB0YWdzLCBidXQgaXQgbmVlZHMgdG8gYmUgXCJub25lXCIgdG8gZW5zdXJlIFByZWxvYWRKUyB3b3Jrcy5cblx0XHR0YWcuc3JjID0gc3JjO1xuXHRcdHJldHVybiB0YWc7XG5cdH07XG5cblx0Y3JlYXRlanMuU291bmRMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKFNvdW5kTG9hZGVyLCBcIkFic3RyYWN0TWVkaWFMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBWaWRlb0xvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxud2luZG93LmNyZWF0ZWpzID0gd2luZG93LmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIHZpZGVvIGZpbGVzLlxuXHQgKiBAY2xhc3MgVmlkZW9Mb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZmVyWEhSXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TWVkaWFMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBWaWRlb0xvYWRlcihsb2FkSXRlbSwgcHJlZmVyWEhSKSB7XG5cdFx0dGhpcy5BYnN0cmFjdE1lZGlhTG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLlR5cGVzLlZJREVPKTtcblxuXHRcdGlmIChjcmVhdGVqcy5Eb21VdGlscy5pc1ZpZGVvVGFnKGxvYWRJdGVtKSB8fCBjcmVhdGVqcy5Eb21VdGlscy5pc1ZpZGVvVGFnKGxvYWRJdGVtLnNyYykpIHtcblx0XHRcdHRoaXMuc2V0VGFnKGNyZWF0ZWpzLkRvbVV0aWxzLmlzVmlkZW9UYWcobG9hZEl0ZW0pP2xvYWRJdGVtOmxvYWRJdGVtLnNyYyk7XG5cblx0XHRcdC8vIFdlIGNhbid0IHVzZSBYSFIgZm9yIGEgdGFnIHRoYXQncyBwYXNzZWQgaW4uXG5cdFx0XHR0aGlzLl9wcmVmZXJYSFIgPSBmYWxzZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZXRUYWcodGhpcy5fY3JlYXRlVGFnKCkpO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChWaWRlb0xvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RNZWRpYUxvYWRlcik7XG5cdHZhciBzID0gVmlkZW9Mb2FkZXI7XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIG5ldyB2aWRlbyB0YWdcblx0ICpcblx0ICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY3JlYXRlVGFnID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjcmVhdGVqcy5FbGVtZW50cy52aWRlbygpO1xuXHR9O1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiVHlwZXMvVklERU86cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuVHlwZXMuVklERU87XG5cdH07XG5cblx0Y3JlYXRlanMuVmlkZW9Mb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKFZpZGVvTG9hZGVyLCBcIkFic3RyYWN0TWVkaWFMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTcHJpdGVTaGVldExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxud2luZG93LmNyZWF0ZWpzID0gd2luZG93LmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIEVhc2VsSlMgU3ByaXRlU2hlZXRzLiBJbWFnZXMgaW5zaWRlIHRoZSBzcHJpdGVzaGVldCBkZWZpbml0aW9uIGFyZSBsb2FkZWQgYmVmb3JlIHRoZSBsb2FkZXJcblx0ICogY29tcGxldGVzLiBUbyBsb2FkIFNwcml0ZVNoZWV0cyB1c2luZyBKU09OUCwgc3BlY2lmeSBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL2NhbGxiYWNrOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGFzIHBhcnQgb2YgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319LiBOb3RlIHRoYXQgdGhlIHt7I2Nyb3NzTGluayBcIkpTT05Mb2FkZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogYW5kIHt7I2Nyb3NzTGluayBcIkpTT05QTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGFyZSBoaWdoZXIgcHJpb3JpdHkgbG9hZGVycywgc28gU3ByaXRlU2hlZXRzIDxzdHJvbmc+bXVzdDwvc3Ryb25nPlxuXHQgKiBzZXQgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL3R5cGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHlcblx0ICogdG8ge3sjY3Jvc3NMaW5rIFwiVHlwZXMvU1BSSVRFU0hFRVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS9jcm9zc09yaWdpbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBhcyB3ZWxsXG5cdCAqIGFzIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUnc1wifX17ey9jcm9zc0xpbmt9fSBgYmFzZVBhdGhgIGFyZ3VtZW50IGFuZCB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvX3ByZWZlclhIUlwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBwcm9wZXJ0eSBzdXBwbGllZCB0byB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319IGFyZSBwYXNzZWQgb24gdG8gdGhlIHN1Yi1tYW5pZmVzdCB0aGF0IGxvYWRzXG5cdCAqIHRoZSBTcHJpdGVTaGVldCBpbWFnZXMuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgU3ByaXRlU2hlZXQgSlNPTiBkb2VzIG5vdCByZXNwZWN0IHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvX3ByZWZlclhIUjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBwcm9wZXJ0eSwgd2hpY2ggc2hvdWxkIGluc3RlYWQgYmUgZGV0ZXJtaW5lZCBieSB0aGUgcHJlc2VuY2Ugb2YgYSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS9jYWxsYmFjazpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBwcm9wZXJ0eSBvbiB0aGUgU3ByaXRlU2hlZXQgbG9hZCBpdGVtLiBUaGlzIGlzIGJlY2F1c2UgdGhlIEpTT04gbG9hZGVkIHdpbGwgaGF2ZSBhIGRpZmZlcmVudCBmb3JtYXQgZGVwZW5kaW5nIG9uXG5cdCAqIGlmIGl0IGlzIGxvYWRlZCBhcyBKU09OLCBzbyBqdXN0IGNoYW5naW5nIGBwcmVmZXJYSFJgIGlzIG5vdCBlbm91Z2ggdG8gY2hhbmdlIGhvdyBpdCBpcyBsb2FkZWQuXG5cdCAqIEBjbGFzcyBTcHJpdGVTaGVldExvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBTcHJpdGVTaGVldExvYWRlcihsb2FkSXRlbSwgcHJlZmVyWEhSKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgcHJlZmVyWEhSLCBjcmVhdGVqcy5UeXBlcy5TUFJJVEVTSEVFVCk7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEFuIGludGVybmFsIHF1ZXVlIHdoaWNoIGxvYWRzIHRoZSBTcHJpdGVTaGVldCdzIGltYWdlcy5cblx0XHQgKiBAbWV0aG9kIF9tYW5pZmVzdFF1ZXVlXG5cdFx0ICogQHR5cGUge0xvYWRRdWV1ZX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX21hbmlmZXN0UXVldWUgPSBudWxsO1xuXHR9XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoU3ByaXRlU2hlZXRMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBTcHJpdGVTaGVldExvYWRlcjtcblxuXHQvLyBzdGF0aWMgcHJvcGVydGllc1xuXHQvKipcblx0ICogVGhlIGFtb3VudCBvZiBwcm9ncmVzcyB0aGF0IHRoZSBtYW5pZmVzdCBpdHNlbGYgdGFrZXMgdXAuXG5cdCAqIEBwcm9wZXJ0eSBTUFJJVEVTSEVFVF9QUk9HUkVTU1xuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAwLjI1ICgyNSUpXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuU1BSSVRFU0hFRVRfUFJPR1JFU1MgPSAwLjI1O1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiVHlwZXMvU1BSSVRFU0hFRVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5UeXBlcy5TUFJJVEVTSEVFVDtcblx0fTtcblxuXHQvLyBwdWJsaWMgbWV0aG9kc1xuXHRwLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2Rlc3Ryb3koKTtcblx0XHR0aGlzLl9tYW5pZmVzdFF1ZXVlLmNsb3NlKCk7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0cC5fY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IHRoaXMuX2l0ZW0uY2FsbGJhY2s7XG5cdFx0aWYgKGNhbGxiYWNrICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuSlNPTlBMb2FkZXIodGhpcy5faXRlbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuSlNPTkxvYWRlcih0aGlzLl9pdGVtKTtcblx0XHR9XG5cdH07XG5cblx0cC5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHN3aXRjaCAoZXZlbnQudHlwZSkge1xuXHRcdFx0Y2FzZSBcImNvbXBsZXRlXCI6XG5cdFx0XHRcdHRoaXMuX3Jhd1Jlc3VsdCA9IGV2ZW50LnRhcmdldC5nZXRSZXN1bHQodHJ1ZSk7XG5cdFx0XHRcdHRoaXMuX3Jlc3VsdCA9IGV2ZW50LnRhcmdldC5nZXRSZXN1bHQoKTtcblx0XHRcdFx0dGhpcy5fc2VuZFByb2dyZXNzKHMuU1BSSVRFU0hFRVRfUFJPR1JFU1MpO1xuXHRcdFx0XHR0aGlzLl9sb2FkTWFuaWZlc3QodGhpcy5fcmVzdWx0KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0Y2FzZSBcInByb2dyZXNzXCI6XG5cdFx0XHRcdGV2ZW50LmxvYWRlZCAqPSBzLlNQUklURVNIRUVUX1BST0dSRVNTO1xuXHRcdFx0XHR0aGlzLnByb2dyZXNzID0gZXZlbnQubG9hZGVkIC8gZXZlbnQudG90YWw7XG5cdFx0XHRcdGlmIChpc05hTih0aGlzLnByb2dyZXNzKSB8fCB0aGlzLnByb2dyZXNzID09IEluZmluaXR5KSB7IHRoaXMucHJvZ3Jlc3MgPSAwOyB9XG5cdFx0XHRcdHRoaXMuX3NlbmRQcm9ncmVzcyhldmVudCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9oYW5kbGVFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhbmQgbG9hZCB0aGUgaW1hZ2VzIG9uY2UgdGhlIFNwcml0ZVNoZWV0IEpTT04gaGFzIGJlZW4gbG9hZGVkLlxuXHQgKiBAbWV0aG9kIF9sb2FkTWFuaWZlc3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IGpzb25cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2xvYWRNYW5pZmVzdCA9IGZ1bmN0aW9uIChqc29uKSB7XG5cdFx0aWYgKGpzb24gJiYganNvbi5pbWFnZXMpIHtcblx0XHRcdHZhciBxdWV1ZSA9IHRoaXMuX21hbmlmZXN0UXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKHRoaXMuX3ByZWZlclhIUiwgdGhpcy5faXRlbS5wYXRoLCB0aGlzLl9pdGVtLmNyb3NzT3JpZ2luKTtcblx0XHRcdHF1ZXVlLm9uKFwiY29tcGxldGVcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RDb21wbGV0ZSwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRxdWV1ZS5vbihcImZpbGVsb2FkXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0RmlsZUxvYWQsIHRoaXMpO1xuXHRcdFx0cXVldWUub24oXCJwcm9ncmVzc1wiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdFByb2dyZXNzLCB0aGlzKTtcblx0XHRcdHF1ZXVlLm9uKFwiZXJyb3JcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RFcnJvciwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRxdWV1ZS5sb2FkTWFuaWZlc3QoanNvbi5pbWFnZXMpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQW4gaXRlbSBmcm9tIHRoZSB7eyNjcm9zc0xpbmsgXCJfbWFuaWZlc3RRdWV1ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBoYXMgY29tcGxldGVkLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNYW5pZmVzdEZpbGVMb2FkXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVNYW5pZmVzdEZpbGVMb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIGltYWdlID0gZXZlbnQucmVzdWx0O1xuXHRcdGlmIChpbWFnZSAhPSBudWxsKSB7XG5cdFx0XHR2YXIgaW1hZ2VzID0gdGhpcy5nZXRSZXN1bHQoKS5pbWFnZXM7XG5cdFx0XHR2YXIgcG9zID0gaW1hZ2VzLmluZGV4T2YoZXZlbnQuaXRlbS5zcmMpO1xuXHRcdFx0aW1hZ2VzW3Bvc10gPSBpbWFnZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBpbWFnZXMgaGF2ZSBjb21wbGV0ZWQgbG9hZGluZy4gVGhpcyB0cmlnZ2VycyB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvY29tcGxldGU6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZnJvbSB0aGUgU3ByaXRlU2hlZXRMb2FkZXIuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0Q29tcGxldGVcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZU1hbmlmZXN0Q29tcGxldGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLl9yZXN1bHQgPSBuZXcgY3JlYXRlanMuU3ByaXRlU2hlZXQodGhpcy5fcmVzdWx0KTtcblx0XHR0aGlzLl9sb2FkZWRJdGVtcyA9IHRoaXMuX21hbmlmZXN0UXVldWUuZ2V0SXRlbXModHJ1ZSk7XG5cdFx0dGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBpbWFnZXMge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319IGhhcyByZXBvcnRlZCBwcm9ncmVzcy5cblx0ICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RQcm9ncmVzc1xuXHQgKiBAcGFyYW0ge1Byb2dyZXNzRXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVNYW5pZmVzdFByb2dyZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dGhpcy5wcm9ncmVzcyA9IGV2ZW50LnByb2dyZXNzICogKDEgLSBzLlNQUklURVNIRUVUX1BST0dSRVNTKSArIHMuU1BSSVRFU0hFRVRfUFJPR1JFU1M7XG5cdFx0dGhpcy5fc2VuZFByb2dyZXNzKHRoaXMucHJvZ3Jlc3MpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbiBpbWFnZSBoYXMgcmVwb3J0ZWQgYW4gZXJyb3IuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0RXJyb3Jcblx0ICogQHBhcmFtIHtFcnJvckV2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVlcnJvclwiKTtcblx0XHRuZXdFdmVudC5pdGVtID0gZXZlbnQuZGF0YTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLlNwcml0ZVNoZWV0TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShTcHJpdGVTaGVldExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNWR0xvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxud2luZG93LmNyZWF0ZWpzID0gd2luZG93LmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIFNWRyBmaWxlcy5cblx0ICogQGNsYXNzIFNWR0xvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXJYSFJcblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBTVkdMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUikge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgY3JlYXRlanMuVHlwZXMuU1ZHKTtcblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5yZXN1bHRGb3JtYXR0ZXIgPSB0aGlzLl9mb3JtYXRSZXN1bHQ7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSA9IFwiZGF0YVwiO1xuXG5cdFx0aWYgKHByZWZlclhIUikge1xuXHRcdFx0dGhpcy5zZXRUYWcoY3JlYXRlanMuRWxlbWVudHMuc3ZnKCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNldFRhZyhjcmVhdGVqcy5FbGVtZW50cy5vYmplY3QoKSk7XG5cdFx0XHR0aGlzLmdldFRhZygpLnR5cGUgPSBcImltYWdlL3N2Zyt4bWxcIjtcblx0XHR9XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoU1ZHTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gU1ZHTG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiVHlwZXMvU1ZHOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuVHlwZXMuU1ZHO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdC8qKlxuXHQgKiBUaGUgcmVzdWx0IGZvcm1hdHRlciBmb3IgU1ZHIGZpbGVzLlxuXHQgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9mb3JtYXRSZXN1bHQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0Ly8gbWltZSBzaG91bGQgYmUgaW1hZ2Uvc3ZnK3htbCwgYnV0IE9wZXJhIHJlcXVpcmVzIHRleHQveG1sXG5cdFx0dmFyIHhtbCA9IGNyZWF0ZWpzLkRhdGFVdGlscy5wYXJzZVhNTChsb2FkZXIuZ2V0UmVzdWx0KHRydWUpKTtcblx0XHR2YXIgdGFnID0gbG9hZGVyLmdldFRhZygpO1xuXG5cdFx0aWYgKCF0aGlzLl9wcmVmZXJYSFIgJiYgZG9jdW1lbnQuYm9keS5jb250YWlucyh0YWcpKSB7XG5cdFx0XHRkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRhZyk7XG5cdFx0fVxuXG5cdFx0aWYgKHhtbC5kb2N1bWVudEVsZW1lbnQgIT0gbnVsbCkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSB4bWwuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0Ly8gU3VwcG9ydCBsb2FkaW5nIGFuIFNWRyBmcm9tIGEgZGlmZmVyZW50IGRvbWFpbiBpbiBJRFxuXHRcdFx0aWYgKGRvY3VtZW50LmltcG9ydE5vZGUpIHtcblx0XHRcdFx0ZWxlbWVudCA9IGRvY3VtZW50LmltcG9ydE5vZGUoZWxlbWVudCwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHR0YWcuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG5cdFx0XHRyZXR1cm4gdGFnO1xuXHRcdH0gZWxzZSB7IC8vIEZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgU1ZHLCBqdXN0IGdpdmUgdGhlbSB0aGUgWE1MLiAoSUUgOS04KVxuXHRcdFx0cmV0dXJuIHhtbDtcblx0XHR9XG5cdH07XG5cblx0Y3JlYXRlanMuU1ZHTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShTVkdMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBYTUxMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbndpbmRvdy5jcmVhdGVqcyA9IHdpbmRvdy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBDU1MgZmlsZXMuXG5cdCAqIEBjbGFzcyBYTUxMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gWE1MTG9hZGVyKGxvYWRJdGVtKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgdHJ1ZSwgY3JlYXRlanMuVHlwZXMuWE1MKTtcblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5yZXN1bHRGb3JtYXR0ZXIgPSB0aGlzLl9mb3JtYXRSZXN1bHQ7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoWE1MTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gWE1MTG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiVHlwZXMvWE1MOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLlR5cGVzLlhNTDtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIFhNTCBmaWxlcy5cblx0ICogQG1ldGhvZCBfZm9ybWF0UmVzdWx0XG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcmV0dXJucyB7WE1MRG9jdW1lbnR9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9mb3JtYXRSZXN1bHQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0cmV0dXJuIGNyZWF0ZWpzLkRhdGFVdGlscy5wYXJzZVhNTChsb2FkZXIuZ2V0UmVzdWx0KHRydWUpKTtcblx0fTtcblxuXHRjcmVhdGVqcy5YTUxMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKFhNTExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///aaSZ\n");

/***/ })

}]);