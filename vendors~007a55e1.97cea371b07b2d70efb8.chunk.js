(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~007a55e1"],{

/***/ "r0Fr":
/*!*************************************************************************************!*\
  !*** ./node_modules/@iktakahiro/markdown-it-katex/node_modules/katex/dist/katex.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./src/katex.less\nvar katex = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/SourceLocation.js\n/**\n * Lexing or parsing positional information for error reporting.\n * This object is immutable.\n */\nvar SourceLocation =\n/*#__PURE__*/\nfunction () {\n  // The + prefix indicates that these fields aren't writeable\n  // Lexer holding the input string.\n  // Start offset, zero-based inclusive.\n  // End offset, zero-based exclusive.\n  function SourceLocation(lexer, start, end) {\n    this.lexer = void 0;\n    this.start = void 0;\n    this.end = void 0;\n    this.lexer = lexer;\n    this.start = start;\n    this.end = end;\n  }\n  /**\n   * Merges two `SourceLocation`s from location providers, given they are\n   * provided in order of appearance.\n   * - Returns the first one's location if only the first is provided.\n   * - Returns a merged range of the first and the last if both are provided\n   *   and their lexers match.\n   * - Otherwise, returns null.\n   */\n\n\n  SourceLocation.range = function range(first, second) {\n    if (!second) {\n      return first && first.loc;\n    } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {\n      return null;\n    } else {\n      return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);\n    }\n  };\n\n  return SourceLocation;\n}();\n\n\n// CONCATENATED MODULE: ./src/Token.js\n\n/**\n * Interface required to break circular dependency between Token, Lexer, and\n * ParseError.\n */\n\n/**\n * The resulting token returned from `lex`.\n *\n * It consists of the token text plus some position information.\n * The position information is essentially a range in an input string,\n * but instead of referencing the bare input string, we refer to the lexer.\n * That way it is possible to attach extra metadata to the input string,\n * like for example a file name or similar.\n *\n * The position information is optional, so it is OK to construct synthetic\n * tokens if appropriate. Not providing available position information may\n * lead to degraded error reporting, though.\n */\nvar Token_Token =\n/*#__PURE__*/\nfunction () {\n  function Token(text, // the text of this token\n  loc) {\n    this.text = void 0;\n    this.loc = void 0;\n    this.text = text;\n    this.loc = loc;\n  }\n  /**\n   * Given a pair of tokens (this and endToken), compute a `Token` encompassing\n   * the whole input range enclosed by these two.\n   */\n\n\n  var _proto = Token.prototype;\n\n  _proto.range = function range(endToken, // last token of the range, inclusive\n  text) // the text of the newly constructed token\n  {\n    return new Token(text, SourceLocation.range(this, endToken));\n  };\n\n  return Token;\n}();\n// CONCATENATED MODULE: ./src/ParseError.js\n\n\n/**\n * This is the ParseError class, which is the main error thrown by KaTeX\n * functions when something has gone wrong. This is used to distinguish internal\n * errors from errors in the expression that the user provided.\n *\n * If possible, a caller should provide a Token or ParseNode with information\n * about where in the source string the problem occurred.\n */\nvar ParseError = // Error position based on passed-in Token or ParseNode.\nfunction ParseError(message, // The error message\ntoken) // An object providing position information\n{\n  this.position = void 0;\n  var error = \"KaTeX parse error: \" + message;\n  var start;\n  var loc = token && token.loc;\n\n  if (loc && loc.start <= loc.end) {\n    // If we have the input and a position, make the error a bit fancier\n    // Get the input\n    var input = loc.lexer.input; // Prepend some information\n\n    start = loc.start;\n    var end = loc.end;\n\n    if (start === input.length) {\n      error += \" at end of input: \";\n    } else {\n      error += \" at position \" + (start + 1) + \": \";\n    } // Underline token in question using combining underscores\n\n\n    var underlined = input.slice(start, end).replace(/[^]/g, \"$&\\u0332\"); // Extract some context from the input and add it to the error\n\n    var left;\n\n    if (start > 15) {\n      left = \"…\" + input.slice(start - 15, start);\n    } else {\n      left = input.slice(0, start);\n    }\n\n    var right;\n\n    if (end + 15 < input.length) {\n      right = input.slice(end, end + 15) + \"…\";\n    } else {\n      right = input.slice(end);\n    }\n\n    error += left + underlined + right;\n  } // Some hackery to make ParseError a prototype of Error\n  // See http://stackoverflow.com/a/8460753\n\n\n  var self = new Error(error);\n  self.name = \"ParseError\"; // $FlowFixMe\n\n  self.__proto__ = ParseError.prototype; // $FlowFixMe\n\n  self.position = start;\n  return self;\n}; // $FlowFixMe More hackery\n\n\nParseError.prototype.__proto__ = Error.prototype;\n/* harmony default export */ var src_ParseError = (ParseError);\n// CONCATENATED MODULE: ./src/utils.js\n/**\n * This file contains a list of utility functions which are useful in other\n * files.\n */\n\n/**\n * Return whether an element is contained in a list\n */\nvar contains = function contains(list, elem) {\n  return list.indexOf(elem) !== -1;\n};\n/**\n * Provide a default value if a setting is undefined\n * NOTE: Couldn't use `T` as the output type due to facebook/flow#5022.\n */\n\n\nvar deflt = function deflt(setting, defaultIfUndefined) {\n  return setting === undefined ? defaultIfUndefined : setting;\n}; // hyphenate and escape adapted from Facebook's React under Apache 2 license\n\n\nvar uppercase = /([A-Z])/g;\n\nvar hyphenate = function hyphenate(str) {\n  return str.replace(uppercase, \"-$1\").toLowerCase();\n};\n\nvar ESCAPE_LOOKUP = {\n  \"&\": \"&amp;\",\n  \">\": \"&gt;\",\n  \"<\": \"&lt;\",\n  \"\\\"\": \"&quot;\",\n  \"'\": \"&#x27;\"\n};\nvar ESCAPE_REGEX = /[&><\"']/g;\n/**\n * Escapes text to prevent scripting attacks.\n */\n\nfunction utils_escape(text) {\n  return String(text).replace(ESCAPE_REGEX, function (match) {\n    return ESCAPE_LOOKUP[match];\n  });\n}\n/**\n * Sometimes we want to pull out the innermost element of a group. In most\n * cases, this will just be the group itself, but when ordgroups and colors have\n * a single element, we want to pull that out.\n */\n\n\nvar getBaseElem = function getBaseElem(group) {\n  if (group.type === \"ordgroup\") {\n    if (group.body.length === 1) {\n      return getBaseElem(group.body[0]);\n    } else {\n      return group;\n    }\n  } else if (group.type === \"color\") {\n    if (group.body.length === 1) {\n      return getBaseElem(group.body[0]);\n    } else {\n      return group;\n    }\n  } else if (group.type === \"font\") {\n    return getBaseElem(group.body);\n  } else {\n    return group;\n  }\n};\n/**\n * TeXbook algorithms often reference \"character boxes\", which are simply groups\n * with a single character in them. To decide if something is a character box,\n * we find its innermost group, and see if it is a single character.\n */\n\n\nvar utils_isCharacterBox = function isCharacterBox(group) {\n  var baseElem = getBaseElem(group); // These are all they types of groups which hold single characters\n\n  return baseElem.type === \"mathord\" || baseElem.type === \"textord\" || baseElem.type === \"atom\";\n};\n\nvar assert = function assert(value) {\n  if (!value) {\n    throw new Error('Expected non-null, but got ' + String(value));\n  }\n\n  return value;\n};\n/**\n * Return the protocol of a URL, or \"_relative\" if the URL does not specify a\n * protocol (and thus is relative).\n */\n\nvar protocolFromUrl = function protocolFromUrl(url) {\n  var protocol = /^\\s*([^\\\\/#]*?)(?::|&#0*58|&#x0*3a)/i.exec(url);\n  return protocol != null ? protocol[1] : \"_relative\";\n};\n/* harmony default export */ var utils = ({\n  contains: contains,\n  deflt: deflt,\n  escape: utils_escape,\n  hyphenate: hyphenate,\n  getBaseElem: getBaseElem,\n  isCharacterBox: utils_isCharacterBox,\n  protocolFromUrl: protocolFromUrl\n});\n// CONCATENATED MODULE: ./src/Settings.js\n/* eslint no-console:0 */\n\n/**\n * This is a module for storing settings passed into KaTeX. It correctly handles\n * default settings.\n */\n\n\n\n\n/**\n * The main Settings object\n *\n * The current options stored are:\n *  - displayMode: Whether the expression should be typeset as inline math\n *                 (false, the default), meaning that the math starts in\n *                 \\textstyle and is placed in an inline-block); or as display\n *                 math (true), meaning that the math starts in \\displaystyle\n *                 and is placed in a block with vertical margin.\n */\nvar Settings_Settings =\n/*#__PURE__*/\nfunction () {\n  function Settings(options) {\n    this.displayMode = void 0;\n    this.output = void 0;\n    this.leqno = void 0;\n    this.fleqn = void 0;\n    this.throwOnError = void 0;\n    this.errorColor = void 0;\n    this.macros = void 0;\n    this.minRuleThickness = void 0;\n    this.colorIsTextColor = void 0;\n    this.strict = void 0;\n    this.trust = void 0;\n    this.maxSize = void 0;\n    this.maxExpand = void 0;\n    // allow null options\n    options = options || {};\n    this.displayMode = utils.deflt(options.displayMode, false);\n    this.output = utils.deflt(options.output, \"htmlAndMathml\");\n    this.leqno = utils.deflt(options.leqno, false);\n    this.fleqn = utils.deflt(options.fleqn, false);\n    this.throwOnError = utils.deflt(options.throwOnError, true);\n    this.errorColor = utils.deflt(options.errorColor, \"#cc0000\");\n    this.macros = options.macros || {};\n    this.minRuleThickness = Math.max(0, utils.deflt(options.minRuleThickness, 0));\n    this.colorIsTextColor = utils.deflt(options.colorIsTextColor, false);\n    this.strict = utils.deflt(options.strict, \"warn\");\n    this.trust = utils.deflt(options.trust, false);\n    this.maxSize = Math.max(0, utils.deflt(options.maxSize, Infinity));\n    this.maxExpand = Math.max(0, utils.deflt(options.maxExpand, 1000));\n  }\n  /**\n   * Report nonstrict (non-LaTeX-compatible) input.\n   * Can safely not be called if `this.strict` is false in JavaScript.\n   */\n\n\n  var _proto = Settings.prototype;\n\n  _proto.reportNonstrict = function reportNonstrict(errorCode, errorMsg, token) {\n    var strict = this.strict;\n\n    if (typeof strict === \"function\") {\n      // Allow return value of strict function to be boolean or string\n      // (or null/undefined, meaning no further processing).\n      strict = strict(errorCode, errorMsg, token);\n    }\n\n    if (!strict || strict === \"ignore\") {\n      return;\n    } else if (strict === true || strict === \"error\") {\n      throw new src_ParseError(\"LaTeX-incompatible input and strict mode is set to 'error': \" + (errorMsg + \" [\" + errorCode + \"]\"), token);\n    } else if (strict === \"warn\") {\n      typeof console !== \"undefined\" && console.warn(\"LaTeX-incompatible input and strict mode is set to 'warn': \" + (errorMsg + \" [\" + errorCode + \"]\"));\n    } else {\n      // won't happen in type-safe code\n      typeof console !== \"undefined\" && console.warn(\"LaTeX-incompatible input and strict mode is set to \" + (\"unrecognized '\" + strict + \"': \" + errorMsg + \" [\" + errorCode + \"]\"));\n    }\n  }\n  /**\n   * Check whether to apply strict (LaTeX-adhering) behavior for unusual\n   * input (like `\\\\`).  Unlike `nonstrict`, will not throw an error;\n   * instead, \"error\" translates to a return value of `true`, while \"ignore\"\n   * translates to a return value of `false`.  May still print a warning:\n   * \"warn\" prints a warning and returns `false`.\n   * This is for the second category of `errorCode`s listed in the README.\n   */\n  ;\n\n  _proto.useStrictBehavior = function useStrictBehavior(errorCode, errorMsg, token) {\n    var strict = this.strict;\n\n    if (typeof strict === \"function\") {\n      // Allow return value of strict function to be boolean or string\n      // (or null/undefined, meaning no further processing).\n      // But catch any exceptions thrown by function, treating them\n      // like \"error\".\n      try {\n        strict = strict(errorCode, errorMsg, token);\n      } catch (error) {\n        strict = \"error\";\n      }\n    }\n\n    if (!strict || strict === \"ignore\") {\n      return false;\n    } else if (strict === true || strict === \"error\") {\n      return true;\n    } else if (strict === \"warn\") {\n      typeof console !== \"undefined\" && console.warn(\"LaTeX-incompatible input and strict mode is set to 'warn': \" + (errorMsg + \" [\" + errorCode + \"]\"));\n      return false;\n    } else {\n      // won't happen in type-safe code\n      typeof console !== \"undefined\" && console.warn(\"LaTeX-incompatible input and strict mode is set to \" + (\"unrecognized '\" + strict + \"': \" + errorMsg + \" [\" + errorCode + \"]\"));\n      return false;\n    }\n  }\n  /**\n   * Check whether to test potentially dangerous input, and return\n   * `true` (trusted) or `false` (untrusted).  The sole argument `context`\n   * should be an object with `command` field specifying the relevant LaTeX\n   * command (as a string starting with `\\`), and any other arguments, etc.\n   * If `context` has a `url` field, a `protocol` field will automatically\n   * get added by this function (changing the specified object).\n   */\n  ;\n\n  _proto.isTrusted = function isTrusted(context) {\n    if (context.url && !context.protocol) {\n      context.protocol = utils.protocolFromUrl(context.url);\n    }\n\n    var trust = typeof this.trust === \"function\" ? this.trust(context) : this.trust;\n    return Boolean(trust);\n  };\n\n  return Settings;\n}();\n\n\n// CONCATENATED MODULE: ./src/Style.js\n/**\n * This file contains information and classes for the various kinds of styles\n * used in TeX. It provides a generic `Style` class, which holds information\n * about a specific style. It then provides instances of all the different kinds\n * of styles possible, and provides functions to move between them and get\n * information about them.\n */\n\n/**\n * The main style class. Contains a unique id for the style, a size (which is\n * the same for cramped and uncramped version of a style), and a cramped flag.\n */\nvar Style =\n/*#__PURE__*/\nfunction () {\n  function Style(id, size, cramped) {\n    this.id = void 0;\n    this.size = void 0;\n    this.cramped = void 0;\n    this.id = id;\n    this.size = size;\n    this.cramped = cramped;\n  }\n  /**\n   * Get the style of a superscript given a base in the current style.\n   */\n\n\n  var _proto = Style.prototype;\n\n  _proto.sup = function sup() {\n    return Style_styles[_sup[this.id]];\n  }\n  /**\n   * Get the style of a subscript given a base in the current style.\n   */\n  ;\n\n  _proto.sub = function sub() {\n    return Style_styles[_sub[this.id]];\n  }\n  /**\n   * Get the style of a fraction numerator given the fraction in the current\n   * style.\n   */\n  ;\n\n  _proto.fracNum = function fracNum() {\n    return Style_styles[_fracNum[this.id]];\n  }\n  /**\n   * Get the style of a fraction denominator given the fraction in the current\n   * style.\n   */\n  ;\n\n  _proto.fracDen = function fracDen() {\n    return Style_styles[_fracDen[this.id]];\n  }\n  /**\n   * Get the cramped version of a style (in particular, cramping a cramped style\n   * doesn't change the style).\n   */\n  ;\n\n  _proto.cramp = function cramp() {\n    return Style_styles[_cramp[this.id]];\n  }\n  /**\n   * Get a text or display version of this style.\n   */\n  ;\n\n  _proto.text = function text() {\n    return Style_styles[_text[this.id]];\n  }\n  /**\n   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)\n   */\n  ;\n\n  _proto.isTight = function isTight() {\n    return this.size >= 2;\n  };\n\n  return Style;\n}(); // Export an interface for type checking, but don't expose the implementation.\n// This way, no more styles can be generated.\n\n\n// IDs of the different styles\nvar D = 0;\nvar Dc = 1;\nvar T = 2;\nvar Tc = 3;\nvar S = 4;\nvar Sc = 5;\nvar SS = 6;\nvar SSc = 7; // Instances of the different styles\n\nvar Style_styles = [new Style(D, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)]; // Lookup tables for switching from one style to another\n\nvar _sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];\nvar _sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];\nvar _fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];\nvar _fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];\nvar _cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];\nvar _text = [D, Dc, T, Tc, T, Tc, T, Tc]; // We only export some of the styles.\n\n/* harmony default export */ var src_Style = ({\n  DISPLAY: Style_styles[D],\n  TEXT: Style_styles[T],\n  SCRIPT: Style_styles[S],\n  SCRIPTSCRIPT: Style_styles[SS]\n});\n// CONCATENATED MODULE: ./src/unicodeScripts.js\n/*\n * This file defines the Unicode scripts and script families that we\n * support. To add new scripts or families, just add a new entry to the\n * scriptData array below. Adding scripts to the scriptData array allows\n * characters from that script to appear in \\text{} environments.\n */\n\n/**\n * Each script or script family has a name and an array of blocks.\n * Each block is an array of two numbers which specify the start and\n * end points (inclusive) of a block of Unicode codepoints.\n */\n\n/**\n * Unicode block data for the families of scripts we support in \\text{}.\n * Scripts only need to appear here if they do not have font metrics.\n */\nvar scriptData = [{\n  // Latin characters beyond the Latin-1 characters we have metrics for.\n  // Needed for Czech, Hungarian and Turkish text, for example.\n  name: 'latin',\n  blocks: [[0x0100, 0x024f], // Latin Extended-A and Latin Extended-B\n  [0x0300, 0x036f]]\n}, {\n  // The Cyrillic script used by Russian and related languages.\n  // A Cyrillic subset used to be supported as explicitly defined\n  // symbols in symbols.js\n  name: 'cyrillic',\n  blocks: [[0x0400, 0x04ff]]\n}, {\n  // The Brahmic scripts of South and Southeast Asia\n  // Devanagari (0900–097F)\n  // Bengali (0980–09FF)\n  // Gurmukhi (0A00–0A7F)\n  // Gujarati (0A80–0AFF)\n  // Oriya (0B00–0B7F)\n  // Tamil (0B80–0BFF)\n  // Telugu (0C00–0C7F)\n  // Kannada (0C80–0CFF)\n  // Malayalam (0D00–0D7F)\n  // Sinhala (0D80–0DFF)\n  // Thai (0E00–0E7F)\n  // Lao (0E80–0EFF)\n  // Tibetan (0F00–0FFF)\n  // Myanmar (1000–109F)\n  name: 'brahmic',\n  blocks: [[0x0900, 0x109F]]\n}, {\n  name: 'georgian',\n  blocks: [[0x10A0, 0x10ff]]\n}, {\n  // Chinese and Japanese.\n  // The \"k\" in cjk is for Korean, but we've separated Korean out\n  name: \"cjk\",\n  blocks: [[0x3000, 0x30FF], // CJK symbols and punctuation, Hiragana, Katakana\n  [0x4E00, 0x9FAF], // CJK ideograms\n  [0xFF00, 0xFF60]]\n}, {\n  // Korean\n  name: 'hangul',\n  blocks: [[0xAC00, 0xD7AF]]\n}];\n/**\n * Given a codepoint, return the name of the script or script family\n * it is from, or null if it is not part of a known block\n */\n\nfunction scriptFromCodepoint(codepoint) {\n  for (var i = 0; i < scriptData.length; i++) {\n    var script = scriptData[i];\n\n    for (var _i = 0; _i < script.blocks.length; _i++) {\n      var block = script.blocks[_i];\n\n      if (codepoint >= block[0] && codepoint <= block[1]) {\n        return script.name;\n      }\n    }\n  }\n\n  return null;\n}\n/**\n * A flattened version of all the supported blocks in a single array.\n * This is an optimization to make supportedCodepoint() fast.\n */\n\nvar allBlocks = [];\nscriptData.forEach(function (s) {\n  return s.blocks.forEach(function (b) {\n    return allBlocks.push.apply(allBlocks, b);\n  });\n});\n/**\n * Given a codepoint, return true if it falls within one of the\n * scripts or script families defined above and false otherwise.\n *\n * Micro benchmarks shows that this is faster than\n * /[\\u3000-\\u30FF\\u4E00-\\u9FAF\\uFF00-\\uFF60\\uAC00-\\uD7AF\\u0900-\\u109F]/.test()\n * in Firefox, Chrome and Node.\n */\n\nfunction supportedCodepoint(codepoint) {\n  for (var i = 0; i < allBlocks.length; i += 2) {\n    if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n// CONCATENATED MODULE: ./src/svgGeometry.js\n/**\n * This file provides support to domTree.js and delimiter.js.\n * It's a storehouse of path geometry for SVG images.\n */\n// In all paths below, the viewBox-to-em scale is 1000:1.\nvar hLinePad = 80; // padding above a sqrt viniculum. Prevents image cropping.\n// The viniculum of a \\sqrt can be made thicker by a KaTeX rendering option.\n// Think of variable extraViniculum as two detours in the SVG path.\n// The detour begins at the lower left of the area labeled extraViniculum below.\n// The detour proceeds one extraViniculum distance up and slightly to the right,\n// displacing the radiused corner between surd and viniculum. The radius is\n// traversed as usual, then the detour resumes. It goes right, to the end of\n// the very long viniculumn, then down one extraViniculum distance,\n// after which it resumes regular path geometry for the radical.\n\n/*                                                  viniculum\n                                                   /\n         /▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒←extraViniculum\n        / █████████████████████←0.04em (40 unit) std viniculum thickness\n       / /\n      / /\n     / /\\\n    / / surd\n*/\n\nvar sqrtMain = function sqrtMain(extraViniculum, hLinePad) {\n  // sqrtMain path geometry is from glyph U221A in the font KaTeX Main\n  return \"M95,\" + (622 + extraViniculum + hLinePad) + \"\\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\\nc69,-144,104.5,-217.7,106.5,-221\\nl\" + extraViniculum / 2.075 + \" -\" + extraViniculum + \"\\nc5.3,-9.3,12,-14,20,-14\\nH400000v\" + (40 + extraViniculum) + \"H845.2724\\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\\nM\" + (834 + extraViniculum) + \" \" + hLinePad + \"h400000v\" + (40 + extraViniculum) + \"h-400000z\";\n};\n\nvar sqrtSize1 = function sqrtSize1(extraViniculum, hLinePad) {\n  // size1 is from glyph U221A in the font KaTeX_Size1-Regular\n  return \"M263,\" + (601 + extraViniculum + hLinePad) + \"c0.7,0,18,39.7,52,119\\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\\nc340,-704.7,510.7,-1060.3,512,-1067\\nl\" + extraViniculum / 2.084 + \" -\" + extraViniculum + \"\\nc4.7,-7.3,11,-11,19,-11\\nH40000v\" + (40 + extraViniculum) + \"H1012.3\\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\\nM\" + (1001 + extraViniculum) + \" \" + hLinePad + \"h400000v\" + (40 + extraViniculum) + \"h-400000z\";\n};\n\nvar sqrtSize2 = function sqrtSize2(extraViniculum, hLinePad) {\n  // size2 is from glyph U221A in the font KaTeX_Size2-Regular\n  return \"M983 \" + (10 + extraViniculum + hLinePad) + \"\\nl\" + extraViniculum / 3.13 + \" -\" + extraViniculum + \"\\nc4,-6.7,10,-10,18,-10 H400000v\" + (40 + extraViniculum) + \"\\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\\nM\" + (1001 + extraViniculum) + \" \" + hLinePad + \"h400000v\" + (40 + extraViniculum) + \"h-400000z\";\n};\n\nvar sqrtSize3 = function sqrtSize3(extraViniculum, hLinePad) {\n  // size3 is from glyph U221A in the font KaTeX_Size3-Regular\n  return \"M424,\" + (2398 + extraViniculum + hLinePad) + \"\\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\\nl\" + extraViniculum / 4.223 + \" -\" + extraViniculum + \"c4,-6.7,10,-10,18,-10 H400000\\nv\" + (40 + extraViniculum) + \"H1014.6\\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\\nc-2,6,-10,9,-24,9\\nc-8,0,-12,-0.7,-12,-2z M\" + (1001 + extraViniculum) + \" \" + hLinePad + \"\\nh400000v\" + (40 + extraViniculum) + \"h-400000z\";\n};\n\nvar sqrtSize4 = function sqrtSize4(extraViniculum, hLinePad) {\n  // size4 is from glyph U221A in the font KaTeX_Size4-Regular\n  return \"M473,\" + (2713 + extraViniculum + hLinePad) + \"\\nc339.3,-1799.3,509.3,-2700,510,-2702 l\" + extraViniculum / 5.298 + \" -\" + extraViniculum + \"\\nc3.3,-7.3,9.3,-11,18,-11 H400000v\" + (40 + extraViniculum) + \"H1017.7\\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\\n606zM\" + (1001 + extraViniculum) + \" \" + hLinePad + \"h400000v\" + (40 + extraViniculum) + \"H1017.7z\";\n};\n\nvar sqrtTall = function sqrtTall(extraViniculum, hLinePad, viewBoxHeight) {\n  // sqrtTall is from glyph U23B7 in the font KaTeX_Size4-Regular\n  // One path edge has a variable length. It runs vertically from the viniculumn\n  // to a point near (14 units) the bottom of the surd. The viniculum\n  // is normally 40 units thick. So the length of the line in question is:\n  var vertSegment = viewBoxHeight - 54 - hLinePad - extraViniculum;\n  return \"M702 \" + (extraViniculum + hLinePad) + \"H400000\" + (40 + extraViniculum) + \"\\nH742v\" + vertSegment + \"l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\\n219 661 l218 661zM702 \" + hLinePad + \"H400000v\" + (40 + extraViniculum) + \"H742z\";\n};\n\nvar sqrtPath = function sqrtPath(size, extraViniculum, viewBoxHeight) {\n  extraViniculum = 1000 * extraViniculum; // Convert from document ems to viewBox.\n\n  var path = \"\";\n\n  switch (size) {\n    case \"sqrtMain\":\n      path = sqrtMain(extraViniculum, hLinePad);\n      break;\n\n    case \"sqrtSize1\":\n      path = sqrtSize1(extraViniculum, hLinePad);\n      break;\n\n    case \"sqrtSize2\":\n      path = sqrtSize2(extraViniculum, hLinePad);\n      break;\n\n    case \"sqrtSize3\":\n      path = sqrtSize3(extraViniculum, hLinePad);\n      break;\n\n    case \"sqrtSize4\":\n      path = sqrtSize4(extraViniculum, hLinePad);\n      break;\n\n    case \"sqrtTall\":\n      path = sqrtTall(extraViniculum, hLinePad, viewBoxHeight);\n  }\n\n  return path;\n};\nvar svgGeometry_path = {\n  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main\n  doubleleftarrow: \"M262 157\\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\\nm8 0v40h399730v-40zm0 194v40h399730v-40z\",\n  // doublerightarrow is from glyph U+21D2 in font KaTeX Main\n  doublerightarrow: \"M399738 392l\\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z\",\n  // leftarrow is from glyph U+2190 in font KaTeX Main\n  leftarrow: \"M400000 241H110l3-3c68.7-52.7 113.7-120\\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\\n l-3-3h399890zM100 241v40h399900v-40z\",\n  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular\n  leftbrace: \"M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z\",\n  leftbraceunder: \"M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z\",\n  // overgroup is from the MnSymbol package (public domain)\n  leftgroup: \"M400000 80\\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\\n 435 0h399565z\",\n  leftgroupunder: \"M400000 262\\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\\n 435 219h399565z\",\n  // Harpoons are from glyph U+21BD in font KaTeX Main\n  leftharpoon: \"M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z\",\n  leftharpoonplus: \"M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\\nm0 0v40h400000v-40z\",\n  leftharpoondown: \"M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z\",\n  leftharpoondownplus: \"M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z\",\n  // hook is from glyph U+21A9 in font KaTeX Main\n  lefthook: \"M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\\n 71.5 23h399859zM103 281v-40h399897v40z\",\n  leftlinesegment: \"M40 281 V428 H0 V94 H40 V241 H400000 v40z\\nM40 281 V428 H0 V94 H40 V241 H400000 v40z\",\n  leftmapsto: \"M40 281 V448H0V74H40V241H400000v40z\\nM40 281 V448H0V74H40V241H400000v40z\",\n  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular\n  leftToFrom: \"M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z\",\n  longequal: \"M0 50 h400000 v40H0z m0 194h40000v40H0z\\nM0 50 h400000 v40H0z m0 194h40000v40H0z\",\n  midbrace: \"M200428 334\\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z\",\n  midbraceunder: \"M199572 214\\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z\",\n  oiintSize1: \"M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z\",\n  oiintSize2: \"M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\\nc0 110 84 276 504 276s502.4-166 502.4-276z\",\n  oiiintSize1: \"M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z\",\n  oiiintSize2: \"M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z\",\n  rightarrow: \"M0 241v40h399891c-47.3 35.3-84 78-110 128\\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\\n 151.7 139 205zm0 0v40h399900v-40z\",\n  rightbrace: \"M400000 542l\\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z\",\n  rightbraceunder: \"M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z\",\n  rightgroup: \"M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\\n 3-1 3-3v-38c-76-158-257-219-435-219H0z\",\n  rightgroupunder: \"M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z\",\n  rightharpoon: \"M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\\n 69.2 92 94.5zm0 0v40h399900v-40z\",\n  rightharpoonplus: \"M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z\",\n  rightharpoondown: \"M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z\",\n  rightharpoondownplus: \"M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\\nm0-194v40h400000v-40zm0 0v40h400000v-40z\",\n  righthook: \"M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z\",\n  rightlinesegment: \"M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z\",\n  rightToFrom: \"M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z\",\n  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular\n  twoheadleftarrow: \"M0 167c68 40\\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z\",\n  twoheadrightarrow: \"M400000 167\\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z\",\n  // tilde1 is a modified version of a glyph from the MnSymbol package\n  tilde1: \"M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\\n-68.267.847-113-73.952-191-73.952z\",\n  // ditto tilde2, tilde3, & tilde4\n  tilde2: \"M344 55.266c-142 0-300.638 81.316-311.5 86.418\\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z\",\n  tilde3: \"M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\\n -338 0-409-156.573-744-156.573z\",\n  tilde4: \"M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\\n -175.236-744-175.236z\",\n  // vec is from glyph U+20D7 in font KaTeX Main\n  vec: \"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\\nc-16-25.333-24-45-24-59z\",\n  // widehat1 is a modified version of a glyph from the MnSymbol package\n  widehat1: \"M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z\",\n  // ditto widehat2, widehat3, & widehat4\n  widehat2: \"M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z\",\n  widehat3: \"M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z\",\n  widehat4: \"M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z\",\n  // widecheck paths are all inverted versions of widehat\n  widecheck1: \"M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z\",\n  widecheck2: \"M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z\",\n  widecheck3: \"M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z\",\n  widecheck4: \"M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z\",\n  // The next ten paths support reaction arrows from the mhchem package.\n  // Arrows for \\ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX\n  // baraboveleftarrow is mostly from from glyph U+2190 in font KaTeX Main\n  baraboveleftarrow: \"M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z\",\n  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main\n  rightarrowabovebar: \"M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z\",\n  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.\n  // Ref from mhchem.sty: \\rlap{\\raisebox{-.22ex}{$\\kern0.5em\n  baraboveshortleftharpoon: \"M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z\",\n  rightharpoonaboveshortbar: \"M0,241 l0,40c399126,0,399993,0,399993,0\\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z\",\n  shortbaraboveleftharpoon: \"M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z\",\n  shortrightharpoonabovebar: \"M53,241l0,40c398570,0,399437,0,399437,0\\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z\"\n};\n// CONCATENATED MODULE: ./src/tree.js\n\n\n/**\n * This node represents a document fragment, which contains elements, but when\n * placed into the DOM doesn't have any representation itself. It only contains\n * children and doesn't have any DOM node properties.\n */\nvar tree_DocumentFragment =\n/*#__PURE__*/\nfunction () {\n  // HtmlDomNode\n  // Never used; needed for satisfying interface.\n  function DocumentFragment(children) {\n    this.children = void 0;\n    this.classes = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.maxFontSize = void 0;\n    this.style = void 0;\n    this.children = children;\n    this.classes = [];\n    this.height = 0;\n    this.depth = 0;\n    this.maxFontSize = 0;\n    this.style = {};\n  }\n\n  var _proto = DocumentFragment.prototype;\n\n  _proto.hasClass = function hasClass(className) {\n    return utils.contains(this.classes, className);\n  }\n  /** Convert the fragment into a node. */\n  ;\n\n  _proto.toNode = function toNode() {\n    var frag = document.createDocumentFragment();\n\n    for (var i = 0; i < this.children.length; i++) {\n      frag.appendChild(this.children[i].toNode());\n    }\n\n    return frag;\n  }\n  /** Convert the fragment into HTML markup. */\n  ;\n\n  _proto.toMarkup = function toMarkup() {\n    var markup = \"\"; // Simply concatenate the markup for the children together.\n\n    for (var i = 0; i < this.children.length; i++) {\n      markup += this.children[i].toMarkup();\n    }\n\n    return markup;\n  }\n  /**\n   * Converts the math node into a string, similar to innerText. Applies to\n   * MathDomNode's only.\n   */\n  ;\n\n  _proto.toText = function toText() {\n    // To avoid this, we would subclass documentFragment separately for\n    // MathML, but polyfills for subclassing is expensive per PR 1469.\n    // $FlowFixMe: Only works for ChildType = MathDomNode.\n    var toText = function toText(child) {\n      return child.toText();\n    };\n\n    return this.children.map(toText).join(\"\");\n  };\n\n  return DocumentFragment;\n}();\n// CONCATENATED MODULE: ./src/domTree.js\n/**\n * These objects store the data about the DOM nodes we create, as well as some\n * extra data. They can then be transformed into real DOM nodes with the\n * `toNode` function or HTML markup using `toMarkup`. They are useful for both\n * storing extra properties on the nodes, as well as providing a way to easily\n * work with the DOM.\n *\n * Similar functions for working with MathML nodes exist in mathMLTree.js.\n *\n * TODO: refactor `span` and `anchor` into common superclass when\n * target environments support class inheritance\n */\n\n\n\n\n\n/**\n * Create an HTML className based on a list of classes. In addition to joining\n * with spaces, we also remove empty classes.\n */\nvar createClass = function createClass(classes) {\n  return classes.filter(function (cls) {\n    return cls;\n  }).join(\" \");\n};\n\nvar initNode = function initNode(classes, options, style) {\n  this.classes = classes || [];\n  this.attributes = {};\n  this.height = 0;\n  this.depth = 0;\n  this.maxFontSize = 0;\n  this.style = style || {};\n\n  if (options) {\n    if (options.style.isTight()) {\n      this.classes.push(\"mtight\");\n    }\n\n    var color = options.getColor();\n\n    if (color) {\n      this.style.color = color;\n    }\n  }\n};\n/**\n * Convert into an HTML node\n */\n\n\nvar _toNode = function toNode(tagName) {\n  var node = document.createElement(tagName); // Apply the class\n\n  node.className = createClass(this.classes); // Apply inline styles\n\n  for (var style in this.style) {\n    if (this.style.hasOwnProperty(style)) {\n      // $FlowFixMe Flow doesn't seem to understand span.style's type.\n      node.style[style] = this.style[style];\n    }\n  } // Apply attributes\n\n\n  for (var attr in this.attributes) {\n    if (this.attributes.hasOwnProperty(attr)) {\n      node.setAttribute(attr, this.attributes[attr]);\n    }\n  } // Append the children, also as HTML nodes\n\n\n  for (var i = 0; i < this.children.length; i++) {\n    node.appendChild(this.children[i].toNode());\n  }\n\n  return node;\n};\n/**\n * Convert into an HTML markup string\n */\n\n\nvar _toMarkup = function toMarkup(tagName) {\n  var markup = \"<\" + tagName; // Add the class\n\n  if (this.classes.length) {\n    markup += \" class=\\\"\" + utils.escape(createClass(this.classes)) + \"\\\"\";\n  }\n\n  var styles = \"\"; // Add the styles, after hyphenation\n\n  for (var style in this.style) {\n    if (this.style.hasOwnProperty(style)) {\n      styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n    }\n  }\n\n  if (styles) {\n    markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n  } // Add the attributes\n\n\n  for (var attr in this.attributes) {\n    if (this.attributes.hasOwnProperty(attr)) {\n      markup += \" \" + attr + \"=\\\"\" + utils.escape(this.attributes[attr]) + \"\\\"\";\n    }\n  }\n\n  markup += \">\"; // Add the markup of the children, also as markup\n\n  for (var i = 0; i < this.children.length; i++) {\n    markup += this.children[i].toMarkup();\n  }\n\n  markup += \"</\" + tagName + \">\";\n  return markup;\n}; // Making the type below exact with all optional fields doesn't work due to\n// - https://github.com/facebook/flow/issues/4582\n// - https://github.com/facebook/flow/issues/5688\n// However, since *all* fields are optional, $Shape<> works as suggested in 5688\n// above.\n// This type does not include all CSS properties. Additional properties should\n// be added as needed.\n\n\n/**\n * This node represents a span node, with a className, a list of children, and\n * an inline style. It also contains information about its height, depth, and\n * maxFontSize.\n *\n * Represents two types with different uses: SvgSpan to wrap an SVG and DomSpan\n * otherwise. This typesafety is important when HTML builders access a span's\n * children.\n */\nvar domTree_Span =\n/*#__PURE__*/\nfunction () {\n  function Span(classes, children, options, style) {\n    this.children = void 0;\n    this.attributes = void 0;\n    this.classes = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.width = void 0;\n    this.maxFontSize = void 0;\n    this.style = void 0;\n    initNode.call(this, classes, options, style);\n    this.children = children || [];\n  }\n  /**\n   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not\n   * all browsers support attributes the same, and having too many custom\n   * attributes is probably bad.\n   */\n\n\n  var _proto = Span.prototype;\n\n  _proto.setAttribute = function setAttribute(attribute, value) {\n    this.attributes[attribute] = value;\n  };\n\n  _proto.hasClass = function hasClass(className) {\n    return utils.contains(this.classes, className);\n  };\n\n  _proto.toNode = function toNode() {\n    return _toNode.call(this, \"span\");\n  };\n\n  _proto.toMarkup = function toMarkup() {\n    return _toMarkup.call(this, \"span\");\n  };\n\n  return Span;\n}();\n/**\n * This node represents an anchor (<a>) element with a hyperlink.  See `span`\n * for further details.\n */\n\nvar domTree_Anchor =\n/*#__PURE__*/\nfunction () {\n  function Anchor(href, classes, children, options) {\n    this.children = void 0;\n    this.attributes = void 0;\n    this.classes = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.maxFontSize = void 0;\n    this.style = void 0;\n    initNode.call(this, classes, options);\n    this.children = children || [];\n    this.setAttribute('href', href);\n  }\n\n  var _proto2 = Anchor.prototype;\n\n  _proto2.setAttribute = function setAttribute(attribute, value) {\n    this.attributes[attribute] = value;\n  };\n\n  _proto2.hasClass = function hasClass(className) {\n    return utils.contains(this.classes, className);\n  };\n\n  _proto2.toNode = function toNode() {\n    return _toNode.call(this, \"a\");\n  };\n\n  _proto2.toMarkup = function toMarkup() {\n    return _toMarkup.call(this, \"a\");\n  };\n\n  return Anchor;\n}();\n/**\n * This node represents an image embed (<img>) element.\n */\n\nvar domTree_Img =\n/*#__PURE__*/\nfunction () {\n  function Img(src, alt, style) {\n    this.src = void 0;\n    this.alt = void 0;\n    this.classes = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.maxFontSize = void 0;\n    this.style = void 0;\n    this.alt = alt;\n    this.src = src;\n    this.classes = [\"mord\"];\n    this.style = style;\n  }\n\n  var _proto3 = Img.prototype;\n\n  _proto3.hasClass = function hasClass(className) {\n    return utils.contains(this.classes, className);\n  };\n\n  _proto3.toNode = function toNode() {\n    var node = document.createElement(\"img\");\n    node.src = this.src;\n    node.alt = this.alt;\n    node.className = \"mord\"; // Apply inline styles\n\n    for (var style in this.style) {\n      if (this.style.hasOwnProperty(style)) {\n        // $FlowFixMe\n        node.style[style] = this.style[style];\n      }\n    }\n\n    return node;\n  };\n\n  _proto3.toMarkup = function toMarkup() {\n    var markup = \"<img  src='\" + this.src + \" 'alt='\" + this.alt + \"' \"; // Add the styles, after hyphenation\n\n    var styles = \"\";\n\n    for (var style in this.style) {\n      if (this.style.hasOwnProperty(style)) {\n        styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n      }\n    }\n\n    if (styles) {\n      markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n    }\n\n    markup += \"'/>\";\n    return markup;\n  };\n\n  return Img;\n}();\nvar iCombinations = {\n  'î': \"\\u0131\\u0302\",\n  'ï': \"\\u0131\\u0308\",\n  'í': \"\\u0131\\u0301\",\n  // 'ī': '\\u0131\\u0304', // enable when we add Extended Latin\n  'ì': \"\\u0131\\u0300\"\n};\n/**\n * A symbol node contains information about a single symbol. It either renders\n * to a single text node, or a span with a single text node in it, depending on\n * whether it has CSS classes, styles, or needs italic correction.\n */\n\nvar domTree_SymbolNode =\n/*#__PURE__*/\nfunction () {\n  function SymbolNode(text, height, depth, italic, skew, width, classes, style) {\n    this.text = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.italic = void 0;\n    this.skew = void 0;\n    this.width = void 0;\n    this.maxFontSize = void 0;\n    this.classes = void 0;\n    this.style = void 0;\n    this.text = text;\n    this.height = height || 0;\n    this.depth = depth || 0;\n    this.italic = italic || 0;\n    this.skew = skew || 0;\n    this.width = width || 0;\n    this.classes = classes || [];\n    this.style = style || {};\n    this.maxFontSize = 0; // Mark text from non-Latin scripts with specific classes so that we\n    // can specify which fonts to use.  This allows us to render these\n    // characters with a serif font in situations where the browser would\n    // either default to a sans serif or render a placeholder character.\n    // We use CSS class names like cjk_fallback, hangul_fallback and\n    // brahmic_fallback. See ./unicodeScripts.js for the set of possible\n    // script names\n\n    var script = scriptFromCodepoint(this.text.charCodeAt(0));\n\n    if (script) {\n      this.classes.push(script + \"_fallback\");\n    }\n\n    if (/[îïíì]/.test(this.text)) {\n      // add ī when we add Extended Latin\n      this.text = iCombinations[this.text];\n    }\n  }\n\n  var _proto4 = SymbolNode.prototype;\n\n  _proto4.hasClass = function hasClass(className) {\n    return utils.contains(this.classes, className);\n  }\n  /**\n   * Creates a text node or span from a symbol node. Note that a span is only\n   * created if it is needed.\n   */\n  ;\n\n  _proto4.toNode = function toNode() {\n    var node = document.createTextNode(this.text);\n    var span = null;\n\n    if (this.italic > 0) {\n      span = document.createElement(\"span\");\n      span.style.marginRight = this.italic + \"em\";\n    }\n\n    if (this.classes.length > 0) {\n      span = span || document.createElement(\"span\");\n      span.className = createClass(this.classes);\n    }\n\n    for (var style in this.style) {\n      if (this.style.hasOwnProperty(style)) {\n        span = span || document.createElement(\"span\"); // $FlowFixMe Flow doesn't seem to understand span.style's type.\n\n        span.style[style] = this.style[style];\n      }\n    }\n\n    if (span) {\n      span.appendChild(node);\n      return span;\n    } else {\n      return node;\n    }\n  }\n  /**\n   * Creates markup for a symbol node.\n   */\n  ;\n\n  _proto4.toMarkup = function toMarkup() {\n    // TODO(alpert): More duplication than I'd like from\n    // span.prototype.toMarkup and symbolNode.prototype.toNode...\n    var needsSpan = false;\n    var markup = \"<span\";\n\n    if (this.classes.length) {\n      needsSpan = true;\n      markup += \" class=\\\"\";\n      markup += utils.escape(createClass(this.classes));\n      markup += \"\\\"\";\n    }\n\n    var styles = \"\";\n\n    if (this.italic > 0) {\n      styles += \"margin-right:\" + this.italic + \"em;\";\n    }\n\n    for (var style in this.style) {\n      if (this.style.hasOwnProperty(style)) {\n        styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n      }\n    }\n\n    if (styles) {\n      needsSpan = true;\n      markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n    }\n\n    var escaped = utils.escape(this.text);\n\n    if (needsSpan) {\n      markup += \">\";\n      markup += escaped;\n      markup += \"</span>\";\n      return markup;\n    } else {\n      return escaped;\n    }\n  };\n\n  return SymbolNode;\n}();\n/**\n * SVG nodes are used to render stretchy wide elements.\n */\n\nvar SvgNode =\n/*#__PURE__*/\nfunction () {\n  function SvgNode(children, attributes) {\n    this.children = void 0;\n    this.attributes = void 0;\n    this.children = children || [];\n    this.attributes = attributes || {};\n  }\n\n  var _proto5 = SvgNode.prototype;\n\n  _proto5.toNode = function toNode() {\n    var svgNS = \"http://www.w3.org/2000/svg\";\n    var node = document.createElementNS(svgNS, \"svg\"); // Apply attributes\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        node.setAttribute(attr, this.attributes[attr]);\n      }\n    }\n\n    for (var i = 0; i < this.children.length; i++) {\n      node.appendChild(this.children[i].toNode());\n    }\n\n    return node;\n  };\n\n  _proto5.toMarkup = function toMarkup() {\n    var markup = \"<svg\"; // Apply attributes\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        markup += \" \" + attr + \"='\" + this.attributes[attr] + \"'\";\n      }\n    }\n\n    markup += \">\";\n\n    for (var i = 0; i < this.children.length; i++) {\n      markup += this.children[i].toMarkup();\n    }\n\n    markup += \"</svg>\";\n    return markup;\n  };\n\n  return SvgNode;\n}();\nvar domTree_PathNode =\n/*#__PURE__*/\nfunction () {\n  function PathNode(pathName, alternate) {\n    this.pathName = void 0;\n    this.alternate = void 0;\n    this.pathName = pathName;\n    this.alternate = alternate; // Used only for \\sqrt\n  }\n\n  var _proto6 = PathNode.prototype;\n\n  _proto6.toNode = function toNode() {\n    var svgNS = \"http://www.w3.org/2000/svg\";\n    var node = document.createElementNS(svgNS, \"path\");\n\n    if (this.alternate) {\n      node.setAttribute(\"d\", this.alternate);\n    } else {\n      node.setAttribute(\"d\", svgGeometry_path[this.pathName]);\n    }\n\n    return node;\n  };\n\n  _proto6.toMarkup = function toMarkup() {\n    if (this.alternate) {\n      return \"<path d='\" + this.alternate + \"'/>\";\n    } else {\n      return \"<path d='\" + svgGeometry_path[this.pathName] + \"'/>\";\n    }\n  };\n\n  return PathNode;\n}();\nvar LineNode =\n/*#__PURE__*/\nfunction () {\n  function LineNode(attributes) {\n    this.attributes = void 0;\n    this.attributes = attributes || {};\n  }\n\n  var _proto7 = LineNode.prototype;\n\n  _proto7.toNode = function toNode() {\n    var svgNS = \"http://www.w3.org/2000/svg\";\n    var node = document.createElementNS(svgNS, \"line\"); // Apply attributes\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        node.setAttribute(attr, this.attributes[attr]);\n      }\n    }\n\n    return node;\n  };\n\n  _proto7.toMarkup = function toMarkup() {\n    var markup = \"<line\";\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        markup += \" \" + attr + \"='\" + this.attributes[attr] + \"'\";\n      }\n    }\n\n    markup += \"/>\";\n    return markup;\n  };\n\n  return LineNode;\n}();\nfunction assertSymbolDomNode(group) {\n  if (group instanceof domTree_SymbolNode) {\n    return group;\n  } else {\n    throw new Error(\"Expected symbolNode but got \" + String(group) + \".\");\n  }\n}\nfunction assertSpan(group) {\n  if (group instanceof domTree_Span) {\n    return group;\n  } else {\n    throw new Error(\"Expected span<HtmlDomNode> but got \" + String(group) + \".\");\n  }\n}\n// CONCATENATED MODULE: ./submodules/katex-fonts/fontMetricsData.js\n// This file is GENERATED by buildMetrics.sh. DO NOT MODIFY.\n/* harmony default export */ var fontMetricsData = ({\n  \"AMS-Regular\": {\n    \"65\": [0, 0.68889, 0, 0, 0.72222],\n    \"66\": [0, 0.68889, 0, 0, 0.66667],\n    \"67\": [0, 0.68889, 0, 0, 0.72222],\n    \"68\": [0, 0.68889, 0, 0, 0.72222],\n    \"69\": [0, 0.68889, 0, 0, 0.66667],\n    \"70\": [0, 0.68889, 0, 0, 0.61111],\n    \"71\": [0, 0.68889, 0, 0, 0.77778],\n    \"72\": [0, 0.68889, 0, 0, 0.77778],\n    \"73\": [0, 0.68889, 0, 0, 0.38889],\n    \"74\": [0.16667, 0.68889, 0, 0, 0.5],\n    \"75\": [0, 0.68889, 0, 0, 0.77778],\n    \"76\": [0, 0.68889, 0, 0, 0.66667],\n    \"77\": [0, 0.68889, 0, 0, 0.94445],\n    \"78\": [0, 0.68889, 0, 0, 0.72222],\n    \"79\": [0.16667, 0.68889, 0, 0, 0.77778],\n    \"80\": [0, 0.68889, 0, 0, 0.61111],\n    \"81\": [0.16667, 0.68889, 0, 0, 0.77778],\n    \"82\": [0, 0.68889, 0, 0, 0.72222],\n    \"83\": [0, 0.68889, 0, 0, 0.55556],\n    \"84\": [0, 0.68889, 0, 0, 0.66667],\n    \"85\": [0, 0.68889, 0, 0, 0.72222],\n    \"86\": [0, 0.68889, 0, 0, 0.72222],\n    \"87\": [0, 0.68889, 0, 0, 1.0],\n    \"88\": [0, 0.68889, 0, 0, 0.72222],\n    \"89\": [0, 0.68889, 0, 0, 0.72222],\n    \"90\": [0, 0.68889, 0, 0, 0.66667],\n    \"107\": [0, 0.68889, 0, 0, 0.55556],\n    \"165\": [0, 0.675, 0.025, 0, 0.75],\n    \"174\": [0.15559, 0.69224, 0, 0, 0.94666],\n    \"240\": [0, 0.68889, 0, 0, 0.55556],\n    \"295\": [0, 0.68889, 0, 0, 0.54028],\n    \"710\": [0, 0.825, 0, 0, 2.33334],\n    \"732\": [0, 0.9, 0, 0, 2.33334],\n    \"770\": [0, 0.825, 0, 0, 2.33334],\n    \"771\": [0, 0.9, 0, 0, 2.33334],\n    \"989\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"1008\": [0, 0.43056, 0.04028, 0, 0.66667],\n    \"8245\": [0, 0.54986, 0, 0, 0.275],\n    \"8463\": [0, 0.68889, 0, 0, 0.54028],\n    \"8487\": [0, 0.68889, 0, 0, 0.72222],\n    \"8498\": [0, 0.68889, 0, 0, 0.55556],\n    \"8502\": [0, 0.68889, 0, 0, 0.66667],\n    \"8503\": [0, 0.68889, 0, 0, 0.44445],\n    \"8504\": [0, 0.68889, 0, 0, 0.66667],\n    \"8513\": [0, 0.68889, 0, 0, 0.63889],\n    \"8592\": [-0.03598, 0.46402, 0, 0, 0.5],\n    \"8594\": [-0.03598, 0.46402, 0, 0, 0.5],\n    \"8602\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8603\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8606\": [0.01354, 0.52239, 0, 0, 1.0],\n    \"8608\": [0.01354, 0.52239, 0, 0, 1.0],\n    \"8610\": [0.01354, 0.52239, 0, 0, 1.11111],\n    \"8611\": [0.01354, 0.52239, 0, 0, 1.11111],\n    \"8619\": [0, 0.54986, 0, 0, 1.0],\n    \"8620\": [0, 0.54986, 0, 0, 1.0],\n    \"8621\": [-0.13313, 0.37788, 0, 0, 1.38889],\n    \"8622\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8624\": [0, 0.69224, 0, 0, 0.5],\n    \"8625\": [0, 0.69224, 0, 0, 0.5],\n    \"8630\": [0, 0.43056, 0, 0, 1.0],\n    \"8631\": [0, 0.43056, 0, 0, 1.0],\n    \"8634\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8635\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8638\": [0.19444, 0.69224, 0, 0, 0.41667],\n    \"8639\": [0.19444, 0.69224, 0, 0, 0.41667],\n    \"8642\": [0.19444, 0.69224, 0, 0, 0.41667],\n    \"8643\": [0.19444, 0.69224, 0, 0, 0.41667],\n    \"8644\": [0.1808, 0.675, 0, 0, 1.0],\n    \"8646\": [0.1808, 0.675, 0, 0, 1.0],\n    \"8647\": [0.1808, 0.675, 0, 0, 1.0],\n    \"8648\": [0.19444, 0.69224, 0, 0, 0.83334],\n    \"8649\": [0.1808, 0.675, 0, 0, 1.0],\n    \"8650\": [0.19444, 0.69224, 0, 0, 0.83334],\n    \"8651\": [0.01354, 0.52239, 0, 0, 1.0],\n    \"8652\": [0.01354, 0.52239, 0, 0, 1.0],\n    \"8653\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8654\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8655\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8666\": [0.13667, 0.63667, 0, 0, 1.0],\n    \"8667\": [0.13667, 0.63667, 0, 0, 1.0],\n    \"8669\": [-0.13313, 0.37788, 0, 0, 1.0],\n    \"8672\": [-0.064, 0.437, 0, 0, 1.334],\n    \"8674\": [-0.064, 0.437, 0, 0, 1.334],\n    \"8705\": [0, 0.825, 0, 0, 0.5],\n    \"8708\": [0, 0.68889, 0, 0, 0.55556],\n    \"8709\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8717\": [0, 0.43056, 0, 0, 0.42917],\n    \"8722\": [-0.03598, 0.46402, 0, 0, 0.5],\n    \"8724\": [0.08198, 0.69224, 0, 0, 0.77778],\n    \"8726\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8733\": [0, 0.69224, 0, 0, 0.77778],\n    \"8736\": [0, 0.69224, 0, 0, 0.72222],\n    \"8737\": [0, 0.69224, 0, 0, 0.72222],\n    \"8738\": [0.03517, 0.52239, 0, 0, 0.72222],\n    \"8739\": [0.08167, 0.58167, 0, 0, 0.22222],\n    \"8740\": [0.25142, 0.74111, 0, 0, 0.27778],\n    \"8741\": [0.08167, 0.58167, 0, 0, 0.38889],\n    \"8742\": [0.25142, 0.74111, 0, 0, 0.5],\n    \"8756\": [0, 0.69224, 0, 0, 0.66667],\n    \"8757\": [0, 0.69224, 0, 0, 0.66667],\n    \"8764\": [-0.13313, 0.36687, 0, 0, 0.77778],\n    \"8765\": [-0.13313, 0.37788, 0, 0, 0.77778],\n    \"8769\": [-0.13313, 0.36687, 0, 0, 0.77778],\n    \"8770\": [-0.03625, 0.46375, 0, 0, 0.77778],\n    \"8774\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8776\": [-0.01688, 0.48312, 0, 0, 0.77778],\n    \"8778\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8782\": [0.06062, 0.54986, 0, 0, 0.77778],\n    \"8783\": [0.06062, 0.54986, 0, 0, 0.77778],\n    \"8785\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8786\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8787\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8790\": [0, 0.69224, 0, 0, 0.77778],\n    \"8791\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8796\": [0.08198, 0.91667, 0, 0, 0.77778],\n    \"8806\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"8807\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"8808\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"8809\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"8812\": [0.25583, 0.75583, 0, 0, 0.5],\n    \"8814\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8815\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8816\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8817\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8818\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8819\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8822\": [0.1808, 0.675, 0, 0, 0.77778],\n    \"8823\": [0.1808, 0.675, 0, 0, 0.77778],\n    \"8828\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8829\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8830\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8831\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8832\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8833\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8840\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8841\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8842\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8843\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8847\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8848\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8858\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8859\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8861\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8862\": [0, 0.675, 0, 0, 0.77778],\n    \"8863\": [0, 0.675, 0, 0, 0.77778],\n    \"8864\": [0, 0.675, 0, 0, 0.77778],\n    \"8865\": [0, 0.675, 0, 0, 0.77778],\n    \"8872\": [0, 0.69224, 0, 0, 0.61111],\n    \"8873\": [0, 0.69224, 0, 0, 0.72222],\n    \"8874\": [0, 0.69224, 0, 0, 0.88889],\n    \"8876\": [0, 0.68889, 0, 0, 0.61111],\n    \"8877\": [0, 0.68889, 0, 0, 0.61111],\n    \"8878\": [0, 0.68889, 0, 0, 0.72222],\n    \"8879\": [0, 0.68889, 0, 0, 0.72222],\n    \"8882\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8883\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8884\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8885\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8888\": [0, 0.54986, 0, 0, 1.11111],\n    \"8890\": [0.19444, 0.43056, 0, 0, 0.55556],\n    \"8891\": [0.19444, 0.69224, 0, 0, 0.61111],\n    \"8892\": [0.19444, 0.69224, 0, 0, 0.61111],\n    \"8901\": [0, 0.54986, 0, 0, 0.27778],\n    \"8903\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8905\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8906\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8907\": [0, 0.69224, 0, 0, 0.77778],\n    \"8908\": [0, 0.69224, 0, 0, 0.77778],\n    \"8909\": [-0.03598, 0.46402, 0, 0, 0.77778],\n    \"8910\": [0, 0.54986, 0, 0, 0.76042],\n    \"8911\": [0, 0.54986, 0, 0, 0.76042],\n    \"8912\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8913\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8914\": [0, 0.54986, 0, 0, 0.66667],\n    \"8915\": [0, 0.54986, 0, 0, 0.66667],\n    \"8916\": [0, 0.69224, 0, 0, 0.66667],\n    \"8918\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8919\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8920\": [0.03517, 0.54986, 0, 0, 1.33334],\n    \"8921\": [0.03517, 0.54986, 0, 0, 1.33334],\n    \"8922\": [0.38569, 0.88569, 0, 0, 0.77778],\n    \"8923\": [0.38569, 0.88569, 0, 0, 0.77778],\n    \"8926\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8927\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8928\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8929\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8934\": [0.23222, 0.74111, 0, 0, 0.77778],\n    \"8935\": [0.23222, 0.74111, 0, 0, 0.77778],\n    \"8936\": [0.23222, 0.74111, 0, 0, 0.77778],\n    \"8937\": [0.23222, 0.74111, 0, 0, 0.77778],\n    \"8938\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8939\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8940\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8941\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8994\": [0.19444, 0.69224, 0, 0, 0.77778],\n    \"8995\": [0.19444, 0.69224, 0, 0, 0.77778],\n    \"9416\": [0.15559, 0.69224, 0, 0, 0.90222],\n    \"9484\": [0, 0.69224, 0, 0, 0.5],\n    \"9488\": [0, 0.69224, 0, 0, 0.5],\n    \"9492\": [0, 0.37788, 0, 0, 0.5],\n    \"9496\": [0, 0.37788, 0, 0, 0.5],\n    \"9585\": [0.19444, 0.68889, 0, 0, 0.88889],\n    \"9586\": [0.19444, 0.74111, 0, 0, 0.88889],\n    \"9632\": [0, 0.675, 0, 0, 0.77778],\n    \"9633\": [0, 0.675, 0, 0, 0.77778],\n    \"9650\": [0, 0.54986, 0, 0, 0.72222],\n    \"9651\": [0, 0.54986, 0, 0, 0.72222],\n    \"9654\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"9660\": [0, 0.54986, 0, 0, 0.72222],\n    \"9661\": [0, 0.54986, 0, 0, 0.72222],\n    \"9664\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"9674\": [0.11111, 0.69224, 0, 0, 0.66667],\n    \"9733\": [0.19444, 0.69224, 0, 0, 0.94445],\n    \"10003\": [0, 0.69224, 0, 0, 0.83334],\n    \"10016\": [0, 0.69224, 0, 0, 0.83334],\n    \"10731\": [0.11111, 0.69224, 0, 0, 0.66667],\n    \"10846\": [0.19444, 0.75583, 0, 0, 0.61111],\n    \"10877\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"10878\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"10885\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"10886\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"10887\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"10888\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"10889\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10890\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10891\": [0.48256, 0.98256, 0, 0, 0.77778],\n    \"10892\": [0.48256, 0.98256, 0, 0, 0.77778],\n    \"10901\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"10902\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"10933\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"10934\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"10935\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10936\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10937\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10938\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10949\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"10950\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"10955\": [0.28481, 0.79383, 0, 0, 0.77778],\n    \"10956\": [0.28481, 0.79383, 0, 0, 0.77778],\n    \"57350\": [0.08167, 0.58167, 0, 0, 0.22222],\n    \"57351\": [0.08167, 0.58167, 0, 0, 0.38889],\n    \"57352\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"57353\": [0, 0.43056, 0.04028, 0, 0.66667],\n    \"57356\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57357\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57358\": [0.41951, 0.91951, 0, 0, 0.77778],\n    \"57359\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"57360\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"57361\": [0.41951, 0.91951, 0, 0, 0.77778],\n    \"57366\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57367\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57368\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57369\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57370\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"57371\": [0.13597, 0.63597, 0, 0, 0.77778]\n  },\n  \"Caligraphic-Regular\": {\n    \"48\": [0, 0.43056, 0, 0, 0.5],\n    \"49\": [0, 0.43056, 0, 0, 0.5],\n    \"50\": [0, 0.43056, 0, 0, 0.5],\n    \"51\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"52\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"53\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"54\": [0, 0.64444, 0, 0, 0.5],\n    \"55\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"56\": [0, 0.64444, 0, 0, 0.5],\n    \"57\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"65\": [0, 0.68333, 0, 0.19445, 0.79847],\n    \"66\": [0, 0.68333, 0.03041, 0.13889, 0.65681],\n    \"67\": [0, 0.68333, 0.05834, 0.13889, 0.52653],\n    \"68\": [0, 0.68333, 0.02778, 0.08334, 0.77139],\n    \"69\": [0, 0.68333, 0.08944, 0.11111, 0.52778],\n    \"70\": [0, 0.68333, 0.09931, 0.11111, 0.71875],\n    \"71\": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],\n    \"72\": [0, 0.68333, 0.00965, 0.11111, 0.84452],\n    \"73\": [0, 0.68333, 0.07382, 0, 0.54452],\n    \"74\": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],\n    \"75\": [0, 0.68333, 0.01445, 0.05556, 0.76195],\n    \"76\": [0, 0.68333, 0, 0.13889, 0.68972],\n    \"77\": [0, 0.68333, 0, 0.13889, 1.2009],\n    \"78\": [0, 0.68333, 0.14736, 0.08334, 0.82049],\n    \"79\": [0, 0.68333, 0.02778, 0.11111, 0.79611],\n    \"80\": [0, 0.68333, 0.08222, 0.08334, 0.69556],\n    \"81\": [0.09722, 0.68333, 0, 0.11111, 0.81667],\n    \"82\": [0, 0.68333, 0, 0.08334, 0.8475],\n    \"83\": [0, 0.68333, 0.075, 0.13889, 0.60556],\n    \"84\": [0, 0.68333, 0.25417, 0, 0.54464],\n    \"85\": [0, 0.68333, 0.09931, 0.08334, 0.62583],\n    \"86\": [0, 0.68333, 0.08222, 0, 0.61278],\n    \"87\": [0, 0.68333, 0.08222, 0.08334, 0.98778],\n    \"88\": [0, 0.68333, 0.14643, 0.13889, 0.7133],\n    \"89\": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],\n    \"90\": [0, 0.68333, 0.07944, 0.13889, 0.72473]\n  },\n  \"Fraktur-Regular\": {\n    \"33\": [0, 0.69141, 0, 0, 0.29574],\n    \"34\": [0, 0.69141, 0, 0, 0.21471],\n    \"38\": [0, 0.69141, 0, 0, 0.73786],\n    \"39\": [0, 0.69141, 0, 0, 0.21201],\n    \"40\": [0.24982, 0.74947, 0, 0, 0.38865],\n    \"41\": [0.24982, 0.74947, 0, 0, 0.38865],\n    \"42\": [0, 0.62119, 0, 0, 0.27764],\n    \"43\": [0.08319, 0.58283, 0, 0, 0.75623],\n    \"44\": [0, 0.10803, 0, 0, 0.27764],\n    \"45\": [0.08319, 0.58283, 0, 0, 0.75623],\n    \"46\": [0, 0.10803, 0, 0, 0.27764],\n    \"47\": [0.24982, 0.74947, 0, 0, 0.50181],\n    \"48\": [0, 0.47534, 0, 0, 0.50181],\n    \"49\": [0, 0.47534, 0, 0, 0.50181],\n    \"50\": [0, 0.47534, 0, 0, 0.50181],\n    \"51\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"52\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"53\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"54\": [0, 0.69141, 0, 0, 0.50181],\n    \"55\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"56\": [0, 0.69141, 0, 0, 0.50181],\n    \"57\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"58\": [0, 0.47534, 0, 0, 0.21606],\n    \"59\": [0.12604, 0.47534, 0, 0, 0.21606],\n    \"61\": [-0.13099, 0.36866, 0, 0, 0.75623],\n    \"63\": [0, 0.69141, 0, 0, 0.36245],\n    \"65\": [0, 0.69141, 0, 0, 0.7176],\n    \"66\": [0, 0.69141, 0, 0, 0.88397],\n    \"67\": [0, 0.69141, 0, 0, 0.61254],\n    \"68\": [0, 0.69141, 0, 0, 0.83158],\n    \"69\": [0, 0.69141, 0, 0, 0.66278],\n    \"70\": [0.12604, 0.69141, 0, 0, 0.61119],\n    \"71\": [0, 0.69141, 0, 0, 0.78539],\n    \"72\": [0.06302, 0.69141, 0, 0, 0.7203],\n    \"73\": [0, 0.69141, 0, 0, 0.55448],\n    \"74\": [0.12604, 0.69141, 0, 0, 0.55231],\n    \"75\": [0, 0.69141, 0, 0, 0.66845],\n    \"76\": [0, 0.69141, 0, 0, 0.66602],\n    \"77\": [0, 0.69141, 0, 0, 1.04953],\n    \"78\": [0, 0.69141, 0, 0, 0.83212],\n    \"79\": [0, 0.69141, 0, 0, 0.82699],\n    \"80\": [0.18906, 0.69141, 0, 0, 0.82753],\n    \"81\": [0.03781, 0.69141, 0, 0, 0.82699],\n    \"82\": [0, 0.69141, 0, 0, 0.82807],\n    \"83\": [0, 0.69141, 0, 0, 0.82861],\n    \"84\": [0, 0.69141, 0, 0, 0.66899],\n    \"85\": [0, 0.69141, 0, 0, 0.64576],\n    \"86\": [0, 0.69141, 0, 0, 0.83131],\n    \"87\": [0, 0.69141, 0, 0, 1.04602],\n    \"88\": [0, 0.69141, 0, 0, 0.71922],\n    \"89\": [0.18906, 0.69141, 0, 0, 0.83293],\n    \"90\": [0.12604, 0.69141, 0, 0, 0.60201],\n    \"91\": [0.24982, 0.74947, 0, 0, 0.27764],\n    \"93\": [0.24982, 0.74947, 0, 0, 0.27764],\n    \"94\": [0, 0.69141, 0, 0, 0.49965],\n    \"97\": [0, 0.47534, 0, 0, 0.50046],\n    \"98\": [0, 0.69141, 0, 0, 0.51315],\n    \"99\": [0, 0.47534, 0, 0, 0.38946],\n    \"100\": [0, 0.62119, 0, 0, 0.49857],\n    \"101\": [0, 0.47534, 0, 0, 0.40053],\n    \"102\": [0.18906, 0.69141, 0, 0, 0.32626],\n    \"103\": [0.18906, 0.47534, 0, 0, 0.5037],\n    \"104\": [0.18906, 0.69141, 0, 0, 0.52126],\n    \"105\": [0, 0.69141, 0, 0, 0.27899],\n    \"106\": [0, 0.69141, 0, 0, 0.28088],\n    \"107\": [0, 0.69141, 0, 0, 0.38946],\n    \"108\": [0, 0.69141, 0, 0, 0.27953],\n    \"109\": [0, 0.47534, 0, 0, 0.76676],\n    \"110\": [0, 0.47534, 0, 0, 0.52666],\n    \"111\": [0, 0.47534, 0, 0, 0.48885],\n    \"112\": [0.18906, 0.52396, 0, 0, 0.50046],\n    \"113\": [0.18906, 0.47534, 0, 0, 0.48912],\n    \"114\": [0, 0.47534, 0, 0, 0.38919],\n    \"115\": [0, 0.47534, 0, 0, 0.44266],\n    \"116\": [0, 0.62119, 0, 0, 0.33301],\n    \"117\": [0, 0.47534, 0, 0, 0.5172],\n    \"118\": [0, 0.52396, 0, 0, 0.5118],\n    \"119\": [0, 0.52396, 0, 0, 0.77351],\n    \"120\": [0.18906, 0.47534, 0, 0, 0.38865],\n    \"121\": [0.18906, 0.47534, 0, 0, 0.49884],\n    \"122\": [0.18906, 0.47534, 0, 0, 0.39054],\n    \"8216\": [0, 0.69141, 0, 0, 0.21471],\n    \"8217\": [0, 0.69141, 0, 0, 0.21471],\n    \"58112\": [0, 0.62119, 0, 0, 0.49749],\n    \"58113\": [0, 0.62119, 0, 0, 0.4983],\n    \"58114\": [0.18906, 0.69141, 0, 0, 0.33328],\n    \"58115\": [0.18906, 0.69141, 0, 0, 0.32923],\n    \"58116\": [0.18906, 0.47534, 0, 0, 0.50343],\n    \"58117\": [0, 0.69141, 0, 0, 0.33301],\n    \"58118\": [0, 0.62119, 0, 0, 0.33409],\n    \"58119\": [0, 0.47534, 0, 0, 0.50073]\n  },\n  \"Main-Bold\": {\n    \"33\": [0, 0.69444, 0, 0, 0.35],\n    \"34\": [0, 0.69444, 0, 0, 0.60278],\n    \"35\": [0.19444, 0.69444, 0, 0, 0.95833],\n    \"36\": [0.05556, 0.75, 0, 0, 0.575],\n    \"37\": [0.05556, 0.75, 0, 0, 0.95833],\n    \"38\": [0, 0.69444, 0, 0, 0.89444],\n    \"39\": [0, 0.69444, 0, 0, 0.31944],\n    \"40\": [0.25, 0.75, 0, 0, 0.44722],\n    \"41\": [0.25, 0.75, 0, 0, 0.44722],\n    \"42\": [0, 0.75, 0, 0, 0.575],\n    \"43\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"44\": [0.19444, 0.15556, 0, 0, 0.31944],\n    \"45\": [0, 0.44444, 0, 0, 0.38333],\n    \"46\": [0, 0.15556, 0, 0, 0.31944],\n    \"47\": [0.25, 0.75, 0, 0, 0.575],\n    \"48\": [0, 0.64444, 0, 0, 0.575],\n    \"49\": [0, 0.64444, 0, 0, 0.575],\n    \"50\": [0, 0.64444, 0, 0, 0.575],\n    \"51\": [0, 0.64444, 0, 0, 0.575],\n    \"52\": [0, 0.64444, 0, 0, 0.575],\n    \"53\": [0, 0.64444, 0, 0, 0.575],\n    \"54\": [0, 0.64444, 0, 0, 0.575],\n    \"55\": [0, 0.64444, 0, 0, 0.575],\n    \"56\": [0, 0.64444, 0, 0, 0.575],\n    \"57\": [0, 0.64444, 0, 0, 0.575],\n    \"58\": [0, 0.44444, 0, 0, 0.31944],\n    \"59\": [0.19444, 0.44444, 0, 0, 0.31944],\n    \"60\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"61\": [-0.10889, 0.39111, 0, 0, 0.89444],\n    \"62\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"63\": [0, 0.69444, 0, 0, 0.54305],\n    \"64\": [0, 0.69444, 0, 0, 0.89444],\n    \"65\": [0, 0.68611, 0, 0, 0.86944],\n    \"66\": [0, 0.68611, 0, 0, 0.81805],\n    \"67\": [0, 0.68611, 0, 0, 0.83055],\n    \"68\": [0, 0.68611, 0, 0, 0.88194],\n    \"69\": [0, 0.68611, 0, 0, 0.75555],\n    \"70\": [0, 0.68611, 0, 0, 0.72361],\n    \"71\": [0, 0.68611, 0, 0, 0.90416],\n    \"72\": [0, 0.68611, 0, 0, 0.9],\n    \"73\": [0, 0.68611, 0, 0, 0.43611],\n    \"74\": [0, 0.68611, 0, 0, 0.59444],\n    \"75\": [0, 0.68611, 0, 0, 0.90138],\n    \"76\": [0, 0.68611, 0, 0, 0.69166],\n    \"77\": [0, 0.68611, 0, 0, 1.09166],\n    \"78\": [0, 0.68611, 0, 0, 0.9],\n    \"79\": [0, 0.68611, 0, 0, 0.86388],\n    \"80\": [0, 0.68611, 0, 0, 0.78611],\n    \"81\": [0.19444, 0.68611, 0, 0, 0.86388],\n    \"82\": [0, 0.68611, 0, 0, 0.8625],\n    \"83\": [0, 0.68611, 0, 0, 0.63889],\n    \"84\": [0, 0.68611, 0, 0, 0.8],\n    \"85\": [0, 0.68611, 0, 0, 0.88472],\n    \"86\": [0, 0.68611, 0.01597, 0, 0.86944],\n    \"87\": [0, 0.68611, 0.01597, 0, 1.18888],\n    \"88\": [0, 0.68611, 0, 0, 0.86944],\n    \"89\": [0, 0.68611, 0.02875, 0, 0.86944],\n    \"90\": [0, 0.68611, 0, 0, 0.70277],\n    \"91\": [0.25, 0.75, 0, 0, 0.31944],\n    \"92\": [0.25, 0.75, 0, 0, 0.575],\n    \"93\": [0.25, 0.75, 0, 0, 0.31944],\n    \"94\": [0, 0.69444, 0, 0, 0.575],\n    \"95\": [0.31, 0.13444, 0.03194, 0, 0.575],\n    \"97\": [0, 0.44444, 0, 0, 0.55902],\n    \"98\": [0, 0.69444, 0, 0, 0.63889],\n    \"99\": [0, 0.44444, 0, 0, 0.51111],\n    \"100\": [0, 0.69444, 0, 0, 0.63889],\n    \"101\": [0, 0.44444, 0, 0, 0.52708],\n    \"102\": [0, 0.69444, 0.10903, 0, 0.35139],\n    \"103\": [0.19444, 0.44444, 0.01597, 0, 0.575],\n    \"104\": [0, 0.69444, 0, 0, 0.63889],\n    \"105\": [0, 0.69444, 0, 0, 0.31944],\n    \"106\": [0.19444, 0.69444, 0, 0, 0.35139],\n    \"107\": [0, 0.69444, 0, 0, 0.60694],\n    \"108\": [0, 0.69444, 0, 0, 0.31944],\n    \"109\": [0, 0.44444, 0, 0, 0.95833],\n    \"110\": [0, 0.44444, 0, 0, 0.63889],\n    \"111\": [0, 0.44444, 0, 0, 0.575],\n    \"112\": [0.19444, 0.44444, 0, 0, 0.63889],\n    \"113\": [0.19444, 0.44444, 0, 0, 0.60694],\n    \"114\": [0, 0.44444, 0, 0, 0.47361],\n    \"115\": [0, 0.44444, 0, 0, 0.45361],\n    \"116\": [0, 0.63492, 0, 0, 0.44722],\n    \"117\": [0, 0.44444, 0, 0, 0.63889],\n    \"118\": [0, 0.44444, 0.01597, 0, 0.60694],\n    \"119\": [0, 0.44444, 0.01597, 0, 0.83055],\n    \"120\": [0, 0.44444, 0, 0, 0.60694],\n    \"121\": [0.19444, 0.44444, 0.01597, 0, 0.60694],\n    \"122\": [0, 0.44444, 0, 0, 0.51111],\n    \"123\": [0.25, 0.75, 0, 0, 0.575],\n    \"124\": [0.25, 0.75, 0, 0, 0.31944],\n    \"125\": [0.25, 0.75, 0, 0, 0.575],\n    \"126\": [0.35, 0.34444, 0, 0, 0.575],\n    \"168\": [0, 0.69444, 0, 0, 0.575],\n    \"172\": [0, 0.44444, 0, 0, 0.76666],\n    \"176\": [0, 0.69444, 0, 0, 0.86944],\n    \"177\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"184\": [0.17014, 0, 0, 0, 0.51111],\n    \"198\": [0, 0.68611, 0, 0, 1.04166],\n    \"215\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"216\": [0.04861, 0.73472, 0, 0, 0.89444],\n    \"223\": [0, 0.69444, 0, 0, 0.59722],\n    \"230\": [0, 0.44444, 0, 0, 0.83055],\n    \"247\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"248\": [0.09722, 0.54167, 0, 0, 0.575],\n    \"305\": [0, 0.44444, 0, 0, 0.31944],\n    \"338\": [0, 0.68611, 0, 0, 1.16944],\n    \"339\": [0, 0.44444, 0, 0, 0.89444],\n    \"567\": [0.19444, 0.44444, 0, 0, 0.35139],\n    \"710\": [0, 0.69444, 0, 0, 0.575],\n    \"711\": [0, 0.63194, 0, 0, 0.575],\n    \"713\": [0, 0.59611, 0, 0, 0.575],\n    \"714\": [0, 0.69444, 0, 0, 0.575],\n    \"715\": [0, 0.69444, 0, 0, 0.575],\n    \"728\": [0, 0.69444, 0, 0, 0.575],\n    \"729\": [0, 0.69444, 0, 0, 0.31944],\n    \"730\": [0, 0.69444, 0, 0, 0.86944],\n    \"732\": [0, 0.69444, 0, 0, 0.575],\n    \"733\": [0, 0.69444, 0, 0, 0.575],\n    \"915\": [0, 0.68611, 0, 0, 0.69166],\n    \"916\": [0, 0.68611, 0, 0, 0.95833],\n    \"920\": [0, 0.68611, 0, 0, 0.89444],\n    \"923\": [0, 0.68611, 0, 0, 0.80555],\n    \"926\": [0, 0.68611, 0, 0, 0.76666],\n    \"928\": [0, 0.68611, 0, 0, 0.9],\n    \"931\": [0, 0.68611, 0, 0, 0.83055],\n    \"933\": [0, 0.68611, 0, 0, 0.89444],\n    \"934\": [0, 0.68611, 0, 0, 0.83055],\n    \"936\": [0, 0.68611, 0, 0, 0.89444],\n    \"937\": [0, 0.68611, 0, 0, 0.83055],\n    \"8211\": [0, 0.44444, 0.03194, 0, 0.575],\n    \"8212\": [0, 0.44444, 0.03194, 0, 1.14999],\n    \"8216\": [0, 0.69444, 0, 0, 0.31944],\n    \"8217\": [0, 0.69444, 0, 0, 0.31944],\n    \"8220\": [0, 0.69444, 0, 0, 0.60278],\n    \"8221\": [0, 0.69444, 0, 0, 0.60278],\n    \"8224\": [0.19444, 0.69444, 0, 0, 0.51111],\n    \"8225\": [0.19444, 0.69444, 0, 0, 0.51111],\n    \"8242\": [0, 0.55556, 0, 0, 0.34444],\n    \"8407\": [0, 0.72444, 0.15486, 0, 0.575],\n    \"8463\": [0, 0.69444, 0, 0, 0.66759],\n    \"8465\": [0, 0.69444, 0, 0, 0.83055],\n    \"8467\": [0, 0.69444, 0, 0, 0.47361],\n    \"8472\": [0.19444, 0.44444, 0, 0, 0.74027],\n    \"8476\": [0, 0.69444, 0, 0, 0.83055],\n    \"8501\": [0, 0.69444, 0, 0, 0.70277],\n    \"8592\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8593\": [0.19444, 0.69444, 0, 0, 0.575],\n    \"8594\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8595\": [0.19444, 0.69444, 0, 0, 0.575],\n    \"8596\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8597\": [0.25, 0.75, 0, 0, 0.575],\n    \"8598\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"8599\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"8600\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"8601\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"8636\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8637\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8640\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8641\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8656\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8657\": [0.19444, 0.69444, 0, 0, 0.70277],\n    \"8658\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8659\": [0.19444, 0.69444, 0, 0, 0.70277],\n    \"8660\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8661\": [0.25, 0.75, 0, 0, 0.70277],\n    \"8704\": [0, 0.69444, 0, 0, 0.63889],\n    \"8706\": [0, 0.69444, 0.06389, 0, 0.62847],\n    \"8707\": [0, 0.69444, 0, 0, 0.63889],\n    \"8709\": [0.05556, 0.75, 0, 0, 0.575],\n    \"8711\": [0, 0.68611, 0, 0, 0.95833],\n    \"8712\": [0.08556, 0.58556, 0, 0, 0.76666],\n    \"8715\": [0.08556, 0.58556, 0, 0, 0.76666],\n    \"8722\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8723\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8725\": [0.25, 0.75, 0, 0, 0.575],\n    \"8726\": [0.25, 0.75, 0, 0, 0.575],\n    \"8727\": [-0.02778, 0.47222, 0, 0, 0.575],\n    \"8728\": [-0.02639, 0.47361, 0, 0, 0.575],\n    \"8729\": [-0.02639, 0.47361, 0, 0, 0.575],\n    \"8730\": [0.18, 0.82, 0, 0, 0.95833],\n    \"8733\": [0, 0.44444, 0, 0, 0.89444],\n    \"8734\": [0, 0.44444, 0, 0, 1.14999],\n    \"8736\": [0, 0.69224, 0, 0, 0.72222],\n    \"8739\": [0.25, 0.75, 0, 0, 0.31944],\n    \"8741\": [0.25, 0.75, 0, 0, 0.575],\n    \"8743\": [0, 0.55556, 0, 0, 0.76666],\n    \"8744\": [0, 0.55556, 0, 0, 0.76666],\n    \"8745\": [0, 0.55556, 0, 0, 0.76666],\n    \"8746\": [0, 0.55556, 0, 0, 0.76666],\n    \"8747\": [0.19444, 0.69444, 0.12778, 0, 0.56875],\n    \"8764\": [-0.10889, 0.39111, 0, 0, 0.89444],\n    \"8768\": [0.19444, 0.69444, 0, 0, 0.31944],\n    \"8771\": [0.00222, 0.50222, 0, 0, 0.89444],\n    \"8776\": [0.02444, 0.52444, 0, 0, 0.89444],\n    \"8781\": [0.00222, 0.50222, 0, 0, 0.89444],\n    \"8801\": [0.00222, 0.50222, 0, 0, 0.89444],\n    \"8804\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8805\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8810\": [0.08556, 0.58556, 0, 0, 1.14999],\n    \"8811\": [0.08556, 0.58556, 0, 0, 1.14999],\n    \"8826\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"8827\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"8834\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"8835\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"8838\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8839\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8846\": [0, 0.55556, 0, 0, 0.76666],\n    \"8849\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8850\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8851\": [0, 0.55556, 0, 0, 0.76666],\n    \"8852\": [0, 0.55556, 0, 0, 0.76666],\n    \"8853\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8854\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8855\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8856\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8857\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8866\": [0, 0.69444, 0, 0, 0.70277],\n    \"8867\": [0, 0.69444, 0, 0, 0.70277],\n    \"8868\": [0, 0.69444, 0, 0, 0.89444],\n    \"8869\": [0, 0.69444, 0, 0, 0.89444],\n    \"8900\": [-0.02639, 0.47361, 0, 0, 0.575],\n    \"8901\": [-0.02639, 0.47361, 0, 0, 0.31944],\n    \"8902\": [-0.02778, 0.47222, 0, 0, 0.575],\n    \"8968\": [0.25, 0.75, 0, 0, 0.51111],\n    \"8969\": [0.25, 0.75, 0, 0, 0.51111],\n    \"8970\": [0.25, 0.75, 0, 0, 0.51111],\n    \"8971\": [0.25, 0.75, 0, 0, 0.51111],\n    \"8994\": [-0.13889, 0.36111, 0, 0, 1.14999],\n    \"8995\": [-0.13889, 0.36111, 0, 0, 1.14999],\n    \"9651\": [0.19444, 0.69444, 0, 0, 1.02222],\n    \"9657\": [-0.02778, 0.47222, 0, 0, 0.575],\n    \"9661\": [0.19444, 0.69444, 0, 0, 1.02222],\n    \"9667\": [-0.02778, 0.47222, 0, 0, 0.575],\n    \"9711\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"9824\": [0.12963, 0.69444, 0, 0, 0.89444],\n    \"9825\": [0.12963, 0.69444, 0, 0, 0.89444],\n    \"9826\": [0.12963, 0.69444, 0, 0, 0.89444],\n    \"9827\": [0.12963, 0.69444, 0, 0, 0.89444],\n    \"9837\": [0, 0.75, 0, 0, 0.44722],\n    \"9838\": [0.19444, 0.69444, 0, 0, 0.44722],\n    \"9839\": [0.19444, 0.69444, 0, 0, 0.44722],\n    \"10216\": [0.25, 0.75, 0, 0, 0.44722],\n    \"10217\": [0.25, 0.75, 0, 0, 0.44722],\n    \"10815\": [0, 0.68611, 0, 0, 0.9],\n    \"10927\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"10928\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"57376\": [0.19444, 0.69444, 0, 0, 0]\n  },\n  \"Main-BoldItalic\": {\n    \"33\": [0, 0.69444, 0.11417, 0, 0.38611],\n    \"34\": [0, 0.69444, 0.07939, 0, 0.62055],\n    \"35\": [0.19444, 0.69444, 0.06833, 0, 0.94444],\n    \"37\": [0.05556, 0.75, 0.12861, 0, 0.94444],\n    \"38\": [0, 0.69444, 0.08528, 0, 0.88555],\n    \"39\": [0, 0.69444, 0.12945, 0, 0.35555],\n    \"40\": [0.25, 0.75, 0.15806, 0, 0.47333],\n    \"41\": [0.25, 0.75, 0.03306, 0, 0.47333],\n    \"42\": [0, 0.75, 0.14333, 0, 0.59111],\n    \"43\": [0.10333, 0.60333, 0.03306, 0, 0.88555],\n    \"44\": [0.19444, 0.14722, 0, 0, 0.35555],\n    \"45\": [0, 0.44444, 0.02611, 0, 0.41444],\n    \"46\": [0, 0.14722, 0, 0, 0.35555],\n    \"47\": [0.25, 0.75, 0.15806, 0, 0.59111],\n    \"48\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"49\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"50\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"51\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"52\": [0.19444, 0.64444, 0.13167, 0, 0.59111],\n    \"53\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"54\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"55\": [0.19444, 0.64444, 0.13167, 0, 0.59111],\n    \"56\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"57\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"58\": [0, 0.44444, 0.06695, 0, 0.35555],\n    \"59\": [0.19444, 0.44444, 0.06695, 0, 0.35555],\n    \"61\": [-0.10889, 0.39111, 0.06833, 0, 0.88555],\n    \"63\": [0, 0.69444, 0.11472, 0, 0.59111],\n    \"64\": [0, 0.69444, 0.09208, 0, 0.88555],\n    \"65\": [0, 0.68611, 0, 0, 0.86555],\n    \"66\": [0, 0.68611, 0.0992, 0, 0.81666],\n    \"67\": [0, 0.68611, 0.14208, 0, 0.82666],\n    \"68\": [0, 0.68611, 0.09062, 0, 0.87555],\n    \"69\": [0, 0.68611, 0.11431, 0, 0.75666],\n    \"70\": [0, 0.68611, 0.12903, 0, 0.72722],\n    \"71\": [0, 0.68611, 0.07347, 0, 0.89527],\n    \"72\": [0, 0.68611, 0.17208, 0, 0.8961],\n    \"73\": [0, 0.68611, 0.15681, 0, 0.47166],\n    \"74\": [0, 0.68611, 0.145, 0, 0.61055],\n    \"75\": [0, 0.68611, 0.14208, 0, 0.89499],\n    \"76\": [0, 0.68611, 0, 0, 0.69777],\n    \"77\": [0, 0.68611, 0.17208, 0, 1.07277],\n    \"78\": [0, 0.68611, 0.17208, 0, 0.8961],\n    \"79\": [0, 0.68611, 0.09062, 0, 0.85499],\n    \"80\": [0, 0.68611, 0.0992, 0, 0.78721],\n    \"81\": [0.19444, 0.68611, 0.09062, 0, 0.85499],\n    \"82\": [0, 0.68611, 0.02559, 0, 0.85944],\n    \"83\": [0, 0.68611, 0.11264, 0, 0.64999],\n    \"84\": [0, 0.68611, 0.12903, 0, 0.7961],\n    \"85\": [0, 0.68611, 0.17208, 0, 0.88083],\n    \"86\": [0, 0.68611, 0.18625, 0, 0.86555],\n    \"87\": [0, 0.68611, 0.18625, 0, 1.15999],\n    \"88\": [0, 0.68611, 0.15681, 0, 0.86555],\n    \"89\": [0, 0.68611, 0.19803, 0, 0.86555],\n    \"90\": [0, 0.68611, 0.14208, 0, 0.70888],\n    \"91\": [0.25, 0.75, 0.1875, 0, 0.35611],\n    \"93\": [0.25, 0.75, 0.09972, 0, 0.35611],\n    \"94\": [0, 0.69444, 0.06709, 0, 0.59111],\n    \"95\": [0.31, 0.13444, 0.09811, 0, 0.59111],\n    \"97\": [0, 0.44444, 0.09426, 0, 0.59111],\n    \"98\": [0, 0.69444, 0.07861, 0, 0.53222],\n    \"99\": [0, 0.44444, 0.05222, 0, 0.53222],\n    \"100\": [0, 0.69444, 0.10861, 0, 0.59111],\n    \"101\": [0, 0.44444, 0.085, 0, 0.53222],\n    \"102\": [0.19444, 0.69444, 0.21778, 0, 0.4],\n    \"103\": [0.19444, 0.44444, 0.105, 0, 0.53222],\n    \"104\": [0, 0.69444, 0.09426, 0, 0.59111],\n    \"105\": [0, 0.69326, 0.11387, 0, 0.35555],\n    \"106\": [0.19444, 0.69326, 0.1672, 0, 0.35555],\n    \"107\": [0, 0.69444, 0.11111, 0, 0.53222],\n    \"108\": [0, 0.69444, 0.10861, 0, 0.29666],\n    \"109\": [0, 0.44444, 0.09426, 0, 0.94444],\n    \"110\": [0, 0.44444, 0.09426, 0, 0.64999],\n    \"111\": [0, 0.44444, 0.07861, 0, 0.59111],\n    \"112\": [0.19444, 0.44444, 0.07861, 0, 0.59111],\n    \"113\": [0.19444, 0.44444, 0.105, 0, 0.53222],\n    \"114\": [0, 0.44444, 0.11111, 0, 0.50167],\n    \"115\": [0, 0.44444, 0.08167, 0, 0.48694],\n    \"116\": [0, 0.63492, 0.09639, 0, 0.385],\n    \"117\": [0, 0.44444, 0.09426, 0, 0.62055],\n    \"118\": [0, 0.44444, 0.11111, 0, 0.53222],\n    \"119\": [0, 0.44444, 0.11111, 0, 0.76777],\n    \"120\": [0, 0.44444, 0.12583, 0, 0.56055],\n    \"121\": [0.19444, 0.44444, 0.105, 0, 0.56166],\n    \"122\": [0, 0.44444, 0.13889, 0, 0.49055],\n    \"126\": [0.35, 0.34444, 0.11472, 0, 0.59111],\n    \"163\": [0, 0.69444, 0, 0, 0.86853],\n    \"168\": [0, 0.69444, 0.11473, 0, 0.59111],\n    \"176\": [0, 0.69444, 0, 0, 0.94888],\n    \"184\": [0.17014, 0, 0, 0, 0.53222],\n    \"198\": [0, 0.68611, 0.11431, 0, 1.02277],\n    \"216\": [0.04861, 0.73472, 0.09062, 0, 0.88555],\n    \"223\": [0.19444, 0.69444, 0.09736, 0, 0.665],\n    \"230\": [0, 0.44444, 0.085, 0, 0.82666],\n    \"248\": [0.09722, 0.54167, 0.09458, 0, 0.59111],\n    \"305\": [0, 0.44444, 0.09426, 0, 0.35555],\n    \"338\": [0, 0.68611, 0.11431, 0, 1.14054],\n    \"339\": [0, 0.44444, 0.085, 0, 0.82666],\n    \"567\": [0.19444, 0.44444, 0.04611, 0, 0.385],\n    \"710\": [0, 0.69444, 0.06709, 0, 0.59111],\n    \"711\": [0, 0.63194, 0.08271, 0, 0.59111],\n    \"713\": [0, 0.59444, 0.10444, 0, 0.59111],\n    \"714\": [0, 0.69444, 0.08528, 0, 0.59111],\n    \"715\": [0, 0.69444, 0, 0, 0.59111],\n    \"728\": [0, 0.69444, 0.10333, 0, 0.59111],\n    \"729\": [0, 0.69444, 0.12945, 0, 0.35555],\n    \"730\": [0, 0.69444, 0, 0, 0.94888],\n    \"732\": [0, 0.69444, 0.11472, 0, 0.59111],\n    \"733\": [0, 0.69444, 0.11472, 0, 0.59111],\n    \"915\": [0, 0.68611, 0.12903, 0, 0.69777],\n    \"916\": [0, 0.68611, 0, 0, 0.94444],\n    \"920\": [0, 0.68611, 0.09062, 0, 0.88555],\n    \"923\": [0, 0.68611, 0, 0, 0.80666],\n    \"926\": [0, 0.68611, 0.15092, 0, 0.76777],\n    \"928\": [0, 0.68611, 0.17208, 0, 0.8961],\n    \"931\": [0, 0.68611, 0.11431, 0, 0.82666],\n    \"933\": [0, 0.68611, 0.10778, 0, 0.88555],\n    \"934\": [0, 0.68611, 0.05632, 0, 0.82666],\n    \"936\": [0, 0.68611, 0.10778, 0, 0.88555],\n    \"937\": [0, 0.68611, 0.0992, 0, 0.82666],\n    \"8211\": [0, 0.44444, 0.09811, 0, 0.59111],\n    \"8212\": [0, 0.44444, 0.09811, 0, 1.18221],\n    \"8216\": [0, 0.69444, 0.12945, 0, 0.35555],\n    \"8217\": [0, 0.69444, 0.12945, 0, 0.35555],\n    \"8220\": [0, 0.69444, 0.16772, 0, 0.62055],\n    \"8221\": [0, 0.69444, 0.07939, 0, 0.62055]\n  },\n  \"Main-Italic\": {\n    \"33\": [0, 0.69444, 0.12417, 0, 0.30667],\n    \"34\": [0, 0.69444, 0.06961, 0, 0.51444],\n    \"35\": [0.19444, 0.69444, 0.06616, 0, 0.81777],\n    \"37\": [0.05556, 0.75, 0.13639, 0, 0.81777],\n    \"38\": [0, 0.69444, 0.09694, 0, 0.76666],\n    \"39\": [0, 0.69444, 0.12417, 0, 0.30667],\n    \"40\": [0.25, 0.75, 0.16194, 0, 0.40889],\n    \"41\": [0.25, 0.75, 0.03694, 0, 0.40889],\n    \"42\": [0, 0.75, 0.14917, 0, 0.51111],\n    \"43\": [0.05667, 0.56167, 0.03694, 0, 0.76666],\n    \"44\": [0.19444, 0.10556, 0, 0, 0.30667],\n    \"45\": [0, 0.43056, 0.02826, 0, 0.35778],\n    \"46\": [0, 0.10556, 0, 0, 0.30667],\n    \"47\": [0.25, 0.75, 0.16194, 0, 0.51111],\n    \"48\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"49\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"50\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"51\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"52\": [0.19444, 0.64444, 0.13556, 0, 0.51111],\n    \"53\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"54\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"55\": [0.19444, 0.64444, 0.13556, 0, 0.51111],\n    \"56\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"57\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"58\": [0, 0.43056, 0.0582, 0, 0.30667],\n    \"59\": [0.19444, 0.43056, 0.0582, 0, 0.30667],\n    \"61\": [-0.13313, 0.36687, 0.06616, 0, 0.76666],\n    \"63\": [0, 0.69444, 0.1225, 0, 0.51111],\n    \"64\": [0, 0.69444, 0.09597, 0, 0.76666],\n    \"65\": [0, 0.68333, 0, 0, 0.74333],\n    \"66\": [0, 0.68333, 0.10257, 0, 0.70389],\n    \"67\": [0, 0.68333, 0.14528, 0, 0.71555],\n    \"68\": [0, 0.68333, 0.09403, 0, 0.755],\n    \"69\": [0, 0.68333, 0.12028, 0, 0.67833],\n    \"70\": [0, 0.68333, 0.13305, 0, 0.65277],\n    \"71\": [0, 0.68333, 0.08722, 0, 0.77361],\n    \"72\": [0, 0.68333, 0.16389, 0, 0.74333],\n    \"73\": [0, 0.68333, 0.15806, 0, 0.38555],\n    \"74\": [0, 0.68333, 0.14028, 0, 0.525],\n    \"75\": [0, 0.68333, 0.14528, 0, 0.76888],\n    \"76\": [0, 0.68333, 0, 0, 0.62722],\n    \"77\": [0, 0.68333, 0.16389, 0, 0.89666],\n    \"78\": [0, 0.68333, 0.16389, 0, 0.74333],\n    \"79\": [0, 0.68333, 0.09403, 0, 0.76666],\n    \"80\": [0, 0.68333, 0.10257, 0, 0.67833],\n    \"81\": [0.19444, 0.68333, 0.09403, 0, 0.76666],\n    \"82\": [0, 0.68333, 0.03868, 0, 0.72944],\n    \"83\": [0, 0.68333, 0.11972, 0, 0.56222],\n    \"84\": [0, 0.68333, 0.13305, 0, 0.71555],\n    \"85\": [0, 0.68333, 0.16389, 0, 0.74333],\n    \"86\": [0, 0.68333, 0.18361, 0, 0.74333],\n    \"87\": [0, 0.68333, 0.18361, 0, 0.99888],\n    \"88\": [0, 0.68333, 0.15806, 0, 0.74333],\n    \"89\": [0, 0.68333, 0.19383, 0, 0.74333],\n    \"90\": [0, 0.68333, 0.14528, 0, 0.61333],\n    \"91\": [0.25, 0.75, 0.1875, 0, 0.30667],\n    \"93\": [0.25, 0.75, 0.10528, 0, 0.30667],\n    \"94\": [0, 0.69444, 0.06646, 0, 0.51111],\n    \"95\": [0.31, 0.12056, 0.09208, 0, 0.51111],\n    \"97\": [0, 0.43056, 0.07671, 0, 0.51111],\n    \"98\": [0, 0.69444, 0.06312, 0, 0.46],\n    \"99\": [0, 0.43056, 0.05653, 0, 0.46],\n    \"100\": [0, 0.69444, 0.10333, 0, 0.51111],\n    \"101\": [0, 0.43056, 0.07514, 0, 0.46],\n    \"102\": [0.19444, 0.69444, 0.21194, 0, 0.30667],\n    \"103\": [0.19444, 0.43056, 0.08847, 0, 0.46],\n    \"104\": [0, 0.69444, 0.07671, 0, 0.51111],\n    \"105\": [0, 0.65536, 0.1019, 0, 0.30667],\n    \"106\": [0.19444, 0.65536, 0.14467, 0, 0.30667],\n    \"107\": [0, 0.69444, 0.10764, 0, 0.46],\n    \"108\": [0, 0.69444, 0.10333, 0, 0.25555],\n    \"109\": [0, 0.43056, 0.07671, 0, 0.81777],\n    \"110\": [0, 0.43056, 0.07671, 0, 0.56222],\n    \"111\": [0, 0.43056, 0.06312, 0, 0.51111],\n    \"112\": [0.19444, 0.43056, 0.06312, 0, 0.51111],\n    \"113\": [0.19444, 0.43056, 0.08847, 0, 0.46],\n    \"114\": [0, 0.43056, 0.10764, 0, 0.42166],\n    \"115\": [0, 0.43056, 0.08208, 0, 0.40889],\n    \"116\": [0, 0.61508, 0.09486, 0, 0.33222],\n    \"117\": [0, 0.43056, 0.07671, 0, 0.53666],\n    \"118\": [0, 0.43056, 0.10764, 0, 0.46],\n    \"119\": [0, 0.43056, 0.10764, 0, 0.66444],\n    \"120\": [0, 0.43056, 0.12042, 0, 0.46389],\n    \"121\": [0.19444, 0.43056, 0.08847, 0, 0.48555],\n    \"122\": [0, 0.43056, 0.12292, 0, 0.40889],\n    \"126\": [0.35, 0.31786, 0.11585, 0, 0.51111],\n    \"163\": [0, 0.69444, 0, 0, 0.76909],\n    \"168\": [0, 0.66786, 0.10474, 0, 0.51111],\n    \"176\": [0, 0.69444, 0, 0, 0.83129],\n    \"184\": [0.17014, 0, 0, 0, 0.46],\n    \"198\": [0, 0.68333, 0.12028, 0, 0.88277],\n    \"216\": [0.04861, 0.73194, 0.09403, 0, 0.76666],\n    \"223\": [0.19444, 0.69444, 0.10514, 0, 0.53666],\n    \"230\": [0, 0.43056, 0.07514, 0, 0.71555],\n    \"248\": [0.09722, 0.52778, 0.09194, 0, 0.51111],\n    \"305\": [0, 0.43056, 0, 0.02778, 0.32246],\n    \"338\": [0, 0.68333, 0.12028, 0, 0.98499],\n    \"339\": [0, 0.43056, 0.07514, 0, 0.71555],\n    \"567\": [0.19444, 0.43056, 0, 0.08334, 0.38403],\n    \"710\": [0, 0.69444, 0.06646, 0, 0.51111],\n    \"711\": [0, 0.62847, 0.08295, 0, 0.51111],\n    \"713\": [0, 0.56167, 0.10333, 0, 0.51111],\n    \"714\": [0, 0.69444, 0.09694, 0, 0.51111],\n    \"715\": [0, 0.69444, 0, 0, 0.51111],\n    \"728\": [0, 0.69444, 0.10806, 0, 0.51111],\n    \"729\": [0, 0.66786, 0.11752, 0, 0.30667],\n    \"730\": [0, 0.69444, 0, 0, 0.83129],\n    \"732\": [0, 0.66786, 0.11585, 0, 0.51111],\n    \"733\": [0, 0.69444, 0.1225, 0, 0.51111],\n    \"915\": [0, 0.68333, 0.13305, 0, 0.62722],\n    \"916\": [0, 0.68333, 0, 0, 0.81777],\n    \"920\": [0, 0.68333, 0.09403, 0, 0.76666],\n    \"923\": [0, 0.68333, 0, 0, 0.69222],\n    \"926\": [0, 0.68333, 0.15294, 0, 0.66444],\n    \"928\": [0, 0.68333, 0.16389, 0, 0.74333],\n    \"931\": [0, 0.68333, 0.12028, 0, 0.71555],\n    \"933\": [0, 0.68333, 0.11111, 0, 0.76666],\n    \"934\": [0, 0.68333, 0.05986, 0, 0.71555],\n    \"936\": [0, 0.68333, 0.11111, 0, 0.76666],\n    \"937\": [0, 0.68333, 0.10257, 0, 0.71555],\n    \"8211\": [0, 0.43056, 0.09208, 0, 0.51111],\n    \"8212\": [0, 0.43056, 0.09208, 0, 1.02222],\n    \"8216\": [0, 0.69444, 0.12417, 0, 0.30667],\n    \"8217\": [0, 0.69444, 0.12417, 0, 0.30667],\n    \"8220\": [0, 0.69444, 0.1685, 0, 0.51444],\n    \"8221\": [0, 0.69444, 0.06961, 0, 0.51444],\n    \"8463\": [0, 0.68889, 0, 0, 0.54028]\n  },\n  \"Main-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0, 0, 0.27778],\n    \"34\": [0, 0.69444, 0, 0, 0.5],\n    \"35\": [0.19444, 0.69444, 0, 0, 0.83334],\n    \"36\": [0.05556, 0.75, 0, 0, 0.5],\n    \"37\": [0.05556, 0.75, 0, 0, 0.83334],\n    \"38\": [0, 0.69444, 0, 0, 0.77778],\n    \"39\": [0, 0.69444, 0, 0, 0.27778],\n    \"40\": [0.25, 0.75, 0, 0, 0.38889],\n    \"41\": [0.25, 0.75, 0, 0, 0.38889],\n    \"42\": [0, 0.75, 0, 0, 0.5],\n    \"43\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"44\": [0.19444, 0.10556, 0, 0, 0.27778],\n    \"45\": [0, 0.43056, 0, 0, 0.33333],\n    \"46\": [0, 0.10556, 0, 0, 0.27778],\n    \"47\": [0.25, 0.75, 0, 0, 0.5],\n    \"48\": [0, 0.64444, 0, 0, 0.5],\n    \"49\": [0, 0.64444, 0, 0, 0.5],\n    \"50\": [0, 0.64444, 0, 0, 0.5],\n    \"51\": [0, 0.64444, 0, 0, 0.5],\n    \"52\": [0, 0.64444, 0, 0, 0.5],\n    \"53\": [0, 0.64444, 0, 0, 0.5],\n    \"54\": [0, 0.64444, 0, 0, 0.5],\n    \"55\": [0, 0.64444, 0, 0, 0.5],\n    \"56\": [0, 0.64444, 0, 0, 0.5],\n    \"57\": [0, 0.64444, 0, 0, 0.5],\n    \"58\": [0, 0.43056, 0, 0, 0.27778],\n    \"59\": [0.19444, 0.43056, 0, 0, 0.27778],\n    \"60\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"61\": [-0.13313, 0.36687, 0, 0, 0.77778],\n    \"62\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"63\": [0, 0.69444, 0, 0, 0.47222],\n    \"64\": [0, 0.69444, 0, 0, 0.77778],\n    \"65\": [0, 0.68333, 0, 0, 0.75],\n    \"66\": [0, 0.68333, 0, 0, 0.70834],\n    \"67\": [0, 0.68333, 0, 0, 0.72222],\n    \"68\": [0, 0.68333, 0, 0, 0.76389],\n    \"69\": [0, 0.68333, 0, 0, 0.68056],\n    \"70\": [0, 0.68333, 0, 0, 0.65278],\n    \"71\": [0, 0.68333, 0, 0, 0.78472],\n    \"72\": [0, 0.68333, 0, 0, 0.75],\n    \"73\": [0, 0.68333, 0, 0, 0.36111],\n    \"74\": [0, 0.68333, 0, 0, 0.51389],\n    \"75\": [0, 0.68333, 0, 0, 0.77778],\n    \"76\": [0, 0.68333, 0, 0, 0.625],\n    \"77\": [0, 0.68333, 0, 0, 0.91667],\n    \"78\": [0, 0.68333, 0, 0, 0.75],\n    \"79\": [0, 0.68333, 0, 0, 0.77778],\n    \"80\": [0, 0.68333, 0, 0, 0.68056],\n    \"81\": [0.19444, 0.68333, 0, 0, 0.77778],\n    \"82\": [0, 0.68333, 0, 0, 0.73611],\n    \"83\": [0, 0.68333, 0, 0, 0.55556],\n    \"84\": [0, 0.68333, 0, 0, 0.72222],\n    \"85\": [0, 0.68333, 0, 0, 0.75],\n    \"86\": [0, 0.68333, 0.01389, 0, 0.75],\n    \"87\": [0, 0.68333, 0.01389, 0, 1.02778],\n    \"88\": [0, 0.68333, 0, 0, 0.75],\n    \"89\": [0, 0.68333, 0.025, 0, 0.75],\n    \"90\": [0, 0.68333, 0, 0, 0.61111],\n    \"91\": [0.25, 0.75, 0, 0, 0.27778],\n    \"92\": [0.25, 0.75, 0, 0, 0.5],\n    \"93\": [0.25, 0.75, 0, 0, 0.27778],\n    \"94\": [0, 0.69444, 0, 0, 0.5],\n    \"95\": [0.31, 0.12056, 0.02778, 0, 0.5],\n    \"97\": [0, 0.43056, 0, 0, 0.5],\n    \"98\": [0, 0.69444, 0, 0, 0.55556],\n    \"99\": [0, 0.43056, 0, 0, 0.44445],\n    \"100\": [0, 0.69444, 0, 0, 0.55556],\n    \"101\": [0, 0.43056, 0, 0, 0.44445],\n    \"102\": [0, 0.69444, 0.07778, 0, 0.30556],\n    \"103\": [0.19444, 0.43056, 0.01389, 0, 0.5],\n    \"104\": [0, 0.69444, 0, 0, 0.55556],\n    \"105\": [0, 0.66786, 0, 0, 0.27778],\n    \"106\": [0.19444, 0.66786, 0, 0, 0.30556],\n    \"107\": [0, 0.69444, 0, 0, 0.52778],\n    \"108\": [0, 0.69444, 0, 0, 0.27778],\n    \"109\": [0, 0.43056, 0, 0, 0.83334],\n    \"110\": [0, 0.43056, 0, 0, 0.55556],\n    \"111\": [0, 0.43056, 0, 0, 0.5],\n    \"112\": [0.19444, 0.43056, 0, 0, 0.55556],\n    \"113\": [0.19444, 0.43056, 0, 0, 0.52778],\n    \"114\": [0, 0.43056, 0, 0, 0.39167],\n    \"115\": [0, 0.43056, 0, 0, 0.39445],\n    \"116\": [0, 0.61508, 0, 0, 0.38889],\n    \"117\": [0, 0.43056, 0, 0, 0.55556],\n    \"118\": [0, 0.43056, 0.01389, 0, 0.52778],\n    \"119\": [0, 0.43056, 0.01389, 0, 0.72222],\n    \"120\": [0, 0.43056, 0, 0, 0.52778],\n    \"121\": [0.19444, 0.43056, 0.01389, 0, 0.52778],\n    \"122\": [0, 0.43056, 0, 0, 0.44445],\n    \"123\": [0.25, 0.75, 0, 0, 0.5],\n    \"124\": [0.25, 0.75, 0, 0, 0.27778],\n    \"125\": [0.25, 0.75, 0, 0, 0.5],\n    \"126\": [0.35, 0.31786, 0, 0, 0.5],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"167\": [0.19444, 0.69444, 0, 0, 0.44445],\n    \"168\": [0, 0.66786, 0, 0, 0.5],\n    \"172\": [0, 0.43056, 0, 0, 0.66667],\n    \"176\": [0, 0.69444, 0, 0, 0.75],\n    \"177\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"182\": [0.19444, 0.69444, 0, 0, 0.61111],\n    \"184\": [0.17014, 0, 0, 0, 0.44445],\n    \"198\": [0, 0.68333, 0, 0, 0.90278],\n    \"215\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"216\": [0.04861, 0.73194, 0, 0, 0.77778],\n    \"223\": [0, 0.69444, 0, 0, 0.5],\n    \"230\": [0, 0.43056, 0, 0, 0.72222],\n    \"247\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"248\": [0.09722, 0.52778, 0, 0, 0.5],\n    \"305\": [0, 0.43056, 0, 0, 0.27778],\n    \"338\": [0, 0.68333, 0, 0, 1.01389],\n    \"339\": [0, 0.43056, 0, 0, 0.77778],\n    \"567\": [0.19444, 0.43056, 0, 0, 0.30556],\n    \"710\": [0, 0.69444, 0, 0, 0.5],\n    \"711\": [0, 0.62847, 0, 0, 0.5],\n    \"713\": [0, 0.56778, 0, 0, 0.5],\n    \"714\": [0, 0.69444, 0, 0, 0.5],\n    \"715\": [0, 0.69444, 0, 0, 0.5],\n    \"728\": [0, 0.69444, 0, 0, 0.5],\n    \"729\": [0, 0.66786, 0, 0, 0.27778],\n    \"730\": [0, 0.69444, 0, 0, 0.75],\n    \"732\": [0, 0.66786, 0, 0, 0.5],\n    \"733\": [0, 0.69444, 0, 0, 0.5],\n    \"915\": [0, 0.68333, 0, 0, 0.625],\n    \"916\": [0, 0.68333, 0, 0, 0.83334],\n    \"920\": [0, 0.68333, 0, 0, 0.77778],\n    \"923\": [0, 0.68333, 0, 0, 0.69445],\n    \"926\": [0, 0.68333, 0, 0, 0.66667],\n    \"928\": [0, 0.68333, 0, 0, 0.75],\n    \"931\": [0, 0.68333, 0, 0, 0.72222],\n    \"933\": [0, 0.68333, 0, 0, 0.77778],\n    \"934\": [0, 0.68333, 0, 0, 0.72222],\n    \"936\": [0, 0.68333, 0, 0, 0.77778],\n    \"937\": [0, 0.68333, 0, 0, 0.72222],\n    \"8211\": [0, 0.43056, 0.02778, 0, 0.5],\n    \"8212\": [0, 0.43056, 0.02778, 0, 1.0],\n    \"8216\": [0, 0.69444, 0, 0, 0.27778],\n    \"8217\": [0, 0.69444, 0, 0, 0.27778],\n    \"8220\": [0, 0.69444, 0, 0, 0.5],\n    \"8221\": [0, 0.69444, 0, 0, 0.5],\n    \"8224\": [0.19444, 0.69444, 0, 0, 0.44445],\n    \"8225\": [0.19444, 0.69444, 0, 0, 0.44445],\n    \"8230\": [0, 0.12, 0, 0, 1.172],\n    \"8242\": [0, 0.55556, 0, 0, 0.275],\n    \"8407\": [0, 0.71444, 0.15382, 0, 0.5],\n    \"8463\": [0, 0.68889, 0, 0, 0.54028],\n    \"8465\": [0, 0.69444, 0, 0, 0.72222],\n    \"8467\": [0, 0.69444, 0, 0.11111, 0.41667],\n    \"8472\": [0.19444, 0.43056, 0, 0.11111, 0.63646],\n    \"8476\": [0, 0.69444, 0, 0, 0.72222],\n    \"8501\": [0, 0.69444, 0, 0, 0.61111],\n    \"8592\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8593\": [0.19444, 0.69444, 0, 0, 0.5],\n    \"8594\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8595\": [0.19444, 0.69444, 0, 0, 0.5],\n    \"8596\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8597\": [0.25, 0.75, 0, 0, 0.5],\n    \"8598\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"8599\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"8600\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"8601\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"8614\": [0.011, 0.511, 0, 0, 1.0],\n    \"8617\": [0.011, 0.511, 0, 0, 1.126],\n    \"8618\": [0.011, 0.511, 0, 0, 1.126],\n    \"8636\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8637\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8640\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8641\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8652\": [0.011, 0.671, 0, 0, 1.0],\n    \"8656\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8657\": [0.19444, 0.69444, 0, 0, 0.61111],\n    \"8658\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8659\": [0.19444, 0.69444, 0, 0, 0.61111],\n    \"8660\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8661\": [0.25, 0.75, 0, 0, 0.61111],\n    \"8704\": [0, 0.69444, 0, 0, 0.55556],\n    \"8706\": [0, 0.69444, 0.05556, 0.08334, 0.5309],\n    \"8707\": [0, 0.69444, 0, 0, 0.55556],\n    \"8709\": [0.05556, 0.75, 0, 0, 0.5],\n    \"8711\": [0, 0.68333, 0, 0, 0.83334],\n    \"8712\": [0.0391, 0.5391, 0, 0, 0.66667],\n    \"8715\": [0.0391, 0.5391, 0, 0, 0.66667],\n    \"8722\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8723\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8725\": [0.25, 0.75, 0, 0, 0.5],\n    \"8726\": [0.25, 0.75, 0, 0, 0.5],\n    \"8727\": [-0.03472, 0.46528, 0, 0, 0.5],\n    \"8728\": [-0.05555, 0.44445, 0, 0, 0.5],\n    \"8729\": [-0.05555, 0.44445, 0, 0, 0.5],\n    \"8730\": [0.2, 0.8, 0, 0, 0.83334],\n    \"8733\": [0, 0.43056, 0, 0, 0.77778],\n    \"8734\": [0, 0.43056, 0, 0, 1.0],\n    \"8736\": [0, 0.69224, 0, 0, 0.72222],\n    \"8739\": [0.25, 0.75, 0, 0, 0.27778],\n    \"8741\": [0.25, 0.75, 0, 0, 0.5],\n    \"8743\": [0, 0.55556, 0, 0, 0.66667],\n    \"8744\": [0, 0.55556, 0, 0, 0.66667],\n    \"8745\": [0, 0.55556, 0, 0, 0.66667],\n    \"8746\": [0, 0.55556, 0, 0, 0.66667],\n    \"8747\": [0.19444, 0.69444, 0.11111, 0, 0.41667],\n    \"8764\": [-0.13313, 0.36687, 0, 0, 0.77778],\n    \"8768\": [0.19444, 0.69444, 0, 0, 0.27778],\n    \"8771\": [-0.03625, 0.46375, 0, 0, 0.77778],\n    \"8773\": [-0.022, 0.589, 0, 0, 1.0],\n    \"8776\": [-0.01688, 0.48312, 0, 0, 0.77778],\n    \"8781\": [-0.03625, 0.46375, 0, 0, 0.77778],\n    \"8784\": [-0.133, 0.67, 0, 0, 0.778],\n    \"8801\": [-0.03625, 0.46375, 0, 0, 0.77778],\n    \"8804\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8805\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8810\": [0.0391, 0.5391, 0, 0, 1.0],\n    \"8811\": [0.0391, 0.5391, 0, 0, 1.0],\n    \"8826\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8827\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8834\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8835\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8838\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8839\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8846\": [0, 0.55556, 0, 0, 0.66667],\n    \"8849\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8850\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8851\": [0, 0.55556, 0, 0, 0.66667],\n    \"8852\": [0, 0.55556, 0, 0, 0.66667],\n    \"8853\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8854\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8855\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8856\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8857\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8866\": [0, 0.69444, 0, 0, 0.61111],\n    \"8867\": [0, 0.69444, 0, 0, 0.61111],\n    \"8868\": [0, 0.69444, 0, 0, 0.77778],\n    \"8869\": [0, 0.69444, 0, 0, 0.77778],\n    \"8872\": [0.249, 0.75, 0, 0, 0.867],\n    \"8900\": [-0.05555, 0.44445, 0, 0, 0.5],\n    \"8901\": [-0.05555, 0.44445, 0, 0, 0.27778],\n    \"8902\": [-0.03472, 0.46528, 0, 0, 0.5],\n    \"8904\": [0.005, 0.505, 0, 0, 0.9],\n    \"8942\": [0.03, 0.9, 0, 0, 0.278],\n    \"8943\": [-0.19, 0.31, 0, 0, 1.172],\n    \"8945\": [-0.1, 0.82, 0, 0, 1.282],\n    \"8968\": [0.25, 0.75, 0, 0, 0.44445],\n    \"8969\": [0.25, 0.75, 0, 0, 0.44445],\n    \"8970\": [0.25, 0.75, 0, 0, 0.44445],\n    \"8971\": [0.25, 0.75, 0, 0, 0.44445],\n    \"8994\": [-0.14236, 0.35764, 0, 0, 1.0],\n    \"8995\": [-0.14236, 0.35764, 0, 0, 1.0],\n    \"9136\": [0.244, 0.744, 0, 0, 0.412],\n    \"9137\": [0.244, 0.744, 0, 0, 0.412],\n    \"9651\": [0.19444, 0.69444, 0, 0, 0.88889],\n    \"9657\": [-0.03472, 0.46528, 0, 0, 0.5],\n    \"9661\": [0.19444, 0.69444, 0, 0, 0.88889],\n    \"9667\": [-0.03472, 0.46528, 0, 0, 0.5],\n    \"9711\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"9824\": [0.12963, 0.69444, 0, 0, 0.77778],\n    \"9825\": [0.12963, 0.69444, 0, 0, 0.77778],\n    \"9826\": [0.12963, 0.69444, 0, 0, 0.77778],\n    \"9827\": [0.12963, 0.69444, 0, 0, 0.77778],\n    \"9837\": [0, 0.75, 0, 0, 0.38889],\n    \"9838\": [0.19444, 0.69444, 0, 0, 0.38889],\n    \"9839\": [0.19444, 0.69444, 0, 0, 0.38889],\n    \"10216\": [0.25, 0.75, 0, 0, 0.38889],\n    \"10217\": [0.25, 0.75, 0, 0, 0.38889],\n    \"10222\": [0.244, 0.744, 0, 0, 0.412],\n    \"10223\": [0.244, 0.744, 0, 0, 0.412],\n    \"10229\": [0.011, 0.511, 0, 0, 1.609],\n    \"10230\": [0.011, 0.511, 0, 0, 1.638],\n    \"10231\": [0.011, 0.511, 0, 0, 1.859],\n    \"10232\": [0.024, 0.525, 0, 0, 1.609],\n    \"10233\": [0.024, 0.525, 0, 0, 1.638],\n    \"10234\": [0.024, 0.525, 0, 0, 1.858],\n    \"10236\": [0.011, 0.511, 0, 0, 1.638],\n    \"10815\": [0, 0.68333, 0, 0, 0.75],\n    \"10927\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"10928\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"57376\": [0.19444, 0.69444, 0, 0, 0]\n  },\n  \"Math-BoldItalic\": {\n    \"65\": [0, 0.68611, 0, 0, 0.86944],\n    \"66\": [0, 0.68611, 0.04835, 0, 0.8664],\n    \"67\": [0, 0.68611, 0.06979, 0, 0.81694],\n    \"68\": [0, 0.68611, 0.03194, 0, 0.93812],\n    \"69\": [0, 0.68611, 0.05451, 0, 0.81007],\n    \"70\": [0, 0.68611, 0.15972, 0, 0.68889],\n    \"71\": [0, 0.68611, 0, 0, 0.88673],\n    \"72\": [0, 0.68611, 0.08229, 0, 0.98229],\n    \"73\": [0, 0.68611, 0.07778, 0, 0.51111],\n    \"74\": [0, 0.68611, 0.10069, 0, 0.63125],\n    \"75\": [0, 0.68611, 0.06979, 0, 0.97118],\n    \"76\": [0, 0.68611, 0, 0, 0.75555],\n    \"77\": [0, 0.68611, 0.11424, 0, 1.14201],\n    \"78\": [0, 0.68611, 0.11424, 0, 0.95034],\n    \"79\": [0, 0.68611, 0.03194, 0, 0.83666],\n    \"80\": [0, 0.68611, 0.15972, 0, 0.72309],\n    \"81\": [0.19444, 0.68611, 0, 0, 0.86861],\n    \"82\": [0, 0.68611, 0.00421, 0, 0.87235],\n    \"83\": [0, 0.68611, 0.05382, 0, 0.69271],\n    \"84\": [0, 0.68611, 0.15972, 0, 0.63663],\n    \"85\": [0, 0.68611, 0.11424, 0, 0.80027],\n    \"86\": [0, 0.68611, 0.25555, 0, 0.67778],\n    \"87\": [0, 0.68611, 0.15972, 0, 1.09305],\n    \"88\": [0, 0.68611, 0.07778, 0, 0.94722],\n    \"89\": [0, 0.68611, 0.25555, 0, 0.67458],\n    \"90\": [0, 0.68611, 0.06979, 0, 0.77257],\n    \"97\": [0, 0.44444, 0, 0, 0.63287],\n    \"98\": [0, 0.69444, 0, 0, 0.52083],\n    \"99\": [0, 0.44444, 0, 0, 0.51342],\n    \"100\": [0, 0.69444, 0, 0, 0.60972],\n    \"101\": [0, 0.44444, 0, 0, 0.55361],\n    \"102\": [0.19444, 0.69444, 0.11042, 0, 0.56806],\n    \"103\": [0.19444, 0.44444, 0.03704, 0, 0.5449],\n    \"104\": [0, 0.69444, 0, 0, 0.66759],\n    \"105\": [0, 0.69326, 0, 0, 0.4048],\n    \"106\": [0.19444, 0.69326, 0.0622, 0, 0.47083],\n    \"107\": [0, 0.69444, 0.01852, 0, 0.6037],\n    \"108\": [0, 0.69444, 0.0088, 0, 0.34815],\n    \"109\": [0, 0.44444, 0, 0, 1.0324],\n    \"110\": [0, 0.44444, 0, 0, 0.71296],\n    \"111\": [0, 0.44444, 0, 0, 0.58472],\n    \"112\": [0.19444, 0.44444, 0, 0, 0.60092],\n    \"113\": [0.19444, 0.44444, 0.03704, 0, 0.54213],\n    \"114\": [0, 0.44444, 0.03194, 0, 0.5287],\n    \"115\": [0, 0.44444, 0, 0, 0.53125],\n    \"116\": [0, 0.63492, 0, 0, 0.41528],\n    \"117\": [0, 0.44444, 0, 0, 0.68102],\n    \"118\": [0, 0.44444, 0.03704, 0, 0.56666],\n    \"119\": [0, 0.44444, 0.02778, 0, 0.83148],\n    \"120\": [0, 0.44444, 0, 0, 0.65903],\n    \"121\": [0.19444, 0.44444, 0.03704, 0, 0.59028],\n    \"122\": [0, 0.44444, 0.04213, 0, 0.55509],\n    \"915\": [0, 0.68611, 0.15972, 0, 0.65694],\n    \"916\": [0, 0.68611, 0, 0, 0.95833],\n    \"920\": [0, 0.68611, 0.03194, 0, 0.86722],\n    \"923\": [0, 0.68611, 0, 0, 0.80555],\n    \"926\": [0, 0.68611, 0.07458, 0, 0.84125],\n    \"928\": [0, 0.68611, 0.08229, 0, 0.98229],\n    \"931\": [0, 0.68611, 0.05451, 0, 0.88507],\n    \"933\": [0, 0.68611, 0.15972, 0, 0.67083],\n    \"934\": [0, 0.68611, 0, 0, 0.76666],\n    \"936\": [0, 0.68611, 0.11653, 0, 0.71402],\n    \"937\": [0, 0.68611, 0.04835, 0, 0.8789],\n    \"945\": [0, 0.44444, 0, 0, 0.76064],\n    \"946\": [0.19444, 0.69444, 0.03403, 0, 0.65972],\n    \"947\": [0.19444, 0.44444, 0.06389, 0, 0.59003],\n    \"948\": [0, 0.69444, 0.03819, 0, 0.52222],\n    \"949\": [0, 0.44444, 0, 0, 0.52882],\n    \"950\": [0.19444, 0.69444, 0.06215, 0, 0.50833],\n    \"951\": [0.19444, 0.44444, 0.03704, 0, 0.6],\n    \"952\": [0, 0.69444, 0.03194, 0, 0.5618],\n    \"953\": [0, 0.44444, 0, 0, 0.41204],\n    \"954\": [0, 0.44444, 0, 0, 0.66759],\n    \"955\": [0, 0.69444, 0, 0, 0.67083],\n    \"956\": [0.19444, 0.44444, 0, 0, 0.70787],\n    \"957\": [0, 0.44444, 0.06898, 0, 0.57685],\n    \"958\": [0.19444, 0.69444, 0.03021, 0, 0.50833],\n    \"959\": [0, 0.44444, 0, 0, 0.58472],\n    \"960\": [0, 0.44444, 0.03704, 0, 0.68241],\n    \"961\": [0.19444, 0.44444, 0, 0, 0.6118],\n    \"962\": [0.09722, 0.44444, 0.07917, 0, 0.42361],\n    \"963\": [0, 0.44444, 0.03704, 0, 0.68588],\n    \"964\": [0, 0.44444, 0.13472, 0, 0.52083],\n    \"965\": [0, 0.44444, 0.03704, 0, 0.63055],\n    \"966\": [0.19444, 0.44444, 0, 0, 0.74722],\n    \"967\": [0.19444, 0.44444, 0, 0, 0.71805],\n    \"968\": [0.19444, 0.69444, 0.03704, 0, 0.75833],\n    \"969\": [0, 0.44444, 0.03704, 0, 0.71782],\n    \"977\": [0, 0.69444, 0, 0, 0.69155],\n    \"981\": [0.19444, 0.69444, 0, 0, 0.7125],\n    \"982\": [0, 0.44444, 0.03194, 0, 0.975],\n    \"1009\": [0.19444, 0.44444, 0, 0, 0.6118],\n    \"1013\": [0, 0.44444, 0, 0, 0.48333]\n  },\n  \"Math-Italic\": {\n    \"65\": [0, 0.68333, 0, 0.13889, 0.75],\n    \"66\": [0, 0.68333, 0.05017, 0.08334, 0.75851],\n    \"67\": [0, 0.68333, 0.07153, 0.08334, 0.71472],\n    \"68\": [0, 0.68333, 0.02778, 0.05556, 0.82792],\n    \"69\": [0, 0.68333, 0.05764, 0.08334, 0.7382],\n    \"70\": [0, 0.68333, 0.13889, 0.08334, 0.64306],\n    \"71\": [0, 0.68333, 0, 0.08334, 0.78625],\n    \"72\": [0, 0.68333, 0.08125, 0.05556, 0.83125],\n    \"73\": [0, 0.68333, 0.07847, 0.11111, 0.43958],\n    \"74\": [0, 0.68333, 0.09618, 0.16667, 0.55451],\n    \"75\": [0, 0.68333, 0.07153, 0.05556, 0.84931],\n    \"76\": [0, 0.68333, 0, 0.02778, 0.68056],\n    \"77\": [0, 0.68333, 0.10903, 0.08334, 0.97014],\n    \"78\": [0, 0.68333, 0.10903, 0.08334, 0.80347],\n    \"79\": [0, 0.68333, 0.02778, 0.08334, 0.76278],\n    \"80\": [0, 0.68333, 0.13889, 0.08334, 0.64201],\n    \"81\": [0.19444, 0.68333, 0, 0.08334, 0.79056],\n    \"82\": [0, 0.68333, 0.00773, 0.08334, 0.75929],\n    \"83\": [0, 0.68333, 0.05764, 0.08334, 0.6132],\n    \"84\": [0, 0.68333, 0.13889, 0.08334, 0.58438],\n    \"85\": [0, 0.68333, 0.10903, 0.02778, 0.68278],\n    \"86\": [0, 0.68333, 0.22222, 0, 0.58333],\n    \"87\": [0, 0.68333, 0.13889, 0, 0.94445],\n    \"88\": [0, 0.68333, 0.07847, 0.08334, 0.82847],\n    \"89\": [0, 0.68333, 0.22222, 0, 0.58056],\n    \"90\": [0, 0.68333, 0.07153, 0.08334, 0.68264],\n    \"97\": [0, 0.43056, 0, 0, 0.52859],\n    \"98\": [0, 0.69444, 0, 0, 0.42917],\n    \"99\": [0, 0.43056, 0, 0.05556, 0.43276],\n    \"100\": [0, 0.69444, 0, 0.16667, 0.52049],\n    \"101\": [0, 0.43056, 0, 0.05556, 0.46563],\n    \"102\": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],\n    \"103\": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],\n    \"104\": [0, 0.69444, 0, 0, 0.57616],\n    \"105\": [0, 0.65952, 0, 0, 0.34451],\n    \"106\": [0.19444, 0.65952, 0.05724, 0, 0.41181],\n    \"107\": [0, 0.69444, 0.03148, 0, 0.5206],\n    \"108\": [0, 0.69444, 0.01968, 0.08334, 0.29838],\n    \"109\": [0, 0.43056, 0, 0, 0.87801],\n    \"110\": [0, 0.43056, 0, 0, 0.60023],\n    \"111\": [0, 0.43056, 0, 0.05556, 0.48472],\n    \"112\": [0.19444, 0.43056, 0, 0.08334, 0.50313],\n    \"113\": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],\n    \"114\": [0, 0.43056, 0.02778, 0.05556, 0.45116],\n    \"115\": [0, 0.43056, 0, 0.05556, 0.46875],\n    \"116\": [0, 0.61508, 0, 0.08334, 0.36111],\n    \"117\": [0, 0.43056, 0, 0.02778, 0.57246],\n    \"118\": [0, 0.43056, 0.03588, 0.02778, 0.48472],\n    \"119\": [0, 0.43056, 0.02691, 0.08334, 0.71592],\n    \"120\": [0, 0.43056, 0, 0.02778, 0.57153],\n    \"121\": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],\n    \"122\": [0, 0.43056, 0.04398, 0.05556, 0.46505],\n    \"915\": [0, 0.68333, 0.13889, 0.08334, 0.61528],\n    \"916\": [0, 0.68333, 0, 0.16667, 0.83334],\n    \"920\": [0, 0.68333, 0.02778, 0.08334, 0.76278],\n    \"923\": [0, 0.68333, 0, 0.16667, 0.69445],\n    \"926\": [0, 0.68333, 0.07569, 0.08334, 0.74236],\n    \"928\": [0, 0.68333, 0.08125, 0.05556, 0.83125],\n    \"931\": [0, 0.68333, 0.05764, 0.08334, 0.77986],\n    \"933\": [0, 0.68333, 0.13889, 0.05556, 0.58333],\n    \"934\": [0, 0.68333, 0, 0.08334, 0.66667],\n    \"936\": [0, 0.68333, 0.11, 0.05556, 0.61222],\n    \"937\": [0, 0.68333, 0.05017, 0.08334, 0.7724],\n    \"945\": [0, 0.43056, 0.0037, 0.02778, 0.6397],\n    \"946\": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],\n    \"947\": [0.19444, 0.43056, 0.05556, 0, 0.51773],\n    \"948\": [0, 0.69444, 0.03785, 0.05556, 0.44444],\n    \"949\": [0, 0.43056, 0, 0.08334, 0.46632],\n    \"950\": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],\n    \"951\": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],\n    \"952\": [0, 0.69444, 0.02778, 0.08334, 0.46944],\n    \"953\": [0, 0.43056, 0, 0.05556, 0.35394],\n    \"954\": [0, 0.43056, 0, 0, 0.57616],\n    \"955\": [0, 0.69444, 0, 0, 0.58334],\n    \"956\": [0.19444, 0.43056, 0, 0.02778, 0.60255],\n    \"957\": [0, 0.43056, 0.06366, 0.02778, 0.49398],\n    \"958\": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],\n    \"959\": [0, 0.43056, 0, 0.05556, 0.48472],\n    \"960\": [0, 0.43056, 0.03588, 0, 0.57003],\n    \"961\": [0.19444, 0.43056, 0, 0.08334, 0.51702],\n    \"962\": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],\n    \"963\": [0, 0.43056, 0.03588, 0, 0.57141],\n    \"964\": [0, 0.43056, 0.1132, 0.02778, 0.43715],\n    \"965\": [0, 0.43056, 0.03588, 0.02778, 0.54028],\n    \"966\": [0.19444, 0.43056, 0, 0.08334, 0.65417],\n    \"967\": [0.19444, 0.43056, 0, 0.05556, 0.62569],\n    \"968\": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],\n    \"969\": [0, 0.43056, 0.03588, 0, 0.62245],\n    \"977\": [0, 0.69444, 0, 0.08334, 0.59144],\n    \"981\": [0.19444, 0.69444, 0, 0.08334, 0.59583],\n    \"982\": [0, 0.43056, 0.02778, 0, 0.82813],\n    \"1009\": [0.19444, 0.43056, 0, 0.08334, 0.51702],\n    \"1013\": [0, 0.43056, 0, 0.05556, 0.4059]\n  },\n  \"Math-Regular\": {\n    \"65\": [0, 0.68333, 0, 0.13889, 0.75],\n    \"66\": [0, 0.68333, 0.05017, 0.08334, 0.75851],\n    \"67\": [0, 0.68333, 0.07153, 0.08334, 0.71472],\n    \"68\": [0, 0.68333, 0.02778, 0.05556, 0.82792],\n    \"69\": [0, 0.68333, 0.05764, 0.08334, 0.7382],\n    \"70\": [0, 0.68333, 0.13889, 0.08334, 0.64306],\n    \"71\": [0, 0.68333, 0, 0.08334, 0.78625],\n    \"72\": [0, 0.68333, 0.08125, 0.05556, 0.83125],\n    \"73\": [0, 0.68333, 0.07847, 0.11111, 0.43958],\n    \"74\": [0, 0.68333, 0.09618, 0.16667, 0.55451],\n    \"75\": [0, 0.68333, 0.07153, 0.05556, 0.84931],\n    \"76\": [0, 0.68333, 0, 0.02778, 0.68056],\n    \"77\": [0, 0.68333, 0.10903, 0.08334, 0.97014],\n    \"78\": [0, 0.68333, 0.10903, 0.08334, 0.80347],\n    \"79\": [0, 0.68333, 0.02778, 0.08334, 0.76278],\n    \"80\": [0, 0.68333, 0.13889, 0.08334, 0.64201],\n    \"81\": [0.19444, 0.68333, 0, 0.08334, 0.79056],\n    \"82\": [0, 0.68333, 0.00773, 0.08334, 0.75929],\n    \"83\": [0, 0.68333, 0.05764, 0.08334, 0.6132],\n    \"84\": [0, 0.68333, 0.13889, 0.08334, 0.58438],\n    \"85\": [0, 0.68333, 0.10903, 0.02778, 0.68278],\n    \"86\": [0, 0.68333, 0.22222, 0, 0.58333],\n    \"87\": [0, 0.68333, 0.13889, 0, 0.94445],\n    \"88\": [0, 0.68333, 0.07847, 0.08334, 0.82847],\n    \"89\": [0, 0.68333, 0.22222, 0, 0.58056],\n    \"90\": [0, 0.68333, 0.07153, 0.08334, 0.68264],\n    \"97\": [0, 0.43056, 0, 0, 0.52859],\n    \"98\": [0, 0.69444, 0, 0, 0.42917],\n    \"99\": [0, 0.43056, 0, 0.05556, 0.43276],\n    \"100\": [0, 0.69444, 0, 0.16667, 0.52049],\n    \"101\": [0, 0.43056, 0, 0.05556, 0.46563],\n    \"102\": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],\n    \"103\": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],\n    \"104\": [0, 0.69444, 0, 0, 0.57616],\n    \"105\": [0, 0.65952, 0, 0, 0.34451],\n    \"106\": [0.19444, 0.65952, 0.05724, 0, 0.41181],\n    \"107\": [0, 0.69444, 0.03148, 0, 0.5206],\n    \"108\": [0, 0.69444, 0.01968, 0.08334, 0.29838],\n    \"109\": [0, 0.43056, 0, 0, 0.87801],\n    \"110\": [0, 0.43056, 0, 0, 0.60023],\n    \"111\": [0, 0.43056, 0, 0.05556, 0.48472],\n    \"112\": [0.19444, 0.43056, 0, 0.08334, 0.50313],\n    \"113\": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],\n    \"114\": [0, 0.43056, 0.02778, 0.05556, 0.45116],\n    \"115\": [0, 0.43056, 0, 0.05556, 0.46875],\n    \"116\": [0, 0.61508, 0, 0.08334, 0.36111],\n    \"117\": [0, 0.43056, 0, 0.02778, 0.57246],\n    \"118\": [0, 0.43056, 0.03588, 0.02778, 0.48472],\n    \"119\": [0, 0.43056, 0.02691, 0.08334, 0.71592],\n    \"120\": [0, 0.43056, 0, 0.02778, 0.57153],\n    \"121\": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],\n    \"122\": [0, 0.43056, 0.04398, 0.05556, 0.46505],\n    \"915\": [0, 0.68333, 0.13889, 0.08334, 0.61528],\n    \"916\": [0, 0.68333, 0, 0.16667, 0.83334],\n    \"920\": [0, 0.68333, 0.02778, 0.08334, 0.76278],\n    \"923\": [0, 0.68333, 0, 0.16667, 0.69445],\n    \"926\": [0, 0.68333, 0.07569, 0.08334, 0.74236],\n    \"928\": [0, 0.68333, 0.08125, 0.05556, 0.83125],\n    \"931\": [0, 0.68333, 0.05764, 0.08334, 0.77986],\n    \"933\": [0, 0.68333, 0.13889, 0.05556, 0.58333],\n    \"934\": [0, 0.68333, 0, 0.08334, 0.66667],\n    \"936\": [0, 0.68333, 0.11, 0.05556, 0.61222],\n    \"937\": [0, 0.68333, 0.05017, 0.08334, 0.7724],\n    \"945\": [0, 0.43056, 0.0037, 0.02778, 0.6397],\n    \"946\": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],\n    \"947\": [0.19444, 0.43056, 0.05556, 0, 0.51773],\n    \"948\": [0, 0.69444, 0.03785, 0.05556, 0.44444],\n    \"949\": [0, 0.43056, 0, 0.08334, 0.46632],\n    \"950\": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],\n    \"951\": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],\n    \"952\": [0, 0.69444, 0.02778, 0.08334, 0.46944],\n    \"953\": [0, 0.43056, 0, 0.05556, 0.35394],\n    \"954\": [0, 0.43056, 0, 0, 0.57616],\n    \"955\": [0, 0.69444, 0, 0, 0.58334],\n    \"956\": [0.19444, 0.43056, 0, 0.02778, 0.60255],\n    \"957\": [0, 0.43056, 0.06366, 0.02778, 0.49398],\n    \"958\": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],\n    \"959\": [0, 0.43056, 0, 0.05556, 0.48472],\n    \"960\": [0, 0.43056, 0.03588, 0, 0.57003],\n    \"961\": [0.19444, 0.43056, 0, 0.08334, 0.51702],\n    \"962\": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],\n    \"963\": [0, 0.43056, 0.03588, 0, 0.57141],\n    \"964\": [0, 0.43056, 0.1132, 0.02778, 0.43715],\n    \"965\": [0, 0.43056, 0.03588, 0.02778, 0.54028],\n    \"966\": [0.19444, 0.43056, 0, 0.08334, 0.65417],\n    \"967\": [0.19444, 0.43056, 0, 0.05556, 0.62569],\n    \"968\": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],\n    \"969\": [0, 0.43056, 0.03588, 0, 0.62245],\n    \"977\": [0, 0.69444, 0, 0.08334, 0.59144],\n    \"981\": [0.19444, 0.69444, 0, 0.08334, 0.59583],\n    \"982\": [0, 0.43056, 0.02778, 0, 0.82813],\n    \"1009\": [0.19444, 0.43056, 0, 0.08334, 0.51702],\n    \"1013\": [0, 0.43056, 0, 0.05556, 0.4059]\n  },\n  \"SansSerif-Bold\": {\n    \"33\": [0, 0.69444, 0, 0, 0.36667],\n    \"34\": [0, 0.69444, 0, 0, 0.55834],\n    \"35\": [0.19444, 0.69444, 0, 0, 0.91667],\n    \"36\": [0.05556, 0.75, 0, 0, 0.55],\n    \"37\": [0.05556, 0.75, 0, 0, 1.02912],\n    \"38\": [0, 0.69444, 0, 0, 0.83056],\n    \"39\": [0, 0.69444, 0, 0, 0.30556],\n    \"40\": [0.25, 0.75, 0, 0, 0.42778],\n    \"41\": [0.25, 0.75, 0, 0, 0.42778],\n    \"42\": [0, 0.75, 0, 0, 0.55],\n    \"43\": [0.11667, 0.61667, 0, 0, 0.85556],\n    \"44\": [0.10556, 0.13056, 0, 0, 0.30556],\n    \"45\": [0, 0.45833, 0, 0, 0.36667],\n    \"46\": [0, 0.13056, 0, 0, 0.30556],\n    \"47\": [0.25, 0.75, 0, 0, 0.55],\n    \"48\": [0, 0.69444, 0, 0, 0.55],\n    \"49\": [0, 0.69444, 0, 0, 0.55],\n    \"50\": [0, 0.69444, 0, 0, 0.55],\n    \"51\": [0, 0.69444, 0, 0, 0.55],\n    \"52\": [0, 0.69444, 0, 0, 0.55],\n    \"53\": [0, 0.69444, 0, 0, 0.55],\n    \"54\": [0, 0.69444, 0, 0, 0.55],\n    \"55\": [0, 0.69444, 0, 0, 0.55],\n    \"56\": [0, 0.69444, 0, 0, 0.55],\n    \"57\": [0, 0.69444, 0, 0, 0.55],\n    \"58\": [0, 0.45833, 0, 0, 0.30556],\n    \"59\": [0.10556, 0.45833, 0, 0, 0.30556],\n    \"61\": [-0.09375, 0.40625, 0, 0, 0.85556],\n    \"63\": [0, 0.69444, 0, 0, 0.51945],\n    \"64\": [0, 0.69444, 0, 0, 0.73334],\n    \"65\": [0, 0.69444, 0, 0, 0.73334],\n    \"66\": [0, 0.69444, 0, 0, 0.73334],\n    \"67\": [0, 0.69444, 0, 0, 0.70278],\n    \"68\": [0, 0.69444, 0, 0, 0.79445],\n    \"69\": [0, 0.69444, 0, 0, 0.64167],\n    \"70\": [0, 0.69444, 0, 0, 0.61111],\n    \"71\": [0, 0.69444, 0, 0, 0.73334],\n    \"72\": [0, 0.69444, 0, 0, 0.79445],\n    \"73\": [0, 0.69444, 0, 0, 0.33056],\n    \"74\": [0, 0.69444, 0, 0, 0.51945],\n    \"75\": [0, 0.69444, 0, 0, 0.76389],\n    \"76\": [0, 0.69444, 0, 0, 0.58056],\n    \"77\": [0, 0.69444, 0, 0, 0.97778],\n    \"78\": [0, 0.69444, 0, 0, 0.79445],\n    \"79\": [0, 0.69444, 0, 0, 0.79445],\n    \"80\": [0, 0.69444, 0, 0, 0.70278],\n    \"81\": [0.10556, 0.69444, 0, 0, 0.79445],\n    \"82\": [0, 0.69444, 0, 0, 0.70278],\n    \"83\": [0, 0.69444, 0, 0, 0.61111],\n    \"84\": [0, 0.69444, 0, 0, 0.73334],\n    \"85\": [0, 0.69444, 0, 0, 0.76389],\n    \"86\": [0, 0.69444, 0.01528, 0, 0.73334],\n    \"87\": [0, 0.69444, 0.01528, 0, 1.03889],\n    \"88\": [0, 0.69444, 0, 0, 0.73334],\n    \"89\": [0, 0.69444, 0.0275, 0, 0.73334],\n    \"90\": [0, 0.69444, 0, 0, 0.67223],\n    \"91\": [0.25, 0.75, 0, 0, 0.34306],\n    \"93\": [0.25, 0.75, 0, 0, 0.34306],\n    \"94\": [0, 0.69444, 0, 0, 0.55],\n    \"95\": [0.35, 0.10833, 0.03056, 0, 0.55],\n    \"97\": [0, 0.45833, 0, 0, 0.525],\n    \"98\": [0, 0.69444, 0, 0, 0.56111],\n    \"99\": [0, 0.45833, 0, 0, 0.48889],\n    \"100\": [0, 0.69444, 0, 0, 0.56111],\n    \"101\": [0, 0.45833, 0, 0, 0.51111],\n    \"102\": [0, 0.69444, 0.07639, 0, 0.33611],\n    \"103\": [0.19444, 0.45833, 0.01528, 0, 0.55],\n    \"104\": [0, 0.69444, 0, 0, 0.56111],\n    \"105\": [0, 0.69444, 0, 0, 0.25556],\n    \"106\": [0.19444, 0.69444, 0, 0, 0.28611],\n    \"107\": [0, 0.69444, 0, 0, 0.53056],\n    \"108\": [0, 0.69444, 0, 0, 0.25556],\n    \"109\": [0, 0.45833, 0, 0, 0.86667],\n    \"110\": [0, 0.45833, 0, 0, 0.56111],\n    \"111\": [0, 0.45833, 0, 0, 0.55],\n    \"112\": [0.19444, 0.45833, 0, 0, 0.56111],\n    \"113\": [0.19444, 0.45833, 0, 0, 0.56111],\n    \"114\": [0, 0.45833, 0.01528, 0, 0.37222],\n    \"115\": [0, 0.45833, 0, 0, 0.42167],\n    \"116\": [0, 0.58929, 0, 0, 0.40417],\n    \"117\": [0, 0.45833, 0, 0, 0.56111],\n    \"118\": [0, 0.45833, 0.01528, 0, 0.5],\n    \"119\": [0, 0.45833, 0.01528, 0, 0.74445],\n    \"120\": [0, 0.45833, 0, 0, 0.5],\n    \"121\": [0.19444, 0.45833, 0.01528, 0, 0.5],\n    \"122\": [0, 0.45833, 0, 0, 0.47639],\n    \"126\": [0.35, 0.34444, 0, 0, 0.55],\n    \"168\": [0, 0.69444, 0, 0, 0.55],\n    \"176\": [0, 0.69444, 0, 0, 0.73334],\n    \"180\": [0, 0.69444, 0, 0, 0.55],\n    \"184\": [0.17014, 0, 0, 0, 0.48889],\n    \"305\": [0, 0.45833, 0, 0, 0.25556],\n    \"567\": [0.19444, 0.45833, 0, 0, 0.28611],\n    \"710\": [0, 0.69444, 0, 0, 0.55],\n    \"711\": [0, 0.63542, 0, 0, 0.55],\n    \"713\": [0, 0.63778, 0, 0, 0.55],\n    \"728\": [0, 0.69444, 0, 0, 0.55],\n    \"729\": [0, 0.69444, 0, 0, 0.30556],\n    \"730\": [0, 0.69444, 0, 0, 0.73334],\n    \"732\": [0, 0.69444, 0, 0, 0.55],\n    \"733\": [0, 0.69444, 0, 0, 0.55],\n    \"915\": [0, 0.69444, 0, 0, 0.58056],\n    \"916\": [0, 0.69444, 0, 0, 0.91667],\n    \"920\": [0, 0.69444, 0, 0, 0.85556],\n    \"923\": [0, 0.69444, 0, 0, 0.67223],\n    \"926\": [0, 0.69444, 0, 0, 0.73334],\n    \"928\": [0, 0.69444, 0, 0, 0.79445],\n    \"931\": [0, 0.69444, 0, 0, 0.79445],\n    \"933\": [0, 0.69444, 0, 0, 0.85556],\n    \"934\": [0, 0.69444, 0, 0, 0.79445],\n    \"936\": [0, 0.69444, 0, 0, 0.85556],\n    \"937\": [0, 0.69444, 0, 0, 0.79445],\n    \"8211\": [0, 0.45833, 0.03056, 0, 0.55],\n    \"8212\": [0, 0.45833, 0.03056, 0, 1.10001],\n    \"8216\": [0, 0.69444, 0, 0, 0.30556],\n    \"8217\": [0, 0.69444, 0, 0, 0.30556],\n    \"8220\": [0, 0.69444, 0, 0, 0.55834],\n    \"8221\": [0, 0.69444, 0, 0, 0.55834]\n  },\n  \"SansSerif-Italic\": {\n    \"33\": [0, 0.69444, 0.05733, 0, 0.31945],\n    \"34\": [0, 0.69444, 0.00316, 0, 0.5],\n    \"35\": [0.19444, 0.69444, 0.05087, 0, 0.83334],\n    \"36\": [0.05556, 0.75, 0.11156, 0, 0.5],\n    \"37\": [0.05556, 0.75, 0.03126, 0, 0.83334],\n    \"38\": [0, 0.69444, 0.03058, 0, 0.75834],\n    \"39\": [0, 0.69444, 0.07816, 0, 0.27778],\n    \"40\": [0.25, 0.75, 0.13164, 0, 0.38889],\n    \"41\": [0.25, 0.75, 0.02536, 0, 0.38889],\n    \"42\": [0, 0.75, 0.11775, 0, 0.5],\n    \"43\": [0.08333, 0.58333, 0.02536, 0, 0.77778],\n    \"44\": [0.125, 0.08333, 0, 0, 0.27778],\n    \"45\": [0, 0.44444, 0.01946, 0, 0.33333],\n    \"46\": [0, 0.08333, 0, 0, 0.27778],\n    \"47\": [0.25, 0.75, 0.13164, 0, 0.5],\n    \"48\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"49\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"50\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"51\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"52\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"53\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"54\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"55\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"56\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"57\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"58\": [0, 0.44444, 0.02502, 0, 0.27778],\n    \"59\": [0.125, 0.44444, 0.02502, 0, 0.27778],\n    \"61\": [-0.13, 0.37, 0.05087, 0, 0.77778],\n    \"63\": [0, 0.69444, 0.11809, 0, 0.47222],\n    \"64\": [0, 0.69444, 0.07555, 0, 0.66667],\n    \"65\": [0, 0.69444, 0, 0, 0.66667],\n    \"66\": [0, 0.69444, 0.08293, 0, 0.66667],\n    \"67\": [0, 0.69444, 0.11983, 0, 0.63889],\n    \"68\": [0, 0.69444, 0.07555, 0, 0.72223],\n    \"69\": [0, 0.69444, 0.11983, 0, 0.59722],\n    \"70\": [0, 0.69444, 0.13372, 0, 0.56945],\n    \"71\": [0, 0.69444, 0.11983, 0, 0.66667],\n    \"72\": [0, 0.69444, 0.08094, 0, 0.70834],\n    \"73\": [0, 0.69444, 0.13372, 0, 0.27778],\n    \"74\": [0, 0.69444, 0.08094, 0, 0.47222],\n    \"75\": [0, 0.69444, 0.11983, 0, 0.69445],\n    \"76\": [0, 0.69444, 0, 0, 0.54167],\n    \"77\": [0, 0.69444, 0.08094, 0, 0.875],\n    \"78\": [0, 0.69444, 0.08094, 0, 0.70834],\n    \"79\": [0, 0.69444, 0.07555, 0, 0.73611],\n    \"80\": [0, 0.69444, 0.08293, 0, 0.63889],\n    \"81\": [0.125, 0.69444, 0.07555, 0, 0.73611],\n    \"82\": [0, 0.69444, 0.08293, 0, 0.64584],\n    \"83\": [0, 0.69444, 0.09205, 0, 0.55556],\n    \"84\": [0, 0.69444, 0.13372, 0, 0.68056],\n    \"85\": [0, 0.69444, 0.08094, 0, 0.6875],\n    \"86\": [0, 0.69444, 0.1615, 0, 0.66667],\n    \"87\": [0, 0.69444, 0.1615, 0, 0.94445],\n    \"88\": [0, 0.69444, 0.13372, 0, 0.66667],\n    \"89\": [0, 0.69444, 0.17261, 0, 0.66667],\n    \"90\": [0, 0.69444, 0.11983, 0, 0.61111],\n    \"91\": [0.25, 0.75, 0.15942, 0, 0.28889],\n    \"93\": [0.25, 0.75, 0.08719, 0, 0.28889],\n    \"94\": [0, 0.69444, 0.0799, 0, 0.5],\n    \"95\": [0.35, 0.09444, 0.08616, 0, 0.5],\n    \"97\": [0, 0.44444, 0.00981, 0, 0.48056],\n    \"98\": [0, 0.69444, 0.03057, 0, 0.51667],\n    \"99\": [0, 0.44444, 0.08336, 0, 0.44445],\n    \"100\": [0, 0.69444, 0.09483, 0, 0.51667],\n    \"101\": [0, 0.44444, 0.06778, 0, 0.44445],\n    \"102\": [0, 0.69444, 0.21705, 0, 0.30556],\n    \"103\": [0.19444, 0.44444, 0.10836, 0, 0.5],\n    \"104\": [0, 0.69444, 0.01778, 0, 0.51667],\n    \"105\": [0, 0.67937, 0.09718, 0, 0.23889],\n    \"106\": [0.19444, 0.67937, 0.09162, 0, 0.26667],\n    \"107\": [0, 0.69444, 0.08336, 0, 0.48889],\n    \"108\": [0, 0.69444, 0.09483, 0, 0.23889],\n    \"109\": [0, 0.44444, 0.01778, 0, 0.79445],\n    \"110\": [0, 0.44444, 0.01778, 0, 0.51667],\n    \"111\": [0, 0.44444, 0.06613, 0, 0.5],\n    \"112\": [0.19444, 0.44444, 0.0389, 0, 0.51667],\n    \"113\": [0.19444, 0.44444, 0.04169, 0, 0.51667],\n    \"114\": [0, 0.44444, 0.10836, 0, 0.34167],\n    \"115\": [0, 0.44444, 0.0778, 0, 0.38333],\n    \"116\": [0, 0.57143, 0.07225, 0, 0.36111],\n    \"117\": [0, 0.44444, 0.04169, 0, 0.51667],\n    \"118\": [0, 0.44444, 0.10836, 0, 0.46111],\n    \"119\": [0, 0.44444, 0.10836, 0, 0.68334],\n    \"120\": [0, 0.44444, 0.09169, 0, 0.46111],\n    \"121\": [0.19444, 0.44444, 0.10836, 0, 0.46111],\n    \"122\": [0, 0.44444, 0.08752, 0, 0.43472],\n    \"126\": [0.35, 0.32659, 0.08826, 0, 0.5],\n    \"168\": [0, 0.67937, 0.06385, 0, 0.5],\n    \"176\": [0, 0.69444, 0, 0, 0.73752],\n    \"184\": [0.17014, 0, 0, 0, 0.44445],\n    \"305\": [0, 0.44444, 0.04169, 0, 0.23889],\n    \"567\": [0.19444, 0.44444, 0.04169, 0, 0.26667],\n    \"710\": [0, 0.69444, 0.0799, 0, 0.5],\n    \"711\": [0, 0.63194, 0.08432, 0, 0.5],\n    \"713\": [0, 0.60889, 0.08776, 0, 0.5],\n    \"714\": [0, 0.69444, 0.09205, 0, 0.5],\n    \"715\": [0, 0.69444, 0, 0, 0.5],\n    \"728\": [0, 0.69444, 0.09483, 0, 0.5],\n    \"729\": [0, 0.67937, 0.07774, 0, 0.27778],\n    \"730\": [0, 0.69444, 0, 0, 0.73752],\n    \"732\": [0, 0.67659, 0.08826, 0, 0.5],\n    \"733\": [0, 0.69444, 0.09205, 0, 0.5],\n    \"915\": [0, 0.69444, 0.13372, 0, 0.54167],\n    \"916\": [0, 0.69444, 0, 0, 0.83334],\n    \"920\": [0, 0.69444, 0.07555, 0, 0.77778],\n    \"923\": [0, 0.69444, 0, 0, 0.61111],\n    \"926\": [0, 0.69444, 0.12816, 0, 0.66667],\n    \"928\": [0, 0.69444, 0.08094, 0, 0.70834],\n    \"931\": [0, 0.69444, 0.11983, 0, 0.72222],\n    \"933\": [0, 0.69444, 0.09031, 0, 0.77778],\n    \"934\": [0, 0.69444, 0.04603, 0, 0.72222],\n    \"936\": [0, 0.69444, 0.09031, 0, 0.77778],\n    \"937\": [0, 0.69444, 0.08293, 0, 0.72222],\n    \"8211\": [0, 0.44444, 0.08616, 0, 0.5],\n    \"8212\": [0, 0.44444, 0.08616, 0, 1.0],\n    \"8216\": [0, 0.69444, 0.07816, 0, 0.27778],\n    \"8217\": [0, 0.69444, 0.07816, 0, 0.27778],\n    \"8220\": [0, 0.69444, 0.14205, 0, 0.5],\n    \"8221\": [0, 0.69444, 0.00316, 0, 0.5]\n  },\n  \"SansSerif-Regular\": {\n    \"33\": [0, 0.69444, 0, 0, 0.31945],\n    \"34\": [0, 0.69444, 0, 0, 0.5],\n    \"35\": [0.19444, 0.69444, 0, 0, 0.83334],\n    \"36\": [0.05556, 0.75, 0, 0, 0.5],\n    \"37\": [0.05556, 0.75, 0, 0, 0.83334],\n    \"38\": [0, 0.69444, 0, 0, 0.75834],\n    \"39\": [0, 0.69444, 0, 0, 0.27778],\n    \"40\": [0.25, 0.75, 0, 0, 0.38889],\n    \"41\": [0.25, 0.75, 0, 0, 0.38889],\n    \"42\": [0, 0.75, 0, 0, 0.5],\n    \"43\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"44\": [0.125, 0.08333, 0, 0, 0.27778],\n    \"45\": [0, 0.44444, 0, 0, 0.33333],\n    \"46\": [0, 0.08333, 0, 0, 0.27778],\n    \"47\": [0.25, 0.75, 0, 0, 0.5],\n    \"48\": [0, 0.65556, 0, 0, 0.5],\n    \"49\": [0, 0.65556, 0, 0, 0.5],\n    \"50\": [0, 0.65556, 0, 0, 0.5],\n    \"51\": [0, 0.65556, 0, 0, 0.5],\n    \"52\": [0, 0.65556, 0, 0, 0.5],\n    \"53\": [0, 0.65556, 0, 0, 0.5],\n    \"54\": [0, 0.65556, 0, 0, 0.5],\n    \"55\": [0, 0.65556, 0, 0, 0.5],\n    \"56\": [0, 0.65556, 0, 0, 0.5],\n    \"57\": [0, 0.65556, 0, 0, 0.5],\n    \"58\": [0, 0.44444, 0, 0, 0.27778],\n    \"59\": [0.125, 0.44444, 0, 0, 0.27778],\n    \"61\": [-0.13, 0.37, 0, 0, 0.77778],\n    \"63\": [0, 0.69444, 0, 0, 0.47222],\n    \"64\": [0, 0.69444, 0, 0, 0.66667],\n    \"65\": [0, 0.69444, 0, 0, 0.66667],\n    \"66\": [0, 0.69444, 0, 0, 0.66667],\n    \"67\": [0, 0.69444, 0, 0, 0.63889],\n    \"68\": [0, 0.69444, 0, 0, 0.72223],\n    \"69\": [0, 0.69444, 0, 0, 0.59722],\n    \"70\": [0, 0.69444, 0, 0, 0.56945],\n    \"71\": [0, 0.69444, 0, 0, 0.66667],\n    \"72\": [0, 0.69444, 0, 0, 0.70834],\n    \"73\": [0, 0.69444, 0, 0, 0.27778],\n    \"74\": [0, 0.69444, 0, 0, 0.47222],\n    \"75\": [0, 0.69444, 0, 0, 0.69445],\n    \"76\": [0, 0.69444, 0, 0, 0.54167],\n    \"77\": [0, 0.69444, 0, 0, 0.875],\n    \"78\": [0, 0.69444, 0, 0, 0.70834],\n    \"79\": [0, 0.69444, 0, 0, 0.73611],\n    \"80\": [0, 0.69444, 0, 0, 0.63889],\n    \"81\": [0.125, 0.69444, 0, 0, 0.73611],\n    \"82\": [0, 0.69444, 0, 0, 0.64584],\n    \"83\": [0, 0.69444, 0, 0, 0.55556],\n    \"84\": [0, 0.69444, 0, 0, 0.68056],\n    \"85\": [0, 0.69444, 0, 0, 0.6875],\n    \"86\": [0, 0.69444, 0.01389, 0, 0.66667],\n    \"87\": [0, 0.69444, 0.01389, 0, 0.94445],\n    \"88\": [0, 0.69444, 0, 0, 0.66667],\n    \"89\": [0, 0.69444, 0.025, 0, 0.66667],\n    \"90\": [0, 0.69444, 0, 0, 0.61111],\n    \"91\": [0.25, 0.75, 0, 0, 0.28889],\n    \"93\": [0.25, 0.75, 0, 0, 0.28889],\n    \"94\": [0, 0.69444, 0, 0, 0.5],\n    \"95\": [0.35, 0.09444, 0.02778, 0, 0.5],\n    \"97\": [0, 0.44444, 0, 0, 0.48056],\n    \"98\": [0, 0.69444, 0, 0, 0.51667],\n    \"99\": [0, 0.44444, 0, 0, 0.44445],\n    \"100\": [0, 0.69444, 0, 0, 0.51667],\n    \"101\": [0, 0.44444, 0, 0, 0.44445],\n    \"102\": [0, 0.69444, 0.06944, 0, 0.30556],\n    \"103\": [0.19444, 0.44444, 0.01389, 0, 0.5],\n    \"104\": [0, 0.69444, 0, 0, 0.51667],\n    \"105\": [0, 0.67937, 0, 0, 0.23889],\n    \"106\": [0.19444, 0.67937, 0, 0, 0.26667],\n    \"107\": [0, 0.69444, 0, 0, 0.48889],\n    \"108\": [0, 0.69444, 0, 0, 0.23889],\n    \"109\": [0, 0.44444, 0, 0, 0.79445],\n    \"110\": [0, 0.44444, 0, 0, 0.51667],\n    \"111\": [0, 0.44444, 0, 0, 0.5],\n    \"112\": [0.19444, 0.44444, 0, 0, 0.51667],\n    \"113\": [0.19444, 0.44444, 0, 0, 0.51667],\n    \"114\": [0, 0.44444, 0.01389, 0, 0.34167],\n    \"115\": [0, 0.44444, 0, 0, 0.38333],\n    \"116\": [0, 0.57143, 0, 0, 0.36111],\n    \"117\": [0, 0.44444, 0, 0, 0.51667],\n    \"118\": [0, 0.44444, 0.01389, 0, 0.46111],\n    \"119\": [0, 0.44444, 0.01389, 0, 0.68334],\n    \"120\": [0, 0.44444, 0, 0, 0.46111],\n    \"121\": [0.19444, 0.44444, 0.01389, 0, 0.46111],\n    \"122\": [0, 0.44444, 0, 0, 0.43472],\n    \"126\": [0.35, 0.32659, 0, 0, 0.5],\n    \"168\": [0, 0.67937, 0, 0, 0.5],\n    \"176\": [0, 0.69444, 0, 0, 0.66667],\n    \"184\": [0.17014, 0, 0, 0, 0.44445],\n    \"305\": [0, 0.44444, 0, 0, 0.23889],\n    \"567\": [0.19444, 0.44444, 0, 0, 0.26667],\n    \"710\": [0, 0.69444, 0, 0, 0.5],\n    \"711\": [0, 0.63194, 0, 0, 0.5],\n    \"713\": [0, 0.60889, 0, 0, 0.5],\n    \"714\": [0, 0.69444, 0, 0, 0.5],\n    \"715\": [0, 0.69444, 0, 0, 0.5],\n    \"728\": [0, 0.69444, 0, 0, 0.5],\n    \"729\": [0, 0.67937, 0, 0, 0.27778],\n    \"730\": [0, 0.69444, 0, 0, 0.66667],\n    \"732\": [0, 0.67659, 0, 0, 0.5],\n    \"733\": [0, 0.69444, 0, 0, 0.5],\n    \"915\": [0, 0.69444, 0, 0, 0.54167],\n    \"916\": [0, 0.69444, 0, 0, 0.83334],\n    \"920\": [0, 0.69444, 0, 0, 0.77778],\n    \"923\": [0, 0.69444, 0, 0, 0.61111],\n    \"926\": [0, 0.69444, 0, 0, 0.66667],\n    \"928\": [0, 0.69444, 0, 0, 0.70834],\n    \"931\": [0, 0.69444, 0, 0, 0.72222],\n    \"933\": [0, 0.69444, 0, 0, 0.77778],\n    \"934\": [0, 0.69444, 0, 0, 0.72222],\n    \"936\": [0, 0.69444, 0, 0, 0.77778],\n    \"937\": [0, 0.69444, 0, 0, 0.72222],\n    \"8211\": [0, 0.44444, 0.02778, 0, 0.5],\n    \"8212\": [0, 0.44444, 0.02778, 0, 1.0],\n    \"8216\": [0, 0.69444, 0, 0, 0.27778],\n    \"8217\": [0, 0.69444, 0, 0, 0.27778],\n    \"8220\": [0, 0.69444, 0, 0, 0.5],\n    \"8221\": [0, 0.69444, 0, 0, 0.5]\n  },\n  \"Script-Regular\": {\n    \"65\": [0, 0.7, 0.22925, 0, 0.80253],\n    \"66\": [0, 0.7, 0.04087, 0, 0.90757],\n    \"67\": [0, 0.7, 0.1689, 0, 0.66619],\n    \"68\": [0, 0.7, 0.09371, 0, 0.77443],\n    \"69\": [0, 0.7, 0.18583, 0, 0.56162],\n    \"70\": [0, 0.7, 0.13634, 0, 0.89544],\n    \"71\": [0, 0.7, 0.17322, 0, 0.60961],\n    \"72\": [0, 0.7, 0.29694, 0, 0.96919],\n    \"73\": [0, 0.7, 0.19189, 0, 0.80907],\n    \"74\": [0.27778, 0.7, 0.19189, 0, 1.05159],\n    \"75\": [0, 0.7, 0.31259, 0, 0.91364],\n    \"76\": [0, 0.7, 0.19189, 0, 0.87373],\n    \"77\": [0, 0.7, 0.15981, 0, 1.08031],\n    \"78\": [0, 0.7, 0.3525, 0, 0.9015],\n    \"79\": [0, 0.7, 0.08078, 0, 0.73787],\n    \"80\": [0, 0.7, 0.08078, 0, 1.01262],\n    \"81\": [0, 0.7, 0.03305, 0, 0.88282],\n    \"82\": [0, 0.7, 0.06259, 0, 0.85],\n    \"83\": [0, 0.7, 0.19189, 0, 0.86767],\n    \"84\": [0, 0.7, 0.29087, 0, 0.74697],\n    \"85\": [0, 0.7, 0.25815, 0, 0.79996],\n    \"86\": [0, 0.7, 0.27523, 0, 0.62204],\n    \"87\": [0, 0.7, 0.27523, 0, 0.80532],\n    \"88\": [0, 0.7, 0.26006, 0, 0.94445],\n    \"89\": [0, 0.7, 0.2939, 0, 0.70961],\n    \"90\": [0, 0.7, 0.24037, 0, 0.8212]\n  },\n  \"Size1-Regular\": {\n    \"40\": [0.35001, 0.85, 0, 0, 0.45834],\n    \"41\": [0.35001, 0.85, 0, 0, 0.45834],\n    \"47\": [0.35001, 0.85, 0, 0, 0.57778],\n    \"91\": [0.35001, 0.85, 0, 0, 0.41667],\n    \"92\": [0.35001, 0.85, 0, 0, 0.57778],\n    \"93\": [0.35001, 0.85, 0, 0, 0.41667],\n    \"123\": [0.35001, 0.85, 0, 0, 0.58334],\n    \"125\": [0.35001, 0.85, 0, 0, 0.58334],\n    \"710\": [0, 0.72222, 0, 0, 0.55556],\n    \"732\": [0, 0.72222, 0, 0, 0.55556],\n    \"770\": [0, 0.72222, 0, 0, 0.55556],\n    \"771\": [0, 0.72222, 0, 0, 0.55556],\n    \"8214\": [-0.00099, 0.601, 0, 0, 0.77778],\n    \"8593\": [1e-05, 0.6, 0, 0, 0.66667],\n    \"8595\": [1e-05, 0.6, 0, 0, 0.66667],\n    \"8657\": [1e-05, 0.6, 0, 0, 0.77778],\n    \"8659\": [1e-05, 0.6, 0, 0, 0.77778],\n    \"8719\": [0.25001, 0.75, 0, 0, 0.94445],\n    \"8720\": [0.25001, 0.75, 0, 0, 0.94445],\n    \"8721\": [0.25001, 0.75, 0, 0, 1.05556],\n    \"8730\": [0.35001, 0.85, 0, 0, 1.0],\n    \"8739\": [-0.00599, 0.606, 0, 0, 0.33333],\n    \"8741\": [-0.00599, 0.606, 0, 0, 0.55556],\n    \"8747\": [0.30612, 0.805, 0.19445, 0, 0.47222],\n    \"8748\": [0.306, 0.805, 0.19445, 0, 0.47222],\n    \"8749\": [0.306, 0.805, 0.19445, 0, 0.47222],\n    \"8750\": [0.30612, 0.805, 0.19445, 0, 0.47222],\n    \"8896\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"8897\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"8898\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"8899\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"8968\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"8969\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"8970\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"8971\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"9168\": [-0.00099, 0.601, 0, 0, 0.66667],\n    \"10216\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"10217\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"10752\": [0.25001, 0.75, 0, 0, 1.11111],\n    \"10753\": [0.25001, 0.75, 0, 0, 1.11111],\n    \"10754\": [0.25001, 0.75, 0, 0, 1.11111],\n    \"10756\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"10758\": [0.25001, 0.75, 0, 0, 0.83334]\n  },\n  \"Size2-Regular\": {\n    \"40\": [0.65002, 1.15, 0, 0, 0.59722],\n    \"41\": [0.65002, 1.15, 0, 0, 0.59722],\n    \"47\": [0.65002, 1.15, 0, 0, 0.81111],\n    \"91\": [0.65002, 1.15, 0, 0, 0.47222],\n    \"92\": [0.65002, 1.15, 0, 0, 0.81111],\n    \"93\": [0.65002, 1.15, 0, 0, 0.47222],\n    \"123\": [0.65002, 1.15, 0, 0, 0.66667],\n    \"125\": [0.65002, 1.15, 0, 0, 0.66667],\n    \"710\": [0, 0.75, 0, 0, 1.0],\n    \"732\": [0, 0.75, 0, 0, 1.0],\n    \"770\": [0, 0.75, 0, 0, 1.0],\n    \"771\": [0, 0.75, 0, 0, 1.0],\n    \"8719\": [0.55001, 1.05, 0, 0, 1.27778],\n    \"8720\": [0.55001, 1.05, 0, 0, 1.27778],\n    \"8721\": [0.55001, 1.05, 0, 0, 1.44445],\n    \"8730\": [0.65002, 1.15, 0, 0, 1.0],\n    \"8747\": [0.86225, 1.36, 0.44445, 0, 0.55556],\n    \"8748\": [0.862, 1.36, 0.44445, 0, 0.55556],\n    \"8749\": [0.862, 1.36, 0.44445, 0, 0.55556],\n    \"8750\": [0.86225, 1.36, 0.44445, 0, 0.55556],\n    \"8896\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"8897\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"8898\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"8899\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"8968\": [0.65002, 1.15, 0, 0, 0.52778],\n    \"8969\": [0.65002, 1.15, 0, 0, 0.52778],\n    \"8970\": [0.65002, 1.15, 0, 0, 0.52778],\n    \"8971\": [0.65002, 1.15, 0, 0, 0.52778],\n    \"10216\": [0.65002, 1.15, 0, 0, 0.61111],\n    \"10217\": [0.65002, 1.15, 0, 0, 0.61111],\n    \"10752\": [0.55001, 1.05, 0, 0, 1.51112],\n    \"10753\": [0.55001, 1.05, 0, 0, 1.51112],\n    \"10754\": [0.55001, 1.05, 0, 0, 1.51112],\n    \"10756\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"10758\": [0.55001, 1.05, 0, 0, 1.11111]\n  },\n  \"Size3-Regular\": {\n    \"40\": [0.95003, 1.45, 0, 0, 0.73611],\n    \"41\": [0.95003, 1.45, 0, 0, 0.73611],\n    \"47\": [0.95003, 1.45, 0, 0, 1.04445],\n    \"91\": [0.95003, 1.45, 0, 0, 0.52778],\n    \"92\": [0.95003, 1.45, 0, 0, 1.04445],\n    \"93\": [0.95003, 1.45, 0, 0, 0.52778],\n    \"123\": [0.95003, 1.45, 0, 0, 0.75],\n    \"125\": [0.95003, 1.45, 0, 0, 0.75],\n    \"710\": [0, 0.75, 0, 0, 1.44445],\n    \"732\": [0, 0.75, 0, 0, 1.44445],\n    \"770\": [0, 0.75, 0, 0, 1.44445],\n    \"771\": [0, 0.75, 0, 0, 1.44445],\n    \"8730\": [0.95003, 1.45, 0, 0, 1.0],\n    \"8968\": [0.95003, 1.45, 0, 0, 0.58334],\n    \"8969\": [0.95003, 1.45, 0, 0, 0.58334],\n    \"8970\": [0.95003, 1.45, 0, 0, 0.58334],\n    \"8971\": [0.95003, 1.45, 0, 0, 0.58334],\n    \"10216\": [0.95003, 1.45, 0, 0, 0.75],\n    \"10217\": [0.95003, 1.45, 0, 0, 0.75]\n  },\n  \"Size4-Regular\": {\n    \"40\": [1.25003, 1.75, 0, 0, 0.79167],\n    \"41\": [1.25003, 1.75, 0, 0, 0.79167],\n    \"47\": [1.25003, 1.75, 0, 0, 1.27778],\n    \"91\": [1.25003, 1.75, 0, 0, 0.58334],\n    \"92\": [1.25003, 1.75, 0, 0, 1.27778],\n    \"93\": [1.25003, 1.75, 0, 0, 0.58334],\n    \"123\": [1.25003, 1.75, 0, 0, 0.80556],\n    \"125\": [1.25003, 1.75, 0, 0, 0.80556],\n    \"710\": [0, 0.825, 0, 0, 1.8889],\n    \"732\": [0, 0.825, 0, 0, 1.8889],\n    \"770\": [0, 0.825, 0, 0, 1.8889],\n    \"771\": [0, 0.825, 0, 0, 1.8889],\n    \"8730\": [1.25003, 1.75, 0, 0, 1.0],\n    \"8968\": [1.25003, 1.75, 0, 0, 0.63889],\n    \"8969\": [1.25003, 1.75, 0, 0, 0.63889],\n    \"8970\": [1.25003, 1.75, 0, 0, 0.63889],\n    \"8971\": [1.25003, 1.75, 0, 0, 0.63889],\n    \"9115\": [0.64502, 1.155, 0, 0, 0.875],\n    \"9116\": [1e-05, 0.6, 0, 0, 0.875],\n    \"9117\": [0.64502, 1.155, 0, 0, 0.875],\n    \"9118\": [0.64502, 1.155, 0, 0, 0.875],\n    \"9119\": [1e-05, 0.6, 0, 0, 0.875],\n    \"9120\": [0.64502, 1.155, 0, 0, 0.875],\n    \"9121\": [0.64502, 1.155, 0, 0, 0.66667],\n    \"9122\": [-0.00099, 0.601, 0, 0, 0.66667],\n    \"9123\": [0.64502, 1.155, 0, 0, 0.66667],\n    \"9124\": [0.64502, 1.155, 0, 0, 0.66667],\n    \"9125\": [-0.00099, 0.601, 0, 0, 0.66667],\n    \"9126\": [0.64502, 1.155, 0, 0, 0.66667],\n    \"9127\": [1e-05, 0.9, 0, 0, 0.88889],\n    \"9128\": [0.65002, 1.15, 0, 0, 0.88889],\n    \"9129\": [0.90001, 0, 0, 0, 0.88889],\n    \"9130\": [0, 0.3, 0, 0, 0.88889],\n    \"9131\": [1e-05, 0.9, 0, 0, 0.88889],\n    \"9132\": [0.65002, 1.15, 0, 0, 0.88889],\n    \"9133\": [0.90001, 0, 0, 0, 0.88889],\n    \"9143\": [0.88502, 0.915, 0, 0, 1.05556],\n    \"10216\": [1.25003, 1.75, 0, 0, 0.80556],\n    \"10217\": [1.25003, 1.75, 0, 0, 0.80556],\n    \"57344\": [-0.00499, 0.605, 0, 0, 1.05556],\n    \"57345\": [-0.00499, 0.605, 0, 0, 1.05556],\n    \"57680\": [0, 0.12, 0, 0, 0.45],\n    \"57681\": [0, 0.12, 0, 0, 0.45],\n    \"57682\": [0, 0.12, 0, 0, 0.45],\n    \"57683\": [0, 0.12, 0, 0, 0.45]\n  },\n  \"Typewriter-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.525],\n    \"33\": [0, 0.61111, 0, 0, 0.525],\n    \"34\": [0, 0.61111, 0, 0, 0.525],\n    \"35\": [0, 0.61111, 0, 0, 0.525],\n    \"36\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"37\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"38\": [0, 0.61111, 0, 0, 0.525],\n    \"39\": [0, 0.61111, 0, 0, 0.525],\n    \"40\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"41\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"42\": [0, 0.52083, 0, 0, 0.525],\n    \"43\": [-0.08056, 0.53055, 0, 0, 0.525],\n    \"44\": [0.13889, 0.125, 0, 0, 0.525],\n    \"45\": [-0.08056, 0.53055, 0, 0, 0.525],\n    \"46\": [0, 0.125, 0, 0, 0.525],\n    \"47\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"48\": [0, 0.61111, 0, 0, 0.525],\n    \"49\": [0, 0.61111, 0, 0, 0.525],\n    \"50\": [0, 0.61111, 0, 0, 0.525],\n    \"51\": [0, 0.61111, 0, 0, 0.525],\n    \"52\": [0, 0.61111, 0, 0, 0.525],\n    \"53\": [0, 0.61111, 0, 0, 0.525],\n    \"54\": [0, 0.61111, 0, 0, 0.525],\n    \"55\": [0, 0.61111, 0, 0, 0.525],\n    \"56\": [0, 0.61111, 0, 0, 0.525],\n    \"57\": [0, 0.61111, 0, 0, 0.525],\n    \"58\": [0, 0.43056, 0, 0, 0.525],\n    \"59\": [0.13889, 0.43056, 0, 0, 0.525],\n    \"60\": [-0.05556, 0.55556, 0, 0, 0.525],\n    \"61\": [-0.19549, 0.41562, 0, 0, 0.525],\n    \"62\": [-0.05556, 0.55556, 0, 0, 0.525],\n    \"63\": [0, 0.61111, 0, 0, 0.525],\n    \"64\": [0, 0.61111, 0, 0, 0.525],\n    \"65\": [0, 0.61111, 0, 0, 0.525],\n    \"66\": [0, 0.61111, 0, 0, 0.525],\n    \"67\": [0, 0.61111, 0, 0, 0.525],\n    \"68\": [0, 0.61111, 0, 0, 0.525],\n    \"69\": [0, 0.61111, 0, 0, 0.525],\n    \"70\": [0, 0.61111, 0, 0, 0.525],\n    \"71\": [0, 0.61111, 0, 0, 0.525],\n    \"72\": [0, 0.61111, 0, 0, 0.525],\n    \"73\": [0, 0.61111, 0, 0, 0.525],\n    \"74\": [0, 0.61111, 0, 0, 0.525],\n    \"75\": [0, 0.61111, 0, 0, 0.525],\n    \"76\": [0, 0.61111, 0, 0, 0.525],\n    \"77\": [0, 0.61111, 0, 0, 0.525],\n    \"78\": [0, 0.61111, 0, 0, 0.525],\n    \"79\": [0, 0.61111, 0, 0, 0.525],\n    \"80\": [0, 0.61111, 0, 0, 0.525],\n    \"81\": [0.13889, 0.61111, 0, 0, 0.525],\n    \"82\": [0, 0.61111, 0, 0, 0.525],\n    \"83\": [0, 0.61111, 0, 0, 0.525],\n    \"84\": [0, 0.61111, 0, 0, 0.525],\n    \"85\": [0, 0.61111, 0, 0, 0.525],\n    \"86\": [0, 0.61111, 0, 0, 0.525],\n    \"87\": [0, 0.61111, 0, 0, 0.525],\n    \"88\": [0, 0.61111, 0, 0, 0.525],\n    \"89\": [0, 0.61111, 0, 0, 0.525],\n    \"90\": [0, 0.61111, 0, 0, 0.525],\n    \"91\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"92\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"93\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"94\": [0, 0.61111, 0, 0, 0.525],\n    \"95\": [0.09514, 0, 0, 0, 0.525],\n    \"96\": [0, 0.61111, 0, 0, 0.525],\n    \"97\": [0, 0.43056, 0, 0, 0.525],\n    \"98\": [0, 0.61111, 0, 0, 0.525],\n    \"99\": [0, 0.43056, 0, 0, 0.525],\n    \"100\": [0, 0.61111, 0, 0, 0.525],\n    \"101\": [0, 0.43056, 0, 0, 0.525],\n    \"102\": [0, 0.61111, 0, 0, 0.525],\n    \"103\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"104\": [0, 0.61111, 0, 0, 0.525],\n    \"105\": [0, 0.61111, 0, 0, 0.525],\n    \"106\": [0.22222, 0.61111, 0, 0, 0.525],\n    \"107\": [0, 0.61111, 0, 0, 0.525],\n    \"108\": [0, 0.61111, 0, 0, 0.525],\n    \"109\": [0, 0.43056, 0, 0, 0.525],\n    \"110\": [0, 0.43056, 0, 0, 0.525],\n    \"111\": [0, 0.43056, 0, 0, 0.525],\n    \"112\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"113\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"114\": [0, 0.43056, 0, 0, 0.525],\n    \"115\": [0, 0.43056, 0, 0, 0.525],\n    \"116\": [0, 0.55358, 0, 0, 0.525],\n    \"117\": [0, 0.43056, 0, 0, 0.525],\n    \"118\": [0, 0.43056, 0, 0, 0.525],\n    \"119\": [0, 0.43056, 0, 0, 0.525],\n    \"120\": [0, 0.43056, 0, 0, 0.525],\n    \"121\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"122\": [0, 0.43056, 0, 0, 0.525],\n    \"123\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"124\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"125\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"126\": [0, 0.61111, 0, 0, 0.525],\n    \"127\": [0, 0.61111, 0, 0, 0.525],\n    \"160\": [0, 0, 0, 0, 0.525],\n    \"176\": [0, 0.61111, 0, 0, 0.525],\n    \"184\": [0.19445, 0, 0, 0, 0.525],\n    \"305\": [0, 0.43056, 0, 0, 0.525],\n    \"567\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"711\": [0, 0.56597, 0, 0, 0.525],\n    \"713\": [0, 0.56555, 0, 0, 0.525],\n    \"714\": [0, 0.61111, 0, 0, 0.525],\n    \"715\": [0, 0.61111, 0, 0, 0.525],\n    \"728\": [0, 0.61111, 0, 0, 0.525],\n    \"730\": [0, 0.61111, 0, 0, 0.525],\n    \"770\": [0, 0.61111, 0, 0, 0.525],\n    \"771\": [0, 0.61111, 0, 0, 0.525],\n    \"776\": [0, 0.61111, 0, 0, 0.525],\n    \"915\": [0, 0.61111, 0, 0, 0.525],\n    \"916\": [0, 0.61111, 0, 0, 0.525],\n    \"920\": [0, 0.61111, 0, 0, 0.525],\n    \"923\": [0, 0.61111, 0, 0, 0.525],\n    \"926\": [0, 0.61111, 0, 0, 0.525],\n    \"928\": [0, 0.61111, 0, 0, 0.525],\n    \"931\": [0, 0.61111, 0, 0, 0.525],\n    \"933\": [0, 0.61111, 0, 0, 0.525],\n    \"934\": [0, 0.61111, 0, 0, 0.525],\n    \"936\": [0, 0.61111, 0, 0, 0.525],\n    \"937\": [0, 0.61111, 0, 0, 0.525],\n    \"8216\": [0, 0.61111, 0, 0, 0.525],\n    \"8217\": [0, 0.61111, 0, 0, 0.525],\n    \"8242\": [0, 0.61111, 0, 0, 0.525],\n    \"9251\": [0.11111, 0.21944, 0, 0, 0.525]\n  }\n});\n// CONCATENATED MODULE: ./src/fontMetrics.js\n\n\n/**\n * This file contains metrics regarding fonts and individual symbols. The sigma\n * and xi variables, as well as the metricMap map contain data extracted from\n * TeX, TeX font metrics, and the TTF files. These data are then exposed via the\n * `metrics` variable and the getCharacterMetrics function.\n */\n// In TeX, there are actually three sets of dimensions, one for each of\n// textstyle (size index 5 and higher: >=9pt), scriptstyle (size index 3 and 4:\n// 7-8pt), and scriptscriptstyle (size index 1 and 2: 5-6pt).  These are\n// provided in the the arrays below, in that order.\n//\n// The font metrics are stored in fonts cmsy10, cmsy7, and cmsy5 respsectively.\n// This was determined by running the following script:\n//\n//     latex -interaction=nonstopmode \\\n//     '\\documentclass{article}\\usepackage{amsmath}\\begin{document}' \\\n//     '$a$ \\expandafter\\show\\the\\textfont2' \\\n//     '\\expandafter\\show\\the\\scriptfont2' \\\n//     '\\expandafter\\show\\the\\scriptscriptfont2' \\\n//     '\\stop'\n//\n// The metrics themselves were retreived using the following commands:\n//\n//     tftopl cmsy10\n//     tftopl cmsy7\n//     tftopl cmsy5\n//\n// The output of each of these commands is quite lengthy.  The only part we\n// care about is the FONTDIMEN section. Each value is measured in EMs.\nvar sigmasAndXis = {\n  slant: [0.250, 0.250, 0.250],\n  // sigma1\n  space: [0.000, 0.000, 0.000],\n  // sigma2\n  stretch: [0.000, 0.000, 0.000],\n  // sigma3\n  shrink: [0.000, 0.000, 0.000],\n  // sigma4\n  xHeight: [0.431, 0.431, 0.431],\n  // sigma5\n  quad: [1.000, 1.171, 1.472],\n  // sigma6\n  extraSpace: [0.000, 0.000, 0.000],\n  // sigma7\n  num1: [0.677, 0.732, 0.925],\n  // sigma8\n  num2: [0.394, 0.384, 0.387],\n  // sigma9\n  num3: [0.444, 0.471, 0.504],\n  // sigma10\n  denom1: [0.686, 0.752, 1.025],\n  // sigma11\n  denom2: [0.345, 0.344, 0.532],\n  // sigma12\n  sup1: [0.413, 0.503, 0.504],\n  // sigma13\n  sup2: [0.363, 0.431, 0.404],\n  // sigma14\n  sup3: [0.289, 0.286, 0.294],\n  // sigma15\n  sub1: [0.150, 0.143, 0.200],\n  // sigma16\n  sub2: [0.247, 0.286, 0.400],\n  // sigma17\n  supDrop: [0.386, 0.353, 0.494],\n  // sigma18\n  subDrop: [0.050, 0.071, 0.100],\n  // sigma19\n  delim1: [2.390, 1.700, 1.980],\n  // sigma20\n  delim2: [1.010, 1.157, 1.420],\n  // sigma21\n  axisHeight: [0.250, 0.250, 0.250],\n  // sigma22\n  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;\n  // they correspond to the font parameters of the extension fonts (family 3).\n  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to\n  // match cmex7, we'd use cmex7.tfm values for script and scriptscript\n  // values.\n  defaultRuleThickness: [0.04, 0.049, 0.049],\n  // xi8; cmex7: 0.049\n  bigOpSpacing1: [0.111, 0.111, 0.111],\n  // xi9\n  bigOpSpacing2: [0.166, 0.166, 0.166],\n  // xi10\n  bigOpSpacing3: [0.2, 0.2, 0.2],\n  // xi11\n  bigOpSpacing4: [0.6, 0.611, 0.611],\n  // xi12; cmex7: 0.611\n  bigOpSpacing5: [0.1, 0.143, 0.143],\n  // xi13; cmex7: 0.143\n  // The \\sqrt rule width is taken from the height of the surd character.\n  // Since we use the same font at all sizes, this thickness doesn't scale.\n  sqrtRuleThickness: [0.04, 0.04, 0.04],\n  // This value determines how large a pt is, for metrics which are defined\n  // in terms of pts.\n  // This value is also used in katex.less; if you change it make sure the\n  // values match.\n  ptPerEm: [10.0, 10.0, 10.0],\n  // The space between adjacent `|` columns in an array definition. From\n  // `\\showthe\\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.\n  doubleRuleSep: [0.2, 0.2, 0.2],\n  // The width of separator lines in {array} environments. From\n  // `\\showthe\\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.\n  arrayRuleWidth: [0.04, 0.04, 0.04],\n  // Two values from LaTeX source2e:\n  fboxsep: [0.3, 0.3, 0.3],\n  //        3 pt / ptPerEm\n  fboxrule: [0.04, 0.04, 0.04] // 0.4 pt / ptPerEm\n\n}; // This map contains a mapping from font name and character code to character\n// metrics, including height, depth, italic correction, and skew (kern from the\n// character to the corresponding \\skewchar)\n// This map is generated via `make metrics`. It should not be changed manually.\n\n // These are very rough approximations.  We default to Times New Roman which\n// should have Latin-1 and Cyrillic characters, but may not depending on the\n// operating system.  The metrics do not account for extra height from the\n// accents.  In the case of Cyrillic characters which have both ascenders and\n// descenders we prefer approximations with ascenders, primarily to prevent\n// the fraction bar or root line from intersecting the glyph.\n// TODO(kevinb) allow union of multiple glyph metrics for better accuracy.\n\nvar extraCharacterMap = {\n  // Latin-1\n  'Å': 'A',\n  'Ç': 'C',\n  'Ð': 'D',\n  'Þ': 'o',\n  'å': 'a',\n  'ç': 'c',\n  'ð': 'd',\n  'þ': 'o',\n  // Cyrillic\n  'А': 'A',\n  'Б': 'B',\n  'В': 'B',\n  'Г': 'F',\n  'Д': 'A',\n  'Е': 'E',\n  'Ж': 'K',\n  'З': '3',\n  'И': 'N',\n  'Й': 'N',\n  'К': 'K',\n  'Л': 'N',\n  'М': 'M',\n  'Н': 'H',\n  'О': 'O',\n  'П': 'N',\n  'Р': 'P',\n  'С': 'C',\n  'Т': 'T',\n  'У': 'y',\n  'Ф': 'O',\n  'Х': 'X',\n  'Ц': 'U',\n  'Ч': 'h',\n  'Ш': 'W',\n  'Щ': 'W',\n  'Ъ': 'B',\n  'Ы': 'X',\n  'Ь': 'B',\n  'Э': '3',\n  'Ю': 'X',\n  'Я': 'R',\n  'а': 'a',\n  'б': 'b',\n  'в': 'a',\n  'г': 'r',\n  'д': 'y',\n  'е': 'e',\n  'ж': 'm',\n  'з': 'e',\n  'и': 'n',\n  'й': 'n',\n  'к': 'n',\n  'л': 'n',\n  'м': 'm',\n  'н': 'n',\n  'о': 'o',\n  'п': 'n',\n  'р': 'p',\n  'с': 'c',\n  'т': 'o',\n  'у': 'y',\n  'ф': 'b',\n  'х': 'x',\n  'ц': 'n',\n  'ч': 'n',\n  'ш': 'w',\n  'щ': 'w',\n  'ъ': 'a',\n  'ы': 'm',\n  'ь': 'a',\n  'э': 'e',\n  'ю': 'm',\n  'я': 'r'\n};\n\n/**\n * This function adds new font metrics to default metricMap\n * It can also override existing metrics\n */\nfunction setFontMetrics(fontName, metrics) {\n  fontMetricsData[fontName] = metrics;\n}\n/**\n * This function is a convenience function for looking up information in the\n * metricMap table. It takes a character as a string, and a font.\n *\n * Note: the `width` property may be undefined if fontMetricsData.js wasn't\n * built using `Make extended_metrics`.\n */\n\nfunction getCharacterMetrics(character, font, mode) {\n  if (!fontMetricsData[font]) {\n    throw new Error(\"Font metrics not found for font: \" + font + \".\");\n  }\n\n  var ch = character.charCodeAt(0);\n  var metrics = fontMetricsData[font][ch];\n\n  if (!metrics && character[0] in extraCharacterMap) {\n    ch = extraCharacterMap[character[0]].charCodeAt(0);\n    metrics = fontMetricsData[font][ch];\n  }\n\n  if (!metrics && mode === 'text') {\n    // We don't typically have font metrics for Asian scripts.\n    // But since we support them in text mode, we need to return\n    // some sort of metrics.\n    // So if the character is in a script we support but we\n    // don't have metrics for it, just use the metrics for\n    // the Latin capital letter M. This is close enough because\n    // we (currently) only care about the height of the glpyh\n    // not its width.\n    if (supportedCodepoint(ch)) {\n      metrics = fontMetricsData[font][77]; // 77 is the charcode for 'M'\n    }\n  }\n\n  if (metrics) {\n    return {\n      depth: metrics[0],\n      height: metrics[1],\n      italic: metrics[2],\n      skew: metrics[3],\n      width: metrics[4]\n    };\n  }\n}\nvar fontMetricsBySizeIndex = {};\n/**\n * Get the font metrics for a given size.\n */\n\nfunction getGlobalMetrics(size) {\n  var sizeIndex;\n\n  if (size >= 5) {\n    sizeIndex = 0;\n  } else if (size >= 3) {\n    sizeIndex = 1;\n  } else {\n    sizeIndex = 2;\n  }\n\n  if (!fontMetricsBySizeIndex[sizeIndex]) {\n    var metrics = fontMetricsBySizeIndex[sizeIndex] = {\n      cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18\n    };\n\n    for (var key in sigmasAndXis) {\n      if (sigmasAndXis.hasOwnProperty(key)) {\n        metrics[key] = sigmasAndXis[key][sizeIndex];\n      }\n    }\n  }\n\n  return fontMetricsBySizeIndex[sizeIndex];\n}\n// CONCATENATED MODULE: ./src/symbols.js\n/**\n * This file holds a list of all no-argument functions and single-character\n * symbols (like 'a' or ';').\n *\n * For each of the symbols, there are three properties they can have:\n * - font (required): the font to be used for this symbol. Either \"main\" (the\n     normal font), or \"ams\" (the ams fonts).\n * - group (required): the ParseNode group type the symbol should have (i.e.\n     \"textord\", \"mathord\", etc).\n     See https://github.com/KaTeX/KaTeX/wiki/Examining-TeX#group-types\n * - replace: the character that this symbol or function should be\n *   replaced with (i.e. \"\\phi\" has a replace value of \"\\u03d5\", the phi\n *   character in the main font).\n *\n * The outermost map in the table indicates what mode the symbols should be\n * accepted in (e.g. \"math\" or \"text\").\n */\n// Some of these have a \"-token\" suffix since these are also used as `ParseNode`\n// types for raw text tokens, and we want to avoid conflicts with higher-level\n// `ParseNode` types. These `ParseNode`s are constructed within `Parser` by\n// looking up the `symbols` map.\nvar ATOMS = {\n  \"bin\": 1,\n  \"close\": 1,\n  \"inner\": 1,\n  \"open\": 1,\n  \"punct\": 1,\n  \"rel\": 1\n};\nvar NON_ATOMS = {\n  \"accent-token\": 1,\n  \"mathord\": 1,\n  \"op-token\": 1,\n  \"spacing\": 1,\n  \"textord\": 1\n};\nvar symbols = {\n  \"math\": {},\n  \"text\": {}\n};\n/* harmony default export */ var src_symbols = (symbols);\n/** `acceptUnicodeChar = true` is only applicable if `replace` is set. */\n\nfunction defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {\n  symbols[mode][name] = {\n    font: font,\n    group: group,\n    replace: replace\n  };\n\n  if (acceptUnicodeChar && replace) {\n    symbols[mode][replace] = symbols[mode][name];\n  }\n} // Some abbreviations for commonly used strings.\n// This helps minify the code, and also spotting typos using jshint.\n// modes:\n\nvar symbols_math = \"math\";\nvar symbols_text = \"text\"; // fonts:\n\nvar main = \"main\";\nvar ams = \"ams\"; // groups:\n\nvar symbols_accent = \"accent-token\";\nvar bin = \"bin\";\nvar symbols_close = \"close\";\nvar symbols_inner = \"inner\";\nvar mathord = \"mathord\";\nvar op = \"op-token\";\nvar symbols_open = \"open\";\nvar punct = \"punct\";\nvar rel = \"rel\";\nvar symbols_spacing = \"spacing\";\nvar symbols_textord = \"textord\"; // Now comes the symbol table\n// Relation Symbols\n\ndefineSymbol(symbols_math, main, rel, \"\\u2261\", \"\\\\equiv\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u227A\", \"\\\\prec\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u227B\", \"\\\\succ\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u223C\", \"\\\\sim\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u22A5\", \"\\\\perp\");\ndefineSymbol(symbols_math, main, rel, \"\\u2AAF\", \"\\\\preceq\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2AB0\", \"\\\\succeq\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2243\", \"\\\\simeq\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2223\", \"\\\\mid\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u226A\", \"\\\\ll\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u226B\", \"\\\\gg\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u224D\", \"\\\\asymp\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2225\", \"\\\\parallel\");\ndefineSymbol(symbols_math, main, rel, \"\\u22C8\", \"\\\\bowtie\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2323\", \"\\\\smile\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2291\", \"\\\\sqsubseteq\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2292\", \"\\\\sqsupseteq\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2250\", \"\\\\doteq\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2322\", \"\\\\frown\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u220B\", \"\\\\ni\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u221D\", \"\\\\propto\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u22A2\", \"\\\\vdash\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u22A3\", \"\\\\dashv\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u220B\", \"\\\\owns\"); // Punctuation\n\ndefineSymbol(symbols_math, main, punct, \".\", \"\\\\ldotp\");\ndefineSymbol(symbols_math, main, punct, \"\\u22C5\", \"\\\\cdotp\"); // Misc Symbols\n\ndefineSymbol(symbols_math, main, symbols_textord, \"#\", \"\\\\#\");\ndefineSymbol(symbols_text, main, symbols_textord, \"#\", \"\\\\#\");\ndefineSymbol(symbols_math, main, symbols_textord, \"&\", \"\\\\&\");\ndefineSymbol(symbols_text, main, symbols_textord, \"&\", \"\\\\&\");\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u2135\", \"\\\\aleph\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u2200\", \"\\\\forall\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u210F\", \"\\\\hbar\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u2203\", \"\\\\exists\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u2207\", \"\\\\nabla\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u266D\", \"\\\\flat\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u2113\", \"\\\\ell\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u266E\", \"\\\\natural\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u2663\", \"\\\\clubsuit\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u2118\", \"\\\\wp\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u266F\", \"\\\\sharp\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u2662\", \"\\\\diamondsuit\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u211C\", \"\\\\Re\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u2661\", \"\\\\heartsuit\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u2111\", \"\\\\Im\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u2660\", \"\\\\spadesuit\", true);\ndefineSymbol(symbols_text, main, symbols_textord, \"\\xA7\", \"\\\\S\", true);\ndefineSymbol(symbols_text, main, symbols_textord, \"\\xB6\", \"\\\\P\", true); // Math and Text\n\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u2020\", \"\\\\dag\");\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u2020\", \"\\\\dag\");\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u2020\", \"\\\\textdagger\");\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u2021\", \"\\\\ddag\");\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u2021\", \"\\\\ddag\");\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u2021\", \"\\\\textdaggerdbl\"); // Large Delimiters\n\ndefineSymbol(symbols_math, main, symbols_close, \"\\u23B1\", \"\\\\rmoustache\", true);\ndefineSymbol(symbols_math, main, symbols_open, \"\\u23B0\", \"\\\\lmoustache\", true);\ndefineSymbol(symbols_math, main, symbols_close, \"\\u27EF\", \"\\\\rgroup\", true);\ndefineSymbol(symbols_math, main, symbols_open, \"\\u27EE\", \"\\\\lgroup\", true); // Binary Operators\n\ndefineSymbol(symbols_math, main, bin, \"\\u2213\", \"\\\\mp\", true);\ndefineSymbol(symbols_math, main, bin, \"\\u2296\", \"\\\\ominus\", true);\ndefineSymbol(symbols_math, main, bin, \"\\u228E\", \"\\\\uplus\", true);\ndefineSymbol(symbols_math, main, bin, \"\\u2293\", \"\\\\sqcap\", true);\ndefineSymbol(symbols_math, main, bin, \"\\u2217\", \"\\\\ast\");\ndefineSymbol(symbols_math, main, bin, \"\\u2294\", \"\\\\sqcup\", true);\ndefineSymbol(symbols_math, main, bin, \"\\u25EF\", \"\\\\bigcirc\");\ndefineSymbol(symbols_math, main, bin, \"\\u2219\", \"\\\\bullet\");\ndefineSymbol(symbols_math, main, bin, \"\\u2021\", \"\\\\ddagger\");\ndefineSymbol(symbols_math, main, bin, \"\\u2240\", \"\\\\wr\", true);\ndefineSymbol(symbols_math, main, bin, \"\\u2A3F\", \"\\\\amalg\");\ndefineSymbol(symbols_math, main, bin, \"&\", \"\\\\And\"); // from amsmath\n// Arrow Symbols\n\ndefineSymbol(symbols_math, main, rel, \"\\u27F5\", \"\\\\longleftarrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u21D0\", \"\\\\Leftarrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u27F8\", \"\\\\Longleftarrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u27F6\", \"\\\\longrightarrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u21D2\", \"\\\\Rightarrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u27F9\", \"\\\\Longrightarrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2194\", \"\\\\leftrightarrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u27F7\", \"\\\\longleftrightarrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u21D4\", \"\\\\Leftrightarrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u27FA\", \"\\\\Longleftrightarrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u21A6\", \"\\\\mapsto\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u27FC\", \"\\\\longmapsto\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2197\", \"\\\\nearrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u21A9\", \"\\\\hookleftarrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u21AA\", \"\\\\hookrightarrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2198\", \"\\\\searrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u21BC\", \"\\\\leftharpoonup\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u21C0\", \"\\\\rightharpoonup\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2199\", \"\\\\swarrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u21BD\", \"\\\\leftharpoondown\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u21C1\", \"\\\\rightharpoondown\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2196\", \"\\\\nwarrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u21CC\", \"\\\\rightleftharpoons\", true); // AMS Negated Binary Relations\n\ndefineSymbol(symbols_math, ams, rel, \"\\u226E\", \"\\\\nless\", true); // Symbol names preceeded by \"@\" each have a corresponding macro.\n\ndefineSymbol(symbols_math, ams, rel, \"\\uE010\", \"\\\\@nleqslant\");\ndefineSymbol(symbols_math, ams, rel, \"\\uE011\", \"\\\\@nleqq\");\ndefineSymbol(symbols_math, ams, rel, \"\\u2A87\", \"\\\\lneq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2268\", \"\\\\lneqq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\uE00C\", \"\\\\@lvertneqq\");\ndefineSymbol(symbols_math, ams, rel, \"\\u22E6\", \"\\\\lnsim\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2A89\", \"\\\\lnapprox\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2280\", \"\\\\nprec\", true); // unicode-math maps \\u22e0 to \\npreccurlyeq. We'll use the AMS synonym.\n\ndefineSymbol(symbols_math, ams, rel, \"\\u22E0\", \"\\\\npreceq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u22E8\", \"\\\\precnsim\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2AB9\", \"\\\\precnapprox\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2241\", \"\\\\nsim\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\uE006\", \"\\\\@nshortmid\");\ndefineSymbol(symbols_math, ams, rel, \"\\u2224\", \"\\\\nmid\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u22AC\", \"\\\\nvdash\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u22AD\", \"\\\\nvDash\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u22EA\", \"\\\\ntriangleleft\");\ndefineSymbol(symbols_math, ams, rel, \"\\u22EC\", \"\\\\ntrianglelefteq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u228A\", \"\\\\subsetneq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\uE01A\", \"\\\\@varsubsetneq\");\ndefineSymbol(symbols_math, ams, rel, \"\\u2ACB\", \"\\\\subsetneqq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\uE017\", \"\\\\@varsubsetneqq\");\ndefineSymbol(symbols_math, ams, rel, \"\\u226F\", \"\\\\ngtr\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\uE00F\", \"\\\\@ngeqslant\");\ndefineSymbol(symbols_math, ams, rel, \"\\uE00E\", \"\\\\@ngeqq\");\ndefineSymbol(symbols_math, ams, rel, \"\\u2A88\", \"\\\\gneq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2269\", \"\\\\gneqq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\uE00D\", \"\\\\@gvertneqq\");\ndefineSymbol(symbols_math, ams, rel, \"\\u22E7\", \"\\\\gnsim\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2A8A\", \"\\\\gnapprox\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2281\", \"\\\\nsucc\", true); // unicode-math maps \\u22e1 to \\nsucccurlyeq. We'll use the AMS synonym.\n\ndefineSymbol(symbols_math, ams, rel, \"\\u22E1\", \"\\\\nsucceq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u22E9\", \"\\\\succnsim\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2ABA\", \"\\\\succnapprox\", true); // unicode-math maps \\u2246 to \\simneqq. We'll use the AMS synonym.\n\ndefineSymbol(symbols_math, ams, rel, \"\\u2246\", \"\\\\ncong\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\uE007\", \"\\\\@nshortparallel\");\ndefineSymbol(symbols_math, ams, rel, \"\\u2226\", \"\\\\nparallel\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u22AF\", \"\\\\nVDash\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u22EB\", \"\\\\ntriangleright\");\ndefineSymbol(symbols_math, ams, rel, \"\\u22ED\", \"\\\\ntrianglerighteq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\uE018\", \"\\\\@nsupseteqq\");\ndefineSymbol(symbols_math, ams, rel, \"\\u228B\", \"\\\\supsetneq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\uE01B\", \"\\\\@varsupsetneq\");\ndefineSymbol(symbols_math, ams, rel, \"\\u2ACC\", \"\\\\supsetneqq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\uE019\", \"\\\\@varsupsetneqq\");\ndefineSymbol(symbols_math, ams, rel, \"\\u22AE\", \"\\\\nVdash\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2AB5\", \"\\\\precneqq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2AB6\", \"\\\\succneqq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\uE016\", \"\\\\@nsubseteqq\");\ndefineSymbol(symbols_math, ams, bin, \"\\u22B4\", \"\\\\unlhd\");\ndefineSymbol(symbols_math, ams, bin, \"\\u22B5\", \"\\\\unrhd\"); // AMS Negated Arrows\n\ndefineSymbol(symbols_math, ams, rel, \"\\u219A\", \"\\\\nleftarrow\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u219B\", \"\\\\nrightarrow\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21CD\", \"\\\\nLeftarrow\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21CF\", \"\\\\nRightarrow\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21AE\", \"\\\\nleftrightarrow\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21CE\", \"\\\\nLeftrightarrow\", true); // AMS Misc\n\ndefineSymbol(symbols_math, ams, rel, \"\\u25B3\", \"\\\\vartriangle\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u210F\", \"\\\\hslash\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u25BD\", \"\\\\triangledown\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u25CA\", \"\\\\lozenge\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u24C8\", \"\\\\circledS\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\xAE\", \"\\\\circledR\");\ndefineSymbol(symbols_text, ams, symbols_textord, \"\\xAE\", \"\\\\circledR\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u2221\", \"\\\\measuredangle\", true);\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u2204\", \"\\\\nexists\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u2127\", \"\\\\mho\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u2132\", \"\\\\Finv\", true);\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u2141\", \"\\\\Game\", true);\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u2035\", \"\\\\backprime\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u25B2\", \"\\\\blacktriangle\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u25BC\", \"\\\\blacktriangledown\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u25A0\", \"\\\\blacksquare\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u29EB\", \"\\\\blacklozenge\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u2605\", \"\\\\bigstar\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u2222\", \"\\\\sphericalangle\", true);\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u2201\", \"\\\\complement\", true); // unicode-math maps U+F0 (ð) to \\matheth. We map to AMS function \\eth\n\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\xF0\", \"\\\\eth\", true);\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u2571\", \"\\\\diagup\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u2572\", \"\\\\diagdown\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u25A1\", \"\\\\square\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u25A1\", \"\\\\Box\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u25CA\", \"\\\\Diamond\"); // unicode-math maps U+A5 to \\mathyen. We map to AMS function \\yen\n\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\xA5\", \"\\\\yen\", true);\ndefineSymbol(symbols_text, ams, symbols_textord, \"\\xA5\", \"\\\\yen\", true);\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u2713\", \"\\\\checkmark\", true);\ndefineSymbol(symbols_text, ams, symbols_textord, \"\\u2713\", \"\\\\checkmark\"); // AMS Hebrew\n\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u2136\", \"\\\\beth\", true);\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u2138\", \"\\\\daleth\", true);\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u2137\", \"\\\\gimel\", true); // AMS Greek\n\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u03DD\", \"\\\\digamma\", true);\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u03F0\", \"\\\\varkappa\"); // AMS Delimiters\n\ndefineSymbol(symbols_math, ams, symbols_open, \"\\u250C\", \"\\\\ulcorner\", true);\ndefineSymbol(symbols_math, ams, symbols_close, \"\\u2510\", \"\\\\urcorner\", true);\ndefineSymbol(symbols_math, ams, symbols_open, \"\\u2514\", \"\\\\llcorner\", true);\ndefineSymbol(symbols_math, ams, symbols_close, \"\\u2518\", \"\\\\lrcorner\", true); // AMS Binary Relations\n\ndefineSymbol(symbols_math, ams, rel, \"\\u2266\", \"\\\\leqq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2A7D\", \"\\\\leqslant\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2A95\", \"\\\\eqslantless\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2272\", \"\\\\lesssim\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2A85\", \"\\\\lessapprox\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u224A\", \"\\\\approxeq\", true);\ndefineSymbol(symbols_math, ams, bin, \"\\u22D6\", \"\\\\lessdot\");\ndefineSymbol(symbols_math, ams, rel, \"\\u22D8\", \"\\\\lll\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2276\", \"\\\\lessgtr\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u22DA\", \"\\\\lesseqgtr\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2A8B\", \"\\\\lesseqqgtr\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2251\", \"\\\\doteqdot\");\ndefineSymbol(symbols_math, ams, rel, \"\\u2253\", \"\\\\risingdotseq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2252\", \"\\\\fallingdotseq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u223D\", \"\\\\backsim\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u22CD\", \"\\\\backsimeq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2AC5\", \"\\\\subseteqq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u22D0\", \"\\\\Subset\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u228F\", \"\\\\sqsubset\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u227C\", \"\\\\preccurlyeq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u22DE\", \"\\\\curlyeqprec\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u227E\", \"\\\\precsim\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2AB7\", \"\\\\precapprox\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u22B2\", \"\\\\vartriangleleft\");\ndefineSymbol(symbols_math, ams, rel, \"\\u22B4\", \"\\\\trianglelefteq\");\ndefineSymbol(symbols_math, ams, rel, \"\\u22A8\", \"\\\\vDash\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u22AA\", \"\\\\Vvdash\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2323\", \"\\\\smallsmile\");\ndefineSymbol(symbols_math, ams, rel, \"\\u2322\", \"\\\\smallfrown\");\ndefineSymbol(symbols_math, ams, rel, \"\\u224F\", \"\\\\bumpeq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u224E\", \"\\\\Bumpeq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2267\", \"\\\\geqq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2A7E\", \"\\\\geqslant\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2A96\", \"\\\\eqslantgtr\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2273\", \"\\\\gtrsim\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2A86\", \"\\\\gtrapprox\", true);\ndefineSymbol(symbols_math, ams, bin, \"\\u22D7\", \"\\\\gtrdot\");\ndefineSymbol(symbols_math, ams, rel, \"\\u22D9\", \"\\\\ggg\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2277\", \"\\\\gtrless\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u22DB\", \"\\\\gtreqless\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2A8C\", \"\\\\gtreqqless\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2256\", \"\\\\eqcirc\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2257\", \"\\\\circeq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u225C\", \"\\\\triangleq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u223C\", \"\\\\thicksim\");\ndefineSymbol(symbols_math, ams, rel, \"\\u2248\", \"\\\\thickapprox\");\ndefineSymbol(symbols_math, ams, rel, \"\\u2AC6\", \"\\\\supseteqq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u22D1\", \"\\\\Supset\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2290\", \"\\\\sqsupset\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u227D\", \"\\\\succcurlyeq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u22DF\", \"\\\\curlyeqsucc\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u227F\", \"\\\\succsim\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2AB8\", \"\\\\succapprox\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u22B3\", \"\\\\vartriangleright\");\ndefineSymbol(symbols_math, ams, rel, \"\\u22B5\", \"\\\\trianglerighteq\");\ndefineSymbol(symbols_math, ams, rel, \"\\u22A9\", \"\\\\Vdash\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2223\", \"\\\\shortmid\");\ndefineSymbol(symbols_math, ams, rel, \"\\u2225\", \"\\\\shortparallel\");\ndefineSymbol(symbols_math, ams, rel, \"\\u226C\", \"\\\\between\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u22D4\", \"\\\\pitchfork\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u221D\", \"\\\\varpropto\");\ndefineSymbol(symbols_math, ams, rel, \"\\u25C0\", \"\\\\blacktriangleleft\"); // unicode-math says that \\therefore is a mathord atom.\n// We kept the amssymb atom type, which is rel.\n\ndefineSymbol(symbols_math, ams, rel, \"\\u2234\", \"\\\\therefore\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u220D\", \"\\\\backepsilon\");\ndefineSymbol(symbols_math, ams, rel, \"\\u25B6\", \"\\\\blacktriangleright\"); // unicode-math says that \\because is a mathord atom.\n// We kept the amssymb atom type, which is rel.\n\ndefineSymbol(symbols_math, ams, rel, \"\\u2235\", \"\\\\because\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u22D8\", \"\\\\llless\");\ndefineSymbol(symbols_math, ams, rel, \"\\u22D9\", \"\\\\gggtr\");\ndefineSymbol(symbols_math, ams, bin, \"\\u22B2\", \"\\\\lhd\");\ndefineSymbol(symbols_math, ams, bin, \"\\u22B3\", \"\\\\rhd\");\ndefineSymbol(symbols_math, ams, rel, \"\\u2242\", \"\\\\eqsim\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u22C8\", \"\\\\Join\");\ndefineSymbol(symbols_math, ams, rel, \"\\u2251\", \"\\\\Doteq\", true); // AMS Binary Operators\n\ndefineSymbol(symbols_math, ams, bin, \"\\u2214\", \"\\\\dotplus\", true);\ndefineSymbol(symbols_math, ams, bin, \"\\u2216\", \"\\\\smallsetminus\");\ndefineSymbol(symbols_math, ams, bin, \"\\u22D2\", \"\\\\Cap\", true);\ndefineSymbol(symbols_math, ams, bin, \"\\u22D3\", \"\\\\Cup\", true);\ndefineSymbol(symbols_math, ams, bin, \"\\u2A5E\", \"\\\\doublebarwedge\", true);\ndefineSymbol(symbols_math, ams, bin, \"\\u229F\", \"\\\\boxminus\", true);\ndefineSymbol(symbols_math, ams, bin, \"\\u229E\", \"\\\\boxplus\", true);\ndefineSymbol(symbols_math, ams, bin, \"\\u22C7\", \"\\\\divideontimes\", true);\ndefineSymbol(symbols_math, ams, bin, \"\\u22C9\", \"\\\\ltimes\", true);\ndefineSymbol(symbols_math, ams, bin, \"\\u22CA\", \"\\\\rtimes\", true);\ndefineSymbol(symbols_math, ams, bin, \"\\u22CB\", \"\\\\leftthreetimes\", true);\ndefineSymbol(symbols_math, ams, bin, \"\\u22CC\", \"\\\\rightthreetimes\", true);\ndefineSymbol(symbols_math, ams, bin, \"\\u22CF\", \"\\\\curlywedge\", true);\ndefineSymbol(symbols_math, ams, bin, \"\\u22CE\", \"\\\\curlyvee\", true);\ndefineSymbol(symbols_math, ams, bin, \"\\u229D\", \"\\\\circleddash\", true);\ndefineSymbol(symbols_math, ams, bin, \"\\u229B\", \"\\\\circledast\", true);\ndefineSymbol(symbols_math, ams, bin, \"\\u22C5\", \"\\\\centerdot\");\ndefineSymbol(symbols_math, ams, bin, \"\\u22BA\", \"\\\\intercal\", true);\ndefineSymbol(symbols_math, ams, bin, \"\\u22D2\", \"\\\\doublecap\");\ndefineSymbol(symbols_math, ams, bin, \"\\u22D3\", \"\\\\doublecup\");\ndefineSymbol(symbols_math, ams, bin, \"\\u22A0\", \"\\\\boxtimes\", true); // AMS Arrows\n// Note: unicode-math maps \\u21e2 to their own function \\rightdasharrow.\n// We'll map it to AMS function \\dashrightarrow. It produces the same atom.\n\ndefineSymbol(symbols_math, ams, rel, \"\\u21E2\", \"\\\\dashrightarrow\", true); // unicode-math maps \\u21e0 to \\leftdasharrow. We'll use the AMS synonym.\n\ndefineSymbol(symbols_math, ams, rel, \"\\u21E0\", \"\\\\dashleftarrow\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21C7\", \"\\\\leftleftarrows\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21C6\", \"\\\\leftrightarrows\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21DA\", \"\\\\Lleftarrow\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u219E\", \"\\\\twoheadleftarrow\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21A2\", \"\\\\leftarrowtail\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21AB\", \"\\\\looparrowleft\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21CB\", \"\\\\leftrightharpoons\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21B6\", \"\\\\curvearrowleft\", true); // unicode-math maps \\u21ba to \\acwopencirclearrow. We'll use the AMS synonym.\n\ndefineSymbol(symbols_math, ams, rel, \"\\u21BA\", \"\\\\circlearrowleft\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21B0\", \"\\\\Lsh\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21C8\", \"\\\\upuparrows\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21BF\", \"\\\\upharpoonleft\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21C3\", \"\\\\downharpoonleft\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u22B8\", \"\\\\multimap\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21AD\", \"\\\\leftrightsquigarrow\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21C9\", \"\\\\rightrightarrows\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21C4\", \"\\\\rightleftarrows\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21A0\", \"\\\\twoheadrightarrow\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21A3\", \"\\\\rightarrowtail\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21AC\", \"\\\\looparrowright\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21B7\", \"\\\\curvearrowright\", true); // unicode-math maps \\u21bb to \\cwopencirclearrow. We'll use the AMS synonym.\n\ndefineSymbol(symbols_math, ams, rel, \"\\u21BB\", \"\\\\circlearrowright\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21B1\", \"\\\\Rsh\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21CA\", \"\\\\downdownarrows\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21BE\", \"\\\\upharpoonright\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21C2\", \"\\\\downharpoonright\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21DD\", \"\\\\rightsquigarrow\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21DD\", \"\\\\leadsto\");\ndefineSymbol(symbols_math, ams, rel, \"\\u21DB\", \"\\\\Rrightarrow\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u21BE\", \"\\\\restriction\");\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u2018\", \"`\");\ndefineSymbol(symbols_math, main, symbols_textord, \"$\", \"\\\\$\");\ndefineSymbol(symbols_text, main, symbols_textord, \"$\", \"\\\\$\");\ndefineSymbol(symbols_text, main, symbols_textord, \"$\", \"\\\\textdollar\");\ndefineSymbol(symbols_math, main, symbols_textord, \"%\", \"\\\\%\");\ndefineSymbol(symbols_text, main, symbols_textord, \"%\", \"\\\\%\");\ndefineSymbol(symbols_math, main, symbols_textord, \"_\", \"\\\\_\");\ndefineSymbol(symbols_text, main, symbols_textord, \"_\", \"\\\\_\");\ndefineSymbol(symbols_text, main, symbols_textord, \"_\", \"\\\\textunderscore\");\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u2220\", \"\\\\angle\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u221E\", \"\\\\infty\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u2032\", \"\\\\prime\");\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u25B3\", \"\\\\triangle\");\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u0393\", \"\\\\Gamma\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u0394\", \"\\\\Delta\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u0398\", \"\\\\Theta\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u039B\", \"\\\\Lambda\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u039E\", \"\\\\Xi\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u03A0\", \"\\\\Pi\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u03A3\", \"\\\\Sigma\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u03A5\", \"\\\\Upsilon\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u03A6\", \"\\\\Phi\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u03A8\", \"\\\\Psi\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u03A9\", \"\\\\Omega\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"A\", \"\\u0391\");\ndefineSymbol(symbols_math, main, symbols_textord, \"B\", \"\\u0392\");\ndefineSymbol(symbols_math, main, symbols_textord, \"E\", \"\\u0395\");\ndefineSymbol(symbols_math, main, symbols_textord, \"Z\", \"\\u0396\");\ndefineSymbol(symbols_math, main, symbols_textord, \"H\", \"\\u0397\");\ndefineSymbol(symbols_math, main, symbols_textord, \"I\", \"\\u0399\");\ndefineSymbol(symbols_math, main, symbols_textord, \"K\", \"\\u039A\");\ndefineSymbol(symbols_math, main, symbols_textord, \"M\", \"\\u039C\");\ndefineSymbol(symbols_math, main, symbols_textord, \"N\", \"\\u039D\");\ndefineSymbol(symbols_math, main, symbols_textord, \"O\", \"\\u039F\");\ndefineSymbol(symbols_math, main, symbols_textord, \"P\", \"\\u03A1\");\ndefineSymbol(symbols_math, main, symbols_textord, \"T\", \"\\u03A4\");\ndefineSymbol(symbols_math, main, symbols_textord, \"X\", \"\\u03A7\");\ndefineSymbol(symbols_math, main, symbols_textord, \"\\xAC\", \"\\\\neg\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\xAC\", \"\\\\lnot\");\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u22A4\", \"\\\\top\");\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u22A5\", \"\\\\bot\");\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u2205\", \"\\\\emptyset\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u2205\", \"\\\\varnothing\");\ndefineSymbol(symbols_math, main, mathord, \"\\u03B1\", \"\\\\alpha\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03B2\", \"\\\\beta\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03B3\", \"\\\\gamma\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03B4\", \"\\\\delta\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03F5\", \"\\\\epsilon\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03B6\", \"\\\\zeta\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03B7\", \"\\\\eta\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03B8\", \"\\\\theta\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03B9\", \"\\\\iota\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03BA\", \"\\\\kappa\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03BB\", \"\\\\lambda\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03BC\", \"\\\\mu\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03BD\", \"\\\\nu\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03BE\", \"\\\\xi\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03BF\", \"\\\\omicron\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03C0\", \"\\\\pi\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03C1\", \"\\\\rho\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03C3\", \"\\\\sigma\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03C4\", \"\\\\tau\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03C5\", \"\\\\upsilon\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03D5\", \"\\\\phi\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03C7\", \"\\\\chi\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03C8\", \"\\\\psi\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03C9\", \"\\\\omega\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03B5\", \"\\\\varepsilon\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03D1\", \"\\\\vartheta\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03D6\", \"\\\\varpi\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03F1\", \"\\\\varrho\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03C2\", \"\\\\varsigma\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u03C6\", \"\\\\varphi\", true);\ndefineSymbol(symbols_math, main, bin, \"\\u2217\", \"*\");\ndefineSymbol(symbols_math, main, bin, \"+\", \"+\");\ndefineSymbol(symbols_math, main, bin, \"\\u2212\", \"-\");\ndefineSymbol(symbols_math, main, bin, \"\\u22C5\", \"\\\\cdot\", true);\ndefineSymbol(symbols_math, main, bin, \"\\u2218\", \"\\\\circ\");\ndefineSymbol(symbols_math, main, bin, \"\\xF7\", \"\\\\div\", true);\ndefineSymbol(symbols_math, main, bin, \"\\xB1\", \"\\\\pm\", true);\ndefineSymbol(symbols_math, main, bin, \"\\xD7\", \"\\\\times\", true);\ndefineSymbol(symbols_math, main, bin, \"\\u2229\", \"\\\\cap\", true);\ndefineSymbol(symbols_math, main, bin, \"\\u222A\", \"\\\\cup\", true);\ndefineSymbol(symbols_math, main, bin, \"\\u2216\", \"\\\\setminus\");\ndefineSymbol(symbols_math, main, bin, \"\\u2227\", \"\\\\land\");\ndefineSymbol(symbols_math, main, bin, \"\\u2228\", \"\\\\lor\");\ndefineSymbol(symbols_math, main, bin, \"\\u2227\", \"\\\\wedge\", true);\ndefineSymbol(symbols_math, main, bin, \"\\u2228\", \"\\\\vee\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u221A\", \"\\\\surd\");\ndefineSymbol(symbols_math, main, symbols_open, \"(\", \"(\");\ndefineSymbol(symbols_math, main, symbols_open, \"[\", \"[\");\ndefineSymbol(symbols_math, main, symbols_open, \"\\u27E8\", \"\\\\langle\", true);\ndefineSymbol(symbols_math, main, symbols_open, \"\\u2223\", \"\\\\lvert\");\ndefineSymbol(symbols_math, main, symbols_open, \"\\u2225\", \"\\\\lVert\");\ndefineSymbol(symbols_math, main, symbols_close, \")\", \")\");\ndefineSymbol(symbols_math, main, symbols_close, \"]\", \"]\");\ndefineSymbol(symbols_math, main, symbols_close, \"?\", \"?\");\ndefineSymbol(symbols_math, main, symbols_close, \"!\", \"!\");\ndefineSymbol(symbols_math, main, symbols_close, \"\\u27E9\", \"\\\\rangle\", true);\ndefineSymbol(symbols_math, main, symbols_close, \"\\u2223\", \"\\\\rvert\");\ndefineSymbol(symbols_math, main, symbols_close, \"\\u2225\", \"\\\\rVert\");\ndefineSymbol(symbols_math, main, rel, \"=\", \"=\");\ndefineSymbol(symbols_math, main, rel, \"<\", \"<\");\ndefineSymbol(symbols_math, main, rel, \">\", \">\");\ndefineSymbol(symbols_math, main, rel, \":\", \":\");\ndefineSymbol(symbols_math, main, rel, \"\\u2248\", \"\\\\approx\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2245\", \"\\\\cong\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2265\", \"\\\\ge\");\ndefineSymbol(symbols_math, main, rel, \"\\u2265\", \"\\\\geq\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2190\", \"\\\\gets\");\ndefineSymbol(symbols_math, main, rel, \">\", \"\\\\gt\");\ndefineSymbol(symbols_math, main, rel, \"\\u2208\", \"\\\\in\", true);\ndefineSymbol(symbols_math, main, rel, \"\\uE020\", \"\\\\@not\");\ndefineSymbol(symbols_math, main, rel, \"\\u2282\", \"\\\\subset\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2283\", \"\\\\supset\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2286\", \"\\\\subseteq\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2287\", \"\\\\supseteq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2288\", \"\\\\nsubseteq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2289\", \"\\\\nsupseteq\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u22A8\", \"\\\\models\");\ndefineSymbol(symbols_math, main, rel, \"\\u2190\", \"\\\\leftarrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2264\", \"\\\\le\");\ndefineSymbol(symbols_math, main, rel, \"\\u2264\", \"\\\\leq\", true);\ndefineSymbol(symbols_math, main, rel, \"<\", \"\\\\lt\");\ndefineSymbol(symbols_math, main, rel, \"\\u2192\", \"\\\\rightarrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2192\", \"\\\\to\");\ndefineSymbol(symbols_math, ams, rel, \"\\u2271\", \"\\\\ngeq\", true);\ndefineSymbol(symbols_math, ams, rel, \"\\u2270\", \"\\\\nleq\", true);\ndefineSymbol(symbols_math, main, symbols_spacing, \"\\xA0\", \"\\\\ \");\ndefineSymbol(symbols_math, main, symbols_spacing, \"\\xA0\", \"~\");\ndefineSymbol(symbols_math, main, symbols_spacing, \"\\xA0\", \"\\\\space\"); // Ref: LaTeX Source 2e: \\DeclareRobustCommand{\\nobreakspace}{%\n\ndefineSymbol(symbols_math, main, symbols_spacing, \"\\xA0\", \"\\\\nobreakspace\");\ndefineSymbol(symbols_text, main, symbols_spacing, \"\\xA0\", \"\\\\ \");\ndefineSymbol(symbols_text, main, symbols_spacing, \"\\xA0\", \"~\");\ndefineSymbol(symbols_text, main, symbols_spacing, \"\\xA0\", \"\\\\space\");\ndefineSymbol(symbols_text, main, symbols_spacing, \"\\xA0\", \"\\\\nobreakspace\");\ndefineSymbol(symbols_math, main, symbols_spacing, null, \"\\\\nobreak\");\ndefineSymbol(symbols_math, main, symbols_spacing, null, \"\\\\allowbreak\");\ndefineSymbol(symbols_math, main, punct, \",\", \",\");\ndefineSymbol(symbols_math, main, punct, \";\", \";\");\ndefineSymbol(symbols_math, ams, bin, \"\\u22BC\", \"\\\\barwedge\", true);\ndefineSymbol(symbols_math, ams, bin, \"\\u22BB\", \"\\\\veebar\", true);\ndefineSymbol(symbols_math, main, bin, \"\\u2299\", \"\\\\odot\", true);\ndefineSymbol(symbols_math, main, bin, \"\\u2295\", \"\\\\oplus\", true);\ndefineSymbol(symbols_math, main, bin, \"\\u2297\", \"\\\\otimes\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u2202\", \"\\\\partial\", true);\ndefineSymbol(symbols_math, main, bin, \"\\u2298\", \"\\\\oslash\", true);\ndefineSymbol(symbols_math, ams, bin, \"\\u229A\", \"\\\\circledcirc\", true);\ndefineSymbol(symbols_math, ams, bin, \"\\u22A1\", \"\\\\boxdot\", true);\ndefineSymbol(symbols_math, main, bin, \"\\u25B3\", \"\\\\bigtriangleup\");\ndefineSymbol(symbols_math, main, bin, \"\\u25BD\", \"\\\\bigtriangledown\");\ndefineSymbol(symbols_math, main, bin, \"\\u2020\", \"\\\\dagger\");\ndefineSymbol(symbols_math, main, bin, \"\\u22C4\", \"\\\\diamond\");\ndefineSymbol(symbols_math, main, bin, \"\\u22C6\", \"\\\\star\");\ndefineSymbol(symbols_math, main, bin, \"\\u25C3\", \"\\\\triangleleft\");\ndefineSymbol(symbols_math, main, bin, \"\\u25B9\", \"\\\\triangleright\");\ndefineSymbol(symbols_math, main, symbols_open, \"{\", \"\\\\{\");\ndefineSymbol(symbols_text, main, symbols_textord, \"{\", \"\\\\{\");\ndefineSymbol(symbols_text, main, symbols_textord, \"{\", \"\\\\textbraceleft\");\ndefineSymbol(symbols_math, main, symbols_close, \"}\", \"\\\\}\");\ndefineSymbol(symbols_text, main, symbols_textord, \"}\", \"\\\\}\");\ndefineSymbol(symbols_text, main, symbols_textord, \"}\", \"\\\\textbraceright\");\ndefineSymbol(symbols_math, main, symbols_open, \"{\", \"\\\\lbrace\");\ndefineSymbol(symbols_math, main, symbols_close, \"}\", \"\\\\rbrace\");\ndefineSymbol(symbols_math, main, symbols_open, \"[\", \"\\\\lbrack\");\ndefineSymbol(symbols_text, main, symbols_textord, \"[\", \"\\\\lbrack\");\ndefineSymbol(symbols_math, main, symbols_close, \"]\", \"\\\\rbrack\");\ndefineSymbol(symbols_text, main, symbols_textord, \"]\", \"\\\\rbrack\");\ndefineSymbol(symbols_math, main, symbols_open, \"(\", \"\\\\lparen\");\ndefineSymbol(symbols_math, main, symbols_close, \")\", \"\\\\rparen\");\ndefineSymbol(symbols_text, main, symbols_textord, \"<\", \"\\\\textless\"); // in T1 fontenc\n\ndefineSymbol(symbols_text, main, symbols_textord, \">\", \"\\\\textgreater\"); // in T1 fontenc\n\ndefineSymbol(symbols_math, main, symbols_open, \"\\u230A\", \"\\\\lfloor\", true);\ndefineSymbol(symbols_math, main, symbols_close, \"\\u230B\", \"\\\\rfloor\", true);\ndefineSymbol(symbols_math, main, symbols_open, \"\\u2308\", \"\\\\lceil\", true);\ndefineSymbol(symbols_math, main, symbols_close, \"\\u2309\", \"\\\\rceil\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\\\\", \"\\\\backslash\");\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u2223\", \"|\");\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u2223\", \"\\\\vert\");\ndefineSymbol(symbols_text, main, symbols_textord, \"|\", \"\\\\textbar\"); // in T1 fontenc\n\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u2225\", \"\\\\|\");\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u2225\", \"\\\\Vert\");\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u2225\", \"\\\\textbardbl\");\ndefineSymbol(symbols_text, main, symbols_textord, \"~\", \"\\\\textasciitilde\");\ndefineSymbol(symbols_text, main, symbols_textord, \"\\\\\", \"\\\\textbackslash\");\ndefineSymbol(symbols_text, main, symbols_textord, \"^\", \"\\\\textasciicircum\");\ndefineSymbol(symbols_math, main, rel, \"\\u2191\", \"\\\\uparrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u21D1\", \"\\\\Uparrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2193\", \"\\\\downarrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u21D3\", \"\\\\Downarrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u2195\", \"\\\\updownarrow\", true);\ndefineSymbol(symbols_math, main, rel, \"\\u21D5\", \"\\\\Updownarrow\", true);\ndefineSymbol(symbols_math, main, op, \"\\u2210\", \"\\\\coprod\");\ndefineSymbol(symbols_math, main, op, \"\\u22C1\", \"\\\\bigvee\");\ndefineSymbol(symbols_math, main, op, \"\\u22C0\", \"\\\\bigwedge\");\ndefineSymbol(symbols_math, main, op, \"\\u2A04\", \"\\\\biguplus\");\ndefineSymbol(symbols_math, main, op, \"\\u22C2\", \"\\\\bigcap\");\ndefineSymbol(symbols_math, main, op, \"\\u22C3\", \"\\\\bigcup\");\ndefineSymbol(symbols_math, main, op, \"\\u222B\", \"\\\\int\");\ndefineSymbol(symbols_math, main, op, \"\\u222B\", \"\\\\intop\");\ndefineSymbol(symbols_math, main, op, \"\\u222C\", \"\\\\iint\");\ndefineSymbol(symbols_math, main, op, \"\\u222D\", \"\\\\iiint\");\ndefineSymbol(symbols_math, main, op, \"\\u220F\", \"\\\\prod\");\ndefineSymbol(symbols_math, main, op, \"\\u2211\", \"\\\\sum\");\ndefineSymbol(symbols_math, main, op, \"\\u2A02\", \"\\\\bigotimes\");\ndefineSymbol(symbols_math, main, op, \"\\u2A01\", \"\\\\bigoplus\");\ndefineSymbol(symbols_math, main, op, \"\\u2A00\", \"\\\\bigodot\");\ndefineSymbol(symbols_math, main, op, \"\\u222E\", \"\\\\oint\");\ndefineSymbol(symbols_math, main, op, \"\\u222F\", \"\\\\oiint\");\ndefineSymbol(symbols_math, main, op, \"\\u2230\", \"\\\\oiiint\");\ndefineSymbol(symbols_math, main, op, \"\\u2A06\", \"\\\\bigsqcup\");\ndefineSymbol(symbols_math, main, op, \"\\u222B\", \"\\\\smallint\");\ndefineSymbol(symbols_text, main, symbols_inner, \"\\u2026\", \"\\\\textellipsis\");\ndefineSymbol(symbols_math, main, symbols_inner, \"\\u2026\", \"\\\\mathellipsis\");\ndefineSymbol(symbols_text, main, symbols_inner, \"\\u2026\", \"\\\\ldots\", true);\ndefineSymbol(symbols_math, main, symbols_inner, \"\\u2026\", \"\\\\ldots\", true);\ndefineSymbol(symbols_math, main, symbols_inner, \"\\u22EF\", \"\\\\@cdots\", true);\ndefineSymbol(symbols_math, main, symbols_inner, \"\\u22F1\", \"\\\\ddots\", true);\ndefineSymbol(symbols_math, main, symbols_textord, \"\\u22EE\", \"\\\\varvdots\"); // \\vdots is a macro\n\ndefineSymbol(symbols_math, main, symbols_accent, \"\\u02CA\", \"\\\\acute\");\ndefineSymbol(symbols_math, main, symbols_accent, \"\\u02CB\", \"\\\\grave\");\ndefineSymbol(symbols_math, main, symbols_accent, \"\\xA8\", \"\\\\ddot\");\ndefineSymbol(symbols_math, main, symbols_accent, \"~\", \"\\\\tilde\");\ndefineSymbol(symbols_math, main, symbols_accent, \"\\u02C9\", \"\\\\bar\");\ndefineSymbol(symbols_math, main, symbols_accent, \"\\u02D8\", \"\\\\breve\");\ndefineSymbol(symbols_math, main, symbols_accent, \"\\u02C7\", \"\\\\check\");\ndefineSymbol(symbols_math, main, symbols_accent, \"^\", \"\\\\hat\");\ndefineSymbol(symbols_math, main, symbols_accent, \"\\u20D7\", \"\\\\vec\");\ndefineSymbol(symbols_math, main, symbols_accent, \"\\u02D9\", \"\\\\dot\");\ndefineSymbol(symbols_math, main, symbols_accent, \"\\u02DA\", \"\\\\mathring\");\ndefineSymbol(symbols_math, main, mathord, \"\\u0131\", \"\\\\imath\", true);\ndefineSymbol(symbols_math, main, mathord, \"\\u0237\", \"\\\\jmath\", true);\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u0131\", \"\\\\i\", true);\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u0237\", \"\\\\j\", true);\ndefineSymbol(symbols_text, main, symbols_textord, \"\\xDF\", \"\\\\ss\", true);\ndefineSymbol(symbols_text, main, symbols_textord, \"\\xE6\", \"\\\\ae\", true);\ndefineSymbol(symbols_text, main, symbols_textord, \"\\xE6\", \"\\\\ae\", true);\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u0153\", \"\\\\oe\", true);\ndefineSymbol(symbols_text, main, symbols_textord, \"\\xF8\", \"\\\\o\", true);\ndefineSymbol(symbols_text, main, symbols_textord, \"\\xC6\", \"\\\\AE\", true);\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u0152\", \"\\\\OE\", true);\ndefineSymbol(symbols_text, main, symbols_textord, \"\\xD8\", \"\\\\O\", true);\ndefineSymbol(symbols_text, main, symbols_accent, \"\\u02CA\", \"\\\\'\"); // acute\n\ndefineSymbol(symbols_text, main, symbols_accent, \"\\u02CB\", \"\\\\`\"); // grave\n\ndefineSymbol(symbols_text, main, symbols_accent, \"\\u02C6\", \"\\\\^\"); // circumflex\n\ndefineSymbol(symbols_text, main, symbols_accent, \"\\u02DC\", \"\\\\~\"); // tilde\n\ndefineSymbol(symbols_text, main, symbols_accent, \"\\u02C9\", \"\\\\=\"); // macron\n\ndefineSymbol(symbols_text, main, symbols_accent, \"\\u02D8\", \"\\\\u\"); // breve\n\ndefineSymbol(symbols_text, main, symbols_accent, \"\\u02D9\", \"\\\\.\"); // dot above\n\ndefineSymbol(symbols_text, main, symbols_accent, \"\\u02DA\", \"\\\\r\"); // ring above\n\ndefineSymbol(symbols_text, main, symbols_accent, \"\\u02C7\", \"\\\\v\"); // caron\n\ndefineSymbol(symbols_text, main, symbols_accent, \"\\xA8\", '\\\\\"'); // diaresis\n\ndefineSymbol(symbols_text, main, symbols_accent, \"\\u02DD\", \"\\\\H\"); // double acute\n\ndefineSymbol(symbols_text, main, symbols_accent, \"\\u25EF\", \"\\\\textcircled\"); // \\bigcirc glyph\n// These ligatures are detected and created in Parser.js's `formLigatures`.\n\nvar ligatures = {\n  \"--\": true,\n  \"---\": true,\n  \"``\": true,\n  \"''\": true\n};\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u2013\", \"--\");\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u2013\", \"\\\\textendash\");\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u2014\", \"---\");\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u2014\", \"\\\\textemdash\");\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u2018\", \"`\");\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u2018\", \"\\\\textquoteleft\");\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u2019\", \"'\");\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u2019\", \"\\\\textquoteright\");\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u201C\", \"``\");\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u201C\", \"\\\\textquotedblleft\");\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u201D\", \"''\");\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u201D\", \"\\\\textquotedblright\"); //  \\degree from gensymb package\n\ndefineSymbol(symbols_math, main, symbols_textord, \"\\xB0\", \"\\\\degree\", true);\ndefineSymbol(symbols_text, main, symbols_textord, \"\\xB0\", \"\\\\degree\"); // \\textdegree from inputenc package\n\ndefineSymbol(symbols_text, main, symbols_textord, \"\\xB0\", \"\\\\textdegree\", true); // TODO: In LaTeX, \\pounds can generate a different character in text and math\n// mode, but among our fonts, only Main-Italic defines this character \"163\".\n\ndefineSymbol(symbols_math, main, mathord, \"\\xA3\", \"\\\\pounds\");\ndefineSymbol(symbols_math, main, mathord, \"\\xA3\", \"\\\\mathsterling\", true);\ndefineSymbol(symbols_text, main, mathord, \"\\xA3\", \"\\\\pounds\");\ndefineSymbol(symbols_text, main, mathord, \"\\xA3\", \"\\\\textsterling\", true);\ndefineSymbol(symbols_math, ams, symbols_textord, \"\\u2720\", \"\\\\maltese\");\ndefineSymbol(symbols_text, ams, symbols_textord, \"\\u2720\", \"\\\\maltese\");\ndefineSymbol(symbols_text, main, symbols_spacing, \"\\xA0\", \"\\\\ \");\ndefineSymbol(symbols_text, main, symbols_spacing, \"\\xA0\", \" \");\ndefineSymbol(symbols_text, main, symbols_spacing, \"\\xA0\", \"~\"); // There are lots of symbols which are the same, so we add them in afterwards.\n// All of these are textords in math mode\n\nvar mathTextSymbols = \"0123456789/@.\\\"\";\n\nfor (var symbols_i = 0; symbols_i < mathTextSymbols.length; symbols_i++) {\n  var symbols_ch = mathTextSymbols.charAt(symbols_i);\n  defineSymbol(symbols_math, main, symbols_textord, symbols_ch, symbols_ch);\n} // All of these are textords in text mode\n\n\nvar textSymbols = \"0123456789!@*()-=+[]<>|\\\";:?/.,\";\n\nfor (var src_symbols_i = 0; src_symbols_i < textSymbols.length; src_symbols_i++) {\n  var _ch = textSymbols.charAt(src_symbols_i);\n\n  defineSymbol(symbols_text, main, symbols_textord, _ch, _ch);\n} // All of these are textords in text mode, and mathords in math mode\n\n\nvar letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\nfor (var symbols_i2 = 0; symbols_i2 < letters.length; symbols_i2++) {\n  var _ch2 = letters.charAt(symbols_i2);\n\n  defineSymbol(symbols_math, main, mathord, _ch2, _ch2);\n  defineSymbol(symbols_text, main, symbols_textord, _ch2, _ch2);\n} // Blackboard bold and script letters in Unicode range\n\n\ndefineSymbol(symbols_math, ams, symbols_textord, \"C\", \"\\u2102\"); // blackboard bold\n\ndefineSymbol(symbols_text, ams, symbols_textord, \"C\", \"\\u2102\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"H\", \"\\u210D\");\ndefineSymbol(symbols_text, ams, symbols_textord, \"H\", \"\\u210D\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"N\", \"\\u2115\");\ndefineSymbol(symbols_text, ams, symbols_textord, \"N\", \"\\u2115\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"P\", \"\\u2119\");\ndefineSymbol(symbols_text, ams, symbols_textord, \"P\", \"\\u2119\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"Q\", \"\\u211A\");\ndefineSymbol(symbols_text, ams, symbols_textord, \"Q\", \"\\u211A\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"R\", \"\\u211D\");\ndefineSymbol(symbols_text, ams, symbols_textord, \"R\", \"\\u211D\");\ndefineSymbol(symbols_math, ams, symbols_textord, \"Z\", \"\\u2124\");\ndefineSymbol(symbols_text, ams, symbols_textord, \"Z\", \"\\u2124\");\ndefineSymbol(symbols_math, main, mathord, \"h\", \"\\u210E\"); // italic h, Planck constant\n\ndefineSymbol(symbols_text, main, mathord, \"h\", \"\\u210E\"); // The next loop loads wide (surrogate pair) characters.\n// We support some letters in the Unicode range U+1D400 to U+1D7FF,\n// Mathematical Alphanumeric Symbols.\n// Some editors do not deal well with wide characters. So don't write the\n// string into this file. Instead, create the string from the surrogate pair.\n\nvar symbols_wideChar = \"\";\n\nfor (var symbols_i3 = 0; symbols_i3 < letters.length; symbols_i3++) {\n  var _ch3 = letters.charAt(symbols_i3); // The hex numbers in the next line are a surrogate pair.\n  // 0xD835 is the high surrogate for all letters in the range we support.\n  // 0xDC00 is the low surrogate for bold A.\n\n\n  symbols_wideChar = String.fromCharCode(0xD835, 0xDC00 + symbols_i3); // A-Z a-z bold\n\n  defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);\n  defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);\n  symbols_wideChar = String.fromCharCode(0xD835, 0xDC34 + symbols_i3); // A-Z a-z italic\n\n  defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);\n  defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);\n  symbols_wideChar = String.fromCharCode(0xD835, 0xDC68 + symbols_i3); // A-Z a-z bold italic\n\n  defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);\n  defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);\n  symbols_wideChar = String.fromCharCode(0xD835, 0xDD04 + symbols_i3); // A-Z a-z Fractur\n\n  defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);\n  defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);\n  symbols_wideChar = String.fromCharCode(0xD835, 0xDDA0 + symbols_i3); // A-Z a-z sans-serif\n\n  defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);\n  defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);\n  symbols_wideChar = String.fromCharCode(0xD835, 0xDDD4 + symbols_i3); // A-Z a-z sans bold\n\n  defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);\n  defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);\n  symbols_wideChar = String.fromCharCode(0xD835, 0xDE08 + symbols_i3); // A-Z a-z sans italic\n\n  defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);\n  defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);\n  symbols_wideChar = String.fromCharCode(0xD835, 0xDE70 + symbols_i3); // A-Z a-z monospace\n\n  defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);\n  defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);\n\n  if (symbols_i3 < 26) {\n    // KaTeX fonts have only capital letters for blackboard bold and script.\n    // See exception for k below.\n    symbols_wideChar = String.fromCharCode(0xD835, 0xDD38 + symbols_i3); // A-Z double struck\n\n    defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);\n    defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);\n    symbols_wideChar = String.fromCharCode(0xD835, 0xDC9C + symbols_i3); // A-Z script\n\n    defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);\n    defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);\n  } // TODO: Add bold script when it is supported by a KaTeX font.\n\n} // \"k\" is the only double struck lower case letter in the KaTeX fonts.\n\n\nsymbols_wideChar = String.fromCharCode(0xD835, 0xDD5C); // k double struck\n\ndefineSymbol(symbols_math, main, mathord, \"k\", symbols_wideChar);\ndefineSymbol(symbols_text, main, symbols_textord, \"k\", symbols_wideChar); // Next, some wide character numerals\n\nfor (var symbols_i4 = 0; symbols_i4 < 10; symbols_i4++) {\n  var _ch4 = symbols_i4.toString();\n\n  symbols_wideChar = String.fromCharCode(0xD835, 0xDFCE + symbols_i4); // 0-9 bold\n\n  defineSymbol(symbols_math, main, mathord, _ch4, symbols_wideChar);\n  defineSymbol(symbols_text, main, symbols_textord, _ch4, symbols_wideChar);\n  symbols_wideChar = String.fromCharCode(0xD835, 0xDFE2 + symbols_i4); // 0-9 sans serif\n\n  defineSymbol(symbols_math, main, mathord, _ch4, symbols_wideChar);\n  defineSymbol(symbols_text, main, symbols_textord, _ch4, symbols_wideChar);\n  symbols_wideChar = String.fromCharCode(0xD835, 0xDFEC + symbols_i4); // 0-9 bold sans\n\n  defineSymbol(symbols_math, main, mathord, _ch4, symbols_wideChar);\n  defineSymbol(symbols_text, main, symbols_textord, _ch4, symbols_wideChar);\n  symbols_wideChar = String.fromCharCode(0xD835, 0xDFF6 + symbols_i4); // 0-9 monospace\n\n  defineSymbol(symbols_math, main, mathord, _ch4, symbols_wideChar);\n  defineSymbol(symbols_text, main, symbols_textord, _ch4, symbols_wideChar);\n} // We add these Latin-1 letters as symbols for backwards-compatibility,\n// but they are not actually in the font, nor are they supported by the\n// Unicode accent mechanism, so they fall back to Times font and look ugly.\n// TODO(edemaine): Fix this.\n\n\nvar extraLatin = \"ÇÐÞçþ\";\n\nfor (var _i5 = 0; _i5 < extraLatin.length; _i5++) {\n  var _ch5 = extraLatin.charAt(_i5);\n\n  defineSymbol(symbols_math, main, mathord, _ch5, _ch5);\n  defineSymbol(symbols_text, main, symbols_textord, _ch5, _ch5);\n}\n\ndefineSymbol(symbols_text, main, symbols_textord, \"ð\", \"ð\"); // Unicode versions of existing characters\n\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u2013\", \"–\");\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u2014\", \"—\");\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u2018\", \"‘\");\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u2019\", \"’\");\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u201C\", \"“\");\ndefineSymbol(symbols_text, main, symbols_textord, \"\\u201D\", \"”\");\n// CONCATENATED MODULE: ./src/wide-character.js\n/**\n * This file provides support for Unicode range U+1D400 to U+1D7FF,\n * Mathematical Alphanumeric Symbols.\n *\n * Function wideCharacterFont takes a wide character as input and returns\n * the font information necessary to render it properly.\n */\n\n/**\n * Data below is from https://www.unicode.org/charts/PDF/U1D400.pdf\n * That document sorts characters into groups by font type, say bold or italic.\n *\n * In the arrays below, each subarray consists three elements:\n *      * The CSS class of that group when in math mode.\n *      * The CSS class of that group when in text mode.\n *      * The font name, so that KaTeX can get font metrics.\n */\n\nvar wideLatinLetterData = [[\"mathbf\", \"textbf\", \"Main-Bold\"], // A-Z bold upright\n[\"mathbf\", \"textbf\", \"Main-Bold\"], // a-z bold upright\n[\"mathdefault\", \"textit\", \"Math-Italic\"], // A-Z italic\n[\"mathdefault\", \"textit\", \"Math-Italic\"], // a-z italic\n[\"boldsymbol\", \"boldsymbol\", \"Main-BoldItalic\"], // A-Z bold italic\n[\"boldsymbol\", \"boldsymbol\", \"Main-BoldItalic\"], // a-z bold italic\n// Map fancy A-Z letters to script, not calligraphic.\n// This aligns with unicode-math and math fonts (except Cambria Math).\n[\"mathscr\", \"textscr\", \"Script-Regular\"], // A-Z script\n[\"\", \"\", \"\"], // a-z script.  No font\n[\"\", \"\", \"\"], // A-Z bold script. No font\n[\"\", \"\", \"\"], // a-z bold script. No font\n[\"mathfrak\", \"textfrak\", \"Fraktur-Regular\"], // A-Z Fraktur\n[\"mathfrak\", \"textfrak\", \"Fraktur-Regular\"], // a-z Fraktur\n[\"mathbb\", \"textbb\", \"AMS-Regular\"], // A-Z double-struck\n[\"mathbb\", \"textbb\", \"AMS-Regular\"], // k double-struck\n[\"\", \"\", \"\"], // A-Z bold Fraktur No font metrics\n[\"\", \"\", \"\"], // a-z bold Fraktur.   No font.\n[\"mathsf\", \"textsf\", \"SansSerif-Regular\"], // A-Z sans-serif\n[\"mathsf\", \"textsf\", \"SansSerif-Regular\"], // a-z sans-serif\n[\"mathboldsf\", \"textboldsf\", \"SansSerif-Bold\"], // A-Z bold sans-serif\n[\"mathboldsf\", \"textboldsf\", \"SansSerif-Bold\"], // a-z bold sans-serif\n[\"mathitsf\", \"textitsf\", \"SansSerif-Italic\"], // A-Z italic sans-serif\n[\"mathitsf\", \"textitsf\", \"SansSerif-Italic\"], // a-z italic sans-serif\n[\"\", \"\", \"\"], // A-Z bold italic sans. No font\n[\"\", \"\", \"\"], // a-z bold italic sans. No font\n[\"mathtt\", \"texttt\", \"Typewriter-Regular\"], // A-Z monospace\n[\"mathtt\", \"texttt\", \"Typewriter-Regular\"]];\nvar wideNumeralData = [[\"mathbf\", \"textbf\", \"Main-Bold\"], // 0-9 bold\n[\"\", \"\", \"\"], // 0-9 double-struck. No KaTeX font.\n[\"mathsf\", \"textsf\", \"SansSerif-Regular\"], // 0-9 sans-serif\n[\"mathboldsf\", \"textboldsf\", \"SansSerif-Bold\"], // 0-9 bold sans-serif\n[\"mathtt\", \"texttt\", \"Typewriter-Regular\"]];\nvar wide_character_wideCharacterFont = function wideCharacterFont(wideChar, mode) {\n  // IE doesn't support codePointAt(). So work with the surrogate pair.\n  var H = wideChar.charCodeAt(0); // high surrogate\n\n  var L = wideChar.charCodeAt(1); // low surrogate\n\n  var codePoint = (H - 0xD800) * 0x400 + (L - 0xDC00) + 0x10000;\n  var j = mode === \"math\" ? 0 : 1; // column index for CSS class.\n\n  if (0x1D400 <= codePoint && codePoint < 0x1D6A4) {\n    // wideLatinLetterData contains exactly 26 chars on each row.\n    // So we can calculate the relevant row. No traverse necessary.\n    var i = Math.floor((codePoint - 0x1D400) / 26);\n    return [wideLatinLetterData[i][2], wideLatinLetterData[i][j]];\n  } else if (0x1D7CE <= codePoint && codePoint <= 0x1D7FF) {\n    // Numerals, ten per row.\n    var _i = Math.floor((codePoint - 0x1D7CE) / 10);\n\n    return [wideNumeralData[_i][2], wideNumeralData[_i][j]];\n  } else if (codePoint === 0x1D6A5 || codePoint === 0x1D6A6) {\n    // dotless i or j\n    return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];\n  } else if (0x1D6A6 < codePoint && codePoint < 0x1D7CE) {\n    // Greek letters. Not supported, yet.\n    return [\"\", \"\"];\n  } else {\n    // We don't support any wide characters outside 1D400–1D7FF.\n    throw new src_ParseError(\"Unsupported character: \" + wideChar);\n  }\n};\n// CONCATENATED MODULE: ./src/Options.js\n/**\n * This file contains information about the options that the Parser carries\n * around with it while parsing. Data is held in an `Options` object, and when\n * recursing, a new `Options` object can be created with the `.with*` and\n * `.reset` functions.\n */\n\nvar sizeStyleMap = [// Each element contains [textsize, scriptsize, scriptscriptsize].\n// The size mappings are taken from TeX with \\normalsize=10pt.\n[1, 1, 1], // size1: [5, 5, 5]              \\tiny\n[2, 1, 1], // size2: [6, 5, 5]\n[3, 1, 1], // size3: [7, 5, 5]              \\scriptsize\n[4, 2, 1], // size4: [8, 6, 5]              \\footnotesize\n[5, 2, 1], // size5: [9, 6, 5]              \\small\n[6, 3, 1], // size6: [10, 7, 5]             \\normalsize\n[7, 4, 2], // size7: [12, 8, 6]             \\large\n[8, 6, 3], // size8: [14.4, 10, 7]          \\Large\n[9, 7, 6], // size9: [17.28, 12, 10]        \\LARGE\n[10, 8, 7], // size10: [20.74, 14.4, 12]     \\huge\n[11, 10, 9]];\nvar sizeMultipliers = [// fontMetrics.js:getGlobalMetrics also uses size indexes, so if\n// you change size indexes, change that function.\n0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.2, 1.44, 1.728, 2.074, 2.488];\n\nvar sizeAtStyle = function sizeAtStyle(size, style) {\n  return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];\n}; // In these types, \"\" (empty string) means \"no change\".\n\n\n/**\n * This is the main options class. It contains the current style, size, color,\n * and font.\n *\n * Options objects should not be modified. To create a new Options with\n * different properties, call a `.having*` method.\n */\nvar Options_Options =\n/*#__PURE__*/\nfunction () {\n  // A font family applies to a group of fonts (i.e. SansSerif), while a font\n  // represents a specific font (i.e. SansSerif Bold).\n  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm\n\n  /**\n   * The base size index.\n   */\n  function Options(data) {\n    this.style = void 0;\n    this.color = void 0;\n    this.size = void 0;\n    this.textSize = void 0;\n    this.phantom = void 0;\n    this.font = void 0;\n    this.fontFamily = void 0;\n    this.fontWeight = void 0;\n    this.fontShape = void 0;\n    this.sizeMultiplier = void 0;\n    this.maxSize = void 0;\n    this.minRuleThickness = void 0;\n    this._fontMetrics = void 0;\n    this.style = data.style;\n    this.color = data.color;\n    this.size = data.size || Options.BASESIZE;\n    this.textSize = data.textSize || this.size;\n    this.phantom = !!data.phantom;\n    this.font = data.font || \"\";\n    this.fontFamily = data.fontFamily || \"\";\n    this.fontWeight = data.fontWeight || '';\n    this.fontShape = data.fontShape || '';\n    this.sizeMultiplier = sizeMultipliers[this.size - 1];\n    this.maxSize = data.maxSize;\n    this.minRuleThickness = data.minRuleThickness;\n    this._fontMetrics = undefined;\n  }\n  /**\n   * Returns a new options object with the same properties as \"this\".  Properties\n   * from \"extension\" will be copied to the new options object.\n   */\n\n\n  var _proto = Options.prototype;\n\n  _proto.extend = function extend(extension) {\n    var data = {\n      style: this.style,\n      size: this.size,\n      textSize: this.textSize,\n      color: this.color,\n      phantom: this.phantom,\n      font: this.font,\n      fontFamily: this.fontFamily,\n      fontWeight: this.fontWeight,\n      fontShape: this.fontShape,\n      maxSize: this.maxSize,\n      minRuleThickness: this.minRuleThickness\n    };\n\n    for (var key in extension) {\n      if (extension.hasOwnProperty(key)) {\n        data[key] = extension[key];\n      }\n    }\n\n    return new Options(data);\n  }\n  /**\n   * Return an options object with the given style. If `this.style === style`,\n   * returns `this`.\n   */\n  ;\n\n  _proto.havingStyle = function havingStyle(style) {\n    if (this.style === style) {\n      return this;\n    } else {\n      return this.extend({\n        style: style,\n        size: sizeAtStyle(this.textSize, style)\n      });\n    }\n  }\n  /**\n   * Return an options object with a cramped version of the current style. If\n   * the current style is cramped, returns `this`.\n   */\n  ;\n\n  _proto.havingCrampedStyle = function havingCrampedStyle() {\n    return this.havingStyle(this.style.cramp());\n  }\n  /**\n   * Return an options object with the given size and in at least `\\textstyle`.\n   * Returns `this` if appropriate.\n   */\n  ;\n\n  _proto.havingSize = function havingSize(size) {\n    if (this.size === size && this.textSize === size) {\n      return this;\n    } else {\n      return this.extend({\n        style: this.style.text(),\n        size: size,\n        textSize: size,\n        sizeMultiplier: sizeMultipliers[size - 1]\n      });\n    }\n  }\n  /**\n   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,\n   * changes to at least `\\textstyle`.\n   */\n  ;\n\n  _proto.havingBaseStyle = function havingBaseStyle(style) {\n    style = style || this.style.text();\n    var wantSize = sizeAtStyle(Options.BASESIZE, style);\n\n    if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {\n      return this;\n    } else {\n      return this.extend({\n        style: style,\n        size: wantSize\n      });\n    }\n  }\n  /**\n   * Remove the effect of sizing changes such as \\Huge.\n   * Keep the effect of the current style, such as \\scriptstyle.\n   */\n  ;\n\n  _proto.havingBaseSizing = function havingBaseSizing() {\n    var size;\n\n    switch (this.style.id) {\n      case 4:\n      case 5:\n        size = 3; // normalsize in scriptstyle\n\n        break;\n\n      case 6:\n      case 7:\n        size = 1; // normalsize in scriptscriptstyle\n\n        break;\n\n      default:\n        size = 6;\n      // normalsize in textstyle or displaystyle\n    }\n\n    return this.extend({\n      style: this.style.text(),\n      size: size\n    });\n  }\n  /**\n   * Create a new options object with the given color.\n   */\n  ;\n\n  _proto.withColor = function withColor(color) {\n    return this.extend({\n      color: color\n    });\n  }\n  /**\n   * Create a new options object with \"phantom\" set to true.\n   */\n  ;\n\n  _proto.withPhantom = function withPhantom() {\n    return this.extend({\n      phantom: true\n    });\n  }\n  /**\n   * Creates a new options object with the given math font or old text font.\n   * @type {[type]}\n   */\n  ;\n\n  _proto.withFont = function withFont(font) {\n    return this.extend({\n      font: font\n    });\n  }\n  /**\n   * Create a new options objects with the given fontFamily.\n   */\n  ;\n\n  _proto.withTextFontFamily = function withTextFontFamily(fontFamily) {\n    return this.extend({\n      fontFamily: fontFamily,\n      font: \"\"\n    });\n  }\n  /**\n   * Creates a new options object with the given font weight\n   */\n  ;\n\n  _proto.withTextFontWeight = function withTextFontWeight(fontWeight) {\n    return this.extend({\n      fontWeight: fontWeight,\n      font: \"\"\n    });\n  }\n  /**\n   * Creates a new options object with the given font weight\n   */\n  ;\n\n  _proto.withTextFontShape = function withTextFontShape(fontShape) {\n    return this.extend({\n      fontShape: fontShape,\n      font: \"\"\n    });\n  }\n  /**\n   * Return the CSS sizing classes required to switch from enclosing options\n   * `oldOptions` to `this`. Returns an array of classes.\n   */\n  ;\n\n  _proto.sizingClasses = function sizingClasses(oldOptions) {\n    if (oldOptions.size !== this.size) {\n      return [\"sizing\", \"reset-size\" + oldOptions.size, \"size\" + this.size];\n    } else {\n      return [];\n    }\n  }\n  /**\n   * Return the CSS sizing classes required to switch to the base size. Like\n   * `this.havingSize(BASESIZE).sizingClasses(this)`.\n   */\n  ;\n\n  _proto.baseSizingClasses = function baseSizingClasses() {\n    if (this.size !== Options.BASESIZE) {\n      return [\"sizing\", \"reset-size\" + this.size, \"size\" + Options.BASESIZE];\n    } else {\n      return [];\n    }\n  }\n  /**\n   * Return the font metrics for this size.\n   */\n  ;\n\n  _proto.fontMetrics = function fontMetrics() {\n    if (!this._fontMetrics) {\n      this._fontMetrics = getGlobalMetrics(this.size);\n    }\n\n    return this._fontMetrics;\n  }\n  /**\n   * Gets the CSS color of the current options object\n   */\n  ;\n\n  _proto.getColor = function getColor() {\n    if (this.phantom) {\n      return \"transparent\";\n    } else {\n      return this.color;\n    }\n  };\n\n  return Options;\n}();\n\nOptions_Options.BASESIZE = 6;\n/* harmony default export */ var src_Options = (Options_Options);\n// CONCATENATED MODULE: ./src/units.js\n/**\n * This file does conversion between units.  In particular, it provides\n * calculateSize to convert other units into ems.\n */\n\n // This table gives the number of TeX pts in one of each *absolute* TeX unit.\n// Thus, multiplying a length by this number converts the length from units\n// into pts.  Dividing the result by ptPerEm gives the number of ems\n// *assuming* a font size of ptPerEm (normal size, normal style).\n\nvar ptPerUnit = {\n  // https://en.wikibooks.org/wiki/LaTeX/Lengths and\n  // https://tex.stackexchange.com/a/8263\n  \"pt\": 1,\n  // TeX point\n  \"mm\": 7227 / 2540,\n  // millimeter\n  \"cm\": 7227 / 254,\n  // centimeter\n  \"in\": 72.27,\n  // inch\n  \"bp\": 803 / 800,\n  // big (PostScript) points\n  \"pc\": 12,\n  // pica\n  \"dd\": 1238 / 1157,\n  // didot\n  \"cc\": 14856 / 1157,\n  // cicero (12 didot)\n  \"nd\": 685 / 642,\n  // new didot\n  \"nc\": 1370 / 107,\n  // new cicero (12 new didot)\n  \"sp\": 1 / 65536,\n  // scaled point (TeX's internal smallest unit)\n  // https://tex.stackexchange.com/a/41371\n  \"px\": 803 / 800 // \\pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX\n\n}; // Dictionary of relative units, for fast validity testing.\n\nvar relativeUnit = {\n  \"ex\": true,\n  \"em\": true,\n  \"mu\": true\n};\n\n/**\n * Determine whether the specified unit (either a string defining the unit\n * or a \"size\" parse node containing a unit field) is valid.\n */\nvar validUnit = function validUnit(unit) {\n  if (typeof unit !== \"string\") {\n    unit = unit.unit;\n  }\n\n  return unit in ptPerUnit || unit in relativeUnit || unit === \"ex\";\n};\n/*\n * Convert a \"size\" parse node (with numeric \"number\" and string \"unit\" fields,\n * as parsed by functions.js argType \"size\") into a CSS em value for the\n * current style/scale.  `options` gives the current options.\n */\n\nvar units_calculateSize = function calculateSize(sizeValue, options) {\n  var scale;\n\n  if (sizeValue.unit in ptPerUnit) {\n    // Absolute units\n    scale = ptPerUnit[sizeValue.unit] // Convert unit to pt\n    / options.fontMetrics().ptPerEm // Convert pt to CSS em\n    / options.sizeMultiplier; // Unscale to make absolute units\n  } else if (sizeValue.unit === \"mu\") {\n    // `mu` units scale with scriptstyle/scriptscriptstyle.\n    scale = options.fontMetrics().cssEmPerMu;\n  } else {\n    // Other relative units always refer to the *textstyle* font\n    // in the current size.\n    var unitOptions;\n\n    if (options.style.isTight()) {\n      // isTight() means current style is script/scriptscript.\n      unitOptions = options.havingStyle(options.style.text());\n    } else {\n      unitOptions = options;\n    } // TODO: In TeX these units are relative to the quad of the current\n    // *text* font, e.g. cmr10. KaTeX instead uses values from the\n    // comparably-sized *Computer Modern symbol* font. At 10pt, these\n    // match. At 7pt and 5pt, they differ: cmr7=1.138894, cmsy7=1.170641;\n    // cmr5=1.361133, cmsy5=1.472241. Consider $\\scriptsize a\\kern1emb$.\n    // TeX \\showlists shows a kern of 1.13889 * fontsize;\n    // KaTeX shows a kern of 1.171 * fontsize.\n\n\n    if (sizeValue.unit === \"ex\") {\n      scale = unitOptions.fontMetrics().xHeight;\n    } else if (sizeValue.unit === \"em\") {\n      scale = unitOptions.fontMetrics().quad;\n    } else {\n      throw new src_ParseError(\"Invalid unit: '\" + sizeValue.unit + \"'\");\n    }\n\n    if (unitOptions !== options) {\n      scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;\n    }\n  }\n\n  return Math.min(sizeValue.number * scale, options.maxSize);\n};\n// CONCATENATED MODULE: ./src/buildCommon.js\n/* eslint no-console:0 */\n\n/**\n * This module contains general functions that can be used for building\n * different kinds of domTree nodes in a consistent manner.\n */\n\n\n\n\n\n\n\n// The following have to be loaded from Main-Italic font, using class mathit\nvar mathitLetters = [\"\\\\imath\", \"ı\", // dotless i\n\"\\\\jmath\", \"ȷ\", // dotless j\n\"\\\\pounds\", \"\\\\mathsterling\", \"\\\\textsterling\", \"£\"];\n/**\n * Looks up the given symbol in fontMetrics, after applying any symbol\n * replacements defined in symbol.js\n */\n\nvar buildCommon_lookupSymbol = function lookupSymbol(value, // TODO(#963): Use a union type for this.\nfontName, mode) {\n  // Replace the value with its replaced value from symbol.js\n  if (src_symbols[mode][value] && src_symbols[mode][value].replace) {\n    value = src_symbols[mode][value].replace;\n  }\n\n  return {\n    value: value,\n    metrics: getCharacterMetrics(value, fontName, mode)\n  };\n};\n/**\n * Makes a symbolNode after translation via the list of symbols in symbols.js.\n * Correctly pulls out metrics for the character, and optionally takes a list of\n * classes to be attached to the node.\n *\n * TODO: make argument order closer to makeSpan\n * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which\n * should if present come first in `classes`.\n * TODO(#953): Make `options` mandatory and always pass it in.\n */\n\n\nvar buildCommon_makeSymbol = function makeSymbol(value, fontName, mode, options, classes) {\n  var lookup = buildCommon_lookupSymbol(value, fontName, mode);\n  var metrics = lookup.metrics;\n  value = lookup.value;\n  var symbolNode;\n\n  if (metrics) {\n    var italic = metrics.italic;\n\n    if (mode === \"text\" || options && options.font === \"mathit\") {\n      italic = 0;\n    }\n\n    symbolNode = new domTree_SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);\n  } else {\n    // TODO(emily): Figure out a good way to only print this in development\n    typeof console !== \"undefined\" && console.warn(\"No character metrics \" + (\"for '\" + value + \"' in style '\" + fontName + \"' and mode '\" + mode + \"'\"));\n    symbolNode = new domTree_SymbolNode(value, 0, 0, 0, 0, 0, classes);\n  }\n\n  if (options) {\n    symbolNode.maxFontSize = options.sizeMultiplier;\n\n    if (options.style.isTight()) {\n      symbolNode.classes.push(\"mtight\");\n    }\n\n    var color = options.getColor();\n\n    if (color) {\n      symbolNode.style.color = color;\n    }\n  }\n\n  return symbolNode;\n};\n/**\n * Makes a symbol in Main-Regular or AMS-Regular.\n * Used for rel, bin, open, close, inner, and punct.\n */\n\n\nvar buildCommon_mathsym = function mathsym(value, mode, options, classes) {\n  if (classes === void 0) {\n    classes = [];\n  }\n\n  // Decide what font to render the symbol in by its entry in the symbols\n  // table.\n  // Have a special case for when the value = \\ because the \\ is used as a\n  // textord in unsupported command errors but cannot be parsed as a regular\n  // text ordinal and is therefore not present as a symbol in the symbols\n  // table for text, as well as a special case for boldsymbol because it\n  // can be used for bold + and -\n  if (options.font === \"boldsymbol\" && buildCommon_lookupSymbol(value, \"Main-Bold\", mode).metrics) {\n    return buildCommon_makeSymbol(value, \"Main-Bold\", mode, options, classes.concat([\"mathbf\"]));\n  } else if (value === \"\\\\\" || src_symbols[mode][value].font === \"main\") {\n    return buildCommon_makeSymbol(value, \"Main-Regular\", mode, options, classes);\n  } else {\n    return buildCommon_makeSymbol(value, \"AMS-Regular\", mode, options, classes.concat([\"amsrm\"]));\n  }\n};\n/**\n * Determines which of the two font names (Main-Italic and Math-Italic) and\n * corresponding style tags (maindefault or mathit) to use for default math font,\n * depending on the symbol.\n */\n\n\nvar buildCommon_mathdefault = function mathdefault(value, mode, options, classes) {\n  if (/[0-9]/.test(value.charAt(0)) || // glyphs for \\imath and \\jmath do not exist in Math-Italic so we\n  // need to use Main-Italic instead\n  utils.contains(mathitLetters, value)) {\n    return {\n      fontName: \"Main-Italic\",\n      fontClass: \"mathit\"\n    };\n  } else {\n    return {\n      fontName: \"Math-Italic\",\n      fontClass: \"mathdefault\"\n    };\n  }\n};\n/**\n * Determines which of the font names (Main-Italic, Math-Italic, and Caligraphic)\n * and corresponding style tags (mathit, mathdefault, or mathcal) to use for font\n * \"mathnormal\", depending on the symbol.  Use this function instead of fontMap for\n * font \"mathnormal\".\n */\n\n\nvar buildCommon_mathnormal = function mathnormal(value, mode, options, classes) {\n  if (utils.contains(mathitLetters, value)) {\n    return {\n      fontName: \"Main-Italic\",\n      fontClass: \"mathit\"\n    };\n  } else if (/[0-9]/.test(value.charAt(0))) {\n    return {\n      fontName: \"Caligraphic-Regular\",\n      fontClass: \"mathcal\"\n    };\n  } else {\n    return {\n      fontName: \"Math-Italic\",\n      fontClass: \"mathdefault\"\n    };\n  }\n};\n/**\n * Determines which of the two font names (Main-Bold and Math-BoldItalic) and\n * corresponding style tags (mathbf or boldsymbol) to use for font \"boldsymbol\",\n * depending on the symbol.  Use this function instead of fontMap for font\n * \"boldsymbol\".\n */\n\n\nvar boldsymbol = function boldsymbol(value, mode, options, classes) {\n  if (buildCommon_lookupSymbol(value, \"Math-BoldItalic\", mode).metrics) {\n    return {\n      fontName: \"Math-BoldItalic\",\n      fontClass: \"boldsymbol\"\n    };\n  } else {\n    // Some glyphs do not exist in Math-BoldItalic so we need to use\n    // Main-Bold instead.\n    return {\n      fontName: \"Main-Bold\",\n      fontClass: \"mathbf\"\n    };\n  }\n};\n/**\n * Makes either a mathord or textord in the correct font and color.\n */\n\n\nvar buildCommon_makeOrd = function makeOrd(group, options, type) {\n  var mode = group.mode;\n  var text = group.text;\n  var classes = [\"mord\"]; // Math mode or Old font (i.e. \\rm)\n\n  var isFont = mode === \"math\" || mode === \"text\" && options.font;\n  var fontOrFamily = isFont ? options.font : options.fontFamily;\n\n  if (text.charCodeAt(0) === 0xD835) {\n    // surrogate pairs get special treatment\n    var _wideCharacterFont = wide_character_wideCharacterFont(text, mode),\n        wideFontName = _wideCharacterFont[0],\n        wideFontClass = _wideCharacterFont[1];\n\n    return buildCommon_makeSymbol(text, wideFontName, mode, options, classes.concat(wideFontClass));\n  } else if (fontOrFamily) {\n    var fontName;\n    var fontClasses;\n\n    if (fontOrFamily === \"boldsymbol\" || fontOrFamily === \"mathnormal\") {\n      var fontData = fontOrFamily === \"boldsymbol\" ? boldsymbol(text, mode, options, classes) : buildCommon_mathnormal(text, mode, options, classes);\n      fontName = fontData.fontName;\n      fontClasses = [fontData.fontClass];\n    } else if (utils.contains(mathitLetters, text)) {\n      fontName = \"Main-Italic\";\n      fontClasses = [\"mathit\"];\n    } else if (isFont) {\n      fontName = fontMap[fontOrFamily].fontName;\n      fontClasses = [fontOrFamily];\n    } else {\n      fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);\n      fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];\n    }\n\n    if (buildCommon_lookupSymbol(text, fontName, mode).metrics) {\n      return buildCommon_makeSymbol(text, fontName, mode, options, classes.concat(fontClasses));\n    } else if (ligatures.hasOwnProperty(text) && fontName.substr(0, 10) === \"Typewriter\") {\n      // Deconstruct ligatures in monospace fonts (\\texttt, \\tt).\n      var parts = [];\n\n      for (var i = 0; i < text.length; i++) {\n        parts.push(buildCommon_makeSymbol(text[i], fontName, mode, options, classes.concat(fontClasses)));\n      }\n\n      return buildCommon_makeFragment(parts);\n    }\n  } // Makes a symbol in the default font for mathords and textords.\n\n\n  if (type === \"mathord\") {\n    var fontLookup = buildCommon_mathdefault(text, mode, options, classes);\n    return buildCommon_makeSymbol(text, fontLookup.fontName, mode, options, classes.concat([fontLookup.fontClass]));\n  } else if (type === \"textord\") {\n    var font = src_symbols[mode][text] && src_symbols[mode][text].font;\n\n    if (font === \"ams\") {\n      var _fontName = retrieveTextFontName(\"amsrm\", options.fontWeight, options.fontShape);\n\n      return buildCommon_makeSymbol(text, _fontName, mode, options, classes.concat(\"amsrm\", options.fontWeight, options.fontShape));\n    } else if (font === \"main\" || !font) {\n      var _fontName2 = retrieveTextFontName(\"textrm\", options.fontWeight, options.fontShape);\n\n      return buildCommon_makeSymbol(text, _fontName2, mode, options, classes.concat(options.fontWeight, options.fontShape));\n    } else {\n      // fonts added by plugins\n      var _fontName3 = retrieveTextFontName(font, options.fontWeight, options.fontShape); // We add font name as a css class\n\n\n      return buildCommon_makeSymbol(text, _fontName3, mode, options, classes.concat(_fontName3, options.fontWeight, options.fontShape));\n    }\n  } else {\n    throw new Error(\"unexpected type: \" + type + \" in makeOrd\");\n  }\n};\n/**\n * Returns true if subsequent symbolNodes have the same classes, skew, maxFont,\n * and styles.\n */\n\n\nvar buildCommon_canCombine = function canCombine(prev, next) {\n  if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {\n    return false;\n  }\n\n  for (var style in prev.style) {\n    if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {\n      return false;\n    }\n  }\n\n  for (var _style in next.style) {\n    if (next.style.hasOwnProperty(_style) && prev.style[_style] !== next.style[_style]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Combine consequetive domTree.symbolNodes into a single symbolNode.\n * Note: this function mutates the argument.\n */\n\n\nvar buildCommon_tryCombineChars = function tryCombineChars(chars) {\n  for (var i = 0; i < chars.length - 1; i++) {\n    var prev = chars[i];\n    var next = chars[i + 1];\n\n    if (prev instanceof domTree_SymbolNode && next instanceof domTree_SymbolNode && buildCommon_canCombine(prev, next)) {\n      prev.text += next.text;\n      prev.height = Math.max(prev.height, next.height);\n      prev.depth = Math.max(prev.depth, next.depth); // Use the last character's italic correction since we use\n      // it to add padding to the right of the span created from\n      // the combined characters.\n\n      prev.italic = next.italic;\n      chars.splice(i + 1, 1);\n      i--;\n    }\n  }\n\n  return chars;\n};\n/**\n * Calculate the height, depth, and maxFontSize of an element based on its\n * children.\n */\n\n\nvar sizeElementFromChildren = function sizeElementFromChildren(elem) {\n  var height = 0;\n  var depth = 0;\n  var maxFontSize = 0;\n\n  for (var i = 0; i < elem.children.length; i++) {\n    var child = elem.children[i];\n\n    if (child.height > height) {\n      height = child.height;\n    }\n\n    if (child.depth > depth) {\n      depth = child.depth;\n    }\n\n    if (child.maxFontSize > maxFontSize) {\n      maxFontSize = child.maxFontSize;\n    }\n  }\n\n  elem.height = height;\n  elem.depth = depth;\n  elem.maxFontSize = maxFontSize;\n};\n/**\n * Makes a span with the given list of classes, list of children, and options.\n *\n * TODO(#953): Ensure that `options` is always provided (currently some call\n * sites don't pass it) and make the type below mandatory.\n * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which\n * should if present come first in `classes`.\n */\n\n\nvar buildCommon_makeSpan = function makeSpan(classes, children, options, style) {\n  var span = new domTree_Span(classes, children, options, style);\n  sizeElementFromChildren(span);\n  return span;\n}; // SVG one is simpler -- doesn't require height, depth, max-font setting.\n// This is also a separate method for typesafety.\n\n\nvar buildCommon_makeSvgSpan = function makeSvgSpan(classes, children, options, style) {\n  return new domTree_Span(classes, children, options, style);\n};\n\nvar makeLineSpan = function makeLineSpan(className, options, thickness) {\n  var line = buildCommon_makeSpan([className], [], options);\n  line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);\n  line.style.borderBottomWidth = line.height + \"em\";\n  line.maxFontSize = 1.0;\n  return line;\n};\n/**\n * Makes an anchor with the given href, list of classes, list of children,\n * and options.\n */\n\n\nvar buildCommon_makeAnchor = function makeAnchor(href, classes, children, options) {\n  var anchor = new domTree_Anchor(href, classes, children, options);\n  sizeElementFromChildren(anchor);\n  return anchor;\n};\n/**\n * Makes a document fragment with the given list of children.\n */\n\n\nvar buildCommon_makeFragment = function makeFragment(children) {\n  var fragment = new tree_DocumentFragment(children);\n  sizeElementFromChildren(fragment);\n  return fragment;\n};\n/**\n * Wraps group in a span if it's a document fragment, allowing to apply classes\n * and styles\n */\n\n\nvar buildCommon_wrapFragment = function wrapFragment(group, options) {\n  if (group instanceof tree_DocumentFragment) {\n    return buildCommon_makeSpan([], [group], options);\n  }\n\n  return group;\n}; // These are exact object types to catch typos in the names of the optional fields.\n\n\n// Computes the updated `children` list and the overall depth.\n//\n// This helper function for makeVList makes it easier to enforce type safety by\n// allowing early exits (returns) in the logic.\nvar getVListChildrenAndDepth = function getVListChildrenAndDepth(params) {\n  if (params.positionType === \"individualShift\") {\n    var oldChildren = params.children;\n    var children = [oldChildren[0]]; // Add in kerns to the list of params.children to get each element to be\n    // shifted to the correct specified shift\n\n    var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;\n\n    var currPos = _depth;\n\n    for (var i = 1; i < oldChildren.length; i++) {\n      var diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;\n      var size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);\n      currPos = currPos + diff;\n      children.push({\n        type: \"kern\",\n        size: size\n      });\n      children.push(oldChildren[i]);\n    }\n\n    return {\n      children: children,\n      depth: _depth\n    };\n  }\n\n  var depth;\n\n  if (params.positionType === \"top\") {\n    // We always start at the bottom, so calculate the bottom by adding up\n    // all the sizes\n    var bottom = params.positionData;\n\n    for (var _i = 0; _i < params.children.length; _i++) {\n      var child = params.children[_i];\n      bottom -= child.type === \"kern\" ? child.size : child.elem.height + child.elem.depth;\n    }\n\n    depth = bottom;\n  } else if (params.positionType === \"bottom\") {\n    depth = -params.positionData;\n  } else {\n    var firstChild = params.children[0];\n\n    if (firstChild.type !== \"elem\") {\n      throw new Error('First child must have type \"elem\".');\n    }\n\n    if (params.positionType === \"shift\") {\n      depth = -firstChild.elem.depth - params.positionData;\n    } else if (params.positionType === \"firstBaseline\") {\n      depth = -firstChild.elem.depth;\n    } else {\n      throw new Error(\"Invalid positionType \" + params.positionType + \".\");\n    }\n  }\n\n  return {\n    children: params.children,\n    depth: depth\n  };\n};\n/**\n * Makes a vertical list by stacking elements and kerns on top of each other.\n * Allows for many different ways of specifying the positioning method.\n *\n * See VListParam documentation above.\n */\n\n\nvar buildCommon_makeVList = function makeVList(params, options) {\n  var _getVListChildrenAndD = getVListChildrenAndDepth(params),\n      children = _getVListChildrenAndD.children,\n      depth = _getVListChildrenAndD.depth; // Create a strut that is taller than any list item. The strut is added to\n  // each item, where it will determine the item's baseline. Since it has\n  // `overflow:hidden`, the strut's top edge will sit on the item's line box's\n  // top edge and the strut's bottom edge will sit on the item's baseline,\n  // with no additional line-height spacing. This allows the item baseline to\n  // be positioned precisely without worrying about font ascent and\n  // line-height.\n\n\n  var pstrutSize = 0;\n\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n\n    if (child.type === \"elem\") {\n      var elem = child.elem;\n      pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);\n    }\n  }\n\n  pstrutSize += 2;\n  var pstrut = buildCommon_makeSpan([\"pstrut\"], []);\n  pstrut.style.height = pstrutSize + \"em\"; // Create a new list of actual children at the correct offsets\n\n  var realChildren = [];\n  var minPos = depth;\n  var maxPos = depth;\n  var currPos = depth;\n\n  for (var _i2 = 0; _i2 < children.length; _i2++) {\n    var _child = children[_i2];\n\n    if (_child.type === \"kern\") {\n      currPos += _child.size;\n    } else {\n      var _elem = _child.elem;\n      var classes = _child.wrapperClasses || [];\n      var style = _child.wrapperStyle || {};\n      var childWrap = buildCommon_makeSpan(classes, [pstrut, _elem], undefined, style);\n      childWrap.style.top = -pstrutSize - currPos - _elem.depth + \"em\";\n\n      if (_child.marginLeft) {\n        childWrap.style.marginLeft = _child.marginLeft;\n      }\n\n      if (_child.marginRight) {\n        childWrap.style.marginRight = _child.marginRight;\n      }\n\n      realChildren.push(childWrap);\n      currPos += _elem.height + _elem.depth;\n    }\n\n    minPos = Math.min(minPos, currPos);\n    maxPos = Math.max(maxPos, currPos);\n  } // The vlist contents go in a table-cell with `vertical-align:bottom`.\n  // This cell's bottom edge will determine the containing table's baseline\n  // without overly expanding the containing line-box.\n\n\n  var vlist = buildCommon_makeSpan([\"vlist\"], realChildren);\n  vlist.style.height = maxPos + \"em\"; // A second row is used if necessary to represent the vlist's depth.\n\n  var rows;\n\n  if (minPos < 0) {\n    // We will define depth in an empty span with display: table-cell.\n    // It should render with the height that we define. But Chrome, in\n    // contenteditable mode only, treats that span as if it contains some\n    // text content. And that min-height over-rides our desired height.\n    // So we put another empty span inside the depth strut span.\n    var emptySpan = buildCommon_makeSpan([], []);\n    var depthStrut = buildCommon_makeSpan([\"vlist\"], [emptySpan]);\n    depthStrut.style.height = -minPos + \"em\"; // Safari wants the first row to have inline content; otherwise it\n    // puts the bottom of the *second* row on the baseline.\n\n    var topStrut = buildCommon_makeSpan([\"vlist-s\"], [new domTree_SymbolNode(\"\\u200B\")]);\n    rows = [buildCommon_makeSpan([\"vlist-r\"], [vlist, topStrut]), buildCommon_makeSpan([\"vlist-r\"], [depthStrut])];\n  } else {\n    rows = [buildCommon_makeSpan([\"vlist-r\"], [vlist])];\n  }\n\n  var vtable = buildCommon_makeSpan([\"vlist-t\"], rows);\n\n  if (rows.length === 2) {\n    vtable.classes.push(\"vlist-t2\");\n  }\n\n  vtable.height = maxPos;\n  vtable.depth = -minPos;\n  return vtable;\n}; // Glue is a concept from TeX which is a flexible space between elements in\n// either a vertical or horizontal list. In KaTeX, at least for now, it's\n// static space between elements in a horizontal layout.\n\n\nvar buildCommon_makeGlue = function makeGlue(measurement, options) {\n  // Make an empty span for the space\n  var rule = buildCommon_makeSpan([\"mspace\"], [], options);\n  var size = units_calculateSize(measurement, options);\n  rule.style.marginRight = size + \"em\";\n  return rule;\n}; // Takes font options, and returns the appropriate fontLookup name\n\n\nvar retrieveTextFontName = function retrieveTextFontName(fontFamily, fontWeight, fontShape) {\n  var baseFontName = \"\";\n\n  switch (fontFamily) {\n    case \"amsrm\":\n      baseFontName = \"AMS\";\n      break;\n\n    case \"textrm\":\n      baseFontName = \"Main\";\n      break;\n\n    case \"textsf\":\n      baseFontName = \"SansSerif\";\n      break;\n\n    case \"texttt\":\n      baseFontName = \"Typewriter\";\n      break;\n\n    default:\n      baseFontName = fontFamily;\n    // use fonts added by a plugin\n  }\n\n  var fontStylesName;\n\n  if (fontWeight === \"textbf\" && fontShape === \"textit\") {\n    fontStylesName = \"BoldItalic\";\n  } else if (fontWeight === \"textbf\") {\n    fontStylesName = \"Bold\";\n  } else if (fontWeight === \"textit\") {\n    fontStylesName = \"Italic\";\n  } else {\n    fontStylesName = \"Regular\";\n  }\n\n  return baseFontName + \"-\" + fontStylesName;\n};\n/**\n * Maps TeX font commands to objects containing:\n * - variant: string used for \"mathvariant\" attribute in buildMathML.js\n * - fontName: the \"style\" parameter to fontMetrics.getCharacterMetrics\n */\n// A map between tex font commands an MathML mathvariant attribute values\n\n\nvar fontMap = {\n  // styles\n  \"mathbf\": {\n    variant: \"bold\",\n    fontName: \"Main-Bold\"\n  },\n  \"mathrm\": {\n    variant: \"normal\",\n    fontName: \"Main-Regular\"\n  },\n  \"textit\": {\n    variant: \"italic\",\n    fontName: \"Main-Italic\"\n  },\n  \"mathit\": {\n    variant: \"italic\",\n    fontName: \"Main-Italic\"\n  },\n  // Default math font, \"mathnormal\" and \"boldsymbol\" are missing because they\n  // require the use of several fonts: Main-Italic and Math-Italic for default\n  // math font, Main-Italic, Math-Italic, Caligraphic for \"mathnormal\", and\n  // Math-BoldItalic and Main-Bold for \"boldsymbol\".  This is handled by a\n  // special case in makeOrd which ends up calling mathdefault, mathnormal,\n  // and boldsymbol.\n  // families\n  \"mathbb\": {\n    variant: \"double-struck\",\n    fontName: \"AMS-Regular\"\n  },\n  \"mathcal\": {\n    variant: \"script\",\n    fontName: \"Caligraphic-Regular\"\n  },\n  \"mathfrak\": {\n    variant: \"fraktur\",\n    fontName: \"Fraktur-Regular\"\n  },\n  \"mathscr\": {\n    variant: \"script\",\n    fontName: \"Script-Regular\"\n  },\n  \"mathsf\": {\n    variant: \"sans-serif\",\n    fontName: \"SansSerif-Regular\"\n  },\n  \"mathtt\": {\n    variant: \"monospace\",\n    fontName: \"Typewriter-Regular\"\n  }\n};\nvar svgData = {\n  //   path, width, height\n  vec: [\"vec\", 0.471, 0.714],\n  // values from the font glyph\n  oiintSize1: [\"oiintSize1\", 0.957, 0.499],\n  // oval to overlay the integrand\n  oiintSize2: [\"oiintSize2\", 1.472, 0.659],\n  oiiintSize1: [\"oiiintSize1\", 1.304, 0.499],\n  oiiintSize2: [\"oiiintSize2\", 1.98, 0.659]\n};\n\nvar buildCommon_staticSvg = function staticSvg(value, options) {\n  // Create a span with inline SVG for the element.\n  var _svgData$value = svgData[value],\n      pathName = _svgData$value[0],\n      width = _svgData$value[1],\n      height = _svgData$value[2];\n  var path = new domTree_PathNode(pathName);\n  var svgNode = new SvgNode([path], {\n    \"width\": width + \"em\",\n    \"height\": height + \"em\",\n    // Override CSS rule `.katex svg { width: 100% }`\n    \"style\": \"width:\" + width + \"em\",\n    \"viewBox\": \"0 0 \" + 1000 * width + \" \" + 1000 * height,\n    \"preserveAspectRatio\": \"xMinYMin\"\n  });\n  var span = buildCommon_makeSvgSpan([\"overlay\"], [svgNode], options);\n  span.height = height;\n  span.style.height = height + \"em\";\n  span.style.width = width + \"em\";\n  return span;\n};\n\n/* harmony default export */ var buildCommon = ({\n  fontMap: fontMap,\n  makeSymbol: buildCommon_makeSymbol,\n  mathsym: buildCommon_mathsym,\n  makeSpan: buildCommon_makeSpan,\n  makeSvgSpan: buildCommon_makeSvgSpan,\n  makeLineSpan: makeLineSpan,\n  makeAnchor: buildCommon_makeAnchor,\n  makeFragment: buildCommon_makeFragment,\n  wrapFragment: buildCommon_wrapFragment,\n  makeVList: buildCommon_makeVList,\n  makeOrd: buildCommon_makeOrd,\n  makeGlue: buildCommon_makeGlue,\n  staticSvg: buildCommon_staticSvg,\n  svgData: svgData,\n  tryCombineChars: buildCommon_tryCombineChars\n});\n// CONCATENATED MODULE: ./src/parseNode.js\n\n\n/**\n * Asserts that the node is of the given type and returns it with stricter\n * typing. Throws if the node's type does not match.\n */\nfunction assertNodeType(node, type) {\n  var typedNode = checkNodeType(node, type);\n\n  if (!typedNode) {\n    throw new Error(\"Expected node of type \" + type + \", but got \" + (node ? \"node of type \" + node.type : String(node)));\n  } // $FlowFixMe: Unsure why.\n\n\n  return typedNode;\n}\n/**\n * Returns the node more strictly typed iff it is of the given type. Otherwise,\n * returns null.\n */\n\nfunction checkNodeType(node, type) {\n  if (node && node.type === type) {\n    // The definition of ParseNode<TYPE> doesn't communicate to flow that\n    // `type: TYPE` (as that's not explicitly mentioned anywhere), though that\n    // happens to be true for all our value types.\n    // $FlowFixMe\n    return node;\n  }\n\n  return null;\n}\n/**\n * Asserts that the node is of the given type and returns it with stricter\n * typing. Throws if the node's type does not match.\n */\n\nfunction assertAtomFamily(node, family) {\n  var typedNode = checkAtomFamily(node, family);\n\n  if (!typedNode) {\n    throw new Error(\"Expected node of type \\\"atom\\\" and family \\\"\" + family + \"\\\", but got \" + (node ? node.type === \"atom\" ? \"atom of family \" + node.family : \"node of type \" + node.type : String(node)));\n  }\n\n  return typedNode;\n}\n/**\n * Returns the node more strictly typed iff it is of the given type. Otherwise,\n * returns null.\n */\n\nfunction checkAtomFamily(node, family) {\n  return node && node.type === \"atom\" && node.family === family ? node : null;\n}\n/**\n * Returns the node more strictly typed iff it is of the given type. Otherwise,\n * returns null.\n */\n\nfunction assertSymbolNodeType(node) {\n  var typedNode = checkSymbolNodeType(node);\n\n  if (!typedNode) {\n    throw new Error(\"Expected node of symbol group type, but got \" + (node ? \"node of type \" + node.type : String(node)));\n  }\n\n  return typedNode;\n}\n/**\n * Returns the node more strictly typed iff it is of the given type. Otherwise,\n * returns null.\n */\n\nfunction checkSymbolNodeType(node) {\n  if (node && (node.type === \"atom\" || NON_ATOMS.hasOwnProperty(node.type))) {\n    // $FlowFixMe\n    return node;\n  }\n\n  return null;\n}\n// CONCATENATED MODULE: ./src/spacingData.js\n/**\n * Describes spaces between different classes of atoms.\n */\nvar thinspace = {\n  number: 3,\n  unit: \"mu\"\n};\nvar mediumspace = {\n  number: 4,\n  unit: \"mu\"\n};\nvar thickspace = {\n  number: 5,\n  unit: \"mu\"\n}; // Making the type below exact with all optional fields doesn't work due to\n// - https://github.com/facebook/flow/issues/4582\n// - https://github.com/facebook/flow/issues/5688\n// However, since *all* fields are optional, $Shape<> works as suggested in 5688\n// above.\n\n// Spacing relationships for display and text styles\nvar spacings = {\n  mord: {\n    mop: thinspace,\n    mbin: mediumspace,\n    mrel: thickspace,\n    minner: thinspace\n  },\n  mop: {\n    mord: thinspace,\n    mop: thinspace,\n    mrel: thickspace,\n    minner: thinspace\n  },\n  mbin: {\n    mord: mediumspace,\n    mop: mediumspace,\n    mopen: mediumspace,\n    minner: mediumspace\n  },\n  mrel: {\n    mord: thickspace,\n    mop: thickspace,\n    mopen: thickspace,\n    minner: thickspace\n  },\n  mopen: {},\n  mclose: {\n    mop: thinspace,\n    mbin: mediumspace,\n    mrel: thickspace,\n    minner: thinspace\n  },\n  mpunct: {\n    mord: thinspace,\n    mop: thinspace,\n    mrel: thickspace,\n    mopen: thinspace,\n    mclose: thinspace,\n    mpunct: thinspace,\n    minner: thinspace\n  },\n  minner: {\n    mord: thinspace,\n    mop: thinspace,\n    mbin: mediumspace,\n    mrel: thickspace,\n    mopen: thinspace,\n    mpunct: thinspace,\n    minner: thinspace\n  }\n}; // Spacing relationships for script and scriptscript styles\n\nvar tightSpacings = {\n  mord: {\n    mop: thinspace\n  },\n  mop: {\n    mord: thinspace,\n    mop: thinspace\n  },\n  mbin: {},\n  mrel: {},\n  mopen: {},\n  mclose: {\n    mop: thinspace\n  },\n  mpunct: {},\n  minner: {\n    mop: thinspace\n  }\n};\n// CONCATENATED MODULE: ./src/defineFunction.js\n\n\n/**\n * All registered functions.\n * `functions.js` just exports this same dictionary again and makes it public.\n * `Parser.js` requires this dictionary.\n */\nvar _functions = {};\n/**\n * All HTML builders. Should be only used in the `define*` and the `build*ML`\n * functions.\n */\n\nvar _htmlGroupBuilders = {};\n/**\n * All MathML builders. Should be only used in the `define*` and the `build*ML`\n * functions.\n */\n\nvar _mathmlGroupBuilders = {};\nfunction defineFunction(_ref) {\n  var type = _ref.type,\n      names = _ref.names,\n      props = _ref.props,\n      handler = _ref.handler,\n      htmlBuilder = _ref.htmlBuilder,\n      mathmlBuilder = _ref.mathmlBuilder;\n  // Set default values of functions\n  var data = {\n    type: type,\n    numArgs: props.numArgs,\n    argTypes: props.argTypes,\n    greediness: props.greediness === undefined ? 1 : props.greediness,\n    allowedInText: !!props.allowedInText,\n    allowedInMath: props.allowedInMath === undefined ? true : props.allowedInMath,\n    numOptionalArgs: props.numOptionalArgs || 0,\n    infix: !!props.infix,\n    handler: handler\n  };\n\n  for (var i = 0; i < names.length; ++i) {\n    _functions[names[i]] = data;\n  }\n\n  if (type) {\n    if (htmlBuilder) {\n      _htmlGroupBuilders[type] = htmlBuilder;\n    }\n\n    if (mathmlBuilder) {\n      _mathmlGroupBuilders[type] = mathmlBuilder;\n    }\n  }\n}\n/**\n * Use this to register only the HTML and MathML builders for a function (e.g.\n * if the function's ParseNode is generated in Parser.js rather than via a\n * stand-alone handler provided to `defineFunction`).\n */\n\nfunction defineFunctionBuilders(_ref2) {\n  var type = _ref2.type,\n      htmlBuilder = _ref2.htmlBuilder,\n      mathmlBuilder = _ref2.mathmlBuilder;\n  defineFunction({\n    type: type,\n    names: [],\n    props: {\n      numArgs: 0\n    },\n    handler: function handler() {\n      throw new Error('Should never be called.');\n    },\n    htmlBuilder: htmlBuilder,\n    mathmlBuilder: mathmlBuilder\n  });\n} // Since the corresponding buildHTML/buildMathML function expects a\n// list of elements, we normalize for different kinds of arguments\n\nvar defineFunction_ordargument = function ordargument(arg) {\n  var node = checkNodeType(arg, \"ordgroup\");\n  return node ? node.body : [arg];\n};\n// CONCATENATED MODULE: ./src/buildHTML.js\n/**\n * This file does the main work of building a domTree structure from a parse\n * tree. The entry point is the `buildHTML` function, which takes a parse tree.\n * Then, the buildExpression, buildGroup, and various groupBuilders functions\n * are called, to produce a final HTML tree.\n */\n\n\n\n\n\n\n\n\n\nvar buildHTML_makeSpan = buildCommon.makeSpan; // Binary atoms (first class `mbin`) change into ordinary atoms (`mord`)\n// depending on their surroundings. See TeXbook pg. 442-446, Rules 5 and 6,\n// and the text before Rule 19.\n\nvar binLeftCanceller = [\"leftmost\", \"mbin\", \"mopen\", \"mrel\", \"mop\", \"mpunct\"];\nvar binRightCanceller = [\"rightmost\", \"mrel\", \"mclose\", \"mpunct\"];\nvar styleMap = {\n  \"display\": src_Style.DISPLAY,\n  \"text\": src_Style.TEXT,\n  \"script\": src_Style.SCRIPT,\n  \"scriptscript\": src_Style.SCRIPTSCRIPT\n};\nvar DomEnum = {\n  mord: \"mord\",\n  mop: \"mop\",\n  mbin: \"mbin\",\n  mrel: \"mrel\",\n  mopen: \"mopen\",\n  mclose: \"mclose\",\n  mpunct: \"mpunct\",\n  minner: \"minner\"\n};\n\n/**\n * Take a list of nodes, build them in order, and return a list of the built\n * nodes. documentFragments are flattened into their contents, so the\n * returned list contains no fragments. `isRealGroup` is true if `expression`\n * is a real group (no atoms will be added on either side), as opposed to\n * a partial group (e.g. one created by \\color). `surrounding` is an array\n * consisting type of nodes that will be added to the left and right.\n */\nvar buildHTML_buildExpression = function buildExpression(expression, options, isRealGroup, surrounding) {\n  if (surrounding === void 0) {\n    surrounding = [null, null];\n  }\n\n  // Parse expressions into `groups`.\n  var groups = [];\n\n  for (var i = 0; i < expression.length; i++) {\n    var output = buildHTML_buildGroup(expression[i], options);\n\n    if (output instanceof tree_DocumentFragment) {\n      var children = output.children;\n      groups.push.apply(groups, children);\n    } else {\n      groups.push(output);\n    }\n  } // If `expression` is a partial group, let the parent handle spacings\n  // to avoid processing groups multiple times.\n\n\n  if (!isRealGroup) {\n    return groups;\n  }\n\n  var glueOptions = options;\n\n  if (expression.length === 1) {\n    var node = checkNodeType(expression[0], \"sizing\") || checkNodeType(expression[0], \"styling\");\n\n    if (!node) {// No match.\n    } else if (node.type === \"sizing\") {\n      glueOptions = options.havingSize(node.size);\n    } else if (node.type === \"styling\") {\n      glueOptions = options.havingStyle(styleMap[node.style]);\n    }\n  } // Dummy spans for determining spacings between surrounding atoms.\n  // If `expression` has no atoms on the left or right, class \"leftmost\"\n  // or \"rightmost\", respectively, is used to indicate it.\n\n\n  var dummyPrev = buildHTML_makeSpan([surrounding[0] || \"leftmost\"], [], options);\n  var dummyNext = buildHTML_makeSpan([surrounding[1] || \"rightmost\"], [], options); // TODO: These code assumes that a node's math class is the first element\n  // of its `classes` array. A later cleanup should ensure this, for\n  // instance by changing the signature of `makeSpan`.\n  // Before determining what spaces to insert, perform bin cancellation.\n  // Binary operators change to ordinary symbols in some contexts.\n\n  traverseNonSpaceNodes(groups, function (node, prev) {\n    var prevType = prev.classes[0];\n    var type = node.classes[0];\n\n    if (prevType === \"mbin\" && utils.contains(binRightCanceller, type)) {\n      prev.classes[0] = \"mord\";\n    } else if (type === \"mbin\" && utils.contains(binLeftCanceller, prevType)) {\n      node.classes[0] = \"mord\";\n    }\n  }, {\n    node: dummyPrev\n  }, dummyNext);\n  traverseNonSpaceNodes(groups, function (node, prev) {\n    var prevType = getTypeOfDomTree(prev);\n    var type = getTypeOfDomTree(node); // 'mtight' indicates that the node is script or scriptscript style.\n\n    var space = prevType && type ? node.hasClass(\"mtight\") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;\n\n    if (space) {\n      // Insert glue (spacing) after the `prev`.\n      return buildCommon.makeGlue(space, glueOptions);\n    }\n  }, {\n    node: dummyPrev\n  }, dummyNext);\n  return groups;\n}; // Depth-first traverse non-space `nodes`, calling `callback` with the current and\n// previous node as arguments, optionally returning a node to insert after the\n// previous node. `prev` is an object with the previous node and `insertAfter`\n// function to insert after it. `next` is a node that will be added to the right.\n// Used for bin cancellation and inserting spacings.\n\nvar traverseNonSpaceNodes = function traverseNonSpaceNodes(nodes, callback, prev, next) {\n  if (next) {\n    // temporarily append the right node, if exists\n    nodes.push(next);\n  }\n\n  var i = 0;\n\n  for (; i < nodes.length; i++) {\n    var node = nodes[i];\n    var partialGroup = buildHTML_checkPartialGroup(node);\n\n    if (partialGroup) {\n      // Recursive DFS\n      // $FlowFixMe: make nodes a $ReadOnlyArray by returning a new array\n      traverseNonSpaceNodes(partialGroup.children, callback, prev);\n      continue;\n    } // Ignore explicit spaces (e.g., \\;, \\,) when determining what implicit\n    // spacing should go between atoms of different classes\n\n\n    if (node.classes[0] === \"mspace\") {\n      continue;\n    }\n\n    var result = callback(node, prev.node);\n\n    if (result) {\n      if (prev.insertAfter) {\n        prev.insertAfter(result);\n      } else {\n        // insert at front\n        nodes.unshift(result);\n        i++;\n      }\n    }\n\n    prev.node = node;\n\n    prev.insertAfter = function (index) {\n      return function (n) {\n        nodes.splice(index + 1, 0, n);\n        i++;\n      };\n    }(i);\n  }\n\n  if (next) {\n    nodes.pop();\n  }\n}; // Check if given node is a partial group, i.e., does not affect spacing around.\n\n\nvar buildHTML_checkPartialGroup = function checkPartialGroup(node) {\n  if (node instanceof tree_DocumentFragment || node instanceof domTree_Anchor) {\n    return node;\n  }\n\n  return null;\n}; // Return the outermost node of a domTree.\n\n\nvar getOutermostNode = function getOutermostNode(node, side) {\n  var partialGroup = buildHTML_checkPartialGroup(node);\n\n  if (partialGroup) {\n    var children = partialGroup.children;\n\n    if (children.length) {\n      if (side === \"right\") {\n        return getOutermostNode(children[children.length - 1], \"right\");\n      } else if (side === \"left\") {\n        return getOutermostNode(children[0], \"left\");\n      }\n    }\n  }\n\n  return node;\n}; // Return math atom class (mclass) of a domTree.\n// If `side` is given, it will get the type of the outermost node at given side.\n\n\nvar getTypeOfDomTree = function getTypeOfDomTree(node, side) {\n  if (!node) {\n    return null;\n  }\n\n  if (side) {\n    node = getOutermostNode(node, side);\n  } // This makes a lot of assumptions as to where the type of atom\n  // appears.  We should do a better job of enforcing this.\n\n\n  return DomEnum[node.classes[0]] || null;\n};\nvar makeNullDelimiter = function makeNullDelimiter(options, classes) {\n  var moreClasses = [\"nulldelimiter\"].concat(options.baseSizingClasses());\n  return buildHTML_makeSpan(classes.concat(moreClasses));\n};\n/**\n * buildGroup is the function that takes a group and calls the correct groupType\n * function for it. It also handles the interaction of size and style changes\n * between parents and children.\n */\n\nvar buildHTML_buildGroup = function buildGroup(group, options, baseOptions) {\n  if (!group) {\n    return buildHTML_makeSpan();\n  }\n\n  if (_htmlGroupBuilders[group.type]) {\n    // Call the groupBuilders function\n    var groupNode = _htmlGroupBuilders[group.type](group, options); // If the size changed between the parent and the current group, account\n    // for that size difference.\n\n    if (baseOptions && options.size !== baseOptions.size) {\n      groupNode = buildHTML_makeSpan(options.sizingClasses(baseOptions), [groupNode], options);\n      var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;\n      groupNode.height *= multiplier;\n      groupNode.depth *= multiplier;\n    }\n\n    return groupNode;\n  } else {\n    throw new src_ParseError(\"Got group of unknown type: '\" + group.type + \"'\");\n  }\n};\n/**\n * Combine an array of HTML DOM nodes (e.g., the output of `buildExpression`)\n * into an unbreakable HTML node of class .base, with proper struts to\n * guarantee correct vertical extent.  `buildHTML` calls this repeatedly to\n * make up the entire expression as a sequence of unbreakable units.\n */\n\nfunction buildHTMLUnbreakable(children, options) {\n  // Compute height and depth of this chunk.\n  var body = buildHTML_makeSpan([\"base\"], children, options); // Add strut, which ensures that the top of the HTML element falls at\n  // the height of the expression, and the bottom of the HTML element\n  // falls at the depth of the expression.\n  // We used to have separate top and bottom struts, where the bottom strut\n  // would like to use `vertical-align: top`, but in IE 9 this lowers the\n  // baseline of the box to the bottom of this strut (instead of staying in\n  // the normal place) so we use an absolute value for vertical-align instead.\n\n  var strut = buildHTML_makeSpan([\"strut\"]);\n  strut.style.height = body.height + body.depth + \"em\";\n  strut.style.verticalAlign = -body.depth + \"em\";\n  body.children.unshift(strut);\n  return body;\n}\n/**\n * Take an entire parse tree, and build it into an appropriate set of HTML\n * nodes.\n */\n\n\nfunction buildHTML(tree, options) {\n  // Strip off outer tag wrapper for processing below.\n  var tag = null;\n\n  if (tree.length === 1 && tree[0].type === \"tag\") {\n    tag = tree[0].tag;\n    tree = tree[0].body;\n  } // Build the expression contained in the tree\n\n\n  var expression = buildHTML_buildExpression(tree, options, true);\n  var children = []; // Create one base node for each chunk between potential line breaks.\n  // The TeXBook [p.173] says \"A formula will be broken only after a\n  // relation symbol like $=$ or $<$ or $\\rightarrow$, or after a binary\n  // operation symbol like $+$ or $-$ or $\\times$, where the relation or\n  // binary operation is on the ``outer level'' of the formula (i.e., not\n  // enclosed in {...} and not part of an \\over construction).\"\n\n  var parts = [];\n\n  for (var i = 0; i < expression.length; i++) {\n    parts.push(expression[i]);\n\n    if (expression[i].hasClass(\"mbin\") || expression[i].hasClass(\"mrel\") || expression[i].hasClass(\"allowbreak\")) {\n      // Put any post-operator glue on same line as operator.\n      // Watch for \\nobreak along the way, and stop at \\newline.\n      var nobreak = false;\n\n      while (i < expression.length - 1 && expression[i + 1].hasClass(\"mspace\") && !expression[i + 1].hasClass(\"newline\")) {\n        i++;\n        parts.push(expression[i]);\n\n        if (expression[i].hasClass(\"nobreak\")) {\n          nobreak = true;\n        }\n      } // Don't allow break if \\nobreak among the post-operator glue.\n\n\n      if (!nobreak) {\n        children.push(buildHTMLUnbreakable(parts, options));\n        parts = [];\n      }\n    } else if (expression[i].hasClass(\"newline\")) {\n      // Write the line except the newline\n      parts.pop();\n\n      if (parts.length > 0) {\n        children.push(buildHTMLUnbreakable(parts, options));\n        parts = [];\n      } // Put the newline at the top level\n\n\n      children.push(expression[i]);\n    }\n  }\n\n  if (parts.length > 0) {\n    children.push(buildHTMLUnbreakable(parts, options));\n  } // Now, if there was a tag, build it too and append it as a final child.\n\n\n  var tagChild;\n\n  if (tag) {\n    tagChild = buildHTMLUnbreakable(buildHTML_buildExpression(tag, options, true));\n    tagChild.classes = [\"tag\"];\n    children.push(tagChild);\n  }\n\n  var htmlNode = buildHTML_makeSpan([\"katex-html\"], children);\n  htmlNode.setAttribute(\"aria-hidden\", \"true\"); // Adjust the strut of the tag to be the maximum height of all children\n  // (the height of the enclosing htmlNode) for proper vertical alignment.\n\n  if (tagChild) {\n    var strut = tagChild.children[0];\n    strut.style.height = htmlNode.height + htmlNode.depth + \"em\";\n    strut.style.verticalAlign = -htmlNode.depth + \"em\";\n  }\n\n  return htmlNode;\n}\n// CONCATENATED MODULE: ./src/mathMLTree.js\n/**\n * These objects store data about MathML nodes. This is the MathML equivalent\n * of the types in domTree.js. Since MathML handles its own rendering, and\n * since we're mainly using MathML to improve accessibility, we don't manage\n * any of the styling state that the plain DOM nodes do.\n *\n * The `toNode` and `toMarkup` functions work simlarly to how they do in\n * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.\n */\n\n\nfunction newDocumentFragment(children) {\n  return new tree_DocumentFragment(children);\n}\n/**\n * This node represents a general purpose MathML node of any type. The\n * constructor requires the type of node to create (for example, `\"mo\"` or\n * `\"mspace\"`, corresponding to `<mo>` and `<mspace>` tags).\n */\n\nvar mathMLTree_MathNode =\n/*#__PURE__*/\nfunction () {\n  function MathNode(type, children) {\n    this.type = void 0;\n    this.attributes = void 0;\n    this.children = void 0;\n    this.type = type;\n    this.attributes = {};\n    this.children = children || [];\n  }\n  /**\n   * Sets an attribute on a MathML node. MathML depends on attributes to convey a\n   * semantic content, so this is used heavily.\n   */\n\n\n  var _proto = MathNode.prototype;\n\n  _proto.setAttribute = function setAttribute(name, value) {\n    this.attributes[name] = value;\n  }\n  /**\n   * Gets an attribute on a MathML node.\n   */\n  ;\n\n  _proto.getAttribute = function getAttribute(name) {\n    return this.attributes[name];\n  }\n  /**\n   * Converts the math node into a MathML-namespaced DOM element.\n   */\n  ;\n\n  _proto.toNode = function toNode() {\n    var node = document.createElementNS(\"http://www.w3.org/1998/Math/MathML\", this.type);\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        node.setAttribute(attr, this.attributes[attr]);\n      }\n    }\n\n    for (var i = 0; i < this.children.length; i++) {\n      node.appendChild(this.children[i].toNode());\n    }\n\n    return node;\n  }\n  /**\n   * Converts the math node into an HTML markup string.\n   */\n  ;\n\n  _proto.toMarkup = function toMarkup() {\n    var markup = \"<\" + this.type; // Add the attributes\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        markup += \" \" + attr + \"=\\\"\";\n        markup += utils.escape(this.attributes[attr]);\n        markup += \"\\\"\";\n      }\n    }\n\n    markup += \">\";\n\n    for (var i = 0; i < this.children.length; i++) {\n      markup += this.children[i].toMarkup();\n    }\n\n    markup += \"</\" + this.type + \">\";\n    return markup;\n  }\n  /**\n   * Converts the math node into a string, similar to innerText, but escaped.\n   */\n  ;\n\n  _proto.toText = function toText() {\n    return this.children.map(function (child) {\n      return child.toText();\n    }).join(\"\");\n  };\n\n  return MathNode;\n}();\n/**\n * This node represents a piece of text.\n */\n\nvar mathMLTree_TextNode =\n/*#__PURE__*/\nfunction () {\n  function TextNode(text) {\n    this.text = void 0;\n    this.text = text;\n  }\n  /**\n   * Converts the text node into a DOM text node.\n   */\n\n\n  var _proto2 = TextNode.prototype;\n\n  _proto2.toNode = function toNode() {\n    return document.createTextNode(this.text);\n  }\n  /**\n   * Converts the text node into escaped HTML markup\n   * (representing the text itself).\n   */\n  ;\n\n  _proto2.toMarkup = function toMarkup() {\n    return utils.escape(this.toText());\n  }\n  /**\n   * Converts the text node into a string\n   * (representing the text iteself).\n   */\n  ;\n\n  _proto2.toText = function toText() {\n    return this.text;\n  };\n\n  return TextNode;\n}();\n/**\n * This node represents a space, but may render as <mspace.../> or as text,\n * depending on the width.\n */\n\nvar SpaceNode =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Create a Space node with width given in CSS ems.\n   */\n  function SpaceNode(width) {\n    this.width = void 0;\n    this.character = void 0;\n    this.width = width; // See https://www.w3.org/TR/2000/WD-MathML2-20000328/chapter6.html\n    // for a table of space-like characters.  We use Unicode\n    // representations instead of &LongNames; as it's not clear how to\n    // make the latter via document.createTextNode.\n\n    if (width >= 0.05555 && width <= 0.05556) {\n      this.character = \"\\u200A\"; // &VeryThinSpace;\n    } else if (width >= 0.1666 && width <= 0.1667) {\n      this.character = \"\\u2009\"; // &ThinSpace;\n    } else if (width >= 0.2222 && width <= 0.2223) {\n      this.character = \"\\u2005\"; // &MediumSpace;\n    } else if (width >= 0.2777 && width <= 0.2778) {\n      this.character = \"\\u2005\\u200A\"; // &ThickSpace;\n    } else if (width >= -0.05556 && width <= -0.05555) {\n      this.character = \"\\u200A\\u2063\"; // &NegativeVeryThinSpace;\n    } else if (width >= -0.1667 && width <= -0.1666) {\n      this.character = \"\\u2009\\u2063\"; // &NegativeThinSpace;\n    } else if (width >= -0.2223 && width <= -0.2222) {\n      this.character = \"\\u205F\\u2063\"; // &NegativeMediumSpace;\n    } else if (width >= -0.2778 && width <= -0.2777) {\n      this.character = \"\\u2005\\u2063\"; // &NegativeThickSpace;\n    } else {\n      this.character = null;\n    }\n  }\n  /**\n   * Converts the math node into a MathML-namespaced DOM element.\n   */\n\n\n  var _proto3 = SpaceNode.prototype;\n\n  _proto3.toNode = function toNode() {\n    if (this.character) {\n      return document.createTextNode(this.character);\n    } else {\n      var node = document.createElementNS(\"http://www.w3.org/1998/Math/MathML\", \"mspace\");\n      node.setAttribute(\"width\", this.width + \"em\");\n      return node;\n    }\n  }\n  /**\n   * Converts the math node into an HTML markup string.\n   */\n  ;\n\n  _proto3.toMarkup = function toMarkup() {\n    if (this.character) {\n      return \"<mtext>\" + this.character + \"</mtext>\";\n    } else {\n      return \"<mspace width=\\\"\" + this.width + \"em\\\"/>\";\n    }\n  }\n  /**\n   * Converts the math node into a string, similar to innerText.\n   */\n  ;\n\n  _proto3.toText = function toText() {\n    if (this.character) {\n      return this.character;\n    } else {\n      return \" \";\n    }\n  };\n\n  return SpaceNode;\n}();\n\n/* harmony default export */ var mathMLTree = ({\n  MathNode: mathMLTree_MathNode,\n  TextNode: mathMLTree_TextNode,\n  SpaceNode: SpaceNode,\n  newDocumentFragment: newDocumentFragment\n});\n// CONCATENATED MODULE: ./src/buildMathML.js\n/**\n * This file converts a parse tree into a cooresponding MathML tree. The main\n * entry point is the `buildMathML` function, which takes a parse tree from the\n * parser.\n */\n\n\n\n\n\n\n\n\n\n/**\n * Takes a symbol and converts it into a MathML text node after performing\n * optional replacement from symbols.js.\n */\nvar buildMathML_makeText = function makeText(text, mode, options) {\n  if (src_symbols[mode][text] && src_symbols[mode][text].replace && text.charCodeAt(0) !== 0xD835 && !(ligatures.hasOwnProperty(text) && options && (options.fontFamily && options.fontFamily.substr(4, 2) === \"tt\" || options.font && options.font.substr(4, 2) === \"tt\"))) {\n    text = src_symbols[mode][text].replace;\n  }\n\n  return new mathMLTree.TextNode(text);\n};\n/**\n * Wrap the given array of nodes in an <mrow> node if needed, i.e.,\n * unless the array has length 1.  Always returns a single node.\n */\n\nvar buildMathML_makeRow = function makeRow(body) {\n  if (body.length === 1) {\n    return body[0];\n  } else {\n    return new mathMLTree.MathNode(\"mrow\", body);\n  }\n};\n/**\n * Returns the math variant as a string or null if none is required.\n */\n\nvar buildMathML_getVariant = function getVariant(group, options) {\n  // Handle \\text... font specifiers as best we can.\n  // MathML has a limited list of allowable mathvariant specifiers; see\n  // https://www.w3.org/TR/MathML3/chapter3.html#presm.commatt\n  if (options.fontFamily === \"texttt\") {\n    return \"monospace\";\n  } else if (options.fontFamily === \"textsf\") {\n    if (options.fontShape === \"textit\" && options.fontWeight === \"textbf\") {\n      return \"sans-serif-bold-italic\";\n    } else if (options.fontShape === \"textit\") {\n      return \"sans-serif-italic\";\n    } else if (options.fontWeight === \"textbf\") {\n      return \"bold-sans-serif\";\n    } else {\n      return \"sans-serif\";\n    }\n  } else if (options.fontShape === \"textit\" && options.fontWeight === \"textbf\") {\n    return \"bold-italic\";\n  } else if (options.fontShape === \"textit\") {\n    return \"italic\";\n  } else if (options.fontWeight === \"textbf\") {\n    return \"bold\";\n  }\n\n  var font = options.font;\n\n  if (!font || font === \"mathnormal\") {\n    return null;\n  }\n\n  var mode = group.mode;\n\n  if (font === \"mathit\") {\n    return \"italic\";\n  } else if (font === \"boldsymbol\") {\n    return \"bold-italic\";\n  } else if (font === \"mathbf\") {\n    return \"bold\";\n  } else if (font === \"mathbb\") {\n    return \"double-struck\";\n  } else if (font === \"mathfrak\") {\n    return \"fraktur\";\n  } else if (font === \"mathscr\" || font === \"mathcal\") {\n    // MathML makes no distinction between script and caligrahpic\n    return \"script\";\n  } else if (font === \"mathsf\") {\n    return \"sans-serif\";\n  } else if (font === \"mathtt\") {\n    return \"monospace\";\n  }\n\n  var text = group.text;\n\n  if (utils.contains([\"\\\\imath\", \"\\\\jmath\"], text)) {\n    return null;\n  }\n\n  if (src_symbols[mode][text] && src_symbols[mode][text].replace) {\n    text = src_symbols[mode][text].replace;\n  }\n\n  var fontName = buildCommon.fontMap[font].fontName;\n\n  if (getCharacterMetrics(text, fontName, mode)) {\n    return buildCommon.fontMap[font].variant;\n  }\n\n  return null;\n};\n/**\n * Takes a list of nodes, builds them, and returns a list of the generated\n * MathML nodes.  Also combine consecutive <mtext> outputs into a single\n * <mtext> tag.\n */\n\nvar buildMathML_buildExpression = function buildExpression(expression, options, isOrdgroup) {\n  if (expression.length === 1) {\n    var group = buildMathML_buildGroup(expression[0], options);\n\n    if (isOrdgroup && group instanceof mathMLTree_MathNode && group.type === \"mo\") {\n      // When TeX writers want to suppress spacing on an operator,\n      // they often put the operator by itself inside braces.\n      group.setAttribute(\"lspace\", \"0em\");\n      group.setAttribute(\"rspace\", \"0em\");\n    }\n\n    return [group];\n  }\n\n  var groups = [];\n  var lastGroup;\n\n  for (var i = 0; i < expression.length; i++) {\n    var _group = buildMathML_buildGroup(expression[i], options);\n\n    if (_group instanceof mathMLTree_MathNode && lastGroup instanceof mathMLTree_MathNode) {\n      // Concatenate adjacent <mtext>s\n      if (_group.type === 'mtext' && lastGroup.type === 'mtext' && _group.getAttribute('mathvariant') === lastGroup.getAttribute('mathvariant')) {\n        var _lastGroup$children;\n\n        (_lastGroup$children = lastGroup.children).push.apply(_lastGroup$children, _group.children);\n\n        continue; // Concatenate adjacent <mn>s\n      } else if (_group.type === 'mn' && lastGroup.type === 'mn') {\n        var _lastGroup$children2;\n\n        (_lastGroup$children2 = lastGroup.children).push.apply(_lastGroup$children2, _group.children);\n\n        continue; // Concatenate <mn>...</mn> followed by <mi>.</mi>\n      } else if (_group.type === 'mi' && _group.children.length === 1 && lastGroup.type === 'mn') {\n        var child = _group.children[0];\n\n        if (child instanceof mathMLTree_TextNode && child.text === '.') {\n          var _lastGroup$children3;\n\n          (_lastGroup$children3 = lastGroup.children).push.apply(_lastGroup$children3, _group.children);\n\n          continue;\n        }\n      } else if (lastGroup.type === 'mi' && lastGroup.children.length === 1) {\n        var lastChild = lastGroup.children[0];\n\n        if (lastChild instanceof mathMLTree_TextNode && lastChild.text === \"\\u0338\" && (_group.type === 'mo' || _group.type === 'mi' || _group.type === 'mn')) {\n          var _child = _group.children[0];\n\n          if (_child instanceof mathMLTree_TextNode && _child.text.length > 0) {\n            // Overlay with combining character long solidus\n            _child.text = _child.text.slice(0, 1) + \"\\u0338\" + _child.text.slice(1);\n            groups.pop();\n          }\n        }\n      }\n    }\n\n    groups.push(_group);\n    lastGroup = _group;\n  }\n\n  return groups;\n};\n/**\n * Equivalent to buildExpression, but wraps the elements in an <mrow>\n * if there's more than one.  Returns a single node instead of an array.\n */\n\nvar buildExpressionRow = function buildExpressionRow(expression, options, isOrdgroup) {\n  return buildMathML_makeRow(buildMathML_buildExpression(expression, options, isOrdgroup));\n};\n/**\n * Takes a group from the parser and calls the appropriate groupBuilders function\n * on it to produce a MathML node.\n */\n\nvar buildMathML_buildGroup = function buildGroup(group, options) {\n  if (!group) {\n    return new mathMLTree.MathNode(\"mrow\");\n  }\n\n  if (_mathmlGroupBuilders[group.type]) {\n    // Call the groupBuilders function\n    var result = _mathmlGroupBuilders[group.type](group, options);\n    return result;\n  } else {\n    throw new src_ParseError(\"Got group of unknown type: '\" + group.type + \"'\");\n  }\n};\n/**\n * Takes a full parse tree and settings and builds a MathML representation of\n * it. In particular, we put the elements from building the parse tree into a\n * <semantics> tag so we can also include that TeX source as an annotation.\n *\n * Note that we actually return a domTree element with a `<math>` inside it so\n * we can do appropriate styling.\n */\n\nfunction buildMathML(tree, texExpression, options, forMathmlOnly) {\n  var expression = buildMathML_buildExpression(tree, options); // Wrap up the expression in an mrow so it is presented in the semantics\n  // tag correctly, unless it's a single <mrow> or <mtable>.\n\n  var wrapper;\n\n  if (expression.length === 1 && expression[0] instanceof mathMLTree_MathNode && utils.contains([\"mrow\", \"mtable\"], expression[0].type)) {\n    wrapper = expression[0];\n  } else {\n    wrapper = new mathMLTree.MathNode(\"mrow\", expression);\n  } // Build a TeX annotation of the source\n\n\n  var annotation = new mathMLTree.MathNode(\"annotation\", [new mathMLTree.TextNode(texExpression)]);\n  annotation.setAttribute(\"encoding\", \"application/x-tex\");\n  var semantics = new mathMLTree.MathNode(\"semantics\", [wrapper, annotation]);\n  var math = new mathMLTree.MathNode(\"math\", [semantics]);\n  math.setAttribute(\"xmlns\", \"http://www.w3.org/1998/Math/MathML\"); // You can't style <math> nodes, so we wrap the node in a span.\n  // NOTE: The span class is not typed to have <math> nodes as children, and\n  // we don't want to make the children type more generic since the children\n  // of span are expected to have more fields in `buildHtml` contexts.\n\n  var wrapperClass = forMathmlOnly ? \"katex\" : \"katex-mathml\"; // $FlowFixMe\n\n  return buildCommon.makeSpan([wrapperClass], [math]);\n}\n// CONCATENATED MODULE: ./src/buildTree.js\n\n\n\n\n\n\n\nvar buildTree_optionsFromSettings = function optionsFromSettings(settings) {\n  return new src_Options({\n    style: settings.displayMode ? src_Style.DISPLAY : src_Style.TEXT,\n    maxSize: settings.maxSize,\n    minRuleThickness: settings.minRuleThickness\n  });\n};\n\nvar buildTree_displayWrap = function displayWrap(node, settings) {\n  if (settings.displayMode) {\n    var classes = [\"katex-display\"];\n\n    if (settings.leqno) {\n      classes.push(\"leqno\");\n    }\n\n    if (settings.fleqn) {\n      classes.push(\"fleqn\");\n    }\n\n    node = buildCommon.makeSpan(classes, [node]);\n  }\n\n  return node;\n};\n\nvar buildTree_buildTree = function buildTree(tree, expression, settings) {\n  var options = buildTree_optionsFromSettings(settings);\n  var katexNode;\n\n  if (settings.output === \"mathml\") {\n    return buildMathML(tree, expression, options, true);\n  } else if (settings.output === \"html\") {\n    var htmlNode = buildHTML(tree, options);\n    katexNode = buildCommon.makeSpan([\"katex\"], [htmlNode]);\n  } else {\n    var mathMLNode = buildMathML(tree, expression, options, false);\n\n    var _htmlNode = buildHTML(tree, options);\n\n    katexNode = buildCommon.makeSpan([\"katex\"], [mathMLNode, _htmlNode]);\n  }\n\n  return buildTree_displayWrap(katexNode, settings);\n};\nvar buildTree_buildHTMLTree = function buildHTMLTree(tree, expression, settings) {\n  var options = buildTree_optionsFromSettings(settings);\n  var htmlNode = buildHTML(tree, options);\n  var katexNode = buildCommon.makeSpan([\"katex\"], [htmlNode]);\n  return buildTree_displayWrap(katexNode, settings);\n};\n/* harmony default export */ var src_buildTree = (buildTree_buildTree);\n// CONCATENATED MODULE: ./src/stretchy.js\n/**\n * This file provides support to buildMathML.js and buildHTML.js\n * for stretchy wide elements rendered from SVG files\n * and other CSS trickery.\n */\n\n\n\n\nvar stretchyCodePoint = {\n  widehat: \"^\",\n  widecheck: \"ˇ\",\n  widetilde: \"~\",\n  utilde: \"~\",\n  overleftarrow: \"\\u2190\",\n  underleftarrow: \"\\u2190\",\n  xleftarrow: \"\\u2190\",\n  overrightarrow: \"\\u2192\",\n  underrightarrow: \"\\u2192\",\n  xrightarrow: \"\\u2192\",\n  underbrace: \"\\u23DF\",\n  overbrace: \"\\u23DE\",\n  overgroup: \"\\u23E0\",\n  undergroup: \"\\u23E1\",\n  overleftrightarrow: \"\\u2194\",\n  underleftrightarrow: \"\\u2194\",\n  xleftrightarrow: \"\\u2194\",\n  Overrightarrow: \"\\u21D2\",\n  xRightarrow: \"\\u21D2\",\n  overleftharpoon: \"\\u21BC\",\n  xleftharpoonup: \"\\u21BC\",\n  overrightharpoon: \"\\u21C0\",\n  xrightharpoonup: \"\\u21C0\",\n  xLeftarrow: \"\\u21D0\",\n  xLeftrightarrow: \"\\u21D4\",\n  xhookleftarrow: \"\\u21A9\",\n  xhookrightarrow: \"\\u21AA\",\n  xmapsto: \"\\u21A6\",\n  xrightharpoondown: \"\\u21C1\",\n  xleftharpoondown: \"\\u21BD\",\n  xrightleftharpoons: \"\\u21CC\",\n  xleftrightharpoons: \"\\u21CB\",\n  xtwoheadleftarrow: \"\\u219E\",\n  xtwoheadrightarrow: \"\\u21A0\",\n  xlongequal: \"=\",\n  xtofrom: \"\\u21C4\",\n  xrightleftarrows: \"\\u21C4\",\n  xrightequilibrium: \"\\u21CC\",\n  // Not a perfect match.\n  xleftequilibrium: \"\\u21CB\" // None better available.\n\n};\n\nvar stretchy_mathMLnode = function mathMLnode(label) {\n  var node = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(stretchyCodePoint[label.substr(1)])]);\n  node.setAttribute(\"stretchy\", \"true\");\n  return node;\n}; // Many of the KaTeX SVG images have been adapted from glyphs in KaTeX fonts.\n// Copyright (c) 2009-2010, Design Science, Inc. (<www.mathjax.org>)\n// Copyright (c) 2014-2017 Khan Academy (<www.khanacademy.org>)\n// Licensed under the SIL Open Font License, Version 1.1.\n// See \\nhttp://scripts.sil.org/OFL\n// Very Long SVGs\n//    Many of the KaTeX stretchy wide elements use a long SVG image and an\n//    overflow: hidden tactic to achieve a stretchy image while avoiding\n//    distortion of arrowheads or brace corners.\n//    The SVG typically contains a very long (400 em) arrow.\n//    The SVG is in a container span that has overflow: hidden, so the span\n//    acts like a window that exposes only part of the  SVG.\n//    The SVG always has a longer, thinner aspect ratio than the container span.\n//    After the SVG fills 100% of the height of the container span,\n//    there is a long arrow shaft left over. That left-over shaft is not shown.\n//    Instead, it is sliced off because the span's CSS has overflow: hidden.\n//    Thus, the reader sees an arrow that matches the subject matter width\n//    without distortion.\n//    Some functions, such as \\cancel, need to vary their aspect ratio. These\n//    functions do not get the overflow SVG treatment.\n// Second Brush Stroke\n//    Low resolution monitors struggle to display images in fine detail.\n//    So browsers apply anti-aliasing. A long straight arrow shaft therefore\n//    will sometimes appear as if it has a blurred edge.\n//    To mitigate this, these SVG files contain a second \"brush-stroke\" on the\n//    arrow shafts. That is, a second long thin rectangular SVG path has been\n//    written directly on top of each arrow shaft. This reinforcement causes\n//    some of the screen pixels to display as black instead of the anti-aliased\n//    gray pixel that a  single path would generate. So we get arrow shafts\n//    whose edges appear to be sharper.\n// In the katexImagesData object just below, the dimensions all\n// correspond to path geometry inside the relevant SVG.\n// For example, \\overrightarrow uses the same arrowhead as glyph U+2192\n// from the KaTeX Main font. The scaling factor is 1000.\n// That is, inside the font, that arrowhead is 522 units tall, which\n// corresponds to 0.522 em inside the document.\n\n\nvar katexImagesData = {\n  //   path(s), minWidth, height, align\n  overrightarrow: [[\"rightarrow\"], 0.888, 522, \"xMaxYMin\"],\n  overleftarrow: [[\"leftarrow\"], 0.888, 522, \"xMinYMin\"],\n  underrightarrow: [[\"rightarrow\"], 0.888, 522, \"xMaxYMin\"],\n  underleftarrow: [[\"leftarrow\"], 0.888, 522, \"xMinYMin\"],\n  xrightarrow: [[\"rightarrow\"], 1.469, 522, \"xMaxYMin\"],\n  xleftarrow: [[\"leftarrow\"], 1.469, 522, \"xMinYMin\"],\n  Overrightarrow: [[\"doublerightarrow\"], 0.888, 560, \"xMaxYMin\"],\n  xRightarrow: [[\"doublerightarrow\"], 1.526, 560, \"xMaxYMin\"],\n  xLeftarrow: [[\"doubleleftarrow\"], 1.526, 560, \"xMinYMin\"],\n  overleftharpoon: [[\"leftharpoon\"], 0.888, 522, \"xMinYMin\"],\n  xleftharpoonup: [[\"leftharpoon\"], 0.888, 522, \"xMinYMin\"],\n  xleftharpoondown: [[\"leftharpoondown\"], 0.888, 522, \"xMinYMin\"],\n  overrightharpoon: [[\"rightharpoon\"], 0.888, 522, \"xMaxYMin\"],\n  xrightharpoonup: [[\"rightharpoon\"], 0.888, 522, \"xMaxYMin\"],\n  xrightharpoondown: [[\"rightharpoondown\"], 0.888, 522, \"xMaxYMin\"],\n  xlongequal: [[\"longequal\"], 0.888, 334, \"xMinYMin\"],\n  xtwoheadleftarrow: [[\"twoheadleftarrow\"], 0.888, 334, \"xMinYMin\"],\n  xtwoheadrightarrow: [[\"twoheadrightarrow\"], 0.888, 334, \"xMaxYMin\"],\n  overleftrightarrow: [[\"leftarrow\", \"rightarrow\"], 0.888, 522],\n  overbrace: [[\"leftbrace\", \"midbrace\", \"rightbrace\"], 1.6, 548],\n  underbrace: [[\"leftbraceunder\", \"midbraceunder\", \"rightbraceunder\"], 1.6, 548],\n  underleftrightarrow: [[\"leftarrow\", \"rightarrow\"], 0.888, 522],\n  xleftrightarrow: [[\"leftarrow\", \"rightarrow\"], 1.75, 522],\n  xLeftrightarrow: [[\"doubleleftarrow\", \"doublerightarrow\"], 1.75, 560],\n  xrightleftharpoons: [[\"leftharpoondownplus\", \"rightharpoonplus\"], 1.75, 716],\n  xleftrightharpoons: [[\"leftharpoonplus\", \"rightharpoondownplus\"], 1.75, 716],\n  xhookleftarrow: [[\"leftarrow\", \"righthook\"], 1.08, 522],\n  xhookrightarrow: [[\"lefthook\", \"rightarrow\"], 1.08, 522],\n  overlinesegment: [[\"leftlinesegment\", \"rightlinesegment\"], 0.888, 522],\n  underlinesegment: [[\"leftlinesegment\", \"rightlinesegment\"], 0.888, 522],\n  overgroup: [[\"leftgroup\", \"rightgroup\"], 0.888, 342],\n  undergroup: [[\"leftgroupunder\", \"rightgroupunder\"], 0.888, 342],\n  xmapsto: [[\"leftmapsto\", \"rightarrow\"], 1.5, 522],\n  xtofrom: [[\"leftToFrom\", \"rightToFrom\"], 1.75, 528],\n  // The next three arrows are from the mhchem package.\n  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the\n  // document as \\xrightarrow or \\xrightleftharpoons. Those have\n  // min-length = 1.75em, so we set min-length on these next three to match.\n  xrightleftarrows: [[\"baraboveleftarrow\", \"rightarrowabovebar\"], 1.75, 901],\n  xrightequilibrium: [[\"baraboveshortleftharpoon\", \"rightharpoonaboveshortbar\"], 1.75, 716],\n  xleftequilibrium: [[\"shortbaraboveleftharpoon\", \"shortrightharpoonabovebar\"], 1.75, 716]\n};\n\nvar groupLength = function groupLength(arg) {\n  if (arg.type === \"ordgroup\") {\n    return arg.body.length;\n  } else {\n    return 1;\n  }\n};\n\nvar stretchy_svgSpan = function svgSpan(group, options) {\n  // Create a span with inline SVG for the element.\n  function buildSvgSpan_() {\n    var viewBoxWidth = 400000; // default\n\n    var label = group.label.substr(1);\n\n    if (utils.contains([\"widehat\", \"widecheck\", \"widetilde\", \"utilde\"], label)) {\n      // Each type in the `if` statement corresponds to one of the ParseNode\n      // types below. This narrowing is required to access `grp.base`.\n      var grp = group; // There are four SVG images available for each function.\n      // Choose a taller image when there are more characters.\n\n      var numChars = groupLength(grp.base);\n      var viewBoxHeight;\n      var pathName;\n\n      var _height;\n\n      if (numChars > 5) {\n        if (label === \"widehat\" || label === \"widecheck\") {\n          viewBoxHeight = 420;\n          viewBoxWidth = 2364;\n          _height = 0.42;\n          pathName = label + \"4\";\n        } else {\n          viewBoxHeight = 312;\n          viewBoxWidth = 2340;\n          _height = 0.34;\n          pathName = \"tilde4\";\n        }\n      } else {\n        var imgIndex = [1, 1, 2, 2, 3, 3][numChars];\n\n        if (label === \"widehat\" || label === \"widecheck\") {\n          viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];\n          viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];\n          _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];\n          pathName = label + imgIndex;\n        } else {\n          viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];\n          viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];\n          _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];\n          pathName = \"tilde\" + imgIndex;\n        }\n      }\n\n      var path = new domTree_PathNode(pathName);\n      var svgNode = new SvgNode([path], {\n        \"width\": \"100%\",\n        \"height\": _height + \"em\",\n        \"viewBox\": \"0 0 \" + viewBoxWidth + \" \" + viewBoxHeight,\n        \"preserveAspectRatio\": \"none\"\n      });\n      return {\n        span: buildCommon.makeSvgSpan([], [svgNode], options),\n        minWidth: 0,\n        height: _height\n      };\n    } else {\n      var spans = [];\n      var data = katexImagesData[label];\n      var paths = data[0],\n          _minWidth = data[1],\n          _viewBoxHeight = data[2];\n\n      var _height2 = _viewBoxHeight / 1000;\n\n      var numSvgChildren = paths.length;\n      var widthClasses;\n      var aligns;\n\n      if (numSvgChildren === 1) {\n        // $FlowFixMe: All these cases must be of the 4-tuple type.\n        var align1 = data[3];\n        widthClasses = [\"hide-tail\"];\n        aligns = [align1];\n      } else if (numSvgChildren === 2) {\n        widthClasses = [\"halfarrow-left\", \"halfarrow-right\"];\n        aligns = [\"xMinYMin\", \"xMaxYMin\"];\n      } else if (numSvgChildren === 3) {\n        widthClasses = [\"brace-left\", \"brace-center\", \"brace-right\"];\n        aligns = [\"xMinYMin\", \"xMidYMin\", \"xMaxYMin\"];\n      } else {\n        throw new Error(\"Correct katexImagesData or update code here to support\\n                    \" + numSvgChildren + \" children.\");\n      }\n\n      for (var i = 0; i < numSvgChildren; i++) {\n        var _path = new domTree_PathNode(paths[i]);\n\n        var _svgNode = new SvgNode([_path], {\n          \"width\": \"400em\",\n          \"height\": _height2 + \"em\",\n          \"viewBox\": \"0 0 \" + viewBoxWidth + \" \" + _viewBoxHeight,\n          \"preserveAspectRatio\": aligns[i] + \" slice\"\n        });\n\n        var _span = buildCommon.makeSvgSpan([widthClasses[i]], [_svgNode], options);\n\n        if (numSvgChildren === 1) {\n          return {\n            span: _span,\n            minWidth: _minWidth,\n            height: _height2\n          };\n        } else {\n          _span.style.height = _height2 + \"em\";\n          spans.push(_span);\n        }\n      }\n\n      return {\n        span: buildCommon.makeSpan([\"stretchy\"], spans, options),\n        minWidth: _minWidth,\n        height: _height2\n      };\n    }\n  } // buildSvgSpan_()\n\n\n  var _buildSvgSpan_ = buildSvgSpan_(),\n      span = _buildSvgSpan_.span,\n      minWidth = _buildSvgSpan_.minWidth,\n      height = _buildSvgSpan_.height; // Note that we are returning span.depth = 0.\n  // Any adjustments relative to the baseline must be done in buildHTML.\n\n\n  span.height = height;\n  span.style.height = height + \"em\";\n\n  if (minWidth > 0) {\n    span.style.minWidth = minWidth + \"em\";\n  }\n\n  return span;\n};\n\nvar stretchy_encloseSpan = function encloseSpan(inner, label, pad, options) {\n  // Return an image span for \\cancel, \\bcancel, \\xcancel, or \\fbox\n  var img;\n  var totalHeight = inner.height + inner.depth + 2 * pad;\n\n  if (/fbox|color/.test(label)) {\n    img = buildCommon.makeSpan([\"stretchy\", label], [], options);\n\n    if (label === \"fbox\") {\n      var color = options.color && options.getColor();\n\n      if (color) {\n        img.style.borderColor = color;\n      }\n    }\n  } else {\n    // \\cancel, \\bcancel, or \\xcancel\n    // Since \\cancel's SVG is inline and it omits the viewBox attribute,\n    // its stroke-width will not vary with span area.\n    var lines = [];\n\n    if (/^[bx]cancel$/.test(label)) {\n      lines.push(new LineNode({\n        \"x1\": \"0\",\n        \"y1\": \"0\",\n        \"x2\": \"100%\",\n        \"y2\": \"100%\",\n        \"stroke-width\": \"0.046em\"\n      }));\n    }\n\n    if (/^x?cancel$/.test(label)) {\n      lines.push(new LineNode({\n        \"x1\": \"0\",\n        \"y1\": \"100%\",\n        \"x2\": \"100%\",\n        \"y2\": \"0\",\n        \"stroke-width\": \"0.046em\"\n      }));\n    }\n\n    var svgNode = new SvgNode(lines, {\n      \"width\": \"100%\",\n      \"height\": totalHeight + \"em\"\n    });\n    img = buildCommon.makeSvgSpan([], [svgNode], options);\n  }\n\n  img.height = totalHeight;\n  img.style.height = totalHeight + \"em\";\n  return img;\n};\n\n/* harmony default export */ var stretchy = ({\n  encloseSpan: stretchy_encloseSpan,\n  mathMLnode: stretchy_mathMLnode,\n  svgSpan: stretchy_svgSpan\n});\n// CONCATENATED MODULE: ./src/functions/accent.js\n\n\n\n\n\n\n\n\n\n// NOTE: Unlike most `htmlBuilder`s, this one handles not only \"accent\", but\nvar accent_htmlBuilder = function htmlBuilder(grp, options) {\n  // Accents are handled in the TeXbook pg. 443, rule 12.\n  var base;\n  var group;\n  var supSub = checkNodeType(grp, \"supsub\");\n  var supSubGroup;\n\n  if (supSub) {\n    // If our base is a character box, and we have superscripts and\n    // subscripts, the supsub will defer to us. In particular, we want\n    // to attach the superscripts and subscripts to the inner body (so\n    // that the position of the superscripts and subscripts won't be\n    // affected by the height of the accent). We accomplish this by\n    // sticking the base of the accent into the base of the supsub, and\n    // rendering that, while keeping track of where the accent is.\n    // The real accent group is the base of the supsub group\n    group = assertNodeType(supSub.base, \"accent\"); // The character box is the base of the accent group\n\n    base = group.base; // Stick the character box into the base of the supsub group\n\n    supSub.base = base; // Rerender the supsub group with its new base, and store that\n    // result.\n\n    supSubGroup = assertSpan(buildHTML_buildGroup(supSub, options)); // reset original base\n\n    supSub.base = group;\n  } else {\n    group = assertNodeType(grp, \"accent\");\n    base = group.base;\n  } // Build the base group\n\n\n  var body = buildHTML_buildGroup(base, options.havingCrampedStyle()); // Does the accent need to shift for the skew of a character?\n\n  var mustShift = group.isShifty && utils.isCharacterBox(base); // Calculate the skew of the accent. This is based on the line \"If the\n  // nucleus is not a single character, let s = 0; otherwise set s to the\n  // kern amount for the nucleus followed by the \\skewchar of its font.\"\n  // Note that our skew metrics are just the kern between each character\n  // and the skewchar.\n\n  var skew = 0;\n\n  if (mustShift) {\n    // If the base is a character box, then we want the skew of the\n    // innermost character. To do that, we find the innermost character:\n    var baseChar = utils.getBaseElem(base); // Then, we render its group to get the symbol inside it\n\n    var baseGroup = buildHTML_buildGroup(baseChar, options.havingCrampedStyle()); // Finally, we pull the skew off of the symbol.\n\n    skew = assertSymbolDomNode(baseGroup).skew; // Note that we now throw away baseGroup, because the layers we\n    // removed with getBaseElem might contain things like \\color which\n    // we can't get rid of.\n    // TODO(emily): Find a better way to get the skew\n  } // calculate the amount of space between the body and the accent\n\n\n  var clearance = Math.min(body.height, options.fontMetrics().xHeight); // Build the accent\n\n  var accentBody;\n\n  if (!group.isStretchy) {\n    var accent;\n    var width;\n\n    if (group.label === \"\\\\vec\") {\n      // Before version 0.9, \\vec used the combining font glyph U+20D7.\n      // But browsers, especially Safari, are not consistent in how they\n      // render combining characters when not preceded by a character.\n      // So now we use an SVG.\n      // If Safari reforms, we should consider reverting to the glyph.\n      accent = buildCommon.staticSvg(\"vec\", options);\n      width = buildCommon.svgData.vec[1];\n    } else {\n      accent = buildCommon.makeOrd({\n        mode: group.mode,\n        text: group.label\n      }, options, \"textord\");\n      accent = assertSymbolDomNode(accent); // Remove the italic correction of the accent, because it only serves to\n      // shift the accent over to a place we don't want.\n\n      accent.italic = 0;\n      width = accent.width;\n    }\n\n    accentBody = buildCommon.makeSpan([\"accent-body\"], [accent]); // \"Full\" accents expand the width of the resulting symbol to be\n    // at least the width of the accent, and overlap directly onto the\n    // character without any vertical offset.\n\n    var accentFull = group.label === \"\\\\textcircled\";\n\n    if (accentFull) {\n      accentBody.classes.push('accent-full');\n      clearance = body.height;\n    } // Shift the accent over by the skew.\n\n\n    var left = skew; // CSS defines `.katex .accent .accent-body:not(.accent-full) { width: 0 }`\n    // so that the accent doesn't contribute to the bounding box.\n    // We need to shift the character by its width (effectively half\n    // its width) to compensate.\n\n    if (!accentFull) {\n      left -= width / 2;\n    }\n\n    accentBody.style.left = left + \"em\"; // \\textcircled uses the \\bigcirc glyph, so it needs some\n    // vertical adjustment to match LaTeX.\n\n    if (group.label === \"\\\\textcircled\") {\n      accentBody.style.top = \".2em\";\n    }\n\n    accentBody = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: body\n      }, {\n        type: \"kern\",\n        size: -clearance\n      }, {\n        type: \"elem\",\n        elem: accentBody\n      }]\n    }, options);\n  } else {\n    accentBody = stretchy.svgSpan(group, options);\n    accentBody = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: body\n      }, {\n        type: \"elem\",\n        elem: accentBody,\n        wrapperClasses: [\"svg-align\"],\n        wrapperStyle: skew > 0 ? {\n          width: \"calc(100% - \" + 2 * skew + \"em)\",\n          marginLeft: 2 * skew + \"em\"\n        } : undefined\n      }]\n    }, options);\n  }\n\n  var accentWrap = buildCommon.makeSpan([\"mord\", \"accent\"], [accentBody], options);\n\n  if (supSubGroup) {\n    // Here, we replace the \"base\" child of the supsub with our newly\n    // generated accent.\n    supSubGroup.children[0] = accentWrap; // Since we don't rerun the height calculation after replacing the\n    // accent, we manually recalculate height.\n\n    supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height); // Accents should always be ords, even when their innards are not.\n\n    supSubGroup.classes[0] = \"mord\";\n    return supSubGroup;\n  } else {\n    return accentWrap;\n  }\n};\n\nvar accent_mathmlBuilder = function mathmlBuilder(group, options) {\n  var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode(\"mo\", [buildMathML_makeText(group.label, group.mode)]);\n  var node = new mathMLTree.MathNode(\"mover\", [buildMathML_buildGroup(group.base, options), accentNode]);\n  node.setAttribute(\"accent\", \"true\");\n  return node;\n};\n\nvar NON_STRETCHY_ACCENT_REGEX = new RegExp([\"\\\\acute\", \"\\\\grave\", \"\\\\ddot\", \"\\\\tilde\", \"\\\\bar\", \"\\\\breve\", \"\\\\check\", \"\\\\hat\", \"\\\\vec\", \"\\\\dot\", \"\\\\mathring\"].map(function (accent) {\n  return \"\\\\\" + accent;\n}).join(\"|\")); // Accents\n\ndefineFunction({\n  type: \"accent\",\n  names: [\"\\\\acute\", \"\\\\grave\", \"\\\\ddot\", \"\\\\tilde\", \"\\\\bar\", \"\\\\breve\", \"\\\\check\", \"\\\\hat\", \"\\\\vec\", \"\\\\dot\", \"\\\\mathring\", \"\\\\widecheck\", \"\\\\widehat\", \"\\\\widetilde\", \"\\\\overrightarrow\", \"\\\\overleftarrow\", \"\\\\Overrightarrow\", \"\\\\overleftrightarrow\", \"\\\\overgroup\", \"\\\\overlinesegment\", \"\\\\overleftharpoon\", \"\\\\overrightharpoon\"],\n  props: {\n    numArgs: 1\n  },\n  handler: function handler(context, args) {\n    var base = args[0];\n    var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);\n    var isShifty = !isStretchy || context.funcName === \"\\\\widehat\" || context.funcName === \"\\\\widetilde\" || context.funcName === \"\\\\widecheck\";\n    return {\n      type: \"accent\",\n      mode: context.parser.mode,\n      label: context.funcName,\n      isStretchy: isStretchy,\n      isShifty: isShifty,\n      base: base\n    };\n  },\n  htmlBuilder: accent_htmlBuilder,\n  mathmlBuilder: accent_mathmlBuilder\n}); // Text-mode accents\n\ndefineFunction({\n  type: \"accent\",\n  names: [\"\\\\'\", \"\\\\`\", \"\\\\^\", \"\\\\~\", \"\\\\=\", \"\\\\u\", \"\\\\.\", '\\\\\"', \"\\\\r\", \"\\\\H\", \"\\\\v\", \"\\\\textcircled\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true,\n    allowedInMath: false\n  },\n  handler: function handler(context, args) {\n    var base = args[0];\n    return {\n      type: \"accent\",\n      mode: context.parser.mode,\n      label: context.funcName,\n      isStretchy: false,\n      isShifty: true,\n      base: base\n    };\n  },\n  htmlBuilder: accent_htmlBuilder,\n  mathmlBuilder: accent_mathmlBuilder\n});\n// CONCATENATED MODULE: ./src/functions/accentunder.js\n// Horizontal overlap functions\n\n\n\n\n\n\ndefineFunction({\n  type: \"accentUnder\",\n  names: [\"\\\\underleftarrow\", \"\\\\underrightarrow\", \"\\\\underleftrightarrow\", \"\\\\undergroup\", \"\\\\underlinesegment\", \"\\\\utilde\"],\n  props: {\n    numArgs: 1\n  },\n  handler: function handler(_ref, args) {\n    var parser = _ref.parser,\n        funcName = _ref.funcName;\n    var base = args[0];\n    return {\n      type: \"accentUnder\",\n      mode: parser.mode,\n      label: funcName,\n      base: base\n    };\n  },\n  htmlBuilder: function htmlBuilder(group, options) {\n    // Treat under accents much like underlines.\n    var innerGroup = buildHTML_buildGroup(group.base, options);\n    var accentBody = stretchy.svgSpan(group, options);\n    var kern = group.label === \"\\\\utilde\" ? 0.12 : 0; // Generate the vlist, with the appropriate kerns\n\n    var vlist = buildCommon.makeVList({\n      positionType: \"bottom\",\n      positionData: accentBody.height + kern,\n      children: [{\n        type: \"elem\",\n        elem: accentBody,\n        wrapperClasses: [\"svg-align\"]\n      }, {\n        type: \"kern\",\n        size: kern\n      }, {\n        type: \"elem\",\n        elem: innerGroup\n      }]\n    }, options);\n    return buildCommon.makeSpan([\"mord\", \"accentunder\"], [vlist], options);\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var accentNode = stretchy.mathMLnode(group.label);\n    var node = new mathMLTree.MathNode(\"munder\", [buildMathML_buildGroup(group.base, options), accentNode]);\n    node.setAttribute(\"accentunder\", \"true\");\n    return node;\n  }\n});\n// CONCATENATED MODULE: ./src/functions/arrow.js\n\n\n\n\n\n\n\n// Helper function\nvar arrow_paddedNode = function paddedNode(group) {\n  var node = new mathMLTree.MathNode(\"mpadded\", group ? [group] : []);\n  node.setAttribute(\"width\", \"+0.6em\");\n  node.setAttribute(\"lspace\", \"0.3em\");\n  return node;\n}; // Stretchy arrows with an optional argument\n\n\ndefineFunction({\n  type: \"xArrow\",\n  names: [\"\\\\xleftarrow\", \"\\\\xrightarrow\", \"\\\\xLeftarrow\", \"\\\\xRightarrow\", \"\\\\xleftrightarrow\", \"\\\\xLeftrightarrow\", \"\\\\xhookleftarrow\", \"\\\\xhookrightarrow\", \"\\\\xmapsto\", \"\\\\xrightharpoondown\", \"\\\\xrightharpoonup\", \"\\\\xleftharpoondown\", \"\\\\xleftharpoonup\", \"\\\\xrightleftharpoons\", \"\\\\xleftrightharpoons\", \"\\\\xlongequal\", \"\\\\xtwoheadrightarrow\", \"\\\\xtwoheadleftarrow\", \"\\\\xtofrom\", // The next 3 functions are here to support the mhchem extension.\n  // Direct use of these functions is discouraged and may break someday.\n  \"\\\\xrightleftarrows\", \"\\\\xrightequilibrium\", \"\\\\xleftequilibrium\"],\n  props: {\n    numArgs: 1,\n    numOptionalArgs: 1\n  },\n  handler: function handler(_ref, args, optArgs) {\n    var parser = _ref.parser,\n        funcName = _ref.funcName;\n    return {\n      type: \"xArrow\",\n      mode: parser.mode,\n      label: funcName,\n      body: args[0],\n      below: optArgs[0]\n    };\n  },\n  // Flow is unable to correctly infer the type of `group`, even though it's\n  // unamibiguously determined from the passed-in `type` above.\n  htmlBuilder: function htmlBuilder(group, options) {\n    var style = options.style; // Build the argument groups in the appropriate style.\n    // Ref: amsmath.dtx:   \\hbox{$\\scriptstyle\\mkern#3mu{#6}\\mkern#4mu$}%\n    // Some groups can return document fragments.  Handle those by wrapping\n    // them in a span.\n\n    var newOptions = options.havingStyle(style.sup());\n    var upperGroup = buildCommon.wrapFragment(buildHTML_buildGroup(group.body, newOptions, options), options);\n    upperGroup.classes.push(\"x-arrow-pad\");\n    var lowerGroup;\n\n    if (group.below) {\n      // Build the lower group\n      newOptions = options.havingStyle(style.sub());\n      lowerGroup = buildCommon.wrapFragment(buildHTML_buildGroup(group.below, newOptions, options), options);\n      lowerGroup.classes.push(\"x-arrow-pad\");\n    }\n\n    var arrowBody = stretchy.svgSpan(group, options); // Re shift: Note that stretchy.svgSpan returned arrowBody.depth = 0.\n    // The point we want on the math axis is at 0.5 * arrowBody.height.\n\n    var arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height; // 2 mu kern. Ref: amsmath.dtx: #7\\if0#2\\else\\mkern#2mu\\fi\n\n    var upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111; // 0.111 em = 2 mu\n\n    if (upperGroup.depth > 0.25 || group.label === \"\\\\xleftequilibrium\") {\n      upperShift -= upperGroup.depth; // shift up if depth encroaches\n    } // Generate the vlist\n\n\n    var vlist;\n\n    if (lowerGroup) {\n      var lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;\n      vlist = buildCommon.makeVList({\n        positionType: \"individualShift\",\n        children: [{\n          type: \"elem\",\n          elem: upperGroup,\n          shift: upperShift\n        }, {\n          type: \"elem\",\n          elem: arrowBody,\n          shift: arrowShift\n        }, {\n          type: \"elem\",\n          elem: lowerGroup,\n          shift: lowerShift\n        }]\n      }, options);\n    } else {\n      vlist = buildCommon.makeVList({\n        positionType: \"individualShift\",\n        children: [{\n          type: \"elem\",\n          elem: upperGroup,\n          shift: upperShift\n        }, {\n          type: \"elem\",\n          elem: arrowBody,\n          shift: arrowShift\n        }]\n      }, options);\n    } // $FlowFixMe: Replace this with passing \"svg-align\" into makeVList.\n\n\n    vlist.children[0].children[0].children[1].classes.push(\"svg-align\");\n    return buildCommon.makeSpan([\"mrel\", \"x-arrow\"], [vlist], options);\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var arrowNode = stretchy.mathMLnode(group.label);\n    var node;\n\n    if (group.body) {\n      var upperNode = arrow_paddedNode(buildMathML_buildGroup(group.body, options));\n\n      if (group.below) {\n        var lowerNode = arrow_paddedNode(buildMathML_buildGroup(group.below, options));\n        node = new mathMLTree.MathNode(\"munderover\", [arrowNode, lowerNode, upperNode]);\n      } else {\n        node = new mathMLTree.MathNode(\"mover\", [arrowNode, upperNode]);\n      }\n    } else if (group.below) {\n      var _lowerNode = arrow_paddedNode(buildMathML_buildGroup(group.below, options));\n\n      node = new mathMLTree.MathNode(\"munder\", [arrowNode, _lowerNode]);\n    } else {\n      // This should never happen.\n      // Parser.js throws an error if there is no argument.\n      node = arrow_paddedNode();\n      node = new mathMLTree.MathNode(\"mover\", [arrowNode, node]);\n    }\n\n    return node;\n  }\n});\n// CONCATENATED MODULE: ./src/functions/char.js\n\n\n // \\@char is an internal function that takes a grouped decimal argument like\n// {123} and converts into symbol with code 123.  It is used by the *macro*\n// \\char defined in macros.js.\n\ndefineFunction({\n  type: \"textord\",\n  names: [\"\\\\@char\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n  handler: function handler(_ref, args) {\n    var parser = _ref.parser;\n    var arg = assertNodeType(args[0], \"ordgroup\");\n    var group = arg.body;\n    var number = \"\";\n\n    for (var i = 0; i < group.length; i++) {\n      var node = assertNodeType(group[i], \"textord\");\n      number += node.text;\n    }\n\n    var code = parseInt(number);\n\n    if (isNaN(code)) {\n      throw new src_ParseError(\"\\\\@char has non-numeric argument \" + number);\n    }\n\n    return {\n      type: \"textord\",\n      mode: parser.mode,\n      text: String.fromCharCode(code)\n    };\n  }\n});\n// CONCATENATED MODULE: ./src/functions/color.js\n\n\n\n\n\n\n\nvar color_htmlBuilder = function htmlBuilder(group, options) {\n  var elements = buildHTML_buildExpression(group.body, options.withColor(group.color), false); // \\color isn't supposed to affect the type of the elements it contains.\n  // To accomplish this, we wrap the results in a fragment, so the inner\n  // elements will be able to directly interact with their neighbors. For\n  // example, `\\color{red}{2 +} 3` has the same spacing as `2 + 3`\n\n  return buildCommon.makeFragment(elements);\n};\n\nvar color_mathmlBuilder = function mathmlBuilder(group, options) {\n  var inner = buildMathML_buildExpression(group.body, options.withColor(group.color));\n  var node = new mathMLTree.MathNode(\"mstyle\", inner);\n  node.setAttribute(\"mathcolor\", group.color);\n  return node;\n};\n\ndefineFunction({\n  type: \"color\",\n  names: [\"\\\\textcolor\"],\n  props: {\n    numArgs: 2,\n    allowedInText: true,\n    greediness: 3,\n    argTypes: [\"color\", \"original\"]\n  },\n  handler: function handler(_ref, args) {\n    var parser = _ref.parser;\n    var color = assertNodeType(args[0], \"color-token\").color;\n    var body = args[1];\n    return {\n      type: \"color\",\n      mode: parser.mode,\n      color: color,\n      body: defineFunction_ordargument(body)\n    };\n  },\n  htmlBuilder: color_htmlBuilder,\n  mathmlBuilder: color_mathmlBuilder\n});\ndefineFunction({\n  type: \"color\",\n  names: [\"\\\\color\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true,\n    greediness: 3,\n    argTypes: [\"color\"]\n  },\n  handler: function handler(_ref2, args) {\n    var parser = _ref2.parser,\n        breakOnTokenText = _ref2.breakOnTokenText;\n    var color = assertNodeType(args[0], \"color-token\").color; // Set macro \\current@color in current namespace to store the current\n    // color, mimicking the behavior of color.sty.\n    // This is currently used just to correctly color a \\right\n    // that follows a \\color command.\n\n    parser.gullet.macros.set(\"\\\\current@color\", color); // Parse out the implicit body that should be colored.\n\n    var body = parser.parseExpression(true, breakOnTokenText);\n    return {\n      type: \"color\",\n      mode: parser.mode,\n      color: color,\n      body: body\n    };\n  },\n  htmlBuilder: color_htmlBuilder,\n  mathmlBuilder: color_mathmlBuilder\n});\n// CONCATENATED MODULE: ./src/functions/cr.js\n// Row breaks within tabular environments, and line breaks at top level\n\n\n\n\n\n // \\\\ is a macro mapping to either \\cr or \\newline.  Because they have the\n// same signature, we implement them as one megafunction, with newRow\n// indicating whether we're in the \\cr case, and newLine indicating whether\n// to break the line in the \\newline case.\n\ndefineFunction({\n  type: \"cr\",\n  names: [\"\\\\cr\", \"\\\\newline\"],\n  props: {\n    numArgs: 0,\n    numOptionalArgs: 1,\n    argTypes: [\"size\"],\n    allowedInText: true\n  },\n  handler: function handler(_ref, args, optArgs) {\n    var parser = _ref.parser,\n        funcName = _ref.funcName;\n    var size = optArgs[0];\n    var newRow = funcName === \"\\\\cr\";\n    var newLine = false;\n\n    if (!newRow) {\n      if (parser.settings.displayMode && parser.settings.useStrictBehavior(\"newLineInDisplayMode\", \"In LaTeX, \\\\\\\\ or \\\\newline \" + \"does nothing in display mode\")) {\n        newLine = false;\n      } else {\n        newLine = true;\n      }\n    }\n\n    return {\n      type: \"cr\",\n      mode: parser.mode,\n      newLine: newLine,\n      newRow: newRow,\n      size: size && assertNodeType(size, \"size\").value\n    };\n  },\n  // The following builders are called only at the top level,\n  // not within tabular/array environments.\n  htmlBuilder: function htmlBuilder(group, options) {\n    if (group.newRow) {\n      throw new src_ParseError(\"\\\\cr valid only within a tabular/array environment\");\n    }\n\n    var span = buildCommon.makeSpan([\"mspace\"], [], options);\n\n    if (group.newLine) {\n      span.classes.push(\"newline\");\n\n      if (group.size) {\n        span.style.marginTop = units_calculateSize(group.size, options) + \"em\";\n      }\n    }\n\n    return span;\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var node = new mathMLTree.MathNode(\"mspace\");\n\n    if (group.newLine) {\n      node.setAttribute(\"linebreak\", \"newline\");\n\n      if (group.size) {\n        node.setAttribute(\"height\", units_calculateSize(group.size, options) + \"em\");\n      }\n    }\n\n    return node;\n  }\n});\n// CONCATENATED MODULE: ./src/delimiter.js\n/**\n * This file deals with creating delimiters of various sizes. The TeXbook\n * discusses these routines on page 441-442, in the \"Another subroutine sets box\n * x to a specified variable delimiter\" paragraph.\n *\n * There are three main routines here. `makeSmallDelim` makes a delimiter in the\n * normal font, but in either text, script, or scriptscript style.\n * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,\n * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of\n * smaller pieces that are stacked on top of one another.\n *\n * The functions take a parameter `center`, which determines if the delimiter\n * should be centered around the axis.\n *\n * Then, there are three exposed functions. `sizedDelim` makes a delimiter in\n * one of the given sizes. This is used for things like `\\bigl`.\n * `customSizedDelim` makes a delimiter with a given total height+depth. It is\n * called in places like `\\sqrt`. `leftRightDelim` makes an appropriate\n * delimiter which surrounds an expression of a given height an depth. It is\n * used in `\\left` and `\\right`.\n */\n\n\n\n\n\n\n\n\n\n/**\n * Get the metrics for a given symbol and font, after transformation (i.e.\n * after following replacement from symbols.js)\n */\nvar delimiter_getMetrics = function getMetrics(symbol, font, mode) {\n  var replace = src_symbols.math[symbol] && src_symbols.math[symbol].replace;\n  var metrics = getCharacterMetrics(replace || symbol, font, mode);\n\n  if (!metrics) {\n    throw new Error(\"Unsupported symbol \" + symbol + \" and font size \" + font + \".\");\n  }\n\n  return metrics;\n};\n/**\n * Puts a delimiter span in a given style, and adds appropriate height, depth,\n * and maxFontSizes.\n */\n\n\nvar delimiter_styleWrap = function styleWrap(delim, toStyle, options, classes) {\n  var newOptions = options.havingBaseStyle(toStyle);\n  var span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);\n  var delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;\n  span.height *= delimSizeMultiplier;\n  span.depth *= delimSizeMultiplier;\n  span.maxFontSize = newOptions.sizeMultiplier;\n  return span;\n};\n\nvar centerSpan = function centerSpan(span, options, style) {\n  var newOptions = options.havingBaseStyle(style);\n  var shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;\n  span.classes.push(\"delimcenter\");\n  span.style.top = shift + \"em\";\n  span.height -= shift;\n  span.depth += shift;\n};\n/**\n * Makes a small delimiter. This is a delimiter that comes in the Main-Regular\n * font, but is restyled to either be in textstyle, scriptstyle, or\n * scriptscriptstyle.\n */\n\n\nvar delimiter_makeSmallDelim = function makeSmallDelim(delim, style, center, options, mode, classes) {\n  var text = buildCommon.makeSymbol(delim, \"Main-Regular\", mode, options);\n  var span = delimiter_styleWrap(text, style, options, classes);\n\n  if (center) {\n    centerSpan(span, options, style);\n  }\n\n  return span;\n};\n/**\n * Builds a symbol in the given font size (note size is an integer)\n */\n\n\nvar delimiter_mathrmSize = function mathrmSize(value, size, mode, options) {\n  return buildCommon.makeSymbol(value, \"Size\" + size + \"-Regular\", mode, options);\n};\n/**\n * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,\n * Size3, or Size4 fonts. It is always rendered in textstyle.\n */\n\n\nvar delimiter_makeLargeDelim = function makeLargeDelim(delim, size, center, options, mode, classes) {\n  var inner = delimiter_mathrmSize(delim, size, mode, options);\n  var span = delimiter_styleWrap(buildCommon.makeSpan([\"delimsizing\", \"size\" + size], [inner], options), src_Style.TEXT, options, classes);\n\n  if (center) {\n    centerSpan(span, options, src_Style.TEXT);\n  }\n\n  return span;\n};\n/**\n * Make an inner span with the given offset and in the given font. This is used\n * in `makeStackedDelim` to make the stacking pieces for the delimiter.\n */\n\n\nvar delimiter_makeInner = function makeInner(symbol, font, mode) {\n  var sizeClass; // Apply the correct CSS class to choose the right font.\n\n  if (font === \"Size1-Regular\") {\n    sizeClass = \"delim-size1\";\n  } else\n    /* if (font === \"Size4-Regular\") */\n    {\n      sizeClass = \"delim-size4\";\n    }\n\n  var inner = buildCommon.makeSpan([\"delimsizinginner\", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]); // Since this will be passed into `makeVList` in the end, wrap the element\n  // in the appropriate tag that VList uses.\n\n  return {\n    type: \"elem\",\n    elem: inner\n  };\n}; // Helper for makeStackedDelim\n\n\nvar lap = {\n  type: \"kern\",\n  size: -0.005\n};\n/**\n * Make a stacked delimiter out of a given delimiter, with the total height at\n * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.\n */\n\nvar delimiter_makeStackedDelim = function makeStackedDelim(delim, heightTotal, center, options, mode, classes) {\n  // There are four parts, the top, an optional middle, a repeated part, and a\n  // bottom.\n  var top;\n  var middle;\n  var repeat;\n  var bottom;\n  top = repeat = bottom = delim;\n  middle = null; // Also keep track of what font the delimiters are in\n\n  var font = \"Size1-Regular\"; // We set the parts and font based on the symbol. Note that we use\n  // '\\u23d0' instead of '|' and '\\u2016' instead of '\\\\|' for the\n  // repeats of the arrows\n\n  if (delim === \"\\\\uparrow\") {\n    repeat = bottom = \"\\u23D0\";\n  } else if (delim === \"\\\\Uparrow\") {\n    repeat = bottom = \"\\u2016\";\n  } else if (delim === \"\\\\downarrow\") {\n    top = repeat = \"\\u23D0\";\n  } else if (delim === \"\\\\Downarrow\") {\n    top = repeat = \"\\u2016\";\n  } else if (delim === \"\\\\updownarrow\") {\n    top = \"\\\\uparrow\";\n    repeat = \"\\u23D0\";\n    bottom = \"\\\\downarrow\";\n  } else if (delim === \"\\\\Updownarrow\") {\n    top = \"\\\\Uparrow\";\n    repeat = \"\\u2016\";\n    bottom = \"\\\\Downarrow\";\n  } else if (delim === \"[\" || delim === \"\\\\lbrack\") {\n    top = \"\\u23A1\";\n    repeat = \"\\u23A2\";\n    bottom = \"\\u23A3\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"]\" || delim === \"\\\\rbrack\") {\n    top = \"\\u23A4\";\n    repeat = \"\\u23A5\";\n    bottom = \"\\u23A6\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\lfloor\" || delim === \"\\u230A\") {\n    repeat = top = \"\\u23A2\";\n    bottom = \"\\u23A3\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\lceil\" || delim === \"\\u2308\") {\n    top = \"\\u23A1\";\n    repeat = bottom = \"\\u23A2\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\rfloor\" || delim === \"\\u230B\") {\n    repeat = top = \"\\u23A5\";\n    bottom = \"\\u23A6\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\rceil\" || delim === \"\\u2309\") {\n    top = \"\\u23A4\";\n    repeat = bottom = \"\\u23A5\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"(\" || delim === \"\\\\lparen\") {\n    top = \"\\u239B\";\n    repeat = \"\\u239C\";\n    bottom = \"\\u239D\";\n    font = \"Size4-Regular\";\n  } else if (delim === \")\" || delim === \"\\\\rparen\") {\n    top = \"\\u239E\";\n    repeat = \"\\u239F\";\n    bottom = \"\\u23A0\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\{\" || delim === \"\\\\lbrace\") {\n    top = \"\\u23A7\";\n    middle = \"\\u23A8\";\n    bottom = \"\\u23A9\";\n    repeat = \"\\u23AA\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\}\" || delim === \"\\\\rbrace\") {\n    top = \"\\u23AB\";\n    middle = \"\\u23AC\";\n    bottom = \"\\u23AD\";\n    repeat = \"\\u23AA\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\lgroup\" || delim === \"\\u27EE\") {\n    top = \"\\u23A7\";\n    bottom = \"\\u23A9\";\n    repeat = \"\\u23AA\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\rgroup\" || delim === \"\\u27EF\") {\n    top = \"\\u23AB\";\n    bottom = \"\\u23AD\";\n    repeat = \"\\u23AA\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\lmoustache\" || delim === \"\\u23B0\") {\n    top = \"\\u23A7\";\n    bottom = \"\\u23AD\";\n    repeat = \"\\u23AA\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\rmoustache\" || delim === \"\\u23B1\") {\n    top = \"\\u23AB\";\n    bottom = \"\\u23A9\";\n    repeat = \"\\u23AA\";\n    font = \"Size4-Regular\";\n  } // Get the metrics of the four sections\n\n\n  var topMetrics = delimiter_getMetrics(top, font, mode);\n  var topHeightTotal = topMetrics.height + topMetrics.depth;\n  var repeatMetrics = delimiter_getMetrics(repeat, font, mode);\n  var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;\n  var bottomMetrics = delimiter_getMetrics(bottom, font, mode);\n  var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;\n  var middleHeightTotal = 0;\n  var middleFactor = 1;\n\n  if (middle !== null) {\n    var middleMetrics = delimiter_getMetrics(middle, font, mode);\n    middleHeightTotal = middleMetrics.height + middleMetrics.depth;\n    middleFactor = 2; // repeat symmetrically above and below middle\n  } // Calcuate the minimal height that the delimiter can have.\n  // It is at least the size of the top, bottom, and optional middle combined.\n\n\n  var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal; // Compute the number of copies of the repeat symbol we will need\n\n  var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal))); // Compute the total height of the delimiter including all the symbols\n\n  var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal; // The center of the delimiter is placed at the center of the axis. Note\n  // that in this context, \"center\" means that the delimiter should be\n  // centered around the axis in the current style, while normally it is\n  // centered around the axis in textstyle.\n\n  var axisHeight = options.fontMetrics().axisHeight;\n\n  if (center) {\n    axisHeight *= options.sizeMultiplier;\n  } // Calculate the depth\n\n\n  var depth = realHeightTotal / 2 - axisHeight; // This function differs from the TeX procedure in one way.\n  // We shift each repeat element downwards by 0.005em, to prevent a gap\n  // due to browser floating point rounding error.\n  // Then, at the last element-to element joint, we add one extra repeat\n  // element to cover the gap created by the shifts.\n  // Find the shift needed to align the upper end of the extra element at a point\n  // 0.005em above the lower end of the top element.\n\n  var shiftOfExtraElement = (repeatCount + 1) * 0.005 - repeatHeightTotal; // Now, we start building the pieces that will go into the vlist\n  // Keep a list of the inner pieces\n\n  var inners = []; // Add the bottom symbol\n\n  inners.push(delimiter_makeInner(bottom, font, mode));\n\n  if (middle === null) {\n    // Add that many symbols\n    for (var i = 0; i < repeatCount; i++) {\n      inners.push(lap); // overlap\n\n      inners.push(delimiter_makeInner(repeat, font, mode));\n    }\n  } else {\n    // When there is a middle bit, we need the middle part and two repeated\n    // sections\n    for (var _i = 0; _i < repeatCount; _i++) {\n      inners.push(lap);\n      inners.push(delimiter_makeInner(repeat, font, mode));\n    } // Insert one extra repeat element.\n\n\n    inners.push({\n      type: \"kern\",\n      size: shiftOfExtraElement\n    });\n    inners.push(delimiter_makeInner(repeat, font, mode));\n    inners.push(lap); // Now insert the middle of the brace.\n\n    inners.push(delimiter_makeInner(middle, font, mode));\n\n    for (var _i2 = 0; _i2 < repeatCount; _i2++) {\n      inners.push(lap);\n      inners.push(delimiter_makeInner(repeat, font, mode));\n    }\n  } // To cover the gap create by the overlaps, insert one more repeat element,\n  // at a position that juts 0.005 above the bottom of the top element.\n\n\n  inners.push({\n    type: \"kern\",\n    size: shiftOfExtraElement\n  });\n  inners.push(delimiter_makeInner(repeat, font, mode));\n  inners.push(lap); // Add the top symbol\n\n  inners.push(delimiter_makeInner(top, font, mode)); // Finally, build the vlist\n\n  var newOptions = options.havingBaseStyle(src_Style.TEXT);\n  var inner = buildCommon.makeVList({\n    positionType: \"bottom\",\n    positionData: depth,\n    children: inners\n  }, newOptions);\n  return delimiter_styleWrap(buildCommon.makeSpan([\"delimsizing\", \"mult\"], [inner], newOptions), src_Style.TEXT, options, classes);\n}; // All surds have 0.08em padding above the viniculum inside the SVG.\n// That keeps browser span height rounding error from pinching the line.\n\n\nvar vbPad = 80; // padding above the surd, measured inside the viewBox.\n\nvar emPad = 0.08; // padding, in ems, measured in the document.\n\nvar delimiter_sqrtSvg = function sqrtSvg(sqrtName, height, viewBoxHeight, extraViniculum, options) {\n  var path = sqrtPath(sqrtName, extraViniculum, viewBoxHeight);\n  var pathNode = new domTree_PathNode(sqrtName, path);\n  var svg = new SvgNode([pathNode], {\n    // Note: 1000:1 ratio of viewBox to document em width.\n    \"width\": \"400em\",\n    \"height\": height + \"em\",\n    \"viewBox\": \"0 0 400000 \" + viewBoxHeight,\n    \"preserveAspectRatio\": \"xMinYMin slice\"\n  });\n  return buildCommon.makeSvgSpan([\"hide-tail\"], [svg], options);\n};\n/**\n * Make a sqrt image of the given height,\n */\n\n\nvar makeSqrtImage = function makeSqrtImage(height, options) {\n  // Define a newOptions that removes the effect of size changes such as \\Huge.\n  // We don't pick different a height surd for \\Huge. For it, we scale up.\n  var newOptions = options.havingBaseSizing(); // Pick the desired surd glyph from a sequence of surds.\n\n  var delim = traverseSequence(\"\\\\surd\", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);\n  var sizeMultiplier = newOptions.sizeMultiplier; // default\n  // The standard sqrt SVGs each have a 0.04em thick viniculum.\n  // If Settings.minRuleThickness is larger than that, we add extraViniculum.\n\n  var extraViniculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness); // Create a span containing an SVG image of a sqrt symbol.\n\n  var span;\n  var spanHeight = 0;\n  var texHeight = 0;\n  var viewBoxHeight = 0;\n  var advanceWidth; // We create viewBoxes with 80 units of \"padding\" above each surd.\n  // Then browser rounding error on the parent span height will not\n  // encroach on the ink of the viniculum. But that padding is not\n  // included in the TeX-like `height` used for calculation of\n  // vertical alignment. So texHeight = span.height < span.style.height.\n\n  if (delim.type === \"small\") {\n    // Get an SVG that is derived from glyph U+221A in font KaTeX-Main.\n    // 1000 unit normal glyph height.\n    viewBoxHeight = 1000 + 1000 * extraViniculum + vbPad;\n\n    if (height < 1.0) {\n      sizeMultiplier = 1.0; // mimic a \\textfont radical\n    } else if (height < 1.4) {\n      sizeMultiplier = 0.7; // mimic a \\scriptfont radical\n    }\n\n    spanHeight = (1.0 + extraViniculum + emPad) / sizeMultiplier;\n    texHeight = (1.00 + extraViniculum) / sizeMultiplier;\n    span = delimiter_sqrtSvg(\"sqrtMain\", spanHeight, viewBoxHeight, extraViniculum, options);\n    span.style.minWidth = \"0.853em\";\n    advanceWidth = 0.833 / sizeMultiplier; // from the font.\n  } else if (delim.type === \"large\") {\n    // These SVGs come from fonts: KaTeX_Size1, _Size2, etc.\n    viewBoxHeight = (1000 + vbPad) * sizeToMaxHeight[delim.size];\n    texHeight = (sizeToMaxHeight[delim.size] + extraViniculum) / sizeMultiplier;\n    spanHeight = (sizeToMaxHeight[delim.size] + extraViniculum + emPad) / sizeMultiplier;\n    span = delimiter_sqrtSvg(\"sqrtSize\" + delim.size, spanHeight, viewBoxHeight, extraViniculum, options);\n    span.style.minWidth = \"1.02em\";\n    advanceWidth = 1.0 / sizeMultiplier; // 1.0 from the font.\n  } else {\n    // Tall sqrt. In TeX, this would be stacked using multiple glyphs.\n    // We'll use a single SVG to accomplish the same thing.\n    spanHeight = height + extraViniculum + emPad;\n    texHeight = height + extraViniculum;\n    viewBoxHeight = Math.floor(1000 * height + extraViniculum) + vbPad;\n    span = delimiter_sqrtSvg(\"sqrtTall\", spanHeight, viewBoxHeight, extraViniculum, options);\n    span.style.minWidth = \"0.742em\";\n    advanceWidth = 1.056;\n  }\n\n  span.height = texHeight;\n  span.style.height = spanHeight + \"em\";\n  return {\n    span: span,\n    advanceWidth: advanceWidth,\n    // Calculate the actual line width.\n    // This actually should depend on the chosen font -- e.g. \\boldmath\n    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and\n    // have thicker rules.\n    ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraViniculum) * sizeMultiplier\n  };\n}; // There are three kinds of delimiters, delimiters that stack when they become\n// too large\n\n\nvar stackLargeDelimiters = [\"(\", \"\\\\lparen\", \")\", \"\\\\rparen\", \"[\", \"\\\\lbrack\", \"]\", \"\\\\rbrack\", \"\\\\{\", \"\\\\lbrace\", \"\\\\}\", \"\\\\rbrace\", \"\\\\lfloor\", \"\\\\rfloor\", \"\\u230A\", \"\\u230B\", \"\\\\lceil\", \"\\\\rceil\", \"\\u2308\", \"\\u2309\", \"\\\\surd\"]; // delimiters that always stack\n\nvar stackAlwaysDelimiters = [\"\\\\uparrow\", \"\\\\downarrow\", \"\\\\updownarrow\", \"\\\\Uparrow\", \"\\\\Downarrow\", \"\\\\Updownarrow\", \"|\", \"\\\\|\", \"\\\\vert\", \"\\\\Vert\", \"\\\\lvert\", \"\\\\rvert\", \"\\\\lVert\", \"\\\\rVert\", \"\\\\lgroup\", \"\\\\rgroup\", \"\\u27EE\", \"\\u27EF\", \"\\\\lmoustache\", \"\\\\rmoustache\", \"\\u23B0\", \"\\u23B1\"]; // and delimiters that never stack\n\nvar stackNeverDelimiters = [\"<\", \">\", \"\\\\langle\", \"\\\\rangle\", \"/\", \"\\\\backslash\", \"\\\\lt\", \"\\\\gt\"]; // Metrics of the different sizes. Found by looking at TeX's output of\n// $\\bigl| // \\Bigl| \\biggl| \\Biggl| \\showlists$\n// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.\n\nvar sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];\n/**\n * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.\n */\n\nvar delimiter_makeSizedDelim = function makeSizedDelim(delim, size, options, mode, classes) {\n  // < and > turn into \\langle and \\rangle in delimiters\n  if (delim === \"<\" || delim === \"\\\\lt\" || delim === \"\\u27E8\") {\n    delim = \"\\\\langle\";\n  } else if (delim === \">\" || delim === \"\\\\gt\" || delim === \"\\u27E9\") {\n    delim = \"\\\\rangle\";\n  } // Sized delimiters are never centered.\n\n\n  if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {\n    return delimiter_makeLargeDelim(delim, size, false, options, mode, classes);\n  } else if (utils.contains(stackAlwaysDelimiters, delim)) {\n    return delimiter_makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);\n  } else {\n    throw new src_ParseError(\"Illegal delimiter: '\" + delim + \"'\");\n  }\n};\n/**\n * There are three different sequences of delimiter sizes that the delimiters\n * follow depending on the kind of delimiter. This is used when creating custom\n * sized delimiters to decide whether to create a small, large, or stacked\n * delimiter.\n *\n * In real TeX, these sequences aren't explicitly defined, but are instead\n * defined inside the font metrics. Since there are only three sequences that\n * are possible for the delimiters that TeX defines, it is easier to just encode\n * them explicitly here.\n */\n\n\n// Delimiters that never stack try small delimiters and large delimiters only\nvar stackNeverDelimiterSequence = [{\n  type: \"small\",\n  style: src_Style.SCRIPTSCRIPT\n}, {\n  type: \"small\",\n  style: src_Style.SCRIPT\n}, {\n  type: \"small\",\n  style: src_Style.TEXT\n}, {\n  type: \"large\",\n  size: 1\n}, {\n  type: \"large\",\n  size: 2\n}, {\n  type: \"large\",\n  size: 3\n}, {\n  type: \"large\",\n  size: 4\n}]; // Delimiters that always stack try the small delimiters first, then stack\n\nvar stackAlwaysDelimiterSequence = [{\n  type: \"small\",\n  style: src_Style.SCRIPTSCRIPT\n}, {\n  type: \"small\",\n  style: src_Style.SCRIPT\n}, {\n  type: \"small\",\n  style: src_Style.TEXT\n}, {\n  type: \"stack\"\n}]; // Delimiters that stack when large try the small and then large delimiters, and\n// stack afterwards\n\nvar stackLargeDelimiterSequence = [{\n  type: \"small\",\n  style: src_Style.SCRIPTSCRIPT\n}, {\n  type: \"small\",\n  style: src_Style.SCRIPT\n}, {\n  type: \"small\",\n  style: src_Style.TEXT\n}, {\n  type: \"large\",\n  size: 1\n}, {\n  type: \"large\",\n  size: 2\n}, {\n  type: \"large\",\n  size: 3\n}, {\n  type: \"large\",\n  size: 4\n}, {\n  type: \"stack\"\n}];\n/**\n * Get the font used in a delimiter based on what kind of delimiter it is.\n * TODO(#963) Use more specific font family return type once that is introduced.\n */\n\nvar delimTypeToFont = function delimTypeToFont(type) {\n  if (type.type === \"small\") {\n    return \"Main-Regular\";\n  } else if (type.type === \"large\") {\n    return \"Size\" + type.size + \"-Regular\";\n  } else if (type.type === \"stack\") {\n    return \"Size4-Regular\";\n  } else {\n    throw new Error(\"Add support for delim type '\" + type.type + \"' here.\");\n  }\n};\n/**\n * Traverse a sequence of types of delimiters to decide what kind of delimiter\n * should be used to create a delimiter of the given height+depth.\n */\n\n\nvar traverseSequence = function traverseSequence(delim, height, sequence, options) {\n  // Here, we choose the index we should start at in the sequences. In smaller\n  // sizes (which correspond to larger numbers in style.size) we start earlier\n  // in the sequence. Thus, scriptscript starts at index 3-3=0, script starts\n  // at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2\n  var start = Math.min(2, 3 - options.style.size);\n\n  for (var i = start; i < sequence.length; i++) {\n    if (sequence[i].type === \"stack\") {\n      // This is always the last delimiter, so we just break the loop now.\n      break;\n    }\n\n    var metrics = delimiter_getMetrics(delim, delimTypeToFont(sequence[i]), \"math\");\n    var heightDepth = metrics.height + metrics.depth; // Small delimiters are scaled down versions of the same font, so we\n    // account for the style change size.\n\n    if (sequence[i].type === \"small\") {\n      var newOptions = options.havingBaseStyle(sequence[i].style);\n      heightDepth *= newOptions.sizeMultiplier;\n    } // Check if the delimiter at this size works for the given height.\n\n\n    if (heightDepth > height) {\n      return sequence[i];\n    }\n  } // If we reached the end of the sequence, return the last sequence element.\n\n\n  return sequence[sequence.length - 1];\n};\n/**\n * Make a delimiter of a given height+depth, with optional centering. Here, we\n * traverse the sequences, and create a delimiter that the sequence tells us to.\n */\n\n\nvar delimiter_makeCustomSizedDelim = function makeCustomSizedDelim(delim, height, center, options, mode, classes) {\n  if (delim === \"<\" || delim === \"\\\\lt\" || delim === \"\\u27E8\") {\n    delim = \"\\\\langle\";\n  } else if (delim === \">\" || delim === \"\\\\gt\" || delim === \"\\u27E9\") {\n    delim = \"\\\\rangle\";\n  } // Decide what sequence to use\n\n\n  var sequence;\n\n  if (utils.contains(stackNeverDelimiters, delim)) {\n    sequence = stackNeverDelimiterSequence;\n  } else if (utils.contains(stackLargeDelimiters, delim)) {\n    sequence = stackLargeDelimiterSequence;\n  } else {\n    sequence = stackAlwaysDelimiterSequence;\n  } // Look through the sequence\n\n\n  var delimType = traverseSequence(delim, height, sequence, options); // Get the delimiter from font glyphs.\n  // Depending on the sequence element we decided on, call the\n  // appropriate function.\n\n  if (delimType.type === \"small\") {\n    return delimiter_makeSmallDelim(delim, delimType.style, center, options, mode, classes);\n  } else if (delimType.type === \"large\") {\n    return delimiter_makeLargeDelim(delim, delimType.size, center, options, mode, classes);\n  } else\n    /* if (delimType.type === \"stack\") */\n    {\n      return delimiter_makeStackedDelim(delim, height, center, options, mode, classes);\n    }\n};\n/**\n * Make a delimiter for use with `\\left` and `\\right`, given a height and depth\n * of an expression that the delimiters surround.\n */\n\n\nvar makeLeftRightDelim = function makeLeftRightDelim(delim, height, depth, options, mode, classes) {\n  // We always center \\left/\\right delimiters, so the axis is always shifted\n  var axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier; // Taken from TeX source, tex.web, function make_left_right\n\n  var delimiterFactor = 901;\n  var delimiterExtend = 5.0 / options.fontMetrics().ptPerEm;\n  var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);\n  var totalHeight = Math.max( // In real TeX, calculations are done using integral values which are\n  // 65536 per pt, or 655360 per em. So, the division here truncates in\n  // TeX but doesn't here, producing different results. If we wanted to\n  // exactly match TeX's calculation, we could do\n  //   Math.floor(655360 * maxDistFromAxis / 500) *\n  //    delimiterFactor / 655360\n  // (To see the difference, compare\n  //    x^{x^{\\left(\\rule{0.1em}{0.68em}\\right)}}\n  // in TeX and KaTeX)\n  maxDistFromAxis / 500 * delimiterFactor, 2 * maxDistFromAxis - delimiterExtend); // Finally, we defer to `makeCustomSizedDelim` with our calculated total\n  // height\n\n  return delimiter_makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);\n};\n\n/* harmony default export */ var delimiter = ({\n  sqrtImage: makeSqrtImage,\n  sizedDelim: delimiter_makeSizedDelim,\n  customSizedDelim: delimiter_makeCustomSizedDelim,\n  leftRightDelim: makeLeftRightDelim\n});\n// CONCATENATED MODULE: ./src/functions/delimsizing.js\n\n\n\n\n\n\n\n\n\n// Extra data needed for the delimiter handler down below\nvar delimiterSizes = {\n  \"\\\\bigl\": {\n    mclass: \"mopen\",\n    size: 1\n  },\n  \"\\\\Bigl\": {\n    mclass: \"mopen\",\n    size: 2\n  },\n  \"\\\\biggl\": {\n    mclass: \"mopen\",\n    size: 3\n  },\n  \"\\\\Biggl\": {\n    mclass: \"mopen\",\n    size: 4\n  },\n  \"\\\\bigr\": {\n    mclass: \"mclose\",\n    size: 1\n  },\n  \"\\\\Bigr\": {\n    mclass: \"mclose\",\n    size: 2\n  },\n  \"\\\\biggr\": {\n    mclass: \"mclose\",\n    size: 3\n  },\n  \"\\\\Biggr\": {\n    mclass: \"mclose\",\n    size: 4\n  },\n  \"\\\\bigm\": {\n    mclass: \"mrel\",\n    size: 1\n  },\n  \"\\\\Bigm\": {\n    mclass: \"mrel\",\n    size: 2\n  },\n  \"\\\\biggm\": {\n    mclass: \"mrel\",\n    size: 3\n  },\n  \"\\\\Biggm\": {\n    mclass: \"mrel\",\n    size: 4\n  },\n  \"\\\\big\": {\n    mclass: \"mord\",\n    size: 1\n  },\n  \"\\\\Big\": {\n    mclass: \"mord\",\n    size: 2\n  },\n  \"\\\\bigg\": {\n    mclass: \"mord\",\n    size: 3\n  },\n  \"\\\\Bigg\": {\n    mclass: \"mord\",\n    size: 4\n  }\n};\nvar delimiters = [\"(\", \"\\\\lparen\", \")\", \"\\\\rparen\", \"[\", \"\\\\lbrack\", \"]\", \"\\\\rbrack\", \"\\\\{\", \"\\\\lbrace\", \"\\\\}\", \"\\\\rbrace\", \"\\\\lfloor\", \"\\\\rfloor\", \"\\u230A\", \"\\u230B\", \"\\\\lceil\", \"\\\\rceil\", \"\\u2308\", \"\\u2309\", \"<\", \">\", \"\\\\langle\", \"\\u27E8\", \"\\\\rangle\", \"\\u27E9\", \"\\\\lt\", \"\\\\gt\", \"\\\\lvert\", \"\\\\rvert\", \"\\\\lVert\", \"\\\\rVert\", \"\\\\lgroup\", \"\\\\rgroup\", \"\\u27EE\", \"\\u27EF\", \"\\\\lmoustache\", \"\\\\rmoustache\", \"\\u23B0\", \"\\u23B1\", \"/\", \"\\\\backslash\", \"|\", \"\\\\vert\", \"\\\\|\", \"\\\\Vert\", \"\\\\uparrow\", \"\\\\Uparrow\", \"\\\\downarrow\", \"\\\\Downarrow\", \"\\\\updownarrow\", \"\\\\Updownarrow\", \".\"];\n\n// Delimiter functions\nfunction checkDelimiter(delim, context) {\n  var symDelim = checkSymbolNodeType(delim);\n\n  if (symDelim && utils.contains(delimiters, symDelim.text)) {\n    return symDelim;\n  } else {\n    throw new src_ParseError(\"Invalid delimiter: '\" + (symDelim ? symDelim.text : JSON.stringify(delim)) + \"' after '\" + context.funcName + \"'\", delim);\n  }\n}\n\ndefineFunction({\n  type: \"delimsizing\",\n  names: [\"\\\\bigl\", \"\\\\Bigl\", \"\\\\biggl\", \"\\\\Biggl\", \"\\\\bigr\", \"\\\\Bigr\", \"\\\\biggr\", \"\\\\Biggr\", \"\\\\bigm\", \"\\\\Bigm\", \"\\\\biggm\", \"\\\\Biggm\", \"\\\\big\", \"\\\\Big\", \"\\\\bigg\", \"\\\\Bigg\"],\n  props: {\n    numArgs: 1\n  },\n  handler: function handler(context, args) {\n    var delim = checkDelimiter(args[0], context);\n    return {\n      type: \"delimsizing\",\n      mode: context.parser.mode,\n      size: delimiterSizes[context.funcName].size,\n      mclass: delimiterSizes[context.funcName].mclass,\n      delim: delim.text\n    };\n  },\n  htmlBuilder: function htmlBuilder(group, options) {\n    if (group.delim === \".\") {\n      // Empty delimiters still count as elements, even though they don't\n      // show anything.\n      return buildCommon.makeSpan([group.mclass]);\n    } // Use delimiter.sizedDelim to generate the delimiter.\n\n\n    return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);\n  },\n  mathmlBuilder: function mathmlBuilder(group) {\n    var children = [];\n\n    if (group.delim !== \".\") {\n      children.push(buildMathML_makeText(group.delim, group.mode));\n    }\n\n    var node = new mathMLTree.MathNode(\"mo\", children);\n\n    if (group.mclass === \"mopen\" || group.mclass === \"mclose\") {\n      // Only some of the delimsizing functions act as fences, and they\n      // return \"mopen\" or \"mclose\" mclass.\n      node.setAttribute(\"fence\", \"true\");\n    } else {\n      // Explicitly disable fencing if it's not a fence, to override the\n      // defaults.\n      node.setAttribute(\"fence\", \"false\");\n    }\n\n    return node;\n  }\n});\n\nfunction assertParsed(group) {\n  if (!group.body) {\n    throw new Error(\"Bug: The leftright ParseNode wasn't fully parsed.\");\n  }\n}\n\ndefineFunction({\n  type: \"leftright-right\",\n  names: [\"\\\\right\"],\n  props: {\n    numArgs: 1\n  },\n  handler: function handler(context, args) {\n    // \\left case below triggers parsing of \\right in\n    //   `const right = parser.parseFunction();`\n    // uses this return value.\n    var color = context.parser.gullet.macros.get(\"\\\\current@color\");\n\n    if (color && typeof color !== \"string\") {\n      throw new src_ParseError(\"\\\\current@color set to non-string in \\\\right\");\n    }\n\n    return {\n      type: \"leftright-right\",\n      mode: context.parser.mode,\n      delim: checkDelimiter(args[0], context).text,\n      color: color // undefined if not set via \\color\n\n    };\n  }\n});\ndefineFunction({\n  type: \"leftright\",\n  names: [\"\\\\left\"],\n  props: {\n    numArgs: 1\n  },\n  handler: function handler(context, args) {\n    var delim = checkDelimiter(args[0], context);\n    var parser = context.parser; // Parse out the implicit body\n\n    ++parser.leftrightDepth; // parseExpression stops before '\\\\right'\n\n    var body = parser.parseExpression(false);\n    --parser.leftrightDepth; // Check the next token\n\n    parser.expect(\"\\\\right\", false);\n    var right = assertNodeType(parser.parseFunction(), \"leftright-right\");\n    return {\n      type: \"leftright\",\n      mode: parser.mode,\n      body: body,\n      left: delim.text,\n      right: right.delim,\n      rightColor: right.color\n    };\n  },\n  htmlBuilder: function htmlBuilder(group, options) {\n    assertParsed(group); // Build the inner expression\n\n    var inner = buildHTML_buildExpression(group.body, options, true, [\"mopen\", \"mclose\"]);\n    var innerHeight = 0;\n    var innerDepth = 0;\n    var hadMiddle = false; // Calculate its height and depth\n\n    for (var i = 0; i < inner.length; i++) {\n      // Property `isMiddle` not defined on `span`. See comment in\n      // \"middle\"'s htmlBuilder.\n      // $FlowFixMe\n      if (inner[i].isMiddle) {\n        hadMiddle = true;\n      } else {\n        innerHeight = Math.max(inner[i].height, innerHeight);\n        innerDepth = Math.max(inner[i].depth, innerDepth);\n      }\n    } // The size of delimiters is the same, regardless of what style we are\n    // in. Thus, to correctly calculate the size of delimiter we need around\n    // a group, we scale down the inner size based on the size.\n\n\n    innerHeight *= options.sizeMultiplier;\n    innerDepth *= options.sizeMultiplier;\n    var leftDelim;\n\n    if (group.left === \".\") {\n      // Empty delimiters in \\left and \\right make null delimiter spaces.\n      leftDelim = makeNullDelimiter(options, [\"mopen\"]);\n    } else {\n      // Otherwise, use leftRightDelim to generate the correct sized\n      // delimiter.\n      leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, [\"mopen\"]);\n    } // Add it to the beginning of the expression\n\n\n    inner.unshift(leftDelim); // Handle middle delimiters\n\n    if (hadMiddle) {\n      for (var _i = 1; _i < inner.length; _i++) {\n        var middleDelim = inner[_i]; // Property `isMiddle` not defined on `span`. See comment in\n        // \"middle\"'s htmlBuilder.\n        // $FlowFixMe\n\n        var isMiddle = middleDelim.isMiddle;\n\n        if (isMiddle) {\n          // Apply the options that were active when \\middle was called\n          inner[_i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);\n        }\n      }\n    }\n\n    var rightDelim; // Same for the right delimiter, but using color specified by \\color\n\n    if (group.right === \".\") {\n      rightDelim = makeNullDelimiter(options, [\"mclose\"]);\n    } else {\n      var colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;\n      rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, [\"mclose\"]);\n    } // Add it to the end of the expression.\n\n\n    inner.push(rightDelim);\n    return buildCommon.makeSpan([\"minner\"], inner, options);\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    assertParsed(group);\n    var inner = buildMathML_buildExpression(group.body, options);\n\n    if (group.left !== \".\") {\n      var leftNode = new mathMLTree.MathNode(\"mo\", [buildMathML_makeText(group.left, group.mode)]);\n      leftNode.setAttribute(\"fence\", \"true\");\n      inner.unshift(leftNode);\n    }\n\n    if (group.right !== \".\") {\n      var rightNode = new mathMLTree.MathNode(\"mo\", [buildMathML_makeText(group.right, group.mode)]);\n      rightNode.setAttribute(\"fence\", \"true\");\n\n      if (group.rightColor) {\n        rightNode.setAttribute(\"mathcolor\", group.rightColor);\n      }\n\n      inner.push(rightNode);\n    }\n\n    return buildMathML_makeRow(inner);\n  }\n});\ndefineFunction({\n  type: \"middle\",\n  names: [\"\\\\middle\"],\n  props: {\n    numArgs: 1\n  },\n  handler: function handler(context, args) {\n    var delim = checkDelimiter(args[0], context);\n\n    if (!context.parser.leftrightDepth) {\n      throw new src_ParseError(\"\\\\middle without preceding \\\\left\", delim);\n    }\n\n    return {\n      type: \"middle\",\n      mode: context.parser.mode,\n      delim: delim.text\n    };\n  },\n  htmlBuilder: function htmlBuilder(group, options) {\n    var middleDelim;\n\n    if (group.delim === \".\") {\n      middleDelim = makeNullDelimiter(options, []);\n    } else {\n      middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);\n      var isMiddle = {\n        delim: group.delim,\n        options: options\n      }; // Property `isMiddle` not defined on `span`. It is only used in\n      // this file above.\n      // TODO: Fix this violation of the `span` type and possibly rename\n      // things since `isMiddle` sounds like a boolean, but is a struct.\n      // $FlowFixMe\n\n      middleDelim.isMiddle = isMiddle;\n    }\n\n    return middleDelim;\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    // A Firefox \\middle will strech a character vertically only if it\n    // is in the fence part of the operator dictionary at:\n    // https://www.w3.org/TR/MathML3/appendixc.html.\n    // So we need to avoid U+2223 and use plain \"|\" instead.\n    var textNode = group.delim === \"\\\\vert\" || group.delim === \"|\" ? buildMathML_makeText(\"|\", \"text\") : buildMathML_makeText(group.delim, group.mode);\n    var middleNode = new mathMLTree.MathNode(\"mo\", [textNode]);\n    middleNode.setAttribute(\"fence\", \"true\"); // MathML gives 5/18em spacing to each <mo> element.\n    // \\middle should get delimiter spacing instead.\n\n    middleNode.setAttribute(\"lspace\", \"0.05em\");\n    middleNode.setAttribute(\"rspace\", \"0.05em\");\n    return middleNode;\n  }\n});\n// CONCATENATED MODULE: ./src/functions/enclose.js\n\n\n\n\n\n\n\n\n\nvar enclose_htmlBuilder = function htmlBuilder(group, options) {\n  // \\cancel, \\bcancel, \\xcancel, \\sout, \\fbox, \\colorbox, \\fcolorbox\n  // Some groups can return document fragments.  Handle those by wrapping\n  // them in a span.\n  var inner = buildCommon.wrapFragment(buildHTML_buildGroup(group.body, options), options);\n  var label = group.label.substr(1);\n  var scale = options.sizeMultiplier;\n  var img;\n  var imgShift = 0; // In the LaTeX cancel package, line geometry is slightly different\n  // depending on whether the subject is wider than it is tall, or vice versa.\n  // We don't know the width of a group, so as a proxy, we test if\n  // the subject is a single character. This captures most of the\n  // subjects that should get the \"tall\" treatment.\n\n  var isSingleChar = utils.isCharacterBox(group.body);\n\n  if (label === \"sout\") {\n    img = buildCommon.makeSpan([\"stretchy\", \"sout\"]);\n    img.height = options.fontMetrics().defaultRuleThickness / scale;\n    imgShift = -0.5 * options.fontMetrics().xHeight;\n  } else {\n    // Add horizontal padding\n    if (/cancel/.test(label)) {\n      if (!isSingleChar) {\n        inner.classes.push(\"cancel-pad\");\n      }\n    } else {\n      inner.classes.push(\"boxpad\");\n    } // Add vertical padding\n\n\n    var vertPad = 0;\n    var ruleThickness = 0; // ref: cancel package: \\advance\\totalheight2\\p@ % \"+2\"\n\n    if (/box/.test(label)) {\n      ruleThickness = Math.max(options.fontMetrics().fboxrule, // default\n      options.minRuleThickness // User override.\n      );\n      vertPad = options.fontMetrics().fboxsep + (label === \"colorbox\" ? 0 : ruleThickness);\n    } else {\n      vertPad = isSingleChar ? 0.2 : 0;\n    }\n\n    img = stretchy.encloseSpan(inner, label, vertPad, options);\n\n    if (/fbox|boxed|fcolorbox/.test(label)) {\n      img.style.borderStyle = \"solid\";\n      img.style.borderWidth = ruleThickness + \"em\";\n    }\n\n    imgShift = inner.depth + vertPad;\n\n    if (group.backgroundColor) {\n      img.style.backgroundColor = group.backgroundColor;\n\n      if (group.borderColor) {\n        img.style.borderColor = group.borderColor;\n      }\n    }\n  }\n\n  var vlist;\n\n  if (group.backgroundColor) {\n    vlist = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: [// Put the color background behind inner;\n      {\n        type: \"elem\",\n        elem: img,\n        shift: imgShift\n      }, {\n        type: \"elem\",\n        elem: inner,\n        shift: 0\n      }]\n    }, options);\n  } else {\n    vlist = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: [// Write the \\cancel stroke on top of inner.\n      {\n        type: \"elem\",\n        elem: inner,\n        shift: 0\n      }, {\n        type: \"elem\",\n        elem: img,\n        shift: imgShift,\n        wrapperClasses: /cancel/.test(label) ? [\"svg-align\"] : []\n      }]\n    }, options);\n  }\n\n  if (/cancel/.test(label)) {\n    // The cancel package documentation says that cancel lines add their height\n    // to the expression, but tests show that isn't how it actually works.\n    vlist.height = inner.height;\n    vlist.depth = inner.depth;\n  }\n\n  if (/cancel/.test(label) && !isSingleChar) {\n    // cancel does not create horiz space for its line extension.\n    return buildCommon.makeSpan([\"mord\", \"cancel-lap\"], [vlist], options);\n  } else {\n    return buildCommon.makeSpan([\"mord\"], [vlist], options);\n  }\n};\n\nvar enclose_mathmlBuilder = function mathmlBuilder(group, options) {\n  var fboxsep = 0;\n  var node = new mathMLTree.MathNode(group.label.indexOf(\"colorbox\") > -1 ? \"mpadded\" : \"menclose\", [buildMathML_buildGroup(group.body, options)]);\n\n  switch (group.label) {\n    case \"\\\\cancel\":\n      node.setAttribute(\"notation\", \"updiagonalstrike\");\n      break;\n\n    case \"\\\\bcancel\":\n      node.setAttribute(\"notation\", \"downdiagonalstrike\");\n      break;\n\n    case \"\\\\sout\":\n      node.setAttribute(\"notation\", \"horizontalstrike\");\n      break;\n\n    case \"\\\\fbox\":\n      node.setAttribute(\"notation\", \"box\");\n      break;\n\n    case \"\\\\fcolorbox\":\n    case \"\\\\colorbox\":\n      // <menclose> doesn't have a good notation option. So use <mpadded>\n      // instead. Set some attributes that come included with <menclose>.\n      fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;\n      node.setAttribute(\"width\", \"+\" + 2 * fboxsep + \"pt\");\n      node.setAttribute(\"height\", \"+\" + 2 * fboxsep + \"pt\");\n      node.setAttribute(\"lspace\", fboxsep + \"pt\"); //\n\n      node.setAttribute(\"voffset\", fboxsep + \"pt\");\n\n      if (group.label === \"\\\\fcolorbox\") {\n        var thk = Math.max(options.fontMetrics().fboxrule, // default\n        options.minRuleThickness // user override\n        );\n        node.setAttribute(\"style\", \"border: \" + thk + \"em solid \" + String(group.borderColor));\n      }\n\n      break;\n\n    case \"\\\\xcancel\":\n      node.setAttribute(\"notation\", \"updiagonalstrike downdiagonalstrike\");\n      break;\n  }\n\n  if (group.backgroundColor) {\n    node.setAttribute(\"mathbackground\", group.backgroundColor);\n  }\n\n  return node;\n};\n\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\colorbox\"],\n  props: {\n    numArgs: 2,\n    allowedInText: true,\n    greediness: 3,\n    argTypes: [\"color\", \"text\"]\n  },\n  handler: function handler(_ref, args, optArgs) {\n    var parser = _ref.parser,\n        funcName = _ref.funcName;\n    var color = assertNodeType(args[0], \"color-token\").color;\n    var body = args[1];\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: funcName,\n      backgroundColor: color,\n      body: body\n    };\n  },\n  htmlBuilder: enclose_htmlBuilder,\n  mathmlBuilder: enclose_mathmlBuilder\n});\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\fcolorbox\"],\n  props: {\n    numArgs: 3,\n    allowedInText: true,\n    greediness: 3,\n    argTypes: [\"color\", \"color\", \"text\"]\n  },\n  handler: function handler(_ref2, args, optArgs) {\n    var parser = _ref2.parser,\n        funcName = _ref2.funcName;\n    var borderColor = assertNodeType(args[0], \"color-token\").color;\n    var backgroundColor = assertNodeType(args[1], \"color-token\").color;\n    var body = args[2];\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: funcName,\n      backgroundColor: backgroundColor,\n      borderColor: borderColor,\n      body: body\n    };\n  },\n  htmlBuilder: enclose_htmlBuilder,\n  mathmlBuilder: enclose_mathmlBuilder\n});\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\fbox\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"hbox\"],\n    allowedInText: true\n  },\n  handler: function handler(_ref3, args) {\n    var parser = _ref3.parser;\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: \"\\\\fbox\",\n      body: args[0]\n    };\n  }\n});\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\cancel\", \"\\\\bcancel\", \"\\\\xcancel\", \"\\\\sout\"],\n  props: {\n    numArgs: 1\n  },\n  handler: function handler(_ref4, args, optArgs) {\n    var parser = _ref4.parser,\n        funcName = _ref4.funcName;\n    var body = args[0];\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: funcName,\n      body: body\n    };\n  },\n  htmlBuilder: enclose_htmlBuilder,\n  mathmlBuilder: enclose_mathmlBuilder\n});\n// CONCATENATED MODULE: ./src/defineEnvironment.js\n\n\n/**\n * All registered environments.\n * `environments.js` exports this same dictionary again and makes it public.\n * `Parser.js` requires this dictionary via `environments.js`.\n */\nvar _environments = {};\nfunction defineEnvironment(_ref) {\n  var type = _ref.type,\n      names = _ref.names,\n      props = _ref.props,\n      handler = _ref.handler,\n      htmlBuilder = _ref.htmlBuilder,\n      mathmlBuilder = _ref.mathmlBuilder;\n  // Set default values of environments.\n  var data = {\n    type: type,\n    numArgs: props.numArgs || 0,\n    greediness: 1,\n    allowedInText: false,\n    numOptionalArgs: 0,\n    handler: handler\n  };\n\n  for (var i = 0; i < names.length; ++i) {\n    // TODO: The value type of _environments should be a type union of all\n    // possible `EnvSpec<>` possibilities instead of `EnvSpec<*>`, which is\n    // an existential type.\n    // $FlowFixMe\n    _environments[names[i]] = data;\n  }\n\n  if (htmlBuilder) {\n    _htmlGroupBuilders[type] = htmlBuilder;\n  }\n\n  if (mathmlBuilder) {\n    _mathmlGroupBuilders[type] = mathmlBuilder;\n  }\n}\n// CONCATENATED MODULE: ./src/environments/array.js\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getHLines(parser) {\n  // Return an array. The array length = number of hlines.\n  // Each element in the array tells if the line is dashed.\n  var hlineInfo = [];\n  parser.consumeSpaces();\n  var nxt = parser.fetch().text;\n\n  while (nxt === \"\\\\hline\" || nxt === \"\\\\hdashline\") {\n    parser.consume();\n    hlineInfo.push(nxt === \"\\\\hdashline\");\n    parser.consumeSpaces();\n    nxt = parser.fetch().text;\n  }\n\n  return hlineInfo;\n}\n/**\n * Parse the body of the environment, with rows delimited by \\\\ and\n * columns delimited by &, and create a nested list in row-major order\n * with one group per cell.  If given an optional argument style\n * (\"text\", \"display\", etc.), then each cell is cast into that style.\n */\n\n\nfunction parseArray(parser, _ref, style) {\n  var hskipBeforeAndAfter = _ref.hskipBeforeAndAfter,\n      addJot = _ref.addJot,\n      cols = _ref.cols,\n      arraystretch = _ref.arraystretch,\n      colSeparationType = _ref.colSeparationType;\n  // Parse body of array with \\\\ temporarily mapped to \\cr\n  parser.gullet.beginGroup();\n  parser.gullet.macros.set(\"\\\\\\\\\", \"\\\\cr\"); // Get current arraystretch if it's not set by the environment\n\n  if (!arraystretch) {\n    var stretch = parser.gullet.expandMacroAsText(\"\\\\arraystretch\");\n\n    if (stretch == null) {\n      // Default \\arraystretch from lttab.dtx\n      arraystretch = 1;\n    } else {\n      arraystretch = parseFloat(stretch);\n\n      if (!arraystretch || arraystretch < 0) {\n        throw new src_ParseError(\"Invalid \\\\arraystretch: \" + stretch);\n      }\n    }\n  } // Start group for first cell\n\n\n  parser.gullet.beginGroup();\n  var row = [];\n  var body = [row];\n  var rowGaps = [];\n  var hLinesBeforeRow = []; // Test for \\hline at the top of the array.\n\n  hLinesBeforeRow.push(getHLines(parser));\n\n  while (true) {\n    // eslint-disable-line no-constant-condition\n    // Parse each cell in its own group (namespace)\n    var cell = parser.parseExpression(false, \"\\\\cr\");\n    parser.gullet.endGroup();\n    parser.gullet.beginGroup();\n    cell = {\n      type: \"ordgroup\",\n      mode: parser.mode,\n      body: cell\n    };\n\n    if (style) {\n      cell = {\n        type: \"styling\",\n        mode: parser.mode,\n        style: style,\n        body: [cell]\n      };\n    }\n\n    row.push(cell);\n    var next = parser.fetch().text;\n\n    if (next === \"&\") {\n      parser.consume();\n    } else if (next === \"\\\\end\") {\n      // Arrays terminate newlines with `\\crcr` which consumes a `\\cr` if\n      // the last line is empty.\n      // NOTE: Currently, `cell` is the last item added into `row`.\n      if (row.length === 1 && cell.type === \"styling\" && cell.body[0].body.length === 0) {\n        body.pop();\n      }\n\n      if (hLinesBeforeRow.length < body.length + 1) {\n        hLinesBeforeRow.push([]);\n      }\n\n      break;\n    } else if (next === \"\\\\cr\") {\n      var cr = assertNodeType(parser.parseFunction(), \"cr\");\n      rowGaps.push(cr.size); // check for \\hline(s) following the row separator\n\n      hLinesBeforeRow.push(getHLines(parser));\n      row = [];\n      body.push(row);\n    } else {\n      throw new src_ParseError(\"Expected & or \\\\\\\\ or \\\\cr or \\\\end\", parser.nextToken);\n    }\n  } // End cell group\n\n\n  parser.gullet.endGroup(); // End array group defining \\\\\n\n  parser.gullet.endGroup();\n  return {\n    type: \"array\",\n    mode: parser.mode,\n    addJot: addJot,\n    arraystretch: arraystretch,\n    body: body,\n    cols: cols,\n    rowGaps: rowGaps,\n    hskipBeforeAndAfter: hskipBeforeAndAfter,\n    hLinesBeforeRow: hLinesBeforeRow,\n    colSeparationType: colSeparationType\n  };\n} // Decides on a style for cells in an array according to whether the given\n// environment name starts with the letter 'd'.\n\n\nfunction dCellStyle(envName) {\n  if (envName.substr(0, 1) === \"d\") {\n    return \"display\";\n  } else {\n    return \"text\";\n  }\n}\n\nvar array_htmlBuilder = function htmlBuilder(group, options) {\n  var r;\n  var c;\n  var nr = group.body.length;\n  var hLinesBeforeRow = group.hLinesBeforeRow;\n  var nc = 0;\n  var body = new Array(nr);\n  var hlines = [];\n  var ruleThickness = Math.max( // From LaTeX \\showthe\\arrayrulewidth. Equals 0.04 em.\n  options.fontMetrics().arrayRuleWidth, options.minRuleThickness // User override.\n  ); // Horizontal spacing\n\n  var pt = 1 / options.fontMetrics().ptPerEm;\n  var arraycolsep = 5 * pt; // default value, i.e. \\arraycolsep in article.cls\n\n  if (group.colSeparationType && group.colSeparationType === \"small\") {\n    // We're in a {smallmatrix}. Default column space is \\thickspace,\n    // i.e. 5/18em = 0.2778em, per amsmath.dtx for {smallmatrix}.\n    // But that needs adjustment because LaTeX applies \\scriptstyle to the\n    // entire array, including the colspace, but this function applies\n    // \\scriptstyle only inside each element.\n    var localMultiplier = options.havingStyle(src_Style.SCRIPT).sizeMultiplier;\n    arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);\n  } // Vertical spacing\n\n\n  var baselineskip = 12 * pt; // see size10.clo\n  // Default \\jot from ltmath.dtx\n  // TODO(edemaine): allow overriding \\jot via \\setlength (#687)\n\n  var jot = 3 * pt;\n  var arrayskip = group.arraystretch * baselineskip;\n  var arstrutHeight = 0.7 * arrayskip; // \\strutbox in ltfsstrc.dtx and\n\n  var arstrutDepth = 0.3 * arrayskip; // \\@arstrutbox in lttab.dtx\n\n  var totalHeight = 0; // Set a position for \\hline(s) at the top of the array, if any.\n\n  function setHLinePos(hlinesInGap) {\n    for (var i = 0; i < hlinesInGap.length; ++i) {\n      if (i > 0) {\n        totalHeight += 0.25;\n      }\n\n      hlines.push({\n        pos: totalHeight,\n        isDashed: hlinesInGap[i]\n      });\n    }\n  }\n\n  setHLinePos(hLinesBeforeRow[0]);\n\n  for (r = 0; r < group.body.length; ++r) {\n    var inrow = group.body[r];\n    var height = arstrutHeight; // \\@array adds an \\@arstrut\n\n    var depth = arstrutDepth; // to each tow (via the template)\n\n    if (nc < inrow.length) {\n      nc = inrow.length;\n    }\n\n    var outrow = new Array(inrow.length);\n\n    for (c = 0; c < inrow.length; ++c) {\n      var elt = buildHTML_buildGroup(inrow[c], options);\n\n      if (depth < elt.depth) {\n        depth = elt.depth;\n      }\n\n      if (height < elt.height) {\n        height = elt.height;\n      }\n\n      outrow[c] = elt;\n    }\n\n    var rowGap = group.rowGaps[r];\n    var gap = 0;\n\n    if (rowGap) {\n      gap = units_calculateSize(rowGap, options);\n\n      if (gap > 0) {\n        // \\@argarraycr\n        gap += arstrutDepth;\n\n        if (depth < gap) {\n          depth = gap; // \\@xargarraycr\n        }\n\n        gap = 0;\n      }\n    } // In AMS multiline environments such as aligned and gathered, rows\n    // correspond to lines that have additional \\jot added to the\n    // \\baselineskip via \\openup.\n\n\n    if (group.addJot) {\n      depth += jot;\n    }\n\n    outrow.height = height;\n    outrow.depth = depth;\n    totalHeight += height;\n    outrow.pos = totalHeight;\n    totalHeight += depth + gap; // \\@yargarraycr\n\n    body[r] = outrow; // Set a position for \\hline(s), if any.\n\n    setHLinePos(hLinesBeforeRow[r + 1]);\n  }\n\n  var offset = totalHeight / 2 + options.fontMetrics().axisHeight;\n  var colDescriptions = group.cols || [];\n  var cols = [];\n  var colSep;\n  var colDescrNum;\n\n  for (c = 0, colDescrNum = 0; // Continue while either there are more columns or more column\n  // descriptions, so trailing separators don't get lost.\n  c < nc || colDescrNum < colDescriptions.length; ++c, ++colDescrNum) {\n    var colDescr = colDescriptions[colDescrNum] || {};\n    var firstSeparator = true;\n\n    while (colDescr.type === \"separator\") {\n      // If there is more than one separator in a row, add a space\n      // between them.\n      if (!firstSeparator) {\n        colSep = buildCommon.makeSpan([\"arraycolsep\"], []);\n        colSep.style.width = options.fontMetrics().doubleRuleSep + \"em\";\n        cols.push(colSep);\n      }\n\n      if (colDescr.separator === \"|\" || colDescr.separator === \":\") {\n        var lineType = colDescr.separator === \"|\" ? \"solid\" : \"dashed\";\n        var separator = buildCommon.makeSpan([\"vertical-separator\"], [], options);\n        separator.style.height = totalHeight + \"em\";\n        separator.style.borderRightWidth = ruleThickness + \"em\";\n        separator.style.borderRightStyle = lineType;\n        separator.style.margin = \"0 -\" + ruleThickness / 2 + \"em\";\n        separator.style.verticalAlign = -(totalHeight - offset) + \"em\";\n        cols.push(separator);\n      } else {\n        throw new src_ParseError(\"Invalid separator type: \" + colDescr.separator);\n      }\n\n      colDescrNum++;\n      colDescr = colDescriptions[colDescrNum] || {};\n      firstSeparator = false;\n    }\n\n    if (c >= nc) {\n      continue;\n    }\n\n    var sepwidth = void 0;\n\n    if (c > 0 || group.hskipBeforeAndAfter) {\n      sepwidth = utils.deflt(colDescr.pregap, arraycolsep);\n\n      if (sepwidth !== 0) {\n        colSep = buildCommon.makeSpan([\"arraycolsep\"], []);\n        colSep.style.width = sepwidth + \"em\";\n        cols.push(colSep);\n      }\n    }\n\n    var col = [];\n\n    for (r = 0; r < nr; ++r) {\n      var row = body[r];\n      var elem = row[c];\n\n      if (!elem) {\n        continue;\n      }\n\n      var shift = row.pos - offset;\n      elem.depth = row.depth;\n      elem.height = row.height;\n      col.push({\n        type: \"elem\",\n        elem: elem,\n        shift: shift\n      });\n    }\n\n    col = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: col\n    }, options);\n    col = buildCommon.makeSpan([\"col-align-\" + (colDescr.align || \"c\")], [col]);\n    cols.push(col);\n\n    if (c < nc - 1 || group.hskipBeforeAndAfter) {\n      sepwidth = utils.deflt(colDescr.postgap, arraycolsep);\n\n      if (sepwidth !== 0) {\n        colSep = buildCommon.makeSpan([\"arraycolsep\"], []);\n        colSep.style.width = sepwidth + \"em\";\n        cols.push(colSep);\n      }\n    }\n  }\n\n  body = buildCommon.makeSpan([\"mtable\"], cols); // Add \\hline(s), if any.\n\n  if (hlines.length > 0) {\n    var line = buildCommon.makeLineSpan(\"hline\", options, ruleThickness);\n    var dashes = buildCommon.makeLineSpan(\"hdashline\", options, ruleThickness);\n    var vListElems = [{\n      type: \"elem\",\n      elem: body,\n      shift: 0\n    }];\n\n    while (hlines.length > 0) {\n      var hline = hlines.pop();\n      var lineShift = hline.pos - offset;\n\n      if (hline.isDashed) {\n        vListElems.push({\n          type: \"elem\",\n          elem: dashes,\n          shift: lineShift\n        });\n      } else {\n        vListElems.push({\n          type: \"elem\",\n          elem: line,\n          shift: lineShift\n        });\n      }\n    }\n\n    body = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: vListElems\n    }, options);\n  }\n\n  return buildCommon.makeSpan([\"mord\"], [body], options);\n};\n\nvar alignMap = {\n  c: \"center \",\n  l: \"left \",\n  r: \"right \"\n};\n\nvar array_mathmlBuilder = function mathmlBuilder(group, options) {\n  var table = new mathMLTree.MathNode(\"mtable\", group.body.map(function (row) {\n    return new mathMLTree.MathNode(\"mtr\", row.map(function (cell) {\n      return new mathMLTree.MathNode(\"mtd\", [buildMathML_buildGroup(cell, options)]);\n    }));\n  })); // Set column alignment, row spacing, column spacing, and\n  // array lines by setting attributes on the table element.\n  // Set the row spacing. In MathML, we specify a gap distance.\n  // We do not use rowGap[] because MathML automatically increases\n  // cell height with the height/depth of the element content.\n  // LaTeX \\arraystretch multiplies the row baseline-to-baseline distance.\n  // We simulate this by adding (arraystretch - 1)em to the gap. This\n  // does a reasonable job of adjusting arrays containing 1 em tall content.\n  // The 0.16 and 0.09 values are found emprically. They produce an array\n  // similar to LaTeX and in which content does not interfere with \\hines.\n\n  var gap = group.arraystretch === 0.5 ? 0.1 // {smallmatrix}, {subarray}\n  : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);\n  table.setAttribute(\"rowspacing\", gap + \"em\"); // MathML table lines go only between cells.\n  // To place a line on an edge we'll use <menclose>, if necessary.\n\n  var menclose = \"\";\n  var align = \"\";\n\n  if (group.cols) {\n    // Find column alignment, column spacing, and  vertical lines.\n    var cols = group.cols;\n    var columnLines = \"\";\n    var prevTypeWasAlign = false;\n    var iStart = 0;\n    var iEnd = cols.length;\n\n    if (cols[0].type === \"separator\") {\n      menclose += \"top \";\n      iStart = 1;\n    }\n\n    if (cols[cols.length - 1].type === \"separator\") {\n      menclose += \"bottom \";\n      iEnd -= 1;\n    }\n\n    for (var i = iStart; i < iEnd; i++) {\n      if (cols[i].type === \"align\") {\n        align += alignMap[cols[i].align];\n\n        if (prevTypeWasAlign) {\n          columnLines += \"none \";\n        }\n\n        prevTypeWasAlign = true;\n      } else if (cols[i].type === \"separator\") {\n        // MathML accepts only single lines between cells.\n        // So we read only the first of consecutive separators.\n        if (prevTypeWasAlign) {\n          columnLines += cols[i].separator === \"|\" ? \"solid \" : \"dashed \";\n          prevTypeWasAlign = false;\n        }\n      }\n    }\n\n    table.setAttribute(\"columnalign\", align.trim());\n\n    if (/[sd]/.test(columnLines)) {\n      table.setAttribute(\"columnlines\", columnLines.trim());\n    }\n  } // Set column spacing.\n\n\n  if (group.colSeparationType === \"align\") {\n    var _cols = group.cols || [];\n\n    var spacing = \"\";\n\n    for (var _i = 1; _i < _cols.length; _i++) {\n      spacing += _i % 2 ? \"0em \" : \"1em \";\n    }\n\n    table.setAttribute(\"columnspacing\", spacing.trim());\n  } else if (group.colSeparationType === \"alignat\") {\n    table.setAttribute(\"columnspacing\", \"0em\");\n  } else if (group.colSeparationType === \"small\") {\n    table.setAttribute(\"columnspacing\", \"0.2778em\");\n  } else {\n    table.setAttribute(\"columnspacing\", \"1em\");\n  } // Address \\hline and \\hdashline\n\n\n  var rowLines = \"\";\n  var hlines = group.hLinesBeforeRow;\n  menclose += hlines[0].length > 0 ? \"left \" : \"\";\n  menclose += hlines[hlines.length - 1].length > 0 ? \"right \" : \"\";\n\n  for (var _i2 = 1; _i2 < hlines.length - 1; _i2++) {\n    rowLines += hlines[_i2].length === 0 ? \"none \" // MathML accepts only a single line between rows. Read one element.\n    : hlines[_i2][0] ? \"dashed \" : \"solid \";\n  }\n\n  if (/[sd]/.test(rowLines)) {\n    table.setAttribute(\"rowlines\", rowLines.trim());\n  }\n\n  if (menclose !== \"\") {\n    table = new mathMLTree.MathNode(\"menclose\", [table]);\n    table.setAttribute(\"notation\", menclose.trim());\n  }\n\n  if (group.arraystretch && group.arraystretch < 1) {\n    // A small array. Wrap in scriptstyle so row gap is not too large.\n    table = new mathMLTree.MathNode(\"mstyle\", [table]);\n    table.setAttribute(\"scriptlevel\", \"1\");\n  }\n\n  return table;\n}; // Convenience function for aligned and alignedat environments.\n\n\nvar array_alignedHandler = function alignedHandler(context, args) {\n  var cols = [];\n  var res = parseArray(context.parser, {\n    cols: cols,\n    addJot: true\n  }, \"display\"); // Determining number of columns.\n  // 1. If the first argument is given, we use it as a number of columns,\n  //    and makes sure that each row doesn't exceed that number.\n  // 2. Otherwise, just count number of columns = maximum number\n  //    of cells in each row (\"aligned\" mode -- isAligned will be true).\n  //\n  // At the same time, prepend empty group {} at beginning of every second\n  // cell in each row (starting with second cell) so that operators become\n  // binary.  This behavior is implemented in amsmath's \\start@aligned.\n\n  var numMaths;\n  var numCols = 0;\n  var emptyGroup = {\n    type: \"ordgroup\",\n    mode: context.mode,\n    body: []\n  };\n  var ordgroup = checkNodeType(args[0], \"ordgroup\");\n\n  if (ordgroup) {\n    var arg0 = \"\";\n\n    for (var i = 0; i < ordgroup.body.length; i++) {\n      var textord = assertNodeType(ordgroup.body[i], \"textord\");\n      arg0 += textord.text;\n    }\n\n    numMaths = Number(arg0);\n    numCols = numMaths * 2;\n  }\n\n  var isAligned = !numCols;\n  res.body.forEach(function (row) {\n    for (var _i3 = 1; _i3 < row.length; _i3 += 2) {\n      // Modify ordgroup node within styling node\n      var styling = assertNodeType(row[_i3], \"styling\");\n\n      var _ordgroup = assertNodeType(styling.body[0], \"ordgroup\");\n\n      _ordgroup.body.unshift(emptyGroup);\n    }\n\n    if (!isAligned) {\n      // Case 1\n      var curMaths = row.length / 2;\n\n      if (numMaths < curMaths) {\n        throw new src_ParseError(\"Too many math in a row: \" + (\"expected \" + numMaths + \", but got \" + curMaths), row[0]);\n      }\n    } else if (numCols < row.length) {\n      // Case 2\n      numCols = row.length;\n    }\n  }); // Adjusting alignment.\n  // In aligned mode, we add one \\qquad between columns;\n  // otherwise we add nothing.\n\n  for (var _i4 = 0; _i4 < numCols; ++_i4) {\n    var align = \"r\";\n    var pregap = 0;\n\n    if (_i4 % 2 === 1) {\n      align = \"l\";\n    } else if (_i4 > 0 && isAligned) {\n      // \"aligned\" mode.\n      pregap = 1; // add one \\quad\n    }\n\n    cols[_i4] = {\n      type: \"align\",\n      align: align,\n      pregap: pregap,\n      postgap: 0\n    };\n  }\n\n  res.colSeparationType = isAligned ? \"align\" : \"alignat\";\n  return res;\n}; // Arrays are part of LaTeX, defined in lttab.dtx so its documentation\n// is part of the source2e.pdf file of LaTeX2e source documentation.\n// {darray} is an {array} environment where cells are set in \\displaystyle,\n// as defined in nccmath.sty.\n\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"array\", \"darray\"],\n  props: {\n    numArgs: 1\n  },\n  handler: function handler(context, args) {\n    // Since no types are specified above, the two possibilities are\n    // - The argument is wrapped in {} or [], in which case Parser's\n    //   parseGroup() returns an \"ordgroup\" wrapping some symbol node.\n    // - The argument is a bare symbol node.\n    var symNode = checkSymbolNodeType(args[0]);\n    var colalign = symNode ? [args[0]] : assertNodeType(args[0], \"ordgroup\").body;\n    var cols = colalign.map(function (nde) {\n      var node = assertSymbolNodeType(nde);\n      var ca = node.text;\n\n      if (\"lcr\".indexOf(ca) !== -1) {\n        return {\n          type: \"align\",\n          align: ca\n        };\n      } else if (ca === \"|\") {\n        return {\n          type: \"separator\",\n          separator: \"|\"\n        };\n      } else if (ca === \":\") {\n        return {\n          type: \"separator\",\n          separator: \":\"\n        };\n      }\n\n      throw new src_ParseError(\"Unknown column alignment: \" + ca, nde);\n    });\n    var res = {\n      cols: cols,\n      hskipBeforeAndAfter: true // \\@preamble in lttab.dtx\n\n    };\n    return parseArray(context.parser, res, dCellStyle(context.envName));\n  },\n  htmlBuilder: array_htmlBuilder,\n  mathmlBuilder: array_mathmlBuilder\n}); // The matrix environments of amsmath builds on the array environment\n// of LaTeX, which is discussed above.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"matrix\", \"pmatrix\", \"bmatrix\", \"Bmatrix\", \"vmatrix\", \"Vmatrix\"],\n  props: {\n    numArgs: 0\n  },\n  handler: function handler(context) {\n    var delimiters = {\n      \"matrix\": null,\n      \"pmatrix\": [\"(\", \")\"],\n      \"bmatrix\": [\"[\", \"]\"],\n      \"Bmatrix\": [\"\\\\{\", \"\\\\}\"],\n      \"vmatrix\": [\"|\", \"|\"],\n      \"Vmatrix\": [\"\\\\Vert\", \"\\\\Vert\"]\n    }[context.envName]; // \\hskip -\\arraycolsep in amsmath\n\n    var payload = {\n      hskipBeforeAndAfter: false\n    };\n    var res = parseArray(context.parser, payload, dCellStyle(context.envName));\n    return delimiters ? {\n      type: \"leftright\",\n      mode: context.mode,\n      body: [res],\n      left: delimiters[0],\n      right: delimiters[1],\n      rightColor: undefined // \\right uninfluenced by \\color in array\n\n    } : res;\n  },\n  htmlBuilder: array_htmlBuilder,\n  mathmlBuilder: array_mathmlBuilder\n});\ndefineEnvironment({\n  type: \"array\",\n  names: [\"smallmatrix\"],\n  props: {\n    numArgs: 0\n  },\n  handler: function handler(context) {\n    var payload = {\n      arraystretch: 0.5\n    };\n    var res = parseArray(context.parser, payload, \"script\");\n    res.colSeparationType = \"small\";\n    return res;\n  },\n  htmlBuilder: array_htmlBuilder,\n  mathmlBuilder: array_mathmlBuilder\n});\ndefineEnvironment({\n  type: \"array\",\n  names: [\"subarray\"],\n  props: {\n    numArgs: 1\n  },\n  handler: function handler(context, args) {\n    // Parsing of {subarray} is similar to {array}\n    var symNode = checkSymbolNodeType(args[0]);\n    var colalign = symNode ? [args[0]] : assertNodeType(args[0], \"ordgroup\").body;\n    var cols = colalign.map(function (nde) {\n      var node = assertSymbolNodeType(nde);\n      var ca = node.text; // {subarray} only recognizes \"l\" & \"c\"\n\n      if (\"lc\".indexOf(ca) !== -1) {\n        return {\n          type: \"align\",\n          align: ca\n        };\n      }\n\n      throw new src_ParseError(\"Unknown column alignment: \" + ca, nde);\n    });\n\n    if (cols.length > 1) {\n      throw new src_ParseError(\"{subarray} can contain only one column\");\n    }\n\n    var res = {\n      cols: cols,\n      hskipBeforeAndAfter: false,\n      arraystretch: 0.5\n    };\n    res = parseArray(context.parser, res, \"script\");\n\n    if (res.body[0].length > 1) {\n      throw new src_ParseError(\"{subarray} can contain only one column\");\n    }\n\n    return res;\n  },\n  htmlBuilder: array_htmlBuilder,\n  mathmlBuilder: array_mathmlBuilder\n}); // A cases environment (in amsmath.sty) is almost equivalent to\n// \\def\\arraystretch{1.2}%\n// \\left\\{\\begin{array}{@{}l@{\\quad}l@{}} … \\end{array}\\right.\n// {dcases} is a {cases} environment where cells are set in \\displaystyle,\n// as defined in mathtools.sty.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"cases\", \"dcases\"],\n  props: {\n    numArgs: 0\n  },\n  handler: function handler(context) {\n    var payload = {\n      arraystretch: 1.2,\n      cols: [{\n        type: \"align\",\n        align: \"l\",\n        pregap: 0,\n        // TODO(kevinb) get the current style.\n        // For now we use the metrics for TEXT style which is what we were\n        // doing before.  Before attempting to get the current style we\n        // should look at TeX's behavior especially for \\over and matrices.\n        postgap: 1.0\n        /* 1em quad */\n\n      }, {\n        type: \"align\",\n        align: \"l\",\n        pregap: 0,\n        postgap: 0\n      }]\n    };\n    var res = parseArray(context.parser, payload, dCellStyle(context.envName));\n    return {\n      type: \"leftright\",\n      mode: context.mode,\n      body: [res],\n      left: \"\\\\{\",\n      right: \".\",\n      rightColor: undefined\n    };\n  },\n  htmlBuilder: array_htmlBuilder,\n  mathmlBuilder: array_mathmlBuilder\n}); // An aligned environment is like the align* environment\n// except it operates within math mode.\n// Note that we assume \\nomallineskiplimit to be zero,\n// so that \\strut@ is the same as \\strut.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"aligned\"],\n  props: {\n    numArgs: 0\n  },\n  handler: array_alignedHandler,\n  htmlBuilder: array_htmlBuilder,\n  mathmlBuilder: array_mathmlBuilder\n}); // A gathered environment is like an array environment with one centered\n// column, but where rows are considered lines so get \\jot line spacing\n// and contents are set in \\displaystyle.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"gathered\"],\n  props: {\n    numArgs: 0\n  },\n  handler: function handler(context) {\n    var res = {\n      cols: [{\n        type: \"align\",\n        align: \"c\"\n      }],\n      addJot: true\n    };\n    return parseArray(context.parser, res, \"display\");\n  },\n  htmlBuilder: array_htmlBuilder,\n  mathmlBuilder: array_mathmlBuilder\n}); // alignat environment is like an align environment, but one must explicitly\n// specify maximum number of columns in each row, and can adjust spacing between\n// each columns.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"alignedat\"],\n  // One for numbered and for unnumbered;\n  // but, KaTeX doesn't supports math numbering yet,\n  // they make no difference for now.\n  props: {\n    numArgs: 1\n  },\n  handler: array_alignedHandler,\n  htmlBuilder: array_htmlBuilder,\n  mathmlBuilder: array_mathmlBuilder\n}); // Catch \\hline outside array environment\n\ndefineFunction({\n  type: \"text\",\n  // Doesn't matter what this is.\n  names: [\"\\\\hline\", \"\\\\hdashline\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    allowedInMath: true\n  },\n  handler: function handler(context, args) {\n    throw new src_ParseError(context.funcName + \" valid only within array environment\");\n  }\n});\n// CONCATENATED MODULE: ./src/environments.js\n\nvar environments = _environments;\n/* harmony default export */ var src_environments = (environments); // All environment definitions should be imported below\n\n\n// CONCATENATED MODULE: ./src/functions/environment.js\n\n\n\n // Environment delimiters. HTML/MathML rendering is defined in the corresponding\n// defineEnvironment definitions.\n// $FlowFixMe, \"environment\" handler returns an environment ParseNode\n\ndefineFunction({\n  type: \"environment\",\n  names: [\"\\\\begin\", \"\\\\end\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"text\"]\n  },\n  handler: function handler(_ref, args) {\n    var parser = _ref.parser,\n        funcName = _ref.funcName;\n    var nameGroup = args[0];\n\n    if (nameGroup.type !== \"ordgroup\") {\n      throw new src_ParseError(\"Invalid environment name\", nameGroup);\n    }\n\n    var envName = \"\";\n\n    for (var i = 0; i < nameGroup.body.length; ++i) {\n      envName += assertNodeType(nameGroup.body[i], \"textord\").text;\n    }\n\n    if (funcName === \"\\\\begin\") {\n      // begin...end is similar to left...right\n      if (!src_environments.hasOwnProperty(envName)) {\n        throw new src_ParseError(\"No such environment: \" + envName, nameGroup);\n      } // Build the environment object. Arguments and other information will\n      // be made available to the begin and end methods using properties.\n\n\n      var env = src_environments[envName];\n\n      var _parser$parseArgument = parser.parseArguments(\"\\\\begin{\" + envName + \"}\", env),\n          _args = _parser$parseArgument.args,\n          optArgs = _parser$parseArgument.optArgs;\n\n      var context = {\n        mode: parser.mode,\n        envName: envName,\n        parser: parser\n      };\n      var result = env.handler(context, _args, optArgs);\n      parser.expect(\"\\\\end\", false);\n      var endNameToken = parser.nextToken;\n      var end = assertNodeType(parser.parseFunction(), \"environment\");\n\n      if (end.name !== envName) {\n        throw new src_ParseError(\"Mismatch: \\\\begin{\" + envName + \"} matched by \\\\end{\" + end.name + \"}\", endNameToken);\n      }\n\n      return result;\n    }\n\n    return {\n      type: \"environment\",\n      mode: parser.mode,\n      name: envName,\n      nameGroup: nameGroup\n    };\n  }\n});\n// CONCATENATED MODULE: ./src/functions/mclass.js\n\n\n\n\n\n\nvar mclass_makeSpan = buildCommon.makeSpan;\n\nfunction mclass_htmlBuilder(group, options) {\n  var elements = buildHTML_buildExpression(group.body, options, true);\n  return mclass_makeSpan([group.mclass], elements, options);\n}\n\nfunction mclass_mathmlBuilder(group, options) {\n  var node;\n  var inner = buildMathML_buildExpression(group.body, options);\n\n  if (group.mclass === \"minner\") {\n    return mathMLTree.newDocumentFragment(inner);\n  } else if (group.mclass === \"mord\") {\n    if (group.isCharacterBox) {\n      node = inner[0];\n      node.type = \"mi\";\n    } else {\n      node = new mathMLTree.MathNode(\"mi\", inner);\n    }\n  } else {\n    if (group.isCharacterBox) {\n      node = inner[0];\n      node.type = \"mo\";\n    } else {\n      node = new mathMLTree.MathNode(\"mo\", inner);\n    } // Set spacing based on what is the most likely adjacent atom type.\n    // See TeXbook p170.\n\n\n    if (group.mclass === \"mbin\") {\n      node.attributes.lspace = \"0.22em\"; // medium space\n\n      node.attributes.rspace = \"0.22em\";\n    } else if (group.mclass === \"mpunct\") {\n      node.attributes.lspace = \"0em\";\n      node.attributes.rspace = \"0.17em\"; // thinspace\n    } else if (group.mclass === \"mopen\" || group.mclass === \"mclose\") {\n      node.attributes.lspace = \"0em\";\n      node.attributes.rspace = \"0em\";\n    } // MathML <mo> default space is 5/18 em, so <mrel> needs no action.\n    // Ref: https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mo\n\n  }\n\n  return node;\n} // Math class commands except \\mathop\n\n\ndefineFunction({\n  type: \"mclass\",\n  names: [\"\\\\mathord\", \"\\\\mathbin\", \"\\\\mathrel\", \"\\\\mathopen\", \"\\\\mathclose\", \"\\\\mathpunct\", \"\\\\mathinner\"],\n  props: {\n    numArgs: 1\n  },\n  handler: function handler(_ref, args) {\n    var parser = _ref.parser,\n        funcName = _ref.funcName;\n    var body = args[0];\n    return {\n      type: \"mclass\",\n      mode: parser.mode,\n      mclass: \"m\" + funcName.substr(5),\n      // TODO(kevinb): don't prefix with 'm'\n      body: defineFunction_ordargument(body),\n      isCharacterBox: utils.isCharacterBox(body)\n    };\n  },\n  htmlBuilder: mclass_htmlBuilder,\n  mathmlBuilder: mclass_mathmlBuilder\n});\nvar binrelClass = function binrelClass(arg) {\n  // \\binrel@ spacing varies with (bin|rel|ord) of the atom in the argument.\n  // (by rendering separately and with {}s before and after, and measuring\n  // the change in spacing).  We'll do roughly the same by detecting the\n  // atom type directly.\n  var atom = arg.type === \"ordgroup\" && arg.body.length ? arg.body[0] : arg;\n\n  if (atom.type === \"atom\" && (atom.family === \"bin\" || atom.family === \"rel\")) {\n    return \"m\" + atom.family;\n  } else {\n    return \"mord\";\n  }\n}; // \\@binrel{x}{y} renders like y but as mbin/mrel/mord if x is mbin/mrel/mord.\n// This is equivalent to \\binrel@{x}\\binrel@@{y} in AMSTeX.\n\ndefineFunction({\n  type: \"mclass\",\n  names: [\"\\\\@binrel\"],\n  props: {\n    numArgs: 2\n  },\n  handler: function handler(_ref2, args) {\n    var parser = _ref2.parser;\n    return {\n      type: \"mclass\",\n      mode: parser.mode,\n      mclass: binrelClass(args[0]),\n      body: [args[1]],\n      isCharacterBox: utils.isCharacterBox(args[1])\n    };\n  }\n}); // Build a relation or stacked op by placing one symbol on top of another\n\ndefineFunction({\n  type: \"mclass\",\n  names: [\"\\\\stackrel\", \"\\\\overset\", \"\\\\underset\"],\n  props: {\n    numArgs: 2\n  },\n  handler: function handler(_ref3, args) {\n    var parser = _ref3.parser,\n        funcName = _ref3.funcName;\n    var baseArg = args[1];\n    var shiftedArg = args[0];\n    var mclass;\n\n    if (funcName !== \"\\\\stackrel\") {\n      // LaTeX applies \\binrel spacing to \\overset and \\underset.\n      mclass = binrelClass(baseArg);\n    } else {\n      mclass = \"mrel\"; // for \\stackrel\n    }\n\n    var baseOp = {\n      type: \"op\",\n      mode: baseArg.mode,\n      limits: true,\n      alwaysHandleSupSub: true,\n      parentIsSupSub: false,\n      symbol: false,\n      suppressBaseShift: funcName !== \"\\\\stackrel\",\n      body: defineFunction_ordargument(baseArg)\n    };\n    var supsub = {\n      type: \"supsub\",\n      mode: shiftedArg.mode,\n      base: baseOp,\n      sup: funcName === \"\\\\underset\" ? null : shiftedArg,\n      sub: funcName === \"\\\\underset\" ? shiftedArg : null\n    };\n    return {\n      type: \"mclass\",\n      mode: parser.mode,\n      mclass: mclass,\n      body: [supsub],\n      isCharacterBox: utils.isCharacterBox(supsub)\n    };\n  },\n  htmlBuilder: mclass_htmlBuilder,\n  mathmlBuilder: mclass_mathmlBuilder\n});\n// CONCATENATED MODULE: ./src/functions/font.js\n// TODO(kevinb): implement \\\\sl and \\\\sc\n\n\n\n\n\n\nvar font_htmlBuilder = function htmlBuilder(group, options) {\n  var font = group.font;\n  var newOptions = options.withFont(font);\n  return buildHTML_buildGroup(group.body, newOptions);\n};\n\nvar font_mathmlBuilder = function mathmlBuilder(group, options) {\n  var font = group.font;\n  var newOptions = options.withFont(font);\n  return buildMathML_buildGroup(group.body, newOptions);\n};\n\nvar fontAliases = {\n  \"\\\\Bbb\": \"\\\\mathbb\",\n  \"\\\\bold\": \"\\\\mathbf\",\n  \"\\\\frak\": \"\\\\mathfrak\",\n  \"\\\\bm\": \"\\\\boldsymbol\"\n};\ndefineFunction({\n  type: \"font\",\n  names: [// styles, except \\boldsymbol defined below\n  \"\\\\mathrm\", \"\\\\mathit\", \"\\\\mathbf\", \"\\\\mathnormal\", // families\n  \"\\\\mathbb\", \"\\\\mathcal\", \"\\\\mathfrak\", \"\\\\mathscr\", \"\\\\mathsf\", \"\\\\mathtt\", // aliases, except \\bm defined below\n  \"\\\\Bbb\", \"\\\\bold\", \"\\\\frak\"],\n  props: {\n    numArgs: 1,\n    greediness: 2\n  },\n  handler: function handler(_ref, args) {\n    var parser = _ref.parser,\n        funcName = _ref.funcName;\n    var body = args[0];\n    var func = funcName;\n\n    if (func in fontAliases) {\n      func = fontAliases[func];\n    }\n\n    return {\n      type: \"font\",\n      mode: parser.mode,\n      font: func.slice(1),\n      body: body\n    };\n  },\n  htmlBuilder: font_htmlBuilder,\n  mathmlBuilder: font_mathmlBuilder\n});\ndefineFunction({\n  type: \"mclass\",\n  names: [\"\\\\boldsymbol\", \"\\\\bm\"],\n  props: {\n    numArgs: 1,\n    greediness: 2\n  },\n  handler: function handler(_ref2, args) {\n    var parser = _ref2.parser;\n    var body = args[0];\n    var isCharacterBox = utils.isCharacterBox(body); // amsbsy.sty's \\boldsymbol uses \\binrel spacing to inherit the\n    // argument's bin|rel|ord status\n\n    return {\n      type: \"mclass\",\n      mode: parser.mode,\n      mclass: binrelClass(body),\n      body: [{\n        type: \"font\",\n        mode: parser.mode,\n        font: \"boldsymbol\",\n        body: body\n      }],\n      isCharacterBox: isCharacterBox\n    };\n  }\n}); // Old font changing functions\n\ndefineFunction({\n  type: \"font\",\n  names: [\"\\\\rm\", \"\\\\sf\", \"\\\\tt\", \"\\\\bf\", \"\\\\it\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n  handler: function handler(_ref3, args) {\n    var parser = _ref3.parser,\n        funcName = _ref3.funcName,\n        breakOnTokenText = _ref3.breakOnTokenText;\n    var mode = parser.mode;\n    var body = parser.parseExpression(true, breakOnTokenText);\n    var style = \"math\" + funcName.slice(1);\n    return {\n      type: \"font\",\n      mode: mode,\n      font: style,\n      body: {\n        type: \"ordgroup\",\n        mode: parser.mode,\n        body: body\n      }\n    };\n  },\n  htmlBuilder: font_htmlBuilder,\n  mathmlBuilder: font_mathmlBuilder\n});\n// CONCATENATED MODULE: ./src/functions/genfrac.js\n\n\n\n\n\n\n\n\n\n\n\nvar genfrac_adjustStyle = function adjustStyle(size, originalStyle) {\n  // Figure out what style this fraction should be in based on the\n  // function used\n  var style = originalStyle;\n\n  if (size === \"display\") {\n    // Get display style as a default.\n    // If incoming style is sub/sup, use style.text() to get correct size.\n    style = style.id >= src_Style.SCRIPT.id ? style.text() : src_Style.DISPLAY;\n  } else if (size === \"text\" && style.size === src_Style.DISPLAY.size) {\n    // We're in a \\tfrac but incoming style is displaystyle, so:\n    style = src_Style.TEXT;\n  } else if (size === \"script\") {\n    style = src_Style.SCRIPT;\n  } else if (size === \"scriptscript\") {\n    style = src_Style.SCRIPTSCRIPT;\n  }\n\n  return style;\n};\n\nvar genfrac_htmlBuilder = function htmlBuilder(group, options) {\n  // Fractions are handled in the TeXbook on pages 444-445, rules 15(a-e).\n  var style = genfrac_adjustStyle(group.size, options.style);\n  var nstyle = style.fracNum();\n  var dstyle = style.fracDen();\n  var newOptions;\n  newOptions = options.havingStyle(nstyle);\n  var numerm = buildHTML_buildGroup(group.numer, newOptions, options);\n\n  if (group.continued) {\n    // \\cfrac inserts a \\strut into the numerator.\n    // Get \\strut dimensions from TeXbook page 353.\n    var hStrut = 8.5 / options.fontMetrics().ptPerEm;\n    var dStrut = 3.5 / options.fontMetrics().ptPerEm;\n    numerm.height = numerm.height < hStrut ? hStrut : numerm.height;\n    numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;\n  }\n\n  newOptions = options.havingStyle(dstyle);\n  var denomm = buildHTML_buildGroup(group.denom, newOptions, options);\n  var rule;\n  var ruleWidth;\n  var ruleSpacing;\n\n  if (group.hasBarLine) {\n    if (group.barSize) {\n      ruleWidth = units_calculateSize(group.barSize, options);\n      rule = buildCommon.makeLineSpan(\"frac-line\", options, ruleWidth);\n    } else {\n      rule = buildCommon.makeLineSpan(\"frac-line\", options);\n    }\n\n    ruleWidth = rule.height;\n    ruleSpacing = rule.height;\n  } else {\n    rule = null;\n    ruleWidth = 0;\n    ruleSpacing = options.fontMetrics().defaultRuleThickness;\n  } // Rule 15b\n\n\n  var numShift;\n  var clearance;\n  var denomShift;\n\n  if (style.size === src_Style.DISPLAY.size || group.size === \"display\") {\n    numShift = options.fontMetrics().num1;\n\n    if (ruleWidth > 0) {\n      clearance = 3 * ruleSpacing;\n    } else {\n      clearance = 7 * ruleSpacing;\n    }\n\n    denomShift = options.fontMetrics().denom1;\n  } else {\n    if (ruleWidth > 0) {\n      numShift = options.fontMetrics().num2;\n      clearance = ruleSpacing;\n    } else {\n      numShift = options.fontMetrics().num3;\n      clearance = 3 * ruleSpacing;\n    }\n\n    denomShift = options.fontMetrics().denom2;\n  }\n\n  var frac;\n\n  if (!rule) {\n    // Rule 15c\n    var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);\n\n    if (candidateClearance < clearance) {\n      numShift += 0.5 * (clearance - candidateClearance);\n      denomShift += 0.5 * (clearance - candidateClearance);\n    }\n\n    frac = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: [{\n        type: \"elem\",\n        elem: denomm,\n        shift: denomShift\n      }, {\n        type: \"elem\",\n        elem: numerm,\n        shift: -numShift\n      }]\n    }, options);\n  } else {\n    // Rule 15d\n    var axisHeight = options.fontMetrics().axisHeight;\n\n    if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {\n      numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));\n    }\n\n    if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {\n      denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));\n    }\n\n    var midShift = -(axisHeight - 0.5 * ruleWidth);\n    frac = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: [{\n        type: \"elem\",\n        elem: denomm,\n        shift: denomShift\n      }, {\n        type: \"elem\",\n        elem: rule,\n        shift: midShift\n      }, {\n        type: \"elem\",\n        elem: numerm,\n        shift: -numShift\n      }]\n    }, options);\n  } // Since we manually change the style sometimes (with \\dfrac or \\tfrac),\n  // account for the possible size change here.\n\n\n  newOptions = options.havingStyle(style);\n  frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;\n  frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier; // Rule 15e\n\n  var delimSize;\n\n  if (style.size === src_Style.DISPLAY.size) {\n    delimSize = options.fontMetrics().delim1;\n  } else {\n    delimSize = options.fontMetrics().delim2;\n  }\n\n  var leftDelim;\n  var rightDelim;\n\n  if (group.leftDelim == null) {\n    leftDelim = makeNullDelimiter(options, [\"mopen\"]);\n  } else {\n    leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, [\"mopen\"]);\n  }\n\n  if (group.continued) {\n    rightDelim = buildCommon.makeSpan([]); // zero width for \\cfrac\n  } else if (group.rightDelim == null) {\n    rightDelim = makeNullDelimiter(options, [\"mclose\"]);\n  } else {\n    rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, [\"mclose\"]);\n  }\n\n  return buildCommon.makeSpan([\"mord\"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan([\"mfrac\"], [frac]), rightDelim], options);\n};\n\nvar genfrac_mathmlBuilder = function mathmlBuilder(group, options) {\n  var node = new mathMLTree.MathNode(\"mfrac\", [buildMathML_buildGroup(group.numer, options), buildMathML_buildGroup(group.denom, options)]);\n\n  if (!group.hasBarLine) {\n    node.setAttribute(\"linethickness\", \"0px\");\n  } else if (group.barSize) {\n    var ruleWidth = units_calculateSize(group.barSize, options);\n    node.setAttribute(\"linethickness\", ruleWidth + \"em\");\n  }\n\n  var style = genfrac_adjustStyle(group.size, options.style);\n\n  if (style.size !== options.style.size) {\n    node = new mathMLTree.MathNode(\"mstyle\", [node]);\n    var isDisplay = style.size === src_Style.DISPLAY.size ? \"true\" : \"false\";\n    node.setAttribute(\"displaystyle\", isDisplay);\n    node.setAttribute(\"scriptlevel\", \"0\");\n  }\n\n  if (group.leftDelim != null || group.rightDelim != null) {\n    var withDelims = [];\n\n    if (group.leftDelim != null) {\n      var leftOp = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(group.leftDelim.replace(\"\\\\\", \"\"))]);\n      leftOp.setAttribute(\"fence\", \"true\");\n      withDelims.push(leftOp);\n    }\n\n    withDelims.push(node);\n\n    if (group.rightDelim != null) {\n      var rightOp = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(group.rightDelim.replace(\"\\\\\", \"\"))]);\n      rightOp.setAttribute(\"fence\", \"true\");\n      withDelims.push(rightOp);\n    }\n\n    return buildMathML_makeRow(withDelims);\n  }\n\n  return node;\n};\n\ndefineFunction({\n  type: \"genfrac\",\n  names: [\"\\\\cfrac\", \"\\\\dfrac\", \"\\\\frac\", \"\\\\tfrac\", \"\\\\dbinom\", \"\\\\binom\", \"\\\\tbinom\", \"\\\\\\\\atopfrac\", // can’t be entered directly\n  \"\\\\\\\\bracefrac\", \"\\\\\\\\brackfrac\"],\n  props: {\n    numArgs: 2,\n    greediness: 2\n  },\n  handler: function handler(_ref, args) {\n    var parser = _ref.parser,\n        funcName = _ref.funcName;\n    var numer = args[0];\n    var denom = args[1];\n    var hasBarLine;\n    var leftDelim = null;\n    var rightDelim = null;\n    var size = \"auto\";\n\n    switch (funcName) {\n      case \"\\\\cfrac\":\n      case \"\\\\dfrac\":\n      case \"\\\\frac\":\n      case \"\\\\tfrac\":\n        hasBarLine = true;\n        break;\n\n      case \"\\\\\\\\atopfrac\":\n        hasBarLine = false;\n        break;\n\n      case \"\\\\dbinom\":\n      case \"\\\\binom\":\n      case \"\\\\tbinom\":\n        hasBarLine = false;\n        leftDelim = \"(\";\n        rightDelim = \")\";\n        break;\n\n      case \"\\\\\\\\bracefrac\":\n        hasBarLine = false;\n        leftDelim = \"\\\\{\";\n        rightDelim = \"\\\\}\";\n        break;\n\n      case \"\\\\\\\\brackfrac\":\n        hasBarLine = false;\n        leftDelim = \"[\";\n        rightDelim = \"]\";\n        break;\n\n      default:\n        throw new Error(\"Unrecognized genfrac command\");\n    }\n\n    switch (funcName) {\n      case \"\\\\cfrac\":\n      case \"\\\\dfrac\":\n      case \"\\\\dbinom\":\n        size = \"display\";\n        break;\n\n      case \"\\\\tfrac\":\n      case \"\\\\tbinom\":\n        size = \"text\";\n        break;\n    }\n\n    return {\n      type: \"genfrac\",\n      mode: parser.mode,\n      continued: funcName === \"\\\\cfrac\",\n      numer: numer,\n      denom: denom,\n      hasBarLine: hasBarLine,\n      leftDelim: leftDelim,\n      rightDelim: rightDelim,\n      size: size,\n      barSize: null\n    };\n  },\n  htmlBuilder: genfrac_htmlBuilder,\n  mathmlBuilder: genfrac_mathmlBuilder\n}); // Infix generalized fractions -- these are not rendered directly, but replaced\n// immediately by one of the variants above.\n\ndefineFunction({\n  type: \"infix\",\n  names: [\"\\\\over\", \"\\\\choose\", \"\\\\atop\", \"\\\\brace\", \"\\\\brack\"],\n  props: {\n    numArgs: 0,\n    infix: true\n  },\n  handler: function handler(_ref2) {\n    var parser = _ref2.parser,\n        funcName = _ref2.funcName,\n        token = _ref2.token;\n    var replaceWith;\n\n    switch (funcName) {\n      case \"\\\\over\":\n        replaceWith = \"\\\\frac\";\n        break;\n\n      case \"\\\\choose\":\n        replaceWith = \"\\\\binom\";\n        break;\n\n      case \"\\\\atop\":\n        replaceWith = \"\\\\\\\\atopfrac\";\n        break;\n\n      case \"\\\\brace\":\n        replaceWith = \"\\\\\\\\bracefrac\";\n        break;\n\n      case \"\\\\brack\":\n        replaceWith = \"\\\\\\\\brackfrac\";\n        break;\n\n      default:\n        throw new Error(\"Unrecognized infix genfrac command\");\n    }\n\n    return {\n      type: \"infix\",\n      mode: parser.mode,\n      replaceWith: replaceWith,\n      token: token\n    };\n  }\n});\nvar stylArray = [\"display\", \"text\", \"script\", \"scriptscript\"];\n\nvar delimFromValue = function delimFromValue(delimString) {\n  var delim = null;\n\n  if (delimString.length > 0) {\n    delim = delimString;\n    delim = delim === \".\" ? null : delim;\n  }\n\n  return delim;\n};\n\ndefineFunction({\n  type: \"genfrac\",\n  names: [\"\\\\genfrac\"],\n  props: {\n    numArgs: 6,\n    greediness: 6,\n    argTypes: [\"math\", \"math\", \"size\", \"text\", \"math\", \"math\"]\n  },\n  handler: function handler(_ref3, args) {\n    var parser = _ref3.parser;\n    var numer = args[4];\n    var denom = args[5]; // Look into the parse nodes to get the desired delimiters.\n\n    var leftNode = checkNodeType(args[0], \"atom\");\n\n    if (leftNode) {\n      leftNode = assertAtomFamily(args[0], \"open\");\n    }\n\n    var leftDelim = leftNode ? delimFromValue(leftNode.text) : null;\n    var rightNode = checkNodeType(args[1], \"atom\");\n\n    if (rightNode) {\n      rightNode = assertAtomFamily(args[1], \"close\");\n    }\n\n    var rightDelim = rightNode ? delimFromValue(rightNode.text) : null;\n    var barNode = assertNodeType(args[2], \"size\");\n    var hasBarLine;\n    var barSize = null;\n\n    if (barNode.isBlank) {\n      // \\genfrac acts differently than \\above.\n      // \\genfrac treats an empty size group as a signal to use a\n      // standard bar size. \\above would see size = 0 and omit the bar.\n      hasBarLine = true;\n    } else {\n      barSize = barNode.value;\n      hasBarLine = barSize.number > 0;\n    } // Find out if we want displaystyle, textstyle, etc.\n\n\n    var size = \"auto\";\n    var styl = checkNodeType(args[3], \"ordgroup\");\n\n    if (styl) {\n      if (styl.body.length > 0) {\n        var textOrd = assertNodeType(styl.body[0], \"textord\");\n        size = stylArray[Number(textOrd.text)];\n      }\n    } else {\n      styl = assertNodeType(args[3], \"textord\");\n      size = stylArray[Number(styl.text)];\n    }\n\n    return {\n      type: \"genfrac\",\n      mode: parser.mode,\n      numer: numer,\n      denom: denom,\n      continued: false,\n      hasBarLine: hasBarLine,\n      barSize: barSize,\n      leftDelim: leftDelim,\n      rightDelim: rightDelim,\n      size: size\n    };\n  },\n  htmlBuilder: genfrac_htmlBuilder,\n  mathmlBuilder: genfrac_mathmlBuilder\n}); // \\above is an infix fraction that also defines a fraction bar size.\n\ndefineFunction({\n  type: \"infix\",\n  names: [\"\\\\above\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"size\"],\n    infix: true\n  },\n  handler: function handler(_ref4, args) {\n    var parser = _ref4.parser,\n        funcName = _ref4.funcName,\n        token = _ref4.token;\n    return {\n      type: \"infix\",\n      mode: parser.mode,\n      replaceWith: \"\\\\\\\\abovefrac\",\n      size: assertNodeType(args[0], \"size\").value,\n      token: token\n    };\n  }\n});\ndefineFunction({\n  type: \"genfrac\",\n  names: [\"\\\\\\\\abovefrac\"],\n  props: {\n    numArgs: 3,\n    argTypes: [\"math\", \"size\", \"math\"]\n  },\n  handler: function handler(_ref5, args) {\n    var parser = _ref5.parser,\n        funcName = _ref5.funcName;\n    var numer = args[0];\n    var barSize = assert(assertNodeType(args[1], \"infix\").size);\n    var denom = args[2];\n    var hasBarLine = barSize.number > 0;\n    return {\n      type: \"genfrac\",\n      mode: parser.mode,\n      numer: numer,\n      denom: denom,\n      continued: false,\n      hasBarLine: hasBarLine,\n      barSize: barSize,\n      leftDelim: null,\n      rightDelim: null,\n      size: \"auto\"\n    };\n  },\n  htmlBuilder: genfrac_htmlBuilder,\n  mathmlBuilder: genfrac_mathmlBuilder\n});\n// CONCATENATED MODULE: ./src/functions/horizBrace.js\n\n\n\n\n\n\n\n\n// NOTE: Unlike most `htmlBuilder`s, this one handles not only \"horizBrace\", but\nvar horizBrace_htmlBuilder = function htmlBuilder(grp, options) {\n  var style = options.style; // Pull out the `ParseNode<\"horizBrace\">` if `grp` is a \"supsub\" node.\n\n  var supSubGroup;\n  var group;\n  var supSub = checkNodeType(grp, \"supsub\");\n\n  if (supSub) {\n    // Ref: LaTeX source2e: }}}}\\limits}\n    // i.e. LaTeX treats the brace similar to an op and passes it\n    // with \\limits, so we need to assign supsub style.\n    supSubGroup = supSub.sup ? buildHTML_buildGroup(supSub.sup, options.havingStyle(style.sup()), options) : buildHTML_buildGroup(supSub.sub, options.havingStyle(style.sub()), options);\n    group = assertNodeType(supSub.base, \"horizBrace\");\n  } else {\n    group = assertNodeType(grp, \"horizBrace\");\n  } // Build the base group\n\n\n  var body = buildHTML_buildGroup(group.base, options.havingBaseStyle(src_Style.DISPLAY)); // Create the stretchy element\n\n  var braceBody = stretchy.svgSpan(group, options); // Generate the vlist, with the appropriate kerns        ┏━━━━━━━━┓\n  // This first vlist contains the content and the brace:   equation\n\n  var vlist;\n\n  if (group.isOver) {\n    vlist = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: body\n      }, {\n        type: \"kern\",\n        size: 0.1\n      }, {\n        type: \"elem\",\n        elem: braceBody\n      }]\n    }, options); // $FlowFixMe: Replace this with passing \"svg-align\" into makeVList.\n\n    vlist.children[0].children[0].children[1].classes.push(\"svg-align\");\n  } else {\n    vlist = buildCommon.makeVList({\n      positionType: \"bottom\",\n      positionData: body.depth + 0.1 + braceBody.height,\n      children: [{\n        type: \"elem\",\n        elem: braceBody\n      }, {\n        type: \"kern\",\n        size: 0.1\n      }, {\n        type: \"elem\",\n        elem: body\n      }]\n    }, options); // $FlowFixMe: Replace this with passing \"svg-align\" into makeVList.\n\n    vlist.children[0].children[0].children[0].classes.push(\"svg-align\");\n  }\n\n  if (supSubGroup) {\n    // To write the supsub, wrap the first vlist in another vlist:\n    // They can't all go in the same vlist, because the note might be\n    // wider than the equation. We want the equation to control the\n    // brace width.\n    //      note          long note           long note\n    //   ┏━━━━━━━━┓   or    ┏━━━┓     not    ┏━━━━━━━━━┓\n    //    equation           eqn                 eqn\n    var vSpan = buildCommon.makeSpan([\"mord\", group.isOver ? \"mover\" : \"munder\"], [vlist], options);\n\n    if (group.isOver) {\n      vlist = buildCommon.makeVList({\n        positionType: \"firstBaseline\",\n        children: [{\n          type: \"elem\",\n          elem: vSpan\n        }, {\n          type: \"kern\",\n          size: 0.2\n        }, {\n          type: \"elem\",\n          elem: supSubGroup\n        }]\n      }, options);\n    } else {\n      vlist = buildCommon.makeVList({\n        positionType: \"bottom\",\n        positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,\n        children: [{\n          type: \"elem\",\n          elem: supSubGroup\n        }, {\n          type: \"kern\",\n          size: 0.2\n        }, {\n          type: \"elem\",\n          elem: vSpan\n        }]\n      }, options);\n    }\n  }\n\n  return buildCommon.makeSpan([\"mord\", group.isOver ? \"mover\" : \"munder\"], [vlist], options);\n};\n\nvar horizBrace_mathmlBuilder = function mathmlBuilder(group, options) {\n  var accentNode = stretchy.mathMLnode(group.label);\n  return new mathMLTree.MathNode(group.isOver ? \"mover\" : \"munder\", [buildMathML_buildGroup(group.base, options), accentNode]);\n}; // Horizontal stretchy braces\n\n\ndefineFunction({\n  type: \"horizBrace\",\n  names: [\"\\\\overbrace\", \"\\\\underbrace\"],\n  props: {\n    numArgs: 1\n  },\n  handler: function handler(_ref, args) {\n    var parser = _ref.parser,\n        funcName = _ref.funcName;\n    return {\n      type: \"horizBrace\",\n      mode: parser.mode,\n      label: funcName,\n      isOver: /^\\\\over/.test(funcName),\n      base: args[0]\n    };\n  },\n  htmlBuilder: horizBrace_htmlBuilder,\n  mathmlBuilder: horizBrace_mathmlBuilder\n});\n// CONCATENATED MODULE: ./src/functions/href.js\n\n\n\n\n\n\ndefineFunction({\n  type: \"href\",\n  names: [\"\\\\href\"],\n  props: {\n    numArgs: 2,\n    argTypes: [\"url\", \"original\"],\n    allowedInText: true\n  },\n  handler: function handler(_ref, args) {\n    var parser = _ref.parser;\n    var body = args[1];\n    var href = assertNodeType(args[0], \"url\").url;\n\n    if (!parser.settings.isTrusted({\n      command: \"\\\\href\",\n      url: href\n    })) {\n      return parser.formatUnsupportedCmd(\"\\\\href\");\n    }\n\n    return {\n      type: \"href\",\n      mode: parser.mode,\n      href: href,\n      body: defineFunction_ordargument(body)\n    };\n  },\n  htmlBuilder: function htmlBuilder(group, options) {\n    var elements = buildHTML_buildExpression(group.body, options, false);\n    return buildCommon.makeAnchor(group.href, [], elements, options);\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var math = buildExpressionRow(group.body, options);\n\n    if (!(math instanceof mathMLTree_MathNode)) {\n      math = new mathMLTree_MathNode(\"mrow\", [math]);\n    }\n\n    math.setAttribute(\"href\", group.href);\n    return math;\n  }\n});\ndefineFunction({\n  type: \"href\",\n  names: [\"\\\\url\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"url\"],\n    allowedInText: true\n  },\n  handler: function handler(_ref2, args) {\n    var parser = _ref2.parser;\n    var href = assertNodeType(args[0], \"url\").url;\n\n    if (!parser.settings.isTrusted({\n      command: \"\\\\url\",\n      url: href\n    })) {\n      return parser.formatUnsupportedCmd(\"\\\\url\");\n    }\n\n    var chars = [];\n\n    for (var i = 0; i < href.length; i++) {\n      var c = href[i];\n\n      if (c === \"~\") {\n        c = \"\\\\textasciitilde\";\n      }\n\n      chars.push({\n        type: \"textord\",\n        mode: \"text\",\n        text: c\n      });\n    }\n\n    var body = {\n      type: \"text\",\n      mode: parser.mode,\n      font: \"\\\\texttt\",\n      body: chars\n    };\n    return {\n      type: \"href\",\n      mode: parser.mode,\n      href: href,\n      body: defineFunction_ordargument(body)\n    };\n  }\n});\n// CONCATENATED MODULE: ./src/functions/htmlmathml.js\n\n\n\n\ndefineFunction({\n  type: \"htmlmathml\",\n  names: [\"\\\\html@mathml\"],\n  props: {\n    numArgs: 2,\n    allowedInText: true\n  },\n  handler: function handler(_ref, args) {\n    var parser = _ref.parser;\n    return {\n      type: \"htmlmathml\",\n      mode: parser.mode,\n      html: defineFunction_ordargument(args[0]),\n      mathml: defineFunction_ordargument(args[1])\n    };\n  },\n  htmlBuilder: function htmlBuilder(group, options) {\n    var elements = buildHTML_buildExpression(group.html, options, false);\n    return buildCommon.makeFragment(elements);\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    return buildExpressionRow(group.mathml, options);\n  }\n});\n// CONCATENATED MODULE: ./src/functions/includegraphics.js\n\n\n\n\n\n\n\nvar includegraphics_sizeData = function sizeData(str) {\n  if (/^[-+]? *(\\d+(\\.\\d*)?|\\.\\d+)$/.test(str)) {\n    // str is a number with no unit specified.\n    // default unit is bp, per graphix package.\n    return {\n      number: +str,\n      unit: \"bp\"\n    };\n  } else {\n    var match = /([-+]?) *(\\d+(?:\\.\\d*)?|\\.\\d+) *([a-z]{2})/.exec(str);\n\n    if (!match) {\n      throw new src_ParseError(\"Invalid size: '\" + str + \"' in \\\\includegraphics\");\n    }\n\n    var data = {\n      number: +(match[1] + match[2]),\n      // sign + magnitude, cast to number\n      unit: match[3]\n    };\n\n    if (!validUnit(data)) {\n      throw new src_ParseError(\"Invalid unit: '\" + data.unit + \"' in \\\\includegraphics.\");\n    }\n\n    return data;\n  }\n};\n\ndefineFunction({\n  type: \"includegraphics\",\n  names: [\"\\\\includegraphics\"],\n  props: {\n    numArgs: 1,\n    numOptionalArgs: 1,\n    argTypes: [\"raw\", \"url\"],\n    allowedInText: false\n  },\n  handler: function handler(_ref, args, optArgs) {\n    var parser = _ref.parser;\n    var width = {\n      number: 0,\n      unit: \"em\"\n    };\n    var height = {\n      number: 0.9,\n      unit: \"em\"\n    }; // sorta character sized.\n\n    var totalheight = {\n      number: 0,\n      unit: \"em\"\n    };\n    var alt = \"\";\n\n    if (optArgs[0]) {\n      var attributeStr = assertNodeType(optArgs[0], \"raw\").string; // Parser.js does not parse key/value pairs. We get a string.\n\n      var attributes = attributeStr.split(\",\");\n\n      for (var i = 0; i < attributes.length; i++) {\n        var keyVal = attributes[i].split(\"=\");\n\n        if (keyVal.length === 2) {\n          var str = keyVal[1].trim();\n\n          switch (keyVal[0].trim()) {\n            case \"alt\":\n              alt = str;\n              break;\n\n            case \"width\":\n              width = includegraphics_sizeData(str);\n              break;\n\n            case \"height\":\n              height = includegraphics_sizeData(str);\n              break;\n\n            case \"totalheight\":\n              totalheight = includegraphics_sizeData(str);\n              break;\n\n            default:\n              throw new src_ParseError(\"Invalid key: '\" + keyVal[0] + \"' in \\\\includegraphics.\");\n          }\n        }\n      }\n    }\n\n    var src = assertNodeType(args[0], \"url\").url;\n\n    if (alt === \"\") {\n      // No alt given. Use the file name. Strip away the path.\n      alt = src;\n      alt = alt.replace(/^.*[\\\\/]/, '');\n      alt = alt.substring(0, alt.lastIndexOf('.'));\n    }\n\n    if (!parser.settings.isTrusted({\n      command: \"\\\\includegraphics\",\n      url: src\n    })) {\n      return parser.formatUnsupportedCmd(\"\\\\includegraphics\");\n    }\n\n    return {\n      type: \"includegraphics\",\n      mode: parser.mode,\n      alt: alt,\n      width: width,\n      height: height,\n      totalheight: totalheight,\n      src: src\n    };\n  },\n  htmlBuilder: function htmlBuilder(group, options) {\n    var height = units_calculateSize(group.height, options);\n    var depth = 0;\n\n    if (group.totalheight.number > 0) {\n      depth = units_calculateSize(group.totalheight, options) - height;\n      depth = Number(depth.toFixed(2));\n    }\n\n    var width = 0;\n\n    if (group.width.number > 0) {\n      width = units_calculateSize(group.width, options);\n    }\n\n    var style = {\n      height: height + depth + \"em\"\n    };\n\n    if (width > 0) {\n      style.width = width + \"em\";\n    }\n\n    if (depth > 0) {\n      style.verticalAlign = -depth + \"em\";\n    }\n\n    var node = new domTree_Img(group.src, group.alt, style);\n    node.height = height;\n    node.depth = depth;\n    return node;\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var node = new mathMLTree.MathNode(\"mglyph\", []);\n    node.setAttribute(\"alt\", group.alt);\n    var height = units_calculateSize(group.height, options);\n    var depth = 0;\n\n    if (group.totalheight.number > 0) {\n      depth = units_calculateSize(group.totalheight, options) - height;\n      depth = depth.toFixed(2);\n      node.setAttribute(\"valign\", \"-\" + depth + \"em\");\n    }\n\n    node.setAttribute(\"height\", height + depth + \"em\");\n\n    if (group.width.number > 0) {\n      var width = units_calculateSize(group.width, options);\n      node.setAttribute(\"width\", width + \"em\");\n    }\n\n    node.setAttribute(\"src\", group.src);\n    return node;\n  }\n});\n// CONCATENATED MODULE: ./src/functions/kern.js\n// Horizontal spacing commands\n\n\n\n\n // TODO: \\hskip and \\mskip should support plus and minus in lengths\n\ndefineFunction({\n  type: \"kern\",\n  names: [\"\\\\kern\", \"\\\\mkern\", \"\\\\hskip\", \"\\\\mskip\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"size\"],\n    allowedInText: true\n  },\n  handler: function handler(_ref, args) {\n    var parser = _ref.parser,\n        funcName = _ref.funcName;\n    var size = assertNodeType(args[0], \"size\");\n\n    if (parser.settings.strict) {\n      var mathFunction = funcName[1] === 'm'; // \\mkern, \\mskip\n\n      var muUnit = size.value.unit === 'mu';\n\n      if (mathFunction) {\n        if (!muUnit) {\n          parser.settings.reportNonstrict(\"mathVsTextUnits\", \"LaTeX's \" + funcName + \" supports only mu units, \" + (\"not \" + size.value.unit + \" units\"));\n        }\n\n        if (parser.mode !== \"math\") {\n          parser.settings.reportNonstrict(\"mathVsTextUnits\", \"LaTeX's \" + funcName + \" works only in math mode\");\n        }\n      } else {\n        // !mathFunction\n        if (muUnit) {\n          parser.settings.reportNonstrict(\"mathVsTextUnits\", \"LaTeX's \" + funcName + \" doesn't support mu units\");\n        }\n      }\n    }\n\n    return {\n      type: \"kern\",\n      mode: parser.mode,\n      dimension: size.value\n    };\n  },\n  htmlBuilder: function htmlBuilder(group, options) {\n    return buildCommon.makeGlue(group.dimension, options);\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var dimension = units_calculateSize(group.dimension, options);\n    return new mathMLTree.SpaceNode(dimension);\n  }\n});\n// CONCATENATED MODULE: ./src/functions/lap.js\n// Horizontal overlap functions\n\n\n\n\n\ndefineFunction({\n  type: \"lap\",\n  names: [\"\\\\mathllap\", \"\\\\mathrlap\", \"\\\\mathclap\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n  handler: function handler(_ref, args) {\n    var parser = _ref.parser,\n        funcName = _ref.funcName;\n    var body = args[0];\n    return {\n      type: \"lap\",\n      mode: parser.mode,\n      alignment: funcName.slice(5),\n      body: body\n    };\n  },\n  htmlBuilder: function htmlBuilder(group, options) {\n    // mathllap, mathrlap, mathclap\n    var inner;\n\n    if (group.alignment === \"clap\") {\n      // ref: https://www.math.lsu.edu/~aperlis/publications/mathclap/\n      inner = buildCommon.makeSpan([], [buildHTML_buildGroup(group.body, options)]); // wrap, since CSS will center a .clap > .inner > span\n\n      inner = buildCommon.makeSpan([\"inner\"], [inner], options);\n    } else {\n      inner = buildCommon.makeSpan([\"inner\"], [buildHTML_buildGroup(group.body, options)]);\n    }\n\n    var fix = buildCommon.makeSpan([\"fix\"], []);\n    var node = buildCommon.makeSpan([group.alignment], [inner, fix], options); // At this point, we have correctly set horizontal alignment of the\n    // two items involved in the lap.\n    // Next, use a strut to set the height of the HTML bounding box.\n    // Otherwise, a tall argument may be misplaced.\n\n    var strut = buildCommon.makeSpan([\"strut\"]);\n    strut.style.height = node.height + node.depth + \"em\";\n    strut.style.verticalAlign = -node.depth + \"em\";\n    node.children.unshift(strut); // Next, prevent vertical misplacement when next to something tall.\n\n    node = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: node\n      }]\n    }, options); // Get the horizontal spacing correct relative to adjacent items.\n\n    return buildCommon.makeSpan([\"mord\"], [node], options);\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    // mathllap, mathrlap, mathclap\n    var node = new mathMLTree.MathNode(\"mpadded\", [buildMathML_buildGroup(group.body, options)]);\n\n    if (group.alignment !== \"rlap\") {\n      var offset = group.alignment === \"llap\" ? \"-1\" : \"-0.5\";\n      node.setAttribute(\"lspace\", offset + \"width\");\n    }\n\n    node.setAttribute(\"width\", \"0px\");\n    return node;\n  }\n});\n// CONCATENATED MODULE: ./src/functions/math.js\n\n // Switching from text mode back to math mode\n\ndefineFunction({\n  type: \"styling\",\n  names: [\"\\\\(\", \"$\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    allowedInMath: false\n  },\n  handler: function handler(_ref, args) {\n    var funcName = _ref.funcName,\n        parser = _ref.parser;\n    var outerMode = parser.mode;\n    parser.switchMode(\"math\");\n    var close = funcName === \"\\\\(\" ? \"\\\\)\" : \"$\";\n    var body = parser.parseExpression(false, close);\n    parser.expect(close);\n    parser.switchMode(outerMode);\n    return {\n      type: \"styling\",\n      mode: parser.mode,\n      style: \"text\",\n      body: body\n    };\n  }\n}); // Check for extra closing math delimiters\n\ndefineFunction({\n  type: \"text\",\n  // Doesn't matter what this is.\n  names: [\"\\\\)\", \"\\\\]\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    allowedInMath: false\n  },\n  handler: function handler(context, args) {\n    throw new src_ParseError(\"Mismatched \" + context.funcName);\n  }\n});\n// CONCATENATED MODULE: ./src/functions/mathchoice.js\n\n\n\n\n\n\nvar mathchoice_chooseMathStyle = function chooseMathStyle(group, options) {\n  switch (options.style.size) {\n    case src_Style.DISPLAY.size:\n      return group.display;\n\n    case src_Style.TEXT.size:\n      return group.text;\n\n    case src_Style.SCRIPT.size:\n      return group.script;\n\n    case src_Style.SCRIPTSCRIPT.size:\n      return group.scriptscript;\n\n    default:\n      return group.text;\n  }\n};\n\ndefineFunction({\n  type: \"mathchoice\",\n  names: [\"\\\\mathchoice\"],\n  props: {\n    numArgs: 4\n  },\n  handler: function handler(_ref, args) {\n    var parser = _ref.parser;\n    return {\n      type: \"mathchoice\",\n      mode: parser.mode,\n      display: defineFunction_ordargument(args[0]),\n      text: defineFunction_ordargument(args[1]),\n      script: defineFunction_ordargument(args[2]),\n      scriptscript: defineFunction_ordargument(args[3])\n    };\n  },\n  htmlBuilder: function htmlBuilder(group, options) {\n    var body = mathchoice_chooseMathStyle(group, options);\n    var elements = buildHTML_buildExpression(body, options, false);\n    return buildCommon.makeFragment(elements);\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var body = mathchoice_chooseMathStyle(group, options);\n    return buildExpressionRow(body, options);\n  }\n});\n// CONCATENATED MODULE: ./src/functions/utils/assembleSupSub.js\n\n\n// For an operator with limits, assemble the base, sup, and sub into a span.\nvar assembleSupSub_assembleSupSub = function assembleSupSub(base, supGroup, subGroup, options, style, slant, baseShift) {\n  // IE 8 clips \\int if it is in a display: inline-block. We wrap it\n  // in a new span so it is an inline, and works.\n  base = buildCommon.makeSpan([], [base]);\n  var sub;\n  var sup; // We manually have to handle the superscripts and subscripts. This,\n  // aside from the kern calculations, is copied from supsub.\n\n  if (supGroup) {\n    var elem = buildHTML_buildGroup(supGroup, options.havingStyle(style.sup()), options);\n    sup = {\n      elem: elem,\n      kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)\n    };\n  }\n\n  if (subGroup) {\n    var _elem = buildHTML_buildGroup(subGroup, options.havingStyle(style.sub()), options);\n\n    sub = {\n      elem: _elem,\n      kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - _elem.height)\n    };\n  } // Build the final group as a vlist of the possible subscript, base,\n  // and possible superscript.\n\n\n  var finalGroup;\n\n  if (sup && sub) {\n    var bottom = options.fontMetrics().bigOpSpacing5 + sub.elem.height + sub.elem.depth + sub.kern + base.depth + baseShift;\n    finalGroup = buildCommon.makeVList({\n      positionType: \"bottom\",\n      positionData: bottom,\n      children: [{\n        type: \"kern\",\n        size: options.fontMetrics().bigOpSpacing5\n      }, {\n        type: \"elem\",\n        elem: sub.elem,\n        marginLeft: -slant + \"em\"\n      }, {\n        type: \"kern\",\n        size: sub.kern\n      }, {\n        type: \"elem\",\n        elem: base\n      }, {\n        type: \"kern\",\n        size: sup.kern\n      }, {\n        type: \"elem\",\n        elem: sup.elem,\n        marginLeft: slant + \"em\"\n      }, {\n        type: \"kern\",\n        size: options.fontMetrics().bigOpSpacing5\n      }]\n    }, options);\n  } else if (sub) {\n    var top = base.height - baseShift; // Shift the limits by the slant of the symbol. Note\n    // that we are supposed to shift the limits by 1/2 of the slant,\n    // but since we are centering the limits adding a full slant of\n    // margin will shift by 1/2 that.\n\n    finalGroup = buildCommon.makeVList({\n      positionType: \"top\",\n      positionData: top,\n      children: [{\n        type: \"kern\",\n        size: options.fontMetrics().bigOpSpacing5\n      }, {\n        type: \"elem\",\n        elem: sub.elem,\n        marginLeft: -slant + \"em\"\n      }, {\n        type: \"kern\",\n        size: sub.kern\n      }, {\n        type: \"elem\",\n        elem: base\n      }]\n    }, options);\n  } else if (sup) {\n    var _bottom = base.depth + baseShift;\n\n    finalGroup = buildCommon.makeVList({\n      positionType: \"bottom\",\n      positionData: _bottom,\n      children: [{\n        type: \"elem\",\n        elem: base\n      }, {\n        type: \"kern\",\n        size: sup.kern\n      }, {\n        type: \"elem\",\n        elem: sup.elem,\n        marginLeft: slant + \"em\"\n      }, {\n        type: \"kern\",\n        size: options.fontMetrics().bigOpSpacing5\n      }]\n    }, options);\n  } else {\n    // This case probably shouldn't occur (this would mean the\n    // supsub was sending us a group with no superscript or\n    // subscript) but be safe.\n    return base;\n  }\n\n  return buildCommon.makeSpan([\"mop\", \"op-limits\"], [finalGroup], options);\n};\n// CONCATENATED MODULE: ./src/functions/op.js\n// Limits, symbols\n\n\n\n\n\n\n\n\n\n\n// Most operators have a large successor symbol, but these don't.\nvar noSuccessor = [\"\\\\smallint\"]; // NOTE: Unlike most `htmlBuilder`s, this one handles not only \"op\", but also\n// \"supsub\" since some of them (like \\int) can affect super/subscripting.\n\nvar op_htmlBuilder = function htmlBuilder(grp, options) {\n  // Operators are handled in the TeXbook pg. 443-444, rule 13(a).\n  var supGroup;\n  var subGroup;\n  var hasLimits = false;\n  var group;\n  var supSub = checkNodeType(grp, \"supsub\");\n\n  if (supSub) {\n    // If we have limits, supsub will pass us its group to handle. Pull\n    // out the superscript and subscript and set the group to the op in\n    // its base.\n    supGroup = supSub.sup;\n    subGroup = supSub.sub;\n    group = assertNodeType(supSub.base, \"op\");\n    hasLimits = true;\n  } else {\n    group = assertNodeType(grp, \"op\");\n  }\n\n  var style = options.style;\n  var large = false;\n\n  if (style.size === src_Style.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {\n    // Most symbol operators get larger in displaystyle (rule 13)\n    large = true;\n  }\n\n  var base;\n\n  if (group.symbol) {\n    // If this is a symbol, create the symbol.\n    var fontName = large ? \"Size2-Regular\" : \"Size1-Regular\";\n    var stash = \"\";\n\n    if (group.name === \"\\\\oiint\" || group.name === \"\\\\oiiint\") {\n      // No font glyphs yet, so use a glyph w/o the oval.\n      // TODO: When font glyphs are available, delete this code.\n      stash = group.name.substr(1); // $FlowFixMe\n\n      group.name = stash === \"oiint\" ? \"\\\\iint\" : \"\\\\iiint\";\n    }\n\n    base = buildCommon.makeSymbol(group.name, fontName, \"math\", options, [\"mop\", \"op-symbol\", large ? \"large-op\" : \"small-op\"]);\n\n    if (stash.length > 0) {\n      // We're in \\oiint or \\oiiint. Overlay the oval.\n      // TODO: When font glyphs are available, delete this code.\n      var italic = base.italic;\n      var oval = buildCommon.staticSvg(stash + \"Size\" + (large ? \"2\" : \"1\"), options);\n      base = buildCommon.makeVList({\n        positionType: \"individualShift\",\n        children: [{\n          type: \"elem\",\n          elem: base,\n          shift: 0\n        }, {\n          type: \"elem\",\n          elem: oval,\n          shift: large ? 0.08 : 0\n        }]\n      }, options); // $FlowFixMe\n\n      group.name = \"\\\\\" + stash;\n      base.classes.unshift(\"mop\"); // $FlowFixMe\n\n      base.italic = italic;\n    }\n  } else if (group.body) {\n    // If this is a list, compose that list.\n    var inner = buildHTML_buildExpression(group.body, options, true);\n\n    if (inner.length === 1 && inner[0] instanceof domTree_SymbolNode) {\n      base = inner[0];\n      base.classes[0] = \"mop\"; // replace old mclass\n    } else {\n      base = buildCommon.makeSpan([\"mop\"], buildCommon.tryCombineChars(inner), options);\n    }\n  } else {\n    // Otherwise, this is a text operator. Build the text from the\n    // operator's name.\n    // TODO(emily): Add a space in the middle of some of these\n    // operators, like \\limsup\n    var output = [];\n\n    for (var i = 1; i < group.name.length; i++) {\n      output.push(buildCommon.mathsym(group.name[i], group.mode, options));\n    }\n\n    base = buildCommon.makeSpan([\"mop\"], output, options);\n  } // If content of op is a single symbol, shift it vertically.\n\n\n  var baseShift = 0;\n  var slant = 0;\n\n  if ((base instanceof domTree_SymbolNode || group.name === \"\\\\oiint\" || group.name === \"\\\\oiiint\") && !group.suppressBaseShift) {\n    // We suppress the shift of the base of \\overset and \\underset. Otherwise,\n    // shift the symbol so its center lies on the axis (rule 13). It\n    // appears that our fonts have the centers of the symbols already\n    // almost on the axis, so these numbers are very small. Note we\n    // don't actually apply this here, but instead it is used either in\n    // the vlist creation or separately when there are no limits.\n    baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight; // The slant of the symbol is just its italic correction.\n    // $FlowFixMe\n\n    slant = base.italic;\n  }\n\n  if (hasLimits) {\n    return assembleSupSub_assembleSupSub(base, supGroup, subGroup, options, style, slant, baseShift);\n  } else {\n    if (baseShift) {\n      base.style.position = \"relative\";\n      base.style.top = baseShift + \"em\";\n    }\n\n    return base;\n  }\n};\n\nvar op_mathmlBuilder = function mathmlBuilder(group, options) {\n  var node;\n\n  if (group.symbol) {\n    // This is a symbol. Just add the symbol.\n    node = new mathMLTree_MathNode(\"mo\", [buildMathML_makeText(group.name, group.mode)]);\n\n    if (utils.contains(noSuccessor, group.name)) {\n      node.setAttribute(\"largeop\", \"false\");\n    }\n  } else if (group.body) {\n    // This is an operator with children. Add them.\n    node = new mathMLTree_MathNode(\"mo\", buildMathML_buildExpression(group.body, options));\n  } else {\n    // This is a text operator. Add all of the characters from the\n    // operator's name.\n    node = new mathMLTree_MathNode(\"mi\", [new mathMLTree_TextNode(group.name.slice(1))]); // Append an <mo>&ApplyFunction;</mo>.\n    // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4\n\n    var operator = new mathMLTree_MathNode(\"mo\", [buildMathML_makeText(\"\\u2061\", \"text\")]);\n\n    if (group.parentIsSupSub) {\n      node = new mathMLTree_MathNode(\"mo\", [node, operator]);\n    } else {\n      node = newDocumentFragment([node, operator]);\n    }\n  }\n\n  return node;\n};\n\nvar singleCharBigOps = {\n  \"\\u220F\": \"\\\\prod\",\n  \"\\u2210\": \"\\\\coprod\",\n  \"\\u2211\": \"\\\\sum\",\n  \"\\u22C0\": \"\\\\bigwedge\",\n  \"\\u22C1\": \"\\\\bigvee\",\n  \"\\u22C2\": \"\\\\bigcap\",\n  \"\\u22C3\": \"\\\\bigcup\",\n  \"\\u2A00\": \"\\\\bigodot\",\n  \"\\u2A01\": \"\\\\bigoplus\",\n  \"\\u2A02\": \"\\\\bigotimes\",\n  \"\\u2A04\": \"\\\\biguplus\",\n  \"\\u2A06\": \"\\\\bigsqcup\"\n};\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\coprod\", \"\\\\bigvee\", \"\\\\bigwedge\", \"\\\\biguplus\", \"\\\\bigcap\", \"\\\\bigcup\", \"\\\\intop\", \"\\\\prod\", \"\\\\sum\", \"\\\\bigotimes\", \"\\\\bigoplus\", \"\\\\bigodot\", \"\\\\bigsqcup\", \"\\\\smallint\", \"\\u220F\", \"\\u2210\", \"\\u2211\", \"\\u22C0\", \"\\u22C1\", \"\\u22C2\", \"\\u22C3\", \"\\u2A00\", \"\\u2A01\", \"\\u2A02\", \"\\u2A04\", \"\\u2A06\"],\n  props: {\n    numArgs: 0\n  },\n  handler: function handler(_ref, args) {\n    var parser = _ref.parser,\n        funcName = _ref.funcName;\n    var fName = funcName;\n\n    if (fName.length === 1) {\n      fName = singleCharBigOps[fName];\n    }\n\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: true,\n      parentIsSupSub: false,\n      symbol: true,\n      name: fName\n    };\n  },\n  htmlBuilder: op_htmlBuilder,\n  mathmlBuilder: op_mathmlBuilder\n}); // Note: calling defineFunction with a type that's already been defined only\n// works because the same htmlBuilder and mathmlBuilder are being used.\n\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\mathop\"],\n  props: {\n    numArgs: 1\n  },\n  handler: function handler(_ref2, args) {\n    var parser = _ref2.parser;\n    var body = args[0];\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: false,\n      parentIsSupSub: false,\n      symbol: false,\n      body: defineFunction_ordargument(body)\n    };\n  },\n  htmlBuilder: op_htmlBuilder,\n  mathmlBuilder: op_mathmlBuilder\n}); // There are 2 flags for operators; whether they produce limits in\n// displaystyle, and whether they are symbols and should grow in\n// displaystyle. These four groups cover the four possible choices.\n\nvar singleCharIntegrals = {\n  \"\\u222B\": \"\\\\int\",\n  \"\\u222C\": \"\\\\iint\",\n  \"\\u222D\": \"\\\\iiint\",\n  \"\\u222E\": \"\\\\oint\",\n  \"\\u222F\": \"\\\\oiint\",\n  \"\\u2230\": \"\\\\oiiint\"\n}; // No limits, not symbols\n\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\arcsin\", \"\\\\arccos\", \"\\\\arctan\", \"\\\\arctg\", \"\\\\arcctg\", \"\\\\arg\", \"\\\\ch\", \"\\\\cos\", \"\\\\cosec\", \"\\\\cosh\", \"\\\\cot\", \"\\\\cotg\", \"\\\\coth\", \"\\\\csc\", \"\\\\ctg\", \"\\\\cth\", \"\\\\deg\", \"\\\\dim\", \"\\\\exp\", \"\\\\hom\", \"\\\\ker\", \"\\\\lg\", \"\\\\ln\", \"\\\\log\", \"\\\\sec\", \"\\\\sin\", \"\\\\sinh\", \"\\\\sh\", \"\\\\tan\", \"\\\\tanh\", \"\\\\tg\", \"\\\\th\"],\n  props: {\n    numArgs: 0\n  },\n  handler: function handler(_ref3) {\n    var parser = _ref3.parser,\n        funcName = _ref3.funcName;\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: false,\n      parentIsSupSub: false,\n      symbol: false,\n      name: funcName\n    };\n  },\n  htmlBuilder: op_htmlBuilder,\n  mathmlBuilder: op_mathmlBuilder\n}); // Limits, not symbols\n\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\det\", \"\\\\gcd\", \"\\\\inf\", \"\\\\lim\", \"\\\\max\", \"\\\\min\", \"\\\\Pr\", \"\\\\sup\"],\n  props: {\n    numArgs: 0\n  },\n  handler: function handler(_ref4) {\n    var parser = _ref4.parser,\n        funcName = _ref4.funcName;\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: true,\n      parentIsSupSub: false,\n      symbol: false,\n      name: funcName\n    };\n  },\n  htmlBuilder: op_htmlBuilder,\n  mathmlBuilder: op_mathmlBuilder\n}); // No limits, symbols\n\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\int\", \"\\\\iint\", \"\\\\iiint\", \"\\\\oint\", \"\\\\oiint\", \"\\\\oiiint\", \"\\u222B\", \"\\u222C\", \"\\u222D\", \"\\u222E\", \"\\u222F\", \"\\u2230\"],\n  props: {\n    numArgs: 0\n  },\n  handler: function handler(_ref5) {\n    var parser = _ref5.parser,\n        funcName = _ref5.funcName;\n    var fName = funcName;\n\n    if (fName.length === 1) {\n      fName = singleCharIntegrals[fName];\n    }\n\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: false,\n      parentIsSupSub: false,\n      symbol: true,\n      name: fName\n    };\n  },\n  htmlBuilder: op_htmlBuilder,\n  mathmlBuilder: op_mathmlBuilder\n});\n// CONCATENATED MODULE: ./src/functions/operatorname.js\n\n\n\n\n\n\n\n\n// NOTE: Unlike most `htmlBuilder`s, this one handles not only\n// \"operatorname\", but also  \"supsub\" since \\operatorname* can\nvar operatorname_htmlBuilder = function htmlBuilder(grp, options) {\n  // Operators are handled in the TeXbook pg. 443-444, rule 13(a).\n  var supGroup;\n  var subGroup;\n  var hasLimits = false;\n  var group;\n  var supSub = checkNodeType(grp, \"supsub\");\n\n  if (supSub) {\n    // If we have limits, supsub will pass us its group to handle. Pull\n    // out the superscript and subscript and set the group to the op in\n    // its base.\n    supGroup = supSub.sup;\n    subGroup = supSub.sub;\n    group = assertNodeType(supSub.base, \"operatorname\");\n    hasLimits = true;\n  } else {\n    group = assertNodeType(grp, \"operatorname\");\n  }\n\n  var base;\n\n  if (group.body.length > 0) {\n    var body = group.body.map(function (child) {\n      // $FlowFixMe: Check if the node has a string `text` property.\n      var childText = child.text;\n\n      if (typeof childText === \"string\") {\n        return {\n          type: \"textord\",\n          mode: child.mode,\n          text: childText\n        };\n      } else {\n        return child;\n      }\n    }); // Consolidate function names into symbol characters.\n\n    var expression = buildHTML_buildExpression(body, options.withFont(\"mathrm\"), true);\n\n    for (var i = 0; i < expression.length; i++) {\n      var child = expression[i];\n\n      if (child instanceof domTree_SymbolNode) {\n        // Per amsopn package,\n        // change minus to hyphen and \\ast to asterisk\n        child.text = child.text.replace(/\\u2212/, \"-\").replace(/\\u2217/, \"*\");\n      }\n    }\n\n    base = buildCommon.makeSpan([\"mop\"], expression, options);\n  } else {\n    base = buildCommon.makeSpan([\"mop\"], [], options);\n  }\n\n  if (hasLimits) {\n    return assembleSupSub_assembleSupSub(base, supGroup, subGroup, options, options.style, 0, 0);\n  } else {\n    return base;\n  }\n};\n\nvar operatorname_mathmlBuilder = function mathmlBuilder(group, options) {\n  // The steps taken here are similar to the html version.\n  var expression = buildMathML_buildExpression(group.body, options.withFont(\"mathrm\")); // Is expression a string or has it something like a fraction?\n\n  var isAllString = true; // default\n\n  for (var i = 0; i < expression.length; i++) {\n    var node = expression[i];\n\n    if (node instanceof mathMLTree.SpaceNode) {// Do nothing\n    } else if (node instanceof mathMLTree.MathNode) {\n      switch (node.type) {\n        case \"mi\":\n        case \"mn\":\n        case \"ms\":\n        case \"mspace\":\n        case \"mtext\":\n          break;\n        // Do nothing yet.\n\n        case \"mo\":\n          {\n            var child = node.children[0];\n\n            if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {\n              child.text = child.text.replace(/\\u2212/, \"-\").replace(/\\u2217/, \"*\");\n            } else {\n              isAllString = false;\n            }\n\n            break;\n          }\n\n        default:\n          isAllString = false;\n      }\n    } else {\n      isAllString = false;\n    }\n  }\n\n  if (isAllString) {\n    // Write a single TextNode instead of multiple nested tags.\n    var word = expression.map(function (node) {\n      return node.toText();\n    }).join(\"\");\n    expression = [new mathMLTree.TextNode(word)];\n  }\n\n  var identifier = new mathMLTree.MathNode(\"mi\", expression);\n  identifier.setAttribute(\"mathvariant\", \"normal\"); // \\u2061 is the same as &ApplyFunction;\n  // ref: https://www.w3schools.com/charsets/ref_html_entities_a.asp\n\n  var operator = new mathMLTree.MathNode(\"mo\", [buildMathML_makeText(\"\\u2061\", \"text\")]);\n\n  if (group.parentIsSupSub) {\n    return new mathMLTree.MathNode(\"mo\", [identifier, operator]);\n  } else {\n    return mathMLTree.newDocumentFragment([identifier, operator]);\n  }\n}; // \\operatorname\n// amsopn.dtx: \\mathop{#1\\kern\\z@\\operator@font#3}\\newmcodes@\n\n\ndefineFunction({\n  type: \"operatorname\",\n  names: [\"\\\\operatorname\", \"\\\\operatorname*\"],\n  props: {\n    numArgs: 1\n  },\n  handler: function handler(_ref, args) {\n    var parser = _ref.parser,\n        funcName = _ref.funcName;\n    var body = args[0];\n    return {\n      type: \"operatorname\",\n      mode: parser.mode,\n      body: defineFunction_ordargument(body),\n      alwaysHandleSupSub: funcName === \"\\\\operatorname*\",\n      limits: false,\n      parentIsSupSub: false\n    };\n  },\n  htmlBuilder: operatorname_htmlBuilder,\n  mathmlBuilder: operatorname_mathmlBuilder\n});\n// CONCATENATED MODULE: ./src/functions/ordgroup.js\n\n\n\n\ndefineFunctionBuilders({\n  type: \"ordgroup\",\n  htmlBuilder: function htmlBuilder(group, options) {\n    if (group.semisimple) {\n      return buildCommon.makeFragment(buildHTML_buildExpression(group.body, options, false));\n    }\n\n    return buildCommon.makeSpan([\"mord\"], buildHTML_buildExpression(group.body, options, true), options);\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    return buildExpressionRow(group.body, options, true);\n  }\n});\n// CONCATENATED MODULE: ./src/functions/overline.js\n\n\n\n\n\ndefineFunction({\n  type: \"overline\",\n  names: [\"\\\\overline\"],\n  props: {\n    numArgs: 1\n  },\n  handler: function handler(_ref, args) {\n    var parser = _ref.parser;\n    var body = args[0];\n    return {\n      type: \"overline\",\n      mode: parser.mode,\n      body: body\n    };\n  },\n  htmlBuilder: function htmlBuilder(group, options) {\n    // Overlines are handled in the TeXbook pg 443, Rule 9.\n    // Build the inner group in the cramped style.\n    var innerGroup = buildHTML_buildGroup(group.body, options.havingCrampedStyle()); // Create the line above the body\n\n    var line = buildCommon.makeLineSpan(\"overline-line\", options); // Generate the vlist, with the appropriate kerns\n\n    var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;\n    var vlist = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: innerGroup\n      }, {\n        type: \"kern\",\n        size: 3 * defaultRuleThickness\n      }, {\n        type: \"elem\",\n        elem: line\n      }, {\n        type: \"kern\",\n        size: defaultRuleThickness\n      }]\n    }, options);\n    return buildCommon.makeSpan([\"mord\", \"overline\"], [vlist], options);\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var operator = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(\"\\u203E\")]);\n    operator.setAttribute(\"stretchy\", \"true\");\n    var node = new mathMLTree.MathNode(\"mover\", [buildMathML_buildGroup(group.body, options), operator]);\n    node.setAttribute(\"accent\", \"true\");\n    return node;\n  }\n});\n// CONCATENATED MODULE: ./src/functions/phantom.js\n\n\n\n\n\ndefineFunction({\n  type: \"phantom\",\n  names: [\"\\\\phantom\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n  handler: function handler(_ref, args) {\n    var parser = _ref.parser;\n    var body = args[0];\n    return {\n      type: \"phantom\",\n      mode: parser.mode,\n      body: defineFunction_ordargument(body)\n    };\n  },\n  htmlBuilder: function htmlBuilder(group, options) {\n    var elements = buildHTML_buildExpression(group.body, options.withPhantom(), false); // \\phantom isn't supposed to affect the elements it contains.\n    // See \"color\" for more details.\n\n    return buildCommon.makeFragment(elements);\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var inner = buildMathML_buildExpression(group.body, options);\n    return new mathMLTree.MathNode(\"mphantom\", inner);\n  }\n});\ndefineFunction({\n  type: \"hphantom\",\n  names: [\"\\\\hphantom\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n  handler: function handler(_ref2, args) {\n    var parser = _ref2.parser;\n    var body = args[0];\n    return {\n      type: \"hphantom\",\n      mode: parser.mode,\n      body: body\n    };\n  },\n  htmlBuilder: function htmlBuilder(group, options) {\n    var node = buildCommon.makeSpan([], [buildHTML_buildGroup(group.body, options.withPhantom())]);\n    node.height = 0;\n    node.depth = 0;\n\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        node.children[i].height = 0;\n        node.children[i].depth = 0;\n      }\n    } // See smash for comment re: use of makeVList\n\n\n    node = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: node\n      }]\n    }, options); // For spacing, TeX treats \\smash as a math group (same spacing as ord).\n\n    return buildCommon.makeSpan([\"mord\"], [node], options);\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var inner = buildMathML_buildExpression(defineFunction_ordargument(group.body), options);\n    var phantom = new mathMLTree.MathNode(\"mphantom\", inner);\n    var node = new mathMLTree.MathNode(\"mpadded\", [phantom]);\n    node.setAttribute(\"height\", \"0px\");\n    node.setAttribute(\"depth\", \"0px\");\n    return node;\n  }\n});\ndefineFunction({\n  type: \"vphantom\",\n  names: [\"\\\\vphantom\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n  handler: function handler(_ref3, args) {\n    var parser = _ref3.parser;\n    var body = args[0];\n    return {\n      type: \"vphantom\",\n      mode: parser.mode,\n      body: body\n    };\n  },\n  htmlBuilder: function htmlBuilder(group, options) {\n    var inner = buildCommon.makeSpan([\"inner\"], [buildHTML_buildGroup(group.body, options.withPhantom())]);\n    var fix = buildCommon.makeSpan([\"fix\"], []);\n    return buildCommon.makeSpan([\"mord\", \"rlap\"], [inner, fix], options);\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var inner = buildMathML_buildExpression(defineFunction_ordargument(group.body), options);\n    var phantom = new mathMLTree.MathNode(\"mphantom\", inner);\n    var node = new mathMLTree.MathNode(\"mpadded\", [phantom]);\n    node.setAttribute(\"width\", \"0px\");\n    return node;\n  }\n});\n// CONCATENATED MODULE: ./src/functions/raisebox.js\n\n\n\n\n\n\n // Box manipulation\n\ndefineFunction({\n  type: \"raisebox\",\n  names: [\"\\\\raisebox\"],\n  props: {\n    numArgs: 2,\n    argTypes: [\"size\", \"hbox\"],\n    allowedInText: true\n  },\n  handler: function handler(_ref, args) {\n    var parser = _ref.parser;\n    var amount = assertNodeType(args[0], \"size\").value;\n    var body = args[1];\n    return {\n      type: \"raisebox\",\n      mode: parser.mode,\n      dy: amount,\n      body: body\n    };\n  },\n  htmlBuilder: function htmlBuilder(group, options) {\n    var body = buildHTML_buildGroup(group.body, options);\n    var dy = units_calculateSize(group.dy, options);\n    return buildCommon.makeVList({\n      positionType: \"shift\",\n      positionData: -dy,\n      children: [{\n        type: \"elem\",\n        elem: body\n      }]\n    }, options);\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var node = new mathMLTree.MathNode(\"mpadded\", [buildMathML_buildGroup(group.body, options)]);\n    var dy = group.dy.number + group.dy.unit;\n    node.setAttribute(\"voffset\", dy);\n    return node;\n  }\n});\n// CONCATENATED MODULE: ./src/functions/rule.js\n\n\n\n\n\ndefineFunction({\n  type: \"rule\",\n  names: [\"\\\\rule\"],\n  props: {\n    numArgs: 2,\n    numOptionalArgs: 1,\n    argTypes: [\"size\", \"size\", \"size\"]\n  },\n  handler: function handler(_ref, args, optArgs) {\n    var parser = _ref.parser;\n    var shift = optArgs[0];\n    var width = assertNodeType(args[0], \"size\");\n    var height = assertNodeType(args[1], \"size\");\n    return {\n      type: \"rule\",\n      mode: parser.mode,\n      shift: shift && assertNodeType(shift, \"size\").value,\n      width: width.value,\n      height: height.value\n    };\n  },\n  htmlBuilder: function htmlBuilder(group, options) {\n    // Make an empty span for the rule\n    var rule = buildCommon.makeSpan([\"mord\", \"rule\"], [], options); // Calculate the shift, width, and height of the rule, and account for units\n\n    var width = units_calculateSize(group.width, options);\n    var height = units_calculateSize(group.height, options);\n    var shift = group.shift ? units_calculateSize(group.shift, options) : 0; // Style the rule to the right size\n\n    rule.style.borderRightWidth = width + \"em\";\n    rule.style.borderTopWidth = height + \"em\";\n    rule.style.bottom = shift + \"em\"; // Record the height and width\n\n    rule.width = width;\n    rule.height = height + shift;\n    rule.depth = -shift; // Font size is the number large enough that the browser will\n    // reserve at least `absHeight` space above the baseline.\n    // The 1.125 factor was empirically determined\n\n    rule.maxFontSize = height * 1.125 * options.sizeMultiplier;\n    return rule;\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var width = units_calculateSize(group.width, options);\n    var height = units_calculateSize(group.height, options);\n    var shift = group.shift ? units_calculateSize(group.shift, options) : 0;\n    var color = options.color && options.getColor() || \"black\";\n    var rule = new mathMLTree.MathNode(\"mspace\");\n    rule.setAttribute(\"mathbackground\", color);\n    rule.setAttribute(\"width\", width + \"em\");\n    rule.setAttribute(\"height\", height + \"em\");\n    var wrapper = new mathMLTree.MathNode(\"mpadded\", [rule]);\n\n    if (shift >= 0) {\n      wrapper.setAttribute(\"height\", \"+\" + shift + \"em\");\n    } else {\n      wrapper.setAttribute(\"height\", shift + \"em\");\n      wrapper.setAttribute(\"depth\", \"+\" + -shift + \"em\");\n    }\n\n    wrapper.setAttribute(\"voffset\", shift + \"em\");\n    return wrapper;\n  }\n});\n// CONCATENATED MODULE: ./src/functions/sizing.js\n\n\n\n\n\nfunction sizingGroup(value, options, baseOptions) {\n  var inner = buildHTML_buildExpression(value, options, false);\n  var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier; // Add size-resetting classes to the inner list and set maxFontSize\n  // manually. Handle nested size changes.\n\n  for (var i = 0; i < inner.length; i++) {\n    var pos = inner[i].classes.indexOf(\"sizing\");\n\n    if (pos < 0) {\n      Array.prototype.push.apply(inner[i].classes, options.sizingClasses(baseOptions));\n    } else if (inner[i].classes[pos + 1] === \"reset-size\" + options.size) {\n      // This is a nested size change: e.g., inner[i] is the \"b\" in\n      // `\\Huge a \\small b`. Override the old size (the `reset-` class)\n      // but not the new size.\n      inner[i].classes[pos + 1] = \"reset-size\" + baseOptions.size;\n    }\n\n    inner[i].height *= multiplier;\n    inner[i].depth *= multiplier;\n  }\n\n  return buildCommon.makeFragment(inner);\n}\nvar sizeFuncs = [\"\\\\tiny\", \"\\\\sixptsize\", \"\\\\scriptsize\", \"\\\\footnotesize\", \"\\\\small\", \"\\\\normalsize\", \"\\\\large\", \"\\\\Large\", \"\\\\LARGE\", \"\\\\huge\", \"\\\\Huge\"];\nvar sizing_htmlBuilder = function htmlBuilder(group, options) {\n  // Handle sizing operators like \\Huge. Real TeX doesn't actually allow\n  // these functions inside of math expressions, so we do some special\n  // handling.\n  var newOptions = options.havingSize(group.size);\n  return sizingGroup(group.body, newOptions, options);\n};\ndefineFunction({\n  type: \"sizing\",\n  names: sizeFuncs,\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n  handler: function handler(_ref, args) {\n    var breakOnTokenText = _ref.breakOnTokenText,\n        funcName = _ref.funcName,\n        parser = _ref.parser;\n    var body = parser.parseExpression(false, breakOnTokenText);\n    return {\n      type: \"sizing\",\n      mode: parser.mode,\n      // Figure out what size to use based on the list of functions above\n      size: sizeFuncs.indexOf(funcName) + 1,\n      body: body\n    };\n  },\n  htmlBuilder: sizing_htmlBuilder,\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var newOptions = options.havingSize(group.size);\n    var inner = buildMathML_buildExpression(group.body, newOptions);\n    var node = new mathMLTree.MathNode(\"mstyle\", inner); // TODO(emily): This doesn't produce the correct size for nested size\n    // changes, because we don't keep state of what style we're currently\n    // in, so we can't reset the size to normal before changing it.  Now\n    // that we're passing an options parameter we should be able to fix\n    // this.\n\n    node.setAttribute(\"mathsize\", newOptions.sizeMultiplier + \"em\");\n    return node;\n  }\n});\n// CONCATENATED MODULE: ./src/functions/smash.js\n// smash, with optional [tb], as in AMS\n\n\n\n\n\n\ndefineFunction({\n  type: \"smash\",\n  names: [\"\\\\smash\"],\n  props: {\n    numArgs: 1,\n    numOptionalArgs: 1,\n    allowedInText: true\n  },\n  handler: function handler(_ref, args, optArgs) {\n    var parser = _ref.parser;\n    var smashHeight = false;\n    var smashDepth = false;\n    var tbArg = optArgs[0] && assertNodeType(optArgs[0], \"ordgroup\");\n\n    if (tbArg) {\n      // Optional [tb] argument is engaged.\n      // ref: amsmath: \\renewcommand{\\smash}[1][tb]{%\n      //               def\\mb@t{\\ht}\\def\\mb@b{\\dp}\\def\\mb@tb{\\ht\\z@\\z@\\dp}%\n      var letter = \"\";\n\n      for (var i = 0; i < tbArg.body.length; ++i) {\n        var node = tbArg.body[i]; // $FlowFixMe: Not every node type has a `text` property.\n\n        letter = node.text;\n\n        if (letter === \"t\") {\n          smashHeight = true;\n        } else if (letter === \"b\") {\n          smashDepth = true;\n        } else {\n          smashHeight = false;\n          smashDepth = false;\n          break;\n        }\n      }\n    } else {\n      smashHeight = true;\n      smashDepth = true;\n    }\n\n    var body = args[0];\n    return {\n      type: \"smash\",\n      mode: parser.mode,\n      body: body,\n      smashHeight: smashHeight,\n      smashDepth: smashDepth\n    };\n  },\n  htmlBuilder: function htmlBuilder(group, options) {\n    var node = buildCommon.makeSpan([], [buildHTML_buildGroup(group.body, options)]);\n\n    if (!group.smashHeight && !group.smashDepth) {\n      return node;\n    }\n\n    if (group.smashHeight) {\n      node.height = 0; // In order to influence makeVList, we have to reset the children.\n\n      if (node.children) {\n        for (var i = 0; i < node.children.length; i++) {\n          node.children[i].height = 0;\n        }\n      }\n    }\n\n    if (group.smashDepth) {\n      node.depth = 0;\n\n      if (node.children) {\n        for (var _i = 0; _i < node.children.length; _i++) {\n          node.children[_i].depth = 0;\n        }\n      }\n    } // At this point, we've reset the TeX-like height and depth values.\n    // But the span still has an HTML line height.\n    // makeVList applies \"display: table-cell\", which prevents the browser\n    // from acting on that line height. So we'll call makeVList now.\n\n\n    var smashedNode = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: node\n      }]\n    }, options); // For spacing, TeX treats \\hphantom as a math group (same spacing as ord).\n\n    return buildCommon.makeSpan([\"mord\"], [smashedNode], options);\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var node = new mathMLTree.MathNode(\"mpadded\", [buildMathML_buildGroup(group.body, options)]);\n\n    if (group.smashHeight) {\n      node.setAttribute(\"height\", \"0px\");\n    }\n\n    if (group.smashDepth) {\n      node.setAttribute(\"depth\", \"0px\");\n    }\n\n    return node;\n  }\n});\n// CONCATENATED MODULE: ./src/functions/sqrt.js\n\n\n\n\n\n\n\ndefineFunction({\n  type: \"sqrt\",\n  names: [\"\\\\sqrt\"],\n  props: {\n    numArgs: 1,\n    numOptionalArgs: 1\n  },\n  handler: function handler(_ref, args, optArgs) {\n    var parser = _ref.parser;\n    var index = optArgs[0];\n    var body = args[0];\n    return {\n      type: \"sqrt\",\n      mode: parser.mode,\n      body: body,\n      index: index\n    };\n  },\n  htmlBuilder: function htmlBuilder(group, options) {\n    // Square roots are handled in the TeXbook pg. 443, Rule 11.\n    // First, we do the same steps as in overline to build the inner group\n    // and line\n    var inner = buildHTML_buildGroup(group.body, options.havingCrampedStyle());\n\n    if (inner.height === 0) {\n      // Render a small surd.\n      inner.height = options.fontMetrics().xHeight;\n    } // Some groups can return document fragments.  Handle those by wrapping\n    // them in a span.\n\n\n    inner = buildCommon.wrapFragment(inner, options); // Calculate the minimum size for the \\surd delimiter\n\n    var metrics = options.fontMetrics();\n    var theta = metrics.defaultRuleThickness;\n    var phi = theta;\n\n    if (options.style.id < src_Style.TEXT.id) {\n      phi = options.fontMetrics().xHeight;\n    } // Calculate the clearance between the body and line\n\n\n    var lineClearance = theta + phi / 4;\n    var minDelimiterHeight = inner.height + inner.depth + lineClearance + theta; // Create a sqrt SVG of the required minimum size\n\n    var _delimiter$sqrtImage = delimiter.sqrtImage(minDelimiterHeight, options),\n        img = _delimiter$sqrtImage.span,\n        ruleWidth = _delimiter$sqrtImage.ruleWidth,\n        advanceWidth = _delimiter$sqrtImage.advanceWidth;\n\n    var delimDepth = img.height - ruleWidth; // Adjust the clearance based on the delimiter size\n\n    if (delimDepth > inner.height + inner.depth + lineClearance) {\n      lineClearance = (lineClearance + delimDepth - inner.height - inner.depth) / 2;\n    } // Shift the sqrt image\n\n\n    var imgShift = img.height - inner.height - lineClearance - ruleWidth;\n    inner.style.paddingLeft = advanceWidth + \"em\"; // Overlay the image and the argument.\n\n    var body = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: inner,\n        wrapperClasses: [\"svg-align\"]\n      }, {\n        type: \"kern\",\n        size: -(inner.height + imgShift)\n      }, {\n        type: \"elem\",\n        elem: img\n      }, {\n        type: \"kern\",\n        size: ruleWidth\n      }]\n    }, options);\n\n    if (!group.index) {\n      return buildCommon.makeSpan([\"mord\", \"sqrt\"], [body], options);\n    } else {\n      // Handle the optional root index\n      // The index is always in scriptscript style\n      var newOptions = options.havingStyle(src_Style.SCRIPTSCRIPT);\n      var rootm = buildHTML_buildGroup(group.index, newOptions, options); // The amount the index is shifted by. This is taken from the TeX\n      // source, in the definition of `\\r@@t`.\n\n      var toShift = 0.6 * (body.height - body.depth); // Build a VList with the superscript shifted up correctly\n\n      var rootVList = buildCommon.makeVList({\n        positionType: \"shift\",\n        positionData: -toShift,\n        children: [{\n          type: \"elem\",\n          elem: rootm\n        }]\n      }, options); // Add a class surrounding it so we can add on the appropriate\n      // kerning\n\n      var rootVListWrap = buildCommon.makeSpan([\"root\"], [rootVList]);\n      return buildCommon.makeSpan([\"mord\", \"sqrt\"], [rootVListWrap, body], options);\n    }\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var body = group.body,\n        index = group.index;\n    return index ? new mathMLTree.MathNode(\"mroot\", [buildMathML_buildGroup(body, options), buildMathML_buildGroup(index, options)]) : new mathMLTree.MathNode(\"msqrt\", [buildMathML_buildGroup(body, options)]);\n  }\n});\n// CONCATENATED MODULE: ./src/functions/styling.js\n\n\n\n\n\nvar styling_styleMap = {\n  \"display\": src_Style.DISPLAY,\n  \"text\": src_Style.TEXT,\n  \"script\": src_Style.SCRIPT,\n  \"scriptscript\": src_Style.SCRIPTSCRIPT\n};\ndefineFunction({\n  type: \"styling\",\n  names: [\"\\\\displaystyle\", \"\\\\textstyle\", \"\\\\scriptstyle\", \"\\\\scriptscriptstyle\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n  handler: function handler(_ref, args) {\n    var breakOnTokenText = _ref.breakOnTokenText,\n        funcName = _ref.funcName,\n        parser = _ref.parser;\n    // parse out the implicit body\n    var body = parser.parseExpression(true, breakOnTokenText); // TODO: Refactor to avoid duplicating styleMap in multiple places (e.g.\n    // here and in buildHTML and de-dupe the enumeration of all the styles).\n    // $FlowFixMe: The names above exactly match the styles.\n\n    var style = funcName.slice(1, funcName.length - 5);\n    return {\n      type: \"styling\",\n      mode: parser.mode,\n      // Figure out what style to use by pulling out the style from\n      // the function name\n      style: style,\n      body: body\n    };\n  },\n  htmlBuilder: function htmlBuilder(group, options) {\n    // Style changes are handled in the TeXbook on pg. 442, Rule 3.\n    var newStyle = styling_styleMap[group.style];\n    var newOptions = options.havingStyle(newStyle).withFont('');\n    return sizingGroup(group.body, newOptions, options);\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    // Figure out what style we're changing to.\n    var newStyle = styling_styleMap[group.style];\n    var newOptions = options.havingStyle(newStyle);\n    var inner = buildMathML_buildExpression(group.body, newOptions);\n    var node = new mathMLTree.MathNode(\"mstyle\", inner);\n    var styleAttributes = {\n      \"display\": [\"0\", \"true\"],\n      \"text\": [\"0\", \"false\"],\n      \"script\": [\"1\", \"false\"],\n      \"scriptscript\": [\"2\", \"false\"]\n    };\n    var attr = styleAttributes[group.style];\n    node.setAttribute(\"scriptlevel\", attr[0]);\n    node.setAttribute(\"displaystyle\", attr[1]);\n    return node;\n  }\n});\n// CONCATENATED MODULE: ./src/functions/supsub.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Sometimes, groups perform special rules when they have superscripts or\n * subscripts attached to them. This function lets the `supsub` group know that\n * Sometimes, groups perform special rules when they have superscripts or\n * its inner element should handle the superscripts and subscripts instead of\n * handling them itself.\n */\nvar supsub_htmlBuilderDelegate = function htmlBuilderDelegate(group, options) {\n  var base = group.base;\n\n  if (!base) {\n    return null;\n  } else if (base.type === \"op\") {\n    // Operators handle supsubs differently when they have limits\n    // (e.g. `\\displaystyle\\sum_2^3`)\n    var delegate = base.limits && (options.style.size === src_Style.DISPLAY.size || base.alwaysHandleSupSub);\n    return delegate ? op_htmlBuilder : null;\n  } else if (base.type === \"operatorname\") {\n    var _delegate = base.alwaysHandleSupSub && (options.style.size === src_Style.DISPLAY.size || base.limits);\n\n    return _delegate ? operatorname_htmlBuilder : null;\n  } else if (base.type === \"accent\") {\n    return utils.isCharacterBox(base.base) ? accent_htmlBuilder : null;\n  } else if (base.type === \"horizBrace\") {\n    var isSup = !group.sub;\n    return isSup === base.isOver ? horizBrace_htmlBuilder : null;\n  } else {\n    return null;\n  }\n}; // Super scripts and subscripts, whose precise placement can depend on other\n// functions that precede them.\n\n\ndefineFunctionBuilders({\n  type: \"supsub\",\n  htmlBuilder: function htmlBuilder(group, options) {\n    // Superscript and subscripts are handled in the TeXbook on page\n    // 445-446, rules 18(a-f).\n    // Here is where we defer to the inner group if it should handle\n    // superscripts and subscripts itself.\n    var builderDelegate = supsub_htmlBuilderDelegate(group, options);\n\n    if (builderDelegate) {\n      return builderDelegate(group, options);\n    }\n\n    var valueBase = group.base,\n        valueSup = group.sup,\n        valueSub = group.sub;\n    var base = buildHTML_buildGroup(valueBase, options);\n    var supm;\n    var subm;\n    var metrics = options.fontMetrics(); // Rule 18a\n\n    var supShift = 0;\n    var subShift = 0;\n    var isCharacterBox = valueBase && utils.isCharacterBox(valueBase);\n\n    if (valueSup) {\n      var newOptions = options.havingStyle(options.style.sup());\n      supm = buildHTML_buildGroup(valueSup, newOptions, options);\n\n      if (!isCharacterBox) {\n        supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;\n      }\n    }\n\n    if (valueSub) {\n      var _newOptions = options.havingStyle(options.style.sub());\n\n      subm = buildHTML_buildGroup(valueSub, _newOptions, options);\n\n      if (!isCharacterBox) {\n        subShift = base.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options.sizeMultiplier;\n      }\n    } // Rule 18c\n\n\n    var minSupShift;\n\n    if (options.style === src_Style.DISPLAY) {\n      minSupShift = metrics.sup1;\n    } else if (options.style.cramped) {\n      minSupShift = metrics.sup3;\n    } else {\n      minSupShift = metrics.sup2;\n    } // scriptspace is a font-size-independent size, so scale it\n    // appropriately for use as the marginRight.\n\n\n    var multiplier = options.sizeMultiplier;\n    var marginRight = 0.5 / metrics.ptPerEm / multiplier + \"em\";\n    var marginLeft = null;\n\n    if (subm) {\n      // Subscripts shouldn't be shifted by the base's italic correction.\n      // Account for that by shifting the subscript back the appropriate\n      // amount. Note we only do this when the base is a single symbol.\n      var isOiint = group.base && group.base.type === \"op\" && group.base.name && (group.base.name === \"\\\\oiint\" || group.base.name === \"\\\\oiiint\");\n\n      if (base instanceof domTree_SymbolNode || isOiint) {\n        // $FlowFixMe\n        marginLeft = -base.italic + \"em\";\n      }\n    }\n\n    var supsub;\n\n    if (supm && subm) {\n      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);\n      subShift = Math.max(subShift, metrics.sub2);\n      var ruleWidth = metrics.defaultRuleThickness; // Rule 18e\n\n      var maxWidth = 4 * ruleWidth;\n\n      if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {\n        subShift = maxWidth - (supShift - supm.depth) + subm.height;\n        var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);\n\n        if (psi > 0) {\n          supShift += psi;\n          subShift -= psi;\n        }\n      }\n\n      var vlistElem = [{\n        type: \"elem\",\n        elem: subm,\n        shift: subShift,\n        marginRight: marginRight,\n        marginLeft: marginLeft\n      }, {\n        type: \"elem\",\n        elem: supm,\n        shift: -supShift,\n        marginRight: marginRight\n      }];\n      supsub = buildCommon.makeVList({\n        positionType: \"individualShift\",\n        children: vlistElem\n      }, options);\n    } else if (subm) {\n      // Rule 18b\n      subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);\n      var _vlistElem = [{\n        type: \"elem\",\n        elem: subm,\n        marginLeft: marginLeft,\n        marginRight: marginRight\n      }];\n      supsub = buildCommon.makeVList({\n        positionType: \"shift\",\n        positionData: subShift,\n        children: _vlistElem\n      }, options);\n    } else if (supm) {\n      // Rule 18c, d\n      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);\n      supsub = buildCommon.makeVList({\n        positionType: \"shift\",\n        positionData: -supShift,\n        children: [{\n          type: \"elem\",\n          elem: supm,\n          marginRight: marginRight\n        }]\n      }, options);\n    } else {\n      throw new Error(\"supsub must have either sup or sub.\");\n    } // Wrap the supsub vlist in a span.msupsub to reset text-align.\n\n\n    var mclass = getTypeOfDomTree(base, \"right\") || \"mord\";\n    return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan([\"msupsub\"], [supsub])], options);\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    // Is the inner group a relevant horizonal brace?\n    var isBrace = false;\n    var isOver;\n    var isSup;\n    var horizBrace = checkNodeType(group.base, \"horizBrace\");\n\n    if (horizBrace) {\n      isSup = !!group.sup;\n\n      if (isSup === horizBrace.isOver) {\n        isBrace = true;\n        isOver = horizBrace.isOver;\n      }\n    }\n\n    if (group.base && (group.base.type === \"op\" || group.base.type === \"operatorname\")) {\n      group.base.parentIsSupSub = true;\n    }\n\n    var children = [buildMathML_buildGroup(group.base, options)];\n\n    if (group.sub) {\n      children.push(buildMathML_buildGroup(group.sub, options));\n    }\n\n    if (group.sup) {\n      children.push(buildMathML_buildGroup(group.sup, options));\n    }\n\n    var nodeType;\n\n    if (isBrace) {\n      nodeType = isOver ? \"mover\" : \"munder\";\n    } else if (!group.sub) {\n      var base = group.base;\n\n      if (base && base.type === \"op\" && base.limits && (options.style === src_Style.DISPLAY || base.alwaysHandleSupSub)) {\n        nodeType = \"mover\";\n      } else if (base && base.type === \"operatorname\" && base.alwaysHandleSupSub && (base.limits || options.style === src_Style.DISPLAY)) {\n        nodeType = \"mover\";\n      } else {\n        nodeType = \"msup\";\n      }\n    } else if (!group.sup) {\n      var _base = group.base;\n\n      if (_base && _base.type === \"op\" && _base.limits && (options.style === src_Style.DISPLAY || _base.alwaysHandleSupSub)) {\n        nodeType = \"munder\";\n      } else if (_base && _base.type === \"operatorname\" && _base.alwaysHandleSupSub && (_base.limits || options.style === src_Style.DISPLAY)) {\n        nodeType = \"munder\";\n      } else {\n        nodeType = \"msub\";\n      }\n    } else {\n      var _base2 = group.base;\n\n      if (_base2 && _base2.type === \"op\" && _base2.limits && options.style === src_Style.DISPLAY) {\n        nodeType = \"munderover\";\n      } else if (_base2 && _base2.type === \"operatorname\" && _base2.alwaysHandleSupSub && (options.style === src_Style.DISPLAY || _base2.limits)) {\n        nodeType = \"munderover\";\n      } else {\n        nodeType = \"msubsup\";\n      }\n    }\n\n    var node = new mathMLTree.MathNode(nodeType, children);\n    return node;\n  }\n});\n// CONCATENATED MODULE: ./src/functions/symbolsOp.js\n\n\n\n // Operator ParseNodes created in Parser.js from symbol Groups in src/symbols.js.\n\ndefineFunctionBuilders({\n  type: \"atom\",\n  htmlBuilder: function htmlBuilder(group, options) {\n    return buildCommon.mathsym(group.text, group.mode, options, [\"m\" + group.family]);\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var node = new mathMLTree.MathNode(\"mo\", [buildMathML_makeText(group.text, group.mode)]);\n\n    if (group.family === \"bin\") {\n      var variant = buildMathML_getVariant(group, options);\n\n      if (variant === \"bold-italic\") {\n        node.setAttribute(\"mathvariant\", variant);\n      }\n    } else if (group.family === \"punct\") {\n      node.setAttribute(\"separator\", \"true\");\n    } else if (group.family === \"open\" || group.family === \"close\") {\n      // Delims built here should not stretch vertically.\n      // See delimsizing.js for stretchy delims.\n      node.setAttribute(\"stretchy\", \"false\");\n    }\n\n    return node;\n  }\n});\n// CONCATENATED MODULE: ./src/functions/symbolsOrd.js\n\n\n\n\n// \"mathord\" and \"textord\" ParseNodes created in Parser.js from symbol Groups in\nvar defaultVariant = {\n  \"mi\": \"italic\",\n  \"mn\": \"normal\",\n  \"mtext\": \"normal\"\n};\ndefineFunctionBuilders({\n  type: \"mathord\",\n  htmlBuilder: function htmlBuilder(group, options) {\n    return buildCommon.makeOrd(group, options, \"mathord\");\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var node = new mathMLTree.MathNode(\"mi\", [buildMathML_makeText(group.text, group.mode, options)]);\n    var variant = buildMathML_getVariant(group, options) || \"italic\";\n\n    if (variant !== defaultVariant[node.type]) {\n      node.setAttribute(\"mathvariant\", variant);\n    }\n\n    return node;\n  }\n});\ndefineFunctionBuilders({\n  type: \"textord\",\n  htmlBuilder: function htmlBuilder(group, options) {\n    return buildCommon.makeOrd(group, options, \"textord\");\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var text = buildMathML_makeText(group.text, group.mode, options);\n    var variant = buildMathML_getVariant(group, options) || \"normal\";\n    var node;\n\n    if (group.mode === 'text') {\n      node = new mathMLTree.MathNode(\"mtext\", [text]);\n    } else if (/[0-9]/.test(group.text)) {\n      // TODO(kevinb) merge adjacent <mn> nodes\n      // do it as a post processing step\n      node = new mathMLTree.MathNode(\"mn\", [text]);\n    } else if (group.text === \"\\\\prime\") {\n      node = new mathMLTree.MathNode(\"mo\", [text]);\n    } else {\n      node = new mathMLTree.MathNode(\"mi\", [text]);\n    }\n\n    if (variant !== defaultVariant[node.type]) {\n      node.setAttribute(\"mathvariant\", variant);\n    }\n\n    return node;\n  }\n});\n// CONCATENATED MODULE: ./src/functions/symbolsSpacing.js\n\n\n\n // A map of CSS-based spacing functions to their CSS class.\n\nvar cssSpace = {\n  \"\\\\nobreak\": \"nobreak\",\n  \"\\\\allowbreak\": \"allowbreak\"\n}; // A lookup table to determine whether a spacing function/symbol should be\n// treated like a regular space character.  If a symbol or command is a key\n// in this table, then it should be a regular space character.  Furthermore,\n// the associated value may have a `className` specifying an extra CSS class\n// to add to the created `span`.\n\nvar regularSpace = {\n  \" \": {},\n  \"\\\\ \": {},\n  \"~\": {\n    className: \"nobreak\"\n  },\n  \"\\\\space\": {},\n  \"\\\\nobreakspace\": {\n    className: \"nobreak\"\n  }\n}; // ParseNode<\"spacing\"> created in Parser.js from the \"spacing\" symbol Groups in\n// src/symbols.js.\n\ndefineFunctionBuilders({\n  type: \"spacing\",\n  htmlBuilder: function htmlBuilder(group, options) {\n    if (regularSpace.hasOwnProperty(group.text)) {\n      var className = regularSpace[group.text].className || \"\"; // Spaces are generated by adding an actual space. Each of these\n      // things has an entry in the symbols table, so these will be turned\n      // into appropriate outputs.\n\n      if (group.mode === \"text\") {\n        var ord = buildCommon.makeOrd(group, options, \"textord\");\n        ord.classes.push(className);\n        return ord;\n      } else {\n        return buildCommon.makeSpan([\"mspace\", className], [buildCommon.mathsym(group.text, group.mode, options)], options);\n      }\n    } else if (cssSpace.hasOwnProperty(group.text)) {\n      // Spaces based on just a CSS class.\n      return buildCommon.makeSpan([\"mspace\", cssSpace[group.text]], [], options);\n    } else {\n      throw new src_ParseError(\"Unknown type of space \\\"\" + group.text + \"\\\"\");\n    }\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var node;\n\n    if (regularSpace.hasOwnProperty(group.text)) {\n      node = new mathMLTree.MathNode(\"mtext\", [new mathMLTree.TextNode(\"\\xA0\")]);\n    } else if (cssSpace.hasOwnProperty(group.text)) {\n      // CSS-based MathML spaces (\\nobreak, \\allowbreak) are ignored\n      return new mathMLTree.MathNode(\"mspace\");\n    } else {\n      throw new src_ParseError(\"Unknown type of space \\\"\" + group.text + \"\\\"\");\n    }\n\n    return node;\n  }\n});\n// CONCATENATED MODULE: ./src/functions/tag.js\n\n\n\n\nvar tag_pad = function pad() {\n  var padNode = new mathMLTree.MathNode(\"mtd\", []);\n  padNode.setAttribute(\"width\", \"50%\");\n  return padNode;\n};\n\ndefineFunctionBuilders({\n  type: \"tag\",\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var table = new mathMLTree.MathNode(\"mtable\", [new mathMLTree.MathNode(\"mtr\", [tag_pad(), new mathMLTree.MathNode(\"mtd\", [buildExpressionRow(group.body, options)]), tag_pad(), new mathMLTree.MathNode(\"mtd\", [buildExpressionRow(group.tag, options)])])]);\n    table.setAttribute(\"width\", \"100%\");\n    return table; // TODO: Left-aligned tags.\n    // Currently, the group and options passed here do not contain\n    // enough info to set tag alignment. `leqno` is in Settings but it is\n    // not passed to Options. On the HTML side, leqno is\n    // set by a CSS class applied in buildTree.js. That would have worked\n    // in MathML if browsers supported <mlabeledtr>. Since they don't, we\n    // need to rewrite the way this function is called.\n  }\n});\n// CONCATENATED MODULE: ./src/functions/text.js\n\n\n\n // Non-mathy text, possibly in a font\n\nvar textFontFamilies = {\n  \"\\\\text\": undefined,\n  \"\\\\textrm\": \"textrm\",\n  \"\\\\textsf\": \"textsf\",\n  \"\\\\texttt\": \"texttt\",\n  \"\\\\textnormal\": \"textrm\"\n};\nvar textFontWeights = {\n  \"\\\\textbf\": \"textbf\",\n  \"\\\\textmd\": \"textmd\"\n};\nvar textFontShapes = {\n  \"\\\\textit\": \"textit\",\n  \"\\\\textup\": \"textup\"\n};\n\nvar optionsWithFont = function optionsWithFont(group, options) {\n  var font = group.font; // Checks if the argument is a font family or a font style.\n\n  if (!font) {\n    return options;\n  } else if (textFontFamilies[font]) {\n    return options.withTextFontFamily(textFontFamilies[font]);\n  } else if (textFontWeights[font]) {\n    return options.withTextFontWeight(textFontWeights[font]);\n  } else {\n    return options.withTextFontShape(textFontShapes[font]);\n  }\n};\n\ndefineFunction({\n  type: \"text\",\n  names: [// Font families\n  \"\\\\text\", \"\\\\textrm\", \"\\\\textsf\", \"\\\\texttt\", \"\\\\textnormal\", // Font weights\n  \"\\\\textbf\", \"\\\\textmd\", // Font Shapes\n  \"\\\\textit\", \"\\\\textup\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"text\"],\n    greediness: 2,\n    allowedInText: true\n  },\n  handler: function handler(_ref, args) {\n    var parser = _ref.parser,\n        funcName = _ref.funcName;\n    var body = args[0];\n    return {\n      type: \"text\",\n      mode: parser.mode,\n      body: defineFunction_ordargument(body),\n      font: funcName\n    };\n  },\n  htmlBuilder: function htmlBuilder(group, options) {\n    var newOptions = optionsWithFont(group, options);\n    var inner = buildHTML_buildExpression(group.body, newOptions, true);\n    return buildCommon.makeSpan([\"mord\", \"text\"], buildCommon.tryCombineChars(inner), newOptions);\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var newOptions = optionsWithFont(group, options);\n    return buildExpressionRow(group.body, newOptions);\n  }\n});\n// CONCATENATED MODULE: ./src/functions/underline.js\n\n\n\n\n\ndefineFunction({\n  type: \"underline\",\n  names: [\"\\\\underline\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n  handler: function handler(_ref, args) {\n    var parser = _ref.parser;\n    return {\n      type: \"underline\",\n      mode: parser.mode,\n      body: args[0]\n    };\n  },\n  htmlBuilder: function htmlBuilder(group, options) {\n    // Underlines are handled in the TeXbook pg 443, Rule 10.\n    // Build the inner group.\n    var innerGroup = buildHTML_buildGroup(group.body, options); // Create the line to go below the body\n\n    var line = buildCommon.makeLineSpan(\"underline-line\", options); // Generate the vlist, with the appropriate kerns\n\n    var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;\n    var vlist = buildCommon.makeVList({\n      positionType: \"top\",\n      positionData: innerGroup.height,\n      children: [{\n        type: \"kern\",\n        size: defaultRuleThickness\n      }, {\n        type: \"elem\",\n        elem: line\n      }, {\n        type: \"kern\",\n        size: 3 * defaultRuleThickness\n      }, {\n        type: \"elem\",\n        elem: innerGroup\n      }]\n    }, options);\n    return buildCommon.makeSpan([\"mord\", \"underline\"], [vlist], options);\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var operator = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(\"\\u203E\")]);\n    operator.setAttribute(\"stretchy\", \"true\");\n    var node = new mathMLTree.MathNode(\"munder\", [buildMathML_buildGroup(group.body, options), operator]);\n    node.setAttribute(\"accentunder\", \"true\");\n    return node;\n  }\n});\n// CONCATENATED MODULE: ./src/functions/verb.js\n\n\n\n\ndefineFunction({\n  type: \"verb\",\n  names: [\"\\\\verb\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n  handler: function handler(context, args, optArgs) {\n    // \\verb and \\verb* are dealt with directly in Parser.js.\n    // If we end up here, it's because of a failure to match the two delimiters\n    // in the regex in Lexer.js.  LaTeX raises the following error when \\verb is\n    // terminated by end of line (or file).\n    throw new src_ParseError(\"\\\\verb ended by end of line instead of matching delimiter\");\n  },\n  htmlBuilder: function htmlBuilder(group, options) {\n    var text = makeVerb(group);\n    var body = []; // \\verb enters text mode and therefore is sized like \\textstyle\n\n    var newOptions = options.havingStyle(options.style.text());\n\n    for (var i = 0; i < text.length; i++) {\n      var c = text[i];\n\n      if (c === '~') {\n        c = '\\\\textasciitilde';\n      }\n\n      body.push(buildCommon.makeSymbol(c, \"Typewriter-Regular\", group.mode, newOptions, [\"mord\", \"texttt\"]));\n    }\n\n    return buildCommon.makeSpan([\"mord\", \"text\"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);\n  },\n  mathmlBuilder: function mathmlBuilder(group, options) {\n    var text = new mathMLTree.TextNode(makeVerb(group));\n    var node = new mathMLTree.MathNode(\"mtext\", [text]);\n    node.setAttribute(\"mathvariant\", \"monospace\");\n    return node;\n  }\n});\n/**\n * Converts verb group into body string.\n *\n * \\verb* replaces each space with an open box \\u2423\n * \\verb replaces each space with a no-break space \\xA0\n */\n\nvar makeVerb = function makeVerb(group) {\n  return group.body.replace(/ /g, group.star ? \"\\u2423\" : '\\xA0');\n};\n// CONCATENATED MODULE: ./src/functions.js\n/** Include this to ensure that all functions are defined. */\n\nvar functions = _functions;\n/* harmony default export */ var src_functions = (functions); // TODO(kevinb): have functions return an object and call defineFunction with\n// that object in this file instead of relying on side-effects.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: ./src/Lexer.js\n/**\n * The Lexer class handles tokenizing the input in various ways. Since our\n * parser expects us to be able to backtrack, the lexer allows lexing from any\n * given starting point.\n *\n * Its main exposed function is the `lex` function, which takes a position to\n * lex from and a type of token to lex. It defers to the appropriate `_innerLex`\n * function.\n *\n * The various `_innerLex` functions perform the actual lexing of different\n * kinds.\n */\n\n\n\n\n/* The following tokenRegex\n * - matches typical whitespace (but not NBSP etc.) using its first group\n * - does not match any control character \\x00-\\x1f except whitespace\n * - does not match a bare backslash\n * - matches any ASCII character except those just mentioned\n * - does not match the BMP private use area \\uE000-\\uF8FF\n * - does not match bare surrogate code units\n * - matches any BMP character except for those just described\n * - matches any valid Unicode surrogate pair\n * - matches a backslash followed by one or more letters\n * - matches a backslash followed by any BMP character, including newline\n * Just because the Lexer matches something doesn't mean it's valid input:\n * If there is no matching function or symbol definition, the Parser will\n * still reject the input.\n */\nvar spaceRegexString = \"[ \\r\\n\\t]\";\nvar controlWordRegexString = \"\\\\\\\\[a-zA-Z@]+\";\nvar controlSymbolRegexString = \"\\\\\\\\[^\\uD800-\\uDFFF]\";\nvar controlWordWhitespaceRegexString = \"\" + controlWordRegexString + spaceRegexString + \"*\";\nvar controlWordWhitespaceRegex = new RegExp(\"^(\" + controlWordRegexString + \")\" + spaceRegexString + \"*$\");\nvar combiningDiacriticalMarkString = \"[\\u0300-\\u036F]\";\nvar combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + \"+$\");\nvar tokenRegexString = \"(\" + spaceRegexString + \"+)|\" + // whitespace\n\"([!-\\\\[\\\\]-\\u2027\\u202A-\\uD7FF\\uF900-\\uFFFF]\" + ( // single codepoint\ncombiningDiacriticalMarkString + \"*\") + // ...plus accents\n\"|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]\" + ( // surrogate pair\ncombiningDiacriticalMarkString + \"*\") + // ...plus accents\n\"|\\\\\\\\verb\\\\*([^]).*?\\\\3\" + // \\verb*\n\"|\\\\\\\\verb([^*a-zA-Z]).*?\\\\4\" + // \\verb unstarred\n\"|\\\\\\\\operatorname\\\\*\" + ( // \\operatorname*\n\"|\" + controlWordWhitespaceRegexString) + ( // \\macroName + spaces\n\"|\" + controlSymbolRegexString + \")\"); // \\\\, \\', etc.\n\n/** Main Lexer class */\n\nvar Lexer_Lexer =\n/*#__PURE__*/\nfunction () {\n  // category codes, only supports comment characters (14) for now\n  function Lexer(input, settings) {\n    this.input = void 0;\n    this.settings = void 0;\n    this.tokenRegex = void 0;\n    this.catcodes = void 0;\n    // Separate accents from characters\n    this.input = input;\n    this.settings = settings;\n    this.tokenRegex = new RegExp(tokenRegexString, 'g');\n    this.catcodes = {\n      \"%\": 14 // comment character\n\n    };\n  }\n\n  var _proto = Lexer.prototype;\n\n  _proto.setCatcode = function setCatcode(char, code) {\n    this.catcodes[char] = code;\n  }\n  /**\n   * This function lexes a single token.\n   */\n  ;\n\n  _proto.lex = function lex() {\n    var input = this.input;\n    var pos = this.tokenRegex.lastIndex;\n\n    if (pos === input.length) {\n      return new Token_Token(\"EOF\", new SourceLocation(this, pos, pos));\n    }\n\n    var match = this.tokenRegex.exec(input);\n\n    if (match === null || match.index !== pos) {\n      throw new src_ParseError(\"Unexpected character: '\" + input[pos] + \"'\", new Token_Token(input[pos], new SourceLocation(this, pos, pos + 1)));\n    }\n\n    var text = match[2] || \" \";\n\n    if (this.catcodes[text] === 14) {\n      // comment character\n      var nlIndex = input.indexOf('\\n', this.tokenRegex.lastIndex);\n\n      if (nlIndex === -1) {\n        this.tokenRegex.lastIndex = input.length; // EOF\n\n        this.settings.reportNonstrict(\"commentAtEnd\", \"% comment has no terminating newline; LaTeX would \" + \"fail because of commenting the end of math mode (e.g. $)\");\n      } else {\n        this.tokenRegex.lastIndex = nlIndex + 1;\n      }\n\n      return this.lex();\n    } // Trim any trailing whitespace from control word match\n\n\n    var controlMatch = text.match(controlWordWhitespaceRegex);\n\n    if (controlMatch) {\n      text = controlMatch[1];\n    }\n\n    return new Token_Token(text, new SourceLocation(this, pos, this.tokenRegex.lastIndex));\n  };\n\n  return Lexer;\n}();\n\n\n// CONCATENATED MODULE: ./src/Namespace.js\n/**\n * A `Namespace` refers to a space of nameable things like macros or lengths,\n * which can be `set` either globally or local to a nested group, using an\n * undo stack similar to how TeX implements this functionality.\n * Performance-wise, `get` and local `set` take constant time, while global\n * `set` takes time proportional to the depth of group nesting.\n */\n\n\nvar Namespace_Namespace =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Both arguments are optional.  The first argument is an object of\n   * built-in mappings which never change.  The second argument is an object\n   * of initial (global-level) mappings, which will constantly change\n   * according to any global/top-level `set`s done.\n   */\n  function Namespace(builtins, globalMacros) {\n    if (builtins === void 0) {\n      builtins = {};\n    }\n\n    if (globalMacros === void 0) {\n      globalMacros = {};\n    }\n\n    this.current = void 0;\n    this.builtins = void 0;\n    this.undefStack = void 0;\n    this.current = globalMacros;\n    this.builtins = builtins;\n    this.undefStack = [];\n  }\n  /**\n   * Start a new nested group, affecting future local `set`s.\n   */\n\n\n  var _proto = Namespace.prototype;\n\n  _proto.beginGroup = function beginGroup() {\n    this.undefStack.push({});\n  }\n  /**\n   * End current nested group, restoring values before the group began.\n   */\n  ;\n\n  _proto.endGroup = function endGroup() {\n    if (this.undefStack.length === 0) {\n      throw new src_ParseError(\"Unbalanced namespace destruction: attempt \" + \"to pop global namespace; please report this as a bug\");\n    }\n\n    var undefs = this.undefStack.pop();\n\n    for (var undef in undefs) {\n      if (undefs.hasOwnProperty(undef)) {\n        if (undefs[undef] === undefined) {\n          delete this.current[undef];\n        } else {\n          this.current[undef] = undefs[undef];\n        }\n      }\n    }\n  }\n  /**\n   * Detect whether `name` has a definition.  Equivalent to\n   * `get(name) != null`.\n   */\n  ;\n\n  _proto.has = function has(name) {\n    return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);\n  }\n  /**\n   * Get the current value of a name, or `undefined` if there is no value.\n   *\n   * Note: Do not use `if (namespace.get(...))` to detect whether a macro\n   * is defined, as the definition may be the empty string which evaluates\n   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or\n   * `if (namespace.has(...))`.\n   */\n  ;\n\n  _proto.get = function get(name) {\n    if (this.current.hasOwnProperty(name)) {\n      return this.current[name];\n    } else {\n      return this.builtins[name];\n    }\n  }\n  /**\n   * Set the current value of a name, and optionally set it globally too.\n   * Local set() sets the current value and (when appropriate) adds an undo\n   * operation to the undo stack.  Global set() may change the undo\n   * operation at every level, so takes time linear in their number.\n   */\n  ;\n\n  _proto.set = function set(name, value, global) {\n    if (global === void 0) {\n      global = false;\n    }\n\n    if (global) {\n      // Global set is equivalent to setting in all groups.  Simulate this\n      // by destroying any undos currently scheduled for this name,\n      // and adding an undo with the *new* value (in case it later gets\n      // locally reset within this environment).\n      for (var i = 0; i < this.undefStack.length; i++) {\n        delete this.undefStack[i][name];\n      }\n\n      if (this.undefStack.length > 0) {\n        this.undefStack[this.undefStack.length - 1][name] = value;\n      }\n    } else {\n      // Undo this set at end of this group (possibly to `undefined`),\n      // unless an undo is already in place, in which case that older\n      // value is the correct one.\n      var top = this.undefStack[this.undefStack.length - 1];\n\n      if (top && !top.hasOwnProperty(name)) {\n        top[name] = this.current[name];\n      }\n    }\n\n    this.current[name] = value;\n  };\n\n  return Namespace;\n}();\n\n\n// CONCATENATED MODULE: ./src/macros.js\n/**\n * Predefined macros for KaTeX.\n * This can be used to define some commands in terms of others.\n */\n\n\n\n\n\nvar builtinMacros = {};\n/* harmony default export */ var macros = (builtinMacros); // This function might one day accept an additional argument and do more things.\n\nfunction defineMacro(name, body) {\n  builtinMacros[name] = body;\n} //////////////////////////////////////////////////////////////////////\n// macro tools\n// LaTeX's \\@firstoftwo{#1}{#2} expands to #1, skipping #2\n// TeX source: \\long\\def\\@firstoftwo#1#2{#1}\n\ndefineMacro(\"\\\\@firstoftwo\", function (context) {\n  var args = context.consumeArgs(2);\n  return {\n    tokens: args[0],\n    numArgs: 0\n  };\n}); // LaTeX's \\@secondoftwo{#1}{#2} expands to #2, skipping #1\n// TeX source: \\long\\def\\@secondoftwo#1#2{#2}\n\ndefineMacro(\"\\\\@secondoftwo\", function (context) {\n  var args = context.consumeArgs(2);\n  return {\n    tokens: args[1],\n    numArgs: 0\n  };\n}); // LaTeX's \\@ifnextchar{#1}{#2}{#3} looks ahead to the next (unexpanded)\n// symbol.  If it matches #1, then the macro expands to #2; otherwise, #3.\n// Note, however, that it does not consume the next symbol in either case.\n\ndefineMacro(\"\\\\@ifnextchar\", function (context) {\n  var args = context.consumeArgs(3); // symbol, if, else\n\n  var nextToken = context.future();\n\n  if (args[0].length === 1 && args[0][0].text === nextToken.text) {\n    return {\n      tokens: args[1],\n      numArgs: 0\n    };\n  } else {\n    return {\n      tokens: args[2],\n      numArgs: 0\n    };\n  }\n}); // LaTeX's \\@ifstar{#1}{#2} looks ahead to the next (unexpanded) symbol.\n// If it is `*`, then it consumes the symbol, and the macro expands to #1;\n// otherwise, the macro expands to #2 (without consuming the symbol).\n// TeX source: \\def\\@ifstar#1{\\@ifnextchar *{\\@firstoftwo{#1}}}\n\ndefineMacro(\"\\\\@ifstar\", \"\\\\@ifnextchar *{\\\\@firstoftwo{#1}}\"); // LaTeX's \\TextOrMath{#1}{#2} expands to #1 in text mode, #2 in math mode\n\ndefineMacro(\"\\\\TextOrMath\", function (context) {\n  var args = context.consumeArgs(2);\n\n  if (context.mode === 'text') {\n    return {\n      tokens: args[0],\n      numArgs: 0\n    };\n  } else {\n    return {\n      tokens: args[1],\n      numArgs: 0\n    };\n  }\n}); // Lookup table for parsing numbers in base 8 through 16\n\nvar digitToNumber = {\n  \"0\": 0,\n  \"1\": 1,\n  \"2\": 2,\n  \"3\": 3,\n  \"4\": 4,\n  \"5\": 5,\n  \"6\": 6,\n  \"7\": 7,\n  \"8\": 8,\n  \"9\": 9,\n  \"a\": 10,\n  \"A\": 10,\n  \"b\": 11,\n  \"B\": 11,\n  \"c\": 12,\n  \"C\": 12,\n  \"d\": 13,\n  \"D\": 13,\n  \"e\": 14,\n  \"E\": 14,\n  \"f\": 15,\n  \"F\": 15\n}; // TeX \\char makes a literal character (catcode 12) using the following forms:\n// (see The TeXBook, p. 43)\n//   \\char123  -- decimal\n//   \\char'123 -- octal\n//   \\char\"123 -- hex\n//   \\char`x   -- character that can be written (i.e. isn't active)\n//   \\char`\\x  -- character that cannot be written (e.g. %)\n// These all refer to characters from the font, so we turn them into special\n// calls to a function \\@char dealt with in the Parser.\n\ndefineMacro(\"\\\\char\", function (context) {\n  var token = context.popToken();\n  var base;\n  var number = '';\n\n  if (token.text === \"'\") {\n    base = 8;\n    token = context.popToken();\n  } else if (token.text === '\"') {\n    base = 16;\n    token = context.popToken();\n  } else if (token.text === \"`\") {\n    token = context.popToken();\n\n    if (token.text[0] === \"\\\\\") {\n      number = token.text.charCodeAt(1);\n    } else if (token.text === \"EOF\") {\n      throw new src_ParseError(\"\\\\char` missing argument\");\n    } else {\n      number = token.text.charCodeAt(0);\n    }\n  } else {\n    base = 10;\n  }\n\n  if (base) {\n    // Parse a number in the given base, starting with first `token`.\n    number = digitToNumber[token.text];\n\n    if (number == null || number >= base) {\n      throw new src_ParseError(\"Invalid base-\" + base + \" digit \" + token.text);\n    }\n\n    var digit;\n\n    while ((digit = digitToNumber[context.future().text]) != null && digit < base) {\n      number *= base;\n      number += digit;\n      context.popToken();\n    }\n  }\n\n  return \"\\\\@char{\" + number + \"}\";\n}); // Basic support for macro definitions:\n//     \\def\\macro{expansion}\n//     \\def\\macro#1{expansion}\n//     \\def\\macro#1#2{expansion}\n//     \\def\\macro#1#2#3#4#5#6#7#8#9{expansion}\n// Also the \\gdef and \\global\\def equivalents\n\nvar macros_def = function def(context, global) {\n  var arg = context.consumeArgs(1)[0];\n\n  if (arg.length !== 1) {\n    throw new src_ParseError(\"\\\\gdef's first argument must be a macro name\");\n  }\n\n  var name = arg[0].text; // Count argument specifiers, and check they are in the order #1 #2 ...\n\n  var numArgs = 0;\n  arg = context.consumeArgs(1)[0];\n\n  while (arg.length === 1 && arg[0].text === \"#\") {\n    arg = context.consumeArgs(1)[0];\n\n    if (arg.length !== 1) {\n      throw new src_ParseError(\"Invalid argument number length \\\"\" + arg.length + \"\\\"\");\n    }\n\n    if (!/^[1-9]$/.test(arg[0].text)) {\n      throw new src_ParseError(\"Invalid argument number \\\"\" + arg[0].text + \"\\\"\");\n    }\n\n    numArgs++;\n\n    if (parseInt(arg[0].text) !== numArgs) {\n      throw new src_ParseError(\"Argument number \\\"\" + arg[0].text + \"\\\" out of order\");\n    }\n\n    arg = context.consumeArgs(1)[0];\n  } // Final arg is the expansion of the macro\n\n\n  context.macros.set(name, {\n    tokens: arg,\n    numArgs: numArgs\n  }, global);\n  return '';\n};\n\ndefineMacro(\"\\\\gdef\", function (context) {\n  return macros_def(context, true);\n});\ndefineMacro(\"\\\\def\", function (context) {\n  return macros_def(context, false);\n});\ndefineMacro(\"\\\\global\", function (context) {\n  var next = context.consumeArgs(1)[0];\n\n  if (next.length !== 1) {\n    throw new src_ParseError(\"Invalid command after \\\\global\");\n  }\n\n  var command = next[0].text; // TODO: Should expand command\n\n  if (command === \"\\\\def\") {\n    // \\global\\def is equivalent to \\gdef\n    return macros_def(context, true);\n  } else {\n    throw new src_ParseError(\"Invalid command '\" + command + \"' after \\\\global\");\n  }\n}); // \\newcommand{\\macro}[args]{definition}\n// \\renewcommand{\\macro}[args]{definition}\n// TODO: Optional arguments: \\newcommand{\\macro}[args][default]{definition}\n\nvar macros_newcommand = function newcommand(context, existsOK, nonexistsOK) {\n  var arg = context.consumeArgs(1)[0];\n\n  if (arg.length !== 1) {\n    throw new src_ParseError(\"\\\\newcommand's first argument must be a macro name\");\n  }\n\n  var name = arg[0].text;\n  var exists = context.isDefined(name);\n\n  if (exists && !existsOK) {\n    throw new src_ParseError(\"\\\\newcommand{\" + name + \"} attempting to redefine \" + (name + \"; use \\\\renewcommand\"));\n  }\n\n  if (!exists && !nonexistsOK) {\n    throw new src_ParseError(\"\\\\renewcommand{\" + name + \"} when command \" + name + \" \" + \"does not yet exist; use \\\\newcommand\");\n  }\n\n  var numArgs = 0;\n  arg = context.consumeArgs(1)[0];\n\n  if (arg.length === 1 && arg[0].text === \"[\") {\n    var argText = '';\n    var token = context.expandNextToken();\n\n    while (token.text !== \"]\" && token.text !== \"EOF\") {\n      // TODO: Should properly expand arg, e.g., ignore {}s\n      argText += token.text;\n      token = context.expandNextToken();\n    }\n\n    if (!argText.match(/^\\s*[0-9]+\\s*$/)) {\n      throw new src_ParseError(\"Invalid number of arguments: \" + argText);\n    }\n\n    numArgs = parseInt(argText);\n    arg = context.consumeArgs(1)[0];\n  } // Final arg is the expansion of the macro\n\n\n  context.macros.set(name, {\n    tokens: arg,\n    numArgs: numArgs\n  });\n  return '';\n};\n\ndefineMacro(\"\\\\newcommand\", function (context) {\n  return macros_newcommand(context, false, true);\n});\ndefineMacro(\"\\\\renewcommand\", function (context) {\n  return macros_newcommand(context, true, false);\n});\ndefineMacro(\"\\\\providecommand\", function (context) {\n  return macros_newcommand(context, true, true);\n}); //////////////////////////////////////////////////////////////////////\n// Grouping\n// \\let\\bgroup={ \\let\\egroup=}\n\ndefineMacro(\"\\\\bgroup\", \"{\");\ndefineMacro(\"\\\\egroup\", \"}\"); // Symbols from latex.ltx:\n// \\def\\lq{`}\n// \\def\\rq{'}\n// \\def \\aa {\\r a}\n// \\def \\AA {\\r A}\n\ndefineMacro(\"\\\\lq\", \"`\");\ndefineMacro(\"\\\\rq\", \"'\");\ndefineMacro(\"\\\\aa\", \"\\\\r a\");\ndefineMacro(\"\\\\AA\", \"\\\\r A\"); // Copyright (C) and registered (R) symbols. Use raw symbol in MathML.\n// \\DeclareTextCommandDefault{\\textcopyright}{\\textcircled{c}}\n// \\DeclareTextCommandDefault{\\textregistered}{\\textcircled{%\n//      \\check@mathfonts\\fontsize\\sf@size\\z@\\math@fontsfalse\\selectfont R}}\n// \\DeclareRobustCommand{\\copyright}{%\n//    \\ifmmode{\\nfss@text{\\textcopyright}}\\else\\textcopyright\\fi}\n\ndefineMacro(\"\\\\textcopyright\", \"\\\\html@mathml{\\\\textcircled{c}}{\\\\char`©}\");\ndefineMacro(\"\\\\copyright\", \"\\\\TextOrMath{\\\\textcopyright}{\\\\text{\\\\textcopyright}}\");\ndefineMacro(\"\\\\textregistered\", \"\\\\html@mathml{\\\\textcircled{\\\\scriptsize R}}{\\\\char`®}\"); // Characters omitted from Unicode range 1D400–1D7FF\n\ndefineMacro(\"\\u212C\", \"\\\\mathscr{B}\"); // script\n\ndefineMacro(\"\\u2130\", \"\\\\mathscr{E}\");\ndefineMacro(\"\\u2131\", \"\\\\mathscr{F}\");\ndefineMacro(\"\\u210B\", \"\\\\mathscr{H}\");\ndefineMacro(\"\\u2110\", \"\\\\mathscr{I}\");\ndefineMacro(\"\\u2112\", \"\\\\mathscr{L}\");\ndefineMacro(\"\\u2133\", \"\\\\mathscr{M}\");\ndefineMacro(\"\\u211B\", \"\\\\mathscr{R}\");\ndefineMacro(\"\\u212D\", \"\\\\mathfrak{C}\"); // Fraktur\n\ndefineMacro(\"\\u210C\", \"\\\\mathfrak{H}\");\ndefineMacro(\"\\u2128\", \"\\\\mathfrak{Z}\"); // Define \\Bbbk with a macro that works in both HTML and MathML.\n\ndefineMacro(\"\\\\Bbbk\", \"\\\\Bbb{k}\"); // Unicode middle dot\n// The KaTeX fonts do not contain U+00B7. Instead, \\cdotp displays\n// the dot at U+22C5 and gives it punct spacing.\n\ndefineMacro(\"\\xB7\", \"\\\\cdotp\"); // \\llap and \\rlap render their contents in text mode\n\ndefineMacro(\"\\\\llap\", \"\\\\mathllap{\\\\textrm{#1}}\");\ndefineMacro(\"\\\\rlap\", \"\\\\mathrlap{\\\\textrm{#1}}\");\ndefineMacro(\"\\\\clap\", \"\\\\mathclap{\\\\textrm{#1}}\"); // \\not is defined by base/fontmath.ltx via\n// \\DeclareMathSymbol{\\not}{\\mathrel}{symbols}{\"36}\n// It's thus treated like a \\mathrel, but defined by a symbol that has zero\n// width but extends to the right.  We use \\rlap to get that spacing.\n// For MathML we write U+0338 here. buildMathML.js will then do the overlay.\n\ndefineMacro(\"\\\\not\", '\\\\html@mathml{\\\\mathrel{\\\\mathrlap\\\\@not}}{\\\\char\"338}'); // Negated symbols from base/fontmath.ltx:\n// \\def\\neq{\\not=} \\let\\ne=\\neq\n// \\DeclareRobustCommand\n//   \\notin{\\mathrel{\\m@th\\mathpalette\\c@ncel\\in}}\n// \\def\\c@ncel#1#2{\\m@th\\ooalign{$\\hfil#1\\mkern1mu/\\hfil$\\crcr$#1#2$}}\n\ndefineMacro(\"\\\\neq\", \"\\\\html@mathml{\\\\mathrel{\\\\not=}}{\\\\mathrel{\\\\char`≠}}\");\ndefineMacro(\"\\\\ne\", \"\\\\neq\");\ndefineMacro(\"\\u2260\", \"\\\\neq\");\ndefineMacro(\"\\\\notin\", \"\\\\html@mathml{\\\\mathrel{{\\\\in}\\\\mathllap{/\\\\mskip1mu}}}\" + \"{\\\\mathrel{\\\\char`∉}}\");\ndefineMacro(\"\\u2209\", \"\\\\notin\"); // Unicode stacked relations\n\ndefineMacro(\"\\u2258\", \"\\\\html@mathml{\" + \"\\\\mathrel{=\\\\kern{-1em}\\\\raisebox{0.4em}{$\\\\scriptsize\\\\frown$}}\" + \"}{\\\\mathrel{\\\\char`\\u2258}}\");\ndefineMacro(\"\\u2259\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny\\\\wedge}{=}}{\\\\mathrel{\\\\char`\\u2258}}\");\ndefineMacro(\"\\u225A\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny\\\\vee}{=}}{\\\\mathrel{\\\\char`\\u225A}}\");\ndefineMacro(\"\\u225B\", \"\\\\html@mathml{\\\\stackrel{\\\\scriptsize\\\\star}{=}}\" + \"{\\\\mathrel{\\\\char`\\u225B}}\");\ndefineMacro(\"\\u225D\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny\\\\mathrm{def}}{=}}\" + \"{\\\\mathrel{\\\\char`\\u225D}}\");\ndefineMacro(\"\\u225E\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny\\\\mathrm{m}}{=}}\" + \"{\\\\mathrel{\\\\char`\\u225E}}\");\ndefineMacro(\"\\u225F\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny?}{=}}{\\\\mathrel{\\\\char`\\u225F}}\"); // Misc Unicode\n\ndefineMacro(\"\\u27C2\", \"\\\\perp\");\ndefineMacro(\"\\u203C\", \"\\\\mathclose{!\\\\mkern-0.8mu!}\");\ndefineMacro(\"\\u220C\", \"\\\\notni\");\ndefineMacro(\"\\u231C\", \"\\\\ulcorner\");\ndefineMacro(\"\\u231D\", \"\\\\urcorner\");\ndefineMacro(\"\\u231E\", \"\\\\llcorner\");\ndefineMacro(\"\\u231F\", \"\\\\lrcorner\");\ndefineMacro(\"\\xA9\", \"\\\\copyright\");\ndefineMacro(\"\\xAE\", \"\\\\textregistered\");\ndefineMacro(\"\\uFE0F\", \"\\\\textregistered\"); //////////////////////////////////////////////////////////////////////\n// LaTeX_2ε\n// \\vdots{\\vbox{\\baselineskip4\\p@  \\lineskiplimit\\z@\n// \\kern6\\p@\\hbox{.}\\hbox{.}\\hbox{.}}}\n// We'll call \\varvdots, which gets a glyph from symbols.js.\n// The zero-width rule gets us an equivalent to the vertical 6pt kern.\n\ndefineMacro(\"\\\\vdots\", \"\\\\mathord{\\\\varvdots\\\\rule{0pt}{15pt}}\");\ndefineMacro(\"\\u22EE\", \"\\\\vdots\"); //////////////////////////////////////////////////////////////////////\n// amsmath.sty\n// http://mirrors.concertpass.com/tex-archive/macros/latex/required/amsmath/amsmath.pdf\n// Italic Greek capital letters.  AMS defines these with \\DeclareMathSymbol,\n// but they are equivalent to \\mathit{\\Letter}.\n\ndefineMacro(\"\\\\varGamma\", \"\\\\mathit{\\\\Gamma}\");\ndefineMacro(\"\\\\varDelta\", \"\\\\mathit{\\\\Delta}\");\ndefineMacro(\"\\\\varTheta\", \"\\\\mathit{\\\\Theta}\");\ndefineMacro(\"\\\\varLambda\", \"\\\\mathit{\\\\Lambda}\");\ndefineMacro(\"\\\\varXi\", \"\\\\mathit{\\\\Xi}\");\ndefineMacro(\"\\\\varPi\", \"\\\\mathit{\\\\Pi}\");\ndefineMacro(\"\\\\varSigma\", \"\\\\mathit{\\\\Sigma}\");\ndefineMacro(\"\\\\varUpsilon\", \"\\\\mathit{\\\\Upsilon}\");\ndefineMacro(\"\\\\varPhi\", \"\\\\mathit{\\\\Phi}\");\ndefineMacro(\"\\\\varPsi\", \"\\\\mathit{\\\\Psi}\");\ndefineMacro(\"\\\\varOmega\", \"\\\\mathit{\\\\Omega}\"); //\\newcommand{\\substack}[1]{\\subarray{c}#1\\endsubarray}\n\ndefineMacro(\"\\\\substack\", \"\\\\begin{subarray}{c}#1\\\\end{subarray}\"); // \\renewcommand{\\colon}{\\nobreak\\mskip2mu\\mathpunct{}\\nonscript\n// \\mkern-\\thinmuskip{:}\\mskip6muplus1mu\\relax}\n\ndefineMacro(\"\\\\colon\", \"\\\\nobreak\\\\mskip2mu\\\\mathpunct{}\" + \"\\\\mathchoice{\\\\mkern-3mu}{\\\\mkern-3mu}{}{}{:}\\\\mskip6mu\"); // \\newcommand{\\boxed}[1]{\\fbox{\\m@th$\\displaystyle#1$}}\n\ndefineMacro(\"\\\\boxed\", \"\\\\fbox{$\\\\displaystyle{#1}$}\"); // \\def\\iff{\\DOTSB\\;\\Longleftrightarrow\\;}\n// \\def\\implies{\\DOTSB\\;\\Longrightarrow\\;}\n// \\def\\impliedby{\\DOTSB\\;\\Longleftarrow\\;}\n\ndefineMacro(\"\\\\iff\", \"\\\\DOTSB\\\\;\\\\Longleftrightarrow\\\\;\");\ndefineMacro(\"\\\\implies\", \"\\\\DOTSB\\\\;\\\\Longrightarrow\\\\;\");\ndefineMacro(\"\\\\impliedby\", \"\\\\DOTSB\\\\;\\\\Longleftarrow\\\\;\"); // AMSMath's automatic \\dots, based on \\mdots@@ macro.\n\nvar dotsByToken = {\n  ',': '\\\\dotsc',\n  '\\\\not': '\\\\dotsb',\n  // \\keybin@ checks for the following:\n  '+': '\\\\dotsb',\n  '=': '\\\\dotsb',\n  '<': '\\\\dotsb',\n  '>': '\\\\dotsb',\n  '-': '\\\\dotsb',\n  '*': '\\\\dotsb',\n  ':': '\\\\dotsb',\n  // Symbols whose definition starts with \\DOTSB:\n  '\\\\DOTSB': '\\\\dotsb',\n  '\\\\coprod': '\\\\dotsb',\n  '\\\\bigvee': '\\\\dotsb',\n  '\\\\bigwedge': '\\\\dotsb',\n  '\\\\biguplus': '\\\\dotsb',\n  '\\\\bigcap': '\\\\dotsb',\n  '\\\\bigcup': '\\\\dotsb',\n  '\\\\prod': '\\\\dotsb',\n  '\\\\sum': '\\\\dotsb',\n  '\\\\bigotimes': '\\\\dotsb',\n  '\\\\bigoplus': '\\\\dotsb',\n  '\\\\bigodot': '\\\\dotsb',\n  '\\\\bigsqcup': '\\\\dotsb',\n  '\\\\And': '\\\\dotsb',\n  '\\\\longrightarrow': '\\\\dotsb',\n  '\\\\Longrightarrow': '\\\\dotsb',\n  '\\\\longleftarrow': '\\\\dotsb',\n  '\\\\Longleftarrow': '\\\\dotsb',\n  '\\\\longleftrightarrow': '\\\\dotsb',\n  '\\\\Longleftrightarrow': '\\\\dotsb',\n  '\\\\mapsto': '\\\\dotsb',\n  '\\\\longmapsto': '\\\\dotsb',\n  '\\\\hookrightarrow': '\\\\dotsb',\n  '\\\\doteq': '\\\\dotsb',\n  // Symbols whose definition starts with \\mathbin:\n  '\\\\mathbin': '\\\\dotsb',\n  // Symbols whose definition starts with \\mathrel:\n  '\\\\mathrel': '\\\\dotsb',\n  '\\\\relbar': '\\\\dotsb',\n  '\\\\Relbar': '\\\\dotsb',\n  '\\\\xrightarrow': '\\\\dotsb',\n  '\\\\xleftarrow': '\\\\dotsb',\n  // Symbols whose definition starts with \\DOTSI:\n  '\\\\DOTSI': '\\\\dotsi',\n  '\\\\int': '\\\\dotsi',\n  '\\\\oint': '\\\\dotsi',\n  '\\\\iint': '\\\\dotsi',\n  '\\\\iiint': '\\\\dotsi',\n  '\\\\iiiint': '\\\\dotsi',\n  '\\\\idotsint': '\\\\dotsi',\n  // Symbols whose definition starts with \\DOTSX:\n  '\\\\DOTSX': '\\\\dotsx'\n};\ndefineMacro(\"\\\\dots\", function (context) {\n  // TODO: If used in text mode, should expand to \\textellipsis.\n  // However, in KaTeX, \\textellipsis and \\ldots behave the same\n  // (in text mode), and it's unlikely we'd see any of the math commands\n  // that affect the behavior of \\dots when in text mode.  So fine for now\n  // (until we support \\ifmmode ... \\else ... \\fi).\n  var thedots = '\\\\dotso';\n  var next = context.expandAfterFuture().text;\n\n  if (next in dotsByToken) {\n    thedots = dotsByToken[next];\n  } else if (next.substr(0, 4) === '\\\\not') {\n    thedots = '\\\\dotsb';\n  } else if (next in src_symbols.math) {\n    if (utils.contains(['bin', 'rel'], src_symbols.math[next].group)) {\n      thedots = '\\\\dotsb';\n    }\n  }\n\n  return thedots;\n});\nvar spaceAfterDots = {\n  // \\rightdelim@ checks for the following:\n  ')': true,\n  ']': true,\n  '\\\\rbrack': true,\n  '\\\\}': true,\n  '\\\\rbrace': true,\n  '\\\\rangle': true,\n  '\\\\rceil': true,\n  '\\\\rfloor': true,\n  '\\\\rgroup': true,\n  '\\\\rmoustache': true,\n  '\\\\right': true,\n  '\\\\bigr': true,\n  '\\\\biggr': true,\n  '\\\\Bigr': true,\n  '\\\\Biggr': true,\n  // \\extra@ also tests for the following:\n  '$': true,\n  // \\extrap@ checks for the following:\n  ';': true,\n  '.': true,\n  ',': true\n};\ndefineMacro(\"\\\\dotso\", function (context) {\n  var next = context.future().text;\n\n  if (next in spaceAfterDots) {\n    return \"\\\\ldots\\\\,\";\n  } else {\n    return \"\\\\ldots\";\n  }\n});\ndefineMacro(\"\\\\dotsc\", function (context) {\n  var next = context.future().text; // \\dotsc uses \\extra@ but not \\extrap@, instead specially checking for\n  // ';' and '.', but doesn't check for ','.\n\n  if (next in spaceAfterDots && next !== ',') {\n    return \"\\\\ldots\\\\,\";\n  } else {\n    return \"\\\\ldots\";\n  }\n});\ndefineMacro(\"\\\\cdots\", function (context) {\n  var next = context.future().text;\n\n  if (next in spaceAfterDots) {\n    return \"\\\\@cdots\\\\,\";\n  } else {\n    return \"\\\\@cdots\";\n  }\n});\ndefineMacro(\"\\\\dotsb\", \"\\\\cdots\");\ndefineMacro(\"\\\\dotsm\", \"\\\\cdots\");\ndefineMacro(\"\\\\dotsi\", \"\\\\!\\\\cdots\"); // amsmath doesn't actually define \\dotsx, but \\dots followed by a macro\n// starting with \\DOTSX implies \\dotso, and then \\extra@ detects this case\n// and forces the added `\\,`.\n\ndefineMacro(\"\\\\dotsx\", \"\\\\ldots\\\\,\"); // \\let\\DOTSI\\relax\n// \\let\\DOTSB\\relax\n// \\let\\DOTSX\\relax\n\ndefineMacro(\"\\\\DOTSI\", \"\\\\relax\");\ndefineMacro(\"\\\\DOTSB\", \"\\\\relax\");\ndefineMacro(\"\\\\DOTSX\", \"\\\\relax\"); // Spacing, based on amsmath.sty's override of LaTeX defaults\n// \\DeclareRobustCommand{\\tmspace}[3]{%\n//   \\ifmmode\\mskip#1#2\\else\\kern#1#3\\fi\\relax}\n\ndefineMacro(\"\\\\tmspace\", \"\\\\TextOrMath{\\\\kern#1#3}{\\\\mskip#1#2}\\\\relax\"); // \\renewcommand{\\,}{\\tmspace+\\thinmuskip{.1667em}}\n// TODO: math mode should use \\thinmuskip\n\ndefineMacro(\"\\\\,\", \"\\\\tmspace+{3mu}{.1667em}\"); // \\let\\thinspace\\,\n\ndefineMacro(\"\\\\thinspace\", \"\\\\,\"); // \\def\\>{\\mskip\\medmuskip}\n// \\renewcommand{\\:}{\\tmspace+\\medmuskip{.2222em}}\n// TODO: \\> and math mode of \\: should use \\medmuskip = 4mu plus 2mu minus 4mu\n\ndefineMacro(\"\\\\>\", \"\\\\mskip{4mu}\");\ndefineMacro(\"\\\\:\", \"\\\\tmspace+{4mu}{.2222em}\"); // \\let\\medspace\\:\n\ndefineMacro(\"\\\\medspace\", \"\\\\:\"); // \\renewcommand{\\;}{\\tmspace+\\thickmuskip{.2777em}}\n// TODO: math mode should use \\thickmuskip = 5mu plus 5mu\n\ndefineMacro(\"\\\\;\", \"\\\\tmspace+{5mu}{.2777em}\"); // \\let\\thickspace\\;\n\ndefineMacro(\"\\\\thickspace\", \"\\\\;\"); // \\renewcommand{\\!}{\\tmspace-\\thinmuskip{.1667em}}\n// TODO: math mode should use \\thinmuskip\n\ndefineMacro(\"\\\\!\", \"\\\\tmspace-{3mu}{.1667em}\"); // \\let\\negthinspace\\!\n\ndefineMacro(\"\\\\negthinspace\", \"\\\\!\"); // \\newcommand{\\negmedspace}{\\tmspace-\\medmuskip{.2222em}}\n// TODO: math mode should use \\medmuskip\n\ndefineMacro(\"\\\\negmedspace\", \"\\\\tmspace-{4mu}{.2222em}\"); // \\newcommand{\\negthickspace}{\\tmspace-\\thickmuskip{.2777em}}\n// TODO: math mode should use \\thickmuskip\n\ndefineMacro(\"\\\\negthickspace\", \"\\\\tmspace-{5mu}{.277em}\"); // \\def\\enspace{\\kern.5em }\n\ndefineMacro(\"\\\\enspace\", \"\\\\kern.5em \"); // \\def\\enskip{\\hskip.5em\\relax}\n\ndefineMacro(\"\\\\enskip\", \"\\\\hskip.5em\\\\relax\"); // \\def\\quad{\\hskip1em\\relax}\n\ndefineMacro(\"\\\\quad\", \"\\\\hskip1em\\\\relax\"); // \\def\\qquad{\\hskip2em\\relax}\n\ndefineMacro(\"\\\\qquad\", \"\\\\hskip2em\\\\relax\"); // \\tag@in@display form of \\tag\n\ndefineMacro(\"\\\\tag\", \"\\\\@ifstar\\\\tag@literal\\\\tag@paren\");\ndefineMacro(\"\\\\tag@paren\", \"\\\\tag@literal{({#1})}\");\ndefineMacro(\"\\\\tag@literal\", function (context) {\n  if (context.macros.get(\"\\\\df@tag\")) {\n    throw new src_ParseError(\"Multiple \\\\tag\");\n  }\n\n  return \"\\\\gdef\\\\df@tag{\\\\text{#1}}\";\n}); // \\renewcommand{\\bmod}{\\nonscript\\mskip-\\medmuskip\\mkern5mu\\mathbin\n//   {\\operator@font mod}\\penalty900\n//   \\mkern5mu\\nonscript\\mskip-\\medmuskip}\n// \\newcommand{\\pod}[1]{\\allowbreak\n//   \\if@display\\mkern18mu\\else\\mkern8mu\\fi(#1)}\n// \\renewcommand{\\pmod}[1]{\\pod{{\\operator@font mod}\\mkern6mu#1}}\n// \\newcommand{\\mod}[1]{\\allowbreak\\if@display\\mkern18mu\n//   \\else\\mkern12mu\\fi{\\operator@font mod}\\,\\,#1}\n// TODO: math mode should use \\medmuskip = 4mu plus 2mu minus 4mu\n\ndefineMacro(\"\\\\bmod\", \"\\\\mathchoice{\\\\mskip1mu}{\\\\mskip1mu}{\\\\mskip5mu}{\\\\mskip5mu}\" + \"\\\\mathbin{\\\\rm mod}\" + \"\\\\mathchoice{\\\\mskip1mu}{\\\\mskip1mu}{\\\\mskip5mu}{\\\\mskip5mu}\");\ndefineMacro(\"\\\\pod\", \"\\\\allowbreak\" + \"\\\\mathchoice{\\\\mkern18mu}{\\\\mkern8mu}{\\\\mkern8mu}{\\\\mkern8mu}(#1)\");\ndefineMacro(\"\\\\pmod\", \"\\\\pod{{\\\\rm mod}\\\\mkern6mu#1}\");\ndefineMacro(\"\\\\mod\", \"\\\\allowbreak\" + \"\\\\mathchoice{\\\\mkern18mu}{\\\\mkern12mu}{\\\\mkern12mu}{\\\\mkern12mu}\" + \"{\\\\rm mod}\\\\,\\\\,#1\"); // \\pmb    --   A simulation of bold.\n// The version in ambsy.sty works by typesetting three copies of the argument\n// with small offsets. We use two copies. We omit the vertical offset because\n// of rendering problems that makeVList encounters in Safari.\n\ndefineMacro(\"\\\\pmb\", \"\\\\html@mathml{\" + \"\\\\@binrel{#1}{\\\\mathrlap{#1}\\\\kern0.5px#1}}\" + \"{\\\\mathbf{#1}}\"); //////////////////////////////////////////////////////////////////////\n// LaTeX source2e\n// \\\\ defaults to \\newline, but changes to \\cr within array environment\n\ndefineMacro(\"\\\\\\\\\", \"\\\\newline\"); // \\def\\TeX{T\\kern-.1667em\\lower.5ex\\hbox{E}\\kern-.125emX\\@}\n// TODO: Doesn't normally work in math mode because \\@ fails.  KaTeX doesn't\n// support \\@ yet, so that's omitted, and we add \\text so that the result\n// doesn't look funny in math mode.\n\ndefineMacro(\"\\\\TeX\", \"\\\\textrm{\\\\html@mathml{\" + \"T\\\\kern-.1667em\\\\raisebox{-.5ex}{E}\\\\kern-.125emX\" + \"}{TeX}}\"); // \\DeclareRobustCommand{\\LaTeX}{L\\kern-.36em%\n//         {\\sbox\\z@ T%\n//          \\vbox to\\ht\\z@{\\hbox{\\check@mathfonts\n//                               \\fontsize\\sf@size\\z@\n//                               \\math@fontsfalse\\selectfont\n//                               A}%\n//                         \\vss}%\n//         }%\n//         \\kern-.15em%\n//         \\TeX}\n// This code aligns the top of the A with the T (from the perspective of TeX's\n// boxes, though visually the A appears to extend above slightly).\n// We compute the corresponding \\raisebox when A is rendered in \\normalsize\n// \\scriptstyle, which has a scale factor of 0.7 (see Options.js).\n\nvar latexRaiseA = fontMetricsData['Main-Regular'][\"T\".charCodeAt(0)][1] - 0.7 * fontMetricsData['Main-Regular'][\"A\".charCodeAt(0)][1] + \"em\";\ndefineMacro(\"\\\\LaTeX\", \"\\\\textrm{\\\\html@mathml{\" + (\"L\\\\kern-.36em\\\\raisebox{\" + latexRaiseA + \"}{\\\\scriptstyle A}\") + \"\\\\kern-.15em\\\\TeX}{LaTeX}}\"); // New KaTeX logo based on tweaking LaTeX logo\n\ndefineMacro(\"\\\\KaTeX\", \"\\\\textrm{\\\\html@mathml{\" + (\"K\\\\kern-.17em\\\\raisebox{\" + latexRaiseA + \"}{\\\\scriptstyle A}\") + \"\\\\kern-.15em\\\\TeX}{KaTeX}}\"); // \\DeclareRobustCommand\\hspace{\\@ifstar\\@hspacer\\@hspace}\n// \\def\\@hspace#1{\\hskip  #1\\relax}\n// \\def\\@hspacer#1{\\vrule \\@width\\z@\\nobreak\n//                 \\hskip #1\\hskip \\z@skip}\n\ndefineMacro(\"\\\\hspace\", \"\\\\@ifstar\\\\@hspacer\\\\@hspace\");\ndefineMacro(\"\\\\@hspace\", \"\\\\hskip #1\\\\relax\");\ndefineMacro(\"\\\\@hspacer\", \"\\\\rule{0pt}{0pt}\\\\hskip #1\\\\relax\"); //////////////////////////////////////////////////////////////////////\n// mathtools.sty\n//\\providecommand\\ordinarycolon{:}\n\ndefineMacro(\"\\\\ordinarycolon\", \":\"); //\\def\\vcentcolon{\\mathrel{\\mathop\\ordinarycolon}}\n//TODO(edemaine): Not yet centered. Fix via \\raisebox or #726\n\ndefineMacro(\"\\\\vcentcolon\", \"\\\\mathrel{\\\\mathop\\\\ordinarycolon}\"); // \\providecommand*\\dblcolon{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}\n\ndefineMacro(\"\\\\dblcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-.9mu}\\\\vcentcolon}}\" + \"{\\\\mathop{\\\\char\\\"2237}}\"); // \\providecommand*\\coloneqq{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}\n\ndefineMacro(\"\\\\coloneqq\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}}\" + \"{\\\\mathop{\\\\char\\\"2254}}\"); // ≔\n// \\providecommand*\\Coloneqq{\\dblcolon\\mathrel{\\mkern-1.2mu}=}\n\ndefineMacro(\"\\\\Coloneqq\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\dblcolon\\\\mathrel{\\\\mkern-1.2mu}=}}\" + \"{\\\\mathop{\\\\char\\\"2237\\\\char\\\"3d}}\"); // \\providecommand*\\coloneq{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}\n\ndefineMacro(\"\\\\coloneq\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\mathrel{-}}}\" + \"{\\\\mathop{\\\\char\\\"3a\\\\char\\\"2212}}\"); // \\providecommand*\\Coloneq{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}\n\ndefineMacro(\"\\\\Coloneq\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\dblcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\mathrel{-}}}\" + \"{\\\\mathop{\\\\char\\\"2237\\\\char\\\"2212}}\"); // \\providecommand*\\eqqcolon{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}\n\ndefineMacro(\"\\\\eqqcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{=\\\\mathrel{\\\\mkern-1.2mu}\\\\vcentcolon}}\" + \"{\\\\mathop{\\\\char\\\"2255}}\"); // ≕\n// \\providecommand*\\Eqqcolon{=\\mathrel{\\mkern-1.2mu}\\dblcolon}\n\ndefineMacro(\"\\\\Eqqcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{=\\\\mathrel{\\\\mkern-1.2mu}\\\\dblcolon}}\" + \"{\\\\mathop{\\\\char\\\"3d\\\\char\\\"2237}}\"); // \\providecommand*\\eqcolon{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}\n\ndefineMacro(\"\\\\eqcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\mathrel{-}\\\\mathrel{\\\\mkern-1.2mu}\\\\vcentcolon}}\" + \"{\\\\mathop{\\\\char\\\"2239}}\"); // \\providecommand*\\Eqcolon{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}\n\ndefineMacro(\"\\\\Eqcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\mathrel{-}\\\\mathrel{\\\\mkern-1.2mu}\\\\dblcolon}}\" + \"{\\\\mathop{\\\\char\\\"2212\\\\char\\\"2237}}\"); // \\providecommand*\\colonapprox{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}\n\ndefineMacro(\"\\\\colonapprox\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\approx}}\" + \"{\\\\mathop{\\\\char\\\"3a\\\\char\\\"2248}}\"); // \\providecommand*\\Colonapprox{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}\n\ndefineMacro(\"\\\\Colonapprox\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\dblcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\approx}}\" + \"{\\\\mathop{\\\\char\\\"2237\\\\char\\\"2248}}\"); // \\providecommand*\\colonsim{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}\n\ndefineMacro(\"\\\\colonsim\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\sim}}\" + \"{\\\\mathop{\\\\char\\\"3a\\\\char\\\"223c}}\"); // \\providecommand*\\Colonsim{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}\n\ndefineMacro(\"\\\\Colonsim\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\dblcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\sim}}\" + \"{\\\\mathop{\\\\char\\\"2237\\\\char\\\"223c}}\"); // Some Unicode characters are implemented with macros to mathtools functions.\n\ndefineMacro(\"\\u2237\", \"\\\\dblcolon\"); // ::\n\ndefineMacro(\"\\u2239\", \"\\\\eqcolon\"); // -:\n\ndefineMacro(\"\\u2254\", \"\\\\coloneqq\"); // :=\n\ndefineMacro(\"\\u2255\", \"\\\\eqqcolon\"); // =:\n\ndefineMacro(\"\\u2A74\", \"\\\\Coloneqq\"); // ::=\n//////////////////////////////////////////////////////////////////////\n// colonequals.sty\n// Alternate names for mathtools's macros:\n\ndefineMacro(\"\\\\ratio\", \"\\\\vcentcolon\");\ndefineMacro(\"\\\\coloncolon\", \"\\\\dblcolon\");\ndefineMacro(\"\\\\colonequals\", \"\\\\coloneqq\");\ndefineMacro(\"\\\\coloncolonequals\", \"\\\\Coloneqq\");\ndefineMacro(\"\\\\equalscolon\", \"\\\\eqqcolon\");\ndefineMacro(\"\\\\equalscoloncolon\", \"\\\\Eqqcolon\");\ndefineMacro(\"\\\\colonminus\", \"\\\\coloneq\");\ndefineMacro(\"\\\\coloncolonminus\", \"\\\\Coloneq\");\ndefineMacro(\"\\\\minuscolon\", \"\\\\eqcolon\");\ndefineMacro(\"\\\\minuscoloncolon\", \"\\\\Eqcolon\"); // \\colonapprox name is same in mathtools and colonequals.\n\ndefineMacro(\"\\\\coloncolonapprox\", \"\\\\Colonapprox\"); // \\colonsim name is same in mathtools and colonequals.\n\ndefineMacro(\"\\\\coloncolonsim\", \"\\\\Colonsim\"); // Additional macros, implemented by analogy with mathtools definitions:\n\ndefineMacro(\"\\\\simcolon\", \"\\\\mathrel{\\\\sim\\\\mathrel{\\\\mkern-1.2mu}\\\\vcentcolon}\");\ndefineMacro(\"\\\\simcoloncolon\", \"\\\\mathrel{\\\\sim\\\\mathrel{\\\\mkern-1.2mu}\\\\dblcolon}\");\ndefineMacro(\"\\\\approxcolon\", \"\\\\mathrel{\\\\approx\\\\mathrel{\\\\mkern-1.2mu}\\\\vcentcolon}\");\ndefineMacro(\"\\\\approxcoloncolon\", \"\\\\mathrel{\\\\approx\\\\mathrel{\\\\mkern-1.2mu}\\\\dblcolon}\"); // Present in newtxmath, pxfonts and txfonts\n\ndefineMacro(\"\\\\notni\", \"\\\\html@mathml{\\\\not\\\\ni}{\\\\mathrel{\\\\char`\\u220C}}\");\ndefineMacro(\"\\\\limsup\", \"\\\\DOTSB\\\\operatorname*{lim\\\\,sup}\");\ndefineMacro(\"\\\\liminf\", \"\\\\DOTSB\\\\operatorname*{lim\\\\,inf}\"); //////////////////////////////////////////////////////////////////////\n// MathML alternates for KaTeX glyphs in the Unicode private area\n\ndefineMacro(\"\\\\gvertneqq\", \"\\\\html@mathml{\\\\@gvertneqq}{\\u2269}\");\ndefineMacro(\"\\\\lvertneqq\", \"\\\\html@mathml{\\\\@lvertneqq}{\\u2268}\");\ndefineMacro(\"\\\\ngeqq\", \"\\\\html@mathml{\\\\@ngeqq}{\\u2271}\");\ndefineMacro(\"\\\\ngeqslant\", \"\\\\html@mathml{\\\\@ngeqslant}{\\u2271}\");\ndefineMacro(\"\\\\nleqq\", \"\\\\html@mathml{\\\\@nleqq}{\\u2270}\");\ndefineMacro(\"\\\\nleqslant\", \"\\\\html@mathml{\\\\@nleqslant}{\\u2270}\");\ndefineMacro(\"\\\\nshortmid\", \"\\\\html@mathml{\\\\@nshortmid}{∤}\");\ndefineMacro(\"\\\\nshortparallel\", \"\\\\html@mathml{\\\\@nshortparallel}{∦}\");\ndefineMacro(\"\\\\nsubseteqq\", \"\\\\html@mathml{\\\\@nsubseteqq}{\\u2288}\");\ndefineMacro(\"\\\\nsupseteqq\", \"\\\\html@mathml{\\\\@nsupseteqq}{\\u2289}\");\ndefineMacro(\"\\\\varsubsetneq\", \"\\\\html@mathml{\\\\@varsubsetneq}{⊊}\");\ndefineMacro(\"\\\\varsubsetneqq\", \"\\\\html@mathml{\\\\@varsubsetneqq}{⫋}\");\ndefineMacro(\"\\\\varsupsetneq\", \"\\\\html@mathml{\\\\@varsupsetneq}{⊋}\");\ndefineMacro(\"\\\\varsupsetneqq\", \"\\\\html@mathml{\\\\@varsupsetneqq}{⫌}\"); //////////////////////////////////////////////////////////////////////\n// stmaryrd and semantic\n// The stmaryrd and semantic packages render the next four items by calling a\n// glyph. Those glyphs do not exist in the KaTeX fonts. Hence the macros.\n\ndefineMacro(\"\\\\llbracket\", \"\\\\html@mathml{\" + \"\\\\mathopen{[\\\\mkern-3.2mu[}}\" + \"{\\\\mathopen{\\\\char`\\u27E6}}\");\ndefineMacro(\"\\\\rrbracket\", \"\\\\html@mathml{\" + \"\\\\mathclose{]\\\\mkern-3.2mu]}}\" + \"{\\\\mathclose{\\\\char`\\u27E7}}\");\ndefineMacro(\"\\u27E6\", \"\\\\llbracket\"); // blackboard bold [\n\ndefineMacro(\"\\u27E7\", \"\\\\rrbracket\"); // blackboard bold ]\n\ndefineMacro(\"\\\\lBrace\", \"\\\\html@mathml{\" + \"\\\\mathopen{\\\\{\\\\mkern-3.2mu[}}\" + \"{\\\\mathopen{\\\\char`\\u2983}}\");\ndefineMacro(\"\\\\rBrace\", \"\\\\html@mathml{\" + \"\\\\mathclose{]\\\\mkern-3.2mu\\\\}}}\" + \"{\\\\mathclose{\\\\char`\\u2984}}\");\ndefineMacro(\"\\u2983\", \"\\\\lBrace\"); // blackboard bold {\n\ndefineMacro(\"\\u2984\", \"\\\\rBrace\"); // blackboard bold }\n// TODO: Create variable sized versions of the last two items. I believe that\n// will require new font glyphs.\n//////////////////////////////////////////////////////////////////////\n// texvc.sty\n// The texvc package contains macros available in mediawiki pages.\n// We omit the functions deprecated at\n// https://en.wikipedia.org/wiki/Help:Displaying_a_formula#Deprecated_syntax\n// We also omit texvc's \\O, which conflicts with \\text{\\O}\n\ndefineMacro(\"\\\\darr\", \"\\\\downarrow\");\ndefineMacro(\"\\\\dArr\", \"\\\\Downarrow\");\ndefineMacro(\"\\\\Darr\", \"\\\\Downarrow\");\ndefineMacro(\"\\\\lang\", \"\\\\langle\");\ndefineMacro(\"\\\\rang\", \"\\\\rangle\");\ndefineMacro(\"\\\\uarr\", \"\\\\uparrow\");\ndefineMacro(\"\\\\uArr\", \"\\\\Uparrow\");\ndefineMacro(\"\\\\Uarr\", \"\\\\Uparrow\");\ndefineMacro(\"\\\\N\", \"\\\\mathbb{N}\");\ndefineMacro(\"\\\\R\", \"\\\\mathbb{R}\");\ndefineMacro(\"\\\\Z\", \"\\\\mathbb{Z}\");\ndefineMacro(\"\\\\alef\", \"\\\\aleph\");\ndefineMacro(\"\\\\alefsym\", \"\\\\aleph\");\ndefineMacro(\"\\\\Alpha\", \"\\\\mathrm{A}\");\ndefineMacro(\"\\\\Beta\", \"\\\\mathrm{B}\");\ndefineMacro(\"\\\\bull\", \"\\\\bullet\");\ndefineMacro(\"\\\\Chi\", \"\\\\mathrm{X}\");\ndefineMacro(\"\\\\clubs\", \"\\\\clubsuit\");\ndefineMacro(\"\\\\cnums\", \"\\\\mathbb{C}\");\ndefineMacro(\"\\\\Complex\", \"\\\\mathbb{C}\");\ndefineMacro(\"\\\\Dagger\", \"\\\\ddagger\");\ndefineMacro(\"\\\\diamonds\", \"\\\\diamondsuit\");\ndefineMacro(\"\\\\empty\", \"\\\\emptyset\");\ndefineMacro(\"\\\\Epsilon\", \"\\\\mathrm{E}\");\ndefineMacro(\"\\\\Eta\", \"\\\\mathrm{H}\");\ndefineMacro(\"\\\\exist\", \"\\\\exists\");\ndefineMacro(\"\\\\harr\", \"\\\\leftrightarrow\");\ndefineMacro(\"\\\\hArr\", \"\\\\Leftrightarrow\");\ndefineMacro(\"\\\\Harr\", \"\\\\Leftrightarrow\");\ndefineMacro(\"\\\\hearts\", \"\\\\heartsuit\");\ndefineMacro(\"\\\\image\", \"\\\\Im\");\ndefineMacro(\"\\\\infin\", \"\\\\infty\");\ndefineMacro(\"\\\\Iota\", \"\\\\mathrm{I}\");\ndefineMacro(\"\\\\isin\", \"\\\\in\");\ndefineMacro(\"\\\\Kappa\", \"\\\\mathrm{K}\");\ndefineMacro(\"\\\\larr\", \"\\\\leftarrow\");\ndefineMacro(\"\\\\lArr\", \"\\\\Leftarrow\");\ndefineMacro(\"\\\\Larr\", \"\\\\Leftarrow\");\ndefineMacro(\"\\\\lrarr\", \"\\\\leftrightarrow\");\ndefineMacro(\"\\\\lrArr\", \"\\\\Leftrightarrow\");\ndefineMacro(\"\\\\Lrarr\", \"\\\\Leftrightarrow\");\ndefineMacro(\"\\\\Mu\", \"\\\\mathrm{M}\");\ndefineMacro(\"\\\\natnums\", \"\\\\mathbb{N}\");\ndefineMacro(\"\\\\Nu\", \"\\\\mathrm{N}\");\ndefineMacro(\"\\\\Omicron\", \"\\\\mathrm{O}\");\ndefineMacro(\"\\\\plusmn\", \"\\\\pm\");\ndefineMacro(\"\\\\rarr\", \"\\\\rightarrow\");\ndefineMacro(\"\\\\rArr\", \"\\\\Rightarrow\");\ndefineMacro(\"\\\\Rarr\", \"\\\\Rightarrow\");\ndefineMacro(\"\\\\real\", \"\\\\Re\");\ndefineMacro(\"\\\\reals\", \"\\\\mathbb{R}\");\ndefineMacro(\"\\\\Reals\", \"\\\\mathbb{R}\");\ndefineMacro(\"\\\\Rho\", \"\\\\mathrm{P}\");\ndefineMacro(\"\\\\sdot\", \"\\\\cdot\");\ndefineMacro(\"\\\\sect\", \"\\\\S\");\ndefineMacro(\"\\\\spades\", \"\\\\spadesuit\");\ndefineMacro(\"\\\\sub\", \"\\\\subset\");\ndefineMacro(\"\\\\sube\", \"\\\\subseteq\");\ndefineMacro(\"\\\\supe\", \"\\\\supseteq\");\ndefineMacro(\"\\\\Tau\", \"\\\\mathrm{T}\");\ndefineMacro(\"\\\\thetasym\", \"\\\\vartheta\"); // TODO: defineMacro(\"\\\\varcoppa\", \"\\\\\\mbox{\\\\coppa}\");\n\ndefineMacro(\"\\\\weierp\", \"\\\\wp\");\ndefineMacro(\"\\\\Zeta\", \"\\\\mathrm{Z}\"); //////////////////////////////////////////////////////////////////////\n// statmath.sty\n// https://ctan.math.illinois.edu/macros/latex/contrib/statmath/statmath.pdf\n\ndefineMacro(\"\\\\argmin\", \"\\\\DOTSB\\\\operatorname*{arg\\\\,min}\");\ndefineMacro(\"\\\\argmax\", \"\\\\DOTSB\\\\operatorname*{arg\\\\,max}\");\ndefineMacro(\"\\\\plim\", \"\\\\DOTSB\\\\mathop{\\\\operatorname{plim}}\\\\limits\"); // Custom Khan Academy colors, should be moved to an optional package\n\ndefineMacro(\"\\\\blue\", \"\\\\textcolor{##6495ed}{#1}\");\ndefineMacro(\"\\\\orange\", \"\\\\textcolor{##ffa500}{#1}\");\ndefineMacro(\"\\\\pink\", \"\\\\textcolor{##ff00af}{#1}\");\ndefineMacro(\"\\\\red\", \"\\\\textcolor{##df0030}{#1}\");\ndefineMacro(\"\\\\green\", \"\\\\textcolor{##28ae7b}{#1}\");\ndefineMacro(\"\\\\gray\", \"\\\\textcolor{gray}{#1}\");\ndefineMacro(\"\\\\purple\", \"\\\\textcolor{##9d38bd}{#1}\");\ndefineMacro(\"\\\\blueA\", \"\\\\textcolor{##ccfaff}{#1}\");\ndefineMacro(\"\\\\blueB\", \"\\\\textcolor{##80f6ff}{#1}\");\ndefineMacro(\"\\\\blueC\", \"\\\\textcolor{##63d9ea}{#1}\");\ndefineMacro(\"\\\\blueD\", \"\\\\textcolor{##11accd}{#1}\");\ndefineMacro(\"\\\\blueE\", \"\\\\textcolor{##0c7f99}{#1}\");\ndefineMacro(\"\\\\tealA\", \"\\\\textcolor{##94fff5}{#1}\");\ndefineMacro(\"\\\\tealB\", \"\\\\textcolor{##26edd5}{#1}\");\ndefineMacro(\"\\\\tealC\", \"\\\\textcolor{##01d1c1}{#1}\");\ndefineMacro(\"\\\\tealD\", \"\\\\textcolor{##01a995}{#1}\");\ndefineMacro(\"\\\\tealE\", \"\\\\textcolor{##208170}{#1}\");\ndefineMacro(\"\\\\greenA\", \"\\\\textcolor{##b6ffb0}{#1}\");\ndefineMacro(\"\\\\greenB\", \"\\\\textcolor{##8af281}{#1}\");\ndefineMacro(\"\\\\greenC\", \"\\\\textcolor{##74cf70}{#1}\");\ndefineMacro(\"\\\\greenD\", \"\\\\textcolor{##1fab54}{#1}\");\ndefineMacro(\"\\\\greenE\", \"\\\\textcolor{##0d923f}{#1}\");\ndefineMacro(\"\\\\goldA\", \"\\\\textcolor{##ffd0a9}{#1}\");\ndefineMacro(\"\\\\goldB\", \"\\\\textcolor{##ffbb71}{#1}\");\ndefineMacro(\"\\\\goldC\", \"\\\\textcolor{##ff9c39}{#1}\");\ndefineMacro(\"\\\\goldD\", \"\\\\textcolor{##e07d10}{#1}\");\ndefineMacro(\"\\\\goldE\", \"\\\\textcolor{##a75a05}{#1}\");\ndefineMacro(\"\\\\redA\", \"\\\\textcolor{##fca9a9}{#1}\");\ndefineMacro(\"\\\\redB\", \"\\\\textcolor{##ff8482}{#1}\");\ndefineMacro(\"\\\\redC\", \"\\\\textcolor{##f9685d}{#1}\");\ndefineMacro(\"\\\\redD\", \"\\\\textcolor{##e84d39}{#1}\");\ndefineMacro(\"\\\\redE\", \"\\\\textcolor{##bc2612}{#1}\");\ndefineMacro(\"\\\\maroonA\", \"\\\\textcolor{##ffbde0}{#1}\");\ndefineMacro(\"\\\\maroonB\", \"\\\\textcolor{##ff92c6}{#1}\");\ndefineMacro(\"\\\\maroonC\", \"\\\\textcolor{##ed5fa6}{#1}\");\ndefineMacro(\"\\\\maroonD\", \"\\\\textcolor{##ca337c}{#1}\");\ndefineMacro(\"\\\\maroonE\", \"\\\\textcolor{##9e034e}{#1}\");\ndefineMacro(\"\\\\purpleA\", \"\\\\textcolor{##ddd7ff}{#1}\");\ndefineMacro(\"\\\\purpleB\", \"\\\\textcolor{##c6b9fc}{#1}\");\ndefineMacro(\"\\\\purpleC\", \"\\\\textcolor{##aa87ff}{#1}\");\ndefineMacro(\"\\\\purpleD\", \"\\\\textcolor{##7854ab}{#1}\");\ndefineMacro(\"\\\\purpleE\", \"\\\\textcolor{##543b78}{#1}\");\ndefineMacro(\"\\\\mintA\", \"\\\\textcolor{##f5f9e8}{#1}\");\ndefineMacro(\"\\\\mintB\", \"\\\\textcolor{##edf2df}{#1}\");\ndefineMacro(\"\\\\mintC\", \"\\\\textcolor{##e0e5cc}{#1}\");\ndefineMacro(\"\\\\grayA\", \"\\\\textcolor{##f6f7f7}{#1}\");\ndefineMacro(\"\\\\grayB\", \"\\\\textcolor{##f0f1f2}{#1}\");\ndefineMacro(\"\\\\grayC\", \"\\\\textcolor{##e3e5e6}{#1}\");\ndefineMacro(\"\\\\grayD\", \"\\\\textcolor{##d6d8da}{#1}\");\ndefineMacro(\"\\\\grayE\", \"\\\\textcolor{##babec2}{#1}\");\ndefineMacro(\"\\\\grayF\", \"\\\\textcolor{##888d93}{#1}\");\ndefineMacro(\"\\\\grayG\", \"\\\\textcolor{##626569}{#1}\");\ndefineMacro(\"\\\\grayH\", \"\\\\textcolor{##3b3e40}{#1}\");\ndefineMacro(\"\\\\grayI\", \"\\\\textcolor{##21242c}{#1}\");\ndefineMacro(\"\\\\kaBlue\", \"\\\\textcolor{##314453}{#1}\");\ndefineMacro(\"\\\\kaGreen\", \"\\\\textcolor{##71B307}{#1}\");\n// CONCATENATED MODULE: ./src/MacroExpander.js\n/**\n * This file contains the “gullet” where macros are expanded\n * until only non-macro tokens remain.\n */\n\n\n\n\n\n\n\n// List of commands that act like macros but aren't defined as a macro,\n// function, or symbol.  Used in `isDefined`.\nvar implicitCommands = {\n  \"\\\\relax\": true,\n  // MacroExpander.js\n  \"^\": true,\n  // Parser.js\n  \"_\": true,\n  // Parser.js\n  \"\\\\limits\": true,\n  // Parser.js\n  \"\\\\nolimits\": true // Parser.js\n\n};\n\nvar MacroExpander_MacroExpander =\n/*#__PURE__*/\nfunction () {\n  function MacroExpander(input, settings, mode) {\n    this.settings = void 0;\n    this.expansionCount = void 0;\n    this.lexer = void 0;\n    this.macros = void 0;\n    this.stack = void 0;\n    this.mode = void 0;\n    this.settings = settings;\n    this.expansionCount = 0;\n    this.feed(input); // Make new global namespace\n\n    this.macros = new Namespace_Namespace(macros, settings.macros);\n    this.mode = mode;\n    this.stack = []; // contains tokens in REVERSE order\n  }\n  /**\n   * Feed a new input string to the same MacroExpander\n   * (with existing macros etc.).\n   */\n\n\n  var _proto = MacroExpander.prototype;\n\n  _proto.feed = function feed(input) {\n    this.lexer = new Lexer_Lexer(input, this.settings);\n  }\n  /**\n   * Switches between \"text\" and \"math\" modes.\n   */\n  ;\n\n  _proto.switchMode = function switchMode(newMode) {\n    this.mode = newMode;\n  }\n  /**\n   * Start a new group nesting within all namespaces.\n   */\n  ;\n\n  _proto.beginGroup = function beginGroup() {\n    this.macros.beginGroup();\n  }\n  /**\n   * End current group nesting within all namespaces.\n   */\n  ;\n\n  _proto.endGroup = function endGroup() {\n    this.macros.endGroup();\n  }\n  /**\n   * Returns the topmost token on the stack, without expanding it.\n   * Similar in behavior to TeX's `\\futurelet`.\n   */\n  ;\n\n  _proto.future = function future() {\n    if (this.stack.length === 0) {\n      this.pushToken(this.lexer.lex());\n    }\n\n    return this.stack[this.stack.length - 1];\n  }\n  /**\n   * Remove and return the next unexpanded token.\n   */\n  ;\n\n  _proto.popToken = function popToken() {\n    this.future(); // ensure non-empty stack\n\n    return this.stack.pop();\n  }\n  /**\n   * Add a given token to the token stack.  In particular, this get be used\n   * to put back a token returned from one of the other methods.\n   */\n  ;\n\n  _proto.pushToken = function pushToken(token) {\n    this.stack.push(token);\n  }\n  /**\n   * Append an array of tokens to the token stack.\n   */\n  ;\n\n  _proto.pushTokens = function pushTokens(tokens) {\n    var _this$stack;\n\n    (_this$stack = this.stack).push.apply(_this$stack, tokens);\n  }\n  /**\n   * Consume all following space tokens, without expansion.\n   */\n  ;\n\n  _proto.consumeSpaces = function consumeSpaces() {\n    for (;;) {\n      var token = this.future();\n\n      if (token.text === \" \") {\n        this.stack.pop();\n      } else {\n        break;\n      }\n    }\n  }\n  /**\n   * Consume the specified number of arguments from the token stream,\n   * and return the resulting array of arguments.\n   */\n  ;\n\n  _proto.consumeArgs = function consumeArgs(numArgs) {\n    var args = []; // obtain arguments, either single token or balanced {…} group\n\n    for (var i = 0; i < numArgs; ++i) {\n      this.consumeSpaces(); // ignore spaces before each argument\n\n      var startOfArg = this.popToken();\n\n      if (startOfArg.text === \"{\") {\n        var arg = [];\n        var depth = 1;\n\n        while (depth !== 0) {\n          var tok = this.popToken();\n          arg.push(tok);\n\n          if (tok.text === \"{\") {\n            ++depth;\n          } else if (tok.text === \"}\") {\n            --depth;\n          } else if (tok.text === \"EOF\") {\n            throw new src_ParseError(\"End of input in macro argument\", startOfArg);\n          }\n        }\n\n        arg.pop(); // remove last }\n\n        arg.reverse(); // like above, to fit in with stack order\n\n        args[i] = arg;\n      } else if (startOfArg.text === \"EOF\") {\n        throw new src_ParseError(\"End of input expecting macro argument\");\n      } else {\n        args[i] = [startOfArg];\n      }\n    }\n\n    return args;\n  }\n  /**\n   * Expand the next token only once if possible.\n   *\n   * If the token is expanded, the resulting tokens will be pushed onto\n   * the stack in reverse order and will be returned as an array,\n   * also in reverse order.\n   *\n   * If not, the next token will be returned without removing it\n   * from the stack.  This case can be detected by a `Token` return value\n   * instead of an `Array` return value.\n   *\n   * In either case, the next token will be on the top of the stack,\n   * or the stack will be empty.\n   *\n   * Used to implement `expandAfterFuture` and `expandNextToken`.\n   *\n   * At the moment, macro expansion doesn't handle delimited macros,\n   * i.e. things like those defined by \\def\\foo#1\\end{…}.\n   * See the TeX book page 202ff. for details on how those should behave.\n   */\n  ;\n\n  _proto.expandOnce = function expandOnce() {\n    var topToken = this.popToken();\n    var name = topToken.text;\n\n    var expansion = this._getExpansion(name);\n\n    if (expansion == null) {\n      // mainly checking for undefined here\n      // Fully expanded\n      this.pushToken(topToken);\n      return topToken;\n    }\n\n    this.expansionCount++;\n\n    if (this.expansionCount > this.settings.maxExpand) {\n      throw new src_ParseError(\"Too many expansions: infinite loop or \" + \"need to increase maxExpand setting\");\n    }\n\n    var tokens = expansion.tokens;\n\n    if (expansion.numArgs) {\n      var args = this.consumeArgs(expansion.numArgs); // paste arguments in place of the placeholders\n\n      tokens = tokens.slice(); // make a shallow copy\n\n      for (var i = tokens.length - 1; i >= 0; --i) {\n        var tok = tokens[i];\n\n        if (tok.text === \"#\") {\n          if (i === 0) {\n            throw new src_ParseError(\"Incomplete placeholder at end of macro body\", tok);\n          }\n\n          tok = tokens[--i]; // next token on stack\n\n          if (tok.text === \"#\") {\n            // ## → #\n            tokens.splice(i + 1, 1); // drop first #\n          } else if (/^[1-9]$/.test(tok.text)) {\n            var _tokens;\n\n            // replace the placeholder with the indicated argument\n            (_tokens = tokens).splice.apply(_tokens, [i, 2].concat(args[+tok.text - 1]));\n          } else {\n            throw new src_ParseError(\"Not a valid argument number\", tok);\n          }\n        }\n      }\n    } // Concatenate expansion onto top of stack.\n\n\n    this.pushTokens(tokens);\n    return tokens;\n  }\n  /**\n   * Expand the next token only once (if possible), and return the resulting\n   * top token on the stack (without removing anything from the stack).\n   * Similar in behavior to TeX's `\\expandafter\\futurelet`.\n   * Equivalent to expandOnce() followed by future().\n   */\n  ;\n\n  _proto.expandAfterFuture = function expandAfterFuture() {\n    this.expandOnce();\n    return this.future();\n  }\n  /**\n   * Recursively expand first token, then return first non-expandable token.\n   */\n  ;\n\n  _proto.expandNextToken = function expandNextToken() {\n    for (;;) {\n      var expanded = this.expandOnce(); // expandOnce returns Token if and only if it's fully expanded.\n\n      if (expanded instanceof Token_Token) {\n        // \\relax stops the expansion, but shouldn't get returned (a\n        // null return value couldn't get implemented as a function).\n        if (expanded.text === \"\\\\relax\") {\n          this.stack.pop();\n        } else {\n          return this.stack.pop(); // === expanded\n        }\n      }\n    } // Flow unable to figure out that this pathway is impossible.\n    // https://github.com/facebook/flow/issues/4808\n\n\n    throw new Error(); // eslint-disable-line no-unreachable\n  }\n  /**\n   * Fully expand the given macro name and return the resulting list of\n   * tokens, or return `undefined` if no such macro is defined.\n   */\n  ;\n\n  _proto.expandMacro = function expandMacro(name) {\n    if (!this.macros.get(name)) {\n      return undefined;\n    }\n\n    var output = [];\n    var oldStackLength = this.stack.length;\n    this.pushToken(new Token_Token(name));\n\n    while (this.stack.length > oldStackLength) {\n      var expanded = this.expandOnce(); // expandOnce returns Token if and only if it's fully expanded.\n\n      if (expanded instanceof Token_Token) {\n        output.push(this.stack.pop());\n      }\n    }\n\n    return output;\n  }\n  /**\n   * Fully expand the given macro name and return the result as a string,\n   * or return `undefined` if no such macro is defined.\n   */\n  ;\n\n  _proto.expandMacroAsText = function expandMacroAsText(name) {\n    var tokens = this.expandMacro(name);\n\n    if (tokens) {\n      return tokens.map(function (token) {\n        return token.text;\n      }).join(\"\");\n    } else {\n      return tokens;\n    }\n  }\n  /**\n   * Returns the expanded macro as a reversed array of tokens and a macro\n   * argument count.  Or returns `null` if no such macro.\n   */\n  ;\n\n  _proto._getExpansion = function _getExpansion(name) {\n    var definition = this.macros.get(name);\n\n    if (definition == null) {\n      // mainly checking for undefined here\n      return definition;\n    }\n\n    var expansion = typeof definition === \"function\" ? definition(this) : definition;\n\n    if (typeof expansion === \"string\") {\n      var numArgs = 0;\n\n      if (expansion.indexOf(\"#\") !== -1) {\n        var stripped = expansion.replace(/##/g, \"\");\n\n        while (stripped.indexOf(\"#\" + (numArgs + 1)) !== -1) {\n          ++numArgs;\n        }\n      }\n\n      var bodyLexer = new Lexer_Lexer(expansion, this.settings);\n      var tokens = [];\n      var tok = bodyLexer.lex();\n\n      while (tok.text !== \"EOF\") {\n        tokens.push(tok);\n        tok = bodyLexer.lex();\n      }\n\n      tokens.reverse(); // to fit in with stack using push and pop\n\n      var expanded = {\n        tokens: tokens,\n        numArgs: numArgs\n      };\n      return expanded;\n    }\n\n    return expansion;\n  }\n  /**\n   * Determine whether a command is currently \"defined\" (has some\n   * functionality), meaning that it's a macro (in the current group),\n   * a function, a symbol, or one of the special commands listed in\n   * `implicitCommands`.\n   */\n  ;\n\n  _proto.isDefined = function isDefined(name) {\n    return this.macros.has(name) || src_functions.hasOwnProperty(name) || src_symbols.math.hasOwnProperty(name) || src_symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);\n  };\n\n  return MacroExpander;\n}();\n\n\n// CONCATENATED MODULE: ./src/unicodeAccents.js\n// Mapping of Unicode accent characters to their LaTeX equivalent in text and\n// math mode (when they exist).\n/* harmony default export */ var unicodeAccents = ({\n  \"\\u0301\": {\n    text: \"\\\\'\",\n    math: '\\\\acute'\n  },\n  \"\\u0300\": {\n    text: '\\\\`',\n    math: '\\\\grave'\n  },\n  \"\\u0308\": {\n    text: '\\\\\"',\n    math: '\\\\ddot'\n  },\n  \"\\u0303\": {\n    text: '\\\\~',\n    math: '\\\\tilde'\n  },\n  \"\\u0304\": {\n    text: '\\\\=',\n    math: '\\\\bar'\n  },\n  \"\\u0306\": {\n    text: \"\\\\u\",\n    math: '\\\\breve'\n  },\n  \"\\u030C\": {\n    text: '\\\\v',\n    math: '\\\\check'\n  },\n  \"\\u0302\": {\n    text: '\\\\^',\n    math: '\\\\hat'\n  },\n  \"\\u0307\": {\n    text: '\\\\.',\n    math: '\\\\dot'\n  },\n  \"\\u030A\": {\n    text: '\\\\r',\n    math: '\\\\mathring'\n  },\n  \"\\u030B\": {\n    text: '\\\\H'\n  }\n});\n// CONCATENATED MODULE: ./src/unicodeSymbols.js\n// This file is GENERATED by unicodeMake.js. DO NOT MODIFY.\n/* harmony default export */ var unicodeSymbols = ({\n  \"\\xE1\": \"a\\u0301\",\n  // á = \\'{a}\n  \"\\xE0\": \"a\\u0300\",\n  // à = \\`{a}\n  \"\\xE4\": \"a\\u0308\",\n  // ä = \\\"{a}\n  \"\\u01DF\": \"a\\u0308\\u0304\",\n  // ǟ = \\\"\\={a}\n  \"\\xE3\": \"a\\u0303\",\n  // ã = \\~{a}\n  \"\\u0101\": \"a\\u0304\",\n  // ā = \\={a}\n  \"\\u0103\": \"a\\u0306\",\n  // ă = \\u{a}\n  \"\\u1EAF\": \"a\\u0306\\u0301\",\n  // ắ = \\u\\'{a}\n  \"\\u1EB1\": \"a\\u0306\\u0300\",\n  // ằ = \\u\\`{a}\n  \"\\u1EB5\": \"a\\u0306\\u0303\",\n  // ẵ = \\u\\~{a}\n  \"\\u01CE\": \"a\\u030C\",\n  // ǎ = \\v{a}\n  \"\\xE2\": \"a\\u0302\",\n  // â = \\^{a}\n  \"\\u1EA5\": \"a\\u0302\\u0301\",\n  // ấ = \\^\\'{a}\n  \"\\u1EA7\": \"a\\u0302\\u0300\",\n  // ầ = \\^\\`{a}\n  \"\\u1EAB\": \"a\\u0302\\u0303\",\n  // ẫ = \\^\\~{a}\n  \"\\u0227\": \"a\\u0307\",\n  // ȧ = \\.{a}\n  \"\\u01E1\": \"a\\u0307\\u0304\",\n  // ǡ = \\.\\={a}\n  \"\\xE5\": \"a\\u030A\",\n  // å = \\r{a}\n  \"\\u01FB\": \"a\\u030A\\u0301\",\n  // ǻ = \\r\\'{a}\n  \"\\u1E03\": \"b\\u0307\",\n  // ḃ = \\.{b}\n  \"\\u0107\": \"c\\u0301\",\n  // ć = \\'{c}\n  \"\\u010D\": \"c\\u030C\",\n  // č = \\v{c}\n  \"\\u0109\": \"c\\u0302\",\n  // ĉ = \\^{c}\n  \"\\u010B\": \"c\\u0307\",\n  // ċ = \\.{c}\n  \"\\u010F\": \"d\\u030C\",\n  // ď = \\v{d}\n  \"\\u1E0B\": \"d\\u0307\",\n  // ḋ = \\.{d}\n  \"\\xE9\": \"e\\u0301\",\n  // é = \\'{e}\n  \"\\xE8\": \"e\\u0300\",\n  // è = \\`{e}\n  \"\\xEB\": \"e\\u0308\",\n  // ë = \\\"{e}\n  \"\\u1EBD\": \"e\\u0303\",\n  // ẽ = \\~{e}\n  \"\\u0113\": \"e\\u0304\",\n  // ē = \\={e}\n  \"\\u1E17\": \"e\\u0304\\u0301\",\n  // ḗ = \\=\\'{e}\n  \"\\u1E15\": \"e\\u0304\\u0300\",\n  // ḕ = \\=\\`{e}\n  \"\\u0115\": \"e\\u0306\",\n  // ĕ = \\u{e}\n  \"\\u011B\": \"e\\u030C\",\n  // ě = \\v{e}\n  \"\\xEA\": \"e\\u0302\",\n  // ê = \\^{e}\n  \"\\u1EBF\": \"e\\u0302\\u0301\",\n  // ế = \\^\\'{e}\n  \"\\u1EC1\": \"e\\u0302\\u0300\",\n  // ề = \\^\\`{e}\n  \"\\u1EC5\": \"e\\u0302\\u0303\",\n  // ễ = \\^\\~{e}\n  \"\\u0117\": \"e\\u0307\",\n  // ė = \\.{e}\n  \"\\u1E1F\": \"f\\u0307\",\n  // ḟ = \\.{f}\n  \"\\u01F5\": \"g\\u0301\",\n  // ǵ = \\'{g}\n  \"\\u1E21\": \"g\\u0304\",\n  // ḡ = \\={g}\n  \"\\u011F\": \"g\\u0306\",\n  // ğ = \\u{g}\n  \"\\u01E7\": \"g\\u030C\",\n  // ǧ = \\v{g}\n  \"\\u011D\": \"g\\u0302\",\n  // ĝ = \\^{g}\n  \"\\u0121\": \"g\\u0307\",\n  // ġ = \\.{g}\n  \"\\u1E27\": \"h\\u0308\",\n  // ḧ = \\\"{h}\n  \"\\u021F\": \"h\\u030C\",\n  // ȟ = \\v{h}\n  \"\\u0125\": \"h\\u0302\",\n  // ĥ = \\^{h}\n  \"\\u1E23\": \"h\\u0307\",\n  // ḣ = \\.{h}\n  \"\\xED\": \"i\\u0301\",\n  // í = \\'{i}\n  \"\\xEC\": \"i\\u0300\",\n  // ì = \\`{i}\n  \"\\xEF\": \"i\\u0308\",\n  // ï = \\\"{i}\n  \"\\u1E2F\": \"i\\u0308\\u0301\",\n  // ḯ = \\\"\\'{i}\n  \"\\u0129\": \"i\\u0303\",\n  // ĩ = \\~{i}\n  \"\\u012B\": \"i\\u0304\",\n  // ī = \\={i}\n  \"\\u012D\": \"i\\u0306\",\n  // ĭ = \\u{i}\n  \"\\u01D0\": \"i\\u030C\",\n  // ǐ = \\v{i}\n  \"\\xEE\": \"i\\u0302\",\n  // î = \\^{i}\n  \"\\u01F0\": \"j\\u030C\",\n  // ǰ = \\v{j}\n  \"\\u0135\": \"j\\u0302\",\n  // ĵ = \\^{j}\n  \"\\u1E31\": \"k\\u0301\",\n  // ḱ = \\'{k}\n  \"\\u01E9\": \"k\\u030C\",\n  // ǩ = \\v{k}\n  \"\\u013A\": \"l\\u0301\",\n  // ĺ = \\'{l}\n  \"\\u013E\": \"l\\u030C\",\n  // ľ = \\v{l}\n  \"\\u1E3F\": \"m\\u0301\",\n  // ḿ = \\'{m}\n  \"\\u1E41\": \"m\\u0307\",\n  // ṁ = \\.{m}\n  \"\\u0144\": \"n\\u0301\",\n  // ń = \\'{n}\n  \"\\u01F9\": \"n\\u0300\",\n  // ǹ = \\`{n}\n  \"\\xF1\": \"n\\u0303\",\n  // ñ = \\~{n}\n  \"\\u0148\": \"n\\u030C\",\n  // ň = \\v{n}\n  \"\\u1E45\": \"n\\u0307\",\n  // ṅ = \\.{n}\n  \"\\xF3\": \"o\\u0301\",\n  // ó = \\'{o}\n  \"\\xF2\": \"o\\u0300\",\n  // ò = \\`{o}\n  \"\\xF6\": \"o\\u0308\",\n  // ö = \\\"{o}\n  \"\\u022B\": \"o\\u0308\\u0304\",\n  // ȫ = \\\"\\={o}\n  \"\\xF5\": \"o\\u0303\",\n  // õ = \\~{o}\n  \"\\u1E4D\": \"o\\u0303\\u0301\",\n  // ṍ = \\~\\'{o}\n  \"\\u1E4F\": \"o\\u0303\\u0308\",\n  // ṏ = \\~\\\"{o}\n  \"\\u022D\": \"o\\u0303\\u0304\",\n  // ȭ = \\~\\={o}\n  \"\\u014D\": \"o\\u0304\",\n  // ō = \\={o}\n  \"\\u1E53\": \"o\\u0304\\u0301\",\n  // ṓ = \\=\\'{o}\n  \"\\u1E51\": \"o\\u0304\\u0300\",\n  // ṑ = \\=\\`{o}\n  \"\\u014F\": \"o\\u0306\",\n  // ŏ = \\u{o}\n  \"\\u01D2\": \"o\\u030C\",\n  // ǒ = \\v{o}\n  \"\\xF4\": \"o\\u0302\",\n  // ô = \\^{o}\n  \"\\u1ED1\": \"o\\u0302\\u0301\",\n  // ố = \\^\\'{o}\n  \"\\u1ED3\": \"o\\u0302\\u0300\",\n  // ồ = \\^\\`{o}\n  \"\\u1ED7\": \"o\\u0302\\u0303\",\n  // ỗ = \\^\\~{o}\n  \"\\u022F\": \"o\\u0307\",\n  // ȯ = \\.{o}\n  \"\\u0231\": \"o\\u0307\\u0304\",\n  // ȱ = \\.\\={o}\n  \"\\u0151\": \"o\\u030B\",\n  // ő = \\H{o}\n  \"\\u1E55\": \"p\\u0301\",\n  // ṕ = \\'{p}\n  \"\\u1E57\": \"p\\u0307\",\n  // ṗ = \\.{p}\n  \"\\u0155\": \"r\\u0301\",\n  // ŕ = \\'{r}\n  \"\\u0159\": \"r\\u030C\",\n  // ř = \\v{r}\n  \"\\u1E59\": \"r\\u0307\",\n  // ṙ = \\.{r}\n  \"\\u015B\": \"s\\u0301\",\n  // ś = \\'{s}\n  \"\\u1E65\": \"s\\u0301\\u0307\",\n  // ṥ = \\'\\.{s}\n  \"\\u0161\": \"s\\u030C\",\n  // š = \\v{s}\n  \"\\u1E67\": \"s\\u030C\\u0307\",\n  // ṧ = \\v\\.{s}\n  \"\\u015D\": \"s\\u0302\",\n  // ŝ = \\^{s}\n  \"\\u1E61\": \"s\\u0307\",\n  // ṡ = \\.{s}\n  \"\\u1E97\": \"t\\u0308\",\n  // ẗ = \\\"{t}\n  \"\\u0165\": \"t\\u030C\",\n  // ť = \\v{t}\n  \"\\u1E6B\": \"t\\u0307\",\n  // ṫ = \\.{t}\n  \"\\xFA\": \"u\\u0301\",\n  // ú = \\'{u}\n  \"\\xF9\": \"u\\u0300\",\n  // ù = \\`{u}\n  \"\\xFC\": \"u\\u0308\",\n  // ü = \\\"{u}\n  \"\\u01D8\": \"u\\u0308\\u0301\",\n  // ǘ = \\\"\\'{u}\n  \"\\u01DC\": \"u\\u0308\\u0300\",\n  // ǜ = \\\"\\`{u}\n  \"\\u01D6\": \"u\\u0308\\u0304\",\n  // ǖ = \\\"\\={u}\n  \"\\u01DA\": \"u\\u0308\\u030C\",\n  // ǚ = \\\"\\v{u}\n  \"\\u0169\": \"u\\u0303\",\n  // ũ = \\~{u}\n  \"\\u1E79\": \"u\\u0303\\u0301\",\n  // ṹ = \\~\\'{u}\n  \"\\u016B\": \"u\\u0304\",\n  // ū = \\={u}\n  \"\\u1E7B\": \"u\\u0304\\u0308\",\n  // ṻ = \\=\\\"{u}\n  \"\\u016D\": \"u\\u0306\",\n  // ŭ = \\u{u}\n  \"\\u01D4\": \"u\\u030C\",\n  // ǔ = \\v{u}\n  \"\\xFB\": \"u\\u0302\",\n  // û = \\^{u}\n  \"\\u016F\": \"u\\u030A\",\n  // ů = \\r{u}\n  \"\\u0171\": \"u\\u030B\",\n  // ű = \\H{u}\n  \"\\u1E7D\": \"v\\u0303\",\n  // ṽ = \\~{v}\n  \"\\u1E83\": \"w\\u0301\",\n  // ẃ = \\'{w}\n  \"\\u1E81\": \"w\\u0300\",\n  // ẁ = \\`{w}\n  \"\\u1E85\": \"w\\u0308\",\n  // ẅ = \\\"{w}\n  \"\\u0175\": \"w\\u0302\",\n  // ŵ = \\^{w}\n  \"\\u1E87\": \"w\\u0307\",\n  // ẇ = \\.{w}\n  \"\\u1E98\": \"w\\u030A\",\n  // ẘ = \\r{w}\n  \"\\u1E8D\": \"x\\u0308\",\n  // ẍ = \\\"{x}\n  \"\\u1E8B\": \"x\\u0307\",\n  // ẋ = \\.{x}\n  \"\\xFD\": \"y\\u0301\",\n  // ý = \\'{y}\n  \"\\u1EF3\": \"y\\u0300\",\n  // ỳ = \\`{y}\n  \"\\xFF\": \"y\\u0308\",\n  // ÿ = \\\"{y}\n  \"\\u1EF9\": \"y\\u0303\",\n  // ỹ = \\~{y}\n  \"\\u0233\": \"y\\u0304\",\n  // ȳ = \\={y}\n  \"\\u0177\": \"y\\u0302\",\n  // ŷ = \\^{y}\n  \"\\u1E8F\": \"y\\u0307\",\n  // ẏ = \\.{y}\n  \"\\u1E99\": \"y\\u030A\",\n  // ẙ = \\r{y}\n  \"\\u017A\": \"z\\u0301\",\n  // ź = \\'{z}\n  \"\\u017E\": \"z\\u030C\",\n  // ž = \\v{z}\n  \"\\u1E91\": \"z\\u0302\",\n  // ẑ = \\^{z}\n  \"\\u017C\": \"z\\u0307\",\n  // ż = \\.{z}\n  \"\\xC1\": \"A\\u0301\",\n  // Á = \\'{A}\n  \"\\xC0\": \"A\\u0300\",\n  // À = \\`{A}\n  \"\\xC4\": \"A\\u0308\",\n  // Ä = \\\"{A}\n  \"\\u01DE\": \"A\\u0308\\u0304\",\n  // Ǟ = \\\"\\={A}\n  \"\\xC3\": \"A\\u0303\",\n  // Ã = \\~{A}\n  \"\\u0100\": \"A\\u0304\",\n  // Ā = \\={A}\n  \"\\u0102\": \"A\\u0306\",\n  // Ă = \\u{A}\n  \"\\u1EAE\": \"A\\u0306\\u0301\",\n  // Ắ = \\u\\'{A}\n  \"\\u1EB0\": \"A\\u0306\\u0300\",\n  // Ằ = \\u\\`{A}\n  \"\\u1EB4\": \"A\\u0306\\u0303\",\n  // Ẵ = \\u\\~{A}\n  \"\\u01CD\": \"A\\u030C\",\n  // Ǎ = \\v{A}\n  \"\\xC2\": \"A\\u0302\",\n  // Â = \\^{A}\n  \"\\u1EA4\": \"A\\u0302\\u0301\",\n  // Ấ = \\^\\'{A}\n  \"\\u1EA6\": \"A\\u0302\\u0300\",\n  // Ầ = \\^\\`{A}\n  \"\\u1EAA\": \"A\\u0302\\u0303\",\n  // Ẫ = \\^\\~{A}\n  \"\\u0226\": \"A\\u0307\",\n  // Ȧ = \\.{A}\n  \"\\u01E0\": \"A\\u0307\\u0304\",\n  // Ǡ = \\.\\={A}\n  \"\\xC5\": \"A\\u030A\",\n  // Å = \\r{A}\n  \"\\u01FA\": \"A\\u030A\\u0301\",\n  // Ǻ = \\r\\'{A}\n  \"\\u1E02\": \"B\\u0307\",\n  // Ḃ = \\.{B}\n  \"\\u0106\": \"C\\u0301\",\n  // Ć = \\'{C}\n  \"\\u010C\": \"C\\u030C\",\n  // Č = \\v{C}\n  \"\\u0108\": \"C\\u0302\",\n  // Ĉ = \\^{C}\n  \"\\u010A\": \"C\\u0307\",\n  // Ċ = \\.{C}\n  \"\\u010E\": \"D\\u030C\",\n  // Ď = \\v{D}\n  \"\\u1E0A\": \"D\\u0307\",\n  // Ḋ = \\.{D}\n  \"\\xC9\": \"E\\u0301\",\n  // É = \\'{E}\n  \"\\xC8\": \"E\\u0300\",\n  // È = \\`{E}\n  \"\\xCB\": \"E\\u0308\",\n  // Ë = \\\"{E}\n  \"\\u1EBC\": \"E\\u0303\",\n  // Ẽ = \\~{E}\n  \"\\u0112\": \"E\\u0304\",\n  // Ē = \\={E}\n  \"\\u1E16\": \"E\\u0304\\u0301\",\n  // Ḗ = \\=\\'{E}\n  \"\\u1E14\": \"E\\u0304\\u0300\",\n  // Ḕ = \\=\\`{E}\n  \"\\u0114\": \"E\\u0306\",\n  // Ĕ = \\u{E}\n  \"\\u011A\": \"E\\u030C\",\n  // Ě = \\v{E}\n  \"\\xCA\": \"E\\u0302\",\n  // Ê = \\^{E}\n  \"\\u1EBE\": \"E\\u0302\\u0301\",\n  // Ế = \\^\\'{E}\n  \"\\u1EC0\": \"E\\u0302\\u0300\",\n  // Ề = \\^\\`{E}\n  \"\\u1EC4\": \"E\\u0302\\u0303\",\n  // Ễ = \\^\\~{E}\n  \"\\u0116\": \"E\\u0307\",\n  // Ė = \\.{E}\n  \"\\u1E1E\": \"F\\u0307\",\n  // Ḟ = \\.{F}\n  \"\\u01F4\": \"G\\u0301\",\n  // Ǵ = \\'{G}\n  \"\\u1E20\": \"G\\u0304\",\n  // Ḡ = \\={G}\n  \"\\u011E\": \"G\\u0306\",\n  // Ğ = \\u{G}\n  \"\\u01E6\": \"G\\u030C\",\n  // Ǧ = \\v{G}\n  \"\\u011C\": \"G\\u0302\",\n  // Ĝ = \\^{G}\n  \"\\u0120\": \"G\\u0307\",\n  // Ġ = \\.{G}\n  \"\\u1E26\": \"H\\u0308\",\n  // Ḧ = \\\"{H}\n  \"\\u021E\": \"H\\u030C\",\n  // Ȟ = \\v{H}\n  \"\\u0124\": \"H\\u0302\",\n  // Ĥ = \\^{H}\n  \"\\u1E22\": \"H\\u0307\",\n  // Ḣ = \\.{H}\n  \"\\xCD\": \"I\\u0301\",\n  // Í = \\'{I}\n  \"\\xCC\": \"I\\u0300\",\n  // Ì = \\`{I}\n  \"\\xCF\": \"I\\u0308\",\n  // Ï = \\\"{I}\n  \"\\u1E2E\": \"I\\u0308\\u0301\",\n  // Ḯ = \\\"\\'{I}\n  \"\\u0128\": \"I\\u0303\",\n  // Ĩ = \\~{I}\n  \"\\u012A\": \"I\\u0304\",\n  // Ī = \\={I}\n  \"\\u012C\": \"I\\u0306\",\n  // Ĭ = \\u{I}\n  \"\\u01CF\": \"I\\u030C\",\n  // Ǐ = \\v{I}\n  \"\\xCE\": \"I\\u0302\",\n  // Î = \\^{I}\n  \"\\u0130\": \"I\\u0307\",\n  // İ = \\.{I}\n  \"\\u0134\": \"J\\u0302\",\n  // Ĵ = \\^{J}\n  \"\\u1E30\": \"K\\u0301\",\n  // Ḱ = \\'{K}\n  \"\\u01E8\": \"K\\u030C\",\n  // Ǩ = \\v{K}\n  \"\\u0139\": \"L\\u0301\",\n  // Ĺ = \\'{L}\n  \"\\u013D\": \"L\\u030C\",\n  // Ľ = \\v{L}\n  \"\\u1E3E\": \"M\\u0301\",\n  // Ḿ = \\'{M}\n  \"\\u1E40\": \"M\\u0307\",\n  // Ṁ = \\.{M}\n  \"\\u0143\": \"N\\u0301\",\n  // Ń = \\'{N}\n  \"\\u01F8\": \"N\\u0300\",\n  // Ǹ = \\`{N}\n  \"\\xD1\": \"N\\u0303\",\n  // Ñ = \\~{N}\n  \"\\u0147\": \"N\\u030C\",\n  // Ň = \\v{N}\n  \"\\u1E44\": \"N\\u0307\",\n  // Ṅ = \\.{N}\n  \"\\xD3\": \"O\\u0301\",\n  // Ó = \\'{O}\n  \"\\xD2\": \"O\\u0300\",\n  // Ò = \\`{O}\n  \"\\xD6\": \"O\\u0308\",\n  // Ö = \\\"{O}\n  \"\\u022A\": \"O\\u0308\\u0304\",\n  // Ȫ = \\\"\\={O}\n  \"\\xD5\": \"O\\u0303\",\n  // Õ = \\~{O}\n  \"\\u1E4C\": \"O\\u0303\\u0301\",\n  // Ṍ = \\~\\'{O}\n  \"\\u1E4E\": \"O\\u0303\\u0308\",\n  // Ṏ = \\~\\\"{O}\n  \"\\u022C\": \"O\\u0303\\u0304\",\n  // Ȭ = \\~\\={O}\n  \"\\u014C\": \"O\\u0304\",\n  // Ō = \\={O}\n  \"\\u1E52\": \"O\\u0304\\u0301\",\n  // Ṓ = \\=\\'{O}\n  \"\\u1E50\": \"O\\u0304\\u0300\",\n  // Ṑ = \\=\\`{O}\n  \"\\u014E\": \"O\\u0306\",\n  // Ŏ = \\u{O}\n  \"\\u01D1\": \"O\\u030C\",\n  // Ǒ = \\v{O}\n  \"\\xD4\": \"O\\u0302\",\n  // Ô = \\^{O}\n  \"\\u1ED0\": \"O\\u0302\\u0301\",\n  // Ố = \\^\\'{O}\n  \"\\u1ED2\": \"O\\u0302\\u0300\",\n  // Ồ = \\^\\`{O}\n  \"\\u1ED6\": \"O\\u0302\\u0303\",\n  // Ỗ = \\^\\~{O}\n  \"\\u022E\": \"O\\u0307\",\n  // Ȯ = \\.{O}\n  \"\\u0230\": \"O\\u0307\\u0304\",\n  // Ȱ = \\.\\={O}\n  \"\\u0150\": \"O\\u030B\",\n  // Ő = \\H{O}\n  \"\\u1E54\": \"P\\u0301\",\n  // Ṕ = \\'{P}\n  \"\\u1E56\": \"P\\u0307\",\n  // Ṗ = \\.{P}\n  \"\\u0154\": \"R\\u0301\",\n  // Ŕ = \\'{R}\n  \"\\u0158\": \"R\\u030C\",\n  // Ř = \\v{R}\n  \"\\u1E58\": \"R\\u0307\",\n  // Ṙ = \\.{R}\n  \"\\u015A\": \"S\\u0301\",\n  // Ś = \\'{S}\n  \"\\u1E64\": \"S\\u0301\\u0307\",\n  // Ṥ = \\'\\.{S}\n  \"\\u0160\": \"S\\u030C\",\n  // Š = \\v{S}\n  \"\\u1E66\": \"S\\u030C\\u0307\",\n  // Ṧ = \\v\\.{S}\n  \"\\u015C\": \"S\\u0302\",\n  // Ŝ = \\^{S}\n  \"\\u1E60\": \"S\\u0307\",\n  // Ṡ = \\.{S}\n  \"\\u0164\": \"T\\u030C\",\n  // Ť = \\v{T}\n  \"\\u1E6A\": \"T\\u0307\",\n  // Ṫ = \\.{T}\n  \"\\xDA\": \"U\\u0301\",\n  // Ú = \\'{U}\n  \"\\xD9\": \"U\\u0300\",\n  // Ù = \\`{U}\n  \"\\xDC\": \"U\\u0308\",\n  // Ü = \\\"{U}\n  \"\\u01D7\": \"U\\u0308\\u0301\",\n  // Ǘ = \\\"\\'{U}\n  \"\\u01DB\": \"U\\u0308\\u0300\",\n  // Ǜ = \\\"\\`{U}\n  \"\\u01D5\": \"U\\u0308\\u0304\",\n  // Ǖ = \\\"\\={U}\n  \"\\u01D9\": \"U\\u0308\\u030C\",\n  // Ǚ = \\\"\\v{U}\n  \"\\u0168\": \"U\\u0303\",\n  // Ũ = \\~{U}\n  \"\\u1E78\": \"U\\u0303\\u0301\",\n  // Ṹ = \\~\\'{U}\n  \"\\u016A\": \"U\\u0304\",\n  // Ū = \\={U}\n  \"\\u1E7A\": \"U\\u0304\\u0308\",\n  // Ṻ = \\=\\\"{U}\n  \"\\u016C\": \"U\\u0306\",\n  // Ŭ = \\u{U}\n  \"\\u01D3\": \"U\\u030C\",\n  // Ǔ = \\v{U}\n  \"\\xDB\": \"U\\u0302\",\n  // Û = \\^{U}\n  \"\\u016E\": \"U\\u030A\",\n  // Ů = \\r{U}\n  \"\\u0170\": \"U\\u030B\",\n  // Ű = \\H{U}\n  \"\\u1E7C\": \"V\\u0303\",\n  // Ṽ = \\~{V}\n  \"\\u1E82\": \"W\\u0301\",\n  // Ẃ = \\'{W}\n  \"\\u1E80\": \"W\\u0300\",\n  // Ẁ = \\`{W}\n  \"\\u1E84\": \"W\\u0308\",\n  // Ẅ = \\\"{W}\n  \"\\u0174\": \"W\\u0302\",\n  // Ŵ = \\^{W}\n  \"\\u1E86\": \"W\\u0307\",\n  // Ẇ = \\.{W}\n  \"\\u1E8C\": \"X\\u0308\",\n  // Ẍ = \\\"{X}\n  \"\\u1E8A\": \"X\\u0307\",\n  // Ẋ = \\.{X}\n  \"\\xDD\": \"Y\\u0301\",\n  // Ý = \\'{Y}\n  \"\\u1EF2\": \"Y\\u0300\",\n  // Ỳ = \\`{Y}\n  \"\\u0178\": \"Y\\u0308\",\n  // Ÿ = \\\"{Y}\n  \"\\u1EF8\": \"Y\\u0303\",\n  // Ỹ = \\~{Y}\n  \"\\u0232\": \"Y\\u0304\",\n  // Ȳ = \\={Y}\n  \"\\u0176\": \"Y\\u0302\",\n  // Ŷ = \\^{Y}\n  \"\\u1E8E\": \"Y\\u0307\",\n  // Ẏ = \\.{Y}\n  \"\\u0179\": \"Z\\u0301\",\n  // Ź = \\'{Z}\n  \"\\u017D\": \"Z\\u030C\",\n  // Ž = \\v{Z}\n  \"\\u1E90\": \"Z\\u0302\",\n  // Ẑ = \\^{Z}\n  \"\\u017B\": \"Z\\u0307\",\n  // Ż = \\.{Z}\n  \"\\u03AC\": \"\\u03B1\\u0301\",\n  // ά = \\'{α}\n  \"\\u1F70\": \"\\u03B1\\u0300\",\n  // ὰ = \\`{α}\n  \"\\u1FB1\": \"\\u03B1\\u0304\",\n  // ᾱ = \\={α}\n  \"\\u1FB0\": \"\\u03B1\\u0306\",\n  // ᾰ = \\u{α}\n  \"\\u03AD\": \"\\u03B5\\u0301\",\n  // έ = \\'{ε}\n  \"\\u1F72\": \"\\u03B5\\u0300\",\n  // ὲ = \\`{ε}\n  \"\\u03AE\": \"\\u03B7\\u0301\",\n  // ή = \\'{η}\n  \"\\u1F74\": \"\\u03B7\\u0300\",\n  // ὴ = \\`{η}\n  \"\\u03AF\": \"\\u03B9\\u0301\",\n  // ί = \\'{ι}\n  \"\\u1F76\": \"\\u03B9\\u0300\",\n  // ὶ = \\`{ι}\n  \"\\u03CA\": \"\\u03B9\\u0308\",\n  // ϊ = \\\"{ι}\n  \"\\u0390\": \"\\u03B9\\u0308\\u0301\",\n  // ΐ = \\\"\\'{ι}\n  \"\\u1FD2\": \"\\u03B9\\u0308\\u0300\",\n  // ῒ = \\\"\\`{ι}\n  \"\\u1FD1\": \"\\u03B9\\u0304\",\n  // ῑ = \\={ι}\n  \"\\u1FD0\": \"\\u03B9\\u0306\",\n  // ῐ = \\u{ι}\n  \"\\u03CC\": \"\\u03BF\\u0301\",\n  // ό = \\'{ο}\n  \"\\u1F78\": \"\\u03BF\\u0300\",\n  // ὸ = \\`{ο}\n  \"\\u03CD\": \"\\u03C5\\u0301\",\n  // ύ = \\'{υ}\n  \"\\u1F7A\": \"\\u03C5\\u0300\",\n  // ὺ = \\`{υ}\n  \"\\u03CB\": \"\\u03C5\\u0308\",\n  // ϋ = \\\"{υ}\n  \"\\u03B0\": \"\\u03C5\\u0308\\u0301\",\n  // ΰ = \\\"\\'{υ}\n  \"\\u1FE2\": \"\\u03C5\\u0308\\u0300\",\n  // ῢ = \\\"\\`{υ}\n  \"\\u1FE1\": \"\\u03C5\\u0304\",\n  // ῡ = \\={υ}\n  \"\\u1FE0\": \"\\u03C5\\u0306\",\n  // ῠ = \\u{υ}\n  \"\\u03CE\": \"\\u03C9\\u0301\",\n  // ώ = \\'{ω}\n  \"\\u1F7C\": \"\\u03C9\\u0300\",\n  // ὼ = \\`{ω}\n  \"\\u038E\": \"\\u03A5\\u0301\",\n  // Ύ = \\'{Υ}\n  \"\\u1FEA\": \"\\u03A5\\u0300\",\n  // Ὺ = \\`{Υ}\n  \"\\u03AB\": \"\\u03A5\\u0308\",\n  // Ϋ = \\\"{Υ}\n  \"\\u1FE9\": \"\\u03A5\\u0304\",\n  // Ῡ = \\={Υ}\n  \"\\u1FE8\": \"\\u03A5\\u0306\",\n  // Ῠ = \\u{Υ}\n  \"\\u038F\": \"\\u03A9\\u0301\",\n  // Ώ = \\'{Ω}\n  \"\\u1FFA\": \"\\u03A9\\u0300\" // Ὼ = \\`{Ω}\n\n});\n// CONCATENATED MODULE: ./src/Parser.js\n/* eslint no-constant-condition:0 */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * This file contains the parser used to parse out a TeX expression from the\n * input. Since TeX isn't context-free, standard parsers don't work particularly\n * well.\n *\n * The strategy of this parser is as such:\n *\n * The main functions (the `.parse...` ones) take a position in the current\n * parse string to parse tokens from. The lexer (found in Lexer.js, stored at\n * this.gullet.lexer) also supports pulling out tokens at arbitrary places. When\n * individual tokens are needed at a position, the lexer is called to pull out a\n * token, which is then used.\n *\n * The parser has a property called \"mode\" indicating the mode that\n * the parser is currently in. Currently it has to be one of \"math\" or\n * \"text\", which denotes whether the current environment is a math-y\n * one or a text-y one (e.g. inside \\text). Currently, this serves to\n * limit the functions which can be used in text mode.\n *\n * The main functions then return an object which contains the useful data that\n * was parsed at its given point, and a new position at the end of the parsed\n * data. The main functions can call each other and continue the parsing by\n * using the returned position as a new starting point.\n *\n * There are also extra `.handle...` functions, which pull out some reused\n * functionality into self-contained functions.\n *\n * The functions return ParseNodes.\n */\nvar Parser_Parser =\n/*#__PURE__*/\nfunction () {\n  function Parser(input, settings) {\n    this.mode = void 0;\n    this.gullet = void 0;\n    this.settings = void 0;\n    this.leftrightDepth = void 0;\n    this.nextToken = void 0;\n    // Start in math mode\n    this.mode = \"math\"; // Create a new macro expander (gullet) and (indirectly via that) also a\n    // new lexer (mouth) for this parser (stomach, in the language of TeX)\n\n    this.gullet = new MacroExpander_MacroExpander(input, settings, this.mode); // Store the settings for use in parsing\n\n    this.settings = settings; // Count leftright depth (for \\middle errors)\n\n    this.leftrightDepth = 0;\n  }\n  /**\n   * Checks a result to make sure it has the right type, and throws an\n   * appropriate error otherwise.\n   */\n\n\n  var _proto = Parser.prototype;\n\n  _proto.expect = function expect(text, consume) {\n    if (consume === void 0) {\n      consume = true;\n    }\n\n    if (this.fetch().text !== text) {\n      throw new src_ParseError(\"Expected '\" + text + \"', got '\" + this.fetch().text + \"'\", this.fetch());\n    }\n\n    if (consume) {\n      this.consume();\n    }\n  }\n  /**\n   * Discards the current lookahead token, considering it consumed.\n   */\n  ;\n\n  _proto.consume = function consume() {\n    this.nextToken = null;\n  }\n  /**\n   * Return the current lookahead token, or if there isn't one (at the\n   * beginning, or if the previous lookahead token was consume()d),\n   * fetch the next token as the new lookahead token and return it.\n   */\n  ;\n\n  _proto.fetch = function fetch() {\n    if (this.nextToken == null) {\n      this.nextToken = this.gullet.expandNextToken();\n    }\n\n    return this.nextToken;\n  }\n  /**\n   * Switches between \"text\" and \"math\" modes.\n   */\n  ;\n\n  _proto.switchMode = function switchMode(newMode) {\n    this.mode = newMode;\n    this.gullet.switchMode(newMode);\n  }\n  /**\n   * Main parsing function, which parses an entire input.\n   */\n  ;\n\n  _proto.parse = function parse() {\n    // Create a group namespace for the math expression.\n    // (LaTeX creates a new group for every $...$, $$...$$, \\[...\\].)\n    this.gullet.beginGroup(); // Use old \\color behavior (same as LaTeX's \\textcolor) if requested.\n    // We do this within the group for the math expression, so it doesn't\n    // pollute settings.macros.\n\n    if (this.settings.colorIsTextColor) {\n      this.gullet.macros.set(\"\\\\color\", \"\\\\textcolor\");\n    } // Try to parse the input\n\n\n    var parse = this.parseExpression(false); // If we succeeded, make sure there's an EOF at the end\n\n    this.expect(\"EOF\"); // End the group namespace for the expression\n\n    this.gullet.endGroup();\n    return parse;\n  };\n\n  _proto.parseExpression = function parseExpression(breakOnInfix, breakOnTokenText) {\n    var body = []; // Keep adding atoms to the body until we can't parse any more atoms (either\n    // we reached the end, a }, or a \\right)\n\n    while (true) {\n      // Ignore spaces in math mode\n      if (this.mode === \"math\") {\n        this.consumeSpaces();\n      }\n\n      var lex = this.fetch();\n\n      if (Parser.endOfExpression.indexOf(lex.text) !== -1) {\n        break;\n      }\n\n      if (breakOnTokenText && lex.text === breakOnTokenText) {\n        break;\n      }\n\n      if (breakOnInfix && src_functions[lex.text] && src_functions[lex.text].infix) {\n        break;\n      }\n\n      var atom = this.parseAtom(breakOnTokenText);\n\n      if (!atom) {\n        break;\n      }\n\n      body.push(atom);\n    }\n\n    if (this.mode === \"text\") {\n      this.formLigatures(body);\n    }\n\n    return this.handleInfixNodes(body);\n  }\n  /**\n   * Rewrites infix operators such as \\over with corresponding commands such\n   * as \\frac.\n   *\n   * There can only be one infix operator per group.  If there's more than one\n   * then the expression is ambiguous.  This can be resolved by adding {}.\n   */\n  ;\n\n  _proto.handleInfixNodes = function handleInfixNodes(body) {\n    var overIndex = -1;\n    var funcName;\n\n    for (var i = 0; i < body.length; i++) {\n      var node = checkNodeType(body[i], \"infix\");\n\n      if (node) {\n        if (overIndex !== -1) {\n          throw new src_ParseError(\"only one infix operator per group\", node.token);\n        }\n\n        overIndex = i;\n        funcName = node.replaceWith;\n      }\n    }\n\n    if (overIndex !== -1 && funcName) {\n      var numerNode;\n      var denomNode;\n      var numerBody = body.slice(0, overIndex);\n      var denomBody = body.slice(overIndex + 1);\n\n      if (numerBody.length === 1 && numerBody[0].type === \"ordgroup\") {\n        numerNode = numerBody[0];\n      } else {\n        numerNode = {\n          type: \"ordgroup\",\n          mode: this.mode,\n          body: numerBody\n        };\n      }\n\n      if (denomBody.length === 1 && denomBody[0].type === \"ordgroup\") {\n        denomNode = denomBody[0];\n      } else {\n        denomNode = {\n          type: \"ordgroup\",\n          mode: this.mode,\n          body: denomBody\n        };\n      }\n\n      var _node;\n\n      if (funcName === \"\\\\\\\\abovefrac\") {\n        _node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);\n      } else {\n        _node = this.callFunction(funcName, [numerNode, denomNode], []);\n      }\n\n      return [_node];\n    } else {\n      return body;\n    }\n  } // The greediness of a superscript or subscript\n  ;\n\n  /**\n   * Handle a subscript or superscript with nice errors.\n   */\n  _proto.handleSupSubscript = function handleSupSubscript(name) {\n    var symbolToken = this.fetch();\n    var symbol = symbolToken.text;\n    this.consume();\n    var group = this.parseGroup(name, false, Parser.SUPSUB_GREEDINESS, undefined, undefined, true); // ignore spaces before sup/subscript argument\n\n    if (!group) {\n      throw new src_ParseError(\"Expected group after '\" + symbol + \"'\", symbolToken);\n    }\n\n    return group;\n  }\n  /**\n   * Converts the textual input of an unsupported command into a text node\n   * contained within a color node whose color is determined by errorColor\n   */\n  ;\n\n  _proto.formatUnsupportedCmd = function formatUnsupportedCmd(text) {\n    var textordArray = [];\n\n    for (var i = 0; i < text.length; i++) {\n      textordArray.push({\n        type: \"textord\",\n        mode: \"text\",\n        text: text[i]\n      });\n    }\n\n    var textNode = {\n      type: \"text\",\n      mode: this.mode,\n      body: textordArray\n    };\n    var colorNode = {\n      type: \"color\",\n      mode: this.mode,\n      color: this.settings.errorColor,\n      body: [textNode]\n    };\n    return colorNode;\n  }\n  /**\n   * Parses a group with optional super/subscripts.\n   */\n  ;\n\n  _proto.parseAtom = function parseAtom(breakOnTokenText) {\n    // The body of an atom is an implicit group, so that things like\n    // \\left(x\\right)^2 work correctly.\n    var base = this.parseGroup(\"atom\", false, null, breakOnTokenText); // In text mode, we don't have superscripts or subscripts\n\n    if (this.mode === \"text\") {\n      return base;\n    } // Note that base may be empty (i.e. null) at this point.\n\n\n    var superscript;\n    var subscript;\n\n    while (true) {\n      // Guaranteed in math mode, so eat any spaces first.\n      this.consumeSpaces(); // Lex the first token\n\n      var lex = this.fetch();\n\n      if (lex.text === \"\\\\limits\" || lex.text === \"\\\\nolimits\") {\n        // We got a limit control\n        var opNode = checkNodeType(base, \"op\");\n\n        if (opNode) {\n          var limits = lex.text === \"\\\\limits\";\n          opNode.limits = limits;\n          opNode.alwaysHandleSupSub = true;\n        } else {\n          opNode = checkNodeType(base, \"operatorname\");\n\n          if (opNode && opNode.alwaysHandleSupSub) {\n            var _limits = lex.text === \"\\\\limits\";\n\n            opNode.limits = _limits;\n          } else {\n            throw new src_ParseError(\"Limit controls must follow a math operator\", lex);\n          }\n        }\n\n        this.consume();\n      } else if (lex.text === \"^\") {\n        // We got a superscript start\n        if (superscript) {\n          throw new src_ParseError(\"Double superscript\", lex);\n        }\n\n        superscript = this.handleSupSubscript(\"superscript\");\n      } else if (lex.text === \"_\") {\n        // We got a subscript start\n        if (subscript) {\n          throw new src_ParseError(\"Double subscript\", lex);\n        }\n\n        subscript = this.handleSupSubscript(\"subscript\");\n      } else if (lex.text === \"'\") {\n        // We got a prime\n        if (superscript) {\n          throw new src_ParseError(\"Double superscript\", lex);\n        }\n\n        var prime = {\n          type: \"textord\",\n          mode: this.mode,\n          text: \"\\\\prime\"\n        }; // Many primes can be grouped together, so we handle this here\n\n        var primes = [prime];\n        this.consume(); // Keep lexing tokens until we get something that's not a prime\n\n        while (this.fetch().text === \"'\") {\n          // For each one, add another prime to the list\n          primes.push(prime);\n          this.consume();\n        } // If there's a superscript following the primes, combine that\n        // superscript in with the primes.\n\n\n        if (this.fetch().text === \"^\") {\n          primes.push(this.handleSupSubscript(\"superscript\"));\n        } // Put everything into an ordgroup as the superscript\n\n\n        superscript = {\n          type: \"ordgroup\",\n          mode: this.mode,\n          body: primes\n        };\n      } else {\n        // If it wasn't ^, _, or ', stop parsing super/subscripts\n        break;\n      }\n    } // Base must be set if superscript or subscript are set per logic above,\n    // but need to check here for type check to pass.\n\n\n    if (superscript || subscript) {\n      // If we got either a superscript or subscript, create a supsub\n      return {\n        type: \"supsub\",\n        mode: this.mode,\n        base: base,\n        sup: superscript,\n        sub: subscript\n      };\n    } else {\n      // Otherwise return the original body\n      return base;\n    }\n  }\n  /**\n   * Parses an entire function, including its base and all of its arguments.\n   */\n  ;\n\n  _proto.parseFunction = function parseFunction(breakOnTokenText, name, // For error reporting.\n  greediness) {\n    var token = this.fetch();\n    var func = token.text;\n    var funcData = src_functions[func];\n\n    if (!funcData) {\n      return null;\n    }\n\n    this.consume(); // consume command token\n\n    if (greediness != null && funcData.greediness <= greediness) {\n      throw new src_ParseError(\"Got function '\" + func + \"' with no arguments\" + (name ? \" as \" + name : \"\"), token);\n    } else if (this.mode === \"text\" && !funcData.allowedInText) {\n      throw new src_ParseError(\"Can't use function '\" + func + \"' in text mode\", token);\n    } else if (this.mode === \"math\" && funcData.allowedInMath === false) {\n      throw new src_ParseError(\"Can't use function '\" + func + \"' in math mode\", token);\n    }\n\n    var _this$parseArguments = this.parseArguments(func, funcData),\n        args = _this$parseArguments.args,\n        optArgs = _this$parseArguments.optArgs;\n\n    return this.callFunction(func, args, optArgs, token, breakOnTokenText);\n  }\n  /**\n   * Call a function handler with a suitable context and arguments.\n   */\n  ;\n\n  _proto.callFunction = function callFunction(name, args, optArgs, token, breakOnTokenText) {\n    var context = {\n      funcName: name,\n      parser: this,\n      token: token,\n      breakOnTokenText: breakOnTokenText\n    };\n    var func = src_functions[name];\n\n    if (func && func.handler) {\n      return func.handler(context, args, optArgs);\n    } else {\n      throw new src_ParseError(\"No function handler for \" + name);\n    }\n  }\n  /**\n   * Parses the arguments of a function or environment\n   */\n  ;\n\n  _proto.parseArguments = function parseArguments(func, // Should look like \"\\name\" or \"\\begin{name}\".\n  funcData) {\n    var totalArgs = funcData.numArgs + funcData.numOptionalArgs;\n\n    if (totalArgs === 0) {\n      return {\n        args: [],\n        optArgs: []\n      };\n    }\n\n    var baseGreediness = funcData.greediness;\n    var args = [];\n    var optArgs = [];\n\n    for (var i = 0; i < totalArgs; i++) {\n      var argType = funcData.argTypes && funcData.argTypes[i];\n      var isOptional = i < funcData.numOptionalArgs; // Ignore spaces between arguments.  As the TeXbook says:\n      // \"After you have said ‘\\def\\row#1#2{...}’, you are allowed to\n      //  put spaces between the arguments (e.g., ‘\\row x n’), because\n      //  TeX doesn’t use single spaces as undelimited arguments.\"\n\n      var consumeSpaces = i > 0 && !isOptional || // Also consume leading spaces in math mode, as parseSymbol\n      // won't know what to do with them.  This can only happen with\n      // macros, e.g. \\frac\\foo\\foo where \\foo expands to a space symbol.\n      // In LaTeX, the \\foo's get treated as (blank) arguments.\n      // In KaTeX, for now, both spaces will get consumed.\n      // TODO(edemaine)\n      i === 0 && !isOptional && this.mode === \"math\";\n      var arg = this.parseGroupOfType(\"argument to '\" + func + \"'\", argType, isOptional, baseGreediness, consumeSpaces);\n\n      if (!arg) {\n        if (isOptional) {\n          optArgs.push(null);\n          continue;\n        }\n\n        throw new src_ParseError(\"Expected group after '\" + func + \"'\", this.fetch());\n      }\n\n      (isOptional ? optArgs : args).push(arg);\n    }\n\n    return {\n      args: args,\n      optArgs: optArgs\n    };\n  }\n  /**\n   * Parses a group when the mode is changing.\n   */\n  ;\n\n  _proto.parseGroupOfType = function parseGroupOfType(name, type, optional, greediness, consumeSpaces) {\n    switch (type) {\n      case \"color\":\n        if (consumeSpaces) {\n          this.consumeSpaces();\n        }\n\n        return this.parseColorGroup(optional);\n\n      case \"size\":\n        if (consumeSpaces) {\n          this.consumeSpaces();\n        }\n\n        return this.parseSizeGroup(optional);\n\n      case \"url\":\n        return this.parseUrlGroup(optional, consumeSpaces);\n\n      case \"math\":\n      case \"text\":\n        return this.parseGroup(name, optional, greediness, undefined, type, consumeSpaces);\n\n      case \"hbox\":\n        {\n          // hbox argument type wraps the argument in the equivalent of\n          // \\hbox, which is like \\text but switching to \\textstyle size.\n          var group = this.parseGroup(name, optional, greediness, undefined, \"text\", consumeSpaces);\n\n          if (!group) {\n            return group;\n          }\n\n          var styledGroup = {\n            type: \"styling\",\n            mode: group.mode,\n            body: [group],\n            style: \"text\" // simulate \\textstyle\n\n          };\n          return styledGroup;\n        }\n\n      case \"raw\":\n        {\n          if (consumeSpaces) {\n            this.consumeSpaces();\n          }\n\n          if (optional && this.fetch().text === \"{\") {\n            return null;\n          }\n\n          var token = this.parseStringGroup(\"raw\", optional, true);\n\n          if (token) {\n            return {\n              type: \"raw\",\n              mode: \"text\",\n              string: token.text\n            };\n          } else {\n            throw new src_ParseError(\"Expected raw group\", this.fetch());\n          }\n        }\n\n      case \"original\":\n      case null:\n      case undefined:\n        return this.parseGroup(name, optional, greediness, undefined, undefined, consumeSpaces);\n\n      default:\n        throw new src_ParseError(\"Unknown group type as \" + name, this.fetch());\n    }\n  }\n  /**\n   * Discard any space tokens, fetching the next non-space token.\n   */\n  ;\n\n  _proto.consumeSpaces = function consumeSpaces() {\n    while (this.fetch().text === \" \") {\n      this.consume();\n    }\n  }\n  /**\n   * Parses a group, essentially returning the string formed by the\n   * brace-enclosed tokens plus some position information.\n   */\n  ;\n\n  _proto.parseStringGroup = function parseStringGroup(modeName, // Used to describe the mode in error messages.\n  optional, raw) {\n    var groupBegin = optional ? \"[\" : \"{\";\n    var groupEnd = optional ? \"]\" : \"}\";\n    var beginToken = this.fetch();\n\n    if (beginToken.text !== groupBegin) {\n      if (optional) {\n        return null;\n      } else if (raw && beginToken.text !== \"EOF\" && /[^{}[\\]]/.test(beginToken.text)) {\n        this.consume();\n        return beginToken;\n      }\n    }\n\n    var outerMode = this.mode;\n    this.mode = \"text\";\n    this.expect(groupBegin);\n    var str = \"\";\n    var firstToken = this.fetch();\n    var nested = 0; // allow nested braces in raw string group\n\n    var lastToken = firstToken;\n    var nextToken;\n\n    while ((nextToken = this.fetch()).text !== groupEnd || raw && nested > 0) {\n      switch (nextToken.text) {\n        case \"EOF\":\n          throw new src_ParseError(\"Unexpected end of input in \" + modeName, firstToken.range(lastToken, str));\n\n        case groupBegin:\n          nested++;\n          break;\n\n        case groupEnd:\n          nested--;\n          break;\n      }\n\n      lastToken = nextToken;\n      str += lastToken.text;\n      this.consume();\n    }\n\n    this.expect(groupEnd);\n    this.mode = outerMode;\n    return firstToken.range(lastToken, str);\n  }\n  /**\n   * Parses a regex-delimited group: the largest sequence of tokens\n   * whose concatenated strings match `regex`. Returns the string\n   * formed by the tokens plus some position information.\n   */\n  ;\n\n  _proto.parseRegexGroup = function parseRegexGroup(regex, modeName) {\n    var outerMode = this.mode;\n    this.mode = \"text\";\n    var firstToken = this.fetch();\n    var lastToken = firstToken;\n    var str = \"\";\n    var nextToken;\n\n    while ((nextToken = this.fetch()).text !== \"EOF\" && regex.test(str + nextToken.text)) {\n      lastToken = nextToken;\n      str += lastToken.text;\n      this.consume();\n    }\n\n    if (str === \"\") {\n      throw new src_ParseError(\"Invalid \" + modeName + \": '\" + firstToken.text + \"'\", firstToken);\n    }\n\n    this.mode = outerMode;\n    return firstToken.range(lastToken, str);\n  }\n  /**\n   * Parses a color description.\n   */\n  ;\n\n  _proto.parseColorGroup = function parseColorGroup(optional) {\n    var res = this.parseStringGroup(\"color\", optional);\n\n    if (!res) {\n      return null;\n    }\n\n    var match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);\n\n    if (!match) {\n      throw new src_ParseError(\"Invalid color: '\" + res.text + \"'\", res);\n    }\n\n    var color = match[0];\n\n    if (/^[0-9a-f]{6}$/i.test(color)) {\n      // We allow a 6-digit HTML color spec without a leading \"#\".\n      // This follows the xcolor package's HTML color model.\n      // Predefined color names are all missed by this RegEx pattern.\n      color = \"#\" + color;\n    }\n\n    return {\n      type: \"color-token\",\n      mode: this.mode,\n      color: color\n    };\n  }\n  /**\n   * Parses a size specification, consisting of magnitude and unit.\n   */\n  ;\n\n  _proto.parseSizeGroup = function parseSizeGroup(optional) {\n    var res;\n    var isBlank = false;\n\n    if (!optional && this.fetch().text !== \"{\") {\n      res = this.parseRegexGroup(/^[-+]? *(?:$|\\d+|\\d+\\.\\d*|\\.\\d*) *[a-z]{0,2} *$/, \"size\");\n    } else {\n      res = this.parseStringGroup(\"size\", optional);\n    }\n\n    if (!res) {\n      return null;\n    }\n\n    if (!optional && res.text.length === 0) {\n      // Because we've tested for what is !optional, this block won't\n      // affect \\kern, \\hspace, etc. It will capture the mandatory arguments\n      // to \\genfrac and \\above.\n      res.text = \"0pt\"; // Enable \\above{}\n\n      isBlank = true; // This is here specifically for \\genfrac\n    }\n\n    var match = /([-+]?) *(\\d+(?:\\.\\d*)?|\\.\\d+) *([a-z]{2})/.exec(res.text);\n\n    if (!match) {\n      throw new src_ParseError(\"Invalid size: '\" + res.text + \"'\", res);\n    }\n\n    var data = {\n      number: +(match[1] + match[2]),\n      // sign + magnitude, cast to number\n      unit: match[3]\n    };\n\n    if (!validUnit(data)) {\n      throw new src_ParseError(\"Invalid unit: '\" + data.unit + \"'\", res);\n    }\n\n    return {\n      type: \"size\",\n      mode: this.mode,\n      value: data,\n      isBlank: isBlank\n    };\n  }\n  /**\n   * Parses an URL, checking escaped letters and allowed protocols,\n   * and setting the catcode of % as an active character (as in \\hyperref).\n   */\n  ;\n\n  _proto.parseUrlGroup = function parseUrlGroup(optional, consumeSpaces) {\n    this.gullet.lexer.setCatcode(\"%\", 13); // active character\n\n    var res = this.parseStringGroup(\"url\", optional, true); // get raw string\n\n    this.gullet.lexer.setCatcode(\"%\", 14); // comment character\n\n    if (!res) {\n      return null;\n    } // hyperref package allows backslashes alone in href, but doesn't\n    // generate valid links in such cases; we interpret this as\n    // \"undefined\" behaviour, and keep them as-is. Some browser will\n    // replace backslashes with forward slashes.\n\n\n    var url = res.text.replace(/\\\\([#$%&~_^{}])/g, '$1');\n    return {\n      type: \"url\",\n      mode: this.mode,\n      url: url\n    };\n  }\n  /**\n   * If `optional` is false or absent, this parses an ordinary group,\n   * which is either a single nucleus (like \"x\") or an expression\n   * in braces (like \"{x+y}\") or an implicit group, a group that starts\n   * at the current position, and ends right before a higher explicit\n   * group ends, or at EOF.\n   * If `optional` is true, it parses either a bracket-delimited expression\n   * (like \"[x+y]\") or returns null to indicate the absence of a\n   * bracket-enclosed group.\n   * If `mode` is present, switches to that mode while parsing the group,\n   * and switches back after.\n   */\n  ;\n\n  _proto.parseGroup = function parseGroup(name, // For error reporting.\n  optional, greediness, breakOnTokenText, mode, consumeSpaces) {\n    // Switch to specified mode\n    var outerMode = this.mode;\n\n    if (mode) {\n      this.switchMode(mode);\n    } // Consume spaces if requested, crucially *after* we switch modes,\n    // so that the next non-space token is parsed in the correct mode.\n\n\n    if (consumeSpaces) {\n      this.consumeSpaces();\n    } // Get first token\n\n\n    var firstToken = this.fetch();\n    var text = firstToken.text;\n    var result; // Try to parse an open brace or \\begingroup\n\n    if (optional ? text === \"[\" : text === \"{\" || text === \"\\\\begingroup\") {\n      this.consume();\n      var groupEnd = Parser.endOfGroup[text]; // Start a new group namespace\n\n      this.gullet.beginGroup(); // If we get a brace, parse an expression\n\n      var expression = this.parseExpression(false, groupEnd);\n      var lastToken = this.fetch(); // Check that we got a matching closing brace\n\n      this.expect(groupEnd); // End group namespace\n\n      this.gullet.endGroup();\n      result = {\n        type: \"ordgroup\",\n        mode: this.mode,\n        loc: SourceLocation.range(firstToken, lastToken),\n        body: expression,\n        // A group formed by \\begingroup...\\endgroup is a semi-simple group\n        // which doesn't affect spacing in math mode, i.e., is transparent.\n        // https://tex.stackexchange.com/questions/1930/when-should-one-\n        // use-begingroup-instead-of-bgroup\n        semisimple: text === \"\\\\begingroup\" || undefined\n      };\n    } else if (optional) {\n      // Return nothing for an optional group\n      result = null;\n    } else {\n      // If there exists a function with this name, parse the function.\n      // Otherwise, just return a nucleus\n      result = this.parseFunction(breakOnTokenText, name, greediness) || this.parseSymbol();\n\n      if (result == null && text[0] === \"\\\\\" && !implicitCommands.hasOwnProperty(text)) {\n        if (this.settings.throwOnError) {\n          throw new src_ParseError(\"Undefined control sequence: \" + text, firstToken);\n        }\n\n        result = this.formatUnsupportedCmd(text);\n        this.consume();\n      }\n    } // Switch mode back\n\n\n    if (mode) {\n      this.switchMode(outerMode);\n    }\n\n    return result;\n  }\n  /**\n   * Form ligature-like combinations of characters for text mode.\n   * This includes inputs like \"--\", \"---\", \"``\" and \"''\".\n   * The result will simply replace multiple textord nodes with a single\n   * character in each value by a single textord node having multiple\n   * characters in its value.  The representation is still ASCII source.\n   * The group will be modified in place.\n   */\n  ;\n\n  _proto.formLigatures = function formLigatures(group) {\n    var n = group.length - 1;\n\n    for (var i = 0; i < n; ++i) {\n      var a = group[i]; // $FlowFixMe: Not every node type has a `text` property.\n\n      var v = a.text;\n\n      if (v === \"-\" && group[i + 1].text === \"-\") {\n        if (i + 1 < n && group[i + 2].text === \"-\") {\n          group.splice(i, 3, {\n            type: \"textord\",\n            mode: \"text\",\n            loc: SourceLocation.range(a, group[i + 2]),\n            text: \"---\"\n          });\n          n -= 2;\n        } else {\n          group.splice(i, 2, {\n            type: \"textord\",\n            mode: \"text\",\n            loc: SourceLocation.range(a, group[i + 1]),\n            text: \"--\"\n          });\n          n -= 1;\n        }\n      }\n\n      if ((v === \"'\" || v === \"`\") && group[i + 1].text === v) {\n        group.splice(i, 2, {\n          type: \"textord\",\n          mode: \"text\",\n          loc: SourceLocation.range(a, group[i + 1]),\n          text: v + v\n        });\n        n -= 1;\n      }\n    }\n  }\n  /**\n   * Parse a single symbol out of the string. Here, we handle single character\n   * symbols and special functions like \\verb.\n   */\n  ;\n\n  _proto.parseSymbol = function parseSymbol() {\n    var nucleus = this.fetch();\n    var text = nucleus.text;\n\n    if (/^\\\\verb[^a-zA-Z]/.test(text)) {\n      this.consume();\n      var arg = text.slice(5);\n      var star = arg.charAt(0) === \"*\";\n\n      if (star) {\n        arg = arg.slice(1);\n      } // Lexer's tokenRegex is constructed to always have matching\n      // first/last characters.\n\n\n      if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {\n        throw new src_ParseError(\"\\\\verb assertion failed --\\n                    please report what input caused this bug\");\n      }\n\n      arg = arg.slice(1, -1); // remove first and last char\n\n      return {\n        type: \"verb\",\n        mode: \"text\",\n        body: arg,\n        star: star\n      };\n    } // At this point, we should have a symbol, possibly with accents.\n    // First expand any accented base symbol according to unicodeSymbols.\n\n\n    if (unicodeSymbols.hasOwnProperty(text[0]) && !src_symbols[this.mode][text[0]]) {\n      // This behavior is not strict (XeTeX-compatible) in math mode.\n      if (this.settings.strict && this.mode === \"math\") {\n        this.settings.reportNonstrict(\"unicodeTextInMathMode\", \"Accented Unicode text character \\\"\" + text[0] + \"\\\" used in \" + \"math mode\", nucleus);\n      }\n\n      text = unicodeSymbols[text[0]] + text.substr(1);\n    } // Strip off any combining characters\n\n\n    var match = combiningDiacriticalMarksEndRegex.exec(text);\n\n    if (match) {\n      text = text.substring(0, match.index);\n\n      if (text === 'i') {\n        text = \"\\u0131\"; // dotless i, in math and text mode\n      } else if (text === 'j') {\n        text = \"\\u0237\"; // dotless j, in math and text mode\n      }\n    } // Recognize base symbol\n\n\n    var symbol;\n\n    if (src_symbols[this.mode][text]) {\n      if (this.settings.strict && this.mode === 'math' && extraLatin.indexOf(text) >= 0) {\n        this.settings.reportNonstrict(\"unicodeTextInMathMode\", \"Latin-1/Unicode text character \\\"\" + text[0] + \"\\\" used in \" + \"math mode\", nucleus);\n      }\n\n      var group = src_symbols[this.mode][text].group;\n      var loc = SourceLocation.range(nucleus);\n      var s;\n\n      if (ATOMS.hasOwnProperty(group)) {\n        // $FlowFixMe\n        var family = group;\n        s = {\n          type: \"atom\",\n          mode: this.mode,\n          family: family,\n          loc: loc,\n          text: text\n        };\n      } else {\n        // $FlowFixMe\n        s = {\n          type: group,\n          mode: this.mode,\n          loc: loc,\n          text: text\n        };\n      }\n\n      symbol = s;\n    } else if (text.charCodeAt(0) >= 0x80) {\n      // no symbol for e.g. ^\n      if (this.settings.strict) {\n        if (!supportedCodepoint(text.charCodeAt(0))) {\n          this.settings.reportNonstrict(\"unknownSymbol\", \"Unrecognized Unicode character \\\"\" + text[0] + \"\\\"\" + (\" (\" + text.charCodeAt(0) + \")\"), nucleus);\n        } else if (this.mode === \"math\") {\n          this.settings.reportNonstrict(\"unicodeTextInMathMode\", \"Unicode text character \\\"\" + text[0] + \"\\\" used in math mode\", nucleus);\n        }\n      } // All nonmathematical Unicode characters are rendered as if they\n      // are in text mode (wrapped in \\text) because that's what it\n      // takes to render them in LaTeX.  Setting `mode: this.mode` is\n      // another natural choice (the user requested math mode), but\n      // this makes it more difficult for getCharacterMetrics() to\n      // distinguish Unicode characters without metrics and those for\n      // which we want to simulate the letter M.\n\n\n      symbol = {\n        type: \"textord\",\n        mode: \"text\",\n        loc: SourceLocation.range(nucleus),\n        text: text\n      };\n    } else {\n      return null; // EOF, ^, _, {, }, etc.\n    }\n\n    this.consume(); // Transform combining characters into accents\n\n    if (match) {\n      for (var i = 0; i < match[0].length; i++) {\n        var accent = match[0][i];\n\n        if (!unicodeAccents[accent]) {\n          throw new src_ParseError(\"Unknown accent ' \" + accent + \"'\", nucleus);\n        }\n\n        var command = unicodeAccents[accent][this.mode];\n\n        if (!command) {\n          throw new src_ParseError(\"Accent \" + accent + \" unsupported in \" + this.mode + \" mode\", nucleus);\n        }\n\n        symbol = {\n          type: \"accent\",\n          mode: this.mode,\n          loc: SourceLocation.range(nucleus),\n          label: command,\n          isStretchy: false,\n          isShifty: true,\n          base: symbol\n        };\n      }\n    }\n\n    return symbol;\n  };\n\n  return Parser;\n}();\n\nParser_Parser.endOfExpression = [\"}\", \"\\\\endgroup\", \"\\\\end\", \"\\\\right\", \"&\"];\nParser_Parser.endOfGroup = {\n  \"[\": \"]\",\n  \"{\": \"}\",\n  \"\\\\begingroup\": \"\\\\endgroup\"\n  /**\n   * Parses an \"expression\", which is a list of atoms.\n   *\n   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This\n   *                 happens when functions have higher precendence han infix\n   *                 nodes in implicit parses.\n   *\n   * `breakOnTokenText`: The text of the token that the expression should end\n   *                     with, or `null` if something else should end the\n   *                     expression.\n   */\n\n};\nParser_Parser.SUPSUB_GREEDINESS = 1;\n\n// CONCATENATED MODULE: ./src/parseTree.js\n/**\n * Provides a single function for parsing an expression using a Parser\n * TODO(emily): Remove this\n */\n\n\n\n/**\n * Parses an expression using a Parser, then returns the parsed result.\n */\nvar parseTree_parseTree = function parseTree(toParse, settings) {\n  if (!(typeof toParse === 'string' || toParse instanceof String)) {\n    throw new TypeError('KaTeX can only parse string typed expression');\n  }\n\n  var parser = new Parser_Parser(toParse, settings); // Blank out any \\df@tag to avoid spurious \"Duplicate \\tag\" errors\n\n  delete parser.gullet.macros.current[\"\\\\df@tag\"];\n  var tree = parser.parse(); // If the input used \\tag, it will set the \\df@tag macro to the tag.\n  // In this case, we separately parse the tag and wrap the tree.\n\n  if (parser.gullet.macros.get(\"\\\\df@tag\")) {\n    if (!settings.displayMode) {\n      throw new src_ParseError(\"\\\\tag works only in display equations\");\n    }\n\n    parser.gullet.feed(\"\\\\df@tag\");\n    tree = [{\n      type: \"tag\",\n      mode: \"text\",\n      body: tree,\n      tag: parser.parse()\n    }];\n  }\n\n  return tree;\n};\n\n/* harmony default export */ var src_parseTree = (parseTree_parseTree);\n// CONCATENATED MODULE: ./katex.js\n/* eslint no-console:0 */\n\n/**\n * This is the main entry point for KaTeX. Here, we expose functions for\n * rendering expressions either to DOM nodes or to markup strings.\n *\n * We also expose the ParseError class to check if errors thrown from KaTeX are\n * errors in the expression, or errors in javascript handling.\n */\n\n\n\n\n\n\n\n\n\n\n/**\n * Parse and build an expression, and place that expression in the DOM node\n * given.\n */\nvar katex_render = function render(expression, baseNode, options) {\n  baseNode.textContent = \"\";\n  var node = katex_renderToDomTree(expression, options).toNode();\n  baseNode.appendChild(node);\n}; // KaTeX's styles don't work properly in quirks mode. Print out an error, and\n// disable rendering.\n\n\nif (typeof document !== \"undefined\") {\n  if (document.compatMode !== \"CSS1Compat\") {\n    typeof console !== \"undefined\" && console.warn(\"Warning: KaTeX doesn't work in quirks mode. Make sure your \" + \"website has a suitable doctype.\");\n\n    katex_render = function render() {\n      throw new src_ParseError(\"KaTeX doesn't work in quirks mode.\");\n    };\n  }\n}\n/**\n * Parse and build an expression, and return the markup for that.\n */\n\n\nvar renderToString = function renderToString(expression, options) {\n  var markup = katex_renderToDomTree(expression, options).toMarkup();\n  return markup;\n};\n/**\n * Parse an expression and return the parse tree.\n */\n\n\nvar katex_generateParseTree = function generateParseTree(expression, options) {\n  var settings = new Settings_Settings(options);\n  return src_parseTree(expression, settings);\n};\n/**\n * If the given error is a KaTeX ParseError and options.throwOnError is false,\n * renders the invalid LaTeX as a span with hover title giving the KaTeX\n * error message.  Otherwise, simply throws the error.\n */\n\n\nvar katex_renderError = function renderError(error, expression, options) {\n  if (options.throwOnError || !(error instanceof src_ParseError)) {\n    throw error;\n  }\n\n  var node = buildCommon.makeSpan([\"katex-error\"], [new domTree_SymbolNode(expression)]);\n  node.setAttribute(\"title\", error.toString());\n  node.setAttribute(\"style\", \"color:\" + options.errorColor);\n  return node;\n};\n/**\n * Generates and returns the katex build tree. This is used for advanced\n * use cases (like rendering to custom output).\n */\n\n\nvar katex_renderToDomTree = function renderToDomTree(expression, options) {\n  var settings = new Settings_Settings(options);\n\n  try {\n    var tree = src_parseTree(expression, settings);\n    return buildTree_buildTree(tree, expression, settings);\n  } catch (error) {\n    return katex_renderError(error, expression, settings);\n  }\n};\n/**\n * Generates and returns the katex build tree, with just HTML (no MathML).\n * This is used for advanced use cases (like rendering to custom output).\n */\n\n\nvar katex_renderToHTMLTree = function renderToHTMLTree(expression, options) {\n  var settings = new Settings_Settings(options);\n\n  try {\n    var tree = src_parseTree(expression, settings);\n    return buildTree_buildHTMLTree(tree, expression, settings);\n  } catch (error) {\n    return katex_renderError(error, expression, settings);\n  }\n};\n\n/* harmony default export */ var katex_0 = ({\n  /**\n   * Current KaTeX version\n   */\n  version: \"0.11.1\",\n\n  /**\n   * Renders the given LaTeX into an HTML+MathML combination, and adds\n   * it as a child to the specified DOM node.\n   */\n  render: katex_render,\n\n  /**\n   * Renders the given LaTeX into an HTML+MathML combination string,\n   * for sending to the client.\n   */\n  renderToString: renderToString,\n\n  /**\n   * KaTeX error, usually during parsing.\n   */\n  ParseError: src_ParseError,\n\n  /**\n   * Parses the given LaTeX into KaTeX's internal parse tree structure,\n   * without rendering to HTML or MathML.\n   *\n   * NOTE: This method is not currently recommended for public use.\n   * The internal tree representation is unstable and is very likely\n   * to change. Use at your own risk.\n   */\n  __parse: katex_generateParseTree,\n\n  /**\n   * Renders the given LaTeX into an HTML+MathML internal DOM tree\n   * representation, without flattening that representation to a string.\n   *\n   * NOTE: This method is not currently recommended for public use.\n   * The internal tree representation is unstable and is very likely\n   * to change. Use at your own risk.\n   */\n  __renderToDomTree: katex_renderToDomTree,\n\n  /**\n   * Renders the given LaTeX into an HTML internal DOM tree representation,\n   * without MathML and without flattening that representation to a string.\n   *\n   * NOTE: This method is not currently recommended for public use.\n   * The internal tree representation is unstable and is very likely\n   * to change. Use at your own risk.\n   */\n  __renderToHTMLTree: katex_renderToHTMLTree,\n\n  /**\n   * extends internal font metrics object with a new object\n   * each key in the new object represents a font name\n  */\n  __setFontMetrics: setFontMetrics,\n\n  /**\n   * adds a new symbol to builtin symbols table\n   */\n  __defineSymbol: defineSymbol,\n\n  /**\n   * adds a new macro to builtin macro list\n   */\n  __defineMacro: defineMacro,\n\n  /**\n   * Expose the dom tree node types, which can be useful for type checking nodes.\n   *\n   * NOTE: This method is not currently recommended for public use.\n   * The internal tree representation is unstable and is very likely\n   * to change. Use at your own risk.\n   */\n  __domTree: {\n    Span: domTree_Span,\n    Anchor: domTree_Anchor,\n    SymbolNode: domTree_SymbolNode,\n    SvgNode: SvgNode,\n    PathNode: domTree_PathNode,\n    LineNode: LineNode\n  }\n});\n// CONCATENATED MODULE: ./katex.webpack.js\n/**\n * This is the webpack entry point for KaTeX. As ECMAScript, flow[1] and jest[2]\n * doesn't support CSS modules natively, a separate entry point is used and\n * it is not flowtyped.\n *\n * [1] https://gist.github.com/lambdahands/d19e0da96285b749f0ef\n * [2] https://facebook.github.io/jest/docs/en/webpack.html\n */\n\n\n/* harmony default export */ var katex_webpack = __webpack_exports__[\"default\"] = (katex_0);\n\n/***/ })\n/******/ ])[\"default\"];\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicjBGci5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaWt0YWthaGlyby9tYXJrZG93bi1pdC1rYXRleC9ub2RlX21vZHVsZXMva2F0ZXgvZGlzdC9rYXRleC5qcz9hZjQxIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImthdGV4XCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImthdGV4XCJdID0gZmFjdG9yeSgpO1xufSkoKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzKSwgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9rYXRleC5sZXNzXG52YXIga2F0ZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9Tb3VyY2VMb2NhdGlvbi5qc1xuLyoqXG4gKiBMZXhpbmcgb3IgcGFyc2luZyBwb3NpdGlvbmFsIGluZm9ybWF0aW9uIGZvciBlcnJvciByZXBvcnRpbmcuXG4gKiBUaGlzIG9iamVjdCBpcyBpbW11dGFibGUuXG4gKi9cbnZhciBTb3VyY2VMb2NhdGlvbiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8vIFRoZSArIHByZWZpeCBpbmRpY2F0ZXMgdGhhdCB0aGVzZSBmaWVsZHMgYXJlbid0IHdyaXRlYWJsZVxuICAvLyBMZXhlciBob2xkaW5nIHRoZSBpbnB1dCBzdHJpbmcuXG4gIC8vIFN0YXJ0IG9mZnNldCwgemVyby1iYXNlZCBpbmNsdXNpdmUuXG4gIC8vIEVuZCBvZmZzZXQsIHplcm8tYmFzZWQgZXhjbHVzaXZlLlxuICBmdW5jdGlvbiBTb3VyY2VMb2NhdGlvbihsZXhlciwgc3RhcnQsIGVuZCkge1xuICAgIHRoaXMubGV4ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFydCA9IHZvaWQgMDtcbiAgICB0aGlzLmVuZCA9IHZvaWQgMDtcbiAgICB0aGlzLmxleGVyID0gbGV4ZXI7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kO1xuICB9XG4gIC8qKlxuICAgKiBNZXJnZXMgdHdvIGBTb3VyY2VMb2NhdGlvbmBzIGZyb20gbG9jYXRpb24gcHJvdmlkZXJzLCBnaXZlbiB0aGV5IGFyZVxuICAgKiBwcm92aWRlZCBpbiBvcmRlciBvZiBhcHBlYXJhbmNlLlxuICAgKiAtIFJldHVybnMgdGhlIGZpcnN0IG9uZSdzIGxvY2F0aW9uIGlmIG9ubHkgdGhlIGZpcnN0IGlzIHByb3ZpZGVkLlxuICAgKiAtIFJldHVybnMgYSBtZXJnZWQgcmFuZ2Ugb2YgdGhlIGZpcnN0IGFuZCB0aGUgbGFzdCBpZiBib3RoIGFyZSBwcm92aWRlZFxuICAgKiAgIGFuZCB0aGVpciBsZXhlcnMgbWF0Y2guXG4gICAqIC0gT3RoZXJ3aXNlLCByZXR1cm5zIG51bGwuXG4gICAqL1xuXG5cbiAgU291cmNlTG9jYXRpb24ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZShmaXJzdCwgc2Vjb25kKSB7XG4gICAgaWYgKCFzZWNvbmQpIHtcbiAgICAgIHJldHVybiBmaXJzdCAmJiBmaXJzdC5sb2M7XG4gICAgfSBlbHNlIGlmICghZmlyc3QgfHwgIWZpcnN0LmxvYyB8fCAhc2Vjb25kLmxvYyB8fCBmaXJzdC5sb2MubGV4ZXIgIT09IHNlY29uZC5sb2MubGV4ZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFNvdXJjZUxvY2F0aW9uKGZpcnN0LmxvYy5sZXhlciwgZmlyc3QubG9jLnN0YXJ0LCBzZWNvbmQubG9jLmVuZCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBTb3VyY2VMb2NhdGlvbjtcbn0oKTtcblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9Ub2tlbi5qc1xuXG4vKipcbiAqIEludGVyZmFjZSByZXF1aXJlZCB0byBicmVhayBjaXJjdWxhciBkZXBlbmRlbmN5IGJldHdlZW4gVG9rZW4sIExleGVyLCBhbmRcbiAqIFBhcnNlRXJyb3IuXG4gKi9cblxuLyoqXG4gKiBUaGUgcmVzdWx0aW5nIHRva2VuIHJldHVybmVkIGZyb20gYGxleGAuXG4gKlxuICogSXQgY29uc2lzdHMgb2YgdGhlIHRva2VuIHRleHQgcGx1cyBzb21lIHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICogVGhlIHBvc2l0aW9uIGluZm9ybWF0aW9uIGlzIGVzc2VudGlhbGx5IGEgcmFuZ2UgaW4gYW4gaW5wdXQgc3RyaW5nLFxuICogYnV0IGluc3RlYWQgb2YgcmVmZXJlbmNpbmcgdGhlIGJhcmUgaW5wdXQgc3RyaW5nLCB3ZSByZWZlciB0byB0aGUgbGV4ZXIuXG4gKiBUaGF0IHdheSBpdCBpcyBwb3NzaWJsZSB0byBhdHRhY2ggZXh0cmEgbWV0YWRhdGEgdG8gdGhlIGlucHV0IHN0cmluZyxcbiAqIGxpa2UgZm9yIGV4YW1wbGUgYSBmaWxlIG5hbWUgb3Igc2ltaWxhci5cbiAqXG4gKiBUaGUgcG9zaXRpb24gaW5mb3JtYXRpb24gaXMgb3B0aW9uYWwsIHNvIGl0IGlzIE9LIHRvIGNvbnN0cnVjdCBzeW50aGV0aWNcbiAqIHRva2VucyBpZiBhcHByb3ByaWF0ZS4gTm90IHByb3ZpZGluZyBhdmFpbGFibGUgcG9zaXRpb24gaW5mb3JtYXRpb24gbWF5XG4gKiBsZWFkIHRvIGRlZ3JhZGVkIGVycm9yIHJlcG9ydGluZywgdGhvdWdoLlxuICovXG52YXIgVG9rZW5fVG9rZW4gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUb2tlbih0ZXh0LCAvLyB0aGUgdGV4dCBvZiB0aGlzIHRva2VuXG4gIGxvYykge1xuICAgIHRoaXMudGV4dCA9IHZvaWQgMDtcbiAgICB0aGlzLmxvYyA9IHZvaWQgMDtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMubG9jID0gbG9jO1xuICB9XG4gIC8qKlxuICAgKiBHaXZlbiBhIHBhaXIgb2YgdG9rZW5zICh0aGlzIGFuZCBlbmRUb2tlbiksIGNvbXB1dGUgYSBgVG9rZW5gIGVuY29tcGFzc2luZ1xuICAgKiB0aGUgd2hvbGUgaW5wdXQgcmFuZ2UgZW5jbG9zZWQgYnkgdGhlc2UgdHdvLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBUb2tlbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJhbmdlID0gZnVuY3Rpb24gcmFuZ2UoZW5kVG9rZW4sIC8vIGxhc3QgdG9rZW4gb2YgdGhlIHJhbmdlLCBpbmNsdXNpdmVcbiAgdGV4dCkgLy8gdGhlIHRleHQgb2YgdGhlIG5ld2x5IGNvbnN0cnVjdGVkIHRva2VuXG4gIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKHRleHQsIFNvdXJjZUxvY2F0aW9uLnJhbmdlKHRoaXMsIGVuZFRva2VuKSk7XG4gIH07XG5cbiAgcmV0dXJuIFRva2VuO1xufSgpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvUGFyc2VFcnJvci5qc1xuXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgUGFyc2VFcnJvciBjbGFzcywgd2hpY2ggaXMgdGhlIG1haW4gZXJyb3IgdGhyb3duIGJ5IEthVGVYXG4gKiBmdW5jdGlvbnMgd2hlbiBzb21ldGhpbmcgaGFzIGdvbmUgd3JvbmcuIFRoaXMgaXMgdXNlZCB0byBkaXN0aW5ndWlzaCBpbnRlcm5hbFxuICogZXJyb3JzIGZyb20gZXJyb3JzIGluIHRoZSBleHByZXNzaW9uIHRoYXQgdGhlIHVzZXIgcHJvdmlkZWQuXG4gKlxuICogSWYgcG9zc2libGUsIGEgY2FsbGVyIHNob3VsZCBwcm92aWRlIGEgVG9rZW4gb3IgUGFyc2VOb2RlIHdpdGggaW5mb3JtYXRpb25cbiAqIGFib3V0IHdoZXJlIGluIHRoZSBzb3VyY2Ugc3RyaW5nIHRoZSBwcm9ibGVtIG9jY3VycmVkLlxuICovXG52YXIgUGFyc2VFcnJvciA9IC8vIEVycm9yIHBvc2l0aW9uIGJhc2VkIG9uIHBhc3NlZC1pbiBUb2tlbiBvciBQYXJzZU5vZGUuXG5mdW5jdGlvbiBQYXJzZUVycm9yKG1lc3NhZ2UsIC8vIFRoZSBlcnJvciBtZXNzYWdlXG50b2tlbikgLy8gQW4gb2JqZWN0IHByb3ZpZGluZyBwb3NpdGlvbiBpbmZvcm1hdGlvblxue1xuICB0aGlzLnBvc2l0aW9uID0gdm9pZCAwO1xuICB2YXIgZXJyb3IgPSBcIkthVGVYIHBhcnNlIGVycm9yOiBcIiArIG1lc3NhZ2U7XG4gIHZhciBzdGFydDtcbiAgdmFyIGxvYyA9IHRva2VuICYmIHRva2VuLmxvYztcblxuICBpZiAobG9jICYmIGxvYy5zdGFydCA8PSBsb2MuZW5kKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSB0aGUgaW5wdXQgYW5kIGEgcG9zaXRpb24sIG1ha2UgdGhlIGVycm9yIGEgYml0IGZhbmNpZXJcbiAgICAvLyBHZXQgdGhlIGlucHV0XG4gICAgdmFyIGlucHV0ID0gbG9jLmxleGVyLmlucHV0OyAvLyBQcmVwZW5kIHNvbWUgaW5mb3JtYXRpb25cblxuICAgIHN0YXJ0ID0gbG9jLnN0YXJ0O1xuICAgIHZhciBlbmQgPSBsb2MuZW5kO1xuXG4gICAgaWYgKHN0YXJ0ID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIGVycm9yICs9IFwiIGF0IGVuZCBvZiBpbnB1dDogXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yICs9IFwiIGF0IHBvc2l0aW9uIFwiICsgKHN0YXJ0ICsgMSkgKyBcIjogXCI7XG4gICAgfSAvLyBVbmRlcmxpbmUgdG9rZW4gaW4gcXVlc3Rpb24gdXNpbmcgY29tYmluaW5nIHVuZGVyc2NvcmVzXG5cblxuICAgIHZhciB1bmRlcmxpbmVkID0gaW5wdXQuc2xpY2Uoc3RhcnQsIGVuZCkucmVwbGFjZSgvW15dL2csIFwiJCZcXHUwMzMyXCIpOyAvLyBFeHRyYWN0IHNvbWUgY29udGV4dCBmcm9tIHRoZSBpbnB1dCBhbmQgYWRkIGl0IHRvIHRoZSBlcnJvclxuXG4gICAgdmFyIGxlZnQ7XG5cbiAgICBpZiAoc3RhcnQgPiAxNSkge1xuICAgICAgbGVmdCA9IFwi4oCmXCIgKyBpbnB1dC5zbGljZShzdGFydCAtIDE1LCBzdGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSBpbnB1dC5zbGljZSgwLCBzdGFydCk7XG4gICAgfVxuXG4gICAgdmFyIHJpZ2h0O1xuXG4gICAgaWYgKGVuZCArIDE1IDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICByaWdodCA9IGlucHV0LnNsaWNlKGVuZCwgZW5kICsgMTUpICsgXCLigKZcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmlnaHQgPSBpbnB1dC5zbGljZShlbmQpO1xuICAgIH1cblxuICAgIGVycm9yICs9IGxlZnQgKyB1bmRlcmxpbmVkICsgcmlnaHQ7XG4gIH0gLy8gU29tZSBoYWNrZXJ5IHRvIG1ha2UgUGFyc2VFcnJvciBhIHByb3RvdHlwZSBvZiBFcnJvclxuICAvLyBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODQ2MDc1M1xuXG5cbiAgdmFyIHNlbGYgPSBuZXcgRXJyb3IoZXJyb3IpO1xuICBzZWxmLm5hbWUgPSBcIlBhcnNlRXJyb3JcIjsgLy8gJEZsb3dGaXhNZVxuXG4gIHNlbGYuX19wcm90b19fID0gUGFyc2VFcnJvci5wcm90b3R5cGU7IC8vICRGbG93Rml4TWVcblxuICBzZWxmLnBvc2l0aW9uID0gc3RhcnQ7XG4gIHJldHVybiBzZWxmO1xufTsgLy8gJEZsb3dGaXhNZSBNb3JlIGhhY2tlcnlcblxuXG5QYXJzZUVycm9yLnByb3RvdHlwZS5fX3Byb3RvX18gPSBFcnJvci5wcm90b3R5cGU7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfUGFyc2VFcnJvciA9IChQYXJzZUVycm9yKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWxzLmpzXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBhIGxpc3Qgb2YgdXRpbGl0eSBmdW5jdGlvbnMgd2hpY2ggYXJlIHVzZWZ1bCBpbiBvdGhlclxuICogZmlsZXMuXG4gKi9cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBhbiBlbGVtZW50IGlzIGNvbnRhaW5lZCBpbiBhIGxpc3RcbiAqL1xudmFyIGNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMobGlzdCwgZWxlbSkge1xuICByZXR1cm4gbGlzdC5pbmRleE9mKGVsZW0pICE9PSAtMTtcbn07XG4vKipcbiAqIFByb3ZpZGUgYSBkZWZhdWx0IHZhbHVlIGlmIGEgc2V0dGluZyBpcyB1bmRlZmluZWRcbiAqIE5PVEU6IENvdWxkbid0IHVzZSBgVGAgYXMgdGhlIG91dHB1dCB0eXBlIGR1ZSB0byBmYWNlYm9vay9mbG93IzUwMjIuXG4gKi9cblxuXG52YXIgZGVmbHQgPSBmdW5jdGlvbiBkZWZsdChzZXR0aW5nLCBkZWZhdWx0SWZVbmRlZmluZWQpIHtcbiAgcmV0dXJuIHNldHRpbmcgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRJZlVuZGVmaW5lZCA6IHNldHRpbmc7XG59OyAvLyBoeXBoZW5hdGUgYW5kIGVzY2FwZSBhZGFwdGVkIGZyb20gRmFjZWJvb2sncyBSZWFjdCB1bmRlciBBcGFjaGUgMiBsaWNlbnNlXG5cblxudmFyIHVwcGVyY2FzZSA9IC8oW0EtWl0pL2c7XG5cbnZhciBoeXBoZW5hdGUgPSBmdW5jdGlvbiBoeXBoZW5hdGUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSh1cHBlcmNhc2UsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG52YXIgRVNDQVBFX0xPT0tVUCA9IHtcbiAgXCImXCI6IFwiJmFtcDtcIixcbiAgXCI+XCI6IFwiJmd0O1wiLFxuICBcIjxcIjogXCImbHQ7XCIsXG4gIFwiXFxcIlwiOiBcIiZxdW90O1wiLFxuICBcIidcIjogXCImI3gyNztcIlxufTtcbnZhciBFU0NBUEVfUkVHRVggPSAvWyY+PFwiJ10vZztcbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKi9cblxuZnVuY3Rpb24gdXRpbHNfZXNjYXBlKHRleHQpIHtcbiAgcmV0dXJuIFN0cmluZyh0ZXh0KS5yZXBsYWNlKEVTQ0FQRV9SRUdFWCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIEVTQ0FQRV9MT09LVVBbbWF0Y2hdO1xuICB9KTtcbn1cbi8qKlxuICogU29tZXRpbWVzIHdlIHdhbnQgdG8gcHVsbCBvdXQgdGhlIGlubmVybW9zdCBlbGVtZW50IG9mIGEgZ3JvdXAuIEluIG1vc3RcbiAqIGNhc2VzLCB0aGlzIHdpbGwganVzdCBiZSB0aGUgZ3JvdXAgaXRzZWxmLCBidXQgd2hlbiBvcmRncm91cHMgYW5kIGNvbG9ycyBoYXZlXG4gKiBhIHNpbmdsZSBlbGVtZW50LCB3ZSB3YW50IHRvIHB1bGwgdGhhdCBvdXQuXG4gKi9cblxuXG52YXIgZ2V0QmFzZUVsZW0gPSBmdW5jdGlvbiBnZXRCYXNlRWxlbShncm91cCkge1xuICBpZiAoZ3JvdXAudHlwZSA9PT0gXCJvcmRncm91cFwiKSB7XG4gICAgaWYgKGdyb3VwLmJvZHkubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gZ2V0QmFzZUVsZW0oZ3JvdXAuYm9keVswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJjb2xvclwiKSB7XG4gICAgaWYgKGdyb3VwLmJvZHkubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gZ2V0QmFzZUVsZW0oZ3JvdXAuYm9keVswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJmb250XCIpIHtcbiAgICByZXR1cm4gZ2V0QmFzZUVsZW0oZ3JvdXAuYm9keSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdyb3VwO1xuICB9XG59O1xuLyoqXG4gKiBUZVhib29rIGFsZ29yaXRobXMgb2Z0ZW4gcmVmZXJlbmNlIFwiY2hhcmFjdGVyIGJveGVzXCIsIHdoaWNoIGFyZSBzaW1wbHkgZ3JvdXBzXG4gKiB3aXRoIGEgc2luZ2xlIGNoYXJhY3RlciBpbiB0aGVtLiBUbyBkZWNpZGUgaWYgc29tZXRoaW5nIGlzIGEgY2hhcmFjdGVyIGJveCxcbiAqIHdlIGZpbmQgaXRzIGlubmVybW9zdCBncm91cCwgYW5kIHNlZSBpZiBpdCBpcyBhIHNpbmdsZSBjaGFyYWN0ZXIuXG4gKi9cblxuXG52YXIgdXRpbHNfaXNDaGFyYWN0ZXJCb3ggPSBmdW5jdGlvbiBpc0NoYXJhY3RlckJveChncm91cCkge1xuICB2YXIgYmFzZUVsZW0gPSBnZXRCYXNlRWxlbShncm91cCk7IC8vIFRoZXNlIGFyZSBhbGwgdGhleSB0eXBlcyBvZiBncm91cHMgd2hpY2ggaG9sZCBzaW5nbGUgY2hhcmFjdGVyc1xuXG4gIHJldHVybiBiYXNlRWxlbS50eXBlID09PSBcIm1hdGhvcmRcIiB8fCBiYXNlRWxlbS50eXBlID09PSBcInRleHRvcmRcIiB8fCBiYXNlRWxlbS50eXBlID09PSBcImF0b21cIjtcbn07XG5cbnZhciBhc3NlcnQgPSBmdW5jdGlvbiBhc3NlcnQodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbm9uLW51bGwsIGJ1dCBnb3QgJyArIFN0cmluZyh2YWx1ZSkpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcbi8qKlxuICogUmV0dXJuIHRoZSBwcm90b2NvbCBvZiBhIFVSTCwgb3IgXCJfcmVsYXRpdmVcIiBpZiB0aGUgVVJMIGRvZXMgbm90IHNwZWNpZnkgYVxuICogcHJvdG9jb2wgKGFuZCB0aHVzIGlzIHJlbGF0aXZlKS5cbiAqL1xuXG52YXIgcHJvdG9jb2xGcm9tVXJsID0gZnVuY3Rpb24gcHJvdG9jb2xGcm9tVXJsKHVybCkge1xuICB2YXIgcHJvdG9jb2wgPSAvXlxccyooW15cXFxcLyNdKj8pKD86OnwmIzAqNTh8JiN4MCozYSkvaS5leGVjKHVybCk7XG4gIHJldHVybiBwcm90b2NvbCAhPSBudWxsID8gcHJvdG9jb2xbMV0gOiBcIl9yZWxhdGl2ZVwiO1xufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHV0aWxzID0gKHtcbiAgY29udGFpbnM6IGNvbnRhaW5zLFxuICBkZWZsdDogZGVmbHQsXG4gIGVzY2FwZTogdXRpbHNfZXNjYXBlLFxuICBoeXBoZW5hdGU6IGh5cGhlbmF0ZSxcbiAgZ2V0QmFzZUVsZW06IGdldEJhc2VFbGVtLFxuICBpc0NoYXJhY3RlckJveDogdXRpbHNfaXNDaGFyYWN0ZXJCb3gsXG4gIHByb3RvY29sRnJvbVVybDogcHJvdG9jb2xGcm9tVXJsXG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL1NldHRpbmdzLmpzXG4vKiBlc2xpbnQgbm8tY29uc29sZTowICovXG5cbi8qKlxuICogVGhpcyBpcyBhIG1vZHVsZSBmb3Igc3RvcmluZyBzZXR0aW5ncyBwYXNzZWQgaW50byBLYVRlWC4gSXQgY29ycmVjdGx5IGhhbmRsZXNcbiAqIGRlZmF1bHQgc2V0dGluZ3MuXG4gKi9cblxuXG5cblxuLyoqXG4gKiBUaGUgbWFpbiBTZXR0aW5ncyBvYmplY3RcbiAqXG4gKiBUaGUgY3VycmVudCBvcHRpb25zIHN0b3JlZCBhcmU6XG4gKiAgLSBkaXNwbGF5TW9kZTogV2hldGhlciB0aGUgZXhwcmVzc2lvbiBzaG91bGQgYmUgdHlwZXNldCBhcyBpbmxpbmUgbWF0aFxuICogICAgICAgICAgICAgICAgIChmYWxzZSwgdGhlIGRlZmF1bHQpLCBtZWFuaW5nIHRoYXQgdGhlIG1hdGggc3RhcnRzIGluXG4gKiAgICAgICAgICAgICAgICAgXFx0ZXh0c3R5bGUgYW5kIGlzIHBsYWNlZCBpbiBhbiBpbmxpbmUtYmxvY2spOyBvciBhcyBkaXNwbGF5XG4gKiAgICAgICAgICAgICAgICAgbWF0aCAodHJ1ZSksIG1lYW5pbmcgdGhhdCB0aGUgbWF0aCBzdGFydHMgaW4gXFxkaXNwbGF5c3R5bGVcbiAqICAgICAgICAgICAgICAgICBhbmQgaXMgcGxhY2VkIGluIGEgYmxvY2sgd2l0aCB2ZXJ0aWNhbCBtYXJnaW4uXG4gKi9cbnZhciBTZXR0aW5nc19TZXR0aW5ncyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNldHRpbmdzKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRpc3BsYXlNb2RlID0gdm9pZCAwO1xuICAgIHRoaXMub3V0cHV0ID0gdm9pZCAwO1xuICAgIHRoaXMubGVxbm8gPSB2b2lkIDA7XG4gICAgdGhpcy5mbGVxbiA9IHZvaWQgMDtcbiAgICB0aGlzLnRocm93T25FcnJvciA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9yQ29sb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5tYWNyb3MgPSB2b2lkIDA7XG4gICAgdGhpcy5taW5SdWxlVGhpY2tuZXNzID0gdm9pZCAwO1xuICAgIHRoaXMuY29sb3JJc1RleHRDb2xvciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0cmljdCA9IHZvaWQgMDtcbiAgICB0aGlzLnRydXN0ID0gdm9pZCAwO1xuICAgIHRoaXMubWF4U2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLm1heEV4cGFuZCA9IHZvaWQgMDtcbiAgICAvLyBhbGxvdyBudWxsIG9wdGlvbnNcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLmRpc3BsYXlNb2RlID0gdXRpbHMuZGVmbHQob3B0aW9ucy5kaXNwbGF5TW9kZSwgZmFsc2UpO1xuICAgIHRoaXMub3V0cHV0ID0gdXRpbHMuZGVmbHQob3B0aW9ucy5vdXRwdXQsIFwiaHRtbEFuZE1hdGhtbFwiKTtcbiAgICB0aGlzLmxlcW5vID0gdXRpbHMuZGVmbHQob3B0aW9ucy5sZXFubywgZmFsc2UpO1xuICAgIHRoaXMuZmxlcW4gPSB1dGlscy5kZWZsdChvcHRpb25zLmZsZXFuLCBmYWxzZSk7XG4gICAgdGhpcy50aHJvd09uRXJyb3IgPSB1dGlscy5kZWZsdChvcHRpb25zLnRocm93T25FcnJvciwgdHJ1ZSk7XG4gICAgdGhpcy5lcnJvckNvbG9yID0gdXRpbHMuZGVmbHQob3B0aW9ucy5lcnJvckNvbG9yLCBcIiNjYzAwMDBcIik7XG4gICAgdGhpcy5tYWNyb3MgPSBvcHRpb25zLm1hY3JvcyB8fCB7fTtcbiAgICB0aGlzLm1pblJ1bGVUaGlja25lc3MgPSBNYXRoLm1heCgwLCB1dGlscy5kZWZsdChvcHRpb25zLm1pblJ1bGVUaGlja25lc3MsIDApKTtcbiAgICB0aGlzLmNvbG9ySXNUZXh0Q29sb3IgPSB1dGlscy5kZWZsdChvcHRpb25zLmNvbG9ySXNUZXh0Q29sb3IsIGZhbHNlKTtcbiAgICB0aGlzLnN0cmljdCA9IHV0aWxzLmRlZmx0KG9wdGlvbnMuc3RyaWN0LCBcIndhcm5cIik7XG4gICAgdGhpcy50cnVzdCA9IHV0aWxzLmRlZmx0KG9wdGlvbnMudHJ1c3QsIGZhbHNlKTtcbiAgICB0aGlzLm1heFNpemUgPSBNYXRoLm1heCgwLCB1dGlscy5kZWZsdChvcHRpb25zLm1heFNpemUsIEluZmluaXR5KSk7XG4gICAgdGhpcy5tYXhFeHBhbmQgPSBNYXRoLm1heCgwLCB1dGlscy5kZWZsdChvcHRpb25zLm1heEV4cGFuZCwgMTAwMCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXBvcnQgbm9uc3RyaWN0IChub24tTGFUZVgtY29tcGF0aWJsZSkgaW5wdXQuXG4gICAqIENhbiBzYWZlbHkgbm90IGJlIGNhbGxlZCBpZiBgdGhpcy5zdHJpY3RgIGlzIGZhbHNlIGluIEphdmFTY3JpcHQuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFNldHRpbmdzLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVwb3J0Tm9uc3RyaWN0ID0gZnVuY3Rpb24gcmVwb3J0Tm9uc3RyaWN0KGVycm9yQ29kZSwgZXJyb3JNc2csIHRva2VuKSB7XG4gICAgdmFyIHN0cmljdCA9IHRoaXMuc3RyaWN0O1xuXG4gICAgaWYgKHR5cGVvZiBzdHJpY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgLy8gQWxsb3cgcmV0dXJuIHZhbHVlIG9mIHN0cmljdCBmdW5jdGlvbiB0byBiZSBib29sZWFuIG9yIHN0cmluZ1xuICAgICAgLy8gKG9yIG51bGwvdW5kZWZpbmVkLCBtZWFuaW5nIG5vIGZ1cnRoZXIgcHJvY2Vzc2luZykuXG4gICAgICBzdHJpY3QgPSBzdHJpY3QoZXJyb3JDb2RlLCBlcnJvck1zZywgdG9rZW4pO1xuICAgIH1cblxuICAgIGlmICghc3RyaWN0IHx8IHN0cmljdCA9PT0gXCJpZ25vcmVcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoc3RyaWN0ID09PSB0cnVlIHx8IHN0cmljdCA9PT0gXCJlcnJvclwiKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJMYVRlWC1pbmNvbXBhdGlibGUgaW5wdXQgYW5kIHN0cmljdCBtb2RlIGlzIHNldCB0byAnZXJyb3InOiBcIiArIChlcnJvck1zZyArIFwiIFtcIiArIGVycm9yQ29kZSArIFwiXVwiKSwgdG9rZW4pO1xuICAgIH0gZWxzZSBpZiAoc3RyaWN0ID09PSBcIndhcm5cIikge1xuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTGFUZVgtaW5jb21wYXRpYmxlIGlucHV0IGFuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gJ3dhcm4nOiBcIiArIChlcnJvck1zZyArIFwiIFtcIiArIGVycm9yQ29kZSArIFwiXVwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdvbid0IGhhcHBlbiBpbiB0eXBlLXNhZmUgY29kZVxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTGFUZVgtaW5jb21wYXRpYmxlIGlucHV0IGFuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gXCIgKyAoXCJ1bnJlY29nbml6ZWQgJ1wiICsgc3RyaWN0ICsgXCInOiBcIiArIGVycm9yTXNnICsgXCIgW1wiICsgZXJyb3JDb2RlICsgXCJdXCIpKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdG8gYXBwbHkgc3RyaWN0IChMYVRlWC1hZGhlcmluZykgYmVoYXZpb3IgZm9yIHVudXN1YWxcbiAgICogaW5wdXQgKGxpa2UgYFxcXFxgKS4gIFVubGlrZSBgbm9uc3RyaWN0YCwgd2lsbCBub3QgdGhyb3cgYW4gZXJyb3I7XG4gICAqIGluc3RlYWQsIFwiZXJyb3JcIiB0cmFuc2xhdGVzIHRvIGEgcmV0dXJuIHZhbHVlIG9mIGB0cnVlYCwgd2hpbGUgXCJpZ25vcmVcIlxuICAgKiB0cmFuc2xhdGVzIHRvIGEgcmV0dXJuIHZhbHVlIG9mIGBmYWxzZWAuICBNYXkgc3RpbGwgcHJpbnQgYSB3YXJuaW5nOlxuICAgKiBcIndhcm5cIiBwcmludHMgYSB3YXJuaW5nIGFuZCByZXR1cm5zIGBmYWxzZWAuXG4gICAqIFRoaXMgaXMgZm9yIHRoZSBzZWNvbmQgY2F0ZWdvcnkgb2YgYGVycm9yQ29kZWBzIGxpc3RlZCBpbiB0aGUgUkVBRE1FLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51c2VTdHJpY3RCZWhhdmlvciA9IGZ1bmN0aW9uIHVzZVN0cmljdEJlaGF2aW9yKGVycm9yQ29kZSwgZXJyb3JNc2csIHRva2VuKSB7XG4gICAgdmFyIHN0cmljdCA9IHRoaXMuc3RyaWN0O1xuXG4gICAgaWYgKHR5cGVvZiBzdHJpY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgLy8gQWxsb3cgcmV0dXJuIHZhbHVlIG9mIHN0cmljdCBmdW5jdGlvbiB0byBiZSBib29sZWFuIG9yIHN0cmluZ1xuICAgICAgLy8gKG9yIG51bGwvdW5kZWZpbmVkLCBtZWFuaW5nIG5vIGZ1cnRoZXIgcHJvY2Vzc2luZykuXG4gICAgICAvLyBCdXQgY2F0Y2ggYW55IGV4Y2VwdGlvbnMgdGhyb3duIGJ5IGZ1bmN0aW9uLCB0cmVhdGluZyB0aGVtXG4gICAgICAvLyBsaWtlIFwiZXJyb3JcIi5cbiAgICAgIHRyeSB7XG4gICAgICAgIHN0cmljdCA9IHN0cmljdChlcnJvckNvZGUsIGVycm9yTXNnLCB0b2tlbik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzdHJpY3QgPSBcImVycm9yXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzdHJpY3QgfHwgc3RyaWN0ID09PSBcImlnbm9yZVwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChzdHJpY3QgPT09IHRydWUgfHwgc3RyaWN0ID09PSBcImVycm9yXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc3RyaWN0ID09PSBcIndhcm5cIikge1xuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTGFUZVgtaW5jb21wYXRpYmxlIGlucHV0IGFuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gJ3dhcm4nOiBcIiArIChlcnJvck1zZyArIFwiIFtcIiArIGVycm9yQ29kZSArIFwiXVwiKSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdvbid0IGhhcHBlbiBpbiB0eXBlLXNhZmUgY29kZVxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTGFUZVgtaW5jb21wYXRpYmxlIGlucHV0IGFuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gXCIgKyAoXCJ1bnJlY29nbml6ZWQgJ1wiICsgc3RyaWN0ICsgXCInOiBcIiArIGVycm9yTXNnICsgXCIgW1wiICsgZXJyb3JDb2RlICsgXCJdXCIpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdG8gdGVzdCBwb3RlbnRpYWxseSBkYW5nZXJvdXMgaW5wdXQsIGFuZCByZXR1cm5cbiAgICogYHRydWVgICh0cnVzdGVkKSBvciBgZmFsc2VgICh1bnRydXN0ZWQpLiAgVGhlIHNvbGUgYXJndW1lbnQgYGNvbnRleHRgXG4gICAqIHNob3VsZCBiZSBhbiBvYmplY3Qgd2l0aCBgY29tbWFuZGAgZmllbGQgc3BlY2lmeWluZyB0aGUgcmVsZXZhbnQgTGFUZVhcbiAgICogY29tbWFuZCAoYXMgYSBzdHJpbmcgc3RhcnRpbmcgd2l0aCBgXFxgKSwgYW5kIGFueSBvdGhlciBhcmd1bWVudHMsIGV0Yy5cbiAgICogSWYgYGNvbnRleHRgIGhhcyBhIGB1cmxgIGZpZWxkLCBhIGBwcm90b2NvbGAgZmllbGQgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAqIGdldCBhZGRlZCBieSB0aGlzIGZ1bmN0aW9uIChjaGFuZ2luZyB0aGUgc3BlY2lmaWVkIG9iamVjdCkuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmlzVHJ1c3RlZCA9IGZ1bmN0aW9uIGlzVHJ1c3RlZChjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQudXJsICYmICFjb250ZXh0LnByb3RvY29sKSB7XG4gICAgICBjb250ZXh0LnByb3RvY29sID0gdXRpbHMucHJvdG9jb2xGcm9tVXJsKGNvbnRleHQudXJsKTtcbiAgICB9XG5cbiAgICB2YXIgdHJ1c3QgPSB0eXBlb2YgdGhpcy50cnVzdCA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy50cnVzdChjb250ZXh0KSA6IHRoaXMudHJ1c3Q7XG4gICAgcmV0dXJuIEJvb2xlYW4odHJ1c3QpO1xuICB9O1xuXG4gIHJldHVybiBTZXR0aW5ncztcbn0oKTtcblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9TdHlsZS5qc1xuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgaW5mb3JtYXRpb24gYW5kIGNsYXNzZXMgZm9yIHRoZSB2YXJpb3VzIGtpbmRzIG9mIHN0eWxlc1xuICogdXNlZCBpbiBUZVguIEl0IHByb3ZpZGVzIGEgZ2VuZXJpYyBgU3R5bGVgIGNsYXNzLCB3aGljaCBob2xkcyBpbmZvcm1hdGlvblxuICogYWJvdXQgYSBzcGVjaWZpYyBzdHlsZS4gSXQgdGhlbiBwcm92aWRlcyBpbnN0YW5jZXMgb2YgYWxsIHRoZSBkaWZmZXJlbnQga2luZHNcbiAqIG9mIHN0eWxlcyBwb3NzaWJsZSwgYW5kIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBtb3ZlIGJldHdlZW4gdGhlbSBhbmQgZ2V0XG4gKiBpbmZvcm1hdGlvbiBhYm91dCB0aGVtLlxuICovXG5cbi8qKlxuICogVGhlIG1haW4gc3R5bGUgY2xhc3MuIENvbnRhaW5zIGEgdW5pcXVlIGlkIGZvciB0aGUgc3R5bGUsIGEgc2l6ZSAod2hpY2ggaXNcbiAqIHRoZSBzYW1lIGZvciBjcmFtcGVkIGFuZCB1bmNyYW1wZWQgdmVyc2lvbiBvZiBhIHN0eWxlKSwgYW5kIGEgY3JhbXBlZCBmbGFnLlxuICovXG52YXIgU3R5bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHlsZShpZCwgc2l6ZSwgY3JhbXBlZCkge1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5zaXplID0gdm9pZCAwO1xuICAgIHRoaXMuY3JhbXBlZCA9IHZvaWQgMDtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmNyYW1wZWQgPSBjcmFtcGVkO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0eWxlIG9mIGEgc3VwZXJzY3JpcHQgZ2l2ZW4gYSBiYXNlIGluIHRoZSBjdXJyZW50IHN0eWxlLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBTdHlsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnN1cCA9IGZ1bmN0aW9uIHN1cCgpIHtcbiAgICByZXR1cm4gU3R5bGVfc3R5bGVzW19zdXBbdGhpcy5pZF1dO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0eWxlIG9mIGEgc3Vic2NyaXB0IGdpdmVuIGEgYmFzZSBpbiB0aGUgY3VycmVudCBzdHlsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uc3ViID0gZnVuY3Rpb24gc3ViKCkge1xuICAgIHJldHVybiBTdHlsZV9zdHlsZXNbX3N1Ylt0aGlzLmlkXV07XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgc3R5bGUgb2YgYSBmcmFjdGlvbiBudW1lcmF0b3IgZ2l2ZW4gdGhlIGZyYWN0aW9uIGluIHRoZSBjdXJyZW50XG4gICAqIHN0eWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5mcmFjTnVtID0gZnVuY3Rpb24gZnJhY051bSgpIHtcbiAgICByZXR1cm4gU3R5bGVfc3R5bGVzW19mcmFjTnVtW3RoaXMuaWRdXTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBzdHlsZSBvZiBhIGZyYWN0aW9uIGRlbm9taW5hdG9yIGdpdmVuIHRoZSBmcmFjdGlvbiBpbiB0aGUgY3VycmVudFxuICAgKiBzdHlsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZnJhY0RlbiA9IGZ1bmN0aW9uIGZyYWNEZW4oKSB7XG4gICAgcmV0dXJuIFN0eWxlX3N0eWxlc1tfZnJhY0Rlblt0aGlzLmlkXV07XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3JhbXBlZCB2ZXJzaW9uIG9mIGEgc3R5bGUgKGluIHBhcnRpY3VsYXIsIGNyYW1waW5nIGEgY3JhbXBlZCBzdHlsZVxuICAgKiBkb2Vzbid0IGNoYW5nZSB0aGUgc3R5bGUpLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jcmFtcCA9IGZ1bmN0aW9uIGNyYW1wKCkge1xuICAgIHJldHVybiBTdHlsZV9zdHlsZXNbX2NyYW1wW3RoaXMuaWRdXTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgdGV4dCBvciBkaXNwbGF5IHZlcnNpb24gb2YgdGhpcyBzdHlsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udGV4dCA9IGZ1bmN0aW9uIHRleHQoKSB7XG4gICAgcmV0dXJuIFN0eWxlX3N0eWxlc1tfdGV4dFt0aGlzLmlkXV07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIHRoaXMgc3R5bGUgaXMgdGlnaHRseSBzcGFjZWQgKHNjcmlwdHN0eWxlL3NjcmlwdHNjcmlwdHN0eWxlKVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pc1RpZ2h0ID0gZnVuY3Rpb24gaXNUaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplID49IDI7XG4gIH07XG5cbiAgcmV0dXJuIFN0eWxlO1xufSgpOyAvLyBFeHBvcnQgYW4gaW50ZXJmYWNlIGZvciB0eXBlIGNoZWNraW5nLCBidXQgZG9uJ3QgZXhwb3NlIHRoZSBpbXBsZW1lbnRhdGlvbi5cbi8vIFRoaXMgd2F5LCBubyBtb3JlIHN0eWxlcyBjYW4gYmUgZ2VuZXJhdGVkLlxuXG5cbi8vIElEcyBvZiB0aGUgZGlmZmVyZW50IHN0eWxlc1xudmFyIEQgPSAwO1xudmFyIERjID0gMTtcbnZhciBUID0gMjtcbnZhciBUYyA9IDM7XG52YXIgUyA9IDQ7XG52YXIgU2MgPSA1O1xudmFyIFNTID0gNjtcbnZhciBTU2MgPSA3OyAvLyBJbnN0YW5jZXMgb2YgdGhlIGRpZmZlcmVudCBzdHlsZXNcblxudmFyIFN0eWxlX3N0eWxlcyA9IFtuZXcgU3R5bGUoRCwgMCwgZmFsc2UpLCBuZXcgU3R5bGUoRGMsIDAsIHRydWUpLCBuZXcgU3R5bGUoVCwgMSwgZmFsc2UpLCBuZXcgU3R5bGUoVGMsIDEsIHRydWUpLCBuZXcgU3R5bGUoUywgMiwgZmFsc2UpLCBuZXcgU3R5bGUoU2MsIDIsIHRydWUpLCBuZXcgU3R5bGUoU1MsIDMsIGZhbHNlKSwgbmV3IFN0eWxlKFNTYywgMywgdHJ1ZSldOyAvLyBMb29rdXAgdGFibGVzIGZvciBzd2l0Y2hpbmcgZnJvbSBvbmUgc3R5bGUgdG8gYW5vdGhlclxuXG52YXIgX3N1cCA9IFtTLCBTYywgUywgU2MsIFNTLCBTU2MsIFNTLCBTU2NdO1xudmFyIF9zdWIgPSBbU2MsIFNjLCBTYywgU2MsIFNTYywgU1NjLCBTU2MsIFNTY107XG52YXIgX2ZyYWNOdW0gPSBbVCwgVGMsIFMsIFNjLCBTUywgU1NjLCBTUywgU1NjXTtcbnZhciBfZnJhY0RlbiA9IFtUYywgVGMsIFNjLCBTYywgU1NjLCBTU2MsIFNTYywgU1NjXTtcbnZhciBfY3JhbXAgPSBbRGMsIERjLCBUYywgVGMsIFNjLCBTYywgU1NjLCBTU2NdO1xudmFyIF90ZXh0ID0gW0QsIERjLCBULCBUYywgVCwgVGMsIFQsIFRjXTsgLy8gV2Ugb25seSBleHBvcnQgc29tZSBvZiB0aGUgc3R5bGVzLlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfU3R5bGUgPSAoe1xuICBESVNQTEFZOiBTdHlsZV9zdHlsZXNbRF0sXG4gIFRFWFQ6IFN0eWxlX3N0eWxlc1tUXSxcbiAgU0NSSVBUOiBTdHlsZV9zdHlsZXNbU10sXG4gIFNDUklQVFNDUklQVDogU3R5bGVfc3R5bGVzW1NTXVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91bmljb2RlU2NyaXB0cy5qc1xuLypcbiAqIFRoaXMgZmlsZSBkZWZpbmVzIHRoZSBVbmljb2RlIHNjcmlwdHMgYW5kIHNjcmlwdCBmYW1pbGllcyB0aGF0IHdlXG4gKiBzdXBwb3J0LiBUbyBhZGQgbmV3IHNjcmlwdHMgb3IgZmFtaWxpZXMsIGp1c3QgYWRkIGEgbmV3IGVudHJ5IHRvIHRoZVxuICogc2NyaXB0RGF0YSBhcnJheSBiZWxvdy4gQWRkaW5nIHNjcmlwdHMgdG8gdGhlIHNjcmlwdERhdGEgYXJyYXkgYWxsb3dzXG4gKiBjaGFyYWN0ZXJzIGZyb20gdGhhdCBzY3JpcHQgdG8gYXBwZWFyIGluIFxcdGV4dHt9IGVudmlyb25tZW50cy5cbiAqL1xuXG4vKipcbiAqIEVhY2ggc2NyaXB0IG9yIHNjcmlwdCBmYW1pbHkgaGFzIGEgbmFtZSBhbmQgYW4gYXJyYXkgb2YgYmxvY2tzLlxuICogRWFjaCBibG9jayBpcyBhbiBhcnJheSBvZiB0d28gbnVtYmVycyB3aGljaCBzcGVjaWZ5IHRoZSBzdGFydCBhbmRcbiAqIGVuZCBwb2ludHMgKGluY2x1c2l2ZSkgb2YgYSBibG9jayBvZiBVbmljb2RlIGNvZGVwb2ludHMuXG4gKi9cblxuLyoqXG4gKiBVbmljb2RlIGJsb2NrIGRhdGEgZm9yIHRoZSBmYW1pbGllcyBvZiBzY3JpcHRzIHdlIHN1cHBvcnQgaW4gXFx0ZXh0e30uXG4gKiBTY3JpcHRzIG9ubHkgbmVlZCB0byBhcHBlYXIgaGVyZSBpZiB0aGV5IGRvIG5vdCBoYXZlIGZvbnQgbWV0cmljcy5cbiAqL1xudmFyIHNjcmlwdERhdGEgPSBbe1xuICAvLyBMYXRpbiBjaGFyYWN0ZXJzIGJleW9uZCB0aGUgTGF0aW4tMSBjaGFyYWN0ZXJzIHdlIGhhdmUgbWV0cmljcyBmb3IuXG4gIC8vIE5lZWRlZCBmb3IgQ3plY2gsIEh1bmdhcmlhbiBhbmQgVHVya2lzaCB0ZXh0LCBmb3IgZXhhbXBsZS5cbiAgbmFtZTogJ2xhdGluJyxcbiAgYmxvY2tzOiBbWzB4MDEwMCwgMHgwMjRmXSwgLy8gTGF0aW4gRXh0ZW5kZWQtQSBhbmQgTGF0aW4gRXh0ZW5kZWQtQlxuICBbMHgwMzAwLCAweDAzNmZdXVxufSwge1xuICAvLyBUaGUgQ3lyaWxsaWMgc2NyaXB0IHVzZWQgYnkgUnVzc2lhbiBhbmQgcmVsYXRlZCBsYW5ndWFnZXMuXG4gIC8vIEEgQ3lyaWxsaWMgc3Vic2V0IHVzZWQgdG8gYmUgc3VwcG9ydGVkIGFzIGV4cGxpY2l0bHkgZGVmaW5lZFxuICAvLyBzeW1ib2xzIGluIHN5bWJvbHMuanNcbiAgbmFtZTogJ2N5cmlsbGljJyxcbiAgYmxvY2tzOiBbWzB4MDQwMCwgMHgwNGZmXV1cbn0sIHtcbiAgLy8gVGhlIEJyYWhtaWMgc2NyaXB0cyBvZiBTb3V0aCBhbmQgU291dGhlYXN0IEFzaWFcbiAgLy8gRGV2YW5hZ2FyaSAoMDkwMOKAkzA5N0YpXG4gIC8vIEJlbmdhbGkgKDA5ODDigJMwOUZGKVxuICAvLyBHdXJtdWtoaSAoMEEwMOKAkzBBN0YpXG4gIC8vIEd1amFyYXRpICgwQTgw4oCTMEFGRilcbiAgLy8gT3JpeWEgKDBCMDDigJMwQjdGKVxuICAvLyBUYW1pbCAoMEI4MOKAkzBCRkYpXG4gIC8vIFRlbHVndSAoMEMwMOKAkzBDN0YpXG4gIC8vIEthbm5hZGEgKDBDODDigJMwQ0ZGKVxuICAvLyBNYWxheWFsYW0gKDBEMDDigJMwRDdGKVxuICAvLyBTaW5oYWxhICgwRDgw4oCTMERGRilcbiAgLy8gVGhhaSAoMEUwMOKAkzBFN0YpXG4gIC8vIExhbyAoMEU4MOKAkzBFRkYpXG4gIC8vIFRpYmV0YW4gKDBGMDDigJMwRkZGKVxuICAvLyBNeWFubWFyICgxMDAw4oCTMTA5RilcbiAgbmFtZTogJ2JyYWhtaWMnLFxuICBibG9ja3M6IFtbMHgwOTAwLCAweDEwOUZdXVxufSwge1xuICBuYW1lOiAnZ2VvcmdpYW4nLFxuICBibG9ja3M6IFtbMHgxMEEwLCAweDEwZmZdXVxufSwge1xuICAvLyBDaGluZXNlIGFuZCBKYXBhbmVzZS5cbiAgLy8gVGhlIFwia1wiIGluIGNqayBpcyBmb3IgS29yZWFuLCBidXQgd2UndmUgc2VwYXJhdGVkIEtvcmVhbiBvdXRcbiAgbmFtZTogXCJjamtcIixcbiAgYmxvY2tzOiBbWzB4MzAwMCwgMHgzMEZGXSwgLy8gQ0pLIHN5bWJvbHMgYW5kIHB1bmN0dWF0aW9uLCBIaXJhZ2FuYSwgS2F0YWthbmFcbiAgWzB4NEUwMCwgMHg5RkFGXSwgLy8gQ0pLIGlkZW9ncmFtc1xuICBbMHhGRjAwLCAweEZGNjBdXVxufSwge1xuICAvLyBLb3JlYW5cbiAgbmFtZTogJ2hhbmd1bCcsXG4gIGJsb2NrczogW1sweEFDMDAsIDB4RDdBRl1dXG59XTtcbi8qKlxuICogR2l2ZW4gYSBjb2RlcG9pbnQsIHJldHVybiB0aGUgbmFtZSBvZiB0aGUgc2NyaXB0IG9yIHNjcmlwdCBmYW1pbHlcbiAqIGl0IGlzIGZyb20sIG9yIG51bGwgaWYgaXQgaXMgbm90IHBhcnQgb2YgYSBrbm93biBibG9ja1xuICovXG5cbmZ1bmN0aW9uIHNjcmlwdEZyb21Db2RlcG9pbnQoY29kZXBvaW50KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2NyaXB0RGF0YS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzY3JpcHQgPSBzY3JpcHREYXRhW2ldO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHNjcmlwdC5ibG9ja3MubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgYmxvY2sgPSBzY3JpcHQuYmxvY2tzW19pXTtcblxuICAgICAgaWYgKGNvZGVwb2ludCA+PSBibG9ja1swXSAmJiBjb2RlcG9pbnQgPD0gYmxvY2tbMV0pIHtcbiAgICAgICAgcmV0dXJuIHNjcmlwdC5uYW1lO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBBIGZsYXR0ZW5lZCB2ZXJzaW9uIG9mIGFsbCB0aGUgc3VwcG9ydGVkIGJsb2NrcyBpbiBhIHNpbmdsZSBhcnJheS5cbiAqIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIHRvIG1ha2Ugc3VwcG9ydGVkQ29kZXBvaW50KCkgZmFzdC5cbiAqL1xuXG52YXIgYWxsQmxvY2tzID0gW107XG5zY3JpcHREYXRhLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgcmV0dXJuIHMuYmxvY2tzLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICByZXR1cm4gYWxsQmxvY2tzLnB1c2guYXBwbHkoYWxsQmxvY2tzLCBiKTtcbiAgfSk7XG59KTtcbi8qKlxuICogR2l2ZW4gYSBjb2RlcG9pbnQsIHJldHVybiB0cnVlIGlmIGl0IGZhbGxzIHdpdGhpbiBvbmUgb2YgdGhlXG4gKiBzY3JpcHRzIG9yIHNjcmlwdCBmYW1pbGllcyBkZWZpbmVkIGFib3ZlIGFuZCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogTWljcm8gYmVuY2htYXJrcyBzaG93cyB0aGF0IHRoaXMgaXMgZmFzdGVyIHRoYW5cbiAqIC9bXFx1MzAwMC1cXHUzMEZGXFx1NEUwMC1cXHU5RkFGXFx1RkYwMC1cXHVGRjYwXFx1QUMwMC1cXHVEN0FGXFx1MDkwMC1cXHUxMDlGXS8udGVzdCgpXG4gKiBpbiBGaXJlZm94LCBDaHJvbWUgYW5kIE5vZGUuXG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydGVkQ29kZXBvaW50KGNvZGVwb2ludCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEJsb2Nrcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGlmIChjb2RlcG9pbnQgPj0gYWxsQmxvY2tzW2ldICYmIGNvZGVwb2ludCA8PSBhbGxCbG9ja3NbaSArIDFdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zdmdHZW9tZXRyeS5qc1xuLyoqXG4gKiBUaGlzIGZpbGUgcHJvdmlkZXMgc3VwcG9ydCB0byBkb21UcmVlLmpzIGFuZCBkZWxpbWl0ZXIuanMuXG4gKiBJdCdzIGEgc3RvcmVob3VzZSBvZiBwYXRoIGdlb21ldHJ5IGZvciBTVkcgaW1hZ2VzLlxuICovXG4vLyBJbiBhbGwgcGF0aHMgYmVsb3csIHRoZSB2aWV3Qm94LXRvLWVtIHNjYWxlIGlzIDEwMDA6MS5cbnZhciBoTGluZVBhZCA9IDgwOyAvLyBwYWRkaW5nIGFib3ZlIGEgc3FydCB2aW5pY3VsdW0uIFByZXZlbnRzIGltYWdlIGNyb3BwaW5nLlxuLy8gVGhlIHZpbmljdWx1bSBvZiBhIFxcc3FydCBjYW4gYmUgbWFkZSB0aGlja2VyIGJ5IGEgS2FUZVggcmVuZGVyaW5nIG9wdGlvbi5cbi8vIFRoaW5rIG9mIHZhcmlhYmxlIGV4dHJhVmluaWN1bHVtIGFzIHR3byBkZXRvdXJzIGluIHRoZSBTVkcgcGF0aC5cbi8vIFRoZSBkZXRvdXIgYmVnaW5zIGF0IHRoZSBsb3dlciBsZWZ0IG9mIHRoZSBhcmVhIGxhYmVsZWQgZXh0cmFWaW5pY3VsdW0gYmVsb3cuXG4vLyBUaGUgZGV0b3VyIHByb2NlZWRzIG9uZSBleHRyYVZpbmljdWx1bSBkaXN0YW5jZSB1cCBhbmQgc2xpZ2h0bHkgdG8gdGhlIHJpZ2h0LFxuLy8gZGlzcGxhY2luZyB0aGUgcmFkaXVzZWQgY29ybmVyIGJldHdlZW4gc3VyZCBhbmQgdmluaWN1bHVtLiBUaGUgcmFkaXVzIGlzXG4vLyB0cmF2ZXJzZWQgYXMgdXN1YWwsIHRoZW4gdGhlIGRldG91ciByZXN1bWVzLiBJdCBnb2VzIHJpZ2h0LCB0byB0aGUgZW5kIG9mXG4vLyB0aGUgdmVyeSBsb25nIHZpbmljdWx1bW4sIHRoZW4gZG93biBvbmUgZXh0cmFWaW5pY3VsdW0gZGlzdGFuY2UsXG4vLyBhZnRlciB3aGljaCBpdCByZXN1bWVzIHJlZ3VsYXIgcGF0aCBnZW9tZXRyeSBmb3IgdGhlIHJhZGljYWwuXG5cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aW5pY3VsdW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC9cbiAgICAgICAgIC/ilpLilpLilpLilpLilpLilpLilpLilpLilpLilpLilpLilpLilpLilpLilpLilpLilpLilpLilpLilpLilpLihpBleHRyYVZpbmljdWx1bVxuICAgICAgICAvIOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKGkDAuMDRlbSAoNDAgdW5pdCkgc3RkIHZpbmljdWx1bSB0aGlja25lc3NcbiAgICAgICAvIC9cbiAgICAgIC8gL1xuICAgICAvIC9cXFxuICAgIC8gLyBzdXJkXG4qL1xuXG52YXIgc3FydE1haW4gPSBmdW5jdGlvbiBzcXJ0TWFpbihleHRyYVZpbmljdWx1bSwgaExpbmVQYWQpIHtcbiAgLy8gc3FydE1haW4gcGF0aCBnZW9tZXRyeSBpcyBmcm9tIGdseXBoIFUyMjFBIGluIHRoZSBmb250IEthVGVYIE1haW5cbiAgcmV0dXJuIFwiTTk1LFwiICsgKDYyMiArIGV4dHJhVmluaWN1bHVtICsgaExpbmVQYWQpICsgXCJcXG5jLTIuNywwLC03LjE3LC0yLjcsLTEzLjUsLThjLTUuOCwtNS4zLC05LjUsLTEwLC05LjUsLTE0XFxuYzAsLTIsMC4zLC0zLjMsMSwtNGMxLjMsLTIuNywyMy44MywtMjAuNyw2Ny41LC01NFxcbmM0NC4yLC0zMy4zLDY1LjgsLTUwLjMsNjYuNSwtNTFjMS4zLC0xLjMsMywtMiw1LC0yYzQuNywwLDguNywzLjMsMTIsMTBcXG5zMTczLDM3OCwxNzMsMzc4YzAuNywwLDM1LjMsLTcxLDEwNCwtMjEzYzY4LjcsLTE0MiwxMzcuNSwtMjg1LDIwNi41LC00MjlcXG5jNjksLTE0NCwxMDQuNSwtMjE3LjcsMTA2LjUsLTIyMVxcbmxcIiArIGV4dHJhVmluaWN1bHVtIC8gMi4wNzUgKyBcIiAtXCIgKyBleHRyYVZpbmljdWx1bSArIFwiXFxuYzUuMywtOS4zLDEyLC0xNCwyMCwtMTRcXG5INDAwMDAwdlwiICsgKDQwICsgZXh0cmFWaW5pY3VsdW0pICsgXCJIODQ1LjI3MjRcXG5zLTIyNS4yNzIsNDY3LC0yMjUuMjcyLDQ2N3MtMjM1LDQ4NiwtMjM1LDQ4NmMtMi43LDQuNywtOSw3LC0xOSw3XFxuYy02LDAsLTEwLC0xLC0xMiwtM3MtMTk0LC00MjIsLTE5NCwtNDIycy02NSw0NywtNjUsNDd6XFxuTVwiICsgKDgzNCArIGV4dHJhVmluaWN1bHVtKSArIFwiIFwiICsgaExpbmVQYWQgKyBcImg0MDAwMDB2XCIgKyAoNDAgKyBleHRyYVZpbmljdWx1bSkgKyBcImgtNDAwMDAwelwiO1xufTtcblxudmFyIHNxcnRTaXplMSA9IGZ1bmN0aW9uIHNxcnRTaXplMShleHRyYVZpbmljdWx1bSwgaExpbmVQYWQpIHtcbiAgLy8gc2l6ZTEgaXMgZnJvbSBnbHlwaCBVMjIxQSBpbiB0aGUgZm9udCBLYVRlWF9TaXplMS1SZWd1bGFyXG4gIHJldHVybiBcIk0yNjMsXCIgKyAoNjAxICsgZXh0cmFWaW5pY3VsdW0gKyBoTGluZVBhZCkgKyBcImMwLjcsMCwxOCwzOS43LDUyLDExOVxcbmMzNCw3OS4zLDY4LjE2NywxNTguNywxMDIuNSwyMzhjMzQuMyw3OS4zLDUxLjgsMTE5LjMsNTIuNSwxMjBcXG5jMzQwLC03MDQuNyw1MTAuNywtMTA2MC4zLDUxMiwtMTA2N1xcbmxcIiArIGV4dHJhVmluaWN1bHVtIC8gMi4wODQgKyBcIiAtXCIgKyBleHRyYVZpbmljdWx1bSArIFwiXFxuYzQuNywtNy4zLDExLC0xMSwxOSwtMTFcXG5INDAwMDB2XCIgKyAoNDAgKyBleHRyYVZpbmljdWx1bSkgKyBcIkgxMDEyLjNcXG5zLTI3MS4zLDU2NywtMjcxLjMsNTY3Yy0zOC43LDgwLjcsLTg0LDE3NSwtMTM2LDI4M2MtNTIsMTA4LC04OS4xNjcsMTg1LjMsLTExMS41LDIzMlxcbmMtMjIuMyw0Ni43LC0zMy44LDcwLjMsLTM0LjUsNzFjLTQuNyw0LjcsLTEyLjMsNywtMjMsN3MtMTIsLTEsLTEyLC0xXFxucy0xMDksLTI1MywtMTA5LC0yNTNjLTcyLjcsLTE2OCwtMTA5LjMsLTI1MiwtMTEwLC0yNTJjLTEwLjcsOCwtMjIsMTYuNywtMzQsMjZcXG5jLTIyLDE3LjMsLTMzLjMsMjYsLTM0LDI2cy0yNiwtMjYsLTI2LC0yNnM3NiwtNTksNzYsLTU5czc2LC02MCw3NiwtNjB6XFxuTVwiICsgKDEwMDEgKyBleHRyYVZpbmljdWx1bSkgKyBcIiBcIiArIGhMaW5lUGFkICsgXCJoNDAwMDAwdlwiICsgKDQwICsgZXh0cmFWaW5pY3VsdW0pICsgXCJoLTQwMDAwMHpcIjtcbn07XG5cbnZhciBzcXJ0U2l6ZTIgPSBmdW5jdGlvbiBzcXJ0U2l6ZTIoZXh0cmFWaW5pY3VsdW0sIGhMaW5lUGFkKSB7XG4gIC8vIHNpemUyIGlzIGZyb20gZ2x5cGggVTIyMUEgaW4gdGhlIGZvbnQgS2FUZVhfU2l6ZTItUmVndWxhclxuICByZXR1cm4gXCJNOTgzIFwiICsgKDEwICsgZXh0cmFWaW5pY3VsdW0gKyBoTGluZVBhZCkgKyBcIlxcbmxcIiArIGV4dHJhVmluaWN1bHVtIC8gMy4xMyArIFwiIC1cIiArIGV4dHJhVmluaWN1bHVtICsgXCJcXG5jNCwtNi43LDEwLC0xMCwxOCwtMTAgSDQwMDAwMHZcIiArICg0MCArIGV4dHJhVmluaWN1bHVtKSArIFwiXFxuSDEwMTMuMXMtODMuNCwyNjgsLTI2NC4xLDg0MGMtMTgwLjcsNTcyLC0yNzcsODc2LjMsLTI4OSw5MTNjLTQuNyw0LjcsLTEyLjcsNywtMjQsN1xcbnMtMTIsMCwtMTIsMGMtMS4zLC0zLjMsLTMuNywtMTEuNywtNywtMjVjLTM1LjMsLTEyNS4zLC0xMDYuNywtMzczLjMsLTIxNCwtNzQ0XFxuYy0xMCwxMiwtMjEsMjUsLTMzLDM5cy0zMiwzOSwtMzIsMzljLTYsLTUuMywtMTUsLTE0LC0yNywtMjZzMjUsLTMwLDI1LC0zMFxcbmMyNi43LC0zMi43LDUyLC02Myw3NiwtOTFzNTIsLTYwLDUyLC02MHMyMDgsNzIyLDIwOCw3MjJcXG5jNTYsLTE3NS4zLDEyNi4zLC0zOTcuMywyMTEsLTY2NmM4NC43LC0yNjguNywxNTMuOCwtNDg4LjIsMjA3LjUsLTY1OC41XFxuYzUzLjcsLTE3MC4zLDg0LjUsLTI2Ni44LDkyLjUsLTI4OS41elxcbk1cIiArICgxMDAxICsgZXh0cmFWaW5pY3VsdW0pICsgXCIgXCIgKyBoTGluZVBhZCArIFwiaDQwMDAwMHZcIiArICg0MCArIGV4dHJhVmluaWN1bHVtKSArIFwiaC00MDAwMDB6XCI7XG59O1xuXG52YXIgc3FydFNpemUzID0gZnVuY3Rpb24gc3FydFNpemUzKGV4dHJhVmluaWN1bHVtLCBoTGluZVBhZCkge1xuICAvLyBzaXplMyBpcyBmcm9tIGdseXBoIFUyMjFBIGluIHRoZSBmb250IEthVGVYX1NpemUzLVJlZ3VsYXJcbiAgcmV0dXJuIFwiTTQyNCxcIiArICgyMzk4ICsgZXh0cmFWaW5pY3VsdW0gKyBoTGluZVBhZCkgKyBcIlxcbmMtMS4zLC0wLjcsLTM4LjUsLTE3MiwtMTExLjUsLTUxNGMtNzMsLTM0MiwtMTA5LjgsLTUxMy4zLC0xMTAuNSwtNTE0XFxuYzAsLTIsLTEwLjcsMTQuMywtMzIsNDljLTQuNyw3LjMsLTkuOCwxNS43LC0xNS41LDI1Yy01LjcsOS4zLC05LjgsMTYsLTEyLjUsMjBcXG5zLTUsNywtNSw3Yy00LC0zLjMsLTguMywtNy43LC0xMywtMTNzLTEzLC0xMywtMTMsLTEzczc2LC0xMjIsNzYsLTEyMnM3NywtMTIxLDc3LC0xMjFcXG5zMjA5LDk2OCwyMDksOTY4YzAsLTIsODQuNywtMzYxLjcsMjU0LC0xMDc5YzE2OS4zLC03MTcuMywyNTQuNywtMTA3Ny43LDI1NiwtMTA4MVxcbmxcIiArIGV4dHJhVmluaWN1bHVtIC8gNC4yMjMgKyBcIiAtXCIgKyBleHRyYVZpbmljdWx1bSArIFwiYzQsLTYuNywxMCwtMTAsMTgsLTEwIEg0MDAwMDBcXG52XCIgKyAoNDAgKyBleHRyYVZpbmljdWx1bSkgKyBcIkgxMDE0LjZcXG5zLTg3LjMsMzc4LjcsLTI3Mi42LDExNjZjLTE4NS4zLDc4Ny4zLC0yNzkuMywxMTgyLjMsLTI4MiwxMTg1XFxuYy0yLDYsLTEwLDksLTI0LDlcXG5jLTgsMCwtMTIsLTAuNywtMTIsLTJ6IE1cIiArICgxMDAxICsgZXh0cmFWaW5pY3VsdW0pICsgXCIgXCIgKyBoTGluZVBhZCArIFwiXFxuaDQwMDAwMHZcIiArICg0MCArIGV4dHJhVmluaWN1bHVtKSArIFwiaC00MDAwMDB6XCI7XG59O1xuXG52YXIgc3FydFNpemU0ID0gZnVuY3Rpb24gc3FydFNpemU0KGV4dHJhVmluaWN1bHVtLCBoTGluZVBhZCkge1xuICAvLyBzaXplNCBpcyBmcm9tIGdseXBoIFUyMjFBIGluIHRoZSBmb250IEthVGVYX1NpemU0LVJlZ3VsYXJcbiAgcmV0dXJuIFwiTTQ3MyxcIiArICgyNzEzICsgZXh0cmFWaW5pY3VsdW0gKyBoTGluZVBhZCkgKyBcIlxcbmMzMzkuMywtMTc5OS4zLDUwOS4zLC0yNzAwLDUxMCwtMjcwMiBsXCIgKyBleHRyYVZpbmljdWx1bSAvIDUuMjk4ICsgXCIgLVwiICsgZXh0cmFWaW5pY3VsdW0gKyBcIlxcbmMzLjMsLTcuMyw5LjMsLTExLDE4LC0xMSBINDAwMDAwdlwiICsgKDQwICsgZXh0cmFWaW5pY3VsdW0pICsgXCJIMTAxNy43XFxucy05MC41LDQ3OCwtMjc2LjIsMTQ2NmMtMTg1LjcsOTg4LC0yNzkuNSwxNDgzLC0yODEuNSwxNDg1Yy0yLDYsLTEwLDksLTI0LDlcXG5jLTgsMCwtMTIsLTAuNywtMTIsLTJjMCwtMS4zLC01LjMsLTMyLC0xNiwtOTJjLTUwLjcsLTI5My4zLC0xMTkuNywtNjkzLjMsLTIwNywtMTIwMFxcbmMwLC0xLjMsLTUuMyw4LjcsLTE2LDMwYy0xMC43LDIxLjMsLTIxLjMsNDIuNywtMzIsNjRzLTE2LDMzLC0xNiwzM3MtMjYsLTI2LC0yNiwtMjZcXG5zNzYsLTE1Myw3NiwtMTUzczc3LC0xNTEsNzcsLTE1MWMwLjcsMC43LDM1LjcsMjAyLDEwNSw2MDRjNjcuMyw0MDAuNywxMDIsNjAyLjcsMTA0LFxcbjYwNnpNXCIgKyAoMTAwMSArIGV4dHJhVmluaWN1bHVtKSArIFwiIFwiICsgaExpbmVQYWQgKyBcImg0MDAwMDB2XCIgKyAoNDAgKyBleHRyYVZpbmljdWx1bSkgKyBcIkgxMDE3Ljd6XCI7XG59O1xuXG52YXIgc3FydFRhbGwgPSBmdW5jdGlvbiBzcXJ0VGFsbChleHRyYVZpbmljdWx1bSwgaExpbmVQYWQsIHZpZXdCb3hIZWlnaHQpIHtcbiAgLy8gc3FydFRhbGwgaXMgZnJvbSBnbHlwaCBVMjNCNyBpbiB0aGUgZm9udCBLYVRlWF9TaXplNC1SZWd1bGFyXG4gIC8vIE9uZSBwYXRoIGVkZ2UgaGFzIGEgdmFyaWFibGUgbGVuZ3RoLiBJdCBydW5zIHZlcnRpY2FsbHkgZnJvbSB0aGUgdmluaWN1bHVtblxuICAvLyB0byBhIHBvaW50IG5lYXIgKDE0IHVuaXRzKSB0aGUgYm90dG9tIG9mIHRoZSBzdXJkLiBUaGUgdmluaWN1bHVtXG4gIC8vIGlzIG5vcm1hbGx5IDQwIHVuaXRzIHRoaWNrLiBTbyB0aGUgbGVuZ3RoIG9mIHRoZSBsaW5lIGluIHF1ZXN0aW9uIGlzOlxuICB2YXIgdmVydFNlZ21lbnQgPSB2aWV3Qm94SGVpZ2h0IC0gNTQgLSBoTGluZVBhZCAtIGV4dHJhVmluaWN1bHVtO1xuICByZXR1cm4gXCJNNzAyIFwiICsgKGV4dHJhVmluaWN1bHVtICsgaExpbmVQYWQpICsgXCJINDAwMDAwXCIgKyAoNDAgKyBleHRyYVZpbmljdWx1bSkgKyBcIlxcbkg3NDJ2XCIgKyB2ZXJ0U2VnbWVudCArIFwibC00IDQtNCA0Yy0uNjY3LjcgLTIgMS41LTQgMi41cy00LjE2NyAxLjgzMy02LjUgMi41LTUuNSAxLTkuNSAxXFxuaC0xMmwtMjgtODRjLTE2LjY2Ny01Mi05Ni42NjcgLTI5NC4zMzMtMjQwLTcyN2wtMjEyIC02NDMgLTg1IDE3MFxcbmMtNC0zLjMzMy04LjMzMy03LjY2Ny0xMyAtMTNsLTEzLTEzbDc3LTE1NSA3Ny0xNTZjNjYgMTk5LjMzMyAxMzkgNDE5LjY2N1xcbjIxOSA2NjEgbDIxOCA2NjF6TTcwMiBcIiArIGhMaW5lUGFkICsgXCJINDAwMDAwdlwiICsgKDQwICsgZXh0cmFWaW5pY3VsdW0pICsgXCJINzQyelwiO1xufTtcblxudmFyIHNxcnRQYXRoID0gZnVuY3Rpb24gc3FydFBhdGgoc2l6ZSwgZXh0cmFWaW5pY3VsdW0sIHZpZXdCb3hIZWlnaHQpIHtcbiAgZXh0cmFWaW5pY3VsdW0gPSAxMDAwICogZXh0cmFWaW5pY3VsdW07IC8vIENvbnZlcnQgZnJvbSBkb2N1bWVudCBlbXMgdG8gdmlld0JveC5cblxuICB2YXIgcGF0aCA9IFwiXCI7XG5cbiAgc3dpdGNoIChzaXplKSB7XG4gICAgY2FzZSBcInNxcnRNYWluXCI6XG4gICAgICBwYXRoID0gc3FydE1haW4oZXh0cmFWaW5pY3VsdW0sIGhMaW5lUGFkKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInNxcnRTaXplMVwiOlxuICAgICAgcGF0aCA9IHNxcnRTaXplMShleHRyYVZpbmljdWx1bSwgaExpbmVQYWQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwic3FydFNpemUyXCI6XG4gICAgICBwYXRoID0gc3FydFNpemUyKGV4dHJhVmluaWN1bHVtLCBoTGluZVBhZCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJzcXJ0U2l6ZTNcIjpcbiAgICAgIHBhdGggPSBzcXJ0U2l6ZTMoZXh0cmFWaW5pY3VsdW0sIGhMaW5lUGFkKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInNxcnRTaXplNFwiOlxuICAgICAgcGF0aCA9IHNxcnRTaXplNChleHRyYVZpbmljdWx1bSwgaExpbmVQYWQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwic3FydFRhbGxcIjpcbiAgICAgIHBhdGggPSBzcXJ0VGFsbChleHRyYVZpbmljdWx1bSwgaExpbmVQYWQsIHZpZXdCb3hIZWlnaHQpO1xuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59O1xudmFyIHN2Z0dlb21ldHJ5X3BhdGggPSB7XG4gIC8vIFRoZSBkb3VibGVsZWZ0YXJyb3cgZ2VvbWV0cnkgaXMgZnJvbSBnbHlwaCBVKzIxRDAgaW4gdGhlIGZvbnQgS2FUZVggTWFpblxuICBkb3VibGVsZWZ0YXJyb3c6IFwiTTI2MiAxNTdcXG5sMTAtMTBjMzQtMzYgNjIuNy03NyA4Ni0xMjMgMy4zLTggNS0xMy4zIDUtMTYgMC01LjMtNi43LTgtMjAtOC03LjNcXG4gMC0xMi4yLjUtMTQuNSAxLjUtMi4zIDEtNC44IDQuNS03LjUgMTAuNS00OS4zIDk3LjMtMTIxLjcgMTY5LjMtMjE3IDIxNi0yOFxcbiAxNC01Ny4zIDI1LTg4IDMzLTYuNyAyLTExIDMuOC0xMyA1LjUtMiAxLjctMyA0LjItMyA3LjVzMSA1LjggMyA3LjVcXG5jMiAxLjcgNi4zIDMuNSAxMyA1LjUgNjggMTcuMyAxMjguMiA0Ny44IDE4MC41IDkxLjUgNTIuMyA0My43IDkzLjggOTYuMiAxMjQuNVxcbiAxNTcuNSA5LjMgOCAxNS4zIDEyLjMgMTggMTNoNmMxMi0uNyAxOC00IDE4LTEwIDAtMi0xLjctNy01LTE1LTIzLjMtNDYtNTItODdcXG4tODYtMTIzbC0xMC0xMGgzOTk3Mzh2LTQwSDIxOGMzMjggMCAwIDAgMCAwbC0xMC04Yy0yNi43LTIwLTY1LjctNDMtMTE3LTY5IDIuN1xcbi0yIDYtMy43IDEwLTUgMzYuNy0xNiA3Mi4zLTM3LjMgMTA3LTY0bDEwLThoMzk5Nzgydi00MHpcXG5tOCAwdjQwaDM5OTczMHYtNDB6bTAgMTk0djQwaDM5OTczMHYtNDB6XCIsXG4gIC8vIGRvdWJsZXJpZ2h0YXJyb3cgaXMgZnJvbSBnbHlwaCBVKzIxRDIgaW4gZm9udCBLYVRlWCBNYWluXG4gIGRvdWJsZXJpZ2h0YXJyb3c6IFwiTTM5OTczOCAzOTJsXFxuLTEwIDEwYy0zNCAzNi02Mi43IDc3LTg2IDEyMy0zLjMgOC01IDEzLjMtNSAxNiAwIDUuMyA2LjcgOCAyMCA4IDcuMyAwIDEyLjItLjVcXG4gMTQuNS0xLjUgMi4zLTEgNC44LTQuNSA3LjUtMTAuNSA0OS4zLTk3LjMgMTIxLjctMTY5LjMgMjE3LTIxNiAyOC0xNCA1Ny4zLTI1IDg4XFxuLTMzIDYuNy0yIDExLTMuOCAxMy01LjUgMi0xLjcgMy00LjIgMy03LjVzLTEtNS44LTMtNy41Yy0yLTEuNy02LjMtMy41LTEzLTUuNS02OFxcbi0xNy4zLTEyOC4yLTQ3LjgtMTgwLjUtOTEuNS01Mi4zLTQzLjctOTMuOC05Ni4yLTEyNC41LTE1Ny41LTkuMy04LTE1LjMtMTIuMy0xOFxcbi0xM2gtNmMtMTIgLjctMTggNC0xOCAxMCAwIDIgMS43IDcgNSAxNSAyMy4zIDQ2IDUyIDg3IDg2IDEyM2wxMCAxMEgwdjQwaDM5OTc4MlxcbmMtMzI4IDAgMCAwIDAgMGwxMCA4YzI2LjcgMjAgNjUuNyA0MyAxMTcgNjktMi43IDItNiAzLjctMTAgNS0zNi43IDE2LTcyLjMgMzcuM1xcbi0xMDcgNjRsLTEwIDhIMHY0MHpNMCAxNTd2NDBoMzk5NzMwdi00MHptMCAxOTR2NDBoMzk5NzMwdi00MHpcIixcbiAgLy8gbGVmdGFycm93IGlzIGZyb20gZ2x5cGggVSsyMTkwIGluIGZvbnQgS2FUZVggTWFpblxuICBsZWZ0YXJyb3c6IFwiTTQwMDAwMCAyNDFIMTEwbDMtM2M2OC43LTUyLjcgMTEzLjctMTIwXFxuIDEzNS0yMDIgNC0xNC43IDYtMjMgNi0yNSAwLTcuMy03LTExLTIxLTExLTggMC0xMy4yLjgtMTUuNSAyLjUtMi4zIDEuNy00LjIgNS44XFxuLTUuNSAxMi41LTEuMyA0LjctMi43IDEwLjMtNCAxNy0xMiA0OC43LTM0LjggOTItNjguNSAxMzBTNjUuMyAyMjguMyAxOCAyNDdcXG5jLTEwIDQtMTYgNy43LTE4IDExIDAgOC43IDYgMTQuMyAxOCAxNyA0Ny4zIDE4LjcgODcuOCA0NyAxMjEuNSA4NVMxOTYgNDQxLjMgMjA4XFxuIDQ5MGMuNyAyIDEuMyA1IDIgOXMxLjIgNi43IDEuNSA4Yy4zIDEuMyAxIDMuMyAyIDZzMi4yIDQuNSAzLjUgNS41YzEuMyAxIDMuM1xcbiAxLjggNiAyLjVzNiAxIDEwIDFjMTQgMCAyMS0zLjcgMjEtMTEgMC0yLTItMTAuMy02LTI1LTIwLTc5LjMtNjUtMTQ2LjctMTM1LTIwMlxcbiBsLTMtM2gzOTk4OTB6TTEwMCAyNDF2NDBoMzk5OTAwdi00MHpcIixcbiAgLy8gb3ZlcmJyYWNlIGlzIGZyb20gZ2x5cGhzIFUrMjNBOS8yM0E4LzIzQTcgaW4gZm9udCBLYVRlWF9TaXplNC1SZWd1bGFyXG4gIGxlZnRicmFjZTogXCJNNiA1NDhsLTYtNnYtMzVsNi0xMWM1Ni0xMDQgMTM1LjMtMTgxLjMgMjM4LTIzMiA1Ny4zLTI4LjcgMTE3XFxuLTQ1IDE3OS01MGgzOTk1Nzd2MTIwSDQwM2MtNDMuMyA3LTgxIDE1LTExMyAyNi0xMDAuNyAzMy0xNzkuNyA5MS0yMzcgMTc0LTIuN1xcbiA1LTYgOS0xMCAxMy0uNyAxLTcuMyAxLTIwIDFINnpcIixcbiAgbGVmdGJyYWNldW5kZXI6IFwiTTAgNmw2LTZoMTdjMTIuNjg4IDAgMTkuMzEzLjMgMjAgMSA0IDQgNy4zMTMgOC4zIDEwIDEzXFxuIDM1LjMxMyA1MS4zIDgwLjgxMyA5My44IDEzNi41IDEyNy41IDU1LjY4OCAzMy43IDExNy4xODggNTUuOCAxODQuNSA2Ni41LjY4OFxcbiAwIDIgLjMgNCAxIDE4LjY4OCAyLjcgNzYgNC4zIDE3MiA1aDM5OTQ1MHYxMjBINDI5bC02LTFjLTEyNC42ODgtOC0yMzUtNjEuN1xcbi0zMzEtMTYxQzYwLjY4NyAxMzguNyAzMi4zMTIgOTkuMyA3IDU0TDAgNDFWNnpcIixcbiAgLy8gb3Zlcmdyb3VwIGlzIGZyb20gdGhlIE1uU3ltYm9sIHBhY2thZ2UgKHB1YmxpYyBkb21haW4pXG4gIGxlZnRncm91cDogXCJNNDAwMDAwIDgwXFxuSDQzNUM2NCA4MCAxNjguMyAyMjkuNCAyMSAyNjBjLTUuOSAxLjItMTggMC0xOCAwLTIgMC0zLTEtMy0zdi0zOEM3NiA2MSAyNTcgMFxcbiA0MzUgMGgzOTk1NjV6XCIsXG4gIGxlZnRncm91cHVuZGVyOiBcIk00MDAwMDAgMjYyXFxuSDQzNUM2NCAyNjIgMTY4LjMgMTEyLjYgMjEgODJjLTUuOS0xLjItMTggMC0xOCAwLTIgMC0zIDEtMyAzdjM4Yzc2IDE1OCAyNTcgMjE5XFxuIDQzNSAyMTloMzk5NTY1elwiLFxuICAvLyBIYXJwb29ucyBhcmUgZnJvbSBnbHlwaCBVKzIxQkQgaW4gZm9udCBLYVRlWCBNYWluXG4gIGxlZnRoYXJwb29uOiBcIk0wIDI2N2MuNyA1LjMgMyAxMCA3IDE0aDM5OTk5M3YtNDBIOTNjMy4zXFxuLTMuMyAxMC4yLTkuNSAyMC41LTE4LjVzMTcuOC0xNS44IDIyLjUtMjAuNWM1MC43LTUyIDg4LTExMC4zIDExMi0xNzUgNC0xMS4zIDVcXG4tMTguMyAzLTIxLTEuMy00LTcuMy02LTE4LTYtOCAwLTEzIC43LTE1IDJzLTQuNyA2LjctOCAxNmMtNDIgOTguNy0xMDcuMyAxNzQuN1xcbi0xOTYgMjI4LTYuNyA0LjctMTAuNyA4LTEyIDEwLTEuMyAyLTIgNS43LTIgMTF6bTEwMC0yNnY0MGgzOTk5MDB2LTQwelwiLFxuICBsZWZ0aGFycG9vbnBsdXM6IFwiTTAgMjY3Yy43IDUuMyAzIDEwIDcgMTRoMzk5OTkzdi00MEg5M2MzLjMtMy4zIDEwLjItOS41XFxuIDIwLjUtMTguNXMxNy44LTE1LjggMjIuNS0yMC41YzUwLjctNTIgODgtMTEwLjMgMTEyLTE3NSA0LTExLjMgNS0xOC4zIDMtMjEtMS4zXFxuLTQtNy4zLTYtMTgtNi04IDAtMTMgLjctMTUgMnMtNC43IDYuNy04IDE2Yy00MiA5OC43LTEwNy4zIDE3NC43LTE5NiAyMjgtNi43IDQuN1xcbi0xMC43IDgtMTIgMTAtMS4zIDItMiA1LjctMiAxMXptMTAwLTI2djQwaDM5OTkwMHYtNDB6TTAgNDM1djQwaDQwMDAwMHYtNDB6XFxubTAgMHY0MGg0MDAwMDB2LTQwelwiLFxuICBsZWZ0aGFycG9vbmRvd246IFwiTTcgMjQxYy00IDQtNi4zMzMgOC42NjctNyAxNCAwIDUuMzMzLjY2NyA5IDIgMTFzNS4zMzNcXG4gNS4zMzMgMTIgMTBjOTAuNjY3IDU0IDE1NiAxMzAgMTk2IDIyOCAzLjMzMyAxMC42NjcgNi4zMzMgMTYuMzMzIDkgMTcgMiAuNjY3IDVcXG4gMSA5IDFoNWMxMC42NjcgMCAxNi42NjctMiAxOC02IDItMi42NjcgMS05LjY2Ny0zLTIxLTMyLTg3LjMzMy04Mi42NjctMTU3LjY2N1xcbi0xNTItMjExbC0zLTNoMzk5OTA3di00MHpNOTMgMjgxIEg0MDAwMDAgdi00MEw3IDI0MXpcIixcbiAgbGVmdGhhcnBvb25kb3ducGx1czogXCJNNyA0MzVjLTQgNC02LjMgOC43LTcgMTQgMCA1LjMuNyA5IDIgMTFzNS4zIDUuMyAxMlxcbiAxMGM5MC43IDU0IDE1NiAxMzAgMTk2IDIyOCAzLjMgMTAuNyA2LjMgMTYuMyA5IDE3IDIgLjcgNSAxIDkgMWg1YzEwLjcgMCAxNi43XFxuLTIgMTgtNiAyLTIuNyAxLTkuNy0zLTIxLTMyLTg3LjMtODIuNy0xNTcuNy0xNTItMjExbC0zLTNoMzk5OTA3di00MEg3em05MyAwXFxudjQwaDM5OTkwMHYtNDB6TTAgMjQxdjQwaDM5OTkwMHYtNDB6bTAgMHY0MGgzOTk5MDB2LTQwelwiLFxuICAvLyBob29rIGlzIGZyb20gZ2x5cGggVSsyMUE5IGluIGZvbnQgS2FUZVggTWFpblxuICBsZWZ0aG9vazogXCJNNDAwMDAwIDI4MSBIMTAzcy0zMy0xMS4yLTYxLTMzLjVTMCAxOTcuMyAwIDE2NHMxNC4yLTYxLjIgNDIuNVxcbi04My41QzcwLjggNTguMiAxMDQgNDcgMTQyIDQ3IGMxNi43IDAgMjUgNi43IDI1IDIwIDAgMTItOC43IDE4LjctMjYgMjAtNDAgMy4zXFxuLTY4LjcgMTUuNy04NiAzNy0xMCAxMi0xNSAyNS4zLTE1IDQwIDAgMjIuNyA5LjggNDAuNyAyOS41IDU0IDE5LjcgMTMuMyA0My41IDIxXFxuIDcxLjUgMjNoMzk5ODU5ek0xMDMgMjgxdi00MGgzOTk4OTd2NDB6XCIsXG4gIGxlZnRsaW5lc2VnbWVudDogXCJNNDAgMjgxIFY0MjggSDAgVjk0IEg0MCBWMjQxIEg0MDAwMDAgdjQwelxcbk00MCAyODEgVjQyOCBIMCBWOTQgSDQwIFYyNDEgSDQwMDAwMCB2NDB6XCIsXG4gIGxlZnRtYXBzdG86IFwiTTQwIDI4MSBWNDQ4SDBWNzRINDBWMjQxSDQwMDAwMHY0MHpcXG5NNDAgMjgxIFY0NDhIMFY3NEg0MFYyNDFINDAwMDAwdjQwelwiLFxuICAvLyB0b2Zyb20gaXMgZnJvbSBnbHlwaCBVKzIxQzQgaW4gZm9udCBLYVRlWCBBTVMgUmVndWxhclxuICBsZWZ0VG9Gcm9tOiBcIk0wIDE0N2g0MDAwMDB2NDBIMHptMCAyMTRjNjggNDAgMTE1LjcgOTUuNyAxNDMgMTY3aDIyYzE1LjMgMCAyM1xcbi0uMyAyMy0xIDAtMS4zLTUuMy0xMy43LTE2LTM3LTE4LTM1LjMtNDEuMy02OS03MC0xMDFsLTctOGgzOTk5MDV2LTQwSDk1bDctOFxcbmMyOC43LTMyIDUyLTY1LjcgNzAtMTAxIDEwLjctMjMuMyAxNi0zNS43IDE2LTM3IDAtLjctNy43LTEtMjMtMWgtMjJDMTE1LjcgMjY1LjNcXG4gNjggMzIxIDAgMzYxem0wLTE3NHYtNDBoMzk5OTAwdjQwem0xMDAgMTU0djQwaDM5OTkwMHYtNDB6XCIsXG4gIGxvbmdlcXVhbDogXCJNMCA1MCBoNDAwMDAwIHY0MEgweiBtMCAxOTRoNDAwMDB2NDBIMHpcXG5NMCA1MCBoNDAwMDAwIHY0MEgweiBtMCAxOTRoNDAwMDB2NDBIMHpcIixcbiAgbWlkYnJhY2U6IFwiTTIwMDQyOCAzMzRcXG5jLTEwMC43LTguMy0xOTUuMy00NC0yODAtMTA4LTU1LjMtNDItMTAxLjctOTMtMTM5LTE1M2wtOS0xNGMtMi43IDQtNS43IDguNy05IDE0XFxuLTUzLjMgODYuNy0xMjMuNyAxNTMtMjExIDE5OS02Ni43IDM2LTEzNy4zIDU2LjMtMjEyIDYySDBWMjE0aDE5OTU2OGMxNzguMy0xMS43XFxuIDMxMS43LTc4LjMgNDAzLTIwMSA2LTggOS43LTEyIDExLTEyIC43LS43IDYuNy0xIDE4LTFzMTcuMy4zIDE4IDFjMS4zIDAgNSA0IDExXFxuIDEyIDQ0LjcgNTkuMyAxMDEuMyAxMDYuMyAxNzAgMTQxczE0NS4zIDU0LjMgMjI5IDYwaDE5OTU3MnYxMjB6XCIsXG4gIG1pZGJyYWNldW5kZXI6IFwiTTE5OTU3MiAyMTRcXG5jMTAwLjcgOC4zIDE5NS4zIDQ0IDI4MCAxMDggNTUuMyA0MiAxMDEuNyA5MyAxMzkgMTUzbDkgMTRjMi43LTQgNS43LTguNyA5LTE0XFxuIDUzLjMtODYuNyAxMjMuNy0xNTMgMjExLTE5OSA2Ni43LTM2IDEzNy4zLTU2LjMgMjEyLTYyaDE5OTU2OHYxMjBIMjAwNDMyYy0xNzguM1xcbiAxMS43LTMxMS43IDc4LjMtNDAzIDIwMS02IDgtOS43IDEyLTExIDEyLS43LjctNi43IDEtMTggMXMtMTcuMy0uMy0xOC0xYy0xLjMgMFxcbi01LTQtMTEtMTItNDQuNy01OS4zLTEwMS4zLTEwNi4zLTE3MC0xNDFzLTE0NS4zLTU0LjMtMjI5LTYwSDBWMjE0elwiLFxuICBvaWludFNpemUxOiBcIk01MTIuNiA3MS42YzI3Mi42IDAgMzIwLjMgMTA2LjggMzIwLjMgMTc4LjIgMCA3MC44LTQ3LjcgMTc3LjZcXG4tMzIwLjMgMTc3LjZTMTkzLjEgMzIwLjYgMTkzLjEgMjQ5LjhjMC03MS40IDQ2LjktMTc4LjIgMzE5LjUtMTc4LjJ6XFxubTM2OC4xIDE3OC4yYzAtODYuNC02MC45LTIxNS40LTM2OC4xLTIxNS40LTMwNi40IDAtMzY3LjMgMTI5LTM2Ny4zIDIxNS40IDAgODUuOFxcbjYwLjkgMjE0LjggMzY3LjMgMjE0LjggMzA3LjIgMCAzNjguMS0xMjkgMzY4LjEtMjE0Ljh6XCIsXG4gIG9paW50U2l6ZTI6IFwiTTc1Ny44IDEwMC4xYzM4NC43IDAgNDUxLjEgMTM3LjYgNDUxLjEgMjMwIDAgOTEuMy02Ni40IDIyOC44XFxuLTQ1MS4xIDIyOC44LTM4Ni4zIDAtNDUyLjctMTM3LjUtNDUyLjctMjI4LjggMC05Mi40IDY2LjQtMjMwIDQ1Mi43LTIzMHpcXG5tNTAyLjQgMjMwYzAtMTExLjItODIuNC0yNzcuMi01MDIuNC0yNzcuMnMtNTA0IDE2Ni01MDQgMjc3LjJcXG5jMCAxMTAgODQgMjc2IDUwNCAyNzZzNTAyLjQtMTY2IDUwMi40LTI3NnpcIixcbiAgb2lpaW50U2l6ZTE6IFwiTTY4MS40IDcxLjZjNDA4LjkgMCA0ODAuNSAxMDYuOCA0ODAuNSAxNzguMiAwIDcwLjgtNzEuNiAxNzcuNlxcbi00ODAuNSAxNzcuNlMyMDIuMSAzMjAuNiAyMDIuMSAyNDkuOGMwLTcxLjQgNzAuNS0xNzguMiA0NzkuMy0xNzguMnpcXG5tNTI1LjggMTc4LjJjMC04Ni40LTg2LjgtMjE1LjQtNTI1LjctMjE1LjQtNDM3LjkgMC01MjQuNyAxMjktNTI0LjcgMjE1LjQgMFxcbjg1LjggODYuOCAyMTQuOCA1MjQuNyAyMTQuOCA0MzguOSAwIDUyNS43LTEyOSA1MjUuNy0yMTQuOHpcIixcbiAgb2lpaW50U2l6ZTI6IFwiTTEwMjEuMiA1M2M2MDMuNiAwIDcwNy44IDE2NS44IDcwNy44IDI3Ny4yIDAgMTEwLTEwNC4yIDI3NS44XFxuLTcwNy44IDI3NS44LTYwNiAwLTcxMC4yLTE2NS44LTcxMC4yLTI3NS44QzMxMSAyMTguOCA0MTUuMiA1MyAxMDIxLjIgNTN6XFxubTc3MC40IDI3Ny4xYzAtMTMxLjItMTI2LjQtMzI3LjYtNzcwLjUtMzI3LjZTMjQ4LjQgMTk4LjkgMjQ4LjQgMzMwLjFcXG5jMCAxMzAgMTI4LjggMzI2LjQgNzcyLjcgMzI2LjRzNzcwLjUtMTk2LjQgNzcwLjUtMzI2LjR6XCIsXG4gIHJpZ2h0YXJyb3c6IFwiTTAgMjQxdjQwaDM5OTg5MWMtNDcuMyAzNS4zLTg0IDc4LTExMCAxMjhcXG4tMTYuNyAzMi0yNy43IDYzLjctMzMgOTUgMCAxLjMtLjIgMi43LS41IDQtLjMgMS4zLS41IDIuMy0uNSAzIDAgNy4zIDYuNyAxMSAyMFxcbiAxMSA4IDAgMTMuMi0uOCAxNS41LTIuNSAyLjMtMS43IDQuMi01LjUgNS41LTExLjUgMi0xMy4zIDUuNy0yNyAxMS00MSAxNC43LTQ0LjdcXG4gMzktODQuNSA3My0xMTkuNXM3My43LTYwLjIgMTE5LTc1LjVjNi0yIDktNS43IDktMTFzLTMtOS05LTExYy00NS4zLTE1LjMtODVcXG4tNDAuNS0xMTktNzUuNXMtNTguMy03NC44LTczLTExOS41Yy00LjctMTQtOC4zLTI3LjMtMTEtNDAtMS4zLTYuNy0zLjItMTAuOC01LjVcXG4tMTIuNS0yLjMtMS43LTcuNS0yLjUtMTUuNS0yLjUtMTQgMC0yMSAzLjctMjEgMTEgMCAyIDIgMTAuMyA2IDI1IDIwLjcgODMuMyA2N1xcbiAxNTEuNyAxMzkgMjA1em0wIDB2NDBoMzk5OTAwdi00MHpcIixcbiAgcmlnaHRicmFjZTogXCJNNDAwMDAwIDU0MmxcXG4tNiA2aC0xN2MtMTIuNyAwLTE5LjMtLjMtMjAtMS00LTQtNy4zLTguMy0xMC0xMy0zNS4zLTUxLjMtODAuOC05My44LTEzNi41LTEyNy41XFxucy0xMTcuMi01NS44LTE4NC41LTY2LjVjLS43IDAtMi0uMy00LTEtMTguNy0yLjctNzYtNC4zLTE3Mi01SDBWMjE0aDM5OTU3MWw2IDFcXG5jMTI0LjcgOCAyMzUgNjEuNyAzMzEgMTYxIDMxLjMgMzMuMyA1OS43IDcyLjcgODUgMTE4bDcgMTN2MzV6XCIsXG4gIHJpZ2h0YnJhY2V1bmRlcjogXCJNMzk5OTk0IDBsNiA2djM1bC02IDExYy01NiAxMDQtMTM1LjMgMTgxLjMtMjM4IDIzMi01Ny4zXFxuIDI4LjctMTE3IDQ1LTE3OSA1MEgtMzAwVjIxNGgzOTk4OTdjNDMuMy03IDgxLTE1IDExMy0yNiAxMDAuNy0zMyAxNzkuNy05MSAyMzdcXG4tMTc0IDIuNy01IDYtOSAxMC0xMyAuNy0xIDcuMy0xIDIwLTFoMTd6XCIsXG4gIHJpZ2h0Z3JvdXA6IFwiTTAgODBoMzk5NTY1YzM3MSAwIDI2Ni43IDE0OS40IDQxNCAxODAgNS45IDEuMiAxOCAwIDE4IDAgMiAwXFxuIDMtMSAzLTN2LTM4Yy03Ni0xNTgtMjU3LTIxOS00MzUtMjE5SDB6XCIsXG4gIHJpZ2h0Z3JvdXB1bmRlcjogXCJNMCAyNjJoMzk5NTY1YzM3MSAwIDI2Ni43LTE0OS40IDQxNC0xODAgNS45LTEuMiAxOCAwIDE4XFxuIDAgMiAwIDMgMSAzIDN2MzhjLTc2IDE1OC0yNTcgMjE5LTQzNSAyMTlIMHpcIixcbiAgcmlnaHRoYXJwb29uOiBcIk0wIDI0MXY0MGgzOTk5OTNjNC43LTQuNyA3LTkuMyA3LTE0IDAtOS4zXFxuLTMuNy0xNS4zLTExLTE4LTkyLjctNTYuNy0xNTktMTMzLjctMTk5LTIzMS0zLjMtOS4zLTYtMTQuNy04LTE2LTItMS4zLTctMi0xNS0yXFxuLTEwLjcgMC0xNi43IDItMTggNi0yIDIuNy0xIDkuNyAzIDIxIDE1LjMgNDIgMzYuNyA4MS44IDY0IDExOS41IDI3LjMgMzcuNyA1OFxcbiA2OS4yIDkyIDk0LjV6bTAgMHY0MGgzOTk5MDB2LTQwelwiLFxuICByaWdodGhhcnBvb25wbHVzOiBcIk0wIDI0MXY0MGgzOTk5OTNjNC43LTQuNyA3LTkuMyA3LTE0IDAtOS4zLTMuNy0xNS4zLTExXFxuLTE4LTkyLjctNTYuNy0xNTktMTMzLjctMTk5LTIzMS0zLjMtOS4zLTYtMTQuNy04LTE2LTItMS4zLTctMi0xNS0yLTEwLjcgMC0xNi43XFxuIDItMTggNi0yIDIuNy0xIDkuNyAzIDIxIDE1LjMgNDIgMzYuNyA4MS44IDY0IDExOS41IDI3LjMgMzcuNyA1OCA2OS4yIDkyIDk0LjV6XFxubTAgMHY0MGgzOTk5MDB2LTQweiBtMTAwIDE5NHY0MGgzOTk5MDB2LTQwem0wIDB2NDBoMzk5OTAwdi00MHpcIixcbiAgcmlnaHRoYXJwb29uZG93bjogXCJNMzk5NzQ3IDUxMWMwIDcuMyA2LjcgMTEgMjAgMTEgOCAwIDEzLS44IDE1LTIuNXM0LjctNi44XFxuIDgtMTUuNWM0MC05NCA5OS4zLTE2Ni4zIDE3OC0yMTcgMTMuMy04IDIwLjMtMTIuMyAyMS0xMyA1LjMtMy4zIDguNS01LjggOS41XFxuLTcuNSAxLTEuNyAxLjUtNS4yIDEuNS0xMC41cy0yLjMtMTAuMy03LTE1SDB2NDBoMzk5OTA4Yy0zNCAyNS4zLTY0LjcgNTctOTIgOTVcXG4tMjcuMyAzOC00OC43IDc3LjctNjQgMTE5LTMuMyA4LjctNSAxNC01IDE2ek0wIDI0MXY0MGgzOTk5MDB2LTQwelwiLFxuICByaWdodGhhcnBvb25kb3ducGx1czogXCJNMzk5NzQ3IDcwNWMwIDcuMyA2LjcgMTEgMjAgMTEgOCAwIDEzLS44XFxuIDE1LTIuNXM0LjctNi44IDgtMTUuNWM0MC05NCA5OS4zLTE2Ni4zIDE3OC0yMTcgMTMuMy04IDIwLjMtMTIuMyAyMS0xMyA1LjMtMy4zXFxuIDguNS01LjggOS41LTcuNSAxLTEuNyAxLjUtNS4yIDEuNS0xMC41cy0yLjMtMTAuMy03LTE1SDB2NDBoMzk5OTA4Yy0zNCAyNS4zXFxuLTY0LjcgNTctOTIgOTUtMjcuMyAzOC00OC43IDc3LjctNjQgMTE5LTMuMyA4LjctNSAxNC01IDE2ek0wIDQzNXY0MGgzOTk5MDB2LTQwelxcbm0wLTE5NHY0MGg0MDAwMDB2LTQwem0wIDB2NDBoNDAwMDAwdi00MHpcIixcbiAgcmlnaHRob29rOiBcIk0zOTk4NTkgMjQxYy03NjQgMCAwIDAgMCAwIDQwLTMuMyA2OC43LTE1LjcgODYtMzcgMTAtMTIgMTUtMjUuM1xcbiAxNS00MCAwLTIyLjctOS44LTQwLjctMjkuNS01NC0xOS43LTEzLjMtNDMuNS0yMS03MS41LTIzLTE3LjMtMS4zLTI2LTgtMjYtMjAgMFxcbi0xMy4zIDguNy0yMCAyNi0yMCAzOCAwIDcxIDExLjIgOTkgMzMuNSAwIDAgNyA1LjYgMjEgMTYuNyAxNCAxMS4yIDIxIDMzLjUgMjFcXG4gNjYuOHMtMTQgNjEuMi00MiA4My41Yy0yOCAyMi4zLTYxIDMzLjUtOTkgMzMuNUwwIDI0MXogTTAgMjgxdi00MGgzOTk4NTl2NDB6XCIsXG4gIHJpZ2h0bGluZXNlZ21lbnQ6IFwiTTM5OTk2MCAyNDEgVjk0IGg0MCBWNDI4IGgtNDAgVjI4MSBIMCB2LTQwelxcbk0zOTk5NjAgMjQxIFY5NCBoNDAgVjQyOCBoLTQwIFYyODEgSDAgdi00MHpcIixcbiAgcmlnaHRUb0Zyb206IFwiTTQwMDAwMCAxNjdjLTcwLjctNDItMTE4LTk3LjctMTQyLTE2N2gtMjNjLTE1LjMgMC0yMyAuMy0yM1xcbiAxIDAgMS4zIDUuMyAxMy43IDE2IDM3IDE4IDM1LjMgNDEuMyA2OSA3MCAxMDFsNyA4SDB2NDBoMzk5OTA1bC03IDhjLTI4LjcgMzJcXG4tNTIgNjUuNy03MCAxMDEtMTAuNyAyMy4zLTE2IDM1LjctMTYgMzcgMCAuNyA3LjcgMSAyMyAxaDIzYzI0LTY5LjMgNzEuMy0xMjUgMTQyXFxuLTE2N3ogTTEwMCAxNDd2NDBoMzk5OTAwdi00MHpNMCAzNDF2NDBoMzk5OTAwdi00MHpcIixcbiAgLy8gdHdvaGVhZGxlZnRhcnJvdyBpcyBmcm9tIGdseXBoIFUrMjE5RSBpbiBmb250IEthVGVYIEFNUyBSZWd1bGFyXG4gIHR3b2hlYWRsZWZ0YXJyb3c6IFwiTTAgMTY3YzY4IDQwXFxuIDExNS43IDk1LjcgMTQzIDE2N2gyMmMxNS4zIDAgMjMtLjMgMjMtMSAwLTEuMy01LjMtMTMuNy0xNi0zNy0xOC0zNS4zLTQxLjMtNjlcXG4tNzAtMTAxbC03LThoMTI1bDkgN2M1MC43IDM5LjMgODUgODYgMTAzIDE0MGg0NmMwLTQuNy02LjMtMTguNy0xOS00Mi0xOC0zNS4zXFxuLTQwLTY3LjMtNjYtOTZsLTktOWgzOTk3MTZ2LTQwSDI4NGw5LTljMjYtMjguNyA0OC02MC43IDY2LTk2IDEyLjctMjMuMzMzIDE5XFxuLTM3LjMzMyAxOS00MmgtNDZjLTE4IDU0LTUyLjMgMTAwLjctMTAzIDE0MGwtOSA3SDk1bDctOGMyOC43LTMyIDUyLTY1LjcgNzAtMTAxXFxuIDEwLjctMjMuMzMzIDE2LTM1LjcgMTYtMzcgMC0uNy03LjctMS0yMy0xaC0yMkMxMTUuNyA3MS4zIDY4IDEyNyAwIDE2N3pcIixcbiAgdHdvaGVhZHJpZ2h0YXJyb3c6IFwiTTQwMDAwMCAxNjdcXG5jLTY4LTQwLTExNS43LTk1LjctMTQzLTE2N2gtMjJjLTE1LjMgMC0yMyAuMy0yMyAxIDAgMS4zIDUuMyAxMy43IDE2IDM3IDE4IDM1LjNcXG4gNDEuMyA2OSA3MCAxMDFsNyA4aC0xMjVsLTktN2MtNTAuNy0zOS4zLTg1LTg2LTEwMy0xNDBoLTQ2YzAgNC43IDYuMyAxOC43IDE5IDQyXFxuIDE4IDM1LjMgNDAgNjcuMyA2NiA5Nmw5IDlIMHY0MGgzOTk3MTZsLTkgOWMtMjYgMjguNy00OCA2MC43LTY2IDk2LTEyLjcgMjMuMzMzXFxuLTE5IDM3LjMzMy0xOSA0Mmg0NmMxOC01NCA1Mi4zLTEwMC43IDEwMy0xNDBsOS03aDEyNWwtNyA4Yy0yOC43IDMyLTUyIDY1LjctNzBcXG4gMTAxLTEwLjcgMjMuMzMzLTE2IDM1LjctMTYgMzcgMCAuNyA3LjcgMSAyMyAxaDIyYzI3LjMtNzEuMyA3NS0xMjcgMTQzLTE2N3pcIixcbiAgLy8gdGlsZGUxIGlzIGEgbW9kaWZpZWQgdmVyc2lvbiBvZiBhIGdseXBoIGZyb20gdGhlIE1uU3ltYm9sIHBhY2thZ2VcbiAgdGlsZGUxOiBcIk0yMDAgNTUuNTM4Yy03NyAwLTE2OCA3My45NTMtMTc3IDczLjk1My0zIDAtN1xcbi0yLjE3NS05LTUuNDM3TDIgOTdjLTEtMi0yLTQtMi02IDAtNCAyLTcgNS05bDIwLTEyQzExNiAxMiAxNzEgMCAyMDcgMGM4NiAwXFxuIDExNCA2OCAxOTEgNjggNzggMCAxNjgtNjggMTc3LTY4IDQgMCA3IDIgOSA1bDEyIDE5YzEgMi4xNzUgMiA0LjM1IDIgNi41MjUgMFxcbiA0LjM1LTIgNy42MTMtNSA5Ljc4OGwtMTkgMTMuMDVjLTkyIDYzLjA3Ny0xMTYuOTM3IDc1LjMwOC0xODMgNzYuMTI4XFxuLTY4LjI2Ny44NDctMTEzLTczLjk1Mi0xOTEtNzMuOTUyelwiLFxuICAvLyBkaXR0byB0aWxkZTIsIHRpbGRlMywgJiB0aWxkZTRcbiAgdGlsZGUyOiBcIk0zNDQgNTUuMjY2Yy0xNDIgMC0zMDAuNjM4IDgxLjMxNi0zMTEuNSA4Ni40MThcXG4tOC4wMSAzLjc2Mi0yMi41IDEwLjkxLTIzLjUgNS41NjJMMSAxMjBjLTEtMi0xLTMtMS00IDAtNSAzLTkgOC0xMGwxOC40LTlDMTYwLjlcXG4gMzEuOSAyODMgMCAzNTggMGMxNDggMCAxODggMTIyIDMzMSAxMjJzMzE0LTk3IDMyNi05N2M0IDAgOCAyIDEwIDdsNyAyMS4xMTRcXG5jMSAyLjE0IDEgMy4yMSAxIDQuMjggMCA1LjM0Ny0zIDkuNjI2LTcgMTAuNjk2bC0yMi4zIDEyLjYyMkM4NTIuNiAxNTguMzcyIDc1MVxcbiAxODEuNDc2IDY3NiAxODEuNDc2Yy0xNDkgMC0xODktMTI2LjIxLTMzMi0xMjYuMjF6XCIsXG4gIHRpbGRlMzogXCJNNzg2IDU5QzQ1NyA1OSAzMiAxNzUuMjQyIDEzIDE3NS4yNDJjLTYgMC0xMC0zLjQ1N1xcbi0xMS0xMC4zN0wuMTUgMTM4Yy0xLTcgMy0xMiAxMC0xM2wxOS4yLTYuNEMzNzguNCA0MC43IDYzNC4zIDAgODA0LjMgMGMzMzcgMFxcbiA0MTEuOCAxNTcgNzQ2LjggMTU3IDMyOCAwIDc1NC0xMTIgNzczLTExMiA1IDAgMTAgMyAxMSA5bDEgMTQuMDc1YzEgOC4wNjYtLjY5N1xcbiAxNi41OTUtNi42OTcgMTcuNDkybC0yMS4wNTIgNy4zMWMtMzY3LjkgOTguMTQ2LTYwOS4xNSAxMjIuNjk2LTc3OC4xNSAxMjIuNjk2XFxuIC0zMzggMC00MDktMTU2LjU3My03NDQtMTU2LjU3M3pcIixcbiAgdGlsZGU0OiBcIk03ODYgNThDNDU3IDU4IDMyIDE3Ny40ODcgMTMgMTc3LjQ4N2MtNiAwLTEwLTMuMzQ1XFxuLTExLTEwLjAzNUwuMTUgMTQzYy0xLTcgMy0xMiAxMC0xM2wyMi02LjdDMzgxLjIgMzUgNjM3LjE1IDAgODA3LjE1IDBjMzM3IDAgNDA5XFxuIDE3NyA3NDQgMTc3IDMyOCAwIDc1NC0xMjcgNzczLTEyNyA1IDAgMTAgMyAxMSA5bDEgMTQuNzk0YzEgNy44MDUtMyAxMy4zOC05XFxuIDE0LjQ5NWwtMjAuNyA1LjU3NGMtMzY2Ljg1IDk5Ljc5LTYwNy4zIDEzOS4zNzItNzc2LjMgMTM5LjM3Mi0zMzggMC00MDlcXG4gLTE3NS4yMzYtNzQ0LTE3NS4yMzZ6XCIsXG4gIC8vIHZlYyBpcyBmcm9tIGdseXBoIFUrMjBENyBpbiBmb250IEthVGVYIE1haW5cbiAgdmVjOiBcIk0zNzcgMjBjMC01LjMzMyAxLjgzMy0xMCA1LjUtMTRTMzkxIDAgMzk3IDBjNC42NjcgMCA4LjY2NyAxLjY2NyAxMiA1XFxuMy4zMzMgMi42NjcgNi42NjcgOSAxMCAxOSA2LjY2NyAyNC42NjcgMjAuMzMzIDQzLjY2NyA0MSA1NyA3LjMzMyA0LjY2NyAxMVxcbjEwLjY2NyAxMSAxOCAwIDYtMSAxMC0zIDEycy02LjY2NyA1LTE0IDljLTI4LjY2NyAxNC42NjctNTMuNjY3IDM1LjY2Ny03NSA2M1xcbi0xLjMzMyAxLjMzMy0zLjE2NyAzLjUtNS41IDYuNXMtNCA0LjgzMy01IDUuNWMtMSAuNjY3LTIuNSAxLjMzMy00LjUgMnMtNC4zMzMgMVxcbi03IDFjLTQuNjY3IDAtOS4xNjctMS44MzMtMTMuNS01LjVTMzM3IDE4NCAzMzcgMTc4YzAtMTIuNjY3IDE1LjY2Ny0zMi4zMzMgNDctNTlcXG5IMjEzbC0xNzEtMWMtOC42NjctNi0xMy0xMi4zMzMtMTMtMTkgMC00LjY2NyA0LjMzMy0xMS4zMzMgMTMtMjBoMzU5XFxuYy0xNi0yNS4zMzMtMjQtNDUtMjQtNTl6XCIsXG4gIC8vIHdpZGVoYXQxIGlzIGEgbW9kaWZpZWQgdmVyc2lvbiBvZiBhIGdseXBoIGZyb20gdGhlIE1uU3ltYm9sIHBhY2thZ2VcbiAgd2lkZWhhdDE6IFwiTTUyOSAwaDVsNTE5IDExNWM1IDEgOSA1IDkgMTAgMCAxLTEgMi0xIDNsLTQgMjJcXG5jLTEgNS01IDktMTEgOWgtMkw1MzIgNjcgMTkgMTU5aC0yYy01IDAtOS00LTExLTlsLTUtMjJjLTEtNiAyLTEyIDgtMTN6XCIsXG4gIC8vIGRpdHRvIHdpZGVoYXQyLCB3aWRlaGF0MywgJiB3aWRlaGF0NFxuICB3aWRlaGF0MjogXCJNMTE4MSAwaDJsMTE3MSAxNzZjNiAwIDEwIDUgMTAgMTFsLTIgMjNjLTEgNi01IDEwXFxuLTExIDEwaC0xTDExODIgNjcgMTUgMjIwaC0xYy02IDAtMTAtNC0xMS0xMGwtMi0yM2MtMS02IDQtMTEgMTAtMTF6XCIsXG4gIHdpZGVoYXQzOiBcIk0xMTgxIDBoMmwxMTcxIDIzNmM2IDAgMTAgNSAxMCAxMWwtMiAyM2MtMSA2LTUgMTBcXG4tMTEgMTBoLTFMMTE4MiA2NyAxNSAyODBoLTFjLTYgMC0xMC00LTExLTEwbC0yLTIzYy0xLTYgNC0xMSAxMC0xMXpcIixcbiAgd2lkZWhhdDQ6IFwiTTExODEgMGgybDExNzEgMjk2YzYgMCAxMCA1IDEwIDExbC0yIDIzYy0xIDYtNSAxMFxcbi0xMSAxMGgtMUwxMTgyIDY3IDE1IDM0MGgtMWMtNiAwLTEwLTQtMTEtMTBsLTItMjNjLTEtNiA0LTExIDEwLTExelwiLFxuICAvLyB3aWRlY2hlY2sgcGF0aHMgYXJlIGFsbCBpbnZlcnRlZCB2ZXJzaW9ucyBvZiB3aWRlaGF0XG4gIHdpZGVjaGVjazE6IFwiTTUyOSwxNTloNWw1MTksLTExNWM1LC0xLDksLTUsOSwtMTBjMCwtMSwtMSwtMiwtMSwtM2wtNCwtMjJjLTEsXFxuLTUsLTUsLTksLTExLC05aC0ybC01MTIsOTJsLTUxMywtOTJoLTJjLTUsMCwtOSw0LC0xMSw5bC01LDIyYy0xLDYsMiwxMiw4LDEzelwiLFxuICB3aWRlY2hlY2syOiBcIk0xMTgxLDIyMGgybDExNzEsLTE3NmM2LDAsMTAsLTUsMTAsLTExbC0yLC0yM2MtMSwtNiwtNSwtMTAsXFxuLTExLC0xMGgtMWwtMTE2OCwxNTNsLTExNjcsLTE1M2gtMWMtNiwwLC0xMCw0LC0xMSwxMGwtMiwyM2MtMSw2LDQsMTEsMTAsMTF6XCIsXG4gIHdpZGVjaGVjazM6IFwiTTExODEsMjgwaDJsMTE3MSwtMjM2YzYsMCwxMCwtNSwxMCwtMTFsLTIsLTIzYy0xLC02LC01LC0xMCxcXG4tMTEsLTEwaC0xbC0xMTY4LDIxM2wtMTE2NywtMjEzaC0xYy02LDAsLTEwLDQsLTExLDEwbC0yLDIzYy0xLDYsNCwxMSwxMCwxMXpcIixcbiAgd2lkZWNoZWNrNDogXCJNMTE4MSwzNDBoMmwxMTcxLC0yOTZjNiwwLDEwLC01LDEwLC0xMWwtMiwtMjNjLTEsLTYsLTUsLTEwLFxcbi0xMSwtMTBoLTFsLTExNjgsMjczbC0xMTY3LC0yNzNoLTFjLTYsMCwtMTAsNCwtMTEsMTBsLTIsMjNjLTEsNiw0LDExLDEwLDExelwiLFxuICAvLyBUaGUgbmV4dCB0ZW4gcGF0aHMgc3VwcG9ydCByZWFjdGlvbiBhcnJvd3MgZnJvbSB0aGUgbWhjaGVtIHBhY2thZ2UuXG4gIC8vIEFycm93cyBmb3IgXFxjZXs8LS0+fSBhcmUgb2Zmc2V0IGZyb20geEF4aXMgYnkgMC4yMmV4LCBwZXIgbWhjaGVtIGluIExhVGVYXG4gIC8vIGJhcmFib3ZlbGVmdGFycm93IGlzIG1vc3RseSBmcm9tIGZyb20gZ2x5cGggVSsyMTkwIGluIGZvbnQgS2FUZVggTWFpblxuICBiYXJhYm92ZWxlZnRhcnJvdzogXCJNNDAwMDAwIDYyMGgtMzk5ODkwbDMgLTNjNjguNyAtNTIuNyAxMTMuNyAtMTIwIDEzNSAtMjAyXFxuYzQgLTE0LjcgNiAtMjMgNiAtMjVjMCAtNy4zIC03IC0xMSAtMjEgLTExYy04IDAgLTEzLjIgMC44IC0xNS41IDIuNVxcbmMtMi4zIDEuNyAtNC4yIDUuOCAtNS41IDEyLjVjLTEuMyA0LjcgLTIuNyAxMC4zIC00IDE3Yy0xMiA0OC43IC0zNC44IDkyIC02OC41IDEzMFxcbnMtNzQuMiA2Ni4zIC0xMjEuNSA4NWMtMTAgNCAtMTYgNy43IC0xOCAxMWMwIDguNyA2IDE0LjMgMTggMTdjNDcuMyAxOC43IDg3LjggNDdcXG4xMjEuNSA4NXM1Ni41IDgxLjMgNjguNSAxMzBjMC43IDIgMS4zIDUgMiA5czEuMiA2LjcgMS41IDhjMC4zIDEuMyAxIDMuMyAyIDZcXG5zMi4yIDQuNSAzLjUgNS41YzEuMyAxIDMuMyAxLjggNiAyLjVzNiAxIDEwIDFjMTQgMCAyMSAtMy43IDIxIC0xMVxcbmMwIC0yIC0yIC0xMC4zIC02IC0yNWMtMjAgLTc5LjMgLTY1IC0xNDYuNyAtMTM1IC0yMDJsLTMgLTNoMzk5ODkwelxcbk0xMDAgNjIwdjQwaDM5OTkwMHYtNDB6IE0wIDI0MXY0MGgzOTk5MDB2LTQwek0wIDI0MXY0MGgzOTk5MDB2LTQwelwiLFxuICAvLyByaWdodGFycm93YWJvdmViYXIgaXMgbW9zdGx5IGZyb20gZ2x5cGggVSsyMTkyLCBLYVRlWCBNYWluXG4gIHJpZ2h0YXJyb3dhYm92ZWJhcjogXCJNMCAyNDF2NDBoMzk5ODkxYy00Ny4zIDM1LjMtODQgNzgtMTEwIDEyOC0xNi43IDMyXFxuLTI3LjcgNjMuNy0zMyA5NSAwIDEuMy0uMiAyLjctLjUgNC0uMyAxLjMtLjUgMi4zLS41IDMgMCA3LjMgNi43IDExIDIwIDExIDggMFxcbjEzLjItLjggMTUuNS0yLjUgMi4zLTEuNyA0LjItNS41IDUuNS0xMS41IDItMTMuMyA1LjctMjcgMTEtNDEgMTQuNy00NC43IDM5XFxuLTg0LjUgNzMtMTE5LjVzNzMuNy02MC4yIDExOS03NS41YzYtMiA5LTUuNyA5LTExcy0zLTktOS0xMWMtNDUuMy0xNS4zLTg1LTQwLjVcXG4tMTE5LTc1LjVzLTU4LjMtNzQuOC03My0xMTkuNWMtNC43LTE0LTguMy0yNy4zLTExLTQwLTEuMy02LjctMy4yLTEwLjgtNS41XFxuLTEyLjUtMi4zLTEuNy03LjUtMi41LTE1LjUtMi41LTE0IDAtMjEgMy43LTIxIDExIDAgMiAyIDEwLjMgNiAyNSAyMC43IDgzLjMgNjdcXG4xNTEuNyAxMzkgMjA1em05NiAzNzloMzk5ODk0djQwSDB6bTAgMGgzOTk5MDR2NDBIMHpcIixcbiAgLy8gVGhlIHNob3J0IGxlZnQgaGFycG9vbiBoYXMgMC41ZW0gKGkuZS4gNTAwIHVuaXRzKSBrZXJuIG9uIHRoZSBsZWZ0IGVuZC5cbiAgLy8gUmVmIGZyb20gbWhjaGVtLnN0eTogXFxybGFwe1xccmFpc2Vib3h7LS4yMmV4fXskXFxrZXJuMC41ZW1cbiAgYmFyYWJvdmVzaG9ydGxlZnRoYXJwb29uOiBcIk01MDcsNDM1Yy00LDQsLTYuMyw4LjcsLTcsMTRjMCw1LjMsMC43LDksMiwxMVxcbmMxLjMsMiw1LjMsNS4zLDEyLDEwYzkwLjcsNTQsMTU2LDEzMCwxOTYsMjI4YzMuMywxMC43LDYuMywxNi4zLDksMTdcXG5jMiwwLjcsNSwxLDksMWMwLDAsNSwwLDUsMGMxMC43LDAsMTYuNywtMiwxOCwtNmMyLC0yLjcsMSwtOS43LC0zLC0yMVxcbmMtMzIsLTg3LjMsLTgyLjcsLTE1Ny43LC0xNTIsLTIxMWMwLDAsLTMsLTMsLTMsLTNsMzk5MzUxLDBsMCwtNDBcXG5jLTM5ODU3MCwwLC0zOTk0MzcsMCwtMzk5NDM3LDB6IE01OTMgNDM1IHY0MCBIMzk5NTAwIHYtNDB6XFxuTTAgMjgxIHYtNDAgSDM5OTkwOCB2NDB6IE0wIDI4MSB2LTQwIEgzOTk5MDggdjQwelwiLFxuICByaWdodGhhcnBvb25hYm92ZXNob3J0YmFyOiBcIk0wLDI0MSBsMCw0MGMzOTkxMjYsMCwzOTk5OTMsMCwzOTk5OTMsMFxcbmM0LjcsLTQuNyw3LC05LjMsNywtMTRjMCwtOS4zLC0zLjcsLTE1LjMsLTExLC0xOGMtOTIuNywtNTYuNywtMTU5LC0xMzMuNywtMTk5LFxcbi0yMzFjLTMuMywtOS4zLC02LC0xNC43LC04LC0xNmMtMiwtMS4zLC03LC0yLC0xNSwtMmMtMTAuNywwLC0xNi43LDIsLTE4LDZcXG5jLTIsMi43LC0xLDkuNywzLDIxYzE1LjMsNDIsMzYuNyw4MS44LDY0LDExOS41YzI3LjMsMzcuNyw1OCw2OS4yLDkyLDk0LjV6XFxuTTAgMjQxIHY0MCBIMzk5OTA4IHYtNDB6IE0wIDQ3NSB2LTQwIEgzOTk1MDAgdjQweiBNMCA0NzUgdi00MCBIMzk5NTAwIHY0MHpcIixcbiAgc2hvcnRiYXJhYm92ZWxlZnRoYXJwb29uOiBcIk03LDQzNWMtNCw0LC02LjMsOC43LC03LDE0YzAsNS4zLDAuNyw5LDIsMTFcXG5jMS4zLDIsNS4zLDUuMywxMiwxMGM5MC43LDU0LDE1NiwxMzAsMTk2LDIyOGMzLjMsMTAuNyw2LjMsMTYuMyw5LDE3YzIsMC43LDUsMSw5LFxcbjFjMCwwLDUsMCw1LDBjMTAuNywwLDE2LjcsLTIsMTgsLTZjMiwtMi43LDEsLTkuNywtMywtMjFjLTMyLC04Ny4zLC04Mi43LC0xNTcuNyxcXG4tMTUyLC0yMTFjMCwwLC0zLC0zLC0zLC0zbDM5OTkwNywwbDAsLTQwYy0zOTkxMjYsMCwtMzk5OTkzLDAsLTM5OTk5Mywwelxcbk05MyA0MzUgdjQwIEg0MDAwMDAgdi00MHogTTUwMCAyNDEgdjQwIEg0MDAwMDAgdi00MHogTTUwMCAyNDEgdjQwIEg0MDAwMDAgdi00MHpcIixcbiAgc2hvcnRyaWdodGhhcnBvb25hYm92ZWJhcjogXCJNNTMsMjQxbDAsNDBjMzk4NTcwLDAsMzk5NDM3LDAsMzk5NDM3LDBcXG5jNC43LC00LjcsNywtOS4zLDcsLTE0YzAsLTkuMywtMy43LC0xNS4zLC0xMSwtMThjLTkyLjcsLTU2LjcsLTE1OSwtMTMzLjcsLTE5OSxcXG4tMjMxYy0zLjMsLTkuMywtNiwtMTQuNywtOCwtMTZjLTIsLTEuMywtNywtMiwtMTUsLTJjLTEwLjcsMCwtMTYuNywyLC0xOCw2XFxuYy0yLDIuNywtMSw5LjcsMywyMWMxNS4zLDQyLDM2LjcsODEuOCw2NCwxMTkuNWMyNy4zLDM3LjcsNTgsNjkuMiw5Miw5NC41elxcbk01MDAgMjQxIHY0MCBIMzk5NDA4IHYtNDB6IE01MDAgNDM1IHY0MCBINDAwMDAwIHYtNDB6XCJcbn07XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy90cmVlLmpzXG5cblxuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhIGRvY3VtZW50IGZyYWdtZW50LCB3aGljaCBjb250YWlucyBlbGVtZW50cywgYnV0IHdoZW5cbiAqIHBsYWNlZCBpbnRvIHRoZSBET00gZG9lc24ndCBoYXZlIGFueSByZXByZXNlbnRhdGlvbiBpdHNlbGYuIEl0IG9ubHkgY29udGFpbnNcbiAqIGNoaWxkcmVuIGFuZCBkb2Vzbid0IGhhdmUgYW55IERPTSBub2RlIHByb3BlcnRpZXMuXG4gKi9cbnZhciB0cmVlX0RvY3VtZW50RnJhZ21lbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvLyBIdG1sRG9tTm9kZVxuICAvLyBOZXZlciB1c2VkOyBuZWVkZWQgZm9yIHNhdGlzZnlpbmcgaW50ZXJmYWNlLlxuICBmdW5jdGlvbiBEb2N1bWVudEZyYWdtZW50KGNoaWxkcmVuKSB7XG4gICAgdGhpcy5jaGlsZHJlbiA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXB0aCA9IHZvaWQgMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMuY2xhc3NlcyA9IFtdO1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLmRlcHRoID0gMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gMDtcbiAgICB0aGlzLnN0eWxlID0ge307XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmhhc0NsYXNzID0gZnVuY3Rpb24gaGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIHV0aWxzLmNvbnRhaW5zKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKTtcbiAgfVxuICAvKiogQ29udmVydCB0aGUgZnJhZ21lbnQgaW50byBhIG5vZGUuICovXG4gIDtcblxuICBfcHJvdG8udG9Ob2RlID0gZnVuY3Rpb24gdG9Ob2RlKCkge1xuICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmcmFnLmFwcGVuZENoaWxkKHRoaXMuY2hpbGRyZW5baV0udG9Ob2RlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBmcmFnO1xuICB9XG4gIC8qKiBDb252ZXJ0IHRoZSBmcmFnbWVudCBpbnRvIEhUTUwgbWFya3VwLiAqL1xuICA7XG5cbiAgX3Byb3RvLnRvTWFya3VwID0gZnVuY3Rpb24gdG9NYXJrdXAoKSB7XG4gICAgdmFyIG1hcmt1cCA9IFwiXCI7IC8vIFNpbXBseSBjb25jYXRlbmF0ZSB0aGUgbWFya3VwIGZvciB0aGUgY2hpbGRyZW4gdG9nZXRoZXIuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1hcmt1cCArPSB0aGlzLmNoaWxkcmVuW2ldLnRvTWFya3VwKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIG1hdGggbm9kZSBpbnRvIGEgc3RyaW5nLCBzaW1pbGFyIHRvIGlubmVyVGV4dC4gQXBwbGllcyB0b1xuICAgKiBNYXRoRG9tTm9kZSdzIG9ubHkuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvVGV4dCA9IGZ1bmN0aW9uIHRvVGV4dCgpIHtcbiAgICAvLyBUbyBhdm9pZCB0aGlzLCB3ZSB3b3VsZCBzdWJjbGFzcyBkb2N1bWVudEZyYWdtZW50IHNlcGFyYXRlbHkgZm9yXG4gICAgLy8gTWF0aE1MLCBidXQgcG9seWZpbGxzIGZvciBzdWJjbGFzc2luZyBpcyBleHBlbnNpdmUgcGVyIFBSIDE0NjkuXG4gICAgLy8gJEZsb3dGaXhNZTogT25seSB3b3JrcyBmb3IgQ2hpbGRUeXBlID0gTWF0aERvbU5vZGUuXG4gICAgdmFyIHRvVGV4dCA9IGZ1bmN0aW9uIHRvVGV4dChjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkLnRvVGV4dCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5tYXAodG9UZXh0KS5qb2luKFwiXCIpO1xuICB9O1xuXG4gIHJldHVybiBEb2N1bWVudEZyYWdtZW50O1xufSgpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZG9tVHJlZS5qc1xuLyoqXG4gKiBUaGVzZSBvYmplY3RzIHN0b3JlIHRoZSBkYXRhIGFib3V0IHRoZSBET00gbm9kZXMgd2UgY3JlYXRlLCBhcyB3ZWxsIGFzIHNvbWVcbiAqIGV4dHJhIGRhdGEuIFRoZXkgY2FuIHRoZW4gYmUgdHJhbnNmb3JtZWQgaW50byByZWFsIERPTSBub2RlcyB3aXRoIHRoZVxuICogYHRvTm9kZWAgZnVuY3Rpb24gb3IgSFRNTCBtYXJrdXAgdXNpbmcgYHRvTWFya3VwYC4gVGhleSBhcmUgdXNlZnVsIGZvciBib3RoXG4gKiBzdG9yaW5nIGV4dHJhIHByb3BlcnRpZXMgb24gdGhlIG5vZGVzLCBhcyB3ZWxsIGFzIHByb3ZpZGluZyBhIHdheSB0byBlYXNpbHlcbiAqIHdvcmsgd2l0aCB0aGUgRE9NLlxuICpcbiAqIFNpbWlsYXIgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggTWF0aE1MIG5vZGVzIGV4aXN0IGluIG1hdGhNTFRyZWUuanMuXG4gKlxuICogVE9ETzogcmVmYWN0b3IgYHNwYW5gIGFuZCBgYW5jaG9yYCBpbnRvIGNvbW1vbiBzdXBlcmNsYXNzIHdoZW5cbiAqIHRhcmdldCBlbnZpcm9ubWVudHMgc3VwcG9ydCBjbGFzcyBpbmhlcml0YW5jZVxuICovXG5cblxuXG5cblxuLyoqXG4gKiBDcmVhdGUgYW4gSFRNTCBjbGFzc05hbWUgYmFzZWQgb24gYSBsaXN0IG9mIGNsYXNzZXMuIEluIGFkZGl0aW9uIHRvIGpvaW5pbmdcbiAqIHdpdGggc3BhY2VzLCB3ZSBhbHNvIHJlbW92ZSBlbXB0eSBjbGFzc2VzLlxuICovXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiBjcmVhdGVDbGFzcyhjbGFzc2VzKSB7XG4gIHJldHVybiBjbGFzc2VzLmZpbHRlcihmdW5jdGlvbiAoY2xzKSB7XG4gICAgcmV0dXJuIGNscztcbiAgfSkuam9pbihcIiBcIik7XG59O1xuXG52YXIgaW5pdE5vZGUgPSBmdW5jdGlvbiBpbml0Tm9kZShjbGFzc2VzLCBvcHRpb25zLCBzdHlsZSkge1xuICB0aGlzLmNsYXNzZXMgPSBjbGFzc2VzIHx8IFtdO1xuICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgdGhpcy5oZWlnaHQgPSAwO1xuICB0aGlzLmRlcHRoID0gMDtcbiAgdGhpcy5tYXhGb250U2l6ZSA9IDA7XG4gIHRoaXMuc3R5bGUgPSBzdHlsZSB8fCB7fTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnN0eWxlLmlzVGlnaHQoKSkge1xuICAgICAgdGhpcy5jbGFzc2VzLnB1c2goXCJtdGlnaHRcIik7XG4gICAgfVxuXG4gICAgdmFyIGNvbG9yID0gb3B0aW9ucy5nZXRDb2xvcigpO1xuXG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICB0aGlzLnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBDb252ZXJ0IGludG8gYW4gSFRNTCBub2RlXG4gKi9cblxuXG52YXIgX3RvTm9kZSA9IGZ1bmN0aW9uIHRvTm9kZSh0YWdOYW1lKSB7XG4gIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTsgLy8gQXBwbHkgdGhlIGNsYXNzXG5cbiAgbm9kZS5jbGFzc05hbWUgPSBjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpOyAvLyBBcHBseSBpbmxpbmUgc3R5bGVzXG5cbiAgZm9yICh2YXIgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgIGlmICh0aGlzLnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgLy8gJEZsb3dGaXhNZSBGbG93IGRvZXNuJ3Qgc2VlbSB0byB1bmRlcnN0YW5kIHNwYW4uc3R5bGUncyB0eXBlLlxuICAgICAgbm9kZS5zdHlsZVtzdHlsZV0gPSB0aGlzLnN0eWxlW3N0eWxlXTtcbiAgICB9XG4gIH0gLy8gQXBwbHkgYXR0cmlidXRlc1xuXG5cbiAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICBpZiAodGhpcy5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgIH1cbiAgfSAvLyBBcHBlbmQgdGhlIGNoaWxkcmVuLCBhbHNvIGFzIEhUTUwgbm9kZXNcblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG4vKipcbiAqIENvbnZlcnQgaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmdcbiAqL1xuXG5cbnZhciBfdG9NYXJrdXAgPSBmdW5jdGlvbiB0b01hcmt1cCh0YWdOYW1lKSB7XG4gIHZhciBtYXJrdXAgPSBcIjxcIiArIHRhZ05hbWU7IC8vIEFkZCB0aGUgY2xhc3NcblxuICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCkge1xuICAgIG1hcmt1cCArPSBcIiBjbGFzcz1cXFwiXCIgKyB1dGlscy5lc2NhcGUoY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKSkgKyBcIlxcXCJcIjtcbiAgfVxuXG4gIHZhciBzdHlsZXMgPSBcIlwiOyAvLyBBZGQgdGhlIHN0eWxlcywgYWZ0ZXIgaHlwaGVuYXRpb25cblxuICBmb3IgKHZhciBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgaWYgKHRoaXMuc3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICBzdHlsZXMgKz0gdXRpbHMuaHlwaGVuYXRlKHN0eWxlKSArIFwiOlwiICsgdGhpcy5zdHlsZVtzdHlsZV0gKyBcIjtcIjtcbiAgICB9XG4gIH1cblxuICBpZiAoc3R5bGVzKSB7XG4gICAgbWFya3VwICs9IFwiIHN0eWxlPVxcXCJcIiArIHV0aWxzLmVzY2FwZShzdHlsZXMpICsgXCJcXFwiXCI7XG4gIH0gLy8gQWRkIHRoZSBhdHRyaWJ1dGVzXG5cblxuICBmb3IgKHZhciBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgIGlmICh0aGlzLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgIG1hcmt1cCArPSBcIiBcIiArIGF0dHIgKyBcIj1cXFwiXCIgKyB1dGlscy5lc2NhcGUodGhpcy5hdHRyaWJ1dGVzW2F0dHJdKSArIFwiXFxcIlwiO1xuICAgIH1cbiAgfVxuXG4gIG1hcmt1cCArPSBcIj5cIjsgLy8gQWRkIHRoZSBtYXJrdXAgb2YgdGhlIGNoaWxkcmVuLCBhbHNvIGFzIG1hcmt1cFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIG1hcmt1cCArPSB0aGlzLmNoaWxkcmVuW2ldLnRvTWFya3VwKCk7XG4gIH1cblxuICBtYXJrdXAgKz0gXCI8L1wiICsgdGFnTmFtZSArIFwiPlwiO1xuICByZXR1cm4gbWFya3VwO1xufTsgLy8gTWFraW5nIHRoZSB0eXBlIGJlbG93IGV4YWN0IHdpdGggYWxsIG9wdGlvbmFsIGZpZWxkcyBkb2Vzbid0IHdvcmsgZHVlIHRvXG4vLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy80NTgyXG4vLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy81Njg4XG4vLyBIb3dldmVyLCBzaW5jZSAqYWxsKiBmaWVsZHMgYXJlIG9wdGlvbmFsLCAkU2hhcGU8PiB3b3JrcyBhcyBzdWdnZXN0ZWQgaW4gNTY4OFxuLy8gYWJvdmUuXG4vLyBUaGlzIHR5cGUgZG9lcyBub3QgaW5jbHVkZSBhbGwgQ1NTIHByb3BlcnRpZXMuIEFkZGl0aW9uYWwgcHJvcGVydGllcyBzaG91bGRcbi8vIGJlIGFkZGVkIGFzIG5lZWRlZC5cblxuXG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgc3BhbiBub2RlLCB3aXRoIGEgY2xhc3NOYW1lLCBhIGxpc3Qgb2YgY2hpbGRyZW4sIGFuZFxuICogYW4gaW5saW5lIHN0eWxlLiBJdCBhbHNvIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IGl0cyBoZWlnaHQsIGRlcHRoLCBhbmRcbiAqIG1heEZvbnRTaXplLlxuICpcbiAqIFJlcHJlc2VudHMgdHdvIHR5cGVzIHdpdGggZGlmZmVyZW50IHVzZXM6IFN2Z1NwYW4gdG8gd3JhcCBhbiBTVkcgYW5kIERvbVNwYW5cbiAqIG90aGVyd2lzZS4gVGhpcyB0eXBlc2FmZXR5IGlzIGltcG9ydGFudCB3aGVuIEhUTUwgYnVpbGRlcnMgYWNjZXNzIGEgc3BhbidzXG4gKiBjaGlsZHJlbi5cbiAqL1xudmFyIGRvbVRyZWVfU3BhbiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNwYW4oY2xhc3NlcywgY2hpbGRyZW4sIG9wdGlvbnMsIHN0eWxlKSB7XG4gICAgdGhpcy5jaGlsZHJlbiA9IHZvaWQgMDtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5jbGFzc2VzID0gdm9pZCAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gdm9pZCAwO1xuICAgIHRoaXMuZGVwdGggPSB2b2lkIDA7XG4gICAgdGhpcy53aWR0aCA9IHZvaWQgMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgaW5pdE5vZGUuY2FsbCh0aGlzLCBjbGFzc2VzLCBvcHRpb25zLCBzdHlsZSk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuIHx8IFtdO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGFuIGFyYml0cmFyeSBhdHRyaWJ1dGUgb24gdGhlIHNwYW4uIFdhcm5pbmc6IHVzZSB0aGlzIHdpc2VseS4gTm90XG4gICAqIGFsbCBicm93c2VycyBzdXBwb3J0IGF0dHJpYnV0ZXMgdGhlIHNhbWUsIGFuZCBoYXZpbmcgdG9vIG1hbnkgY3VzdG9tXG4gICAqIGF0dHJpYnV0ZXMgaXMgcHJvYmFibHkgYmFkLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBTcGFuLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IHZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5oYXNDbGFzcyA9IGZ1bmN0aW9uIGhhc0NsYXNzKGNsYXNzTmFtZSkge1xuICAgIHJldHVybiB1dGlscy5jb250YWlucyh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvTm9kZSA9IGZ1bmN0aW9uIHRvTm9kZSgpIHtcbiAgICByZXR1cm4gX3RvTm9kZS5jYWxsKHRoaXMsIFwic3BhblwiKTtcbiAgfTtcblxuICBfcHJvdG8udG9NYXJrdXAgPSBmdW5jdGlvbiB0b01hcmt1cCgpIHtcbiAgICByZXR1cm4gX3RvTWFya3VwLmNhbGwodGhpcywgXCJzcGFuXCIpO1xuICB9O1xuXG4gIHJldHVybiBTcGFuO1xufSgpO1xuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhbiBhbmNob3IgKDxhPikgZWxlbWVudCB3aXRoIGEgaHlwZXJsaW5rLiAgU2VlIGBzcGFuYFxuICogZm9yIGZ1cnRoZXIgZGV0YWlscy5cbiAqL1xuXG52YXIgZG9tVHJlZV9BbmNob3IgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBbmNob3IoaHJlZiwgY2xhc3NlcywgY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gdm9pZCAwO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXB0aCA9IHZvaWQgMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgaW5pdE5vZGUuY2FsbCh0aGlzLCBjbGFzc2VzLCBvcHRpb25zKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgW107XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gQW5jaG9yLnByb3RvdHlwZTtcblxuICBfcHJvdG8yLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSB2YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8yLmhhc0NsYXNzID0gZnVuY3Rpb24gaGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIHV0aWxzLmNvbnRhaW5zKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKTtcbiAgfTtcblxuICBfcHJvdG8yLnRvTm9kZSA9IGZ1bmN0aW9uIHRvTm9kZSgpIHtcbiAgICByZXR1cm4gX3RvTm9kZS5jYWxsKHRoaXMsIFwiYVwiKTtcbiAgfTtcblxuICBfcHJvdG8yLnRvTWFya3VwID0gZnVuY3Rpb24gdG9NYXJrdXAoKSB7XG4gICAgcmV0dXJuIF90b01hcmt1cC5jYWxsKHRoaXMsIFwiYVwiKTtcbiAgfTtcblxuICByZXR1cm4gQW5jaG9yO1xufSgpO1xuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhbiBpbWFnZSBlbWJlZCAoPGltZz4pIGVsZW1lbnQuXG4gKi9cblxudmFyIGRvbVRyZWVfSW1nID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW1nKHNyYywgYWx0LCBzdHlsZSkge1xuICAgIHRoaXMuc3JjID0gdm9pZCAwO1xuICAgIHRoaXMuYWx0ID0gdm9pZCAwO1xuICAgIHRoaXMuY2xhc3NlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmhlaWdodCA9IHZvaWQgMDtcbiAgICB0aGlzLmRlcHRoID0gdm9pZCAwO1xuICAgIHRoaXMubWF4Rm9udFNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHlsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmFsdCA9IGFsdDtcbiAgICB0aGlzLnNyYyA9IHNyYztcbiAgICB0aGlzLmNsYXNzZXMgPSBbXCJtb3JkXCJdO1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgfVxuXG4gIHZhciBfcHJvdG8zID0gSW1nLnByb3RvdHlwZTtcblxuICBfcHJvdG8zLmhhc0NsYXNzID0gZnVuY3Rpb24gaGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIHV0aWxzLmNvbnRhaW5zKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKTtcbiAgfTtcblxuICBfcHJvdG8zLnRvTm9kZSA9IGZ1bmN0aW9uIHRvTm9kZSgpIHtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgbm9kZS5zcmMgPSB0aGlzLnNyYztcbiAgICBub2RlLmFsdCA9IHRoaXMuYWx0O1xuICAgIG5vZGUuY2xhc3NOYW1lID0gXCJtb3JkXCI7IC8vIEFwcGx5IGlubGluZSBzdHlsZXNcblxuICAgIGZvciAodmFyIHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgIGlmICh0aGlzLnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIG5vZGUuc3R5bGVbc3R5bGVdID0gdGhpcy5zdHlsZVtzdHlsZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvMy50b01hcmt1cCA9IGZ1bmN0aW9uIHRvTWFya3VwKCkge1xuICAgIHZhciBtYXJrdXAgPSBcIjxpbWcgIHNyYz0nXCIgKyB0aGlzLnNyYyArIFwiICdhbHQ9J1wiICsgdGhpcy5hbHQgKyBcIicgXCI7IC8vIEFkZCB0aGUgc3R5bGVzLCBhZnRlciBoeXBoZW5hdGlvblxuXG4gICAgdmFyIHN0eWxlcyA9IFwiXCI7XG5cbiAgICBmb3IgKHZhciBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgc3R5bGVzICs9IHV0aWxzLmh5cGhlbmF0ZShzdHlsZSkgKyBcIjpcIiArIHRoaXMuc3R5bGVbc3R5bGVdICsgXCI7XCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlcykge1xuICAgICAgbWFya3VwICs9IFwiIHN0eWxlPVxcXCJcIiArIHV0aWxzLmVzY2FwZShzdHlsZXMpICsgXCJcXFwiXCI7XG4gICAgfVxuXG4gICAgbWFya3VwICs9IFwiJy8+XCI7XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfTtcblxuICByZXR1cm4gSW1nO1xufSgpO1xudmFyIGlDb21iaW5hdGlvbnMgPSB7XG4gICfDric6IFwiXFx1MDEzMVxcdTAzMDJcIixcbiAgJ8OvJzogXCJcXHUwMTMxXFx1MDMwOFwiLFxuICAnw60nOiBcIlxcdTAxMzFcXHUwMzAxXCIsXG4gIC8vICfEqyc6ICdcXHUwMTMxXFx1MDMwNCcsIC8vIGVuYWJsZSB3aGVuIHdlIGFkZCBFeHRlbmRlZCBMYXRpblxuICAnw6wnOiBcIlxcdTAxMzFcXHUwMzAwXCJcbn07XG4vKipcbiAqIEEgc3ltYm9sIG5vZGUgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgYSBzaW5nbGUgc3ltYm9sLiBJdCBlaXRoZXIgcmVuZGVyc1xuICogdG8gYSBzaW5nbGUgdGV4dCBub2RlLCBvciBhIHNwYW4gd2l0aCBhIHNpbmdsZSB0ZXh0IG5vZGUgaW4gaXQsIGRlcGVuZGluZyBvblxuICogd2hldGhlciBpdCBoYXMgQ1NTIGNsYXNzZXMsIHN0eWxlcywgb3IgbmVlZHMgaXRhbGljIGNvcnJlY3Rpb24uXG4gKi9cblxudmFyIGRvbVRyZWVfU3ltYm9sTm9kZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN5bWJvbE5vZGUodGV4dCwgaGVpZ2h0LCBkZXB0aCwgaXRhbGljLCBza2V3LCB3aWR0aCwgY2xhc3Nlcywgc3R5bGUpIHtcbiAgICB0aGlzLnRleHQgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXB0aCA9IHZvaWQgMDtcbiAgICB0aGlzLml0YWxpYyA9IHZvaWQgMDtcbiAgICB0aGlzLnNrZXcgPSB2b2lkIDA7XG4gICAgdGhpcy53aWR0aCA9IHZvaWQgMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gdm9pZCAwO1xuICAgIHRoaXMuY2xhc3NlcyA9IHZvaWQgMDtcbiAgICB0aGlzLnN0eWxlID0gdm9pZCAwO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgMDtcbiAgICB0aGlzLmRlcHRoID0gZGVwdGggfHwgMDtcbiAgICB0aGlzLml0YWxpYyA9IGl0YWxpYyB8fCAwO1xuICAgIHRoaXMuc2tldyA9IHNrZXcgfHwgMDtcbiAgICB0aGlzLndpZHRoID0gd2lkdGggfHwgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSBjbGFzc2VzIHx8IFtdO1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZSB8fCB7fTtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gMDsgLy8gTWFyayB0ZXh0IGZyb20gbm9uLUxhdGluIHNjcmlwdHMgd2l0aCBzcGVjaWZpYyBjbGFzc2VzIHNvIHRoYXQgd2VcbiAgICAvLyBjYW4gc3BlY2lmeSB3aGljaCBmb250cyB0byB1c2UuICBUaGlzIGFsbG93cyB1cyB0byByZW5kZXIgdGhlc2VcbiAgICAvLyBjaGFyYWN0ZXJzIHdpdGggYSBzZXJpZiBmb250IGluIHNpdHVhdGlvbnMgd2hlcmUgdGhlIGJyb3dzZXIgd291bGRcbiAgICAvLyBlaXRoZXIgZGVmYXVsdCB0byBhIHNhbnMgc2VyaWYgb3IgcmVuZGVyIGEgcGxhY2Vob2xkZXIgY2hhcmFjdGVyLlxuICAgIC8vIFdlIHVzZSBDU1MgY2xhc3MgbmFtZXMgbGlrZSBjamtfZmFsbGJhY2ssIGhhbmd1bF9mYWxsYmFjayBhbmRcbiAgICAvLyBicmFobWljX2ZhbGxiYWNrLiBTZWUgLi91bmljb2RlU2NyaXB0cy5qcyBmb3IgdGhlIHNldCBvZiBwb3NzaWJsZVxuICAgIC8vIHNjcmlwdCBuYW1lc1xuXG4gICAgdmFyIHNjcmlwdCA9IHNjcmlwdEZyb21Db2RlcG9pbnQodGhpcy50ZXh0LmNoYXJDb2RlQXQoMCkpO1xuXG4gICAgaWYgKHNjcmlwdCkge1xuICAgICAgdGhpcy5jbGFzc2VzLnB1c2goc2NyaXB0ICsgXCJfZmFsbGJhY2tcIik7XG4gICAgfVxuXG4gICAgaWYgKC9bw67Dr8Otw6xdLy50ZXN0KHRoaXMudGV4dCkpIHtcbiAgICAgIC8vIGFkZCDEqyB3aGVuIHdlIGFkZCBFeHRlbmRlZCBMYXRpblxuICAgICAgdGhpcy50ZXh0ID0gaUNvbWJpbmF0aW9uc1t0aGlzLnRleHRdO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcHJvdG80ID0gU3ltYm9sTm9kZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvNC5oYXNDbGFzcyA9IGZ1bmN0aW9uIGhhc0NsYXNzKGNsYXNzTmFtZSkge1xuICAgIHJldHVybiB1dGlscy5jb250YWlucyh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0ZXh0IG5vZGUgb3Igc3BhbiBmcm9tIGEgc3ltYm9sIG5vZGUuIE5vdGUgdGhhdCBhIHNwYW4gaXMgb25seVxuICAgKiBjcmVhdGVkIGlmIGl0IGlzIG5lZWRlZC5cbiAgICovXG4gIDtcblxuICBfcHJvdG80LnRvTm9kZSA9IGZ1bmN0aW9uIHRvTm9kZSgpIHtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudGV4dCk7XG4gICAgdmFyIHNwYW4gPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuaXRhbGljID4gMCkge1xuICAgICAgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgc3Bhbi5zdHlsZS5tYXJnaW5SaWdodCA9IHRoaXMuaXRhbGljICsgXCJlbVwiO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3BhbiA9IHNwYW4gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBzcGFuLmNsYXNzTmFtZSA9IGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3Nlcyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgICAgaWYgKHRoaXMuc3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgIHNwYW4gPSBzcGFuIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpOyAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBzZWVtIHRvIHVuZGVyc3RhbmQgc3Bhbi5zdHlsZSdzIHR5cGUuXG5cbiAgICAgICAgc3Bhbi5zdHlsZVtzdHlsZV0gPSB0aGlzLnN0eWxlW3N0eWxlXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3Bhbikge1xuICAgICAgc3Bhbi5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgIHJldHVybiBzcGFuO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBhIHN5bWJvbCBub2RlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzQudG9NYXJrdXAgPSBmdW5jdGlvbiB0b01hcmt1cCgpIHtcbiAgICAvLyBUT0RPKGFscGVydCk6IE1vcmUgZHVwbGljYXRpb24gdGhhbiBJJ2QgbGlrZSBmcm9tXG4gICAgLy8gc3Bhbi5wcm90b3R5cGUudG9NYXJrdXAgYW5kIHN5bWJvbE5vZGUucHJvdG90eXBlLnRvTm9kZS4uLlxuICAgIHZhciBuZWVkc1NwYW4gPSBmYWxzZTtcbiAgICB2YXIgbWFya3VwID0gXCI8c3BhblwiO1xuXG4gICAgaWYgKHRoaXMuY2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgIG5lZWRzU3BhbiA9IHRydWU7XG4gICAgICBtYXJrdXAgKz0gXCIgY2xhc3M9XFxcIlwiO1xuICAgICAgbWFya3VwICs9IHV0aWxzLmVzY2FwZShjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpKTtcbiAgICAgIG1hcmt1cCArPSBcIlxcXCJcIjtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGVzID0gXCJcIjtcblxuICAgIGlmICh0aGlzLml0YWxpYyA+IDApIHtcbiAgICAgIHN0eWxlcyArPSBcIm1hcmdpbi1yaWdodDpcIiArIHRoaXMuaXRhbGljICsgXCJlbTtcIjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgc3R5bGVzICs9IHV0aWxzLmh5cGhlbmF0ZShzdHlsZSkgKyBcIjpcIiArIHRoaXMuc3R5bGVbc3R5bGVdICsgXCI7XCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlcykge1xuICAgICAgbmVlZHNTcGFuID0gdHJ1ZTtcbiAgICAgIG1hcmt1cCArPSBcIiBzdHlsZT1cXFwiXCIgKyB1dGlscy5lc2NhcGUoc3R5bGVzKSArIFwiXFxcIlwiO1xuICAgIH1cblxuICAgIHZhciBlc2NhcGVkID0gdXRpbHMuZXNjYXBlKHRoaXMudGV4dCk7XG5cbiAgICBpZiAobmVlZHNTcGFuKSB7XG4gICAgICBtYXJrdXAgKz0gXCI+XCI7XG4gICAgICBtYXJrdXAgKz0gZXNjYXBlZDtcbiAgICAgIG1hcmt1cCArPSBcIjwvc3Bhbj5cIjtcbiAgICAgIHJldHVybiBtYXJrdXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlc2NhcGVkO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU3ltYm9sTm9kZTtcbn0oKTtcbi8qKlxuICogU1ZHIG5vZGVzIGFyZSB1c2VkIHRvIHJlbmRlciBzdHJldGNoeSB3aWRlIGVsZW1lbnRzLlxuICovXG5cbnZhciBTdmdOb2RlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3ZnTm9kZShjaGlsZHJlbiwgYXR0cmlidXRlcykge1xuICAgIHRoaXMuY2hpbGRyZW4gPSB2b2lkIDA7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gdm9pZCAwO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuICB9XG5cbiAgdmFyIF9wcm90bzUgPSBTdmdOb2RlLnByb3RvdHlwZTtcblxuICBfcHJvdG81LnRvTm9kZSA9IGZ1bmN0aW9uIHRvTm9kZSgpIHtcbiAgICB2YXIgc3ZnTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIFwic3ZnXCIpOyAvLyBBcHBseSBhdHRyaWJ1dGVzXG5cbiAgICBmb3IgKHZhciBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIHRoaXMuYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMuY2hpbGRyZW5baV0udG9Ob2RlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90bzUudG9NYXJrdXAgPSBmdW5jdGlvbiB0b01hcmt1cCgpIHtcbiAgICB2YXIgbWFya3VwID0gXCI8c3ZnXCI7IC8vIEFwcGx5IGF0dHJpYnV0ZXNcblxuICAgIGZvciAodmFyIGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXR0cmlidXRlcywgYXR0cikpIHtcbiAgICAgICAgbWFya3VwICs9IFwiIFwiICsgYXR0ciArIFwiPSdcIiArIHRoaXMuYXR0cmlidXRlc1thdHRyXSArIFwiJ1wiO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIj5cIjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbWFya3VwICs9IHRoaXMuY2hpbGRyZW5baV0udG9NYXJrdXAoKTtcbiAgICB9XG5cbiAgICBtYXJrdXAgKz0gXCI8L3N2Zz5cIjtcbiAgICByZXR1cm4gbWFya3VwO1xuICB9O1xuXG4gIHJldHVybiBTdmdOb2RlO1xufSgpO1xudmFyIGRvbVRyZWVfUGF0aE5vZGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYXRoTm9kZShwYXRoTmFtZSwgYWx0ZXJuYXRlKSB7XG4gICAgdGhpcy5wYXRoTmFtZSA9IHZvaWQgMDtcbiAgICB0aGlzLmFsdGVybmF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnBhdGhOYW1lID0gcGF0aE5hbWU7XG4gICAgdGhpcy5hbHRlcm5hdGUgPSBhbHRlcm5hdGU7IC8vIFVzZWQgb25seSBmb3IgXFxzcXJ0XG4gIH1cblxuICB2YXIgX3Byb3RvNiA9IFBhdGhOb2RlLnByb3RvdHlwZTtcblxuICBfcHJvdG82LnRvTm9kZSA9IGZ1bmN0aW9uIHRvTm9kZSgpIHtcbiAgICB2YXIgc3ZnTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIFwicGF0aFwiKTtcblxuICAgIGlmICh0aGlzLmFsdGVybmF0ZSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkXCIsIHRoaXMuYWx0ZXJuYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkXCIsIHN2Z0dlb21ldHJ5X3BhdGhbdGhpcy5wYXRoTmFtZV0pO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90bzYudG9NYXJrdXAgPSBmdW5jdGlvbiB0b01hcmt1cCgpIHtcbiAgICBpZiAodGhpcy5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiBcIjxwYXRoIGQ9J1wiICsgdGhpcy5hbHRlcm5hdGUgKyBcIicvPlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCI8cGF0aCBkPSdcIiArIHN2Z0dlb21ldHJ5X3BhdGhbdGhpcy5wYXRoTmFtZV0gKyBcIicvPlwiO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUGF0aE5vZGU7XG59KCk7XG52YXIgTGluZU5vZGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMaW5lTm9kZShhdHRyaWJ1dGVzKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gdm9pZCAwO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgfHwge307XG4gIH1cblxuICB2YXIgX3Byb3RvNyA9IExpbmVOb2RlLnByb3RvdHlwZTtcblxuICBfcHJvdG83LnRvTm9kZSA9IGZ1bmN0aW9uIHRvTm9kZSgpIHtcbiAgICB2YXIgc3ZnTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIFwibGluZVwiKTsgLy8gQXBwbHkgYXR0cmlidXRlc1xuXG4gICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90bzcudG9NYXJrdXAgPSBmdW5jdGlvbiB0b01hcmt1cCgpIHtcbiAgICB2YXIgbWFya3VwID0gXCI8bGluZVwiO1xuXG4gICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICBtYXJrdXAgKz0gXCIgXCIgKyBhdHRyICsgXCI9J1wiICsgdGhpcy5hdHRyaWJ1dGVzW2F0dHJdICsgXCInXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWFya3VwICs9IFwiLz5cIjtcbiAgICByZXR1cm4gbWFya3VwO1xuICB9O1xuXG4gIHJldHVybiBMaW5lTm9kZTtcbn0oKTtcbmZ1bmN0aW9uIGFzc2VydFN5bWJvbERvbU5vZGUoZ3JvdXApIHtcbiAgaWYgKGdyb3VwIGluc3RhbmNlb2YgZG9tVHJlZV9TeW1ib2xOb2RlKSB7XG4gICAgcmV0dXJuIGdyb3VwO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHN5bWJvbE5vZGUgYnV0IGdvdCBcIiArIFN0cmluZyhncm91cCkgKyBcIi5cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydFNwYW4oZ3JvdXApIHtcbiAgaWYgKGdyb3VwIGluc3RhbmNlb2YgZG9tVHJlZV9TcGFuKSB7XG4gICAgcmV0dXJuIGdyb3VwO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHNwYW48SHRtbERvbU5vZGU+IGJ1dCBnb3QgXCIgKyBTdHJpbmcoZ3JvdXApICsgXCIuXCIpO1xuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3N1Ym1vZHVsZXMva2F0ZXgtZm9udHMvZm9udE1ldHJpY3NEYXRhLmpzXG4vLyBUaGlzIGZpbGUgaXMgR0VORVJBVEVEIGJ5IGJ1aWxkTWV0cmljcy5zaC4gRE8gTk9UIE1PRElGWS5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGZvbnRNZXRyaWNzRGF0YSA9ICh7XG4gIFwiQU1TLVJlZ3VsYXJcIjoge1xuICAgIFwiNjVcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiNjZcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiNjdcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiNjhcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiNjlcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiNzBcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiNzFcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNzJcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNzNcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiNzRcIjogWzAuMTY2NjcsIDAuNjg4ODksIDAsIDAsIDAuNV0sXG4gICAgXCI3NVwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI3NlwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI3N1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC45NDQ0NV0sXG4gICAgXCI3OFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI3OVwiOiBbMC4xNjY2NywgMC42ODg4OSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4MFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4MVwiOiBbMC4xNjY2NywgMC42ODg4OSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4MlwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4M1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI4NFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NVwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NlwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4N1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMS4wXSxcbiAgICBcIjg4XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg5XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjkwXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjEwN1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCIxNjVcIjogWzAsIDAuNjc1LCAwLjAyNSwgMCwgMC43NV0sXG4gICAgXCIxNzRcIjogWzAuMTU1NTksIDAuNjkyMjQsIDAsIDAsIDAuOTQ2NjZdLFxuICAgIFwiMjQwXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjI5NVwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC41NDAyOF0sXG4gICAgXCI3MTBcIjogWzAsIDAuODI1LCAwLCAwLCAyLjMzMzM0XSxcbiAgICBcIjczMlwiOiBbMCwgMC45LCAwLCAwLCAyLjMzMzM0XSxcbiAgICBcIjc3MFwiOiBbMCwgMC44MjUsIDAsIDAsIDIuMzMzMzRdLFxuICAgIFwiNzcxXCI6IFswLCAwLjksIDAsIDAsIDIuMzMzMzRdLFxuICAgIFwiOTg5XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwMDhcIjogWzAsIDAuNDMwNTYsIDAuMDQwMjgsIDAsIDAuNjY2NjddLFxuICAgIFwiODI0NVwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC4yNzVdLFxuICAgIFwiODQ2M1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC41NDAyOF0sXG4gICAgXCI4NDg3XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg0OThcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiODUwMlwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NTAzXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjg1MDRcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODUxM1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCI4NTkyXCI6IFstMC4wMzU5OCwgMC40NjQwMiwgMCwgMCwgMC41XSxcbiAgICBcIjg1OTRcIjogWy0wLjAzNTk4LCAwLjQ2NDAyLCAwLCAwLCAwLjVdLFxuICAgIFwiODYwMlwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjAzXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2MDZcIjogWzAuMDEzNTQsIDAuNTIyMzksIDAsIDAsIDEuMF0sXG4gICAgXCI4NjA4XCI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwLCAxLjBdLFxuICAgIFwiODYxMFwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMCwgMS4xMTExMV0sXG4gICAgXCI4NjExXCI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjg2MTlcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjIwXCI6IFswLCAwLjU0OTg2LCAwLCAwLCAxLjBdLFxuICAgIFwiODYyMVwiOiBbLTAuMTMzMTMsIDAuMzc3ODgsIDAsIDAsIDEuMzg4ODldLFxuICAgIFwiODYyMlwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjI0XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjVdLFxuICAgIFwiODYyNVwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC41XSxcbiAgICBcIjg2MzBcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjMxXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAxLjBdLFxuICAgIFwiODYzNFwiOiBbMC4wODE5OCwgMC41ODE5OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NjM1XCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg2MzhcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuNDE2NjddLFxuICAgIFwiODYzOVwiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC40MTY2N10sXG4gICAgXCI4NjQyXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjQxNjY3XSxcbiAgICBcIjg2NDNcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuNDE2NjddLFxuICAgIFwiODY0NFwiOiBbMC4xODA4LCAwLjY3NSwgMCwgMCwgMS4wXSxcbiAgICBcIjg2NDZcIjogWzAuMTgwOCwgMC42NzUsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjQ3XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwLCAxLjBdLFxuICAgIFwiODY0OFwiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCI4NjQ5XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwLCAxLjBdLFxuICAgIFwiODY1MFwiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCI4NjUxXCI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwLCAxLjBdLFxuICAgIFwiODY1MlwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMCwgMS4wXSxcbiAgICBcIjg2NTNcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODY1NFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjU1XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2NjZcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjY3XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAxLjBdLFxuICAgIFwiODY2OVwiOiBbLTAuMTMzMTMsIDAuMzc3ODgsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjcyXCI6IFstMC4wNjQsIDAuNDM3LCAwLCAwLCAxLjMzNF0sXG4gICAgXCI4Njc0XCI6IFstMC4wNjQsIDAuNDM3LCAwLCAwLCAxLjMzNF0sXG4gICAgXCI4NzA1XCI6IFswLCAwLjgyNSwgMCwgMCwgMC41XSxcbiAgICBcIjg3MDhcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiODcwOVwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzE3XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjQyOTE3XSxcbiAgICBcIjg3MjJcIjogWy0wLjAzNTk4LCAwLjQ2NDAyLCAwLCAwLCAwLjVdLFxuICAgIFwiODcyNFwiOiBbMC4wODE5OCwgMC42OTIyNCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzI2XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3MzNcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODczNlwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NzM3XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg3MzhcIjogWzAuMDM1MTcsIDAuNTIyMzksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODczOVwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC4yMjIyMl0sXG4gICAgXCI4NzQwXCI6IFswLjI1MTQyLCAwLjc0MTExLCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjg3NDFcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiODc0MlwiOiBbMC4yNTE0MiwgMC43NDExMSwgMCwgMCwgMC41XSxcbiAgICBcIjg3NTZcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODc1N1wiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NzY0XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzY1XCI6IFstMC4xMzMxMywgMC4zNzc4OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzY5XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzcwXCI6IFstMC4wMzYyNSwgMC40NjM3NSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4Nzc0XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3NzZcIjogWy0wLjAxNjg4LCAwLjQ4MzEyLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3NzhcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc4MlwiOiBbMC4wNjA2MiwgMC41NDk4NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzgzXCI6IFswLjA2MDYyLCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3ODVcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc4NlwiOiBbMC4wODE5OCwgMC41ODE5OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4Nzg3XCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3OTBcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc5MVwiOiBbMC4yMjk1OCwgMC43Mjk1OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4Nzk2XCI6IFswLjA4MTk4LCAwLjkxNjY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MDZcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgwN1wiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODA4XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MDlcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgxMlwiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMCwgMC41XSxcbiAgICBcIjg4MTRcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgxNVwiOiBbMC4yMDU3NiwgMC43MDU3NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODE2XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MTdcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgxOFwiOiBbMC4yMjk1OCwgMC43Mjk1OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODE5XCI6IFswLjIyOTU4LCAwLjcyOTU4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MjJcIjogWzAuMTgwOCwgMC42NzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgyM1wiOiBbMC4xODA4LCAwLjY3NSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODI4XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MjlcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgzMFwiOiBbMC4yMjk1OCwgMC43Mjk1OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODMxXCI6IFswLjIyOTU4LCAwLjcyOTU4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MzJcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgzM1wiOiBbMC4yMDU3NiwgMC43MDU3NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODQwXCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NDFcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg0MlwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODQzXCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NDdcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg0OFwiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODU4XCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NTlcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg2MVwiOiBbMC4wODE5OCwgMC41ODE5OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODYyXCI6IFswLCAwLjY3NSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODYzXCI6IFswLCAwLjY3NSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODY0XCI6IFswLCAwLjY3NSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODY1XCI6IFswLCAwLjY3NSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODcyXCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg4NzNcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODg3NFwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI4ODc2XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg4NzdcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODg3OFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4ODc5XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg4ODJcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg4M1wiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODg0XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4ODVcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg4OFwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMS4xMTExMV0sXG4gICAgXCI4ODkwXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjg4OTFcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODg5MlwiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4OTAxXCI6IFswLCAwLjU0OTg2LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjg5MDNcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkwNVwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTA2XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MDdcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkwOFwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTA5XCI6IFstMC4wMzU5OCwgMC40NjQwMiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTEwXCI6IFswLCAwLjU0OTg2LCAwLCAwLCAwLjc2MDQyXSxcbiAgICBcIjg5MTFcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuNzYwNDJdLFxuICAgIFwiODkxMlwiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTEzXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MTRcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODkxNVwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4OTE2XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg5MThcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MTlcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MjBcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDAsIDEuMzMzMzRdLFxuICAgIFwiODkyMVwiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMS4zMzMzNF0sXG4gICAgXCI4OTIyXCI6IFswLjM4NTY5LCAwLjg4NTY5LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MjNcIjogWzAuMzg1NjksIDAuODg1NjksIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkyNlwiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTI3XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MjhcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkyOVwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTM0XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MzVcIjogWzAuMjMyMjIsIDAuNzQxMTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkzNlwiOiBbMC4yMzIyMiwgMC43NDExMSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTM3XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MzhcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkzOVwiOiBbMC4yMDU3NiwgMC43MDU3NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTQwXCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5NDFcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODk5NFwiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTk1XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjk0MTZcIjogWzAuMTU1NTksIDAuNjkyMjQsIDAsIDAsIDAuOTAyMjJdLFxuICAgIFwiOTQ4NFwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC41XSxcbiAgICBcIjk0ODhcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNV0sXG4gICAgXCI5NDkyXCI6IFswLCAwLjM3Nzg4LCAwLCAwLCAwLjVdLFxuICAgIFwiOTQ5NlwiOiBbMCwgMC4zNzc4OCwgMCwgMCwgMC41XSxcbiAgICBcIjk1ODVcIjogWzAuMTk0NDQsIDAuNjg4ODksIDAsIDAsIDAuODg4ODldLFxuICAgIFwiOTU4NlwiOiBbMC4xOTQ0NCwgMC43NDExMSwgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI5NjMyXCI6IFswLCAwLjY3NSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5NjMzXCI6IFswLCAwLjY3NSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5NjUwXCI6IFswLCAwLjU0OTg2LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjk2NTFcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTY1NFwiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5NjYwXCI6IFswLCAwLjU0OTg2LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjk2NjFcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTY2NFwiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5Njc0XCI6IFswLjExMTExLCAwLjY5MjI0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjk3MzNcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuOTQ0NDVdLFxuICAgIFwiMTAwMDNcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiMTAwMTZcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiMTA3MzFcIjogWzAuMTExMTEsIDAuNjkyMjQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiMTA4NDZcIjogWzAuMTk0NDQsIDAuNzU1ODMsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiMTA4NzdcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA4NzhcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA4ODVcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA4ODZcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA4ODdcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA4ODhcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA4ODlcIjogWzAuMjYxNjcsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA4OTBcIjogWzAuMjYxNjcsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA4OTFcIjogWzAuNDgyNTYsIDAuOTgyNTYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA4OTJcIjogWzAuNDgyNTYsIDAuOTgyNTYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5MDFcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5MDJcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5MzNcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5MzRcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5MzVcIjogWzAuMjYxNjcsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5MzZcIjogWzAuMjYxNjcsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5MzdcIjogWzAuMjYxNjcsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5MzhcIjogWzAuMjYxNjcsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5NDlcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5NTBcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5NTVcIjogWzAuMjg0ODEsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5NTZcIjogWzAuMjg0ODEsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNTBcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuMjIyMjJdLFxuICAgIFwiNTczNTFcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiNTczNTJcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNTNcIjogWzAsIDAuNDMwNTYsIDAuMDQwMjgsIDAsIDAuNjY2NjddLFxuICAgIFwiNTczNTZcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNTdcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNThcIjogWzAuNDE5NTEsIDAuOTE5NTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNTlcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNjBcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNjFcIjogWzAuNDE5NTEsIDAuOTE5NTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNjZcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNjdcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNjhcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNjlcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNzBcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNzFcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdXG4gIH0sXG4gIFwiQ2FsaWdyYXBoaWMtUmVndWxhclwiOiB7XG4gICAgXCI0OFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41XSxcbiAgICBcIjQ5XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTBcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1MVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC41XSxcbiAgICBcIjUyXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1NFwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjU1XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI1N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC41XSxcbiAgICBcIjY1XCI6IFswLCAwLjY4MzMzLCAwLCAwLjE5NDQ1LCAwLjc5ODQ3XSxcbiAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLjAzMDQxLCAwLjEzODg5LCAwLjY1NjgxXSxcbiAgICBcIjY3XCI6IFswLCAwLjY4MzMzLCAwLjA1ODM0LCAwLjEzODg5LCAwLjUyNjUzXSxcbiAgICBcIjY4XCI6IFswLCAwLjY4MzMzLCAwLjAyNzc4LCAwLjA4MzM0LCAwLjc3MTM5XSxcbiAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLjA4OTQ0LCAwLjExMTExLCAwLjUyNzc4XSxcbiAgICBcIjcwXCI6IFswLCAwLjY4MzMzLCAwLjA5OTMxLCAwLjExMTExLCAwLjcxODc1XSxcbiAgICBcIjcxXCI6IFswLjA5NzIyLCAwLjY4MzMzLCAwLjA1OTMsIDAuMTExMTEsIDAuNTk0ODddLFxuICAgIFwiNzJcIjogWzAsIDAuNjgzMzMsIDAuMDA5NjUsIDAuMTExMTEsIDAuODQ0NTJdLFxuICAgIFwiNzNcIjogWzAsIDAuNjgzMzMsIDAuMDczODIsIDAsIDAuNTQ0NTJdLFxuICAgIFwiNzRcIjogWzAuMDk3MjIsIDAuNjgzMzMsIDAuMTg0NzIsIDAuMTY2NjcsIDAuNjc3NzhdLFxuICAgIFwiNzVcIjogWzAsIDAuNjgzMzMsIDAuMDE0NDUsIDAuMDU1NTYsIDAuNzYxOTVdLFxuICAgIFwiNzZcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTM4ODksIDAuNjg5NzJdLFxuICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTM4ODksIDEuMjAwOV0sXG4gICAgXCI3OFwiOiBbMCwgMC42ODMzMywgMC4xNDczNiwgMC4wODMzNCwgMC44MjA0OV0sXG4gICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4xMTExMSwgMC43OTYxMV0sXG4gICAgXCI4MFwiOiBbMCwgMC42ODMzMywgMC4wODIyMiwgMC4wODMzNCwgMC42OTU1Nl0sXG4gICAgXCI4MVwiOiBbMC4wOTcyMiwgMC42ODMzMywgMCwgMC4xMTExMSwgMC44MTY2N10sXG4gICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMCwgMC4wODMzNCwgMC44NDc1XSxcbiAgICBcIjgzXCI6IFswLCAwLjY4MzMzLCAwLjA3NSwgMC4xMzg4OSwgMC42MDU1Nl0sXG4gICAgXCI4NFwiOiBbMCwgMC42ODMzMywgMC4yNTQxNywgMCwgMC41NDQ2NF0sXG4gICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMC4wOTkzMSwgMC4wODMzNCwgMC42MjU4M10sXG4gICAgXCI4NlwiOiBbMCwgMC42ODMzMywgMC4wODIyMiwgMCwgMC42MTI3OF0sXG4gICAgXCI4N1wiOiBbMCwgMC42ODMzMywgMC4wODIyMiwgMC4wODMzNCwgMC45ODc3OF0sXG4gICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMC4xNDY0MywgMC4xMzg4OSwgMC43MTMzXSxcbiAgICBcIjg5XCI6IFswLjA5NzIyLCAwLjY4MzMzLCAwLjA4MjIyLCAwLjA4MzM0LCAwLjY2ODM0XSxcbiAgICBcIjkwXCI6IFswLCAwLjY4MzMzLCAwLjA3OTQ0LCAwLjEzODg5LCAwLjcyNDczXVxuICB9LFxuICBcIkZyYWt0dXItUmVndWxhclwiOiB7XG4gICAgXCIzM1wiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4yOTU3NF0sXG4gICAgXCIzNFwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4yMTQ3MV0sXG4gICAgXCIzOFwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC43Mzc4Nl0sXG4gICAgXCIzOVwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4yMTIwMV0sXG4gICAgXCI0MFwiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMCwgMC4zODg2NV0sXG4gICAgXCI0MVwiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMCwgMC4zODg2NV0sXG4gICAgXCI0MlwiOiBbMCwgMC42MjExOSwgMCwgMCwgMC4yNzc2NF0sXG4gICAgXCI0M1wiOiBbMC4wODMxOSwgMC41ODI4MywgMCwgMCwgMC43NTYyM10sXG4gICAgXCI0NFwiOiBbMCwgMC4xMDgwMywgMCwgMCwgMC4yNzc2NF0sXG4gICAgXCI0NVwiOiBbMC4wODMxOSwgMC41ODI4MywgMCwgMCwgMC43NTYyM10sXG4gICAgXCI0NlwiOiBbMCwgMC4xMDgwMywgMCwgMCwgMC4yNzc2NF0sXG4gICAgXCI0N1wiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI0OFwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI0OVwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1MFwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1MVwiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1MlwiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1M1wiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1NFwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1NVwiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1NlwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1N1wiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1OFwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC4yMTYwNl0sXG4gICAgXCI1OVwiOiBbMC4xMjYwNCwgMC40NzUzNCwgMCwgMCwgMC4yMTYwNl0sXG4gICAgXCI2MVwiOiBbLTAuMTMwOTksIDAuMzY4NjYsIDAsIDAsIDAuNzU2MjNdLFxuICAgIFwiNjNcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMzYyNDVdLFxuICAgIFwiNjVcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNzE3Nl0sXG4gICAgXCI2NlwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC44ODM5N10sXG4gICAgXCI2N1wiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC42MTI1NF0sXG4gICAgXCI2OFwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC44MzE1OF0sXG4gICAgXCI2OVwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC42NjI3OF0sXG4gICAgXCI3MFwiOiBbMC4xMjYwNCwgMC42OTE0MSwgMCwgMCwgMC42MTExOV0sXG4gICAgXCI3MVwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC43ODUzOV0sXG4gICAgXCI3MlwiOiBbMC4wNjMwMiwgMC42OTE0MSwgMCwgMCwgMC43MjAzXSxcbiAgICBcIjczXCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjU1NDQ4XSxcbiAgICBcIjc0XCI6IFswLjEyNjA0LCAwLjY5MTQxLCAwLCAwLCAwLjU1MjMxXSxcbiAgICBcIjc1XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjY2ODQ1XSxcbiAgICBcIjc2XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjY2NjAyXSxcbiAgICBcIjc3XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAxLjA0OTUzXSxcbiAgICBcIjc4XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjgzMjEyXSxcbiAgICBcIjc5XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjgyNjk5XSxcbiAgICBcIjgwXCI6IFswLjE4OTA2LCAwLjY5MTQxLCAwLCAwLCAwLjgyNzUzXSxcbiAgICBcIjgxXCI6IFswLjAzNzgxLCAwLjY5MTQxLCAwLCAwLCAwLjgyNjk5XSxcbiAgICBcIjgyXCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjgyODA3XSxcbiAgICBcIjgzXCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjgyODYxXSxcbiAgICBcIjg0XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjY2ODk5XSxcbiAgICBcIjg1XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjY0NTc2XSxcbiAgICBcIjg2XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjgzMTMxXSxcbiAgICBcIjg3XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAxLjA0NjAyXSxcbiAgICBcIjg4XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjcxOTIyXSxcbiAgICBcIjg5XCI6IFswLjE4OTA2LCAwLjY5MTQxLCAwLCAwLCAwLjgzMjkzXSxcbiAgICBcIjkwXCI6IFswLjEyNjA0LCAwLjY5MTQxLCAwLCAwLCAwLjYwMjAxXSxcbiAgICBcIjkxXCI6IFswLjI0OTgyLCAwLjc0OTQ3LCAwLCAwLCAwLjI3NzY0XSxcbiAgICBcIjkzXCI6IFswLjI0OTgyLCAwLjc0OTQ3LCAwLCAwLCAwLjI3NzY0XSxcbiAgICBcIjk0XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjQ5OTY1XSxcbiAgICBcIjk3XCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjUwMDQ2XSxcbiAgICBcIjk4XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjUxMzE1XSxcbiAgICBcIjk5XCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjM4OTQ2XSxcbiAgICBcIjEwMFwiOiBbMCwgMC42MjExOSwgMCwgMCwgMC40OTg1N10sXG4gICAgXCIxMDFcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNDAwNTNdLFxuICAgIFwiMTAyXCI6IFswLjE4OTA2LCAwLjY5MTQxLCAwLCAwLCAwLjMyNjI2XSxcbiAgICBcIjEwM1wiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC41MDM3XSxcbiAgICBcIjEwNFwiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMCwgMC41MjEyNl0sXG4gICAgXCIxMDVcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMjc4OTldLFxuICAgIFwiMTA2XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjI4MDg4XSxcbiAgICBcIjEwN1wiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4zODk0Nl0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMjc5NTNdLFxuICAgIFwiMTA5XCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjc2Njc2XSxcbiAgICBcIjExMFwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC41MjY2Nl0sXG4gICAgXCIxMTFcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNDg4ODVdLFxuICAgIFwiMTEyXCI6IFswLjE4OTA2LCAwLjUyMzk2LCAwLCAwLCAwLjUwMDQ2XSxcbiAgICBcIjExM1wiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC40ODkxMl0sXG4gICAgXCIxMTRcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuMzg5MTldLFxuICAgIFwiMTE1XCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjQ0MjY2XSxcbiAgICBcIjExNlwiOiBbMCwgMC42MjExOSwgMCwgMCwgMC4zMzMwMV0sXG4gICAgXCIxMTdcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNTE3Ml0sXG4gICAgXCIxMThcIjogWzAsIDAuNTIzOTYsIDAsIDAsIDAuNTExOF0sXG4gICAgXCIxMTlcIjogWzAsIDAuNTIzOTYsIDAsIDAsIDAuNzczNTFdLFxuICAgIFwiMTIwXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjM4ODY1XSxcbiAgICBcIjEyMVwiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC40OTg4NF0sXG4gICAgXCIxMjJcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuMzkwNTRdLFxuICAgIFwiODIxNlwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4yMTQ3MV0sXG4gICAgXCI4MjE3XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjIxNDcxXSxcbiAgICBcIjU4MTEyXCI6IFswLCAwLjYyMTE5LCAwLCAwLCAwLjQ5NzQ5XSxcbiAgICBcIjU4MTEzXCI6IFswLCAwLjYyMTE5LCAwLCAwLCAwLjQ5ODNdLFxuICAgIFwiNTgxMTRcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDAsIDAuMzMzMjhdLFxuICAgIFwiNTgxMTVcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDAsIDAuMzI5MjNdLFxuICAgIFwiNTgxMTZcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuNTAzNDNdLFxuICAgIFwiNTgxMTdcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMzMzMDFdLFxuICAgIFwiNTgxMThcIjogWzAsIDAuNjIxMTksIDAsIDAsIDAuMzM0MDldLFxuICAgIFwiNTgxMTlcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNTAwNzNdXG4gIH0sXG4gIFwiTWFpbi1Cb2xkXCI6IHtcbiAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjM1XSxcbiAgICBcIjM0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYwMjc4XSxcbiAgICBcIjM1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjk1ODMzXSxcbiAgICBcIjM2XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwLCAwLjU3NV0sXG4gICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMC45NTgzM10sXG4gICAgXCIzOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40NDcyMl0sXG4gICAgXCI0MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40NDcyMl0sXG4gICAgXCI0MlwiOiBbMCwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiNDNcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiNDRcIjogWzAuMTk0NDQsIDAuMTU1NTYsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiNDVcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuMzgzMzNdLFxuICAgIFwiNDZcIjogWzAsIDAuMTU1NTYsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiNDdcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjQ4XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI0OVwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTBcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjUxXCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1MlwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTNcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1NVwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjU3XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1OFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI1OVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI2MFwiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI2MVwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiNjJcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiNjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTQzMDVdLFxuICAgIFwiNjRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiNjVcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODY5NDRdLFxuICAgIFwiNjZcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODE4MDVdLFxuICAgIFwiNjdcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODMwNTVdLFxuICAgIFwiNjhcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODgxOTRdLFxuICAgIFwiNjlcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNzU1NTVdLFxuICAgIFwiNzBcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNzIzNjFdLFxuICAgIFwiNzFcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOTA0MTZdLFxuICAgIFwiNzJcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOV0sXG4gICAgXCI3M1wiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC40MzYxMV0sXG4gICAgXCI3NFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC41OTQ0NF0sXG4gICAgXCI3NVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC45MDEzOF0sXG4gICAgXCI3NlwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC42OTE2Nl0sXG4gICAgXCI3N1wiOiBbMCwgMC42ODYxMSwgMCwgMCwgMS4wOTE2Nl0sXG4gICAgXCI3OFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC45XSxcbiAgICBcIjc5XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg2Mzg4XSxcbiAgICBcIjgwXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjc4NjExXSxcbiAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4NjExLCAwLCAwLCAwLjg2Mzg4XSxcbiAgICBcIjgyXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg2MjVdLFxuICAgIFwiODNcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiODRcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOF0sXG4gICAgXCI4NVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44ODQ3Ml0sXG4gICAgXCI4NlwiOiBbMCwgMC42ODYxMSwgMC4wMTU5NywgMCwgMC44Njk0NF0sXG4gICAgXCI4N1wiOiBbMCwgMC42ODYxMSwgMC4wMTU5NywgMCwgMS4xODg4OF0sXG4gICAgXCI4OFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44Njk0NF0sXG4gICAgXCI4OVwiOiBbMCwgMC42ODYxMSwgMC4wMjg3NSwgMCwgMC44Njk0NF0sXG4gICAgXCI5MFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC43MDI3N10sXG4gICAgXCI5MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI5MlwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiOTNcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjk1XCI6IFswLjMxLCAwLjEzNDQ0LCAwLjAzMTk0LCAwLCAwLjU3NV0sXG4gICAgXCI5N1wiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41NTkwMl0sXG4gICAgXCI5OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCI5OVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41MTExMV0sXG4gICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiMTAxXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjUyNzA4XSxcbiAgICBcIjEwMlwiOiBbMCwgMC42OTQ0NCwgMC4xMDkwMywgMCwgMC4zNTEzOV0sXG4gICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDE1OTcsIDAsIDAuNTc1XSxcbiAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCIxMDVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjM1MTM5XSxcbiAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MDY5NF0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiMTA5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjk1ODMzXSxcbiAgICBcIjExMFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCIxMTFcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNjA2OTRdLFxuICAgIFwiMTE0XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjQ3MzYxXSxcbiAgICBcIjExNVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC40NTM2MV0sXG4gICAgXCIxMTZcIjogWzAsIDAuNjM0OTIsIDAsIDAsIDAuNDQ3MjJdLFxuICAgIFwiMTE3XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjExOFwiOiBbMCwgMC40NDQ0NCwgMC4wMTU5NywgMCwgMC42MDY5NF0sXG4gICAgXCIxMTlcIjogWzAsIDAuNDQ0NDQsIDAuMDE1OTcsIDAsIDAuODMwNTVdLFxuICAgIFwiMTIwXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjYwNjk0XSxcbiAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMTU5NywgMCwgMC42MDY5NF0sXG4gICAgXCIxMjJcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTExMTFdLFxuICAgIFwiMTIzXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjU3NV0sXG4gICAgXCIxMjRcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiMTI1XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjU3NV0sXG4gICAgXCIxMjZcIjogWzAuMzUsIDAuMzQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjE2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiMTcyXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjc2NjY2XSxcbiAgICBcIjE3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44Njk0NF0sXG4gICAgXCIxNzdcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiMTg0XCI6IFswLjE3MDE0LCAwLCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjE5OFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMS4wNDE2Nl0sXG4gICAgXCIyMTVcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiMjE2XCI6IFswLjA0ODYxLCAwLjczNDcyLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjIyM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41OTcyMl0sXG4gICAgXCIyMzBcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuODMwNTVdLFxuICAgIFwiMjQ3XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjI0OFwiOiBbMC4wOTcyMiwgMC41NDE2NywgMCwgMCwgMC41NzVdLFxuICAgIFwiMzA1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjMzOFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMS4xNjk0NF0sXG4gICAgXCIzMzlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjM1MTM5XSxcbiAgICBcIjcxMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNzExXCI6IFswLCAwLjYzMTk0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI3MTNcIjogWzAsIDAuNTk2MTEsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjcxNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNzE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI3MjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjcyOVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI3MzBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODY5NDRdLFxuICAgIFwiNzMyXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI3MzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjkxNVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC42OTE2Nl0sXG4gICAgXCI5MTZcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOTU4MzNdLFxuICAgIFwiOTIwXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjkyM1wiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44MDU1NV0sXG4gICAgXCI5MjZcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiOTI4XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjldLFxuICAgIFwiOTMxXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjgzMDU1XSxcbiAgICBcIjkzM1wiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI5MzRcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODMwNTVdLFxuICAgIFwiOTM2XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjkzN1wiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44MzA1NV0sXG4gICAgXCI4MjExXCI6IFswLCAwLjQ0NDQ0LCAwLjAzMTk0LCAwLCAwLjU3NV0sXG4gICAgXCI4MjEyXCI6IFswLCAwLjQ0NDQ0LCAwLjAzMTk0LCAwLCAxLjE0OTk5XSxcbiAgICBcIjgyMTZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiODIxN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI4MjIwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYwMjc4XSxcbiAgICBcIjgyMjFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjAyNzhdLFxuICAgIFwiODIyNFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC41MTExMV0sXG4gICAgXCI4MjI1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjgyNDJcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuMzQ0NDRdLFxuICAgIFwiODQwN1wiOiBbMCwgMC43MjQ0NCwgMC4xNTQ4NiwgMCwgMC41NzVdLFxuICAgIFwiODQ2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42Njc1OV0sXG4gICAgXCI4NDY1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjgzMDU1XSxcbiAgICBcIjg0NjdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNDczNjFdLFxuICAgIFwiODQ3MlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC43NDAyN10sXG4gICAgXCI4NDc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjgzMDU1XSxcbiAgICBcIjg1MDFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzddLFxuICAgIFwiODU5MlwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODU5M1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiODU5NFwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODU5NVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiODU5NlwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODU5N1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiODU5OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NTk5XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg2MDBcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODYwMVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjM2XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjM3XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjQwXCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjQxXCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjU2XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjU3XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjcwMjc3XSxcbiAgICBcIjg2NThcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg2NTlcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzddLFxuICAgIFwiODY2MFwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODY2MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC43MDI3N10sXG4gICAgXCI4NzA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjg3MDZcIjogWzAsIDAuNjk0NDQsIDAuMDYzODksIDAsIDAuNjI4NDddLFxuICAgIFwiODcwN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCI4NzA5XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4NzExXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjk1ODMzXSxcbiAgICBcIjg3MTJcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiODcxNVwiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCI4NzIyXCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg3MjNcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODcyNVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiODcyNlwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiODcyN1wiOiBbLTAuMDI3NzgsIDAuNDcyMjIsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjg3MjhcIjogWy0wLjAyNjM5LCAwLjQ3MzYxLCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4NzI5XCI6IFstMC4wMjYzOSwgMC40NzM2MSwgMCwgMCwgMC41NzVdLFxuICAgIFwiODczMFwiOiBbMC4xOCwgMC44MiwgMCwgMCwgMC45NTgzM10sXG4gICAgXCI4NzMzXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg3MzRcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODczNlwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NzM5XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjg3NDFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjg3NDNcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiODc0NFwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCI4NzQ1XCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjc2NjY2XSxcbiAgICBcIjg3NDZcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiODc0N1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4xMjc3OCwgMCwgMC41Njg3NV0sXG4gICAgXCI4NzY0XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4NzY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjg3NzFcIjogWzAuMDAyMjIsIDAuNTAyMjIsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODc3NlwiOiBbMC4wMjQ0NCwgMC41MjQ0NCwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4NzgxXCI6IFswLjAwMjIyLCAwLjUwMjIyLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4MDFcIjogWzAuMDAyMjIsIDAuNTAyMjIsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODgwNFwiOiBbMC4xOTY2NywgMC42OTY2NywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODA1XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4MTBcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODgxMVwiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4ODI2XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4MjdcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODgzNFwiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODM1XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4MzhcIjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODgzOVwiOiBbMC4xOTY2NywgMC42OTY2NywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODQ2XCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjc2NjY2XSxcbiAgICBcIjg4NDlcIjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODg1MFwiOiBbMC4xOTY2NywgMC42OTY2NywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODUxXCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjc2NjY2XSxcbiAgICBcIjg4NTJcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiODg1M1wiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODU0XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4NTVcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODg1NlwiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODU3XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4NjZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzddLFxuICAgIFwiODg2N1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MDI3N10sXG4gICAgXCI4ODY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4NjlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODkwMFwiOiBbLTAuMDI2MzksIDAuNDczNjEsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjg5MDFcIjogWy0wLjAyNjM5LCAwLjQ3MzYxLCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjg5MDJcIjogWy0wLjAyNzc4LCAwLjQ3MjIyLCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4OTY4XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjg5NjlcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTExMTFdLFxuICAgIFwiODk3MFwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41MTExMV0sXG4gICAgXCI4OTcxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjg5OTRcIjogWy0wLjEzODg5LCAwLjM2MTExLCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg5OTVcIjogWy0wLjEzODg5LCAwLjM2MTExLCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjk2NTFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMDIyMjJdLFxuICAgIFwiOTY1N1wiOiBbLTAuMDI3NzgsIDAuNDcyMjIsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjk2NjFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMDIyMjJdLFxuICAgIFwiOTY2N1wiOiBbLTAuMDI3NzgsIDAuNDcyMjIsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjk3MTFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiOTgyNFwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI5ODI1XCI6IFswLjEyOTYzLCAwLjY5NDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjk4MjZcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiOTgyN1wiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI5ODM3XCI6IFswLCAwLjc1LCAwLCAwLCAwLjQ0NzIyXSxcbiAgICBcIjk4MzhcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNDQ3MjJdLFxuICAgIFwiOTgzOVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC40NDcyMl0sXG4gICAgXCIxMDIxNlwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40NDcyMl0sXG4gICAgXCIxMDIxN1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40NDcyMl0sXG4gICAgXCIxMDgxNVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC45XSxcbiAgICBcIjEwOTI3XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjEwOTI4XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjU3Mzc2XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwXVxuICB9LFxuICBcIk1haW4tQm9sZEl0YWxpY1wiOiB7XG4gICAgXCIzM1wiOiBbMCwgMC42OTQ0NCwgMC4xMTQxNywgMCwgMC4zODYxMV0sXG4gICAgXCIzNFwiOiBbMCwgMC42OTQ0NCwgMC4wNzkzOSwgMCwgMC42MjA1NV0sXG4gICAgXCIzNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNjgzMywgMCwgMC45NDQ0NF0sXG4gICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMC4xMjg2MSwgMCwgMC45NDQ0NF0sXG4gICAgXCIzOFwiOiBbMCwgMC42OTQ0NCwgMC4wODUyOCwgMCwgMC44ODU1NV0sXG4gICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMC4xMjk0NSwgMCwgMC4zNTU1NV0sXG4gICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMC4xNTgwNiwgMCwgMC40NzMzM10sXG4gICAgXCI0MVwiOiBbMC4yNSwgMC43NSwgMC4wMzMwNiwgMCwgMC40NzMzM10sXG4gICAgXCI0MlwiOiBbMCwgMC43NSwgMC4xNDMzMywgMCwgMC41OTExMV0sXG4gICAgXCI0M1wiOiBbMC4xMDMzMywgMC42MDMzMywgMC4wMzMwNiwgMCwgMC44ODU1NV0sXG4gICAgXCI0NFwiOiBbMC4xOTQ0NCwgMC4xNDcyMiwgMCwgMCwgMC4zNTU1NV0sXG4gICAgXCI0NVwiOiBbMCwgMC40NDQ0NCwgMC4wMjYxMSwgMCwgMC40MTQ0NF0sXG4gICAgXCI0NlwiOiBbMCwgMC4xNDcyMiwgMCwgMCwgMC4zNTU1NV0sXG4gICAgXCI0N1wiOiBbMC4yNSwgMC43NSwgMC4xNTgwNiwgMCwgMC41OTExMV0sXG4gICAgXCI0OFwiOiBbMCwgMC42NDQ0NCwgMC4xMzE2NywgMCwgMC41OTExMV0sXG4gICAgXCI0OVwiOiBbMCwgMC42NDQ0NCwgMC4xMzE2NywgMCwgMC41OTExMV0sXG4gICAgXCI1MFwiOiBbMCwgMC42NDQ0NCwgMC4xMzE2NywgMCwgMC41OTExMV0sXG4gICAgXCI1MVwiOiBbMCwgMC42NDQ0NCwgMC4xMzE2NywgMCwgMC41OTExMV0sXG4gICAgXCI1MlwiOiBbMC4xOTQ0NCwgMC42NDQ0NCwgMC4xMzE2NywgMCwgMC41OTExMV0sXG4gICAgXCI1M1wiOiBbMCwgMC42NDQ0NCwgMC4xMzE2NywgMCwgMC41OTExMV0sXG4gICAgXCI1NFwiOiBbMCwgMC42NDQ0NCwgMC4xMzE2NywgMCwgMC41OTExMV0sXG4gICAgXCI1NVwiOiBbMC4xOTQ0NCwgMC42NDQ0NCwgMC4xMzE2NywgMCwgMC41OTExMV0sXG4gICAgXCI1NlwiOiBbMCwgMC42NDQ0NCwgMC4xMzE2NywgMCwgMC41OTExMV0sXG4gICAgXCI1N1wiOiBbMCwgMC42NDQ0NCwgMC4xMzE2NywgMCwgMC41OTExMV0sXG4gICAgXCI1OFwiOiBbMCwgMC40NDQ0NCwgMC4wNjY5NSwgMCwgMC4zNTU1NV0sXG4gICAgXCI1OVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wNjY5NSwgMCwgMC4zNTU1NV0sXG4gICAgXCI2MVwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAuMDY4MzMsIDAsIDAuODg1NTVdLFxuICAgIFwiNjNcIjogWzAsIDAuNjk0NDQsIDAuMTE0NzIsIDAsIDAuNTkxMTFdLFxuICAgIFwiNjRcIjogWzAsIDAuNjk0NDQsIDAuMDkyMDgsIDAsIDAuODg1NTVdLFxuICAgIFwiNjVcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODY1NTVdLFxuICAgIFwiNjZcIjogWzAsIDAuNjg2MTEsIDAuMDk5MiwgMCwgMC44MTY2Nl0sXG4gICAgXCI2N1wiOiBbMCwgMC42ODYxMSwgMC4xNDIwOCwgMCwgMC44MjY2Nl0sXG4gICAgXCI2OFwiOiBbMCwgMC42ODYxMSwgMC4wOTA2MiwgMCwgMC44NzU1NV0sXG4gICAgXCI2OVwiOiBbMCwgMC42ODYxMSwgMC4xMTQzMSwgMCwgMC43NTY2Nl0sXG4gICAgXCI3MFwiOiBbMCwgMC42ODYxMSwgMC4xMjkwMywgMCwgMC43MjcyMl0sXG4gICAgXCI3MVwiOiBbMCwgMC42ODYxMSwgMC4wNzM0NywgMCwgMC44OTUyN10sXG4gICAgXCI3MlwiOiBbMCwgMC42ODYxMSwgMC4xNzIwOCwgMCwgMC44OTYxXSxcbiAgICBcIjczXCI6IFswLCAwLjY4NjExLCAwLjE1NjgxLCAwLCAwLjQ3MTY2XSxcbiAgICBcIjc0XCI6IFswLCAwLjY4NjExLCAwLjE0NSwgMCwgMC42MTA1NV0sXG4gICAgXCI3NVwiOiBbMCwgMC42ODYxMSwgMC4xNDIwOCwgMCwgMC44OTQ5OV0sXG4gICAgXCI3NlwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC42OTc3N10sXG4gICAgXCI3N1wiOiBbMCwgMC42ODYxMSwgMC4xNzIwOCwgMCwgMS4wNzI3N10sXG4gICAgXCI3OFwiOiBbMCwgMC42ODYxMSwgMC4xNzIwOCwgMCwgMC44OTYxXSxcbiAgICBcIjc5XCI6IFswLCAwLjY4NjExLCAwLjA5MDYyLCAwLCAwLjg1NDk5XSxcbiAgICBcIjgwXCI6IFswLCAwLjY4NjExLCAwLjA5OTIsIDAsIDAuNzg3MjFdLFxuICAgIFwiODFcIjogWzAuMTk0NDQsIDAuNjg2MTEsIDAuMDkwNjIsIDAsIDAuODU0OTldLFxuICAgIFwiODJcIjogWzAsIDAuNjg2MTEsIDAuMDI1NTksIDAsIDAuODU5NDRdLFxuICAgIFwiODNcIjogWzAsIDAuNjg2MTEsIDAuMTEyNjQsIDAsIDAuNjQ5OTldLFxuICAgIFwiODRcIjogWzAsIDAuNjg2MTEsIDAuMTI5MDMsIDAsIDAuNzk2MV0sXG4gICAgXCI4NVwiOiBbMCwgMC42ODYxMSwgMC4xNzIwOCwgMCwgMC44ODA4M10sXG4gICAgXCI4NlwiOiBbMCwgMC42ODYxMSwgMC4xODYyNSwgMCwgMC44NjU1NV0sXG4gICAgXCI4N1wiOiBbMCwgMC42ODYxMSwgMC4xODYyNSwgMCwgMS4xNTk5OV0sXG4gICAgXCI4OFwiOiBbMCwgMC42ODYxMSwgMC4xNTY4MSwgMCwgMC44NjU1NV0sXG4gICAgXCI4OVwiOiBbMCwgMC42ODYxMSwgMC4xOTgwMywgMCwgMC44NjU1NV0sXG4gICAgXCI5MFwiOiBbMCwgMC42ODYxMSwgMC4xNDIwOCwgMCwgMC43MDg4OF0sXG4gICAgXCI5MVwiOiBbMC4yNSwgMC43NSwgMC4xODc1LCAwLCAwLjM1NjExXSxcbiAgICBcIjkzXCI6IFswLjI1LCAwLjc1LCAwLjA5OTcyLCAwLCAwLjM1NjExXSxcbiAgICBcIjk0XCI6IFswLCAwLjY5NDQ0LCAwLjA2NzA5LCAwLCAwLjU5MTExXSxcbiAgICBcIjk1XCI6IFswLjMxLCAwLjEzNDQ0LCAwLjA5ODExLCAwLCAwLjU5MTExXSxcbiAgICBcIjk3XCI6IFswLCAwLjQ0NDQ0LCAwLjA5NDI2LCAwLCAwLjU5MTExXSxcbiAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLjA3ODYxLCAwLCAwLjUzMjIyXSxcbiAgICBcIjk5XCI6IFswLCAwLjQ0NDQ0LCAwLjA1MjIyLCAwLCAwLjUzMjIyXSxcbiAgICBcIjEwMFwiOiBbMCwgMC42OTQ0NCwgMC4xMDg2MSwgMCwgMC41OTExMV0sXG4gICAgXCIxMDFcIjogWzAsIDAuNDQ0NDQsIDAuMDg1LCAwLCAwLjUzMjIyXSxcbiAgICBcIjEwMlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4yMTc3OCwgMCwgMC40XSxcbiAgICBcIjEwM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4xMDUsIDAsIDAuNTMyMjJdLFxuICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLjA5NDI2LCAwLCAwLjU5MTExXSxcbiAgICBcIjEwNVwiOiBbMCwgMC42OTMyNiwgMC4xMTM4NywgMCwgMC4zNTU1NV0sXG4gICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjkzMjYsIDAuMTY3MiwgMCwgMC4zNTU1NV0sXG4gICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAuMTExMTEsIDAsIDAuNTMyMjJdLFxuICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLjEwODYxLCAwLCAwLjI5NjY2XSxcbiAgICBcIjEwOVwiOiBbMCwgMC40NDQ0NCwgMC4wOTQyNiwgMCwgMC45NDQ0NF0sXG4gICAgXCIxMTBcIjogWzAsIDAuNDQ0NDQsIDAuMDk0MjYsIDAsIDAuNjQ5OTldLFxuICAgIFwiMTExXCI6IFswLCAwLjQ0NDQ0LCAwLjA3ODYxLCAwLCAwLjU5MTExXSxcbiAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wNzg2MSwgMCwgMC41OTExMV0sXG4gICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMTA1LCAwLCAwLjUzMjIyXSxcbiAgICBcIjExNFwiOiBbMCwgMC40NDQ0NCwgMC4xMTExMSwgMCwgMC41MDE2N10sXG4gICAgXCIxMTVcIjogWzAsIDAuNDQ0NDQsIDAuMDgxNjcsIDAsIDAuNDg2OTRdLFxuICAgIFwiMTE2XCI6IFswLCAwLjYzNDkyLCAwLjA5NjM5LCAwLCAwLjM4NV0sXG4gICAgXCIxMTdcIjogWzAsIDAuNDQ0NDQsIDAuMDk0MjYsIDAsIDAuNjIwNTVdLFxuICAgIFwiMTE4XCI6IFswLCAwLjQ0NDQ0LCAwLjExMTExLCAwLCAwLjUzMjIyXSxcbiAgICBcIjExOVwiOiBbMCwgMC40NDQ0NCwgMC4xMTExMSwgMCwgMC43Njc3N10sXG4gICAgXCIxMjBcIjogWzAsIDAuNDQ0NDQsIDAuMTI1ODMsIDAsIDAuNTYwNTVdLFxuICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjEwNSwgMCwgMC41NjE2Nl0sXG4gICAgXCIxMjJcIjogWzAsIDAuNDQ0NDQsIDAuMTM4ODksIDAsIDAuNDkwNTVdLFxuICAgIFwiMTI2XCI6IFswLjM1LCAwLjM0NDQ0LCAwLjExNDcyLCAwLCAwLjU5MTExXSxcbiAgICBcIjE2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44Njg1M10sXG4gICAgXCIxNjhcIjogWzAsIDAuNjk0NDQsIDAuMTE0NzMsIDAsIDAuNTkxMTFdLFxuICAgIFwiMTc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjk0ODg4XSxcbiAgICBcIjE4NFwiOiBbMC4xNzAxNCwgMCwgMCwgMCwgMC41MzIyMl0sXG4gICAgXCIxOThcIjogWzAsIDAuNjg2MTEsIDAuMTE0MzEsIDAsIDEuMDIyNzddLFxuICAgIFwiMjE2XCI6IFswLjA0ODYxLCAwLjczNDcyLCAwLjA5MDYyLCAwLCAwLjg4NTU1XSxcbiAgICBcIjIyM1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wOTczNiwgMCwgMC42NjVdLFxuICAgIFwiMjMwXCI6IFswLCAwLjQ0NDQ0LCAwLjA4NSwgMCwgMC44MjY2Nl0sXG4gICAgXCIyNDhcIjogWzAuMDk3MjIsIDAuNTQxNjcsIDAuMDk0NTgsIDAsIDAuNTkxMTFdLFxuICAgIFwiMzA1XCI6IFswLCAwLjQ0NDQ0LCAwLjA5NDI2LCAwLCAwLjM1NTU1XSxcbiAgICBcIjMzOFwiOiBbMCwgMC42ODYxMSwgMC4xMTQzMSwgMCwgMS4xNDA1NF0sXG4gICAgXCIzMzlcIjogWzAsIDAuNDQ0NDQsIDAuMDg1LCAwLCAwLjgyNjY2XSxcbiAgICBcIjU2N1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wNDYxMSwgMCwgMC4zODVdLFxuICAgIFwiNzEwXCI6IFswLCAwLjY5NDQ0LCAwLjA2NzA5LCAwLCAwLjU5MTExXSxcbiAgICBcIjcxMVwiOiBbMCwgMC42MzE5NCwgMC4wODI3MSwgMCwgMC41OTExMV0sXG4gICAgXCI3MTNcIjogWzAsIDAuNTk0NDQsIDAuMTA0NDQsIDAsIDAuNTkxMTFdLFxuICAgIFwiNzE0XCI6IFswLCAwLjY5NDQ0LCAwLjA4NTI4LCAwLCAwLjU5MTExXSxcbiAgICBcIjcxNVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41OTExMV0sXG4gICAgXCI3MjhcIjogWzAsIDAuNjk0NDQsIDAuMTAzMzMsIDAsIDAuNTkxMTFdLFxuICAgIFwiNzI5XCI6IFswLCAwLjY5NDQ0LCAwLjEyOTQ1LCAwLCAwLjM1NTU1XSxcbiAgICBcIjczMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC45NDg4OF0sXG4gICAgXCI3MzJcIjogWzAsIDAuNjk0NDQsIDAuMTE0NzIsIDAsIDAuNTkxMTFdLFxuICAgIFwiNzMzXCI6IFswLCAwLjY5NDQ0LCAwLjExNDcyLCAwLCAwLjU5MTExXSxcbiAgICBcIjkxNVwiOiBbMCwgMC42ODYxMSwgMC4xMjkwMywgMCwgMC42OTc3N10sXG4gICAgXCI5MTZcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOTQ0NDRdLFxuICAgIFwiOTIwXCI6IFswLCAwLjY4NjExLCAwLjA5MDYyLCAwLCAwLjg4NTU1XSxcbiAgICBcIjkyM1wiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44MDY2Nl0sXG4gICAgXCI5MjZcIjogWzAsIDAuNjg2MTEsIDAuMTUwOTIsIDAsIDAuNzY3NzddLFxuICAgIFwiOTI4XCI6IFswLCAwLjY4NjExLCAwLjE3MjA4LCAwLCAwLjg5NjFdLFxuICAgIFwiOTMxXCI6IFswLCAwLjY4NjExLCAwLjExNDMxLCAwLCAwLjgyNjY2XSxcbiAgICBcIjkzM1wiOiBbMCwgMC42ODYxMSwgMC4xMDc3OCwgMCwgMC44ODU1NV0sXG4gICAgXCI5MzRcIjogWzAsIDAuNjg2MTEsIDAuMDU2MzIsIDAsIDAuODI2NjZdLFxuICAgIFwiOTM2XCI6IFswLCAwLjY4NjExLCAwLjEwNzc4LCAwLCAwLjg4NTU1XSxcbiAgICBcIjkzN1wiOiBbMCwgMC42ODYxMSwgMC4wOTkyLCAwLCAwLjgyNjY2XSxcbiAgICBcIjgyMTFcIjogWzAsIDAuNDQ0NDQsIDAuMDk4MTEsIDAsIDAuNTkxMTFdLFxuICAgIFwiODIxMlwiOiBbMCwgMC40NDQ0NCwgMC4wOTgxMSwgMCwgMS4xODIyMV0sXG4gICAgXCI4MjE2XCI6IFswLCAwLjY5NDQ0LCAwLjEyOTQ1LCAwLCAwLjM1NTU1XSxcbiAgICBcIjgyMTdcIjogWzAsIDAuNjk0NDQsIDAuMTI5NDUsIDAsIDAuMzU1NTVdLFxuICAgIFwiODIyMFwiOiBbMCwgMC42OTQ0NCwgMC4xNjc3MiwgMCwgMC42MjA1NV0sXG4gICAgXCI4MjIxXCI6IFswLCAwLjY5NDQ0LCAwLjA3OTM5LCAwLCAwLjYyMDU1XVxuICB9LFxuICBcIk1haW4tSXRhbGljXCI6IHtcbiAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLjEyNDE3LCAwLCAwLjMwNjY3XSxcbiAgICBcIjM0XCI6IFswLCAwLjY5NDQ0LCAwLjA2OTYxLCAwLCAwLjUxNDQ0XSxcbiAgICBcIjM1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA2NjE2LCAwLCAwLjgxNzc3XSxcbiAgICBcIjM3XCI6IFswLjA1NTU2LCAwLjc1LCAwLjEzNjM5LCAwLCAwLjgxNzc3XSxcbiAgICBcIjM4XCI6IFswLCAwLjY5NDQ0LCAwLjA5Njk0LCAwLCAwLjc2NjY2XSxcbiAgICBcIjM5XCI6IFswLCAwLjY5NDQ0LCAwLjEyNDE3LCAwLCAwLjMwNjY3XSxcbiAgICBcIjQwXCI6IFswLjI1LCAwLjc1LCAwLjE2MTk0LCAwLCAwLjQwODg5XSxcbiAgICBcIjQxXCI6IFswLjI1LCAwLjc1LCAwLjAzNjk0LCAwLCAwLjQwODg5XSxcbiAgICBcIjQyXCI6IFswLCAwLjc1LCAwLjE0OTE3LCAwLCAwLjUxMTExXSxcbiAgICBcIjQzXCI6IFswLjA1NjY3LCAwLjU2MTY3LCAwLjAzNjk0LCAwLCAwLjc2NjY2XSxcbiAgICBcIjQ0XCI6IFswLjE5NDQ0LCAwLjEwNTU2LCAwLCAwLCAwLjMwNjY3XSxcbiAgICBcIjQ1XCI6IFswLCAwLjQzMDU2LCAwLjAyODI2LCAwLCAwLjM1Nzc4XSxcbiAgICBcIjQ2XCI6IFswLCAwLjEwNTU2LCAwLCAwLCAwLjMwNjY3XSxcbiAgICBcIjQ3XCI6IFswLjI1LCAwLjc1LCAwLjE2MTk0LCAwLCAwLjUxMTExXSxcbiAgICBcIjQ4XCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSxcbiAgICBcIjQ5XCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSxcbiAgICBcIjUwXCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSxcbiAgICBcIjUxXCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSxcbiAgICBcIjUyXCI6IFswLjE5NDQ0LCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSxcbiAgICBcIjUzXCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSxcbiAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSxcbiAgICBcIjU1XCI6IFswLjE5NDQ0LCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSxcbiAgICBcIjU2XCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSxcbiAgICBcIjU3XCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSxcbiAgICBcIjU4XCI6IFswLCAwLjQzMDU2LCAwLjA1ODIsIDAsIDAuMzA2NjddLFxuICAgIFwiNTlcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDU4MiwgMCwgMC4zMDY2N10sXG4gICAgXCI2MVwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAuMDY2MTYsIDAsIDAuNzY2NjZdLFxuICAgIFwiNjNcIjogWzAsIDAuNjk0NDQsIDAuMTIyNSwgMCwgMC41MTExMV0sXG4gICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMC4wOTU5NywgMCwgMC43NjY2Nl0sXG4gICAgXCI2NVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NDMzM10sXG4gICAgXCI2NlwiOiBbMCwgMC42ODMzMywgMC4xMDI1NywgMCwgMC43MDM4OV0sXG4gICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMC4xNDUyOCwgMCwgMC43MTU1NV0sXG4gICAgXCI2OFwiOiBbMCwgMC42ODMzMywgMC4wOTQwMywgMCwgMC43NTVdLFxuICAgIFwiNjlcIjogWzAsIDAuNjgzMzMsIDAuMTIwMjgsIDAsIDAuNjc4MzNdLFxuICAgIFwiNzBcIjogWzAsIDAuNjgzMzMsIDAuMTMzMDUsIDAsIDAuNjUyNzddLFxuICAgIFwiNzFcIjogWzAsIDAuNjgzMzMsIDAuMDg3MjIsIDAsIDAuNzczNjFdLFxuICAgIFwiNzJcIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDAsIDAuNzQzMzNdLFxuICAgIFwiNzNcIjogWzAsIDAuNjgzMzMsIDAuMTU4MDYsIDAsIDAuMzg1NTVdLFxuICAgIFwiNzRcIjogWzAsIDAuNjgzMzMsIDAuMTQwMjgsIDAsIDAuNTI1XSxcbiAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLjE0NTI4LCAwLCAwLjc2ODg4XSxcbiAgICBcIjc2XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjYyNzIyXSxcbiAgICBcIjc3XCI6IFswLCAwLjY4MzMzLCAwLjE2Mzg5LCAwLCAwLjg5NjY2XSxcbiAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLjE2Mzg5LCAwLCAwLjc0MzMzXSxcbiAgICBcIjc5XCI6IFswLCAwLjY4MzMzLCAwLjA5NDAzLCAwLCAwLjc2NjY2XSxcbiAgICBcIjgwXCI6IFswLCAwLjY4MzMzLCAwLjEwMjU3LCAwLCAwLjY3ODMzXSxcbiAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLjA5NDAzLCAwLCAwLjc2NjY2XSxcbiAgICBcIjgyXCI6IFswLCAwLjY4MzMzLCAwLjAzODY4LCAwLCAwLjcyOTQ0XSxcbiAgICBcIjgzXCI6IFswLCAwLjY4MzMzLCAwLjExOTcyLCAwLCAwLjU2MjIyXSxcbiAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLjEzMzA1LCAwLCAwLjcxNTU1XSxcbiAgICBcIjg1XCI6IFswLCAwLjY4MzMzLCAwLjE2Mzg5LCAwLCAwLjc0MzMzXSxcbiAgICBcIjg2XCI6IFswLCAwLjY4MzMzLCAwLjE4MzYxLCAwLCAwLjc0MzMzXSxcbiAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjE4MzYxLCAwLCAwLjk5ODg4XSxcbiAgICBcIjg4XCI6IFswLCAwLjY4MzMzLCAwLjE1ODA2LCAwLCAwLjc0MzMzXSxcbiAgICBcIjg5XCI6IFswLCAwLjY4MzMzLCAwLjE5MzgzLCAwLCAwLjc0MzMzXSxcbiAgICBcIjkwXCI6IFswLCAwLjY4MzMzLCAwLjE0NTI4LCAwLCAwLjYxMzMzXSxcbiAgICBcIjkxXCI6IFswLjI1LCAwLjc1LCAwLjE4NzUsIDAsIDAuMzA2NjddLFxuICAgIFwiOTNcIjogWzAuMjUsIDAuNzUsIDAuMTA1MjgsIDAsIDAuMzA2NjddLFxuICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAuMDY2NDYsIDAsIDAuNTExMTFdLFxuICAgIFwiOTVcIjogWzAuMzEsIDAuMTIwNTYsIDAuMDkyMDgsIDAsIDAuNTExMTFdLFxuICAgIFwiOTdcIjogWzAsIDAuNDMwNTYsIDAuMDc2NzEsIDAsIDAuNTExMTFdLFxuICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAuMDYzMTIsIDAsIDAuNDZdLFxuICAgIFwiOTlcIjogWzAsIDAuNDMwNTYsIDAuMDU2NTMsIDAsIDAuNDZdLFxuICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLjEwMzMzLCAwLCAwLjUxMTExXSxcbiAgICBcIjEwMVwiOiBbMCwgMC40MzA1NiwgMC4wNzUxNCwgMCwgMC40Nl0sXG4gICAgXCIxMDJcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMjExOTQsIDAsIDAuMzA2NjddLFxuICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjA4ODQ3LCAwLCAwLjQ2XSxcbiAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMC4wNzY3MSwgMCwgMC41MTExMV0sXG4gICAgXCIxMDVcIjogWzAsIDAuNjU1MzYsIDAuMTAxOSwgMCwgMC4zMDY2N10sXG4gICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjU1MzYsIDAuMTQ0NjcsIDAsIDAuMzA2NjddLFxuICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLjEwNzY0LCAwLCAwLjQ2XSxcbiAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMC4xMDMzMywgMCwgMC4yNTU1NV0sXG4gICAgXCIxMDlcIjogWzAsIDAuNDMwNTYsIDAuMDc2NzEsIDAsIDAuODE3NzddLFxuICAgIFwiMTEwXCI6IFswLCAwLjQzMDU2LCAwLjA3NjcxLCAwLCAwLjU2MjIyXSxcbiAgICBcIjExMVwiOiBbMCwgMC40MzA1NiwgMC4wNjMxMiwgMCwgMC41MTExMV0sXG4gICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDYzMTIsIDAsIDAuNTExMTFdLFxuICAgIFwiMTEzXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjA4ODQ3LCAwLCAwLjQ2XSxcbiAgICBcIjExNFwiOiBbMCwgMC40MzA1NiwgMC4xMDc2NCwgMCwgMC40MjE2Nl0sXG4gICAgXCIxMTVcIjogWzAsIDAuNDMwNTYsIDAuMDgyMDgsIDAsIDAuNDA4ODldLFxuICAgIFwiMTE2XCI6IFswLCAwLjYxNTA4LCAwLjA5NDg2LCAwLCAwLjMzMjIyXSxcbiAgICBcIjExN1wiOiBbMCwgMC40MzA1NiwgMC4wNzY3MSwgMCwgMC41MzY2Nl0sXG4gICAgXCIxMThcIjogWzAsIDAuNDMwNTYsIDAuMTA3NjQsIDAsIDAuNDZdLFxuICAgIFwiMTE5XCI6IFswLCAwLjQzMDU2LCAwLjEwNzY0LCAwLCAwLjY2NDQ0XSxcbiAgICBcIjEyMFwiOiBbMCwgMC40MzA1NiwgMC4xMjA0MiwgMCwgMC40NjM4OV0sXG4gICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDg4NDcsIDAsIDAuNDg1NTVdLFxuICAgIFwiMTIyXCI6IFswLCAwLjQzMDU2LCAwLjEyMjkyLCAwLCAwLjQwODg5XSxcbiAgICBcIjEyNlwiOiBbMC4zNSwgMC4zMTc4NiwgMC4xMTU4NSwgMCwgMC41MTExMV0sXG4gICAgXCIxNjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzY5MDldLFxuICAgIFwiMTY4XCI6IFswLCAwLjY2Nzg2LCAwLjEwNDc0LCAwLCAwLjUxMTExXSxcbiAgICBcIjE3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44MzEyOV0sXG4gICAgXCIxODRcIjogWzAuMTcwMTQsIDAsIDAsIDAsIDAuNDZdLFxuICAgIFwiMTk4XCI6IFswLCAwLjY4MzMzLCAwLjEyMDI4LCAwLCAwLjg4Mjc3XSxcbiAgICBcIjIxNlwiOiBbMC4wNDg2MSwgMC43MzE5NCwgMC4wOTQwMywgMCwgMC43NjY2Nl0sXG4gICAgXCIyMjNcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMTA1MTQsIDAsIDAuNTM2NjZdLFxuICAgIFwiMjMwXCI6IFswLCAwLjQzMDU2LCAwLjA3NTE0LCAwLCAwLjcxNTU1XSxcbiAgICBcIjI0OFwiOiBbMC4wOTcyMiwgMC41Mjc3OCwgMC4wOTE5NCwgMCwgMC41MTExMV0sXG4gICAgXCIzMDVcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDI3NzgsIDAuMzIyNDZdLFxuICAgIFwiMzM4XCI6IFswLCAwLjY4MzMzLCAwLjEyMDI4LCAwLCAwLjk4NDk5XSxcbiAgICBcIjMzOVwiOiBbMCwgMC40MzA1NiwgMC4wNzUxNCwgMCwgMC43MTU1NV0sXG4gICAgXCI1NjdcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzQsIDAuMzg0MDNdLFxuICAgIFwiNzEwXCI6IFswLCAwLjY5NDQ0LCAwLjA2NjQ2LCAwLCAwLjUxMTExXSxcbiAgICBcIjcxMVwiOiBbMCwgMC42Mjg0NywgMC4wODI5NSwgMCwgMC41MTExMV0sXG4gICAgXCI3MTNcIjogWzAsIDAuNTYxNjcsIDAuMTAzMzMsIDAsIDAuNTExMTFdLFxuICAgIFwiNzE0XCI6IFswLCAwLjY5NDQ0LCAwLjA5Njk0LCAwLCAwLjUxMTExXSxcbiAgICBcIjcxNVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41MTExMV0sXG4gICAgXCI3MjhcIjogWzAsIDAuNjk0NDQsIDAuMTA4MDYsIDAsIDAuNTExMTFdLFxuICAgIFwiNzI5XCI6IFswLCAwLjY2Nzg2LCAwLjExNzUyLCAwLCAwLjMwNjY3XSxcbiAgICBcIjczMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44MzEyOV0sXG4gICAgXCI3MzJcIjogWzAsIDAuNjY3ODYsIDAuMTE1ODUsIDAsIDAuNTExMTFdLFxuICAgIFwiNzMzXCI6IFswLCAwLjY5NDQ0LCAwLjEyMjUsIDAsIDAuNTExMTFdLFxuICAgIFwiOTE1XCI6IFswLCAwLjY4MzMzLCAwLjEzMzA1LCAwLCAwLjYyNzIyXSxcbiAgICBcIjkxNlwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC44MTc3N10sXG4gICAgXCI5MjBcIjogWzAsIDAuNjgzMzMsIDAuMDk0MDMsIDAsIDAuNzY2NjZdLFxuICAgIFwiOTIzXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjY5MjIyXSxcbiAgICBcIjkyNlwiOiBbMCwgMC42ODMzMywgMC4xNTI5NCwgMCwgMC42NjQ0NF0sXG4gICAgXCI5MjhcIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDAsIDAuNzQzMzNdLFxuICAgIFwiOTMxXCI6IFswLCAwLjY4MzMzLCAwLjEyMDI4LCAwLCAwLjcxNTU1XSxcbiAgICBcIjkzM1wiOiBbMCwgMC42ODMzMywgMC4xMTExMSwgMCwgMC43NjY2Nl0sXG4gICAgXCI5MzRcIjogWzAsIDAuNjgzMzMsIDAuMDU5ODYsIDAsIDAuNzE1NTVdLFxuICAgIFwiOTM2XCI6IFswLCAwLjY4MzMzLCAwLjExMTExLCAwLCAwLjc2NjY2XSxcbiAgICBcIjkzN1wiOiBbMCwgMC42ODMzMywgMC4xMDI1NywgMCwgMC43MTU1NV0sXG4gICAgXCI4MjExXCI6IFswLCAwLjQzMDU2LCAwLjA5MjA4LCAwLCAwLjUxMTExXSxcbiAgICBcIjgyMTJcIjogWzAsIDAuNDMwNTYsIDAuMDkyMDgsIDAsIDEuMDIyMjJdLFxuICAgIFwiODIxNlwiOiBbMCwgMC42OTQ0NCwgMC4xMjQxNywgMCwgMC4zMDY2N10sXG4gICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLjEyNDE3LCAwLCAwLjMwNjY3XSxcbiAgICBcIjgyMjBcIjogWzAsIDAuNjk0NDQsIDAuMTY4NSwgMCwgMC41MTQ0NF0sXG4gICAgXCI4MjIxXCI6IFswLCAwLjY5NDQ0LCAwLjA2OTYxLCAwLCAwLjUxNDQ0XSxcbiAgICBcIjg0NjNcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNTQwMjhdXG4gIH0sXG4gIFwiTWFpbi1SZWd1bGFyXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjM0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiMzZcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCIzOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zODg4OV0sXG4gICAgXCI0MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zODg4OV0sXG4gICAgXCI0MlwiOiBbMCwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjQzXCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjQ0XCI6IFswLjE5NDQ0LCAwLjEwNTU2LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjQ1XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjMzMzMzXSxcbiAgICBcIjQ2XCI6IFswLCAwLjEwNTU2LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjQ3XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiNDhcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI0OVwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjUwXCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNTFcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI1MlwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjUzXCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNTRcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI1NVwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjU2XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNTdcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI1OFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI1OVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI2MFwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNjFcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjYyXCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI2NVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NV0sXG4gICAgXCI2NlwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43MDgzNF0sXG4gICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI2OFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NjM4OV0sXG4gICAgXCI2OVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42ODA1Nl0sXG4gICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42NTI3OF0sXG4gICAgXCI3MVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43ODQ3Ml0sXG4gICAgXCI3MlwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NV0sXG4gICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMCwgMCwgMC4zNjExMV0sXG4gICAgXCI3NFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC41MTM4OV0sXG4gICAgXCI3NVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42MjVdLFxuICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuOTE2NjddLFxuICAgIFwiNzhcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzVdLFxuICAgIFwiNzlcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNjgwNTZdLFxuICAgIFwiODFcIjogWzAuMTk0NDQsIDAuNjgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODJcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzM2MTFdLFxuICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiODRcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODVcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzVdLFxuICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMDEzODksIDAsIDAuNzVdLFxuICAgIFwiODdcIjogWzAsIDAuNjgzMzMsIDAuMDEzODksIDAsIDEuMDI3NzhdLFxuICAgIFwiODhcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzVdLFxuICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMDI1LCAwLCAwLjc1XSxcbiAgICBcIjkwXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjkxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjkyXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiOTNcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI5NVwiOiBbMC4zMSwgMC4xMjA1NiwgMC4wMjc3OCwgMCwgMC41XSxcbiAgICBcIjk3XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjVdLFxuICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiOTlcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjEwMVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCIxMDJcIjogWzAsIDAuNjk0NDQsIDAuMDc3NzgsIDAsIDAuMzA1NTZdLFxuICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAxMzg5LCAwLCAwLjVdLFxuICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjEwNVwiOiBbMCwgMC42Njc4NiwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjY3ODYsIDAsIDAsIDAuMzA1NTZdLFxuICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNzc4XSxcbiAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCIxMDlcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiMTEwXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjExMVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41XSxcbiAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuNTI3NzhdLFxuICAgIFwiMTE0XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjM5MTY3XSxcbiAgICBcIjExNVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC4zOTQ0NV0sXG4gICAgXCIxMTZcIjogWzAsIDAuNjE1MDgsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiMTE3XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjExOFwiOiBbMCwgMC40MzA1NiwgMC4wMTM4OSwgMCwgMC41Mjc3OF0sXG4gICAgXCIxMTlcIjogWzAsIDAuNDMwNTYsIDAuMDEzODksIDAsIDAuNzIyMjJdLFxuICAgIFwiMTIwXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNzc4XSxcbiAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMTM4OSwgMCwgMC41Mjc3OF0sXG4gICAgXCIxMjJcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMTIzXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiMTI0XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjEyNVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjEyNlwiOiBbMC4zNSwgMC4zMTc4NiwgMCwgMCwgMC41XSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIxNjdcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMTY4XCI6IFswLCAwLjY2Nzg2LCAwLCAwLCAwLjVdLFxuICAgIFwiMTcyXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjE3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43NV0sXG4gICAgXCIxNzdcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTgyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjE4NFwiOiBbMC4xNzAxNCwgMCwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCIxOThcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuOTAyNzhdLFxuICAgIFwiMjE1XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjIxNlwiOiBbMC4wNDg2MSwgMC43MzE5NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIyMjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCIyMzBcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiMjQ3XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjI0OFwiOiBbMC4wOTcyMiwgMC41Mjc3OCwgMCwgMCwgMC41XSxcbiAgICBcIjMwNVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCIzMzhcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDEuMDEzODldLFxuICAgIFwiMzM5XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU2N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI3MTBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI3MTFcIjogWzAsIDAuNjI4NDcsIDAsIDAsIDAuNV0sXG4gICAgXCI3MTNcIjogWzAsIDAuNTY3NzgsIDAsIDAsIDAuNV0sXG4gICAgXCI3MTRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI3MTVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI3MjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI3MjlcIjogWzAsIDAuNjY3ODYsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNzMwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc1XSxcbiAgICBcIjczMlwiOiBbMCwgMC42Njc4NiwgMCwgMCwgMC41XSxcbiAgICBcIjczM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjkxNVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42MjVdLFxuICAgIFwiOTE2XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjkyMFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5MjNcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNjk0NDVdLFxuICAgIFwiOTI2XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjkyOFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NV0sXG4gICAgXCI5MzFcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTMzXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjkzNFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI5MzZcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTM3XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjgyMTFcIjogWzAsIDAuNDMwNTYsIDAuMDI3NzgsIDAsIDAuNV0sXG4gICAgXCI4MjEyXCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwLCAxLjBdLFxuICAgIFwiODIxNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjgyMjBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI4MjIxXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiODIyNFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCI4MjI1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjgyMzBcIjogWzAsIDAuMTIsIDAsIDAsIDEuMTcyXSxcbiAgICBcIjgyNDJcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuMjc1XSxcbiAgICBcIjg0MDdcIjogWzAsIDAuNzE0NDQsIDAuMTUzODIsIDAsIDAuNV0sXG4gICAgXCI4NDYzXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjU0MDI4XSxcbiAgICBcIjg0NjVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODQ2N1wiOiBbMCwgMC42OTQ0NCwgMCwgMC4xMTExMSwgMC40MTY2N10sXG4gICAgXCI4NDcyXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjExMTExLCAwLjYzNjQ2XSxcbiAgICBcIjg0NzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODUwMVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4NTkyXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg1OTNcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI4NTk0XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg1OTVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI4NTk2XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg1OTdcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCI4NTk4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxLjBdLFxuICAgIFwiODU5OVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4wXSxcbiAgICBcIjg2MDBcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjAxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxLjBdLFxuICAgIFwiODYxNFwiOiBbMC4wMTEsIDAuNTExLCAwLCAwLCAxLjBdLFxuICAgIFwiODYxN1wiOiBbMC4wMTEsIDAuNTExLCAwLCAwLCAxLjEyNl0sXG4gICAgXCI4NjE4XCI6IFswLjAxMSwgMC41MTEsIDAsIDAsIDEuMTI2XSxcbiAgICBcIjg2MzZcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODYzN1wiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjQwXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2NDFcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODY1MlwiOiBbMC4wMTEsIDAuNjcxLCAwLCAwLCAxLjBdLFxuICAgIFwiODY1NlwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjU3XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg2NThcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODY1OVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4NjYwXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2NjFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODcwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI4NzA2XCI6IFswLCAwLjY5NDQ0LCAwLjA1NTU2LCAwLjA4MzM0LCAwLjUzMDldLFxuICAgIFwiODcwN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI4NzA5XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiODcxMVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC44MzMzNF0sXG4gICAgXCI4NzEyXCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NzE1XCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NzIyXCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3MjNcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODcyNVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjg3MjZcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCI4NzI3XCI6IFstMC4wMzQ3MiwgMC40NjUyOCwgMCwgMCwgMC41XSxcbiAgICBcIjg3MjhcIjogWy0wLjA1NTU1LCAwLjQ0NDQ1LCAwLCAwLCAwLjVdLFxuICAgIFwiODcyOVwiOiBbLTAuMDU1NTUsIDAuNDQ0NDUsIDAsIDAsIDAuNV0sXG4gICAgXCI4NzMwXCI6IFswLjIsIDAuOCwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCI4NzMzXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3MzRcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDEuMF0sXG4gICAgXCI4NzM2XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg3MzlcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiODc0MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjg3NDNcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODc0NFwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NzQ1XCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg3NDZcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODc0N1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4xMTExMSwgMCwgMC40MTY2N10sXG4gICAgXCI4NzY0XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjg3NzFcIjogWy0wLjAzNjI1LCAwLjQ2Mzc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3NzNcIjogWy0wLjAyMiwgMC41ODksIDAsIDAsIDEuMF0sXG4gICAgXCI4Nzc2XCI6IFstMC4wMTY4OCwgMC40ODMxMiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzgxXCI6IFstMC4wMzYyNSwgMC40NjM3NSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4Nzg0XCI6IFstMC4xMzMsIDAuNjcsIDAsIDAsIDAuNzc4XSxcbiAgICBcIjg4MDFcIjogWy0wLjAzNjI1LCAwLjQ2Mzc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MDRcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgwNVwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODEwXCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMS4wXSxcbiAgICBcIjg4MTFcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAxLjBdLFxuICAgIFwiODgyNlwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgyN1wiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgzNFwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgzNVwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgzOFwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODM5XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NDZcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODg0OVwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODUwXCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NTFcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODg1MlwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4ODUzXCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NTRcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg1NVwiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODU2XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NTdcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg2NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4ODY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg4NjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg2OVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODcyXCI6IFswLjI0OSwgMC43NSwgMCwgMCwgMC44NjddLFxuICAgIFwiODkwMFwiOiBbLTAuMDU1NTUsIDAuNDQ0NDUsIDAsIDAsIDAuNV0sXG4gICAgXCI4OTAxXCI6IFstMC4wNTU1NSwgMC40NDQ0NSwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI4OTAyXCI6IFstMC4wMzQ3MiwgMC40NjUyOCwgMCwgMCwgMC41XSxcbiAgICBcIjg5MDRcIjogWzAuMDA1LCAwLjUwNSwgMCwgMCwgMC45XSxcbiAgICBcIjg5NDJcIjogWzAuMDMsIDAuOSwgMCwgMCwgMC4yNzhdLFxuICAgIFwiODk0M1wiOiBbLTAuMTksIDAuMzEsIDAsIDAsIDEuMTcyXSxcbiAgICBcIjg5NDVcIjogWy0wLjEsIDAuODIsIDAsIDAsIDEuMjgyXSxcbiAgICBcIjg5NjhcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiODk2OVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCI4OTcwXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjg5NzFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiODk5NFwiOiBbLTAuMTQyMzYsIDAuMzU3NjQsIDAsIDAsIDEuMF0sXG4gICAgXCI4OTk1XCI6IFstMC4xNDIzNiwgMC4zNTc2NCwgMCwgMCwgMS4wXSxcbiAgICBcIjkxMzZcIjogWzAuMjQ0LCAwLjc0NCwgMCwgMCwgMC40MTJdLFxuICAgIFwiOTEzN1wiOiBbMC4yNDQsIDAuNzQ0LCAwLCAwLCAwLjQxMl0sXG4gICAgXCI5NjUxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjk2NTdcIjogWy0wLjAzNDcyLCAwLjQ2NTI4LCAwLCAwLCAwLjVdLFxuICAgIFwiOTY2MVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI5NjY3XCI6IFstMC4wMzQ3MiwgMC40NjUyOCwgMCwgMCwgMC41XSxcbiAgICBcIjk3MTFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMF0sXG4gICAgXCI5ODI0XCI6IFswLjEyOTYzLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjk4MjVcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTgyNlwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5ODI3XCI6IFswLjEyOTYzLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjk4MzdcIjogWzAsIDAuNzUsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiOTgzOFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC4zODg4OV0sXG4gICAgXCI5ODM5XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjEwMjE2XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjEwMjE3XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjEwMjIyXCI6IFswLjI0NCwgMC43NDQsIDAsIDAsIDAuNDEyXSxcbiAgICBcIjEwMjIzXCI6IFswLjI0NCwgMC43NDQsIDAsIDAsIDAuNDEyXSxcbiAgICBcIjEwMjI5XCI6IFswLjAxMSwgMC41MTEsIDAsIDAsIDEuNjA5XSxcbiAgICBcIjEwMjMwXCI6IFswLjAxMSwgMC41MTEsIDAsIDAsIDEuNjM4XSxcbiAgICBcIjEwMjMxXCI6IFswLjAxMSwgMC41MTEsIDAsIDAsIDEuODU5XSxcbiAgICBcIjEwMjMyXCI6IFswLjAyNCwgMC41MjUsIDAsIDAsIDEuNjA5XSxcbiAgICBcIjEwMjMzXCI6IFswLjAyNCwgMC41MjUsIDAsIDAsIDEuNjM4XSxcbiAgICBcIjEwMjM0XCI6IFswLjAyNCwgMC41MjUsIDAsIDAsIDEuODU4XSxcbiAgICBcIjEwMjM2XCI6IFswLjAxMSwgMC41MTEsIDAsIDAsIDEuNjM4XSxcbiAgICBcIjEwODE1XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc1XSxcbiAgICBcIjEwOTI3XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTI4XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3Mzc2XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwXVxuICB9LFxuICBcIk1hdGgtQm9sZEl0YWxpY1wiOiB7XG4gICAgXCI2NVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44Njk0NF0sXG4gICAgXCI2NlwiOiBbMCwgMC42ODYxMSwgMC4wNDgzNSwgMCwgMC44NjY0XSxcbiAgICBcIjY3XCI6IFswLCAwLjY4NjExLCAwLjA2OTc5LCAwLCAwLjgxNjk0XSxcbiAgICBcIjY4XCI6IFswLCAwLjY4NjExLCAwLjAzMTk0LCAwLCAwLjkzODEyXSxcbiAgICBcIjY5XCI6IFswLCAwLjY4NjExLCAwLjA1NDUxLCAwLCAwLjgxMDA3XSxcbiAgICBcIjcwXCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwLCAwLjY4ODg5XSxcbiAgICBcIjcxXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg4NjczXSxcbiAgICBcIjcyXCI6IFswLCAwLjY4NjExLCAwLjA4MjI5LCAwLCAwLjk4MjI5XSxcbiAgICBcIjczXCI6IFswLCAwLjY4NjExLCAwLjA3Nzc4LCAwLCAwLjUxMTExXSxcbiAgICBcIjc0XCI6IFswLCAwLjY4NjExLCAwLjEwMDY5LCAwLCAwLjYzMTI1XSxcbiAgICBcIjc1XCI6IFswLCAwLjY4NjExLCAwLjA2OTc5LCAwLCAwLjk3MTE4XSxcbiAgICBcIjc2XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjc1NTU1XSxcbiAgICBcIjc3XCI6IFswLCAwLjY4NjExLCAwLjExNDI0LCAwLCAxLjE0MjAxXSxcbiAgICBcIjc4XCI6IFswLCAwLjY4NjExLCAwLjExNDI0LCAwLCAwLjk1MDM0XSxcbiAgICBcIjc5XCI6IFswLCAwLjY4NjExLCAwLjAzMTk0LCAwLCAwLjgzNjY2XSxcbiAgICBcIjgwXCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwLCAwLjcyMzA5XSxcbiAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4NjExLCAwLCAwLCAwLjg2ODYxXSxcbiAgICBcIjgyXCI6IFswLCAwLjY4NjExLCAwLjAwNDIxLCAwLCAwLjg3MjM1XSxcbiAgICBcIjgzXCI6IFswLCAwLjY4NjExLCAwLjA1MzgyLCAwLCAwLjY5MjcxXSxcbiAgICBcIjg0XCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwLCAwLjYzNjYzXSxcbiAgICBcIjg1XCI6IFswLCAwLjY4NjExLCAwLjExNDI0LCAwLCAwLjgwMDI3XSxcbiAgICBcIjg2XCI6IFswLCAwLjY4NjExLCAwLjI1NTU1LCAwLCAwLjY3Nzc4XSxcbiAgICBcIjg3XCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwLCAxLjA5MzA1XSxcbiAgICBcIjg4XCI6IFswLCAwLjY4NjExLCAwLjA3Nzc4LCAwLCAwLjk0NzIyXSxcbiAgICBcIjg5XCI6IFswLCAwLjY4NjExLCAwLjI1NTU1LCAwLCAwLjY3NDU4XSxcbiAgICBcIjkwXCI6IFswLCAwLjY4NjExLCAwLjA2OTc5LCAwLCAwLjc3MjU3XSxcbiAgICBcIjk3XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjYzMjg3XSxcbiAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjUyMDgzXSxcbiAgICBcIjk5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjUxMzQyXSxcbiAgICBcIjEwMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MDk3Ml0sXG4gICAgXCIxMDFcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTUzNjFdLFxuICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjExMDQyLCAwLCAwLjU2ODA2XSxcbiAgICBcIjEwM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMzcwNCwgMCwgMC41NDQ5XSxcbiAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42Njc1OV0sXG4gICAgXCIxMDVcIjogWzAsIDAuNjkzMjYsIDAsIDAsIDAuNDA0OF0sXG4gICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjkzMjYsIDAuMDYyMiwgMCwgMC40NzA4M10sXG4gICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAuMDE4NTIsIDAsIDAuNjAzN10sXG4gICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAuMDA4OCwgMCwgMC4zNDgxNV0sXG4gICAgXCIxMDlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDEuMDMyNF0sXG4gICAgXCIxMTBcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNzEyOTZdLFxuICAgIFwiMTExXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjU4NDcyXSxcbiAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC42MDA5Ml0sXG4gICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNTQyMTNdLFxuICAgIFwiMTE0XCI6IFswLCAwLjQ0NDQ0LCAwLjAzMTk0LCAwLCAwLjUyODddLFxuICAgIFwiMTE1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjUzMTI1XSxcbiAgICBcIjExNlwiOiBbMCwgMC42MzQ5MiwgMCwgMCwgMC40MTUyOF0sXG4gICAgXCIxMTdcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNjgxMDJdLFxuICAgIFwiMTE4XCI6IFswLCAwLjQ0NDQ0LCAwLjAzNzA0LCAwLCAwLjU2NjY2XSxcbiAgICBcIjExOVwiOiBbMCwgMC40NDQ0NCwgMC4wMjc3OCwgMCwgMC44MzE0OF0sXG4gICAgXCIxMjBcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNjU5MDNdLFxuICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAzNzA0LCAwLCAwLjU5MDI4XSxcbiAgICBcIjEyMlwiOiBbMCwgMC40NDQ0NCwgMC4wNDIxMywgMCwgMC41NTUwOV0sXG4gICAgXCI5MTVcIjogWzAsIDAuNjg2MTEsIDAuMTU5NzIsIDAsIDAuNjU2OTRdLFxuICAgIFwiOTE2XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjk1ODMzXSxcbiAgICBcIjkyMFwiOiBbMCwgMC42ODYxMSwgMC4wMzE5NCwgMCwgMC44NjcyMl0sXG4gICAgXCI5MjNcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODA1NTVdLFxuICAgIFwiOTI2XCI6IFswLCAwLjY4NjExLCAwLjA3NDU4LCAwLCAwLjg0MTI1XSxcbiAgICBcIjkyOFwiOiBbMCwgMC42ODYxMSwgMC4wODIyOSwgMCwgMC45ODIyOV0sXG4gICAgXCI5MzFcIjogWzAsIDAuNjg2MTEsIDAuMDU0NTEsIDAsIDAuODg1MDddLFxuICAgIFwiOTMzXCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwLCAwLjY3MDgzXSxcbiAgICBcIjkzNFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCI5MzZcIjogWzAsIDAuNjg2MTEsIDAuMTE2NTMsIDAsIDAuNzE0MDJdLFxuICAgIFwiOTM3XCI6IFswLCAwLjY4NjExLCAwLjA0ODM1LCAwLCAwLjg3ODldLFxuICAgIFwiOTQ1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjc2MDY0XSxcbiAgICBcIjk0NlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wMzQwMywgMCwgMC42NTk3Ml0sXG4gICAgXCI5NDdcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDYzODksIDAsIDAuNTkwMDNdLFxuICAgIFwiOTQ4XCI6IFswLCAwLjY5NDQ0LCAwLjAzODE5LCAwLCAwLjUyMjIyXSxcbiAgICBcIjk0OVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41Mjg4Ml0sXG4gICAgXCI5NTBcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDYyMTUsIDAsIDAuNTA4MzNdLFxuICAgIFwiOTUxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAzNzA0LCAwLCAwLjZdLFxuICAgIFwiOTUyXCI6IFswLCAwLjY5NDQ0LCAwLjAzMTk0LCAwLCAwLjU2MThdLFxuICAgIFwiOTUzXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjQxMjA0XSxcbiAgICBcIjk1NFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC42Njc1OV0sXG4gICAgXCI5NTVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjcwODNdLFxuICAgIFwiOTU2XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjcwNzg3XSxcbiAgICBcIjk1N1wiOiBbMCwgMC40NDQ0NCwgMC4wNjg5OCwgMCwgMC41NzY4NV0sXG4gICAgXCI5NThcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDMwMjEsIDAsIDAuNTA4MzNdLFxuICAgIFwiOTU5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjU4NDcyXSxcbiAgICBcIjk2MFwiOiBbMCwgMC40NDQ0NCwgMC4wMzcwNCwgMCwgMC42ODI0MV0sXG4gICAgXCI5NjFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNjExOF0sXG4gICAgXCI5NjJcIjogWzAuMDk3MjIsIDAuNDQ0NDQsIDAuMDc5MTcsIDAsIDAuNDIzNjFdLFxuICAgIFwiOTYzXCI6IFswLCAwLjQ0NDQ0LCAwLjAzNzA0LCAwLCAwLjY4NTg4XSxcbiAgICBcIjk2NFwiOiBbMCwgMC40NDQ0NCwgMC4xMzQ3MiwgMCwgMC41MjA4M10sXG4gICAgXCI5NjVcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNjMwNTVdLFxuICAgIFwiOTY2XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjc0NzIyXSxcbiAgICBcIjk2N1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC43MTgwNV0sXG4gICAgXCI5NjhcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDM3MDQsIDAsIDAuNzU4MzNdLFxuICAgIFwiOTY5XCI6IFswLCAwLjQ0NDQ0LCAwLjAzNzA0LCAwLCAwLjcxNzgyXSxcbiAgICBcIjk3N1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42OTE1NV0sXG4gICAgXCI5ODFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNzEyNV0sXG4gICAgXCI5ODJcIjogWzAsIDAuNDQ0NDQsIDAuMDMxOTQsIDAsIDAuOTc1XSxcbiAgICBcIjEwMDlcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNjExOF0sXG4gICAgXCIxMDEzXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjQ4MzMzXVxuICB9LFxuICBcIk1hdGgtSXRhbGljXCI6IHtcbiAgICBcIjY1XCI6IFswLCAwLjY4MzMzLCAwLCAwLjEzODg5LCAwLjc1XSxcbiAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLjA1MDE3LCAwLjA4MzM0LCAwLjc1ODUxXSxcbiAgICBcIjY3XCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA4MzM0LCAwLjcxNDcyXSxcbiAgICBcIjY4XCI6IFswLCAwLjY4MzMzLCAwLjAyNzc4LCAwLjA1NTU2LCAwLjgyNzkyXSxcbiAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0LCAwLjczODJdLFxuICAgIFwiNzBcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDgzMzQsIDAuNjQzMDZdLFxuICAgIFwiNzFcIjogWzAsIDAuNjgzMzMsIDAsIDAuMDgzMzQsIDAuNzg2MjVdLFxuICAgIFwiNzJcIjogWzAsIDAuNjgzMzMsIDAuMDgxMjUsIDAuMDU1NTYsIDAuODMxMjVdLFxuICAgIFwiNzNcIjogWzAsIDAuNjgzMzMsIDAuMDc4NDcsIDAuMTExMTEsIDAuNDM5NThdLFxuICAgIFwiNzRcIjogWzAsIDAuNjgzMzMsIDAuMDk2MTgsIDAuMTY2NjcsIDAuNTU0NTFdLFxuICAgIFwiNzVcIjogWzAsIDAuNjgzMzMsIDAuMDcxNTMsIDAuMDU1NTYsIDAuODQ5MzFdLFxuICAgIFwiNzZcIjogWzAsIDAuNjgzMzMsIDAsIDAuMDI3NzgsIDAuNjgwNTZdLFxuICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAuMTA5MDMsIDAuMDgzMzQsIDAuOTcwMTRdLFxuICAgIFwiNzhcIjogWzAsIDAuNjgzMzMsIDAuMTA5MDMsIDAuMDgzMzQsIDAuODAzNDddLFxuICAgIFwiNzlcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMDgzMzQsIDAuNzYyNzhdLFxuICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDgzMzQsIDAuNjQyMDFdLFxuICAgIFwiODFcIjogWzAuMTk0NDQsIDAuNjgzMzMsIDAsIDAuMDgzMzQsIDAuNzkwNTZdLFxuICAgIFwiODJcIjogWzAsIDAuNjgzMzMsIDAuMDA3NzMsIDAuMDgzMzQsIDAuNzU5MjldLFxuICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAuMDU3NjQsIDAuMDgzMzQsIDAuNjEzMl0sXG4gICAgXCI4NFwiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wODMzNCwgMC41ODQzOF0sXG4gICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMC4xMDkwMywgMC4wMjc3OCwgMC42ODI3OF0sXG4gICAgXCI4NlwiOiBbMCwgMC42ODMzMywgMC4yMjIyMiwgMCwgMC41ODMzM10sXG4gICAgXCI4N1wiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMCwgMC45NDQ0NV0sXG4gICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4wODMzNCwgMC44Mjg0N10sXG4gICAgXCI4OVwiOiBbMCwgMC42ODMzMywgMC4yMjIyMiwgMCwgMC41ODA1Nl0sXG4gICAgXCI5MFwiOiBbMCwgMC42ODMzMywgMC4wNzE1MywgMC4wODMzNCwgMC42ODI2NF0sXG4gICAgXCI5N1wiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41Mjg1OV0sXG4gICAgXCI5OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC40MjkxN10sXG4gICAgXCI5OVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1NiwgMC40MzI3Nl0sXG4gICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDAuMTY2NjcsIDAuNTIwNDldLFxuICAgIFwiMTAxXCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjQ2NTYzXSxcbiAgICBcIjEwMlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4xMDc2NCwgMC4xNjY2NywgMC40ODk1OV0sXG4gICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzgsIDAuNDc2OTddLFxuICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NjE2XSxcbiAgICBcIjEwNVwiOiBbMCwgMC42NTk1MiwgMCwgMCwgMC4zNDQ1MV0sXG4gICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjU5NTIsIDAuMDU3MjQsIDAsIDAuNDExODFdLFxuICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLjAzMTQ4LCAwLCAwLjUyMDZdLFxuICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLjAxOTY4LCAwLjA4MzM0LCAwLjI5ODM4XSxcbiAgICBcIjEwOVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC44NzgwMV0sXG4gICAgXCIxMTBcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNjAwMjNdLFxuICAgIFwiMTExXCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjQ4NDcyXSxcbiAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wODMzNCwgMC41MDMxM10sXG4gICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDgzMzQsIDAuNDQ2NDFdLFxuICAgIFwiMTE0XCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwLjA1NTU2LCAwLjQ1MTE2XSxcbiAgICBcIjExNVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1NiwgMC40Njg3NV0sXG4gICAgXCIxMTZcIjogWzAsIDAuNjE1MDgsIDAsIDAuMDgzMzQsIDAuMzYxMTFdLFxuICAgIFwiMTE3XCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4LCAwLjU3MjQ2XSxcbiAgICBcIjExOFwiOiBbMCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wMjc3OCwgMC40ODQ3Ml0sXG4gICAgXCIxMTlcIjogWzAsIDAuNDMwNTYsIDAuMDI2OTEsIDAuMDgzMzQsIDAuNzE1OTJdLFxuICAgIFwiMTIwXCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4LCAwLjU3MTUzXSxcbiAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wNTU1NiwgMC40OTAyOF0sXG4gICAgXCIxMjJcIjogWzAsIDAuNDMwNTYsIDAuMDQzOTgsIDAuMDU1NTYsIDAuNDY1MDVdLFxuICAgIFwiOTE1XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0LCAwLjYxNTI4XSxcbiAgICBcIjkxNlwiOiBbMCwgMC42ODMzMywgMCwgMC4xNjY2NywgMC44MzMzNF0sXG4gICAgXCI5MjBcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMDgzMzQsIDAuNzYyNzhdLFxuICAgIFwiOTIzXCI6IFswLCAwLjY4MzMzLCAwLCAwLjE2NjY3LCAwLjY5NDQ1XSxcbiAgICBcIjkyNlwiOiBbMCwgMC42ODMzMywgMC4wNzU2OSwgMC4wODMzNCwgMC43NDIzNl0sXG4gICAgXCI5MjhcIjogWzAsIDAuNjgzMzMsIDAuMDgxMjUsIDAuMDU1NTYsIDAuODMxMjVdLFxuICAgIFwiOTMxXCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0LCAwLjc3OTg2XSxcbiAgICBcIjkzM1wiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wNTU1NiwgMC41ODMzM10sXG4gICAgXCI5MzRcIjogWzAsIDAuNjgzMzMsIDAsIDAuMDgzMzQsIDAuNjY2NjddLFxuICAgIFwiOTM2XCI6IFswLCAwLjY4MzMzLCAwLjExLCAwLjA1NTU2LCAwLjYxMjIyXSxcbiAgICBcIjkzN1wiOiBbMCwgMC42ODMzMywgMC4wNTAxNywgMC4wODMzNCwgMC43NzI0XSxcbiAgICBcIjk0NVwiOiBbMCwgMC40MzA1NiwgMC4wMDM3LCAwLjAyNzc4LCAwLjYzOTddLFxuICAgIFwiOTQ2XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA1Mjc4LCAwLjA4MzM0LCAwLjU2NTYzXSxcbiAgICBcIjk0N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wNTU1NiwgMCwgMC41MTc3M10sXG4gICAgXCI5NDhcIjogWzAsIDAuNjk0NDQsIDAuMDM3ODUsIDAuMDU1NTYsIDAuNDQ0NDRdLFxuICAgIFwiOTQ5XCI6IFswLCAwLjQzMDU2LCAwLCAwLjA4MzM0LCAwLjQ2NjMyXSxcbiAgICBcIjk1MFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNzM3OCwgMC4wODMzNCwgMC40Mzc1XSxcbiAgICBcIjk1MVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wNTU1NiwgMC40OTY1M10sXG4gICAgXCI5NTJcIjogWzAsIDAuNjk0NDQsIDAuMDI3NzgsIDAuMDgzMzQsIDAuNDY5NDRdLFxuICAgIFwiOTUzXCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjM1Mzk0XSxcbiAgICBcIjk1NFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41NzYxNl0sXG4gICAgXCI5NTVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTgzMzRdLFxuICAgIFwiOTU2XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjAyNzc4LCAwLjYwMjU1XSxcbiAgICBcIjk1N1wiOiBbMCwgMC40MzA1NiwgMC4wNjM2NiwgMC4wMjc3OCwgMC40OTM5OF0sXG4gICAgXCI5NThcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDQ2MDEsIDAuMTExMTEsIDAuNDM3NV0sXG4gICAgXCI5NTlcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuNDg0NzJdLFxuICAgIFwiOTYwXCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLCAwLjU3MDAzXSxcbiAgICBcIjk2MVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wODMzNCwgMC41MTcwMl0sXG4gICAgXCI5NjJcIjogWzAuMDk3MjIsIDAuNDMwNTYsIDAuMDc5ODYsIDAuMDgzMzQsIDAuMzYyODVdLFxuICAgIFwiOTYzXCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLCAwLjU3MTQxXSxcbiAgICBcIjk2NFwiOiBbMCwgMC40MzA1NiwgMC4xMTMyLCAwLjAyNzc4LCAwLjQzNzE1XSxcbiAgICBcIjk2NVwiOiBbMCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wMjc3OCwgMC41NDAyOF0sXG4gICAgXCI5NjZcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzQsIDAuNjU0MTddLFxuICAgIFwiOTY3XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjYyNTY5XSxcbiAgICBcIjk2OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wMzU4OCwgMC4xMTExMSwgMC42NTEzOV0sXG4gICAgXCI5NjlcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAsIDAuNjIyNDVdLFxuICAgIFwiOTc3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLjA4MzM0LCAwLjU5MTQ0XSxcbiAgICBcIjk4MVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMC4wODMzNCwgMC41OTU4M10sXG4gICAgXCI5ODJcIjogWzAsIDAuNDMwNTYsIDAuMDI3NzgsIDAsIDAuODI4MTNdLFxuICAgIFwiMTAwOVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wODMzNCwgMC41MTcwMl0sXG4gICAgXCIxMDEzXCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjQwNTldXG4gIH0sXG4gIFwiTWF0aC1SZWd1bGFyXCI6IHtcbiAgICBcIjY1XCI6IFswLCAwLjY4MzMzLCAwLCAwLjEzODg5LCAwLjc1XSxcbiAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLjA1MDE3LCAwLjA4MzM0LCAwLjc1ODUxXSxcbiAgICBcIjY3XCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA4MzM0LCAwLjcxNDcyXSxcbiAgICBcIjY4XCI6IFswLCAwLjY4MzMzLCAwLjAyNzc4LCAwLjA1NTU2LCAwLjgyNzkyXSxcbiAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0LCAwLjczODJdLFxuICAgIFwiNzBcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDgzMzQsIDAuNjQzMDZdLFxuICAgIFwiNzFcIjogWzAsIDAuNjgzMzMsIDAsIDAuMDgzMzQsIDAuNzg2MjVdLFxuICAgIFwiNzJcIjogWzAsIDAuNjgzMzMsIDAuMDgxMjUsIDAuMDU1NTYsIDAuODMxMjVdLFxuICAgIFwiNzNcIjogWzAsIDAuNjgzMzMsIDAuMDc4NDcsIDAuMTExMTEsIDAuNDM5NThdLFxuICAgIFwiNzRcIjogWzAsIDAuNjgzMzMsIDAuMDk2MTgsIDAuMTY2NjcsIDAuNTU0NTFdLFxuICAgIFwiNzVcIjogWzAsIDAuNjgzMzMsIDAuMDcxNTMsIDAuMDU1NTYsIDAuODQ5MzFdLFxuICAgIFwiNzZcIjogWzAsIDAuNjgzMzMsIDAsIDAuMDI3NzgsIDAuNjgwNTZdLFxuICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAuMTA5MDMsIDAuMDgzMzQsIDAuOTcwMTRdLFxuICAgIFwiNzhcIjogWzAsIDAuNjgzMzMsIDAuMTA5MDMsIDAuMDgzMzQsIDAuODAzNDddLFxuICAgIFwiNzlcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMDgzMzQsIDAuNzYyNzhdLFxuICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDgzMzQsIDAuNjQyMDFdLFxuICAgIFwiODFcIjogWzAuMTk0NDQsIDAuNjgzMzMsIDAsIDAuMDgzMzQsIDAuNzkwNTZdLFxuICAgIFwiODJcIjogWzAsIDAuNjgzMzMsIDAuMDA3NzMsIDAuMDgzMzQsIDAuNzU5MjldLFxuICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAuMDU3NjQsIDAuMDgzMzQsIDAuNjEzMl0sXG4gICAgXCI4NFwiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wODMzNCwgMC41ODQzOF0sXG4gICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMC4xMDkwMywgMC4wMjc3OCwgMC42ODI3OF0sXG4gICAgXCI4NlwiOiBbMCwgMC42ODMzMywgMC4yMjIyMiwgMCwgMC41ODMzM10sXG4gICAgXCI4N1wiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMCwgMC45NDQ0NV0sXG4gICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4wODMzNCwgMC44Mjg0N10sXG4gICAgXCI4OVwiOiBbMCwgMC42ODMzMywgMC4yMjIyMiwgMCwgMC41ODA1Nl0sXG4gICAgXCI5MFwiOiBbMCwgMC42ODMzMywgMC4wNzE1MywgMC4wODMzNCwgMC42ODI2NF0sXG4gICAgXCI5N1wiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41Mjg1OV0sXG4gICAgXCI5OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC40MjkxN10sXG4gICAgXCI5OVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1NiwgMC40MzI3Nl0sXG4gICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDAuMTY2NjcsIDAuNTIwNDldLFxuICAgIFwiMTAxXCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjQ2NTYzXSxcbiAgICBcIjEwMlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4xMDc2NCwgMC4xNjY2NywgMC40ODk1OV0sXG4gICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzgsIDAuNDc2OTddLFxuICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NjE2XSxcbiAgICBcIjEwNVwiOiBbMCwgMC42NTk1MiwgMCwgMCwgMC4zNDQ1MV0sXG4gICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjU5NTIsIDAuMDU3MjQsIDAsIDAuNDExODFdLFxuICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLjAzMTQ4LCAwLCAwLjUyMDZdLFxuICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLjAxOTY4LCAwLjA4MzM0LCAwLjI5ODM4XSxcbiAgICBcIjEwOVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC44NzgwMV0sXG4gICAgXCIxMTBcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNjAwMjNdLFxuICAgIFwiMTExXCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjQ4NDcyXSxcbiAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wODMzNCwgMC41MDMxM10sXG4gICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDgzMzQsIDAuNDQ2NDFdLFxuICAgIFwiMTE0XCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwLjA1NTU2LCAwLjQ1MTE2XSxcbiAgICBcIjExNVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1NiwgMC40Njg3NV0sXG4gICAgXCIxMTZcIjogWzAsIDAuNjE1MDgsIDAsIDAuMDgzMzQsIDAuMzYxMTFdLFxuICAgIFwiMTE3XCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4LCAwLjU3MjQ2XSxcbiAgICBcIjExOFwiOiBbMCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wMjc3OCwgMC40ODQ3Ml0sXG4gICAgXCIxMTlcIjogWzAsIDAuNDMwNTYsIDAuMDI2OTEsIDAuMDgzMzQsIDAuNzE1OTJdLFxuICAgIFwiMTIwXCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4LCAwLjU3MTUzXSxcbiAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wNTU1NiwgMC40OTAyOF0sXG4gICAgXCIxMjJcIjogWzAsIDAuNDMwNTYsIDAuMDQzOTgsIDAuMDU1NTYsIDAuNDY1MDVdLFxuICAgIFwiOTE1XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0LCAwLjYxNTI4XSxcbiAgICBcIjkxNlwiOiBbMCwgMC42ODMzMywgMCwgMC4xNjY2NywgMC44MzMzNF0sXG4gICAgXCI5MjBcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMDgzMzQsIDAuNzYyNzhdLFxuICAgIFwiOTIzXCI6IFswLCAwLjY4MzMzLCAwLCAwLjE2NjY3LCAwLjY5NDQ1XSxcbiAgICBcIjkyNlwiOiBbMCwgMC42ODMzMywgMC4wNzU2OSwgMC4wODMzNCwgMC43NDIzNl0sXG4gICAgXCI5MjhcIjogWzAsIDAuNjgzMzMsIDAuMDgxMjUsIDAuMDU1NTYsIDAuODMxMjVdLFxuICAgIFwiOTMxXCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0LCAwLjc3OTg2XSxcbiAgICBcIjkzM1wiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wNTU1NiwgMC41ODMzM10sXG4gICAgXCI5MzRcIjogWzAsIDAuNjgzMzMsIDAsIDAuMDgzMzQsIDAuNjY2NjddLFxuICAgIFwiOTM2XCI6IFswLCAwLjY4MzMzLCAwLjExLCAwLjA1NTU2LCAwLjYxMjIyXSxcbiAgICBcIjkzN1wiOiBbMCwgMC42ODMzMywgMC4wNTAxNywgMC4wODMzNCwgMC43NzI0XSxcbiAgICBcIjk0NVwiOiBbMCwgMC40MzA1NiwgMC4wMDM3LCAwLjAyNzc4LCAwLjYzOTddLFxuICAgIFwiOTQ2XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA1Mjc4LCAwLjA4MzM0LCAwLjU2NTYzXSxcbiAgICBcIjk0N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wNTU1NiwgMCwgMC41MTc3M10sXG4gICAgXCI5NDhcIjogWzAsIDAuNjk0NDQsIDAuMDM3ODUsIDAuMDU1NTYsIDAuNDQ0NDRdLFxuICAgIFwiOTQ5XCI6IFswLCAwLjQzMDU2LCAwLCAwLjA4MzM0LCAwLjQ2NjMyXSxcbiAgICBcIjk1MFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNzM3OCwgMC4wODMzNCwgMC40Mzc1XSxcbiAgICBcIjk1MVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wNTU1NiwgMC40OTY1M10sXG4gICAgXCI5NTJcIjogWzAsIDAuNjk0NDQsIDAuMDI3NzgsIDAuMDgzMzQsIDAuNDY5NDRdLFxuICAgIFwiOTUzXCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjM1Mzk0XSxcbiAgICBcIjk1NFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41NzYxNl0sXG4gICAgXCI5NTVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTgzMzRdLFxuICAgIFwiOTU2XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjAyNzc4LCAwLjYwMjU1XSxcbiAgICBcIjk1N1wiOiBbMCwgMC40MzA1NiwgMC4wNjM2NiwgMC4wMjc3OCwgMC40OTM5OF0sXG4gICAgXCI5NThcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDQ2MDEsIDAuMTExMTEsIDAuNDM3NV0sXG4gICAgXCI5NTlcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuNDg0NzJdLFxuICAgIFwiOTYwXCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLCAwLjU3MDAzXSxcbiAgICBcIjk2MVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wODMzNCwgMC41MTcwMl0sXG4gICAgXCI5NjJcIjogWzAuMDk3MjIsIDAuNDMwNTYsIDAuMDc5ODYsIDAuMDgzMzQsIDAuMzYyODVdLFxuICAgIFwiOTYzXCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLCAwLjU3MTQxXSxcbiAgICBcIjk2NFwiOiBbMCwgMC40MzA1NiwgMC4xMTMyLCAwLjAyNzc4LCAwLjQzNzE1XSxcbiAgICBcIjk2NVwiOiBbMCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wMjc3OCwgMC41NDAyOF0sXG4gICAgXCI5NjZcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzQsIDAuNjU0MTddLFxuICAgIFwiOTY3XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjYyNTY5XSxcbiAgICBcIjk2OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wMzU4OCwgMC4xMTExMSwgMC42NTEzOV0sXG4gICAgXCI5NjlcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAsIDAuNjIyNDVdLFxuICAgIFwiOTc3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLjA4MzM0LCAwLjU5MTQ0XSxcbiAgICBcIjk4MVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMC4wODMzNCwgMC41OTU4M10sXG4gICAgXCI5ODJcIjogWzAsIDAuNDMwNTYsIDAuMDI3NzgsIDAsIDAuODI4MTNdLFxuICAgIFwiMTAwOVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wODMzNCwgMC41MTcwMl0sXG4gICAgXCIxMDEzXCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjQwNTldXG4gIH0sXG4gIFwiU2Fuc1NlcmlmLUJvbGRcIjoge1xuICAgIFwiMzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzY2NjddLFxuICAgIFwiMzRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTU4MzRdLFxuICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuOTE2NjddLFxuICAgIFwiMzZcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDAuNTVdLFxuICAgIFwiMzdcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDEuMDI5MTJdLFxuICAgIFwiMzhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODMwNTZdLFxuICAgIFwiMzlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzA1NTZdLFxuICAgIFwiNDBcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNDI3NzhdLFxuICAgIFwiNDFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNDI3NzhdLFxuICAgIFwiNDJcIjogWzAsIDAuNzUsIDAsIDAsIDAuNTVdLFxuICAgIFwiNDNcIjogWzAuMTE2NjcsIDAuNjE2NjcsIDAsIDAsIDAuODU1NTZdLFxuICAgIFwiNDRcIjogWzAuMTA1NTYsIDAuMTMwNTYsIDAsIDAsIDAuMzA1NTZdLFxuICAgIFwiNDVcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuMzY2NjddLFxuICAgIFwiNDZcIjogWzAsIDAuMTMwNTYsIDAsIDAsIDAuMzA1NTZdLFxuICAgIFwiNDdcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTVdLFxuICAgIFwiNDhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNDlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNTBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNTFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNTJcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNTNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNTRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNTVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNTZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNTdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNThcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuMzA1NTZdLFxuICAgIFwiNTlcIjogWzAuMTA1NTYsIDAuNDU4MzMsIDAsIDAsIDAuMzA1NTZdLFxuICAgIFwiNjFcIjogWy0wLjA5Mzc1LCAwLjQwNjI1LCAwLCAwLCAwLjg1NTU2XSxcbiAgICBcIjYzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjUxOTQ1XSxcbiAgICBcIjY0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczMzM0XSxcbiAgICBcIjY1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczMzM0XSxcbiAgICBcIjY2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczMzM0XSxcbiAgICBcIjY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcwMjc4XSxcbiAgICBcIjY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc5NDQ1XSxcbiAgICBcIjY5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY0MTY3XSxcbiAgICBcIjcwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjcxXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczMzM0XSxcbiAgICBcIjcyXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc5NDQ1XSxcbiAgICBcIjczXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMzMDU2XSxcbiAgICBcIjc0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjUxOTQ1XSxcbiAgICBcIjc1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc2Mzg5XSxcbiAgICBcIjc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU4MDU2XSxcbiAgICBcIjc3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjk3Nzc4XSxcbiAgICBcIjc4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc5NDQ1XSxcbiAgICBcIjc5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc5NDQ1XSxcbiAgICBcIjgwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcwMjc4XSxcbiAgICBcIjgxXCI6IFswLjEwNTU2LCAwLjY5NDQ0LCAwLCAwLCAwLjc5NDQ1XSxcbiAgICBcIjgyXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcwMjc4XSxcbiAgICBcIjgzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczMzM0XSxcbiAgICBcIjg1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc2Mzg5XSxcbiAgICBcIjg2XCI6IFswLCAwLjY5NDQ0LCAwLjAxNTI4LCAwLCAwLjczMzM0XSxcbiAgICBcIjg3XCI6IFswLCAwLjY5NDQ0LCAwLjAxNTI4LCAwLCAxLjAzODg5XSxcbiAgICBcIjg4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczMzM0XSxcbiAgICBcIjg5XCI6IFswLCAwLjY5NDQ0LCAwLjAyNzUsIDAsIDAuNzMzMzRdLFxuICAgIFwiOTBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjcyMjNdLFxuICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzQzMDZdLFxuICAgIFwiOTNcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzQzMDZdLFxuICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiOTVcIjogWzAuMzUsIDAuMTA4MzMsIDAuMDMwNTYsIDAsIDAuNTVdLFxuICAgIFwiOTdcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU2MTExXSxcbiAgICBcIjk5XCI6IFswLCAwLjQ1ODMzLCAwLCAwLCAwLjQ4ODg5XSxcbiAgICBcIjEwMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NjExMV0sXG4gICAgXCIxMDFcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNTExMTFdLFxuICAgIFwiMTAyXCI6IFswLCAwLjY5NDQ0LCAwLjA3NjM5LCAwLCAwLjMzNjExXSxcbiAgICBcIjEwM1wiOiBbMC4xOTQ0NCwgMC40NTgzMywgMC4wMTUyOCwgMCwgMC41NV0sXG4gICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTYxMTFdLFxuICAgIFwiMTA1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI1NTU2XSxcbiAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC4yODYxMV0sXG4gICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTMwNTZdLFxuICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI1NTU2XSxcbiAgICBcIjEwOVwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC44NjY2N10sXG4gICAgXCIxMTBcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNTYxMTFdLFxuICAgIFwiMTExXCI6IFswLCAwLjQ1ODMzLCAwLCAwLCAwLjU1XSxcbiAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40NTgzMywgMCwgMCwgMC41NjExMV0sXG4gICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDU4MzMsIDAsIDAsIDAuNTYxMTFdLFxuICAgIFwiMTE0XCI6IFswLCAwLjQ1ODMzLCAwLjAxNTI4LCAwLCAwLjM3MjIyXSxcbiAgICBcIjExNVwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC40MjE2N10sXG4gICAgXCIxMTZcIjogWzAsIDAuNTg5MjksIDAsIDAsIDAuNDA0MTddLFxuICAgIFwiMTE3XCI6IFswLCAwLjQ1ODMzLCAwLCAwLCAwLjU2MTExXSxcbiAgICBcIjExOFwiOiBbMCwgMC40NTgzMywgMC4wMTUyOCwgMCwgMC41XSxcbiAgICBcIjExOVwiOiBbMCwgMC40NTgzMywgMC4wMTUyOCwgMCwgMC43NDQ0NV0sXG4gICAgXCIxMjBcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNV0sXG4gICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDU4MzMsIDAuMDE1MjgsIDAsIDAuNV0sXG4gICAgXCIxMjJcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNDc2MzldLFxuICAgIFwiMTI2XCI6IFswLjM1LCAwLjM0NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjE2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCIxNzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiMTgwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjE4NFwiOiBbMC4xNzAxNCwgMCwgMCwgMCwgMC40ODg4OV0sXG4gICAgXCIzMDVcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuMjU1NTZdLFxuICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQ1ODMzLCAwLCAwLCAwLjI4NjExXSxcbiAgICBcIjcxMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI3MTFcIjogWzAsIDAuNjM1NDIsIDAsIDAsIDAuNTVdLFxuICAgIFwiNzEzXCI6IFswLCAwLjYzNzc4LCAwLCAwLCAwLjU1XSxcbiAgICBcIjcyOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI3MjlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzA1NTZdLFxuICAgIFwiNzMwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczMzM0XSxcbiAgICBcIjczMlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI3MzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiOTE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU4MDU2XSxcbiAgICBcIjkxNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC45MTY2N10sXG4gICAgXCI5MjBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODU1NTZdLFxuICAgIFwiOTIzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY3MjIzXSxcbiAgICBcIjkyNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MzMzNF0sXG4gICAgXCI5MjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiOTMxXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc5NDQ1XSxcbiAgICBcIjkzM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44NTU1Nl0sXG4gICAgXCI5MzRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiOTM2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg1NTU2XSxcbiAgICBcIjkzN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43OTQ0NV0sXG4gICAgXCI4MjExXCI6IFswLCAwLjQ1ODMzLCAwLjAzMDU2LCAwLCAwLjU1XSxcbiAgICBcIjgyMTJcIjogWzAsIDAuNDU4MzMsIDAuMDMwNTYsIDAsIDEuMTAwMDFdLFxuICAgIFwiODIxNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMwNTU2XSxcbiAgICBcIjgyMjBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTU4MzRdLFxuICAgIFwiODIyMVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NTgzNF1cbiAgfSxcbiAgXCJTYW5zU2VyaWYtSXRhbGljXCI6IHtcbiAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLjA1NzMzLCAwLCAwLjMxOTQ1XSxcbiAgICBcIjM0XCI6IFswLCAwLjY5NDQ0LCAwLjAwMzE2LCAwLCAwLjVdLFxuICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDUwODcsIDAsIDAuODMzMzRdLFxuICAgIFwiMzZcIjogWzAuMDU1NTYsIDAuNzUsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMC4wMzEyNiwgMCwgMC44MzMzNF0sXG4gICAgXCIzOFwiOiBbMCwgMC42OTQ0NCwgMC4wMzA1OCwgMCwgMC43NTgzNF0sXG4gICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMC4wNzgxNiwgMCwgMC4yNzc3OF0sXG4gICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMC4xMzE2NCwgMCwgMC4zODg4OV0sXG4gICAgXCI0MVwiOiBbMC4yNSwgMC43NSwgMC4wMjUzNiwgMCwgMC4zODg4OV0sXG4gICAgXCI0MlwiOiBbMCwgMC43NSwgMC4xMTc3NSwgMCwgMC41XSxcbiAgICBcIjQzXCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLjAyNTM2LCAwLCAwLjc3Nzc4XSxcbiAgICBcIjQ0XCI6IFswLjEyNSwgMC4wODMzMywgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI0NVwiOiBbMCwgMC40NDQ0NCwgMC4wMTk0NiwgMCwgMC4zMzMzM10sXG4gICAgXCI0NlwiOiBbMCwgMC4wODMzMywgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI0N1wiOiBbMC4yNSwgMC43NSwgMC4xMzE2NCwgMCwgMC41XSxcbiAgICBcIjQ4XCI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLFxuICAgIFwiNDlcIjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCI1MFwiOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSxcbiAgICBcIjUxXCI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLFxuICAgIFwiNTJcIjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCI1M1wiOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSxcbiAgICBcIjU0XCI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLFxuICAgIFwiNTVcIjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCI1NlwiOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSxcbiAgICBcIjU3XCI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLFxuICAgIFwiNThcIjogWzAsIDAuNDQ0NDQsIDAuMDI1MDIsIDAsIDAuMjc3NzhdLFxuICAgIFwiNTlcIjogWzAuMTI1LCAwLjQ0NDQ0LCAwLjAyNTAyLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjYxXCI6IFstMC4xMywgMC4zNywgMC4wNTA4NywgMCwgMC43Nzc3OF0sXG4gICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMC4xMTgwOSwgMCwgMC40NzIyMl0sXG4gICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMC4wNzU1NSwgMCwgMC42NjY2N10sXG4gICAgXCI2NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI2NlwiOiBbMCwgMC42OTQ0NCwgMC4wODI5MywgMCwgMC42NjY2N10sXG4gICAgXCI2N1wiOiBbMCwgMC42OTQ0NCwgMC4xMTk4MywgMCwgMC42Mzg4OV0sXG4gICAgXCI2OFwiOiBbMCwgMC42OTQ0NCwgMC4wNzU1NSwgMCwgMC43MjIyM10sXG4gICAgXCI2OVwiOiBbMCwgMC42OTQ0NCwgMC4xMTk4MywgMCwgMC41OTcyMl0sXG4gICAgXCI3MFwiOiBbMCwgMC42OTQ0NCwgMC4xMzM3MiwgMCwgMC41Njk0NV0sXG4gICAgXCI3MVwiOiBbMCwgMC42OTQ0NCwgMC4xMTk4MywgMCwgMC42NjY2N10sXG4gICAgXCI3MlwiOiBbMCwgMC42OTQ0NCwgMC4wODA5NCwgMCwgMC43MDgzNF0sXG4gICAgXCI3M1wiOiBbMCwgMC42OTQ0NCwgMC4xMzM3MiwgMCwgMC4yNzc3OF0sXG4gICAgXCI3NFwiOiBbMCwgMC42OTQ0NCwgMC4wODA5NCwgMCwgMC40NzIyMl0sXG4gICAgXCI3NVwiOiBbMCwgMC42OTQ0NCwgMC4xMTk4MywgMCwgMC42OTQ0NV0sXG4gICAgXCI3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NDE2N10sXG4gICAgXCI3N1wiOiBbMCwgMC42OTQ0NCwgMC4wODA5NCwgMCwgMC44NzVdLFxuICAgIFwiNzhcIjogWzAsIDAuNjk0NDQsIDAuMDgwOTQsIDAsIDAuNzA4MzRdLFxuICAgIFwiNzlcIjogWzAsIDAuNjk0NDQsIDAuMDc1NTUsIDAsIDAuNzM2MTFdLFxuICAgIFwiODBcIjogWzAsIDAuNjk0NDQsIDAuMDgyOTMsIDAsIDAuNjM4ODldLFxuICAgIFwiODFcIjogWzAuMTI1LCAwLjY5NDQ0LCAwLjA3NTU1LCAwLCAwLjczNjExXSxcbiAgICBcIjgyXCI6IFswLCAwLjY5NDQ0LCAwLjA4MjkzLCAwLCAwLjY0NTg0XSxcbiAgICBcIjgzXCI6IFswLCAwLjY5NDQ0LCAwLjA5MjA1LCAwLCAwLjU1NTU2XSxcbiAgICBcIjg0XCI6IFswLCAwLjY5NDQ0LCAwLjEzMzcyLCAwLCAwLjY4MDU2XSxcbiAgICBcIjg1XCI6IFswLCAwLjY5NDQ0LCAwLjA4MDk0LCAwLCAwLjY4NzVdLFxuICAgIFwiODZcIjogWzAsIDAuNjk0NDQsIDAuMTYxNSwgMCwgMC42NjY2N10sXG4gICAgXCI4N1wiOiBbMCwgMC42OTQ0NCwgMC4xNjE1LCAwLCAwLjk0NDQ1XSxcbiAgICBcIjg4XCI6IFswLCAwLjY5NDQ0LCAwLjEzMzcyLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg5XCI6IFswLCAwLjY5NDQ0LCAwLjE3MjYxLCAwLCAwLjY2NjY3XSxcbiAgICBcIjkwXCI6IFswLCAwLjY5NDQ0LCAwLjExOTgzLCAwLCAwLjYxMTExXSxcbiAgICBcIjkxXCI6IFswLjI1LCAwLjc1LCAwLjE1OTQyLCAwLCAwLjI4ODg5XSxcbiAgICBcIjkzXCI6IFswLjI1LCAwLjc1LCAwLjA4NzE5LCAwLCAwLjI4ODg5XSxcbiAgICBcIjk0XCI6IFswLCAwLjY5NDQ0LCAwLjA3OTksIDAsIDAuNV0sXG4gICAgXCI5NVwiOiBbMC4zNSwgMC4wOTQ0NCwgMC4wODYxNiwgMCwgMC41XSxcbiAgICBcIjk3XCI6IFswLCAwLjQ0NDQ0LCAwLjAwOTgxLCAwLCAwLjQ4MDU2XSxcbiAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLjAzMDU3LCAwLCAwLjUxNjY3XSxcbiAgICBcIjk5XCI6IFswLCAwLjQ0NDQ0LCAwLjA4MzM2LCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjEwMFwiOiBbMCwgMC42OTQ0NCwgMC4wOTQ4MywgMCwgMC41MTY2N10sXG4gICAgXCIxMDFcIjogWzAsIDAuNDQ0NDQsIDAuMDY3NzgsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMTAyXCI6IFswLCAwLjY5NDQ0LCAwLjIxNzA1LCAwLCAwLjMwNTU2XSxcbiAgICBcIjEwM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4xMDgzNiwgMCwgMC41XSxcbiAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMC4wMTc3OCwgMCwgMC41MTY2N10sXG4gICAgXCIxMDVcIjogWzAsIDAuNjc5MzcsIDAuMDk3MTgsIDAsIDAuMjM4ODldLFxuICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY3OTM3LCAwLjA5MTYyLCAwLCAwLjI2NjY3XSxcbiAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMC4wODMzNiwgMCwgMC40ODg4OV0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAuMDk0ODMsIDAsIDAuMjM4ODldLFxuICAgIFwiMTA5XCI6IFswLCAwLjQ0NDQ0LCAwLjAxNzc4LCAwLCAwLjc5NDQ1XSxcbiAgICBcIjExMFwiOiBbMCwgMC40NDQ0NCwgMC4wMTc3OCwgMCwgMC41MTY2N10sXG4gICAgXCIxMTFcIjogWzAsIDAuNDQ0NDQsIDAuMDY2MTMsIDAsIDAuNV0sXG4gICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM4OSwgMCwgMC41MTY2N10sXG4gICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDQxNjksIDAsIDAuNTE2NjddLFxuICAgIFwiMTE0XCI6IFswLCAwLjQ0NDQ0LCAwLjEwODM2LCAwLCAwLjM0MTY3XSxcbiAgICBcIjExNVwiOiBbMCwgMC40NDQ0NCwgMC4wNzc4LCAwLCAwLjM4MzMzXSxcbiAgICBcIjExNlwiOiBbMCwgMC41NzE0MywgMC4wNzIyNSwgMCwgMC4zNjExMV0sXG4gICAgXCIxMTdcIjogWzAsIDAuNDQ0NDQsIDAuMDQxNjksIDAsIDAuNTE2NjddLFxuICAgIFwiMTE4XCI6IFswLCAwLjQ0NDQ0LCAwLjEwODM2LCAwLCAwLjQ2MTExXSxcbiAgICBcIjExOVwiOiBbMCwgMC40NDQ0NCwgMC4xMDgzNiwgMCwgMC42ODMzNF0sXG4gICAgXCIxMjBcIjogWzAsIDAuNDQ0NDQsIDAuMDkxNjksIDAsIDAuNDYxMTFdLFxuICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjEwODM2LCAwLCAwLjQ2MTExXSxcbiAgICBcIjEyMlwiOiBbMCwgMC40NDQ0NCwgMC4wODc1MiwgMCwgMC40MzQ3Ml0sXG4gICAgXCIxMjZcIjogWzAuMzUsIDAuMzI2NTksIDAuMDg4MjYsIDAsIDAuNV0sXG4gICAgXCIxNjhcIjogWzAsIDAuNjc5MzcsIDAuMDYzODUsIDAsIDAuNV0sXG4gICAgXCIxNzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzM3NTJdLFxuICAgIFwiMTg0XCI6IFswLjE3MDE0LCAwLCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjMwNVwiOiBbMCwgMC40NDQ0NCwgMC4wNDE2OSwgMCwgMC4yMzg4OV0sXG4gICAgXCI1NjdcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDQxNjksIDAsIDAuMjY2NjddLFxuICAgIFwiNzEwXCI6IFswLCAwLjY5NDQ0LCAwLjA3OTksIDAsIDAuNV0sXG4gICAgXCI3MTFcIjogWzAsIDAuNjMxOTQsIDAuMDg0MzIsIDAsIDAuNV0sXG4gICAgXCI3MTNcIjogWzAsIDAuNjA4ODksIDAuMDg3NzYsIDAsIDAuNV0sXG4gICAgXCI3MTRcIjogWzAsIDAuNjk0NDQsIDAuMDkyMDUsIDAsIDAuNV0sXG4gICAgXCI3MTVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI3MjhcIjogWzAsIDAuNjk0NDQsIDAuMDk0ODMsIDAsIDAuNV0sXG4gICAgXCI3MjlcIjogWzAsIDAuNjc5MzcsIDAuMDc3NzQsIDAsIDAuMjc3NzhdLFxuICAgIFwiNzMwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczNzUyXSxcbiAgICBcIjczMlwiOiBbMCwgMC42NzY1OSwgMC4wODgyNiwgMCwgMC41XSxcbiAgICBcIjczM1wiOiBbMCwgMC42OTQ0NCwgMC4wOTIwNSwgMCwgMC41XSxcbiAgICBcIjkxNVwiOiBbMCwgMC42OTQ0NCwgMC4xMzM3MiwgMCwgMC41NDE2N10sXG4gICAgXCI5MTZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiOTIwXCI6IFswLCAwLjY5NDQ0LCAwLjA3NTU1LCAwLCAwLjc3Nzc4XSxcbiAgICBcIjkyM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI5MjZcIjogWzAsIDAuNjk0NDQsIDAuMTI4MTYsIDAsIDAuNjY2NjddLFxuICAgIFwiOTI4XCI6IFswLCAwLjY5NDQ0LCAwLjA4MDk0LCAwLCAwLjcwODM0XSxcbiAgICBcIjkzMVwiOiBbMCwgMC42OTQ0NCwgMC4xMTk4MywgMCwgMC43MjIyMl0sXG4gICAgXCI5MzNcIjogWzAsIDAuNjk0NDQsIDAuMDkwMzEsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTM0XCI6IFswLCAwLjY5NDQ0LCAwLjA0NjAzLCAwLCAwLjcyMjIyXSxcbiAgICBcIjkzNlwiOiBbMCwgMC42OTQ0NCwgMC4wOTAzMSwgMCwgMC43Nzc3OF0sXG4gICAgXCI5MzdcIjogWzAsIDAuNjk0NDQsIDAuMDgyOTMsIDAsIDAuNzIyMjJdLFxuICAgIFwiODIxMVwiOiBbMCwgMC40NDQ0NCwgMC4wODYxNiwgMCwgMC41XSxcbiAgICBcIjgyMTJcIjogWzAsIDAuNDQ0NDQsIDAuMDg2MTYsIDAsIDEuMF0sXG4gICAgXCI4MjE2XCI6IFswLCAwLjY5NDQ0LCAwLjA3ODE2LCAwLCAwLjI3Nzc4XSxcbiAgICBcIjgyMTdcIjogWzAsIDAuNjk0NDQsIDAuMDc4MTYsIDAsIDAuMjc3NzhdLFxuICAgIFwiODIyMFwiOiBbMCwgMC42OTQ0NCwgMC4xNDIwNSwgMCwgMC41XSxcbiAgICBcIjgyMjFcIjogWzAsIDAuNjk0NDQsIDAuMDAzMTYsIDAsIDAuNV1cbiAgfSxcbiAgXCJTYW5zU2VyaWYtUmVndWxhclwiOiB7XG4gICAgXCIzM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMTk0NV0sXG4gICAgXCIzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjM1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjM2XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiMzdcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiMzhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzU4MzRdLFxuICAgIFwiMzlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNDBcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiNDFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiNDJcIjogWzAsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCI0M1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI0NFwiOiBbMC4xMjUsIDAuMDgzMzMsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNDVcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuMzMzMzNdLFxuICAgIFwiNDZcIjogWzAsIDAuMDgzMzMsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNDdcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCI0OFwiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSxcbiAgICBcIjQ5XCI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTBcIjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1MVwiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSxcbiAgICBcIjUyXCI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTNcIjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1NFwiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSxcbiAgICBcIjU1XCI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTZcIjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1N1wiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSxcbiAgICBcIjU4XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjU5XCI6IFswLjEyNSwgMC40NDQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI2MVwiOiBbLTAuMTMsIDAuMzcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNDcyMjJdLFxuICAgIFwiNjRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiNjVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiNjZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiNjdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiNjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzIyMjNdLFxuICAgIFwiNjlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTk3MjJdLFxuICAgIFwiNzBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTY5NDVdLFxuICAgIFwiNzFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiNzJcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzA4MzRdLFxuICAgIFwiNzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNzRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNDcyMjJdLFxuICAgIFwiNzVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjk0NDVdLFxuICAgIFwiNzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTQxNjddLFxuICAgIFwiNzdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODc1XSxcbiAgICBcIjc4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcwODM0XSxcbiAgICBcIjc5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczNjExXSxcbiAgICBcIjgwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjgxXCI6IFswLjEyNSwgMC42OTQ0NCwgMCwgMCwgMC43MzYxMV0sXG4gICAgXCI4MlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NDU4NF0sXG4gICAgXCI4M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI4NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42ODA1Nl0sXG4gICAgXCI4NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42ODc1XSxcbiAgICBcIjg2XCI6IFswLCAwLjY5NDQ0LCAwLjAxMzg5LCAwLCAwLjY2NjY3XSxcbiAgICBcIjg3XCI6IFswLCAwLjY5NDQ0LCAwLjAxMzg5LCAwLCAwLjk0NDQ1XSxcbiAgICBcIjg4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg5XCI6IFswLCAwLjY5NDQ0LCAwLjAyNSwgMCwgMC42NjY2N10sXG4gICAgXCI5MFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI5MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4yODg4OV0sXG4gICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4yODg4OV0sXG4gICAgXCI5NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjk1XCI6IFswLjM1LCAwLjA5NDQ0LCAwLjAyNzc4LCAwLCAwLjVdLFxuICAgIFwiOTdcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDgwNTZdLFxuICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTE2NjddLFxuICAgIFwiOTlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjUxNjY3XSxcbiAgICBcIjEwMVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCIxMDJcIjogWzAsIDAuNjk0NDQsIDAuMDY5NDQsIDAsIDAuMzA1NTZdLFxuICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAxMzg5LCAwLCAwLjVdLFxuICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjUxNjY3XSxcbiAgICBcIjEwNVwiOiBbMCwgMC42NzkzNywgMCwgMCwgMC4yMzg4OV0sXG4gICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjc5MzcsIDAsIDAsIDAuMjY2NjddLFxuICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjQ4ODg5XSxcbiAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yMzg4OV0sXG4gICAgXCIxMDlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiMTEwXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjUxNjY3XSxcbiAgICBcIjExMVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC41MTY2N10sXG4gICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNTE2NjddLFxuICAgIFwiMTE0XCI6IFswLCAwLjQ0NDQ0LCAwLjAxMzg5LCAwLCAwLjM0MTY3XSxcbiAgICBcIjExNVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC4zODMzM10sXG4gICAgXCIxMTZcIjogWzAsIDAuNTcxNDMsIDAsIDAsIDAuMzYxMTFdLFxuICAgIFwiMTE3XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjUxNjY3XSxcbiAgICBcIjExOFwiOiBbMCwgMC40NDQ0NCwgMC4wMTM4OSwgMCwgMC40NjExMV0sXG4gICAgXCIxMTlcIjogWzAsIDAuNDQ0NDQsIDAuMDEzODksIDAsIDAuNjgzMzRdLFxuICAgIFwiMTIwXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjQ2MTExXSxcbiAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMTM4OSwgMCwgMC40NjExMV0sXG4gICAgXCIxMjJcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDM0NzJdLFxuICAgIFwiMTI2XCI6IFswLjM1LCAwLjMyNjU5LCAwLCAwLCAwLjVdLFxuICAgIFwiMTY4XCI6IFswLCAwLjY3OTM3LCAwLCAwLCAwLjVdLFxuICAgIFwiMTc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjE4NFwiOiBbMC4xNzAxNCwgMCwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCIzMDVcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuMjM4ODldLFxuICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjI2NjY3XSxcbiAgICBcIjcxMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjcxMVwiOiBbMCwgMC42MzE5NCwgMCwgMCwgMC41XSxcbiAgICBcIjcxM1wiOiBbMCwgMC42MDg4OSwgMCwgMCwgMC41XSxcbiAgICBcIjcxNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjcxNVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjcyOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjcyOVwiOiBbMCwgMC42NzkzNywgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI3MzBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiNzMyXCI6IFswLCAwLjY3NjU5LCAwLCAwLCAwLjVdLFxuICAgIFwiNzMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiOTE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU0MTY3XSxcbiAgICBcIjkxNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCI5MjBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTIzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjkyNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI5MjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzA4MzRdLFxuICAgIFwiOTMxXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjkzM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5MzRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTM2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjkzN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4MjExXCI6IFswLCAwLjQ0NDQ0LCAwLjAyNzc4LCAwLCAwLjVdLFxuICAgIFwiODIxMlwiOiBbMCwgMC40NDQ0NCwgMC4wMjc3OCwgMCwgMS4wXSxcbiAgICBcIjgyMTZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiODIxN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI4MjIwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiODIyMVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XVxuICB9LFxuICBcIlNjcmlwdC1SZWd1bGFyXCI6IHtcbiAgICBcIjY1XCI6IFswLCAwLjcsIDAuMjI5MjUsIDAsIDAuODAyNTNdLFxuICAgIFwiNjZcIjogWzAsIDAuNywgMC4wNDA4NywgMCwgMC45MDc1N10sXG4gICAgXCI2N1wiOiBbMCwgMC43LCAwLjE2ODksIDAsIDAuNjY2MTldLFxuICAgIFwiNjhcIjogWzAsIDAuNywgMC4wOTM3MSwgMCwgMC43NzQ0M10sXG4gICAgXCI2OVwiOiBbMCwgMC43LCAwLjE4NTgzLCAwLCAwLjU2MTYyXSxcbiAgICBcIjcwXCI6IFswLCAwLjcsIDAuMTM2MzQsIDAsIDAuODk1NDRdLFxuICAgIFwiNzFcIjogWzAsIDAuNywgMC4xNzMyMiwgMCwgMC42MDk2MV0sXG4gICAgXCI3MlwiOiBbMCwgMC43LCAwLjI5Njk0LCAwLCAwLjk2OTE5XSxcbiAgICBcIjczXCI6IFswLCAwLjcsIDAuMTkxODksIDAsIDAuODA5MDddLFxuICAgIFwiNzRcIjogWzAuMjc3NzgsIDAuNywgMC4xOTE4OSwgMCwgMS4wNTE1OV0sXG4gICAgXCI3NVwiOiBbMCwgMC43LCAwLjMxMjU5LCAwLCAwLjkxMzY0XSxcbiAgICBcIjc2XCI6IFswLCAwLjcsIDAuMTkxODksIDAsIDAuODczNzNdLFxuICAgIFwiNzdcIjogWzAsIDAuNywgMC4xNTk4MSwgMCwgMS4wODAzMV0sXG4gICAgXCI3OFwiOiBbMCwgMC43LCAwLjM1MjUsIDAsIDAuOTAxNV0sXG4gICAgXCI3OVwiOiBbMCwgMC43LCAwLjA4MDc4LCAwLCAwLjczNzg3XSxcbiAgICBcIjgwXCI6IFswLCAwLjcsIDAuMDgwNzgsIDAsIDEuMDEyNjJdLFxuICAgIFwiODFcIjogWzAsIDAuNywgMC4wMzMwNSwgMCwgMC44ODI4Ml0sXG4gICAgXCI4MlwiOiBbMCwgMC43LCAwLjA2MjU5LCAwLCAwLjg1XSxcbiAgICBcIjgzXCI6IFswLCAwLjcsIDAuMTkxODksIDAsIDAuODY3NjddLFxuICAgIFwiODRcIjogWzAsIDAuNywgMC4yOTA4NywgMCwgMC43NDY5N10sXG4gICAgXCI4NVwiOiBbMCwgMC43LCAwLjI1ODE1LCAwLCAwLjc5OTk2XSxcbiAgICBcIjg2XCI6IFswLCAwLjcsIDAuMjc1MjMsIDAsIDAuNjIyMDRdLFxuICAgIFwiODdcIjogWzAsIDAuNywgMC4yNzUyMywgMCwgMC44MDUzMl0sXG4gICAgXCI4OFwiOiBbMCwgMC43LCAwLjI2MDA2LCAwLCAwLjk0NDQ1XSxcbiAgICBcIjg5XCI6IFswLCAwLjcsIDAuMjkzOSwgMCwgMC43MDk2MV0sXG4gICAgXCI5MFwiOiBbMCwgMC43LCAwLjI0MDM3LCAwLCAwLjgyMTJdXG4gIH0sXG4gIFwiU2l6ZTEtUmVndWxhclwiOiB7XG4gICAgXCI0MFwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40NTgzNF0sXG4gICAgXCI0MVwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40NTgzNF0sXG4gICAgXCI0N1wiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC41Nzc3OF0sXG4gICAgXCI5MVwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40MTY2N10sXG4gICAgXCI5MlwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC41Nzc3OF0sXG4gICAgXCI5M1wiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40MTY2N10sXG4gICAgXCIxMjNcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNTgzMzRdLFxuICAgIFwiMTI1XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjU4MzM0XSxcbiAgICBcIjcxMFwiOiBbMCwgMC43MjIyMiwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI3MzJcIjogWzAsIDAuNzIyMjIsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiNzcwXCI6IFswLCAwLjcyMjIyLCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjc3MVwiOiBbMCwgMC43MjIyMiwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI4MjE0XCI6IFstMC4wMDA5OSwgMC42MDEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODU5M1wiOiBbMWUtMDUsIDAuNiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NTk1XCI6IFsxZS0wNSwgMC42LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg2NTdcIjogWzFlLTA1LCAwLjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODY1OVwiOiBbMWUtMDUsIDAuNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzE5XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAwLjk0NDQ1XSxcbiAgICBcIjg3MjBcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDAuOTQ0NDVdLFxuICAgIFwiODcyMVwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMS4wNTU1Nl0sXG4gICAgXCI4NzMwXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAxLjBdLFxuICAgIFwiODczOVwiOiBbLTAuMDA1OTksIDAuNjA2LCAwLCAwLCAwLjMzMzMzXSxcbiAgICBcIjg3NDFcIjogWy0wLjAwNTk5LCAwLjYwNiwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI4NzQ3XCI6IFswLjMwNjEyLCAwLjgwNSwgMC4xOTQ0NSwgMCwgMC40NzIyMl0sXG4gICAgXCI4NzQ4XCI6IFswLjMwNiwgMC44MDUsIDAuMTk0NDUsIDAsIDAuNDcyMjJdLFxuICAgIFwiODc0OVwiOiBbMC4zMDYsIDAuODA1LCAwLjE5NDQ1LCAwLCAwLjQ3MjIyXSxcbiAgICBcIjg3NTBcIjogWzAuMzA2MTIsIDAuODA1LCAwLjE5NDQ1LCAwLCAwLjQ3MjIyXSxcbiAgICBcIjg4OTZcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiODg5N1wiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCI4ODk4XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjg4OTlcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiODk2OFwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCI4OTY5XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjQ3MjIyXSxcbiAgICBcIjg5NzBcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNDcyMjJdLFxuICAgIFwiODk3MVwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCI5MTY4XCI6IFstMC4wMDA5OSwgMC42MDEsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiMTAyMTZcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNDcyMjJdLFxuICAgIFwiMTAyMTdcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNDcyMjJdLFxuICAgIFwiMTA3NTJcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDEuMTExMTFdLFxuICAgIFwiMTA3NTNcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDEuMTExMTFdLFxuICAgIFwiMTA3NTRcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDEuMTExMTFdLFxuICAgIFwiMTA3NTZcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiMTA3NThcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDAuODMzMzRdXG4gIH0sXG4gIFwiU2l6ZTItUmVndWxhclwiOiB7XG4gICAgXCI0MFwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC41OTcyMl0sXG4gICAgXCI0MVwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC41OTcyMl0sXG4gICAgXCI0N1wiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC44MTExMV0sXG4gICAgXCI5MVwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCI5MlwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC44MTExMV0sXG4gICAgXCI5M1wiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCIxMjNcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiMTI1XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjcxMFwiOiBbMCwgMC43NSwgMCwgMCwgMS4wXSxcbiAgICBcIjczMlwiOiBbMCwgMC43NSwgMCwgMCwgMS4wXSxcbiAgICBcIjc3MFwiOiBbMCwgMC43NSwgMCwgMCwgMS4wXSxcbiAgICBcIjc3MVwiOiBbMCwgMC43NSwgMCwgMCwgMS4wXSxcbiAgICBcIjg3MTlcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuMjc3NzhdLFxuICAgIFwiODcyMFwiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS4yNzc3OF0sXG4gICAgXCI4NzIxXCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjQ0NDQ1XSxcbiAgICBcIjg3MzBcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDEuMF0sXG4gICAgXCI4NzQ3XCI6IFswLjg2MjI1LCAxLjM2LCAwLjQ0NDQ1LCAwLCAwLjU1NTU2XSxcbiAgICBcIjg3NDhcIjogWzAuODYyLCAxLjM2LCAwLjQ0NDQ1LCAwLCAwLjU1NTU2XSxcbiAgICBcIjg3NDlcIjogWzAuODYyLCAxLjM2LCAwLjQ0NDQ1LCAwLCAwLjU1NTU2XSxcbiAgICBcIjg3NTBcIjogWzAuODYyMjUsIDEuMzYsIDAuNDQ0NDUsIDAsIDAuNTU1NTZdLFxuICAgIFwiODg5NlwiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS4xMTExMV0sXG4gICAgXCI4ODk3XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjg4OThcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuMTExMTFdLFxuICAgIFwiODg5OVwiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS4xMTExMV0sXG4gICAgXCI4OTY4XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjUyNzc4XSxcbiAgICBcIjg5NjlcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNTI3NzhdLFxuICAgIFwiODk3MFwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC41Mjc3OF0sXG4gICAgXCI4OTcxXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjUyNzc4XSxcbiAgICBcIjEwMjE2XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjEwMjE3XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjEwNzUyXCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjUxMTEyXSxcbiAgICBcIjEwNzUzXCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjUxMTEyXSxcbiAgICBcIjEwNzU0XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjUxMTEyXSxcbiAgICBcIjEwNzU2XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjEwNzU4XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjExMTExXVxuICB9LFxuICBcIlNpemUzLVJlZ3VsYXJcIjoge1xuICAgIFwiNDBcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNzM2MTFdLFxuICAgIFwiNDFcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNzM2MTFdLFxuICAgIFwiNDdcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDEuMDQ0NDVdLFxuICAgIFwiOTFcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNTI3NzhdLFxuICAgIFwiOTJcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDEuMDQ0NDVdLFxuICAgIFwiOTNcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNTI3NzhdLFxuICAgIFwiMTIzXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAwLjc1XSxcbiAgICBcIjEyNVwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC43NV0sXG4gICAgXCI3MTBcIjogWzAsIDAuNzUsIDAsIDAsIDEuNDQ0NDVdLFxuICAgIFwiNzMyXCI6IFswLCAwLjc1LCAwLCAwLCAxLjQ0NDQ1XSxcbiAgICBcIjc3MFwiOiBbMCwgMC43NSwgMCwgMCwgMS40NDQ0NV0sXG4gICAgXCI3NzFcIjogWzAsIDAuNzUsIDAsIDAsIDEuNDQ0NDVdLFxuICAgIFwiODczMFwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMS4wXSxcbiAgICBcIjg5NjhcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNTgzMzRdLFxuICAgIFwiODk2OVwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC41ODMzNF0sXG4gICAgXCI4OTcwXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAwLjU4MzM0XSxcbiAgICBcIjg5NzFcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNTgzMzRdLFxuICAgIFwiMTAyMTZcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNzVdLFxuICAgIFwiMTAyMTdcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNzVdXG4gIH0sXG4gIFwiU2l6ZTQtUmVndWxhclwiOiB7XG4gICAgXCI0MFwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC43OTE2N10sXG4gICAgXCI0MVwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC43OTE2N10sXG4gICAgXCI0N1wiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMS4yNzc3OF0sXG4gICAgXCI5MVwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC41ODMzNF0sXG4gICAgXCI5MlwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMS4yNzc3OF0sXG4gICAgXCI5M1wiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC41ODMzNF0sXG4gICAgXCIxMjNcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuODA1NTZdLFxuICAgIFwiMTI1XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjgwNTU2XSxcbiAgICBcIjcxMFwiOiBbMCwgMC44MjUsIDAsIDAsIDEuODg4OV0sXG4gICAgXCI3MzJcIjogWzAsIDAuODI1LCAwLCAwLCAxLjg4ODldLFxuICAgIFwiNzcwXCI6IFswLCAwLjgyNSwgMCwgMCwgMS44ODg5XSxcbiAgICBcIjc3MVwiOiBbMCwgMC44MjUsIDAsIDAsIDEuODg4OV0sXG4gICAgXCI4NzMwXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAxLjBdLFxuICAgIFwiODk2OFwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCI4OTY5XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjg5NzBcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiODk3MVwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCI5MTE1XCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMCwgMC44NzVdLFxuICAgIFwiOTExNlwiOiBbMWUtMDUsIDAuNiwgMCwgMCwgMC44NzVdLFxuICAgIFwiOTExN1wiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDAsIDAuODc1XSxcbiAgICBcIjkxMThcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwLCAwLjg3NV0sXG4gICAgXCI5MTE5XCI6IFsxZS0wNSwgMC42LCAwLCAwLCAwLjg3NV0sXG4gICAgXCI5MTIwXCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMCwgMC44NzVdLFxuICAgIFwiOTEyMVwiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiOTEyMlwiOiBbLTAuMDAwOTksIDAuNjAxLCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjkxMjNcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjkxMjRcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjkxMjVcIjogWy0wLjAwMDk5LCAwLjYwMSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI5MTI2XCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI5MTI3XCI6IFsxZS0wNSwgMC45LCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjkxMjhcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuODg4ODldLFxuICAgIFwiOTEyOVwiOiBbMC45MDAwMSwgMCwgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI5MTMwXCI6IFswLCAwLjMsIDAsIDAsIDAuODg4ODldLFxuICAgIFwiOTEzMVwiOiBbMWUtMDUsIDAuOSwgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI5MTMyXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjkxMzNcIjogWzAuOTAwMDEsIDAsIDAsIDAsIDAuODg4ODldLFxuICAgIFwiOTE0M1wiOiBbMC44ODUwMiwgMC45MTUsIDAsIDAsIDEuMDU1NTZdLFxuICAgIFwiMTAyMTZcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuODA1NTZdLFxuICAgIFwiMTAyMTdcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuODA1NTZdLFxuICAgIFwiNTczNDRcIjogWy0wLjAwNDk5LCAwLjYwNSwgMCwgMCwgMS4wNTU1Nl0sXG4gICAgXCI1NzM0NVwiOiBbLTAuMDA0OTksIDAuNjA1LCAwLCAwLCAxLjA1NTU2XSxcbiAgICBcIjU3NjgwXCI6IFswLCAwLjEyLCAwLCAwLCAwLjQ1XSxcbiAgICBcIjU3NjgxXCI6IFswLCAwLjEyLCAwLCAwLCAwLjQ1XSxcbiAgICBcIjU3NjgyXCI6IFswLCAwLjEyLCAwLCAwLCAwLjQ1XSxcbiAgICBcIjU3NjgzXCI6IFswLCAwLjEyLCAwLCAwLCAwLjQ1XVxuICB9LFxuICBcIlR5cGV3cml0ZXItUmVndWxhclwiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC41MjVdLFxuICAgIFwiMzNcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjM0XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIzNVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMzZcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjM3XCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIzOFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMzlcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjQwXCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI0MVwiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLFxuICAgIFwiNDJcIjogWzAsIDAuNTIwODMsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjQzXCI6IFstMC4wODA1NiwgMC41MzA1NSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNDRcIjogWzAuMTM4ODksIDAuMTI1LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI0NVwiOiBbLTAuMDgwNTYsIDAuNTMwNTUsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjQ2XCI6IFswLCAwLjEyNSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNDdcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjQ4XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI0OVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNTBcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjUxXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI1MlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNTNcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjU0XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI1NVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNTZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjU3XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI1OFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiNTlcIjogWzAuMTM4ODksIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjYwXCI6IFstMC4wNTU1NiwgMC41NTU1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiNjFcIjogWy0wLjE5NTQ5LCAwLjQxNTYyLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI2MlwiOiBbLTAuMDU1NTYsIDAuNTU1NTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjYzXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI2NFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNjVcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjY2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI2N1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNjhcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjY5XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3MFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzFcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjcyXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3M1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzRcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjc1XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3NlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzdcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjc4XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3OVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODBcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjgxXCI6IFswLjEzODg5LCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4MlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODNcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjg0XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4NVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjg3XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4OFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODlcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkwXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MVwiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTJcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkzXCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5NFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTVcIjogWzAuMDk1MTQsIDAsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjk2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5N1wiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiOThcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjk5XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMDBcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEwMVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTAyXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMDNcIjogWzAuMjIyMjIsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEwNFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTA1XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMDZcIjogWzAuMjIyMjIsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEwN1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTA4XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMDlcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjExMFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTExXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMTJcIjogWzAuMjIyMjIsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjExM1wiOiBbMC4yMjIyMiwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTE0XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMTVcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjExNlwiOiBbMCwgMC41NTM1OCwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTE3XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMThcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjExOVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTIwXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMjFcIjogWzAuMjIyMjIsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEyMlwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTIzXCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMjRcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEyNVwiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTI2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMjdcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTc2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxODRcIjogWzAuMTk0NDUsIDAsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjMwNVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiNTY3XCI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3MTFcIjogWzAsIDAuNTY1OTcsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjcxM1wiOiBbMCwgMC41NjU1NSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzE0XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3MTVcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjcyOFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzMwXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3NzBcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjc3MVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzc2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MTVcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkxNlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTIwXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MjNcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkyNlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTI4XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MzFcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkzM1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTM0XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MzZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkzN1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODIxNlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODIxN1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODI0MlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTI1MVwiOiBbMC4xMTExMSwgMC4yMTk0NCwgMCwgMCwgMC41MjVdXG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZm9udE1ldHJpY3MuanNcblxuXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBtZXRyaWNzIHJlZ2FyZGluZyBmb250cyBhbmQgaW5kaXZpZHVhbCBzeW1ib2xzLiBUaGUgc2lnbWFcbiAqIGFuZCB4aSB2YXJpYWJsZXMsIGFzIHdlbGwgYXMgdGhlIG1ldHJpY01hcCBtYXAgY29udGFpbiBkYXRhIGV4dHJhY3RlZCBmcm9tXG4gKiBUZVgsIFRlWCBmb250IG1ldHJpY3MsIGFuZCB0aGUgVFRGIGZpbGVzLiBUaGVzZSBkYXRhIGFyZSB0aGVuIGV4cG9zZWQgdmlhIHRoZVxuICogYG1ldHJpY3NgIHZhcmlhYmxlIGFuZCB0aGUgZ2V0Q2hhcmFjdGVyTWV0cmljcyBmdW5jdGlvbi5cbiAqL1xuLy8gSW4gVGVYLCB0aGVyZSBhcmUgYWN0dWFsbHkgdGhyZWUgc2V0cyBvZiBkaW1lbnNpb25zLCBvbmUgZm9yIGVhY2ggb2Zcbi8vIHRleHRzdHlsZSAoc2l6ZSBpbmRleCA1IGFuZCBoaWdoZXI6ID49OXB0KSwgc2NyaXB0c3R5bGUgKHNpemUgaW5kZXggMyBhbmQgNDpcbi8vIDctOHB0KSwgYW5kIHNjcmlwdHNjcmlwdHN0eWxlIChzaXplIGluZGV4IDEgYW5kIDI6IDUtNnB0KS4gIFRoZXNlIGFyZVxuLy8gcHJvdmlkZWQgaW4gdGhlIHRoZSBhcnJheXMgYmVsb3csIGluIHRoYXQgb3JkZXIuXG4vL1xuLy8gVGhlIGZvbnQgbWV0cmljcyBhcmUgc3RvcmVkIGluIGZvbnRzIGNtc3kxMCwgY21zeTcsIGFuZCBjbXN5NSByZXNwc2VjdGl2ZWx5LlxuLy8gVGhpcyB3YXMgZGV0ZXJtaW5lZCBieSBydW5uaW5nIHRoZSBmb2xsb3dpbmcgc2NyaXB0OlxuLy9cbi8vICAgICBsYXRleCAtaW50ZXJhY3Rpb249bm9uc3RvcG1vZGUgXFxcbi8vICAgICAnXFxkb2N1bWVudGNsYXNze2FydGljbGV9XFx1c2VwYWNrYWdle2Ftc21hdGh9XFxiZWdpbntkb2N1bWVudH0nIFxcXG4vLyAgICAgJyRhJCBcXGV4cGFuZGFmdGVyXFxzaG93XFx0aGVcXHRleHRmb250MicgXFxcbi8vICAgICAnXFxleHBhbmRhZnRlclxcc2hvd1xcdGhlXFxzY3JpcHRmb250MicgXFxcbi8vICAgICAnXFxleHBhbmRhZnRlclxcc2hvd1xcdGhlXFxzY3JpcHRzY3JpcHRmb250MicgXFxcbi8vICAgICAnXFxzdG9wJ1xuLy9cbi8vIFRoZSBtZXRyaWNzIHRoZW1zZWx2ZXMgd2VyZSByZXRyZWl2ZWQgdXNpbmcgdGhlIGZvbGxvd2luZyBjb21tYW5kczpcbi8vXG4vLyAgICAgdGZ0b3BsIGNtc3kxMFxuLy8gICAgIHRmdG9wbCBjbXN5N1xuLy8gICAgIHRmdG9wbCBjbXN5NVxuLy9cbi8vIFRoZSBvdXRwdXQgb2YgZWFjaCBvZiB0aGVzZSBjb21tYW5kcyBpcyBxdWl0ZSBsZW5ndGh5LiAgVGhlIG9ubHkgcGFydCB3ZVxuLy8gY2FyZSBhYm91dCBpcyB0aGUgRk9OVERJTUVOIHNlY3Rpb24uIEVhY2ggdmFsdWUgaXMgbWVhc3VyZWQgaW4gRU1zLlxudmFyIHNpZ21hc0FuZFhpcyA9IHtcbiAgc2xhbnQ6IFswLjI1MCwgMC4yNTAsIDAuMjUwXSxcbiAgLy8gc2lnbWExXG4gIHNwYWNlOiBbMC4wMDAsIDAuMDAwLCAwLjAwMF0sXG4gIC8vIHNpZ21hMlxuICBzdHJldGNoOiBbMC4wMDAsIDAuMDAwLCAwLjAwMF0sXG4gIC8vIHNpZ21hM1xuICBzaHJpbms6IFswLjAwMCwgMC4wMDAsIDAuMDAwXSxcbiAgLy8gc2lnbWE0XG4gIHhIZWlnaHQ6IFswLjQzMSwgMC40MzEsIDAuNDMxXSxcbiAgLy8gc2lnbWE1XG4gIHF1YWQ6IFsxLjAwMCwgMS4xNzEsIDEuNDcyXSxcbiAgLy8gc2lnbWE2XG4gIGV4dHJhU3BhY2U6IFswLjAwMCwgMC4wMDAsIDAuMDAwXSxcbiAgLy8gc2lnbWE3XG4gIG51bTE6IFswLjY3NywgMC43MzIsIDAuOTI1XSxcbiAgLy8gc2lnbWE4XG4gIG51bTI6IFswLjM5NCwgMC4zODQsIDAuMzg3XSxcbiAgLy8gc2lnbWE5XG4gIG51bTM6IFswLjQ0NCwgMC40NzEsIDAuNTA0XSxcbiAgLy8gc2lnbWExMFxuICBkZW5vbTE6IFswLjY4NiwgMC43NTIsIDEuMDI1XSxcbiAgLy8gc2lnbWExMVxuICBkZW5vbTI6IFswLjM0NSwgMC4zNDQsIDAuNTMyXSxcbiAgLy8gc2lnbWExMlxuICBzdXAxOiBbMC40MTMsIDAuNTAzLCAwLjUwNF0sXG4gIC8vIHNpZ21hMTNcbiAgc3VwMjogWzAuMzYzLCAwLjQzMSwgMC40MDRdLFxuICAvLyBzaWdtYTE0XG4gIHN1cDM6IFswLjI4OSwgMC4yODYsIDAuMjk0XSxcbiAgLy8gc2lnbWExNVxuICBzdWIxOiBbMC4xNTAsIDAuMTQzLCAwLjIwMF0sXG4gIC8vIHNpZ21hMTZcbiAgc3ViMjogWzAuMjQ3LCAwLjI4NiwgMC40MDBdLFxuICAvLyBzaWdtYTE3XG4gIHN1cERyb3A6IFswLjM4NiwgMC4zNTMsIDAuNDk0XSxcbiAgLy8gc2lnbWExOFxuICBzdWJEcm9wOiBbMC4wNTAsIDAuMDcxLCAwLjEwMF0sXG4gIC8vIHNpZ21hMTlcbiAgZGVsaW0xOiBbMi4zOTAsIDEuNzAwLCAxLjk4MF0sXG4gIC8vIHNpZ21hMjBcbiAgZGVsaW0yOiBbMS4wMTAsIDEuMTU3LCAxLjQyMF0sXG4gIC8vIHNpZ21hMjFcbiAgYXhpc0hlaWdodDogWzAuMjUwLCAwLjI1MCwgMC4yNTBdLFxuICAvLyBzaWdtYTIyXG4gIC8vIFRoZXNlIGZvbnQgbWV0cmljcyBhcmUgZXh0cmFjdGVkIGZyb20gVGVYIGJ5IHVzaW5nIHRmdG9wbCBvbiBjbWV4MTAudGZtO1xuICAvLyB0aGV5IGNvcnJlc3BvbmQgdG8gdGhlIGZvbnQgcGFyYW1ldGVycyBvZiB0aGUgZXh0ZW5zaW9uIGZvbnRzIChmYW1pbHkgMykuXG4gIC8vIFNlZSB0aGUgVGVYYm9vaywgcGFnZSA0NDEuIEluIEFNU1RlWCwgdGhlIGV4dGVuc2lvbiBmb250cyBzY2FsZTsgdG9cbiAgLy8gbWF0Y2ggY21leDcsIHdlJ2QgdXNlIGNtZXg3LnRmbSB2YWx1ZXMgZm9yIHNjcmlwdCBhbmQgc2NyaXB0c2NyaXB0XG4gIC8vIHZhbHVlcy5cbiAgZGVmYXVsdFJ1bGVUaGlja25lc3M6IFswLjA0LCAwLjA0OSwgMC4wNDldLFxuICAvLyB4aTg7IGNtZXg3OiAwLjA0OVxuICBiaWdPcFNwYWNpbmcxOiBbMC4xMTEsIDAuMTExLCAwLjExMV0sXG4gIC8vIHhpOVxuICBiaWdPcFNwYWNpbmcyOiBbMC4xNjYsIDAuMTY2LCAwLjE2Nl0sXG4gIC8vIHhpMTBcbiAgYmlnT3BTcGFjaW5nMzogWzAuMiwgMC4yLCAwLjJdLFxuICAvLyB4aTExXG4gIGJpZ09wU3BhY2luZzQ6IFswLjYsIDAuNjExLCAwLjYxMV0sXG4gIC8vIHhpMTI7IGNtZXg3OiAwLjYxMVxuICBiaWdPcFNwYWNpbmc1OiBbMC4xLCAwLjE0MywgMC4xNDNdLFxuICAvLyB4aTEzOyBjbWV4NzogMC4xNDNcbiAgLy8gVGhlIFxcc3FydCBydWxlIHdpZHRoIGlzIHRha2VuIGZyb20gdGhlIGhlaWdodCBvZiB0aGUgc3VyZCBjaGFyYWN0ZXIuXG4gIC8vIFNpbmNlIHdlIHVzZSB0aGUgc2FtZSBmb250IGF0IGFsbCBzaXplcywgdGhpcyB0aGlja25lc3MgZG9lc24ndCBzY2FsZS5cbiAgc3FydFJ1bGVUaGlja25lc3M6IFswLjA0LCAwLjA0LCAwLjA0XSxcbiAgLy8gVGhpcyB2YWx1ZSBkZXRlcm1pbmVzIGhvdyBsYXJnZSBhIHB0IGlzLCBmb3IgbWV0cmljcyB3aGljaCBhcmUgZGVmaW5lZFxuICAvLyBpbiB0ZXJtcyBvZiBwdHMuXG4gIC8vIFRoaXMgdmFsdWUgaXMgYWxzbyB1c2VkIGluIGthdGV4Lmxlc3M7IGlmIHlvdSBjaGFuZ2UgaXQgbWFrZSBzdXJlIHRoZVxuICAvLyB2YWx1ZXMgbWF0Y2guXG4gIHB0UGVyRW06IFsxMC4wLCAxMC4wLCAxMC4wXSxcbiAgLy8gVGhlIHNwYWNlIGJldHdlZW4gYWRqYWNlbnQgYHxgIGNvbHVtbnMgaW4gYW4gYXJyYXkgZGVmaW5pdGlvbi4gRnJvbVxuICAvLyBgXFxzaG93dGhlXFxkb3VibGVydWxlc2VwYCBpbiBMYVRlWC4gRXF1YWxzIDIuMCAvIHB0UGVyRW0uXG4gIGRvdWJsZVJ1bGVTZXA6IFswLjIsIDAuMiwgMC4yXSxcbiAgLy8gVGhlIHdpZHRoIG9mIHNlcGFyYXRvciBsaW5lcyBpbiB7YXJyYXl9IGVudmlyb25tZW50cy4gRnJvbVxuICAvLyBgXFxzaG93dGhlXFxhcnJheXJ1bGV3aWR0aGAgaW4gTGFUZVguIEVxdWFscyAwLjQgLyBwdFBlckVtLlxuICBhcnJheVJ1bGVXaWR0aDogWzAuMDQsIDAuMDQsIDAuMDRdLFxuICAvLyBUd28gdmFsdWVzIGZyb20gTGFUZVggc291cmNlMmU6XG4gIGZib3hzZXA6IFswLjMsIDAuMywgMC4zXSxcbiAgLy8gICAgICAgIDMgcHQgLyBwdFBlckVtXG4gIGZib3hydWxlOiBbMC4wNCwgMC4wNCwgMC4wNF0gLy8gMC40IHB0IC8gcHRQZXJFbVxuXG59OyAvLyBUaGlzIG1hcCBjb250YWlucyBhIG1hcHBpbmcgZnJvbSBmb250IG5hbWUgYW5kIGNoYXJhY3RlciBjb2RlIHRvIGNoYXJhY3RlclxuLy8gbWV0cmljcywgaW5jbHVkaW5nIGhlaWdodCwgZGVwdGgsIGl0YWxpYyBjb3JyZWN0aW9uLCBhbmQgc2tldyAoa2VybiBmcm9tIHRoZVxuLy8gY2hhcmFjdGVyIHRvIHRoZSBjb3JyZXNwb25kaW5nIFxcc2tld2NoYXIpXG4vLyBUaGlzIG1hcCBpcyBnZW5lcmF0ZWQgdmlhIGBtYWtlIG1ldHJpY3NgLiBJdCBzaG91bGQgbm90IGJlIGNoYW5nZWQgbWFudWFsbHkuXG5cbiAvLyBUaGVzZSBhcmUgdmVyeSByb3VnaCBhcHByb3hpbWF0aW9ucy4gIFdlIGRlZmF1bHQgdG8gVGltZXMgTmV3IFJvbWFuIHdoaWNoXG4vLyBzaG91bGQgaGF2ZSBMYXRpbi0xIGFuZCBDeXJpbGxpYyBjaGFyYWN0ZXJzLCBidXQgbWF5IG5vdCBkZXBlbmRpbmcgb24gdGhlXG4vLyBvcGVyYXRpbmcgc3lzdGVtLiAgVGhlIG1ldHJpY3MgZG8gbm90IGFjY291bnQgZm9yIGV4dHJhIGhlaWdodCBmcm9tIHRoZVxuLy8gYWNjZW50cy4gIEluIHRoZSBjYXNlIG9mIEN5cmlsbGljIGNoYXJhY3RlcnMgd2hpY2ggaGF2ZSBib3RoIGFzY2VuZGVycyBhbmRcbi8vIGRlc2NlbmRlcnMgd2UgcHJlZmVyIGFwcHJveGltYXRpb25zIHdpdGggYXNjZW5kZXJzLCBwcmltYXJpbHkgdG8gcHJldmVudFxuLy8gdGhlIGZyYWN0aW9uIGJhciBvciByb290IGxpbmUgZnJvbSBpbnRlcnNlY3RpbmcgdGhlIGdseXBoLlxuLy8gVE9ETyhrZXZpbmIpIGFsbG93IHVuaW9uIG9mIG11bHRpcGxlIGdseXBoIG1ldHJpY3MgZm9yIGJldHRlciBhY2N1cmFjeS5cblxudmFyIGV4dHJhQ2hhcmFjdGVyTWFwID0ge1xuICAvLyBMYXRpbi0xXG4gICfDhSc6ICdBJyxcbiAgJ8OHJzogJ0MnLFxuICAnw5AnOiAnRCcsXG4gICfDnic6ICdvJyxcbiAgJ8OlJzogJ2EnLFxuICAnw6cnOiAnYycsXG4gICfDsCc6ICdkJyxcbiAgJ8O+JzogJ28nLFxuICAvLyBDeXJpbGxpY1xuICAn0JAnOiAnQScsXG4gICfQkSc6ICdCJyxcbiAgJ9CSJzogJ0InLFxuICAn0JMnOiAnRicsXG4gICfQlCc6ICdBJyxcbiAgJ9CVJzogJ0UnLFxuICAn0JYnOiAnSycsXG4gICfQlyc6ICczJyxcbiAgJ9CYJzogJ04nLFxuICAn0JknOiAnTicsXG4gICfQmic6ICdLJyxcbiAgJ9CbJzogJ04nLFxuICAn0JwnOiAnTScsXG4gICfQnSc6ICdIJyxcbiAgJ9CeJzogJ08nLFxuICAn0J8nOiAnTicsXG4gICfQoCc6ICdQJyxcbiAgJ9ChJzogJ0MnLFxuICAn0KInOiAnVCcsXG4gICfQoyc6ICd5JyxcbiAgJ9CkJzogJ08nLFxuICAn0KUnOiAnWCcsXG4gICfQpic6ICdVJyxcbiAgJ9CnJzogJ2gnLFxuICAn0KgnOiAnVycsXG4gICfQqSc6ICdXJyxcbiAgJ9CqJzogJ0InLFxuICAn0KsnOiAnWCcsXG4gICfQrCc6ICdCJyxcbiAgJ9CtJzogJzMnLFxuICAn0K4nOiAnWCcsXG4gICfQryc6ICdSJyxcbiAgJ9CwJzogJ2EnLFxuICAn0LEnOiAnYicsXG4gICfQsic6ICdhJyxcbiAgJ9CzJzogJ3InLFxuICAn0LQnOiAneScsXG4gICfQtSc6ICdlJyxcbiAgJ9C2JzogJ20nLFxuICAn0LcnOiAnZScsXG4gICfQuCc6ICduJyxcbiAgJ9C5JzogJ24nLFxuICAn0LonOiAnbicsXG4gICfQuyc6ICduJyxcbiAgJ9C8JzogJ20nLFxuICAn0L0nOiAnbicsXG4gICfQvic6ICdvJyxcbiAgJ9C/JzogJ24nLFxuICAn0YAnOiAncCcsXG4gICfRgSc6ICdjJyxcbiAgJ9GCJzogJ28nLFxuICAn0YMnOiAneScsXG4gICfRhCc6ICdiJyxcbiAgJ9GFJzogJ3gnLFxuICAn0YYnOiAnbicsXG4gICfRhyc6ICduJyxcbiAgJ9GIJzogJ3cnLFxuICAn0YknOiAndycsXG4gICfRiic6ICdhJyxcbiAgJ9GLJzogJ20nLFxuICAn0YwnOiAnYScsXG4gICfRjSc6ICdlJyxcbiAgJ9GOJzogJ20nLFxuICAn0Y8nOiAncidcbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhZGRzIG5ldyBmb250IG1ldHJpY3MgdG8gZGVmYXVsdCBtZXRyaWNNYXBcbiAqIEl0IGNhbiBhbHNvIG92ZXJyaWRlIGV4aXN0aW5nIG1ldHJpY3NcbiAqL1xuZnVuY3Rpb24gc2V0Rm9udE1ldHJpY3MoZm9udE5hbWUsIG1ldHJpY3MpIHtcbiAgZm9udE1ldHJpY3NEYXRhW2ZvbnROYW1lXSA9IG1ldHJpY3M7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgbG9va2luZyB1cCBpbmZvcm1hdGlvbiBpbiB0aGVcbiAqIG1ldHJpY01hcCB0YWJsZS4gSXQgdGFrZXMgYSBjaGFyYWN0ZXIgYXMgYSBzdHJpbmcsIGFuZCBhIGZvbnQuXG4gKlxuICogTm90ZTogdGhlIGB3aWR0aGAgcHJvcGVydHkgbWF5IGJlIHVuZGVmaW5lZCBpZiBmb250TWV0cmljc0RhdGEuanMgd2Fzbid0XG4gKiBidWlsdCB1c2luZyBgTWFrZSBleHRlbmRlZF9tZXRyaWNzYC5cbiAqL1xuXG5mdW5jdGlvbiBnZXRDaGFyYWN0ZXJNZXRyaWNzKGNoYXJhY3RlciwgZm9udCwgbW9kZSkge1xuICBpZiAoIWZvbnRNZXRyaWNzRGF0YVtmb250XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZvbnQgbWV0cmljcyBub3QgZm91bmQgZm9yIGZvbnQ6IFwiICsgZm9udCArIFwiLlwiKTtcbiAgfVxuXG4gIHZhciBjaCA9IGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApO1xuICB2YXIgbWV0cmljcyA9IGZvbnRNZXRyaWNzRGF0YVtmb250XVtjaF07XG5cbiAgaWYgKCFtZXRyaWNzICYmIGNoYXJhY3RlclswXSBpbiBleHRyYUNoYXJhY3Rlck1hcCkge1xuICAgIGNoID0gZXh0cmFDaGFyYWN0ZXJNYXBbY2hhcmFjdGVyWzBdXS5jaGFyQ29kZUF0KDApO1xuICAgIG1ldHJpY3MgPSBmb250TWV0cmljc0RhdGFbZm9udF1bY2hdO1xuICB9XG5cbiAgaWYgKCFtZXRyaWNzICYmIG1vZGUgPT09ICd0ZXh0Jykge1xuICAgIC8vIFdlIGRvbid0IHR5cGljYWxseSBoYXZlIGZvbnQgbWV0cmljcyBmb3IgQXNpYW4gc2NyaXB0cy5cbiAgICAvLyBCdXQgc2luY2Ugd2Ugc3VwcG9ydCB0aGVtIGluIHRleHQgbW9kZSwgd2UgbmVlZCB0byByZXR1cm5cbiAgICAvLyBzb21lIHNvcnQgb2YgbWV0cmljcy5cbiAgICAvLyBTbyBpZiB0aGUgY2hhcmFjdGVyIGlzIGluIGEgc2NyaXB0IHdlIHN1cHBvcnQgYnV0IHdlXG4gICAgLy8gZG9uJ3QgaGF2ZSBtZXRyaWNzIGZvciBpdCwganVzdCB1c2UgdGhlIG1ldHJpY3MgZm9yXG4gICAgLy8gdGhlIExhdGluIGNhcGl0YWwgbGV0dGVyIE0uIFRoaXMgaXMgY2xvc2UgZW5vdWdoIGJlY2F1c2VcbiAgICAvLyB3ZSAoY3VycmVudGx5KSBvbmx5IGNhcmUgYWJvdXQgdGhlIGhlaWdodCBvZiB0aGUgZ2xweWhcbiAgICAvLyBub3QgaXRzIHdpZHRoLlxuICAgIGlmIChzdXBwb3J0ZWRDb2RlcG9pbnQoY2gpKSB7XG4gICAgICBtZXRyaWNzID0gZm9udE1ldHJpY3NEYXRhW2ZvbnRdWzc3XTsgLy8gNzcgaXMgdGhlIGNoYXJjb2RlIGZvciAnTSdcbiAgICB9XG4gIH1cblxuICBpZiAobWV0cmljcykge1xuICAgIHJldHVybiB7XG4gICAgICBkZXB0aDogbWV0cmljc1swXSxcbiAgICAgIGhlaWdodDogbWV0cmljc1sxXSxcbiAgICAgIGl0YWxpYzogbWV0cmljc1syXSxcbiAgICAgIHNrZXc6IG1ldHJpY3NbM10sXG4gICAgICB3aWR0aDogbWV0cmljc1s0XVxuICAgIH07XG4gIH1cbn1cbnZhciBmb250TWV0cmljc0J5U2l6ZUluZGV4ID0ge307XG4vKipcbiAqIEdldCB0aGUgZm9udCBtZXRyaWNzIGZvciBhIGdpdmVuIHNpemUuXG4gKi9cblxuZnVuY3Rpb24gZ2V0R2xvYmFsTWV0cmljcyhzaXplKSB7XG4gIHZhciBzaXplSW5kZXg7XG5cbiAgaWYgKHNpemUgPj0gNSkge1xuICAgIHNpemVJbmRleCA9IDA7XG4gIH0gZWxzZSBpZiAoc2l6ZSA+PSAzKSB7XG4gICAgc2l6ZUluZGV4ID0gMTtcbiAgfSBlbHNlIHtcbiAgICBzaXplSW5kZXggPSAyO1xuICB9XG5cbiAgaWYgKCFmb250TWV0cmljc0J5U2l6ZUluZGV4W3NpemVJbmRleF0pIHtcbiAgICB2YXIgbWV0cmljcyA9IGZvbnRNZXRyaWNzQnlTaXplSW5kZXhbc2l6ZUluZGV4XSA9IHtcbiAgICAgIGNzc0VtUGVyTXU6IHNpZ21hc0FuZFhpcy5xdWFkW3NpemVJbmRleF0gLyAxOFxuICAgIH07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc2lnbWFzQW5kWGlzKSB7XG4gICAgICBpZiAoc2lnbWFzQW5kWGlzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgbWV0cmljc1trZXldID0gc2lnbWFzQW5kWGlzW2tleV1bc2l6ZUluZGV4XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZm9udE1ldHJpY3NCeVNpemVJbmRleFtzaXplSW5kZXhdO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc3ltYm9scy5qc1xuLyoqXG4gKiBUaGlzIGZpbGUgaG9sZHMgYSBsaXN0IG9mIGFsbCBuby1hcmd1bWVudCBmdW5jdGlvbnMgYW5kIHNpbmdsZS1jaGFyYWN0ZXJcbiAqIHN5bWJvbHMgKGxpa2UgJ2EnIG9yICc7JykuXG4gKlxuICogRm9yIGVhY2ggb2YgdGhlIHN5bWJvbHMsIHRoZXJlIGFyZSB0aHJlZSBwcm9wZXJ0aWVzIHRoZXkgY2FuIGhhdmU6XG4gKiAtIGZvbnQgKHJlcXVpcmVkKTogdGhlIGZvbnQgdG8gYmUgdXNlZCBmb3IgdGhpcyBzeW1ib2wuIEVpdGhlciBcIm1haW5cIiAodGhlXG4gICAgIG5vcm1hbCBmb250KSwgb3IgXCJhbXNcIiAodGhlIGFtcyBmb250cykuXG4gKiAtIGdyb3VwIChyZXF1aXJlZCk6IHRoZSBQYXJzZU5vZGUgZ3JvdXAgdHlwZSB0aGUgc3ltYm9sIHNob3VsZCBoYXZlIChpLmUuXG4gICAgIFwidGV4dG9yZFwiLCBcIm1hdGhvcmRcIiwgZXRjKS5cbiAgICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9LYVRlWC9LYVRlWC93aWtpL0V4YW1pbmluZy1UZVgjZ3JvdXAtdHlwZXNcbiAqIC0gcmVwbGFjZTogdGhlIGNoYXJhY3RlciB0aGF0IHRoaXMgc3ltYm9sIG9yIGZ1bmN0aW9uIHNob3VsZCBiZVxuICogICByZXBsYWNlZCB3aXRoIChpLmUuIFwiXFxwaGlcIiBoYXMgYSByZXBsYWNlIHZhbHVlIG9mIFwiXFx1MDNkNVwiLCB0aGUgcGhpXG4gKiAgIGNoYXJhY3RlciBpbiB0aGUgbWFpbiBmb250KS5cbiAqXG4gKiBUaGUgb3V0ZXJtb3N0IG1hcCBpbiB0aGUgdGFibGUgaW5kaWNhdGVzIHdoYXQgbW9kZSB0aGUgc3ltYm9scyBzaG91bGQgYmVcbiAqIGFjY2VwdGVkIGluIChlLmcuIFwibWF0aFwiIG9yIFwidGV4dFwiKS5cbiAqL1xuLy8gU29tZSBvZiB0aGVzZSBoYXZlIGEgXCItdG9rZW5cIiBzdWZmaXggc2luY2UgdGhlc2UgYXJlIGFsc28gdXNlZCBhcyBgUGFyc2VOb2RlYFxuLy8gdHlwZXMgZm9yIHJhdyB0ZXh0IHRva2VucywgYW5kIHdlIHdhbnQgdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggaGlnaGVyLWxldmVsXG4vLyBgUGFyc2VOb2RlYCB0eXBlcy4gVGhlc2UgYFBhcnNlTm9kZWBzIGFyZSBjb25zdHJ1Y3RlZCB3aXRoaW4gYFBhcnNlcmAgYnlcbi8vIGxvb2tpbmcgdXAgdGhlIGBzeW1ib2xzYCBtYXAuXG52YXIgQVRPTVMgPSB7XG4gIFwiYmluXCI6IDEsXG4gIFwiY2xvc2VcIjogMSxcbiAgXCJpbm5lclwiOiAxLFxuICBcIm9wZW5cIjogMSxcbiAgXCJwdW5jdFwiOiAxLFxuICBcInJlbFwiOiAxXG59O1xudmFyIE5PTl9BVE9NUyA9IHtcbiAgXCJhY2NlbnQtdG9rZW5cIjogMSxcbiAgXCJtYXRob3JkXCI6IDEsXG4gIFwib3AtdG9rZW5cIjogMSxcbiAgXCJzcGFjaW5nXCI6IDEsXG4gIFwidGV4dG9yZFwiOiAxXG59O1xudmFyIHN5bWJvbHMgPSB7XG4gIFwibWF0aFwiOiB7fSxcbiAgXCJ0ZXh0XCI6IHt9XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX3N5bWJvbHMgPSAoc3ltYm9scyk7XG4vKiogYGFjY2VwdFVuaWNvZGVDaGFyID0gdHJ1ZWAgaXMgb25seSBhcHBsaWNhYmxlIGlmIGByZXBsYWNlYCBpcyBzZXQuICovXG5cbmZ1bmN0aW9uIGRlZmluZVN5bWJvbChtb2RlLCBmb250LCBncm91cCwgcmVwbGFjZSwgbmFtZSwgYWNjZXB0VW5pY29kZUNoYXIpIHtcbiAgc3ltYm9sc1ttb2RlXVtuYW1lXSA9IHtcbiAgICBmb250OiBmb250LFxuICAgIGdyb3VwOiBncm91cCxcbiAgICByZXBsYWNlOiByZXBsYWNlXG4gIH07XG5cbiAgaWYgKGFjY2VwdFVuaWNvZGVDaGFyICYmIHJlcGxhY2UpIHtcbiAgICBzeW1ib2xzW21vZGVdW3JlcGxhY2VdID0gc3ltYm9sc1ttb2RlXVtuYW1lXTtcbiAgfVxufSAvLyBTb21lIGFiYnJldmlhdGlvbnMgZm9yIGNvbW1vbmx5IHVzZWQgc3RyaW5ncy5cbi8vIFRoaXMgaGVscHMgbWluaWZ5IHRoZSBjb2RlLCBhbmQgYWxzbyBzcG90dGluZyB0eXBvcyB1c2luZyBqc2hpbnQuXG4vLyBtb2RlczpcblxudmFyIHN5bWJvbHNfbWF0aCA9IFwibWF0aFwiO1xudmFyIHN5bWJvbHNfdGV4dCA9IFwidGV4dFwiOyAvLyBmb250czpcblxudmFyIG1haW4gPSBcIm1haW5cIjtcbnZhciBhbXMgPSBcImFtc1wiOyAvLyBncm91cHM6XG5cbnZhciBzeW1ib2xzX2FjY2VudCA9IFwiYWNjZW50LXRva2VuXCI7XG52YXIgYmluID0gXCJiaW5cIjtcbnZhciBzeW1ib2xzX2Nsb3NlID0gXCJjbG9zZVwiO1xudmFyIHN5bWJvbHNfaW5uZXIgPSBcImlubmVyXCI7XG52YXIgbWF0aG9yZCA9IFwibWF0aG9yZFwiO1xudmFyIG9wID0gXCJvcC10b2tlblwiO1xudmFyIHN5bWJvbHNfb3BlbiA9IFwib3BlblwiO1xudmFyIHB1bmN0ID0gXCJwdW5jdFwiO1xudmFyIHJlbCA9IFwicmVsXCI7XG52YXIgc3ltYm9sc19zcGFjaW5nID0gXCJzcGFjaW5nXCI7XG52YXIgc3ltYm9sc190ZXh0b3JkID0gXCJ0ZXh0b3JkXCI7IC8vIE5vdyBjb21lcyB0aGUgc3ltYm9sIHRhYmxlXG4vLyBSZWxhdGlvbiBTeW1ib2xzXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjYxXCIsIFwiXFxcXGVxdWl2XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyN0FcIiwgXCJcXFxccHJlY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjdCXCIsIFwiXFxcXHN1Y2NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjIzQ1wiLCBcIlxcXFxzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjJBNVwiLCBcIlxcXFxwZXJwXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTJBQUZcIiwgXCJcXFxccHJlY2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTJBQjBcIiwgXCJcXFxcc3VjY2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNDNcIiwgXCJcXFxcc2ltZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjIyM1wiLCBcIlxcXFxtaWRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2QVwiLCBcIlxcXFxsbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjZCXCIsIFwiXFxcXGdnXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNERcIiwgXCJcXFxcYXN5bXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjIyNVwiLCBcIlxcXFxwYXJhbGxlbFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMkM4XCIsIFwiXFxcXGJvd3RpZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMzIzXCIsIFwiXFxcXHNtaWxlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyOTFcIiwgXCJcXFxcc3FzdWJzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjkyXCIsIFwiXFxcXHNxc3Vwc2V0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjI1MFwiLCBcIlxcXFxkb3RlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMzIyXCIsIFwiXFxcXGZyb3duXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyMEJcIiwgXCJcXFxcbmlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjIxRFwiLCBcIlxcXFxwcm9wdG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjJBMlwiLCBcIlxcXFx2ZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMkEzXCIsIFwiXFxcXGRhc2h2XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyMEJcIiwgXCJcXFxcb3duc1wiKTsgLy8gUHVuY3R1YXRpb25cblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcHVuY3QsIFwiLlwiLCBcIlxcXFxsZG90cFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHB1bmN0LCBcIlxcdTIyQzVcIiwgXCJcXFxcY2RvdHBcIik7IC8vIE1pc2MgU3ltYm9sc1xuXG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiI1wiLCBcIlxcXFwjXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIiNcIiwgXCJcXFxcI1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCImXCIsIFwiXFxcXCZcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiJlwiLCBcIlxcXFwmXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIxMzVcIiwgXCJcXFxcYWxlcGhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjIwMFwiLCBcIlxcXFxmb3JhbGxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjEwRlwiLCBcIlxcXFxoYmFyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIyMDNcIiwgXCJcXFxcZXhpc3RzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIyMDdcIiwgXCJcXFxcbmFibGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjY2RFwiLCBcIlxcXFxmbGF0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIxMTNcIiwgXCJcXFxcZWxsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTI2NkVcIiwgXCJcXFxcbmF0dXJhbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNjYzXCIsIFwiXFxcXGNsdWJzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIxMThcIiwgXCJcXFxcd3BcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjY2RlwiLCBcIlxcXFxzaGFycFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNjYyXCIsIFwiXFxcXGRpYW1vbmRzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIxMUNcIiwgXCJcXFxcUmVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjY2MVwiLCBcIlxcXFxoZWFydHN1aXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjExMVwiLCBcIlxcXFxJbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNjYwXCIsIFwiXFxcXHNwYWRlc3VpdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHhBN1wiLCBcIlxcXFxTXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxceEI2XCIsIFwiXFxcXFBcIiwgdHJ1ZSk7IC8vIE1hdGggYW5kIFRleHRcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIwMjBcIiwgXCJcXFxcZGFnXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIwMjBcIiwgXCJcXFxcZGFnXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIwMjBcIiwgXCJcXFxcdGV4dGRhZ2dlclwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyMDIxXCIsIFwiXFxcXGRkYWdcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjAyMVwiLCBcIlxcXFxkZGFnXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIwMjFcIiwgXCJcXFxcdGV4dGRhZ2dlcmRibFwiKTsgLy8gTGFyZ2UgRGVsaW1pdGVyc1xuXG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX2Nsb3NlLCBcIlxcdTIzQjFcIiwgXCJcXFxccm1vdXN0YWNoZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfb3BlbiwgXCJcXHUyM0IwXCIsIFwiXFxcXGxtb3VzdGFjaGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX2Nsb3NlLCBcIlxcdTI3RUZcIiwgXCJcXFxccmdyb3VwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19vcGVuLCBcIlxcdTI3RUVcIiwgXCJcXFxcbGdyb3VwXCIsIHRydWUpOyAvLyBCaW5hcnkgT3BlcmF0b3JzXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjEzXCIsIFwiXFxcXG1wXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTZcIiwgXCJcXFxcb21pbnVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOEVcIiwgXCJcXFxcdXBsdXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI5M1wiLCBcIlxcXFxzcWNhcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE3XCIsIFwiXFxcXGFzdFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjk0XCIsIFwiXFxcXHNxY3VwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1RUZcIiwgXCJcXFxcYmlnY2lyY1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE5XCIsIFwiXFxcXGJ1bGxldFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIGJpbiwgXCJcXHUyMDIxXCIsIFwiXFxcXGRkYWdnZXJcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI0MFwiLCBcIlxcXFx3clwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIGJpbiwgXCJcXHUyQTNGXCIsIFwiXFxcXGFtYWxnXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIiZcIiwgXCJcXFxcQW5kXCIpOyAvLyBmcm9tIGFtc21hdGhcbi8vIEFycm93IFN5bWJvbHNcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTI3RjVcIiwgXCJcXFxcbG9uZ2xlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMUQwXCIsIFwiXFxcXExlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyN0Y4XCIsIFwiXFxcXExvbmdsZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjdGNlwiLCBcIlxcXFxsb25ncmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMUQyXCIsIFwiXFxcXFJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjdGOVwiLCBcIlxcXFxMb25ncmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk0XCIsIFwiXFxcXGxlZnRyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTI3RjdcIiwgXCJcXFxcbG9uZ2xlZnRyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxRDRcIiwgXCJcXFxcTGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjdGQVwiLCBcIlxcXFxMb25nbGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjFBNlwiLCBcIlxcXFxtYXBzdG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjdGQ1wiLCBcIlxcXFxsb25nbWFwc3RvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTdcIiwgXCJcXFxcbmVhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMUE5XCIsIFwiXFxcXGhvb2tsZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjFBQVwiLCBcIlxcXFxob29rcmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk4XCIsIFwiXFxcXHNlYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjFCQ1wiLCBcIlxcXFxsZWZ0aGFycG9vbnVwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxQzBcIiwgXCJcXFxccmlnaHRoYXJwb29udXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5OVwiLCBcIlxcXFxzd2Fycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxQkRcIiwgXCJcXFxcbGVmdGhhcnBvb25kb3duXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxQzFcIiwgXCJcXFxccmlnaHRoYXJwb29uZG93blwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk2XCIsIFwiXFxcXG53YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjFDQ1wiLCBcIlxcXFxyaWdodGxlZnRoYXJwb29uc1wiLCB0cnVlKTsgLy8gQU1TIE5lZ2F0ZWQgQmluYXJ5IFJlbGF0aW9uc1xuXG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjZFXCIsIFwiXFxcXG5sZXNzXCIsIHRydWUpOyAvLyBTeW1ib2wgbmFtZXMgcHJlY2VlZGVkIGJ5IFwiQFwiIGVhY2ggaGF2ZSBhIGNvcnJlc3BvbmRpbmcgbWFjcm8uXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdUUwMTBcIiwgXCJcXFxcQG5sZXFzbGFudFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdUUwMTFcIiwgXCJcXFxcQG5sZXFxXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MkE4N1wiLCBcIlxcXFxsbmVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2OFwiLCBcIlxcXFxsbmVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdUUwMENcIiwgXCJcXFxcQGx2ZXJ0bmVxcVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyRTZcIiwgXCJcXFxcbG5zaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyQTg5XCIsIFwiXFxcXGxuYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjI4MFwiLCBcIlxcXFxucHJlY1wiLCB0cnVlKTsgLy8gdW5pY29kZS1tYXRoIG1hcHMgXFx1MjJlMCB0byBcXG5wcmVjY3VybHllcS4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJFMFwiLCBcIlxcXFxucHJlY2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJFOFwiLCBcIlxcXFxwcmVjbnNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTJBQjlcIiwgXCJcXFxccHJlY25hcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjQxXCIsIFwiXFxcXG5zaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHVFMDA2XCIsIFwiXFxcXEBuc2hvcnRtaWRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjI0XCIsIFwiXFxcXG5taWRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMkFDXCIsIFwiXFxcXG52ZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyQURcIiwgXCJcXFxcbnZEYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJFQVwiLCBcIlxcXFxudHJpYW5nbGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJFQ1wiLCBcIlxcXFxudHJpYW5nbGVsZWZ0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjhBXCIsIFwiXFxcXHN1YnNldG5lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdUUwMUFcIiwgXCJcXFxcQHZhcnN1YnNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTJBQ0JcIiwgXCJcXFxcc3Vic2V0bmVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdUUwMTdcIiwgXCJcXFxcQHZhcnN1YnNldG5lcXFcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjZGXCIsIFwiXFxcXG5ndHJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHVFMDBGXCIsIFwiXFxcXEBuZ2Vxc2xhbnRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHVFMDBFXCIsIFwiXFxcXEBuZ2VxcVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTJBODhcIiwgXCJcXFxcZ25lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyNjlcIiwgXCJcXFxcZ25lcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHVFMDBEXCIsIFwiXFxcXEBndmVydG5lcXFcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMkU3XCIsIFwiXFxcXGduc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MkE4QVwiLCBcIlxcXFxnbmFwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyODFcIiwgXCJcXFxcbnN1Y2NcIiwgdHJ1ZSk7IC8vIHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIyZTEgdG8gXFxuc3VjY2N1cmx5ZXEuIFdlJ2xsIHVzZSB0aGUgQU1TIHN5bm9ueW0uXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyRTFcIiwgXCJcXFxcbnN1Y2NlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyRTlcIiwgXCJcXFxcc3VjY25zaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyQUJBXCIsIFwiXFxcXHN1Y2NuYXBwcm94XCIsIHRydWUpOyAvLyB1bmljb2RlLW1hdGggbWFwcyBcXHUyMjQ2IHRvIFxcc2ltbmVxcS4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0NlwiLCBcIlxcXFxuY29uZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdUUwMDdcIiwgXCJcXFxcQG5zaG9ydHBhcmFsbGVsXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjIyNlwiLCBcIlxcXFxucGFyYWxsZWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMkFGXCIsIFwiXFxcXG5WRGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyRUJcIiwgXCJcXFxcbnRyaWFuZ2xlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMkVEXCIsIFwiXFxcXG50cmlhbmdsZXJpZ2h0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHVFMDE4XCIsIFwiXFxcXEBuc3Vwc2V0ZXFxXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjI4QlwiLCBcIlxcXFxzdXBzZXRuZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHVFMDFCXCIsIFwiXFxcXEB2YXJzdXBzZXRuZXFcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyQUNDXCIsIFwiXFxcXHN1cHNldG5lcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHVFMDE5XCIsIFwiXFxcXEB2YXJzdXBzZXRuZXFxXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJBRVwiLCBcIlxcXFxuVmRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyQUI1XCIsIFwiXFxcXHByZWNuZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MkFCNlwiLCBcIlxcXFxzdWNjbmVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdUUwMTZcIiwgXCJcXFxcQG5zdWJzZXRlcXFcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIGJpbiwgXCJcXHUyMkI0XCIsIFwiXFxcXHVubGhkXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJCNVwiLCBcIlxcXFx1bnJoZFwiKTsgLy8gQU1TIE5lZ2F0ZWQgQXJyb3dzXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxOUFcIiwgXCJcXFxcbmxlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxOUJcIiwgXCJcXFxcbnJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUNEXCIsIFwiXFxcXG5MZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUNGXCIsIFwiXFxcXG5SaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjFBRVwiLCBcIlxcXFxubGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUNFXCIsIFwiXFxcXG5MZWZ0cmlnaHRhcnJvd1wiLCB0cnVlKTsgLy8gQU1TIE1pc2NcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjVCM1wiLCBcIlxcXFx2YXJ0cmlhbmdsZVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIxMEZcIiwgXCJcXFxcaHNsYXNoXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjVCRFwiLCBcIlxcXFx0cmlhbmdsZWRvd25cIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNUNBXCIsIFwiXFxcXGxvemVuZ2VcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNEM4XCIsIFwiXFxcXGNpcmNsZWRTXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx4QUVcIiwgXCJcXFxcY2lyY2xlZFJcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHhBRVwiLCBcIlxcXFxjaXJjbGVkUlwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIyMjFcIiwgXCJcXFxcbWVhc3VyZWRhbmdsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIyMDRcIiwgXCJcXFxcbmV4aXN0c1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIxMjdcIiwgXCJcXFxcbWhvXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjEzMlwiLCBcIlxcXFxGaW52XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjE0MVwiLCBcIlxcXFxHYW1lXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjAzNVwiLCBcIlxcXFxiYWNrcHJpbWVcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNUIyXCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNUJDXCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVkb3duXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjVBMFwiLCBcIlxcXFxibGFja3NxdWFyZVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTI5RUJcIiwgXCJcXFxcYmxhY2tsb3plbmdlXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjYwNVwiLCBcIlxcXFxiaWdzdGFyXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjIyMlwiLCBcIlxcXFxzcGhlcmljYWxhbmdsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIyMDFcIiwgXCJcXFxcY29tcGxlbWVudFwiLCB0cnVlKTsgLy8gdW5pY29kZS1tYXRoIG1hcHMgVStGMCAow7ApIHRvIFxcbWF0aGV0aC4gV2UgbWFwIHRvIEFNUyBmdW5jdGlvbiBcXGV0aFxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHhGMFwiLCBcIlxcXFxldGhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNTcxXCIsIFwiXFxcXGRpYWd1cFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTI1NzJcIiwgXCJcXFxcZGlhZ2Rvd25cIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNUExXCIsIFwiXFxcXHNxdWFyZVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTI1QTFcIiwgXCJcXFxcQm94XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjVDQVwiLCBcIlxcXFxEaWFtb25kXCIpOyAvLyB1bmljb2RlLW1hdGggbWFwcyBVK0E1IHRvIFxcbWF0aHllbi4gV2UgbWFwIHRvIEFNUyBmdW5jdGlvbiBcXHllblxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHhBNVwiLCBcIlxcXFx5ZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHhBNVwiLCBcIlxcXFx5ZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNzEzXCIsIFwiXFxcXGNoZWNrbWFya1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTI3MTNcIiwgXCJcXFxcY2hlY2ttYXJrXCIpOyAvLyBBTVMgSGVicmV3XG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIxMzZcIiwgXCJcXFxcYmV0aFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIxMzhcIiwgXCJcXFxcZGFsZXRoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjEzN1wiLCBcIlxcXFxnaW1lbFwiLCB0cnVlKTsgLy8gQU1TIEdyZWVrXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTAzRERcIiwgXCJcXFxcZGlnYW1tYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTAzRjBcIiwgXCJcXFxcdmFya2FwcGFcIik7IC8vIEFNUyBEZWxpbWl0ZXJzXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc19vcGVuLCBcIlxcdTI1MENcIiwgXCJcXFxcdWxjb3JuZXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfY2xvc2UsIFwiXFx1MjUxMFwiLCBcIlxcXFx1cmNvcm5lclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc19vcGVuLCBcIlxcdTI1MTRcIiwgXCJcXFxcbGxjb3JuZXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfY2xvc2UsIFwiXFx1MjUxOFwiLCBcIlxcXFxscmNvcm5lclwiLCB0cnVlKTsgLy8gQU1TIEJpbmFyeSBSZWxhdGlvbnNcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2NlwiLCBcIlxcXFxsZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MkE3RFwiLCBcIlxcXFxsZXFzbGFudFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTJBOTVcIiwgXCJcXFxcZXFzbGFudGxlc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjcyXCIsIFwiXFxcXGxlc3NzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyQTg1XCIsIFwiXFxcXGxlc3NhcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjRBXCIsIFwiXFxcXGFwcHJveGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJENlwiLCBcIlxcXFxsZXNzZG90XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJEOFwiLCBcIlxcXFxsbGxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjc2XCIsIFwiXFxcXGxlc3NndHJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMkRBXCIsIFwiXFxcXGxlc3NlcWd0clwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTJBOEJcIiwgXCJcXFxcbGVzc2VxcWd0clwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyNTFcIiwgXCJcXFxcZG90ZXFkb3RcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjUzXCIsIFwiXFxcXHJpc2luZ2RvdHNlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyNTJcIiwgXCJcXFxcZmFsbGluZ2RvdHNlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyM0RcIiwgXCJcXFxcYmFja3NpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyQ0RcIiwgXCJcXFxcYmFja3NpbWVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MkFDNVwiLCBcIlxcXFxzdWJzZXRlcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMkQwXCIsIFwiXFxcXFN1YnNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyOEZcIiwgXCJcXFxcc3FzdWJzZXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjdDXCIsIFwiXFxcXHByZWNjdXJseWVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJERVwiLCBcIlxcXFxjdXJseWVxcHJlY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyN0VcIiwgXCJcXFxccHJlY3NpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTJBQjdcIiwgXCJcXFxccHJlY2FwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyQjJcIiwgXCJcXFxcdmFydHJpYW5nbGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJCNFwiLCBcIlxcXFx0cmlhbmdsZWxlZnRlcVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyQThcIiwgXCJcXFxcdkRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMkFBXCIsIFwiXFxcXFZ2ZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIzMjNcIiwgXCJcXFxcc21hbGxzbWlsZVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIzMjJcIiwgXCJcXFxcc21hbGxmcm93blwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyNEZcIiwgXCJcXFxcYnVtcGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0RVwiLCBcIlxcXFxCdW1wZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjY3XCIsIFwiXFxcXGdlcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyQTdFXCIsIFwiXFxcXGdlcXNsYW50XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MkE5NlwiLCBcIlxcXFxlcXNsYW50Z3RyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjI3M1wiLCBcIlxcXFxndHJzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyQTg2XCIsIFwiXFxcXGd0cmFwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyRDdcIiwgXCJcXFxcZ3RyZG90XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJEOVwiLCBcIlxcXFxnZ2dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjc3XCIsIFwiXFxcXGd0cmxlc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMkRCXCIsIFwiXFxcXGd0cmVxbGVzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTJBOENcIiwgXCJcXFxcZ3RyZXFxbGVzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyNTZcIiwgXCJcXFxcZXFjaXJjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1N1wiLCBcIlxcXFxjaXJjZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjVDXCIsIFwiXFxcXHRyaWFuZ2xlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyM0NcIiwgXCJcXFxcdGhpY2tzaW1cIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjQ4XCIsIFwiXFxcXHRoaWNrYXBwcm94XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MkFDNlwiLCBcIlxcXFxzdXBzZXRlcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMkQxXCIsIFwiXFxcXFN1cHNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyOTBcIiwgXCJcXFxcc3FzdXBzZXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjdEXCIsIFwiXFxcXHN1Y2NjdXJseWVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJERlwiLCBcIlxcXFxjdXJseWVxc3VjY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyN0ZcIiwgXCJcXFxcc3VjY3NpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTJBQjhcIiwgXCJcXFxcc3VjY2FwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyQjNcIiwgXCJcXFxcdmFydHJpYW5nbGVyaWdodFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyQjVcIiwgXCJcXFxcdHJpYW5nbGVyaWdodGVxXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJBOVwiLCBcIlxcXFxWZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyMjNcIiwgXCJcXFxcc2hvcnRtaWRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjI1XCIsIFwiXFxcXHNob3J0cGFyYWxsZWxcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjZDXCIsIFwiXFxcXGJldHdlZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMkQ0XCIsIFwiXFxcXHBpdGNoZm9ya1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyMURcIiwgXCJcXFxcdmFycHJvcHRvXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjVDMFwiLCBcIlxcXFxibGFja3RyaWFuZ2xlbGVmdFwiKTsgLy8gdW5pY29kZS1tYXRoIHNheXMgdGhhdCBcXHRoZXJlZm9yZSBpcyBhIG1hdGhvcmQgYXRvbS5cbi8vIFdlIGtlcHQgdGhlIGFtc3N5bWIgYXRvbSB0eXBlLCB3aGljaCBpcyByZWwuXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyMzRcIiwgXCJcXFxcdGhlcmVmb3JlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjIwRFwiLCBcIlxcXFxiYWNrZXBzaWxvblwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTI1QjZcIiwgXCJcXFxcYmxhY2t0cmlhbmdsZXJpZ2h0XCIpOyAvLyB1bmljb2RlLW1hdGggc2F5cyB0aGF0IFxcYmVjYXVzZSBpcyBhIG1hdGhvcmQgYXRvbS5cbi8vIFdlIGtlcHQgdGhlIGFtc3N5bWIgYXRvbSB0eXBlLCB3aGljaCBpcyByZWwuXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyMzVcIiwgXCJcXFxcYmVjYXVzZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyRDhcIiwgXCJcXFxcbGxsZXNzXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJEOVwiLCBcIlxcXFxnZ2d0clwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyQjJcIiwgXCJcXFxcbGhkXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJCM1wiLCBcIlxcXFxyaGRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjQyXCIsIFwiXFxcXGVxc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyQzhcIiwgXCJcXFxcSm9pblwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyNTFcIiwgXCJcXFxcRG90ZXFcIiwgdHJ1ZSk7IC8vIEFNUyBCaW5hcnkgT3BlcmF0b3JzXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyMTRcIiwgXCJcXFxcZG90cGx1c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyMTZcIiwgXCJcXFxcc21hbGxzZXRtaW51c1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyRDJcIiwgXCJcXFxcQ2FwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJEM1wiLCBcIlxcXFxDdXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIGJpbiwgXCJcXHUyQTVFXCIsIFwiXFxcXGRvdWJsZWJhcndlZGdlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5RlwiLCBcIlxcXFxib3htaW51c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyOUVcIiwgXCJcXFxcYm94cGx1c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyQzdcIiwgXCJcXFxcZGl2aWRlb250aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyQzlcIiwgXCJcXFxcbHRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJDQVwiLCBcIlxcXFxydGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIGJpbiwgXCJcXHUyMkNCXCIsIFwiXFxcXGxlZnR0aHJlZXRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJDQ1wiLCBcIlxcXFxyaWdodHRocmVldGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIGJpbiwgXCJcXHUyMkNGXCIsIFwiXFxcXGN1cmx5d2VkZ2VcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIGJpbiwgXCJcXHUyMkNFXCIsIFwiXFxcXGN1cmx5dmVlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5RFwiLCBcIlxcXFxjaXJjbGVkZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyOUJcIiwgXCJcXFxcY2lyY2xlZGFzdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyQzVcIiwgXCJcXFxcY2VudGVyZG90XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJCQVwiLCBcIlxcXFxpbnRlcmNhbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyRDJcIiwgXCJcXFxcZG91YmxlY2FwXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJEM1wiLCBcIlxcXFxkb3VibGVjdXBcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIGJpbiwgXCJcXHUyMkEwXCIsIFwiXFxcXGJveHRpbWVzXCIsIHRydWUpOyAvLyBBTVMgQXJyb3dzXG4vLyBOb3RlOiB1bmljb2RlLW1hdGggbWFwcyBcXHUyMWUyIHRvIHRoZWlyIG93biBmdW5jdGlvbiBcXHJpZ2h0ZGFzaGFycm93LlxuLy8gV2UnbGwgbWFwIGl0IHRvIEFNUyBmdW5jdGlvbiBcXGRhc2hyaWdodGFycm93LiBJdCBwcm9kdWNlcyB0aGUgc2FtZSBhdG9tLlxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUUyXCIsIFwiXFxcXGRhc2hyaWdodGFycm93XCIsIHRydWUpOyAvLyB1bmljb2RlLW1hdGggbWFwcyBcXHUyMWUwIHRvIFxcbGVmdGRhc2hhcnJvdy4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjFFMFwiLCBcIlxcXFxkYXNobGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjFDN1wiLCBcIlxcXFxsZWZ0bGVmdGFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxQzZcIiwgXCJcXFxcbGVmdHJpZ2h0YXJyb3dzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjFEQVwiLCBcIlxcXFxMbGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjE5RVwiLCBcIlxcXFx0d29oZWFkbGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjFBMlwiLCBcIlxcXFxsZWZ0YXJyb3d0YWlsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjFBQlwiLCBcIlxcXFxsb29wYXJyb3dsZWZ0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjFDQlwiLCBcIlxcXFxsZWZ0cmlnaHRoYXJwb29uc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxQjZcIiwgXCJcXFxcY3VydmVhcnJvd2xlZnRcIiwgdHJ1ZSk7IC8vIHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIxYmEgdG8gXFxhY3dvcGVuY2lyY2xlYXJyb3cuIFdlJ2xsIHVzZSB0aGUgQU1TIHN5bm9ueW0uXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxQkFcIiwgXCJcXFxcY2lyY2xlYXJyb3dsZWZ0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjFCMFwiLCBcIlxcXFxMc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUM4XCIsIFwiXFxcXHVwdXBhcnJvd3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUJGXCIsIFwiXFxcXHVwaGFycG9vbmxlZnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUMzXCIsIFwiXFxcXGRvd25oYXJwb29ubGVmdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyQjhcIiwgXCJcXFxcbXVsdGltYXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUFEXCIsIFwiXFxcXGxlZnRyaWdodHNxdWlnYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUM5XCIsIFwiXFxcXHJpZ2h0cmlnaHRhcnJvd3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUM0XCIsIFwiXFxcXHJpZ2h0bGVmdGFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxQTBcIiwgXCJcXFxcdHdvaGVhZHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUEzXCIsIFwiXFxcXHJpZ2h0YXJyb3d0YWlsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjFBQ1wiLCBcIlxcXFxsb29wYXJyb3dyaWdodFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxQjdcIiwgXCJcXFxcY3VydmVhcnJvd3JpZ2h0XCIsIHRydWUpOyAvLyB1bmljb2RlLW1hdGggbWFwcyBcXHUyMWJiIHRvIFxcY3dvcGVuY2lyY2xlYXJyb3cuIFdlJ2xsIHVzZSB0aGUgQU1TIHN5bm9ueW0uXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxQkJcIiwgXCJcXFxcY2lyY2xlYXJyb3dyaWdodFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxQjFcIiwgXCJcXFxcUnNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjFDQVwiLCBcIlxcXFxkb3duZG93bmFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxQkVcIiwgXCJcXFxcdXBoYXJwb29ucmlnaHRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUMyXCIsIFwiXFxcXGRvd25oYXJwb29ucmlnaHRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUREXCIsIFwiXFxcXHJpZ2h0c3F1aWdhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxRERcIiwgXCJcXFxcbGVhZHN0b1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxREJcIiwgXCJcXFxcUnJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUJFXCIsIFwiXFxcXHJlc3RyaWN0aW9uXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIwMThcIiwgXCJgXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIiRcIiwgXCJcXFxcJFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCIkXCIsIFwiXFxcXCRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiJFwiLCBcIlxcXFx0ZXh0ZG9sbGFyXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIiVcIiwgXCJcXFxcJVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCIlXCIsIFwiXFxcXCVcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiX1wiLCBcIlxcXFxfXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIl9cIiwgXCJcXFxcX1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJfXCIsIFwiXFxcXHRleHR1bmRlcnNjb3JlXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIyMjBcIiwgXCJcXFxcYW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjIxRVwiLCBcIlxcXFxpbmZ0eVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyMDMyXCIsIFwiXFxcXHByaW1lXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTI1QjNcIiwgXCJcXFxcdHJpYW5nbGVcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MDM5M1wiLCBcIlxcXFxHYW1tYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUwMzk0XCIsIFwiXFxcXERlbHRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTAzOThcIiwgXCJcXFxcVGhldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MDM5QlwiLCBcIlxcXFxMYW1iZGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MDM5RVwiLCBcIlxcXFxYaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUwM0EwXCIsIFwiXFxcXFBpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTAzQTNcIiwgXCJcXFxcU2lnbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MDNBNVwiLCBcIlxcXFxVcHNpbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTAzQTZcIiwgXCJcXFxcUGhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTAzQThcIiwgXCJcXFxcUHNpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTAzQTlcIiwgXCJcXFxcT21lZ2FcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiQVwiLCBcIlxcdTAzOTFcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiQlwiLCBcIlxcdTAzOTJcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiRVwiLCBcIlxcdTAzOTVcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiWlwiLCBcIlxcdTAzOTZcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiSFwiLCBcIlxcdTAzOTdcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiSVwiLCBcIlxcdTAzOTlcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiS1wiLCBcIlxcdTAzOUFcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiTVwiLCBcIlxcdTAzOUNcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiTlwiLCBcIlxcdTAzOURcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiT1wiLCBcIlxcdTAzOUZcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiUFwiLCBcIlxcdTAzQTFcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiVFwiLCBcIlxcdTAzQTRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiWFwiLCBcIlxcdTAzQTdcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx4QUNcIiwgXCJcXFxcbmVnXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxceEFDXCIsIFwiXFxcXGxub3RcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjJBNFwiLCBcIlxcXFx0b3BcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjJBNVwiLCBcIlxcXFxib3RcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjIwNVwiLCBcIlxcXFxlbXB0eXNldFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIyMDVcIiwgXCJcXFxcdmFybm90aGluZ1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNCMVwiLCBcIlxcXFxhbHBoYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNCMlwiLCBcIlxcXFxiZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM0IzXCIsIFwiXFxcXGdhbW1hXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM0I0XCIsIFwiXFxcXGRlbHRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM0Y1XCIsIFwiXFxcXGVwc2lsb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQjZcIiwgXCJcXFxcemV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNCN1wiLCBcIlxcXFxldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQjhcIiwgXCJcXFxcdGhldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQjlcIiwgXCJcXFxcaW90YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNCQVwiLCBcIlxcXFxrYXBwYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNCQlwiLCBcIlxcXFxsYW1iZGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQkNcIiwgXCJcXFxcbXVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQkRcIiwgXCJcXFxcbnVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQkVcIiwgXCJcXFxceGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQkZcIiwgXCJcXFxcb21pY3JvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNDMFwiLCBcIlxcXFxwaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNDMVwiLCBcIlxcXFxyaG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQzNcIiwgXCJcXFxcc2lnbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQzRcIiwgXCJcXFxcdGF1XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM0M1XCIsIFwiXFxcXHVwc2lsb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzRDVcIiwgXCJcXFxccGhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM0M3XCIsIFwiXFxcXGNoaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNDOFwiLCBcIlxcXFxwc2lcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQzlcIiwgXCJcXFxcb21lZ2FcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQjVcIiwgXCJcXFxcdmFyZXBzaWxvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNEMVwiLCBcIlxcXFx2YXJ0aGV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNENlwiLCBcIlxcXFx2YXJwaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNGMVwiLCBcIlxcXFx2YXJyaG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQzJcIiwgXCJcXFxcdmFyc2lnbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQzZcIiwgXCJcXFxcdmFycGhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMTdcIiwgXCIqXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIitcIiwgXCIrXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMTJcIiwgXCItXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyQzVcIiwgXCJcXFxcY2RvdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE4XCIsIFwiXFxcXGNpcmNcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBiaW4sIFwiXFx4RjdcIiwgXCJcXFxcZGl2XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxceEIxXCIsIFwiXFxcXHBtXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxceEQ3XCIsIFwiXFxcXHRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjlcIiwgXCJcXFxcY2FwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMkFcIiwgXCJcXFxcY3VwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMTZcIiwgXCJcXFxcc2V0bWludXNcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIyN1wiLCBcIlxcXFxsYW5kXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjhcIiwgXCJcXFxcbG9yXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjdcIiwgXCJcXFxcd2VkZ2VcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIyOFwiLCBcIlxcXFx2ZWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjIxQVwiLCBcIlxcXFxzdXJkXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19vcGVuLCBcIihcIiwgXCIoXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19vcGVuLCBcIltcIiwgXCJbXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19vcGVuLCBcIlxcdTI3RThcIiwgXCJcXFxcbGFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19vcGVuLCBcIlxcdTIyMjNcIiwgXCJcXFxcbHZlcnRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX29wZW4sIFwiXFx1MjIyNVwiLCBcIlxcXFxsVmVydFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfY2xvc2UsIFwiKVwiLCBcIilcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX2Nsb3NlLCBcIl1cIiwgXCJdXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19jbG9zZSwgXCI/XCIsIFwiP1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfY2xvc2UsIFwiIVwiLCBcIiFcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX2Nsb3NlLCBcIlxcdTI3RTlcIiwgXCJcXFxccmFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19jbG9zZSwgXCJcXHUyMjIzXCIsIFwiXFxcXHJ2ZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19jbG9zZSwgXCJcXHUyMjI1XCIsIFwiXFxcXHJWZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIj1cIiwgXCI9XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIjxcIiwgXCI8XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIj5cIiwgXCI+XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIjpcIiwgXCI6XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNDhcIiwgXCJcXFxcYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNDVcIiwgXCJcXFxcY29uZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjY1XCIsIFwiXFxcXGdlXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNjVcIiwgXCJcXFxcZ2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTBcIiwgXCJcXFxcZ2V0c1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCI+XCIsIFwiXFxcXGd0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyMDhcIiwgXCJcXFxcaW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1RTAyMFwiLCBcIlxcXFxAbm90XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyODJcIiwgXCJcXFxcc3Vic2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyODNcIiwgXCJcXFxcc3Vwc2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyODZcIiwgXCJcXFxcc3Vic2V0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjI4N1wiLCBcIlxcXFxzdXBzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyODhcIiwgXCJcXFxcbnN1YnNldGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjI4OVwiLCBcIlxcXFxuc3Vwc2V0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjJBOFwiLCBcIlxcXFxtb2RlbHNcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5MFwiLCBcIlxcXFxsZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2NFwiLCBcIlxcXFxsZVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjY0XCIsIFwiXFxcXGxlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCI8XCIsIFwiXFxcXGx0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTJcIiwgXCJcXFxccmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTkyXCIsIFwiXFxcXHRvXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjI3MVwiLCBcIlxcXFxuZ2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjI3MFwiLCBcIlxcXFxubGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19zcGFjaW5nLCBcIlxceEEwXCIsIFwiXFxcXCBcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3NwYWNpbmcsIFwiXFx4QTBcIiwgXCJ+XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19zcGFjaW5nLCBcIlxceEEwXCIsIFwiXFxcXHNwYWNlXCIpOyAvLyBSZWY6IExhVGVYIFNvdXJjZSAyZTogXFxEZWNsYXJlUm9idXN0Q29tbWFuZHtcXG5vYnJlYWtzcGFjZX17JVxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3NwYWNpbmcsIFwiXFx4QTBcIiwgXCJcXFxcbm9icmVha3NwYWNlXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc19zcGFjaW5nLCBcIlxceEEwXCIsIFwiXFxcXCBcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3NwYWNpbmcsIFwiXFx4QTBcIiwgXCJ+XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc19zcGFjaW5nLCBcIlxceEEwXCIsIFwiXFxcXHNwYWNlXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc19zcGFjaW5nLCBcIlxceEEwXCIsIFwiXFxcXG5vYnJlYWtzcGFjZVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfc3BhY2luZywgbnVsbCwgXCJcXFxcbm9icmVha1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfc3BhY2luZywgbnVsbCwgXCJcXFxcYWxsb3dicmVha1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHB1bmN0LCBcIixcIiwgXCIsXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcHVuY3QsIFwiO1wiLCBcIjtcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIGJpbiwgXCJcXHUyMkJDXCIsIFwiXFxcXGJhcndlZGdlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJCQlwiLCBcIlxcXFx2ZWViYXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI5OVwiLCBcIlxcXFxvZG90XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTVcIiwgXCJcXFxcb3BsdXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI5N1wiLCBcIlxcXFxvdGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjIwMlwiLCBcIlxcXFxwYXJ0aWFsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOThcIiwgXCJcXFxcb3NsYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5QVwiLCBcIlxcXFxjaXJjbGVkY2lyY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyQTFcIiwgXCJcXFxcYm94ZG90XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1QjNcIiwgXCJcXFxcYmlndHJpYW5nbGV1cFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIGJpbiwgXCJcXHUyNUJEXCIsIFwiXFxcXGJpZ3RyaWFuZ2xlZG93blwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIGJpbiwgXCJcXHUyMDIwXCIsIFwiXFxcXGRhZ2dlclwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIGJpbiwgXCJcXHUyMkM0XCIsIFwiXFxcXGRpYW1vbmRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBiaW4sIFwiXFx1MjJDNlwiLCBcIlxcXFxzdGFyXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1QzNcIiwgXCJcXFxcdHJpYW5nbGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1QjlcIiwgXCJcXFxcdHJpYW5nbGVyaWdodFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfb3BlbiwgXCJ7XCIsIFwiXFxcXHtcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwie1wiLCBcIlxcXFx7XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIntcIiwgXCJcXFxcdGV4dGJyYWNlbGVmdFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfY2xvc2UsIFwifVwiLCBcIlxcXFx9XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIn1cIiwgXCJcXFxcfVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJ9XCIsIFwiXFxcXHRleHRicmFjZXJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19vcGVuLCBcIntcIiwgXCJcXFxcbGJyYWNlXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19jbG9zZSwgXCJ9XCIsIFwiXFxcXHJicmFjZVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfb3BlbiwgXCJbXCIsIFwiXFxcXGxicmFja1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJbXCIsIFwiXFxcXGxicmFja1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfY2xvc2UsIFwiXVwiLCBcIlxcXFxyYnJhY2tcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXVwiLCBcIlxcXFxyYnJhY2tcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX29wZW4sIFwiKFwiLCBcIlxcXFxscGFyZW5cIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX2Nsb3NlLCBcIilcIiwgXCJcXFxccnBhcmVuXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIjxcIiwgXCJcXFxcdGV4dGxlc3NcIik7IC8vIGluIFQxIGZvbnRlbmNcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIj5cIiwgXCJcXFxcdGV4dGdyZWF0ZXJcIik7IC8vIGluIFQxIGZvbnRlbmNcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19vcGVuLCBcIlxcdTIzMEFcIiwgXCJcXFxcbGZsb29yXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19jbG9zZSwgXCJcXHUyMzBCXCIsIFwiXFxcXHJmbG9vclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfb3BlbiwgXCJcXHUyMzA4XCIsIFwiXFxcXGxjZWlsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19jbG9zZSwgXCJcXHUyMzA5XCIsIFwiXFxcXHJjZWlsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcXFxcIiwgXCJcXFxcYmFja3NsYXNoXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIyMjNcIiwgXCJ8XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIyMjNcIiwgXCJcXFxcdmVydFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJ8XCIsIFwiXFxcXHRleHRiYXJcIik7IC8vIGluIFQxIGZvbnRlbmNcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIyMjVcIiwgXCJcXFxcfFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyMjI1XCIsIFwiXFxcXFZlcnRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjIyNVwiLCBcIlxcXFx0ZXh0YmFyZGJsXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIn5cIiwgXCJcXFxcdGV4dGFzY2lpdGlsZGVcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFxcXFwiLCBcIlxcXFx0ZXh0YmFja3NsYXNoXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIl5cIiwgXCJcXFxcdGV4dGFzY2lpY2lyY3VtXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTFcIiwgXCJcXFxcdXBhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMUQxXCIsIFwiXFxcXFVwYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5M1wiLCBcIlxcXFxkb3duYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjFEM1wiLCBcIlxcXFxEb3duYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5NVwiLCBcIlxcXFx1cGRvd25hcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMUQ1XCIsIFwiXFxcXFVwZG93bmFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgb3AsIFwiXFx1MjIxMFwiLCBcIlxcXFxjb3Byb2RcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBvcCwgXCJcXHUyMkMxXCIsIFwiXFxcXGJpZ3ZlZVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG9wLCBcIlxcdTIyQzBcIiwgXCJcXFxcYmlnd2VkZ2VcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBvcCwgXCJcXHUyQTA0XCIsIFwiXFxcXGJpZ3VwbHVzXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgb3AsIFwiXFx1MjJDMlwiLCBcIlxcXFxiaWdjYXBcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBvcCwgXCJcXHUyMkMzXCIsIFwiXFxcXGJpZ2N1cFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG9wLCBcIlxcdTIyMkJcIiwgXCJcXFxcaW50XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgb3AsIFwiXFx1MjIyQlwiLCBcIlxcXFxpbnRvcFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG9wLCBcIlxcdTIyMkNcIiwgXCJcXFxcaWludFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG9wLCBcIlxcdTIyMkRcIiwgXCJcXFxcaWlpbnRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBvcCwgXCJcXHUyMjBGXCIsIFwiXFxcXHByb2RcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBvcCwgXCJcXHUyMjExXCIsIFwiXFxcXHN1bVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG9wLCBcIlxcdTJBMDJcIiwgXCJcXFxcYmlnb3RpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgb3AsIFwiXFx1MkEwMVwiLCBcIlxcXFxiaWdvcGx1c1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG9wLCBcIlxcdTJBMDBcIiwgXCJcXFxcYmlnb2RvdFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG9wLCBcIlxcdTIyMkVcIiwgXCJcXFxcb2ludFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG9wLCBcIlxcdTIyMkZcIiwgXCJcXFxcb2lpbnRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBvcCwgXCJcXHUyMjMwXCIsIFwiXFxcXG9paWludFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG9wLCBcIlxcdTJBMDZcIiwgXCJcXFxcYmlnc3FjdXBcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBvcCwgXCJcXHUyMjJCXCIsIFwiXFxcXHNtYWxsaW50XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc19pbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXHRleHRlbGxpcHNpc1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfaW5uZXIsIFwiXFx1MjAyNlwiLCBcIlxcXFxtYXRoZWxsaXBzaXNcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX2lubmVyLCBcIlxcdTIwMjZcIiwgXCJcXFxcbGRvdHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX2lubmVyLCBcIlxcdTIwMjZcIiwgXCJcXFxcbGRvdHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX2lubmVyLCBcIlxcdTIyRUZcIiwgXCJcXFxcQGNkb3RzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19pbm5lciwgXCJcXHUyMkYxXCIsIFwiXFxcXGRkb3RzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIyRUVcIiwgXCJcXFxcdmFydmRvdHNcIik7IC8vIFxcdmRvdHMgaXMgYSBtYWNyb1xuXG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX2FjY2VudCwgXCJcXHUwMkNBXCIsIFwiXFxcXGFjdXRlXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19hY2NlbnQsIFwiXFx1MDJDQlwiLCBcIlxcXFxncmF2ZVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfYWNjZW50LCBcIlxceEE4XCIsIFwiXFxcXGRkb3RcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX2FjY2VudCwgXCJ+XCIsIFwiXFxcXHRpbGRlXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19hY2NlbnQsIFwiXFx1MDJDOVwiLCBcIlxcXFxiYXJcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX2FjY2VudCwgXCJcXHUwMkQ4XCIsIFwiXFxcXGJyZXZlXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19hY2NlbnQsIFwiXFx1MDJDN1wiLCBcIlxcXFxjaGVja1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfYWNjZW50LCBcIl5cIiwgXCJcXFxcaGF0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19hY2NlbnQsIFwiXFx1MjBEN1wiLCBcIlxcXFx2ZWNcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX2FjY2VudCwgXCJcXHUwMkQ5XCIsIFwiXFxcXGRvdFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfYWNjZW50LCBcIlxcdTAyREFcIiwgXCJcXFxcbWF0aHJpbmdcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAxMzFcIiwgXCJcXFxcaW1hdGhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAyMzdcIiwgXCJcXFxcam1hdGhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MDEzMVwiLCBcIlxcXFxpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTAyMzdcIiwgXCJcXFxcalwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHhERlwiLCBcIlxcXFxzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHhFNlwiLCBcIlxcXFxhZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHhFNlwiLCBcIlxcXFxhZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUwMTUzXCIsIFwiXFxcXG9lXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxceEY4XCIsIFwiXFxcXG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx4QzZcIiwgXCJcXFxcQUVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MDE1MlwiLCBcIlxcXFxPRVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHhEOFwiLCBcIlxcXFxPXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc19hY2NlbnQsIFwiXFx1MDJDQVwiLCBcIlxcXFwnXCIpOyAvLyBhY3V0ZVxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX2FjY2VudCwgXCJcXHUwMkNCXCIsIFwiXFxcXGBcIik7IC8vIGdyYXZlXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfYWNjZW50LCBcIlxcdTAyQzZcIiwgXCJcXFxcXlwiKTsgLy8gY2lyY3VtZmxleFxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX2FjY2VudCwgXCJcXHUwMkRDXCIsIFwiXFxcXH5cIik7IC8vIHRpbGRlXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfYWNjZW50LCBcIlxcdTAyQzlcIiwgXCJcXFxcPVwiKTsgLy8gbWFjcm9uXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfYWNjZW50LCBcIlxcdTAyRDhcIiwgXCJcXFxcdVwiKTsgLy8gYnJldmVcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc19hY2NlbnQsIFwiXFx1MDJEOVwiLCBcIlxcXFwuXCIpOyAvLyBkb3QgYWJvdmVcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc19hY2NlbnQsIFwiXFx1MDJEQVwiLCBcIlxcXFxyXCIpOyAvLyByaW5nIGFib3ZlXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfYWNjZW50LCBcIlxcdTAyQzdcIiwgXCJcXFxcdlwiKTsgLy8gY2Fyb25cblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc19hY2NlbnQsIFwiXFx4QThcIiwgJ1xcXFxcIicpOyAvLyBkaWFyZXNpc1xuXG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX2FjY2VudCwgXCJcXHUwMkREXCIsIFwiXFxcXEhcIik7IC8vIGRvdWJsZSBhY3V0ZVxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX2FjY2VudCwgXCJcXHUyNUVGXCIsIFwiXFxcXHRleHRjaXJjbGVkXCIpOyAvLyBcXGJpZ2NpcmMgZ2x5cGhcbi8vIFRoZXNlIGxpZ2F0dXJlcyBhcmUgZGV0ZWN0ZWQgYW5kIGNyZWF0ZWQgaW4gUGFyc2VyLmpzJ3MgYGZvcm1MaWdhdHVyZXNgLlxuXG52YXIgbGlnYXR1cmVzID0ge1xuICBcIi0tXCI6IHRydWUsXG4gIFwiLS0tXCI6IHRydWUsXG4gIFwiYGBcIjogdHJ1ZSxcbiAgXCInJ1wiOiB0cnVlXG59O1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIwMTNcIiwgXCItLVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyMDEzXCIsIFwiXFxcXHRleHRlbmRhc2hcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjAxNFwiLCBcIi0tLVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyMDE0XCIsIFwiXFxcXHRleHRlbWRhc2hcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjAxOFwiLCBcImBcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjAxOFwiLCBcIlxcXFx0ZXh0cXVvdGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIwMTlcIiwgXCInXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIwMTlcIiwgXCJcXFxcdGV4dHF1b3RlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjAxQ1wiLCBcImBgXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIwMUNcIiwgXCJcXFxcdGV4dHF1b3RlZGJsbGVmdFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyMDFEXCIsIFwiJydcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjAxRFwiLCBcIlxcXFx0ZXh0cXVvdGVkYmxyaWdodFwiKTsgLy8gIFxcZGVncmVlIGZyb20gZ2Vuc3ltYiBwYWNrYWdlXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHhCMFwiLCBcIlxcXFxkZWdyZWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx4QjBcIiwgXCJcXFxcZGVncmVlXCIpOyAvLyBcXHRleHRkZWdyZWUgZnJvbSBpbnB1dGVuYyBwYWNrYWdlXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHhCMFwiLCBcIlxcXFx0ZXh0ZGVncmVlXCIsIHRydWUpOyAvLyBUT0RPOiBJbiBMYVRlWCwgXFxwb3VuZHMgY2FuIGdlbmVyYXRlIGEgZGlmZmVyZW50IGNoYXJhY3RlciBpbiB0ZXh0IGFuZCBtYXRoXG4vLyBtb2RlLCBidXQgYW1vbmcgb3VyIGZvbnRzLCBvbmx5IE1haW4tSXRhbGljIGRlZmluZXMgdGhpcyBjaGFyYWN0ZXIgXCIxNjNcIi5cblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHhBM1wiLCBcIlxcXFxwb3VuZHNcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxceEEzXCIsIFwiXFxcXG1hdGhzdGVybGluZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIG1hdGhvcmQsIFwiXFx4QTNcIiwgXCJcXFxccG91bmRzXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgbWF0aG9yZCwgXCJcXHhBM1wiLCBcIlxcXFx0ZXh0c3RlcmxpbmdcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNzIwXCIsIFwiXFxcXG1hbHRlc2VcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNzIwXCIsIFwiXFxcXG1hbHRlc2VcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3NwYWNpbmcsIFwiXFx4QTBcIiwgXCJcXFxcIFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfc3BhY2luZywgXCJcXHhBMFwiLCBcIiBcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3NwYWNpbmcsIFwiXFx4QTBcIiwgXCJ+XCIpOyAvLyBUaGVyZSBhcmUgbG90cyBvZiBzeW1ib2xzIHdoaWNoIGFyZSB0aGUgc2FtZSwgc28gd2UgYWRkIHRoZW0gaW4gYWZ0ZXJ3YXJkcy5cbi8vIEFsbCBvZiB0aGVzZSBhcmUgdGV4dG9yZHMgaW4gbWF0aCBtb2RlXG5cbnZhciBtYXRoVGV4dFN5bWJvbHMgPSBcIjAxMjM0NTY3ODkvQC5cXFwiXCI7XG5cbmZvciAodmFyIHN5bWJvbHNfaSA9IDA7IHN5bWJvbHNfaSA8IG1hdGhUZXh0U3ltYm9scy5sZW5ndGg7IHN5bWJvbHNfaSsrKSB7XG4gIHZhciBzeW1ib2xzX2NoID0gbWF0aFRleHRTeW1ib2xzLmNoYXJBdChzeW1ib2xzX2kpO1xuICBkZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIHN5bWJvbHNfY2gsIHN5bWJvbHNfY2gpO1xufSAvLyBBbGwgb2YgdGhlc2UgYXJlIHRleHRvcmRzIGluIHRleHQgbW9kZVxuXG5cbnZhciB0ZXh0U3ltYm9scyA9IFwiMDEyMzQ1Njc4OSFAKigpLT0rW108PnxcXFwiOzo/Ly4sXCI7XG5cbmZvciAodmFyIHNyY19zeW1ib2xzX2kgPSAwOyBzcmNfc3ltYm9sc19pIDwgdGV4dFN5bWJvbHMubGVuZ3RoOyBzcmNfc3ltYm9sc19pKyspIHtcbiAgdmFyIF9jaCA9IHRleHRTeW1ib2xzLmNoYXJBdChzcmNfc3ltYm9sc19pKTtcblxuICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIF9jaCwgX2NoKTtcbn0gLy8gQWxsIG9mIHRoZXNlIGFyZSB0ZXh0b3JkcyBpbiB0ZXh0IG1vZGUsIGFuZCBtYXRob3JkcyBpbiBtYXRoIG1vZGVcblxuXG52YXIgbGV0dGVycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiO1xuXG5mb3IgKHZhciBzeW1ib2xzX2kyID0gMDsgc3ltYm9sc19pMiA8IGxldHRlcnMubGVuZ3RoOyBzeW1ib2xzX2kyKyspIHtcbiAgdmFyIF9jaDIgPSBsZXR0ZXJzLmNoYXJBdChzeW1ib2xzX2kyKTtcblxuICBkZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBfY2gyLCBfY2gyKTtcbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBfY2gyLCBfY2gyKTtcbn0gLy8gQmxhY2tib2FyZCBib2xkIGFuZCBzY3JpcHQgbGV0dGVycyBpbiBVbmljb2RlIHJhbmdlXG5cblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiQ1wiLCBcIlxcdTIxMDJcIik7IC8vIGJsYWNrYm9hcmQgYm9sZFxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJDXCIsIFwiXFx1MjEwMlwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIkhcIiwgXCJcXHUyMTBEXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiSFwiLCBcIlxcdTIxMERcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJOXCIsIFwiXFx1MjExNVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIk5cIiwgXCJcXHUyMTE1XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiUFwiLCBcIlxcdTIxMTlcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJQXCIsIFwiXFx1MjExOVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlFcIiwgXCJcXHUyMTFBXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiUVwiLCBcIlxcdTIxMUFcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJSXCIsIFwiXFx1MjExRFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlJcIiwgXCJcXHUyMTFEXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiWlwiLCBcIlxcdTIxMjRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJaXCIsIFwiXFx1MjEyNFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiaFwiLCBcIlxcdTIxMEVcIik7IC8vIGl0YWxpYyBoLCBQbGFuY2sgY29uc3RhbnRcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgbWF0aG9yZCwgXCJoXCIsIFwiXFx1MjEwRVwiKTsgLy8gVGhlIG5leHQgbG9vcCBsb2FkcyB3aWRlIChzdXJyb2dhdGUgcGFpcikgY2hhcmFjdGVycy5cbi8vIFdlIHN1cHBvcnQgc29tZSBsZXR0ZXJzIGluIHRoZSBVbmljb2RlIHJhbmdlIFUrMUQ0MDAgdG8gVSsxRDdGRixcbi8vIE1hdGhlbWF0aWNhbCBBbHBoYW51bWVyaWMgU3ltYm9scy5cbi8vIFNvbWUgZWRpdG9ycyBkbyBub3QgZGVhbCB3ZWxsIHdpdGggd2lkZSBjaGFyYWN0ZXJzLiBTbyBkb24ndCB3cml0ZSB0aGVcbi8vIHN0cmluZyBpbnRvIHRoaXMgZmlsZS4gSW5zdGVhZCwgY3JlYXRlIHRoZSBzdHJpbmcgZnJvbSB0aGUgc3Vycm9nYXRlIHBhaXIuXG5cbnZhciBzeW1ib2xzX3dpZGVDaGFyID0gXCJcIjtcblxuZm9yICh2YXIgc3ltYm9sc19pMyA9IDA7IHN5bWJvbHNfaTMgPCBsZXR0ZXJzLmxlbmd0aDsgc3ltYm9sc19pMysrKSB7XG4gIHZhciBfY2gzID0gbGV0dGVycy5jaGFyQXQoc3ltYm9sc19pMyk7IC8vIFRoZSBoZXggbnVtYmVycyBpbiB0aGUgbmV4dCBsaW5lIGFyZSBhIHN1cnJvZ2F0ZSBwYWlyLlxuICAvLyAweEQ4MzUgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIGZvciBhbGwgbGV0dGVycyBpbiB0aGUgcmFuZ2Ugd2Ugc3VwcG9ydC5cbiAgLy8gMHhEQzAwIGlzIHRoZSBsb3cgc3Vycm9nYXRlIGZvciBib2xkIEEuXG5cblxuICBzeW1ib2xzX3dpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REMwMCArIHN5bWJvbHNfaTMpOyAvLyBBLVogYS16IGJvbGRcblxuICBkZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgc3ltYm9sc193aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERDMzQgKyBzeW1ib2xzX2kzKTsgLy8gQS1aIGEteiBpdGFsaWNcblxuICBkZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgc3ltYm9sc193aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERDNjggKyBzeW1ib2xzX2kzKTsgLy8gQS1aIGEteiBib2xkIGl0YWxpY1xuXG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIF9jaDMsIHN5bWJvbHNfd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIF9jaDMsIHN5bWJvbHNfd2lkZUNoYXIpO1xuICBzeW1ib2xzX3dpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REQwNCArIHN5bWJvbHNfaTMpOyAvLyBBLVogYS16IEZyYWN0dXJcblxuICBkZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgc3ltYm9sc193aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweEREQTAgKyBzeW1ib2xzX2kzKTsgLy8gQS1aIGEteiBzYW5zLXNlcmlmXG5cbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoMywgc3ltYm9sc193aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgX2NoMywgc3ltYm9sc193aWRlQ2hhcik7XG4gIHN5bWJvbHNfd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgzNSwgMHhEREQ0ICsgc3ltYm9sc19pMyk7IC8vIEEtWiBhLXogc2FucyBib2xkXG5cbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoMywgc3ltYm9sc193aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgX2NoMywgc3ltYm9sc193aWRlQ2hhcik7XG4gIHN5bWJvbHNfd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgzNSwgMHhERTA4ICsgc3ltYm9sc19pMyk7IC8vIEEtWiBhLXogc2FucyBpdGFsaWNcblxuICBkZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgc3ltYm9sc193aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERFNzAgKyBzeW1ib2xzX2kzKTsgLy8gQS1aIGEteiBtb25vc3BhY2VcblxuICBkZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcblxuICBpZiAoc3ltYm9sc19pMyA8IDI2KSB7XG4gICAgLy8gS2FUZVggZm9udHMgaGF2ZSBvbmx5IGNhcGl0YWwgbGV0dGVycyBmb3IgYmxhY2tib2FyZCBib2xkIGFuZCBzY3JpcHQuXG4gICAgLy8gU2VlIGV4Y2VwdGlvbiBmb3IgayBiZWxvdy5cbiAgICBzeW1ib2xzX3dpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REQzOCArIHN5bWJvbHNfaTMpOyAvLyBBLVogZG91YmxlIHN0cnVja1xuXG4gICAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoMywgc3ltYm9sc193aWRlQ2hhcik7XG4gICAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgICBzeW1ib2xzX3dpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REM5QyArIHN5bWJvbHNfaTMpOyAvLyBBLVogc2NyaXB0XG5cbiAgICBkZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIF9jaDMsIHN5bWJvbHNfd2lkZUNoYXIpO1xuICB9IC8vIFRPRE86IEFkZCBib2xkIHNjcmlwdCB3aGVuIGl0IGlzIHN1cHBvcnRlZCBieSBhIEthVGVYIGZvbnQuXG5cbn0gLy8gXCJrXCIgaXMgdGhlIG9ubHkgZG91YmxlIHN0cnVjayBsb3dlciBjYXNlIGxldHRlciBpbiB0aGUgS2FUZVggZm9udHMuXG5cblxuc3ltYm9sc193aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERENUMpOyAvLyBrIGRvdWJsZSBzdHJ1Y2tcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJrXCIsIHN5bWJvbHNfd2lkZUNoYXIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcImtcIiwgc3ltYm9sc193aWRlQ2hhcik7IC8vIE5leHQsIHNvbWUgd2lkZSBjaGFyYWN0ZXIgbnVtZXJhbHNcblxuZm9yICh2YXIgc3ltYm9sc19pNCA9IDA7IHN5bWJvbHNfaTQgPCAxMDsgc3ltYm9sc19pNCsrKSB7XG4gIHZhciBfY2g0ID0gc3ltYm9sc19pNC50b1N0cmluZygpO1xuXG4gIHN5bWJvbHNfd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgzNSwgMHhERkNFICsgc3ltYm9sc19pNCk7IC8vIDAtOSBib2xkXG5cbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoNCwgc3ltYm9sc193aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgX2NoNCwgc3ltYm9sc193aWRlQ2hhcik7XG4gIHN5bWJvbHNfd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgzNSwgMHhERkUyICsgc3ltYm9sc19pNCk7IC8vIDAtOSBzYW5zIHNlcmlmXG5cbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoNCwgc3ltYm9sc193aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgX2NoNCwgc3ltYm9sc193aWRlQ2hhcik7XG4gIHN5bWJvbHNfd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgzNSwgMHhERkVDICsgc3ltYm9sc19pNCk7IC8vIDAtOSBib2xkIHNhbnNcblxuICBkZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBfY2g0LCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBfY2g0LCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgc3ltYm9sc193aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERGRjYgKyBzeW1ib2xzX2k0KTsgLy8gMC05IG1vbm9zcGFjZVxuXG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIF9jaDQsIHN5bWJvbHNfd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIF9jaDQsIHN5bWJvbHNfd2lkZUNoYXIpO1xufSAvLyBXZSBhZGQgdGhlc2UgTGF0aW4tMSBsZXR0ZXJzIGFzIHN5bWJvbHMgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LFxuLy8gYnV0IHRoZXkgYXJlIG5vdCBhY3R1YWxseSBpbiB0aGUgZm9udCwgbm9yIGFyZSB0aGV5IHN1cHBvcnRlZCBieSB0aGVcbi8vIFVuaWNvZGUgYWNjZW50IG1lY2hhbmlzbSwgc28gdGhleSBmYWxsIGJhY2sgdG8gVGltZXMgZm9udCBhbmQgbG9vayB1Z2x5LlxuLy8gVE9ETyhlZGVtYWluZSk6IEZpeCB0aGlzLlxuXG5cbnZhciBleHRyYUxhdGluID0gXCLDh8OQw57Dp8O+XCI7XG5cbmZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGV4dHJhTGF0aW4ubGVuZ3RoOyBfaTUrKykge1xuICB2YXIgX2NoNSA9IGV4dHJhTGF0aW4uY2hhckF0KF9pNSk7XG5cbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoNSwgX2NoNSk7XG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgX2NoNSwgX2NoNSk7XG59XG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCLDsFwiLCBcIsOwXCIpOyAvLyBVbmljb2RlIHZlcnNpb25zIG9mIGV4aXN0aW5nIGNoYXJhY3RlcnNcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIwMTNcIiwgXCLigJNcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjAxNFwiLCBcIuKAlFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyMDE4XCIsIFwi4oCYXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIwMTlcIiwgXCLigJlcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjAxQ1wiLCBcIuKAnFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyMDFEXCIsIFwi4oCdXCIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvd2lkZS1jaGFyYWN0ZXIuanNcbi8qKlxuICogVGhpcyBmaWxlIHByb3ZpZGVzIHN1cHBvcnQgZm9yIFVuaWNvZGUgcmFuZ2UgVSsxRDQwMCB0byBVKzFEN0ZGLFxuICogTWF0aGVtYXRpY2FsIEFscGhhbnVtZXJpYyBTeW1ib2xzLlxuICpcbiAqIEZ1bmN0aW9uIHdpZGVDaGFyYWN0ZXJGb250IHRha2VzIGEgd2lkZSBjaGFyYWN0ZXIgYXMgaW5wdXQgYW5kIHJldHVybnNcbiAqIHRoZSBmb250IGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byByZW5kZXIgaXQgcHJvcGVybHkuXG4gKi9cblxuLyoqXG4gKiBEYXRhIGJlbG93IGlzIGZyb20gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvY2hhcnRzL1BERi9VMUQ0MDAucGRmXG4gKiBUaGF0IGRvY3VtZW50IHNvcnRzIGNoYXJhY3RlcnMgaW50byBncm91cHMgYnkgZm9udCB0eXBlLCBzYXkgYm9sZCBvciBpdGFsaWMuXG4gKlxuICogSW4gdGhlIGFycmF5cyBiZWxvdywgZWFjaCBzdWJhcnJheSBjb25zaXN0cyB0aHJlZSBlbGVtZW50czpcbiAqICAgICAgKiBUaGUgQ1NTIGNsYXNzIG9mIHRoYXQgZ3JvdXAgd2hlbiBpbiBtYXRoIG1vZGUuXG4gKiAgICAgICogVGhlIENTUyBjbGFzcyBvZiB0aGF0IGdyb3VwIHdoZW4gaW4gdGV4dCBtb2RlLlxuICogICAgICAqIFRoZSBmb250IG5hbWUsIHNvIHRoYXQgS2FUZVggY2FuIGdldCBmb250IG1ldHJpY3MuXG4gKi9cblxudmFyIHdpZGVMYXRpbkxldHRlckRhdGEgPSBbW1wibWF0aGJmXCIsIFwidGV4dGJmXCIsIFwiTWFpbi1Cb2xkXCJdLCAvLyBBLVogYm9sZCB1cHJpZ2h0XG5bXCJtYXRoYmZcIiwgXCJ0ZXh0YmZcIiwgXCJNYWluLUJvbGRcIl0sIC8vIGEteiBib2xkIHVwcmlnaHRcbltcIm1hdGhkZWZhdWx0XCIsIFwidGV4dGl0XCIsIFwiTWF0aC1JdGFsaWNcIl0sIC8vIEEtWiBpdGFsaWNcbltcIm1hdGhkZWZhdWx0XCIsIFwidGV4dGl0XCIsIFwiTWF0aC1JdGFsaWNcIl0sIC8vIGEteiBpdGFsaWNcbltcImJvbGRzeW1ib2xcIiwgXCJib2xkc3ltYm9sXCIsIFwiTWFpbi1Cb2xkSXRhbGljXCJdLCAvLyBBLVogYm9sZCBpdGFsaWNcbltcImJvbGRzeW1ib2xcIiwgXCJib2xkc3ltYm9sXCIsIFwiTWFpbi1Cb2xkSXRhbGljXCJdLCAvLyBhLXogYm9sZCBpdGFsaWNcbi8vIE1hcCBmYW5jeSBBLVogbGV0dGVycyB0byBzY3JpcHQsIG5vdCBjYWxsaWdyYXBoaWMuXG4vLyBUaGlzIGFsaWducyB3aXRoIHVuaWNvZGUtbWF0aCBhbmQgbWF0aCBmb250cyAoZXhjZXB0IENhbWJyaWEgTWF0aCkuXG5bXCJtYXRoc2NyXCIsIFwidGV4dHNjclwiLCBcIlNjcmlwdC1SZWd1bGFyXCJdLCAvLyBBLVogc2NyaXB0XG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIGEteiBzY3JpcHQuICBObyBmb250XG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIEEtWiBib2xkIHNjcmlwdC4gTm8gZm9udFxuW1wiXCIsIFwiXCIsIFwiXCJdLCAvLyBhLXogYm9sZCBzY3JpcHQuIE5vIGZvbnRcbltcIm1hdGhmcmFrXCIsIFwidGV4dGZyYWtcIiwgXCJGcmFrdHVyLVJlZ3VsYXJcIl0sIC8vIEEtWiBGcmFrdHVyXG5bXCJtYXRoZnJha1wiLCBcInRleHRmcmFrXCIsIFwiRnJha3R1ci1SZWd1bGFyXCJdLCAvLyBhLXogRnJha3R1clxuW1wibWF0aGJiXCIsIFwidGV4dGJiXCIsIFwiQU1TLVJlZ3VsYXJcIl0sIC8vIEEtWiBkb3VibGUtc3RydWNrXG5bXCJtYXRoYmJcIiwgXCJ0ZXh0YmJcIiwgXCJBTVMtUmVndWxhclwiXSwgLy8gayBkb3VibGUtc3RydWNrXG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIEEtWiBib2xkIEZyYWt0dXIgTm8gZm9udCBtZXRyaWNzXG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIGEteiBib2xkIEZyYWt0dXIuICAgTm8gZm9udC5cbltcIm1hdGhzZlwiLCBcInRleHRzZlwiLCBcIlNhbnNTZXJpZi1SZWd1bGFyXCJdLCAvLyBBLVogc2Fucy1zZXJpZlxuW1wibWF0aHNmXCIsIFwidGV4dHNmXCIsIFwiU2Fuc1NlcmlmLVJlZ3VsYXJcIl0sIC8vIGEteiBzYW5zLXNlcmlmXG5bXCJtYXRoYm9sZHNmXCIsIFwidGV4dGJvbGRzZlwiLCBcIlNhbnNTZXJpZi1Cb2xkXCJdLCAvLyBBLVogYm9sZCBzYW5zLXNlcmlmXG5bXCJtYXRoYm9sZHNmXCIsIFwidGV4dGJvbGRzZlwiLCBcIlNhbnNTZXJpZi1Cb2xkXCJdLCAvLyBhLXogYm9sZCBzYW5zLXNlcmlmXG5bXCJtYXRoaXRzZlwiLCBcInRleHRpdHNmXCIsIFwiU2Fuc1NlcmlmLUl0YWxpY1wiXSwgLy8gQS1aIGl0YWxpYyBzYW5zLXNlcmlmXG5bXCJtYXRoaXRzZlwiLCBcInRleHRpdHNmXCIsIFwiU2Fuc1NlcmlmLUl0YWxpY1wiXSwgLy8gYS16IGl0YWxpYyBzYW5zLXNlcmlmXG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIEEtWiBib2xkIGl0YWxpYyBzYW5zLiBObyBmb250XG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIGEteiBib2xkIGl0YWxpYyBzYW5zLiBObyBmb250XG5bXCJtYXRodHRcIiwgXCJ0ZXh0dHRcIiwgXCJUeXBld3JpdGVyLVJlZ3VsYXJcIl0sIC8vIEEtWiBtb25vc3BhY2VcbltcIm1hdGh0dFwiLCBcInRleHR0dFwiLCBcIlR5cGV3cml0ZXItUmVndWxhclwiXV07XG52YXIgd2lkZU51bWVyYWxEYXRhID0gW1tcIm1hdGhiZlwiLCBcInRleHRiZlwiLCBcIk1haW4tQm9sZFwiXSwgLy8gMC05IGJvbGRcbltcIlwiLCBcIlwiLCBcIlwiXSwgLy8gMC05IGRvdWJsZS1zdHJ1Y2suIE5vIEthVGVYIGZvbnQuXG5bXCJtYXRoc2ZcIiwgXCJ0ZXh0c2ZcIiwgXCJTYW5zU2VyaWYtUmVndWxhclwiXSwgLy8gMC05IHNhbnMtc2VyaWZcbltcIm1hdGhib2xkc2ZcIiwgXCJ0ZXh0Ym9sZHNmXCIsIFwiU2Fuc1NlcmlmLUJvbGRcIl0sIC8vIDAtOSBib2xkIHNhbnMtc2VyaWZcbltcIm1hdGh0dFwiLCBcInRleHR0dFwiLCBcIlR5cGV3cml0ZXItUmVndWxhclwiXV07XG52YXIgd2lkZV9jaGFyYWN0ZXJfd2lkZUNoYXJhY3RlckZvbnQgPSBmdW5jdGlvbiB3aWRlQ2hhcmFjdGVyRm9udCh3aWRlQ2hhciwgbW9kZSkge1xuICAvLyBJRSBkb2Vzbid0IHN1cHBvcnQgY29kZVBvaW50QXQoKS4gU28gd29yayB3aXRoIHRoZSBzdXJyb2dhdGUgcGFpci5cbiAgdmFyIEggPSB3aWRlQ2hhci5jaGFyQ29kZUF0KDApOyAvLyBoaWdoIHN1cnJvZ2F0ZVxuXG4gIHZhciBMID0gd2lkZUNoYXIuY2hhckNvZGVBdCgxKTsgLy8gbG93IHN1cnJvZ2F0ZVxuXG4gIHZhciBjb2RlUG9pbnQgPSAoSCAtIDB4RDgwMCkgKiAweDQwMCArIChMIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gIHZhciBqID0gbW9kZSA9PT0gXCJtYXRoXCIgPyAwIDogMTsgLy8gY29sdW1uIGluZGV4IGZvciBDU1MgY2xhc3MuXG5cbiAgaWYgKDB4MUQ0MDAgPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDB4MUQ2QTQpIHtcbiAgICAvLyB3aWRlTGF0aW5MZXR0ZXJEYXRhIGNvbnRhaW5zIGV4YWN0bHkgMjYgY2hhcnMgb24gZWFjaCByb3cuXG4gICAgLy8gU28gd2UgY2FuIGNhbGN1bGF0ZSB0aGUgcmVsZXZhbnQgcm93LiBObyB0cmF2ZXJzZSBuZWNlc3NhcnkuXG4gICAgdmFyIGkgPSBNYXRoLmZsb29yKChjb2RlUG9pbnQgLSAweDFENDAwKSAvIDI2KTtcbiAgICByZXR1cm4gW3dpZGVMYXRpbkxldHRlckRhdGFbaV1bMl0sIHdpZGVMYXRpbkxldHRlckRhdGFbaV1bal1dO1xuICB9IGVsc2UgaWYgKDB4MUQ3Q0UgPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8PSAweDFEN0ZGKSB7XG4gICAgLy8gTnVtZXJhbHMsIHRlbiBwZXIgcm93LlxuICAgIHZhciBfaSA9IE1hdGguZmxvb3IoKGNvZGVQb2ludCAtIDB4MUQ3Q0UpIC8gMTApO1xuXG4gICAgcmV0dXJuIFt3aWRlTnVtZXJhbERhdGFbX2ldWzJdLCB3aWRlTnVtZXJhbERhdGFbX2ldW2pdXTtcbiAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPT09IDB4MUQ2QTUgfHwgY29kZVBvaW50ID09PSAweDFENkE2KSB7XG4gICAgLy8gZG90bGVzcyBpIG9yIGpcbiAgICByZXR1cm4gW3dpZGVMYXRpbkxldHRlckRhdGFbMF1bMl0sIHdpZGVMYXRpbkxldHRlckRhdGFbMF1bal1dO1xuICB9IGVsc2UgaWYgKDB4MUQ2QTYgPCBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDwgMHgxRDdDRSkge1xuICAgIC8vIEdyZWVrIGxldHRlcnMuIE5vdCBzdXBwb3J0ZWQsIHlldC5cbiAgICByZXR1cm4gW1wiXCIsIFwiXCJdO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgYW55IHdpZGUgY2hhcmFjdGVycyBvdXRzaWRlIDFENDAw4oCTMUQ3RkYuXG4gICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiVW5zdXBwb3J0ZWQgY2hhcmFjdGVyOiBcIiArIHdpZGVDaGFyKTtcbiAgfVxufTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL09wdGlvbnMuanNcbi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcHRpb25zIHRoYXQgdGhlIFBhcnNlciBjYXJyaWVzXG4gKiBhcm91bmQgd2l0aCBpdCB3aGlsZSBwYXJzaW5nLiBEYXRhIGlzIGhlbGQgaW4gYW4gYE9wdGlvbnNgIG9iamVjdCwgYW5kIHdoZW5cbiAqIHJlY3Vyc2luZywgYSBuZXcgYE9wdGlvbnNgIG9iamVjdCBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZSBgLndpdGgqYCBhbmRcbiAqIGAucmVzZXRgIGZ1bmN0aW9ucy5cbiAqL1xuXG52YXIgc2l6ZVN0eWxlTWFwID0gWy8vIEVhY2ggZWxlbWVudCBjb250YWlucyBbdGV4dHNpemUsIHNjcmlwdHNpemUsIHNjcmlwdHNjcmlwdHNpemVdLlxuLy8gVGhlIHNpemUgbWFwcGluZ3MgYXJlIHRha2VuIGZyb20gVGVYIHdpdGggXFxub3JtYWxzaXplPTEwcHQuXG5bMSwgMSwgMV0sIC8vIHNpemUxOiBbNSwgNSwgNV0gICAgICAgICAgICAgIFxcdGlueVxuWzIsIDEsIDFdLCAvLyBzaXplMjogWzYsIDUsIDVdXG5bMywgMSwgMV0sIC8vIHNpemUzOiBbNywgNSwgNV0gICAgICAgICAgICAgIFxcc2NyaXB0c2l6ZVxuWzQsIDIsIDFdLCAvLyBzaXplNDogWzgsIDYsIDVdICAgICAgICAgICAgICBcXGZvb3Rub3Rlc2l6ZVxuWzUsIDIsIDFdLCAvLyBzaXplNTogWzksIDYsIDVdICAgICAgICAgICAgICBcXHNtYWxsXG5bNiwgMywgMV0sIC8vIHNpemU2OiBbMTAsIDcsIDVdICAgICAgICAgICAgIFxcbm9ybWFsc2l6ZVxuWzcsIDQsIDJdLCAvLyBzaXplNzogWzEyLCA4LCA2XSAgICAgICAgICAgICBcXGxhcmdlXG5bOCwgNiwgM10sIC8vIHNpemU4OiBbMTQuNCwgMTAsIDddICAgICAgICAgIFxcTGFyZ2Vcbls5LCA3LCA2XSwgLy8gc2l6ZTk6IFsxNy4yOCwgMTIsIDEwXSAgICAgICAgXFxMQVJHRVxuWzEwLCA4LCA3XSwgLy8gc2l6ZTEwOiBbMjAuNzQsIDE0LjQsIDEyXSAgICAgXFxodWdlXG5bMTEsIDEwLCA5XV07XG52YXIgc2l6ZU11bHRpcGxpZXJzID0gWy8vIGZvbnRNZXRyaWNzLmpzOmdldEdsb2JhbE1ldHJpY3MgYWxzbyB1c2VzIHNpemUgaW5kZXhlcywgc28gaWZcbi8vIHlvdSBjaGFuZ2Ugc2l6ZSBpbmRleGVzLCBjaGFuZ2UgdGhhdCBmdW5jdGlvbi5cbjAuNSwgMC42LCAwLjcsIDAuOCwgMC45LCAxLjAsIDEuMiwgMS40NCwgMS43MjgsIDIuMDc0LCAyLjQ4OF07XG5cbnZhciBzaXplQXRTdHlsZSA9IGZ1bmN0aW9uIHNpemVBdFN0eWxlKHNpemUsIHN0eWxlKSB7XG4gIHJldHVybiBzdHlsZS5zaXplIDwgMiA/IHNpemUgOiBzaXplU3R5bGVNYXBbc2l6ZSAtIDFdW3N0eWxlLnNpemUgLSAxXTtcbn07IC8vIEluIHRoZXNlIHR5cGVzLCBcIlwiIChlbXB0eSBzdHJpbmcpIG1lYW5zIFwibm8gY2hhbmdlXCIuXG5cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBtYWluIG9wdGlvbnMgY2xhc3MuIEl0IGNvbnRhaW5zIHRoZSBjdXJyZW50IHN0eWxlLCBzaXplLCBjb2xvcixcbiAqIGFuZCBmb250LlxuICpcbiAqIE9wdGlvbnMgb2JqZWN0cyBzaG91bGQgbm90IGJlIG1vZGlmaWVkLiBUbyBjcmVhdGUgYSBuZXcgT3B0aW9ucyB3aXRoXG4gKiBkaWZmZXJlbnQgcHJvcGVydGllcywgY2FsbCBhIGAuaGF2aW5nKmAgbWV0aG9kLlxuICovXG52YXIgT3B0aW9uc19PcHRpb25zID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLy8gQSBmb250IGZhbWlseSBhcHBsaWVzIHRvIGEgZ3JvdXAgb2YgZm9udHMgKGkuZS4gU2Fuc1NlcmlmKSwgd2hpbGUgYSBmb250XG4gIC8vIHJlcHJlc2VudHMgYSBzcGVjaWZpYyBmb250IChpLmUuIFNhbnNTZXJpZiBCb2xkKS5cbiAgLy8gU2VlOiBodHRwczovL3RleC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMjIzNTAvZGlmZmVyZW5jZS1iZXR3ZWVuLXRleHRybS1hbmQtbWF0aHJtXG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIHNpemUgaW5kZXguXG4gICAqL1xuICBmdW5jdGlvbiBPcHRpb25zKGRhdGEpIHtcbiAgICB0aGlzLnN0eWxlID0gdm9pZCAwO1xuICAgIHRoaXMuY29sb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5zaXplID0gdm9pZCAwO1xuICAgIHRoaXMudGV4dFNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5waGFudG9tID0gdm9pZCAwO1xuICAgIHRoaXMuZm9udCA9IHZvaWQgMDtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSB2b2lkIDA7XG4gICAgdGhpcy5mb250V2VpZ2h0ID0gdm9pZCAwO1xuICAgIHRoaXMuZm9udFNoYXBlID0gdm9pZCAwO1xuICAgIHRoaXMuc2l6ZU11bHRpcGxpZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5tYXhTaXplID0gdm9pZCAwO1xuICAgIHRoaXMubWluUnVsZVRoaWNrbmVzcyA9IHZvaWQgMDtcbiAgICB0aGlzLl9mb250TWV0cmljcyA9IHZvaWQgMDtcbiAgICB0aGlzLnN0eWxlID0gZGF0YS5zdHlsZTtcbiAgICB0aGlzLmNvbG9yID0gZGF0YS5jb2xvcjtcbiAgICB0aGlzLnNpemUgPSBkYXRhLnNpemUgfHwgT3B0aW9ucy5CQVNFU0laRTtcbiAgICB0aGlzLnRleHRTaXplID0gZGF0YS50ZXh0U2l6ZSB8fCB0aGlzLnNpemU7XG4gICAgdGhpcy5waGFudG9tID0gISFkYXRhLnBoYW50b207XG4gICAgdGhpcy5mb250ID0gZGF0YS5mb250IHx8IFwiXCI7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gZGF0YS5mb250RmFtaWx5IHx8IFwiXCI7XG4gICAgdGhpcy5mb250V2VpZ2h0ID0gZGF0YS5mb250V2VpZ2h0IHx8ICcnO1xuICAgIHRoaXMuZm9udFNoYXBlID0gZGF0YS5mb250U2hhcGUgfHwgJyc7XG4gICAgdGhpcy5zaXplTXVsdGlwbGllciA9IHNpemVNdWx0aXBsaWVyc1t0aGlzLnNpemUgLSAxXTtcbiAgICB0aGlzLm1heFNpemUgPSBkYXRhLm1heFNpemU7XG4gICAgdGhpcy5taW5SdWxlVGhpY2tuZXNzID0gZGF0YS5taW5SdWxlVGhpY2tuZXNzO1xuICAgIHRoaXMuX2ZvbnRNZXRyaWNzID0gdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBhcyBcInRoaXNcIi4gIFByb3BlcnRpZXNcbiAgICogZnJvbSBcImV4dGVuc2lvblwiIHdpbGwgYmUgY29waWVkIHRvIHRoZSBuZXcgb3B0aW9ucyBvYmplY3QuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IE9wdGlvbnMucHJvdG90eXBlO1xuXG4gIF9wcm90by5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQoZXh0ZW5zaW9uKSB7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBzdHlsZTogdGhpcy5zdHlsZSxcbiAgICAgIHNpemU6IHRoaXMuc2l6ZSxcbiAgICAgIHRleHRTaXplOiB0aGlzLnRleHRTaXplLFxuICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICBwaGFudG9tOiB0aGlzLnBoYW50b20sXG4gICAgICBmb250OiB0aGlzLmZvbnQsXG4gICAgICBmb250RmFtaWx5OiB0aGlzLmZvbnRGYW1pbHksXG4gICAgICBmb250V2VpZ2h0OiB0aGlzLmZvbnRXZWlnaHQsXG4gICAgICBmb250U2hhcGU6IHRoaXMuZm9udFNoYXBlLFxuICAgICAgbWF4U2l6ZTogdGhpcy5tYXhTaXplLFxuICAgICAgbWluUnVsZVRoaWNrbmVzczogdGhpcy5taW5SdWxlVGhpY2tuZXNzXG4gICAgfTtcblxuICAgIGZvciAodmFyIGtleSBpbiBleHRlbnNpb24pIHtcbiAgICAgIGlmIChleHRlbnNpb24uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBkYXRhW2tleV0gPSBleHRlbnNpb25ba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE9wdGlvbnMoZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbiBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBzdHlsZS4gSWYgYHRoaXMuc3R5bGUgPT09IHN0eWxlYCxcbiAgICogcmV0dXJucyBgdGhpc2AuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmhhdmluZ1N0eWxlID0gZnVuY3Rpb24gaGF2aW5nU3R5bGUoc3R5bGUpIHtcbiAgICBpZiAodGhpcy5zdHlsZSA9PT0gc3R5bGUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIHNpemU6IHNpemVBdFN0eWxlKHRoaXMudGV4dFNpemUsIHN0eWxlKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBhIGNyYW1wZWQgdmVyc2lvbiBvZiB0aGUgY3VycmVudCBzdHlsZS4gSWZcbiAgICogdGhlIGN1cnJlbnQgc3R5bGUgaXMgY3JhbXBlZCwgcmV0dXJucyBgdGhpc2AuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmhhdmluZ0NyYW1wZWRTdHlsZSA9IGZ1bmN0aW9uIGhhdmluZ0NyYW1wZWRTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXZpbmdTdHlsZSh0aGlzLnN0eWxlLmNyYW1wKCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gc2l6ZSBhbmQgaW4gYXQgbGVhc3QgYFxcdGV4dHN0eWxlYC5cbiAgICogUmV0dXJucyBgdGhpc2AgaWYgYXBwcm9wcmlhdGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmhhdmluZ1NpemUgPSBmdW5jdGlvbiBoYXZpbmdTaXplKHNpemUpIHtcbiAgICBpZiAodGhpcy5zaXplID09PSBzaXplICYmIHRoaXMudGV4dFNpemUgPT09IHNpemUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgICBzdHlsZTogdGhpcy5zdHlsZS50ZXh0KCksXG4gICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgIHRleHRTaXplOiBzaXplLFxuICAgICAgICBzaXplTXVsdGlwbGllcjogc2l6ZU11bHRpcGxpZXJzW3NpemUgLSAxXVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBMaWtlIGB0aGlzLmhhdmluZ1NpemUoQkFTRVNJWkUpLmhhdmluZ1N0eWxlKHN0eWxlKWAuIElmIGBzdHlsZWAgaXMgb21pdHRlZCxcbiAgICogY2hhbmdlcyB0byBhdCBsZWFzdCBgXFx0ZXh0c3R5bGVgLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5oYXZpbmdCYXNlU3R5bGUgPSBmdW5jdGlvbiBoYXZpbmdCYXNlU3R5bGUoc3R5bGUpIHtcbiAgICBzdHlsZSA9IHN0eWxlIHx8IHRoaXMuc3R5bGUudGV4dCgpO1xuICAgIHZhciB3YW50U2l6ZSA9IHNpemVBdFN0eWxlKE9wdGlvbnMuQkFTRVNJWkUsIHN0eWxlKTtcblxuICAgIGlmICh0aGlzLnNpemUgPT09IHdhbnRTaXplICYmIHRoaXMudGV4dFNpemUgPT09IE9wdGlvbnMuQkFTRVNJWkUgJiYgdGhpcy5zdHlsZSA9PT0gc3R5bGUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIHNpemU6IHdhbnRTaXplXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZWZmZWN0IG9mIHNpemluZyBjaGFuZ2VzIHN1Y2ggYXMgXFxIdWdlLlxuICAgKiBLZWVwIHRoZSBlZmZlY3Qgb2YgdGhlIGN1cnJlbnQgc3R5bGUsIHN1Y2ggYXMgXFxzY3JpcHRzdHlsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaGF2aW5nQmFzZVNpemluZyA9IGZ1bmN0aW9uIGhhdmluZ0Jhc2VTaXppbmcoKSB7XG4gICAgdmFyIHNpemU7XG5cbiAgICBzd2l0Y2ggKHRoaXMuc3R5bGUuaWQpIHtcbiAgICAgIGNhc2UgNDpcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgc2l6ZSA9IDM7IC8vIG5vcm1hbHNpemUgaW4gc2NyaXB0c3R5bGVcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA2OlxuICAgICAgY2FzZSA3OlxuICAgICAgICBzaXplID0gMTsgLy8gbm9ybWFsc2l6ZSBpbiBzY3JpcHRzY3JpcHRzdHlsZVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzaXplID0gNjtcbiAgICAgIC8vIG5vcm1hbHNpemUgaW4gdGV4dHN0eWxlIG9yIGRpc3BsYXlzdHlsZVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBzdHlsZTogdGhpcy5zdHlsZS50ZXh0KCksXG4gICAgICBzaXplOiBzaXplXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2xvci5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ud2l0aENvbG9yID0gZnVuY3Rpb24gd2l0aENvbG9yKGNvbG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgIGNvbG9yOiBjb2xvclxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCBcInBoYW50b21cIiBzZXQgdG8gdHJ1ZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ud2l0aFBoYW50b20gPSBmdW5jdGlvbiB3aXRoUGhhbnRvbSgpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgcGhhbnRvbTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIG1hdGggZm9udCBvciBvbGQgdGV4dCBmb250LlxuICAgKiBAdHlwZSB7W3R5cGVdfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by53aXRoRm9udCA9IGZ1bmN0aW9uIHdpdGhGb250KGZvbnQpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgZm9udDogZm9udFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgb3B0aW9ucyBvYmplY3RzIHdpdGggdGhlIGdpdmVuIGZvbnRGYW1pbHkuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLndpdGhUZXh0Rm9udEZhbWlseSA9IGZ1bmN0aW9uIHdpdGhUZXh0Rm9udEZhbWlseShmb250RmFtaWx5KSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHksXG4gICAgICBmb250OiBcIlwiXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gZm9udCB3ZWlnaHRcbiAgICovXG4gIDtcblxuICBfcHJvdG8ud2l0aFRleHRGb250V2VpZ2h0ID0gZnVuY3Rpb24gd2l0aFRleHRGb250V2VpZ2h0KGZvbnRXZWlnaHQpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgZm9udFdlaWdodDogZm9udFdlaWdodCxcbiAgICAgIGZvbnQ6IFwiXCJcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBmb250IHdlaWdodFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by53aXRoVGV4dEZvbnRTaGFwZSA9IGZ1bmN0aW9uIHdpdGhUZXh0Rm9udFNoYXBlKGZvbnRTaGFwZSkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBmb250U2hhcGU6IGZvbnRTaGFwZSxcbiAgICAgIGZvbnQ6IFwiXCJcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBDU1Mgc2l6aW5nIGNsYXNzZXMgcmVxdWlyZWQgdG8gc3dpdGNoIGZyb20gZW5jbG9zaW5nIG9wdGlvbnNcbiAgICogYG9sZE9wdGlvbnNgIHRvIGB0aGlzYC4gUmV0dXJucyBhbiBhcnJheSBvZiBjbGFzc2VzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zaXppbmdDbGFzc2VzID0gZnVuY3Rpb24gc2l6aW5nQ2xhc3NlcyhvbGRPcHRpb25zKSB7XG4gICAgaWYgKG9sZE9wdGlvbnMuc2l6ZSAhPT0gdGhpcy5zaXplKSB7XG4gICAgICByZXR1cm4gW1wic2l6aW5nXCIsIFwicmVzZXQtc2l6ZVwiICsgb2xkT3B0aW9ucy5zaXplLCBcInNpemVcIiArIHRoaXMuc2l6ZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgQ1NTIHNpemluZyBjbGFzc2VzIHJlcXVpcmVkIHRvIHN3aXRjaCB0byB0aGUgYmFzZSBzaXplLiBMaWtlXG4gICAqIGB0aGlzLmhhdmluZ1NpemUoQkFTRVNJWkUpLnNpemluZ0NsYXNzZXModGhpcylgLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5iYXNlU2l6aW5nQ2xhc3NlcyA9IGZ1bmN0aW9uIGJhc2VTaXppbmdDbGFzc2VzKCkge1xuICAgIGlmICh0aGlzLnNpemUgIT09IE9wdGlvbnMuQkFTRVNJWkUpIHtcbiAgICAgIHJldHVybiBbXCJzaXppbmdcIiwgXCJyZXNldC1zaXplXCIgKyB0aGlzLnNpemUsIFwic2l6ZVwiICsgT3B0aW9ucy5CQVNFU0laRV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZm9udCBtZXRyaWNzIGZvciB0aGlzIHNpemUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmZvbnRNZXRyaWNzID0gZnVuY3Rpb24gZm9udE1ldHJpY3MoKSB7XG4gICAgaWYgKCF0aGlzLl9mb250TWV0cmljcykge1xuICAgICAgdGhpcy5fZm9udE1ldHJpY3MgPSBnZXRHbG9iYWxNZXRyaWNzKHRoaXMuc2l6ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2ZvbnRNZXRyaWNzO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBDU1MgY29sb3Igb2YgdGhlIGN1cnJlbnQgb3B0aW9ucyBvYmplY3RcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0Q29sb3IgPSBmdW5jdGlvbiBnZXRDb2xvcigpIHtcbiAgICBpZiAodGhpcy5waGFudG9tKSB7XG4gICAgICByZXR1cm4gXCJ0cmFuc3BhcmVudFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jb2xvcjtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE9wdGlvbnM7XG59KCk7XG5cbk9wdGlvbnNfT3B0aW9ucy5CQVNFU0laRSA9IDY7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfT3B0aW9ucyA9IChPcHRpb25zX09wdGlvbnMpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdW5pdHMuanNcbi8qKlxuICogVGhpcyBmaWxlIGRvZXMgY29udmVyc2lvbiBiZXR3ZWVuIHVuaXRzLiAgSW4gcGFydGljdWxhciwgaXQgcHJvdmlkZXNcbiAqIGNhbGN1bGF0ZVNpemUgdG8gY29udmVydCBvdGhlciB1bml0cyBpbnRvIGVtcy5cbiAqL1xuXG4gLy8gVGhpcyB0YWJsZSBnaXZlcyB0aGUgbnVtYmVyIG9mIFRlWCBwdHMgaW4gb25lIG9mIGVhY2ggKmFic29sdXRlKiBUZVggdW5pdC5cbi8vIFRodXMsIG11bHRpcGx5aW5nIGEgbGVuZ3RoIGJ5IHRoaXMgbnVtYmVyIGNvbnZlcnRzIHRoZSBsZW5ndGggZnJvbSB1bml0c1xuLy8gaW50byBwdHMuICBEaXZpZGluZyB0aGUgcmVzdWx0IGJ5IHB0UGVyRW0gZ2l2ZXMgdGhlIG51bWJlciBvZiBlbXNcbi8vICphc3N1bWluZyogYSBmb250IHNpemUgb2YgcHRQZXJFbSAobm9ybWFsIHNpemUsIG5vcm1hbCBzdHlsZSkuXG5cbnZhciBwdFBlclVuaXQgPSB7XG4gIC8vIGh0dHBzOi8vZW4ud2lraWJvb2tzLm9yZy93aWtpL0xhVGVYL0xlbmd0aHMgYW5kXG4gIC8vIGh0dHBzOi8vdGV4LnN0YWNrZXhjaGFuZ2UuY29tL2EvODI2M1xuICBcInB0XCI6IDEsXG4gIC8vIFRlWCBwb2ludFxuICBcIm1tXCI6IDcyMjcgLyAyNTQwLFxuICAvLyBtaWxsaW1ldGVyXG4gIFwiY21cIjogNzIyNyAvIDI1NCxcbiAgLy8gY2VudGltZXRlclxuICBcImluXCI6IDcyLjI3LFxuICAvLyBpbmNoXG4gIFwiYnBcIjogODAzIC8gODAwLFxuICAvLyBiaWcgKFBvc3RTY3JpcHQpIHBvaW50c1xuICBcInBjXCI6IDEyLFxuICAvLyBwaWNhXG4gIFwiZGRcIjogMTIzOCAvIDExNTcsXG4gIC8vIGRpZG90XG4gIFwiY2NcIjogMTQ4NTYgLyAxMTU3LFxuICAvLyBjaWNlcm8gKDEyIGRpZG90KVxuICBcIm5kXCI6IDY4NSAvIDY0MixcbiAgLy8gbmV3IGRpZG90XG4gIFwibmNcIjogMTM3MCAvIDEwNyxcbiAgLy8gbmV3IGNpY2VybyAoMTIgbmV3IGRpZG90KVxuICBcInNwXCI6IDEgLyA2NTUzNixcbiAgLy8gc2NhbGVkIHBvaW50IChUZVgncyBpbnRlcm5hbCBzbWFsbGVzdCB1bml0KVxuICAvLyBodHRwczovL3RleC5zdGFja2V4Y2hhbmdlLmNvbS9hLzQxMzcxXG4gIFwicHhcIjogODAzIC8gODAwIC8vIFxccGRmcHhkaW1lbiBkZWZhdWx0cyB0byAxIGJwIGluIHBkZlRlWCBhbmQgTHVhVGVYXG5cbn07IC8vIERpY3Rpb25hcnkgb2YgcmVsYXRpdmUgdW5pdHMsIGZvciBmYXN0IHZhbGlkaXR5IHRlc3RpbmcuXG5cbnZhciByZWxhdGl2ZVVuaXQgPSB7XG4gIFwiZXhcIjogdHJ1ZSxcbiAgXCJlbVwiOiB0cnVlLFxuICBcIm11XCI6IHRydWVcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHNwZWNpZmllZCB1bml0IChlaXRoZXIgYSBzdHJpbmcgZGVmaW5pbmcgdGhlIHVuaXRcbiAqIG9yIGEgXCJzaXplXCIgcGFyc2Ugbm9kZSBjb250YWluaW5nIGEgdW5pdCBmaWVsZCkgaXMgdmFsaWQuXG4gKi9cbnZhciB2YWxpZFVuaXQgPSBmdW5jdGlvbiB2YWxpZFVuaXQodW5pdCkge1xuICBpZiAodHlwZW9mIHVuaXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICB1bml0ID0gdW5pdC51bml0O1xuICB9XG5cbiAgcmV0dXJuIHVuaXQgaW4gcHRQZXJVbml0IHx8IHVuaXQgaW4gcmVsYXRpdmVVbml0IHx8IHVuaXQgPT09IFwiZXhcIjtcbn07XG4vKlxuICogQ29udmVydCBhIFwic2l6ZVwiIHBhcnNlIG5vZGUgKHdpdGggbnVtZXJpYyBcIm51bWJlclwiIGFuZCBzdHJpbmcgXCJ1bml0XCIgZmllbGRzLFxuICogYXMgcGFyc2VkIGJ5IGZ1bmN0aW9ucy5qcyBhcmdUeXBlIFwic2l6ZVwiKSBpbnRvIGEgQ1NTIGVtIHZhbHVlIGZvciB0aGVcbiAqIGN1cnJlbnQgc3R5bGUvc2NhbGUuICBgb3B0aW9uc2AgZ2l2ZXMgdGhlIGN1cnJlbnQgb3B0aW9ucy5cbiAqL1xuXG52YXIgdW5pdHNfY2FsY3VsYXRlU2l6ZSA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVNpemUoc2l6ZVZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciBzY2FsZTtcblxuICBpZiAoc2l6ZVZhbHVlLnVuaXQgaW4gcHRQZXJVbml0KSB7XG4gICAgLy8gQWJzb2x1dGUgdW5pdHNcbiAgICBzY2FsZSA9IHB0UGVyVW5pdFtzaXplVmFsdWUudW5pdF0gLy8gQ29udmVydCB1bml0IHRvIHB0XG4gICAgLyBvcHRpb25zLmZvbnRNZXRyaWNzKCkucHRQZXJFbSAvLyBDb252ZXJ0IHB0IHRvIENTUyBlbVxuICAgIC8gb3B0aW9ucy5zaXplTXVsdGlwbGllcjsgLy8gVW5zY2FsZSB0byBtYWtlIGFic29sdXRlIHVuaXRzXG4gIH0gZWxzZSBpZiAoc2l6ZVZhbHVlLnVuaXQgPT09IFwibXVcIikge1xuICAgIC8vIGBtdWAgdW5pdHMgc2NhbGUgd2l0aCBzY3JpcHRzdHlsZS9zY3JpcHRzY3JpcHRzdHlsZS5cbiAgICBzY2FsZSA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5jc3NFbVBlck11O1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyIHJlbGF0aXZlIHVuaXRzIGFsd2F5cyByZWZlciB0byB0aGUgKnRleHRzdHlsZSogZm9udFxuICAgIC8vIGluIHRoZSBjdXJyZW50IHNpemUuXG4gICAgdmFyIHVuaXRPcHRpb25zO1xuXG4gICAgaWYgKG9wdGlvbnMuc3R5bGUuaXNUaWdodCgpKSB7XG4gICAgICAvLyBpc1RpZ2h0KCkgbWVhbnMgY3VycmVudCBzdHlsZSBpcyBzY3JpcHQvc2NyaXB0c2NyaXB0LlxuICAgICAgdW5pdE9wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKG9wdGlvbnMuc3R5bGUudGV4dCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5pdE9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH0gLy8gVE9ETzogSW4gVGVYIHRoZXNlIHVuaXRzIGFyZSByZWxhdGl2ZSB0byB0aGUgcXVhZCBvZiB0aGUgY3VycmVudFxuICAgIC8vICp0ZXh0KiBmb250LCBlLmcuIGNtcjEwLiBLYVRlWCBpbnN0ZWFkIHVzZXMgdmFsdWVzIGZyb20gdGhlXG4gICAgLy8gY29tcGFyYWJseS1zaXplZCAqQ29tcHV0ZXIgTW9kZXJuIHN5bWJvbCogZm9udC4gQXQgMTBwdCwgdGhlc2VcbiAgICAvLyBtYXRjaC4gQXQgN3B0IGFuZCA1cHQsIHRoZXkgZGlmZmVyOiBjbXI3PTEuMTM4ODk0LCBjbXN5Nz0xLjE3MDY0MTtcbiAgICAvLyBjbXI1PTEuMzYxMTMzLCBjbXN5NT0xLjQ3MjI0MS4gQ29uc2lkZXIgJFxcc2NyaXB0c2l6ZSBhXFxrZXJuMWVtYiQuXG4gICAgLy8gVGVYIFxcc2hvd2xpc3RzIHNob3dzIGEga2VybiBvZiAxLjEzODg5ICogZm9udHNpemU7XG4gICAgLy8gS2FUZVggc2hvd3MgYSBrZXJuIG9mIDEuMTcxICogZm9udHNpemUuXG5cblxuICAgIGlmIChzaXplVmFsdWUudW5pdCA9PT0gXCJleFwiKSB7XG4gICAgICBzY2FsZSA9IHVuaXRPcHRpb25zLmZvbnRNZXRyaWNzKCkueEhlaWdodDtcbiAgICB9IGVsc2UgaWYgKHNpemVWYWx1ZS51bml0ID09PSBcImVtXCIpIHtcbiAgICAgIHNjYWxlID0gdW5pdE9wdGlvbnMuZm9udE1ldHJpY3MoKS5xdWFkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbnZhbGlkIHVuaXQ6ICdcIiArIHNpemVWYWx1ZS51bml0ICsgXCInXCIpO1xuICAgIH1cblxuICAgIGlmICh1bml0T3B0aW9ucyAhPT0gb3B0aW9ucykge1xuICAgICAgc2NhbGUgKj0gdW5pdE9wdGlvbnMuc2l6ZU11bHRpcGxpZXIgLyBvcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBNYXRoLm1pbihzaXplVmFsdWUubnVtYmVyICogc2NhbGUsIG9wdGlvbnMubWF4U2l6ZSk7XG59O1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYnVpbGRDb21tb24uanNcbi8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cblxuLyoqXG4gKiBUaGlzIG1vZHVsZSBjb250YWlucyBnZW5lcmFsIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIGZvciBidWlsZGluZ1xuICogZGlmZmVyZW50IGtpbmRzIG9mIGRvbVRyZWUgbm9kZXMgaW4gYSBjb25zaXN0ZW50IG1hbm5lci5cbiAqL1xuXG5cblxuXG5cblxuXG4vLyBUaGUgZm9sbG93aW5nIGhhdmUgdG8gYmUgbG9hZGVkIGZyb20gTWFpbi1JdGFsaWMgZm9udCwgdXNpbmcgY2xhc3MgbWF0aGl0XG52YXIgbWF0aGl0TGV0dGVycyA9IFtcIlxcXFxpbWF0aFwiLCBcIsSxXCIsIC8vIGRvdGxlc3MgaVxuXCJcXFxcam1hdGhcIiwgXCLIt1wiLCAvLyBkb3RsZXNzIGpcblwiXFxcXHBvdW5kc1wiLCBcIlxcXFxtYXRoc3RlcmxpbmdcIiwgXCJcXFxcdGV4dHN0ZXJsaW5nXCIsIFwiwqNcIl07XG4vKipcbiAqIExvb2tzIHVwIHRoZSBnaXZlbiBzeW1ib2wgaW4gZm9udE1ldHJpY3MsIGFmdGVyIGFwcGx5aW5nIGFueSBzeW1ib2xcbiAqIHJlcGxhY2VtZW50cyBkZWZpbmVkIGluIHN5bWJvbC5qc1xuICovXG5cbnZhciBidWlsZENvbW1vbl9sb29rdXBTeW1ib2wgPSBmdW5jdGlvbiBsb29rdXBTeW1ib2wodmFsdWUsIC8vIFRPRE8oIzk2Myk6IFVzZSBhIHVuaW9uIHR5cGUgZm9yIHRoaXMuXG5mb250TmFtZSwgbW9kZSkge1xuICAvLyBSZXBsYWNlIHRoZSB2YWx1ZSB3aXRoIGl0cyByZXBsYWNlZCB2YWx1ZSBmcm9tIHN5bWJvbC5qc1xuICBpZiAoc3JjX3N5bWJvbHNbbW9kZV1bdmFsdWVdICYmIHNyY19zeW1ib2xzW21vZGVdW3ZhbHVlXS5yZXBsYWNlKSB7XG4gICAgdmFsdWUgPSBzcmNfc3ltYm9sc1ttb2RlXVt2YWx1ZV0ucmVwbGFjZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIG1ldHJpY3M6IGdldENoYXJhY3Rlck1ldHJpY3ModmFsdWUsIGZvbnROYW1lLCBtb2RlKVxuICB9O1xufTtcbi8qKlxuICogTWFrZXMgYSBzeW1ib2xOb2RlIGFmdGVyIHRyYW5zbGF0aW9uIHZpYSB0aGUgbGlzdCBvZiBzeW1ib2xzIGluIHN5bWJvbHMuanMuXG4gKiBDb3JyZWN0bHkgcHVsbHMgb3V0IG1ldHJpY3MgZm9yIHRoZSBjaGFyYWN0ZXIsIGFuZCBvcHRpb25hbGx5IHRha2VzIGEgbGlzdCBvZlxuICogY2xhc3NlcyB0byBiZSBhdHRhY2hlZCB0byB0aGUgbm9kZS5cbiAqXG4gKiBUT0RPOiBtYWtlIGFyZ3VtZW50IG9yZGVyIGNsb3NlciB0byBtYWtlU3BhblxuICogVE9ETzogYWRkIGEgc2VwYXJhdGUgYXJndW1lbnQgZm9yIG1hdGggY2xhc3MgKGUuZy4gYG1vcGAsIGBtYmluYCksIHdoaWNoXG4gKiBzaG91bGQgaWYgcHJlc2VudCBjb21lIGZpcnN0IGluIGBjbGFzc2VzYC5cbiAqIFRPRE8oIzk1Myk6IE1ha2UgYG9wdGlvbnNgIG1hbmRhdG9yeSBhbmQgYWx3YXlzIHBhc3MgaXQgaW4uXG4gKi9cblxuXG52YXIgYnVpbGRDb21tb25fbWFrZVN5bWJvbCA9IGZ1bmN0aW9uIG1ha2VTeW1ib2wodmFsdWUsIGZvbnROYW1lLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzKSB7XG4gIHZhciBsb29rdXAgPSBidWlsZENvbW1vbl9sb29rdXBTeW1ib2wodmFsdWUsIGZvbnROYW1lLCBtb2RlKTtcbiAgdmFyIG1ldHJpY3MgPSBsb29rdXAubWV0cmljcztcbiAgdmFsdWUgPSBsb29rdXAudmFsdWU7XG4gIHZhciBzeW1ib2xOb2RlO1xuXG4gIGlmIChtZXRyaWNzKSB7XG4gICAgdmFyIGl0YWxpYyA9IG1ldHJpY3MuaXRhbGljO1xuXG4gICAgaWYgKG1vZGUgPT09IFwidGV4dFwiIHx8IG9wdGlvbnMgJiYgb3B0aW9ucy5mb250ID09PSBcIm1hdGhpdFwiKSB7XG4gICAgICBpdGFsaWMgPSAwO1xuICAgIH1cblxuICAgIHN5bWJvbE5vZGUgPSBuZXcgZG9tVHJlZV9TeW1ib2xOb2RlKHZhbHVlLCBtZXRyaWNzLmhlaWdodCwgbWV0cmljcy5kZXB0aCwgaXRhbGljLCBtZXRyaWNzLnNrZXcsIG1ldHJpY3Mud2lkdGgsIGNsYXNzZXMpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRPRE8oZW1pbHkpOiBGaWd1cmUgb3V0IGEgZ29vZCB3YXkgdG8gb25seSBwcmludCB0aGlzIGluIGRldmVsb3BtZW50XG4gICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTm8gY2hhcmFjdGVyIG1ldHJpY3MgXCIgKyAoXCJmb3IgJ1wiICsgdmFsdWUgKyBcIicgaW4gc3R5bGUgJ1wiICsgZm9udE5hbWUgKyBcIicgYW5kIG1vZGUgJ1wiICsgbW9kZSArIFwiJ1wiKSk7XG4gICAgc3ltYm9sTm9kZSA9IG5ldyBkb21UcmVlX1N5bWJvbE5vZGUodmFsdWUsIDAsIDAsIDAsIDAsIDAsIGNsYXNzZXMpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBzeW1ib2xOb2RlLm1heEZvbnRTaXplID0gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcblxuICAgIGlmIChvcHRpb25zLnN0eWxlLmlzVGlnaHQoKSkge1xuICAgICAgc3ltYm9sTm9kZS5jbGFzc2VzLnB1c2goXCJtdGlnaHRcIik7XG4gICAgfVxuXG4gICAgdmFyIGNvbG9yID0gb3B0aW9ucy5nZXRDb2xvcigpO1xuXG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBzeW1ib2xOb2RlLnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bWJvbE5vZGU7XG59O1xuLyoqXG4gKiBNYWtlcyBhIHN5bWJvbCBpbiBNYWluLVJlZ3VsYXIgb3IgQU1TLVJlZ3VsYXIuXG4gKiBVc2VkIGZvciByZWwsIGJpbiwgb3BlbiwgY2xvc2UsIGlubmVyLCBhbmQgcHVuY3QuXG4gKi9cblxuXG52YXIgYnVpbGRDb21tb25fbWF0aHN5bSA9IGZ1bmN0aW9uIG1hdGhzeW0odmFsdWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMpIHtcbiAgaWYgKGNsYXNzZXMgPT09IHZvaWQgMCkge1xuICAgIGNsYXNzZXMgPSBbXTtcbiAgfVxuXG4gIC8vIERlY2lkZSB3aGF0IGZvbnQgdG8gcmVuZGVyIHRoZSBzeW1ib2wgaW4gYnkgaXRzIGVudHJ5IGluIHRoZSBzeW1ib2xzXG4gIC8vIHRhYmxlLlxuICAvLyBIYXZlIGEgc3BlY2lhbCBjYXNlIGZvciB3aGVuIHRoZSB2YWx1ZSA9IFxcIGJlY2F1c2UgdGhlIFxcIGlzIHVzZWQgYXMgYVxuICAvLyB0ZXh0b3JkIGluIHVuc3VwcG9ydGVkIGNvbW1hbmQgZXJyb3JzIGJ1dCBjYW5ub3QgYmUgcGFyc2VkIGFzIGEgcmVndWxhclxuICAvLyB0ZXh0IG9yZGluYWwgYW5kIGlzIHRoZXJlZm9yZSBub3QgcHJlc2VudCBhcyBhIHN5bWJvbCBpbiB0aGUgc3ltYm9sc1xuICAvLyB0YWJsZSBmb3IgdGV4dCwgYXMgd2VsbCBhcyBhIHNwZWNpYWwgY2FzZSBmb3IgYm9sZHN5bWJvbCBiZWNhdXNlIGl0XG4gIC8vIGNhbiBiZSB1c2VkIGZvciBib2xkICsgYW5kIC1cbiAgaWYgKG9wdGlvbnMuZm9udCA9PT0gXCJib2xkc3ltYm9sXCIgJiYgYnVpbGRDb21tb25fbG9va3VwU3ltYm9sKHZhbHVlLCBcIk1haW4tQm9sZFwiLCBtb2RlKS5tZXRyaWNzKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uX21ha2VTeW1ib2wodmFsdWUsIFwiTWFpbi1Cb2xkXCIsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KFtcIm1hdGhiZlwiXSkpO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSBcIlxcXFxcIiB8fCBzcmNfc3ltYm9sc1ttb2RlXVt2YWx1ZV0uZm9udCA9PT0gXCJtYWluXCIpIHtcbiAgICByZXR1cm4gYnVpbGRDb21tb25fbWFrZVN5bWJvbCh2YWx1ZSwgXCJNYWluLVJlZ3VsYXJcIiwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uX21ha2VTeW1ib2wodmFsdWUsIFwiQU1TLVJlZ3VsYXJcIiwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQoW1wiYW1zcm1cIl0pKTtcbiAgfVxufTtcbi8qKlxuICogRGV0ZXJtaW5lcyB3aGljaCBvZiB0aGUgdHdvIGZvbnQgbmFtZXMgKE1haW4tSXRhbGljIGFuZCBNYXRoLUl0YWxpYykgYW5kXG4gKiBjb3JyZXNwb25kaW5nIHN0eWxlIHRhZ3MgKG1haW5kZWZhdWx0IG9yIG1hdGhpdCkgdG8gdXNlIGZvciBkZWZhdWx0IG1hdGggZm9udCxcbiAqIGRlcGVuZGluZyBvbiB0aGUgc3ltYm9sLlxuICovXG5cblxudmFyIGJ1aWxkQ29tbW9uX21hdGhkZWZhdWx0ID0gZnVuY3Rpb24gbWF0aGRlZmF1bHQodmFsdWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMpIHtcbiAgaWYgKC9bMC05XS8udGVzdCh2YWx1ZS5jaGFyQXQoMCkpIHx8IC8vIGdseXBocyBmb3IgXFxpbWF0aCBhbmQgXFxqbWF0aCBkbyBub3QgZXhpc3QgaW4gTWF0aC1JdGFsaWMgc28gd2VcbiAgLy8gbmVlZCB0byB1c2UgTWFpbi1JdGFsaWMgaW5zdGVhZFxuICB1dGlscy5jb250YWlucyhtYXRoaXRMZXR0ZXJzLCB2YWx1ZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9udE5hbWU6IFwiTWFpbi1JdGFsaWNcIixcbiAgICAgIGZvbnRDbGFzczogXCJtYXRoaXRcIlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvbnROYW1lOiBcIk1hdGgtSXRhbGljXCIsXG4gICAgICBmb250Q2xhc3M6IFwibWF0aGRlZmF1bHRcIlxuICAgIH07XG4gIH1cbn07XG4vKipcbiAqIERldGVybWluZXMgd2hpY2ggb2YgdGhlIGZvbnQgbmFtZXMgKE1haW4tSXRhbGljLCBNYXRoLUl0YWxpYywgYW5kIENhbGlncmFwaGljKVxuICogYW5kIGNvcnJlc3BvbmRpbmcgc3R5bGUgdGFncyAobWF0aGl0LCBtYXRoZGVmYXVsdCwgb3IgbWF0aGNhbCkgdG8gdXNlIGZvciBmb250XG4gKiBcIm1hdGhub3JtYWxcIiwgZGVwZW5kaW5nIG9uIHRoZSBzeW1ib2wuICBVc2UgdGhpcyBmdW5jdGlvbiBpbnN0ZWFkIG9mIGZvbnRNYXAgZm9yXG4gKiBmb250IFwibWF0aG5vcm1hbFwiLlxuICovXG5cblxudmFyIGJ1aWxkQ29tbW9uX21hdGhub3JtYWwgPSBmdW5jdGlvbiBtYXRobm9ybWFsKHZhbHVlLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzKSB7XG4gIGlmICh1dGlscy5jb250YWlucyhtYXRoaXRMZXR0ZXJzLCB2YWx1ZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9udE5hbWU6IFwiTWFpbi1JdGFsaWNcIixcbiAgICAgIGZvbnRDbGFzczogXCJtYXRoaXRcIlxuICAgIH07XG4gIH0gZWxzZSBpZiAoL1swLTldLy50ZXN0KHZhbHVlLmNoYXJBdCgwKSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9udE5hbWU6IFwiQ2FsaWdyYXBoaWMtUmVndWxhclwiLFxuICAgICAgZm9udENsYXNzOiBcIm1hdGhjYWxcIlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvbnROYW1lOiBcIk1hdGgtSXRhbGljXCIsXG4gICAgICBmb250Q2xhc3M6IFwibWF0aGRlZmF1bHRcIlxuICAgIH07XG4gIH1cbn07XG4vKipcbiAqIERldGVybWluZXMgd2hpY2ggb2YgdGhlIHR3byBmb250IG5hbWVzIChNYWluLUJvbGQgYW5kIE1hdGgtQm9sZEl0YWxpYykgYW5kXG4gKiBjb3JyZXNwb25kaW5nIHN0eWxlIHRhZ3MgKG1hdGhiZiBvciBib2xkc3ltYm9sKSB0byB1c2UgZm9yIGZvbnQgXCJib2xkc3ltYm9sXCIsXG4gKiBkZXBlbmRpbmcgb24gdGhlIHN5bWJvbC4gIFVzZSB0aGlzIGZ1bmN0aW9uIGluc3RlYWQgb2YgZm9udE1hcCBmb3IgZm9udFxuICogXCJib2xkc3ltYm9sXCIuXG4gKi9cblxuXG52YXIgYm9sZHN5bWJvbCA9IGZ1bmN0aW9uIGJvbGRzeW1ib2wodmFsdWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMpIHtcbiAgaWYgKGJ1aWxkQ29tbW9uX2xvb2t1cFN5bWJvbCh2YWx1ZSwgXCJNYXRoLUJvbGRJdGFsaWNcIiwgbW9kZSkubWV0cmljcykge1xuICAgIHJldHVybiB7XG4gICAgICBmb250TmFtZTogXCJNYXRoLUJvbGRJdGFsaWNcIixcbiAgICAgIGZvbnRDbGFzczogXCJib2xkc3ltYm9sXCJcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIFNvbWUgZ2x5cGhzIGRvIG5vdCBleGlzdCBpbiBNYXRoLUJvbGRJdGFsaWMgc28gd2UgbmVlZCB0byB1c2VcbiAgICAvLyBNYWluLUJvbGQgaW5zdGVhZC5cbiAgICByZXR1cm4ge1xuICAgICAgZm9udE5hbWU6IFwiTWFpbi1Cb2xkXCIsXG4gICAgICBmb250Q2xhc3M6IFwibWF0aGJmXCJcbiAgICB9O1xuICB9XG59O1xuLyoqXG4gKiBNYWtlcyBlaXRoZXIgYSBtYXRob3JkIG9yIHRleHRvcmQgaW4gdGhlIGNvcnJlY3QgZm9udCBhbmQgY29sb3IuXG4gKi9cblxuXG52YXIgYnVpbGRDb21tb25fbWFrZU9yZCA9IGZ1bmN0aW9uIG1ha2VPcmQoZ3JvdXAsIG9wdGlvbnMsIHR5cGUpIHtcbiAgdmFyIG1vZGUgPSBncm91cC5tb2RlO1xuICB2YXIgdGV4dCA9IGdyb3VwLnRleHQ7XG4gIHZhciBjbGFzc2VzID0gW1wibW9yZFwiXTsgLy8gTWF0aCBtb2RlIG9yIE9sZCBmb250IChpLmUuIFxccm0pXG5cbiAgdmFyIGlzRm9udCA9IG1vZGUgPT09IFwibWF0aFwiIHx8IG1vZGUgPT09IFwidGV4dFwiICYmIG9wdGlvbnMuZm9udDtcbiAgdmFyIGZvbnRPckZhbWlseSA9IGlzRm9udCA/IG9wdGlvbnMuZm9udCA6IG9wdGlvbnMuZm9udEZhbWlseTtcblxuICBpZiAodGV4dC5jaGFyQ29kZUF0KDApID09PSAweEQ4MzUpIHtcbiAgICAvLyBzdXJyb2dhdGUgcGFpcnMgZ2V0IHNwZWNpYWwgdHJlYXRtZW50XG4gICAgdmFyIF93aWRlQ2hhcmFjdGVyRm9udCA9IHdpZGVfY2hhcmFjdGVyX3dpZGVDaGFyYWN0ZXJGb250KHRleHQsIG1vZGUpLFxuICAgICAgICB3aWRlRm9udE5hbWUgPSBfd2lkZUNoYXJhY3RlckZvbnRbMF0sXG4gICAgICAgIHdpZGVGb250Q2xhc3MgPSBfd2lkZUNoYXJhY3RlckZvbnRbMV07XG5cbiAgICByZXR1cm4gYnVpbGRDb21tb25fbWFrZVN5bWJvbCh0ZXh0LCB3aWRlRm9udE5hbWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KHdpZGVGb250Q2xhc3MpKTtcbiAgfSBlbHNlIGlmIChmb250T3JGYW1pbHkpIHtcbiAgICB2YXIgZm9udE5hbWU7XG4gICAgdmFyIGZvbnRDbGFzc2VzO1xuXG4gICAgaWYgKGZvbnRPckZhbWlseSA9PT0gXCJib2xkc3ltYm9sXCIgfHwgZm9udE9yRmFtaWx5ID09PSBcIm1hdGhub3JtYWxcIikge1xuICAgICAgdmFyIGZvbnREYXRhID0gZm9udE9yRmFtaWx5ID09PSBcImJvbGRzeW1ib2xcIiA/IGJvbGRzeW1ib2wodGV4dCwgbW9kZSwgb3B0aW9ucywgY2xhc3NlcykgOiBidWlsZENvbW1vbl9tYXRobm9ybWFsKHRleHQsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMpO1xuICAgICAgZm9udE5hbWUgPSBmb250RGF0YS5mb250TmFtZTtcbiAgICAgIGZvbnRDbGFzc2VzID0gW2ZvbnREYXRhLmZvbnRDbGFzc107XG4gICAgfSBlbHNlIGlmICh1dGlscy5jb250YWlucyhtYXRoaXRMZXR0ZXJzLCB0ZXh0KSkge1xuICAgICAgZm9udE5hbWUgPSBcIk1haW4tSXRhbGljXCI7XG4gICAgICBmb250Q2xhc3NlcyA9IFtcIm1hdGhpdFwiXTtcbiAgICB9IGVsc2UgaWYgKGlzRm9udCkge1xuICAgICAgZm9udE5hbWUgPSBmb250TWFwW2ZvbnRPckZhbWlseV0uZm9udE5hbWU7XG4gICAgICBmb250Q2xhc3NlcyA9IFtmb250T3JGYW1pbHldO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb250TmFtZSA9IHJldHJpZXZlVGV4dEZvbnROYW1lKGZvbnRPckZhbWlseSwgb3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZSk7XG4gICAgICBmb250Q2xhc3NlcyA9IFtmb250T3JGYW1pbHksIG9wdGlvbnMuZm9udFdlaWdodCwgb3B0aW9ucy5mb250U2hhcGVdO1xuICAgIH1cblxuICAgIGlmIChidWlsZENvbW1vbl9sb29rdXBTeW1ib2wodGV4dCwgZm9udE5hbWUsIG1vZGUpLm1ldHJpY3MpIHtcbiAgICAgIHJldHVybiBidWlsZENvbW1vbl9tYWtlU3ltYm9sKHRleHQsIGZvbnROYW1lLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChmb250Q2xhc3NlcykpO1xuICAgIH0gZWxzZSBpZiAobGlnYXR1cmVzLmhhc093blByb3BlcnR5KHRleHQpICYmIGZvbnROYW1lLnN1YnN0cigwLCAxMCkgPT09IFwiVHlwZXdyaXRlclwiKSB7XG4gICAgICAvLyBEZWNvbnN0cnVjdCBsaWdhdHVyZXMgaW4gbW9ub3NwYWNlIGZvbnRzIChcXHRleHR0dCwgXFx0dCkuXG4gICAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYnVpbGRDb21tb25fbWFrZVN5bWJvbCh0ZXh0W2ldLCBmb250TmFtZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQoZm9udENsYXNzZXMpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWlsZENvbW1vbl9tYWtlRnJhZ21lbnQocGFydHMpO1xuICAgIH1cbiAgfSAvLyBNYWtlcyBhIHN5bWJvbCBpbiB0aGUgZGVmYXVsdCBmb250IGZvciBtYXRob3JkcyBhbmQgdGV4dG9yZHMuXG5cblxuICBpZiAodHlwZSA9PT0gXCJtYXRob3JkXCIpIHtcbiAgICB2YXIgZm9udExvb2t1cCA9IGJ1aWxkQ29tbW9uX21hdGhkZWZhdWx0KHRleHQsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMpO1xuICAgIHJldHVybiBidWlsZENvbW1vbl9tYWtlU3ltYm9sKHRleHQsIGZvbnRMb29rdXAuZm9udE5hbWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KFtmb250TG9va3VwLmZvbnRDbGFzc10pKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcInRleHRvcmRcIikge1xuICAgIHZhciBmb250ID0gc3JjX3N5bWJvbHNbbW9kZV1bdGV4dF0gJiYgc3JjX3N5bWJvbHNbbW9kZV1bdGV4dF0uZm9udDtcblxuICAgIGlmIChmb250ID09PSBcImFtc1wiKSB7XG4gICAgICB2YXIgX2ZvbnROYW1lID0gcmV0cmlldmVUZXh0Rm9udE5hbWUoXCJhbXNybVwiLCBvcHRpb25zLmZvbnRXZWlnaHQsIG9wdGlvbnMuZm9udFNoYXBlKTtcblxuICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uX21ha2VTeW1ib2wodGV4dCwgX2ZvbnROYW1lLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChcImFtc3JtXCIsIG9wdGlvbnMuZm9udFdlaWdodCwgb3B0aW9ucy5mb250U2hhcGUpKTtcbiAgICB9IGVsc2UgaWYgKGZvbnQgPT09IFwibWFpblwiIHx8ICFmb250KSB7XG4gICAgICB2YXIgX2ZvbnROYW1lMiA9IHJldHJpZXZlVGV4dEZvbnROYW1lKFwidGV4dHJtXCIsIG9wdGlvbnMuZm9udFdlaWdodCwgb3B0aW9ucy5mb250U2hhcGUpO1xuXG4gICAgICByZXR1cm4gYnVpbGRDb21tb25fbWFrZVN5bWJvbCh0ZXh0LCBfZm9udE5hbWUyLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChvcHRpb25zLmZvbnRXZWlnaHQsIG9wdGlvbnMuZm9udFNoYXBlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvbnRzIGFkZGVkIGJ5IHBsdWdpbnNcbiAgICAgIHZhciBfZm9udE5hbWUzID0gcmV0cmlldmVUZXh0Rm9udE5hbWUoZm9udCwgb3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZSk7IC8vIFdlIGFkZCBmb250IG5hbWUgYXMgYSBjc3MgY2xhc3NcblxuXG4gICAgICByZXR1cm4gYnVpbGRDb21tb25fbWFrZVN5bWJvbCh0ZXh0LCBfZm9udE5hbWUzLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChfZm9udE5hbWUzLCBvcHRpb25zLmZvbnRXZWlnaHQsIG9wdGlvbnMuZm9udFNoYXBlKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgdHlwZTogXCIgKyB0eXBlICsgXCIgaW4gbWFrZU9yZFwiKTtcbiAgfVxufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHN1YnNlcXVlbnQgc3ltYm9sTm9kZXMgaGF2ZSB0aGUgc2FtZSBjbGFzc2VzLCBza2V3LCBtYXhGb250LFxuICogYW5kIHN0eWxlcy5cbiAqL1xuXG5cbnZhciBidWlsZENvbW1vbl9jYW5Db21iaW5lID0gZnVuY3Rpb24gY2FuQ29tYmluZShwcmV2LCBuZXh0KSB7XG4gIGlmIChjcmVhdGVDbGFzcyhwcmV2LmNsYXNzZXMpICE9PSBjcmVhdGVDbGFzcyhuZXh0LmNsYXNzZXMpIHx8IHByZXYuc2tldyAhPT0gbmV4dC5za2V3IHx8IHByZXYubWF4Rm9udFNpemUgIT09IG5leHQubWF4Rm9udFNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBzdHlsZSBpbiBwcmV2LnN0eWxlKSB7XG4gICAgaWYgKHByZXYuc3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpICYmIHByZXYuc3R5bGVbc3R5bGVdICE9PSBuZXh0LnN0eWxlW3N0eWxlXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9zdHlsZSBpbiBuZXh0LnN0eWxlKSB7XG4gICAgaWYgKG5leHQuc3R5bGUuaGFzT3duUHJvcGVydHkoX3N0eWxlKSAmJiBwcmV2LnN0eWxlW19zdHlsZV0gIT09IG5leHQuc3R5bGVbX3N0eWxlXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogQ29tYmluZSBjb25zZXF1ZXRpdmUgZG9tVHJlZS5zeW1ib2xOb2RlcyBpbnRvIGEgc2luZ2xlIHN5bWJvbE5vZGUuXG4gKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIG11dGF0ZXMgdGhlIGFyZ3VtZW50LlxuICovXG5cblxudmFyIGJ1aWxkQ29tbW9uX3RyeUNvbWJpbmVDaGFycyA9IGZ1bmN0aW9uIHRyeUNvbWJpbmVDaGFycyhjaGFycykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIHZhciBwcmV2ID0gY2hhcnNbaV07XG4gICAgdmFyIG5leHQgPSBjaGFyc1tpICsgMV07XG5cbiAgICBpZiAocHJldiBpbnN0YW5jZW9mIGRvbVRyZWVfU3ltYm9sTm9kZSAmJiBuZXh0IGluc3RhbmNlb2YgZG9tVHJlZV9TeW1ib2xOb2RlICYmIGJ1aWxkQ29tbW9uX2NhbkNvbWJpbmUocHJldiwgbmV4dCkpIHtcbiAgICAgIHByZXYudGV4dCArPSBuZXh0LnRleHQ7XG4gICAgICBwcmV2LmhlaWdodCA9IE1hdGgubWF4KHByZXYuaGVpZ2h0LCBuZXh0LmhlaWdodCk7XG4gICAgICBwcmV2LmRlcHRoID0gTWF0aC5tYXgocHJldi5kZXB0aCwgbmV4dC5kZXB0aCk7IC8vIFVzZSB0aGUgbGFzdCBjaGFyYWN0ZXIncyBpdGFsaWMgY29ycmVjdGlvbiBzaW5jZSB3ZSB1c2VcbiAgICAgIC8vIGl0IHRvIGFkZCBwYWRkaW5nIHRvIHRoZSByaWdodCBvZiB0aGUgc3BhbiBjcmVhdGVkIGZyb21cbiAgICAgIC8vIHRoZSBjb21iaW5lZCBjaGFyYWN0ZXJzLlxuXG4gICAgICBwcmV2Lml0YWxpYyA9IG5leHQuaXRhbGljO1xuICAgICAgY2hhcnMuc3BsaWNlKGkgKyAxLCAxKTtcbiAgICAgIGktLTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hhcnM7XG59O1xuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGhlaWdodCwgZGVwdGgsIGFuZCBtYXhGb250U2l6ZSBvZiBhbiBlbGVtZW50IGJhc2VkIG9uIGl0c1xuICogY2hpbGRyZW4uXG4gKi9cblxuXG52YXIgc2l6ZUVsZW1lbnRGcm9tQ2hpbGRyZW4gPSBmdW5jdGlvbiBzaXplRWxlbWVudEZyb21DaGlsZHJlbihlbGVtKSB7XG4gIHZhciBoZWlnaHQgPSAwO1xuICB2YXIgZGVwdGggPSAwO1xuICB2YXIgbWF4Rm9udFNpemUgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGVsZW0uY2hpbGRyZW5baV07XG5cbiAgICBpZiAoY2hpbGQuaGVpZ2h0ID4gaGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSBjaGlsZC5oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkLmRlcHRoID4gZGVwdGgpIHtcbiAgICAgIGRlcHRoID0gY2hpbGQuZGVwdGg7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkLm1heEZvbnRTaXplID4gbWF4Rm9udFNpemUpIHtcbiAgICAgIG1heEZvbnRTaXplID0gY2hpbGQubWF4Rm9udFNpemU7XG4gICAgfVxuICB9XG5cbiAgZWxlbS5oZWlnaHQgPSBoZWlnaHQ7XG4gIGVsZW0uZGVwdGggPSBkZXB0aDtcbiAgZWxlbS5tYXhGb250U2l6ZSA9IG1heEZvbnRTaXplO1xufTtcbi8qKlxuICogTWFrZXMgYSBzcGFuIHdpdGggdGhlIGdpdmVuIGxpc3Qgb2YgY2xhc3NlcywgbGlzdCBvZiBjaGlsZHJlbiwgYW5kIG9wdGlvbnMuXG4gKlxuICogVE9ETygjOTUzKTogRW5zdXJlIHRoYXQgYG9wdGlvbnNgIGlzIGFsd2F5cyBwcm92aWRlZCAoY3VycmVudGx5IHNvbWUgY2FsbFxuICogc2l0ZXMgZG9uJ3QgcGFzcyBpdCkgYW5kIG1ha2UgdGhlIHR5cGUgYmVsb3cgbWFuZGF0b3J5LlxuICogVE9ETzogYWRkIGEgc2VwYXJhdGUgYXJndW1lbnQgZm9yIG1hdGggY2xhc3MgKGUuZy4gYG1vcGAsIGBtYmluYCksIHdoaWNoXG4gKiBzaG91bGQgaWYgcHJlc2VudCBjb21lIGZpcnN0IGluIGBjbGFzc2VzYC5cbiAqL1xuXG5cbnZhciBidWlsZENvbW1vbl9tYWtlU3BhbiA9IGZ1bmN0aW9uIG1ha2VTcGFuKGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zLCBzdHlsZSkge1xuICB2YXIgc3BhbiA9IG5ldyBkb21UcmVlX1NwYW4oY2xhc3NlcywgY2hpbGRyZW4sIG9wdGlvbnMsIHN0eWxlKTtcbiAgc2l6ZUVsZW1lbnRGcm9tQ2hpbGRyZW4oc3Bhbik7XG4gIHJldHVybiBzcGFuO1xufTsgLy8gU1ZHIG9uZSBpcyBzaW1wbGVyIC0tIGRvZXNuJ3QgcmVxdWlyZSBoZWlnaHQsIGRlcHRoLCBtYXgtZm9udCBzZXR0aW5nLlxuLy8gVGhpcyBpcyBhbHNvIGEgc2VwYXJhdGUgbWV0aG9kIGZvciB0eXBlc2FmZXR5LlxuXG5cbnZhciBidWlsZENvbW1vbl9tYWtlU3ZnU3BhbiA9IGZ1bmN0aW9uIG1ha2VTdmdTcGFuKGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zLCBzdHlsZSkge1xuICByZXR1cm4gbmV3IGRvbVRyZWVfU3BhbihjbGFzc2VzLCBjaGlsZHJlbiwgb3B0aW9ucywgc3R5bGUpO1xufTtcblxudmFyIG1ha2VMaW5lU3BhbiA9IGZ1bmN0aW9uIG1ha2VMaW5lU3BhbihjbGFzc05hbWUsIG9wdGlvbnMsIHRoaWNrbmVzcykge1xuICB2YXIgbGluZSA9IGJ1aWxkQ29tbW9uX21ha2VTcGFuKFtjbGFzc05hbWVdLCBbXSwgb3B0aW9ucyk7XG4gIGxpbmUuaGVpZ2h0ID0gTWF0aC5tYXgodGhpY2tuZXNzIHx8IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kZWZhdWx0UnVsZVRoaWNrbmVzcywgb3B0aW9ucy5taW5SdWxlVGhpY2tuZXNzKTtcbiAgbGluZS5zdHlsZS5ib3JkZXJCb3R0b21XaWR0aCA9IGxpbmUuaGVpZ2h0ICsgXCJlbVwiO1xuICBsaW5lLm1heEZvbnRTaXplID0gMS4wO1xuICByZXR1cm4gbGluZTtcbn07XG4vKipcbiAqIE1ha2VzIGFuIGFuY2hvciB3aXRoIHRoZSBnaXZlbiBocmVmLCBsaXN0IG9mIGNsYXNzZXMsIGxpc3Qgb2YgY2hpbGRyZW4sXG4gKiBhbmQgb3B0aW9ucy5cbiAqL1xuXG5cbnZhciBidWlsZENvbW1vbl9tYWtlQW5jaG9yID0gZnVuY3Rpb24gbWFrZUFuY2hvcihocmVmLCBjbGFzc2VzLCBjaGlsZHJlbiwgb3B0aW9ucykge1xuICB2YXIgYW5jaG9yID0gbmV3IGRvbVRyZWVfQW5jaG9yKGhyZWYsIGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zKTtcbiAgc2l6ZUVsZW1lbnRGcm9tQ2hpbGRyZW4oYW5jaG9yKTtcbiAgcmV0dXJuIGFuY2hvcjtcbn07XG4vKipcbiAqIE1ha2VzIGEgZG9jdW1lbnQgZnJhZ21lbnQgd2l0aCB0aGUgZ2l2ZW4gbGlzdCBvZiBjaGlsZHJlbi5cbiAqL1xuXG5cbnZhciBidWlsZENvbW1vbl9tYWtlRnJhZ21lbnQgPSBmdW5jdGlvbiBtYWtlRnJhZ21lbnQoY2hpbGRyZW4pIHtcbiAgdmFyIGZyYWdtZW50ID0gbmV3IHRyZWVfRG9jdW1lbnRGcmFnbWVudChjaGlsZHJlbik7XG4gIHNpemVFbGVtZW50RnJvbUNoaWxkcmVuKGZyYWdtZW50KTtcbiAgcmV0dXJuIGZyYWdtZW50O1xufTtcbi8qKlxuICogV3JhcHMgZ3JvdXAgaW4gYSBzcGFuIGlmIGl0J3MgYSBkb2N1bWVudCBmcmFnbWVudCwgYWxsb3dpbmcgdG8gYXBwbHkgY2xhc3Nlc1xuICogYW5kIHN0eWxlc1xuICovXG5cblxudmFyIGJ1aWxkQ29tbW9uX3dyYXBGcmFnbWVudCA9IGZ1bmN0aW9uIHdyYXBGcmFnbWVudChncm91cCwgb3B0aW9ucykge1xuICBpZiAoZ3JvdXAgaW5zdGFuY2VvZiB0cmVlX0RvY3VtZW50RnJhZ21lbnQpIHtcbiAgICByZXR1cm4gYnVpbGRDb21tb25fbWFrZVNwYW4oW10sIFtncm91cF0sIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIGdyb3VwO1xufTsgLy8gVGhlc2UgYXJlIGV4YWN0IG9iamVjdCB0eXBlcyB0byBjYXRjaCB0eXBvcyBpbiB0aGUgbmFtZXMgb2YgdGhlIG9wdGlvbmFsIGZpZWxkcy5cblxuXG4vLyBDb21wdXRlcyB0aGUgdXBkYXRlZCBgY2hpbGRyZW5gIGxpc3QgYW5kIHRoZSBvdmVyYWxsIGRlcHRoLlxuLy9cbi8vIFRoaXMgaGVscGVyIGZ1bmN0aW9uIGZvciBtYWtlVkxpc3QgbWFrZXMgaXQgZWFzaWVyIHRvIGVuZm9yY2UgdHlwZSBzYWZldHkgYnlcbi8vIGFsbG93aW5nIGVhcmx5IGV4aXRzIChyZXR1cm5zKSBpbiB0aGUgbG9naWMuXG52YXIgZ2V0Vkxpc3RDaGlsZHJlbkFuZERlcHRoID0gZnVuY3Rpb24gZ2V0Vkxpc3RDaGlsZHJlbkFuZERlcHRoKHBhcmFtcykge1xuICBpZiAocGFyYW1zLnBvc2l0aW9uVHlwZSA9PT0gXCJpbmRpdmlkdWFsU2hpZnRcIikge1xuICAgIHZhciBvbGRDaGlsZHJlbiA9IHBhcmFtcy5jaGlsZHJlbjtcbiAgICB2YXIgY2hpbGRyZW4gPSBbb2xkQ2hpbGRyZW5bMF1dOyAvLyBBZGQgaW4ga2VybnMgdG8gdGhlIGxpc3Qgb2YgcGFyYW1zLmNoaWxkcmVuIHRvIGdldCBlYWNoIGVsZW1lbnQgdG8gYmVcbiAgICAvLyBzaGlmdGVkIHRvIHRoZSBjb3JyZWN0IHNwZWNpZmllZCBzaGlmdFxuXG4gICAgdmFyIF9kZXB0aCA9IC1vbGRDaGlsZHJlblswXS5zaGlmdCAtIG9sZENoaWxkcmVuWzBdLmVsZW0uZGVwdGg7XG5cbiAgICB2YXIgY3VyclBvcyA9IF9kZXB0aDtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgb2xkQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkaWZmID0gLW9sZENoaWxkcmVuW2ldLnNoaWZ0IC0gY3VyclBvcyAtIG9sZENoaWxkcmVuW2ldLmVsZW0uZGVwdGg7XG4gICAgICB2YXIgc2l6ZSA9IGRpZmYgLSAob2xkQ2hpbGRyZW5baSAtIDFdLmVsZW0uaGVpZ2h0ICsgb2xkQ2hpbGRyZW5baSAtIDFdLmVsZW0uZGVwdGgpO1xuICAgICAgY3VyclBvcyA9IGN1cnJQb3MgKyBkaWZmO1xuICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiBzaXplXG4gICAgICB9KTtcbiAgICAgIGNoaWxkcmVuLnB1c2gob2xkQ2hpbGRyZW5baV0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICBkZXB0aDogX2RlcHRoXG4gICAgfTtcbiAgfVxuXG4gIHZhciBkZXB0aDtcblxuICBpZiAocGFyYW1zLnBvc2l0aW9uVHlwZSA9PT0gXCJ0b3BcIikge1xuICAgIC8vIFdlIGFsd2F5cyBzdGFydCBhdCB0aGUgYm90dG9tLCBzbyBjYWxjdWxhdGUgdGhlIGJvdHRvbSBieSBhZGRpbmcgdXBcbiAgICAvLyBhbGwgdGhlIHNpemVzXG4gICAgdmFyIGJvdHRvbSA9IHBhcmFtcy5wb3NpdGlvbkRhdGE7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcGFyYW1zLmNoaWxkcmVuLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGNoaWxkID0gcGFyYW1zLmNoaWxkcmVuW19pXTtcbiAgICAgIGJvdHRvbSAtPSBjaGlsZC50eXBlID09PSBcImtlcm5cIiA/IGNoaWxkLnNpemUgOiBjaGlsZC5lbGVtLmhlaWdodCArIGNoaWxkLmVsZW0uZGVwdGg7XG4gICAgfVxuXG4gICAgZGVwdGggPSBib3R0b207XG4gIH0gZWxzZSBpZiAocGFyYW1zLnBvc2l0aW9uVHlwZSA9PT0gXCJib3R0b21cIikge1xuICAgIGRlcHRoID0gLXBhcmFtcy5wb3NpdGlvbkRhdGE7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBwYXJhbXMuY2hpbGRyZW5bMF07XG5cbiAgICBpZiAoZmlyc3RDaGlsZC50eXBlICE9PSBcImVsZW1cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBjaGlsZCBtdXN0IGhhdmUgdHlwZSBcImVsZW1cIi4nKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLnBvc2l0aW9uVHlwZSA9PT0gXCJzaGlmdFwiKSB7XG4gICAgICBkZXB0aCA9IC1maXJzdENoaWxkLmVsZW0uZGVwdGggLSBwYXJhbXMucG9zaXRpb25EYXRhO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zLnBvc2l0aW9uVHlwZSA9PT0gXCJmaXJzdEJhc2VsaW5lXCIpIHtcbiAgICAgIGRlcHRoID0gLWZpcnN0Q2hpbGQuZWxlbS5kZXB0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwb3NpdGlvblR5cGUgXCIgKyBwYXJhbXMucG9zaXRpb25UeXBlICsgXCIuXCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2hpbGRyZW46IHBhcmFtcy5jaGlsZHJlbixcbiAgICBkZXB0aDogZGVwdGhcbiAgfTtcbn07XG4vKipcbiAqIE1ha2VzIGEgdmVydGljYWwgbGlzdCBieSBzdGFja2luZyBlbGVtZW50cyBhbmQga2VybnMgb24gdG9wIG9mIGVhY2ggb3RoZXIuXG4gKiBBbGxvd3MgZm9yIG1hbnkgZGlmZmVyZW50IHdheXMgb2Ygc3BlY2lmeWluZyB0aGUgcG9zaXRpb25pbmcgbWV0aG9kLlxuICpcbiAqIFNlZSBWTGlzdFBhcmFtIGRvY3VtZW50YXRpb24gYWJvdmUuXG4gKi9cblxuXG52YXIgYnVpbGRDb21tb25fbWFrZVZMaXN0ID0gZnVuY3Rpb24gbWFrZVZMaXN0KHBhcmFtcywgb3B0aW9ucykge1xuICB2YXIgX2dldFZMaXN0Q2hpbGRyZW5BbmREID0gZ2V0Vkxpc3RDaGlsZHJlbkFuZERlcHRoKHBhcmFtcyksXG4gICAgICBjaGlsZHJlbiA9IF9nZXRWTGlzdENoaWxkcmVuQW5kRC5jaGlsZHJlbixcbiAgICAgIGRlcHRoID0gX2dldFZMaXN0Q2hpbGRyZW5BbmRELmRlcHRoOyAvLyBDcmVhdGUgYSBzdHJ1dCB0aGF0IGlzIHRhbGxlciB0aGFuIGFueSBsaXN0IGl0ZW0uIFRoZSBzdHJ1dCBpcyBhZGRlZCB0b1xuICAvLyBlYWNoIGl0ZW0sIHdoZXJlIGl0IHdpbGwgZGV0ZXJtaW5lIHRoZSBpdGVtJ3MgYmFzZWxpbmUuIFNpbmNlIGl0IGhhc1xuICAvLyBgb3ZlcmZsb3c6aGlkZGVuYCwgdGhlIHN0cnV0J3MgdG9wIGVkZ2Ugd2lsbCBzaXQgb24gdGhlIGl0ZW0ncyBsaW5lIGJveCdzXG4gIC8vIHRvcCBlZGdlIGFuZCB0aGUgc3RydXQncyBib3R0b20gZWRnZSB3aWxsIHNpdCBvbiB0aGUgaXRlbSdzIGJhc2VsaW5lLFxuICAvLyB3aXRoIG5vIGFkZGl0aW9uYWwgbGluZS1oZWlnaHQgc3BhY2luZy4gVGhpcyBhbGxvd3MgdGhlIGl0ZW0gYmFzZWxpbmUgdG9cbiAgLy8gYmUgcG9zaXRpb25lZCBwcmVjaXNlbHkgd2l0aG91dCB3b3JyeWluZyBhYm91dCBmb250IGFzY2VudCBhbmRcbiAgLy8gbGluZS1oZWlnaHQuXG5cblxuICB2YXIgcHN0cnV0U2l6ZSA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiZWxlbVwiKSB7XG4gICAgICB2YXIgZWxlbSA9IGNoaWxkLmVsZW07XG4gICAgICBwc3RydXRTaXplID0gTWF0aC5tYXgocHN0cnV0U2l6ZSwgZWxlbS5tYXhGb250U2l6ZSwgZWxlbS5oZWlnaHQpO1xuICAgIH1cbiAgfVxuXG4gIHBzdHJ1dFNpemUgKz0gMjtcbiAgdmFyIHBzdHJ1dCA9IGJ1aWxkQ29tbW9uX21ha2VTcGFuKFtcInBzdHJ1dFwiXSwgW10pO1xuICBwc3RydXQuc3R5bGUuaGVpZ2h0ID0gcHN0cnV0U2l6ZSArIFwiZW1cIjsgLy8gQ3JlYXRlIGEgbmV3IGxpc3Qgb2YgYWN0dWFsIGNoaWxkcmVuIGF0IHRoZSBjb3JyZWN0IG9mZnNldHNcblxuICB2YXIgcmVhbENoaWxkcmVuID0gW107XG4gIHZhciBtaW5Qb3MgPSBkZXB0aDtcbiAgdmFyIG1heFBvcyA9IGRlcHRoO1xuICB2YXIgY3VyclBvcyA9IGRlcHRoO1xuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGNoaWxkcmVuLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX2NoaWxkID0gY2hpbGRyZW5bX2kyXTtcblxuICAgIGlmIChfY2hpbGQudHlwZSA9PT0gXCJrZXJuXCIpIHtcbiAgICAgIGN1cnJQb3MgKz0gX2NoaWxkLnNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfZWxlbSA9IF9jaGlsZC5lbGVtO1xuICAgICAgdmFyIGNsYXNzZXMgPSBfY2hpbGQud3JhcHBlckNsYXNzZXMgfHwgW107XG4gICAgICB2YXIgc3R5bGUgPSBfY2hpbGQud3JhcHBlclN0eWxlIHx8IHt9O1xuICAgICAgdmFyIGNoaWxkV3JhcCA9IGJ1aWxkQ29tbW9uX21ha2VTcGFuKGNsYXNzZXMsIFtwc3RydXQsIF9lbGVtXSwgdW5kZWZpbmVkLCBzdHlsZSk7XG4gICAgICBjaGlsZFdyYXAuc3R5bGUudG9wID0gLXBzdHJ1dFNpemUgLSBjdXJyUG9zIC0gX2VsZW0uZGVwdGggKyBcImVtXCI7XG5cbiAgICAgIGlmIChfY2hpbGQubWFyZ2luTGVmdCkge1xuICAgICAgICBjaGlsZFdyYXAuc3R5bGUubWFyZ2luTGVmdCA9IF9jaGlsZC5tYXJnaW5MZWZ0O1xuICAgICAgfVxuXG4gICAgICBpZiAoX2NoaWxkLm1hcmdpblJpZ2h0KSB7XG4gICAgICAgIGNoaWxkV3JhcC5zdHlsZS5tYXJnaW5SaWdodCA9IF9jaGlsZC5tYXJnaW5SaWdodDtcbiAgICAgIH1cblxuICAgICAgcmVhbENoaWxkcmVuLnB1c2goY2hpbGRXcmFwKTtcbiAgICAgIGN1cnJQb3MgKz0gX2VsZW0uaGVpZ2h0ICsgX2VsZW0uZGVwdGg7XG4gICAgfVxuXG4gICAgbWluUG9zID0gTWF0aC5taW4obWluUG9zLCBjdXJyUG9zKTtcbiAgICBtYXhQb3MgPSBNYXRoLm1heChtYXhQb3MsIGN1cnJQb3MpO1xuICB9IC8vIFRoZSB2bGlzdCBjb250ZW50cyBnbyBpbiBhIHRhYmxlLWNlbGwgd2l0aCBgdmVydGljYWwtYWxpZ246Ym90dG9tYC5cbiAgLy8gVGhpcyBjZWxsJ3MgYm90dG9tIGVkZ2Ugd2lsbCBkZXRlcm1pbmUgdGhlIGNvbnRhaW5pbmcgdGFibGUncyBiYXNlbGluZVxuICAvLyB3aXRob3V0IG92ZXJseSBleHBhbmRpbmcgdGhlIGNvbnRhaW5pbmcgbGluZS1ib3guXG5cblxuICB2YXIgdmxpc3QgPSBidWlsZENvbW1vbl9tYWtlU3BhbihbXCJ2bGlzdFwiXSwgcmVhbENoaWxkcmVuKTtcbiAgdmxpc3Quc3R5bGUuaGVpZ2h0ID0gbWF4UG9zICsgXCJlbVwiOyAvLyBBIHNlY29uZCByb3cgaXMgdXNlZCBpZiBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSB2bGlzdCdzIGRlcHRoLlxuXG4gIHZhciByb3dzO1xuXG4gIGlmIChtaW5Qb3MgPCAwKSB7XG4gICAgLy8gV2Ugd2lsbCBkZWZpbmUgZGVwdGggaW4gYW4gZW1wdHkgc3BhbiB3aXRoIGRpc3BsYXk6IHRhYmxlLWNlbGwuXG4gICAgLy8gSXQgc2hvdWxkIHJlbmRlciB3aXRoIHRoZSBoZWlnaHQgdGhhdCB3ZSBkZWZpbmUuIEJ1dCBDaHJvbWUsIGluXG4gICAgLy8gY29udGVudGVkaXRhYmxlIG1vZGUgb25seSwgdHJlYXRzIHRoYXQgc3BhbiBhcyBpZiBpdCBjb250YWlucyBzb21lXG4gICAgLy8gdGV4dCBjb250ZW50LiBBbmQgdGhhdCBtaW4taGVpZ2h0IG92ZXItcmlkZXMgb3VyIGRlc2lyZWQgaGVpZ2h0LlxuICAgIC8vIFNvIHdlIHB1dCBhbm90aGVyIGVtcHR5IHNwYW4gaW5zaWRlIHRoZSBkZXB0aCBzdHJ1dCBzcGFuLlxuICAgIHZhciBlbXB0eVNwYW4gPSBidWlsZENvbW1vbl9tYWtlU3BhbihbXSwgW10pO1xuICAgIHZhciBkZXB0aFN0cnV0ID0gYnVpbGRDb21tb25fbWFrZVNwYW4oW1widmxpc3RcIl0sIFtlbXB0eVNwYW5dKTtcbiAgICBkZXB0aFN0cnV0LnN0eWxlLmhlaWdodCA9IC1taW5Qb3MgKyBcImVtXCI7IC8vIFNhZmFyaSB3YW50cyB0aGUgZmlyc3Qgcm93IHRvIGhhdmUgaW5saW5lIGNvbnRlbnQ7IG90aGVyd2lzZSBpdFxuICAgIC8vIHB1dHMgdGhlIGJvdHRvbSBvZiB0aGUgKnNlY29uZCogcm93IG9uIHRoZSBiYXNlbGluZS5cblxuICAgIHZhciB0b3BTdHJ1dCA9IGJ1aWxkQ29tbW9uX21ha2VTcGFuKFtcInZsaXN0LXNcIl0sIFtuZXcgZG9tVHJlZV9TeW1ib2xOb2RlKFwiXFx1MjAwQlwiKV0pO1xuICAgIHJvd3MgPSBbYnVpbGRDb21tb25fbWFrZVNwYW4oW1widmxpc3QtclwiXSwgW3ZsaXN0LCB0b3BTdHJ1dF0pLCBidWlsZENvbW1vbl9tYWtlU3BhbihbXCJ2bGlzdC1yXCJdLCBbZGVwdGhTdHJ1dF0pXTtcbiAgfSBlbHNlIHtcbiAgICByb3dzID0gW2J1aWxkQ29tbW9uX21ha2VTcGFuKFtcInZsaXN0LXJcIl0sIFt2bGlzdF0pXTtcbiAgfVxuXG4gIHZhciB2dGFibGUgPSBidWlsZENvbW1vbl9tYWtlU3BhbihbXCJ2bGlzdC10XCJdLCByb3dzKTtcblxuICBpZiAocm93cy5sZW5ndGggPT09IDIpIHtcbiAgICB2dGFibGUuY2xhc3Nlcy5wdXNoKFwidmxpc3QtdDJcIik7XG4gIH1cblxuICB2dGFibGUuaGVpZ2h0ID0gbWF4UG9zO1xuICB2dGFibGUuZGVwdGggPSAtbWluUG9zO1xuICByZXR1cm4gdnRhYmxlO1xufTsgLy8gR2x1ZSBpcyBhIGNvbmNlcHQgZnJvbSBUZVggd2hpY2ggaXMgYSBmbGV4aWJsZSBzcGFjZSBiZXR3ZWVuIGVsZW1lbnRzIGluXG4vLyBlaXRoZXIgYSB2ZXJ0aWNhbCBvciBob3Jpem9udGFsIGxpc3QuIEluIEthVGVYLCBhdCBsZWFzdCBmb3Igbm93LCBpdCdzXG4vLyBzdGF0aWMgc3BhY2UgYmV0d2VlbiBlbGVtZW50cyBpbiBhIGhvcml6b250YWwgbGF5b3V0LlxuXG5cbnZhciBidWlsZENvbW1vbl9tYWtlR2x1ZSA9IGZ1bmN0aW9uIG1ha2VHbHVlKG1lYXN1cmVtZW50LCBvcHRpb25zKSB7XG4gIC8vIE1ha2UgYW4gZW1wdHkgc3BhbiBmb3IgdGhlIHNwYWNlXG4gIHZhciBydWxlID0gYnVpbGRDb21tb25fbWFrZVNwYW4oW1wibXNwYWNlXCJdLCBbXSwgb3B0aW9ucyk7XG4gIHZhciBzaXplID0gdW5pdHNfY2FsY3VsYXRlU2l6ZShtZWFzdXJlbWVudCwgb3B0aW9ucyk7XG4gIHJ1bGUuc3R5bGUubWFyZ2luUmlnaHQgPSBzaXplICsgXCJlbVwiO1xuICByZXR1cm4gcnVsZTtcbn07IC8vIFRha2VzIGZvbnQgb3B0aW9ucywgYW5kIHJldHVybnMgdGhlIGFwcHJvcHJpYXRlIGZvbnRMb29rdXAgbmFtZVxuXG5cbnZhciByZXRyaWV2ZVRleHRGb250TmFtZSA9IGZ1bmN0aW9uIHJldHJpZXZlVGV4dEZvbnROYW1lKGZvbnRGYW1pbHksIGZvbnRXZWlnaHQsIGZvbnRTaGFwZSkge1xuICB2YXIgYmFzZUZvbnROYW1lID0gXCJcIjtcblxuICBzd2l0Y2ggKGZvbnRGYW1pbHkpIHtcbiAgICBjYXNlIFwiYW1zcm1cIjpcbiAgICAgIGJhc2VGb250TmFtZSA9IFwiQU1TXCI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0ZXh0cm1cIjpcbiAgICAgIGJhc2VGb250TmFtZSA9IFwiTWFpblwiO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGV4dHNmXCI6XG4gICAgICBiYXNlRm9udE5hbWUgPSBcIlNhbnNTZXJpZlwiO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGV4dHR0XCI6XG4gICAgICBiYXNlRm9udE5hbWUgPSBcIlR5cGV3cml0ZXJcIjtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGJhc2VGb250TmFtZSA9IGZvbnRGYW1pbHk7XG4gICAgLy8gdXNlIGZvbnRzIGFkZGVkIGJ5IGEgcGx1Z2luXG4gIH1cblxuICB2YXIgZm9udFN0eWxlc05hbWU7XG5cbiAgaWYgKGZvbnRXZWlnaHQgPT09IFwidGV4dGJmXCIgJiYgZm9udFNoYXBlID09PSBcInRleHRpdFwiKSB7XG4gICAgZm9udFN0eWxlc05hbWUgPSBcIkJvbGRJdGFsaWNcIjtcbiAgfSBlbHNlIGlmIChmb250V2VpZ2h0ID09PSBcInRleHRiZlwiKSB7XG4gICAgZm9udFN0eWxlc05hbWUgPSBcIkJvbGRcIjtcbiAgfSBlbHNlIGlmIChmb250V2VpZ2h0ID09PSBcInRleHRpdFwiKSB7XG4gICAgZm9udFN0eWxlc05hbWUgPSBcIkl0YWxpY1wiO1xuICB9IGVsc2Uge1xuICAgIGZvbnRTdHlsZXNOYW1lID0gXCJSZWd1bGFyXCI7XG4gIH1cblxuICByZXR1cm4gYmFzZUZvbnROYW1lICsgXCItXCIgKyBmb250U3R5bGVzTmFtZTtcbn07XG4vKipcbiAqIE1hcHMgVGVYIGZvbnQgY29tbWFuZHMgdG8gb2JqZWN0cyBjb250YWluaW5nOlxuICogLSB2YXJpYW50OiBzdHJpbmcgdXNlZCBmb3IgXCJtYXRodmFyaWFudFwiIGF0dHJpYnV0ZSBpbiBidWlsZE1hdGhNTC5qc1xuICogLSBmb250TmFtZTogdGhlIFwic3R5bGVcIiBwYXJhbWV0ZXIgdG8gZm9udE1ldHJpY3MuZ2V0Q2hhcmFjdGVyTWV0cmljc1xuICovXG4vLyBBIG1hcCBiZXR3ZWVuIHRleCBmb250IGNvbW1hbmRzIGFuIE1hdGhNTCBtYXRodmFyaWFudCBhdHRyaWJ1dGUgdmFsdWVzXG5cblxudmFyIGZvbnRNYXAgPSB7XG4gIC8vIHN0eWxlc1xuICBcIm1hdGhiZlwiOiB7XG4gICAgdmFyaWFudDogXCJib2xkXCIsXG4gICAgZm9udE5hbWU6IFwiTWFpbi1Cb2xkXCJcbiAgfSxcbiAgXCJtYXRocm1cIjoge1xuICAgIHZhcmlhbnQ6IFwibm9ybWFsXCIsXG4gICAgZm9udE5hbWU6IFwiTWFpbi1SZWd1bGFyXCJcbiAgfSxcbiAgXCJ0ZXh0aXRcIjoge1xuICAgIHZhcmlhbnQ6IFwiaXRhbGljXCIsXG4gICAgZm9udE5hbWU6IFwiTWFpbi1JdGFsaWNcIlxuICB9LFxuICBcIm1hdGhpdFwiOiB7XG4gICAgdmFyaWFudDogXCJpdGFsaWNcIixcbiAgICBmb250TmFtZTogXCJNYWluLUl0YWxpY1wiXG4gIH0sXG4gIC8vIERlZmF1bHQgbWF0aCBmb250LCBcIm1hdGhub3JtYWxcIiBhbmQgXCJib2xkc3ltYm9sXCIgYXJlIG1pc3NpbmcgYmVjYXVzZSB0aGV5XG4gIC8vIHJlcXVpcmUgdGhlIHVzZSBvZiBzZXZlcmFsIGZvbnRzOiBNYWluLUl0YWxpYyBhbmQgTWF0aC1JdGFsaWMgZm9yIGRlZmF1bHRcbiAgLy8gbWF0aCBmb250LCBNYWluLUl0YWxpYywgTWF0aC1JdGFsaWMsIENhbGlncmFwaGljIGZvciBcIm1hdGhub3JtYWxcIiwgYW5kXG4gIC8vIE1hdGgtQm9sZEl0YWxpYyBhbmQgTWFpbi1Cb2xkIGZvciBcImJvbGRzeW1ib2xcIi4gIFRoaXMgaXMgaGFuZGxlZCBieSBhXG4gIC8vIHNwZWNpYWwgY2FzZSBpbiBtYWtlT3JkIHdoaWNoIGVuZHMgdXAgY2FsbGluZyBtYXRoZGVmYXVsdCwgbWF0aG5vcm1hbCxcbiAgLy8gYW5kIGJvbGRzeW1ib2wuXG4gIC8vIGZhbWlsaWVzXG4gIFwibWF0aGJiXCI6IHtcbiAgICB2YXJpYW50OiBcImRvdWJsZS1zdHJ1Y2tcIixcbiAgICBmb250TmFtZTogXCJBTVMtUmVndWxhclwiXG4gIH0sXG4gIFwibWF0aGNhbFwiOiB7XG4gICAgdmFyaWFudDogXCJzY3JpcHRcIixcbiAgICBmb250TmFtZTogXCJDYWxpZ3JhcGhpYy1SZWd1bGFyXCJcbiAgfSxcbiAgXCJtYXRoZnJha1wiOiB7XG4gICAgdmFyaWFudDogXCJmcmFrdHVyXCIsXG4gICAgZm9udE5hbWU6IFwiRnJha3R1ci1SZWd1bGFyXCJcbiAgfSxcbiAgXCJtYXRoc2NyXCI6IHtcbiAgICB2YXJpYW50OiBcInNjcmlwdFwiLFxuICAgIGZvbnROYW1lOiBcIlNjcmlwdC1SZWd1bGFyXCJcbiAgfSxcbiAgXCJtYXRoc2ZcIjoge1xuICAgIHZhcmlhbnQ6IFwic2Fucy1zZXJpZlwiLFxuICAgIGZvbnROYW1lOiBcIlNhbnNTZXJpZi1SZWd1bGFyXCJcbiAgfSxcbiAgXCJtYXRodHRcIjoge1xuICAgIHZhcmlhbnQ6IFwibW9ub3NwYWNlXCIsXG4gICAgZm9udE5hbWU6IFwiVHlwZXdyaXRlci1SZWd1bGFyXCJcbiAgfVxufTtcbnZhciBzdmdEYXRhID0ge1xuICAvLyAgIHBhdGgsIHdpZHRoLCBoZWlnaHRcbiAgdmVjOiBbXCJ2ZWNcIiwgMC40NzEsIDAuNzE0XSxcbiAgLy8gdmFsdWVzIGZyb20gdGhlIGZvbnQgZ2x5cGhcbiAgb2lpbnRTaXplMTogW1wib2lpbnRTaXplMVwiLCAwLjk1NywgMC40OTldLFxuICAvLyBvdmFsIHRvIG92ZXJsYXkgdGhlIGludGVncmFuZFxuICBvaWludFNpemUyOiBbXCJvaWludFNpemUyXCIsIDEuNDcyLCAwLjY1OV0sXG4gIG9paWludFNpemUxOiBbXCJvaWlpbnRTaXplMVwiLCAxLjMwNCwgMC40OTldLFxuICBvaWlpbnRTaXplMjogW1wib2lpaW50U2l6ZTJcIiwgMS45OCwgMC42NTldXG59O1xuXG52YXIgYnVpbGRDb21tb25fc3RhdGljU3ZnID0gZnVuY3Rpb24gc3RhdGljU3ZnKHZhbHVlLCBvcHRpb25zKSB7XG4gIC8vIENyZWF0ZSBhIHNwYW4gd2l0aCBpbmxpbmUgU1ZHIGZvciB0aGUgZWxlbWVudC5cbiAgdmFyIF9zdmdEYXRhJHZhbHVlID0gc3ZnRGF0YVt2YWx1ZV0sXG4gICAgICBwYXRoTmFtZSA9IF9zdmdEYXRhJHZhbHVlWzBdLFxuICAgICAgd2lkdGggPSBfc3ZnRGF0YSR2YWx1ZVsxXSxcbiAgICAgIGhlaWdodCA9IF9zdmdEYXRhJHZhbHVlWzJdO1xuICB2YXIgcGF0aCA9IG5ldyBkb21UcmVlX1BhdGhOb2RlKHBhdGhOYW1lKTtcbiAgdmFyIHN2Z05vZGUgPSBuZXcgU3ZnTm9kZShbcGF0aF0sIHtcbiAgICBcIndpZHRoXCI6IHdpZHRoICsgXCJlbVwiLFxuICAgIFwiaGVpZ2h0XCI6IGhlaWdodCArIFwiZW1cIixcbiAgICAvLyBPdmVycmlkZSBDU1MgcnVsZSBgLmthdGV4IHN2ZyB7IHdpZHRoOiAxMDAlIH1gXG4gICAgXCJzdHlsZVwiOiBcIndpZHRoOlwiICsgd2lkdGggKyBcImVtXCIsXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIFwiICsgMTAwMCAqIHdpZHRoICsgXCIgXCIgKyAxMDAwICogaGVpZ2h0LFxuICAgIFwicHJlc2VydmVBc3BlY3RSYXRpb1wiOiBcInhNaW5ZTWluXCJcbiAgfSk7XG4gIHZhciBzcGFuID0gYnVpbGRDb21tb25fbWFrZVN2Z1NwYW4oW1wib3ZlcmxheVwiXSwgW3N2Z05vZGVdLCBvcHRpb25zKTtcbiAgc3Bhbi5oZWlnaHQgPSBoZWlnaHQ7XG4gIHNwYW4uc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJlbVwiO1xuICBzcGFuLnN0eWxlLndpZHRoID0gd2lkdGggKyBcImVtXCI7XG4gIHJldHVybiBzcGFuO1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgYnVpbGRDb21tb24gPSAoe1xuICBmb250TWFwOiBmb250TWFwLFxuICBtYWtlU3ltYm9sOiBidWlsZENvbW1vbl9tYWtlU3ltYm9sLFxuICBtYXRoc3ltOiBidWlsZENvbW1vbl9tYXRoc3ltLFxuICBtYWtlU3BhbjogYnVpbGRDb21tb25fbWFrZVNwYW4sXG4gIG1ha2VTdmdTcGFuOiBidWlsZENvbW1vbl9tYWtlU3ZnU3BhbixcbiAgbWFrZUxpbmVTcGFuOiBtYWtlTGluZVNwYW4sXG4gIG1ha2VBbmNob3I6IGJ1aWxkQ29tbW9uX21ha2VBbmNob3IsXG4gIG1ha2VGcmFnbWVudDogYnVpbGRDb21tb25fbWFrZUZyYWdtZW50LFxuICB3cmFwRnJhZ21lbnQ6IGJ1aWxkQ29tbW9uX3dyYXBGcmFnbWVudCxcbiAgbWFrZVZMaXN0OiBidWlsZENvbW1vbl9tYWtlVkxpc3QsXG4gIG1ha2VPcmQ6IGJ1aWxkQ29tbW9uX21ha2VPcmQsXG4gIG1ha2VHbHVlOiBidWlsZENvbW1vbl9tYWtlR2x1ZSxcbiAgc3RhdGljU3ZnOiBidWlsZENvbW1vbl9zdGF0aWNTdmcsXG4gIHN2Z0RhdGE6IHN2Z0RhdGEsXG4gIHRyeUNvbWJpbmVDaGFyczogYnVpbGRDb21tb25fdHJ5Q29tYmluZUNoYXJzXG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3BhcnNlTm9kZS5qc1xuXG5cbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBub2RlIGlzIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCByZXR1cm5zIGl0IHdpdGggc3RyaWN0ZXJcbiAqIHR5cGluZy4gVGhyb3dzIGlmIHRoZSBub2RlJ3MgdHlwZSBkb2VzIG5vdCBtYXRjaC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0Tm9kZVR5cGUobm9kZSwgdHlwZSkge1xuICB2YXIgdHlwZWROb2RlID0gY2hlY2tOb2RlVHlwZShub2RlLCB0eXBlKTtcblxuICBpZiAoIXR5cGVkTm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG5vZGUgb2YgdHlwZSBcIiArIHR5cGUgKyBcIiwgYnV0IGdvdCBcIiArIChub2RlID8gXCJub2RlIG9mIHR5cGUgXCIgKyBub2RlLnR5cGUgOiBTdHJpbmcobm9kZSkpKTtcbiAgfSAvLyAkRmxvd0ZpeE1lOiBVbnN1cmUgd2h5LlxuXG5cbiAgcmV0dXJuIHR5cGVkTm9kZTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbm9kZSBtb3JlIHN0cmljdGx5IHR5cGVkIGlmZiBpdCBpcyBvZiB0aGUgZ2l2ZW4gdHlwZS4gT3RoZXJ3aXNlLFxuICogcmV0dXJucyBudWxsLlxuICovXG5cbmZ1bmN0aW9uIGNoZWNrTm9kZVR5cGUobm9kZSwgdHlwZSkge1xuICBpZiAobm9kZSAmJiBub2RlLnR5cGUgPT09IHR5cGUpIHtcbiAgICAvLyBUaGUgZGVmaW5pdGlvbiBvZiBQYXJzZU5vZGU8VFlQRT4gZG9lc24ndCBjb21tdW5pY2F0ZSB0byBmbG93IHRoYXRcbiAgICAvLyBgdHlwZTogVFlQRWAgKGFzIHRoYXQncyBub3QgZXhwbGljaXRseSBtZW50aW9uZWQgYW55d2hlcmUpLCB0aG91Z2ggdGhhdFxuICAgIC8vIGhhcHBlbnMgdG8gYmUgdHJ1ZSBmb3IgYWxsIG91ciB2YWx1ZSB0eXBlcy5cbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBub2RlIGlzIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCByZXR1cm5zIGl0IHdpdGggc3RyaWN0ZXJcbiAqIHR5cGluZy4gVGhyb3dzIGlmIHRoZSBub2RlJ3MgdHlwZSBkb2VzIG5vdCBtYXRjaC5cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRBdG9tRmFtaWx5KG5vZGUsIGZhbWlseSkge1xuICB2YXIgdHlwZWROb2RlID0gY2hlY2tBdG9tRmFtaWx5KG5vZGUsIGZhbWlseSk7XG5cbiAgaWYgKCF0eXBlZE5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBub2RlIG9mIHR5cGUgXFxcImF0b21cXFwiIGFuZCBmYW1pbHkgXFxcIlwiICsgZmFtaWx5ICsgXCJcXFwiLCBidXQgZ290IFwiICsgKG5vZGUgPyBub2RlLnR5cGUgPT09IFwiYXRvbVwiID8gXCJhdG9tIG9mIGZhbWlseSBcIiArIG5vZGUuZmFtaWx5IDogXCJub2RlIG9mIHR5cGUgXCIgKyBub2RlLnR5cGUgOiBTdHJpbmcobm9kZSkpKTtcbiAgfVxuXG4gIHJldHVybiB0eXBlZE5vZGU7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG5vZGUgbW9yZSBzdHJpY3RseSB0eXBlZCBpZmYgaXQgaXMgb2YgdGhlIGdpdmVuIHR5cGUuIE90aGVyd2lzZSxcbiAqIHJldHVybnMgbnVsbC5cbiAqL1xuXG5mdW5jdGlvbiBjaGVja0F0b21GYW1pbHkobm9kZSwgZmFtaWx5KSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUudHlwZSA9PT0gXCJhdG9tXCIgJiYgbm9kZS5mYW1pbHkgPT09IGZhbWlseSA/IG5vZGUgOiBudWxsO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBub2RlIG1vcmUgc3RyaWN0bHkgdHlwZWQgaWZmIGl0IGlzIG9mIHRoZSBnaXZlbiB0eXBlLiBPdGhlcndpc2UsXG4gKiByZXR1cm5zIG51bGwuXG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0U3ltYm9sTm9kZVR5cGUobm9kZSkge1xuICB2YXIgdHlwZWROb2RlID0gY2hlY2tTeW1ib2xOb2RlVHlwZShub2RlKTtcblxuICBpZiAoIXR5cGVkTm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG5vZGUgb2Ygc3ltYm9sIGdyb3VwIHR5cGUsIGJ1dCBnb3QgXCIgKyAobm9kZSA/IFwibm9kZSBvZiB0eXBlIFwiICsgbm9kZS50eXBlIDogU3RyaW5nKG5vZGUpKSk7XG4gIH1cblxuICByZXR1cm4gdHlwZWROb2RlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBub2RlIG1vcmUgc3RyaWN0bHkgdHlwZWQgaWZmIGl0IGlzIG9mIHRoZSBnaXZlbiB0eXBlLiBPdGhlcndpc2UsXG4gKiByZXR1cm5zIG51bGwuXG4gKi9cblxuZnVuY3Rpb24gY2hlY2tTeW1ib2xOb2RlVHlwZShub2RlKSB7XG4gIGlmIChub2RlICYmIChub2RlLnR5cGUgPT09IFwiYXRvbVwiIHx8IE5PTl9BVE9NUy5oYXNPd25Qcm9wZXJ0eShub2RlLnR5cGUpKSkge1xuICAgIC8vICRGbG93Rml4TWVcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc3BhY2luZ0RhdGEuanNcbi8qKlxuICogRGVzY3JpYmVzIHNwYWNlcyBiZXR3ZWVuIGRpZmZlcmVudCBjbGFzc2VzIG9mIGF0b21zLlxuICovXG52YXIgdGhpbnNwYWNlID0ge1xuICBudW1iZXI6IDMsXG4gIHVuaXQ6IFwibXVcIlxufTtcbnZhciBtZWRpdW1zcGFjZSA9IHtcbiAgbnVtYmVyOiA0LFxuICB1bml0OiBcIm11XCJcbn07XG52YXIgdGhpY2tzcGFjZSA9IHtcbiAgbnVtYmVyOiA1LFxuICB1bml0OiBcIm11XCJcbn07IC8vIE1ha2luZyB0aGUgdHlwZSBiZWxvdyBleGFjdCB3aXRoIGFsbCBvcHRpb25hbCBmaWVsZHMgZG9lc24ndCB3b3JrIGR1ZSB0b1xuLy8gLSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNDU4MlxuLy8gLSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNTY4OFxuLy8gSG93ZXZlciwgc2luY2UgKmFsbCogZmllbGRzIGFyZSBvcHRpb25hbCwgJFNoYXBlPD4gd29ya3MgYXMgc3VnZ2VzdGVkIGluIDU2ODhcbi8vIGFib3ZlLlxuXG4vLyBTcGFjaW5nIHJlbGF0aW9uc2hpcHMgZm9yIGRpc3BsYXkgYW5kIHRleHQgc3R5bGVzXG52YXIgc3BhY2luZ3MgPSB7XG4gIG1vcmQ6IHtcbiAgICBtb3A6IHRoaW5zcGFjZSxcbiAgICBtYmluOiBtZWRpdW1zcGFjZSxcbiAgICBtcmVsOiB0aGlja3NwYWNlLFxuICAgIG1pbm5lcjogdGhpbnNwYWNlXG4gIH0sXG4gIG1vcDoge1xuICAgIG1vcmQ6IHRoaW5zcGFjZSxcbiAgICBtb3A6IHRoaW5zcGFjZSxcbiAgICBtcmVsOiB0aGlja3NwYWNlLFxuICAgIG1pbm5lcjogdGhpbnNwYWNlXG4gIH0sXG4gIG1iaW46IHtcbiAgICBtb3JkOiBtZWRpdW1zcGFjZSxcbiAgICBtb3A6IG1lZGl1bXNwYWNlLFxuICAgIG1vcGVuOiBtZWRpdW1zcGFjZSxcbiAgICBtaW5uZXI6IG1lZGl1bXNwYWNlXG4gIH0sXG4gIG1yZWw6IHtcbiAgICBtb3JkOiB0aGlja3NwYWNlLFxuICAgIG1vcDogdGhpY2tzcGFjZSxcbiAgICBtb3BlbjogdGhpY2tzcGFjZSxcbiAgICBtaW5uZXI6IHRoaWNrc3BhY2VcbiAgfSxcbiAgbW9wZW46IHt9LFxuICBtY2xvc2U6IHtcbiAgICBtb3A6IHRoaW5zcGFjZSxcbiAgICBtYmluOiBtZWRpdW1zcGFjZSxcbiAgICBtcmVsOiB0aGlja3NwYWNlLFxuICAgIG1pbm5lcjogdGhpbnNwYWNlXG4gIH0sXG4gIG1wdW5jdDoge1xuICAgIG1vcmQ6IHRoaW5zcGFjZSxcbiAgICBtb3A6IHRoaW5zcGFjZSxcbiAgICBtcmVsOiB0aGlja3NwYWNlLFxuICAgIG1vcGVuOiB0aGluc3BhY2UsXG4gICAgbWNsb3NlOiB0aGluc3BhY2UsXG4gICAgbXB1bmN0OiB0aGluc3BhY2UsXG4gICAgbWlubmVyOiB0aGluc3BhY2VcbiAgfSxcbiAgbWlubmVyOiB7XG4gICAgbW9yZDogdGhpbnNwYWNlLFxuICAgIG1vcDogdGhpbnNwYWNlLFxuICAgIG1iaW46IG1lZGl1bXNwYWNlLFxuICAgIG1yZWw6IHRoaWNrc3BhY2UsXG4gICAgbW9wZW46IHRoaW5zcGFjZSxcbiAgICBtcHVuY3Q6IHRoaW5zcGFjZSxcbiAgICBtaW5uZXI6IHRoaW5zcGFjZVxuICB9XG59OyAvLyBTcGFjaW5nIHJlbGF0aW9uc2hpcHMgZm9yIHNjcmlwdCBhbmQgc2NyaXB0c2NyaXB0IHN0eWxlc1xuXG52YXIgdGlnaHRTcGFjaW5ncyA9IHtcbiAgbW9yZDoge1xuICAgIG1vcDogdGhpbnNwYWNlXG4gIH0sXG4gIG1vcDoge1xuICAgIG1vcmQ6IHRoaW5zcGFjZSxcbiAgICBtb3A6IHRoaW5zcGFjZVxuICB9LFxuICBtYmluOiB7fSxcbiAgbXJlbDoge30sXG4gIG1vcGVuOiB7fSxcbiAgbWNsb3NlOiB7XG4gICAgbW9wOiB0aGluc3BhY2VcbiAgfSxcbiAgbXB1bmN0OiB7fSxcbiAgbWlubmVyOiB7XG4gICAgbW9wOiB0aGluc3BhY2VcbiAgfVxufTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2RlZmluZUZ1bmN0aW9uLmpzXG5cblxuLyoqXG4gKiBBbGwgcmVnaXN0ZXJlZCBmdW5jdGlvbnMuXG4gKiBgZnVuY3Rpb25zLmpzYCBqdXN0IGV4cG9ydHMgdGhpcyBzYW1lIGRpY3Rpb25hcnkgYWdhaW4gYW5kIG1ha2VzIGl0IHB1YmxpYy5cbiAqIGBQYXJzZXIuanNgIHJlcXVpcmVzIHRoaXMgZGljdGlvbmFyeS5cbiAqL1xudmFyIF9mdW5jdGlvbnMgPSB7fTtcbi8qKlxuICogQWxsIEhUTUwgYnVpbGRlcnMuIFNob3VsZCBiZSBvbmx5IHVzZWQgaW4gdGhlIGBkZWZpbmUqYCBhbmQgdGhlIGBidWlsZCpNTGBcbiAqIGZ1bmN0aW9ucy5cbiAqL1xuXG52YXIgX2h0bWxHcm91cEJ1aWxkZXJzID0ge307XG4vKipcbiAqIEFsbCBNYXRoTUwgYnVpbGRlcnMuIFNob3VsZCBiZSBvbmx5IHVzZWQgaW4gdGhlIGBkZWZpbmUqYCBhbmQgdGhlIGBidWlsZCpNTGBcbiAqIGZ1bmN0aW9ucy5cbiAqL1xuXG52YXIgX21hdGhtbEdyb3VwQnVpbGRlcnMgPSB7fTtcbmZ1bmN0aW9uIGRlZmluZUZ1bmN0aW9uKF9yZWYpIHtcbiAgdmFyIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICBuYW1lcyA9IF9yZWYubmFtZXMsXG4gICAgICBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICBoYW5kbGVyID0gX3JlZi5oYW5kbGVyLFxuICAgICAgaHRtbEJ1aWxkZXIgPSBfcmVmLmh0bWxCdWlsZGVyLFxuICAgICAgbWF0aG1sQnVpbGRlciA9IF9yZWYubWF0aG1sQnVpbGRlcjtcbiAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzIG9mIGZ1bmN0aW9uc1xuICB2YXIgZGF0YSA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIG51bUFyZ3M6IHByb3BzLm51bUFyZ3MsXG4gICAgYXJnVHlwZXM6IHByb3BzLmFyZ1R5cGVzLFxuICAgIGdyZWVkaW5lc3M6IHByb3BzLmdyZWVkaW5lc3MgPT09IHVuZGVmaW5lZCA/IDEgOiBwcm9wcy5ncmVlZGluZXNzLFxuICAgIGFsbG93ZWRJblRleHQ6ICEhcHJvcHMuYWxsb3dlZEluVGV4dCxcbiAgICBhbGxvd2VkSW5NYXRoOiBwcm9wcy5hbGxvd2VkSW5NYXRoID09PSB1bmRlZmluZWQgPyB0cnVlIDogcHJvcHMuYWxsb3dlZEluTWF0aCxcbiAgICBudW1PcHRpb25hbEFyZ3M6IHByb3BzLm51bU9wdGlvbmFsQXJncyB8fCAwLFxuICAgIGluZml4OiAhIXByb3BzLmluZml4LFxuICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgX2Z1bmN0aW9uc1tuYW1lc1tpXV0gPSBkYXRhO1xuICB9XG5cbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoaHRtbEJ1aWxkZXIpIHtcbiAgICAgIF9odG1sR3JvdXBCdWlsZGVyc1t0eXBlXSA9IGh0bWxCdWlsZGVyO1xuICAgIH1cblxuICAgIGlmIChtYXRobWxCdWlsZGVyKSB7XG4gICAgICBfbWF0aG1sR3JvdXBCdWlsZGVyc1t0eXBlXSA9IG1hdGhtbEJ1aWxkZXI7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFVzZSB0aGlzIHRvIHJlZ2lzdGVyIG9ubHkgdGhlIEhUTUwgYW5kIE1hdGhNTCBidWlsZGVycyBmb3IgYSBmdW5jdGlvbiAoZS5nLlxuICogaWYgdGhlIGZ1bmN0aW9uJ3MgUGFyc2VOb2RlIGlzIGdlbmVyYXRlZCBpbiBQYXJzZXIuanMgcmF0aGVyIHRoYW4gdmlhIGFcbiAqIHN0YW5kLWFsb25lIGhhbmRsZXIgcHJvdmlkZWQgdG8gYGRlZmluZUZ1bmN0aW9uYCkuXG4gKi9cblxuZnVuY3Rpb24gZGVmaW5lRnVuY3Rpb25CdWlsZGVycyhfcmVmMikge1xuICB2YXIgdHlwZSA9IF9yZWYyLnR5cGUsXG4gICAgICBodG1sQnVpbGRlciA9IF9yZWYyLmh0bWxCdWlsZGVyLFxuICAgICAgbWF0aG1sQnVpbGRlciA9IF9yZWYyLm1hdGhtbEJ1aWxkZXI7XG4gIGRlZmluZUZ1bmN0aW9uKHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIG5hbWVzOiBbXSxcbiAgICBwcm9wczoge1xuICAgICAgbnVtQXJnczogMFxuICAgIH0sXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5ldmVyIGJlIGNhbGxlZC4nKTtcbiAgICB9LFxuICAgIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlcixcbiAgICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyXG4gIH0pO1xufSAvLyBTaW5jZSB0aGUgY29ycmVzcG9uZGluZyBidWlsZEhUTUwvYnVpbGRNYXRoTUwgZnVuY3Rpb24gZXhwZWN0cyBhXG4vLyBsaXN0IG9mIGVsZW1lbnRzLCB3ZSBub3JtYWxpemUgZm9yIGRpZmZlcmVudCBraW5kcyBvZiBhcmd1bWVudHNcblxudmFyIGRlZmluZUZ1bmN0aW9uX29yZGFyZ3VtZW50ID0gZnVuY3Rpb24gb3JkYXJndW1lbnQoYXJnKSB7XG4gIHZhciBub2RlID0gY2hlY2tOb2RlVHlwZShhcmcsIFwib3JkZ3JvdXBcIik7XG4gIHJldHVybiBub2RlID8gbm9kZS5ib2R5IDogW2FyZ107XG59O1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYnVpbGRIVE1MLmpzXG4vKipcbiAqIFRoaXMgZmlsZSBkb2VzIHRoZSBtYWluIHdvcmsgb2YgYnVpbGRpbmcgYSBkb21UcmVlIHN0cnVjdHVyZSBmcm9tIGEgcGFyc2VcbiAqIHRyZWUuIFRoZSBlbnRyeSBwb2ludCBpcyB0aGUgYGJ1aWxkSFRNTGAgZnVuY3Rpb24sIHdoaWNoIHRha2VzIGEgcGFyc2UgdHJlZS5cbiAqIFRoZW4sIHRoZSBidWlsZEV4cHJlc3Npb24sIGJ1aWxkR3JvdXAsIGFuZCB2YXJpb3VzIGdyb3VwQnVpbGRlcnMgZnVuY3Rpb25zXG4gKiBhcmUgY2FsbGVkLCB0byBwcm9kdWNlIGEgZmluYWwgSFRNTCB0cmVlLlxuICovXG5cblxuXG5cblxuXG5cblxuXG52YXIgYnVpbGRIVE1MX21ha2VTcGFuID0gYnVpbGRDb21tb24ubWFrZVNwYW47IC8vIEJpbmFyeSBhdG9tcyAoZmlyc3QgY2xhc3MgYG1iaW5gKSBjaGFuZ2UgaW50byBvcmRpbmFyeSBhdG9tcyAoYG1vcmRgKVxuLy8gZGVwZW5kaW5nIG9uIHRoZWlyIHN1cnJvdW5kaW5ncy4gU2VlIFRlWGJvb2sgcGcuIDQ0Mi00NDYsIFJ1bGVzIDUgYW5kIDYsXG4vLyBhbmQgdGhlIHRleHQgYmVmb3JlIFJ1bGUgMTkuXG5cbnZhciBiaW5MZWZ0Q2FuY2VsbGVyID0gW1wibGVmdG1vc3RcIiwgXCJtYmluXCIsIFwibW9wZW5cIiwgXCJtcmVsXCIsIFwibW9wXCIsIFwibXB1bmN0XCJdO1xudmFyIGJpblJpZ2h0Q2FuY2VsbGVyID0gW1wicmlnaHRtb3N0XCIsIFwibXJlbFwiLCBcIm1jbG9zZVwiLCBcIm1wdW5jdFwiXTtcbnZhciBzdHlsZU1hcCA9IHtcbiAgXCJkaXNwbGF5XCI6IHNyY19TdHlsZS5ESVNQTEFZLFxuICBcInRleHRcIjogc3JjX1N0eWxlLlRFWFQsXG4gIFwic2NyaXB0XCI6IHNyY19TdHlsZS5TQ1JJUFQsXG4gIFwic2NyaXB0c2NyaXB0XCI6IHNyY19TdHlsZS5TQ1JJUFRTQ1JJUFRcbn07XG52YXIgRG9tRW51bSA9IHtcbiAgbW9yZDogXCJtb3JkXCIsXG4gIG1vcDogXCJtb3BcIixcbiAgbWJpbjogXCJtYmluXCIsXG4gIG1yZWw6IFwibXJlbFwiLFxuICBtb3BlbjogXCJtb3BlblwiLFxuICBtY2xvc2U6IFwibWNsb3NlXCIsXG4gIG1wdW5jdDogXCJtcHVuY3RcIixcbiAgbWlubmVyOiBcIm1pbm5lclwiXG59O1xuXG4vKipcbiAqIFRha2UgYSBsaXN0IG9mIG5vZGVzLCBidWlsZCB0aGVtIGluIG9yZGVyLCBhbmQgcmV0dXJuIGEgbGlzdCBvZiB0aGUgYnVpbHRcbiAqIG5vZGVzLiBkb2N1bWVudEZyYWdtZW50cyBhcmUgZmxhdHRlbmVkIGludG8gdGhlaXIgY29udGVudHMsIHNvIHRoZVxuICogcmV0dXJuZWQgbGlzdCBjb250YWlucyBubyBmcmFnbWVudHMuIGBpc1JlYWxHcm91cGAgaXMgdHJ1ZSBpZiBgZXhwcmVzc2lvbmBcbiAqIGlzIGEgcmVhbCBncm91cCAobm8gYXRvbXMgd2lsbCBiZSBhZGRlZCBvbiBlaXRoZXIgc2lkZSksIGFzIG9wcG9zZWQgdG9cbiAqIGEgcGFydGlhbCBncm91cCAoZS5nLiBvbmUgY3JlYXRlZCBieSBcXGNvbG9yKS4gYHN1cnJvdW5kaW5nYCBpcyBhbiBhcnJheVxuICogY29uc2lzdGluZyB0eXBlIG9mIG5vZGVzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgbGVmdCBhbmQgcmlnaHQuXG4gKi9cbnZhciBidWlsZEhUTUxfYnVpbGRFeHByZXNzaW9uID0gZnVuY3Rpb24gYnVpbGRFeHByZXNzaW9uKGV4cHJlc3Npb24sIG9wdGlvbnMsIGlzUmVhbEdyb3VwLCBzdXJyb3VuZGluZykge1xuICBpZiAoc3Vycm91bmRpbmcgPT09IHZvaWQgMCkge1xuICAgIHN1cnJvdW5kaW5nID0gW251bGwsIG51bGxdO1xuICB9XG5cbiAgLy8gUGFyc2UgZXhwcmVzc2lvbnMgaW50byBgZ3JvdXBzYC5cbiAgdmFyIGdyb3VwcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvdXRwdXQgPSBidWlsZEhUTUxfYnVpbGRHcm91cChleHByZXNzaW9uW2ldLCBvcHRpb25zKTtcblxuICAgIGlmIChvdXRwdXQgaW5zdGFuY2VvZiB0cmVlX0RvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG91dHB1dC5jaGlsZHJlbjtcbiAgICAgIGdyb3Vwcy5wdXNoLmFwcGx5KGdyb3VwcywgY2hpbGRyZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cHMucHVzaChvdXRwdXQpO1xuICAgIH1cbiAgfSAvLyBJZiBgZXhwcmVzc2lvbmAgaXMgYSBwYXJ0aWFsIGdyb3VwLCBsZXQgdGhlIHBhcmVudCBoYW5kbGUgc3BhY2luZ3NcbiAgLy8gdG8gYXZvaWQgcHJvY2Vzc2luZyBncm91cHMgbXVsdGlwbGUgdGltZXMuXG5cblxuICBpZiAoIWlzUmVhbEdyb3VwKSB7XG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuXG4gIHZhciBnbHVlT3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgaWYgKGV4cHJlc3Npb24ubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIG5vZGUgPSBjaGVja05vZGVUeXBlKGV4cHJlc3Npb25bMF0sIFwic2l6aW5nXCIpIHx8IGNoZWNrTm9kZVR5cGUoZXhwcmVzc2lvblswXSwgXCJzdHlsaW5nXCIpO1xuXG4gICAgaWYgKCFub2RlKSB7Ly8gTm8gbWF0Y2guXG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwic2l6aW5nXCIpIHtcbiAgICAgIGdsdWVPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTaXplKG5vZGUuc2l6ZSk7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwic3R5bGluZ1wiKSB7XG4gICAgICBnbHVlT3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGVNYXBbbm9kZS5zdHlsZV0pO1xuICAgIH1cbiAgfSAvLyBEdW1teSBzcGFucyBmb3IgZGV0ZXJtaW5pbmcgc3BhY2luZ3MgYmV0d2VlbiBzdXJyb3VuZGluZyBhdG9tcy5cbiAgLy8gSWYgYGV4cHJlc3Npb25gIGhhcyBubyBhdG9tcyBvbiB0aGUgbGVmdCBvciByaWdodCwgY2xhc3MgXCJsZWZ0bW9zdFwiXG4gIC8vIG9yIFwicmlnaHRtb3N0XCIsIHJlc3BlY3RpdmVseSwgaXMgdXNlZCB0byBpbmRpY2F0ZSBpdC5cblxuXG4gIHZhciBkdW1teVByZXYgPSBidWlsZEhUTUxfbWFrZVNwYW4oW3N1cnJvdW5kaW5nWzBdIHx8IFwibGVmdG1vc3RcIl0sIFtdLCBvcHRpb25zKTtcbiAgdmFyIGR1bW15TmV4dCA9IGJ1aWxkSFRNTF9tYWtlU3Bhbihbc3Vycm91bmRpbmdbMV0gfHwgXCJyaWdodG1vc3RcIl0sIFtdLCBvcHRpb25zKTsgLy8gVE9ETzogVGhlc2UgY29kZSBhc3N1bWVzIHRoYXQgYSBub2RlJ3MgbWF0aCBjbGFzcyBpcyB0aGUgZmlyc3QgZWxlbWVudFxuICAvLyBvZiBpdHMgYGNsYXNzZXNgIGFycmF5LiBBIGxhdGVyIGNsZWFudXAgc2hvdWxkIGVuc3VyZSB0aGlzLCBmb3JcbiAgLy8gaW5zdGFuY2UgYnkgY2hhbmdpbmcgdGhlIHNpZ25hdHVyZSBvZiBgbWFrZVNwYW5gLlxuICAvLyBCZWZvcmUgZGV0ZXJtaW5pbmcgd2hhdCBzcGFjZXMgdG8gaW5zZXJ0LCBwZXJmb3JtIGJpbiBjYW5jZWxsYXRpb24uXG4gIC8vIEJpbmFyeSBvcGVyYXRvcnMgY2hhbmdlIHRvIG9yZGluYXJ5IHN5bWJvbHMgaW4gc29tZSBjb250ZXh0cy5cblxuICB0cmF2ZXJzZU5vblNwYWNlTm9kZXMoZ3JvdXBzLCBmdW5jdGlvbiAobm9kZSwgcHJldikge1xuICAgIHZhciBwcmV2VHlwZSA9IHByZXYuY2xhc3Nlc1swXTtcbiAgICB2YXIgdHlwZSA9IG5vZGUuY2xhc3Nlc1swXTtcblxuICAgIGlmIChwcmV2VHlwZSA9PT0gXCJtYmluXCIgJiYgdXRpbHMuY29udGFpbnMoYmluUmlnaHRDYW5jZWxsZXIsIHR5cGUpKSB7XG4gICAgICBwcmV2LmNsYXNzZXNbMF0gPSBcIm1vcmRcIjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibWJpblwiICYmIHV0aWxzLmNvbnRhaW5zKGJpbkxlZnRDYW5jZWxsZXIsIHByZXZUeXBlKSkge1xuICAgICAgbm9kZS5jbGFzc2VzWzBdID0gXCJtb3JkXCI7XG4gICAgfVxuICB9LCB7XG4gICAgbm9kZTogZHVtbXlQcmV2XG4gIH0sIGR1bW15TmV4dCk7XG4gIHRyYXZlcnNlTm9uU3BhY2VOb2Rlcyhncm91cHMsIGZ1bmN0aW9uIChub2RlLCBwcmV2KSB7XG4gICAgdmFyIHByZXZUeXBlID0gZ2V0VHlwZU9mRG9tVHJlZShwcmV2KTtcbiAgICB2YXIgdHlwZSA9IGdldFR5cGVPZkRvbVRyZWUobm9kZSk7IC8vICdtdGlnaHQnIGluZGljYXRlcyB0aGF0IHRoZSBub2RlIGlzIHNjcmlwdCBvciBzY3JpcHRzY3JpcHQgc3R5bGUuXG5cbiAgICB2YXIgc3BhY2UgPSBwcmV2VHlwZSAmJiB0eXBlID8gbm9kZS5oYXNDbGFzcyhcIm10aWdodFwiKSA/IHRpZ2h0U3BhY2luZ3NbcHJldlR5cGVdW3R5cGVdIDogc3BhY2luZ3NbcHJldlR5cGVdW3R5cGVdIDogbnVsbDtcblxuICAgIGlmIChzcGFjZSkge1xuICAgICAgLy8gSW5zZXJ0IGdsdWUgKHNwYWNpbmcpIGFmdGVyIHRoZSBgcHJldmAuXG4gICAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUdsdWUoc3BhY2UsIGdsdWVPcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBub2RlOiBkdW1teVByZXZcbiAgfSwgZHVtbXlOZXh0KTtcbiAgcmV0dXJuIGdyb3Vwcztcbn07IC8vIERlcHRoLWZpcnN0IHRyYXZlcnNlIG5vbi1zcGFjZSBgbm9kZXNgLCBjYWxsaW5nIGBjYWxsYmFja2Agd2l0aCB0aGUgY3VycmVudCBhbmRcbi8vIHByZXZpb3VzIG5vZGUgYXMgYXJndW1lbnRzLCBvcHRpb25hbGx5IHJldHVybmluZyBhIG5vZGUgdG8gaW5zZXJ0IGFmdGVyIHRoZVxuLy8gcHJldmlvdXMgbm9kZS4gYHByZXZgIGlzIGFuIG9iamVjdCB3aXRoIHRoZSBwcmV2aW91cyBub2RlIGFuZCBgaW5zZXJ0QWZ0ZXJgXG4vLyBmdW5jdGlvbiB0byBpbnNlcnQgYWZ0ZXIgaXQuIGBuZXh0YCBpcyBhIG5vZGUgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSByaWdodC5cbi8vIFVzZWQgZm9yIGJpbiBjYW5jZWxsYXRpb24gYW5kIGluc2VydGluZyBzcGFjaW5ncy5cblxudmFyIHRyYXZlcnNlTm9uU3BhY2VOb2RlcyA9IGZ1bmN0aW9uIHRyYXZlcnNlTm9uU3BhY2VOb2Rlcyhub2RlcywgY2FsbGJhY2ssIHByZXYsIG5leHQpIHtcbiAgaWYgKG5leHQpIHtcbiAgICAvLyB0ZW1wb3JhcmlseSBhcHBlbmQgdGhlIHJpZ2h0IG5vZGUsIGlmIGV4aXN0c1xuICAgIG5vZGVzLnB1c2gobmV4dCk7XG4gIH1cblxuICB2YXIgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgdmFyIHBhcnRpYWxHcm91cCA9IGJ1aWxkSFRNTF9jaGVja1BhcnRpYWxHcm91cChub2RlKTtcblxuICAgIGlmIChwYXJ0aWFsR3JvdXApIHtcbiAgICAgIC8vIFJlY3Vyc2l2ZSBERlNcbiAgICAgIC8vICRGbG93Rml4TWU6IG1ha2Ugbm9kZXMgYSAkUmVhZE9ubHlBcnJheSBieSByZXR1cm5pbmcgYSBuZXcgYXJyYXlcbiAgICAgIHRyYXZlcnNlTm9uU3BhY2VOb2RlcyhwYXJ0aWFsR3JvdXAuY2hpbGRyZW4sIGNhbGxiYWNrLCBwcmV2KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gSWdub3JlIGV4cGxpY2l0IHNwYWNlcyAoZS5nLiwgXFw7LCBcXCwpIHdoZW4gZGV0ZXJtaW5pbmcgd2hhdCBpbXBsaWNpdFxuICAgIC8vIHNwYWNpbmcgc2hvdWxkIGdvIGJldHdlZW4gYXRvbXMgb2YgZGlmZmVyZW50IGNsYXNzZXNcblxuXG4gICAgaWYgKG5vZGUuY2xhc3Nlc1swXSA9PT0gXCJtc3BhY2VcIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrKG5vZGUsIHByZXYubm9kZSk7XG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBpZiAocHJldi5pbnNlcnRBZnRlcikge1xuICAgICAgICBwcmV2Lmluc2VydEFmdGVyKHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpbnNlcnQgYXQgZnJvbnRcbiAgICAgICAgbm9kZXMudW5zaGlmdChyZXN1bHQpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJldi5ub2RlID0gbm9kZTtcblxuICAgIHByZXYuaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobikge1xuICAgICAgICBub2Rlcy5zcGxpY2UoaW5kZXggKyAxLCAwLCBuKTtcbiAgICAgICAgaSsrO1xuICAgICAgfTtcbiAgICB9KGkpO1xuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBub2Rlcy5wb3AoKTtcbiAgfVxufTsgLy8gQ2hlY2sgaWYgZ2l2ZW4gbm9kZSBpcyBhIHBhcnRpYWwgZ3JvdXAsIGkuZS4sIGRvZXMgbm90IGFmZmVjdCBzcGFjaW5nIGFyb3VuZC5cblxuXG52YXIgYnVpbGRIVE1MX2NoZWNrUGFydGlhbEdyb3VwID0gZnVuY3Rpb24gY2hlY2tQYXJ0aWFsR3JvdXAobm9kZSkge1xuICBpZiAobm9kZSBpbnN0YW5jZW9mIHRyZWVfRG9jdW1lbnRGcmFnbWVudCB8fCBub2RlIGluc3RhbmNlb2YgZG9tVHJlZV9BbmNob3IpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTsgLy8gUmV0dXJuIHRoZSBvdXRlcm1vc3Qgbm9kZSBvZiBhIGRvbVRyZWUuXG5cblxudmFyIGdldE91dGVybW9zdE5vZGUgPSBmdW5jdGlvbiBnZXRPdXRlcm1vc3ROb2RlKG5vZGUsIHNpZGUpIHtcbiAgdmFyIHBhcnRpYWxHcm91cCA9IGJ1aWxkSFRNTF9jaGVja1BhcnRpYWxHcm91cChub2RlKTtcblxuICBpZiAocGFydGlhbEdyb3VwKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gcGFydGlhbEdyb3VwLmNoaWxkcmVuO1xuXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgaWYgKHNpZGUgPT09IFwicmlnaHRcIikge1xuICAgICAgICByZXR1cm4gZ2V0T3V0ZXJtb3N0Tm9kZShjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXSwgXCJyaWdodFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoc2lkZSA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgcmV0dXJuIGdldE91dGVybW9zdE5vZGUoY2hpbGRyZW5bMF0sIFwibGVmdFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07IC8vIFJldHVybiBtYXRoIGF0b20gY2xhc3MgKG1jbGFzcykgb2YgYSBkb21UcmVlLlxuLy8gSWYgYHNpZGVgIGlzIGdpdmVuLCBpdCB3aWxsIGdldCB0aGUgdHlwZSBvZiB0aGUgb3V0ZXJtb3N0IG5vZGUgYXQgZ2l2ZW4gc2lkZS5cblxuXG52YXIgZ2V0VHlwZU9mRG9tVHJlZSA9IGZ1bmN0aW9uIGdldFR5cGVPZkRvbVRyZWUobm9kZSwgc2lkZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChzaWRlKSB7XG4gICAgbm9kZSA9IGdldE91dGVybW9zdE5vZGUobm9kZSwgc2lkZSk7XG4gIH0gLy8gVGhpcyBtYWtlcyBhIGxvdCBvZiBhc3N1bXB0aW9ucyBhcyB0byB3aGVyZSB0aGUgdHlwZSBvZiBhdG9tXG4gIC8vIGFwcGVhcnMuICBXZSBzaG91bGQgZG8gYSBiZXR0ZXIgam9iIG9mIGVuZm9yY2luZyB0aGlzLlxuXG5cbiAgcmV0dXJuIERvbUVudW1bbm9kZS5jbGFzc2VzWzBdXSB8fCBudWxsO1xufTtcbnZhciBtYWtlTnVsbERlbGltaXRlciA9IGZ1bmN0aW9uIG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIGNsYXNzZXMpIHtcbiAgdmFyIG1vcmVDbGFzc2VzID0gW1wibnVsbGRlbGltaXRlclwiXS5jb25jYXQob3B0aW9ucy5iYXNlU2l6aW5nQ2xhc3NlcygpKTtcbiAgcmV0dXJuIGJ1aWxkSFRNTF9tYWtlU3BhbihjbGFzc2VzLmNvbmNhdChtb3JlQ2xhc3NlcykpO1xufTtcbi8qKlxuICogYnVpbGRHcm91cCBpcyB0aGUgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGdyb3VwIGFuZCBjYWxscyB0aGUgY29ycmVjdCBncm91cFR5cGVcbiAqIGZ1bmN0aW9uIGZvciBpdC4gSXQgYWxzbyBoYW5kbGVzIHRoZSBpbnRlcmFjdGlvbiBvZiBzaXplIGFuZCBzdHlsZSBjaGFuZ2VzXG4gKiBiZXR3ZWVuIHBhcmVudHMgYW5kIGNoaWxkcmVuLlxuICovXG5cbnZhciBidWlsZEhUTUxfYnVpbGRHcm91cCA9IGZ1bmN0aW9uIGJ1aWxkR3JvdXAoZ3JvdXAsIG9wdGlvbnMsIGJhc2VPcHRpb25zKSB7XG4gIGlmICghZ3JvdXApIHtcbiAgICByZXR1cm4gYnVpbGRIVE1MX21ha2VTcGFuKCk7XG4gIH1cblxuICBpZiAoX2h0bWxHcm91cEJ1aWxkZXJzW2dyb3VwLnR5cGVdKSB7XG4gICAgLy8gQ2FsbCB0aGUgZ3JvdXBCdWlsZGVycyBmdW5jdGlvblxuICAgIHZhciBncm91cE5vZGUgPSBfaHRtbEdyb3VwQnVpbGRlcnNbZ3JvdXAudHlwZV0oZ3JvdXAsIG9wdGlvbnMpOyAvLyBJZiB0aGUgc2l6ZSBjaGFuZ2VkIGJldHdlZW4gdGhlIHBhcmVudCBhbmQgdGhlIGN1cnJlbnQgZ3JvdXAsIGFjY291bnRcbiAgICAvLyBmb3IgdGhhdCBzaXplIGRpZmZlcmVuY2UuXG5cbiAgICBpZiAoYmFzZU9wdGlvbnMgJiYgb3B0aW9ucy5zaXplICE9PSBiYXNlT3B0aW9ucy5zaXplKSB7XG4gICAgICBncm91cE5vZGUgPSBidWlsZEhUTUxfbWFrZVNwYW4ob3B0aW9ucy5zaXppbmdDbGFzc2VzKGJhc2VPcHRpb25zKSwgW2dyb3VwTm9kZV0sIG9wdGlvbnMpO1xuICAgICAgdmFyIG11bHRpcGxpZXIgPSBvcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gYmFzZU9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gICAgICBncm91cE5vZGUuaGVpZ2h0ICo9IG11bHRpcGxpZXI7XG4gICAgICBncm91cE5vZGUuZGVwdGggKj0gbXVsdGlwbGllcjtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JvdXBOb2RlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkdvdCBncm91cCBvZiB1bmtub3duIHR5cGU6ICdcIiArIGdyb3VwLnR5cGUgKyBcIidcIik7XG4gIH1cbn07XG4vKipcbiAqIENvbWJpbmUgYW4gYXJyYXkgb2YgSFRNTCBET00gbm9kZXMgKGUuZy4sIHRoZSBvdXRwdXQgb2YgYGJ1aWxkRXhwcmVzc2lvbmApXG4gKiBpbnRvIGFuIHVuYnJlYWthYmxlIEhUTUwgbm9kZSBvZiBjbGFzcyAuYmFzZSwgd2l0aCBwcm9wZXIgc3RydXRzIHRvXG4gKiBndWFyYW50ZWUgY29ycmVjdCB2ZXJ0aWNhbCBleHRlbnQuICBgYnVpbGRIVE1MYCBjYWxscyB0aGlzIHJlcGVhdGVkbHkgdG9cbiAqIG1ha2UgdXAgdGhlIGVudGlyZSBleHByZXNzaW9uIGFzIGEgc2VxdWVuY2Ugb2YgdW5icmVha2FibGUgdW5pdHMuXG4gKi9cblxuZnVuY3Rpb24gYnVpbGRIVE1MVW5icmVha2FibGUoY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgLy8gQ29tcHV0ZSBoZWlnaHQgYW5kIGRlcHRoIG9mIHRoaXMgY2h1bmsuXG4gIHZhciBib2R5ID0gYnVpbGRIVE1MX21ha2VTcGFuKFtcImJhc2VcIl0sIGNoaWxkcmVuLCBvcHRpb25zKTsgLy8gQWRkIHN0cnV0LCB3aGljaCBlbnN1cmVzIHRoYXQgdGhlIHRvcCBvZiB0aGUgSFRNTCBlbGVtZW50IGZhbGxzIGF0XG4gIC8vIHRoZSBoZWlnaHQgb2YgdGhlIGV4cHJlc3Npb24sIGFuZCB0aGUgYm90dG9tIG9mIHRoZSBIVE1MIGVsZW1lbnRcbiAgLy8gZmFsbHMgYXQgdGhlIGRlcHRoIG9mIHRoZSBleHByZXNzaW9uLlxuICAvLyBXZSB1c2VkIHRvIGhhdmUgc2VwYXJhdGUgdG9wIGFuZCBib3R0b20gc3RydXRzLCB3aGVyZSB0aGUgYm90dG9tIHN0cnV0XG4gIC8vIHdvdWxkIGxpa2UgdG8gdXNlIGB2ZXJ0aWNhbC1hbGlnbjogdG9wYCwgYnV0IGluIElFIDkgdGhpcyBsb3dlcnMgdGhlXG4gIC8vIGJhc2VsaW5lIG9mIHRoZSBib3ggdG8gdGhlIGJvdHRvbSBvZiB0aGlzIHN0cnV0IChpbnN0ZWFkIG9mIHN0YXlpbmcgaW5cbiAgLy8gdGhlIG5vcm1hbCBwbGFjZSkgc28gd2UgdXNlIGFuIGFic29sdXRlIHZhbHVlIGZvciB2ZXJ0aWNhbC1hbGlnbiBpbnN0ZWFkLlxuXG4gIHZhciBzdHJ1dCA9IGJ1aWxkSFRNTF9tYWtlU3BhbihbXCJzdHJ1dFwiXSk7XG4gIHN0cnV0LnN0eWxlLmhlaWdodCA9IGJvZHkuaGVpZ2h0ICsgYm9keS5kZXB0aCArIFwiZW1cIjtcbiAgc3RydXQuc3R5bGUudmVydGljYWxBbGlnbiA9IC1ib2R5LmRlcHRoICsgXCJlbVwiO1xuICBib2R5LmNoaWxkcmVuLnVuc2hpZnQoc3RydXQpO1xuICByZXR1cm4gYm9keTtcbn1cbi8qKlxuICogVGFrZSBhbiBlbnRpcmUgcGFyc2UgdHJlZSwgYW5kIGJ1aWxkIGl0IGludG8gYW4gYXBwcm9wcmlhdGUgc2V0IG9mIEhUTUxcbiAqIG5vZGVzLlxuICovXG5cblxuZnVuY3Rpb24gYnVpbGRIVE1MKHRyZWUsIG9wdGlvbnMpIHtcbiAgLy8gU3RyaXAgb2ZmIG91dGVyIHRhZyB3cmFwcGVyIGZvciBwcm9jZXNzaW5nIGJlbG93LlxuICB2YXIgdGFnID0gbnVsbDtcblxuICBpZiAodHJlZS5sZW5ndGggPT09IDEgJiYgdHJlZVswXS50eXBlID09PSBcInRhZ1wiKSB7XG4gICAgdGFnID0gdHJlZVswXS50YWc7XG4gICAgdHJlZSA9IHRyZWVbMF0uYm9keTtcbiAgfSAvLyBCdWlsZCB0aGUgZXhwcmVzc2lvbiBjb250YWluZWQgaW4gdGhlIHRyZWVcblxuXG4gIHZhciBleHByZXNzaW9uID0gYnVpbGRIVE1MX2J1aWxkRXhwcmVzc2lvbih0cmVlLCBvcHRpb25zLCB0cnVlKTtcbiAgdmFyIGNoaWxkcmVuID0gW107IC8vIENyZWF0ZSBvbmUgYmFzZSBub2RlIGZvciBlYWNoIGNodW5rIGJldHdlZW4gcG90ZW50aWFsIGxpbmUgYnJlYWtzLlxuICAvLyBUaGUgVGVYQm9vayBbcC4xNzNdIHNheXMgXCJBIGZvcm11bGEgd2lsbCBiZSBicm9rZW4gb25seSBhZnRlciBhXG4gIC8vIHJlbGF0aW9uIHN5bWJvbCBsaWtlICQ9JCBvciAkPCQgb3IgJFxccmlnaHRhcnJvdyQsIG9yIGFmdGVyIGEgYmluYXJ5XG4gIC8vIG9wZXJhdGlvbiBzeW1ib2wgbGlrZSAkKyQgb3IgJC0kIG9yICRcXHRpbWVzJCwgd2hlcmUgdGhlIHJlbGF0aW9uIG9yXG4gIC8vIGJpbmFyeSBvcGVyYXRpb24gaXMgb24gdGhlIGBgb3V0ZXIgbGV2ZWwnJyBvZiB0aGUgZm9ybXVsYSAoaS5lLiwgbm90XG4gIC8vIGVuY2xvc2VkIGluIHsuLi59IGFuZCBub3QgcGFydCBvZiBhbiBcXG92ZXIgY29uc3RydWN0aW9uKS5cIlxuXG4gIHZhciBwYXJ0cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuICAgIHBhcnRzLnB1c2goZXhwcmVzc2lvbltpXSk7XG5cbiAgICBpZiAoZXhwcmVzc2lvbltpXS5oYXNDbGFzcyhcIm1iaW5cIikgfHwgZXhwcmVzc2lvbltpXS5oYXNDbGFzcyhcIm1yZWxcIikgfHwgZXhwcmVzc2lvbltpXS5oYXNDbGFzcyhcImFsbG93YnJlYWtcIikpIHtcbiAgICAgIC8vIFB1dCBhbnkgcG9zdC1vcGVyYXRvciBnbHVlIG9uIHNhbWUgbGluZSBhcyBvcGVyYXRvci5cbiAgICAgIC8vIFdhdGNoIGZvciBcXG5vYnJlYWsgYWxvbmcgdGhlIHdheSwgYW5kIHN0b3AgYXQgXFxuZXdsaW5lLlxuICAgICAgdmFyIG5vYnJlYWsgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKGkgPCBleHByZXNzaW9uLmxlbmd0aCAtIDEgJiYgZXhwcmVzc2lvbltpICsgMV0uaGFzQ2xhc3MoXCJtc3BhY2VcIikgJiYgIWV4cHJlc3Npb25baSArIDFdLmhhc0NsYXNzKFwibmV3bGluZVwiKSkge1xuICAgICAgICBpKys7XG4gICAgICAgIHBhcnRzLnB1c2goZXhwcmVzc2lvbltpXSk7XG5cbiAgICAgICAgaWYgKGV4cHJlc3Npb25baV0uaGFzQ2xhc3MoXCJub2JyZWFrXCIpKSB7XG4gICAgICAgICAgbm9icmVhayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gRG9uJ3QgYWxsb3cgYnJlYWsgaWYgXFxub2JyZWFrIGFtb25nIHRoZSBwb3N0LW9wZXJhdG9yIGdsdWUuXG5cblxuICAgICAgaWYgKCFub2JyZWFrKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goYnVpbGRIVE1MVW5icmVha2FibGUocGFydHMsIG9wdGlvbnMpKTtcbiAgICAgICAgcGFydHMgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cHJlc3Npb25baV0uaGFzQ2xhc3MoXCJuZXdsaW5lXCIpKSB7XG4gICAgICAvLyBXcml0ZSB0aGUgbGluZSBleGNlcHQgdGhlIG5ld2xpbmVcbiAgICAgIHBhcnRzLnBvcCgpO1xuXG4gICAgICBpZiAocGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGJ1aWxkSFRNTFVuYnJlYWthYmxlKHBhcnRzLCBvcHRpb25zKSk7XG4gICAgICAgIHBhcnRzID0gW107XG4gICAgICB9IC8vIFB1dCB0aGUgbmV3bGluZSBhdCB0aGUgdG9wIGxldmVsXG5cblxuICAgICAgY2hpbGRyZW4ucHVzaChleHByZXNzaW9uW2ldKTtcbiAgICB9XG4gIH1cblxuICBpZiAocGFydHMubGVuZ3RoID4gMCkge1xuICAgIGNoaWxkcmVuLnB1c2goYnVpbGRIVE1MVW5icmVha2FibGUocGFydHMsIG9wdGlvbnMpKTtcbiAgfSAvLyBOb3csIGlmIHRoZXJlIHdhcyBhIHRhZywgYnVpbGQgaXQgdG9vIGFuZCBhcHBlbmQgaXQgYXMgYSBmaW5hbCBjaGlsZC5cblxuXG4gIHZhciB0YWdDaGlsZDtcblxuICBpZiAodGFnKSB7XG4gICAgdGFnQ2hpbGQgPSBidWlsZEhUTUxVbmJyZWFrYWJsZShidWlsZEhUTUxfYnVpbGRFeHByZXNzaW9uKHRhZywgb3B0aW9ucywgdHJ1ZSkpO1xuICAgIHRhZ0NoaWxkLmNsYXNzZXMgPSBbXCJ0YWdcIl07XG4gICAgY2hpbGRyZW4ucHVzaCh0YWdDaGlsZCk7XG4gIH1cblxuICB2YXIgaHRtbE5vZGUgPSBidWlsZEhUTUxfbWFrZVNwYW4oW1wia2F0ZXgtaHRtbFwiXSwgY2hpbGRyZW4pO1xuICBodG1sTm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7IC8vIEFkanVzdCB0aGUgc3RydXQgb2YgdGhlIHRhZyB0byBiZSB0aGUgbWF4aW11bSBoZWlnaHQgb2YgYWxsIGNoaWxkcmVuXG4gIC8vICh0aGUgaGVpZ2h0IG9mIHRoZSBlbmNsb3NpbmcgaHRtbE5vZGUpIGZvciBwcm9wZXIgdmVydGljYWwgYWxpZ25tZW50LlxuXG4gIGlmICh0YWdDaGlsZCkge1xuICAgIHZhciBzdHJ1dCA9IHRhZ0NoaWxkLmNoaWxkcmVuWzBdO1xuICAgIHN0cnV0LnN0eWxlLmhlaWdodCA9IGh0bWxOb2RlLmhlaWdodCArIGh0bWxOb2RlLmRlcHRoICsgXCJlbVwiO1xuICAgIHN0cnV0LnN0eWxlLnZlcnRpY2FsQWxpZ24gPSAtaHRtbE5vZGUuZGVwdGggKyBcImVtXCI7XG4gIH1cblxuICByZXR1cm4gaHRtbE5vZGU7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9tYXRoTUxUcmVlLmpzXG4vKipcbiAqIFRoZXNlIG9iamVjdHMgc3RvcmUgZGF0YSBhYm91dCBNYXRoTUwgbm9kZXMuIFRoaXMgaXMgdGhlIE1hdGhNTCBlcXVpdmFsZW50XG4gKiBvZiB0aGUgdHlwZXMgaW4gZG9tVHJlZS5qcy4gU2luY2UgTWF0aE1MIGhhbmRsZXMgaXRzIG93biByZW5kZXJpbmcsIGFuZFxuICogc2luY2Ugd2UncmUgbWFpbmx5IHVzaW5nIE1hdGhNTCB0byBpbXByb3ZlIGFjY2Vzc2liaWxpdHksIHdlIGRvbid0IG1hbmFnZVxuICogYW55IG9mIHRoZSBzdHlsaW5nIHN0YXRlIHRoYXQgdGhlIHBsYWluIERPTSBub2RlcyBkby5cbiAqXG4gKiBUaGUgYHRvTm9kZWAgYW5kIGB0b01hcmt1cGAgZnVuY3Rpb25zIHdvcmsgc2ltbGFybHkgdG8gaG93IHRoZXkgZG8gaW5cbiAqIGRvbVRyZWUuanMsIGNyZWF0aW5nIG5hbWVzcGFjZWQgRE9NIG5vZGVzIGFuZCBIVE1MIHRleHQgbWFya3VwIHJlc3BlY3RpdmVseS5cbiAqL1xuXG5cbmZ1bmN0aW9uIG5ld0RvY3VtZW50RnJhZ21lbnQoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIG5ldyB0cmVlX0RvY3VtZW50RnJhZ21lbnQoY2hpbGRyZW4pO1xufVxuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhIGdlbmVyYWwgcHVycG9zZSBNYXRoTUwgbm9kZSBvZiBhbnkgdHlwZS4gVGhlXG4gKiBjb25zdHJ1Y3RvciByZXF1aXJlcyB0aGUgdHlwZSBvZiBub2RlIHRvIGNyZWF0ZSAoZm9yIGV4YW1wbGUsIGBcIm1vXCJgIG9yXG4gKiBgXCJtc3BhY2VcImAsIGNvcnJlc3BvbmRpbmcgdG8gYDxtbz5gIGFuZCBgPG1zcGFjZT5gIHRhZ3MpLlxuICovXG5cbnZhciBtYXRoTUxUcmVlX01hdGhOb2RlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWF0aE5vZGUodHlwZSwgY2hpbGRyZW4pIHtcbiAgICB0aGlzLnR5cGUgPSB2b2lkIDA7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gdm9pZCAwO1xuICAgIHRoaXMuY2hpbGRyZW4gPSB2b2lkIDA7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgW107XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYW4gYXR0cmlidXRlIG9uIGEgTWF0aE1MIG5vZGUuIE1hdGhNTCBkZXBlbmRzIG9uIGF0dHJpYnV0ZXMgdG8gY29udmV5IGFcbiAgICogc2VtYW50aWMgY29udGVudCwgc28gdGhpcyBpcyB1c2VkIGhlYXZpbHkuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IE1hdGhOb2RlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYW4gYXR0cmlidXRlIG9uIGEgTWF0aE1MIG5vZGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIG1hdGggbm9kZSBpbnRvIGEgTWF0aE1MLW5hbWVzcGFjZWQgRE9NIGVsZW1lbnQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvTm9kZSA9IGZ1bmN0aW9uIHRvTm9kZSgpIHtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIiwgdGhpcy50eXBlKTtcblxuICAgIGZvciAodmFyIGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXR0cmlidXRlcywgYXR0cikpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0ciwgdGhpcy5hdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvTWFya3VwID0gZnVuY3Rpb24gdG9NYXJrdXAoKSB7XG4gICAgdmFyIG1hcmt1cCA9IFwiPFwiICsgdGhpcy50eXBlOyAvLyBBZGQgdGhlIGF0dHJpYnV0ZXNcblxuICAgIGZvciAodmFyIGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXR0cmlidXRlcywgYXR0cikpIHtcbiAgICAgICAgbWFya3VwICs9IFwiIFwiICsgYXR0ciArIFwiPVxcXCJcIjtcbiAgICAgICAgbWFya3VwICs9IHV0aWxzLmVzY2FwZSh0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgICBtYXJrdXAgKz0gXCJcXFwiXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWFya3VwICs9IFwiPlwiO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIjwvXCIgKyB0aGlzLnR5cGUgKyBcIj5cIjtcbiAgICByZXR1cm4gbWFya3VwO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgbWF0aCBub2RlIGludG8gYSBzdHJpbmcsIHNpbWlsYXIgdG8gaW5uZXJUZXh0LCBidXQgZXNjYXBlZC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9UZXh0ID0gZnVuY3Rpb24gdG9UZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC50b1RleHQoKTtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9O1xuXG4gIHJldHVybiBNYXRoTm9kZTtcbn0oKTtcbi8qKlxuICogVGhpcyBub2RlIHJlcHJlc2VudHMgYSBwaWVjZSBvZiB0ZXh0LlxuICovXG5cbnZhciBtYXRoTUxUcmVlX1RleHROb2RlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGV4dE5vZGUodGV4dCkge1xuICAgIHRoaXMudGV4dCA9IHZvaWQgMDtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgdGV4dCBub2RlIGludG8gYSBET00gdGV4dCBub2RlLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8yID0gVGV4dE5vZGUucHJvdG90eXBlO1xuXG4gIF9wcm90bzIudG9Ob2RlID0gZnVuY3Rpb24gdG9Ob2RlKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgdGV4dCBub2RlIGludG8gZXNjYXBlZCBIVE1MIG1hcmt1cFxuICAgKiAocmVwcmVzZW50aW5nIHRoZSB0ZXh0IGl0c2VsZikuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvMi50b01hcmt1cCA9IGZ1bmN0aW9uIHRvTWFya3VwKCkge1xuICAgIHJldHVybiB1dGlscy5lc2NhcGUodGhpcy50b1RleHQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSB0ZXh0IG5vZGUgaW50byBhIHN0cmluZ1xuICAgKiAocmVwcmVzZW50aW5nIHRoZSB0ZXh0IGl0ZXNlbGYpLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzIudG9UZXh0ID0gZnVuY3Rpb24gdG9UZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIFRleHROb2RlO1xufSgpO1xuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhIHNwYWNlLCBidXQgbWF5IHJlbmRlciBhcyA8bXNwYWNlLi4uLz4gb3IgYXMgdGV4dCxcbiAqIGRlcGVuZGluZyBvbiB0aGUgd2lkdGguXG4gKi9cblxudmFyIFNwYWNlTm9kZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBTcGFjZSBub2RlIHdpdGggd2lkdGggZ2l2ZW4gaW4gQ1NTIGVtcy5cbiAgICovXG4gIGZ1bmN0aW9uIFNwYWNlTm9kZSh3aWR0aCkge1xuICAgIHRoaXMud2lkdGggPSB2b2lkIDA7XG4gICAgdGhpcy5jaGFyYWN0ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoOyAvLyBTZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDAvV0QtTWF0aE1MMi0yMDAwMDMyOC9jaGFwdGVyNi5odG1sXG4gICAgLy8gZm9yIGEgdGFibGUgb2Ygc3BhY2UtbGlrZSBjaGFyYWN0ZXJzLiAgV2UgdXNlIFVuaWNvZGVcbiAgICAvLyByZXByZXNlbnRhdGlvbnMgaW5zdGVhZCBvZiAmTG9uZ05hbWVzOyBhcyBpdCdzIG5vdCBjbGVhciBob3cgdG9cbiAgICAvLyBtYWtlIHRoZSBsYXR0ZXIgdmlhIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlLlxuXG4gICAgaWYgKHdpZHRoID49IDAuMDU1NTUgJiYgd2lkdGggPD0gMC4wNTU1Nikge1xuICAgICAgdGhpcy5jaGFyYWN0ZXIgPSBcIlxcdTIwMEFcIjsgLy8gJlZlcnlUaGluU3BhY2U7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA+PSAwLjE2NjYgJiYgd2lkdGggPD0gMC4xNjY3KSB7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IFwiXFx1MjAwOVwiOyAvLyAmVGhpblNwYWNlO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPj0gMC4yMjIyICYmIHdpZHRoIDw9IDAuMjIyMykge1xuICAgICAgdGhpcy5jaGFyYWN0ZXIgPSBcIlxcdTIwMDVcIjsgLy8gJk1lZGl1bVNwYWNlO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPj0gMC4yNzc3ICYmIHdpZHRoIDw9IDAuMjc3OCkge1xuICAgICAgdGhpcy5jaGFyYWN0ZXIgPSBcIlxcdTIwMDVcXHUyMDBBXCI7IC8vICZUaGlja1NwYWNlO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPj0gLTAuMDU1NTYgJiYgd2lkdGggPD0gLTAuMDU1NTUpIHtcbiAgICAgIHRoaXMuY2hhcmFjdGVyID0gXCJcXHUyMDBBXFx1MjA2M1wiOyAvLyAmTmVnYXRpdmVWZXJ5VGhpblNwYWNlO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPj0gLTAuMTY2NyAmJiB3aWR0aCA8PSAtMC4xNjY2KSB7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IFwiXFx1MjAwOVxcdTIwNjNcIjsgLy8gJk5lZ2F0aXZlVGhpblNwYWNlO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPj0gLTAuMjIyMyAmJiB3aWR0aCA8PSAtMC4yMjIyKSB7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IFwiXFx1MjA1RlxcdTIwNjNcIjsgLy8gJk5lZ2F0aXZlTWVkaXVtU3BhY2U7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA+PSAtMC4yNzc4ICYmIHdpZHRoIDw9IC0wLjI3NzcpIHtcbiAgICAgIHRoaXMuY2hhcmFjdGVyID0gXCJcXHUyMDA1XFx1MjA2M1wiOyAvLyAmTmVnYXRpdmVUaGlja1NwYWNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgbWF0aCBub2RlIGludG8gYSBNYXRoTUwtbmFtZXNwYWNlZCBET00gZWxlbWVudC5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvMyA9IFNwYWNlTm9kZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMy50b05vZGUgPSBmdW5jdGlvbiB0b05vZGUoKSB7XG4gICAgaWYgKHRoaXMuY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5jaGFyYWN0ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIiwgXCJtc3BhY2VcIik7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHRoaXMud2lkdGggKyBcImVtXCIpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgbWF0aCBub2RlIGludG8gYW4gSFRNTCBtYXJrdXAgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzMudG9NYXJrdXAgPSBmdW5jdGlvbiB0b01hcmt1cCgpIHtcbiAgICBpZiAodGhpcy5jaGFyYWN0ZXIpIHtcbiAgICAgIHJldHVybiBcIjxtdGV4dD5cIiArIHRoaXMuY2hhcmFjdGVyICsgXCI8L210ZXh0PlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCI8bXNwYWNlIHdpZHRoPVxcXCJcIiArIHRoaXMud2lkdGggKyBcImVtXFxcIi8+XCI7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgbWF0aCBub2RlIGludG8gYSBzdHJpbmcsIHNpbWlsYXIgdG8gaW5uZXJUZXh0LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzMudG9UZXh0ID0gZnVuY3Rpb24gdG9UZXh0KCkge1xuICAgIGlmICh0aGlzLmNoYXJhY3Rlcikge1xuICAgICAgcmV0dXJuIHRoaXMuY2hhcmFjdGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCIgXCI7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBTcGFjZU5vZGU7XG59KCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIG1hdGhNTFRyZWUgPSAoe1xuICBNYXRoTm9kZTogbWF0aE1MVHJlZV9NYXRoTm9kZSxcbiAgVGV4dE5vZGU6IG1hdGhNTFRyZWVfVGV4dE5vZGUsXG4gIFNwYWNlTm9kZTogU3BhY2VOb2RlLFxuICBuZXdEb2N1bWVudEZyYWdtZW50OiBuZXdEb2N1bWVudEZyYWdtZW50XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2J1aWxkTWF0aE1MLmpzXG4vKipcbiAqIFRoaXMgZmlsZSBjb252ZXJ0cyBhIHBhcnNlIHRyZWUgaW50byBhIGNvb3Jlc3BvbmRpbmcgTWF0aE1MIHRyZWUuIFRoZSBtYWluXG4gKiBlbnRyeSBwb2ludCBpcyB0aGUgYGJ1aWxkTWF0aE1MYCBmdW5jdGlvbiwgd2hpY2ggdGFrZXMgYSBwYXJzZSB0cmVlIGZyb20gdGhlXG4gKiBwYXJzZXIuXG4gKi9cblxuXG5cblxuXG5cblxuXG5cbi8qKlxuICogVGFrZXMgYSBzeW1ib2wgYW5kIGNvbnZlcnRzIGl0IGludG8gYSBNYXRoTUwgdGV4dCBub2RlIGFmdGVyIHBlcmZvcm1pbmdcbiAqIG9wdGlvbmFsIHJlcGxhY2VtZW50IGZyb20gc3ltYm9scy5qcy5cbiAqL1xudmFyIGJ1aWxkTWF0aE1MX21ha2VUZXh0ID0gZnVuY3Rpb24gbWFrZVRleHQodGV4dCwgbW9kZSwgb3B0aW9ucykge1xuICBpZiAoc3JjX3N5bWJvbHNbbW9kZV1bdGV4dF0gJiYgc3JjX3N5bWJvbHNbbW9kZV1bdGV4dF0ucmVwbGFjZSAmJiB0ZXh0LmNoYXJDb2RlQXQoMCkgIT09IDB4RDgzNSAmJiAhKGxpZ2F0dXJlcy5oYXNPd25Qcm9wZXJ0eSh0ZXh0KSAmJiBvcHRpb25zICYmIChvcHRpb25zLmZvbnRGYW1pbHkgJiYgb3B0aW9ucy5mb250RmFtaWx5LnN1YnN0cig0LCAyKSA9PT0gXCJ0dFwiIHx8IG9wdGlvbnMuZm9udCAmJiBvcHRpb25zLmZvbnQuc3Vic3RyKDQsIDIpID09PSBcInR0XCIpKSkge1xuICAgIHRleHQgPSBzcmNfc3ltYm9sc1ttb2RlXVt0ZXh0XS5yZXBsYWNlO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLlRleHROb2RlKHRleHQpO1xufTtcbi8qKlxuICogV3JhcCB0aGUgZ2l2ZW4gYXJyYXkgb2Ygbm9kZXMgaW4gYW4gPG1yb3c+IG5vZGUgaWYgbmVlZGVkLCBpLmUuLFxuICogdW5sZXNzIHRoZSBhcnJheSBoYXMgbGVuZ3RoIDEuICBBbHdheXMgcmV0dXJucyBhIHNpbmdsZSBub2RlLlxuICovXG5cbnZhciBidWlsZE1hdGhNTF9tYWtlUm93ID0gZnVuY3Rpb24gbWFrZVJvdyhib2R5KSB7XG4gIGlmIChib2R5Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBib2R5WzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgYm9keSk7XG4gIH1cbn07XG4vKipcbiAqIFJldHVybnMgdGhlIG1hdGggdmFyaWFudCBhcyBhIHN0cmluZyBvciBudWxsIGlmIG5vbmUgaXMgcmVxdWlyZWQuXG4gKi9cblxudmFyIGJ1aWxkTWF0aE1MX2dldFZhcmlhbnQgPSBmdW5jdGlvbiBnZXRWYXJpYW50KGdyb3VwLCBvcHRpb25zKSB7XG4gIC8vIEhhbmRsZSBcXHRleHQuLi4gZm9udCBzcGVjaWZpZXJzIGFzIGJlc3Qgd2UgY2FuLlxuICAvLyBNYXRoTUwgaGFzIGEgbGltaXRlZCBsaXN0IG9mIGFsbG93YWJsZSBtYXRodmFyaWFudCBzcGVjaWZpZXJzOyBzZWVcbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL01hdGhNTDMvY2hhcHRlcjMuaHRtbCNwcmVzbS5jb21tYXR0XG4gIGlmIChvcHRpb25zLmZvbnRGYW1pbHkgPT09IFwidGV4dHR0XCIpIHtcbiAgICByZXR1cm4gXCJtb25vc3BhY2VcIjtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmZvbnRGYW1pbHkgPT09IFwidGV4dHNmXCIpIHtcbiAgICBpZiAob3B0aW9ucy5mb250U2hhcGUgPT09IFwidGV4dGl0XCIgJiYgb3B0aW9ucy5mb250V2VpZ2h0ID09PSBcInRleHRiZlwiKSB7XG4gICAgICByZXR1cm4gXCJzYW5zLXNlcmlmLWJvbGQtaXRhbGljXCI7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmZvbnRTaGFwZSA9PT0gXCJ0ZXh0aXRcIikge1xuICAgICAgcmV0dXJuIFwic2Fucy1zZXJpZi1pdGFsaWNcIjtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZm9udFdlaWdodCA9PT0gXCJ0ZXh0YmZcIikge1xuICAgICAgcmV0dXJuIFwiYm9sZC1zYW5zLXNlcmlmXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcInNhbnMtc2VyaWZcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5mb250U2hhcGUgPT09IFwidGV4dGl0XCIgJiYgb3B0aW9ucy5mb250V2VpZ2h0ID09PSBcInRleHRiZlwiKSB7XG4gICAgcmV0dXJuIFwiYm9sZC1pdGFsaWNcIjtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmZvbnRTaGFwZSA9PT0gXCJ0ZXh0aXRcIikge1xuICAgIHJldHVybiBcIml0YWxpY1wiO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuZm9udFdlaWdodCA9PT0gXCJ0ZXh0YmZcIikge1xuICAgIHJldHVybiBcImJvbGRcIjtcbiAgfVxuXG4gIHZhciBmb250ID0gb3B0aW9ucy5mb250O1xuXG4gIGlmICghZm9udCB8fCBmb250ID09PSBcIm1hdGhub3JtYWxcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1vZGUgPSBncm91cC5tb2RlO1xuXG4gIGlmIChmb250ID09PSBcIm1hdGhpdFwiKSB7XG4gICAgcmV0dXJuIFwiaXRhbGljXCI7XG4gIH0gZWxzZSBpZiAoZm9udCA9PT0gXCJib2xkc3ltYm9sXCIpIHtcbiAgICByZXR1cm4gXCJib2xkLWl0YWxpY1wiO1xuICB9IGVsc2UgaWYgKGZvbnQgPT09IFwibWF0aGJmXCIpIHtcbiAgICByZXR1cm4gXCJib2xkXCI7XG4gIH0gZWxzZSBpZiAoZm9udCA9PT0gXCJtYXRoYmJcIikge1xuICAgIHJldHVybiBcImRvdWJsZS1zdHJ1Y2tcIjtcbiAgfSBlbHNlIGlmIChmb250ID09PSBcIm1hdGhmcmFrXCIpIHtcbiAgICByZXR1cm4gXCJmcmFrdHVyXCI7XG4gIH0gZWxzZSBpZiAoZm9udCA9PT0gXCJtYXRoc2NyXCIgfHwgZm9udCA9PT0gXCJtYXRoY2FsXCIpIHtcbiAgICAvLyBNYXRoTUwgbWFrZXMgbm8gZGlzdGluY3Rpb24gYmV0d2VlbiBzY3JpcHQgYW5kIGNhbGlncmFocGljXG4gICAgcmV0dXJuIFwic2NyaXB0XCI7XG4gIH0gZWxzZSBpZiAoZm9udCA9PT0gXCJtYXRoc2ZcIikge1xuICAgIHJldHVybiBcInNhbnMtc2VyaWZcIjtcbiAgfSBlbHNlIGlmIChmb250ID09PSBcIm1hdGh0dFwiKSB7XG4gICAgcmV0dXJuIFwibW9ub3NwYWNlXCI7XG4gIH1cblxuICB2YXIgdGV4dCA9IGdyb3VwLnRleHQ7XG5cbiAgaWYgKHV0aWxzLmNvbnRhaW5zKFtcIlxcXFxpbWF0aFwiLCBcIlxcXFxqbWF0aFwiXSwgdGV4dCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChzcmNfc3ltYm9sc1ttb2RlXVt0ZXh0XSAmJiBzcmNfc3ltYm9sc1ttb2RlXVt0ZXh0XS5yZXBsYWNlKSB7XG4gICAgdGV4dCA9IHNyY19zeW1ib2xzW21vZGVdW3RleHRdLnJlcGxhY2U7XG4gIH1cblxuICB2YXIgZm9udE5hbWUgPSBidWlsZENvbW1vbi5mb250TWFwW2ZvbnRdLmZvbnROYW1lO1xuXG4gIGlmIChnZXRDaGFyYWN0ZXJNZXRyaWNzKHRleHQsIGZvbnROYW1lLCBtb2RlKSkge1xuICAgIHJldHVybiBidWlsZENvbW1vbi5mb250TWFwW2ZvbnRdLnZhcmlhbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG4vKipcbiAqIFRha2VzIGEgbGlzdCBvZiBub2RlcywgYnVpbGRzIHRoZW0sIGFuZCByZXR1cm5zIGEgbGlzdCBvZiB0aGUgZ2VuZXJhdGVkXG4gKiBNYXRoTUwgbm9kZXMuICBBbHNvIGNvbWJpbmUgY29uc2VjdXRpdmUgPG10ZXh0PiBvdXRwdXRzIGludG8gYSBzaW5nbGVcbiAqIDxtdGV4dD4gdGFnLlxuICovXG5cbnZhciBidWlsZE1hdGhNTF9idWlsZEV4cHJlc3Npb24gPSBmdW5jdGlvbiBidWlsZEV4cHJlc3Npb24oZXhwcmVzc2lvbiwgb3B0aW9ucywgaXNPcmRncm91cCkge1xuICBpZiAoZXhwcmVzc2lvbi5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZ3JvdXAgPSBidWlsZE1hdGhNTF9idWlsZEdyb3VwKGV4cHJlc3Npb25bMF0sIG9wdGlvbnMpO1xuXG4gICAgaWYgKGlzT3JkZ3JvdXAgJiYgZ3JvdXAgaW5zdGFuY2VvZiBtYXRoTUxUcmVlX01hdGhOb2RlICYmIGdyb3VwLnR5cGUgPT09IFwibW9cIikge1xuICAgICAgLy8gV2hlbiBUZVggd3JpdGVycyB3YW50IHRvIHN1cHByZXNzIHNwYWNpbmcgb24gYW4gb3BlcmF0b3IsXG4gICAgICAvLyB0aGV5IG9mdGVuIHB1dCB0aGUgb3BlcmF0b3IgYnkgaXRzZWxmIGluc2lkZSBicmFjZXMuXG4gICAgICBncm91cC5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgXCIwZW1cIik7XG4gICAgICBncm91cC5zZXRBdHRyaWJ1dGUoXCJyc3BhY2VcIiwgXCIwZW1cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtncm91cF07XG4gIH1cblxuICB2YXIgZ3JvdXBzID0gW107XG4gIHZhciBsYXN0R3JvdXA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9ncm91cCA9IGJ1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZXhwcmVzc2lvbltpXSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoX2dyb3VwIGluc3RhbmNlb2YgbWF0aE1MVHJlZV9NYXRoTm9kZSAmJiBsYXN0R3JvdXAgaW5zdGFuY2VvZiBtYXRoTUxUcmVlX01hdGhOb2RlKSB7XG4gICAgICAvLyBDb25jYXRlbmF0ZSBhZGphY2VudCA8bXRleHQ+c1xuICAgICAgaWYgKF9ncm91cC50eXBlID09PSAnbXRleHQnICYmIGxhc3RHcm91cC50eXBlID09PSAnbXRleHQnICYmIF9ncm91cC5nZXRBdHRyaWJ1dGUoJ21hdGh2YXJpYW50JykgPT09IGxhc3RHcm91cC5nZXRBdHRyaWJ1dGUoJ21hdGh2YXJpYW50JykpIHtcbiAgICAgICAgdmFyIF9sYXN0R3JvdXAkY2hpbGRyZW47XG5cbiAgICAgICAgKF9sYXN0R3JvdXAkY2hpbGRyZW4gPSBsYXN0R3JvdXAuY2hpbGRyZW4pLnB1c2guYXBwbHkoX2xhc3RHcm91cCRjaGlsZHJlbiwgX2dyb3VwLmNoaWxkcmVuKTtcblxuICAgICAgICBjb250aW51ZTsgLy8gQ29uY2F0ZW5hdGUgYWRqYWNlbnQgPG1uPnNcbiAgICAgIH0gZWxzZSBpZiAoX2dyb3VwLnR5cGUgPT09ICdtbicgJiYgbGFzdEdyb3VwLnR5cGUgPT09ICdtbicpIHtcbiAgICAgICAgdmFyIF9sYXN0R3JvdXAkY2hpbGRyZW4yO1xuXG4gICAgICAgIChfbGFzdEdyb3VwJGNoaWxkcmVuMiA9IGxhc3RHcm91cC5jaGlsZHJlbikucHVzaC5hcHBseShfbGFzdEdyb3VwJGNoaWxkcmVuMiwgX2dyb3VwLmNoaWxkcmVuKTtcblxuICAgICAgICBjb250aW51ZTsgLy8gQ29uY2F0ZW5hdGUgPG1uPi4uLjwvbW4+IGZvbGxvd2VkIGJ5IDxtaT4uPC9taT5cbiAgICAgIH0gZWxzZSBpZiAoX2dyb3VwLnR5cGUgPT09ICdtaScgJiYgX2dyb3VwLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBsYXN0R3JvdXAudHlwZSA9PT0gJ21uJykge1xuICAgICAgICB2YXIgY2hpbGQgPSBfZ3JvdXAuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgbWF0aE1MVHJlZV9UZXh0Tm9kZSAmJiBjaGlsZC50ZXh0ID09PSAnLicpIHtcbiAgICAgICAgICB2YXIgX2xhc3RHcm91cCRjaGlsZHJlbjM7XG5cbiAgICAgICAgICAoX2xhc3RHcm91cCRjaGlsZHJlbjMgPSBsYXN0R3JvdXAuY2hpbGRyZW4pLnB1c2guYXBwbHkoX2xhc3RHcm91cCRjaGlsZHJlbjMsIF9ncm91cC5jaGlsZHJlbik7XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsYXN0R3JvdXAudHlwZSA9PT0gJ21pJyAmJiBsYXN0R3JvdXAuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBsYXN0Q2hpbGQgPSBsYXN0R3JvdXAuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgaWYgKGxhc3RDaGlsZCBpbnN0YW5jZW9mIG1hdGhNTFRyZWVfVGV4dE5vZGUgJiYgbGFzdENoaWxkLnRleHQgPT09IFwiXFx1MDMzOFwiICYmIChfZ3JvdXAudHlwZSA9PT0gJ21vJyB8fCBfZ3JvdXAudHlwZSA9PT0gJ21pJyB8fCBfZ3JvdXAudHlwZSA9PT0gJ21uJykpIHtcbiAgICAgICAgICB2YXIgX2NoaWxkID0gX2dyb3VwLmNoaWxkcmVuWzBdO1xuXG4gICAgICAgICAgaWYgKF9jaGlsZCBpbnN0YW5jZW9mIG1hdGhNTFRyZWVfVGV4dE5vZGUgJiYgX2NoaWxkLnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gT3ZlcmxheSB3aXRoIGNvbWJpbmluZyBjaGFyYWN0ZXIgbG9uZyBzb2xpZHVzXG4gICAgICAgICAgICBfY2hpbGQudGV4dCA9IF9jaGlsZC50ZXh0LnNsaWNlKDAsIDEpICsgXCJcXHUwMzM4XCIgKyBfY2hpbGQudGV4dC5zbGljZSgxKTtcbiAgICAgICAgICAgIGdyb3Vwcy5wb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBncm91cHMucHVzaChfZ3JvdXApO1xuICAgIGxhc3RHcm91cCA9IF9ncm91cDtcbiAgfVxuXG4gIHJldHVybiBncm91cHM7XG59O1xuLyoqXG4gKiBFcXVpdmFsZW50IHRvIGJ1aWxkRXhwcmVzc2lvbiwgYnV0IHdyYXBzIHRoZSBlbGVtZW50cyBpbiBhbiA8bXJvdz5cbiAqIGlmIHRoZXJlJ3MgbW9yZSB0aGFuIG9uZS4gIFJldHVybnMgYSBzaW5nbGUgbm9kZSBpbnN0ZWFkIG9mIGFuIGFycmF5LlxuICovXG5cbnZhciBidWlsZEV4cHJlc3Npb25Sb3cgPSBmdW5jdGlvbiBidWlsZEV4cHJlc3Npb25Sb3coZXhwcmVzc2lvbiwgb3B0aW9ucywgaXNPcmRncm91cCkge1xuICByZXR1cm4gYnVpbGRNYXRoTUxfbWFrZVJvdyhidWlsZE1hdGhNTF9idWlsZEV4cHJlc3Npb24oZXhwcmVzc2lvbiwgb3B0aW9ucywgaXNPcmRncm91cCkpO1xufTtcbi8qKlxuICogVGFrZXMgYSBncm91cCBmcm9tIHRoZSBwYXJzZXIgYW5kIGNhbGxzIHRoZSBhcHByb3ByaWF0ZSBncm91cEJ1aWxkZXJzIGZ1bmN0aW9uXG4gKiBvbiBpdCB0byBwcm9kdWNlIGEgTWF0aE1MIG5vZGUuXG4gKi9cblxudmFyIGJ1aWxkTWF0aE1MX2J1aWxkR3JvdXAgPSBmdW5jdGlvbiBidWlsZEdyb3VwKGdyb3VwLCBvcHRpb25zKSB7XG4gIGlmICghZ3JvdXApIHtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIpO1xuICB9XG5cbiAgaWYgKF9tYXRobWxHcm91cEJ1aWxkZXJzW2dyb3VwLnR5cGVdKSB7XG4gICAgLy8gQ2FsbCB0aGUgZ3JvdXBCdWlsZGVycyBmdW5jdGlvblxuICAgIHZhciByZXN1bHQgPSBfbWF0aG1sR3JvdXBCdWlsZGVyc1tncm91cC50eXBlXShncm91cCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJHb3QgZ3JvdXAgb2YgdW5rbm93biB0eXBlOiAnXCIgKyBncm91cC50eXBlICsgXCInXCIpO1xuICB9XG59O1xuLyoqXG4gKiBUYWtlcyBhIGZ1bGwgcGFyc2UgdHJlZSBhbmQgc2V0dGluZ3MgYW5kIGJ1aWxkcyBhIE1hdGhNTCByZXByZXNlbnRhdGlvbiBvZlxuICogaXQuIEluIHBhcnRpY3VsYXIsIHdlIHB1dCB0aGUgZWxlbWVudHMgZnJvbSBidWlsZGluZyB0aGUgcGFyc2UgdHJlZSBpbnRvIGFcbiAqIDxzZW1hbnRpY3M+IHRhZyBzbyB3ZSBjYW4gYWxzbyBpbmNsdWRlIHRoYXQgVGVYIHNvdXJjZSBhcyBhbiBhbm5vdGF0aW9uLlxuICpcbiAqIE5vdGUgdGhhdCB3ZSBhY3R1YWxseSByZXR1cm4gYSBkb21UcmVlIGVsZW1lbnQgd2l0aCBhIGA8bWF0aD5gIGluc2lkZSBpdCBzb1xuICogd2UgY2FuIGRvIGFwcHJvcHJpYXRlIHN0eWxpbmcuXG4gKi9cblxuZnVuY3Rpb24gYnVpbGRNYXRoTUwodHJlZSwgdGV4RXhwcmVzc2lvbiwgb3B0aW9ucywgZm9yTWF0aG1sT25seSkge1xuICB2YXIgZXhwcmVzc2lvbiA9IGJ1aWxkTWF0aE1MX2J1aWxkRXhwcmVzc2lvbih0cmVlLCBvcHRpb25zKTsgLy8gV3JhcCB1cCB0aGUgZXhwcmVzc2lvbiBpbiBhbiBtcm93IHNvIGl0IGlzIHByZXNlbnRlZCBpbiB0aGUgc2VtYW50aWNzXG4gIC8vIHRhZyBjb3JyZWN0bHksIHVubGVzcyBpdCdzIGEgc2luZ2xlIDxtcm93PiBvciA8bXRhYmxlPi5cblxuICB2YXIgd3JhcHBlcjtcblxuICBpZiAoZXhwcmVzc2lvbi5sZW5ndGggPT09IDEgJiYgZXhwcmVzc2lvblswXSBpbnN0YW5jZW9mIG1hdGhNTFRyZWVfTWF0aE5vZGUgJiYgdXRpbHMuY29udGFpbnMoW1wibXJvd1wiLCBcIm10YWJsZVwiXSwgZXhwcmVzc2lvblswXS50eXBlKSkge1xuICAgIHdyYXBwZXIgPSBleHByZXNzaW9uWzBdO1xuICB9IGVsc2Uge1xuICAgIHdyYXBwZXIgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgZXhwcmVzc2lvbik7XG4gIH0gLy8gQnVpbGQgYSBUZVggYW5ub3RhdGlvbiBvZiB0aGUgc291cmNlXG5cblxuICB2YXIgYW5ub3RhdGlvbiA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwiYW5ub3RhdGlvblwiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUodGV4RXhwcmVzc2lvbildKTtcbiAgYW5ub3RhdGlvbi5zZXRBdHRyaWJ1dGUoXCJlbmNvZGluZ1wiLCBcImFwcGxpY2F0aW9uL3gtdGV4XCIpO1xuICB2YXIgc2VtYW50aWNzID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJzZW1hbnRpY3NcIiwgW3dyYXBwZXIsIGFubm90YXRpb25dKTtcbiAgdmFyIG1hdGggPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1hdGhcIiwgW3NlbWFudGljc10pO1xuICBtYXRoLnNldEF0dHJpYnV0ZShcInhtbG5zXCIsIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiKTsgLy8gWW91IGNhbid0IHN0eWxlIDxtYXRoPiBub2Rlcywgc28gd2Ugd3JhcCB0aGUgbm9kZSBpbiBhIHNwYW4uXG4gIC8vIE5PVEU6IFRoZSBzcGFuIGNsYXNzIGlzIG5vdCB0eXBlZCB0byBoYXZlIDxtYXRoPiBub2RlcyBhcyBjaGlsZHJlbiwgYW5kXG4gIC8vIHdlIGRvbid0IHdhbnQgdG8gbWFrZSB0aGUgY2hpbGRyZW4gdHlwZSBtb3JlIGdlbmVyaWMgc2luY2UgdGhlIGNoaWxkcmVuXG4gIC8vIG9mIHNwYW4gYXJlIGV4cGVjdGVkIHRvIGhhdmUgbW9yZSBmaWVsZHMgaW4gYGJ1aWxkSHRtbGAgY29udGV4dHMuXG5cbiAgdmFyIHdyYXBwZXJDbGFzcyA9IGZvck1hdGhtbE9ubHkgPyBcImthdGV4XCIgOiBcImthdGV4LW1hdGhtbFwiOyAvLyAkRmxvd0ZpeE1lXG5cbiAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFt3cmFwcGVyQ2xhc3NdLCBbbWF0aF0pO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYnVpbGRUcmVlLmpzXG5cblxuXG5cblxuXG5cbnZhciBidWlsZFRyZWVfb3B0aW9uc0Zyb21TZXR0aW5ncyA9IGZ1bmN0aW9uIG9wdGlvbnNGcm9tU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgcmV0dXJuIG5ldyBzcmNfT3B0aW9ucyh7XG4gICAgc3R5bGU6IHNldHRpbmdzLmRpc3BsYXlNb2RlID8gc3JjX1N0eWxlLkRJU1BMQVkgOiBzcmNfU3R5bGUuVEVYVCxcbiAgICBtYXhTaXplOiBzZXR0aW5ncy5tYXhTaXplLFxuICAgIG1pblJ1bGVUaGlja25lc3M6IHNldHRpbmdzLm1pblJ1bGVUaGlja25lc3NcbiAgfSk7XG59O1xuXG52YXIgYnVpbGRUcmVlX2Rpc3BsYXlXcmFwID0gZnVuY3Rpb24gZGlzcGxheVdyYXAobm9kZSwgc2V0dGluZ3MpIHtcbiAgaWYgKHNldHRpbmdzLmRpc3BsYXlNb2RlKSB7XG4gICAgdmFyIGNsYXNzZXMgPSBbXCJrYXRleC1kaXNwbGF5XCJdO1xuXG4gICAgaWYgKHNldHRpbmdzLmxlcW5vKSB7XG4gICAgICBjbGFzc2VzLnB1c2goXCJsZXFub1wiKTtcbiAgICB9XG5cbiAgICBpZiAoc2V0dGluZ3MuZmxlcW4pIHtcbiAgICAgIGNsYXNzZXMucHVzaChcImZsZXFuXCIpO1xuICAgIH1cblxuICAgIG5vZGUgPSBidWlsZENvbW1vbi5tYWtlU3BhbihjbGFzc2VzLCBbbm9kZV0pO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG52YXIgYnVpbGRUcmVlX2J1aWxkVHJlZSA9IGZ1bmN0aW9uIGJ1aWxkVHJlZSh0cmVlLCBleHByZXNzaW9uLCBzZXR0aW5ncykge1xuICB2YXIgb3B0aW9ucyA9IGJ1aWxkVHJlZV9vcHRpb25zRnJvbVNldHRpbmdzKHNldHRpbmdzKTtcbiAgdmFyIGthdGV4Tm9kZTtcblxuICBpZiAoc2V0dGluZ3Mub3V0cHV0ID09PSBcIm1hdGhtbFwiKSB7XG4gICAgcmV0dXJuIGJ1aWxkTWF0aE1MKHRyZWUsIGV4cHJlc3Npb24sIG9wdGlvbnMsIHRydWUpO1xuICB9IGVsc2UgaWYgKHNldHRpbmdzLm91dHB1dCA9PT0gXCJodG1sXCIpIHtcbiAgICB2YXIgaHRtbE5vZGUgPSBidWlsZEhUTUwodHJlZSwgb3B0aW9ucyk7XG4gICAga2F0ZXhOb2RlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wia2F0ZXhcIl0sIFtodG1sTm9kZV0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBtYXRoTUxOb2RlID0gYnVpbGRNYXRoTUwodHJlZSwgZXhwcmVzc2lvbiwgb3B0aW9ucywgZmFsc2UpO1xuXG4gICAgdmFyIF9odG1sTm9kZSA9IGJ1aWxkSFRNTCh0cmVlLCBvcHRpb25zKTtcblxuICAgIGthdGV4Tm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImthdGV4XCJdLCBbbWF0aE1MTm9kZSwgX2h0bWxOb2RlXSk7XG4gIH1cblxuICByZXR1cm4gYnVpbGRUcmVlX2Rpc3BsYXlXcmFwKGthdGV4Tm9kZSwgc2V0dGluZ3MpO1xufTtcbnZhciBidWlsZFRyZWVfYnVpbGRIVE1MVHJlZSA9IGZ1bmN0aW9uIGJ1aWxkSFRNTFRyZWUodHJlZSwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpIHtcbiAgdmFyIG9wdGlvbnMgPSBidWlsZFRyZWVfb3B0aW9uc0Zyb21TZXR0aW5ncyhzZXR0aW5ncyk7XG4gIHZhciBodG1sTm9kZSA9IGJ1aWxkSFRNTCh0cmVlLCBvcHRpb25zKTtcbiAgdmFyIGthdGV4Tm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImthdGV4XCJdLCBbaHRtbE5vZGVdKTtcbiAgcmV0dXJuIGJ1aWxkVHJlZV9kaXNwbGF5V3JhcChrYXRleE5vZGUsIHNldHRpbmdzKTtcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfYnVpbGRUcmVlID0gKGJ1aWxkVHJlZV9idWlsZFRyZWUpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc3RyZXRjaHkuanNcbi8qKlxuICogVGhpcyBmaWxlIHByb3ZpZGVzIHN1cHBvcnQgdG8gYnVpbGRNYXRoTUwuanMgYW5kIGJ1aWxkSFRNTC5qc1xuICogZm9yIHN0cmV0Y2h5IHdpZGUgZWxlbWVudHMgcmVuZGVyZWQgZnJvbSBTVkcgZmlsZXNcbiAqIGFuZCBvdGhlciBDU1MgdHJpY2tlcnkuXG4gKi9cblxuXG5cblxudmFyIHN0cmV0Y2h5Q29kZVBvaW50ID0ge1xuICB3aWRlaGF0OiBcIl5cIixcbiAgd2lkZWNoZWNrOiBcIsuHXCIsXG4gIHdpZGV0aWxkZTogXCJ+XCIsXG4gIHV0aWxkZTogXCJ+XCIsXG4gIG92ZXJsZWZ0YXJyb3c6IFwiXFx1MjE5MFwiLFxuICB1bmRlcmxlZnRhcnJvdzogXCJcXHUyMTkwXCIsXG4gIHhsZWZ0YXJyb3c6IFwiXFx1MjE5MFwiLFxuICBvdmVycmlnaHRhcnJvdzogXCJcXHUyMTkyXCIsXG4gIHVuZGVycmlnaHRhcnJvdzogXCJcXHUyMTkyXCIsXG4gIHhyaWdodGFycm93OiBcIlxcdTIxOTJcIixcbiAgdW5kZXJicmFjZTogXCJcXHUyM0RGXCIsXG4gIG92ZXJicmFjZTogXCJcXHUyM0RFXCIsXG4gIG92ZXJncm91cDogXCJcXHUyM0UwXCIsXG4gIHVuZGVyZ3JvdXA6IFwiXFx1MjNFMVwiLFxuICBvdmVybGVmdHJpZ2h0YXJyb3c6IFwiXFx1MjE5NFwiLFxuICB1bmRlcmxlZnRyaWdodGFycm93OiBcIlxcdTIxOTRcIixcbiAgeGxlZnRyaWdodGFycm93OiBcIlxcdTIxOTRcIixcbiAgT3ZlcnJpZ2h0YXJyb3c6IFwiXFx1MjFEMlwiLFxuICB4UmlnaHRhcnJvdzogXCJcXHUyMUQyXCIsXG4gIG92ZXJsZWZ0aGFycG9vbjogXCJcXHUyMUJDXCIsXG4gIHhsZWZ0aGFycG9vbnVwOiBcIlxcdTIxQkNcIixcbiAgb3ZlcnJpZ2h0aGFycG9vbjogXCJcXHUyMUMwXCIsXG4gIHhyaWdodGhhcnBvb251cDogXCJcXHUyMUMwXCIsXG4gIHhMZWZ0YXJyb3c6IFwiXFx1MjFEMFwiLFxuICB4TGVmdHJpZ2h0YXJyb3c6IFwiXFx1MjFENFwiLFxuICB4aG9va2xlZnRhcnJvdzogXCJcXHUyMUE5XCIsXG4gIHhob29rcmlnaHRhcnJvdzogXCJcXHUyMUFBXCIsXG4gIHhtYXBzdG86IFwiXFx1MjFBNlwiLFxuICB4cmlnaHRoYXJwb29uZG93bjogXCJcXHUyMUMxXCIsXG4gIHhsZWZ0aGFycG9vbmRvd246IFwiXFx1MjFCRFwiLFxuICB4cmlnaHRsZWZ0aGFycG9vbnM6IFwiXFx1MjFDQ1wiLFxuICB4bGVmdHJpZ2h0aGFycG9vbnM6IFwiXFx1MjFDQlwiLFxuICB4dHdvaGVhZGxlZnRhcnJvdzogXCJcXHUyMTlFXCIsXG4gIHh0d29oZWFkcmlnaHRhcnJvdzogXCJcXHUyMUEwXCIsXG4gIHhsb25nZXF1YWw6IFwiPVwiLFxuICB4dG9mcm9tOiBcIlxcdTIxQzRcIixcbiAgeHJpZ2h0bGVmdGFycm93czogXCJcXHUyMUM0XCIsXG4gIHhyaWdodGVxdWlsaWJyaXVtOiBcIlxcdTIxQ0NcIixcbiAgLy8gTm90IGEgcGVyZmVjdCBtYXRjaC5cbiAgeGxlZnRlcXVpbGlicml1bTogXCJcXHUyMUNCXCIgLy8gTm9uZSBiZXR0ZXIgYXZhaWxhYmxlLlxuXG59O1xuXG52YXIgc3RyZXRjaHlfbWF0aE1Mbm9kZSA9IGZ1bmN0aW9uIG1hdGhNTG5vZGUobGFiZWwpIHtcbiAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShzdHJldGNoeUNvZGVQb2ludFtsYWJlbC5zdWJzdHIoMSldKV0pO1xuICBub2RlLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwidHJ1ZVwiKTtcbiAgcmV0dXJuIG5vZGU7XG59OyAvLyBNYW55IG9mIHRoZSBLYVRlWCBTVkcgaW1hZ2VzIGhhdmUgYmVlbiBhZGFwdGVkIGZyb20gZ2x5cGhzIGluIEthVGVYIGZvbnRzLlxuLy8gQ29weXJpZ2h0IChjKSAyMDA5LTIwMTAsIERlc2lnbiBTY2llbmNlLCBJbmMuICg8d3d3Lm1hdGhqYXgub3JnPilcbi8vIENvcHlyaWdodCAoYykgMjAxNC0yMDE3IEtoYW4gQWNhZGVteSAoPHd3dy5raGFuYWNhZGVteS5vcmc+KVxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIFNJTCBPcGVuIEZvbnQgTGljZW5zZSwgVmVyc2lvbiAxLjEuXG4vLyBTZWUgXFxuaHR0cDovL3NjcmlwdHMuc2lsLm9yZy9PRkxcbi8vIFZlcnkgTG9uZyBTVkdzXG4vLyAgICBNYW55IG9mIHRoZSBLYVRlWCBzdHJldGNoeSB3aWRlIGVsZW1lbnRzIHVzZSBhIGxvbmcgU1ZHIGltYWdlIGFuZCBhblxuLy8gICAgb3ZlcmZsb3c6IGhpZGRlbiB0YWN0aWMgdG8gYWNoaWV2ZSBhIHN0cmV0Y2h5IGltYWdlIHdoaWxlIGF2b2lkaW5nXG4vLyAgICBkaXN0b3J0aW9uIG9mIGFycm93aGVhZHMgb3IgYnJhY2UgY29ybmVycy5cbi8vICAgIFRoZSBTVkcgdHlwaWNhbGx5IGNvbnRhaW5zIGEgdmVyeSBsb25nICg0MDAgZW0pIGFycm93LlxuLy8gICAgVGhlIFNWRyBpcyBpbiBhIGNvbnRhaW5lciBzcGFuIHRoYXQgaGFzIG92ZXJmbG93OiBoaWRkZW4sIHNvIHRoZSBzcGFuXG4vLyAgICBhY3RzIGxpa2UgYSB3aW5kb3cgdGhhdCBleHBvc2VzIG9ubHkgcGFydCBvZiB0aGUgIFNWRy5cbi8vICAgIFRoZSBTVkcgYWx3YXlzIGhhcyBhIGxvbmdlciwgdGhpbm5lciBhc3BlY3QgcmF0aW8gdGhhbiB0aGUgY29udGFpbmVyIHNwYW4uXG4vLyAgICBBZnRlciB0aGUgU1ZHIGZpbGxzIDEwMCUgb2YgdGhlIGhlaWdodCBvZiB0aGUgY29udGFpbmVyIHNwYW4sXG4vLyAgICB0aGVyZSBpcyBhIGxvbmcgYXJyb3cgc2hhZnQgbGVmdCBvdmVyLiBUaGF0IGxlZnQtb3ZlciBzaGFmdCBpcyBub3Qgc2hvd24uXG4vLyAgICBJbnN0ZWFkLCBpdCBpcyBzbGljZWQgb2ZmIGJlY2F1c2UgdGhlIHNwYW4ncyBDU1MgaGFzIG92ZXJmbG93OiBoaWRkZW4uXG4vLyAgICBUaHVzLCB0aGUgcmVhZGVyIHNlZXMgYW4gYXJyb3cgdGhhdCBtYXRjaGVzIHRoZSBzdWJqZWN0IG1hdHRlciB3aWR0aFxuLy8gICAgd2l0aG91dCBkaXN0b3J0aW9uLlxuLy8gICAgU29tZSBmdW5jdGlvbnMsIHN1Y2ggYXMgXFxjYW5jZWwsIG5lZWQgdG8gdmFyeSB0aGVpciBhc3BlY3QgcmF0aW8uIFRoZXNlXG4vLyAgICBmdW5jdGlvbnMgZG8gbm90IGdldCB0aGUgb3ZlcmZsb3cgU1ZHIHRyZWF0bWVudC5cbi8vIFNlY29uZCBCcnVzaCBTdHJva2Vcbi8vICAgIExvdyByZXNvbHV0aW9uIG1vbml0b3JzIHN0cnVnZ2xlIHRvIGRpc3BsYXkgaW1hZ2VzIGluIGZpbmUgZGV0YWlsLlxuLy8gICAgU28gYnJvd3NlcnMgYXBwbHkgYW50aS1hbGlhc2luZy4gQSBsb25nIHN0cmFpZ2h0IGFycm93IHNoYWZ0IHRoZXJlZm9yZVxuLy8gICAgd2lsbCBzb21ldGltZXMgYXBwZWFyIGFzIGlmIGl0IGhhcyBhIGJsdXJyZWQgZWRnZS5cbi8vICAgIFRvIG1pdGlnYXRlIHRoaXMsIHRoZXNlIFNWRyBmaWxlcyBjb250YWluIGEgc2Vjb25kIFwiYnJ1c2gtc3Ryb2tlXCIgb24gdGhlXG4vLyAgICBhcnJvdyBzaGFmdHMuIFRoYXQgaXMsIGEgc2Vjb25kIGxvbmcgdGhpbiByZWN0YW5ndWxhciBTVkcgcGF0aCBoYXMgYmVlblxuLy8gICAgd3JpdHRlbiBkaXJlY3RseSBvbiB0b3Agb2YgZWFjaCBhcnJvdyBzaGFmdC4gVGhpcyByZWluZm9yY2VtZW50IGNhdXNlc1xuLy8gICAgc29tZSBvZiB0aGUgc2NyZWVuIHBpeGVscyB0byBkaXNwbGF5IGFzIGJsYWNrIGluc3RlYWQgb2YgdGhlIGFudGktYWxpYXNlZFxuLy8gICAgZ3JheSBwaXhlbCB0aGF0IGEgIHNpbmdsZSBwYXRoIHdvdWxkIGdlbmVyYXRlLiBTbyB3ZSBnZXQgYXJyb3cgc2hhZnRzXG4vLyAgICB3aG9zZSBlZGdlcyBhcHBlYXIgdG8gYmUgc2hhcnBlci5cbi8vIEluIHRoZSBrYXRleEltYWdlc0RhdGEgb2JqZWN0IGp1c3QgYmVsb3csIHRoZSBkaW1lbnNpb25zIGFsbFxuLy8gY29ycmVzcG9uZCB0byBwYXRoIGdlb21ldHJ5IGluc2lkZSB0aGUgcmVsZXZhbnQgU1ZHLlxuLy8gRm9yIGV4YW1wbGUsIFxcb3ZlcnJpZ2h0YXJyb3cgdXNlcyB0aGUgc2FtZSBhcnJvd2hlYWQgYXMgZ2x5cGggVSsyMTkyXG4vLyBmcm9tIHRoZSBLYVRlWCBNYWluIGZvbnQuIFRoZSBzY2FsaW5nIGZhY3RvciBpcyAxMDAwLlxuLy8gVGhhdCBpcywgaW5zaWRlIHRoZSBmb250LCB0aGF0IGFycm93aGVhZCBpcyA1MjIgdW5pdHMgdGFsbCwgd2hpY2hcbi8vIGNvcnJlc3BvbmRzIHRvIDAuNTIyIGVtIGluc2lkZSB0aGUgZG9jdW1lbnQuXG5cblxudmFyIGthdGV4SW1hZ2VzRGF0YSA9IHtcbiAgLy8gICBwYXRoKHMpLCBtaW5XaWR0aCwgaGVpZ2h0LCBhbGlnblxuICBvdmVycmlnaHRhcnJvdzogW1tcInJpZ2h0YXJyb3dcIl0sIDAuODg4LCA1MjIsIFwieE1heFlNaW5cIl0sXG4gIG92ZXJsZWZ0YXJyb3c6IFtbXCJsZWZ0YXJyb3dcIl0sIDAuODg4LCA1MjIsIFwieE1pbllNaW5cIl0sXG4gIHVuZGVycmlnaHRhcnJvdzogW1tcInJpZ2h0YXJyb3dcIl0sIDAuODg4LCA1MjIsIFwieE1heFlNaW5cIl0sXG4gIHVuZGVybGVmdGFycm93OiBbW1wibGVmdGFycm93XCJdLCAwLjg4OCwgNTIyLCBcInhNaW5ZTWluXCJdLFxuICB4cmlnaHRhcnJvdzogW1tcInJpZ2h0YXJyb3dcIl0sIDEuNDY5LCA1MjIsIFwieE1heFlNaW5cIl0sXG4gIHhsZWZ0YXJyb3c6IFtbXCJsZWZ0YXJyb3dcIl0sIDEuNDY5LCA1MjIsIFwieE1pbllNaW5cIl0sXG4gIE92ZXJyaWdodGFycm93OiBbW1wiZG91YmxlcmlnaHRhcnJvd1wiXSwgMC44ODgsIDU2MCwgXCJ4TWF4WU1pblwiXSxcbiAgeFJpZ2h0YXJyb3c6IFtbXCJkb3VibGVyaWdodGFycm93XCJdLCAxLjUyNiwgNTYwLCBcInhNYXhZTWluXCJdLFxuICB4TGVmdGFycm93OiBbW1wiZG91YmxlbGVmdGFycm93XCJdLCAxLjUyNiwgNTYwLCBcInhNaW5ZTWluXCJdLFxuICBvdmVybGVmdGhhcnBvb246IFtbXCJsZWZ0aGFycG9vblwiXSwgMC44ODgsIDUyMiwgXCJ4TWluWU1pblwiXSxcbiAgeGxlZnRoYXJwb29udXA6IFtbXCJsZWZ0aGFycG9vblwiXSwgMC44ODgsIDUyMiwgXCJ4TWluWU1pblwiXSxcbiAgeGxlZnRoYXJwb29uZG93bjogW1tcImxlZnRoYXJwb29uZG93blwiXSwgMC44ODgsIDUyMiwgXCJ4TWluWU1pblwiXSxcbiAgb3ZlcnJpZ2h0aGFycG9vbjogW1tcInJpZ2h0aGFycG9vblwiXSwgMC44ODgsIDUyMiwgXCJ4TWF4WU1pblwiXSxcbiAgeHJpZ2h0aGFycG9vbnVwOiBbW1wicmlnaHRoYXJwb29uXCJdLCAwLjg4OCwgNTIyLCBcInhNYXhZTWluXCJdLFxuICB4cmlnaHRoYXJwb29uZG93bjogW1tcInJpZ2h0aGFycG9vbmRvd25cIl0sIDAuODg4LCA1MjIsIFwieE1heFlNaW5cIl0sXG4gIHhsb25nZXF1YWw6IFtbXCJsb25nZXF1YWxcIl0sIDAuODg4LCAzMzQsIFwieE1pbllNaW5cIl0sXG4gIHh0d29oZWFkbGVmdGFycm93OiBbW1widHdvaGVhZGxlZnRhcnJvd1wiXSwgMC44ODgsIDMzNCwgXCJ4TWluWU1pblwiXSxcbiAgeHR3b2hlYWRyaWdodGFycm93OiBbW1widHdvaGVhZHJpZ2h0YXJyb3dcIl0sIDAuODg4LCAzMzQsIFwieE1heFlNaW5cIl0sXG4gIG92ZXJsZWZ0cmlnaHRhcnJvdzogW1tcImxlZnRhcnJvd1wiLCBcInJpZ2h0YXJyb3dcIl0sIDAuODg4LCA1MjJdLFxuICBvdmVyYnJhY2U6IFtbXCJsZWZ0YnJhY2VcIiwgXCJtaWRicmFjZVwiLCBcInJpZ2h0YnJhY2VcIl0sIDEuNiwgNTQ4XSxcbiAgdW5kZXJicmFjZTogW1tcImxlZnRicmFjZXVuZGVyXCIsIFwibWlkYnJhY2V1bmRlclwiLCBcInJpZ2h0YnJhY2V1bmRlclwiXSwgMS42LCA1NDhdLFxuICB1bmRlcmxlZnRyaWdodGFycm93OiBbW1wibGVmdGFycm93XCIsIFwicmlnaHRhcnJvd1wiXSwgMC44ODgsIDUyMl0sXG4gIHhsZWZ0cmlnaHRhcnJvdzogW1tcImxlZnRhcnJvd1wiLCBcInJpZ2h0YXJyb3dcIl0sIDEuNzUsIDUyMl0sXG4gIHhMZWZ0cmlnaHRhcnJvdzogW1tcImRvdWJsZWxlZnRhcnJvd1wiLCBcImRvdWJsZXJpZ2h0YXJyb3dcIl0sIDEuNzUsIDU2MF0sXG4gIHhyaWdodGxlZnRoYXJwb29uczogW1tcImxlZnRoYXJwb29uZG93bnBsdXNcIiwgXCJyaWdodGhhcnBvb25wbHVzXCJdLCAxLjc1LCA3MTZdLFxuICB4bGVmdHJpZ2h0aGFycG9vbnM6IFtbXCJsZWZ0aGFycG9vbnBsdXNcIiwgXCJyaWdodGhhcnBvb25kb3ducGx1c1wiXSwgMS43NSwgNzE2XSxcbiAgeGhvb2tsZWZ0YXJyb3c6IFtbXCJsZWZ0YXJyb3dcIiwgXCJyaWdodGhvb2tcIl0sIDEuMDgsIDUyMl0sXG4gIHhob29rcmlnaHRhcnJvdzogW1tcImxlZnRob29rXCIsIFwicmlnaHRhcnJvd1wiXSwgMS4wOCwgNTIyXSxcbiAgb3ZlcmxpbmVzZWdtZW50OiBbW1wibGVmdGxpbmVzZWdtZW50XCIsIFwicmlnaHRsaW5lc2VnbWVudFwiXSwgMC44ODgsIDUyMl0sXG4gIHVuZGVybGluZXNlZ21lbnQ6IFtbXCJsZWZ0bGluZXNlZ21lbnRcIiwgXCJyaWdodGxpbmVzZWdtZW50XCJdLCAwLjg4OCwgNTIyXSxcbiAgb3Zlcmdyb3VwOiBbW1wibGVmdGdyb3VwXCIsIFwicmlnaHRncm91cFwiXSwgMC44ODgsIDM0Ml0sXG4gIHVuZGVyZ3JvdXA6IFtbXCJsZWZ0Z3JvdXB1bmRlclwiLCBcInJpZ2h0Z3JvdXB1bmRlclwiXSwgMC44ODgsIDM0Ml0sXG4gIHhtYXBzdG86IFtbXCJsZWZ0bWFwc3RvXCIsIFwicmlnaHRhcnJvd1wiXSwgMS41LCA1MjJdLFxuICB4dG9mcm9tOiBbW1wibGVmdFRvRnJvbVwiLCBcInJpZ2h0VG9Gcm9tXCJdLCAxLjc1LCA1MjhdLFxuICAvLyBUaGUgbmV4dCB0aHJlZSBhcnJvd3MgYXJlIGZyb20gdGhlIG1oY2hlbSBwYWNrYWdlLlxuICAvLyBJbiBtaGNoZW0uc3R5LCBtaW4tbGVuZ3RoIGlzIDIuMGVtLiBCdXQgdGhlc2UgYXJyb3dzIG1pZ2h0IGFwcGVhciBpbiB0aGVcbiAgLy8gZG9jdW1lbnQgYXMgXFx4cmlnaHRhcnJvdyBvciBcXHhyaWdodGxlZnRoYXJwb29ucy4gVGhvc2UgaGF2ZVxuICAvLyBtaW4tbGVuZ3RoID0gMS43NWVtLCBzbyB3ZSBzZXQgbWluLWxlbmd0aCBvbiB0aGVzZSBuZXh0IHRocmVlIHRvIG1hdGNoLlxuICB4cmlnaHRsZWZ0YXJyb3dzOiBbW1wiYmFyYWJvdmVsZWZ0YXJyb3dcIiwgXCJyaWdodGFycm93YWJvdmViYXJcIl0sIDEuNzUsIDkwMV0sXG4gIHhyaWdodGVxdWlsaWJyaXVtOiBbW1wiYmFyYWJvdmVzaG9ydGxlZnRoYXJwb29uXCIsIFwicmlnaHRoYXJwb29uYWJvdmVzaG9ydGJhclwiXSwgMS43NSwgNzE2XSxcbiAgeGxlZnRlcXVpbGlicml1bTogW1tcInNob3J0YmFyYWJvdmVsZWZ0aGFycG9vblwiLCBcInNob3J0cmlnaHRoYXJwb29uYWJvdmViYXJcIl0sIDEuNzUsIDcxNl1cbn07XG5cbnZhciBncm91cExlbmd0aCA9IGZ1bmN0aW9uIGdyb3VwTGVuZ3RoKGFyZykge1xuICBpZiAoYXJnLnR5cGUgPT09IFwib3JkZ3JvdXBcIikge1xuICAgIHJldHVybiBhcmcuYm9keS5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn07XG5cbnZhciBzdHJldGNoeV9zdmdTcGFuID0gZnVuY3Rpb24gc3ZnU3Bhbihncm91cCwgb3B0aW9ucykge1xuICAvLyBDcmVhdGUgYSBzcGFuIHdpdGggaW5saW5lIFNWRyBmb3IgdGhlIGVsZW1lbnQuXG4gIGZ1bmN0aW9uIGJ1aWxkU3ZnU3Bhbl8oKSB7XG4gICAgdmFyIHZpZXdCb3hXaWR0aCA9IDQwMDAwMDsgLy8gZGVmYXVsdFxuXG4gICAgdmFyIGxhYmVsID0gZ3JvdXAubGFiZWwuc3Vic3RyKDEpO1xuXG4gICAgaWYgKHV0aWxzLmNvbnRhaW5zKFtcIndpZGVoYXRcIiwgXCJ3aWRlY2hlY2tcIiwgXCJ3aWRldGlsZGVcIiwgXCJ1dGlsZGVcIl0sIGxhYmVsKSkge1xuICAgICAgLy8gRWFjaCB0eXBlIGluIHRoZSBgaWZgIHN0YXRlbWVudCBjb3JyZXNwb25kcyB0byBvbmUgb2YgdGhlIFBhcnNlTm9kZVxuICAgICAgLy8gdHlwZXMgYmVsb3cuIFRoaXMgbmFycm93aW5nIGlzIHJlcXVpcmVkIHRvIGFjY2VzcyBgZ3JwLmJhc2VgLlxuICAgICAgdmFyIGdycCA9IGdyb3VwOyAvLyBUaGVyZSBhcmUgZm91ciBTVkcgaW1hZ2VzIGF2YWlsYWJsZSBmb3IgZWFjaCBmdW5jdGlvbi5cbiAgICAgIC8vIENob29zZSBhIHRhbGxlciBpbWFnZSB3aGVuIHRoZXJlIGFyZSBtb3JlIGNoYXJhY3RlcnMuXG5cbiAgICAgIHZhciBudW1DaGFycyA9IGdyb3VwTGVuZ3RoKGdycC5iYXNlKTtcbiAgICAgIHZhciB2aWV3Qm94SGVpZ2h0O1xuICAgICAgdmFyIHBhdGhOYW1lO1xuXG4gICAgICB2YXIgX2hlaWdodDtcblxuICAgICAgaWYgKG51bUNoYXJzID4gNSkge1xuICAgICAgICBpZiAobGFiZWwgPT09IFwid2lkZWhhdFwiIHx8IGxhYmVsID09PSBcIndpZGVjaGVja1wiKSB7XG4gICAgICAgICAgdmlld0JveEhlaWdodCA9IDQyMDtcbiAgICAgICAgICB2aWV3Qm94V2lkdGggPSAyMzY0O1xuICAgICAgICAgIF9oZWlnaHQgPSAwLjQyO1xuICAgICAgICAgIHBhdGhOYW1lID0gbGFiZWwgKyBcIjRcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2aWV3Qm94SGVpZ2h0ID0gMzEyO1xuICAgICAgICAgIHZpZXdCb3hXaWR0aCA9IDIzNDA7XG4gICAgICAgICAgX2hlaWdodCA9IDAuMzQ7XG4gICAgICAgICAgcGF0aE5hbWUgPSBcInRpbGRlNFwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaW1nSW5kZXggPSBbMSwgMSwgMiwgMiwgMywgM11bbnVtQ2hhcnNdO1xuXG4gICAgICAgIGlmIChsYWJlbCA9PT0gXCJ3aWRlaGF0XCIgfHwgbGFiZWwgPT09IFwid2lkZWNoZWNrXCIpIHtcbiAgICAgICAgICB2aWV3Qm94V2lkdGggPSBbMCwgMTA2MiwgMjM2NCwgMjM2NCwgMjM2NF1baW1nSW5kZXhdO1xuICAgICAgICAgIHZpZXdCb3hIZWlnaHQgPSBbMCwgMjM5LCAzMDAsIDM2MCwgNDIwXVtpbWdJbmRleF07XG4gICAgICAgICAgX2hlaWdodCA9IFswLCAwLjI0LCAwLjMsIDAuMywgMC4zNiwgMC40Ml1baW1nSW5kZXhdO1xuICAgICAgICAgIHBhdGhOYW1lID0gbGFiZWwgKyBpbWdJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2aWV3Qm94V2lkdGggPSBbMCwgNjAwLCAxMDMzLCAyMzM5LCAyMzQwXVtpbWdJbmRleF07XG4gICAgICAgICAgdmlld0JveEhlaWdodCA9IFswLCAyNjAsIDI4NiwgMzA2LCAzMTJdW2ltZ0luZGV4XTtcbiAgICAgICAgICBfaGVpZ2h0ID0gWzAsIDAuMjYsIDAuMjg2LCAwLjMsIDAuMzA2LCAwLjM0XVtpbWdJbmRleF07XG4gICAgICAgICAgcGF0aE5hbWUgPSBcInRpbGRlXCIgKyBpbWdJbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcGF0aCA9IG5ldyBkb21UcmVlX1BhdGhOb2RlKHBhdGhOYW1lKTtcbiAgICAgIHZhciBzdmdOb2RlID0gbmV3IFN2Z05vZGUoW3BhdGhdLCB7XG4gICAgICAgIFwid2lkdGhcIjogXCIxMDAlXCIsXG4gICAgICAgIFwiaGVpZ2h0XCI6IF9oZWlnaHQgKyBcImVtXCIsXG4gICAgICAgIFwidmlld0JveFwiOiBcIjAgMCBcIiArIHZpZXdCb3hXaWR0aCArIFwiIFwiICsgdmlld0JveEhlaWdodCxcbiAgICAgICAgXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCI6IFwibm9uZVwiXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNwYW46IGJ1aWxkQ29tbW9uLm1ha2VTdmdTcGFuKFtdLCBbc3ZnTm9kZV0sIG9wdGlvbnMpLFxuICAgICAgICBtaW5XaWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiBfaGVpZ2h0XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3BhbnMgPSBbXTtcbiAgICAgIHZhciBkYXRhID0ga2F0ZXhJbWFnZXNEYXRhW2xhYmVsXTtcbiAgICAgIHZhciBwYXRocyA9IGRhdGFbMF0sXG4gICAgICAgICAgX21pbldpZHRoID0gZGF0YVsxXSxcbiAgICAgICAgICBfdmlld0JveEhlaWdodCA9IGRhdGFbMl07XG5cbiAgICAgIHZhciBfaGVpZ2h0MiA9IF92aWV3Qm94SGVpZ2h0IC8gMTAwMDtcblxuICAgICAgdmFyIG51bVN2Z0NoaWxkcmVuID0gcGF0aHMubGVuZ3RoO1xuICAgICAgdmFyIHdpZHRoQ2xhc3NlcztcbiAgICAgIHZhciBhbGlnbnM7XG5cbiAgICAgIGlmIChudW1TdmdDaGlsZHJlbiA9PT0gMSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lOiBBbGwgdGhlc2UgY2FzZXMgbXVzdCBiZSBvZiB0aGUgNC10dXBsZSB0eXBlLlxuICAgICAgICB2YXIgYWxpZ24xID0gZGF0YVszXTtcbiAgICAgICAgd2lkdGhDbGFzc2VzID0gW1wiaGlkZS10YWlsXCJdO1xuICAgICAgICBhbGlnbnMgPSBbYWxpZ24xXTtcbiAgICAgIH0gZWxzZSBpZiAobnVtU3ZnQ2hpbGRyZW4gPT09IDIpIHtcbiAgICAgICAgd2lkdGhDbGFzc2VzID0gW1wiaGFsZmFycm93LWxlZnRcIiwgXCJoYWxmYXJyb3ctcmlnaHRcIl07XG4gICAgICAgIGFsaWducyA9IFtcInhNaW5ZTWluXCIsIFwieE1heFlNaW5cIl07XG4gICAgICB9IGVsc2UgaWYgKG51bVN2Z0NoaWxkcmVuID09PSAzKSB7XG4gICAgICAgIHdpZHRoQ2xhc3NlcyA9IFtcImJyYWNlLWxlZnRcIiwgXCJicmFjZS1jZW50ZXJcIiwgXCJicmFjZS1yaWdodFwiXTtcbiAgICAgICAgYWxpZ25zID0gW1wieE1pbllNaW5cIiwgXCJ4TWlkWU1pblwiLCBcInhNYXhZTWluXCJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycmVjdCBrYXRleEltYWdlc0RhdGEgb3IgdXBkYXRlIGNvZGUgaGVyZSB0byBzdXBwb3J0XFxuICAgICAgICAgICAgICAgICAgICBcIiArIG51bVN2Z0NoaWxkcmVuICsgXCIgY2hpbGRyZW4uXCIpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVN2Z0NoaWxkcmVuOyBpKyspIHtcbiAgICAgICAgdmFyIF9wYXRoID0gbmV3IGRvbVRyZWVfUGF0aE5vZGUocGF0aHNbaV0pO1xuXG4gICAgICAgIHZhciBfc3ZnTm9kZSA9IG5ldyBTdmdOb2RlKFtfcGF0aF0sIHtcbiAgICAgICAgICBcIndpZHRoXCI6IFwiNDAwZW1cIixcbiAgICAgICAgICBcImhlaWdodFwiOiBfaGVpZ2h0MiArIFwiZW1cIixcbiAgICAgICAgICBcInZpZXdCb3hcIjogXCIwIDAgXCIgKyB2aWV3Qm94V2lkdGggKyBcIiBcIiArIF92aWV3Qm94SGVpZ2h0LFxuICAgICAgICAgIFwicHJlc2VydmVBc3BlY3RSYXRpb1wiOiBhbGlnbnNbaV0gKyBcIiBzbGljZVwiXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBfc3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTdmdTcGFuKFt3aWR0aENsYXNzZXNbaV1dLCBbX3N2Z05vZGVdLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAobnVtU3ZnQ2hpbGRyZW4gPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3BhbjogX3NwYW4sXG4gICAgICAgICAgICBtaW5XaWR0aDogX21pbldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBfaGVpZ2h0MlxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3NwYW4uc3R5bGUuaGVpZ2h0ID0gX2hlaWdodDIgKyBcImVtXCI7XG4gICAgICAgICAgc3BhbnMucHVzaChfc3Bhbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3BhbjogYnVpbGRDb21tb24ubWFrZVNwYW4oW1wic3RyZXRjaHlcIl0sIHNwYW5zLCBvcHRpb25zKSxcbiAgICAgICAgbWluV2lkdGg6IF9taW5XaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBfaGVpZ2h0MlxuICAgICAgfTtcbiAgICB9XG4gIH0gLy8gYnVpbGRTdmdTcGFuXygpXG5cblxuICB2YXIgX2J1aWxkU3ZnU3Bhbl8gPSBidWlsZFN2Z1NwYW5fKCksXG4gICAgICBzcGFuID0gX2J1aWxkU3ZnU3Bhbl8uc3BhbixcbiAgICAgIG1pbldpZHRoID0gX2J1aWxkU3ZnU3Bhbl8ubWluV2lkdGgsXG4gICAgICBoZWlnaHQgPSBfYnVpbGRTdmdTcGFuXy5oZWlnaHQ7IC8vIE5vdGUgdGhhdCB3ZSBhcmUgcmV0dXJuaW5nIHNwYW4uZGVwdGggPSAwLlxuICAvLyBBbnkgYWRqdXN0bWVudHMgcmVsYXRpdmUgdG8gdGhlIGJhc2VsaW5lIG11c3QgYmUgZG9uZSBpbiBidWlsZEhUTUwuXG5cblxuICBzcGFuLmhlaWdodCA9IGhlaWdodDtcbiAgc3Bhbi5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcImVtXCI7XG5cbiAgaWYgKG1pbldpZHRoID4gMCkge1xuICAgIHNwYW4uc3R5bGUubWluV2lkdGggPSBtaW5XaWR0aCArIFwiZW1cIjtcbiAgfVxuXG4gIHJldHVybiBzcGFuO1xufTtcblxudmFyIHN0cmV0Y2h5X2VuY2xvc2VTcGFuID0gZnVuY3Rpb24gZW5jbG9zZVNwYW4oaW5uZXIsIGxhYmVsLCBwYWQsIG9wdGlvbnMpIHtcbiAgLy8gUmV0dXJuIGFuIGltYWdlIHNwYW4gZm9yIFxcY2FuY2VsLCBcXGJjYW5jZWwsIFxceGNhbmNlbCwgb3IgXFxmYm94XG4gIHZhciBpbWc7XG4gIHZhciB0b3RhbEhlaWdodCA9IGlubmVyLmhlaWdodCArIGlubmVyLmRlcHRoICsgMiAqIHBhZDtcblxuICBpZiAoL2Zib3h8Y29sb3IvLnRlc3QobGFiZWwpKSB7XG4gICAgaW1nID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wic3RyZXRjaHlcIiwgbGFiZWxdLCBbXSwgb3B0aW9ucyk7XG5cbiAgICBpZiAobGFiZWwgPT09IFwiZmJveFwiKSB7XG4gICAgICB2YXIgY29sb3IgPSBvcHRpb25zLmNvbG9yICYmIG9wdGlvbnMuZ2V0Q29sb3IoKTtcblxuICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgIGltZy5zdHlsZS5ib3JkZXJDb2xvciA9IGNvbG9yO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBcXGNhbmNlbCwgXFxiY2FuY2VsLCBvciBcXHhjYW5jZWxcbiAgICAvLyBTaW5jZSBcXGNhbmNlbCdzIFNWRyBpcyBpbmxpbmUgYW5kIGl0IG9taXRzIHRoZSB2aWV3Qm94IGF0dHJpYnV0ZSxcbiAgICAvLyBpdHMgc3Ryb2tlLXdpZHRoIHdpbGwgbm90IHZhcnkgd2l0aCBzcGFuIGFyZWEuXG4gICAgdmFyIGxpbmVzID0gW107XG5cbiAgICBpZiAoL15bYnhdY2FuY2VsJC8udGVzdChsYWJlbCkpIHtcbiAgICAgIGxpbmVzLnB1c2gobmV3IExpbmVOb2RlKHtcbiAgICAgICAgXCJ4MVwiOiBcIjBcIixcbiAgICAgICAgXCJ5MVwiOiBcIjBcIixcbiAgICAgICAgXCJ4MlwiOiBcIjEwMCVcIixcbiAgICAgICAgXCJ5MlwiOiBcIjEwMCVcIixcbiAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogXCIwLjA0NmVtXCJcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBpZiAoL154P2NhbmNlbCQvLnRlc3QobGFiZWwpKSB7XG4gICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lTm9kZSh7XG4gICAgICAgIFwieDFcIjogXCIwXCIsXG4gICAgICAgIFwieTFcIjogXCIxMDAlXCIsXG4gICAgICAgIFwieDJcIjogXCIxMDAlXCIsXG4gICAgICAgIFwieTJcIjogXCIwXCIsXG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IFwiMC4wNDZlbVwiXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgdmFyIHN2Z05vZGUgPSBuZXcgU3ZnTm9kZShsaW5lcywge1xuICAgICAgXCJ3aWR0aFwiOiBcIjEwMCVcIixcbiAgICAgIFwiaGVpZ2h0XCI6IHRvdGFsSGVpZ2h0ICsgXCJlbVwiXG4gICAgfSk7XG4gICAgaW1nID0gYnVpbGRDb21tb24ubWFrZVN2Z1NwYW4oW10sIFtzdmdOb2RlXSwgb3B0aW9ucyk7XG4gIH1cblxuICBpbWcuaGVpZ2h0ID0gdG90YWxIZWlnaHQ7XG4gIGltZy5zdHlsZS5oZWlnaHQgPSB0b3RhbEhlaWdodCArIFwiZW1cIjtcbiAgcmV0dXJuIGltZztcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHN0cmV0Y2h5ID0gKHtcbiAgZW5jbG9zZVNwYW46IHN0cmV0Y2h5X2VuY2xvc2VTcGFuLFxuICBtYXRoTUxub2RlOiBzdHJldGNoeV9tYXRoTUxub2RlLFxuICBzdmdTcGFuOiBzdHJldGNoeV9zdmdTcGFuXG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9hY2NlbnQuanNcblxuXG5cblxuXG5cblxuXG5cbi8vIE5PVEU6IFVubGlrZSBtb3N0IGBodG1sQnVpbGRlcmBzLCB0aGlzIG9uZSBoYW5kbGVzIG5vdCBvbmx5IFwiYWNjZW50XCIsIGJ1dFxudmFyIGFjY2VudF9odG1sQnVpbGRlciA9IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdycCwgb3B0aW9ucykge1xuICAvLyBBY2NlbnRzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnLiA0NDMsIHJ1bGUgMTIuXG4gIHZhciBiYXNlO1xuICB2YXIgZ3JvdXA7XG4gIHZhciBzdXBTdWIgPSBjaGVja05vZGVUeXBlKGdycCwgXCJzdXBzdWJcIik7XG4gIHZhciBzdXBTdWJHcm91cDtcblxuICBpZiAoc3VwU3ViKSB7XG4gICAgLy8gSWYgb3VyIGJhc2UgaXMgYSBjaGFyYWN0ZXIgYm94LCBhbmQgd2UgaGF2ZSBzdXBlcnNjcmlwdHMgYW5kXG4gICAgLy8gc3Vic2NyaXB0cywgdGhlIHN1cHN1YiB3aWxsIGRlZmVyIHRvIHVzLiBJbiBwYXJ0aWN1bGFyLCB3ZSB3YW50XG4gICAgLy8gdG8gYXR0YWNoIHRoZSBzdXBlcnNjcmlwdHMgYW5kIHN1YnNjcmlwdHMgdG8gdGhlIGlubmVyIGJvZHkgKHNvXG4gICAgLy8gdGhhdCB0aGUgcG9zaXRpb24gb2YgdGhlIHN1cGVyc2NyaXB0cyBhbmQgc3Vic2NyaXB0cyB3b24ndCBiZVxuICAgIC8vIGFmZmVjdGVkIGJ5IHRoZSBoZWlnaHQgb2YgdGhlIGFjY2VudCkuIFdlIGFjY29tcGxpc2ggdGhpcyBieVxuICAgIC8vIHN0aWNraW5nIHRoZSBiYXNlIG9mIHRoZSBhY2NlbnQgaW50byB0aGUgYmFzZSBvZiB0aGUgc3Vwc3ViLCBhbmRcbiAgICAvLyByZW5kZXJpbmcgdGhhdCwgd2hpbGUga2VlcGluZyB0cmFjayBvZiB3aGVyZSB0aGUgYWNjZW50IGlzLlxuICAgIC8vIFRoZSByZWFsIGFjY2VudCBncm91cCBpcyB0aGUgYmFzZSBvZiB0aGUgc3Vwc3ViIGdyb3VwXG4gICAgZ3JvdXAgPSBhc3NlcnROb2RlVHlwZShzdXBTdWIuYmFzZSwgXCJhY2NlbnRcIik7IC8vIFRoZSBjaGFyYWN0ZXIgYm94IGlzIHRoZSBiYXNlIG9mIHRoZSBhY2NlbnQgZ3JvdXBcblxuICAgIGJhc2UgPSBncm91cC5iYXNlOyAvLyBTdGljayB0aGUgY2hhcmFjdGVyIGJveCBpbnRvIHRoZSBiYXNlIG9mIHRoZSBzdXBzdWIgZ3JvdXBcblxuICAgIHN1cFN1Yi5iYXNlID0gYmFzZTsgLy8gUmVyZW5kZXIgdGhlIHN1cHN1YiBncm91cCB3aXRoIGl0cyBuZXcgYmFzZSwgYW5kIHN0b3JlIHRoYXRcbiAgICAvLyByZXN1bHQuXG5cbiAgICBzdXBTdWJHcm91cCA9IGFzc2VydFNwYW4oYnVpbGRIVE1MX2J1aWxkR3JvdXAoc3VwU3ViLCBvcHRpb25zKSk7IC8vIHJlc2V0IG9yaWdpbmFsIGJhc2VcblxuICAgIHN1cFN1Yi5iYXNlID0gZ3JvdXA7XG4gIH0gZWxzZSB7XG4gICAgZ3JvdXAgPSBhc3NlcnROb2RlVHlwZShncnAsIFwiYWNjZW50XCIpO1xuICAgIGJhc2UgPSBncm91cC5iYXNlO1xuICB9IC8vIEJ1aWxkIHRoZSBiYXNlIGdyb3VwXG5cblxuICB2YXIgYm9keSA9IGJ1aWxkSFRNTF9idWlsZEdyb3VwKGJhc2UsIG9wdGlvbnMuaGF2aW5nQ3JhbXBlZFN0eWxlKCkpOyAvLyBEb2VzIHRoZSBhY2NlbnQgbmVlZCB0byBzaGlmdCBmb3IgdGhlIHNrZXcgb2YgYSBjaGFyYWN0ZXI/XG5cbiAgdmFyIG11c3RTaGlmdCA9IGdyb3VwLmlzU2hpZnR5ICYmIHV0aWxzLmlzQ2hhcmFjdGVyQm94KGJhc2UpOyAvLyBDYWxjdWxhdGUgdGhlIHNrZXcgb2YgdGhlIGFjY2VudC4gVGhpcyBpcyBiYXNlZCBvbiB0aGUgbGluZSBcIklmIHRoZVxuICAvLyBudWNsZXVzIGlzIG5vdCBhIHNpbmdsZSBjaGFyYWN0ZXIsIGxldCBzID0gMDsgb3RoZXJ3aXNlIHNldCBzIHRvIHRoZVxuICAvLyBrZXJuIGFtb3VudCBmb3IgdGhlIG51Y2xldXMgZm9sbG93ZWQgYnkgdGhlIFxcc2tld2NoYXIgb2YgaXRzIGZvbnQuXCJcbiAgLy8gTm90ZSB0aGF0IG91ciBza2V3IG1ldHJpY3MgYXJlIGp1c3QgdGhlIGtlcm4gYmV0d2VlbiBlYWNoIGNoYXJhY3RlclxuICAvLyBhbmQgdGhlIHNrZXdjaGFyLlxuXG4gIHZhciBza2V3ID0gMDtcblxuICBpZiAobXVzdFNoaWZ0KSB7XG4gICAgLy8gSWYgdGhlIGJhc2UgaXMgYSBjaGFyYWN0ZXIgYm94LCB0aGVuIHdlIHdhbnQgdGhlIHNrZXcgb2YgdGhlXG4gICAgLy8gaW5uZXJtb3N0IGNoYXJhY3Rlci4gVG8gZG8gdGhhdCwgd2UgZmluZCB0aGUgaW5uZXJtb3N0IGNoYXJhY3RlcjpcbiAgICB2YXIgYmFzZUNoYXIgPSB1dGlscy5nZXRCYXNlRWxlbShiYXNlKTsgLy8gVGhlbiwgd2UgcmVuZGVyIGl0cyBncm91cCB0byBnZXQgdGhlIHN5bWJvbCBpbnNpZGUgaXRcblxuICAgIHZhciBiYXNlR3JvdXAgPSBidWlsZEhUTUxfYnVpbGRHcm91cChiYXNlQ2hhciwgb3B0aW9ucy5oYXZpbmdDcmFtcGVkU3R5bGUoKSk7IC8vIEZpbmFsbHksIHdlIHB1bGwgdGhlIHNrZXcgb2ZmIG9mIHRoZSBzeW1ib2wuXG5cbiAgICBza2V3ID0gYXNzZXJ0U3ltYm9sRG9tTm9kZShiYXNlR3JvdXApLnNrZXc7IC8vIE5vdGUgdGhhdCB3ZSBub3cgdGhyb3cgYXdheSBiYXNlR3JvdXAsIGJlY2F1c2UgdGhlIGxheWVycyB3ZVxuICAgIC8vIHJlbW92ZWQgd2l0aCBnZXRCYXNlRWxlbSBtaWdodCBjb250YWluIHRoaW5ncyBsaWtlIFxcY29sb3Igd2hpY2hcbiAgICAvLyB3ZSBjYW4ndCBnZXQgcmlkIG9mLlxuICAgIC8vIFRPRE8oZW1pbHkpOiBGaW5kIGEgYmV0dGVyIHdheSB0byBnZXQgdGhlIHNrZXdcbiAgfSAvLyBjYWxjdWxhdGUgdGhlIGFtb3VudCBvZiBzcGFjZSBiZXR3ZWVuIHRoZSBib2R5IGFuZCB0aGUgYWNjZW50XG5cblxuICB2YXIgY2xlYXJhbmNlID0gTWF0aC5taW4oYm9keS5oZWlnaHQsIG9wdGlvbnMuZm9udE1ldHJpY3MoKS54SGVpZ2h0KTsgLy8gQnVpbGQgdGhlIGFjY2VudFxuXG4gIHZhciBhY2NlbnRCb2R5O1xuXG4gIGlmICghZ3JvdXAuaXNTdHJldGNoeSkge1xuICAgIHZhciBhY2NlbnQ7XG4gICAgdmFyIHdpZHRoO1xuXG4gICAgaWYgKGdyb3VwLmxhYmVsID09PSBcIlxcXFx2ZWNcIikge1xuICAgICAgLy8gQmVmb3JlIHZlcnNpb24gMC45LCBcXHZlYyB1c2VkIHRoZSBjb21iaW5pbmcgZm9udCBnbHlwaCBVKzIwRDcuXG4gICAgICAvLyBCdXQgYnJvd3NlcnMsIGVzcGVjaWFsbHkgU2FmYXJpLCBhcmUgbm90IGNvbnNpc3RlbnQgaW4gaG93IHRoZXlcbiAgICAgIC8vIHJlbmRlciBjb21iaW5pbmcgY2hhcmFjdGVycyB3aGVuIG5vdCBwcmVjZWRlZCBieSBhIGNoYXJhY3Rlci5cbiAgICAgIC8vIFNvIG5vdyB3ZSB1c2UgYW4gU1ZHLlxuICAgICAgLy8gSWYgU2FmYXJpIHJlZm9ybXMsIHdlIHNob3VsZCBjb25zaWRlciByZXZlcnRpbmcgdG8gdGhlIGdseXBoLlxuICAgICAgYWNjZW50ID0gYnVpbGRDb21tb24uc3RhdGljU3ZnKFwidmVjXCIsIG9wdGlvbnMpO1xuICAgICAgd2lkdGggPSBidWlsZENvbW1vbi5zdmdEYXRhLnZlY1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWNjZW50ID0gYnVpbGRDb21tb24ubWFrZU9yZCh7XG4gICAgICAgIG1vZGU6IGdyb3VwLm1vZGUsXG4gICAgICAgIHRleHQ6IGdyb3VwLmxhYmVsXG4gICAgICB9LCBvcHRpb25zLCBcInRleHRvcmRcIik7XG4gICAgICBhY2NlbnQgPSBhc3NlcnRTeW1ib2xEb21Ob2RlKGFjY2VudCk7IC8vIFJlbW92ZSB0aGUgaXRhbGljIGNvcnJlY3Rpb24gb2YgdGhlIGFjY2VudCwgYmVjYXVzZSBpdCBvbmx5IHNlcnZlcyB0b1xuICAgICAgLy8gc2hpZnQgdGhlIGFjY2VudCBvdmVyIHRvIGEgcGxhY2Ugd2UgZG9uJ3Qgd2FudC5cblxuICAgICAgYWNjZW50Lml0YWxpYyA9IDA7XG4gICAgICB3aWR0aCA9IGFjY2VudC53aWR0aDtcbiAgICB9XG5cbiAgICBhY2NlbnRCb2R5ID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiYWNjZW50LWJvZHlcIl0sIFthY2NlbnRdKTsgLy8gXCJGdWxsXCIgYWNjZW50cyBleHBhbmQgdGhlIHdpZHRoIG9mIHRoZSByZXN1bHRpbmcgc3ltYm9sIHRvIGJlXG4gICAgLy8gYXQgbGVhc3QgdGhlIHdpZHRoIG9mIHRoZSBhY2NlbnQsIGFuZCBvdmVybGFwIGRpcmVjdGx5IG9udG8gdGhlXG4gICAgLy8gY2hhcmFjdGVyIHdpdGhvdXQgYW55IHZlcnRpY2FsIG9mZnNldC5cblxuICAgIHZhciBhY2NlbnRGdWxsID0gZ3JvdXAubGFiZWwgPT09IFwiXFxcXHRleHRjaXJjbGVkXCI7XG5cbiAgICBpZiAoYWNjZW50RnVsbCkge1xuICAgICAgYWNjZW50Qm9keS5jbGFzc2VzLnB1c2goJ2FjY2VudC1mdWxsJyk7XG4gICAgICBjbGVhcmFuY2UgPSBib2R5LmhlaWdodDtcbiAgICB9IC8vIFNoaWZ0IHRoZSBhY2NlbnQgb3ZlciBieSB0aGUgc2tldy5cblxuXG4gICAgdmFyIGxlZnQgPSBza2V3OyAvLyBDU1MgZGVmaW5lcyBgLmthdGV4IC5hY2NlbnQgLmFjY2VudC1ib2R5Om5vdCguYWNjZW50LWZ1bGwpIHsgd2lkdGg6IDAgfWBcbiAgICAvLyBzbyB0aGF0IHRoZSBhY2NlbnQgZG9lc24ndCBjb250cmlidXRlIHRvIHRoZSBib3VuZGluZyBib3guXG4gICAgLy8gV2UgbmVlZCB0byBzaGlmdCB0aGUgY2hhcmFjdGVyIGJ5IGl0cyB3aWR0aCAoZWZmZWN0aXZlbHkgaGFsZlxuICAgIC8vIGl0cyB3aWR0aCkgdG8gY29tcGVuc2F0ZS5cblxuICAgIGlmICghYWNjZW50RnVsbCkge1xuICAgICAgbGVmdCAtPSB3aWR0aCAvIDI7XG4gICAgfVxuXG4gICAgYWNjZW50Qm9keS5zdHlsZS5sZWZ0ID0gbGVmdCArIFwiZW1cIjsgLy8gXFx0ZXh0Y2lyY2xlZCB1c2VzIHRoZSBcXGJpZ2NpcmMgZ2x5cGgsIHNvIGl0IG5lZWRzIHNvbWVcbiAgICAvLyB2ZXJ0aWNhbCBhZGp1c3RtZW50IHRvIG1hdGNoIExhVGVYLlxuXG4gICAgaWYgKGdyb3VwLmxhYmVsID09PSBcIlxcXFx0ZXh0Y2lyY2xlZFwiKSB7XG4gICAgICBhY2NlbnRCb2R5LnN0eWxlLnRvcCA9IFwiLjJlbVwiO1xuICAgIH1cblxuICAgIGFjY2VudEJvZHkgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImZpcnN0QmFzZWxpbmVcIixcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYm9keVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogLWNsZWFyYW5jZVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYWNjZW50Qm9keVxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBhY2NlbnRCb2R5ID0gc3RyZXRjaHkuc3ZnU3Bhbihncm91cCwgb3B0aW9ucyk7XG4gICAgYWNjZW50Qm9keSA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiZmlyc3RCYXNlbGluZVwiLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBib2R5XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBhY2NlbnRCb2R5LFxuICAgICAgICB3cmFwcGVyQ2xhc3NlczogW1wic3ZnLWFsaWduXCJdLFxuICAgICAgICB3cmFwcGVyU3R5bGU6IHNrZXcgPiAwID8ge1xuICAgICAgICAgIHdpZHRoOiBcImNhbGMoMTAwJSAtIFwiICsgMiAqIHNrZXcgKyBcImVtKVwiLFxuICAgICAgICAgIG1hcmdpbkxlZnQ6IDIgKiBza2V3ICsgXCJlbVwiXG4gICAgICAgIH0gOiB1bmRlZmluZWRcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgYWNjZW50V3JhcCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJhY2NlbnRcIl0sIFthY2NlbnRCb2R5XSwgb3B0aW9ucyk7XG5cbiAgaWYgKHN1cFN1Ykdyb3VwKSB7XG4gICAgLy8gSGVyZSwgd2UgcmVwbGFjZSB0aGUgXCJiYXNlXCIgY2hpbGQgb2YgdGhlIHN1cHN1YiB3aXRoIG91ciBuZXdseVxuICAgIC8vIGdlbmVyYXRlZCBhY2NlbnQuXG4gICAgc3VwU3ViR3JvdXAuY2hpbGRyZW5bMF0gPSBhY2NlbnRXcmFwOyAvLyBTaW5jZSB3ZSBkb24ndCByZXJ1biB0aGUgaGVpZ2h0IGNhbGN1bGF0aW9uIGFmdGVyIHJlcGxhY2luZyB0aGVcbiAgICAvLyBhY2NlbnQsIHdlIG1hbnVhbGx5IHJlY2FsY3VsYXRlIGhlaWdodC5cblxuICAgIHN1cFN1Ykdyb3VwLmhlaWdodCA9IE1hdGgubWF4KGFjY2VudFdyYXAuaGVpZ2h0LCBzdXBTdWJHcm91cC5oZWlnaHQpOyAvLyBBY2NlbnRzIHNob3VsZCBhbHdheXMgYmUgb3JkcywgZXZlbiB3aGVuIHRoZWlyIGlubmFyZHMgYXJlIG5vdC5cblxuICAgIHN1cFN1Ykdyb3VwLmNsYXNzZXNbMF0gPSBcIm1vcmRcIjtcbiAgICByZXR1cm4gc3VwU3ViR3JvdXA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFjY2VudFdyYXA7XG4gIH1cbn07XG5cbnZhciBhY2NlbnRfbWF0aG1sQnVpbGRlciA9IGZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgdmFyIGFjY2VudE5vZGUgPSBncm91cC5pc1N0cmV0Y2h5ID8gc3RyZXRjaHkubWF0aE1Mbm9kZShncm91cC5sYWJlbCkgOiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFtidWlsZE1hdGhNTF9tYWtlVGV4dChncm91cC5sYWJlbCwgZ3JvdXAubW9kZSldKTtcbiAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vdmVyXCIsIFtidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLmJhc2UsIG9wdGlvbnMpLCBhY2NlbnROb2RlXSk7XG4gIG5vZGUuc2V0QXR0cmlidXRlKFwiYWNjZW50XCIsIFwidHJ1ZVwiKTtcbiAgcmV0dXJuIG5vZGU7XG59O1xuXG52YXIgTk9OX1NUUkVUQ0hZX0FDQ0VOVF9SRUdFWCA9IG5ldyBSZWdFeHAoW1wiXFxcXGFjdXRlXCIsIFwiXFxcXGdyYXZlXCIsIFwiXFxcXGRkb3RcIiwgXCJcXFxcdGlsZGVcIiwgXCJcXFxcYmFyXCIsIFwiXFxcXGJyZXZlXCIsIFwiXFxcXGNoZWNrXCIsIFwiXFxcXGhhdFwiLCBcIlxcXFx2ZWNcIiwgXCJcXFxcZG90XCIsIFwiXFxcXG1hdGhyaW5nXCJdLm1hcChmdW5jdGlvbiAoYWNjZW50KSB7XG4gIHJldHVybiBcIlxcXFxcIiArIGFjY2VudDtcbn0pLmpvaW4oXCJ8XCIpKTsgLy8gQWNjZW50c1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiYWNjZW50XCIsXG4gIG5hbWVzOiBbXCJcXFxcYWN1dGVcIiwgXCJcXFxcZ3JhdmVcIiwgXCJcXFxcZGRvdFwiLCBcIlxcXFx0aWxkZVwiLCBcIlxcXFxiYXJcIiwgXCJcXFxcYnJldmVcIiwgXCJcXFxcY2hlY2tcIiwgXCJcXFxcaGF0XCIsIFwiXFxcXHZlY1wiLCBcIlxcXFxkb3RcIiwgXCJcXFxcbWF0aHJpbmdcIiwgXCJcXFxcd2lkZWNoZWNrXCIsIFwiXFxcXHdpZGVoYXRcIiwgXCJcXFxcd2lkZXRpbGRlXCIsIFwiXFxcXG92ZXJyaWdodGFycm93XCIsIFwiXFxcXG92ZXJsZWZ0YXJyb3dcIiwgXCJcXFxcT3ZlcnJpZ2h0YXJyb3dcIiwgXCJcXFxcb3ZlcmxlZnRyaWdodGFycm93XCIsIFwiXFxcXG92ZXJncm91cFwiLCBcIlxcXFxvdmVybGluZXNlZ21lbnRcIiwgXCJcXFxcb3ZlcmxlZnRoYXJwb29uXCIsIFwiXFxcXG92ZXJyaWdodGhhcnBvb25cIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgYmFzZSA9IGFyZ3NbMF07XG4gICAgdmFyIGlzU3RyZXRjaHkgPSAhTk9OX1NUUkVUQ0hZX0FDQ0VOVF9SRUdFWC50ZXN0KGNvbnRleHQuZnVuY05hbWUpO1xuICAgIHZhciBpc1NoaWZ0eSA9ICFpc1N0cmV0Y2h5IHx8IGNvbnRleHQuZnVuY05hbWUgPT09IFwiXFxcXHdpZGVoYXRcIiB8fCBjb250ZXh0LmZ1bmNOYW1lID09PSBcIlxcXFx3aWRldGlsZGVcIiB8fCBjb250ZXh0LmZ1bmNOYW1lID09PSBcIlxcXFx3aWRlY2hlY2tcIjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhY2NlbnRcIixcbiAgICAgIG1vZGU6IGNvbnRleHQucGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogY29udGV4dC5mdW5jTmFtZSxcbiAgICAgIGlzU3RyZXRjaHk6IGlzU3RyZXRjaHksXG4gICAgICBpc1NoaWZ0eTogaXNTaGlmdHksXG4gICAgICBiYXNlOiBiYXNlXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGFjY2VudF9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogYWNjZW50X21hdGhtbEJ1aWxkZXJcbn0pOyAvLyBUZXh0LW1vZGUgYWNjZW50c1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiYWNjZW50XCIsXG4gIG5hbWVzOiBbXCJcXFxcJ1wiLCBcIlxcXFxgXCIsIFwiXFxcXF5cIiwgXCJcXFxcflwiLCBcIlxcXFw9XCIsIFwiXFxcXHVcIiwgXCJcXFxcLlwiLCAnXFxcXFwiJywgXCJcXFxcclwiLCBcIlxcXFxIXCIsIFwiXFxcXHZcIiwgXCJcXFxcdGV4dGNpcmNsZWRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFsbG93ZWRJbk1hdGg6IGZhbHNlXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoY29udGV4dCwgYXJncykge1xuICAgIHZhciBiYXNlID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhY2NlbnRcIixcbiAgICAgIG1vZGU6IGNvbnRleHQucGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogY29udGV4dC5mdW5jTmFtZSxcbiAgICAgIGlzU3RyZXRjaHk6IGZhbHNlLFxuICAgICAgaXNTaGlmdHk6IHRydWUsXG4gICAgICBiYXNlOiBiYXNlXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGFjY2VudF9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogYWNjZW50X21hdGhtbEJ1aWxkZXJcbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2FjY2VudHVuZGVyLmpzXG4vLyBIb3Jpem9udGFsIG92ZXJsYXAgZnVuY3Rpb25zXG5cblxuXG5cblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiYWNjZW50VW5kZXJcIixcbiAgbmFtZXM6IFtcIlxcXFx1bmRlcmxlZnRhcnJvd1wiLCBcIlxcXFx1bmRlcnJpZ2h0YXJyb3dcIiwgXCJcXFxcdW5kZXJsZWZ0cmlnaHRhcnJvd1wiLCBcIlxcXFx1bmRlcmdyb3VwXCIsIFwiXFxcXHVuZGVybGluZXNlZ21lbnRcIiwgXCJcXFxcdXRpbGRlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYucGFyc2VyLFxuICAgICAgICBmdW5jTmFtZSA9IF9yZWYuZnVuY05hbWU7XG4gICAgdmFyIGJhc2UgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFjY2VudFVuZGVyXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBmdW5jTmFtZSxcbiAgICAgIGJhc2U6IGJhc2VcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBUcmVhdCB1bmRlciBhY2NlbnRzIG11Y2ggbGlrZSB1bmRlcmxpbmVzLlxuICAgIHZhciBpbm5lckdyb3VwID0gYnVpbGRIVE1MX2J1aWxkR3JvdXAoZ3JvdXAuYmFzZSwgb3B0aW9ucyk7XG4gICAgdmFyIGFjY2VudEJvZHkgPSBzdHJldGNoeS5zdmdTcGFuKGdyb3VwLCBvcHRpb25zKTtcbiAgICB2YXIga2VybiA9IGdyb3VwLmxhYmVsID09PSBcIlxcXFx1dGlsZGVcIiA/IDAuMTIgOiAwOyAvLyBHZW5lcmF0ZSB0aGUgdmxpc3QsIHdpdGggdGhlIGFwcHJvcHJpYXRlIGtlcm5zXG5cbiAgICB2YXIgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImJvdHRvbVwiLFxuICAgICAgcG9zaXRpb25EYXRhOiBhY2NlbnRCb2R5LmhlaWdodCArIGtlcm4sXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGFjY2VudEJvZHksXG4gICAgICAgIHdyYXBwZXJDbGFzc2VzOiBbXCJzdmctYWxpZ25cIl1cbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IGtlcm5cbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGlubmVyR3JvdXBcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJhY2NlbnR1bmRlclwiXSwgW3ZsaXN0XSwgb3B0aW9ucyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IGZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgYWNjZW50Tm9kZSA9IHN0cmV0Y2h5Lm1hdGhNTG5vZGUoZ3JvdXAubGFiZWwpO1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdW5kZXJcIiwgW2J1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZ3JvdXAuYmFzZSwgb3B0aW9ucyksIGFjY2VudE5vZGVdKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImFjY2VudHVuZGVyXCIsIFwidHJ1ZVwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvYXJyb3cuanNcblxuXG5cblxuXG5cblxuLy8gSGVscGVyIGZ1bmN0aW9uXG52YXIgYXJyb3dfcGFkZGVkTm9kZSA9IGZ1bmN0aW9uIHBhZGRlZE5vZGUoZ3JvdXApIHtcbiAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgZ3JvdXAgPyBbZ3JvdXBdIDogW10pO1xuICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiKzAuNmVtXCIpO1xuICBub2RlLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBcIjAuM2VtXCIpO1xuICByZXR1cm4gbm9kZTtcbn07IC8vIFN0cmV0Y2h5IGFycm93cyB3aXRoIGFuIG9wdGlvbmFsIGFyZ3VtZW50XG5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInhBcnJvd1wiLFxuICBuYW1lczogW1wiXFxcXHhsZWZ0YXJyb3dcIiwgXCJcXFxceHJpZ2h0YXJyb3dcIiwgXCJcXFxceExlZnRhcnJvd1wiLCBcIlxcXFx4UmlnaHRhcnJvd1wiLCBcIlxcXFx4bGVmdHJpZ2h0YXJyb3dcIiwgXCJcXFxceExlZnRyaWdodGFycm93XCIsIFwiXFxcXHhob29rbGVmdGFycm93XCIsIFwiXFxcXHhob29rcmlnaHRhcnJvd1wiLCBcIlxcXFx4bWFwc3RvXCIsIFwiXFxcXHhyaWdodGhhcnBvb25kb3duXCIsIFwiXFxcXHhyaWdodGhhcnBvb251cFwiLCBcIlxcXFx4bGVmdGhhcnBvb25kb3duXCIsIFwiXFxcXHhsZWZ0aGFycG9vbnVwXCIsIFwiXFxcXHhyaWdodGxlZnRoYXJwb29uc1wiLCBcIlxcXFx4bGVmdHJpZ2h0aGFycG9vbnNcIiwgXCJcXFxceGxvbmdlcXVhbFwiLCBcIlxcXFx4dHdvaGVhZHJpZ2h0YXJyb3dcIiwgXCJcXFxceHR3b2hlYWRsZWZ0YXJyb3dcIiwgXCJcXFxceHRvZnJvbVwiLCAvLyBUaGUgbmV4dCAzIGZ1bmN0aW9ucyBhcmUgaGVyZSB0byBzdXBwb3J0IHRoZSBtaGNoZW0gZXh0ZW5zaW9uLlxuICAvLyBEaXJlY3QgdXNlIG9mIHRoZXNlIGZ1bmN0aW9ucyBpcyBkaXNjb3VyYWdlZCBhbmQgbWF5IGJyZWFrIHNvbWVkYXkuXG4gIFwiXFxcXHhyaWdodGxlZnRhcnJvd3NcIiwgXCJcXFxceHJpZ2h0ZXF1aWxpYnJpdW1cIiwgXCJcXFxceGxlZnRlcXVpbGlicml1bVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIG51bU9wdGlvbmFsQXJnczogMVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYsIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZi5wYXJzZXIsXG4gICAgICAgIGZ1bmNOYW1lID0gX3JlZi5mdW5jTmFtZTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ4QXJyb3dcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgYm9keTogYXJnc1swXSxcbiAgICAgIGJlbG93OiBvcHRBcmdzWzBdXG4gICAgfTtcbiAgfSxcbiAgLy8gRmxvdyBpcyB1bmFibGUgdG8gY29ycmVjdGx5IGluZmVyIHRoZSB0eXBlIG9mIGBncm91cGAsIGV2ZW4gdGhvdWdoIGl0J3NcbiAgLy8gdW5hbWliaWd1b3VzbHkgZGV0ZXJtaW5lZCBmcm9tIHRoZSBwYXNzZWQtaW4gYHR5cGVgIGFib3ZlLlxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlOyAvLyBCdWlsZCB0aGUgYXJndW1lbnQgZ3JvdXBzIGluIHRoZSBhcHByb3ByaWF0ZSBzdHlsZS5cbiAgICAvLyBSZWY6IGFtc21hdGguZHR4OiAgIFxcaGJveHskXFxzY3JpcHRzdHlsZVxcbWtlcm4jM211eyM2fVxcbWtlcm4jNG11JH0lXG4gICAgLy8gU29tZSBncm91cHMgY2FuIHJldHVybiBkb2N1bWVudCBmcmFnbWVudHMuICBIYW5kbGUgdGhvc2UgYnkgd3JhcHBpbmdcbiAgICAvLyB0aGVtIGluIGEgc3Bhbi5cblxuICAgIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShzdHlsZS5zdXAoKSk7XG4gICAgdmFyIHVwcGVyR3JvdXAgPSBidWlsZENvbW1vbi53cmFwRnJhZ21lbnQoYnVpbGRIVE1MX2J1aWxkR3JvdXAoZ3JvdXAuYm9keSwgbmV3T3B0aW9ucywgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIHVwcGVyR3JvdXAuY2xhc3Nlcy5wdXNoKFwieC1hcnJvdy1wYWRcIik7XG4gICAgdmFyIGxvd2VyR3JvdXA7XG5cbiAgICBpZiAoZ3JvdXAuYmVsb3cpIHtcbiAgICAgIC8vIEJ1aWxkIHRoZSBsb3dlciBncm91cFxuICAgICAgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUuc3ViKCkpO1xuICAgICAgbG93ZXJHcm91cCA9IGJ1aWxkQ29tbW9uLndyYXBGcmFnbWVudChidWlsZEhUTUxfYnVpbGRHcm91cChncm91cC5iZWxvdywgbmV3T3B0aW9ucywgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgbG93ZXJHcm91cC5jbGFzc2VzLnB1c2goXCJ4LWFycm93LXBhZFwiKTtcbiAgICB9XG5cbiAgICB2YXIgYXJyb3dCb2R5ID0gc3RyZXRjaHkuc3ZnU3Bhbihncm91cCwgb3B0aW9ucyk7IC8vIFJlIHNoaWZ0OiBOb3RlIHRoYXQgc3RyZXRjaHkuc3ZnU3BhbiByZXR1cm5lZCBhcnJvd0JvZHkuZGVwdGggPSAwLlxuICAgIC8vIFRoZSBwb2ludCB3ZSB3YW50IG9uIHRoZSBtYXRoIGF4aXMgaXMgYXQgMC41ICogYXJyb3dCb2R5LmhlaWdodC5cblxuICAgIHZhciBhcnJvd1NoaWZ0ID0gLW9wdGlvbnMuZm9udE1ldHJpY3MoKS5heGlzSGVpZ2h0ICsgMC41ICogYXJyb3dCb2R5LmhlaWdodDsgLy8gMiBtdSBrZXJuLiBSZWY6IGFtc21hdGguZHR4OiAjN1xcaWYwIzJcXGVsc2VcXG1rZXJuIzJtdVxcZmlcblxuICAgIHZhciB1cHBlclNoaWZ0ID0gLW9wdGlvbnMuZm9udE1ldHJpY3MoKS5heGlzSGVpZ2h0IC0gMC41ICogYXJyb3dCb2R5LmhlaWdodCAtIDAuMTExOyAvLyAwLjExMSBlbSA9IDIgbXVcblxuICAgIGlmICh1cHBlckdyb3VwLmRlcHRoID4gMC4yNSB8fCBncm91cC5sYWJlbCA9PT0gXCJcXFxceGxlZnRlcXVpbGlicml1bVwiKSB7XG4gICAgICB1cHBlclNoaWZ0IC09IHVwcGVyR3JvdXAuZGVwdGg7IC8vIHNoaWZ0IHVwIGlmIGRlcHRoIGVuY3JvYWNoZXNcbiAgICB9IC8vIEdlbmVyYXRlIHRoZSB2bGlzdFxuXG5cbiAgICB2YXIgdmxpc3Q7XG5cbiAgICBpZiAobG93ZXJHcm91cCkge1xuICAgICAgdmFyIGxvd2VyU2hpZnQgPSAtb3B0aW9ucy5mb250TWV0cmljcygpLmF4aXNIZWlnaHQgKyBsb3dlckdyb3VwLmhlaWdodCArIDAuNSAqIGFycm93Qm9keS5oZWlnaHQgKyAwLjExMTtcbiAgICAgIHZsaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiB1cHBlckdyb3VwLFxuICAgICAgICAgIHNoaWZ0OiB1cHBlclNoaWZ0XG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiBhcnJvd0JvZHksXG4gICAgICAgICAgc2hpZnQ6IGFycm93U2hpZnRcbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IGxvd2VyR3JvdXAsXG4gICAgICAgICAgc2hpZnQ6IGxvd2VyU2hpZnRcbiAgICAgICAgfV1cbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICAgIHBvc2l0aW9uVHlwZTogXCJpbmRpdmlkdWFsU2hpZnRcIixcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogdXBwZXJHcm91cCxcbiAgICAgICAgICBzaGlmdDogdXBwZXJTaGlmdFxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogYXJyb3dCb2R5LFxuICAgICAgICAgIHNoaWZ0OiBhcnJvd1NoaWZ0XG4gICAgICAgIH1dXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9IC8vICRGbG93Rml4TWU6IFJlcGxhY2UgdGhpcyB3aXRoIHBhc3NpbmcgXCJzdmctYWxpZ25cIiBpbnRvIG1ha2VWTGlzdC5cblxuXG4gICAgdmxpc3QuY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uY2hpbGRyZW5bMV0uY2xhc3Nlcy5wdXNoKFwic3ZnLWFsaWduXCIpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtcmVsXCIsIFwieC1hcnJvd1wiXSwgW3ZsaXN0XSwgb3B0aW9ucyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IGZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgYXJyb3dOb2RlID0gc3RyZXRjaHkubWF0aE1Mbm9kZShncm91cC5sYWJlbCk7XG4gICAgdmFyIG5vZGU7XG5cbiAgICBpZiAoZ3JvdXAuYm9keSkge1xuICAgICAgdmFyIHVwcGVyTm9kZSA9IGFycm93X3BhZGRlZE5vZGUoYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKSk7XG5cbiAgICAgIGlmIChncm91cC5iZWxvdykge1xuICAgICAgICB2YXIgbG93ZXJOb2RlID0gYXJyb3dfcGFkZGVkTm9kZShidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLmJlbG93LCBvcHRpb25zKSk7XG4gICAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm11bmRlcm92ZXJcIiwgW2Fycm93Tm9kZSwgbG93ZXJOb2RlLCB1cHBlck5vZGVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vdmVyXCIsIFthcnJvd05vZGUsIHVwcGVyTm9kZV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3JvdXAuYmVsb3cpIHtcbiAgICAgIHZhciBfbG93ZXJOb2RlID0gYXJyb3dfcGFkZGVkTm9kZShidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLmJlbG93LCBvcHRpb25zKSk7XG5cbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm11bmRlclwiLCBbYXJyb3dOb2RlLCBfbG93ZXJOb2RlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgICAgIC8vIFBhcnNlci5qcyB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgaXMgbm8gYXJndW1lbnQuXG4gICAgICBub2RlID0gYXJyb3dfcGFkZGVkTm9kZSgpO1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW92ZXJcIiwgW2Fycm93Tm9kZSwgbm9kZV0pO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9jaGFyLmpzXG5cblxuIC8vIFxcQGNoYXIgaXMgYW4gaW50ZXJuYWwgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGdyb3VwZWQgZGVjaW1hbCBhcmd1bWVudCBsaWtlXG4vLyB7MTIzfSBhbmQgY29udmVydHMgaW50byBzeW1ib2wgd2l0aCBjb2RlIDEyMy4gIEl0IGlzIHVzZWQgYnkgdGhlICptYWNybypcbi8vIFxcY2hhciBkZWZpbmVkIGluIG1hY3Jvcy5qcy5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInRleHRvcmRcIixcbiAgbmFtZXM6IFtcIlxcXFxAY2hhclwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYucGFyc2VyO1xuICAgIHZhciBhcmcgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcIm9yZGdyb3VwXCIpO1xuICAgIHZhciBncm91cCA9IGFyZy5ib2R5O1xuICAgIHZhciBudW1iZXIgPSBcIlwiO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBhc3NlcnROb2RlVHlwZShncm91cFtpXSwgXCJ0ZXh0b3JkXCIpO1xuICAgICAgbnVtYmVyICs9IG5vZGUudGV4dDtcbiAgICB9XG5cbiAgICB2YXIgY29kZSA9IHBhcnNlSW50KG51bWJlcik7XG5cbiAgICBpZiAoaXNOYU4oY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlxcXFxAY2hhciBoYXMgbm9uLW51bWVyaWMgYXJndW1lbnQgXCIgKyBudW1iZXIpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgdGV4dDogU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKVxuICAgIH07XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2NvbG9yLmpzXG5cblxuXG5cblxuXG5cbnZhciBjb2xvcl9odG1sQnVpbGRlciA9IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gIHZhciBlbGVtZW50cyA9IGJ1aWxkSFRNTF9idWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucy53aXRoQ29sb3IoZ3JvdXAuY29sb3IpLCBmYWxzZSk7IC8vIFxcY29sb3IgaXNuJ3Qgc3VwcG9zZWQgdG8gYWZmZWN0IHRoZSB0eXBlIG9mIHRoZSBlbGVtZW50cyBpdCBjb250YWlucy5cbiAgLy8gVG8gYWNjb21wbGlzaCB0aGlzLCB3ZSB3cmFwIHRoZSByZXN1bHRzIGluIGEgZnJhZ21lbnQsIHNvIHRoZSBpbm5lclxuICAvLyBlbGVtZW50cyB3aWxsIGJlIGFibGUgdG8gZGlyZWN0bHkgaW50ZXJhY3Qgd2l0aCB0aGVpciBuZWlnaGJvcnMuIEZvclxuICAvLyBleGFtcGxlLCBgXFxjb2xvcntyZWR9ezIgK30gM2AgaGFzIHRoZSBzYW1lIHNwYWNpbmcgYXMgYDIgKyAzYFxuXG4gIHJldHVybiBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoZWxlbWVudHMpO1xufTtcblxudmFyIGNvbG9yX21hdGhtbEJ1aWxkZXIgPSBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gIHZhciBpbm5lciA9IGJ1aWxkTWF0aE1MX2J1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBvcHRpb25zLndpdGhDb2xvcihncm91cC5jb2xvcikpO1xuICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXN0eWxlXCIsIGlubmVyKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRoY29sb3JcIiwgZ3JvdXAuY29sb3IpO1xuICByZXR1cm4gbm9kZTtcbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJjb2xvclwiLFxuICBuYW1lczogW1wiXFxcXHRleHRjb2xvclwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgZ3JlZWRpbmVzczogMyxcbiAgICBhcmdUeXBlczogW1wiY29sb3JcIiwgXCJvcmlnaW5hbFwiXVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZi5wYXJzZXI7XG4gICAgdmFyIGNvbG9yID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJjb2xvci10b2tlblwiKS5jb2xvcjtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgYm9keTogZGVmaW5lRnVuY3Rpb25fb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogY29sb3JfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGNvbG9yX21hdGhtbEJ1aWxkZXJcbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImNvbG9yXCIsXG4gIG5hbWVzOiBbXCJcXFxcY29sb3JcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGdyZWVkaW5lc3M6IDMsXG4gICAgYXJnVHlwZXM6IFtcImNvbG9yXCJdXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZjIsIGFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZjIucGFyc2VyLFxuICAgICAgICBicmVha09uVG9rZW5UZXh0ID0gX3JlZjIuYnJlYWtPblRva2VuVGV4dDtcbiAgICB2YXIgY29sb3IgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcImNvbG9yLXRva2VuXCIpLmNvbG9yOyAvLyBTZXQgbWFjcm8gXFxjdXJyZW50QGNvbG9yIGluIGN1cnJlbnQgbmFtZXNwYWNlIHRvIHN0b3JlIHRoZSBjdXJyZW50XG4gICAgLy8gY29sb3IsIG1pbWlja2luZyB0aGUgYmVoYXZpb3Igb2YgY29sb3Iuc3R5LlxuICAgIC8vIFRoaXMgaXMgY3VycmVudGx5IHVzZWQganVzdCB0byBjb3JyZWN0bHkgY29sb3IgYSBcXHJpZ2h0XG4gICAgLy8gdGhhdCBmb2xsb3dzIGEgXFxjb2xvciBjb21tYW5kLlxuXG4gICAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KFwiXFxcXGN1cnJlbnRAY29sb3JcIiwgY29sb3IpOyAvLyBQYXJzZSBvdXQgdGhlIGltcGxpY2l0IGJvZHkgdGhhdCBzaG91bGQgYmUgY29sb3JlZC5cblxuICAgIHZhciBib2R5ID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbih0cnVlLCBicmVha09uVG9rZW5UZXh0KTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBjb2xvcjogY29sb3IsXG4gICAgICBib2R5OiBib2R5XG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGNvbG9yX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBjb2xvcl9tYXRobWxCdWlsZGVyXG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9jci5qc1xuLy8gUm93IGJyZWFrcyB3aXRoaW4gdGFidWxhciBlbnZpcm9ubWVudHMsIGFuZCBsaW5lIGJyZWFrcyBhdCB0b3AgbGV2ZWxcblxuXG5cblxuXG4gLy8gXFxcXCBpcyBhIG1hY3JvIG1hcHBpbmcgdG8gZWl0aGVyIFxcY3Igb3IgXFxuZXdsaW5lLiAgQmVjYXVzZSB0aGV5IGhhdmUgdGhlXG4vLyBzYW1lIHNpZ25hdHVyZSwgd2UgaW1wbGVtZW50IHRoZW0gYXMgb25lIG1lZ2FmdW5jdGlvbiwgd2l0aCBuZXdSb3dcbi8vIGluZGljYXRpbmcgd2hldGhlciB3ZSdyZSBpbiB0aGUgXFxjciBjYXNlLCBhbmQgbmV3TGluZSBpbmRpY2F0aW5nIHdoZXRoZXJcbi8vIHRvIGJyZWFrIHRoZSBsaW5lIGluIHRoZSBcXG5ld2xpbmUgY2FzZS5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImNyXCIsXG4gIG5hbWVzOiBbXCJcXFxcY3JcIiwgXCJcXFxcbmV3bGluZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZiwgYXJncywgb3B0QXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmLnBhcnNlcixcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmLmZ1bmNOYW1lO1xuICAgIHZhciBzaXplID0gb3B0QXJnc1swXTtcbiAgICB2YXIgbmV3Um93ID0gZnVuY05hbWUgPT09IFwiXFxcXGNyXCI7XG4gICAgdmFyIG5ld0xpbmUgPSBmYWxzZTtcblxuICAgIGlmICghbmV3Um93KSB7XG4gICAgICBpZiAocGFyc2VyLnNldHRpbmdzLmRpc3BsYXlNb2RlICYmIHBhcnNlci5zZXR0aW5ncy51c2VTdHJpY3RCZWhhdmlvcihcIm5ld0xpbmVJbkRpc3BsYXlNb2RlXCIsIFwiSW4gTGFUZVgsIFxcXFxcXFxcIG9yIFxcXFxuZXdsaW5lIFwiICsgXCJkb2VzIG5vdGhpbmcgaW4gZGlzcGxheSBtb2RlXCIpKSB7XG4gICAgICAgIG5ld0xpbmUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0xpbmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNyXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG5ld0xpbmU6IG5ld0xpbmUsXG4gICAgICBuZXdSb3c6IG5ld1JvdyxcbiAgICAgIHNpemU6IHNpemUgJiYgYXNzZXJ0Tm9kZVR5cGUoc2l6ZSwgXCJzaXplXCIpLnZhbHVlXG4gICAgfTtcbiAgfSxcbiAgLy8gVGhlIGZvbGxvd2luZyBidWlsZGVycyBhcmUgY2FsbGVkIG9ubHkgYXQgdGhlIHRvcCBsZXZlbCxcbiAgLy8gbm90IHdpdGhpbiB0YWJ1bGFyL2FycmF5IGVudmlyb25tZW50cy5cbiAgaHRtbEJ1aWxkZXI6IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgaWYgKGdyb3VwLm5ld1Jvdykge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiXFxcXGNyIHZhbGlkIG9ubHkgd2l0aGluIGEgdGFidWxhci9hcnJheSBlbnZpcm9ubWVudFwiKTtcbiAgICB9XG5cbiAgICB2YXIgc3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1zcGFjZVwiXSwgW10sIG9wdGlvbnMpO1xuXG4gICAgaWYgKGdyb3VwLm5ld0xpbmUpIHtcbiAgICAgIHNwYW4uY2xhc3Nlcy5wdXNoKFwibmV3bGluZVwiKTtcblxuICAgICAgaWYgKGdyb3VwLnNpemUpIHtcbiAgICAgICAgc3Bhbi5zdHlsZS5tYXJnaW5Ub3AgPSB1bml0c19jYWxjdWxhdGVTaXplKGdyb3VwLnNpemUsIG9wdGlvbnMpICsgXCJlbVwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzcGFuO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zcGFjZVwiKTtcblxuICAgIGlmIChncm91cC5uZXdMaW5lKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImxpbmVicmVha1wiLCBcIm5ld2xpbmVcIik7XG5cbiAgICAgIGlmIChncm91cC5zaXplKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIHVuaXRzX2NhbGN1bGF0ZVNpemUoZ3JvdXAuc2l6ZSwgb3B0aW9ucykgKyBcImVtXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2RlbGltaXRlci5qc1xuLyoqXG4gKiBUaGlzIGZpbGUgZGVhbHMgd2l0aCBjcmVhdGluZyBkZWxpbWl0ZXJzIG9mIHZhcmlvdXMgc2l6ZXMuIFRoZSBUZVhib29rXG4gKiBkaXNjdXNzZXMgdGhlc2Ugcm91dGluZXMgb24gcGFnZSA0NDEtNDQyLCBpbiB0aGUgXCJBbm90aGVyIHN1YnJvdXRpbmUgc2V0cyBib3hcbiAqIHggdG8gYSBzcGVjaWZpZWQgdmFyaWFibGUgZGVsaW1pdGVyXCIgcGFyYWdyYXBoLlxuICpcbiAqIFRoZXJlIGFyZSB0aHJlZSBtYWluIHJvdXRpbmVzIGhlcmUuIGBtYWtlU21hbGxEZWxpbWAgbWFrZXMgYSBkZWxpbWl0ZXIgaW4gdGhlXG4gKiBub3JtYWwgZm9udCwgYnV0IGluIGVpdGhlciB0ZXh0LCBzY3JpcHQsIG9yIHNjcmlwdHNjcmlwdCBzdHlsZS5cbiAqIGBtYWtlTGFyZ2VEZWxpbWAgbWFrZXMgYSBkZWxpbWl0ZXIgaW4gdGV4dHN0eWxlLCBidXQgaW4gb25lIG9mIHRoZSBTaXplMSxcbiAqIFNpemUyLCBTaXplMywgb3IgU2l6ZTQgZm9udHMuIGBtYWtlU3RhY2tlZERlbGltYCBtYWtlcyBhIGRlbGltaXRlciBvdXQgb2ZcbiAqIHNtYWxsZXIgcGllY2VzIHRoYXQgYXJlIHN0YWNrZWQgb24gdG9wIG9mIG9uZSBhbm90aGVyLlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgdGFrZSBhIHBhcmFtZXRlciBgY2VudGVyYCwgd2hpY2ggZGV0ZXJtaW5lcyBpZiB0aGUgZGVsaW1pdGVyXG4gKiBzaG91bGQgYmUgY2VudGVyZWQgYXJvdW5kIHRoZSBheGlzLlxuICpcbiAqIFRoZW4sIHRoZXJlIGFyZSB0aHJlZSBleHBvc2VkIGZ1bmN0aW9ucy4gYHNpemVkRGVsaW1gIG1ha2VzIGEgZGVsaW1pdGVyIGluXG4gKiBvbmUgb2YgdGhlIGdpdmVuIHNpemVzLiBUaGlzIGlzIHVzZWQgZm9yIHRoaW5ncyBsaWtlIGBcXGJpZ2xgLlxuICogYGN1c3RvbVNpemVkRGVsaW1gIG1ha2VzIGEgZGVsaW1pdGVyIHdpdGggYSBnaXZlbiB0b3RhbCBoZWlnaHQrZGVwdGguIEl0IGlzXG4gKiBjYWxsZWQgaW4gcGxhY2VzIGxpa2UgYFxcc3FydGAuIGBsZWZ0UmlnaHREZWxpbWAgbWFrZXMgYW4gYXBwcm9wcmlhdGVcbiAqIGRlbGltaXRlciB3aGljaCBzdXJyb3VuZHMgYW4gZXhwcmVzc2lvbiBvZiBhIGdpdmVuIGhlaWdodCBhbiBkZXB0aC4gSXQgaXNcbiAqIHVzZWQgaW4gYFxcbGVmdGAgYW5kIGBcXHJpZ2h0YC5cbiAqL1xuXG5cblxuXG5cblxuXG5cblxuLyoqXG4gKiBHZXQgdGhlIG1ldHJpY3MgZm9yIGEgZ2l2ZW4gc3ltYm9sIGFuZCBmb250LCBhZnRlciB0cmFuc2Zvcm1hdGlvbiAoaS5lLlxuICogYWZ0ZXIgZm9sbG93aW5nIHJlcGxhY2VtZW50IGZyb20gc3ltYm9scy5qcylcbiAqL1xudmFyIGRlbGltaXRlcl9nZXRNZXRyaWNzID0gZnVuY3Rpb24gZ2V0TWV0cmljcyhzeW1ib2wsIGZvbnQsIG1vZGUpIHtcbiAgdmFyIHJlcGxhY2UgPSBzcmNfc3ltYm9scy5tYXRoW3N5bWJvbF0gJiYgc3JjX3N5bWJvbHMubWF0aFtzeW1ib2xdLnJlcGxhY2U7XG4gIHZhciBtZXRyaWNzID0gZ2V0Q2hhcmFjdGVyTWV0cmljcyhyZXBsYWNlIHx8IHN5bWJvbCwgZm9udCwgbW9kZSk7XG5cbiAgaWYgKCFtZXRyaWNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgc3ltYm9sIFwiICsgc3ltYm9sICsgXCIgYW5kIGZvbnQgc2l6ZSBcIiArIGZvbnQgKyBcIi5cIik7XG4gIH1cblxuICByZXR1cm4gbWV0cmljcztcbn07XG4vKipcbiAqIFB1dHMgYSBkZWxpbWl0ZXIgc3BhbiBpbiBhIGdpdmVuIHN0eWxlLCBhbmQgYWRkcyBhcHByb3ByaWF0ZSBoZWlnaHQsIGRlcHRoLFxuICogYW5kIG1heEZvbnRTaXplcy5cbiAqL1xuXG5cbnZhciBkZWxpbWl0ZXJfc3R5bGVXcmFwID0gZnVuY3Rpb24gc3R5bGVXcmFwKGRlbGltLCB0b1N0eWxlLCBvcHRpb25zLCBjbGFzc2VzKSB7XG4gIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdCYXNlU3R5bGUodG9TdHlsZSk7XG4gIHZhciBzcGFuID0gYnVpbGRDb21tb24ubWFrZVNwYW4oY2xhc3Nlcy5jb25jYXQobmV3T3B0aW9ucy5zaXppbmdDbGFzc2VzKG9wdGlvbnMpKSwgW2RlbGltXSwgb3B0aW9ucyk7XG4gIHZhciBkZWxpbVNpemVNdWx0aXBsaWVyID0gbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllciAvIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gIHNwYW4uaGVpZ2h0ICo9IGRlbGltU2l6ZU11bHRpcGxpZXI7XG4gIHNwYW4uZGVwdGggKj0gZGVsaW1TaXplTXVsdGlwbGllcjtcbiAgc3Bhbi5tYXhGb250U2l6ZSA9IG5ld09wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gIHJldHVybiBzcGFuO1xufTtcblxudmFyIGNlbnRlclNwYW4gPSBmdW5jdGlvbiBjZW50ZXJTcGFuKHNwYW4sIG9wdGlvbnMsIHN0eWxlKSB7XG4gIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdCYXNlU3R5bGUoc3R5bGUpO1xuICB2YXIgc2hpZnQgPSAoMSAtIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXIgLyBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyKSAqIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5heGlzSGVpZ2h0O1xuICBzcGFuLmNsYXNzZXMucHVzaChcImRlbGltY2VudGVyXCIpO1xuICBzcGFuLnN0eWxlLnRvcCA9IHNoaWZ0ICsgXCJlbVwiO1xuICBzcGFuLmhlaWdodCAtPSBzaGlmdDtcbiAgc3Bhbi5kZXB0aCArPSBzaGlmdDtcbn07XG4vKipcbiAqIE1ha2VzIGEgc21hbGwgZGVsaW1pdGVyLiBUaGlzIGlzIGEgZGVsaW1pdGVyIHRoYXQgY29tZXMgaW4gdGhlIE1haW4tUmVndWxhclxuICogZm9udCwgYnV0IGlzIHJlc3R5bGVkIHRvIGVpdGhlciBiZSBpbiB0ZXh0c3R5bGUsIHNjcmlwdHN0eWxlLCBvclxuICogc2NyaXB0c2NyaXB0c3R5bGUuXG4gKi9cblxuXG52YXIgZGVsaW1pdGVyX21ha2VTbWFsbERlbGltID0gZnVuY3Rpb24gbWFrZVNtYWxsRGVsaW0oZGVsaW0sIHN0eWxlLCBjZW50ZXIsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpIHtcbiAgdmFyIHRleHQgPSBidWlsZENvbW1vbi5tYWtlU3ltYm9sKGRlbGltLCBcIk1haW4tUmVndWxhclwiLCBtb2RlLCBvcHRpb25zKTtcbiAgdmFyIHNwYW4gPSBkZWxpbWl0ZXJfc3R5bGVXcmFwKHRleHQsIHN0eWxlLCBvcHRpb25zLCBjbGFzc2VzKTtcblxuICBpZiAoY2VudGVyKSB7XG4gICAgY2VudGVyU3BhbihzcGFuLCBvcHRpb25zLCBzdHlsZSk7XG4gIH1cblxuICByZXR1cm4gc3Bhbjtcbn07XG4vKipcbiAqIEJ1aWxkcyBhIHN5bWJvbCBpbiB0aGUgZ2l2ZW4gZm9udCBzaXplIChub3RlIHNpemUgaXMgYW4gaW50ZWdlcilcbiAqL1xuXG5cbnZhciBkZWxpbWl0ZXJfbWF0aHJtU2l6ZSA9IGZ1bmN0aW9uIG1hdGhybVNpemUodmFsdWUsIHNpemUsIG1vZGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTeW1ib2wodmFsdWUsIFwiU2l6ZVwiICsgc2l6ZSArIFwiLVJlZ3VsYXJcIiwgbW9kZSwgb3B0aW9ucyk7XG59O1xuLyoqXG4gKiBNYWtlcyBhIGxhcmdlIGRlbGltaXRlci4gVGhpcyBpcyBhIGRlbGltaXRlciB0aGF0IGNvbWVzIGluIHRoZSBTaXplMSwgU2l6ZTIsXG4gKiBTaXplMywgb3IgU2l6ZTQgZm9udHMuIEl0IGlzIGFsd2F5cyByZW5kZXJlZCBpbiB0ZXh0c3R5bGUuXG4gKi9cblxuXG52YXIgZGVsaW1pdGVyX21ha2VMYXJnZURlbGltID0gZnVuY3Rpb24gbWFrZUxhcmdlRGVsaW0oZGVsaW0sIHNpemUsIGNlbnRlciwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcykge1xuICB2YXIgaW5uZXIgPSBkZWxpbWl0ZXJfbWF0aHJtU2l6ZShkZWxpbSwgc2l6ZSwgbW9kZSwgb3B0aW9ucyk7XG4gIHZhciBzcGFuID0gZGVsaW1pdGVyX3N0eWxlV3JhcChidWlsZENvbW1vbi5tYWtlU3BhbihbXCJkZWxpbXNpemluZ1wiLCBcInNpemVcIiArIHNpemVdLCBbaW5uZXJdLCBvcHRpb25zKSwgc3JjX1N0eWxlLlRFWFQsIG9wdGlvbnMsIGNsYXNzZXMpO1xuXG4gIGlmIChjZW50ZXIpIHtcbiAgICBjZW50ZXJTcGFuKHNwYW4sIG9wdGlvbnMsIHNyY19TdHlsZS5URVhUKTtcbiAgfVxuXG4gIHJldHVybiBzcGFuO1xufTtcbi8qKlxuICogTWFrZSBhbiBpbm5lciBzcGFuIHdpdGggdGhlIGdpdmVuIG9mZnNldCBhbmQgaW4gdGhlIGdpdmVuIGZvbnQuIFRoaXMgaXMgdXNlZFxuICogaW4gYG1ha2VTdGFja2VkRGVsaW1gIHRvIG1ha2UgdGhlIHN0YWNraW5nIHBpZWNlcyBmb3IgdGhlIGRlbGltaXRlci5cbiAqL1xuXG5cbnZhciBkZWxpbWl0ZXJfbWFrZUlubmVyID0gZnVuY3Rpb24gbWFrZUlubmVyKHN5bWJvbCwgZm9udCwgbW9kZSkge1xuICB2YXIgc2l6ZUNsYXNzOyAvLyBBcHBseSB0aGUgY29ycmVjdCBDU1MgY2xhc3MgdG8gY2hvb3NlIHRoZSByaWdodCBmb250LlxuXG4gIGlmIChmb250ID09PSBcIlNpemUxLVJlZ3VsYXJcIikge1xuICAgIHNpemVDbGFzcyA9IFwiZGVsaW0tc2l6ZTFcIjtcbiAgfSBlbHNlXG4gICAgLyogaWYgKGZvbnQgPT09IFwiU2l6ZTQtUmVndWxhclwiKSAqL1xuICAgIHtcbiAgICAgIHNpemVDbGFzcyA9IFwiZGVsaW0tc2l6ZTRcIjtcbiAgICB9XG5cbiAgdmFyIGlubmVyID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiZGVsaW1zaXppbmdpbm5lclwiLCBzaXplQ2xhc3NdLCBbYnVpbGRDb21tb24ubWFrZVNwYW4oW10sIFtidWlsZENvbW1vbi5tYWtlU3ltYm9sKHN5bWJvbCwgZm9udCwgbW9kZSldKV0pOyAvLyBTaW5jZSB0aGlzIHdpbGwgYmUgcGFzc2VkIGludG8gYG1ha2VWTGlzdGAgaW4gdGhlIGVuZCwgd3JhcCB0aGUgZWxlbWVudFxuICAvLyBpbiB0aGUgYXBwcm9wcmlhdGUgdGFnIHRoYXQgVkxpc3QgdXNlcy5cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgIGVsZW06IGlubmVyXG4gIH07XG59OyAvLyBIZWxwZXIgZm9yIG1ha2VTdGFja2VkRGVsaW1cblxuXG52YXIgbGFwID0ge1xuICB0eXBlOiBcImtlcm5cIixcbiAgc2l6ZTogLTAuMDA1XG59O1xuLyoqXG4gKiBNYWtlIGEgc3RhY2tlZCBkZWxpbWl0ZXIgb3V0IG9mIGEgZ2l2ZW4gZGVsaW1pdGVyLCB3aXRoIHRoZSB0b3RhbCBoZWlnaHQgYXRcbiAqIGxlYXN0IGBoZWlnaHRUb3RhbGAuIFRoaXMgcm91dGluZSBpcyBtZW50aW9uZWQgb24gcGFnZSA0NDIgb2YgdGhlIFRlWGJvb2suXG4gKi9cblxudmFyIGRlbGltaXRlcl9tYWtlU3RhY2tlZERlbGltID0gZnVuY3Rpb24gbWFrZVN0YWNrZWREZWxpbShkZWxpbSwgaGVpZ2h0VG90YWwsIGNlbnRlciwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcykge1xuICAvLyBUaGVyZSBhcmUgZm91ciBwYXJ0cywgdGhlIHRvcCwgYW4gb3B0aW9uYWwgbWlkZGxlLCBhIHJlcGVhdGVkIHBhcnQsIGFuZCBhXG4gIC8vIGJvdHRvbS5cbiAgdmFyIHRvcDtcbiAgdmFyIG1pZGRsZTtcbiAgdmFyIHJlcGVhdDtcbiAgdmFyIGJvdHRvbTtcbiAgdG9wID0gcmVwZWF0ID0gYm90dG9tID0gZGVsaW07XG4gIG1pZGRsZSA9IG51bGw7IC8vIEFsc28ga2VlcCB0cmFjayBvZiB3aGF0IGZvbnQgdGhlIGRlbGltaXRlcnMgYXJlIGluXG5cbiAgdmFyIGZvbnQgPSBcIlNpemUxLVJlZ3VsYXJcIjsgLy8gV2Ugc2V0IHRoZSBwYXJ0cyBhbmQgZm9udCBiYXNlZCBvbiB0aGUgc3ltYm9sLiBOb3RlIHRoYXQgd2UgdXNlXG4gIC8vICdcXHUyM2QwJyBpbnN0ZWFkIG9mICd8JyBhbmQgJ1xcdTIwMTYnIGluc3RlYWQgb2YgJ1xcXFx8JyBmb3IgdGhlXG4gIC8vIHJlcGVhdHMgb2YgdGhlIGFycm93c1xuXG4gIGlmIChkZWxpbSA9PT0gXCJcXFxcdXBhcnJvd1wiKSB7XG4gICAgcmVwZWF0ID0gYm90dG9tID0gXCJcXHUyM0QwXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXFVwYXJyb3dcIikge1xuICAgIHJlcGVhdCA9IGJvdHRvbSA9IFwiXFx1MjAxNlwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxkb3duYXJyb3dcIikge1xuICAgIHRvcCA9IHJlcGVhdCA9IFwiXFx1MjNEMFwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxEb3duYXJyb3dcIikge1xuICAgIHRvcCA9IHJlcGVhdCA9IFwiXFx1MjAxNlwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFx1cGRvd25hcnJvd1wiKSB7XG4gICAgdG9wID0gXCJcXFxcdXBhcnJvd1wiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjNEMFwiO1xuICAgIGJvdHRvbSA9IFwiXFxcXGRvd25hcnJvd1wiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxVcGRvd25hcnJvd1wiKSB7XG4gICAgdG9wID0gXCJcXFxcVXBhcnJvd1wiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjAxNlwiO1xuICAgIGJvdHRvbSA9IFwiXFxcXERvd25hcnJvd1wiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIltcIiB8fCBkZWxpbSA9PT0gXCJcXFxcbGJyYWNrXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzQTFcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzQTJcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzQTNcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXVwiIHx8IGRlbGltID09PSBcIlxcXFxyYnJhY2tcIikge1xuICAgIHRvcCA9IFwiXFx1MjNBNFwiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjNBNVwiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjNBNlwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcbGZsb29yXCIgfHwgZGVsaW0gPT09IFwiXFx1MjMwQVwiKSB7XG4gICAgcmVwZWF0ID0gdG9wID0gXCJcXHUyM0EyXCI7XG4gICAgYm90dG9tID0gXCJcXHUyM0EzXCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxsY2VpbFwiIHx8IGRlbGltID09PSBcIlxcdTIzMDhcIikge1xuICAgIHRvcCA9IFwiXFx1MjNBMVwiO1xuICAgIHJlcGVhdCA9IGJvdHRvbSA9IFwiXFx1MjNBMlwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxccmZsb29yXCIgfHwgZGVsaW0gPT09IFwiXFx1MjMwQlwiKSB7XG4gICAgcmVwZWF0ID0gdG9wID0gXCJcXHUyM0E1XCI7XG4gICAgYm90dG9tID0gXCJcXHUyM0E2XCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxyY2VpbFwiIHx8IGRlbGltID09PSBcIlxcdTIzMDlcIikge1xuICAgIHRvcCA9IFwiXFx1MjNBNFwiO1xuICAgIHJlcGVhdCA9IGJvdHRvbSA9IFwiXFx1MjNBNVwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCIoXCIgfHwgZGVsaW0gPT09IFwiXFxcXGxwYXJlblwiKSB7XG4gICAgdG9wID0gXCJcXHUyMzlCXCI7XG4gICAgcmVwZWF0ID0gXCJcXHUyMzlDXCI7XG4gICAgYm90dG9tID0gXCJcXHUyMzlEXCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIilcIiB8fCBkZWxpbSA9PT0gXCJcXFxccnBhcmVuXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzOUVcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzOUZcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzQTBcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHtcIiB8fCBkZWxpbSA9PT0gXCJcXFxcbGJyYWNlXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzQTdcIjtcbiAgICBtaWRkbGUgPSBcIlxcdTIzQThcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzQTlcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzQUFcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXH1cIiB8fCBkZWxpbSA9PT0gXCJcXFxccmJyYWNlXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzQUJcIjtcbiAgICBtaWRkbGUgPSBcIlxcdTIzQUNcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzQURcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzQUFcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXGxncm91cFwiIHx8IGRlbGltID09PSBcIlxcdTI3RUVcIikge1xuICAgIHRvcCA9IFwiXFx1MjNBN1wiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjNBOVwiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjNBQVwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxccmdyb3VwXCIgfHwgZGVsaW0gPT09IFwiXFx1MjdFRlwiKSB7XG4gICAgdG9wID0gXCJcXHUyM0FCXCI7XG4gICAgYm90dG9tID0gXCJcXHUyM0FEXCI7XG4gICAgcmVwZWF0ID0gXCJcXHUyM0FBXCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxsbW91c3RhY2hlXCIgfHwgZGVsaW0gPT09IFwiXFx1MjNCMFwiKSB7XG4gICAgdG9wID0gXCJcXHUyM0E3XCI7XG4gICAgYm90dG9tID0gXCJcXHUyM0FEXCI7XG4gICAgcmVwZWF0ID0gXCJcXHUyM0FBXCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxybW91c3RhY2hlXCIgfHwgZGVsaW0gPT09IFwiXFx1MjNCMVwiKSB7XG4gICAgdG9wID0gXCJcXHUyM0FCXCI7XG4gICAgYm90dG9tID0gXCJcXHUyM0E5XCI7XG4gICAgcmVwZWF0ID0gXCJcXHUyM0FBXCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICB9IC8vIEdldCB0aGUgbWV0cmljcyBvZiB0aGUgZm91ciBzZWN0aW9uc1xuXG5cbiAgdmFyIHRvcE1ldHJpY3MgPSBkZWxpbWl0ZXJfZ2V0TWV0cmljcyh0b3AsIGZvbnQsIG1vZGUpO1xuICB2YXIgdG9wSGVpZ2h0VG90YWwgPSB0b3BNZXRyaWNzLmhlaWdodCArIHRvcE1ldHJpY3MuZGVwdGg7XG4gIHZhciByZXBlYXRNZXRyaWNzID0gZGVsaW1pdGVyX2dldE1ldHJpY3MocmVwZWF0LCBmb250LCBtb2RlKTtcbiAgdmFyIHJlcGVhdEhlaWdodFRvdGFsID0gcmVwZWF0TWV0cmljcy5oZWlnaHQgKyByZXBlYXRNZXRyaWNzLmRlcHRoO1xuICB2YXIgYm90dG9tTWV0cmljcyA9IGRlbGltaXRlcl9nZXRNZXRyaWNzKGJvdHRvbSwgZm9udCwgbW9kZSk7XG4gIHZhciBib3R0b21IZWlnaHRUb3RhbCA9IGJvdHRvbU1ldHJpY3MuaGVpZ2h0ICsgYm90dG9tTWV0cmljcy5kZXB0aDtcbiAgdmFyIG1pZGRsZUhlaWdodFRvdGFsID0gMDtcbiAgdmFyIG1pZGRsZUZhY3RvciA9IDE7XG5cbiAgaWYgKG1pZGRsZSAhPT0gbnVsbCkge1xuICAgIHZhciBtaWRkbGVNZXRyaWNzID0gZGVsaW1pdGVyX2dldE1ldHJpY3MobWlkZGxlLCBmb250LCBtb2RlKTtcbiAgICBtaWRkbGVIZWlnaHRUb3RhbCA9IG1pZGRsZU1ldHJpY3MuaGVpZ2h0ICsgbWlkZGxlTWV0cmljcy5kZXB0aDtcbiAgICBtaWRkbGVGYWN0b3IgPSAyOyAvLyByZXBlYXQgc3ltbWV0cmljYWxseSBhYm92ZSBhbmQgYmVsb3cgbWlkZGxlXG4gIH0gLy8gQ2FsY3VhdGUgdGhlIG1pbmltYWwgaGVpZ2h0IHRoYXQgdGhlIGRlbGltaXRlciBjYW4gaGF2ZS5cbiAgLy8gSXQgaXMgYXQgbGVhc3QgdGhlIHNpemUgb2YgdGhlIHRvcCwgYm90dG9tLCBhbmQgb3B0aW9uYWwgbWlkZGxlIGNvbWJpbmVkLlxuXG5cbiAgdmFyIG1pbkhlaWdodCA9IHRvcEhlaWdodFRvdGFsICsgYm90dG9tSGVpZ2h0VG90YWwgKyBtaWRkbGVIZWlnaHRUb3RhbDsgLy8gQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIGNvcGllcyBvZiB0aGUgcmVwZWF0IHN5bWJvbCB3ZSB3aWxsIG5lZWRcblxuICB2YXIgcmVwZWF0Q291bnQgPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKGhlaWdodFRvdGFsIC0gbWluSGVpZ2h0KSAvIChtaWRkbGVGYWN0b3IgKiByZXBlYXRIZWlnaHRUb3RhbCkpKTsgLy8gQ29tcHV0ZSB0aGUgdG90YWwgaGVpZ2h0IG9mIHRoZSBkZWxpbWl0ZXIgaW5jbHVkaW5nIGFsbCB0aGUgc3ltYm9sc1xuXG4gIHZhciByZWFsSGVpZ2h0VG90YWwgPSBtaW5IZWlnaHQgKyByZXBlYXRDb3VudCAqIG1pZGRsZUZhY3RvciAqIHJlcGVhdEhlaWdodFRvdGFsOyAvLyBUaGUgY2VudGVyIG9mIHRoZSBkZWxpbWl0ZXIgaXMgcGxhY2VkIGF0IHRoZSBjZW50ZXIgb2YgdGhlIGF4aXMuIE5vdGVcbiAgLy8gdGhhdCBpbiB0aGlzIGNvbnRleHQsIFwiY2VudGVyXCIgbWVhbnMgdGhhdCB0aGUgZGVsaW1pdGVyIHNob3VsZCBiZVxuICAvLyBjZW50ZXJlZCBhcm91bmQgdGhlIGF4aXMgaW4gdGhlIGN1cnJlbnQgc3R5bGUsIHdoaWxlIG5vcm1hbGx5IGl0IGlzXG4gIC8vIGNlbnRlcmVkIGFyb3VuZCB0aGUgYXhpcyBpbiB0ZXh0c3R5bGUuXG5cbiAgdmFyIGF4aXNIZWlnaHQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodDtcblxuICBpZiAoY2VudGVyKSB7XG4gICAgYXhpc0hlaWdodCAqPSBvcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICB9IC8vIENhbGN1bGF0ZSB0aGUgZGVwdGhcblxuXG4gIHZhciBkZXB0aCA9IHJlYWxIZWlnaHRUb3RhbCAvIDIgLSBheGlzSGVpZ2h0OyAvLyBUaGlzIGZ1bmN0aW9uIGRpZmZlcnMgZnJvbSB0aGUgVGVYIHByb2NlZHVyZSBpbiBvbmUgd2F5LlxuICAvLyBXZSBzaGlmdCBlYWNoIHJlcGVhdCBlbGVtZW50IGRvd253YXJkcyBieSAwLjAwNWVtLCB0byBwcmV2ZW50IGEgZ2FwXG4gIC8vIGR1ZSB0byBicm93c2VyIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9yLlxuICAvLyBUaGVuLCBhdCB0aGUgbGFzdCBlbGVtZW50LXRvIGVsZW1lbnQgam9pbnQsIHdlIGFkZCBvbmUgZXh0cmEgcmVwZWF0XG4gIC8vIGVsZW1lbnQgdG8gY292ZXIgdGhlIGdhcCBjcmVhdGVkIGJ5IHRoZSBzaGlmdHMuXG4gIC8vIEZpbmQgdGhlIHNoaWZ0IG5lZWRlZCB0byBhbGlnbiB0aGUgdXBwZXIgZW5kIG9mIHRoZSBleHRyYSBlbGVtZW50IGF0IGEgcG9pbnRcbiAgLy8gMC4wMDVlbSBhYm92ZSB0aGUgbG93ZXIgZW5kIG9mIHRoZSB0b3AgZWxlbWVudC5cblxuICB2YXIgc2hpZnRPZkV4dHJhRWxlbWVudCA9IChyZXBlYXRDb3VudCArIDEpICogMC4wMDUgLSByZXBlYXRIZWlnaHRUb3RhbDsgLy8gTm93LCB3ZSBzdGFydCBidWlsZGluZyB0aGUgcGllY2VzIHRoYXQgd2lsbCBnbyBpbnRvIHRoZSB2bGlzdFxuICAvLyBLZWVwIGEgbGlzdCBvZiB0aGUgaW5uZXIgcGllY2VzXG5cbiAgdmFyIGlubmVycyA9IFtdOyAvLyBBZGQgdGhlIGJvdHRvbSBzeW1ib2xcblxuICBpbm5lcnMucHVzaChkZWxpbWl0ZXJfbWFrZUlubmVyKGJvdHRvbSwgZm9udCwgbW9kZSkpO1xuXG4gIGlmIChtaWRkbGUgPT09IG51bGwpIHtcbiAgICAvLyBBZGQgdGhhdCBtYW55IHN5bWJvbHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcGVhdENvdW50OyBpKyspIHtcbiAgICAgIGlubmVycy5wdXNoKGxhcCk7IC8vIG92ZXJsYXBcblxuICAgICAgaW5uZXJzLnB1c2goZGVsaW1pdGVyX21ha2VJbm5lcihyZXBlYXQsIGZvbnQsIG1vZGUpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gV2hlbiB0aGVyZSBpcyBhIG1pZGRsZSBiaXQsIHdlIG5lZWQgdGhlIG1pZGRsZSBwYXJ0IGFuZCB0d28gcmVwZWF0ZWRcbiAgICAvLyBzZWN0aW9uc1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCByZXBlYXRDb3VudDsgX2krKykge1xuICAgICAgaW5uZXJzLnB1c2gobGFwKTtcbiAgICAgIGlubmVycy5wdXNoKGRlbGltaXRlcl9tYWtlSW5uZXIocmVwZWF0LCBmb250LCBtb2RlKSk7XG4gICAgfSAvLyBJbnNlcnQgb25lIGV4dHJhIHJlcGVhdCBlbGVtZW50LlxuXG5cbiAgICBpbm5lcnMucHVzaCh7XG4gICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgIHNpemU6IHNoaWZ0T2ZFeHRyYUVsZW1lbnRcbiAgICB9KTtcbiAgICBpbm5lcnMucHVzaChkZWxpbWl0ZXJfbWFrZUlubmVyKHJlcGVhdCwgZm9udCwgbW9kZSkpO1xuICAgIGlubmVycy5wdXNoKGxhcCk7IC8vIE5vdyBpbnNlcnQgdGhlIG1pZGRsZSBvZiB0aGUgYnJhY2UuXG5cbiAgICBpbm5lcnMucHVzaChkZWxpbWl0ZXJfbWFrZUlubmVyKG1pZGRsZSwgZm9udCwgbW9kZSkpO1xuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcmVwZWF0Q291bnQ7IF9pMisrKSB7XG4gICAgICBpbm5lcnMucHVzaChsYXApO1xuICAgICAgaW5uZXJzLnB1c2goZGVsaW1pdGVyX21ha2VJbm5lcihyZXBlYXQsIGZvbnQsIG1vZGUpKTtcbiAgICB9XG4gIH0gLy8gVG8gY292ZXIgdGhlIGdhcCBjcmVhdGUgYnkgdGhlIG92ZXJsYXBzLCBpbnNlcnQgb25lIG1vcmUgcmVwZWF0IGVsZW1lbnQsXG4gIC8vIGF0IGEgcG9zaXRpb24gdGhhdCBqdXRzIDAuMDA1IGFib3ZlIHRoZSBib3R0b20gb2YgdGhlIHRvcCBlbGVtZW50LlxuXG5cbiAgaW5uZXJzLnB1c2goe1xuICAgIHR5cGU6IFwia2VyblwiLFxuICAgIHNpemU6IHNoaWZ0T2ZFeHRyYUVsZW1lbnRcbiAgfSk7XG4gIGlubmVycy5wdXNoKGRlbGltaXRlcl9tYWtlSW5uZXIocmVwZWF0LCBmb250LCBtb2RlKSk7XG4gIGlubmVycy5wdXNoKGxhcCk7IC8vIEFkZCB0aGUgdG9wIHN5bWJvbFxuXG4gIGlubmVycy5wdXNoKGRlbGltaXRlcl9tYWtlSW5uZXIodG9wLCBmb250LCBtb2RlKSk7IC8vIEZpbmFsbHksIGJ1aWxkIHRoZSB2bGlzdFxuXG4gIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdCYXNlU3R5bGUoc3JjX1N0eWxlLlRFWFQpO1xuICB2YXIgaW5uZXIgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgIHBvc2l0aW9uVHlwZTogXCJib3R0b21cIixcbiAgICBwb3NpdGlvbkRhdGE6IGRlcHRoLFxuICAgIGNoaWxkcmVuOiBpbm5lcnNcbiAgfSwgbmV3T3B0aW9ucyk7XG4gIHJldHVybiBkZWxpbWl0ZXJfc3R5bGVXcmFwKGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImRlbGltc2l6aW5nXCIsIFwibXVsdFwiXSwgW2lubmVyXSwgbmV3T3B0aW9ucyksIHNyY19TdHlsZS5URVhULCBvcHRpb25zLCBjbGFzc2VzKTtcbn07IC8vIEFsbCBzdXJkcyBoYXZlIDAuMDhlbSBwYWRkaW5nIGFib3ZlIHRoZSB2aW5pY3VsdW0gaW5zaWRlIHRoZSBTVkcuXG4vLyBUaGF0IGtlZXBzIGJyb3dzZXIgc3BhbiBoZWlnaHQgcm91bmRpbmcgZXJyb3IgZnJvbSBwaW5jaGluZyB0aGUgbGluZS5cblxuXG52YXIgdmJQYWQgPSA4MDsgLy8gcGFkZGluZyBhYm92ZSB0aGUgc3VyZCwgbWVhc3VyZWQgaW5zaWRlIHRoZSB2aWV3Qm94LlxuXG52YXIgZW1QYWQgPSAwLjA4OyAvLyBwYWRkaW5nLCBpbiBlbXMsIG1lYXN1cmVkIGluIHRoZSBkb2N1bWVudC5cblxudmFyIGRlbGltaXRlcl9zcXJ0U3ZnID0gZnVuY3Rpb24gc3FydFN2ZyhzcXJ0TmFtZSwgaGVpZ2h0LCB2aWV3Qm94SGVpZ2h0LCBleHRyYVZpbmljdWx1bSwgb3B0aW9ucykge1xuICB2YXIgcGF0aCA9IHNxcnRQYXRoKHNxcnROYW1lLCBleHRyYVZpbmljdWx1bSwgdmlld0JveEhlaWdodCk7XG4gIHZhciBwYXRoTm9kZSA9IG5ldyBkb21UcmVlX1BhdGhOb2RlKHNxcnROYW1lLCBwYXRoKTtcbiAgdmFyIHN2ZyA9IG5ldyBTdmdOb2RlKFtwYXRoTm9kZV0sIHtcbiAgICAvLyBOb3RlOiAxMDAwOjEgcmF0aW8gb2Ygdmlld0JveCB0byBkb2N1bWVudCBlbSB3aWR0aC5cbiAgICBcIndpZHRoXCI6IFwiNDAwZW1cIixcbiAgICBcImhlaWdodFwiOiBoZWlnaHQgKyBcImVtXCIsXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDQwMDAwMCBcIiArIHZpZXdCb3hIZWlnaHQsXG4gICAgXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCI6IFwieE1pbllNaW4gc2xpY2VcIlxuICB9KTtcbiAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTdmdTcGFuKFtcImhpZGUtdGFpbFwiXSwgW3N2Z10sIG9wdGlvbnMpO1xufTtcbi8qKlxuICogTWFrZSBhIHNxcnQgaW1hZ2Ugb2YgdGhlIGdpdmVuIGhlaWdodCxcbiAqL1xuXG5cbnZhciBtYWtlU3FydEltYWdlID0gZnVuY3Rpb24gbWFrZVNxcnRJbWFnZShoZWlnaHQsIG9wdGlvbnMpIHtcbiAgLy8gRGVmaW5lIGEgbmV3T3B0aW9ucyB0aGF0IHJlbW92ZXMgdGhlIGVmZmVjdCBvZiBzaXplIGNoYW5nZXMgc3VjaCBhcyBcXEh1Z2UuXG4gIC8vIFdlIGRvbid0IHBpY2sgZGlmZmVyZW50IGEgaGVpZ2h0IHN1cmQgZm9yIFxcSHVnZS4gRm9yIGl0LCB3ZSBzY2FsZSB1cC5cbiAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ0Jhc2VTaXppbmcoKTsgLy8gUGljayB0aGUgZGVzaXJlZCBzdXJkIGdseXBoIGZyb20gYSBzZXF1ZW5jZSBvZiBzdXJkcy5cblxuICB2YXIgZGVsaW0gPSB0cmF2ZXJzZVNlcXVlbmNlKFwiXFxcXHN1cmRcIiwgaGVpZ2h0ICogbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllciwgc3RhY2tMYXJnZURlbGltaXRlclNlcXVlbmNlLCBuZXdPcHRpb25zKTtcbiAgdmFyIHNpemVNdWx0aXBsaWVyID0gbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllcjsgLy8gZGVmYXVsdFxuICAvLyBUaGUgc3RhbmRhcmQgc3FydCBTVkdzIGVhY2ggaGF2ZSBhIDAuMDRlbSB0aGljayB2aW5pY3VsdW0uXG4gIC8vIElmIFNldHRpbmdzLm1pblJ1bGVUaGlja25lc3MgaXMgbGFyZ2VyIHRoYW4gdGhhdCwgd2UgYWRkIGV4dHJhVmluaWN1bHVtLlxuXG4gIHZhciBleHRyYVZpbmljdWx1bSA9IE1hdGgubWF4KDAsIG9wdGlvbnMubWluUnVsZVRoaWNrbmVzcyAtIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5zcXJ0UnVsZVRoaWNrbmVzcyk7IC8vIENyZWF0ZSBhIHNwYW4gY29udGFpbmluZyBhbiBTVkcgaW1hZ2Ugb2YgYSBzcXJ0IHN5bWJvbC5cblxuICB2YXIgc3BhbjtcbiAgdmFyIHNwYW5IZWlnaHQgPSAwO1xuICB2YXIgdGV4SGVpZ2h0ID0gMDtcbiAgdmFyIHZpZXdCb3hIZWlnaHQgPSAwO1xuICB2YXIgYWR2YW5jZVdpZHRoOyAvLyBXZSBjcmVhdGUgdmlld0JveGVzIHdpdGggODAgdW5pdHMgb2YgXCJwYWRkaW5nXCIgYWJvdmUgZWFjaCBzdXJkLlxuICAvLyBUaGVuIGJyb3dzZXIgcm91bmRpbmcgZXJyb3Igb24gdGhlIHBhcmVudCBzcGFuIGhlaWdodCB3aWxsIG5vdFxuICAvLyBlbmNyb2FjaCBvbiB0aGUgaW5rIG9mIHRoZSB2aW5pY3VsdW0uIEJ1dCB0aGF0IHBhZGRpbmcgaXMgbm90XG4gIC8vIGluY2x1ZGVkIGluIHRoZSBUZVgtbGlrZSBgaGVpZ2h0YCB1c2VkIGZvciBjYWxjdWxhdGlvbiBvZlxuICAvLyB2ZXJ0aWNhbCBhbGlnbm1lbnQuIFNvIHRleEhlaWdodCA9IHNwYW4uaGVpZ2h0IDwgc3Bhbi5zdHlsZS5oZWlnaHQuXG5cbiAgaWYgKGRlbGltLnR5cGUgPT09IFwic21hbGxcIikge1xuICAgIC8vIEdldCBhbiBTVkcgdGhhdCBpcyBkZXJpdmVkIGZyb20gZ2x5cGggVSsyMjFBIGluIGZvbnQgS2FUZVgtTWFpbi5cbiAgICAvLyAxMDAwIHVuaXQgbm9ybWFsIGdseXBoIGhlaWdodC5cbiAgICB2aWV3Qm94SGVpZ2h0ID0gMTAwMCArIDEwMDAgKiBleHRyYVZpbmljdWx1bSArIHZiUGFkO1xuXG4gICAgaWYgKGhlaWdodCA8IDEuMCkge1xuICAgICAgc2l6ZU11bHRpcGxpZXIgPSAxLjA7IC8vIG1pbWljIGEgXFx0ZXh0Zm9udCByYWRpY2FsXG4gICAgfSBlbHNlIGlmIChoZWlnaHQgPCAxLjQpIHtcbiAgICAgIHNpemVNdWx0aXBsaWVyID0gMC43OyAvLyBtaW1pYyBhIFxcc2NyaXB0Zm9udCByYWRpY2FsXG4gICAgfVxuXG4gICAgc3BhbkhlaWdodCA9ICgxLjAgKyBleHRyYVZpbmljdWx1bSArIGVtUGFkKSAvIHNpemVNdWx0aXBsaWVyO1xuICAgIHRleEhlaWdodCA9ICgxLjAwICsgZXh0cmFWaW5pY3VsdW0pIC8gc2l6ZU11bHRpcGxpZXI7XG4gICAgc3BhbiA9IGRlbGltaXRlcl9zcXJ0U3ZnKFwic3FydE1haW5cIiwgc3BhbkhlaWdodCwgdmlld0JveEhlaWdodCwgZXh0cmFWaW5pY3VsdW0sIG9wdGlvbnMpO1xuICAgIHNwYW4uc3R5bGUubWluV2lkdGggPSBcIjAuODUzZW1cIjtcbiAgICBhZHZhbmNlV2lkdGggPSAwLjgzMyAvIHNpemVNdWx0aXBsaWVyOyAvLyBmcm9tIHRoZSBmb250LlxuICB9IGVsc2UgaWYgKGRlbGltLnR5cGUgPT09IFwibGFyZ2VcIikge1xuICAgIC8vIFRoZXNlIFNWR3MgY29tZSBmcm9tIGZvbnRzOiBLYVRlWF9TaXplMSwgX1NpemUyLCBldGMuXG4gICAgdmlld0JveEhlaWdodCA9ICgxMDAwICsgdmJQYWQpICogc2l6ZVRvTWF4SGVpZ2h0W2RlbGltLnNpemVdO1xuICAgIHRleEhlaWdodCA9IChzaXplVG9NYXhIZWlnaHRbZGVsaW0uc2l6ZV0gKyBleHRyYVZpbmljdWx1bSkgLyBzaXplTXVsdGlwbGllcjtcbiAgICBzcGFuSGVpZ2h0ID0gKHNpemVUb01heEhlaWdodFtkZWxpbS5zaXplXSArIGV4dHJhVmluaWN1bHVtICsgZW1QYWQpIC8gc2l6ZU11bHRpcGxpZXI7XG4gICAgc3BhbiA9IGRlbGltaXRlcl9zcXJ0U3ZnKFwic3FydFNpemVcIiArIGRlbGltLnNpemUsIHNwYW5IZWlnaHQsIHZpZXdCb3hIZWlnaHQsIGV4dHJhVmluaWN1bHVtLCBvcHRpb25zKTtcbiAgICBzcGFuLnN0eWxlLm1pbldpZHRoID0gXCIxLjAyZW1cIjtcbiAgICBhZHZhbmNlV2lkdGggPSAxLjAgLyBzaXplTXVsdGlwbGllcjsgLy8gMS4wIGZyb20gdGhlIGZvbnQuXG4gIH0gZWxzZSB7XG4gICAgLy8gVGFsbCBzcXJ0LiBJbiBUZVgsIHRoaXMgd291bGQgYmUgc3RhY2tlZCB1c2luZyBtdWx0aXBsZSBnbHlwaHMuXG4gICAgLy8gV2UnbGwgdXNlIGEgc2luZ2xlIFNWRyB0byBhY2NvbXBsaXNoIHRoZSBzYW1lIHRoaW5nLlxuICAgIHNwYW5IZWlnaHQgPSBoZWlnaHQgKyBleHRyYVZpbmljdWx1bSArIGVtUGFkO1xuICAgIHRleEhlaWdodCA9IGhlaWdodCArIGV4dHJhVmluaWN1bHVtO1xuICAgIHZpZXdCb3hIZWlnaHQgPSBNYXRoLmZsb29yKDEwMDAgKiBoZWlnaHQgKyBleHRyYVZpbmljdWx1bSkgKyB2YlBhZDtcbiAgICBzcGFuID0gZGVsaW1pdGVyX3NxcnRTdmcoXCJzcXJ0VGFsbFwiLCBzcGFuSGVpZ2h0LCB2aWV3Qm94SGVpZ2h0LCBleHRyYVZpbmljdWx1bSwgb3B0aW9ucyk7XG4gICAgc3Bhbi5zdHlsZS5taW5XaWR0aCA9IFwiMC43NDJlbVwiO1xuICAgIGFkdmFuY2VXaWR0aCA9IDEuMDU2O1xuICB9XG5cbiAgc3Bhbi5oZWlnaHQgPSB0ZXhIZWlnaHQ7XG4gIHNwYW4uc3R5bGUuaGVpZ2h0ID0gc3BhbkhlaWdodCArIFwiZW1cIjtcbiAgcmV0dXJuIHtcbiAgICBzcGFuOiBzcGFuLFxuICAgIGFkdmFuY2VXaWR0aDogYWR2YW5jZVdpZHRoLFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgYWN0dWFsIGxpbmUgd2lkdGguXG4gICAgLy8gVGhpcyBhY3R1YWxseSBzaG91bGQgZGVwZW5kIG9uIHRoZSBjaG9zZW4gZm9udCAtLSBlLmcuIFxcYm9sZG1hdGhcbiAgICAvLyBzaG91bGQgdXNlIHRoZSB0aGlja2VyIHN1cmQgc3ltYm9scyBmcm9tIGUuZy4gS2FUZVhfTWFpbi1Cb2xkLCBhbmRcbiAgICAvLyBoYXZlIHRoaWNrZXIgcnVsZXMuXG4gICAgcnVsZVdpZHRoOiAob3B0aW9ucy5mb250TWV0cmljcygpLnNxcnRSdWxlVGhpY2tuZXNzICsgZXh0cmFWaW5pY3VsdW0pICogc2l6ZU11bHRpcGxpZXJcbiAgfTtcbn07IC8vIFRoZXJlIGFyZSB0aHJlZSBraW5kcyBvZiBkZWxpbWl0ZXJzLCBkZWxpbWl0ZXJzIHRoYXQgc3RhY2sgd2hlbiB0aGV5IGJlY29tZVxuLy8gdG9vIGxhcmdlXG5cblxudmFyIHN0YWNrTGFyZ2VEZWxpbWl0ZXJzID0gW1wiKFwiLCBcIlxcXFxscGFyZW5cIiwgXCIpXCIsIFwiXFxcXHJwYXJlblwiLCBcIltcIiwgXCJcXFxcbGJyYWNrXCIsIFwiXVwiLCBcIlxcXFxyYnJhY2tcIiwgXCJcXFxce1wiLCBcIlxcXFxsYnJhY2VcIiwgXCJcXFxcfVwiLCBcIlxcXFxyYnJhY2VcIiwgXCJcXFxcbGZsb29yXCIsIFwiXFxcXHJmbG9vclwiLCBcIlxcdTIzMEFcIiwgXCJcXHUyMzBCXCIsIFwiXFxcXGxjZWlsXCIsIFwiXFxcXHJjZWlsXCIsIFwiXFx1MjMwOFwiLCBcIlxcdTIzMDlcIiwgXCJcXFxcc3VyZFwiXTsgLy8gZGVsaW1pdGVycyB0aGF0IGFsd2F5cyBzdGFja1xuXG52YXIgc3RhY2tBbHdheXNEZWxpbWl0ZXJzID0gW1wiXFxcXHVwYXJyb3dcIiwgXCJcXFxcZG93bmFycm93XCIsIFwiXFxcXHVwZG93bmFycm93XCIsIFwiXFxcXFVwYXJyb3dcIiwgXCJcXFxcRG93bmFycm93XCIsIFwiXFxcXFVwZG93bmFycm93XCIsIFwifFwiLCBcIlxcXFx8XCIsIFwiXFxcXHZlcnRcIiwgXCJcXFxcVmVydFwiLCBcIlxcXFxsdmVydFwiLCBcIlxcXFxydmVydFwiLCBcIlxcXFxsVmVydFwiLCBcIlxcXFxyVmVydFwiLCBcIlxcXFxsZ3JvdXBcIiwgXCJcXFxccmdyb3VwXCIsIFwiXFx1MjdFRVwiLCBcIlxcdTI3RUZcIiwgXCJcXFxcbG1vdXN0YWNoZVwiLCBcIlxcXFxybW91c3RhY2hlXCIsIFwiXFx1MjNCMFwiLCBcIlxcdTIzQjFcIl07IC8vIGFuZCBkZWxpbWl0ZXJzIHRoYXQgbmV2ZXIgc3RhY2tcblxudmFyIHN0YWNrTmV2ZXJEZWxpbWl0ZXJzID0gW1wiPFwiLCBcIj5cIiwgXCJcXFxcbGFuZ2xlXCIsIFwiXFxcXHJhbmdsZVwiLCBcIi9cIiwgXCJcXFxcYmFja3NsYXNoXCIsIFwiXFxcXGx0XCIsIFwiXFxcXGd0XCJdOyAvLyBNZXRyaWNzIG9mIHRoZSBkaWZmZXJlbnQgc2l6ZXMuIEZvdW5kIGJ5IGxvb2tpbmcgYXQgVGVYJ3Mgb3V0cHV0IG9mXG4vLyAkXFxiaWdsfCAvLyBcXEJpZ2x8IFxcYmlnZ2x8IFxcQmlnZ2x8IFxcc2hvd2xpc3RzJFxuLy8gVXNlZCB0byBjcmVhdGUgc3RhY2tlZCBkZWxpbWl0ZXJzIG9mIGFwcHJvcHJpYXRlIHNpemVzIGluIG1ha2VTaXplZERlbGltLlxuXG52YXIgc2l6ZVRvTWF4SGVpZ2h0ID0gWzAsIDEuMiwgMS44LCAyLjQsIDMuMF07XG4vKipcbiAqIFVzZWQgdG8gY3JlYXRlIGEgZGVsaW1pdGVyIG9mIGEgc3BlY2lmaWMgc2l6ZSwgd2hlcmUgYHNpemVgIGlzIDEsIDIsIDMsIG9yIDQuXG4gKi9cblxudmFyIGRlbGltaXRlcl9tYWtlU2l6ZWREZWxpbSA9IGZ1bmN0aW9uIG1ha2VTaXplZERlbGltKGRlbGltLCBzaXplLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKSB7XG4gIC8vIDwgYW5kID4gdHVybiBpbnRvIFxcbGFuZ2xlIGFuZCBcXHJhbmdsZSBpbiBkZWxpbWl0ZXJzXG4gIGlmIChkZWxpbSA9PT0gXCI8XCIgfHwgZGVsaW0gPT09IFwiXFxcXGx0XCIgfHwgZGVsaW0gPT09IFwiXFx1MjdFOFwiKSB7XG4gICAgZGVsaW0gPSBcIlxcXFxsYW5nbGVcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCI+XCIgfHwgZGVsaW0gPT09IFwiXFxcXGd0XCIgfHwgZGVsaW0gPT09IFwiXFx1MjdFOVwiKSB7XG4gICAgZGVsaW0gPSBcIlxcXFxyYW5nbGVcIjtcbiAgfSAvLyBTaXplZCBkZWxpbWl0ZXJzIGFyZSBuZXZlciBjZW50ZXJlZC5cblxuXG4gIGlmICh1dGlscy5jb250YWlucyhzdGFja0xhcmdlRGVsaW1pdGVycywgZGVsaW0pIHx8IHV0aWxzLmNvbnRhaW5zKHN0YWNrTmV2ZXJEZWxpbWl0ZXJzLCBkZWxpbSkpIHtcbiAgICByZXR1cm4gZGVsaW1pdGVyX21ha2VMYXJnZURlbGltKGRlbGltLCBzaXplLCBmYWxzZSwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuY29udGFpbnMoc3RhY2tBbHdheXNEZWxpbWl0ZXJzLCBkZWxpbSkpIHtcbiAgICByZXR1cm4gZGVsaW1pdGVyX21ha2VTdGFja2VkRGVsaW0oZGVsaW0sIHNpemVUb01heEhlaWdodFtzaXplXSwgZmFsc2UsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIklsbGVnYWwgZGVsaW1pdGVyOiAnXCIgKyBkZWxpbSArIFwiJ1wiKTtcbiAgfVxufTtcbi8qKlxuICogVGhlcmUgYXJlIHRocmVlIGRpZmZlcmVudCBzZXF1ZW5jZXMgb2YgZGVsaW1pdGVyIHNpemVzIHRoYXQgdGhlIGRlbGltaXRlcnNcbiAqIGZvbGxvdyBkZXBlbmRpbmcgb24gdGhlIGtpbmQgb2YgZGVsaW1pdGVyLiBUaGlzIGlzIHVzZWQgd2hlbiBjcmVhdGluZyBjdXN0b21cbiAqIHNpemVkIGRlbGltaXRlcnMgdG8gZGVjaWRlIHdoZXRoZXIgdG8gY3JlYXRlIGEgc21hbGwsIGxhcmdlLCBvciBzdGFja2VkXG4gKiBkZWxpbWl0ZXIuXG4gKlxuICogSW4gcmVhbCBUZVgsIHRoZXNlIHNlcXVlbmNlcyBhcmVuJ3QgZXhwbGljaXRseSBkZWZpbmVkLCBidXQgYXJlIGluc3RlYWRcbiAqIGRlZmluZWQgaW5zaWRlIHRoZSBmb250IG1ldHJpY3MuIFNpbmNlIHRoZXJlIGFyZSBvbmx5IHRocmVlIHNlcXVlbmNlcyB0aGF0XG4gKiBhcmUgcG9zc2libGUgZm9yIHRoZSBkZWxpbWl0ZXJzIHRoYXQgVGVYIGRlZmluZXMsIGl0IGlzIGVhc2llciB0byBqdXN0IGVuY29kZVxuICogdGhlbSBleHBsaWNpdGx5IGhlcmUuXG4gKi9cblxuXG4vLyBEZWxpbWl0ZXJzIHRoYXQgbmV2ZXIgc3RhY2sgdHJ5IHNtYWxsIGRlbGltaXRlcnMgYW5kIGxhcmdlIGRlbGltaXRlcnMgb25seVxudmFyIHN0YWNrTmV2ZXJEZWxpbWl0ZXJTZXF1ZW5jZSA9IFt7XG4gIHR5cGU6IFwic21hbGxcIixcbiAgc3R5bGU6IHNyY19TdHlsZS5TQ1JJUFRTQ1JJUFRcbn0sIHtcbiAgdHlwZTogXCJzbWFsbFwiLFxuICBzdHlsZTogc3JjX1N0eWxlLlNDUklQVFxufSwge1xuICB0eXBlOiBcInNtYWxsXCIsXG4gIHN0eWxlOiBzcmNfU3R5bGUuVEVYVFxufSwge1xuICB0eXBlOiBcImxhcmdlXCIsXG4gIHNpemU6IDFcbn0sIHtcbiAgdHlwZTogXCJsYXJnZVwiLFxuICBzaXplOiAyXG59LCB7XG4gIHR5cGU6IFwibGFyZ2VcIixcbiAgc2l6ZTogM1xufSwge1xuICB0eXBlOiBcImxhcmdlXCIsXG4gIHNpemU6IDRcbn1dOyAvLyBEZWxpbWl0ZXJzIHRoYXQgYWx3YXlzIHN0YWNrIHRyeSB0aGUgc21hbGwgZGVsaW1pdGVycyBmaXJzdCwgdGhlbiBzdGFja1xuXG52YXIgc3RhY2tBbHdheXNEZWxpbWl0ZXJTZXF1ZW5jZSA9IFt7XG4gIHR5cGU6IFwic21hbGxcIixcbiAgc3R5bGU6IHNyY19TdHlsZS5TQ1JJUFRTQ1JJUFRcbn0sIHtcbiAgdHlwZTogXCJzbWFsbFwiLFxuICBzdHlsZTogc3JjX1N0eWxlLlNDUklQVFxufSwge1xuICB0eXBlOiBcInNtYWxsXCIsXG4gIHN0eWxlOiBzcmNfU3R5bGUuVEVYVFxufSwge1xuICB0eXBlOiBcInN0YWNrXCJcbn1dOyAvLyBEZWxpbWl0ZXJzIHRoYXQgc3RhY2sgd2hlbiBsYXJnZSB0cnkgdGhlIHNtYWxsIGFuZCB0aGVuIGxhcmdlIGRlbGltaXRlcnMsIGFuZFxuLy8gc3RhY2sgYWZ0ZXJ3YXJkc1xuXG52YXIgc3RhY2tMYXJnZURlbGltaXRlclNlcXVlbmNlID0gW3tcbiAgdHlwZTogXCJzbWFsbFwiLFxuICBzdHlsZTogc3JjX1N0eWxlLlNDUklQVFNDUklQVFxufSwge1xuICB0eXBlOiBcInNtYWxsXCIsXG4gIHN0eWxlOiBzcmNfU3R5bGUuU0NSSVBUXG59LCB7XG4gIHR5cGU6IFwic21hbGxcIixcbiAgc3R5bGU6IHNyY19TdHlsZS5URVhUXG59LCB7XG4gIHR5cGU6IFwibGFyZ2VcIixcbiAgc2l6ZTogMVxufSwge1xuICB0eXBlOiBcImxhcmdlXCIsXG4gIHNpemU6IDJcbn0sIHtcbiAgdHlwZTogXCJsYXJnZVwiLFxuICBzaXplOiAzXG59LCB7XG4gIHR5cGU6IFwibGFyZ2VcIixcbiAgc2l6ZTogNFxufSwge1xuICB0eXBlOiBcInN0YWNrXCJcbn1dO1xuLyoqXG4gKiBHZXQgdGhlIGZvbnQgdXNlZCBpbiBhIGRlbGltaXRlciBiYXNlZCBvbiB3aGF0IGtpbmQgb2YgZGVsaW1pdGVyIGl0IGlzLlxuICogVE9ETygjOTYzKSBVc2UgbW9yZSBzcGVjaWZpYyBmb250IGZhbWlseSByZXR1cm4gdHlwZSBvbmNlIHRoYXQgaXMgaW50cm9kdWNlZC5cbiAqL1xuXG52YXIgZGVsaW1UeXBlVG9Gb250ID0gZnVuY3Rpb24gZGVsaW1UeXBlVG9Gb250KHR5cGUpIHtcbiAgaWYgKHR5cGUudHlwZSA9PT0gXCJzbWFsbFwiKSB7XG4gICAgcmV0dXJuIFwiTWFpbi1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAodHlwZS50eXBlID09PSBcImxhcmdlXCIpIHtcbiAgICByZXR1cm4gXCJTaXplXCIgKyB0eXBlLnNpemUgKyBcIi1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAodHlwZS50eXBlID09PSBcInN0YWNrXCIpIHtcbiAgICByZXR1cm4gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQWRkIHN1cHBvcnQgZm9yIGRlbGltIHR5cGUgJ1wiICsgdHlwZS50eXBlICsgXCInIGhlcmUuXCIpO1xuICB9XG59O1xuLyoqXG4gKiBUcmF2ZXJzZSBhIHNlcXVlbmNlIG9mIHR5cGVzIG9mIGRlbGltaXRlcnMgdG8gZGVjaWRlIHdoYXQga2luZCBvZiBkZWxpbWl0ZXJcbiAqIHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBhIGRlbGltaXRlciBvZiB0aGUgZ2l2ZW4gaGVpZ2h0K2RlcHRoLlxuICovXG5cblxudmFyIHRyYXZlcnNlU2VxdWVuY2UgPSBmdW5jdGlvbiB0cmF2ZXJzZVNlcXVlbmNlKGRlbGltLCBoZWlnaHQsIHNlcXVlbmNlLCBvcHRpb25zKSB7XG4gIC8vIEhlcmUsIHdlIGNob29zZSB0aGUgaW5kZXggd2Ugc2hvdWxkIHN0YXJ0IGF0IGluIHRoZSBzZXF1ZW5jZXMuIEluIHNtYWxsZXJcbiAgLy8gc2l6ZXMgKHdoaWNoIGNvcnJlc3BvbmQgdG8gbGFyZ2VyIG51bWJlcnMgaW4gc3R5bGUuc2l6ZSkgd2Ugc3RhcnQgZWFybGllclxuICAvLyBpbiB0aGUgc2VxdWVuY2UuIFRodXMsIHNjcmlwdHNjcmlwdCBzdGFydHMgYXQgaW5kZXggMy0zPTAsIHNjcmlwdCBzdGFydHNcbiAgLy8gYXQgaW5kZXggMy0yPTEsIHRleHQgc3RhcnRzIGF0IDMtMT0yLCBhbmQgZGlzcGxheSBzdGFydHMgYXQgbWluKDIsMy0wKT0yXG4gIHZhciBzdGFydCA9IE1hdGgubWluKDIsIDMgLSBvcHRpb25zLnN0eWxlLnNpemUpO1xuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IHNlcXVlbmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHNlcXVlbmNlW2ldLnR5cGUgPT09IFwic3RhY2tcIikge1xuICAgICAgLy8gVGhpcyBpcyBhbHdheXMgdGhlIGxhc3QgZGVsaW1pdGVyLCBzbyB3ZSBqdXN0IGJyZWFrIHRoZSBsb29wIG5vdy5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBtZXRyaWNzID0gZGVsaW1pdGVyX2dldE1ldHJpY3MoZGVsaW0sIGRlbGltVHlwZVRvRm9udChzZXF1ZW5jZVtpXSksIFwibWF0aFwiKTtcbiAgICB2YXIgaGVpZ2h0RGVwdGggPSBtZXRyaWNzLmhlaWdodCArIG1ldHJpY3MuZGVwdGg7IC8vIFNtYWxsIGRlbGltaXRlcnMgYXJlIHNjYWxlZCBkb3duIHZlcnNpb25zIG9mIHRoZSBzYW1lIGZvbnQsIHNvIHdlXG4gICAgLy8gYWNjb3VudCBmb3IgdGhlIHN0eWxlIGNoYW5nZSBzaXplLlxuXG4gICAgaWYgKHNlcXVlbmNlW2ldLnR5cGUgPT09IFwic21hbGxcIikge1xuICAgICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ0Jhc2VTdHlsZShzZXF1ZW5jZVtpXS5zdHlsZSk7XG4gICAgICBoZWlnaHREZXB0aCAqPSBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICAgIH0gLy8gQ2hlY2sgaWYgdGhlIGRlbGltaXRlciBhdCB0aGlzIHNpemUgd29ya3MgZm9yIHRoZSBnaXZlbiBoZWlnaHQuXG5cblxuICAgIGlmIChoZWlnaHREZXB0aCA+IGhlaWdodCkge1xuICAgICAgcmV0dXJuIHNlcXVlbmNlW2ldO1xuICAgIH1cbiAgfSAvLyBJZiB3ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLCByZXR1cm4gdGhlIGxhc3Qgc2VxdWVuY2UgZWxlbWVudC5cblxuXG4gIHJldHVybiBzZXF1ZW5jZVtzZXF1ZW5jZS5sZW5ndGggLSAxXTtcbn07XG4vKipcbiAqIE1ha2UgYSBkZWxpbWl0ZXIgb2YgYSBnaXZlbiBoZWlnaHQrZGVwdGgsIHdpdGggb3B0aW9uYWwgY2VudGVyaW5nLiBIZXJlLCB3ZVxuICogdHJhdmVyc2UgdGhlIHNlcXVlbmNlcywgYW5kIGNyZWF0ZSBhIGRlbGltaXRlciB0aGF0IHRoZSBzZXF1ZW5jZSB0ZWxscyB1cyB0by5cbiAqL1xuXG5cbnZhciBkZWxpbWl0ZXJfbWFrZUN1c3RvbVNpemVkRGVsaW0gPSBmdW5jdGlvbiBtYWtlQ3VzdG9tU2l6ZWREZWxpbShkZWxpbSwgaGVpZ2h0LCBjZW50ZXIsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpIHtcbiAgaWYgKGRlbGltID09PSBcIjxcIiB8fCBkZWxpbSA9PT0gXCJcXFxcbHRcIiB8fCBkZWxpbSA9PT0gXCJcXHUyN0U4XCIpIHtcbiAgICBkZWxpbSA9IFwiXFxcXGxhbmdsZVwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIj5cIiB8fCBkZWxpbSA9PT0gXCJcXFxcZ3RcIiB8fCBkZWxpbSA9PT0gXCJcXHUyN0U5XCIpIHtcbiAgICBkZWxpbSA9IFwiXFxcXHJhbmdsZVwiO1xuICB9IC8vIERlY2lkZSB3aGF0IHNlcXVlbmNlIHRvIHVzZVxuXG5cbiAgdmFyIHNlcXVlbmNlO1xuXG4gIGlmICh1dGlscy5jb250YWlucyhzdGFja05ldmVyRGVsaW1pdGVycywgZGVsaW0pKSB7XG4gICAgc2VxdWVuY2UgPSBzdGFja05ldmVyRGVsaW1pdGVyU2VxdWVuY2U7XG4gIH0gZWxzZSBpZiAodXRpbHMuY29udGFpbnMoc3RhY2tMYXJnZURlbGltaXRlcnMsIGRlbGltKSkge1xuICAgIHNlcXVlbmNlID0gc3RhY2tMYXJnZURlbGltaXRlclNlcXVlbmNlO1xuICB9IGVsc2Uge1xuICAgIHNlcXVlbmNlID0gc3RhY2tBbHdheXNEZWxpbWl0ZXJTZXF1ZW5jZTtcbiAgfSAvLyBMb29rIHRocm91Z2ggdGhlIHNlcXVlbmNlXG5cblxuICB2YXIgZGVsaW1UeXBlID0gdHJhdmVyc2VTZXF1ZW5jZShkZWxpbSwgaGVpZ2h0LCBzZXF1ZW5jZSwgb3B0aW9ucyk7IC8vIEdldCB0aGUgZGVsaW1pdGVyIGZyb20gZm9udCBnbHlwaHMuXG4gIC8vIERlcGVuZGluZyBvbiB0aGUgc2VxdWVuY2UgZWxlbWVudCB3ZSBkZWNpZGVkIG9uLCBjYWxsIHRoZVxuICAvLyBhcHByb3ByaWF0ZSBmdW5jdGlvbi5cblxuICBpZiAoZGVsaW1UeXBlLnR5cGUgPT09IFwic21hbGxcIikge1xuICAgIHJldHVybiBkZWxpbWl0ZXJfbWFrZVNtYWxsRGVsaW0oZGVsaW0sIGRlbGltVHlwZS5zdHlsZSwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKTtcbiAgfSBlbHNlIGlmIChkZWxpbVR5cGUudHlwZSA9PT0gXCJsYXJnZVwiKSB7XG4gICAgcmV0dXJuIGRlbGltaXRlcl9tYWtlTGFyZ2VEZWxpbShkZWxpbSwgZGVsaW1UeXBlLnNpemUsIGNlbnRlciwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcyk7XG4gIH0gZWxzZVxuICAgIC8qIGlmIChkZWxpbVR5cGUudHlwZSA9PT0gXCJzdGFja1wiKSAqL1xuICAgIHtcbiAgICAgIHJldHVybiBkZWxpbWl0ZXJfbWFrZVN0YWNrZWREZWxpbShkZWxpbSwgaGVpZ2h0LCBjZW50ZXIsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpO1xuICAgIH1cbn07XG4vKipcbiAqIE1ha2UgYSBkZWxpbWl0ZXIgZm9yIHVzZSB3aXRoIGBcXGxlZnRgIGFuZCBgXFxyaWdodGAsIGdpdmVuIGEgaGVpZ2h0IGFuZCBkZXB0aFxuICogb2YgYW4gZXhwcmVzc2lvbiB0aGF0IHRoZSBkZWxpbWl0ZXJzIHN1cnJvdW5kLlxuICovXG5cblxudmFyIG1ha2VMZWZ0UmlnaHREZWxpbSA9IGZ1bmN0aW9uIG1ha2VMZWZ0UmlnaHREZWxpbShkZWxpbSwgaGVpZ2h0LCBkZXB0aCwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcykge1xuICAvLyBXZSBhbHdheXMgY2VudGVyIFxcbGVmdC9cXHJpZ2h0IGRlbGltaXRlcnMsIHNvIHRoZSBheGlzIGlzIGFsd2F5cyBzaGlmdGVkXG4gIHZhciBheGlzSGVpZ2h0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLmF4aXNIZWlnaHQgKiBvcHRpb25zLnNpemVNdWx0aXBsaWVyOyAvLyBUYWtlbiBmcm9tIFRlWCBzb3VyY2UsIHRleC53ZWIsIGZ1bmN0aW9uIG1ha2VfbGVmdF9yaWdodFxuXG4gIHZhciBkZWxpbWl0ZXJGYWN0b3IgPSA5MDE7XG4gIHZhciBkZWxpbWl0ZXJFeHRlbmQgPSA1LjAgLyBvcHRpb25zLmZvbnRNZXRyaWNzKCkucHRQZXJFbTtcbiAgdmFyIG1heERpc3RGcm9tQXhpcyA9IE1hdGgubWF4KGhlaWdodCAtIGF4aXNIZWlnaHQsIGRlcHRoICsgYXhpc0hlaWdodCk7XG4gIHZhciB0b3RhbEhlaWdodCA9IE1hdGgubWF4KCAvLyBJbiByZWFsIFRlWCwgY2FsY3VsYXRpb25zIGFyZSBkb25lIHVzaW5nIGludGVncmFsIHZhbHVlcyB3aGljaCBhcmVcbiAgLy8gNjU1MzYgcGVyIHB0LCBvciA2NTUzNjAgcGVyIGVtLiBTbywgdGhlIGRpdmlzaW9uIGhlcmUgdHJ1bmNhdGVzIGluXG4gIC8vIFRlWCBidXQgZG9lc24ndCBoZXJlLCBwcm9kdWNpbmcgZGlmZmVyZW50IHJlc3VsdHMuIElmIHdlIHdhbnRlZCB0b1xuICAvLyBleGFjdGx5IG1hdGNoIFRlWCdzIGNhbGN1bGF0aW9uLCB3ZSBjb3VsZCBkb1xuICAvLyAgIE1hdGguZmxvb3IoNjU1MzYwICogbWF4RGlzdEZyb21BeGlzIC8gNTAwKSAqXG4gIC8vICAgIGRlbGltaXRlckZhY3RvciAvIDY1NTM2MFxuICAvLyAoVG8gc2VlIHRoZSBkaWZmZXJlbmNlLCBjb21wYXJlXG4gIC8vICAgIHhee3hee1xcbGVmdChcXHJ1bGV7MC4xZW19ezAuNjhlbX1cXHJpZ2h0KX19XG4gIC8vIGluIFRlWCBhbmQgS2FUZVgpXG4gIG1heERpc3RGcm9tQXhpcyAvIDUwMCAqIGRlbGltaXRlckZhY3RvciwgMiAqIG1heERpc3RGcm9tQXhpcyAtIGRlbGltaXRlckV4dGVuZCk7IC8vIEZpbmFsbHksIHdlIGRlZmVyIHRvIGBtYWtlQ3VzdG9tU2l6ZWREZWxpbWAgd2l0aCBvdXIgY2FsY3VsYXRlZCB0b3RhbFxuICAvLyBoZWlnaHRcblxuICByZXR1cm4gZGVsaW1pdGVyX21ha2VDdXN0b21TaXplZERlbGltKGRlbGltLCB0b3RhbEhlaWdodCwgdHJ1ZSwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcyk7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBkZWxpbWl0ZXIgPSAoe1xuICBzcXJ0SW1hZ2U6IG1ha2VTcXJ0SW1hZ2UsXG4gIHNpemVkRGVsaW06IGRlbGltaXRlcl9tYWtlU2l6ZWREZWxpbSxcbiAgY3VzdG9tU2l6ZWREZWxpbTogZGVsaW1pdGVyX21ha2VDdXN0b21TaXplZERlbGltLFxuICBsZWZ0UmlnaHREZWxpbTogbWFrZUxlZnRSaWdodERlbGltXG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9kZWxpbXNpemluZy5qc1xuXG5cblxuXG5cblxuXG5cblxuLy8gRXh0cmEgZGF0YSBuZWVkZWQgZm9yIHRoZSBkZWxpbWl0ZXIgaGFuZGxlciBkb3duIGJlbG93XG52YXIgZGVsaW1pdGVyU2l6ZXMgPSB7XG4gIFwiXFxcXGJpZ2xcIjoge1xuICAgIG1jbGFzczogXCJtb3BlblwiLFxuICAgIHNpemU6IDFcbiAgfSxcbiAgXCJcXFxcQmlnbFwiOiB7XG4gICAgbWNsYXNzOiBcIm1vcGVuXCIsXG4gICAgc2l6ZTogMlxuICB9LFxuICBcIlxcXFxiaWdnbFwiOiB7XG4gICAgbWNsYXNzOiBcIm1vcGVuXCIsXG4gICAgc2l6ZTogM1xuICB9LFxuICBcIlxcXFxCaWdnbFwiOiB7XG4gICAgbWNsYXNzOiBcIm1vcGVuXCIsXG4gICAgc2l6ZTogNFxuICB9LFxuICBcIlxcXFxiaWdyXCI6IHtcbiAgICBtY2xhc3M6IFwibWNsb3NlXCIsXG4gICAgc2l6ZTogMVxuICB9LFxuICBcIlxcXFxCaWdyXCI6IHtcbiAgICBtY2xhc3M6IFwibWNsb3NlXCIsXG4gICAgc2l6ZTogMlxuICB9LFxuICBcIlxcXFxiaWdnclwiOiB7XG4gICAgbWNsYXNzOiBcIm1jbG9zZVwiLFxuICAgIHNpemU6IDNcbiAgfSxcbiAgXCJcXFxcQmlnZ3JcIjoge1xuICAgIG1jbGFzczogXCJtY2xvc2VcIixcbiAgICBzaXplOiA0XG4gIH0sXG4gIFwiXFxcXGJpZ21cIjoge1xuICAgIG1jbGFzczogXCJtcmVsXCIsXG4gICAgc2l6ZTogMVxuICB9LFxuICBcIlxcXFxCaWdtXCI6IHtcbiAgICBtY2xhc3M6IFwibXJlbFwiLFxuICAgIHNpemU6IDJcbiAgfSxcbiAgXCJcXFxcYmlnZ21cIjoge1xuICAgIG1jbGFzczogXCJtcmVsXCIsXG4gICAgc2l6ZTogM1xuICB9LFxuICBcIlxcXFxCaWdnbVwiOiB7XG4gICAgbWNsYXNzOiBcIm1yZWxcIixcbiAgICBzaXplOiA0XG4gIH0sXG4gIFwiXFxcXGJpZ1wiOiB7XG4gICAgbWNsYXNzOiBcIm1vcmRcIixcbiAgICBzaXplOiAxXG4gIH0sXG4gIFwiXFxcXEJpZ1wiOiB7XG4gICAgbWNsYXNzOiBcIm1vcmRcIixcbiAgICBzaXplOiAyXG4gIH0sXG4gIFwiXFxcXGJpZ2dcIjoge1xuICAgIG1jbGFzczogXCJtb3JkXCIsXG4gICAgc2l6ZTogM1xuICB9LFxuICBcIlxcXFxCaWdnXCI6IHtcbiAgICBtY2xhc3M6IFwibW9yZFwiLFxuICAgIHNpemU6IDRcbiAgfVxufTtcbnZhciBkZWxpbWl0ZXJzID0gW1wiKFwiLCBcIlxcXFxscGFyZW5cIiwgXCIpXCIsIFwiXFxcXHJwYXJlblwiLCBcIltcIiwgXCJcXFxcbGJyYWNrXCIsIFwiXVwiLCBcIlxcXFxyYnJhY2tcIiwgXCJcXFxce1wiLCBcIlxcXFxsYnJhY2VcIiwgXCJcXFxcfVwiLCBcIlxcXFxyYnJhY2VcIiwgXCJcXFxcbGZsb29yXCIsIFwiXFxcXHJmbG9vclwiLCBcIlxcdTIzMEFcIiwgXCJcXHUyMzBCXCIsIFwiXFxcXGxjZWlsXCIsIFwiXFxcXHJjZWlsXCIsIFwiXFx1MjMwOFwiLCBcIlxcdTIzMDlcIiwgXCI8XCIsIFwiPlwiLCBcIlxcXFxsYW5nbGVcIiwgXCJcXHUyN0U4XCIsIFwiXFxcXHJhbmdsZVwiLCBcIlxcdTI3RTlcIiwgXCJcXFxcbHRcIiwgXCJcXFxcZ3RcIiwgXCJcXFxcbHZlcnRcIiwgXCJcXFxccnZlcnRcIiwgXCJcXFxcbFZlcnRcIiwgXCJcXFxcclZlcnRcIiwgXCJcXFxcbGdyb3VwXCIsIFwiXFxcXHJncm91cFwiLCBcIlxcdTI3RUVcIiwgXCJcXHUyN0VGXCIsIFwiXFxcXGxtb3VzdGFjaGVcIiwgXCJcXFxccm1vdXN0YWNoZVwiLCBcIlxcdTIzQjBcIiwgXCJcXHUyM0IxXCIsIFwiL1wiLCBcIlxcXFxiYWNrc2xhc2hcIiwgXCJ8XCIsIFwiXFxcXHZlcnRcIiwgXCJcXFxcfFwiLCBcIlxcXFxWZXJ0XCIsIFwiXFxcXHVwYXJyb3dcIiwgXCJcXFxcVXBhcnJvd1wiLCBcIlxcXFxkb3duYXJyb3dcIiwgXCJcXFxcRG93bmFycm93XCIsIFwiXFxcXHVwZG93bmFycm93XCIsIFwiXFxcXFVwZG93bmFycm93XCIsIFwiLlwiXTtcblxuLy8gRGVsaW1pdGVyIGZ1bmN0aW9uc1xuZnVuY3Rpb24gY2hlY2tEZWxpbWl0ZXIoZGVsaW0sIGNvbnRleHQpIHtcbiAgdmFyIHN5bURlbGltID0gY2hlY2tTeW1ib2xOb2RlVHlwZShkZWxpbSk7XG5cbiAgaWYgKHN5bURlbGltICYmIHV0aWxzLmNvbnRhaW5zKGRlbGltaXRlcnMsIHN5bURlbGltLnRleHQpKSB7XG4gICAgcmV0dXJuIHN5bURlbGltO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgZGVsaW1pdGVyOiAnXCIgKyAoc3ltRGVsaW0gPyBzeW1EZWxpbS50ZXh0IDogSlNPTi5zdHJpbmdpZnkoZGVsaW0pKSArIFwiJyBhZnRlciAnXCIgKyBjb250ZXh0LmZ1bmNOYW1lICsgXCInXCIsIGRlbGltKTtcbiAgfVxufVxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZGVsaW1zaXppbmdcIixcbiAgbmFtZXM6IFtcIlxcXFxiaWdsXCIsIFwiXFxcXEJpZ2xcIiwgXCJcXFxcYmlnZ2xcIiwgXCJcXFxcQmlnZ2xcIiwgXCJcXFxcYmlnclwiLCBcIlxcXFxCaWdyXCIsIFwiXFxcXGJpZ2dyXCIsIFwiXFxcXEJpZ2dyXCIsIFwiXFxcXGJpZ21cIiwgXCJcXFxcQmlnbVwiLCBcIlxcXFxiaWdnbVwiLCBcIlxcXFxCaWdnbVwiLCBcIlxcXFxiaWdcIiwgXCJcXFxcQmlnXCIsIFwiXFxcXGJpZ2dcIiwgXCJcXFxcQmlnZ1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoY29udGV4dCwgYXJncykge1xuICAgIHZhciBkZWxpbSA9IGNoZWNrRGVsaW1pdGVyKGFyZ3NbMF0sIGNvbnRleHQpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImRlbGltc2l6aW5nXCIsXG4gICAgICBtb2RlOiBjb250ZXh0LnBhcnNlci5tb2RlLFxuICAgICAgc2l6ZTogZGVsaW1pdGVyU2l6ZXNbY29udGV4dC5mdW5jTmFtZV0uc2l6ZSxcbiAgICAgIG1jbGFzczogZGVsaW1pdGVyU2l6ZXNbY29udGV4dC5mdW5jTmFtZV0ubWNsYXNzLFxuICAgICAgZGVsaW06IGRlbGltLnRleHRcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBpZiAoZ3JvdXAuZGVsaW0gPT09IFwiLlwiKSB7XG4gICAgICAvLyBFbXB0eSBkZWxpbWl0ZXJzIHN0aWxsIGNvdW50IGFzIGVsZW1lbnRzLCBldmVuIHRob3VnaCB0aGV5IGRvbid0XG4gICAgICAvLyBzaG93IGFueXRoaW5nLlxuICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtncm91cC5tY2xhc3NdKTtcbiAgICB9IC8vIFVzZSBkZWxpbWl0ZXIuc2l6ZWREZWxpbSB0byBnZW5lcmF0ZSB0aGUgZGVsaW1pdGVyLlxuXG5cbiAgICByZXR1cm4gZGVsaW1pdGVyLnNpemVkRGVsaW0oZ3JvdXAuZGVsaW0sIGdyb3VwLnNpemUsIG9wdGlvbnMsIGdyb3VwLm1vZGUsIFtncm91cC5tY2xhc3NdKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCkge1xuICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuXG4gICAgaWYgKGdyb3VwLmRlbGltICE9PSBcIi5cIikge1xuICAgICAgY2hpbGRyZW4ucHVzaChidWlsZE1hdGhNTF9tYWtlVGV4dChncm91cC5kZWxpbSwgZ3JvdXAubW9kZSkpO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBjaGlsZHJlbik7XG5cbiAgICBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1vcGVuXCIgfHwgZ3JvdXAubWNsYXNzID09PSBcIm1jbG9zZVwiKSB7XG4gICAgICAvLyBPbmx5IHNvbWUgb2YgdGhlIGRlbGltc2l6aW5nIGZ1bmN0aW9ucyBhY3QgYXMgZmVuY2VzLCBhbmQgdGhleVxuICAgICAgLy8gcmV0dXJuIFwibW9wZW5cIiBvciBcIm1jbG9zZVwiIG1jbGFzcy5cbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFeHBsaWNpdGx5IGRpc2FibGUgZmVuY2luZyBpZiBpdCdzIG5vdCBhIGZlbmNlLCB0byBvdmVycmlkZSB0aGVcbiAgICAgIC8vIGRlZmF1bHRzLlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcImZhbHNlXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcblxuZnVuY3Rpb24gYXNzZXJ0UGFyc2VkKGdyb3VwKSB7XG4gIGlmICghZ3JvdXAuYm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZzogVGhlIGxlZnRyaWdodCBQYXJzZU5vZGUgd2Fzbid0IGZ1bGx5IHBhcnNlZC5cIik7XG4gIH1cbn1cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImxlZnRyaWdodC1yaWdodFwiLFxuICBuYW1lczogW1wiXFxcXHJpZ2h0XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihjb250ZXh0LCBhcmdzKSB7XG4gICAgLy8gXFxsZWZ0IGNhc2UgYmVsb3cgdHJpZ2dlcnMgcGFyc2luZyBvZiBcXHJpZ2h0IGluXG4gICAgLy8gICBgY29uc3QgcmlnaHQgPSBwYXJzZXIucGFyc2VGdW5jdGlvbigpO2BcbiAgICAvLyB1c2VzIHRoaXMgcmV0dXJuIHZhbHVlLlxuICAgIHZhciBjb2xvciA9IGNvbnRleHQucGFyc2VyLmd1bGxldC5tYWNyb3MuZ2V0KFwiXFxcXGN1cnJlbnRAY29sb3JcIik7XG5cbiAgICBpZiAoY29sb3IgJiYgdHlwZW9mIGNvbG9yICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJcXFxcY3VycmVudEBjb2xvciBzZXQgdG8gbm9uLXN0cmluZyBpbiBcXFxccmlnaHRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibGVmdHJpZ2h0LXJpZ2h0XCIsXG4gICAgICBtb2RlOiBjb250ZXh0LnBhcnNlci5tb2RlLFxuICAgICAgZGVsaW06IGNoZWNrRGVsaW1pdGVyKGFyZ3NbMF0sIGNvbnRleHQpLnRleHQsXG4gICAgICBjb2xvcjogY29sb3IgLy8gdW5kZWZpbmVkIGlmIG5vdCBzZXQgdmlhIFxcY29sb3JcblxuICAgIH07XG4gIH1cbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICBuYW1lczogW1wiXFxcXGxlZnRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgZGVsaW0gPSBjaGVja0RlbGltaXRlcihhcmdzWzBdLCBjb250ZXh0KTtcbiAgICB2YXIgcGFyc2VyID0gY29udGV4dC5wYXJzZXI7IC8vIFBhcnNlIG91dCB0aGUgaW1wbGljaXQgYm9keVxuXG4gICAgKytwYXJzZXIubGVmdHJpZ2h0RGVwdGg7IC8vIHBhcnNlRXhwcmVzc2lvbiBzdG9wcyBiZWZvcmUgJ1xcXFxyaWdodCdcblxuICAgIHZhciBib2R5ID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbihmYWxzZSk7XG4gICAgLS1wYXJzZXIubGVmdHJpZ2h0RGVwdGg7IC8vIENoZWNrIHRoZSBuZXh0IHRva2VuXG5cbiAgICBwYXJzZXIuZXhwZWN0KFwiXFxcXHJpZ2h0XCIsIGZhbHNlKTtcbiAgICB2YXIgcmlnaHQgPSBhc3NlcnROb2RlVHlwZShwYXJzZXIucGFyc2VGdW5jdGlvbigpLCBcImxlZnRyaWdodC1yaWdodFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsZWZ0cmlnaHRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keTogYm9keSxcbiAgICAgIGxlZnQ6IGRlbGltLnRleHQsXG4gICAgICByaWdodDogcmlnaHQuZGVsaW0sXG4gICAgICByaWdodENvbG9yOiByaWdodC5jb2xvclxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGFzc2VydFBhcnNlZChncm91cCk7IC8vIEJ1aWxkIHRoZSBpbm5lciBleHByZXNzaW9uXG5cbiAgICB2YXIgaW5uZXIgPSBidWlsZEhUTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMsIHRydWUsIFtcIm1vcGVuXCIsIFwibWNsb3NlXCJdKTtcbiAgICB2YXIgaW5uZXJIZWlnaHQgPSAwO1xuICAgIHZhciBpbm5lckRlcHRoID0gMDtcbiAgICB2YXIgaGFkTWlkZGxlID0gZmFsc2U7IC8vIENhbGN1bGF0ZSBpdHMgaGVpZ2h0IGFuZCBkZXB0aFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbm5lci5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gUHJvcGVydHkgYGlzTWlkZGxlYCBub3QgZGVmaW5lZCBvbiBgc3BhbmAuIFNlZSBjb21tZW50IGluXG4gICAgICAvLyBcIm1pZGRsZVwiJ3MgaHRtbEJ1aWxkZXIuXG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICBpZiAoaW5uZXJbaV0uaXNNaWRkbGUpIHtcbiAgICAgICAgaGFkTWlkZGxlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlubmVySGVpZ2h0ID0gTWF0aC5tYXgoaW5uZXJbaV0uaGVpZ2h0LCBpbm5lckhlaWdodCk7XG4gICAgICAgIGlubmVyRGVwdGggPSBNYXRoLm1heChpbm5lcltpXS5kZXB0aCwgaW5uZXJEZXB0aCk7XG4gICAgICB9XG4gICAgfSAvLyBUaGUgc2l6ZSBvZiBkZWxpbWl0ZXJzIGlzIHRoZSBzYW1lLCByZWdhcmRsZXNzIG9mIHdoYXQgc3R5bGUgd2UgYXJlXG4gICAgLy8gaW4uIFRodXMsIHRvIGNvcnJlY3RseSBjYWxjdWxhdGUgdGhlIHNpemUgb2YgZGVsaW1pdGVyIHdlIG5lZWQgYXJvdW5kXG4gICAgLy8gYSBncm91cCwgd2Ugc2NhbGUgZG93biB0aGUgaW5uZXIgc2l6ZSBiYXNlZCBvbiB0aGUgc2l6ZS5cblxuXG4gICAgaW5uZXJIZWlnaHQgKj0gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgICBpbm5lckRlcHRoICo9IG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gICAgdmFyIGxlZnREZWxpbTtcblxuICAgIGlmIChncm91cC5sZWZ0ID09PSBcIi5cIikge1xuICAgICAgLy8gRW1wdHkgZGVsaW1pdGVycyBpbiBcXGxlZnQgYW5kIFxccmlnaHQgbWFrZSBudWxsIGRlbGltaXRlciBzcGFjZXMuXG4gICAgICBsZWZ0RGVsaW0gPSBtYWtlTnVsbERlbGltaXRlcihvcHRpb25zLCBbXCJtb3BlblwiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgdXNlIGxlZnRSaWdodERlbGltIHRvIGdlbmVyYXRlIHRoZSBjb3JyZWN0IHNpemVkXG4gICAgICAvLyBkZWxpbWl0ZXIuXG4gICAgICBsZWZ0RGVsaW0gPSBkZWxpbWl0ZXIubGVmdFJpZ2h0RGVsaW0oZ3JvdXAubGVmdCwgaW5uZXJIZWlnaHQsIGlubmVyRGVwdGgsIG9wdGlvbnMsIGdyb3VwLm1vZGUsIFtcIm1vcGVuXCJdKTtcbiAgICB9IC8vIEFkZCBpdCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBleHByZXNzaW9uXG5cblxuICAgIGlubmVyLnVuc2hpZnQobGVmdERlbGltKTsgLy8gSGFuZGxlIG1pZGRsZSBkZWxpbWl0ZXJzXG5cbiAgICBpZiAoaGFkTWlkZGxlKSB7XG4gICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgaW5uZXIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBtaWRkbGVEZWxpbSA9IGlubmVyW19pXTsgLy8gUHJvcGVydHkgYGlzTWlkZGxlYCBub3QgZGVmaW5lZCBvbiBgc3BhbmAuIFNlZSBjb21tZW50IGluXG4gICAgICAgIC8vIFwibWlkZGxlXCIncyBodG1sQnVpbGRlci5cbiAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgIHZhciBpc01pZGRsZSA9IG1pZGRsZURlbGltLmlzTWlkZGxlO1xuXG4gICAgICAgIGlmIChpc01pZGRsZSkge1xuICAgICAgICAgIC8vIEFwcGx5IHRoZSBvcHRpb25zIHRoYXQgd2VyZSBhY3RpdmUgd2hlbiBcXG1pZGRsZSB3YXMgY2FsbGVkXG4gICAgICAgICAgaW5uZXJbX2ldID0gZGVsaW1pdGVyLmxlZnRSaWdodERlbGltKGlzTWlkZGxlLmRlbGltLCBpbm5lckhlaWdodCwgaW5uZXJEZXB0aCwgaXNNaWRkbGUub3B0aW9ucywgZ3JvdXAubW9kZSwgW10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJpZ2h0RGVsaW07IC8vIFNhbWUgZm9yIHRoZSByaWdodCBkZWxpbWl0ZXIsIGJ1dCB1c2luZyBjb2xvciBzcGVjaWZpZWQgYnkgXFxjb2xvclxuXG4gICAgaWYgKGdyb3VwLnJpZ2h0ID09PSBcIi5cIikge1xuICAgICAgcmlnaHREZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtcIm1jbG9zZVwiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb2xvck9wdGlvbnMgPSBncm91cC5yaWdodENvbG9yID8gb3B0aW9ucy53aXRoQ29sb3IoZ3JvdXAucmlnaHRDb2xvcikgOiBvcHRpb25zO1xuICAgICAgcmlnaHREZWxpbSA9IGRlbGltaXRlci5sZWZ0UmlnaHREZWxpbShncm91cC5yaWdodCwgaW5uZXJIZWlnaHQsIGlubmVyRGVwdGgsIGNvbG9yT3B0aW9ucywgZ3JvdXAubW9kZSwgW1wibWNsb3NlXCJdKTtcbiAgICB9IC8vIEFkZCBpdCB0byB0aGUgZW5kIG9mIHRoZSBleHByZXNzaW9uLlxuXG5cbiAgICBpbm5lci5wdXNoKHJpZ2h0RGVsaW0pO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtaW5uZXJcIl0sIGlubmVyLCBvcHRpb25zKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGFzc2VydFBhcnNlZChncm91cCk7XG4gICAgdmFyIGlubmVyID0gYnVpbGRNYXRoTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMpO1xuXG4gICAgaWYgKGdyb3VwLmxlZnQgIT09IFwiLlwiKSB7XG4gICAgICB2YXIgbGVmdE5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFtidWlsZE1hdGhNTF9tYWtlVGV4dChncm91cC5sZWZ0LCBncm91cC5tb2RlKV0pO1xuICAgICAgbGVmdE5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgICAgaW5uZXIudW5zaGlmdChsZWZ0Tm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnJpZ2h0ICE9PSBcIi5cIikge1xuICAgICAgdmFyIHJpZ2h0Tm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW2J1aWxkTWF0aE1MX21ha2VUZXh0KGdyb3VwLnJpZ2h0LCBncm91cC5tb2RlKV0pO1xuICAgICAgcmlnaHROb2RlLnNldEF0dHJpYnV0ZShcImZlbmNlXCIsIFwidHJ1ZVwiKTtcblxuICAgICAgaWYgKGdyb3VwLnJpZ2h0Q29sb3IpIHtcbiAgICAgICAgcmlnaHROb2RlLnNldEF0dHJpYnV0ZShcIm1hdGhjb2xvclwiLCBncm91cC5yaWdodENvbG9yKTtcbiAgICAgIH1cblxuICAgICAgaW5uZXIucHVzaChyaWdodE5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBidWlsZE1hdGhNTF9tYWtlUm93KGlubmVyKTtcbiAgfVxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibWlkZGxlXCIsXG4gIG5hbWVzOiBbXCJcXFxcbWlkZGxlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGRlbGltID0gY2hlY2tEZWxpbWl0ZXIoYXJnc1swXSwgY29udGV4dCk7XG5cbiAgICBpZiAoIWNvbnRleHQucGFyc2VyLmxlZnRyaWdodERlcHRoKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJcXFxcbWlkZGxlIHdpdGhvdXQgcHJlY2VkaW5nIFxcXFxsZWZ0XCIsIGRlbGltKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJtaWRkbGVcIixcbiAgICAgIG1vZGU6IGNvbnRleHQucGFyc2VyLm1vZGUsXG4gICAgICBkZWxpbTogZGVsaW0udGV4dFxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBtaWRkbGVEZWxpbTtcblxuICAgIGlmIChncm91cC5kZWxpbSA9PT0gXCIuXCIpIHtcbiAgICAgIG1pZGRsZURlbGltID0gbWFrZU51bGxEZWxpbWl0ZXIob3B0aW9ucywgW10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaWRkbGVEZWxpbSA9IGRlbGltaXRlci5zaXplZERlbGltKGdyb3VwLmRlbGltLCAxLCBvcHRpb25zLCBncm91cC5tb2RlLCBbXSk7XG4gICAgICB2YXIgaXNNaWRkbGUgPSB7XG4gICAgICAgIGRlbGltOiBncm91cC5kZWxpbSxcbiAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgfTsgLy8gUHJvcGVydHkgYGlzTWlkZGxlYCBub3QgZGVmaW5lZCBvbiBgc3BhbmAuIEl0IGlzIG9ubHkgdXNlZCBpblxuICAgICAgLy8gdGhpcyBmaWxlIGFib3ZlLlxuICAgICAgLy8gVE9ETzogRml4IHRoaXMgdmlvbGF0aW9uIG9mIHRoZSBgc3BhbmAgdHlwZSBhbmQgcG9zc2libHkgcmVuYW1lXG4gICAgICAvLyB0aGluZ3Mgc2luY2UgYGlzTWlkZGxlYCBzb3VuZHMgbGlrZSBhIGJvb2xlYW4sIGJ1dCBpcyBhIHN0cnVjdC5cbiAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgbWlkZGxlRGVsaW0uaXNNaWRkbGUgPSBpc01pZGRsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWlkZGxlRGVsaW07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IGZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBBIEZpcmVmb3ggXFxtaWRkbGUgd2lsbCBzdHJlY2ggYSBjaGFyYWN0ZXIgdmVydGljYWxseSBvbmx5IGlmIGl0XG4gICAgLy8gaXMgaW4gdGhlIGZlbmNlIHBhcnQgb2YgdGhlIG9wZXJhdG9yIGRpY3Rpb25hcnkgYXQ6XG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL01hdGhNTDMvYXBwZW5kaXhjLmh0bWwuXG4gICAgLy8gU28gd2UgbmVlZCB0byBhdm9pZCBVKzIyMjMgYW5kIHVzZSBwbGFpbiBcInxcIiBpbnN0ZWFkLlxuICAgIHZhciB0ZXh0Tm9kZSA9IGdyb3VwLmRlbGltID09PSBcIlxcXFx2ZXJ0XCIgfHwgZ3JvdXAuZGVsaW0gPT09IFwifFwiID8gYnVpbGRNYXRoTUxfbWFrZVRleHQoXCJ8XCIsIFwidGV4dFwiKSA6IGJ1aWxkTWF0aE1MX21ha2VUZXh0KGdyb3VwLmRlbGltLCBncm91cC5tb2RlKTtcbiAgICB2YXIgbWlkZGxlTm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW3RleHROb2RlXSk7XG4gICAgbWlkZGxlTm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7IC8vIE1hdGhNTCBnaXZlcyA1LzE4ZW0gc3BhY2luZyB0byBlYWNoIDxtbz4gZWxlbWVudC5cbiAgICAvLyBcXG1pZGRsZSBzaG91bGQgZ2V0IGRlbGltaXRlciBzcGFjaW5nIGluc3RlYWQuXG5cbiAgICBtaWRkbGVOb2RlLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBcIjAuMDVlbVwiKTtcbiAgICBtaWRkbGVOb2RlLnNldEF0dHJpYnV0ZShcInJzcGFjZVwiLCBcIjAuMDVlbVwiKTtcbiAgICByZXR1cm4gbWlkZGxlTm9kZTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvZW5jbG9zZS5qc1xuXG5cblxuXG5cblxuXG5cblxudmFyIGVuY2xvc2VfaHRtbEJ1aWxkZXIgPSBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAvLyBcXGNhbmNlbCwgXFxiY2FuY2VsLCBcXHhjYW5jZWwsIFxcc291dCwgXFxmYm94LCBcXGNvbG9yYm94LCBcXGZjb2xvcmJveFxuICAvLyBTb21lIGdyb3VwcyBjYW4gcmV0dXJuIGRvY3VtZW50IGZyYWdtZW50cy4gIEhhbmRsZSB0aG9zZSBieSB3cmFwcGluZ1xuICAvLyB0aGVtIGluIGEgc3Bhbi5cbiAgdmFyIGlubmVyID0gYnVpbGRDb21tb24ud3JhcEZyYWdtZW50KGJ1aWxkSFRNTF9idWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgdmFyIGxhYmVsID0gZ3JvdXAubGFiZWwuc3Vic3RyKDEpO1xuICB2YXIgc2NhbGUgPSBvcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICB2YXIgaW1nO1xuICB2YXIgaW1nU2hpZnQgPSAwOyAvLyBJbiB0aGUgTGFUZVggY2FuY2VsIHBhY2thZ2UsIGxpbmUgZ2VvbWV0cnkgaXMgc2xpZ2h0bHkgZGlmZmVyZW50XG4gIC8vIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBzdWJqZWN0IGlzIHdpZGVyIHRoYW4gaXQgaXMgdGFsbCwgb3IgdmljZSB2ZXJzYS5cbiAgLy8gV2UgZG9uJ3Qga25vdyB0aGUgd2lkdGggb2YgYSBncm91cCwgc28gYXMgYSBwcm94eSwgd2UgdGVzdCBpZlxuICAvLyB0aGUgc3ViamVjdCBpcyBhIHNpbmdsZSBjaGFyYWN0ZXIuIFRoaXMgY2FwdHVyZXMgbW9zdCBvZiB0aGVcbiAgLy8gc3ViamVjdHMgdGhhdCBzaG91bGQgZ2V0IHRoZSBcInRhbGxcIiB0cmVhdG1lbnQuXG5cbiAgdmFyIGlzU2luZ2xlQ2hhciA9IHV0aWxzLmlzQ2hhcmFjdGVyQm94KGdyb3VwLmJvZHkpO1xuXG4gIGlmIChsYWJlbCA9PT0gXCJzb3V0XCIpIHtcbiAgICBpbWcgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJzdHJldGNoeVwiLCBcInNvdXRcIl0pO1xuICAgIGltZy5oZWlnaHQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZGVmYXVsdFJ1bGVUaGlja25lc3MgLyBzY2FsZTtcbiAgICBpbWdTaGlmdCA9IC0wLjUgKiBvcHRpb25zLmZvbnRNZXRyaWNzKCkueEhlaWdodDtcbiAgfSBlbHNlIHtcbiAgICAvLyBBZGQgaG9yaXpvbnRhbCBwYWRkaW5nXG4gICAgaWYgKC9jYW5jZWwvLnRlc3QobGFiZWwpKSB7XG4gICAgICBpZiAoIWlzU2luZ2xlQ2hhcikge1xuICAgICAgICBpbm5lci5jbGFzc2VzLnB1c2goXCJjYW5jZWwtcGFkXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbm5lci5jbGFzc2VzLnB1c2goXCJib3hwYWRcIik7XG4gICAgfSAvLyBBZGQgdmVydGljYWwgcGFkZGluZ1xuXG5cbiAgICB2YXIgdmVydFBhZCA9IDA7XG4gICAgdmFyIHJ1bGVUaGlja25lc3MgPSAwOyAvLyByZWY6IGNhbmNlbCBwYWNrYWdlOiBcXGFkdmFuY2VcXHRvdGFsaGVpZ2h0MlxccEAgJSBcIisyXCJcblxuICAgIGlmICgvYm94Ly50ZXN0KGxhYmVsKSkge1xuICAgICAgcnVsZVRoaWNrbmVzcyA9IE1hdGgubWF4KG9wdGlvbnMuZm9udE1ldHJpY3MoKS5mYm94cnVsZSwgLy8gZGVmYXVsdFxuICAgICAgb3B0aW9ucy5taW5SdWxlVGhpY2tuZXNzIC8vIFVzZXIgb3ZlcnJpZGUuXG4gICAgICApO1xuICAgICAgdmVydFBhZCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5mYm94c2VwICsgKGxhYmVsID09PSBcImNvbG9yYm94XCIgPyAwIDogcnVsZVRoaWNrbmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZlcnRQYWQgPSBpc1NpbmdsZUNoYXIgPyAwLjIgOiAwO1xuICAgIH1cblxuICAgIGltZyA9IHN0cmV0Y2h5LmVuY2xvc2VTcGFuKGlubmVyLCBsYWJlbCwgdmVydFBhZCwgb3B0aW9ucyk7XG5cbiAgICBpZiAoL2Zib3h8Ym94ZWR8ZmNvbG9yYm94Ly50ZXN0KGxhYmVsKSkge1xuICAgICAgaW1nLnN0eWxlLmJvcmRlclN0eWxlID0gXCJzb2xpZFwiO1xuICAgICAgaW1nLnN0eWxlLmJvcmRlcldpZHRoID0gcnVsZVRoaWNrbmVzcyArIFwiZW1cIjtcbiAgICB9XG5cbiAgICBpbWdTaGlmdCA9IGlubmVyLmRlcHRoICsgdmVydFBhZDtcblxuICAgIGlmIChncm91cC5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGltZy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBncm91cC5iYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICAgIGlmIChncm91cC5ib3JkZXJDb2xvcikge1xuICAgICAgICBpbWcuc3R5bGUuYm9yZGVyQ29sb3IgPSBncm91cC5ib3JkZXJDb2xvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgdmxpc3Q7XG5cbiAgaWYgKGdyb3VwLmJhY2tncm91bmRDb2xvcikge1xuICAgIHZsaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJpbmRpdmlkdWFsU2hpZnRcIixcbiAgICAgIGNoaWxkcmVuOiBbLy8gUHV0IHRoZSBjb2xvciBiYWNrZ3JvdW5kIGJlaGluZCBpbm5lcjtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGltZyxcbiAgICAgICAgc2hpZnQ6IGltZ1NoaWZ0XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBpbm5lcixcbiAgICAgICAgc2hpZnQ6IDBcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgY2hpbGRyZW46IFsvLyBXcml0ZSB0aGUgXFxjYW5jZWwgc3Ryb2tlIG9uIHRvcCBvZiBpbm5lci5cbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGlubmVyLFxuICAgICAgICBzaGlmdDogMFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogaW1nLFxuICAgICAgICBzaGlmdDogaW1nU2hpZnQsXG4gICAgICAgIHdyYXBwZXJDbGFzc2VzOiAvY2FuY2VsLy50ZXN0KGxhYmVsKSA/IFtcInN2Zy1hbGlnblwiXSA6IFtdXG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKC9jYW5jZWwvLnRlc3QobGFiZWwpKSB7XG4gICAgLy8gVGhlIGNhbmNlbCBwYWNrYWdlIGRvY3VtZW50YXRpb24gc2F5cyB0aGF0IGNhbmNlbCBsaW5lcyBhZGQgdGhlaXIgaGVpZ2h0XG4gICAgLy8gdG8gdGhlIGV4cHJlc3Npb24sIGJ1dCB0ZXN0cyBzaG93IHRoYXQgaXNuJ3QgaG93IGl0IGFjdHVhbGx5IHdvcmtzLlxuICAgIHZsaXN0LmhlaWdodCA9IGlubmVyLmhlaWdodDtcbiAgICB2bGlzdC5kZXB0aCA9IGlubmVyLmRlcHRoO1xuICB9XG5cbiAgaWYgKC9jYW5jZWwvLnRlc3QobGFiZWwpICYmICFpc1NpbmdsZUNoYXIpIHtcbiAgICAvLyBjYW5jZWwgZG9lcyBub3QgY3JlYXRlIGhvcml6IHNwYWNlIGZvciBpdHMgbGluZSBleHRlbnNpb24uXG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJjYW5jZWwtbGFwXCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiXSwgW3ZsaXN0XSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbnZhciBlbmNsb3NlX21hdGhtbEJ1aWxkZXIgPSBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gIHZhciBmYm94c2VwID0gMDtcbiAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShncm91cC5sYWJlbC5pbmRleE9mKFwiY29sb3Jib3hcIikgPiAtMSA/IFwibXBhZGRlZFwiIDogXCJtZW5jbG9zZVwiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKV0pO1xuXG4gIHN3aXRjaCAoZ3JvdXAubGFiZWwpIHtcbiAgICBjYXNlIFwiXFxcXGNhbmNlbFwiOlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBcInVwZGlhZ29uYWxzdHJpa2VcIik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJcXFxcYmNhbmNlbFwiOlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBcImRvd25kaWFnb25hbHN0cmlrZVwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIlxcXFxzb3V0XCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwiaG9yaXpvbnRhbHN0cmlrZVwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIlxcXFxmYm94XCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwiYm94XCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiXFxcXGZjb2xvcmJveFwiOlxuICAgIGNhc2UgXCJcXFxcY29sb3Jib3hcIjpcbiAgICAgIC8vIDxtZW5jbG9zZT4gZG9lc24ndCBoYXZlIGEgZ29vZCBub3RhdGlvbiBvcHRpb24uIFNvIHVzZSA8bXBhZGRlZD5cbiAgICAgIC8vIGluc3RlYWQuIFNldCBzb21lIGF0dHJpYnV0ZXMgdGhhdCBjb21lIGluY2x1ZGVkIHdpdGggPG1lbmNsb3NlPi5cbiAgICAgIGZib3hzZXAgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZmJveHNlcCAqIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5wdFBlckVtO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIitcIiArIDIgKiBmYm94c2VwICsgXCJwdFwiKTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiK1wiICsgMiAqIGZib3hzZXAgKyBcInB0XCIpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgZmJveHNlcCArIFwicHRcIik7IC8vXG5cbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwidm9mZnNldFwiLCBmYm94c2VwICsgXCJwdFwiKTtcblxuICAgICAgaWYgKGdyb3VwLmxhYmVsID09PSBcIlxcXFxmY29sb3Jib3hcIikge1xuICAgICAgICB2YXIgdGhrID0gTWF0aC5tYXgob3B0aW9ucy5mb250TWV0cmljcygpLmZib3hydWxlLCAvLyBkZWZhdWx0XG4gICAgICAgIG9wdGlvbnMubWluUnVsZVRoaWNrbmVzcyAvLyB1c2VyIG92ZXJyaWRlXG4gICAgICAgICk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJib3JkZXI6IFwiICsgdGhrICsgXCJlbSBzb2xpZCBcIiArIFN0cmluZyhncm91cC5ib3JkZXJDb2xvcikpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJcXFxceGNhbmNlbFwiOlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBcInVwZGlhZ29uYWxzdHJpa2UgZG93bmRpYWdvbmFsc3RyaWtlXCIpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBpZiAoZ3JvdXAuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRoYmFja2dyb3VuZFwiLCBncm91cC5iYWNrZ3JvdW5kQ29sb3IpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW5jbG9zZVwiLFxuICBuYW1lczogW1wiXFxcXGNvbG9yYm94XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBncmVlZGluZXNzOiAzLFxuICAgIGFyZ1R5cGVzOiBbXCJjb2xvclwiLCBcInRleHRcIl1cbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmLCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYucGFyc2VyLFxuICAgICAgICBmdW5jTmFtZSA9IF9yZWYuZnVuY05hbWU7XG4gICAgdmFyIGNvbG9yID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJjb2xvci10b2tlblwiKS5jb2xvcjtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW5jbG9zZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogZnVuY05hbWUsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yLFxuICAgICAgYm9keTogYm9keVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBlbmNsb3NlX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBlbmNsb3NlX21hdGhtbEJ1aWxkZXJcbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImVuY2xvc2VcIixcbiAgbmFtZXM6IFtcIlxcXFxmY29sb3Jib3hcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMyxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGdyZWVkaW5lc3M6IDMsXG4gICAgYXJnVHlwZXM6IFtcImNvbG9yXCIsIFwiY29sb3JcIiwgXCJ0ZXh0XCJdXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZjIsIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZjIucGFyc2VyLFxuICAgICAgICBmdW5jTmFtZSA9IF9yZWYyLmZ1bmNOYW1lO1xuICAgIHZhciBib3JkZXJDb2xvciA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwiY29sb3ItdG9rZW5cIikuY29sb3I7XG4gICAgdmFyIGJhY2tncm91bmRDb2xvciA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMV0sIFwiY29sb3ItdG9rZW5cIikuY29sb3I7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzJdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVuY2xvc2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgICBib3JkZXJDb2xvcjogYm9yZGVyQ29sb3IsXG4gICAgICBib2R5OiBib2R5XG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGVuY2xvc2VfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGVuY2xvc2VfbWF0aG1sQnVpbGRlclxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW5jbG9zZVwiLFxuICBuYW1lczogW1wiXFxcXGZib3hcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wiaGJveFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZjMsIGFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZjMucGFyc2VyO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVuY2xvc2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IFwiXFxcXGZib3hcIixcbiAgICAgIGJvZHk6IGFyZ3NbMF1cbiAgICB9O1xuICB9XG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbmNsb3NlXCIsXG4gIG5hbWVzOiBbXCJcXFxcY2FuY2VsXCIsIFwiXFxcXGJjYW5jZWxcIiwgXCJcXFxceGNhbmNlbFwiLCBcIlxcXFxzb3V0XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmNCwgYXJncywgb3B0QXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmNC5wYXJzZXIsXG4gICAgICAgIGZ1bmNOYW1lID0gX3JlZjQuZnVuY05hbWU7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVuY2xvc2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgYm9keTogYm9keVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBlbmNsb3NlX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBlbmNsb3NlX21hdGhtbEJ1aWxkZXJcbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZGVmaW5lRW52aXJvbm1lbnQuanNcblxuXG4vKipcbiAqIEFsbCByZWdpc3RlcmVkIGVudmlyb25tZW50cy5cbiAqIGBlbnZpcm9ubWVudHMuanNgIGV4cG9ydHMgdGhpcyBzYW1lIGRpY3Rpb25hcnkgYWdhaW4gYW5kIG1ha2VzIGl0IHB1YmxpYy5cbiAqIGBQYXJzZXIuanNgIHJlcXVpcmVzIHRoaXMgZGljdGlvbmFyeSB2aWEgYGVudmlyb25tZW50cy5qc2AuXG4gKi9cbnZhciBfZW52aXJvbm1lbnRzID0ge307XG5mdW5jdGlvbiBkZWZpbmVFbnZpcm9ubWVudChfcmVmKSB7XG4gIHZhciB0eXBlID0gX3JlZi50eXBlLFxuICAgICAgbmFtZXMgPSBfcmVmLm5hbWVzLFxuICAgICAgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgaGFuZGxlciA9IF9yZWYuaGFuZGxlcixcbiAgICAgIGh0bWxCdWlsZGVyID0gX3JlZi5odG1sQnVpbGRlcixcbiAgICAgIG1hdGhtbEJ1aWxkZXIgPSBfcmVmLm1hdGhtbEJ1aWxkZXI7XG4gIC8vIFNldCBkZWZhdWx0IHZhbHVlcyBvZiBlbnZpcm9ubWVudHMuXG4gIHZhciBkYXRhID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgbnVtQXJnczogcHJvcHMubnVtQXJncyB8fCAwLFxuICAgIGdyZWVkaW5lc3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogZmFsc2UsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAwLFxuICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gVE9ETzogVGhlIHZhbHVlIHR5cGUgb2YgX2Vudmlyb25tZW50cyBzaG91bGQgYmUgYSB0eXBlIHVuaW9uIG9mIGFsbFxuICAgIC8vIHBvc3NpYmxlIGBFbnZTcGVjPD5gIHBvc3NpYmlsaXRpZXMgaW5zdGVhZCBvZiBgRW52U3BlYzwqPmAsIHdoaWNoIGlzXG4gICAgLy8gYW4gZXhpc3RlbnRpYWwgdHlwZS5cbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgX2Vudmlyb25tZW50c1tuYW1lc1tpXV0gPSBkYXRhO1xuICB9XG5cbiAgaWYgKGh0bWxCdWlsZGVyKSB7XG4gICAgX2h0bWxHcm91cEJ1aWxkZXJzW3R5cGVdID0gaHRtbEJ1aWxkZXI7XG4gIH1cblxuICBpZiAobWF0aG1sQnVpbGRlcikge1xuICAgIF9tYXRobWxHcm91cEJ1aWxkZXJzW3R5cGVdID0gbWF0aG1sQnVpbGRlcjtcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZW52aXJvbm1lbnRzL2FycmF5LmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGdldEhMaW5lcyhwYXJzZXIpIHtcbiAgLy8gUmV0dXJuIGFuIGFycmF5LiBUaGUgYXJyYXkgbGVuZ3RoID0gbnVtYmVyIG9mIGhsaW5lcy5cbiAgLy8gRWFjaCBlbGVtZW50IGluIHRoZSBhcnJheSB0ZWxscyBpZiB0aGUgbGluZSBpcyBkYXNoZWQuXG4gIHZhciBobGluZUluZm8gPSBbXTtcbiAgcGFyc2VyLmNvbnN1bWVTcGFjZXMoKTtcbiAgdmFyIG54dCA9IHBhcnNlci5mZXRjaCgpLnRleHQ7XG5cbiAgd2hpbGUgKG54dCA9PT0gXCJcXFxcaGxpbmVcIiB8fCBueHQgPT09IFwiXFxcXGhkYXNobGluZVwiKSB7XG4gICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICBobGluZUluZm8ucHVzaChueHQgPT09IFwiXFxcXGhkYXNobGluZVwiKTtcbiAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuICAgIG54dCA9IHBhcnNlci5mZXRjaCgpLnRleHQ7XG4gIH1cblxuICByZXR1cm4gaGxpbmVJbmZvO1xufVxuLyoqXG4gKiBQYXJzZSB0aGUgYm9keSBvZiB0aGUgZW52aXJvbm1lbnQsIHdpdGggcm93cyBkZWxpbWl0ZWQgYnkgXFxcXCBhbmRcbiAqIGNvbHVtbnMgZGVsaW1pdGVkIGJ5ICYsIGFuZCBjcmVhdGUgYSBuZXN0ZWQgbGlzdCBpbiByb3ctbWFqb3Igb3JkZXJcbiAqIHdpdGggb25lIGdyb3VwIHBlciBjZWxsLiAgSWYgZ2l2ZW4gYW4gb3B0aW9uYWwgYXJndW1lbnQgc3R5bGVcbiAqIChcInRleHRcIiwgXCJkaXNwbGF5XCIsIGV0Yy4pLCB0aGVuIGVhY2ggY2VsbCBpcyBjYXN0IGludG8gdGhhdCBzdHlsZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlQXJyYXkocGFyc2VyLCBfcmVmLCBzdHlsZSkge1xuICB2YXIgaHNraXBCZWZvcmVBbmRBZnRlciA9IF9yZWYuaHNraXBCZWZvcmVBbmRBZnRlcixcbiAgICAgIGFkZEpvdCA9IF9yZWYuYWRkSm90LFxuICAgICAgY29scyA9IF9yZWYuY29scyxcbiAgICAgIGFycmF5c3RyZXRjaCA9IF9yZWYuYXJyYXlzdHJldGNoLFxuICAgICAgY29sU2VwYXJhdGlvblR5cGUgPSBfcmVmLmNvbFNlcGFyYXRpb25UeXBlO1xuICAvLyBQYXJzZSBib2R5IG9mIGFycmF5IHdpdGggXFxcXCB0ZW1wb3JhcmlseSBtYXBwZWQgdG8gXFxjclxuICBwYXJzZXIuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcbiAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KFwiXFxcXFxcXFxcIiwgXCJcXFxcY3JcIik7IC8vIEdldCBjdXJyZW50IGFycmF5c3RyZXRjaCBpZiBpdCdzIG5vdCBzZXQgYnkgdGhlIGVudmlyb25tZW50XG5cbiAgaWYgKCFhcnJheXN0cmV0Y2gpIHtcbiAgICB2YXIgc3RyZXRjaCA9IHBhcnNlci5ndWxsZXQuZXhwYW5kTWFjcm9Bc1RleHQoXCJcXFxcYXJyYXlzdHJldGNoXCIpO1xuXG4gICAgaWYgKHN0cmV0Y2ggPT0gbnVsbCkge1xuICAgICAgLy8gRGVmYXVsdCBcXGFycmF5c3RyZXRjaCBmcm9tIGx0dGFiLmR0eFxuICAgICAgYXJyYXlzdHJldGNoID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJyYXlzdHJldGNoID0gcGFyc2VGbG9hdChzdHJldGNoKTtcblxuICAgICAgaWYgKCFhcnJheXN0cmV0Y2ggfHwgYXJyYXlzdHJldGNoIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbnZhbGlkIFxcXFxhcnJheXN0cmV0Y2g6IFwiICsgc3RyZXRjaCk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFN0YXJ0IGdyb3VwIGZvciBmaXJzdCBjZWxsXG5cblxuICBwYXJzZXIuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcbiAgdmFyIHJvdyA9IFtdO1xuICB2YXIgYm9keSA9IFtyb3ddO1xuICB2YXIgcm93R2FwcyA9IFtdO1xuICB2YXIgaExpbmVzQmVmb3JlUm93ID0gW107IC8vIFRlc3QgZm9yIFxcaGxpbmUgYXQgdGhlIHRvcCBvZiB0aGUgYXJyYXkuXG5cbiAgaExpbmVzQmVmb3JlUm93LnB1c2goZ2V0SExpbmVzKHBhcnNlcikpO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAvLyBQYXJzZSBlYWNoIGNlbGwgaW4gaXRzIG93biBncm91cCAobmFtZXNwYWNlKVxuICAgIHZhciBjZWxsID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbihmYWxzZSwgXCJcXFxcY3JcIik7XG4gICAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpO1xuICAgIHBhcnNlci5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuICAgIGNlbGwgPSB7XG4gICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IGNlbGxcbiAgICB9O1xuXG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBjZWxsID0ge1xuICAgICAgICB0eXBlOiBcInN0eWxpbmdcIixcbiAgICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgYm9keTogW2NlbGxdXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJvdy5wdXNoKGNlbGwpO1xuICAgIHZhciBuZXh0ID0gcGFyc2VyLmZldGNoKCkudGV4dDtcblxuICAgIGlmIChuZXh0ID09PSBcIiZcIikge1xuICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09IFwiXFxcXGVuZFwiKSB7XG4gICAgICAvLyBBcnJheXMgdGVybWluYXRlIG5ld2xpbmVzIHdpdGggYFxcY3JjcmAgd2hpY2ggY29uc3VtZXMgYSBgXFxjcmAgaWZcbiAgICAgIC8vIHRoZSBsYXN0IGxpbmUgaXMgZW1wdHkuXG4gICAgICAvLyBOT1RFOiBDdXJyZW50bHksIGBjZWxsYCBpcyB0aGUgbGFzdCBpdGVtIGFkZGVkIGludG8gYHJvd2AuXG4gICAgICBpZiAocm93Lmxlbmd0aCA9PT0gMSAmJiBjZWxsLnR5cGUgPT09IFwic3R5bGluZ1wiICYmIGNlbGwuYm9keVswXS5ib2R5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBib2R5LnBvcCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaExpbmVzQmVmb3JlUm93Lmxlbmd0aCA8IGJvZHkubGVuZ3RoICsgMSkge1xuICAgICAgICBoTGluZXNCZWZvcmVSb3cucHVzaChbXSk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gXCJcXFxcY3JcIikge1xuICAgICAgdmFyIGNyID0gYXNzZXJ0Tm9kZVR5cGUocGFyc2VyLnBhcnNlRnVuY3Rpb24oKSwgXCJjclwiKTtcbiAgICAgIHJvd0dhcHMucHVzaChjci5zaXplKTsgLy8gY2hlY2sgZm9yIFxcaGxpbmUocykgZm9sbG93aW5nIHRoZSByb3cgc2VwYXJhdG9yXG5cbiAgICAgIGhMaW5lc0JlZm9yZVJvdy5wdXNoKGdldEhMaW5lcyhwYXJzZXIpKTtcbiAgICAgIHJvdyA9IFtdO1xuICAgICAgYm9keS5wdXNoKHJvdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkV4cGVjdGVkICYgb3IgXFxcXFxcXFwgb3IgXFxcXGNyIG9yIFxcXFxlbmRcIiwgcGFyc2VyLm5leHRUb2tlbik7XG4gICAgfVxuICB9IC8vIEVuZCBjZWxsIGdyb3VwXG5cblxuICBwYXJzZXIuZ3VsbGV0LmVuZEdyb3VwKCk7IC8vIEVuZCBhcnJheSBncm91cCBkZWZpbmluZyBcXFxcXG5cbiAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICBhZGRKb3Q6IGFkZEpvdCxcbiAgICBhcnJheXN0cmV0Y2g6IGFycmF5c3RyZXRjaCxcbiAgICBib2R5OiBib2R5LFxuICAgIGNvbHM6IGNvbHMsXG4gICAgcm93R2Fwczogcm93R2FwcyxcbiAgICBoc2tpcEJlZm9yZUFuZEFmdGVyOiBoc2tpcEJlZm9yZUFuZEFmdGVyLFxuICAgIGhMaW5lc0JlZm9yZVJvdzogaExpbmVzQmVmb3JlUm93LFxuICAgIGNvbFNlcGFyYXRpb25UeXBlOiBjb2xTZXBhcmF0aW9uVHlwZVxuICB9O1xufSAvLyBEZWNpZGVzIG9uIGEgc3R5bGUgZm9yIGNlbGxzIGluIGFuIGFycmF5IGFjY29yZGluZyB0byB3aGV0aGVyIHRoZSBnaXZlblxuLy8gZW52aXJvbm1lbnQgbmFtZSBzdGFydHMgd2l0aCB0aGUgbGV0dGVyICdkJy5cblxuXG5mdW5jdGlvbiBkQ2VsbFN0eWxlKGVudk5hbWUpIHtcbiAgaWYgKGVudk5hbWUuc3Vic3RyKDAsIDEpID09PSBcImRcIikge1xuICAgIHJldHVybiBcImRpc3BsYXlcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJ0ZXh0XCI7XG4gIH1cbn1cblxudmFyIGFycmF5X2h0bWxCdWlsZGVyID0gZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgdmFyIHI7XG4gIHZhciBjO1xuICB2YXIgbnIgPSBncm91cC5ib2R5Lmxlbmd0aDtcbiAgdmFyIGhMaW5lc0JlZm9yZVJvdyA9IGdyb3VwLmhMaW5lc0JlZm9yZVJvdztcbiAgdmFyIG5jID0gMDtcbiAgdmFyIGJvZHkgPSBuZXcgQXJyYXkobnIpO1xuICB2YXIgaGxpbmVzID0gW107XG4gIHZhciBydWxlVGhpY2tuZXNzID0gTWF0aC5tYXgoIC8vIEZyb20gTGFUZVggXFxzaG93dGhlXFxhcnJheXJ1bGV3aWR0aC4gRXF1YWxzIDAuMDQgZW0uXG4gIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5hcnJheVJ1bGVXaWR0aCwgb3B0aW9ucy5taW5SdWxlVGhpY2tuZXNzIC8vIFVzZXIgb3ZlcnJpZGUuXG4gICk7IC8vIEhvcml6b250YWwgc3BhY2luZ1xuXG4gIHZhciBwdCA9IDEgLyBvcHRpb25zLmZvbnRNZXRyaWNzKCkucHRQZXJFbTtcbiAgdmFyIGFycmF5Y29sc2VwID0gNSAqIHB0OyAvLyBkZWZhdWx0IHZhbHVlLCBpLmUuIFxcYXJyYXljb2xzZXAgaW4gYXJ0aWNsZS5jbHNcblxuICBpZiAoZ3JvdXAuY29sU2VwYXJhdGlvblR5cGUgJiYgZ3JvdXAuY29sU2VwYXJhdGlvblR5cGUgPT09IFwic21hbGxcIikge1xuICAgIC8vIFdlJ3JlIGluIGEge3NtYWxsbWF0cml4fS4gRGVmYXVsdCBjb2x1bW4gc3BhY2UgaXMgXFx0aGlja3NwYWNlLFxuICAgIC8vIGkuZS4gNS8xOGVtID0gMC4yNzc4ZW0sIHBlciBhbXNtYXRoLmR0eCBmb3Ige3NtYWxsbWF0cml4fS5cbiAgICAvLyBCdXQgdGhhdCBuZWVkcyBhZGp1c3RtZW50IGJlY2F1c2UgTGFUZVggYXBwbGllcyBcXHNjcmlwdHN0eWxlIHRvIHRoZVxuICAgIC8vIGVudGlyZSBhcnJheSwgaW5jbHVkaW5nIHRoZSBjb2xzcGFjZSwgYnV0IHRoaXMgZnVuY3Rpb24gYXBwbGllc1xuICAgIC8vIFxcc2NyaXB0c3R5bGUgb25seSBpbnNpZGUgZWFjaCBlbGVtZW50LlxuICAgIHZhciBsb2NhbE11bHRpcGxpZXIgPSBvcHRpb25zLmhhdmluZ1N0eWxlKHNyY19TdHlsZS5TQ1JJUFQpLnNpemVNdWx0aXBsaWVyO1xuICAgIGFycmF5Y29sc2VwID0gMC4yNzc4ICogKGxvY2FsTXVsdGlwbGllciAvIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXIpO1xuICB9IC8vIFZlcnRpY2FsIHNwYWNpbmdcblxuXG4gIHZhciBiYXNlbGluZXNraXAgPSAxMiAqIHB0OyAvLyBzZWUgc2l6ZTEwLmNsb1xuICAvLyBEZWZhdWx0IFxcam90IGZyb20gbHRtYXRoLmR0eFxuICAvLyBUT0RPKGVkZW1haW5lKTogYWxsb3cgb3ZlcnJpZGluZyBcXGpvdCB2aWEgXFxzZXRsZW5ndGggKCM2ODcpXG5cbiAgdmFyIGpvdCA9IDMgKiBwdDtcbiAgdmFyIGFycmF5c2tpcCA9IGdyb3VwLmFycmF5c3RyZXRjaCAqIGJhc2VsaW5lc2tpcDtcbiAgdmFyIGFyc3RydXRIZWlnaHQgPSAwLjcgKiBhcnJheXNraXA7IC8vIFxcc3RydXRib3ggaW4gbHRmc3N0cmMuZHR4IGFuZFxuXG4gIHZhciBhcnN0cnV0RGVwdGggPSAwLjMgKiBhcnJheXNraXA7IC8vIFxcQGFyc3RydXRib3ggaW4gbHR0YWIuZHR4XG5cbiAgdmFyIHRvdGFsSGVpZ2h0ID0gMDsgLy8gU2V0IGEgcG9zaXRpb24gZm9yIFxcaGxpbmUocykgYXQgdGhlIHRvcCBvZiB0aGUgYXJyYXksIGlmIGFueS5cblxuICBmdW5jdGlvbiBzZXRITGluZVBvcyhobGluZXNJbkdhcCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGxpbmVzSW5HYXAubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICB0b3RhbEhlaWdodCArPSAwLjI1O1xuICAgICAgfVxuXG4gICAgICBobGluZXMucHVzaCh7XG4gICAgICAgIHBvczogdG90YWxIZWlnaHQsXG4gICAgICAgIGlzRGFzaGVkOiBobGluZXNJbkdhcFtpXVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgc2V0SExpbmVQb3MoaExpbmVzQmVmb3JlUm93WzBdKTtcblxuICBmb3IgKHIgPSAwOyByIDwgZ3JvdXAuYm9keS5sZW5ndGg7ICsrcikge1xuICAgIHZhciBpbnJvdyA9IGdyb3VwLmJvZHlbcl07XG4gICAgdmFyIGhlaWdodCA9IGFyc3RydXRIZWlnaHQ7IC8vIFxcQGFycmF5IGFkZHMgYW4gXFxAYXJzdHJ1dFxuXG4gICAgdmFyIGRlcHRoID0gYXJzdHJ1dERlcHRoOyAvLyB0byBlYWNoIHRvdyAodmlhIHRoZSB0ZW1wbGF0ZSlcblxuICAgIGlmIChuYyA8IGlucm93Lmxlbmd0aCkge1xuICAgICAgbmMgPSBpbnJvdy5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIG91dHJvdyA9IG5ldyBBcnJheShpbnJvdy5sZW5ndGgpO1xuXG4gICAgZm9yIChjID0gMDsgYyA8IGlucm93Lmxlbmd0aDsgKytjKSB7XG4gICAgICB2YXIgZWx0ID0gYnVpbGRIVE1MX2J1aWxkR3JvdXAoaW5yb3dbY10sIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoZGVwdGggPCBlbHQuZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSBlbHQuZGVwdGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChoZWlnaHQgPCBlbHQuaGVpZ2h0KSB7XG4gICAgICAgIGhlaWdodCA9IGVsdC5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIG91dHJvd1tjXSA9IGVsdDtcbiAgICB9XG5cbiAgICB2YXIgcm93R2FwID0gZ3JvdXAucm93R2Fwc1tyXTtcbiAgICB2YXIgZ2FwID0gMDtcblxuICAgIGlmIChyb3dHYXApIHtcbiAgICAgIGdhcCA9IHVuaXRzX2NhbGN1bGF0ZVNpemUocm93R2FwLCBvcHRpb25zKTtcblxuICAgICAgaWYgKGdhcCA+IDApIHtcbiAgICAgICAgLy8gXFxAYXJnYXJyYXljclxuICAgICAgICBnYXAgKz0gYXJzdHJ1dERlcHRoO1xuXG4gICAgICAgIGlmIChkZXB0aCA8IGdhcCkge1xuICAgICAgICAgIGRlcHRoID0gZ2FwOyAvLyBcXEB4YXJnYXJyYXljclxuICAgICAgICB9XG5cbiAgICAgICAgZ2FwID0gMDtcbiAgICAgIH1cbiAgICB9IC8vIEluIEFNUyBtdWx0aWxpbmUgZW52aXJvbm1lbnRzIHN1Y2ggYXMgYWxpZ25lZCBhbmQgZ2F0aGVyZWQsIHJvd3NcbiAgICAvLyBjb3JyZXNwb25kIHRvIGxpbmVzIHRoYXQgaGF2ZSBhZGRpdGlvbmFsIFxcam90IGFkZGVkIHRvIHRoZVxuICAgIC8vIFxcYmFzZWxpbmVza2lwIHZpYSBcXG9wZW51cC5cblxuXG4gICAgaWYgKGdyb3VwLmFkZEpvdCkge1xuICAgICAgZGVwdGggKz0gam90O1xuICAgIH1cblxuICAgIG91dHJvdy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgb3V0cm93LmRlcHRoID0gZGVwdGg7XG4gICAgdG90YWxIZWlnaHQgKz0gaGVpZ2h0O1xuICAgIG91dHJvdy5wb3MgPSB0b3RhbEhlaWdodDtcbiAgICB0b3RhbEhlaWdodCArPSBkZXB0aCArIGdhcDsgLy8gXFxAeWFyZ2FycmF5Y3JcblxuICAgIGJvZHlbcl0gPSBvdXRyb3c7IC8vIFNldCBhIHBvc2l0aW9uIGZvciBcXGhsaW5lKHMpLCBpZiBhbnkuXG5cbiAgICBzZXRITGluZVBvcyhoTGluZXNCZWZvcmVSb3dbciArIDFdKTtcbiAgfVxuXG4gIHZhciBvZmZzZXQgPSB0b3RhbEhlaWdodCAvIDIgKyBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodDtcbiAgdmFyIGNvbERlc2NyaXB0aW9ucyA9IGdyb3VwLmNvbHMgfHwgW107XG4gIHZhciBjb2xzID0gW107XG4gIHZhciBjb2xTZXA7XG4gIHZhciBjb2xEZXNjck51bTtcblxuICBmb3IgKGMgPSAwLCBjb2xEZXNjck51bSA9IDA7IC8vIENvbnRpbnVlIHdoaWxlIGVpdGhlciB0aGVyZSBhcmUgbW9yZSBjb2x1bW5zIG9yIG1vcmUgY29sdW1uXG4gIC8vIGRlc2NyaXB0aW9ucywgc28gdHJhaWxpbmcgc2VwYXJhdG9ycyBkb24ndCBnZXQgbG9zdC5cbiAgYyA8IG5jIHx8IGNvbERlc2NyTnVtIDwgY29sRGVzY3JpcHRpb25zLmxlbmd0aDsgKytjLCArK2NvbERlc2NyTnVtKSB7XG4gICAgdmFyIGNvbERlc2NyID0gY29sRGVzY3JpcHRpb25zW2NvbERlc2NyTnVtXSB8fCB7fTtcbiAgICB2YXIgZmlyc3RTZXBhcmF0b3IgPSB0cnVlO1xuXG4gICAgd2hpbGUgKGNvbERlc2NyLnR5cGUgPT09IFwic2VwYXJhdG9yXCIpIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgc2VwYXJhdG9yIGluIGEgcm93LCBhZGQgYSBzcGFjZVxuICAgICAgLy8gYmV0d2VlbiB0aGVtLlxuICAgICAgaWYgKCFmaXJzdFNlcGFyYXRvcikge1xuICAgICAgICBjb2xTZXAgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJhcnJheWNvbHNlcFwiXSwgW10pO1xuICAgICAgICBjb2xTZXAuc3R5bGUud2lkdGggPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZG91YmxlUnVsZVNlcCArIFwiZW1cIjtcbiAgICAgICAgY29scy5wdXNoKGNvbFNlcCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb2xEZXNjci5zZXBhcmF0b3IgPT09IFwifFwiIHx8IGNvbERlc2NyLnNlcGFyYXRvciA9PT0gXCI6XCIpIHtcbiAgICAgICAgdmFyIGxpbmVUeXBlID0gY29sRGVzY3Iuc2VwYXJhdG9yID09PSBcInxcIiA/IFwic29saWRcIiA6IFwiZGFzaGVkXCI7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJ2ZXJ0aWNhbC1zZXBhcmF0b3JcIl0sIFtdLCBvcHRpb25zKTtcbiAgICAgICAgc2VwYXJhdG9yLnN0eWxlLmhlaWdodCA9IHRvdGFsSGVpZ2h0ICsgXCJlbVwiO1xuICAgICAgICBzZXBhcmF0b3Iuc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCA9IHJ1bGVUaGlja25lc3MgKyBcImVtXCI7XG4gICAgICAgIHNlcGFyYXRvci5zdHlsZS5ib3JkZXJSaWdodFN0eWxlID0gbGluZVR5cGU7XG4gICAgICAgIHNlcGFyYXRvci5zdHlsZS5tYXJnaW4gPSBcIjAgLVwiICsgcnVsZVRoaWNrbmVzcyAvIDIgKyBcImVtXCI7XG4gICAgICAgIHNlcGFyYXRvci5zdHlsZS52ZXJ0aWNhbEFsaWduID0gLSh0b3RhbEhlaWdodCAtIG9mZnNldCkgKyBcImVtXCI7XG4gICAgICAgIGNvbHMucHVzaChzZXBhcmF0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW52YWxpZCBzZXBhcmF0b3IgdHlwZTogXCIgKyBjb2xEZXNjci5zZXBhcmF0b3IpO1xuICAgICAgfVxuXG4gICAgICBjb2xEZXNjck51bSsrO1xuICAgICAgY29sRGVzY3IgPSBjb2xEZXNjcmlwdGlvbnNbY29sRGVzY3JOdW1dIHx8IHt9O1xuICAgICAgZmlyc3RTZXBhcmF0b3IgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYyA+PSBuYykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHNlcHdpZHRoID0gdm9pZCAwO1xuXG4gICAgaWYgKGMgPiAwIHx8IGdyb3VwLmhza2lwQmVmb3JlQW5kQWZ0ZXIpIHtcbiAgICAgIHNlcHdpZHRoID0gdXRpbHMuZGVmbHQoY29sRGVzY3IucHJlZ2FwLCBhcnJheWNvbHNlcCk7XG5cbiAgICAgIGlmIChzZXB3aWR0aCAhPT0gMCkge1xuICAgICAgICBjb2xTZXAgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJhcnJheWNvbHNlcFwiXSwgW10pO1xuICAgICAgICBjb2xTZXAuc3R5bGUud2lkdGggPSBzZXB3aWR0aCArIFwiZW1cIjtcbiAgICAgICAgY29scy5wdXNoKGNvbFNlcCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvbCA9IFtdO1xuXG4gICAgZm9yIChyID0gMDsgciA8IG5yOyArK3IpIHtcbiAgICAgIHZhciByb3cgPSBib2R5W3JdO1xuICAgICAgdmFyIGVsZW0gPSByb3dbY107XG5cbiAgICAgIGlmICghZWxlbSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNoaWZ0ID0gcm93LnBvcyAtIG9mZnNldDtcbiAgICAgIGVsZW0uZGVwdGggPSByb3cuZGVwdGg7XG4gICAgICBlbGVtLmhlaWdodCA9IHJvdy5oZWlnaHQ7XG4gICAgICBjb2wucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBlbGVtLFxuICAgICAgICBzaGlmdDogc2hpZnRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiaW5kaXZpZHVhbFNoaWZ0XCIsXG4gICAgICBjaGlsZHJlbjogY29sXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgY29sID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiY29sLWFsaWduLVwiICsgKGNvbERlc2NyLmFsaWduIHx8IFwiY1wiKV0sIFtjb2xdKTtcbiAgICBjb2xzLnB1c2goY29sKTtcblxuICAgIGlmIChjIDwgbmMgLSAxIHx8IGdyb3VwLmhza2lwQmVmb3JlQW5kQWZ0ZXIpIHtcbiAgICAgIHNlcHdpZHRoID0gdXRpbHMuZGVmbHQoY29sRGVzY3IucG9zdGdhcCwgYXJyYXljb2xzZXApO1xuXG4gICAgICBpZiAoc2Vwd2lkdGggIT09IDApIHtcbiAgICAgICAgY29sU2VwID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiYXJyYXljb2xzZXBcIl0sIFtdKTtcbiAgICAgICAgY29sU2VwLnN0eWxlLndpZHRoID0gc2Vwd2lkdGggKyBcImVtXCI7XG4gICAgICAgIGNvbHMucHVzaChjb2xTZXApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGJvZHkgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtdGFibGVcIl0sIGNvbHMpOyAvLyBBZGQgXFxobGluZShzKSwgaWYgYW55LlxuXG4gIGlmIChobGluZXMubGVuZ3RoID4gMCkge1xuICAgIHZhciBsaW5lID0gYnVpbGRDb21tb24ubWFrZUxpbmVTcGFuKFwiaGxpbmVcIiwgb3B0aW9ucywgcnVsZVRoaWNrbmVzcyk7XG4gICAgdmFyIGRhc2hlcyA9IGJ1aWxkQ29tbW9uLm1ha2VMaW5lU3BhbihcImhkYXNobGluZVwiLCBvcHRpb25zLCBydWxlVGhpY2tuZXNzKTtcbiAgICB2YXIgdkxpc3RFbGVtcyA9IFt7XG4gICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgIGVsZW06IGJvZHksXG4gICAgICBzaGlmdDogMFxuICAgIH1dO1xuXG4gICAgd2hpbGUgKGhsaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgaGxpbmUgPSBobGluZXMucG9wKCk7XG4gICAgICB2YXIgbGluZVNoaWZ0ID0gaGxpbmUucG9zIC0gb2Zmc2V0O1xuXG4gICAgICBpZiAoaGxpbmUuaXNEYXNoZWQpIHtcbiAgICAgICAgdkxpc3RFbGVtcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiBkYXNoZXMsXG4gICAgICAgICAgc2hpZnQ6IGxpbmVTaGlmdFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZMaXN0RWxlbXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogbGluZSxcbiAgICAgICAgICBzaGlmdDogbGluZVNoaWZ0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJvZHkgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgY2hpbGRyZW46IHZMaXN0RWxlbXNcbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCJdLCBbYm9keV0sIG9wdGlvbnMpO1xufTtcblxudmFyIGFsaWduTWFwID0ge1xuICBjOiBcImNlbnRlciBcIixcbiAgbDogXCJsZWZ0IFwiLFxuICByOiBcInJpZ2h0IFwiXG59O1xuXG52YXIgYXJyYXlfbWF0aG1sQnVpbGRlciA9IGZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgdmFyIHRhYmxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGFibGVcIiwgZ3JvdXAuYm9keS5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10clwiLCByb3cubWFwKGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW2J1aWxkTWF0aE1MX2J1aWxkR3JvdXAoY2VsbCwgb3B0aW9ucyldKTtcbiAgICB9KSk7XG4gIH0pKTsgLy8gU2V0IGNvbHVtbiBhbGlnbm1lbnQsIHJvdyBzcGFjaW5nLCBjb2x1bW4gc3BhY2luZywgYW5kXG4gIC8vIGFycmF5IGxpbmVzIGJ5IHNldHRpbmcgYXR0cmlidXRlcyBvbiB0aGUgdGFibGUgZWxlbWVudC5cbiAgLy8gU2V0IHRoZSByb3cgc3BhY2luZy4gSW4gTWF0aE1MLCB3ZSBzcGVjaWZ5IGEgZ2FwIGRpc3RhbmNlLlxuICAvLyBXZSBkbyBub3QgdXNlIHJvd0dhcFtdIGJlY2F1c2UgTWF0aE1MIGF1dG9tYXRpY2FsbHkgaW5jcmVhc2VzXG4gIC8vIGNlbGwgaGVpZ2h0IHdpdGggdGhlIGhlaWdodC9kZXB0aCBvZiB0aGUgZWxlbWVudCBjb250ZW50LlxuICAvLyBMYVRlWCBcXGFycmF5c3RyZXRjaCBtdWx0aXBsaWVzIHRoZSByb3cgYmFzZWxpbmUtdG8tYmFzZWxpbmUgZGlzdGFuY2UuXG4gIC8vIFdlIHNpbXVsYXRlIHRoaXMgYnkgYWRkaW5nIChhcnJheXN0cmV0Y2ggLSAxKWVtIHRvIHRoZSBnYXAuIFRoaXNcbiAgLy8gZG9lcyBhIHJlYXNvbmFibGUgam9iIG9mIGFkanVzdGluZyBhcnJheXMgY29udGFpbmluZyAxIGVtIHRhbGwgY29udGVudC5cbiAgLy8gVGhlIDAuMTYgYW5kIDAuMDkgdmFsdWVzIGFyZSBmb3VuZCBlbXByaWNhbGx5LiBUaGV5IHByb2R1Y2UgYW4gYXJyYXlcbiAgLy8gc2ltaWxhciB0byBMYVRlWCBhbmQgaW4gd2hpY2ggY29udGVudCBkb2VzIG5vdCBpbnRlcmZlcmUgd2l0aCBcXGhpbmVzLlxuXG4gIHZhciBnYXAgPSBncm91cC5hcnJheXN0cmV0Y2ggPT09IDAuNSA/IDAuMSAvLyB7c21hbGxtYXRyaXh9LCB7c3ViYXJyYXl9XG4gIDogMC4xNiArIGdyb3VwLmFycmF5c3RyZXRjaCAtIDEgKyAoZ3JvdXAuYWRkSm90ID8gMC4wOSA6IDApO1xuICB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJyb3dzcGFjaW5nXCIsIGdhcCArIFwiZW1cIik7IC8vIE1hdGhNTCB0YWJsZSBsaW5lcyBnbyBvbmx5IGJldHdlZW4gY2VsbHMuXG4gIC8vIFRvIHBsYWNlIGEgbGluZSBvbiBhbiBlZGdlIHdlJ2xsIHVzZSA8bWVuY2xvc2U+LCBpZiBuZWNlc3NhcnkuXG5cbiAgdmFyIG1lbmNsb3NlID0gXCJcIjtcbiAgdmFyIGFsaWduID0gXCJcIjtcblxuICBpZiAoZ3JvdXAuY29scykge1xuICAgIC8vIEZpbmQgY29sdW1uIGFsaWdubWVudCwgY29sdW1uIHNwYWNpbmcsIGFuZCAgdmVydGljYWwgbGluZXMuXG4gICAgdmFyIGNvbHMgPSBncm91cC5jb2xzO1xuICAgIHZhciBjb2x1bW5MaW5lcyA9IFwiXCI7XG4gICAgdmFyIHByZXZUeXBlV2FzQWxpZ24gPSBmYWxzZTtcbiAgICB2YXIgaVN0YXJ0ID0gMDtcbiAgICB2YXIgaUVuZCA9IGNvbHMubGVuZ3RoO1xuXG4gICAgaWYgKGNvbHNbMF0udHlwZSA9PT0gXCJzZXBhcmF0b3JcIikge1xuICAgICAgbWVuY2xvc2UgKz0gXCJ0b3AgXCI7XG4gICAgICBpU3RhcnQgPSAxO1xuICAgIH1cblxuICAgIGlmIChjb2xzW2NvbHMubGVuZ3RoIC0gMV0udHlwZSA9PT0gXCJzZXBhcmF0b3JcIikge1xuICAgICAgbWVuY2xvc2UgKz0gXCJib3R0b20gXCI7XG4gICAgICBpRW5kIC09IDE7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IGlTdGFydDsgaSA8IGlFbmQ7IGkrKykge1xuICAgICAgaWYgKGNvbHNbaV0udHlwZSA9PT0gXCJhbGlnblwiKSB7XG4gICAgICAgIGFsaWduICs9IGFsaWduTWFwW2NvbHNbaV0uYWxpZ25dO1xuXG4gICAgICAgIGlmIChwcmV2VHlwZVdhc0FsaWduKSB7XG4gICAgICAgICAgY29sdW1uTGluZXMgKz0gXCJub25lIFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldlR5cGVXYXNBbGlnbiA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGNvbHNbaV0udHlwZSA9PT0gXCJzZXBhcmF0b3JcIikge1xuICAgICAgICAvLyBNYXRoTUwgYWNjZXB0cyBvbmx5IHNpbmdsZSBsaW5lcyBiZXR3ZWVuIGNlbGxzLlxuICAgICAgICAvLyBTbyB3ZSByZWFkIG9ubHkgdGhlIGZpcnN0IG9mIGNvbnNlY3V0aXZlIHNlcGFyYXRvcnMuXG4gICAgICAgIGlmIChwcmV2VHlwZVdhc0FsaWduKSB7XG4gICAgICAgICAgY29sdW1uTGluZXMgKz0gY29sc1tpXS5zZXBhcmF0b3IgPT09IFwifFwiID8gXCJzb2xpZCBcIiA6IFwiZGFzaGVkIFwiO1xuICAgICAgICAgIHByZXZUeXBlV2FzQWxpZ24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcImNvbHVtbmFsaWduXCIsIGFsaWduLnRyaW0oKSk7XG5cbiAgICBpZiAoL1tzZF0vLnRlc3QoY29sdW1uTGluZXMpKSB7XG4gICAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJjb2x1bW5saW5lc1wiLCBjb2x1bW5MaW5lcy50cmltKCkpO1xuICAgIH1cbiAgfSAvLyBTZXQgY29sdW1uIHNwYWNpbmcuXG5cblxuICBpZiAoZ3JvdXAuY29sU2VwYXJhdGlvblR5cGUgPT09IFwiYWxpZ25cIikge1xuICAgIHZhciBfY29scyA9IGdyb3VwLmNvbHMgfHwgW107XG5cbiAgICB2YXIgc3BhY2luZyA9IFwiXCI7XG5cbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgX2NvbHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBzcGFjaW5nICs9IF9pICUgMiA/IFwiMGVtIFwiIDogXCIxZW0gXCI7XG4gICAgfVxuXG4gICAgdGFibGUuc2V0QXR0cmlidXRlKFwiY29sdW1uc3BhY2luZ1wiLCBzcGFjaW5nLnRyaW0oKSk7XG4gIH0gZWxzZSBpZiAoZ3JvdXAuY29sU2VwYXJhdGlvblR5cGUgPT09IFwiYWxpZ25hdFwiKSB7XG4gICAgdGFibGUuc2V0QXR0cmlidXRlKFwiY29sdW1uc3BhY2luZ1wiLCBcIjBlbVwiKTtcbiAgfSBlbHNlIGlmIChncm91cC5jb2xTZXBhcmF0aW9uVHlwZSA9PT0gXCJzbWFsbFwiKSB7XG4gICAgdGFibGUuc2V0QXR0cmlidXRlKFwiY29sdW1uc3BhY2luZ1wiLCBcIjAuMjc3OGVtXCIpO1xuICB9IGVsc2Uge1xuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcImNvbHVtbnNwYWNpbmdcIiwgXCIxZW1cIik7XG4gIH0gLy8gQWRkcmVzcyBcXGhsaW5lIGFuZCBcXGhkYXNobGluZVxuXG5cbiAgdmFyIHJvd0xpbmVzID0gXCJcIjtcbiAgdmFyIGhsaW5lcyA9IGdyb3VwLmhMaW5lc0JlZm9yZVJvdztcbiAgbWVuY2xvc2UgKz0gaGxpbmVzWzBdLmxlbmd0aCA+IDAgPyBcImxlZnQgXCIgOiBcIlwiO1xuICBtZW5jbG9zZSArPSBobGluZXNbaGxpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCA+IDAgPyBcInJpZ2h0IFwiIDogXCJcIjtcblxuICBmb3IgKHZhciBfaTIgPSAxOyBfaTIgPCBobGluZXMubGVuZ3RoIC0gMTsgX2kyKyspIHtcbiAgICByb3dMaW5lcyArPSBobGluZXNbX2kyXS5sZW5ndGggPT09IDAgPyBcIm5vbmUgXCIgLy8gTWF0aE1MIGFjY2VwdHMgb25seSBhIHNpbmdsZSBsaW5lIGJldHdlZW4gcm93cy4gUmVhZCBvbmUgZWxlbWVudC5cbiAgICA6IGhsaW5lc1tfaTJdWzBdID8gXCJkYXNoZWQgXCIgOiBcInNvbGlkIFwiO1xuICB9XG5cbiAgaWYgKC9bc2RdLy50ZXN0KHJvd0xpbmVzKSkge1xuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcInJvd2xpbmVzXCIsIHJvd0xpbmVzLnRyaW0oKSk7XG4gIH1cblxuICBpZiAobWVuY2xvc2UgIT09IFwiXCIpIHtcbiAgICB0YWJsZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWVuY2xvc2VcIiwgW3RhYmxlXSk7XG4gICAgdGFibGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgbWVuY2xvc2UudHJpbSgpKTtcbiAgfVxuXG4gIGlmIChncm91cC5hcnJheXN0cmV0Y2ggJiYgZ3JvdXAuYXJyYXlzdHJldGNoIDwgMSkge1xuICAgIC8vIEEgc21hbGwgYXJyYXkuIFdyYXAgaW4gc2NyaXB0c3R5bGUgc28gcm93IGdhcCBpcyBub3QgdG9vIGxhcmdlLlxuICAgIHRhYmxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3R5bGVcIiwgW3RhYmxlXSk7XG4gICAgdGFibGUuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgXCIxXCIpO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlO1xufTsgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGFsaWduZWQgYW5kIGFsaWduZWRhdCBlbnZpcm9ubWVudHMuXG5cblxudmFyIGFycmF5X2FsaWduZWRIYW5kbGVyID0gZnVuY3Rpb24gYWxpZ25lZEhhbmRsZXIoY29udGV4dCwgYXJncykge1xuICB2YXIgY29scyA9IFtdO1xuICB2YXIgcmVzID0gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwge1xuICAgIGNvbHM6IGNvbHMsXG4gICAgYWRkSm90OiB0cnVlXG4gIH0sIFwiZGlzcGxheVwiKTsgLy8gRGV0ZXJtaW5pbmcgbnVtYmVyIG9mIGNvbHVtbnMuXG4gIC8vIDEuIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBnaXZlbiwgd2UgdXNlIGl0IGFzIGEgbnVtYmVyIG9mIGNvbHVtbnMsXG4gIC8vICAgIGFuZCBtYWtlcyBzdXJlIHRoYXQgZWFjaCByb3cgZG9lc24ndCBleGNlZWQgdGhhdCBudW1iZXIuXG4gIC8vIDIuIE90aGVyd2lzZSwganVzdCBjb3VudCBudW1iZXIgb2YgY29sdW1ucyA9IG1heGltdW0gbnVtYmVyXG4gIC8vICAgIG9mIGNlbGxzIGluIGVhY2ggcm93IChcImFsaWduZWRcIiBtb2RlIC0tIGlzQWxpZ25lZCB3aWxsIGJlIHRydWUpLlxuICAvL1xuICAvLyBBdCB0aGUgc2FtZSB0aW1lLCBwcmVwZW5kIGVtcHR5IGdyb3VwIHt9IGF0IGJlZ2lubmluZyBvZiBldmVyeSBzZWNvbmRcbiAgLy8gY2VsbCBpbiBlYWNoIHJvdyAoc3RhcnRpbmcgd2l0aCBzZWNvbmQgY2VsbCkgc28gdGhhdCBvcGVyYXRvcnMgYmVjb21lXG4gIC8vIGJpbmFyeS4gIFRoaXMgYmVoYXZpb3IgaXMgaW1wbGVtZW50ZWQgaW4gYW1zbWF0aCdzIFxcc3RhcnRAYWxpZ25lZC5cblxuICB2YXIgbnVtTWF0aHM7XG4gIHZhciBudW1Db2xzID0gMDtcbiAgdmFyIGVtcHR5R3JvdXAgPSB7XG4gICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgIG1vZGU6IGNvbnRleHQubW9kZSxcbiAgICBib2R5OiBbXVxuICB9O1xuICB2YXIgb3JkZ3JvdXAgPSBjaGVja05vZGVUeXBlKGFyZ3NbMF0sIFwib3JkZ3JvdXBcIik7XG5cbiAgaWYgKG9yZGdyb3VwKSB7XG4gICAgdmFyIGFyZzAgPSBcIlwiO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRncm91cC5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdGV4dG9yZCA9IGFzc2VydE5vZGVUeXBlKG9yZGdyb3VwLmJvZHlbaV0sIFwidGV4dG9yZFwiKTtcbiAgICAgIGFyZzAgKz0gdGV4dG9yZC50ZXh0O1xuICAgIH1cblxuICAgIG51bU1hdGhzID0gTnVtYmVyKGFyZzApO1xuICAgIG51bUNvbHMgPSBudW1NYXRocyAqIDI7XG4gIH1cblxuICB2YXIgaXNBbGlnbmVkID0gIW51bUNvbHM7XG4gIHJlcy5ib2R5LmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgIGZvciAodmFyIF9pMyA9IDE7IF9pMyA8IHJvdy5sZW5ndGg7IF9pMyArPSAyKSB7XG4gICAgICAvLyBNb2RpZnkgb3JkZ3JvdXAgbm9kZSB3aXRoaW4gc3R5bGluZyBub2RlXG4gICAgICB2YXIgc3R5bGluZyA9IGFzc2VydE5vZGVUeXBlKHJvd1tfaTNdLCBcInN0eWxpbmdcIik7XG5cbiAgICAgIHZhciBfb3JkZ3JvdXAgPSBhc3NlcnROb2RlVHlwZShzdHlsaW5nLmJvZHlbMF0sIFwib3JkZ3JvdXBcIik7XG5cbiAgICAgIF9vcmRncm91cC5ib2R5LnVuc2hpZnQoZW1wdHlHcm91cCk7XG4gICAgfVxuXG4gICAgaWYgKCFpc0FsaWduZWQpIHtcbiAgICAgIC8vIENhc2UgMVxuICAgICAgdmFyIGN1ck1hdGhzID0gcm93Lmxlbmd0aCAvIDI7XG5cbiAgICAgIGlmIChudW1NYXRocyA8IGN1ck1hdGhzKSB7XG4gICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlRvbyBtYW55IG1hdGggaW4gYSByb3c6IFwiICsgKFwiZXhwZWN0ZWQgXCIgKyBudW1NYXRocyArIFwiLCBidXQgZ290IFwiICsgY3VyTWF0aHMpLCByb3dbMF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobnVtQ29scyA8IHJvdy5sZW5ndGgpIHtcbiAgICAgIC8vIENhc2UgMlxuICAgICAgbnVtQ29scyA9IHJvdy5sZW5ndGg7XG4gICAgfVxuICB9KTsgLy8gQWRqdXN0aW5nIGFsaWdubWVudC5cbiAgLy8gSW4gYWxpZ25lZCBtb2RlLCB3ZSBhZGQgb25lIFxccXF1YWQgYmV0d2VlbiBjb2x1bW5zO1xuICAvLyBvdGhlcndpc2Ugd2UgYWRkIG5vdGhpbmcuXG5cbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbnVtQ29sczsgKytfaTQpIHtcbiAgICB2YXIgYWxpZ24gPSBcInJcIjtcbiAgICB2YXIgcHJlZ2FwID0gMDtcblxuICAgIGlmIChfaTQgJSAyID09PSAxKSB7XG4gICAgICBhbGlnbiA9IFwibFwiO1xuICAgIH0gZWxzZSBpZiAoX2k0ID4gMCAmJiBpc0FsaWduZWQpIHtcbiAgICAgIC8vIFwiYWxpZ25lZFwiIG1vZGUuXG4gICAgICBwcmVnYXAgPSAxOyAvLyBhZGQgb25lIFxccXVhZFxuICAgIH1cblxuICAgIGNvbHNbX2k0XSA9IHtcbiAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgIGFsaWduOiBhbGlnbixcbiAgICAgIHByZWdhcDogcHJlZ2FwLFxuICAgICAgcG9zdGdhcDogMFxuICAgIH07XG4gIH1cblxuICByZXMuY29sU2VwYXJhdGlvblR5cGUgPSBpc0FsaWduZWQgPyBcImFsaWduXCIgOiBcImFsaWduYXRcIjtcbiAgcmV0dXJuIHJlcztcbn07IC8vIEFycmF5cyBhcmUgcGFydCBvZiBMYVRlWCwgZGVmaW5lZCBpbiBsdHRhYi5kdHggc28gaXRzIGRvY3VtZW50YXRpb25cbi8vIGlzIHBhcnQgb2YgdGhlIHNvdXJjZTJlLnBkZiBmaWxlIG9mIExhVGVYMmUgc291cmNlIGRvY3VtZW50YXRpb24uXG4vLyB7ZGFycmF5fSBpcyBhbiB7YXJyYXl9IGVudmlyb25tZW50IHdoZXJlIGNlbGxzIGFyZSBzZXQgaW4gXFxkaXNwbGF5c3R5bGUsXG4vLyBhcyBkZWZpbmVkIGluIG5jY21hdGguc3R5LlxuXG5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiYXJyYXlcIiwgXCJkYXJyYXlcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKGNvbnRleHQsIGFyZ3MpIHtcbiAgICAvLyBTaW5jZSBubyB0eXBlcyBhcmUgc3BlY2lmaWVkIGFib3ZlLCB0aGUgdHdvIHBvc3NpYmlsaXRpZXMgYXJlXG4gICAgLy8gLSBUaGUgYXJndW1lbnQgaXMgd3JhcHBlZCBpbiB7fSBvciBbXSwgaW4gd2hpY2ggY2FzZSBQYXJzZXInc1xuICAgIC8vICAgcGFyc2VHcm91cCgpIHJldHVybnMgYW4gXCJvcmRncm91cFwiIHdyYXBwaW5nIHNvbWUgc3ltYm9sIG5vZGUuXG4gICAgLy8gLSBUaGUgYXJndW1lbnQgaXMgYSBiYXJlIHN5bWJvbCBub2RlLlxuICAgIHZhciBzeW1Ob2RlID0gY2hlY2tTeW1ib2xOb2RlVHlwZShhcmdzWzBdKTtcbiAgICB2YXIgY29sYWxpZ24gPSBzeW1Ob2RlID8gW2FyZ3NbMF1dIDogYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJvcmRncm91cFwiKS5ib2R5O1xuICAgIHZhciBjb2xzID0gY29sYWxpZ24ubWFwKGZ1bmN0aW9uIChuZGUpIHtcbiAgICAgIHZhciBub2RlID0gYXNzZXJ0U3ltYm9sTm9kZVR5cGUobmRlKTtcbiAgICAgIHZhciBjYSA9IG5vZGUudGV4dDtcblxuICAgICAgaWYgKFwibGNyXCIuaW5kZXhPZihjYSkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJhbGlnblwiLFxuICAgICAgICAgIGFsaWduOiBjYVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChjYSA9PT0gXCJ8XCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInNlcGFyYXRvclwiLFxuICAgICAgICAgIHNlcGFyYXRvcjogXCJ8XCJcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoY2EgPT09IFwiOlwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJzZXBhcmF0b3JcIixcbiAgICAgICAgICBzZXBhcmF0b3I6IFwiOlwiXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlVua25vd24gY29sdW1uIGFsaWdubWVudDogXCIgKyBjYSwgbmRlKTtcbiAgICB9KTtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgY29sczogY29scyxcbiAgICAgIGhza2lwQmVmb3JlQW5kQWZ0ZXI6IHRydWUgLy8gXFxAcHJlYW1ibGUgaW4gbHR0YWIuZHR4XG5cbiAgICB9O1xuICAgIHJldHVybiBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMsIGRDZWxsU3R5bGUoY29udGV4dC5lbnZOYW1lKSk7XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBhcnJheV9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogYXJyYXlfbWF0aG1sQnVpbGRlclxufSk7IC8vIFRoZSBtYXRyaXggZW52aXJvbm1lbnRzIG9mIGFtc21hdGggYnVpbGRzIG9uIHRoZSBhcnJheSBlbnZpcm9ubWVudFxuLy8gb2YgTGFUZVgsIHdoaWNoIGlzIGRpc2N1c3NlZCBhYm92ZS5cblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJtYXRyaXhcIiwgXCJwbWF0cml4XCIsIFwiYm1hdHJpeFwiLCBcIkJtYXRyaXhcIiwgXCJ2bWF0cml4XCIsIFwiVm1hdHJpeFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoY29udGV4dCkge1xuICAgIHZhciBkZWxpbWl0ZXJzID0ge1xuICAgICAgXCJtYXRyaXhcIjogbnVsbCxcbiAgICAgIFwicG1hdHJpeFwiOiBbXCIoXCIsIFwiKVwiXSxcbiAgICAgIFwiYm1hdHJpeFwiOiBbXCJbXCIsIFwiXVwiXSxcbiAgICAgIFwiQm1hdHJpeFwiOiBbXCJcXFxce1wiLCBcIlxcXFx9XCJdLFxuICAgICAgXCJ2bWF0cml4XCI6IFtcInxcIiwgXCJ8XCJdLFxuICAgICAgXCJWbWF0cml4XCI6IFtcIlxcXFxWZXJ0XCIsIFwiXFxcXFZlcnRcIl1cbiAgICB9W2NvbnRleHQuZW52TmFtZV07IC8vIFxcaHNraXAgLVxcYXJyYXljb2xzZXAgaW4gYW1zbWF0aFxuXG4gICAgdmFyIHBheWxvYWQgPSB7XG4gICAgICBoc2tpcEJlZm9yZUFuZEFmdGVyOiBmYWxzZVxuICAgIH07XG4gICAgdmFyIHJlcyA9IHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHBheWxvYWQsIGRDZWxsU3R5bGUoY29udGV4dC5lbnZOYW1lKSk7XG4gICAgcmV0dXJuIGRlbGltaXRlcnMgPyB7XG4gICAgICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICAgICAgbW9kZTogY29udGV4dC5tb2RlLFxuICAgICAgYm9keTogW3Jlc10sXG4gICAgICBsZWZ0OiBkZWxpbWl0ZXJzWzBdLFxuICAgICAgcmlnaHQ6IGRlbGltaXRlcnNbMV0sXG4gICAgICByaWdodENvbG9yOiB1bmRlZmluZWQgLy8gXFxyaWdodCB1bmluZmx1ZW5jZWQgYnkgXFxjb2xvciBpbiBhcnJheVxuXG4gICAgfSA6IHJlcztcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGFycmF5X2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBhcnJheV9tYXRobWxCdWlsZGVyXG59KTtcbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wic21hbGxtYXRyaXhcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgIGFycmF5c3RyZXRjaDogMC41XG4gICAgfTtcbiAgICB2YXIgcmVzID0gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcGF5bG9hZCwgXCJzY3JpcHRcIik7XG4gICAgcmVzLmNvbFNlcGFyYXRpb25UeXBlID0gXCJzbWFsbFwiO1xuICAgIHJldHVybiByZXM7XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBhcnJheV9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogYXJyYXlfbWF0aG1sQnVpbGRlclxufSk7XG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcInN1YmFycmF5XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihjb250ZXh0LCBhcmdzKSB7XG4gICAgLy8gUGFyc2luZyBvZiB7c3ViYXJyYXl9IGlzIHNpbWlsYXIgdG8ge2FycmF5fVxuICAgIHZhciBzeW1Ob2RlID0gY2hlY2tTeW1ib2xOb2RlVHlwZShhcmdzWzBdKTtcbiAgICB2YXIgY29sYWxpZ24gPSBzeW1Ob2RlID8gW2FyZ3NbMF1dIDogYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJvcmRncm91cFwiKS5ib2R5O1xuICAgIHZhciBjb2xzID0gY29sYWxpZ24ubWFwKGZ1bmN0aW9uIChuZGUpIHtcbiAgICAgIHZhciBub2RlID0gYXNzZXJ0U3ltYm9sTm9kZVR5cGUobmRlKTtcbiAgICAgIHZhciBjYSA9IG5vZGUudGV4dDsgLy8ge3N1YmFycmF5fSBvbmx5IHJlY29nbml6ZXMgXCJsXCIgJiBcImNcIlxuXG4gICAgICBpZiAoXCJsY1wiLmluZGV4T2YoY2EpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgICAgICBhbGlnbjogY2FcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiVW5rbm93biBjb2x1bW4gYWxpZ25tZW50OiBcIiArIGNhLCBuZGUpO1xuICAgIH0pO1xuXG4gICAgaWYgKGNvbHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwie3N1YmFycmF5fSBjYW4gY29udGFpbiBvbmx5IG9uZSBjb2x1bW5cIik7XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IHtcbiAgICAgIGNvbHM6IGNvbHMsXG4gICAgICBoc2tpcEJlZm9yZUFuZEFmdGVyOiBmYWxzZSxcbiAgICAgIGFycmF5c3RyZXRjaDogMC41XG4gICAgfTtcbiAgICByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMsIFwic2NyaXB0XCIpO1xuXG4gICAgaWYgKHJlcy5ib2R5WzBdLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIntzdWJhcnJheX0gY2FuIGNvbnRhaW4gb25seSBvbmUgY29sdW1uXCIpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBhcnJheV9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogYXJyYXlfbWF0aG1sQnVpbGRlclxufSk7IC8vIEEgY2FzZXMgZW52aXJvbm1lbnQgKGluIGFtc21hdGguc3R5KSBpcyBhbG1vc3QgZXF1aXZhbGVudCB0b1xuLy8gXFxkZWZcXGFycmF5c3RyZXRjaHsxLjJ9JVxuLy8gXFxsZWZ0XFx7XFxiZWdpbnthcnJheX17QHt9bEB7XFxxdWFkfWxAe319IOKApiBcXGVuZHthcnJheX1cXHJpZ2h0LlxuLy8ge2RjYXNlc30gaXMgYSB7Y2FzZXN9IGVudmlyb25tZW50IHdoZXJlIGNlbGxzIGFyZSBzZXQgaW4gXFxkaXNwbGF5c3R5bGUsXG4vLyBhcyBkZWZpbmVkIGluIG1hdGh0b29scy5zdHkuXG5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiY2FzZXNcIiwgXCJkY2FzZXNcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgIGFycmF5c3RyZXRjaDogMS4yLFxuICAgICAgY29sczogW3tcbiAgICAgICAgdHlwZTogXCJhbGlnblwiLFxuICAgICAgICBhbGlnbjogXCJsXCIsXG4gICAgICAgIHByZWdhcDogMCxcbiAgICAgICAgLy8gVE9ETyhrZXZpbmIpIGdldCB0aGUgY3VycmVudCBzdHlsZS5cbiAgICAgICAgLy8gRm9yIG5vdyB3ZSB1c2UgdGhlIG1ldHJpY3MgZm9yIFRFWFQgc3R5bGUgd2hpY2ggaXMgd2hhdCB3ZSB3ZXJlXG4gICAgICAgIC8vIGRvaW5nIGJlZm9yZS4gIEJlZm9yZSBhdHRlbXB0aW5nIHRvIGdldCB0aGUgY3VycmVudCBzdHlsZSB3ZVxuICAgICAgICAvLyBzaG91bGQgbG9vayBhdCBUZVgncyBiZWhhdmlvciBlc3BlY2lhbGx5IGZvciBcXG92ZXIgYW5kIG1hdHJpY2VzLlxuICAgICAgICBwb3N0Z2FwOiAxLjBcbiAgICAgICAgLyogMWVtIHF1YWQgKi9cblxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgIGFsaWduOiBcImxcIixcbiAgICAgICAgcHJlZ2FwOiAwLFxuICAgICAgICBwb3N0Z2FwOiAwXG4gICAgICB9XVxuICAgIH07XG4gICAgdmFyIHJlcyA9IHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHBheWxvYWQsIGRDZWxsU3R5bGUoY29udGV4dC5lbnZOYW1lKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibGVmdHJpZ2h0XCIsXG4gICAgICBtb2RlOiBjb250ZXh0Lm1vZGUsXG4gICAgICBib2R5OiBbcmVzXSxcbiAgICAgIGxlZnQ6IFwiXFxcXHtcIixcbiAgICAgIHJpZ2h0OiBcIi5cIixcbiAgICAgIHJpZ2h0Q29sb3I6IHVuZGVmaW5lZFxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBhcnJheV9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogYXJyYXlfbWF0aG1sQnVpbGRlclxufSk7IC8vIEFuIGFsaWduZWQgZW52aXJvbm1lbnQgaXMgbGlrZSB0aGUgYWxpZ24qIGVudmlyb25tZW50XG4vLyBleGNlcHQgaXQgb3BlcmF0ZXMgd2l0aGluIG1hdGggbW9kZS5cbi8vIE5vdGUgdGhhdCB3ZSBhc3N1bWUgXFxub21hbGxpbmVza2lwbGltaXQgdG8gYmUgemVybyxcbi8vIHNvIHRoYXQgXFxzdHJ1dEAgaXMgdGhlIHNhbWUgYXMgXFxzdHJ1dC5cblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJhbGlnbmVkXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcjogYXJyYXlfYWxpZ25lZEhhbmRsZXIsXG4gIGh0bWxCdWlsZGVyOiBhcnJheV9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogYXJyYXlfbWF0aG1sQnVpbGRlclxufSk7IC8vIEEgZ2F0aGVyZWQgZW52aXJvbm1lbnQgaXMgbGlrZSBhbiBhcnJheSBlbnZpcm9ubWVudCB3aXRoIG9uZSBjZW50ZXJlZFxuLy8gY29sdW1uLCBidXQgd2hlcmUgcm93cyBhcmUgY29uc2lkZXJlZCBsaW5lcyBzbyBnZXQgXFxqb3QgbGluZSBzcGFjaW5nXG4vLyBhbmQgY29udGVudHMgYXJlIHNldCBpbiBcXGRpc3BsYXlzdHlsZS5cblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJnYXRoZXJlZFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoY29udGV4dCkge1xuICAgIHZhciByZXMgPSB7XG4gICAgICBjb2xzOiBbe1xuICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgIGFsaWduOiBcImNcIlxuICAgICAgfV0sXG4gICAgICBhZGRKb3Q6IHRydWVcbiAgICB9O1xuICAgIHJldHVybiBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMsIFwiZGlzcGxheVwiKTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGFycmF5X2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBhcnJheV9tYXRobWxCdWlsZGVyXG59KTsgLy8gYWxpZ25hdCBlbnZpcm9ubWVudCBpcyBsaWtlIGFuIGFsaWduIGVudmlyb25tZW50LCBidXQgb25lIG11c3QgZXhwbGljaXRseVxuLy8gc3BlY2lmeSBtYXhpbXVtIG51bWJlciBvZiBjb2x1bW5zIGluIGVhY2ggcm93LCBhbmQgY2FuIGFkanVzdCBzcGFjaW5nIGJldHdlZW5cbi8vIGVhY2ggY29sdW1ucy5cblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJhbGlnbmVkYXRcIl0sXG4gIC8vIE9uZSBmb3IgbnVtYmVyZWQgYW5kIGZvciB1bm51bWJlcmVkO1xuICAvLyBidXQsIEthVGVYIGRvZXNuJ3Qgc3VwcG9ydHMgbWF0aCBudW1iZXJpbmcgeWV0LFxuICAvLyB0aGV5IG1ha2Ugbm8gZGlmZmVyZW5jZSBmb3Igbm93LlxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogYXJyYXlfYWxpZ25lZEhhbmRsZXIsXG4gIGh0bWxCdWlsZGVyOiBhcnJheV9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogYXJyYXlfbWF0aG1sQnVpbGRlclxufSk7IC8vIENhdGNoIFxcaGxpbmUgb3V0c2lkZSBhcnJheSBlbnZpcm9ubWVudFxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidGV4dFwiLFxuICAvLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoaXMgaXMuXG4gIG5hbWVzOiBbXCJcXFxcaGxpbmVcIiwgXCJcXFxcaGRhc2hsaW5lXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhbGxvd2VkSW5NYXRoOiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoY29udGV4dCwgYXJncykge1xuICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihjb250ZXh0LmZ1bmNOYW1lICsgXCIgdmFsaWQgb25seSB3aXRoaW4gYXJyYXkgZW52aXJvbm1lbnRcIik7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZW52aXJvbm1lbnRzLmpzXG5cbnZhciBlbnZpcm9ubWVudHMgPSBfZW52aXJvbm1lbnRzO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX2Vudmlyb25tZW50cyA9IChlbnZpcm9ubWVudHMpOyAvLyBBbGwgZW52aXJvbm1lbnQgZGVmaW5pdGlvbnMgc2hvdWxkIGJlIGltcG9ydGVkIGJlbG93XG5cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2Vudmlyb25tZW50LmpzXG5cblxuXG4gLy8gRW52aXJvbm1lbnQgZGVsaW1pdGVycy4gSFRNTC9NYXRoTUwgcmVuZGVyaW5nIGlzIGRlZmluZWQgaW4gdGhlIGNvcnJlc3BvbmRpbmdcbi8vIGRlZmluZUVudmlyb25tZW50IGRlZmluaXRpb25zLlxuLy8gJEZsb3dGaXhNZSwgXCJlbnZpcm9ubWVudFwiIGhhbmRsZXIgcmV0dXJucyBhbiBlbnZpcm9ubWVudCBQYXJzZU5vZGVcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImVudmlyb25tZW50XCIsXG4gIG5hbWVzOiBbXCJcXFxcYmVnaW5cIiwgXCJcXFxcZW5kXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInRleHRcIl1cbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYucGFyc2VyLFxuICAgICAgICBmdW5jTmFtZSA9IF9yZWYuZnVuY05hbWU7XG4gICAgdmFyIG5hbWVHcm91cCA9IGFyZ3NbMF07XG5cbiAgICBpZiAobmFtZUdyb3VwLnR5cGUgIT09IFwib3JkZ3JvdXBcIikge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW52YWxpZCBlbnZpcm9ubWVudCBuYW1lXCIsIG5hbWVHcm91cCk7XG4gICAgfVxuXG4gICAgdmFyIGVudk5hbWUgPSBcIlwiO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lR3JvdXAuYm9keS5sZW5ndGg7ICsraSkge1xuICAgICAgZW52TmFtZSArPSBhc3NlcnROb2RlVHlwZShuYW1lR3JvdXAuYm9keVtpXSwgXCJ0ZXh0b3JkXCIpLnRleHQ7XG4gICAgfVxuXG4gICAgaWYgKGZ1bmNOYW1lID09PSBcIlxcXFxiZWdpblwiKSB7XG4gICAgICAvLyBiZWdpbi4uLmVuZCBpcyBzaW1pbGFyIHRvIGxlZnQuLi5yaWdodFxuICAgICAgaWYgKCFzcmNfZW52aXJvbm1lbnRzLmhhc093blByb3BlcnR5KGVudk5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIk5vIHN1Y2ggZW52aXJvbm1lbnQ6IFwiICsgZW52TmFtZSwgbmFtZUdyb3VwKTtcbiAgICAgIH0gLy8gQnVpbGQgdGhlIGVudmlyb25tZW50IG9iamVjdC4gQXJndW1lbnRzIGFuZCBvdGhlciBpbmZvcm1hdGlvbiB3aWxsXG4gICAgICAvLyBiZSBtYWRlIGF2YWlsYWJsZSB0byB0aGUgYmVnaW4gYW5kIGVuZCBtZXRob2RzIHVzaW5nIHByb3BlcnRpZXMuXG5cblxuICAgICAgdmFyIGVudiA9IHNyY19lbnZpcm9ubWVudHNbZW52TmFtZV07XG5cbiAgICAgIHZhciBfcGFyc2VyJHBhcnNlQXJndW1lbnQgPSBwYXJzZXIucGFyc2VBcmd1bWVudHMoXCJcXFxcYmVnaW57XCIgKyBlbnZOYW1lICsgXCJ9XCIsIGVudiksXG4gICAgICAgICAgX2FyZ3MgPSBfcGFyc2VyJHBhcnNlQXJndW1lbnQuYXJncyxcbiAgICAgICAgICBvcHRBcmdzID0gX3BhcnNlciRwYXJzZUFyZ3VtZW50Lm9wdEFyZ3M7XG5cbiAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgICAgZW52TmFtZTogZW52TmFtZSxcbiAgICAgICAgcGFyc2VyOiBwYXJzZXJcbiAgICAgIH07XG4gICAgICB2YXIgcmVzdWx0ID0gZW52LmhhbmRsZXIoY29udGV4dCwgX2FyZ3MsIG9wdEFyZ3MpO1xuICAgICAgcGFyc2VyLmV4cGVjdChcIlxcXFxlbmRcIiwgZmFsc2UpO1xuICAgICAgdmFyIGVuZE5hbWVUb2tlbiA9IHBhcnNlci5uZXh0VG9rZW47XG4gICAgICB2YXIgZW5kID0gYXNzZXJ0Tm9kZVR5cGUocGFyc2VyLnBhcnNlRnVuY3Rpb24oKSwgXCJlbnZpcm9ubWVudFwiKTtcblxuICAgICAgaWYgKGVuZC5uYW1lICE9PSBlbnZOYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIk1pc21hdGNoOiBcXFxcYmVnaW57XCIgKyBlbnZOYW1lICsgXCJ9IG1hdGNoZWQgYnkgXFxcXGVuZHtcIiArIGVuZC5uYW1lICsgXCJ9XCIsIGVuZE5hbWVUb2tlbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW52aXJvbm1lbnRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbmFtZTogZW52TmFtZSxcbiAgICAgIG5hbWVHcm91cDogbmFtZUdyb3VwXG4gICAgfTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvbWNsYXNzLmpzXG5cblxuXG5cblxuXG52YXIgbWNsYXNzX21ha2VTcGFuID0gYnVpbGRDb21tb24ubWFrZVNwYW47XG5cbmZ1bmN0aW9uIG1jbGFzc19odG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICB2YXIgZWxlbWVudHMgPSBidWlsZEhUTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMsIHRydWUpO1xuICByZXR1cm4gbWNsYXNzX21ha2VTcGFuKFtncm91cC5tY2xhc3NdLCBlbGVtZW50cywgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIG1jbGFzc19tYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gIHZhciBub2RlO1xuICB2YXIgaW5uZXIgPSBidWlsZE1hdGhNTF9idWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucyk7XG5cbiAgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtaW5uZXJcIikge1xuICAgIHJldHVybiBtYXRoTUxUcmVlLm5ld0RvY3VtZW50RnJhZ21lbnQoaW5uZXIpO1xuICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtb3JkXCIpIHtcbiAgICBpZiAoZ3JvdXAuaXNDaGFyYWN0ZXJCb3gpIHtcbiAgICAgIG5vZGUgPSBpbm5lclswXTtcbiAgICAgIG5vZGUudHlwZSA9IFwibWlcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWlcIiwgaW5uZXIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZ3JvdXAuaXNDaGFyYWN0ZXJCb3gpIHtcbiAgICAgIG5vZGUgPSBpbm5lclswXTtcbiAgICAgIG5vZGUudHlwZSA9IFwibW9cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgaW5uZXIpO1xuICAgIH0gLy8gU2V0IHNwYWNpbmcgYmFzZWQgb24gd2hhdCBpcyB0aGUgbW9zdCBsaWtlbHkgYWRqYWNlbnQgYXRvbSB0eXBlLlxuICAgIC8vIFNlZSBUZVhib29rIHAxNzAuXG5cblxuICAgIGlmIChncm91cC5tY2xhc3MgPT09IFwibWJpblwiKSB7XG4gICAgICBub2RlLmF0dHJpYnV0ZXMubHNwYWNlID0gXCIwLjIyZW1cIjsgLy8gbWVkaXVtIHNwYWNlXG5cbiAgICAgIG5vZGUuYXR0cmlidXRlcy5yc3BhY2UgPSBcIjAuMjJlbVwiO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1wdW5jdFwiKSB7XG4gICAgICBub2RlLmF0dHJpYnV0ZXMubHNwYWNlID0gXCIwZW1cIjtcbiAgICAgIG5vZGUuYXR0cmlidXRlcy5yc3BhY2UgPSBcIjAuMTdlbVwiOyAvLyB0aGluc3BhY2VcbiAgICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtb3BlblwiIHx8IGdyb3VwLm1jbGFzcyA9PT0gXCJtY2xvc2VcIikge1xuICAgICAgbm9kZS5hdHRyaWJ1dGVzLmxzcGFjZSA9IFwiMGVtXCI7XG4gICAgICBub2RlLmF0dHJpYnV0ZXMucnNwYWNlID0gXCIwZW1cIjtcbiAgICB9IC8vIE1hdGhNTCA8bW8+IGRlZmF1bHQgc3BhY2UgaXMgNS8xOCBlbSwgc28gPG1yZWw+IG5lZWRzIG5vIGFjdGlvbi5cbiAgICAvLyBSZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL01hdGhNTC9FbGVtZW50L21vXG5cbiAgfVxuXG4gIHJldHVybiBub2RlO1xufSAvLyBNYXRoIGNsYXNzIGNvbW1hbmRzIGV4Y2VwdCBcXG1hdGhvcFxuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJtY2xhc3NcIixcbiAgbmFtZXM6IFtcIlxcXFxtYXRob3JkXCIsIFwiXFxcXG1hdGhiaW5cIiwgXCJcXFxcbWF0aHJlbFwiLCBcIlxcXFxtYXRob3BlblwiLCBcIlxcXFxtYXRoY2xvc2VcIiwgXCJcXFxcbWF0aHB1bmN0XCIsIFwiXFxcXG1hdGhpbm5lclwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmLnBhcnNlcixcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmLmZ1bmNOYW1lO1xuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJtY2xhc3NcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbWNsYXNzOiBcIm1cIiArIGZ1bmNOYW1lLnN1YnN0cig1KSxcbiAgICAgIC8vIFRPRE8oa2V2aW5iKTogZG9uJ3QgcHJlZml4IHdpdGggJ20nXG4gICAgICBib2R5OiBkZWZpbmVGdW5jdGlvbl9vcmRhcmd1bWVudChib2R5KSxcbiAgICAgIGlzQ2hhcmFjdGVyQm94OiB1dGlscy5pc0NoYXJhY3RlckJveChib2R5KVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBtY2xhc3NfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IG1jbGFzc19tYXRobWxCdWlsZGVyXG59KTtcbnZhciBiaW5yZWxDbGFzcyA9IGZ1bmN0aW9uIGJpbnJlbENsYXNzKGFyZykge1xuICAvLyBcXGJpbnJlbEAgc3BhY2luZyB2YXJpZXMgd2l0aCAoYmlufHJlbHxvcmQpIG9mIHRoZSBhdG9tIGluIHRoZSBhcmd1bWVudC5cbiAgLy8gKGJ5IHJlbmRlcmluZyBzZXBhcmF0ZWx5IGFuZCB3aXRoIHt9cyBiZWZvcmUgYW5kIGFmdGVyLCBhbmQgbWVhc3VyaW5nXG4gIC8vIHRoZSBjaGFuZ2UgaW4gc3BhY2luZykuICBXZSdsbCBkbyByb3VnaGx5IHRoZSBzYW1lIGJ5IGRldGVjdGluZyB0aGVcbiAgLy8gYXRvbSB0eXBlIGRpcmVjdGx5LlxuICB2YXIgYXRvbSA9IGFyZy50eXBlID09PSBcIm9yZGdyb3VwXCIgJiYgYXJnLmJvZHkubGVuZ3RoID8gYXJnLmJvZHlbMF0gOiBhcmc7XG5cbiAgaWYgKGF0b20udHlwZSA9PT0gXCJhdG9tXCIgJiYgKGF0b20uZmFtaWx5ID09PSBcImJpblwiIHx8IGF0b20uZmFtaWx5ID09PSBcInJlbFwiKSkge1xuICAgIHJldHVybiBcIm1cIiArIGF0b20uZmFtaWx5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIm1vcmRcIjtcbiAgfVxufTsgLy8gXFxAYmlucmVse3h9e3l9IHJlbmRlcnMgbGlrZSB5IGJ1dCBhcyBtYmluL21yZWwvbW9yZCBpZiB4IGlzIG1iaW4vbXJlbC9tb3JkLlxuLy8gVGhpcyBpcyBlcXVpdmFsZW50IHRvIFxcYmlucmVsQHt4fVxcYmlucmVsQEB7eX0gaW4gQU1TVGVYLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibWNsYXNzXCIsXG4gIG5hbWVzOiBbXCJcXFxcQGJpbnJlbFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZjIsIGFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZjIucGFyc2VyO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm1jbGFzc1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBtY2xhc3M6IGJpbnJlbENsYXNzKGFyZ3NbMF0pLFxuICAgICAgYm9keTogW2FyZ3NbMV1dLFxuICAgICAgaXNDaGFyYWN0ZXJCb3g6IHV0aWxzLmlzQ2hhcmFjdGVyQm94KGFyZ3NbMV0pXG4gICAgfTtcbiAgfVxufSk7IC8vIEJ1aWxkIGEgcmVsYXRpb24gb3Igc3RhY2tlZCBvcCBieSBwbGFjaW5nIG9uZSBzeW1ib2wgb24gdG9wIG9mIGFub3RoZXJcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm1jbGFzc1wiLFxuICBuYW1lczogW1wiXFxcXHN0YWNrcmVsXCIsIFwiXFxcXG92ZXJzZXRcIiwgXCJcXFxcdW5kZXJzZXRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMlxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYzLCBhcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYzLnBhcnNlcixcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmMy5mdW5jTmFtZTtcbiAgICB2YXIgYmFzZUFyZyA9IGFyZ3NbMV07XG4gICAgdmFyIHNoaWZ0ZWRBcmcgPSBhcmdzWzBdO1xuICAgIHZhciBtY2xhc3M7XG5cbiAgICBpZiAoZnVuY05hbWUgIT09IFwiXFxcXHN0YWNrcmVsXCIpIHtcbiAgICAgIC8vIExhVGVYIGFwcGxpZXMgXFxiaW5yZWwgc3BhY2luZyB0byBcXG92ZXJzZXQgYW5kIFxcdW5kZXJzZXQuXG4gICAgICBtY2xhc3MgPSBiaW5yZWxDbGFzcyhiYXNlQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWNsYXNzID0gXCJtcmVsXCI7IC8vIGZvciBcXHN0YWNrcmVsXG4gICAgfVxuXG4gICAgdmFyIGJhc2VPcCA9IHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IGJhc2VBcmcubW9kZSxcbiAgICAgIGxpbWl0czogdHJ1ZSxcbiAgICAgIGFsd2F5c0hhbmRsZVN1cFN1YjogdHJ1ZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICBzdXBwcmVzc0Jhc2VTaGlmdDogZnVuY05hbWUgIT09IFwiXFxcXHN0YWNrcmVsXCIsXG4gICAgICBib2R5OiBkZWZpbmVGdW5jdGlvbl9vcmRhcmd1bWVudChiYXNlQXJnKVxuICAgIH07XG4gICAgdmFyIHN1cHN1YiA9IHtcbiAgICAgIHR5cGU6IFwic3Vwc3ViXCIsXG4gICAgICBtb2RlOiBzaGlmdGVkQXJnLm1vZGUsXG4gICAgICBiYXNlOiBiYXNlT3AsXG4gICAgICBzdXA6IGZ1bmNOYW1lID09PSBcIlxcXFx1bmRlcnNldFwiID8gbnVsbCA6IHNoaWZ0ZWRBcmcsXG4gICAgICBzdWI6IGZ1bmNOYW1lID09PSBcIlxcXFx1bmRlcnNldFwiID8gc2hpZnRlZEFyZyA6IG51bGxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm1jbGFzc1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBtY2xhc3M6IG1jbGFzcyxcbiAgICAgIGJvZHk6IFtzdXBzdWJdLFxuICAgICAgaXNDaGFyYWN0ZXJCb3g6IHV0aWxzLmlzQ2hhcmFjdGVyQm94KHN1cHN1YilcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogbWNsYXNzX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBtY2xhc3NfbWF0aG1sQnVpbGRlclxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvZm9udC5qc1xuLy8gVE9ETyhrZXZpbmIpOiBpbXBsZW1lbnQgXFxcXHNsIGFuZCBcXFxcc2NcblxuXG5cblxuXG5cbnZhciBmb250X2h0bWxCdWlsZGVyID0gZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgdmFyIGZvbnQgPSBncm91cC5mb250O1xuICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMud2l0aEZvbnQoZm9udCk7XG4gIHJldHVybiBidWlsZEhUTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBuZXdPcHRpb25zKTtcbn07XG5cbnZhciBmb250X21hdGhtbEJ1aWxkZXIgPSBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gIHZhciBmb250ID0gZ3JvdXAuZm9udDtcbiAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLndpdGhGb250KGZvbnQpO1xuICByZXR1cm4gYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBuZXdPcHRpb25zKTtcbn07XG5cbnZhciBmb250QWxpYXNlcyA9IHtcbiAgXCJcXFxcQmJiXCI6IFwiXFxcXG1hdGhiYlwiLFxuICBcIlxcXFxib2xkXCI6IFwiXFxcXG1hdGhiZlwiLFxuICBcIlxcXFxmcmFrXCI6IFwiXFxcXG1hdGhmcmFrXCIsXG4gIFwiXFxcXGJtXCI6IFwiXFxcXGJvbGRzeW1ib2xcIlxufTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJmb250XCIsXG4gIG5hbWVzOiBbLy8gc3R5bGVzLCBleGNlcHQgXFxib2xkc3ltYm9sIGRlZmluZWQgYmVsb3dcbiAgXCJcXFxcbWF0aHJtXCIsIFwiXFxcXG1hdGhpdFwiLCBcIlxcXFxtYXRoYmZcIiwgXCJcXFxcbWF0aG5vcm1hbFwiLCAvLyBmYW1pbGllc1xuICBcIlxcXFxtYXRoYmJcIiwgXCJcXFxcbWF0aGNhbFwiLCBcIlxcXFxtYXRoZnJha1wiLCBcIlxcXFxtYXRoc2NyXCIsIFwiXFxcXG1hdGhzZlwiLCBcIlxcXFxtYXRodHRcIiwgLy8gYWxpYXNlcywgZXhjZXB0IFxcYm0gZGVmaW5lZCBiZWxvd1xuICBcIlxcXFxCYmJcIiwgXCJcXFxcYm9sZFwiLCBcIlxcXFxmcmFrXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgZ3JlZWRpbmVzczogMlxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZi5wYXJzZXIsXG4gICAgICAgIGZ1bmNOYW1lID0gX3JlZi5mdW5jTmFtZTtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgdmFyIGZ1bmMgPSBmdW5jTmFtZTtcblxuICAgIGlmIChmdW5jIGluIGZvbnRBbGlhc2VzKSB7XG4gICAgICBmdW5jID0gZm9udEFsaWFzZXNbZnVuY107XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZm9udFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBmb250OiBmdW5jLnNsaWNlKDEpLFxuICAgICAgYm9keTogYm9keVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBmb250X2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBmb250X21hdGhtbEJ1aWxkZXJcbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm1jbGFzc1wiLFxuICBuYW1lczogW1wiXFxcXGJvbGRzeW1ib2xcIiwgXCJcXFxcYm1cIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBncmVlZGluZXNzOiAyXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZjIsIGFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZjIucGFyc2VyO1xuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICB2YXIgaXNDaGFyYWN0ZXJCb3ggPSB1dGlscy5pc0NoYXJhY3RlckJveChib2R5KTsgLy8gYW1zYnN5LnN0eSdzIFxcYm9sZHN5bWJvbCB1c2VzIFxcYmlucmVsIHNwYWNpbmcgdG8gaW5oZXJpdCB0aGVcbiAgICAvLyBhcmd1bWVudCdzIGJpbnxyZWx8b3JkIHN0YXR1c1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibWNsYXNzXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG1jbGFzczogYmlucmVsQ2xhc3MoYm9keSksXG4gICAgICBib2R5OiBbe1xuICAgICAgICB0eXBlOiBcImZvbnRcIixcbiAgICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAgIGZvbnQ6IFwiYm9sZHN5bWJvbFwiLFxuICAgICAgICBib2R5OiBib2R5XG4gICAgICB9XSxcbiAgICAgIGlzQ2hhcmFjdGVyQm94OiBpc0NoYXJhY3RlckJveFxuICAgIH07XG4gIH1cbn0pOyAvLyBPbGQgZm9udCBjaGFuZ2luZyBmdW5jdGlvbnNcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImZvbnRcIixcbiAgbmFtZXM6IFtcIlxcXFxybVwiLCBcIlxcXFxzZlwiLCBcIlxcXFx0dFwiLCBcIlxcXFxiZlwiLCBcIlxcXFxpdFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmMywgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmMy5wYXJzZXIsXG4gICAgICAgIGZ1bmNOYW1lID0gX3JlZjMuZnVuY05hbWUsXG4gICAgICAgIGJyZWFrT25Ub2tlblRleHQgPSBfcmVmMy5icmVha09uVG9rZW5UZXh0O1xuICAgIHZhciBtb2RlID0gcGFyc2VyLm1vZGU7XG4gICAgdmFyIGJvZHkgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKHRydWUsIGJyZWFrT25Ub2tlblRleHQpO1xuICAgIHZhciBzdHlsZSA9IFwibWF0aFwiICsgZnVuY05hbWUuc2xpY2UoMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZm9udFwiLFxuICAgICAgbW9kZTogbW9kZSxcbiAgICAgIGZvbnQ6IHN0eWxlLFxuICAgICAgYm9keToge1xuICAgICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgICBib2R5OiBib2R5XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGZvbnRfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGZvbnRfbWF0aG1sQnVpbGRlclxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvZ2VuZnJhYy5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBnZW5mcmFjX2FkanVzdFN0eWxlID0gZnVuY3Rpb24gYWRqdXN0U3R5bGUoc2l6ZSwgb3JpZ2luYWxTdHlsZSkge1xuICAvLyBGaWd1cmUgb3V0IHdoYXQgc3R5bGUgdGhpcyBmcmFjdGlvbiBzaG91bGQgYmUgaW4gYmFzZWQgb24gdGhlXG4gIC8vIGZ1bmN0aW9uIHVzZWRcbiAgdmFyIHN0eWxlID0gb3JpZ2luYWxTdHlsZTtcblxuICBpZiAoc2l6ZSA9PT0gXCJkaXNwbGF5XCIpIHtcbiAgICAvLyBHZXQgZGlzcGxheSBzdHlsZSBhcyBhIGRlZmF1bHQuXG4gICAgLy8gSWYgaW5jb21pbmcgc3R5bGUgaXMgc3ViL3N1cCwgdXNlIHN0eWxlLnRleHQoKSB0byBnZXQgY29ycmVjdCBzaXplLlxuICAgIHN0eWxlID0gc3R5bGUuaWQgPj0gc3JjX1N0eWxlLlNDUklQVC5pZCA/IHN0eWxlLnRleHQoKSA6IHNyY19TdHlsZS5ESVNQTEFZO1xuICB9IGVsc2UgaWYgKHNpemUgPT09IFwidGV4dFwiICYmIHN0eWxlLnNpemUgPT09IHNyY19TdHlsZS5ESVNQTEFZLnNpemUpIHtcbiAgICAvLyBXZSdyZSBpbiBhIFxcdGZyYWMgYnV0IGluY29taW5nIHN0eWxlIGlzIGRpc3BsYXlzdHlsZSwgc286XG4gICAgc3R5bGUgPSBzcmNfU3R5bGUuVEVYVDtcbiAgfSBlbHNlIGlmIChzaXplID09PSBcInNjcmlwdFwiKSB7XG4gICAgc3R5bGUgPSBzcmNfU3R5bGUuU0NSSVBUO1xuICB9IGVsc2UgaWYgKHNpemUgPT09IFwic2NyaXB0c2NyaXB0XCIpIHtcbiAgICBzdHlsZSA9IHNyY19TdHlsZS5TQ1JJUFRTQ1JJUFQ7XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG52YXIgZ2VuZnJhY19odG1sQnVpbGRlciA9IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gIC8vIEZyYWN0aW9ucyBhcmUgaGFuZGxlZCBpbiB0aGUgVGVYYm9vayBvbiBwYWdlcyA0NDQtNDQ1LCBydWxlcyAxNShhLWUpLlxuICB2YXIgc3R5bGUgPSBnZW5mcmFjX2FkanVzdFN0eWxlKGdyb3VwLnNpemUsIG9wdGlvbnMuc3R5bGUpO1xuICB2YXIgbnN0eWxlID0gc3R5bGUuZnJhY051bSgpO1xuICB2YXIgZHN0eWxlID0gc3R5bGUuZnJhY0RlbigpO1xuICB2YXIgbmV3T3B0aW9ucztcbiAgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUobnN0eWxlKTtcbiAgdmFyIG51bWVybSA9IGJ1aWxkSFRNTF9idWlsZEdyb3VwKGdyb3VwLm51bWVyLCBuZXdPcHRpb25zLCBvcHRpb25zKTtcblxuICBpZiAoZ3JvdXAuY29udGludWVkKSB7XG4gICAgLy8gXFxjZnJhYyBpbnNlcnRzIGEgXFxzdHJ1dCBpbnRvIHRoZSBudW1lcmF0b3IuXG4gICAgLy8gR2V0IFxcc3RydXQgZGltZW5zaW9ucyBmcm9tIFRlWGJvb2sgcGFnZSAzNTMuXG4gICAgdmFyIGhTdHJ1dCA9IDguNSAvIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5wdFBlckVtO1xuICAgIHZhciBkU3RydXQgPSAzLjUgLyBvcHRpb25zLmZvbnRNZXRyaWNzKCkucHRQZXJFbTtcbiAgICBudW1lcm0uaGVpZ2h0ID0gbnVtZXJtLmhlaWdodCA8IGhTdHJ1dCA/IGhTdHJ1dCA6IG51bWVybS5oZWlnaHQ7XG4gICAgbnVtZXJtLmRlcHRoID0gbnVtZXJtLmRlcHRoIDwgZFN0cnV0ID8gZFN0cnV0IDogbnVtZXJtLmRlcHRoO1xuICB9XG5cbiAgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUoZHN0eWxlKTtcbiAgdmFyIGRlbm9tbSA9IGJ1aWxkSFRNTF9idWlsZEdyb3VwKGdyb3VwLmRlbm9tLCBuZXdPcHRpb25zLCBvcHRpb25zKTtcbiAgdmFyIHJ1bGU7XG4gIHZhciBydWxlV2lkdGg7XG4gIHZhciBydWxlU3BhY2luZztcblxuICBpZiAoZ3JvdXAuaGFzQmFyTGluZSkge1xuICAgIGlmIChncm91cC5iYXJTaXplKSB7XG4gICAgICBydWxlV2lkdGggPSB1bml0c19jYWxjdWxhdGVTaXplKGdyb3VwLmJhclNpemUsIG9wdGlvbnMpO1xuICAgICAgcnVsZSA9IGJ1aWxkQ29tbW9uLm1ha2VMaW5lU3BhbihcImZyYWMtbGluZVwiLCBvcHRpb25zLCBydWxlV2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBydWxlID0gYnVpbGRDb21tb24ubWFrZUxpbmVTcGFuKFwiZnJhYy1saW5lXCIsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJ1bGVXaWR0aCA9IHJ1bGUuaGVpZ2h0O1xuICAgIHJ1bGVTcGFjaW5nID0gcnVsZS5oZWlnaHQ7XG4gIH0gZWxzZSB7XG4gICAgcnVsZSA9IG51bGw7XG4gICAgcnVsZVdpZHRoID0gMDtcbiAgICBydWxlU3BhY2luZyA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kZWZhdWx0UnVsZVRoaWNrbmVzcztcbiAgfSAvLyBSdWxlIDE1YlxuXG5cbiAgdmFyIG51bVNoaWZ0O1xuICB2YXIgY2xlYXJhbmNlO1xuICB2YXIgZGVub21TaGlmdDtcblxuICBpZiAoc3R5bGUuc2l6ZSA9PT0gc3JjX1N0eWxlLkRJU1BMQVkuc2l6ZSB8fCBncm91cC5zaXplID09PSBcImRpc3BsYXlcIikge1xuICAgIG51bVNoaWZ0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLm51bTE7XG5cbiAgICBpZiAocnVsZVdpZHRoID4gMCkge1xuICAgICAgY2xlYXJhbmNlID0gMyAqIHJ1bGVTcGFjaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhcmFuY2UgPSA3ICogcnVsZVNwYWNpbmc7XG4gICAgfVxuXG4gICAgZGVub21TaGlmdCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kZW5vbTE7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHJ1bGVXaWR0aCA+IDApIHtcbiAgICAgIG51bVNoaWZ0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLm51bTI7XG4gICAgICBjbGVhcmFuY2UgPSBydWxlU3BhY2luZztcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtU2hpZnQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkubnVtMztcbiAgICAgIGNsZWFyYW5jZSA9IDMgKiBydWxlU3BhY2luZztcbiAgICB9XG5cbiAgICBkZW5vbVNoaWZ0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLmRlbm9tMjtcbiAgfVxuXG4gIHZhciBmcmFjO1xuXG4gIGlmICghcnVsZSkge1xuICAgIC8vIFJ1bGUgMTVjXG4gICAgdmFyIGNhbmRpZGF0ZUNsZWFyYW5jZSA9IG51bVNoaWZ0IC0gbnVtZXJtLmRlcHRoIC0gKGRlbm9tbS5oZWlnaHQgLSBkZW5vbVNoaWZ0KTtcblxuICAgIGlmIChjYW5kaWRhdGVDbGVhcmFuY2UgPCBjbGVhcmFuY2UpIHtcbiAgICAgIG51bVNoaWZ0ICs9IDAuNSAqIChjbGVhcmFuY2UgLSBjYW5kaWRhdGVDbGVhcmFuY2UpO1xuICAgICAgZGVub21TaGlmdCArPSAwLjUgKiAoY2xlYXJhbmNlIC0gY2FuZGlkYXRlQ2xlYXJhbmNlKTtcbiAgICB9XG5cbiAgICBmcmFjID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJpbmRpdmlkdWFsU2hpZnRcIixcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogZGVub21tLFxuICAgICAgICBzaGlmdDogZGVub21TaGlmdFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogbnVtZXJtLFxuICAgICAgICBzaGlmdDogLW51bVNoaWZ0XG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIFJ1bGUgMTVkXG4gICAgdmFyIGF4aXNIZWlnaHQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodDtcblxuICAgIGlmIChudW1TaGlmdCAtIG51bWVybS5kZXB0aCAtIChheGlzSGVpZ2h0ICsgMC41ICogcnVsZVdpZHRoKSA8IGNsZWFyYW5jZSkge1xuICAgICAgbnVtU2hpZnQgKz0gY2xlYXJhbmNlIC0gKG51bVNoaWZ0IC0gbnVtZXJtLmRlcHRoIC0gKGF4aXNIZWlnaHQgKyAwLjUgKiBydWxlV2lkdGgpKTtcbiAgICB9XG5cbiAgICBpZiAoYXhpc0hlaWdodCAtIDAuNSAqIHJ1bGVXaWR0aCAtIChkZW5vbW0uaGVpZ2h0IC0gZGVub21TaGlmdCkgPCBjbGVhcmFuY2UpIHtcbiAgICAgIGRlbm9tU2hpZnQgKz0gY2xlYXJhbmNlIC0gKGF4aXNIZWlnaHQgLSAwLjUgKiBydWxlV2lkdGggLSAoZGVub21tLmhlaWdodCAtIGRlbm9tU2hpZnQpKTtcbiAgICB9XG5cbiAgICB2YXIgbWlkU2hpZnQgPSAtKGF4aXNIZWlnaHQgLSAwLjUgKiBydWxlV2lkdGgpO1xuICAgIGZyYWMgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBkZW5vbW0sXG4gICAgICAgIHNoaWZ0OiBkZW5vbVNoaWZ0XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBydWxlLFxuICAgICAgICBzaGlmdDogbWlkU2hpZnRcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IG51bWVybSxcbiAgICAgICAgc2hpZnQ6IC1udW1TaGlmdFxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgfSAvLyBTaW5jZSB3ZSBtYW51YWxseSBjaGFuZ2UgdGhlIHN0eWxlIHNvbWV0aW1lcyAod2l0aCBcXGRmcmFjIG9yIFxcdGZyYWMpLFxuICAvLyBhY2NvdW50IGZvciB0aGUgcG9zc2libGUgc2l6ZSBjaGFuZ2UgaGVyZS5cblxuXG4gIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlKTtcbiAgZnJhYy5oZWlnaHQgKj0gbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllciAvIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gIGZyYWMuZGVwdGggKj0gbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllciAvIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7IC8vIFJ1bGUgMTVlXG5cbiAgdmFyIGRlbGltU2l6ZTtcblxuICBpZiAoc3R5bGUuc2l6ZSA9PT0gc3JjX1N0eWxlLkRJU1BMQVkuc2l6ZSkge1xuICAgIGRlbGltU2l6ZSA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kZWxpbTE7XG4gIH0gZWxzZSB7XG4gICAgZGVsaW1TaXplID0gb3B0aW9ucy5mb250TWV0cmljcygpLmRlbGltMjtcbiAgfVxuXG4gIHZhciBsZWZ0RGVsaW07XG4gIHZhciByaWdodERlbGltO1xuXG4gIGlmIChncm91cC5sZWZ0RGVsaW0gPT0gbnVsbCkge1xuICAgIGxlZnREZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtcIm1vcGVuXCJdKTtcbiAgfSBlbHNlIHtcbiAgICBsZWZ0RGVsaW0gPSBkZWxpbWl0ZXIuY3VzdG9tU2l6ZWREZWxpbShncm91cC5sZWZ0RGVsaW0sIGRlbGltU2l6ZSwgdHJ1ZSwgb3B0aW9ucy5oYXZpbmdTdHlsZShzdHlsZSksIGdyb3VwLm1vZGUsIFtcIm1vcGVuXCJdKTtcbiAgfVxuXG4gIGlmIChncm91cC5jb250aW51ZWQpIHtcbiAgICByaWdodERlbGltID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW10pOyAvLyB6ZXJvIHdpZHRoIGZvciBcXGNmcmFjXG4gIH0gZWxzZSBpZiAoZ3JvdXAucmlnaHREZWxpbSA9PSBudWxsKSB7XG4gICAgcmlnaHREZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtcIm1jbG9zZVwiXSk7XG4gIH0gZWxzZSB7XG4gICAgcmlnaHREZWxpbSA9IGRlbGltaXRlci5jdXN0b21TaXplZERlbGltKGdyb3VwLnJpZ2h0RGVsaW0sIGRlbGltU2l6ZSwgdHJ1ZSwgb3B0aW9ucy5oYXZpbmdTdHlsZShzdHlsZSksIGdyb3VwLm1vZGUsIFtcIm1jbG9zZVwiXSk7XG4gIH1cblxuICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiXS5jb25jYXQobmV3T3B0aW9ucy5zaXppbmdDbGFzc2VzKG9wdGlvbnMpKSwgW2xlZnREZWxpbSwgYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibWZyYWNcIl0sIFtmcmFjXSksIHJpZ2h0RGVsaW1dLCBvcHRpb25zKTtcbn07XG5cbnZhciBnZW5mcmFjX21hdGhtbEJ1aWxkZXIgPSBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtZnJhY1wiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5udW1lciwgb3B0aW9ucyksIGJ1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZ3JvdXAuZGVub20sIG9wdGlvbnMpXSk7XG5cbiAgaWYgKCFncm91cC5oYXNCYXJMaW5lKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsaW5ldGhpY2tuZXNzXCIsIFwiMHB4XCIpO1xuICB9IGVsc2UgaWYgKGdyb3VwLmJhclNpemUpIHtcbiAgICB2YXIgcnVsZVdpZHRoID0gdW5pdHNfY2FsY3VsYXRlU2l6ZShncm91cC5iYXJTaXplLCBvcHRpb25zKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImxpbmV0aGlja25lc3NcIiwgcnVsZVdpZHRoICsgXCJlbVwiKTtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IGdlbmZyYWNfYWRqdXN0U3R5bGUoZ3JvdXAuc2l6ZSwgb3B0aW9ucy5zdHlsZSk7XG5cbiAgaWYgKHN0eWxlLnNpemUgIT09IG9wdGlvbnMuc3R5bGUuc2l6ZSkge1xuICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBbbm9kZV0pO1xuICAgIHZhciBpc0Rpc3BsYXkgPSBzdHlsZS5zaXplID09PSBzcmNfU3R5bGUuRElTUExBWS5zaXplID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkaXNwbGF5c3R5bGVcIiwgaXNEaXNwbGF5KTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcInNjcmlwdGxldmVsXCIsIFwiMFwiKTtcbiAgfVxuXG4gIGlmIChncm91cC5sZWZ0RGVsaW0gIT0gbnVsbCB8fCBncm91cC5yaWdodERlbGltICE9IG51bGwpIHtcbiAgICB2YXIgd2l0aERlbGltcyA9IFtdO1xuXG4gICAgaWYgKGdyb3VwLmxlZnREZWxpbSAhPSBudWxsKSB7XG4gICAgICB2YXIgbGVmdE9wID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoZ3JvdXAubGVmdERlbGltLnJlcGxhY2UoXCJcXFxcXCIsIFwiXCIpKV0pO1xuICAgICAgbGVmdE9wLnNldEF0dHJpYnV0ZShcImZlbmNlXCIsIFwidHJ1ZVwiKTtcbiAgICAgIHdpdGhEZWxpbXMucHVzaChsZWZ0T3ApO1xuICAgIH1cblxuICAgIHdpdGhEZWxpbXMucHVzaChub2RlKTtcblxuICAgIGlmIChncm91cC5yaWdodERlbGltICE9IG51bGwpIHtcbiAgICAgIHZhciByaWdodE9wID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoZ3JvdXAucmlnaHREZWxpbS5yZXBsYWNlKFwiXFxcXFwiLCBcIlwiKSldKTtcbiAgICAgIHJpZ2h0T3Auc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgICAgd2l0aERlbGltcy5wdXNoKHJpZ2h0T3ApO1xuICAgIH1cblxuICAgIHJldHVybiBidWlsZE1hdGhNTF9tYWtlUm93KHdpdGhEZWxpbXMpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICBuYW1lczogW1wiXFxcXGNmcmFjXCIsIFwiXFxcXGRmcmFjXCIsIFwiXFxcXGZyYWNcIiwgXCJcXFxcdGZyYWNcIiwgXCJcXFxcZGJpbm9tXCIsIFwiXFxcXGJpbm9tXCIsIFwiXFxcXHRiaW5vbVwiLCBcIlxcXFxcXFxcYXRvcGZyYWNcIiwgLy8gY2Fu4oCZdCBiZSBlbnRlcmVkIGRpcmVjdGx5XG4gIFwiXFxcXFxcXFxicmFjZWZyYWNcIiwgXCJcXFxcXFxcXGJyYWNrZnJhY1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGdyZWVkaW5lc3M6IDJcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYucGFyc2VyLFxuICAgICAgICBmdW5jTmFtZSA9IF9yZWYuZnVuY05hbWU7XG4gICAgdmFyIG51bWVyID0gYXJnc1swXTtcbiAgICB2YXIgZGVub20gPSBhcmdzWzFdO1xuICAgIHZhciBoYXNCYXJMaW5lO1xuICAgIHZhciBsZWZ0RGVsaW0gPSBudWxsO1xuICAgIHZhciByaWdodERlbGltID0gbnVsbDtcbiAgICB2YXIgc2l6ZSA9IFwiYXV0b1wiO1xuXG4gICAgc3dpdGNoIChmdW5jTmFtZSkge1xuICAgICAgY2FzZSBcIlxcXFxjZnJhY1wiOlxuICAgICAgY2FzZSBcIlxcXFxkZnJhY1wiOlxuICAgICAgY2FzZSBcIlxcXFxmcmFjXCI6XG4gICAgICBjYXNlIFwiXFxcXHRmcmFjXCI6XG4gICAgICAgIGhhc0JhckxpbmUgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlxcXFxcXFxcYXRvcGZyYWNcIjpcbiAgICAgICAgaGFzQmFyTGluZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlxcXFxkYmlub21cIjpcbiAgICAgIGNhc2UgXCJcXFxcYmlub21cIjpcbiAgICAgIGNhc2UgXCJcXFxcdGJpbm9tXCI6XG4gICAgICAgIGhhc0JhckxpbmUgPSBmYWxzZTtcbiAgICAgICAgbGVmdERlbGltID0gXCIoXCI7XG4gICAgICAgIHJpZ2h0RGVsaW0gPSBcIilcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcXFxcXGJyYWNlZnJhY1wiOlxuICAgICAgICBoYXNCYXJMaW5lID0gZmFsc2U7XG4gICAgICAgIGxlZnREZWxpbSA9IFwiXFxcXHtcIjtcbiAgICAgICAgcmlnaHREZWxpbSA9IFwiXFxcXH1cIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcXFxcXGJyYWNrZnJhY1wiOlxuICAgICAgICBoYXNCYXJMaW5lID0gZmFsc2U7XG4gICAgICAgIGxlZnREZWxpbSA9IFwiW1wiO1xuICAgICAgICByaWdodERlbGltID0gXCJdXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgZ2VuZnJhYyBjb21tYW5kXCIpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZnVuY05hbWUpIHtcbiAgICAgIGNhc2UgXCJcXFxcY2ZyYWNcIjpcbiAgICAgIGNhc2UgXCJcXFxcZGZyYWNcIjpcbiAgICAgIGNhc2UgXCJcXFxcZGJpbm9tXCI6XG4gICAgICAgIHNpemUgPSBcImRpc3BsYXlcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcdGZyYWNcIjpcbiAgICAgIGNhc2UgXCJcXFxcdGJpbm9tXCI6XG4gICAgICAgIHNpemUgPSBcInRleHRcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBjb250aW51ZWQ6IGZ1bmNOYW1lID09PSBcIlxcXFxjZnJhY1wiLFxuICAgICAgbnVtZXI6IG51bWVyLFxuICAgICAgZGVub206IGRlbm9tLFxuICAgICAgaGFzQmFyTGluZTogaGFzQmFyTGluZSxcbiAgICAgIGxlZnREZWxpbTogbGVmdERlbGltLFxuICAgICAgcmlnaHREZWxpbTogcmlnaHREZWxpbSxcbiAgICAgIHNpemU6IHNpemUsXG4gICAgICBiYXJTaXplOiBudWxsXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGdlbmZyYWNfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGdlbmZyYWNfbWF0aG1sQnVpbGRlclxufSk7IC8vIEluZml4IGdlbmVyYWxpemVkIGZyYWN0aW9ucyAtLSB0aGVzZSBhcmUgbm90IHJlbmRlcmVkIGRpcmVjdGx5LCBidXQgcmVwbGFjZWRcbi8vIGltbWVkaWF0ZWx5IGJ5IG9uZSBvZiB0aGUgdmFyaWFudHMgYWJvdmUuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJpbmZpeFwiLFxuICBuYW1lczogW1wiXFxcXG92ZXJcIiwgXCJcXFxcY2hvb3NlXCIsIFwiXFxcXGF0b3BcIiwgXCJcXFxcYnJhY2VcIiwgXCJcXFxcYnJhY2tcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBpbmZpeDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYyKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYyLnBhcnNlcixcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmMi5mdW5jTmFtZSxcbiAgICAgICAgdG9rZW4gPSBfcmVmMi50b2tlbjtcbiAgICB2YXIgcmVwbGFjZVdpdGg7XG5cbiAgICBzd2l0Y2ggKGZ1bmNOYW1lKSB7XG4gICAgICBjYXNlIFwiXFxcXG92ZXJcIjpcbiAgICAgICAgcmVwbGFjZVdpdGggPSBcIlxcXFxmcmFjXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiXFxcXGNob29zZVwiOlxuICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXGJpbm9tXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiXFxcXGF0b3BcIjpcbiAgICAgICAgcmVwbGFjZVdpdGggPSBcIlxcXFxcXFxcYXRvcGZyYWNcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcYnJhY2VcIjpcbiAgICAgICAgcmVwbGFjZVdpdGggPSBcIlxcXFxcXFxcYnJhY2VmcmFjXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiXFxcXGJyYWNrXCI6XG4gICAgICAgIHJlcGxhY2VXaXRoID0gXCJcXFxcXFxcXGJyYWNrZnJhY1wiO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIGluZml4IGdlbmZyYWMgY29tbWFuZFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpbmZpeFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICByZXBsYWNlV2l0aDogcmVwbGFjZVdpdGgsXG4gICAgICB0b2tlbjogdG9rZW5cbiAgICB9O1xuICB9XG59KTtcbnZhciBzdHlsQXJyYXkgPSBbXCJkaXNwbGF5XCIsIFwidGV4dFwiLCBcInNjcmlwdFwiLCBcInNjcmlwdHNjcmlwdFwiXTtcblxudmFyIGRlbGltRnJvbVZhbHVlID0gZnVuY3Rpb24gZGVsaW1Gcm9tVmFsdWUoZGVsaW1TdHJpbmcpIHtcbiAgdmFyIGRlbGltID0gbnVsbDtcblxuICBpZiAoZGVsaW1TdHJpbmcubGVuZ3RoID4gMCkge1xuICAgIGRlbGltID0gZGVsaW1TdHJpbmc7XG4gICAgZGVsaW0gPSBkZWxpbSA9PT0gXCIuXCIgPyBudWxsIDogZGVsaW07XG4gIH1cblxuICByZXR1cm4gZGVsaW07XG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICBuYW1lczogW1wiXFxcXGdlbmZyYWNcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogNixcbiAgICBncmVlZGluZXNzOiA2LFxuICAgIGFyZ1R5cGVzOiBbXCJtYXRoXCIsIFwibWF0aFwiLCBcInNpemVcIiwgXCJ0ZXh0XCIsIFwibWF0aFwiLCBcIm1hdGhcIl1cbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmMywgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmMy5wYXJzZXI7XG4gICAgdmFyIG51bWVyID0gYXJnc1s0XTtcbiAgICB2YXIgZGVub20gPSBhcmdzWzVdOyAvLyBMb29rIGludG8gdGhlIHBhcnNlIG5vZGVzIHRvIGdldCB0aGUgZGVzaXJlZCBkZWxpbWl0ZXJzLlxuXG4gICAgdmFyIGxlZnROb2RlID0gY2hlY2tOb2RlVHlwZShhcmdzWzBdLCBcImF0b21cIik7XG5cbiAgICBpZiAobGVmdE5vZGUpIHtcbiAgICAgIGxlZnROb2RlID0gYXNzZXJ0QXRvbUZhbWlseShhcmdzWzBdLCBcIm9wZW5cIik7XG4gICAgfVxuXG4gICAgdmFyIGxlZnREZWxpbSA9IGxlZnROb2RlID8gZGVsaW1Gcm9tVmFsdWUobGVmdE5vZGUudGV4dCkgOiBudWxsO1xuICAgIHZhciByaWdodE5vZGUgPSBjaGVja05vZGVUeXBlKGFyZ3NbMV0sIFwiYXRvbVwiKTtcblxuICAgIGlmIChyaWdodE5vZGUpIHtcbiAgICAgIHJpZ2h0Tm9kZSA9IGFzc2VydEF0b21GYW1pbHkoYXJnc1sxXSwgXCJjbG9zZVwiKTtcbiAgICB9XG5cbiAgICB2YXIgcmlnaHREZWxpbSA9IHJpZ2h0Tm9kZSA/IGRlbGltRnJvbVZhbHVlKHJpZ2h0Tm9kZS50ZXh0KSA6IG51bGw7XG4gICAgdmFyIGJhck5vZGUgPSBhc3NlcnROb2RlVHlwZShhcmdzWzJdLCBcInNpemVcIik7XG4gICAgdmFyIGhhc0JhckxpbmU7XG4gICAgdmFyIGJhclNpemUgPSBudWxsO1xuXG4gICAgaWYgKGJhck5vZGUuaXNCbGFuaykge1xuICAgICAgLy8gXFxnZW5mcmFjIGFjdHMgZGlmZmVyZW50bHkgdGhhbiBcXGFib3ZlLlxuICAgICAgLy8gXFxnZW5mcmFjIHRyZWF0cyBhbiBlbXB0eSBzaXplIGdyb3VwIGFzIGEgc2lnbmFsIHRvIHVzZSBhXG4gICAgICAvLyBzdGFuZGFyZCBiYXIgc2l6ZS4gXFxhYm92ZSB3b3VsZCBzZWUgc2l6ZSA9IDAgYW5kIG9taXQgdGhlIGJhci5cbiAgICAgIGhhc0JhckxpbmUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXJTaXplID0gYmFyTm9kZS52YWx1ZTtcbiAgICAgIGhhc0JhckxpbmUgPSBiYXJTaXplLm51bWJlciA+IDA7XG4gICAgfSAvLyBGaW5kIG91dCBpZiB3ZSB3YW50IGRpc3BsYXlzdHlsZSwgdGV4dHN0eWxlLCBldGMuXG5cblxuICAgIHZhciBzaXplID0gXCJhdXRvXCI7XG4gICAgdmFyIHN0eWwgPSBjaGVja05vZGVUeXBlKGFyZ3NbM10sIFwib3JkZ3JvdXBcIik7XG5cbiAgICBpZiAoc3R5bCkge1xuICAgICAgaWYgKHN0eWwuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB0ZXh0T3JkID0gYXNzZXJ0Tm9kZVR5cGUoc3R5bC5ib2R5WzBdLCBcInRleHRvcmRcIik7XG4gICAgICAgIHNpemUgPSBzdHlsQXJyYXlbTnVtYmVyKHRleHRPcmQudGV4dCldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1szXSwgXCJ0ZXh0b3JkXCIpO1xuICAgICAgc2l6ZSA9IHN0eWxBcnJheVtOdW1iZXIoc3R5bC50ZXh0KV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBudW1lcjogbnVtZXIsXG4gICAgICBkZW5vbTogZGVub20sXG4gICAgICBjb250aW51ZWQ6IGZhbHNlLFxuICAgICAgaGFzQmFyTGluZTogaGFzQmFyTGluZSxcbiAgICAgIGJhclNpemU6IGJhclNpemUsXG4gICAgICBsZWZ0RGVsaW06IGxlZnREZWxpbSxcbiAgICAgIHJpZ2h0RGVsaW06IHJpZ2h0RGVsaW0sXG4gICAgICBzaXplOiBzaXplXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGdlbmZyYWNfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGdlbmZyYWNfbWF0aG1sQnVpbGRlclxufSk7IC8vIFxcYWJvdmUgaXMgYW4gaW5maXggZnJhY3Rpb24gdGhhdCBhbHNvIGRlZmluZXMgYSBmcmFjdGlvbiBiYXIgc2l6ZS5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImluZml4XCIsXG4gIG5hbWVzOiBbXCJcXFxcYWJvdmVcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiXSxcbiAgICBpbmZpeDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWY0LCBhcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWY0LnBhcnNlcixcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmNC5mdW5jTmFtZSxcbiAgICAgICAgdG9rZW4gPSBfcmVmNC50b2tlbjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpbmZpeFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICByZXBsYWNlV2l0aDogXCJcXFxcXFxcXGFib3ZlZnJhY1wiLFxuICAgICAgc2l6ZTogYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJzaXplXCIpLnZhbHVlLFxuICAgICAgdG9rZW46IHRva2VuXG4gICAgfTtcbiAgfVxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICBuYW1lczogW1wiXFxcXFxcXFxhYm92ZWZyYWNcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMyxcbiAgICBhcmdUeXBlczogW1wibWF0aFwiLCBcInNpemVcIiwgXCJtYXRoXCJdXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZjUsIGFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZjUucGFyc2VyLFxuICAgICAgICBmdW5jTmFtZSA9IF9yZWY1LmZ1bmNOYW1lO1xuICAgIHZhciBudW1lciA9IGFyZ3NbMF07XG4gICAgdmFyIGJhclNpemUgPSBhc3NlcnQoYXNzZXJ0Tm9kZVR5cGUoYXJnc1sxXSwgXCJpbmZpeFwiKS5zaXplKTtcbiAgICB2YXIgZGVub20gPSBhcmdzWzJdO1xuICAgIHZhciBoYXNCYXJMaW5lID0gYmFyU2l6ZS5udW1iZXIgPiAwO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImdlbmZyYWNcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbnVtZXI6IG51bWVyLFxuICAgICAgZGVub206IGRlbm9tLFxuICAgICAgY29udGludWVkOiBmYWxzZSxcbiAgICAgIGhhc0JhckxpbmU6IGhhc0JhckxpbmUsXG4gICAgICBiYXJTaXplOiBiYXJTaXplLFxuICAgICAgbGVmdERlbGltOiBudWxsLFxuICAgICAgcmlnaHREZWxpbTogbnVsbCxcbiAgICAgIHNpemU6IFwiYXV0b1wiXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGdlbmZyYWNfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGdlbmZyYWNfbWF0aG1sQnVpbGRlclxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvaG9yaXpCcmFjZS5qc1xuXG5cblxuXG5cblxuXG5cbi8vIE5PVEU6IFVubGlrZSBtb3N0IGBodG1sQnVpbGRlcmBzLCB0aGlzIG9uZSBoYW5kbGVzIG5vdCBvbmx5IFwiaG9yaXpCcmFjZVwiLCBidXRcbnZhciBob3JpekJyYWNlX2h0bWxCdWlsZGVyID0gZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JwLCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7IC8vIFB1bGwgb3V0IHRoZSBgUGFyc2VOb2RlPFwiaG9yaXpCcmFjZVwiPmAgaWYgYGdycGAgaXMgYSBcInN1cHN1YlwiIG5vZGUuXG5cbiAgdmFyIHN1cFN1Ykdyb3VwO1xuICB2YXIgZ3JvdXA7XG4gIHZhciBzdXBTdWIgPSBjaGVja05vZGVUeXBlKGdycCwgXCJzdXBzdWJcIik7XG5cbiAgaWYgKHN1cFN1Yikge1xuICAgIC8vIFJlZjogTGFUZVggc291cmNlMmU6IH19fX1cXGxpbWl0c31cbiAgICAvLyBpLmUuIExhVGVYIHRyZWF0cyB0aGUgYnJhY2Ugc2ltaWxhciB0byBhbiBvcCBhbmQgcGFzc2VzIGl0XG4gICAgLy8gd2l0aCBcXGxpbWl0cywgc28gd2UgbmVlZCB0byBhc3NpZ24gc3Vwc3ViIHN0eWxlLlxuICAgIHN1cFN1Ykdyb3VwID0gc3VwU3ViLnN1cCA/IGJ1aWxkSFRNTF9idWlsZEdyb3VwKHN1cFN1Yi5zdXAsIG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUuc3VwKCkpLCBvcHRpb25zKSA6IGJ1aWxkSFRNTF9idWlsZEdyb3VwKHN1cFN1Yi5zdWIsIG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUuc3ViKCkpLCBvcHRpb25zKTtcbiAgICBncm91cCA9IGFzc2VydE5vZGVUeXBlKHN1cFN1Yi5iYXNlLCBcImhvcml6QnJhY2VcIik7XG4gIH0gZWxzZSB7XG4gICAgZ3JvdXAgPSBhc3NlcnROb2RlVHlwZShncnAsIFwiaG9yaXpCcmFjZVwiKTtcbiAgfSAvLyBCdWlsZCB0aGUgYmFzZSBncm91cFxuXG5cbiAgdmFyIGJvZHkgPSBidWlsZEhUTUxfYnVpbGRHcm91cChncm91cC5iYXNlLCBvcHRpb25zLmhhdmluZ0Jhc2VTdHlsZShzcmNfU3R5bGUuRElTUExBWSkpOyAvLyBDcmVhdGUgdGhlIHN0cmV0Y2h5IGVsZW1lbnRcblxuICB2YXIgYnJhY2VCb2R5ID0gc3RyZXRjaHkuc3ZnU3Bhbihncm91cCwgb3B0aW9ucyk7IC8vIEdlbmVyYXRlIHRoZSB2bGlzdCwgd2l0aCB0aGUgYXBwcm9wcmlhdGUga2VybnMgICAgICAgIOKUj+KUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUk1xuICAvLyBUaGlzIGZpcnN0IHZsaXN0IGNvbnRhaW5zIHRoZSBjb250ZW50IGFuZCB0aGUgYnJhY2U6ICAgZXF1YXRpb25cblxuICB2YXIgdmxpc3Q7XG5cbiAgaWYgKGdyb3VwLmlzT3Zlcikge1xuICAgIHZsaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJmaXJzdEJhc2VsaW5lXCIsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGJvZHlcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IDAuMVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYnJhY2VCb2R5XG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpOyAvLyAkRmxvd0ZpeE1lOiBSZXBsYWNlIHRoaXMgd2l0aCBwYXNzaW5nIFwic3ZnLWFsaWduXCIgaW50byBtYWtlVkxpc3QuXG5cbiAgICB2bGlzdC5jaGlsZHJlblswXS5jaGlsZHJlblswXS5jaGlsZHJlblsxXS5jbGFzc2VzLnB1c2goXCJzdmctYWxpZ25cIik7XG4gIH0gZWxzZSB7XG4gICAgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImJvdHRvbVwiLFxuICAgICAgcG9zaXRpb25EYXRhOiBib2R5LmRlcHRoICsgMC4xICsgYnJhY2VCb2R5LmhlaWdodCxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYnJhY2VCb2R5XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiAwLjFcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGJvZHlcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7IC8vICRGbG93Rml4TWU6IFJlcGxhY2UgdGhpcyB3aXRoIHBhc3NpbmcgXCJzdmctYWxpZ25cIiBpbnRvIG1ha2VWTGlzdC5cblxuICAgIHZsaXN0LmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLmNsYXNzZXMucHVzaChcInN2Zy1hbGlnblwiKTtcbiAgfVxuXG4gIGlmIChzdXBTdWJHcm91cCkge1xuICAgIC8vIFRvIHdyaXRlIHRoZSBzdXBzdWIsIHdyYXAgdGhlIGZpcnN0IHZsaXN0IGluIGFub3RoZXIgdmxpc3Q6XG4gICAgLy8gVGhleSBjYW4ndCBhbGwgZ28gaW4gdGhlIHNhbWUgdmxpc3QsIGJlY2F1c2UgdGhlIG5vdGUgbWlnaHQgYmVcbiAgICAvLyB3aWRlciB0aGFuIHRoZSBlcXVhdGlvbi4gV2Ugd2FudCB0aGUgZXF1YXRpb24gdG8gY29udHJvbCB0aGVcbiAgICAvLyBicmFjZSB3aWR0aC5cbiAgICAvLyAgICAgIG5vdGUgICAgICAgICAgbG9uZyBub3RlICAgICAgICAgICBsb25nIG5vdGVcbiAgICAvLyAgIOKUj+KUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUkyAgIG9yICAgIOKUj+KUgeKUgeKUgeKUkyAgICAgbm90ICAgIOKUj+KUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUk1xuICAgIC8vICAgIGVxdWF0aW9uICAgICAgICAgICBlcW4gICAgICAgICAgICAgICAgIGVxblxuICAgIHZhciB2U3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgZ3JvdXAuaXNPdmVyID8gXCJtb3ZlclwiIDogXCJtdW5kZXJcIl0sIFt2bGlzdF0sIG9wdGlvbnMpO1xuXG4gICAgaWYgKGdyb3VwLmlzT3Zlcikge1xuICAgICAgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgICBwb3NpdGlvblR5cGU6IFwiZmlyc3RCYXNlbGluZVwiLFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiB2U3BhblxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgICAgc2l6ZTogMC4yXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiBzdXBTdWJHcm91cFxuICAgICAgICB9XVxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZsaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgICAgcG9zaXRpb25UeXBlOiBcImJvdHRvbVwiLFxuICAgICAgICBwb3NpdGlvbkRhdGE6IHZTcGFuLmRlcHRoICsgMC4yICsgc3VwU3ViR3JvdXAuaGVpZ2h0ICsgc3VwU3ViR3JvdXAuZGVwdGgsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IHN1cFN1Ykdyb3VwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgICBzaXplOiAwLjJcbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IHZTcGFuXG4gICAgICAgIH1dXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiLCBncm91cC5pc092ZXIgPyBcIm1vdmVyXCIgOiBcIm11bmRlclwiXSwgW3ZsaXN0XSwgb3B0aW9ucyk7XG59O1xuXG52YXIgaG9yaXpCcmFjZV9tYXRobWxCdWlsZGVyID0gZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICB2YXIgYWNjZW50Tm9kZSA9IHN0cmV0Y2h5Lm1hdGhNTG5vZGUoZ3JvdXAubGFiZWwpO1xuICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoZ3JvdXAuaXNPdmVyID8gXCJtb3ZlclwiIDogXCJtdW5kZXJcIiwgW2J1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZ3JvdXAuYmFzZSwgb3B0aW9ucyksIGFjY2VudE5vZGVdKTtcbn07IC8vIEhvcml6b250YWwgc3RyZXRjaHkgYnJhY2VzXG5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImhvcml6QnJhY2VcIixcbiAgbmFtZXM6IFtcIlxcXFxvdmVyYnJhY2VcIiwgXCJcXFxcdW5kZXJicmFjZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmLnBhcnNlcixcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmLmZ1bmNOYW1lO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImhvcml6QnJhY2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgaXNPdmVyOiAvXlxcXFxvdmVyLy50ZXN0KGZ1bmNOYW1lKSxcbiAgICAgIGJhc2U6IGFyZ3NbMF1cbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogaG9yaXpCcmFjZV9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogaG9yaXpCcmFjZV9tYXRobWxCdWlsZGVyXG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9ocmVmLmpzXG5cblxuXG5cblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaHJlZlwiLFxuICBuYW1lczogW1wiXFxcXGhyZWZcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBhcmdUeXBlczogW1widXJsXCIsIFwib3JpZ2luYWxcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZi5wYXJzZXI7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzFdO1xuICAgIHZhciBocmVmID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJ1cmxcIikudXJsO1xuXG4gICAgaWYgKCFwYXJzZXIuc2V0dGluZ3MuaXNUcnVzdGVkKHtcbiAgICAgIGNvbW1hbmQ6IFwiXFxcXGhyZWZcIixcbiAgICAgIHVybDogaHJlZlxuICAgIH0pKSB7XG4gICAgICByZXR1cm4gcGFyc2VyLmZvcm1hdFVuc3VwcG9ydGVkQ21kKFwiXFxcXGhyZWZcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaHJlZlwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBocmVmOiBocmVmLFxuICAgICAgYm9keTogZGVmaW5lRnVuY3Rpb25fb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBidWlsZEhUTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMsIGZhbHNlKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUFuY2hvcihncm91cC5ocmVmLCBbXSwgZWxlbWVudHMsIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG1hdGggPSBidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAuYm9keSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoIShtYXRoIGluc3RhbmNlb2YgbWF0aE1MVHJlZV9NYXRoTm9kZSkpIHtcbiAgICAgIG1hdGggPSBuZXcgbWF0aE1MVHJlZV9NYXRoTm9kZShcIm1yb3dcIiwgW21hdGhdKTtcbiAgICB9XG5cbiAgICBtYXRoLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgZ3JvdXAuaHJlZik7XG4gICAgcmV0dXJuIG1hdGg7XG4gIH1cbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImhyZWZcIixcbiAgbmFtZXM6IFtcIlxcXFx1cmxcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1widXJsXCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmMiwgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmMi5wYXJzZXI7XG4gICAgdmFyIGhyZWYgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInVybFwiKS51cmw7XG5cbiAgICBpZiAoIXBhcnNlci5zZXR0aW5ncy5pc1RydXN0ZWQoe1xuICAgICAgY29tbWFuZDogXCJcXFxcdXJsXCIsXG4gICAgICB1cmw6IGhyZWZcbiAgICB9KSkge1xuICAgICAgcmV0dXJuIHBhcnNlci5mb3JtYXRVbnN1cHBvcnRlZENtZChcIlxcXFx1cmxcIik7XG4gICAgfVxuXG4gICAgdmFyIGNoYXJzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhyZWYubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gaHJlZltpXTtcblxuICAgICAgaWYgKGMgPT09IFwiflwiKSB7XG4gICAgICAgIGMgPSBcIlxcXFx0ZXh0YXNjaWl0aWxkZVwiO1xuICAgICAgfVxuXG4gICAgICBjaGFycy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICB0ZXh0OiBjXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgYm9keSA9IHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBmb250OiBcIlxcXFx0ZXh0dHRcIixcbiAgICAgIGJvZHk6IGNoYXJzXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJocmVmXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGhyZWY6IGhyZWYsXG4gICAgICBib2R5OiBkZWZpbmVGdW5jdGlvbl9vcmRhcmd1bWVudChib2R5KVxuICAgIH07XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2h0bWxtYXRobWwuanNcblxuXG5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImh0bWxtYXRobWxcIixcbiAgbmFtZXM6IFtcIlxcXFxodG1sQG1hdGhtbFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYucGFyc2VyO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImh0bWxtYXRobWxcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgaHRtbDogZGVmaW5lRnVuY3Rpb25fb3JkYXJndW1lbnQoYXJnc1swXSksXG4gICAgICBtYXRobWw6IGRlZmluZUZ1bmN0aW9uX29yZGFyZ3VtZW50KGFyZ3NbMV0pXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gYnVpbGRIVE1MX2J1aWxkRXhwcmVzc2lvbihncm91cC5odG1sLCBvcHRpb25zLCBmYWxzZSk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChlbGVtZW50cyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IGZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLm1hdGhtbCwgb3B0aW9ucyk7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2luY2x1ZGVncmFwaGljcy5qc1xuXG5cblxuXG5cblxuXG52YXIgaW5jbHVkZWdyYXBoaWNzX3NpemVEYXRhID0gZnVuY3Rpb24gc2l6ZURhdGEoc3RyKSB7XG4gIGlmICgvXlstK10/ICooXFxkKyhcXC5cXGQqKT98XFwuXFxkKykkLy50ZXN0KHN0cikpIHtcbiAgICAvLyBzdHIgaXMgYSBudW1iZXIgd2l0aCBubyB1bml0IHNwZWNpZmllZC5cbiAgICAvLyBkZWZhdWx0IHVuaXQgaXMgYnAsIHBlciBncmFwaGl4IHBhY2thZ2UuXG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWJlcjogK3N0cixcbiAgICAgIHVuaXQ6IFwiYnBcIlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1hdGNoID0gLyhbLStdPykgKihcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspICooW2Etel17Mn0pLy5leGVjKHN0cik7XG5cbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbnZhbGlkIHNpemU6ICdcIiArIHN0ciArIFwiJyBpbiBcXFxcaW5jbHVkZWdyYXBoaWNzXCIpO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0ge1xuICAgICAgbnVtYmVyOiArKG1hdGNoWzFdICsgbWF0Y2hbMl0pLFxuICAgICAgLy8gc2lnbiArIG1hZ25pdHVkZSwgY2FzdCB0byBudW1iZXJcbiAgICAgIHVuaXQ6IG1hdGNoWzNdXG4gICAgfTtcblxuICAgIGlmICghdmFsaWRVbml0KGRhdGEpKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbnZhbGlkIHVuaXQ6ICdcIiArIGRhdGEudW5pdCArIFwiJyBpbiBcXFxcaW5jbHVkZWdyYXBoaWNzLlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImluY2x1ZGVncmFwaGljc1wiLFxuICBuYW1lczogW1wiXFxcXGluY2x1ZGVncmFwaGljc1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wicmF3XCIsIFwidXJsXCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IGZhbHNlXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZiwgYXJncywgb3B0QXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmLnBhcnNlcjtcbiAgICB2YXIgd2lkdGggPSB7XG4gICAgICBudW1iZXI6IDAsXG4gICAgICB1bml0OiBcImVtXCJcbiAgICB9O1xuICAgIHZhciBoZWlnaHQgPSB7XG4gICAgICBudW1iZXI6IDAuOSxcbiAgICAgIHVuaXQ6IFwiZW1cIlxuICAgIH07IC8vIHNvcnRhIGNoYXJhY3RlciBzaXplZC5cblxuICAgIHZhciB0b3RhbGhlaWdodCA9IHtcbiAgICAgIG51bWJlcjogMCxcbiAgICAgIHVuaXQ6IFwiZW1cIlxuICAgIH07XG4gICAgdmFyIGFsdCA9IFwiXCI7XG5cbiAgICBpZiAob3B0QXJnc1swXSkge1xuICAgICAgdmFyIGF0dHJpYnV0ZVN0ciA9IGFzc2VydE5vZGVUeXBlKG9wdEFyZ3NbMF0sIFwicmF3XCIpLnN0cmluZzsgLy8gUGFyc2VyLmpzIGRvZXMgbm90IHBhcnNlIGtleS92YWx1ZSBwYWlycy4gV2UgZ2V0IGEgc3RyaW5nLlxuXG4gICAgICB2YXIgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZVN0ci5zcGxpdChcIixcIik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5VmFsID0gYXR0cmlidXRlc1tpXS5zcGxpdChcIj1cIik7XG5cbiAgICAgICAgaWYgKGtleVZhbC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICB2YXIgc3RyID0ga2V5VmFsWzFdLnRyaW0oKTtcblxuICAgICAgICAgIHN3aXRjaCAoa2V5VmFsWzBdLnRyaW0oKSkge1xuICAgICAgICAgICAgY2FzZSBcImFsdFwiOlxuICAgICAgICAgICAgICBhbHQgPSBzdHI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwid2lkdGhcIjpcbiAgICAgICAgICAgICAgd2lkdGggPSBpbmNsdWRlZ3JhcGhpY3Nfc2l6ZURhdGEoc3RyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJoZWlnaHRcIjpcbiAgICAgICAgICAgICAgaGVpZ2h0ID0gaW5jbHVkZWdyYXBoaWNzX3NpemVEYXRhKHN0cik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwidG90YWxoZWlnaHRcIjpcbiAgICAgICAgICAgICAgdG90YWxoZWlnaHQgPSBpbmNsdWRlZ3JhcGhpY3Nfc2l6ZURhdGEoc3RyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQga2V5OiAnXCIgKyBrZXlWYWxbMF0gKyBcIicgaW4gXFxcXGluY2x1ZGVncmFwaGljcy5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNyYyA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwidXJsXCIpLnVybDtcblxuICAgIGlmIChhbHQgPT09IFwiXCIpIHtcbiAgICAgIC8vIE5vIGFsdCBnaXZlbi4gVXNlIHRoZSBmaWxlIG5hbWUuIFN0cmlwIGF3YXkgdGhlIHBhdGguXG4gICAgICBhbHQgPSBzcmM7XG4gICAgICBhbHQgPSBhbHQucmVwbGFjZSgvXi4qW1xcXFwvXS8sICcnKTtcbiAgICAgIGFsdCA9IGFsdC5zdWJzdHJpbmcoMCwgYWx0Lmxhc3RJbmRleE9mKCcuJykpO1xuICAgIH1cblxuICAgIGlmICghcGFyc2VyLnNldHRpbmdzLmlzVHJ1c3RlZCh7XG4gICAgICBjb21tYW5kOiBcIlxcXFxpbmNsdWRlZ3JhcGhpY3NcIixcbiAgICAgIHVybDogc3JjXG4gICAgfSkpIHtcbiAgICAgIHJldHVybiBwYXJzZXIuZm9ybWF0VW5zdXBwb3J0ZWRDbWQoXCJcXFxcaW5jbHVkZWdyYXBoaWNzXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImluY2x1ZGVncmFwaGljc1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBhbHQ6IGFsdCxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgdG90YWxoZWlnaHQ6IHRvdGFsaGVpZ2h0LFxuICAgICAgc3JjOiBzcmNcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaGVpZ2h0ID0gdW5pdHNfY2FsY3VsYXRlU2l6ZShncm91cC5oZWlnaHQsIG9wdGlvbnMpO1xuICAgIHZhciBkZXB0aCA9IDA7XG5cbiAgICBpZiAoZ3JvdXAudG90YWxoZWlnaHQubnVtYmVyID4gMCkge1xuICAgICAgZGVwdGggPSB1bml0c19jYWxjdWxhdGVTaXplKGdyb3VwLnRvdGFsaGVpZ2h0LCBvcHRpb25zKSAtIGhlaWdodDtcbiAgICAgIGRlcHRoID0gTnVtYmVyKGRlcHRoLnRvRml4ZWQoMikpO1xuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IDA7XG5cbiAgICBpZiAoZ3JvdXAud2lkdGgubnVtYmVyID4gMCkge1xuICAgICAgd2lkdGggPSB1bml0c19jYWxjdWxhdGVTaXplKGdyb3VwLndpZHRoLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSB7XG4gICAgICBoZWlnaHQ6IGhlaWdodCArIGRlcHRoICsgXCJlbVwiXG4gICAgfTtcblxuICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgIHN0eWxlLndpZHRoID0gd2lkdGggKyBcImVtXCI7XG4gICAgfVxuXG4gICAgaWYgKGRlcHRoID4gMCkge1xuICAgICAgc3R5bGUudmVydGljYWxBbGlnbiA9IC1kZXB0aCArIFwiZW1cIjtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IG5ldyBkb21UcmVlX0ltZyhncm91cC5zcmMsIGdyb3VwLmFsdCwgc3R5bGUpO1xuICAgIG5vZGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIG5vZGUuZGVwdGggPSBkZXB0aDtcbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtZ2x5cGhcIiwgW10pO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiYWx0XCIsIGdyb3VwLmFsdCk7XG4gICAgdmFyIGhlaWdodCA9IHVuaXRzX2NhbGN1bGF0ZVNpemUoZ3JvdXAuaGVpZ2h0LCBvcHRpb25zKTtcbiAgICB2YXIgZGVwdGggPSAwO1xuXG4gICAgaWYgKGdyb3VwLnRvdGFsaGVpZ2h0Lm51bWJlciA+IDApIHtcbiAgICAgIGRlcHRoID0gdW5pdHNfY2FsY3VsYXRlU2l6ZShncm91cC50b3RhbGhlaWdodCwgb3B0aW9ucykgLSBoZWlnaHQ7XG4gICAgICBkZXB0aCA9IGRlcHRoLnRvRml4ZWQoMik7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcInZhbGlnblwiLCBcIi1cIiArIGRlcHRoICsgXCJlbVwiKTtcbiAgICB9XG5cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoZWlnaHQgKyBkZXB0aCArIFwiZW1cIik7XG5cbiAgICBpZiAoZ3JvdXAud2lkdGgubnVtYmVyID4gMCkge1xuICAgICAgdmFyIHdpZHRoID0gdW5pdHNfY2FsY3VsYXRlU2l6ZShncm91cC53aWR0aCwgb3B0aW9ucyk7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHdpZHRoICsgXCJlbVwiKTtcbiAgICB9XG5cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcInNyY1wiLCBncm91cC5zcmMpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9rZXJuLmpzXG4vLyBIb3Jpem9udGFsIHNwYWNpbmcgY29tbWFuZHNcblxuXG5cblxuIC8vIFRPRE86IFxcaHNraXAgYW5kIFxcbXNraXAgc2hvdWxkIHN1cHBvcnQgcGx1cyBhbmQgbWludXMgaW4gbGVuZ3Roc1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwia2VyblwiLFxuICBuYW1lczogW1wiXFxcXGtlcm5cIiwgXCJcXFxcbWtlcm5cIiwgXCJcXFxcaHNraXBcIiwgXCJcXFxcbXNraXBcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmLnBhcnNlcixcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmLmZ1bmNOYW1lO1xuICAgIHZhciBzaXplID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJzaXplXCIpO1xuXG4gICAgaWYgKHBhcnNlci5zZXR0aW5ncy5zdHJpY3QpIHtcbiAgICAgIHZhciBtYXRoRnVuY3Rpb24gPSBmdW5jTmFtZVsxXSA9PT0gJ20nOyAvLyBcXG1rZXJuLCBcXG1za2lwXG5cbiAgICAgIHZhciBtdVVuaXQgPSBzaXplLnZhbHVlLnVuaXQgPT09ICdtdSc7XG5cbiAgICAgIGlmIChtYXRoRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKCFtdVVuaXQpIHtcbiAgICAgICAgICBwYXJzZXIuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KFwibWF0aFZzVGV4dFVuaXRzXCIsIFwiTGFUZVgncyBcIiArIGZ1bmNOYW1lICsgXCIgc3VwcG9ydHMgb25seSBtdSB1bml0cywgXCIgKyAoXCJub3QgXCIgKyBzaXplLnZhbHVlLnVuaXQgKyBcIiB1bml0c1wiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VyLm1vZGUgIT09IFwibWF0aFwiKSB7XG4gICAgICAgICAgcGFyc2VyLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdChcIm1hdGhWc1RleHRVbml0c1wiLCBcIkxhVGVYJ3MgXCIgKyBmdW5jTmFtZSArIFwiIHdvcmtzIG9ubHkgaW4gbWF0aCBtb2RlXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAhbWF0aEZ1bmN0aW9uXG4gICAgICAgIGlmIChtdVVuaXQpIHtcbiAgICAgICAgICBwYXJzZXIuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KFwibWF0aFZzVGV4dFVuaXRzXCIsIFwiTGFUZVgncyBcIiArIGZ1bmNOYW1lICsgXCIgZG9lc24ndCBzdXBwb3J0IG11IHVuaXRzXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBkaW1lbnNpb246IHNpemUudmFsdWVcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUdsdWUoZ3JvdXAuZGltZW5zaW9uLCBvcHRpb25zKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBkaW1lbnNpb24gPSB1bml0c19jYWxjdWxhdGVTaXplKGdyb3VwLmRpbWVuc2lvbiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLlNwYWNlTm9kZShkaW1lbnNpb24pO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9sYXAuanNcbi8vIEhvcml6b250YWwgb3ZlcmxhcCBmdW5jdGlvbnNcblxuXG5cblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibGFwXCIsXG4gIG5hbWVzOiBbXCJcXFxcbWF0aGxsYXBcIiwgXCJcXFxcbWF0aHJsYXBcIiwgXCJcXFxcbWF0aGNsYXBcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmLnBhcnNlcixcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmLmZ1bmNOYW1lO1xuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsYXBcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYWxpZ25tZW50OiBmdW5jTmFtZS5zbGljZSg1KSxcbiAgICAgIGJvZHk6IGJvZHlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBtYXRobGxhcCwgbWF0aHJsYXAsIG1hdGhjbGFwXG4gICAgdmFyIGlubmVyO1xuXG4gICAgaWYgKGdyb3VwLmFsaWdubWVudCA9PT0gXCJjbGFwXCIpIHtcbiAgICAgIC8vIHJlZjogaHR0cHM6Ly93d3cubWF0aC5sc3UuZWR1L35hcGVybGlzL3B1YmxpY2F0aW9ucy9tYXRoY2xhcC9cbiAgICAgIGlubmVyID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW10sIFtidWlsZEhUTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKV0pOyAvLyB3cmFwLCBzaW5jZSBDU1Mgd2lsbCBjZW50ZXIgYSAuY2xhcCA+IC5pbm5lciA+IHNwYW5cblxuICAgICAgaW5uZXIgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJpbm5lclwiXSwgW2lubmVyXSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlubmVyID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiaW5uZXJcIl0sIFtidWlsZEhUTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKV0pO1xuICAgIH1cblxuICAgIHZhciBmaXggPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJmaXhcIl0sIFtdKTtcbiAgICB2YXIgbm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtncm91cC5hbGlnbm1lbnRdLCBbaW5uZXIsIGZpeF0sIG9wdGlvbnMpOyAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIGNvcnJlY3RseSBzZXQgaG9yaXpvbnRhbCBhbGlnbm1lbnQgb2YgdGhlXG4gICAgLy8gdHdvIGl0ZW1zIGludm9sdmVkIGluIHRoZSBsYXAuXG4gICAgLy8gTmV4dCwgdXNlIGEgc3RydXQgdG8gc2V0IHRoZSBoZWlnaHQgb2YgdGhlIEhUTUwgYm91bmRpbmcgYm94LlxuICAgIC8vIE90aGVyd2lzZSwgYSB0YWxsIGFyZ3VtZW50IG1heSBiZSBtaXNwbGFjZWQuXG5cbiAgICB2YXIgc3RydXQgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJzdHJ1dFwiXSk7XG4gICAgc3RydXQuc3R5bGUuaGVpZ2h0ID0gbm9kZS5oZWlnaHQgKyBub2RlLmRlcHRoICsgXCJlbVwiO1xuICAgIHN0cnV0LnN0eWxlLnZlcnRpY2FsQWxpZ24gPSAtbm9kZS5kZXB0aCArIFwiZW1cIjtcbiAgICBub2RlLmNoaWxkcmVuLnVuc2hpZnQoc3RydXQpOyAvLyBOZXh0LCBwcmV2ZW50IHZlcnRpY2FsIG1pc3BsYWNlbWVudCB3aGVuIG5leHQgdG8gc29tZXRoaW5nIHRhbGwuXG5cbiAgICBub2RlID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJmaXJzdEJhc2VsaW5lXCIsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IG5vZGVcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7IC8vIEdldCB0aGUgaG9yaXpvbnRhbCBzcGFjaW5nIGNvcnJlY3QgcmVsYXRpdmUgdG8gYWRqYWNlbnQgaXRlbXMuXG5cbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiXSwgW25vZGVdLCBvcHRpb25zKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIG1hdGhsbGFwLCBtYXRocmxhcCwgbWF0aGNsYXBcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKV0pO1xuXG4gICAgaWYgKGdyb3VwLmFsaWdubWVudCAhPT0gXCJybGFwXCIpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBncm91cC5hbGlnbm1lbnQgPT09IFwibGxhcFwiID8gXCItMVwiIDogXCItMC41XCI7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBvZmZzZXQgKyBcIndpZHRoXCIpO1xuICAgIH1cblxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIwcHhcIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL21hdGguanNcblxuIC8vIFN3aXRjaGluZyBmcm9tIHRleHQgbW9kZSBiYWNrIHRvIG1hdGggbW9kZVxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwic3R5bGluZ1wiLFxuICBuYW1lczogW1wiXFxcXChcIiwgXCIkXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhbGxvd2VkSW5NYXRoOiBmYWxzZVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIgZnVuY05hbWUgPSBfcmVmLmZ1bmNOYW1lLFxuICAgICAgICBwYXJzZXIgPSBfcmVmLnBhcnNlcjtcbiAgICB2YXIgb3V0ZXJNb2RlID0gcGFyc2VyLm1vZGU7XG4gICAgcGFyc2VyLnN3aXRjaE1vZGUoXCJtYXRoXCIpO1xuICAgIHZhciBjbG9zZSA9IGZ1bmNOYW1lID09PSBcIlxcXFwoXCIgPyBcIlxcXFwpXCIgOiBcIiRcIjtcbiAgICB2YXIgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIGNsb3NlKTtcbiAgICBwYXJzZXIuZXhwZWN0KGNsb3NlKTtcbiAgICBwYXJzZXIuc3dpdGNoTW9kZShvdXRlck1vZGUpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInN0eWxpbmdcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgc3R5bGU6IFwidGV4dFwiLFxuICAgICAgYm9keTogYm9keVxuICAgIH07XG4gIH1cbn0pOyAvLyBDaGVjayBmb3IgZXh0cmEgY2xvc2luZyBtYXRoIGRlbGltaXRlcnNcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInRleHRcIixcbiAgLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGlzIGlzLlxuICBuYW1lczogW1wiXFxcXClcIiwgXCJcXFxcXVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYWxsb3dlZEluTWF0aDogZmFsc2VcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihjb250ZXh0LCBhcmdzKSB7XG4gICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiTWlzbWF0Y2hlZCBcIiArIGNvbnRleHQuZnVuY05hbWUpO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9tYXRoY2hvaWNlLmpzXG5cblxuXG5cblxuXG52YXIgbWF0aGNob2ljZV9jaG9vc2VNYXRoU3R5bGUgPSBmdW5jdGlvbiBjaG9vc2VNYXRoU3R5bGUoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgc3dpdGNoIChvcHRpb25zLnN0eWxlLnNpemUpIHtcbiAgICBjYXNlIHNyY19TdHlsZS5ESVNQTEFZLnNpemU6XG4gICAgICByZXR1cm4gZ3JvdXAuZGlzcGxheTtcblxuICAgIGNhc2Ugc3JjX1N0eWxlLlRFWFQuc2l6ZTpcbiAgICAgIHJldHVybiBncm91cC50ZXh0O1xuXG4gICAgY2FzZSBzcmNfU3R5bGUuU0NSSVBULnNpemU6XG4gICAgICByZXR1cm4gZ3JvdXAuc2NyaXB0O1xuXG4gICAgY2FzZSBzcmNfU3R5bGUuU0NSSVBUU0NSSVBULnNpemU6XG4gICAgICByZXR1cm4gZ3JvdXAuc2NyaXB0c2NyaXB0O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBncm91cC50ZXh0O1xuICB9XG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibWF0aGNob2ljZVwiLFxuICBuYW1lczogW1wiXFxcXG1hdGhjaG9pY2VcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogNFxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZi5wYXJzZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibWF0aGNob2ljZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBkaXNwbGF5OiBkZWZpbmVGdW5jdGlvbl9vcmRhcmd1bWVudChhcmdzWzBdKSxcbiAgICAgIHRleHQ6IGRlZmluZUZ1bmN0aW9uX29yZGFyZ3VtZW50KGFyZ3NbMV0pLFxuICAgICAgc2NyaXB0OiBkZWZpbmVGdW5jdGlvbl9vcmRhcmd1bWVudChhcmdzWzJdKSxcbiAgICAgIHNjcmlwdHNjcmlwdDogZGVmaW5lRnVuY3Rpb25fb3JkYXJndW1lbnQoYXJnc1szXSlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgYm9keSA9IG1hdGhjaG9pY2VfY2hvb3NlTWF0aFN0eWxlKGdyb3VwLCBvcHRpb25zKTtcbiAgICB2YXIgZWxlbWVudHMgPSBidWlsZEhUTUxfYnVpbGRFeHByZXNzaW9uKGJvZHksIG9wdGlvbnMsIGZhbHNlKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUZyYWdtZW50KGVsZW1lbnRzKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBib2R5ID0gbWF0aGNob2ljZV9jaG9vc2VNYXRoU3R5bGUoZ3JvdXAsIG9wdGlvbnMpO1xuICAgIHJldHVybiBidWlsZEV4cHJlc3Npb25Sb3coYm9keSwgb3B0aW9ucyk7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL3V0aWxzL2Fzc2VtYmxlU3VwU3ViLmpzXG5cblxuLy8gRm9yIGFuIG9wZXJhdG9yIHdpdGggbGltaXRzLCBhc3NlbWJsZSB0aGUgYmFzZSwgc3VwLCBhbmQgc3ViIGludG8gYSBzcGFuLlxudmFyIGFzc2VtYmxlU3VwU3ViX2Fzc2VtYmxlU3VwU3ViID0gZnVuY3Rpb24gYXNzZW1ibGVTdXBTdWIoYmFzZSwgc3VwR3JvdXAsIHN1Ykdyb3VwLCBvcHRpb25zLCBzdHlsZSwgc2xhbnQsIGJhc2VTaGlmdCkge1xuICAvLyBJRSA4IGNsaXBzIFxcaW50IGlmIGl0IGlzIGluIGEgZGlzcGxheTogaW5saW5lLWJsb2NrLiBXZSB3cmFwIGl0XG4gIC8vIGluIGEgbmV3IHNwYW4gc28gaXQgaXMgYW4gaW5saW5lLCBhbmQgd29ya3MuXG4gIGJhc2UgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXSwgW2Jhc2VdKTtcbiAgdmFyIHN1YjtcbiAgdmFyIHN1cDsgLy8gV2UgbWFudWFsbHkgaGF2ZSB0byBoYW5kbGUgdGhlIHN1cGVyc2NyaXB0cyBhbmQgc3Vic2NyaXB0cy4gVGhpcyxcbiAgLy8gYXNpZGUgZnJvbSB0aGUga2VybiBjYWxjdWxhdGlvbnMsIGlzIGNvcGllZCBmcm9tIHN1cHN1Yi5cblxuICBpZiAoc3VwR3JvdXApIHtcbiAgICB2YXIgZWxlbSA9IGJ1aWxkSFRNTF9idWlsZEdyb3VwKHN1cEdyb3VwLCBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlLnN1cCgpKSwgb3B0aW9ucyk7XG4gICAgc3VwID0ge1xuICAgICAgZWxlbTogZWxlbSxcbiAgICAgIGtlcm46IE1hdGgubWF4KG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmcxLCBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYmlnT3BTcGFjaW5nMyAtIGVsZW0uZGVwdGgpXG4gICAgfTtcbiAgfVxuXG4gIGlmIChzdWJHcm91cCkge1xuICAgIHZhciBfZWxlbSA9IGJ1aWxkSFRNTF9idWlsZEdyb3VwKHN1Ykdyb3VwLCBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlLnN1YigpKSwgb3B0aW9ucyk7XG5cbiAgICBzdWIgPSB7XG4gICAgICBlbGVtOiBfZWxlbSxcbiAgICAgIGtlcm46IE1hdGgubWF4KG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmcyLCBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYmlnT3BTcGFjaW5nNCAtIF9lbGVtLmhlaWdodClcbiAgICB9O1xuICB9IC8vIEJ1aWxkIHRoZSBmaW5hbCBncm91cCBhcyBhIHZsaXN0IG9mIHRoZSBwb3NzaWJsZSBzdWJzY3JpcHQsIGJhc2UsXG4gIC8vIGFuZCBwb3NzaWJsZSBzdXBlcnNjcmlwdC5cblxuXG4gIHZhciBmaW5hbEdyb3VwO1xuXG4gIGlmIChzdXAgJiYgc3ViKSB7XG4gICAgdmFyIGJvdHRvbSA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmc1ICsgc3ViLmVsZW0uaGVpZ2h0ICsgc3ViLmVsZW0uZGVwdGggKyBzdWIua2VybiArIGJhc2UuZGVwdGggKyBiYXNlU2hpZnQ7XG4gICAgZmluYWxHcm91cCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiYm90dG9tXCIsXG4gICAgICBwb3NpdGlvbkRhdGE6IGJvdHRvbSxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogb3B0aW9ucy5mb250TWV0cmljcygpLmJpZ09wU3BhY2luZzVcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IHN1Yi5lbGVtLFxuICAgICAgICBtYXJnaW5MZWZ0OiAtc2xhbnQgKyBcImVtXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IHN1Yi5rZXJuXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBiYXNlXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiBzdXAua2VyblxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogc3VwLmVsZW0sXG4gICAgICAgIG1hcmdpbkxlZnQ6IHNsYW50ICsgXCJlbVwiXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYmlnT3BTcGFjaW5nNVxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgfSBlbHNlIGlmIChzdWIpIHtcbiAgICB2YXIgdG9wID0gYmFzZS5oZWlnaHQgLSBiYXNlU2hpZnQ7IC8vIFNoaWZ0IHRoZSBsaW1pdHMgYnkgdGhlIHNsYW50IG9mIHRoZSBzeW1ib2wuIE5vdGVcbiAgICAvLyB0aGF0IHdlIGFyZSBzdXBwb3NlZCB0byBzaGlmdCB0aGUgbGltaXRzIGJ5IDEvMiBvZiB0aGUgc2xhbnQsXG4gICAgLy8gYnV0IHNpbmNlIHdlIGFyZSBjZW50ZXJpbmcgdGhlIGxpbWl0cyBhZGRpbmcgYSBmdWxsIHNsYW50IG9mXG4gICAgLy8gbWFyZ2luIHdpbGwgc2hpZnQgYnkgMS8yIHRoYXQuXG5cbiAgICBmaW5hbEdyb3VwID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJ0b3BcIixcbiAgICAgIHBvc2l0aW9uRGF0YTogdG9wLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYmlnT3BTcGFjaW5nNVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogc3ViLmVsZW0sXG4gICAgICAgIG1hcmdpbkxlZnQ6IC1zbGFudCArIFwiZW1cIlxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogc3ViLmtlcm5cbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGJhc2VcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAoc3VwKSB7XG4gICAgdmFyIF9ib3R0b20gPSBiYXNlLmRlcHRoICsgYmFzZVNoaWZ0O1xuXG4gICAgZmluYWxHcm91cCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiYm90dG9tXCIsXG4gICAgICBwb3NpdGlvbkRhdGE6IF9ib3R0b20sXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGJhc2VcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IHN1cC5rZXJuXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBzdXAuZWxlbSxcbiAgICAgICAgbWFyZ2luTGVmdDogc2xhbnQgKyBcImVtXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmc1XG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgY2FzZSBwcm9iYWJseSBzaG91bGRuJ3Qgb2NjdXIgKHRoaXMgd291bGQgbWVhbiB0aGVcbiAgICAvLyBzdXBzdWIgd2FzIHNlbmRpbmcgdXMgYSBncm91cCB3aXRoIG5vIHN1cGVyc2NyaXB0IG9yXG4gICAgLy8gc3Vic2NyaXB0KSBidXQgYmUgc2FmZS5cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3BcIiwgXCJvcC1saW1pdHNcIl0sIFtmaW5hbEdyb3VwXSwgb3B0aW9ucyk7XG59O1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL29wLmpzXG4vLyBMaW1pdHMsIHN5bWJvbHNcblxuXG5cblxuXG5cblxuXG5cblxuLy8gTW9zdCBvcGVyYXRvcnMgaGF2ZSBhIGxhcmdlIHN1Y2Nlc3NvciBzeW1ib2wsIGJ1dCB0aGVzZSBkb24ndC5cbnZhciBub1N1Y2Nlc3NvciA9IFtcIlxcXFxzbWFsbGludFwiXTsgLy8gTk9URTogVW5saWtlIG1vc3QgYGh0bWxCdWlsZGVyYHMsIHRoaXMgb25lIGhhbmRsZXMgbm90IG9ubHkgXCJvcFwiLCBidXQgYWxzb1xuLy8gXCJzdXBzdWJcIiBzaW5jZSBzb21lIG9mIHRoZW0gKGxpa2UgXFxpbnQpIGNhbiBhZmZlY3Qgc3VwZXIvc3Vic2NyaXB0aW5nLlxuXG52YXIgb3BfaHRtbEJ1aWxkZXIgPSBmdW5jdGlvbiBodG1sQnVpbGRlcihncnAsIG9wdGlvbnMpIHtcbiAgLy8gT3BlcmF0b3JzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnLiA0NDMtNDQ0LCBydWxlIDEzKGEpLlxuICB2YXIgc3VwR3JvdXA7XG4gIHZhciBzdWJHcm91cDtcbiAgdmFyIGhhc0xpbWl0cyA9IGZhbHNlO1xuICB2YXIgZ3JvdXA7XG4gIHZhciBzdXBTdWIgPSBjaGVja05vZGVUeXBlKGdycCwgXCJzdXBzdWJcIik7XG5cbiAgaWYgKHN1cFN1Yikge1xuICAgIC8vIElmIHdlIGhhdmUgbGltaXRzLCBzdXBzdWIgd2lsbCBwYXNzIHVzIGl0cyBncm91cCB0byBoYW5kbGUuIFB1bGxcbiAgICAvLyBvdXQgdGhlIHN1cGVyc2NyaXB0IGFuZCBzdWJzY3JpcHQgYW5kIHNldCB0aGUgZ3JvdXAgdG8gdGhlIG9wIGluXG4gICAgLy8gaXRzIGJhc2UuXG4gICAgc3VwR3JvdXAgPSBzdXBTdWIuc3VwO1xuICAgIHN1Ykdyb3VwID0gc3VwU3ViLnN1YjtcbiAgICBncm91cCA9IGFzc2VydE5vZGVUeXBlKHN1cFN1Yi5iYXNlLCBcIm9wXCIpO1xuICAgIGhhc0xpbWl0cyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgZ3JvdXAgPSBhc3NlcnROb2RlVHlwZShncnAsIFwib3BcIik7XG4gIH1cblxuICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICB2YXIgbGFyZ2UgPSBmYWxzZTtcblxuICBpZiAoc3R5bGUuc2l6ZSA9PT0gc3JjX1N0eWxlLkRJU1BMQVkuc2l6ZSAmJiBncm91cC5zeW1ib2wgJiYgIXV0aWxzLmNvbnRhaW5zKG5vU3VjY2Vzc29yLCBncm91cC5uYW1lKSkge1xuICAgIC8vIE1vc3Qgc3ltYm9sIG9wZXJhdG9ycyBnZXQgbGFyZ2VyIGluIGRpc3BsYXlzdHlsZSAocnVsZSAxMylcbiAgICBsYXJnZSA9IHRydWU7XG4gIH1cblxuICB2YXIgYmFzZTtcblxuICBpZiAoZ3JvdXAuc3ltYm9sKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhIHN5bWJvbCwgY3JlYXRlIHRoZSBzeW1ib2wuXG4gICAgdmFyIGZvbnROYW1lID0gbGFyZ2UgPyBcIlNpemUyLVJlZ3VsYXJcIiA6IFwiU2l6ZTEtUmVndWxhclwiO1xuICAgIHZhciBzdGFzaCA9IFwiXCI7XG5cbiAgICBpZiAoZ3JvdXAubmFtZSA9PT0gXCJcXFxcb2lpbnRcIiB8fCBncm91cC5uYW1lID09PSBcIlxcXFxvaWlpbnRcIikge1xuICAgICAgLy8gTm8gZm9udCBnbHlwaHMgeWV0LCBzbyB1c2UgYSBnbHlwaCB3L28gdGhlIG92YWwuXG4gICAgICAvLyBUT0RPOiBXaGVuIGZvbnQgZ2x5cGhzIGFyZSBhdmFpbGFibGUsIGRlbGV0ZSB0aGlzIGNvZGUuXG4gICAgICBzdGFzaCA9IGdyb3VwLm5hbWUuc3Vic3RyKDEpOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgIGdyb3VwLm5hbWUgPSBzdGFzaCA9PT0gXCJvaWludFwiID8gXCJcXFxcaWludFwiIDogXCJcXFxcaWlpbnRcIjtcbiAgICB9XG5cbiAgICBiYXNlID0gYnVpbGRDb21tb24ubWFrZVN5bWJvbChncm91cC5uYW1lLCBmb250TmFtZSwgXCJtYXRoXCIsIG9wdGlvbnMsIFtcIm1vcFwiLCBcIm9wLXN5bWJvbFwiLCBsYXJnZSA/IFwibGFyZ2Utb3BcIiA6IFwic21hbGwtb3BcIl0pO1xuXG4gICAgaWYgKHN0YXNoLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIFdlJ3JlIGluIFxcb2lpbnQgb3IgXFxvaWlpbnQuIE92ZXJsYXkgdGhlIG92YWwuXG4gICAgICAvLyBUT0RPOiBXaGVuIGZvbnQgZ2x5cGhzIGFyZSBhdmFpbGFibGUsIGRlbGV0ZSB0aGlzIGNvZGUuXG4gICAgICB2YXIgaXRhbGljID0gYmFzZS5pdGFsaWM7XG4gICAgICB2YXIgb3ZhbCA9IGJ1aWxkQ29tbW9uLnN0YXRpY1N2ZyhzdGFzaCArIFwiU2l6ZVwiICsgKGxhcmdlID8gXCIyXCIgOiBcIjFcIiksIG9wdGlvbnMpO1xuICAgICAgYmFzZSA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICAgIHBvc2l0aW9uVHlwZTogXCJpbmRpdmlkdWFsU2hpZnRcIixcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogYmFzZSxcbiAgICAgICAgICBzaGlmdDogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogb3ZhbCxcbiAgICAgICAgICBzaGlmdDogbGFyZ2UgPyAwLjA4IDogMFxuICAgICAgICB9XVxuICAgICAgfSwgb3B0aW9ucyk7IC8vICRGbG93Rml4TWVcblxuICAgICAgZ3JvdXAubmFtZSA9IFwiXFxcXFwiICsgc3Rhc2g7XG4gICAgICBiYXNlLmNsYXNzZXMudW5zaGlmdChcIm1vcFwiKTsgLy8gJEZsb3dGaXhNZVxuXG4gICAgICBiYXNlLml0YWxpYyA9IGl0YWxpYztcbiAgICB9XG4gIH0gZWxzZSBpZiAoZ3JvdXAuYm9keSkge1xuICAgIC8vIElmIHRoaXMgaXMgYSBsaXN0LCBjb21wb3NlIHRoYXQgbGlzdC5cbiAgICB2YXIgaW5uZXIgPSBidWlsZEhUTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMsIHRydWUpO1xuXG4gICAgaWYgKGlubmVyLmxlbmd0aCA9PT0gMSAmJiBpbm5lclswXSBpbnN0YW5jZW9mIGRvbVRyZWVfU3ltYm9sTm9kZSkge1xuICAgICAgYmFzZSA9IGlubmVyWzBdO1xuICAgICAgYmFzZS5jbGFzc2VzWzBdID0gXCJtb3BcIjsgLy8gcmVwbGFjZSBvbGQgbWNsYXNzXG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3BcIl0sIGJ1aWxkQ29tbW9uLnRyeUNvbWJpbmVDaGFycyhpbm5lciksIG9wdGlvbnMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2UsIHRoaXMgaXMgYSB0ZXh0IG9wZXJhdG9yLiBCdWlsZCB0aGUgdGV4dCBmcm9tIHRoZVxuICAgIC8vIG9wZXJhdG9yJ3MgbmFtZS5cbiAgICAvLyBUT0RPKGVtaWx5KTogQWRkIGEgc3BhY2UgaW4gdGhlIG1pZGRsZSBvZiBzb21lIG9mIHRoZXNlXG4gICAgLy8gb3BlcmF0b3JzLCBsaWtlIFxcbGltc3VwXG4gICAgdmFyIG91dHB1dCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBncm91cC5uYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvdXRwdXQucHVzaChidWlsZENvbW1vbi5tYXRoc3ltKGdyb3VwLm5hbWVbaV0sIGdyb3VwLm1vZGUsIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICBiYXNlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9wXCJdLCBvdXRwdXQsIG9wdGlvbnMpO1xuICB9IC8vIElmIGNvbnRlbnQgb2Ygb3AgaXMgYSBzaW5nbGUgc3ltYm9sLCBzaGlmdCBpdCB2ZXJ0aWNhbGx5LlxuXG5cbiAgdmFyIGJhc2VTaGlmdCA9IDA7XG4gIHZhciBzbGFudCA9IDA7XG5cbiAgaWYgKChiYXNlIGluc3RhbmNlb2YgZG9tVHJlZV9TeW1ib2xOb2RlIHx8IGdyb3VwLm5hbWUgPT09IFwiXFxcXG9paW50XCIgfHwgZ3JvdXAubmFtZSA9PT0gXCJcXFxcb2lpaW50XCIpICYmICFncm91cC5zdXBwcmVzc0Jhc2VTaGlmdCkge1xuICAgIC8vIFdlIHN1cHByZXNzIHRoZSBzaGlmdCBvZiB0aGUgYmFzZSBvZiBcXG92ZXJzZXQgYW5kIFxcdW5kZXJzZXQuIE90aGVyd2lzZSxcbiAgICAvLyBzaGlmdCB0aGUgc3ltYm9sIHNvIGl0cyBjZW50ZXIgbGllcyBvbiB0aGUgYXhpcyAocnVsZSAxMykuIEl0XG4gICAgLy8gYXBwZWFycyB0aGF0IG91ciBmb250cyBoYXZlIHRoZSBjZW50ZXJzIG9mIHRoZSBzeW1ib2xzIGFscmVhZHlcbiAgICAvLyBhbG1vc3Qgb24gdGhlIGF4aXMsIHNvIHRoZXNlIG51bWJlcnMgYXJlIHZlcnkgc21hbGwuIE5vdGUgd2VcbiAgICAvLyBkb24ndCBhY3R1YWxseSBhcHBseSB0aGlzIGhlcmUsIGJ1dCBpbnN0ZWFkIGl0IGlzIHVzZWQgZWl0aGVyIGluXG4gICAgLy8gdGhlIHZsaXN0IGNyZWF0aW9uIG9yIHNlcGFyYXRlbHkgd2hlbiB0aGVyZSBhcmUgbm8gbGltaXRzLlxuICAgIGJhc2VTaGlmdCA9IChiYXNlLmhlaWdodCAtIGJhc2UuZGVwdGgpIC8gMiAtIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5heGlzSGVpZ2h0OyAvLyBUaGUgc2xhbnQgb2YgdGhlIHN5bWJvbCBpcyBqdXN0IGl0cyBpdGFsaWMgY29ycmVjdGlvbi5cbiAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICBzbGFudCA9IGJhc2UuaXRhbGljO1xuICB9XG5cbiAgaWYgKGhhc0xpbWl0cykge1xuICAgIHJldHVybiBhc3NlbWJsZVN1cFN1Yl9hc3NlbWJsZVN1cFN1YihiYXNlLCBzdXBHcm91cCwgc3ViR3JvdXAsIG9wdGlvbnMsIHN0eWxlLCBzbGFudCwgYmFzZVNoaWZ0KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoYmFzZVNoaWZ0KSB7XG4gICAgICBiYXNlLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgYmFzZS5zdHlsZS50b3AgPSBiYXNlU2hpZnQgKyBcImVtXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbn07XG5cbnZhciBvcF9tYXRobWxCdWlsZGVyID0gZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICB2YXIgbm9kZTtcblxuICBpZiAoZ3JvdXAuc3ltYm9sKSB7XG4gICAgLy8gVGhpcyBpcyBhIHN5bWJvbC4gSnVzdCBhZGQgdGhlIHN5bWJvbC5cbiAgICBub2RlID0gbmV3IG1hdGhNTFRyZWVfTWF0aE5vZGUoXCJtb1wiLCBbYnVpbGRNYXRoTUxfbWFrZVRleHQoZ3JvdXAubmFtZSwgZ3JvdXAubW9kZSldKTtcblxuICAgIGlmICh1dGlscy5jb250YWlucyhub1N1Y2Nlc3NvciwgZ3JvdXAubmFtZSkpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibGFyZ2VvcFwiLCBcImZhbHNlXCIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChncm91cC5ib2R5KSB7XG4gICAgLy8gVGhpcyBpcyBhbiBvcGVyYXRvciB3aXRoIGNoaWxkcmVuLiBBZGQgdGhlbS5cbiAgICBub2RlID0gbmV3IG1hdGhNTFRyZWVfTWF0aE5vZGUoXCJtb1wiLCBidWlsZE1hdGhNTF9idWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucykpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYSB0ZXh0IG9wZXJhdG9yLiBBZGQgYWxsIG9mIHRoZSBjaGFyYWN0ZXJzIGZyb20gdGhlXG4gICAgLy8gb3BlcmF0b3IncyBuYW1lLlxuICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZV9NYXRoTm9kZShcIm1pXCIsIFtuZXcgbWF0aE1MVHJlZV9UZXh0Tm9kZShncm91cC5uYW1lLnNsaWNlKDEpKV0pOyAvLyBBcHBlbmQgYW4gPG1vPiZBcHBseUZ1bmN0aW9uOzwvbW8+LlxuICAgIC8vIHJlZjogaHR0cHM6Ly93d3cudzMub3JnL1RSL1JFQy1NYXRoTUwvY2hhcDNfMi5odG1sI3NlYzMuMi40XG5cbiAgICB2YXIgb3BlcmF0b3IgPSBuZXcgbWF0aE1MVHJlZV9NYXRoTm9kZShcIm1vXCIsIFtidWlsZE1hdGhNTF9tYWtlVGV4dChcIlxcdTIwNjFcIiwgXCJ0ZXh0XCIpXSk7XG5cbiAgICBpZiAoZ3JvdXAucGFyZW50SXNTdXBTdWIpIHtcbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZV9NYXRoTm9kZShcIm1vXCIsIFtub2RlLCBvcGVyYXRvcl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gbmV3RG9jdW1lbnRGcmFnbWVudChbbm9kZSwgb3BlcmF0b3JdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG5cbnZhciBzaW5nbGVDaGFyQmlnT3BzID0ge1xuICBcIlxcdTIyMEZcIjogXCJcXFxccHJvZFwiLFxuICBcIlxcdTIyMTBcIjogXCJcXFxcY29wcm9kXCIsXG4gIFwiXFx1MjIxMVwiOiBcIlxcXFxzdW1cIixcbiAgXCJcXHUyMkMwXCI6IFwiXFxcXGJpZ3dlZGdlXCIsXG4gIFwiXFx1MjJDMVwiOiBcIlxcXFxiaWd2ZWVcIixcbiAgXCJcXHUyMkMyXCI6IFwiXFxcXGJpZ2NhcFwiLFxuICBcIlxcdTIyQzNcIjogXCJcXFxcYmlnY3VwXCIsXG4gIFwiXFx1MkEwMFwiOiBcIlxcXFxiaWdvZG90XCIsXG4gIFwiXFx1MkEwMVwiOiBcIlxcXFxiaWdvcGx1c1wiLFxuICBcIlxcdTJBMDJcIjogXCJcXFxcYmlnb3RpbWVzXCIsXG4gIFwiXFx1MkEwNFwiOiBcIlxcXFxiaWd1cGx1c1wiLFxuICBcIlxcdTJBMDZcIjogXCJcXFxcYmlnc3FjdXBcIlxufTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvcFwiLFxuICBuYW1lczogW1wiXFxcXGNvcHJvZFwiLCBcIlxcXFxiaWd2ZWVcIiwgXCJcXFxcYmlnd2VkZ2VcIiwgXCJcXFxcYmlndXBsdXNcIiwgXCJcXFxcYmlnY2FwXCIsIFwiXFxcXGJpZ2N1cFwiLCBcIlxcXFxpbnRvcFwiLCBcIlxcXFxwcm9kXCIsIFwiXFxcXHN1bVwiLCBcIlxcXFxiaWdvdGltZXNcIiwgXCJcXFxcYmlnb3BsdXNcIiwgXCJcXFxcYmlnb2RvdFwiLCBcIlxcXFxiaWdzcWN1cFwiLCBcIlxcXFxzbWFsbGludFwiLCBcIlxcdTIyMEZcIiwgXCJcXHUyMjEwXCIsIFwiXFx1MjIxMVwiLCBcIlxcdTIyQzBcIiwgXCJcXHUyMkMxXCIsIFwiXFx1MjJDMlwiLCBcIlxcdTIyQzNcIiwgXCJcXHUyQTAwXCIsIFwiXFx1MkEwMVwiLCBcIlxcdTJBMDJcIiwgXCJcXHUyQTA0XCIsIFwiXFx1MkEwNlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmLnBhcnNlcixcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmLmZ1bmNOYW1lO1xuICAgIHZhciBmTmFtZSA9IGZ1bmNOYW1lO1xuXG4gICAgaWYgKGZOYW1lLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZk5hbWUgPSBzaW5nbGVDaGFyQmlnT3BzW2ZOYW1lXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsaW1pdHM6IHRydWUsXG4gICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsXG4gICAgICBzeW1ib2w6IHRydWUsXG4gICAgICBuYW1lOiBmTmFtZVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBvcF9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogb3BfbWF0aG1sQnVpbGRlclxufSk7IC8vIE5vdGU6IGNhbGxpbmcgZGVmaW5lRnVuY3Rpb24gd2l0aCBhIHR5cGUgdGhhdCdzIGFscmVhZHkgYmVlbiBkZWZpbmVkIG9ubHlcbi8vIHdvcmtzIGJlY2F1c2UgdGhlIHNhbWUgaHRtbEJ1aWxkZXIgYW5kIG1hdGhtbEJ1aWxkZXIgYXJlIGJlaW5nIHVzZWQuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvcFwiLFxuICBuYW1lczogW1wiXFxcXG1hdGhvcFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZjIsIGFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZjIucGFyc2VyO1xuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsaW1pdHM6IGZhbHNlLFxuICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlLFxuICAgICAgc3ltYm9sOiBmYWxzZSxcbiAgICAgIGJvZHk6IGRlZmluZUZ1bmN0aW9uX29yZGFyZ3VtZW50KGJvZHkpXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IG9wX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBvcF9tYXRobWxCdWlsZGVyXG59KTsgLy8gVGhlcmUgYXJlIDIgZmxhZ3MgZm9yIG9wZXJhdG9yczsgd2hldGhlciB0aGV5IHByb2R1Y2UgbGltaXRzIGluXG4vLyBkaXNwbGF5c3R5bGUsIGFuZCB3aGV0aGVyIHRoZXkgYXJlIHN5bWJvbHMgYW5kIHNob3VsZCBncm93IGluXG4vLyBkaXNwbGF5c3R5bGUuIFRoZXNlIGZvdXIgZ3JvdXBzIGNvdmVyIHRoZSBmb3VyIHBvc3NpYmxlIGNob2ljZXMuXG5cbnZhciBzaW5nbGVDaGFySW50ZWdyYWxzID0ge1xuICBcIlxcdTIyMkJcIjogXCJcXFxcaW50XCIsXG4gIFwiXFx1MjIyQ1wiOiBcIlxcXFxpaW50XCIsXG4gIFwiXFx1MjIyRFwiOiBcIlxcXFxpaWludFwiLFxuICBcIlxcdTIyMkVcIjogXCJcXFxcb2ludFwiLFxuICBcIlxcdTIyMkZcIjogXCJcXFxcb2lpbnRcIixcbiAgXCJcXHUyMjMwXCI6IFwiXFxcXG9paWludFwiXG59OyAvLyBObyBsaW1pdHMsIG5vdCBzeW1ib2xzXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvcFwiLFxuICBuYW1lczogW1wiXFxcXGFyY3NpblwiLCBcIlxcXFxhcmNjb3NcIiwgXCJcXFxcYXJjdGFuXCIsIFwiXFxcXGFyY3RnXCIsIFwiXFxcXGFyY2N0Z1wiLCBcIlxcXFxhcmdcIiwgXCJcXFxcY2hcIiwgXCJcXFxcY29zXCIsIFwiXFxcXGNvc2VjXCIsIFwiXFxcXGNvc2hcIiwgXCJcXFxcY290XCIsIFwiXFxcXGNvdGdcIiwgXCJcXFxcY290aFwiLCBcIlxcXFxjc2NcIiwgXCJcXFxcY3RnXCIsIFwiXFxcXGN0aFwiLCBcIlxcXFxkZWdcIiwgXCJcXFxcZGltXCIsIFwiXFxcXGV4cFwiLCBcIlxcXFxob21cIiwgXCJcXFxca2VyXCIsIFwiXFxcXGxnXCIsIFwiXFxcXGxuXCIsIFwiXFxcXGxvZ1wiLCBcIlxcXFxzZWNcIiwgXCJcXFxcc2luXCIsIFwiXFxcXHNpbmhcIiwgXCJcXFxcc2hcIiwgXCJcXFxcdGFuXCIsIFwiXFxcXHRhbmhcIiwgXCJcXFxcdGdcIiwgXCJcXFxcdGhcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYzLnBhcnNlcixcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmMy5mdW5jTmFtZTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsaW1pdHM6IGZhbHNlLFxuICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlLFxuICAgICAgc3ltYm9sOiBmYWxzZSxcbiAgICAgIG5hbWU6IGZ1bmNOYW1lXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IG9wX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBvcF9tYXRobWxCdWlsZGVyXG59KTsgLy8gTGltaXRzLCBub3Qgc3ltYm9sc1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwib3BcIixcbiAgbmFtZXM6IFtcIlxcXFxkZXRcIiwgXCJcXFxcZ2NkXCIsIFwiXFxcXGluZlwiLCBcIlxcXFxsaW1cIiwgXCJcXFxcbWF4XCIsIFwiXFxcXG1pblwiLCBcIlxcXFxQclwiLCBcIlxcXFxzdXBcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWY0KSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWY0LnBhcnNlcixcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmNC5mdW5jTmFtZTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsaW1pdHM6IHRydWUsXG4gICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsXG4gICAgICBzeW1ib2w6IGZhbHNlLFxuICAgICAgbmFtZTogZnVuY05hbWVcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogb3BfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IG9wX21hdGhtbEJ1aWxkZXJcbn0pOyAvLyBObyBsaW1pdHMsIHN5bWJvbHNcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm9wXCIsXG4gIG5hbWVzOiBbXCJcXFxcaW50XCIsIFwiXFxcXGlpbnRcIiwgXCJcXFxcaWlpbnRcIiwgXCJcXFxcb2ludFwiLCBcIlxcXFxvaWludFwiLCBcIlxcXFxvaWlpbnRcIiwgXCJcXHUyMjJCXCIsIFwiXFx1MjIyQ1wiLCBcIlxcdTIyMkRcIiwgXCJcXHUyMjJFXCIsIFwiXFx1MjIyRlwiLCBcIlxcdTIyMzBcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWY1KSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWY1LnBhcnNlcixcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmNS5mdW5jTmFtZTtcbiAgICB2YXIgZk5hbWUgPSBmdW5jTmFtZTtcblxuICAgIGlmIChmTmFtZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGZOYW1lID0gc2luZ2xlQ2hhckludGVncmFsc1tmTmFtZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGltaXRzOiBmYWxzZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIHN5bWJvbDogdHJ1ZSxcbiAgICAgIG5hbWU6IGZOYW1lXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IG9wX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBvcF9tYXRobWxCdWlsZGVyXG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9vcGVyYXRvcm5hbWUuanNcblxuXG5cblxuXG5cblxuXG4vLyBOT1RFOiBVbmxpa2UgbW9zdCBgaHRtbEJ1aWxkZXJgcywgdGhpcyBvbmUgaGFuZGxlcyBub3Qgb25seVxuLy8gXCJvcGVyYXRvcm5hbWVcIiwgYnV0IGFsc28gIFwic3Vwc3ViXCIgc2luY2UgXFxvcGVyYXRvcm5hbWUqIGNhblxudmFyIG9wZXJhdG9ybmFtZV9odG1sQnVpbGRlciA9IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdycCwgb3B0aW9ucykge1xuICAvLyBPcGVyYXRvcnMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgcGcuIDQ0My00NDQsIHJ1bGUgMTMoYSkuXG4gIHZhciBzdXBHcm91cDtcbiAgdmFyIHN1Ykdyb3VwO1xuICB2YXIgaGFzTGltaXRzID0gZmFsc2U7XG4gIHZhciBncm91cDtcbiAgdmFyIHN1cFN1YiA9IGNoZWNrTm9kZVR5cGUoZ3JwLCBcInN1cHN1YlwiKTtcblxuICBpZiAoc3VwU3ViKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBsaW1pdHMsIHN1cHN1YiB3aWxsIHBhc3MgdXMgaXRzIGdyb3VwIHRvIGhhbmRsZS4gUHVsbFxuICAgIC8vIG91dCB0aGUgc3VwZXJzY3JpcHQgYW5kIHN1YnNjcmlwdCBhbmQgc2V0IHRoZSBncm91cCB0byB0aGUgb3AgaW5cbiAgICAvLyBpdHMgYmFzZS5cbiAgICBzdXBHcm91cCA9IHN1cFN1Yi5zdXA7XG4gICAgc3ViR3JvdXAgPSBzdXBTdWIuc3ViO1xuICAgIGdyb3VwID0gYXNzZXJ0Tm9kZVR5cGUoc3VwU3ViLmJhc2UsIFwib3BlcmF0b3JuYW1lXCIpO1xuICAgIGhhc0xpbWl0cyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgZ3JvdXAgPSBhc3NlcnROb2RlVHlwZShncnAsIFwib3BlcmF0b3JuYW1lXCIpO1xuICB9XG5cbiAgdmFyIGJhc2U7XG5cbiAgaWYgKGdyb3VwLmJvZHkubGVuZ3RoID4gMCkge1xuICAgIHZhciBib2R5ID0gZ3JvdXAuYm9keS5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lOiBDaGVjayBpZiB0aGUgbm9kZSBoYXMgYSBzdHJpbmcgYHRleHRgIHByb3BlcnR5LlxuICAgICAgdmFyIGNoaWxkVGV4dCA9IGNoaWxkLnRleHQ7XG5cbiAgICAgIGlmICh0eXBlb2YgY2hpbGRUZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgICAgbW9kZTogY2hpbGQubW9kZSxcbiAgICAgICAgICB0ZXh0OiBjaGlsZFRleHRcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cbiAgICB9KTsgLy8gQ29uc29saWRhdGUgZnVuY3Rpb24gbmFtZXMgaW50byBzeW1ib2wgY2hhcmFjdGVycy5cblxuICAgIHZhciBleHByZXNzaW9uID0gYnVpbGRIVE1MX2J1aWxkRXhwcmVzc2lvbihib2R5LCBvcHRpb25zLndpdGhGb250KFwibWF0aHJtXCIpLCB0cnVlKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gZXhwcmVzc2lvbltpXTtcblxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgZG9tVHJlZV9TeW1ib2xOb2RlKSB7XG4gICAgICAgIC8vIFBlciBhbXNvcG4gcGFja2FnZSxcbiAgICAgICAgLy8gY2hhbmdlIG1pbnVzIHRvIGh5cGhlbiBhbmQgXFxhc3QgdG8gYXN0ZXJpc2tcbiAgICAgICAgY2hpbGQudGV4dCA9IGNoaWxkLnRleHQucmVwbGFjZSgvXFx1MjIxMi8sIFwiLVwiKS5yZXBsYWNlKC9cXHUyMjE3LywgXCIqXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJhc2UgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3BcIl0sIGV4cHJlc3Npb24sIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIGJhc2UgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3BcIl0sIFtdLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChoYXNMaW1pdHMpIHtcbiAgICByZXR1cm4gYXNzZW1ibGVTdXBTdWJfYXNzZW1ibGVTdXBTdWIoYmFzZSwgc3VwR3JvdXAsIHN1Ykdyb3VwLCBvcHRpb25zLCBvcHRpb25zLnN0eWxlLCAwLCAwKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxufTtcblxudmFyIG9wZXJhdG9ybmFtZV9tYXRobWxCdWlsZGVyID0gZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAvLyBUaGUgc3RlcHMgdGFrZW4gaGVyZSBhcmUgc2ltaWxhciB0byB0aGUgaHRtbCB2ZXJzaW9uLlxuICB2YXIgZXhwcmVzc2lvbiA9IGJ1aWxkTWF0aE1MX2J1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBvcHRpb25zLndpdGhGb250KFwibWF0aHJtXCIpKTsgLy8gSXMgZXhwcmVzc2lvbiBhIHN0cmluZyBvciBoYXMgaXQgc29tZXRoaW5nIGxpa2UgYSBmcmFjdGlvbj9cblxuICB2YXIgaXNBbGxTdHJpbmcgPSB0cnVlOyAvLyBkZWZhdWx0XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBleHByZXNzaW9uW2ldO1xuXG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBtYXRoTUxUcmVlLlNwYWNlTm9kZSkgey8vIERvIG5vdGhpbmdcbiAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBtYXRoTUxUcmVlLk1hdGhOb2RlKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlIFwibWlcIjpcbiAgICAgICAgY2FzZSBcIm1uXCI6XG4gICAgICAgIGNhc2UgXCJtc1wiOlxuICAgICAgICBjYXNlIFwibXNwYWNlXCI6XG4gICAgICAgIGNhc2UgXCJtdGV4dFwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBEbyBub3RoaW5nIHlldC5cblxuICAgICAgICBjYXNlIFwibW9cIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuWzBdO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGQgaW5zdGFuY2VvZiBtYXRoTUxUcmVlLlRleHROb2RlKSB7XG4gICAgICAgICAgICAgIGNoaWxkLnRleHQgPSBjaGlsZC50ZXh0LnJlcGxhY2UoL1xcdTIyMTIvLCBcIi1cIikucmVwbGFjZSgvXFx1MjIxNy8sIFwiKlwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlzQWxsU3RyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlzQWxsU3RyaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzQWxsU3RyaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzQWxsU3RyaW5nKSB7XG4gICAgLy8gV3JpdGUgYSBzaW5nbGUgVGV4dE5vZGUgaW5zdGVhZCBvZiBtdWx0aXBsZSBuZXN0ZWQgdGFncy5cbiAgICB2YXIgd29yZCA9IGV4cHJlc3Npb24ubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS50b1RleHQoKTtcbiAgICB9KS5qb2luKFwiXCIpO1xuICAgIGV4cHJlc3Npb24gPSBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUod29yZCldO1xuICB9XG5cbiAgdmFyIGlkZW50aWZpZXIgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1pXCIsIGV4cHJlc3Npb24pO1xuICBpZGVudGlmaWVyLnNldEF0dHJpYnV0ZShcIm1hdGh2YXJpYW50XCIsIFwibm9ybWFsXCIpOyAvLyBcXHUyMDYxIGlzIHRoZSBzYW1lIGFzICZBcHBseUZ1bmN0aW9uO1xuICAvLyByZWY6IGh0dHBzOi8vd3d3Lnczc2Nob29scy5jb20vY2hhcnNldHMvcmVmX2h0bWxfZW50aXRpZXNfYS5hc3BcblxuICB2YXIgb3BlcmF0b3IgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFtidWlsZE1hdGhNTF9tYWtlVGV4dChcIlxcdTIwNjFcIiwgXCJ0ZXh0XCIpXSk7XG5cbiAgaWYgKGdyb3VwLnBhcmVudElzU3VwU3ViKSB7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW2lkZW50aWZpZXIsIG9wZXJhdG9yXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1hdGhNTFRyZWUubmV3RG9jdW1lbnRGcmFnbWVudChbaWRlbnRpZmllciwgb3BlcmF0b3JdKTtcbiAgfVxufTsgLy8gXFxvcGVyYXRvcm5hbWVcbi8vIGFtc29wbi5kdHg6IFxcbWF0aG9weyMxXFxrZXJuXFx6QFxcb3BlcmF0b3JAZm9udCMzfVxcbmV3bWNvZGVzQFxuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvcGVyYXRvcm5hbWVcIixcbiAgbmFtZXM6IFtcIlxcXFxvcGVyYXRvcm5hbWVcIiwgXCJcXFxcb3BlcmF0b3JuYW1lKlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmLnBhcnNlcixcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmLmZ1bmNOYW1lO1xuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvcGVyYXRvcm5hbWVcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keTogZGVmaW5lRnVuY3Rpb25fb3JkYXJndW1lbnQoYm9keSksXG4gICAgICBhbHdheXNIYW5kbGVTdXBTdWI6IGZ1bmNOYW1lID09PSBcIlxcXFxvcGVyYXRvcm5hbWUqXCIsXG4gICAgICBsaW1pdHM6IGZhbHNlLFxuICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IG9wZXJhdG9ybmFtZV9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogb3BlcmF0b3JuYW1lX21hdGhtbEJ1aWxkZXJcbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL29yZGdyb3VwLmpzXG5cblxuXG5cbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gIGh0bWxCdWlsZGVyOiBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGlmIChncm91cC5zZW1pc2ltcGxlKSB7XG4gICAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUZyYWdtZW50KGJ1aWxkSFRNTF9idWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucywgZmFsc2UpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiXSwgYnVpbGRIVE1MX2J1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBvcHRpb25zLCB0cnVlKSwgb3B0aW9ucyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IGZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLmJvZHksIG9wdGlvbnMsIHRydWUpO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9vdmVybGluZS5qc1xuXG5cblxuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvdmVybGluZVwiLFxuICBuYW1lczogW1wiXFxcXG92ZXJsaW5lXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYucGFyc2VyO1xuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvdmVybGluZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBib2R5XG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gT3ZlcmxpbmVzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnIDQ0MywgUnVsZSA5LlxuICAgIC8vIEJ1aWxkIHRoZSBpbm5lciBncm91cCBpbiB0aGUgY3JhbXBlZCBzdHlsZS5cbiAgICB2YXIgaW5uZXJHcm91cCA9IGJ1aWxkSFRNTF9idWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMuaGF2aW5nQ3JhbXBlZFN0eWxlKCkpOyAvLyBDcmVhdGUgdGhlIGxpbmUgYWJvdmUgdGhlIGJvZHlcblxuICAgIHZhciBsaW5lID0gYnVpbGRDb21tb24ubWFrZUxpbmVTcGFuKFwib3ZlcmxpbmUtbGluZVwiLCBvcHRpb25zKTsgLy8gR2VuZXJhdGUgdGhlIHZsaXN0LCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBrZXJuc1xuXG4gICAgdmFyIGRlZmF1bHRSdWxlVGhpY2tuZXNzID0gb3B0aW9ucy5mb250TWV0cmljcygpLmRlZmF1bHRSdWxlVGhpY2tuZXNzO1xuICAgIHZhciB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiZmlyc3RCYXNlbGluZVwiLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBpbm5lckdyb3VwXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiAzICogZGVmYXVsdFJ1bGVUaGlja25lc3NcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGxpbmVcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IGRlZmF1bHRSdWxlVGhpY2tuZXNzXG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwib3ZlcmxpbmVcIl0sIFt2bGlzdF0sIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG9wZXJhdG9yID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoXCJcXHUyMDNFXCIpXSk7XG4gICAgb3BlcmF0b3Iuc2V0QXR0cmlidXRlKFwic3RyZXRjaHlcIiwgXCJ0cnVlXCIpO1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb3ZlclwiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKSwgb3BlcmF0b3JdKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImFjY2VudFwiLCBcInRydWVcIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL3BoYW50b20uanNcblxuXG5cblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwicGhhbnRvbVwiLFxuICBuYW1lczogW1wiXFxcXHBoYW50b21cIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmLnBhcnNlcjtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicGhhbnRvbVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBkZWZpbmVGdW5jdGlvbl9vcmRhcmd1bWVudChib2R5KVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBlbGVtZW50cyA9IGJ1aWxkSFRNTF9idWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucy53aXRoUGhhbnRvbSgpLCBmYWxzZSk7IC8vIFxccGhhbnRvbSBpc24ndCBzdXBwb3NlZCB0byBhZmZlY3QgdGhlIGVsZW1lbnRzIGl0IGNvbnRhaW5zLlxuICAgIC8vIFNlZSBcImNvbG9yXCIgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoZWxlbWVudHMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGlubmVyID0gYnVpbGRNYXRoTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1waGFudG9tXCIsIGlubmVyKTtcbiAgfVxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaHBoYW50b21cIixcbiAgbmFtZXM6IFtcIlxcXFxocGhhbnRvbVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmMiwgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmMi5wYXJzZXI7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImhwaGFudG9tXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IGJvZHlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtdLCBbYnVpbGRIVE1MX2J1aWxkR3JvdXAoZ3JvdXAuYm9keSwgb3B0aW9ucy53aXRoUGhhbnRvbSgpKV0pO1xuICAgIG5vZGUuaGVpZ2h0ID0gMDtcbiAgICBub2RlLmRlcHRoID0gMDtcblxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZS5jaGlsZHJlbltpXS5oZWlnaHQgPSAwO1xuICAgICAgICBub2RlLmNoaWxkcmVuW2ldLmRlcHRoID0gMDtcbiAgICAgIH1cbiAgICB9IC8vIFNlZSBzbWFzaCBmb3IgY29tbWVudCByZTogdXNlIG9mIG1ha2VWTGlzdFxuXG5cbiAgICBub2RlID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJmaXJzdEJhc2VsaW5lXCIsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IG5vZGVcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7IC8vIEZvciBzcGFjaW5nLCBUZVggdHJlYXRzIFxcc21hc2ggYXMgYSBtYXRoIGdyb3VwIChzYW1lIHNwYWNpbmcgYXMgb3JkKS5cblxuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCJdLCBbbm9kZV0sIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGlubmVyID0gYnVpbGRNYXRoTUxfYnVpbGRFeHByZXNzaW9uKGRlZmluZUZ1bmN0aW9uX29yZGFyZ3VtZW50KGdyb3VwLmJvZHkpLCBvcHRpb25zKTtcbiAgICB2YXIgcGhhbnRvbSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBoYW50b21cIiwgaW5uZXIpO1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtwaGFudG9tXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIwcHhcIik7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkZXB0aFwiLCBcIjBweFwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidnBoYW50b21cIixcbiAgbmFtZXM6IFtcIlxcXFx2cGhhbnRvbVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmMywgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmMy5wYXJzZXI7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInZwaGFudG9tXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IGJvZHlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJpbm5lclwiXSwgW2J1aWxkSFRNTF9idWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMud2l0aFBoYW50b20oKSldKTtcbiAgICB2YXIgZml4ID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiZml4XCJdLCBbXSk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJybGFwXCJdLCBbaW5uZXIsIGZpeF0sIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGlubmVyID0gYnVpbGRNYXRoTUxfYnVpbGRFeHByZXNzaW9uKGRlZmluZUZ1bmN0aW9uX29yZGFyZ3VtZW50KGdyb3VwLmJvZHkpLCBvcHRpb25zKTtcbiAgICB2YXIgcGhhbnRvbSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBoYW50b21cIiwgaW5uZXIpO1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtwaGFudG9tXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjBweFwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvcmFpc2Vib3guanNcblxuXG5cblxuXG5cbiAvLyBCb3ggbWFuaXB1bGF0aW9uXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJyYWlzZWJveFwiLFxuICBuYW1lczogW1wiXFxcXHJhaXNlYm94XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgYXJnVHlwZXM6IFtcInNpemVcIiwgXCJoYm94XCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYucGFyc2VyO1xuICAgIHZhciBhbW91bnQgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInNpemVcIikudmFsdWU7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzFdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInJhaXNlYm94XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGR5OiBhbW91bnQsXG4gICAgICBib2R5OiBib2R5XG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGJvZHkgPSBidWlsZEhUTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKTtcbiAgICB2YXIgZHkgPSB1bml0c19jYWxjdWxhdGVTaXplKGdyb3VwLmR5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJzaGlmdFwiLFxuICAgICAgcG9zaXRpb25EYXRhOiAtZHksXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGJvZHlcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IGZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKV0pO1xuICAgIHZhciBkeSA9IGdyb3VwLmR5Lm51bWJlciArIGdyb3VwLmR5LnVuaXQ7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ2b2Zmc2V0XCIsIGR5KTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvcnVsZS5qc1xuXG5cblxuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJydWxlXCIsXG4gIG5hbWVzOiBbXCJcXFxccnVsZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiLCBcInNpemVcIiwgXCJzaXplXCJdXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZiwgYXJncywgb3B0QXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmLnBhcnNlcjtcbiAgICB2YXIgc2hpZnQgPSBvcHRBcmdzWzBdO1xuICAgIHZhciB3aWR0aCA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwic2l6ZVwiKTtcbiAgICB2YXIgaGVpZ2h0ID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1sxXSwgXCJzaXplXCIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInJ1bGVcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgc2hpZnQ6IHNoaWZ0ICYmIGFzc2VydE5vZGVUeXBlKHNoaWZ0LCBcInNpemVcIikudmFsdWUsXG4gICAgICB3aWR0aDogd2lkdGgudmFsdWUsXG4gICAgICBoZWlnaHQ6IGhlaWdodC52YWx1ZVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIE1ha2UgYW4gZW1wdHkgc3BhbiBmb3IgdGhlIHJ1bGVcbiAgICB2YXIgcnVsZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJydWxlXCJdLCBbXSwgb3B0aW9ucyk7IC8vIENhbGN1bGF0ZSB0aGUgc2hpZnQsIHdpZHRoLCBhbmQgaGVpZ2h0IG9mIHRoZSBydWxlLCBhbmQgYWNjb3VudCBmb3IgdW5pdHNcblxuICAgIHZhciB3aWR0aCA9IHVuaXRzX2NhbGN1bGF0ZVNpemUoZ3JvdXAud2lkdGgsIG9wdGlvbnMpO1xuICAgIHZhciBoZWlnaHQgPSB1bml0c19jYWxjdWxhdGVTaXplKGdyb3VwLmhlaWdodCwgb3B0aW9ucyk7XG4gICAgdmFyIHNoaWZ0ID0gZ3JvdXAuc2hpZnQgPyB1bml0c19jYWxjdWxhdGVTaXplKGdyb3VwLnNoaWZ0LCBvcHRpb25zKSA6IDA7IC8vIFN0eWxlIHRoZSBydWxlIHRvIHRoZSByaWdodCBzaXplXG5cbiAgICBydWxlLnN0eWxlLmJvcmRlclJpZ2h0V2lkdGggPSB3aWR0aCArIFwiZW1cIjtcbiAgICBydWxlLnN0eWxlLmJvcmRlclRvcFdpZHRoID0gaGVpZ2h0ICsgXCJlbVwiO1xuICAgIHJ1bGUuc3R5bGUuYm90dG9tID0gc2hpZnQgKyBcImVtXCI7IC8vIFJlY29yZCB0aGUgaGVpZ2h0IGFuZCB3aWR0aFxuXG4gICAgcnVsZS53aWR0aCA9IHdpZHRoO1xuICAgIHJ1bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgc2hpZnQ7XG4gICAgcnVsZS5kZXB0aCA9IC1zaGlmdDsgLy8gRm9udCBzaXplIGlzIHRoZSBudW1iZXIgbGFyZ2UgZW5vdWdoIHRoYXQgdGhlIGJyb3dzZXIgd2lsbFxuICAgIC8vIHJlc2VydmUgYXQgbGVhc3QgYGFic0hlaWdodGAgc3BhY2UgYWJvdmUgdGhlIGJhc2VsaW5lLlxuICAgIC8vIFRoZSAxLjEyNSBmYWN0b3Igd2FzIGVtcGlyaWNhbGx5IGRldGVybWluZWRcblxuICAgIHJ1bGUubWF4Rm9udFNpemUgPSBoZWlnaHQgKiAxLjEyNSAqIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IGZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgd2lkdGggPSB1bml0c19jYWxjdWxhdGVTaXplKGdyb3VwLndpZHRoLCBvcHRpb25zKTtcbiAgICB2YXIgaGVpZ2h0ID0gdW5pdHNfY2FsY3VsYXRlU2l6ZShncm91cC5oZWlnaHQsIG9wdGlvbnMpO1xuICAgIHZhciBzaGlmdCA9IGdyb3VwLnNoaWZ0ID8gdW5pdHNfY2FsY3VsYXRlU2l6ZShncm91cC5zaGlmdCwgb3B0aW9ucykgOiAwO1xuICAgIHZhciBjb2xvciA9IG9wdGlvbnMuY29sb3IgJiYgb3B0aW9ucy5nZXRDb2xvcigpIHx8IFwiYmxhY2tcIjtcbiAgICB2YXIgcnVsZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXNwYWNlXCIpO1xuICAgIHJ1bGUuc2V0QXR0cmlidXRlKFwibWF0aGJhY2tncm91bmRcIiwgY29sb3IpO1xuICAgIHJ1bGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgd2lkdGggKyBcImVtXCIpO1xuICAgIHJ1bGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGhlaWdodCArIFwiZW1cIik7XG4gICAgdmFyIHdyYXBwZXIgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW3J1bGVdKTtcblxuICAgIGlmIChzaGlmdCA+PSAwKSB7XG4gICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIitcIiArIHNoaWZ0ICsgXCJlbVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgc2hpZnQgKyBcImVtXCIpO1xuICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJkZXB0aFwiLCBcIitcIiArIC1zaGlmdCArIFwiZW1cIik7XG4gICAgfVxuXG4gICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJ2b2Zmc2V0XCIsIHNoaWZ0ICsgXCJlbVwiKTtcbiAgICByZXR1cm4gd3JhcHBlcjtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvc2l6aW5nLmpzXG5cblxuXG5cblxuZnVuY3Rpb24gc2l6aW5nR3JvdXAodmFsdWUsIG9wdGlvbnMsIGJhc2VPcHRpb25zKSB7XG4gIHZhciBpbm5lciA9IGJ1aWxkSFRNTF9idWlsZEV4cHJlc3Npb24odmFsdWUsIG9wdGlvbnMsIGZhbHNlKTtcbiAgdmFyIG11bHRpcGxpZXIgPSBvcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gYmFzZU9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7IC8vIEFkZCBzaXplLXJlc2V0dGluZyBjbGFzc2VzIHRvIHRoZSBpbm5lciBsaXN0IGFuZCBzZXQgbWF4Rm9udFNpemVcbiAgLy8gbWFudWFsbHkuIEhhbmRsZSBuZXN0ZWQgc2l6ZSBjaGFuZ2VzLlxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcG9zID0gaW5uZXJbaV0uY2xhc3Nlcy5pbmRleE9mKFwic2l6aW5nXCIpO1xuXG4gICAgaWYgKHBvcyA8IDApIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGlubmVyW2ldLmNsYXNzZXMsIG9wdGlvbnMuc2l6aW5nQ2xhc3NlcyhiYXNlT3B0aW9ucykpO1xuICAgIH0gZWxzZSBpZiAoaW5uZXJbaV0uY2xhc3Nlc1twb3MgKyAxXSA9PT0gXCJyZXNldC1zaXplXCIgKyBvcHRpb25zLnNpemUpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBuZXN0ZWQgc2l6ZSBjaGFuZ2U6IGUuZy4sIGlubmVyW2ldIGlzIHRoZSBcImJcIiBpblxuICAgICAgLy8gYFxcSHVnZSBhIFxcc21hbGwgYmAuIE92ZXJyaWRlIHRoZSBvbGQgc2l6ZSAodGhlIGByZXNldC1gIGNsYXNzKVxuICAgICAgLy8gYnV0IG5vdCB0aGUgbmV3IHNpemUuXG4gICAgICBpbm5lcltpXS5jbGFzc2VzW3BvcyArIDFdID0gXCJyZXNldC1zaXplXCIgKyBiYXNlT3B0aW9ucy5zaXplO1xuICAgIH1cblxuICAgIGlubmVyW2ldLmhlaWdodCAqPSBtdWx0aXBsaWVyO1xuICAgIGlubmVyW2ldLmRlcHRoICo9IG11bHRpcGxpZXI7XG4gIH1cblxuICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUZyYWdtZW50KGlubmVyKTtcbn1cbnZhciBzaXplRnVuY3MgPSBbXCJcXFxcdGlueVwiLCBcIlxcXFxzaXhwdHNpemVcIiwgXCJcXFxcc2NyaXB0c2l6ZVwiLCBcIlxcXFxmb290bm90ZXNpemVcIiwgXCJcXFxcc21hbGxcIiwgXCJcXFxcbm9ybWFsc2l6ZVwiLCBcIlxcXFxsYXJnZVwiLCBcIlxcXFxMYXJnZVwiLCBcIlxcXFxMQVJHRVwiLCBcIlxcXFxodWdlXCIsIFwiXFxcXEh1Z2VcIl07XG52YXIgc2l6aW5nX2h0bWxCdWlsZGVyID0gZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgLy8gSGFuZGxlIHNpemluZyBvcGVyYXRvcnMgbGlrZSBcXEh1Z2UuIFJlYWwgVGVYIGRvZXNuJ3QgYWN0dWFsbHkgYWxsb3dcbiAgLy8gdGhlc2UgZnVuY3Rpb25zIGluc2lkZSBvZiBtYXRoIGV4cHJlc3Npb25zLCBzbyB3ZSBkbyBzb21lIHNwZWNpYWxcbiAgLy8gaGFuZGxpbmcuXG4gIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTaXplKGdyb3VwLnNpemUpO1xuICByZXR1cm4gc2l6aW5nR3JvdXAoZ3JvdXAuYm9keSwgbmV3T3B0aW9ucywgb3B0aW9ucyk7XG59O1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInNpemluZ1wiLFxuICBuYW1lczogc2l6ZUZ1bmNzLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIgYnJlYWtPblRva2VuVGV4dCA9IF9yZWYuYnJlYWtPblRva2VuVGV4dCxcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmLmZ1bmNOYW1lLFxuICAgICAgICBwYXJzZXIgPSBfcmVmLnBhcnNlcjtcbiAgICB2YXIgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIGJyZWFrT25Ub2tlblRleHQpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInNpemluZ1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAvLyBGaWd1cmUgb3V0IHdoYXQgc2l6ZSB0byB1c2UgYmFzZWQgb24gdGhlIGxpc3Qgb2YgZnVuY3Rpb25zIGFib3ZlXG4gICAgICBzaXplOiBzaXplRnVuY3MuaW5kZXhPZihmdW5jTmFtZSkgKyAxLFxuICAgICAgYm9keTogYm9keVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBzaXppbmdfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU2l6ZShncm91cC5zaXplKTtcbiAgICB2YXIgaW5uZXIgPSBidWlsZE1hdGhNTF9idWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgbmV3T3B0aW9ucyk7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7IC8vIFRPRE8oZW1pbHkpOiBUaGlzIGRvZXNuJ3QgcHJvZHVjZSB0aGUgY29ycmVjdCBzaXplIGZvciBuZXN0ZWQgc2l6ZVxuICAgIC8vIGNoYW5nZXMsIGJlY2F1c2Ugd2UgZG9uJ3Qga2VlcCBzdGF0ZSBvZiB3aGF0IHN0eWxlIHdlJ3JlIGN1cnJlbnRseVxuICAgIC8vIGluLCBzbyB3ZSBjYW4ndCByZXNldCB0aGUgc2l6ZSB0byBub3JtYWwgYmVmb3JlIGNoYW5naW5nIGl0LiAgTm93XG4gICAgLy8gdGhhdCB3ZSdyZSBwYXNzaW5nIGFuIG9wdGlvbnMgcGFyYW1ldGVyIHdlIHNob3VsZCBiZSBhYmxlIHRvIGZpeFxuICAgIC8vIHRoaXMuXG5cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGhzaXplXCIsIG5ld09wdGlvbnMuc2l6ZU11bHRpcGxpZXIgKyBcImVtXCIpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9zbWFzaC5qc1xuLy8gc21hc2gsIHdpdGggb3B0aW9uYWwgW3RiXSwgYXMgaW4gQU1TXG5cblxuXG5cblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwic21hc2hcIixcbiAgbmFtZXM6IFtcIlxcXFxzbWFzaFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZiwgYXJncywgb3B0QXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmLnBhcnNlcjtcbiAgICB2YXIgc21hc2hIZWlnaHQgPSBmYWxzZTtcbiAgICB2YXIgc21hc2hEZXB0aCA9IGZhbHNlO1xuICAgIHZhciB0YkFyZyA9IG9wdEFyZ3NbMF0gJiYgYXNzZXJ0Tm9kZVR5cGUob3B0QXJnc1swXSwgXCJvcmRncm91cFwiKTtcblxuICAgIGlmICh0YkFyZykge1xuICAgICAgLy8gT3B0aW9uYWwgW3RiXSBhcmd1bWVudCBpcyBlbmdhZ2VkLlxuICAgICAgLy8gcmVmOiBhbXNtYXRoOiBcXHJlbmV3Y29tbWFuZHtcXHNtYXNofVsxXVt0Yl17JVxuICAgICAgLy8gICAgICAgICAgICAgICBkZWZcXG1iQHR7XFxodH1cXGRlZlxcbWJAYntcXGRwfVxcZGVmXFxtYkB0YntcXGh0XFx6QFxcekBcXGRwfSVcbiAgICAgIHZhciBsZXR0ZXIgPSBcIlwiO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRiQXJnLmJvZHkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0YkFyZy5ib2R5W2ldOyAvLyAkRmxvd0ZpeE1lOiBOb3QgZXZlcnkgbm9kZSB0eXBlIGhhcyBhIGB0ZXh0YCBwcm9wZXJ0eS5cblxuICAgICAgICBsZXR0ZXIgPSBub2RlLnRleHQ7XG5cbiAgICAgICAgaWYgKGxldHRlciA9PT0gXCJ0XCIpIHtcbiAgICAgICAgICBzbWFzaEhlaWdodCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBcImJcIikge1xuICAgICAgICAgIHNtYXNoRGVwdGggPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNtYXNoSGVpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgc21hc2hEZXB0aCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNtYXNoSGVpZ2h0ID0gdHJ1ZTtcbiAgICAgIHNtYXNoRGVwdGggPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzbWFzaFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBib2R5LFxuICAgICAgc21hc2hIZWlnaHQ6IHNtYXNoSGVpZ2h0LFxuICAgICAgc21hc2hEZXB0aDogc21hc2hEZXB0aFxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBub2RlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW10sIFtidWlsZEhUTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKV0pO1xuXG4gICAgaWYgKCFncm91cC5zbWFzaEhlaWdodCAmJiAhZ3JvdXAuc21hc2hEZXB0aCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnNtYXNoSGVpZ2h0KSB7XG4gICAgICBub2RlLmhlaWdodCA9IDA7IC8vIEluIG9yZGVyIHRvIGluZmx1ZW5jZSBtYWtlVkxpc3QsIHdlIGhhdmUgdG8gcmVzZXQgdGhlIGNoaWxkcmVuLlxuXG4gICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuW2ldLmhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAuc21hc2hEZXB0aCkge1xuICAgICAgbm9kZS5kZXB0aCA9IDA7XG5cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIG5vZGUuY2hpbGRyZW5bX2ldLmRlcHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgd2UndmUgcmVzZXQgdGhlIFRlWC1saWtlIGhlaWdodCBhbmQgZGVwdGggdmFsdWVzLlxuICAgIC8vIEJ1dCB0aGUgc3BhbiBzdGlsbCBoYXMgYW4gSFRNTCBsaW5lIGhlaWdodC5cbiAgICAvLyBtYWtlVkxpc3QgYXBwbGllcyBcImRpc3BsYXk6IHRhYmxlLWNlbGxcIiwgd2hpY2ggcHJldmVudHMgdGhlIGJyb3dzZXJcbiAgICAvLyBmcm9tIGFjdGluZyBvbiB0aGF0IGxpbmUgaGVpZ2h0LiBTbyB3ZSdsbCBjYWxsIG1ha2VWTGlzdCBub3cuXG5cblxuICAgIHZhciBzbWFzaGVkTm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiZmlyc3RCYXNlbGluZVwiLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBub2RlXG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpOyAvLyBGb3Igc3BhY2luZywgVGVYIHRyZWF0cyBcXGhwaGFudG9tIGFzIGEgbWF0aCBncm91cCAoc2FtZSBzcGFjaW5nIGFzIG9yZCkuXG5cbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiXSwgW3NtYXNoZWROb2RlXSwgb3B0aW9ucyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IGZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKV0pO1xuXG4gICAgaWYgKGdyb3VwLnNtYXNoSGVpZ2h0KSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjBweFwiKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAuc21hc2hEZXB0aCkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkZXB0aFwiLCBcIjBweFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvc3FydC5qc1xuXG5cblxuXG5cblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwic3FydFwiLFxuICBuYW1lczogW1wiXFxcXHNxcnRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmLCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYucGFyc2VyO1xuICAgIHZhciBpbmRleCA9IG9wdEFyZ3NbMF07XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInNxcnRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keTogYm9keSxcbiAgICAgIGluZGV4OiBpbmRleFxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIFNxdWFyZSByb290cyBhcmUgaGFuZGxlZCBpbiB0aGUgVGVYYm9vayBwZy4gNDQzLCBSdWxlIDExLlxuICAgIC8vIEZpcnN0LCB3ZSBkbyB0aGUgc2FtZSBzdGVwcyBhcyBpbiBvdmVybGluZSB0byBidWlsZCB0aGUgaW5uZXIgZ3JvdXBcbiAgICAvLyBhbmQgbGluZVxuICAgIHZhciBpbm5lciA9IGJ1aWxkSFRNTF9idWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMuaGF2aW5nQ3JhbXBlZFN0eWxlKCkpO1xuXG4gICAgaWYgKGlubmVyLmhlaWdodCA9PT0gMCkge1xuICAgICAgLy8gUmVuZGVyIGEgc21hbGwgc3VyZC5cbiAgICAgIGlubmVyLmhlaWdodCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS54SGVpZ2h0O1xuICAgIH0gLy8gU29tZSBncm91cHMgY2FuIHJldHVybiBkb2N1bWVudCBmcmFnbWVudHMuICBIYW5kbGUgdGhvc2UgYnkgd3JhcHBpbmdcbiAgICAvLyB0aGVtIGluIGEgc3Bhbi5cblxuXG4gICAgaW5uZXIgPSBidWlsZENvbW1vbi53cmFwRnJhZ21lbnQoaW5uZXIsIG9wdGlvbnMpOyAvLyBDYWxjdWxhdGUgdGhlIG1pbmltdW0gc2l6ZSBmb3IgdGhlIFxcc3VyZCBkZWxpbWl0ZXJcblxuICAgIHZhciBtZXRyaWNzID0gb3B0aW9ucy5mb250TWV0cmljcygpO1xuICAgIHZhciB0aGV0YSA9IG1ldHJpY3MuZGVmYXVsdFJ1bGVUaGlja25lc3M7XG4gICAgdmFyIHBoaSA9IHRoZXRhO1xuXG4gICAgaWYgKG9wdGlvbnMuc3R5bGUuaWQgPCBzcmNfU3R5bGUuVEVYVC5pZCkge1xuICAgICAgcGhpID0gb3B0aW9ucy5mb250TWV0cmljcygpLnhIZWlnaHQ7XG4gICAgfSAvLyBDYWxjdWxhdGUgdGhlIGNsZWFyYW5jZSBiZXR3ZWVuIHRoZSBib2R5IGFuZCBsaW5lXG5cblxuICAgIHZhciBsaW5lQ2xlYXJhbmNlID0gdGhldGEgKyBwaGkgLyA0O1xuICAgIHZhciBtaW5EZWxpbWl0ZXJIZWlnaHQgPSBpbm5lci5oZWlnaHQgKyBpbm5lci5kZXB0aCArIGxpbmVDbGVhcmFuY2UgKyB0aGV0YTsgLy8gQ3JlYXRlIGEgc3FydCBTVkcgb2YgdGhlIHJlcXVpcmVkIG1pbmltdW0gc2l6ZVxuXG4gICAgdmFyIF9kZWxpbWl0ZXIkc3FydEltYWdlID0gZGVsaW1pdGVyLnNxcnRJbWFnZShtaW5EZWxpbWl0ZXJIZWlnaHQsIG9wdGlvbnMpLFxuICAgICAgICBpbWcgPSBfZGVsaW1pdGVyJHNxcnRJbWFnZS5zcGFuLFxuICAgICAgICBydWxlV2lkdGggPSBfZGVsaW1pdGVyJHNxcnRJbWFnZS5ydWxlV2lkdGgsXG4gICAgICAgIGFkdmFuY2VXaWR0aCA9IF9kZWxpbWl0ZXIkc3FydEltYWdlLmFkdmFuY2VXaWR0aDtcblxuICAgIHZhciBkZWxpbURlcHRoID0gaW1nLmhlaWdodCAtIHJ1bGVXaWR0aDsgLy8gQWRqdXN0IHRoZSBjbGVhcmFuY2UgYmFzZWQgb24gdGhlIGRlbGltaXRlciBzaXplXG5cbiAgICBpZiAoZGVsaW1EZXB0aCA+IGlubmVyLmhlaWdodCArIGlubmVyLmRlcHRoICsgbGluZUNsZWFyYW5jZSkge1xuICAgICAgbGluZUNsZWFyYW5jZSA9IChsaW5lQ2xlYXJhbmNlICsgZGVsaW1EZXB0aCAtIGlubmVyLmhlaWdodCAtIGlubmVyLmRlcHRoKSAvIDI7XG4gICAgfSAvLyBTaGlmdCB0aGUgc3FydCBpbWFnZVxuXG5cbiAgICB2YXIgaW1nU2hpZnQgPSBpbWcuaGVpZ2h0IC0gaW5uZXIuaGVpZ2h0IC0gbGluZUNsZWFyYW5jZSAtIHJ1bGVXaWR0aDtcbiAgICBpbm5lci5zdHlsZS5wYWRkaW5nTGVmdCA9IGFkdmFuY2VXaWR0aCArIFwiZW1cIjsgLy8gT3ZlcmxheSB0aGUgaW1hZ2UgYW5kIHRoZSBhcmd1bWVudC5cblxuICAgIHZhciBib2R5ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJmaXJzdEJhc2VsaW5lXCIsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGlubmVyLFxuICAgICAgICB3cmFwcGVyQ2xhc3NlczogW1wic3ZnLWFsaWduXCJdXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiAtKGlubmVyLmhlaWdodCArIGltZ1NoaWZ0KVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogaW1nXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiBydWxlV2lkdGhcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoIWdyb3VwLmluZGV4KSB7XG4gICAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiLCBcInNxcnRcIl0sIFtib2R5XSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEhhbmRsZSB0aGUgb3B0aW9uYWwgcm9vdCBpbmRleFxuICAgICAgLy8gVGhlIGluZGV4IGlzIGFsd2F5cyBpbiBzY3JpcHRzY3JpcHQgc3R5bGVcbiAgICAgIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShzcmNfU3R5bGUuU0NSSVBUU0NSSVBUKTtcbiAgICAgIHZhciByb290bSA9IGJ1aWxkSFRNTF9idWlsZEdyb3VwKGdyb3VwLmluZGV4LCBuZXdPcHRpb25zLCBvcHRpb25zKTsgLy8gVGhlIGFtb3VudCB0aGUgaW5kZXggaXMgc2hpZnRlZCBieS4gVGhpcyBpcyB0YWtlbiBmcm9tIHRoZSBUZVhcbiAgICAgIC8vIHNvdXJjZSwgaW4gdGhlIGRlZmluaXRpb24gb2YgYFxcckBAdGAuXG5cbiAgICAgIHZhciB0b1NoaWZ0ID0gMC42ICogKGJvZHkuaGVpZ2h0IC0gYm9keS5kZXB0aCk7IC8vIEJ1aWxkIGEgVkxpc3Qgd2l0aCB0aGUgc3VwZXJzY3JpcHQgc2hpZnRlZCB1cCBjb3JyZWN0bHlcblxuICAgICAgdmFyIHJvb3RWTGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICAgIHBvc2l0aW9uVHlwZTogXCJzaGlmdFwiLFxuICAgICAgICBwb3NpdGlvbkRhdGE6IC10b1NoaWZ0LFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiByb290bVxuICAgICAgICB9XVxuICAgICAgfSwgb3B0aW9ucyk7IC8vIEFkZCBhIGNsYXNzIHN1cnJvdW5kaW5nIGl0IHNvIHdlIGNhbiBhZGQgb24gdGhlIGFwcHJvcHJpYXRlXG4gICAgICAvLyBrZXJuaW5nXG5cbiAgICAgIHZhciByb290Vkxpc3RXcmFwID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wicm9vdFwiXSwgW3Jvb3RWTGlzdF0pO1xuICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJzcXJ0XCJdLCBbcm9vdFZMaXN0V3JhcCwgYm9keV0sIG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBib2R5ID0gZ3JvdXAuYm9keSxcbiAgICAgICAgaW5kZXggPSBncm91cC5pbmRleDtcbiAgICByZXR1cm4gaW5kZXggPyBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb290XCIsIFtidWlsZE1hdGhNTF9idWlsZEdyb3VwKGJvZHksIG9wdGlvbnMpLCBidWlsZE1hdGhNTF9idWlsZEdyb3VwKGluZGV4LCBvcHRpb25zKV0pIDogbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3FydFwiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChib2R5LCBvcHRpb25zKV0pO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9zdHlsaW5nLmpzXG5cblxuXG5cblxudmFyIHN0eWxpbmdfc3R5bGVNYXAgPSB7XG4gIFwiZGlzcGxheVwiOiBzcmNfU3R5bGUuRElTUExBWSxcbiAgXCJ0ZXh0XCI6IHNyY19TdHlsZS5URVhULFxuICBcInNjcmlwdFwiOiBzcmNfU3R5bGUuU0NSSVBULFxuICBcInNjcmlwdHNjcmlwdFwiOiBzcmNfU3R5bGUuU0NSSVBUU0NSSVBUXG59O1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInN0eWxpbmdcIixcbiAgbmFtZXM6IFtcIlxcXFxkaXNwbGF5c3R5bGVcIiwgXCJcXFxcdGV4dHN0eWxlXCIsIFwiXFxcXHNjcmlwdHN0eWxlXCIsIFwiXFxcXHNjcmlwdHNjcmlwdHN0eWxlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIgYnJlYWtPblRva2VuVGV4dCA9IF9yZWYuYnJlYWtPblRva2VuVGV4dCxcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmLmZ1bmNOYW1lLFxuICAgICAgICBwYXJzZXIgPSBfcmVmLnBhcnNlcjtcbiAgICAvLyBwYXJzZSBvdXQgdGhlIGltcGxpY2l0IGJvZHlcbiAgICB2YXIgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgYnJlYWtPblRva2VuVGV4dCk7IC8vIFRPRE86IFJlZmFjdG9yIHRvIGF2b2lkIGR1cGxpY2F0aW5nIHN0eWxlTWFwIGluIG11bHRpcGxlIHBsYWNlcyAoZS5nLlxuICAgIC8vIGhlcmUgYW5kIGluIGJ1aWxkSFRNTCBhbmQgZGUtZHVwZSB0aGUgZW51bWVyYXRpb24gb2YgYWxsIHRoZSBzdHlsZXMpLlxuICAgIC8vICRGbG93Rml4TWU6IFRoZSBuYW1lcyBhYm92ZSBleGFjdGx5IG1hdGNoIHRoZSBzdHlsZXMuXG5cbiAgICB2YXIgc3R5bGUgPSBmdW5jTmFtZS5zbGljZSgxLCBmdW5jTmFtZS5sZW5ndGggLSA1KTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzdHlsaW5nXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIC8vIEZpZ3VyZSBvdXQgd2hhdCBzdHlsZSB0byB1c2UgYnkgcHVsbGluZyBvdXQgdGhlIHN0eWxlIGZyb21cbiAgICAgIC8vIHRoZSBmdW5jdGlvbiBuYW1lXG4gICAgICBzdHlsZTogc3R5bGUsXG4gICAgICBib2R5OiBib2R5XG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gU3R5bGUgY2hhbmdlcyBhcmUgaGFuZGxlZCBpbiB0aGUgVGVYYm9vayBvbiBwZy4gNDQyLCBSdWxlIDMuXG4gICAgdmFyIG5ld1N0eWxlID0gc3R5bGluZ19zdHlsZU1hcFtncm91cC5zdHlsZV07XG4gICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKG5ld1N0eWxlKS53aXRoRm9udCgnJyk7XG4gICAgcmV0dXJuIHNpemluZ0dyb3VwKGdyb3VwLmJvZHksIG5ld09wdGlvbnMsIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gRmlndXJlIG91dCB3aGF0IHN0eWxlIHdlJ3JlIGNoYW5naW5nIHRvLlxuICAgIHZhciBuZXdTdHlsZSA9IHN0eWxpbmdfc3R5bGVNYXBbZ3JvdXAuc3R5bGVdO1xuICAgIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShuZXdTdHlsZSk7XG4gICAgdmFyIGlubmVyID0gYnVpbGRNYXRoTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG5ld09wdGlvbnMpO1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3R5bGVcIiwgaW5uZXIpO1xuICAgIHZhciBzdHlsZUF0dHJpYnV0ZXMgPSB7XG4gICAgICBcImRpc3BsYXlcIjogW1wiMFwiLCBcInRydWVcIl0sXG4gICAgICBcInRleHRcIjogW1wiMFwiLCBcImZhbHNlXCJdLFxuICAgICAgXCJzY3JpcHRcIjogW1wiMVwiLCBcImZhbHNlXCJdLFxuICAgICAgXCJzY3JpcHRzY3JpcHRcIjogW1wiMlwiLCBcImZhbHNlXCJdXG4gICAgfTtcbiAgICB2YXIgYXR0ciA9IHN0eWxlQXR0cmlidXRlc1tncm91cC5zdHlsZV07XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzY3JpcHRsZXZlbFwiLCBhdHRyWzBdKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImRpc3BsYXlzdHlsZVwiLCBhdHRyWzFdKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvc3Vwc3ViLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLyoqXG4gKiBTb21ldGltZXMsIGdyb3VwcyBwZXJmb3JtIHNwZWNpYWwgcnVsZXMgd2hlbiB0aGV5IGhhdmUgc3VwZXJzY3JpcHRzIG9yXG4gKiBzdWJzY3JpcHRzIGF0dGFjaGVkIHRvIHRoZW0uIFRoaXMgZnVuY3Rpb24gbGV0cyB0aGUgYHN1cHN1YmAgZ3JvdXAga25vdyB0aGF0XG4gKiBTb21ldGltZXMsIGdyb3VwcyBwZXJmb3JtIHNwZWNpYWwgcnVsZXMgd2hlbiB0aGV5IGhhdmUgc3VwZXJzY3JpcHRzIG9yXG4gKiBpdHMgaW5uZXIgZWxlbWVudCBzaG91bGQgaGFuZGxlIHRoZSBzdXBlcnNjcmlwdHMgYW5kIHN1YnNjcmlwdHMgaW5zdGVhZCBvZlxuICogaGFuZGxpbmcgdGhlbSBpdHNlbGYuXG4gKi9cbnZhciBzdXBzdWJfaHRtbEJ1aWxkZXJEZWxlZ2F0ZSA9IGZ1bmN0aW9uIGh0bWxCdWlsZGVyRGVsZWdhdGUoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgdmFyIGJhc2UgPSBncm91cC5iYXNlO1xuXG4gIGlmICghYmFzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKGJhc2UudHlwZSA9PT0gXCJvcFwiKSB7XG4gICAgLy8gT3BlcmF0b3JzIGhhbmRsZSBzdXBzdWJzIGRpZmZlcmVudGx5IHdoZW4gdGhleSBoYXZlIGxpbWl0c1xuICAgIC8vIChlLmcuIGBcXGRpc3BsYXlzdHlsZVxcc3VtXzJeM2ApXG4gICAgdmFyIGRlbGVnYXRlID0gYmFzZS5saW1pdHMgJiYgKG9wdGlvbnMuc3R5bGUuc2l6ZSA9PT0gc3JjX1N0eWxlLkRJU1BMQVkuc2l6ZSB8fCBiYXNlLmFsd2F5c0hhbmRsZVN1cFN1Yik7XG4gICAgcmV0dXJuIGRlbGVnYXRlID8gb3BfaHRtbEJ1aWxkZXIgOiBudWxsO1xuICB9IGVsc2UgaWYgKGJhc2UudHlwZSA9PT0gXCJvcGVyYXRvcm5hbWVcIikge1xuICAgIHZhciBfZGVsZWdhdGUgPSBiYXNlLmFsd2F5c0hhbmRsZVN1cFN1YiAmJiAob3B0aW9ucy5zdHlsZS5zaXplID09PSBzcmNfU3R5bGUuRElTUExBWS5zaXplIHx8IGJhc2UubGltaXRzKTtcblxuICAgIHJldHVybiBfZGVsZWdhdGUgPyBvcGVyYXRvcm5hbWVfaHRtbEJ1aWxkZXIgOiBudWxsO1xuICB9IGVsc2UgaWYgKGJhc2UudHlwZSA9PT0gXCJhY2NlbnRcIikge1xuICAgIHJldHVybiB1dGlscy5pc0NoYXJhY3RlckJveChiYXNlLmJhc2UpID8gYWNjZW50X2h0bWxCdWlsZGVyIDogbnVsbDtcbiAgfSBlbHNlIGlmIChiYXNlLnR5cGUgPT09IFwiaG9yaXpCcmFjZVwiKSB7XG4gICAgdmFyIGlzU3VwID0gIWdyb3VwLnN1YjtcbiAgICByZXR1cm4gaXNTdXAgPT09IGJhc2UuaXNPdmVyID8gaG9yaXpCcmFjZV9odG1sQnVpbGRlciA6IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07IC8vIFN1cGVyIHNjcmlwdHMgYW5kIHN1YnNjcmlwdHMsIHdob3NlIHByZWNpc2UgcGxhY2VtZW50IGNhbiBkZXBlbmQgb24gb3RoZXJcbi8vIGZ1bmN0aW9ucyB0aGF0IHByZWNlZGUgdGhlbS5cblxuXG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJzdXBzdWJcIixcbiAgaHRtbEJ1aWxkZXI6IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gU3VwZXJzY3JpcHQgYW5kIHN1YnNjcmlwdHMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgb24gcGFnZVxuICAgIC8vIDQ0NS00NDYsIHJ1bGVzIDE4KGEtZikuXG4gICAgLy8gSGVyZSBpcyB3aGVyZSB3ZSBkZWZlciB0byB0aGUgaW5uZXIgZ3JvdXAgaWYgaXQgc2hvdWxkIGhhbmRsZVxuICAgIC8vIHN1cGVyc2NyaXB0cyBhbmQgc3Vic2NyaXB0cyBpdHNlbGYuXG4gICAgdmFyIGJ1aWxkZXJEZWxlZ2F0ZSA9IHN1cHN1Yl9odG1sQnVpbGRlckRlbGVnYXRlKGdyb3VwLCBvcHRpb25zKTtcblxuICAgIGlmIChidWlsZGVyRGVsZWdhdGUpIHtcbiAgICAgIHJldHVybiBidWlsZGVyRGVsZWdhdGUoZ3JvdXAsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZUJhc2UgPSBncm91cC5iYXNlLFxuICAgICAgICB2YWx1ZVN1cCA9IGdyb3VwLnN1cCxcbiAgICAgICAgdmFsdWVTdWIgPSBncm91cC5zdWI7XG4gICAgdmFyIGJhc2UgPSBidWlsZEhUTUxfYnVpbGRHcm91cCh2YWx1ZUJhc2UsIG9wdGlvbnMpO1xuICAgIHZhciBzdXBtO1xuICAgIHZhciBzdWJtO1xuICAgIHZhciBtZXRyaWNzID0gb3B0aW9ucy5mb250TWV0cmljcygpOyAvLyBSdWxlIDE4YVxuXG4gICAgdmFyIHN1cFNoaWZ0ID0gMDtcbiAgICB2YXIgc3ViU2hpZnQgPSAwO1xuICAgIHZhciBpc0NoYXJhY3RlckJveCA9IHZhbHVlQmFzZSAmJiB1dGlscy5pc0NoYXJhY3RlckJveCh2YWx1ZUJhc2UpO1xuXG4gICAgaWYgKHZhbHVlU3VwKSB7XG4gICAgICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUob3B0aW9ucy5zdHlsZS5zdXAoKSk7XG4gICAgICBzdXBtID0gYnVpbGRIVE1MX2J1aWxkR3JvdXAodmFsdWVTdXAsIG5ld09wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoIWlzQ2hhcmFjdGVyQm94KSB7XG4gICAgICAgIHN1cFNoaWZ0ID0gYmFzZS5oZWlnaHQgLSBuZXdPcHRpb25zLmZvbnRNZXRyaWNzKCkuc3VwRHJvcCAqIG5ld09wdGlvbnMuc2l6ZU11bHRpcGxpZXIgLyBvcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2YWx1ZVN1Yikge1xuICAgICAgdmFyIF9uZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShvcHRpb25zLnN0eWxlLnN1YigpKTtcblxuICAgICAgc3VibSA9IGJ1aWxkSFRNTF9idWlsZEdyb3VwKHZhbHVlU3ViLCBfbmV3T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIGlmICghaXNDaGFyYWN0ZXJCb3gpIHtcbiAgICAgICAgc3ViU2hpZnQgPSBiYXNlLmRlcHRoICsgX25ld09wdGlvbnMuZm9udE1ldHJpY3MoKS5zdWJEcm9wICogX25ld09wdGlvbnMuc2l6ZU11bHRpcGxpZXIgLyBvcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICAgICAgfVxuICAgIH0gLy8gUnVsZSAxOGNcblxuXG4gICAgdmFyIG1pblN1cFNoaWZ0O1xuXG4gICAgaWYgKG9wdGlvbnMuc3R5bGUgPT09IHNyY19TdHlsZS5ESVNQTEFZKSB7XG4gICAgICBtaW5TdXBTaGlmdCA9IG1ldHJpY3Muc3VwMTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc3R5bGUuY3JhbXBlZCkge1xuICAgICAgbWluU3VwU2hpZnQgPSBtZXRyaWNzLnN1cDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pblN1cFNoaWZ0ID0gbWV0cmljcy5zdXAyO1xuICAgIH0gLy8gc2NyaXB0c3BhY2UgaXMgYSBmb250LXNpemUtaW5kZXBlbmRlbnQgc2l6ZSwgc28gc2NhbGUgaXRcbiAgICAvLyBhcHByb3ByaWF0ZWx5IGZvciB1c2UgYXMgdGhlIG1hcmdpblJpZ2h0LlxuXG5cbiAgICB2YXIgbXVsdGlwbGllciA9IG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gICAgdmFyIG1hcmdpblJpZ2h0ID0gMC41IC8gbWV0cmljcy5wdFBlckVtIC8gbXVsdGlwbGllciArIFwiZW1cIjtcbiAgICB2YXIgbWFyZ2luTGVmdCA9IG51bGw7XG5cbiAgICBpZiAoc3VibSkge1xuICAgICAgLy8gU3Vic2NyaXB0cyBzaG91bGRuJ3QgYmUgc2hpZnRlZCBieSB0aGUgYmFzZSdzIGl0YWxpYyBjb3JyZWN0aW9uLlxuICAgICAgLy8gQWNjb3VudCBmb3IgdGhhdCBieSBzaGlmdGluZyB0aGUgc3Vic2NyaXB0IGJhY2sgdGhlIGFwcHJvcHJpYXRlXG4gICAgICAvLyBhbW91bnQuIE5vdGUgd2Ugb25seSBkbyB0aGlzIHdoZW4gdGhlIGJhc2UgaXMgYSBzaW5nbGUgc3ltYm9sLlxuICAgICAgdmFyIGlzT2lpbnQgPSBncm91cC5iYXNlICYmIGdyb3VwLmJhc2UudHlwZSA9PT0gXCJvcFwiICYmIGdyb3VwLmJhc2UubmFtZSAmJiAoZ3JvdXAuYmFzZS5uYW1lID09PSBcIlxcXFxvaWludFwiIHx8IGdyb3VwLmJhc2UubmFtZSA9PT0gXCJcXFxcb2lpaW50XCIpO1xuXG4gICAgICBpZiAoYmFzZSBpbnN0YW5jZW9mIGRvbVRyZWVfU3ltYm9sTm9kZSB8fCBpc09paW50KSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgbWFyZ2luTGVmdCA9IC1iYXNlLml0YWxpYyArIFwiZW1cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3Vwc3ViO1xuXG4gICAgaWYgKHN1cG0gJiYgc3VibSkge1xuICAgICAgc3VwU2hpZnQgPSBNYXRoLm1heChzdXBTaGlmdCwgbWluU3VwU2hpZnQsIHN1cG0uZGVwdGggKyAwLjI1ICogbWV0cmljcy54SGVpZ2h0KTtcbiAgICAgIHN1YlNoaWZ0ID0gTWF0aC5tYXgoc3ViU2hpZnQsIG1ldHJpY3Muc3ViMik7XG4gICAgICB2YXIgcnVsZVdpZHRoID0gbWV0cmljcy5kZWZhdWx0UnVsZVRoaWNrbmVzczsgLy8gUnVsZSAxOGVcblxuICAgICAgdmFyIG1heFdpZHRoID0gNCAqIHJ1bGVXaWR0aDtcblxuICAgICAgaWYgKHN1cFNoaWZ0IC0gc3VwbS5kZXB0aCAtIChzdWJtLmhlaWdodCAtIHN1YlNoaWZ0KSA8IG1heFdpZHRoKSB7XG4gICAgICAgIHN1YlNoaWZ0ID0gbWF4V2lkdGggLSAoc3VwU2hpZnQgLSBzdXBtLmRlcHRoKSArIHN1Ym0uaGVpZ2h0O1xuICAgICAgICB2YXIgcHNpID0gMC44ICogbWV0cmljcy54SGVpZ2h0IC0gKHN1cFNoaWZ0IC0gc3VwbS5kZXB0aCk7XG5cbiAgICAgICAgaWYgKHBzaSA+IDApIHtcbiAgICAgICAgICBzdXBTaGlmdCArPSBwc2k7XG4gICAgICAgICAgc3ViU2hpZnQgLT0gcHNpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2bGlzdEVsZW0gPSBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogc3VibSxcbiAgICAgICAgc2hpZnQ6IHN1YlNoaWZ0LFxuICAgICAgICBtYXJnaW5SaWdodDogbWFyZ2luUmlnaHQsXG4gICAgICAgIG1hcmdpbkxlZnQ6IG1hcmdpbkxlZnRcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IHN1cG0sXG4gICAgICAgIHNoaWZ0OiAtc3VwU2hpZnQsXG4gICAgICAgIG1hcmdpblJpZ2h0OiBtYXJnaW5SaWdodFxuICAgICAgfV07XG4gICAgICBzdXBzdWIgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgICBwb3NpdGlvblR5cGU6IFwiaW5kaXZpZHVhbFNoaWZ0XCIsXG4gICAgICAgIGNoaWxkcmVuOiB2bGlzdEVsZW1cbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoc3VibSkge1xuICAgICAgLy8gUnVsZSAxOGJcbiAgICAgIHN1YlNoaWZ0ID0gTWF0aC5tYXgoc3ViU2hpZnQsIG1ldHJpY3Muc3ViMSwgc3VibS5oZWlnaHQgLSAwLjggKiBtZXRyaWNzLnhIZWlnaHQpO1xuICAgICAgdmFyIF92bGlzdEVsZW0gPSBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogc3VibSxcbiAgICAgICAgbWFyZ2luTGVmdDogbWFyZ2luTGVmdCxcbiAgICAgICAgbWFyZ2luUmlnaHQ6IG1hcmdpblJpZ2h0XG4gICAgICB9XTtcbiAgICAgIHN1cHN1YiA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICAgIHBvc2l0aW9uVHlwZTogXCJzaGlmdFwiLFxuICAgICAgICBwb3NpdGlvbkRhdGE6IHN1YlNoaWZ0LFxuICAgICAgICBjaGlsZHJlbjogX3ZsaXN0RWxlbVxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChzdXBtKSB7XG4gICAgICAvLyBSdWxlIDE4YywgZFxuICAgICAgc3VwU2hpZnQgPSBNYXRoLm1heChzdXBTaGlmdCwgbWluU3VwU2hpZnQsIHN1cG0uZGVwdGggKyAwLjI1ICogbWV0cmljcy54SGVpZ2h0KTtcbiAgICAgIHN1cHN1YiA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICAgIHBvc2l0aW9uVHlwZTogXCJzaGlmdFwiLFxuICAgICAgICBwb3NpdGlvbkRhdGE6IC1zdXBTaGlmdCxcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogc3VwbSxcbiAgICAgICAgICBtYXJnaW5SaWdodDogbWFyZ2luUmlnaHRcbiAgICAgICAgfV1cbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdXBzdWIgbXVzdCBoYXZlIGVpdGhlciBzdXAgb3Igc3ViLlwiKTtcbiAgICB9IC8vIFdyYXAgdGhlIHN1cHN1YiB2bGlzdCBpbiBhIHNwYW4ubXN1cHN1YiB0byByZXNldCB0ZXh0LWFsaWduLlxuXG5cbiAgICB2YXIgbWNsYXNzID0gZ2V0VHlwZU9mRG9tVHJlZShiYXNlLCBcInJpZ2h0XCIpIHx8IFwibW9yZFwiO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbbWNsYXNzXSwgW2Jhc2UsIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1zdXBzdWJcIl0sIFtzdXBzdWJdKV0sIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gSXMgdGhlIGlubmVyIGdyb3VwIGEgcmVsZXZhbnQgaG9yaXpvbmFsIGJyYWNlP1xuICAgIHZhciBpc0JyYWNlID0gZmFsc2U7XG4gICAgdmFyIGlzT3ZlcjtcbiAgICB2YXIgaXNTdXA7XG4gICAgdmFyIGhvcml6QnJhY2UgPSBjaGVja05vZGVUeXBlKGdyb3VwLmJhc2UsIFwiaG9yaXpCcmFjZVwiKTtcblxuICAgIGlmIChob3JpekJyYWNlKSB7XG4gICAgICBpc1N1cCA9ICEhZ3JvdXAuc3VwO1xuXG4gICAgICBpZiAoaXNTdXAgPT09IGhvcml6QnJhY2UuaXNPdmVyKSB7XG4gICAgICAgIGlzQnJhY2UgPSB0cnVlO1xuICAgICAgICBpc092ZXIgPSBob3JpekJyYWNlLmlzT3ZlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAuYmFzZSAmJiAoZ3JvdXAuYmFzZS50eXBlID09PSBcIm9wXCIgfHwgZ3JvdXAuYmFzZS50eXBlID09PSBcIm9wZXJhdG9ybmFtZVwiKSkge1xuICAgICAgZ3JvdXAuYmFzZS5wYXJlbnRJc1N1cFN1YiA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gW2J1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZ3JvdXAuYmFzZSwgb3B0aW9ucyldO1xuXG4gICAgaWYgKGdyb3VwLnN1Yikge1xuICAgICAgY2hpbGRyZW4ucHVzaChidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLnN1Yiwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIGlmIChncm91cC5zdXApIHtcbiAgICAgIGNoaWxkcmVuLnB1c2goYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5zdXAsIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZVR5cGU7XG5cbiAgICBpZiAoaXNCcmFjZSkge1xuICAgICAgbm9kZVR5cGUgPSBpc092ZXIgPyBcIm1vdmVyXCIgOiBcIm11bmRlclwiO1xuICAgIH0gZWxzZSBpZiAoIWdyb3VwLnN1Yikge1xuICAgICAgdmFyIGJhc2UgPSBncm91cC5iYXNlO1xuXG4gICAgICBpZiAoYmFzZSAmJiBiYXNlLnR5cGUgPT09IFwib3BcIiAmJiBiYXNlLmxpbWl0cyAmJiAob3B0aW9ucy5zdHlsZSA9PT0gc3JjX1N0eWxlLkRJU1BMQVkgfHwgYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIpKSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtb3ZlclwiO1xuICAgICAgfSBlbHNlIGlmIChiYXNlICYmIGJhc2UudHlwZSA9PT0gXCJvcGVyYXRvcm5hbWVcIiAmJiBiYXNlLmFsd2F5c0hhbmRsZVN1cFN1YiAmJiAoYmFzZS5saW1pdHMgfHwgb3B0aW9ucy5zdHlsZSA9PT0gc3JjX1N0eWxlLkRJU1BMQVkpKSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtb3ZlclwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1zdXBcIjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFncm91cC5zdXApIHtcbiAgICAgIHZhciBfYmFzZSA9IGdyb3VwLmJhc2U7XG5cbiAgICAgIGlmIChfYmFzZSAmJiBfYmFzZS50eXBlID09PSBcIm9wXCIgJiYgX2Jhc2UubGltaXRzICYmIChvcHRpb25zLnN0eWxlID09PSBzcmNfU3R5bGUuRElTUExBWSB8fCBfYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIpKSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtdW5kZXJcIjtcbiAgICAgIH0gZWxzZSBpZiAoX2Jhc2UgJiYgX2Jhc2UudHlwZSA9PT0gXCJvcGVyYXRvcm5hbWVcIiAmJiBfYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIgJiYgKF9iYXNlLmxpbWl0cyB8fCBvcHRpb25zLnN0eWxlID09PSBzcmNfU3R5bGUuRElTUExBWSkpIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm11bmRlclwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1zdWJcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9iYXNlMiA9IGdyb3VwLmJhc2U7XG5cbiAgICAgIGlmIChfYmFzZTIgJiYgX2Jhc2UyLnR5cGUgPT09IFwib3BcIiAmJiBfYmFzZTIubGltaXRzICYmIG9wdGlvbnMuc3R5bGUgPT09IHNyY19TdHlsZS5ESVNQTEFZKSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtdW5kZXJvdmVyXCI7XG4gICAgICB9IGVsc2UgaWYgKF9iYXNlMiAmJiBfYmFzZTIudHlwZSA9PT0gXCJvcGVyYXRvcm5hbWVcIiAmJiBfYmFzZTIuYWx3YXlzSGFuZGxlU3VwU3ViICYmIChvcHRpb25zLnN0eWxlID09PSBzcmNfU3R5bGUuRElTUExBWSB8fCBfYmFzZTIubGltaXRzKSkge1xuICAgICAgICBub2RlVHlwZSA9IFwibXVuZGVyb3ZlclwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1zdWJzdXBcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKG5vZGVUeXBlLCBjaGlsZHJlbik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL3N5bWJvbHNPcC5qc1xuXG5cblxuIC8vIE9wZXJhdG9yIFBhcnNlTm9kZXMgY3JlYXRlZCBpbiBQYXJzZXIuanMgZnJvbSBzeW1ib2wgR3JvdXBzIGluIHNyYy9zeW1ib2xzLmpzLlxuXG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJhdG9tXCIsXG4gIGh0bWxCdWlsZGVyOiBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYXRoc3ltKGdyb3VwLnRleHQsIGdyb3VwLm1vZGUsIG9wdGlvbnMsIFtcIm1cIiArIGdyb3VwLmZhbWlseV0pO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFtidWlsZE1hdGhNTF9tYWtlVGV4dChncm91cC50ZXh0LCBncm91cC5tb2RlKV0pO1xuXG4gICAgaWYgKGdyb3VwLmZhbWlseSA9PT0gXCJiaW5cIikge1xuICAgICAgdmFyIHZhcmlhbnQgPSBidWlsZE1hdGhNTF9nZXRWYXJpYW50KGdyb3VwLCBvcHRpb25zKTtcblxuICAgICAgaWYgKHZhcmlhbnQgPT09IFwiYm9sZC1pdGFsaWNcIikge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGh2YXJpYW50XCIsIHZhcmlhbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3JvdXAuZmFtaWx5ID09PSBcInB1bmN0XCIpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic2VwYXJhdG9yXCIsIFwidHJ1ZVwiKTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLmZhbWlseSA9PT0gXCJvcGVuXCIgfHwgZ3JvdXAuZmFtaWx5ID09PSBcImNsb3NlXCIpIHtcbiAgICAgIC8vIERlbGltcyBidWlsdCBoZXJlIHNob3VsZCBub3Qgc3RyZXRjaCB2ZXJ0aWNhbGx5LlxuICAgICAgLy8gU2VlIGRlbGltc2l6aW5nLmpzIGZvciBzdHJldGNoeSBkZWxpbXMuXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwiZmFsc2VcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL3N5bWJvbHNPcmQuanNcblxuXG5cblxuLy8gXCJtYXRob3JkXCIgYW5kIFwidGV4dG9yZFwiIFBhcnNlTm9kZXMgY3JlYXRlZCBpbiBQYXJzZXIuanMgZnJvbSBzeW1ib2wgR3JvdXBzIGluXG52YXIgZGVmYXVsdFZhcmlhbnQgPSB7XG4gIFwibWlcIjogXCJpdGFsaWNcIixcbiAgXCJtblwiOiBcIm5vcm1hbFwiLFxuICBcIm10ZXh0XCI6IFwibm9ybWFsXCJcbn07XG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJtYXRob3JkXCIsXG4gIGh0bWxCdWlsZGVyOiBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlT3JkKGdyb3VwLCBvcHRpb25zLCBcIm1hdGhvcmRcIik7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IGZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWlcIiwgW2J1aWxkTWF0aE1MX21ha2VUZXh0KGdyb3VwLnRleHQsIGdyb3VwLm1vZGUsIG9wdGlvbnMpXSk7XG4gICAgdmFyIHZhcmlhbnQgPSBidWlsZE1hdGhNTF9nZXRWYXJpYW50KGdyb3VwLCBvcHRpb25zKSB8fCBcIml0YWxpY1wiO1xuXG4gICAgaWYgKHZhcmlhbnQgIT09IGRlZmF1bHRWYXJpYW50W25vZGUudHlwZV0pIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgdmFyaWFudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwidGV4dG9yZFwiLFxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZU9yZChncm91cCwgb3B0aW9ucywgXCJ0ZXh0b3JkXCIpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIHRleHQgPSBidWlsZE1hdGhNTF9tYWtlVGV4dChncm91cC50ZXh0LCBncm91cC5tb2RlLCBvcHRpb25zKTtcbiAgICB2YXIgdmFyaWFudCA9IGJ1aWxkTWF0aE1MX2dldFZhcmlhbnQoZ3JvdXAsIG9wdGlvbnMpIHx8IFwibm9ybWFsXCI7XG4gICAgdmFyIG5vZGU7XG5cbiAgICBpZiAoZ3JvdXAubW9kZSA9PT0gJ3RleHQnKSB7XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGV4dFwiLCBbdGV4dF0pO1xuICAgIH0gZWxzZSBpZiAoL1swLTldLy50ZXN0KGdyb3VwLnRleHQpKSB7XG4gICAgICAvLyBUT0RPKGtldmluYikgbWVyZ2UgYWRqYWNlbnQgPG1uPiBub2Rlc1xuICAgICAgLy8gZG8gaXQgYXMgYSBwb3N0IHByb2Nlc3Npbmcgc3RlcFxuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW5cIiwgW3RleHRdKTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLnRleHQgPT09IFwiXFxcXHByaW1lXCIpIHtcbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFt0ZXh0XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1pXCIsIFt0ZXh0XSk7XG4gICAgfVxuXG4gICAgaWYgKHZhcmlhbnQgIT09IGRlZmF1bHRWYXJpYW50W25vZGUudHlwZV0pIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgdmFyaWFudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL3N5bWJvbHNTcGFjaW5nLmpzXG5cblxuXG4gLy8gQSBtYXAgb2YgQ1NTLWJhc2VkIHNwYWNpbmcgZnVuY3Rpb25zIHRvIHRoZWlyIENTUyBjbGFzcy5cblxudmFyIGNzc1NwYWNlID0ge1xuICBcIlxcXFxub2JyZWFrXCI6IFwibm9icmVha1wiLFxuICBcIlxcXFxhbGxvd2JyZWFrXCI6IFwiYWxsb3dicmVha1wiXG59OyAvLyBBIGxvb2t1cCB0YWJsZSB0byBkZXRlcm1pbmUgd2hldGhlciBhIHNwYWNpbmcgZnVuY3Rpb24vc3ltYm9sIHNob3VsZCBiZVxuLy8gdHJlYXRlZCBsaWtlIGEgcmVndWxhciBzcGFjZSBjaGFyYWN0ZXIuICBJZiBhIHN5bWJvbCBvciBjb21tYW5kIGlzIGEga2V5XG4vLyBpbiB0aGlzIHRhYmxlLCB0aGVuIGl0IHNob3VsZCBiZSBhIHJlZ3VsYXIgc3BhY2UgY2hhcmFjdGVyLiAgRnVydGhlcm1vcmUsXG4vLyB0aGUgYXNzb2NpYXRlZCB2YWx1ZSBtYXkgaGF2ZSBhIGBjbGFzc05hbWVgIHNwZWNpZnlpbmcgYW4gZXh0cmEgQ1NTIGNsYXNzXG4vLyB0byBhZGQgdG8gdGhlIGNyZWF0ZWQgYHNwYW5gLlxuXG52YXIgcmVndWxhclNwYWNlID0ge1xuICBcIiBcIjoge30sXG4gIFwiXFxcXCBcIjoge30sXG4gIFwiflwiOiB7XG4gICAgY2xhc3NOYW1lOiBcIm5vYnJlYWtcIlxuICB9LFxuICBcIlxcXFxzcGFjZVwiOiB7fSxcbiAgXCJcXFxcbm9icmVha3NwYWNlXCI6IHtcbiAgICBjbGFzc05hbWU6IFwibm9icmVha1wiXG4gIH1cbn07IC8vIFBhcnNlTm9kZTxcInNwYWNpbmdcIj4gY3JlYXRlZCBpbiBQYXJzZXIuanMgZnJvbSB0aGUgXCJzcGFjaW5nXCIgc3ltYm9sIEdyb3VwcyBpblxuLy8gc3JjL3N5bWJvbHMuanMuXG5cbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcInNwYWNpbmdcIixcbiAgaHRtbEJ1aWxkZXI6IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgaWYgKHJlZ3VsYXJTcGFjZS5oYXNPd25Qcm9wZXJ0eShncm91cC50ZXh0KSkge1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHJlZ3VsYXJTcGFjZVtncm91cC50ZXh0XS5jbGFzc05hbWUgfHwgXCJcIjsgLy8gU3BhY2VzIGFyZSBnZW5lcmF0ZWQgYnkgYWRkaW5nIGFuIGFjdHVhbCBzcGFjZS4gRWFjaCBvZiB0aGVzZVxuICAgICAgLy8gdGhpbmdzIGhhcyBhbiBlbnRyeSBpbiB0aGUgc3ltYm9scyB0YWJsZSwgc28gdGhlc2Ugd2lsbCBiZSB0dXJuZWRcbiAgICAgIC8vIGludG8gYXBwcm9wcmlhdGUgb3V0cHV0cy5cblxuICAgICAgaWYgKGdyb3VwLm1vZGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgIHZhciBvcmQgPSBidWlsZENvbW1vbi5tYWtlT3JkKGdyb3VwLCBvcHRpb25zLCBcInRleHRvcmRcIik7XG4gICAgICAgIG9yZC5jbGFzc2VzLnB1c2goY2xhc3NOYW1lKTtcbiAgICAgICAgcmV0dXJuIG9yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtc3BhY2VcIiwgY2xhc3NOYW1lXSwgW2J1aWxkQ29tbW9uLm1hdGhzeW0oZ3JvdXAudGV4dCwgZ3JvdXAubW9kZSwgb3B0aW9ucyldLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNzc1NwYWNlLmhhc093blByb3BlcnR5KGdyb3VwLnRleHQpKSB7XG4gICAgICAvLyBTcGFjZXMgYmFzZWQgb24ganVzdCBhIENTUyBjbGFzcy5cbiAgICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtc3BhY2VcIiwgY3NzU3BhY2VbZ3JvdXAudGV4dF1dLCBbXSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlVua25vd24gdHlwZSBvZiBzcGFjZSBcXFwiXCIgKyBncm91cC50ZXh0ICsgXCJcXFwiXCIpO1xuICAgIH1cbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBub2RlO1xuXG4gICAgaWYgKHJlZ3VsYXJTcGFjZS5oYXNPd25Qcm9wZXJ0eShncm91cC50ZXh0KSkge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRleHRcIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKFwiXFx4QTBcIildKTtcbiAgICB9IGVsc2UgaWYgKGNzc1NwYWNlLmhhc093blByb3BlcnR5KGdyb3VwLnRleHQpKSB7XG4gICAgICAvLyBDU1MtYmFzZWQgTWF0aE1MIHNwYWNlcyAoXFxub2JyZWFrLCBcXGFsbG93YnJlYWspIGFyZSBpZ25vcmVkXG4gICAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlVua25vd24gdHlwZSBvZiBzcGFjZSBcXFwiXCIgKyBncm91cC50ZXh0ICsgXCJcXFwiXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy90YWcuanNcblxuXG5cblxudmFyIHRhZ19wYWQgPSBmdW5jdGlvbiBwYWQoKSB7XG4gIHZhciBwYWROb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW10pO1xuICBwYWROb2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiNTAlXCIpO1xuICByZXR1cm4gcGFkTm9kZTtcbn07XG5cbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcInRhZ1wiLFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIHRhYmxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGFibGVcIiwgW25ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRyXCIsIFt0YWdfcGFkKCksIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRkXCIsIFtidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAuYm9keSwgb3B0aW9ucyldKSwgdGFnX3BhZCgpLCBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZFwiLCBbYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLnRhZywgb3B0aW9ucyldKV0pXSk7XG4gICAgdGFibGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIxMDAlXCIpO1xuICAgIHJldHVybiB0YWJsZTsgLy8gVE9ETzogTGVmdC1hbGlnbmVkIHRhZ3MuXG4gICAgLy8gQ3VycmVudGx5LCB0aGUgZ3JvdXAgYW5kIG9wdGlvbnMgcGFzc2VkIGhlcmUgZG8gbm90IGNvbnRhaW5cbiAgICAvLyBlbm91Z2ggaW5mbyB0byBzZXQgdGFnIGFsaWdubWVudC4gYGxlcW5vYCBpcyBpbiBTZXR0aW5ncyBidXQgaXQgaXNcbiAgICAvLyBub3QgcGFzc2VkIHRvIE9wdGlvbnMuIE9uIHRoZSBIVE1MIHNpZGUsIGxlcW5vIGlzXG4gICAgLy8gc2V0IGJ5IGEgQ1NTIGNsYXNzIGFwcGxpZWQgaW4gYnVpbGRUcmVlLmpzLiBUaGF0IHdvdWxkIGhhdmUgd29ya2VkXG4gICAgLy8gaW4gTWF0aE1MIGlmIGJyb3dzZXJzIHN1cHBvcnRlZCA8bWxhYmVsZWR0cj4uIFNpbmNlIHRoZXkgZG9uJ3QsIHdlXG4gICAgLy8gbmVlZCB0byByZXdyaXRlIHRoZSB3YXkgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQuXG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL3RleHQuanNcblxuXG5cbiAvLyBOb24tbWF0aHkgdGV4dCwgcG9zc2libHkgaW4gYSBmb250XG5cbnZhciB0ZXh0Rm9udEZhbWlsaWVzID0ge1xuICBcIlxcXFx0ZXh0XCI6IHVuZGVmaW5lZCxcbiAgXCJcXFxcdGV4dHJtXCI6IFwidGV4dHJtXCIsXG4gIFwiXFxcXHRleHRzZlwiOiBcInRleHRzZlwiLFxuICBcIlxcXFx0ZXh0dHRcIjogXCJ0ZXh0dHRcIixcbiAgXCJcXFxcdGV4dG5vcm1hbFwiOiBcInRleHRybVwiXG59O1xudmFyIHRleHRGb250V2VpZ2h0cyA9IHtcbiAgXCJcXFxcdGV4dGJmXCI6IFwidGV4dGJmXCIsXG4gIFwiXFxcXHRleHRtZFwiOiBcInRleHRtZFwiXG59O1xudmFyIHRleHRGb250U2hhcGVzID0ge1xuICBcIlxcXFx0ZXh0aXRcIjogXCJ0ZXh0aXRcIixcbiAgXCJcXFxcdGV4dHVwXCI6IFwidGV4dHVwXCJcbn07XG5cbnZhciBvcHRpb25zV2l0aEZvbnQgPSBmdW5jdGlvbiBvcHRpb25zV2l0aEZvbnQoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgdmFyIGZvbnQgPSBncm91cC5mb250OyAvLyBDaGVja3MgaWYgdGhlIGFyZ3VtZW50IGlzIGEgZm9udCBmYW1pbHkgb3IgYSBmb250IHN0eWxlLlxuXG4gIGlmICghZm9udCkge1xuICAgIHJldHVybiBvcHRpb25zO1xuICB9IGVsc2UgaWYgKHRleHRGb250RmFtaWxpZXNbZm9udF0pIHtcbiAgICByZXR1cm4gb3B0aW9ucy53aXRoVGV4dEZvbnRGYW1pbHkodGV4dEZvbnRGYW1pbGllc1tmb250XSk7XG4gIH0gZWxzZSBpZiAodGV4dEZvbnRXZWlnaHRzW2ZvbnRdKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMud2l0aFRleHRGb250V2VpZ2h0KHRleHRGb250V2VpZ2h0c1tmb250XSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9wdGlvbnMud2l0aFRleHRGb250U2hhcGUodGV4dEZvbnRTaGFwZXNbZm9udF0pO1xuICB9XG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidGV4dFwiLFxuICBuYW1lczogWy8vIEZvbnQgZmFtaWxpZXNcbiAgXCJcXFxcdGV4dFwiLCBcIlxcXFx0ZXh0cm1cIiwgXCJcXFxcdGV4dHNmXCIsIFwiXFxcXHRleHR0dFwiLCBcIlxcXFx0ZXh0bm9ybWFsXCIsIC8vIEZvbnQgd2VpZ2h0c1xuICBcIlxcXFx0ZXh0YmZcIiwgXCJcXFxcdGV4dG1kXCIsIC8vIEZvbnQgU2hhcGVzXG4gIFwiXFxcXHRleHRpdFwiLCBcIlxcXFx0ZXh0dXBcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1widGV4dFwiXSxcbiAgICBncmVlZGluZXNzOiAyLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYucGFyc2VyLFxuICAgICAgICBmdW5jTmFtZSA9IF9yZWYuZnVuY05hbWU7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keTogZGVmaW5lRnVuY3Rpb25fb3JkYXJndW1lbnQoYm9keSksXG4gICAgICBmb250OiBmdW5jTmFtZVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBuZXdPcHRpb25zID0gb3B0aW9uc1dpdGhGb250KGdyb3VwLCBvcHRpb25zKTtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEhUTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG5ld09wdGlvbnMsIHRydWUpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwidGV4dFwiXSwgYnVpbGRDb21tb24udHJ5Q29tYmluZUNoYXJzKGlubmVyKSwgbmV3T3B0aW9ucyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IGZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnNXaXRoRm9udChncm91cCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGJ1aWxkRXhwcmVzc2lvblJvdyhncm91cC5ib2R5LCBuZXdPcHRpb25zKTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvdW5kZXJsaW5lLmpzXG5cblxuXG5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInVuZGVybGluZVwiLFxuICBuYW1lczogW1wiXFxcXHVuZGVybGluZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYucGFyc2VyO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInVuZGVybGluZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBhcmdzWzBdXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gVW5kZXJsaW5lcyBhcmUgaGFuZGxlZCBpbiB0aGUgVGVYYm9vayBwZyA0NDMsIFJ1bGUgMTAuXG4gICAgLy8gQnVpbGQgdGhlIGlubmVyIGdyb3VwLlxuICAgIHZhciBpbm5lckdyb3VwID0gYnVpbGRIVE1MX2J1aWxkR3JvdXAoZ3JvdXAuYm9keSwgb3B0aW9ucyk7IC8vIENyZWF0ZSB0aGUgbGluZSB0byBnbyBiZWxvdyB0aGUgYm9keVxuXG4gICAgdmFyIGxpbmUgPSBidWlsZENvbW1vbi5tYWtlTGluZVNwYW4oXCJ1bmRlcmxpbmUtbGluZVwiLCBvcHRpb25zKTsgLy8gR2VuZXJhdGUgdGhlIHZsaXN0LCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBrZXJuc1xuXG4gICAgdmFyIGRlZmF1bHRSdWxlVGhpY2tuZXNzID0gb3B0aW9ucy5mb250TWV0cmljcygpLmRlZmF1bHRSdWxlVGhpY2tuZXNzO1xuICAgIHZhciB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwidG9wXCIsXG4gICAgICBwb3NpdGlvbkRhdGE6IGlubmVyR3JvdXAuaGVpZ2h0LFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiBkZWZhdWx0UnVsZVRoaWNrbmVzc1xuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogbGluZVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogMyAqIGRlZmF1bHRSdWxlVGhpY2tuZXNzXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBpbm5lckdyb3VwXG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwidW5kZXJsaW5lXCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBvcGVyYXRvciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKFwiXFx1MjAzRVwiKV0pO1xuICAgIG9wZXJhdG9yLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwidHJ1ZVwiKTtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXVuZGVyXCIsIFtidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpLCBvcGVyYXRvcl0pO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiYWNjZW50dW5kZXJcIiwgXCJ0cnVlXCIpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy92ZXJiLmpzXG5cblxuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ2ZXJiXCIsXG4gIG5hbWVzOiBbXCJcXFxcdmVyYlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihjb250ZXh0LCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgLy8gXFx2ZXJiIGFuZCBcXHZlcmIqIGFyZSBkZWFsdCB3aXRoIGRpcmVjdGx5IGluIFBhcnNlci5qcy5cbiAgICAvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXQncyBiZWNhdXNlIG9mIGEgZmFpbHVyZSB0byBtYXRjaCB0aGUgdHdvIGRlbGltaXRlcnNcbiAgICAvLyBpbiB0aGUgcmVnZXggaW4gTGV4ZXIuanMuICBMYVRlWCByYWlzZXMgdGhlIGZvbGxvd2luZyBlcnJvciB3aGVuIFxcdmVyYiBpc1xuICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIGxpbmUgKG9yIGZpbGUpLlxuICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlxcXFx2ZXJiIGVuZGVkIGJ5IGVuZCBvZiBsaW5lIGluc3RlYWQgb2YgbWF0Y2hpbmcgZGVsaW1pdGVyXCIpO1xuICB9LFxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGV4dCA9IG1ha2VWZXJiKGdyb3VwKTtcbiAgICB2YXIgYm9keSA9IFtdOyAvLyBcXHZlcmIgZW50ZXJzIHRleHQgbW9kZSBhbmQgdGhlcmVmb3JlIGlzIHNpemVkIGxpa2UgXFx0ZXh0c3R5bGVcblxuICAgIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShvcHRpb25zLnN0eWxlLnRleHQoKSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gdGV4dFtpXTtcblxuICAgICAgaWYgKGMgPT09ICd+Jykge1xuICAgICAgICBjID0gJ1xcXFx0ZXh0YXNjaWl0aWxkZSc7XG4gICAgICB9XG5cbiAgICAgIGJvZHkucHVzaChidWlsZENvbW1vbi5tYWtlU3ltYm9sKGMsIFwiVHlwZXdyaXRlci1SZWd1bGFyXCIsIGdyb3VwLm1vZGUsIG5ld09wdGlvbnMsIFtcIm1vcmRcIiwgXCJ0ZXh0dHRcIl0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiLCBcInRleHRcIl0uY29uY2F0KG5ld09wdGlvbnMuc2l6aW5nQ2xhc3NlcyhvcHRpb25zKSksIGJ1aWxkQ29tbW9uLnRyeUNvbWJpbmVDaGFycyhib2R5KSwgbmV3T3B0aW9ucyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IGZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGV4dCA9IG5ldyBtYXRoTUxUcmVlLlRleHROb2RlKG1ha2VWZXJiKGdyb3VwKSk7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZXh0XCIsIFt0ZXh0XSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCBcIm1vbm9zcGFjZVwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG4vKipcbiAqIENvbnZlcnRzIHZlcmIgZ3JvdXAgaW50byBib2R5IHN0cmluZy5cbiAqXG4gKiBcXHZlcmIqIHJlcGxhY2VzIGVhY2ggc3BhY2Ugd2l0aCBhbiBvcGVuIGJveCBcXHUyNDIzXG4gKiBcXHZlcmIgcmVwbGFjZXMgZWFjaCBzcGFjZSB3aXRoIGEgbm8tYnJlYWsgc3BhY2UgXFx4QTBcbiAqL1xuXG52YXIgbWFrZVZlcmIgPSBmdW5jdGlvbiBtYWtlVmVyYihncm91cCkge1xuICByZXR1cm4gZ3JvdXAuYm9keS5yZXBsYWNlKC8gL2csIGdyb3VwLnN0YXIgPyBcIlxcdTI0MjNcIiA6ICdcXHhBMCcpO1xufTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy5qc1xuLyoqIEluY2x1ZGUgdGhpcyB0byBlbnN1cmUgdGhhdCBhbGwgZnVuY3Rpb25zIGFyZSBkZWZpbmVkLiAqL1xuXG52YXIgZnVuY3Rpb25zID0gX2Z1bmN0aW9ucztcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY19mdW5jdGlvbnMgPSAoZnVuY3Rpb25zKTsgLy8gVE9ETyhrZXZpbmIpOiBoYXZlIGZ1bmN0aW9ucyByZXR1cm4gYW4gb2JqZWN0IGFuZCBjYWxsIGRlZmluZUZ1bmN0aW9uIHdpdGhcbi8vIHRoYXQgb2JqZWN0IGluIHRoaXMgZmlsZSBpbnN0ZWFkIG9mIHJlbHlpbmcgb24gc2lkZS1lZmZlY3RzLlxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9MZXhlci5qc1xuLyoqXG4gKiBUaGUgTGV4ZXIgY2xhc3MgaGFuZGxlcyB0b2tlbml6aW5nIHRoZSBpbnB1dCBpbiB2YXJpb3VzIHdheXMuIFNpbmNlIG91clxuICogcGFyc2VyIGV4cGVjdHMgdXMgdG8gYmUgYWJsZSB0byBiYWNrdHJhY2ssIHRoZSBsZXhlciBhbGxvd3MgbGV4aW5nIGZyb20gYW55XG4gKiBnaXZlbiBzdGFydGluZyBwb2ludC5cbiAqXG4gKiBJdHMgbWFpbiBleHBvc2VkIGZ1bmN0aW9uIGlzIHRoZSBgbGV4YCBmdW5jdGlvbiwgd2hpY2ggdGFrZXMgYSBwb3NpdGlvbiB0b1xuICogbGV4IGZyb20gYW5kIGEgdHlwZSBvZiB0b2tlbiB0byBsZXguIEl0IGRlZmVycyB0byB0aGUgYXBwcm9wcmlhdGUgYF9pbm5lckxleGBcbiAqIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSB2YXJpb3VzIGBfaW5uZXJMZXhgIGZ1bmN0aW9ucyBwZXJmb3JtIHRoZSBhY3R1YWwgbGV4aW5nIG9mIGRpZmZlcmVudFxuICoga2luZHMuXG4gKi9cblxuXG5cblxuLyogVGhlIGZvbGxvd2luZyB0b2tlblJlZ2V4XG4gKiAtIG1hdGNoZXMgdHlwaWNhbCB3aGl0ZXNwYWNlIChidXQgbm90IE5CU1AgZXRjLikgdXNpbmcgaXRzIGZpcnN0IGdyb3VwXG4gKiAtIGRvZXMgbm90IG1hdGNoIGFueSBjb250cm9sIGNoYXJhY3RlciBcXHgwMC1cXHgxZiBleGNlcHQgd2hpdGVzcGFjZVxuICogLSBkb2VzIG5vdCBtYXRjaCBhIGJhcmUgYmFja3NsYXNoXG4gKiAtIG1hdGNoZXMgYW55IEFTQ0lJIGNoYXJhY3RlciBleGNlcHQgdGhvc2UganVzdCBtZW50aW9uZWRcbiAqIC0gZG9lcyBub3QgbWF0Y2ggdGhlIEJNUCBwcml2YXRlIHVzZSBhcmVhIFxcdUUwMDAtXFx1RjhGRlxuICogLSBkb2VzIG5vdCBtYXRjaCBiYXJlIHN1cnJvZ2F0ZSBjb2RlIHVuaXRzXG4gKiAtIG1hdGNoZXMgYW55IEJNUCBjaGFyYWN0ZXIgZXhjZXB0IGZvciB0aG9zZSBqdXN0IGRlc2NyaWJlZFxuICogLSBtYXRjaGVzIGFueSB2YWxpZCBVbmljb2RlIHN1cnJvZ2F0ZSBwYWlyXG4gKiAtIG1hdGNoZXMgYSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgbGV0dGVyc1xuICogLSBtYXRjaGVzIGEgYmFja3NsYXNoIGZvbGxvd2VkIGJ5IGFueSBCTVAgY2hhcmFjdGVyLCBpbmNsdWRpbmcgbmV3bGluZVxuICogSnVzdCBiZWNhdXNlIHRoZSBMZXhlciBtYXRjaGVzIHNvbWV0aGluZyBkb2Vzbid0IG1lYW4gaXQncyB2YWxpZCBpbnB1dDpcbiAqIElmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIGZ1bmN0aW9uIG9yIHN5bWJvbCBkZWZpbml0aW9uLCB0aGUgUGFyc2VyIHdpbGxcbiAqIHN0aWxsIHJlamVjdCB0aGUgaW5wdXQuXG4gKi9cbnZhciBzcGFjZVJlZ2V4U3RyaW5nID0gXCJbIFxcclxcblxcdF1cIjtcbnZhciBjb250cm9sV29yZFJlZ2V4U3RyaW5nID0gXCJcXFxcXFxcXFthLXpBLVpAXStcIjtcbnZhciBjb250cm9sU3ltYm9sUmVnZXhTdHJpbmcgPSBcIlxcXFxcXFxcW15cXHVEODAwLVxcdURGRkZdXCI7XG52YXIgY29udHJvbFdvcmRXaGl0ZXNwYWNlUmVnZXhTdHJpbmcgPSBcIlwiICsgY29udHJvbFdvcmRSZWdleFN0cmluZyArIHNwYWNlUmVnZXhTdHJpbmcgKyBcIipcIjtcbnZhciBjb250cm9sV29yZFdoaXRlc3BhY2VSZWdleCA9IG5ldyBSZWdFeHAoXCJeKFwiICsgY29udHJvbFdvcmRSZWdleFN0cmluZyArIFwiKVwiICsgc3BhY2VSZWdleFN0cmluZyArIFwiKiRcIik7XG52YXIgY29tYmluaW5nRGlhY3JpdGljYWxNYXJrU3RyaW5nID0gXCJbXFx1MDMwMC1cXHUwMzZGXVwiO1xudmFyIGNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya3NFbmRSZWdleCA9IG5ldyBSZWdFeHAoY29tYmluaW5nRGlhY3JpdGljYWxNYXJrU3RyaW5nICsgXCIrJFwiKTtcbnZhciB0b2tlblJlZ2V4U3RyaW5nID0gXCIoXCIgKyBzcGFjZVJlZ2V4U3RyaW5nICsgXCIrKXxcIiArIC8vIHdoaXRlc3BhY2VcblwiKFshLVxcXFxbXFxcXF0tXFx1MjAyN1xcdTIwMkEtXFx1RDdGRlxcdUY5MDAtXFx1RkZGRl1cIiArICggLy8gc2luZ2xlIGNvZGVwb2ludFxuY29tYmluaW5nRGlhY3JpdGljYWxNYXJrU3RyaW5nICsgXCIqXCIpICsgLy8gLi4ucGx1cyBhY2NlbnRzXG5cInxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdXCIgKyAoIC8vIHN1cnJvZ2F0ZSBwYWlyXG5jb21iaW5pbmdEaWFjcml0aWNhbE1hcmtTdHJpbmcgKyBcIipcIikgKyAvLyAuLi5wbHVzIGFjY2VudHNcblwifFxcXFxcXFxcdmVyYlxcXFwqKFteXSkuKj9cXFxcM1wiICsgLy8gXFx2ZXJiKlxuXCJ8XFxcXFxcXFx2ZXJiKFteKmEtekEtWl0pLio/XFxcXDRcIiArIC8vIFxcdmVyYiB1bnN0YXJyZWRcblwifFxcXFxcXFxcb3BlcmF0b3JuYW1lXFxcXCpcIiArICggLy8gXFxvcGVyYXRvcm5hbWUqXG5cInxcIiArIGNvbnRyb2xXb3JkV2hpdGVzcGFjZVJlZ2V4U3RyaW5nKSArICggLy8gXFxtYWNyb05hbWUgKyBzcGFjZXNcblwifFwiICsgY29udHJvbFN5bWJvbFJlZ2V4U3RyaW5nICsgXCIpXCIpOyAvLyBcXFxcLCBcXCcsIGV0Yy5cblxuLyoqIE1haW4gTGV4ZXIgY2xhc3MgKi9cblxudmFyIExleGVyX0xleGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLy8gY2F0ZWdvcnkgY29kZXMsIG9ubHkgc3VwcG9ydHMgY29tbWVudCBjaGFyYWN0ZXJzICgxNCkgZm9yIG5vd1xuICBmdW5jdGlvbiBMZXhlcihpbnB1dCwgc2V0dGluZ3MpIHtcbiAgICB0aGlzLmlucHV0ID0gdm9pZCAwO1xuICAgIHRoaXMuc2V0dGluZ3MgPSB2b2lkIDA7XG4gICAgdGhpcy50b2tlblJlZ2V4ID0gdm9pZCAwO1xuICAgIHRoaXMuY2F0Y29kZXMgPSB2b2lkIDA7XG4gICAgLy8gU2VwYXJhdGUgYWNjZW50cyBmcm9tIGNoYXJhY3RlcnNcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMudG9rZW5SZWdleCA9IG5ldyBSZWdFeHAodG9rZW5SZWdleFN0cmluZywgJ2cnKTtcbiAgICB0aGlzLmNhdGNvZGVzID0ge1xuICAgICAgXCIlXCI6IDE0IC8vIGNvbW1lbnQgY2hhcmFjdGVyXG5cbiAgICB9O1xuICB9XG5cbiAgdmFyIF9wcm90byA9IExleGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0Q2F0Y29kZSA9IGZ1bmN0aW9uIHNldENhdGNvZGUoY2hhciwgY29kZSkge1xuICAgIHRoaXMuY2F0Y29kZXNbY2hhcl0gPSBjb2RlO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGxleGVzIGEgc2luZ2xlIHRva2VuLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5sZXggPSBmdW5jdGlvbiBsZXgoKSB7XG4gICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dDtcbiAgICB2YXIgcG9zID0gdGhpcy50b2tlblJlZ2V4Lmxhc3RJbmRleDtcblxuICAgIGlmIChwb3MgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5ldyBUb2tlbl9Ub2tlbihcIkVPRlwiLCBuZXcgU291cmNlTG9jYXRpb24odGhpcywgcG9zLCBwb3MpKTtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2ggPSB0aGlzLnRva2VuUmVnZXguZXhlYyhpbnB1dCk7XG5cbiAgICBpZiAobWF0Y2ggPT09IG51bGwgfHwgbWF0Y2guaW5kZXggIT09IHBvcykge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXI6ICdcIiArIGlucHV0W3Bvc10gKyBcIidcIiwgbmV3IFRva2VuX1Rva2VuKGlucHV0W3Bvc10sIG5ldyBTb3VyY2VMb2NhdGlvbih0aGlzLCBwb3MsIHBvcyArIDEpKSk7XG4gICAgfVxuXG4gICAgdmFyIHRleHQgPSBtYXRjaFsyXSB8fCBcIiBcIjtcblxuICAgIGlmICh0aGlzLmNhdGNvZGVzW3RleHRdID09PSAxNCkge1xuICAgICAgLy8gY29tbWVudCBjaGFyYWN0ZXJcbiAgICAgIHZhciBubEluZGV4ID0gaW5wdXQuaW5kZXhPZignXFxuJywgdGhpcy50b2tlblJlZ2V4Lmxhc3RJbmRleCk7XG5cbiAgICAgIGlmIChubEluZGV4ID09PSAtMSkge1xuICAgICAgICB0aGlzLnRva2VuUmVnZXgubGFzdEluZGV4ID0gaW5wdXQubGVuZ3RoOyAvLyBFT0ZcblxuICAgICAgICB0aGlzLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdChcImNvbW1lbnRBdEVuZFwiLCBcIiUgY29tbWVudCBoYXMgbm8gdGVybWluYXRpbmcgbmV3bGluZTsgTGFUZVggd291bGQgXCIgKyBcImZhaWwgYmVjYXVzZSBvZiBjb21tZW50aW5nIHRoZSBlbmQgb2YgbWF0aCBtb2RlIChlLmcuICQpXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50b2tlblJlZ2V4Lmxhc3RJbmRleCA9IG5sSW5kZXggKyAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5sZXgoKTtcbiAgICB9IC8vIFRyaW0gYW55IHRyYWlsaW5nIHdoaXRlc3BhY2UgZnJvbSBjb250cm9sIHdvcmQgbWF0Y2hcblxuXG4gICAgdmFyIGNvbnRyb2xNYXRjaCA9IHRleHQubWF0Y2goY29udHJvbFdvcmRXaGl0ZXNwYWNlUmVnZXgpO1xuXG4gICAgaWYgKGNvbnRyb2xNYXRjaCkge1xuICAgICAgdGV4dCA9IGNvbnRyb2xNYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRva2VuX1Rva2VuKHRleHQsIG5ldyBTb3VyY2VMb2NhdGlvbih0aGlzLCBwb3MsIHRoaXMudG9rZW5SZWdleC5sYXN0SW5kZXgpKTtcbiAgfTtcblxuICByZXR1cm4gTGV4ZXI7XG59KCk7XG5cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvTmFtZXNwYWNlLmpzXG4vKipcbiAqIEEgYE5hbWVzcGFjZWAgcmVmZXJzIHRvIGEgc3BhY2Ugb2YgbmFtZWFibGUgdGhpbmdzIGxpa2UgbWFjcm9zIG9yIGxlbmd0aHMsXG4gKiB3aGljaCBjYW4gYmUgYHNldGAgZWl0aGVyIGdsb2JhbGx5IG9yIGxvY2FsIHRvIGEgbmVzdGVkIGdyb3VwLCB1c2luZyBhblxuICogdW5kbyBzdGFjayBzaW1pbGFyIHRvIGhvdyBUZVggaW1wbGVtZW50cyB0aGlzIGZ1bmN0aW9uYWxpdHkuXG4gKiBQZXJmb3JtYW5jZS13aXNlLCBgZ2V0YCBhbmQgbG9jYWwgYHNldGAgdGFrZSBjb25zdGFudCB0aW1lLCB3aGlsZSBnbG9iYWxcbiAqIGBzZXRgIHRha2VzIHRpbWUgcHJvcG9ydGlvbmFsIHRvIHRoZSBkZXB0aCBvZiBncm91cCBuZXN0aW5nLlxuICovXG5cblxudmFyIE5hbWVzcGFjZV9OYW1lc3BhY2UgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQm90aCBhcmd1bWVudHMgYXJlIG9wdGlvbmFsLiAgVGhlIGZpcnN0IGFyZ3VtZW50IGlzIGFuIG9iamVjdCBvZlxuICAgKiBidWlsdC1pbiBtYXBwaW5ncyB3aGljaCBuZXZlciBjaGFuZ2UuICBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICAgKiBvZiBpbml0aWFsIChnbG9iYWwtbGV2ZWwpIG1hcHBpbmdzLCB3aGljaCB3aWxsIGNvbnN0YW50bHkgY2hhbmdlXG4gICAqIGFjY29yZGluZyB0byBhbnkgZ2xvYmFsL3RvcC1sZXZlbCBgc2V0YHMgZG9uZS5cbiAgICovXG4gIGZ1bmN0aW9uIE5hbWVzcGFjZShidWlsdGlucywgZ2xvYmFsTWFjcm9zKSB7XG4gICAgaWYgKGJ1aWx0aW5zID09PSB2b2lkIDApIHtcbiAgICAgIGJ1aWx0aW5zID0ge307XG4gICAgfVxuXG4gICAgaWYgKGdsb2JhbE1hY3JvcyA9PT0gdm9pZCAwKSB7XG4gICAgICBnbG9iYWxNYWNyb3MgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5idWlsdGlucyA9IHZvaWQgMDtcbiAgICB0aGlzLnVuZGVmU3RhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5jdXJyZW50ID0gZ2xvYmFsTWFjcm9zO1xuICAgIHRoaXMuYnVpbHRpbnMgPSBidWlsdGlucztcbiAgICB0aGlzLnVuZGVmU3RhY2sgPSBbXTtcbiAgfVxuICAvKipcbiAgICogU3RhcnQgYSBuZXcgbmVzdGVkIGdyb3VwLCBhZmZlY3RpbmcgZnV0dXJlIGxvY2FsIGBzZXRgcy5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gTmFtZXNwYWNlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYmVnaW5Hcm91cCA9IGZ1bmN0aW9uIGJlZ2luR3JvdXAoKSB7XG4gICAgdGhpcy51bmRlZlN0YWNrLnB1c2goe30pO1xuICB9XG4gIC8qKlxuICAgKiBFbmQgY3VycmVudCBuZXN0ZWQgZ3JvdXAsIHJlc3RvcmluZyB2YWx1ZXMgYmVmb3JlIHRoZSBncm91cCBiZWdhbi5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZW5kR3JvdXAgPSBmdW5jdGlvbiBlbmRHcm91cCgpIHtcbiAgICBpZiAodGhpcy51bmRlZlN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiVW5iYWxhbmNlZCBuYW1lc3BhY2UgZGVzdHJ1Y3Rpb246IGF0dGVtcHQgXCIgKyBcInRvIHBvcCBnbG9iYWwgbmFtZXNwYWNlOyBwbGVhc2UgcmVwb3J0IHRoaXMgYXMgYSBidWdcIik7XG4gICAgfVxuXG4gICAgdmFyIHVuZGVmcyA9IHRoaXMudW5kZWZTdGFjay5wb3AoKTtcblxuICAgIGZvciAodmFyIHVuZGVmIGluIHVuZGVmcykge1xuICAgICAgaWYgKHVuZGVmcy5oYXNPd25Qcm9wZXJ0eSh1bmRlZikpIHtcbiAgICAgICAgaWYgKHVuZGVmc1t1bmRlZl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRbdW5kZWZdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY3VycmVudFt1bmRlZl0gPSB1bmRlZnNbdW5kZWZdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZXRlY3Qgd2hldGhlciBgbmFtZWAgaGFzIGEgZGVmaW5pdGlvbi4gIEVxdWl2YWxlbnQgdG9cbiAgICogYGdldChuYW1lKSAhPSBudWxsYC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaGFzID0gZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50Lmhhc093blByb3BlcnR5KG5hbWUpIHx8IHRoaXMuYnVpbHRpbnMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIG5hbWUsIG9yIGB1bmRlZmluZWRgIGlmIHRoZXJlIGlzIG5vIHZhbHVlLlxuICAgKlxuICAgKiBOb3RlOiBEbyBub3QgdXNlIGBpZiAobmFtZXNwYWNlLmdldCguLi4pKWAgdG8gZGV0ZWN0IHdoZXRoZXIgYSBtYWNyb1xuICAgKiBpcyBkZWZpbmVkLCBhcyB0aGUgZGVmaW5pdGlvbiBtYXkgYmUgdGhlIGVtcHR5IHN0cmluZyB3aGljaCBldmFsdWF0ZXNcbiAgICogdG8gYGZhbHNlYCBpbiBKYXZhU2NyaXB0LiAgVXNlIGBpZiAobmFtZXNwYWNlLmdldCguLi4pICE9IG51bGwpYCBvclxuICAgKiBgaWYgKG5hbWVzcGFjZS5oYXMoLi4uKSlgLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmJ1aWx0aW5zW25hbWVdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgbmFtZSwgYW5kIG9wdGlvbmFsbHkgc2V0IGl0IGdsb2JhbGx5IHRvby5cbiAgICogTG9jYWwgc2V0KCkgc2V0cyB0aGUgY3VycmVudCB2YWx1ZSBhbmQgKHdoZW4gYXBwcm9wcmlhdGUpIGFkZHMgYW4gdW5kb1xuICAgKiBvcGVyYXRpb24gdG8gdGhlIHVuZG8gc3RhY2suICBHbG9iYWwgc2V0KCkgbWF5IGNoYW5nZSB0aGUgdW5kb1xuICAgKiBvcGVyYXRpb24gYXQgZXZlcnkgbGV2ZWwsIHNvIHRha2VzIHRpbWUgbGluZWFyIGluIHRoZWlyIG51bWJlci5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KG5hbWUsIHZhbHVlLCBnbG9iYWwpIHtcbiAgICBpZiAoZ2xvYmFsID09PSB2b2lkIDApIHtcbiAgICAgIGdsb2JhbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChnbG9iYWwpIHtcbiAgICAgIC8vIEdsb2JhbCBzZXQgaXMgZXF1aXZhbGVudCB0byBzZXR0aW5nIGluIGFsbCBncm91cHMuICBTaW11bGF0ZSB0aGlzXG4gICAgICAvLyBieSBkZXN0cm95aW5nIGFueSB1bmRvcyBjdXJyZW50bHkgc2NoZWR1bGVkIGZvciB0aGlzIG5hbWUsXG4gICAgICAvLyBhbmQgYWRkaW5nIGFuIHVuZG8gd2l0aCB0aGUgKm5ldyogdmFsdWUgKGluIGNhc2UgaXQgbGF0ZXIgZ2V0c1xuICAgICAgLy8gbG9jYWxseSByZXNldCB3aXRoaW4gdGhpcyBlbnZpcm9ubWVudCkuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudW5kZWZTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZWxldGUgdGhpcy51bmRlZlN0YWNrW2ldW25hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy51bmRlZlN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy51bmRlZlN0YWNrW3RoaXMudW5kZWZTdGFjay5sZW5ndGggLSAxXVtuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVbmRvIHRoaXMgc2V0IGF0IGVuZCBvZiB0aGlzIGdyb3VwIChwb3NzaWJseSB0byBgdW5kZWZpbmVkYCksXG4gICAgICAvLyB1bmxlc3MgYW4gdW5kbyBpcyBhbHJlYWR5IGluIHBsYWNlLCBpbiB3aGljaCBjYXNlIHRoYXQgb2xkZXJcbiAgICAgIC8vIHZhbHVlIGlzIHRoZSBjb3JyZWN0IG9uZS5cbiAgICAgIHZhciB0b3AgPSB0aGlzLnVuZGVmU3RhY2tbdGhpcy51bmRlZlN0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAodG9wICYmICF0b3AuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgdG9wW25hbWVdID0gdGhpcy5jdXJyZW50W25hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY3VycmVudFtuYW1lXSA9IHZhbHVlO1xuICB9O1xuXG4gIHJldHVybiBOYW1lc3BhY2U7XG59KCk7XG5cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbWFjcm9zLmpzXG4vKipcbiAqIFByZWRlZmluZWQgbWFjcm9zIGZvciBLYVRlWC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gZGVmaW5lIHNvbWUgY29tbWFuZHMgaW4gdGVybXMgb2Ygb3RoZXJzLlxuICovXG5cblxuXG5cblxudmFyIGJ1aWx0aW5NYWNyb3MgPSB7fTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIG1hY3JvcyA9IChidWlsdGluTWFjcm9zKTsgLy8gVGhpcyBmdW5jdGlvbiBtaWdodCBvbmUgZGF5IGFjY2VwdCBhbiBhZGRpdGlvbmFsIGFyZ3VtZW50IGFuZCBkbyBtb3JlIHRoaW5ncy5cblxuZnVuY3Rpb24gZGVmaW5lTWFjcm8obmFtZSwgYm9keSkge1xuICBidWlsdGluTWFjcm9zW25hbWVdID0gYm9keTtcbn0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gbWFjcm8gdG9vbHNcbi8vIExhVGVYJ3MgXFxAZmlyc3RvZnR3b3sjMX17IzJ9IGV4cGFuZHMgdG8gIzEsIHNraXBwaW5nICMyXG4vLyBUZVggc291cmNlOiBcXGxvbmdcXGRlZlxcQGZpcnN0b2Z0d28jMSMyeyMxfVxuXG5kZWZpbmVNYWNybyhcIlxcXFxAZmlyc3RvZnR3b1wiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICB2YXIgYXJncyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMik7XG4gIHJldHVybiB7XG4gICAgdG9rZW5zOiBhcmdzWzBdLFxuICAgIG51bUFyZ3M6IDBcbiAgfTtcbn0pOyAvLyBMYVRlWCdzIFxcQHNlY29uZG9mdHdveyMxfXsjMn0gZXhwYW5kcyB0byAjMiwgc2tpcHBpbmcgIzFcbi8vIFRlWCBzb3VyY2U6IFxcbG9uZ1xcZGVmXFxAc2Vjb25kb2Z0d28jMSMyeyMyfVxuXG5kZWZpbmVNYWNybyhcIlxcXFxAc2Vjb25kb2Z0d29cIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgdmFyIGFyZ3MgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDIpO1xuICByZXR1cm4ge1xuICAgIHRva2VuczogYXJnc1sxXSxcbiAgICBudW1BcmdzOiAwXG4gIH07XG59KTsgLy8gTGFUZVgncyBcXEBpZm5leHRjaGFyeyMxfXsjMn17IzN9IGxvb2tzIGFoZWFkIHRvIHRoZSBuZXh0ICh1bmV4cGFuZGVkKVxuLy8gc3ltYm9sLiAgSWYgaXQgbWF0Y2hlcyAjMSwgdGhlbiB0aGUgbWFjcm8gZXhwYW5kcyB0byAjMjsgb3RoZXJ3aXNlLCAjMy5cbi8vIE5vdGUsIGhvd2V2ZXIsIHRoYXQgaXQgZG9lcyBub3QgY29uc3VtZSB0aGUgbmV4dCBzeW1ib2wgaW4gZWl0aGVyIGNhc2UuXG5cbmRlZmluZU1hY3JvKFwiXFxcXEBpZm5leHRjaGFyXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHZhciBhcmdzID0gY29udGV4dC5jb25zdW1lQXJncygzKTsgLy8gc3ltYm9sLCBpZiwgZWxzZVxuXG4gIHZhciBuZXh0VG9rZW4gPSBjb250ZXh0LmZ1dHVyZSgpO1xuXG4gIGlmIChhcmdzWzBdLmxlbmd0aCA9PT0gMSAmJiBhcmdzWzBdWzBdLnRleHQgPT09IG5leHRUb2tlbi50ZXh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuczogYXJnc1sxXSxcbiAgICAgIG51bUFyZ3M6IDBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbnM6IGFyZ3NbMl0sXG4gICAgICBudW1BcmdzOiAwXG4gICAgfTtcbiAgfVxufSk7IC8vIExhVGVYJ3MgXFxAaWZzdGFyeyMxfXsjMn0gbG9va3MgYWhlYWQgdG8gdGhlIG5leHQgKHVuZXhwYW5kZWQpIHN5bWJvbC5cbi8vIElmIGl0IGlzIGAqYCwgdGhlbiBpdCBjb25zdW1lcyB0aGUgc3ltYm9sLCBhbmQgdGhlIG1hY3JvIGV4cGFuZHMgdG8gIzE7XG4vLyBvdGhlcndpc2UsIHRoZSBtYWNybyBleHBhbmRzIHRvICMyICh3aXRob3V0IGNvbnN1bWluZyB0aGUgc3ltYm9sKS5cbi8vIFRlWCBzb3VyY2U6IFxcZGVmXFxAaWZzdGFyIzF7XFxAaWZuZXh0Y2hhciAqe1xcQGZpcnN0b2Z0d297IzF9fX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcQGlmc3RhclwiLCBcIlxcXFxAaWZuZXh0Y2hhciAqe1xcXFxAZmlyc3RvZnR3b3sjMX19XCIpOyAvLyBMYVRlWCdzIFxcVGV4dE9yTWF0aHsjMX17IzJ9IGV4cGFuZHMgdG8gIzEgaW4gdGV4dCBtb2RlLCAjMiBpbiBtYXRoIG1vZGVcblxuZGVmaW5lTWFjcm8oXCJcXFxcVGV4dE9yTWF0aFwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICB2YXIgYXJncyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMik7XG5cbiAgaWYgKGNvbnRleHQubW9kZSA9PT0gJ3RleHQnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuczogYXJnc1swXSxcbiAgICAgIG51bUFyZ3M6IDBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbnM6IGFyZ3NbMV0sXG4gICAgICBudW1BcmdzOiAwXG4gICAgfTtcbiAgfVxufSk7IC8vIExvb2t1cCB0YWJsZSBmb3IgcGFyc2luZyBudW1iZXJzIGluIGJhc2UgOCB0aHJvdWdoIDE2XG5cbnZhciBkaWdpdFRvTnVtYmVyID0ge1xuICBcIjBcIjogMCxcbiAgXCIxXCI6IDEsXG4gIFwiMlwiOiAyLFxuICBcIjNcIjogMyxcbiAgXCI0XCI6IDQsXG4gIFwiNVwiOiA1LFxuICBcIjZcIjogNixcbiAgXCI3XCI6IDcsXG4gIFwiOFwiOiA4LFxuICBcIjlcIjogOSxcbiAgXCJhXCI6IDEwLFxuICBcIkFcIjogMTAsXG4gIFwiYlwiOiAxMSxcbiAgXCJCXCI6IDExLFxuICBcImNcIjogMTIsXG4gIFwiQ1wiOiAxMixcbiAgXCJkXCI6IDEzLFxuICBcIkRcIjogMTMsXG4gIFwiZVwiOiAxNCxcbiAgXCJFXCI6IDE0LFxuICBcImZcIjogMTUsXG4gIFwiRlwiOiAxNVxufTsgLy8gVGVYIFxcY2hhciBtYWtlcyBhIGxpdGVyYWwgY2hhcmFjdGVyIChjYXRjb2RlIDEyKSB1c2luZyB0aGUgZm9sbG93aW5nIGZvcm1zOlxuLy8gKHNlZSBUaGUgVGVYQm9vaywgcC4gNDMpXG4vLyAgIFxcY2hhcjEyMyAgLS0gZGVjaW1hbFxuLy8gICBcXGNoYXInMTIzIC0tIG9jdGFsXG4vLyAgIFxcY2hhclwiMTIzIC0tIGhleFxuLy8gICBcXGNoYXJgeCAgIC0tIGNoYXJhY3RlciB0aGF0IGNhbiBiZSB3cml0dGVuIChpLmUuIGlzbid0IGFjdGl2ZSlcbi8vICAgXFxjaGFyYFxceCAgLS0gY2hhcmFjdGVyIHRoYXQgY2Fubm90IGJlIHdyaXR0ZW4gKGUuZy4gJSlcbi8vIFRoZXNlIGFsbCByZWZlciB0byBjaGFyYWN0ZXJzIGZyb20gdGhlIGZvbnQsIHNvIHdlIHR1cm4gdGhlbSBpbnRvIHNwZWNpYWxcbi8vIGNhbGxzIHRvIGEgZnVuY3Rpb24gXFxAY2hhciBkZWFsdCB3aXRoIGluIHRoZSBQYXJzZXIuXG5cbmRlZmluZU1hY3JvKFwiXFxcXGNoYXJcIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgdmFyIHRva2VuID0gY29udGV4dC5wb3BUb2tlbigpO1xuICB2YXIgYmFzZTtcbiAgdmFyIG51bWJlciA9ICcnO1xuXG4gIGlmICh0b2tlbi50ZXh0ID09PSBcIidcIikge1xuICAgIGJhc2UgPSA4O1xuICAgIHRva2VuID0gY29udGV4dC5wb3BUb2tlbigpO1xuICB9IGVsc2UgaWYgKHRva2VuLnRleHQgPT09ICdcIicpIHtcbiAgICBiYXNlID0gMTY7XG4gICAgdG9rZW4gPSBjb250ZXh0LnBvcFRva2VuKCk7XG4gIH0gZWxzZSBpZiAodG9rZW4udGV4dCA9PT0gXCJgXCIpIHtcbiAgICB0b2tlbiA9IGNvbnRleHQucG9wVG9rZW4oKTtcblxuICAgIGlmICh0b2tlbi50ZXh0WzBdID09PSBcIlxcXFxcIikge1xuICAgICAgbnVtYmVyID0gdG9rZW4udGV4dC5jaGFyQ29kZUF0KDEpO1xuICAgIH0gZWxzZSBpZiAodG9rZW4udGV4dCA9PT0gXCJFT0ZcIikge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiXFxcXGNoYXJgIG1pc3NpbmcgYXJndW1lbnRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bWJlciA9IHRva2VuLnRleHQuY2hhckNvZGVBdCgwKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmFzZSA9IDEwO1xuICB9XG5cbiAgaWYgKGJhc2UpIHtcbiAgICAvLyBQYXJzZSBhIG51bWJlciBpbiB0aGUgZ2l2ZW4gYmFzZSwgc3RhcnRpbmcgd2l0aCBmaXJzdCBgdG9rZW5gLlxuICAgIG51bWJlciA9IGRpZ2l0VG9OdW1iZXJbdG9rZW4udGV4dF07XG5cbiAgICBpZiAobnVtYmVyID09IG51bGwgfHwgbnVtYmVyID49IGJhc2UpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgYmFzZS1cIiArIGJhc2UgKyBcIiBkaWdpdCBcIiArIHRva2VuLnRleHQpO1xuICAgIH1cblxuICAgIHZhciBkaWdpdDtcblxuICAgIHdoaWxlICgoZGlnaXQgPSBkaWdpdFRvTnVtYmVyW2NvbnRleHQuZnV0dXJlKCkudGV4dF0pICE9IG51bGwgJiYgZGlnaXQgPCBiYXNlKSB7XG4gICAgICBudW1iZXIgKj0gYmFzZTtcbiAgICAgIG51bWJlciArPSBkaWdpdDtcbiAgICAgIGNvbnRleHQucG9wVG9rZW4oKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gXCJcXFxcQGNoYXJ7XCIgKyBudW1iZXIgKyBcIn1cIjtcbn0pOyAvLyBCYXNpYyBzdXBwb3J0IGZvciBtYWNybyBkZWZpbml0aW9uczpcbi8vICAgICBcXGRlZlxcbWFjcm97ZXhwYW5zaW9ufVxuLy8gICAgIFxcZGVmXFxtYWNybyMxe2V4cGFuc2lvbn1cbi8vICAgICBcXGRlZlxcbWFjcm8jMSMye2V4cGFuc2lvbn1cbi8vICAgICBcXGRlZlxcbWFjcm8jMSMyIzMjNCM1IzYjNyM4Izl7ZXhwYW5zaW9ufVxuLy8gQWxzbyB0aGUgXFxnZGVmIGFuZCBcXGdsb2JhbFxcZGVmIGVxdWl2YWxlbnRzXG5cbnZhciBtYWNyb3NfZGVmID0gZnVuY3Rpb24gZGVmKGNvbnRleHQsIGdsb2JhbCkge1xuICB2YXIgYXJnID0gY29udGV4dC5jb25zdW1lQXJncygxKVswXTtcblxuICBpZiAoYXJnLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlxcXFxnZGVmJ3MgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIG1hY3JvIG5hbWVcIik7XG4gIH1cblxuICB2YXIgbmFtZSA9IGFyZ1swXS50ZXh0OyAvLyBDb3VudCBhcmd1bWVudCBzcGVjaWZpZXJzLCBhbmQgY2hlY2sgdGhleSBhcmUgaW4gdGhlIG9yZGVyICMxICMyIC4uLlxuXG4gIHZhciBudW1BcmdzID0gMDtcbiAgYXJnID0gY29udGV4dC5jb25zdW1lQXJncygxKVswXTtcblxuICB3aGlsZSAoYXJnLmxlbmd0aCA9PT0gMSAmJiBhcmdbMF0udGV4dCA9PT0gXCIjXCIpIHtcbiAgICBhcmcgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDEpWzBdO1xuXG4gICAgaWYgKGFyZy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgYXJndW1lbnQgbnVtYmVyIGxlbmd0aCBcXFwiXCIgKyBhcmcubGVuZ3RoICsgXCJcXFwiXCIpO1xuICAgIH1cblxuICAgIGlmICghL15bMS05XSQvLnRlc3QoYXJnWzBdLnRleHQpKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50IG51bWJlciBcXFwiXCIgKyBhcmdbMF0udGV4dCArIFwiXFxcIlwiKTtcbiAgICB9XG5cbiAgICBudW1BcmdzKys7XG5cbiAgICBpZiAocGFyc2VJbnQoYXJnWzBdLnRleHQpICE9PSBudW1BcmdzKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJBcmd1bWVudCBudW1iZXIgXFxcIlwiICsgYXJnWzBdLnRleHQgKyBcIlxcXCIgb3V0IG9mIG9yZGVyXCIpO1xuICAgIH1cblxuICAgIGFyZyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMSlbMF07XG4gIH0gLy8gRmluYWwgYXJnIGlzIHRoZSBleHBhbnNpb24gb2YgdGhlIG1hY3JvXG5cblxuICBjb250ZXh0Lm1hY3Jvcy5zZXQobmFtZSwge1xuICAgIHRva2VuczogYXJnLFxuICAgIG51bUFyZ3M6IG51bUFyZ3NcbiAgfSwgZ2xvYmFsKTtcbiAgcmV0dXJuICcnO1xufTtcblxuZGVmaW5lTWFjcm8oXCJcXFxcZ2RlZlwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICByZXR1cm4gbWFjcm9zX2RlZihjb250ZXh0LCB0cnVlKTtcbn0pO1xuZGVmaW5lTWFjcm8oXCJcXFxcZGVmXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHJldHVybiBtYWNyb3NfZGVmKGNvbnRleHQsIGZhbHNlKTtcbn0pO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ2xvYmFsXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHZhciBuZXh0ID0gY29udGV4dC5jb25zdW1lQXJncygxKVswXTtcblxuICBpZiAobmV4dC5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbnZhbGlkIGNvbW1hbmQgYWZ0ZXIgXFxcXGdsb2JhbFwiKTtcbiAgfVxuXG4gIHZhciBjb21tYW5kID0gbmV4dFswXS50ZXh0OyAvLyBUT0RPOiBTaG91bGQgZXhwYW5kIGNvbW1hbmRcblxuICBpZiAoY29tbWFuZCA9PT0gXCJcXFxcZGVmXCIpIHtcbiAgICAvLyBcXGdsb2JhbFxcZGVmIGlzIGVxdWl2YWxlbnQgdG8gXFxnZGVmXG4gICAgcmV0dXJuIG1hY3Jvc19kZWYoY29udGV4dCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW52YWxpZCBjb21tYW5kICdcIiArIGNvbW1hbmQgKyBcIicgYWZ0ZXIgXFxcXGdsb2JhbFwiKTtcbiAgfVxufSk7IC8vIFxcbmV3Y29tbWFuZHtcXG1hY3JvfVthcmdzXXtkZWZpbml0aW9ufVxuLy8gXFxyZW5ld2NvbW1hbmR7XFxtYWNyb31bYXJnc117ZGVmaW5pdGlvbn1cbi8vIFRPRE86IE9wdGlvbmFsIGFyZ3VtZW50czogXFxuZXdjb21tYW5ke1xcbWFjcm99W2FyZ3NdW2RlZmF1bHRde2RlZmluaXRpb259XG5cbnZhciBtYWNyb3NfbmV3Y29tbWFuZCA9IGZ1bmN0aW9uIG5ld2NvbW1hbmQoY29udGV4dCwgZXhpc3RzT0ssIG5vbmV4aXN0c09LKSB7XG4gIHZhciBhcmcgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDEpWzBdO1xuXG4gIGlmIChhcmcubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiXFxcXG5ld2NvbW1hbmQncyBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgbWFjcm8gbmFtZVwiKTtcbiAgfVxuXG4gIHZhciBuYW1lID0gYXJnWzBdLnRleHQ7XG4gIHZhciBleGlzdHMgPSBjb250ZXh0LmlzRGVmaW5lZChuYW1lKTtcblxuICBpZiAoZXhpc3RzICYmICFleGlzdHNPSykge1xuICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlxcXFxuZXdjb21tYW5ke1wiICsgbmFtZSArIFwifSBhdHRlbXB0aW5nIHRvIHJlZGVmaW5lIFwiICsgKG5hbWUgKyBcIjsgdXNlIFxcXFxyZW5ld2NvbW1hbmRcIikpO1xuICB9XG5cbiAgaWYgKCFleGlzdHMgJiYgIW5vbmV4aXN0c09LKSB7XG4gICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiXFxcXHJlbmV3Y29tbWFuZHtcIiArIG5hbWUgKyBcIn0gd2hlbiBjb21tYW5kIFwiICsgbmFtZSArIFwiIFwiICsgXCJkb2VzIG5vdCB5ZXQgZXhpc3Q7IHVzZSBcXFxcbmV3Y29tbWFuZFwiKTtcbiAgfVxuXG4gIHZhciBudW1BcmdzID0gMDtcbiAgYXJnID0gY29udGV4dC5jb25zdW1lQXJncygxKVswXTtcblxuICBpZiAoYXJnLmxlbmd0aCA9PT0gMSAmJiBhcmdbMF0udGV4dCA9PT0gXCJbXCIpIHtcbiAgICB2YXIgYXJnVGV4dCA9ICcnO1xuICAgIHZhciB0b2tlbiA9IGNvbnRleHQuZXhwYW5kTmV4dFRva2VuKCk7XG5cbiAgICB3aGlsZSAodG9rZW4udGV4dCAhPT0gXCJdXCIgJiYgdG9rZW4udGV4dCAhPT0gXCJFT0ZcIikge1xuICAgICAgLy8gVE9ETzogU2hvdWxkIHByb3Blcmx5IGV4cGFuZCBhcmcsIGUuZy4sIGlnbm9yZSB7fXNcbiAgICAgIGFyZ1RleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgIHRva2VuID0gY29udGV4dC5leHBhbmROZXh0VG9rZW4oKTtcbiAgICB9XG5cbiAgICBpZiAoIWFyZ1RleHQubWF0Y2goL15cXHMqWzAtOV0rXFxzKiQvKSkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzOiBcIiArIGFyZ1RleHQpO1xuICAgIH1cblxuICAgIG51bUFyZ3MgPSBwYXJzZUludChhcmdUZXh0KTtcbiAgICBhcmcgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDEpWzBdO1xuICB9IC8vIEZpbmFsIGFyZyBpcyB0aGUgZXhwYW5zaW9uIG9mIHRoZSBtYWNyb1xuXG5cbiAgY29udGV4dC5tYWNyb3Muc2V0KG5hbWUsIHtcbiAgICB0b2tlbnM6IGFyZyxcbiAgICBudW1BcmdzOiBudW1BcmdzXG4gIH0pO1xuICByZXR1cm4gJyc7XG59O1xuXG5kZWZpbmVNYWNybyhcIlxcXFxuZXdjb21tYW5kXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHJldHVybiBtYWNyb3NfbmV3Y29tbWFuZChjb250ZXh0LCBmYWxzZSwgdHJ1ZSk7XG59KTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlbmV3Y29tbWFuZFwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICByZXR1cm4gbWFjcm9zX25ld2NvbW1hbmQoY29udGV4dCwgdHJ1ZSwgZmFsc2UpO1xufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxwcm92aWRlY29tbWFuZFwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICByZXR1cm4gbWFjcm9zX25ld2NvbW1hbmQoY29udGV4dCwgdHJ1ZSwgdHJ1ZSk7XG59KTsgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gR3JvdXBpbmdcbi8vIFxcbGV0XFxiZ3JvdXA9eyBcXGxldFxcZWdyb3VwPX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcYmdyb3VwXCIsIFwie1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGVncm91cFwiLCBcIn1cIik7IC8vIFN5bWJvbHMgZnJvbSBsYXRleC5sdHg6XG4vLyBcXGRlZlxcbHF7YH1cbi8vIFxcZGVmXFxycXsnfVxuLy8gXFxkZWYgXFxhYSB7XFxyIGF9XG4vLyBcXGRlZiBcXEFBIHtcXHIgQX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcbHFcIiwgXCJgXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccnFcIiwgXCInXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYWFcIiwgXCJcXFxcciBhXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcQUFcIiwgXCJcXFxcciBBXCIpOyAvLyBDb3B5cmlnaHQgKEMpIGFuZCByZWdpc3RlcmVkIChSKSBzeW1ib2xzLiBVc2UgcmF3IHN5bWJvbCBpbiBNYXRoTUwuXG4vLyBcXERlY2xhcmVUZXh0Q29tbWFuZERlZmF1bHR7XFx0ZXh0Y29weXJpZ2h0fXtcXHRleHRjaXJjbGVke2N9fVxuLy8gXFxEZWNsYXJlVGV4dENvbW1hbmREZWZhdWx0e1xcdGV4dHJlZ2lzdGVyZWR9e1xcdGV4dGNpcmNsZWR7JVxuLy8gICAgICBcXGNoZWNrQG1hdGhmb250c1xcZm9udHNpemVcXHNmQHNpemVcXHpAXFxtYXRoQGZvbnRzZmFsc2VcXHNlbGVjdGZvbnQgUn19XG4vLyBcXERlY2xhcmVSb2J1c3RDb21tYW5ke1xcY29weXJpZ2h0fXslXG4vLyAgICBcXGlmbW1vZGV7XFxuZnNzQHRleHR7XFx0ZXh0Y29weXJpZ2h0fX1cXGVsc2VcXHRleHRjb3B5cmlnaHRcXGZpfVxuXG5kZWZpbmVNYWNybyhcIlxcXFx0ZXh0Y29weXJpZ2h0XCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFx0ZXh0Y2lyY2xlZHtjfX17XFxcXGNoYXJgwql9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29weXJpZ2h0XCIsIFwiXFxcXFRleHRPck1hdGh7XFxcXHRleHRjb3B5cmlnaHR9e1xcXFx0ZXh0e1xcXFx0ZXh0Y29weXJpZ2h0fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0ZXh0cmVnaXN0ZXJlZFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcdGV4dGNpcmNsZWR7XFxcXHNjcmlwdHNpemUgUn19e1xcXFxjaGFyYMKufVwiKTsgLy8gQ2hhcmFjdGVycyBvbWl0dGVkIGZyb20gVW5pY29kZSByYW5nZSAxRDQwMOKAkzFEN0ZGXG5cbmRlZmluZU1hY3JvKFwiXFx1MjEyQ1wiLCBcIlxcXFxtYXRoc2Nye0J9XCIpOyAvLyBzY3JpcHRcblxuZGVmaW5lTWFjcm8oXCJcXHUyMTMwXCIsIFwiXFxcXG1hdGhzY3J7RX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIxMzFcIiwgXCJcXFxcbWF0aHNjcntGfVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjEwQlwiLCBcIlxcXFxtYXRoc2Nye0h9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMTEwXCIsIFwiXFxcXG1hdGhzY3J7SX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIxMTJcIiwgXCJcXFxcbWF0aHNjcntMfVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjEzM1wiLCBcIlxcXFxtYXRoc2Nye019XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMTFCXCIsIFwiXFxcXG1hdGhzY3J7Un1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIxMkRcIiwgXCJcXFxcbWF0aGZyYWt7Q31cIik7IC8vIEZyYWt0dXJcblxuZGVmaW5lTWFjcm8oXCJcXHUyMTBDXCIsIFwiXFxcXG1hdGhmcmFre0h9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMTI4XCIsIFwiXFxcXG1hdGhmcmFre1p9XCIpOyAvLyBEZWZpbmUgXFxCYmJrIHdpdGggYSBtYWNybyB0aGF0IHdvcmtzIGluIGJvdGggSFRNTCBhbmQgTWF0aE1MLlxuXG5kZWZpbmVNYWNybyhcIlxcXFxCYmJrXCIsIFwiXFxcXEJiYntrfVwiKTsgLy8gVW5pY29kZSBtaWRkbGUgZG90XG4vLyBUaGUgS2FUZVggZm9udHMgZG8gbm90IGNvbnRhaW4gVSswMEI3LiBJbnN0ZWFkLCBcXGNkb3RwIGRpc3BsYXlzXG4vLyB0aGUgZG90IGF0IFUrMjJDNSBhbmQgZ2l2ZXMgaXQgcHVuY3Qgc3BhY2luZy5cblxuZGVmaW5lTWFjcm8oXCJcXHhCN1wiLCBcIlxcXFxjZG90cFwiKTsgLy8gXFxsbGFwIGFuZCBcXHJsYXAgcmVuZGVyIHRoZWlyIGNvbnRlbnRzIGluIHRleHQgbW9kZVxuXG5kZWZpbmVNYWNybyhcIlxcXFxsbGFwXCIsIFwiXFxcXG1hdGhsbGFwe1xcXFx0ZXh0cm17IzF9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJsYXBcIiwgXCJcXFxcbWF0aHJsYXB7XFxcXHRleHRybXsjMX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY2xhcFwiLCBcIlxcXFxtYXRoY2xhcHtcXFxcdGV4dHJteyMxfX1cIik7IC8vIFxcbm90IGlzIGRlZmluZWQgYnkgYmFzZS9mb250bWF0aC5sdHggdmlhXG4vLyBcXERlY2xhcmVNYXRoU3ltYm9se1xcbm90fXtcXG1hdGhyZWx9e3N5bWJvbHN9e1wiMzZ9XG4vLyBJdCdzIHRodXMgdHJlYXRlZCBsaWtlIGEgXFxtYXRocmVsLCBidXQgZGVmaW5lZCBieSBhIHN5bWJvbCB0aGF0IGhhcyB6ZXJvXG4vLyB3aWR0aCBidXQgZXh0ZW5kcyB0byB0aGUgcmlnaHQuICBXZSB1c2UgXFxybGFwIHRvIGdldCB0aGF0IHNwYWNpbmcuXG4vLyBGb3IgTWF0aE1MIHdlIHdyaXRlIFUrMDMzOCBoZXJlLiBidWlsZE1hdGhNTC5qcyB3aWxsIHRoZW4gZG8gdGhlIG92ZXJsYXkuXG5cbmRlZmluZU1hY3JvKFwiXFxcXG5vdFwiLCAnXFxcXGh0bWxAbWF0aG1se1xcXFxtYXRocmVse1xcXFxtYXRocmxhcFxcXFxAbm90fX17XFxcXGNoYXJcIjMzOH0nKTsgLy8gTmVnYXRlZCBzeW1ib2xzIGZyb20gYmFzZS9mb250bWF0aC5sdHg6XG4vLyBcXGRlZlxcbmVxe1xcbm90PX0gXFxsZXRcXG5lPVxcbmVxXG4vLyBcXERlY2xhcmVSb2J1c3RDb21tYW5kXG4vLyAgIFxcbm90aW57XFxtYXRocmVse1xcbUB0aFxcbWF0aHBhbGV0dGVcXGNAbmNlbFxcaW59fVxuLy8gXFxkZWZcXGNAbmNlbCMxIzJ7XFxtQHRoXFxvb2FsaWdueyRcXGhmaWwjMVxcbWtlcm4xbXUvXFxoZmlsJFxcY3JjciQjMSMyJH19XG5cbmRlZmluZU1hY3JvKFwiXFxcXG5lcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcbWF0aHJlbHtcXFxcbm90PX19e1xcXFxtYXRocmVse1xcXFxjaGFyYOKJoH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbmVcIiwgXCJcXFxcbmVxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMjYwXCIsIFwiXFxcXG5lcVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5vdGluXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxtYXRocmVse3tcXFxcaW59XFxcXG1hdGhsbGFwey9cXFxcbXNraXAxbXV9fX1cIiArIFwie1xcXFxtYXRocmVse1xcXFxjaGFyYOKIiX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMjA5XCIsIFwiXFxcXG5vdGluXCIpOyAvLyBVbmljb2RlIHN0YWNrZWQgcmVsYXRpb25zXG5cbmRlZmluZU1hY3JvKFwiXFx1MjI1OFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7PVxcXFxrZXJuey0xZW19XFxcXHJhaXNlYm94ezAuNGVtfXskXFxcXHNjcmlwdHNpemVcXFxcZnJvd24kfX1cIiArIFwifXtcXFxcbWF0aHJlbHtcXFxcY2hhcmBcXHUyMjU4fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyNTlcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHN0YWNrcmVse1xcXFx0aW55XFxcXHdlZGdlfXs9fX17XFxcXG1hdGhyZWx7XFxcXGNoYXJgXFx1MjI1OH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMjVBXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxzdGFja3JlbHtcXFxcdGlueVxcXFx2ZWV9ez19fXtcXFxcbWF0aHJlbHtcXFxcY2hhcmBcXHUyMjVBfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyNUJcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHN0YWNrcmVse1xcXFxzY3JpcHRzaXplXFxcXHN0YXJ9ez19fVwiICsgXCJ7XFxcXG1hdGhyZWx7XFxcXGNoYXJgXFx1MjI1Qn19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMjVEXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxzdGFja3JlbHtcXFxcdGlueVxcXFxtYXRocm17ZGVmfX17PX19XCIgKyBcIntcXFxcbWF0aHJlbHtcXFxcY2hhcmBcXHUyMjVEfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyNUVcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHN0YWNrcmVse1xcXFx0aW55XFxcXG1hdGhybXttfX17PX19XCIgKyBcIntcXFxcbWF0aHJlbHtcXFxcY2hhcmBcXHUyMjVFfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyNUZcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHN0YWNrcmVse1xcXFx0aW55P317PX19e1xcXFxtYXRocmVse1xcXFxjaGFyYFxcdTIyNUZ9fVwiKTsgLy8gTWlzYyBVbmljb2RlXG5cbmRlZmluZU1hY3JvKFwiXFx1MjdDMlwiLCBcIlxcXFxwZXJwXCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMDNDXCIsIFwiXFxcXG1hdGhjbG9zZXshXFxcXG1rZXJuLTAuOG11IX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyMENcIiwgXCJcXFxcbm90bmlcIik7XG5kZWZpbmVNYWNybyhcIlxcdTIzMUNcIiwgXCJcXFxcdWxjb3JuZXJcIik7XG5kZWZpbmVNYWNybyhcIlxcdTIzMURcIiwgXCJcXFxcdXJjb3JuZXJcIik7XG5kZWZpbmVNYWNybyhcIlxcdTIzMUVcIiwgXCJcXFxcbGxjb3JuZXJcIik7XG5kZWZpbmVNYWNybyhcIlxcdTIzMUZcIiwgXCJcXFxcbHJjb3JuZXJcIik7XG5kZWZpbmVNYWNybyhcIlxceEE5XCIsIFwiXFxcXGNvcHlyaWdodFwiKTtcbmRlZmluZU1hY3JvKFwiXFx4QUVcIiwgXCJcXFxcdGV4dHJlZ2lzdGVyZWRcIik7XG5kZWZpbmVNYWNybyhcIlxcdUZFMEZcIiwgXCJcXFxcdGV4dHJlZ2lzdGVyZWRcIik7IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIExhVGVYXzLOtVxuLy8gXFx2ZG90c3tcXHZib3h7XFxiYXNlbGluZXNraXA0XFxwQCAgXFxsaW5lc2tpcGxpbWl0XFx6QFxuLy8gXFxrZXJuNlxccEBcXGhib3h7Ln1cXGhib3h7Ln1cXGhib3h7Ln19fVxuLy8gV2UnbGwgY2FsbCBcXHZhcnZkb3RzLCB3aGljaCBnZXRzIGEgZ2x5cGggZnJvbSBzeW1ib2xzLmpzLlxuLy8gVGhlIHplcm8td2lkdGggcnVsZSBnZXRzIHVzIGFuIGVxdWl2YWxlbnQgdG8gdGhlIHZlcnRpY2FsIDZwdCBrZXJuLlxuXG5kZWZpbmVNYWNybyhcIlxcXFx2ZG90c1wiLCBcIlxcXFxtYXRob3Jke1xcXFx2YXJ2ZG90c1xcXFxydWxlezBwdH17MTVwdH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMkVFXCIsIFwiXFxcXHZkb3RzXCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBhbXNtYXRoLnN0eVxuLy8gaHR0cDovL21pcnJvcnMuY29uY2VydHBhc3MuY29tL3RleC1hcmNoaXZlL21hY3Jvcy9sYXRleC9yZXF1aXJlZC9hbXNtYXRoL2Ftc21hdGgucGRmXG4vLyBJdGFsaWMgR3JlZWsgY2FwaXRhbCBsZXR0ZXJzLiAgQU1TIGRlZmluZXMgdGhlc2Ugd2l0aCBcXERlY2xhcmVNYXRoU3ltYm9sLFxuLy8gYnV0IHRoZXkgYXJlIGVxdWl2YWxlbnQgdG8gXFxtYXRoaXR7XFxMZXR0ZXJ9LlxuXG5kZWZpbmVNYWNybyhcIlxcXFx2YXJHYW1tYVwiLCBcIlxcXFxtYXRoaXR7XFxcXEdhbW1hfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhckRlbHRhXCIsIFwiXFxcXG1hdGhpdHtcXFxcRGVsdGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyVGhldGFcIiwgXCJcXFxcbWF0aGl0e1xcXFxUaGV0YX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJMYW1iZGFcIiwgXCJcXFxcbWF0aGl0e1xcXFxMYW1iZGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyWGlcIiwgXCJcXFxcbWF0aGl0e1xcXFxYaX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJQaVwiLCBcIlxcXFxtYXRoaXR7XFxcXFBpfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhclNpZ21hXCIsIFwiXFxcXG1hdGhpdHtcXFxcU2lnbWF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyVXBzaWxvblwiLCBcIlxcXFxtYXRoaXR7XFxcXFVwc2lsb259XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyUGhpXCIsIFwiXFxcXG1hdGhpdHtcXFxcUGhpfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhclBzaVwiLCBcIlxcXFxtYXRoaXR7XFxcXFBzaX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJPbWVnYVwiLCBcIlxcXFxtYXRoaXR7XFxcXE9tZWdhfVwiKTsgLy9cXG5ld2NvbW1hbmR7XFxzdWJzdGFja31bMV17XFxzdWJhcnJheXtjfSMxXFxlbmRzdWJhcnJheX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcc3Vic3RhY2tcIiwgXCJcXFxcYmVnaW57c3ViYXJyYXl9e2N9IzFcXFxcZW5ke3N1YmFycmF5fVwiKTsgLy8gXFxyZW5ld2NvbW1hbmR7XFxjb2xvbn17XFxub2JyZWFrXFxtc2tpcDJtdVxcbWF0aHB1bmN0e31cXG5vbnNjcmlwdFxuLy8gXFxta2Vybi1cXHRoaW5tdXNraXB7On1cXG1za2lwNm11cGx1czFtdVxccmVsYXh9XG5cbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uXCIsIFwiXFxcXG5vYnJlYWtcXFxcbXNraXAybXVcXFxcbWF0aHB1bmN0e31cIiArIFwiXFxcXG1hdGhjaG9pY2V7XFxcXG1rZXJuLTNtdX17XFxcXG1rZXJuLTNtdX17fXt9ezp9XFxcXG1za2lwNm11XCIpOyAvLyBcXG5ld2NvbW1hbmR7XFxib3hlZH1bMV17XFxmYm94e1xcbUB0aCRcXGRpc3BsYXlzdHlsZSMxJH19XG5cbmRlZmluZU1hY3JvKFwiXFxcXGJveGVkXCIsIFwiXFxcXGZib3h7JFxcXFxkaXNwbGF5c3R5bGV7IzF9JH1cIik7IC8vIFxcZGVmXFxpZmZ7XFxET1RTQlxcO1xcTG9uZ2xlZnRyaWdodGFycm93XFw7fVxuLy8gXFxkZWZcXGltcGxpZXN7XFxET1RTQlxcO1xcTG9uZ3JpZ2h0YXJyb3dcXDt9XG4vLyBcXGRlZlxcaW1wbGllZGJ5e1xcRE9UU0JcXDtcXExvbmdsZWZ0YXJyb3dcXDt9XG5cbmRlZmluZU1hY3JvKFwiXFxcXGlmZlwiLCBcIlxcXFxET1RTQlxcXFw7XFxcXExvbmdsZWZ0cmlnaHRhcnJvd1xcXFw7XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaW1wbGllc1wiLCBcIlxcXFxET1RTQlxcXFw7XFxcXExvbmdyaWdodGFycm93XFxcXDtcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpbXBsaWVkYnlcIiwgXCJcXFxcRE9UU0JcXFxcO1xcXFxMb25nbGVmdGFycm93XFxcXDtcIik7IC8vIEFNU01hdGgncyBhdXRvbWF0aWMgXFxkb3RzLCBiYXNlZCBvbiBcXG1kb3RzQEAgbWFjcm8uXG5cbnZhciBkb3RzQnlUb2tlbiA9IHtcbiAgJywnOiAnXFxcXGRvdHNjJyxcbiAgJ1xcXFxub3QnOiAnXFxcXGRvdHNiJyxcbiAgLy8gXFxrZXliaW5AIGNoZWNrcyBmb3IgdGhlIGZvbGxvd2luZzpcbiAgJysnOiAnXFxcXGRvdHNiJyxcbiAgJz0nOiAnXFxcXGRvdHNiJyxcbiAgJzwnOiAnXFxcXGRvdHNiJyxcbiAgJz4nOiAnXFxcXGRvdHNiJyxcbiAgJy0nOiAnXFxcXGRvdHNiJyxcbiAgJyonOiAnXFxcXGRvdHNiJyxcbiAgJzonOiAnXFxcXGRvdHNiJyxcbiAgLy8gU3ltYm9scyB3aG9zZSBkZWZpbml0aW9uIHN0YXJ0cyB3aXRoIFxcRE9UU0I6XG4gICdcXFxcRE9UU0InOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxjb3Byb2QnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxiaWd2ZWUnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxiaWd3ZWRnZSc6ICdcXFxcZG90c2InLFxuICAnXFxcXGJpZ3VwbHVzJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcYmlnY2FwJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcYmlnY3VwJzogJ1xcXFxkb3RzYicsXG4gICdcXFxccHJvZCc6ICdcXFxcZG90c2InLFxuICAnXFxcXHN1bSc6ICdcXFxcZG90c2InLFxuICAnXFxcXGJpZ290aW1lcyc6ICdcXFxcZG90c2InLFxuICAnXFxcXGJpZ29wbHVzJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcYmlnb2RvdCc6ICdcXFxcZG90c2InLFxuICAnXFxcXGJpZ3NxY3VwJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcQW5kJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcbG9uZ3JpZ2h0YXJyb3cnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxMb25ncmlnaHRhcnJvdyc6ICdcXFxcZG90c2InLFxuICAnXFxcXGxvbmdsZWZ0YXJyb3cnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxMb25nbGVmdGFycm93JzogJ1xcXFxkb3RzYicsXG4gICdcXFxcbG9uZ2xlZnRyaWdodGFycm93JzogJ1xcXFxkb3RzYicsXG4gICdcXFxcTG9uZ2xlZnRyaWdodGFycm93JzogJ1xcXFxkb3RzYicsXG4gICdcXFxcbWFwc3RvJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcbG9uZ21hcHN0byc6ICdcXFxcZG90c2InLFxuICAnXFxcXGhvb2tyaWdodGFycm93JzogJ1xcXFxkb3RzYicsXG4gICdcXFxcZG90ZXEnOiAnXFxcXGRvdHNiJyxcbiAgLy8gU3ltYm9scyB3aG9zZSBkZWZpbml0aW9uIHN0YXJ0cyB3aXRoIFxcbWF0aGJpbjpcbiAgJ1xcXFxtYXRoYmluJzogJ1xcXFxkb3RzYicsXG4gIC8vIFN5bWJvbHMgd2hvc2UgZGVmaW5pdGlvbiBzdGFydHMgd2l0aCBcXG1hdGhyZWw6XG4gICdcXFxcbWF0aHJlbCc6ICdcXFxcZG90c2InLFxuICAnXFxcXHJlbGJhcic6ICdcXFxcZG90c2InLFxuICAnXFxcXFJlbGJhcic6ICdcXFxcZG90c2InLFxuICAnXFxcXHhyaWdodGFycm93JzogJ1xcXFxkb3RzYicsXG4gICdcXFxceGxlZnRhcnJvdyc6ICdcXFxcZG90c2InLFxuICAvLyBTeW1ib2xzIHdob3NlIGRlZmluaXRpb24gc3RhcnRzIHdpdGggXFxET1RTSTpcbiAgJ1xcXFxET1RTSSc6ICdcXFxcZG90c2knLFxuICAnXFxcXGludCc6ICdcXFxcZG90c2knLFxuICAnXFxcXG9pbnQnOiAnXFxcXGRvdHNpJyxcbiAgJ1xcXFxpaW50JzogJ1xcXFxkb3RzaScsXG4gICdcXFxcaWlpbnQnOiAnXFxcXGRvdHNpJyxcbiAgJ1xcXFxpaWlpbnQnOiAnXFxcXGRvdHNpJyxcbiAgJ1xcXFxpZG90c2ludCc6ICdcXFxcZG90c2knLFxuICAvLyBTeW1ib2xzIHdob3NlIGRlZmluaXRpb24gc3RhcnRzIHdpdGggXFxET1RTWDpcbiAgJ1xcXFxET1RTWCc6ICdcXFxcZG90c3gnXG59O1xuZGVmaW5lTWFjcm8oXCJcXFxcZG90c1wiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAvLyBUT0RPOiBJZiB1c2VkIGluIHRleHQgbW9kZSwgc2hvdWxkIGV4cGFuZCB0byBcXHRleHRlbGxpcHNpcy5cbiAgLy8gSG93ZXZlciwgaW4gS2FUZVgsIFxcdGV4dGVsbGlwc2lzIGFuZCBcXGxkb3RzIGJlaGF2ZSB0aGUgc2FtZVxuICAvLyAoaW4gdGV4dCBtb2RlKSwgYW5kIGl0J3MgdW5saWtlbHkgd2UnZCBzZWUgYW55IG9mIHRoZSBtYXRoIGNvbW1hbmRzXG4gIC8vIHRoYXQgYWZmZWN0IHRoZSBiZWhhdmlvciBvZiBcXGRvdHMgd2hlbiBpbiB0ZXh0IG1vZGUuICBTbyBmaW5lIGZvciBub3dcbiAgLy8gKHVudGlsIHdlIHN1cHBvcnQgXFxpZm1tb2RlIC4uLiBcXGVsc2UgLi4uIFxcZmkpLlxuICB2YXIgdGhlZG90cyA9ICdcXFxcZG90c28nO1xuICB2YXIgbmV4dCA9IGNvbnRleHQuZXhwYW5kQWZ0ZXJGdXR1cmUoKS50ZXh0O1xuXG4gIGlmIChuZXh0IGluIGRvdHNCeVRva2VuKSB7XG4gICAgdGhlZG90cyA9IGRvdHNCeVRva2VuW25leHRdO1xuICB9IGVsc2UgaWYgKG5leHQuc3Vic3RyKDAsIDQpID09PSAnXFxcXG5vdCcpIHtcbiAgICB0aGVkb3RzID0gJ1xcXFxkb3RzYic7XG4gIH0gZWxzZSBpZiAobmV4dCBpbiBzcmNfc3ltYm9scy5tYXRoKSB7XG4gICAgaWYgKHV0aWxzLmNvbnRhaW5zKFsnYmluJywgJ3JlbCddLCBzcmNfc3ltYm9scy5tYXRoW25leHRdLmdyb3VwKSkge1xuICAgICAgdGhlZG90cyA9ICdcXFxcZG90c2InO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGVkb3RzO1xufSk7XG52YXIgc3BhY2VBZnRlckRvdHMgPSB7XG4gIC8vIFxccmlnaHRkZWxpbUAgY2hlY2tzIGZvciB0aGUgZm9sbG93aW5nOlxuICAnKSc6IHRydWUsXG4gICddJzogdHJ1ZSxcbiAgJ1xcXFxyYnJhY2snOiB0cnVlLFxuICAnXFxcXH0nOiB0cnVlLFxuICAnXFxcXHJicmFjZSc6IHRydWUsXG4gICdcXFxccmFuZ2xlJzogdHJ1ZSxcbiAgJ1xcXFxyY2VpbCc6IHRydWUsXG4gICdcXFxccmZsb29yJzogdHJ1ZSxcbiAgJ1xcXFxyZ3JvdXAnOiB0cnVlLFxuICAnXFxcXHJtb3VzdGFjaGUnOiB0cnVlLFxuICAnXFxcXHJpZ2h0JzogdHJ1ZSxcbiAgJ1xcXFxiaWdyJzogdHJ1ZSxcbiAgJ1xcXFxiaWdncic6IHRydWUsXG4gICdcXFxcQmlncic6IHRydWUsXG4gICdcXFxcQmlnZ3InOiB0cnVlLFxuICAvLyBcXGV4dHJhQCBhbHNvIHRlc3RzIGZvciB0aGUgZm9sbG93aW5nOlxuICAnJCc6IHRydWUsXG4gIC8vIFxcZXh0cmFwQCBjaGVja3MgZm9yIHRoZSBmb2xsb3dpbmc6XG4gICc7JzogdHJ1ZSxcbiAgJy4nOiB0cnVlLFxuICAnLCc6IHRydWVcbn07XG5kZWZpbmVNYWNybyhcIlxcXFxkb3Rzb1wiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICB2YXIgbmV4dCA9IGNvbnRleHQuZnV0dXJlKCkudGV4dDtcblxuICBpZiAobmV4dCBpbiBzcGFjZUFmdGVyRG90cykge1xuICAgIHJldHVybiBcIlxcXFxsZG90c1xcXFwsXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiXFxcXGxkb3RzXCI7XG4gIH1cbn0pO1xuZGVmaW5lTWFjcm8oXCJcXFxcZG90c2NcIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgdmFyIG5leHQgPSBjb250ZXh0LmZ1dHVyZSgpLnRleHQ7IC8vIFxcZG90c2MgdXNlcyBcXGV4dHJhQCBidXQgbm90IFxcZXh0cmFwQCwgaW5zdGVhZCBzcGVjaWFsbHkgY2hlY2tpbmcgZm9yXG4gIC8vICc7JyBhbmQgJy4nLCBidXQgZG9lc24ndCBjaGVjayBmb3IgJywnLlxuXG4gIGlmIChuZXh0IGluIHNwYWNlQWZ0ZXJEb3RzICYmIG5leHQgIT09ICcsJykge1xuICAgIHJldHVybiBcIlxcXFxsZG90c1xcXFwsXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiXFxcXGxkb3RzXCI7XG4gIH1cbn0pO1xuZGVmaW5lTWFjcm8oXCJcXFxcY2RvdHNcIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgdmFyIG5leHQgPSBjb250ZXh0LmZ1dHVyZSgpLnRleHQ7XG5cbiAgaWYgKG5leHQgaW4gc3BhY2VBZnRlckRvdHMpIHtcbiAgICByZXR1cm4gXCJcXFxcQGNkb3RzXFxcXCxcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcXFxcQGNkb3RzXCI7XG4gIH1cbn0pO1xuZGVmaW5lTWFjcm8oXCJcXFxcZG90c2JcIiwgXCJcXFxcY2RvdHNcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxkb3RzbVwiLCBcIlxcXFxjZG90c1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGRvdHNpXCIsIFwiXFxcXCFcXFxcY2RvdHNcIik7IC8vIGFtc21hdGggZG9lc24ndCBhY3R1YWxseSBkZWZpbmUgXFxkb3RzeCwgYnV0IFxcZG90cyBmb2xsb3dlZCBieSBhIG1hY3JvXG4vLyBzdGFydGluZyB3aXRoIFxcRE9UU1ggaW1wbGllcyBcXGRvdHNvLCBhbmQgdGhlbiBcXGV4dHJhQCBkZXRlY3RzIHRoaXMgY2FzZVxuLy8gYW5kIGZvcmNlcyB0aGUgYWRkZWQgYFxcLGAuXG5cbmRlZmluZU1hY3JvKFwiXFxcXGRvdHN4XCIsIFwiXFxcXGxkb3RzXFxcXCxcIik7IC8vIFxcbGV0XFxET1RTSVxccmVsYXhcbi8vIFxcbGV0XFxET1RTQlxccmVsYXhcbi8vIFxcbGV0XFxET1RTWFxccmVsYXhcblxuZGVmaW5lTWFjcm8oXCJcXFxcRE9UU0lcIiwgXCJcXFxccmVsYXhcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxET1RTQlwiLCBcIlxcXFxyZWxheFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXERPVFNYXCIsIFwiXFxcXHJlbGF4XCIpOyAvLyBTcGFjaW5nLCBiYXNlZCBvbiBhbXNtYXRoLnN0eSdzIG92ZXJyaWRlIG9mIExhVGVYIGRlZmF1bHRzXG4vLyBcXERlY2xhcmVSb2J1c3RDb21tYW5ke1xcdG1zcGFjZX1bM117JVxuLy8gICBcXGlmbW1vZGVcXG1za2lwIzEjMlxcZWxzZVxca2VybiMxIzNcXGZpXFxyZWxheH1cblxuZGVmaW5lTWFjcm8oXCJcXFxcdG1zcGFjZVwiLCBcIlxcXFxUZXh0T3JNYXRoe1xcXFxrZXJuIzEjM317XFxcXG1za2lwIzEjMn1cXFxccmVsYXhcIik7IC8vIFxccmVuZXdjb21tYW5ke1xcLH17XFx0bXNwYWNlK1xcdGhpbm11c2tpcHsuMTY2N2VtfX1cbi8vIFRPRE86IG1hdGggbW9kZSBzaG91bGQgdXNlIFxcdGhpbm11c2tpcFxuXG5kZWZpbmVNYWNybyhcIlxcXFwsXCIsIFwiXFxcXHRtc3BhY2UrezNtdX17LjE2NjdlbX1cIik7IC8vIFxcbGV0XFx0aGluc3BhY2VcXCxcblxuZGVmaW5lTWFjcm8oXCJcXFxcdGhpbnNwYWNlXCIsIFwiXFxcXCxcIik7IC8vIFxcZGVmXFw+e1xcbXNraXBcXG1lZG11c2tpcH1cbi8vIFxccmVuZXdjb21tYW5ke1xcOn17XFx0bXNwYWNlK1xcbWVkbXVza2lwey4yMjIyZW19fVxuLy8gVE9ETzogXFw+IGFuZCBtYXRoIG1vZGUgb2YgXFw6IHNob3VsZCB1c2UgXFxtZWRtdXNraXAgPSA0bXUgcGx1cyAybXUgbWludXMgNG11XG5cbmRlZmluZU1hY3JvKFwiXFxcXD5cIiwgXCJcXFxcbXNraXB7NG11fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXDpcIiwgXCJcXFxcdG1zcGFjZSt7NG11fXsuMjIyMmVtfVwiKTsgLy8gXFxsZXRcXG1lZHNwYWNlXFw6XG5cbmRlZmluZU1hY3JvKFwiXFxcXG1lZHNwYWNlXCIsIFwiXFxcXDpcIik7IC8vIFxccmVuZXdjb21tYW5ke1xcO317XFx0bXNwYWNlK1xcdGhpY2ttdXNraXB7LjI3NzdlbX19XG4vLyBUT0RPOiBtYXRoIG1vZGUgc2hvdWxkIHVzZSBcXHRoaWNrbXVza2lwID0gNW11IHBsdXMgNW11XG5cbmRlZmluZU1hY3JvKFwiXFxcXDtcIiwgXCJcXFxcdG1zcGFjZSt7NW11fXsuMjc3N2VtfVwiKTsgLy8gXFxsZXRcXHRoaWNrc3BhY2VcXDtcblxuZGVmaW5lTWFjcm8oXCJcXFxcdGhpY2tzcGFjZVwiLCBcIlxcXFw7XCIpOyAvLyBcXHJlbmV3Y29tbWFuZHtcXCF9e1xcdG1zcGFjZS1cXHRoaW5tdXNraXB7LjE2NjdlbX19XG4vLyBUT0RPOiBtYXRoIG1vZGUgc2hvdWxkIHVzZSBcXHRoaW5tdXNraXBcblxuZGVmaW5lTWFjcm8oXCJcXFxcIVwiLCBcIlxcXFx0bXNwYWNlLXszbXV9ey4xNjY3ZW19XCIpOyAvLyBcXGxldFxcbmVndGhpbnNwYWNlXFwhXG5cbmRlZmluZU1hY3JvKFwiXFxcXG5lZ3RoaW5zcGFjZVwiLCBcIlxcXFwhXCIpOyAvLyBcXG5ld2NvbW1hbmR7XFxuZWdtZWRzcGFjZX17XFx0bXNwYWNlLVxcbWVkbXVza2lwey4yMjIyZW19fVxuLy8gVE9ETzogbWF0aCBtb2RlIHNob3VsZCB1c2UgXFxtZWRtdXNraXBcblxuZGVmaW5lTWFjcm8oXCJcXFxcbmVnbWVkc3BhY2VcIiwgXCJcXFxcdG1zcGFjZS17NG11fXsuMjIyMmVtfVwiKTsgLy8gXFxuZXdjb21tYW5ke1xcbmVndGhpY2tzcGFjZX17XFx0bXNwYWNlLVxcdGhpY2ttdXNraXB7LjI3NzdlbX19XG4vLyBUT0RPOiBtYXRoIG1vZGUgc2hvdWxkIHVzZSBcXHRoaWNrbXVza2lwXG5cbmRlZmluZU1hY3JvKFwiXFxcXG5lZ3RoaWNrc3BhY2VcIiwgXCJcXFxcdG1zcGFjZS17NW11fXsuMjc3ZW19XCIpOyAvLyBcXGRlZlxcZW5zcGFjZXtcXGtlcm4uNWVtIH1cblxuZGVmaW5lTWFjcm8oXCJcXFxcZW5zcGFjZVwiLCBcIlxcXFxrZXJuLjVlbSBcIik7IC8vIFxcZGVmXFxlbnNraXB7XFxoc2tpcC41ZW1cXHJlbGF4fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxlbnNraXBcIiwgXCJcXFxcaHNraXAuNWVtXFxcXHJlbGF4XCIpOyAvLyBcXGRlZlxccXVhZHtcXGhza2lwMWVtXFxyZWxheH1cblxuZGVmaW5lTWFjcm8oXCJcXFxccXVhZFwiLCBcIlxcXFxoc2tpcDFlbVxcXFxyZWxheFwiKTsgLy8gXFxkZWZcXHFxdWFke1xcaHNraXAyZW1cXHJlbGF4fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxxcXVhZFwiLCBcIlxcXFxoc2tpcDJlbVxcXFxyZWxheFwiKTsgLy8gXFx0YWdAaW5AZGlzcGxheSBmb3JtIG9mIFxcdGFnXG5cbmRlZmluZU1hY3JvKFwiXFxcXHRhZ1wiLCBcIlxcXFxAaWZzdGFyXFxcXHRhZ0BsaXRlcmFsXFxcXHRhZ0BwYXJlblwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHRhZ0BwYXJlblwiLCBcIlxcXFx0YWdAbGl0ZXJhbHsoeyMxfSl9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGFnQGxpdGVyYWxcIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgaWYgKGNvbnRleHQubWFjcm9zLmdldChcIlxcXFxkZkB0YWdcIikpIHtcbiAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJNdWx0aXBsZSBcXFxcdGFnXCIpO1xuICB9XG5cbiAgcmV0dXJuIFwiXFxcXGdkZWZcXFxcZGZAdGFne1xcXFx0ZXh0eyMxfX1cIjtcbn0pOyAvLyBcXHJlbmV3Y29tbWFuZHtcXGJtb2R9e1xcbm9uc2NyaXB0XFxtc2tpcC1cXG1lZG11c2tpcFxcbWtlcm41bXVcXG1hdGhiaW5cbi8vICAge1xcb3BlcmF0b3JAZm9udCBtb2R9XFxwZW5hbHR5OTAwXG4vLyAgIFxcbWtlcm41bXVcXG5vbnNjcmlwdFxcbXNraXAtXFxtZWRtdXNraXB9XG4vLyBcXG5ld2NvbW1hbmR7XFxwb2R9WzFde1xcYWxsb3dicmVha1xuLy8gICBcXGlmQGRpc3BsYXlcXG1rZXJuMThtdVxcZWxzZVxcbWtlcm44bXVcXGZpKCMxKX1cbi8vIFxccmVuZXdjb21tYW5ke1xccG1vZH1bMV17XFxwb2R7e1xcb3BlcmF0b3JAZm9udCBtb2R9XFxta2VybjZtdSMxfX1cbi8vIFxcbmV3Y29tbWFuZHtcXG1vZH1bMV17XFxhbGxvd2JyZWFrXFxpZkBkaXNwbGF5XFxta2VybjE4bXVcbi8vICAgXFxlbHNlXFxta2VybjEybXVcXGZpe1xcb3BlcmF0b3JAZm9udCBtb2R9XFwsXFwsIzF9XG4vLyBUT0RPOiBtYXRoIG1vZGUgc2hvdWxkIHVzZSBcXG1lZG11c2tpcCA9IDRtdSBwbHVzIDJtdSBtaW51cyA0bXVcblxuZGVmaW5lTWFjcm8oXCJcXFxcYm1vZFwiLCBcIlxcXFxtYXRoY2hvaWNle1xcXFxtc2tpcDFtdX17XFxcXG1za2lwMW11fXtcXFxcbXNraXA1bXV9e1xcXFxtc2tpcDVtdX1cIiArIFwiXFxcXG1hdGhiaW57XFxcXHJtIG1vZH1cIiArIFwiXFxcXG1hdGhjaG9pY2V7XFxcXG1za2lwMW11fXtcXFxcbXNraXAxbXV9e1xcXFxtc2tpcDVtdX17XFxcXG1za2lwNW11fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBvZFwiLCBcIlxcXFxhbGxvd2JyZWFrXCIgKyBcIlxcXFxtYXRoY2hvaWNle1xcXFxta2VybjE4bXV9e1xcXFxta2VybjhtdX17XFxcXG1rZXJuOG11fXtcXFxcbWtlcm44bXV9KCMxKVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBtb2RcIiwgXCJcXFxccG9ke3tcXFxccm0gbW9kfVxcXFxta2VybjZtdSMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1vZFwiLCBcIlxcXFxhbGxvd2JyZWFrXCIgKyBcIlxcXFxtYXRoY2hvaWNle1xcXFxta2VybjE4bXV9e1xcXFxta2VybjEybXV9e1xcXFxta2VybjEybXV9e1xcXFxta2VybjEybXV9XCIgKyBcIntcXFxccm0gbW9kfVxcXFwsXFxcXCwjMVwiKTsgLy8gXFxwbWIgICAgLS0gICBBIHNpbXVsYXRpb24gb2YgYm9sZC5cbi8vIFRoZSB2ZXJzaW9uIGluIGFtYnN5LnN0eSB3b3JrcyBieSB0eXBlc2V0dGluZyB0aHJlZSBjb3BpZXMgb2YgdGhlIGFyZ3VtZW50XG4vLyB3aXRoIHNtYWxsIG9mZnNldHMuIFdlIHVzZSB0d28gY29waWVzLiBXZSBvbWl0IHRoZSB2ZXJ0aWNhbCBvZmZzZXQgYmVjYXVzZVxuLy8gb2YgcmVuZGVyaW5nIHByb2JsZW1zIHRoYXQgbWFrZVZMaXN0IGVuY291bnRlcnMgaW4gU2FmYXJpLlxuXG5kZWZpbmVNYWNybyhcIlxcXFxwbWJcIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxAYmlucmVseyMxfXtcXFxcbWF0aHJsYXB7IzF9XFxcXGtlcm4wLjVweCMxfX1cIiArIFwie1xcXFxtYXRoYmZ7IzF9fVwiKTsgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTGFUZVggc291cmNlMmVcbi8vIFxcXFwgZGVmYXVsdHMgdG8gXFxuZXdsaW5lLCBidXQgY2hhbmdlcyB0byBcXGNyIHdpdGhpbiBhcnJheSBlbnZpcm9ubWVudFxuXG5kZWZpbmVNYWNybyhcIlxcXFxcXFxcXCIsIFwiXFxcXG5ld2xpbmVcIik7IC8vIFxcZGVmXFxUZVh7VFxca2Vybi0uMTY2N2VtXFxsb3dlci41ZXhcXGhib3h7RX1cXGtlcm4tLjEyNWVtWFxcQH1cbi8vIFRPRE86IERvZXNuJ3Qgbm9ybWFsbHkgd29yayBpbiBtYXRoIG1vZGUgYmVjYXVzZSBcXEAgZmFpbHMuICBLYVRlWCBkb2Vzbid0XG4vLyBzdXBwb3J0IFxcQCB5ZXQsIHNvIHRoYXQncyBvbWl0dGVkLCBhbmQgd2UgYWRkIFxcdGV4dCBzbyB0aGF0IHRoZSByZXN1bHRcbi8vIGRvZXNuJ3QgbG9vayBmdW5ueSBpbiBtYXRoIG1vZGUuXG5cbmRlZmluZU1hY3JvKFwiXFxcXFRlWFwiLCBcIlxcXFx0ZXh0cm17XFxcXGh0bWxAbWF0aG1se1wiICsgXCJUXFxcXGtlcm4tLjE2NjdlbVxcXFxyYWlzZWJveHstLjVleH17RX1cXFxca2Vybi0uMTI1ZW1YXCIgKyBcIn17VGVYfX1cIik7IC8vIFxcRGVjbGFyZVJvYnVzdENvbW1hbmR7XFxMYVRlWH17TFxca2Vybi0uMzZlbSVcbi8vICAgICAgICAge1xcc2JveFxcekAgVCVcbi8vICAgICAgICAgIFxcdmJveCB0b1xcaHRcXHpAe1xcaGJveHtcXGNoZWNrQG1hdGhmb250c1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxmb250c2l6ZVxcc2ZAc2l6ZVxcekBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbWF0aEBmb250c2ZhbHNlXFxzZWxlY3Rmb250XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBfSVcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIFxcdnNzfSVcbi8vICAgICAgICAgfSVcbi8vICAgICAgICAgXFxrZXJuLS4xNWVtJVxuLy8gICAgICAgICBcXFRlWH1cbi8vIFRoaXMgY29kZSBhbGlnbnMgdGhlIHRvcCBvZiB0aGUgQSB3aXRoIHRoZSBUIChmcm9tIHRoZSBwZXJzcGVjdGl2ZSBvZiBUZVgnc1xuLy8gYm94ZXMsIHRob3VnaCB2aXN1YWxseSB0aGUgQSBhcHBlYXJzIHRvIGV4dGVuZCBhYm92ZSBzbGlnaHRseSkuXG4vLyBXZSBjb21wdXRlIHRoZSBjb3JyZXNwb25kaW5nIFxccmFpc2Vib3ggd2hlbiBBIGlzIHJlbmRlcmVkIGluIFxcbm9ybWFsc2l6ZVxuLy8gXFxzY3JpcHRzdHlsZSwgd2hpY2ggaGFzIGEgc2NhbGUgZmFjdG9yIG9mIDAuNyAoc2VlIE9wdGlvbnMuanMpLlxuXG52YXIgbGF0ZXhSYWlzZUEgPSBmb250TWV0cmljc0RhdGFbJ01haW4tUmVndWxhciddW1wiVFwiLmNoYXJDb2RlQXQoMCldWzFdIC0gMC43ICogZm9udE1ldHJpY3NEYXRhWydNYWluLVJlZ3VsYXInXVtcIkFcIi5jaGFyQ29kZUF0KDApXVsxXSArIFwiZW1cIjtcbmRlZmluZU1hY3JvKFwiXFxcXExhVGVYXCIsIFwiXFxcXHRleHRybXtcXFxcaHRtbEBtYXRobWx7XCIgKyAoXCJMXFxcXGtlcm4tLjM2ZW1cXFxccmFpc2Vib3h7XCIgKyBsYXRleFJhaXNlQSArIFwifXtcXFxcc2NyaXB0c3R5bGUgQX1cIikgKyBcIlxcXFxrZXJuLS4xNWVtXFxcXFRlWH17TGFUZVh9fVwiKTsgLy8gTmV3IEthVGVYIGxvZ28gYmFzZWQgb24gdHdlYWtpbmcgTGFUZVggbG9nb1xuXG5kZWZpbmVNYWNybyhcIlxcXFxLYVRlWFwiLCBcIlxcXFx0ZXh0cm17XFxcXGh0bWxAbWF0aG1se1wiICsgKFwiS1xcXFxrZXJuLS4xN2VtXFxcXHJhaXNlYm94e1wiICsgbGF0ZXhSYWlzZUEgKyBcIn17XFxcXHNjcmlwdHN0eWxlIEF9XCIpICsgXCJcXFxca2Vybi0uMTVlbVxcXFxUZVh9e0thVGVYfX1cIik7IC8vIFxcRGVjbGFyZVJvYnVzdENvbW1hbmRcXGhzcGFjZXtcXEBpZnN0YXJcXEBoc3BhY2VyXFxAaHNwYWNlfVxuLy8gXFxkZWZcXEBoc3BhY2UjMXtcXGhza2lwICAjMVxccmVsYXh9XG4vLyBcXGRlZlxcQGhzcGFjZXIjMXtcXHZydWxlIFxcQHdpZHRoXFx6QFxcbm9icmVha1xuLy8gICAgICAgICAgICAgICAgIFxcaHNraXAgIzFcXGhza2lwIFxcekBza2lwfVxuXG5kZWZpbmVNYWNybyhcIlxcXFxoc3BhY2VcIiwgXCJcXFxcQGlmc3RhclxcXFxAaHNwYWNlclxcXFxAaHNwYWNlXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcQGhzcGFjZVwiLCBcIlxcXFxoc2tpcCAjMVxcXFxyZWxheFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEBoc3BhY2VyXCIsIFwiXFxcXHJ1bGV7MHB0fXswcHR9XFxcXGhza2lwICMxXFxcXHJlbGF4XCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBtYXRodG9vbHMuc3R5XG4vL1xccHJvdmlkZWNvbW1hbmRcXG9yZGluYXJ5Y29sb257On1cblxuZGVmaW5lTWFjcm8oXCJcXFxcb3JkaW5hcnljb2xvblwiLCBcIjpcIik7IC8vXFxkZWZcXHZjZW50Y29sb257XFxtYXRocmVse1xcbWF0aG9wXFxvcmRpbmFyeWNvbG9ufX1cbi8vVE9ETyhlZGVtYWluZSk6IE5vdCB5ZXQgY2VudGVyZWQuIEZpeCB2aWEgXFxyYWlzZWJveCBvciAjNzI2XG5cbmRlZmluZU1hY3JvKFwiXFxcXHZjZW50Y29sb25cIiwgXCJcXFxcbWF0aHJlbHtcXFxcbWF0aG9wXFxcXG9yZGluYXJ5Y29sb259XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcZGJsY29sb257XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tLjltdX1cXHZjZW50Y29sb259XG5cbmRlZmluZU1hY3JvKFwiXFxcXGRibGNvbG9uXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcdmNlbnRjb2xvblxcXFxtYXRocmVse1xcXFxta2Vybi0uOW11fVxcXFx2Y2VudGNvbG9ufX1cIiArIFwie1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiMjIzN319XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcY29sb25lcXF7XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9PX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25lcXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRocmVse1xcXFx2Y2VudGNvbG9uXFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fT19fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjU0fX1cIik7IC8vIOKJlFxuLy8gXFxwcm92aWRlY29tbWFuZCpcXENvbG9uZXFxe1xcZGJsY29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX09fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxDb2xvbmVxcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7XFxcXGRibGNvbG9uXFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fT19fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjM3XFxcXGNoYXJcXFwiM2R9fVwiKTsgLy8gXFxwcm92aWRlY29tbWFuZCpcXGNvbG9uZXF7XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxtYXRocmVsey19fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmVxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcdmNlbnRjb2xvblxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcbWF0aHJlbHstfX19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjNhXFxcXGNoYXJcXFwiMjIxMn19XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcQ29sb25lcXtcXGRibGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxtYXRocmVsey19fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxDb2xvbmVxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcZGJsY29sb25cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXG1hdGhyZWx7LX19fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjM3XFxcXGNoYXJcXFwiMjIxMn19XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcZXFxY29sb257PVxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcdmNlbnRjb2xvbn1cblxuZGVmaW5lTWFjcm8oXCJcXFxcZXFxY29sb25cIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRocmVsez1cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXHZjZW50Y29sb259fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjU1fX1cIik7IC8vIOKJlVxuLy8gXFxwcm92aWRlY29tbWFuZCpcXEVxcWNvbG9uez1cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXGRibGNvbG9ufVxuXG5kZWZpbmVNYWNybyhcIlxcXFxFcXFjb2xvblwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7PVxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcZGJsY29sb259fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIzZFxcXFxjaGFyXFxcIjIyMzd9fVwiKTsgLy8gXFxwcm92aWRlY29tbWFuZCpcXGVxY29sb257XFxtYXRocmVsey19XFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFx2Y2VudGNvbG9ufVxuXG5kZWZpbmVNYWNybyhcIlxcXFxlcWNvbG9uXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcbWF0aHJlbHstfVxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcdmNlbnRjb2xvbn19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIyMzl9fVwiKTsgLy8gXFxwcm92aWRlY29tbWFuZCpcXEVxY29sb257XFxtYXRocmVsey19XFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxkYmxjb2xvbn1cblxuZGVmaW5lTWFjcm8oXCJcXFxcRXFjb2xvblwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7XFxcXG1hdGhyZWx7LX1cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXGRibGNvbG9ufX1cIiArIFwie1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiMjIxMlxcXFxjaGFyXFxcIjIyMzd9fVwiKTsgLy8gXFxwcm92aWRlY29tbWFuZCpcXGNvbG9uYXBwcm94e1xcdmNlbnRjb2xvblxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcYXBwcm94fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmFwcHJveFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7XFxcXHZjZW50Y29sb25cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXGFwcHJveH19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjNhXFxcXGNoYXJcXFwiMjI0OH19XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcQ29sb25hcHByb3h7XFxkYmxjb2xvblxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcYXBwcm94fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxDb2xvbmFwcHJveFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7XFxcXGRibGNvbG9uXFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFxhcHByb3h9fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjM3XFxcXGNoYXJcXFwiMjI0OH19XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcY29sb25zaW17XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxzaW19XG5cbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uc2ltXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcdmNlbnRjb2xvblxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcc2ltfX1cIiArIFwie1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiM2FcXFxcY2hhclxcXCIyMjNjfX1cIik7IC8vIFxccHJvdmlkZWNvbW1hbmQqXFxDb2xvbnNpbXtcXGRibGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxzaW19XG5cbmRlZmluZU1hY3JvKFwiXFxcXENvbG9uc2ltXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcZGJsY29sb25cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXHNpbX19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIyMzdcXFxcY2hhclxcXCIyMjNjfX1cIik7IC8vIFNvbWUgVW5pY29kZSBjaGFyYWN0ZXJzIGFyZSBpbXBsZW1lbnRlZCB3aXRoIG1hY3JvcyB0byBtYXRodG9vbHMgZnVuY3Rpb25zLlxuXG5kZWZpbmVNYWNybyhcIlxcdTIyMzdcIiwgXCJcXFxcZGJsY29sb25cIik7IC8vIDo6XG5cbmRlZmluZU1hY3JvKFwiXFx1MjIzOVwiLCBcIlxcXFxlcWNvbG9uXCIpOyAvLyAtOlxuXG5kZWZpbmVNYWNybyhcIlxcdTIyNTRcIiwgXCJcXFxcY29sb25lcXFcIik7IC8vIDo9XG5cbmRlZmluZU1hY3JvKFwiXFx1MjI1NVwiLCBcIlxcXFxlcXFjb2xvblwiKTsgLy8gPTpcblxuZGVmaW5lTWFjcm8oXCJcXHUyQTc0XCIsIFwiXFxcXENvbG9uZXFxXCIpOyAvLyA6Oj1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGNvbG9uZXF1YWxzLnN0eVxuLy8gQWx0ZXJuYXRlIG5hbWVzIGZvciBtYXRodG9vbHMncyBtYWNyb3M6XG5cbmRlZmluZU1hY3JvKFwiXFxcXHJhdGlvXCIsIFwiXFxcXHZjZW50Y29sb25cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmNvbG9uXCIsIFwiXFxcXGRibGNvbG9uXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25lcXVhbHNcIiwgXCJcXFxcY29sb25lcXFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmNvbG9uZXF1YWxzXCIsIFwiXFxcXENvbG9uZXFxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZXF1YWxzY29sb25cIiwgXCJcXFxcZXFxY29sb25cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxlcXVhbHNjb2xvbmNvbG9uXCIsIFwiXFxcXEVxcWNvbG9uXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25taW51c1wiLCBcIlxcXFxjb2xvbmVxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25jb2xvbm1pbnVzXCIsIFwiXFxcXENvbG9uZXFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtaW51c2NvbG9uXCIsIFwiXFxcXGVxY29sb25cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtaW51c2NvbG9uY29sb25cIiwgXCJcXFxcRXFjb2xvblwiKTsgLy8gXFxjb2xvbmFwcHJveCBuYW1lIGlzIHNhbWUgaW4gbWF0aHRvb2xzIGFuZCBjb2xvbmVxdWFscy5cblxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25jb2xvbmFwcHJveFwiLCBcIlxcXFxDb2xvbmFwcHJveFwiKTsgLy8gXFxjb2xvbnNpbSBuYW1lIGlzIHNhbWUgaW4gbWF0aHRvb2xzIGFuZCBjb2xvbmVxdWFscy5cblxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25jb2xvbnNpbVwiLCBcIlxcXFxDb2xvbnNpbVwiKTsgLy8gQWRkaXRpb25hbCBtYWNyb3MsIGltcGxlbWVudGVkIGJ5IGFuYWxvZ3kgd2l0aCBtYXRodG9vbHMgZGVmaW5pdGlvbnM6XG5cbmRlZmluZU1hY3JvKFwiXFxcXHNpbWNvbG9uXCIsIFwiXFxcXG1hdGhyZWx7XFxcXHNpbVxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcdmNlbnRjb2xvbn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzaW1jb2xvbmNvbG9uXCIsIFwiXFxcXG1hdGhyZWx7XFxcXHNpbVxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcZGJsY29sb259XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYXBwcm94Y29sb25cIiwgXCJcXFxcbWF0aHJlbHtcXFxcYXBwcm94XFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFx2Y2VudGNvbG9ufVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGFwcHJveGNvbG9uY29sb25cIiwgXCJcXFxcbWF0aHJlbHtcXFxcYXBwcm94XFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFxkYmxjb2xvbn1cIik7IC8vIFByZXNlbnQgaW4gbmV3dHhtYXRoLCBweGZvbnRzIGFuZCB0eGZvbnRzXG5cbmRlZmluZU1hY3JvKFwiXFxcXG5vdG5pXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxub3RcXFxcbml9e1xcXFxtYXRocmVse1xcXFxjaGFyYFxcdTIyMEN9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxpbXN1cFwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe2xpbVxcXFwsc3VwfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxpbWluZlwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe2xpbVxcXFwsaW5mfVwiKTsgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTWF0aE1MIGFsdGVybmF0ZXMgZm9yIEthVGVYIGdseXBocyBpbiB0aGUgVW5pY29kZSBwcml2YXRlIGFyZWFcblxuZGVmaW5lTWFjcm8oXCJcXFxcZ3ZlcnRuZXFxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAZ3ZlcnRuZXFxfXtcXHUyMjY5fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGx2ZXJ0bmVxcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQGx2ZXJ0bmVxcX17XFx1MjI2OH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxuZ2VxcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQG5nZXFxfXtcXHUyMjcxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5nZXFzbGFudFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQG5nZXFzbGFudH17XFx1MjI3MX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxubGVxcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQG5sZXFxfXtcXHUyMjcwfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5sZXFzbGFudFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQG5sZXFzbGFudH17XFx1MjI3MH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxuc2hvcnRtaWRcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBuc2hvcnRtaWR9e+KIpH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxuc2hvcnRwYXJhbGxlbFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQG5zaG9ydHBhcmFsbGVsfXviiKZ9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbnN1YnNldGVxcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQG5zdWJzZXRlcXF9e1xcdTIyODh9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbnN1cHNldGVxcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQG5zdXBzZXRlcXF9e1xcdTIyODl9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyc3Vic2V0bmVxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAdmFyc3Vic2V0bmVxfXviiop9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyc3Vic2V0bmVxcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQHZhcnN1YnNldG5lcXF9e+Kri31cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJzdXBzZXRuZXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEB2YXJzdXBzZXRuZXF9e+KKi31cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJzdXBzZXRuZXFxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAdmFyc3Vwc2V0bmVxcX174quMfVwiKTsgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gc3RtYXJ5cmQgYW5kIHNlbWFudGljXG4vLyBUaGUgc3RtYXJ5cmQgYW5kIHNlbWFudGljIHBhY2thZ2VzIHJlbmRlciB0aGUgbmV4dCBmb3VyIGl0ZW1zIGJ5IGNhbGxpbmcgYVxuLy8gZ2x5cGguIFRob3NlIGdseXBocyBkbyBub3QgZXhpc3QgaW4gdGhlIEthVGVYIGZvbnRzLiBIZW5jZSB0aGUgbWFjcm9zLlxuXG5kZWZpbmVNYWNybyhcIlxcXFxsbGJyYWNrZXRcIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRob3BlbntbXFxcXG1rZXJuLTMuMm11W319XCIgKyBcIntcXFxcbWF0aG9wZW57XFxcXGNoYXJgXFx1MjdFNn19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccnJicmFja2V0XCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aGNsb3Nle11cXFxcbWtlcm4tMy4ybXVdfX1cIiArIFwie1xcXFxtYXRoY2xvc2V7XFxcXGNoYXJgXFx1MjdFN319XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyN0U2XCIsIFwiXFxcXGxsYnJhY2tldFwiKTsgLy8gYmxhY2tib2FyZCBib2xkIFtcblxuZGVmaW5lTWFjcm8oXCJcXHUyN0U3XCIsIFwiXFxcXHJyYnJhY2tldFwiKTsgLy8gYmxhY2tib2FyZCBib2xkIF1cblxuZGVmaW5lTWFjcm8oXCJcXFxcbEJyYWNlXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aG9wZW57XFxcXHtcXFxcbWtlcm4tMy4ybXVbfX1cIiArIFwie1xcXFxtYXRob3BlbntcXFxcY2hhcmBcXHUyOTgzfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyQnJhY2VcIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRoY2xvc2V7XVxcXFxta2Vybi0zLjJtdVxcXFx9fX1cIiArIFwie1xcXFxtYXRoY2xvc2V7XFxcXGNoYXJgXFx1Mjk4NH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyOTgzXCIsIFwiXFxcXGxCcmFjZVwiKTsgLy8gYmxhY2tib2FyZCBib2xkIHtcblxuZGVmaW5lTWFjcm8oXCJcXHUyOTg0XCIsIFwiXFxcXHJCcmFjZVwiKTsgLy8gYmxhY2tib2FyZCBib2xkIH1cbi8vIFRPRE86IENyZWF0ZSB2YXJpYWJsZSBzaXplZCB2ZXJzaW9ucyBvZiB0aGUgbGFzdCB0d28gaXRlbXMuIEkgYmVsaWV2ZSB0aGF0XG4vLyB3aWxsIHJlcXVpcmUgbmV3IGZvbnQgZ2x5cGhzLlxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gdGV4dmMuc3R5XG4vLyBUaGUgdGV4dmMgcGFja2FnZSBjb250YWlucyBtYWNyb3MgYXZhaWxhYmxlIGluIG1lZGlhd2lraSBwYWdlcy5cbi8vIFdlIG9taXQgdGhlIGZ1bmN0aW9ucyBkZXByZWNhdGVkIGF0XG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZWxwOkRpc3BsYXlpbmdfYV9mb3JtdWxhI0RlcHJlY2F0ZWRfc3ludGF4XG4vLyBXZSBhbHNvIG9taXQgdGV4dmMncyBcXE8sIHdoaWNoIGNvbmZsaWN0cyB3aXRoIFxcdGV4dHtcXE99XG5cbmRlZmluZU1hY3JvKFwiXFxcXGRhcnJcIiwgXCJcXFxcZG93bmFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZEFyclwiLCBcIlxcXFxEb3duYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxEYXJyXCIsIFwiXFxcXERvd25hcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxhbmdcIiwgXCJcXFxcbGFuZ2xlXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmFuZ1wiLCBcIlxcXFxyYW5nbGVcIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1YXJyXCIsIFwiXFxcXHVwYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1QXJyXCIsIFwiXFxcXFVwYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxVYXJyXCIsIFwiXFxcXFVwYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxOXCIsIFwiXFxcXG1hdGhiYntOfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFJcIiwgXCJcXFxcbWF0aGJie1J9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcWlwiLCBcIlxcXFxtYXRoYmJ7Wn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxhbGVmXCIsIFwiXFxcXGFsZXBoXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYWxlZnN5bVwiLCBcIlxcXFxhbGVwaFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEFscGhhXCIsIFwiXFxcXG1hdGhybXtBfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEJldGFcIiwgXCJcXFxcbWF0aHJte0J9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYnVsbFwiLCBcIlxcXFxidWxsZXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxDaGlcIiwgXCJcXFxcbWF0aHJte1h9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY2x1YnNcIiwgXCJcXFxcY2x1YnN1aXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjbnVtc1wiLCBcIlxcXFxtYXRoYmJ7Q31cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxDb21wbGV4XCIsIFwiXFxcXG1hdGhiYntDfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXERhZ2dlclwiLCBcIlxcXFxkZGFnZ2VyXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZGlhbW9uZHNcIiwgXCJcXFxcZGlhbW9uZHN1aXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxlbXB0eVwiLCBcIlxcXFxlbXB0eXNldFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEVwc2lsb25cIiwgXCJcXFxcbWF0aHJte0V9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcRXRhXCIsIFwiXFxcXG1hdGhybXtIfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGV4aXN0XCIsIFwiXFxcXGV4aXN0c1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGhhcnJcIiwgXCJcXFxcbGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxoQXJyXCIsIFwiXFxcXExlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcSGFyclwiLCBcIlxcXFxMZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGhlYXJ0c1wiLCBcIlxcXFxoZWFydHN1aXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpbWFnZVwiLCBcIlxcXFxJbVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGluZmluXCIsIFwiXFxcXGluZnR5XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcSW90YVwiLCBcIlxcXFxtYXRocm17SX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpc2luXCIsIFwiXFxcXGluXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcS2FwcGFcIiwgXCJcXFxcbWF0aHJte0t9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbGFyclwiLCBcIlxcXFxsZWZ0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsQXJyXCIsIFwiXFxcXExlZnRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXExhcnJcIiwgXCJcXFxcTGVmdGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbHJhcnJcIiwgXCJcXFxcbGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsckFyclwiLCBcIlxcXFxMZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXExyYXJyXCIsIFwiXFxcXExlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcTXVcIiwgXCJcXFxcbWF0aHJte019XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbmF0bnVtc1wiLCBcIlxcXFxtYXRoYmJ7Tn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxOdVwiLCBcIlxcXFxtYXRocm17Tn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxPbWljcm9uXCIsIFwiXFxcXG1hdGhybXtPfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBsdXNtblwiLCBcIlxcXFxwbVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJhcnJcIiwgXCJcXFxccmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJBcnJcIiwgXCJcXFxcUmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFJhcnJcIiwgXCJcXFxcUmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlYWxcIiwgXCJcXFxcUmVcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyZWFsc1wiLCBcIlxcXFxtYXRoYmJ7Un1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxSZWFsc1wiLCBcIlxcXFxtYXRoYmJ7Un1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxSaG9cIiwgXCJcXFxcbWF0aHJte1B9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc2RvdFwiLCBcIlxcXFxjZG90XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc2VjdFwiLCBcIlxcXFxTXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc3BhZGVzXCIsIFwiXFxcXHNwYWRlc3VpdFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHN1YlwiLCBcIlxcXFxzdWJzZXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzdWJlXCIsIFwiXFxcXHN1YnNldGVxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc3VwZVwiLCBcIlxcXFxzdXBzZXRlcVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFRhdVwiLCBcIlxcXFxtYXRocm17VH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0aGV0YXN5bVwiLCBcIlxcXFx2YXJ0aGV0YVwiKTsgLy8gVE9ETzogZGVmaW5lTWFjcm8oXCJcXFxcdmFyY29wcGFcIiwgXCJcXFxcXFxtYm94e1xcXFxjb3BwYX1cIik7XG5cbmRlZmluZU1hY3JvKFwiXFxcXHdlaWVycFwiLCBcIlxcXFx3cFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFpldGFcIiwgXCJcXFxcbWF0aHJte1p9XCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBzdGF0bWF0aC5zdHlcbi8vIGh0dHBzOi8vY3Rhbi5tYXRoLmlsbGlub2lzLmVkdS9tYWNyb3MvbGF0ZXgvY29udHJpYi9zdGF0bWF0aC9zdGF0bWF0aC5wZGZcblxuZGVmaW5lTWFjcm8oXCJcXFxcYXJnbWluXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7YXJnXFxcXCxtaW59XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYXJnbWF4XCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7YXJnXFxcXCxtYXh9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccGxpbVwiLCBcIlxcXFxET1RTQlxcXFxtYXRob3B7XFxcXG9wZXJhdG9ybmFtZXtwbGltfX1cXFxcbGltaXRzXCIpOyAvLyBDdXN0b20gS2hhbiBBY2FkZW15IGNvbG9ycywgc2hvdWxkIGJlIG1vdmVkIHRvIGFuIG9wdGlvbmFsIHBhY2thZ2VcblxuZGVmaW5lTWFjcm8oXCJcXFxcYmx1ZVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyM2NDk1ZWR9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG9yYW5nZVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmZmE1MDB9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBpbmtcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZmYwMGFmfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyZWRcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZGYwMDMwfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmVlblwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMyOGFlN2J9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYXlcIiwgXCJcXFxcdGV4dGNvbG9ye2dyYXl9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHB1cnBsZVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyM5ZDM4YmR9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGJsdWVBXCIsIFwiXFxcXHRleHRjb2xvcnsjI2NjZmFmZn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYmx1ZUJcIiwgXCJcXFxcdGV4dGNvbG9yeyMjODBmNmZmfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxibHVlQ1wiLCBcIlxcXFx0ZXh0Y29sb3J7IyM2M2Q5ZWF9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGJsdWVEXCIsIFwiXFxcXHRleHRjb2xvcnsjIzExYWNjZH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYmx1ZUVcIiwgXCJcXFxcdGV4dGNvbG9yeyMjMGM3Zjk5fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0ZWFsQVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyM5NGZmZjV9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHRlYWxCXCIsIFwiXFxcXHRleHRjb2xvcnsjIzI2ZWRkNX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGVhbENcIiwgXCJcXFxcdGV4dGNvbG9yeyMjMDFkMWMxfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0ZWFsRFwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMwMWE5OTV9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHRlYWxFXCIsIFwiXFxcXHRleHRjb2xvcnsjIzIwODE3MH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JlZW5BXCIsIFwiXFxcXHRleHRjb2xvcnsjI2I2ZmZiMH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JlZW5CXCIsIFwiXFxcXHRleHRjb2xvcnsjIzhhZjI4MX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JlZW5DXCIsIFwiXFxcXHRleHRjb2xvcnsjIzc0Y2Y3MH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JlZW5EXCIsIFwiXFxcXHRleHRjb2xvcnsjIzFmYWI1NH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JlZW5FXCIsIFwiXFxcXHRleHRjb2xvcnsjIzBkOTIzZn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ29sZEFcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZmZkMGE5fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxnb2xkQlwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmZmJiNzF9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdvbGRDXCIsIFwiXFxcXHRleHRjb2xvcnsjI2ZmOWMzOX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ29sZERcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZTA3ZDEwfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxnb2xkRVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNhNzVhMDV9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlZEFcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZmNhOWE5fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyZWRCXCIsIFwiXFxcXHRleHRjb2xvcnsjI2ZmODQ4Mn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmVkQ1wiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmOTY4NWR9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlZERcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZTg0ZDM5fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyZWRFXCIsIFwiXFxcXHRleHRjb2xvcnsjI2JjMjYxMn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWFyb29uQVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmZmJkZTB9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1hcm9vbkJcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZmY5MmM2fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtYXJvb25DXCIsIFwiXFxcXHRleHRjb2xvcnsjI2VkNWZhNn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWFyb29uRFwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNjYTMzN2N9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1hcm9vbkVcIiwgXCJcXFxcdGV4dGNvbG9yeyMjOWUwMzRlfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwdXJwbGVBXCIsIFwiXFxcXHRleHRjb2xvcnsjI2RkZDdmZn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccHVycGxlQlwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNjNmI5ZmN9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHB1cnBsZUNcIiwgXCJcXFxcdGV4dGNvbG9yeyMjYWE4N2ZmfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwdXJwbGVEXCIsIFwiXFxcXHRleHRjb2xvcnsjIzc4NTRhYn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccHVycGxlRVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyM1NDNiNzh9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1pbnRBXCIsIFwiXFxcXHRleHRjb2xvcnsjI2Y1ZjllOH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWludEJcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZWRmMmRmfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtaW50Q1wiLCBcIlxcXFx0ZXh0Y29sb3J7IyNlMGU1Y2N9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYXlBXCIsIFwiXFxcXHRleHRjb2xvcnsjI2Y2ZjdmN317IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JheUJcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZjBmMWYyfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmF5Q1wiLCBcIlxcXFx0ZXh0Y29sb3J7IyNlM2U1ZTZ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYXlEXCIsIFwiXFxcXHRleHRjb2xvcnsjI2Q2ZDhkYX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JheUVcIiwgXCJcXFxcdGV4dGNvbG9yeyMjYmFiZWMyfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmF5RlwiLCBcIlxcXFx0ZXh0Y29sb3J7IyM4ODhkOTN9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYXlHXCIsIFwiXFxcXHRleHRjb2xvcnsjIzYyNjU2OX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JheUhcIiwgXCJcXFxcdGV4dGNvbG9yeyMjM2IzZTQwfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmF5SVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMyMTI0MmN9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGthQmx1ZVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMzMTQ0NTN9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGthR3JlZW5cIiwgXCJcXFxcdGV4dGNvbG9yeyMjNzFCMzA3fXsjMX1cIik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9NYWNyb0V4cGFuZGVyLmpzXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUg4oCcZ3VsbGV04oCdIHdoZXJlIG1hY3JvcyBhcmUgZXhwYW5kZWRcbiAqIHVudGlsIG9ubHkgbm9uLW1hY3JvIHRva2VucyByZW1haW4uXG4gKi9cblxuXG5cblxuXG5cblxuLy8gTGlzdCBvZiBjb21tYW5kcyB0aGF0IGFjdCBsaWtlIG1hY3JvcyBidXQgYXJlbid0IGRlZmluZWQgYXMgYSBtYWNybyxcbi8vIGZ1bmN0aW9uLCBvciBzeW1ib2wuICBVc2VkIGluIGBpc0RlZmluZWRgLlxudmFyIGltcGxpY2l0Q29tbWFuZHMgPSB7XG4gIFwiXFxcXHJlbGF4XCI6IHRydWUsXG4gIC8vIE1hY3JvRXhwYW5kZXIuanNcbiAgXCJeXCI6IHRydWUsXG4gIC8vIFBhcnNlci5qc1xuICBcIl9cIjogdHJ1ZSxcbiAgLy8gUGFyc2VyLmpzXG4gIFwiXFxcXGxpbWl0c1wiOiB0cnVlLFxuICAvLyBQYXJzZXIuanNcbiAgXCJcXFxcbm9saW1pdHNcIjogdHJ1ZSAvLyBQYXJzZXIuanNcblxufTtcblxudmFyIE1hY3JvRXhwYW5kZXJfTWFjcm9FeHBhbmRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hY3JvRXhwYW5kZXIoaW5wdXQsIHNldHRpbmdzLCBtb2RlKSB7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHZvaWQgMDtcbiAgICB0aGlzLmV4cGFuc2lvbkNvdW50ID0gdm9pZCAwO1xuICAgIHRoaXMubGV4ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5tYWNyb3MgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFjayA9IHZvaWQgMDtcbiAgICB0aGlzLm1vZGUgPSB2b2lkIDA7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuZXhwYW5zaW9uQ291bnQgPSAwO1xuICAgIHRoaXMuZmVlZChpbnB1dCk7IC8vIE1ha2UgbmV3IGdsb2JhbCBuYW1lc3BhY2VcblxuICAgIHRoaXMubWFjcm9zID0gbmV3IE5hbWVzcGFjZV9OYW1lc3BhY2UobWFjcm9zLCBzZXR0aW5ncy5tYWNyb3MpO1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgdGhpcy5zdGFjayA9IFtdOyAvLyBjb250YWlucyB0b2tlbnMgaW4gUkVWRVJTRSBvcmRlclxuICB9XG4gIC8qKlxuICAgKiBGZWVkIGEgbmV3IGlucHV0IHN0cmluZyB0byB0aGUgc2FtZSBNYWNyb0V4cGFuZGVyXG4gICAqICh3aXRoIGV4aXN0aW5nIG1hY3JvcyBldGMuKS5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gTWFjcm9FeHBhbmRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmZlZWQgPSBmdW5jdGlvbiBmZWVkKGlucHV0KSB7XG4gICAgdGhpcy5sZXhlciA9IG5ldyBMZXhlcl9MZXhlcihpbnB1dCwgdGhpcy5zZXR0aW5ncyk7XG4gIH1cbiAgLyoqXG4gICAqIFN3aXRjaGVzIGJldHdlZW4gXCJ0ZXh0XCIgYW5kIFwibWF0aFwiIG1vZGVzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zd2l0Y2hNb2RlID0gZnVuY3Rpb24gc3dpdGNoTW9kZShuZXdNb2RlKSB7XG4gICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgfVxuICAvKipcbiAgICogU3RhcnQgYSBuZXcgZ3JvdXAgbmVzdGluZyB3aXRoaW4gYWxsIG5hbWVzcGFjZXMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmJlZ2luR3JvdXAgPSBmdW5jdGlvbiBiZWdpbkdyb3VwKCkge1xuICAgIHRoaXMubWFjcm9zLmJlZ2luR3JvdXAoKTtcbiAgfVxuICAvKipcbiAgICogRW5kIGN1cnJlbnQgZ3JvdXAgbmVzdGluZyB3aXRoaW4gYWxsIG5hbWVzcGFjZXMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmVuZEdyb3VwID0gZnVuY3Rpb24gZW5kR3JvdXAoKSB7XG4gICAgdGhpcy5tYWNyb3MuZW5kR3JvdXAoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdG9wbW9zdCB0b2tlbiBvbiB0aGUgc3RhY2ssIHdpdGhvdXQgZXhwYW5kaW5nIGl0LlxuICAgKiBTaW1pbGFyIGluIGJlaGF2aW9yIHRvIFRlWCdzIGBcXGZ1dHVyZWxldGAuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmZ1dHVyZSA9IGZ1bmN0aW9uIGZ1dHVyZSgpIHtcbiAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMucHVzaFRva2VuKHRoaXMubGV4ZXIubGV4KCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhbmQgcmV0dXJuIHRoZSBuZXh0IHVuZXhwYW5kZWQgdG9rZW4uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBvcFRva2VuID0gZnVuY3Rpb24gcG9wVG9rZW4oKSB7XG4gICAgdGhpcy5mdXR1cmUoKTsgLy8gZW5zdXJlIG5vbi1lbXB0eSBzdGFja1xuXG4gICAgcmV0dXJuIHRoaXMuc3RhY2sucG9wKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIGdpdmVuIHRva2VuIHRvIHRoZSB0b2tlbiBzdGFjay4gIEluIHBhcnRpY3VsYXIsIHRoaXMgZ2V0IGJlIHVzZWRcbiAgICogdG8gcHV0IGJhY2sgYSB0b2tlbiByZXR1cm5lZCBmcm9tIG9uZSBvZiB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucHVzaFRva2VuID0gZnVuY3Rpb24gcHVzaFRva2VuKHRva2VuKSB7XG4gICAgdGhpcy5zdGFjay5wdXNoKHRva2VuKTtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kIGFuIGFycmF5IG9mIHRva2VucyB0byB0aGUgdG9rZW4gc3RhY2suXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnB1c2hUb2tlbnMgPSBmdW5jdGlvbiBwdXNoVG9rZW5zKHRva2Vucykge1xuICAgIHZhciBfdGhpcyRzdGFjaztcblxuICAgIChfdGhpcyRzdGFjayA9IHRoaXMuc3RhY2spLnB1c2guYXBwbHkoX3RoaXMkc3RhY2ssIHRva2Vucyk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnN1bWUgYWxsIGZvbGxvd2luZyBzcGFjZSB0b2tlbnMsIHdpdGhvdXQgZXhwYW5zaW9uLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jb25zdW1lU3BhY2VzID0gZnVuY3Rpb24gY29uc3VtZVNwYWNlcygpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgdG9rZW4gPSB0aGlzLmZ1dHVyZSgpO1xuXG4gICAgICBpZiAodG9rZW4udGV4dCA9PT0gXCIgXCIpIHtcbiAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29uc3VtZSB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBhcmd1bWVudHMgZnJvbSB0aGUgdG9rZW4gc3RyZWFtLFxuICAgKiBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgYXJyYXkgb2YgYXJndW1lbnRzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jb25zdW1lQXJncyA9IGZ1bmN0aW9uIGNvbnN1bWVBcmdzKG51bUFyZ3MpIHtcbiAgICB2YXIgYXJncyA9IFtdOyAvLyBvYnRhaW4gYXJndW1lbnRzLCBlaXRoZXIgc2luZ2xlIHRva2VuIG9yIGJhbGFuY2VkIHvigKZ9IGdyb3VwXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUFyZ3M7ICsraSkge1xuICAgICAgdGhpcy5jb25zdW1lU3BhY2VzKCk7IC8vIGlnbm9yZSBzcGFjZXMgYmVmb3JlIGVhY2ggYXJndW1lbnRcblxuICAgICAgdmFyIHN0YXJ0T2ZBcmcgPSB0aGlzLnBvcFRva2VuKCk7XG5cbiAgICAgIGlmIChzdGFydE9mQXJnLnRleHQgPT09IFwie1wiKSB7XG4gICAgICAgIHZhciBhcmcgPSBbXTtcbiAgICAgICAgdmFyIGRlcHRoID0gMTtcblxuICAgICAgICB3aGlsZSAoZGVwdGggIT09IDApIHtcbiAgICAgICAgICB2YXIgdG9rID0gdGhpcy5wb3BUb2tlbigpO1xuICAgICAgICAgIGFyZy5wdXNoKHRvayk7XG5cbiAgICAgICAgICBpZiAodG9rLnRleHQgPT09IFwie1wiKSB7XG4gICAgICAgICAgICArK2RlcHRoO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9rLnRleHQgPT09IFwifVwiKSB7XG4gICAgICAgICAgICAtLWRlcHRoO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9rLnRleHQgPT09IFwiRU9GXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkVuZCBvZiBpbnB1dCBpbiBtYWNybyBhcmd1bWVudFwiLCBzdGFydE9mQXJnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhcmcucG9wKCk7IC8vIHJlbW92ZSBsYXN0IH1cblxuICAgICAgICBhcmcucmV2ZXJzZSgpOyAvLyBsaWtlIGFib3ZlLCB0byBmaXQgaW4gd2l0aCBzdGFjayBvcmRlclxuXG4gICAgICAgIGFyZ3NbaV0gPSBhcmc7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0T2ZBcmcudGV4dCA9PT0gXCJFT0ZcIikge1xuICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJFbmQgb2YgaW5wdXQgZXhwZWN0aW5nIG1hY3JvIGFyZ3VtZW50XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJnc1tpXSA9IFtzdGFydE9mQXJnXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJncztcbiAgfVxuICAvKipcbiAgICogRXhwYW5kIHRoZSBuZXh0IHRva2VuIG9ubHkgb25jZSBpZiBwb3NzaWJsZS5cbiAgICpcbiAgICogSWYgdGhlIHRva2VuIGlzIGV4cGFuZGVkLCB0aGUgcmVzdWx0aW5nIHRva2VucyB3aWxsIGJlIHB1c2hlZCBvbnRvXG4gICAqIHRoZSBzdGFjayBpbiByZXZlcnNlIG9yZGVyIGFuZCB3aWxsIGJlIHJldHVybmVkIGFzIGFuIGFycmF5LFxuICAgKiBhbHNvIGluIHJldmVyc2Ugb3JkZXIuXG4gICAqXG4gICAqIElmIG5vdCwgdGhlIG5leHQgdG9rZW4gd2lsbCBiZSByZXR1cm5lZCB3aXRob3V0IHJlbW92aW5nIGl0XG4gICAqIGZyb20gdGhlIHN0YWNrLiAgVGhpcyBjYXNlIGNhbiBiZSBkZXRlY3RlZCBieSBhIGBUb2tlbmAgcmV0dXJuIHZhbHVlXG4gICAqIGluc3RlYWQgb2YgYW4gYEFycmF5YCByZXR1cm4gdmFsdWUuXG4gICAqXG4gICAqIEluIGVpdGhlciBjYXNlLCB0aGUgbmV4dCB0b2tlbiB3aWxsIGJlIG9uIHRoZSB0b3Agb2YgdGhlIHN0YWNrLFxuICAgKiBvciB0aGUgc3RhY2sgd2lsbCBiZSBlbXB0eS5cbiAgICpcbiAgICogVXNlZCB0byBpbXBsZW1lbnQgYGV4cGFuZEFmdGVyRnV0dXJlYCBhbmQgYGV4cGFuZE5leHRUb2tlbmAuXG4gICAqXG4gICAqIEF0IHRoZSBtb21lbnQsIG1hY3JvIGV4cGFuc2lvbiBkb2Vzbid0IGhhbmRsZSBkZWxpbWl0ZWQgbWFjcm9zLFxuICAgKiBpLmUuIHRoaW5ncyBsaWtlIHRob3NlIGRlZmluZWQgYnkgXFxkZWZcXGZvbyMxXFxlbmR74oCmfS5cbiAgICogU2VlIHRoZSBUZVggYm9vayBwYWdlIDIwMmZmLiBmb3IgZGV0YWlscyBvbiBob3cgdGhvc2Ugc2hvdWxkIGJlaGF2ZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZXhwYW5kT25jZSA9IGZ1bmN0aW9uIGV4cGFuZE9uY2UoKSB7XG4gICAgdmFyIHRvcFRva2VuID0gdGhpcy5wb3BUb2tlbigpO1xuICAgIHZhciBuYW1lID0gdG9wVG9rZW4udGV4dDtcblxuICAgIHZhciBleHBhbnNpb24gPSB0aGlzLl9nZXRFeHBhbnNpb24obmFtZSk7XG5cbiAgICBpZiAoZXhwYW5zaW9uID09IG51bGwpIHtcbiAgICAgIC8vIG1haW5seSBjaGVja2luZyBmb3IgdW5kZWZpbmVkIGhlcmVcbiAgICAgIC8vIEZ1bGx5IGV4cGFuZGVkXG4gICAgICB0aGlzLnB1c2hUb2tlbih0b3BUb2tlbik7XG4gICAgICByZXR1cm4gdG9wVG9rZW47XG4gICAgfVxuXG4gICAgdGhpcy5leHBhbnNpb25Db3VudCsrO1xuXG4gICAgaWYgKHRoaXMuZXhwYW5zaW9uQ291bnQgPiB0aGlzLnNldHRpbmdzLm1heEV4cGFuZCkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiVG9vIG1hbnkgZXhwYW5zaW9uczogaW5maW5pdGUgbG9vcCBvciBcIiArIFwibmVlZCB0byBpbmNyZWFzZSBtYXhFeHBhbmQgc2V0dGluZ1wiKTtcbiAgICB9XG5cbiAgICB2YXIgdG9rZW5zID0gZXhwYW5zaW9uLnRva2VucztcblxuICAgIGlmIChleHBhbnNpb24ubnVtQXJncykge1xuICAgICAgdmFyIGFyZ3MgPSB0aGlzLmNvbnN1bWVBcmdzKGV4cGFuc2lvbi5udW1BcmdzKTsgLy8gcGFzdGUgYXJndW1lbnRzIGluIHBsYWNlIG9mIHRoZSBwbGFjZWhvbGRlcnNcblxuICAgICAgdG9rZW5zID0gdG9rZW5zLnNsaWNlKCk7IC8vIG1ha2UgYSBzaGFsbG93IGNvcHlcblxuICAgICAgZm9yICh2YXIgaSA9IHRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgdG9rID0gdG9rZW5zW2ldO1xuXG4gICAgICAgIGlmICh0b2sudGV4dCA9PT0gXCIjXCIpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW5jb21wbGV0ZSBwbGFjZWhvbGRlciBhdCBlbmQgb2YgbWFjcm8gYm9keVwiLCB0b2spO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvayA9IHRva2Vuc1stLWldOyAvLyBuZXh0IHRva2VuIG9uIHN0YWNrXG5cbiAgICAgICAgICBpZiAodG9rLnRleHQgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICAvLyAjIyDihpIgI1xuICAgICAgICAgICAgdG9rZW5zLnNwbGljZShpICsgMSwgMSk7IC8vIGRyb3AgZmlyc3QgI1xuICAgICAgICAgIH0gZWxzZSBpZiAoL15bMS05XSQvLnRlc3QodG9rLnRleHQpKSB7XG4gICAgICAgICAgICB2YXIgX3Rva2VucztcblxuICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgcGxhY2Vob2xkZXIgd2l0aCB0aGUgaW5kaWNhdGVkIGFyZ3VtZW50XG4gICAgICAgICAgICAoX3Rva2VucyA9IHRva2Vucykuc3BsaWNlLmFwcGx5KF90b2tlbnMsIFtpLCAyXS5jb25jYXQoYXJnc1srdG9rLnRleHQgLSAxXSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJOb3QgYSB2YWxpZCBhcmd1bWVudCBudW1iZXJcIiwgdG9rKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIENvbmNhdGVuYXRlIGV4cGFuc2lvbiBvbnRvIHRvcCBvZiBzdGFjay5cblxuXG4gICAgdGhpcy5wdXNoVG9rZW5zKHRva2Vucyk7XG4gICAgcmV0dXJuIHRva2VucztcbiAgfVxuICAvKipcbiAgICogRXhwYW5kIHRoZSBuZXh0IHRva2VuIG9ubHkgb25jZSAoaWYgcG9zc2libGUpLCBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmdcbiAgICogdG9wIHRva2VuIG9uIHRoZSBzdGFjayAod2l0aG91dCByZW1vdmluZyBhbnl0aGluZyBmcm9tIHRoZSBzdGFjaykuXG4gICAqIFNpbWlsYXIgaW4gYmVoYXZpb3IgdG8gVGVYJ3MgYFxcZXhwYW5kYWZ0ZXJcXGZ1dHVyZWxldGAuXG4gICAqIEVxdWl2YWxlbnQgdG8gZXhwYW5kT25jZSgpIGZvbGxvd2VkIGJ5IGZ1dHVyZSgpLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5leHBhbmRBZnRlckZ1dHVyZSA9IGZ1bmN0aW9uIGV4cGFuZEFmdGVyRnV0dXJlKCkge1xuICAgIHRoaXMuZXhwYW5kT25jZSgpO1xuICAgIHJldHVybiB0aGlzLmZ1dHVyZSgpO1xuICB9XG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBleHBhbmQgZmlyc3QgdG9rZW4sIHRoZW4gcmV0dXJuIGZpcnN0IG5vbi1leHBhbmRhYmxlIHRva2VuLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5leHBhbmROZXh0VG9rZW4gPSBmdW5jdGlvbiBleHBhbmROZXh0VG9rZW4oKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIGV4cGFuZGVkID0gdGhpcy5leHBhbmRPbmNlKCk7IC8vIGV4cGFuZE9uY2UgcmV0dXJucyBUb2tlbiBpZiBhbmQgb25seSBpZiBpdCdzIGZ1bGx5IGV4cGFuZGVkLlxuXG4gICAgICBpZiAoZXhwYW5kZWQgaW5zdGFuY2VvZiBUb2tlbl9Ub2tlbikge1xuICAgICAgICAvLyBcXHJlbGF4IHN0b3BzIHRoZSBleHBhbnNpb24sIGJ1dCBzaG91bGRuJ3QgZ2V0IHJldHVybmVkIChhXG4gICAgICAgIC8vIG51bGwgcmV0dXJuIHZhbHVlIGNvdWxkbid0IGdldCBpbXBsZW1lbnRlZCBhcyBhIGZ1bmN0aW9uKS5cbiAgICAgICAgaWYgKGV4cGFuZGVkLnRleHQgPT09IFwiXFxcXHJlbGF4XCIpIHtcbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrLnBvcCgpOyAvLyA9PT0gZXhwYW5kZWRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gRmxvdyB1bmFibGUgdG8gZmlndXJlIG91dCB0aGF0IHRoaXMgcGF0aHdheSBpcyBpbXBvc3NpYmxlLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy80ODA4XG5cblxuICAgIHRocm93IG5ldyBFcnJvcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVucmVhY2hhYmxlXG4gIH1cbiAgLyoqXG4gICAqIEZ1bGx5IGV4cGFuZCB0aGUgZ2l2ZW4gbWFjcm8gbmFtZSBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgbGlzdCBvZlxuICAgKiB0b2tlbnMsIG9yIHJldHVybiBgdW5kZWZpbmVkYCBpZiBubyBzdWNoIG1hY3JvIGlzIGRlZmluZWQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmV4cGFuZE1hY3JvID0gZnVuY3Rpb24gZXhwYW5kTWFjcm8obmFtZSkge1xuICAgIGlmICghdGhpcy5tYWNyb3MuZ2V0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICB2YXIgb2xkU3RhY2tMZW5ndGggPSB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgICB0aGlzLnB1c2hUb2tlbihuZXcgVG9rZW5fVG9rZW4obmFtZSkpO1xuXG4gICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gb2xkU3RhY2tMZW5ndGgpIHtcbiAgICAgIHZhciBleHBhbmRlZCA9IHRoaXMuZXhwYW5kT25jZSgpOyAvLyBleHBhbmRPbmNlIHJldHVybnMgVG9rZW4gaWYgYW5kIG9ubHkgaWYgaXQncyBmdWxseSBleHBhbmRlZC5cblxuICAgICAgaWYgKGV4cGFuZGVkIGluc3RhbmNlb2YgVG9rZW5fVG9rZW4pIHtcbiAgICAgICAgb3V0cHV0LnB1c2godGhpcy5zdGFjay5wb3AoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuICAvKipcbiAgICogRnVsbHkgZXhwYW5kIHRoZSBnaXZlbiBtYWNybyBuYW1lIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBhcyBhIHN0cmluZyxcbiAgICogb3IgcmV0dXJuIGB1bmRlZmluZWRgIGlmIG5vIHN1Y2ggbWFjcm8gaXMgZGVmaW5lZC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZXhwYW5kTWFjcm9Bc1RleHQgPSBmdW5jdGlvbiBleHBhbmRNYWNyb0FzVGV4dChuYW1lKSB7XG4gICAgdmFyIHRva2VucyA9IHRoaXMuZXhwYW5kTWFjcm8obmFtZSk7XG5cbiAgICBpZiAodG9rZW5zKSB7XG4gICAgICByZXR1cm4gdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRva2VuLnRleHQ7XG4gICAgICB9KS5qb2luKFwiXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXhwYW5kZWQgbWFjcm8gYXMgYSByZXZlcnNlZCBhcnJheSBvZiB0b2tlbnMgYW5kIGEgbWFjcm9cbiAgICogYXJndW1lbnQgY291bnQuICBPciByZXR1cm5zIGBudWxsYCBpZiBubyBzdWNoIG1hY3JvLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5fZ2V0RXhwYW5zaW9uID0gZnVuY3Rpb24gX2dldEV4cGFuc2lvbihuYW1lKSB7XG4gICAgdmFyIGRlZmluaXRpb24gPSB0aGlzLm1hY3Jvcy5nZXQobmFtZSk7XG5cbiAgICBpZiAoZGVmaW5pdGlvbiA9PSBudWxsKSB7XG4gICAgICAvLyBtYWlubHkgY2hlY2tpbmcgZm9yIHVuZGVmaW5lZCBoZXJlXG4gICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgZXhwYW5zaW9uID0gdHlwZW9mIGRlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IGRlZmluaXRpb24odGhpcykgOiBkZWZpbml0aW9uO1xuXG4gICAgaWYgKHR5cGVvZiBleHBhbnNpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhciBudW1BcmdzID0gMDtcblxuICAgICAgaWYgKGV4cGFuc2lvbi5pbmRleE9mKFwiI1wiKSAhPT0gLTEpIHtcbiAgICAgICAgdmFyIHN0cmlwcGVkID0gZXhwYW5zaW9uLnJlcGxhY2UoLyMjL2csIFwiXCIpO1xuXG4gICAgICAgIHdoaWxlIChzdHJpcHBlZC5pbmRleE9mKFwiI1wiICsgKG51bUFyZ3MgKyAxKSkgIT09IC0xKSB7XG4gICAgICAgICAgKytudW1BcmdzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBib2R5TGV4ZXIgPSBuZXcgTGV4ZXJfTGV4ZXIoZXhwYW5zaW9uLCB0aGlzLnNldHRpbmdzKTtcbiAgICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICAgIHZhciB0b2sgPSBib2R5TGV4ZXIubGV4KCk7XG5cbiAgICAgIHdoaWxlICh0b2sudGV4dCAhPT0gXCJFT0ZcIikge1xuICAgICAgICB0b2tlbnMucHVzaCh0b2spO1xuICAgICAgICB0b2sgPSBib2R5TGV4ZXIubGV4KCk7XG4gICAgICB9XG5cbiAgICAgIHRva2Vucy5yZXZlcnNlKCk7IC8vIHRvIGZpdCBpbiB3aXRoIHN0YWNrIHVzaW5nIHB1c2ggYW5kIHBvcFxuXG4gICAgICB2YXIgZXhwYW5kZWQgPSB7XG4gICAgICAgIHRva2VuczogdG9rZW5zLFxuICAgICAgICBudW1BcmdzOiBudW1BcmdzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGV4cGFuZGVkO1xuICAgIH1cblxuICAgIHJldHVybiBleHBhbnNpb247XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIGEgY29tbWFuZCBpcyBjdXJyZW50bHkgXCJkZWZpbmVkXCIgKGhhcyBzb21lXG4gICAqIGZ1bmN0aW9uYWxpdHkpLCBtZWFuaW5nIHRoYXQgaXQncyBhIG1hY3JvIChpbiB0aGUgY3VycmVudCBncm91cCksXG4gICAqIGEgZnVuY3Rpb24sIGEgc3ltYm9sLCBvciBvbmUgb2YgdGhlIHNwZWNpYWwgY29tbWFuZHMgbGlzdGVkIGluXG4gICAqIGBpbXBsaWNpdENvbW1hbmRzYC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaXNEZWZpbmVkID0gZnVuY3Rpb24gaXNEZWZpbmVkKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYWNyb3MuaGFzKG5hbWUpIHx8IHNyY19mdW5jdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkgfHwgc3JjX3N5bWJvbHMubWF0aC5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCBzcmNfc3ltYm9scy50ZXh0Lmhhc093blByb3BlcnR5KG5hbWUpIHx8IGltcGxpY2l0Q29tbWFuZHMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIH07XG5cbiAgcmV0dXJuIE1hY3JvRXhwYW5kZXI7XG59KCk7XG5cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdW5pY29kZUFjY2VudHMuanNcbi8vIE1hcHBpbmcgb2YgVW5pY29kZSBhY2NlbnQgY2hhcmFjdGVycyB0byB0aGVpciBMYVRlWCBlcXVpdmFsZW50IGluIHRleHQgYW5kXG4vLyBtYXRoIG1vZGUgKHdoZW4gdGhleSBleGlzdCkuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB1bmljb2RlQWNjZW50cyA9ICh7XG4gIFwiXFx1MDMwMVwiOiB7XG4gICAgdGV4dDogXCJcXFxcJ1wiLFxuICAgIG1hdGg6ICdcXFxcYWN1dGUnXG4gIH0sXG4gIFwiXFx1MDMwMFwiOiB7XG4gICAgdGV4dDogJ1xcXFxgJyxcbiAgICBtYXRoOiAnXFxcXGdyYXZlJ1xuICB9LFxuICBcIlxcdTAzMDhcIjoge1xuICAgIHRleHQ6ICdcXFxcXCInLFxuICAgIG1hdGg6ICdcXFxcZGRvdCdcbiAgfSxcbiAgXCJcXHUwMzAzXCI6IHtcbiAgICB0ZXh0OiAnXFxcXH4nLFxuICAgIG1hdGg6ICdcXFxcdGlsZGUnXG4gIH0sXG4gIFwiXFx1MDMwNFwiOiB7XG4gICAgdGV4dDogJ1xcXFw9JyxcbiAgICBtYXRoOiAnXFxcXGJhcidcbiAgfSxcbiAgXCJcXHUwMzA2XCI6IHtcbiAgICB0ZXh0OiBcIlxcXFx1XCIsXG4gICAgbWF0aDogJ1xcXFxicmV2ZSdcbiAgfSxcbiAgXCJcXHUwMzBDXCI6IHtcbiAgICB0ZXh0OiAnXFxcXHYnLFxuICAgIG1hdGg6ICdcXFxcY2hlY2snXG4gIH0sXG4gIFwiXFx1MDMwMlwiOiB7XG4gICAgdGV4dDogJ1xcXFxeJyxcbiAgICBtYXRoOiAnXFxcXGhhdCdcbiAgfSxcbiAgXCJcXHUwMzA3XCI6IHtcbiAgICB0ZXh0OiAnXFxcXC4nLFxuICAgIG1hdGg6ICdcXFxcZG90J1xuICB9LFxuICBcIlxcdTAzMEFcIjoge1xuICAgIHRleHQ6ICdcXFxccicsXG4gICAgbWF0aDogJ1xcXFxtYXRocmluZydcbiAgfSxcbiAgXCJcXHUwMzBCXCI6IHtcbiAgICB0ZXh0OiAnXFxcXEgnXG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdW5pY29kZVN5bWJvbHMuanNcbi8vIFRoaXMgZmlsZSBpcyBHRU5FUkFURUQgYnkgdW5pY29kZU1ha2UuanMuIERPIE5PVCBNT0RJRlkuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB1bmljb2RlU3ltYm9scyA9ICh7XG4gIFwiXFx4RTFcIjogXCJhXFx1MDMwMVwiLFxuICAvLyDDoSA9IFxcJ3thfVxuICBcIlxceEUwXCI6IFwiYVxcdTAzMDBcIixcbiAgLy8gw6AgPSBcXGB7YX1cbiAgXCJcXHhFNFwiOiBcImFcXHUwMzA4XCIsXG4gIC8vIMOkID0gXFxcInthfVxuICBcIlxcdTAxREZcIjogXCJhXFx1MDMwOFxcdTAzMDRcIixcbiAgLy8gx58gPSBcXFwiXFw9e2F9XG4gIFwiXFx4RTNcIjogXCJhXFx1MDMwM1wiLFxuICAvLyDDoyA9IFxcfnthfVxuICBcIlxcdTAxMDFcIjogXCJhXFx1MDMwNFwiLFxuICAvLyDEgSA9IFxcPXthfVxuICBcIlxcdTAxMDNcIjogXCJhXFx1MDMwNlwiLFxuICAvLyDEgyA9IFxcdXthfVxuICBcIlxcdTFFQUZcIjogXCJhXFx1MDMwNlxcdTAzMDFcIixcbiAgLy8g4bqvID0gXFx1XFwne2F9XG4gIFwiXFx1MUVCMVwiOiBcImFcXHUwMzA2XFx1MDMwMFwiLFxuICAvLyDhurEgPSBcXHVcXGB7YX1cbiAgXCJcXHUxRUI1XCI6IFwiYVxcdTAzMDZcXHUwMzAzXCIsXG4gIC8vIOG6tSA9IFxcdVxcfnthfVxuICBcIlxcdTAxQ0VcIjogXCJhXFx1MDMwQ1wiLFxuICAvLyDHjiA9IFxcdnthfVxuICBcIlxceEUyXCI6IFwiYVxcdTAzMDJcIixcbiAgLy8gw6IgPSBcXF57YX1cbiAgXCJcXHUxRUE1XCI6IFwiYVxcdTAzMDJcXHUwMzAxXCIsXG4gIC8vIOG6pSA9IFxcXlxcJ3thfVxuICBcIlxcdTFFQTdcIjogXCJhXFx1MDMwMlxcdTAzMDBcIixcbiAgLy8g4bqnID0gXFxeXFxge2F9XG4gIFwiXFx1MUVBQlwiOiBcImFcXHUwMzAyXFx1MDMwM1wiLFxuICAvLyDhuqsgPSBcXF5cXH57YX1cbiAgXCJcXHUwMjI3XCI6IFwiYVxcdTAzMDdcIixcbiAgLy8gyKcgPSBcXC57YX1cbiAgXCJcXHUwMUUxXCI6IFwiYVxcdTAzMDdcXHUwMzA0XCIsXG4gIC8vIMehID0gXFwuXFw9e2F9XG4gIFwiXFx4RTVcIjogXCJhXFx1MDMwQVwiLFxuICAvLyDDpSA9IFxccnthfVxuICBcIlxcdTAxRkJcIjogXCJhXFx1MDMwQVxcdTAzMDFcIixcbiAgLy8gx7sgPSBcXHJcXCd7YX1cbiAgXCJcXHUxRTAzXCI6IFwiYlxcdTAzMDdcIixcbiAgLy8g4biDID0gXFwue2J9XG4gIFwiXFx1MDEwN1wiOiBcImNcXHUwMzAxXCIsXG4gIC8vIMSHID0gXFwne2N9XG4gIFwiXFx1MDEwRFwiOiBcImNcXHUwMzBDXCIsXG4gIC8vIMSNID0gXFx2e2N9XG4gIFwiXFx1MDEwOVwiOiBcImNcXHUwMzAyXCIsXG4gIC8vIMSJID0gXFxee2N9XG4gIFwiXFx1MDEwQlwiOiBcImNcXHUwMzA3XCIsXG4gIC8vIMSLID0gXFwue2N9XG4gIFwiXFx1MDEwRlwiOiBcImRcXHUwMzBDXCIsXG4gIC8vIMSPID0gXFx2e2R9XG4gIFwiXFx1MUUwQlwiOiBcImRcXHUwMzA3XCIsXG4gIC8vIOG4iyA9IFxcLntkfVxuICBcIlxceEU5XCI6IFwiZVxcdTAzMDFcIixcbiAgLy8gw6kgPSBcXCd7ZX1cbiAgXCJcXHhFOFwiOiBcImVcXHUwMzAwXCIsXG4gIC8vIMOoID0gXFxge2V9XG4gIFwiXFx4RUJcIjogXCJlXFx1MDMwOFwiLFxuICAvLyDDqyA9IFxcXCJ7ZX1cbiAgXCJcXHUxRUJEXCI6IFwiZVxcdTAzMDNcIixcbiAgLy8g4bq9ID0gXFx+e2V9XG4gIFwiXFx1MDExM1wiOiBcImVcXHUwMzA0XCIsXG4gIC8vIMSTID0gXFw9e2V9XG4gIFwiXFx1MUUxN1wiOiBcImVcXHUwMzA0XFx1MDMwMVwiLFxuICAvLyDhuJcgPSBcXD1cXCd7ZX1cbiAgXCJcXHUxRTE1XCI6IFwiZVxcdTAzMDRcXHUwMzAwXCIsXG4gIC8vIOG4lSA9IFxcPVxcYHtlfVxuICBcIlxcdTAxMTVcIjogXCJlXFx1MDMwNlwiLFxuICAvLyDElSA9IFxcdXtlfVxuICBcIlxcdTAxMUJcIjogXCJlXFx1MDMwQ1wiLFxuICAvLyDEmyA9IFxcdntlfVxuICBcIlxceEVBXCI6IFwiZVxcdTAzMDJcIixcbiAgLy8gw6ogPSBcXF57ZX1cbiAgXCJcXHUxRUJGXCI6IFwiZVxcdTAzMDJcXHUwMzAxXCIsXG4gIC8vIOG6vyA9IFxcXlxcJ3tlfVxuICBcIlxcdTFFQzFcIjogXCJlXFx1MDMwMlxcdTAzMDBcIixcbiAgLy8g4buBID0gXFxeXFxge2V9XG4gIFwiXFx1MUVDNVwiOiBcImVcXHUwMzAyXFx1MDMwM1wiLFxuICAvLyDhu4UgPSBcXF5cXH57ZX1cbiAgXCJcXHUwMTE3XCI6IFwiZVxcdTAzMDdcIixcbiAgLy8gxJcgPSBcXC57ZX1cbiAgXCJcXHUxRTFGXCI6IFwiZlxcdTAzMDdcIixcbiAgLy8g4bifID0gXFwue2Z9XG4gIFwiXFx1MDFGNVwiOiBcImdcXHUwMzAxXCIsXG4gIC8vIMe1ID0gXFwne2d9XG4gIFwiXFx1MUUyMVwiOiBcImdcXHUwMzA0XCIsXG4gIC8vIOG4oSA9IFxcPXtnfVxuICBcIlxcdTAxMUZcIjogXCJnXFx1MDMwNlwiLFxuICAvLyDEnyA9IFxcdXtnfVxuICBcIlxcdTAxRTdcIjogXCJnXFx1MDMwQ1wiLFxuICAvLyDHpyA9IFxcdntnfVxuICBcIlxcdTAxMURcIjogXCJnXFx1MDMwMlwiLFxuICAvLyDEnSA9IFxcXntnfVxuICBcIlxcdTAxMjFcIjogXCJnXFx1MDMwN1wiLFxuICAvLyDEoSA9IFxcLntnfVxuICBcIlxcdTFFMjdcIjogXCJoXFx1MDMwOFwiLFxuICAvLyDhuKcgPSBcXFwie2h9XG4gIFwiXFx1MDIxRlwiOiBcImhcXHUwMzBDXCIsXG4gIC8vIMifID0gXFx2e2h9XG4gIFwiXFx1MDEyNVwiOiBcImhcXHUwMzAyXCIsXG4gIC8vIMSlID0gXFxee2h9XG4gIFwiXFx1MUUyM1wiOiBcImhcXHUwMzA3XCIsXG4gIC8vIOG4oyA9IFxcLntofVxuICBcIlxceEVEXCI6IFwiaVxcdTAzMDFcIixcbiAgLy8gw60gPSBcXCd7aX1cbiAgXCJcXHhFQ1wiOiBcImlcXHUwMzAwXCIsXG4gIC8vIMOsID0gXFxge2l9XG4gIFwiXFx4RUZcIjogXCJpXFx1MDMwOFwiLFxuICAvLyDDryA9IFxcXCJ7aX1cbiAgXCJcXHUxRTJGXCI6IFwiaVxcdTAzMDhcXHUwMzAxXCIsXG4gIC8vIOG4ryA9IFxcXCJcXCd7aX1cbiAgXCJcXHUwMTI5XCI6IFwiaVxcdTAzMDNcIixcbiAgLy8gxKkgPSBcXH57aX1cbiAgXCJcXHUwMTJCXCI6IFwiaVxcdTAzMDRcIixcbiAgLy8gxKsgPSBcXD17aX1cbiAgXCJcXHUwMTJEXCI6IFwiaVxcdTAzMDZcIixcbiAgLy8gxK0gPSBcXHV7aX1cbiAgXCJcXHUwMUQwXCI6IFwiaVxcdTAzMENcIixcbiAgLy8gx5AgPSBcXHZ7aX1cbiAgXCJcXHhFRVwiOiBcImlcXHUwMzAyXCIsXG4gIC8vIMOuID0gXFxee2l9XG4gIFwiXFx1MDFGMFwiOiBcImpcXHUwMzBDXCIsXG4gIC8vIMewID0gXFx2e2p9XG4gIFwiXFx1MDEzNVwiOiBcImpcXHUwMzAyXCIsXG4gIC8vIMS1ID0gXFxee2p9XG4gIFwiXFx1MUUzMVwiOiBcImtcXHUwMzAxXCIsXG4gIC8vIOG4sSA9IFxcJ3trfVxuICBcIlxcdTAxRTlcIjogXCJrXFx1MDMwQ1wiLFxuICAvLyDHqSA9IFxcdntrfVxuICBcIlxcdTAxM0FcIjogXCJsXFx1MDMwMVwiLFxuICAvLyDEuiA9IFxcJ3tsfVxuICBcIlxcdTAxM0VcIjogXCJsXFx1MDMwQ1wiLFxuICAvLyDEviA9IFxcdntsfVxuICBcIlxcdTFFM0ZcIjogXCJtXFx1MDMwMVwiLFxuICAvLyDhuL8gPSBcXCd7bX1cbiAgXCJcXHUxRTQxXCI6IFwibVxcdTAzMDdcIixcbiAgLy8g4bmBID0gXFwue219XG4gIFwiXFx1MDE0NFwiOiBcIm5cXHUwMzAxXCIsXG4gIC8vIMWEID0gXFwne259XG4gIFwiXFx1MDFGOVwiOiBcIm5cXHUwMzAwXCIsXG4gIC8vIMe5ID0gXFxge259XG4gIFwiXFx4RjFcIjogXCJuXFx1MDMwM1wiLFxuICAvLyDDsSA9IFxcfntufVxuICBcIlxcdTAxNDhcIjogXCJuXFx1MDMwQ1wiLFxuICAvLyDFiCA9IFxcdntufVxuICBcIlxcdTFFNDVcIjogXCJuXFx1MDMwN1wiLFxuICAvLyDhuYUgPSBcXC57bn1cbiAgXCJcXHhGM1wiOiBcIm9cXHUwMzAxXCIsXG4gIC8vIMOzID0gXFwne299XG4gIFwiXFx4RjJcIjogXCJvXFx1MDMwMFwiLFxuICAvLyDDsiA9IFxcYHtvfVxuICBcIlxceEY2XCI6IFwib1xcdTAzMDhcIixcbiAgLy8gw7YgPSBcXFwie299XG4gIFwiXFx1MDIyQlwiOiBcIm9cXHUwMzA4XFx1MDMwNFwiLFxuICAvLyDIqyA9IFxcXCJcXD17b31cbiAgXCJcXHhGNVwiOiBcIm9cXHUwMzAzXCIsXG4gIC8vIMO1ID0gXFx+e299XG4gIFwiXFx1MUU0RFwiOiBcIm9cXHUwMzAzXFx1MDMwMVwiLFxuICAvLyDhuY0gPSBcXH5cXCd7b31cbiAgXCJcXHUxRTRGXCI6IFwib1xcdTAzMDNcXHUwMzA4XCIsXG4gIC8vIOG5jyA9IFxcflxcXCJ7b31cbiAgXCJcXHUwMjJEXCI6IFwib1xcdTAzMDNcXHUwMzA0XCIsXG4gIC8vIMitID0gXFx+XFw9e299XG4gIFwiXFx1MDE0RFwiOiBcIm9cXHUwMzA0XCIsXG4gIC8vIMWNID0gXFw9e299XG4gIFwiXFx1MUU1M1wiOiBcIm9cXHUwMzA0XFx1MDMwMVwiLFxuICAvLyDhuZMgPSBcXD1cXCd7b31cbiAgXCJcXHUxRTUxXCI6IFwib1xcdTAzMDRcXHUwMzAwXCIsXG4gIC8vIOG5kSA9IFxcPVxcYHtvfVxuICBcIlxcdTAxNEZcIjogXCJvXFx1MDMwNlwiLFxuICAvLyDFjyA9IFxcdXtvfVxuICBcIlxcdTAxRDJcIjogXCJvXFx1MDMwQ1wiLFxuICAvLyDHkiA9IFxcdntvfVxuICBcIlxceEY0XCI6IFwib1xcdTAzMDJcIixcbiAgLy8gw7QgPSBcXF57b31cbiAgXCJcXHUxRUQxXCI6IFwib1xcdTAzMDJcXHUwMzAxXCIsXG4gIC8vIOG7kSA9IFxcXlxcJ3tvfVxuICBcIlxcdTFFRDNcIjogXCJvXFx1MDMwMlxcdTAzMDBcIixcbiAgLy8g4buTID0gXFxeXFxge299XG4gIFwiXFx1MUVEN1wiOiBcIm9cXHUwMzAyXFx1MDMwM1wiLFxuICAvLyDhu5cgPSBcXF5cXH57b31cbiAgXCJcXHUwMjJGXCI6IFwib1xcdTAzMDdcIixcbiAgLy8gyK8gPSBcXC57b31cbiAgXCJcXHUwMjMxXCI6IFwib1xcdTAzMDdcXHUwMzA0XCIsXG4gIC8vIMixID0gXFwuXFw9e299XG4gIFwiXFx1MDE1MVwiOiBcIm9cXHUwMzBCXCIsXG4gIC8vIMWRID0gXFxIe299XG4gIFwiXFx1MUU1NVwiOiBcInBcXHUwMzAxXCIsXG4gIC8vIOG5lSA9IFxcJ3twfVxuICBcIlxcdTFFNTdcIjogXCJwXFx1MDMwN1wiLFxuICAvLyDhuZcgPSBcXC57cH1cbiAgXCJcXHUwMTU1XCI6IFwiclxcdTAzMDFcIixcbiAgLy8gxZUgPSBcXCd7cn1cbiAgXCJcXHUwMTU5XCI6IFwiclxcdTAzMENcIixcbiAgLy8gxZkgPSBcXHZ7cn1cbiAgXCJcXHUxRTU5XCI6IFwiclxcdTAzMDdcIixcbiAgLy8g4bmZID0gXFwue3J9XG4gIFwiXFx1MDE1QlwiOiBcInNcXHUwMzAxXCIsXG4gIC8vIMWbID0gXFwne3N9XG4gIFwiXFx1MUU2NVwiOiBcInNcXHUwMzAxXFx1MDMwN1wiLFxuICAvLyDhuaUgPSBcXCdcXC57c31cbiAgXCJcXHUwMTYxXCI6IFwic1xcdTAzMENcIixcbiAgLy8gxaEgPSBcXHZ7c31cbiAgXCJcXHUxRTY3XCI6IFwic1xcdTAzMENcXHUwMzA3XCIsXG4gIC8vIOG5pyA9IFxcdlxcLntzfVxuICBcIlxcdTAxNURcIjogXCJzXFx1MDMwMlwiLFxuICAvLyDFnSA9IFxcXntzfVxuICBcIlxcdTFFNjFcIjogXCJzXFx1MDMwN1wiLFxuICAvLyDhuaEgPSBcXC57c31cbiAgXCJcXHUxRTk3XCI6IFwidFxcdTAzMDhcIixcbiAgLy8g4bqXID0gXFxcInt0fVxuICBcIlxcdTAxNjVcIjogXCJ0XFx1MDMwQ1wiLFxuICAvLyDFpSA9IFxcdnt0fVxuICBcIlxcdTFFNkJcIjogXCJ0XFx1MDMwN1wiLFxuICAvLyDhuasgPSBcXC57dH1cbiAgXCJcXHhGQVwiOiBcInVcXHUwMzAxXCIsXG4gIC8vIMO6ID0gXFwne3V9XG4gIFwiXFx4RjlcIjogXCJ1XFx1MDMwMFwiLFxuICAvLyDDuSA9IFxcYHt1fVxuICBcIlxceEZDXCI6IFwidVxcdTAzMDhcIixcbiAgLy8gw7wgPSBcXFwie3V9XG4gIFwiXFx1MDFEOFwiOiBcInVcXHUwMzA4XFx1MDMwMVwiLFxuICAvLyDHmCA9IFxcXCJcXCd7dX1cbiAgXCJcXHUwMURDXCI6IFwidVxcdTAzMDhcXHUwMzAwXCIsXG4gIC8vIMecID0gXFxcIlxcYHt1fVxuICBcIlxcdTAxRDZcIjogXCJ1XFx1MDMwOFxcdTAzMDRcIixcbiAgLy8gx5YgPSBcXFwiXFw9e3V9XG4gIFwiXFx1MDFEQVwiOiBcInVcXHUwMzA4XFx1MDMwQ1wiLFxuICAvLyDHmiA9IFxcXCJcXHZ7dX1cbiAgXCJcXHUwMTY5XCI6IFwidVxcdTAzMDNcIixcbiAgLy8gxakgPSBcXH57dX1cbiAgXCJcXHUxRTc5XCI6IFwidVxcdTAzMDNcXHUwMzAxXCIsXG4gIC8vIOG5uSA9IFxcflxcJ3t1fVxuICBcIlxcdTAxNkJcIjogXCJ1XFx1MDMwNFwiLFxuICAvLyDFqyA9IFxcPXt1fVxuICBcIlxcdTFFN0JcIjogXCJ1XFx1MDMwNFxcdTAzMDhcIixcbiAgLy8g4bm7ID0gXFw9XFxcInt1fVxuICBcIlxcdTAxNkRcIjogXCJ1XFx1MDMwNlwiLFxuICAvLyDFrSA9IFxcdXt1fVxuICBcIlxcdTAxRDRcIjogXCJ1XFx1MDMwQ1wiLFxuICAvLyDHlCA9IFxcdnt1fVxuICBcIlxceEZCXCI6IFwidVxcdTAzMDJcIixcbiAgLy8gw7sgPSBcXF57dX1cbiAgXCJcXHUwMTZGXCI6IFwidVxcdTAzMEFcIixcbiAgLy8gxa8gPSBcXHJ7dX1cbiAgXCJcXHUwMTcxXCI6IFwidVxcdTAzMEJcIixcbiAgLy8gxbEgPSBcXEh7dX1cbiAgXCJcXHUxRTdEXCI6IFwidlxcdTAzMDNcIixcbiAgLy8g4bm9ID0gXFx+e3Z9XG4gIFwiXFx1MUU4M1wiOiBcIndcXHUwMzAxXCIsXG4gIC8vIOG6gyA9IFxcJ3t3fVxuICBcIlxcdTFFODFcIjogXCJ3XFx1MDMwMFwiLFxuICAvLyDhuoEgPSBcXGB7d31cbiAgXCJcXHUxRTg1XCI6IFwid1xcdTAzMDhcIixcbiAgLy8g4bqFID0gXFxcInt3fVxuICBcIlxcdTAxNzVcIjogXCJ3XFx1MDMwMlwiLFxuICAvLyDFtSA9IFxcXnt3fVxuICBcIlxcdTFFODdcIjogXCJ3XFx1MDMwN1wiLFxuICAvLyDhuocgPSBcXC57d31cbiAgXCJcXHUxRTk4XCI6IFwid1xcdTAzMEFcIixcbiAgLy8g4bqYID0gXFxye3d9XG4gIFwiXFx1MUU4RFwiOiBcInhcXHUwMzA4XCIsXG4gIC8vIOG6jSA9IFxcXCJ7eH1cbiAgXCJcXHUxRThCXCI6IFwieFxcdTAzMDdcIixcbiAgLy8g4bqLID0gXFwue3h9XG4gIFwiXFx4RkRcIjogXCJ5XFx1MDMwMVwiLFxuICAvLyDDvSA9IFxcJ3t5fVxuICBcIlxcdTFFRjNcIjogXCJ5XFx1MDMwMFwiLFxuICAvLyDhu7MgPSBcXGB7eX1cbiAgXCJcXHhGRlwiOiBcInlcXHUwMzA4XCIsXG4gIC8vIMO/ID0gXFxcInt5fVxuICBcIlxcdTFFRjlcIjogXCJ5XFx1MDMwM1wiLFxuICAvLyDhu7kgPSBcXH57eX1cbiAgXCJcXHUwMjMzXCI6IFwieVxcdTAzMDRcIixcbiAgLy8gyLMgPSBcXD17eX1cbiAgXCJcXHUwMTc3XCI6IFwieVxcdTAzMDJcIixcbiAgLy8gxbcgPSBcXF57eX1cbiAgXCJcXHUxRThGXCI6IFwieVxcdTAzMDdcIixcbiAgLy8g4bqPID0gXFwue3l9XG4gIFwiXFx1MUU5OVwiOiBcInlcXHUwMzBBXCIsXG4gIC8vIOG6mSA9IFxccnt5fVxuICBcIlxcdTAxN0FcIjogXCJ6XFx1MDMwMVwiLFxuICAvLyDFuiA9IFxcJ3t6fVxuICBcIlxcdTAxN0VcIjogXCJ6XFx1MDMwQ1wiLFxuICAvLyDFviA9IFxcdnt6fVxuICBcIlxcdTFFOTFcIjogXCJ6XFx1MDMwMlwiLFxuICAvLyDhupEgPSBcXF57en1cbiAgXCJcXHUwMTdDXCI6IFwielxcdTAzMDdcIixcbiAgLy8gxbwgPSBcXC57en1cbiAgXCJcXHhDMVwiOiBcIkFcXHUwMzAxXCIsXG4gIC8vIMOBID0gXFwne0F9XG4gIFwiXFx4QzBcIjogXCJBXFx1MDMwMFwiLFxuICAvLyDDgCA9IFxcYHtBfVxuICBcIlxceEM0XCI6IFwiQVxcdTAzMDhcIixcbiAgLy8gw4QgPSBcXFwie0F9XG4gIFwiXFx1MDFERVwiOiBcIkFcXHUwMzA4XFx1MDMwNFwiLFxuICAvLyDHniA9IFxcXCJcXD17QX1cbiAgXCJcXHhDM1wiOiBcIkFcXHUwMzAzXCIsXG4gIC8vIMODID0gXFx+e0F9XG4gIFwiXFx1MDEwMFwiOiBcIkFcXHUwMzA0XCIsXG4gIC8vIMSAID0gXFw9e0F9XG4gIFwiXFx1MDEwMlwiOiBcIkFcXHUwMzA2XCIsXG4gIC8vIMSCID0gXFx1e0F9XG4gIFwiXFx1MUVBRVwiOiBcIkFcXHUwMzA2XFx1MDMwMVwiLFxuICAvLyDhuq4gPSBcXHVcXCd7QX1cbiAgXCJcXHUxRUIwXCI6IFwiQVxcdTAzMDZcXHUwMzAwXCIsXG4gIC8vIOG6sCA9IFxcdVxcYHtBfVxuICBcIlxcdTFFQjRcIjogXCJBXFx1MDMwNlxcdTAzMDNcIixcbiAgLy8g4bq0ID0gXFx1XFx+e0F9XG4gIFwiXFx1MDFDRFwiOiBcIkFcXHUwMzBDXCIsXG4gIC8vIMeNID0gXFx2e0F9XG4gIFwiXFx4QzJcIjogXCJBXFx1MDMwMlwiLFxuICAvLyDDgiA9IFxcXntBfVxuICBcIlxcdTFFQTRcIjogXCJBXFx1MDMwMlxcdTAzMDFcIixcbiAgLy8g4bqkID0gXFxeXFwne0F9XG4gIFwiXFx1MUVBNlwiOiBcIkFcXHUwMzAyXFx1MDMwMFwiLFxuICAvLyDhuqYgPSBcXF5cXGB7QX1cbiAgXCJcXHUxRUFBXCI6IFwiQVxcdTAzMDJcXHUwMzAzXCIsXG4gIC8vIOG6qiA9IFxcXlxcfntBfVxuICBcIlxcdTAyMjZcIjogXCJBXFx1MDMwN1wiLFxuICAvLyDIpiA9IFxcLntBfVxuICBcIlxcdTAxRTBcIjogXCJBXFx1MDMwN1xcdTAzMDRcIixcbiAgLy8gx6AgPSBcXC5cXD17QX1cbiAgXCJcXHhDNVwiOiBcIkFcXHUwMzBBXCIsXG4gIC8vIMOFID0gXFxye0F9XG4gIFwiXFx1MDFGQVwiOiBcIkFcXHUwMzBBXFx1MDMwMVwiLFxuICAvLyDHuiA9IFxcclxcJ3tBfVxuICBcIlxcdTFFMDJcIjogXCJCXFx1MDMwN1wiLFxuICAvLyDhuIIgPSBcXC57Qn1cbiAgXCJcXHUwMTA2XCI6IFwiQ1xcdTAzMDFcIixcbiAgLy8gxIYgPSBcXCd7Q31cbiAgXCJcXHUwMTBDXCI6IFwiQ1xcdTAzMENcIixcbiAgLy8gxIwgPSBcXHZ7Q31cbiAgXCJcXHUwMTA4XCI6IFwiQ1xcdTAzMDJcIixcbiAgLy8gxIggPSBcXF57Q31cbiAgXCJcXHUwMTBBXCI6IFwiQ1xcdTAzMDdcIixcbiAgLy8gxIogPSBcXC57Q31cbiAgXCJcXHUwMTBFXCI6IFwiRFxcdTAzMENcIixcbiAgLy8gxI4gPSBcXHZ7RH1cbiAgXCJcXHUxRTBBXCI6IFwiRFxcdTAzMDdcIixcbiAgLy8g4biKID0gXFwue0R9XG4gIFwiXFx4QzlcIjogXCJFXFx1MDMwMVwiLFxuICAvLyDDiSA9IFxcJ3tFfVxuICBcIlxceEM4XCI6IFwiRVxcdTAzMDBcIixcbiAgLy8gw4ggPSBcXGB7RX1cbiAgXCJcXHhDQlwiOiBcIkVcXHUwMzA4XCIsXG4gIC8vIMOLID0gXFxcIntFfVxuICBcIlxcdTFFQkNcIjogXCJFXFx1MDMwM1wiLFxuICAvLyDhurwgPSBcXH57RX1cbiAgXCJcXHUwMTEyXCI6IFwiRVxcdTAzMDRcIixcbiAgLy8gxJIgPSBcXD17RX1cbiAgXCJcXHUxRTE2XCI6IFwiRVxcdTAzMDRcXHUwMzAxXCIsXG4gIC8vIOG4liA9IFxcPVxcJ3tFfVxuICBcIlxcdTFFMTRcIjogXCJFXFx1MDMwNFxcdTAzMDBcIixcbiAgLy8g4biUID0gXFw9XFxge0V9XG4gIFwiXFx1MDExNFwiOiBcIkVcXHUwMzA2XCIsXG4gIC8vIMSUID0gXFx1e0V9XG4gIFwiXFx1MDExQVwiOiBcIkVcXHUwMzBDXCIsXG4gIC8vIMSaID0gXFx2e0V9XG4gIFwiXFx4Q0FcIjogXCJFXFx1MDMwMlwiLFxuICAvLyDDiiA9IFxcXntFfVxuICBcIlxcdTFFQkVcIjogXCJFXFx1MDMwMlxcdTAzMDFcIixcbiAgLy8g4bq+ID0gXFxeXFwne0V9XG4gIFwiXFx1MUVDMFwiOiBcIkVcXHUwMzAyXFx1MDMwMFwiLFxuICAvLyDhu4AgPSBcXF5cXGB7RX1cbiAgXCJcXHUxRUM0XCI6IFwiRVxcdTAzMDJcXHUwMzAzXCIsXG4gIC8vIOG7hCA9IFxcXlxcfntFfVxuICBcIlxcdTAxMTZcIjogXCJFXFx1MDMwN1wiLFxuICAvLyDEliA9IFxcLntFfVxuICBcIlxcdTFFMUVcIjogXCJGXFx1MDMwN1wiLFxuICAvLyDhuJ4gPSBcXC57Rn1cbiAgXCJcXHUwMUY0XCI6IFwiR1xcdTAzMDFcIixcbiAgLy8gx7QgPSBcXCd7R31cbiAgXCJcXHUxRTIwXCI6IFwiR1xcdTAzMDRcIixcbiAgLy8g4bigID0gXFw9e0d9XG4gIFwiXFx1MDExRVwiOiBcIkdcXHUwMzA2XCIsXG4gIC8vIMSeID0gXFx1e0d9XG4gIFwiXFx1MDFFNlwiOiBcIkdcXHUwMzBDXCIsXG4gIC8vIMemID0gXFx2e0d9XG4gIFwiXFx1MDExQ1wiOiBcIkdcXHUwMzAyXCIsXG4gIC8vIMScID0gXFxee0d9XG4gIFwiXFx1MDEyMFwiOiBcIkdcXHUwMzA3XCIsXG4gIC8vIMSgID0gXFwue0d9XG4gIFwiXFx1MUUyNlwiOiBcIkhcXHUwMzA4XCIsXG4gIC8vIOG4piA9IFxcXCJ7SH1cbiAgXCJcXHUwMjFFXCI6IFwiSFxcdTAzMENcIixcbiAgLy8gyJ4gPSBcXHZ7SH1cbiAgXCJcXHUwMTI0XCI6IFwiSFxcdTAzMDJcIixcbiAgLy8gxKQgPSBcXF57SH1cbiAgXCJcXHUxRTIyXCI6IFwiSFxcdTAzMDdcIixcbiAgLy8g4biiID0gXFwue0h9XG4gIFwiXFx4Q0RcIjogXCJJXFx1MDMwMVwiLFxuICAvLyDDjSA9IFxcJ3tJfVxuICBcIlxceENDXCI6IFwiSVxcdTAzMDBcIixcbiAgLy8gw4wgPSBcXGB7SX1cbiAgXCJcXHhDRlwiOiBcIklcXHUwMzA4XCIsXG4gIC8vIMOPID0gXFxcIntJfVxuICBcIlxcdTFFMkVcIjogXCJJXFx1MDMwOFxcdTAzMDFcIixcbiAgLy8g4biuID0gXFxcIlxcJ3tJfVxuICBcIlxcdTAxMjhcIjogXCJJXFx1MDMwM1wiLFxuICAvLyDEqCA9IFxcfntJfVxuICBcIlxcdTAxMkFcIjogXCJJXFx1MDMwNFwiLFxuICAvLyDEqiA9IFxcPXtJfVxuICBcIlxcdTAxMkNcIjogXCJJXFx1MDMwNlwiLFxuICAvLyDErCA9IFxcdXtJfVxuICBcIlxcdTAxQ0ZcIjogXCJJXFx1MDMwQ1wiLFxuICAvLyDHjyA9IFxcdntJfVxuICBcIlxceENFXCI6IFwiSVxcdTAzMDJcIixcbiAgLy8gw44gPSBcXF57SX1cbiAgXCJcXHUwMTMwXCI6IFwiSVxcdTAzMDdcIixcbiAgLy8gxLAgPSBcXC57SX1cbiAgXCJcXHUwMTM0XCI6IFwiSlxcdTAzMDJcIixcbiAgLy8gxLQgPSBcXF57Sn1cbiAgXCJcXHUxRTMwXCI6IFwiS1xcdTAzMDFcIixcbiAgLy8g4biwID0gXFwne0t9XG4gIFwiXFx1MDFFOFwiOiBcIktcXHUwMzBDXCIsXG4gIC8vIMeoID0gXFx2e0t9XG4gIFwiXFx1MDEzOVwiOiBcIkxcXHUwMzAxXCIsXG4gIC8vIMS5ID0gXFwne0x9XG4gIFwiXFx1MDEzRFwiOiBcIkxcXHUwMzBDXCIsXG4gIC8vIMS9ID0gXFx2e0x9XG4gIFwiXFx1MUUzRVwiOiBcIk1cXHUwMzAxXCIsXG4gIC8vIOG4viA9IFxcJ3tNfVxuICBcIlxcdTFFNDBcIjogXCJNXFx1MDMwN1wiLFxuICAvLyDhuYAgPSBcXC57TX1cbiAgXCJcXHUwMTQzXCI6IFwiTlxcdTAzMDFcIixcbiAgLy8gxYMgPSBcXCd7Tn1cbiAgXCJcXHUwMUY4XCI6IFwiTlxcdTAzMDBcIixcbiAgLy8gx7ggPSBcXGB7Tn1cbiAgXCJcXHhEMVwiOiBcIk5cXHUwMzAzXCIsXG4gIC8vIMORID0gXFx+e059XG4gIFwiXFx1MDE0N1wiOiBcIk5cXHUwMzBDXCIsXG4gIC8vIMWHID0gXFx2e059XG4gIFwiXFx1MUU0NFwiOiBcIk5cXHUwMzA3XCIsXG4gIC8vIOG5hCA9IFxcLntOfVxuICBcIlxceEQzXCI6IFwiT1xcdTAzMDFcIixcbiAgLy8gw5MgPSBcXCd7T31cbiAgXCJcXHhEMlwiOiBcIk9cXHUwMzAwXCIsXG4gIC8vIMOSID0gXFxge099XG4gIFwiXFx4RDZcIjogXCJPXFx1MDMwOFwiLFxuICAvLyDDliA9IFxcXCJ7T31cbiAgXCJcXHUwMjJBXCI6IFwiT1xcdTAzMDhcXHUwMzA0XCIsXG4gIC8vIMiqID0gXFxcIlxcPXtPfVxuICBcIlxceEQ1XCI6IFwiT1xcdTAzMDNcIixcbiAgLy8gw5UgPSBcXH57T31cbiAgXCJcXHUxRTRDXCI6IFwiT1xcdTAzMDNcXHUwMzAxXCIsXG4gIC8vIOG5jCA9IFxcflxcJ3tPfVxuICBcIlxcdTFFNEVcIjogXCJPXFx1MDMwM1xcdTAzMDhcIixcbiAgLy8g4bmOID0gXFx+XFxcIntPfVxuICBcIlxcdTAyMkNcIjogXCJPXFx1MDMwM1xcdTAzMDRcIixcbiAgLy8gyKwgPSBcXH5cXD17T31cbiAgXCJcXHUwMTRDXCI6IFwiT1xcdTAzMDRcIixcbiAgLy8gxYwgPSBcXD17T31cbiAgXCJcXHUxRTUyXCI6IFwiT1xcdTAzMDRcXHUwMzAxXCIsXG4gIC8vIOG5kiA9IFxcPVxcJ3tPfVxuICBcIlxcdTFFNTBcIjogXCJPXFx1MDMwNFxcdTAzMDBcIixcbiAgLy8g4bmQID0gXFw9XFxge099XG4gIFwiXFx1MDE0RVwiOiBcIk9cXHUwMzA2XCIsXG4gIC8vIMWOID0gXFx1e099XG4gIFwiXFx1MDFEMVwiOiBcIk9cXHUwMzBDXCIsXG4gIC8vIMeRID0gXFx2e099XG4gIFwiXFx4RDRcIjogXCJPXFx1MDMwMlwiLFxuICAvLyDDlCA9IFxcXntPfVxuICBcIlxcdTFFRDBcIjogXCJPXFx1MDMwMlxcdTAzMDFcIixcbiAgLy8g4buQID0gXFxeXFwne099XG4gIFwiXFx1MUVEMlwiOiBcIk9cXHUwMzAyXFx1MDMwMFwiLFxuICAvLyDhu5IgPSBcXF5cXGB7T31cbiAgXCJcXHUxRUQ2XCI6IFwiT1xcdTAzMDJcXHUwMzAzXCIsXG4gIC8vIOG7liA9IFxcXlxcfntPfVxuICBcIlxcdTAyMkVcIjogXCJPXFx1MDMwN1wiLFxuICAvLyDIriA9IFxcLntPfVxuICBcIlxcdTAyMzBcIjogXCJPXFx1MDMwN1xcdTAzMDRcIixcbiAgLy8gyLAgPSBcXC5cXD17T31cbiAgXCJcXHUwMTUwXCI6IFwiT1xcdTAzMEJcIixcbiAgLy8gxZAgPSBcXEh7T31cbiAgXCJcXHUxRTU0XCI6IFwiUFxcdTAzMDFcIixcbiAgLy8g4bmUID0gXFwne1B9XG4gIFwiXFx1MUU1NlwiOiBcIlBcXHUwMzA3XCIsXG4gIC8vIOG5liA9IFxcLntQfVxuICBcIlxcdTAxNTRcIjogXCJSXFx1MDMwMVwiLFxuICAvLyDFlCA9IFxcJ3tSfVxuICBcIlxcdTAxNThcIjogXCJSXFx1MDMwQ1wiLFxuICAvLyDFmCA9IFxcdntSfVxuICBcIlxcdTFFNThcIjogXCJSXFx1MDMwN1wiLFxuICAvLyDhuZggPSBcXC57Un1cbiAgXCJcXHUwMTVBXCI6IFwiU1xcdTAzMDFcIixcbiAgLy8gxZogPSBcXCd7U31cbiAgXCJcXHUxRTY0XCI6IFwiU1xcdTAzMDFcXHUwMzA3XCIsXG4gIC8vIOG5pCA9IFxcJ1xcLntTfVxuICBcIlxcdTAxNjBcIjogXCJTXFx1MDMwQ1wiLFxuICAvLyDFoCA9IFxcdntTfVxuICBcIlxcdTFFNjZcIjogXCJTXFx1MDMwQ1xcdTAzMDdcIixcbiAgLy8g4bmmID0gXFx2XFwue1N9XG4gIFwiXFx1MDE1Q1wiOiBcIlNcXHUwMzAyXCIsXG4gIC8vIMWcID0gXFxee1N9XG4gIFwiXFx1MUU2MFwiOiBcIlNcXHUwMzA3XCIsXG4gIC8vIOG5oCA9IFxcLntTfVxuICBcIlxcdTAxNjRcIjogXCJUXFx1MDMwQ1wiLFxuICAvLyDFpCA9IFxcdntUfVxuICBcIlxcdTFFNkFcIjogXCJUXFx1MDMwN1wiLFxuICAvLyDhuaogPSBcXC57VH1cbiAgXCJcXHhEQVwiOiBcIlVcXHUwMzAxXCIsXG4gIC8vIMOaID0gXFwne1V9XG4gIFwiXFx4RDlcIjogXCJVXFx1MDMwMFwiLFxuICAvLyDDmSA9IFxcYHtVfVxuICBcIlxceERDXCI6IFwiVVxcdTAzMDhcIixcbiAgLy8gw5wgPSBcXFwie1V9XG4gIFwiXFx1MDFEN1wiOiBcIlVcXHUwMzA4XFx1MDMwMVwiLFxuICAvLyDHlyA9IFxcXCJcXCd7VX1cbiAgXCJcXHUwMURCXCI6IFwiVVxcdTAzMDhcXHUwMzAwXCIsXG4gIC8vIMebID0gXFxcIlxcYHtVfVxuICBcIlxcdTAxRDVcIjogXCJVXFx1MDMwOFxcdTAzMDRcIixcbiAgLy8gx5UgPSBcXFwiXFw9e1V9XG4gIFwiXFx1MDFEOVwiOiBcIlVcXHUwMzA4XFx1MDMwQ1wiLFxuICAvLyDHmSA9IFxcXCJcXHZ7VX1cbiAgXCJcXHUwMTY4XCI6IFwiVVxcdTAzMDNcIixcbiAgLy8gxaggPSBcXH57VX1cbiAgXCJcXHUxRTc4XCI6IFwiVVxcdTAzMDNcXHUwMzAxXCIsXG4gIC8vIOG5uCA9IFxcflxcJ3tVfVxuICBcIlxcdTAxNkFcIjogXCJVXFx1MDMwNFwiLFxuICAvLyDFqiA9IFxcPXtVfVxuICBcIlxcdTFFN0FcIjogXCJVXFx1MDMwNFxcdTAzMDhcIixcbiAgLy8g4bm6ID0gXFw9XFxcIntVfVxuICBcIlxcdTAxNkNcIjogXCJVXFx1MDMwNlwiLFxuICAvLyDFrCA9IFxcdXtVfVxuICBcIlxcdTAxRDNcIjogXCJVXFx1MDMwQ1wiLFxuICAvLyDHkyA9IFxcdntVfVxuICBcIlxceERCXCI6IFwiVVxcdTAzMDJcIixcbiAgLy8gw5sgPSBcXF57VX1cbiAgXCJcXHUwMTZFXCI6IFwiVVxcdTAzMEFcIixcbiAgLy8gxa4gPSBcXHJ7VX1cbiAgXCJcXHUwMTcwXCI6IFwiVVxcdTAzMEJcIixcbiAgLy8gxbAgPSBcXEh7VX1cbiAgXCJcXHUxRTdDXCI6IFwiVlxcdTAzMDNcIixcbiAgLy8g4bm8ID0gXFx+e1Z9XG4gIFwiXFx1MUU4MlwiOiBcIldcXHUwMzAxXCIsXG4gIC8vIOG6giA9IFxcJ3tXfVxuICBcIlxcdTFFODBcIjogXCJXXFx1MDMwMFwiLFxuICAvLyDhuoAgPSBcXGB7V31cbiAgXCJcXHUxRTg0XCI6IFwiV1xcdTAzMDhcIixcbiAgLy8g4bqEID0gXFxcIntXfVxuICBcIlxcdTAxNzRcIjogXCJXXFx1MDMwMlwiLFxuICAvLyDFtCA9IFxcXntXfVxuICBcIlxcdTFFODZcIjogXCJXXFx1MDMwN1wiLFxuICAvLyDhuoYgPSBcXC57V31cbiAgXCJcXHUxRThDXCI6IFwiWFxcdTAzMDhcIixcbiAgLy8g4bqMID0gXFxcIntYfVxuICBcIlxcdTFFOEFcIjogXCJYXFx1MDMwN1wiLFxuICAvLyDhuoogPSBcXC57WH1cbiAgXCJcXHhERFwiOiBcIllcXHUwMzAxXCIsXG4gIC8vIMOdID0gXFwne1l9XG4gIFwiXFx1MUVGMlwiOiBcIllcXHUwMzAwXCIsXG4gIC8vIOG7siA9IFxcYHtZfVxuICBcIlxcdTAxNzhcIjogXCJZXFx1MDMwOFwiLFxuICAvLyDFuCA9IFxcXCJ7WX1cbiAgXCJcXHUxRUY4XCI6IFwiWVxcdTAzMDNcIixcbiAgLy8g4bu4ID0gXFx+e1l9XG4gIFwiXFx1MDIzMlwiOiBcIllcXHUwMzA0XCIsXG4gIC8vIMiyID0gXFw9e1l9XG4gIFwiXFx1MDE3NlwiOiBcIllcXHUwMzAyXCIsXG4gIC8vIMW2ID0gXFxee1l9XG4gIFwiXFx1MUU4RVwiOiBcIllcXHUwMzA3XCIsXG4gIC8vIOG6jiA9IFxcLntZfVxuICBcIlxcdTAxNzlcIjogXCJaXFx1MDMwMVwiLFxuICAvLyDFuSA9IFxcJ3tafVxuICBcIlxcdTAxN0RcIjogXCJaXFx1MDMwQ1wiLFxuICAvLyDFvSA9IFxcdntafVxuICBcIlxcdTFFOTBcIjogXCJaXFx1MDMwMlwiLFxuICAvLyDhupAgPSBcXF57Wn1cbiAgXCJcXHUwMTdCXCI6IFwiWlxcdTAzMDdcIixcbiAgLy8gxbsgPSBcXC57Wn1cbiAgXCJcXHUwM0FDXCI6IFwiXFx1MDNCMVxcdTAzMDFcIixcbiAgLy8gzqwgPSBcXCd7zrF9XG4gIFwiXFx1MUY3MFwiOiBcIlxcdTAzQjFcXHUwMzAwXCIsXG4gIC8vIOG9sCA9IFxcYHvOsX1cbiAgXCJcXHUxRkIxXCI6IFwiXFx1MDNCMVxcdTAzMDRcIixcbiAgLy8g4b6xID0gXFw9e86xfVxuICBcIlxcdTFGQjBcIjogXCJcXHUwM0IxXFx1MDMwNlwiLFxuICAvLyDhvrAgPSBcXHV7zrF9XG4gIFwiXFx1MDNBRFwiOiBcIlxcdTAzQjVcXHUwMzAxXCIsXG4gIC8vIM6tID0gXFwne861fVxuICBcIlxcdTFGNzJcIjogXCJcXHUwM0I1XFx1MDMwMFwiLFxuICAvLyDhvbIgPSBcXGB7zrV9XG4gIFwiXFx1MDNBRVwiOiBcIlxcdTAzQjdcXHUwMzAxXCIsXG4gIC8vIM6uID0gXFwne863fVxuICBcIlxcdTFGNzRcIjogXCJcXHUwM0I3XFx1MDMwMFwiLFxuICAvLyDhvbQgPSBcXGB7zrd9XG4gIFwiXFx1MDNBRlwiOiBcIlxcdTAzQjlcXHUwMzAxXCIsXG4gIC8vIM6vID0gXFwne865fVxuICBcIlxcdTFGNzZcIjogXCJcXHUwM0I5XFx1MDMwMFwiLFxuICAvLyDhvbYgPSBcXGB7zrl9XG4gIFwiXFx1MDNDQVwiOiBcIlxcdTAzQjlcXHUwMzA4XCIsXG4gIC8vIM+KID0gXFxcInvOuX1cbiAgXCJcXHUwMzkwXCI6IFwiXFx1MDNCOVxcdTAzMDhcXHUwMzAxXCIsXG4gIC8vIM6QID0gXFxcIlxcJ3vOuX1cbiAgXCJcXHUxRkQyXCI6IFwiXFx1MDNCOVxcdTAzMDhcXHUwMzAwXCIsXG4gIC8vIOG/kiA9IFxcXCJcXGB7zrl9XG4gIFwiXFx1MUZEMVwiOiBcIlxcdTAzQjlcXHUwMzA0XCIsXG4gIC8vIOG/kSA9IFxcPXvOuX1cbiAgXCJcXHUxRkQwXCI6IFwiXFx1MDNCOVxcdTAzMDZcIixcbiAgLy8g4b+QID0gXFx1e865fVxuICBcIlxcdTAzQ0NcIjogXCJcXHUwM0JGXFx1MDMwMVwiLFxuICAvLyDPjCA9IFxcJ3vOv31cbiAgXCJcXHUxRjc4XCI6IFwiXFx1MDNCRlxcdTAzMDBcIixcbiAgLy8g4b24ID0gXFxge86/fVxuICBcIlxcdTAzQ0RcIjogXCJcXHUwM0M1XFx1MDMwMVwiLFxuICAvLyDPjSA9IFxcJ3vPhX1cbiAgXCJcXHUxRjdBXCI6IFwiXFx1MDNDNVxcdTAzMDBcIixcbiAgLy8g4b26ID0gXFxge8+FfVxuICBcIlxcdTAzQ0JcIjogXCJcXHUwM0M1XFx1MDMwOFwiLFxuICAvLyDPiyA9IFxcXCJ7z4V9XG4gIFwiXFx1MDNCMFwiOiBcIlxcdTAzQzVcXHUwMzA4XFx1MDMwMVwiLFxuICAvLyDOsCA9IFxcXCJcXCd7z4V9XG4gIFwiXFx1MUZFMlwiOiBcIlxcdTAzQzVcXHUwMzA4XFx1MDMwMFwiLFxuICAvLyDhv6IgPSBcXFwiXFxge8+FfVxuICBcIlxcdTFGRTFcIjogXCJcXHUwM0M1XFx1MDMwNFwiLFxuICAvLyDhv6EgPSBcXD17z4V9XG4gIFwiXFx1MUZFMFwiOiBcIlxcdTAzQzVcXHUwMzA2XCIsXG4gIC8vIOG/oCA9IFxcdXvPhX1cbiAgXCJcXHUwM0NFXCI6IFwiXFx1MDNDOVxcdTAzMDFcIixcbiAgLy8gz44gPSBcXCd7z4l9XG4gIFwiXFx1MUY3Q1wiOiBcIlxcdTAzQzlcXHUwMzAwXCIsXG4gIC8vIOG9vCA9IFxcYHvPiX1cbiAgXCJcXHUwMzhFXCI6IFwiXFx1MDNBNVxcdTAzMDFcIixcbiAgLy8gzo4gPSBcXCd7zqV9XG4gIFwiXFx1MUZFQVwiOiBcIlxcdTAzQTVcXHUwMzAwXCIsXG4gIC8vIOG/qiA9IFxcYHvOpX1cbiAgXCJcXHUwM0FCXCI6IFwiXFx1MDNBNVxcdTAzMDhcIixcbiAgLy8gzqsgPSBcXFwie86lfVxuICBcIlxcdTFGRTlcIjogXCJcXHUwM0E1XFx1MDMwNFwiLFxuICAvLyDhv6kgPSBcXD17zqV9XG4gIFwiXFx1MUZFOFwiOiBcIlxcdTAzQTVcXHUwMzA2XCIsXG4gIC8vIOG/qCA9IFxcdXvOpX1cbiAgXCJcXHUwMzhGXCI6IFwiXFx1MDNBOVxcdTAzMDFcIixcbiAgLy8gzo8gPSBcXCd7zql9XG4gIFwiXFx1MUZGQVwiOiBcIlxcdTAzQTlcXHUwMzAwXCIgLy8g4b+6ID0gXFxge86pfVxuXG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL1BhcnNlci5qc1xuLyogZXNsaW50IG5vLWNvbnN0YW50LWNvbmRpdGlvbjowICovXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIHBhcnNlciB1c2VkIHRvIHBhcnNlIG91dCBhIFRlWCBleHByZXNzaW9uIGZyb20gdGhlXG4gKiBpbnB1dC4gU2luY2UgVGVYIGlzbid0IGNvbnRleHQtZnJlZSwgc3RhbmRhcmQgcGFyc2VycyBkb24ndCB3b3JrIHBhcnRpY3VsYXJseVxuICogd2VsbC5cbiAqXG4gKiBUaGUgc3RyYXRlZ3kgb2YgdGhpcyBwYXJzZXIgaXMgYXMgc3VjaDpcbiAqXG4gKiBUaGUgbWFpbiBmdW5jdGlvbnMgKHRoZSBgLnBhcnNlLi4uYCBvbmVzKSB0YWtlIGEgcG9zaXRpb24gaW4gdGhlIGN1cnJlbnRcbiAqIHBhcnNlIHN0cmluZyB0byBwYXJzZSB0b2tlbnMgZnJvbS4gVGhlIGxleGVyIChmb3VuZCBpbiBMZXhlci5qcywgc3RvcmVkIGF0XG4gKiB0aGlzLmd1bGxldC5sZXhlcikgYWxzbyBzdXBwb3J0cyBwdWxsaW5nIG91dCB0b2tlbnMgYXQgYXJiaXRyYXJ5IHBsYWNlcy4gV2hlblxuICogaW5kaXZpZHVhbCB0b2tlbnMgYXJlIG5lZWRlZCBhdCBhIHBvc2l0aW9uLCB0aGUgbGV4ZXIgaXMgY2FsbGVkIHRvIHB1bGwgb3V0IGFcbiAqIHRva2VuLCB3aGljaCBpcyB0aGVuIHVzZWQuXG4gKlxuICogVGhlIHBhcnNlciBoYXMgYSBwcm9wZXJ0eSBjYWxsZWQgXCJtb2RlXCIgaW5kaWNhdGluZyB0aGUgbW9kZSB0aGF0XG4gKiB0aGUgcGFyc2VyIGlzIGN1cnJlbnRseSBpbi4gQ3VycmVudGx5IGl0IGhhcyB0byBiZSBvbmUgb2YgXCJtYXRoXCIgb3JcbiAqIFwidGV4dFwiLCB3aGljaCBkZW5vdGVzIHdoZXRoZXIgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgaXMgYSBtYXRoLXlcbiAqIG9uZSBvciBhIHRleHQteSBvbmUgKGUuZy4gaW5zaWRlIFxcdGV4dCkuIEN1cnJlbnRseSwgdGhpcyBzZXJ2ZXMgdG9cbiAqIGxpbWl0IHRoZSBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIHVzZWQgaW4gdGV4dCBtb2RlLlxuICpcbiAqIFRoZSBtYWluIGZ1bmN0aW9ucyB0aGVuIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIHVzZWZ1bCBkYXRhIHRoYXRcbiAqIHdhcyBwYXJzZWQgYXQgaXRzIGdpdmVuIHBvaW50LCBhbmQgYSBuZXcgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgcGFyc2VkXG4gKiBkYXRhLiBUaGUgbWFpbiBmdW5jdGlvbnMgY2FuIGNhbGwgZWFjaCBvdGhlciBhbmQgY29udGludWUgdGhlIHBhcnNpbmcgYnlcbiAqIHVzaW5nIHRoZSByZXR1cm5lZCBwb3NpdGlvbiBhcyBhIG5ldyBzdGFydGluZyBwb2ludC5cbiAqXG4gKiBUaGVyZSBhcmUgYWxzbyBleHRyYSBgLmhhbmRsZS4uLmAgZnVuY3Rpb25zLCB3aGljaCBwdWxsIG91dCBzb21lIHJldXNlZFxuICogZnVuY3Rpb25hbGl0eSBpbnRvIHNlbGYtY29udGFpbmVkIGZ1bmN0aW9ucy5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIHJldHVybiBQYXJzZU5vZGVzLlxuICovXG52YXIgUGFyc2VyX1BhcnNlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBhcnNlcihpbnB1dCwgc2V0dGluZ3MpIHtcbiAgICB0aGlzLm1vZGUgPSB2b2lkIDA7XG4gICAgdGhpcy5ndWxsZXQgPSB2b2lkIDA7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHZvaWQgMDtcbiAgICB0aGlzLmxlZnRyaWdodERlcHRoID0gdm9pZCAwO1xuICAgIHRoaXMubmV4dFRva2VuID0gdm9pZCAwO1xuICAgIC8vIFN0YXJ0IGluIG1hdGggbW9kZVxuICAgIHRoaXMubW9kZSA9IFwibWF0aFwiOyAvLyBDcmVhdGUgYSBuZXcgbWFjcm8gZXhwYW5kZXIgKGd1bGxldCkgYW5kIChpbmRpcmVjdGx5IHZpYSB0aGF0KSBhbHNvIGFcbiAgICAvLyBuZXcgbGV4ZXIgKG1vdXRoKSBmb3IgdGhpcyBwYXJzZXIgKHN0b21hY2gsIGluIHRoZSBsYW5ndWFnZSBvZiBUZVgpXG5cbiAgICB0aGlzLmd1bGxldCA9IG5ldyBNYWNyb0V4cGFuZGVyX01hY3JvRXhwYW5kZXIoaW5wdXQsIHNldHRpbmdzLCB0aGlzLm1vZGUpOyAvLyBTdG9yZSB0aGUgc2V0dGluZ3MgZm9yIHVzZSBpbiBwYXJzaW5nXG5cbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7IC8vIENvdW50IGxlZnRyaWdodCBkZXB0aCAoZm9yIFxcbWlkZGxlIGVycm9ycylcblxuICAgIHRoaXMubGVmdHJpZ2h0RGVwdGggPSAwO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgYSByZXN1bHQgdG8gbWFrZSBzdXJlIGl0IGhhcyB0aGUgcmlnaHQgdHlwZSwgYW5kIHRocm93cyBhblxuICAgKiBhcHByb3ByaWF0ZSBlcnJvciBvdGhlcndpc2UuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmV4cGVjdCA9IGZ1bmN0aW9uIGV4cGVjdCh0ZXh0LCBjb25zdW1lKSB7XG4gICAgaWYgKGNvbnN1bWUgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3VtZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmV0Y2goKS50ZXh0ICE9PSB0ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJFeHBlY3RlZCAnXCIgKyB0ZXh0ICsgXCInLCBnb3QgJ1wiICsgdGhpcy5mZXRjaCgpLnRleHQgKyBcIidcIiwgdGhpcy5mZXRjaCgpKTtcbiAgICB9XG5cbiAgICBpZiAoY29uc3VtZSkge1xuICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEaXNjYXJkcyB0aGUgY3VycmVudCBsb29rYWhlYWQgdG9rZW4sIGNvbnNpZGVyaW5nIGl0IGNvbnN1bWVkLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jb25zdW1lID0gZnVuY3Rpb24gY29uc3VtZSgpIHtcbiAgICB0aGlzLm5leHRUb2tlbiA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY3VycmVudCBsb29rYWhlYWQgdG9rZW4sIG9yIGlmIHRoZXJlIGlzbid0IG9uZSAoYXQgdGhlXG4gICAqIGJlZ2lubmluZywgb3IgaWYgdGhlIHByZXZpb3VzIGxvb2thaGVhZCB0b2tlbiB3YXMgY29uc3VtZSgpZCksXG4gICAqIGZldGNoIHRoZSBuZXh0IHRva2VuIGFzIHRoZSBuZXcgbG9va2FoZWFkIHRva2VuIGFuZCByZXR1cm4gaXQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmZldGNoID0gZnVuY3Rpb24gZmV0Y2goKSB7XG4gICAgaWYgKHRoaXMubmV4dFRva2VuID09IG51bGwpIHtcbiAgICAgIHRoaXMubmV4dFRva2VuID0gdGhpcy5ndWxsZXQuZXhwYW5kTmV4dFRva2VuKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubmV4dFRva2VuO1xuICB9XG4gIC8qKlxuICAgKiBTd2l0Y2hlcyBiZXR3ZWVuIFwidGV4dFwiIGFuZCBcIm1hdGhcIiBtb2Rlcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uc3dpdGNoTW9kZSA9IGZ1bmN0aW9uIHN3aXRjaE1vZGUobmV3TW9kZSkge1xuICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gICAgdGhpcy5ndWxsZXQuc3dpdGNoTW9kZShuZXdNb2RlKTtcbiAgfVxuICAvKipcbiAgICogTWFpbiBwYXJzaW5nIGZ1bmN0aW9uLCB3aGljaCBwYXJzZXMgYW4gZW50aXJlIGlucHV0LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKCkge1xuICAgIC8vIENyZWF0ZSBhIGdyb3VwIG5hbWVzcGFjZSBmb3IgdGhlIG1hdGggZXhwcmVzc2lvbi5cbiAgICAvLyAoTGFUZVggY3JlYXRlcyBhIG5ldyBncm91cCBmb3IgZXZlcnkgJC4uLiQsICQkLi4uJCQsIFxcWy4uLlxcXS4pXG4gICAgdGhpcy5ndWxsZXQuYmVnaW5Hcm91cCgpOyAvLyBVc2Ugb2xkIFxcY29sb3IgYmVoYXZpb3IgKHNhbWUgYXMgTGFUZVgncyBcXHRleHRjb2xvcikgaWYgcmVxdWVzdGVkLlxuICAgIC8vIFdlIGRvIHRoaXMgd2l0aGluIHRoZSBncm91cCBmb3IgdGhlIG1hdGggZXhwcmVzc2lvbiwgc28gaXQgZG9lc24ndFxuICAgIC8vIHBvbGx1dGUgc2V0dGluZ3MubWFjcm9zLlxuXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MuY29sb3JJc1RleHRDb2xvcikge1xuICAgICAgdGhpcy5ndWxsZXQubWFjcm9zLnNldChcIlxcXFxjb2xvclwiLCBcIlxcXFx0ZXh0Y29sb3JcIik7XG4gICAgfSAvLyBUcnkgdG8gcGFyc2UgdGhlIGlucHV0XG5cblxuICAgIHZhciBwYXJzZSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGZhbHNlKTsgLy8gSWYgd2Ugc3VjY2VlZGVkLCBtYWtlIHN1cmUgdGhlcmUncyBhbiBFT0YgYXQgdGhlIGVuZFxuXG4gICAgdGhpcy5leHBlY3QoXCJFT0ZcIik7IC8vIEVuZCB0aGUgZ3JvdXAgbmFtZXNwYWNlIGZvciB0aGUgZXhwcmVzc2lvblxuXG4gICAgdGhpcy5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgICByZXR1cm4gcGFyc2U7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbihicmVha09uSW5maXgsIGJyZWFrT25Ub2tlblRleHQpIHtcbiAgICB2YXIgYm9keSA9IFtdOyAvLyBLZWVwIGFkZGluZyBhdG9tcyB0byB0aGUgYm9keSB1bnRpbCB3ZSBjYW4ndCBwYXJzZSBhbnkgbW9yZSBhdG9tcyAoZWl0aGVyXG4gICAgLy8gd2UgcmVhY2hlZCB0aGUgZW5kLCBhIH0sIG9yIGEgXFxyaWdodClcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyBJZ25vcmUgc3BhY2VzIGluIG1hdGggbW9kZVxuICAgICAgaWYgKHRoaXMubW9kZSA9PT0gXCJtYXRoXCIpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lU3BhY2VzKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZXggPSB0aGlzLmZldGNoKCk7XG5cbiAgICAgIGlmIChQYXJzZXIuZW5kT2ZFeHByZXNzaW9uLmluZGV4T2YobGV4LnRleHQpICE9PSAtMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGJyZWFrT25Ub2tlblRleHQgJiYgbGV4LnRleHQgPT09IGJyZWFrT25Ub2tlblRleHQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChicmVha09uSW5maXggJiYgc3JjX2Z1bmN0aW9uc1tsZXgudGV4dF0gJiYgc3JjX2Z1bmN0aW9uc1tsZXgudGV4dF0uaW5maXgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBhdG9tID0gdGhpcy5wYXJzZUF0b20oYnJlYWtPblRva2VuVGV4dCk7XG5cbiAgICAgIGlmICghYXRvbSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYm9keS5wdXNoKGF0b20pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1vZGUgPT09IFwidGV4dFwiKSB7XG4gICAgICB0aGlzLmZvcm1MaWdhdHVyZXMoYm9keSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlSW5maXhOb2Rlcyhib2R5KTtcbiAgfVxuICAvKipcbiAgICogUmV3cml0ZXMgaW5maXggb3BlcmF0b3JzIHN1Y2ggYXMgXFxvdmVyIHdpdGggY29ycmVzcG9uZGluZyBjb21tYW5kcyBzdWNoXG4gICAqIGFzIFxcZnJhYy5cbiAgICpcbiAgICogVGhlcmUgY2FuIG9ubHkgYmUgb25lIGluZml4IG9wZXJhdG9yIHBlciBncm91cC4gIElmIHRoZXJlJ3MgbW9yZSB0aGFuIG9uZVxuICAgKiB0aGVuIHRoZSBleHByZXNzaW9uIGlzIGFtYmlndW91cy4gIFRoaXMgY2FuIGJlIHJlc29sdmVkIGJ5IGFkZGluZyB7fS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaGFuZGxlSW5maXhOb2RlcyA9IGZ1bmN0aW9uIGhhbmRsZUluZml4Tm9kZXMoYm9keSkge1xuICAgIHZhciBvdmVySW5kZXggPSAtMTtcbiAgICB2YXIgZnVuY05hbWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBub2RlID0gY2hlY2tOb2RlVHlwZShib2R5W2ldLCBcImluZml4XCIpO1xuXG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBpZiAob3ZlckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIm9ubHkgb25lIGluZml4IG9wZXJhdG9yIHBlciBncm91cFwiLCBub2RlLnRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG92ZXJJbmRleCA9IGk7XG4gICAgICAgIGZ1bmNOYW1lID0gbm9kZS5yZXBsYWNlV2l0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3ZlckluZGV4ICE9PSAtMSAmJiBmdW5jTmFtZSkge1xuICAgICAgdmFyIG51bWVyTm9kZTtcbiAgICAgIHZhciBkZW5vbU5vZGU7XG4gICAgICB2YXIgbnVtZXJCb2R5ID0gYm9keS5zbGljZSgwLCBvdmVySW5kZXgpO1xuICAgICAgdmFyIGRlbm9tQm9keSA9IGJvZHkuc2xpY2Uob3ZlckluZGV4ICsgMSk7XG5cbiAgICAgIGlmIChudW1lckJvZHkubGVuZ3RoID09PSAxICYmIG51bWVyQm9keVswXS50eXBlID09PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgICAgbnVtZXJOb2RlID0gbnVtZXJCb2R5WzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbnVtZXJOb2RlID0ge1xuICAgICAgICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgYm9keTogbnVtZXJCb2R5XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChkZW5vbUJvZHkubGVuZ3RoID09PSAxICYmIGRlbm9tQm9keVswXS50eXBlID09PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgICAgZGVub21Ob2RlID0gZGVub21Cb2R5WzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVub21Ob2RlID0ge1xuICAgICAgICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgYm9keTogZGVub21Cb2R5XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBfbm9kZTtcblxuICAgICAgaWYgKGZ1bmNOYW1lID09PSBcIlxcXFxcXFxcYWJvdmVmcmFjXCIpIHtcbiAgICAgICAgX25vZGUgPSB0aGlzLmNhbGxGdW5jdGlvbihmdW5jTmFtZSwgW251bWVyTm9kZSwgYm9keVtvdmVySW5kZXhdLCBkZW5vbU5vZGVdLCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfbm9kZSA9IHRoaXMuY2FsbEZ1bmN0aW9uKGZ1bmNOYW1lLCBbbnVtZXJOb2RlLCBkZW5vbU5vZGVdLCBbXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbX25vZGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYm9keTtcbiAgICB9XG4gIH0gLy8gVGhlIGdyZWVkaW5lc3Mgb2YgYSBzdXBlcnNjcmlwdCBvciBzdWJzY3JpcHRcbiAgO1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBzdWJzY3JpcHQgb3Igc3VwZXJzY3JpcHQgd2l0aCBuaWNlIGVycm9ycy5cbiAgICovXG4gIF9wcm90by5oYW5kbGVTdXBTdWJzY3JpcHQgPSBmdW5jdGlvbiBoYW5kbGVTdXBTdWJzY3JpcHQobmFtZSkge1xuICAgIHZhciBzeW1ib2xUb2tlbiA9IHRoaXMuZmV0Y2goKTtcbiAgICB2YXIgc3ltYm9sID0gc3ltYm9sVG9rZW4udGV4dDtcbiAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLnBhcnNlR3JvdXAobmFtZSwgZmFsc2UsIFBhcnNlci5TVVBTVUJfR1JFRURJTkVTUywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpOyAvLyBpZ25vcmUgc3BhY2VzIGJlZm9yZSBzdXAvc3Vic2NyaXB0IGFyZ3VtZW50XG5cbiAgICBpZiAoIWdyb3VwKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJFeHBlY3RlZCBncm91cCBhZnRlciAnXCIgKyBzeW1ib2wgKyBcIidcIiwgc3ltYm9sVG9rZW4pO1xuICAgIH1cblxuICAgIHJldHVybiBncm91cDtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHRleHR1YWwgaW5wdXQgb2YgYW4gdW5zdXBwb3J0ZWQgY29tbWFuZCBpbnRvIGEgdGV4dCBub2RlXG4gICAqIGNvbnRhaW5lZCB3aXRoaW4gYSBjb2xvciBub2RlIHdob3NlIGNvbG9yIGlzIGRldGVybWluZWQgYnkgZXJyb3JDb2xvclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5mb3JtYXRVbnN1cHBvcnRlZENtZCA9IGZ1bmN0aW9uIGZvcm1hdFVuc3VwcG9ydGVkQ21kKHRleHQpIHtcbiAgICB2YXIgdGV4dG9yZEFycmF5ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRleHRvcmRBcnJheS5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICB0ZXh0OiB0ZXh0W2ldXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgdGV4dE5vZGUgPSB7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIGJvZHk6IHRleHRvcmRBcnJheVxuICAgIH07XG4gICAgdmFyIGNvbG9yTm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIGNvbG9yOiB0aGlzLnNldHRpbmdzLmVycm9yQ29sb3IsXG4gICAgICBib2R5OiBbdGV4dE5vZGVdXG4gICAgfTtcbiAgICByZXR1cm4gY29sb3JOb2RlO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYSBncm91cCB3aXRoIG9wdGlvbmFsIHN1cGVyL3N1YnNjcmlwdHMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlQXRvbSA9IGZ1bmN0aW9uIHBhcnNlQXRvbShicmVha09uVG9rZW5UZXh0KSB7XG4gICAgLy8gVGhlIGJvZHkgb2YgYW4gYXRvbSBpcyBhbiBpbXBsaWNpdCBncm91cCwgc28gdGhhdCB0aGluZ3MgbGlrZVxuICAgIC8vIFxcbGVmdCh4XFxyaWdodCleMiB3b3JrIGNvcnJlY3RseS5cbiAgICB2YXIgYmFzZSA9IHRoaXMucGFyc2VHcm91cChcImF0b21cIiwgZmFsc2UsIG51bGwsIGJyZWFrT25Ub2tlblRleHQpOyAvLyBJbiB0ZXh0IG1vZGUsIHdlIGRvbid0IGhhdmUgc3VwZXJzY3JpcHRzIG9yIHN1YnNjcmlwdHNcblxuICAgIGlmICh0aGlzLm1vZGUgPT09IFwidGV4dFwiKSB7XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9IC8vIE5vdGUgdGhhdCBiYXNlIG1heSBiZSBlbXB0eSAoaS5lLiBudWxsKSBhdCB0aGlzIHBvaW50LlxuXG5cbiAgICB2YXIgc3VwZXJzY3JpcHQ7XG4gICAgdmFyIHN1YnNjcmlwdDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyBHdWFyYW50ZWVkIGluIG1hdGggbW9kZSwgc28gZWF0IGFueSBzcGFjZXMgZmlyc3QuXG4gICAgICB0aGlzLmNvbnN1bWVTcGFjZXMoKTsgLy8gTGV4IHRoZSBmaXJzdCB0b2tlblxuXG4gICAgICB2YXIgbGV4ID0gdGhpcy5mZXRjaCgpO1xuXG4gICAgICBpZiAobGV4LnRleHQgPT09IFwiXFxcXGxpbWl0c1wiIHx8IGxleC50ZXh0ID09PSBcIlxcXFxub2xpbWl0c1wiKSB7XG4gICAgICAgIC8vIFdlIGdvdCBhIGxpbWl0IGNvbnRyb2xcbiAgICAgICAgdmFyIG9wTm9kZSA9IGNoZWNrTm9kZVR5cGUoYmFzZSwgXCJvcFwiKTtcblxuICAgICAgICBpZiAob3BOb2RlKSB7XG4gICAgICAgICAgdmFyIGxpbWl0cyA9IGxleC50ZXh0ID09PSBcIlxcXFxsaW1pdHNcIjtcbiAgICAgICAgICBvcE5vZGUubGltaXRzID0gbGltaXRzO1xuICAgICAgICAgIG9wTm9kZS5hbHdheXNIYW5kbGVTdXBTdWIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wTm9kZSA9IGNoZWNrTm9kZVR5cGUoYmFzZSwgXCJvcGVyYXRvcm5hbWVcIik7XG5cbiAgICAgICAgICBpZiAob3BOb2RlICYmIG9wTm9kZS5hbHdheXNIYW5kbGVTdXBTdWIpIHtcbiAgICAgICAgICAgIHZhciBfbGltaXRzID0gbGV4LnRleHQgPT09IFwiXFxcXGxpbWl0c1wiO1xuXG4gICAgICAgICAgICBvcE5vZGUubGltaXRzID0gX2xpbWl0cztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiTGltaXQgY29udHJvbHMgbXVzdCBmb2xsb3cgYSBtYXRoIG9wZXJhdG9yXCIsIGxleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICB9IGVsc2UgaWYgKGxleC50ZXh0ID09PSBcIl5cIikge1xuICAgICAgICAvLyBXZSBnb3QgYSBzdXBlcnNjcmlwdCBzdGFydFxuICAgICAgICBpZiAoc3VwZXJzY3JpcHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJEb3VibGUgc3VwZXJzY3JpcHRcIiwgbGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyc2NyaXB0ID0gdGhpcy5oYW5kbGVTdXBTdWJzY3JpcHQoXCJzdXBlcnNjcmlwdFwiKTtcbiAgICAgIH0gZWxzZSBpZiAobGV4LnRleHQgPT09IFwiX1wiKSB7XG4gICAgICAgIC8vIFdlIGdvdCBhIHN1YnNjcmlwdCBzdGFydFxuICAgICAgICBpZiAoc3Vic2NyaXB0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiRG91YmxlIHN1YnNjcmlwdFwiLCBsZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3Vic2NyaXB0ID0gdGhpcy5oYW5kbGVTdXBTdWJzY3JpcHQoXCJzdWJzY3JpcHRcIik7XG4gICAgICB9IGVsc2UgaWYgKGxleC50ZXh0ID09PSBcIidcIikge1xuICAgICAgICAvLyBXZSBnb3QgYSBwcmltZVxuICAgICAgICBpZiAoc3VwZXJzY3JpcHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJEb3VibGUgc3VwZXJzY3JpcHRcIiwgbGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmltZSA9IHtcbiAgICAgICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgdGV4dDogXCJcXFxccHJpbWVcIlxuICAgICAgICB9OyAvLyBNYW55IHByaW1lcyBjYW4gYmUgZ3JvdXBlZCB0b2dldGhlciwgc28gd2UgaGFuZGxlIHRoaXMgaGVyZVxuXG4gICAgICAgIHZhciBwcmltZXMgPSBbcHJpbWVdO1xuICAgICAgICB0aGlzLmNvbnN1bWUoKTsgLy8gS2VlcCBsZXhpbmcgdG9rZW5zIHVudGlsIHdlIGdldCBzb21ldGhpbmcgdGhhdCdzIG5vdCBhIHByaW1lXG5cbiAgICAgICAgd2hpbGUgKHRoaXMuZmV0Y2goKS50ZXh0ID09PSBcIidcIikge1xuICAgICAgICAgIC8vIEZvciBlYWNoIG9uZSwgYWRkIGFub3RoZXIgcHJpbWUgdG8gdGhlIGxpc3RcbiAgICAgICAgICBwcmltZXMucHVzaChwcmltZSk7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIH0gLy8gSWYgdGhlcmUncyBhIHN1cGVyc2NyaXB0IGZvbGxvd2luZyB0aGUgcHJpbWVzLCBjb21iaW5lIHRoYXRcbiAgICAgICAgLy8gc3VwZXJzY3JpcHQgaW4gd2l0aCB0aGUgcHJpbWVzLlxuXG5cbiAgICAgICAgaWYgKHRoaXMuZmV0Y2goKS50ZXh0ID09PSBcIl5cIikge1xuICAgICAgICAgIHByaW1lcy5wdXNoKHRoaXMuaGFuZGxlU3VwU3Vic2NyaXB0KFwic3VwZXJzY3JpcHRcIikpO1xuICAgICAgICB9IC8vIFB1dCBldmVyeXRoaW5nIGludG8gYW4gb3JkZ3JvdXAgYXMgdGhlIHN1cGVyc2NyaXB0XG5cblxuICAgICAgICBzdXBlcnNjcmlwdCA9IHtcbiAgICAgICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgIGJvZHk6IHByaW1lc1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgaXQgd2Fzbid0IF4sIF8sIG9yICcsIHN0b3AgcGFyc2luZyBzdXBlci9zdWJzY3JpcHRzXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gLy8gQmFzZSBtdXN0IGJlIHNldCBpZiBzdXBlcnNjcmlwdCBvciBzdWJzY3JpcHQgYXJlIHNldCBwZXIgbG9naWMgYWJvdmUsXG4gICAgLy8gYnV0IG5lZWQgdG8gY2hlY2sgaGVyZSBmb3IgdHlwZSBjaGVjayB0byBwYXNzLlxuXG5cbiAgICBpZiAoc3VwZXJzY3JpcHQgfHwgc3Vic2NyaXB0KSB7XG4gICAgICAvLyBJZiB3ZSBnb3QgZWl0aGVyIGEgc3VwZXJzY3JpcHQgb3Igc3Vic2NyaXB0LCBjcmVhdGUgYSBzdXBzdWJcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3Vwc3ViXCIsXG4gICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgc3VwOiBzdXBlcnNjcmlwdCxcbiAgICAgICAgc3ViOiBzdWJzY3JpcHRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSByZXR1cm4gdGhlIG9yaWdpbmFsIGJvZHlcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGFuIGVudGlyZSBmdW5jdGlvbiwgaW5jbHVkaW5nIGl0cyBiYXNlIGFuZCBhbGwgb2YgaXRzIGFyZ3VtZW50cy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VGdW5jdGlvbiA9IGZ1bmN0aW9uIHBhcnNlRnVuY3Rpb24oYnJlYWtPblRva2VuVGV4dCwgbmFtZSwgLy8gRm9yIGVycm9yIHJlcG9ydGluZy5cbiAgZ3JlZWRpbmVzcykge1xuICAgIHZhciB0b2tlbiA9IHRoaXMuZmV0Y2goKTtcbiAgICB2YXIgZnVuYyA9IHRva2VuLnRleHQ7XG4gICAgdmFyIGZ1bmNEYXRhID0gc3JjX2Z1bmN0aW9uc1tmdW5jXTtcblxuICAgIGlmICghZnVuY0RhdGEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuY29uc3VtZSgpOyAvLyBjb25zdW1lIGNvbW1hbmQgdG9rZW5cblxuICAgIGlmIChncmVlZGluZXNzICE9IG51bGwgJiYgZnVuY0RhdGEuZ3JlZWRpbmVzcyA8PSBncmVlZGluZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJHb3QgZnVuY3Rpb24gJ1wiICsgZnVuYyArIFwiJyB3aXRoIG5vIGFyZ3VtZW50c1wiICsgKG5hbWUgPyBcIiBhcyBcIiArIG5hbWUgOiBcIlwiKSwgdG9rZW4pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSBcInRleHRcIiAmJiAhZnVuY0RhdGEuYWxsb3dlZEluVGV4dCkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiQ2FuJ3QgdXNlIGZ1bmN0aW9uICdcIiArIGZ1bmMgKyBcIicgaW4gdGV4dCBtb2RlXCIsIHRva2VuKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gXCJtYXRoXCIgJiYgZnVuY0RhdGEuYWxsb3dlZEluTWF0aCA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkNhbid0IHVzZSBmdW5jdGlvbiAnXCIgKyBmdW5jICsgXCInIGluIG1hdGggbW9kZVwiLCB0b2tlbik7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzJHBhcnNlQXJndW1lbnRzID0gdGhpcy5wYXJzZUFyZ3VtZW50cyhmdW5jLCBmdW5jRGF0YSksXG4gICAgICAgIGFyZ3MgPSBfdGhpcyRwYXJzZUFyZ3VtZW50cy5hcmdzLFxuICAgICAgICBvcHRBcmdzID0gX3RoaXMkcGFyc2VBcmd1bWVudHMub3B0QXJncztcblxuICAgIHJldHVybiB0aGlzLmNhbGxGdW5jdGlvbihmdW5jLCBhcmdzLCBvcHRBcmdzLCB0b2tlbiwgYnJlYWtPblRva2VuVGV4dCk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYSBmdW5jdGlvbiBoYW5kbGVyIHdpdGggYSBzdWl0YWJsZSBjb250ZXh0IGFuZCBhcmd1bWVudHMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmNhbGxGdW5jdGlvbiA9IGZ1bmN0aW9uIGNhbGxGdW5jdGlvbihuYW1lLCBhcmdzLCBvcHRBcmdzLCB0b2tlbiwgYnJlYWtPblRva2VuVGV4dCkge1xuICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgZnVuY05hbWU6IG5hbWUsXG4gICAgICBwYXJzZXI6IHRoaXMsXG4gICAgICB0b2tlbjogdG9rZW4sXG4gICAgICBicmVha09uVG9rZW5UZXh0OiBicmVha09uVG9rZW5UZXh0XG4gICAgfTtcbiAgICB2YXIgZnVuYyA9IHNyY19mdW5jdGlvbnNbbmFtZV07XG5cbiAgICBpZiAoZnVuYyAmJiBmdW5jLmhhbmRsZXIpIHtcbiAgICAgIHJldHVybiBmdW5jLmhhbmRsZXIoY29udGV4dCwgYXJncywgb3B0QXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIk5vIGZ1bmN0aW9uIGhhbmRsZXIgZm9yIFwiICsgbmFtZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGFyZ3VtZW50cyBvZiBhIGZ1bmN0aW9uIG9yIGVudmlyb25tZW50XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlQXJndW1lbnRzID0gZnVuY3Rpb24gcGFyc2VBcmd1bWVudHMoZnVuYywgLy8gU2hvdWxkIGxvb2sgbGlrZSBcIlxcbmFtZVwiIG9yIFwiXFxiZWdpbntuYW1lfVwiLlxuICBmdW5jRGF0YSkge1xuICAgIHZhciB0b3RhbEFyZ3MgPSBmdW5jRGF0YS5udW1BcmdzICsgZnVuY0RhdGEubnVtT3B0aW9uYWxBcmdzO1xuXG4gICAgaWYgKHRvdGFsQXJncyA9PT0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXJnczogW10sXG4gICAgICAgIG9wdEFyZ3M6IFtdXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBiYXNlR3JlZWRpbmVzcyA9IGZ1bmNEYXRhLmdyZWVkaW5lc3M7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgb3B0QXJncyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbEFyZ3M7IGkrKykge1xuICAgICAgdmFyIGFyZ1R5cGUgPSBmdW5jRGF0YS5hcmdUeXBlcyAmJiBmdW5jRGF0YS5hcmdUeXBlc1tpXTtcbiAgICAgIHZhciBpc09wdGlvbmFsID0gaSA8IGZ1bmNEYXRhLm51bU9wdGlvbmFsQXJnczsgLy8gSWdub3JlIHNwYWNlcyBiZXR3ZWVuIGFyZ3VtZW50cy4gIEFzIHRoZSBUZVhib29rIHNheXM6XG4gICAgICAvLyBcIkFmdGVyIHlvdSBoYXZlIHNhaWQg4oCYXFxkZWZcXHJvdyMxIzJ7Li4ufeKAmSwgeW91IGFyZSBhbGxvd2VkIHRvXG4gICAgICAvLyAgcHV0IHNwYWNlcyBiZXR3ZWVuIHRoZSBhcmd1bWVudHMgKGUuZy4sIOKAmFxccm93IHggbuKAmSksIGJlY2F1c2VcbiAgICAgIC8vICBUZVggZG9lc27igJl0IHVzZSBzaW5nbGUgc3BhY2VzIGFzIHVuZGVsaW1pdGVkIGFyZ3VtZW50cy5cIlxuXG4gICAgICB2YXIgY29uc3VtZVNwYWNlcyA9IGkgPiAwICYmICFpc09wdGlvbmFsIHx8IC8vIEFsc28gY29uc3VtZSBsZWFkaW5nIHNwYWNlcyBpbiBtYXRoIG1vZGUsIGFzIHBhcnNlU3ltYm9sXG4gICAgICAvLyB3b24ndCBrbm93IHdoYXQgdG8gZG8gd2l0aCB0aGVtLiAgVGhpcyBjYW4gb25seSBoYXBwZW4gd2l0aFxuICAgICAgLy8gbWFjcm9zLCBlLmcuIFxcZnJhY1xcZm9vXFxmb28gd2hlcmUgXFxmb28gZXhwYW5kcyB0byBhIHNwYWNlIHN5bWJvbC5cbiAgICAgIC8vIEluIExhVGVYLCB0aGUgXFxmb28ncyBnZXQgdHJlYXRlZCBhcyAoYmxhbmspIGFyZ3VtZW50cy5cbiAgICAgIC8vIEluIEthVGVYLCBmb3Igbm93LCBib3RoIHNwYWNlcyB3aWxsIGdldCBjb25zdW1lZC5cbiAgICAgIC8vIFRPRE8oZWRlbWFpbmUpXG4gICAgICBpID09PSAwICYmICFpc09wdGlvbmFsICYmIHRoaXMubW9kZSA9PT0gXCJtYXRoXCI7XG4gICAgICB2YXIgYXJnID0gdGhpcy5wYXJzZUdyb3VwT2ZUeXBlKFwiYXJndW1lbnQgdG8gJ1wiICsgZnVuYyArIFwiJ1wiLCBhcmdUeXBlLCBpc09wdGlvbmFsLCBiYXNlR3JlZWRpbmVzcywgY29uc3VtZVNwYWNlcyk7XG5cbiAgICAgIGlmICghYXJnKSB7XG4gICAgICAgIGlmIChpc09wdGlvbmFsKSB7XG4gICAgICAgICAgb3B0QXJncy5wdXNoKG51bGwpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiRXhwZWN0ZWQgZ3JvdXAgYWZ0ZXIgJ1wiICsgZnVuYyArIFwiJ1wiLCB0aGlzLmZldGNoKCkpO1xuICAgICAgfVxuXG4gICAgICAoaXNPcHRpb25hbCA/IG9wdEFyZ3MgOiBhcmdzKS5wdXNoKGFyZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICBvcHRBcmdzOiBvcHRBcmdzXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgZ3JvdXAgd2hlbiB0aGUgbW9kZSBpcyBjaGFuZ2luZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VHcm91cE9mVHlwZSA9IGZ1bmN0aW9uIHBhcnNlR3JvdXBPZlR5cGUobmFtZSwgdHlwZSwgb3B0aW9uYWwsIGdyZWVkaW5lc3MsIGNvbnN1bWVTcGFjZXMpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJjb2xvclwiOlxuICAgICAgICBpZiAoY29uc3VtZVNwYWNlcykge1xuICAgICAgICAgIHRoaXMuY29uc3VtZVNwYWNlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb2xvckdyb3VwKG9wdGlvbmFsKTtcblxuICAgICAgY2FzZSBcInNpemVcIjpcbiAgICAgICAgaWYgKGNvbnN1bWVTcGFjZXMpIHtcbiAgICAgICAgICB0aGlzLmNvbnN1bWVTcGFjZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlU2l6ZUdyb3VwKG9wdGlvbmFsKTtcblxuICAgICAgY2FzZSBcInVybFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVVybEdyb3VwKG9wdGlvbmFsLCBjb25zdW1lU3BhY2VzKTtcblxuICAgICAgY2FzZSBcIm1hdGhcIjpcbiAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlR3JvdXAobmFtZSwgb3B0aW9uYWwsIGdyZWVkaW5lc3MsIHVuZGVmaW5lZCwgdHlwZSwgY29uc3VtZVNwYWNlcyk7XG5cbiAgICAgIGNhc2UgXCJoYm94XCI6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBoYm94IGFyZ3VtZW50IHR5cGUgd3JhcHMgdGhlIGFyZ3VtZW50IGluIHRoZSBlcXVpdmFsZW50IG9mXG4gICAgICAgICAgLy8gXFxoYm94LCB3aGljaCBpcyBsaWtlIFxcdGV4dCBidXQgc3dpdGNoaW5nIHRvIFxcdGV4dHN0eWxlIHNpemUuXG4gICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5wYXJzZUdyb3VwKG5hbWUsIG9wdGlvbmFsLCBncmVlZGluZXNzLCB1bmRlZmluZWQsIFwidGV4dFwiLCBjb25zdW1lU3BhY2VzKTtcblxuICAgICAgICAgIGlmICghZ3JvdXApIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3R5bGVkR3JvdXAgPSB7XG4gICAgICAgICAgICB0eXBlOiBcInN0eWxpbmdcIixcbiAgICAgICAgICAgIG1vZGU6IGdyb3VwLm1vZGUsXG4gICAgICAgICAgICBib2R5OiBbZ3JvdXBdLFxuICAgICAgICAgICAgc3R5bGU6IFwidGV4dFwiIC8vIHNpbXVsYXRlIFxcdGV4dHN0eWxlXG5cbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBzdHlsZWRHcm91cDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwicmF3XCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoY29uc3VtZVNwYWNlcykge1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lU3BhY2VzKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbmFsICYmIHRoaXMuZmV0Y2goKS50ZXh0ID09PSBcIntcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5wYXJzZVN0cmluZ0dyb3VwKFwicmF3XCIsIG9wdGlvbmFsLCB0cnVlKTtcblxuICAgICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJyYXdcIixcbiAgICAgICAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgIHN0cmluZzogdG9rZW4udGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiRXhwZWN0ZWQgcmF3IGdyb3VwXCIsIHRoaXMuZmV0Y2goKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJvcmlnaW5hbFwiOlxuICAgICAgY2FzZSBudWxsOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlR3JvdXAobmFtZSwgb3B0aW9uYWwsIGdyZWVkaW5lc3MsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25zdW1lU3BhY2VzKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiVW5rbm93biBncm91cCB0eXBlIGFzIFwiICsgbmFtZSwgdGhpcy5mZXRjaCgpKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERpc2NhcmQgYW55IHNwYWNlIHRva2VucywgZmV0Y2hpbmcgdGhlIG5leHQgbm9uLXNwYWNlIHRva2VuLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jb25zdW1lU3BhY2VzID0gZnVuY3Rpb24gY29uc3VtZVNwYWNlcygpIHtcbiAgICB3aGlsZSAodGhpcy5mZXRjaCgpLnRleHQgPT09IFwiIFwiKSB7XG4gICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIGdyb3VwLCBlc3NlbnRpYWxseSByZXR1cm5pbmcgdGhlIHN0cmluZyBmb3JtZWQgYnkgdGhlXG4gICAqIGJyYWNlLWVuY2xvc2VkIHRva2VucyBwbHVzIHNvbWUgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlU3RyaW5nR3JvdXAgPSBmdW5jdGlvbiBwYXJzZVN0cmluZ0dyb3VwKG1vZGVOYW1lLCAvLyBVc2VkIHRvIGRlc2NyaWJlIHRoZSBtb2RlIGluIGVycm9yIG1lc3NhZ2VzLlxuICBvcHRpb25hbCwgcmF3KSB7XG4gICAgdmFyIGdyb3VwQmVnaW4gPSBvcHRpb25hbCA/IFwiW1wiIDogXCJ7XCI7XG4gICAgdmFyIGdyb3VwRW5kID0gb3B0aW9uYWwgPyBcIl1cIiA6IFwifVwiO1xuICAgIHZhciBiZWdpblRva2VuID0gdGhpcy5mZXRjaCgpO1xuXG4gICAgaWYgKGJlZ2luVG9rZW4udGV4dCAhPT0gZ3JvdXBCZWdpbikge1xuICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIGlmIChyYXcgJiYgYmVnaW5Ub2tlbi50ZXh0ICE9PSBcIkVPRlwiICYmIC9bXnt9W1xcXV0vLnRlc3QoYmVnaW5Ub2tlbi50ZXh0KSkge1xuICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgcmV0dXJuIGJlZ2luVG9rZW47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG91dGVyTW9kZSA9IHRoaXMubW9kZTtcbiAgICB0aGlzLm1vZGUgPSBcInRleHRcIjtcbiAgICB0aGlzLmV4cGVjdChncm91cEJlZ2luKTtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB2YXIgZmlyc3RUb2tlbiA9IHRoaXMuZmV0Y2goKTtcbiAgICB2YXIgbmVzdGVkID0gMDsgLy8gYWxsb3cgbmVzdGVkIGJyYWNlcyBpbiByYXcgc3RyaW5nIGdyb3VwXG5cbiAgICB2YXIgbGFzdFRva2VuID0gZmlyc3RUb2tlbjtcbiAgICB2YXIgbmV4dFRva2VuO1xuXG4gICAgd2hpbGUgKChuZXh0VG9rZW4gPSB0aGlzLmZldGNoKCkpLnRleHQgIT09IGdyb3VwRW5kIHx8IHJhdyAmJiBuZXN0ZWQgPiAwKSB7XG4gICAgICBzd2l0Y2ggKG5leHRUb2tlbi50ZXh0KSB7XG4gICAgICAgIGNhc2UgXCJFT0ZcIjpcbiAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCBpbiBcIiArIG1vZGVOYW1lLCBmaXJzdFRva2VuLnJhbmdlKGxhc3RUb2tlbiwgc3RyKSk7XG5cbiAgICAgICAgY2FzZSBncm91cEJlZ2luOlxuICAgICAgICAgIG5lc3RlZCsrO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgZ3JvdXBFbmQ6XG4gICAgICAgICAgbmVzdGVkLS07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGxhc3RUb2tlbiA9IG5leHRUb2tlbjtcbiAgICAgIHN0ciArPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cblxuICAgIHRoaXMuZXhwZWN0KGdyb3VwRW5kKTtcbiAgICB0aGlzLm1vZGUgPSBvdXRlck1vZGU7XG4gICAgcmV0dXJuIGZpcnN0VG9rZW4ucmFuZ2UobGFzdFRva2VuLCBzdHIpO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYSByZWdleC1kZWxpbWl0ZWQgZ3JvdXA6IHRoZSBsYXJnZXN0IHNlcXVlbmNlIG9mIHRva2Vuc1xuICAgKiB3aG9zZSBjb25jYXRlbmF0ZWQgc3RyaW5ncyBtYXRjaCBgcmVnZXhgLiBSZXR1cm5zIHRoZSBzdHJpbmdcbiAgICogZm9ybWVkIGJ5IHRoZSB0b2tlbnMgcGx1cyBzb21lIHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZVJlZ2V4R3JvdXAgPSBmdW5jdGlvbiBwYXJzZVJlZ2V4R3JvdXAocmVnZXgsIG1vZGVOYW1lKSB7XG4gICAgdmFyIG91dGVyTW9kZSA9IHRoaXMubW9kZTtcbiAgICB0aGlzLm1vZGUgPSBcInRleHRcIjtcbiAgICB2YXIgZmlyc3RUb2tlbiA9IHRoaXMuZmV0Y2goKTtcbiAgICB2YXIgbGFzdFRva2VuID0gZmlyc3RUb2tlbjtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB2YXIgbmV4dFRva2VuO1xuXG4gICAgd2hpbGUgKChuZXh0VG9rZW4gPSB0aGlzLmZldGNoKCkpLnRleHQgIT09IFwiRU9GXCIgJiYgcmVnZXgudGVzdChzdHIgKyBuZXh0VG9rZW4udGV4dCkpIHtcbiAgICAgIGxhc3RUb2tlbiA9IG5leHRUb2tlbjtcbiAgICAgIHN0ciArPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cblxuICAgIGlmIChzdHIgPT09IFwiXCIpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgXCIgKyBtb2RlTmFtZSArIFwiOiAnXCIgKyBmaXJzdFRva2VuLnRleHQgKyBcIidcIiwgZmlyc3RUb2tlbik7XG4gICAgfVxuXG4gICAgdGhpcy5tb2RlID0gb3V0ZXJNb2RlO1xuICAgIHJldHVybiBmaXJzdFRva2VuLnJhbmdlKGxhc3RUb2tlbiwgc3RyKTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgY29sb3IgZGVzY3JpcHRpb24uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlQ29sb3JHcm91cCA9IGZ1bmN0aW9uIHBhcnNlQ29sb3JHcm91cChvcHRpb25hbCkge1xuICAgIHZhciByZXMgPSB0aGlzLnBhcnNlU3RyaW5nR3JvdXAoXCJjb2xvclwiLCBvcHRpb25hbCk7XG5cbiAgICBpZiAoIXJlcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoID0gL14oI1thLWYwLTldezN9fCM/W2EtZjAtOV17Nn18W2Etel0rKSQvaS5leGVjKHJlcy50ZXh0KTtcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgY29sb3I6ICdcIiArIHJlcy50ZXh0ICsgXCInXCIsIHJlcyk7XG4gICAgfVxuXG4gICAgdmFyIGNvbG9yID0gbWF0Y2hbMF07XG5cbiAgICBpZiAoL15bMC05YS1mXXs2fSQvaS50ZXN0KGNvbG9yKSkge1xuICAgICAgLy8gV2UgYWxsb3cgYSA2LWRpZ2l0IEhUTUwgY29sb3Igc3BlYyB3aXRob3V0IGEgbGVhZGluZyBcIiNcIi5cbiAgICAgIC8vIFRoaXMgZm9sbG93cyB0aGUgeGNvbG9yIHBhY2thZ2UncyBIVE1MIGNvbG9yIG1vZGVsLlxuICAgICAgLy8gUHJlZGVmaW5lZCBjb2xvciBuYW1lcyBhcmUgYWxsIG1pc3NlZCBieSB0aGlzIFJlZ0V4IHBhdHRlcm4uXG4gICAgICBjb2xvciA9IFwiI1wiICsgY29sb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY29sb3ItdG9rZW5cIixcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIGNvbG9yOiBjb2xvclxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHNpemUgc3BlY2lmaWNhdGlvbiwgY29uc2lzdGluZyBvZiBtYWduaXR1ZGUgYW5kIHVuaXQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlU2l6ZUdyb3VwID0gZnVuY3Rpb24gcGFyc2VTaXplR3JvdXAob3B0aW9uYWwpIHtcbiAgICB2YXIgcmVzO1xuICAgIHZhciBpc0JsYW5rID0gZmFsc2U7XG5cbiAgICBpZiAoIW9wdGlvbmFsICYmIHRoaXMuZmV0Y2goKS50ZXh0ICE9PSBcIntcIikge1xuICAgICAgcmVzID0gdGhpcy5wYXJzZVJlZ2V4R3JvdXAoL15bLStdPyAqKD86JHxcXGQrfFxcZCtcXC5cXGQqfFxcLlxcZCopICpbYS16XXswLDJ9ICokLywgXCJzaXplXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB0aGlzLnBhcnNlU3RyaW5nR3JvdXAoXCJzaXplXCIsIG9wdGlvbmFsKTtcbiAgICB9XG5cbiAgICBpZiAoIXJlcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25hbCAmJiByZXMudGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIEJlY2F1c2Ugd2UndmUgdGVzdGVkIGZvciB3aGF0IGlzICFvcHRpb25hbCwgdGhpcyBibG9jayB3b24ndFxuICAgICAgLy8gYWZmZWN0IFxca2VybiwgXFxoc3BhY2UsIGV0Yy4gSXQgd2lsbCBjYXB0dXJlIHRoZSBtYW5kYXRvcnkgYXJndW1lbnRzXG4gICAgICAvLyB0byBcXGdlbmZyYWMgYW5kIFxcYWJvdmUuXG4gICAgICByZXMudGV4dCA9IFwiMHB0XCI7IC8vIEVuYWJsZSBcXGFib3Zle31cblxuICAgICAgaXNCbGFuayA9IHRydWU7IC8vIFRoaXMgaXMgaGVyZSBzcGVjaWZpY2FsbHkgZm9yIFxcZ2VuZnJhY1xuICAgIH1cblxuICAgIHZhciBtYXRjaCA9IC8oWy0rXT8pICooXFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSAqKFthLXpdezJ9KS8uZXhlYyhyZXMudGV4dCk7XG5cbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbnZhbGlkIHNpemU6ICdcIiArIHJlcy50ZXh0ICsgXCInXCIsIHJlcyk7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBudW1iZXI6ICsobWF0Y2hbMV0gKyBtYXRjaFsyXSksXG4gICAgICAvLyBzaWduICsgbWFnbml0dWRlLCBjYXN0IHRvIG51bWJlclxuICAgICAgdW5pdDogbWF0Y2hbM11cbiAgICB9O1xuXG4gICAgaWYgKCF2YWxpZFVuaXQoZGF0YSkpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgdW5pdDogJ1wiICsgZGF0YS51bml0ICsgXCInXCIsIHJlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic2l6ZVwiLFxuICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgdmFsdWU6IGRhdGEsXG4gICAgICBpc0JsYW5rOiBpc0JsYW5rXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGFuIFVSTCwgY2hlY2tpbmcgZXNjYXBlZCBsZXR0ZXJzIGFuZCBhbGxvd2VkIHByb3RvY29scyxcbiAgICogYW5kIHNldHRpbmcgdGhlIGNhdGNvZGUgb2YgJSBhcyBhbiBhY3RpdmUgY2hhcmFjdGVyIChhcyBpbiBcXGh5cGVycmVmKS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VVcmxHcm91cCA9IGZ1bmN0aW9uIHBhcnNlVXJsR3JvdXAob3B0aW9uYWwsIGNvbnN1bWVTcGFjZXMpIHtcbiAgICB0aGlzLmd1bGxldC5sZXhlci5zZXRDYXRjb2RlKFwiJVwiLCAxMyk7IC8vIGFjdGl2ZSBjaGFyYWN0ZXJcblxuICAgIHZhciByZXMgPSB0aGlzLnBhcnNlU3RyaW5nR3JvdXAoXCJ1cmxcIiwgb3B0aW9uYWwsIHRydWUpOyAvLyBnZXQgcmF3IHN0cmluZ1xuXG4gICAgdGhpcy5ndWxsZXQubGV4ZXIuc2V0Q2F0Y29kZShcIiVcIiwgMTQpOyAvLyBjb21tZW50IGNoYXJhY3RlclxuXG4gICAgaWYgKCFyZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gaHlwZXJyZWYgcGFja2FnZSBhbGxvd3MgYmFja3NsYXNoZXMgYWxvbmUgaW4gaHJlZiwgYnV0IGRvZXNuJ3RcbiAgICAvLyBnZW5lcmF0ZSB2YWxpZCBsaW5rcyBpbiBzdWNoIGNhc2VzOyB3ZSBpbnRlcnByZXQgdGhpcyBhc1xuICAgIC8vIFwidW5kZWZpbmVkXCIgYmVoYXZpb3VyLCBhbmQga2VlcCB0aGVtIGFzLWlzLiBTb21lIGJyb3dzZXIgd2lsbFxuICAgIC8vIHJlcGxhY2UgYmFja3NsYXNoZXMgd2l0aCBmb3J3YXJkIHNsYXNoZXMuXG5cblxuICAgIHZhciB1cmwgPSByZXMudGV4dC5yZXBsYWNlKC9cXFxcKFsjJCUmfl9ee31dKS9nLCAnJDEnKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ1cmxcIixcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIHVybDogdXJsXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogSWYgYG9wdGlvbmFsYCBpcyBmYWxzZSBvciBhYnNlbnQsIHRoaXMgcGFyc2VzIGFuIG9yZGluYXJ5IGdyb3VwLFxuICAgKiB3aGljaCBpcyBlaXRoZXIgYSBzaW5nbGUgbnVjbGV1cyAobGlrZSBcInhcIikgb3IgYW4gZXhwcmVzc2lvblxuICAgKiBpbiBicmFjZXMgKGxpa2UgXCJ7eCt5fVwiKSBvciBhbiBpbXBsaWNpdCBncm91cCwgYSBncm91cCB0aGF0IHN0YXJ0c1xuICAgKiBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiwgYW5kIGVuZHMgcmlnaHQgYmVmb3JlIGEgaGlnaGVyIGV4cGxpY2l0XG4gICAqIGdyb3VwIGVuZHMsIG9yIGF0IEVPRi5cbiAgICogSWYgYG9wdGlvbmFsYCBpcyB0cnVlLCBpdCBwYXJzZXMgZWl0aGVyIGEgYnJhY2tldC1kZWxpbWl0ZWQgZXhwcmVzc2lvblxuICAgKiAobGlrZSBcIlt4K3ldXCIpIG9yIHJldHVybnMgbnVsbCB0byBpbmRpY2F0ZSB0aGUgYWJzZW5jZSBvZiBhXG4gICAqIGJyYWNrZXQtZW5jbG9zZWQgZ3JvdXAuXG4gICAqIElmIGBtb2RlYCBpcyBwcmVzZW50LCBzd2l0Y2hlcyB0byB0aGF0IG1vZGUgd2hpbGUgcGFyc2luZyB0aGUgZ3JvdXAsXG4gICAqIGFuZCBzd2l0Y2hlcyBiYWNrIGFmdGVyLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUdyb3VwID0gZnVuY3Rpb24gcGFyc2VHcm91cChuYW1lLCAvLyBGb3IgZXJyb3IgcmVwb3J0aW5nLlxuICBvcHRpb25hbCwgZ3JlZWRpbmVzcywgYnJlYWtPblRva2VuVGV4dCwgbW9kZSwgY29uc3VtZVNwYWNlcykge1xuICAgIC8vIFN3aXRjaCB0byBzcGVjaWZpZWQgbW9kZVxuICAgIHZhciBvdXRlck1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICBpZiAobW9kZSkge1xuICAgICAgdGhpcy5zd2l0Y2hNb2RlKG1vZGUpO1xuICAgIH0gLy8gQ29uc3VtZSBzcGFjZXMgaWYgcmVxdWVzdGVkLCBjcnVjaWFsbHkgKmFmdGVyKiB3ZSBzd2l0Y2ggbW9kZXMsXG4gICAgLy8gc28gdGhhdCB0aGUgbmV4dCBub24tc3BhY2UgdG9rZW4gaXMgcGFyc2VkIGluIHRoZSBjb3JyZWN0IG1vZGUuXG5cblxuICAgIGlmIChjb25zdW1lU3BhY2VzKSB7XG4gICAgICB0aGlzLmNvbnN1bWVTcGFjZXMoKTtcbiAgICB9IC8vIEdldCBmaXJzdCB0b2tlblxuXG5cbiAgICB2YXIgZmlyc3RUb2tlbiA9IHRoaXMuZmV0Y2goKTtcbiAgICB2YXIgdGV4dCA9IGZpcnN0VG9rZW4udGV4dDtcbiAgICB2YXIgcmVzdWx0OyAvLyBUcnkgdG8gcGFyc2UgYW4gb3BlbiBicmFjZSBvciBcXGJlZ2luZ3JvdXBcblxuICAgIGlmIChvcHRpb25hbCA/IHRleHQgPT09IFwiW1wiIDogdGV4dCA9PT0gXCJ7XCIgfHwgdGV4dCA9PT0gXCJcXFxcYmVnaW5ncm91cFwiKSB7XG4gICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgIHZhciBncm91cEVuZCA9IFBhcnNlci5lbmRPZkdyb3VwW3RleHRdOyAvLyBTdGFydCBhIG5ldyBncm91cCBuYW1lc3BhY2VcblxuICAgICAgdGhpcy5ndWxsZXQuYmVnaW5Hcm91cCgpOyAvLyBJZiB3ZSBnZXQgYSBicmFjZSwgcGFyc2UgYW4gZXhwcmVzc2lvblxuXG4gICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBncm91cEVuZCk7XG4gICAgICB2YXIgbGFzdFRva2VuID0gdGhpcy5mZXRjaCgpOyAvLyBDaGVjayB0aGF0IHdlIGdvdCBhIG1hdGNoaW5nIGNsb3NpbmcgYnJhY2VcblxuICAgICAgdGhpcy5leHBlY3QoZ3JvdXBFbmQpOyAvLyBFbmQgZ3JvdXAgbmFtZXNwYWNlXG5cbiAgICAgIHRoaXMuZ3VsbGV0LmVuZEdyb3VwKCk7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICBsb2M6IFNvdXJjZUxvY2F0aW9uLnJhbmdlKGZpcnN0VG9rZW4sIGxhc3RUb2tlbiksXG4gICAgICAgIGJvZHk6IGV4cHJlc3Npb24sXG4gICAgICAgIC8vIEEgZ3JvdXAgZm9ybWVkIGJ5IFxcYmVnaW5ncm91cC4uLlxcZW5kZ3JvdXAgaXMgYSBzZW1pLXNpbXBsZSBncm91cFxuICAgICAgICAvLyB3aGljaCBkb2Vzbid0IGFmZmVjdCBzcGFjaW5nIGluIG1hdGggbW9kZSwgaS5lLiwgaXMgdHJhbnNwYXJlbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vdGV4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8xOTMwL3doZW4tc2hvdWxkLW9uZS1cbiAgICAgICAgLy8gdXNlLWJlZ2luZ3JvdXAtaW5zdGVhZC1vZi1iZ3JvdXBcbiAgICAgICAgc2VtaXNpbXBsZTogdGV4dCA9PT0gXCJcXFxcYmVnaW5ncm91cFwiIHx8IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAvLyBSZXR1cm4gbm90aGluZyBmb3IgYW4gb3B0aW9uYWwgZ3JvdXBcbiAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlIGV4aXN0cyBhIGZ1bmN0aW9uIHdpdGggdGhpcyBuYW1lLCBwYXJzZSB0aGUgZnVuY3Rpb24uXG4gICAgICAvLyBPdGhlcndpc2UsIGp1c3QgcmV0dXJuIGEgbnVjbGV1c1xuICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUZ1bmN0aW9uKGJyZWFrT25Ub2tlblRleHQsIG5hbWUsIGdyZWVkaW5lc3MpIHx8IHRoaXMucGFyc2VTeW1ib2woKTtcblxuICAgICAgaWYgKHJlc3VsdCA9PSBudWxsICYmIHRleHRbMF0gPT09IFwiXFxcXFwiICYmICFpbXBsaWNpdENvbW1hbmRzLmhhc093blByb3BlcnR5KHRleHQpKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnRocm93T25FcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlVuZGVmaW5lZCBjb250cm9sIHNlcXVlbmNlOiBcIiArIHRleHQsIGZpcnN0VG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gdGhpcy5mb3JtYXRVbnN1cHBvcnRlZENtZCh0ZXh0KTtcbiAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICB9XG4gICAgfSAvLyBTd2l0Y2ggbW9kZSBiYWNrXG5cblxuICAgIGlmIChtb2RlKSB7XG4gICAgICB0aGlzLnN3aXRjaE1vZGUob3V0ZXJNb2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBGb3JtIGxpZ2F0dXJlLWxpa2UgY29tYmluYXRpb25zIG9mIGNoYXJhY3RlcnMgZm9yIHRleHQgbW9kZS5cbiAgICogVGhpcyBpbmNsdWRlcyBpbnB1dHMgbGlrZSBcIi0tXCIsIFwiLS0tXCIsIFwiYGBcIiBhbmQgXCInJ1wiLlxuICAgKiBUaGUgcmVzdWx0IHdpbGwgc2ltcGx5IHJlcGxhY2UgbXVsdGlwbGUgdGV4dG9yZCBub2RlcyB3aXRoIGEgc2luZ2xlXG4gICAqIGNoYXJhY3RlciBpbiBlYWNoIHZhbHVlIGJ5IGEgc2luZ2xlIHRleHRvcmQgbm9kZSBoYXZpbmcgbXVsdGlwbGVcbiAgICogY2hhcmFjdGVycyBpbiBpdHMgdmFsdWUuICBUaGUgcmVwcmVzZW50YXRpb24gaXMgc3RpbGwgQVNDSUkgc291cmNlLlxuICAgKiBUaGUgZ3JvdXAgd2lsbCBiZSBtb2RpZmllZCBpbiBwbGFjZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZm9ybUxpZ2F0dXJlcyA9IGZ1bmN0aW9uIGZvcm1MaWdhdHVyZXMoZ3JvdXApIHtcbiAgICB2YXIgbiA9IGdyb3VwLmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIGEgPSBncm91cFtpXTsgLy8gJEZsb3dGaXhNZTogTm90IGV2ZXJ5IG5vZGUgdHlwZSBoYXMgYSBgdGV4dGAgcHJvcGVydHkuXG5cbiAgICAgIHZhciB2ID0gYS50ZXh0O1xuXG4gICAgICBpZiAodiA9PT0gXCItXCIgJiYgZ3JvdXBbaSArIDFdLnRleHQgPT09IFwiLVwiKSB7XG4gICAgICAgIGlmIChpICsgMSA8IG4gJiYgZ3JvdXBbaSArIDJdLnRleHQgPT09IFwiLVwiKSB7XG4gICAgICAgICAgZ3JvdXAuc3BsaWNlKGksIDMsIHtcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICBsb2M6IFNvdXJjZUxvY2F0aW9uLnJhbmdlKGEsIGdyb3VwW2kgKyAyXSksXG4gICAgICAgICAgICB0ZXh0OiBcIi0tLVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbiAtPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyb3VwLnNwbGljZShpLCAyLCB7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShhLCBncm91cFtpICsgMV0pLFxuICAgICAgICAgICAgdGV4dDogXCItLVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbiAtPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgodiA9PT0gXCInXCIgfHwgdiA9PT0gXCJgXCIpICYmIGdyb3VwW2kgKyAxXS50ZXh0ID09PSB2KSB7XG4gICAgICAgIGdyb3VwLnNwbGljZShpLCAyLCB7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShhLCBncm91cFtpICsgMV0pLFxuICAgICAgICAgIHRleHQ6IHYgKyB2XG4gICAgICAgIH0pO1xuICAgICAgICBuIC09IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBhIHNpbmdsZSBzeW1ib2wgb3V0IG9mIHRoZSBzdHJpbmcuIEhlcmUsIHdlIGhhbmRsZSBzaW5nbGUgY2hhcmFjdGVyXG4gICAqIHN5bWJvbHMgYW5kIHNwZWNpYWwgZnVuY3Rpb25zIGxpa2UgXFx2ZXJiLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZVN5bWJvbCA9IGZ1bmN0aW9uIHBhcnNlU3ltYm9sKCkge1xuICAgIHZhciBudWNsZXVzID0gdGhpcy5mZXRjaCgpO1xuICAgIHZhciB0ZXh0ID0gbnVjbGV1cy50ZXh0O1xuXG4gICAgaWYgKC9eXFxcXHZlcmJbXmEtekEtWl0vLnRlc3QodGV4dCkpIHtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgdmFyIGFyZyA9IHRleHQuc2xpY2UoNSk7XG4gICAgICB2YXIgc3RhciA9IGFyZy5jaGFyQXQoMCkgPT09IFwiKlwiO1xuXG4gICAgICBpZiAoc3Rhcikge1xuICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMSk7XG4gICAgICB9IC8vIExleGVyJ3MgdG9rZW5SZWdleCBpcyBjb25zdHJ1Y3RlZCB0byBhbHdheXMgaGF2ZSBtYXRjaGluZ1xuICAgICAgLy8gZmlyc3QvbGFzdCBjaGFyYWN0ZXJzLlxuXG5cbiAgICAgIGlmIChhcmcubGVuZ3RoIDwgMiB8fCBhcmcuY2hhckF0KDApICE9PSBhcmcuc2xpY2UoLTEpKSB7XG4gICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlxcXFx2ZXJiIGFzc2VydGlvbiBmYWlsZWQgLS1cXG4gICAgICAgICAgICAgICAgICAgIHBsZWFzZSByZXBvcnQgd2hhdCBpbnB1dCBjYXVzZWQgdGhpcyBidWdcIik7XG4gICAgICB9XG5cbiAgICAgIGFyZyA9IGFyZy5zbGljZSgxLCAtMSk7IC8vIHJlbW92ZSBmaXJzdCBhbmQgbGFzdCBjaGFyXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidmVyYlwiLFxuICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgYm9keTogYXJnLFxuICAgICAgICBzdGFyOiBzdGFyXG4gICAgICB9O1xuICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgd2Ugc2hvdWxkIGhhdmUgYSBzeW1ib2wsIHBvc3NpYmx5IHdpdGggYWNjZW50cy5cbiAgICAvLyBGaXJzdCBleHBhbmQgYW55IGFjY2VudGVkIGJhc2Ugc3ltYm9sIGFjY29yZGluZyB0byB1bmljb2RlU3ltYm9scy5cblxuXG4gICAgaWYgKHVuaWNvZGVTeW1ib2xzLmhhc093blByb3BlcnR5KHRleHRbMF0pICYmICFzcmNfc3ltYm9sc1t0aGlzLm1vZGVdW3RleHRbMF1dKSB7XG4gICAgICAvLyBUaGlzIGJlaGF2aW9yIGlzIG5vdCBzdHJpY3QgKFhlVGVYLWNvbXBhdGlibGUpIGluIG1hdGggbW9kZS5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnN0cmljdCAmJiB0aGlzLm1vZGUgPT09IFwibWF0aFwiKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KFwidW5pY29kZVRleHRJbk1hdGhNb2RlXCIsIFwiQWNjZW50ZWQgVW5pY29kZSB0ZXh0IGNoYXJhY3RlciBcXFwiXCIgKyB0ZXh0WzBdICsgXCJcXFwiIHVzZWQgaW4gXCIgKyBcIm1hdGggbW9kZVwiLCBudWNsZXVzKTtcbiAgICAgIH1cblxuICAgICAgdGV4dCA9IHVuaWNvZGVTeW1ib2xzW3RleHRbMF1dICsgdGV4dC5zdWJzdHIoMSk7XG4gICAgfSAvLyBTdHJpcCBvZmYgYW55IGNvbWJpbmluZyBjaGFyYWN0ZXJzXG5cblxuICAgIHZhciBtYXRjaCA9IGNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya3NFbmRSZWdleC5leGVjKHRleHQpO1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgbWF0Y2guaW5kZXgpO1xuXG4gICAgICBpZiAodGV4dCA9PT0gJ2knKSB7XG4gICAgICAgIHRleHQgPSBcIlxcdTAxMzFcIjsgLy8gZG90bGVzcyBpLCBpbiBtYXRoIGFuZCB0ZXh0IG1vZGVcbiAgICAgIH0gZWxzZSBpZiAodGV4dCA9PT0gJ2onKSB7XG4gICAgICAgIHRleHQgPSBcIlxcdTAyMzdcIjsgLy8gZG90bGVzcyBqLCBpbiBtYXRoIGFuZCB0ZXh0IG1vZGVcbiAgICAgIH1cbiAgICB9IC8vIFJlY29nbml6ZSBiYXNlIHN5bWJvbFxuXG5cbiAgICB2YXIgc3ltYm9sO1xuXG4gICAgaWYgKHNyY19zeW1ib2xzW3RoaXMubW9kZV1bdGV4dF0pIHtcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnN0cmljdCAmJiB0aGlzLm1vZGUgPT09ICdtYXRoJyAmJiBleHRyYUxhdGluLmluZGV4T2YodGV4dCkgPj0gMCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdChcInVuaWNvZGVUZXh0SW5NYXRoTW9kZVwiLCBcIkxhdGluLTEvVW5pY29kZSB0ZXh0IGNoYXJhY3RlciBcXFwiXCIgKyB0ZXh0WzBdICsgXCJcXFwiIHVzZWQgaW4gXCIgKyBcIm1hdGggbW9kZVwiLCBudWNsZXVzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGdyb3VwID0gc3JjX3N5bWJvbHNbdGhpcy5tb2RlXVt0ZXh0XS5ncm91cDtcbiAgICAgIHZhciBsb2MgPSBTb3VyY2VMb2NhdGlvbi5yYW5nZShudWNsZXVzKTtcbiAgICAgIHZhciBzO1xuXG4gICAgICBpZiAoQVRPTVMuaGFzT3duUHJvcGVydHkoZ3JvdXApKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgdmFyIGZhbWlseSA9IGdyb3VwO1xuICAgICAgICBzID0ge1xuICAgICAgICAgIHR5cGU6IFwiYXRvbVwiLFxuICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICBmYW1pbHk6IGZhbWlseSxcbiAgICAgICAgICBsb2M6IGxvYyxcbiAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIHMgPSB7XG4gICAgICAgICAgdHlwZTogZ3JvdXAsXG4gICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgIGxvYzogbG9jLFxuICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgc3ltYm9sID0gcztcbiAgICB9IGVsc2UgaWYgKHRleHQuY2hhckNvZGVBdCgwKSA+PSAweDgwKSB7XG4gICAgICAvLyBubyBzeW1ib2wgZm9yIGUuZy4gXlxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3RyaWN0KSB7XG4gICAgICAgIGlmICghc3VwcG9ydGVkQ29kZXBvaW50KHRleHQuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICB0aGlzLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdChcInVua25vd25TeW1ib2xcIiwgXCJVbnJlY29nbml6ZWQgVW5pY29kZSBjaGFyYWN0ZXIgXFxcIlwiICsgdGV4dFswXSArIFwiXFxcIlwiICsgKFwiIChcIiArIHRleHQuY2hhckNvZGVBdCgwKSArIFwiKVwiKSwgbnVjbGV1cyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSBcIm1hdGhcIikge1xuICAgICAgICAgIHRoaXMuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KFwidW5pY29kZVRleHRJbk1hdGhNb2RlXCIsIFwiVW5pY29kZSB0ZXh0IGNoYXJhY3RlciBcXFwiXCIgKyB0ZXh0WzBdICsgXCJcXFwiIHVzZWQgaW4gbWF0aCBtb2RlXCIsIG51Y2xldXMpO1xuICAgICAgICB9XG4gICAgICB9IC8vIEFsbCBub25tYXRoZW1hdGljYWwgVW5pY29kZSBjaGFyYWN0ZXJzIGFyZSByZW5kZXJlZCBhcyBpZiB0aGV5XG4gICAgICAvLyBhcmUgaW4gdGV4dCBtb2RlICh3cmFwcGVkIGluIFxcdGV4dCkgYmVjYXVzZSB0aGF0J3Mgd2hhdCBpdFxuICAgICAgLy8gdGFrZXMgdG8gcmVuZGVyIHRoZW0gaW4gTGFUZVguICBTZXR0aW5nIGBtb2RlOiB0aGlzLm1vZGVgIGlzXG4gICAgICAvLyBhbm90aGVyIG5hdHVyYWwgY2hvaWNlICh0aGUgdXNlciByZXF1ZXN0ZWQgbWF0aCBtb2RlKSwgYnV0XG4gICAgICAvLyB0aGlzIG1ha2VzIGl0IG1vcmUgZGlmZmljdWx0IGZvciBnZXRDaGFyYWN0ZXJNZXRyaWNzKCkgdG9cbiAgICAgIC8vIGRpc3Rpbmd1aXNoIFVuaWNvZGUgY2hhcmFjdGVycyB3aXRob3V0IG1ldHJpY3MgYW5kIHRob3NlIGZvclxuICAgICAgLy8gd2hpY2ggd2Ugd2FudCB0byBzaW11bGF0ZSB0aGUgbGV0dGVyIE0uXG5cblxuICAgICAgc3ltYm9sID0ge1xuICAgICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UobnVjbGV1cyksXG4gICAgICAgIHRleHQ6IHRleHRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsOyAvLyBFT0YsIF4sIF8sIHssIH0sIGV0Yy5cbiAgICB9XG5cbiAgICB0aGlzLmNvbnN1bWUoKTsgLy8gVHJhbnNmb3JtIGNvbWJpbmluZyBjaGFyYWN0ZXJzIGludG8gYWNjZW50c1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoWzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhY2NlbnQgPSBtYXRjaFswXVtpXTtcblxuICAgICAgICBpZiAoIXVuaWNvZGVBY2NlbnRzW2FjY2VudF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJVbmtub3duIGFjY2VudCAnIFwiICsgYWNjZW50ICsgXCInXCIsIG51Y2xldXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbW1hbmQgPSB1bmljb2RlQWNjZW50c1thY2NlbnRdW3RoaXMubW9kZV07XG5cbiAgICAgICAgaWYgKCFjb21tYW5kKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiQWNjZW50IFwiICsgYWNjZW50ICsgXCIgdW5zdXBwb3J0ZWQgaW4gXCIgKyB0aGlzLm1vZGUgKyBcIiBtb2RlXCIsIG51Y2xldXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ltYm9sID0ge1xuICAgICAgICAgIHR5cGU6IFwiYWNjZW50XCIsXG4gICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UobnVjbGV1cyksXG4gICAgICAgICAgbGFiZWw6IGNvbW1hbmQsXG4gICAgICAgICAgaXNTdHJldGNoeTogZmFsc2UsXG4gICAgICAgICAgaXNTaGlmdHk6IHRydWUsXG4gICAgICAgICAgYmFzZTogc3ltYm9sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN5bWJvbDtcbiAgfTtcblxuICByZXR1cm4gUGFyc2VyO1xufSgpO1xuXG5QYXJzZXJfUGFyc2VyLmVuZE9mRXhwcmVzc2lvbiA9IFtcIn1cIiwgXCJcXFxcZW5kZ3JvdXBcIiwgXCJcXFxcZW5kXCIsIFwiXFxcXHJpZ2h0XCIsIFwiJlwiXTtcblBhcnNlcl9QYXJzZXIuZW5kT2ZHcm91cCA9IHtcbiAgXCJbXCI6IFwiXVwiLFxuICBcIntcIjogXCJ9XCIsXG4gIFwiXFxcXGJlZ2luZ3JvdXBcIjogXCJcXFxcZW5kZ3JvdXBcIlxuICAvKipcbiAgICogUGFyc2VzIGFuIFwiZXhwcmVzc2lvblwiLCB3aGljaCBpcyBhIGxpc3Qgb2YgYXRvbXMuXG4gICAqXG4gICAqIGBicmVha09uSW5maXhgOiBTaG91bGQgdGhlIHBhcnNpbmcgc3RvcCB3aGVuIHdlIGhpdCBpbmZpeCBub2Rlcz8gVGhpc1xuICAgKiAgICAgICAgICAgICAgICAgaGFwcGVucyB3aGVuIGZ1bmN0aW9ucyBoYXZlIGhpZ2hlciBwcmVjZW5kZW5jZSBoYW4gaW5maXhcbiAgICogICAgICAgICAgICAgICAgIG5vZGVzIGluIGltcGxpY2l0IHBhcnNlcy5cbiAgICpcbiAgICogYGJyZWFrT25Ub2tlblRleHRgOiBUaGUgdGV4dCBvZiB0aGUgdG9rZW4gdGhhdCB0aGUgZXhwcmVzc2lvbiBzaG91bGQgZW5kXG4gICAqICAgICAgICAgICAgICAgICAgICAgd2l0aCwgb3IgYG51bGxgIGlmIHNvbWV0aGluZyBlbHNlIHNob3VsZCBlbmQgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5cbiAgICovXG5cbn07XG5QYXJzZXJfUGFyc2VyLlNVUFNVQl9HUkVFRElORVNTID0gMTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcGFyc2VUcmVlLmpzXG4vKipcbiAqIFByb3ZpZGVzIGEgc2luZ2xlIGZ1bmN0aW9uIGZvciBwYXJzaW5nIGFuIGV4cHJlc3Npb24gdXNpbmcgYSBQYXJzZXJcbiAqIFRPRE8oZW1pbHkpOiBSZW1vdmUgdGhpc1xuICovXG5cblxuXG4vKipcbiAqIFBhcnNlcyBhbiBleHByZXNzaW9uIHVzaW5nIGEgUGFyc2VyLCB0aGVuIHJldHVybnMgdGhlIHBhcnNlZCByZXN1bHQuXG4gKi9cbnZhciBwYXJzZVRyZWVfcGFyc2VUcmVlID0gZnVuY3Rpb24gcGFyc2VUcmVlKHRvUGFyc2UsIHNldHRpbmdzKSB7XG4gIGlmICghKHR5cGVvZiB0b1BhcnNlID09PSAnc3RyaW5nJyB8fCB0b1BhcnNlIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0thVGVYIGNhbiBvbmx5IHBhcnNlIHN0cmluZyB0eXBlZCBleHByZXNzaW9uJyk7XG4gIH1cblxuICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcl9QYXJzZXIodG9QYXJzZSwgc2V0dGluZ3MpOyAvLyBCbGFuayBvdXQgYW55IFxcZGZAdGFnIHRvIGF2b2lkIHNwdXJpb3VzIFwiRHVwbGljYXRlIFxcdGFnXCIgZXJyb3JzXG5cbiAgZGVsZXRlIHBhcnNlci5ndWxsZXQubWFjcm9zLmN1cnJlbnRbXCJcXFxcZGZAdGFnXCJdO1xuICB2YXIgdHJlZSA9IHBhcnNlci5wYXJzZSgpOyAvLyBJZiB0aGUgaW5wdXQgdXNlZCBcXHRhZywgaXQgd2lsbCBzZXQgdGhlIFxcZGZAdGFnIG1hY3JvIHRvIHRoZSB0YWcuXG4gIC8vIEluIHRoaXMgY2FzZSwgd2Ugc2VwYXJhdGVseSBwYXJzZSB0aGUgdGFnIGFuZCB3cmFwIHRoZSB0cmVlLlxuXG4gIGlmIChwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5nZXQoXCJcXFxcZGZAdGFnXCIpKSB7XG4gICAgaWYgKCFzZXR0aW5ncy5kaXNwbGF5TW9kZSkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiXFxcXHRhZyB3b3JrcyBvbmx5IGluIGRpc3BsYXkgZXF1YXRpb25zXCIpO1xuICAgIH1cblxuICAgIHBhcnNlci5ndWxsZXQuZmVlZChcIlxcXFxkZkB0YWdcIik7XG4gICAgdHJlZSA9IFt7XG4gICAgICB0eXBlOiBcInRhZ1wiLFxuICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICBib2R5OiB0cmVlLFxuICAgICAgdGFnOiBwYXJzZXIucGFyc2UoKVxuICAgIH1dO1xuICB9XG5cbiAgcmV0dXJuIHRyZWU7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfcGFyc2VUcmVlID0gKHBhcnNlVHJlZV9wYXJzZVRyZWUpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9rYXRleC5qc1xuLyogZXNsaW50IG5vLWNvbnNvbGU6MCAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIG1haW4gZW50cnkgcG9pbnQgZm9yIEthVGVYLiBIZXJlLCB3ZSBleHBvc2UgZnVuY3Rpb25zIGZvclxuICogcmVuZGVyaW5nIGV4cHJlc3Npb25zIGVpdGhlciB0byBET00gbm9kZXMgb3IgdG8gbWFya3VwIHN0cmluZ3MuXG4gKlxuICogV2UgYWxzbyBleHBvc2UgdGhlIFBhcnNlRXJyb3IgY2xhc3MgdG8gY2hlY2sgaWYgZXJyb3JzIHRocm93biBmcm9tIEthVGVYIGFyZVxuICogZXJyb3JzIGluIHRoZSBleHByZXNzaW9uLCBvciBlcnJvcnMgaW4gamF2YXNjcmlwdCBoYW5kbGluZy5cbiAqL1xuXG5cblxuXG5cblxuXG5cblxuXG4vKipcbiAqIFBhcnNlIGFuZCBidWlsZCBhbiBleHByZXNzaW9uLCBhbmQgcGxhY2UgdGhhdCBleHByZXNzaW9uIGluIHRoZSBET00gbm9kZVxuICogZ2l2ZW4uXG4gKi9cbnZhciBrYXRleF9yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoZXhwcmVzc2lvbiwgYmFzZU5vZGUsIG9wdGlvbnMpIHtcbiAgYmFzZU5vZGUudGV4dENvbnRlbnQgPSBcIlwiO1xuICB2YXIgbm9kZSA9IGthdGV4X3JlbmRlclRvRG9tVHJlZShleHByZXNzaW9uLCBvcHRpb25zKS50b05vZGUoKTtcbiAgYmFzZU5vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XG59OyAvLyBLYVRlWCdzIHN0eWxlcyBkb24ndCB3b3JrIHByb3Blcmx5IGluIHF1aXJrcyBtb2RlLiBQcmludCBvdXQgYW4gZXJyb3IsIGFuZFxuLy8gZGlzYWJsZSByZW5kZXJpbmcuXG5cblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBpZiAoZG9jdW1lbnQuY29tcGF0TW9kZSAhPT0gXCJDU1MxQ29tcGF0XCIpIHtcbiAgICB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBLYVRlWCBkb2Vzbid0IHdvcmsgaW4gcXVpcmtzIG1vZGUuIE1ha2Ugc3VyZSB5b3VyIFwiICsgXCJ3ZWJzaXRlIGhhcyBhIHN1aXRhYmxlIGRvY3R5cGUuXCIpO1xuXG4gICAga2F0ZXhfcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiS2FUZVggZG9lc24ndCB3b3JrIGluIHF1aXJrcyBtb2RlLlwiKTtcbiAgICB9O1xuICB9XG59XG4vKipcbiAqIFBhcnNlIGFuZCBidWlsZCBhbiBleHByZXNzaW9uLCBhbmQgcmV0dXJuIHRoZSBtYXJrdXAgZm9yIHRoYXQuXG4gKi9cblxuXG52YXIgcmVuZGVyVG9TdHJpbmcgPSBmdW5jdGlvbiByZW5kZXJUb1N0cmluZyhleHByZXNzaW9uLCBvcHRpb25zKSB7XG4gIHZhciBtYXJrdXAgPSBrYXRleF9yZW5kZXJUb0RvbVRyZWUoZXhwcmVzc2lvbiwgb3B0aW9ucykudG9NYXJrdXAoKTtcbiAgcmV0dXJuIG1hcmt1cDtcbn07XG4vKipcbiAqIFBhcnNlIGFuIGV4cHJlc3Npb24gYW5kIHJldHVybiB0aGUgcGFyc2UgdHJlZS5cbiAqL1xuXG5cbnZhciBrYXRleF9nZW5lcmF0ZVBhcnNlVHJlZSA9IGZ1bmN0aW9uIGdlbmVyYXRlUGFyc2VUcmVlKGV4cHJlc3Npb24sIG9wdGlvbnMpIHtcbiAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzX1NldHRpbmdzKG9wdGlvbnMpO1xuICByZXR1cm4gc3JjX3BhcnNlVHJlZShleHByZXNzaW9uLCBzZXR0aW5ncyk7XG59O1xuLyoqXG4gKiBJZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgYSBLYVRlWCBQYXJzZUVycm9yIGFuZCBvcHRpb25zLnRocm93T25FcnJvciBpcyBmYWxzZSxcbiAqIHJlbmRlcnMgdGhlIGludmFsaWQgTGFUZVggYXMgYSBzcGFuIHdpdGggaG92ZXIgdGl0bGUgZ2l2aW5nIHRoZSBLYVRlWFxuICogZXJyb3IgbWVzc2FnZS4gIE90aGVyd2lzZSwgc2ltcGx5IHRocm93cyB0aGUgZXJyb3IuXG4gKi9cblxuXG52YXIga2F0ZXhfcmVuZGVyRXJyb3IgPSBmdW5jdGlvbiByZW5kZXJFcnJvcihlcnJvciwgZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy50aHJvd09uRXJyb3IgfHwgIShlcnJvciBpbnN0YW5jZW9mIHNyY19QYXJzZUVycm9yKSkge1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIG5vZGUgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJrYXRleC1lcnJvclwiXSwgW25ldyBkb21UcmVlX1N5bWJvbE5vZGUoZXhwcmVzc2lvbildKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLCBlcnJvci50b1N0cmluZygpKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImNvbG9yOlwiICsgb3B0aW9ucy5lcnJvckNvbG9yKTtcbiAgcmV0dXJuIG5vZGU7XG59O1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW5kIHJldHVybnMgdGhlIGthdGV4IGJ1aWxkIHRyZWUuIFRoaXMgaXMgdXNlZCBmb3IgYWR2YW5jZWRcbiAqIHVzZSBjYXNlcyAobGlrZSByZW5kZXJpbmcgdG8gY3VzdG9tIG91dHB1dCkuXG4gKi9cblxuXG52YXIga2F0ZXhfcmVuZGVyVG9Eb21UcmVlID0gZnVuY3Rpb24gcmVuZGVyVG9Eb21UcmVlKGV4cHJlc3Npb24sIG9wdGlvbnMpIHtcbiAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzX1NldHRpbmdzKG9wdGlvbnMpO1xuXG4gIHRyeSB7XG4gICAgdmFyIHRyZWUgPSBzcmNfcGFyc2VUcmVlKGV4cHJlc3Npb24sIHNldHRpbmdzKTtcbiAgICByZXR1cm4gYnVpbGRUcmVlX2J1aWxkVHJlZSh0cmVlLCBleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGthdGV4X3JlbmRlckVycm9yKGVycm9yLCBleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gIH1cbn07XG4vKipcbiAqIEdlbmVyYXRlcyBhbmQgcmV0dXJucyB0aGUga2F0ZXggYnVpbGQgdHJlZSwgd2l0aCBqdXN0IEhUTUwgKG5vIE1hdGhNTCkuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGFkdmFuY2VkIHVzZSBjYXNlcyAobGlrZSByZW5kZXJpbmcgdG8gY3VzdG9tIG91dHB1dCkuXG4gKi9cblxuXG52YXIga2F0ZXhfcmVuZGVyVG9IVE1MVHJlZSA9IGZ1bmN0aW9uIHJlbmRlclRvSFRNTFRyZWUoZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICB2YXIgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3NfU2V0dGluZ3Mob3B0aW9ucyk7XG5cbiAgdHJ5IHtcbiAgICB2YXIgdHJlZSA9IHNyY19wYXJzZVRyZWUoZXhwcmVzc2lvbiwgc2V0dGluZ3MpO1xuICAgIHJldHVybiBidWlsZFRyZWVfYnVpbGRIVE1MVHJlZSh0cmVlLCBleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGthdGV4X3JlbmRlckVycm9yKGVycm9yLCBleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gIH1cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGthdGV4XzAgPSAoe1xuICAvKipcbiAgICogQ3VycmVudCBLYVRlWCB2ZXJzaW9uXG4gICAqL1xuICB2ZXJzaW9uOiBcIjAuMTEuMVwiLFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIGFuIEhUTUwrTWF0aE1MIGNvbWJpbmF0aW9uLCBhbmQgYWRkc1xuICAgKiBpdCBhcyBhIGNoaWxkIHRvIHRoZSBzcGVjaWZpZWQgRE9NIG5vZGUuXG4gICAqL1xuICByZW5kZXI6IGthdGV4X3JlbmRlcixcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZ2l2ZW4gTGFUZVggaW50byBhbiBIVE1MK01hdGhNTCBjb21iaW5hdGlvbiBzdHJpbmcsXG4gICAqIGZvciBzZW5kaW5nIHRvIHRoZSBjbGllbnQuXG4gICAqL1xuICByZW5kZXJUb1N0cmluZzogcmVuZGVyVG9TdHJpbmcsXG5cbiAgLyoqXG4gICAqIEthVGVYIGVycm9yLCB1c3VhbGx5IGR1cmluZyBwYXJzaW5nLlxuICAgKi9cbiAgUGFyc2VFcnJvcjogc3JjX1BhcnNlRXJyb3IsXG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgZ2l2ZW4gTGFUZVggaW50byBLYVRlWCdzIGludGVybmFsIHBhcnNlIHRyZWUgc3RydWN0dXJlLFxuICAgKiB3aXRob3V0IHJlbmRlcmluZyB0byBIVE1MIG9yIE1hdGhNTC5cbiAgICpcbiAgICogTk9URTogVGhpcyBtZXRob2QgaXMgbm90IGN1cnJlbnRseSByZWNvbW1lbmRlZCBmb3IgcHVibGljIHVzZS5cbiAgICogVGhlIGludGVybmFsIHRyZWUgcmVwcmVzZW50YXRpb24gaXMgdW5zdGFibGUgYW5kIGlzIHZlcnkgbGlrZWx5XG4gICAqIHRvIGNoYW5nZS4gVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gICAqL1xuICBfX3BhcnNlOiBrYXRleF9nZW5lcmF0ZVBhcnNlVHJlZSxcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZ2l2ZW4gTGFUZVggaW50byBhbiBIVE1MK01hdGhNTCBpbnRlcm5hbCBET00gdHJlZVxuICAgKiByZXByZXNlbnRhdGlvbiwgd2l0aG91dCBmbGF0dGVuaW5nIHRoYXQgcmVwcmVzZW50YXRpb24gdG8gYSBzdHJpbmcuXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG5vdCBjdXJyZW50bHkgcmVjb21tZW5kZWQgZm9yIHB1YmxpYyB1c2UuXG4gICAqIFRoZSBpbnRlcm5hbCB0cmVlIHJlcHJlc2VudGF0aW9uIGlzIHVuc3RhYmxlIGFuZCBpcyB2ZXJ5IGxpa2VseVxuICAgKiB0byBjaGFuZ2UuIFVzZSBhdCB5b3VyIG93biByaXNrLlxuICAgKi9cbiAgX19yZW5kZXJUb0RvbVRyZWU6IGthdGV4X3JlbmRlclRvRG9tVHJlZSxcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZ2l2ZW4gTGFUZVggaW50byBhbiBIVE1MIGludGVybmFsIERPTSB0cmVlIHJlcHJlc2VudGF0aW9uLFxuICAgKiB3aXRob3V0IE1hdGhNTCBhbmQgd2l0aG91dCBmbGF0dGVuaW5nIHRoYXQgcmVwcmVzZW50YXRpb24gdG8gYSBzdHJpbmcuXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG5vdCBjdXJyZW50bHkgcmVjb21tZW5kZWQgZm9yIHB1YmxpYyB1c2UuXG4gICAqIFRoZSBpbnRlcm5hbCB0cmVlIHJlcHJlc2VudGF0aW9uIGlzIHVuc3RhYmxlIGFuZCBpcyB2ZXJ5IGxpa2VseVxuICAgKiB0byBjaGFuZ2UuIFVzZSBhdCB5b3VyIG93biByaXNrLlxuICAgKi9cbiAgX19yZW5kZXJUb0hUTUxUcmVlOiBrYXRleF9yZW5kZXJUb0hUTUxUcmVlLFxuXG4gIC8qKlxuICAgKiBleHRlbmRzIGludGVybmFsIGZvbnQgbWV0cmljcyBvYmplY3Qgd2l0aCBhIG5ldyBvYmplY3RcbiAgICogZWFjaCBrZXkgaW4gdGhlIG5ldyBvYmplY3QgcmVwcmVzZW50cyBhIGZvbnQgbmFtZVxuICAqL1xuICBfX3NldEZvbnRNZXRyaWNzOiBzZXRGb250TWV0cmljcyxcblxuICAvKipcbiAgICogYWRkcyBhIG5ldyBzeW1ib2wgdG8gYnVpbHRpbiBzeW1ib2xzIHRhYmxlXG4gICAqL1xuICBfX2RlZmluZVN5bWJvbDogZGVmaW5lU3ltYm9sLFxuXG4gIC8qKlxuICAgKiBhZGRzIGEgbmV3IG1hY3JvIHRvIGJ1aWx0aW4gbWFjcm8gbGlzdFxuICAgKi9cbiAgX19kZWZpbmVNYWNybzogZGVmaW5lTWFjcm8sXG5cbiAgLyoqXG4gICAqIEV4cG9zZSB0aGUgZG9tIHRyZWUgbm9kZSB0eXBlcywgd2hpY2ggY2FuIGJlIHVzZWZ1bCBmb3IgdHlwZSBjaGVja2luZyBub2Rlcy5cbiAgICpcbiAgICogTk9URTogVGhpcyBtZXRob2QgaXMgbm90IGN1cnJlbnRseSByZWNvbW1lbmRlZCBmb3IgcHVibGljIHVzZS5cbiAgICogVGhlIGludGVybmFsIHRyZWUgcmVwcmVzZW50YXRpb24gaXMgdW5zdGFibGUgYW5kIGlzIHZlcnkgbGlrZWx5XG4gICAqIHRvIGNoYW5nZS4gVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gICAqL1xuICBfX2RvbVRyZWU6IHtcbiAgICBTcGFuOiBkb21UcmVlX1NwYW4sXG4gICAgQW5jaG9yOiBkb21UcmVlX0FuY2hvcixcbiAgICBTeW1ib2xOb2RlOiBkb21UcmVlX1N5bWJvbE5vZGUsXG4gICAgU3ZnTm9kZTogU3ZnTm9kZSxcbiAgICBQYXRoTm9kZTogZG9tVHJlZV9QYXRoTm9kZSxcbiAgICBMaW5lTm9kZTogTGluZU5vZGVcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2thdGV4LndlYnBhY2suanNcbi8qKlxuICogVGhpcyBpcyB0aGUgd2VicGFjayBlbnRyeSBwb2ludCBmb3IgS2FUZVguIEFzIEVDTUFTY3JpcHQsIGZsb3dbMV0gYW5kIGplc3RbMl1cbiAqIGRvZXNuJ3Qgc3VwcG9ydCBDU1MgbW9kdWxlcyBuYXRpdmVseSwgYSBzZXBhcmF0ZSBlbnRyeSBwb2ludCBpcyB1c2VkIGFuZFxuICogaXQgaXMgbm90IGZsb3d0eXBlZC5cbiAqXG4gKiBbMV0gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbGFtYmRhaGFuZHMvZDE5ZTBkYTk2Mjg1Yjc0OWYwZWZcbiAqIFsyXSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9qZXN0L2RvY3MvZW4vd2VicGFjay5odG1sXG4gKi9cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBrYXRleF93ZWJwYWNrID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoa2F0ZXhfMCk7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKVtcImRlZmF1bHRcIl07XG59KTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLFFBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///r0Fr\n");

/***/ })

}]);