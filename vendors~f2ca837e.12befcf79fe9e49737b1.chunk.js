(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~f2ca837e"],{

/***/ "aurelia-bodylight-plugin/elements/dygraphchart":
/*!********************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/dygraphchart.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.Dygraphchart = void 0;\n\nvar _dygraph = __webpack_require__(/*! ../utils/dygraph */ \"PA41\");\n\nvar _aureliaFramework = __webpack_require__(/*! aurelia-framework */ \"aurelia-framework\");\n\nvar _fileSaver = __webpack_require__(/*! file-saver */ \"Iab2\");\n\nvar _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10;\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\nlet Dygraphchart = (_class = class Dygraphchart {\n  //time to throttle chart update, if it is too much at once\n  constructor() {\n    _initializerDefineProperty(this, \"width\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"height\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"inputs\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"fromid\", _descriptor4, this);\n\n    _initializerDefineProperty(this, \"maxdata\", _descriptor5, this);\n\n    _initializerDefineProperty(this, \"refindex\", _descriptor6, this);\n\n    _initializerDefineProperty(this, \"refvalues\", _descriptor7, this);\n\n    _initializerDefineProperty(this, \"throttle\", _descriptor8, this);\n\n    _initializerDefineProperty(this, \"convertors\", _descriptor9, this);\n\n    _initializerDefineProperty(this, \"minichart\", _descriptor10, this);\n\n    this.initialdata = true;\n    this.refindices = null;\n    this.xy = false;\n    this.operation = null;\n    //this.data = [[0, 0, 0]];\n    //this.data=[[1, 5], [2, 5], [3, 4.9], [4, 4.8], [5, 5.2]];\n    //create lambda function which is added as listener later\n    console.log('dygraph chart constructor');\n\n    this.handleValueChange = e => {\n      let datapoint = [];\n      if (!this.xy) datapoint.push(e.detail.time); //e.detail do not reallocate - using same buffer, thus slicing to append to data array\n\n      let edata = e.detail.data.slice();\n      let opindex = 0;\n\n      if (this.refindices) {\n        for (let myindex of this.refindices) {\n          if (this.operation) {\n            datapoint.push(this.operation[opindex](edata[myindex]));\n            opindex++;\n          } else datapoint.push(edata[myindex]);\n        }\n      } else {\n        for (let i = this.refindex; i < this.refindex + this.refvalues; i++) {\n          if (this.operation) {\n            datapoint.push(this.operation[opindex](edata[i]));\n            opindex++;\n          } else datapoint.push(edata[i]);\n        }\n      }\n\n      if (this.initialdata) {\n        this.data = [];\n        this.initialdata = false;\n      } //datapoint\n\n\n      this.data.push(datapoint); //shift - remove first element if data is too big\n\n      if (this.data.length > this.maxdata) this.data.shift(); //console.log('Dygraphchar data', this.data);\n\n      this.updatechart(); //this.dygraph.updateOptions( { 'file': this.data } );\n    };\n\n    this.handleReset = e => {\n      this.resetdata();\n      this.updatechart(); //this.dygraph.updateOptions( { 'file': this.data } );\n    };\n  }\n\n  updatechartfn() {\n    this.dygraph.updateOptions({\n      'file': this.data\n    });\n  }\n\n  resetdata() {\n    this.data = [];\n    let initdatapoint = Array(parseInt(this.refvalues, 10) + 1).fill(0);\n    this.data.push(initdatapoint);\n    this.initialdata = true;\n  }\n\n  bind() {\n    if (typeof this.minichart === 'string') this.minichart = this.minichart === 'true';\n  }\n\n  attached() {\n    //listening to custom event fmidata\n    console.log('dygraph attached');\n    if (this.refindex && this.refindex.indexOf(',') > 0) this.refindices = this.refindex.split(',');\n    let fmielement = document.getElementById(this.fromid);\n\n    if (fmielement) {\n      fmielement.addEventListener('fmidata', this.handleValueChange);\n      fmielement.addEventListener('fmireset', this.handleReset);\n    } //labels are separated by , in attribute inputs\n    //console.log('BdlDygraphchart attached inputs', this.inputs);\n\n\n    this.labels = this.inputs ? this.inputs.split(',') : []; //console.log('BdlDygraphchart attached labels', labels);\n    //create dygraph\n\n    this.resetdata(); //console.log('BdlDygraphchart attached initial data init data', initdatapoint, ' data:', this.data);\n\n    this.initdygraph();\n    /*data.push([x, y]);\n    g.updateOptions( { 'file': data } );*/\n    //register throttled update function\n\n    if (typeof this.throttle === 'string') this.throttle = parseInt(this.throttle, 10);\n\n    if (this.throttle > 0) {\n      //throttle\n      this.updatechart = _.throttle(this.updatechartfn.bind(this), this.throttle);\n    } else {\n      //directly call chart update\n      this.updatechart = this.updatechartfn.bind(this);\n    } //configure convertors - used to convert units received from fmi\n\n\n    if (this.convertors) {\n      let convertvalues = this.convertors.split(';');\n\n      let identity = x => x;\n\n      this.operation = [];\n\n      for (let i = 0; i < convertvalues.length; i++) {\n        if (convertvalues[i].includes(',')) {\n          //convert values are in form numerator,denominator contains comma ','\n          let convertitems = convertvalues[i].split(',');\n          if (convertitems[0] === '1' && convertitems[1] === '1') this.operation.push(identity);else {\n            let numerator = parseFloat(convertitems[0]);\n            let denominator = parseFloat(convertitems[1]);\n            let addend = convertitems.length > 2 ? parseFloat(convertitems[2]) : 0;\n            this.operation.push(x => x * numerator / denominator + addend);\n          }\n        } else {\n          //convert values are in form of expression, do not contain comma\n          if (convertvalues === '1/x') this.operation.push(x => 1 / x);else {\n            // for eval() security filter only allowed characters:\n            // algebraic, digits, e, dot, modulo, parenthesis and 'x' and 'e' is allowed\n            let expression = convertvalues[i].replace(/[^-\\d/*+.()%xe]/g, '');\n            console.log('chartjs bind(), evaluating expression:' + convertvalues[i] + ' securely filtered to :' + expression); // eslint-disable-next-line no-eval\n\n            this.operation.push(x => eval(expression));\n          }\n        }\n      }\n    }\n  }\n\n  initdygraph() {\n    //console.log('initdygraph:',Dygraph);\n    this.dygraph = new _dygraph.Dygraph(this.dygraphcanvas, this.data, {\n      //Draw a small dot at each point\n      drawPoints: true,\n      //rolling average period text box to be show\n      //showRoller: true,\n      //customBars if series is low;middle;high where range between low and high is visualised\n      //customBars: true,\n      //range selector\n      //showRangeSelector: true,\n      labels: this.labels\n    });\n  }\n\n  detached() {\n    if (document.getElementById(this.fromid)) document.getElementById(this.fromid).removeEventListener('fmidata', this.handleValueChange);\n    if (document.getElementById(this.fromid)) document.getElementById(this.fromid).removeEventListener('fmireset', this.handleReset);\n  }\n\n  download() {\n    let filename = prompt('File name (*.csv):', 'data.csv');\n\n    if (filename) {\n      if (!filename.endsWith('.csv')) filename = filename.concat('.csv');\n      let content = this.inputs + '\\n' + this.data.map(e => e.join(',')).join('\\n');\n      let blob = new Blob([content], {\n        type: 'text/csv;charset=utf-8;'\n      });\n      (0, _fileSaver.saveAs)(blob, filename);\n    }\n  }\n\n  preview() {\n    let content = this.inputs + '\\n' + this.data.map(e => e.join(',')).join('\\n');\n    let blob = new Blob([content], {\n      type: 'text/csv;charset=utf-8;'\n    });\n    let url = URL.createObjectURL(blob);\n    this.popup = window.open(url, 'BodylightPreview', 'width=800,height=600,menubar=no,status=no,titlebar=no,toolbar=no');\n  }\n\n}, (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"width\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"height\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"inputs\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, \"fromid\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, \"maxdata\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 300;\n  }\n}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, \"refindex\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor7 = _applyDecoratedDescriptor(_class.prototype, \"refvalues\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 1;\n  }\n}), _descriptor8 = _applyDecoratedDescriptor(_class.prototype, \"throttle\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 200;\n  }\n}), _descriptor9 = _applyDecoratedDescriptor(_class.prototype, \"convertors\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor10 = _applyDecoratedDescriptor(_class.prototype, \"minichart\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class);\nexports.Dygraphchart = Dygraphchart;\n//# sourceMappingURL=dygraphchart.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2R5Z3JhcGhjaGFydC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLWJvZHlsaWdodC1wbHVnaW4vZGlzdC9uYXRpdmUtbW9kdWxlcy9lbGVtZW50cy9keWdyYXBoY2hhcnQuanM/NDcxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuRHlncmFwaGNoYXJ0ID0gdm9pZCAwO1xuXG52YXIgX2R5Z3JhcGggPSByZXF1aXJlKFwiLi4vdXRpbHMvZHlncmFwaFwiKTtcblxudmFyIF9hdXJlbGlhRnJhbWV3b3JrID0gcmVxdWlyZShcImF1cmVsaWEtZnJhbWV3b3JrXCIpO1xuXG52YXIgX2ZpbGVTYXZlciA9IHJlcXVpcmUoXCJmaWxlLXNhdmVyXCIpO1xuXG52YXIgX2NsYXNzLCBfZGVzY3JpcHRvciwgX2Rlc2NyaXB0b3IyLCBfZGVzY3JpcHRvcjMsIF9kZXNjcmlwdG9yNCwgX2Rlc2NyaXB0b3I1LCBfZGVzY3JpcHRvcjYsIF9kZXNjcmlwdG9yNywgX2Rlc2NyaXB0b3I4LCBfZGVzY3JpcHRvcjksIF9kZXNjcmlwdG9yMTA7XG5cbmZ1bmN0aW9uIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2NyaXB0b3IsIGNvbnRleHQpIHsgaWYgKCFkZXNjcmlwdG9yKSByZXR1cm47IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCB7IGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSwgY29uZmlndXJhYmxlOiBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSwgd3JpdGFibGU6IGRlc2NyaXB0b3Iud3JpdGFibGUsIHZhbHVlOiBkZXNjcmlwdG9yLmluaXRpYWxpemVyID8gZGVzY3JpcHRvci5pbml0aWFsaXplci5jYWxsKGNvbnRleHQpIDogdm9pZCAwIH0pOyB9XG5cbmZ1bmN0aW9uIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVjb3JhdG9ycywgZGVzY3JpcHRvciwgY29udGV4dCkgeyB2YXIgZGVzYyA9IHt9OyBPYmplY3Qua2V5cyhkZXNjcmlwdG9yKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZGVzY1trZXldID0gZGVzY3JpcHRvcltrZXldOyB9KTsgZGVzYy5lbnVtZXJhYmxlID0gISFkZXNjLmVudW1lcmFibGU7IGRlc2MuY29uZmlndXJhYmxlID0gISFkZXNjLmNvbmZpZ3VyYWJsZTsgaWYgKCd2YWx1ZScgaW4gZGVzYyB8fCBkZXNjLmluaXRpYWxpemVyKSB7IGRlc2Mud3JpdGFibGUgPSB0cnVlOyB9IGRlc2MgPSBkZWNvcmF0b3JzLnNsaWNlKCkucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbiAoZGVzYywgZGVjb3JhdG9yKSB7IHJldHVybiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYykgfHwgZGVzYzsgfSwgZGVzYyk7IGlmIChjb250ZXh0ICYmIGRlc2MuaW5pdGlhbGl6ZXIgIT09IHZvaWQgMCkgeyBkZXNjLnZhbHVlID0gZGVzYy5pbml0aWFsaXplciA/IGRlc2MuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMDsgZGVzYy5pbml0aWFsaXplciA9IHVuZGVmaW5lZDsgfSBpZiAoZGVzYy5pbml0aWFsaXplciA9PT0gdm9pZCAwKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjKTsgZGVzYyA9IG51bGw7IH0gcmV0dXJuIGRlc2M7IH1cblxuZnVuY3Rpb24gX2luaXRpYWxpemVyV2FybmluZ0hlbHBlcihkZXNjcmlwdG9yLCBjb250ZXh0KSB7IHRocm93IG5ldyBFcnJvcignRGVjb3JhdGluZyBjbGFzcyBwcm9wZXJ0eSBmYWlsZWQuIFBsZWFzZSBlbnN1cmUgdGhhdCAnICsgJ3Byb3Bvc2FsLWNsYXNzLXByb3BlcnRpZXMgaXMgZW5hYmxlZCBhbmQgcnVucyBhZnRlciB0aGUgZGVjb3JhdG9ycyB0cmFuc2Zvcm0uJyk7IH1cblxubGV0IER5Z3JhcGhjaGFydCA9IChfY2xhc3MgPSBjbGFzcyBEeWdyYXBoY2hhcnQge1xuICAvL3RpbWUgdG8gdGhyb3R0bGUgY2hhcnQgdXBkYXRlLCBpZiBpdCBpcyB0b28gbXVjaCBhdCBvbmNlXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwid2lkdGhcIiwgX2Rlc2NyaXB0b3IsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJoZWlnaHRcIiwgX2Rlc2NyaXB0b3IyLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5wdXRzXCIsIF9kZXNjcmlwdG9yMywgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZyb21pZFwiLCBfZGVzY3JpcHRvcjQsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhkYXRhXCIsIF9kZXNjcmlwdG9yNSwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZmluZGV4XCIsIF9kZXNjcmlwdG9yNiwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZnZhbHVlc1wiLCBfZGVzY3JpcHRvcjcsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aHJvdHRsZVwiLCBfZGVzY3JpcHRvcjgsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJjb252ZXJ0b3JzXCIsIF9kZXNjcmlwdG9yOSwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1pbmljaGFydFwiLCBfZGVzY3JpcHRvcjEwLCB0aGlzKTtcblxuICAgIHRoaXMuaW5pdGlhbGRhdGEgPSB0cnVlO1xuICAgIHRoaXMucmVmaW5kaWNlcyA9IG51bGw7XG4gICAgdGhpcy54eSA9IGZhbHNlO1xuICAgIHRoaXMub3BlcmF0aW9uID0gbnVsbDtcbiAgICAvL3RoaXMuZGF0YSA9IFtbMCwgMCwgMF1dO1xuICAgIC8vdGhpcy5kYXRhPVtbMSwgNV0sIFsyLCA1XSwgWzMsIDQuOV0sIFs0LCA0LjhdLCBbNSwgNS4yXV07XG4gICAgLy9jcmVhdGUgbGFtYmRhIGZ1bmN0aW9uIHdoaWNoIGlzIGFkZGVkIGFzIGxpc3RlbmVyIGxhdGVyXG4gICAgY29uc29sZS5sb2coJ2R5Z3JhcGggY2hhcnQgY29uc3RydWN0b3InKTtcblxuICAgIHRoaXMuaGFuZGxlVmFsdWVDaGFuZ2UgPSBlID0+IHtcbiAgICAgIGxldCBkYXRhcG9pbnQgPSBbXTtcbiAgICAgIGlmICghdGhpcy54eSkgZGF0YXBvaW50LnB1c2goZS5kZXRhaWwudGltZSk7IC8vZS5kZXRhaWwgZG8gbm90IHJlYWxsb2NhdGUgLSB1c2luZyBzYW1lIGJ1ZmZlciwgdGh1cyBzbGljaW5nIHRvIGFwcGVuZCB0byBkYXRhIGFycmF5XG5cbiAgICAgIGxldCBlZGF0YSA9IGUuZGV0YWlsLmRhdGEuc2xpY2UoKTtcbiAgICAgIGxldCBvcGluZGV4ID0gMDtcblxuICAgICAgaWYgKHRoaXMucmVmaW5kaWNlcykge1xuICAgICAgICBmb3IgKGxldCBteWluZGV4IG9mIHRoaXMucmVmaW5kaWNlcykge1xuICAgICAgICAgIGlmICh0aGlzLm9wZXJhdGlvbikge1xuICAgICAgICAgICAgZGF0YXBvaW50LnB1c2godGhpcy5vcGVyYXRpb25bb3BpbmRleF0oZWRhdGFbbXlpbmRleF0pKTtcbiAgICAgICAgICAgIG9waW5kZXgrKztcbiAgICAgICAgICB9IGVsc2UgZGF0YXBvaW50LnB1c2goZWRhdGFbbXlpbmRleF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5yZWZpbmRleDsgaSA8IHRoaXMucmVmaW5kZXggKyB0aGlzLnJlZnZhbHVlczsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3BlcmF0aW9uKSB7XG4gICAgICAgICAgICBkYXRhcG9pbnQucHVzaCh0aGlzLm9wZXJhdGlvbltvcGluZGV4XShlZGF0YVtpXSkpO1xuICAgICAgICAgICAgb3BpbmRleCsrO1xuICAgICAgICAgIH0gZWxzZSBkYXRhcG9pbnQucHVzaChlZGF0YVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaW5pdGlhbGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIHRoaXMuaW5pdGlhbGRhdGEgPSBmYWxzZTtcbiAgICAgIH0gLy9kYXRhcG9pbnRcblxuXG4gICAgICB0aGlzLmRhdGEucHVzaChkYXRhcG9pbnQpOyAvL3NoaWZ0IC0gcmVtb3ZlIGZpcnN0IGVsZW1lbnQgaWYgZGF0YSBpcyB0b28gYmlnXG5cbiAgICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoID4gdGhpcy5tYXhkYXRhKSB0aGlzLmRhdGEuc2hpZnQoKTsgLy9jb25zb2xlLmxvZygnRHlncmFwaGNoYXIgZGF0YScsIHRoaXMuZGF0YSk7XG5cbiAgICAgIHRoaXMudXBkYXRlY2hhcnQoKTsgLy90aGlzLmR5Z3JhcGgudXBkYXRlT3B0aW9ucyggeyAnZmlsZSc6IHRoaXMuZGF0YSB9ICk7XG4gICAgfTtcblxuICAgIHRoaXMuaGFuZGxlUmVzZXQgPSBlID0+IHtcbiAgICAgIHRoaXMucmVzZXRkYXRhKCk7XG4gICAgICB0aGlzLnVwZGF0ZWNoYXJ0KCk7IC8vdGhpcy5keWdyYXBoLnVwZGF0ZU9wdGlvbnMoIHsgJ2ZpbGUnOiB0aGlzLmRhdGEgfSApO1xuICAgIH07XG4gIH1cblxuICB1cGRhdGVjaGFydGZuKCkge1xuICAgIHRoaXMuZHlncmFwaC51cGRhdGVPcHRpb25zKHtcbiAgICAgICdmaWxlJzogdGhpcy5kYXRhXG4gICAgfSk7XG4gIH1cblxuICByZXNldGRhdGEoKSB7XG4gICAgdGhpcy5kYXRhID0gW107XG4gICAgbGV0IGluaXRkYXRhcG9pbnQgPSBBcnJheShwYXJzZUludCh0aGlzLnJlZnZhbHVlcywgMTApICsgMSkuZmlsbCgwKTtcbiAgICB0aGlzLmRhdGEucHVzaChpbml0ZGF0YXBvaW50KTtcbiAgICB0aGlzLmluaXRpYWxkYXRhID0gdHJ1ZTtcbiAgfVxuXG4gIGJpbmQoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm1pbmljaGFydCA9PT0gJ3N0cmluZycpIHRoaXMubWluaWNoYXJ0ID0gdGhpcy5taW5pY2hhcnQgPT09ICd0cnVlJztcbiAgfVxuXG4gIGF0dGFjaGVkKCkge1xuICAgIC8vbGlzdGVuaW5nIHRvIGN1c3RvbSBldmVudCBmbWlkYXRhXG4gICAgY29uc29sZS5sb2coJ2R5Z3JhcGggYXR0YWNoZWQnKTtcbiAgICBpZiAodGhpcy5yZWZpbmRleCAmJiB0aGlzLnJlZmluZGV4LmluZGV4T2YoJywnKSA+IDApIHRoaXMucmVmaW5kaWNlcyA9IHRoaXMucmVmaW5kZXguc3BsaXQoJywnKTtcbiAgICBsZXQgZm1pZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZnJvbWlkKTtcblxuICAgIGlmIChmbWllbGVtZW50KSB7XG4gICAgICBmbWllbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZtaWRhdGEnLCB0aGlzLmhhbmRsZVZhbHVlQ2hhbmdlKTtcbiAgICAgIGZtaWVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm1pcmVzZXQnLCB0aGlzLmhhbmRsZVJlc2V0KTtcbiAgICB9IC8vbGFiZWxzIGFyZSBzZXBhcmF0ZWQgYnkgLCBpbiBhdHRyaWJ1dGUgaW5wdXRzXG4gICAgLy9jb25zb2xlLmxvZygnQmRsRHlncmFwaGNoYXJ0IGF0dGFjaGVkIGlucHV0cycsIHRoaXMuaW5wdXRzKTtcblxuXG4gICAgdGhpcy5sYWJlbHMgPSB0aGlzLmlucHV0cyA/IHRoaXMuaW5wdXRzLnNwbGl0KCcsJykgOiBbXTsgLy9jb25zb2xlLmxvZygnQmRsRHlncmFwaGNoYXJ0IGF0dGFjaGVkIGxhYmVscycsIGxhYmVscyk7XG4gICAgLy9jcmVhdGUgZHlncmFwaFxuXG4gICAgdGhpcy5yZXNldGRhdGEoKTsgLy9jb25zb2xlLmxvZygnQmRsRHlncmFwaGNoYXJ0IGF0dGFjaGVkIGluaXRpYWwgZGF0YSBpbml0IGRhdGEnLCBpbml0ZGF0YXBvaW50LCAnIGRhdGE6JywgdGhpcy5kYXRhKTtcblxuICAgIHRoaXMuaW5pdGR5Z3JhcGgoKTtcbiAgICAvKmRhdGEucHVzaChbeCwgeV0pO1xuICAgIGcudXBkYXRlT3B0aW9ucyggeyAnZmlsZSc6IGRhdGEgfSApOyovXG4gICAgLy9yZWdpc3RlciB0aHJvdHRsZWQgdXBkYXRlIGZ1bmN0aW9uXG5cbiAgICBpZiAodHlwZW9mIHRoaXMudGhyb3R0bGUgPT09ICdzdHJpbmcnKSB0aGlzLnRocm90dGxlID0gcGFyc2VJbnQodGhpcy50aHJvdHRsZSwgMTApO1xuXG4gICAgaWYgKHRoaXMudGhyb3R0bGUgPiAwKSB7XG4gICAgICAvL3Rocm90dGxlXG4gICAgICB0aGlzLnVwZGF0ZWNoYXJ0ID0gXy50aHJvdHRsZSh0aGlzLnVwZGF0ZWNoYXJ0Zm4uYmluZCh0aGlzKSwgdGhpcy50aHJvdHRsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vZGlyZWN0bHkgY2FsbCBjaGFydCB1cGRhdGVcbiAgICAgIHRoaXMudXBkYXRlY2hhcnQgPSB0aGlzLnVwZGF0ZWNoYXJ0Zm4uYmluZCh0aGlzKTtcbiAgICB9IC8vY29uZmlndXJlIGNvbnZlcnRvcnMgLSB1c2VkIHRvIGNvbnZlcnQgdW5pdHMgcmVjZWl2ZWQgZnJvbSBmbWlcblxuXG4gICAgaWYgKHRoaXMuY29udmVydG9ycykge1xuICAgICAgbGV0IGNvbnZlcnR2YWx1ZXMgPSB0aGlzLmNvbnZlcnRvcnMuc3BsaXQoJzsnKTtcblxuICAgICAgbGV0IGlkZW50aXR5ID0geCA9PiB4O1xuXG4gICAgICB0aGlzLm9wZXJhdGlvbiA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnZlcnR2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGNvbnZlcnR2YWx1ZXNbaV0uaW5jbHVkZXMoJywnKSkge1xuICAgICAgICAgIC8vY29udmVydCB2YWx1ZXMgYXJlIGluIGZvcm0gbnVtZXJhdG9yLGRlbm9taW5hdG9yIGNvbnRhaW5zIGNvbW1hICcsJ1xuICAgICAgICAgIGxldCBjb252ZXJ0aXRlbXMgPSBjb252ZXJ0dmFsdWVzW2ldLnNwbGl0KCcsJyk7XG4gICAgICAgICAgaWYgKGNvbnZlcnRpdGVtc1swXSA9PT0gJzEnICYmIGNvbnZlcnRpdGVtc1sxXSA9PT0gJzEnKSB0aGlzLm9wZXJhdGlvbi5wdXNoKGlkZW50aXR5KTtlbHNlIHtcbiAgICAgICAgICAgIGxldCBudW1lcmF0b3IgPSBwYXJzZUZsb2F0KGNvbnZlcnRpdGVtc1swXSk7XG4gICAgICAgICAgICBsZXQgZGVub21pbmF0b3IgPSBwYXJzZUZsb2F0KGNvbnZlcnRpdGVtc1sxXSk7XG4gICAgICAgICAgICBsZXQgYWRkZW5kID0gY29udmVydGl0ZW1zLmxlbmd0aCA+IDIgPyBwYXJzZUZsb2F0KGNvbnZlcnRpdGVtc1syXSkgOiAwO1xuICAgICAgICAgICAgdGhpcy5vcGVyYXRpb24ucHVzaCh4ID0+IHggKiBudW1lcmF0b3IgLyBkZW5vbWluYXRvciArIGFkZGVuZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vY29udmVydCB2YWx1ZXMgYXJlIGluIGZvcm0gb2YgZXhwcmVzc2lvbiwgZG8gbm90IGNvbnRhaW4gY29tbWFcbiAgICAgICAgICBpZiAoY29udmVydHZhbHVlcyA9PT0gJzEveCcpIHRoaXMub3BlcmF0aW9uLnB1c2goeCA9PiAxIC8geCk7ZWxzZSB7XG4gICAgICAgICAgICAvLyBmb3IgZXZhbCgpIHNlY3VyaXR5IGZpbHRlciBvbmx5IGFsbG93ZWQgY2hhcmFjdGVyczpcbiAgICAgICAgICAgIC8vIGFsZ2VicmFpYywgZGlnaXRzLCBlLCBkb3QsIG1vZHVsbywgcGFyZW50aGVzaXMgYW5kICd4JyBhbmQgJ2UnIGlzIGFsbG93ZWRcbiAgICAgICAgICAgIGxldCBleHByZXNzaW9uID0gY29udmVydHZhbHVlc1tpXS5yZXBsYWNlKC9bXi1cXGQvKisuKCkleGVdL2csICcnKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjaGFydGpzIGJpbmQoKSwgZXZhbHVhdGluZyBleHByZXNzaW9uOicgKyBjb252ZXJ0dmFsdWVzW2ldICsgJyBzZWN1cmVseSBmaWx0ZXJlZCB0byA6JyArIGV4cHJlc3Npb24pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXZhbFxuXG4gICAgICAgICAgICB0aGlzLm9wZXJhdGlvbi5wdXNoKHggPT4gZXZhbChleHByZXNzaW9uKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW5pdGR5Z3JhcGgoKSB7XG4gICAgLy9jb25zb2xlLmxvZygnaW5pdGR5Z3JhcGg6JyxEeWdyYXBoKTtcbiAgICB0aGlzLmR5Z3JhcGggPSBuZXcgX2R5Z3JhcGguRHlncmFwaCh0aGlzLmR5Z3JhcGhjYW52YXMsIHRoaXMuZGF0YSwge1xuICAgICAgLy9EcmF3IGEgc21hbGwgZG90IGF0IGVhY2ggcG9pbnRcbiAgICAgIGRyYXdQb2ludHM6IHRydWUsXG4gICAgICAvL3JvbGxpbmcgYXZlcmFnZSBwZXJpb2QgdGV4dCBib3ggdG8gYmUgc2hvd1xuICAgICAgLy9zaG93Um9sbGVyOiB0cnVlLFxuICAgICAgLy9jdXN0b21CYXJzIGlmIHNlcmllcyBpcyBsb3c7bWlkZGxlO2hpZ2ggd2hlcmUgcmFuZ2UgYmV0d2VlbiBsb3cgYW5kIGhpZ2ggaXMgdmlzdWFsaXNlZFxuICAgICAgLy9jdXN0b21CYXJzOiB0cnVlLFxuICAgICAgLy9yYW5nZSBzZWxlY3RvclxuICAgICAgLy9zaG93UmFuZ2VTZWxlY3RvcjogdHJ1ZSxcbiAgICAgIGxhYmVsczogdGhpcy5sYWJlbHNcbiAgICB9KTtcbiAgfVxuXG4gIGRldGFjaGVkKCkge1xuICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmZyb21pZCkpIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZnJvbWlkKS5yZW1vdmVFdmVudExpc3RlbmVyKCdmbWlkYXRhJywgdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZSk7XG4gICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZnJvbWlkKSkgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5mcm9taWQpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZtaXJlc2V0JywgdGhpcy5oYW5kbGVSZXNldCk7XG4gIH1cblxuICBkb3dubG9hZCgpIHtcbiAgICBsZXQgZmlsZW5hbWUgPSBwcm9tcHQoJ0ZpbGUgbmFtZSAoKi5jc3YpOicsICdkYXRhLmNzdicpO1xuXG4gICAgaWYgKGZpbGVuYW1lKSB7XG4gICAgICBpZiAoIWZpbGVuYW1lLmVuZHNXaXRoKCcuY3N2JykpIGZpbGVuYW1lID0gZmlsZW5hbWUuY29uY2F0KCcuY3N2Jyk7XG4gICAgICBsZXQgY29udGVudCA9IHRoaXMuaW5wdXRzICsgJ1xcbicgKyB0aGlzLmRhdGEubWFwKGUgPT4gZS5qb2luKCcsJykpLmpvaW4oJ1xcbicpO1xuICAgICAgbGV0IGJsb2IgPSBuZXcgQmxvYihbY29udGVudF0sIHtcbiAgICAgICAgdHlwZTogJ3RleHQvY3N2O2NoYXJzZXQ9dXRmLTg7J1xuICAgICAgfSk7XG4gICAgICAoMCwgX2ZpbGVTYXZlci5zYXZlQXMpKGJsb2IsIGZpbGVuYW1lKTtcbiAgICB9XG4gIH1cblxuICBwcmV2aWV3KCkge1xuICAgIGxldCBjb250ZW50ID0gdGhpcy5pbnB1dHMgKyAnXFxuJyArIHRoaXMuZGF0YS5tYXAoZSA9PiBlLmpvaW4oJywnKSkuam9pbignXFxuJyk7XG4gICAgbGV0IGJsb2IgPSBuZXcgQmxvYihbY29udGVudF0sIHtcbiAgICAgIHR5cGU6ICd0ZXh0L2NzdjtjaGFyc2V0PXV0Zi04OydcbiAgICB9KTtcbiAgICBsZXQgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICB0aGlzLnBvcHVwID0gd2luZG93Lm9wZW4odXJsLCAnQm9keWxpZ2h0UHJldmlldycsICd3aWR0aD04MDAsaGVpZ2h0PTYwMCxtZW51YmFyPW5vLHN0YXR1cz1ubyx0aXRsZWJhcj1ubyx0b29sYmFyPW5vJyk7XG4gIH1cblxufSwgKF9kZXNjcmlwdG9yID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcIndpZHRoXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjIgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjMgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiaW5wdXRzXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjQgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiZnJvbWlkXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjUgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwibWF4ZGF0YVwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDMwMDtcbiAgfVxufSksIF9kZXNjcmlwdG9yNiA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJyZWZpbmRleFwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I3ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcInJlZnZhbHVlc1wiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjggPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwidGhyb3R0bGVcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAyMDA7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjkgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiY29udmVydG9yc1wiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3IxMCA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJtaW5pY2hhcnRcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSkpLCBfY2xhc3MpO1xuZXhwb3J0cy5EeWdyYXBoY2hhcnQgPSBEeWdyYXBoY2hhcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1keWdyYXBoY2hhcnQuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/dygraphchart\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/dygraphchart.html":
/*!**********************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/dygraphchart.html ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template bindable=\\\"width,height,minichart\\\">   <!--other attributes @bindable inputs;  @bindable fromid;  @bindable maxdata=300;-->\\n  <div class=\\\"w3-container\\\">\\n    <span show.bind=\\\"! minichart\\\" class=\\\"w3-small\\\">\\n      <i class=\\\"fa fa-download w3-border\\\" title=\\\"download csv data\\\" click.delegate=\\\"download()\\\"></i>      \\n    </span>\\n  <div ref=\\\"dygraphcanvas\\\"  css=\\\"width: ${width}px; height: ${height}px;\\\"></div>\\n  </div>\\n</template>\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2R5Z3JhcGhjaGFydC5odG1sLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F1cmVsaWEtYm9keWxpZ2h0LXBsdWdpbi9kaXN0L25hdGl2ZS1tb2R1bGVzL2VsZW1lbnRzL2R5Z3JhcGhjaGFydC5odG1sPzdlMTgiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIjx0ZW1wbGF0ZSBiaW5kYWJsZT1cXFwid2lkdGgsaGVpZ2h0LG1pbmljaGFydFxcXCI+ICAgPCEtLW90aGVyIGF0dHJpYnV0ZXMgQGJpbmRhYmxlIGlucHV0czsgIEBiaW5kYWJsZSBmcm9taWQ7ICBAYmluZGFibGUgbWF4ZGF0YT0zMDA7LS0+XFxuICA8ZGl2IGNsYXNzPVxcXCJ3My1jb250YWluZXJcXFwiPlxcbiAgICA8c3BhbiBzaG93LmJpbmQ9XFxcIiEgbWluaWNoYXJ0XFxcIiBjbGFzcz1cXFwidzMtc21hbGxcXFwiPlxcbiAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1kb3dubG9hZCB3My1ib3JkZXJcXFwiIHRpdGxlPVxcXCJkb3dubG9hZCBjc3YgZGF0YVxcXCIgY2xpY2suZGVsZWdhdGU9XFxcImRvd25sb2FkKClcXFwiPjwvaT4gICAgICBcXG4gICAgPC9zcGFuPlxcbiAgPGRpdiByZWY9XFxcImR5Z3JhcGhjYW52YXNcXFwiICBjc3M9XFxcIndpZHRoOiAke3dpZHRofXB4OyBoZWlnaHQ6ICR7aGVpZ2h0fXB4O1xcXCI+PC9kaXY+XFxuICA8L2Rpdj5cXG48L3RlbXBsYXRlPlxcblwiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/dygraphchart.html\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/ecg":
/*!***********************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/ecg.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.Ecg = void 0;\n\nvar _chartjsTime = __webpack_require__(/*! ./chartjs-time */ \"aurelia-bodylight-plugin/elements/chartjs-time\");\n\nvar _aureliaTemplating = __webpack_require__(/*! aurelia-templating */ \"hij8\");\n\nvar _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6;\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\n//import {PLATFORM} from 'aurelia-pal';\n//@useView(PLATFORM.moduleName('./bdl-chartjs.html'))\nlet Ecg = (_dec = (0, _aureliaTemplating.useView)('./chartjs.html'), _dec(_class = (_class2 = class Ecg extends _chartjsTime.ChartjsTime {\n  //2 * 5*8 ecgvalues = 2 cardiac cycles\n  //@bindable refindex;\n  //  @bindable refvalues;\n  //initiate\n  // ]; //values in mV in segments\n  //ecgvalueslbb=[]\n  //labels related to values\n  constructor() {\n    super();\n\n    _initializerDefineProperty(this, \"fromid\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"labels\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"maxdata\", _descriptor3, this);\n\n    this.refindex = 0;\n    this.refvalues = 1;\n    this.previousreltime = 0;\n\n    _initializerDefineProperty(this, \"type\", _descriptor4, this);\n\n    this.ecgvalues = [[0.2, 0.12, 0, 0, 0, 0, -0.1, 1.4], //4b\n    [-0.5, 0, 0, 0, 0, 0, 0, 0], //1\n    [0, 0, 0, 0, 0.15, 0.28, 0.35, 0.38], //2\n    [0.38, 0.35, 0.28, 0.15, 0, 0, 0, 0], //3\n    [0, 0, 0, 0, 0, 0, 0.12, 0.2] //4a\n    ];\n    this.ecglabels = [['P', '', '', '', '', '', 'Q', 'R'], //4b\n    ['S', '', '', '', '', '', '', ''], //1\n    ['', '', '', '', '', '', '', 'T'], //2\n    ['', '', '', '', '', '', '', ''], //3\n    ['', '', '', '', '', '', '', 'P'] //4a\n    ];\n    this.ecgindex = 0;\n    this.ecgsegment = 1;\n\n    _initializerDefineProperty(this, \"width\", _descriptor5, this);\n\n    _initializerDefineProperty(this, \"height\", _descriptor6, this);\n\n    console.log('BdlEcg()'); //this.type = 'line';\n    //need to define method here in order to register it for eventlistener later\n\n    this.handleValueChange = e => {\n      this.handleValueChangeImpl(e);\n    };\n  }\n\n  bind() {\n    super.bind();\n    this.datalabels = true; //disable labels on xaxes\n\n    this.options.scales.xAxes = [{\n      ticks: {\n        display: false\n      }\n    }];\n  }\n\n  attached() {\n    super.attached();\n    let fromidel = document.getElementById(this.fromid);\n\n    if (fromidel) {\n      fromidel.addEventListener('animatedata', this.handleValueChange);\n    } //instantiate datalabels\n\n\n    if (!this.chart.data.datasets[0].datalabels) this.chart.data.datasets[0].datalabels = [];\n  }\n\n  detached() {\n    super.detached();\n\n    if (document.getElementById(this.fromid)) {\n      document.getElementById(this.fromid).removeEventListener('animatedata', this.handleValueChange);\n    }\n  }\n\n  handleValueChangeImpl(e) {\n    console.log('bdl-ecg handlevaluechange e.detail', e.detail);\n    let mysegment = e.detail.segment;\n    let myreltime = e.detail.relativetime; //reset index if new segment\n\n    if (this.currentsegment !== mysegment) {\n      //reset index\n      this.previousindex = 0;\n      this.index = 0;\n      this.currentsegment = mysegment;\n      this.previousreltime = 0; //TODO draw points from previous segments - if not already drawn\n    } else {\n      this.previousindex = this.index;\n    } //count difference in this step\n\n\n    let rd = myreltime - this.previousreltime; //e.g. 0.33 of segments\n    //count how many points of ECG to draw - >1 -\n\n    let npoints = Math.round(this.ecgvalues[mysegment].length * rd);\n    this.index += npoints; //set previousreltime to current points of time used\n\n    this.previousreltime = this.previousreltime + npoints / this.ecgvalues[mysegment].length; //TODO push multiple values - per percent in current segment - or do approximation\n    //push multiple values - if in ecgvalues\n\n    console.log('bdl-ecg handlevaluechange npoints,previndex,index:', npoints, this.previousindex, this.index);\n\n    if (npoints > 0) {\n      this.chart.data.datasets[0].data.push(...this.ecgvalues[mysegment].slice(this.previousindex, this.index));\n      this.chart.data.datasets[0].datalabels.push(...this.ecglabels[mysegment].slice(this.previousindex, this.index)); //push npoints times the 'time' label\n\n      this.chart.data.labels.push(...Array(npoints).fill(e.detail.time)); //shift\n\n      if (this.chart.data.datasets[0].data.length > this.maxdata) {\n        //console.log('shifting dataset chartjs-time', this.chart.data.datasets[j].data);\n        let pointstoremove = this.chart.data.datasets[0].data.length - this.maxdata;\n        this.chart.data.datasets[0].data.splice(0, pointstoremove);\n        this.chart.data.datasets[0].datalabels.splice(0, pointstoremove);\n        this.chart.data.labels.splice(0, pointstoremove);\n      }\n    } //shift - remove first element if data is too big\n    //console.log('chartjs handlevaluechange() chart.data.datasets[0].data', this.chart.data.datasets[0].data);\n\n\n    this.chart.update(0);\n  }\n\n}, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"fromid\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"labels\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 'ECG I (mV)';\n  }\n}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, \"maxdata\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 80;\n  }\n}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, \"type\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, \"width\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return '300';\n  }\n}), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, \"height\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return '50';\n  }\n})), _class2)) || _class);\nexports.Ecg = Ecg;\n//# sourceMappingURL=ecg.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2VjZy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLWJvZHlsaWdodC1wbHVnaW4vZGlzdC9uYXRpdmUtbW9kdWxlcy9lbGVtZW50cy9lY2cuanM/OTA0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuRWNnID0gdm9pZCAwO1xuXG52YXIgX2NoYXJ0anNUaW1lID0gcmVxdWlyZShcIi4vY2hhcnRqcy10aW1lXCIpO1xuXG52YXIgX2F1cmVsaWFUZW1wbGF0aW5nID0gcmVxdWlyZShcImF1cmVsaWEtdGVtcGxhdGluZ1wiKTtcblxudmFyIF9kZWMsIF9jbGFzcywgX2NsYXNzMiwgX2Rlc2NyaXB0b3IsIF9kZXNjcmlwdG9yMiwgX2Rlc2NyaXB0b3IzLCBfZGVzY3JpcHRvcjQsIF9kZXNjcmlwdG9yNSwgX2Rlc2NyaXB0b3I2O1xuXG5mdW5jdGlvbiBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7IGlmICghZGVzY3JpcHRvcikgcmV0dXJuOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgeyBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsIHdyaXRhYmxlOiBkZXNjcmlwdG9yLndyaXRhYmxlLCB2YWx1ZTogZGVzY3JpcHRvci5pbml0aWFsaXplciA/IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMCB9KTsgfVxuXG5mdW5jdGlvbiBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHksIGRlY29yYXRvcnMsIGRlc2NyaXB0b3IsIGNvbnRleHQpIHsgdmFyIGRlc2MgPSB7fTsgT2JqZWN0LmtleXMoZGVzY3JpcHRvcikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGRlc2Nba2V5XSA9IGRlc2NyaXB0b3Jba2V5XTsgfSk7IGRlc2MuZW51bWVyYWJsZSA9ICEhZGVzYy5lbnVtZXJhYmxlOyBkZXNjLmNvbmZpZ3VyYWJsZSA9ICEhZGVzYy5jb25maWd1cmFibGU7IGlmICgndmFsdWUnIGluIGRlc2MgfHwgZGVzYy5pbml0aWFsaXplcikgeyBkZXNjLndyaXRhYmxlID0gdHJ1ZTsgfSBkZXNjID0gZGVjb3JhdG9ycy5zbGljZSgpLnJldmVyc2UoKS5yZWR1Y2UoZnVuY3Rpb24gKGRlc2MsIGRlY29yYXRvcikgeyByZXR1cm4gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHksIGRlc2MpIHx8IGRlc2M7IH0sIGRlc2MpOyBpZiAoY29udGV4dCAmJiBkZXNjLmluaXRpYWxpemVyICE9PSB2b2lkIDApIHsgZGVzYy52YWx1ZSA9IGRlc2MuaW5pdGlhbGl6ZXIgPyBkZXNjLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDA7IGRlc2MuaW5pdGlhbGl6ZXIgPSB1bmRlZmluZWQ7IH0gaWYgKGRlc2MuaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYyk7IGRlc2MgPSBudWxsOyB9IHJldHVybiBkZXNjOyB9XG5cbmZ1bmN0aW9uIF9pbml0aWFsaXplcldhcm5pbmdIZWxwZXIoZGVzY3JpcHRvciwgY29udGV4dCkgeyB0aHJvdyBuZXcgRXJyb3IoJ0RlY29yYXRpbmcgY2xhc3MgcHJvcGVydHkgZmFpbGVkLiBQbGVhc2UgZW5zdXJlIHRoYXQgJyArICdwcm9wb3NhbC1jbGFzcy1wcm9wZXJ0aWVzIGlzIGVuYWJsZWQgYW5kIHJ1bnMgYWZ0ZXIgdGhlIGRlY29yYXRvcnMgdHJhbnNmb3JtLicpOyB9XG5cbi8vaW1wb3J0IHtQTEFURk9STX0gZnJvbSAnYXVyZWxpYS1wYWwnO1xuLy9AdXNlVmlldyhQTEFURk9STS5tb2R1bGVOYW1lKCcuL2JkbC1jaGFydGpzLmh0bWwnKSlcbmxldCBFY2cgPSAoX2RlYyA9ICgwLCBfYXVyZWxpYVRlbXBsYXRpbmcudXNlVmlldykoJy4vY2hhcnRqcy5odG1sJyksIF9kZWMoX2NsYXNzID0gKF9jbGFzczIgPSBjbGFzcyBFY2cgZXh0ZW5kcyBfY2hhcnRqc1RpbWUuQ2hhcnRqc1RpbWUge1xuICAvLzIgKiA1KjggZWNndmFsdWVzID0gMiBjYXJkaWFjIGN5Y2xlc1xuICAvL0BiaW5kYWJsZSByZWZpbmRleDtcbiAgLy8gIEBiaW5kYWJsZSByZWZ2YWx1ZXM7XG4gIC8vaW5pdGlhdGVcbiAgLy8gXTsgLy92YWx1ZXMgaW4gbVYgaW4gc2VnbWVudHNcbiAgLy9lY2d2YWx1ZXNsYmI9W11cbiAgLy9sYWJlbHMgcmVsYXRlZCB0byB2YWx1ZXNcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwiZnJvbWlkXCIsIF9kZXNjcmlwdG9yLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwibGFiZWxzXCIsIF9kZXNjcmlwdG9yMiwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heGRhdGFcIiwgX2Rlc2NyaXB0b3IzLCB0aGlzKTtcblxuICAgIHRoaXMucmVmaW5kZXggPSAwO1xuICAgIHRoaXMucmVmdmFsdWVzID0gMTtcbiAgICB0aGlzLnByZXZpb3VzcmVsdGltZSA9IDA7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgX2Rlc2NyaXB0b3I0LCB0aGlzKTtcblxuICAgIHRoaXMuZWNndmFsdWVzID0gW1swLjIsIDAuMTIsIDAsIDAsIDAsIDAsIC0wLjEsIDEuNF0sIC8vNGJcbiAgICBbLTAuNSwgMCwgMCwgMCwgMCwgMCwgMCwgMF0sIC8vMVxuICAgIFswLCAwLCAwLCAwLCAwLjE1LCAwLjI4LCAwLjM1LCAwLjM4XSwgLy8yXG4gICAgWzAuMzgsIDAuMzUsIDAuMjgsIDAuMTUsIDAsIDAsIDAsIDBdLCAvLzNcbiAgICBbMCwgMCwgMCwgMCwgMCwgMCwgMC4xMiwgMC4yXSAvLzRhXG4gICAgXTtcbiAgICB0aGlzLmVjZ2xhYmVscyA9IFtbJ1AnLCAnJywgJycsICcnLCAnJywgJycsICdRJywgJ1InXSwgLy80YlxuICAgIFsnUycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnXSwgLy8xXG4gICAgWycnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnVCddLCAvLzJcbiAgICBbJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnXSwgLy8zXG4gICAgWycnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnUCddIC8vNGFcbiAgICBdO1xuICAgIHRoaXMuZWNnaW5kZXggPSAwO1xuICAgIHRoaXMuZWNnc2VnbWVudCA9IDE7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndpZHRoXCIsIF9kZXNjcmlwdG9yNSwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhlaWdodFwiLCBfZGVzY3JpcHRvcjYsIHRoaXMpO1xuXG4gICAgY29uc29sZS5sb2coJ0JkbEVjZygpJyk7IC8vdGhpcy50eXBlID0gJ2xpbmUnO1xuICAgIC8vbmVlZCB0byBkZWZpbmUgbWV0aG9kIGhlcmUgaW4gb3JkZXIgdG8gcmVnaXN0ZXIgaXQgZm9yIGV2ZW50bGlzdGVuZXIgbGF0ZXJcblxuICAgIHRoaXMuaGFuZGxlVmFsdWVDaGFuZ2UgPSBlID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlVmFsdWVDaGFuZ2VJbXBsKGUpO1xuICAgIH07XG4gIH1cblxuICBiaW5kKCkge1xuICAgIHN1cGVyLmJpbmQoKTtcbiAgICB0aGlzLmRhdGFsYWJlbHMgPSB0cnVlOyAvL2Rpc2FibGUgbGFiZWxzIG9uIHhheGVzXG5cbiAgICB0aGlzLm9wdGlvbnMuc2NhbGVzLnhBeGVzID0gW3tcbiAgICAgIHRpY2tzOiB7XG4gICAgICAgIGRpc3BsYXk6IGZhbHNlXG4gICAgICB9XG4gICAgfV07XG4gIH1cblxuICBhdHRhY2hlZCgpIHtcbiAgICBzdXBlci5hdHRhY2hlZCgpO1xuICAgIGxldCBmcm9taWRlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZnJvbWlkKTtcblxuICAgIGlmIChmcm9taWRlbCkge1xuICAgICAgZnJvbWlkZWwuYWRkRXZlbnRMaXN0ZW5lcignYW5pbWF0ZWRhdGEnLCB0aGlzLmhhbmRsZVZhbHVlQ2hhbmdlKTtcbiAgICB9IC8vaW5zdGFudGlhdGUgZGF0YWxhYmVsc1xuXG5cbiAgICBpZiAoIXRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhbGFiZWxzKSB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YWxhYmVscyA9IFtdO1xuICB9XG5cbiAgZGV0YWNoZWQoKSB7XG4gICAgc3VwZXIuZGV0YWNoZWQoKTtcblxuICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmZyb21pZCkpIHtcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZnJvbWlkKS5yZW1vdmVFdmVudExpc3RlbmVyKCdhbmltYXRlZGF0YScsIHRoaXMuaGFuZGxlVmFsdWVDaGFuZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVZhbHVlQ2hhbmdlSW1wbChlKSB7XG4gICAgY29uc29sZS5sb2coJ2JkbC1lY2cgaGFuZGxldmFsdWVjaGFuZ2UgZS5kZXRhaWwnLCBlLmRldGFpbCk7XG4gICAgbGV0IG15c2VnbWVudCA9IGUuZGV0YWlsLnNlZ21lbnQ7XG4gICAgbGV0IG15cmVsdGltZSA9IGUuZGV0YWlsLnJlbGF0aXZldGltZTsgLy9yZXNldCBpbmRleCBpZiBuZXcgc2VnbWVudFxuXG4gICAgaWYgKHRoaXMuY3VycmVudHNlZ21lbnQgIT09IG15c2VnbWVudCkge1xuICAgICAgLy9yZXNldCBpbmRleFxuICAgICAgdGhpcy5wcmV2aW91c2luZGV4ID0gMDtcbiAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgdGhpcy5jdXJyZW50c2VnbWVudCA9IG15c2VnbWVudDtcbiAgICAgIHRoaXMucHJldmlvdXNyZWx0aW1lID0gMDsgLy9UT0RPIGRyYXcgcG9pbnRzIGZyb20gcHJldmlvdXMgc2VnbWVudHMgLSBpZiBub3QgYWxyZWFkeSBkcmF3blxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByZXZpb3VzaW5kZXggPSB0aGlzLmluZGV4O1xuICAgIH0gLy9jb3VudCBkaWZmZXJlbmNlIGluIHRoaXMgc3RlcFxuXG5cbiAgICBsZXQgcmQgPSBteXJlbHRpbWUgLSB0aGlzLnByZXZpb3VzcmVsdGltZTsgLy9lLmcuIDAuMzMgb2Ygc2VnbWVudHNcbiAgICAvL2NvdW50IGhvdyBtYW55IHBvaW50cyBvZiBFQ0cgdG8gZHJhdyAtID4xIC1cblxuICAgIGxldCBucG9pbnRzID0gTWF0aC5yb3VuZCh0aGlzLmVjZ3ZhbHVlc1tteXNlZ21lbnRdLmxlbmd0aCAqIHJkKTtcbiAgICB0aGlzLmluZGV4ICs9IG5wb2ludHM7IC8vc2V0IHByZXZpb3VzcmVsdGltZSB0byBjdXJyZW50IHBvaW50cyBvZiB0aW1lIHVzZWRcblxuICAgIHRoaXMucHJldmlvdXNyZWx0aW1lID0gdGhpcy5wcmV2aW91c3JlbHRpbWUgKyBucG9pbnRzIC8gdGhpcy5lY2d2YWx1ZXNbbXlzZWdtZW50XS5sZW5ndGg7IC8vVE9ETyBwdXNoIG11bHRpcGxlIHZhbHVlcyAtIHBlciBwZXJjZW50IGluIGN1cnJlbnQgc2VnbWVudCAtIG9yIGRvIGFwcHJveGltYXRpb25cbiAgICAvL3B1c2ggbXVsdGlwbGUgdmFsdWVzIC0gaWYgaW4gZWNndmFsdWVzXG5cbiAgICBjb25zb2xlLmxvZygnYmRsLWVjZyBoYW5kbGV2YWx1ZWNoYW5nZSBucG9pbnRzLHByZXZpbmRleCxpbmRleDonLCBucG9pbnRzLCB0aGlzLnByZXZpb3VzaW5kZXgsIHRoaXMuaW5kZXgpO1xuXG4gICAgaWYgKG5wb2ludHMgPiAwKSB7XG4gICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YS5wdXNoKC4uLnRoaXMuZWNndmFsdWVzW215c2VnbWVudF0uc2xpY2UodGhpcy5wcmV2aW91c2luZGV4LCB0aGlzLmluZGV4KSk7XG4gICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YWxhYmVscy5wdXNoKC4uLnRoaXMuZWNnbGFiZWxzW215c2VnbWVudF0uc2xpY2UodGhpcy5wcmV2aW91c2luZGV4LCB0aGlzLmluZGV4KSk7IC8vcHVzaCBucG9pbnRzIHRpbWVzIHRoZSAndGltZScgbGFiZWxcblxuICAgICAgdGhpcy5jaGFydC5kYXRhLmxhYmVscy5wdXNoKC4uLkFycmF5KG5wb2ludHMpLmZpbGwoZS5kZXRhaWwudGltZSkpOyAvL3NoaWZ0XG5cbiAgICAgIGlmICh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YS5sZW5ndGggPiB0aGlzLm1heGRhdGEpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnc2hpZnRpbmcgZGF0YXNldCBjaGFydGpzLXRpbWUnLCB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbal0uZGF0YSk7XG4gICAgICAgIGxldCBwb2ludHN0b3JlbW92ZSA9IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhLmxlbmd0aCAtIHRoaXMubWF4ZGF0YTtcbiAgICAgICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGEuc3BsaWNlKDAsIHBvaW50c3RvcmVtb3ZlKTtcbiAgICAgICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGFsYWJlbHMuc3BsaWNlKDAsIHBvaW50c3RvcmVtb3ZlKTtcbiAgICAgICAgdGhpcy5jaGFydC5kYXRhLmxhYmVscy5zcGxpY2UoMCwgcG9pbnRzdG9yZW1vdmUpO1xuICAgICAgfVxuICAgIH0gLy9zaGlmdCAtIHJlbW92ZSBmaXJzdCBlbGVtZW50IGlmIGRhdGEgaXMgdG9vIGJpZ1xuICAgIC8vY29uc29sZS5sb2coJ2NoYXJ0anMgaGFuZGxldmFsdWVjaGFuZ2UoKSBjaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGEnLCB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YSk7XG5cblxuICAgIHRoaXMuY2hhcnQudXBkYXRlKDApO1xuICB9XG5cbn0sIChfZGVzY3JpcHRvciA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwiZnJvbWlkXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3IyID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJsYWJlbHNcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ0VDRyBJIChtViknO1xuICB9XG59KSwgX2Rlc2NyaXB0b3IzID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJtYXhkYXRhXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDgwO1xuICB9XG59KSwgX2Rlc2NyaXB0b3I0ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJ0eXBlXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I1ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnMzAwJztcbiAgfVxufSksIF9kZXNjcmlwdG9yNiA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICc1MCc7XG4gIH1cbn0pKSwgX2NsYXNzMikpIHx8IF9jbGFzcyk7XG5leHBvcnRzLkVjZyA9IEVjZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVjZy5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/ecg\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/ecg.html":
/*!*************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/ecg.html ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template>\\n  <!-- not used, inherited from chartjs-->\\n  ECG:\\n  <div id=\\\"canvas-holder\\\">\\n    <span class=\\\"w3-small\\\">\\n      <i class=\\\"fa fa-download\\\" title=\\\"download csv data, row=data in time point\\\" click.delegate=\\\"download()\\\"></i>\\n      <i class=\\\"fa fa-download fa-rotate-270\\\" title=\\\"download flat csv data, row=all data for variable\\\" click.delegate=\\\"downloadflat()\\\"></i>\\n      <!--i class=\\\"fa fa-eye w3-border\\\" title=\\\"preview csv data\\\" click.delegate=\\\"preview()\\\"></i-->\\n    </span>\\n    <canvas id=\\\"${id}-canvas\\\" ref=\\\"chartcanvas\\\" width=\\\"${width}\\\" height=\\\"${height}\\\"></canvas> <!-- width=\\\"${width}\\\" height=\\\"${height}\\\" -->\\n  </div>\\n</template>\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2VjZy5odG1sLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F1cmVsaWEtYm9keWxpZ2h0LXBsdWdpbi9kaXN0L25hdGl2ZS1tb2R1bGVzL2VsZW1lbnRzL2VjZy5odG1sPzExYjYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIjx0ZW1wbGF0ZT5cXG4gIDwhLS0gbm90IHVzZWQsIGluaGVyaXRlZCBmcm9tIGNoYXJ0anMtLT5cXG4gIEVDRzpcXG4gIDxkaXYgaWQ9XFxcImNhbnZhcy1ob2xkZXJcXFwiPlxcbiAgICA8c3BhbiBjbGFzcz1cXFwidzMtc21hbGxcXFwiPlxcbiAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1kb3dubG9hZFxcXCIgdGl0bGU9XFxcImRvd25sb2FkIGNzdiBkYXRhLCByb3c9ZGF0YSBpbiB0aW1lIHBvaW50XFxcIiBjbGljay5kZWxlZ2F0ZT1cXFwiZG93bmxvYWQoKVxcXCI+PC9pPlxcbiAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1kb3dubG9hZCBmYS1yb3RhdGUtMjcwXFxcIiB0aXRsZT1cXFwiZG93bmxvYWQgZmxhdCBjc3YgZGF0YSwgcm93PWFsbCBkYXRhIGZvciB2YXJpYWJsZVxcXCIgY2xpY2suZGVsZWdhdGU9XFxcImRvd25sb2FkZmxhdCgpXFxcIj48L2k+XFxuICAgICAgPCEtLWkgY2xhc3M9XFxcImZhIGZhLWV5ZSB3My1ib3JkZXJcXFwiIHRpdGxlPVxcXCJwcmV2aWV3IGNzdiBkYXRhXFxcIiBjbGljay5kZWxlZ2F0ZT1cXFwicHJldmlldygpXFxcIj48L2ktLT5cXG4gICAgPC9zcGFuPlxcbiAgICA8Y2FudmFzIGlkPVxcXCIke2lkfS1jYW52YXNcXFwiIHJlZj1cXFwiY2hhcnRjYW52YXNcXFwiIHdpZHRoPVxcXCIke3dpZHRofVxcXCIgaGVpZ2h0PVxcXCIke2hlaWdodH1cXFwiPjwvY2FudmFzPiA8IS0tIHdpZHRoPVxcXCIke3dpZHRofVxcXCIgaGVpZ2h0PVxcXCIke2hlaWdodH1cXFwiIC0tPlxcbiAgPC9kaXY+XFxuPC90ZW1wbGF0ZT5cXG5cIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/ecg.html\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/fmi":
/*!***********************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/fmi.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.thirdpartytimeout = exports.Fmi = void 0;\n\nvar _aureliaFramework = __webpack_require__(/*! aurelia-framework */ \"aurelia-framework\");\n\nvar _lodash = _interopRequireDefault(__webpack_require__(/*! lodash */ \"LvDl\"));\n\nvar _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16, _descriptor17, _descriptor18, _descriptor19, _descriptor20, _descriptor21, _descriptor22;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\nconst thirdpartytimeout = 5000;\nexports.thirdpartytimeout = thirdpartytimeout;\nlet Fmi = (_class = class Fmi {\n  //0.000030517578\n  //if >0 then fmi will stop at stoptime\n  //input==continuous/change==when user drops the value\n  //continuous or oneshot or onestep\n  //0.0078125;\n  constructor() {\n    _initializerDefineProperty(this, \"fminame\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"tolerance\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"starttime\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"stoptime\", _descriptor4, this);\n\n    _initializerDefineProperty(this, \"guid\", _descriptor5, this);\n\n    _initializerDefineProperty(this, \"id\", _descriptor6, this);\n\n    _initializerDefineProperty(this, \"inputs\", _descriptor7, this);\n\n    _initializerDefineProperty(this, \"otherinputs\", _descriptor8, this);\n\n    _initializerDefineProperty(this, \"valuereferences\", _descriptor9, this);\n\n    _initializerDefineProperty(this, \"ticksToUpdate\", _descriptor10, this);\n\n    _initializerDefineProperty(this, \"src\", _descriptor11, this);\n\n    _initializerDefineProperty(this, \"fstepsize\", _descriptor12, this);\n\n    _initializerDefineProperty(this, \"controlid\", _descriptor13, this);\n\n    _initializerDefineProperty(this, \"showcontrols\", _descriptor14, this);\n\n    _initializerDefineProperty(this, \"fpslimit\", _descriptor15, this);\n\n    _initializerDefineProperty(this, \"showtime\", _descriptor16, this);\n\n    _initializerDefineProperty(this, \"showtimemultiply\", _descriptor17, this);\n\n    _initializerDefineProperty(this, \"eventlisten\", _descriptor18, this);\n\n    _initializerDefineProperty(this, \"mode\", _descriptor19, this);\n\n    _initializerDefineProperty(this, \"stepsperframe\", _descriptor20, this);\n\n    _initializerDefineProperty(this, \"startafter\", _descriptor21, this);\n\n    _initializerDefineProperty(this, \"fmuspeed\", _descriptor22, this);\n\n    this.cosimulation = 1;\n    this.stepSize = 0.01;\n    this.doingstep = false;\n    this.animationstarted = false;\n    this.measurefps = false;\n    this.d = void 0;\n    this.fpstick = 0;\n    this.stepi = 0;\n    this.resetBeforeChange = false;\n    this.simulationtime = 0;\n    this.isOneshot = false;\n    this.isOnestep = false;\n    this.perfstartTime = void 0;\n    this.perfendTime = void 0;\n    //create lambda function which is added as listener later\n    this.changeinputs = {}; //[]; change to associative array\n\n    this.handleValueChange = e => {\n      //e.target; //triggered the event\n      let targetid;\n      if (e.detail && e.detail.id) targetid = e.detail.id;else if (e.target.id.length > 0) targetid = e.target.id;else targetid = e.target.parentElement.parentElement.id;\n      let targetvalue = e.detail && e.detail.value ? e.detail.value : e.target.value; //bug sometimes value change is double fired, check whether changeinputs already contains the same value\n\n      if (this.changeinputs[targetid] && this.changeinputs[targetid].value === targetvalue) return;\n      this.changeinputs[targetid] = {\n        id: targetid,\n        value: targetvalue\n      }; //detail will hold the value being changed\n      //determine whether it is fixed parameter - further reset is needed?\n\n      this.resetBeforeChange = this.resetBeforeChange || this.inputreferences[targetid] && this.inputreferences[targetid].fixed; //do step if mode is onestep\n      //TODO may be do throttle here - if more events will come do step shot only once\n\n      if (this.isOnestep) setTimeout(this.step.bind(this), 200); //do simulation step after 200 ms\n\n      if (this.isOneshot) setTimeout(this.shot.bind(this), 200); //so shot after 200ms\n    };\n\n    this.handleDetailChange = e => {\n      //this.changeinputs.push({valuereference: e.detail.valuereference, value: e.detail.value, fromid: e.detail.id}); //detail will hold the value being changed\n      //bug sometimes value change is double fired, check whether changeinputs already contains the same value\n      if (this.changeinputs[e.detail.id] && this.changeinputs[e.detail.id].value === e.detail.value) return;\n      this.changeinputs[e.detail.id] = {\n        valuereference: e.detail.valuereference,\n        value: e.detail.value,\n        fromid: e.detail.id\n      }; //this.changeinputs[targetid] = targetvalue; //detail will hold the value being changed TODO valuereference???\n\n      console.log('fmi handle detail change', this.changeinputs); //do step if mode is onestep\n\n      if (this.isOnestep) setTimeout(this.stepHandler, 200); //do simulation step after 100 ms\n\n      if (this.isOneshot) {\n        //TODO do start\n        setTimeout(this.shot.bind(this), 200);\n      } //do simulation step after 100 ms\n\n    };\n\n    this.handleStart = e => {\n      this.startevent(e);\n    };\n\n    this.handleStop = e => {\n      this.stopevent(e);\n    };\n\n    this.handleShot = this.shot.bind(this);\n    this.handleStep = this.step.bind(this);\n    this.debounceStep = _lodash.default.debounce(this.handleStep, 1000);\n    this.debounceShot = _lodash.default.debounce(this.handleShot, 1000); //this handles event to register inputs - may be sent by subsequent component which change inputs/outputs communicating with fmi\n\n    this.handleRegister = () => {\n      this.deregisterInputs();\n      this.registerInputs();\n      if (this.isOnestep) this.debounceStep(); //do simulation step immediately;\n\n      if (this.isOneshot) this.debounceShot(); //do simulation shot immediately;}\n    };\n\n    this.inst = false;\n  }\n\n  registerInputs() {\n    if (this.inputs) {\n      //register DOM elements to listen to their 'change' event directly\n      let inputparts = this.inputs.split(';'); //splits groups delimited by ;\n\n      this.inputreferences = [];\n\n      for (let inputpart of inputparts) {\n        let myinputs = inputpart.split(','); //splits reference and id by ,\n\n        let numerator = myinputs.length > 2 ? parseFloat(myinputs[2]) : 1;\n        let denominator = myinputs.length > 3 ? parseFloat(myinputs[3]) : 1;\n        let addconst = myinputs.length > 4 ? parseFloat(myinputs[4]) : 0;\n        let fixedsignature = myinputs.length > 5 ? myinputs[5] === 'f' : false;\n\n        if (isNaN(addconst)) {\n          addconst = 0;\n          fixedsignature = myinputs[4] === 'f';\n        } //fixes bug, setting  instead of NaN, when 4th param is omited and instead 'f' or 't' is specified\n\n\n        let inputref = {\n          ref: myinputs[1],\n          numerator: numerator,\n          denominator: denominator,\n          addconst: addconst,\n          fixed: fixedsignature\n        };\n\n        if (this.inputreferences[myinputs[0]]) {\n          this.inputreferences[myinputs[0]].fixed = this.inputreferences[myinputs[0]].fixed || fixedsignature;\n          this.inputreferences[myinputs[0]].refs.push(inputref); //first is id second is reference\n        } else this.inputreferences[myinputs[0]] = {\n          fixed: fixedsignature,\n          refs: [inputref]\n        }; //first is id second is reference\n        //register change event - the alteration is commited\n\n\n        let dependentEl = document.getElementById(myinputs[0]); //now register 'change' event or eventlisten\n\n        if (dependentEl) {\n          dependentEl.addEventListener(this.eventlisten, this.handleValueChange);\n          console.log('registering input, ref, num,den,add,fixed', myinputs[0], myinputs[1], numerator, denominator, addconst, fixedsignature);\n        } else {\n          //const dependentAnimEl = window.ani.getAnimateObj(myinputs[0]);\n          //will push unregistered inputs into possible animation inputs handled during start/stop  \n          if (!window.animateranges) window.animateranges = [];\n          window.animateranges.push({\n            name: myinputs[0],\n            handleValueChange: this.handleValueChange\n          });\n          console.log('non-existing element id, will try to register to animation:', myinputs[0]);\n        }\n      }\n    }\n\n    if (this.otherinputs) {\n      let otherinputtargets = this.otherinputs.split(';');\n\n      for (let target of otherinputtargets) {\n        document.getElementById(target).addEventListener('fmiinput', this.handleDetailChange);\n      }\n    } //TODO check if onestep - do step after\n\n    /*if (this.isOnestep) {\n      //console.log('onestep scheduling startevent in promise() to do step()')\n      setTimeout(this.sendStartEvent.bind(this),1000);\n      console.log('onestep scheduling promise() to do step()')\n      setTimeout(this.step.bind(this),1500);\n    } */\n    //do simulation step after 100 ms\n\n  }\n\n  deregisterInputs() {\n    //do removeListeners()\n    window.animateranges = [];\n\n    if (this.inputs) {\n      let inputparts = this.inputs.split(';');\n\n      for (let inputpart of inputparts) {\n        let myinputs = inputpart.split(',');\n\n        try {\n          document.getElementById(myinputs[0]).removeEventListener(this.eventlisten, this.handleValueChange);\n        } catch (e) {}\n      }\n    }\n\n    if (this.otherinputs) {\n      let otherinputtargets = this.otherinputs.split(';');\n\n      for (let target of otherinputtargets) {\n        try {\n          document.getElementById(target).removeEventListener('fmiinput', this.handleDetailChange);\n        } catch (e) {}\n      }\n    }\n  }\n\n  attached() {\n    console.log('fmi attached');\n    this.mydata = [0, 0]; //split references by ,\n\n    this.references = this.valuereferences.split(',');\n    this.registerInputs(); //if src is not specified - then expects that fmi scripts is loaded in HTML page prior thus should be available\n\n    if (this.src && this.src.length > 0) {\n      console.log('loading script first, then init fmi'); //keep 'this' reference in global for callback\n\n      window.thisfmi = this;\n      this.getScript(this.src, this.initfmi.bind(this));\n    } else {\n      //src is specified, thus load it - browser loads it at the end, thus adding the rest as callback after loaded\n      console.log('init fmi without loading script: fminame, this:', this.fminame, this);\n      this.initfmi();\n    }\n\n    if (this.controlid) {\n      document.getElementById(this.controlid).addEventListener('fmistart', this.handleStart);\n      document.getElementById(this.controlid).addEventListener('fmistop', this.handleStop);\n    }\n\n    if (typeof this.showcontrols === 'string') {\n      this.showcontrols = this.showcontrols === 'true';\n    }\n\n    document.addEventListener('fmiregister', this.handleRegister);\n    document.addEventListener('dostep', this.handleStep); //sending attached event - some may detect it to register it's outpu listener if attached before\n\n    let event = new CustomEvent('fmiattached');\n    document.dispatchEvent(event);\n  } //detects whether script with FMU is already loaded, if not it adds it to DOM and loads\n  //get script element and registers 'onload' callback to be called when the script is loaded\n\n\n  getScript(source, callback) {\n    //check whether the script is not already there\n    if (Array.from(document.getElementsByTagName('script')).filter(x => x.getAttribute('src') === source).length > 0) {\n      console.log('fmi.getScript() WARNING, script is already added into DOM:', source); //do callback?\n\n      if (callback) setTimeout(callback, 0);\n      return;\n    } //console.log('fmi getscript()');\n\n\n    let script = document.createElement('script');\n    let prior = document.getElementsByTagName('script')[0];\n    script.async = 1;\n\n    script.onerror = function () {\n      if (!script.readyState || /loaded|complete/.test(script.readyState)) {\n        script.onerror = script.onload = null;\n        script = undefined; // try to insert script by other app for previewing - scripts might be inserted into DOM\n\n        if (window.editorapi && typeof window.editorapi.insertScriptById === 'function') {\n          console.log('inserting script by thirdparty api');\n          window.editorapi.insertScriptById(source, 'fmiobj-' + source);\n        } //do callback even if isAbort - scripts might be inserted into DOM by another app\n\n\n        if (callback) setTimeout(callback, 1500);\n      }\n    }; //remove onreadystatechange - only reliable in IE https://stackoverflow.com/questions/1929742/can-script-readystate-be-trusted-to-detect-the-end-of-dynamic-script-loading\n\n\n    script.onload = function (_, isAbort) {\n      if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {\n        script.onerror = script.onload = null;\n        script = undefined; //do callback - scripts might be inserted into DOM by another app\n\n        if (!isAbort && callback) setTimeout(callback, 0);\n      }\n    };\n\n    script.src = window.bdlBaseHref ? window.bdlBaseHref + source : source;\n    prior.parentNode.insertBefore(script, prior);\n  } //make inst object globally - in case of globals (non-src) declaration\n\n\n  initfmi() {\n    console.log('fmi initfmi()');\n    let that = {};\n    /* global/local fminame */\n\n    if (this.fminame) {\n      that.fminame = this.fminame;\n      console.log('using local fmi initfmi() fminame', that.fminame);\n    } else {\n      //try to use global fminame\n      that.fminame = window.thisfmi.fminame;\n      console.log('using global fmi initfmi() fminame', that.fminame);\n    } //bug fmu cosimulation\n\n\n    that.fminame = this.fminame; //create instance\n\n    let myinst = window[that.fminame](); //EMSDK v 3.x compiles fmu to Promise based api\n\n    if (myinst instanceof Promise) {\n      myinst.then(inst => {\n        that.inst = inst;\n\n        if (!window.fmiinst) {\n          window.fmiinst = [];\n        }\n\n        window.fmiinst[that.fminame] = that; //console.log('fmi callback from Promise that', that, that.inst);\n        //do one step if mode is onestep\n        //https://newbedev.com/pass-correct-this-context-to-settimeout-callback\n        //TODO check if this step/shot is needed\n\n        if (window.thisfmi.isOnestep) {\n          //console.log('onestep scheduling startevent in promise() to do step()')\n          setTimeout(window.thisfmi.sendStartEvent.bind(window.thisfmi), 1000);\n          console.log('onestep scheduling promise() to do step()'); //setTimeout(window.thisfmi.step.bind(window.thisfmi),1500);\n\n          window.thisfmi.debounceStep();\n        } else //do simulation step after 100 ms\n          if (window.thisfmi.isOneshot) {\n            //console.log('oneshot scheduling startevent in promise() to do step()')\n            setTimeout(window.thisfmi.sendStartEvent.bind(window.thisfmi), 800);\n            console.log('oneshot scheduling promise() to do shot() after 4.5s'); //setTimeout(window.thisfmi.shot.bind(window.thisfmi),1500);\n\n            window.thisfmi.debounceShot();\n          } else //do simulation step after 100 ms\n            if (this.startafter > 0) {\n              setTimeout(window.thisfmi.startstop.bind(window.thisfmi), 1000 * this.startafter);\n            }\n      });\n    } else {\n      //older EMSDK prior 3.x compiles directly to api, keep compatibility\n      that.inst = myinst;\n\n      if (!window.fmiinst) {\n        window.fmiinst = [];\n      }\n\n      window.fmiinst[that.fminame] = that; //console.log('fmi callback that, that.inst', that, that.inst);\n      //do one step if mode is onestep\n      //https://newbedev.com/pass-correct-this-context-to-settimeout-callback\n\n      if (window.thisfmi.isOnestep) {\n        console.log('onestep scheduling direct(nopromise) to do step()');\n        setTimeout(window.thisfmi.sendStartEvent.bind(window.thisfmi), 1000); //setTimeout(window.thisfmi.step.bind(window.thisfmi),1500);\n\n        _lodash.default.throttle(window.thisfmi.step.bind(window.thisfmi), 1500);\n      } else //do simulation step after 100 ms\n        if (window.thisfmi.isOneshot) {\n          console.log('oneshot scheduling direct(nopromise) to do step()');\n          setTimeout(window.thisfmi.sendStartEvent.bind(window.thisfmi), 1000); //setTimeout(window.thisfmi.shot.bind(window.thisfmi),1500);\n\n          _lodash.default.throttle(window.thisfmi.shot.bind(window.thisfmi), 1500);\n        } else if (this.startafter > 0) {\n          setTimeout(window.thisfmi.sendStartEvent.bind(window.thisfmi), 1000 * this.startafter);\n        }\n    }\n  }\n\n  bind() {\n    this.isOneshot = this.mode === 'oneshot';\n    this.isOnestep = this.mode === 'onestep';\n\n    if (this.isOnestep) {\n      this.showcontrols = false;\n    }\n\n    if (this.isOneshot) {\n      this.showcontrols = false;\n    }\n\n    if (typeof this.stoptime === 'string') {\n      this.stoptime = parseFloat(this.stoptime);\n    }\n\n    if (typeof this.starttime === 'string') {\n      this.starttime = parseFloat(this.starttime);\n    }\n\n    if (typeof this.stepsperframee === 'string') {\n      this.stepsperframe = parseInt(this.stepsperframe);\n    }\n\n    if (typeof this.startafter === 'string') {\n      this.starttime = parseFloat(this.startafter);\n    }\n\n    if (typeof this.fpslimit === 'string') {\n      this.fpslimit = parseFloat(this.fpslimit);\n    }\n\n    if (typeof this.fmuspeed === 'string') {\n      this.fmuspeed = parseInt(this.fmuspeed);\n      this.stepSize = this.fmuspeed * (typeof this.fstepsize === 'string' ? parseFloat(this.fstepsize) : this.fstepsize);\n    }\n  }\n\n  detached() {\n    document.removeEventListener('fmiregister', this.handleRegister);\n\n    if (this.animationstarted) {\n      this.startstop();\n    }\n\n    this.deregisterInputs();\n\n    if (this.controlid) {\n      document.getElementById(this.controlid).removeEventListener('fmistart', this.handleStart);\n      document.getElementById(this.controlid).removeEventListener('fmistop', this.handleStop);\n    }\n\n    if (window.editorapi && typeof window.editorapi.removeScriptById === 'function') {\n      console.log('inserting script by thirdparty api');\n      window.editorapi.removeScriptById(this.src, 'fmiobj-' + this.src);\n    }\n  }\n  /**\n   * Implements a rudimentary browser console logger for the FMU.\n   */\n\n\n  consoleLogger(componentEnvironment, instanceName, status, category, message, other) {\n    /* Fills variables into message returned by the FMU, the C way */\n    const formatMessage = (message1, other1) => {\n      // get a new pointer\n      let ptr = this.inst._malloc(1); // get the size of the resulting formated message\n\n\n      let num = this.inst._snprintf(ptr, 0, message1, other1);\n\n      this.inst._free(ptr);\n\n      num++; // TODO: Error handling num < 0\n\n      ptr = this.inst._malloc(num);\n\n      this.inst._snprintf(ptr, num, message1, other1); // return pointer to the resulting message string\n\n\n      return ptr;\n    }; // eslint-disable-next-line new-cap\n\n\n    console.log('FMU(' + this.inst.UTF8ToString(instanceName) + ':' + status + ':' + this.inst.UTF8ToString(category) + ') msg: ' + this.inst.UTF8ToString(formatMessage(message, other)));\n\n    this.inst._free(formatMessage);\n  }\n\n  initialize() {\n    console.log('fmi initialize()');\n    this.fmiEnterInit(this.fmiinst);\n    this.fmiExitInit(this.fmiinst);\n  }\n\n  instantiate() {\n    console.log('fmi instantiate()'); //first define FMI API function names;\n\n    const sReset = 'fmi2Reset';\n    const sInstantiate = 'fmi2Instantiate';\n    const sSetup = 'fmi2SetupExperiment';\n    const sEnterinit = 'fmi2EnterInitializationMode';\n    const sExitinit = 'fmi2ExitInitializationMode';\n    const sSetreal = 'fmi2SetReal';\n    const sSetboolean = 'fmi2SetBoolean';\n    const sGetreal = 'fmi2GetReal';\n    const sGetboolean = 'fmi2GetBoolean';\n    const sDostep = 'fmi2DoStep';\n    const sCreateCallback = 'createFmi2CallbackFunctions'; //add fmustate support\n\n    const sGetFMUState = 'fmi2GetFMUState';\n    const sSetFMUState = 'fmi2SetFMUState';\n    const sFreeFMUState = 'fmi2FreeFMUState';\n    const sSerializedFMUStateSize = 'fmi2SerializedFMUStateSize';\n    const sSerializeFMUState = 'fmi2SerializeFMUState';\n    const sDeSerializeFMUStateSize = 'fmi2DeSerializeFMUState';\n    this.stepTime = 0;\n    this.stepSize = this.fmuspeed * (typeof this.fstepsize === 'string' ? parseFloat(this.fstepsize) : this.fstepsize);\n    this.mystep = this.stepSize; //console callback ptr, per emsripten create int ptr with signature viiiiii\n\n    if (window.fmiinst && window.fmiinst[this.fminame]) this.inst = window.fmiinst[this.fminame].inst;else {\n      console.warn('fmi instantiate() error initfmi() probably not called');\n    } //else this.inst = null;//if (window.thisfmi) {this.inst = window.thisfmi.inst;}\n\n    console.log('instantiate() this.inst', this.inst); //set the fminame and JS WASM function references\n\n    let separator = '_';\n    let prefix = this.fminame; //console.log('attached fminame:', that.fminame);\n    // OpenModelica exports function names without prefix\n\n    if (typeof this.inst._fmi2GetVersion === 'function') {\n      prefix = '';\n      separator = '';\n    } //now use a 'cwrap' delivered by emscripten to facilitate calling C functions with C primitives (string,number) from Javascript\n\n\n    this.fmiCreateCallback = this.inst.cwrap(sCreateCallback, 'number', ['number']);\n    this.fmiReset = this.inst.cwrap(prefix + separator + sReset, 'number', ['number']);\n    this.fmiInstantiate = this.inst.cwrap(prefix + separator + sInstantiate, 'number', ['string', 'number', 'string', 'string', 'number', 'number', 'number']);\n    this.fmiSetup = this.inst.cwrap(prefix + separator + sSetup, 'number', ['number', 'number', 'number', 'number', 'number', 'number']);\n    this.fmiEnterInit = this.inst.cwrap(prefix + separator + sEnterinit, 'number', ['number']);\n    this.fmiExitInit = this.inst.cwrap(prefix + separator + sExitinit, 'number', ['number']);\n    this.fmiSetReal = this.inst.cwrap(prefix + separator + sSetreal, 'number', ['number', 'number', 'number', 'number']);\n    this.fmiGetReal = this.inst.cwrap(prefix + separator + sGetreal, 'number', ['number', 'number', 'number', 'number']);\n    this.fmiSetBoolean = this.inst.cwrap(prefix + separator + sSetboolean, 'number', ['number', 'number', 'number', 'number']);\n    this.fmiGetBoolean = this.inst.cwrap(prefix + separator + sGetboolean, 'number', ['number', 'number', 'number', 'number']);\n    this.fmiDoStep = this.inst.cwrap(prefix + separator + sDostep, 'number', ['number', 'number', 'number', 'number']);\n    this.fmiGetVersion = this.inst.cwrap(prefix + separator + 'fmi2GetVersion', 'string');\n    this.fmiGetTypesPlatform = this.inst.cwrap(prefix + separator + 'fmi2GetTypesPlatform', 'string');\n    this.fmi2FreeInstance = this.inst.cwrap(prefix + separator + 'fmi2FreeInstance', 'number', ['number']); //add fmustate\n\n    this.fmiGetFMUState = this.inst.cwrap(prefix + separator + sGetFMUState, 'number', ['number']);\n    this.fmiSetFMUState = this.inst.cwrap(prefix + separator + sSetFMUState, 'number', ['number']);\n    this.fmiFreeFMUState = this.inst.cwrap(prefix + separator + sFreeFMUState, 'number', ['number']);\n    this.fmiSerializedFMUStateSize = this.inst.cwrap(prefix + separator + sSerializedFMUStateSize, 'number', ['number']);\n    this.fmiSerializeFMUState = this.inst.cwrap(prefix + separator + sSerializeFMUState, 'number', ['number']);\n    this.fmiDeSerializeFMUStateSize = this.inst.cwrap(prefix + separator + sDeSerializeFMUStateSize, 'number', ['number']);\n    this.instantiated = false; //calculate pow, power of stepsize\n\n    this.pow = this.stepSize < 1 ? -Math.ceil(-Math.log10(this.stepSize)) : Math.ceil(Math.log10(this.stepSize)); //use Math.trunc ??\n    //console.log('instantiate() this', this);\n\n    this.consoleLoggerPtr = this.inst.addFunction(this.consoleLogger.bind(this), 'viiiiii');\n    this.callbackptr = this.fmiCreateCallback(this.consoleLoggerPtr); //console.log('fminame',this.fminame);\n    //console.log('guid',this.guid);\n    //console.log('callbackptr',this.callbackptr);\n    //console.log('fmiinstantiate fnc:',this.fmiInstantiate);\n    //create instance of model simulation\n\n    this.fmiinst = this.fmiInstantiate(this.fminame, this.cosimulation, this.guid, '', this.callbackptr, 0, 0); //last 1 debug, 0 nodebug\n\n    this.setupExperiment();\n  }\n\n  setupExperiment() {\n    //setup experiment\n    this.fmiSetup(this.fmiinst, 1, this.tolerance, this.starttime, 0);\n    console.log('setupExperiment() fmiinst', this.fmiinst);\n    this.instantiated = true;\n  }\n\n  simulate() {}\n\n  setReal(query, value, count) {\n    console.log('setreal query,value,count', query, value, count);\n    return this.fmiSetReal(this.fmiinst, query.byteOffset, count, value.byteOffset);\n  }\n\n  setBoolean(query, value, count) {\n    return this.fmiSetBoolean(this.fmiinst, query.byteOffset, count, value.byteOffset);\n  }\n  /**\n   * Loads Reals from FMU\n   */\n\n\n  getReal(query, output, count) {\n    return this.fmiGetReal(this.fmiinst, query.byteOffset, count, output.byteOffset);\n  }\n  /**\n   * Loads Booleans from FMU\n   */\n\n\n  getBoolean(query, output, count) {\n    return this.fmiGetBoolean(this.fmiinst, query.byteOffset, count, output.byteOffset);\n  }\n\n  startevent(e) {\n    console.log('fmi startevent recieved', e); //if (!this.animationstarted) \n\n    this.perfstart();\n    this.startSimulation();\n  }\n\n  stopevent(e) {\n    console.log('fmi stopevent recieved', e); //if (this.animationstarted) \n\n    this.stopSimulation();\n    this.perfend();\n  } //action to be performed when clicking the play/pause button\n  //sends fmistart/fmistop event and starts/stops simulation\n\n\n  startstop() {\n    if (this.animationstarted) {\n      this.stopSimulation();\n      this.sendStopEvent();\n      this.perfend();\n    } else {\n      this.perfstart();\n      this.sendStartEvent();\n      this.startSimulation();\n    }\n  } //defines action to be done during browser animationframe and starts\n\n\n  startSimulation() {\n    this.animationstarted = true;\n    this.fpsInterval = 1000 / (isNaN(this.fpslimit) ? parseInt(this.fpslimit, 10) : this.fpslimit);\n    this.then = window.performance.now(); //read input values\n    //define performAnimation\n\n    const performAnimation = newtime => {\n      if (!this.animationstarted) return;\n      this.request = requestAnimationFrame(performAnimation);\n\n      if (this.fpslimit && this.fpslimit < 60) {\n        if (isNaN(this.fpslimit)) this.fpslimit = parseInt(this.fpslimit, 10);\n        this.now = newtime; //console.log('limiting fps to fpslimit, newtime, now, then, fpsinterval', this.fpslimit, newtime, this.now, this.then, this.fpsInterval);\n\n        this.elapsed = this.now - this.then; //console.log('elapsed,fpsinterval', this.elapsed, this.fpsInterval);\n\n        if (this.elapsed > this.fpsInterval) {\n          this.then = this.now - this.elapsed % this.fpsInterval;\n          this.step();\n        }\n      } else {\n        for (let i = 0; i < this.stepsperframe; i++) this.step();\n      }\n    };\n\n    performAnimation();\n  } //cancels all action to be done during browser animationframe and starts\n\n\n  stopSimulation() {\n    //stop animation\n    this.animationstarted = false;\n    cancelAnimationFrame(this.request);\n  } //sends fmistop event\n\n\n  sendStopEvent() {\n    //create custom event\n    let event = new CustomEvent('fmistop', {\n      detail: {\n        time: this.round(this.stepTime, this.pow)\n      }\n    }); //dispatch event - it should be listened by some other component\n\n    document.getElementById(this.id).dispatchEvent(event);\n  }\n\n  sendStartEvent() {\n    //create custom event\n    console.log('fmi.sendStartEvent(). Sending start event for adobeobj');\n    let event = new CustomEvent('fmistart', {\n      detail: {\n        time: this.round(this.stepTime, this.pow)\n      }\n    }); //dispatch event - it should be listened by some other component\n\n    document.getElementById(this.id).dispatchEvent(event); //animate using requestAnimationFrame\n  }\n\n  round(value, decimals) {\n    if (decimals < 0) {\n      let posdecimals = -decimals;\n      return Number(Math.round(value + 'e' + posdecimals) + 'e-' + posdecimals);\n    }\n\n    return Number(Math.round(value + 'e-' + decimals) + 'e+' + decimals);\n  }\n\n  step(e) {\n    //this = window.thisfmi;\n    //primitive semaphore, only one instance can perform this call\n    if (!this.doingstep) {\n      //console.log('fmu step()');\n      this.doingstep = true;\n\n      try {\n        if (!this.instantiated) {\n          this.instantiate();\n          this.initialize();\n        }\n\n        this.stepi++; //changeinputs\n\n        if (this.resetBeforeChange) {\n          //fmi call\n          this.setupExperiment(); //do reset\n\n          this.fmiReset(this.fmiinst); //setting fixed parameters are now allowed\n\n          this.setInputVariables(); //initialize\n\n          this.initialize(); //make big step from 0 to current stepTime ???\n          //const res =\n          //make big step only if it is not onestep\n\n          if (!this.isOnestep) this.fmiDoStep(this.fmiinst, this.starttime, this.stepTime, 1);else this.stepTime = this.starttime; //reset the signature\n\n          this.resetBeforeChange = false;\n        } else {\n          //do only change of variables\n          this.setInputVariables();\n        } //dostep\n        //compute step to round the desired time\n\n\n        const res = this.fmiDoStep(this.fmiinst, this.stepTime, this.mystep, 1);\n        this.stepTime = this.stepTime + this.mystep;\n        this.mystep = this.stepSize; //update correction step to current step\n\n        if (res === 1 || res === 2) {\n          console.warn('step() returned state<>0, doing reset()', res);\n          this.fmiReset(this.fmiinst);\n          this.initialize();\n        } //distribute simulation data to listeners\n\n\n        this.mydata = this.getReals(this.references); //create custom event\n\n        let event = new CustomEvent('fmidata', {\n          detail: {\n            time: this.round(this.stepTime, this.pow),\n            data: this.mydata\n          }\n        }); //dispatch event - it should be listened by some other component\n\n        document.getElementById(this.id).dispatchEvent(event); //compute showtime\n\n        if (this.showtime) this.simulationtime = this.secondsToTime(this.stepTime, this.showtimemultiply); //do computation only every tickstoupdate tick\n\n        if (this.measurefps) {\n          if (this.fpstick === 0) {\n            this.startfpstime = window.performance.now();\n          }\n\n          this.fpstick++;\n\n          if (this.fpstick >= this.ticksToUpdate) {\n            this.fpsInterval = 1000 / (isNaN(this.fpslimit) ? parseInt(this.fpslimit, 10) : this.fpslimit); //update ticks - so it will be every 3 seconds\n\n            this.ticksToUpdate = Math.round(3000 / this.fpsInterval); //do correction step calculation\n\n            if (this.stepSize < 1) {\n              this.pow = -Math.ceil(-Math.log10(this.stepSize));\n            } else {\n              this.pow = Math.ceil(Math.log10(this.stepSize));\n            }\n\n            this.mystep = this.round(this.stepTime + this.stepSize, this.pow) - this.stepTime; //do fps calculation\n\n            this.fps = (1000 * this.ticksToUpdate / (window.performance.now() - this.startfpstime)).toPrecision(4);\n            this.fpstick = 0;\n          }\n        } //stop simulation when stoptime is defined and reached\n\n\n        if (this.stoptime > 0 && this.animationstarted && this.stoptime < this.stepTime) {\n          this.startstop();\n        }\n      } catch (err) {\n        console.error('error catched during fmu step', err);\n      } finally {\n        this.doingstep = false;\n      }\n    }\n  }\n\n  shot(e) {\n    console.log('fmi -> shot()'); //check whether initialized and instantiated\n\n    if (!this.inst) {\n      //not instantiated\n      if (window.fmiinst && window.fmiinst[this.fminame]) {\n        console.warn('fmi shot() not instantiated, do it first time');\n        this.instantiate();\n        this.initialize();\n      } else {\n        //no initfmi() called = wait for script to be loaded, do nothing\n        return;\n      }\n    } else {\n      console.log('fmi shot() doing reset');\n      this.reset(); //this.setInputVariables();\n    } // do steps from starttime to stoptime\n\n\n    do {\n      this.step();\n    } while (this.stoptime > this.stepTime);\n  }\n\n  setInputVariables() {\n    for (let key in this.changeinputs) {\n      let myinputs = this.changeinputs[key]; //console.log('changing inputs', myinputs);\n      //set real - reference is in - one input one reference\n      //sets individual values - if id is in input, then reference is taken from inputs definition\n\n      console.log('changing inputs for myinputs.id ' + myinputs.id + \" value \" + myinputs.value, this.inputreferences);\n\n      if (this.inputreferences[myinputs.id]) {\n        for (let iref of this.inputreferences[myinputs.id].refs) {\n          let normalizedvalue = myinputs.value * iref.numerator / iref.denominator + iref.addconst;\n          if (myinputs.id) this.setSingleReal(iref.ref, normalizedvalue); // if reference is in input, then it is set directly\n          else if (myinputs.valuereference) this.setSingleReal(myinputs.valuereference, normalizedvalue);\n        }\n      }\n    }\n\n    this.flushRealQueue();\n\n    if (!this.isOneshot && !this.isOnestep) {\n      //forget inputs in continuous mode\n      this.changeinputs = {};\n    }\n    /*if (this.changeinputs.length > 0) {\n      while (this.changeinputs.length > 0) {\n        let myinputs = this.changeinputs.shift(); //remove first item\n        //console.log('changing inputs', myinputs);\n        //set real - reference is in - one input one reference\n        //sets individual values - if id is in input, then reference is taken from inputs definition\n        console.log('changing inputs,id,value', this.inputreferences, myinputs.id, myinputs.value);\n        for (let iref of this.inputreferences[myinputs.id].refs) {\n          let normalizedvalue = myinputs.value * iref.numerator / iref.denominator + iref.addconst;\n          if (myinputs.id) this.setSingleReal(iref.ref, normalizedvalue);\n          // if reference is in input, then it is set directly\n          else if (myinputs.valuereference) this.setSingleReal(myinputs.valuereference, normalizedvalue);\n        }\n      }\n      //flush all in one call to fmi\n      this.flushRealQueue();\n    }*/\n\n  }\n\n  reset() {\n    console.log('doing reset()');\n    this.stepTime = this.starttime;\n    this.stepSize = this.fmuspeed * (typeof this.fstepsize === 'string' ? parseFloat(this.fstepsize) : this.fstepsize);\n    this.mystep = this.stepSize;\n    this.setupExperiment();\n    this.fmiReset(this.fmiinst); //set input variables for possible change of non-tunable - fixed parameter values\n\n    this.setInputVariables();\n    this.initialize(); //create custom event\n\n    let event = new CustomEvent('fmireset'); //dispatch event - it should be listened by some other component\n\n    document.getElementById(this.id).dispatchEvent(event);\n  }\n\n  softreset() {\n    this.stepTime = this.starttime;\n    this.stepSize = this.fmuspeed * (typeof this.fstepsize === 'string' ? parseFloat(this.fstepsize) : this.fstepsize);\n    this.mystep = this.stepSize; //this.setupExperiment();\n    //this.fmiReset(this.fmiinst);\n    //set input variables for possible change of non-tunable - fixed parameter values\n\n    this.setInputVariables(); //this.initialize();\n    //create custom event\n\n    let event = new CustomEvent('fmireset'); //dispatch event - it should be listened by some other component\n\n    document.getElementById(this.id).dispatchEvent(event);\n  }\n  /* routines to alloc buffer for getting/setting from fmi*/\n\n\n  createBuffer(arr) {\n    let size = arr.length * arr.BYTES_PER_ELEMENT;\n\n    let ptr = this.inst._malloc(size);\n\n    return {\n      ptr,\n      size\n    };\n  }\n\n  createAndFillBuffer(arr) {\n    const buffer = this.createBuffer(arr);\n    this.fillBuffer(buffer, arr);\n    return buffer;\n  }\n\n  freeBuffer(buffer) {\n    if (buffer.ptr !== null) {\n      this.inst._free(buffer.ptr);\n    }\n\n    buffer.ptr = null;\n    buffer.size = null;\n  }\n\n  viewBuffer(buffer) {\n    return new Uint8Array(this.inst.HEAPU8.buffer, buffer.ptr, buffer.size);\n  }\n\n  fillBuffer(buffer, arr) {\n    const view = this.viewBuffer(buffer);\n    view.set(new Uint8Array(arr.buffer));\n    return buffer;\n  }\n\n  getReals(references) {\n    const queryBuffer = this.createAndFillBuffer(new Int32Array(references));\n    const query = this.viewBuffer(queryBuffer);\n    const outputBuffer = this.createBuffer(new Float64Array(references.length));\n    const output = this.viewBuffer(outputBuffer);\n    this.getReal(query, output, references.length);\n    const real = new Float64Array(output.buffer, output.byteOffset, references.length);\n    this.freeBuffer(queryBuffer);\n    this.freeBuffer(outputBuffer);\n    return real;\n  }\n\n  getSingleReal(reference) {\n    const queryBuffer = this.createAndFillBuffer(new Int32Array([reference]));\n    const query = this.viewBuffer(queryBuffer);\n    const outputBuffer = this.createBuffer(new Float64Array(1));\n    const output = this.viewBuffer(outputBuffer);\n    this.getReal(query, output, 1);\n    const real = new Float64Array(output.buffer, output.byteOffset, 1);\n    this.freeBuffer(queryBuffer);\n    this.freeBuffer(outputBuffer);\n    return real[0];\n  }\n  /**\n     * Adds a real value to setRealQueue\n     */\n\n\n  setSingleReal(reference, value) {\n    console.log('setSingleReal reference,value', reference, value);\n\n    if (!this.setRealQueue) {\n      this.setRealQueue = {\n        references: [],\n        values: []\n      };\n    }\n\n    this.setRealQueue.references.push(reference);\n    this.setRealQueue.values.push(value);\n  }\n\n  flushRealQueue() {\n    if (this.setRealQueue) {\n      const referenceBuffer = this.createAndFillBuffer(new Int32Array(this.setRealQueue.references));\n      const references = this.viewBuffer(referenceBuffer);\n      const valueBuffer = this.createAndFillBuffer(new Float64Array(this.setRealQueue.values));\n      const values = this.viewBuffer(valueBuffer);\n      this.setReal(references, values, this.setRealQueue.references.length);\n      this.freeBuffer(referenceBuffer);\n      this.freeBuffer(valueBuffer);\n      this.setRealQueue = false;\n    }\n  }\n\n  flushBooleanQueue() {\n    if (this.setBooleanQueue) {\n      const referenceBuffer = this.createAndFillBuffer(new Int32Array(this.setBooleanQueue.references));\n      const references = this.viewBuffer(referenceBuffer);\n      const valueBuffer = this.createAndFillBuffer(new Int32Array(this.setBooleanQueue.values));\n      const values = this.viewBuffer(valueBuffer);\n      this.setBoolean(references, values, this.setBooleanQueue.references.length);\n      this.freeBuffer(referenceBuffer);\n      this.freeBuffer(valueBuffer);\n      this.setBooleanQueue = false;\n    }\n  }\n  /**\n     */\n\n\n  setSingleBoolean(reference, value) {\n    if (!this.setBooleanQueue) {\n      this.setBooleanQueue = {\n        references: [],\n        values: []\n      };\n    }\n\n    this.setBooleanQueue.references.push(reference);\n    this.setBooleanQueue.values.push(value);\n  }\n  /**\n     * Loads a single boolean value based on reference, this is a shorthand function.\n     * It is recommended to use Module.getBoolean with reusable mallocs.\n     */\n\n\n  getSingleBoolean(reference) {\n    const queryBuffer = this.createAndFillBuffer(new Int32Array([reference]));\n    const query = this.viewBuffer(queryBuffer);\n    const outputBuffer = this.createBuffer(new Int32Array(1));\n    const output = this.viewBuffer(outputBuffer);\n    this.getBoolean(query, output, 1);\n    const bool = new Int32Array(output.buffer, output.byteOffset, 1);\n    this.freeBuffer(queryBuffer);\n    this.freeBuffer(outputBuffer);\n    return bool[0];\n  }\n\n  getBooleans(references) {\n    const queryBuffer = this.createAndFillBuffer(new Int32Array(references));\n    const query = this.viewBuffer(queryBuffer);\n    const outputBuffer = this.createBuffer(new Int32Array(references.length));\n    const output = this.viewBuffer(outputBuffer);\n    this.getBoolean(query, output, references.length);\n    const bool = new Int32Array(output.buffer, output.byteOffset, references.length);\n    this.freeBuffer(queryBuffer);\n    this.freeBuffer(outputBuffer);\n    return bool;\n  }\n\n  secondsToTime(sec, multiply) {\n    if (multiply === void 0) {\n      multiply = 1;\n    }\n\n    let x = Math.floor(sec * multiply);\n    let seconds = Math.floor(x % 60).toString().padStart(2, '0');\n    x /= 60;\n    let minutes = Math.floor(x % 60).toString().padStart(2, '0');\n    x /= 60;\n    let hours = Math.floor(x % 24).toString().padStart(2, '0');\n    x /= 24;\n    let days = Math.floor(x);\n    return ' ' + days + ' ' + hours + ':' + minutes + ':' + seconds;\n  }\n\n  perfstart() {\n    this.perfstartTime = new Date();\n  }\n\n  //outputs how many s the simulation was performed - at the end of simulation, good to measure performance\n  perfend() {\n    this.perfendTime = new Date();\n    var timeDiff = this.perfendTime - this.perfstartTime; //in ms\n    // strip the ms\n\n    timeDiff /= 1000; // get seconds\n\n    console.warn(\"Simulation took \" + timeDiff + \" seconds\");\n  }\n\n  fmuspeedChanged(newValue) {\n    this.stepSize = this.fmuspeed * (typeof this.fstepsize === 'string' ? parseFloat(this.fstepsize) : this.fstepsize);\n  }\n\n  getState() {\n    let size = this.fmiSerializedFMUStateSize();\n    let status = this.fmiSerializeFMUState(this.fmiinst, fmistate, serializedstate, size);\n  }\n\n}, (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"fminame\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return '';\n  }\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"tolerance\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 0.000001;\n  }\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"starttime\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 0;\n  }\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, \"stoptime\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 0;\n  }\n}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, \"guid\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return '';\n  }\n}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, \"id\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor7 = _applyDecoratedDescriptor(_class.prototype, \"inputs\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor8 = _applyDecoratedDescriptor(_class.prototype, \"otherinputs\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor9 = _applyDecoratedDescriptor(_class.prototype, \"valuereferences\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor10 = _applyDecoratedDescriptor(_class.prototype, \"ticksToUpdate\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 30;\n  }\n}), _descriptor11 = _applyDecoratedDescriptor(_class.prototype, \"src\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor12 = _applyDecoratedDescriptor(_class.prototype, \"fstepsize\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 0.01;\n  }\n}), _descriptor13 = _applyDecoratedDescriptor(_class.prototype, \"controlid\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor14 = _applyDecoratedDescriptor(_class.prototype, \"showcontrols\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return true;\n  }\n}), _descriptor15 = _applyDecoratedDescriptor(_class.prototype, \"fpslimit\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 60;\n  }\n}), _descriptor16 = _applyDecoratedDescriptor(_class.prototype, \"showtime\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return false;\n  }\n}), _descriptor17 = _applyDecoratedDescriptor(_class.prototype, \"showtimemultiply\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 1;\n  }\n}), _descriptor18 = _applyDecoratedDescriptor(_class.prototype, \"eventlisten\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 'input';\n  }\n}), _descriptor19 = _applyDecoratedDescriptor(_class.prototype, \"mode\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return \"continuous\";\n  }\n}), _descriptor20 = _applyDecoratedDescriptor(_class.prototype, \"stepsperframe\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 1;\n  }\n}), _descriptor21 = _applyDecoratedDescriptor(_class.prototype, \"startafter\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 0;\n  }\n}), _descriptor22 = _applyDecoratedDescriptor(_class.prototype, \"fmuspeed\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 1;\n  }\n})), _class);\nexports.Fmi = Fmi;\n//# sourceMappingURL=fmi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2ZtaS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLWJvZHlsaWdodC1wbHVnaW4vZGlzdC9uYXRpdmUtbW9kdWxlcy9lbGVtZW50cy9mbWkuanM/NGZjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudGhpcmRwYXJ0eXRpbWVvdXQgPSBleHBvcnRzLkZtaSA9IHZvaWQgMDtcblxudmFyIF9hdXJlbGlhRnJhbWV3b3JrID0gcmVxdWlyZShcImF1cmVsaWEtZnJhbWV3b3JrXCIpO1xuXG52YXIgX2xvZGFzaCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaFwiKSk7XG5cbnZhciBfY2xhc3MsIF9kZXNjcmlwdG9yLCBfZGVzY3JpcHRvcjIsIF9kZXNjcmlwdG9yMywgX2Rlc2NyaXB0b3I0LCBfZGVzY3JpcHRvcjUsIF9kZXNjcmlwdG9yNiwgX2Rlc2NyaXB0b3I3LCBfZGVzY3JpcHRvcjgsIF9kZXNjcmlwdG9yOSwgX2Rlc2NyaXB0b3IxMCwgX2Rlc2NyaXB0b3IxMSwgX2Rlc2NyaXB0b3IxMiwgX2Rlc2NyaXB0b3IxMywgX2Rlc2NyaXB0b3IxNCwgX2Rlc2NyaXB0b3IxNSwgX2Rlc2NyaXB0b3IxNiwgX2Rlc2NyaXB0b3IxNywgX2Rlc2NyaXB0b3IxOCwgX2Rlc2NyaXB0b3IxOSwgX2Rlc2NyaXB0b3IyMCwgX2Rlc2NyaXB0b3IyMSwgX2Rlc2NyaXB0b3IyMjtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvciwgY29udGV4dCkgeyBpZiAoIWRlc2NyaXB0b3IpIHJldHVybjsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHsgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLCBjb25maWd1cmFibGU6IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlLCB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSwgdmFsdWU6IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIgPyBkZXNjcmlwdG9yLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDAgfSk7IH1cblxuZnVuY3Rpb24gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5LCBkZWNvcmF0b3JzLCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7IHZhciBkZXNjID0ge307IE9iamVjdC5rZXlzKGRlc2NyaXB0b3IpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBkZXNjW2tleV0gPSBkZXNjcmlwdG9yW2tleV07IH0pOyBkZXNjLmVudW1lcmFibGUgPSAhIWRlc2MuZW51bWVyYWJsZTsgZGVzYy5jb25maWd1cmFibGUgPSAhIWRlc2MuY29uZmlndXJhYmxlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjIHx8IGRlc2MuaW5pdGlhbGl6ZXIpIHsgZGVzYy53cml0YWJsZSA9IHRydWU7IH0gZGVzYyA9IGRlY29yYXRvcnMuc2xpY2UoKS5yZXZlcnNlKCkucmVkdWNlKGZ1bmN0aW9uIChkZXNjLCBkZWNvcmF0b3IpIHsgcmV0dXJuIGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5LCBkZXNjKSB8fCBkZXNjOyB9LCBkZXNjKTsgaWYgKGNvbnRleHQgJiYgZGVzYy5pbml0aWFsaXplciAhPT0gdm9pZCAwKSB7IGRlc2MudmFsdWUgPSBkZXNjLmluaXRpYWxpemVyID8gZGVzYy5pbml0aWFsaXplci5jYWxsKGNvbnRleHQpIDogdm9pZCAwOyBkZXNjLmluaXRpYWxpemVyID0gdW5kZWZpbmVkOyB9IGlmIChkZXNjLmluaXRpYWxpemVyID09PSB2b2lkIDApIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2MpOyBkZXNjID0gbnVsbDsgfSByZXR1cm4gZGVzYzsgfVxuXG5mdW5jdGlvbiBfaW5pdGlhbGl6ZXJXYXJuaW5nSGVscGVyKGRlc2NyaXB0b3IsIGNvbnRleHQpIHsgdGhyb3cgbmV3IEVycm9yKCdEZWNvcmF0aW5nIGNsYXNzIHByb3BlcnR5IGZhaWxlZC4gUGxlYXNlIGVuc3VyZSB0aGF0ICcgKyAncHJvcG9zYWwtY2xhc3MtcHJvcGVydGllcyBpcyBlbmFibGVkIGFuZCBydW5zIGFmdGVyIHRoZSBkZWNvcmF0b3JzIHRyYW5zZm9ybS4nKTsgfVxuXG5jb25zdCB0aGlyZHBhcnR5dGltZW91dCA9IDUwMDA7XG5leHBvcnRzLnRoaXJkcGFydHl0aW1lb3V0ID0gdGhpcmRwYXJ0eXRpbWVvdXQ7XG5sZXQgRm1pID0gKF9jbGFzcyA9IGNsYXNzIEZtaSB7XG4gIC8vMC4wMDAwMzA1MTc1NzhcbiAgLy9pZiA+MCB0aGVuIGZtaSB3aWxsIHN0b3AgYXQgc3RvcHRpbWVcbiAgLy9pbnB1dD09Y29udGludW91cy9jaGFuZ2U9PXdoZW4gdXNlciBkcm9wcyB0aGUgdmFsdWVcbiAgLy9jb250aW51b3VzIG9yIG9uZXNob3Qgb3Igb25lc3RlcFxuICAvLzAuMDA3ODEyNTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJmbWluYW1lXCIsIF9kZXNjcmlwdG9yLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9sZXJhbmNlXCIsIF9kZXNjcmlwdG9yMiwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXJ0dGltZVwiLCBfZGVzY3JpcHRvcjMsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9wdGltZVwiLCBfZGVzY3JpcHRvcjQsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJndWlkXCIsIF9kZXNjcmlwdG9yNSwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlkXCIsIF9kZXNjcmlwdG9yNiwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlucHV0c1wiLCBfZGVzY3JpcHRvcjcsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJvdGhlcmlucHV0c1wiLCBfZGVzY3JpcHRvcjgsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YWx1ZXJlZmVyZW5jZXNcIiwgX2Rlc2NyaXB0b3I5LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwidGlja3NUb1VwZGF0ZVwiLCBfZGVzY3JpcHRvcjEwLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwic3JjXCIsIF9kZXNjcmlwdG9yMTEsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJmc3RlcHNpemVcIiwgX2Rlc2NyaXB0b3IxMiwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRyb2xpZFwiLCBfZGVzY3JpcHRvcjEzLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwic2hvd2NvbnRyb2xzXCIsIF9kZXNjcmlwdG9yMTQsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJmcHNsaW1pdFwiLCBfZGVzY3JpcHRvcjE1LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwic2hvd3RpbWVcIiwgX2Rlc2NyaXB0b3IxNiwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNob3d0aW1lbXVsdGlwbHlcIiwgX2Rlc2NyaXB0b3IxNywgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV2ZW50bGlzdGVuXCIsIF9kZXNjcmlwdG9yMTgsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJtb2RlXCIsIF9kZXNjcmlwdG9yMTksIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGVwc3BlcmZyYW1lXCIsIF9kZXNjcmlwdG9yMjAsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGFydGFmdGVyXCIsIF9kZXNjcmlwdG9yMjEsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJmbXVzcGVlZFwiLCBfZGVzY3JpcHRvcjIyLCB0aGlzKTtcblxuICAgIHRoaXMuY29zaW11bGF0aW9uID0gMTtcbiAgICB0aGlzLnN0ZXBTaXplID0gMC4wMTtcbiAgICB0aGlzLmRvaW5nc3RlcCA9IGZhbHNlO1xuICAgIHRoaXMuYW5pbWF0aW9uc3RhcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMubWVhc3VyZWZwcyA9IGZhbHNlO1xuICAgIHRoaXMuZCA9IHZvaWQgMDtcbiAgICB0aGlzLmZwc3RpY2sgPSAwO1xuICAgIHRoaXMuc3RlcGkgPSAwO1xuICAgIHRoaXMucmVzZXRCZWZvcmVDaGFuZ2UgPSBmYWxzZTtcbiAgICB0aGlzLnNpbXVsYXRpb250aW1lID0gMDtcbiAgICB0aGlzLmlzT25lc2hvdCA9IGZhbHNlO1xuICAgIHRoaXMuaXNPbmVzdGVwID0gZmFsc2U7XG4gICAgdGhpcy5wZXJmc3RhcnRUaW1lID0gdm9pZCAwO1xuICAgIHRoaXMucGVyZmVuZFRpbWUgPSB2b2lkIDA7XG4gICAgLy9jcmVhdGUgbGFtYmRhIGZ1bmN0aW9uIHdoaWNoIGlzIGFkZGVkIGFzIGxpc3RlbmVyIGxhdGVyXG4gICAgdGhpcy5jaGFuZ2VpbnB1dHMgPSB7fTsgLy9bXTsgY2hhbmdlIHRvIGFzc29jaWF0aXZlIGFycmF5XG5cbiAgICB0aGlzLmhhbmRsZVZhbHVlQ2hhbmdlID0gZSA9PiB7XG4gICAgICAvL2UudGFyZ2V0OyAvL3RyaWdnZXJlZCB0aGUgZXZlbnRcbiAgICAgIGxldCB0YXJnZXRpZDtcbiAgICAgIGlmIChlLmRldGFpbCAmJiBlLmRldGFpbC5pZCkgdGFyZ2V0aWQgPSBlLmRldGFpbC5pZDtlbHNlIGlmIChlLnRhcmdldC5pZC5sZW5ndGggPiAwKSB0YXJnZXRpZCA9IGUudGFyZ2V0LmlkO2Vsc2UgdGFyZ2V0aWQgPSBlLnRhcmdldC5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQuaWQ7XG4gICAgICBsZXQgdGFyZ2V0dmFsdWUgPSBlLmRldGFpbCAmJiBlLmRldGFpbC52YWx1ZSA/IGUuZGV0YWlsLnZhbHVlIDogZS50YXJnZXQudmFsdWU7IC8vYnVnIHNvbWV0aW1lcyB2YWx1ZSBjaGFuZ2UgaXMgZG91YmxlIGZpcmVkLCBjaGVjayB3aGV0aGVyIGNoYW5nZWlucHV0cyBhbHJlYWR5IGNvbnRhaW5zIHRoZSBzYW1lIHZhbHVlXG5cbiAgICAgIGlmICh0aGlzLmNoYW5nZWlucHV0c1t0YXJnZXRpZF0gJiYgdGhpcy5jaGFuZ2VpbnB1dHNbdGFyZ2V0aWRdLnZhbHVlID09PSB0YXJnZXR2YWx1ZSkgcmV0dXJuO1xuICAgICAgdGhpcy5jaGFuZ2VpbnB1dHNbdGFyZ2V0aWRdID0ge1xuICAgICAgICBpZDogdGFyZ2V0aWQsXG4gICAgICAgIHZhbHVlOiB0YXJnZXR2YWx1ZVxuICAgICAgfTsgLy9kZXRhaWwgd2lsbCBob2xkIHRoZSB2YWx1ZSBiZWluZyBjaGFuZ2VkXG4gICAgICAvL2RldGVybWluZSB3aGV0aGVyIGl0IGlzIGZpeGVkIHBhcmFtZXRlciAtIGZ1cnRoZXIgcmVzZXQgaXMgbmVlZGVkP1xuXG4gICAgICB0aGlzLnJlc2V0QmVmb3JlQ2hhbmdlID0gdGhpcy5yZXNldEJlZm9yZUNoYW5nZSB8fCB0aGlzLmlucHV0cmVmZXJlbmNlc1t0YXJnZXRpZF0gJiYgdGhpcy5pbnB1dHJlZmVyZW5jZXNbdGFyZ2V0aWRdLmZpeGVkOyAvL2RvIHN0ZXAgaWYgbW9kZSBpcyBvbmVzdGVwXG4gICAgICAvL1RPRE8gbWF5IGJlIGRvIHRocm90dGxlIGhlcmUgLSBpZiBtb3JlIGV2ZW50cyB3aWxsIGNvbWUgZG8gc3RlcCBzaG90IG9ubHkgb25jZVxuXG4gICAgICBpZiAodGhpcy5pc09uZXN0ZXApIHNldFRpbWVvdXQodGhpcy5zdGVwLmJpbmQodGhpcyksIDIwMCk7IC8vZG8gc2ltdWxhdGlvbiBzdGVwIGFmdGVyIDIwMCBtc1xuXG4gICAgICBpZiAodGhpcy5pc09uZXNob3QpIHNldFRpbWVvdXQodGhpcy5zaG90LmJpbmQodGhpcyksIDIwMCk7IC8vc28gc2hvdCBhZnRlciAyMDBtc1xuICAgIH07XG5cbiAgICB0aGlzLmhhbmRsZURldGFpbENoYW5nZSA9IGUgPT4ge1xuICAgICAgLy90aGlzLmNoYW5nZWlucHV0cy5wdXNoKHt2YWx1ZXJlZmVyZW5jZTogZS5kZXRhaWwudmFsdWVyZWZlcmVuY2UsIHZhbHVlOiBlLmRldGFpbC52YWx1ZSwgZnJvbWlkOiBlLmRldGFpbC5pZH0pOyAvL2RldGFpbCB3aWxsIGhvbGQgdGhlIHZhbHVlIGJlaW5nIGNoYW5nZWRcbiAgICAgIC8vYnVnIHNvbWV0aW1lcyB2YWx1ZSBjaGFuZ2UgaXMgZG91YmxlIGZpcmVkLCBjaGVjayB3aGV0aGVyIGNoYW5nZWlucHV0cyBhbHJlYWR5IGNvbnRhaW5zIHRoZSBzYW1lIHZhbHVlXG4gICAgICBpZiAodGhpcy5jaGFuZ2VpbnB1dHNbZS5kZXRhaWwuaWRdICYmIHRoaXMuY2hhbmdlaW5wdXRzW2UuZGV0YWlsLmlkXS52YWx1ZSA9PT0gZS5kZXRhaWwudmFsdWUpIHJldHVybjtcbiAgICAgIHRoaXMuY2hhbmdlaW5wdXRzW2UuZGV0YWlsLmlkXSA9IHtcbiAgICAgICAgdmFsdWVyZWZlcmVuY2U6IGUuZGV0YWlsLnZhbHVlcmVmZXJlbmNlLFxuICAgICAgICB2YWx1ZTogZS5kZXRhaWwudmFsdWUsXG4gICAgICAgIGZyb21pZDogZS5kZXRhaWwuaWRcbiAgICAgIH07IC8vdGhpcy5jaGFuZ2VpbnB1dHNbdGFyZ2V0aWRdID0gdGFyZ2V0dmFsdWU7IC8vZGV0YWlsIHdpbGwgaG9sZCB0aGUgdmFsdWUgYmVpbmcgY2hhbmdlZCBUT0RPIHZhbHVlcmVmZXJlbmNlPz8/XG5cbiAgICAgIGNvbnNvbGUubG9nKCdmbWkgaGFuZGxlIGRldGFpbCBjaGFuZ2UnLCB0aGlzLmNoYW5nZWlucHV0cyk7IC8vZG8gc3RlcCBpZiBtb2RlIGlzIG9uZXN0ZXBcblxuICAgICAgaWYgKHRoaXMuaXNPbmVzdGVwKSBzZXRUaW1lb3V0KHRoaXMuc3RlcEhhbmRsZXIsIDIwMCk7IC8vZG8gc2ltdWxhdGlvbiBzdGVwIGFmdGVyIDEwMCBtc1xuXG4gICAgICBpZiAodGhpcy5pc09uZXNob3QpIHtcbiAgICAgICAgLy9UT0RPIGRvIHN0YXJ0XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5zaG90LmJpbmQodGhpcyksIDIwMCk7XG4gICAgICB9IC8vZG8gc2ltdWxhdGlvbiBzdGVwIGFmdGVyIDEwMCBtc1xuXG4gICAgfTtcblxuICAgIHRoaXMuaGFuZGxlU3RhcnQgPSBlID0+IHtcbiAgICAgIHRoaXMuc3RhcnRldmVudChlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5oYW5kbGVTdG9wID0gZSA9PiB7XG4gICAgICB0aGlzLnN0b3BldmVudChlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5oYW5kbGVTaG90ID0gdGhpcy5zaG90LmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVTdGVwID0gdGhpcy5zdGVwLmJpbmQodGhpcyk7XG4gICAgdGhpcy5kZWJvdW5jZVN0ZXAgPSBfbG9kYXNoLmRlZmF1bHQuZGVib3VuY2UodGhpcy5oYW5kbGVTdGVwLCAxMDAwKTtcbiAgICB0aGlzLmRlYm91bmNlU2hvdCA9IF9sb2Rhc2guZGVmYXVsdC5kZWJvdW5jZSh0aGlzLmhhbmRsZVNob3QsIDEwMDApOyAvL3RoaXMgaGFuZGxlcyBldmVudCB0byByZWdpc3RlciBpbnB1dHMgLSBtYXkgYmUgc2VudCBieSBzdWJzZXF1ZW50IGNvbXBvbmVudCB3aGljaCBjaGFuZ2UgaW5wdXRzL291dHB1dHMgY29tbXVuaWNhdGluZyB3aXRoIGZtaVxuXG4gICAgdGhpcy5oYW5kbGVSZWdpc3RlciA9ICgpID0+IHtcbiAgICAgIHRoaXMuZGVyZWdpc3RlcklucHV0cygpO1xuICAgICAgdGhpcy5yZWdpc3RlcklucHV0cygpO1xuICAgICAgaWYgKHRoaXMuaXNPbmVzdGVwKSB0aGlzLmRlYm91bmNlU3RlcCgpOyAvL2RvIHNpbXVsYXRpb24gc3RlcCBpbW1lZGlhdGVseTtcblxuICAgICAgaWYgKHRoaXMuaXNPbmVzaG90KSB0aGlzLmRlYm91bmNlU2hvdCgpOyAvL2RvIHNpbXVsYXRpb24gc2hvdCBpbW1lZGlhdGVseTt9XG4gICAgfTtcblxuICAgIHRoaXMuaW5zdCA9IGZhbHNlO1xuICB9XG5cbiAgcmVnaXN0ZXJJbnB1dHMoKSB7XG4gICAgaWYgKHRoaXMuaW5wdXRzKSB7XG4gICAgICAvL3JlZ2lzdGVyIERPTSBlbGVtZW50cyB0byBsaXN0ZW4gdG8gdGhlaXIgJ2NoYW5nZScgZXZlbnQgZGlyZWN0bHlcbiAgICAgIGxldCBpbnB1dHBhcnRzID0gdGhpcy5pbnB1dHMuc3BsaXQoJzsnKTsgLy9zcGxpdHMgZ3JvdXBzIGRlbGltaXRlZCBieSA7XG5cbiAgICAgIHRoaXMuaW5wdXRyZWZlcmVuY2VzID0gW107XG5cbiAgICAgIGZvciAobGV0IGlucHV0cGFydCBvZiBpbnB1dHBhcnRzKSB7XG4gICAgICAgIGxldCBteWlucHV0cyA9IGlucHV0cGFydC5zcGxpdCgnLCcpOyAvL3NwbGl0cyByZWZlcmVuY2UgYW5kIGlkIGJ5ICxcblxuICAgICAgICBsZXQgbnVtZXJhdG9yID0gbXlpbnB1dHMubGVuZ3RoID4gMiA/IHBhcnNlRmxvYXQobXlpbnB1dHNbMl0pIDogMTtcbiAgICAgICAgbGV0IGRlbm9taW5hdG9yID0gbXlpbnB1dHMubGVuZ3RoID4gMyA/IHBhcnNlRmxvYXQobXlpbnB1dHNbM10pIDogMTtcbiAgICAgICAgbGV0IGFkZGNvbnN0ID0gbXlpbnB1dHMubGVuZ3RoID4gNCA/IHBhcnNlRmxvYXQobXlpbnB1dHNbNF0pIDogMDtcbiAgICAgICAgbGV0IGZpeGVkc2lnbmF0dXJlID0gbXlpbnB1dHMubGVuZ3RoID4gNSA/IG15aW5wdXRzWzVdID09PSAnZicgOiBmYWxzZTtcblxuICAgICAgICBpZiAoaXNOYU4oYWRkY29uc3QpKSB7XG4gICAgICAgICAgYWRkY29uc3QgPSAwO1xuICAgICAgICAgIGZpeGVkc2lnbmF0dXJlID0gbXlpbnB1dHNbNF0gPT09ICdmJztcbiAgICAgICAgfSAvL2ZpeGVzIGJ1Zywgc2V0dGluZyAgaW5zdGVhZCBvZiBOYU4sIHdoZW4gNHRoIHBhcmFtIGlzIG9taXRlZCBhbmQgaW5zdGVhZCAnZicgb3IgJ3QnIGlzIHNwZWNpZmllZFxuXG5cbiAgICAgICAgbGV0IGlucHV0cmVmID0ge1xuICAgICAgICAgIHJlZjogbXlpbnB1dHNbMV0sXG4gICAgICAgICAgbnVtZXJhdG9yOiBudW1lcmF0b3IsXG4gICAgICAgICAgZGVub21pbmF0b3I6IGRlbm9taW5hdG9yLFxuICAgICAgICAgIGFkZGNvbnN0OiBhZGRjb25zdCxcbiAgICAgICAgICBmaXhlZDogZml4ZWRzaWduYXR1cmVcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5pbnB1dHJlZmVyZW5jZXNbbXlpbnB1dHNbMF1dKSB7XG4gICAgICAgICAgdGhpcy5pbnB1dHJlZmVyZW5jZXNbbXlpbnB1dHNbMF1dLmZpeGVkID0gdGhpcy5pbnB1dHJlZmVyZW5jZXNbbXlpbnB1dHNbMF1dLmZpeGVkIHx8IGZpeGVkc2lnbmF0dXJlO1xuICAgICAgICAgIHRoaXMuaW5wdXRyZWZlcmVuY2VzW215aW5wdXRzWzBdXS5yZWZzLnB1c2goaW5wdXRyZWYpOyAvL2ZpcnN0IGlzIGlkIHNlY29uZCBpcyByZWZlcmVuY2VcbiAgICAgICAgfSBlbHNlIHRoaXMuaW5wdXRyZWZlcmVuY2VzW215aW5wdXRzWzBdXSA9IHtcbiAgICAgICAgICBmaXhlZDogZml4ZWRzaWduYXR1cmUsXG4gICAgICAgICAgcmVmczogW2lucHV0cmVmXVxuICAgICAgICB9OyAvL2ZpcnN0IGlzIGlkIHNlY29uZCBpcyByZWZlcmVuY2VcbiAgICAgICAgLy9yZWdpc3RlciBjaGFuZ2UgZXZlbnQgLSB0aGUgYWx0ZXJhdGlvbiBpcyBjb21taXRlZFxuXG5cbiAgICAgICAgbGV0IGRlcGVuZGVudEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXlpbnB1dHNbMF0pOyAvL25vdyByZWdpc3RlciAnY2hhbmdlJyBldmVudCBvciBldmVudGxpc3RlblxuXG4gICAgICAgIGlmIChkZXBlbmRlbnRFbCkge1xuICAgICAgICAgIGRlcGVuZGVudEVsLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5ldmVudGxpc3RlbiwgdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZSk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ3JlZ2lzdGVyaW5nIGlucHV0LCByZWYsIG51bSxkZW4sYWRkLGZpeGVkJywgbXlpbnB1dHNbMF0sIG15aW5wdXRzWzFdLCBudW1lcmF0b3IsIGRlbm9taW5hdG9yLCBhZGRjb25zdCwgZml4ZWRzaWduYXR1cmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vY29uc3QgZGVwZW5kZW50QW5pbUVsID0gd2luZG93LmFuaS5nZXRBbmltYXRlT2JqKG15aW5wdXRzWzBdKTtcbiAgICAgICAgICAvL3dpbGwgcHVzaCB1bnJlZ2lzdGVyZWQgaW5wdXRzIGludG8gcG9zc2libGUgYW5pbWF0aW9uIGlucHV0cyBoYW5kbGVkIGR1cmluZyBzdGFydC9zdG9wICBcbiAgICAgICAgICBpZiAoIXdpbmRvdy5hbmltYXRlcmFuZ2VzKSB3aW5kb3cuYW5pbWF0ZXJhbmdlcyA9IFtdO1xuICAgICAgICAgIHdpbmRvdy5hbmltYXRlcmFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogbXlpbnB1dHNbMF0sXG4gICAgICAgICAgICBoYW5kbGVWYWx1ZUNoYW5nZTogdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdub24tZXhpc3RpbmcgZWxlbWVudCBpZCwgd2lsbCB0cnkgdG8gcmVnaXN0ZXIgdG8gYW5pbWF0aW9uOicsIG15aW5wdXRzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm90aGVyaW5wdXRzKSB7XG4gICAgICBsZXQgb3RoZXJpbnB1dHRhcmdldHMgPSB0aGlzLm90aGVyaW5wdXRzLnNwbGl0KCc7Jyk7XG5cbiAgICAgIGZvciAobGV0IHRhcmdldCBvZiBvdGhlcmlucHV0dGFyZ2V0cykge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YXJnZXQpLmFkZEV2ZW50TGlzdGVuZXIoJ2ZtaWlucHV0JywgdGhpcy5oYW5kbGVEZXRhaWxDaGFuZ2UpO1xuICAgICAgfVxuICAgIH0gLy9UT0RPIGNoZWNrIGlmIG9uZXN0ZXAgLSBkbyBzdGVwIGFmdGVyXG5cbiAgICAvKmlmICh0aGlzLmlzT25lc3RlcCkge1xuICAgICAgLy9jb25zb2xlLmxvZygnb25lc3RlcCBzY2hlZHVsaW5nIHN0YXJ0ZXZlbnQgaW4gcHJvbWlzZSgpIHRvIGRvIHN0ZXAoKScpXG4gICAgICBzZXRUaW1lb3V0KHRoaXMuc2VuZFN0YXJ0RXZlbnQuYmluZCh0aGlzKSwxMDAwKTtcbiAgICAgIGNvbnNvbGUubG9nKCdvbmVzdGVwIHNjaGVkdWxpbmcgcHJvbWlzZSgpIHRvIGRvIHN0ZXAoKScpXG4gICAgICBzZXRUaW1lb3V0KHRoaXMuc3RlcC5iaW5kKHRoaXMpLDE1MDApO1xuICAgIH0gKi9cbiAgICAvL2RvIHNpbXVsYXRpb24gc3RlcCBhZnRlciAxMDAgbXNcblxuICB9XG5cbiAgZGVyZWdpc3RlcklucHV0cygpIHtcbiAgICAvL2RvIHJlbW92ZUxpc3RlbmVycygpXG4gICAgd2luZG93LmFuaW1hdGVyYW5nZXMgPSBbXTtcblxuICAgIGlmICh0aGlzLmlucHV0cykge1xuICAgICAgbGV0IGlucHV0cGFydHMgPSB0aGlzLmlucHV0cy5zcGxpdCgnOycpO1xuXG4gICAgICBmb3IgKGxldCBpbnB1dHBhcnQgb2YgaW5wdXRwYXJ0cykge1xuICAgICAgICBsZXQgbXlpbnB1dHMgPSBpbnB1dHBhcnQuc3BsaXQoJywnKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15aW5wdXRzWzBdKS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuZXZlbnRsaXN0ZW4sIHRoaXMuaGFuZGxlVmFsdWVDaGFuZ2UpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm90aGVyaW5wdXRzKSB7XG4gICAgICBsZXQgb3RoZXJpbnB1dHRhcmdldHMgPSB0aGlzLm90aGVyaW5wdXRzLnNwbGl0KCc7Jyk7XG5cbiAgICAgIGZvciAobGV0IHRhcmdldCBvZiBvdGhlcmlucHV0dGFyZ2V0cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldCkucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm1paW5wdXQnLCB0aGlzLmhhbmRsZURldGFpbENoYW5nZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXR0YWNoZWQoKSB7XG4gICAgY29uc29sZS5sb2coJ2ZtaSBhdHRhY2hlZCcpO1xuICAgIHRoaXMubXlkYXRhID0gWzAsIDBdOyAvL3NwbGl0IHJlZmVyZW5jZXMgYnkgLFxuXG4gICAgdGhpcy5yZWZlcmVuY2VzID0gdGhpcy52YWx1ZXJlZmVyZW5jZXMuc3BsaXQoJywnKTtcbiAgICB0aGlzLnJlZ2lzdGVySW5wdXRzKCk7IC8vaWYgc3JjIGlzIG5vdCBzcGVjaWZpZWQgLSB0aGVuIGV4cGVjdHMgdGhhdCBmbWkgc2NyaXB0cyBpcyBsb2FkZWQgaW4gSFRNTCBwYWdlIHByaW9yIHRodXMgc2hvdWxkIGJlIGF2YWlsYWJsZVxuXG4gICAgaWYgKHRoaXMuc3JjICYmIHRoaXMuc3JjLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCdsb2FkaW5nIHNjcmlwdCBmaXJzdCwgdGhlbiBpbml0IGZtaScpOyAvL2tlZXAgJ3RoaXMnIHJlZmVyZW5jZSBpbiBnbG9iYWwgZm9yIGNhbGxiYWNrXG5cbiAgICAgIHdpbmRvdy50aGlzZm1pID0gdGhpcztcbiAgICAgIHRoaXMuZ2V0U2NyaXB0KHRoaXMuc3JjLCB0aGlzLmluaXRmbWkuYmluZCh0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vc3JjIGlzIHNwZWNpZmllZCwgdGh1cyBsb2FkIGl0IC0gYnJvd3NlciBsb2FkcyBpdCBhdCB0aGUgZW5kLCB0aHVzIGFkZGluZyB0aGUgcmVzdCBhcyBjYWxsYmFjayBhZnRlciBsb2FkZWRcbiAgICAgIGNvbnNvbGUubG9nKCdpbml0IGZtaSB3aXRob3V0IGxvYWRpbmcgc2NyaXB0OiBmbWluYW1lLCB0aGlzOicsIHRoaXMuZm1pbmFtZSwgdGhpcyk7XG4gICAgICB0aGlzLmluaXRmbWkoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb250cm9saWQpIHtcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuY29udHJvbGlkKS5hZGRFdmVudExpc3RlbmVyKCdmbWlzdGFydCcsIHRoaXMuaGFuZGxlU3RhcnQpO1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5jb250cm9saWQpLmFkZEV2ZW50TGlzdGVuZXIoJ2ZtaXN0b3AnLCB0aGlzLmhhbmRsZVN0b3ApO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5zaG93Y29udHJvbHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnNob3djb250cm9scyA9IHRoaXMuc2hvd2NvbnRyb2xzID09PSAndHJ1ZSc7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm1pcmVnaXN0ZXInLCB0aGlzLmhhbmRsZVJlZ2lzdGVyKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkb3N0ZXAnLCB0aGlzLmhhbmRsZVN0ZXApOyAvL3NlbmRpbmcgYXR0YWNoZWQgZXZlbnQgLSBzb21lIG1heSBkZXRlY3QgaXQgdG8gcmVnaXN0ZXIgaXQncyBvdXRwdSBsaXN0ZW5lciBpZiBhdHRhY2hlZCBiZWZvcmVcblxuICAgIGxldCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnZm1pYXR0YWNoZWQnKTtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfSAvL2RldGVjdHMgd2hldGhlciBzY3JpcHQgd2l0aCBGTVUgaXMgYWxyZWFkeSBsb2FkZWQsIGlmIG5vdCBpdCBhZGRzIGl0IHRvIERPTSBhbmQgbG9hZHNcbiAgLy9nZXQgc2NyaXB0IGVsZW1lbnQgYW5kIHJlZ2lzdGVycyAnb25sb2FkJyBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiB0aGUgc2NyaXB0IGlzIGxvYWRlZFxuXG5cbiAgZ2V0U2NyaXB0KHNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICAvL2NoZWNrIHdoZXRoZXIgdGhlIHNjcmlwdCBpcyBub3QgYWxyZWFkeSB0aGVyZVxuICAgIGlmIChBcnJheS5mcm9tKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKSkuZmlsdGVyKHggPT4geC5nZXRBdHRyaWJ1dGUoJ3NyYycpID09PSBzb3VyY2UpLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCdmbWkuZ2V0U2NyaXB0KCkgV0FSTklORywgc2NyaXB0IGlzIGFscmVhZHkgYWRkZWQgaW50byBET006Jywgc291cmNlKTsgLy9kbyBjYWxsYmFjaz9cblxuICAgICAgaWYgKGNhbGxiYWNrKSBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vY29uc29sZS5sb2coJ2ZtaSBnZXRzY3JpcHQoKScpO1xuXG5cbiAgICBsZXQgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgbGV0IHByaW9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICAgIHNjcmlwdC5hc3luYyA9IDE7XG5cbiAgICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc2NyaXB0LnJlYWR5U3RhdGUgfHwgL2xvYWRlZHxjb21wbGV0ZS8udGVzdChzY3JpcHQucmVhZHlTdGF0ZSkpIHtcbiAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBzY3JpcHQub25sb2FkID0gbnVsbDtcbiAgICAgICAgc2NyaXB0ID0gdW5kZWZpbmVkOyAvLyB0cnkgdG8gaW5zZXJ0IHNjcmlwdCBieSBvdGhlciBhcHAgZm9yIHByZXZpZXdpbmcgLSBzY3JpcHRzIG1pZ2h0IGJlIGluc2VydGVkIGludG8gRE9NXG5cbiAgICAgICAgaWYgKHdpbmRvdy5lZGl0b3JhcGkgJiYgdHlwZW9mIHdpbmRvdy5lZGl0b3JhcGkuaW5zZXJ0U2NyaXB0QnlJZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdpbnNlcnRpbmcgc2NyaXB0IGJ5IHRoaXJkcGFydHkgYXBpJyk7XG4gICAgICAgICAgd2luZG93LmVkaXRvcmFwaS5pbnNlcnRTY3JpcHRCeUlkKHNvdXJjZSwgJ2ZtaW9iai0nICsgc291cmNlKTtcbiAgICAgICAgfSAvL2RvIGNhbGxiYWNrIGV2ZW4gaWYgaXNBYm9ydCAtIHNjcmlwdHMgbWlnaHQgYmUgaW5zZXJ0ZWQgaW50byBET00gYnkgYW5vdGhlciBhcHBcblxuXG4gICAgICAgIGlmIChjYWxsYmFjaykgc2V0VGltZW91dChjYWxsYmFjaywgMTUwMCk7XG4gICAgICB9XG4gICAgfTsgLy9yZW1vdmUgb25yZWFkeXN0YXRlY2hhbmdlIC0gb25seSByZWxpYWJsZSBpbiBJRSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xOTI5NzQyL2Nhbi1zY3JpcHQtcmVhZHlzdGF0ZS1iZS10cnVzdGVkLXRvLWRldGVjdC10aGUtZW5kLW9mLWR5bmFtaWMtc2NyaXB0LWxvYWRpbmdcblxuXG4gICAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uIChfLCBpc0Fib3J0KSB7XG4gICAgICBpZiAoaXNBYm9ydCB8fCAhc2NyaXB0LnJlYWR5U3RhdGUgfHwgL2xvYWRlZHxjb21wbGV0ZS8udGVzdChzY3JpcHQucmVhZHlTdGF0ZSkpIHtcbiAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBzY3JpcHQub25sb2FkID0gbnVsbDtcbiAgICAgICAgc2NyaXB0ID0gdW5kZWZpbmVkOyAvL2RvIGNhbGxiYWNrIC0gc2NyaXB0cyBtaWdodCBiZSBpbnNlcnRlZCBpbnRvIERPTSBieSBhbm90aGVyIGFwcFxuXG4gICAgICAgIGlmICghaXNBYm9ydCAmJiBjYWxsYmFjaykgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNjcmlwdC5zcmMgPSB3aW5kb3cuYmRsQmFzZUhyZWYgPyB3aW5kb3cuYmRsQmFzZUhyZWYgKyBzb3VyY2UgOiBzb3VyY2U7XG4gICAgcHJpb3IucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBwcmlvcik7XG4gIH0gLy9tYWtlIGluc3Qgb2JqZWN0IGdsb2JhbGx5IC0gaW4gY2FzZSBvZiBnbG9iYWxzIChub24tc3JjKSBkZWNsYXJhdGlvblxuXG5cbiAgaW5pdGZtaSgpIHtcbiAgICBjb25zb2xlLmxvZygnZm1pIGluaXRmbWkoKScpO1xuICAgIGxldCB0aGF0ID0ge307XG4gICAgLyogZ2xvYmFsL2xvY2FsIGZtaW5hbWUgKi9cblxuICAgIGlmICh0aGlzLmZtaW5hbWUpIHtcbiAgICAgIHRoYXQuZm1pbmFtZSA9IHRoaXMuZm1pbmFtZTtcbiAgICAgIGNvbnNvbGUubG9nKCd1c2luZyBsb2NhbCBmbWkgaW5pdGZtaSgpIGZtaW5hbWUnLCB0aGF0LmZtaW5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL3RyeSB0byB1c2UgZ2xvYmFsIGZtaW5hbWVcbiAgICAgIHRoYXQuZm1pbmFtZSA9IHdpbmRvdy50aGlzZm1pLmZtaW5hbWU7XG4gICAgICBjb25zb2xlLmxvZygndXNpbmcgZ2xvYmFsIGZtaSBpbml0Zm1pKCkgZm1pbmFtZScsIHRoYXQuZm1pbmFtZSk7XG4gICAgfSAvL2J1ZyBmbXUgY29zaW11bGF0aW9uXG5cblxuICAgIHRoYXQuZm1pbmFtZSA9IHRoaXMuZm1pbmFtZTsgLy9jcmVhdGUgaW5zdGFuY2VcblxuICAgIGxldCBteWluc3QgPSB3aW5kb3dbdGhhdC5mbWluYW1lXSgpOyAvL0VNU0RLIHYgMy54IGNvbXBpbGVzIGZtdSB0byBQcm9taXNlIGJhc2VkIGFwaVxuXG4gICAgaWYgKG15aW5zdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIG15aW5zdC50aGVuKGluc3QgPT4ge1xuICAgICAgICB0aGF0Lmluc3QgPSBpbnN0O1xuXG4gICAgICAgIGlmICghd2luZG93LmZtaWluc3QpIHtcbiAgICAgICAgICB3aW5kb3cuZm1paW5zdCA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93LmZtaWluc3RbdGhhdC5mbWluYW1lXSA9IHRoYXQ7IC8vY29uc29sZS5sb2coJ2ZtaSBjYWxsYmFjayBmcm9tIFByb21pc2UgdGhhdCcsIHRoYXQsIHRoYXQuaW5zdCk7XG4gICAgICAgIC8vZG8gb25lIHN0ZXAgaWYgbW9kZSBpcyBvbmVzdGVwXG4gICAgICAgIC8vaHR0cHM6Ly9uZXdiZWRldi5jb20vcGFzcy1jb3JyZWN0LXRoaXMtY29udGV4dC10by1zZXR0aW1lb3V0LWNhbGxiYWNrXG4gICAgICAgIC8vVE9ETyBjaGVjayBpZiB0aGlzIHN0ZXAvc2hvdCBpcyBuZWVkZWRcblxuICAgICAgICBpZiAod2luZG93LnRoaXNmbWkuaXNPbmVzdGVwKSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZygnb25lc3RlcCBzY2hlZHVsaW5nIHN0YXJ0ZXZlbnQgaW4gcHJvbWlzZSgpIHRvIGRvIHN0ZXAoKScpXG4gICAgICAgICAgc2V0VGltZW91dCh3aW5kb3cudGhpc2ZtaS5zZW5kU3RhcnRFdmVudC5iaW5kKHdpbmRvdy50aGlzZm1pKSwgMTAwMCk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ29uZXN0ZXAgc2NoZWR1bGluZyBwcm9taXNlKCkgdG8gZG8gc3RlcCgpJyk7IC8vc2V0VGltZW91dCh3aW5kb3cudGhpc2ZtaS5zdGVwLmJpbmQod2luZG93LnRoaXNmbWkpLDE1MDApO1xuXG4gICAgICAgICAgd2luZG93LnRoaXNmbWkuZGVib3VuY2VTdGVwKCk7XG4gICAgICAgIH0gZWxzZSAvL2RvIHNpbXVsYXRpb24gc3RlcCBhZnRlciAxMDAgbXNcbiAgICAgICAgICBpZiAod2luZG93LnRoaXNmbWkuaXNPbmVzaG90KSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdvbmVzaG90IHNjaGVkdWxpbmcgc3RhcnRldmVudCBpbiBwcm9taXNlKCkgdG8gZG8gc3RlcCgpJylcbiAgICAgICAgICAgIHNldFRpbWVvdXQod2luZG93LnRoaXNmbWkuc2VuZFN0YXJ0RXZlbnQuYmluZCh3aW5kb3cudGhpc2ZtaSksIDgwMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnb25lc2hvdCBzY2hlZHVsaW5nIHByb21pc2UoKSB0byBkbyBzaG90KCkgYWZ0ZXIgNC41cycpOyAvL3NldFRpbWVvdXQod2luZG93LnRoaXNmbWkuc2hvdC5iaW5kKHdpbmRvdy50aGlzZm1pKSwxNTAwKTtcblxuICAgICAgICAgICAgd2luZG93LnRoaXNmbWkuZGVib3VuY2VTaG90KCk7XG4gICAgICAgICAgfSBlbHNlIC8vZG8gc2ltdWxhdGlvbiBzdGVwIGFmdGVyIDEwMCBtc1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRhZnRlciA+IDApIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dCh3aW5kb3cudGhpc2ZtaS5zdGFydHN0b3AuYmluZCh3aW5kb3cudGhpc2ZtaSksIDEwMDAgKiB0aGlzLnN0YXJ0YWZ0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vb2xkZXIgRU1TREsgcHJpb3IgMy54IGNvbXBpbGVzIGRpcmVjdGx5IHRvIGFwaSwga2VlcCBjb21wYXRpYmlsaXR5XG4gICAgICB0aGF0Lmluc3QgPSBteWluc3Q7XG5cbiAgICAgIGlmICghd2luZG93LmZtaWluc3QpIHtcbiAgICAgICAgd2luZG93LmZtaWluc3QgPSBbXTtcbiAgICAgIH1cblxuICAgICAgd2luZG93LmZtaWluc3RbdGhhdC5mbWluYW1lXSA9IHRoYXQ7IC8vY29uc29sZS5sb2coJ2ZtaSBjYWxsYmFjayB0aGF0LCB0aGF0Lmluc3QnLCB0aGF0LCB0aGF0Lmluc3QpO1xuICAgICAgLy9kbyBvbmUgc3RlcCBpZiBtb2RlIGlzIG9uZXN0ZXBcbiAgICAgIC8vaHR0cHM6Ly9uZXdiZWRldi5jb20vcGFzcy1jb3JyZWN0LXRoaXMtY29udGV4dC10by1zZXR0aW1lb3V0LWNhbGxiYWNrXG5cbiAgICAgIGlmICh3aW5kb3cudGhpc2ZtaS5pc09uZXN0ZXApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ29uZXN0ZXAgc2NoZWR1bGluZyBkaXJlY3Qobm9wcm9taXNlKSB0byBkbyBzdGVwKCknKTtcbiAgICAgICAgc2V0VGltZW91dCh3aW5kb3cudGhpc2ZtaS5zZW5kU3RhcnRFdmVudC5iaW5kKHdpbmRvdy50aGlzZm1pKSwgMTAwMCk7IC8vc2V0VGltZW91dCh3aW5kb3cudGhpc2ZtaS5zdGVwLmJpbmQod2luZG93LnRoaXNmbWkpLDE1MDApO1xuXG4gICAgICAgIF9sb2Rhc2guZGVmYXVsdC50aHJvdHRsZSh3aW5kb3cudGhpc2ZtaS5zdGVwLmJpbmQod2luZG93LnRoaXNmbWkpLCAxNTAwKTtcbiAgICAgIH0gZWxzZSAvL2RvIHNpbXVsYXRpb24gc3RlcCBhZnRlciAxMDAgbXNcbiAgICAgICAgaWYgKHdpbmRvdy50aGlzZm1pLmlzT25lc2hvdCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdvbmVzaG90IHNjaGVkdWxpbmcgZGlyZWN0KG5vcHJvbWlzZSkgdG8gZG8gc3RlcCgpJyk7XG4gICAgICAgICAgc2V0VGltZW91dCh3aW5kb3cudGhpc2ZtaS5zZW5kU3RhcnRFdmVudC5iaW5kKHdpbmRvdy50aGlzZm1pKSwgMTAwMCk7IC8vc2V0VGltZW91dCh3aW5kb3cudGhpc2ZtaS5zaG90LmJpbmQod2luZG93LnRoaXNmbWkpLDE1MDApO1xuXG4gICAgICAgICAgX2xvZGFzaC5kZWZhdWx0LnRocm90dGxlKHdpbmRvdy50aGlzZm1pLnNob3QuYmluZCh3aW5kb3cudGhpc2ZtaSksIDE1MDApO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhcnRhZnRlciA+IDApIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KHdpbmRvdy50aGlzZm1pLnNlbmRTdGFydEV2ZW50LmJpbmQod2luZG93LnRoaXNmbWkpLCAxMDAwICogdGhpcy5zdGFydGFmdGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGJpbmQoKSB7XG4gICAgdGhpcy5pc09uZXNob3QgPSB0aGlzLm1vZGUgPT09ICdvbmVzaG90JztcbiAgICB0aGlzLmlzT25lc3RlcCA9IHRoaXMubW9kZSA9PT0gJ29uZXN0ZXAnO1xuXG4gICAgaWYgKHRoaXMuaXNPbmVzdGVwKSB7XG4gICAgICB0aGlzLnNob3djb250cm9scyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzT25lc2hvdCkge1xuICAgICAgdGhpcy5zaG93Y29udHJvbHMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMuc3RvcHRpbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnN0b3B0aW1lID0gcGFyc2VGbG9hdCh0aGlzLnN0b3B0aW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMuc3RhcnR0aW1lID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5zdGFydHRpbWUgPSBwYXJzZUZsb2F0KHRoaXMuc3RhcnR0aW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMuc3RlcHNwZXJmcmFtZWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnN0ZXBzcGVyZnJhbWUgPSBwYXJzZUludCh0aGlzLnN0ZXBzcGVyZnJhbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5zdGFydGFmdGVyID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5zdGFydHRpbWUgPSBwYXJzZUZsb2F0KHRoaXMuc3RhcnRhZnRlcik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLmZwc2xpbWl0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5mcHNsaW1pdCA9IHBhcnNlRmxvYXQodGhpcy5mcHNsaW1pdCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLmZtdXNwZWVkID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5mbXVzcGVlZCA9IHBhcnNlSW50KHRoaXMuZm11c3BlZWQpO1xuICAgICAgdGhpcy5zdGVwU2l6ZSA9IHRoaXMuZm11c3BlZWQgKiAodHlwZW9mIHRoaXMuZnN0ZXBzaXplID09PSAnc3RyaW5nJyA/IHBhcnNlRmxvYXQodGhpcy5mc3RlcHNpemUpIDogdGhpcy5mc3RlcHNpemUpO1xuICAgIH1cbiAgfVxuXG4gIGRldGFjaGVkKCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZtaXJlZ2lzdGVyJywgdGhpcy5oYW5kbGVSZWdpc3Rlcik7XG5cbiAgICBpZiAodGhpcy5hbmltYXRpb25zdGFydGVkKSB7XG4gICAgICB0aGlzLnN0YXJ0c3RvcCgpO1xuICAgIH1cblxuICAgIHRoaXMuZGVyZWdpc3RlcklucHV0cygpO1xuXG4gICAgaWYgKHRoaXMuY29udHJvbGlkKSB7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmNvbnRyb2xpZCkucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm1pc3RhcnQnLCB0aGlzLmhhbmRsZVN0YXJ0KTtcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuY29udHJvbGlkKS5yZW1vdmVFdmVudExpc3RlbmVyKCdmbWlzdG9wJywgdGhpcy5oYW5kbGVTdG9wKTtcbiAgICB9XG5cbiAgICBpZiAod2luZG93LmVkaXRvcmFwaSAmJiB0eXBlb2Ygd2luZG93LmVkaXRvcmFwaS5yZW1vdmVTY3JpcHRCeUlkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zb2xlLmxvZygnaW5zZXJ0aW5nIHNjcmlwdCBieSB0aGlyZHBhcnR5IGFwaScpO1xuICAgICAgd2luZG93LmVkaXRvcmFwaS5yZW1vdmVTY3JpcHRCeUlkKHRoaXMuc3JjLCAnZm1pb2JqLScgKyB0aGlzLnNyYyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbXBsZW1lbnRzIGEgcnVkaW1lbnRhcnkgYnJvd3NlciBjb25zb2xlIGxvZ2dlciBmb3IgdGhlIEZNVS5cbiAgICovXG5cblxuICBjb25zb2xlTG9nZ2VyKGNvbXBvbmVudEVudmlyb25tZW50LCBpbnN0YW5jZU5hbWUsIHN0YXR1cywgY2F0ZWdvcnksIG1lc3NhZ2UsIG90aGVyKSB7XG4gICAgLyogRmlsbHMgdmFyaWFibGVzIGludG8gbWVzc2FnZSByZXR1cm5lZCBieSB0aGUgRk1VLCB0aGUgQyB3YXkgKi9cbiAgICBjb25zdCBmb3JtYXRNZXNzYWdlID0gKG1lc3NhZ2UxLCBvdGhlcjEpID0+IHtcbiAgICAgIC8vIGdldCBhIG5ldyBwb2ludGVyXG4gICAgICBsZXQgcHRyID0gdGhpcy5pbnN0Ll9tYWxsb2MoMSk7IC8vIGdldCB0aGUgc2l6ZSBvZiB0aGUgcmVzdWx0aW5nIGZvcm1hdGVkIG1lc3NhZ2VcblxuXG4gICAgICBsZXQgbnVtID0gdGhpcy5pbnN0Ll9zbnByaW50ZihwdHIsIDAsIG1lc3NhZ2UxLCBvdGhlcjEpO1xuXG4gICAgICB0aGlzLmluc3QuX2ZyZWUocHRyKTtcblxuICAgICAgbnVtKys7IC8vIFRPRE86IEVycm9yIGhhbmRsaW5nIG51bSA8IDBcblxuICAgICAgcHRyID0gdGhpcy5pbnN0Ll9tYWxsb2MobnVtKTtcblxuICAgICAgdGhpcy5pbnN0Ll9zbnByaW50ZihwdHIsIG51bSwgbWVzc2FnZTEsIG90aGVyMSk7IC8vIHJldHVybiBwb2ludGVyIHRvIHRoZSByZXN1bHRpbmcgbWVzc2FnZSBzdHJpbmdcblxuXG4gICAgICByZXR1cm4gcHRyO1xuICAgIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG5cblxuICAgIGNvbnNvbGUubG9nKCdGTVUoJyArIHRoaXMuaW5zdC5VVEY4VG9TdHJpbmcoaW5zdGFuY2VOYW1lKSArICc6JyArIHN0YXR1cyArICc6JyArIHRoaXMuaW5zdC5VVEY4VG9TdHJpbmcoY2F0ZWdvcnkpICsgJykgbXNnOiAnICsgdGhpcy5pbnN0LlVURjhUb1N0cmluZyhmb3JtYXRNZXNzYWdlKG1lc3NhZ2UsIG90aGVyKSkpO1xuXG4gICAgdGhpcy5pbnN0Ll9mcmVlKGZvcm1hdE1lc3NhZ2UpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICBjb25zb2xlLmxvZygnZm1pIGluaXRpYWxpemUoKScpO1xuICAgIHRoaXMuZm1pRW50ZXJJbml0KHRoaXMuZm1paW5zdCk7XG4gICAgdGhpcy5mbWlFeGl0SW5pdCh0aGlzLmZtaWluc3QpO1xuICB9XG5cbiAgaW5zdGFudGlhdGUoKSB7XG4gICAgY29uc29sZS5sb2coJ2ZtaSBpbnN0YW50aWF0ZSgpJyk7IC8vZmlyc3QgZGVmaW5lIEZNSSBBUEkgZnVuY3Rpb24gbmFtZXM7XG5cbiAgICBjb25zdCBzUmVzZXQgPSAnZm1pMlJlc2V0JztcbiAgICBjb25zdCBzSW5zdGFudGlhdGUgPSAnZm1pMkluc3RhbnRpYXRlJztcbiAgICBjb25zdCBzU2V0dXAgPSAnZm1pMlNldHVwRXhwZXJpbWVudCc7XG4gICAgY29uc3Qgc0VudGVyaW5pdCA9ICdmbWkyRW50ZXJJbml0aWFsaXphdGlvbk1vZGUnO1xuICAgIGNvbnN0IHNFeGl0aW5pdCA9ICdmbWkyRXhpdEluaXRpYWxpemF0aW9uTW9kZSc7XG4gICAgY29uc3Qgc1NldHJlYWwgPSAnZm1pMlNldFJlYWwnO1xuICAgIGNvbnN0IHNTZXRib29sZWFuID0gJ2ZtaTJTZXRCb29sZWFuJztcbiAgICBjb25zdCBzR2V0cmVhbCA9ICdmbWkyR2V0UmVhbCc7XG4gICAgY29uc3Qgc0dldGJvb2xlYW4gPSAnZm1pMkdldEJvb2xlYW4nO1xuICAgIGNvbnN0IHNEb3N0ZXAgPSAnZm1pMkRvU3RlcCc7XG4gICAgY29uc3Qgc0NyZWF0ZUNhbGxiYWNrID0gJ2NyZWF0ZUZtaTJDYWxsYmFja0Z1bmN0aW9ucyc7IC8vYWRkIGZtdXN0YXRlIHN1cHBvcnRcblxuICAgIGNvbnN0IHNHZXRGTVVTdGF0ZSA9ICdmbWkyR2V0Rk1VU3RhdGUnO1xuICAgIGNvbnN0IHNTZXRGTVVTdGF0ZSA9ICdmbWkyU2V0Rk1VU3RhdGUnO1xuICAgIGNvbnN0IHNGcmVlRk1VU3RhdGUgPSAnZm1pMkZyZWVGTVVTdGF0ZSc7XG4gICAgY29uc3Qgc1NlcmlhbGl6ZWRGTVVTdGF0ZVNpemUgPSAnZm1pMlNlcmlhbGl6ZWRGTVVTdGF0ZVNpemUnO1xuICAgIGNvbnN0IHNTZXJpYWxpemVGTVVTdGF0ZSA9ICdmbWkyU2VyaWFsaXplRk1VU3RhdGUnO1xuICAgIGNvbnN0IHNEZVNlcmlhbGl6ZUZNVVN0YXRlU2l6ZSA9ICdmbWkyRGVTZXJpYWxpemVGTVVTdGF0ZSc7XG4gICAgdGhpcy5zdGVwVGltZSA9IDA7XG4gICAgdGhpcy5zdGVwU2l6ZSA9IHRoaXMuZm11c3BlZWQgKiAodHlwZW9mIHRoaXMuZnN0ZXBzaXplID09PSAnc3RyaW5nJyA/IHBhcnNlRmxvYXQodGhpcy5mc3RlcHNpemUpIDogdGhpcy5mc3RlcHNpemUpO1xuICAgIHRoaXMubXlzdGVwID0gdGhpcy5zdGVwU2l6ZTsgLy9jb25zb2xlIGNhbGxiYWNrIHB0ciwgcGVyIGVtc3JpcHRlbiBjcmVhdGUgaW50IHB0ciB3aXRoIHNpZ25hdHVyZSB2aWlpaWlpXG5cbiAgICBpZiAod2luZG93LmZtaWluc3QgJiYgd2luZG93LmZtaWluc3RbdGhpcy5mbWluYW1lXSkgdGhpcy5pbnN0ID0gd2luZG93LmZtaWluc3RbdGhpcy5mbWluYW1lXS5pbnN0O2Vsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdmbWkgaW5zdGFudGlhdGUoKSBlcnJvciBpbml0Zm1pKCkgcHJvYmFibHkgbm90IGNhbGxlZCcpO1xuICAgIH0gLy9lbHNlIHRoaXMuaW5zdCA9IG51bGw7Ly9pZiAod2luZG93LnRoaXNmbWkpIHt0aGlzLmluc3QgPSB3aW5kb3cudGhpc2ZtaS5pbnN0O31cblxuICAgIGNvbnNvbGUubG9nKCdpbnN0YW50aWF0ZSgpIHRoaXMuaW5zdCcsIHRoaXMuaW5zdCk7IC8vc2V0IHRoZSBmbWluYW1lIGFuZCBKUyBXQVNNIGZ1bmN0aW9uIHJlZmVyZW5jZXNcblxuICAgIGxldCBzZXBhcmF0b3IgPSAnXyc7XG4gICAgbGV0IHByZWZpeCA9IHRoaXMuZm1pbmFtZTsgLy9jb25zb2xlLmxvZygnYXR0YWNoZWQgZm1pbmFtZTonLCB0aGF0LmZtaW5hbWUpO1xuICAgIC8vIE9wZW5Nb2RlbGljYSBleHBvcnRzIGZ1bmN0aW9uIG5hbWVzIHdpdGhvdXQgcHJlZml4XG5cbiAgICBpZiAodHlwZW9mIHRoaXMuaW5zdC5fZm1pMkdldFZlcnNpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByZWZpeCA9ICcnO1xuICAgICAgc2VwYXJhdG9yID0gJyc7XG4gICAgfSAvL25vdyB1c2UgYSAnY3dyYXAnIGRlbGl2ZXJlZCBieSBlbXNjcmlwdGVuIHRvIGZhY2lsaXRhdGUgY2FsbGluZyBDIGZ1bmN0aW9ucyB3aXRoIEMgcHJpbWl0aXZlcyAoc3RyaW5nLG51bWJlcikgZnJvbSBKYXZhc2NyaXB0XG5cblxuICAgIHRoaXMuZm1pQ3JlYXRlQ2FsbGJhY2sgPSB0aGlzLmluc3QuY3dyYXAoc0NyZWF0ZUNhbGxiYWNrLCAnbnVtYmVyJywgWydudW1iZXInXSk7XG4gICAgdGhpcy5mbWlSZXNldCA9IHRoaXMuaW5zdC5jd3JhcChwcmVmaXggKyBzZXBhcmF0b3IgKyBzUmVzZXQsICdudW1iZXInLCBbJ251bWJlciddKTtcbiAgICB0aGlzLmZtaUluc3RhbnRpYXRlID0gdGhpcy5pbnN0LmN3cmFwKHByZWZpeCArIHNlcGFyYXRvciArIHNJbnN0YW50aWF0ZSwgJ251bWJlcicsIFsnc3RyaW5nJywgJ251bWJlcicsICdzdHJpbmcnLCAnc3RyaW5nJywgJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJ10pO1xuICAgIHRoaXMuZm1pU2V0dXAgPSB0aGlzLmluc3QuY3dyYXAocHJlZml4ICsgc2VwYXJhdG9yICsgc1NldHVwLCAnbnVtYmVyJywgWydudW1iZXInLCAnbnVtYmVyJywgJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJywgJ251bWJlciddKTtcbiAgICB0aGlzLmZtaUVudGVySW5pdCA9IHRoaXMuaW5zdC5jd3JhcChwcmVmaXggKyBzZXBhcmF0b3IgKyBzRW50ZXJpbml0LCAnbnVtYmVyJywgWydudW1iZXInXSk7XG4gICAgdGhpcy5mbWlFeGl0SW5pdCA9IHRoaXMuaW5zdC5jd3JhcChwcmVmaXggKyBzZXBhcmF0b3IgKyBzRXhpdGluaXQsICdudW1iZXInLCBbJ251bWJlciddKTtcbiAgICB0aGlzLmZtaVNldFJlYWwgPSB0aGlzLmluc3QuY3dyYXAocHJlZml4ICsgc2VwYXJhdG9yICsgc1NldHJlYWwsICdudW1iZXInLCBbJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJywgJ251bWJlciddKTtcbiAgICB0aGlzLmZtaUdldFJlYWwgPSB0aGlzLmluc3QuY3dyYXAocHJlZml4ICsgc2VwYXJhdG9yICsgc0dldHJlYWwsICdudW1iZXInLCBbJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJywgJ251bWJlciddKTtcbiAgICB0aGlzLmZtaVNldEJvb2xlYW4gPSB0aGlzLmluc3QuY3dyYXAocHJlZml4ICsgc2VwYXJhdG9yICsgc1NldGJvb2xlYW4sICdudW1iZXInLCBbJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJywgJ251bWJlciddKTtcbiAgICB0aGlzLmZtaUdldEJvb2xlYW4gPSB0aGlzLmluc3QuY3dyYXAocHJlZml4ICsgc2VwYXJhdG9yICsgc0dldGJvb2xlYW4sICdudW1iZXInLCBbJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJywgJ251bWJlciddKTtcbiAgICB0aGlzLmZtaURvU3RlcCA9IHRoaXMuaW5zdC5jd3JhcChwcmVmaXggKyBzZXBhcmF0b3IgKyBzRG9zdGVwLCAnbnVtYmVyJywgWydudW1iZXInLCAnbnVtYmVyJywgJ251bWJlcicsICdudW1iZXInXSk7XG4gICAgdGhpcy5mbWlHZXRWZXJzaW9uID0gdGhpcy5pbnN0LmN3cmFwKHByZWZpeCArIHNlcGFyYXRvciArICdmbWkyR2V0VmVyc2lvbicsICdzdHJpbmcnKTtcbiAgICB0aGlzLmZtaUdldFR5cGVzUGxhdGZvcm0gPSB0aGlzLmluc3QuY3dyYXAocHJlZml4ICsgc2VwYXJhdG9yICsgJ2ZtaTJHZXRUeXBlc1BsYXRmb3JtJywgJ3N0cmluZycpO1xuICAgIHRoaXMuZm1pMkZyZWVJbnN0YW5jZSA9IHRoaXMuaW5zdC5jd3JhcChwcmVmaXggKyBzZXBhcmF0b3IgKyAnZm1pMkZyZWVJbnN0YW5jZScsICdudW1iZXInLCBbJ251bWJlciddKTsgLy9hZGQgZm11c3RhdGVcblxuICAgIHRoaXMuZm1pR2V0Rk1VU3RhdGUgPSB0aGlzLmluc3QuY3dyYXAocHJlZml4ICsgc2VwYXJhdG9yICsgc0dldEZNVVN0YXRlLCAnbnVtYmVyJywgWydudW1iZXInXSk7XG4gICAgdGhpcy5mbWlTZXRGTVVTdGF0ZSA9IHRoaXMuaW5zdC5jd3JhcChwcmVmaXggKyBzZXBhcmF0b3IgKyBzU2V0Rk1VU3RhdGUsICdudW1iZXInLCBbJ251bWJlciddKTtcbiAgICB0aGlzLmZtaUZyZWVGTVVTdGF0ZSA9IHRoaXMuaW5zdC5jd3JhcChwcmVmaXggKyBzZXBhcmF0b3IgKyBzRnJlZUZNVVN0YXRlLCAnbnVtYmVyJywgWydudW1iZXInXSk7XG4gICAgdGhpcy5mbWlTZXJpYWxpemVkRk1VU3RhdGVTaXplID0gdGhpcy5pbnN0LmN3cmFwKHByZWZpeCArIHNlcGFyYXRvciArIHNTZXJpYWxpemVkRk1VU3RhdGVTaXplLCAnbnVtYmVyJywgWydudW1iZXInXSk7XG4gICAgdGhpcy5mbWlTZXJpYWxpemVGTVVTdGF0ZSA9IHRoaXMuaW5zdC5jd3JhcChwcmVmaXggKyBzZXBhcmF0b3IgKyBzU2VyaWFsaXplRk1VU3RhdGUsICdudW1iZXInLCBbJ251bWJlciddKTtcbiAgICB0aGlzLmZtaURlU2VyaWFsaXplRk1VU3RhdGVTaXplID0gdGhpcy5pbnN0LmN3cmFwKHByZWZpeCArIHNlcGFyYXRvciArIHNEZVNlcmlhbGl6ZUZNVVN0YXRlU2l6ZSwgJ251bWJlcicsIFsnbnVtYmVyJ10pO1xuICAgIHRoaXMuaW5zdGFudGlhdGVkID0gZmFsc2U7IC8vY2FsY3VsYXRlIHBvdywgcG93ZXIgb2Ygc3RlcHNpemVcblxuICAgIHRoaXMucG93ID0gdGhpcy5zdGVwU2l6ZSA8IDEgPyAtTWF0aC5jZWlsKC1NYXRoLmxvZzEwKHRoaXMuc3RlcFNpemUpKSA6IE1hdGguY2VpbChNYXRoLmxvZzEwKHRoaXMuc3RlcFNpemUpKTsgLy91c2UgTWF0aC50cnVuYyA/P1xuICAgIC8vY29uc29sZS5sb2coJ2luc3RhbnRpYXRlKCkgdGhpcycsIHRoaXMpO1xuXG4gICAgdGhpcy5jb25zb2xlTG9nZ2VyUHRyID0gdGhpcy5pbnN0LmFkZEZ1bmN0aW9uKHRoaXMuY29uc29sZUxvZ2dlci5iaW5kKHRoaXMpLCAndmlpaWlpaScpO1xuICAgIHRoaXMuY2FsbGJhY2twdHIgPSB0aGlzLmZtaUNyZWF0ZUNhbGxiYWNrKHRoaXMuY29uc29sZUxvZ2dlclB0cik7IC8vY29uc29sZS5sb2coJ2ZtaW5hbWUnLHRoaXMuZm1pbmFtZSk7XG4gICAgLy9jb25zb2xlLmxvZygnZ3VpZCcsdGhpcy5ndWlkKTtcbiAgICAvL2NvbnNvbGUubG9nKCdjYWxsYmFja3B0cicsdGhpcy5jYWxsYmFja3B0cik7XG4gICAgLy9jb25zb2xlLmxvZygnZm1paW5zdGFudGlhdGUgZm5jOicsdGhpcy5mbWlJbnN0YW50aWF0ZSk7XG4gICAgLy9jcmVhdGUgaW5zdGFuY2Ugb2YgbW9kZWwgc2ltdWxhdGlvblxuXG4gICAgdGhpcy5mbWlpbnN0ID0gdGhpcy5mbWlJbnN0YW50aWF0ZSh0aGlzLmZtaW5hbWUsIHRoaXMuY29zaW11bGF0aW9uLCB0aGlzLmd1aWQsICcnLCB0aGlzLmNhbGxiYWNrcHRyLCAwLCAwKTsgLy9sYXN0IDEgZGVidWcsIDAgbm9kZWJ1Z1xuXG4gICAgdGhpcy5zZXR1cEV4cGVyaW1lbnQoKTtcbiAgfVxuXG4gIHNldHVwRXhwZXJpbWVudCgpIHtcbiAgICAvL3NldHVwIGV4cGVyaW1lbnRcbiAgICB0aGlzLmZtaVNldHVwKHRoaXMuZm1paW5zdCwgMSwgdGhpcy50b2xlcmFuY2UsIHRoaXMuc3RhcnR0aW1lLCAwKTtcbiAgICBjb25zb2xlLmxvZygnc2V0dXBFeHBlcmltZW50KCkgZm1paW5zdCcsIHRoaXMuZm1paW5zdCk7XG4gICAgdGhpcy5pbnN0YW50aWF0ZWQgPSB0cnVlO1xuICB9XG5cbiAgc2ltdWxhdGUoKSB7fVxuXG4gIHNldFJlYWwocXVlcnksIHZhbHVlLCBjb3VudCkge1xuICAgIGNvbnNvbGUubG9nKCdzZXRyZWFsIHF1ZXJ5LHZhbHVlLGNvdW50JywgcXVlcnksIHZhbHVlLCBjb3VudCk7XG4gICAgcmV0dXJuIHRoaXMuZm1pU2V0UmVhbCh0aGlzLmZtaWluc3QsIHF1ZXJ5LmJ5dGVPZmZzZXQsIGNvdW50LCB2YWx1ZS5ieXRlT2Zmc2V0KTtcbiAgfVxuXG4gIHNldEJvb2xlYW4ocXVlcnksIHZhbHVlLCBjb3VudCkge1xuICAgIHJldHVybiB0aGlzLmZtaVNldEJvb2xlYW4odGhpcy5mbWlpbnN0LCBxdWVyeS5ieXRlT2Zmc2V0LCBjb3VudCwgdmFsdWUuYnl0ZU9mZnNldCk7XG4gIH1cbiAgLyoqXG4gICAqIExvYWRzIFJlYWxzIGZyb20gRk1VXG4gICAqL1xuXG5cbiAgZ2V0UmVhbChxdWVyeSwgb3V0cHV0LCBjb3VudCkge1xuICAgIHJldHVybiB0aGlzLmZtaUdldFJlYWwodGhpcy5mbWlpbnN0LCBxdWVyeS5ieXRlT2Zmc2V0LCBjb3VudCwgb3V0cHV0LmJ5dGVPZmZzZXQpO1xuICB9XG4gIC8qKlxuICAgKiBMb2FkcyBCb29sZWFucyBmcm9tIEZNVVxuICAgKi9cblxuXG4gIGdldEJvb2xlYW4ocXVlcnksIG91dHB1dCwgY291bnQpIHtcbiAgICByZXR1cm4gdGhpcy5mbWlHZXRCb29sZWFuKHRoaXMuZm1paW5zdCwgcXVlcnkuYnl0ZU9mZnNldCwgY291bnQsIG91dHB1dC5ieXRlT2Zmc2V0KTtcbiAgfVxuXG4gIHN0YXJ0ZXZlbnQoZSkge1xuICAgIGNvbnNvbGUubG9nKCdmbWkgc3RhcnRldmVudCByZWNpZXZlZCcsIGUpOyAvL2lmICghdGhpcy5hbmltYXRpb25zdGFydGVkKSBcblxuICAgIHRoaXMucGVyZnN0YXJ0KCk7XG4gICAgdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgfVxuXG4gIHN0b3BldmVudChlKSB7XG4gICAgY29uc29sZS5sb2coJ2ZtaSBzdG9wZXZlbnQgcmVjaWV2ZWQnLCBlKTsgLy9pZiAodGhpcy5hbmltYXRpb25zdGFydGVkKSBcblxuICAgIHRoaXMuc3RvcFNpbXVsYXRpb24oKTtcbiAgICB0aGlzLnBlcmZlbmQoKTtcbiAgfSAvL2FjdGlvbiB0byBiZSBwZXJmb3JtZWQgd2hlbiBjbGlja2luZyB0aGUgcGxheS9wYXVzZSBidXR0b25cbiAgLy9zZW5kcyBmbWlzdGFydC9mbWlzdG9wIGV2ZW50IGFuZCBzdGFydHMvc3RvcHMgc2ltdWxhdGlvblxuXG5cbiAgc3RhcnRzdG9wKCkge1xuICAgIGlmICh0aGlzLmFuaW1hdGlvbnN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuc3RvcFNpbXVsYXRpb24oKTtcbiAgICAgIHRoaXMuc2VuZFN0b3BFdmVudCgpO1xuICAgICAgdGhpcy5wZXJmZW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGVyZnN0YXJ0KCk7XG4gICAgICB0aGlzLnNlbmRTdGFydEV2ZW50KCk7XG4gICAgICB0aGlzLnN0YXJ0U2ltdWxhdGlvbigpO1xuICAgIH1cbiAgfSAvL2RlZmluZXMgYWN0aW9uIHRvIGJlIGRvbmUgZHVyaW5nIGJyb3dzZXIgYW5pbWF0aW9uZnJhbWUgYW5kIHN0YXJ0c1xuXG5cbiAgc3RhcnRTaW11bGF0aW9uKCkge1xuICAgIHRoaXMuYW5pbWF0aW9uc3RhcnRlZCA9IHRydWU7XG4gICAgdGhpcy5mcHNJbnRlcnZhbCA9IDEwMDAgLyAoaXNOYU4odGhpcy5mcHNsaW1pdCkgPyBwYXJzZUludCh0aGlzLmZwc2xpbWl0LCAxMCkgOiB0aGlzLmZwc2xpbWl0KTtcbiAgICB0aGlzLnRoZW4gPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7IC8vcmVhZCBpbnB1dCB2YWx1ZXNcbiAgICAvL2RlZmluZSBwZXJmb3JtQW5pbWF0aW9uXG5cbiAgICBjb25zdCBwZXJmb3JtQW5pbWF0aW9uID0gbmV3dGltZSA9PiB7XG4gICAgICBpZiAoIXRoaXMuYW5pbWF0aW9uc3RhcnRlZCkgcmV0dXJuO1xuICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHBlcmZvcm1BbmltYXRpb24pO1xuXG4gICAgICBpZiAodGhpcy5mcHNsaW1pdCAmJiB0aGlzLmZwc2xpbWl0IDwgNjApIHtcbiAgICAgICAgaWYgKGlzTmFOKHRoaXMuZnBzbGltaXQpKSB0aGlzLmZwc2xpbWl0ID0gcGFyc2VJbnQodGhpcy5mcHNsaW1pdCwgMTApO1xuICAgICAgICB0aGlzLm5vdyA9IG5ld3RpbWU7IC8vY29uc29sZS5sb2coJ2xpbWl0aW5nIGZwcyB0byBmcHNsaW1pdCwgbmV3dGltZSwgbm93LCB0aGVuLCBmcHNpbnRlcnZhbCcsIHRoaXMuZnBzbGltaXQsIG5ld3RpbWUsIHRoaXMubm93LCB0aGlzLnRoZW4sIHRoaXMuZnBzSW50ZXJ2YWwpO1xuXG4gICAgICAgIHRoaXMuZWxhcHNlZCA9IHRoaXMubm93IC0gdGhpcy50aGVuOyAvL2NvbnNvbGUubG9nKCdlbGFwc2VkLGZwc2ludGVydmFsJywgdGhpcy5lbGFwc2VkLCB0aGlzLmZwc0ludGVydmFsKTtcblxuICAgICAgICBpZiAodGhpcy5lbGFwc2VkID4gdGhpcy5mcHNJbnRlcnZhbCkge1xuICAgICAgICAgIHRoaXMudGhlbiA9IHRoaXMubm93IC0gdGhpcy5lbGFwc2VkICUgdGhpcy5mcHNJbnRlcnZhbDtcbiAgICAgICAgICB0aGlzLnN0ZXAoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0ZXBzcGVyZnJhbWU7IGkrKykgdGhpcy5zdGVwKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHBlcmZvcm1BbmltYXRpb24oKTtcbiAgfSAvL2NhbmNlbHMgYWxsIGFjdGlvbiB0byBiZSBkb25lIGR1cmluZyBicm93c2VyIGFuaW1hdGlvbmZyYW1lIGFuZCBzdGFydHNcblxuXG4gIHN0b3BTaW11bGF0aW9uKCkge1xuICAgIC8vc3RvcCBhbmltYXRpb25cbiAgICB0aGlzLmFuaW1hdGlvbnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJlcXVlc3QpO1xuICB9IC8vc2VuZHMgZm1pc3RvcCBldmVudFxuXG5cbiAgc2VuZFN0b3BFdmVudCgpIHtcbiAgICAvL2NyZWF0ZSBjdXN0b20gZXZlbnRcbiAgICBsZXQgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2ZtaXN0b3AnLCB7XG4gICAgICBkZXRhaWw6IHtcbiAgICAgICAgdGltZTogdGhpcy5yb3VuZCh0aGlzLnN0ZXBUaW1lLCB0aGlzLnBvdylcbiAgICAgIH1cbiAgICB9KTsgLy9kaXNwYXRjaCBldmVudCAtIGl0IHNob3VsZCBiZSBsaXN0ZW5lZCBieSBzb21lIG90aGVyIGNvbXBvbmVudFxuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCkuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cblxuICBzZW5kU3RhcnRFdmVudCgpIHtcbiAgICAvL2NyZWF0ZSBjdXN0b20gZXZlbnRcbiAgICBjb25zb2xlLmxvZygnZm1pLnNlbmRTdGFydEV2ZW50KCkuIFNlbmRpbmcgc3RhcnQgZXZlbnQgZm9yIGFkb2Jlb2JqJyk7XG4gICAgbGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmbWlzdGFydCcsIHtcbiAgICAgIGRldGFpbDoge1xuICAgICAgICB0aW1lOiB0aGlzLnJvdW5kKHRoaXMuc3RlcFRpbWUsIHRoaXMucG93KVxuICAgICAgfVxuICAgIH0pOyAvL2Rpc3BhdGNoIGV2ZW50IC0gaXQgc2hvdWxkIGJlIGxpc3RlbmVkIGJ5IHNvbWUgb3RoZXIgY29tcG9uZW50XG5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKS5kaXNwYXRjaEV2ZW50KGV2ZW50KTsgLy9hbmltYXRlIHVzaW5nIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICB9XG5cbiAgcm91bmQodmFsdWUsIGRlY2ltYWxzKSB7XG4gICAgaWYgKGRlY2ltYWxzIDwgMCkge1xuICAgICAgbGV0IHBvc2RlY2ltYWxzID0gLWRlY2ltYWxzO1xuICAgICAgcmV0dXJuIE51bWJlcihNYXRoLnJvdW5kKHZhbHVlICsgJ2UnICsgcG9zZGVjaW1hbHMpICsgJ2UtJyArIHBvc2RlY2ltYWxzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTnVtYmVyKE1hdGgucm91bmQodmFsdWUgKyAnZS0nICsgZGVjaW1hbHMpICsgJ2UrJyArIGRlY2ltYWxzKTtcbiAgfVxuXG4gIHN0ZXAoZSkge1xuICAgIC8vdGhpcyA9IHdpbmRvdy50aGlzZm1pO1xuICAgIC8vcHJpbWl0aXZlIHNlbWFwaG9yZSwgb25seSBvbmUgaW5zdGFuY2UgY2FuIHBlcmZvcm0gdGhpcyBjYWxsXG4gICAgaWYgKCF0aGlzLmRvaW5nc3RlcCkge1xuICAgICAgLy9jb25zb2xlLmxvZygnZm11IHN0ZXAoKScpO1xuICAgICAgdGhpcy5kb2luZ3N0ZXAgPSB0cnVlO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXRoaXMuaW5zdGFudGlhdGVkKSB7XG4gICAgICAgICAgdGhpcy5pbnN0YW50aWF0ZSgpO1xuICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGVwaSsrOyAvL2NoYW5nZWlucHV0c1xuXG4gICAgICAgIGlmICh0aGlzLnJlc2V0QmVmb3JlQ2hhbmdlKSB7XG4gICAgICAgICAgLy9mbWkgY2FsbFxuICAgICAgICAgIHRoaXMuc2V0dXBFeHBlcmltZW50KCk7IC8vZG8gcmVzZXRcblxuICAgICAgICAgIHRoaXMuZm1pUmVzZXQodGhpcy5mbWlpbnN0KTsgLy9zZXR0aW5nIGZpeGVkIHBhcmFtZXRlcnMgYXJlIG5vdyBhbGxvd2VkXG5cbiAgICAgICAgICB0aGlzLnNldElucHV0VmFyaWFibGVzKCk7IC8vaW5pdGlhbGl6ZVxuXG4gICAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7IC8vbWFrZSBiaWcgc3RlcCBmcm9tIDAgdG8gY3VycmVudCBzdGVwVGltZSA/Pz9cbiAgICAgICAgICAvL2NvbnN0IHJlcyA9XG4gICAgICAgICAgLy9tYWtlIGJpZyBzdGVwIG9ubHkgaWYgaXQgaXMgbm90IG9uZXN0ZXBcblxuICAgICAgICAgIGlmICghdGhpcy5pc09uZXN0ZXApIHRoaXMuZm1pRG9TdGVwKHRoaXMuZm1paW5zdCwgdGhpcy5zdGFydHRpbWUsIHRoaXMuc3RlcFRpbWUsIDEpO2Vsc2UgdGhpcy5zdGVwVGltZSA9IHRoaXMuc3RhcnR0aW1lOyAvL3Jlc2V0IHRoZSBzaWduYXR1cmVcblxuICAgICAgICAgIHRoaXMucmVzZXRCZWZvcmVDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL2RvIG9ubHkgY2hhbmdlIG9mIHZhcmlhYmxlc1xuICAgICAgICAgIHRoaXMuc2V0SW5wdXRWYXJpYWJsZXMoKTtcbiAgICAgICAgfSAvL2Rvc3RlcFxuICAgICAgICAvL2NvbXB1dGUgc3RlcCB0byByb3VuZCB0aGUgZGVzaXJlZCB0aW1lXG5cblxuICAgICAgICBjb25zdCByZXMgPSB0aGlzLmZtaURvU3RlcCh0aGlzLmZtaWluc3QsIHRoaXMuc3RlcFRpbWUsIHRoaXMubXlzdGVwLCAxKTtcbiAgICAgICAgdGhpcy5zdGVwVGltZSA9IHRoaXMuc3RlcFRpbWUgKyB0aGlzLm15c3RlcDtcbiAgICAgICAgdGhpcy5teXN0ZXAgPSB0aGlzLnN0ZXBTaXplOyAvL3VwZGF0ZSBjb3JyZWN0aW9uIHN0ZXAgdG8gY3VycmVudCBzdGVwXG5cbiAgICAgICAgaWYgKHJlcyA9PT0gMSB8fCByZXMgPT09IDIpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ3N0ZXAoKSByZXR1cm5lZCBzdGF0ZTw+MCwgZG9pbmcgcmVzZXQoKScsIHJlcyk7XG4gICAgICAgICAgdGhpcy5mbWlSZXNldCh0aGlzLmZtaWluc3QpO1xuICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB9IC8vZGlzdHJpYnV0ZSBzaW11bGF0aW9uIGRhdGEgdG8gbGlzdGVuZXJzXG5cblxuICAgICAgICB0aGlzLm15ZGF0YSA9IHRoaXMuZ2V0UmVhbHModGhpcy5yZWZlcmVuY2VzKTsgLy9jcmVhdGUgY3VzdG9tIGV2ZW50XG5cbiAgICAgICAgbGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmbWlkYXRhJywge1xuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgdGltZTogdGhpcy5yb3VuZCh0aGlzLnN0ZXBUaW1lLCB0aGlzLnBvdyksXG4gICAgICAgICAgICBkYXRhOiB0aGlzLm15ZGF0YVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vZGlzcGF0Y2ggZXZlbnQgLSBpdCBzaG91bGQgYmUgbGlzdGVuZWQgYnkgc29tZSBvdGhlciBjb21wb25lbnRcblxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKS5kaXNwYXRjaEV2ZW50KGV2ZW50KTsgLy9jb21wdXRlIHNob3d0aW1lXG5cbiAgICAgICAgaWYgKHRoaXMuc2hvd3RpbWUpIHRoaXMuc2ltdWxhdGlvbnRpbWUgPSB0aGlzLnNlY29uZHNUb1RpbWUodGhpcy5zdGVwVGltZSwgdGhpcy5zaG93dGltZW11bHRpcGx5KTsgLy9kbyBjb21wdXRhdGlvbiBvbmx5IGV2ZXJ5IHRpY2tzdG91cGRhdGUgdGlja1xuXG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVmcHMpIHtcbiAgICAgICAgICBpZiAodGhpcy5mcHN0aWNrID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZnBzdGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmZwc3RpY2srKztcblxuICAgICAgICAgIGlmICh0aGlzLmZwc3RpY2sgPj0gdGhpcy50aWNrc1RvVXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmZwc0ludGVydmFsID0gMTAwMCAvIChpc05hTih0aGlzLmZwc2xpbWl0KSA/IHBhcnNlSW50KHRoaXMuZnBzbGltaXQsIDEwKSA6IHRoaXMuZnBzbGltaXQpOyAvL3VwZGF0ZSB0aWNrcyAtIHNvIGl0IHdpbGwgYmUgZXZlcnkgMyBzZWNvbmRzXG5cbiAgICAgICAgICAgIHRoaXMudGlja3NUb1VwZGF0ZSA9IE1hdGgucm91bmQoMzAwMCAvIHRoaXMuZnBzSW50ZXJ2YWwpOyAvL2RvIGNvcnJlY3Rpb24gc3RlcCBjYWxjdWxhdGlvblxuXG4gICAgICAgICAgICBpZiAodGhpcy5zdGVwU2l6ZSA8IDEpIHtcbiAgICAgICAgICAgICAgdGhpcy5wb3cgPSAtTWF0aC5jZWlsKC1NYXRoLmxvZzEwKHRoaXMuc3RlcFNpemUpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMucG93ID0gTWF0aC5jZWlsKE1hdGgubG9nMTAodGhpcy5zdGVwU2l6ZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm15c3RlcCA9IHRoaXMucm91bmQodGhpcy5zdGVwVGltZSArIHRoaXMuc3RlcFNpemUsIHRoaXMucG93KSAtIHRoaXMuc3RlcFRpbWU7IC8vZG8gZnBzIGNhbGN1bGF0aW9uXG5cbiAgICAgICAgICAgIHRoaXMuZnBzID0gKDEwMDAgKiB0aGlzLnRpY2tzVG9VcGRhdGUgLyAod2luZG93LnBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5zdGFydGZwc3RpbWUpKS50b1ByZWNpc2lvbig0KTtcbiAgICAgICAgICAgIHRoaXMuZnBzdGljayA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vc3RvcCBzaW11bGF0aW9uIHdoZW4gc3RvcHRpbWUgaXMgZGVmaW5lZCBhbmQgcmVhY2hlZFxuXG5cbiAgICAgICAgaWYgKHRoaXMuc3RvcHRpbWUgPiAwICYmIHRoaXMuYW5pbWF0aW9uc3RhcnRlZCAmJiB0aGlzLnN0b3B0aW1lIDwgdGhpcy5zdGVwVGltZSkge1xuICAgICAgICAgIHRoaXMuc3RhcnRzdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdlcnJvciBjYXRjaGVkIGR1cmluZyBmbXUgc3RlcCcsIGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLmRvaW5nc3RlcCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNob3QoZSkge1xuICAgIGNvbnNvbGUubG9nKCdmbWkgLT4gc2hvdCgpJyk7IC8vY2hlY2sgd2hldGhlciBpbml0aWFsaXplZCBhbmQgaW5zdGFudGlhdGVkXG5cbiAgICBpZiAoIXRoaXMuaW5zdCkge1xuICAgICAgLy9ub3QgaW5zdGFudGlhdGVkXG4gICAgICBpZiAod2luZG93LmZtaWluc3QgJiYgd2luZG93LmZtaWluc3RbdGhpcy5mbWluYW1lXSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2ZtaSBzaG90KCkgbm90IGluc3RhbnRpYXRlZCwgZG8gaXQgZmlyc3QgdGltZScpO1xuICAgICAgICB0aGlzLmluc3RhbnRpYXRlKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9ubyBpbml0Zm1pKCkgY2FsbGVkID0gd2FpdCBmb3Igc2NyaXB0IHRvIGJlIGxvYWRlZCwgZG8gbm90aGluZ1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCdmbWkgc2hvdCgpIGRvaW5nIHJlc2V0Jyk7XG4gICAgICB0aGlzLnJlc2V0KCk7IC8vdGhpcy5zZXRJbnB1dFZhcmlhYmxlcygpO1xuICAgIH0gLy8gZG8gc3RlcHMgZnJvbSBzdGFydHRpbWUgdG8gc3RvcHRpbWVcblxuXG4gICAgZG8ge1xuICAgICAgdGhpcy5zdGVwKCk7XG4gICAgfSB3aGlsZSAodGhpcy5zdG9wdGltZSA+IHRoaXMuc3RlcFRpbWUpO1xuICB9XG5cbiAgc2V0SW5wdXRWYXJpYWJsZXMoKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHRoaXMuY2hhbmdlaW5wdXRzKSB7XG4gICAgICBsZXQgbXlpbnB1dHMgPSB0aGlzLmNoYW5nZWlucHV0c1trZXldOyAvL2NvbnNvbGUubG9nKCdjaGFuZ2luZyBpbnB1dHMnLCBteWlucHV0cyk7XG4gICAgICAvL3NldCByZWFsIC0gcmVmZXJlbmNlIGlzIGluIC0gb25lIGlucHV0IG9uZSByZWZlcmVuY2VcbiAgICAgIC8vc2V0cyBpbmRpdmlkdWFsIHZhbHVlcyAtIGlmIGlkIGlzIGluIGlucHV0LCB0aGVuIHJlZmVyZW5jZSBpcyB0YWtlbiBmcm9tIGlucHV0cyBkZWZpbml0aW9uXG5cbiAgICAgIGNvbnNvbGUubG9nKCdjaGFuZ2luZyBpbnB1dHMgZm9yIG15aW5wdXRzLmlkICcgKyBteWlucHV0cy5pZCArIFwiIHZhbHVlIFwiICsgbXlpbnB1dHMudmFsdWUsIHRoaXMuaW5wdXRyZWZlcmVuY2VzKTtcblxuICAgICAgaWYgKHRoaXMuaW5wdXRyZWZlcmVuY2VzW215aW5wdXRzLmlkXSkge1xuICAgICAgICBmb3IgKGxldCBpcmVmIG9mIHRoaXMuaW5wdXRyZWZlcmVuY2VzW215aW5wdXRzLmlkXS5yZWZzKSB7XG4gICAgICAgICAgbGV0IG5vcm1hbGl6ZWR2YWx1ZSA9IG15aW5wdXRzLnZhbHVlICogaXJlZi5udW1lcmF0b3IgLyBpcmVmLmRlbm9taW5hdG9yICsgaXJlZi5hZGRjb25zdDtcbiAgICAgICAgICBpZiAobXlpbnB1dHMuaWQpIHRoaXMuc2V0U2luZ2xlUmVhbChpcmVmLnJlZiwgbm9ybWFsaXplZHZhbHVlKTsgLy8gaWYgcmVmZXJlbmNlIGlzIGluIGlucHV0LCB0aGVuIGl0IGlzIHNldCBkaXJlY3RseVxuICAgICAgICAgIGVsc2UgaWYgKG15aW5wdXRzLnZhbHVlcmVmZXJlbmNlKSB0aGlzLnNldFNpbmdsZVJlYWwobXlpbnB1dHMudmFsdWVyZWZlcmVuY2UsIG5vcm1hbGl6ZWR2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZsdXNoUmVhbFF1ZXVlKCk7XG5cbiAgICBpZiAoIXRoaXMuaXNPbmVzaG90ICYmICF0aGlzLmlzT25lc3RlcCkge1xuICAgICAgLy9mb3JnZXQgaW5wdXRzIGluIGNvbnRpbnVvdXMgbW9kZVxuICAgICAgdGhpcy5jaGFuZ2VpbnB1dHMgPSB7fTtcbiAgICB9XG4gICAgLyppZiAodGhpcy5jaGFuZ2VpbnB1dHMubGVuZ3RoID4gMCkge1xuICAgICAgd2hpbGUgKHRoaXMuY2hhbmdlaW5wdXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IG15aW5wdXRzID0gdGhpcy5jaGFuZ2VpbnB1dHMuc2hpZnQoKTsgLy9yZW1vdmUgZmlyc3QgaXRlbVxuICAgICAgICAvL2NvbnNvbGUubG9nKCdjaGFuZ2luZyBpbnB1dHMnLCBteWlucHV0cyk7XG4gICAgICAgIC8vc2V0IHJlYWwgLSByZWZlcmVuY2UgaXMgaW4gLSBvbmUgaW5wdXQgb25lIHJlZmVyZW5jZVxuICAgICAgICAvL3NldHMgaW5kaXZpZHVhbCB2YWx1ZXMgLSBpZiBpZCBpcyBpbiBpbnB1dCwgdGhlbiByZWZlcmVuY2UgaXMgdGFrZW4gZnJvbSBpbnB1dHMgZGVmaW5pdGlvblxuICAgICAgICBjb25zb2xlLmxvZygnY2hhbmdpbmcgaW5wdXRzLGlkLHZhbHVlJywgdGhpcy5pbnB1dHJlZmVyZW5jZXMsIG15aW5wdXRzLmlkLCBteWlucHV0cy52YWx1ZSk7XG4gICAgICAgIGZvciAobGV0IGlyZWYgb2YgdGhpcy5pbnB1dHJlZmVyZW5jZXNbbXlpbnB1dHMuaWRdLnJlZnMpIHtcbiAgICAgICAgICBsZXQgbm9ybWFsaXplZHZhbHVlID0gbXlpbnB1dHMudmFsdWUgKiBpcmVmLm51bWVyYXRvciAvIGlyZWYuZGVub21pbmF0b3IgKyBpcmVmLmFkZGNvbnN0O1xuICAgICAgICAgIGlmIChteWlucHV0cy5pZCkgdGhpcy5zZXRTaW5nbGVSZWFsKGlyZWYucmVmLCBub3JtYWxpemVkdmFsdWUpO1xuICAgICAgICAgIC8vIGlmIHJlZmVyZW5jZSBpcyBpbiBpbnB1dCwgdGhlbiBpdCBpcyBzZXQgZGlyZWN0bHlcbiAgICAgICAgICBlbHNlIGlmIChteWlucHV0cy52YWx1ZXJlZmVyZW5jZSkgdGhpcy5zZXRTaW5nbGVSZWFsKG15aW5wdXRzLnZhbHVlcmVmZXJlbmNlLCBub3JtYWxpemVkdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL2ZsdXNoIGFsbCBpbiBvbmUgY2FsbCB0byBmbWlcbiAgICAgIHRoaXMuZmx1c2hSZWFsUXVldWUoKTtcbiAgICB9Ki9cblxuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgY29uc29sZS5sb2coJ2RvaW5nIHJlc2V0KCknKTtcbiAgICB0aGlzLnN0ZXBUaW1lID0gdGhpcy5zdGFydHRpbWU7XG4gICAgdGhpcy5zdGVwU2l6ZSA9IHRoaXMuZm11c3BlZWQgKiAodHlwZW9mIHRoaXMuZnN0ZXBzaXplID09PSAnc3RyaW5nJyA/IHBhcnNlRmxvYXQodGhpcy5mc3RlcHNpemUpIDogdGhpcy5mc3RlcHNpemUpO1xuICAgIHRoaXMubXlzdGVwID0gdGhpcy5zdGVwU2l6ZTtcbiAgICB0aGlzLnNldHVwRXhwZXJpbWVudCgpO1xuICAgIHRoaXMuZm1pUmVzZXQodGhpcy5mbWlpbnN0KTsgLy9zZXQgaW5wdXQgdmFyaWFibGVzIGZvciBwb3NzaWJsZSBjaGFuZ2Ugb2Ygbm9uLXR1bmFibGUgLSBmaXhlZCBwYXJhbWV0ZXIgdmFsdWVzXG5cbiAgICB0aGlzLnNldElucHV0VmFyaWFibGVzKCk7XG4gICAgdGhpcy5pbml0aWFsaXplKCk7IC8vY3JlYXRlIGN1c3RvbSBldmVudFxuXG4gICAgbGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmbWlyZXNldCcpOyAvL2Rpc3BhdGNoIGV2ZW50IC0gaXQgc2hvdWxkIGJlIGxpc3RlbmVkIGJ5IHNvbWUgb3RoZXIgY29tcG9uZW50XG5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxuXG4gIHNvZnRyZXNldCgpIHtcbiAgICB0aGlzLnN0ZXBUaW1lID0gdGhpcy5zdGFydHRpbWU7XG4gICAgdGhpcy5zdGVwU2l6ZSA9IHRoaXMuZm11c3BlZWQgKiAodHlwZW9mIHRoaXMuZnN0ZXBzaXplID09PSAnc3RyaW5nJyA/IHBhcnNlRmxvYXQodGhpcy5mc3RlcHNpemUpIDogdGhpcy5mc3RlcHNpemUpO1xuICAgIHRoaXMubXlzdGVwID0gdGhpcy5zdGVwU2l6ZTsgLy90aGlzLnNldHVwRXhwZXJpbWVudCgpO1xuICAgIC8vdGhpcy5mbWlSZXNldCh0aGlzLmZtaWluc3QpO1xuICAgIC8vc2V0IGlucHV0IHZhcmlhYmxlcyBmb3IgcG9zc2libGUgY2hhbmdlIG9mIG5vbi10dW5hYmxlIC0gZml4ZWQgcGFyYW1ldGVyIHZhbHVlc1xuXG4gICAgdGhpcy5zZXRJbnB1dFZhcmlhYmxlcygpOyAvL3RoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIC8vY3JlYXRlIGN1c3RvbSBldmVudFxuXG4gICAgbGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmbWlyZXNldCcpOyAvL2Rpc3BhdGNoIGV2ZW50IC0gaXQgc2hvdWxkIGJlIGxpc3RlbmVkIGJ5IHNvbWUgb3RoZXIgY29tcG9uZW50XG5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxuICAvKiByb3V0aW5lcyB0byBhbGxvYyBidWZmZXIgZm9yIGdldHRpbmcvc2V0dGluZyBmcm9tIGZtaSovXG5cblxuICBjcmVhdGVCdWZmZXIoYXJyKSB7XG4gICAgbGV0IHNpemUgPSBhcnIubGVuZ3RoICogYXJyLkJZVEVTX1BFUl9FTEVNRU5UO1xuXG4gICAgbGV0IHB0ciA9IHRoaXMuaW5zdC5fbWFsbG9jKHNpemUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHB0cixcbiAgICAgIHNpemVcbiAgICB9O1xuICB9XG5cbiAgY3JlYXRlQW5kRmlsbEJ1ZmZlcihhcnIpIHtcbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLmNyZWF0ZUJ1ZmZlcihhcnIpO1xuICAgIHRoaXMuZmlsbEJ1ZmZlcihidWZmZXIsIGFycik7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG4gIGZyZWVCdWZmZXIoYnVmZmVyKSB7XG4gICAgaWYgKGJ1ZmZlci5wdHIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuaW5zdC5fZnJlZShidWZmZXIucHRyKTtcbiAgICB9XG5cbiAgICBidWZmZXIucHRyID0gbnVsbDtcbiAgICBidWZmZXIuc2l6ZSA9IG51bGw7XG4gIH1cblxuICB2aWV3QnVmZmVyKGJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLmluc3QuSEVBUFU4LmJ1ZmZlciwgYnVmZmVyLnB0ciwgYnVmZmVyLnNpemUpO1xuICB9XG5cbiAgZmlsbEJ1ZmZlcihidWZmZXIsIGFycikge1xuICAgIGNvbnN0IHZpZXcgPSB0aGlzLnZpZXdCdWZmZXIoYnVmZmVyKTtcbiAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShhcnIuYnVmZmVyKSk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG4gIGdldFJlYWxzKHJlZmVyZW5jZXMpIHtcbiAgICBjb25zdCBxdWVyeUJ1ZmZlciA9IHRoaXMuY3JlYXRlQW5kRmlsbEJ1ZmZlcihuZXcgSW50MzJBcnJheShyZWZlcmVuY2VzKSk7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnZpZXdCdWZmZXIocXVlcnlCdWZmZXIpO1xuICAgIGNvbnN0IG91dHB1dEJ1ZmZlciA9IHRoaXMuY3JlYXRlQnVmZmVyKG5ldyBGbG9hdDY0QXJyYXkocmVmZXJlbmNlcy5sZW5ndGgpKTtcbiAgICBjb25zdCBvdXRwdXQgPSB0aGlzLnZpZXdCdWZmZXIob3V0cHV0QnVmZmVyKTtcbiAgICB0aGlzLmdldFJlYWwocXVlcnksIG91dHB1dCwgcmVmZXJlbmNlcy5sZW5ndGgpO1xuICAgIGNvbnN0IHJlYWwgPSBuZXcgRmxvYXQ2NEFycmF5KG91dHB1dC5idWZmZXIsIG91dHB1dC5ieXRlT2Zmc2V0LCByZWZlcmVuY2VzLmxlbmd0aCk7XG4gICAgdGhpcy5mcmVlQnVmZmVyKHF1ZXJ5QnVmZmVyKTtcbiAgICB0aGlzLmZyZWVCdWZmZXIob3V0cHV0QnVmZmVyKTtcbiAgICByZXR1cm4gcmVhbDtcbiAgfVxuXG4gIGdldFNpbmdsZVJlYWwocmVmZXJlbmNlKSB7XG4gICAgY29uc3QgcXVlcnlCdWZmZXIgPSB0aGlzLmNyZWF0ZUFuZEZpbGxCdWZmZXIobmV3IEludDMyQXJyYXkoW3JlZmVyZW5jZV0pKTtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMudmlld0J1ZmZlcihxdWVyeUJ1ZmZlcik7XG4gICAgY29uc3Qgb3V0cHV0QnVmZmVyID0gdGhpcy5jcmVhdGVCdWZmZXIobmV3IEZsb2F0NjRBcnJheSgxKSk7XG4gICAgY29uc3Qgb3V0cHV0ID0gdGhpcy52aWV3QnVmZmVyKG91dHB1dEJ1ZmZlcik7XG4gICAgdGhpcy5nZXRSZWFsKHF1ZXJ5LCBvdXRwdXQsIDEpO1xuICAgIGNvbnN0IHJlYWwgPSBuZXcgRmxvYXQ2NEFycmF5KG91dHB1dC5idWZmZXIsIG91dHB1dC5ieXRlT2Zmc2V0LCAxKTtcbiAgICB0aGlzLmZyZWVCdWZmZXIocXVlcnlCdWZmZXIpO1xuICAgIHRoaXMuZnJlZUJ1ZmZlcihvdXRwdXRCdWZmZXIpO1xuICAgIHJldHVybiByZWFsWzBdO1xuICB9XG4gIC8qKlxuICAgICAqIEFkZHMgYSByZWFsIHZhbHVlIHRvIHNldFJlYWxRdWV1ZVxuICAgICAqL1xuXG5cbiAgc2V0U2luZ2xlUmVhbChyZWZlcmVuY2UsIHZhbHVlKSB7XG4gICAgY29uc29sZS5sb2coJ3NldFNpbmdsZVJlYWwgcmVmZXJlbmNlLHZhbHVlJywgcmVmZXJlbmNlLCB2YWx1ZSk7XG5cbiAgICBpZiAoIXRoaXMuc2V0UmVhbFF1ZXVlKSB7XG4gICAgICB0aGlzLnNldFJlYWxRdWV1ZSA9IHtcbiAgICAgICAgcmVmZXJlbmNlczogW10sXG4gICAgICAgIHZhbHVlczogW11cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5zZXRSZWFsUXVldWUucmVmZXJlbmNlcy5wdXNoKHJlZmVyZW5jZSk7XG4gICAgdGhpcy5zZXRSZWFsUXVldWUudmFsdWVzLnB1c2godmFsdWUpO1xuICB9XG5cbiAgZmx1c2hSZWFsUXVldWUoKSB7XG4gICAgaWYgKHRoaXMuc2V0UmVhbFF1ZXVlKSB7XG4gICAgICBjb25zdCByZWZlcmVuY2VCdWZmZXIgPSB0aGlzLmNyZWF0ZUFuZEZpbGxCdWZmZXIobmV3IEludDMyQXJyYXkodGhpcy5zZXRSZWFsUXVldWUucmVmZXJlbmNlcykpO1xuICAgICAgY29uc3QgcmVmZXJlbmNlcyA9IHRoaXMudmlld0J1ZmZlcihyZWZlcmVuY2VCdWZmZXIpO1xuICAgICAgY29uc3QgdmFsdWVCdWZmZXIgPSB0aGlzLmNyZWF0ZUFuZEZpbGxCdWZmZXIobmV3IEZsb2F0NjRBcnJheSh0aGlzLnNldFJlYWxRdWV1ZS52YWx1ZXMpKTtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMudmlld0J1ZmZlcih2YWx1ZUJ1ZmZlcik7XG4gICAgICB0aGlzLnNldFJlYWwocmVmZXJlbmNlcywgdmFsdWVzLCB0aGlzLnNldFJlYWxRdWV1ZS5yZWZlcmVuY2VzLmxlbmd0aCk7XG4gICAgICB0aGlzLmZyZWVCdWZmZXIocmVmZXJlbmNlQnVmZmVyKTtcbiAgICAgIHRoaXMuZnJlZUJ1ZmZlcih2YWx1ZUJ1ZmZlcik7XG4gICAgICB0aGlzLnNldFJlYWxRdWV1ZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZsdXNoQm9vbGVhblF1ZXVlKCkge1xuICAgIGlmICh0aGlzLnNldEJvb2xlYW5RdWV1ZSkge1xuICAgICAgY29uc3QgcmVmZXJlbmNlQnVmZmVyID0gdGhpcy5jcmVhdGVBbmRGaWxsQnVmZmVyKG5ldyBJbnQzMkFycmF5KHRoaXMuc2V0Qm9vbGVhblF1ZXVlLnJlZmVyZW5jZXMpKTtcbiAgICAgIGNvbnN0IHJlZmVyZW5jZXMgPSB0aGlzLnZpZXdCdWZmZXIocmVmZXJlbmNlQnVmZmVyKTtcbiAgICAgIGNvbnN0IHZhbHVlQnVmZmVyID0gdGhpcy5jcmVhdGVBbmRGaWxsQnVmZmVyKG5ldyBJbnQzMkFycmF5KHRoaXMuc2V0Qm9vbGVhblF1ZXVlLnZhbHVlcykpO1xuICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy52aWV3QnVmZmVyKHZhbHVlQnVmZmVyKTtcbiAgICAgIHRoaXMuc2V0Qm9vbGVhbihyZWZlcmVuY2VzLCB2YWx1ZXMsIHRoaXMuc2V0Qm9vbGVhblF1ZXVlLnJlZmVyZW5jZXMubGVuZ3RoKTtcbiAgICAgIHRoaXMuZnJlZUJ1ZmZlcihyZWZlcmVuY2VCdWZmZXIpO1xuICAgICAgdGhpcy5mcmVlQnVmZmVyKHZhbHVlQnVmZmVyKTtcbiAgICAgIHRoaXMuc2V0Qm9vbGVhblF1ZXVlID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgICAqL1xuXG5cbiAgc2V0U2luZ2xlQm9vbGVhbihyZWZlcmVuY2UsIHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLnNldEJvb2xlYW5RdWV1ZSkge1xuICAgICAgdGhpcy5zZXRCb29sZWFuUXVldWUgPSB7XG4gICAgICAgIHJlZmVyZW5jZXM6IFtdLFxuICAgICAgICB2YWx1ZXM6IFtdXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuc2V0Qm9vbGVhblF1ZXVlLnJlZmVyZW5jZXMucHVzaChyZWZlcmVuY2UpO1xuICAgIHRoaXMuc2V0Qm9vbGVhblF1ZXVlLnZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICAgKiBMb2FkcyBhIHNpbmdsZSBib29sZWFuIHZhbHVlIGJhc2VkIG9uIHJlZmVyZW5jZSwgdGhpcyBpcyBhIHNob3J0aGFuZCBmdW5jdGlvbi5cbiAgICAgKiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgTW9kdWxlLmdldEJvb2xlYW4gd2l0aCByZXVzYWJsZSBtYWxsb2NzLlxuICAgICAqL1xuXG5cbiAgZ2V0U2luZ2xlQm9vbGVhbihyZWZlcmVuY2UpIHtcbiAgICBjb25zdCBxdWVyeUJ1ZmZlciA9IHRoaXMuY3JlYXRlQW5kRmlsbEJ1ZmZlcihuZXcgSW50MzJBcnJheShbcmVmZXJlbmNlXSkpO1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy52aWV3QnVmZmVyKHF1ZXJ5QnVmZmVyKTtcbiAgICBjb25zdCBvdXRwdXRCdWZmZXIgPSB0aGlzLmNyZWF0ZUJ1ZmZlcihuZXcgSW50MzJBcnJheSgxKSk7XG4gICAgY29uc3Qgb3V0cHV0ID0gdGhpcy52aWV3QnVmZmVyKG91dHB1dEJ1ZmZlcik7XG4gICAgdGhpcy5nZXRCb29sZWFuKHF1ZXJ5LCBvdXRwdXQsIDEpO1xuICAgIGNvbnN0IGJvb2wgPSBuZXcgSW50MzJBcnJheShvdXRwdXQuYnVmZmVyLCBvdXRwdXQuYnl0ZU9mZnNldCwgMSk7XG4gICAgdGhpcy5mcmVlQnVmZmVyKHF1ZXJ5QnVmZmVyKTtcbiAgICB0aGlzLmZyZWVCdWZmZXIob3V0cHV0QnVmZmVyKTtcbiAgICByZXR1cm4gYm9vbFswXTtcbiAgfVxuXG4gIGdldEJvb2xlYW5zKHJlZmVyZW5jZXMpIHtcbiAgICBjb25zdCBxdWVyeUJ1ZmZlciA9IHRoaXMuY3JlYXRlQW5kRmlsbEJ1ZmZlcihuZXcgSW50MzJBcnJheShyZWZlcmVuY2VzKSk7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnZpZXdCdWZmZXIocXVlcnlCdWZmZXIpO1xuICAgIGNvbnN0IG91dHB1dEJ1ZmZlciA9IHRoaXMuY3JlYXRlQnVmZmVyKG5ldyBJbnQzMkFycmF5KHJlZmVyZW5jZXMubGVuZ3RoKSk7XG4gICAgY29uc3Qgb3V0cHV0ID0gdGhpcy52aWV3QnVmZmVyKG91dHB1dEJ1ZmZlcik7XG4gICAgdGhpcy5nZXRCb29sZWFuKHF1ZXJ5LCBvdXRwdXQsIHJlZmVyZW5jZXMubGVuZ3RoKTtcbiAgICBjb25zdCBib29sID0gbmV3IEludDMyQXJyYXkob3V0cHV0LmJ1ZmZlciwgb3V0cHV0LmJ5dGVPZmZzZXQsIHJlZmVyZW5jZXMubGVuZ3RoKTtcbiAgICB0aGlzLmZyZWVCdWZmZXIocXVlcnlCdWZmZXIpO1xuICAgIHRoaXMuZnJlZUJ1ZmZlcihvdXRwdXRCdWZmZXIpO1xuICAgIHJldHVybiBib29sO1xuICB9XG5cbiAgc2Vjb25kc1RvVGltZShzZWMsIG11bHRpcGx5KSB7XG4gICAgaWYgKG11bHRpcGx5ID09PSB2b2lkIDApIHtcbiAgICAgIG11bHRpcGx5ID0gMTtcbiAgICB9XG5cbiAgICBsZXQgeCA9IE1hdGguZmxvb3Ioc2VjICogbXVsdGlwbHkpO1xuICAgIGxldCBzZWNvbmRzID0gTWF0aC5mbG9vcih4ICUgNjApLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICB4IC89IDYwO1xuICAgIGxldCBtaW51dGVzID0gTWF0aC5mbG9vcih4ICUgNjApLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICB4IC89IDYwO1xuICAgIGxldCBob3VycyA9IE1hdGguZmxvb3IoeCAlIDI0KS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgeCAvPSAyNDtcbiAgICBsZXQgZGF5cyA9IE1hdGguZmxvb3IoeCk7XG4gICAgcmV0dXJuICcgJyArIGRheXMgKyAnICcgKyBob3VycyArICc6JyArIG1pbnV0ZXMgKyAnOicgKyBzZWNvbmRzO1xuICB9XG5cbiAgcGVyZnN0YXJ0KCkge1xuICAgIHRoaXMucGVyZnN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gIH1cblxuICAvL291dHB1dHMgaG93IG1hbnkgcyB0aGUgc2ltdWxhdGlvbiB3YXMgcGVyZm9ybWVkIC0gYXQgdGhlIGVuZCBvZiBzaW11bGF0aW9uLCBnb29kIHRvIG1lYXN1cmUgcGVyZm9ybWFuY2VcbiAgcGVyZmVuZCgpIHtcbiAgICB0aGlzLnBlcmZlbmRUaW1lID0gbmV3IERhdGUoKTtcbiAgICB2YXIgdGltZURpZmYgPSB0aGlzLnBlcmZlbmRUaW1lIC0gdGhpcy5wZXJmc3RhcnRUaW1lOyAvL2luIG1zXG4gICAgLy8gc3RyaXAgdGhlIG1zXG5cbiAgICB0aW1lRGlmZiAvPSAxMDAwOyAvLyBnZXQgc2Vjb25kc1xuXG4gICAgY29uc29sZS53YXJuKFwiU2ltdWxhdGlvbiB0b29rIFwiICsgdGltZURpZmYgKyBcIiBzZWNvbmRzXCIpO1xuICB9XG5cbiAgZm11c3BlZWRDaGFuZ2VkKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5zdGVwU2l6ZSA9IHRoaXMuZm11c3BlZWQgKiAodHlwZW9mIHRoaXMuZnN0ZXBzaXplID09PSAnc3RyaW5nJyA/IHBhcnNlRmxvYXQodGhpcy5mc3RlcHNpemUpIDogdGhpcy5mc3RlcHNpemUpO1xuICB9XG5cbiAgZ2V0U3RhdGUoKSB7XG4gICAgbGV0IHNpemUgPSB0aGlzLmZtaVNlcmlhbGl6ZWRGTVVTdGF0ZVNpemUoKTtcbiAgICBsZXQgc3RhdHVzID0gdGhpcy5mbWlTZXJpYWxpemVGTVVTdGF0ZSh0aGlzLmZtaWluc3QsIGZtaXN0YXRlLCBzZXJpYWxpemVkc3RhdGUsIHNpemUpO1xuICB9XG5cbn0sIChfZGVzY3JpcHRvciA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJmbWluYW1lXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjIgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwidG9sZXJhbmNlXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMC4wMDAwMDE7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjMgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwic3RhcnR0aW1lXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufSksIF9kZXNjcmlwdG9yNCA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJzdG9wdGltZVwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjUgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiZ3VpZFwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59KSwgX2Rlc2NyaXB0b3I2ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImlkXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjcgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiaW5wdXRzXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjggPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwib3RoZXJpbnB1dHNcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yOSA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJ2YWx1ZXJlZmVyZW5jZXNcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMTAgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwidGlja3NUb1VwZGF0ZVwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDMwO1xuICB9XG59KSwgX2Rlc2NyaXB0b3IxMSA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJzcmNcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMTIgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiZnN0ZXBzaXplXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMC4wMTtcbiAgfVxufSksIF9kZXNjcmlwdG9yMTMgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiY29udHJvbGlkXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjE0ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcInNob3djb250cm9sc1wiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjE1ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImZwc2xpbWl0XCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gNjA7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjE2ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcInNob3d0aW1lXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjE3ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcInNob3d0aW1lbXVsdGlwbHlcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAxO1xuICB9XG59KSwgX2Rlc2NyaXB0b3IxOCA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJldmVudGxpc3RlblwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdpbnB1dCc7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjE5ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcIm1vZGVcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcImNvbnRpbnVvdXNcIjtcbiAgfVxufSksIF9kZXNjcmlwdG9yMjAgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwic3RlcHNwZXJmcmFtZVwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjIxID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcInN0YXJ0YWZ0ZXJcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAwO1xuICB9XG59KSwgX2Rlc2NyaXB0b3IyMiA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJmbXVzcGVlZFwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn0pKSwgX2NsYXNzKTtcbmV4cG9ydHMuRm1pID0gRm1pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm1pLmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/fmi\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/fmi.html":
/*!*************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/fmi.html ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = \"<template>\\n  <require from=\\\"./w3.css\\\"></require>\\n  <!--require from=\\\"font-awesome/css/font-awesome.min.css\\\"></require>\\n  <require from=\\\"font-awesome/fonts/fontawesome-webfont.woff\\\"></require>\\n  <require from=\\\"font-awesome/fonts/fontawesome-webfont.ttf\\\"></require>\\n  <require from=\\\"font-awesome/fonts/fontawesome-webfont.woff2\\\"></require-->\\n  <div show.bind=\\\"simplecontrols\\\">\\n    <button class=\\\"w3-button w3-theme\\\" click.delegate=\\\"startstop()\\\" title=\\\"Start/Stop simulation\\\"><i class.bind=\\\"animationstarted? 'fa fa-stop':'fa fa-play'\\\"></i> &nbsp;</button>\\n  </div>  \\n  <div show.bind=\\\"showcontrols\\\">\\n    <table>\\n      <tr>\\n        <td>\\n          <button class=\\\"w3-button w3-theme\\\" click.delegate=\\\"startstop()\\\" title=\\\"Start/Stop simulation\\\"><i class.bind=\\\"animationstarted? 'fa fa-stop':'fa fa-play'\\\"></i> &nbsp;</button>\\n        </td>\\n        <td>\\n          <button class=\\\"w3-button w3-theme\\\" click.delegate=\\\"step()\\\" title=\\\"Do simulation step\\\"><i class=\\\"fa fa-step-forward\\\"> <sub><b>1</b></sub></i> &nbsp;</button>\\n        </td>\\n        <td>\\n          <button class=\\\"w3-button w3-theme\\\" click.delegate=\\\"reset()\\\" title=\\\"Reset simulation\\\"><i class=\\\"fa fa-refresh\\\"></i> &nbsp;</button>\\n        </td>\\n        <td class=\\\"w3-tiny\\\">\\n          <table>\\n            <tr><td><input type=\\\"checkbox\\\" checked.bind=\\\"measurefps\\\"/>\\n              <i show.bind=\\\"measurefps\\\" title=\\\"FMI: ${fminame}\\\">FPS:${fps}</i></td>\\n              <td show.bind=\\\"measurefps\\\">\\n                <label><input type=\\\"radio\\\" name=\\\"fmuspeed\\\" checked.bind=\\\"fmuspeed\\\" model.bind=\\\"0.1\\\"/>0.1 x</label>\\n                <label><input type=\\\"radio\\\" name=\\\"fmuspeed\\\" checked.bind=\\\"fmuspeed\\\" model.bind=\\\"1\\\"/>1.0 x</label>\\n              </td>\\n            </tr>\\n            <tr><td show.bind=\\\"measurefps\\\"><input type=\\\"number\\\" min=\\\"1\\\" max=\\\"60\\\" value.bind=\\\"fpslimit\\\" style=\\\"width:8ch\\\" /></td>\\n              <td show.bind=\\\"measurefps\\\">\\n                <label><input type=\\\"radio\\\" name=\\\"fmuspeed\\\" checked.bind=\\\"fmuspeed\\\" model.bind=\\\"10\\\"/>10 x</label>\\n                <label><input type=\\\"radio\\\" name=\\\"fmuspeed\\\" checked.bind=\\\"fmuspeed\\\" model.bind=\\\"100\\\"/>100 x</label>\\n              </td>\\n            </tr>\\n          </table>\\n        </td>\\n        <td show.bind=\\\"showtime\\\">\\n          <table style=\\\"font-family:Consolas,'courier new';line-height: 1.0;\\\" title=\\\"simulation time\\\">\\n            <tr><td><span>d hh:mm:ss</span></td></tr>\\n            <tr><td><span>${simulationtime}</span></td></tr>\\n          </table>\\n        </td>\\n      </tr>\\n    </table>\\n  </div>\\n</template>\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2ZtaS5odG1sLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F1cmVsaWEtYm9keWxpZ2h0LXBsdWdpbi9kaXN0L25hdGl2ZS1tb2R1bGVzL2VsZW1lbnRzL2ZtaS5odG1sPzFjYWYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIjx0ZW1wbGF0ZT5cXG4gIDxyZXF1aXJlIGZyb209XFxcIi4vdzMuY3NzXFxcIj48L3JlcXVpcmU+XFxuICA8IS0tcmVxdWlyZSBmcm9tPVxcXCJmb250LWF3ZXNvbWUvY3NzL2ZvbnQtYXdlc29tZS5taW4uY3NzXFxcIj48L3JlcXVpcmU+XFxuICA8cmVxdWlyZSBmcm9tPVxcXCJmb250LWF3ZXNvbWUvZm9udHMvZm9udGF3ZXNvbWUtd2ViZm9udC53b2ZmXFxcIj48L3JlcXVpcmU+XFxuICA8cmVxdWlyZSBmcm9tPVxcXCJmb250LWF3ZXNvbWUvZm9udHMvZm9udGF3ZXNvbWUtd2ViZm9udC50dGZcXFwiPjwvcmVxdWlyZT5cXG4gIDxyZXF1aXJlIGZyb209XFxcImZvbnQtYXdlc29tZS9mb250cy9mb250YXdlc29tZS13ZWJmb250LndvZmYyXFxcIj48L3JlcXVpcmUtLT5cXG4gIDxkaXYgc2hvdy5iaW5kPVxcXCJzaW1wbGVjb250cm9sc1xcXCI+XFxuICAgIDxidXR0b24gY2xhc3M9XFxcInczLWJ1dHRvbiB3My10aGVtZVxcXCIgY2xpY2suZGVsZWdhdGU9XFxcInN0YXJ0c3RvcCgpXFxcIiB0aXRsZT1cXFwiU3RhcnQvU3RvcCBzaW11bGF0aW9uXFxcIj48aSBjbGFzcy5iaW5kPVxcXCJhbmltYXRpb25zdGFydGVkPyAnZmEgZmEtc3RvcCc6J2ZhIGZhLXBsYXknXFxcIj48L2k+ICZuYnNwOzwvYnV0dG9uPlxcbiAgPC9kaXY+ICBcXG4gIDxkaXYgc2hvdy5iaW5kPVxcXCJzaG93Y29udHJvbHNcXFwiPlxcbiAgICA8dGFibGU+XFxuICAgICAgPHRyPlxcbiAgICAgICAgPHRkPlxcbiAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJ3My1idXR0b24gdzMtdGhlbWVcXFwiIGNsaWNrLmRlbGVnYXRlPVxcXCJzdGFydHN0b3AoKVxcXCIgdGl0bGU9XFxcIlN0YXJ0L1N0b3Agc2ltdWxhdGlvblxcXCI+PGkgY2xhc3MuYmluZD1cXFwiYW5pbWF0aW9uc3RhcnRlZD8gJ2ZhIGZhLXN0b3AnOidmYSBmYS1wbGF5J1xcXCI+PC9pPiAmbmJzcDs8L2J1dHRvbj5cXG4gICAgICAgIDwvdGQ+XFxuICAgICAgICA8dGQ+XFxuICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcInczLWJ1dHRvbiB3My10aGVtZVxcXCIgY2xpY2suZGVsZWdhdGU9XFxcInN0ZXAoKVxcXCIgdGl0bGU9XFxcIkRvIHNpbXVsYXRpb24gc3RlcFxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXN0ZXAtZm9yd2FyZFxcXCI+IDxzdWI+PGI+MTwvYj48L3N1Yj48L2k+ICZuYnNwOzwvYnV0dG9uPlxcbiAgICAgICAgPC90ZD5cXG4gICAgICAgIDx0ZD5cXG4gICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwidzMtYnV0dG9uIHczLXRoZW1lXFxcIiBjbGljay5kZWxlZ2F0ZT1cXFwicmVzZXQoKVxcXCIgdGl0bGU9XFxcIlJlc2V0IHNpbXVsYXRpb25cXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1yZWZyZXNoXFxcIj48L2k+ICZuYnNwOzwvYnV0dG9uPlxcbiAgICAgICAgPC90ZD5cXG4gICAgICAgIDx0ZCBjbGFzcz1cXFwidzMtdGlueVxcXCI+XFxuICAgICAgICAgIDx0YWJsZT5cXG4gICAgICAgICAgICA8dHI+PHRkPjxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCIgY2hlY2tlZC5iaW5kPVxcXCJtZWFzdXJlZnBzXFxcIi8+XFxuICAgICAgICAgICAgICA8aSBzaG93LmJpbmQ9XFxcIm1lYXN1cmVmcHNcXFwiIHRpdGxlPVxcXCJGTUk6ICR7Zm1pbmFtZX1cXFwiPkZQUzoke2Zwc308L2k+PC90ZD5cXG4gICAgICAgICAgICAgIDx0ZCBzaG93LmJpbmQ9XFxcIm1lYXN1cmVmcHNcXFwiPlxcbiAgICAgICAgICAgICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XFxcInJhZGlvXFxcIiBuYW1lPVxcXCJmbXVzcGVlZFxcXCIgY2hlY2tlZC5iaW5kPVxcXCJmbXVzcGVlZFxcXCIgbW9kZWwuYmluZD1cXFwiMC4xXFxcIi8+MC4xIHg8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XFxcInJhZGlvXFxcIiBuYW1lPVxcXCJmbXVzcGVlZFxcXCIgY2hlY2tlZC5iaW5kPVxcXCJmbXVzcGVlZFxcXCIgbW9kZWwuYmluZD1cXFwiMVxcXCIvPjEuMCB4PC9sYWJlbD5cXG4gICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICA8dHI+PHRkIHNob3cuYmluZD1cXFwibWVhc3VyZWZwc1xcXCI+PGlucHV0IHR5cGU9XFxcIm51bWJlclxcXCIgbWluPVxcXCIxXFxcIiBtYXg9XFxcIjYwXFxcIiB2YWx1ZS5iaW5kPVxcXCJmcHNsaW1pdFxcXCIgc3R5bGU9XFxcIndpZHRoOjhjaFxcXCIgLz48L3RkPlxcbiAgICAgICAgICAgICAgPHRkIHNob3cuYmluZD1cXFwibWVhc3VyZWZwc1xcXCI+XFxuICAgICAgICAgICAgICAgIDxsYWJlbD48aW5wdXQgdHlwZT1cXFwicmFkaW9cXFwiIG5hbWU9XFxcImZtdXNwZWVkXFxcIiBjaGVja2VkLmJpbmQ9XFxcImZtdXNwZWVkXFxcIiBtb2RlbC5iaW5kPVxcXCIxMFxcXCIvPjEwIHg8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XFxcInJhZGlvXFxcIiBuYW1lPVxcXCJmbXVzcGVlZFxcXCIgY2hlY2tlZC5iaW5kPVxcXCJmbXVzcGVlZFxcXCIgbW9kZWwuYmluZD1cXFwiMTAwXFxcIi8+MTAwIHg8L2xhYmVsPlxcbiAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgPC90ZD5cXG4gICAgICAgIDx0ZCBzaG93LmJpbmQ9XFxcInNob3d0aW1lXFxcIj5cXG4gICAgICAgICAgPHRhYmxlIHN0eWxlPVxcXCJmb250LWZhbWlseTpDb25zb2xhcywnY291cmllciBuZXcnO2xpbmUtaGVpZ2h0OiAxLjA7XFxcIiB0aXRsZT1cXFwic2ltdWxhdGlvbiB0aW1lXFxcIj5cXG4gICAgICAgICAgICA8dHI+PHRkPjxzcGFuPmQgaGg6bW06c3M8L3NwYW4+PC90ZD48L3RyPlxcbiAgICAgICAgICAgIDx0cj48dGQ+PHNwYW4+JHtzaW11bGF0aW9udGltZX08L3NwYW4+PC90ZD48L3RyPlxcbiAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgPC90ZD5cXG4gICAgICA8L3RyPlxcbiAgICA8L3RhYmxlPlxcbiAgPC9kaXY+XFxuPC90ZW1wbGF0ZT5cXG5cIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/fmi.html\n");

/***/ })

}]);