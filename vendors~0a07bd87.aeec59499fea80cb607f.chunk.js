(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~0a07bd87"],{

/***/ "aurelia-bodylight-plugin/elements/chartjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.Chartjs = void 0;\nexports.myParseInt = myParseInt;\n\nvar _chart = _interopRequireDefault(__webpack_require__(/*! chart.js */ \"MO+k\"));\n\nvar _chartjsPluginDatalabels = _interopRequireDefault(__webpack_require__(/*! chartjs-plugin-datalabels */ \"qb46\"));\n\nvar _aureliaFramework = __webpack_require__(/*! aurelia-framework */ \"aurelia-framework\");\n\nvar _lodash = _interopRequireDefault(__webpack_require__(/*! lodash */ \"LvDl\"));\n\nvar _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16, _descriptor17, _descriptor18, _descriptor19, _descriptor20, _descriptor21, _descriptor22, _descriptor23, _descriptor24, _descriptor25, _descriptor26, _descriptor27;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\n//returns array of numbers if contains comma, or number - int\nfunction myParseInt(str, raddix) {\n  if (typeof str !== \"string\") return str;\n  if (str.lastIndexOf(',') > 0) return str.split(',').map(x => parseInt(x, raddix));else return parseInt(str, raddix);\n}\n\nlet Chartjs = (_class = class Chartjs {\n  //id to listen addsection event\n  //false - to keep width and height, true - to rescale\n  //time to throttle chart update, if it is too much at once\n  //min for y axis - if chart has this axis\n  //max for y axis - if chart has this axis\n  //whether to integrate with 3d babylonjs\n  //canvas obj name -\n  //index to shift the color\n  //index to shift the color\n  //may be configured by subclasses\n\n  /**\n   * initializes handlers for event processing - this is recommended way\n   */\n  constructor() {\n    _initializerDefineProperty(this, \"fromid\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"labels\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"refindex\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"refvalues\", _descriptor4, this);\n\n    _initializerDefineProperty(this, \"type\", _descriptor5, this);\n\n    _initializerDefineProperty(this, \"maxdata\", _descriptor6, this);\n\n    _initializerDefineProperty(this, \"initialdata\", _descriptor7, this);\n\n    _initializerDefineProperty(this, \"width\", _descriptor8, this);\n\n    _initializerDefineProperty(this, \"height\", _descriptor9, this);\n\n    _initializerDefineProperty(this, \"animate\", _descriptor10, this);\n\n    _initializerDefineProperty(this, \"id\", _descriptor11, this);\n\n    _initializerDefineProperty(this, \"ylabel\", _descriptor12, this);\n\n    _initializerDefineProperty(this, \"xlabel\", _descriptor13, this);\n\n    _initializerDefineProperty(this, \"convertors\", _descriptor14, this);\n\n    _initializerDefineProperty(this, \"verticalline\", _descriptor15, this);\n\n    _initializerDefineProperty(this, \"generatelabels\", _descriptor16, this);\n\n    _initializerDefineProperty(this, \"sectionid\", _descriptor17, this);\n\n    _initializerDefineProperty(this, \"responsive\", _descriptor18, this);\n\n    _initializerDefineProperty(this, \"throttle\", _descriptor19, this);\n\n    _initializerDefineProperty(this, \"precision\", _descriptor20, this);\n\n    _initializerDefineProperty(this, \"min\", _descriptor21, this);\n\n    _initializerDefineProperty(this, \"max\", _descriptor22, this);\n\n    _initializerDefineProperty(this, \"babylonjs\", _descriptor23, this);\n\n    _initializerDefineProperty(this, \"canvasobj\", _descriptor24, this);\n\n    _initializerDefineProperty(this, \"colorsegmentindex\", _descriptor25, this);\n\n    _initializerDefineProperty(this, \"colorindex\", _descriptor26, this);\n\n    _initializerDefineProperty(this, \"minichart\", _descriptor27, this);\n\n    this.indexsection = 0;\n    this.datalabels = false;\n    this.refindices = void 0;\n\n    this.handleValueChange = e => {\n      //sets data to dataset\n      //apply value convert among all data\n      let rawdata;\n\n      if (this.refindices) {\n        rawdata = this.refindices.map(x => e.detail.data[x]);\n      } else rawdata = e.detail.data.slice(this.refindex, this.refendindex); //if convert operation is defined as array\n\n\n      if (this.operation) {\n        for (let i = 0; i < rawdata.length; i++) {\n          //if particular operation is defined\n          if (this.operation[i]) rawdata[i] = this.operation[i](rawdata[i]);\n        }\n      }\n\n      this.chart.data.datasets[0].data = rawdata;\n      this.updatechart();\n    };\n\n    this.handleReset = e => {\n      console.log('handlereset2()');\n      if (this.chart.data.datasets) for (let dataset of this.chart.data.datasets) if (dataset && dataset.data) dataset.data = [];\n      if (this.chart.data.labels.length > 0) this.chart.data.labels = [];\n\n      if (this.sectionid) {\n        this.chart.config.options.section = [];\n        this.indexsection = 0;\n      }\n\n      this.updatechart(); //this.chart.config.options.section = [];\n    };\n\n    this.handleAddSection = e => {\n      this.addSection(e.detail.label);\n    };\n\n    this.handleFMIAttached = e => {\n      const fromel = document.getElementById(this.fromid);\n\n      if (fromel) {\n        fromel.addEventListener('fmidata', this.handleValueChange);\n        fromel.addEventListener('fmireset', this.handleReset);\n      } else {\n        console.warn('fmi attached, but no element with id found:', this.fromid);\n      }\n    };\n  }\n  /**\n   * Returns unique color per index- neighbouring colors are different using golden angle approximation\n   * @param index\n   * @returns {string} usable by CSS or DOM elements\n   */\n  //  const hue = (i - 1) * 137.508; // use golden angle approximation\n  //  var color = `hsl(${hue},85%,91%)`;\n\n\n  selectColor(index, saturation, lightness) {\n    if (saturation === void 0) {\n      saturation = 55;\n    }\n\n    if (lightness === void 0) {\n      lightness = 55;\n    }\n\n    const hue = (index - 1) * 137.508; // use golden angle approximation\n\n    return \"hsl(\" + hue + \",\" + saturation + \"%,\" + lightness + \"%)\";\n  }\n  /**\n   * process all attributes of <bdl-chart> component and sets appropriate settings of subesquent chartjs\n   */\n\n\n  bind() {\n    //console.log('chartjs bind');\n    if (typeof this.refindex == 'string' && this.refindex.indexOf(',') > 0) {\n      this.refindices = this.refindex.split(',');\n    } else {\n      this.refindex = myParseInt(this.refindex, 10);\n      this.refvalues = parseInt(this.refvalues, 10);\n      this.refendindex = this.refindex + this.refvalues;\n    } //empty plugins by default\n\n\n    this.plugins = []; //configure convertors - used to convert units received from fmi\n\n    if (this.convertors) {\n      let convertvalues = this.convertors.split(';');\n\n      let identity = x => x;\n\n      this.operation = [];\n\n      for (let i = 0; i < convertvalues.length; i++) {\n        if (convertvalues[i].includes(',')) {\n          //convert values are in form numerator,denominator contains comma ','\n          let convertitems = convertvalues[i].split(',');\n          if (convertitems[0] === '1' && convertitems[1] === '1') this.operation.push(identity);else {\n            let numerator = parseFloat(convertitems[0]);\n            let denominator = parseFloat(convertitems[1]);\n            let addend = convertitems.length > 2 ? parseFloat(convertitems[2]) : 0;\n            this.operation.push(x => x * numerator / denominator + addend);\n          }\n        } else {\n          //convert values are in form of expression, do not contain comma\n          if (convertvalues === '1/x') this.operation.push(x => 1 / x);else {\n            // for eval() security filter only allowed characters:\n            // algebraic, digits, e, dot, modulo, parenthesis and 'x' and 'e' is allowed\n            let expression = convertvalues[i].replace(/[^-\\d/*+.()%xe]/g, '');\n            console.log('chartjs bind(), evaluating expression:' + convertvalues[i] + ' securely filtered to :' + expression); // eslint-disable-next-line no-eval\n\n            this.operation.push(x => eval(expression));\n          }\n        }\n      }\n    } //sets boolean value - if verticalline attribute is set\n\n\n    if (typeof this.generatelabels === 'string') {\n      this.generatelabels = this.generatelabels === 'true';\n    }\n\n    if (typeof this.minichart === 'string') this.minichart = this.minichart === 'true';\n\n    if (typeof this.colorindex === 'string') {\n      this.colorindex = parseInt(this.colorindex, 10);\n    }\n\n    if (!this.colorindex) this.colorindex = 0; //in case not defined or null\n\n    if (typeof this.colorsegmentindex === 'string') {\n      this.colorsegmentindex = parseInt(this.colorsegmentindex, 10);\n    } //sets color of each dataset as different as possible\n    //and set initial data in chart\n    //set labels - separated by comma\n\n\n    if (this.labels) this.chlabels = this.labels.split(','); //else generate labels as 'variable 1' ...\n    else {\n      //this.chlabels = [...Array(this.refvalues)].map((_, i) => this.generatelabels ? `variable ${i}` : '');\n      //this seems not to be correctly transpilled to ES5, therefore following generator ->\n      this.chlabels = [];\n\n      for (let i = 0; i < this.refvalues; i++) {\n        let ilabel = this.generatelabels ? 'variable ' + i : '';\n        this.chlabels.push(ilabel);\n      }\n    }\n    this.colors = [];\n    let mydatastr = this.initialdata.split(',');\n    this.mydata = mydatastr.map(x => {\n      return parseFloat(x);\n    });\n    if (this.refindices) this.refvalues = this.refindices.length;\n\n    for (let i = 0; i < this.refvalues; i++) {\n      if (!this.mydata[i]) {//this.mydata.push(0);\n        //console.log('chartjs no data');\n      }\n\n      this.colors.push(this.selectColor(i + this.colorindex));\n    }\n\n    let datasets = [{\n      data: this.mydata,\n      backgroundColor: this.colors\n    }];\n    this.data = {\n      labels: this.chlabels,\n      datasets: datasets\n    }; //bind - string value to boolean\n\n    if (typeof this.animate === 'string') {\n      this.animate = this.animate === 'true';\n    }\n\n    if (typeof this.responsive === 'string') {\n      this.responsive = this.responsive === 'true';\n    } //set animation options\n\n\n    let animopts1 = {\n      animateScale: true,\n      animateRotate: true,\n      duration: 500\n    };\n    let animopts2 = {\n      duration: 0\n    }; //select options based on attribute value - whether to animate or not\n\n    let animopts = this.animate ? animopts1 : animopts2; //set labels for axes in chartjs opts\n\n    let axisopts = {};\n\n    if (this.ylabel) {\n      axisopts.yAxes = [{\n        scaleLabel: {\n          display: true,\n          labelString: this.ylabel\n        }\n      }];\n    }\n\n    if (this.xlabel) {\n      axisopts.xAxes = [{\n        scaleLabel: {\n          display: true,\n          labelString: this.xlabel\n        }\n      }];\n    }\n\n    if (this.minichart) {\n      if (axisopts.xAxes) axisopts.xAxes[0].display = false;else axisopts.xAxes = [{\n        display: false\n      }];\n      if (axisopts.yAxes) axisopts.yAxes[0].display = false;else axisopts.yAxes = [{\n        display: false\n      }];\n    } //initialize options - used later by chartjs instance\n\n\n    this.options = {\n      live: true,\n      responsive: this.responsive,\n      //true - rescale, false - will keep canvas width and height\n      legend: {\n        display: !this.minichart,\n        position: 'top'\n      },\n      animation: animopts,\n      tooltips: {\n        position: 'nearest',\n        mode: 'index',\n        intersect: false,\n        titleFontFamily: 'Open Sans',\n        backgroundColor: 'rgba(0,0,0,0.3)',\n        //titleFontColor: 'red',\n        caretSize: 5,\n        cornerRadius: 4,\n        xPadding: 3,\n        yPadding: 3,\n        callbacks: {\n          label: function (tooltipItem, data) {\n            //let label = data.labels[tooltipItem.index];\n            let value = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index]; //console.log('chartjs tooltip, value',tooltipItem,value);\n\n            if (typeof value === 'object') return value.x.toPrecision(4) + ':' + value.y.toPrecision(4);\n            if (typeof value === 'number') return value.toPrecision(4); //TODO this.precision is not accessible from here\n\n            return value;\n          }\n        }\n      },\n      hover: {\n        animationDuration: 0,\n        //disable animation on hover - e.g. for tooltips\n        intersect: false\n      },\n      scales: axisopts,\n      babylondynamictexture: \"\" // name of global dynamictextureobj to call update()\n\n    }; //sets boolean value - if verticalline attribute is set\n\n    if (typeof this.verticalline === 'string') {\n      this.verticalline = this.verticalline === 'true';\n    }\n\n    if (typeof this.maxdata === 'string') {\n      this.maxdata = parseInt(this.maxdata, 10);\n    } //if sections are requested - define chartjs plugin to draw it in background\n\n\n    if (this.sectionid) {\n      this.options.section = [];\n    }\n\n    if (this.min) {\n      //sets yscale min\n      if (!this.options) this.options = {};\n      if (!this.options.scales) this.options.scales = {};\n      if (!this.options.scales.yAxes) this.options.scales.yAxes = [{}]; //chartjs 2.9.4\n\n      if (!this.options.scales.yAxes[0].ticks) this.options.scales.yAxes[0].ticks = {}; //chartjs 2.9.4\n\n      this.options.scales.yAxes[0].ticks.min = parseFloat(this.min);\n    }\n\n    if (this.max) {\n      //sets yscale max\n      if (!this.options) this.options = {};\n      if (!this.options.scales) this.options.scales = {};\n      if (!this.options.scales.yAxes) this.options.scales.yAxes = [{}]; //chartjs 2.9.4\n\n      if (!this.options.scales.yAxes[0].ticks) this.options.scales.yAxes[0].ticks = {}; //chartjs 2.9.4\n\n      this.options.scales.yAxes[0].ticks.max = parseFloat(this.max); //if (this.min) this.options.scales.yAxes[0].ticks.stepSize = (this.options.scales.yAxes[0].ticks.max - this.options.scales.yAxes[0].ticks.min) / 10;\n    }\n\n    this.tooltips = ['mousemove', 'touchstart', 'touchmove', 'click'];\n    /*if (this.minichart) {\n      this.options.plugins.legend.display = false\n    }*/\n  }\n  /**\n   * this is called when the DOM is attached to view - instantiate the chartjs and sets all necesary binding\n   */\n\n\n  attached() {\n    //console.log('chartjs attached');\n    //listening to custom event fmidata and fmireset\n    const fromel = document.getElementById(this.fromid);\n\n    if (fromel) {\n      fromel.addEventListener('fmidata', this.handleValueChange);\n      fromel.addEventListener('fmireset', this.handleReset);\n    } else {\n      console.warn('chartjs, null fromid element, waiting to be attached');\n      document.addEventListener('fmiattached', this.handleFMIAttached);\n    }\n\n    if (this.sectionid) {\n      const sectionel = document.getElementById(this.sectionid);\n      if (sectionel) sectionel.addEventListener('addsection', this.handleAddSection);else console.log('chartjs WARNING, null sectionid element');\n    } //unregister\n\n\n    _chart.default.plugins.unregister(_chartjsPluginDatalabels.default); //for verticalline option - register controller for BdlChartjs\n\n\n    if (this.verticalline) {\n      _chart.default.defaults.LineWithLine = _chart.default.defaults.line;\n      _chart.default.controllers.LineWithLine = _chart.default.controllers.line.extend({\n        draw: function (ease) {\n          _chart.default.controllers.line.prototype.draw.call(this, ease);\n\n          if (this.chart.tooltip._active && this.chart.tooltip._active.length) {\n            let activePoint = this.chart.tooltip._active[0];\n            let ctx = this.chart.ctx;\n            let x = activePoint.tooltipPosition().x;\n            let topY = this.chart.legend.bottom;\n            let bottomY = this.chart.chartArea.bottom; // draw line\n\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(x, topY);\n            ctx.lineTo(x, bottomY);\n            ctx.lineWidth = 1;\n            ctx.strokeStyle = '#555';\n            ctx.stroke();\n            ctx.restore();\n          }\n        }\n      });\n    } //for sections register chartjs plugin\n\n\n    if (this.sectionid) {\n      _chart.default.pluginService.register({\n        beforeDraw: function (chart, easing) {\n          if (chart.config.options.section && chart.config.options.section.length > 0) {\n            let ctx = chart.chart.ctx;\n            let chartArea = chart.chartArea;\n            let meta = chart.getDatasetMeta(0);\n            let i;\n            ctx.save(); //console.log('chartjs sections', chart.config.options.section);\n\n            if (meta.data.length == 0) return; //first section\n\n            for (i = 1; i < chart.config.options.section.length; i++) {\n              //console.log('chartjs sectionplugin:i, section[i-1], section[1],start,stop)', i, chart.config.options.section[i - 1],chart.config.options.section[i]);\n              const startindex = chart.config.options.section[i - 1].index;\n              const stopindex = chart.config.options.section[i].index;\n              if (startindex >= meta.data.length) continue;\n              if (stopindex >= meta.data.length) continue;\n              let start = meta.data[startindex]._model.x;\n              let stop = meta.data[stopindex]._model.x;\n              /*const hue = (i - 1) * 137.508; // use golden angle approximation\n              ctx.fillStyle = `hsl(${hue},85%,91%)`;\n               */\n              //bar\n\n              ctx.fillStyle = chart.config.options.section[i - 1].color;\n              ctx.fillRect(start, chartArea.top, stop - start, chartArea.bottom - chartArea.top); //label\n              //ctx.translate(start, chartArea.top);\n              //ctx.rotate(Math.PI / 2);\n\n              ctx.save();\n              ctx.translate(start, chartArea.top);\n              ctx.rotate(90 * Math.PI / 180);\n              ctx.fillStyle = '#aaa';\n              ctx.font = '12px Helvetica';\n              ctx.fillText(chart.config.options.section[i - 1].label, 5, -5); //start, chartArea.top);\n\n              ctx.restore();\n            }\n\n            ctx.restore(); //console.log('last i',i);\n            //last section\n\n            i = chart.config.options.section.length;\n\n            if (i > 1 && chart.config.options.section[i - 1].index < meta.data.length - 1 && chart.config.options.section[i - 1].index < meta.data.length) {\n              //draw last section\n              let start = meta.data[chart.config.options.section[i - 1].index]._model.x;\n              let stop = meta.data[meta.data.length - 1]._model.x; //console.log (start,stop);\n\n              /*\n              const hue = (i - 1) * 137.508; // use golden angle approximation\n              var color = `hsl(${hue},85%,91%)`;\n               */\n\n              ctx.fillStyle = chart.config.options.section[i - 1].color; //console.log (chartArea);\n\n              ctx.fillRect(start, chartArea.top, stop - start, chartArea.bottom - chartArea.top);\n              ctx.save();\n              ctx.translate(start, chartArea.top);\n              ctx.rotate(90 * Math.PI / 180);\n              ctx.fillStyle = '#aaa';\n              ctx.font = '12px Helvetica';\n              ctx.fillText(chart.config.options.section[i - 1].label, 5, -5); //start, chartArea.top);\n\n              ctx.restore();\n            }\n          }\n        }\n      });\n    }\n\n    if (this.datalabels) {\n      console.log('datalabels true ,setting plugin', this.datalabels);\n      console.log('datalabels true ,setting plugin', this.datalabels);\n\n      _chart.default.pluginService.register({\n        afterDatasetsDraw: function (chartInstance, easing) {\n          // To only draw at the end of animation, check for easing === 1\n          //if (dataset && dataset.datalabels) {\n          let ctx = chartInstance.chart.ctx;\n          chartInstance.data.datasets.forEach(function (dataset, i) {\n            if (dataset && dataset.datalabels) {\n              let meta = chartInstance.getDatasetMeta(i);\n\n              if (!meta.hidden) {\n                meta.data.forEach(function (element, index) {\n                  if (dataset.datalabels[index].length > 0) {\n                    // Draw the text in black, with the specified font\n                    ctx.fillStyle = '#aaa';\n                    ctx.font = '12px Helvetica'; // Just naively convert to string for now\n\n                    let dataString = dataset.datalabels[index]; // Make sure alignment settings are correct\n\n                    ctx.textAlign = 'center';\n                    ctx.textBaseline = 'middle';\n                    let padding = 5;\n                    let position = element.tooltipPosition();\n                    ctx.fillText(dataString, position.x, position.y - 12 / 2 - padding);\n                  }\n                });\n              }\n            }\n          });\n        }\n      });\n    } //babylonjs bind\n\n    /*if (typeof this.babylonjs === 'string') {\n      //this.babylonjs = this.babylonjs === 'true';\n    } else this.babylonjs = false;*/\n\n\n    if (this.babylonjs) {\n      this.options.babylondynamictexture = this.babylonjs;\n\n      _chart.default.plugins.register({\n        beforeDraw: function (chartInstance) {\n          var ctx = chartInstance.chart.ctx; //console.log('ctx before draw:')\n\n          ctx.fillStyle = \"white\";\n          ctx.fillRect(0, 0, chartInstance.chart.width, chartInstance.chart.height);\n        },\n        afterDraw: function (chartInstance) {\n          var ctx = chartInstance.chart.ctx; //console.log('ctx after draw:')\n\n          if (window[chartInstance.options.babylondynamictexture]) window[chartInstance.options.babylondynamictexture].update();\n        }\n      });\n    } //canvasobj - if defined then use this object name to get canvas object -  otherwise the one from template\n\n\n    let ctx = this.canvasobj ? window[this.canvasobj] : this.chartcanvas.getContext('2d'); //ctx may be null if canvasobj is not yet initialized.\n\n    if (ctx) this.initChart(ctx); //init chart only if ctx is ready\n    else {\n      //add myself to lazyinitchart array\n      if (!window.lazyInitChart) window.lazyInitChart = [];\n      window.lazyInitChart.push(this);\n    }\n    /*\n        //do lazy init of charts after third party canvas initialization\n        if (window.lazyInitChart) {\n            for (let obj in window.lazyInitChart) obj.initChart().bind(obj);\n        }\n     */\n  }\n\n  initChart() {\n    let ctx = this.canvasobj ? window[this.canvasobj] : this.chartcanvas.getContext('2d');\n    initChart(ctx);\n  }\n\n  initChart(ctx) {\n    /*let that = this;\n    if (window.lazyInitChart) {let that = window.lazyInitChart;}*/\n    this.chart = new _chart.default(ctx, {\n      plugins: this.plugins,\n      type: this.type,\n      data: this.data,\n      options: this.options,\n      tooltipEvents: this.tooltips\n    }); //register throttled update function\n\n    if (typeof this.throttle === 'string') this.throttle = parseInt(this.throttle, 10);\n\n    if (this.throttle > 0) {\n      //throttle\n      this.updatechart = _lodash.default.throttle(this.chart.update.bind(this.chart), this.throttle);\n    } else {\n      //directly call chart update\n      this.updatechart = this.chart.update.bind(this.chart);\n    } // console.log('chartjs data', this.data);\n\n    /*    //now delay tooltip\n        let originalShowTooltip = that.chart.showTooltip;\n        //let that.timeout;\n        that.timeout=0;\n        that.chart.showTooltip = function (activeElements) {\n          let delay = (activeElements.length === 0) ? 2000 : 0;\n          clearTimeout(that.timeout);\n          that.timeout = setTimeout(function () {\n            originalShowTooltip.call(that.chart, activeElements);\n          }, delay);\n        }\n    \n     */\n\n  }\n  /**\n   * called when component is detached from view - remove event listeners - no need to update chart\n   */\n\n\n  detached() {\n    if (document.getElementById(this.fromid)) {\n      document.getElementById(this.fromid).removeEventListener('fmidata', this.handleValueChange);\n      document.getElementById(this.fromid).removeEventListener('fmireset', this.handleReset);\n    } else {\n      console.log('chartjs WARNING, null fromid element,removing from global');\n      document.removeEventListener('fmidata', this.handleValueChange);\n      document.removeEventListener('fmireset', this.handleReset);\n    }\n\n    if (this.sectionid) {\n      document.getElementById(this.sectionid).removeEventListener('addsection', this.handleAddSection);\n    }\n\n    document.removeEventListener('fmiattached', this.handleFMIAttached);\n  }\n  /**\n   * asks for filename and creates blob with CSV data from chart which initiates web browser download dialog.\n   * CSV -  time point per row\n   */\n\n\n  download() {\n    //ask for filename\n    let filename = prompt('File name (*.csv):', 'data.csv');\n\n    if (filename) {\n      //adds csv as extension\n      if (!filename.endsWith('.csv')) filename = filename.concat('.csv'); //labels first row\n\n      let content = 'Time,' + this.labels + '\\n'; //transpose each row = variable in specific time\n\n      for (let i = 0; i < this.chart.data.labels.length; i++) {\n        let row = this.chart.data.labels[i];\n\n        for (let j = 0; j < this.chart.data.datasets.length; j++) {\n          row += ',' + this.chart.data.datasets[j].data[i];\n        }\n\n        content += row + '\\n';\n      }\n\n      let blob = new Blob([content], {\n        type: 'text/csv;charset=utf-8;'\n      });\n      saveAs(blob, filename);\n    }\n  }\n  /**\n   * asks for filename and creates blob with CSV data from chart which initiates web browser download dialog\n   * CSV - variable values per row\n   */\n\n\n  downloadflat() {\n    //ask for filename\n    let filename = prompt('File name (*.csv):', 'data.csv');\n\n    if (filename) {\n      //adds csv as extension\n      if (!filename.endsWith('.csv')) filename = filename.concat('.csv'); //labels first row - each row is then all data per variable - transposition might be needed\n\n      let content = 'variable name,values ...' + '\\n';\n      let labels = this.labels.split(','); // variable per row\n      //chart labels - usually time\n\n      content = content + 'Time,' + this.chart.data.labels.join(',') + '\\n'; //dataset data on other rows\n\n      for (let i = 0; i < this.chart.data.datasets.length; i++) {\n        content = content + labels[i] + ',' + this.chart.data.datasets[i].data.join(',') + '\\n';\n      }\n\n      let blob = new Blob([content], {\n        type: 'text/csv;charset=utf-8;'\n      });\n      saveAs(blob, filename);\n    }\n  }\n  /**\n   * Adds new section in chartarea - current last data in dataset\n   */\n\n\n  addSection(label) {\n    if (label === void 0) {\n      label = '';\n    }\n\n    this.indexsection++;\n    if (!label) label = '';\n    console.log('chartjs.addsection()', this.chart.data.labels.length - 1, label);\n    let ind; //if (this.chart.data.labels.length>0) ind = 0\n    //else\n\n    ind = Math.max(0, this.chart.data.labels.length - 1);\n    this.chart.config.options.section.push({\n      index: ind,\n      color: this.selectColor(this.indexsection + this.colorsegmentindex, 85, 93),\n      label: label\n    });\n  }\n\n}, (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"fromid\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"labels\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"refindex\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, \"refvalues\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, \"type\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 'doughnut';\n  }\n}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, \"maxdata\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 256;\n  }\n}), _descriptor7 = _applyDecoratedDescriptor(_class.prototype, \"initialdata\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return '';\n  }\n}), _descriptor8 = _applyDecoratedDescriptor(_class.prototype, \"width\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 300;\n  }\n}), _descriptor9 = _applyDecoratedDescriptor(_class.prototype, \"height\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 200;\n  }\n}), _descriptor10 = _applyDecoratedDescriptor(_class.prototype, \"animate\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return false;\n  }\n}), _descriptor11 = _applyDecoratedDescriptor(_class.prototype, \"id\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor12 = _applyDecoratedDescriptor(_class.prototype, \"ylabel\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor13 = _applyDecoratedDescriptor(_class.prototype, \"xlabel\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor14 = _applyDecoratedDescriptor(_class.prototype, \"convertors\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor15 = _applyDecoratedDescriptor(_class.prototype, \"verticalline\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return false;\n  }\n}), _descriptor16 = _applyDecoratedDescriptor(_class.prototype, \"generatelabels\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return false;\n  }\n}), _descriptor17 = _applyDecoratedDescriptor(_class.prototype, \"sectionid\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor18 = _applyDecoratedDescriptor(_class.prototype, \"responsive\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return false;\n  }\n}), _descriptor19 = _applyDecoratedDescriptor(_class.prototype, \"throttle\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 200;\n  }\n}), _descriptor20 = _applyDecoratedDescriptor(_class.prototype, \"precision\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 4;\n  }\n}), _descriptor21 = _applyDecoratedDescriptor(_class.prototype, \"min\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor22 = _applyDecoratedDescriptor(_class.prototype, \"max\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor23 = _applyDecoratedDescriptor(_class.prototype, \"babylonjs\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor24 = _applyDecoratedDescriptor(_class.prototype, \"canvasobj\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor25 = _applyDecoratedDescriptor(_class.prototype, \"colorsegmentindex\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return -2;\n  }\n}), _descriptor26 = _applyDecoratedDescriptor(_class.prototype, \"colorindex\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 0;\n  }\n}), _descriptor27 = _applyDecoratedDescriptor(_class.prototype, \"minichart\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class);\nexports.Chartjs = Chartjs;\n//# sourceMappingURL=chartjs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2Rpc3QvbmF0aXZlLW1vZHVsZXMvZWxlbWVudHMvY2hhcnRqcy5qcz9lOWFmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5DaGFydGpzID0gdm9pZCAwO1xuZXhwb3J0cy5teVBhcnNlSW50ID0gbXlQYXJzZUludDtcblxudmFyIF9jaGFydCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNoYXJ0LmpzXCIpKTtcblxudmFyIF9jaGFydGpzUGx1Z2luRGF0YWxhYmVscyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHNcIikpO1xuXG52YXIgX2F1cmVsaWFGcmFtZXdvcmsgPSByZXF1aXJlKFwiYXVyZWxpYS1mcmFtZXdvcmtcIik7XG5cbnZhciBfbG9kYXNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoXCIpKTtcblxudmFyIF9jbGFzcywgX2Rlc2NyaXB0b3IsIF9kZXNjcmlwdG9yMiwgX2Rlc2NyaXB0b3IzLCBfZGVzY3JpcHRvcjQsIF9kZXNjcmlwdG9yNSwgX2Rlc2NyaXB0b3I2LCBfZGVzY3JpcHRvcjcsIF9kZXNjcmlwdG9yOCwgX2Rlc2NyaXB0b3I5LCBfZGVzY3JpcHRvcjEwLCBfZGVzY3JpcHRvcjExLCBfZGVzY3JpcHRvcjEyLCBfZGVzY3JpcHRvcjEzLCBfZGVzY3JpcHRvcjE0LCBfZGVzY3JpcHRvcjE1LCBfZGVzY3JpcHRvcjE2LCBfZGVzY3JpcHRvcjE3LCBfZGVzY3JpcHRvcjE4LCBfZGVzY3JpcHRvcjE5LCBfZGVzY3JpcHRvcjIwLCBfZGVzY3JpcHRvcjIxLCBfZGVzY3JpcHRvcjIyLCBfZGVzY3JpcHRvcjIzLCBfZGVzY3JpcHRvcjI0LCBfZGVzY3JpcHRvcjI1LCBfZGVzY3JpcHRvcjI2LCBfZGVzY3JpcHRvcjI3O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7IGlmICghZGVzY3JpcHRvcikgcmV0dXJuOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgeyBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsIHdyaXRhYmxlOiBkZXNjcmlwdG9yLndyaXRhYmxlLCB2YWx1ZTogZGVzY3JpcHRvci5pbml0aWFsaXplciA/IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMCB9KTsgfVxuXG5mdW5jdGlvbiBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHksIGRlY29yYXRvcnMsIGRlc2NyaXB0b3IsIGNvbnRleHQpIHsgdmFyIGRlc2MgPSB7fTsgT2JqZWN0LmtleXMoZGVzY3JpcHRvcikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGRlc2Nba2V5XSA9IGRlc2NyaXB0b3Jba2V5XTsgfSk7IGRlc2MuZW51bWVyYWJsZSA9ICEhZGVzYy5lbnVtZXJhYmxlOyBkZXNjLmNvbmZpZ3VyYWJsZSA9ICEhZGVzYy5jb25maWd1cmFibGU7IGlmICgndmFsdWUnIGluIGRlc2MgfHwgZGVzYy5pbml0aWFsaXplcikgeyBkZXNjLndyaXRhYmxlID0gdHJ1ZTsgfSBkZXNjID0gZGVjb3JhdG9ycy5zbGljZSgpLnJldmVyc2UoKS5yZWR1Y2UoZnVuY3Rpb24gKGRlc2MsIGRlY29yYXRvcikgeyByZXR1cm4gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHksIGRlc2MpIHx8IGRlc2M7IH0sIGRlc2MpOyBpZiAoY29udGV4dCAmJiBkZXNjLmluaXRpYWxpemVyICE9PSB2b2lkIDApIHsgZGVzYy52YWx1ZSA9IGRlc2MuaW5pdGlhbGl6ZXIgPyBkZXNjLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDA7IGRlc2MuaW5pdGlhbGl6ZXIgPSB1bmRlZmluZWQ7IH0gaWYgKGRlc2MuaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYyk7IGRlc2MgPSBudWxsOyB9IHJldHVybiBkZXNjOyB9XG5cbmZ1bmN0aW9uIF9pbml0aWFsaXplcldhcm5pbmdIZWxwZXIoZGVzY3JpcHRvciwgY29udGV4dCkgeyB0aHJvdyBuZXcgRXJyb3IoJ0RlY29yYXRpbmcgY2xhc3MgcHJvcGVydHkgZmFpbGVkLiBQbGVhc2UgZW5zdXJlIHRoYXQgJyArICdwcm9wb3NhbC1jbGFzcy1wcm9wZXJ0aWVzIGlzIGVuYWJsZWQgYW5kIHJ1bnMgYWZ0ZXIgdGhlIGRlY29yYXRvcnMgdHJhbnNmb3JtLicpOyB9XG5cbi8vcmV0dXJucyBhcnJheSBvZiBudW1iZXJzIGlmIGNvbnRhaW5zIGNvbW1hLCBvciBudW1iZXIgLSBpbnRcbmZ1bmN0aW9uIG15UGFyc2VJbnQoc3RyLCByYWRkaXgpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09IFwic3RyaW5nXCIpIHJldHVybiBzdHI7XG4gIGlmIChzdHIubGFzdEluZGV4T2YoJywnKSA+IDApIHJldHVybiBzdHIuc3BsaXQoJywnKS5tYXAoeCA9PiBwYXJzZUludCh4LCByYWRkaXgpKTtlbHNlIHJldHVybiBwYXJzZUludChzdHIsIHJhZGRpeCk7XG59XG5cbmxldCBDaGFydGpzID0gKF9jbGFzcyA9IGNsYXNzIENoYXJ0anMge1xuICAvL2lkIHRvIGxpc3RlbiBhZGRzZWN0aW9uIGV2ZW50XG4gIC8vZmFsc2UgLSB0byBrZWVwIHdpZHRoIGFuZCBoZWlnaHQsIHRydWUgLSB0byByZXNjYWxlXG4gIC8vdGltZSB0byB0aHJvdHRsZSBjaGFydCB1cGRhdGUsIGlmIGl0IGlzIHRvbyBtdWNoIGF0IG9uY2VcbiAgLy9taW4gZm9yIHkgYXhpcyAtIGlmIGNoYXJ0IGhhcyB0aGlzIGF4aXNcbiAgLy9tYXggZm9yIHkgYXhpcyAtIGlmIGNoYXJ0IGhhcyB0aGlzIGF4aXNcbiAgLy93aGV0aGVyIHRvIGludGVncmF0ZSB3aXRoIDNkIGJhYnlsb25qc1xuICAvL2NhbnZhcyBvYmogbmFtZSAtXG4gIC8vaW5kZXggdG8gc2hpZnQgdGhlIGNvbG9yXG4gIC8vaW5kZXggdG8gc2hpZnQgdGhlIGNvbG9yXG4gIC8vbWF5IGJlIGNvbmZpZ3VyZWQgYnkgc3ViY2xhc3Nlc1xuXG4gIC8qKlxuICAgKiBpbml0aWFsaXplcyBoYW5kbGVycyBmb3IgZXZlbnQgcHJvY2Vzc2luZyAtIHRoaXMgaXMgcmVjb21tZW5kZWQgd2F5XG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZyb21pZFwiLCBfZGVzY3JpcHRvciwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxhYmVsc1wiLCBfZGVzY3JpcHRvcjIsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWZpbmRleFwiLCBfZGVzY3JpcHRvcjMsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWZ2YWx1ZXNcIiwgX2Rlc2NyaXB0b3I0LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBfZGVzY3JpcHRvcjUsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhkYXRhXCIsIF9kZXNjcmlwdG9yNiwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaXRpYWxkYXRhXCIsIF9kZXNjcmlwdG9yNywgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndpZHRoXCIsIF9kZXNjcmlwdG9yOCwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhlaWdodFwiLCBfZGVzY3JpcHRvcjksIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJhbmltYXRlXCIsIF9kZXNjcmlwdG9yMTAsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCBfZGVzY3JpcHRvcjExLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwieWxhYmVsXCIsIF9kZXNjcmlwdG9yMTIsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJ4bGFiZWxcIiwgX2Rlc2NyaXB0b3IxMywgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnZlcnRvcnNcIiwgX2Rlc2NyaXB0b3IxNCwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcnRpY2FsbGluZVwiLCBfZGVzY3JpcHRvcjE1LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2VuZXJhdGVsYWJlbHNcIiwgX2Rlc2NyaXB0b3IxNiwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlY3Rpb25pZFwiLCBfZGVzY3JpcHRvcjE3LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzcG9uc2l2ZVwiLCBfZGVzY3JpcHRvcjE4LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwidGhyb3R0bGVcIiwgX2Rlc2NyaXB0b3IxOSwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByZWNpc2lvblwiLCBfZGVzY3JpcHRvcjIwLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwibWluXCIsIF9kZXNjcmlwdG9yMjEsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhcIiwgX2Rlc2NyaXB0b3IyMiwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJhYnlsb25qc1wiLCBfZGVzY3JpcHRvcjIzLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FudmFzb2JqXCIsIF9kZXNjcmlwdG9yMjQsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2xvcnNlZ21lbnRpbmRleFwiLCBfZGVzY3JpcHRvcjI1LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29sb3JpbmRleFwiLCBfZGVzY3JpcHRvcjI2LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwibWluaWNoYXJ0XCIsIF9kZXNjcmlwdG9yMjcsIHRoaXMpO1xuXG4gICAgdGhpcy5pbmRleHNlY3Rpb24gPSAwO1xuICAgIHRoaXMuZGF0YWxhYmVscyA9IGZhbHNlO1xuICAgIHRoaXMucmVmaW5kaWNlcyA9IHZvaWQgMDtcblxuICAgIHRoaXMuaGFuZGxlVmFsdWVDaGFuZ2UgPSBlID0+IHtcbiAgICAgIC8vc2V0cyBkYXRhIHRvIGRhdGFzZXRcbiAgICAgIC8vYXBwbHkgdmFsdWUgY29udmVydCBhbW9uZyBhbGwgZGF0YVxuICAgICAgbGV0IHJhd2RhdGE7XG5cbiAgICAgIGlmICh0aGlzLnJlZmluZGljZXMpIHtcbiAgICAgICAgcmF3ZGF0YSA9IHRoaXMucmVmaW5kaWNlcy5tYXAoeCA9PiBlLmRldGFpbC5kYXRhW3hdKTtcbiAgICAgIH0gZWxzZSByYXdkYXRhID0gZS5kZXRhaWwuZGF0YS5zbGljZSh0aGlzLnJlZmluZGV4LCB0aGlzLnJlZmVuZGluZGV4KTsgLy9pZiBjb252ZXJ0IG9wZXJhdGlvbiBpcyBkZWZpbmVkIGFzIGFycmF5XG5cblxuICAgICAgaWYgKHRoaXMub3BlcmF0aW9uKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIC8vaWYgcGFydGljdWxhciBvcGVyYXRpb24gaXMgZGVmaW5lZFxuICAgICAgICAgIGlmICh0aGlzLm9wZXJhdGlvbltpXSkgcmF3ZGF0YVtpXSA9IHRoaXMub3BlcmF0aW9uW2ldKHJhd2RhdGFbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhID0gcmF3ZGF0YTtcbiAgICAgIHRoaXMudXBkYXRlY2hhcnQoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5oYW5kbGVSZXNldCA9IGUgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ2hhbmRsZXJlc2V0MigpJyk7XG4gICAgICBpZiAodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzKSBmb3IgKGxldCBkYXRhc2V0IG9mIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cykgaWYgKGRhdGFzZXQgJiYgZGF0YXNldC5kYXRhKSBkYXRhc2V0LmRhdGEgPSBbXTtcbiAgICAgIGlmICh0aGlzLmNoYXJ0LmRhdGEubGFiZWxzLmxlbmd0aCA+IDApIHRoaXMuY2hhcnQuZGF0YS5sYWJlbHMgPSBbXTtcblxuICAgICAgaWYgKHRoaXMuc2VjdGlvbmlkKSB7XG4gICAgICAgIHRoaXMuY2hhcnQuY29uZmlnLm9wdGlvbnMuc2VjdGlvbiA9IFtdO1xuICAgICAgICB0aGlzLmluZGV4c2VjdGlvbiA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlY2hhcnQoKTsgLy90aGlzLmNoYXJ0LmNvbmZpZy5vcHRpb25zLnNlY3Rpb24gPSBbXTtcbiAgICB9O1xuXG4gICAgdGhpcy5oYW5kbGVBZGRTZWN0aW9uID0gZSA9PiB7XG4gICAgICB0aGlzLmFkZFNlY3Rpb24oZS5kZXRhaWwubGFiZWwpO1xuICAgIH07XG5cbiAgICB0aGlzLmhhbmRsZUZNSUF0dGFjaGVkID0gZSA9PiB7XG4gICAgICBjb25zdCBmcm9tZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmZyb21pZCk7XG5cbiAgICAgIGlmIChmcm9tZWwpIHtcbiAgICAgICAgZnJvbWVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ZtaWRhdGEnLCB0aGlzLmhhbmRsZVZhbHVlQ2hhbmdlKTtcbiAgICAgICAgZnJvbWVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ZtaXJlc2V0JywgdGhpcy5oYW5kbGVSZXNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2ZtaSBhdHRhY2hlZCwgYnV0IG5vIGVsZW1lbnQgd2l0aCBpZCBmb3VuZDonLCB0aGlzLmZyb21pZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB1bmlxdWUgY29sb3IgcGVyIGluZGV4LSBuZWlnaGJvdXJpbmcgY29sb3JzIGFyZSBkaWZmZXJlbnQgdXNpbmcgZ29sZGVuIGFuZ2xlIGFwcHJveGltYXRpb25cbiAgICogQHBhcmFtIGluZGV4XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHVzYWJsZSBieSBDU1Mgb3IgRE9NIGVsZW1lbnRzXG4gICAqL1xuICAvLyAgY29uc3QgaHVlID0gKGkgLSAxKSAqIDEzNy41MDg7IC8vIHVzZSBnb2xkZW4gYW5nbGUgYXBwcm94aW1hdGlvblxuICAvLyAgdmFyIGNvbG9yID0gYGhzbCgke2h1ZX0sODUlLDkxJSlgO1xuXG5cbiAgc2VsZWN0Q29sb3IoaW5kZXgsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcykge1xuICAgIGlmIChzYXR1cmF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIHNhdHVyYXRpb24gPSA1NTtcbiAgICB9XG5cbiAgICBpZiAobGlnaHRuZXNzID09PSB2b2lkIDApIHtcbiAgICAgIGxpZ2h0bmVzcyA9IDU1O1xuICAgIH1cblxuICAgIGNvbnN0IGh1ZSA9IChpbmRleCAtIDEpICogMTM3LjUwODsgLy8gdXNlIGdvbGRlbiBhbmdsZSBhcHByb3hpbWF0aW9uXG5cbiAgICByZXR1cm4gXCJoc2woXCIgKyBodWUgKyBcIixcIiArIHNhdHVyYXRpb24gKyBcIiUsXCIgKyBsaWdodG5lc3MgKyBcIiUpXCI7XG4gIH1cbiAgLyoqXG4gICAqIHByb2Nlc3MgYWxsIGF0dHJpYnV0ZXMgb2YgPGJkbC1jaGFydD4gY29tcG9uZW50IGFuZCBzZXRzIGFwcHJvcHJpYXRlIHNldHRpbmdzIG9mIHN1YmVzcXVlbnQgY2hhcnRqc1xuICAgKi9cblxuXG4gIGJpbmQoKSB7XG4gICAgLy9jb25zb2xlLmxvZygnY2hhcnRqcyBiaW5kJyk7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnJlZmluZGV4ID09ICdzdHJpbmcnICYmIHRoaXMucmVmaW5kZXguaW5kZXhPZignLCcpID4gMCkge1xuICAgICAgdGhpcy5yZWZpbmRpY2VzID0gdGhpcy5yZWZpbmRleC5zcGxpdCgnLCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlZmluZGV4ID0gbXlQYXJzZUludCh0aGlzLnJlZmluZGV4LCAxMCk7XG4gICAgICB0aGlzLnJlZnZhbHVlcyA9IHBhcnNlSW50KHRoaXMucmVmdmFsdWVzLCAxMCk7XG4gICAgICB0aGlzLnJlZmVuZGluZGV4ID0gdGhpcy5yZWZpbmRleCArIHRoaXMucmVmdmFsdWVzO1xuICAgIH0gLy9lbXB0eSBwbHVnaW5zIGJ5IGRlZmF1bHRcblxuXG4gICAgdGhpcy5wbHVnaW5zID0gW107IC8vY29uZmlndXJlIGNvbnZlcnRvcnMgLSB1c2VkIHRvIGNvbnZlcnQgdW5pdHMgcmVjZWl2ZWQgZnJvbSBmbWlcblxuICAgIGlmICh0aGlzLmNvbnZlcnRvcnMpIHtcbiAgICAgIGxldCBjb252ZXJ0dmFsdWVzID0gdGhpcy5jb252ZXJ0b3JzLnNwbGl0KCc7Jyk7XG5cbiAgICAgIGxldCBpZGVudGl0eSA9IHggPT4geDtcblxuICAgICAgdGhpcy5vcGVyYXRpb24gPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb252ZXJ0dmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjb252ZXJ0dmFsdWVzW2ldLmluY2x1ZGVzKCcsJykpIHtcbiAgICAgICAgICAvL2NvbnZlcnQgdmFsdWVzIGFyZSBpbiBmb3JtIG51bWVyYXRvcixkZW5vbWluYXRvciBjb250YWlucyBjb21tYSAnLCdcbiAgICAgICAgICBsZXQgY29udmVydGl0ZW1zID0gY29udmVydHZhbHVlc1tpXS5zcGxpdCgnLCcpO1xuICAgICAgICAgIGlmIChjb252ZXJ0aXRlbXNbMF0gPT09ICcxJyAmJiBjb252ZXJ0aXRlbXNbMV0gPT09ICcxJykgdGhpcy5vcGVyYXRpb24ucHVzaChpZGVudGl0eSk7ZWxzZSB7XG4gICAgICAgICAgICBsZXQgbnVtZXJhdG9yID0gcGFyc2VGbG9hdChjb252ZXJ0aXRlbXNbMF0pO1xuICAgICAgICAgICAgbGV0IGRlbm9taW5hdG9yID0gcGFyc2VGbG9hdChjb252ZXJ0aXRlbXNbMV0pO1xuICAgICAgICAgICAgbGV0IGFkZGVuZCA9IGNvbnZlcnRpdGVtcy5sZW5ndGggPiAyID8gcGFyc2VGbG9hdChjb252ZXJ0aXRlbXNbMl0pIDogMDtcbiAgICAgICAgICAgIHRoaXMub3BlcmF0aW9uLnB1c2goeCA9PiB4ICogbnVtZXJhdG9yIC8gZGVub21pbmF0b3IgKyBhZGRlbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL2NvbnZlcnQgdmFsdWVzIGFyZSBpbiBmb3JtIG9mIGV4cHJlc3Npb24sIGRvIG5vdCBjb250YWluIGNvbW1hXG4gICAgICAgICAgaWYgKGNvbnZlcnR2YWx1ZXMgPT09ICcxL3gnKSB0aGlzLm9wZXJhdGlvbi5wdXNoKHggPT4gMSAvIHgpO2Vsc2Uge1xuICAgICAgICAgICAgLy8gZm9yIGV2YWwoKSBzZWN1cml0eSBmaWx0ZXIgb25seSBhbGxvd2VkIGNoYXJhY3RlcnM6XG4gICAgICAgICAgICAvLyBhbGdlYnJhaWMsIGRpZ2l0cywgZSwgZG90LCBtb2R1bG8sIHBhcmVudGhlc2lzIGFuZCAneCcgYW5kICdlJyBpcyBhbGxvd2VkXG4gICAgICAgICAgICBsZXQgZXhwcmVzc2lvbiA9IGNvbnZlcnR2YWx1ZXNbaV0ucmVwbGFjZSgvW14tXFxkLyorLigpJXhlXS9nLCAnJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnY2hhcnRqcyBiaW5kKCksIGV2YWx1YXRpbmcgZXhwcmVzc2lvbjonICsgY29udmVydHZhbHVlc1tpXSArICcgc2VjdXJlbHkgZmlsdGVyZWQgdG8gOicgKyBleHByZXNzaW9uKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV2YWxcblxuICAgICAgICAgICAgdGhpcy5vcGVyYXRpb24ucHVzaCh4ID0+IGV2YWwoZXhwcmVzc2lvbikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy9zZXRzIGJvb2xlYW4gdmFsdWUgLSBpZiB2ZXJ0aWNhbGxpbmUgYXR0cmlidXRlIGlzIHNldFxuXG5cbiAgICBpZiAodHlwZW9mIHRoaXMuZ2VuZXJhdGVsYWJlbHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmdlbmVyYXRlbGFiZWxzID0gdGhpcy5nZW5lcmF0ZWxhYmVscyA9PT0gJ3RydWUnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5taW5pY2hhcnQgPT09ICdzdHJpbmcnKSB0aGlzLm1pbmljaGFydCA9IHRoaXMubWluaWNoYXJ0ID09PSAndHJ1ZSc7XG5cbiAgICBpZiAodHlwZW9mIHRoaXMuY29sb3JpbmRleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuY29sb3JpbmRleCA9IHBhcnNlSW50KHRoaXMuY29sb3JpbmRleCwgMTApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jb2xvcmluZGV4KSB0aGlzLmNvbG9yaW5kZXggPSAwOyAvL2luIGNhc2Ugbm90IGRlZmluZWQgb3IgbnVsbFxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLmNvbG9yc2VnbWVudGluZGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5jb2xvcnNlZ21lbnRpbmRleCA9IHBhcnNlSW50KHRoaXMuY29sb3JzZWdtZW50aW5kZXgsIDEwKTtcbiAgICB9IC8vc2V0cyBjb2xvciBvZiBlYWNoIGRhdGFzZXQgYXMgZGlmZmVyZW50IGFzIHBvc3NpYmxlXG4gICAgLy9hbmQgc2V0IGluaXRpYWwgZGF0YSBpbiBjaGFydFxuICAgIC8vc2V0IGxhYmVscyAtIHNlcGFyYXRlZCBieSBjb21tYVxuXG5cbiAgICBpZiAodGhpcy5sYWJlbHMpIHRoaXMuY2hsYWJlbHMgPSB0aGlzLmxhYmVscy5zcGxpdCgnLCcpOyAvL2Vsc2UgZ2VuZXJhdGUgbGFiZWxzIGFzICd2YXJpYWJsZSAxJyAuLi5cbiAgICBlbHNlIHtcbiAgICAgIC8vdGhpcy5jaGxhYmVscyA9IFsuLi5BcnJheSh0aGlzLnJlZnZhbHVlcyldLm1hcCgoXywgaSkgPT4gdGhpcy5nZW5lcmF0ZWxhYmVscyA/IGB2YXJpYWJsZSAke2l9YCA6ICcnKTtcbiAgICAgIC8vdGhpcyBzZWVtcyBub3QgdG8gYmUgY29ycmVjdGx5IHRyYW5zcGlsbGVkIHRvIEVTNSwgdGhlcmVmb3JlIGZvbGxvd2luZyBnZW5lcmF0b3IgLT5cbiAgICAgIHRoaXMuY2hsYWJlbHMgPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJlZnZhbHVlczsgaSsrKSB7XG4gICAgICAgIGxldCBpbGFiZWwgPSB0aGlzLmdlbmVyYXRlbGFiZWxzID8gJ3ZhcmlhYmxlICcgKyBpIDogJyc7XG4gICAgICAgIHRoaXMuY2hsYWJlbHMucHVzaChpbGFiZWwpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbG9ycyA9IFtdO1xuICAgIGxldCBteWRhdGFzdHIgPSB0aGlzLmluaXRpYWxkYXRhLnNwbGl0KCcsJyk7XG4gICAgdGhpcy5teWRhdGEgPSBteWRhdGFzdHIubWFwKHggPT4ge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoeCk7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMucmVmaW5kaWNlcykgdGhpcy5yZWZ2YWx1ZXMgPSB0aGlzLnJlZmluZGljZXMubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJlZnZhbHVlczsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMubXlkYXRhW2ldKSB7Ly90aGlzLm15ZGF0YS5wdXNoKDApO1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdjaGFydGpzIG5vIGRhdGEnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb2xvcnMucHVzaCh0aGlzLnNlbGVjdENvbG9yKGkgKyB0aGlzLmNvbG9yaW5kZXgpKTtcbiAgICB9XG5cbiAgICBsZXQgZGF0YXNldHMgPSBbe1xuICAgICAgZGF0YTogdGhpcy5teWRhdGEsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuY29sb3JzXG4gICAgfV07XG4gICAgdGhpcy5kYXRhID0ge1xuICAgICAgbGFiZWxzOiB0aGlzLmNobGFiZWxzLFxuICAgICAgZGF0YXNldHM6IGRhdGFzZXRzXG4gICAgfTsgLy9iaW5kIC0gc3RyaW5nIHZhbHVlIHRvIGJvb2xlYW5cblxuICAgIGlmICh0eXBlb2YgdGhpcy5hbmltYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5hbmltYXRlID0gdGhpcy5hbmltYXRlID09PSAndHJ1ZSc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLnJlc3BvbnNpdmUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnJlc3BvbnNpdmUgPSB0aGlzLnJlc3BvbnNpdmUgPT09ICd0cnVlJztcbiAgICB9IC8vc2V0IGFuaW1hdGlvbiBvcHRpb25zXG5cblxuICAgIGxldCBhbmltb3B0czEgPSB7XG4gICAgICBhbmltYXRlU2NhbGU6IHRydWUsXG4gICAgICBhbmltYXRlUm90YXRlOiB0cnVlLFxuICAgICAgZHVyYXRpb246IDUwMFxuICAgIH07XG4gICAgbGV0IGFuaW1vcHRzMiA9IHtcbiAgICAgIGR1cmF0aW9uOiAwXG4gICAgfTsgLy9zZWxlY3Qgb3B0aW9ucyBiYXNlZCBvbiBhdHRyaWJ1dGUgdmFsdWUgLSB3aGV0aGVyIHRvIGFuaW1hdGUgb3Igbm90XG5cbiAgICBsZXQgYW5pbW9wdHMgPSB0aGlzLmFuaW1hdGUgPyBhbmltb3B0czEgOiBhbmltb3B0czI7IC8vc2V0IGxhYmVscyBmb3IgYXhlcyBpbiBjaGFydGpzIG9wdHNcblxuICAgIGxldCBheGlzb3B0cyA9IHt9O1xuXG4gICAgaWYgKHRoaXMueWxhYmVsKSB7XG4gICAgICBheGlzb3B0cy55QXhlcyA9IFt7XG4gICAgICAgIHNjYWxlTGFiZWw6IHtcbiAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICAgIGxhYmVsU3RyaW5nOiB0aGlzLnlsYWJlbFxuICAgICAgICB9XG4gICAgICB9XTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy54bGFiZWwpIHtcbiAgICAgIGF4aXNvcHRzLnhBeGVzID0gW3tcbiAgICAgICAgc2NhbGVMYWJlbDoge1xuICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgbGFiZWxTdHJpbmc6IHRoaXMueGxhYmVsXG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1pbmljaGFydCkge1xuICAgICAgaWYgKGF4aXNvcHRzLnhBeGVzKSBheGlzb3B0cy54QXhlc1swXS5kaXNwbGF5ID0gZmFsc2U7ZWxzZSBheGlzb3B0cy54QXhlcyA9IFt7XG4gICAgICAgIGRpc3BsYXk6IGZhbHNlXG4gICAgICB9XTtcbiAgICAgIGlmIChheGlzb3B0cy55QXhlcykgYXhpc29wdHMueUF4ZXNbMF0uZGlzcGxheSA9IGZhbHNlO2Vsc2UgYXhpc29wdHMueUF4ZXMgPSBbe1xuICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgfV07XG4gICAgfSAvL2luaXRpYWxpemUgb3B0aW9ucyAtIHVzZWQgbGF0ZXIgYnkgY2hhcnRqcyBpbnN0YW5jZVxuXG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBsaXZlOiB0cnVlLFxuICAgICAgcmVzcG9uc2l2ZTogdGhpcy5yZXNwb25zaXZlLFxuICAgICAgLy90cnVlIC0gcmVzY2FsZSwgZmFsc2UgLSB3aWxsIGtlZXAgY2FudmFzIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiAhdGhpcy5taW5pY2hhcnQsXG4gICAgICAgIHBvc2l0aW9uOiAndG9wJ1xuICAgICAgfSxcbiAgICAgIGFuaW1hdGlvbjogYW5pbW9wdHMsXG4gICAgICB0b29sdGlwczoge1xuICAgICAgICBwb3NpdGlvbjogJ25lYXJlc3QnLFxuICAgICAgICBtb2RlOiAnaW5kZXgnLFxuICAgICAgICBpbnRlcnNlY3Q6IGZhbHNlLFxuICAgICAgICB0aXRsZUZvbnRGYW1pbHk6ICdPcGVuIFNhbnMnLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuMyknLFxuICAgICAgICAvL3RpdGxlRm9udENvbG9yOiAncmVkJyxcbiAgICAgICAgY2FyZXRTaXplOiA1LFxuICAgICAgICBjb3JuZXJSYWRpdXM6IDQsXG4gICAgICAgIHhQYWRkaW5nOiAzLFxuICAgICAgICB5UGFkZGluZzogMyxcbiAgICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAgbGFiZWw6IGZ1bmN0aW9uICh0b29sdGlwSXRlbSwgZGF0YSkge1xuICAgICAgICAgICAgLy9sZXQgbGFiZWwgPSBkYXRhLmxhYmVsc1t0b29sdGlwSXRlbS5pbmRleF07XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBkYXRhLmRhdGFzZXRzW3Rvb2x0aXBJdGVtLmRhdGFzZXRJbmRleF0uZGF0YVt0b29sdGlwSXRlbS5pbmRleF07IC8vY29uc29sZS5sb2coJ2NoYXJ0anMgdG9vbHRpcCwgdmFsdWUnLHRvb2x0aXBJdGVtLHZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHJldHVybiB2YWx1ZS54LnRvUHJlY2lzaW9uKDQpICsgJzonICsgdmFsdWUueS50b1ByZWNpc2lvbig0KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSByZXR1cm4gdmFsdWUudG9QcmVjaXNpb24oNCk7IC8vVE9ETyB0aGlzLnByZWNpc2lvbiBpcyBub3QgYWNjZXNzaWJsZSBmcm9tIGhlcmVcblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAwLFxuICAgICAgICAvL2Rpc2FibGUgYW5pbWF0aW9uIG9uIGhvdmVyIC0gZS5nLiBmb3IgdG9vbHRpcHNcbiAgICAgICAgaW50ZXJzZWN0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHNjYWxlczogYXhpc29wdHMsXG4gICAgICBiYWJ5bG9uZHluYW1pY3RleHR1cmU6IFwiXCIgLy8gbmFtZSBvZiBnbG9iYWwgZHluYW1pY3RleHR1cmVvYmogdG8gY2FsbCB1cGRhdGUoKVxuXG4gICAgfTsgLy9zZXRzIGJvb2xlYW4gdmFsdWUgLSBpZiB2ZXJ0aWNhbGxpbmUgYXR0cmlidXRlIGlzIHNldFxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLnZlcnRpY2FsbGluZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMudmVydGljYWxsaW5lID0gdGhpcy52ZXJ0aWNhbGxpbmUgPT09ICd0cnVlJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMubWF4ZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMubWF4ZGF0YSA9IHBhcnNlSW50KHRoaXMubWF4ZGF0YSwgMTApO1xuICAgIH0gLy9pZiBzZWN0aW9ucyBhcmUgcmVxdWVzdGVkIC0gZGVmaW5lIGNoYXJ0anMgcGx1Z2luIHRvIGRyYXcgaXQgaW4gYmFja2dyb3VuZFxuXG5cbiAgICBpZiAodGhpcy5zZWN0aW9uaWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5zZWN0aW9uID0gW107XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWluKSB7XG4gICAgICAvL3NldHMgeXNjYWxlIG1pblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMpIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2NhbGVzKSB0aGlzLm9wdGlvbnMuc2NhbGVzID0ge307XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zY2FsZXMueUF4ZXMpIHRoaXMub3B0aW9ucy5zY2FsZXMueUF4ZXMgPSBbe31dOyAvL2NoYXJ0anMgMi45LjRcblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2NhbGVzLnlBeGVzWzBdLnRpY2tzKSB0aGlzLm9wdGlvbnMuc2NhbGVzLnlBeGVzWzBdLnRpY2tzID0ge307IC8vY2hhcnRqcyAyLjkuNFxuXG4gICAgICB0aGlzLm9wdGlvbnMuc2NhbGVzLnlBeGVzWzBdLnRpY2tzLm1pbiA9IHBhcnNlRmxvYXQodGhpcy5taW4pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1heCkge1xuICAgICAgLy9zZXRzIHlzY2FsZSBtYXhcbiAgICAgIGlmICghdGhpcy5vcHRpb25zKSB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNjYWxlcykgdGhpcy5vcHRpb25zLnNjYWxlcyA9IHt9O1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2NhbGVzLnlBeGVzKSB0aGlzLm9wdGlvbnMuc2NhbGVzLnlBeGVzID0gW3t9XTsgLy9jaGFydGpzIDIuOS40XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNjYWxlcy55QXhlc1swXS50aWNrcykgdGhpcy5vcHRpb25zLnNjYWxlcy55QXhlc1swXS50aWNrcyA9IHt9OyAvL2NoYXJ0anMgMi45LjRcblxuICAgICAgdGhpcy5vcHRpb25zLnNjYWxlcy55QXhlc1swXS50aWNrcy5tYXggPSBwYXJzZUZsb2F0KHRoaXMubWF4KTsgLy9pZiAodGhpcy5taW4pIHRoaXMub3B0aW9ucy5zY2FsZXMueUF4ZXNbMF0udGlja3Muc3RlcFNpemUgPSAodGhpcy5vcHRpb25zLnNjYWxlcy55QXhlc1swXS50aWNrcy5tYXggLSB0aGlzLm9wdGlvbnMuc2NhbGVzLnlBeGVzWzBdLnRpY2tzLm1pbikgLyAxMDtcbiAgICB9XG5cbiAgICB0aGlzLnRvb2x0aXBzID0gWydtb3VzZW1vdmUnLCAndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAnY2xpY2snXTtcbiAgICAvKmlmICh0aGlzLm1pbmljaGFydCkge1xuICAgICAgdGhpcy5vcHRpb25zLnBsdWdpbnMubGVnZW5kLmRpc3BsYXkgPSBmYWxzZVxuICAgIH0qL1xuICB9XG4gIC8qKlxuICAgKiB0aGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBET00gaXMgYXR0YWNoZWQgdG8gdmlldyAtIGluc3RhbnRpYXRlIHRoZSBjaGFydGpzIGFuZCBzZXRzIGFsbCBuZWNlc2FyeSBiaW5kaW5nXG4gICAqL1xuXG5cbiAgYXR0YWNoZWQoKSB7XG4gICAgLy9jb25zb2xlLmxvZygnY2hhcnRqcyBhdHRhY2hlZCcpO1xuICAgIC8vbGlzdGVuaW5nIHRvIGN1c3RvbSBldmVudCBmbWlkYXRhIGFuZCBmbWlyZXNldFxuICAgIGNvbnN0IGZyb21lbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZnJvbWlkKTtcblxuICAgIGlmIChmcm9tZWwpIHtcbiAgICAgIGZyb21lbC5hZGRFdmVudExpc3RlbmVyKCdmbWlkYXRhJywgdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZSk7XG4gICAgICBmcm9tZWwuYWRkRXZlbnRMaXN0ZW5lcignZm1pcmVzZXQnLCB0aGlzLmhhbmRsZVJlc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdjaGFydGpzLCBudWxsIGZyb21pZCBlbGVtZW50LCB3YWl0aW5nIHRvIGJlIGF0dGFjaGVkJyk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmbWlhdHRhY2hlZCcsIHRoaXMuaGFuZGxlRk1JQXR0YWNoZWQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNlY3Rpb25pZCkge1xuICAgICAgY29uc3Qgc2VjdGlvbmVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5zZWN0aW9uaWQpO1xuICAgICAgaWYgKHNlY3Rpb25lbCkgc2VjdGlvbmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHNlY3Rpb24nLCB0aGlzLmhhbmRsZUFkZFNlY3Rpb24pO2Vsc2UgY29uc29sZS5sb2coJ2NoYXJ0anMgV0FSTklORywgbnVsbCBzZWN0aW9uaWQgZWxlbWVudCcpO1xuICAgIH0gLy91bnJlZ2lzdGVyXG5cblxuICAgIF9jaGFydC5kZWZhdWx0LnBsdWdpbnMudW5yZWdpc3RlcihfY2hhcnRqc1BsdWdpbkRhdGFsYWJlbHMuZGVmYXVsdCk7IC8vZm9yIHZlcnRpY2FsbGluZSBvcHRpb24gLSByZWdpc3RlciBjb250cm9sbGVyIGZvciBCZGxDaGFydGpzXG5cblxuICAgIGlmICh0aGlzLnZlcnRpY2FsbGluZSkge1xuICAgICAgX2NoYXJ0LmRlZmF1bHQuZGVmYXVsdHMuTGluZVdpdGhMaW5lID0gX2NoYXJ0LmRlZmF1bHQuZGVmYXVsdHMubGluZTtcbiAgICAgIF9jaGFydC5kZWZhdWx0LmNvbnRyb2xsZXJzLkxpbmVXaXRoTGluZSA9IF9jaGFydC5kZWZhdWx0LmNvbnRyb2xsZXJzLmxpbmUuZXh0ZW5kKHtcbiAgICAgICAgZHJhdzogZnVuY3Rpb24gKGVhc2UpIHtcbiAgICAgICAgICBfY2hhcnQuZGVmYXVsdC5jb250cm9sbGVycy5saW5lLnByb3RvdHlwZS5kcmF3LmNhbGwodGhpcywgZWFzZSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5jaGFydC50b29sdGlwLl9hY3RpdmUgJiYgdGhpcy5jaGFydC50b29sdGlwLl9hY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgYWN0aXZlUG9pbnQgPSB0aGlzLmNoYXJ0LnRvb2x0aXAuX2FjdGl2ZVswXTtcbiAgICAgICAgICAgIGxldCBjdHggPSB0aGlzLmNoYXJ0LmN0eDtcbiAgICAgICAgICAgIGxldCB4ID0gYWN0aXZlUG9pbnQudG9vbHRpcFBvc2l0aW9uKCkueDtcbiAgICAgICAgICAgIGxldCB0b3BZID0gdGhpcy5jaGFydC5sZWdlbmQuYm90dG9tO1xuICAgICAgICAgICAgbGV0IGJvdHRvbVkgPSB0aGlzLmNoYXJ0LmNoYXJ0QXJlYS5ib3R0b207IC8vIGRyYXcgbGluZVxuXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB0b3BZKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgYm90dG9tWSk7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjNTU1JztcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IC8vZm9yIHNlY3Rpb25zIHJlZ2lzdGVyIGNoYXJ0anMgcGx1Z2luXG5cblxuICAgIGlmICh0aGlzLnNlY3Rpb25pZCkge1xuICAgICAgX2NoYXJ0LmRlZmF1bHQucGx1Z2luU2VydmljZS5yZWdpc3Rlcih7XG4gICAgICAgIGJlZm9yZURyYXc6IGZ1bmN0aW9uIChjaGFydCwgZWFzaW5nKSB7XG4gICAgICAgICAgaWYgKGNoYXJ0LmNvbmZpZy5vcHRpb25zLnNlY3Rpb24gJiYgY2hhcnQuY29uZmlnLm9wdGlvbnMuc2VjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgY3R4ID0gY2hhcnQuY2hhcnQuY3R4O1xuICAgICAgICAgICAgbGV0IGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICAgICAgICAgIGxldCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7IC8vY29uc29sZS5sb2coJ2NoYXJ0anMgc2VjdGlvbnMnLCBjaGFydC5jb25maWcub3B0aW9ucy5zZWN0aW9uKTtcblxuICAgICAgICAgICAgaWYgKG1ldGEuZGF0YS5sZW5ndGggPT0gMCkgcmV0dXJuOyAvL2ZpcnN0IHNlY3Rpb25cblxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGNoYXJ0LmNvbmZpZy5vcHRpb25zLnNlY3Rpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY2hhcnRqcyBzZWN0aW9ucGx1Z2luOmksIHNlY3Rpb25baS0xXSwgc2VjdGlvblsxXSxzdGFydCxzdG9wKScsIGksIGNoYXJ0LmNvbmZpZy5vcHRpb25zLnNlY3Rpb25baSAtIDFdLGNoYXJ0LmNvbmZpZy5vcHRpb25zLnNlY3Rpb25baV0pO1xuICAgICAgICAgICAgICBjb25zdCBzdGFydGluZGV4ID0gY2hhcnQuY29uZmlnLm9wdGlvbnMuc2VjdGlvbltpIC0gMV0uaW5kZXg7XG4gICAgICAgICAgICAgIGNvbnN0IHN0b3BpbmRleCA9IGNoYXJ0LmNvbmZpZy5vcHRpb25zLnNlY3Rpb25baV0uaW5kZXg7XG4gICAgICAgICAgICAgIGlmIChzdGFydGluZGV4ID49IG1ldGEuZGF0YS5sZW5ndGgpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBpZiAoc3RvcGluZGV4ID49IG1ldGEuZGF0YS5sZW5ndGgpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBtZXRhLmRhdGFbc3RhcnRpbmRleF0uX21vZGVsLng7XG4gICAgICAgICAgICAgIGxldCBzdG9wID0gbWV0YS5kYXRhW3N0b3BpbmRleF0uX21vZGVsLng7XG4gICAgICAgICAgICAgIC8qY29uc3QgaHVlID0gKGkgLSAxKSAqIDEzNy41MDg7IC8vIHVzZSBnb2xkZW4gYW5nbGUgYXBwcm94aW1hdGlvblxuICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYGhzbCgke2h1ZX0sODUlLDkxJSlgO1xuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgLy9iYXJcblxuICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY2hhcnQuY29uZmlnLm9wdGlvbnMuc2VjdGlvbltpIC0gMV0uY29sb3I7XG4gICAgICAgICAgICAgIGN0eC5maWxsUmVjdChzdGFydCwgY2hhcnRBcmVhLnRvcCwgc3RvcCAtIHN0YXJ0LCBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcCk7IC8vbGFiZWxcbiAgICAgICAgICAgICAgLy9jdHgudHJhbnNsYXRlKHN0YXJ0LCBjaGFydEFyZWEudG9wKTtcbiAgICAgICAgICAgICAgLy9jdHgucm90YXRlKE1hdGguUEkgLyAyKTtcblxuICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHN0YXJ0LCBjaGFydEFyZWEudG9wKTtcbiAgICAgICAgICAgICAgY3R4LnJvdGF0ZSg5MCAqIE1hdGguUEkgLyAxODApO1xuICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJyNhYWEnO1xuICAgICAgICAgICAgICBjdHguZm9udCA9ICcxMnB4IEhlbHZldGljYSc7XG4gICAgICAgICAgICAgIGN0eC5maWxsVGV4dChjaGFydC5jb25maWcub3B0aW9ucy5zZWN0aW9uW2kgLSAxXS5sYWJlbCwgNSwgLTUpOyAvL3N0YXJ0LCBjaGFydEFyZWEudG9wKTtcblxuICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpOyAvL2NvbnNvbGUubG9nKCdsYXN0IGknLGkpO1xuICAgICAgICAgICAgLy9sYXN0IHNlY3Rpb25cblxuICAgICAgICAgICAgaSA9IGNoYXJ0LmNvbmZpZy5vcHRpb25zLnNlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoaSA+IDEgJiYgY2hhcnQuY29uZmlnLm9wdGlvbnMuc2VjdGlvbltpIC0gMV0uaW5kZXggPCBtZXRhLmRhdGEubGVuZ3RoIC0gMSAmJiBjaGFydC5jb25maWcub3B0aW9ucy5zZWN0aW9uW2kgLSAxXS5pbmRleCA8IG1ldGEuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy9kcmF3IGxhc3Qgc2VjdGlvblxuICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBtZXRhLmRhdGFbY2hhcnQuY29uZmlnLm9wdGlvbnMuc2VjdGlvbltpIC0gMV0uaW5kZXhdLl9tb2RlbC54O1xuICAgICAgICAgICAgICBsZXQgc3RvcCA9IG1ldGEuZGF0YVttZXRhLmRhdGEubGVuZ3RoIC0gMV0uX21vZGVsLng7IC8vY29uc29sZS5sb2cgKHN0YXJ0LHN0b3ApO1xuXG4gICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgIGNvbnN0IGh1ZSA9IChpIC0gMSkgKiAxMzcuNTA4OyAvLyB1c2UgZ29sZGVuIGFuZ2xlIGFwcHJveGltYXRpb25cbiAgICAgICAgICAgICAgdmFyIGNvbG9yID0gYGhzbCgke2h1ZX0sODUlLDkxJSlgO1xuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY2hhcnQuY29uZmlnLm9wdGlvbnMuc2VjdGlvbltpIC0gMV0uY29sb3I7IC8vY29uc29sZS5sb2cgKGNoYXJ0QXJlYSk7XG5cbiAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHN0YXJ0LCBjaGFydEFyZWEudG9wLCBzdG9wIC0gc3RhcnQsIGNoYXJ0QXJlYS5ib3R0b20gLSBjaGFydEFyZWEudG9wKTtcbiAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShzdGFydCwgY2hhcnRBcmVhLnRvcCk7XG4gICAgICAgICAgICAgIGN0eC5yb3RhdGUoOTAgKiBNYXRoLlBJIC8gMTgwKTtcbiAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjYWFhJztcbiAgICAgICAgICAgICAgY3R4LmZvbnQgPSAnMTJweCBIZWx2ZXRpY2EnO1xuICAgICAgICAgICAgICBjdHguZmlsbFRleHQoY2hhcnQuY29uZmlnLm9wdGlvbnMuc2VjdGlvbltpIC0gMV0ubGFiZWwsIDUsIC01KTsgLy9zdGFydCwgY2hhcnRBcmVhLnRvcCk7XG5cbiAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRhdGFsYWJlbHMpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdkYXRhbGFiZWxzIHRydWUgLHNldHRpbmcgcGx1Z2luJywgdGhpcy5kYXRhbGFiZWxzKTtcbiAgICAgIGNvbnNvbGUubG9nKCdkYXRhbGFiZWxzIHRydWUgLHNldHRpbmcgcGx1Z2luJywgdGhpcy5kYXRhbGFiZWxzKTtcblxuICAgICAgX2NoYXJ0LmRlZmF1bHQucGx1Z2luU2VydmljZS5yZWdpc3Rlcih7XG4gICAgICAgIGFmdGVyRGF0YXNldHNEcmF3OiBmdW5jdGlvbiAoY2hhcnRJbnN0YW5jZSwgZWFzaW5nKSB7XG4gICAgICAgICAgLy8gVG8gb25seSBkcmF3IGF0IHRoZSBlbmQgb2YgYW5pbWF0aW9uLCBjaGVjayBmb3IgZWFzaW5nID09PSAxXG4gICAgICAgICAgLy9pZiAoZGF0YXNldCAmJiBkYXRhc2V0LmRhdGFsYWJlbHMpIHtcbiAgICAgICAgICBsZXQgY3R4ID0gY2hhcnRJbnN0YW5jZS5jaGFydC5jdHg7XG4gICAgICAgICAgY2hhcnRJbnN0YW5jZS5kYXRhLmRhdGFzZXRzLmZvckVhY2goZnVuY3Rpb24gKGRhdGFzZXQsIGkpIHtcbiAgICAgICAgICAgIGlmIChkYXRhc2V0ICYmIGRhdGFzZXQuZGF0YWxhYmVscykge1xuICAgICAgICAgICAgICBsZXQgbWV0YSA9IGNoYXJ0SW5zdGFuY2UuZ2V0RGF0YXNldE1ldGEoaSk7XG5cbiAgICAgICAgICAgICAgaWYgKCFtZXRhLmhpZGRlbikge1xuICAgICAgICAgICAgICAgIG1ldGEuZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGRhdGFzZXQuZGF0YWxhYmVsc1tpbmRleF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEcmF3IHRoZSB0ZXh0IGluIGJsYWNrLCB3aXRoIHRoZSBzcGVjaWZpZWQgZm9udFxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJyNhYWEnO1xuICAgICAgICAgICAgICAgICAgICBjdHguZm9udCA9ICcxMnB4IEhlbHZldGljYSc7IC8vIEp1c3QgbmFpdmVseSBjb252ZXJ0IHRvIHN0cmluZyBmb3Igbm93XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGFTdHJpbmcgPSBkYXRhc2V0LmRhdGFsYWJlbHNbaW5kZXhdOyAvLyBNYWtlIHN1cmUgYWxpZ25tZW50IHNldHRpbmdzIGFyZSBjb3JyZWN0XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYWRkaW5nID0gNTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gZWxlbWVudC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGRhdGFTdHJpbmcsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnkgLSAxMiAvIDIgLSBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IC8vYmFieWxvbmpzIGJpbmRcblxuICAgIC8qaWYgKHR5cGVvZiB0aGlzLmJhYnlsb25qcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vdGhpcy5iYWJ5bG9uanMgPSB0aGlzLmJhYnlsb25qcyA9PT0gJ3RydWUnO1xuICAgIH0gZWxzZSB0aGlzLmJhYnlsb25qcyA9IGZhbHNlOyovXG5cblxuICAgIGlmICh0aGlzLmJhYnlsb25qcykge1xuICAgICAgdGhpcy5vcHRpb25zLmJhYnlsb25keW5hbWljdGV4dHVyZSA9IHRoaXMuYmFieWxvbmpzO1xuXG4gICAgICBfY2hhcnQuZGVmYXVsdC5wbHVnaW5zLnJlZ2lzdGVyKHtcbiAgICAgICAgYmVmb3JlRHJhdzogZnVuY3Rpb24gKGNoYXJ0SW5zdGFuY2UpIHtcbiAgICAgICAgICB2YXIgY3R4ID0gY2hhcnRJbnN0YW5jZS5jaGFydC5jdHg7IC8vY29uc29sZS5sb2coJ2N0eCBiZWZvcmUgZHJhdzonKVxuXG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcbiAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2hhcnRJbnN0YW5jZS5jaGFydC53aWR0aCwgY2hhcnRJbnN0YW5jZS5jaGFydC5oZWlnaHQpO1xuICAgICAgICB9LFxuICAgICAgICBhZnRlckRyYXc6IGZ1bmN0aW9uIChjaGFydEluc3RhbmNlKSB7XG4gICAgICAgICAgdmFyIGN0eCA9IGNoYXJ0SW5zdGFuY2UuY2hhcnQuY3R4OyAvL2NvbnNvbGUubG9nKCdjdHggYWZ0ZXIgZHJhdzonKVxuXG4gICAgICAgICAgaWYgKHdpbmRvd1tjaGFydEluc3RhbmNlLm9wdGlvbnMuYmFieWxvbmR5bmFtaWN0ZXh0dXJlXSkgd2luZG93W2NoYXJ0SW5zdGFuY2Uub3B0aW9ucy5iYWJ5bG9uZHluYW1pY3RleHR1cmVdLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IC8vY2FudmFzb2JqIC0gaWYgZGVmaW5lZCB0aGVuIHVzZSB0aGlzIG9iamVjdCBuYW1lIHRvIGdldCBjYW52YXMgb2JqZWN0IC0gIG90aGVyd2lzZSB0aGUgb25lIGZyb20gdGVtcGxhdGVcblxuXG4gICAgbGV0IGN0eCA9IHRoaXMuY2FudmFzb2JqID8gd2luZG93W3RoaXMuY2FudmFzb2JqXSA6IHRoaXMuY2hhcnRjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTsgLy9jdHggbWF5IGJlIG51bGwgaWYgY2FudmFzb2JqIGlzIG5vdCB5ZXQgaW5pdGlhbGl6ZWQuXG5cbiAgICBpZiAoY3R4KSB0aGlzLmluaXRDaGFydChjdHgpOyAvL2luaXQgY2hhcnQgb25seSBpZiBjdHggaXMgcmVhZHlcbiAgICBlbHNlIHtcbiAgICAgIC8vYWRkIG15c2VsZiB0byBsYXp5aW5pdGNoYXJ0IGFycmF5XG4gICAgICBpZiAoIXdpbmRvdy5sYXp5SW5pdENoYXJ0KSB3aW5kb3cubGF6eUluaXRDaGFydCA9IFtdO1xuICAgICAgd2luZG93LmxhenlJbml0Q2hhcnQucHVzaCh0aGlzKTtcbiAgICB9XG4gICAgLypcbiAgICAgICAgLy9kbyBsYXp5IGluaXQgb2YgY2hhcnRzIGFmdGVyIHRoaXJkIHBhcnR5IGNhbnZhcyBpbml0aWFsaXphdGlvblxuICAgICAgICBpZiAod2luZG93LmxhenlJbml0Q2hhcnQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG9iaiBpbiB3aW5kb3cubGF6eUluaXRDaGFydCkgb2JqLmluaXRDaGFydCgpLmJpbmQob2JqKTtcbiAgICAgICAgfVxuICAgICAqL1xuICB9XG5cbiAgaW5pdENoYXJ0KCkge1xuICAgIGxldCBjdHggPSB0aGlzLmNhbnZhc29iaiA/IHdpbmRvd1t0aGlzLmNhbnZhc29ial0gOiB0aGlzLmNoYXJ0Y2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgaW5pdENoYXJ0KGN0eCk7XG4gIH1cblxuICBpbml0Q2hhcnQoY3R4KSB7XG4gICAgLypsZXQgdGhhdCA9IHRoaXM7XG4gICAgaWYgKHdpbmRvdy5sYXp5SW5pdENoYXJ0KSB7bGV0IHRoYXQgPSB3aW5kb3cubGF6eUluaXRDaGFydDt9Ki9cbiAgICB0aGlzLmNoYXJ0ID0gbmV3IF9jaGFydC5kZWZhdWx0KGN0eCwge1xuICAgICAgcGx1Z2luczogdGhpcy5wbHVnaW5zLFxuICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgdG9vbHRpcEV2ZW50czogdGhpcy50b29sdGlwc1xuICAgIH0pOyAvL3JlZ2lzdGVyIHRocm90dGxlZCB1cGRhdGUgZnVuY3Rpb25cblxuICAgIGlmICh0eXBlb2YgdGhpcy50aHJvdHRsZSA9PT0gJ3N0cmluZycpIHRoaXMudGhyb3R0bGUgPSBwYXJzZUludCh0aGlzLnRocm90dGxlLCAxMCk7XG5cbiAgICBpZiAodGhpcy50aHJvdHRsZSA+IDApIHtcbiAgICAgIC8vdGhyb3R0bGVcbiAgICAgIHRoaXMudXBkYXRlY2hhcnQgPSBfbG9kYXNoLmRlZmF1bHQudGhyb3R0bGUodGhpcy5jaGFydC51cGRhdGUuYmluZCh0aGlzLmNoYXJ0KSwgdGhpcy50aHJvdHRsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vZGlyZWN0bHkgY2FsbCBjaGFydCB1cGRhdGVcbiAgICAgIHRoaXMudXBkYXRlY2hhcnQgPSB0aGlzLmNoYXJ0LnVwZGF0ZS5iaW5kKHRoaXMuY2hhcnQpO1xuICAgIH0gLy8gY29uc29sZS5sb2coJ2NoYXJ0anMgZGF0YScsIHRoaXMuZGF0YSk7XG5cbiAgICAvKiAgICAvL25vdyBkZWxheSB0b29sdGlwXG4gICAgICAgIGxldCBvcmlnaW5hbFNob3dUb29sdGlwID0gdGhhdC5jaGFydC5zaG93VG9vbHRpcDtcbiAgICAgICAgLy9sZXQgdGhhdC50aW1lb3V0O1xuICAgICAgICB0aGF0LnRpbWVvdXQ9MDtcbiAgICAgICAgdGhhdC5jaGFydC5zaG93VG9vbHRpcCA9IGZ1bmN0aW9uIChhY3RpdmVFbGVtZW50cykge1xuICAgICAgICAgIGxldCBkZWxheSA9IChhY3RpdmVFbGVtZW50cy5sZW5ndGggPT09IDApID8gMjAwMCA6IDA7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoYXQudGltZW91dCk7XG4gICAgICAgICAgdGhhdC50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcmlnaW5hbFNob3dUb29sdGlwLmNhbGwodGhhdC5jaGFydCwgYWN0aXZlRWxlbWVudHMpO1xuICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgfVxuICAgIFxuICAgICAqL1xuXG4gIH1cbiAgLyoqXG4gICAqIGNhbGxlZCB3aGVuIGNvbXBvbmVudCBpcyBkZXRhY2hlZCBmcm9tIHZpZXcgLSByZW1vdmUgZXZlbnQgbGlzdGVuZXJzIC0gbm8gbmVlZCB0byB1cGRhdGUgY2hhcnRcbiAgICovXG5cblxuICBkZXRhY2hlZCgpIHtcbiAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5mcm9taWQpKSB7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmZyb21pZCkucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm1pZGF0YScsIHRoaXMuaGFuZGxlVmFsdWVDaGFuZ2UpO1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5mcm9taWQpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZtaXJlc2V0JywgdGhpcy5oYW5kbGVSZXNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCdjaGFydGpzIFdBUk5JTkcsIG51bGwgZnJvbWlkIGVsZW1lbnQscmVtb3ZpbmcgZnJvbSBnbG9iYWwnKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZtaWRhdGEnLCB0aGlzLmhhbmRsZVZhbHVlQ2hhbmdlKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZtaXJlc2V0JywgdGhpcy5oYW5kbGVSZXNldCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2VjdGlvbmlkKSB7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLnNlY3Rpb25pZCkucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWRkc2VjdGlvbicsIHRoaXMuaGFuZGxlQWRkU2VjdGlvbik7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm1pYXR0YWNoZWQnLCB0aGlzLmhhbmRsZUZNSUF0dGFjaGVkKTtcbiAgfVxuICAvKipcbiAgICogYXNrcyBmb3IgZmlsZW5hbWUgYW5kIGNyZWF0ZXMgYmxvYiB3aXRoIENTViBkYXRhIGZyb20gY2hhcnQgd2hpY2ggaW5pdGlhdGVzIHdlYiBicm93c2VyIGRvd25sb2FkIGRpYWxvZy5cbiAgICogQ1NWIC0gIHRpbWUgcG9pbnQgcGVyIHJvd1xuICAgKi9cblxuXG4gIGRvd25sb2FkKCkge1xuICAgIC8vYXNrIGZvciBmaWxlbmFtZVxuICAgIGxldCBmaWxlbmFtZSA9IHByb21wdCgnRmlsZSBuYW1lICgqLmNzdik6JywgJ2RhdGEuY3N2Jyk7XG5cbiAgICBpZiAoZmlsZW5hbWUpIHtcbiAgICAgIC8vYWRkcyBjc3YgYXMgZXh0ZW5zaW9uXG4gICAgICBpZiAoIWZpbGVuYW1lLmVuZHNXaXRoKCcuY3N2JykpIGZpbGVuYW1lID0gZmlsZW5hbWUuY29uY2F0KCcuY3N2Jyk7IC8vbGFiZWxzIGZpcnN0IHJvd1xuXG4gICAgICBsZXQgY29udGVudCA9ICdUaW1lLCcgKyB0aGlzLmxhYmVscyArICdcXG4nOyAvL3RyYW5zcG9zZSBlYWNoIHJvdyA9IHZhcmlhYmxlIGluIHNwZWNpZmljIHRpbWVcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYXJ0LmRhdGEubGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCByb3cgPSB0aGlzLmNoYXJ0LmRhdGEubGFiZWxzW2ldO1xuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgcm93ICs9ICcsJyArIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tqXS5kYXRhW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGVudCArPSByb3cgKyAnXFxuJztcbiAgICAgIH1cblxuICAgICAgbGV0IGJsb2IgPSBuZXcgQmxvYihbY29udGVudF0sIHtcbiAgICAgICAgdHlwZTogJ3RleHQvY3N2O2NoYXJzZXQ9dXRmLTg7J1xuICAgICAgfSk7XG4gICAgICBzYXZlQXMoYmxvYiwgZmlsZW5hbWUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogYXNrcyBmb3IgZmlsZW5hbWUgYW5kIGNyZWF0ZXMgYmxvYiB3aXRoIENTViBkYXRhIGZyb20gY2hhcnQgd2hpY2ggaW5pdGlhdGVzIHdlYiBicm93c2VyIGRvd25sb2FkIGRpYWxvZ1xuICAgKiBDU1YgLSB2YXJpYWJsZSB2YWx1ZXMgcGVyIHJvd1xuICAgKi9cblxuXG4gIGRvd25sb2FkZmxhdCgpIHtcbiAgICAvL2FzayBmb3IgZmlsZW5hbWVcbiAgICBsZXQgZmlsZW5hbWUgPSBwcm9tcHQoJ0ZpbGUgbmFtZSAoKi5jc3YpOicsICdkYXRhLmNzdicpO1xuXG4gICAgaWYgKGZpbGVuYW1lKSB7XG4gICAgICAvL2FkZHMgY3N2IGFzIGV4dGVuc2lvblxuICAgICAgaWYgKCFmaWxlbmFtZS5lbmRzV2l0aCgnLmNzdicpKSBmaWxlbmFtZSA9IGZpbGVuYW1lLmNvbmNhdCgnLmNzdicpOyAvL2xhYmVscyBmaXJzdCByb3cgLSBlYWNoIHJvdyBpcyB0aGVuIGFsbCBkYXRhIHBlciB2YXJpYWJsZSAtIHRyYW5zcG9zaXRpb24gbWlnaHQgYmUgbmVlZGVkXG5cbiAgICAgIGxldCBjb250ZW50ID0gJ3ZhcmlhYmxlIG5hbWUsdmFsdWVzIC4uLicgKyAnXFxuJztcbiAgICAgIGxldCBsYWJlbHMgPSB0aGlzLmxhYmVscy5zcGxpdCgnLCcpOyAvLyB2YXJpYWJsZSBwZXIgcm93XG4gICAgICAvL2NoYXJ0IGxhYmVscyAtIHVzdWFsbHkgdGltZVxuXG4gICAgICBjb250ZW50ID0gY29udGVudCArICdUaW1lLCcgKyB0aGlzLmNoYXJ0LmRhdGEubGFiZWxzLmpvaW4oJywnKSArICdcXG4nOyAvL2RhdGFzZXQgZGF0YSBvbiBvdGhlciByb3dzXG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnRlbnQgPSBjb250ZW50ICsgbGFiZWxzW2ldICsgJywnICsgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2ldLmRhdGEuam9pbignLCcpICsgJ1xcbic7XG4gICAgICB9XG5cbiAgICAgIGxldCBibG9iID0gbmV3IEJsb2IoW2NvbnRlbnRdLCB7XG4gICAgICAgIHR5cGU6ICd0ZXh0L2NzdjtjaGFyc2V0PXV0Zi04OydcbiAgICAgIH0pO1xuICAgICAgc2F2ZUFzKGJsb2IsIGZpbGVuYW1lKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgbmV3IHNlY3Rpb24gaW4gY2hhcnRhcmVhIC0gY3VycmVudCBsYXN0IGRhdGEgaW4gZGF0YXNldFxuICAgKi9cblxuXG4gIGFkZFNlY3Rpb24obGFiZWwpIHtcbiAgICBpZiAobGFiZWwgPT09IHZvaWQgMCkge1xuICAgICAgbGFiZWwgPSAnJztcbiAgICB9XG5cbiAgICB0aGlzLmluZGV4c2VjdGlvbisrO1xuICAgIGlmICghbGFiZWwpIGxhYmVsID0gJyc7XG4gICAgY29uc29sZS5sb2coJ2NoYXJ0anMuYWRkc2VjdGlvbigpJywgdGhpcy5jaGFydC5kYXRhLmxhYmVscy5sZW5ndGggLSAxLCBsYWJlbCk7XG4gICAgbGV0IGluZDsgLy9pZiAodGhpcy5jaGFydC5kYXRhLmxhYmVscy5sZW5ndGg+MCkgaW5kID0gMFxuICAgIC8vZWxzZVxuXG4gICAgaW5kID0gTWF0aC5tYXgoMCwgdGhpcy5jaGFydC5kYXRhLmxhYmVscy5sZW5ndGggLSAxKTtcbiAgICB0aGlzLmNoYXJ0LmNvbmZpZy5vcHRpb25zLnNlY3Rpb24ucHVzaCh7XG4gICAgICBpbmRleDogaW5kLFxuICAgICAgY29sb3I6IHRoaXMuc2VsZWN0Q29sb3IodGhpcy5pbmRleHNlY3Rpb24gKyB0aGlzLmNvbG9yc2VnbWVudGluZGV4LCA4NSwgOTMpLFxuICAgICAgbGFiZWw6IGxhYmVsXG4gICAgfSk7XG4gIH1cblxufSwgKF9kZXNjcmlwdG9yID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImZyb21pZFwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3IyID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImxhYmVsc1wiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3IzID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcInJlZmluZGV4XCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjQgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwicmVmdmFsdWVzXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjUgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwidHlwZVwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdkb3VnaG51dCc7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjYgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwibWF4ZGF0YVwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDI1NjtcbiAgfVxufSksIF9kZXNjcmlwdG9yNyA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJpbml0aWFsZGF0YVwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59KSwgX2Rlc2NyaXB0b3I4ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcIndpZHRoXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMzAwO1xuICB9XG59KSwgX2Rlc2NyaXB0b3I5ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImhlaWdodFwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDIwMDtcbiAgfVxufSksIF9kZXNjcmlwdG9yMTAgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiYW5pbWF0ZVwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSwgX2Rlc2NyaXB0b3IxMSA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJpZFwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3IxMiA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJ5bGFiZWxcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMTMgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwieGxhYmVsXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjE0ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImNvbnZlcnRvcnNcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMTUgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwidmVydGljYWxsaW5lXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjE2ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImdlbmVyYXRlbGFiZWxzXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjE3ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcInNlY3Rpb25pZFwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3IxOCA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJyZXNwb25zaXZlXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjE5ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcInRocm90dGxlXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMjAwO1xuICB9XG59KSwgX2Rlc2NyaXB0b3IyMCA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJwcmVjaXNpb25cIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiA0O1xuICB9XG59KSwgX2Rlc2NyaXB0b3IyMSA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJtaW5cIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMjIgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwibWF4XCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjIzID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImJhYnlsb25qc1wiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3IyNCA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJjYW52YXNvYmpcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMjUgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiY29sb3JzZWdtZW50aW5kZXhcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAtMjtcbiAgfVxufSksIF9kZXNjcmlwdG9yMjYgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiY29sb3JpbmRleFwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjI3ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcIm1pbmljaGFydFwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSksIF9jbGFzcyk7XG5leHBvcnRzLkNoYXJ0anMgPSBDaGFydGpzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhcnRqcy5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-barplot":
/*!***********************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-barplot.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.ChartjsBarplot = void 0;\n\nvar _chartjs = __webpack_require__(/*! ./chartjs */ \"aurelia-bodylight-plugin/elements/chartjs\");\n\nvar _chartjsPluginDatalabels = _interopRequireDefault(__webpack_require__(/*! chartjs-plugin-datalabels */ \"qb46\"));\n\nvar _aureliaTemplating = __webpack_require__(/*! aurelia-templating */ \"hij8\");\n\nvar _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\n//import {PLATFORM} from 'aurelia-pal';\n//@useView(PLATFORM.moduleName('./bdl-chartjs.html'))\n//@useView('./chartjs.html')\nlet ChartjsBarplot = (_class = class ChartjsBarplot extends _chartjs.Chartjs {\n  //csv limits of chart min and max\n  //='';//0.25,0.75'; //csv normal limits inside chart\n  //sets precision to floor/round\n  //whether click will create event 'change'\n  constructor() {\n    super();\n\n    _initializerDefineProperty(this, \"id\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"fromid\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"labels\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"refindex\", _descriptor4, this);\n\n    _initializerDefineProperty(this, \"refvalues\", _descriptor5, this);\n\n    _initializerDefineProperty(this, \"extremelimits\", _descriptor6, this);\n\n    _initializerDefineProperty(this, \"normallimits\", _descriptor7, this);\n\n    _initializerDefineProperty(this, \"initialdata\", _descriptor8, this);\n\n    _initializerDefineProperty(this, \"width\", _descriptor9, this);\n\n    _initializerDefineProperty(this, \"height\", _descriptor10, this);\n\n    _initializerDefineProperty(this, \"nominal\", _descriptor11, this);\n\n    _initializerDefineProperty(this, \"twoway\", _descriptor12, this);\n\n    _initializerDefineProperty(this, \"responsive\", _descriptor13, this);\n\n    this.handleValueChange = e => {\n      //sets data to dataset\n      //apply value convert among all data\n      let rawdata = e.detail.data.slice(this.refindex, this.refendindex); //if convert operation is defined as array\n\n      if (this.operation) {\n        for (let i = 0; i < rawdata.length; i++) {\n          //if particular operation is defined\n          if (this.operation[i]) rawdata[i] = this.operation[i](rawdata[i]);\n        }\n      }\n\n      this.chart.data.datasets[0].data = rawdata; //now decide whether datalabel is right or left\n\n      if ((this.elimits[1] - rawdata) / (this.elimits[1] - this.elimits[0]) < 0.05) {\n        this.options.plugins.datalabels.align = 'left';\n        this.options.plugins.datalabels.color = 'white';\n      } else {\n        this.options.plugins.datalabels.align = 'right';\n        this.options.plugins.datalabels.color = 'black';\n      }\n\n      this.updatechart();\n    };\n  }\n\n  bind() {\n    super.bind();\n    this.plugins = [_chartjsPluginDatalabels.default];\n\n    if (this.extremelimits) {\n      this.elimits = this.extremelimits.split(','); //split by comma\n\n      for (let i = 0; i < this.elimits.length; i++) this.elimits[i] = parseFloat(this.elimits[i]);\n    }\n\n    if (this.normallimits) {\n      this.nlimits = this.normallimits.split(',');\n\n      for (let i = 0; i < this.nlimits.length; i++) this.nlimits[i] = parseFloat(this.nlimits[i]);\n    }\n\n    if (this.nominal) {\n      if (typeof this.nominal === 'string') this.nominal = parseFloat(this.nominal);\n      this.options.nominal = this.nominal;\n    }\n\n    if (this.twoway && typeof this.twoway === 'string') {\n      this.twoway = this.twoway === 'true';\n    } //chartjs type horizontal bar\n\n\n    this.type = 'horizontalBar'; // no legend and no labels\n    //this.chlabels = [];\n\n    this.options.legend.display = false; //sets xaxis limits to extremelimits\n\n    if (!this.options.scales.xAxes) this.options.scales.xAxes = [{}];\n    this.options.scales.xAxes[0].ticks = {\n      autoSkip: true,\n      min: this.elimits[0],\n      max: this.elimits[1],\n      fontSize: 8,\n      callback: function (value, index, values) {\n        //count relative distance to last tick value\n        const reldistance = (values[3] - value) / (values[3] - values[0]); // do not display tick label if too close to extreme limit (<5% of length)\n\n        if (index === 2 && reldistance < 0.05) return '';\n        return value;\n      }\n    }; //set ticks to extreme and normal limits only\n\n    let myticks = this.normallimits ? [this.elimits[0], this.nlimits[0], this.nlimits[1], this.elimits[1]] : [this.elimits[0], this.elimits[1]]; //console.log('charjs barplot myticks', myticks);\n\n    this.options.scales.xAxes[0].afterBuildTicks = function (scale) {\n      scale.ticks = myticks;\n      return;\n    };\n\n    this.options.scales.xAxes[0].beforeUpdate = function (oScale) {\n      return;\n    }; //datalabel plugin shows value right of the bar\n\n\n    this.options.plugins = {\n      datalabels: {\n        align: 'right',\n        anchor: 'end',\n        formatter: function (value, context) {\n          return value.toPrecision(3);\n        },\n        font: {\n          size: 8\n        },\n        padding: {\n          top: 0,\n          right: 0,\n          bottom: 0,\n          left: 1\n        }\n      }\n    }; //now decide whether datalabel is right or left\n    //TODO eliminate duplicate in handlevaluechange\n\n    if ((this.elimits[1] - parseFloat(this.initialdata)) / (this.elimits[1] - this.elimits[0]) < 0.05) {\n      this.options.plugins.datalabels.align = 'left';\n      this.options.plugins.datalabels.color = 'white';\n    } else {\n      this.options.plugins.datalabels.align = 'right';\n      this.options.plugins.datalabels.color = 'black';\n    } //if the component is twoway - on click shows second bar with desired value and triggers 'change' event\n\n\n    if (this.twoway) {\n      //sets options for chart\n      this.options.events = ['click'];\n      this.options.parentId = this.id; //this.options.parentvm = this;\n\n      this.options.onClick = function (c, i) {\n        //note this - refers now to chart, not to webcomponent - shared properties are via options.nominal and options.parentid\n        //console.log('chartjs barplot click,', c, i, 'this:', this);\n        //let scaler = this.chart.scales['y-axis-0'];\n        let xscaler = this.chart.scales['x-axis-0']; //let y = c.clientY - this.canvas.getBoundingClientRect().top - scaler.top;\n\n        let x = c.clientX - this.canvas.getBoundingClientRect().left - xscaler.left; //let yval = scaler.max - y / scaler.height * (scaler.max - scaler.min);\n\n        let xval = xscaler.min + x / xscaler.width * (xscaler.max - xscaler.min);\n\n        if (this.options.nominal) {\n          //nominal is defined - floor xval to nominal\n          xval = Math.floor(xval / this.options.nominal) * this.options.nominal;\n        } //console.log('value clicked: %o, ypx: %o', yval, y);\n        //console.log('value clicked: %o, xpx: %o', xval, x);\n        //this.trigger('onTickerXClick', xval);\n\n\n        if (this.data.datasets.length < 2) {\n          this.data.datasets.push({\n            data: [xval],\n            backgroundColor: '#ff0000',\n            label: 'new value'\n          });\n        } else this.data.datasets[1].data = [xval];\n\n        this.update(); //create and dispatch change event\n\n        let event = new CustomEvent('change', {\n          detail: {\n            value: xval,\n            id: this.options.parentId\n          }\n        }); //dispatch event - it should be listened by some other component\n\n        document.getElementById(this.options.parentId).dispatchEvent(event); //this.parentvm.valueChanged(xval);\n      };\n    }\n\n    this.options.tooltips = {\n      enabled: false\n    };\n    this.tooltips = [];\n    /*if (!this.options.scales.yAxes) this.options.scales.yAxes = [{}];\n    this.options.scales.yAxes[0].ticks = {\n      max: 5,\n      min: 0,\n      stepSize: 0.5\n    };*/\n  }\n\n  valueChanged(value) {\n    console.log('chartjs barplot valuechanged:', value);\n  }\n\n}, (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"id\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"fromid\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"labels\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, \"refindex\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, \"refvalues\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 1;\n  }\n}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, \"extremelimits\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return '0,1';\n  }\n}), _descriptor7 = _applyDecoratedDescriptor(_class.prototype, \"normallimits\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor8 = _applyDecoratedDescriptor(_class.prototype, \"initialdata\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return '7.5';\n  }\n}), _descriptor9 = _applyDecoratedDescriptor(_class.prototype, \"width\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return '500';\n  }\n}), _descriptor10 = _applyDecoratedDescriptor(_class.prototype, \"height\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return '50';\n  }\n}), _descriptor11 = _applyDecoratedDescriptor(_class.prototype, \"nominal\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 0.01;\n  }\n}), _descriptor12 = _applyDecoratedDescriptor(_class.prototype, \"twoway\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return false;\n  }\n}), _descriptor13 = _applyDecoratedDescriptor(_class.prototype, \"responsive\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class);\nexports.ChartjsBarplot = ChartjsBarplot;\n//# sourceMappingURL=chartjs-barplot.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMtYmFycGxvdC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLWJvZHlsaWdodC1wbHVnaW4vZGlzdC9uYXRpdmUtbW9kdWxlcy9lbGVtZW50cy9jaGFydGpzLWJhcnBsb3QuanM/MjFjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQ2hhcnRqc0JhcnBsb3QgPSB2b2lkIDA7XG5cbnZhciBfY2hhcnRqcyA9IHJlcXVpcmUoXCIuL2NoYXJ0anNcIik7XG5cbnZhciBfY2hhcnRqc1BsdWdpbkRhdGFsYWJlbHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzXCIpKTtcblxudmFyIF9hdXJlbGlhVGVtcGxhdGluZyA9IHJlcXVpcmUoXCJhdXJlbGlhLXRlbXBsYXRpbmdcIik7XG5cbnZhciBfY2xhc3MsIF9kZXNjcmlwdG9yLCBfZGVzY3JpcHRvcjIsIF9kZXNjcmlwdG9yMywgX2Rlc2NyaXB0b3I0LCBfZGVzY3JpcHRvcjUsIF9kZXNjcmlwdG9yNiwgX2Rlc2NyaXB0b3I3LCBfZGVzY3JpcHRvcjgsIF9kZXNjcmlwdG9yOSwgX2Rlc2NyaXB0b3IxMCwgX2Rlc2NyaXB0b3IxMSwgX2Rlc2NyaXB0b3IxMiwgX2Rlc2NyaXB0b3IxMztcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvciwgY29udGV4dCkgeyBpZiAoIWRlc2NyaXB0b3IpIHJldHVybjsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHsgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLCBjb25maWd1cmFibGU6IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlLCB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSwgdmFsdWU6IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIgPyBkZXNjcmlwdG9yLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDAgfSk7IH1cblxuZnVuY3Rpb24gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5LCBkZWNvcmF0b3JzLCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7IHZhciBkZXNjID0ge307IE9iamVjdC5rZXlzKGRlc2NyaXB0b3IpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBkZXNjW2tleV0gPSBkZXNjcmlwdG9yW2tleV07IH0pOyBkZXNjLmVudW1lcmFibGUgPSAhIWRlc2MuZW51bWVyYWJsZTsgZGVzYy5jb25maWd1cmFibGUgPSAhIWRlc2MuY29uZmlndXJhYmxlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjIHx8IGRlc2MuaW5pdGlhbGl6ZXIpIHsgZGVzYy53cml0YWJsZSA9IHRydWU7IH0gZGVzYyA9IGRlY29yYXRvcnMuc2xpY2UoKS5yZXZlcnNlKCkucmVkdWNlKGZ1bmN0aW9uIChkZXNjLCBkZWNvcmF0b3IpIHsgcmV0dXJuIGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5LCBkZXNjKSB8fCBkZXNjOyB9LCBkZXNjKTsgaWYgKGNvbnRleHQgJiYgZGVzYy5pbml0aWFsaXplciAhPT0gdm9pZCAwKSB7IGRlc2MudmFsdWUgPSBkZXNjLmluaXRpYWxpemVyID8gZGVzYy5pbml0aWFsaXplci5jYWxsKGNvbnRleHQpIDogdm9pZCAwOyBkZXNjLmluaXRpYWxpemVyID0gdW5kZWZpbmVkOyB9IGlmIChkZXNjLmluaXRpYWxpemVyID09PSB2b2lkIDApIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2MpOyBkZXNjID0gbnVsbDsgfSByZXR1cm4gZGVzYzsgfVxuXG5mdW5jdGlvbiBfaW5pdGlhbGl6ZXJXYXJuaW5nSGVscGVyKGRlc2NyaXB0b3IsIGNvbnRleHQpIHsgdGhyb3cgbmV3IEVycm9yKCdEZWNvcmF0aW5nIGNsYXNzIHByb3BlcnR5IGZhaWxlZC4gUGxlYXNlIGVuc3VyZSB0aGF0ICcgKyAncHJvcG9zYWwtY2xhc3MtcHJvcGVydGllcyBpcyBlbmFibGVkIGFuZCBydW5zIGFmdGVyIHRoZSBkZWNvcmF0b3JzIHRyYW5zZm9ybS4nKTsgfVxuXG4vL2ltcG9ydCB7UExBVEZPUk19IGZyb20gJ2F1cmVsaWEtcGFsJztcbi8vQHVzZVZpZXcoUExBVEZPUk0ubW9kdWxlTmFtZSgnLi9iZGwtY2hhcnRqcy5odG1sJykpXG4vL0B1c2VWaWV3KCcuL2NoYXJ0anMuaHRtbCcpXG5sZXQgQ2hhcnRqc0JhcnBsb3QgPSAoX2NsYXNzID0gY2xhc3MgQ2hhcnRqc0JhcnBsb3QgZXh0ZW5kcyBfY2hhcnRqcy5DaGFydGpzIHtcbiAgLy9jc3YgbGltaXRzIG9mIGNoYXJ0IG1pbiBhbmQgbWF4XG4gIC8vPScnOy8vMC4yNSwwLjc1JzsgLy9jc3Ygbm9ybWFsIGxpbWl0cyBpbnNpZGUgY2hhcnRcbiAgLy9zZXRzIHByZWNpc2lvbiB0byBmbG9vci9yb3VuZFxuICAvL3doZXRoZXIgY2xpY2sgd2lsbCBjcmVhdGUgZXZlbnQgJ2NoYW5nZSdcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwgX2Rlc2NyaXB0b3IsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJmcm9taWRcIiwgX2Rlc2NyaXB0b3IyLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwibGFiZWxzXCIsIF9kZXNjcmlwdG9yMywgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZmluZGV4XCIsIF9kZXNjcmlwdG9yNCwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZnZhbHVlc1wiLCBfZGVzY3JpcHRvcjUsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJleHRyZW1lbGltaXRzXCIsIF9kZXNjcmlwdG9yNiwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5vcm1hbGxpbWl0c1wiLCBfZGVzY3JpcHRvcjcsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJpbml0aWFsZGF0YVwiLCBfZGVzY3JpcHRvcjgsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJ3aWR0aFwiLCBfZGVzY3JpcHRvcjksIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJoZWlnaHRcIiwgX2Rlc2NyaXB0b3IxMCwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5vbWluYWxcIiwgX2Rlc2NyaXB0b3IxMSwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInR3b3dheVwiLCBfZGVzY3JpcHRvcjEyLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzcG9uc2l2ZVwiLCBfZGVzY3JpcHRvcjEzLCB0aGlzKTtcblxuICAgIHRoaXMuaGFuZGxlVmFsdWVDaGFuZ2UgPSBlID0+IHtcbiAgICAgIC8vc2V0cyBkYXRhIHRvIGRhdGFzZXRcbiAgICAgIC8vYXBwbHkgdmFsdWUgY29udmVydCBhbW9uZyBhbGwgZGF0YVxuICAgICAgbGV0IHJhd2RhdGEgPSBlLmRldGFpbC5kYXRhLnNsaWNlKHRoaXMucmVmaW5kZXgsIHRoaXMucmVmZW5kaW5kZXgpOyAvL2lmIGNvbnZlcnQgb3BlcmF0aW9uIGlzIGRlZmluZWQgYXMgYXJyYXlcblxuICAgICAgaWYgKHRoaXMub3BlcmF0aW9uKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIC8vaWYgcGFydGljdWxhciBvcGVyYXRpb24gaXMgZGVmaW5lZFxuICAgICAgICAgIGlmICh0aGlzLm9wZXJhdGlvbltpXSkgcmF3ZGF0YVtpXSA9IHRoaXMub3BlcmF0aW9uW2ldKHJhd2RhdGFbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhID0gcmF3ZGF0YTsgLy9ub3cgZGVjaWRlIHdoZXRoZXIgZGF0YWxhYmVsIGlzIHJpZ2h0IG9yIGxlZnRcblxuICAgICAgaWYgKCh0aGlzLmVsaW1pdHNbMV0gLSByYXdkYXRhKSAvICh0aGlzLmVsaW1pdHNbMV0gLSB0aGlzLmVsaW1pdHNbMF0pIDwgMC4wNSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMucGx1Z2lucy5kYXRhbGFiZWxzLmFsaWduID0gJ2xlZnQnO1xuICAgICAgICB0aGlzLm9wdGlvbnMucGx1Z2lucy5kYXRhbGFiZWxzLmNvbG9yID0gJ3doaXRlJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5wbHVnaW5zLmRhdGFsYWJlbHMuYWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB0aGlzLm9wdGlvbnMucGx1Z2lucy5kYXRhbGFiZWxzLmNvbG9yID0gJ2JsYWNrJztcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVjaGFydCgpO1xuICAgIH07XG4gIH1cblxuICBiaW5kKCkge1xuICAgIHN1cGVyLmJpbmQoKTtcbiAgICB0aGlzLnBsdWdpbnMgPSBbX2NoYXJ0anNQbHVnaW5EYXRhbGFiZWxzLmRlZmF1bHRdO1xuXG4gICAgaWYgKHRoaXMuZXh0cmVtZWxpbWl0cykge1xuICAgICAgdGhpcy5lbGltaXRzID0gdGhpcy5leHRyZW1lbGltaXRzLnNwbGl0KCcsJyk7IC8vc3BsaXQgYnkgY29tbWFcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmVsaW1pdHMubGVuZ3RoOyBpKyspIHRoaXMuZWxpbWl0c1tpXSA9IHBhcnNlRmxvYXQodGhpcy5lbGltaXRzW2ldKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ub3JtYWxsaW1pdHMpIHtcbiAgICAgIHRoaXMubmxpbWl0cyA9IHRoaXMubm9ybWFsbGltaXRzLnNwbGl0KCcsJyk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ubGltaXRzLmxlbmd0aDsgaSsrKSB0aGlzLm5saW1pdHNbaV0gPSBwYXJzZUZsb2F0KHRoaXMubmxpbWl0c1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubm9taW5hbCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm5vbWluYWwgPT09ICdzdHJpbmcnKSB0aGlzLm5vbWluYWwgPSBwYXJzZUZsb2F0KHRoaXMubm9taW5hbCk7XG4gICAgICB0aGlzLm9wdGlvbnMubm9taW5hbCA9IHRoaXMubm9taW5hbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50d293YXkgJiYgdHlwZW9mIHRoaXMudHdvd2F5ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy50d293YXkgPSB0aGlzLnR3b3dheSA9PT0gJ3RydWUnO1xuICAgIH0gLy9jaGFydGpzIHR5cGUgaG9yaXpvbnRhbCBiYXJcblxuXG4gICAgdGhpcy50eXBlID0gJ2hvcml6b250YWxCYXInOyAvLyBubyBsZWdlbmQgYW5kIG5vIGxhYmVsc1xuICAgIC8vdGhpcy5jaGxhYmVscyA9IFtdO1xuXG4gICAgdGhpcy5vcHRpb25zLmxlZ2VuZC5kaXNwbGF5ID0gZmFsc2U7IC8vc2V0cyB4YXhpcyBsaW1pdHMgdG8gZXh0cmVtZWxpbWl0c1xuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2NhbGVzLnhBeGVzKSB0aGlzLm9wdGlvbnMuc2NhbGVzLnhBeGVzID0gW3t9XTtcbiAgICB0aGlzLm9wdGlvbnMuc2NhbGVzLnhBeGVzWzBdLnRpY2tzID0ge1xuICAgICAgYXV0b1NraXA6IHRydWUsXG4gICAgICBtaW46IHRoaXMuZWxpbWl0c1swXSxcbiAgICAgIG1heDogdGhpcy5lbGltaXRzWzFdLFxuICAgICAgZm9udFNpemU6IDgsXG4gICAgICBjYWxsYmFjazogZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgdmFsdWVzKSB7XG4gICAgICAgIC8vY291bnQgcmVsYXRpdmUgZGlzdGFuY2UgdG8gbGFzdCB0aWNrIHZhbHVlXG4gICAgICAgIGNvbnN0IHJlbGRpc3RhbmNlID0gKHZhbHVlc1szXSAtIHZhbHVlKSAvICh2YWx1ZXNbM10gLSB2YWx1ZXNbMF0pOyAvLyBkbyBub3QgZGlzcGxheSB0aWNrIGxhYmVsIGlmIHRvbyBjbG9zZSB0byBleHRyZW1lIGxpbWl0ICg8NSUgb2YgbGVuZ3RoKVxuXG4gICAgICAgIGlmIChpbmRleCA9PT0gMiAmJiByZWxkaXN0YW5jZSA8IDAuMDUpIHJldHVybiAnJztcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH07IC8vc2V0IHRpY2tzIHRvIGV4dHJlbWUgYW5kIG5vcm1hbCBsaW1pdHMgb25seVxuXG4gICAgbGV0IG15dGlja3MgPSB0aGlzLm5vcm1hbGxpbWl0cyA/IFt0aGlzLmVsaW1pdHNbMF0sIHRoaXMubmxpbWl0c1swXSwgdGhpcy5ubGltaXRzWzFdLCB0aGlzLmVsaW1pdHNbMV1dIDogW3RoaXMuZWxpbWl0c1swXSwgdGhpcy5lbGltaXRzWzFdXTsgLy9jb25zb2xlLmxvZygnY2hhcmpzIGJhcnBsb3QgbXl0aWNrcycsIG15dGlja3MpO1xuXG4gICAgdGhpcy5vcHRpb25zLnNjYWxlcy54QXhlc1swXS5hZnRlckJ1aWxkVGlja3MgPSBmdW5jdGlvbiAoc2NhbGUpIHtcbiAgICAgIHNjYWxlLnRpY2tzID0gbXl0aWNrcztcbiAgICAgIHJldHVybjtcbiAgICB9O1xuXG4gICAgdGhpcy5vcHRpb25zLnNjYWxlcy54QXhlc1swXS5iZWZvcmVVcGRhdGUgPSBmdW5jdGlvbiAob1NjYWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfTsgLy9kYXRhbGFiZWwgcGx1Z2luIHNob3dzIHZhbHVlIHJpZ2h0IG9mIHRoZSBiYXJcblxuXG4gICAgdGhpcy5vcHRpb25zLnBsdWdpbnMgPSB7XG4gICAgICBkYXRhbGFiZWxzOiB7XG4gICAgICAgIGFsaWduOiAncmlnaHQnLFxuICAgICAgICBhbmNob3I6ICdlbmQnLFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZS50b1ByZWNpc2lvbigzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9udDoge1xuICAgICAgICAgIHNpemU6IDhcbiAgICAgICAgfSxcbiAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgbGVmdDogMVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTsgLy9ub3cgZGVjaWRlIHdoZXRoZXIgZGF0YWxhYmVsIGlzIHJpZ2h0IG9yIGxlZnRcbiAgICAvL1RPRE8gZWxpbWluYXRlIGR1cGxpY2F0ZSBpbiBoYW5kbGV2YWx1ZWNoYW5nZVxuXG4gICAgaWYgKCh0aGlzLmVsaW1pdHNbMV0gLSBwYXJzZUZsb2F0KHRoaXMuaW5pdGlhbGRhdGEpKSAvICh0aGlzLmVsaW1pdHNbMV0gLSB0aGlzLmVsaW1pdHNbMF0pIDwgMC4wNSkge1xuICAgICAgdGhpcy5vcHRpb25zLnBsdWdpbnMuZGF0YWxhYmVscy5hbGlnbiA9ICdsZWZ0JztcbiAgICAgIHRoaXMub3B0aW9ucy5wbHVnaW5zLmRhdGFsYWJlbHMuY29sb3IgPSAnd2hpdGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wdGlvbnMucGx1Z2lucy5kYXRhbGFiZWxzLmFsaWduID0gJ3JpZ2h0JztcbiAgICAgIHRoaXMub3B0aW9ucy5wbHVnaW5zLmRhdGFsYWJlbHMuY29sb3IgPSAnYmxhY2snO1xuICAgIH0gLy9pZiB0aGUgY29tcG9uZW50IGlzIHR3b3dheSAtIG9uIGNsaWNrIHNob3dzIHNlY29uZCBiYXIgd2l0aCBkZXNpcmVkIHZhbHVlIGFuZCB0cmlnZ2VycyAnY2hhbmdlJyBldmVudFxuXG5cbiAgICBpZiAodGhpcy50d293YXkpIHtcbiAgICAgIC8vc2V0cyBvcHRpb25zIGZvciBjaGFydFxuICAgICAgdGhpcy5vcHRpb25zLmV2ZW50cyA9IFsnY2xpY2snXTtcbiAgICAgIHRoaXMub3B0aW9ucy5wYXJlbnRJZCA9IHRoaXMuaWQ7IC8vdGhpcy5vcHRpb25zLnBhcmVudHZtID0gdGhpcztcblxuICAgICAgdGhpcy5vcHRpb25zLm9uQ2xpY2sgPSBmdW5jdGlvbiAoYywgaSkge1xuICAgICAgICAvL25vdGUgdGhpcyAtIHJlZmVycyBub3cgdG8gY2hhcnQsIG5vdCB0byB3ZWJjb21wb25lbnQgLSBzaGFyZWQgcHJvcGVydGllcyBhcmUgdmlhIG9wdGlvbnMubm9taW5hbCBhbmQgb3B0aW9ucy5wYXJlbnRpZFxuICAgICAgICAvL2NvbnNvbGUubG9nKCdjaGFydGpzIGJhcnBsb3QgY2xpY2ssJywgYywgaSwgJ3RoaXM6JywgdGhpcyk7XG4gICAgICAgIC8vbGV0IHNjYWxlciA9IHRoaXMuY2hhcnQuc2NhbGVzWyd5LWF4aXMtMCddO1xuICAgICAgICBsZXQgeHNjYWxlciA9IHRoaXMuY2hhcnQuc2NhbGVzWyd4LWF4aXMtMCddOyAvL2xldCB5ID0gYy5jbGllbnRZIC0gdGhpcy5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC0gc2NhbGVyLnRvcDtcblxuICAgICAgICBsZXQgeCA9IGMuY2xpZW50WCAtIHRoaXMuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSB4c2NhbGVyLmxlZnQ7IC8vbGV0IHl2YWwgPSBzY2FsZXIubWF4IC0geSAvIHNjYWxlci5oZWlnaHQgKiAoc2NhbGVyLm1heCAtIHNjYWxlci5taW4pO1xuXG4gICAgICAgIGxldCB4dmFsID0geHNjYWxlci5taW4gKyB4IC8geHNjYWxlci53aWR0aCAqICh4c2NhbGVyLm1heCAtIHhzY2FsZXIubWluKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5vbWluYWwpIHtcbiAgICAgICAgICAvL25vbWluYWwgaXMgZGVmaW5lZCAtIGZsb29yIHh2YWwgdG8gbm9taW5hbFxuICAgICAgICAgIHh2YWwgPSBNYXRoLmZsb29yKHh2YWwgLyB0aGlzLm9wdGlvbnMubm9taW5hbCkgKiB0aGlzLm9wdGlvbnMubm9taW5hbDtcbiAgICAgICAgfSAvL2NvbnNvbGUubG9nKCd2YWx1ZSBjbGlja2VkOiAlbywgeXB4OiAlbycsIHl2YWwsIHkpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKCd2YWx1ZSBjbGlja2VkOiAlbywgeHB4OiAlbycsIHh2YWwsIHgpO1xuICAgICAgICAvL3RoaXMudHJpZ2dlcignb25UaWNrZXJYQ2xpY2snLCB4dmFsKTtcblxuXG4gICAgICAgIGlmICh0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgIHRoaXMuZGF0YS5kYXRhc2V0cy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGE6IFt4dmFsXSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNmZjAwMDAnLFxuICAgICAgICAgICAgbGFiZWw6ICduZXcgdmFsdWUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB0aGlzLmRhdGEuZGF0YXNldHNbMV0uZGF0YSA9IFt4dmFsXTtcblxuICAgICAgICB0aGlzLnVwZGF0ZSgpOyAvL2NyZWF0ZSBhbmQgZGlzcGF0Y2ggY2hhbmdlIGV2ZW50XG5cbiAgICAgICAgbGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdjaGFuZ2UnLCB7XG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICB2YWx1ZTogeHZhbCxcbiAgICAgICAgICAgIGlkOiB0aGlzLm9wdGlvbnMucGFyZW50SWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pOyAvL2Rpc3BhdGNoIGV2ZW50IC0gaXQgc2hvdWxkIGJlIGxpc3RlbmVkIGJ5IHNvbWUgb3RoZXIgY29tcG9uZW50XG5cbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5vcHRpb25zLnBhcmVudElkKS5kaXNwYXRjaEV2ZW50KGV2ZW50KTsgLy90aGlzLnBhcmVudHZtLnZhbHVlQ2hhbmdlZCh4dmFsKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zLnRvb2x0aXBzID0ge1xuICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMudG9vbHRpcHMgPSBbXTtcbiAgICAvKmlmICghdGhpcy5vcHRpb25zLnNjYWxlcy55QXhlcykgdGhpcy5vcHRpb25zLnNjYWxlcy55QXhlcyA9IFt7fV07XG4gICAgdGhpcy5vcHRpb25zLnNjYWxlcy55QXhlc1swXS50aWNrcyA9IHtcbiAgICAgIG1heDogNSxcbiAgICAgIG1pbjogMCxcbiAgICAgIHN0ZXBTaXplOiAwLjVcbiAgICB9OyovXG4gIH1cblxuICB2YWx1ZUNoYW5nZWQodmFsdWUpIHtcbiAgICBjb25zb2xlLmxvZygnY2hhcnRqcyBiYXJwbG90IHZhbHVlY2hhbmdlZDonLCB2YWx1ZSk7XG4gIH1cblxufSwgKF9kZXNjcmlwdG9yID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImlkXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3IyID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImZyb21pZFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMyA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJsYWJlbHNcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjQgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwicmVmaW5kZXhcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjUgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwicmVmdmFsdWVzXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjYgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiZXh0cmVtZWxpbWl0c1wiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnMCwxJztcbiAgfVxufSksIF9kZXNjcmlwdG9yNyA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJub3JtYWxsaW1pdHNcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjggPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiaW5pdGlhbGRhdGFcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJzcuNSc7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjkgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwid2lkdGhcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJzUwMCc7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjEwID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImhlaWdodFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnNTAnO1xuICB9XG59KSwgX2Rlc2NyaXB0b3IxMSA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJub21pbmFsXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDAuMDE7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjEyID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcInR3b3dheVwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSksIF9kZXNjcmlwdG9yMTMgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwicmVzcG9uc2l2ZVwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSkpLCBfY2xhc3MpO1xuZXhwb3J0cy5DaGFydGpzQmFycGxvdCA9IENoYXJ0anNCYXJwbG90O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhcnRqcy1iYXJwbG90LmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-barplot\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-barplot.html":
/*!*************************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-barplot.html ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template bindable=\\\"width,height\\\">\\n    <div id=\\\"canvas-holder\\\">\\n        <canvas id=\\\"${id}-canvas\\\" ref=\\\"chartcanvas\\\" width=\\\"${width}\\\" height=\\\"${height}\\\"></canvas>\\n    </div>\\n</template>\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMtYmFycGxvdC5odG1sLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F1cmVsaWEtYm9keWxpZ2h0LXBsdWdpbi9kaXN0L25hdGl2ZS1tb2R1bGVzL2VsZW1lbnRzL2NoYXJ0anMtYmFycGxvdC5odG1sP2M3OWYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIjx0ZW1wbGF0ZSBiaW5kYWJsZT1cXFwid2lkdGgsaGVpZ2h0XFxcIj5cXG4gICAgPGRpdiBpZD1cXFwiY2FudmFzLWhvbGRlclxcXCI+XFxuICAgICAgICA8Y2FudmFzIGlkPVxcXCIke2lkfS1jYW52YXNcXFwiIHJlZj1cXFwiY2hhcnRjYW52YXNcXFwiIHdpZHRoPVxcXCIke3dpZHRofVxcXCIgaGVpZ2h0PVxcXCIke2hlaWdodH1cXFwiPjwvY2FudmFzPlxcbiAgICA8L2Rpdj5cXG48L3RlbXBsYXRlPlwiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-barplot.html\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-fixed":
/*!*********************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-fixed.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.ChartjsFixed = void 0;\n\nvar _aureliaTemplating = __webpack_require__(/*! aurelia-templating */ \"hij8\");\n\nvar _chartjs = __webpack_require__(/*! ./chartjs */ \"aurelia-bodylight-plugin/elements/chartjs\");\n\nvar _lodash = _interopRequireDefault(__webpack_require__(/*! lodash */ \"LvDl\"));\n\nvar _chart = _interopRequireDefault(__webpack_require__(/*! chart.js */ \"MO+k\"));\n\nvar _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\n/**\n * shows fixed curve at time -\n * on X is 0,1,2,3,4,5,6,7,8,9\n * on Y is values from FMU variables from refindex to refvalues\n */\nlet ChartjsFixed = (_dec = (0, _aureliaTemplating.useView)('./chartjs.html'), _dec(_class = (_class2 = class ChartjsFixed extends _chartjs.Chartjs {\n  //DOM id of FMU component to listen fmu-data event\n  //labels of datasets\n  //variable index in fmu data\n  //how many variables to show from fmu data\n  //type of chart - is overwritten to 'line'\n  //if defined chartjs y axis from min\n  //if defined chartjs y axis to max\n  //howmany datasets to remember\n  //from whic colorindex to start, 0 blue, 1 red, 2 green,...\n  //extra dataset with only one point is drawn\n  //@bindable cachesize;\n  constructor() {\n    super();\n\n    _initializerDefineProperty(this, \"fromid\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"labels\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"refindex\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"refvalues\", _descriptor4, this);\n\n    _initializerDefineProperty(this, \"type\", _descriptor5, this);\n\n    _initializerDefineProperty(this, \"min\", _descriptor6, this);\n\n    _initializerDefineProperty(this, \"max\", _descriptor7, this);\n\n    _initializerDefineProperty(this, \"maxdata\", _descriptor8, this);\n\n    _initializerDefineProperty(this, \"colorindex\", _descriptor9, this);\n\n    _initializerDefineProperty(this, \"highlightindex\", _descriptor10, this);\n\n    _initializerDefineProperty(this, \"refpointindex\", _descriptor11, this);\n\n    this.currentcolor = void 0;\n    this.previouscolor = void 0;\n    this.previouscolor2 = void 0;\n    this.currentcolorb = void 0;\n    this.previouscolorb = void 0;\n    this.previouscolorb2 = void 0;\n    this.currentdataset = 0;\n\n    this.handleValueChange = e => {\n      //let j = this.currentdataset;\n      //all values from refindex to one dataset - as one curve\n      //if (!this.chart.data.datasets[j]) {\n      //do initialize dataset first\n      let newdataset = {\n        data: e.detail.data.slice(this.refindex, this.refindex + this.refvalues),\n        label: \"\",\n        backgroundColor: this.currentcolor,\n        borderColor: this.currentcolor,\n        borderWidth: 1,\n        pointRadius: 1,\n        fill: false\n      }; //index to blure color\n\n      let colorindex = 1; //decide whether to add point\n\n      if (this.refpointindex) {\n        let newpointdataset = {\n          data: [e.detail.data[this.refpointindex]],\n          label: \"\",\n          backgroundColor: this.currentcolor,\n          borderColor: this.currentcolor,\n          borderWidth: 1,\n          pointRadius: 0,\n          fill: false\n        };\n        this.chart.data.datasets[0] = newdataset;\n        this.chart.data.datasets.unshift(newpointdataset); //blur color from inde 2, [0] is point [1] is dataset\n\n        colorindex = 2;\n      } else {\n        this.chart.data.datasets.unshift(newdataset);\n      }\n\n      if (this.chart.data.datasets[colorindex]) {\n        this.chart.data.datasets[colorindex].backgroundColor = this.previouscolor;\n        this.chart.data.datasets[colorindex].borderColor = this.previouscolor;\n      }\n\n      if (this.chart.data.datasets[colorindex + 1]) {\n        this.chart.data.datasets[colorindex + 1].backgroundColor = this.previouscolor2;\n        this.chart.data.datasets[colorindex + 1].borderColor = this.previouscolor2;\n      } //do apply operation on each element of array\n\n\n      if (this.operation && this.operation[0]) {\n        this.chart.data.datasets[0].data.map(item => {\n          return this.operation[0](item);\n        });\n\n        if (this.refpointindex) {\n          //do conversion on [1] too\n          this.chart.data.datasets[1].data.map(item => {\n            return this.operation[0](item);\n          });\n        }\n      }\n\n      if (this.chart.data.datasets.length > this.maxdata) {\n        this.chart.data.datasets.pop();\n      }\n\n      this.updatechart();\n    };\n  }\n\n  bind() {\n    super.bind();\n    this.type = 'line';\n    this.options.legend.display = false;\n    let dataset = [];\n    dataset.push({\n      data: [],\n      label: \"\",\n      backgroundColor: this.selectColor(0),\n      borderColor: this.selectColor(0),\n      borderWidth: 1,\n      pointRadius: 1,\n      fill: false\n    });\n    this.data = {\n      labels: Array.from(Array(this.refvalues), (_, x) => x + 1),\n      //returns [1,2,3,..,refvalues]\n      datasets: dataset\n    };\n    if (typeof this.colorindex === 'string') this.colorindex = parseInt(this.colorindex, 10); //initialize colors for each dataset\n\n    this.currentcolor = this.selectColor(this.colorindex, 65);\n    this.previouscolor = this.selectColor(this.colorindex, 65, 75);\n    this.previouscolor2 = this.selectColor(this.colorindex, 65, 95);\n    this.currentcolorb = this.selectColor(this.colorindex + 1, 65);\n    this.previouscolorb = this.selectColor(this.colorindex + 1, 65, 75);\n    this.previouscolorb2 = this.selectColor(this.colorindex + 1, 65, 95);\n    this.refpointindex = parseInt(this.refpointindex, 10);\n\n    if (this.refpointindex) {\n      this.options.refpointplugin = {\n        index: this.refpointindex - this.refindex\n      };\n    }\n  }\n\n  attached() {\n    if (this.refpointindex) {\n      _chart.default.pluginService.register({\n        id: 'custom_lines to ref point',\n        afterDraw: chart => {\n          if (chart.config.options.refpointplugin) {\n            const ctx = chart.canvas.getContext('2d');\n            ctx.save(); // draw line\n\n            let meta1 = chart.getDatasetMeta(0); //let meta2 = chart.getDatasetMeta(1);\n\n            if (meta1) {\n              ctx.beginPath();\n\n              try {\n                //expect that data[0] contains point data[1] lines\n                let x = meta1.data[0]._model.x;\n                let y = meta1.data[0]._model.y;\n                let value = chart.data.datasets[0].data[0];\n\n                if (isNaN(value)) {\n                  //value is object x, y\n                  ctx.moveTo(0, y);\n                  ctx.lineTo(x, y);\n                  ctx.lineTo(x, chart.height);\n                  ctx.lineWidth = 1;\n                  ctx.strokeStyle = '#ff9c9c';\n                  ctx.stroke();\n                  ctx.font = \"10px Arial\";\n                  if (value.y) ctx.fillText(value.y.toPrecision(4), x, y);\n                } else {\n                  //only y value is there, draw line\n                  ctx.moveTo(0, y);\n                  ctx.lineTo(chart.width, y);\n                  ctx.lineWidth = 1;\n                  ctx.strokeStyle = '#ff9c9c';\n                  ctx.stroke();\n                  ctx.font = \"10px Arial\";\n                  ctx.fillStyle = \"black\";\n                  ctx.fillText(value.toPrecision(4), x, y);\n                }\n              } catch (e) {//console.warn('error, meta1:',meta1);\n              }\n\n              ctx.restore();\n            }\n          }\n        }\n      });\n    }\n\n    super.attached();\n    if (this.refpointindex) console.log('chartjs fixed debug: chart:', this.chart);\n  }\n\n}, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"fromid\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"labels\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, \"refindex\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, \"refvalues\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, \"type\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, \"min\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, \"max\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, \"maxdata\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 3;\n  }\n}), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, \"colorindex\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 0;\n  }\n}), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, \"highlightindex\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, \"refpointindex\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);\nexports.ChartjsFixed = ChartjsFixed;\n//# sourceMappingURL=chartjs-fixed.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMtZml4ZWQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2Rpc3QvbmF0aXZlLW1vZHVsZXMvZWxlbWVudHMvY2hhcnRqcy1maXhlZC5qcz81OWEzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5DaGFydGpzRml4ZWQgPSB2b2lkIDA7XG5cbnZhciBfYXVyZWxpYVRlbXBsYXRpbmcgPSByZXF1aXJlKFwiYXVyZWxpYS10ZW1wbGF0aW5nXCIpO1xuXG52YXIgX2NoYXJ0anMgPSByZXF1aXJlKFwiLi9jaGFydGpzXCIpO1xuXG52YXIgX2xvZGFzaCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaFwiKSk7XG5cbnZhciBfY2hhcnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjaGFydC5qc1wiKSk7XG5cbnZhciBfZGVjLCBfY2xhc3MsIF9jbGFzczIsIF9kZXNjcmlwdG9yLCBfZGVzY3JpcHRvcjIsIF9kZXNjcmlwdG9yMywgX2Rlc2NyaXB0b3I0LCBfZGVzY3JpcHRvcjUsIF9kZXNjcmlwdG9yNiwgX2Rlc2NyaXB0b3I3LCBfZGVzY3JpcHRvcjgsIF9kZXNjcmlwdG9yOSwgX2Rlc2NyaXB0b3IxMCwgX2Rlc2NyaXB0b3IxMTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvciwgY29udGV4dCkgeyBpZiAoIWRlc2NyaXB0b3IpIHJldHVybjsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHsgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLCBjb25maWd1cmFibGU6IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlLCB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSwgdmFsdWU6IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIgPyBkZXNjcmlwdG9yLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDAgfSk7IH1cblxuZnVuY3Rpb24gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5LCBkZWNvcmF0b3JzLCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7IHZhciBkZXNjID0ge307IE9iamVjdC5rZXlzKGRlc2NyaXB0b3IpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBkZXNjW2tleV0gPSBkZXNjcmlwdG9yW2tleV07IH0pOyBkZXNjLmVudW1lcmFibGUgPSAhIWRlc2MuZW51bWVyYWJsZTsgZGVzYy5jb25maWd1cmFibGUgPSAhIWRlc2MuY29uZmlndXJhYmxlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjIHx8IGRlc2MuaW5pdGlhbGl6ZXIpIHsgZGVzYy53cml0YWJsZSA9IHRydWU7IH0gZGVzYyA9IGRlY29yYXRvcnMuc2xpY2UoKS5yZXZlcnNlKCkucmVkdWNlKGZ1bmN0aW9uIChkZXNjLCBkZWNvcmF0b3IpIHsgcmV0dXJuIGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5LCBkZXNjKSB8fCBkZXNjOyB9LCBkZXNjKTsgaWYgKGNvbnRleHQgJiYgZGVzYy5pbml0aWFsaXplciAhPT0gdm9pZCAwKSB7IGRlc2MudmFsdWUgPSBkZXNjLmluaXRpYWxpemVyID8gZGVzYy5pbml0aWFsaXplci5jYWxsKGNvbnRleHQpIDogdm9pZCAwOyBkZXNjLmluaXRpYWxpemVyID0gdW5kZWZpbmVkOyB9IGlmIChkZXNjLmluaXRpYWxpemVyID09PSB2b2lkIDApIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2MpOyBkZXNjID0gbnVsbDsgfSByZXR1cm4gZGVzYzsgfVxuXG5mdW5jdGlvbiBfaW5pdGlhbGl6ZXJXYXJuaW5nSGVscGVyKGRlc2NyaXB0b3IsIGNvbnRleHQpIHsgdGhyb3cgbmV3IEVycm9yKCdEZWNvcmF0aW5nIGNsYXNzIHByb3BlcnR5IGZhaWxlZC4gUGxlYXNlIGVuc3VyZSB0aGF0ICcgKyAncHJvcG9zYWwtY2xhc3MtcHJvcGVydGllcyBpcyBlbmFibGVkIGFuZCBydW5zIGFmdGVyIHRoZSBkZWNvcmF0b3JzIHRyYW5zZm9ybS4nKTsgfVxuXG4vKipcbiAqIHNob3dzIGZpeGVkIGN1cnZlIGF0IHRpbWUgLVxuICogb24gWCBpcyAwLDEsMiwzLDQsNSw2LDcsOCw5XG4gKiBvbiBZIGlzIHZhbHVlcyBmcm9tIEZNVSB2YXJpYWJsZXMgZnJvbSByZWZpbmRleCB0byByZWZ2YWx1ZXNcbiAqL1xubGV0IENoYXJ0anNGaXhlZCA9IChfZGVjID0gKDAsIF9hdXJlbGlhVGVtcGxhdGluZy51c2VWaWV3KSgnLi9jaGFydGpzLmh0bWwnKSwgX2RlYyhfY2xhc3MgPSAoX2NsYXNzMiA9IGNsYXNzIENoYXJ0anNGaXhlZCBleHRlbmRzIF9jaGFydGpzLkNoYXJ0anMge1xuICAvL0RPTSBpZCBvZiBGTVUgY29tcG9uZW50IHRvIGxpc3RlbiBmbXUtZGF0YSBldmVudFxuICAvL2xhYmVscyBvZiBkYXRhc2V0c1xuICAvL3ZhcmlhYmxlIGluZGV4IGluIGZtdSBkYXRhXG4gIC8vaG93IG1hbnkgdmFyaWFibGVzIHRvIHNob3cgZnJvbSBmbXUgZGF0YVxuICAvL3R5cGUgb2YgY2hhcnQgLSBpcyBvdmVyd3JpdHRlbiB0byAnbGluZSdcbiAgLy9pZiBkZWZpbmVkIGNoYXJ0anMgeSBheGlzIGZyb20gbWluXG4gIC8vaWYgZGVmaW5lZCBjaGFydGpzIHkgYXhpcyB0byBtYXhcbiAgLy9ob3dtYW55IGRhdGFzZXRzIHRvIHJlbWVtYmVyXG4gIC8vZnJvbSB3aGljIGNvbG9yaW5kZXggdG8gc3RhcnQsIDAgYmx1ZSwgMSByZWQsIDIgZ3JlZW4sLi4uXG4gIC8vZXh0cmEgZGF0YXNldCB3aXRoIG9ubHkgb25lIHBvaW50IGlzIGRyYXduXG4gIC8vQGJpbmRhYmxlIGNhY2hlc2l6ZTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwiZnJvbWlkXCIsIF9kZXNjcmlwdG9yLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwibGFiZWxzXCIsIF9kZXNjcmlwdG9yMiwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZmluZGV4XCIsIF9kZXNjcmlwdG9yMywgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZnZhbHVlc1wiLCBfZGVzY3JpcHRvcjQsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJ0eXBlXCIsIF9kZXNjcmlwdG9yNSwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1pblwiLCBfZGVzY3JpcHRvcjYsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhcIiwgX2Rlc2NyaXB0b3I3LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4ZGF0YVwiLCBfZGVzY3JpcHRvcjgsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2xvcmluZGV4XCIsIF9kZXNjcmlwdG9yOSwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhpZ2hsaWdodGluZGV4XCIsIF9kZXNjcmlwdG9yMTAsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWZwb2ludGluZGV4XCIsIF9kZXNjcmlwdG9yMTEsIHRoaXMpO1xuXG4gICAgdGhpcy5jdXJyZW50Y29sb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5wcmV2aW91c2NvbG9yID0gdm9pZCAwO1xuICAgIHRoaXMucHJldmlvdXNjb2xvcjIgPSB2b2lkIDA7XG4gICAgdGhpcy5jdXJyZW50Y29sb3JiID0gdm9pZCAwO1xuICAgIHRoaXMucHJldmlvdXNjb2xvcmIgPSB2b2lkIDA7XG4gICAgdGhpcy5wcmV2aW91c2NvbG9yYjIgPSB2b2lkIDA7XG4gICAgdGhpcy5jdXJyZW50ZGF0YXNldCA9IDA7XG5cbiAgICB0aGlzLmhhbmRsZVZhbHVlQ2hhbmdlID0gZSA9PiB7XG4gICAgICAvL2xldCBqID0gdGhpcy5jdXJyZW50ZGF0YXNldDtcbiAgICAgIC8vYWxsIHZhbHVlcyBmcm9tIHJlZmluZGV4IHRvIG9uZSBkYXRhc2V0IC0gYXMgb25lIGN1cnZlXG4gICAgICAvL2lmICghdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2pdKSB7XG4gICAgICAvL2RvIGluaXRpYWxpemUgZGF0YXNldCBmaXJzdFxuICAgICAgbGV0IG5ld2RhdGFzZXQgPSB7XG4gICAgICAgIGRhdGE6IGUuZGV0YWlsLmRhdGEuc2xpY2UodGhpcy5yZWZpbmRleCwgdGhpcy5yZWZpbmRleCArIHRoaXMucmVmdmFsdWVzKSxcbiAgICAgICAgbGFiZWw6IFwiXCIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5jdXJyZW50Y29sb3IsXG4gICAgICAgIGJvcmRlckNvbG9yOiB0aGlzLmN1cnJlbnRjb2xvcixcbiAgICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICAgIHBvaW50UmFkaXVzOiAxLFxuICAgICAgICBmaWxsOiBmYWxzZVxuICAgICAgfTsgLy9pbmRleCB0byBibHVyZSBjb2xvclxuXG4gICAgICBsZXQgY29sb3JpbmRleCA9IDE7IC8vZGVjaWRlIHdoZXRoZXIgdG8gYWRkIHBvaW50XG5cbiAgICAgIGlmICh0aGlzLnJlZnBvaW50aW5kZXgpIHtcbiAgICAgICAgbGV0IG5ld3BvaW50ZGF0YXNldCA9IHtcbiAgICAgICAgICBkYXRhOiBbZS5kZXRhaWwuZGF0YVt0aGlzLnJlZnBvaW50aW5kZXhdXSxcbiAgICAgICAgICBsYWJlbDogXCJcIixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuY3VycmVudGNvbG9yLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiB0aGlzLmN1cnJlbnRjb2xvcixcbiAgICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgICBwb2ludFJhZGl1czogMCxcbiAgICAgICAgICBmaWxsOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbMF0gPSBuZXdkYXRhc2V0O1xuICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMudW5zaGlmdChuZXdwb2ludGRhdGFzZXQpOyAvL2JsdXIgY29sb3IgZnJvbSBpbmRlIDIsIFswXSBpcyBwb2ludCBbMV0gaXMgZGF0YXNldFxuXG4gICAgICAgIGNvbG9yaW5kZXggPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLnVuc2hpZnQobmV3ZGF0YXNldCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbY29sb3JpbmRleF0pIHtcbiAgICAgICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2NvbG9yaW5kZXhdLmJhY2tncm91bmRDb2xvciA9IHRoaXMucHJldmlvdXNjb2xvcjtcbiAgICAgICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2NvbG9yaW5kZXhdLmJvcmRlckNvbG9yID0gdGhpcy5wcmV2aW91c2NvbG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2NvbG9yaW5kZXggKyAxXSkge1xuICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbY29sb3JpbmRleCArIDFdLmJhY2tncm91bmRDb2xvciA9IHRoaXMucHJldmlvdXNjb2xvcjI7XG4gICAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tjb2xvcmluZGV4ICsgMV0uYm9yZGVyQ29sb3IgPSB0aGlzLnByZXZpb3VzY29sb3IyO1xuICAgICAgfSAvL2RvIGFwcGx5IG9wZXJhdGlvbiBvbiBlYWNoIGVsZW1lbnQgb2YgYXJyYXlcblxuXG4gICAgICBpZiAodGhpcy5vcGVyYXRpb24gJiYgdGhpcy5vcGVyYXRpb25bMF0pIHtcbiAgICAgICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGEubWFwKGl0ZW0gPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9wZXJhdGlvblswXShpdGVtKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMucmVmcG9pbnRpbmRleCkge1xuICAgICAgICAgIC8vZG8gY29udmVyc2lvbiBvbiBbMV0gdG9vXG4gICAgICAgICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzWzFdLmRhdGEubWFwKGl0ZW0gPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0aW9uWzBdKGl0ZW0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoID4gdGhpcy5tYXhkYXRhKSB7XG4gICAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVjaGFydCgpO1xuICAgIH07XG4gIH1cblxuICBiaW5kKCkge1xuICAgIHN1cGVyLmJpbmQoKTtcbiAgICB0aGlzLnR5cGUgPSAnbGluZSc7XG4gICAgdGhpcy5vcHRpb25zLmxlZ2VuZC5kaXNwbGF5ID0gZmFsc2U7XG4gICAgbGV0IGRhdGFzZXQgPSBbXTtcbiAgICBkYXRhc2V0LnB1c2goe1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbDogXCJcIixcbiAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5zZWxlY3RDb2xvcigwKSxcbiAgICAgIGJvcmRlckNvbG9yOiB0aGlzLnNlbGVjdENvbG9yKDApLFxuICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICBwb2ludFJhZGl1czogMSxcbiAgICAgIGZpbGw6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5kYXRhID0ge1xuICAgICAgbGFiZWxzOiBBcnJheS5mcm9tKEFycmF5KHRoaXMucmVmdmFsdWVzKSwgKF8sIHgpID0+IHggKyAxKSxcbiAgICAgIC8vcmV0dXJucyBbMSwyLDMsLi4scmVmdmFsdWVzXVxuICAgICAgZGF0YXNldHM6IGRhdGFzZXRcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgdGhpcy5jb2xvcmluZGV4ID09PSAnc3RyaW5nJykgdGhpcy5jb2xvcmluZGV4ID0gcGFyc2VJbnQodGhpcy5jb2xvcmluZGV4LCAxMCk7IC8vaW5pdGlhbGl6ZSBjb2xvcnMgZm9yIGVhY2ggZGF0YXNldFxuXG4gICAgdGhpcy5jdXJyZW50Y29sb3IgPSB0aGlzLnNlbGVjdENvbG9yKHRoaXMuY29sb3JpbmRleCwgNjUpO1xuICAgIHRoaXMucHJldmlvdXNjb2xvciA9IHRoaXMuc2VsZWN0Q29sb3IodGhpcy5jb2xvcmluZGV4LCA2NSwgNzUpO1xuICAgIHRoaXMucHJldmlvdXNjb2xvcjIgPSB0aGlzLnNlbGVjdENvbG9yKHRoaXMuY29sb3JpbmRleCwgNjUsIDk1KTtcbiAgICB0aGlzLmN1cnJlbnRjb2xvcmIgPSB0aGlzLnNlbGVjdENvbG9yKHRoaXMuY29sb3JpbmRleCArIDEsIDY1KTtcbiAgICB0aGlzLnByZXZpb3VzY29sb3JiID0gdGhpcy5zZWxlY3RDb2xvcih0aGlzLmNvbG9yaW5kZXggKyAxLCA2NSwgNzUpO1xuICAgIHRoaXMucHJldmlvdXNjb2xvcmIyID0gdGhpcy5zZWxlY3RDb2xvcih0aGlzLmNvbG9yaW5kZXggKyAxLCA2NSwgOTUpO1xuICAgIHRoaXMucmVmcG9pbnRpbmRleCA9IHBhcnNlSW50KHRoaXMucmVmcG9pbnRpbmRleCwgMTApO1xuXG4gICAgaWYgKHRoaXMucmVmcG9pbnRpbmRleCkge1xuICAgICAgdGhpcy5vcHRpb25zLnJlZnBvaW50cGx1Z2luID0ge1xuICAgICAgICBpbmRleDogdGhpcy5yZWZwb2ludGluZGV4IC0gdGhpcy5yZWZpbmRleFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBhdHRhY2hlZCgpIHtcbiAgICBpZiAodGhpcy5yZWZwb2ludGluZGV4KSB7XG4gICAgICBfY2hhcnQuZGVmYXVsdC5wbHVnaW5TZXJ2aWNlLnJlZ2lzdGVyKHtcbiAgICAgICAgaWQ6ICdjdXN0b21fbGluZXMgdG8gcmVmIHBvaW50JyxcbiAgICAgICAgYWZ0ZXJEcmF3OiBjaGFydCA9PiB7XG4gICAgICAgICAgaWYgKGNoYXJ0LmNvbmZpZy5vcHRpb25zLnJlZnBvaW50cGx1Z2luKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBjaGFydC5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7IC8vIGRyYXcgbGluZVxuXG4gICAgICAgICAgICBsZXQgbWV0YTEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTsgLy9sZXQgbWV0YTIgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgxKTtcblxuICAgICAgICAgICAgaWYgKG1ldGExKSB7XG4gICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vZXhwZWN0IHRoYXQgZGF0YVswXSBjb250YWlucyBwb2ludCBkYXRhWzFdIGxpbmVzXG4gICAgICAgICAgICAgICAgbGV0IHggPSBtZXRhMS5kYXRhWzBdLl9tb2RlbC54O1xuICAgICAgICAgICAgICAgIGxldCB5ID0gbWV0YTEuZGF0YVswXS5fbW9kZWwueTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBjaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGFbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAvL3ZhbHVlIGlzIG9iamVjdCB4LCB5XG4gICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKDAsIHkpO1xuICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgY2hhcnQuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyNmZjljOWMnO1xuICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgY3R4LmZvbnQgPSBcIjEwcHggQXJpYWxcIjtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS55KSBjdHguZmlsbFRleHQodmFsdWUueS50b1ByZWNpc2lvbig0KSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vb25seSB5IHZhbHVlIGlzIHRoZXJlLCBkcmF3IGxpbmVcbiAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oMCwgeSk7XG4gICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGNoYXJ0LndpZHRoLCB5KTtcbiAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyNmZjljOWMnO1xuICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgY3R4LmZvbnQgPSBcIjEwcHggQXJpYWxcIjtcbiAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQodmFsdWUudG9QcmVjaXNpb24oNCksIHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgey8vY29uc29sZS53YXJuKCdlcnJvciwgbWV0YTE6JyxtZXRhMSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3VwZXIuYXR0YWNoZWQoKTtcbiAgICBpZiAodGhpcy5yZWZwb2ludGluZGV4KSBjb25zb2xlLmxvZygnY2hhcnRqcyBmaXhlZCBkZWJ1ZzogY2hhcnQ6JywgdGhpcy5jaGFydCk7XG4gIH1cblxufSwgKF9kZXNjcmlwdG9yID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJmcm9taWRcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjIgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcImxhYmVsc1wiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMyA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwicmVmaW5kZXhcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjQgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcInJlZnZhbHVlc1wiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yNSA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwidHlwZVwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yNiA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwibWluXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I3ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJtYXhcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjggPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcIm1heGRhdGFcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMztcbiAgfVxufSksIF9kZXNjcmlwdG9yOSA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwiY29sb3JpbmRleFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAwO1xuICB9XG59KSwgX2Rlc2NyaXB0b3IxMCA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwiaGlnaGxpZ2h0aW5kZXhcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjExID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJyZWZwb2ludGluZGV4XCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSksIF9jbGFzczIpKSB8fCBfY2xhc3MpO1xuZXhwb3J0cy5DaGFydGpzRml4ZWQgPSBDaGFydGpzRml4ZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFydGpzLWZpeGVkLmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-fixed\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-fixed-xy":
/*!************************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-fixed-xy.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.ChartjsFixedXy = void 0;\n\nvar _aureliaTemplating = __webpack_require__(/*! aurelia-templating */ \"hij8\");\n\nvar _chartjsFixed = __webpack_require__(/*! ./chartjs-fixed */ \"aurelia-bodylight-plugin/elements/chartjs-fixed\");\n\nvar _chartjs = __webpack_require__(/*! ./chartjs */ \"aurelia-bodylight-plugin/elements/chartjs\");\n\nvar _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16;\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\n/**\n * shows fixed curve at time -\n * on X isvalues from FMU variables from xrefindex to xrefvalues\n * on Y is values from FMU variables from refindex to refvalues\n * convertors for x and y axis separated by ;\n * refindex, refvalues for y values\n * refindex2, refvalues2 for second curve in y values;\n * xrefindex,xrefvalues for x values\n * refpointindex\n */\nlet ChartjsFixedXy = (_dec = (0, _aureliaTemplating.useView)('./chartjs.html'), _dec(_class = (_class2 = class ChartjsFixedXy extends _chartjsFixed.ChartjsFixed {\n  //@bindable cachesize;\n  constructor() {\n    super();\n\n    _initializerDefineProperty(this, \"fromid\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"labels\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"refindex\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"refvalues\", _descriptor4, this);\n\n    _initializerDefineProperty(this, \"refindex2\", _descriptor5, this);\n\n    _initializerDefineProperty(this, \"refvalues2\", _descriptor6, this);\n\n    _initializerDefineProperty(this, \"type\", _descriptor7, this);\n\n    _initializerDefineProperty(this, \"min\", _descriptor8, this);\n\n    _initializerDefineProperty(this, \"max\", _descriptor9, this);\n\n    _initializerDefineProperty(this, \"maxdata\", _descriptor10, this);\n\n    _initializerDefineProperty(this, \"xrefindex\", _descriptor11, this);\n\n    _initializerDefineProperty(this, \"xrefvalues\", _descriptor12, this);\n\n    _initializerDefineProperty(this, \"xtofixed\", _descriptor13, this);\n\n    _initializerDefineProperty(this, \"refpointindex\", _descriptor14, this);\n\n    _initializerDefineProperty(this, \"xrefpointindex\", _descriptor15, this);\n\n    _initializerDefineProperty(this, \"showline\", _descriptor16, this);\n\n    this.currentdataset = 0;\n\n    this.handleValueChange = e => {\n      //let j = this.currentdataset;\n      //all values from refindex to one dataset - as one curve\n      let ydata = e.detail.data.slice(this.refindex, this.refindex + this.refvalues);\n      let y2data = [];\n      let xdata = e.detail.data.slice(this.xrefindex, this.xrefindex + this.xrefvalues);\n      let xpoint = 0;\n      let ypoint = 0;\n      let y2point = 0; //point to highlight\n\n      if (this.refpointindex) {\n        xpoint = e.detail.data[this.xrefpointindex];\n        ypoint = e.detail.data[this.refpointindex];\n      } //convertors\n\n\n      if (this.operation && this.operation[0] && this.operation[1]) {\n        xdata = xdata.map(x => this.operation[0](x));\n        ydata = ydata.map(y => this.operation[1](y));\n\n        if (this.refpointindex) {\n          xpoint = this.operation[0](xpoint);\n          ypoint = this.operation[1](ypoint);\n        }\n      }\n\n      let data = [];\n\n      for (let i = 0; i < ydata.length; i++) {\n        data.push({\n          x: xdata[i],\n          y: ydata[i]\n        });\n      }\n\n      let data2 = [{\n        x: xpoint,\n        y: ypoint\n      }]; //set labels to x axis\n\n      if (this.xtofixed >= 0) {\n        let labeldata = xdata.map(x => x.toFixed(this.xtofixed));\n        this.chart.data.labels = labeldata; //console.log('')\n      } //set data xy to chart struct\n      //do initialize dataset first\n\n\n      let newdataset = {\n        data: data,\n        label: \"\",\n        backgroundColor: this.currentcolor,\n        borderColor: this.currentcolor,\n        borderWidth: 1,\n        pointRadius: 1,\n        fill: false,\n        showLine: this.showline\n      };\n      let colorindex = 1;\n\n      if (this.refpointindex) {\n        let newpointdataset = {\n          data: data2,\n          label: \"\",\n          backgroundColor: this.currentcolor,\n          borderColor: this.currentcolor,\n          borderWidth: 1,\n          pointRadius: 2,\n          fill: false\n        };\n        this.chart.data.datasets[0] = newdataset;\n        this.chart.data.datasets.unshift(newpointdataset);\n      } else {\n        this.chart.data.datasets.unshift(newdataset);\n      }\n\n      if (this.chart.data.datasets[colorindex]) {\n        this.chart.data.datasets[colorindex].backgroundColor = this.previouscolor;\n        this.chart.data.datasets[colorindex].borderColor = this.previouscolor;\n      }\n\n      if (this.chart.data.datasets[colorindex + 1]) {\n        this.chart.data.datasets[colorindex + 1].backgroundColor = this.previouscolor2;\n        this.chart.data.datasets[colorindex + 1].borderColor = this.previouscolor2;\n      }\n\n      if (this.chart.data.datasets.length > this.maxdata) {\n        this.chart.data.datasets.pop();\n      }\n\n      if (this.refindex2) {\n        y2data = e.detail.data.slice(this.refindex2, this.refindex2 + this.refvalues2); //if (this.refpointindex2) y2point = e.detail.data[this.ref2pointindex];\n\n        if (this.operation) {\n          y2data = y2data.map(y => this.operation[1](y)); //if (this.refpointindex2) y2point = this.operation[1](y2point);\n        } //operation[1] or operation[2]?\n\n\n        let datab = [];\n\n        for (let i = 0; i < y2data.length; i++) {\n          datab.push({\n            x: xdata[i],\n            y: y2data[i]\n          });\n        }\n\n        let datab2 = [{\n          x: xpoint,\n          y: y2point\n        }];\n        let datasetb = {\n          data: datab,\n          label: \"\",\n          backgroundColor: this.currentcolorb,\n          borderColor: this.currentcolorb,\n          borderWidth: 1,\n          pointRadius: 1,\n          fill: false,\n          showLine: this.showline\n        };\n        this.chart.data.datasets.splice(this.refpointindex ? 2 : 1, 0, datasetb);\n\n        if (this.chart.data.datasets[colorindex + 3]) {\n          this.chart.data.datasets[colorindex + 3].backgroundColor = this.previouscolorb2;\n          this.chart.data.datasets[colorindex + 3].borderColor = this.previouscolorb2;\n        }\n\n        if (this.chart.data.datasets.length > this.maxdata) this.chart.data.datasets.pop();\n      }\n\n      this.updatechart();\n    };\n  }\n\n  bind() {\n    super.bind();\n    this.type = 'scatter';\n    this.data.labels = [];\n    this.xrefindex = parseInt(this.xrefindex, 10);\n    if (typeof this.maxdata === 'string') this.maxdata = parseInt(this.maxdata);\n    if (!this.xrefindex) console.warn('xrefindex is not specified');\n    this.xrefvalues = parseInt(this.xrefvalues, 10);\n    if (this.xrefvalues !== this.refvalues) console.warn('the value of \"xrefvalues\" must be equal to \"refvalues\"');\n    this.xrefpointindex = parseInt(this.xrefpointindex, 10);\n\n    if (typeof this.showline === 'string') {\n      this.showline = this.showline === 'true';\n    }\n\n    if (this.refindex2) {\n      this.refindex2 = (0, _chartjs.myParseInt)(this.refindex2, 10);\n      if (this.refvalues2) this.refvalues2 = parseInt(this.refvalues2, 10);else {\n        console.warn('chartjs-fixed-xy refvalues2 not defined');\n        this.refindex2 = null;\n      }\n    }\n  }\n\n  attached() {\n    super.attached();\n  }\n\n}, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"fromid\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"labels\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, \"refindex\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, \"refvalues\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, \"refindex2\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, \"refvalues2\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, \"type\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, \"min\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, \"max\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, \"maxdata\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 8;\n  }\n}), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, \"xrefindex\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, \"xrefvalues\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor13 = _applyDecoratedDescriptor(_class2.prototype, \"xtofixed\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 0;\n  }\n}), _descriptor14 = _applyDecoratedDescriptor(_class2.prototype, \"refpointindex\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor15 = _applyDecoratedDescriptor(_class2.prototype, \"xrefpointindex\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor16 = _applyDecoratedDescriptor(_class2.prototype, \"showline\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return true;\n  }\n})), _class2)) || _class);\nexports.ChartjsFixedXy = ChartjsFixedXy;\n//# sourceMappingURL=chartjs-fixed-xy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMtZml4ZWQteHkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2Rpc3QvbmF0aXZlLW1vZHVsZXMvZWxlbWVudHMvY2hhcnRqcy1maXhlZC14eS5qcz9mZGZkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5DaGFydGpzRml4ZWRYeSA9IHZvaWQgMDtcblxudmFyIF9hdXJlbGlhVGVtcGxhdGluZyA9IHJlcXVpcmUoXCJhdXJlbGlhLXRlbXBsYXRpbmdcIik7XG5cbnZhciBfY2hhcnRqc0ZpeGVkID0gcmVxdWlyZShcIi4vY2hhcnRqcy1maXhlZFwiKTtcblxudmFyIF9jaGFydGpzID0gcmVxdWlyZShcIi4vY2hhcnRqc1wiKTtcblxudmFyIF9kZWMsIF9jbGFzcywgX2NsYXNzMiwgX2Rlc2NyaXB0b3IsIF9kZXNjcmlwdG9yMiwgX2Rlc2NyaXB0b3IzLCBfZGVzY3JpcHRvcjQsIF9kZXNjcmlwdG9yNSwgX2Rlc2NyaXB0b3I2LCBfZGVzY3JpcHRvcjcsIF9kZXNjcmlwdG9yOCwgX2Rlc2NyaXB0b3I5LCBfZGVzY3JpcHRvcjEwLCBfZGVzY3JpcHRvcjExLCBfZGVzY3JpcHRvcjEyLCBfZGVzY3JpcHRvcjEzLCBfZGVzY3JpcHRvcjE0LCBfZGVzY3JpcHRvcjE1LCBfZGVzY3JpcHRvcjE2O1xuXG5mdW5jdGlvbiBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7IGlmICghZGVzY3JpcHRvcikgcmV0dXJuOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgeyBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsIHdyaXRhYmxlOiBkZXNjcmlwdG9yLndyaXRhYmxlLCB2YWx1ZTogZGVzY3JpcHRvci5pbml0aWFsaXplciA/IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMCB9KTsgfVxuXG5mdW5jdGlvbiBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHksIGRlY29yYXRvcnMsIGRlc2NyaXB0b3IsIGNvbnRleHQpIHsgdmFyIGRlc2MgPSB7fTsgT2JqZWN0LmtleXMoZGVzY3JpcHRvcikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGRlc2Nba2V5XSA9IGRlc2NyaXB0b3Jba2V5XTsgfSk7IGRlc2MuZW51bWVyYWJsZSA9ICEhZGVzYy5lbnVtZXJhYmxlOyBkZXNjLmNvbmZpZ3VyYWJsZSA9ICEhZGVzYy5jb25maWd1cmFibGU7IGlmICgndmFsdWUnIGluIGRlc2MgfHwgZGVzYy5pbml0aWFsaXplcikgeyBkZXNjLndyaXRhYmxlID0gdHJ1ZTsgfSBkZXNjID0gZGVjb3JhdG9ycy5zbGljZSgpLnJldmVyc2UoKS5yZWR1Y2UoZnVuY3Rpb24gKGRlc2MsIGRlY29yYXRvcikgeyByZXR1cm4gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHksIGRlc2MpIHx8IGRlc2M7IH0sIGRlc2MpOyBpZiAoY29udGV4dCAmJiBkZXNjLmluaXRpYWxpemVyICE9PSB2b2lkIDApIHsgZGVzYy52YWx1ZSA9IGRlc2MuaW5pdGlhbGl6ZXIgPyBkZXNjLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDA7IGRlc2MuaW5pdGlhbGl6ZXIgPSB1bmRlZmluZWQ7IH0gaWYgKGRlc2MuaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYyk7IGRlc2MgPSBudWxsOyB9IHJldHVybiBkZXNjOyB9XG5cbmZ1bmN0aW9uIF9pbml0aWFsaXplcldhcm5pbmdIZWxwZXIoZGVzY3JpcHRvciwgY29udGV4dCkgeyB0aHJvdyBuZXcgRXJyb3IoJ0RlY29yYXRpbmcgY2xhc3MgcHJvcGVydHkgZmFpbGVkLiBQbGVhc2UgZW5zdXJlIHRoYXQgJyArICdwcm9wb3NhbC1jbGFzcy1wcm9wZXJ0aWVzIGlzIGVuYWJsZWQgYW5kIHJ1bnMgYWZ0ZXIgdGhlIGRlY29yYXRvcnMgdHJhbnNmb3JtLicpOyB9XG5cbi8qKlxuICogc2hvd3MgZml4ZWQgY3VydmUgYXQgdGltZSAtXG4gKiBvbiBYIGlzdmFsdWVzIGZyb20gRk1VIHZhcmlhYmxlcyBmcm9tIHhyZWZpbmRleCB0byB4cmVmdmFsdWVzXG4gKiBvbiBZIGlzIHZhbHVlcyBmcm9tIEZNVSB2YXJpYWJsZXMgZnJvbSByZWZpbmRleCB0byByZWZ2YWx1ZXNcbiAqIGNvbnZlcnRvcnMgZm9yIHggYW5kIHkgYXhpcyBzZXBhcmF0ZWQgYnkgO1xuICogcmVmaW5kZXgsIHJlZnZhbHVlcyBmb3IgeSB2YWx1ZXNcbiAqIHJlZmluZGV4MiwgcmVmdmFsdWVzMiBmb3Igc2Vjb25kIGN1cnZlIGluIHkgdmFsdWVzO1xuICogeHJlZmluZGV4LHhyZWZ2YWx1ZXMgZm9yIHggdmFsdWVzXG4gKiByZWZwb2ludGluZGV4XG4gKi9cbmxldCBDaGFydGpzRml4ZWRYeSA9IChfZGVjID0gKDAsIF9hdXJlbGlhVGVtcGxhdGluZy51c2VWaWV3KSgnLi9jaGFydGpzLmh0bWwnKSwgX2RlYyhfY2xhc3MgPSAoX2NsYXNzMiA9IGNsYXNzIENoYXJ0anNGaXhlZFh5IGV4dGVuZHMgX2NoYXJ0anNGaXhlZC5DaGFydGpzRml4ZWQge1xuICAvL0BiaW5kYWJsZSBjYWNoZXNpemU7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZyb21pZFwiLCBfZGVzY3JpcHRvciwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxhYmVsc1wiLCBfZGVzY3JpcHRvcjIsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWZpbmRleFwiLCBfZGVzY3JpcHRvcjMsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWZ2YWx1ZXNcIiwgX2Rlc2NyaXB0b3I0LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVmaW5kZXgyXCIsIF9kZXNjcmlwdG9yNSwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZnZhbHVlczJcIiwgX2Rlc2NyaXB0b3I2LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBfZGVzY3JpcHRvcjcsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJtaW5cIiwgX2Rlc2NyaXB0b3I4LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4XCIsIF9kZXNjcmlwdG9yOSwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heGRhdGFcIiwgX2Rlc2NyaXB0b3IxMCwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInhyZWZpbmRleFwiLCBfZGVzY3JpcHRvcjExLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwieHJlZnZhbHVlc1wiLCBfZGVzY3JpcHRvcjEyLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwieHRvZml4ZWRcIiwgX2Rlc2NyaXB0b3IxMywgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZnBvaW50aW5kZXhcIiwgX2Rlc2NyaXB0b3IxNCwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInhyZWZwb2ludGluZGV4XCIsIF9kZXNjcmlwdG9yMTUsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJzaG93bGluZVwiLCBfZGVzY3JpcHRvcjE2LCB0aGlzKTtcblxuICAgIHRoaXMuY3VycmVudGRhdGFzZXQgPSAwO1xuXG4gICAgdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZSA9IGUgPT4ge1xuICAgICAgLy9sZXQgaiA9IHRoaXMuY3VycmVudGRhdGFzZXQ7XG4gICAgICAvL2FsbCB2YWx1ZXMgZnJvbSByZWZpbmRleCB0byBvbmUgZGF0YXNldCAtIGFzIG9uZSBjdXJ2ZVxuICAgICAgbGV0IHlkYXRhID0gZS5kZXRhaWwuZGF0YS5zbGljZSh0aGlzLnJlZmluZGV4LCB0aGlzLnJlZmluZGV4ICsgdGhpcy5yZWZ2YWx1ZXMpO1xuICAgICAgbGV0IHkyZGF0YSA9IFtdO1xuICAgICAgbGV0IHhkYXRhID0gZS5kZXRhaWwuZGF0YS5zbGljZSh0aGlzLnhyZWZpbmRleCwgdGhpcy54cmVmaW5kZXggKyB0aGlzLnhyZWZ2YWx1ZXMpO1xuICAgICAgbGV0IHhwb2ludCA9IDA7XG4gICAgICBsZXQgeXBvaW50ID0gMDtcbiAgICAgIGxldCB5MnBvaW50ID0gMDsgLy9wb2ludCB0byBoaWdobGlnaHRcblxuICAgICAgaWYgKHRoaXMucmVmcG9pbnRpbmRleCkge1xuICAgICAgICB4cG9pbnQgPSBlLmRldGFpbC5kYXRhW3RoaXMueHJlZnBvaW50aW5kZXhdO1xuICAgICAgICB5cG9pbnQgPSBlLmRldGFpbC5kYXRhW3RoaXMucmVmcG9pbnRpbmRleF07XG4gICAgICB9IC8vY29udmVydG9yc1xuXG5cbiAgICAgIGlmICh0aGlzLm9wZXJhdGlvbiAmJiB0aGlzLm9wZXJhdGlvblswXSAmJiB0aGlzLm9wZXJhdGlvblsxXSkge1xuICAgICAgICB4ZGF0YSA9IHhkYXRhLm1hcCh4ID0+IHRoaXMub3BlcmF0aW9uWzBdKHgpKTtcbiAgICAgICAgeWRhdGEgPSB5ZGF0YS5tYXAoeSA9PiB0aGlzLm9wZXJhdGlvblsxXSh5KSk7XG5cbiAgICAgICAgaWYgKHRoaXMucmVmcG9pbnRpbmRleCkge1xuICAgICAgICAgIHhwb2ludCA9IHRoaXMub3BlcmF0aW9uWzBdKHhwb2ludCk7XG4gICAgICAgICAgeXBvaW50ID0gdGhpcy5vcGVyYXRpb25bMV0oeXBvaW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgZGF0YSA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHlkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRhdGEucHVzaCh7XG4gICAgICAgICAgeDogeGRhdGFbaV0sXG4gICAgICAgICAgeTogeWRhdGFbaV1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBkYXRhMiA9IFt7XG4gICAgICAgIHg6IHhwb2ludCxcbiAgICAgICAgeTogeXBvaW50XG4gICAgICB9XTsgLy9zZXQgbGFiZWxzIHRvIHggYXhpc1xuXG4gICAgICBpZiAodGhpcy54dG9maXhlZCA+PSAwKSB7XG4gICAgICAgIGxldCBsYWJlbGRhdGEgPSB4ZGF0YS5tYXAoeCA9PiB4LnRvRml4ZWQodGhpcy54dG9maXhlZCkpO1xuICAgICAgICB0aGlzLmNoYXJ0LmRhdGEubGFiZWxzID0gbGFiZWxkYXRhOyAvL2NvbnNvbGUubG9nKCcnKVxuICAgICAgfSAvL3NldCBkYXRhIHh5IHRvIGNoYXJ0IHN0cnVjdFxuICAgICAgLy9kbyBpbml0aWFsaXplIGRhdGFzZXQgZmlyc3RcblxuXG4gICAgICBsZXQgbmV3ZGF0YXNldCA9IHtcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgbGFiZWw6IFwiXCIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5jdXJyZW50Y29sb3IsXG4gICAgICAgIGJvcmRlckNvbG9yOiB0aGlzLmN1cnJlbnRjb2xvcixcbiAgICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICAgIHBvaW50UmFkaXVzOiAxLFxuICAgICAgICBmaWxsOiBmYWxzZSxcbiAgICAgICAgc2hvd0xpbmU6IHRoaXMuc2hvd2xpbmVcbiAgICAgIH07XG4gICAgICBsZXQgY29sb3JpbmRleCA9IDE7XG5cbiAgICAgIGlmICh0aGlzLnJlZnBvaW50aW5kZXgpIHtcbiAgICAgICAgbGV0IG5ld3BvaW50ZGF0YXNldCA9IHtcbiAgICAgICAgICBkYXRhOiBkYXRhMixcbiAgICAgICAgICBsYWJlbDogXCJcIixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuY3VycmVudGNvbG9yLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiB0aGlzLmN1cnJlbnRjb2xvcixcbiAgICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgICBwb2ludFJhZGl1czogMixcbiAgICAgICAgICBmaWxsOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbMF0gPSBuZXdkYXRhc2V0O1xuICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMudW5zaGlmdChuZXdwb2ludGRhdGFzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLnVuc2hpZnQobmV3ZGF0YXNldCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbY29sb3JpbmRleF0pIHtcbiAgICAgICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2NvbG9yaW5kZXhdLmJhY2tncm91bmRDb2xvciA9IHRoaXMucHJldmlvdXNjb2xvcjtcbiAgICAgICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2NvbG9yaW5kZXhdLmJvcmRlckNvbG9yID0gdGhpcy5wcmV2aW91c2NvbG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2NvbG9yaW5kZXggKyAxXSkge1xuICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbY29sb3JpbmRleCArIDFdLmJhY2tncm91bmRDb2xvciA9IHRoaXMucHJldmlvdXNjb2xvcjI7XG4gICAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tjb2xvcmluZGV4ICsgMV0uYm9yZGVyQ29sb3IgPSB0aGlzLnByZXZpb3VzY29sb3IyO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aCA+IHRoaXMubWF4ZGF0YSkge1xuICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnJlZmluZGV4Mikge1xuICAgICAgICB5MmRhdGEgPSBlLmRldGFpbC5kYXRhLnNsaWNlKHRoaXMucmVmaW5kZXgyLCB0aGlzLnJlZmluZGV4MiArIHRoaXMucmVmdmFsdWVzMik7IC8vaWYgKHRoaXMucmVmcG9pbnRpbmRleDIpIHkycG9pbnQgPSBlLmRldGFpbC5kYXRhW3RoaXMucmVmMnBvaW50aW5kZXhdO1xuXG4gICAgICAgIGlmICh0aGlzLm9wZXJhdGlvbikge1xuICAgICAgICAgIHkyZGF0YSA9IHkyZGF0YS5tYXAoeSA9PiB0aGlzLm9wZXJhdGlvblsxXSh5KSk7IC8vaWYgKHRoaXMucmVmcG9pbnRpbmRleDIpIHkycG9pbnQgPSB0aGlzLm9wZXJhdGlvblsxXSh5MnBvaW50KTtcbiAgICAgICAgfSAvL29wZXJhdGlvblsxXSBvciBvcGVyYXRpb25bMl0/XG5cblxuICAgICAgICBsZXQgZGF0YWIgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHkyZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGRhdGFiLnB1c2goe1xuICAgICAgICAgICAgeDogeGRhdGFbaV0sXG4gICAgICAgICAgICB5OiB5MmRhdGFbaV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkYXRhYjIgPSBbe1xuICAgICAgICAgIHg6IHhwb2ludCxcbiAgICAgICAgICB5OiB5MnBvaW50XG4gICAgICAgIH1dO1xuICAgICAgICBsZXQgZGF0YXNldGIgPSB7XG4gICAgICAgICAgZGF0YTogZGF0YWIsXG4gICAgICAgICAgbGFiZWw6IFwiXCIsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLmN1cnJlbnRjb2xvcmIsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IHRoaXMuY3VycmVudGNvbG9yYixcbiAgICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgICBwb2ludFJhZGl1czogMSxcbiAgICAgICAgICBmaWxsOiBmYWxzZSxcbiAgICAgICAgICBzaG93TGluZTogdGhpcy5zaG93bGluZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMuc3BsaWNlKHRoaXMucmVmcG9pbnRpbmRleCA/IDIgOiAxLCAwLCBkYXRhc2V0Yik7XG5cbiAgICAgICAgaWYgKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tjb2xvcmluZGV4ICsgM10pIHtcbiAgICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbY29sb3JpbmRleCArIDNdLmJhY2tncm91bmRDb2xvciA9IHRoaXMucHJldmlvdXNjb2xvcmIyO1xuICAgICAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tjb2xvcmluZGV4ICsgM10uYm9yZGVyQ29sb3IgPSB0aGlzLnByZXZpb3VzY29sb3JiMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoID4gdGhpcy5tYXhkYXRhKSB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlY2hhcnQoKTtcbiAgICB9O1xuICB9XG5cbiAgYmluZCgpIHtcbiAgICBzdXBlci5iaW5kKCk7XG4gICAgdGhpcy50eXBlID0gJ3NjYXR0ZXInO1xuICAgIHRoaXMuZGF0YS5sYWJlbHMgPSBbXTtcbiAgICB0aGlzLnhyZWZpbmRleCA9IHBhcnNlSW50KHRoaXMueHJlZmluZGV4LCAxMCk7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm1heGRhdGEgPT09ICdzdHJpbmcnKSB0aGlzLm1heGRhdGEgPSBwYXJzZUludCh0aGlzLm1heGRhdGEpO1xuICAgIGlmICghdGhpcy54cmVmaW5kZXgpIGNvbnNvbGUud2FybigneHJlZmluZGV4IGlzIG5vdCBzcGVjaWZpZWQnKTtcbiAgICB0aGlzLnhyZWZ2YWx1ZXMgPSBwYXJzZUludCh0aGlzLnhyZWZ2YWx1ZXMsIDEwKTtcbiAgICBpZiAodGhpcy54cmVmdmFsdWVzICE9PSB0aGlzLnJlZnZhbHVlcykgY29uc29sZS53YXJuKCd0aGUgdmFsdWUgb2YgXCJ4cmVmdmFsdWVzXCIgbXVzdCBiZSBlcXVhbCB0byBcInJlZnZhbHVlc1wiJyk7XG4gICAgdGhpcy54cmVmcG9pbnRpbmRleCA9IHBhcnNlSW50KHRoaXMueHJlZnBvaW50aW5kZXgsIDEwKTtcblxuICAgIGlmICh0eXBlb2YgdGhpcy5zaG93bGluZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuc2hvd2xpbmUgPSB0aGlzLnNob3dsaW5lID09PSAndHJ1ZSc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVmaW5kZXgyKSB7XG4gICAgICB0aGlzLnJlZmluZGV4MiA9ICgwLCBfY2hhcnRqcy5teVBhcnNlSW50KSh0aGlzLnJlZmluZGV4MiwgMTApO1xuICAgICAgaWYgKHRoaXMucmVmdmFsdWVzMikgdGhpcy5yZWZ2YWx1ZXMyID0gcGFyc2VJbnQodGhpcy5yZWZ2YWx1ZXMyLCAxMCk7ZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybignY2hhcnRqcy1maXhlZC14eSByZWZ2YWx1ZXMyIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgIHRoaXMucmVmaW5kZXgyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhdHRhY2hlZCgpIHtcbiAgICBzdXBlci5hdHRhY2hlZCgpO1xuICB9XG5cbn0sIChfZGVzY3JpcHRvciA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwiZnJvbWlkXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3IyID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJsYWJlbHNcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjMgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcInJlZmluZGV4XCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I0ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJyZWZ2YWx1ZXNcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjUgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcInJlZmluZGV4MlwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yNiA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwicmVmdmFsdWVzMlwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yNyA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwidHlwZVwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yOCA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwibWluXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I5ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJtYXhcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjEwID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJtYXhkYXRhXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDg7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjExID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJ4cmVmaW5kZXhcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjEyID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJ4cmVmdmFsdWVzXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3IxMyA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwieHRvZml4ZWRcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufSksIF9kZXNjcmlwdG9yMTQgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcInJlZnBvaW50aW5kZXhcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjE1ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJ4cmVmcG9pbnRpbmRleFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMTYgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcInNob3dsaW5lXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0pKSwgX2NsYXNzMikpIHx8IF9jbGFzcyk7XG5leHBvcnRzLkNoYXJ0anNGaXhlZFh5ID0gQ2hhcnRqc0ZpeGVkWHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFydGpzLWZpeGVkLXh5LmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-fixed-xy\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-fixed-xy.html":
/*!**************************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-fixed-xy.html ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template></template>\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMtZml4ZWQteHkuaHRtbC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLWJvZHlsaWdodC1wbHVnaW4vZGlzdC9uYXRpdmUtbW9kdWxlcy9lbGVtZW50cy9jaGFydGpzLWZpeGVkLXh5Lmh0bWw/YTIyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiPHRlbXBsYXRlPjwvdGVtcGxhdGU+XFxuXCI7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-fixed-xy.html\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-fixed.html":
/*!***********************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-fixed.html ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template></template>\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMtZml4ZWQuaHRtbC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLWJvZHlsaWdodC1wbHVnaW4vZGlzdC9uYXRpdmUtbW9kdWxlcy9lbGVtZW50cy9jaGFydGpzLWZpeGVkLmh0bWw/NTc1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiPHRlbXBsYXRlPjwvdGVtcGxhdGU+XFxuXCI7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-fixed.html\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-stacked":
/*!***********************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-stacked.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.ChartjsStacked = void 0;\n\nvar _aureliaTemplating = __webpack_require__(/*! aurelia-templating */ \"hij8\");\n\nvar _chartjs = __webpack_require__(/*! ./chartjs */ \"aurelia-bodylight-plugin/elements/chartjs\");\n\nvar _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9;\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\n/**\n * shows stacked box -\n * on X is group stack 0 or stack 1\n * on Y is values from FMU variables from refindexes\n */\nlet ChartjsStacked = (_dec = (0, _aureliaTemplating.useView)('./chartjs.html'), _dec(_class = (_class2 = class ChartjsStacked extends _chartjs.Chartjs {\n  constructor() {\n    super(); //stacked box contains data, each box in different dataset, group is\n\n    _initializerDefineProperty(this, \"fromid\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"labels\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"refindex\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"refvalues\", _descriptor4, this);\n\n    _initializerDefineProperty(this, \"type\", _descriptor5, this);\n\n    _initializerDefineProperty(this, \"min\", _descriptor6, this);\n\n    _initializerDefineProperty(this, \"max\", _descriptor7, this);\n\n    _initializerDefineProperty(this, \"maxdata\", _descriptor8, this);\n\n    _initializerDefineProperty(this, \"stacks\", _descriptor9, this);\n\n    this.handleValueChange = e => {\n      for (let j = 0; j < this.refindices.length; j++) {\n        let mydata = e.detail.data[this.refindices[j]]; //do conversion if operation is defined\n\n        if (this.operation && this.operation[j]) mydata = this.operation[j](mydata);\n\n        if (!this.chart.data.datasets[j]) {\n          //do initialize dataset first\n          this.chart.data.datasets.push({\n            data: [mydata],\n            //data is array\n            label: this.chlabels[j],\n            backgroundColor: this.selectColor(j),\n            stack: this.stack[j]\n          });\n        } else {\n          this.chart.data.datasets[j].data[0] = mydata; //data is array 0 item\n        }\n      }\n\n      this.updatechart();\n    };\n  }\n\n  bind() {\n    super.bind();\n    this.type = \"bar\";\n    this.options.scales.xAxes = [{\n      stacked: true\n    }];\n    this.options.scales.yAxes = [{\n      stacked: true\n    }]; //reset labels\n\n    this.data.labels = [\"data\"]; //allows refindices to be defined in refindex separated by comma ,\n\n    if (Array.isArray(this.refindex)) {\n      this.refindices = this.refindex; //define stack array for groups, contains descriptive string for group\n    } else {\n      //or refindices will be refindex, refindex+1, ...\n      this.refindices = [];\n\n      for (let i = 0; i < this.refvalues; i++) this.refindices.push(this.refindex + i);\n    }\n\n    if (this.stacks) {\n      this.stack = this.stacks.split(',');\n    } else {\n      this.stack = new Array(this.refindices.length).fill('stack 0');\n    } //init dataset data and labels = 0\n\n\n    this.data.datasets = [];\n\n    for (let j = 0; j < this.refindices.length; j++) {\n      //do initialize dataset first\n      this.data.datasets.push({\n        data: [0],\n        //data is array\n        label: this.chlabels[j],\n        backgroundColor: this.selectColor(j),\n        stack: this.stack[j]\n      });\n    }\n  }\n\n  attached() {\n    super.attached();\n  }\n\n}, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"fromid\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"labels\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, \"refindex\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, \"refvalues\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, \"type\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, \"min\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, \"max\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, \"maxdata\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 3;\n  }\n}), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, \"stacks\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);\nexports.ChartjsStacked = ChartjsStacked;\n//# sourceMappingURL=chartjs-stacked.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMtc3RhY2tlZC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLWJvZHlsaWdodC1wbHVnaW4vZGlzdC9uYXRpdmUtbW9kdWxlcy9lbGVtZW50cy9jaGFydGpzLXN0YWNrZWQuanM/YzViMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQ2hhcnRqc1N0YWNrZWQgPSB2b2lkIDA7XG5cbnZhciBfYXVyZWxpYVRlbXBsYXRpbmcgPSByZXF1aXJlKFwiYXVyZWxpYS10ZW1wbGF0aW5nXCIpO1xuXG52YXIgX2NoYXJ0anMgPSByZXF1aXJlKFwiLi9jaGFydGpzXCIpO1xuXG52YXIgX2RlYywgX2NsYXNzLCBfY2xhc3MyLCBfZGVzY3JpcHRvciwgX2Rlc2NyaXB0b3IyLCBfZGVzY3JpcHRvcjMsIF9kZXNjcmlwdG9yNCwgX2Rlc2NyaXB0b3I1LCBfZGVzY3JpcHRvcjYsIF9kZXNjcmlwdG9yNywgX2Rlc2NyaXB0b3I4LCBfZGVzY3JpcHRvcjk7XG5cbmZ1bmN0aW9uIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2NyaXB0b3IsIGNvbnRleHQpIHsgaWYgKCFkZXNjcmlwdG9yKSByZXR1cm47IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCB7IGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSwgY29uZmlndXJhYmxlOiBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSwgd3JpdGFibGU6IGRlc2NyaXB0b3Iud3JpdGFibGUsIHZhbHVlOiBkZXNjcmlwdG9yLmluaXRpYWxpemVyID8gZGVzY3JpcHRvci5pbml0aWFsaXplci5jYWxsKGNvbnRleHQpIDogdm9pZCAwIH0pOyB9XG5cbmZ1bmN0aW9uIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVjb3JhdG9ycywgZGVzY3JpcHRvciwgY29udGV4dCkgeyB2YXIgZGVzYyA9IHt9OyBPYmplY3Qua2V5cyhkZXNjcmlwdG9yKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZGVzY1trZXldID0gZGVzY3JpcHRvcltrZXldOyB9KTsgZGVzYy5lbnVtZXJhYmxlID0gISFkZXNjLmVudW1lcmFibGU7IGRlc2MuY29uZmlndXJhYmxlID0gISFkZXNjLmNvbmZpZ3VyYWJsZTsgaWYgKCd2YWx1ZScgaW4gZGVzYyB8fCBkZXNjLmluaXRpYWxpemVyKSB7IGRlc2Mud3JpdGFibGUgPSB0cnVlOyB9IGRlc2MgPSBkZWNvcmF0b3JzLnNsaWNlKCkucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbiAoZGVzYywgZGVjb3JhdG9yKSB7IHJldHVybiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYykgfHwgZGVzYzsgfSwgZGVzYyk7IGlmIChjb250ZXh0ICYmIGRlc2MuaW5pdGlhbGl6ZXIgIT09IHZvaWQgMCkgeyBkZXNjLnZhbHVlID0gZGVzYy5pbml0aWFsaXplciA/IGRlc2MuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMDsgZGVzYy5pbml0aWFsaXplciA9IHVuZGVmaW5lZDsgfSBpZiAoZGVzYy5pbml0aWFsaXplciA9PT0gdm9pZCAwKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjKTsgZGVzYyA9IG51bGw7IH0gcmV0dXJuIGRlc2M7IH1cblxuZnVuY3Rpb24gX2luaXRpYWxpemVyV2FybmluZ0hlbHBlcihkZXNjcmlwdG9yLCBjb250ZXh0KSB7IHRocm93IG5ldyBFcnJvcignRGVjb3JhdGluZyBjbGFzcyBwcm9wZXJ0eSBmYWlsZWQuIFBsZWFzZSBlbnN1cmUgdGhhdCAnICsgJ3Byb3Bvc2FsLWNsYXNzLXByb3BlcnRpZXMgaXMgZW5hYmxlZCBhbmQgcnVucyBhZnRlciB0aGUgZGVjb3JhdG9ycyB0cmFuc2Zvcm0uJyk7IH1cblxuLyoqXG4gKiBzaG93cyBzdGFja2VkIGJveCAtXG4gKiBvbiBYIGlzIGdyb3VwIHN0YWNrIDAgb3Igc3RhY2sgMVxuICogb24gWSBpcyB2YWx1ZXMgZnJvbSBGTVUgdmFyaWFibGVzIGZyb20gcmVmaW5kZXhlc1xuICovXG5sZXQgQ2hhcnRqc1N0YWNrZWQgPSAoX2RlYyA9ICgwLCBfYXVyZWxpYVRlbXBsYXRpbmcudXNlVmlldykoJy4vY2hhcnRqcy5odG1sJyksIF9kZWMoX2NsYXNzID0gKF9jbGFzczIgPSBjbGFzcyBDaGFydGpzU3RhY2tlZCBleHRlbmRzIF9jaGFydGpzLkNoYXJ0anMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpOyAvL3N0YWNrZWQgYm94IGNvbnRhaW5zIGRhdGEsIGVhY2ggYm94IGluIGRpZmZlcmVudCBkYXRhc2V0LCBncm91cCBpc1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJmcm9taWRcIiwgX2Rlc2NyaXB0b3IsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJsYWJlbHNcIiwgX2Rlc2NyaXB0b3IyLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVmaW5kZXhcIiwgX2Rlc2NyaXB0b3IzLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVmdmFsdWVzXCIsIF9kZXNjcmlwdG9yNCwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgX2Rlc2NyaXB0b3I1LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwibWluXCIsIF9kZXNjcmlwdG9yNiwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heFwiLCBfZGVzY3JpcHRvcjcsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhkYXRhXCIsIF9kZXNjcmlwdG9yOCwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YWNrc1wiLCBfZGVzY3JpcHRvcjksIHRoaXMpO1xuXG4gICAgdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZSA9IGUgPT4ge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLnJlZmluZGljZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbGV0IG15ZGF0YSA9IGUuZGV0YWlsLmRhdGFbdGhpcy5yZWZpbmRpY2VzW2pdXTsgLy9kbyBjb252ZXJzaW9uIGlmIG9wZXJhdGlvbiBpcyBkZWZpbmVkXG5cbiAgICAgICAgaWYgKHRoaXMub3BlcmF0aW9uICYmIHRoaXMub3BlcmF0aW9uW2pdKSBteWRhdGEgPSB0aGlzLm9wZXJhdGlvbltqXShteWRhdGEpO1xuXG4gICAgICAgIGlmICghdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2pdKSB7XG4gICAgICAgICAgLy9kbyBpbml0aWFsaXplIGRhdGFzZXQgZmlyc3RcbiAgICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMucHVzaCh7XG4gICAgICAgICAgICBkYXRhOiBbbXlkYXRhXSxcbiAgICAgICAgICAgIC8vZGF0YSBpcyBhcnJheVxuICAgICAgICAgICAgbGFiZWw6IHRoaXMuY2hsYWJlbHNbal0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuc2VsZWN0Q29sb3IoaiksXG4gICAgICAgICAgICBzdGFjazogdGhpcy5zdGFja1tqXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tqXS5kYXRhWzBdID0gbXlkYXRhOyAvL2RhdGEgaXMgYXJyYXkgMCBpdGVtXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVjaGFydCgpO1xuICAgIH07XG4gIH1cblxuICBiaW5kKCkge1xuICAgIHN1cGVyLmJpbmQoKTtcbiAgICB0aGlzLnR5cGUgPSBcImJhclwiO1xuICAgIHRoaXMub3B0aW9ucy5zY2FsZXMueEF4ZXMgPSBbe1xuICAgICAgc3RhY2tlZDogdHJ1ZVxuICAgIH1dO1xuICAgIHRoaXMub3B0aW9ucy5zY2FsZXMueUF4ZXMgPSBbe1xuICAgICAgc3RhY2tlZDogdHJ1ZVxuICAgIH1dOyAvL3Jlc2V0IGxhYmVsc1xuXG4gICAgdGhpcy5kYXRhLmxhYmVscyA9IFtcImRhdGFcIl07IC8vYWxsb3dzIHJlZmluZGljZXMgdG8gYmUgZGVmaW5lZCBpbiByZWZpbmRleCBzZXBhcmF0ZWQgYnkgY29tbWEgLFxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5yZWZpbmRleCkpIHtcbiAgICAgIHRoaXMucmVmaW5kaWNlcyA9IHRoaXMucmVmaW5kZXg7IC8vZGVmaW5lIHN0YWNrIGFycmF5IGZvciBncm91cHMsIGNvbnRhaW5zIGRlc2NyaXB0aXZlIHN0cmluZyBmb3IgZ3JvdXBcbiAgICB9IGVsc2Uge1xuICAgICAgLy9vciByZWZpbmRpY2VzIHdpbGwgYmUgcmVmaW5kZXgsIHJlZmluZGV4KzEsIC4uLlxuICAgICAgdGhpcy5yZWZpbmRpY2VzID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yZWZ2YWx1ZXM7IGkrKykgdGhpcy5yZWZpbmRpY2VzLnB1c2godGhpcy5yZWZpbmRleCArIGkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YWNrcykge1xuICAgICAgdGhpcy5zdGFjayA9IHRoaXMuc3RhY2tzLnNwbGl0KCcsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhY2sgPSBuZXcgQXJyYXkodGhpcy5yZWZpbmRpY2VzLmxlbmd0aCkuZmlsbCgnc3RhY2sgMCcpO1xuICAgIH0gLy9pbml0IGRhdGFzZXQgZGF0YSBhbmQgbGFiZWxzID0gMFxuXG5cbiAgICB0aGlzLmRhdGEuZGF0YXNldHMgPSBbXTtcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5yZWZpbmRpY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAvL2RvIGluaXRpYWxpemUgZGF0YXNldCBmaXJzdFxuICAgICAgdGhpcy5kYXRhLmRhdGFzZXRzLnB1c2goe1xuICAgICAgICBkYXRhOiBbMF0sXG4gICAgICAgIC8vZGF0YSBpcyBhcnJheVxuICAgICAgICBsYWJlbDogdGhpcy5jaGxhYmVsc1tqXSxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLnNlbGVjdENvbG9yKGopLFxuICAgICAgICBzdGFjazogdGhpcy5zdGFja1tqXVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgYXR0YWNoZWQoKSB7XG4gICAgc3VwZXIuYXR0YWNoZWQoKTtcbiAgfVxuXG59LCAoX2Rlc2NyaXB0b3IgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcImZyb21pZFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMiA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwibGFiZWxzXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3IzID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJyZWZpbmRleFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yNCA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwicmVmdmFsdWVzXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I1ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJ0eXBlXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I2ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJtaW5cIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjcgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcIm1heFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yOCA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwibWF4ZGF0YVwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAzO1xuICB9XG59KSwgX2Rlc2NyaXB0b3I5ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJzdGFja3NcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pKSwgX2NsYXNzMikpIHx8IF9jbGFzcyk7XG5leHBvcnRzLkNoYXJ0anNTdGFja2VkID0gQ2hhcnRqc1N0YWNrZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFydGpzLXN0YWNrZWQuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-stacked\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-stacked.html":
/*!*************************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-stacked.html ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template></template>\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMtc3RhY2tlZC5odG1sLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F1cmVsaWEtYm9keWxpZ2h0LXBsdWdpbi9kaXN0L25hdGl2ZS1tb2R1bGVzL2VsZW1lbnRzL2NoYXJ0anMtc3RhY2tlZC5odG1sPzUyM2EiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIjx0ZW1wbGF0ZT48L3RlbXBsYXRlPlxcblwiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-stacked.html\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-time":
/*!********************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-time.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.ChartjsTime = void 0;\n\nvar _aureliaTemplating = __webpack_require__(/*! aurelia-templating */ \"hij8\");\n\nvar _chartjs = __webpack_require__(/*! ./chartjs */ \"aurelia-bodylight-plugin/elements/chartjs\");\n\nvar _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9;\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\n//import {PLATFORM} from 'aurelia-pal';\n//@customElement\n//@useView(PLATFORM.moduleName('./bdl-chartjs.html'))\nlet ChartjsTime = (_dec = (0, _aureliaTemplating.useView)('./chartjs.html'), _dec(_class = (_class2 = class ChartjsTime extends _chartjs.Chartjs {\n  // starting  index - if moooor indices, separate by comma\n  //number of values from refindex - only if one refindex is   defined\n  constructor() {\n    super(); //this.type = 'line';\n\n    _initializerDefineProperty(this, \"fromid\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"labels\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"refindex\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"refvalues\", _descriptor4, this);\n\n    _initializerDefineProperty(this, \"type\", _descriptor5, this);\n\n    _initializerDefineProperty(this, \"min\", _descriptor6, this);\n\n    _initializerDefineProperty(this, \"max\", _descriptor7, this);\n\n    _initializerDefineProperty(this, \"minichart\", _descriptor8, this);\n\n    _initializerDefineProperty(this, \"colorindex\", _descriptor9, this);\n\n    this.refindices = void 0;\n\n    this.handleValueChange = e => {\n      //e.detail do not reallocate - using same buffer, thus slicing to append to data array\n      //let datapoints =e.detail.data.slice(this.refindex, this.refendindex);\n      let j = 0;\n\n      function handleIndex(i) {\n        {\n          //adds data to datasets\n          //if convert operation is defined as array then convert\n          if (this.operation && this.operation[j]) this.chart.data.datasets[j].data.push(this.operation[j](e.detail.data[i])); //else push data directly\n          else this.chart.data.datasets[j].data.push(e.detail.data[i]);\n\n          if (this.chart.data.datasets[j].data.length > this.maxdata) {\n            //console.log('shifting dataset chartjs-time', this.chart.data.datasets[j].data);\n            this.chart.data.datasets[j].data.shift();\n          }\n\n          j++;\n        }\n      }\n\n      if (this.refindices) for (let i of this.refindices) handleIndex.call(this, i);else for (let i = this.refindex; i < this.refindex + this.refvalues; i++) handleIndex.call(this, i);\n      this.chart.data.labels.push(e.detail.time);\n\n      if (this.chart.data.labels.length > this.maxdata) {\n        this.chart.data.labels.shift();\n\n        if (this.sectionid) {\n          //shift sections\n          if (this.chart.config.options.section[0].index === 0) this.chart.config.options.section.shift(); //decrement all indices in sections\n\n          for (let i = 0; i < this.chart.config.options.section.length; i++) this.chart.config.options.section[i].index -= 1;\n        }\n      } //shift - remove first element if data is too big\n      //console.log('chartjs handlevaluechange() chart.data.datasets[0].data', this.chart.data.datasets[0].data);\n\n\n      this.updatechart();\n    };\n  }\n  /**\n   * sets all tim-series specific options for chartjs\n   */\n\n\n  bind() {\n    super.bind(); //done in super\n    //this.chlabels = this.labels.split(','); //labels for each dataset\n    //this.colors = [];\n\n    let datasets = [];\n    let mydata1 = this.initialdata.split(';');\n\n    for (let i = 0; i < this.refvalues + 1; i++) {\n      //mydata[0] == timelabels in x axis, mydata[1..n] ar in y axis\n      let mydata2 = mydata1[i] ? mydata1[i].split(',') : [];\n      this.mydata[i] = mydata2.map(x => {\n        return parseFloat(x);\n      }); //console.log('chartjstime mydata i',this.mydata[i]);\n    } //initialize colors for each dataset\n\n\n    for (let i = 0; i < this.refvalues; i++) {\n      //this.colors.push(this.selectColor(i));\n      datasets.push({\n        data: this.mydata[i + 1],\n        label: this.chlabels[i],\n        backgroundColor: this.selectColor(i + this.colorindex),\n        borderColor: this.selectColor(i + this.colorindex),\n        borderWidth: 1,\n        pointRadius: 1,\n        fill: false\n      }); //timelabels.push(i);\n    }\n\n    this.data = {\n      labels: this.mydata[0],\n      datasets: datasets\n    };\n    if (this.verticalline) this.type = 'LineWithLine';else this.type = 'line';\n  }\n\n  attached() {\n    super.attached();\n  }\n\n  detached() {\n    super.detached();\n  }\n\n  resetdata() {\n    //super.resetdata();\n    for (let j = 0; j < this.refvalues; j++) this.chart.data.datasets[j].data = [];\n\n    this.chart.data.labels = [];\n    this.updatechart();\n  }\n\n}, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"fromid\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"labels\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, \"refindex\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, \"refvalues\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, \"type\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, \"min\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, \"max\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, \"minichart\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, \"colorindex\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);\nexports.ChartjsTime = ChartjsTime;\n//# sourceMappingURL=chartjs-time.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMtdGltZS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLWJvZHlsaWdodC1wbHVnaW4vZGlzdC9uYXRpdmUtbW9kdWxlcy9lbGVtZW50cy9jaGFydGpzLXRpbWUuanM/MTg4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQ2hhcnRqc1RpbWUgPSB2b2lkIDA7XG5cbnZhciBfYXVyZWxpYVRlbXBsYXRpbmcgPSByZXF1aXJlKFwiYXVyZWxpYS10ZW1wbGF0aW5nXCIpO1xuXG52YXIgX2NoYXJ0anMgPSByZXF1aXJlKFwiLi9jaGFydGpzXCIpO1xuXG52YXIgX2RlYywgX2NsYXNzLCBfY2xhc3MyLCBfZGVzY3JpcHRvciwgX2Rlc2NyaXB0b3IyLCBfZGVzY3JpcHRvcjMsIF9kZXNjcmlwdG9yNCwgX2Rlc2NyaXB0b3I1LCBfZGVzY3JpcHRvcjYsIF9kZXNjcmlwdG9yNywgX2Rlc2NyaXB0b3I4LCBfZGVzY3JpcHRvcjk7XG5cbmZ1bmN0aW9uIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2NyaXB0b3IsIGNvbnRleHQpIHsgaWYgKCFkZXNjcmlwdG9yKSByZXR1cm47IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCB7IGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSwgY29uZmlndXJhYmxlOiBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSwgd3JpdGFibGU6IGRlc2NyaXB0b3Iud3JpdGFibGUsIHZhbHVlOiBkZXNjcmlwdG9yLmluaXRpYWxpemVyID8gZGVzY3JpcHRvci5pbml0aWFsaXplci5jYWxsKGNvbnRleHQpIDogdm9pZCAwIH0pOyB9XG5cbmZ1bmN0aW9uIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVjb3JhdG9ycywgZGVzY3JpcHRvciwgY29udGV4dCkgeyB2YXIgZGVzYyA9IHt9OyBPYmplY3Qua2V5cyhkZXNjcmlwdG9yKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZGVzY1trZXldID0gZGVzY3JpcHRvcltrZXldOyB9KTsgZGVzYy5lbnVtZXJhYmxlID0gISFkZXNjLmVudW1lcmFibGU7IGRlc2MuY29uZmlndXJhYmxlID0gISFkZXNjLmNvbmZpZ3VyYWJsZTsgaWYgKCd2YWx1ZScgaW4gZGVzYyB8fCBkZXNjLmluaXRpYWxpemVyKSB7IGRlc2Mud3JpdGFibGUgPSB0cnVlOyB9IGRlc2MgPSBkZWNvcmF0b3JzLnNsaWNlKCkucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbiAoZGVzYywgZGVjb3JhdG9yKSB7IHJldHVybiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYykgfHwgZGVzYzsgfSwgZGVzYyk7IGlmIChjb250ZXh0ICYmIGRlc2MuaW5pdGlhbGl6ZXIgIT09IHZvaWQgMCkgeyBkZXNjLnZhbHVlID0gZGVzYy5pbml0aWFsaXplciA/IGRlc2MuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMDsgZGVzYy5pbml0aWFsaXplciA9IHVuZGVmaW5lZDsgfSBpZiAoZGVzYy5pbml0aWFsaXplciA9PT0gdm9pZCAwKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjKTsgZGVzYyA9IG51bGw7IH0gcmV0dXJuIGRlc2M7IH1cblxuZnVuY3Rpb24gX2luaXRpYWxpemVyV2FybmluZ0hlbHBlcihkZXNjcmlwdG9yLCBjb250ZXh0KSB7IHRocm93IG5ldyBFcnJvcignRGVjb3JhdGluZyBjbGFzcyBwcm9wZXJ0eSBmYWlsZWQuIFBsZWFzZSBlbnN1cmUgdGhhdCAnICsgJ3Byb3Bvc2FsLWNsYXNzLXByb3BlcnRpZXMgaXMgZW5hYmxlZCBhbmQgcnVucyBhZnRlciB0aGUgZGVjb3JhdG9ycyB0cmFuc2Zvcm0uJyk7IH1cblxuLy9pbXBvcnQge1BMQVRGT1JNfSBmcm9tICdhdXJlbGlhLXBhbCc7XG4vL0BjdXN0b21FbGVtZW50XG4vL0B1c2VWaWV3KFBMQVRGT1JNLm1vZHVsZU5hbWUoJy4vYmRsLWNoYXJ0anMuaHRtbCcpKVxubGV0IENoYXJ0anNUaW1lID0gKF9kZWMgPSAoMCwgX2F1cmVsaWFUZW1wbGF0aW5nLnVzZVZpZXcpKCcuL2NoYXJ0anMuaHRtbCcpLCBfZGVjKF9jbGFzcyA9IChfY2xhc3MyID0gY2xhc3MgQ2hhcnRqc1RpbWUgZXh0ZW5kcyBfY2hhcnRqcy5DaGFydGpzIHtcbiAgLy8gc3RhcnRpbmcgIGluZGV4IC0gaWYgbW9vb29yIGluZGljZXMsIHNlcGFyYXRlIGJ5IGNvbW1hXG4gIC8vbnVtYmVyIG9mIHZhbHVlcyBmcm9tIHJlZmluZGV4IC0gb25seSBpZiBvbmUgcmVmaW5kZXggaXMgICBkZWZpbmVkXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7IC8vdGhpcy50eXBlID0gJ2xpbmUnO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJmcm9taWRcIiwgX2Rlc2NyaXB0b3IsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJsYWJlbHNcIiwgX2Rlc2NyaXB0b3IyLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVmaW5kZXhcIiwgX2Rlc2NyaXB0b3IzLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVmdmFsdWVzXCIsIF9kZXNjcmlwdG9yNCwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgX2Rlc2NyaXB0b3I1LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwibWluXCIsIF9kZXNjcmlwdG9yNiwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heFwiLCBfZGVzY3JpcHRvcjcsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJtaW5pY2hhcnRcIiwgX2Rlc2NyaXB0b3I4LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29sb3JpbmRleFwiLCBfZGVzY3JpcHRvcjksIHRoaXMpO1xuXG4gICAgdGhpcy5yZWZpbmRpY2VzID0gdm9pZCAwO1xuXG4gICAgdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZSA9IGUgPT4ge1xuICAgICAgLy9lLmRldGFpbCBkbyBub3QgcmVhbGxvY2F0ZSAtIHVzaW5nIHNhbWUgYnVmZmVyLCB0aHVzIHNsaWNpbmcgdG8gYXBwZW5kIHRvIGRhdGEgYXJyYXlcbiAgICAgIC8vbGV0IGRhdGFwb2ludHMgPWUuZGV0YWlsLmRhdGEuc2xpY2UodGhpcy5yZWZpbmRleCwgdGhpcy5yZWZlbmRpbmRleCk7XG4gICAgICBsZXQgaiA9IDA7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUluZGV4KGkpIHtcbiAgICAgICAge1xuICAgICAgICAgIC8vYWRkcyBkYXRhIHRvIGRhdGFzZXRzXG4gICAgICAgICAgLy9pZiBjb252ZXJ0IG9wZXJhdGlvbiBpcyBkZWZpbmVkIGFzIGFycmF5IHRoZW4gY29udmVydFxuICAgICAgICAgIGlmICh0aGlzLm9wZXJhdGlvbiAmJiB0aGlzLm9wZXJhdGlvbltqXSkgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2pdLmRhdGEucHVzaCh0aGlzLm9wZXJhdGlvbltqXShlLmRldGFpbC5kYXRhW2ldKSk7IC8vZWxzZSBwdXNoIGRhdGEgZGlyZWN0bHlcbiAgICAgICAgICBlbHNlIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tqXS5kYXRhLnB1c2goZS5kZXRhaWwuZGF0YVtpXSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2pdLmRhdGEubGVuZ3RoID4gdGhpcy5tYXhkYXRhKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzaGlmdGluZyBkYXRhc2V0IGNoYXJ0anMtdGltZScsIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tqXS5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tqXS5kYXRhLnNoaWZ0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnJlZmluZGljZXMpIGZvciAobGV0IGkgb2YgdGhpcy5yZWZpbmRpY2VzKSBoYW5kbGVJbmRleC5jYWxsKHRoaXMsIGkpO2Vsc2UgZm9yIChsZXQgaSA9IHRoaXMucmVmaW5kZXg7IGkgPCB0aGlzLnJlZmluZGV4ICsgdGhpcy5yZWZ2YWx1ZXM7IGkrKykgaGFuZGxlSW5kZXguY2FsbCh0aGlzLCBpKTtcbiAgICAgIHRoaXMuY2hhcnQuZGF0YS5sYWJlbHMucHVzaChlLmRldGFpbC50aW1lKTtcblxuICAgICAgaWYgKHRoaXMuY2hhcnQuZGF0YS5sYWJlbHMubGVuZ3RoID4gdGhpcy5tYXhkYXRhKSB7XG4gICAgICAgIHRoaXMuY2hhcnQuZGF0YS5sYWJlbHMuc2hpZnQoKTtcblxuICAgICAgICBpZiAodGhpcy5zZWN0aW9uaWQpIHtcbiAgICAgICAgICAvL3NoaWZ0IHNlY3Rpb25zXG4gICAgICAgICAgaWYgKHRoaXMuY2hhcnQuY29uZmlnLm9wdGlvbnMuc2VjdGlvblswXS5pbmRleCA9PT0gMCkgdGhpcy5jaGFydC5jb25maWcub3B0aW9ucy5zZWN0aW9uLnNoaWZ0KCk7IC8vZGVjcmVtZW50IGFsbCBpbmRpY2VzIGluIHNlY3Rpb25zXG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhcnQuY29uZmlnLm9wdGlvbnMuc2VjdGlvbi5sZW5ndGg7IGkrKykgdGhpcy5jaGFydC5jb25maWcub3B0aW9ucy5zZWN0aW9uW2ldLmluZGV4IC09IDE7XG4gICAgICAgIH1cbiAgICAgIH0gLy9zaGlmdCAtIHJlbW92ZSBmaXJzdCBlbGVtZW50IGlmIGRhdGEgaXMgdG9vIGJpZ1xuICAgICAgLy9jb25zb2xlLmxvZygnY2hhcnRqcyBoYW5kbGV2YWx1ZWNoYW5nZSgpIGNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YScsIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhKTtcblxuXG4gICAgICB0aGlzLnVwZGF0ZWNoYXJ0KCk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogc2V0cyBhbGwgdGltLXNlcmllcyBzcGVjaWZpYyBvcHRpb25zIGZvciBjaGFydGpzXG4gICAqL1xuXG5cbiAgYmluZCgpIHtcbiAgICBzdXBlci5iaW5kKCk7IC8vZG9uZSBpbiBzdXBlclxuICAgIC8vdGhpcy5jaGxhYmVscyA9IHRoaXMubGFiZWxzLnNwbGl0KCcsJyk7IC8vbGFiZWxzIGZvciBlYWNoIGRhdGFzZXRcbiAgICAvL3RoaXMuY29sb3JzID0gW107XG5cbiAgICBsZXQgZGF0YXNldHMgPSBbXTtcbiAgICBsZXQgbXlkYXRhMSA9IHRoaXMuaW5pdGlhbGRhdGEuc3BsaXQoJzsnKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yZWZ2YWx1ZXMgKyAxOyBpKyspIHtcbiAgICAgIC8vbXlkYXRhWzBdID09IHRpbWVsYWJlbHMgaW4geCBheGlzLCBteWRhdGFbMS4ubl0gYXIgaW4geSBheGlzXG4gICAgICBsZXQgbXlkYXRhMiA9IG15ZGF0YTFbaV0gPyBteWRhdGExW2ldLnNwbGl0KCcsJykgOiBbXTtcbiAgICAgIHRoaXMubXlkYXRhW2ldID0gbXlkYXRhMi5tYXAoeCA9PiB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHgpO1xuICAgICAgfSk7IC8vY29uc29sZS5sb2coJ2NoYXJ0anN0aW1lIG15ZGF0YSBpJyx0aGlzLm15ZGF0YVtpXSk7XG4gICAgfSAvL2luaXRpYWxpemUgY29sb3JzIGZvciBlYWNoIGRhdGFzZXRcblxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJlZnZhbHVlczsgaSsrKSB7XG4gICAgICAvL3RoaXMuY29sb3JzLnB1c2godGhpcy5zZWxlY3RDb2xvcihpKSk7XG4gICAgICBkYXRhc2V0cy5wdXNoKHtcbiAgICAgICAgZGF0YTogdGhpcy5teWRhdGFbaSArIDFdLFxuICAgICAgICBsYWJlbDogdGhpcy5jaGxhYmVsc1tpXSxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLnNlbGVjdENvbG9yKGkgKyB0aGlzLmNvbG9yaW5kZXgpLFxuICAgICAgICBib3JkZXJDb2xvcjogdGhpcy5zZWxlY3RDb2xvcihpICsgdGhpcy5jb2xvcmluZGV4KSxcbiAgICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICAgIHBvaW50UmFkaXVzOiAxLFxuICAgICAgICBmaWxsOiBmYWxzZVxuICAgICAgfSk7IC8vdGltZWxhYmVscy5wdXNoKGkpO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgIGxhYmVsczogdGhpcy5teWRhdGFbMF0sXG4gICAgICBkYXRhc2V0czogZGF0YXNldHNcbiAgICB9O1xuICAgIGlmICh0aGlzLnZlcnRpY2FsbGluZSkgdGhpcy50eXBlID0gJ0xpbmVXaXRoTGluZSc7ZWxzZSB0aGlzLnR5cGUgPSAnbGluZSc7XG4gIH1cblxuICBhdHRhY2hlZCgpIHtcbiAgICBzdXBlci5hdHRhY2hlZCgpO1xuICB9XG5cbiAgZGV0YWNoZWQoKSB7XG4gICAgc3VwZXIuZGV0YWNoZWQoKTtcbiAgfVxuXG4gIHJlc2V0ZGF0YSgpIHtcbiAgICAvL3N1cGVyLnJlc2V0ZGF0YSgpO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5yZWZ2YWx1ZXM7IGorKykgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2pdLmRhdGEgPSBbXTtcblxuICAgIHRoaXMuY2hhcnQuZGF0YS5sYWJlbHMgPSBbXTtcbiAgICB0aGlzLnVwZGF0ZWNoYXJ0KCk7XG4gIH1cblxufSwgKF9kZXNjcmlwdG9yID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJmcm9taWRcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjIgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcImxhYmVsc1wiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMyA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwicmVmaW5kZXhcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjQgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcInJlZnZhbHVlc1wiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yNSA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwidHlwZVwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yNiA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwibWluXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I3ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJtYXhcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjggPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcIm1pbmljaGFydFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yOSA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwiY29sb3JpbmRleFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSkpLCBfY2xhc3MyKSkgfHwgX2NsYXNzKTtcbmV4cG9ydHMuQ2hhcnRqc1RpbWUgPSBDaGFydGpzVGltZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYXJ0anMtdGltZS5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-time\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-time.html":
/*!**********************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-time.html ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template><!-- not used, inherited from chartjs--></template>\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMtdGltZS5odG1sLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F1cmVsaWEtYm9keWxpZ2h0LXBsdWdpbi9kaXN0L25hdGl2ZS1tb2R1bGVzL2VsZW1lbnRzL2NoYXJ0anMtdGltZS5odG1sPzZjNzIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIjx0ZW1wbGF0ZT48IS0tIG5vdCB1c2VkLCBpbmhlcml0ZWQgZnJvbSBjaGFydGpzLS0+PC90ZW1wbGF0ZT5cXG5cIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-time.html\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-xy":
/*!******************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-xy.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.ChartjsXy = void 0;\n\nvar _chartjsTime = __webpack_require__(/*! ./chartjs-time */ \"aurelia-bodylight-plugin/elements/chartjs-time\");\n\nvar _aureliaTemplating = __webpack_require__(/*! aurelia-templating */ \"hij8\");\n\nvar _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7;\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\n//import {PLATFORM} from 'aurelia-pal';\n//@useView(PLATFORM.moduleName('./bdl-chartjs.html'))\nlet ChartjsXy = (_dec = (0, _aureliaTemplating.useView)('./chartjs.html'), _dec(_class = (_class2 = class ChartjsXy extends _chartjsTime.ChartjsTime {\n  constructor() {\n    super();\n\n    _initializerDefineProperty(this, \"fromid\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"labels\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"refindex\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"refvalues\", _descriptor4, this);\n\n    _initializerDefineProperty(this, \"type\", _descriptor5, this);\n\n    _initializerDefineProperty(this, \"labelx\", _descriptor6, this);\n\n    _initializerDefineProperty(this, \"labely\", _descriptor7, this);\n\n    this.showlines = true;\n\n    this.handleValueChange = e => {\n      //e.detail do not reallocate - using same buffer, thus slicing to append to data array\n      //let datapoints =e.detail.data.slice(this.refindex, this.refendindex);\n      let j = 0; //put first value on x axis, others on y axis other values\n\n      for (let i = 1; i < this.refvalues; i++) {\n        if (this.operation && this.operation[i]) this.chart.data.datasets[j].data.push({\n          x: this.operation[0](e.detail.data[this.refindex]),\n          y: this.operation[i](e.detail.data[this.refindex + i])\n        });else this.chart.data.datasets[j].data.push({\n          x: e.detail.data[this.refindex],\n          y: e.detail.data[this.refindex + i]\n        }); //console.log('adding from data[], i, data[i]', e.detail.data, i, e.detail.data[i]);\n\n        if (this.chart.data.datasets[j].data.length > this.maxdata) {\n          //console.log('shifting dataset chartjs-xy', this.chart.data.datasets[j].data);\n          this.chart.data.datasets[j].data.shift();\n        }\n\n        j++;\n      } //console.log('chartjs-xy handlevaluechange datasets, e.detail.data',this.chart.data.datasets, e.detail.data);\n\n\n      this.updatechart();\n    };\n  }\n\n  bind() {\n    super.bind();\n    let datasets = [];\n    let mydata1 = this.initialdata.split(';'); //initialize x and y, x is first dataset, y is al the rest\n\n    this.mydata = [];\n\n    for (let i = 0; i < this.refvalues; i++) {\n      let mydata2 = mydata1[i] ? mydata1[i].split(',') : [];\n\n      if (i === 0) {\n        //parse x\n        this.mydata[0] = mydata2.map((x, index) => {\n          return parseFloat(x);\n        });\n      } else {\n        //parse all y\n        this.mydata[i] = mydata2.map((yy, index) => {\n          return {\n            x: this.mydata[0][index],\n            y: parseFloat(yy)\n          };\n        });\n      }\n    } //this.colors already set in super()\n\n\n    for (let i = 1; i < this.refvalues; i++) {\n      datasets.push({\n        data: this.mydata[i],\n        label: this.chlabels[i],\n        backgroundColor: this.colors[i - 1],\n        borderColor: this.colors[i - 1],\n        fill: false,\n        showLine: this.showlines,\n        borderWidth: 1,\n        refvalues: this.refvalues\n      });\n    } //add additional data, all after ; is taken as x values separated by , of initial curve,\n    // after ; is y values of initial curve separated by ,\n    // if more curves then another ;. E.g. initialdata=\";;0,0.00015;0,28000;0,0.00015;0,1400\"\n    // -> line from 0 0 to 0.0015 28000 and from 0 0 to 00015 1400\n\n\n    if (mydata1.length > this.refvalues) {\n      let j = this.refvalues;\n\n      for (let i = this.refvalues; i < mydata1.length; i += 2) {\n        let mydata2 = mydata1[i].split(',');\n        let mydata3 = mydata1[i + 1].split(',');\n        this.mydata[j] = mydata3.map((yy, index) => {\n          return {\n            x: parseFloat(mydata2[index]),\n            y: parseFloat(yy)\n          };\n        });\n        datasets.push({\n          data: this.mydata[j],\n          backgroundColor: this.selectColor(i),\n          borderColor: this.selectColor(i),\n          fill: false,\n          showLine: this.showlines\n        });\n        j++;\n      }\n    }\n\n    this.data = {\n      datasets: datasets\n    };\n    this.type = 'scatter';\n    this.options.tooltips.mode = 'nearest';\n    this.options.elements = {\n      point: {\n        radius: this.customRadius,\n        display: true\n      }\n    };\n  }\n\n  customRadius(context) {\n    let last = context.dataIndex === context.dataset.data.length - 1;\n    let inrefvalues = context.datasetIndex < context.dataset.refvalues; //dataset is in refvalues - changed by simulator\n\n    if (inrefvalues) return last ? 3 : 1;\n    return 1; //dataset is fixed - background borders\n  }\n\n  resetdata() {\n    let j = 0;\n\n    for (let i = this.refindex + 1; i < this.refindex + this.refvalues; i++) {\n      this.chart.data.datasets[j].data = [];\n      j++;\n    }\n  }\n\n}, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"fromid\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"labels\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, \"refindex\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, \"refvalues\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, \"type\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, \"labelx\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, \"labely\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);\nexports.ChartjsXy = ChartjsXy;\n//# sourceMappingURL=chartjs-xy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMteHkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2Rpc3QvbmF0aXZlLW1vZHVsZXMvZWxlbWVudHMvY2hhcnRqcy14eS5qcz84OGMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5DaGFydGpzWHkgPSB2b2lkIDA7XG5cbnZhciBfY2hhcnRqc1RpbWUgPSByZXF1aXJlKFwiLi9jaGFydGpzLXRpbWVcIik7XG5cbnZhciBfYXVyZWxpYVRlbXBsYXRpbmcgPSByZXF1aXJlKFwiYXVyZWxpYS10ZW1wbGF0aW5nXCIpO1xuXG52YXIgX2RlYywgX2NsYXNzLCBfY2xhc3MyLCBfZGVzY3JpcHRvciwgX2Rlc2NyaXB0b3IyLCBfZGVzY3JpcHRvcjMsIF9kZXNjcmlwdG9yNCwgX2Rlc2NyaXB0b3I1LCBfZGVzY3JpcHRvcjYsIF9kZXNjcmlwdG9yNztcblxuZnVuY3Rpb24gX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvciwgY29udGV4dCkgeyBpZiAoIWRlc2NyaXB0b3IpIHJldHVybjsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHsgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLCBjb25maWd1cmFibGU6IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlLCB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSwgdmFsdWU6IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIgPyBkZXNjcmlwdG9yLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDAgfSk7IH1cblxuZnVuY3Rpb24gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5LCBkZWNvcmF0b3JzLCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7IHZhciBkZXNjID0ge307IE9iamVjdC5rZXlzKGRlc2NyaXB0b3IpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBkZXNjW2tleV0gPSBkZXNjcmlwdG9yW2tleV07IH0pOyBkZXNjLmVudW1lcmFibGUgPSAhIWRlc2MuZW51bWVyYWJsZTsgZGVzYy5jb25maWd1cmFibGUgPSAhIWRlc2MuY29uZmlndXJhYmxlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjIHx8IGRlc2MuaW5pdGlhbGl6ZXIpIHsgZGVzYy53cml0YWJsZSA9IHRydWU7IH0gZGVzYyA9IGRlY29yYXRvcnMuc2xpY2UoKS5yZXZlcnNlKCkucmVkdWNlKGZ1bmN0aW9uIChkZXNjLCBkZWNvcmF0b3IpIHsgcmV0dXJuIGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5LCBkZXNjKSB8fCBkZXNjOyB9LCBkZXNjKTsgaWYgKGNvbnRleHQgJiYgZGVzYy5pbml0aWFsaXplciAhPT0gdm9pZCAwKSB7IGRlc2MudmFsdWUgPSBkZXNjLmluaXRpYWxpemVyID8gZGVzYy5pbml0aWFsaXplci5jYWxsKGNvbnRleHQpIDogdm9pZCAwOyBkZXNjLmluaXRpYWxpemVyID0gdW5kZWZpbmVkOyB9IGlmIChkZXNjLmluaXRpYWxpemVyID09PSB2b2lkIDApIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2MpOyBkZXNjID0gbnVsbDsgfSByZXR1cm4gZGVzYzsgfVxuXG5mdW5jdGlvbiBfaW5pdGlhbGl6ZXJXYXJuaW5nSGVscGVyKGRlc2NyaXB0b3IsIGNvbnRleHQpIHsgdGhyb3cgbmV3IEVycm9yKCdEZWNvcmF0aW5nIGNsYXNzIHByb3BlcnR5IGZhaWxlZC4gUGxlYXNlIGVuc3VyZSB0aGF0ICcgKyAncHJvcG9zYWwtY2xhc3MtcHJvcGVydGllcyBpcyBlbmFibGVkIGFuZCBydW5zIGFmdGVyIHRoZSBkZWNvcmF0b3JzIHRyYW5zZm9ybS4nKTsgfVxuXG4vL2ltcG9ydCB7UExBVEZPUk19IGZyb20gJ2F1cmVsaWEtcGFsJztcbi8vQHVzZVZpZXcoUExBVEZPUk0ubW9kdWxlTmFtZSgnLi9iZGwtY2hhcnRqcy5odG1sJykpXG5sZXQgQ2hhcnRqc1h5ID0gKF9kZWMgPSAoMCwgX2F1cmVsaWFUZW1wbGF0aW5nLnVzZVZpZXcpKCcuL2NoYXJ0anMuaHRtbCcpLCBfZGVjKF9jbGFzcyA9IChfY2xhc3MyID0gY2xhc3MgQ2hhcnRqc1h5IGV4dGVuZHMgX2NoYXJ0anNUaW1lLkNoYXJ0anNUaW1lIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwiZnJvbWlkXCIsIF9kZXNjcmlwdG9yLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwibGFiZWxzXCIsIF9kZXNjcmlwdG9yMiwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZmluZGV4XCIsIF9kZXNjcmlwdG9yMywgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZnZhbHVlc1wiLCBfZGVzY3JpcHRvcjQsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJ0eXBlXCIsIF9kZXNjcmlwdG9yNSwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxhYmVseFwiLCBfZGVzY3JpcHRvcjYsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJsYWJlbHlcIiwgX2Rlc2NyaXB0b3I3LCB0aGlzKTtcblxuICAgIHRoaXMuc2hvd2xpbmVzID0gdHJ1ZTtcblxuICAgIHRoaXMuaGFuZGxlVmFsdWVDaGFuZ2UgPSBlID0+IHtcbiAgICAgIC8vZS5kZXRhaWwgZG8gbm90IHJlYWxsb2NhdGUgLSB1c2luZyBzYW1lIGJ1ZmZlciwgdGh1cyBzbGljaW5nIHRvIGFwcGVuZCB0byBkYXRhIGFycmF5XG4gICAgICAvL2xldCBkYXRhcG9pbnRzID1lLmRldGFpbC5kYXRhLnNsaWNlKHRoaXMucmVmaW5kZXgsIHRoaXMucmVmZW5kaW5kZXgpO1xuICAgICAgbGV0IGogPSAwOyAvL3B1dCBmaXJzdCB2YWx1ZSBvbiB4IGF4aXMsIG90aGVycyBvbiB5IGF4aXMgb3RoZXIgdmFsdWVzXG5cbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5yZWZ2YWx1ZXM7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5vcGVyYXRpb24gJiYgdGhpcy5vcGVyYXRpb25baV0pIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tqXS5kYXRhLnB1c2goe1xuICAgICAgICAgIHg6IHRoaXMub3BlcmF0aW9uWzBdKGUuZGV0YWlsLmRhdGFbdGhpcy5yZWZpbmRleF0pLFxuICAgICAgICAgIHk6IHRoaXMub3BlcmF0aW9uW2ldKGUuZGV0YWlsLmRhdGFbdGhpcy5yZWZpbmRleCArIGldKVxuICAgICAgICB9KTtlbHNlIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tqXS5kYXRhLnB1c2goe1xuICAgICAgICAgIHg6IGUuZGV0YWlsLmRhdGFbdGhpcy5yZWZpbmRleF0sXG4gICAgICAgICAgeTogZS5kZXRhaWwuZGF0YVt0aGlzLnJlZmluZGV4ICsgaV1cbiAgICAgICAgfSk7IC8vY29uc29sZS5sb2coJ2FkZGluZyBmcm9tIGRhdGFbXSwgaSwgZGF0YVtpXScsIGUuZGV0YWlsLmRhdGEsIGksIGUuZGV0YWlsLmRhdGFbaV0pO1xuXG4gICAgICAgIGlmICh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbal0uZGF0YS5sZW5ndGggPiB0aGlzLm1heGRhdGEpIHtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzaGlmdGluZyBkYXRhc2V0IGNoYXJ0anMteHknLCB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbal0uZGF0YSk7XG4gICAgICAgICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2pdLmRhdGEuc2hpZnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGorKztcbiAgICAgIH0gLy9jb25zb2xlLmxvZygnY2hhcnRqcy14eSBoYW5kbGV2YWx1ZWNoYW5nZSBkYXRhc2V0cywgZS5kZXRhaWwuZGF0YScsdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLCBlLmRldGFpbC5kYXRhKTtcblxuXG4gICAgICB0aGlzLnVwZGF0ZWNoYXJ0KCk7XG4gICAgfTtcbiAgfVxuXG4gIGJpbmQoKSB7XG4gICAgc3VwZXIuYmluZCgpO1xuICAgIGxldCBkYXRhc2V0cyA9IFtdO1xuICAgIGxldCBteWRhdGExID0gdGhpcy5pbml0aWFsZGF0YS5zcGxpdCgnOycpOyAvL2luaXRpYWxpemUgeCBhbmQgeSwgeCBpcyBmaXJzdCBkYXRhc2V0LCB5IGlzIGFsIHRoZSByZXN0XG5cbiAgICB0aGlzLm15ZGF0YSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJlZnZhbHVlczsgaSsrKSB7XG4gICAgICBsZXQgbXlkYXRhMiA9IG15ZGF0YTFbaV0gPyBteWRhdGExW2ldLnNwbGl0KCcsJykgOiBbXTtcblxuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgLy9wYXJzZSB4XG4gICAgICAgIHRoaXMubXlkYXRhWzBdID0gbXlkYXRhMi5tYXAoKHgsIGluZGV4KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoeCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9wYXJzZSBhbGwgeVxuICAgICAgICB0aGlzLm15ZGF0YVtpXSA9IG15ZGF0YTIubWFwKCh5eSwgaW5kZXgpID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogdGhpcy5teWRhdGFbMF1baW5kZXhdLFxuICAgICAgICAgICAgeTogcGFyc2VGbG9hdCh5eSlcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IC8vdGhpcy5jb2xvcnMgYWxyZWFkeSBzZXQgaW4gc3VwZXIoKVxuXG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMucmVmdmFsdWVzOyBpKyspIHtcbiAgICAgIGRhdGFzZXRzLnB1c2goe1xuICAgICAgICBkYXRhOiB0aGlzLm15ZGF0YVtpXSxcbiAgICAgICAgbGFiZWw6IHRoaXMuY2hsYWJlbHNbaV0sXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5jb2xvcnNbaSAtIDFdLFxuICAgICAgICBib3JkZXJDb2xvcjogdGhpcy5jb2xvcnNbaSAtIDFdLFxuICAgICAgICBmaWxsOiBmYWxzZSxcbiAgICAgICAgc2hvd0xpbmU6IHRoaXMuc2hvd2xpbmVzLFxuICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgcmVmdmFsdWVzOiB0aGlzLnJlZnZhbHVlc1xuICAgICAgfSk7XG4gICAgfSAvL2FkZCBhZGRpdGlvbmFsIGRhdGEsIGFsbCBhZnRlciA7IGlzIHRha2VuIGFzIHggdmFsdWVzIHNlcGFyYXRlZCBieSAsIG9mIGluaXRpYWwgY3VydmUsXG4gICAgLy8gYWZ0ZXIgOyBpcyB5IHZhbHVlcyBvZiBpbml0aWFsIGN1cnZlIHNlcGFyYXRlZCBieSAsXG4gICAgLy8gaWYgbW9yZSBjdXJ2ZXMgdGhlbiBhbm90aGVyIDsuIEUuZy4gaW5pdGlhbGRhdGE9XCI7OzAsMC4wMDAxNTswLDI4MDAwOzAsMC4wMDAxNTswLDE0MDBcIlxuICAgIC8vIC0+IGxpbmUgZnJvbSAwIDAgdG8gMC4wMDE1IDI4MDAwIGFuZCBmcm9tIDAgMCB0byAwMDAxNSAxNDAwXG5cblxuICAgIGlmIChteWRhdGExLmxlbmd0aCA+IHRoaXMucmVmdmFsdWVzKSB7XG4gICAgICBsZXQgaiA9IHRoaXMucmVmdmFsdWVzO1xuXG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5yZWZ2YWx1ZXM7IGkgPCBteWRhdGExLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGxldCBteWRhdGEyID0gbXlkYXRhMVtpXS5zcGxpdCgnLCcpO1xuICAgICAgICBsZXQgbXlkYXRhMyA9IG15ZGF0YTFbaSArIDFdLnNwbGl0KCcsJyk7XG4gICAgICAgIHRoaXMubXlkYXRhW2pdID0gbXlkYXRhMy5tYXAoKHl5LCBpbmRleCkgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBwYXJzZUZsb2F0KG15ZGF0YTJbaW5kZXhdKSxcbiAgICAgICAgICAgIHk6IHBhcnNlRmxvYXQoeXkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRhdGFzZXRzLnB1c2goe1xuICAgICAgICAgIGRhdGE6IHRoaXMubXlkYXRhW2pdLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5zZWxlY3RDb2xvcihpKSxcbiAgICAgICAgICBib3JkZXJDb2xvcjogdGhpcy5zZWxlY3RDb2xvcihpKSxcbiAgICAgICAgICBmaWxsOiBmYWxzZSxcbiAgICAgICAgICBzaG93TGluZTogdGhpcy5zaG93bGluZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRhdGEgPSB7XG4gICAgICBkYXRhc2V0czogZGF0YXNldHNcbiAgICB9O1xuICAgIHRoaXMudHlwZSA9ICdzY2F0dGVyJztcbiAgICB0aGlzLm9wdGlvbnMudG9vbHRpcHMubW9kZSA9ICduZWFyZXN0JztcbiAgICB0aGlzLm9wdGlvbnMuZWxlbWVudHMgPSB7XG4gICAgICBwb2ludDoge1xuICAgICAgICByYWRpdXM6IHRoaXMuY3VzdG9tUmFkaXVzLFxuICAgICAgICBkaXNwbGF5OiB0cnVlXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGN1c3RvbVJhZGl1cyhjb250ZXh0KSB7XG4gICAgbGV0IGxhc3QgPSBjb250ZXh0LmRhdGFJbmRleCA9PT0gY29udGV4dC5kYXRhc2V0LmRhdGEubGVuZ3RoIC0gMTtcbiAgICBsZXQgaW5yZWZ2YWx1ZXMgPSBjb250ZXh0LmRhdGFzZXRJbmRleCA8IGNvbnRleHQuZGF0YXNldC5yZWZ2YWx1ZXM7IC8vZGF0YXNldCBpcyBpbiByZWZ2YWx1ZXMgLSBjaGFuZ2VkIGJ5IHNpbXVsYXRvclxuXG4gICAgaWYgKGlucmVmdmFsdWVzKSByZXR1cm4gbGFzdCA/IDMgOiAxO1xuICAgIHJldHVybiAxOyAvL2RhdGFzZXQgaXMgZml4ZWQgLSBiYWNrZ3JvdW5kIGJvcmRlcnNcbiAgfVxuXG4gIHJlc2V0ZGF0YSgpIHtcbiAgICBsZXQgaiA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gdGhpcy5yZWZpbmRleCArIDE7IGkgPCB0aGlzLnJlZmluZGV4ICsgdGhpcy5yZWZ2YWx1ZXM7IGkrKykge1xuICAgICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2pdLmRhdGEgPSBbXTtcbiAgICAgIGorKztcbiAgICB9XG4gIH1cblxufSwgKF9kZXNjcmlwdG9yID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJmcm9taWRcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjIgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcImxhYmVsc1wiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMyA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwicmVmaW5kZXhcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjQgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcInJlZnZhbHVlc1wiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yNSA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwidHlwZVwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yNiA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwibGFiZWx4XCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I3ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJsYWJlbHlcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pKSwgX2NsYXNzMikpIHx8IF9jbGFzcyk7XG5leHBvcnRzLkNoYXJ0anNYeSA9IENoYXJ0anNYeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYXJ0anMteHkuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-xy\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-xy-points":
/*!*************************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-xy-points.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.ChartjsXyPoints = void 0;\n\nvar _chartjsXy = __webpack_require__(/*! ./chartjs-xy */ \"aurelia-bodylight-plugin/elements/chartjs-xy\");\n\nvar _aureliaTemplating = __webpack_require__(/*! aurelia-templating */ \"hij8\");\n\nvar _chart = _interopRequireDefault(__webpack_require__(/*! chart.js */ \"MO+k\"));\n\nvar _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\nlet ChartjsXyPoints = (_dec = (0, _aureliaTemplating.useView)('./chartjs-xy-points.html'), _dec(_class = (_class2 = class ChartjsXyPoints extends _chartjsXy.ChartjsXy {\n  constructor() {\n    super();\n\n    _initializerDefineProperty(this, \"fromid\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"labels\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"refindex\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"refvalues\", _descriptor4, this);\n\n    _initializerDefineProperty(this, \"min\", _descriptor5, this);\n\n    _initializerDefineProperty(this, \"max\", _descriptor6, this);\n\n    _initializerDefineProperty(this, \"xmin\", _descriptor7, this);\n\n    _initializerDefineProperty(this, \"xmax\", _descriptor8, this);\n\n    _initializerDefineProperty(this, \"atitle\", _descriptor9, this);\n\n    _initializerDefineProperty(this, \"rtitle\", _descriptor10, this);\n\n    this.showlines = false;\n\n    _initializerDefineProperty(this, \"convertors\", _descriptor11, this);\n\n    this.index = 0;\n\n    this.handleValueChange = e => {\n      //e.detail do not reallocate - using same buffer, thus slicing to append to data array\n      let rawdata = e.detail.data.slice(this.refindex, this.refendindex); //do value conversion based on convertors\n\n      if (this.operation) {\n        for (let i = 0; i < rawdata.length; i++) {\n          //if particular operation is defined\n          if (this.operation[i]) rawdata[i] = this.operation[i](rawdata[i]);\n        }\n      }\n\n      let j = 0; //put each first value on x axis, second on y axis\n\n      for (let i = 1; i < this.refvalues; i = i + 2) {\n        //remember only current x,y value - on the index\n        this.chart.data.datasets[j].data[this.index] = {\n          x: rawdata[i - 1],\n          y: rawdata[i]\n        }; //increment dataset - if more dataset are available\n\n        j++;\n      }\n\n      this.updatechart();\n    };\n  }\n\n  bind() {\n    super.bind();\n    console.log('chartjs xy point bind()');\n\n    if (this.xmin) {\n      //sets yscale min\n      if (!this.options) this.options = {};\n      if (!this.options.scales) this.options.scales = {};\n      if (!this.options.scales.xAxes) this.options.scales.xAxes = [{}]; //chartjs 2.9.4\n\n      if (!this.options.scales.xAxes[0].ticks) this.options.scales.xAxes[0].ticks = {}; //chartjs 2.9.4\n\n      this.options.scales.xAxes[0].ticks.min = parseFloat(this.xmin);\n    }\n\n    if (this.xmax) {\n      //sets yscale max\n      if (!this.options) this.options = {};\n      if (!this.options.scales) this.options.scales = {};\n      if (!this.options.scales.xAxes) this.options.scales.xAxes = [{}]; //chartjs 2.9.4\n\n      if (!this.options.scales.xAxes[0].ticks) this.options.scales.xAxes[0].ticks = {}; //chartjs 2.9.4\n\n      this.options.scales.xAxes[0].ticks.max = parseFloat(this.xmax); //if (this.min) this.options.scales.yAxes[0].ticks.stepSize = (this.options.scales.yAxes[0].ticks.max - this.options.scales.yAxes[0].ticks.min) / 10;\n    } //customize tooltip display\n\n\n    this.options.tooltips.callbacks = {\n      label: function (tooltipItem, data) {\n        let label = data.datasets[tooltipItem.datasetIndex].label || '';\n\n        if (label) {\n          label += ': ';\n        }\n\n        label += '(' + tooltipItem.xLabel.toPrecision(3) + ',' + tooltipItem.yLabel.toPrecision(3) + ')';\n        return label;\n      },\n      footer: function (tooltipItem, data) {\n        if (data.datasets.length < 2) return tooltipItem[0].yLabel;\n        let label = []; //label.push('| ' + data.datasets[0].data[tooltipItem[0].index].y.toPrecision(3) + ' - ' + data.datasets[1].data[tooltipItem[0].index].y.toPrecision(3) + ' |');\n\n        label.push(' ' + Math.abs(data.datasets[0].data[tooltipItem[0].index].y - data.datasets[1].data[tooltipItem[0].index].y).toPrecision(3));\n        return label;\n      }\n    };\n    this.type = 'scatter';\n    this.plugins = null;\n    this.options.XYPlugin = true;\n  }\n\n  attached() {\n    //register horizontal line drawing, shows difference line between appropriate points from dataset0 and dataset1\n    _chart.default.pluginService.register({\n      beforeDraw: function (chart, ease) {\n        if (chart.config.options.XYPlugin && chart.tooltip._active && chart.tooltip._active.length) {\n          let activePoint = chart.tooltip._active[0]; //console.log('chart horizontal line debug chart activepoint:', activePoint);\n\n          let ctx = chart.ctx;\n          let y = activePoint.tooltipPosition().y; //let topY = this.chart.legend.bottom;\n\n          let leftX = chart.chartArea.left; //let bottomY = this.chart.chartArea.bottom;\n\n          let rightX = chart.chartArea.right; // draw line\n\n          ctx.save();\n          ctx.beginPath();\n          ctx.moveTo(leftX, y);\n          ctx.lineTo(rightX, y);\n          ctx.lineWidth = 1;\n          ctx.strokeStyle = '#ff9c9c';\n          ctx.stroke();\n          let meta1 = chart.getDatasetMeta(0);\n          let meta2 = chart.getDatasetMeta(1);\n\n          if (meta1) {\n            //draw second line\n            //console.log('plugin meta', chart, meta);\n            let secondy2 = meta1.data[activePoint._index]._model.y;\n            let secondy = secondy2 !== y ? secondy2 : meta2.data[activePoint._index]._model.y; //let stop  = meta.data[chart.config.options.section[i].index]._model.x;\n\n            ctx.beginPath();\n            ctx.moveTo(leftX, secondy);\n            ctx.lineTo(rightX, secondy);\n            ctx.lineWidth = 1;\n            ctx.strokeStyle = '#ff9c9c';\n            ctx.stroke();\n            let x = activePoint.tooltipPosition().x;\n            ctx.beginPath();\n            ctx.moveTo(x, y);\n            let sy = y > secondy ? 3 : -3; //small arrow up\n\n            ctx.lineTo(x - sy, y - sy);\n            ctx.lineTo(x + sy, y - sy); //line\n\n            ctx.lineTo(x, y);\n            ctx.lineTo(x, secondy); //small arrow down\n\n            ctx.lineTo(x - sy, secondy + sy);\n            ctx.lineTo(x + sy, secondy + sy);\n            ctx.lineTo(x, secondy);\n            ctx.lineWidth = 1;\n            ctx.strokeStyle = '#7b7bff';\n            ctx.stroke();\n          }\n\n          ctx.restore();\n        }\n      }\n    });\n\n    super.attached();\n  }\n\n  addpoint() {\n    this.index++;\n  }\n\n  removepoint() {\n    if (this.index > 0) this.index--;\n  }\n\n}, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"fromid\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"labels\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, \"refindex\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, \"refvalues\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, \"min\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, \"max\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, \"xmin\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, \"xmax\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, \"atitle\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 'Add Point';\n  }\n}), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, \"rtitle\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 'Remove Point';\n  }\n}), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, \"convertors\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);\nexports.ChartjsXyPoints = ChartjsXyPoints;\n//# sourceMappingURL=chartjs-xy-points.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMteHktcG9pbnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F1cmVsaWEtYm9keWxpZ2h0LXBsdWdpbi9kaXN0L25hdGl2ZS1tb2R1bGVzL2VsZW1lbnRzL2NoYXJ0anMteHktcG9pbnRzLmpzP2M2YjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkNoYXJ0anNYeVBvaW50cyA9IHZvaWQgMDtcblxudmFyIF9jaGFydGpzWHkgPSByZXF1aXJlKFwiLi9jaGFydGpzLXh5XCIpO1xuXG52YXIgX2F1cmVsaWFUZW1wbGF0aW5nID0gcmVxdWlyZShcImF1cmVsaWEtdGVtcGxhdGluZ1wiKTtcblxudmFyIF9jaGFydCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNoYXJ0LmpzXCIpKTtcblxudmFyIF9kZWMsIF9jbGFzcywgX2NsYXNzMiwgX2Rlc2NyaXB0b3IsIF9kZXNjcmlwdG9yMiwgX2Rlc2NyaXB0b3IzLCBfZGVzY3JpcHRvcjQsIF9kZXNjcmlwdG9yNSwgX2Rlc2NyaXB0b3I2LCBfZGVzY3JpcHRvcjcsIF9kZXNjcmlwdG9yOCwgX2Rlc2NyaXB0b3I5LCBfZGVzY3JpcHRvcjEwLCBfZGVzY3JpcHRvcjExO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7IGlmICghZGVzY3JpcHRvcikgcmV0dXJuOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgeyBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsIHdyaXRhYmxlOiBkZXNjcmlwdG9yLndyaXRhYmxlLCB2YWx1ZTogZGVzY3JpcHRvci5pbml0aWFsaXplciA/IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMCB9KTsgfVxuXG5mdW5jdGlvbiBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHksIGRlY29yYXRvcnMsIGRlc2NyaXB0b3IsIGNvbnRleHQpIHsgdmFyIGRlc2MgPSB7fTsgT2JqZWN0LmtleXMoZGVzY3JpcHRvcikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGRlc2Nba2V5XSA9IGRlc2NyaXB0b3Jba2V5XTsgfSk7IGRlc2MuZW51bWVyYWJsZSA9ICEhZGVzYy5lbnVtZXJhYmxlOyBkZXNjLmNvbmZpZ3VyYWJsZSA9ICEhZGVzYy5jb25maWd1cmFibGU7IGlmICgndmFsdWUnIGluIGRlc2MgfHwgZGVzYy5pbml0aWFsaXplcikgeyBkZXNjLndyaXRhYmxlID0gdHJ1ZTsgfSBkZXNjID0gZGVjb3JhdG9ycy5zbGljZSgpLnJldmVyc2UoKS5yZWR1Y2UoZnVuY3Rpb24gKGRlc2MsIGRlY29yYXRvcikgeyByZXR1cm4gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHksIGRlc2MpIHx8IGRlc2M7IH0sIGRlc2MpOyBpZiAoY29udGV4dCAmJiBkZXNjLmluaXRpYWxpemVyICE9PSB2b2lkIDApIHsgZGVzYy52YWx1ZSA9IGRlc2MuaW5pdGlhbGl6ZXIgPyBkZXNjLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDA7IGRlc2MuaW5pdGlhbGl6ZXIgPSB1bmRlZmluZWQ7IH0gaWYgKGRlc2MuaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYyk7IGRlc2MgPSBudWxsOyB9IHJldHVybiBkZXNjOyB9XG5cbmZ1bmN0aW9uIF9pbml0aWFsaXplcldhcm5pbmdIZWxwZXIoZGVzY3JpcHRvciwgY29udGV4dCkgeyB0aHJvdyBuZXcgRXJyb3IoJ0RlY29yYXRpbmcgY2xhc3MgcHJvcGVydHkgZmFpbGVkLiBQbGVhc2UgZW5zdXJlIHRoYXQgJyArICdwcm9wb3NhbC1jbGFzcy1wcm9wZXJ0aWVzIGlzIGVuYWJsZWQgYW5kIHJ1bnMgYWZ0ZXIgdGhlIGRlY29yYXRvcnMgdHJhbnNmb3JtLicpOyB9XG5cbmxldCBDaGFydGpzWHlQb2ludHMgPSAoX2RlYyA9ICgwLCBfYXVyZWxpYVRlbXBsYXRpbmcudXNlVmlldykoJy4vY2hhcnRqcy14eS1wb2ludHMuaHRtbCcpLCBfZGVjKF9jbGFzcyA9IChfY2xhc3MyID0gY2xhc3MgQ2hhcnRqc1h5UG9pbnRzIGV4dGVuZHMgX2NoYXJ0anNYeS5DaGFydGpzWHkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJmcm9taWRcIiwgX2Rlc2NyaXB0b3IsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJsYWJlbHNcIiwgX2Rlc2NyaXB0b3IyLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVmaW5kZXhcIiwgX2Rlc2NyaXB0b3IzLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVmdmFsdWVzXCIsIF9kZXNjcmlwdG9yNCwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1pblwiLCBfZGVzY3JpcHRvcjUsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhcIiwgX2Rlc2NyaXB0b3I2LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwieG1pblwiLCBfZGVzY3JpcHRvcjcsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJ4bWF4XCIsIF9kZXNjcmlwdG9yOCwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF0aXRsZVwiLCBfZGVzY3JpcHRvcjksIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJydGl0bGVcIiwgX2Rlc2NyaXB0b3IxMCwgdGhpcyk7XG5cbiAgICB0aGlzLnNob3dsaW5lcyA9IGZhbHNlO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJjb252ZXJ0b3JzXCIsIF9kZXNjcmlwdG9yMTEsIHRoaXMpO1xuXG4gICAgdGhpcy5pbmRleCA9IDA7XG5cbiAgICB0aGlzLmhhbmRsZVZhbHVlQ2hhbmdlID0gZSA9PiB7XG4gICAgICAvL2UuZGV0YWlsIGRvIG5vdCByZWFsbG9jYXRlIC0gdXNpbmcgc2FtZSBidWZmZXIsIHRodXMgc2xpY2luZyB0byBhcHBlbmQgdG8gZGF0YSBhcnJheVxuICAgICAgbGV0IHJhd2RhdGEgPSBlLmRldGFpbC5kYXRhLnNsaWNlKHRoaXMucmVmaW5kZXgsIHRoaXMucmVmZW5kaW5kZXgpOyAvL2RvIHZhbHVlIGNvbnZlcnNpb24gYmFzZWQgb24gY29udmVydG9yc1xuXG4gICAgICBpZiAodGhpcy5vcGVyYXRpb24pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXdkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgLy9pZiBwYXJ0aWN1bGFyIG9wZXJhdGlvbiBpcyBkZWZpbmVkXG4gICAgICAgICAgaWYgKHRoaXMub3BlcmF0aW9uW2ldKSByYXdkYXRhW2ldID0gdGhpcy5vcGVyYXRpb25baV0ocmF3ZGF0YVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IGogPSAwOyAvL3B1dCBlYWNoIGZpcnN0IHZhbHVlIG9uIHggYXhpcywgc2Vjb25kIG9uIHkgYXhpc1xuXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMucmVmdmFsdWVzOyBpID0gaSArIDIpIHtcbiAgICAgICAgLy9yZW1lbWJlciBvbmx5IGN1cnJlbnQgeCx5IHZhbHVlIC0gb24gdGhlIGluZGV4XG4gICAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tqXS5kYXRhW3RoaXMuaW5kZXhdID0ge1xuICAgICAgICAgIHg6IHJhd2RhdGFbaSAtIDFdLFxuICAgICAgICAgIHk6IHJhd2RhdGFbaV1cbiAgICAgICAgfTsgLy9pbmNyZW1lbnQgZGF0YXNldCAtIGlmIG1vcmUgZGF0YXNldCBhcmUgYXZhaWxhYmxlXG5cbiAgICAgICAgaisrO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZWNoYXJ0KCk7XG4gICAgfTtcbiAgfVxuXG4gIGJpbmQoKSB7XG4gICAgc3VwZXIuYmluZCgpO1xuICAgIGNvbnNvbGUubG9nKCdjaGFydGpzIHh5IHBvaW50IGJpbmQoKScpO1xuXG4gICAgaWYgKHRoaXMueG1pbikge1xuICAgICAgLy9zZXRzIHlzY2FsZSBtaW5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zKSB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNjYWxlcykgdGhpcy5vcHRpb25zLnNjYWxlcyA9IHt9O1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2NhbGVzLnhBeGVzKSB0aGlzLm9wdGlvbnMuc2NhbGVzLnhBeGVzID0gW3t9XTsgLy9jaGFydGpzIDIuOS40XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNjYWxlcy54QXhlc1swXS50aWNrcykgdGhpcy5vcHRpb25zLnNjYWxlcy54QXhlc1swXS50aWNrcyA9IHt9OyAvL2NoYXJ0anMgMi45LjRcblxuICAgICAgdGhpcy5vcHRpb25zLnNjYWxlcy54QXhlc1swXS50aWNrcy5taW4gPSBwYXJzZUZsb2F0KHRoaXMueG1pbik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMueG1heCkge1xuICAgICAgLy9zZXRzIHlzY2FsZSBtYXhcbiAgICAgIGlmICghdGhpcy5vcHRpb25zKSB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNjYWxlcykgdGhpcy5vcHRpb25zLnNjYWxlcyA9IHt9O1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2NhbGVzLnhBeGVzKSB0aGlzLm9wdGlvbnMuc2NhbGVzLnhBeGVzID0gW3t9XTsgLy9jaGFydGpzIDIuOS40XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNjYWxlcy54QXhlc1swXS50aWNrcykgdGhpcy5vcHRpb25zLnNjYWxlcy54QXhlc1swXS50aWNrcyA9IHt9OyAvL2NoYXJ0anMgMi45LjRcblxuICAgICAgdGhpcy5vcHRpb25zLnNjYWxlcy54QXhlc1swXS50aWNrcy5tYXggPSBwYXJzZUZsb2F0KHRoaXMueG1heCk7IC8vaWYgKHRoaXMubWluKSB0aGlzLm9wdGlvbnMuc2NhbGVzLnlBeGVzWzBdLnRpY2tzLnN0ZXBTaXplID0gKHRoaXMub3B0aW9ucy5zY2FsZXMueUF4ZXNbMF0udGlja3MubWF4IC0gdGhpcy5vcHRpb25zLnNjYWxlcy55QXhlc1swXS50aWNrcy5taW4pIC8gMTA7XG4gICAgfSAvL2N1c3RvbWl6ZSB0b29sdGlwIGRpc3BsYXlcblxuXG4gICAgdGhpcy5vcHRpb25zLnRvb2x0aXBzLmNhbGxiYWNrcyA9IHtcbiAgICAgIGxhYmVsOiBmdW5jdGlvbiAodG9vbHRpcEl0ZW0sIGRhdGEpIHtcbiAgICAgICAgbGV0IGxhYmVsID0gZGF0YS5kYXRhc2V0c1t0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXhdLmxhYmVsIHx8ICcnO1xuXG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgIGxhYmVsICs9ICc6ICc7XG4gICAgICAgIH1cblxuICAgICAgICBsYWJlbCArPSAnKCcgKyB0b29sdGlwSXRlbS54TGFiZWwudG9QcmVjaXNpb24oMykgKyAnLCcgKyB0b29sdGlwSXRlbS55TGFiZWwudG9QcmVjaXNpb24oMykgKyAnKSc7XG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgIH0sXG4gICAgICBmb290ZXI6IGZ1bmN0aW9uICh0b29sdGlwSXRlbSwgZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5kYXRhc2V0cy5sZW5ndGggPCAyKSByZXR1cm4gdG9vbHRpcEl0ZW1bMF0ueUxhYmVsO1xuICAgICAgICBsZXQgbGFiZWwgPSBbXTsgLy9sYWJlbC5wdXNoKCd8ICcgKyBkYXRhLmRhdGFzZXRzWzBdLmRhdGFbdG9vbHRpcEl0ZW1bMF0uaW5kZXhdLnkudG9QcmVjaXNpb24oMykgKyAnIC0gJyArIGRhdGEuZGF0YXNldHNbMV0uZGF0YVt0b29sdGlwSXRlbVswXS5pbmRleF0ueS50b1ByZWNpc2lvbigzKSArICcgfCcpO1xuXG4gICAgICAgIGxhYmVsLnB1c2goJ86UICcgKyBNYXRoLmFicyhkYXRhLmRhdGFzZXRzWzBdLmRhdGFbdG9vbHRpcEl0ZW1bMF0uaW5kZXhdLnkgLSBkYXRhLmRhdGFzZXRzWzFdLmRhdGFbdG9vbHRpcEl0ZW1bMF0uaW5kZXhdLnkpLnRvUHJlY2lzaW9uKDMpKTtcbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy50eXBlID0gJ3NjYXR0ZXInO1xuICAgIHRoaXMucGx1Z2lucyA9IG51bGw7XG4gICAgdGhpcy5vcHRpb25zLlhZUGx1Z2luID0gdHJ1ZTtcbiAgfVxuXG4gIGF0dGFjaGVkKCkge1xuICAgIC8vcmVnaXN0ZXIgaG9yaXpvbnRhbCBsaW5lIGRyYXdpbmcsIHNob3dzIGRpZmZlcmVuY2UgbGluZSBiZXR3ZWVuIGFwcHJvcHJpYXRlIHBvaW50cyBmcm9tIGRhdGFzZXQwIGFuZCBkYXRhc2V0MVxuICAgIF9jaGFydC5kZWZhdWx0LnBsdWdpblNlcnZpY2UucmVnaXN0ZXIoe1xuICAgICAgYmVmb3JlRHJhdzogZnVuY3Rpb24gKGNoYXJ0LCBlYXNlKSB7XG4gICAgICAgIGlmIChjaGFydC5jb25maWcub3B0aW9ucy5YWVBsdWdpbiAmJiBjaGFydC50b29sdGlwLl9hY3RpdmUgJiYgY2hhcnQudG9vbHRpcC5fYWN0aXZlLmxlbmd0aCkge1xuICAgICAgICAgIGxldCBhY3RpdmVQb2ludCA9IGNoYXJ0LnRvb2x0aXAuX2FjdGl2ZVswXTsgLy9jb25zb2xlLmxvZygnY2hhcnQgaG9yaXpvbnRhbCBsaW5lIGRlYnVnIGNoYXJ0IGFjdGl2ZXBvaW50OicsIGFjdGl2ZVBvaW50KTtcblxuICAgICAgICAgIGxldCBjdHggPSBjaGFydC5jdHg7XG4gICAgICAgICAgbGV0IHkgPSBhY3RpdmVQb2ludC50b29sdGlwUG9zaXRpb24oKS55OyAvL2xldCB0b3BZID0gdGhpcy5jaGFydC5sZWdlbmQuYm90dG9tO1xuXG4gICAgICAgICAgbGV0IGxlZnRYID0gY2hhcnQuY2hhcnRBcmVhLmxlZnQ7IC8vbGV0IGJvdHRvbVkgPSB0aGlzLmNoYXJ0LmNoYXJ0QXJlYS5ib3R0b207XG5cbiAgICAgICAgICBsZXQgcmlnaHRYID0gY2hhcnQuY2hhcnRBcmVhLnJpZ2h0OyAvLyBkcmF3IGxpbmVcblxuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5tb3ZlVG8obGVmdFgsIHkpO1xuICAgICAgICAgIGN0eC5saW5lVG8ocmlnaHRYLCB5KTtcbiAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnI2ZmOWM5Yyc7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIGxldCBtZXRhMSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuICAgICAgICAgIGxldCBtZXRhMiA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDEpO1xuXG4gICAgICAgICAgaWYgKG1ldGExKSB7XG4gICAgICAgICAgICAvL2RyYXcgc2Vjb25kIGxpbmVcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3BsdWdpbiBtZXRhJywgY2hhcnQsIG1ldGEpO1xuICAgICAgICAgICAgbGV0IHNlY29uZHkyID0gbWV0YTEuZGF0YVthY3RpdmVQb2ludC5faW5kZXhdLl9tb2RlbC55O1xuICAgICAgICAgICAgbGV0IHNlY29uZHkgPSBzZWNvbmR5MiAhPT0geSA/IHNlY29uZHkyIDogbWV0YTIuZGF0YVthY3RpdmVQb2ludC5faW5kZXhdLl9tb2RlbC55OyAvL2xldCBzdG9wICA9IG1ldGEuZGF0YVtjaGFydC5jb25maWcub3B0aW9ucy5zZWN0aW9uW2ldLmluZGV4XS5fbW9kZWwueDtcblxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhsZWZ0WCwgc2Vjb25keSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHJpZ2h0WCwgc2Vjb25keSk7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjZmY5YzljJztcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIGxldCB4ID0gYWN0aXZlUG9pbnQudG9vbHRpcFBvc2l0aW9uKCkueDtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICBsZXQgc3kgPSB5ID4gc2Vjb25keSA/IDMgOiAtMzsgLy9zbWFsbCBhcnJvdyB1cFxuXG4gICAgICAgICAgICBjdHgubGluZVRvKHggLSBzeSwgeSAtIHN5KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHN5LCB5IC0gc3kpOyAvL2xpbmVcblxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgc2Vjb25keSk7IC8vc21hbGwgYXJyb3cgZG93blxuXG4gICAgICAgICAgICBjdHgubGluZVRvKHggLSBzeSwgc2Vjb25keSArIHN5KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHN5LCBzZWNvbmR5ICsgc3kpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCBzZWNvbmR5KTtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyM3YjdiZmYnO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHN1cGVyLmF0dGFjaGVkKCk7XG4gIH1cblxuICBhZGRwb2ludCgpIHtcbiAgICB0aGlzLmluZGV4Kys7XG4gIH1cblxuICByZW1vdmVwb2ludCgpIHtcbiAgICBpZiAodGhpcy5pbmRleCA+IDApIHRoaXMuaW5kZXgtLTtcbiAgfVxuXG59LCAoX2Rlc2NyaXB0b3IgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcImZyb21pZFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMiA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwibGFiZWxzXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3IzID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJyZWZpbmRleFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yNCA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwicmVmdmFsdWVzXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I1ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJtaW5cIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjYgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcIm1heFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yNyA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwieG1pblwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yOCA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwieG1heFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yOSA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwiYXRpdGxlXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdBZGQgUG9pbnQnO1xuICB9XG59KSwgX2Rlc2NyaXB0b3IxMCA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwicnRpdGxlXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdSZW1vdmUgUG9pbnQnO1xuICB9XG59KSwgX2Rlc2NyaXB0b3IxMSA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwiY29udmVydG9yc1wiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSkpLCBfY2xhc3MyKSkgfHwgX2NsYXNzKTtcbmV4cG9ydHMuQ2hhcnRqc1h5UG9pbnRzID0gQ2hhcnRqc1h5UG9pbnRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhcnRqcy14eS1wb2ludHMuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-xy-points\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-xy-points.html":
/*!***************************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-xy-points.html ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template bindable=\\\"width,height\\\">\\n    <div id=\\\"canvas-holder\\\">\\n        <div class=\\\"w3-small\\\">\\n            <i class=\\\"fa fa-download fa-flip-horizontal\\\" title=\\\"download csv data, row=data in time point\\\"\\n               click.delegate=\\\"download()\\\"> </i>\\n            <i class=\\\"fa fa-download fa-rotate-270\\\" title=\\\"download flat csv data, row=all data for variable\\\"\\n               click.delegate=\\\"downloadflat()\\\"> </i>\\n\\n        </div>\\n        <div style=\\\"margin-top: -1.5em\\\">\\n            <canvas id=\\\"${id}-canvas\\\" ref=\\\"chartcanvas\\\" width=\\\"${width}\\\" height=\\\"${height}\\\"></canvas>\\n        </div>\\n        <button click.delegate=\\\"addpoint()\\\">${atitle}</button><button click.delegate=\\\"removepoint()\\\">${rtitle}</button>\\n    </div>\\n</template>\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMteHktcG9pbnRzLmh0bWwuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2Rpc3QvbmF0aXZlLW1vZHVsZXMvZWxlbWVudHMvY2hhcnRqcy14eS1wb2ludHMuaHRtbD8xNDMyIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCI8dGVtcGxhdGUgYmluZGFibGU9XFxcIndpZHRoLGhlaWdodFxcXCI+XFxuICAgIDxkaXYgaWQ9XFxcImNhbnZhcy1ob2xkZXJcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidzMtc21hbGxcXFwiPlxcbiAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1kb3dubG9hZCBmYS1mbGlwLWhvcml6b250YWxcXFwiIHRpdGxlPVxcXCJkb3dubG9hZCBjc3YgZGF0YSwgcm93PWRhdGEgaW4gdGltZSBwb2ludFxcXCJcXG4gICAgICAgICAgICAgICBjbGljay5kZWxlZ2F0ZT1cXFwiZG93bmxvYWQoKVxcXCI+IDwvaT5cXG4gICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtZG93bmxvYWQgZmEtcm90YXRlLTI3MFxcXCIgdGl0bGU9XFxcImRvd25sb2FkIGZsYXQgY3N2IGRhdGEsIHJvdz1hbGwgZGF0YSBmb3IgdmFyaWFibGVcXFwiXFxuICAgICAgICAgICAgICAgY2xpY2suZGVsZWdhdGU9XFxcImRvd25sb2FkZmxhdCgpXFxcIj4gPC9pPlxcblxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IHN0eWxlPVxcXCJtYXJnaW4tdG9wOiAtMS41ZW1cXFwiPlxcbiAgICAgICAgICAgIDxjYW52YXMgaWQ9XFxcIiR7aWR9LWNhbnZhc1xcXCIgcmVmPVxcXCJjaGFydGNhbnZhc1xcXCIgd2lkdGg9XFxcIiR7d2lkdGh9XFxcIiBoZWlnaHQ9XFxcIiR7aGVpZ2h0fVxcXCI+PC9jYW52YXM+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxidXR0b24gY2xpY2suZGVsZWdhdGU9XFxcImFkZHBvaW50KClcXFwiPiR7YXRpdGxlfTwvYnV0dG9uPjxidXR0b24gY2xpY2suZGVsZWdhdGU9XFxcInJlbW92ZXBvaW50KClcXFwiPiR7cnRpdGxlfTwvYnV0dG9uPlxcbiAgICA8L2Rpdj5cXG48L3RlbXBsYXRlPlwiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-xy-points.html\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs-xy.html":
/*!********************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs-xy.html ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template><!-- not used, inherited from chartjs--></template>\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMteHkuaHRtbC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLWJvZHlsaWdodC1wbHVnaW4vZGlzdC9uYXRpdmUtbW9kdWxlcy9lbGVtZW50cy9jaGFydGpzLXh5Lmh0bWw/ZDFmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiPHRlbXBsYXRlPjwhLS0gbm90IHVzZWQsIGluaGVyaXRlZCBmcm9tIGNoYXJ0anMtLT48L3RlbXBsYXRlPlxcblwiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs-xy.html\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/chartjs.html":
/*!*****************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/chartjs.html ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template bindable=\\\"width,height\\\">\\n    <div id=\\\"canvas-holder\\\" style.bind=\\\"responsive ? '':'display:inline-block'\\\">\\n        <div class=\\\"w3-small\\\" show.bind=\\\"! minichart\\\">\\n            <i class=\\\"fa fa-download fa-flip-horizontal\\\" title=\\\"download csv data, row=data in time point\\\"\\n               click.delegate=\\\"download()\\\"> </i>\\n            <i class=\\\"fa fa-download fa-rotate-270\\\" title=\\\"download flat csv data, row=all data for variable\\\"\\n               click.delegate=\\\"downloadflat()\\\"> </i>\\n        </div>\\n        <div css=\\\"${minichart ? '' : 'margin-top: -1.5em'}\\\">\\n            <canvas id=\\\"${id}-canvas\\\" ref=\\\"chartcanvas\\\" width=\\\"${width}\\\" height=\\\"${height}\\\"></canvas>\\n        </div>\\n    </div>\\n</template>\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoYXJ0anMuaHRtbC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLWJvZHlsaWdodC1wbHVnaW4vZGlzdC9uYXRpdmUtbW9kdWxlcy9lbGVtZW50cy9jaGFydGpzLmh0bWw/MmNiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiPHRlbXBsYXRlIGJpbmRhYmxlPVxcXCJ3aWR0aCxoZWlnaHRcXFwiPlxcbiAgICA8ZGl2IGlkPVxcXCJjYW52YXMtaG9sZGVyXFxcIiBzdHlsZS5iaW5kPVxcXCJyZXNwb25zaXZlID8gJyc6J2Rpc3BsYXk6aW5saW5lLWJsb2NrJ1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ3My1zbWFsbFxcXCIgc2hvdy5iaW5kPVxcXCIhIG1pbmljaGFydFxcXCI+XFxuICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWRvd25sb2FkIGZhLWZsaXAtaG9yaXpvbnRhbFxcXCIgdGl0bGU9XFxcImRvd25sb2FkIGNzdiBkYXRhLCByb3c9ZGF0YSBpbiB0aW1lIHBvaW50XFxcIlxcbiAgICAgICAgICAgICAgIGNsaWNrLmRlbGVnYXRlPVxcXCJkb3dubG9hZCgpXFxcIj4gPC9pPlxcbiAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1kb3dubG9hZCBmYS1yb3RhdGUtMjcwXFxcIiB0aXRsZT1cXFwiZG93bmxvYWQgZmxhdCBjc3YgZGF0YSwgcm93PWFsbCBkYXRhIGZvciB2YXJpYWJsZVxcXCJcXG4gICAgICAgICAgICAgICBjbGljay5kZWxlZ2F0ZT1cXFwiZG93bmxvYWRmbGF0KClcXFwiPiA8L2k+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY3NzPVxcXCIke21pbmljaGFydCA/ICcnIDogJ21hcmdpbi10b3A6IC0xLjVlbSd9XFxcIj5cXG4gICAgICAgICAgICA8Y2FudmFzIGlkPVxcXCIke2lkfS1jYW52YXNcXFwiIHJlZj1cXFwiY2hhcnRjYW52YXNcXFwiIHdpZHRoPVxcXCIke3dpZHRofVxcXCIgaGVpZ2h0PVxcXCIke2hlaWdodH1cXFwiPjwvY2FudmFzPlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuXCI7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/chartjs.html\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/checkbox":
/*!****************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/checkbox.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.Checkbox = void 0;\n\nvar _aureliaFramework = __webpack_require__(/*! aurelia-framework */ \"aurelia-framework\");\n\nvar _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6;\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\nlet Checkbox = (_class = class Checkbox {\n  constructor() {\n    _initializerDefineProperty(this, \"min\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"max\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"title\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"titlemax\", _descriptor4, this);\n\n    _initializerDefineProperty(this, \"titlemin\", _descriptor5, this);\n\n    _initializerDefineProperty(this, \"default\", _descriptor6, this);\n\n    this.value = void 0;\n    this.isChecked = false;\n  }\n\n  bind() {\n    if (this.default) {\n      //console.log('checkbox default,', this.default);\n      this.isChecked = this.default === 'true';\n    }\n\n    if (!this.titlemax) this.titlemax = this.title;\n    if (!this.titlemin) this.titlemin = this.title; //console.log('checkbox bind() min:' + this.min + ' max:' + this.max + ' default:' + this.default + ' ischecked' + this.isChecked);\n  }\n\n}, (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"min\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 0;\n  }\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"max\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 1;\n  }\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"title\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return '';\n  }\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, \"titlemax\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, \"titlemin\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, \"default\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class);\nexports.Checkbox = Checkbox;\n//# sourceMappingURL=checkbox.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoZWNrYm94LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F1cmVsaWEtYm9keWxpZ2h0LXBsdWdpbi9kaXN0L25hdGl2ZS1tb2R1bGVzL2VsZW1lbnRzL2NoZWNrYm94LmpzP2QwNDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkNoZWNrYm94ID0gdm9pZCAwO1xuXG52YXIgX2F1cmVsaWFGcmFtZXdvcmsgPSByZXF1aXJlKFwiYXVyZWxpYS1mcmFtZXdvcmtcIik7XG5cbnZhciBfY2xhc3MsIF9kZXNjcmlwdG9yLCBfZGVzY3JpcHRvcjIsIF9kZXNjcmlwdG9yMywgX2Rlc2NyaXB0b3I0LCBfZGVzY3JpcHRvcjUsIF9kZXNjcmlwdG9yNjtcblxuZnVuY3Rpb24gX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvciwgY29udGV4dCkgeyBpZiAoIWRlc2NyaXB0b3IpIHJldHVybjsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHsgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLCBjb25maWd1cmFibGU6IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlLCB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSwgdmFsdWU6IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIgPyBkZXNjcmlwdG9yLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDAgfSk7IH1cblxuZnVuY3Rpb24gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5LCBkZWNvcmF0b3JzLCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7IHZhciBkZXNjID0ge307IE9iamVjdC5rZXlzKGRlc2NyaXB0b3IpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBkZXNjW2tleV0gPSBkZXNjcmlwdG9yW2tleV07IH0pOyBkZXNjLmVudW1lcmFibGUgPSAhIWRlc2MuZW51bWVyYWJsZTsgZGVzYy5jb25maWd1cmFibGUgPSAhIWRlc2MuY29uZmlndXJhYmxlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjIHx8IGRlc2MuaW5pdGlhbGl6ZXIpIHsgZGVzYy53cml0YWJsZSA9IHRydWU7IH0gZGVzYyA9IGRlY29yYXRvcnMuc2xpY2UoKS5yZXZlcnNlKCkucmVkdWNlKGZ1bmN0aW9uIChkZXNjLCBkZWNvcmF0b3IpIHsgcmV0dXJuIGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5LCBkZXNjKSB8fCBkZXNjOyB9LCBkZXNjKTsgaWYgKGNvbnRleHQgJiYgZGVzYy5pbml0aWFsaXplciAhPT0gdm9pZCAwKSB7IGRlc2MudmFsdWUgPSBkZXNjLmluaXRpYWxpemVyID8gZGVzYy5pbml0aWFsaXplci5jYWxsKGNvbnRleHQpIDogdm9pZCAwOyBkZXNjLmluaXRpYWxpemVyID0gdW5kZWZpbmVkOyB9IGlmIChkZXNjLmluaXRpYWxpemVyID09PSB2b2lkIDApIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2MpOyBkZXNjID0gbnVsbDsgfSByZXR1cm4gZGVzYzsgfVxuXG5mdW5jdGlvbiBfaW5pdGlhbGl6ZXJXYXJuaW5nSGVscGVyKGRlc2NyaXB0b3IsIGNvbnRleHQpIHsgdGhyb3cgbmV3IEVycm9yKCdEZWNvcmF0aW5nIGNsYXNzIHByb3BlcnR5IGZhaWxlZC4gUGxlYXNlIGVuc3VyZSB0aGF0ICcgKyAncHJvcG9zYWwtY2xhc3MtcHJvcGVydGllcyBpcyBlbmFibGVkIGFuZCBydW5zIGFmdGVyIHRoZSBkZWNvcmF0b3JzIHRyYW5zZm9ybS4nKTsgfVxuXG5sZXQgQ2hlY2tib3ggPSAoX2NsYXNzID0gY2xhc3MgQ2hlY2tib3gge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1pblwiLCBfZGVzY3JpcHRvciwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heFwiLCBfZGVzY3JpcHRvcjIsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aXRsZVwiLCBfZGVzY3JpcHRvcjMsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aXRsZW1heFwiLCBfZGVzY3JpcHRvcjQsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aXRsZW1pblwiLCBfZGVzY3JpcHRvcjUsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWZhdWx0XCIsIF9kZXNjcmlwdG9yNiwgdGhpcyk7XG5cbiAgICB0aGlzLnZhbHVlID0gdm9pZCAwO1xuICAgIHRoaXMuaXNDaGVja2VkID0gZmFsc2U7XG4gIH1cblxuICBiaW5kKCkge1xuICAgIGlmICh0aGlzLmRlZmF1bHQpIHtcbiAgICAgIC8vY29uc29sZS5sb2coJ2NoZWNrYm94IGRlZmF1bHQsJywgdGhpcy5kZWZhdWx0KTtcbiAgICAgIHRoaXMuaXNDaGVja2VkID0gdGhpcy5kZWZhdWx0ID09PSAndHJ1ZSc7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnRpdGxlbWF4KSB0aGlzLnRpdGxlbWF4ID0gdGhpcy50aXRsZTtcbiAgICBpZiAoIXRoaXMudGl0bGVtaW4pIHRoaXMudGl0bGVtaW4gPSB0aGlzLnRpdGxlOyAvL2NvbnNvbGUubG9nKCdjaGVja2JveCBiaW5kKCkgbWluOicgKyB0aGlzLm1pbiArICcgbWF4OicgKyB0aGlzLm1heCArICcgZGVmYXVsdDonICsgdGhpcy5kZWZhdWx0ICsgJyBpc2NoZWNrZWQnICsgdGhpcy5pc0NoZWNrZWQpO1xuICB9XG5cbn0sIChfZGVzY3JpcHRvciA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJtaW5cIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAwO1xuICB9XG59KSwgX2Rlc2NyaXB0b3IyID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcIm1heFwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjMgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwidGl0bGVcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJztcbiAgfVxufSksIF9kZXNjcmlwdG9yNCA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJ0aXRsZW1heFwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I1ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcInRpdGxlbWluXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjYgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiZGVmYXVsdFwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSksIF9jbGFzcyk7XG5leHBvcnRzLkNoZWNrYm94ID0gQ2hlY2tib3g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja2JveC5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/checkbox\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/checkbox.html":
/*!******************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/checkbox.html ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template bindable=\\\"default,title,min,max,titlemin,titlemax\\\">\\n    <span class=\\\"slidecontainer\\\">\\n        <input class=\\\"w3-check\\\" type=\\\"checkbox\\\" checked.two-way=\\\"isChecked\\\" value.bind=\\\"isChecked?max:min\\\"/> <label>${isChecked?titlemax:titlemin}</label>\\n    </span>\\n</template>\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2NoZWNrYm94Lmh0bWwuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2Rpc3QvbmF0aXZlLW1vZHVsZXMvZWxlbWVudHMvY2hlY2tib3guaHRtbD9lMjUwIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCI8dGVtcGxhdGUgYmluZGFibGU9XFxcImRlZmF1bHQsdGl0bGUsbWluLG1heCx0aXRsZW1pbix0aXRsZW1heFxcXCI+XFxuICAgIDxzcGFuIGNsYXNzPVxcXCJzbGlkZWNvbnRhaW5lclxcXCI+XFxuICAgICAgICA8aW5wdXQgY2xhc3M9XFxcInczLWNoZWNrXFxcIiB0eXBlPVxcXCJjaGVja2JveFxcXCIgY2hlY2tlZC50d28td2F5PVxcXCJpc0NoZWNrZWRcXFwiIHZhbHVlLmJpbmQ9XFxcImlzQ2hlY2tlZD9tYXg6bWluXFxcIi8+IDxsYWJlbD4ke2lzQ2hlY2tlZD90aXRsZW1heDp0aXRsZW1pbn08L2xhYmVsPlxcbiAgICA8L3NwYW4+XFxuPC90ZW1wbGF0ZT5cXG5cIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/checkbox.html\n");

/***/ })

}]);