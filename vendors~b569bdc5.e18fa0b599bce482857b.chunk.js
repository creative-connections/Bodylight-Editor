(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~b569bdc5"],{

/***/ "+80P":
/*!******************************************!*\
  !*** ./node_modules/linkify-it/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Helpers\n\n// Merge objects\n//\nfunction assign(obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n\n  sources.forEach(function (source) {\n    if (!source) { return; }\n\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key];\n    });\n  });\n\n  return obj;\n}\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\nfunction isString(obj) { return _class(obj) === '[object String]'; }\nfunction isObject(obj) { return _class(obj) === '[object Object]'; }\nfunction isRegExp(obj) { return _class(obj) === '[object RegExp]'; }\nfunction isFunction(obj) { return _class(obj) === '[object Function]'; }\n\n\nfunction escapeRE(str) { return str.replace(/[.?*+^$[\\]\\\\(){}|-]/g, '\\\\$&'); }\n\n////////////////////////////////////////////////////////////////////////////////\n\n\nvar defaultOptions = {\n  fuzzyLink: true,\n  fuzzyEmail: true,\n  fuzzyIP: false\n};\n\n\nfunction isOptionsObj(obj) {\n  return Object.keys(obj || {}).reduce(function (acc, k) {\n    return acc || defaultOptions.hasOwnProperty(k);\n  }, false);\n}\n\n\nvar defaultSchemas = {\n  'http:': {\n    validate: function (text, pos, self) {\n      var tail = text.slice(pos);\n\n      if (!self.re.http) {\n        // compile lazily, because \"host\"-containing variables can change on tlds update.\n        self.re.http =  new RegExp(\n          '^\\\\/\\\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i'\n        );\n      }\n      if (self.re.http.test(tail)) {\n        return tail.match(self.re.http)[0].length;\n      }\n      return 0;\n    }\n  },\n  'https:':  'http:',\n  'ftp:':    'http:',\n  '//':      {\n    validate: function (text, pos, self) {\n      var tail = text.slice(pos);\n\n      if (!self.re.no_http) {\n      // compile lazily, because \"host\"-containing variables can change on tlds update.\n        self.re.no_http =  new RegExp(\n          '^' +\n          self.re.src_auth +\n          // Don't allow single-level domains, because of false positives like '//test'\n          // with code comments\n          '(?:localhost|(?:(?:' + self.re.src_domain + ')\\\\.)+' + self.re.src_domain_root + ')' +\n          self.re.src_port +\n          self.re.src_host_terminator +\n          self.re.src_path,\n\n          'i'\n        );\n      }\n\n      if (self.re.no_http.test(tail)) {\n        // should not be `://` & `///`, that protects from errors in protocol name\n        if (pos >= 3 && text[pos - 3] === ':') { return 0; }\n        if (pos >= 3 && text[pos - 3] === '/') { return 0; }\n        return tail.match(self.re.no_http)[0].length;\n      }\n      return 0;\n    }\n  },\n  'mailto:': {\n    validate: function (text, pos, self) {\n      var tail = text.slice(pos);\n\n      if (!self.re.mailto) {\n        self.re.mailto =  new RegExp(\n          '^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i'\n        );\n      }\n      if (self.re.mailto.test(tail)) {\n        return tail.match(self.re.mailto)[0].length;\n      }\n      return 0;\n    }\n  }\n};\n\n/*eslint-disable max-len*/\n\n// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)\nvar tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';\n\n// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead\nvar tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');\n\n/*eslint-enable max-len*/\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction resetScanCache(self) {\n  self.__index__ = -1;\n  self.__text_cache__   = '';\n}\n\nfunction createValidator(re) {\n  return function (text, pos) {\n    var tail = text.slice(pos);\n\n    if (re.test(tail)) {\n      return tail.match(re)[0].length;\n    }\n    return 0;\n  };\n}\n\nfunction createNormalizer() {\n  return function (match, self) {\n    self.normalize(match);\n  };\n}\n\n// Schemas compiler. Build regexps.\n//\nfunction compile(self) {\n\n  // Load & clone RE patterns.\n  var re = self.re = __webpack_require__(/*! ./lib/re */ \"sRdV\")(self.__opts__);\n\n  // Define dynamic patterns\n  var tlds = self.__tlds__.slice();\n\n  self.onCompile();\n\n  if (!self.__tlds_replaced__) {\n    tlds.push(tlds_2ch_src_re);\n  }\n  tlds.push(re.src_xn);\n\n  re.src_tlds = tlds.join('|');\n\n  function untpl(tpl) { return tpl.replace('%TLDS%', re.src_tlds); }\n\n  re.email_fuzzy      = RegExp(untpl(re.tpl_email_fuzzy), 'i');\n  re.link_fuzzy       = RegExp(untpl(re.tpl_link_fuzzy), 'i');\n  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');\n  re.host_fuzzy_test  = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');\n\n  //\n  // Compile each schema\n  //\n\n  var aliases = [];\n\n  self.__compiled__ = {}; // Reset compiled data\n\n  function schemaError(name, val) {\n    throw new Error('(LinkifyIt) Invalid schema \"' + name + '\": ' + val);\n  }\n\n  Object.keys(self.__schemas__).forEach(function (name) {\n    var val = self.__schemas__[name];\n\n    // skip disabled methods\n    if (val === null) { return; }\n\n    var compiled = { validate: null, link: null };\n\n    self.__compiled__[name] = compiled;\n\n    if (isObject(val)) {\n      if (isRegExp(val.validate)) {\n        compiled.validate = createValidator(val.validate);\n      } else if (isFunction(val.validate)) {\n        compiled.validate = val.validate;\n      } else {\n        schemaError(name, val);\n      }\n\n      if (isFunction(val.normalize)) {\n        compiled.normalize = val.normalize;\n      } else if (!val.normalize) {\n        compiled.normalize = createNormalizer();\n      } else {\n        schemaError(name, val);\n      }\n\n      return;\n    }\n\n    if (isString(val)) {\n      aliases.push(name);\n      return;\n    }\n\n    schemaError(name, val);\n  });\n\n  //\n  // Compile postponed aliases\n  //\n\n  aliases.forEach(function (alias) {\n    if (!self.__compiled__[self.__schemas__[alias]]) {\n      // Silently fail on missed schemas to avoid errons on disable.\n      // schemaError(alias, self.__schemas__[alias]);\n      return;\n    }\n\n    self.__compiled__[alias].validate =\n      self.__compiled__[self.__schemas__[alias]].validate;\n    self.__compiled__[alias].normalize =\n      self.__compiled__[self.__schemas__[alias]].normalize;\n  });\n\n  //\n  // Fake record for guessed links\n  //\n  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };\n\n  //\n  // Build schema condition\n  //\n  var slist = Object.keys(self.__compiled__)\n                      .filter(function (name) {\n                        // Filter disabled & fake schemas\n                        return name.length > 0 && self.__compiled__[name];\n                      })\n                      .map(escapeRE)\n                      .join('|');\n  // (?!_) cause 1.5x slowdown\n  self.re.schema_test   = RegExp('(^|(?!_)(?:[><\\uff5c]|' + re.src_ZPCc + '))(' + slist + ')', 'i');\n  self.re.schema_search = RegExp('(^|(?!_)(?:[><\\uff5c]|' + re.src_ZPCc + '))(' + slist + ')', 'ig');\n\n  self.re.pretest = RegExp(\n    '(' + self.re.schema_test.source + ')|(' + self.re.host_fuzzy_test.source + ')|@',\n    'i'\n  );\n\n  //\n  // Cleanup\n  //\n\n  resetScanCache(self);\n}\n\n/**\n * class Match\n *\n * Match result. Single element of array, returned by [[LinkifyIt#match]]\n **/\nfunction Match(self, shift) {\n  var start = self.__index__,\n      end   = self.__last_index__,\n      text  = self.__text_cache__.slice(start, end);\n\n  /**\n   * Match#schema -> String\n   *\n   * Prefix (protocol) for matched string.\n   **/\n  this.schema    = self.__schema__.toLowerCase();\n  /**\n   * Match#index -> Number\n   *\n   * First position of matched string.\n   **/\n  this.index     = start + shift;\n  /**\n   * Match#lastIndex -> Number\n   *\n   * Next position after matched string.\n   **/\n  this.lastIndex = end + shift;\n  /**\n   * Match#raw -> String\n   *\n   * Matched string.\n   **/\n  this.raw       = text;\n  /**\n   * Match#text -> String\n   *\n   * Notmalized text of matched string.\n   **/\n  this.text      = text;\n  /**\n   * Match#url -> String\n   *\n   * Normalized url of matched string.\n   **/\n  this.url       = text;\n}\n\nfunction createMatch(self, shift) {\n  var match = new Match(self, shift);\n\n  self.__compiled__[match.schema].normalize(match, self);\n\n  return match;\n}\n\n\n/**\n * class LinkifyIt\n **/\n\n/**\n * new LinkifyIt(schemas, options)\n * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)\n * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }\n *\n * Creates new linkifier instance with optional additional schemas.\n * Can be called without `new` keyword for convenience.\n *\n * By default understands:\n *\n * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links\n * - \"fuzzy\" links and emails (example.com, foo@bar.com).\n *\n * `schemas` is an object, where each key/value describes protocol/rule:\n *\n * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`\n *   for example). `linkify-it` makes shure that prefix is not preceeded with\n *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.\n * - __value__ - rule to check tail after link prefix\n *   - _String_ - just alias to existing rule\n *   - _Object_\n *     - _validate_ - validator function (should return matched length on success),\n *       or `RegExp`.\n *     - _normalize_ - optional function to normalize text & url of matched result\n *       (for example, for @twitter mentions).\n *\n * `options`:\n *\n * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.\n * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts\n *   like version numbers. Default `false`.\n * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.\n *\n **/\nfunction LinkifyIt(schemas, options) {\n  if (!(this instanceof LinkifyIt)) {\n    return new LinkifyIt(schemas, options);\n  }\n\n  if (!options) {\n    if (isOptionsObj(schemas)) {\n      options = schemas;\n      schemas = {};\n    }\n  }\n\n  this.__opts__           = assign({}, defaultOptions, options);\n\n  // Cache last tested result. Used to skip repeating steps on next `match` call.\n  this.__index__          = -1;\n  this.__last_index__     = -1; // Next scan position\n  this.__schema__         = '';\n  this.__text_cache__     = '';\n\n  this.__schemas__        = assign({}, defaultSchemas, schemas);\n  this.__compiled__       = {};\n\n  this.__tlds__           = tlds_default;\n  this.__tlds_replaced__  = false;\n\n  this.re = {};\n\n  compile(this);\n}\n\n\n/** chainable\n * LinkifyIt#add(schema, definition)\n * - schema (String): rule name (fixed pattern prefix)\n * - definition (String|RegExp|Object): schema definition\n *\n * Add new rule definition. See constructor description for details.\n **/\nLinkifyIt.prototype.add = function add(schema, definition) {\n  this.__schemas__[schema] = definition;\n  compile(this);\n  return this;\n};\n\n\n/** chainable\n * LinkifyIt#set(options)\n * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }\n *\n * Set recognition options for links without schema.\n **/\nLinkifyIt.prototype.set = function set(options) {\n  this.__opts__ = assign(this.__opts__, options);\n  return this;\n};\n\n\n/**\n * LinkifyIt#test(text) -> Boolean\n *\n * Searches linkifiable pattern and returns `true` on success or `false` on fail.\n **/\nLinkifyIt.prototype.test = function test(text) {\n  // Reset scan cache\n  this.__text_cache__ = text;\n  this.__index__      = -1;\n\n  if (!text.length) { return false; }\n\n  var m, ml, me, len, shift, next, re, tld_pos, at_pos;\n\n  // try to scan for link with schema - that's the most simple rule\n  if (this.re.schema_test.test(text)) {\n    re = this.re.schema_search;\n    re.lastIndex = 0;\n    while ((m = re.exec(text)) !== null) {\n      len = this.testSchemaAt(text, m[2], re.lastIndex);\n      if (len) {\n        this.__schema__     = m[2];\n        this.__index__      = m.index + m[1].length;\n        this.__last_index__ = m.index + m[0].length + len;\n        break;\n      }\n    }\n  }\n\n  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {\n    // guess schemaless links\n    tld_pos = text.search(this.re.host_fuzzy_test);\n    if (tld_pos >= 0) {\n      // if tld is located after found link - no need to check fuzzy pattern\n      if (this.__index__ < 0 || tld_pos < this.__index__) {\n        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {\n\n          shift = ml.index + ml[1].length;\n\n          if (this.__index__ < 0 || shift < this.__index__) {\n            this.__schema__     = '';\n            this.__index__      = shift;\n            this.__last_index__ = ml.index + ml[0].length;\n          }\n        }\n      }\n    }\n  }\n\n  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {\n    // guess schemaless emails\n    at_pos = text.indexOf('@');\n    if (at_pos >= 0) {\n      // We can't skip this check, because this cases are possible:\n      // 192.168.1.1@gmail.com, my.in@example.com\n      if ((me = text.match(this.re.email_fuzzy)) !== null) {\n\n        shift = me.index + me[1].length;\n        next  = me.index + me[0].length;\n\n        if (this.__index__ < 0 || shift < this.__index__ ||\n            (shift === this.__index__ && next > this.__last_index__)) {\n          this.__schema__     = 'mailto:';\n          this.__index__      = shift;\n          this.__last_index__ = next;\n        }\n      }\n    }\n  }\n\n  return this.__index__ >= 0;\n};\n\n\n/**\n * LinkifyIt#pretest(text) -> Boolean\n *\n * Very quick check, that can give false positives. Returns true if link MAY BE\n * can exists. Can be used for speed optimization, when you need to check that\n * link NOT exists.\n **/\nLinkifyIt.prototype.pretest = function pretest(text) {\n  return this.re.pretest.test(text);\n};\n\n\n/**\n * LinkifyIt#testSchemaAt(text, name, position) -> Number\n * - text (String): text to scan\n * - name (String): rule (schema) name\n * - position (Number): text offset to check from\n *\n * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly\n * at given position. Returns length of found pattern (0 on fail).\n **/\nLinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {\n  // If not supported schema check requested - terminate\n  if (!this.__compiled__[schema.toLowerCase()]) {\n    return 0;\n  }\n  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);\n};\n\n\n/**\n * LinkifyIt#match(text) -> Array|null\n *\n * Returns array of found link descriptions or `null` on fail. We strongly\n * recommend to use [[LinkifyIt#test]] first, for best speed.\n *\n * ##### Result match description\n *\n * - __schema__ - link schema, can be empty for fuzzy links, or `//` for\n *   protocol-neutral  links.\n * - __index__ - offset of matched text\n * - __lastIndex__ - index of next char after mathch end\n * - __raw__ - matched text\n * - __text__ - normalized text\n * - __url__ - link, generated from matched text\n **/\nLinkifyIt.prototype.match = function match(text) {\n  var shift = 0, result = [];\n\n  // Try to take previous element from cache, if .test() called before\n  if (this.__index__ >= 0 && this.__text_cache__ === text) {\n    result.push(createMatch(this, shift));\n    shift = this.__last_index__;\n  }\n\n  // Cut head if cache was used\n  var tail = shift ? text.slice(shift) : text;\n\n  // Scan string until end reached\n  while (this.test(tail)) {\n    result.push(createMatch(this, shift));\n\n    tail = tail.slice(this.__last_index__);\n    shift += this.__last_index__;\n  }\n\n  if (result.length) {\n    return result;\n  }\n\n  return null;\n};\n\n\n/** chainable\n * LinkifyIt#tlds(list [, keepOld]) -> this\n * - list (Array): list of tlds\n * - keepOld (Boolean): merge with current list if `true` (`false` by default)\n *\n * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)\n * to avoid false positives. By default this algorythm used:\n *\n * - hostname with any 2-letter root zones are ok.\n * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф\n *   are ok.\n * - encoded (`xn--...`) root zones are ok.\n *\n * If list is replaced, then exact match for 2-chars root zones will be checked.\n **/\nLinkifyIt.prototype.tlds = function tlds(list, keepOld) {\n  list = Array.isArray(list) ? list : [ list ];\n\n  if (!keepOld) {\n    this.__tlds__ = list.slice();\n    this.__tlds_replaced__ = true;\n    compile(this);\n    return this;\n  }\n\n  this.__tlds__ = this.__tlds__.concat(list)\n                                  .sort()\n                                  .filter(function (el, idx, arr) {\n                                    return el !== arr[idx - 1];\n                                  })\n                                  .reverse();\n\n  compile(this);\n  return this;\n};\n\n/**\n * LinkifyIt#normalize(match)\n *\n * Default normalizer (if schema does not define it's own).\n **/\nLinkifyIt.prototype.normalize = function normalize(match) {\n\n  // Do minimal possible changes by default. Need to collect feedback prior\n  // to move forward https://github.com/markdown-it/linkify-it/issues/1\n\n  if (!match.schema) { match.url = 'http://' + match.url; }\n\n  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {\n    match.url = 'mailto:' + match.url;\n  }\n};\n\n\n/**\n * LinkifyIt#onCompile()\n *\n * Override to modify basic RegExp-s.\n **/\nLinkifyIt.prototype.onCompile = function onCompile() {\n};\n\n\nmodule.exports = LinkifyIt;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKzgwUC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saW5raWZ5LWl0L2luZGV4LmpzP2ZiY2QiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIZWxwZXJzXG5cbi8vIE1lcmdlIG9iamVjdHNcbi8vXG5mdW5jdGlvbiBhc3NpZ24ob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgaWYgKCFzb3VyY2UpIHsgcmV0dXJuOyB9XG5cbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX2NsYXNzKG9iaikgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7IH1cbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nOyB9XG5mdW5jdGlvbiBpc09iamVjdChvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBPYmplY3RdJzsgfVxuZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7IH1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJzsgfVxuXG5cbmZ1bmN0aW9uIGVzY2FwZVJFKHN0cikgeyByZXR1cm4gc3RyLnJlcGxhY2UoL1suPyorXiRbXFxdXFxcXCgpe318LV0vZywgJ1xcXFwkJicpOyB9XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBmdXp6eUxpbms6IHRydWUsXG4gIGZ1enp5RW1haWw6IHRydWUsXG4gIGZ1enp5SVA6IGZhbHNlXG59O1xuXG5cbmZ1bmN0aW9uIGlzT3B0aW9uc09iaihvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaiB8fCB7fSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGspIHtcbiAgICByZXR1cm4gYWNjIHx8IGRlZmF1bHRPcHRpb25zLmhhc093blByb3BlcnR5KGspO1xuICB9LCBmYWxzZSk7XG59XG5cblxudmFyIGRlZmF1bHRTY2hlbWFzID0ge1xuICAnaHR0cDonOiB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh0ZXh0LCBwb3MsIHNlbGYpIHtcbiAgICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgICBpZiAoIXNlbGYucmUuaHR0cCkge1xuICAgICAgICAvLyBjb21waWxlIGxhemlseSwgYmVjYXVzZSBcImhvc3RcIi1jb250YWluaW5nIHZhcmlhYmxlcyBjYW4gY2hhbmdlIG9uIHRsZHMgdXBkYXRlLlxuICAgICAgICBzZWxmLnJlLmh0dHAgPSAgbmV3IFJlZ0V4cChcbiAgICAgICAgICAnXlxcXFwvXFxcXC8nICsgc2VsZi5yZS5zcmNfYXV0aCArIHNlbGYucmUuc3JjX2hvc3RfcG9ydF9zdHJpY3QgKyBzZWxmLnJlLnNyY19wYXRoLCAnaSdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLnJlLmh0dHAudGVzdCh0YWlsKSkge1xuICAgICAgICByZXR1cm4gdGFpbC5tYXRjaChzZWxmLnJlLmh0dHApWzBdLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSxcbiAgJ2h0dHBzOic6ICAnaHR0cDonLFxuICAnZnRwOic6ICAgICdodHRwOicsXG4gICcvLyc6ICAgICAge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodGV4dCwgcG9zLCBzZWxmKSB7XG4gICAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgICAgaWYgKCFzZWxmLnJlLm5vX2h0dHApIHtcbiAgICAgIC8vIGNvbXBpbGUgbGF6aWx5LCBiZWNhdXNlIFwiaG9zdFwiLWNvbnRhaW5pbmcgdmFyaWFibGVzIGNhbiBjaGFuZ2Ugb24gdGxkcyB1cGRhdGUuXG4gICAgICAgIHNlbGYucmUubm9faHR0cCA9ICBuZXcgUmVnRXhwKFxuICAgICAgICAgICdeJyArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfYXV0aCArXG4gICAgICAgICAgLy8gRG9uJ3QgYWxsb3cgc2luZ2xlLWxldmVsIGRvbWFpbnMsIGJlY2F1c2Ugb2YgZmFsc2UgcG9zaXRpdmVzIGxpa2UgJy8vdGVzdCdcbiAgICAgICAgICAvLyB3aXRoIGNvZGUgY29tbWVudHNcbiAgICAgICAgICAnKD86bG9jYWxob3N0fCg/Oig/OicgKyBzZWxmLnJlLnNyY19kb21haW4gKyAnKVxcXFwuKSsnICsgc2VsZi5yZS5zcmNfZG9tYWluX3Jvb3QgKyAnKScgK1xuICAgICAgICAgIHNlbGYucmUuc3JjX3BvcnQgK1xuICAgICAgICAgIHNlbGYucmUuc3JjX2hvc3RfdGVybWluYXRvciArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfcGF0aCxcblxuICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5yZS5ub19odHRwLnRlc3QodGFpbCkpIHtcbiAgICAgICAgLy8gc2hvdWxkIG5vdCBiZSBgOi8vYCAmIGAvLy9gLCB0aGF0IHByb3RlY3RzIGZyb20gZXJyb3JzIGluIHByb3RvY29sIG5hbWVcbiAgICAgICAgaWYgKHBvcyA+PSAzICYmIHRleHRbcG9zIC0gM10gPT09ICc6JykgeyByZXR1cm4gMDsgfVxuICAgICAgICBpZiAocG9zID49IDMgJiYgdGV4dFtwb3MgLSAzXSA9PT0gJy8nKSB7IHJldHVybiAwOyB9XG4gICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUubm9faHR0cClbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LFxuICAnbWFpbHRvOic6IHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHRleHQsIHBvcywgc2VsZikge1xuICAgICAgdmFyIHRhaWwgPSB0ZXh0LnNsaWNlKHBvcyk7XG5cbiAgICAgIGlmICghc2VsZi5yZS5tYWlsdG8pIHtcbiAgICAgICAgc2VsZi5yZS5tYWlsdG8gPSAgbmV3IFJlZ0V4cChcbiAgICAgICAgICAnXicgKyBzZWxmLnJlLnNyY19lbWFpbF9uYW1lICsgJ0AnICsgc2VsZi5yZS5zcmNfaG9zdF9zdHJpY3QsICdpJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYucmUubWFpbHRvLnRlc3QodGFpbCkpIHtcbiAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5tYWlsdG8pWzBdLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxufTtcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuKi9cblxuLy8gUkUgcGF0dGVybiBmb3IgMi1jaGFyYWN0ZXIgdGxkcyAoYXV0b2dlbmVyYXRlZCBieSAuL3N1cHBvcnQvdGxkc18yY2hhcl9nZW4uanMpXG52YXIgdGxkc18yY2hfc3JjX3JlID0gJ2FbY2RlZmdpbG1ub3Fyc3R1d3h6XXxiW2FiZGVmZ2hpam1ub3JzdHZ3eXpdfGNbYWNkZmdoaWtsbW5vcnV2d3h5el18ZFtlamttb3pdfGVbY2VncnN0dV18Zltpamttb3JdfGdbYWJkZWZnaGlsbW5wcXJzdHV3eV18aFtrbW5ydHVdfGlbZGVsbW5vcXJzdF18altlbW9wXXxrW2VnaGltbnByd3l6XXxsW2FiY2lrcnN0dXZ5XXxtW2FjZGVnaGtsbW5vcHFyc3R1dnd4eXpdfG5bYWNlZmdpbG9wcnV6XXxvbXxwW2FlZmdoa2xtbnJzdHd5XXxxYXxyW2Vvc3V3XXxzW2FiY2RlZ2hpamtsbW5vcnR1dnh5el18dFtjZGZnaGprbG1ub3J0dnd6XXx1W2Fna3N5el18dlthY2VnaW51XXx3W2ZzXXx5W2V0XXx6W2Ftd10nO1xuXG4vLyBET04nVCB0cnkgdG8gbWFrZSBQUnMgd2l0aCBjaGFuZ2VzLiBFeHRlbmQgVExEcyB3aXRoIExpbmtpZnlJdC50bGRzKCkgaW5zdGVhZFxudmFyIHRsZHNfZGVmYXVsdCA9ICdiaXp8Y29tfGVkdXxnb3Z8bmV0fG9yZ3xwcm98d2VifHh4eHxhZXJvfGFzaWF8Y29vcHxpbmZvfG11c2V1bXxuYW1lfHNob3B80YDRhCcuc3BsaXQoJ3wnKTtcblxuLyplc2xpbnQtZW5hYmxlIG1heC1sZW4qL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiByZXNldFNjYW5DYWNoZShzZWxmKSB7XG4gIHNlbGYuX19pbmRleF9fID0gLTE7XG4gIHNlbGYuX190ZXh0X2NhY2hlX18gICA9ICcnO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVWYWxpZGF0b3IocmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0ZXh0LCBwb3MpIHtcbiAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgIGlmIChyZS50ZXN0KHRhaWwpKSB7XG4gICAgICByZXR1cm4gdGFpbC5tYXRjaChyZSlbMF0ubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9ybWFsaXplcigpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChtYXRjaCwgc2VsZikge1xuICAgIHNlbGYubm9ybWFsaXplKG1hdGNoKTtcbiAgfTtcbn1cblxuLy8gU2NoZW1hcyBjb21waWxlci4gQnVpbGQgcmVnZXhwcy5cbi8vXG5mdW5jdGlvbiBjb21waWxlKHNlbGYpIHtcblxuICAvLyBMb2FkICYgY2xvbmUgUkUgcGF0dGVybnMuXG4gIHZhciByZSA9IHNlbGYucmUgPSByZXF1aXJlKCcuL2xpYi9yZScpKHNlbGYuX19vcHRzX18pO1xuXG4gIC8vIERlZmluZSBkeW5hbWljIHBhdHRlcm5zXG4gIHZhciB0bGRzID0gc2VsZi5fX3RsZHNfXy5zbGljZSgpO1xuXG4gIHNlbGYub25Db21waWxlKCk7XG5cbiAgaWYgKCFzZWxmLl9fdGxkc19yZXBsYWNlZF9fKSB7XG4gICAgdGxkcy5wdXNoKHRsZHNfMmNoX3NyY19yZSk7XG4gIH1cbiAgdGxkcy5wdXNoKHJlLnNyY194bik7XG5cbiAgcmUuc3JjX3RsZHMgPSB0bGRzLmpvaW4oJ3wnKTtcblxuICBmdW5jdGlvbiB1bnRwbCh0cGwpIHsgcmV0dXJuIHRwbC5yZXBsYWNlKCclVExEUyUnLCByZS5zcmNfdGxkcyk7IH1cblxuICByZS5lbWFpbF9mdXp6eSAgICAgID0gUmVnRXhwKHVudHBsKHJlLnRwbF9lbWFpbF9mdXp6eSksICdpJyk7XG4gIHJlLmxpbmtfZnV6enkgICAgICAgPSBSZWdFeHAodW50cGwocmUudHBsX2xpbmtfZnV6enkpLCAnaScpO1xuICByZS5saW5rX25vX2lwX2Z1enp5ID0gUmVnRXhwKHVudHBsKHJlLnRwbF9saW5rX25vX2lwX2Z1enp5KSwgJ2knKTtcbiAgcmUuaG9zdF9mdXp6eV90ZXN0ICA9IFJlZ0V4cCh1bnRwbChyZS50cGxfaG9zdF9mdXp6eV90ZXN0KSwgJ2knKTtcblxuICAvL1xuICAvLyBDb21waWxlIGVhY2ggc2NoZW1hXG4gIC8vXG5cbiAgdmFyIGFsaWFzZXMgPSBbXTtcblxuICBzZWxmLl9fY29tcGlsZWRfXyA9IHt9OyAvLyBSZXNldCBjb21waWxlZCBkYXRhXG5cbiAgZnVuY3Rpb24gc2NoZW1hRXJyb3IobmFtZSwgdmFsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcoTGlua2lmeUl0KSBJbnZhbGlkIHNjaGVtYSBcIicgKyBuYW1lICsgJ1wiOiAnICsgdmFsKTtcbiAgfVxuXG4gIE9iamVjdC5rZXlzKHNlbGYuX19zY2hlbWFzX18pLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgdmFsID0gc2VsZi5fX3NjaGVtYXNfX1tuYW1lXTtcblxuICAgIC8vIHNraXAgZGlzYWJsZWQgbWV0aG9kc1xuICAgIGlmICh2YWwgPT09IG51bGwpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgY29tcGlsZWQgPSB7IHZhbGlkYXRlOiBudWxsLCBsaW5rOiBudWxsIH07XG5cbiAgICBzZWxmLl9fY29tcGlsZWRfX1tuYW1lXSA9IGNvbXBpbGVkO1xuXG4gICAgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWwudmFsaWRhdGUpKSB7XG4gICAgICAgIGNvbXBpbGVkLnZhbGlkYXRlID0gY3JlYXRlVmFsaWRhdG9yKHZhbC52YWxpZGF0ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsLnZhbGlkYXRlKSkge1xuICAgICAgICBjb21waWxlZC52YWxpZGF0ZSA9IHZhbC52YWxpZGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbC5ub3JtYWxpemUpKSB7XG4gICAgICAgIGNvbXBpbGVkLm5vcm1hbGl6ZSA9IHZhbC5ub3JtYWxpemU7XG4gICAgICB9IGVsc2UgaWYgKCF2YWwubm9ybWFsaXplKSB7XG4gICAgICAgIGNvbXBpbGVkLm5vcm1hbGl6ZSA9IGNyZWF0ZU5vcm1hbGl6ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNTdHJpbmcodmFsKSkge1xuICAgICAgYWxpYXNlcy5wdXNoKG5hbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XG4gIH0pO1xuXG4gIC8vXG4gIC8vIENvbXBpbGUgcG9zdHBvbmVkIGFsaWFzZXNcbiAgLy9cblxuICBhbGlhc2VzLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgaWYgKCFzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0pIHtcbiAgICAgIC8vIFNpbGVudGx5IGZhaWwgb24gbWlzc2VkIHNjaGVtYXMgdG8gYXZvaWQgZXJyb25zIG9uIGRpc2FibGUuXG4gICAgICAvLyBzY2hlbWFFcnJvcihhbGlhcywgc2VsZi5fX3NjaGVtYXNfX1thbGlhc10pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNlbGYuX19jb21waWxlZF9fW2FsaWFzXS52YWxpZGF0ZSA9XG4gICAgICBzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0udmFsaWRhdGU7XG4gICAgc2VsZi5fX2NvbXBpbGVkX19bYWxpYXNdLm5vcm1hbGl6ZSA9XG4gICAgICBzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0ubm9ybWFsaXplO1xuICB9KTtcblxuICAvL1xuICAvLyBGYWtlIHJlY29yZCBmb3IgZ3Vlc3NlZCBsaW5rc1xuICAvL1xuICBzZWxmLl9fY29tcGlsZWRfX1snJ10gPSB7IHZhbGlkYXRlOiBudWxsLCBub3JtYWxpemU6IGNyZWF0ZU5vcm1hbGl6ZXIoKSB9O1xuXG4gIC8vXG4gIC8vIEJ1aWxkIHNjaGVtYSBjb25kaXRpb25cbiAgLy9cbiAgdmFyIHNsaXN0ID0gT2JqZWN0LmtleXMoc2VsZi5fX2NvbXBpbGVkX18pXG4gICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIGRpc2FibGVkICYgZmFrZSBzY2hlbWFzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZS5sZW5ndGggPiAwICYmIHNlbGYuX19jb21waWxlZF9fW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgLm1hcChlc2NhcGVSRSlcbiAgICAgICAgICAgICAgICAgICAgICAuam9pbignfCcpO1xuICAvLyAoPyFfKSBjYXVzZSAxLjV4IHNsb3dkb3duXG4gIHNlbGYucmUuc2NoZW1hX3Rlc3QgICA9IFJlZ0V4cCgnKF58KD8hXykoPzpbPjxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSkoJyArIHNsaXN0ICsgJyknLCAnaScpO1xuICBzZWxmLnJlLnNjaGVtYV9zZWFyY2ggPSBSZWdFeHAoJyhefCg/IV8pKD86Wz48XFx1ZmY1Y118JyArIHJlLnNyY19aUENjICsgJykpKCcgKyBzbGlzdCArICcpJywgJ2lnJyk7XG5cbiAgc2VsZi5yZS5wcmV0ZXN0ID0gUmVnRXhwKFxuICAgICcoJyArIHNlbGYucmUuc2NoZW1hX3Rlc3Quc291cmNlICsgJyl8KCcgKyBzZWxmLnJlLmhvc3RfZnV6enlfdGVzdC5zb3VyY2UgKyAnKXxAJyxcbiAgICAnaSdcbiAgKTtcblxuICAvL1xuICAvLyBDbGVhbnVwXG4gIC8vXG5cbiAgcmVzZXRTY2FuQ2FjaGUoc2VsZik7XG59XG5cbi8qKlxuICogY2xhc3MgTWF0Y2hcbiAqXG4gKiBNYXRjaCByZXN1bHQuIFNpbmdsZSBlbGVtZW50IG9mIGFycmF5LCByZXR1cm5lZCBieSBbW0xpbmtpZnlJdCNtYXRjaF1dXG4gKiovXG5mdW5jdGlvbiBNYXRjaChzZWxmLCBzaGlmdCkge1xuICB2YXIgc3RhcnQgPSBzZWxmLl9faW5kZXhfXyxcbiAgICAgIGVuZCAgID0gc2VsZi5fX2xhc3RfaW5kZXhfXyxcbiAgICAgIHRleHQgID0gc2VsZi5fX3RleHRfY2FjaGVfXy5zbGljZShzdGFydCwgZW5kKTtcblxuICAvKipcbiAgICogTWF0Y2gjc2NoZW1hIC0+IFN0cmluZ1xuICAgKlxuICAgKiBQcmVmaXggKHByb3RvY29sKSBmb3IgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5zY2hlbWEgICAgPSBzZWxmLl9fc2NoZW1hX18udG9Mb3dlckNhc2UoKTtcbiAgLyoqXG4gICAqIE1hdGNoI2luZGV4IC0+IE51bWJlclxuICAgKlxuICAgKiBGaXJzdCBwb3NpdGlvbiBvZiBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLmluZGV4ICAgICA9IHN0YXJ0ICsgc2hpZnQ7XG4gIC8qKlxuICAgKiBNYXRjaCNsYXN0SW5kZXggLT4gTnVtYmVyXG4gICAqXG4gICAqIE5leHQgcG9zaXRpb24gYWZ0ZXIgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5sYXN0SW5kZXggPSBlbmQgKyBzaGlmdDtcbiAgLyoqXG4gICAqIE1hdGNoI3JhdyAtPiBTdHJpbmdcbiAgICpcbiAgICogTWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5yYXcgICAgICAgPSB0ZXh0O1xuICAvKipcbiAgICogTWF0Y2gjdGV4dCAtPiBTdHJpbmdcbiAgICpcbiAgICogTm90bWFsaXplZCB0ZXh0IG9mIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMudGV4dCAgICAgID0gdGV4dDtcbiAgLyoqXG4gICAqIE1hdGNoI3VybCAtPiBTdHJpbmdcbiAgICpcbiAgICogTm9ybWFsaXplZCB1cmwgb2YgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy51cmwgICAgICAgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXRjaChzZWxmLCBzaGlmdCkge1xuICB2YXIgbWF0Y2ggPSBuZXcgTWF0Y2goc2VsZiwgc2hpZnQpO1xuXG4gIHNlbGYuX19jb21waWxlZF9fW21hdGNoLnNjaGVtYV0ubm9ybWFsaXplKG1hdGNoLCBzZWxmKTtcblxuICByZXR1cm4gbWF0Y2g7XG59XG5cblxuLyoqXG4gKiBjbGFzcyBMaW5raWZ5SXRcbiAqKi9cblxuLyoqXG4gKiBuZXcgTGlua2lmeUl0KHNjaGVtYXMsIG9wdGlvbnMpXG4gKiAtIHNjaGVtYXMgKE9iamVjdCk6IE9wdGlvbmFsLiBBZGRpdGlvbmFsIHNjaGVtYXMgdG8gdmFsaWRhdGUgKHByZWZpeC92YWxpZGF0b3IpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHsgZnV6enlMaW5rfGZ1enp5RW1haWx8ZnV6enlJUDogdHJ1ZXxmYWxzZSB9XG4gKlxuICogQ3JlYXRlcyBuZXcgbGlua2lmaWVyIGluc3RhbmNlIHdpdGggb3B0aW9uYWwgYWRkaXRpb25hbCBzY2hlbWFzLlxuICogQ2FuIGJlIGNhbGxlZCB3aXRob3V0IGBuZXdgIGtleXdvcmQgZm9yIGNvbnZlbmllbmNlLlxuICpcbiAqIEJ5IGRlZmF1bHQgdW5kZXJzdGFuZHM6XG4gKlxuICogLSBgaHR0cChzKTovLy4uLmAgLCBgZnRwOi8vLi4uYCwgYG1haWx0bzouLi5gICYgYC8vLi4uYCBsaW5rc1xuICogLSBcImZ1enp5XCIgbGlua3MgYW5kIGVtYWlscyAoZXhhbXBsZS5jb20sIGZvb0BiYXIuY29tKS5cbiAqXG4gKiBgc2NoZW1hc2AgaXMgYW4gb2JqZWN0LCB3aGVyZSBlYWNoIGtleS92YWx1ZSBkZXNjcmliZXMgcHJvdG9jb2wvcnVsZTpcbiAqXG4gKiAtIF9fa2V5X18gLSBsaW5rIHByZWZpeCAodXN1YWxseSwgcHJvdG9jb2wgbmFtZSB3aXRoIGA6YCBhdCB0aGUgZW5kLCBgc2t5cGU6YFxuICogICBmb3IgZXhhbXBsZSkuIGBsaW5raWZ5LWl0YCBtYWtlcyBzaHVyZSB0aGF0IHByZWZpeCBpcyBub3QgcHJlY2VlZGVkIHdpdGhcbiAqICAgYWxwaGFudW1lcmljIGNoYXIgYW5kIHN5bWJvbHMuIE9ubHkgd2hpdGVzcGFjZXMgYW5kIHB1bmN0dWF0aW9uIGFsbG93ZWQuXG4gKiAtIF9fdmFsdWVfXyAtIHJ1bGUgdG8gY2hlY2sgdGFpbCBhZnRlciBsaW5rIHByZWZpeFxuICogICAtIF9TdHJpbmdfIC0ganVzdCBhbGlhcyB0byBleGlzdGluZyBydWxlXG4gKiAgIC0gX09iamVjdF9cbiAqICAgICAtIF92YWxpZGF0ZV8gLSB2YWxpZGF0b3IgZnVuY3Rpb24gKHNob3VsZCByZXR1cm4gbWF0Y2hlZCBsZW5ndGggb24gc3VjY2VzcyksXG4gKiAgICAgICBvciBgUmVnRXhwYC5cbiAqICAgICAtIF9ub3JtYWxpemVfIC0gb3B0aW9uYWwgZnVuY3Rpb24gdG8gbm9ybWFsaXplIHRleHQgJiB1cmwgb2YgbWF0Y2hlZCByZXN1bHRcbiAqICAgICAgIChmb3IgZXhhbXBsZSwgZm9yIEB0d2l0dGVyIG1lbnRpb25zKS5cbiAqXG4gKiBgb3B0aW9uc2A6XG4gKlxuICogLSBfX2Z1enp5TGlua19fIC0gcmVjb2duaWdlIFVSTC1zIHdpdGhvdXQgYGh0dHAocyk6YCBwcmVmaXguIERlZmF1bHQgYHRydWVgLlxuICogLSBfX2Z1enp5SVBfXyAtIGFsbG93IElQcyBpbiBmdXp6eSBsaW5rcyBhYm92ZS4gQ2FuIGNvbmZsaWN0IHdpdGggc29tZSB0ZXh0c1xuICogICBsaWtlIHZlcnNpb24gbnVtYmVycy4gRGVmYXVsdCBgZmFsc2VgLlxuICogLSBfX2Z1enp5RW1haWxfXyAtIHJlY29nbml6ZSBlbWFpbHMgd2l0aG91dCBgbWFpbHRvOmAgcHJlZml4LlxuICpcbiAqKi9cbmZ1bmN0aW9uIExpbmtpZnlJdChzY2hlbWFzLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMaW5raWZ5SXQpKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5raWZ5SXQoc2NoZW1hcywgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAoaXNPcHRpb25zT2JqKHNjaGVtYXMpKSB7XG4gICAgICBvcHRpb25zID0gc2NoZW1hcztcbiAgICAgIHNjaGVtYXMgPSB7fTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9fb3B0c19fICAgICAgICAgICA9IGFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gIC8vIENhY2hlIGxhc3QgdGVzdGVkIHJlc3VsdC4gVXNlZCB0byBza2lwIHJlcGVhdGluZyBzdGVwcyBvbiBuZXh0IGBtYXRjaGAgY2FsbC5cbiAgdGhpcy5fX2luZGV4X18gICAgICAgICAgPSAtMTtcbiAgdGhpcy5fX2xhc3RfaW5kZXhfXyAgICAgPSAtMTsgLy8gTmV4dCBzY2FuIHBvc2l0aW9uXG4gIHRoaXMuX19zY2hlbWFfXyAgICAgICAgID0gJyc7XG4gIHRoaXMuX190ZXh0X2NhY2hlX18gICAgID0gJyc7XG5cbiAgdGhpcy5fX3NjaGVtYXNfXyAgICAgICAgPSBhc3NpZ24oe30sIGRlZmF1bHRTY2hlbWFzLCBzY2hlbWFzKTtcbiAgdGhpcy5fX2NvbXBpbGVkX18gICAgICAgPSB7fTtcblxuICB0aGlzLl9fdGxkc19fICAgICAgICAgICA9IHRsZHNfZGVmYXVsdDtcbiAgdGhpcy5fX3RsZHNfcmVwbGFjZWRfXyAgPSBmYWxzZTtcblxuICB0aGlzLnJlID0ge307XG5cbiAgY29tcGlsZSh0aGlzKTtcbn1cblxuXG4vKiogY2hhaW5hYmxlXG4gKiBMaW5raWZ5SXQjYWRkKHNjaGVtYSwgZGVmaW5pdGlvbilcbiAqIC0gc2NoZW1hIChTdHJpbmcpOiBydWxlIG5hbWUgKGZpeGVkIHBhdHRlcm4gcHJlZml4KVxuICogLSBkZWZpbml0aW9uIChTdHJpbmd8UmVnRXhwfE9iamVjdCk6IHNjaGVtYSBkZWZpbml0aW9uXG4gKlxuICogQWRkIG5ldyBydWxlIGRlZmluaXRpb24uIFNlZSBjb25zdHJ1Y3RvciBkZXNjcmlwdGlvbiBmb3IgZGV0YWlscy5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHNjaGVtYSwgZGVmaW5pdGlvbikge1xuICB0aGlzLl9fc2NoZW1hc19fW3NjaGVtYV0gPSBkZWZpbml0aW9uO1xuICBjb21waWxlKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTGlua2lmeUl0I3NldChvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB7IGZ1enp5TGlua3xmdXp6eUVtYWlsfGZ1enp5SVA6IHRydWV8ZmFsc2UgfVxuICpcbiAqIFNldCByZWNvZ25pdGlvbiBvcHRpb25zIGZvciBsaW5rcyB3aXRob3V0IHNjaGVtYS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcbiAgdGhpcy5fX29wdHNfXyA9IGFzc2lnbih0aGlzLl9fb3B0c19fLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I3Rlc3QodGV4dCkgLT4gQm9vbGVhblxuICpcbiAqIFNlYXJjaGVzIGxpbmtpZmlhYmxlIHBhdHRlcm4gYW5kIHJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3Mgb3IgYGZhbHNlYCBvbiBmYWlsLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gdGVzdCh0ZXh0KSB7XG4gIC8vIFJlc2V0IHNjYW4gY2FjaGVcbiAgdGhpcy5fX3RleHRfY2FjaGVfXyA9IHRleHQ7XG4gIHRoaXMuX19pbmRleF9fICAgICAgPSAtMTtcblxuICBpZiAoIXRleHQubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHZhciBtLCBtbCwgbWUsIGxlbiwgc2hpZnQsIG5leHQsIHJlLCB0bGRfcG9zLCBhdF9wb3M7XG5cbiAgLy8gdHJ5IHRvIHNjYW4gZm9yIGxpbmsgd2l0aCBzY2hlbWEgLSB0aGF0J3MgdGhlIG1vc3Qgc2ltcGxlIHJ1bGVcbiAgaWYgKHRoaXMucmUuc2NoZW1hX3Rlc3QudGVzdCh0ZXh0KSkge1xuICAgIHJlID0gdGhpcy5yZS5zY2hlbWFfc2VhcmNoO1xuICAgIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChtID0gcmUuZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcbiAgICAgIGxlbiA9IHRoaXMudGVzdFNjaGVtYUF0KHRleHQsIG1bMl0sIHJlLmxhc3RJbmRleCk7XG4gICAgICBpZiAobGVuKSB7XG4gICAgICAgIHRoaXMuX19zY2hlbWFfXyAgICAgPSBtWzJdO1xuICAgICAgICB0aGlzLl9faW5kZXhfXyAgICAgID0gbS5pbmRleCArIG1bMV0ubGVuZ3RoO1xuICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbS5pbmRleCArIG1bMF0ubGVuZ3RoICsgbGVuO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5fX29wdHNfXy5mdXp6eUxpbmsgJiYgdGhpcy5fX2NvbXBpbGVkX19bJ2h0dHA6J10pIHtcbiAgICAvLyBndWVzcyBzY2hlbWFsZXNzIGxpbmtzXG4gICAgdGxkX3BvcyA9IHRleHQuc2VhcmNoKHRoaXMucmUuaG9zdF9mdXp6eV90ZXN0KTtcbiAgICBpZiAodGxkX3BvcyA+PSAwKSB7XG4gICAgICAvLyBpZiB0bGQgaXMgbG9jYXRlZCBhZnRlciBmb3VuZCBsaW5rIC0gbm8gbmVlZCB0byBjaGVjayBmdXp6eSBwYXR0ZXJuXG4gICAgICBpZiAodGhpcy5fX2luZGV4X18gPCAwIHx8IHRsZF9wb3MgPCB0aGlzLl9faW5kZXhfXykge1xuICAgICAgICBpZiAoKG1sID0gdGV4dC5tYXRjaCh0aGlzLl9fb3B0c19fLmZ1enp5SVAgPyB0aGlzLnJlLmxpbmtfZnV6enkgOiB0aGlzLnJlLmxpbmtfbm9faXBfZnV6enkpKSAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgc2hpZnQgPSBtbC5pbmRleCArIG1sWzFdLmxlbmd0aDtcblxuICAgICAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgc2hpZnQgPCB0aGlzLl9faW5kZXhfXykge1xuICAgICAgICAgICAgdGhpcy5fX3NjaGVtYV9fICAgICA9ICcnO1xuICAgICAgICAgICAgdGhpcy5fX2luZGV4X18gICAgICA9IHNoaWZ0O1xuICAgICAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG1sLmluZGV4ICsgbWxbMF0ubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9fb3B0c19fLmZ1enp5RW1haWwgJiYgdGhpcy5fX2NvbXBpbGVkX19bJ21haWx0bzonXSkge1xuICAgIC8vIGd1ZXNzIHNjaGVtYWxlc3MgZW1haWxzXG4gICAgYXRfcG9zID0gdGV4dC5pbmRleE9mKCdAJyk7XG4gICAgaWYgKGF0X3BvcyA+PSAwKSB7XG4gICAgICAvLyBXZSBjYW4ndCBza2lwIHRoaXMgY2hlY2ssIGJlY2F1c2UgdGhpcyBjYXNlcyBhcmUgcG9zc2libGU6XG4gICAgICAvLyAxOTIuMTY4LjEuMUBnbWFpbC5jb20sIG15LmluQGV4YW1wbGUuY29tXG4gICAgICBpZiAoKG1lID0gdGV4dC5tYXRjaCh0aGlzLnJlLmVtYWlsX2Z1enp5KSkgIT09IG51bGwpIHtcblxuICAgICAgICBzaGlmdCA9IG1lLmluZGV4ICsgbWVbMV0ubGVuZ3RoO1xuICAgICAgICBuZXh0ICA9IG1lLmluZGV4ICsgbWVbMF0ubGVuZ3RoO1xuXG4gICAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgc2hpZnQgPCB0aGlzLl9faW5kZXhfXyB8fFxuICAgICAgICAgICAgKHNoaWZ0ID09PSB0aGlzLl9faW5kZXhfXyAmJiBuZXh0ID4gdGhpcy5fX2xhc3RfaW5kZXhfXykpIHtcbiAgICAgICAgICB0aGlzLl9fc2NoZW1hX18gICAgID0gJ21haWx0bzonO1xuICAgICAgICAgIHRoaXMuX19pbmRleF9fICAgICAgPSBzaGlmdDtcbiAgICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLl9faW5kZXhfXyA+PSAwO1xufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCNwcmV0ZXN0KHRleHQpIC0+IEJvb2xlYW5cbiAqXG4gKiBWZXJ5IHF1aWNrIGNoZWNrLCB0aGF0IGNhbiBnaXZlIGZhbHNlIHBvc2l0aXZlcy4gUmV0dXJucyB0cnVlIGlmIGxpbmsgTUFZIEJFXG4gKiBjYW4gZXhpc3RzLiBDYW4gYmUgdXNlZCBmb3Igc3BlZWQgb3B0aW1pemF0aW9uLCB3aGVuIHlvdSBuZWVkIHRvIGNoZWNrIHRoYXRcbiAqIGxpbmsgTk9UIGV4aXN0cy5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUucHJldGVzdCA9IGZ1bmN0aW9uIHByZXRlc3QodGV4dCkge1xuICByZXR1cm4gdGhpcy5yZS5wcmV0ZXN0LnRlc3QodGV4dCk7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I3Rlc3RTY2hlbWFBdCh0ZXh0LCBuYW1lLCBwb3NpdGlvbikgLT4gTnVtYmVyXG4gKiAtIHRleHQgKFN0cmluZyk6IHRleHQgdG8gc2NhblxuICogLSBuYW1lIChTdHJpbmcpOiBydWxlIChzY2hlbWEpIG5hbWVcbiAqIC0gcG9zaXRpb24gKE51bWJlcik6IHRleHQgb2Zmc2V0IHRvIGNoZWNrIGZyb21cbiAqXG4gKiBTaW1pbGFyIHRvIFtbTGlua2lmeUl0I3Rlc3RdXSBidXQgY2hlY2tzIG9ubHkgc3BlY2lmaWMgcHJvdG9jb2wgdGFpbCBleGFjdGx5XG4gKiBhdCBnaXZlbiBwb3NpdGlvbi4gUmV0dXJucyBsZW5ndGggb2YgZm91bmQgcGF0dGVybiAoMCBvbiBmYWlsKS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUudGVzdFNjaGVtYUF0ID0gZnVuY3Rpb24gdGVzdFNjaGVtYUF0KHRleHQsIHNjaGVtYSwgcG9zKSB7XG4gIC8vIElmIG5vdCBzdXBwb3J0ZWQgc2NoZW1hIGNoZWNrIHJlcXVlc3RlZCAtIHRlcm1pbmF0ZVxuICBpZiAoIXRoaXMuX19jb21waWxlZF9fW3NjaGVtYS50b0xvd2VyQ2FzZSgpXSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiB0aGlzLl9fY29tcGlsZWRfX1tzY2hlbWEudG9Mb3dlckNhc2UoKV0udmFsaWRhdGUodGV4dCwgcG9zLCB0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjbWF0Y2godGV4dCkgLT4gQXJyYXl8bnVsbFxuICpcbiAqIFJldHVybnMgYXJyYXkgb2YgZm91bmQgbGluayBkZXNjcmlwdGlvbnMgb3IgYG51bGxgIG9uIGZhaWwuIFdlIHN0cm9uZ2x5XG4gKiByZWNvbW1lbmQgdG8gdXNlIFtbTGlua2lmeUl0I3Rlc3RdXSBmaXJzdCwgZm9yIGJlc3Qgc3BlZWQuXG4gKlxuICogIyMjIyMgUmVzdWx0IG1hdGNoIGRlc2NyaXB0aW9uXG4gKlxuICogLSBfX3NjaGVtYV9fIC0gbGluayBzY2hlbWEsIGNhbiBiZSBlbXB0eSBmb3IgZnV6enkgbGlua3MsIG9yIGAvL2AgZm9yXG4gKiAgIHByb3RvY29sLW5ldXRyYWwgIGxpbmtzLlxuICogLSBfX2luZGV4X18gLSBvZmZzZXQgb2YgbWF0Y2hlZCB0ZXh0XG4gKiAtIF9fbGFzdEluZGV4X18gLSBpbmRleCBvZiBuZXh0IGNoYXIgYWZ0ZXIgbWF0aGNoIGVuZFxuICogLSBfX3Jhd19fIC0gbWF0Y2hlZCB0ZXh0XG4gKiAtIF9fdGV4dF9fIC0gbm9ybWFsaXplZCB0ZXh0XG4gKiAtIF9fdXJsX18gLSBsaW5rLCBnZW5lcmF0ZWQgZnJvbSBtYXRjaGVkIHRleHRcbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCh0ZXh0KSB7XG4gIHZhciBzaGlmdCA9IDAsIHJlc3VsdCA9IFtdO1xuXG4gIC8vIFRyeSB0byB0YWtlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSBjYWNoZSwgaWYgLnRlc3QoKSBjYWxsZWQgYmVmb3JlXG4gIGlmICh0aGlzLl9faW5kZXhfXyA+PSAwICYmIHRoaXMuX190ZXh0X2NhY2hlX18gPT09IHRleHQpIHtcbiAgICByZXN1bHQucHVzaChjcmVhdGVNYXRjaCh0aGlzLCBzaGlmdCkpO1xuICAgIHNoaWZ0ID0gdGhpcy5fX2xhc3RfaW5kZXhfXztcbiAgfVxuXG4gIC8vIEN1dCBoZWFkIGlmIGNhY2hlIHdhcyB1c2VkXG4gIHZhciB0YWlsID0gc2hpZnQgPyB0ZXh0LnNsaWNlKHNoaWZ0KSA6IHRleHQ7XG5cbiAgLy8gU2NhbiBzdHJpbmcgdW50aWwgZW5kIHJlYWNoZWRcbiAgd2hpbGUgKHRoaXMudGVzdCh0YWlsKSkge1xuICAgIHJlc3VsdC5wdXNoKGNyZWF0ZU1hdGNoKHRoaXMsIHNoaWZ0KSk7XG5cbiAgICB0YWlsID0gdGFpbC5zbGljZSh0aGlzLl9fbGFzdF9pbmRleF9fKTtcbiAgICBzaGlmdCArPSB0aGlzLl9fbGFzdF9pbmRleF9fO1xuICB9XG5cbiAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIExpbmtpZnlJdCN0bGRzKGxpc3QgWywga2VlcE9sZF0pIC0+IHRoaXNcbiAqIC0gbGlzdCAoQXJyYXkpOiBsaXN0IG9mIHRsZHNcbiAqIC0ga2VlcE9sZCAoQm9vbGVhbik6IG1lcmdlIHdpdGggY3VycmVudCBsaXN0IGlmIGB0cnVlYCAoYGZhbHNlYCBieSBkZWZhdWx0KVxuICpcbiAqIExvYWQgKG9yIG1lcmdlKSBuZXcgdGxkcyBsaXN0LiBUaG9zZSBhcmUgdXNlciBmb3IgZnV6enkgbGlua3MgKHdpdGhvdXQgcHJlZml4KVxuICogdG8gYXZvaWQgZmFsc2UgcG9zaXRpdmVzLiBCeSBkZWZhdWx0IHRoaXMgYWxnb3J5dGhtIHVzZWQ6XG4gKlxuICogLSBob3N0bmFtZSB3aXRoIGFueSAyLWxldHRlciByb290IHpvbmVzIGFyZSBvay5cbiAqIC0gYml6fGNvbXxlZHV8Z292fG5ldHxvcmd8cHJvfHdlYnx4eHh8YWVyb3xhc2lhfGNvb3B8aW5mb3xtdXNldW18bmFtZXxzaG9wfNGA0YRcbiAqICAgYXJlIG9rLlxuICogLSBlbmNvZGVkIChgeG4tLS4uLmApIHJvb3Qgem9uZXMgYXJlIG9rLlxuICpcbiAqIElmIGxpc3QgaXMgcmVwbGFjZWQsIHRoZW4gZXhhY3QgbWF0Y2ggZm9yIDItY2hhcnMgcm9vdCB6b25lcyB3aWxsIGJlIGNoZWNrZWQuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnRsZHMgPSBmdW5jdGlvbiB0bGRzKGxpc3QsIGtlZXBPbGQpIHtcbiAgbGlzdCA9IEFycmF5LmlzQXJyYXkobGlzdCkgPyBsaXN0IDogWyBsaXN0IF07XG5cbiAgaWYgKCFrZWVwT2xkKSB7XG4gICAgdGhpcy5fX3RsZHNfXyA9IGxpc3Quc2xpY2UoKTtcbiAgICB0aGlzLl9fdGxkc19yZXBsYWNlZF9fID0gdHJ1ZTtcbiAgICBjb21waWxlKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhpcy5fX3RsZHNfXyA9IHRoaXMuX190bGRzX18uY29uY2F0KGxpc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVsLCBpZHgsIGFycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsICE9PSBhcnJbaWR4IC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmV2ZXJzZSgpO1xuXG4gIGNvbXBpbGUodGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBMaW5raWZ5SXQjbm9ybWFsaXplKG1hdGNoKVxuICpcbiAqIERlZmF1bHQgbm9ybWFsaXplciAoaWYgc2NoZW1hIGRvZXMgbm90IGRlZmluZSBpdCdzIG93bikuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShtYXRjaCkge1xuXG4gIC8vIERvIG1pbmltYWwgcG9zc2libGUgY2hhbmdlcyBieSBkZWZhdWx0LiBOZWVkIHRvIGNvbGxlY3QgZmVlZGJhY2sgcHJpb3JcbiAgLy8gdG8gbW92ZSBmb3J3YXJkIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9saW5raWZ5LWl0L2lzc3Vlcy8xXG5cbiAgaWYgKCFtYXRjaC5zY2hlbWEpIHsgbWF0Y2gudXJsID0gJ2h0dHA6Ly8nICsgbWF0Y2gudXJsOyB9XG5cbiAgaWYgKG1hdGNoLnNjaGVtYSA9PT0gJ21haWx0bzonICYmICEvXm1haWx0bzovaS50ZXN0KG1hdGNoLnVybCkpIHtcbiAgICBtYXRjaC51cmwgPSAnbWFpbHRvOicgKyBtYXRjaC51cmw7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjb25Db21waWxlKClcbiAqXG4gKiBPdmVycmlkZSB0byBtb2RpZnkgYmFzaWMgUmVnRXhwLXMuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLm9uQ29tcGlsZSA9IGZ1bmN0aW9uIG9uQ29tcGlsZSgpIHtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBMaW5raWZ5SXQ7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///+80P\n");

/***/ }),

/***/ "8OGi":
/*!***************************************!*\
  !*** ./node_modules/libgif/libgif.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n\tSuperGif\n\n\tExample usage:\n\n\t\t<img src=\"./example1_preview.gif\" rel:animated_src=\"./example1.gif\" width=\"360\" height=\"360\" rel:auto_play=\"1\" />\n\n\t\t<script type=\"text/javascript\">\n\t\t\t$$('img').each(function (img_tag) {\n\t\t\t\tif (/.*\\.gif/.test(img_tag.src)) {\n\t\t\t\t\tvar rub = new SuperGif({ gif: img_tag } );\n\t\t\t\t\trub.load();\n\t\t\t\t}\n\t\t\t});\n\t\t</script>\n\n\tImage tag attributes:\n\n\t\trel:animated_src -\tIf this url is specified, it's loaded into the player instead of src.\n\t\t\t\t\t\t\tThis allows a preview frame to be shown until animated gif data is streamed into the canvas\n\n\t\trel:auto_play -\t\tDefaults to 1 if not specified. If set to zero, a call to the play() method is needed\n\n\tConstructor options args\n\n\t\tgif \t\t\t\tRequired. The DOM element of an img tag.\n\t\tloop_mode\t\t\tOptional. Setting this to false will force disable looping of the gif.\n\t\tauto_play \t\t\tOptional. Same as the rel:auto_play attribute above, this arg overrides the img tag info.\n\t\tmax_width\t\t\tOptional. Scale images over max_width down to max_width. Helpful with mobile.\n \t\ton_end\t\t\t\tOptional. Add a callback for when the gif reaches the end of a single loop (one iteration). The first argument passed will be the gif HTMLElement.\n\t\tloop_delay\t\t\tOptional. The amount of time to pause (in ms) after each single loop (iteration).\n\t\tdraw_while_loading\tOptional. Determines whether the gif will be drawn to the canvas whilst it is loaded.\n\t\tshow_progress_bar\tOptional. Only applies when draw_while_loading is set to true.\n\n\tInstance methods\n\n\t\t// loading\n\t\tload( callback )\t\tLoads the gif specified by the src or rel:animated_src sttributie of the img tag into a canvas element and then calls callback if one is passed\n\t\tload_url( src, callback )\tLoads the gif file specified in the src argument into a canvas element and then calls callback if one is passed\n\n\t\t// play controls\n\t\tplay -\t\t\t\tStart playing the gif\n\t\tpause -\t\t\t\tStop playing the gif\n\t\tmove_to(i) -\t\tMove to frame i of the gif\n\t\tmove_relative(i) -\tMove i frames ahead (or behind if i < 0)\n\n\t\t// getters\n\t\tget_canvas\t\t\tThe canvas element that the gif is playing in. Handy for assigning event handlers to.\n\t\tget_playing\t\t\tWhether or not the gif is currently playing\n\t\tget_loading\t\t\tWhether or not the gif has finished loading/parsing\n\t\tget_auto_play\t\tWhether or not the gif is set to play automatically\n\t\tget_length\t\t\tThe number of frames in the gif\n\t\tget_current_frame\tThe index of the currently displayed frame of the gif\n\t\tget_frames\t        An array containing the data for all parsed frames\n\t\tget_duration\t    Returns the duration of the gif in hundredths of a second (standard for GIF spec)\n\t\tget_duration_ms\t    Returns the duration of the gif in milliseconds\n\n\t\tFor additional customization (viewport inside iframe) these params may be passed:\n\t\tc_w, c_h - width and height of canvas\n\t\tvp_t, vp_l, vp_ w, vp_h - top, left, width and height of the viewport\n\n\t\tA bonus: few articles to understand what is going on\n\t\t\thttp://enthusiasms.org/post/16976438906\n\t\t\thttp://www.matthewflickinger.com/lab/whatsinagif/bits_and_bytes.asp\n\t\t\thttp://humpy77.deviantart.com/journal/Frame-Delay-Times-for-Animated-GIFs-214150546\n\n*/\n(function (root, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(this, function () {\n    // Generic functions\n    var bitsToNum = function (ba) {\n        return ba.reduce(function (s, n) {\n            return s * 2 + n;\n        }, 0);\n    };\n\n    var byteToBitArr = function (bite) {\n        var a = [];\n        for (var i = 7; i >= 0; i--) {\n            a.push( !! (bite & (1 << i)));\n        }\n        return a;\n    };\n\n    // Stream\n    /**\n     * @constructor\n     */\n    // Make compiler happy.\n    var Stream = function (data) {\n        this.data = data;\n        this.len = this.data.length;\n        this.pos = 0;\n\n        this.readByte = function () {\n            if (this.pos >= this.data.length) {\n                throw new Error('Attempted to read past end of stream.');\n            }\n            if (data instanceof Uint8Array)\n                return data[this.pos++];\n            else\n                return data.charCodeAt(this.pos++) & 0xFF;\n        };\n\n        this.readBytes = function (n) {\n            var bytes = [];\n            for (var i = 0; i < n; i++) {\n                bytes.push(this.readByte());\n            }\n            return bytes;\n        };\n\n        this.read = function (n) {\n            var s = '';\n            for (var i = 0; i < n; i++) {\n                s += String.fromCharCode(this.readByte());\n            }\n            return s;\n        };\n\n        this.readUnsigned = function () { // Little-endian.\n            var a = this.readBytes(2);\n            return (a[1] << 8) + a[0];\n        };\n    };\n\n    var lzwDecode = function (minCodeSize, data) {\n        // TODO: Now that the GIF parser is a bit different, maybe this should get an array of bytes instead of a String?\n        var pos = 0; // Maybe this streaming thing should be merged with the Stream?\n        var readCode = function (size) {\n            var code = 0;\n            for (var i = 0; i < size; i++) {\n                if (data.charCodeAt(pos >> 3) & (1 << (pos & 7))) {\n                    code |= 1 << i;\n                }\n                pos++;\n            }\n            return code;\n        };\n\n        var output = [];\n\n        var clearCode = 1 << minCodeSize;\n        var eoiCode = clearCode + 1;\n\n        var codeSize = minCodeSize + 1;\n\n        var dict = [];\n\n        var clear = function () {\n            dict = [];\n            codeSize = minCodeSize + 1;\n            for (var i = 0; i < clearCode; i++) {\n                dict[i] = [i];\n            }\n            dict[clearCode] = [];\n            dict[eoiCode] = null;\n\n        };\n\n        var code;\n        var last;\n\n        while (true) {\n            last = code;\n            code = readCode(codeSize);\n\n            if (code === clearCode) {\n                clear();\n                continue;\n            }\n            if (code === eoiCode) break;\n\n            if (code < dict.length) {\n                if (last !== clearCode) {\n                    dict.push(dict[last].concat(dict[code][0]));\n                }\n            }\n            else {\n                if (code !== dict.length) throw new Error('Invalid LZW code.');\n                dict.push(dict[last].concat(dict[last][0]));\n            }\n            output.push.apply(output, dict[code]);\n\n            if (dict.length === (1 << codeSize) && codeSize < 12) {\n                // If we're at the last code and codeSize is 12, the next code will be a clearCode, and it'll be 12 bits long.\n                codeSize++;\n            }\n        }\n\n        // I don't know if this is technically an error, but some GIFs do it.\n        //if (Math.ceil(pos / 8) !== data.length) throw new Error('Extraneous LZW bytes.');\n        return output;\n    };\n\n\n    // The actual parsing; returns an object with properties.\n    var parseGIF = function (st, handler) {\n        handler || (handler = {});\n\n        // LZW (GIF-specific)\n        var parseCT = function (entries) { // Each entry is 3 bytes, for RGB.\n            var ct = [];\n            for (var i = 0; i < entries; i++) {\n                ct.push(st.readBytes(3));\n            }\n            return ct;\n        };\n\n        var readSubBlocks = function () {\n            var size, data;\n            data = '';\n            do {\n                size = st.readByte();\n                data += st.read(size);\n            } while (size !== 0);\n            return data;\n        };\n\n        var parseHeader = function () {\n            var hdr = {};\n            hdr.sig = st.read(3);\n            hdr.ver = st.read(3);\n            if (hdr.sig !== 'GIF') throw new Error('Not a GIF file.'); // XXX: This should probably be handled more nicely.\n            hdr.width = st.readUnsigned();\n            hdr.height = st.readUnsigned();\n\n            var bits = byteToBitArr(st.readByte());\n            hdr.gctFlag = bits.shift();\n            hdr.colorRes = bitsToNum(bits.splice(0, 3));\n            hdr.sorted = bits.shift();\n            hdr.gctSize = bitsToNum(bits.splice(0, 3));\n\n            hdr.bgColor = st.readByte();\n            hdr.pixelAspectRatio = st.readByte(); // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64\n            if (hdr.gctFlag) {\n                hdr.gct = parseCT(1 << (hdr.gctSize + 1));\n            }\n            handler.hdr && handler.hdr(hdr);\n        };\n\n        var parseExt = function (block) {\n            var parseGCExt = function (block) {\n                var blockSize = st.readByte(); // Always 4\n                var bits = byteToBitArr(st.readByte());\n                block.reserved = bits.splice(0, 3); // Reserved; should be 000.\n                block.disposalMethod = bitsToNum(bits.splice(0, 3));\n                block.userInput = bits.shift();\n                block.transparencyGiven = bits.shift();\n\n                block.delayTime = st.readUnsigned();\n\n                block.transparencyIndex = st.readByte();\n\n                block.terminator = st.readByte();\n\n                handler.gce && handler.gce(block);\n            };\n\n            var parseComExt = function (block) {\n                block.comment = readSubBlocks();\n                handler.com && handler.com(block);\n            };\n\n            var parsePTExt = function (block) {\n                // No one *ever* uses this. If you use it, deal with parsing it yourself.\n                var blockSize = st.readByte(); // Always 12\n                block.ptHeader = st.readBytes(12);\n                block.ptData = readSubBlocks();\n                handler.pte && handler.pte(block);\n            };\n\n            var parseAppExt = function (block) {\n                var parseNetscapeExt = function (block) {\n                    var blockSize = st.readByte(); // Always 3\n                    block.unknown = st.readByte(); // ??? Always 1? What is this?\n                    block.iterations = st.readUnsigned();\n                    block.terminator = st.readByte();\n                    handler.app && handler.app.NETSCAPE && handler.app.NETSCAPE(block);\n                };\n\n                var parseUnknownAppExt = function (block) {\n                    block.appData = readSubBlocks();\n                    // FIXME: This won't work if a handler wants to match on any identifier.\n                    handler.app && handler.app[block.identifier] && handler.app[block.identifier](block);\n                };\n\n                var blockSize = st.readByte(); // Always 11\n                block.identifier = st.read(8);\n                block.authCode = st.read(3);\n                switch (block.identifier) {\n                    case 'NETSCAPE':\n                        parseNetscapeExt(block);\n                        break;\n                    default:\n                        parseUnknownAppExt(block);\n                        break;\n                }\n            };\n\n            var parseUnknownExt = function (block) {\n                block.data = readSubBlocks();\n                handler.unknown && handler.unknown(block);\n            };\n\n            block.label = st.readByte();\n            switch (block.label) {\n                case 0xF9:\n                    block.extType = 'gce';\n                    parseGCExt(block);\n                    break;\n                case 0xFE:\n                    block.extType = 'com';\n                    parseComExt(block);\n                    break;\n                case 0x01:\n                    block.extType = 'pte';\n                    parsePTExt(block);\n                    break;\n                case 0xFF:\n                    block.extType = 'app';\n                    parseAppExt(block);\n                    break;\n                default:\n                    block.extType = 'unknown';\n                    parseUnknownExt(block);\n                    break;\n            }\n        };\n\n        var parseImg = function (img) {\n            var deinterlace = function (pixels, width) {\n                // Of course this defeats the purpose of interlacing. And it's *probably*\n                // the least efficient way it's ever been implemented. But nevertheless...\n                var newPixels = new Array(pixels.length);\n                var rows = pixels.length / width;\n                var cpRow = function (toRow, fromRow) {\n                    var fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);\n                    newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));\n                };\n\n                // See appendix E.\n                var offsets = [0, 4, 2, 1];\n                var steps = [8, 8, 4, 2];\n\n                var fromRow = 0;\n                for (var pass = 0; pass < 4; pass++) {\n                    for (var toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {\n                        cpRow(toRow, fromRow)\n                        fromRow++;\n                    }\n                }\n\n                return newPixels;\n            };\n\n            img.leftPos = st.readUnsigned();\n            img.topPos = st.readUnsigned();\n            img.width = st.readUnsigned();\n            img.height = st.readUnsigned();\n\n            var bits = byteToBitArr(st.readByte());\n            img.lctFlag = bits.shift();\n            img.interlaced = bits.shift();\n            img.sorted = bits.shift();\n            img.reserved = bits.splice(0, 2);\n            img.lctSize = bitsToNum(bits.splice(0, 3));\n\n            if (img.lctFlag) {\n                img.lct = parseCT(1 << (img.lctSize + 1));\n            }\n\n            img.lzwMinCodeSize = st.readByte();\n\n            var lzwData = readSubBlocks();\n\n            img.pixels = lzwDecode(img.lzwMinCodeSize, lzwData);\n\n            if (img.interlaced) { // Move\n                img.pixels = deinterlace(img.pixels, img.width);\n            }\n\n            handler.img && handler.img(img);\n        };\n\n        var parseBlock = function () {\n            var block = {};\n            block.sentinel = st.readByte();\n\n            switch (String.fromCharCode(block.sentinel)) { // For ease of matching\n                case '!':\n                    block.type = 'ext';\n                    parseExt(block);\n                    break;\n                case ',':\n                    block.type = 'img';\n                    parseImg(block);\n                    break;\n                case ';':\n                    block.type = 'eof';\n                    handler.eof && handler.eof(block);\n                    break;\n                default:\n                    throw new Error('Unknown block: 0x' + block.sentinel.toString(16)); // TODO: Pad this with a 0.\n            }\n\n            if (block.type !== 'eof') setTimeout(parseBlock, 0);\n        };\n\n        var parse = function () {\n            parseHeader();\n            setTimeout(parseBlock, 0);\n        };\n\n        parse();\n    };\n\n    var SuperGif = function ( opts ) {\n        var options = {\n            //viewport position\n            vp_l: 0,\n            vp_t: 0,\n            vp_w: null,\n            vp_h: null,\n            //canvas sizes\n            c_w: null,\n            c_h: null\n        };\n        for (var i in opts ) { options[i] = opts[i] }\n        if (options.vp_w && options.vp_h) options.is_vp = true;\n\n        var stream;\n        var hdr;\n\n        var loadError = null;\n        var loading = false;\n\n        var transparency = null;\n        var delay = null;\n        var disposalMethod = null;\n        var disposalRestoreFromIdx = null;\n        var lastDisposalMethod = null;\n        var frame = null;\n        var lastImg = null;\n\n        var playing = true;\n        var forward = true;\n\n        var ctx_scaled = false;\n\n        var frames = [];\n        var frameOffsets = []; // elements have .x and .y properties\n\n        var gif = options.gif;\n        if (typeof options.auto_play == 'undefined')\n            options.auto_play = (!gif.getAttribute('rel:auto_play') || gif.getAttribute('rel:auto_play') == '1');\n\n        var onEndListener = (options.hasOwnProperty('on_end') ? options.on_end : null);\n        var loopDelay = (options.hasOwnProperty('loop_delay') ? options.loop_delay : 0);\n        var overrideLoopMode = (options.hasOwnProperty('loop_mode') ? options.loop_mode : 'auto');\n        var drawWhileLoading = (options.hasOwnProperty('draw_while_loading') ? options.draw_while_loading : true);\n        var showProgressBar = drawWhileLoading ? (options.hasOwnProperty('show_progress_bar') ? options.show_progress_bar : true) : false;\n        var progressBarHeight = (options.hasOwnProperty('progressbar_height') ? options.progressbar_height : 25);\n        var progressBarBackgroundColor = (options.hasOwnProperty('progressbar_background_color') ? options.progressbar_background_color : 'rgba(255,255,255,0.4)');\n        var progressBarForegroundColor = (options.hasOwnProperty('progressbar_foreground_color') ? options.progressbar_foreground_color : 'rgba(255,0,22,.8)');\n\n        var clear = function () {\n            transparency = null;\n            delay = null;\n            lastDisposalMethod = disposalMethod;\n            disposalMethod = null;\n            frame = null;\n        };\n\n        // XXX: There's probably a better way to handle catching exceptions when\n        // callbacks are involved.\n        var doParse = function () {\n            try {\n                parseGIF(stream, handler);\n            }\n            catch (err) {\n                doLoadError('parse');\n            }\n        };\n\n        var doText = function (text) {\n            toolbar.innerHTML = text; // innerText? Escaping? Whatever.\n            toolbar.style.visibility = 'visible';\n        };\n\n        var setSizes = function(w, h) {\n            canvas.width = w * get_canvas_scale();\n            canvas.height = h * get_canvas_scale();\n            toolbar.style.minWidth = ( w * get_canvas_scale() ) + 'px';\n\n            tmpCanvas.width = w;\n            tmpCanvas.height = h;\n            tmpCanvas.style.width = w + 'px';\n            tmpCanvas.style.height = h + 'px';\n            tmpCanvas.getContext('2d').setTransform(1, 0, 0, 1, 0, 0);\n        };\n\n        var setFrameOffset = function(frame, offset) {\n            if (!frameOffsets[frame]) {\n                frameOffsets[frame] = offset;\n                return;\n            }\n            if (typeof offset.x !== 'undefined') {\n                frameOffsets[frame].x = offset.x;\n            }\n            if (typeof offset.y !== 'undefined') {\n                frameOffsets[frame].y = offset.y;\n            }\n        };\n\n        var doShowProgress = function (pos, length, draw) {\n            if (draw && showProgressBar) {\n                var height = progressBarHeight;\n                var left, mid, top, width;\n                if (options.is_vp) {\n                    if (!ctx_scaled) {\n                        top = (options.vp_t + options.vp_h - height);\n                        height = height;\n                        left = options.vp_l;\n                        mid = left + (pos / length) * options.vp_w;\n                        width = canvas.width;\n                    } else {\n                        top = (options.vp_t + options.vp_h - height) / get_canvas_scale();\n                        height = height / get_canvas_scale();\n                        left = (options.vp_l / get_canvas_scale() );\n                        mid = left + (pos / length) * (options.vp_w / get_canvas_scale());\n                        width = canvas.width / get_canvas_scale();\n                    }\n                    //some debugging, draw rect around viewport\n                    if (false) { var w, h, l, t; }\n                }\n                else {\n                    top = (canvas.height - height) / (ctx_scaled ? get_canvas_scale() : 1);\n                    mid = ((pos / length) * canvas.width) / (ctx_scaled ? get_canvas_scale() : 1);\n                    width = canvas.width / (ctx_scaled ? get_canvas_scale() : 1 );\n                    height /= ctx_scaled ? get_canvas_scale() : 1;\n                }\n\n                ctx.fillStyle = progressBarBackgroundColor;\n                ctx.fillRect(mid, top, width - mid, height);\n\n                ctx.fillStyle = progressBarForegroundColor;\n                ctx.fillRect(0, top, mid, height);\n            }\n        };\n\n        var doLoadError = function (originOfError) {\n            var drawError = function () {\n                ctx.fillStyle = 'black';\n                ctx.fillRect(0, 0, options.c_w ? options.c_w : hdr.width, options.c_h ? options.c_h : hdr.height);\n                ctx.strokeStyle = 'red';\n                ctx.lineWidth = 3;\n                ctx.moveTo(0, 0);\n                ctx.lineTo(options.c_w ? options.c_w : hdr.width, options.c_h ? options.c_h : hdr.height);\n                ctx.moveTo(0, options.c_h ? options.c_h : hdr.height);\n                ctx.lineTo(options.c_w ? options.c_w : hdr.width, 0);\n                ctx.stroke();\n            };\n\n            loadError = originOfError;\n            hdr = {\n                width: gif.width,\n                height: gif.height\n            }; // Fake header.\n            frames = [];\n            drawError();\n        };\n\n        var doHdr = function (_hdr) {\n            hdr = _hdr;\n            setSizes(hdr.width, hdr.height)\n        };\n\n        var doGCE = function (gce) {\n            pushFrame();\n            clear();\n            transparency = gce.transparencyGiven ? gce.transparencyIndex : null;\n            delay = gce.delayTime;\n            disposalMethod = gce.disposalMethod;\n            // We don't have much to do with the rest of GCE.\n        };\n\n        var pushFrame = function () {\n            if (!frame) return;\n            frames.push({\n                            data: frame.getImageData(0, 0, hdr.width, hdr.height),\n                            delay: delay\n                        });\n            frameOffsets.push({ x: 0, y: 0 });\n        };\n\n        var doImg = function (img) {\n            if (!frame) frame = tmpCanvas.getContext('2d');\n\n            var currIdx = frames.length;\n\n            //ct = color table, gct = global color table\n            var ct = img.lctFlag ? img.lct : hdr.gct; // TODO: What if neither exists?\n\n            /*\n            Disposal method indicates the way in which the graphic is to\n            be treated after being displayed.\n\n            Values :    0 - No disposal specified. The decoder is\n                            not required to take any action.\n                        1 - Do not dispose. The graphic is to be left\n                            in place.\n                        2 - Restore to background color. The area used by the\n                            graphic must be restored to the background color.\n                        3 - Restore to previous. The decoder is required to\n                            restore the area overwritten by the graphic with\n                            what was there prior to rendering the graphic.\n\n                            Importantly, \"previous\" means the frame state\n                            after the last disposal of method 0, 1, or 2.\n            */\n            if (currIdx > 0) {\n                if (lastDisposalMethod === 3) {\n                    // Restore to previous\n                    // If we disposed every frame including first frame up to this point, then we have\n                    // no composited frame to restore to. In this case, restore to background instead.\n                    if (disposalRestoreFromIdx !== null) {\n                    \tframe.putImageData(frames[disposalRestoreFromIdx].data, 0, 0);\n                    } else {\n                    \tframe.clearRect(lastImg.leftPos, lastImg.topPos, lastImg.width, lastImg.height);\n                    }\n                } else {\n                    disposalRestoreFromIdx = currIdx - 1;\n                }\n\n                if (lastDisposalMethod === 2) {\n                    // Restore to background color\n                    // Browser implementations historically restore to transparent; we do the same.\n                    // http://www.wizards-toolkit.org/discourse-server/viewtopic.php?f=1&t=21172#p86079\n                    frame.clearRect(lastImg.leftPos, lastImg.topPos, lastImg.width, lastImg.height);\n                }\n            }\n            // else, Undefined/Do not dispose.\n            // frame contains final pixel data from the last frame; do nothing\n\n            //Get existing pixels for img region after applying disposal method\n            var imgData = frame.getImageData(img.leftPos, img.topPos, img.width, img.height);\n\n            //apply color table colors\n            img.pixels.forEach(function (pixel, i) {\n                // imgData.data === [R,G,B,A,R,G,B,A,...]\n                if (pixel !== transparency) {\n                    imgData.data[i * 4 + 0] = ct[pixel][0];\n                    imgData.data[i * 4 + 1] = ct[pixel][1];\n                    imgData.data[i * 4 + 2] = ct[pixel][2];\n                    imgData.data[i * 4 + 3] = 255; // Opaque.\n                }\n            });\n\n            frame.putImageData(imgData, img.leftPos, img.topPos);\n\n            if (!ctx_scaled) {\n                ctx.scale(get_canvas_scale(),get_canvas_scale());\n                ctx_scaled = true;\n            }\n\n            // We could use the on-page canvas directly, except that we draw a progress\n            // bar for each image chunk (not just the final image).\n            if (drawWhileLoading) {\n                ctx.drawImage(tmpCanvas, 0, 0);\n                drawWhileLoading = options.auto_play;\n            }\n\n            lastImg = img;\n        };\n\n        var player = (function () {\n            var i = -1;\n            var iterationCount = 0;\n\n            var showingInfo = false;\n            var pinned = false;\n\n            /**\n             * Gets the index of the frame \"up next\".\n             * @returns {number}\n             */\n            var getNextFrameNo = function () {\n                var delta = (forward ? 1 : -1);\n                return (i + delta + frames.length) % frames.length;\n            };\n\n            var stepFrame = function (amount) { // XXX: Name is confusing.\n                i = i + amount;\n\n                putFrame();\n            };\n\n            var step = (function () {\n                var stepping = false;\n\n                var completeLoop = function () {\n                    if (onEndListener !== null)\n                        onEndListener(gif);\n                    iterationCount++;\n\n                    if (overrideLoopMode !== false || iterationCount < 0) {\n                        doStep();\n                    } else {\n                        stepping = false;\n                        playing = false;\n                    }\n                };\n\n                var doStep = function () {\n                    stepping = playing;\n                    if (!stepping) return;\n\n                    stepFrame(1);\n                    var delay = frames[i].delay * 10;\n                    if (!delay) delay = 100; // FIXME: Should this even default at all? What should it be?\n\n                    var nextFrameNo = getNextFrameNo();\n                    if (nextFrameNo === 0) {\n                        delay += loopDelay;\n                        setTimeout(completeLoop, delay);\n                    } else {\n                        setTimeout(doStep, delay);\n                    }\n                };\n\n                return function () {\n                    if (!stepping) setTimeout(doStep, 0);\n                };\n            }());\n\n            var putFrame = function () {\n                var offset;\n                i = parseInt(i, 10);\n\n                if (i > frames.length - 1){\n                    i = 0;\n                }\n\n                if (i < 0){\n                    i = 0;\n                }\n\n                offset = frameOffsets[i];\n\n                tmpCanvas.getContext(\"2d\").putImageData(frames[i].data, offset.x, offset.y);\n                ctx.globalCompositeOperation = \"copy\";\n                ctx.drawImage(tmpCanvas, 0, 0);\n            };\n\n            var play = function () {\n                playing = true;\n                step();\n            };\n\n            var pause = function () {\n                playing = false;\n            };\n\n\n            return {\n                init: function () {\n                    if (loadError) return;\n\n                    if ( ! (options.c_w && options.c_h) ) {\n                        ctx.scale(get_canvas_scale(),get_canvas_scale());\n                    }\n\n                    if (options.auto_play) {\n                        step();\n                    }\n                    else {\n                        i = 0;\n                        putFrame();\n                    }\n                },\n                step: step,\n                play: play,\n                pause: pause,\n                playing: playing,\n                move_relative: stepFrame,\n                current_frame: function() { return i; },\n                length: function() { return frames.length },\n                move_to: function ( frame_idx ) {\n                    i = frame_idx;\n                    putFrame();\n                }\n            }\n        }());\n\n        var doDecodeProgress = function (draw) {\n            doShowProgress(stream.pos, stream.data.length, draw);\n        };\n\n        var doNothing = function () {};\n        /**\n         * @param{boolean=} draw Whether to draw progress bar or not; this is not idempotent because of translucency.\n         *                       Note that this means that the text will be unsynchronized with the progress bar on non-frames;\n         *                       but those are typically so small (GCE etc.) that it doesn't really matter. TODO: Do this properly.\n         */\n        var withProgress = function (fn, draw) {\n            return function (block) {\n                fn(block);\n                doDecodeProgress(draw);\n            };\n        };\n\n\n        var handler = {\n            hdr: withProgress(doHdr),\n            gce: withProgress(doGCE),\n            com: withProgress(doNothing),\n            // I guess that's all for now.\n            app: {\n                // TODO: Is there much point in actually supporting iterations?\n                NETSCAPE: withProgress(doNothing)\n            },\n            img: withProgress(doImg, true),\n            eof: function (block) {\n                //toolbar.style.display = '';\n                pushFrame();\n                doDecodeProgress(false);\n                if ( ! (options.c_w && options.c_h) ) {\n                    canvas.width = hdr.width * get_canvas_scale();\n                    canvas.height = hdr.height * get_canvas_scale();\n                }\n                player.init();\n                loading = false;\n                if (load_callback) {\n                    load_callback(gif);\n                }\n\n            }\n        };\n\n        var init = function () {\n            var parent = gif.parentNode;\n\n            var div = document.createElement('div');\n            canvas = document.createElement('canvas');\n            ctx = canvas.getContext('2d');\n            toolbar = document.createElement('div');\n\n            tmpCanvas = document.createElement('canvas');\n\n            div.width = canvas.width = gif.width;\n            div.height = canvas.height = gif.height;\n            toolbar.style.minWidth = gif.width + 'px';\n\n            div.className = 'jsgif';\n            toolbar.className = 'jsgif_toolbar';\n            div.appendChild(canvas);\n            div.appendChild(toolbar);\n\n            parent.insertBefore(div, gif);\n            parent.removeChild(gif);\n\n            if (options.c_w && options.c_h) setSizes(options.c_w, options.c_h);\n            initialized=true;\n        };\n\n        var get_canvas_scale = function() {\n            var scale;\n            if (options.max_width && hdr && hdr.width > options.max_width) {\n                scale = options.max_width / hdr.width;\n            }\n            else {\n                scale = 1;\n            }\n            return scale;\n        }\n\n        var canvas, ctx, toolbar, tmpCanvas;\n        var initialized = false;\n        var load_callback = false;\n\n        var load_setup = function(callback) {\n            if (loading) return false;\n            if (callback) load_callback = callback;\n            else load_callback = false;\n\n            loading = true;\n            frames = [];\n            clear();\n            disposalRestoreFromIdx = null;\n            lastDisposalMethod = null;\n            frame = null;\n            lastImg = null;\n\n            return true;\n        }\n\n        var calculateDuration = function() {\n            return frames.reduce(function(duration, frame) {\n                return duration + frame.delay;\n            }, 0);\n        }\n\n        return {\n            // play controls\n            play: player.play,\n            pause: player.pause,\n            move_relative: player.move_relative,\n            move_to: player.move_to,\n\n            // getters for instance vars\n            get_playing      : function() { return playing },\n            get_canvas       : function() { return canvas },\n            get_canvas_scale : function() { return get_canvas_scale() },\n            get_loading      : function() { return loading },\n            get_auto_play    : function() { return options.auto_play },\n            get_length       : function() { return player.length() },\n            get_frames       : function() { return frames },\n            get_duration     : function() { return calculateDuration() },\n            get_duration_ms  : function() { return calculateDuration() * 10 },\n            get_current_frame: function() { return player.current_frame() },\n            load_url: function(src,callback){\n                if (!load_setup(callback)) return;\n\n                var h = new XMLHttpRequest();\n                // new browsers (XMLHttpRequest2-compliant)\n                h.open('GET', src, true);\n\n                if ('overrideMimeType' in h) {\n                    h.overrideMimeType('text/plain; charset=x-user-defined');\n                }\n\n                // old browsers (XMLHttpRequest-compliant)\n                else if ('responseType' in h) {\n                    h.responseType = 'arraybuffer';\n                }\n\n                // IE9 (Microsoft.XMLHTTP-compliant)\n                else {\n                    h.setRequestHeader('Accept-Charset', 'x-user-defined');\n                }\n\n                h.onloadstart = function() {\n                    // Wait until connection is opened to replace the gif element with a canvas to avoid a blank img\n                    if (!initialized) init();\n                };\n                h.onload = function(e) {\n                    if (this.status != 200) {\n                        doLoadError('xhr - response');\n                    }\n                    // emulating response field for IE9\n                    if (!('response' in this)) {\n                        this.response = new VBArray(this.responseText).toArray().map(String.fromCharCode).join('');\n                    }\n                    var data = this.response;\n                    if (data.toString().indexOf(\"ArrayBuffer\") > 0) {\n                        data = new Uint8Array(data);\n                    }\n\n                    stream = new Stream(data);\n                    setTimeout(doParse, 0);\n                };\n                h.onprogress = function (e) {\n                    if (e.lengthComputable) doShowProgress(e.loaded, e.total, true);\n                };\n                h.onerror = function() { doLoadError('xhr'); };\n                h.send();\n            },\n            load: function (callback) {\n                this.load_url(gif.getAttribute('rel:animated_src') || gif.src,callback);\n            },\n            load_raw: function(arr, callback) {\n                if (!load_setup(callback)) return;\n                if (!initialized) init();\n                stream = new Stream(arr);\n                setTimeout(doParse, 0);\n            },\n            set_frame_offset: setFrameOffset\n        };\n    };\n\n    return SuperGif;\n}));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOE9HaS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saWJnaWYvbGliZ2lmLmpzP2YwZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcblx0U3VwZXJHaWZcblxuXHRFeGFtcGxlIHVzYWdlOlxuXG5cdFx0PGltZyBzcmM9XCIuL2V4YW1wbGUxX3ByZXZpZXcuZ2lmXCIgcmVsOmFuaW1hdGVkX3NyYz1cIi4vZXhhbXBsZTEuZ2lmXCIgd2lkdGg9XCIzNjBcIiBoZWlnaHQ9XCIzNjBcIiByZWw6YXV0b19wbGF5PVwiMVwiIC8+XG5cblx0XHQ8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIj5cblx0XHRcdCQkKCdpbWcnKS5lYWNoKGZ1bmN0aW9uIChpbWdfdGFnKSB7XG5cdFx0XHRcdGlmICgvLipcXC5naWYvLnRlc3QoaW1nX3RhZy5zcmMpKSB7XG5cdFx0XHRcdFx0dmFyIHJ1YiA9IG5ldyBTdXBlckdpZih7IGdpZjogaW1nX3RhZyB9ICk7XG5cdFx0XHRcdFx0cnViLmxvYWQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0PC9zY3JpcHQ+XG5cblx0SW1hZ2UgdGFnIGF0dHJpYnV0ZXM6XG5cblx0XHRyZWw6YW5pbWF0ZWRfc3JjIC1cdElmIHRoaXMgdXJsIGlzIHNwZWNpZmllZCwgaXQncyBsb2FkZWQgaW50byB0aGUgcGxheWVyIGluc3RlYWQgb2Ygc3JjLlxuXHRcdFx0XHRcdFx0XHRUaGlzIGFsbG93cyBhIHByZXZpZXcgZnJhbWUgdG8gYmUgc2hvd24gdW50aWwgYW5pbWF0ZWQgZ2lmIGRhdGEgaXMgc3RyZWFtZWQgaW50byB0aGUgY2FudmFzXG5cblx0XHRyZWw6YXV0b19wbGF5IC1cdFx0RGVmYXVsdHMgdG8gMSBpZiBub3Qgc3BlY2lmaWVkLiBJZiBzZXQgdG8gemVybywgYSBjYWxsIHRvIHRoZSBwbGF5KCkgbWV0aG9kIGlzIG5lZWRlZFxuXG5cdENvbnN0cnVjdG9yIG9wdGlvbnMgYXJnc1xuXG5cdFx0Z2lmIFx0XHRcdFx0UmVxdWlyZWQuIFRoZSBET00gZWxlbWVudCBvZiBhbiBpbWcgdGFnLlxuXHRcdGxvb3BfbW9kZVx0XHRcdE9wdGlvbmFsLiBTZXR0aW5nIHRoaXMgdG8gZmFsc2Ugd2lsbCBmb3JjZSBkaXNhYmxlIGxvb3Bpbmcgb2YgdGhlIGdpZi5cblx0XHRhdXRvX3BsYXkgXHRcdFx0T3B0aW9uYWwuIFNhbWUgYXMgdGhlIHJlbDphdXRvX3BsYXkgYXR0cmlidXRlIGFib3ZlLCB0aGlzIGFyZyBvdmVycmlkZXMgdGhlIGltZyB0YWcgaW5mby5cblx0XHRtYXhfd2lkdGhcdFx0XHRPcHRpb25hbC4gU2NhbGUgaW1hZ2VzIG92ZXIgbWF4X3dpZHRoIGRvd24gdG8gbWF4X3dpZHRoLiBIZWxwZnVsIHdpdGggbW9iaWxlLlxuIFx0XHRvbl9lbmRcdFx0XHRcdE9wdGlvbmFsLiBBZGQgYSBjYWxsYmFjayBmb3Igd2hlbiB0aGUgZ2lmIHJlYWNoZXMgdGhlIGVuZCBvZiBhIHNpbmdsZSBsb29wIChvbmUgaXRlcmF0aW9uKS4gVGhlIGZpcnN0IGFyZ3VtZW50IHBhc3NlZCB3aWxsIGJlIHRoZSBnaWYgSFRNTEVsZW1lbnQuXG5cdFx0bG9vcF9kZWxheVx0XHRcdE9wdGlvbmFsLiBUaGUgYW1vdW50IG9mIHRpbWUgdG8gcGF1c2UgKGluIG1zKSBhZnRlciBlYWNoIHNpbmdsZSBsb29wIChpdGVyYXRpb24pLlxuXHRcdGRyYXdfd2hpbGVfbG9hZGluZ1x0T3B0aW9uYWwuIERldGVybWluZXMgd2hldGhlciB0aGUgZ2lmIHdpbGwgYmUgZHJhd24gdG8gdGhlIGNhbnZhcyB3aGlsc3QgaXQgaXMgbG9hZGVkLlxuXHRcdHNob3dfcHJvZ3Jlc3NfYmFyXHRPcHRpb25hbC4gT25seSBhcHBsaWVzIHdoZW4gZHJhd193aGlsZV9sb2FkaW5nIGlzIHNldCB0byB0cnVlLlxuXG5cdEluc3RhbmNlIG1ldGhvZHNcblxuXHRcdC8vIGxvYWRpbmdcblx0XHRsb2FkKCBjYWxsYmFjayApXHRcdExvYWRzIHRoZSBnaWYgc3BlY2lmaWVkIGJ5IHRoZSBzcmMgb3IgcmVsOmFuaW1hdGVkX3NyYyBzdHRyaWJ1dGllIG9mIHRoZSBpbWcgdGFnIGludG8gYSBjYW52YXMgZWxlbWVudCBhbmQgdGhlbiBjYWxscyBjYWxsYmFjayBpZiBvbmUgaXMgcGFzc2VkXG5cdFx0bG9hZF91cmwoIHNyYywgY2FsbGJhY2sgKVx0TG9hZHMgdGhlIGdpZiBmaWxlIHNwZWNpZmllZCBpbiB0aGUgc3JjIGFyZ3VtZW50IGludG8gYSBjYW52YXMgZWxlbWVudCBhbmQgdGhlbiBjYWxscyBjYWxsYmFjayBpZiBvbmUgaXMgcGFzc2VkXG5cblx0XHQvLyBwbGF5IGNvbnRyb2xzXG5cdFx0cGxheSAtXHRcdFx0XHRTdGFydCBwbGF5aW5nIHRoZSBnaWZcblx0XHRwYXVzZSAtXHRcdFx0XHRTdG9wIHBsYXlpbmcgdGhlIGdpZlxuXHRcdG1vdmVfdG8oaSkgLVx0XHRNb3ZlIHRvIGZyYW1lIGkgb2YgdGhlIGdpZlxuXHRcdG1vdmVfcmVsYXRpdmUoaSkgLVx0TW92ZSBpIGZyYW1lcyBhaGVhZCAob3IgYmVoaW5kIGlmIGkgPCAwKVxuXG5cdFx0Ly8gZ2V0dGVyc1xuXHRcdGdldF9jYW52YXNcdFx0XHRUaGUgY2FudmFzIGVsZW1lbnQgdGhhdCB0aGUgZ2lmIGlzIHBsYXlpbmcgaW4uIEhhbmR5IGZvciBhc3NpZ25pbmcgZXZlbnQgaGFuZGxlcnMgdG8uXG5cdFx0Z2V0X3BsYXlpbmdcdFx0XHRXaGV0aGVyIG9yIG5vdCB0aGUgZ2lmIGlzIGN1cnJlbnRseSBwbGF5aW5nXG5cdFx0Z2V0X2xvYWRpbmdcdFx0XHRXaGV0aGVyIG9yIG5vdCB0aGUgZ2lmIGhhcyBmaW5pc2hlZCBsb2FkaW5nL3BhcnNpbmdcblx0XHRnZXRfYXV0b19wbGF5XHRcdFdoZXRoZXIgb3Igbm90IHRoZSBnaWYgaXMgc2V0IHRvIHBsYXkgYXV0b21hdGljYWxseVxuXHRcdGdldF9sZW5ndGhcdFx0XHRUaGUgbnVtYmVyIG9mIGZyYW1lcyBpbiB0aGUgZ2lmXG5cdFx0Z2V0X2N1cnJlbnRfZnJhbWVcdFRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IGRpc3BsYXllZCBmcmFtZSBvZiB0aGUgZ2lmXG5cdFx0Z2V0X2ZyYW1lc1x0ICAgICAgICBBbiBhcnJheSBjb250YWluaW5nIHRoZSBkYXRhIGZvciBhbGwgcGFyc2VkIGZyYW1lc1xuXHRcdGdldF9kdXJhdGlvblx0ICAgIFJldHVybnMgdGhlIGR1cmF0aW9uIG9mIHRoZSBnaWYgaW4gaHVuZHJlZHRocyBvZiBhIHNlY29uZCAoc3RhbmRhcmQgZm9yIEdJRiBzcGVjKVxuXHRcdGdldF9kdXJhdGlvbl9tc1x0ICAgIFJldHVybnMgdGhlIGR1cmF0aW9uIG9mIHRoZSBnaWYgaW4gbWlsbGlzZWNvbmRzXG5cblx0XHRGb3IgYWRkaXRpb25hbCBjdXN0b21pemF0aW9uICh2aWV3cG9ydCBpbnNpZGUgaWZyYW1lKSB0aGVzZSBwYXJhbXMgbWF5IGJlIHBhc3NlZDpcblx0XHRjX3csIGNfaCAtIHdpZHRoIGFuZCBoZWlnaHQgb2YgY2FudmFzXG5cdFx0dnBfdCwgdnBfbCwgdnBfIHcsIHZwX2ggLSB0b3AsIGxlZnQsIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0XG5cblx0XHRBIGJvbnVzOiBmZXcgYXJ0aWNsZXMgdG8gdW5kZXJzdGFuZCB3aGF0IGlzIGdvaW5nIG9uXG5cdFx0XHRodHRwOi8vZW50aHVzaWFzbXMub3JnL3Bvc3QvMTY5NzY0Mzg5MDZcblx0XHRcdGh0dHA6Ly93d3cubWF0dGhld2ZsaWNraW5nZXIuY29tL2xhYi93aGF0c2luYWdpZi9iaXRzX2FuZF9ieXRlcy5hc3Bcblx0XHRcdGh0dHA6Ly9odW1weTc3LmRldmlhbnRhcnQuY29tL2pvdXJuYWwvRnJhbWUtRGVsYXktVGltZXMtZm9yLUFuaW1hdGVkLUdJRnMtMjE0MTUwNTQ2XG5cbiovXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5TdXBlckdpZiA9IGZhY3RvcnkoKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAvLyBHZW5lcmljIGZ1bmN0aW9uc1xuICAgIHZhciBiaXRzVG9OdW0gPSBmdW5jdGlvbiAoYmEpIHtcbiAgICAgICAgcmV0dXJuIGJhLnJlZHVjZShmdW5jdGlvbiAocywgbikge1xuICAgICAgICAgICAgcmV0dXJuIHMgKiAyICsgbjtcbiAgICAgICAgfSwgMCk7XG4gICAgfTtcblxuICAgIHZhciBieXRlVG9CaXRBcnIgPSBmdW5jdGlvbiAoYml0ZSkge1xuICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gNzsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGEucHVzaCggISEgKGJpdGUgJiAoMSA8PCBpKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG5cbiAgICAvLyBTdHJlYW1cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICAvLyBNYWtlIGNvbXBpbGVyIGhhcHB5LlxuICAgIHZhciBTdHJlYW0gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmxlbiA9IHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucG9zID0gMDtcblxuICAgICAgICB0aGlzLnJlYWRCeXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byByZWFkIHBhc3QgZW5kIG9mIHN0cmVhbS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVt0aGlzLnBvcysrXTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5jaGFyQ29kZUF0KHRoaXMucG9zKyspICYgMHhGRjtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJlYWRCeXRlcyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICB2YXIgYnl0ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaCh0aGlzLnJlYWRCeXRlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICB2YXIgcyA9ICcnO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5yZWFkQnl0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVhZFVuc2lnbmVkID0gZnVuY3Rpb24gKCkgeyAvLyBMaXR0bGUtZW5kaWFuLlxuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLnJlYWRCeXRlcygyKTtcbiAgICAgICAgICAgIHJldHVybiAoYVsxXSA8PCA4KSArIGFbMF07XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBsendEZWNvZGUgPSBmdW5jdGlvbiAobWluQ29kZVNpemUsIGRhdGEpIHtcbiAgICAgICAgLy8gVE9ETzogTm93IHRoYXQgdGhlIEdJRiBwYXJzZXIgaXMgYSBiaXQgZGlmZmVyZW50LCBtYXliZSB0aGlzIHNob3VsZCBnZXQgYW4gYXJyYXkgb2YgYnl0ZXMgaW5zdGVhZCBvZiBhIFN0cmluZz9cbiAgICAgICAgdmFyIHBvcyA9IDA7IC8vIE1heWJlIHRoaXMgc3RyZWFtaW5nIHRoaW5nIHNob3VsZCBiZSBtZXJnZWQgd2l0aCB0aGUgU3RyZWFtP1xuICAgICAgICB2YXIgcmVhZENvZGUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5jaGFyQ29kZUF0KHBvcyA+PiAzKSAmICgxIDw8IChwb3MgJiA3KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZSB8PSAxIDw8IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xuXG4gICAgICAgIHZhciBjbGVhckNvZGUgPSAxIDw8IG1pbkNvZGVTaXplO1xuICAgICAgICB2YXIgZW9pQ29kZSA9IGNsZWFyQ29kZSArIDE7XG5cbiAgICAgICAgdmFyIGNvZGVTaXplID0gbWluQ29kZVNpemUgKyAxO1xuXG4gICAgICAgIHZhciBkaWN0ID0gW107XG5cbiAgICAgICAgdmFyIGNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGljdCA9IFtdO1xuICAgICAgICAgICAgY29kZVNpemUgPSBtaW5Db2RlU2l6ZSArIDE7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsZWFyQ29kZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGljdFtpXSA9IFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpY3RbY2xlYXJDb2RlXSA9IFtdO1xuICAgICAgICAgICAgZGljdFtlb2lDb2RlXSA9IG51bGw7XG5cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY29kZTtcbiAgICAgICAgdmFyIGxhc3Q7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGxhc3QgPSBjb2RlO1xuICAgICAgICAgICAgY29kZSA9IHJlYWRDb2RlKGNvZGVTaXplKTtcblxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IGNsZWFyQ29kZSkge1xuICAgICAgICAgICAgICAgIGNsZWFyKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gZW9pQ29kZSkgYnJlYWs7XG5cbiAgICAgICAgICAgIGlmIChjb2RlIDwgZGljdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAhPT0gY2xlYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpY3QucHVzaChkaWN0W2xhc3RdLmNvbmNhdChkaWN0W2NvZGVdWzBdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgIT09IGRpY3QubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTFpXIGNvZGUuJyk7XG4gICAgICAgICAgICAgICAgZGljdC5wdXNoKGRpY3RbbGFzdF0uY29uY2F0KGRpY3RbbGFzdF1bMF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dC5wdXNoLmFwcGx5KG91dHB1dCwgZGljdFtjb2RlXSk7XG5cbiAgICAgICAgICAgIGlmIChkaWN0Lmxlbmd0aCA9PT0gKDEgPDwgY29kZVNpemUpICYmIGNvZGVTaXplIDwgMTIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBhdCB0aGUgbGFzdCBjb2RlIGFuZCBjb2RlU2l6ZSBpcyAxMiwgdGhlIG5leHQgY29kZSB3aWxsIGJlIGEgY2xlYXJDb2RlLCBhbmQgaXQnbGwgYmUgMTIgYml0cyBsb25nLlxuICAgICAgICAgICAgICAgIGNvZGVTaXplKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJIGRvbid0IGtub3cgaWYgdGhpcyBpcyB0ZWNobmljYWxseSBhbiBlcnJvciwgYnV0IHNvbWUgR0lGcyBkbyBpdC5cbiAgICAgICAgLy9pZiAoTWF0aC5jZWlsKHBvcyAvIDgpICE9PSBkYXRhLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdFeHRyYW5lb3VzIExaVyBieXRlcy4nKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuXG5cbiAgICAvLyBUaGUgYWN0dWFsIHBhcnNpbmc7IHJldHVybnMgYW4gb2JqZWN0IHdpdGggcHJvcGVydGllcy5cbiAgICB2YXIgcGFyc2VHSUYgPSBmdW5jdGlvbiAoc3QsIGhhbmRsZXIpIHtcbiAgICAgICAgaGFuZGxlciB8fCAoaGFuZGxlciA9IHt9KTtcblxuICAgICAgICAvLyBMWlcgKEdJRi1zcGVjaWZpYylcbiAgICAgICAgdmFyIHBhcnNlQ1QgPSBmdW5jdGlvbiAoZW50cmllcykgeyAvLyBFYWNoIGVudHJ5IGlzIDMgYnl0ZXMsIGZvciBSR0IuXG4gICAgICAgICAgICB2YXIgY3QgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3QucHVzaChzdC5yZWFkQnl0ZXMoMykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZWFkU3ViQmxvY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNpemUsIGRhdGE7XG4gICAgICAgICAgICBkYXRhID0gJyc7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IHN0LnJlYWRCeXRlKCk7XG4gICAgICAgICAgICAgICAgZGF0YSArPSBzdC5yZWFkKHNpemUpO1xuICAgICAgICAgICAgfSB3aGlsZSAoc2l6ZSAhPT0gMCk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcGFyc2VIZWFkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaGRyID0ge307XG4gICAgICAgICAgICBoZHIuc2lnID0gc3QucmVhZCgzKTtcbiAgICAgICAgICAgIGhkci52ZXIgPSBzdC5yZWFkKDMpO1xuICAgICAgICAgICAgaWYgKGhkci5zaWcgIT09ICdHSUYnKSB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIEdJRiBmaWxlLicpOyAvLyBYWFg6IFRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIGhhbmRsZWQgbW9yZSBuaWNlbHkuXG4gICAgICAgICAgICBoZHIud2lkdGggPSBzdC5yZWFkVW5zaWduZWQoKTtcbiAgICAgICAgICAgIGhkci5oZWlnaHQgPSBzdC5yZWFkVW5zaWduZWQoKTtcblxuICAgICAgICAgICAgdmFyIGJpdHMgPSBieXRlVG9CaXRBcnIoc3QucmVhZEJ5dGUoKSk7XG4gICAgICAgICAgICBoZHIuZ2N0RmxhZyA9IGJpdHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGhkci5jb2xvclJlcyA9IGJpdHNUb051bShiaXRzLnNwbGljZSgwLCAzKSk7XG4gICAgICAgICAgICBoZHIuc29ydGVkID0gYml0cy5zaGlmdCgpO1xuICAgICAgICAgICAgaGRyLmdjdFNpemUgPSBiaXRzVG9OdW0oYml0cy5zcGxpY2UoMCwgMykpO1xuXG4gICAgICAgICAgICBoZHIuYmdDb2xvciA9IHN0LnJlYWRCeXRlKCk7XG4gICAgICAgICAgICBoZHIucGl4ZWxBc3BlY3RSYXRpbyA9IHN0LnJlYWRCeXRlKCk7IC8vIGlmIG5vdCAwLCBhc3BlY3RSYXRpbyA9IChwaXhlbEFzcGVjdFJhdGlvICsgMTUpIC8gNjRcbiAgICAgICAgICAgIGlmIChoZHIuZ2N0RmxhZykge1xuICAgICAgICAgICAgICAgIGhkci5nY3QgPSBwYXJzZUNUKDEgPDwgKGhkci5nY3RTaXplICsgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlci5oZHIgJiYgaGFuZGxlci5oZHIoaGRyKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcGFyc2VFeHQgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgICAgIHZhciBwYXJzZUdDRXh0ID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IHN0LnJlYWRCeXRlKCk7IC8vIEFsd2F5cyA0XG4gICAgICAgICAgICAgICAgdmFyIGJpdHMgPSBieXRlVG9CaXRBcnIoc3QucmVhZEJ5dGUoKSk7XG4gICAgICAgICAgICAgICAgYmxvY2sucmVzZXJ2ZWQgPSBiaXRzLnNwbGljZSgwLCAzKTsgLy8gUmVzZXJ2ZWQ7IHNob3VsZCBiZSAwMDAuXG4gICAgICAgICAgICAgICAgYmxvY2suZGlzcG9zYWxNZXRob2QgPSBiaXRzVG9OdW0oYml0cy5zcGxpY2UoMCwgMykpO1xuICAgICAgICAgICAgICAgIGJsb2NrLnVzZXJJbnB1dCA9IGJpdHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBibG9jay50cmFuc3BhcmVuY3lHaXZlbiA9IGJpdHMuc2hpZnQoKTtcblxuICAgICAgICAgICAgICAgIGJsb2NrLmRlbGF5VGltZSA9IHN0LnJlYWRVbnNpZ25lZCgpO1xuXG4gICAgICAgICAgICAgICAgYmxvY2sudHJhbnNwYXJlbmN5SW5kZXggPSBzdC5yZWFkQnl0ZSgpO1xuXG4gICAgICAgICAgICAgICAgYmxvY2sudGVybWluYXRvciA9IHN0LnJlYWRCeXRlKCk7XG5cbiAgICAgICAgICAgICAgICBoYW5kbGVyLmdjZSAmJiBoYW5kbGVyLmdjZShibG9jayk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgcGFyc2VDb21FeHQgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgICAgICAgICBibG9jay5jb21tZW50ID0gcmVhZFN1YkJsb2NrcygpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuY29tICYmIGhhbmRsZXIuY29tKGJsb2NrKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBwYXJzZVBURXh0ID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gb25lICpldmVyKiB1c2VzIHRoaXMuIElmIHlvdSB1c2UgaXQsIGRlYWwgd2l0aCBwYXJzaW5nIGl0IHlvdXJzZWxmLlxuICAgICAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBzdC5yZWFkQnl0ZSgpOyAvLyBBbHdheXMgMTJcbiAgICAgICAgICAgICAgICBibG9jay5wdEhlYWRlciA9IHN0LnJlYWRCeXRlcygxMik7XG4gICAgICAgICAgICAgICAgYmxvY2sucHREYXRhID0gcmVhZFN1YkJsb2NrcygpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIucHRlICYmIGhhbmRsZXIucHRlKGJsb2NrKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBwYXJzZUFwcEV4dCA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZU5ldHNjYXBlRXh0ID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBzdC5yZWFkQnl0ZSgpOyAvLyBBbHdheXMgM1xuICAgICAgICAgICAgICAgICAgICBibG9jay51bmtub3duID0gc3QucmVhZEJ5dGUoKTsgLy8gPz8/IEFsd2F5cyAxPyBXaGF0IGlzIHRoaXM/XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLml0ZXJhdGlvbnMgPSBzdC5yZWFkVW5zaWduZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2sudGVybWluYXRvciA9IHN0LnJlYWRCeXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuYXBwICYmIGhhbmRsZXIuYXBwLk5FVFNDQVBFICYmIGhhbmRsZXIuYXBwLk5FVFNDQVBFKGJsb2NrKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlVW5rbm93bkFwcEV4dCA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICAgICAgICAgICAgICBibG9jay5hcHBEYXRhID0gcmVhZFN1YkJsb2NrcygpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogVGhpcyB3b24ndCB3b3JrIGlmIGEgaGFuZGxlciB3YW50cyB0byBtYXRjaCBvbiBhbnkgaWRlbnRpZmllci5cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5hcHAgJiYgaGFuZGxlci5hcHBbYmxvY2suaWRlbnRpZmllcl0gJiYgaGFuZGxlci5hcHBbYmxvY2suaWRlbnRpZmllcl0oYmxvY2spO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gc3QucmVhZEJ5dGUoKTsgLy8gQWx3YXlzIDExXG4gICAgICAgICAgICAgICAgYmxvY2suaWRlbnRpZmllciA9IHN0LnJlYWQoOCk7XG4gICAgICAgICAgICAgICAgYmxvY2suYXV0aENvZGUgPSBzdC5yZWFkKDMpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYmxvY2suaWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdORVRTQ0FQRSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZU5ldHNjYXBlRXh0KGJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VVbmtub3duQXBwRXh0KGJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBwYXJzZVVua25vd25FeHQgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgICAgICAgICBibG9jay5kYXRhID0gcmVhZFN1YkJsb2NrcygpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIudW5rbm93biAmJiBoYW5kbGVyLnVua25vd24oYmxvY2spO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgYmxvY2subGFiZWwgPSBzdC5yZWFkQnl0ZSgpO1xuICAgICAgICAgICAgc3dpdGNoIChibG9jay5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMHhGOTpcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suZXh0VHlwZSA9ICdnY2UnO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUdDRXh0KGJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAweEZFOlxuICAgICAgICAgICAgICAgICAgICBibG9jay5leHRUeXBlID0gJ2NvbSc7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlQ29tRXh0KGJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAweDAxOlxuICAgICAgICAgICAgICAgICAgICBibG9jay5leHRUeXBlID0gJ3B0ZSc7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlUFRFeHQoYmxvY2spO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkY6XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmV4dFR5cGUgPSAnYXBwJztcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VBcHBFeHQoYmxvY2spO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBibG9jay5leHRUeXBlID0gJ3Vua25vd24nO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZVVua25vd25FeHQoYmxvY2spO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcGFyc2VJbWcgPSBmdW5jdGlvbiAoaW1nKSB7XG4gICAgICAgICAgICB2YXIgZGVpbnRlcmxhY2UgPSBmdW5jdGlvbiAocGl4ZWxzLCB3aWR0aCkge1xuICAgICAgICAgICAgICAgIC8vIE9mIGNvdXJzZSB0aGlzIGRlZmVhdHMgdGhlIHB1cnBvc2Ugb2YgaW50ZXJsYWNpbmcuIEFuZCBpdCdzICpwcm9iYWJseSpcbiAgICAgICAgICAgICAgICAvLyB0aGUgbGVhc3QgZWZmaWNpZW50IHdheSBpdCdzIGV2ZXIgYmVlbiBpbXBsZW1lbnRlZC4gQnV0IG5ldmVydGhlbGVzcy4uLlxuICAgICAgICAgICAgICAgIHZhciBuZXdQaXhlbHMgPSBuZXcgQXJyYXkocGl4ZWxzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdmFyIHJvd3MgPSBwaXhlbHMubGVuZ3RoIC8gd2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGNwUm93ID0gZnVuY3Rpb24gKHRvUm93LCBmcm9tUm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcm9tUGl4ZWxzID0gcGl4ZWxzLnNsaWNlKGZyb21Sb3cgKiB3aWR0aCwgKGZyb21Sb3cgKyAxKSAqIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3UGl4ZWxzLnNwbGljZS5hcHBseShuZXdQaXhlbHMsIFt0b1JvdyAqIHdpZHRoLCB3aWR0aF0uY29uY2F0KGZyb21QaXhlbHMpKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gU2VlIGFwcGVuZGl4IEUuXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldHMgPSBbMCwgNCwgMiwgMV07XG4gICAgICAgICAgICAgICAgdmFyIHN0ZXBzID0gWzgsIDgsIDQsIDJdO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZyb21Sb3cgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHBhc3MgPSAwOyBwYXNzIDwgNDsgcGFzcysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHRvUm93ID0gb2Zmc2V0c1twYXNzXTsgdG9Sb3cgPCByb3dzOyB0b1JvdyArPSBzdGVwc1twYXNzXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3BSb3codG9Sb3csIGZyb21Sb3cpXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tUm93Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3UGl4ZWxzO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaW1nLmxlZnRQb3MgPSBzdC5yZWFkVW5zaWduZWQoKTtcbiAgICAgICAgICAgIGltZy50b3BQb3MgPSBzdC5yZWFkVW5zaWduZWQoKTtcbiAgICAgICAgICAgIGltZy53aWR0aCA9IHN0LnJlYWRVbnNpZ25lZCgpO1xuICAgICAgICAgICAgaW1nLmhlaWdodCA9IHN0LnJlYWRVbnNpZ25lZCgpO1xuXG4gICAgICAgICAgICB2YXIgYml0cyA9IGJ5dGVUb0JpdEFycihzdC5yZWFkQnl0ZSgpKTtcbiAgICAgICAgICAgIGltZy5sY3RGbGFnID0gYml0cy5zaGlmdCgpO1xuICAgICAgICAgICAgaW1nLmludGVybGFjZWQgPSBiaXRzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpbWcuc29ydGVkID0gYml0cy5zaGlmdCgpO1xuICAgICAgICAgICAgaW1nLnJlc2VydmVkID0gYml0cy5zcGxpY2UoMCwgMik7XG4gICAgICAgICAgICBpbWcubGN0U2l6ZSA9IGJpdHNUb051bShiaXRzLnNwbGljZSgwLCAzKSk7XG5cbiAgICAgICAgICAgIGlmIChpbWcubGN0RmxhZykge1xuICAgICAgICAgICAgICAgIGltZy5sY3QgPSBwYXJzZUNUKDEgPDwgKGltZy5sY3RTaXplICsgMSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbWcubHp3TWluQ29kZVNpemUgPSBzdC5yZWFkQnl0ZSgpO1xuXG4gICAgICAgICAgICB2YXIgbHp3RGF0YSA9IHJlYWRTdWJCbG9ja3MoKTtcblxuICAgICAgICAgICAgaW1nLnBpeGVscyA9IGx6d0RlY29kZShpbWcubHp3TWluQ29kZVNpemUsIGx6d0RhdGEpO1xuXG4gICAgICAgICAgICBpZiAoaW1nLmludGVybGFjZWQpIHsgLy8gTW92ZVxuICAgICAgICAgICAgICAgIGltZy5waXhlbHMgPSBkZWludGVybGFjZShpbWcucGl4ZWxzLCBpbWcud2lkdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoYW5kbGVyLmltZyAmJiBoYW5kbGVyLmltZyhpbWcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwYXJzZUJsb2NrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJsb2NrID0ge307XG4gICAgICAgICAgICBibG9jay5zZW50aW5lbCA9IHN0LnJlYWRCeXRlKCk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoU3RyaW5nLmZyb21DaGFyQ29kZShibG9jay5zZW50aW5lbCkpIHsgLy8gRm9yIGVhc2Ugb2YgbWF0Y2hpbmdcbiAgICAgICAgICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgICAgICAgICAgYmxvY2sudHlwZSA9ICdleHQnO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUV4dChibG9jayk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJywnOlxuICAgICAgICAgICAgICAgICAgICBibG9jay50eXBlID0gJ2ltZyc7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW1nKGJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnOyc6XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLnR5cGUgPSAnZW9mJztcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5lb2YgJiYgaGFuZGxlci5lb2YoYmxvY2spO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gYmxvY2s6IDB4JyArIGJsb2NrLnNlbnRpbmVsLnRvU3RyaW5nKDE2KSk7IC8vIFRPRE86IFBhZCB0aGlzIHdpdGggYSAwLlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYmxvY2sudHlwZSAhPT0gJ2VvZicpIHNldFRpbWVvdXQocGFyc2VCbG9jaywgMCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHBhcnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcGFyc2VIZWFkZXIoKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocGFyc2VCbG9jaywgMCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcGFyc2UoKTtcbiAgICB9O1xuXG4gICAgdmFyIFN1cGVyR2lmID0gZnVuY3Rpb24gKCBvcHRzICkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC8vdmlld3BvcnQgcG9zaXRpb25cbiAgICAgICAgICAgIHZwX2w6IDAsXG4gICAgICAgICAgICB2cF90OiAwLFxuICAgICAgICAgICAgdnBfdzogbnVsbCxcbiAgICAgICAgICAgIHZwX2g6IG51bGwsXG4gICAgICAgICAgICAvL2NhbnZhcyBzaXplc1xuICAgICAgICAgICAgY193OiBudWxsLFxuICAgICAgICAgICAgY19oOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgaW4gb3B0cyApIHsgb3B0aW9uc1tpXSA9IG9wdHNbaV0gfVxuICAgICAgICBpZiAob3B0aW9ucy52cF93ICYmIG9wdGlvbnMudnBfaCkgb3B0aW9ucy5pc192cCA9IHRydWU7XG5cbiAgICAgICAgdmFyIHN0cmVhbTtcbiAgICAgICAgdmFyIGhkcjtcblxuICAgICAgICB2YXIgbG9hZEVycm9yID0gbnVsbDtcbiAgICAgICAgdmFyIGxvYWRpbmcgPSBmYWxzZTtcblxuICAgICAgICB2YXIgdHJhbnNwYXJlbmN5ID0gbnVsbDtcbiAgICAgICAgdmFyIGRlbGF5ID0gbnVsbDtcbiAgICAgICAgdmFyIGRpc3Bvc2FsTWV0aG9kID0gbnVsbDtcbiAgICAgICAgdmFyIGRpc3Bvc2FsUmVzdG9yZUZyb21JZHggPSBudWxsO1xuICAgICAgICB2YXIgbGFzdERpc3Bvc2FsTWV0aG9kID0gbnVsbDtcbiAgICAgICAgdmFyIGZyYW1lID0gbnVsbDtcbiAgICAgICAgdmFyIGxhc3RJbWcgPSBudWxsO1xuXG4gICAgICAgIHZhciBwbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgdmFyIGZvcndhcmQgPSB0cnVlO1xuXG4gICAgICAgIHZhciBjdHhfc2NhbGVkID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGZyYW1lcyA9IFtdO1xuICAgICAgICB2YXIgZnJhbWVPZmZzZXRzID0gW107IC8vIGVsZW1lbnRzIGhhdmUgLnggYW5kIC55IHByb3BlcnRpZXNcblxuICAgICAgICB2YXIgZ2lmID0gb3B0aW9ucy5naWY7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hdXRvX3BsYXkgPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICBvcHRpb25zLmF1dG9fcGxheSA9ICghZ2lmLmdldEF0dHJpYnV0ZSgncmVsOmF1dG9fcGxheScpIHx8IGdpZi5nZXRBdHRyaWJ1dGUoJ3JlbDphdXRvX3BsYXknKSA9PSAnMScpO1xuXG4gICAgICAgIHZhciBvbkVuZExpc3RlbmVyID0gKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ29uX2VuZCcpID8gb3B0aW9ucy5vbl9lbmQgOiBudWxsKTtcbiAgICAgICAgdmFyIGxvb3BEZWxheSA9IChvcHRpb25zLmhhc093blByb3BlcnR5KCdsb29wX2RlbGF5JykgPyBvcHRpb25zLmxvb3BfZGVsYXkgOiAwKTtcbiAgICAgICAgdmFyIG92ZXJyaWRlTG9vcE1vZGUgPSAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnbG9vcF9tb2RlJykgPyBvcHRpb25zLmxvb3BfbW9kZSA6ICdhdXRvJyk7XG4gICAgICAgIHZhciBkcmF3V2hpbGVMb2FkaW5nID0gKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2RyYXdfd2hpbGVfbG9hZGluZycpID8gb3B0aW9ucy5kcmF3X3doaWxlX2xvYWRpbmcgOiB0cnVlKTtcbiAgICAgICAgdmFyIHNob3dQcm9ncmVzc0JhciA9IGRyYXdXaGlsZUxvYWRpbmcgPyAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnc2hvd19wcm9ncmVzc19iYXInKSA/IG9wdGlvbnMuc2hvd19wcm9ncmVzc19iYXIgOiB0cnVlKSA6IGZhbHNlO1xuICAgICAgICB2YXIgcHJvZ3Jlc3NCYXJIZWlnaHQgPSAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgncHJvZ3Jlc3NiYXJfaGVpZ2h0JykgPyBvcHRpb25zLnByb2dyZXNzYmFyX2hlaWdodCA6IDI1KTtcbiAgICAgICAgdmFyIHByb2dyZXNzQmFyQmFja2dyb3VuZENvbG9yID0gKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3Byb2dyZXNzYmFyX2JhY2tncm91bmRfY29sb3InKSA/IG9wdGlvbnMucHJvZ3Jlc3NiYXJfYmFja2dyb3VuZF9jb2xvciA6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNCknKTtcbiAgICAgICAgdmFyIHByb2dyZXNzQmFyRm9yZWdyb3VuZENvbG9yID0gKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3Byb2dyZXNzYmFyX2ZvcmVncm91bmRfY29sb3InKSA/IG9wdGlvbnMucHJvZ3Jlc3NiYXJfZm9yZWdyb3VuZF9jb2xvciA6ICdyZ2JhKDI1NSwwLDIyLC44KScpO1xuXG4gICAgICAgIHZhciBjbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyYW5zcGFyZW5jeSA9IG51bGw7XG4gICAgICAgICAgICBkZWxheSA9IG51bGw7XG4gICAgICAgICAgICBsYXN0RGlzcG9zYWxNZXRob2QgPSBkaXNwb3NhbE1ldGhvZDtcbiAgICAgICAgICAgIGRpc3Bvc2FsTWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgIGZyYW1lID0gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBYWFg6IFRoZXJlJ3MgcHJvYmFibHkgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSBjYXRjaGluZyBleGNlcHRpb25zIHdoZW5cbiAgICAgICAgLy8gY2FsbGJhY2tzIGFyZSBpbnZvbHZlZC5cbiAgICAgICAgdmFyIGRvUGFyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBhcnNlR0lGKHN0cmVhbSwgaGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZG9Mb2FkRXJyb3IoJ3BhcnNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRvVGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICB0b29sYmFyLmlubmVySFRNTCA9IHRleHQ7IC8vIGlubmVyVGV4dD8gRXNjYXBpbmc/IFdoYXRldmVyLlxuICAgICAgICAgICAgdG9vbGJhci5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzZXRTaXplcyA9IGZ1bmN0aW9uKHcsIGgpIHtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHcgKiBnZXRfY2FudmFzX3NjYWxlKCk7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaCAqIGdldF9jYW52YXNfc2NhbGUoKTtcbiAgICAgICAgICAgIHRvb2xiYXIuc3R5bGUubWluV2lkdGggPSAoIHcgKiBnZXRfY2FudmFzX3NjYWxlKCkgKSArICdweCc7XG5cbiAgICAgICAgICAgIHRtcENhbnZhcy53aWR0aCA9IHc7XG4gICAgICAgICAgICB0bXBDYW52YXMuaGVpZ2h0ID0gaDtcbiAgICAgICAgICAgIHRtcENhbnZhcy5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgICAgICAgICAgdG1wQ2FudmFzLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xuICAgICAgICAgICAgdG1wQ2FudmFzLmdldENvbnRleHQoJzJkJykuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzZXRGcmFtZU9mZnNldCA9IGZ1bmN0aW9uKGZyYW1lLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIGlmICghZnJhbWVPZmZzZXRzW2ZyYW1lXSkge1xuICAgICAgICAgICAgICAgIGZyYW1lT2Zmc2V0c1tmcmFtZV0gPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQueCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBmcmFtZU9mZnNldHNbZnJhbWVdLnggPSBvZmZzZXQueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0LnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZnJhbWVPZmZzZXRzW2ZyYW1lXS55ID0gb2Zmc2V0Lnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRvU2hvd1Byb2dyZXNzID0gZnVuY3Rpb24gKHBvcywgbGVuZ3RoLCBkcmF3KSB7XG4gICAgICAgICAgICBpZiAoZHJhdyAmJiBzaG93UHJvZ3Jlc3NCYXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcHJvZ3Jlc3NCYXJIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnQsIG1pZCwgdG9wLCB3aWR0aDtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5pc192cCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN0eF9zY2FsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IChvcHRpb25zLnZwX3QgKyBvcHRpb25zLnZwX2ggLSBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IG9wdGlvbnMudnBfbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZCA9IGxlZnQgKyAocG9zIC8gbGVuZ3RoKSAqIG9wdGlvbnMudnBfdztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gKG9wdGlvbnMudnBfdCArIG9wdGlvbnMudnBfaCAtIGhlaWdodCkgLyBnZXRfY2FudmFzX3NjYWxlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgLyBnZXRfY2FudmFzX3NjYWxlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gKG9wdGlvbnMudnBfbCAvIGdldF9jYW52YXNfc2NhbGUoKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlkID0gbGVmdCArIChwb3MgLyBsZW5ndGgpICogKG9wdGlvbnMudnBfdyAvIGdldF9jYW52YXNfc2NhbGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGNhbnZhcy53aWR0aCAvIGdldF9jYW52YXNfc2NhbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL3NvbWUgZGVidWdnaW5nLCBkcmF3IHJlY3QgYXJvdW5kIHZpZXdwb3J0XG4gICAgICAgICAgICAgICAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdHhfc2NhbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBvcHRpb25zLnZwX2wsIHQgPSBvcHRpb25zLnZwX3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSBvcHRpb25zLnZwX3csIGggPSBvcHRpb25zLnZwX2g7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gb3B0aW9ucy52cF9sL2dldF9jYW52YXNfc2NhbGUoKSwgdCA9IG9wdGlvbnMudnBfdC9nZXRfY2FudmFzX3NjYWxlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSBvcHRpb25zLnZwX3cvZ2V0X2NhbnZhc19zY2FsZSgpLCBoID0gb3B0aW9ucy52cF9oL2dldF9jYW52YXNfc2NhbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KGwsdCx3LGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSAoY2FudmFzLmhlaWdodCAtIGhlaWdodCkgLyAoY3R4X3NjYWxlZCA/IGdldF9jYW52YXNfc2NhbGUoKSA6IDEpO1xuICAgICAgICAgICAgICAgICAgICBtaWQgPSAoKHBvcyAvIGxlbmd0aCkgKiBjYW52YXMud2lkdGgpIC8gKGN0eF9zY2FsZWQgPyBnZXRfY2FudmFzX3NjYWxlKCkgOiAxKTtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBjYW52YXMud2lkdGggLyAoY3R4X3NjYWxlZCA/IGdldF9jYW52YXNfc2NhbGUoKSA6IDEgKTtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0IC89IGN0eF9zY2FsZWQgPyBnZXRfY2FudmFzX3NjYWxlKCkgOiAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBwcm9ncmVzc0JhckJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QobWlkLCB0b3AsIHdpZHRoIC0gbWlkLCBoZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHByb2dyZXNzQmFyRm9yZWdyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCB0b3AsIG1pZCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZG9Mb2FkRXJyb3IgPSBmdW5jdGlvbiAob3JpZ2luT2ZFcnJvcikge1xuICAgICAgICAgICAgdmFyIGRyYXdFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ2JsYWNrJztcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgb3B0aW9ucy5jX3cgPyBvcHRpb25zLmNfdyA6IGhkci53aWR0aCwgb3B0aW9ucy5jX2ggPyBvcHRpb25zLmNfaCA6IGhkci5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAzO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhvcHRpb25zLmNfdyA/IG9wdGlvbnMuY193IDogaGRyLndpZHRoLCBvcHRpb25zLmNfaCA/IG9wdGlvbnMuY19oIDogaGRyLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbygwLCBvcHRpb25zLmNfaCA/IG9wdGlvbnMuY19oIDogaGRyLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhvcHRpb25zLmNfdyA/IG9wdGlvbnMuY193IDogaGRyLndpZHRoLCAwKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBsb2FkRXJyb3IgPSBvcmlnaW5PZkVycm9yO1xuICAgICAgICAgICAgaGRyID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBnaWYud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBnaWYuaGVpZ2h0XG4gICAgICAgICAgICB9OyAvLyBGYWtlIGhlYWRlci5cbiAgICAgICAgICAgIGZyYW1lcyA9IFtdO1xuICAgICAgICAgICAgZHJhd0Vycm9yKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRvSGRyID0gZnVuY3Rpb24gKF9oZHIpIHtcbiAgICAgICAgICAgIGhkciA9IF9oZHI7XG4gICAgICAgICAgICBzZXRTaXplcyhoZHIud2lkdGgsIGhkci5oZWlnaHQpXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRvR0NFID0gZnVuY3Rpb24gKGdjZSkge1xuICAgICAgICAgICAgcHVzaEZyYW1lKCk7XG4gICAgICAgICAgICBjbGVhcigpO1xuICAgICAgICAgICAgdHJhbnNwYXJlbmN5ID0gZ2NlLnRyYW5zcGFyZW5jeUdpdmVuID8gZ2NlLnRyYW5zcGFyZW5jeUluZGV4IDogbnVsbDtcbiAgICAgICAgICAgIGRlbGF5ID0gZ2NlLmRlbGF5VGltZTtcbiAgICAgICAgICAgIGRpc3Bvc2FsTWV0aG9kID0gZ2NlLmRpc3Bvc2FsTWV0aG9kO1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBtdWNoIHRvIGRvIHdpdGggdGhlIHJlc3Qgb2YgR0NFLlxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwdXNoRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWZyYW1lKSByZXR1cm47XG4gICAgICAgICAgICBmcmFtZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZnJhbWUuZ2V0SW1hZ2VEYXRhKDAsIDAsIGhkci53aWR0aCwgaGRyLmhlaWdodCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXk6IGRlbGF5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZyYW1lT2Zmc2V0cy5wdXNoKHsgeDogMCwgeTogMCB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZG9JbWcgPSBmdW5jdGlvbiAoaW1nKSB7XG4gICAgICAgICAgICBpZiAoIWZyYW1lKSBmcmFtZSA9IHRtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICB2YXIgY3VycklkeCA9IGZyYW1lcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIC8vY3QgPSBjb2xvciB0YWJsZSwgZ2N0ID0gZ2xvYmFsIGNvbG9yIHRhYmxlXG4gICAgICAgICAgICB2YXIgY3QgPSBpbWcubGN0RmxhZyA/IGltZy5sY3QgOiBoZHIuZ2N0OyAvLyBUT0RPOiBXaGF0IGlmIG5laXRoZXIgZXhpc3RzP1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgRGlzcG9zYWwgbWV0aG9kIGluZGljYXRlcyB0aGUgd2F5IGluIHdoaWNoIHRoZSBncmFwaGljIGlzIHRvXG4gICAgICAgICAgICBiZSB0cmVhdGVkIGFmdGVyIGJlaW5nIGRpc3BsYXllZC5cblxuICAgICAgICAgICAgVmFsdWVzIDogICAgMCAtIE5vIGRpc3Bvc2FsIHNwZWNpZmllZC4gVGhlIGRlY29kZXIgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3QgcmVxdWlyZWQgdG8gdGFrZSBhbnkgYWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgMSAtIERvIG5vdCBkaXNwb3NlLiBUaGUgZ3JhcGhpYyBpcyB0byBiZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gcGxhY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAyIC0gUmVzdG9yZSB0byBiYWNrZ3JvdW5kIGNvbG9yLiBUaGUgYXJlYSB1c2VkIGJ5IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoaWMgbXVzdCBiZSByZXN0b3JlZCB0byB0aGUgYmFja2dyb3VuZCBjb2xvci5cbiAgICAgICAgICAgICAgICAgICAgICAgIDMgLSBSZXN0b3JlIHRvIHByZXZpb3VzLiBUaGUgZGVjb2RlciBpcyByZXF1aXJlZCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RvcmUgdGhlIGFyZWEgb3ZlcndyaXR0ZW4gYnkgdGhlIGdyYXBoaWMgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoYXQgd2FzIHRoZXJlIHByaW9yIHRvIHJlbmRlcmluZyB0aGUgZ3JhcGhpYy5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEltcG9ydGFudGx5LCBcInByZXZpb3VzXCIgbWVhbnMgdGhlIGZyYW1lIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgdGhlIGxhc3QgZGlzcG9zYWwgb2YgbWV0aG9kIDAsIDEsIG9yIDIuXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGN1cnJJZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3REaXNwb3NhbE1ldGhvZCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRvIHByZXZpb3VzXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGRpc3Bvc2VkIGV2ZXJ5IGZyYW1lIGluY2x1ZGluZyBmaXJzdCBmcmFtZSB1cCB0byB0aGlzIHBvaW50LCB0aGVuIHdlIGhhdmVcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gY29tcG9zaXRlZCBmcmFtZSB0byByZXN0b3JlIHRvLiBJbiB0aGlzIGNhc2UsIHJlc3RvcmUgdG8gYmFja2dyb3VuZCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzcG9zYWxSZXN0b3JlRnJvbUlkeCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBcdGZyYW1lLnB1dEltYWdlRGF0YShmcmFtZXNbZGlzcG9zYWxSZXN0b3JlRnJvbUlkeF0uZGF0YSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFx0ZnJhbWUuY2xlYXJSZWN0KGxhc3RJbWcubGVmdFBvcywgbGFzdEltZy50b3BQb3MsIGxhc3RJbWcud2lkdGgsIGxhc3RJbWcuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FsUmVzdG9yZUZyb21JZHggPSBjdXJySWR4IC0gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobGFzdERpc3Bvc2FsTWV0aG9kID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgdG8gYmFja2dyb3VuZCBjb2xvclxuICAgICAgICAgICAgICAgICAgICAvLyBCcm93c2VyIGltcGxlbWVudGF0aW9ucyBoaXN0b3JpY2FsbHkgcmVzdG9yZSB0byB0cmFuc3BhcmVudDsgd2UgZG8gdGhlIHNhbWUuXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cud2l6YXJkcy10b29sa2l0Lm9yZy9kaXNjb3Vyc2Utc2VydmVyL3ZpZXd0b3BpYy5waHA/Zj0xJnQ9MjExNzIjcDg2MDc5XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLmNsZWFyUmVjdChsYXN0SW1nLmxlZnRQb3MsIGxhc3RJbWcudG9wUG9zLCBsYXN0SW1nLndpZHRoLCBsYXN0SW1nLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZSwgVW5kZWZpbmVkL0RvIG5vdCBkaXNwb3NlLlxuICAgICAgICAgICAgLy8gZnJhbWUgY29udGFpbnMgZmluYWwgcGl4ZWwgZGF0YSBmcm9tIHRoZSBsYXN0IGZyYW1lOyBkbyBub3RoaW5nXG5cbiAgICAgICAgICAgIC8vR2V0IGV4aXN0aW5nIHBpeGVscyBmb3IgaW1nIHJlZ2lvbiBhZnRlciBhcHBseWluZyBkaXNwb3NhbCBtZXRob2RcbiAgICAgICAgICAgIHZhciBpbWdEYXRhID0gZnJhbWUuZ2V0SW1hZ2VEYXRhKGltZy5sZWZ0UG9zLCBpbWcudG9wUG9zLCBpbWcud2lkdGgsIGltZy5oZWlnaHQpO1xuXG4gICAgICAgICAgICAvL2FwcGx5IGNvbG9yIHRhYmxlIGNvbG9yc1xuICAgICAgICAgICAgaW1nLnBpeGVscy5mb3JFYWNoKGZ1bmN0aW9uIChwaXhlbCwgaSkge1xuICAgICAgICAgICAgICAgIC8vIGltZ0RhdGEuZGF0YSA9PT0gW1IsRyxCLEEsUixHLEIsQSwuLi5dXG4gICAgICAgICAgICAgICAgaWYgKHBpeGVsICE9PSB0cmFuc3BhcmVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1nRGF0YS5kYXRhW2kgKiA0ICsgMF0gPSBjdFtwaXhlbF1bMF07XG4gICAgICAgICAgICAgICAgICAgIGltZ0RhdGEuZGF0YVtpICogNCArIDFdID0gY3RbcGl4ZWxdWzFdO1xuICAgICAgICAgICAgICAgICAgICBpbWdEYXRhLmRhdGFbaSAqIDQgKyAyXSA9IGN0W3BpeGVsXVsyXTtcbiAgICAgICAgICAgICAgICAgICAgaW1nRGF0YS5kYXRhW2kgKiA0ICsgM10gPSAyNTU7IC8vIE9wYXF1ZS5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZnJhbWUucHV0SW1hZ2VEYXRhKGltZ0RhdGEsIGltZy5sZWZ0UG9zLCBpbWcudG9wUG9zKTtcblxuICAgICAgICAgICAgaWYgKCFjdHhfc2NhbGVkKSB7XG4gICAgICAgICAgICAgICAgY3R4LnNjYWxlKGdldF9jYW52YXNfc2NhbGUoKSxnZXRfY2FudmFzX3NjYWxlKCkpO1xuICAgICAgICAgICAgICAgIGN0eF9zY2FsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXZSBjb3VsZCB1c2UgdGhlIG9uLXBhZ2UgY2FudmFzIGRpcmVjdGx5LCBleGNlcHQgdGhhdCB3ZSBkcmF3IGEgcHJvZ3Jlc3NcbiAgICAgICAgICAgIC8vIGJhciBmb3IgZWFjaCBpbWFnZSBjaHVuayAobm90IGp1c3QgdGhlIGZpbmFsIGltYWdlKS5cbiAgICAgICAgICAgIGlmIChkcmF3V2hpbGVMb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0bXBDYW52YXMsIDAsIDApO1xuICAgICAgICAgICAgICAgIGRyYXdXaGlsZUxvYWRpbmcgPSBvcHRpb25zLmF1dG9fcGxheTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdEltZyA9IGltZztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcGxheWVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgICAgICB2YXIgaXRlcmF0aW9uQ291bnQgPSAwO1xuXG4gICAgICAgICAgICB2YXIgc2hvd2luZ0luZm8gPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBwaW5uZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBpbmRleCBvZiB0aGUgZnJhbWUgXCJ1cCBuZXh0XCIuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgZ2V0TmV4dEZyYW1lTm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhID0gKGZvcndhcmQgPyAxIDogLTEpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoaSArIGRlbHRhICsgZnJhbWVzLmxlbmd0aCkgJSBmcmFtZXMubGVuZ3RoO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHN0ZXBGcmFtZSA9IGZ1bmN0aW9uIChhbW91bnQpIHsgLy8gWFhYOiBOYW1lIGlzIGNvbmZ1c2luZy5cbiAgICAgICAgICAgICAgICBpID0gaSArIGFtb3VudDtcblxuICAgICAgICAgICAgICAgIHB1dEZyYW1lKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgc3RlcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0ZXBwaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB2YXIgY29tcGxldGVMb29wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob25FbmRMaXN0ZW5lciAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRW5kTGlzdGVuZXIoZ2lmKTtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0aW9uQ291bnQrKztcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVMb29wTW9kZSAhPT0gZmFsc2UgfHwgaXRlcmF0aW9uQ291bnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb1N0ZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBwaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIGRvU3RlcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcHBpbmcgPSBwbGF5aW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0ZXBwaW5nKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgc3RlcEZyYW1lKDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsYXkgPSBmcmFtZXNbaV0uZGVsYXkgKiAxMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWxheSkgZGVsYXkgPSAxMDA7IC8vIEZJWE1FOiBTaG91bGQgdGhpcyBldmVuIGRlZmF1bHQgYXQgYWxsPyBXaGF0IHNob3VsZCBpdCBiZT9cblxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dEZyYW1lTm8gPSBnZXROZXh0RnJhbWVObygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEZyYW1lTm8gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5ICs9IGxvb3BEZWxheTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY29tcGxldGVMb29wLCBkZWxheSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGRvU3RlcCwgZGVsYXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RlcHBpbmcpIHNldFRpbWVvdXQoZG9TdGVwLCAwKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSgpKTtcblxuICAgICAgICAgICAgdmFyIHB1dEZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgaSA9IHBhcnNlSW50KGksIDEwKTtcblxuICAgICAgICAgICAgICAgIGlmIChpID4gZnJhbWVzLmxlbmd0aCAtIDEpe1xuICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA8IDApe1xuICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBmcmFtZU9mZnNldHNbaV07XG5cbiAgICAgICAgICAgICAgICB0bXBDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLnB1dEltYWdlRGF0YShmcmFtZXNbaV0uZGF0YSwgb2Zmc2V0LngsIG9mZnNldC55KTtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJjb3B5XCI7XG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0bXBDYW52YXMsIDAsIDApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcGxheWluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RlcCgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2FkRXJyb3IpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoICEgKG9wdGlvbnMuY193ICYmIG9wdGlvbnMuY19oKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zY2FsZShnZXRfY2FudmFzX3NjYWxlKCksZ2V0X2NhbnZhc19zY2FsZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmF1dG9fcGxheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXRGcmFtZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdGVwOiBzdGVwLFxuICAgICAgICAgICAgICAgIHBsYXk6IHBsYXksXG4gICAgICAgICAgICAgICAgcGF1c2U6IHBhdXNlLFxuICAgICAgICAgICAgICAgIHBsYXlpbmc6IHBsYXlpbmcsXG4gICAgICAgICAgICAgICAgbW92ZV9yZWxhdGl2ZTogc3RlcEZyYW1lLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRfZnJhbWU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gaTsgfSxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZnJhbWVzLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgIG1vdmVfdG86IGZ1bmN0aW9uICggZnJhbWVfaWR4ICkge1xuICAgICAgICAgICAgICAgICAgICBpID0gZnJhbWVfaWR4O1xuICAgICAgICAgICAgICAgICAgICBwdXRGcmFtZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSgpKTtcblxuICAgICAgICB2YXIgZG9EZWNvZGVQcm9ncmVzcyA9IGZ1bmN0aW9uIChkcmF3KSB7XG4gICAgICAgICAgICBkb1Nob3dQcm9ncmVzcyhzdHJlYW0ucG9zLCBzdHJlYW0uZGF0YS5sZW5ndGgsIGRyYXcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBkb05vdGhpbmcgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbXtib29sZWFuPX0gZHJhdyBXaGV0aGVyIHRvIGRyYXcgcHJvZ3Jlc3MgYmFyIG9yIG5vdDsgdGhpcyBpcyBub3QgaWRlbXBvdGVudCBiZWNhdXNlIG9mIHRyYW5zbHVjZW5jeS5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgIE5vdGUgdGhhdCB0aGlzIG1lYW5zIHRoYXQgdGhlIHRleHQgd2lsbCBiZSB1bnN5bmNocm9uaXplZCB3aXRoIHRoZSBwcm9ncmVzcyBiYXIgb24gbm9uLWZyYW1lcztcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgIGJ1dCB0aG9zZSBhcmUgdHlwaWNhbGx5IHNvIHNtYWxsIChHQ0UgZXRjLikgdGhhdCBpdCBkb2Vzbid0IHJlYWxseSBtYXR0ZXIuIFRPRE86IERvIHRoaXMgcHJvcGVybHkuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgd2l0aFByb2dyZXNzID0gZnVuY3Rpb24gKGZuLCBkcmF3KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgZm4oYmxvY2spO1xuICAgICAgICAgICAgICAgIGRvRGVjb2RlUHJvZ3Jlc3MoZHJhdyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgdmFyIGhhbmRsZXIgPSB7XG4gICAgICAgICAgICBoZHI6IHdpdGhQcm9ncmVzcyhkb0hkciksXG4gICAgICAgICAgICBnY2U6IHdpdGhQcm9ncmVzcyhkb0dDRSksXG4gICAgICAgICAgICBjb206IHdpdGhQcm9ncmVzcyhkb05vdGhpbmcpLFxuICAgICAgICAgICAgLy8gSSBndWVzcyB0aGF0J3MgYWxsIGZvciBub3cuXG4gICAgICAgICAgICBhcHA6IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBJcyB0aGVyZSBtdWNoIHBvaW50IGluIGFjdHVhbGx5IHN1cHBvcnRpbmcgaXRlcmF0aW9ucz9cbiAgICAgICAgICAgICAgICBORVRTQ0FQRTogd2l0aFByb2dyZXNzKGRvTm90aGluZylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbWc6IHdpdGhQcm9ncmVzcyhkb0ltZywgdHJ1ZSksXG4gICAgICAgICAgICBlb2Y6IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICAgICAgICAgIC8vdG9vbGJhci5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgICAgICAgICAgcHVzaEZyYW1lKCk7XG4gICAgICAgICAgICAgICAgZG9EZWNvZGVQcm9ncmVzcyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKCAhIChvcHRpb25zLmNfdyAmJiBvcHRpb25zLmNfaCkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGhkci53aWR0aCAqIGdldF9jYW52YXNfc2NhbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhkci5oZWlnaHQgKiBnZXRfY2FudmFzX3NjYWxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBsYXllci5pbml0KCk7XG4gICAgICAgICAgICAgICAgbG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChsb2FkX2NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRfY2FsbGJhY2soZ2lmKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBnaWYucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIHRvb2xiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICAgICAgdG1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICAgICAgICAgIGRpdi53aWR0aCA9IGNhbnZhcy53aWR0aCA9IGdpZi53aWR0aDtcbiAgICAgICAgICAgIGRpdi5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0ID0gZ2lmLmhlaWdodDtcbiAgICAgICAgICAgIHRvb2xiYXIuc3R5bGUubWluV2lkdGggPSBnaWYud2lkdGggKyAncHgnO1xuXG4gICAgICAgICAgICBkaXYuY2xhc3NOYW1lID0gJ2pzZ2lmJztcbiAgICAgICAgICAgIHRvb2xiYXIuY2xhc3NOYW1lID0gJ2pzZ2lmX3Rvb2xiYXInO1xuICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQodG9vbGJhcik7XG5cbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZGl2LCBnaWYpO1xuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGdpZik7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNfdyAmJiBvcHRpb25zLmNfaCkgc2V0U2l6ZXMob3B0aW9ucy5jX3csIG9wdGlvbnMuY19oKTtcbiAgICAgICAgICAgIGluaXRpYWxpemVkPXRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldF9jYW52YXNfc2NhbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzY2FsZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1heF93aWR0aCAmJiBoZHIgJiYgaGRyLndpZHRoID4gb3B0aW9ucy5tYXhfd2lkdGgpIHtcbiAgICAgICAgICAgICAgICBzY2FsZSA9IG9wdGlvbnMubWF4X3dpZHRoIC8gaGRyLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NhbGUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbnZhcywgY3R4LCB0b29sYmFyLCB0bXBDYW52YXM7XG4gICAgICAgIHZhciBpbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB2YXIgbG9hZF9jYWxsYmFjayA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBsb2FkX3NldHVwID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChsb2FkaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGxvYWRfY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIGVsc2UgbG9hZF9jYWxsYmFjayA9IGZhbHNlO1xuXG4gICAgICAgICAgICBsb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGZyYW1lcyA9IFtdO1xuICAgICAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgICAgIGRpc3Bvc2FsUmVzdG9yZUZyb21JZHggPSBudWxsO1xuICAgICAgICAgICAgbGFzdERpc3Bvc2FsTWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgIGZyYW1lID0gbnVsbDtcbiAgICAgICAgICAgIGxhc3RJbWcgPSBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYWxjdWxhdGVEdXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZyYW1lcy5yZWR1Y2UoZnVuY3Rpb24oZHVyYXRpb24sIGZyYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGR1cmF0aW9uICsgZnJhbWUuZGVsYXk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBwbGF5IGNvbnRyb2xzXG4gICAgICAgICAgICBwbGF5OiBwbGF5ZXIucGxheSxcbiAgICAgICAgICAgIHBhdXNlOiBwbGF5ZXIucGF1c2UsXG4gICAgICAgICAgICBtb3ZlX3JlbGF0aXZlOiBwbGF5ZXIubW92ZV9yZWxhdGl2ZSxcbiAgICAgICAgICAgIG1vdmVfdG86IHBsYXllci5tb3ZlX3RvLFxuXG4gICAgICAgICAgICAvLyBnZXR0ZXJzIGZvciBpbnN0YW5jZSB2YXJzXG4gICAgICAgICAgICBnZXRfcGxheWluZyAgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBwbGF5aW5nIH0sXG4gICAgICAgICAgICBnZXRfY2FudmFzICAgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBjYW52YXMgfSxcbiAgICAgICAgICAgIGdldF9jYW52YXNfc2NhbGUgOiBmdW5jdGlvbigpIHsgcmV0dXJuIGdldF9jYW52YXNfc2NhbGUoKSB9LFxuICAgICAgICAgICAgZ2V0X2xvYWRpbmcgICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9hZGluZyB9LFxuICAgICAgICAgICAgZ2V0X2F1dG9fcGxheSAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gb3B0aW9ucy5hdXRvX3BsYXkgfSxcbiAgICAgICAgICAgIGdldF9sZW5ndGggICAgICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIHBsYXllci5sZW5ndGgoKSB9LFxuICAgICAgICAgICAgZ2V0X2ZyYW1lcyAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZnJhbWVzIH0sXG4gICAgICAgICAgICBnZXRfZHVyYXRpb24gICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBjYWxjdWxhdGVEdXJhdGlvbigpIH0sXG4gICAgICAgICAgICBnZXRfZHVyYXRpb25fbXMgIDogZnVuY3Rpb24oKSB7IHJldHVybiBjYWxjdWxhdGVEdXJhdGlvbigpICogMTAgfSxcbiAgICAgICAgICAgIGdldF9jdXJyZW50X2ZyYW1lOiBmdW5jdGlvbigpIHsgcmV0dXJuIHBsYXllci5jdXJyZW50X2ZyYW1lKCkgfSxcbiAgICAgICAgICAgIGxvYWRfdXJsOiBmdW5jdGlvbihzcmMsY2FsbGJhY2spe1xuICAgICAgICAgICAgICAgIGlmICghbG9hZF9zZXR1cChjYWxsYmFjaykpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHZhciBoID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgLy8gbmV3IGJyb3dzZXJzIChYTUxIdHRwUmVxdWVzdDItY29tcGxpYW50KVxuICAgICAgICAgICAgICAgIGgub3BlbignR0VUJywgc3JjLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIGlmICgnb3ZlcnJpZGVNaW1lVHlwZScgaW4gaCkge1xuICAgICAgICAgICAgICAgICAgICBoLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBvbGQgYnJvd3NlcnMgKFhNTEh0dHBSZXF1ZXN0LWNvbXBsaWFudClcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgncmVzcG9uc2VUeXBlJyBpbiBoKSB7XG4gICAgICAgICAgICAgICAgICAgIGgucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJRTkgKE1pY3Jvc29mdC5YTUxIVFRQLWNvbXBsaWFudClcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaC5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQtQ2hhcnNldCcsICd4LXVzZXItZGVmaW5lZCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGgub25sb2Fkc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2FpdCB1bnRpbCBjb25uZWN0aW9uIGlzIG9wZW5lZCB0byByZXBsYWNlIHRoZSBnaWYgZWxlbWVudCB3aXRoIGEgY2FudmFzIHRvIGF2b2lkIGEgYmxhbmsgaW1nXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5pdGlhbGl6ZWQpIGluaXQoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGgub25sb2FkID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb0xvYWRFcnJvcigneGhyIC0gcmVzcG9uc2UnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBlbXVsYXRpbmcgcmVzcG9uc2UgZmllbGQgZm9yIElFOVxuICAgICAgICAgICAgICAgICAgICBpZiAoISgncmVzcG9uc2UnIGluIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gbmV3IFZCQXJyYXkodGhpcy5yZXNwb25zZVRleHQpLnRvQXJyYXkoKS5tYXAoU3RyaW5nLmZyb21DaGFyQ29kZSkuam9pbignJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS50b1N0cmluZygpLmluZGV4T2YoXCJBcnJheUJ1ZmZlclwiKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbSA9IG5ldyBTdHJlYW0oZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZG9QYXJzZSwgMCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBoLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5sZW5ndGhDb21wdXRhYmxlKSBkb1Nob3dQcm9ncmVzcyhlLmxvYWRlZCwgZS50b3RhbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBoLm9uZXJyb3IgPSBmdW5jdGlvbigpIHsgZG9Mb2FkRXJyb3IoJ3hocicpOyB9O1xuICAgICAgICAgICAgICAgIGguc2VuZCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvYWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZF91cmwoZ2lmLmdldEF0dHJpYnV0ZSgncmVsOmFuaW1hdGVkX3NyYycpIHx8IGdpZi5zcmMsY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvYWRfcmF3OiBmdW5jdGlvbihhcnIsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsb2FkX3NldHVwKGNhbGxiYWNrKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICghaW5pdGlhbGl6ZWQpIGluaXQoKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0gPSBuZXcgU3RyZWFtKGFycik7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChkb1BhcnNlLCAwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRfZnJhbWVfb2Zmc2V0OiBzZXRGcmFtZU9mZnNldFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICByZXR1cm4gU3VwZXJHaWY7XG59KSk7XG5cblxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBLGFBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8OGi\n");

/***/ }),

/***/ "sRdV":
/*!*******************************************!*\
  !*** ./node_modules/linkify-it/lib/re.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nmodule.exports = function (opts) {\n  var re = {};\n\n  // Use direct extract instead of `regenerate` to reduse browserified size\n  re.src_Any = __webpack_require__(/*! uc.micro/properties/Any/regex */ \"y8fO\").source;\n  re.src_Cc  = __webpack_require__(/*! uc.micro/categories/Cc/regex */ \"p7ys\").source;\n  re.src_Z   = __webpack_require__(/*! uc.micro/categories/Z/regex */ \"T8I8\").source;\n  re.src_P   = __webpack_require__(/*! uc.micro/categories/P/regex */ \"fKCf\").source;\n\n  // \\p{\\Z\\P\\Cc\\CF} (white spaces + control + format + punctuation)\n  re.src_ZPCc = [ re.src_Z, re.src_P, re.src_Cc ].join('|');\n\n  // \\p{\\Z\\Cc} (white spaces + control)\n  re.src_ZCc = [ re.src_Z, re.src_Cc ].join('|');\n\n  // Experimental. List of chars, completely prohibited in links\n  // because can separate it from other part of text\n  var text_separators = '[><\\uff5c]';\n\n  // All possible word characters (everything without punctuation, spaces & controls)\n  // Defined via punctuation & spaces to save space\n  // Should be something like \\p{\\L\\N\\S\\M} (\\w but without `_`)\n  re.src_pseudo_letter       = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';\n  // The same as abothe but without [0-9]\n  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';\n\n  ////////////////////////////////////////////////////////////////////////////////\n\n  re.src_ip4 =\n\n    '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';\n\n  // Prohibit any of \"@/[]()\" in user/pass to avoid wrong domain fetch.\n  re.src_auth    = '(?:(?:(?!' + re.src_ZCc + '|[@/\\\\[\\\\]()]).)+@)?';\n\n  re.src_port =\n\n    '(?::(?:6(?:[0-4]\\\\d{3}|5(?:[0-4]\\\\d{2}|5(?:[0-2]\\\\d|3[0-5])))|[1-5]?\\\\d{1,4}))?';\n\n  re.src_host_terminator =\n\n    '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\\\d|\\\\.-|\\\\.(?!$|' + re.src_ZPCc + '))';\n\n  re.src_path =\n\n    '(?:' +\n      '[/?#]' +\n        '(?:' +\n          '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\\\]{}.,\"\\'?!\\\\-]).|' +\n          '\\\\[(?:(?!' + re.src_ZCc + '|\\\\]).)*\\\\]|' +\n          '\\\\((?:(?!' + re.src_ZCc + '|[)]).)*\\\\)|' +\n          '\\\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\\\}|' +\n          '\\\\\"(?:(?!' + re.src_ZCc + '|[\"]).)+\\\\\"|' +\n          \"\\\\'(?:(?!\" + re.src_ZCc + \"|[']).)+\\\\'|\" +\n          \"\\\\'(?=\" + re.src_pseudo_letter + '|[-]).|' +  // allow `I'm_king` if no pair found\n          '\\\\.{2,}[a-zA-Z0-9%/&]|' + // google has many dots in \"google search\" links (#66, #81).\n                                     // github has ... in commit range links,\n                                     // Restrict to\n                                     // - english\n                                     // - percent-encoded\n                                     // - parts of file path\n                                     // - params separator\n                                     // until more examples found.\n          '\\\\.(?!' + re.src_ZCc + '|[.]).|' +\n          (opts && opts['---'] ?\n            '\\\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate\n            :\n            '\\\\-+|'\n          ) +\n          '\\\\,(?!' + re.src_ZCc + ').|' +       // allow `,,,` in paths\n          '\\\\!+(?!' + re.src_ZCc + '|[!]).|' +  // allow `!!!` in paths, but not at the end\n          '\\\\?(?!' + re.src_ZCc + '|[?]).' +\n        ')+' +\n      '|\\\\/' +\n    ')?';\n\n  // Allow anything in markdown spec, forbid quote (\") at the first position\n  // because emails enclosed in quotes are far more common\n  re.src_email_name =\n\n    '[\\\\-;:&=\\\\+\\\\$,\\\\.a-zA-Z0-9_][\\\\-;:&=\\\\+\\\\$,\\\\\"\\\\.a-zA-Z0-9_]*';\n\n  re.src_xn =\n\n    'xn--[a-z0-9\\\\-]{1,59}';\n\n  // More to read about domain names\n  // http://serverfault.com/questions/638260/\n\n  re.src_domain_root =\n\n    // Allow letters & digits (http://test1)\n    '(?:' +\n      re.src_xn +\n      '|' +\n      re.src_pseudo_letter + '{1,63}' +\n    ')';\n\n  re.src_domain =\n\n    '(?:' +\n      re.src_xn +\n      '|' +\n      '(?:' + re.src_pseudo_letter + ')' +\n      '|' +\n      '(?:' + re.src_pseudo_letter + '(?:-|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' +\n    ')';\n\n  re.src_host =\n\n    '(?:' +\n    // Don't need IP check, because digits are already allowed in normal domain names\n    //   src_ip4 +\n    // '|' +\n      '(?:(?:(?:' + re.src_domain + ')\\\\.)*' + re.src_domain/*_root*/ + ')' +\n    ')';\n\n  re.tpl_host_fuzzy =\n\n    '(?:' +\n      re.src_ip4 +\n    '|' +\n      '(?:(?:(?:' + re.src_domain + ')\\\\.)+(?:%TLDS%))' +\n    ')';\n\n  re.tpl_host_no_ip_fuzzy =\n\n    '(?:(?:(?:' + re.src_domain + ')\\\\.)+(?:%TLDS%))';\n\n  re.src_host_strict =\n\n    re.src_host + re.src_host_terminator;\n\n  re.tpl_host_fuzzy_strict =\n\n    re.tpl_host_fuzzy + re.src_host_terminator;\n\n  re.src_host_port_strict =\n\n    re.src_host + re.src_port + re.src_host_terminator;\n\n  re.tpl_host_port_fuzzy_strict =\n\n    re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;\n\n  re.tpl_host_port_no_ip_fuzzy_strict =\n\n    re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;\n\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Main rules\n\n  // Rude test fuzzy links by host, for quick deny\n  re.tpl_host_fuzzy_test =\n\n    'localhost|www\\\\.|\\\\.\\\\d{1,3}\\\\.|(?:\\\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';\n\n  re.tpl_email_fuzzy =\n\n      '(^|' + text_separators + '|\"|\\\\(|' + re.src_ZCc + ')' +\n      '(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';\n\n  re.tpl_link_fuzzy =\n      // Fuzzy link can't be prepended with .:/\\- and non punctuation.\n      // but can start with > (markdown blockquote)\n      '(^|(?![.:/\\\\-_@])(?:[$+<=>^`|\\uff5c]|' + re.src_ZPCc + '))' +\n      '((?![$+<=>^`|\\uff5c])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';\n\n  re.tpl_link_no_ip_fuzzy =\n      // Fuzzy link can't be prepended with .:/\\- and non punctuation.\n      // but can start with > (markdown blockquote)\n      '(^|(?![.:/\\\\-_@])(?:[$+<=>^`|\\uff5c]|' + re.src_ZPCc + '))' +\n      '((?![$+<=>^`|\\uff5c])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';\n\n  return re;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic1JkVi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saW5raWZ5LWl0L2xpYi9yZS5qcz9iMTE3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciByZSA9IHt9O1xuXG4gIC8vIFVzZSBkaXJlY3QgZXh0cmFjdCBpbnN0ZWFkIG9mIGByZWdlbmVyYXRlYCB0byByZWR1c2UgYnJvd3NlcmlmaWVkIHNpemVcbiAgcmUuc3JjX0FueSA9IHJlcXVpcmUoJ3VjLm1pY3JvL3Byb3BlcnRpZXMvQW55L3JlZ2V4Jykuc291cmNlO1xuICByZS5zcmNfQ2MgID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9DYy9yZWdleCcpLnNvdXJjZTtcbiAgcmUuc3JjX1ogICA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleCcpLnNvdXJjZTtcbiAgcmUuc3JjX1AgICA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleCcpLnNvdXJjZTtcblxuICAvLyBcXHB7XFxaXFxQXFxDY1xcQ0Z9ICh3aGl0ZSBzcGFjZXMgKyBjb250cm9sICsgZm9ybWF0ICsgcHVuY3R1YXRpb24pXG4gIHJlLnNyY19aUENjID0gWyByZS5zcmNfWiwgcmUuc3JjX1AsIHJlLnNyY19DYyBdLmpvaW4oJ3wnKTtcblxuICAvLyBcXHB7XFxaXFxDY30gKHdoaXRlIHNwYWNlcyArIGNvbnRyb2wpXG4gIHJlLnNyY19aQ2MgPSBbIHJlLnNyY19aLCByZS5zcmNfQ2MgXS5qb2luKCd8Jyk7XG5cbiAgLy8gRXhwZXJpbWVudGFsLiBMaXN0IG9mIGNoYXJzLCBjb21wbGV0ZWx5IHByb2hpYml0ZWQgaW4gbGlua3NcbiAgLy8gYmVjYXVzZSBjYW4gc2VwYXJhdGUgaXQgZnJvbSBvdGhlciBwYXJ0IG9mIHRleHRcbiAgdmFyIHRleHRfc2VwYXJhdG9ycyA9ICdbPjxcXHVmZjVjXSc7XG5cbiAgLy8gQWxsIHBvc3NpYmxlIHdvcmQgY2hhcmFjdGVycyAoZXZlcnl0aGluZyB3aXRob3V0IHB1bmN0dWF0aW9uLCBzcGFjZXMgJiBjb250cm9scylcbiAgLy8gRGVmaW5lZCB2aWEgcHVuY3R1YXRpb24gJiBzcGFjZXMgdG8gc2F2ZSBzcGFjZVxuICAvLyBTaG91bGQgYmUgc29tZXRoaW5nIGxpa2UgXFxwe1xcTFxcTlxcU1xcTX0gKFxcdyBidXQgd2l0aG91dCBgX2ApXG4gIHJlLnNyY19wc2V1ZG9fbGV0dGVyICAgICAgID0gJyg/Oig/IScgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfCcgKyByZS5zcmNfWlBDYyArICcpJyArIHJlLnNyY19BbnkgKyAnKSc7XG4gIC8vIFRoZSBzYW1lIGFzIGFib3RoZSBidXQgd2l0aG91dCBbMC05XVxuICAvLyB2YXIgc3JjX3BzZXVkb19sZXR0ZXJfbm9uX2QgPSAnKD86KD8hWzAtOV18JyArIHNyY19aUENjICsgJyknICsgc3JjX0FueSArICcpJztcblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIHJlLnNyY19pcDQgPVxuXG4gICAgJyg/OigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFxcXC4pezN9KDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPyknO1xuXG4gIC8vIFByb2hpYml0IGFueSBvZiBcIkAvW10oKVwiIGluIHVzZXIvcGFzcyB0byBhdm9pZCB3cm9uZyBkb21haW4gZmV0Y2guXG4gIHJlLnNyY19hdXRoICAgID0gJyg/Oig/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbQC9cXFxcW1xcXFxdKCldKS4pK0ApPyc7XG5cbiAgcmUuc3JjX3BvcnQgPVxuXG4gICAgJyg/OjooPzo2KD86WzAtNF1cXFxcZHszfXw1KD86WzAtNF1cXFxcZHsyfXw1KD86WzAtMl1cXFxcZHwzWzAtNV0pKSl8WzEtNV0/XFxcXGR7MSw0fSkpPyc7XG5cbiAgcmUuc3JjX2hvc3RfdGVybWluYXRvciA9XG5cbiAgICAnKD89JHwnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3wnICsgcmUuc3JjX1pQQ2MgKyAnKSg/IS18X3w6XFxcXGR8XFxcXC4tfFxcXFwuKD8hJHwnICsgcmUuc3JjX1pQQ2MgKyAnKSknO1xuXG4gIHJlLnNyY19wYXRoID1cblxuICAgICcoPzonICtcbiAgICAgICdbLz8jXScgK1xuICAgICAgICAnKD86JyArXG4gICAgICAgICAgJyg/IScgKyByZS5zcmNfWkNjICsgJ3wnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3xbKClbXFxcXF17fS4sXCJcXCc/IVxcXFwtXSkufCcgK1xuICAgICAgICAgICdcXFxcWyg/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xcXFxcXSkuKSpcXFxcXXwnICtcbiAgICAgICAgICAnXFxcXCgoPzooPyEnICsgcmUuc3JjX1pDYyArICd8WyldKS4pKlxcXFwpfCcgK1xuICAgICAgICAgICdcXFxceyg/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbfV0pLikqXFxcXH18JyArXG4gICAgICAgICAgJ1xcXFxcIig/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbXCJdKS4pK1xcXFxcInwnICtcbiAgICAgICAgICBcIlxcXFwnKD86KD8hXCIgKyByZS5zcmNfWkNjICsgXCJ8WyddKS4pK1xcXFwnfFwiICtcbiAgICAgICAgICBcIlxcXFwnKD89XCIgKyByZS5zcmNfcHNldWRvX2xldHRlciArICd8Wy1dKS58JyArICAvLyBhbGxvdyBgSSdtX2tpbmdgIGlmIG5vIHBhaXIgZm91bmRcbiAgICAgICAgICAnXFxcXC57Mix9W2EtekEtWjAtOSUvJl18JyArIC8vIGdvb2dsZSBoYXMgbWFueSBkb3RzIGluIFwiZ29vZ2xlIHNlYXJjaFwiIGxpbmtzICgjNjYsICM4MSkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2l0aHViIGhhcyAuLi4gaW4gY29tbWl0IHJhbmdlIGxpbmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RyaWN0IHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSBlbmdsaXNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSBwZXJjZW50LWVuY29kZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIHBhcnRzIG9mIGZpbGUgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gcGFyYW1zIHNlcGFyYXRvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVudGlsIG1vcmUgZXhhbXBsZXMgZm91bmQuXG4gICAgICAgICAgJ1xcXFwuKD8hJyArIHJlLnNyY19aQ2MgKyAnfFsuXSkufCcgK1xuICAgICAgICAgIChvcHRzICYmIG9wdHNbJy0tLSddID9cbiAgICAgICAgICAgICdcXFxcLSg/IS0tKD86W14tXXwkKSkoPzotKil8JyAvLyBgLS0tYCA9PiBsb25nIGRhc2gsIHRlcm1pbmF0ZVxuICAgICAgICAgICAgOlxuICAgICAgICAgICAgJ1xcXFwtK3wnXG4gICAgICAgICAgKSArXG4gICAgICAgICAgJ1xcXFwsKD8hJyArIHJlLnNyY19aQ2MgKyAnKS58JyArICAgICAgIC8vIGFsbG93IGAsLCxgIGluIHBhdGhzXG4gICAgICAgICAgJ1xcXFwhKyg/IScgKyByZS5zcmNfWkNjICsgJ3xbIV0pLnwnICsgIC8vIGFsbG93IGAhISFgIGluIHBhdGhzLCBidXQgbm90IGF0IHRoZSBlbmRcbiAgICAgICAgICAnXFxcXD8oPyEnICsgcmUuc3JjX1pDYyArICd8Wz9dKS4nICtcbiAgICAgICAgJykrJyArXG4gICAgICAnfFxcXFwvJyArXG4gICAgJyk/JztcblxuICAvLyBBbGxvdyBhbnl0aGluZyBpbiBtYXJrZG93biBzcGVjLCBmb3JiaWQgcXVvdGUgKFwiKSBhdCB0aGUgZmlyc3QgcG9zaXRpb25cbiAgLy8gYmVjYXVzZSBlbWFpbHMgZW5jbG9zZWQgaW4gcXVvdGVzIGFyZSBmYXIgbW9yZSBjb21tb25cbiAgcmUuc3JjX2VtYWlsX25hbWUgPVxuXG4gICAgJ1tcXFxcLTs6Jj1cXFxcK1xcXFwkLFxcXFwuYS16QS1aMC05X11bXFxcXC07OiY9XFxcXCtcXFxcJCxcXFxcXCJcXFxcLmEtekEtWjAtOV9dKic7XG5cbiAgcmUuc3JjX3huID1cblxuICAgICd4bi0tW2EtejAtOVxcXFwtXXsxLDU5fSc7XG5cbiAgLy8gTW9yZSB0byByZWFkIGFib3V0IGRvbWFpbiBuYW1lc1xuICAvLyBodHRwOi8vc2VydmVyZmF1bHQuY29tL3F1ZXN0aW9ucy82MzgyNjAvXG5cbiAgcmUuc3JjX2RvbWFpbl9yb290ID1cblxuICAgIC8vIEFsbG93IGxldHRlcnMgJiBkaWdpdHMgKGh0dHA6Ly90ZXN0MSlcbiAgICAnKD86JyArXG4gICAgICByZS5zcmNfeG4gK1xuICAgICAgJ3wnICtcbiAgICAgIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJ3sxLDYzfScgK1xuICAgICcpJztcblxuICByZS5zcmNfZG9tYWluID1cblxuICAgICcoPzonICtcbiAgICAgIHJlLnNyY194biArXG4gICAgICAnfCcgK1xuICAgICAgJyg/OicgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcpJyArXG4gICAgICAnfCcgK1xuICAgICAgJyg/OicgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcoPzotfCcgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcpezAsNjF9JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyknICtcbiAgICAnKSc7XG5cbiAgcmUuc3JjX2hvc3QgPVxuXG4gICAgJyg/OicgK1xuICAgIC8vIERvbid0IG5lZWQgSVAgY2hlY2ssIGJlY2F1c2UgZGlnaXRzIGFyZSBhbHJlYWR5IGFsbG93ZWQgaW4gbm9ybWFsIGRvbWFpbiBuYW1lc1xuICAgIC8vICAgc3JjX2lwNCArXG4gICAgLy8gJ3wnICtcbiAgICAgICcoPzooPzooPzonICsgcmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKicgKyByZS5zcmNfZG9tYWluLypfcm9vdCovICsgJyknICtcbiAgICAnKSc7XG5cbiAgcmUudHBsX2hvc3RfZnV6enkgPVxuXG4gICAgJyg/OicgK1xuICAgICAgcmUuc3JjX2lwNCArXG4gICAgJ3wnICtcbiAgICAgICcoPzooPzooPzonICsgcmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKyg/OiVUTERTJSkpJyArXG4gICAgJyknO1xuXG4gIHJlLnRwbF9ob3N0X25vX2lwX2Z1enp5ID1cblxuICAgICcoPzooPzooPzonICsgcmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKyg/OiVUTERTJSkpJztcblxuICByZS5zcmNfaG9zdF9zdHJpY3QgPVxuXG4gICAgcmUuc3JjX2hvc3QgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnRwbF9ob3N0X2Z1enp5X3N0cmljdCA9XG5cbiAgICByZS50cGxfaG9zdF9mdXp6eSArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUuc3JjX2hvc3RfcG9ydF9zdHJpY3QgPVxuXG4gICAgcmUuc3JjX2hvc3QgKyByZS5zcmNfcG9ydCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUudHBsX2hvc3RfcG9ydF9mdXp6eV9zdHJpY3QgPVxuXG4gICAgcmUudHBsX2hvc3RfZnV6enkgKyByZS5zcmNfcG9ydCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUudHBsX2hvc3RfcG9ydF9ub19pcF9mdXp6eV9zdHJpY3QgPVxuXG4gICAgcmUudHBsX2hvc3Rfbm9faXBfZnV6enkgKyByZS5zcmNfcG9ydCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBNYWluIHJ1bGVzXG5cbiAgLy8gUnVkZSB0ZXN0IGZ1enp5IGxpbmtzIGJ5IGhvc3QsIGZvciBxdWljayBkZW55XG4gIHJlLnRwbF9ob3N0X2Z1enp5X3Rlc3QgPVxuXG4gICAgJ2xvY2FsaG9zdHx3d3dcXFxcLnxcXFxcLlxcXFxkezEsM31cXFxcLnwoPzpcXFxcLig/OiVUTERTJSkoPzonICsgcmUuc3JjX1pQQ2MgKyAnfD58JCkpJztcblxuICByZS50cGxfZW1haWxfZnV6enkgPVxuXG4gICAgICAnKF58JyArIHRleHRfc2VwYXJhdG9ycyArICd8XCJ8XFxcXCh8JyArIHJlLnNyY19aQ2MgKyAnKScgK1xuICAgICAgJygnICsgcmUuc3JjX2VtYWlsX25hbWUgKyAnQCcgKyByZS50cGxfaG9zdF9mdXp6eV9zdHJpY3QgKyAnKSc7XG5cbiAgcmUudHBsX2xpbmtfZnV6enkgPVxuICAgICAgLy8gRnV6enkgbGluayBjYW4ndCBiZSBwcmVwZW5kZWQgd2l0aCAuOi9cXC0gYW5kIG5vbiBwdW5jdHVhdGlvbi5cbiAgICAgIC8vIGJ1dCBjYW4gc3RhcnQgd2l0aCA+IChtYXJrZG93biBibG9ja3F1b3RlKVxuICAgICAgJyhefCg/IVsuOi9cXFxcLV9AXSkoPzpbJCs8PT5eYHxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSknICtcbiAgICAgICcoKD8hWyQrPD0+XmB8XFx1ZmY1Y10pJyArIHJlLnRwbF9ob3N0X3BvcnRfZnV6enlfc3RyaWN0ICsgcmUuc3JjX3BhdGggKyAnKSc7XG5cbiAgcmUudHBsX2xpbmtfbm9faXBfZnV6enkgPVxuICAgICAgLy8gRnV6enkgbGluayBjYW4ndCBiZSBwcmVwZW5kZWQgd2l0aCAuOi9cXC0gYW5kIG5vbiBwdW5jdHVhdGlvbi5cbiAgICAgIC8vIGJ1dCBjYW4gc3RhcnQgd2l0aCA+IChtYXJrZG93biBibG9ja3F1b3RlKVxuICAgICAgJyhefCg/IVsuOi9cXFxcLV9AXSkoPzpbJCs8PT5eYHxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSknICtcbiAgICAgICcoKD8hWyQrPD0+XmB8XFx1ZmY1Y10pJyArIHJlLnRwbF9ob3N0X3BvcnRfbm9faXBfZnV6enlfc3RyaWN0ICsgcmUuc3JjX3BhdGggKyAnKSc7XG5cbiAgcmV0dXJuIHJlO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///sRdV\n");

/***/ })

}]);