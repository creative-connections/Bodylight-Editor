(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~7680cb85"],{

/***/ "/FzH":
/*!**************************************************!*\
  !*** ./node_modules/dygraphs/src/iframe-tarp.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dygraph-utils */ \"venr\");\n/**\n * To create a \"drag\" interaction, you typically register a mousedown event\n * handler on the element where the drag begins. In that handler, you register a\n * mouseup handler on the window to determine when the mouse is released,\n * wherever that release happens. This works well, except when the user releases\n * the mouse over an off-domain iframe. In that case, the mouseup event is\n * handled by the iframe and never bubbles up to the window handler.\n *\n * To deal with this issue, we cover iframes with high z-index divs to make sure\n * they don't capture mouseup.\n *\n * Usage:\n * element.addEventListener('mousedown', function() {\n *   var tarper = new IFrameTarp();\n *   tarper.cover();\n *   var mouseUpHandler = function() {\n *     ...\n *     window.removeEventListener(mouseUpHandler);\n *     tarper.uncover();\n *   };\n *   window.addEventListener('mouseup', mouseUpHandler);\n * };\n *\n * @constructor\n */\n\n\nfunction IFrameTarp() {\n  /** @type {Array.<!HTMLDivElement>} */\n  this.tarps = [];\n};\n\n/**\n * Find all the iframes in the document and cover them with high z-index\n * transparent divs.\n */\nIFrameTarp.prototype.cover = function() {\n  var iframes = document.getElementsByTagName(\"iframe\");\n  for (var i = 0; i < iframes.length; i++) {\n    var iframe = iframes[i];\n    var pos = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"findPos\"](iframe),\n        x = pos.x,\n        y = pos.y,\n        width = iframe.offsetWidth,\n        height = iframe.offsetHeight;\n\n    var div = document.createElement(\"div\");\n    div.style.position = \"absolute\";\n    div.style.left = x + 'px';\n    div.style.top = y + 'px';\n    div.style.width = width + 'px';\n    div.style.height = height + 'px';\n    div.style.zIndex = 999;\n    document.body.appendChild(div);\n    this.tarps.push(div);\n  }\n};\n\n/**\n * Remove all the iframe covers. You should call this in a mouseup handler.\n */\nIFrameTarp.prototype.uncover = function() {\n  for (var i = 0; i < this.tarps.length; i++) {\n    this.tarps[i].parentNode.removeChild(this.tarps[i]);\n  }\n  this.tarps = [];\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (IFrameTarp);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL0Z6SC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9keWdyYXBocy9zcmMvaWZyYW1lLXRhcnAuanM/ZmM1YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRvIGNyZWF0ZSBhIFwiZHJhZ1wiIGludGVyYWN0aW9uLCB5b3UgdHlwaWNhbGx5IHJlZ2lzdGVyIGEgbW91c2Vkb3duIGV2ZW50XG4gKiBoYW5kbGVyIG9uIHRoZSBlbGVtZW50IHdoZXJlIHRoZSBkcmFnIGJlZ2lucy4gSW4gdGhhdCBoYW5kbGVyLCB5b3UgcmVnaXN0ZXIgYVxuICogbW91c2V1cCBoYW5kbGVyIG9uIHRoZSB3aW5kb3cgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIG1vdXNlIGlzIHJlbGVhc2VkLFxuICogd2hlcmV2ZXIgdGhhdCByZWxlYXNlIGhhcHBlbnMuIFRoaXMgd29ya3Mgd2VsbCwgZXhjZXB0IHdoZW4gdGhlIHVzZXIgcmVsZWFzZXNcbiAqIHRoZSBtb3VzZSBvdmVyIGFuIG9mZi1kb21haW4gaWZyYW1lLiBJbiB0aGF0IGNhc2UsIHRoZSBtb3VzZXVwIGV2ZW50IGlzXG4gKiBoYW5kbGVkIGJ5IHRoZSBpZnJhbWUgYW5kIG5ldmVyIGJ1YmJsZXMgdXAgdG8gdGhlIHdpbmRvdyBoYW5kbGVyLlxuICpcbiAqIFRvIGRlYWwgd2l0aCB0aGlzIGlzc3VlLCB3ZSBjb3ZlciBpZnJhbWVzIHdpdGggaGlnaCB6LWluZGV4IGRpdnMgdG8gbWFrZSBzdXJlXG4gKiB0aGV5IGRvbid0IGNhcHR1cmUgbW91c2V1cC5cbiAqXG4gKiBVc2FnZTpcbiAqIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24oKSB7XG4gKiAgIHZhciB0YXJwZXIgPSBuZXcgSUZyYW1lVGFycCgpO1xuICogICB0YXJwZXIuY292ZXIoKTtcbiAqICAgdmFyIG1vdXNlVXBIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgLi4uXG4gKiAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIobW91c2VVcEhhbmRsZXIpO1xuICogICAgIHRhcnBlci51bmNvdmVyKCk7XG4gKiAgIH07XG4gKiAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2VVcEhhbmRsZXIpO1xuICogfTtcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi9keWdyYXBoLXV0aWxzJztcblxuZnVuY3Rpb24gSUZyYW1lVGFycCgpIHtcbiAgLyoqIEB0eXBlIHtBcnJheS48IUhUTUxEaXZFbGVtZW50Pn0gKi9cbiAgdGhpcy50YXJwcyA9IFtdO1xufTtcblxuLyoqXG4gKiBGaW5kIGFsbCB0aGUgaWZyYW1lcyBpbiB0aGUgZG9jdW1lbnQgYW5kIGNvdmVyIHRoZW0gd2l0aCBoaWdoIHotaW5kZXhcbiAqIHRyYW5zcGFyZW50IGRpdnMuXG4gKi9cbklGcmFtZVRhcnAucHJvdG90eXBlLmNvdmVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpZnJhbWVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpZnJhbWVcIik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaWZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpZnJhbWUgPSBpZnJhbWVzW2ldO1xuICAgIHZhciBwb3MgPSB1dGlscy5maW5kUG9zKGlmcmFtZSksXG4gICAgICAgIHggPSBwb3MueCxcbiAgICAgICAgeSA9IHBvcy55LFxuICAgICAgICB3aWR0aCA9IGlmcmFtZS5vZmZzZXRXaWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gaWZyYW1lLm9mZnNldEhlaWdodDtcblxuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBkaXYuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgIGRpdi5zdHlsZS50b3AgPSB5ICsgJ3B4JztcbiAgICBkaXYuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgZGl2LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgZGl2LnN0eWxlLnpJbmRleCA9IDk5OTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgdGhpcy50YXJwcy5wdXNoKGRpdik7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCB0aGUgaWZyYW1lIGNvdmVycy4gWW91IHNob3VsZCBjYWxsIHRoaXMgaW4gYSBtb3VzZXVwIGhhbmRsZXIuXG4gKi9cbklGcmFtZVRhcnAucHJvdG90eXBlLnVuY292ZXIgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRhcnBzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy50YXJwc1tpXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMudGFycHNbaV0pO1xuICB9XG4gIHRoaXMudGFycHMgPSBbXTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IElGcmFtZVRhcnA7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:////FzH\n");

/***/ }),

/***/ "CnfQ":
/*!***********************************************************!*\
  !*** ./node_modules/dygraphs/src/plugins/chart-labels.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n/*global Dygraph:false */\n\n\n\n// TODO(danvk): move chart label options out of dygraphs and into the plugin.\n// TODO(danvk): only tear down & rebuild the DIVs when it's necessary.\n\nvar chart_labels = function() {\n  this.title_div_ = null;\n  this.xlabel_div_ = null;\n  this.ylabel_div_ = null;\n  this.y2label_div_ = null;\n};\n\nchart_labels.prototype.toString = function() {\n  return \"ChartLabels Plugin\";\n};\n\nchart_labels.prototype.activate = function(g) {\n  return {\n    layout: this.layout,\n    // clearChart: this.clearChart,\n    didDrawChart: this.didDrawChart\n  };\n};\n\n// QUESTION: should there be a plugin-utils.js?\nvar createDivInRect = function(r) {\n  var div = document.createElement('div');\n  div.style.position = 'absolute';\n  div.style.left = r.x + 'px';\n  div.style.top = r.y + 'px';\n  div.style.width = r.w + 'px';\n  div.style.height = r.h + 'px';\n  return div;\n};\n\n// Detach and null out any existing nodes.\nchart_labels.prototype.detachLabels_ = function() {\n  var els = [ this.title_div_,\n              this.xlabel_div_,\n              this.ylabel_div_,\n              this.y2label_div_ ];\n  for (var i = 0; i < els.length; i++) {\n    var el = els[i];\n    if (!el) continue;\n    if (el.parentNode) el.parentNode.removeChild(el);\n  }\n\n  this.title_div_ = null;\n  this.xlabel_div_ = null;\n  this.ylabel_div_ = null;\n  this.y2label_div_ = null;\n};\n\nvar createRotatedDiv = function(g, box, axis, classes, html) {\n  // TODO(danvk): is this outer div actually necessary?\n  var div = document.createElement(\"div\");\n  div.style.position = 'absolute';\n  if (axis == 1) {\n    // NOTE: this is cheating. Should be positioned relative to the box.\n    div.style.left = '0px';\n  } else {\n    div.style.left = box.x + 'px';\n  }\n  div.style.top = box.y + 'px';\n  div.style.width = box.w + 'px';\n  div.style.height = box.h + 'px';\n  div.style.fontSize = (g.getOption('yLabelWidth') - 2) + 'px';\n\n  var inner_div = document.createElement(\"div\");\n  inner_div.style.position = 'absolute';\n  inner_div.style.width = box.h + 'px';\n  inner_div.style.height = box.w + 'px';\n  inner_div.style.top = (box.h / 2 - box.w / 2) + 'px';\n  inner_div.style.left = (box.w / 2 - box.h / 2) + 'px';\n  // TODO: combine inner_div and class_div.\n  inner_div.className = 'dygraph-label-rotate-' + (axis == 1 ? 'right' : 'left');\n\n  var class_div = document.createElement(\"div\");\n  class_div.className = classes;\n  class_div.innerHTML = html;\n\n  inner_div.appendChild(class_div);\n  div.appendChild(inner_div);\n  return div;\n};\n\nchart_labels.prototype.layout = function(e) {\n  this.detachLabels_();\n\n  var g = e.dygraph;\n  var div = e.chart_div;\n  if (g.getOption('title')) {\n    // QUESTION: should this return an absolutely-positioned div instead?\n    var title_rect = e.reserveSpaceTop(g.getOption('titleHeight'));\n    this.title_div_ = createDivInRect(title_rect);\n    this.title_div_.style.fontSize = (g.getOption('titleHeight') - 8) + 'px';\n\n    var class_div = document.createElement(\"div\");\n    class_div.className = 'dygraph-label dygraph-title';\n    class_div.innerHTML = g.getOption('title');\n    this.title_div_.appendChild(class_div);\n    div.appendChild(this.title_div_);\n  }\n\n  if (g.getOption('xlabel')) {\n    var x_rect = e.reserveSpaceBottom(g.getOption('xLabelHeight'));\n    this.xlabel_div_ = createDivInRect(x_rect);\n    this.xlabel_div_.style.fontSize = (g.getOption('xLabelHeight') - 2) + 'px';\n\n    var class_div = document.createElement(\"div\");\n    class_div.className = 'dygraph-label dygraph-xlabel';\n    class_div.innerHTML = g.getOption('xlabel');\n    this.xlabel_div_.appendChild(class_div);\n    div.appendChild(this.xlabel_div_);\n  }\n\n  if (g.getOption('ylabel')) {\n    // It would make sense to shift the chart here to make room for the y-axis\n    // label, but the default yAxisLabelWidth is large enough that this results\n    // in overly-padded charts. The y-axis label should fit fine. If it\n    // doesn't, the yAxisLabelWidth option can be increased.\n    var y_rect = e.reserveSpaceLeft(0);\n\n    this.ylabel_div_ = createRotatedDiv(\n        g, y_rect,\n        1,  // primary (left) y-axis\n        'dygraph-label dygraph-ylabel',\n        g.getOption('ylabel'));\n    div.appendChild(this.ylabel_div_);\n  }\n\n  if (g.getOption('y2label') && g.numAxes() == 2) {\n    // same logic applies here as for ylabel.\n    var y2_rect = e.reserveSpaceRight(0);\n    this.y2label_div_ = createRotatedDiv(\n        g, y2_rect,\n        2,  // secondary (right) y-axis\n        'dygraph-label dygraph-y2label',\n        g.getOption('y2label'));\n    div.appendChild(this.y2label_div_);\n  }\n};\n\nchart_labels.prototype.didDrawChart = function(e) {\n  var g = e.dygraph;\n  if (this.title_div_) {\n    this.title_div_.children[0].innerHTML = g.getOption('title');\n  }\n  if (this.xlabel_div_) {\n    this.xlabel_div_.children[0].innerHTML = g.getOption('xlabel');\n  }\n  if (this.ylabel_div_) {\n    this.ylabel_div_.children[0].children[0].innerHTML = g.getOption('ylabel');\n  }\n  if (this.y2label_div_) {\n    this.y2label_div_.children[0].children[0].innerHTML = g.getOption('y2label');\n  }\n};\n\nchart_labels.prototype.clearChart = function() {\n};\n\nchart_labels.prototype.destroy = function() {\n  this.detachLabels_();\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (chart_labels);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ25mUS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9keWdyYXBocy9zcmMvcGx1Z2lucy9jaGFydC1sYWJlbHMuanM/MGE3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMiBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBUT0RPKGRhbnZrKTogbW92ZSBjaGFydCBsYWJlbCBvcHRpb25zIG91dCBvZiBkeWdyYXBocyBhbmQgaW50byB0aGUgcGx1Z2luLlxuLy8gVE9ETyhkYW52ayk6IG9ubHkgdGVhciBkb3duICYgcmVidWlsZCB0aGUgRElWcyB3aGVuIGl0J3MgbmVjZXNzYXJ5LlxuXG52YXIgY2hhcnRfbGFiZWxzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMudGl0bGVfZGl2XyA9IG51bGw7XG4gIHRoaXMueGxhYmVsX2Rpdl8gPSBudWxsO1xuICB0aGlzLnlsYWJlbF9kaXZfID0gbnVsbDtcbiAgdGhpcy55MmxhYmVsX2Rpdl8gPSBudWxsO1xufTtcblxuY2hhcnRfbGFiZWxzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXCJDaGFydExhYmVscyBQbHVnaW5cIjtcbn07XG5cbmNoYXJ0X2xhYmVscy5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbihnKSB7XG4gIHJldHVybiB7XG4gICAgbGF5b3V0OiB0aGlzLmxheW91dCxcbiAgICAvLyBjbGVhckNoYXJ0OiB0aGlzLmNsZWFyQ2hhcnQsXG4gICAgZGlkRHJhd0NoYXJ0OiB0aGlzLmRpZERyYXdDaGFydFxuICB9O1xufTtcblxuLy8gUVVFU1RJT046IHNob3VsZCB0aGVyZSBiZSBhIHBsdWdpbi11dGlscy5qcz9cbnZhciBjcmVhdGVEaXZJblJlY3QgPSBmdW5jdGlvbihyKSB7XG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgZGl2LnN0eWxlLmxlZnQgPSByLnggKyAncHgnO1xuICBkaXYuc3R5bGUudG9wID0gci55ICsgJ3B4JztcbiAgZGl2LnN0eWxlLndpZHRoID0gci53ICsgJ3B4JztcbiAgZGl2LnN0eWxlLmhlaWdodCA9IHIuaCArICdweCc7XG4gIHJldHVybiBkaXY7XG59O1xuXG4vLyBEZXRhY2ggYW5kIG51bGwgb3V0IGFueSBleGlzdGluZyBub2Rlcy5cbmNoYXJ0X2xhYmVscy5wcm90b3R5cGUuZGV0YWNoTGFiZWxzXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZWxzID0gWyB0aGlzLnRpdGxlX2Rpdl8sXG4gICAgICAgICAgICAgIHRoaXMueGxhYmVsX2Rpdl8sXG4gICAgICAgICAgICAgIHRoaXMueWxhYmVsX2Rpdl8sXG4gICAgICAgICAgICAgIHRoaXMueTJsYWJlbF9kaXZfIF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsID0gZWxzW2ldO1xuICAgIGlmICghZWwpIGNvbnRpbnVlO1xuICAgIGlmIChlbC5wYXJlbnROb2RlKSBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgfVxuXG4gIHRoaXMudGl0bGVfZGl2XyA9IG51bGw7XG4gIHRoaXMueGxhYmVsX2Rpdl8gPSBudWxsO1xuICB0aGlzLnlsYWJlbF9kaXZfID0gbnVsbDtcbiAgdGhpcy55MmxhYmVsX2Rpdl8gPSBudWxsO1xufTtcblxudmFyIGNyZWF0ZVJvdGF0ZWREaXYgPSBmdW5jdGlvbihnLCBib3gsIGF4aXMsIGNsYXNzZXMsIGh0bWwpIHtcbiAgLy8gVE9ETyhkYW52ayk6IGlzIHRoaXMgb3V0ZXIgZGl2IGFjdHVhbGx5IG5lY2Vzc2FyeT9cbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGlmIChheGlzID09IDEpIHtcbiAgICAvLyBOT1RFOiB0aGlzIGlzIGNoZWF0aW5nLiBTaG91bGQgYmUgcG9zaXRpb25lZCByZWxhdGl2ZSB0byB0aGUgYm94LlxuICAgIGRpdi5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gIH0gZWxzZSB7XG4gICAgZGl2LnN0eWxlLmxlZnQgPSBib3gueCArICdweCc7XG4gIH1cbiAgZGl2LnN0eWxlLnRvcCA9IGJveC55ICsgJ3B4JztcbiAgZGl2LnN0eWxlLndpZHRoID0gYm94LncgKyAncHgnO1xuICBkaXYuc3R5bGUuaGVpZ2h0ID0gYm94LmggKyAncHgnO1xuICBkaXYuc3R5bGUuZm9udFNpemUgPSAoZy5nZXRPcHRpb24oJ3lMYWJlbFdpZHRoJykgLSAyKSArICdweCc7XG5cbiAgdmFyIGlubmVyX2RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGlubmVyX2Rpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGlubmVyX2Rpdi5zdHlsZS53aWR0aCA9IGJveC5oICsgJ3B4JztcbiAgaW5uZXJfZGl2LnN0eWxlLmhlaWdodCA9IGJveC53ICsgJ3B4JztcbiAgaW5uZXJfZGl2LnN0eWxlLnRvcCA9IChib3guaCAvIDIgLSBib3gudyAvIDIpICsgJ3B4JztcbiAgaW5uZXJfZGl2LnN0eWxlLmxlZnQgPSAoYm94LncgLyAyIC0gYm94LmggLyAyKSArICdweCc7XG4gIC8vIFRPRE86IGNvbWJpbmUgaW5uZXJfZGl2IGFuZCBjbGFzc19kaXYuXG4gIGlubmVyX2Rpdi5jbGFzc05hbWUgPSAnZHlncmFwaC1sYWJlbC1yb3RhdGUtJyArIChheGlzID09IDEgPyAncmlnaHQnIDogJ2xlZnQnKTtcblxuICB2YXIgY2xhc3NfZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgY2xhc3NfZGl2LmNsYXNzTmFtZSA9IGNsYXNzZXM7XG4gIGNsYXNzX2Rpdi5pbm5lckhUTUwgPSBodG1sO1xuXG4gIGlubmVyX2Rpdi5hcHBlbmRDaGlsZChjbGFzc19kaXYpO1xuICBkaXYuYXBwZW5kQ2hpbGQoaW5uZXJfZGl2KTtcbiAgcmV0dXJuIGRpdjtcbn07XG5cbmNoYXJ0X2xhYmVscy5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24oZSkge1xuICB0aGlzLmRldGFjaExhYmVsc18oKTtcblxuICB2YXIgZyA9IGUuZHlncmFwaDtcbiAgdmFyIGRpdiA9IGUuY2hhcnRfZGl2O1xuICBpZiAoZy5nZXRPcHRpb24oJ3RpdGxlJykpIHtcbiAgICAvLyBRVUVTVElPTjogc2hvdWxkIHRoaXMgcmV0dXJuIGFuIGFic29sdXRlbHktcG9zaXRpb25lZCBkaXYgaW5zdGVhZD9cbiAgICB2YXIgdGl0bGVfcmVjdCA9IGUucmVzZXJ2ZVNwYWNlVG9wKGcuZ2V0T3B0aW9uKCd0aXRsZUhlaWdodCcpKTtcbiAgICB0aGlzLnRpdGxlX2Rpdl8gPSBjcmVhdGVEaXZJblJlY3QodGl0bGVfcmVjdCk7XG4gICAgdGhpcy50aXRsZV9kaXZfLnN0eWxlLmZvbnRTaXplID0gKGcuZ2V0T3B0aW9uKCd0aXRsZUhlaWdodCcpIC0gOCkgKyAncHgnO1xuXG4gICAgdmFyIGNsYXNzX2RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgY2xhc3NfZGl2LmNsYXNzTmFtZSA9ICdkeWdyYXBoLWxhYmVsIGR5Z3JhcGgtdGl0bGUnO1xuICAgIGNsYXNzX2Rpdi5pbm5lckhUTUwgPSBnLmdldE9wdGlvbigndGl0bGUnKTtcbiAgICB0aGlzLnRpdGxlX2Rpdl8uYXBwZW5kQ2hpbGQoY2xhc3NfZGl2KTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQodGhpcy50aXRsZV9kaXZfKTtcbiAgfVxuXG4gIGlmIChnLmdldE9wdGlvbigneGxhYmVsJykpIHtcbiAgICB2YXIgeF9yZWN0ID0gZS5yZXNlcnZlU3BhY2VCb3R0b20oZy5nZXRPcHRpb24oJ3hMYWJlbEhlaWdodCcpKTtcbiAgICB0aGlzLnhsYWJlbF9kaXZfID0gY3JlYXRlRGl2SW5SZWN0KHhfcmVjdCk7XG4gICAgdGhpcy54bGFiZWxfZGl2Xy5zdHlsZS5mb250U2l6ZSA9IChnLmdldE9wdGlvbigneExhYmVsSGVpZ2h0JykgLSAyKSArICdweCc7XG5cbiAgICB2YXIgY2xhc3NfZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBjbGFzc19kaXYuY2xhc3NOYW1lID0gJ2R5Z3JhcGgtbGFiZWwgZHlncmFwaC14bGFiZWwnO1xuICAgIGNsYXNzX2Rpdi5pbm5lckhUTUwgPSBnLmdldE9wdGlvbigneGxhYmVsJyk7XG4gICAgdGhpcy54bGFiZWxfZGl2Xy5hcHBlbmRDaGlsZChjbGFzc19kaXYpO1xuICAgIGRpdi5hcHBlbmRDaGlsZCh0aGlzLnhsYWJlbF9kaXZfKTtcbiAgfVxuXG4gIGlmIChnLmdldE9wdGlvbigneWxhYmVsJykpIHtcbiAgICAvLyBJdCB3b3VsZCBtYWtlIHNlbnNlIHRvIHNoaWZ0IHRoZSBjaGFydCBoZXJlIHRvIG1ha2Ugcm9vbSBmb3IgdGhlIHktYXhpc1xuICAgIC8vIGxhYmVsLCBidXQgdGhlIGRlZmF1bHQgeUF4aXNMYWJlbFdpZHRoIGlzIGxhcmdlIGVub3VnaCB0aGF0IHRoaXMgcmVzdWx0c1xuICAgIC8vIGluIG92ZXJseS1wYWRkZWQgY2hhcnRzLiBUaGUgeS1heGlzIGxhYmVsIHNob3VsZCBmaXQgZmluZS4gSWYgaXRcbiAgICAvLyBkb2Vzbid0LCB0aGUgeUF4aXNMYWJlbFdpZHRoIG9wdGlvbiBjYW4gYmUgaW5jcmVhc2VkLlxuICAgIHZhciB5X3JlY3QgPSBlLnJlc2VydmVTcGFjZUxlZnQoMCk7XG5cbiAgICB0aGlzLnlsYWJlbF9kaXZfID0gY3JlYXRlUm90YXRlZERpdihcbiAgICAgICAgZywgeV9yZWN0LFxuICAgICAgICAxLCAgLy8gcHJpbWFyeSAobGVmdCkgeS1heGlzXG4gICAgICAgICdkeWdyYXBoLWxhYmVsIGR5Z3JhcGgteWxhYmVsJyxcbiAgICAgICAgZy5nZXRPcHRpb24oJ3lsYWJlbCcpKTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQodGhpcy55bGFiZWxfZGl2Xyk7XG4gIH1cblxuICBpZiAoZy5nZXRPcHRpb24oJ3kybGFiZWwnKSAmJiBnLm51bUF4ZXMoKSA9PSAyKSB7XG4gICAgLy8gc2FtZSBsb2dpYyBhcHBsaWVzIGhlcmUgYXMgZm9yIHlsYWJlbC5cbiAgICB2YXIgeTJfcmVjdCA9IGUucmVzZXJ2ZVNwYWNlUmlnaHQoMCk7XG4gICAgdGhpcy55MmxhYmVsX2Rpdl8gPSBjcmVhdGVSb3RhdGVkRGl2KFxuICAgICAgICBnLCB5Ml9yZWN0LFxuICAgICAgICAyLCAgLy8gc2Vjb25kYXJ5IChyaWdodCkgeS1heGlzXG4gICAgICAgICdkeWdyYXBoLWxhYmVsIGR5Z3JhcGgteTJsYWJlbCcsXG4gICAgICAgIGcuZ2V0T3B0aW9uKCd5MmxhYmVsJykpO1xuICAgIGRpdi5hcHBlbmRDaGlsZCh0aGlzLnkybGFiZWxfZGl2Xyk7XG4gIH1cbn07XG5cbmNoYXJ0X2xhYmVscy5wcm90b3R5cGUuZGlkRHJhd0NoYXJ0ID0gZnVuY3Rpb24oZSkge1xuICB2YXIgZyA9IGUuZHlncmFwaDtcbiAgaWYgKHRoaXMudGl0bGVfZGl2Xykge1xuICAgIHRoaXMudGl0bGVfZGl2Xy5jaGlsZHJlblswXS5pbm5lckhUTUwgPSBnLmdldE9wdGlvbigndGl0bGUnKTtcbiAgfVxuICBpZiAodGhpcy54bGFiZWxfZGl2Xykge1xuICAgIHRoaXMueGxhYmVsX2Rpdl8uY2hpbGRyZW5bMF0uaW5uZXJIVE1MID0gZy5nZXRPcHRpb24oJ3hsYWJlbCcpO1xuICB9XG4gIGlmICh0aGlzLnlsYWJlbF9kaXZfKSB7XG4gICAgdGhpcy55bGFiZWxfZGl2Xy5jaGlsZHJlblswXS5jaGlsZHJlblswXS5pbm5lckhUTUwgPSBnLmdldE9wdGlvbigneWxhYmVsJyk7XG4gIH1cbiAgaWYgKHRoaXMueTJsYWJlbF9kaXZfKSB7XG4gICAgdGhpcy55MmxhYmVsX2Rpdl8uY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uaW5uZXJIVE1MID0gZy5nZXRPcHRpb24oJ3kybGFiZWwnKTtcbiAgfVxufTtcblxuY2hhcnRfbGFiZWxzLnByb3RvdHlwZS5jbGVhckNoYXJ0ID0gZnVuY3Rpb24oKSB7XG59O1xuXG5jaGFydF9sYWJlbHMucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kZXRhY2hMYWJlbHNfKCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjaGFydF9sYWJlbHM7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///CnfQ\n");

/***/ }),

/***/ "Jkhw":
/*!*****************************************************!*\
  !*** ./node_modules/dygraphs/src/plugins/legend.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dygraph-utils */ \"venr\");\n/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n/*global Dygraph:false */\n\n/*\nCurrent bits of jankiness:\n- Uses two private APIs:\n    1. Dygraph.optionsViewForAxis_\n    2. dygraph.plotter_.area\n- Registers for a \"predraw\" event, which should be renamed.\n- I call calculateEmWidthInDiv more often than needed.\n*/\n\n/*global Dygraph:false */\n\n\n\n\n\n/**\n * Creates the legend, which appears when the user hovers over the chart.\n * The legend can be either a user-specified or generated div.\n *\n * @constructor\n */\nvar Legend = function() {\n  this.legend_div_ = null;\n  this.is_generated_div_ = false;  // do we own this div, or was it user-specified?\n};\n\nLegend.prototype.toString = function() {\n  return \"Legend Plugin\";\n};\n\n/**\n * This is called during the dygraph constructor, after options have been set\n * but before the data is available.\n *\n * Proper tasks to do here include:\n * - Reading your own options\n * - DOM manipulation\n * - Registering event listeners\n *\n * @param {Dygraph} g Graph instance.\n * @return {object.<string, function(ev)>} Mapping of event names to callbacks.\n */\nLegend.prototype.activate = function(g) {\n  var div;\n\n  var userLabelsDiv = g.getOption('labelsDiv');\n  if (userLabelsDiv && null !== userLabelsDiv) {\n    if (typeof(userLabelsDiv) == \"string\" || userLabelsDiv instanceof String) {\n      div = document.getElementById(userLabelsDiv);\n    } else {\n      div = userLabelsDiv;\n    }\n  } else {\n    div = document.createElement(\"div\");\n    div.className = \"dygraph-legend\";\n    // TODO(danvk): come up with a cleaner way to expose this.\n    g.graphDiv.appendChild(div);\n    this.is_generated_div_ = true;\n  }\n\n  this.legend_div_ = div;\n  this.one_em_width_ = 10;  // just a guess, will be updated.\n\n  return {\n    select: this.select,\n    deselect: this.deselect,\n    // TODO(danvk): rethink the name \"predraw\" before we commit to it in any API.\n    predraw: this.predraw,\n    didDrawChart: this.didDrawChart\n  };\n};\n\n// Needed for dashed lines.\nvar calculateEmWidthInDiv = function(div) {\n  var sizeSpan = document.createElement('span');\n  sizeSpan.setAttribute('style', 'margin: 0; padding: 0 0 0 1em; border: 0;');\n  div.appendChild(sizeSpan);\n  var oneEmWidth=sizeSpan.offsetWidth;\n  div.removeChild(sizeSpan);\n  return oneEmWidth;\n};\n\nvar escapeHTML = function(str) {\n  return str.replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n};\n\nLegend.prototype.select = function(e) {\n  var xValue = e.selectedX;\n  var points = e.selectedPoints;\n  var row = e.selectedRow;\n\n  var legendMode = e.dygraph.getOption('legend');\n  if (legendMode === 'never') {\n    this.legend_div_.style.display = 'none';\n    return;\n  }\n\n  if (legendMode === 'follow') {\n    // create floating legend div\n    var area = e.dygraph.plotter_.area;\n    var labelsDivWidth = this.legend_div_.offsetWidth;\n    var yAxisLabelWidth = e.dygraph.getOptionForAxis('axisLabelWidth', 'y');\n    // determine floating [left, top] coordinates of the legend div\n    // within the plotter_ area\n    // offset 50 px to the right and down from the first selection point\n    // 50 px is guess based on mouse cursor size\n    var leftLegend = points[0].x * area.w + 50;\n    var topLegend  = points[0].y * area.h - 50;\n\n    // if legend floats to end of the chart area, it flips to the other\n    // side of the selection point\n    if ((leftLegend + labelsDivWidth + 1) > area.w) {\n      leftLegend = leftLegend - 2 * 50 - labelsDivWidth - (yAxisLabelWidth - area.x);\n    }\n\n    e.dygraph.graphDiv.appendChild(this.legend_div_);\n    this.legend_div_.style.left = yAxisLabelWidth + leftLegend + \"px\";\n    this.legend_div_.style.top = topLegend + \"px\";\n  }\n\n  var html = Legend.generateLegendHTML(e.dygraph, xValue, points, this.one_em_width_, row);\n  this.legend_div_.innerHTML = html;\n  this.legend_div_.style.display = '';\n};\n\nLegend.prototype.deselect = function(e) {\n  var legendMode = e.dygraph.getOption('legend');\n  if (legendMode !== 'always') {\n    this.legend_div_.style.display = \"none\";\n  }\n\n  // Have to do this every time, since styles might have changed.\n  var oneEmWidth = calculateEmWidthInDiv(this.legend_div_);\n  this.one_em_width_ = oneEmWidth;\n\n  var html = Legend.generateLegendHTML(e.dygraph, undefined, undefined, oneEmWidth, null);\n  this.legend_div_.innerHTML = html;\n};\n\nLegend.prototype.didDrawChart = function(e) {\n  this.deselect(e);\n};\n\n// Right edge should be flush with the right edge of the charting area (which\n// may not be the same as the right edge of the div, if we have two y-axes.\n// TODO(danvk): is any of this really necessary? Could just set \"right\" in \"activate\".\n/**\n * Position the labels div so that:\n * - its right edge is flush with the right edge of the charting area\n * - its top edge is flush with the top edge of the charting area\n * @private\n */\nLegend.prototype.predraw = function(e) {\n  // Don't touch a user-specified labelsDiv.\n  if (!this.is_generated_div_) return;\n\n  // TODO(danvk): only use real APIs for this.\n  e.dygraph.graphDiv.appendChild(this.legend_div_);\n  var area = e.dygraph.getArea();\n  var labelsDivWidth = this.legend_div_.offsetWidth;\n  this.legend_div_.style.left = area.x + area.w - labelsDivWidth - 1 + \"px\";\n  this.legend_div_.style.top = area.y + \"px\";\n};\n\n/**\n * Called when dygraph.destroy() is called.\n * You should null out any references and detach any DOM elements.\n */\nLegend.prototype.destroy = function() {\n  this.legend_div_ = null;\n};\n\n/**\n * Generates HTML for the legend which is displayed when hovering over the\n * chart. If no selected points are specified, a default legend is returned\n * (this may just be the empty string).\n * @param {number} x The x-value of the selected points.\n * @param {Object} sel_points List of selected points for the given\n *   x-value. Should have properties like 'name', 'yval' and 'canvasy'.\n * @param {number} oneEmWidth The pixel width for 1em in the legend. Only\n *   relevant when displaying a legend with no selection (i.e. {legend:\n *   'always'}) and with dashed lines.\n * @param {number} row The selected row index.\n * @private\n */\nLegend.generateLegendHTML = function(g, x, sel_points, oneEmWidth, row) {\n  // Data about the selection to pass to legendFormatter\n  var data = {\n    dygraph: g,\n    x: x,\n    series: []\n  };\n\n  var labelToSeries = {};\n  var labels = g.getLabels();\n  if (labels) {\n    for (var i = 1; i < labels.length; i++) {\n      var series = g.getPropertiesForSeries(labels[i]);\n      var strokePattern = g.getOption('strokePattern', labels[i]);\n      var seriesData = {\n        dashHTML: generateLegendDashHTML(strokePattern, series.color, oneEmWidth),\n        label: labels[i],\n        labelHTML: escapeHTML(labels[i]),\n        isVisible: series.visible,\n        color: series.color\n      };\n\n      data.series.push(seriesData);\n      labelToSeries[labels[i]] = seriesData;\n    }\n  }\n\n  if (typeof(x) !== 'undefined') {\n    var xOptView = g.optionsViewForAxis_('x');\n    var xvf = xOptView('valueFormatter');\n    data.xHTML = xvf.call(g, x, xOptView, labels[0], g, row, 0);\n\n    var yOptViews = [];\n    var num_axes = g.numAxes();\n    for (var i = 0; i < num_axes; i++) {\n      // TODO(danvk): remove this use of a private API\n      yOptViews[i] = g.optionsViewForAxis_('y' + (i ? 1 + i : ''));\n    }\n\n    var showZeros = g.getOption('labelsShowZeroValues');\n    var highlightSeries = g.getHighlightSeries();\n    for (i = 0; i < sel_points.length; i++) {\n      var pt = sel_points[i];\n      var seriesData = labelToSeries[pt.name];\n      seriesData.y = pt.yval;\n\n      if ((pt.yval === 0 && !showZeros) || isNaN(pt.canvasy)) {\n        seriesData.isVisible = false;\n        continue;\n      }\n\n      var series = g.getPropertiesForSeries(pt.name);\n      var yOptView = yOptViews[series.axis - 1];\n      var fmtFunc = yOptView('valueFormatter');\n      var yHTML = fmtFunc.call(g, pt.yval, yOptView, pt.name, g, row, labels.indexOf(pt.name));\n\n      _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"update\"](seriesData, {yHTML});\n\n      if (pt.name == highlightSeries) {\n        seriesData.isHighlighted = true;\n      }\n    }\n  }\n\n  var formatter = (g.getOption('legendFormatter') || Legend.defaultFormatter);\n  return formatter.call(g, data);\n}\n\nLegend.defaultFormatter = function(data) {\n  var g = data.dygraph;\n\n  // TODO(danvk): deprecate this option in place of {legend: 'never'}\n  // XXX should this logic be in the formatter?\n  if (g.getOption('showLabelsOnHighlight') !== true) return '';\n\n  var sepLines = g.getOption('labelsSeparateLines');\n  var html;\n\n  if (typeof(data.x) === 'undefined') {\n    // TODO: this check is duplicated in generateLegendHTML. Put it in one place.\n    if (g.getOption('legend') != 'always') {\n      return '';\n    }\n\n    html = '';\n    for (var i = 0; i < data.series.length; i++) {\n      var series = data.series[i];\n      if (!series.isVisible) continue;\n\n      if (html !== '') html += (sepLines ? '<br/>' : ' ');\n      html += `<span style='font-weight: bold; color: ${series.color};'>${series.dashHTML} ${series.labelHTML}</span>`;\n    }\n    return html;\n  }\n\n  html = data.xHTML + ':';\n  for (var i = 0; i < data.series.length; i++) {\n    var series = data.series[i];\n    if (!series.isVisible) continue;\n    if (sepLines) html += '<br>';\n    var cls = series.isHighlighted ? ' class=\"highlight\"' : '';\n    html += `<span${cls}> <b><span style='color: ${series.color};'>${series.labelHTML}</span></b>:&#160;${series.yHTML}</span>`;\n  }\n  return html;\n};\n\n\n/**\n * Generates html for the \"dash\" displayed on the legend when using \"legend: always\".\n * In particular, this works for dashed lines with any stroke pattern. It will\n * try to scale the pattern to fit in 1em width. Or if small enough repeat the\n * pattern for 1em width.\n *\n * @param strokePattern The pattern\n * @param color The color of the series.\n * @param oneEmWidth The width in pixels of 1em in the legend.\n * @private\n */\n// TODO(danvk): cache the results of this\nfunction generateLegendDashHTML(strokePattern, color, oneEmWidth) {\n  // Easy, common case: a solid line\n  if (!strokePattern || strokePattern.length <= 1) {\n    return `<div class=\"dygraph-legend-line\" style=\"border-bottom-color: ${color};\"></div>`;\n  }\n\n  var i, j, paddingLeft, marginRight;\n  var strokePixelLength = 0, segmentLoop = 0;\n  var normalizedPattern = [];\n  var loop;\n\n  // Compute the length of the pixels including the first segment twice, \n  // since we repeat it.\n  for (i = 0; i <= strokePattern.length; i++) {\n    strokePixelLength += strokePattern[i%strokePattern.length];\n  }\n\n  // See if we can loop the pattern by itself at least twice.\n  loop = Math.floor(oneEmWidth/(strokePixelLength-strokePattern[0]));\n  if (loop > 1) {\n    // This pattern fits at least two times, no scaling just convert to em;\n    for (i = 0; i < strokePattern.length; i++) {\n      normalizedPattern[i] = strokePattern[i]/oneEmWidth;\n    }\n    // Since we are repeating the pattern, we don't worry about repeating the\n    // first segment in one draw.\n    segmentLoop = normalizedPattern.length;\n  } else {\n    // If the pattern doesn't fit in the legend we scale it to fit.\n    loop = 1;\n    for (i = 0; i < strokePattern.length; i++) {\n      normalizedPattern[i] = strokePattern[i]/strokePixelLength;\n    }\n    // For the scaled patterns we do redraw the first segment.\n    segmentLoop = normalizedPattern.length+1;\n  }\n\n  // Now make the pattern.\n  var dash = \"\";\n  for (j = 0; j < loop; j++) {\n    for (i = 0; i < segmentLoop; i+=2) {\n      // The padding is the drawn segment.\n      paddingLeft = normalizedPattern[i%normalizedPattern.length];\n      if (i < strokePattern.length) {\n        // The margin is the space segment.\n        marginRight = normalizedPattern[(i+1)%normalizedPattern.length];\n      } else {\n        // The repeated first segment has no right margin.\n        marginRight = 0;\n      }\n      dash += `<div class=\"dygraph-legend-dash\" style=\"margin-right: ${marginRight}em; padding-left: ${paddingLeft}em;\"></div>`;\n    }\n  }\n  return dash;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Legend);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSmtody5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9keWdyYXBocy9zcmMvcGx1Z2lucy9sZWdlbmQuanM/MjY0OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMiBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cbi8qXG5DdXJyZW50IGJpdHMgb2YgamFua2luZXNzOlxuLSBVc2VzIHR3byBwcml2YXRlIEFQSXM6XG4gICAgMS4gRHlncmFwaC5vcHRpb25zVmlld0ZvckF4aXNfXG4gICAgMi4gZHlncmFwaC5wbG90dGVyXy5hcmVhXG4tIFJlZ2lzdGVycyBmb3IgYSBcInByZWRyYXdcIiBldmVudCwgd2hpY2ggc2hvdWxkIGJlIHJlbmFtZWQuXG4tIEkgY2FsbCBjYWxjdWxhdGVFbVdpZHRoSW5EaXYgbW9yZSBvZnRlbiB0aGFuIG5lZWRlZC5cbiovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi9keWdyYXBoLXV0aWxzJztcblxuXG4vKipcbiAqIENyZWF0ZXMgdGhlIGxlZ2VuZCwgd2hpY2ggYXBwZWFycyB3aGVuIHRoZSB1c2VyIGhvdmVycyBvdmVyIHRoZSBjaGFydC5cbiAqIFRoZSBsZWdlbmQgY2FuIGJlIGVpdGhlciBhIHVzZXItc3BlY2lmaWVkIG9yIGdlbmVyYXRlZCBkaXYuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBMZWdlbmQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5sZWdlbmRfZGl2XyA9IG51bGw7XG4gIHRoaXMuaXNfZ2VuZXJhdGVkX2Rpdl8gPSBmYWxzZTsgIC8vIGRvIHdlIG93biB0aGlzIGRpdiwgb3Igd2FzIGl0IHVzZXItc3BlY2lmaWVkP1xufTtcblxuTGVnZW5kLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXCJMZWdlbmQgUGx1Z2luXCI7XG59O1xuXG4vKipcbiAqIFRoaXMgaXMgY2FsbGVkIGR1cmluZyB0aGUgZHlncmFwaCBjb25zdHJ1Y3RvciwgYWZ0ZXIgb3B0aW9ucyBoYXZlIGJlZW4gc2V0XG4gKiBidXQgYmVmb3JlIHRoZSBkYXRhIGlzIGF2YWlsYWJsZS5cbiAqXG4gKiBQcm9wZXIgdGFza3MgdG8gZG8gaGVyZSBpbmNsdWRlOlxuICogLSBSZWFkaW5nIHlvdXIgb3duIG9wdGlvbnNcbiAqIC0gRE9NIG1hbmlwdWxhdGlvblxuICogLSBSZWdpc3RlcmluZyBldmVudCBsaXN0ZW5lcnNcbiAqXG4gKiBAcGFyYW0ge0R5Z3JhcGh9IGcgR3JhcGggaW5zdGFuY2UuXG4gKiBAcmV0dXJuIHtvYmplY3QuPHN0cmluZywgZnVuY3Rpb24oZXYpPn0gTWFwcGluZyBvZiBldmVudCBuYW1lcyB0byBjYWxsYmFja3MuXG4gKi9cbkxlZ2VuZC5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbihnKSB7XG4gIHZhciBkaXY7XG5cbiAgdmFyIHVzZXJMYWJlbHNEaXYgPSBnLmdldE9wdGlvbignbGFiZWxzRGl2Jyk7XG4gIGlmICh1c2VyTGFiZWxzRGl2ICYmIG51bGwgIT09IHVzZXJMYWJlbHNEaXYpIHtcbiAgICBpZiAodHlwZW9mKHVzZXJMYWJlbHNEaXYpID09IFwic3RyaW5nXCIgfHwgdXNlckxhYmVsc0RpdiBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgZGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodXNlckxhYmVsc0Rpdik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpdiA9IHVzZXJMYWJlbHNEaXY7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LmNsYXNzTmFtZSA9IFwiZHlncmFwaC1sZWdlbmRcIjtcbiAgICAvLyBUT0RPKGRhbnZrKTogY29tZSB1cCB3aXRoIGEgY2xlYW5lciB3YXkgdG8gZXhwb3NlIHRoaXMuXG4gICAgZy5ncmFwaERpdi5hcHBlbmRDaGlsZChkaXYpO1xuICAgIHRoaXMuaXNfZ2VuZXJhdGVkX2Rpdl8gPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5sZWdlbmRfZGl2XyA9IGRpdjtcbiAgdGhpcy5vbmVfZW1fd2lkdGhfID0gMTA7ICAvLyBqdXN0IGEgZ3Vlc3MsIHdpbGwgYmUgdXBkYXRlZC5cblxuICByZXR1cm4ge1xuICAgIHNlbGVjdDogdGhpcy5zZWxlY3QsXG4gICAgZGVzZWxlY3Q6IHRoaXMuZGVzZWxlY3QsXG4gICAgLy8gVE9ETyhkYW52ayk6IHJldGhpbmsgdGhlIG5hbWUgXCJwcmVkcmF3XCIgYmVmb3JlIHdlIGNvbW1pdCB0byBpdCBpbiBhbnkgQVBJLlxuICAgIHByZWRyYXc6IHRoaXMucHJlZHJhdyxcbiAgICBkaWREcmF3Q2hhcnQ6IHRoaXMuZGlkRHJhd0NoYXJ0XG4gIH07XG59O1xuXG4vLyBOZWVkZWQgZm9yIGRhc2hlZCBsaW5lcy5cbnZhciBjYWxjdWxhdGVFbVdpZHRoSW5EaXYgPSBmdW5jdGlvbihkaXYpIHtcbiAgdmFyIHNpemVTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBzaXplU3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ21hcmdpbjogMDsgcGFkZGluZzogMCAwIDAgMWVtOyBib3JkZXI6IDA7Jyk7XG4gIGRpdi5hcHBlbmRDaGlsZChzaXplU3Bhbik7XG4gIHZhciBvbmVFbVdpZHRoPXNpemVTcGFuLm9mZnNldFdpZHRoO1xuICBkaXYucmVtb3ZlQ2hpbGQoc2l6ZVNwYW4pO1xuICByZXR1cm4gb25lRW1XaWR0aDtcbn07XG5cbnZhciBlc2NhcGVIVE1MID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvJi9nLCBcIiZhbXA7XCIpLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpO1xufTtcblxuTGVnZW5kLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihlKSB7XG4gIHZhciB4VmFsdWUgPSBlLnNlbGVjdGVkWDtcbiAgdmFyIHBvaW50cyA9IGUuc2VsZWN0ZWRQb2ludHM7XG4gIHZhciByb3cgPSBlLnNlbGVjdGVkUm93O1xuXG4gIHZhciBsZWdlbmRNb2RlID0gZS5keWdyYXBoLmdldE9wdGlvbignbGVnZW5kJyk7XG4gIGlmIChsZWdlbmRNb2RlID09PSAnbmV2ZXInKSB7XG4gICAgdGhpcy5sZWdlbmRfZGl2Xy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChsZWdlbmRNb2RlID09PSAnZm9sbG93Jykge1xuICAgIC8vIGNyZWF0ZSBmbG9hdGluZyBsZWdlbmQgZGl2XG4gICAgdmFyIGFyZWEgPSBlLmR5Z3JhcGgucGxvdHRlcl8uYXJlYTtcbiAgICB2YXIgbGFiZWxzRGl2V2lkdGggPSB0aGlzLmxlZ2VuZF9kaXZfLm9mZnNldFdpZHRoO1xuICAgIHZhciB5QXhpc0xhYmVsV2lkdGggPSBlLmR5Z3JhcGguZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xhYmVsV2lkdGgnLCAneScpO1xuICAgIC8vIGRldGVybWluZSBmbG9hdGluZyBbbGVmdCwgdG9wXSBjb29yZGluYXRlcyBvZiB0aGUgbGVnZW5kIGRpdlxuICAgIC8vIHdpdGhpbiB0aGUgcGxvdHRlcl8gYXJlYVxuICAgIC8vIG9mZnNldCA1MCBweCB0byB0aGUgcmlnaHQgYW5kIGRvd24gZnJvbSB0aGUgZmlyc3Qgc2VsZWN0aW9uIHBvaW50XG4gICAgLy8gNTAgcHggaXMgZ3Vlc3MgYmFzZWQgb24gbW91c2UgY3Vyc29yIHNpemVcbiAgICB2YXIgbGVmdExlZ2VuZCA9IHBvaW50c1swXS54ICogYXJlYS53ICsgNTA7XG4gICAgdmFyIHRvcExlZ2VuZCAgPSBwb2ludHNbMF0ueSAqIGFyZWEuaCAtIDUwO1xuXG4gICAgLy8gaWYgbGVnZW5kIGZsb2F0cyB0byBlbmQgb2YgdGhlIGNoYXJ0IGFyZWEsIGl0IGZsaXBzIHRvIHRoZSBvdGhlclxuICAgIC8vIHNpZGUgb2YgdGhlIHNlbGVjdGlvbiBwb2ludFxuICAgIGlmICgobGVmdExlZ2VuZCArIGxhYmVsc0RpdldpZHRoICsgMSkgPiBhcmVhLncpIHtcbiAgICAgIGxlZnRMZWdlbmQgPSBsZWZ0TGVnZW5kIC0gMiAqIDUwIC0gbGFiZWxzRGl2V2lkdGggLSAoeUF4aXNMYWJlbFdpZHRoIC0gYXJlYS54KTtcbiAgICB9XG5cbiAgICBlLmR5Z3JhcGguZ3JhcGhEaXYuYXBwZW5kQ2hpbGQodGhpcy5sZWdlbmRfZGl2Xyk7XG4gICAgdGhpcy5sZWdlbmRfZGl2Xy5zdHlsZS5sZWZ0ID0geUF4aXNMYWJlbFdpZHRoICsgbGVmdExlZ2VuZCArIFwicHhcIjtcbiAgICB0aGlzLmxlZ2VuZF9kaXZfLnN0eWxlLnRvcCA9IHRvcExlZ2VuZCArIFwicHhcIjtcbiAgfVxuXG4gIHZhciBodG1sID0gTGVnZW5kLmdlbmVyYXRlTGVnZW5kSFRNTChlLmR5Z3JhcGgsIHhWYWx1ZSwgcG9pbnRzLCB0aGlzLm9uZV9lbV93aWR0aF8sIHJvdyk7XG4gIHRoaXMubGVnZW5kX2Rpdl8uaW5uZXJIVE1MID0gaHRtbDtcbiAgdGhpcy5sZWdlbmRfZGl2Xy5zdHlsZS5kaXNwbGF5ID0gJyc7XG59O1xuXG5MZWdlbmQucHJvdG90eXBlLmRlc2VsZWN0ID0gZnVuY3Rpb24oZSkge1xuICB2YXIgbGVnZW5kTW9kZSA9IGUuZHlncmFwaC5nZXRPcHRpb24oJ2xlZ2VuZCcpO1xuICBpZiAobGVnZW5kTW9kZSAhPT0gJ2Fsd2F5cycpIHtcbiAgICB0aGlzLmxlZ2VuZF9kaXZfLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgfVxuXG4gIC8vIEhhdmUgdG8gZG8gdGhpcyBldmVyeSB0aW1lLCBzaW5jZSBzdHlsZXMgbWlnaHQgaGF2ZSBjaGFuZ2VkLlxuICB2YXIgb25lRW1XaWR0aCA9IGNhbGN1bGF0ZUVtV2lkdGhJbkRpdih0aGlzLmxlZ2VuZF9kaXZfKTtcbiAgdGhpcy5vbmVfZW1fd2lkdGhfID0gb25lRW1XaWR0aDtcblxuICB2YXIgaHRtbCA9IExlZ2VuZC5nZW5lcmF0ZUxlZ2VuZEhUTUwoZS5keWdyYXBoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb25lRW1XaWR0aCwgbnVsbCk7XG4gIHRoaXMubGVnZW5kX2Rpdl8uaW5uZXJIVE1MID0gaHRtbDtcbn07XG5cbkxlZ2VuZC5wcm90b3R5cGUuZGlkRHJhd0NoYXJ0ID0gZnVuY3Rpb24oZSkge1xuICB0aGlzLmRlc2VsZWN0KGUpO1xufTtcblxuLy8gUmlnaHQgZWRnZSBzaG91bGQgYmUgZmx1c2ggd2l0aCB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgY2hhcnRpbmcgYXJlYSAod2hpY2hcbi8vIG1heSBub3QgYmUgdGhlIHNhbWUgYXMgdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIGRpdiwgaWYgd2UgaGF2ZSB0d28geS1heGVzLlxuLy8gVE9ETyhkYW52ayk6IGlzIGFueSBvZiB0aGlzIHJlYWxseSBuZWNlc3Nhcnk/IENvdWxkIGp1c3Qgc2V0IFwicmlnaHRcIiBpbiBcImFjdGl2YXRlXCIuXG4vKipcbiAqIFBvc2l0aW9uIHRoZSBsYWJlbHMgZGl2IHNvIHRoYXQ6XG4gKiAtIGl0cyByaWdodCBlZGdlIGlzIGZsdXNoIHdpdGggdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIGNoYXJ0aW5nIGFyZWFcbiAqIC0gaXRzIHRvcCBlZGdlIGlzIGZsdXNoIHdpdGggdGhlIHRvcCBlZGdlIG9mIHRoZSBjaGFydGluZyBhcmVhXG4gKiBAcHJpdmF0ZVxuICovXG5MZWdlbmQucHJvdG90eXBlLnByZWRyYXcgPSBmdW5jdGlvbihlKSB7XG4gIC8vIERvbid0IHRvdWNoIGEgdXNlci1zcGVjaWZpZWQgbGFiZWxzRGl2LlxuICBpZiAoIXRoaXMuaXNfZ2VuZXJhdGVkX2Rpdl8pIHJldHVybjtcblxuICAvLyBUT0RPKGRhbnZrKTogb25seSB1c2UgcmVhbCBBUElzIGZvciB0aGlzLlxuICBlLmR5Z3JhcGguZ3JhcGhEaXYuYXBwZW5kQ2hpbGQodGhpcy5sZWdlbmRfZGl2Xyk7XG4gIHZhciBhcmVhID0gZS5keWdyYXBoLmdldEFyZWEoKTtcbiAgdmFyIGxhYmVsc0RpdldpZHRoID0gdGhpcy5sZWdlbmRfZGl2Xy5vZmZzZXRXaWR0aDtcbiAgdGhpcy5sZWdlbmRfZGl2Xy5zdHlsZS5sZWZ0ID0gYXJlYS54ICsgYXJlYS53IC0gbGFiZWxzRGl2V2lkdGggLSAxICsgXCJweFwiO1xuICB0aGlzLmxlZ2VuZF9kaXZfLnN0eWxlLnRvcCA9IGFyZWEueSArIFwicHhcIjtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gZHlncmFwaC5kZXN0cm95KCkgaXMgY2FsbGVkLlxuICogWW91IHNob3VsZCBudWxsIG91dCBhbnkgcmVmZXJlbmNlcyBhbmQgZGV0YWNoIGFueSBET00gZWxlbWVudHMuXG4gKi9cbkxlZ2VuZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxlZ2VuZF9kaXZfID0gbnVsbDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIEhUTUwgZm9yIHRoZSBsZWdlbmQgd2hpY2ggaXMgZGlzcGxheWVkIHdoZW4gaG92ZXJpbmcgb3ZlciB0aGVcbiAqIGNoYXJ0LiBJZiBubyBzZWxlY3RlZCBwb2ludHMgYXJlIHNwZWNpZmllZCwgYSBkZWZhdWx0IGxlZ2VuZCBpcyByZXR1cm5lZFxuICogKHRoaXMgbWF5IGp1c3QgYmUgdGhlIGVtcHR5IHN0cmluZykuXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaGUgeC12YWx1ZSBvZiB0aGUgc2VsZWN0ZWQgcG9pbnRzLlxuICogQHBhcmFtIHtPYmplY3R9IHNlbF9wb2ludHMgTGlzdCBvZiBzZWxlY3RlZCBwb2ludHMgZm9yIHRoZSBnaXZlblxuICogICB4LXZhbHVlLiBTaG91bGQgaGF2ZSBwcm9wZXJ0aWVzIGxpa2UgJ25hbWUnLCAneXZhbCcgYW5kICdjYW52YXN5Jy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvbmVFbVdpZHRoIFRoZSBwaXhlbCB3aWR0aCBmb3IgMWVtIGluIHRoZSBsZWdlbmQuIE9ubHlcbiAqICAgcmVsZXZhbnQgd2hlbiBkaXNwbGF5aW5nIGEgbGVnZW5kIHdpdGggbm8gc2VsZWN0aW9uIChpLmUuIHtsZWdlbmQ6XG4gKiAgICdhbHdheXMnfSkgYW5kIHdpdGggZGFzaGVkIGxpbmVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdyBUaGUgc2VsZWN0ZWQgcm93IGluZGV4LlxuICogQHByaXZhdGVcbiAqL1xuTGVnZW5kLmdlbmVyYXRlTGVnZW5kSFRNTCA9IGZ1bmN0aW9uKGcsIHgsIHNlbF9wb2ludHMsIG9uZUVtV2lkdGgsIHJvdykge1xuICAvLyBEYXRhIGFib3V0IHRoZSBzZWxlY3Rpb24gdG8gcGFzcyB0byBsZWdlbmRGb3JtYXR0ZXJcbiAgdmFyIGRhdGEgPSB7XG4gICAgZHlncmFwaDogZyxcbiAgICB4OiB4LFxuICAgIHNlcmllczogW11cbiAgfTtcblxuICB2YXIgbGFiZWxUb1NlcmllcyA9IHt9O1xuICB2YXIgbGFiZWxzID0gZy5nZXRMYWJlbHMoKTtcbiAgaWYgKGxhYmVscykge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VyaWVzID0gZy5nZXRQcm9wZXJ0aWVzRm9yU2VyaWVzKGxhYmVsc1tpXSk7XG4gICAgICB2YXIgc3Ryb2tlUGF0dGVybiA9IGcuZ2V0T3B0aW9uKCdzdHJva2VQYXR0ZXJuJywgbGFiZWxzW2ldKTtcbiAgICAgIHZhciBzZXJpZXNEYXRhID0ge1xuICAgICAgICBkYXNoSFRNTDogZ2VuZXJhdGVMZWdlbmREYXNoSFRNTChzdHJva2VQYXR0ZXJuLCBzZXJpZXMuY29sb3IsIG9uZUVtV2lkdGgpLFxuICAgICAgICBsYWJlbDogbGFiZWxzW2ldLFxuICAgICAgICBsYWJlbEhUTUw6IGVzY2FwZUhUTUwobGFiZWxzW2ldKSxcbiAgICAgICAgaXNWaXNpYmxlOiBzZXJpZXMudmlzaWJsZSxcbiAgICAgICAgY29sb3I6IHNlcmllcy5jb2xvclxuICAgICAgfTtcblxuICAgICAgZGF0YS5zZXJpZXMucHVzaChzZXJpZXNEYXRhKTtcbiAgICAgIGxhYmVsVG9TZXJpZXNbbGFiZWxzW2ldXSA9IHNlcmllc0RhdGE7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZih4KSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgeE9wdFZpZXcgPSBnLm9wdGlvbnNWaWV3Rm9yQXhpc18oJ3gnKTtcbiAgICB2YXIgeHZmID0geE9wdFZpZXcoJ3ZhbHVlRm9ybWF0dGVyJyk7XG4gICAgZGF0YS54SFRNTCA9IHh2Zi5jYWxsKGcsIHgsIHhPcHRWaWV3LCBsYWJlbHNbMF0sIGcsIHJvdywgMCk7XG5cbiAgICB2YXIgeU9wdFZpZXdzID0gW107XG4gICAgdmFyIG51bV9heGVzID0gZy5udW1BeGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fYXhlczsgaSsrKSB7XG4gICAgICAvLyBUT0RPKGRhbnZrKTogcmVtb3ZlIHRoaXMgdXNlIG9mIGEgcHJpdmF0ZSBBUElcbiAgICAgIHlPcHRWaWV3c1tpXSA9IGcub3B0aW9uc1ZpZXdGb3JBeGlzXygneScgKyAoaSA/IDEgKyBpIDogJycpKTtcbiAgICB9XG5cbiAgICB2YXIgc2hvd1plcm9zID0gZy5nZXRPcHRpb24oJ2xhYmVsc1Nob3daZXJvVmFsdWVzJyk7XG4gICAgdmFyIGhpZ2hsaWdodFNlcmllcyA9IGcuZ2V0SGlnaGxpZ2h0U2VyaWVzKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHNlbF9wb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwdCA9IHNlbF9wb2ludHNbaV07XG4gICAgICB2YXIgc2VyaWVzRGF0YSA9IGxhYmVsVG9TZXJpZXNbcHQubmFtZV07XG4gICAgICBzZXJpZXNEYXRhLnkgPSBwdC55dmFsO1xuXG4gICAgICBpZiAoKHB0Lnl2YWwgPT09IDAgJiYgIXNob3daZXJvcykgfHwgaXNOYU4ocHQuY2FudmFzeSkpIHtcbiAgICAgICAgc2VyaWVzRGF0YS5pc1Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZXJpZXMgPSBnLmdldFByb3BlcnRpZXNGb3JTZXJpZXMocHQubmFtZSk7XG4gICAgICB2YXIgeU9wdFZpZXcgPSB5T3B0Vmlld3Nbc2VyaWVzLmF4aXMgLSAxXTtcbiAgICAgIHZhciBmbXRGdW5jID0geU9wdFZpZXcoJ3ZhbHVlRm9ybWF0dGVyJyk7XG4gICAgICB2YXIgeUhUTUwgPSBmbXRGdW5jLmNhbGwoZywgcHQueXZhbCwgeU9wdFZpZXcsIHB0Lm5hbWUsIGcsIHJvdywgbGFiZWxzLmluZGV4T2YocHQubmFtZSkpO1xuXG4gICAgICB1dGlscy51cGRhdGUoc2VyaWVzRGF0YSwge3lIVE1MfSk7XG5cbiAgICAgIGlmIChwdC5uYW1lID09IGhpZ2hsaWdodFNlcmllcykge1xuICAgICAgICBzZXJpZXNEYXRhLmlzSGlnaGxpZ2h0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBmb3JtYXR0ZXIgPSAoZy5nZXRPcHRpb24oJ2xlZ2VuZEZvcm1hdHRlcicpIHx8IExlZ2VuZC5kZWZhdWx0Rm9ybWF0dGVyKTtcbiAgcmV0dXJuIGZvcm1hdHRlci5jYWxsKGcsIGRhdGEpO1xufVxuXG5MZWdlbmQuZGVmYXVsdEZvcm1hdHRlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIGcgPSBkYXRhLmR5Z3JhcGg7XG5cbiAgLy8gVE9ETyhkYW52ayk6IGRlcHJlY2F0ZSB0aGlzIG9wdGlvbiBpbiBwbGFjZSBvZiB7bGVnZW5kOiAnbmV2ZXInfVxuICAvLyBYWFggc2hvdWxkIHRoaXMgbG9naWMgYmUgaW4gdGhlIGZvcm1hdHRlcj9cbiAgaWYgKGcuZ2V0T3B0aW9uKCdzaG93TGFiZWxzT25IaWdobGlnaHQnKSAhPT0gdHJ1ZSkgcmV0dXJuICcnO1xuXG4gIHZhciBzZXBMaW5lcyA9IGcuZ2V0T3B0aW9uKCdsYWJlbHNTZXBhcmF0ZUxpbmVzJyk7XG4gIHZhciBodG1sO1xuXG4gIGlmICh0eXBlb2YoZGF0YS54KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBUT0RPOiB0aGlzIGNoZWNrIGlzIGR1cGxpY2F0ZWQgaW4gZ2VuZXJhdGVMZWdlbmRIVE1MLiBQdXQgaXQgaW4gb25lIHBsYWNlLlxuICAgIGlmIChnLmdldE9wdGlvbignbGVnZW5kJykgIT0gJ2Fsd2F5cycpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBodG1sID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlcmllcyA9IGRhdGEuc2VyaWVzW2ldO1xuICAgICAgaWYgKCFzZXJpZXMuaXNWaXNpYmxlKSBjb250aW51ZTtcblxuICAgICAgaWYgKGh0bWwgIT09ICcnKSBodG1sICs9IChzZXBMaW5lcyA/ICc8YnIvPicgOiAnICcpO1xuICAgICAgaHRtbCArPSBgPHNwYW4gc3R5bGU9J2ZvbnQtd2VpZ2h0OiBib2xkOyBjb2xvcjogJHtzZXJpZXMuY29sb3J9Oyc+JHtzZXJpZXMuZGFzaEhUTUx9ICR7c2VyaWVzLmxhYmVsSFRNTH08L3NwYW4+YDtcbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG4gIH1cblxuICBodG1sID0gZGF0YS54SFRNTCArICc6JztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzZXJpZXMgPSBkYXRhLnNlcmllc1tpXTtcbiAgICBpZiAoIXNlcmllcy5pc1Zpc2libGUpIGNvbnRpbnVlO1xuICAgIGlmIChzZXBMaW5lcykgaHRtbCArPSAnPGJyPic7XG4gICAgdmFyIGNscyA9IHNlcmllcy5pc0hpZ2hsaWdodGVkID8gJyBjbGFzcz1cImhpZ2hsaWdodFwiJyA6ICcnO1xuICAgIGh0bWwgKz0gYDxzcGFuJHtjbHN9PiA8Yj48c3BhbiBzdHlsZT0nY29sb3I6ICR7c2VyaWVzLmNvbG9yfTsnPiR7c2VyaWVzLmxhYmVsSFRNTH08L3NwYW4+PC9iPjomIzE2MDske3Nlcmllcy55SFRNTH08L3NwYW4+YDtcbiAgfVxuICByZXR1cm4gaHRtbDtcbn07XG5cblxuLyoqXG4gKiBHZW5lcmF0ZXMgaHRtbCBmb3IgdGhlIFwiZGFzaFwiIGRpc3BsYXllZCBvbiB0aGUgbGVnZW5kIHdoZW4gdXNpbmcgXCJsZWdlbmQ6IGFsd2F5c1wiLlxuICogSW4gcGFydGljdWxhciwgdGhpcyB3b3JrcyBmb3IgZGFzaGVkIGxpbmVzIHdpdGggYW55IHN0cm9rZSBwYXR0ZXJuLiBJdCB3aWxsXG4gKiB0cnkgdG8gc2NhbGUgdGhlIHBhdHRlcm4gdG8gZml0IGluIDFlbSB3aWR0aC4gT3IgaWYgc21hbGwgZW5vdWdoIHJlcGVhdCB0aGVcbiAqIHBhdHRlcm4gZm9yIDFlbSB3aWR0aC5cbiAqXG4gKiBAcGFyYW0gc3Ryb2tlUGF0dGVybiBUaGUgcGF0dGVyblxuICogQHBhcmFtIGNvbG9yIFRoZSBjb2xvciBvZiB0aGUgc2VyaWVzLlxuICogQHBhcmFtIG9uZUVtV2lkdGggVGhlIHdpZHRoIGluIHBpeGVscyBvZiAxZW0gaW4gdGhlIGxlZ2VuZC5cbiAqIEBwcml2YXRlXG4gKi9cbi8vIFRPRE8oZGFudmspOiBjYWNoZSB0aGUgcmVzdWx0cyBvZiB0aGlzXG5mdW5jdGlvbiBnZW5lcmF0ZUxlZ2VuZERhc2hIVE1MKHN0cm9rZVBhdHRlcm4sIGNvbG9yLCBvbmVFbVdpZHRoKSB7XG4gIC8vIEVhc3ksIGNvbW1vbiBjYXNlOiBhIHNvbGlkIGxpbmVcbiAgaWYgKCFzdHJva2VQYXR0ZXJuIHx8IHN0cm9rZVBhdHRlcm4ubGVuZ3RoIDw9IDEpIHtcbiAgICByZXR1cm4gYDxkaXYgY2xhc3M9XCJkeWdyYXBoLWxlZ2VuZC1saW5lXCIgc3R5bGU9XCJib3JkZXItYm90dG9tLWNvbG9yOiAke2NvbG9yfTtcIj48L2Rpdj5gO1xuICB9XG5cbiAgdmFyIGksIGosIHBhZGRpbmdMZWZ0LCBtYXJnaW5SaWdodDtcbiAgdmFyIHN0cm9rZVBpeGVsTGVuZ3RoID0gMCwgc2VnbWVudExvb3AgPSAwO1xuICB2YXIgbm9ybWFsaXplZFBhdHRlcm4gPSBbXTtcbiAgdmFyIGxvb3A7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBwaXhlbHMgaW5jbHVkaW5nIHRoZSBmaXJzdCBzZWdtZW50IHR3aWNlLCBcbiAgLy8gc2luY2Ugd2UgcmVwZWF0IGl0LlxuICBmb3IgKGkgPSAwOyBpIDw9IHN0cm9rZVBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICBzdHJva2VQaXhlbExlbmd0aCArPSBzdHJva2VQYXR0ZXJuW2klc3Ryb2tlUGF0dGVybi5sZW5ndGhdO1xuICB9XG5cbiAgLy8gU2VlIGlmIHdlIGNhbiBsb29wIHRoZSBwYXR0ZXJuIGJ5IGl0c2VsZiBhdCBsZWFzdCB0d2ljZS5cbiAgbG9vcCA9IE1hdGguZmxvb3Iob25lRW1XaWR0aC8oc3Ryb2tlUGl4ZWxMZW5ndGgtc3Ryb2tlUGF0dGVyblswXSkpO1xuICBpZiAobG9vcCA+IDEpIHtcbiAgICAvLyBUaGlzIHBhdHRlcm4gZml0cyBhdCBsZWFzdCB0d28gdGltZXMsIG5vIHNjYWxpbmcganVzdCBjb252ZXJ0IHRvIGVtO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdHJva2VQYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3JtYWxpemVkUGF0dGVybltpXSA9IHN0cm9rZVBhdHRlcm5baV0vb25lRW1XaWR0aDtcbiAgICB9XG4gICAgLy8gU2luY2Ugd2UgYXJlIHJlcGVhdGluZyB0aGUgcGF0dGVybiwgd2UgZG9uJ3Qgd29ycnkgYWJvdXQgcmVwZWF0aW5nIHRoZVxuICAgIC8vIGZpcnN0IHNlZ21lbnQgaW4gb25lIGRyYXcuXG4gICAgc2VnbWVudExvb3AgPSBub3JtYWxpemVkUGF0dGVybi5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdGhlIHBhdHRlcm4gZG9lc24ndCBmaXQgaW4gdGhlIGxlZ2VuZCB3ZSBzY2FsZSBpdCB0byBmaXQuXG4gICAgbG9vcCA9IDE7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0cm9rZVBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRQYXR0ZXJuW2ldID0gc3Ryb2tlUGF0dGVybltpXS9zdHJva2VQaXhlbExlbmd0aDtcbiAgICB9XG4gICAgLy8gRm9yIHRoZSBzY2FsZWQgcGF0dGVybnMgd2UgZG8gcmVkcmF3IHRoZSBmaXJzdCBzZWdtZW50LlxuICAgIHNlZ21lbnRMb29wID0gbm9ybWFsaXplZFBhdHRlcm4ubGVuZ3RoKzE7XG4gIH1cblxuICAvLyBOb3cgbWFrZSB0aGUgcGF0dGVybi5cbiAgdmFyIGRhc2ggPSBcIlwiO1xuICBmb3IgKGogPSAwOyBqIDwgbG9vcDsgaisrKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHNlZ21lbnRMb29wOyBpKz0yKSB7XG4gICAgICAvLyBUaGUgcGFkZGluZyBpcyB0aGUgZHJhd24gc2VnbWVudC5cbiAgICAgIHBhZGRpbmdMZWZ0ID0gbm9ybWFsaXplZFBhdHRlcm5baSVub3JtYWxpemVkUGF0dGVybi5sZW5ndGhdO1xuICAgICAgaWYgKGkgPCBzdHJva2VQYXR0ZXJuLmxlbmd0aCkge1xuICAgICAgICAvLyBUaGUgbWFyZ2luIGlzIHRoZSBzcGFjZSBzZWdtZW50LlxuICAgICAgICBtYXJnaW5SaWdodCA9IG5vcm1hbGl6ZWRQYXR0ZXJuWyhpKzEpJW5vcm1hbGl6ZWRQYXR0ZXJuLmxlbmd0aF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgcmVwZWF0ZWQgZmlyc3Qgc2VnbWVudCBoYXMgbm8gcmlnaHQgbWFyZ2luLlxuICAgICAgICBtYXJnaW5SaWdodCA9IDA7XG4gICAgICB9XG4gICAgICBkYXNoICs9IGA8ZGl2IGNsYXNzPVwiZHlncmFwaC1sZWdlbmQtZGFzaFwiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAke21hcmdpblJpZ2h0fWVtOyBwYWRkaW5nLWxlZnQ6ICR7cGFkZGluZ0xlZnR9ZW07XCI+PC9kaXY+YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhc2g7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBMZWdlbmQ7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///Jkhw\n");

/***/ }),

/***/ "XJQ2":
/*!***************************************************!*\
  !*** ./node_modules/dygraphs/src/plugins/axes.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dygraph-utils */ \"venr\");\n/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/*global Dygraph:false */\n\n\n\n/*\nBits of jankiness:\n- Direct layout access\n- Direct area access\n- Should include calculation of ticks, not just the drawing.\n\nOptions left to make axis-friendly.\n  ('drawAxesAtZero')\n  ('xAxisHeight')\n*/\n\n\n\n/**\n * Draws the axes. This includes the labels on the x- and y-axes, as well\n * as the tick marks on the axes.\n * It does _not_ draw the grid lines which span the entire chart.\n */\nvar axes = function() {\n  this.xlabels_ = [];\n  this.ylabels_ = [];\n};\n\naxes.prototype.toString = function() {\n  return 'Axes Plugin';\n};\n\naxes.prototype.activate = function(g) {\n  return {\n    layout: this.layout,\n    clearChart: this.clearChart,\n    willDrawChart: this.willDrawChart\n  };\n};\n\naxes.prototype.layout = function(e) {\n  var g = e.dygraph;\n\n  if (g.getOptionForAxis('drawAxis', 'y')) {\n    var w = g.getOptionForAxis('axisLabelWidth', 'y') + 2 * g.getOptionForAxis('axisTickSize', 'y');\n    e.reserveSpaceLeft(w);\n  }\n\n  if (g.getOptionForAxis('drawAxis', 'x')) {\n    var h;\n    // NOTE: I think this is probably broken now, since g.getOption() now\n    // hits the dictionary. (That is, g.getOption('xAxisHeight') now always\n    // has a value.)\n    if (g.getOption('xAxisHeight')) {\n      h = g.getOption('xAxisHeight');\n    } else {\n      h = g.getOptionForAxis('axisLabelFontSize', 'x') + 2 * g.getOptionForAxis('axisTickSize', 'x');\n    }\n    e.reserveSpaceBottom(h);\n  }\n\n  if (g.numAxes() == 2) {\n    if (g.getOptionForAxis('drawAxis', 'y2')) {\n      var w = g.getOptionForAxis('axisLabelWidth', 'y2') + 2 * g.getOptionForAxis('axisTickSize', 'y2');\n      e.reserveSpaceRight(w);\n    }\n  } else if (g.numAxes() > 2) {\n    g.error('Only two y-axes are supported at this time. (Trying ' +\n            'to use ' + g.numAxes() + ')');\n  }\n};\n\naxes.prototype.detachLabels = function() {\n  function removeArray(ary) {\n    for (var i = 0; i < ary.length; i++) {\n      var el = ary[i];\n      if (el.parentNode) el.parentNode.removeChild(el);\n    }\n  }\n\n  removeArray(this.xlabels_);\n  removeArray(this.ylabels_);\n  this.xlabels_ = [];\n  this.ylabels_ = [];\n};\n\naxes.prototype.clearChart = function(e) {\n  this.detachLabels();\n};\n\naxes.prototype.willDrawChart = function(e) {\n  var g = e.dygraph;\n\n  if (!g.getOptionForAxis('drawAxis', 'x') &&\n      !g.getOptionForAxis('drawAxis', 'y') &&\n      !g.getOptionForAxis('drawAxis', 'y2')) {\n    return;\n  }\n\n  // Round pixels to half-integer boundaries for crisper drawing.\n  function halfUp(x)  { return Math.round(x) + 0.5; }\n  function halfDown(y){ return Math.round(y) - 0.5; }\n\n  var context = e.drawingContext;\n  var containerDiv = e.canvas.parentNode;\n  var canvasWidth = g.width_;  // e.canvas.width is affected by pixel ratio.\n  var canvasHeight = g.height_;\n\n  var label, x, y, tick, i;\n\n  var makeLabelStyle = function(axis) {\n    return {\n      position: 'absolute',\n      fontSize: g.getOptionForAxis('axisLabelFontSize', axis) + 'px',\n      width: g.getOptionForAxis('axisLabelWidth', axis) + 'px',\n    };\n  };\n\n  var labelStyles = {\n    x: makeLabelStyle('x'),\n    y: makeLabelStyle('y'),\n    y2: makeLabelStyle('y2')\n  };\n\n  var makeDiv = function(txt, axis, prec_axis) {\n    /*\n     * This seems to be called with the following three sets of axis/prec_axis:\n     * x: undefined\n     * y: y1\n     * y: y2\n     */\n    var div = document.createElement('div');\n    var labelStyle = labelStyles[prec_axis == 'y2' ? 'y2' : axis];\n    _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"update\"](div.style, labelStyle);\n    // TODO: combine outer & inner divs\n    var inner_div = document.createElement('div');\n    inner_div.className = 'dygraph-axis-label' +\n                          ' dygraph-axis-label-' + axis +\n                          (prec_axis ? ' dygraph-axis-label-' + prec_axis : '');\n    inner_div.innerHTML = txt;\n    div.appendChild(inner_div);\n    return div;\n  };\n\n  // axis lines\n  context.save();\n\n  var layout = g.layout_;\n  var area = e.dygraph.plotter_.area;\n\n  // Helper for repeated axis-option accesses.\n  var makeOptionGetter = function(axis) {\n    return function(option) {\n      return g.getOptionForAxis(option, axis);\n    };\n  };\n\n  if (g.getOptionForAxis('drawAxis', 'y')) {\n    if (layout.yticks && layout.yticks.length > 0) {\n      var num_axes = g.numAxes();\n      var getOptions = [makeOptionGetter('y'), makeOptionGetter('y2')];\n      layout.yticks.forEach(tick => {\n        if (tick.label === undefined) return;  // this tick only has a grid line.\n        x = area.x;\n        var sgn = 1;\n        var prec_axis = 'y1';\n        var getAxisOption = getOptions[0];\n        if (tick.axis == 1) {  // right-side y-axis\n          x = area.x + area.w;\n          sgn = -1;\n          prec_axis = 'y2';\n          getAxisOption = getOptions[1];\n        }\n        var fontSize = getAxisOption('axisLabelFontSize');\n        y = area.y + tick.pos * area.h;\n\n        /* Tick marks are currently clipped, so don't bother drawing them.\n        context.beginPath();\n        context.moveTo(halfUp(x), halfDown(y));\n        context.lineTo(halfUp(x - sgn * this.attr_('axisTickSize')), halfDown(y));\n        context.closePath();\n        context.stroke();\n        */\n\n        label = makeDiv(tick.label, 'y', num_axes == 2 ? prec_axis : null);\n        var top = (y - fontSize / 2);\n        if (top < 0) top = 0;\n\n        if (top + fontSize + 3 > canvasHeight) {\n          label.style.bottom = '0';\n        } else {\n          label.style.top = top + 'px';\n        }\n        // TODO: replace these with css classes?\n        if (tick.axis === 0) {\n          label.style.left = (area.x - getAxisOption('axisLabelWidth') - getAxisOption('axisTickSize')) + 'px';\n          label.style.textAlign = 'right';\n        } else if (tick.axis == 1) {\n          label.style.left = (area.x + area.w +\n                              getAxisOption('axisTickSize')) + 'px';\n          label.style.textAlign = 'left';\n        }\n        label.style.width = getAxisOption('axisLabelWidth') + 'px';\n        containerDiv.appendChild(label);\n        this.ylabels_.push(label);\n      });\n\n      // The lowest tick on the y-axis often overlaps with the leftmost\n      // tick on the x-axis. Shift the bottom tick up a little bit to\n      // compensate if necessary.\n      var bottomTick = this.ylabels_[0];\n      // Interested in the y2 axis also?\n      var fontSize = g.getOptionForAxis('axisLabelFontSize', 'y');\n      var bottom = parseInt(bottomTick.style.top, 10) + fontSize;\n      if (bottom > canvasHeight - fontSize) {\n        bottomTick.style.top = (parseInt(bottomTick.style.top, 10) -\n            fontSize / 2) + 'px';\n      }\n    }\n\n    // draw a vertical line on the left to separate the chart from the labels.\n    var axisX;\n    if (g.getOption('drawAxesAtZero')) {\n      var r = g.toPercentXCoord(0);\n      if (r > 1 || r < 0 || isNaN(r)) r = 0;\n      axisX = halfUp(area.x + r * area.w);\n    } else {\n      axisX = halfUp(area.x);\n    }\n\n    context.strokeStyle = g.getOptionForAxis('axisLineColor', 'y');\n    context.lineWidth = g.getOptionForAxis('axisLineWidth', 'y');\n\n    context.beginPath();\n    context.moveTo(axisX, halfDown(area.y));\n    context.lineTo(axisX, halfDown(area.y + area.h));\n    context.closePath();\n    context.stroke();\n\n    // if there's a secondary y-axis, draw a vertical line for that, too.\n    if (g.numAxes() == 2) {\n      context.strokeStyle = g.getOptionForAxis('axisLineColor', 'y2');\n      context.lineWidth = g.getOptionForAxis('axisLineWidth', 'y2');\n      context.beginPath();\n      context.moveTo(halfDown(area.x + area.w), halfDown(area.y));\n      context.lineTo(halfDown(area.x + area.w), halfDown(area.y + area.h));\n      context.closePath();\n      context.stroke();\n    }\n  }\n\n  if (g.getOptionForAxis('drawAxis', 'x')) {\n    if (layout.xticks) {\n      var getAxisOption = makeOptionGetter('x');\n      layout.xticks.forEach(tick => {\n        if (tick.label === undefined) return;  // this tick only has a grid line.\n        x = area.x + tick.pos * area.w;\n        y = area.y + area.h;\n\n        /* Tick marks are currently clipped, so don't bother drawing them.\n        context.beginPath();\n        context.moveTo(halfUp(x), halfDown(y));\n        context.lineTo(halfUp(x), halfDown(y + this.attr_('axisTickSize')));\n        context.closePath();\n        context.stroke();\n        */\n\n        label = makeDiv(tick.label, 'x');\n        label.style.textAlign = 'center';\n        label.style.top = (y + getAxisOption('axisTickSize')) + 'px';\n\n        var left = (x - getAxisOption('axisLabelWidth')/2);\n        if (left + getAxisOption('axisLabelWidth') > canvasWidth) {\n          left = canvasWidth - getAxisOption('axisLabelWidth');\n          label.style.textAlign = 'right';\n        }\n        if (left < 0) {\n          left = 0;\n          label.style.textAlign = 'left';\n        }\n\n        label.style.left = left + 'px';\n        label.style.width = getAxisOption('axisLabelWidth') + 'px';\n        containerDiv.appendChild(label);\n        this.xlabels_.push(label);\n      });\n    }\n\n    context.strokeStyle = g.getOptionForAxis('axisLineColor', 'x');\n    context.lineWidth = g.getOptionForAxis('axisLineWidth', 'x');\n    context.beginPath();\n    var axisY;\n    if (g.getOption('drawAxesAtZero')) {\n      var r = g.toPercentYCoord(0, 0);\n      if (r > 1 || r < 0) r = 1;\n      axisY = halfDown(area.y + r * area.h);\n    } else {\n      axisY = halfDown(area.y + area.h);\n    }\n    context.moveTo(halfUp(area.x), axisY);\n    context.lineTo(halfUp(area.x + area.w), axisY);\n    context.closePath();\n    context.stroke();\n  }\n\n  context.restore();\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (axes);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiWEpRMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9keWdyYXBocy9zcmMvcGx1Z2lucy9heGVzLmpzPzVjOTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTIgRGFuIFZhbmRlcmthbSAoZGFudmRrQGdtYWlsLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cbid1c2Ugc3RyaWN0JztcblxuLypcbkJpdHMgb2YgamFua2luZXNzOlxuLSBEaXJlY3QgbGF5b3V0IGFjY2Vzc1xuLSBEaXJlY3QgYXJlYSBhY2Nlc3Ncbi0gU2hvdWxkIGluY2x1ZGUgY2FsY3VsYXRpb24gb2YgdGlja3MsIG5vdCBqdXN0IHRoZSBkcmF3aW5nLlxuXG5PcHRpb25zIGxlZnQgdG8gbWFrZSBheGlzLWZyaWVuZGx5LlxuICAoJ2RyYXdBeGVzQXRaZXJvJylcbiAgKCd4QXhpc0hlaWdodCcpXG4qL1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi9keWdyYXBoLXV0aWxzJztcblxuLyoqXG4gKiBEcmF3cyB0aGUgYXhlcy4gVGhpcyBpbmNsdWRlcyB0aGUgbGFiZWxzIG9uIHRoZSB4LSBhbmQgeS1heGVzLCBhcyB3ZWxsXG4gKiBhcyB0aGUgdGljayBtYXJrcyBvbiB0aGUgYXhlcy5cbiAqIEl0IGRvZXMgX25vdF8gZHJhdyB0aGUgZ3JpZCBsaW5lcyB3aGljaCBzcGFuIHRoZSBlbnRpcmUgY2hhcnQuXG4gKi9cbnZhciBheGVzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMueGxhYmVsc18gPSBbXTtcbiAgdGhpcy55bGFiZWxzXyA9IFtdO1xufTtcblxuYXhlcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdBeGVzIFBsdWdpbic7XG59O1xuXG5heGVzLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKGcpIHtcbiAgcmV0dXJuIHtcbiAgICBsYXlvdXQ6IHRoaXMubGF5b3V0LFxuICAgIGNsZWFyQ2hhcnQ6IHRoaXMuY2xlYXJDaGFydCxcbiAgICB3aWxsRHJhd0NoYXJ0OiB0aGlzLndpbGxEcmF3Q2hhcnRcbiAgfTtcbn07XG5cbmF4ZXMucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIGcgPSBlLmR5Z3JhcGg7XG5cbiAgaWYgKGcuZ2V0T3B0aW9uRm9yQXhpcygnZHJhd0F4aXMnLCAneScpKSB7XG4gICAgdmFyIHcgPSBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNMYWJlbFdpZHRoJywgJ3knKSArIDIgKiBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNUaWNrU2l6ZScsICd5Jyk7XG4gICAgZS5yZXNlcnZlU3BhY2VMZWZ0KHcpO1xuICB9XG5cbiAgaWYgKGcuZ2V0T3B0aW9uRm9yQXhpcygnZHJhd0F4aXMnLCAneCcpKSB7XG4gICAgdmFyIGg7XG4gICAgLy8gTk9URTogSSB0aGluayB0aGlzIGlzIHByb2JhYmx5IGJyb2tlbiBub3csIHNpbmNlIGcuZ2V0T3B0aW9uKCkgbm93XG4gICAgLy8gaGl0cyB0aGUgZGljdGlvbmFyeS4gKFRoYXQgaXMsIGcuZ2V0T3B0aW9uKCd4QXhpc0hlaWdodCcpIG5vdyBhbHdheXNcbiAgICAvLyBoYXMgYSB2YWx1ZS4pXG4gICAgaWYgKGcuZ2V0T3B0aW9uKCd4QXhpc0hlaWdodCcpKSB7XG4gICAgICBoID0gZy5nZXRPcHRpb24oJ3hBeGlzSGVpZ2h0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGggPSBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNMYWJlbEZvbnRTaXplJywgJ3gnKSArIDIgKiBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNUaWNrU2l6ZScsICd4Jyk7XG4gICAgfVxuICAgIGUucmVzZXJ2ZVNwYWNlQm90dG9tKGgpO1xuICB9XG5cbiAgaWYgKGcubnVtQXhlcygpID09IDIpIHtcbiAgICBpZiAoZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3QXhpcycsICd5MicpKSB7XG4gICAgICB2YXIgdyA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xhYmVsV2lkdGgnLCAneTInKSArIDIgKiBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNUaWNrU2l6ZScsICd5MicpO1xuICAgICAgZS5yZXNlcnZlU3BhY2VSaWdodCh3KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZy5udW1BeGVzKCkgPiAyKSB7XG4gICAgZy5lcnJvcignT25seSB0d28geS1heGVzIGFyZSBzdXBwb3J0ZWQgYXQgdGhpcyB0aW1lLiAoVHJ5aW5nICcgK1xuICAgICAgICAgICAgJ3RvIHVzZSAnICsgZy5udW1BeGVzKCkgKyAnKScpO1xuICB9XG59O1xuXG5heGVzLnByb3RvdHlwZS5kZXRhY2hMYWJlbHMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gcmVtb3ZlQXJyYXkoYXJ5KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbCA9IGFyeVtpXTtcbiAgICAgIGlmIChlbC5wYXJlbnROb2RlKSBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICB9XG4gIH1cblxuICByZW1vdmVBcnJheSh0aGlzLnhsYWJlbHNfKTtcbiAgcmVtb3ZlQXJyYXkodGhpcy55bGFiZWxzXyk7XG4gIHRoaXMueGxhYmVsc18gPSBbXTtcbiAgdGhpcy55bGFiZWxzXyA9IFtdO1xufTtcblxuYXhlcy5wcm90b3R5cGUuY2xlYXJDaGFydCA9IGZ1bmN0aW9uKGUpIHtcbiAgdGhpcy5kZXRhY2hMYWJlbHMoKTtcbn07XG5cbmF4ZXMucHJvdG90eXBlLndpbGxEcmF3Q2hhcnQgPSBmdW5jdGlvbihlKSB7XG4gIHZhciBnID0gZS5keWdyYXBoO1xuXG4gIGlmICghZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3QXhpcycsICd4JykgJiZcbiAgICAgICFnLmdldE9wdGlvbkZvckF4aXMoJ2RyYXdBeGlzJywgJ3knKSAmJlxuICAgICAgIWcuZ2V0T3B0aW9uRm9yQXhpcygnZHJhd0F4aXMnLCAneTInKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFJvdW5kIHBpeGVscyB0byBoYWxmLWludGVnZXIgYm91bmRhcmllcyBmb3IgY3Jpc3BlciBkcmF3aW5nLlxuICBmdW5jdGlvbiBoYWxmVXAoeCkgIHsgcmV0dXJuIE1hdGgucm91bmQoeCkgKyAwLjU7IH1cbiAgZnVuY3Rpb24gaGFsZkRvd24oeSl7IHJldHVybiBNYXRoLnJvdW5kKHkpIC0gMC41OyB9XG5cbiAgdmFyIGNvbnRleHQgPSBlLmRyYXdpbmdDb250ZXh0O1xuICB2YXIgY29udGFpbmVyRGl2ID0gZS5jYW52YXMucGFyZW50Tm9kZTtcbiAgdmFyIGNhbnZhc1dpZHRoID0gZy53aWR0aF87ICAvLyBlLmNhbnZhcy53aWR0aCBpcyBhZmZlY3RlZCBieSBwaXhlbCByYXRpby5cbiAgdmFyIGNhbnZhc0hlaWdodCA9IGcuaGVpZ2h0XztcblxuICB2YXIgbGFiZWwsIHgsIHksIHRpY2ssIGk7XG5cbiAgdmFyIG1ha2VMYWJlbFN0eWxlID0gZnVuY3Rpb24oYXhpcykge1xuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIGZvbnRTaXplOiBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNMYWJlbEZvbnRTaXplJywgYXhpcykgKyAncHgnLFxuICAgICAgd2lkdGg6IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xhYmVsV2lkdGgnLCBheGlzKSArICdweCcsXG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGFiZWxTdHlsZXMgPSB7XG4gICAgeDogbWFrZUxhYmVsU3R5bGUoJ3gnKSxcbiAgICB5OiBtYWtlTGFiZWxTdHlsZSgneScpLFxuICAgIHkyOiBtYWtlTGFiZWxTdHlsZSgneTInKVxuICB9O1xuXG4gIHZhciBtYWtlRGl2ID0gZnVuY3Rpb24odHh0LCBheGlzLCBwcmVjX2F4aXMpIHtcbiAgICAvKlxuICAgICAqIFRoaXMgc2VlbXMgdG8gYmUgY2FsbGVkIHdpdGggdGhlIGZvbGxvd2luZyB0aHJlZSBzZXRzIG9mIGF4aXMvcHJlY19heGlzOlxuICAgICAqIHg6IHVuZGVmaW5lZFxuICAgICAqIHk6IHkxXG4gICAgICogeTogeTJcbiAgICAgKi9cbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdmFyIGxhYmVsU3R5bGUgPSBsYWJlbFN0eWxlc1twcmVjX2F4aXMgPT0gJ3kyJyA/ICd5MicgOiBheGlzXTtcbiAgICB1dGlscy51cGRhdGUoZGl2LnN0eWxlLCBsYWJlbFN0eWxlKTtcbiAgICAvLyBUT0RPOiBjb21iaW5lIG91dGVyICYgaW5uZXIgZGl2c1xuICAgIHZhciBpbm5lcl9kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpbm5lcl9kaXYuY2xhc3NOYW1lID0gJ2R5Z3JhcGgtYXhpcy1sYWJlbCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnIGR5Z3JhcGgtYXhpcy1sYWJlbC0nICsgYXhpcyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChwcmVjX2F4aXMgPyAnIGR5Z3JhcGgtYXhpcy1sYWJlbC0nICsgcHJlY19heGlzIDogJycpO1xuICAgIGlubmVyX2Rpdi5pbm5lckhUTUwgPSB0eHQ7XG4gICAgZGl2LmFwcGVuZENoaWxkKGlubmVyX2Rpdik7XG4gICAgcmV0dXJuIGRpdjtcbiAgfTtcblxuICAvLyBheGlzIGxpbmVzXG4gIGNvbnRleHQuc2F2ZSgpO1xuXG4gIHZhciBsYXlvdXQgPSBnLmxheW91dF87XG4gIHZhciBhcmVhID0gZS5keWdyYXBoLnBsb3R0ZXJfLmFyZWE7XG5cbiAgLy8gSGVscGVyIGZvciByZXBlYXRlZCBheGlzLW9wdGlvbiBhY2Nlc3Nlcy5cbiAgdmFyIG1ha2VPcHRpb25HZXR0ZXIgPSBmdW5jdGlvbihheGlzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgcmV0dXJuIGcuZ2V0T3B0aW9uRm9yQXhpcyhvcHRpb24sIGF4aXMpO1xuICAgIH07XG4gIH07XG5cbiAgaWYgKGcuZ2V0T3B0aW9uRm9yQXhpcygnZHJhd0F4aXMnLCAneScpKSB7XG4gICAgaWYgKGxheW91dC55dGlja3MgJiYgbGF5b3V0Lnl0aWNrcy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgbnVtX2F4ZXMgPSBnLm51bUF4ZXMoKTtcbiAgICAgIHZhciBnZXRPcHRpb25zID0gW21ha2VPcHRpb25HZXR0ZXIoJ3knKSwgbWFrZU9wdGlvbkdldHRlcigneTInKV07XG4gICAgICBsYXlvdXQueXRpY2tzLmZvckVhY2godGljayA9PiB7XG4gICAgICAgIGlmICh0aWNrLmxhYmVsID09PSB1bmRlZmluZWQpIHJldHVybjsgIC8vIHRoaXMgdGljayBvbmx5IGhhcyBhIGdyaWQgbGluZS5cbiAgICAgICAgeCA9IGFyZWEueDtcbiAgICAgICAgdmFyIHNnbiA9IDE7XG4gICAgICAgIHZhciBwcmVjX2F4aXMgPSAneTEnO1xuICAgICAgICB2YXIgZ2V0QXhpc09wdGlvbiA9IGdldE9wdGlvbnNbMF07XG4gICAgICAgIGlmICh0aWNrLmF4aXMgPT0gMSkgeyAgLy8gcmlnaHQtc2lkZSB5LWF4aXNcbiAgICAgICAgICB4ID0gYXJlYS54ICsgYXJlYS53O1xuICAgICAgICAgIHNnbiA9IC0xO1xuICAgICAgICAgIHByZWNfYXhpcyA9ICd5Mic7XG4gICAgICAgICAgZ2V0QXhpc09wdGlvbiA9IGdldE9wdGlvbnNbMV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvbnRTaXplID0gZ2V0QXhpc09wdGlvbignYXhpc0xhYmVsRm9udFNpemUnKTtcbiAgICAgICAgeSA9IGFyZWEueSArIHRpY2sucG9zICogYXJlYS5oO1xuXG4gICAgICAgIC8qIFRpY2sgbWFya3MgYXJlIGN1cnJlbnRseSBjbGlwcGVkLCBzbyBkb24ndCBib3RoZXIgZHJhd2luZyB0aGVtLlxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyhoYWxmVXAoeCksIGhhbGZEb3duKHkpKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oaGFsZlVwKHggLSBzZ24gKiB0aGlzLmF0dHJfKCdheGlzVGlja1NpemUnKSksIGhhbGZEb3duKHkpKTtcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgKi9cblxuICAgICAgICBsYWJlbCA9IG1ha2VEaXYodGljay5sYWJlbCwgJ3knLCBudW1fYXhlcyA9PSAyID8gcHJlY19heGlzIDogbnVsbCk7XG4gICAgICAgIHZhciB0b3AgPSAoeSAtIGZvbnRTaXplIC8gMik7XG4gICAgICAgIGlmICh0b3AgPCAwKSB0b3AgPSAwO1xuXG4gICAgICAgIGlmICh0b3AgKyBmb250U2l6ZSArIDMgPiBjYW52YXNIZWlnaHQpIHtcbiAgICAgICAgICBsYWJlbC5zdHlsZS5ib3R0b20gPSAnMCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFiZWwuc3R5bGUudG9wID0gdG9wICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHRoZXNlIHdpdGggY3NzIGNsYXNzZXM/XG4gICAgICAgIGlmICh0aWNrLmF4aXMgPT09IDApIHtcbiAgICAgICAgICBsYWJlbC5zdHlsZS5sZWZ0ID0gKGFyZWEueCAtIGdldEF4aXNPcHRpb24oJ2F4aXNMYWJlbFdpZHRoJykgLSBnZXRBeGlzT3B0aW9uKCdheGlzVGlja1NpemUnKSkgKyAncHgnO1xuICAgICAgICAgIGxhYmVsLnN0eWxlLnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAodGljay5heGlzID09IDEpIHtcbiAgICAgICAgICBsYWJlbC5zdHlsZS5sZWZ0ID0gKGFyZWEueCArIGFyZWEudyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRBeGlzT3B0aW9uKCdheGlzVGlja1NpemUnKSkgKyAncHgnO1xuICAgICAgICAgIGxhYmVsLnN0eWxlLnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfVxuICAgICAgICBsYWJlbC5zdHlsZS53aWR0aCA9IGdldEF4aXNPcHRpb24oJ2F4aXNMYWJlbFdpZHRoJykgKyAncHgnO1xuICAgICAgICBjb250YWluZXJEaXYuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgICAgICB0aGlzLnlsYWJlbHNfLnB1c2gobGFiZWwpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFRoZSBsb3dlc3QgdGljayBvbiB0aGUgeS1heGlzIG9mdGVuIG92ZXJsYXBzIHdpdGggdGhlIGxlZnRtb3N0XG4gICAgICAvLyB0aWNrIG9uIHRoZSB4LWF4aXMuIFNoaWZ0IHRoZSBib3R0b20gdGljayB1cCBhIGxpdHRsZSBiaXQgdG9cbiAgICAgIC8vIGNvbXBlbnNhdGUgaWYgbmVjZXNzYXJ5LlxuICAgICAgdmFyIGJvdHRvbVRpY2sgPSB0aGlzLnlsYWJlbHNfWzBdO1xuICAgICAgLy8gSW50ZXJlc3RlZCBpbiB0aGUgeTIgYXhpcyBhbHNvP1xuICAgICAgdmFyIGZvbnRTaXplID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdheGlzTGFiZWxGb250U2l6ZScsICd5Jyk7XG4gICAgICB2YXIgYm90dG9tID0gcGFyc2VJbnQoYm90dG9tVGljay5zdHlsZS50b3AsIDEwKSArIGZvbnRTaXplO1xuICAgICAgaWYgKGJvdHRvbSA+IGNhbnZhc0hlaWdodCAtIGZvbnRTaXplKSB7XG4gICAgICAgIGJvdHRvbVRpY2suc3R5bGUudG9wID0gKHBhcnNlSW50KGJvdHRvbVRpY2suc3R5bGUudG9wLCAxMCkgLVxuICAgICAgICAgICAgZm9udFNpemUgLyAyKSArICdweCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZHJhdyBhIHZlcnRpY2FsIGxpbmUgb24gdGhlIGxlZnQgdG8gc2VwYXJhdGUgdGhlIGNoYXJ0IGZyb20gdGhlIGxhYmVscy5cbiAgICB2YXIgYXhpc1g7XG4gICAgaWYgKGcuZ2V0T3B0aW9uKCdkcmF3QXhlc0F0WmVybycpKSB7XG4gICAgICB2YXIgciA9IGcudG9QZXJjZW50WENvb3JkKDApO1xuICAgICAgaWYgKHIgPiAxIHx8IHIgPCAwIHx8IGlzTmFOKHIpKSByID0gMDtcbiAgICAgIGF4aXNYID0gaGFsZlVwKGFyZWEueCArIHIgKiBhcmVhLncpO1xuICAgIH0gZWxzZSB7XG4gICAgICBheGlzWCA9IGhhbGZVcChhcmVhLngpO1xuICAgIH1cblxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNMaW5lQ29sb3InLCAneScpO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdheGlzTGluZVdpZHRoJywgJ3knKTtcblxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oYXhpc1gsIGhhbGZEb3duKGFyZWEueSkpO1xuICAgIGNvbnRleHQubGluZVRvKGF4aXNYLCBoYWxmRG93bihhcmVhLnkgKyBhcmVhLmgpKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICAvLyBpZiB0aGVyZSdzIGEgc2Vjb25kYXJ5IHktYXhpcywgZHJhdyBhIHZlcnRpY2FsIGxpbmUgZm9yIHRoYXQsIHRvby5cbiAgICBpZiAoZy5udW1BeGVzKCkgPT0gMikge1xuICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xpbmVDb2xvcicsICd5MicpO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNMaW5lV2lkdGgnLCAneTInKTtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0Lm1vdmVUbyhoYWxmRG93bihhcmVhLnggKyBhcmVhLncpLCBoYWxmRG93bihhcmVhLnkpKTtcbiAgICAgIGNvbnRleHQubGluZVRvKGhhbGZEb3duKGFyZWEueCArIGFyZWEudyksIGhhbGZEb3duKGFyZWEueSArIGFyZWEuaCkpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGcuZ2V0T3B0aW9uRm9yQXhpcygnZHJhd0F4aXMnLCAneCcpKSB7XG4gICAgaWYgKGxheW91dC54dGlja3MpIHtcbiAgICAgIHZhciBnZXRBeGlzT3B0aW9uID0gbWFrZU9wdGlvbkdldHRlcigneCcpO1xuICAgICAgbGF5b3V0Lnh0aWNrcy5mb3JFYWNoKHRpY2sgPT4ge1xuICAgICAgICBpZiAodGljay5sYWJlbCA9PT0gdW5kZWZpbmVkKSByZXR1cm47ICAvLyB0aGlzIHRpY2sgb25seSBoYXMgYSBncmlkIGxpbmUuXG4gICAgICAgIHggPSBhcmVhLnggKyB0aWNrLnBvcyAqIGFyZWEudztcbiAgICAgICAgeSA9IGFyZWEueSArIGFyZWEuaDtcblxuICAgICAgICAvKiBUaWNrIG1hcmtzIGFyZSBjdXJyZW50bHkgY2xpcHBlZCwgc28gZG9uJ3QgYm90aGVyIGRyYXdpbmcgdGhlbS5cbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oaGFsZlVwKHgpLCBoYWxmRG93bih5KSk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKGhhbGZVcCh4KSwgaGFsZkRvd24oeSArIHRoaXMuYXR0cl8oJ2F4aXNUaWNrU2l6ZScpKSk7XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICovXG5cbiAgICAgICAgbGFiZWwgPSBtYWtlRGl2KHRpY2subGFiZWwsICd4Jyk7XG4gICAgICAgIGxhYmVsLnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICBsYWJlbC5zdHlsZS50b3AgPSAoeSArIGdldEF4aXNPcHRpb24oJ2F4aXNUaWNrU2l6ZScpKSArICdweCc7XG5cbiAgICAgICAgdmFyIGxlZnQgPSAoeCAtIGdldEF4aXNPcHRpb24oJ2F4aXNMYWJlbFdpZHRoJykvMik7XG4gICAgICAgIGlmIChsZWZ0ICsgZ2V0QXhpc09wdGlvbignYXhpc0xhYmVsV2lkdGgnKSA+IGNhbnZhc1dpZHRoKSB7XG4gICAgICAgICAgbGVmdCA9IGNhbnZhc1dpZHRoIC0gZ2V0QXhpc09wdGlvbignYXhpc0xhYmVsV2lkdGgnKTtcbiAgICAgICAgICBsYWJlbC5zdHlsZS50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgICAgIGxlZnQgPSAwO1xuICAgICAgICAgIGxhYmVsLnN0eWxlLnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfVxuXG4gICAgICAgIGxhYmVsLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcbiAgICAgICAgbGFiZWwuc3R5bGUud2lkdGggPSBnZXRBeGlzT3B0aW9uKCdheGlzTGFiZWxXaWR0aCcpICsgJ3B4JztcbiAgICAgICAgY29udGFpbmVyRGl2LmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICAgICAgdGhpcy54bGFiZWxzXy5wdXNoKGxhYmVsKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNMaW5lQ29sb3InLCAneCcpO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdheGlzTGluZVdpZHRoJywgJ3gnKTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIHZhciBheGlzWTtcbiAgICBpZiAoZy5nZXRPcHRpb24oJ2RyYXdBeGVzQXRaZXJvJykpIHtcbiAgICAgIHZhciByID0gZy50b1BlcmNlbnRZQ29vcmQoMCwgMCk7XG4gICAgICBpZiAociA+IDEgfHwgciA8IDApIHIgPSAxO1xuICAgICAgYXhpc1kgPSBoYWxmRG93bihhcmVhLnkgKyByICogYXJlYS5oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXhpc1kgPSBoYWxmRG93bihhcmVhLnkgKyBhcmVhLmgpO1xuICAgIH1cbiAgICBjb250ZXh0Lm1vdmVUbyhoYWxmVXAoYXJlYS54KSwgYXhpc1kpO1xuICAgIGNvbnRleHQubGluZVRvKGhhbGZVcChhcmVhLnggKyBhcmVhLncpLCBheGlzWSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICB9XG5cbiAgY29udGV4dC5yZXN0b3JlKCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBheGVzO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///XJQ2\n");

/***/ }),

/***/ "nGoW":
/*!*************************************************************!*\
  !*** ./node_modules/dygraphs/src/plugins/range-selector.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dygraph-utils */ \"venr\");\n/* harmony import */ var _dygraph_interaction_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dygraph-interaction-model */ \"2Ep6\");\n/* harmony import */ var _iframe_tarp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../iframe-tarp */ \"/FzH\");\n/**\n * @license\n * Copyright 2011 Paul Felix (paul.eric.felix@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n/*global Dygraph:false,TouchEvent:false */\n\n/**\n * @fileoverview This file contains the RangeSelector plugin used to provide\n * a timeline range selector widget for dygraphs.\n */\n\n/*global Dygraph:false */\n\n\n\n\n\n\nvar rangeSelector = function() {\n  this.hasTouchInterface_ = typeof(TouchEvent) != 'undefined';\n  this.isMobileDevice_ = /mobile|android/gi.test(navigator.appVersion);\n  this.interfaceCreated_ = false;\n};\n\nrangeSelector.prototype.toString = function() {\n  return \"RangeSelector Plugin\";\n};\n\nrangeSelector.prototype.activate = function(dygraph) {\n  this.dygraph_ = dygraph;\n  if (this.getOption_('showRangeSelector')) {\n    this.createInterface_();\n  }\n  return {\n    layout: this.reserveSpace_,\n    predraw: this.renderStaticLayer_,\n    didDrawChart: this.renderInteractiveLayer_\n  };\n};\n\nrangeSelector.prototype.destroy = function() {\n  this.bgcanvas_ = null;\n  this.fgcanvas_ = null;\n  this.leftZoomHandle_ = null;\n  this.rightZoomHandle_ = null;\n};\n\n//------------------------------------------------------------------\n// Private methods\n//------------------------------------------------------------------\n\nrangeSelector.prototype.getOption_ = function(name, opt_series) {\n  return this.dygraph_.getOption(name, opt_series);\n};\n\nrangeSelector.prototype.setDefaultOption_ = function(name, value) {\n  this.dygraph_.attrs_[name] = value;\n};\n\n/**\n * @private\n * Creates the range selector elements and adds them to the graph.\n */\nrangeSelector.prototype.createInterface_ = function() {\n  this.createCanvases_();\n  this.createZoomHandles_();\n  this.initInteraction_();\n\n  // Range selector and animatedZooms have a bad interaction. See issue 359.\n  if (this.getOption_('animatedZooms')) {\n    console.warn('Animated zooms and range selector are not compatible; disabling animatedZooms.');\n    this.dygraph_.updateOptions({animatedZooms: false}, true);\n  }\n\n  this.interfaceCreated_ = true;\n  this.addToGraph_();\n};\n\n/**\n * @private\n * Adds the range selector to the graph.\n */\nrangeSelector.prototype.addToGraph_ = function() {\n  var graphDiv = this.graphDiv_ = this.dygraph_.graphDiv;\n  graphDiv.appendChild(this.bgcanvas_);\n  graphDiv.appendChild(this.fgcanvas_);\n  graphDiv.appendChild(this.leftZoomHandle_);\n  graphDiv.appendChild(this.rightZoomHandle_);\n};\n\n/**\n * @private\n * Removes the range selector from the graph.\n */\nrangeSelector.prototype.removeFromGraph_ = function() {\n  var graphDiv = this.graphDiv_;\n  graphDiv.removeChild(this.bgcanvas_);\n  graphDiv.removeChild(this.fgcanvas_);\n  graphDiv.removeChild(this.leftZoomHandle_);\n  graphDiv.removeChild(this.rightZoomHandle_);\n  this.graphDiv_ = null;\n};\n\n/**\n * @private\n * Called by Layout to allow range selector to reserve its space.\n */\nrangeSelector.prototype.reserveSpace_ = function(e) {\n  if (this.getOption_('showRangeSelector')) {\n    e.reserveSpaceBottom(this.getOption_('rangeSelectorHeight') + 4);\n  }\n};\n\n/**\n * @private\n * Renders the static portion of the range selector at the predraw stage.\n */\nrangeSelector.prototype.renderStaticLayer_ = function() {\n  if (!this.updateVisibility_()) {\n    return;\n  }\n  this.resize_();\n  this.drawStaticLayer_();\n};\n\n/**\n * @private\n * Renders the interactive portion of the range selector after the chart has been drawn.\n */\nrangeSelector.prototype.renderInteractiveLayer_ = function() {\n  if (!this.updateVisibility_() || this.isChangingRange_) {\n    return;\n  }\n  this.placeZoomHandles_();\n  this.drawInteractiveLayer_();\n};\n\n/**\n * @private\n * Check to see if the range selector is enabled/disabled and update visibility accordingly.\n */\nrangeSelector.prototype.updateVisibility_ = function() {\n  var enabled = this.getOption_('showRangeSelector');\n  if (enabled) {\n    if (!this.interfaceCreated_) {\n      this.createInterface_();\n    } else if (!this.graphDiv_ || !this.graphDiv_.parentNode) {\n      this.addToGraph_();\n    }\n  } else if (this.graphDiv_) {\n    this.removeFromGraph_();\n    var dygraph = this.dygraph_;\n    setTimeout(function() { dygraph.width_ = 0; dygraph.resize(); }, 1);\n  }\n  return enabled;\n};\n\n/**\n * @private\n * Resizes the range selector.\n */\nrangeSelector.prototype.resize_ = function() {\n  function setElementRect(canvas, context, rect, pixelRatioOption) {\n    var canvasScale = pixelRatioOption || _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"getContextPixelRatio\"](context);\n\n    canvas.style.top = rect.y + 'px';\n    canvas.style.left = rect.x + 'px';\n    canvas.width = rect.w * canvasScale;\n    canvas.height = rect.h * canvasScale;\n    canvas.style.width = rect.w + 'px';\n    canvas.style.height = rect.h + 'px';\n\n    if(canvasScale != 1) {\n      context.scale(canvasScale, canvasScale);\n    }\n  }\n\n  var plotArea = this.dygraph_.layout_.getPlotArea();\n\n  var xAxisLabelHeight = 0;\n  if (this.dygraph_.getOptionForAxis('drawAxis', 'x')) {\n    xAxisLabelHeight = this.getOption_('xAxisHeight') || (this.getOption_('axisLabelFontSize') + 2 * this.getOption_('axisTickSize'));\n  }\n  this.canvasRect_ = {\n    x: plotArea.x,\n    y: plotArea.y + plotArea.h + xAxisLabelHeight + 4,\n    w: plotArea.w,\n    h: this.getOption_('rangeSelectorHeight')\n  };\n\n  var pixelRatioOption = this.dygraph_.getNumericOption('pixelRatio');\n  setElementRect(this.bgcanvas_, this.bgcanvas_ctx_, this.canvasRect_, pixelRatioOption);\n  setElementRect(this.fgcanvas_, this.fgcanvas_ctx_, this.canvasRect_, pixelRatioOption);\n};\n\n/**\n * @private\n * Creates the background and foreground canvases.\n */\nrangeSelector.prototype.createCanvases_ = function() {\n  this.bgcanvas_ = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"createCanvas\"]();\n  this.bgcanvas_.className = 'dygraph-rangesel-bgcanvas';\n  this.bgcanvas_.style.position = 'absolute';\n  this.bgcanvas_.style.zIndex = 9;\n  this.bgcanvas_ctx_ = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"getContext\"](this.bgcanvas_);\n\n  this.fgcanvas_ = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"createCanvas\"]();\n  this.fgcanvas_.className = 'dygraph-rangesel-fgcanvas';\n  this.fgcanvas_.style.position = 'absolute';\n  this.fgcanvas_.style.zIndex = 9;\n  this.fgcanvas_.style.cursor = 'default';\n  this.fgcanvas_ctx_ = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"getContext\"](this.fgcanvas_);\n};\n\n/**\n * @private\n * Creates the zoom handle elements.\n */\nrangeSelector.prototype.createZoomHandles_ = function() {\n  var img = new Image();\n  img.className = 'dygraph-rangesel-zoomhandle';\n  img.style.position = 'absolute';\n  img.style.zIndex = 10;\n  img.style.visibility = 'hidden'; // Initially hidden so they don't show up in the wrong place.\n  img.style.cursor = 'col-resize';\n  // TODO: change image to more options\n  img.width = 9;\n  img.height = 16;\n  img.src = 'data:image/png;base64,' +\n'iVBORw0KGgoAAAANSUhEUgAAAAkAAAAQCAYAAADESFVDAAAAAXNSR0IArs4c6QAAAAZiS0dEANAA' +\n'zwDP4Z7KegAAAAlwSFlzAAAOxAAADsQBlSsOGwAAAAd0SU1FB9sHGw0cMqdt1UwAAAAZdEVYdENv' +\n'bW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAaElEQVQoz+3SsRFAQBCF4Z9WJM8KCDVwownl' +\n'6YXsTmCUsyKGkZzcl7zkz3YLkypgAnreFmDEpHkIwVOMfpdi9CEEN2nGpFdwD03yEqDtOgCaun7s' +\n'qSTDH32I1pQA2Pb9sZecAxc5r3IAb21d6878xsAAAAAASUVORK5CYII=';\n\n  if (this.isMobileDevice_) {\n    img.width *= 2;\n    img.height *= 2;\n  }\n\n  this.leftZoomHandle_ = img;\n  this.rightZoomHandle_ = img.cloneNode(false);\n};\n\n/**\n * @private\n * Sets up the interaction for the range selector.\n */\nrangeSelector.prototype.initInteraction_ = function() {\n  var self = this;\n  var topElem = document;\n  var clientXLast = 0;\n  var handle = null;\n  var isZooming = false;\n  var isPanning = false;\n  var dynamic = !this.isMobileDevice_;\n\n  // We cover iframes during mouse interactions. See comments in\n  // dygraph-utils.js for more info on why this is a good idea.\n  var tarp = new _iframe_tarp__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n\n  // functions, defined below.  Defining them this way (rather than with\n  // \"function foo() {...}\" makes JSHint happy.\n  var toXDataWindow, onZoomStart, onZoom, onZoomEnd, doZoom, isMouseInPanZone,\n      onPanStart, onPan, onPanEnd, doPan, onCanvasHover;\n\n  // Touch event functions\n  var onZoomHandleTouchEvent, onCanvasTouchEvent, addTouchEvents;\n\n  toXDataWindow = function(zoomHandleStatus) {\n    var xDataLimits = self.dygraph_.xAxisExtremes();\n    var fact = (xDataLimits[1] - xDataLimits[0])/self.canvasRect_.w;\n    var xDataMin = xDataLimits[0] + (zoomHandleStatus.leftHandlePos - self.canvasRect_.x)*fact;\n    var xDataMax = xDataLimits[0] + (zoomHandleStatus.rightHandlePos - self.canvasRect_.x)*fact;\n    return [xDataMin, xDataMax];\n  };\n\n  onZoomStart = function(e) {\n    _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"cancelEvent\"](e);\n    isZooming = true;\n    clientXLast = e.clientX;\n    handle = e.target ? e.target : e.srcElement;\n    if (e.type === 'mousedown' || e.type === 'dragstart') {\n      // These events are removed manually.\n      _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"addEvent\"](topElem, 'mousemove', onZoom);\n      _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"addEvent\"](topElem, 'mouseup', onZoomEnd);\n    }\n    self.fgcanvas_.style.cursor = 'col-resize';\n    tarp.cover();\n    return true;\n  };\n\n  onZoom = function(e) {\n    if (!isZooming) {\n      return false;\n    }\n    _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"cancelEvent\"](e);\n\n    var delX = e.clientX - clientXLast;\n    if (Math.abs(delX) < 4) {\n      return true;\n    }\n    clientXLast = e.clientX;\n\n    // Move handle.\n    var zoomHandleStatus = self.getZoomHandleStatus_();\n    var newPos;\n    if (handle == self.leftZoomHandle_) {\n      newPos = zoomHandleStatus.leftHandlePos + delX;\n      newPos = Math.min(newPos, zoomHandleStatus.rightHandlePos - handle.width - 3);\n      newPos = Math.max(newPos, self.canvasRect_.x);\n    } else {\n      newPos = zoomHandleStatus.rightHandlePos + delX;\n      newPos = Math.min(newPos, self.canvasRect_.x + self.canvasRect_.w);\n      newPos = Math.max(newPos, zoomHandleStatus.leftHandlePos + handle.width + 3);\n    }\n    var halfHandleWidth = handle.width/2;\n    handle.style.left = (newPos - halfHandleWidth) + 'px';\n    self.drawInteractiveLayer_();\n\n    // Zoom on the fly.\n    if (dynamic) {\n      doZoom();\n    }\n    return true;\n  };\n\n  onZoomEnd = function(e) {\n    if (!isZooming) {\n      return false;\n    }\n    isZooming = false;\n    tarp.uncover();\n    _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"removeEvent\"](topElem, 'mousemove', onZoom);\n    _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"removeEvent\"](topElem, 'mouseup', onZoomEnd);\n    self.fgcanvas_.style.cursor = 'default';\n\n    // If on a slower device, zoom now.\n    if (!dynamic) {\n      doZoom();\n    }\n    return true;\n  };\n\n  doZoom = function() {\n    try {\n      var zoomHandleStatus = self.getZoomHandleStatus_();\n      self.isChangingRange_ = true;\n      if (!zoomHandleStatus.isZoomed) {\n        self.dygraph_.resetZoom();\n      } else {\n        var xDataWindow = toXDataWindow(zoomHandleStatus);\n        self.dygraph_.doZoomXDates_(xDataWindow[0], xDataWindow[1]);\n      }\n    } finally {\n      self.isChangingRange_ = false;\n    }\n  };\n\n  isMouseInPanZone = function(e) {\n    var rect = self.leftZoomHandle_.getBoundingClientRect();\n    var leftHandleClientX = rect.left + rect.width/2;\n    rect = self.rightZoomHandle_.getBoundingClientRect();\n    var rightHandleClientX = rect.left + rect.width/2;\n    return (e.clientX > leftHandleClientX && e.clientX < rightHandleClientX);\n  };\n\n  onPanStart = function(e) {\n    if (!isPanning && isMouseInPanZone(e) && self.getZoomHandleStatus_().isZoomed) {\n      _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"cancelEvent\"](e);\n      isPanning = true;\n      clientXLast = e.clientX;\n      if (e.type === 'mousedown') {\n        // These events are removed manually.\n        _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"addEvent\"](topElem, 'mousemove', onPan);\n        _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"addEvent\"](topElem, 'mouseup', onPanEnd);\n      }\n      return true;\n    }\n    return false;\n  };\n\n  onPan = function(e) {\n    if (!isPanning) {\n      return false;\n    }\n    _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"cancelEvent\"](e);\n\n    var delX = e.clientX - clientXLast;\n    if (Math.abs(delX) < 4) {\n      return true;\n    }\n    clientXLast = e.clientX;\n\n    // Move range view\n    var zoomHandleStatus = self.getZoomHandleStatus_();\n    var leftHandlePos = zoomHandleStatus.leftHandlePos;\n    var rightHandlePos = zoomHandleStatus.rightHandlePos;\n    var rangeSize = rightHandlePos - leftHandlePos;\n    if (leftHandlePos + delX <= self.canvasRect_.x) {\n      leftHandlePos = self.canvasRect_.x;\n      rightHandlePos = leftHandlePos + rangeSize;\n    } else if (rightHandlePos + delX >= self.canvasRect_.x + self.canvasRect_.w) {\n      rightHandlePos = self.canvasRect_.x + self.canvasRect_.w;\n      leftHandlePos = rightHandlePos - rangeSize;\n    } else {\n      leftHandlePos += delX;\n      rightHandlePos += delX;\n    }\n    var halfHandleWidth = self.leftZoomHandle_.width/2;\n    self.leftZoomHandle_.style.left = (leftHandlePos - halfHandleWidth) + 'px';\n    self.rightZoomHandle_.style.left = (rightHandlePos - halfHandleWidth) + 'px';\n    self.drawInteractiveLayer_();\n\n    // Do pan on the fly.\n    if (dynamic) {\n      doPan();\n    }\n    return true;\n  };\n\n  onPanEnd = function(e) {\n    if (!isPanning) {\n      return false;\n    }\n    isPanning = false;\n    _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"removeEvent\"](topElem, 'mousemove', onPan);\n    _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"removeEvent\"](topElem, 'mouseup', onPanEnd);\n    // If on a slower device, do pan now.\n    if (!dynamic) {\n      doPan();\n    }\n    return true;\n  };\n\n  doPan = function() {\n    try {\n      self.isChangingRange_ = true;\n      self.dygraph_.dateWindow_ = toXDataWindow(self.getZoomHandleStatus_());\n      self.dygraph_.drawGraph_(false);\n    } finally {\n      self.isChangingRange_ = false;\n    }\n  };\n\n  onCanvasHover = function(e) {\n    if (isZooming || isPanning) {\n      return;\n    }\n    var cursor = isMouseInPanZone(e) ? 'move' : 'default';\n    if (cursor != self.fgcanvas_.style.cursor) {\n      self.fgcanvas_.style.cursor = cursor;\n    }\n  };\n\n  onZoomHandleTouchEvent = function(e) {\n    if (e.type == 'touchstart' && e.targetTouches.length == 1) {\n      if (onZoomStart(e.targetTouches[0])) {\n        _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"cancelEvent\"](e);\n      }\n    } else if (e.type == 'touchmove' && e.targetTouches.length == 1) {\n      if (onZoom(e.targetTouches[0])) {\n        _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"cancelEvent\"](e);\n      }\n    } else {\n      onZoomEnd(e);\n    }\n  };\n\n  onCanvasTouchEvent = function(e) {\n    if (e.type == 'touchstart' && e.targetTouches.length == 1) {\n      if (onPanStart(e.targetTouches[0])) {\n        _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"cancelEvent\"](e);\n      }\n    } else if (e.type == 'touchmove' && e.targetTouches.length == 1) {\n      if (onPan(e.targetTouches[0])) {\n        _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"cancelEvent\"](e);\n      }\n    } else {\n      onPanEnd(e);\n    }\n  };\n\n  addTouchEvents = function(elem, fn) {\n    var types = ['touchstart', 'touchend', 'touchmove', 'touchcancel'];\n    for (var i = 0; i < types.length; i++) {\n      self.dygraph_.addAndTrackEvent(elem, types[i], fn);\n    }\n  };\n\n  this.setDefaultOption_('interactionModel', _dygraph_interaction_model__WEBPACK_IMPORTED_MODULE_1__[\"default\"].dragIsPanInteractionModel);\n  this.setDefaultOption_('panEdgeFraction', 0.0001);\n\n  var dragStartEvent = window.opera ? 'mousedown' : 'dragstart';\n  this.dygraph_.addAndTrackEvent(this.leftZoomHandle_, dragStartEvent, onZoomStart);\n  this.dygraph_.addAndTrackEvent(this.rightZoomHandle_, dragStartEvent, onZoomStart);\n\n  this.dygraph_.addAndTrackEvent(this.fgcanvas_, 'mousedown', onPanStart);\n  this.dygraph_.addAndTrackEvent(this.fgcanvas_, 'mousemove', onCanvasHover);\n\n  // Touch events\n  if (this.hasTouchInterface_) {\n    addTouchEvents(this.leftZoomHandle_, onZoomHandleTouchEvent);\n    addTouchEvents(this.rightZoomHandle_, onZoomHandleTouchEvent);\n    addTouchEvents(this.fgcanvas_, onCanvasTouchEvent);\n  }\n};\n\n/**\n * @private\n * Draws the static layer in the background canvas.\n */\nrangeSelector.prototype.drawStaticLayer_ = function() {\n  var ctx = this.bgcanvas_ctx_;\n  ctx.clearRect(0, 0, this.canvasRect_.w, this.canvasRect_.h);\n  try {\n    this.drawMiniPlot_();\n  } catch(ex) {\n    console.warn(ex);\n  }\n\n  var margin = 0.5;\n  this.bgcanvas_ctx_.lineWidth = this.getOption_('rangeSelectorBackgroundLineWidth');\n  ctx.strokeStyle = this.getOption_('rangeSelectorBackgroundStrokeColor');\n  ctx.beginPath();\n  ctx.moveTo(margin, margin);\n  ctx.lineTo(margin, this.canvasRect_.h-margin);\n  ctx.lineTo(this.canvasRect_.w-margin, this.canvasRect_.h-margin);\n  ctx.lineTo(this.canvasRect_.w-margin, margin);\n  ctx.stroke();\n};\n\n\n/**\n * @private\n * Draws the mini plot in the background canvas.\n */\nrangeSelector.prototype.drawMiniPlot_ = function() {\n  var fillStyle = this.getOption_('rangeSelectorPlotFillColor');\n  var fillGradientStyle = this.getOption_('rangeSelectorPlotFillGradientColor');\n  var strokeStyle = this.getOption_('rangeSelectorPlotStrokeColor');\n  if (!fillStyle && !strokeStyle) {\n    return;\n  }\n\n  var stepPlot = this.getOption_('stepPlot');\n\n  var combinedSeriesData = this.computeCombinedSeriesAndLimits_();\n  var yRange = combinedSeriesData.yMax - combinedSeriesData.yMin;\n\n  // Draw the mini plot.\n  var ctx = this.bgcanvas_ctx_;\n  var margin = 0.5;\n\n  var xExtremes = this.dygraph_.xAxisExtremes();\n  var xRange = Math.max(xExtremes[1] - xExtremes[0], 1.e-30);\n  var xFact = (this.canvasRect_.w - margin)/xRange;\n  var yFact = (this.canvasRect_.h - margin)/yRange;\n  var canvasWidth = this.canvasRect_.w - margin;\n  var canvasHeight = this.canvasRect_.h - margin;\n\n  var prevX = null, prevY = null;\n\n  ctx.beginPath();\n  ctx.moveTo(margin, canvasHeight);\n  for (var i = 0; i < combinedSeriesData.data.length; i++) {\n    var dataPoint = combinedSeriesData.data[i];\n    var x = ((dataPoint[0] !== null) ? ((dataPoint[0] - xExtremes[0])*xFact) : NaN);\n    var y = ((dataPoint[1] !== null) ? (canvasHeight - (dataPoint[1] - combinedSeriesData.yMin)*yFact) : NaN);\n\n    // Skip points that don't change the x-value. Overly fine-grained points\n    // can cause major slowdowns with the ctx.fill() call below.\n    if (!stepPlot && prevX !== null && Math.round(x) == Math.round(prevX)) {\n      continue;\n    }\n\n    if (isFinite(x) && isFinite(y)) {\n      if(prevX === null) {\n        ctx.lineTo(x, canvasHeight);\n      }\n      else if (stepPlot) {\n        ctx.lineTo(x, prevY);\n      }\n      ctx.lineTo(x, y);\n      prevX = x;\n      prevY = y;\n    }\n    else {\n      if(prevX !== null) {\n        if (stepPlot) {\n          ctx.lineTo(x, prevY);\n          ctx.lineTo(x, canvasHeight);\n        }\n        else {\n          ctx.lineTo(prevX, canvasHeight);\n        }\n      }\n      prevX = prevY = null;\n    }\n  }\n  ctx.lineTo(canvasWidth, canvasHeight);\n  ctx.closePath();\n\n  if (fillStyle) {\n    var lingrad = this.bgcanvas_ctx_.createLinearGradient(0, 0, 0, canvasHeight);\n    if (fillGradientStyle) {\n      lingrad.addColorStop(0, fillGradientStyle);\n    }\n    lingrad.addColorStop(1, fillStyle);\n    this.bgcanvas_ctx_.fillStyle = lingrad;\n    ctx.fill();\n  }\n\n  if (strokeStyle) {\n    this.bgcanvas_ctx_.strokeStyle = strokeStyle;\n    this.bgcanvas_ctx_.lineWidth = this.getOption_('rangeSelectorPlotLineWidth');\n    ctx.stroke();\n  }\n};\n\n/**\n * @private\n * Computes and returns the combined series data along with min/max for the mini plot.\n * The combined series consists of averaged values for all series.\n * When series have error bars, the error bars are ignored.\n * @return {Object} An object containing combined series array, ymin, ymax.\n */\nrangeSelector.prototype.computeCombinedSeriesAndLimits_ = function() {\n  var g = this.dygraph_;\n  var logscale = this.getOption_('logscale');\n  var i;\n\n  // Select series to combine. By default, all series are combined.\n  var numColumns = g.numColumns();\n  var labels = g.getLabels();\n  var includeSeries = new Array(numColumns);\n  var anySet = false;\n  var visibility = g.visibility();\n  var inclusion = [];\n\n  for (i = 1; i < numColumns; i++) {\n    var include = this.getOption_('showInRangeSelector', labels[i]);\n    inclusion.push(include);\n    if (include !== null) anySet = true;  // it's set explicitly for this series\n  }\n\n  if (anySet) {\n    for (i = 1; i < numColumns; i++) {\n      includeSeries[i] = inclusion[i - 1];\n    }\n  } else {\n    for (i = 1; i < numColumns; i++) {\n      includeSeries[i] = visibility[i - 1];\n    }\n  }\n\n  // Create a combined series (average of selected series values).\n  // TODO(danvk): short-circuit if there's only one series.\n  var rolledSeries = [];\n  var dataHandler = g.dataHandler_;\n  var options = g.attributes_;\n  for (i = 1; i < g.numColumns(); i++) {\n    if (!includeSeries[i]) continue;\n    var series = dataHandler.extractSeries(g.rawData_, i, options);\n    if (g.rollPeriod() > 1) {\n      series = dataHandler.rollingAverage(series, g.rollPeriod(), options);\n    }\n\n    rolledSeries.push(series);\n  }\n\n  var combinedSeries = [];\n  for (i = 0; i < rolledSeries[0].length; i++) {\n    var sum = 0;\n    var count = 0;\n    for (var j = 0; j < rolledSeries.length; j++) {\n      var y = rolledSeries[j][i][1];\n      if (y === null || isNaN(y)) continue;\n      count++;\n      sum += y;\n    }\n    combinedSeries.push([rolledSeries[0][i][0], sum / count]);\n  }\n\n  // Compute the y range.\n  var yMin = Number.MAX_VALUE;\n  var yMax = -Number.MAX_VALUE;\n  for (i = 0; i < combinedSeries.length; i++) {\n    var yVal = combinedSeries[i][1];\n    if (yVal !== null && isFinite(yVal) && (!logscale || yVal > 0)) {\n      yMin = Math.min(yMin, yVal);\n      yMax = Math.max(yMax, yVal);\n    }\n  }\n\n  // Convert Y data to log scale if needed.\n  // Also, expand the Y range to compress the mini plot a little.\n  var extraPercent = 0.25;\n  if (logscale) {\n    yMax = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"log10\"](yMax);\n    yMax += yMax*extraPercent;\n    yMin = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"log10\"](yMin);\n    for (i = 0; i < combinedSeries.length; i++) {\n      combinedSeries[i][1] = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[\"log10\"](combinedSeries[i][1]);\n    }\n  } else {\n    var yExtra;\n    var yRange = yMax - yMin;\n    if (yRange <= Number.MIN_VALUE) {\n      yExtra = yMax*extraPercent;\n    } else {\n      yExtra = yRange*extraPercent;\n    }\n    yMax += yExtra;\n    yMin -= yExtra;\n  }\n\n  return {data: combinedSeries, yMin: yMin, yMax: yMax};\n};\n\n/**\n * @private\n * Places the zoom handles in the proper position based on the current X data window.\n */\nrangeSelector.prototype.placeZoomHandles_ = function() {\n  var xExtremes = this.dygraph_.xAxisExtremes();\n  var xWindowLimits = this.dygraph_.xAxisRange();\n  var xRange = xExtremes[1] - xExtremes[0];\n  var leftPercent = Math.max(0, (xWindowLimits[0] - xExtremes[0])/xRange);\n  var rightPercent = Math.max(0, (xExtremes[1] - xWindowLimits[1])/xRange);\n  var leftCoord = this.canvasRect_.x + this.canvasRect_.w*leftPercent;\n  var rightCoord = this.canvasRect_.x + this.canvasRect_.w*(1 - rightPercent);\n  var handleTop = Math.max(this.canvasRect_.y, this.canvasRect_.y + (this.canvasRect_.h - this.leftZoomHandle_.height)/2);\n  var halfHandleWidth = this.leftZoomHandle_.width/2;\n  this.leftZoomHandle_.style.left = (leftCoord - halfHandleWidth) + 'px';\n  this.leftZoomHandle_.style.top = handleTop + 'px';\n  this.rightZoomHandle_.style.left = (rightCoord - halfHandleWidth) + 'px';\n  this.rightZoomHandle_.style.top = this.leftZoomHandle_.style.top;\n\n  this.leftZoomHandle_.style.visibility = 'visible';\n  this.rightZoomHandle_.style.visibility = 'visible';\n};\n\n/**\n * @private\n * Draws the interactive layer in the foreground canvas.\n */\nrangeSelector.prototype.drawInteractiveLayer_ = function() {\n  var ctx = this.fgcanvas_ctx_;\n  ctx.clearRect(0, 0, this.canvasRect_.w, this.canvasRect_.h);\n  var margin = 1;\n  var width = this.canvasRect_.w - margin;\n  var height = this.canvasRect_.h - margin;\n  var zoomHandleStatus = this.getZoomHandleStatus_();\n\n  ctx.strokeStyle = this.getOption_('rangeSelectorForegroundStrokeColor');\n  ctx.lineWidth = this.getOption_('rangeSelectorForegroundLineWidth');\n  if (!zoomHandleStatus.isZoomed) {\n    ctx.beginPath();\n    ctx.moveTo(margin, margin);\n    ctx.lineTo(margin, height);\n    ctx.lineTo(width, height);\n    ctx.lineTo(width, margin);\n    ctx.stroke();\n  } else {\n    var leftHandleCanvasPos = Math.max(margin, zoomHandleStatus.leftHandlePos - this.canvasRect_.x);\n    var rightHandleCanvasPos = Math.min(width, zoomHandleStatus.rightHandlePos - this.canvasRect_.x);\n\n    ctx.fillStyle = 'rgba(240, 240, 240, ' + this.getOption_('rangeSelectorAlpha').toString() + ')';\n    ctx.fillRect(0, 0, leftHandleCanvasPos, this.canvasRect_.h);\n    ctx.fillRect(rightHandleCanvasPos, 0, this.canvasRect_.w - rightHandleCanvasPos, this.canvasRect_.h);\n\n    ctx.beginPath();\n    ctx.moveTo(margin, margin);\n    ctx.lineTo(leftHandleCanvasPos, margin);\n    ctx.lineTo(leftHandleCanvasPos, height);\n    ctx.lineTo(rightHandleCanvasPos, height);\n    ctx.lineTo(rightHandleCanvasPos, margin);\n    ctx.lineTo(width, margin);\n    ctx.stroke();\n  }\n};\n\n/**\n * @private\n * Returns the current zoom handle position information.\n * @return {Object} The zoom handle status.\n */\nrangeSelector.prototype.getZoomHandleStatus_ = function() {\n  var halfHandleWidth = this.leftZoomHandle_.width/2;\n  var leftHandlePos = parseFloat(this.leftZoomHandle_.style.left) + halfHandleWidth;\n  var rightHandlePos = parseFloat(this.rightZoomHandle_.style.left) + halfHandleWidth;\n  return {\n      leftHandlePos: leftHandlePos,\n      rightHandlePos: rightHandlePos,\n      isZoomed: (leftHandlePos - 1 > this.canvasRect_.x || rightHandlePos + 1 < this.canvasRect_.x+this.canvasRect_.w)\n  };\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (rangeSelector);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibkdvVy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9keWdyYXBocy9zcmMvcGx1Z2lucy9yYW5nZS1zZWxlY3Rvci5qcz85YzZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDExIFBhdWwgRmVsaXggKHBhdWwuZXJpYy5mZWxpeEBnbWFpbC5jb20pXG4gKiBNSVQtbGljZW5zZWQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gKi9cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UsVG91Y2hFdmVudDpmYWxzZSAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBSYW5nZVNlbGVjdG9yIHBsdWdpbiB1c2VkIHRvIHByb3ZpZGVcbiAqIGEgdGltZWxpbmUgcmFuZ2Ugc2VsZWN0b3Igd2lkZ2V0IGZvciBkeWdyYXBocy5cbiAqL1xuXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vZHlncmFwaC11dGlscyc7XG5pbXBvcnQgRHlncmFwaEludGVyYWN0aW9uIGZyb20gJy4uL2R5Z3JhcGgtaW50ZXJhY3Rpb24tbW9kZWwnO1xuaW1wb3J0IElGcmFtZVRhcnAgZnJvbSAnLi4vaWZyYW1lLXRhcnAnO1xuXG52YXIgcmFuZ2VTZWxlY3RvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmhhc1RvdWNoSW50ZXJmYWNlXyA9IHR5cGVvZihUb3VjaEV2ZW50KSAhPSAndW5kZWZpbmVkJztcbiAgdGhpcy5pc01vYmlsZURldmljZV8gPSAvbW9iaWxlfGFuZHJvaWQvZ2kudGVzdChuYXZpZ2F0b3IuYXBwVmVyc2lvbik7XG4gIHRoaXMuaW50ZXJmYWNlQ3JlYXRlZF8gPSBmYWxzZTtcbn07XG5cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBcIlJhbmdlU2VsZWN0b3IgUGx1Z2luXCI7XG59O1xuXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKGR5Z3JhcGgpIHtcbiAgdGhpcy5keWdyYXBoXyA9IGR5Z3JhcGg7XG4gIGlmICh0aGlzLmdldE9wdGlvbl8oJ3Nob3dSYW5nZVNlbGVjdG9yJykpIHtcbiAgICB0aGlzLmNyZWF0ZUludGVyZmFjZV8oKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGxheW91dDogdGhpcy5yZXNlcnZlU3BhY2VfLFxuICAgIHByZWRyYXc6IHRoaXMucmVuZGVyU3RhdGljTGF5ZXJfLFxuICAgIGRpZERyYXdDaGFydDogdGhpcy5yZW5kZXJJbnRlcmFjdGl2ZUxheWVyX1xuICB9O1xufTtcblxucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmJnY2FudmFzXyA9IG51bGw7XG4gIHRoaXMuZmdjYW52YXNfID0gbnVsbDtcbiAgdGhpcy5sZWZ0Wm9vbUhhbmRsZV8gPSBudWxsO1xuICB0aGlzLnJpZ2h0Wm9vbUhhbmRsZV8gPSBudWxsO1xufTtcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgbWV0aG9kc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuZ2V0T3B0aW9uXyA9IGZ1bmN0aW9uKG5hbWUsIG9wdF9zZXJpZXMpIHtcbiAgcmV0dXJuIHRoaXMuZHlncmFwaF8uZ2V0T3B0aW9uKG5hbWUsIG9wdF9zZXJpZXMpO1xufTtcblxucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuc2V0RGVmYXVsdE9wdGlvbl8gPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB0aGlzLmR5Z3JhcGhfLmF0dHJzX1tuYW1lXSA9IHZhbHVlO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQ3JlYXRlcyB0aGUgcmFuZ2Ugc2VsZWN0b3IgZWxlbWVudHMgYW5kIGFkZHMgdGhlbSB0byB0aGUgZ3JhcGguXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmNyZWF0ZUludGVyZmFjZV8gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jcmVhdGVDYW52YXNlc18oKTtcbiAgdGhpcy5jcmVhdGVab29tSGFuZGxlc18oKTtcbiAgdGhpcy5pbml0SW50ZXJhY3Rpb25fKCk7XG5cbiAgLy8gUmFuZ2Ugc2VsZWN0b3IgYW5kIGFuaW1hdGVkWm9vbXMgaGF2ZSBhIGJhZCBpbnRlcmFjdGlvbi4gU2VlIGlzc3VlIDM1OS5cbiAgaWYgKHRoaXMuZ2V0T3B0aW9uXygnYW5pbWF0ZWRab29tcycpKSB7XG4gICAgY29uc29sZS53YXJuKCdBbmltYXRlZCB6b29tcyBhbmQgcmFuZ2Ugc2VsZWN0b3IgYXJlIG5vdCBjb21wYXRpYmxlOyBkaXNhYmxpbmcgYW5pbWF0ZWRab29tcy4nKTtcbiAgICB0aGlzLmR5Z3JhcGhfLnVwZGF0ZU9wdGlvbnMoe2FuaW1hdGVkWm9vbXM6IGZhbHNlfSwgdHJ1ZSk7XG4gIH1cblxuICB0aGlzLmludGVyZmFjZUNyZWF0ZWRfID0gdHJ1ZTtcbiAgdGhpcy5hZGRUb0dyYXBoXygpO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQWRkcyB0aGUgcmFuZ2Ugc2VsZWN0b3IgdG8gdGhlIGdyYXBoLlxuICovXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5hZGRUb0dyYXBoXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZ3JhcGhEaXYgPSB0aGlzLmdyYXBoRGl2XyA9IHRoaXMuZHlncmFwaF8uZ3JhcGhEaXY7XG4gIGdyYXBoRGl2LmFwcGVuZENoaWxkKHRoaXMuYmdjYW52YXNfKTtcbiAgZ3JhcGhEaXYuYXBwZW5kQ2hpbGQodGhpcy5mZ2NhbnZhc18pO1xuICBncmFwaERpdi5hcHBlbmRDaGlsZCh0aGlzLmxlZnRab29tSGFuZGxlXyk7XG4gIGdyYXBoRGl2LmFwcGVuZENoaWxkKHRoaXMucmlnaHRab29tSGFuZGxlXyk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZW1vdmVzIHRoZSByYW5nZSBzZWxlY3RvciBmcm9tIHRoZSBncmFwaC5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUucmVtb3ZlRnJvbUdyYXBoXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZ3JhcGhEaXYgPSB0aGlzLmdyYXBoRGl2XztcbiAgZ3JhcGhEaXYucmVtb3ZlQ2hpbGQodGhpcy5iZ2NhbnZhc18pO1xuICBncmFwaERpdi5yZW1vdmVDaGlsZCh0aGlzLmZnY2FudmFzXyk7XG4gIGdyYXBoRGl2LnJlbW92ZUNoaWxkKHRoaXMubGVmdFpvb21IYW5kbGVfKTtcbiAgZ3JhcGhEaXYucmVtb3ZlQ2hpbGQodGhpcy5yaWdodFpvb21IYW5kbGVfKTtcbiAgdGhpcy5ncmFwaERpdl8gPSBudWxsO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQ2FsbGVkIGJ5IExheW91dCB0byBhbGxvdyByYW5nZSBzZWxlY3RvciB0byByZXNlcnZlIGl0cyBzcGFjZS5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUucmVzZXJ2ZVNwYWNlXyA9IGZ1bmN0aW9uKGUpIHtcbiAgaWYgKHRoaXMuZ2V0T3B0aW9uXygnc2hvd1JhbmdlU2VsZWN0b3InKSkge1xuICAgIGUucmVzZXJ2ZVNwYWNlQm90dG9tKHRoaXMuZ2V0T3B0aW9uXygncmFuZ2VTZWxlY3RvckhlaWdodCcpICsgNCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFJlbmRlcnMgdGhlIHN0YXRpYyBwb3J0aW9uIG9mIHRoZSByYW5nZSBzZWxlY3RvciBhdCB0aGUgcHJlZHJhdyBzdGFnZS5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUucmVuZGVyU3RhdGljTGF5ZXJfID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy51cGRhdGVWaXNpYmlsaXR5XygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucmVzaXplXygpO1xuICB0aGlzLmRyYXdTdGF0aWNMYXllcl8oKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFJlbmRlcnMgdGhlIGludGVyYWN0aXZlIHBvcnRpb24gb2YgdGhlIHJhbmdlIHNlbGVjdG9yIGFmdGVyIHRoZSBjaGFydCBoYXMgYmVlbiBkcmF3bi5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUucmVuZGVySW50ZXJhY3RpdmVMYXllcl8gPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLnVwZGF0ZVZpc2liaWxpdHlfKCkgfHwgdGhpcy5pc0NoYW5naW5nUmFuZ2VfKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucGxhY2Vab29tSGFuZGxlc18oKTtcbiAgdGhpcy5kcmF3SW50ZXJhY3RpdmVMYXllcl8oKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENoZWNrIHRvIHNlZSBpZiB0aGUgcmFuZ2Ugc2VsZWN0b3IgaXMgZW5hYmxlZC9kaXNhYmxlZCBhbmQgdXBkYXRlIHZpc2liaWxpdHkgYWNjb3JkaW5nbHkuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnVwZGF0ZVZpc2liaWxpdHlfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlbmFibGVkID0gdGhpcy5nZXRPcHRpb25fKCdzaG93UmFuZ2VTZWxlY3RvcicpO1xuICBpZiAoZW5hYmxlZCkge1xuICAgIGlmICghdGhpcy5pbnRlcmZhY2VDcmVhdGVkXykge1xuICAgICAgdGhpcy5jcmVhdGVJbnRlcmZhY2VfKCk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5ncmFwaERpdl8gfHwgIXRoaXMuZ3JhcGhEaXZfLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuYWRkVG9HcmFwaF8oKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5ncmFwaERpdl8pIHtcbiAgICB0aGlzLnJlbW92ZUZyb21HcmFwaF8oKTtcbiAgICB2YXIgZHlncmFwaCA9IHRoaXMuZHlncmFwaF87XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgZHlncmFwaC53aWR0aF8gPSAwOyBkeWdyYXBoLnJlc2l6ZSgpOyB9LCAxKTtcbiAgfVxuICByZXR1cm4gZW5hYmxlZDtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFJlc2l6ZXMgdGhlIHJhbmdlIHNlbGVjdG9yLlxuICovXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5yZXNpemVfID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHNldEVsZW1lbnRSZWN0KGNhbnZhcywgY29udGV4dCwgcmVjdCwgcGl4ZWxSYXRpb09wdGlvbikge1xuICAgIHZhciBjYW52YXNTY2FsZSA9IHBpeGVsUmF0aW9PcHRpb24gfHwgdXRpbHMuZ2V0Q29udGV4dFBpeGVsUmF0aW8oY29udGV4dCk7XG5cbiAgICBjYW52YXMuc3R5bGUudG9wID0gcmVjdC55ICsgJ3B4JztcbiAgICBjYW52YXMuc3R5bGUubGVmdCA9IHJlY3QueCArICdweCc7XG4gICAgY2FudmFzLndpZHRoID0gcmVjdC53ICogY2FudmFzU2NhbGU7XG4gICAgY2FudmFzLmhlaWdodCA9IHJlY3QuaCAqIGNhbnZhc1NjYWxlO1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHJlY3QudyArICdweCc7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IHJlY3QuaCArICdweCc7XG5cbiAgICBpZihjYW52YXNTY2FsZSAhPSAxKSB7XG4gICAgICBjb250ZXh0LnNjYWxlKGNhbnZhc1NjYWxlLCBjYW52YXNTY2FsZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBsb3RBcmVhID0gdGhpcy5keWdyYXBoXy5sYXlvdXRfLmdldFBsb3RBcmVhKCk7XG5cbiAgdmFyIHhBeGlzTGFiZWxIZWlnaHQgPSAwO1xuICBpZiAodGhpcy5keWdyYXBoXy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3QXhpcycsICd4JykpIHtcbiAgICB4QXhpc0xhYmVsSGVpZ2h0ID0gdGhpcy5nZXRPcHRpb25fKCd4QXhpc0hlaWdodCcpIHx8ICh0aGlzLmdldE9wdGlvbl8oJ2F4aXNMYWJlbEZvbnRTaXplJykgKyAyICogdGhpcy5nZXRPcHRpb25fKCdheGlzVGlja1NpemUnKSk7XG4gIH1cbiAgdGhpcy5jYW52YXNSZWN0XyA9IHtcbiAgICB4OiBwbG90QXJlYS54LFxuICAgIHk6IHBsb3RBcmVhLnkgKyBwbG90QXJlYS5oICsgeEF4aXNMYWJlbEhlaWdodCArIDQsXG4gICAgdzogcGxvdEFyZWEudyxcbiAgICBoOiB0aGlzLmdldE9wdGlvbl8oJ3JhbmdlU2VsZWN0b3JIZWlnaHQnKVxuICB9O1xuXG4gIHZhciBwaXhlbFJhdGlvT3B0aW9uID0gdGhpcy5keWdyYXBoXy5nZXROdW1lcmljT3B0aW9uKCdwaXhlbFJhdGlvJyk7XG4gIHNldEVsZW1lbnRSZWN0KHRoaXMuYmdjYW52YXNfLCB0aGlzLmJnY2FudmFzX2N0eF8sIHRoaXMuY2FudmFzUmVjdF8sIHBpeGVsUmF0aW9PcHRpb24pO1xuICBzZXRFbGVtZW50UmVjdCh0aGlzLmZnY2FudmFzXywgdGhpcy5mZ2NhbnZhc19jdHhfLCB0aGlzLmNhbnZhc1JlY3RfLCBwaXhlbFJhdGlvT3B0aW9uKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENyZWF0ZXMgdGhlIGJhY2tncm91bmQgYW5kIGZvcmVncm91bmQgY2FudmFzZXMuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmNyZWF0ZUNhbnZhc2VzXyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmJnY2FudmFzXyA9IHV0aWxzLmNyZWF0ZUNhbnZhcygpO1xuICB0aGlzLmJnY2FudmFzXy5jbGFzc05hbWUgPSAnZHlncmFwaC1yYW5nZXNlbC1iZ2NhbnZhcyc7XG4gIHRoaXMuYmdjYW52YXNfLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgdGhpcy5iZ2NhbnZhc18uc3R5bGUuekluZGV4ID0gOTtcbiAgdGhpcy5iZ2NhbnZhc19jdHhfID0gdXRpbHMuZ2V0Q29udGV4dCh0aGlzLmJnY2FudmFzXyk7XG5cbiAgdGhpcy5mZ2NhbnZhc18gPSB1dGlscy5jcmVhdGVDYW52YXMoKTtcbiAgdGhpcy5mZ2NhbnZhc18uY2xhc3NOYW1lID0gJ2R5Z3JhcGgtcmFuZ2VzZWwtZmdjYW52YXMnO1xuICB0aGlzLmZnY2FudmFzXy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIHRoaXMuZmdjYW52YXNfLnN0eWxlLnpJbmRleCA9IDk7XG4gIHRoaXMuZmdjYW52YXNfLnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcbiAgdGhpcy5mZ2NhbnZhc19jdHhfID0gdXRpbHMuZ2V0Q29udGV4dCh0aGlzLmZnY2FudmFzXyk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBDcmVhdGVzIHRoZSB6b29tIGhhbmRsZSBlbGVtZW50cy5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuY3JlYXRlWm9vbUhhbmRsZXNfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgaW1nLmNsYXNzTmFtZSA9ICdkeWdyYXBoLXJhbmdlc2VsLXpvb21oYW5kbGUnO1xuICBpbWcuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBpbWcuc3R5bGUuekluZGV4ID0gMTA7XG4gIGltZy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7IC8vIEluaXRpYWxseSBoaWRkZW4gc28gdGhleSBkb24ndCBzaG93IHVwIGluIHRoZSB3cm9uZyBwbGFjZS5cbiAgaW1nLnN0eWxlLmN1cnNvciA9ICdjb2wtcmVzaXplJztcbiAgLy8gVE9ETzogY2hhbmdlIGltYWdlIHRvIG1vcmUgb3B0aW9uc1xuICBpbWcud2lkdGggPSA5O1xuICBpbWcuaGVpZ2h0ID0gMTY7XG4gIGltZy5zcmMgPSAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LCcgK1xuJ2lWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBa0FBQUFRQ0FZQUFBREVTRlZEQUFBQUFYTlNSMElBcnM0YzZRQUFBQVppUzBkRUFOQUEnICtcbid6d0RQNFo3S2VnQUFBQWx3U0ZsekFBQU94QUFBRHNRQmxTc09Hd0FBQUFkMFNVMUZCOXNIR3cwY01xZHQxVXdBQUFBWmRFVllkRU52JyArXG4nYlcxbGJuUUFRM0psWVhSbFpDQjNhWFJvSUVkSlRWQlhnUTRYQUFBQWFFbEVRVlFveiszU3NSRkFRQkNGNFo5V0pNOEtDRFZ3b3dubCcgK1xuJzZZWHNUbUNVc3lLR2taemNsN3prejNZTGt5cGdBbnJlRm1ERXBIa0l3Vk9NZnBkaTlDRUVOMm5HcEZkd0QwM3lFcUR0T2dDYXVuN3MnICtcbidxU1RESDMySTFwUUEyUGI5c1plY0F4YzVyM0lBYjIxZDY4Nzh4c0FBQUFBQVNVVk9SSzVDWUlJPSc7XG5cbiAgaWYgKHRoaXMuaXNNb2JpbGVEZXZpY2VfKSB7XG4gICAgaW1nLndpZHRoICo9IDI7XG4gICAgaW1nLmhlaWdodCAqPSAyO1xuICB9XG5cbiAgdGhpcy5sZWZ0Wm9vbUhhbmRsZV8gPSBpbWc7XG4gIHRoaXMucmlnaHRab29tSGFuZGxlXyA9IGltZy5jbG9uZU5vZGUoZmFsc2UpO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogU2V0cyB1cCB0aGUgaW50ZXJhY3Rpb24gZm9yIHRoZSByYW5nZSBzZWxlY3Rvci5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuaW5pdEludGVyYWN0aW9uXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0b3BFbGVtID0gZG9jdW1lbnQ7XG4gIHZhciBjbGllbnRYTGFzdCA9IDA7XG4gIHZhciBoYW5kbGUgPSBudWxsO1xuICB2YXIgaXNab29taW5nID0gZmFsc2U7XG4gIHZhciBpc1Bhbm5pbmcgPSBmYWxzZTtcbiAgdmFyIGR5bmFtaWMgPSAhdGhpcy5pc01vYmlsZURldmljZV87XG5cbiAgLy8gV2UgY292ZXIgaWZyYW1lcyBkdXJpbmcgbW91c2UgaW50ZXJhY3Rpb25zLiBTZWUgY29tbWVudHMgaW5cbiAgLy8gZHlncmFwaC11dGlscy5qcyBmb3IgbW9yZSBpbmZvIG9uIHdoeSB0aGlzIGlzIGEgZ29vZCBpZGVhLlxuICB2YXIgdGFycCA9IG5ldyBJRnJhbWVUYXJwKCk7XG5cbiAgLy8gZnVuY3Rpb25zLCBkZWZpbmVkIGJlbG93LiAgRGVmaW5pbmcgdGhlbSB0aGlzIHdheSAocmF0aGVyIHRoYW4gd2l0aFxuICAvLyBcImZ1bmN0aW9uIGZvbygpIHsuLi59XCIgbWFrZXMgSlNIaW50IGhhcHB5LlxuICB2YXIgdG9YRGF0YVdpbmRvdywgb25ab29tU3RhcnQsIG9uWm9vbSwgb25ab29tRW5kLCBkb1pvb20sIGlzTW91c2VJblBhblpvbmUsXG4gICAgICBvblBhblN0YXJ0LCBvblBhbiwgb25QYW5FbmQsIGRvUGFuLCBvbkNhbnZhc0hvdmVyO1xuXG4gIC8vIFRvdWNoIGV2ZW50IGZ1bmN0aW9uc1xuICB2YXIgb25ab29tSGFuZGxlVG91Y2hFdmVudCwgb25DYW52YXNUb3VjaEV2ZW50LCBhZGRUb3VjaEV2ZW50cztcblxuICB0b1hEYXRhV2luZG93ID0gZnVuY3Rpb24oem9vbUhhbmRsZVN0YXR1cykge1xuICAgIHZhciB4RGF0YUxpbWl0cyA9IHNlbGYuZHlncmFwaF8ueEF4aXNFeHRyZW1lcygpO1xuICAgIHZhciBmYWN0ID0gKHhEYXRhTGltaXRzWzFdIC0geERhdGFMaW1pdHNbMF0pL3NlbGYuY2FudmFzUmVjdF8udztcbiAgICB2YXIgeERhdGFNaW4gPSB4RGF0YUxpbWl0c1swXSArICh6b29tSGFuZGxlU3RhdHVzLmxlZnRIYW5kbGVQb3MgLSBzZWxmLmNhbnZhc1JlY3RfLngpKmZhY3Q7XG4gICAgdmFyIHhEYXRhTWF4ID0geERhdGFMaW1pdHNbMF0gKyAoem9vbUhhbmRsZVN0YXR1cy5yaWdodEhhbmRsZVBvcyAtIHNlbGYuY2FudmFzUmVjdF8ueCkqZmFjdDtcbiAgICByZXR1cm4gW3hEYXRhTWluLCB4RGF0YU1heF07XG4gIH07XG5cbiAgb25ab29tU3RhcnQgPSBmdW5jdGlvbihlKSB7XG4gICAgdXRpbHMuY2FuY2VsRXZlbnQoZSk7XG4gICAgaXNab29taW5nID0gdHJ1ZTtcbiAgICBjbGllbnRYTGFzdCA9IGUuY2xpZW50WDtcbiAgICBoYW5kbGUgPSBlLnRhcmdldCA/IGUudGFyZ2V0IDogZS5zcmNFbGVtZW50O1xuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZWRvd24nIHx8IGUudHlwZSA9PT0gJ2RyYWdzdGFydCcpIHtcbiAgICAgIC8vIFRoZXNlIGV2ZW50cyBhcmUgcmVtb3ZlZCBtYW51YWxseS5cbiAgICAgIHV0aWxzLmFkZEV2ZW50KHRvcEVsZW0sICdtb3VzZW1vdmUnLCBvblpvb20pO1xuICAgICAgdXRpbHMuYWRkRXZlbnQodG9wRWxlbSwgJ21vdXNldXAnLCBvblpvb21FbmQpO1xuICAgIH1cbiAgICBzZWxmLmZnY2FudmFzXy5zdHlsZS5jdXJzb3IgPSAnY29sLXJlc2l6ZSc7XG4gICAgdGFycC5jb3ZlcigpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIG9uWm9vbSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoIWlzWm9vbWluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB1dGlscy5jYW5jZWxFdmVudChlKTtcblxuICAgIHZhciBkZWxYID0gZS5jbGllbnRYIC0gY2xpZW50WExhc3Q7XG4gICAgaWYgKE1hdGguYWJzKGRlbFgpIDwgNCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNsaWVudFhMYXN0ID0gZS5jbGllbnRYO1xuXG4gICAgLy8gTW92ZSBoYW5kbGUuXG4gICAgdmFyIHpvb21IYW5kbGVTdGF0dXMgPSBzZWxmLmdldFpvb21IYW5kbGVTdGF0dXNfKCk7XG4gICAgdmFyIG5ld1BvcztcbiAgICBpZiAoaGFuZGxlID09IHNlbGYubGVmdFpvb21IYW5kbGVfKSB7XG4gICAgICBuZXdQb3MgPSB6b29tSGFuZGxlU3RhdHVzLmxlZnRIYW5kbGVQb3MgKyBkZWxYO1xuICAgICAgbmV3UG9zID0gTWF0aC5taW4obmV3UG9zLCB6b29tSGFuZGxlU3RhdHVzLnJpZ2h0SGFuZGxlUG9zIC0gaGFuZGxlLndpZHRoIC0gMyk7XG4gICAgICBuZXdQb3MgPSBNYXRoLm1heChuZXdQb3MsIHNlbGYuY2FudmFzUmVjdF8ueCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1BvcyA9IHpvb21IYW5kbGVTdGF0dXMucmlnaHRIYW5kbGVQb3MgKyBkZWxYO1xuICAgICAgbmV3UG9zID0gTWF0aC5taW4obmV3UG9zLCBzZWxmLmNhbnZhc1JlY3RfLnggKyBzZWxmLmNhbnZhc1JlY3RfLncpO1xuICAgICAgbmV3UG9zID0gTWF0aC5tYXgobmV3UG9zLCB6b29tSGFuZGxlU3RhdHVzLmxlZnRIYW5kbGVQb3MgKyBoYW5kbGUud2lkdGggKyAzKTtcbiAgICB9XG4gICAgdmFyIGhhbGZIYW5kbGVXaWR0aCA9IGhhbmRsZS53aWR0aC8yO1xuICAgIGhhbmRsZS5zdHlsZS5sZWZ0ID0gKG5ld1BvcyAtIGhhbGZIYW5kbGVXaWR0aCkgKyAncHgnO1xuICAgIHNlbGYuZHJhd0ludGVyYWN0aXZlTGF5ZXJfKCk7XG5cbiAgICAvLyBab29tIG9uIHRoZSBmbHkuXG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIGRvWm9vbSgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBvblpvb21FbmQgPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFpc1pvb21pbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXNab29taW5nID0gZmFsc2U7XG4gICAgdGFycC51bmNvdmVyKCk7XG4gICAgdXRpbHMucmVtb3ZlRXZlbnQodG9wRWxlbSwgJ21vdXNlbW92ZScsIG9uWm9vbSk7XG4gICAgdXRpbHMucmVtb3ZlRXZlbnQodG9wRWxlbSwgJ21vdXNldXAnLCBvblpvb21FbmQpO1xuICAgIHNlbGYuZmdjYW52YXNfLnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcblxuICAgIC8vIElmIG9uIGEgc2xvd2VyIGRldmljZSwgem9vbSBub3cuXG4gICAgaWYgKCFkeW5hbWljKSB7XG4gICAgICBkb1pvb20oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgZG9ab29tID0gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB6b29tSGFuZGxlU3RhdHVzID0gc2VsZi5nZXRab29tSGFuZGxlU3RhdHVzXygpO1xuICAgICAgc2VsZi5pc0NoYW5naW5nUmFuZ2VfID0gdHJ1ZTtcbiAgICAgIGlmICghem9vbUhhbmRsZVN0YXR1cy5pc1pvb21lZCkge1xuICAgICAgICBzZWxmLmR5Z3JhcGhfLnJlc2V0Wm9vbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHhEYXRhV2luZG93ID0gdG9YRGF0YVdpbmRvdyh6b29tSGFuZGxlU3RhdHVzKTtcbiAgICAgICAgc2VsZi5keWdyYXBoXy5kb1pvb21YRGF0ZXNfKHhEYXRhV2luZG93WzBdLCB4RGF0YVdpbmRvd1sxXSk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNlbGYuaXNDaGFuZ2luZ1JhbmdlXyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBpc01vdXNlSW5QYW5ab25lID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciByZWN0ID0gc2VsZi5sZWZ0Wm9vbUhhbmRsZV8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIGxlZnRIYW5kbGVDbGllbnRYID0gcmVjdC5sZWZ0ICsgcmVjdC53aWR0aC8yO1xuICAgIHJlY3QgPSBzZWxmLnJpZ2h0Wm9vbUhhbmRsZV8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIHJpZ2h0SGFuZGxlQ2xpZW50WCA9IHJlY3QubGVmdCArIHJlY3Qud2lkdGgvMjtcbiAgICByZXR1cm4gKGUuY2xpZW50WCA+IGxlZnRIYW5kbGVDbGllbnRYICYmIGUuY2xpZW50WCA8IHJpZ2h0SGFuZGxlQ2xpZW50WCk7XG4gIH07XG5cbiAgb25QYW5TdGFydCA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoIWlzUGFubmluZyAmJiBpc01vdXNlSW5QYW5ab25lKGUpICYmIHNlbGYuZ2V0Wm9vbUhhbmRsZVN0YXR1c18oKS5pc1pvb21lZCkge1xuICAgICAgdXRpbHMuY2FuY2VsRXZlbnQoZSk7XG4gICAgICBpc1Bhbm5pbmcgPSB0cnVlO1xuICAgICAgY2xpZW50WExhc3QgPSBlLmNsaWVudFg7XG4gICAgICBpZiAoZS50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAvLyBUaGVzZSBldmVudHMgYXJlIHJlbW92ZWQgbWFudWFsbHkuXG4gICAgICAgIHV0aWxzLmFkZEV2ZW50KHRvcEVsZW0sICdtb3VzZW1vdmUnLCBvblBhbik7XG4gICAgICAgIHV0aWxzLmFkZEV2ZW50KHRvcEVsZW0sICdtb3VzZXVwJywgb25QYW5FbmQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBvblBhbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoIWlzUGFubmluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB1dGlscy5jYW5jZWxFdmVudChlKTtcblxuICAgIHZhciBkZWxYID0gZS5jbGllbnRYIC0gY2xpZW50WExhc3Q7XG4gICAgaWYgKE1hdGguYWJzKGRlbFgpIDwgNCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNsaWVudFhMYXN0ID0gZS5jbGllbnRYO1xuXG4gICAgLy8gTW92ZSByYW5nZSB2aWV3XG4gICAgdmFyIHpvb21IYW5kbGVTdGF0dXMgPSBzZWxmLmdldFpvb21IYW5kbGVTdGF0dXNfKCk7XG4gICAgdmFyIGxlZnRIYW5kbGVQb3MgPSB6b29tSGFuZGxlU3RhdHVzLmxlZnRIYW5kbGVQb3M7XG4gICAgdmFyIHJpZ2h0SGFuZGxlUG9zID0gem9vbUhhbmRsZVN0YXR1cy5yaWdodEhhbmRsZVBvcztcbiAgICB2YXIgcmFuZ2VTaXplID0gcmlnaHRIYW5kbGVQb3MgLSBsZWZ0SGFuZGxlUG9zO1xuICAgIGlmIChsZWZ0SGFuZGxlUG9zICsgZGVsWCA8PSBzZWxmLmNhbnZhc1JlY3RfLngpIHtcbiAgICAgIGxlZnRIYW5kbGVQb3MgPSBzZWxmLmNhbnZhc1JlY3RfLng7XG4gICAgICByaWdodEhhbmRsZVBvcyA9IGxlZnRIYW5kbGVQb3MgKyByYW5nZVNpemU7XG4gICAgfSBlbHNlIGlmIChyaWdodEhhbmRsZVBvcyArIGRlbFggPj0gc2VsZi5jYW52YXNSZWN0Xy54ICsgc2VsZi5jYW52YXNSZWN0Xy53KSB7XG4gICAgICByaWdodEhhbmRsZVBvcyA9IHNlbGYuY2FudmFzUmVjdF8ueCArIHNlbGYuY2FudmFzUmVjdF8udztcbiAgICAgIGxlZnRIYW5kbGVQb3MgPSByaWdodEhhbmRsZVBvcyAtIHJhbmdlU2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdEhhbmRsZVBvcyArPSBkZWxYO1xuICAgICAgcmlnaHRIYW5kbGVQb3MgKz0gZGVsWDtcbiAgICB9XG4gICAgdmFyIGhhbGZIYW5kbGVXaWR0aCA9IHNlbGYubGVmdFpvb21IYW5kbGVfLndpZHRoLzI7XG4gICAgc2VsZi5sZWZ0Wm9vbUhhbmRsZV8uc3R5bGUubGVmdCA9IChsZWZ0SGFuZGxlUG9zIC0gaGFsZkhhbmRsZVdpZHRoKSArICdweCc7XG4gICAgc2VsZi5yaWdodFpvb21IYW5kbGVfLnN0eWxlLmxlZnQgPSAocmlnaHRIYW5kbGVQb3MgLSBoYWxmSGFuZGxlV2lkdGgpICsgJ3B4JztcbiAgICBzZWxmLmRyYXdJbnRlcmFjdGl2ZUxheWVyXygpO1xuXG4gICAgLy8gRG8gcGFuIG9uIHRoZSBmbHkuXG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIGRvUGFuKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIG9uUGFuRW5kID0gZnVuY3Rpb24oZSkge1xuICAgIGlmICghaXNQYW5uaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlzUGFubmluZyA9IGZhbHNlO1xuICAgIHV0aWxzLnJlbW92ZUV2ZW50KHRvcEVsZW0sICdtb3VzZW1vdmUnLCBvblBhbik7XG4gICAgdXRpbHMucmVtb3ZlRXZlbnQodG9wRWxlbSwgJ21vdXNldXAnLCBvblBhbkVuZCk7XG4gICAgLy8gSWYgb24gYSBzbG93ZXIgZGV2aWNlLCBkbyBwYW4gbm93LlxuICAgIGlmICghZHluYW1pYykge1xuICAgICAgZG9QYW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgZG9QYW4gPSBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgc2VsZi5pc0NoYW5naW5nUmFuZ2VfID0gdHJ1ZTtcbiAgICAgIHNlbGYuZHlncmFwaF8uZGF0ZVdpbmRvd18gPSB0b1hEYXRhV2luZG93KHNlbGYuZ2V0Wm9vbUhhbmRsZVN0YXR1c18oKSk7XG4gICAgICBzZWxmLmR5Z3JhcGhfLmRyYXdHcmFwaF8oZmFsc2UpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZWxmLmlzQ2hhbmdpbmdSYW5nZV8gPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgb25DYW52YXNIb3ZlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoaXNab29taW5nIHx8IGlzUGFubmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY3Vyc29yID0gaXNNb3VzZUluUGFuWm9uZShlKSA/ICdtb3ZlJyA6ICdkZWZhdWx0JztcbiAgICBpZiAoY3Vyc29yICE9IHNlbGYuZmdjYW52YXNfLnN0eWxlLmN1cnNvcikge1xuICAgICAgc2VsZi5mZ2NhbnZhc18uc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuICAgIH1cbiAgfTtcblxuICBvblpvb21IYW5kbGVUb3VjaEV2ZW50ID0gZnVuY3Rpb24oZSkge1xuICAgIGlmIChlLnR5cGUgPT0gJ3RvdWNoc3RhcnQnICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgICAgaWYgKG9uWm9vbVN0YXJ0KGUudGFyZ2V0VG91Y2hlc1swXSkpIHtcbiAgICAgICAgdXRpbHMuY2FuY2VsRXZlbnQoZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlLnR5cGUgPT0gJ3RvdWNobW92ZScgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICBpZiAob25ab29tKGUudGFyZ2V0VG91Y2hlc1swXSkpIHtcbiAgICAgICAgdXRpbHMuY2FuY2VsRXZlbnQoZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uWm9vbUVuZChlKTtcbiAgICB9XG4gIH07XG5cbiAgb25DYW52YXNUb3VjaEV2ZW50ID0gZnVuY3Rpb24oZSkge1xuICAgIGlmIChlLnR5cGUgPT0gJ3RvdWNoc3RhcnQnICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgICAgaWYgKG9uUGFuU3RhcnQoZS50YXJnZXRUb3VjaGVzWzBdKSkge1xuICAgICAgICB1dGlscy5jYW5jZWxFdmVudChlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGUudHlwZSA9PSAndG91Y2htb3ZlJyAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICAgIGlmIChvblBhbihlLnRhcmdldFRvdWNoZXNbMF0pKSB7XG4gICAgICAgIHV0aWxzLmNhbmNlbEV2ZW50KGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvblBhbkVuZChlKTtcbiAgICB9XG4gIH07XG5cbiAgYWRkVG91Y2hFdmVudHMgPSBmdW5jdGlvbihlbGVtLCBmbikge1xuICAgIHZhciB0eXBlcyA9IFsndG91Y2hzdGFydCcsICd0b3VjaGVuZCcsICd0b3VjaG1vdmUnLCAndG91Y2hjYW5jZWwnXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzZWxmLmR5Z3JhcGhfLmFkZEFuZFRyYWNrRXZlbnQoZWxlbSwgdHlwZXNbaV0sIGZuKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5zZXREZWZhdWx0T3B0aW9uXygnaW50ZXJhY3Rpb25Nb2RlbCcsIER5Z3JhcGhJbnRlcmFjdGlvbi5kcmFnSXNQYW5JbnRlcmFjdGlvbk1vZGVsKTtcbiAgdGhpcy5zZXREZWZhdWx0T3B0aW9uXygncGFuRWRnZUZyYWN0aW9uJywgMC4wMDAxKTtcblxuICB2YXIgZHJhZ1N0YXJ0RXZlbnQgPSB3aW5kb3cub3BlcmEgPyAnbW91c2Vkb3duJyA6ICdkcmFnc3RhcnQnO1xuICB0aGlzLmR5Z3JhcGhfLmFkZEFuZFRyYWNrRXZlbnQodGhpcy5sZWZ0Wm9vbUhhbmRsZV8sIGRyYWdTdGFydEV2ZW50LCBvblpvb21TdGFydCk7XG4gIHRoaXMuZHlncmFwaF8uYWRkQW5kVHJhY2tFdmVudCh0aGlzLnJpZ2h0Wm9vbUhhbmRsZV8sIGRyYWdTdGFydEV2ZW50LCBvblpvb21TdGFydCk7XG5cbiAgdGhpcy5keWdyYXBoXy5hZGRBbmRUcmFja0V2ZW50KHRoaXMuZmdjYW52YXNfLCAnbW91c2Vkb3duJywgb25QYW5TdGFydCk7XG4gIHRoaXMuZHlncmFwaF8uYWRkQW5kVHJhY2tFdmVudCh0aGlzLmZnY2FudmFzXywgJ21vdXNlbW92ZScsIG9uQ2FudmFzSG92ZXIpO1xuXG4gIC8vIFRvdWNoIGV2ZW50c1xuICBpZiAodGhpcy5oYXNUb3VjaEludGVyZmFjZV8pIHtcbiAgICBhZGRUb3VjaEV2ZW50cyh0aGlzLmxlZnRab29tSGFuZGxlXywgb25ab29tSGFuZGxlVG91Y2hFdmVudCk7XG4gICAgYWRkVG91Y2hFdmVudHModGhpcy5yaWdodFpvb21IYW5kbGVfLCBvblpvb21IYW5kbGVUb3VjaEV2ZW50KTtcbiAgICBhZGRUb3VjaEV2ZW50cyh0aGlzLmZnY2FudmFzXywgb25DYW52YXNUb3VjaEV2ZW50KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogRHJhd3MgdGhlIHN0YXRpYyBsYXllciBpbiB0aGUgYmFja2dyb3VuZCBjYW52YXMuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmRyYXdTdGF0aWNMYXllcl8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGN0eCA9IHRoaXMuYmdjYW52YXNfY3R4XztcbiAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhc1JlY3RfLncsIHRoaXMuY2FudmFzUmVjdF8uaCk7XG4gIHRyeSB7XG4gICAgdGhpcy5kcmF3TWluaVBsb3RfKCk7XG4gIH0gY2F0Y2goZXgpIHtcbiAgICBjb25zb2xlLndhcm4oZXgpO1xuICB9XG5cbiAgdmFyIG1hcmdpbiA9IDAuNTtcbiAgdGhpcy5iZ2NhbnZhc19jdHhfLmxpbmVXaWR0aCA9IHRoaXMuZ2V0T3B0aW9uXygncmFuZ2VTZWxlY3RvckJhY2tncm91bmRMaW5lV2lkdGgnKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9yQmFja2dyb3VuZFN0cm9rZUNvbG9yJyk7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbyhtYXJnaW4sIG1hcmdpbik7XG4gIGN0eC5saW5lVG8obWFyZ2luLCB0aGlzLmNhbnZhc1JlY3RfLmgtbWFyZ2luKTtcbiAgY3R4LmxpbmVUbyh0aGlzLmNhbnZhc1JlY3RfLnctbWFyZ2luLCB0aGlzLmNhbnZhc1JlY3RfLmgtbWFyZ2luKTtcbiAgY3R4LmxpbmVUbyh0aGlzLmNhbnZhc1JlY3RfLnctbWFyZ2luLCBtYXJnaW4pO1xuICBjdHguc3Ryb2tlKCk7XG59O1xuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIERyYXdzIHRoZSBtaW5pIHBsb3QgaW4gdGhlIGJhY2tncm91bmQgY2FudmFzLlxuICovXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5kcmF3TWluaVBsb3RfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBmaWxsU3R5bGUgPSB0aGlzLmdldE9wdGlvbl8oJ3JhbmdlU2VsZWN0b3JQbG90RmlsbENvbG9yJyk7XG4gIHZhciBmaWxsR3JhZGllbnRTdHlsZSA9IHRoaXMuZ2V0T3B0aW9uXygncmFuZ2VTZWxlY3RvclBsb3RGaWxsR3JhZGllbnRDb2xvcicpO1xuICB2YXIgc3Ryb2tlU3R5bGUgPSB0aGlzLmdldE9wdGlvbl8oJ3JhbmdlU2VsZWN0b3JQbG90U3Ryb2tlQ29sb3InKTtcbiAgaWYgKCFmaWxsU3R5bGUgJiYgIXN0cm9rZVN0eWxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHN0ZXBQbG90ID0gdGhpcy5nZXRPcHRpb25fKCdzdGVwUGxvdCcpO1xuXG4gIHZhciBjb21iaW5lZFNlcmllc0RhdGEgPSB0aGlzLmNvbXB1dGVDb21iaW5lZFNlcmllc0FuZExpbWl0c18oKTtcbiAgdmFyIHlSYW5nZSA9IGNvbWJpbmVkU2VyaWVzRGF0YS55TWF4IC0gY29tYmluZWRTZXJpZXNEYXRhLnlNaW47XG5cbiAgLy8gRHJhdyB0aGUgbWluaSBwbG90LlxuICB2YXIgY3R4ID0gdGhpcy5iZ2NhbnZhc19jdHhfO1xuICB2YXIgbWFyZ2luID0gMC41O1xuXG4gIHZhciB4RXh0cmVtZXMgPSB0aGlzLmR5Z3JhcGhfLnhBeGlzRXh0cmVtZXMoKTtcbiAgdmFyIHhSYW5nZSA9IE1hdGgubWF4KHhFeHRyZW1lc1sxXSAtIHhFeHRyZW1lc1swXSwgMS5lLTMwKTtcbiAgdmFyIHhGYWN0ID0gKHRoaXMuY2FudmFzUmVjdF8udyAtIG1hcmdpbikveFJhbmdlO1xuICB2YXIgeUZhY3QgPSAodGhpcy5jYW52YXNSZWN0Xy5oIC0gbWFyZ2luKS95UmFuZ2U7XG4gIHZhciBjYW52YXNXaWR0aCA9IHRoaXMuY2FudmFzUmVjdF8udyAtIG1hcmdpbjtcbiAgdmFyIGNhbnZhc0hlaWdodCA9IHRoaXMuY2FudmFzUmVjdF8uaCAtIG1hcmdpbjtcblxuICB2YXIgcHJldlggPSBudWxsLCBwcmV2WSA9IG51bGw7XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgubW92ZVRvKG1hcmdpbiwgY2FudmFzSGVpZ2h0KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21iaW5lZFNlcmllc0RhdGEuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkYXRhUG9pbnQgPSBjb21iaW5lZFNlcmllc0RhdGEuZGF0YVtpXTtcbiAgICB2YXIgeCA9ICgoZGF0YVBvaW50WzBdICE9PSBudWxsKSA/ICgoZGF0YVBvaW50WzBdIC0geEV4dHJlbWVzWzBdKSp4RmFjdCkgOiBOYU4pO1xuICAgIHZhciB5ID0gKChkYXRhUG9pbnRbMV0gIT09IG51bGwpID8gKGNhbnZhc0hlaWdodCAtIChkYXRhUG9pbnRbMV0gLSBjb21iaW5lZFNlcmllc0RhdGEueU1pbikqeUZhY3QpIDogTmFOKTtcblxuICAgIC8vIFNraXAgcG9pbnRzIHRoYXQgZG9uJ3QgY2hhbmdlIHRoZSB4LXZhbHVlLiBPdmVybHkgZmluZS1ncmFpbmVkIHBvaW50c1xuICAgIC8vIGNhbiBjYXVzZSBtYWpvciBzbG93ZG93bnMgd2l0aCB0aGUgY3R4LmZpbGwoKSBjYWxsIGJlbG93LlxuICAgIGlmICghc3RlcFBsb3QgJiYgcHJldlggIT09IG51bGwgJiYgTWF0aC5yb3VuZCh4KSA9PSBNYXRoLnJvdW5kKHByZXZYKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGlzRmluaXRlKHgpICYmIGlzRmluaXRlKHkpKSB7XG4gICAgICBpZihwcmV2WCA9PT0gbnVsbCkge1xuICAgICAgICBjdHgubGluZVRvKHgsIGNhbnZhc0hlaWdodCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzdGVwUGxvdCkge1xuICAgICAgICBjdHgubGluZVRvKHgsIHByZXZZKTtcbiAgICAgIH1cbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICBwcmV2WCA9IHg7XG4gICAgICBwcmV2WSA9IHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYocHJldlggIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHN0ZXBQbG90KSB7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4LCBwcmV2WSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4LCBjYW52YXNIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGN0eC5saW5lVG8ocHJldlgsIGNhbnZhc0hlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByZXZYID0gcHJldlkgPSBudWxsO1xuICAgIH1cbiAgfVxuICBjdHgubGluZVRvKGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgaWYgKGZpbGxTdHlsZSkge1xuICAgIHZhciBsaW5ncmFkID0gdGhpcy5iZ2NhbnZhc19jdHhfLmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIDAsIGNhbnZhc0hlaWdodCk7XG4gICAgaWYgKGZpbGxHcmFkaWVudFN0eWxlKSB7XG4gICAgICBsaW5ncmFkLmFkZENvbG9yU3RvcCgwLCBmaWxsR3JhZGllbnRTdHlsZSk7XG4gICAgfVxuICAgIGxpbmdyYWQuYWRkQ29sb3JTdG9wKDEsIGZpbGxTdHlsZSk7XG4gICAgdGhpcy5iZ2NhbnZhc19jdHhfLmZpbGxTdHlsZSA9IGxpbmdyYWQ7XG4gICAgY3R4LmZpbGwoKTtcbiAgfVxuXG4gIGlmIChzdHJva2VTdHlsZSkge1xuICAgIHRoaXMuYmdjYW52YXNfY3R4Xy5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgIHRoaXMuYmdjYW52YXNfY3R4Xy5saW5lV2lkdGggPSB0aGlzLmdldE9wdGlvbl8oJ3JhbmdlU2VsZWN0b3JQbG90TGluZVdpZHRoJyk7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgY29tYmluZWQgc2VyaWVzIGRhdGEgYWxvbmcgd2l0aCBtaW4vbWF4IGZvciB0aGUgbWluaSBwbG90LlxuICogVGhlIGNvbWJpbmVkIHNlcmllcyBjb25zaXN0cyBvZiBhdmVyYWdlZCB2YWx1ZXMgZm9yIGFsbCBzZXJpZXMuXG4gKiBXaGVuIHNlcmllcyBoYXZlIGVycm9yIGJhcnMsIHRoZSBlcnJvciBiYXJzIGFyZSBpZ25vcmVkLlxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBjb21iaW5lZCBzZXJpZXMgYXJyYXksIHltaW4sIHltYXguXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmNvbXB1dGVDb21iaW5lZFNlcmllc0FuZExpbWl0c18gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGcgPSB0aGlzLmR5Z3JhcGhfO1xuICB2YXIgbG9nc2NhbGUgPSB0aGlzLmdldE9wdGlvbl8oJ2xvZ3NjYWxlJyk7XG4gIHZhciBpO1xuXG4gIC8vIFNlbGVjdCBzZXJpZXMgdG8gY29tYmluZS4gQnkgZGVmYXVsdCwgYWxsIHNlcmllcyBhcmUgY29tYmluZWQuXG4gIHZhciBudW1Db2x1bW5zID0gZy5udW1Db2x1bW5zKCk7XG4gIHZhciBsYWJlbHMgPSBnLmdldExhYmVscygpO1xuICB2YXIgaW5jbHVkZVNlcmllcyA9IG5ldyBBcnJheShudW1Db2x1bW5zKTtcbiAgdmFyIGFueVNldCA9IGZhbHNlO1xuICB2YXIgdmlzaWJpbGl0eSA9IGcudmlzaWJpbGl0eSgpO1xuICB2YXIgaW5jbHVzaW9uID0gW107XG5cbiAgZm9yIChpID0gMTsgaSA8IG51bUNvbHVtbnM7IGkrKykge1xuICAgIHZhciBpbmNsdWRlID0gdGhpcy5nZXRPcHRpb25fKCdzaG93SW5SYW5nZVNlbGVjdG9yJywgbGFiZWxzW2ldKTtcbiAgICBpbmNsdXNpb24ucHVzaChpbmNsdWRlKTtcbiAgICBpZiAoaW5jbHVkZSAhPT0gbnVsbCkgYW55U2V0ID0gdHJ1ZTsgIC8vIGl0J3Mgc2V0IGV4cGxpY2l0bHkgZm9yIHRoaXMgc2VyaWVzXG4gIH1cblxuICBpZiAoYW55U2V0KSB7XG4gICAgZm9yIChpID0gMTsgaSA8IG51bUNvbHVtbnM7IGkrKykge1xuICAgICAgaW5jbHVkZVNlcmllc1tpXSA9IGluY2x1c2lvbltpIC0gMV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoaSA9IDE7IGkgPCBudW1Db2x1bW5zOyBpKyspIHtcbiAgICAgIGluY2x1ZGVTZXJpZXNbaV0gPSB2aXNpYmlsaXR5W2kgLSAxXTtcbiAgICB9XG4gIH1cblxuICAvLyBDcmVhdGUgYSBjb21iaW5lZCBzZXJpZXMgKGF2ZXJhZ2Ugb2Ygc2VsZWN0ZWQgc2VyaWVzIHZhbHVlcykuXG4gIC8vIFRPRE8oZGFudmspOiBzaG9ydC1jaXJjdWl0IGlmIHRoZXJlJ3Mgb25seSBvbmUgc2VyaWVzLlxuICB2YXIgcm9sbGVkU2VyaWVzID0gW107XG4gIHZhciBkYXRhSGFuZGxlciA9IGcuZGF0YUhhbmRsZXJfO1xuICB2YXIgb3B0aW9ucyA9IGcuYXR0cmlidXRlc187XG4gIGZvciAoaSA9IDE7IGkgPCBnLm51bUNvbHVtbnMoKTsgaSsrKSB7XG4gICAgaWYgKCFpbmNsdWRlU2VyaWVzW2ldKSBjb250aW51ZTtcbiAgICB2YXIgc2VyaWVzID0gZGF0YUhhbmRsZXIuZXh0cmFjdFNlcmllcyhnLnJhd0RhdGFfLCBpLCBvcHRpb25zKTtcbiAgICBpZiAoZy5yb2xsUGVyaW9kKCkgPiAxKSB7XG4gICAgICBzZXJpZXMgPSBkYXRhSGFuZGxlci5yb2xsaW5nQXZlcmFnZShzZXJpZXMsIGcucm9sbFBlcmlvZCgpLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByb2xsZWRTZXJpZXMucHVzaChzZXJpZXMpO1xuICB9XG5cbiAgdmFyIGNvbWJpbmVkU2VyaWVzID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCByb2xsZWRTZXJpZXNbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcm9sbGVkU2VyaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgeSA9IHJvbGxlZFNlcmllc1tqXVtpXVsxXTtcbiAgICAgIGlmICh5ID09PSBudWxsIHx8IGlzTmFOKHkpKSBjb250aW51ZTtcbiAgICAgIGNvdW50Kys7XG4gICAgICBzdW0gKz0geTtcbiAgICB9XG4gICAgY29tYmluZWRTZXJpZXMucHVzaChbcm9sbGVkU2VyaWVzWzBdW2ldWzBdLCBzdW0gLyBjb3VudF0pO1xuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgeSByYW5nZS5cbiAgdmFyIHlNaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICB2YXIgeU1heCA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICBmb3IgKGkgPSAwOyBpIDwgY29tYmluZWRTZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgeVZhbCA9IGNvbWJpbmVkU2VyaWVzW2ldWzFdO1xuICAgIGlmICh5VmFsICE9PSBudWxsICYmIGlzRmluaXRlKHlWYWwpICYmICghbG9nc2NhbGUgfHwgeVZhbCA+IDApKSB7XG4gICAgICB5TWluID0gTWF0aC5taW4oeU1pbiwgeVZhbCk7XG4gICAgICB5TWF4ID0gTWF0aC5tYXgoeU1heCwgeVZhbCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29udmVydCBZIGRhdGEgdG8gbG9nIHNjYWxlIGlmIG5lZWRlZC5cbiAgLy8gQWxzbywgZXhwYW5kIHRoZSBZIHJhbmdlIHRvIGNvbXByZXNzIHRoZSBtaW5pIHBsb3QgYSBsaXR0bGUuXG4gIHZhciBleHRyYVBlcmNlbnQgPSAwLjI1O1xuICBpZiAobG9nc2NhbGUpIHtcbiAgICB5TWF4ID0gdXRpbHMubG9nMTAoeU1heCk7XG4gICAgeU1heCArPSB5TWF4KmV4dHJhUGVyY2VudDtcbiAgICB5TWluID0gdXRpbHMubG9nMTAoeU1pbik7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvbWJpbmVkU2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb21iaW5lZFNlcmllc1tpXVsxXSA9IHV0aWxzLmxvZzEwKGNvbWJpbmVkU2VyaWVzW2ldWzFdKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHlFeHRyYTtcbiAgICB2YXIgeVJhbmdlID0geU1heCAtIHlNaW47XG4gICAgaWYgKHlSYW5nZSA8PSBOdW1iZXIuTUlOX1ZBTFVFKSB7XG4gICAgICB5RXh0cmEgPSB5TWF4KmV4dHJhUGVyY2VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgeUV4dHJhID0geVJhbmdlKmV4dHJhUGVyY2VudDtcbiAgICB9XG4gICAgeU1heCArPSB5RXh0cmE7XG4gICAgeU1pbiAtPSB5RXh0cmE7XG4gIH1cblxuICByZXR1cm4ge2RhdGE6IGNvbWJpbmVkU2VyaWVzLCB5TWluOiB5TWluLCB5TWF4OiB5TWF4fTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFBsYWNlcyB0aGUgem9vbSBoYW5kbGVzIGluIHRoZSBwcm9wZXIgcG9zaXRpb24gYmFzZWQgb24gdGhlIGN1cnJlbnQgWCBkYXRhIHdpbmRvdy5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUucGxhY2Vab29tSGFuZGxlc18gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHhFeHRyZW1lcyA9IHRoaXMuZHlncmFwaF8ueEF4aXNFeHRyZW1lcygpO1xuICB2YXIgeFdpbmRvd0xpbWl0cyA9IHRoaXMuZHlncmFwaF8ueEF4aXNSYW5nZSgpO1xuICB2YXIgeFJhbmdlID0geEV4dHJlbWVzWzFdIC0geEV4dHJlbWVzWzBdO1xuICB2YXIgbGVmdFBlcmNlbnQgPSBNYXRoLm1heCgwLCAoeFdpbmRvd0xpbWl0c1swXSAtIHhFeHRyZW1lc1swXSkveFJhbmdlKTtcbiAgdmFyIHJpZ2h0UGVyY2VudCA9IE1hdGgubWF4KDAsICh4RXh0cmVtZXNbMV0gLSB4V2luZG93TGltaXRzWzFdKS94UmFuZ2UpO1xuICB2YXIgbGVmdENvb3JkID0gdGhpcy5jYW52YXNSZWN0Xy54ICsgdGhpcy5jYW52YXNSZWN0Xy53KmxlZnRQZXJjZW50O1xuICB2YXIgcmlnaHRDb29yZCA9IHRoaXMuY2FudmFzUmVjdF8ueCArIHRoaXMuY2FudmFzUmVjdF8udyooMSAtIHJpZ2h0UGVyY2VudCk7XG4gIHZhciBoYW5kbGVUb3AgPSBNYXRoLm1heCh0aGlzLmNhbnZhc1JlY3RfLnksIHRoaXMuY2FudmFzUmVjdF8ueSArICh0aGlzLmNhbnZhc1JlY3RfLmggLSB0aGlzLmxlZnRab29tSGFuZGxlXy5oZWlnaHQpLzIpO1xuICB2YXIgaGFsZkhhbmRsZVdpZHRoID0gdGhpcy5sZWZ0Wm9vbUhhbmRsZV8ud2lkdGgvMjtcbiAgdGhpcy5sZWZ0Wm9vbUhhbmRsZV8uc3R5bGUubGVmdCA9IChsZWZ0Q29vcmQgLSBoYWxmSGFuZGxlV2lkdGgpICsgJ3B4JztcbiAgdGhpcy5sZWZ0Wm9vbUhhbmRsZV8uc3R5bGUudG9wID0gaGFuZGxlVG9wICsgJ3B4JztcbiAgdGhpcy5yaWdodFpvb21IYW5kbGVfLnN0eWxlLmxlZnQgPSAocmlnaHRDb29yZCAtIGhhbGZIYW5kbGVXaWR0aCkgKyAncHgnO1xuICB0aGlzLnJpZ2h0Wm9vbUhhbmRsZV8uc3R5bGUudG9wID0gdGhpcy5sZWZ0Wm9vbUhhbmRsZV8uc3R5bGUudG9wO1xuXG4gIHRoaXMubGVmdFpvb21IYW5kbGVfLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gIHRoaXMucmlnaHRab29tSGFuZGxlXy5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogRHJhd3MgdGhlIGludGVyYWN0aXZlIGxheWVyIGluIHRoZSBmb3JlZ3JvdW5kIGNhbnZhcy5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuZHJhd0ludGVyYWN0aXZlTGF5ZXJfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjdHggPSB0aGlzLmZnY2FudmFzX2N0eF87XG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXNSZWN0Xy53LCB0aGlzLmNhbnZhc1JlY3RfLmgpO1xuICB2YXIgbWFyZ2luID0gMTtcbiAgdmFyIHdpZHRoID0gdGhpcy5jYW52YXNSZWN0Xy53IC0gbWFyZ2luO1xuICB2YXIgaGVpZ2h0ID0gdGhpcy5jYW52YXNSZWN0Xy5oIC0gbWFyZ2luO1xuICB2YXIgem9vbUhhbmRsZVN0YXR1cyA9IHRoaXMuZ2V0Wm9vbUhhbmRsZVN0YXR1c18oKTtcblxuICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmdldE9wdGlvbl8oJ3JhbmdlU2VsZWN0b3JGb3JlZ3JvdW5kU3Ryb2tlQ29sb3InKTtcbiAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuZ2V0T3B0aW9uXygncmFuZ2VTZWxlY3RvckZvcmVncm91bmRMaW5lV2lkdGgnKTtcbiAgaWYgKCF6b29tSGFuZGxlU3RhdHVzLmlzWm9vbWVkKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8obWFyZ2luLCBtYXJnaW4pO1xuICAgIGN0eC5saW5lVG8obWFyZ2luLCBoZWlnaHQpO1xuICAgIGN0eC5saW5lVG8od2lkdGgsIGhlaWdodCk7XG4gICAgY3R4LmxpbmVUbyh3aWR0aCwgbWFyZ2luKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlZnRIYW5kbGVDYW52YXNQb3MgPSBNYXRoLm1heChtYXJnaW4sIHpvb21IYW5kbGVTdGF0dXMubGVmdEhhbmRsZVBvcyAtIHRoaXMuY2FudmFzUmVjdF8ueCk7XG4gICAgdmFyIHJpZ2h0SGFuZGxlQ2FudmFzUG9zID0gTWF0aC5taW4od2lkdGgsIHpvb21IYW5kbGVTdGF0dXMucmlnaHRIYW5kbGVQb3MgLSB0aGlzLmNhbnZhc1JlY3RfLngpO1xuXG4gICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDI0MCwgMjQwLCAyNDAsICcgKyB0aGlzLmdldE9wdGlvbl8oJ3JhbmdlU2VsZWN0b3JBbHBoYScpLnRvU3RyaW5nKCkgKyAnKSc7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGxlZnRIYW5kbGVDYW52YXNQb3MsIHRoaXMuY2FudmFzUmVjdF8uaCk7XG4gICAgY3R4LmZpbGxSZWN0KHJpZ2h0SGFuZGxlQ2FudmFzUG9zLCAwLCB0aGlzLmNhbnZhc1JlY3RfLncgLSByaWdodEhhbmRsZUNhbnZhc1BvcywgdGhpcy5jYW52YXNSZWN0Xy5oKTtcblxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKG1hcmdpbiwgbWFyZ2luKTtcbiAgICBjdHgubGluZVRvKGxlZnRIYW5kbGVDYW52YXNQb3MsIG1hcmdpbik7XG4gICAgY3R4LmxpbmVUbyhsZWZ0SGFuZGxlQ2FudmFzUG9zLCBoZWlnaHQpO1xuICAgIGN0eC5saW5lVG8ocmlnaHRIYW5kbGVDYW52YXNQb3MsIGhlaWdodCk7XG4gICAgY3R4LmxpbmVUbyhyaWdodEhhbmRsZUNhbnZhc1BvcywgbWFyZ2luKTtcbiAgICBjdHgubGluZVRvKHdpZHRoLCBtYXJnaW4pO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUmV0dXJucyB0aGUgY3VycmVudCB6b29tIGhhbmRsZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHpvb20gaGFuZGxlIHN0YXR1cy5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuZ2V0Wm9vbUhhbmRsZVN0YXR1c18gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhhbGZIYW5kbGVXaWR0aCA9IHRoaXMubGVmdFpvb21IYW5kbGVfLndpZHRoLzI7XG4gIHZhciBsZWZ0SGFuZGxlUG9zID0gcGFyc2VGbG9hdCh0aGlzLmxlZnRab29tSGFuZGxlXy5zdHlsZS5sZWZ0KSArIGhhbGZIYW5kbGVXaWR0aDtcbiAgdmFyIHJpZ2h0SGFuZGxlUG9zID0gcGFyc2VGbG9hdCh0aGlzLnJpZ2h0Wm9vbUhhbmRsZV8uc3R5bGUubGVmdCkgKyBoYWxmSGFuZGxlV2lkdGg7XG4gIHJldHVybiB7XG4gICAgICBsZWZ0SGFuZGxlUG9zOiBsZWZ0SGFuZGxlUG9zLFxuICAgICAgcmlnaHRIYW5kbGVQb3M6IHJpZ2h0SGFuZGxlUG9zLFxuICAgICAgaXNab29tZWQ6IChsZWZ0SGFuZGxlUG9zIC0gMSA+IHRoaXMuY2FudmFzUmVjdF8ueCB8fCByaWdodEhhbmRsZVBvcyArIDEgPCB0aGlzLmNhbnZhc1JlY3RfLngrdGhpcy5jYW52YXNSZWN0Xy53KVxuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgcmFuZ2VTZWxlY3RvcjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///nGoW\n");

/***/ }),

/***/ "qYh3":
/*!**********************************************************!*\
  !*** ./node_modules/dygraphs/src/plugins/annotations.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/*global Dygraph:false */\n\n\n\n/**\nCurrent bits of jankiness:\n- Uses dygraph.layout_ to get the parsed annotations.\n- Uses dygraph.plotter_.area\n\nIt would be nice if the plugin didn't require so much special support inside\nthe core dygraphs classes, but annotations involve quite a bit of parsing and\nlayout.\n\nTODO(danvk): cache DOM elements.\n*/\n\nvar annotations = function() {\n  this.annotations_ = [];\n};\n\nannotations.prototype.toString = function() {\n  return \"Annotations Plugin\";\n};\n\nannotations.prototype.activate = function(g) {\n  return {\n    clearChart: this.clearChart,\n    didDrawChart: this.didDrawChart\n  };\n};\n\nannotations.prototype.detachLabels = function() {\n  for (var i = 0; i < this.annotations_.length; i++) {\n    var a = this.annotations_[i];\n    if (a.parentNode) a.parentNode.removeChild(a);\n    this.annotations_[i] = null;\n  }\n  this.annotations_ = [];\n};\n\nannotations.prototype.clearChart = function(e) {\n  this.detachLabels();\n};\n\nannotations.prototype.didDrawChart = function(e) {\n  var g = e.dygraph;\n\n  // Early out in the (common) case of zero annotations.\n  var points = g.layout_.annotated_points;\n  if (!points || points.length === 0) return;\n\n  var containerDiv = e.canvas.parentNode;\n\n  var bindEvt = function(eventName, classEventName, pt) {\n    return function(annotation_event) {\n      var a = pt.annotation;\n      if (a.hasOwnProperty(eventName)) {\n        a[eventName](a, pt, g, annotation_event);\n      } else if (g.getOption(classEventName)) {\n        g.getOption(classEventName)(a, pt, g, annotation_event );\n      }\n    };\n  };\n\n  // Add the annotations one-by-one.\n  var area = e.dygraph.getArea();\n\n  // x-coord to sum of previous annotation's heights (used for stacking).\n  var xToUsedHeight = {};\n\n  for (var i = 0; i < points.length; i++) {\n    var p = points[i];\n    if (p.canvasx < area.x || p.canvasx > area.x + area.w ||\n        p.canvasy < area.y || p.canvasy > area.y + area.h) {\n      continue;\n    }\n\n    var a = p.annotation;\n    var tick_height = 6;\n    if (a.hasOwnProperty(\"tickHeight\")) {\n      tick_height = a.tickHeight;\n    }\n\n    // TODO: deprecate axisLabelFontSize in favor of CSS\n    var div = document.createElement(\"div\");\n    div.style['fontSize'] = g.getOption('axisLabelFontSize') + \"px\";\n    var className = 'dygraph-annotation';\n    if (!a.hasOwnProperty('icon')) {\n      // camelCase class names are deprecated.\n      className += ' dygraphDefaultAnnotation dygraph-default-annotation';\n    }\n    if (a.hasOwnProperty('cssClass')) {\n      className += \" \" + a.cssClass;\n    }\n    div.className = className;\n\n    var width = a.hasOwnProperty('width') ? a.width : 16;\n    var height = a.hasOwnProperty('height') ? a.height : 16;\n    if (a.hasOwnProperty('icon')) {\n      var img = document.createElement(\"img\");\n      img.src = a.icon;\n      img.width = width;\n      img.height = height;\n      div.appendChild(img);\n    } else if (p.annotation.hasOwnProperty('shortText')) {\n      div.appendChild(document.createTextNode(p.annotation.shortText));\n    }\n    var left = p.canvasx - width / 2;\n    div.style.left = left + \"px\";\n    var divTop = 0;\n    if (a.attachAtBottom) {\n      var y = (area.y + area.h - height - tick_height);\n      if (xToUsedHeight[left]) {\n        y -= xToUsedHeight[left];\n      } else {\n        xToUsedHeight[left] = 0;\n      }\n      xToUsedHeight[left] += (tick_height + height);\n      divTop = y;\n    } else {\n      divTop = p.canvasy - height - tick_height;\n    }\n    div.style.top = divTop + \"px\";\n    div.style.width = width + \"px\";\n    div.style.height = height + \"px\";\n    div.title = p.annotation.text;\n    div.style.color = g.colorsMap_[p.name];\n    div.style.borderColor = g.colorsMap_[p.name];\n    a.div = div;\n\n    g.addAndTrackEvent(div, 'click',\n        bindEvt('clickHandler', 'annotationClickHandler', p, this));\n    g.addAndTrackEvent(div, 'mouseover',\n        bindEvt('mouseOverHandler', 'annotationMouseOverHandler', p, this));\n    g.addAndTrackEvent(div, 'mouseout',\n        bindEvt('mouseOutHandler', 'annotationMouseOutHandler', p, this));\n    g.addAndTrackEvent(div, 'dblclick',\n        bindEvt('dblClickHandler', 'annotationDblClickHandler', p, this));\n\n    containerDiv.appendChild(div);\n    this.annotations_.push(div);\n\n    var ctx = e.drawingContext;\n    ctx.save();\n    ctx.strokeStyle = a.hasOwnProperty('tickColor') ? a.tickColor : g.colorsMap_[p.name];\n    ctx.lineWidth = a.hasOwnProperty('tickWidth') ? a.tickWidth : g.getOption('strokeWidth');\n    ctx.beginPath();\n    if (!a.attachAtBottom) {\n      ctx.moveTo(p.canvasx, p.canvasy);\n      ctx.lineTo(p.canvasx, p.canvasy - 2 - tick_height);\n    } else {\n      var y = divTop + height;\n      ctx.moveTo(p.canvasx, y);\n      ctx.lineTo(p.canvasx, y + tick_height);\n    }\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n  }\n};\n\nannotations.prototype.destroy = function() {\n  this.detachLabels();\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (annotations);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicVloMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9keWdyYXBocy9zcmMvcGx1Z2lucy9hbm5vdGF0aW9ucy5qcz9hOTg4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDEyIERhbiBWYW5kZXJrYW0gKGRhbnZka0BnbWFpbC5jb20pXG4gKiBNSVQtbGljZW5zZWQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gKi9cblxuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG5DdXJyZW50IGJpdHMgb2YgamFua2luZXNzOlxuLSBVc2VzIGR5Z3JhcGgubGF5b3V0XyB0byBnZXQgdGhlIHBhcnNlZCBhbm5vdGF0aW9ucy5cbi0gVXNlcyBkeWdyYXBoLnBsb3R0ZXJfLmFyZWFcblxuSXQgd291bGQgYmUgbmljZSBpZiB0aGUgcGx1Z2luIGRpZG4ndCByZXF1aXJlIHNvIG11Y2ggc3BlY2lhbCBzdXBwb3J0IGluc2lkZVxudGhlIGNvcmUgZHlncmFwaHMgY2xhc3NlcywgYnV0IGFubm90YXRpb25zIGludm9sdmUgcXVpdGUgYSBiaXQgb2YgcGFyc2luZyBhbmRcbmxheW91dC5cblxuVE9ETyhkYW52ayk6IGNhY2hlIERPTSBlbGVtZW50cy5cbiovXG5cbnZhciBhbm5vdGF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmFubm90YXRpb25zXyA9IFtdO1xufTtcblxuYW5ub3RhdGlvbnMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBcIkFubm90YXRpb25zIFBsdWdpblwiO1xufTtcblxuYW5ub3RhdGlvbnMucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oZykge1xuICByZXR1cm4ge1xuICAgIGNsZWFyQ2hhcnQ6IHRoaXMuY2xlYXJDaGFydCxcbiAgICBkaWREcmF3Q2hhcnQ6IHRoaXMuZGlkRHJhd0NoYXJ0XG4gIH07XG59O1xuXG5hbm5vdGF0aW9ucy5wcm90b3R5cGUuZGV0YWNoTGFiZWxzID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hbm5vdGF0aW9uc18ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYSA9IHRoaXMuYW5ub3RhdGlvbnNfW2ldO1xuICAgIGlmIChhLnBhcmVudE5vZGUpIGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKTtcbiAgICB0aGlzLmFubm90YXRpb25zX1tpXSA9IG51bGw7XG4gIH1cbiAgdGhpcy5hbm5vdGF0aW9uc18gPSBbXTtcbn07XG5cbmFubm90YXRpb25zLnByb3RvdHlwZS5jbGVhckNoYXJ0ID0gZnVuY3Rpb24oZSkge1xuICB0aGlzLmRldGFjaExhYmVscygpO1xufTtcblxuYW5ub3RhdGlvbnMucHJvdG90eXBlLmRpZERyYXdDaGFydCA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIGcgPSBlLmR5Z3JhcGg7XG5cbiAgLy8gRWFybHkgb3V0IGluIHRoZSAoY29tbW9uKSBjYXNlIG9mIHplcm8gYW5ub3RhdGlvbnMuXG4gIHZhciBwb2ludHMgPSBnLmxheW91dF8uYW5ub3RhdGVkX3BvaW50cztcbiAgaWYgKCFwb2ludHMgfHwgcG9pbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gIHZhciBjb250YWluZXJEaXYgPSBlLmNhbnZhcy5wYXJlbnROb2RlO1xuXG4gIHZhciBiaW5kRXZ0ID0gZnVuY3Rpb24oZXZlbnROYW1lLCBjbGFzc0V2ZW50TmFtZSwgcHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYW5ub3RhdGlvbl9ldmVudCkge1xuICAgICAgdmFyIGEgPSBwdC5hbm5vdGF0aW9uO1xuICAgICAgaWYgKGEuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICBhW2V2ZW50TmFtZV0oYSwgcHQsIGcsIGFubm90YXRpb25fZXZlbnQpO1xuICAgICAgfSBlbHNlIGlmIChnLmdldE9wdGlvbihjbGFzc0V2ZW50TmFtZSkpIHtcbiAgICAgICAgZy5nZXRPcHRpb24oY2xhc3NFdmVudE5hbWUpKGEsIHB0LCBnLCBhbm5vdGF0aW9uX2V2ZW50ICk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBBZGQgdGhlIGFubm90YXRpb25zIG9uZS1ieS1vbmUuXG4gIHZhciBhcmVhID0gZS5keWdyYXBoLmdldEFyZWEoKTtcblxuICAvLyB4LWNvb3JkIHRvIHN1bSBvZiBwcmV2aW91cyBhbm5vdGF0aW9uJ3MgaGVpZ2h0cyAodXNlZCBmb3Igc3RhY2tpbmcpLlxuICB2YXIgeFRvVXNlZEhlaWdodCA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBwb2ludHNbaV07XG4gICAgaWYgKHAuY2FudmFzeCA8IGFyZWEueCB8fCBwLmNhbnZhc3ggPiBhcmVhLnggKyBhcmVhLncgfHxcbiAgICAgICAgcC5jYW52YXN5IDwgYXJlYS55IHx8IHAuY2FudmFzeSA+IGFyZWEueSArIGFyZWEuaCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGEgPSBwLmFubm90YXRpb247XG4gICAgdmFyIHRpY2tfaGVpZ2h0ID0gNjtcbiAgICBpZiAoYS5oYXNPd25Qcm9wZXJ0eShcInRpY2tIZWlnaHRcIikpIHtcbiAgICAgIHRpY2tfaGVpZ2h0ID0gYS50aWNrSGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIFRPRE86IGRlcHJlY2F0ZSBheGlzTGFiZWxGb250U2l6ZSBpbiBmYXZvciBvZiBDU1NcbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuc3R5bGVbJ2ZvbnRTaXplJ10gPSBnLmdldE9wdGlvbignYXhpc0xhYmVsRm9udFNpemUnKSArIFwicHhcIjtcbiAgICB2YXIgY2xhc3NOYW1lID0gJ2R5Z3JhcGgtYW5ub3RhdGlvbic7XG4gICAgaWYgKCFhLmhhc093blByb3BlcnR5KCdpY29uJykpIHtcbiAgICAgIC8vIGNhbWVsQ2FzZSBjbGFzcyBuYW1lcyBhcmUgZGVwcmVjYXRlZC5cbiAgICAgIGNsYXNzTmFtZSArPSAnIGR5Z3JhcGhEZWZhdWx0QW5ub3RhdGlvbiBkeWdyYXBoLWRlZmF1bHQtYW5ub3RhdGlvbic7XG4gICAgfVxuICAgIGlmIChhLmhhc093blByb3BlcnR5KCdjc3NDbGFzcycpKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgXCIgKyBhLmNzc0NsYXNzO1xuICAgIH1cbiAgICBkaXYuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuXG4gICAgdmFyIHdpZHRoID0gYS5oYXNPd25Qcm9wZXJ0eSgnd2lkdGgnKSA/IGEud2lkdGggOiAxNjtcbiAgICB2YXIgaGVpZ2h0ID0gYS5oYXNPd25Qcm9wZXJ0eSgnaGVpZ2h0JykgPyBhLmhlaWdodCA6IDE2O1xuICAgIGlmIChhLmhhc093blByb3BlcnR5KCdpY29uJykpIHtcbiAgICAgIHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgaW1nLnNyYyA9IGEuaWNvbjtcbiAgICAgIGltZy53aWR0aCA9IHdpZHRoO1xuICAgICAgaW1nLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIGRpdi5hcHBlbmRDaGlsZChpbWcpO1xuICAgIH0gZWxzZSBpZiAocC5hbm5vdGF0aW9uLmhhc093blByb3BlcnR5KCdzaG9ydFRleHQnKSkge1xuICAgICAgZGl2LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHAuYW5ub3RhdGlvbi5zaG9ydFRleHQpKTtcbiAgICB9XG4gICAgdmFyIGxlZnQgPSBwLmNhbnZhc3ggLSB3aWR0aCAvIDI7XG4gICAgZGl2LnN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuICAgIHZhciBkaXZUb3AgPSAwO1xuICAgIGlmIChhLmF0dGFjaEF0Qm90dG9tKSB7XG4gICAgICB2YXIgeSA9IChhcmVhLnkgKyBhcmVhLmggLSBoZWlnaHQgLSB0aWNrX2hlaWdodCk7XG4gICAgICBpZiAoeFRvVXNlZEhlaWdodFtsZWZ0XSkge1xuICAgICAgICB5IC09IHhUb1VzZWRIZWlnaHRbbGVmdF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4VG9Vc2VkSGVpZ2h0W2xlZnRdID0gMDtcbiAgICAgIH1cbiAgICAgIHhUb1VzZWRIZWlnaHRbbGVmdF0gKz0gKHRpY2tfaGVpZ2h0ICsgaGVpZ2h0KTtcbiAgICAgIGRpdlRvcCA9IHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpdlRvcCA9IHAuY2FudmFzeSAtIGhlaWdodCAtIHRpY2tfaGVpZ2h0O1xuICAgIH1cbiAgICBkaXYuc3R5bGUudG9wID0gZGl2VG9wICsgXCJweFwiO1xuICAgIGRpdi5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgIGRpdi5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gICAgZGl2LnRpdGxlID0gcC5hbm5vdGF0aW9uLnRleHQ7XG4gICAgZGl2LnN0eWxlLmNvbG9yID0gZy5jb2xvcnNNYXBfW3AubmFtZV07XG4gICAgZGl2LnN0eWxlLmJvcmRlckNvbG9yID0gZy5jb2xvcnNNYXBfW3AubmFtZV07XG4gICAgYS5kaXYgPSBkaXY7XG5cbiAgICBnLmFkZEFuZFRyYWNrRXZlbnQoZGl2LCAnY2xpY2snLFxuICAgICAgICBiaW5kRXZ0KCdjbGlja0hhbmRsZXInLCAnYW5ub3RhdGlvbkNsaWNrSGFuZGxlcicsIHAsIHRoaXMpKTtcbiAgICBnLmFkZEFuZFRyYWNrRXZlbnQoZGl2LCAnbW91c2VvdmVyJyxcbiAgICAgICAgYmluZEV2dCgnbW91c2VPdmVySGFuZGxlcicsICdhbm5vdGF0aW9uTW91c2VPdmVySGFuZGxlcicsIHAsIHRoaXMpKTtcbiAgICBnLmFkZEFuZFRyYWNrRXZlbnQoZGl2LCAnbW91c2VvdXQnLFxuICAgICAgICBiaW5kRXZ0KCdtb3VzZU91dEhhbmRsZXInLCAnYW5ub3RhdGlvbk1vdXNlT3V0SGFuZGxlcicsIHAsIHRoaXMpKTtcbiAgICBnLmFkZEFuZFRyYWNrRXZlbnQoZGl2LCAnZGJsY2xpY2snLFxuICAgICAgICBiaW5kRXZ0KCdkYmxDbGlja0hhbmRsZXInLCAnYW5ub3RhdGlvbkRibENsaWNrSGFuZGxlcicsIHAsIHRoaXMpKTtcblxuICAgIGNvbnRhaW5lckRpdi5hcHBlbmRDaGlsZChkaXYpO1xuICAgIHRoaXMuYW5ub3RhdGlvbnNfLnB1c2goZGl2KTtcblxuICAgIHZhciBjdHggPSBlLmRyYXdpbmdDb250ZXh0O1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gYS5oYXNPd25Qcm9wZXJ0eSgndGlja0NvbG9yJykgPyBhLnRpY2tDb2xvciA6IGcuY29sb3JzTWFwX1twLm5hbWVdO1xuICAgIGN0eC5saW5lV2lkdGggPSBhLmhhc093blByb3BlcnR5KCd0aWNrV2lkdGgnKSA/IGEudGlja1dpZHRoIDogZy5nZXRPcHRpb24oJ3N0cm9rZVdpZHRoJyk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGlmICghYS5hdHRhY2hBdEJvdHRvbSkge1xuICAgICAgY3R4Lm1vdmVUbyhwLmNhbnZhc3gsIHAuY2FudmFzeSk7XG4gICAgICBjdHgubGluZVRvKHAuY2FudmFzeCwgcC5jYW52YXN5IC0gMiAtIHRpY2tfaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHkgPSBkaXZUb3AgKyBoZWlnaHQ7XG4gICAgICBjdHgubW92ZVRvKHAuY2FudmFzeCwgeSk7XG4gICAgICBjdHgubGluZVRvKHAuY2FudmFzeCwgeSArIHRpY2tfaGVpZ2h0KTtcbiAgICB9XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59O1xuXG5hbm5vdGF0aW9ucy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRldGFjaExhYmVscygpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgYW5ub3RhdGlvbnM7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///qYh3\n");

/***/ }),

/***/ "sVdv":
/*!***************************************************!*\
  !*** ./node_modules/dygraphs/src/plugins/grid.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n/*global Dygraph:false */\n\n/*\n\nCurrent bits of jankiness:\n- Direct layout access\n- Direct area access\n\n*/\n\n\n\n/**\n * Draws the gridlines, i.e. the gray horizontal & vertical lines running the\n * length of the chart.\n *\n * @constructor\n */\nvar grid = function() {\n};\n\ngrid.prototype.toString = function() {\n  return \"Gridline Plugin\";\n};\n\ngrid.prototype.activate = function(g) {\n  return {\n    willDrawChart: this.willDrawChart\n  };\n};\n\ngrid.prototype.willDrawChart = function(e) {\n  // Draw the new X/Y grid. Lines appear crisper when pixels are rounded to\n  // half-integers. This prevents them from drawing in two rows/cols.\n  var g = e.dygraph;\n  var ctx = e.drawingContext;\n  var layout = g.layout_;\n  var area = e.dygraph.plotter_.area;\n\n  function halfUp(x)  { return Math.round(x) + 0.5; }\n  function halfDown(y){ return Math.round(y) - 0.5; }\n\n  var x, y, i, ticks;\n  if (g.getOptionForAxis('drawGrid', 'y')) {\n    var axes = [\"y\", \"y2\"];\n    var strokeStyles = [], lineWidths = [], drawGrid = [], stroking = [], strokePattern = [];\n    for (var i = 0; i < axes.length; i++) {\n      drawGrid[i] = g.getOptionForAxis('drawGrid', axes[i]);\n      if (drawGrid[i]) {\n        strokeStyles[i] = g.getOptionForAxis('gridLineColor', axes[i]);\n        lineWidths[i] = g.getOptionForAxis('gridLineWidth', axes[i]);\n        strokePattern[i] = g.getOptionForAxis('gridLinePattern', axes[i]);\n        stroking[i] = strokePattern[i] && (strokePattern[i].length >= 2);\n      }\n    }\n    ticks = layout.yticks;\n    ctx.save();\n    // draw grids for the different y axes\n    ticks.forEach(tick => {\n      if (!tick.has_tick) return;\n      var axis = tick.axis;\n      if (drawGrid[axis]) {\n        ctx.save();\n        if (stroking[axis]) {\n          if (ctx.setLineDash) ctx.setLineDash(strokePattern[axis]);\n        }\n        ctx.strokeStyle = strokeStyles[axis];\n        ctx.lineWidth = lineWidths[axis];\n\n        x = halfUp(area.x);\n        y = halfDown(area.y + tick.pos * area.h);\n        ctx.beginPath();\n        ctx.moveTo(x, y);\n        ctx.lineTo(x + area.w, y);\n        ctx.stroke();\n\n        ctx.restore();\n      }\n    });\n    ctx.restore();\n  }\n\n  // draw grid for x axis\n  if (g.getOptionForAxis('drawGrid', 'x')) {\n    ticks = layout.xticks;\n    ctx.save();\n    var strokePattern = g.getOptionForAxis('gridLinePattern', 'x');\n    var stroking = strokePattern && (strokePattern.length >= 2);\n    if (stroking) {\n      if (ctx.setLineDash) ctx.setLineDash(strokePattern);\n    }\n    ctx.strokeStyle = g.getOptionForAxis('gridLineColor', 'x');\n    ctx.lineWidth = g.getOptionForAxis('gridLineWidth', 'x');\n    ticks.forEach(tick => {\n      if (!tick.has_tick) return;\n      x = halfUp(area.x + tick.pos * area.w);\n      y = halfDown(area.y + area.h);\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(x, area.y);\n      ctx.closePath();\n      ctx.stroke();\n    });\n    if (stroking) {\n      if (ctx.setLineDash) ctx.setLineDash([]);\n    }\n    ctx.restore();\n  }\n};\n\ngrid.prototype.destroy = function() {\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (grid);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic1Zkdi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9keWdyYXBocy9zcmMvcGx1Z2lucy9ncmlkLmpzP2IxNTciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTIgRGFuIFZhbmRlcmthbSAoZGFudmRrQGdtYWlsLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXG4vKlxuXG5DdXJyZW50IGJpdHMgb2YgamFua2luZXNzOlxuLSBEaXJlY3QgbGF5b3V0IGFjY2Vzc1xuLSBEaXJlY3QgYXJlYSBhY2Nlc3NcblxuKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogRHJhd3MgdGhlIGdyaWRsaW5lcywgaS5lLiB0aGUgZ3JheSBob3Jpem9udGFsICYgdmVydGljYWwgbGluZXMgcnVubmluZyB0aGVcbiAqIGxlbmd0aCBvZiB0aGUgY2hhcnQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBncmlkID0gZnVuY3Rpb24oKSB7XG59O1xuXG5ncmlkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXCJHcmlkbGluZSBQbHVnaW5cIjtcbn07XG5cbmdyaWQucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oZykge1xuICByZXR1cm4ge1xuICAgIHdpbGxEcmF3Q2hhcnQ6IHRoaXMud2lsbERyYXdDaGFydFxuICB9O1xufTtcblxuZ3JpZC5wcm90b3R5cGUud2lsbERyYXdDaGFydCA9IGZ1bmN0aW9uKGUpIHtcbiAgLy8gRHJhdyB0aGUgbmV3IFgvWSBncmlkLiBMaW5lcyBhcHBlYXIgY3Jpc3BlciB3aGVuIHBpeGVscyBhcmUgcm91bmRlZCB0b1xuICAvLyBoYWxmLWludGVnZXJzLiBUaGlzIHByZXZlbnRzIHRoZW0gZnJvbSBkcmF3aW5nIGluIHR3byByb3dzL2NvbHMuXG4gIHZhciBnID0gZS5keWdyYXBoO1xuICB2YXIgY3R4ID0gZS5kcmF3aW5nQ29udGV4dDtcbiAgdmFyIGxheW91dCA9IGcubGF5b3V0XztcbiAgdmFyIGFyZWEgPSBlLmR5Z3JhcGgucGxvdHRlcl8uYXJlYTtcblxuICBmdW5jdGlvbiBoYWxmVXAoeCkgIHsgcmV0dXJuIE1hdGgucm91bmQoeCkgKyAwLjU7IH1cbiAgZnVuY3Rpb24gaGFsZkRvd24oeSl7IHJldHVybiBNYXRoLnJvdW5kKHkpIC0gMC41OyB9XG5cbiAgdmFyIHgsIHksIGksIHRpY2tzO1xuICBpZiAoZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3R3JpZCcsICd5JykpIHtcbiAgICB2YXIgYXhlcyA9IFtcInlcIiwgXCJ5MlwiXTtcbiAgICB2YXIgc3Ryb2tlU3R5bGVzID0gW10sIGxpbmVXaWR0aHMgPSBbXSwgZHJhd0dyaWQgPSBbXSwgc3Ryb2tpbmcgPSBbXSwgc3Ryb2tlUGF0dGVybiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZHJhd0dyaWRbaV0gPSBnLmdldE9wdGlvbkZvckF4aXMoJ2RyYXdHcmlkJywgYXhlc1tpXSk7XG4gICAgICBpZiAoZHJhd0dyaWRbaV0pIHtcbiAgICAgICAgc3Ryb2tlU3R5bGVzW2ldID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdncmlkTGluZUNvbG9yJywgYXhlc1tpXSk7XG4gICAgICAgIGxpbmVXaWR0aHNbaV0gPSBnLmdldE9wdGlvbkZvckF4aXMoJ2dyaWRMaW5lV2lkdGgnLCBheGVzW2ldKTtcbiAgICAgICAgc3Ryb2tlUGF0dGVybltpXSA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnZ3JpZExpbmVQYXR0ZXJuJywgYXhlc1tpXSk7XG4gICAgICAgIHN0cm9raW5nW2ldID0gc3Ryb2tlUGF0dGVybltpXSAmJiAoc3Ryb2tlUGF0dGVybltpXS5sZW5ndGggPj0gMik7XG4gICAgICB9XG4gICAgfVxuICAgIHRpY2tzID0gbGF5b3V0Lnl0aWNrcztcbiAgICBjdHguc2F2ZSgpO1xuICAgIC8vIGRyYXcgZ3JpZHMgZm9yIHRoZSBkaWZmZXJlbnQgeSBheGVzXG4gICAgdGlja3MuZm9yRWFjaCh0aWNrID0+IHtcbiAgICAgIGlmICghdGljay5oYXNfdGljaykgcmV0dXJuO1xuICAgICAgdmFyIGF4aXMgPSB0aWNrLmF4aXM7XG4gICAgICBpZiAoZHJhd0dyaWRbYXhpc10pIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgaWYgKHN0cm9raW5nW2F4aXNdKSB7XG4gICAgICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCkgY3R4LnNldExpbmVEYXNoKHN0cm9rZVBhdHRlcm5bYXhpc10pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlc1theGlzXTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aHNbYXhpc107XG5cbiAgICAgICAgeCA9IGhhbGZVcChhcmVhLngpO1xuICAgICAgICB5ID0gaGFsZkRvd24oYXJlYS55ICsgdGljay5wb3MgKiBhcmVhLmgpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIGFyZWEudywgeSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICAvLyBkcmF3IGdyaWQgZm9yIHggYXhpc1xuICBpZiAoZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3R3JpZCcsICd4JykpIHtcbiAgICB0aWNrcyA9IGxheW91dC54dGlja3M7XG4gICAgY3R4LnNhdmUoKTtcbiAgICB2YXIgc3Ryb2tlUGF0dGVybiA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnZ3JpZExpbmVQYXR0ZXJuJywgJ3gnKTtcbiAgICB2YXIgc3Ryb2tpbmcgPSBzdHJva2VQYXR0ZXJuICYmIChzdHJva2VQYXR0ZXJuLmxlbmd0aCA+PSAyKTtcbiAgICBpZiAoc3Ryb2tpbmcpIHtcbiAgICAgIGlmIChjdHguc2V0TGluZURhc2gpIGN0eC5zZXRMaW5lRGFzaChzdHJva2VQYXR0ZXJuKTtcbiAgICB9XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdncmlkTGluZUNvbG9yJywgJ3gnKTtcbiAgICBjdHgubGluZVdpZHRoID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdncmlkTGluZVdpZHRoJywgJ3gnKTtcbiAgICB0aWNrcy5mb3JFYWNoKHRpY2sgPT4ge1xuICAgICAgaWYgKCF0aWNrLmhhc190aWNrKSByZXR1cm47XG4gICAgICB4ID0gaGFsZlVwKGFyZWEueCArIHRpY2sucG9zICogYXJlYS53KTtcbiAgICAgIHkgPSBoYWxmRG93bihhcmVhLnkgKyBhcmVhLmgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCwgYXJlYS55KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9KTtcbiAgICBpZiAoc3Ryb2tpbmcpIHtcbiAgICAgIGlmIChjdHguc2V0TGluZURhc2gpIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn07XG5cbmdyaWQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGdyaWQ7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///sVdv\n");

/***/ })

}]);