(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~46fbf940"],{

/***/ "MO+k":
/*!*********************************************!*\
  !*** ./node_modules/chart.js/dist/Chart.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chart.js v2.9.4\n * https://www.chartjs.org\n * (c) 2020 Chart.js Contributors\n * Released under the MIT License\n */\n(function (global, factory) {\n true ? module.exports = factory(function() { try { return __webpack_require__(/*! moment */ \"wd/R\"); } catch(e) { } }()) :\nundefined;\n}(this, (function (moment) { 'use strict';\n\nmoment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nfunction getCjsExportFromNamespace (n) {\n\treturn n && n['default'] || n;\n}\n\nvar colorName = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\n\nvar conversions = createCommonjsModule(function (module) {\n/* MIT license */\n\n\n// NOTE: conversions should only return primitive values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//       do not use box values types (i.e. Number(), String(), etc.)\n\nvar reverseKeywords = {};\nfor (var key in colorName) {\n\tif (colorName.hasOwnProperty(key)) {\n\t\treverseKeywords[colorName[key]] = key;\n\t}\n}\n\nvar convert = module.exports = {\n\trgb: {channels: 3, labels: 'rgb'},\n\thsl: {channels: 3, labels: 'hsl'},\n\thsv: {channels: 3, labels: 'hsv'},\n\thwb: {channels: 3, labels: 'hwb'},\n\tcmyk: {channels: 4, labels: 'cmyk'},\n\txyz: {channels: 3, labels: 'xyz'},\n\tlab: {channels: 3, labels: 'lab'},\n\tlch: {channels: 3, labels: 'lch'},\n\thex: {channels: 1, labels: ['hex']},\n\tkeyword: {channels: 1, labels: ['keyword']},\n\tansi16: {channels: 1, labels: ['ansi16']},\n\tansi256: {channels: 1, labels: ['ansi256']},\n\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\tapple: {channels: 3, labels: ['r16', 'g16', 'b16']},\n\tgray: {channels: 1, labels: ['gray']}\n};\n\n// hide .channels and .labels properties\nfor (var model in convert) {\n\tif (convert.hasOwnProperty(model)) {\n\t\tif (!('channels' in convert[model])) {\n\t\t\tthrow new Error('missing channels property: ' + model);\n\t\t}\n\n\t\tif (!('labels' in convert[model])) {\n\t\t\tthrow new Error('missing channel labels property: ' + model);\n\t\t}\n\n\t\tif (convert[model].labels.length !== convert[model].channels) {\n\t\t\tthrow new Error('channel and label counts mismatch: ' + model);\n\t\t}\n\n\t\tvar channels = convert[model].channels;\n\t\tvar labels = convert[model].labels;\n\t\tdelete convert[model].channels;\n\t\tdelete convert[model].labels;\n\t\tObject.defineProperty(convert[model], 'channels', {value: channels});\n\t\tObject.defineProperty(convert[model], 'labels', {value: labels});\n\t}\n}\n\nconvert.rgb.hsl = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar min = Math.min(r, g, b);\n\tvar max = Math.max(r, g, b);\n\tvar delta = max - min;\n\tvar h;\n\tvar s;\n\tvar l;\n\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t} else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\n\th = Math.min(h * 60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tl = (min + max) / 2;\n\n\tif (max === min) {\n\t\ts = 0;\n\t} else if (l <= 0.5) {\n\t\ts = delta / (max + min);\n\t} else {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100, l * 100];\n};\n\nconvert.rgb.hsv = function (rgb) {\n\tvar rdif;\n\tvar gdif;\n\tvar bdif;\n\tvar h;\n\tvar s;\n\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar v = Math.max(r, g, b);\n\tvar diff = v - Math.min(r, g, b);\n\tvar diffc = function (c) {\n\t\treturn (v - c) / 6 / diff + 1 / 2;\n\t};\n\n\tif (diff === 0) {\n\t\th = s = 0;\n\t} else {\n\t\ts = diff / v;\n\t\trdif = diffc(r);\n\t\tgdif = diffc(g);\n\t\tbdif = diffc(b);\n\n\t\tif (r === v) {\n\t\t\th = bdif - gdif;\n\t\t} else if (g === v) {\n\t\t\th = (1 / 3) + rdif - bdif;\n\t\t} else if (b === v) {\n\t\t\th = (2 / 3) + gdif - rdif;\n\t\t}\n\t\tif (h < 0) {\n\t\t\th += 1;\n\t\t} else if (h > 1) {\n\t\t\th -= 1;\n\t\t}\n\t}\n\n\treturn [\n\t\th * 360,\n\t\ts * 100,\n\t\tv * 100\n\t];\n};\n\nconvert.rgb.hwb = function (rgb) {\n\tvar r = rgb[0];\n\tvar g = rgb[1];\n\tvar b = rgb[2];\n\tvar h = convert.rgb.hsl(rgb)[0];\n\tvar w = 1 / 255 * Math.min(r, Math.min(g, b));\n\n\tb = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n\n\treturn [h, w * 100, b * 100];\n};\n\nconvert.rgb.cmyk = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar c;\n\tvar m;\n\tvar y;\n\tvar k;\n\n\tk = Math.min(1 - r, 1 - g, 1 - b);\n\tc = (1 - r - k) / (1 - k) || 0;\n\tm = (1 - g - k) / (1 - k) || 0;\n\ty = (1 - b - k) / (1 - k) || 0;\n\n\treturn [c * 100, m * 100, y * 100, k * 100];\n};\n\n/**\n * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n * */\nfunction comparativeDistance(x, y) {\n\treturn (\n\t\tMath.pow(x[0] - y[0], 2) +\n\t\tMath.pow(x[1] - y[1], 2) +\n\t\tMath.pow(x[2] - y[2], 2)\n\t);\n}\n\nconvert.rgb.keyword = function (rgb) {\n\tvar reversed = reverseKeywords[rgb];\n\tif (reversed) {\n\t\treturn reversed;\n\t}\n\n\tvar currentClosestDistance = Infinity;\n\tvar currentClosestKeyword;\n\n\tfor (var keyword in colorName) {\n\t\tif (colorName.hasOwnProperty(keyword)) {\n\t\t\tvar value = colorName[keyword];\n\n\t\t\t// Compute comparative distance\n\t\t\tvar distance = comparativeDistance(rgb, value);\n\n\t\t\t// Check if its less, if so set as closest\n\t\t\tif (distance < currentClosestDistance) {\n\t\t\t\tcurrentClosestDistance = distance;\n\t\t\t\tcurrentClosestKeyword = keyword;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn currentClosestKeyword;\n};\n\nconvert.keyword.rgb = function (keyword) {\n\treturn colorName[keyword];\n};\n\nconvert.rgb.xyz = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\n\t// assume sRGB\n\tr = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n\tvar x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\tvar y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tvar z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n\treturn [x * 100, y * 100, z * 100];\n};\n\nconvert.rgb.lab = function (rgb) {\n\tvar xyz = convert.rgb.xyz(rgb);\n\tvar x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.hsl.rgb = function (hsl) {\n\tvar h = hsl[0] / 360;\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar t1;\n\tvar t2;\n\tvar t3;\n\tvar rgb;\n\tvar val;\n\n\tif (s === 0) {\n\t\tval = l * 255;\n\t\treturn [val, val, val];\n\t}\n\n\tif (l < 0.5) {\n\t\tt2 = l * (1 + s);\n\t} else {\n\t\tt2 = l + s - l * s;\n\t}\n\n\tt1 = 2 * l - t2;\n\n\trgb = [0, 0, 0];\n\tfor (var i = 0; i < 3; i++) {\n\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\tif (t3 < 0) {\n\t\t\tt3++;\n\t\t}\n\t\tif (t3 > 1) {\n\t\t\tt3--;\n\t\t}\n\n\t\tif (6 * t3 < 1) {\n\t\t\tval = t1 + (t2 - t1) * 6 * t3;\n\t\t} else if (2 * t3 < 1) {\n\t\t\tval = t2;\n\t\t} else if (3 * t3 < 2) {\n\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t} else {\n\t\t\tval = t1;\n\t\t}\n\n\t\trgb[i] = val * 255;\n\t}\n\n\treturn rgb;\n};\n\nconvert.hsl.hsv = function (hsl) {\n\tvar h = hsl[0];\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar smin = s;\n\tvar lmin = Math.max(l, 0.01);\n\tvar sv;\n\tvar v;\n\n\tl *= 2;\n\ts *= (l <= 1) ? l : 2 - l;\n\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\tv = (l + s) / 2;\n\tsv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\n\treturn [h, sv * 100, v * 100];\n};\n\nconvert.hsv.rgb = function (hsv) {\n\tvar h = hsv[0] / 60;\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar hi = Math.floor(h) % 6;\n\n\tvar f = h - Math.floor(h);\n\tvar p = 255 * v * (1 - s);\n\tvar q = 255 * v * (1 - (s * f));\n\tvar t = 255 * v * (1 - (s * (1 - f)));\n\tv *= 255;\n\n\tswitch (hi) {\n\t\tcase 0:\n\t\t\treturn [v, t, p];\n\t\tcase 1:\n\t\t\treturn [q, v, p];\n\t\tcase 2:\n\t\t\treturn [p, v, t];\n\t\tcase 3:\n\t\t\treturn [p, q, v];\n\t\tcase 4:\n\t\t\treturn [t, p, v];\n\t\tcase 5:\n\t\t\treturn [v, p, q];\n\t}\n};\n\nconvert.hsv.hsl = function (hsv) {\n\tvar h = hsv[0];\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar vmin = Math.max(v, 0.01);\n\tvar lmin;\n\tvar sl;\n\tvar l;\n\n\tl = (2 - s) * v;\n\tlmin = (2 - s) * vmin;\n\tsl = s * vmin;\n\tsl /= (lmin <= 1) ? lmin : 2 - lmin;\n\tsl = sl || 0;\n\tl /= 2;\n\n\treturn [h, sl * 100, l * 100];\n};\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb = function (hwb) {\n\tvar h = hwb[0] / 360;\n\tvar wh = hwb[1] / 100;\n\tvar bl = hwb[2] / 100;\n\tvar ratio = wh + bl;\n\tvar i;\n\tvar v;\n\tvar f;\n\tvar n;\n\n\t// wh + bl cant be > 1\n\tif (ratio > 1) {\n\t\twh /= ratio;\n\t\tbl /= ratio;\n\t}\n\n\ti = Math.floor(6 * h);\n\tv = 1 - bl;\n\tf = 6 * h - i;\n\n\tif ((i & 0x01) !== 0) {\n\t\tf = 1 - f;\n\t}\n\n\tn = wh + f * (v - wh); // linear interpolation\n\n\tvar r;\n\tvar g;\n\tvar b;\n\tswitch (i) {\n\t\tdefault:\n\t\tcase 6:\n\t\tcase 0: r = v; g = n; b = wh; break;\n\t\tcase 1: r = n; g = v; b = wh; break;\n\t\tcase 2: r = wh; g = v; b = n; break;\n\t\tcase 3: r = wh; g = n; b = v; break;\n\t\tcase 4: r = n; g = wh; b = v; break;\n\t\tcase 5: r = v; g = wh; b = n; break;\n\t}\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.cmyk.rgb = function (cmyk) {\n\tvar c = cmyk[0] / 100;\n\tvar m = cmyk[1] / 100;\n\tvar y = cmyk[2] / 100;\n\tvar k = cmyk[3] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\n\tr = 1 - Math.min(1, c * (1 - k) + k);\n\tg = 1 - Math.min(1, m * (1 - k) + k);\n\tb = 1 - Math.min(1, y * (1 - k) + k);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.rgb = function (xyz) {\n\tvar x = xyz[0] / 100;\n\tvar y = xyz[1] / 100;\n\tvar z = xyz[2] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\n\tr = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\tb = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n\t// assume sRGB\n\tr = r > 0.0031308\n\t\t? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n\t\t: r * 12.92;\n\n\tg = g > 0.0031308\n\t\t? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n\t\t: g * 12.92;\n\n\tb = b > 0.0031308\n\t\t? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n\t\t: b * 12.92;\n\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.lab = function (xyz) {\n\tvar x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.lab.xyz = function (lab) {\n\tvar l = lab[0];\n\tvar a = lab[1];\n\tvar b = lab[2];\n\tvar x;\n\tvar y;\n\tvar z;\n\n\ty = (l + 16) / 116;\n\tx = a / 500 + y;\n\tz = y - b / 200;\n\n\tvar y2 = Math.pow(y, 3);\n\tvar x2 = Math.pow(x, 3);\n\tvar z2 = Math.pow(z, 3);\n\ty = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\tz = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100;\n\tz *= 108.883;\n\n\treturn [x, y, z];\n};\n\nconvert.lab.lch = function (lab) {\n\tvar l = lab[0];\n\tvar a = lab[1];\n\tvar b = lab[2];\n\tvar hr;\n\tvar h;\n\tvar c;\n\n\thr = Math.atan2(b, a);\n\th = hr * 360 / 2 / Math.PI;\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tc = Math.sqrt(a * a + b * b);\n\n\treturn [l, c, h];\n};\n\nconvert.lch.lab = function (lch) {\n\tvar l = lch[0];\n\tvar c = lch[1];\n\tvar h = lch[2];\n\tvar a;\n\tvar b;\n\tvar hr;\n\n\thr = h / 360 * 2 * Math.PI;\n\ta = c * Math.cos(hr);\n\tb = c * Math.sin(hr);\n\n\treturn [l, a, b];\n};\n\nconvert.rgb.ansi16 = function (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\tvar value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization\n\n\tvalue = Math.round(value / 50);\n\n\tif (value === 0) {\n\t\treturn 30;\n\t}\n\n\tvar ansi = 30\n\t\t+ ((Math.round(b / 255) << 2)\n\t\t| (Math.round(g / 255) << 1)\n\t\t| Math.round(r / 255));\n\n\tif (value === 2) {\n\t\tansi += 60;\n\t}\n\n\treturn ansi;\n};\n\nconvert.hsv.ansi16 = function (args) {\n\t// optimization here; we already know the value and don't need to get\n\t// it converted for us.\n\treturn convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n};\n\nconvert.rgb.ansi256 = function (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\n\t// we use the extended greyscale palette here, with the exception of\n\t// black and white. normal palette only has 4 greyscale shades.\n\tif (r === g && g === b) {\n\t\tif (r < 8) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tif (r > 248) {\n\t\t\treturn 231;\n\t\t}\n\n\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t}\n\n\tvar ansi = 16\n\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t+ (6 * Math.round(g / 255 * 5))\n\t\t+ Math.round(b / 255 * 5);\n\n\treturn ansi;\n};\n\nconvert.ansi16.rgb = function (args) {\n\tvar color = args % 10;\n\n\t// handle greyscale\n\tif (color === 0 || color === 7) {\n\t\tif (args > 50) {\n\t\t\tcolor += 3.5;\n\t\t}\n\n\t\tcolor = color / 10.5 * 255;\n\n\t\treturn [color, color, color];\n\t}\n\n\tvar mult = (~~(args > 50) + 1) * 0.5;\n\tvar r = ((color & 1) * mult) * 255;\n\tvar g = (((color >> 1) & 1) * mult) * 255;\n\tvar b = (((color >> 2) & 1) * mult) * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.ansi256.rgb = function (args) {\n\t// handle greyscale\n\tif (args >= 232) {\n\t\tvar c = (args - 232) * 10 + 8;\n\t\treturn [c, c, c];\n\t}\n\n\targs -= 16;\n\n\tvar rem;\n\tvar r = Math.floor(args / 36) / 5 * 255;\n\tvar g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n\tvar b = (rem % 6) / 5 * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hex = function (args) {\n\tvar integer = ((Math.round(args[0]) & 0xFF) << 16)\n\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t+ (Math.round(args[2]) & 0xFF);\n\n\tvar string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.hex.rgb = function (args) {\n\tvar match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\tif (!match) {\n\t\treturn [0, 0, 0];\n\t}\n\n\tvar colorString = match[0];\n\n\tif (match[0].length === 3) {\n\t\tcolorString = colorString.split('').map(function (char) {\n\t\t\treturn char + char;\n\t\t}).join('');\n\t}\n\n\tvar integer = parseInt(colorString, 16);\n\tvar r = (integer >> 16) & 0xFF;\n\tvar g = (integer >> 8) & 0xFF;\n\tvar b = integer & 0xFF;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hcg = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar max = Math.max(Math.max(r, g), b);\n\tvar min = Math.min(Math.min(r, g), b);\n\tvar chroma = (max - min);\n\tvar grayscale;\n\tvar hue;\n\n\tif (chroma < 1) {\n\t\tgrayscale = min / (1 - chroma);\n\t} else {\n\t\tgrayscale = 0;\n\t}\n\n\tif (chroma <= 0) {\n\t\thue = 0;\n\t} else\n\tif (max === r) {\n\t\thue = ((g - b) / chroma) % 6;\n\t} else\n\tif (max === g) {\n\t\thue = 2 + (b - r) / chroma;\n\t} else {\n\t\thue = 4 + (r - g) / chroma + 4;\n\t}\n\n\thue /= 6;\n\thue %= 1;\n\n\treturn [hue * 360, chroma * 100, grayscale * 100];\n};\n\nconvert.hsl.hcg = function (hsl) {\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar c = 1;\n\tvar f = 0;\n\n\tif (l < 0.5) {\n\t\tc = 2.0 * s * l;\n\t} else {\n\t\tc = 2.0 * s * (1.0 - l);\n\t}\n\n\tif (c < 1.0) {\n\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t}\n\n\treturn [hsl[0], c * 100, f * 100];\n};\n\nconvert.hsv.hcg = function (hsv) {\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\n\tvar c = s * v;\n\tvar f = 0;\n\n\tif (c < 1.0) {\n\t\tf = (v - c) / (1 - c);\n\t}\n\n\treturn [hsv[0], c * 100, f * 100];\n};\n\nconvert.hcg.rgb = function (hcg) {\n\tvar h = hcg[0] / 360;\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tif (c === 0.0) {\n\t\treturn [g * 255, g * 255, g * 255];\n\t}\n\n\tvar pure = [0, 0, 0];\n\tvar hi = (h % 1) * 6;\n\tvar v = hi % 1;\n\tvar w = 1 - v;\n\tvar mg = 0;\n\n\tswitch (Math.floor(hi)) {\n\t\tcase 0:\n\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\tcase 1:\n\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\tcase 2:\n\t\t\tpure[0] = 0; pure[1] = 1; pure[2] = v; break;\n\t\tcase 3:\n\t\t\tpure[0] = 0; pure[1] = w; pure[2] = 1; break;\n\t\tcase 4:\n\t\t\tpure[0] = v; pure[1] = 0; pure[2] = 1; break;\n\t\tdefault:\n\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t}\n\n\tmg = (1.0 - c) * g;\n\n\treturn [\n\t\t(c * pure[0] + mg) * 255,\n\t\t(c * pure[1] + mg) * 255,\n\t\t(c * pure[2] + mg) * 255\n\t];\n};\n\nconvert.hcg.hsv = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tvar v = c + g * (1.0 - c);\n\tvar f = 0;\n\n\tif (v > 0.0) {\n\t\tf = c / v;\n\t}\n\n\treturn [hcg[0], f * 100, v * 100];\n};\n\nconvert.hcg.hsl = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tvar l = g * (1.0 - c) + 0.5 * c;\n\tvar s = 0;\n\n\tif (l > 0.0 && l < 0.5) {\n\t\ts = c / (2 * l);\n\t} else\n\tif (l >= 0.5 && l < 1.0) {\n\t\ts = c / (2 * (1 - l));\n\t}\n\n\treturn [hcg[0], s * 100, l * 100];\n};\n\nconvert.hcg.hwb = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\tvar v = c + g * (1.0 - c);\n\treturn [hcg[0], (v - c) * 100, (1 - v) * 100];\n};\n\nconvert.hwb.hcg = function (hwb) {\n\tvar w = hwb[1] / 100;\n\tvar b = hwb[2] / 100;\n\tvar v = 1 - b;\n\tvar c = v - w;\n\tvar g = 0;\n\n\tif (c < 1) {\n\t\tg = (v - c) / (1 - c);\n\t}\n\n\treturn [hwb[0], c * 100, g * 100];\n};\n\nconvert.apple.rgb = function (apple) {\n\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];\n};\n\nconvert.rgb.apple = function (rgb) {\n\treturn [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n};\n\nconvert.gray.rgb = function (args) {\n\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n};\n\nconvert.gray.hsl = convert.gray.hsv = function (args) {\n\treturn [0, 0, args[0]];\n};\n\nconvert.gray.hwb = function (gray) {\n\treturn [0, 100, gray[0]];\n};\n\nconvert.gray.cmyk = function (gray) {\n\treturn [0, 0, 0, gray[0]];\n};\n\nconvert.gray.lab = function (gray) {\n\treturn [gray[0], 0, 0];\n};\n\nconvert.gray.hex = function (gray) {\n\tvar val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\tvar integer = (val << 16) + (val << 8) + val;\n\n\tvar string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.rgb.gray = function (rgb) {\n\tvar val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\treturn [val / 255 * 100];\n};\n});\nvar conversions_1 = conversions.rgb;\nvar conversions_2 = conversions.hsl;\nvar conversions_3 = conversions.hsv;\nvar conversions_4 = conversions.hwb;\nvar conversions_5 = conversions.cmyk;\nvar conversions_6 = conversions.xyz;\nvar conversions_7 = conversions.lab;\nvar conversions_8 = conversions.lch;\nvar conversions_9 = conversions.hex;\nvar conversions_10 = conversions.keyword;\nvar conversions_11 = conversions.ansi16;\nvar conversions_12 = conversions.ansi256;\nvar conversions_13 = conversions.hcg;\nvar conversions_14 = conversions.apple;\nvar conversions_15 = conversions.gray;\n\n/*\n\tthis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\nfunction buildGraph() {\n\tvar graph = {};\n\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\tvar models = Object.keys(conversions);\n\n\tfor (var len = models.length, i = 0; i < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t// micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel) {\n\tvar graph = buildGraph();\n\tvar queue = [fromModel]; // unshift -> queue -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tvar current = queue.pop();\n\t\tvar adjacents = Object.keys(conversions[current]);\n\n\t\tfor (var len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tvar adjacent = adjacents[i];\n\t\t\tvar node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tvar path = [graph[toModel].parent, toModel];\n\tvar fn = conversions[graph[toModel].parent][toModel];\n\n\tvar cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion = path;\n\treturn fn;\n}\n\nvar route = function (fromModel) {\n\tvar graph = deriveBFS(fromModel);\n\tvar conversion = {};\n\n\tvar models = Object.keys(graph);\n\tfor (var len = models.length, i = 0; i < len; i++) {\n\t\tvar toModel = models[i];\n\t\tvar node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// no possible conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\nvar convert = {};\n\nvar models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tvar wrappedFn = function (args) {\n\t\tif (args === undefined || args === null) {\n\t\t\treturn args;\n\t\t}\n\n\t\tif (arguments.length > 1) {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\n\t\treturn fn(args);\n\t};\n\n\t// preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction wrapRounded(fn) {\n\tvar wrappedFn = function (args) {\n\t\tif (args === undefined || args === null) {\n\t\t\treturn args;\n\t\t}\n\n\t\tif (arguments.length > 1) {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\n\t\tvar result = fn(args);\n\n\t\t// we're assuming the result is an array here.\n\t\t// see notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif (typeof result === 'object') {\n\t\t\tfor (var len = result.length, i = 0; i < len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t// preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(function (fromModel) {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\n\tvar routes = route(fromModel);\n\tvar routeModels = Object.keys(routes);\n\n\trouteModels.forEach(function (toModel) {\n\t\tvar fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t});\n});\n\nvar colorConvert = convert;\n\nvar colorName$1 = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\n\n/* MIT license */\n\n\nvar colorString = {\n   getRgba: getRgba,\n   getHsla: getHsla,\n   getRgb: getRgb,\n   getHsl: getHsl,\n   getHwb: getHwb,\n   getAlpha: getAlpha,\n\n   hexString: hexString,\n   rgbString: rgbString,\n   rgbaString: rgbaString,\n   percentString: percentString,\n   percentaString: percentaString,\n   hslString: hslString,\n   hslaString: hslaString,\n   hwbString: hwbString,\n   keyword: keyword\n};\n\nfunction getRgba(string) {\n   if (!string) {\n      return;\n   }\n   var abbr =  /^#([a-fA-F0-9]{3,4})$/i,\n       hex =  /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i,\n       rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\n       per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\n       keyword = /(\\w+)/;\n\n   var rgb = [0, 0, 0],\n       a = 1,\n       match = string.match(abbr),\n       hexAlpha = \"\";\n   if (match) {\n      match = match[1];\n      hexAlpha = match[3];\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = parseInt(match[i] + match[i], 16);\n      }\n      if (hexAlpha) {\n         a = Math.round((parseInt(hexAlpha + hexAlpha, 16) / 255) * 100) / 100;\n      }\n   }\n   else if (match = string.match(hex)) {\n      hexAlpha = match[2];\n      match = match[1];\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);\n      }\n      if (hexAlpha) {\n         a = Math.round((parseInt(hexAlpha, 16) / 255) * 100) / 100;\n      }\n   }\n   else if (match = string.match(rgba)) {\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = parseInt(match[i + 1]);\n      }\n      a = parseFloat(match[4]);\n   }\n   else if (match = string.match(per)) {\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\n      }\n      a = parseFloat(match[4]);\n   }\n   else if (match = string.match(keyword)) {\n      if (match[1] == \"transparent\") {\n         return [0, 0, 0, 0];\n      }\n      rgb = colorName$1[match[1]];\n      if (!rgb) {\n         return;\n      }\n   }\n\n   for (var i = 0; i < rgb.length; i++) {\n      rgb[i] = scale(rgb[i], 0, 255);\n   }\n   if (!a && a != 0) {\n      a = 1;\n   }\n   else {\n      a = scale(a, 0, 1);\n   }\n   rgb[3] = a;\n   return rgb;\n}\n\nfunction getHsla(string) {\n   if (!string) {\n      return;\n   }\n   var hsl = /^hsla?\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n   var match = string.match(hsl);\n   if (match) {\n      var alpha = parseFloat(match[4]);\n      var h = scale(parseInt(match[1]), 0, 360),\n          s = scale(parseFloat(match[2]), 0, 100),\n          l = scale(parseFloat(match[3]), 0, 100),\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\n      return [h, s, l, a];\n   }\n}\n\nfunction getHwb(string) {\n   if (!string) {\n      return;\n   }\n   var hwb = /^hwb\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n   var match = string.match(hwb);\n   if (match) {\n    var alpha = parseFloat(match[4]);\n      var h = scale(parseInt(match[1]), 0, 360),\n          w = scale(parseFloat(match[2]), 0, 100),\n          b = scale(parseFloat(match[3]), 0, 100),\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\n      return [h, w, b, a];\n   }\n}\n\nfunction getRgb(string) {\n   var rgba = getRgba(string);\n   return rgba && rgba.slice(0, 3);\n}\n\nfunction getHsl(string) {\n  var hsla = getHsla(string);\n  return hsla && hsla.slice(0, 3);\n}\n\nfunction getAlpha(string) {\n   var vals = getRgba(string);\n   if (vals) {\n      return vals[3];\n   }\n   else if (vals = getHsla(string)) {\n      return vals[3];\n   }\n   else if (vals = getHwb(string)) {\n      return vals[3];\n   }\n}\n\n// generators\nfunction hexString(rgba, a) {\n   var a = (a !== undefined && rgba.length === 3) ? a : rgba[3];\n   return \"#\" + hexDouble(rgba[0]) \n              + hexDouble(rgba[1])\n              + hexDouble(rgba[2])\n              + (\n                 (a >= 0 && a < 1)\n                 ? hexDouble(Math.round(a * 255))\n                 : \"\"\n              );\n}\n\nfunction rgbString(rgba, alpha) {\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\n      return rgbaString(rgba, alpha);\n   }\n   return \"rgb(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2] + \")\";\n}\n\nfunction rgbaString(rgba, alpha) {\n   if (alpha === undefined) {\n      alpha = (rgba[3] !== undefined ? rgba[3] : 1);\n   }\n   return \"rgba(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2]\n           + \", \" + alpha + \")\";\n}\n\nfunction percentString(rgba, alpha) {\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\n      return percentaString(rgba, alpha);\n   }\n   var r = Math.round(rgba[0]/255 * 100),\n       g = Math.round(rgba[1]/255 * 100),\n       b = Math.round(rgba[2]/255 * 100);\n\n   return \"rgb(\" + r + \"%, \" + g + \"%, \" + b + \"%)\";\n}\n\nfunction percentaString(rgba, alpha) {\n   var r = Math.round(rgba[0]/255 * 100),\n       g = Math.round(rgba[1]/255 * 100),\n       b = Math.round(rgba[2]/255 * 100);\n   return \"rgba(\" + r + \"%, \" + g + \"%, \" + b + \"%, \" + (alpha || rgba[3] || 1) + \")\";\n}\n\nfunction hslString(hsla, alpha) {\n   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {\n      return hslaString(hsla, alpha);\n   }\n   return \"hsl(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%)\";\n}\n\nfunction hslaString(hsla, alpha) {\n   if (alpha === undefined) {\n      alpha = (hsla[3] !== undefined ? hsla[3] : 1);\n   }\n   return \"hsla(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%, \"\n           + alpha + \")\";\n}\n\n// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\n// (hwb have alpha optional & 1 is default value)\nfunction hwbString(hwb, alpha) {\n   if (alpha === undefined) {\n      alpha = (hwb[3] !== undefined ? hwb[3] : 1);\n   }\n   return \"hwb(\" + hwb[0] + \", \" + hwb[1] + \"%, \" + hwb[2] + \"%\"\n           + (alpha !== undefined && alpha !== 1 ? \", \" + alpha : \"\") + \")\";\n}\n\nfunction keyword(rgb) {\n  return reverseNames[rgb.slice(0, 3)];\n}\n\n// helpers\nfunction scale(num, min, max) {\n   return Math.min(Math.max(min, num), max);\n}\n\nfunction hexDouble(num) {\n  var str = num.toString(16).toUpperCase();\n  return (str.length < 2) ? \"0\" + str : str;\n}\n\n\n//create a list of reverse color names\nvar reverseNames = {};\nfor (var name in colorName$1) {\n   reverseNames[colorName$1[name]] = name;\n}\n\n/* MIT license */\n\n\n\nvar Color = function (obj) {\n\tif (obj instanceof Color) {\n\t\treturn obj;\n\t}\n\tif (!(this instanceof Color)) {\n\t\treturn new Color(obj);\n\t}\n\n\tthis.valid = false;\n\tthis.values = {\n\t\trgb: [0, 0, 0],\n\t\thsl: [0, 0, 0],\n\t\thsv: [0, 0, 0],\n\t\thwb: [0, 0, 0],\n\t\tcmyk: [0, 0, 0, 0],\n\t\talpha: 1\n\t};\n\n\t// parse Color() argument\n\tvar vals;\n\tif (typeof obj === 'string') {\n\t\tvals = colorString.getRgba(obj);\n\t\tif (vals) {\n\t\t\tthis.setValues('rgb', vals);\n\t\t} else if (vals = colorString.getHsla(obj)) {\n\t\t\tthis.setValues('hsl', vals);\n\t\t} else if (vals = colorString.getHwb(obj)) {\n\t\t\tthis.setValues('hwb', vals);\n\t\t}\n\t} else if (typeof obj === 'object') {\n\t\tvals = obj;\n\t\tif (vals.r !== undefined || vals.red !== undefined) {\n\t\t\tthis.setValues('rgb', vals);\n\t\t} else if (vals.l !== undefined || vals.lightness !== undefined) {\n\t\t\tthis.setValues('hsl', vals);\n\t\t} else if (vals.v !== undefined || vals.value !== undefined) {\n\t\t\tthis.setValues('hsv', vals);\n\t\t} else if (vals.w !== undefined || vals.whiteness !== undefined) {\n\t\t\tthis.setValues('hwb', vals);\n\t\t} else if (vals.c !== undefined || vals.cyan !== undefined) {\n\t\t\tthis.setValues('cmyk', vals);\n\t\t}\n\t}\n};\n\nColor.prototype = {\n\tisValid: function () {\n\t\treturn this.valid;\n\t},\n\trgb: function () {\n\t\treturn this.setSpace('rgb', arguments);\n\t},\n\thsl: function () {\n\t\treturn this.setSpace('hsl', arguments);\n\t},\n\thsv: function () {\n\t\treturn this.setSpace('hsv', arguments);\n\t},\n\thwb: function () {\n\t\treturn this.setSpace('hwb', arguments);\n\t},\n\tcmyk: function () {\n\t\treturn this.setSpace('cmyk', arguments);\n\t},\n\n\trgbArray: function () {\n\t\treturn this.values.rgb;\n\t},\n\thslArray: function () {\n\t\treturn this.values.hsl;\n\t},\n\thsvArray: function () {\n\t\treturn this.values.hsv;\n\t},\n\thwbArray: function () {\n\t\tvar values = this.values;\n\t\tif (values.alpha !== 1) {\n\t\t\treturn values.hwb.concat([values.alpha]);\n\t\t}\n\t\treturn values.hwb;\n\t},\n\tcmykArray: function () {\n\t\treturn this.values.cmyk;\n\t},\n\trgbaArray: function () {\n\t\tvar values = this.values;\n\t\treturn values.rgb.concat([values.alpha]);\n\t},\n\thslaArray: function () {\n\t\tvar values = this.values;\n\t\treturn values.hsl.concat([values.alpha]);\n\t},\n\talpha: function (val) {\n\t\tif (val === undefined) {\n\t\t\treturn this.values.alpha;\n\t\t}\n\t\tthis.setValues('alpha', val);\n\t\treturn this;\n\t},\n\n\tred: function (val) {\n\t\treturn this.setChannel('rgb', 0, val);\n\t},\n\tgreen: function (val) {\n\t\treturn this.setChannel('rgb', 1, val);\n\t},\n\tblue: function (val) {\n\t\treturn this.setChannel('rgb', 2, val);\n\t},\n\thue: function (val) {\n\t\tif (val) {\n\t\t\tval %= 360;\n\t\t\tval = val < 0 ? 360 + val : val;\n\t\t}\n\t\treturn this.setChannel('hsl', 0, val);\n\t},\n\tsaturation: function (val) {\n\t\treturn this.setChannel('hsl', 1, val);\n\t},\n\tlightness: function (val) {\n\t\treturn this.setChannel('hsl', 2, val);\n\t},\n\tsaturationv: function (val) {\n\t\treturn this.setChannel('hsv', 1, val);\n\t},\n\twhiteness: function (val) {\n\t\treturn this.setChannel('hwb', 1, val);\n\t},\n\tblackness: function (val) {\n\t\treturn this.setChannel('hwb', 2, val);\n\t},\n\tvalue: function (val) {\n\t\treturn this.setChannel('hsv', 2, val);\n\t},\n\tcyan: function (val) {\n\t\treturn this.setChannel('cmyk', 0, val);\n\t},\n\tmagenta: function (val) {\n\t\treturn this.setChannel('cmyk', 1, val);\n\t},\n\tyellow: function (val) {\n\t\treturn this.setChannel('cmyk', 2, val);\n\t},\n\tblack: function (val) {\n\t\treturn this.setChannel('cmyk', 3, val);\n\t},\n\n\thexString: function () {\n\t\treturn colorString.hexString(this.values.rgb);\n\t},\n\trgbString: function () {\n\t\treturn colorString.rgbString(this.values.rgb, this.values.alpha);\n\t},\n\trgbaString: function () {\n\t\treturn colorString.rgbaString(this.values.rgb, this.values.alpha);\n\t},\n\tpercentString: function () {\n\t\treturn colorString.percentString(this.values.rgb, this.values.alpha);\n\t},\n\thslString: function () {\n\t\treturn colorString.hslString(this.values.hsl, this.values.alpha);\n\t},\n\thslaString: function () {\n\t\treturn colorString.hslaString(this.values.hsl, this.values.alpha);\n\t},\n\thwbString: function () {\n\t\treturn colorString.hwbString(this.values.hwb, this.values.alpha);\n\t},\n\tkeyword: function () {\n\t\treturn colorString.keyword(this.values.rgb, this.values.alpha);\n\t},\n\n\trgbNumber: function () {\n\t\tvar rgb = this.values.rgb;\n\t\treturn (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];\n\t},\n\n\tluminosity: function () {\n\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t\tvar rgb = this.values.rgb;\n\t\tvar lum = [];\n\t\tfor (var i = 0; i < rgb.length; i++) {\n\t\t\tvar chan = rgb[i] / 255;\n\t\t\tlum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\n\t\t}\n\t\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n\t},\n\n\tcontrast: function (color2) {\n\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n\t\tvar lum1 = this.luminosity();\n\t\tvar lum2 = color2.luminosity();\n\t\tif (lum1 > lum2) {\n\t\t\treturn (lum1 + 0.05) / (lum2 + 0.05);\n\t\t}\n\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\n\t},\n\n\tlevel: function (color2) {\n\t\tvar contrastRatio = this.contrast(color2);\n\t\tif (contrastRatio >= 7.1) {\n\t\t\treturn 'AAA';\n\t\t}\n\n\t\treturn (contrastRatio >= 4.5) ? 'AA' : '';\n\t},\n\n\tdark: function () {\n\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\n\t\tvar rgb = this.values.rgb;\n\t\tvar yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n\t\treturn yiq < 128;\n\t},\n\n\tlight: function () {\n\t\treturn !this.dark();\n\t},\n\n\tnegate: function () {\n\t\tvar rgb = [];\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\trgb[i] = 255 - this.values.rgb[i];\n\t\t}\n\t\tthis.setValues('rgb', rgb);\n\t\treturn this;\n\t},\n\n\tlighten: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[2] += hsl[2] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tdarken: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[2] -= hsl[2] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tsaturate: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[1] += hsl[1] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tdesaturate: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[1] -= hsl[1] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\twhiten: function (ratio) {\n\t\tvar hwb = this.values.hwb;\n\t\thwb[1] += hwb[1] * ratio;\n\t\tthis.setValues('hwb', hwb);\n\t\treturn this;\n\t},\n\n\tblacken: function (ratio) {\n\t\tvar hwb = this.values.hwb;\n\t\thwb[2] += hwb[2] * ratio;\n\t\tthis.setValues('hwb', hwb);\n\t\treturn this;\n\t},\n\n\tgreyscale: function () {\n\t\tvar rgb = this.values.rgb;\n\t\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\t\tvar val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n\t\tthis.setValues('rgb', [val, val, val]);\n\t\treturn this;\n\t},\n\n\tclearer: function (ratio) {\n\t\tvar alpha = this.values.alpha;\n\t\tthis.setValues('alpha', alpha - (alpha * ratio));\n\t\treturn this;\n\t},\n\n\topaquer: function (ratio) {\n\t\tvar alpha = this.values.alpha;\n\t\tthis.setValues('alpha', alpha + (alpha * ratio));\n\t\treturn this;\n\t},\n\n\trotate: function (degrees) {\n\t\tvar hsl = this.values.hsl;\n\t\tvar hue = (hsl[0] + degrees) % 360;\n\t\thsl[0] = hue < 0 ? 360 + hue : hue;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\t/**\n\t * Ported from sass implementation in C\n\t * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n\t */\n\tmix: function (mixinColor, weight) {\n\t\tvar color1 = this;\n\t\tvar color2 = mixinColor;\n\t\tvar p = weight === undefined ? 0.5 : weight;\n\n\t\tvar w = 2 * p - 1;\n\t\tvar a = color1.alpha() - color2.alpha();\n\n\t\tvar w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n\t\tvar w2 = 1 - w1;\n\n\t\treturn this\n\t\t\t.rgb(\n\t\t\t\tw1 * color1.red() + w2 * color2.red(),\n\t\t\t\tw1 * color1.green() + w2 * color2.green(),\n\t\t\t\tw1 * color1.blue() + w2 * color2.blue()\n\t\t\t)\n\t\t\t.alpha(color1.alpha() * p + color2.alpha() * (1 - p));\n\t},\n\n\ttoJSON: function () {\n\t\treturn this.rgb();\n\t},\n\n\tclone: function () {\n\t\t// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,\n\t\t// making the final build way to big to embed in Chart.js. So let's do it manually,\n\t\t// assuming that values to clone are 1 dimension arrays containing only numbers,\n\t\t// except 'alpha' which is a number.\n\t\tvar result = new Color();\n\t\tvar source = this.values;\n\t\tvar target = result.values;\n\t\tvar value, type;\n\n\t\tfor (var prop in source) {\n\t\t\tif (source.hasOwnProperty(prop)) {\n\t\t\t\tvalue = source[prop];\n\t\t\t\ttype = ({}).toString.call(value);\n\t\t\t\tif (type === '[object Array]') {\n\t\t\t\t\ttarget[prop] = value.slice(0);\n\t\t\t\t} else if (type === '[object Number]') {\n\t\t\t\t\ttarget[prop] = value;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error('unexpected color value:', value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n};\n\nColor.prototype.spaces = {\n\trgb: ['red', 'green', 'blue'],\n\thsl: ['hue', 'saturation', 'lightness'],\n\thsv: ['hue', 'saturation', 'value'],\n\thwb: ['hue', 'whiteness', 'blackness'],\n\tcmyk: ['cyan', 'magenta', 'yellow', 'black']\n};\n\nColor.prototype.maxes = {\n\trgb: [255, 255, 255],\n\thsl: [360, 100, 100],\n\thsv: [360, 100, 100],\n\thwb: [360, 100, 100],\n\tcmyk: [100, 100, 100, 100]\n};\n\nColor.prototype.getValues = function (space) {\n\tvar values = this.values;\n\tvar vals = {};\n\n\tfor (var i = 0; i < space.length; i++) {\n\t\tvals[space.charAt(i)] = values[space][i];\n\t}\n\n\tif (values.alpha !== 1) {\n\t\tvals.a = values.alpha;\n\t}\n\n\t// {r: 255, g: 255, b: 255, a: 0.4}\n\treturn vals;\n};\n\nColor.prototype.setValues = function (space, vals) {\n\tvar values = this.values;\n\tvar spaces = this.spaces;\n\tvar maxes = this.maxes;\n\tvar alpha = 1;\n\tvar i;\n\n\tthis.valid = true;\n\n\tif (space === 'alpha') {\n\t\talpha = vals;\n\t} else if (vals.length) {\n\t\t// [10, 10, 10]\n\t\tvalues[space] = vals.slice(0, space.length);\n\t\talpha = vals[space.length];\n\t} else if (vals[space.charAt(0)] !== undefined) {\n\t\t// {r: 10, g: 10, b: 10}\n\t\tfor (i = 0; i < space.length; i++) {\n\t\t\tvalues[space][i] = vals[space.charAt(i)];\n\t\t}\n\n\t\talpha = vals.a;\n\t} else if (vals[spaces[space][0]] !== undefined) {\n\t\t// {red: 10, green: 10, blue: 10}\n\t\tvar chans = spaces[space];\n\n\t\tfor (i = 0; i < space.length; i++) {\n\t\t\tvalues[space][i] = vals[chans[i]];\n\t\t}\n\n\t\talpha = vals.alpha;\n\t}\n\n\tvalues.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));\n\n\tif (space === 'alpha') {\n\t\treturn false;\n\t}\n\n\tvar capped;\n\n\t// cap values of the space prior converting all values\n\tfor (i = 0; i < space.length; i++) {\n\t\tcapped = Math.max(0, Math.min(maxes[space][i], values[space][i]));\n\t\tvalues[space][i] = Math.round(capped);\n\t}\n\n\t// convert to all the other color spaces\n\tfor (var sname in spaces) {\n\t\tif (sname !== space) {\n\t\t\tvalues[sname] = colorConvert[space][sname](values[space]);\n\t\t}\n\t}\n\n\treturn true;\n};\n\nColor.prototype.setSpace = function (space, args) {\n\tvar vals = args[0];\n\n\tif (vals === undefined) {\n\t\t// color.rgb()\n\t\treturn this.getValues(space);\n\t}\n\n\t// color.rgb(10, 10, 10)\n\tif (typeof vals === 'number') {\n\t\tvals = Array.prototype.slice.call(args);\n\t}\n\n\tthis.setValues(space, vals);\n\treturn this;\n};\n\nColor.prototype.setChannel = function (space, index, val) {\n\tvar svalues = this.values[space];\n\tif (val === undefined) {\n\t\t// color.red()\n\t\treturn svalues[index];\n\t} else if (val === svalues[index]) {\n\t\t// color.red(color.red())\n\t\treturn this;\n\t}\n\n\t// color.red(100)\n\tsvalues[index] = val;\n\tthis.setValues(space, svalues);\n\n\treturn this;\n};\n\nif (typeof window !== 'undefined') {\n\twindow.Color = Color;\n}\n\nvar chartjsColor = Color;\n\nfunction isValidKey(key) {\r\n\treturn ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\r\n}\r\n\r\n/**\r\n * @namespace Chart.helpers\r\n */\r\nvar helpers = {\r\n\t/**\r\n\t * An empty function that can be used, for example, for optional callback.\r\n\t */\r\n\tnoop: function() {},\r\n\r\n\t/**\r\n\t * Returns a unique id, sequentially generated from a global variable.\r\n\t * @returns {number}\r\n\t * @function\r\n\t */\r\n\tuid: (function() {\r\n\t\tvar id = 0;\r\n\t\treturn function() {\r\n\t\t\treturn id++;\r\n\t\t};\r\n\t}()),\r\n\r\n\t/**\r\n\t * Returns true if `value` is neither null nor undefined, else returns false.\r\n\t * @param {*} value - The value to test.\r\n\t * @returns {boolean}\r\n\t * @since 2.7.0\r\n\t */\r\n\tisNullOrUndef: function(value) {\r\n\t\treturn value === null || typeof value === 'undefined';\r\n\t},\r\n\r\n\t/**\r\n\t * Returns true if `value` is an array (including typed arrays), else returns false.\r\n\t * @param {*} value - The value to test.\r\n\t * @returns {boolean}\r\n\t * @function\r\n\t */\r\n\tisArray: function(value) {\r\n\t\tif (Array.isArray && Array.isArray(value)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tvar type = Object.prototype.toString.call(value);\r\n\t\tif (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns true if `value` is an object (excluding null), else returns false.\r\n\t * @param {*} value - The value to test.\r\n\t * @returns {boolean}\r\n\t * @since 2.7.0\r\n\t */\r\n\tisObject: function(value) {\r\n\t\treturn value !== null && Object.prototype.toString.call(value) === '[object Object]';\r\n\t},\r\n\r\n\t/**\r\n\t * Returns true if `value` is a finite number, else returns false\r\n\t * @param {*} value  - The value to test.\r\n\t * @returns {boolean}\r\n\t */\r\n\tisFinite: function(value) {\r\n\t\treturn (typeof value === 'number' || value instanceof Number) && isFinite(value);\r\n\t},\r\n\r\n\t/**\r\n\t * Returns `value` if defined, else returns `defaultValue`.\r\n\t * @param {*} value - The value to return if defined.\r\n\t * @param {*} defaultValue - The value to return if `value` is undefined.\r\n\t * @returns {*}\r\n\t */\r\n\tvalueOrDefault: function(value, defaultValue) {\r\n\t\treturn typeof value === 'undefined' ? defaultValue : value;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns value at the given `index` in array if defined, else returns `defaultValue`.\r\n\t * @param {Array} value - The array to lookup for value at `index`.\r\n\t * @param {number} index - The index in `value` to lookup for value.\r\n\t * @param {*} defaultValue - The value to return if `value[index]` is undefined.\r\n\t * @returns {*}\r\n\t */\r\n\tvalueAtIndexOrDefault: function(value, index, defaultValue) {\r\n\t\treturn helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);\r\n\t},\r\n\r\n\t/**\r\n\t * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\r\n\t * value returned by `fn`. If `fn` is not a function, this method returns undefined.\r\n\t * @param {function} fn - The function to call.\r\n\t * @param {Array|undefined|null} args - The arguments with which `fn` should be called.\r\n\t * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.\r\n\t * @returns {*}\r\n\t */\r\n\tcallback: function(fn, args, thisArg) {\r\n\t\tif (fn && typeof fn.call === 'function') {\r\n\t\t\treturn fn.apply(thisArg, args);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Note(SB) for performance sake, this method should only be used when loopable type\r\n\t * is unknown or in none intensive code (not called often and small loopable). Else\r\n\t * it's preferable to use a regular for() loop and save extra function calls.\r\n\t * @param {object|Array} loopable - The object or array to be iterated.\r\n\t * @param {function} fn - The function to call for each item.\r\n\t * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.\r\n\t * @param {boolean} [reverse] - If true, iterates backward on the loopable.\r\n\t */\r\n\teach: function(loopable, fn, thisArg, reverse) {\r\n\t\tvar i, len, keys;\r\n\t\tif (helpers.isArray(loopable)) {\r\n\t\t\tlen = loopable.length;\r\n\t\t\tif (reverse) {\r\n\t\t\t\tfor (i = len - 1; i >= 0; i--) {\r\n\t\t\t\t\tfn.call(thisArg, loopable[i], i);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor (i = 0; i < len; i++) {\r\n\t\t\t\t\tfn.call(thisArg, loopable[i], i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (helpers.isObject(loopable)) {\r\n\t\t\tkeys = Object.keys(loopable);\r\n\t\t\tlen = keys.length;\r\n\t\t\tfor (i = 0; i < len; i++) {\r\n\t\t\t\tfn.call(thisArg, loopable[keys[i]], keys[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\r\n\t * @see https://stackoverflow.com/a/14853974\r\n\t * @param {Array} a0 - The array to compare\r\n\t * @param {Array} a1 - The array to compare\r\n\t * @returns {boolean}\r\n\t */\r\n\tarrayEquals: function(a0, a1) {\r\n\t\tvar i, ilen, v0, v1;\r\n\r\n\t\tif (!a0 || !a1 || a0.length !== a1.length) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = a0.length; i < ilen; ++i) {\r\n\t\t\tv0 = a0[i];\r\n\t\t\tv1 = a1[i];\r\n\r\n\t\t\tif (v0 instanceof Array && v1 instanceof Array) {\r\n\t\t\t\tif (!helpers.arrayEquals(v0, v1)) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t} else if (v0 !== v1) {\r\n\t\t\t\t// NOTE: two different object instances will never be equal: {x:20} != {x:20}\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns a deep copy of `source` without keeping references on objects and arrays.\r\n\t * @param {*} source - The value to clone.\r\n\t * @returns {*}\r\n\t */\r\n\tclone: function(source) {\r\n\t\tif (helpers.isArray(source)) {\r\n\t\t\treturn source.map(helpers.clone);\r\n\t\t}\r\n\r\n\t\tif (helpers.isObject(source)) {\r\n\t\t\tvar target = Object.create(source);\r\n\t\t\tvar keys = Object.keys(source);\r\n\t\t\tvar klen = keys.length;\r\n\t\t\tvar k = 0;\r\n\r\n\t\t\tfor (; k < klen; ++k) {\r\n\t\t\t\ttarget[keys[k]] = helpers.clone(source[keys[k]]);\r\n\t\t\t}\r\n\r\n\t\t\treturn target;\r\n\t\t}\r\n\r\n\t\treturn source;\r\n\t},\r\n\r\n\t/**\r\n\t * The default merger when Chart.helpers.merge is called without merger option.\r\n\t * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\r\n\t * @private\r\n\t */\r\n\t_merger: function(key, target, source, options) {\r\n\t\tif (!isValidKey(key)) {\r\n\t\t\t// We want to ensure we do not copy prototypes over\r\n\t\t\t// as this can pollute global namespaces\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar tval = target[key];\r\n\t\tvar sval = source[key];\r\n\r\n\t\tif (helpers.isObject(tval) && helpers.isObject(sval)) {\r\n\t\t\thelpers.merge(tval, sval, options);\r\n\t\t} else {\r\n\t\t\ttarget[key] = helpers.clone(sval);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Merges source[key] in target[key] only if target[key] is undefined.\r\n\t * @private\r\n\t */\r\n\t_mergerIf: function(key, target, source) {\r\n\t\tif (!isValidKey(key)) {\r\n\t\t\t// We want to ensure we do not copy prototypes over\r\n\t\t\t// as this can pollute global namespaces\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar tval = target[key];\r\n\t\tvar sval = source[key];\r\n\r\n\t\tif (helpers.isObject(tval) && helpers.isObject(sval)) {\r\n\t\t\thelpers.mergeIf(tval, sval);\r\n\t\t} else if (!target.hasOwnProperty(key)) {\r\n\t\t\ttarget[key] = helpers.clone(sval);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Recursively deep copies `source` properties into `target` with the given `options`.\r\n\t * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\r\n\t * @param {object} target - The target object in which all sources are merged into.\r\n\t * @param {object|object[]} source - Object(s) to merge into `target`.\r\n\t * @param {object} [options] - Merging options:\r\n\t * @param {function} [options.merger] - The merge method (key, target, source, options)\r\n\t * @returns {object} The `target` object.\r\n\t */\r\n\tmerge: function(target, source, options) {\r\n\t\tvar sources = helpers.isArray(source) ? source : [source];\r\n\t\tvar ilen = sources.length;\r\n\t\tvar merge, i, keys, klen, k;\r\n\r\n\t\tif (!helpers.isObject(target)) {\r\n\t\t\treturn target;\r\n\t\t}\r\n\r\n\t\toptions = options || {};\r\n\t\tmerge = options.merger || helpers._merger;\r\n\r\n\t\tfor (i = 0; i < ilen; ++i) {\r\n\t\t\tsource = sources[i];\r\n\t\t\tif (!helpers.isObject(source)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tkeys = Object.keys(source);\r\n\t\t\tfor (k = 0, klen = keys.length; k < klen; ++k) {\r\n\t\t\t\tmerge(keys[k], target, source, options);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn target;\r\n\t},\r\n\r\n\t/**\r\n\t * Recursively deep copies `source` properties into `target` *only* if not defined in target.\r\n\t * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\r\n\t * @param {object} target - The target object in which all sources are merged into.\r\n\t * @param {object|object[]} source - Object(s) to merge into `target`.\r\n\t * @returns {object} The `target` object.\r\n\t */\r\n\tmergeIf: function(target, source) {\r\n\t\treturn helpers.merge(target, source, {merger: helpers._mergerIf});\r\n\t},\r\n\r\n\t/**\r\n\t * Applies the contents of two or more objects together into the first object.\r\n\t * @param {object} target - The target object in which all objects are merged into.\r\n\t * @param {object} arg1 - Object containing additional properties to merge in target.\r\n\t * @param {object} argN - Additional objects containing properties to merge in target.\r\n\t * @returns {object} The `target` object.\r\n\t */\r\n\textend: Object.assign || function(target) {\r\n\t\treturn helpers.merge(target, [].slice.call(arguments, 1), {\r\n\t\t\tmerger: function(key, dst, src) {\r\n\t\t\t\tdst[key] = src[key];\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\t/**\r\n\t * Basic javascript inheritance based on the model created in Backbone.js\r\n\t */\r\n\tinherits: function(extensions) {\r\n\t\tvar me = this;\r\n\t\tvar ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {\r\n\t\t\treturn me.apply(this, arguments);\r\n\t\t};\r\n\r\n\t\tvar Surrogate = function() {\r\n\t\t\tthis.constructor = ChartElement;\r\n\t\t};\r\n\r\n\t\tSurrogate.prototype = me.prototype;\r\n\t\tChartElement.prototype = new Surrogate();\r\n\t\tChartElement.extend = helpers.inherits;\r\n\r\n\t\tif (extensions) {\r\n\t\t\thelpers.extend(ChartElement.prototype, extensions);\r\n\t\t}\r\n\r\n\t\tChartElement.__super__ = me.prototype;\r\n\t\treturn ChartElement;\r\n\t},\r\n\r\n\t_deprecated: function(scope, value, previous, current) {\r\n\t\tif (value !== undefined) {\r\n\t\t\tconsole.warn(scope + ': \"' + previous +\r\n\t\t\t\t'\" is deprecated. Please use \"' + current + '\" instead');\r\n\t\t}\r\n\t}\r\n};\r\n\r\nvar helpers_core = helpers;\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n * Provided for backward compatibility, use Chart.helpers.callback instead.\r\n * @function Chart.helpers.callCallback\r\n * @deprecated since version 2.6.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers.callCallback = helpers.callback;\r\n\r\n/**\r\n * Provided for backward compatibility, use Array.prototype.indexOf instead.\r\n * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+\r\n * @function Chart.helpers.indexOf\r\n * @deprecated since version 2.7.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers.indexOf = function(array, item, fromIndex) {\r\n\treturn Array.prototype.indexOf.call(array, item, fromIndex);\r\n};\r\n\r\n/**\r\n * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.\r\n * @function Chart.helpers.getValueOrDefault\r\n * @deprecated since version 2.7.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers.getValueOrDefault = helpers.valueOrDefault;\r\n\r\n/**\r\n * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.\r\n * @function Chart.helpers.getValueAtIndexOrDefault\r\n * @deprecated since version 2.7.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n\n/**\r\n * Easing functions adapted from Robert Penner's easing equations.\r\n * @namespace Chart.helpers.easingEffects\r\n * @see http://www.robertpenner.com/easing/\r\n */\r\nvar effects = {\r\n\tlinear: function(t) {\r\n\t\treturn t;\r\n\t},\r\n\r\n\teaseInQuad: function(t) {\r\n\t\treturn t * t;\r\n\t},\r\n\r\n\teaseOutQuad: function(t) {\r\n\t\treturn -t * (t - 2);\r\n\t},\r\n\r\n\teaseInOutQuad: function(t) {\r\n\t\tif ((t /= 0.5) < 1) {\r\n\t\t\treturn 0.5 * t * t;\r\n\t\t}\r\n\t\treturn -0.5 * ((--t) * (t - 2) - 1);\r\n\t},\r\n\r\n\teaseInCubic: function(t) {\r\n\t\treturn t * t * t;\r\n\t},\r\n\r\n\teaseOutCubic: function(t) {\r\n\t\treturn (t = t - 1) * t * t + 1;\r\n\t},\r\n\r\n\teaseInOutCubic: function(t) {\r\n\t\tif ((t /= 0.5) < 1) {\r\n\t\t\treturn 0.5 * t * t * t;\r\n\t\t}\r\n\t\treturn 0.5 * ((t -= 2) * t * t + 2);\r\n\t},\r\n\r\n\teaseInQuart: function(t) {\r\n\t\treturn t * t * t * t;\r\n\t},\r\n\r\n\teaseOutQuart: function(t) {\r\n\t\treturn -((t = t - 1) * t * t * t - 1);\r\n\t},\r\n\r\n\teaseInOutQuart: function(t) {\r\n\t\tif ((t /= 0.5) < 1) {\r\n\t\t\treturn 0.5 * t * t * t * t;\r\n\t\t}\r\n\t\treturn -0.5 * ((t -= 2) * t * t * t - 2);\r\n\t},\r\n\r\n\teaseInQuint: function(t) {\r\n\t\treturn t * t * t * t * t;\r\n\t},\r\n\r\n\teaseOutQuint: function(t) {\r\n\t\treturn (t = t - 1) * t * t * t * t + 1;\r\n\t},\r\n\r\n\teaseInOutQuint: function(t) {\r\n\t\tif ((t /= 0.5) < 1) {\r\n\t\t\treturn 0.5 * t * t * t * t * t;\r\n\t\t}\r\n\t\treturn 0.5 * ((t -= 2) * t * t * t * t + 2);\r\n\t},\r\n\r\n\teaseInSine: function(t) {\r\n\t\treturn -Math.cos(t * (Math.PI / 2)) + 1;\r\n\t},\r\n\r\n\teaseOutSine: function(t) {\r\n\t\treturn Math.sin(t * (Math.PI / 2));\r\n\t},\r\n\r\n\teaseInOutSine: function(t) {\r\n\t\treturn -0.5 * (Math.cos(Math.PI * t) - 1);\r\n\t},\r\n\r\n\teaseInExpo: function(t) {\r\n\t\treturn (t === 0) ? 0 : Math.pow(2, 10 * (t - 1));\r\n\t},\r\n\r\n\teaseOutExpo: function(t) {\r\n\t\treturn (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1;\r\n\t},\r\n\r\n\teaseInOutExpo: function(t) {\r\n\t\tif (t === 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tif (t === 1) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tif ((t /= 0.5) < 1) {\r\n\t\t\treturn 0.5 * Math.pow(2, 10 * (t - 1));\r\n\t\t}\r\n\t\treturn 0.5 * (-Math.pow(2, -10 * --t) + 2);\r\n\t},\r\n\r\n\teaseInCirc: function(t) {\r\n\t\tif (t >= 1) {\r\n\t\t\treturn t;\r\n\t\t}\r\n\t\treturn -(Math.sqrt(1 - t * t) - 1);\r\n\t},\r\n\r\n\teaseOutCirc: function(t) {\r\n\t\treturn Math.sqrt(1 - (t = t - 1) * t);\r\n\t},\r\n\r\n\teaseInOutCirc: function(t) {\r\n\t\tif ((t /= 0.5) < 1) {\r\n\t\t\treturn -0.5 * (Math.sqrt(1 - t * t) - 1);\r\n\t\t}\r\n\t\treturn 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\r\n\t},\r\n\r\n\teaseInElastic: function(t) {\r\n\t\tvar s = 1.70158;\r\n\t\tvar p = 0;\r\n\t\tvar a = 1;\r\n\t\tif (t === 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tif (t === 1) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tif (!p) {\r\n\t\t\tp = 0.3;\r\n\t\t}\r\n\t\tif (a < 1) {\r\n\t\t\ta = 1;\r\n\t\t\ts = p / 4;\r\n\t\t} else {\r\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\r\n\t\t}\r\n\t\treturn -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\r\n\t},\r\n\r\n\teaseOutElastic: function(t) {\r\n\t\tvar s = 1.70158;\r\n\t\tvar p = 0;\r\n\t\tvar a = 1;\r\n\t\tif (t === 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tif (t === 1) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tif (!p) {\r\n\t\t\tp = 0.3;\r\n\t\t}\r\n\t\tif (a < 1) {\r\n\t\t\ta = 1;\r\n\t\t\ts = p / 4;\r\n\t\t} else {\r\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\r\n\t\t}\r\n\t\treturn a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;\r\n\t},\r\n\r\n\teaseInOutElastic: function(t) {\r\n\t\tvar s = 1.70158;\r\n\t\tvar p = 0;\r\n\t\tvar a = 1;\r\n\t\tif (t === 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tif ((t /= 0.5) === 2) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tif (!p) {\r\n\t\t\tp = 0.45;\r\n\t\t}\r\n\t\tif (a < 1) {\r\n\t\t\ta = 1;\r\n\t\t\ts = p / 4;\r\n\t\t} else {\r\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\r\n\t\t}\r\n\t\tif (t < 1) {\r\n\t\t\treturn -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\r\n\t\t}\r\n\t\treturn a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;\r\n\t},\r\n\teaseInBack: function(t) {\r\n\t\tvar s = 1.70158;\r\n\t\treturn t * t * ((s + 1) * t - s);\r\n\t},\r\n\r\n\teaseOutBack: function(t) {\r\n\t\tvar s = 1.70158;\r\n\t\treturn (t = t - 1) * t * ((s + 1) * t + s) + 1;\r\n\t},\r\n\r\n\teaseInOutBack: function(t) {\r\n\t\tvar s = 1.70158;\r\n\t\tif ((t /= 0.5) < 1) {\r\n\t\t\treturn 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\r\n\t\t}\r\n\t\treturn 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\r\n\t},\r\n\r\n\teaseInBounce: function(t) {\r\n\t\treturn 1 - effects.easeOutBounce(1 - t);\r\n\t},\r\n\r\n\teaseOutBounce: function(t) {\r\n\t\tif (t < (1 / 2.75)) {\r\n\t\t\treturn 7.5625 * t * t;\r\n\t\t}\r\n\t\tif (t < (2 / 2.75)) {\r\n\t\t\treturn 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75;\r\n\t\t}\r\n\t\tif (t < (2.5 / 2.75)) {\r\n\t\t\treturn 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;\r\n\t\t}\r\n\t\treturn 7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;\r\n\t},\r\n\r\n\teaseInOutBounce: function(t) {\r\n\t\tif (t < 0.5) {\r\n\t\t\treturn effects.easeInBounce(t * 2) * 0.5;\r\n\t\t}\r\n\t\treturn effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;\r\n\t}\r\n};\r\n\r\nvar helpers_easing = {\r\n\teffects: effects\r\n};\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n * Provided for backward compatibility, use Chart.helpers.easing.effects instead.\r\n * @function Chart.helpers.easingEffects\r\n * @deprecated since version 2.7.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers_core.easingEffects = effects;\n\nvar PI = Math.PI;\r\nvar RAD_PER_DEG = PI / 180;\r\nvar DOUBLE_PI = PI * 2;\r\nvar HALF_PI = PI / 2;\r\nvar QUARTER_PI = PI / 4;\r\nvar TWO_THIRDS_PI = PI * 2 / 3;\r\n\r\n/**\r\n * @namespace Chart.helpers.canvas\r\n */\r\nvar exports$1 = {\r\n\t/**\r\n\t * Clears the entire canvas associated to the given `chart`.\r\n\t * @param {Chart} chart - The chart for which to clear the canvas.\r\n\t */\r\n\tclear: function(chart) {\r\n\t\tchart.ctx.clearRect(0, 0, chart.width, chart.height);\r\n\t},\r\n\r\n\t/**\r\n\t * Creates a \"path\" for a rectangle with rounded corners at position (x, y) with a\r\n\t * given size (width, height) and the same `radius` for all corners.\r\n\t * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.\r\n\t * @param {number} x - The x axis of the coordinate for the rectangle starting point.\r\n\t * @param {number} y - The y axis of the coordinate for the rectangle starting point.\r\n\t * @param {number} width - The rectangle's width.\r\n\t * @param {number} height - The rectangle's height.\r\n\t * @param {number} radius - The rounded amount (in pixels) for the four corners.\r\n\t * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?\r\n\t */\r\n\troundedRect: function(ctx, x, y, width, height, radius) {\r\n\t\tif (radius) {\r\n\t\t\tvar r = Math.min(radius, height / 2, width / 2);\r\n\t\t\tvar left = x + r;\r\n\t\t\tvar top = y + r;\r\n\t\t\tvar right = x + width - r;\r\n\t\t\tvar bottom = y + height - r;\r\n\r\n\t\t\tctx.moveTo(x, top);\r\n\t\t\tif (left < right && top < bottom) {\r\n\t\t\t\tctx.arc(left, top, r, -PI, -HALF_PI);\r\n\t\t\t\tctx.arc(right, top, r, -HALF_PI, 0);\r\n\t\t\t\tctx.arc(right, bottom, r, 0, HALF_PI);\r\n\t\t\t\tctx.arc(left, bottom, r, HALF_PI, PI);\r\n\t\t\t} else if (left < right) {\r\n\t\t\t\tctx.moveTo(left, y);\r\n\t\t\t\tctx.arc(right, top, r, -HALF_PI, HALF_PI);\r\n\t\t\t\tctx.arc(left, top, r, HALF_PI, PI + HALF_PI);\r\n\t\t\t} else if (top < bottom) {\r\n\t\t\t\tctx.arc(left, top, r, -PI, 0);\r\n\t\t\t\tctx.arc(left, bottom, r, 0, PI);\r\n\t\t\t} else {\r\n\t\t\t\tctx.arc(left, top, r, -PI, PI);\r\n\t\t\t}\r\n\t\t\tctx.closePath();\r\n\t\t\tctx.moveTo(x, y);\r\n\t\t} else {\r\n\t\t\tctx.rect(x, y, width, height);\r\n\t\t}\r\n\t},\r\n\r\n\tdrawPoint: function(ctx, style, radius, x, y, rotation) {\r\n\t\tvar type, xOffset, yOffset, size, cornerRadius;\r\n\t\tvar rad = (rotation || 0) * RAD_PER_DEG;\r\n\r\n\t\tif (style && typeof style === 'object') {\r\n\t\t\ttype = style.toString();\r\n\t\t\tif (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\r\n\t\t\t\tctx.save();\r\n\t\t\t\tctx.translate(x, y);\r\n\t\t\t\tctx.rotate(rad);\r\n\t\t\t\tctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\r\n\t\t\t\tctx.restore();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (isNaN(radius) || radius <= 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tctx.beginPath();\r\n\r\n\t\tswitch (style) {\r\n\t\t// Default includes circle\r\n\t\tdefault:\r\n\t\t\tctx.arc(x, y, radius, 0, DOUBLE_PI);\r\n\t\t\tctx.closePath();\r\n\t\t\tbreak;\r\n\t\tcase 'triangle':\r\n\t\t\tctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\r\n\t\t\trad += TWO_THIRDS_PI;\r\n\t\t\tctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\r\n\t\t\trad += TWO_THIRDS_PI;\r\n\t\t\tctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\r\n\t\t\tctx.closePath();\r\n\t\t\tbreak;\r\n\t\tcase 'rectRounded':\r\n\t\t\t// NOTE: the rounded rect implementation changed to use `arc` instead of\r\n\t\t\t// `quadraticCurveTo` since it generates better results when rect is\r\n\t\t\t// almost a circle. 0.516 (instead of 0.5) produces results with visually\r\n\t\t\t// closer proportion to the previous impl and it is inscribed in the\r\n\t\t\t// circle with `radius`. For more details, see the following PRs:\r\n\t\t\t// https://github.com/chartjs/Chart.js/issues/5597\r\n\t\t\t// https://github.com/chartjs/Chart.js/issues/5858\r\n\t\t\tcornerRadius = radius * 0.516;\r\n\t\t\tsize = radius - cornerRadius;\r\n\t\t\txOffset = Math.cos(rad + QUARTER_PI) * size;\r\n\t\t\tyOffset = Math.sin(rad + QUARTER_PI) * size;\r\n\t\t\tctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\r\n\t\t\tctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\r\n\t\t\tctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\r\n\t\t\tctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\r\n\t\t\tctx.closePath();\r\n\t\t\tbreak;\r\n\t\tcase 'rect':\r\n\t\t\tif (!rotation) {\r\n\t\t\t\tsize = Math.SQRT1_2 * radius;\r\n\t\t\t\tctx.rect(x - size, y - size, 2 * size, 2 * size);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\trad += QUARTER_PI;\r\n\t\t\t/* falls through */\r\n\t\tcase 'rectRot':\r\n\t\t\txOffset = Math.cos(rad) * radius;\r\n\t\t\tyOffset = Math.sin(rad) * radius;\r\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\r\n\t\t\tctx.lineTo(x + yOffset, y - xOffset);\r\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\r\n\t\t\tctx.lineTo(x - yOffset, y + xOffset);\r\n\t\t\tctx.closePath();\r\n\t\t\tbreak;\r\n\t\tcase 'crossRot':\r\n\t\t\trad += QUARTER_PI;\r\n\t\t\t/* falls through */\r\n\t\tcase 'cross':\r\n\t\t\txOffset = Math.cos(rad) * radius;\r\n\t\t\tyOffset = Math.sin(rad) * radius;\r\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\r\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\r\n\t\t\tctx.moveTo(x + yOffset, y - xOffset);\r\n\t\t\tctx.lineTo(x - yOffset, y + xOffset);\r\n\t\t\tbreak;\r\n\t\tcase 'star':\r\n\t\t\txOffset = Math.cos(rad) * radius;\r\n\t\t\tyOffset = Math.sin(rad) * radius;\r\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\r\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\r\n\t\t\tctx.moveTo(x + yOffset, y - xOffset);\r\n\t\t\tctx.lineTo(x - yOffset, y + xOffset);\r\n\t\t\trad += QUARTER_PI;\r\n\t\t\txOffset = Math.cos(rad) * radius;\r\n\t\t\tyOffset = Math.sin(rad) * radius;\r\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\r\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\r\n\t\t\tctx.moveTo(x + yOffset, y - xOffset);\r\n\t\t\tctx.lineTo(x - yOffset, y + xOffset);\r\n\t\t\tbreak;\r\n\t\tcase 'line':\r\n\t\t\txOffset = Math.cos(rad) * radius;\r\n\t\t\tyOffset = Math.sin(rad) * radius;\r\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\r\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\r\n\t\t\tbreak;\r\n\t\tcase 'dash':\r\n\t\t\tctx.moveTo(x, y);\r\n\t\t\tctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tctx.fill();\r\n\t\tctx.stroke();\r\n\t},\r\n\r\n\t/**\r\n\t * Returns true if the point is inside the rectangle\r\n\t * @param {object} point - The point to test\r\n\t * @param {object} area - The rectangle\r\n\t * @returns {boolean}\r\n\t * @private\r\n\t */\r\n\t_isPointInArea: function(point, area) {\r\n\t\tvar epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.\r\n\r\n\t\treturn point.x > area.left - epsilon && point.x < area.right + epsilon &&\r\n\t\t\tpoint.y > area.top - epsilon && point.y < area.bottom + epsilon;\r\n\t},\r\n\r\n\tclipArea: function(ctx, area) {\r\n\t\tctx.save();\r\n\t\tctx.beginPath();\r\n\t\tctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\r\n\t\tctx.clip();\r\n\t},\r\n\r\n\tunclipArea: function(ctx) {\r\n\t\tctx.restore();\r\n\t},\r\n\r\n\tlineTo: function(ctx, previous, target, flip) {\r\n\t\tvar stepped = target.steppedLine;\r\n\t\tif (stepped) {\r\n\t\t\tif (stepped === 'middle') {\r\n\t\t\t\tvar midpoint = (previous.x + target.x) / 2.0;\r\n\t\t\t\tctx.lineTo(midpoint, flip ? target.y : previous.y);\r\n\t\t\t\tctx.lineTo(midpoint, flip ? previous.y : target.y);\r\n\t\t\t} else if ((stepped === 'after' && !flip) || (stepped !== 'after' && flip)) {\r\n\t\t\t\tctx.lineTo(previous.x, target.y);\r\n\t\t\t} else {\r\n\t\t\t\tctx.lineTo(target.x, previous.y);\r\n\t\t\t}\r\n\t\t\tctx.lineTo(target.x, target.y);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (!target.tension) {\r\n\t\t\tctx.lineTo(target.x, target.y);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tctx.bezierCurveTo(\r\n\t\t\tflip ? previous.controlPointPreviousX : previous.controlPointNextX,\r\n\t\t\tflip ? previous.controlPointPreviousY : previous.controlPointNextY,\r\n\t\t\tflip ? target.controlPointNextX : target.controlPointPreviousX,\r\n\t\t\tflip ? target.controlPointNextY : target.controlPointPreviousY,\r\n\t\t\ttarget.x,\r\n\t\t\ttarget.y);\r\n\t}\r\n};\r\n\r\nvar helpers_canvas = exports$1;\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.\r\n * @namespace Chart.helpers.clear\r\n * @deprecated since version 2.7.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers_core.clear = exports$1.clear;\r\n\r\n/**\r\n * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.\r\n * @namespace Chart.helpers.drawRoundedRectangle\r\n * @deprecated since version 2.7.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers_core.drawRoundedRectangle = function(ctx) {\r\n\tctx.beginPath();\r\n\texports$1.roundedRect.apply(exports$1, arguments);\r\n};\n\nvar defaults = {\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_set: function(scope, values) {\r\n\t\treturn helpers_core.merge(this[scope] || (this[scope] = {}), values);\r\n\t}\r\n};\r\n\r\n// TODO(v3): remove 'global' from namespace.  all default are global and\r\n// there's inconsistency around which options are under 'global'\r\ndefaults._set('global', {\r\n\tdefaultColor: 'rgba(0,0,0,0.1)',\r\n\tdefaultFontColor: '#666',\r\n\tdefaultFontFamily: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\r\n\tdefaultFontSize: 12,\r\n\tdefaultFontStyle: 'normal',\r\n\tdefaultLineHeight: 1.2,\r\n\tshowLines: true\r\n});\r\n\r\nvar core_defaults = defaults;\n\nvar valueOrDefault = helpers_core.valueOrDefault;\r\n\r\n/**\r\n * Converts the given font object into a CSS font string.\r\n * @param {object} font - A font object.\r\n * @return {string} The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\r\n * @private\r\n */\r\nfunction toFontString(font) {\r\n\tif (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\treturn (font.style ? font.style + ' ' : '')\r\n\t\t+ (font.weight ? font.weight + ' ' : '')\r\n\t\t+ font.size + 'px '\r\n\t\t+ font.family;\r\n}\r\n\r\n/**\r\n * @alias Chart.helpers.options\r\n * @namespace\r\n */\r\nvar helpers_options = {\r\n\t/**\r\n\t * Converts the given line height `value` in pixels for a specific font `size`.\r\n\t * @param {number|string} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\r\n\t * @param {number} size - The font size (in pixels) used to resolve relative `value`.\r\n\t * @returns {number} The effective line height in pixels (size * 1.2 if value is invalid).\r\n\t * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\r\n\t * @since 2.7.0\r\n\t */\r\n\ttoLineHeight: function(value, size) {\r\n\t\tvar matches = ('' + value).match(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\r\n\t\tif (!matches || matches[1] === 'normal') {\r\n\t\t\treturn size * 1.2;\r\n\t\t}\r\n\r\n\t\tvalue = +matches[2];\r\n\r\n\t\tswitch (matches[3]) {\r\n\t\tcase 'px':\r\n\t\t\treturn value;\r\n\t\tcase '%':\r\n\t\t\tvalue /= 100;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\treturn size * value;\r\n\t},\r\n\r\n\t/**\r\n\t * Converts the given value into a padding object with pre-computed width/height.\r\n\t * @param {number|object} value - If a number, set the value to all TRBL component,\r\n\t *  else, if and object, use defined properties and sets undefined ones to 0.\r\n\t * @returns {object} The padding values (top, right, bottom, left, width, height)\r\n\t * @since 2.7.0\r\n\t */\r\n\ttoPadding: function(value) {\r\n\t\tvar t, r, b, l;\r\n\r\n\t\tif (helpers_core.isObject(value)) {\r\n\t\t\tt = +value.top || 0;\r\n\t\t\tr = +value.right || 0;\r\n\t\t\tb = +value.bottom || 0;\r\n\t\t\tl = +value.left || 0;\r\n\t\t} else {\r\n\t\t\tt = r = b = l = +value || 0;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttop: t,\r\n\t\t\tright: r,\r\n\t\t\tbottom: b,\r\n\t\t\tleft: l,\r\n\t\t\theight: t + b,\r\n\t\t\twidth: l + r\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Parses font options and returns the font object.\r\n\t * @param {object} options - A object that contains font options to be parsed.\r\n\t * @return {object} The font object.\r\n\t * @todo Support font.* options and renamed to toFont().\r\n\t * @private\r\n\t */\r\n\t_parseFont: function(options) {\r\n\t\tvar globalDefaults = core_defaults.global;\r\n\t\tvar size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\r\n\t\tvar font = {\r\n\t\t\tfamily: valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily),\r\n\t\t\tlineHeight: helpers_core.options.toLineHeight(valueOrDefault(options.lineHeight, globalDefaults.defaultLineHeight), size),\r\n\t\t\tsize: size,\r\n\t\t\tstyle: valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle),\r\n\t\t\tweight: null,\r\n\t\t\tstring: ''\r\n\t\t};\r\n\r\n\t\tfont.string = toFontString(font);\r\n\t\treturn font;\r\n\t},\r\n\r\n\t/**\r\n\t * Evaluates the given `inputs` sequentially and returns the first defined value.\r\n\t * @param {Array} inputs - An array of values, falling back to the last value.\r\n\t * @param {object} [context] - If defined and the current value is a function, the value\r\n\t * is called with `context` as first argument and the result becomes the new input.\r\n\t * @param {number} [index] - If defined and the current value is an array, the value\r\n\t * at `index` become the new input.\r\n\t * @param {object} [info] - object to return information about resolution in\r\n\t * @param {boolean} [info.cacheable] - Will be set to `false` if option is not cacheable.\r\n\t * @since 2.7.0\r\n\t */\r\n\tresolve: function(inputs, context, index, info) {\r\n\t\tvar cacheable = true;\r\n\t\tvar i, ilen, value;\r\n\r\n\t\tfor (i = 0, ilen = inputs.length; i < ilen; ++i) {\r\n\t\t\tvalue = inputs[i];\r\n\t\t\tif (value === undefined) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (context !== undefined && typeof value === 'function') {\r\n\t\t\t\tvalue = value(context);\r\n\t\t\t\tcacheable = false;\r\n\t\t\t}\r\n\t\t\tif (index !== undefined && helpers_core.isArray(value)) {\r\n\t\t\t\tvalue = value[index];\r\n\t\t\t\tcacheable = false;\r\n\t\t\t}\r\n\t\t\tif (value !== undefined) {\r\n\t\t\t\tif (info && !cacheable) {\r\n\t\t\t\t\tinfo.cacheable = false;\r\n\t\t\t\t}\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\n\n/**\r\n * @alias Chart.helpers.math\r\n * @namespace\r\n */\r\nvar exports$2 = {\r\n\t/**\r\n\t * Returns an array of factors sorted from 1 to sqrt(value)\r\n\t * @private\r\n\t */\r\n\t_factorize: function(value) {\r\n\t\tvar result = [];\r\n\t\tvar sqrt = Math.sqrt(value);\r\n\t\tvar i;\r\n\r\n\t\tfor (i = 1; i < sqrt; i++) {\r\n\t\t\tif (value % i === 0) {\r\n\t\t\t\tresult.push(i);\r\n\t\t\t\tresult.push(value / i);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (sqrt === (sqrt | 0)) { // if value is a square number\r\n\t\t\tresult.push(sqrt);\r\n\t\t}\r\n\r\n\t\tresult.sort(function(a, b) {\r\n\t\t\treturn a - b;\r\n\t\t}).pop();\r\n\t\treturn result;\r\n\t},\r\n\r\n\tlog10: Math.log10 || function(x) {\r\n\t\tvar exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.\r\n\t\t// Check for whole powers of 10,\r\n\t\t// which due to floating point rounding error should be corrected.\r\n\t\tvar powerOf10 = Math.round(exponent);\r\n\t\tvar isPowerOf10 = x === Math.pow(10, powerOf10);\r\n\r\n\t\treturn isPowerOf10 ? powerOf10 : exponent;\r\n\t}\r\n};\r\n\r\nvar helpers_math = exports$2;\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n * Provided for backward compatibility, use Chart.helpers.math.log10 instead.\r\n * @namespace Chart.helpers.log10\r\n * @deprecated since version 2.9.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers_core.log10 = exports$2.log10;\n\nvar getRtlAdapter = function(rectX, width) {\r\n\treturn {\r\n\t\tx: function(x) {\r\n\t\t\treturn rectX + rectX + width - x;\r\n\t\t},\r\n\t\tsetWidth: function(w) {\r\n\t\t\twidth = w;\r\n\t\t},\r\n\t\ttextAlign: function(align) {\r\n\t\t\tif (align === 'center') {\r\n\t\t\t\treturn align;\r\n\t\t\t}\r\n\t\t\treturn align === 'right' ? 'left' : 'right';\r\n\t\t},\r\n\t\txPlus: function(x, value) {\r\n\t\t\treturn x - value;\r\n\t\t},\r\n\t\tleftForLtr: function(x, itemWidth) {\r\n\t\t\treturn x - itemWidth;\r\n\t\t},\r\n\t};\r\n};\r\n\r\nvar getLtrAdapter = function() {\r\n\treturn {\r\n\t\tx: function(x) {\r\n\t\t\treturn x;\r\n\t\t},\r\n\t\tsetWidth: function(w) { // eslint-disable-line no-unused-vars\r\n\t\t},\r\n\t\ttextAlign: function(align) {\r\n\t\t\treturn align;\r\n\t\t},\r\n\t\txPlus: function(x, value) {\r\n\t\t\treturn x + value;\r\n\t\t},\r\n\t\tleftForLtr: function(x, _itemWidth) { // eslint-disable-line no-unused-vars\r\n\t\t\treturn x;\r\n\t\t},\r\n\t};\r\n};\r\n\r\nvar getAdapter = function(rtl, rectX, width) {\r\n\treturn rtl ? getRtlAdapter(rectX, width) : getLtrAdapter();\r\n};\r\n\r\nvar overrideTextDirection = function(ctx, direction) {\r\n\tvar style, original;\r\n\tif (direction === 'ltr' || direction === 'rtl') {\r\n\t\tstyle = ctx.canvas.style;\r\n\t\toriginal = [\r\n\t\t\tstyle.getPropertyValue('direction'),\r\n\t\t\tstyle.getPropertyPriority('direction'),\r\n\t\t];\r\n\r\n\t\tstyle.setProperty('direction', direction, 'important');\r\n\t\tctx.prevTextDirection = original;\r\n\t}\r\n};\r\n\r\nvar restoreTextDirection = function(ctx) {\r\n\tvar original = ctx.prevTextDirection;\r\n\tif (original !== undefined) {\r\n\t\tdelete ctx.prevTextDirection;\r\n\t\tctx.canvas.style.setProperty('direction', original[0], original[1]);\r\n\t}\r\n};\r\n\r\nvar helpers_rtl = {\r\n\tgetRtlAdapter: getAdapter,\r\n\toverrideTextDirection: overrideTextDirection,\r\n\trestoreTextDirection: restoreTextDirection,\r\n};\n\nvar helpers$1 = helpers_core;\r\nvar easing = helpers_easing;\r\nvar canvas = helpers_canvas;\r\nvar options = helpers_options;\r\nvar math = helpers_math;\r\nvar rtl = helpers_rtl;\nhelpers$1.easing = easing;\nhelpers$1.canvas = canvas;\nhelpers$1.options = options;\nhelpers$1.math = math;\nhelpers$1.rtl = rtl;\n\nfunction interpolate(start, view, model, ease) {\r\n\tvar keys = Object.keys(model);\r\n\tvar i, ilen, key, actual, origin, target, type, c0, c1;\r\n\r\n\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\r\n\t\tkey = keys[i];\r\n\r\n\t\ttarget = model[key];\r\n\r\n\t\t// if a value is added to the model after pivot() has been called, the view\r\n\t\t// doesn't contain it, so let's initialize the view to the target value.\r\n\t\tif (!view.hasOwnProperty(key)) {\r\n\t\t\tview[key] = target;\r\n\t\t}\r\n\r\n\t\tactual = view[key];\r\n\r\n\t\tif (actual === target || key[0] === '_') {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (!start.hasOwnProperty(key)) {\r\n\t\t\tstart[key] = actual;\r\n\t\t}\r\n\r\n\t\torigin = start[key];\r\n\r\n\t\ttype = typeof target;\r\n\r\n\t\tif (type === typeof origin) {\r\n\t\t\tif (type === 'string') {\r\n\t\t\t\tc0 = chartjsColor(origin);\r\n\t\t\t\tif (c0.valid) {\r\n\t\t\t\t\tc1 = chartjsColor(target);\r\n\t\t\t\t\tif (c1.valid) {\r\n\t\t\t\t\t\tview[key] = c1.mix(c0, ease).rgbString();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {\r\n\t\t\t\tview[key] = origin + (target - origin) * ease;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tview[key] = target;\r\n\t}\r\n}\r\n\r\nvar Element = function(configuration) {\r\n\thelpers$1.extend(this, configuration);\r\n\tthis.initialize.apply(this, arguments);\r\n};\r\n\r\nhelpers$1.extend(Element.prototype, {\r\n\t_type: undefined,\r\n\r\n\tinitialize: function() {\r\n\t\tthis.hidden = false;\r\n\t},\r\n\r\n\tpivot: function() {\r\n\t\tvar me = this;\r\n\t\tif (!me._view) {\r\n\t\t\tme._view = helpers$1.extend({}, me._model);\r\n\t\t}\r\n\t\tme._start = {};\r\n\t\treturn me;\r\n\t},\r\n\r\n\ttransition: function(ease) {\r\n\t\tvar me = this;\r\n\t\tvar model = me._model;\r\n\t\tvar start = me._start;\r\n\t\tvar view = me._view;\r\n\r\n\t\t// No animation -> No Transition\r\n\t\tif (!model || ease === 1) {\r\n\t\t\tme._view = helpers$1.extend({}, model);\r\n\t\t\tme._start = null;\r\n\t\t\treturn me;\r\n\t\t}\r\n\r\n\t\tif (!view) {\r\n\t\t\tview = me._view = {};\r\n\t\t}\r\n\r\n\t\tif (!start) {\r\n\t\t\tstart = me._start = {};\r\n\t\t}\r\n\r\n\t\tinterpolate(start, view, model, ease);\r\n\r\n\t\treturn me;\r\n\t},\r\n\r\n\ttooltipPosition: function() {\r\n\t\treturn {\r\n\t\t\tx: this._model.x,\r\n\t\t\ty: this._model.y\r\n\t\t};\r\n\t},\r\n\r\n\thasValue: function() {\r\n\t\treturn helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);\r\n\t}\r\n});\r\n\r\nElement.extend = helpers$1.inherits;\r\n\r\nvar core_element = Element;\n\nvar exports$3 = core_element.extend({\r\n\tchart: null, // the animation associated chart instance\r\n\tcurrentStep: 0, // the current animation step\r\n\tnumSteps: 60, // default number of steps\r\n\teasing: '', // the easing to use for this animation\r\n\trender: null, // render function used by the animation service\r\n\r\n\tonAnimationProgress: null, // user specified callback to fire on each step of the animation\r\n\tonAnimationComplete: null, // user specified callback to fire when the animation finishes\r\n});\r\n\r\nvar core_animation = exports$3;\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n * Provided for backward compatibility, use Chart.Animation instead\r\n * @prop Chart.Animation#animationObject\r\n * @deprecated since version 2.6.0\r\n * @todo remove at version 3\r\n */\r\nObject.defineProperty(exports$3.prototype, 'animationObject', {\r\n\tget: function() {\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\n/**\r\n * Provided for backward compatibility, use Chart.Animation#chart instead\r\n * @prop Chart.Animation#chartInstance\r\n * @deprecated since version 2.6.0\r\n * @todo remove at version 3\r\n */\r\nObject.defineProperty(exports$3.prototype, 'chartInstance', {\r\n\tget: function() {\r\n\t\treturn this.chart;\r\n\t},\r\n\tset: function(value) {\r\n\t\tthis.chart = value;\r\n\t}\r\n});\n\ncore_defaults._set('global', {\r\n\tanimation: {\r\n\t\tduration: 1000,\r\n\t\teasing: 'easeOutQuart',\r\n\t\tonProgress: helpers$1.noop,\r\n\t\tonComplete: helpers$1.noop\r\n\t}\r\n});\r\n\r\nvar core_animations = {\r\n\tanimations: [],\r\n\trequest: null,\r\n\r\n\t/**\r\n\t * @param {Chart} chart - The chart to animate.\r\n\t * @param {Chart.Animation} animation - The animation that we will animate.\r\n\t * @param {number} duration - The animation duration in ms.\r\n\t * @param {boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions\r\n\t */\r\n\taddAnimation: function(chart, animation, duration, lazy) {\r\n\t\tvar animations = this.animations;\r\n\t\tvar i, ilen;\r\n\r\n\t\tanimation.chart = chart;\r\n\t\tanimation.startTime = Date.now();\r\n\t\tanimation.duration = duration;\r\n\r\n\t\tif (!lazy) {\r\n\t\t\tchart.animating = true;\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = animations.length; i < ilen; ++i) {\r\n\t\t\tif (animations[i].chart === chart) {\r\n\t\t\t\tanimations[i] = animation;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tanimations.push(animation);\r\n\r\n\t\t// If there are no animations queued, manually kickstart a digest, for lack of a better word\r\n\t\tif (animations.length === 1) {\r\n\t\t\tthis.requestAnimationFrame();\r\n\t\t}\r\n\t},\r\n\r\n\tcancelAnimation: function(chart) {\r\n\t\tvar index = helpers$1.findIndex(this.animations, function(animation) {\r\n\t\t\treturn animation.chart === chart;\r\n\t\t});\r\n\r\n\t\tif (index !== -1) {\r\n\t\t\tthis.animations.splice(index, 1);\r\n\t\t\tchart.animating = false;\r\n\t\t}\r\n\t},\r\n\r\n\trequestAnimationFrame: function() {\r\n\t\tvar me = this;\r\n\t\tif (me.request === null) {\r\n\t\t\t// Skip animation frame requests until the active one is executed.\r\n\t\t\t// This can happen when processing mouse events, e.g. 'mousemove'\r\n\t\t\t// and 'mouseout' events will trigger multiple renders.\r\n\t\t\tme.request = helpers$1.requestAnimFrame.call(window, function() {\r\n\t\t\t\tme.request = null;\r\n\t\t\t\tme.startDigest();\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tstartDigest: function() {\r\n\t\tvar me = this;\r\n\r\n\t\tme.advance();\r\n\r\n\t\t// Do we have more stuff to animate?\r\n\t\tif (me.animations.length > 0) {\r\n\t\t\tme.requestAnimationFrame();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tadvance: function() {\r\n\t\tvar animations = this.animations;\r\n\t\tvar animation, chart, numSteps, nextStep;\r\n\t\tvar i = 0;\r\n\r\n\t\t// 1 animation per chart, so we are looping charts here\r\n\t\twhile (i < animations.length) {\r\n\t\t\tanimation = animations[i];\r\n\t\t\tchart = animation.chart;\r\n\t\t\tnumSteps = animation.numSteps;\r\n\r\n\t\t\t// Make sure that currentStep starts at 1\r\n\t\t\t// https://github.com/chartjs/Chart.js/issues/6104\r\n\t\t\tnextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;\r\n\t\t\tanimation.currentStep = Math.min(nextStep, numSteps);\r\n\r\n\t\t\thelpers$1.callback(animation.render, [chart, animation], chart);\r\n\t\t\thelpers$1.callback(animation.onAnimationProgress, [animation], chart);\r\n\r\n\t\t\tif (animation.currentStep >= numSteps) {\r\n\t\t\t\thelpers$1.callback(animation.onAnimationComplete, [animation], chart);\r\n\t\t\t\tchart.animating = false;\r\n\t\t\t\tanimations.splice(i, 1);\r\n\t\t\t} else {\r\n\t\t\t\t++i;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\n\nvar resolve = helpers$1.options.resolve;\r\n\r\nvar arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\r\n\r\n/**\r\n * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\r\n * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\r\n * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.\r\n */\r\nfunction listenArrayEvents(array, listener) {\r\n\tif (array._chartjs) {\r\n\t\tarray._chartjs.listeners.push(listener);\r\n\t\treturn;\r\n\t}\r\n\r\n\tObject.defineProperty(array, '_chartjs', {\r\n\t\tconfigurable: true,\r\n\t\tenumerable: false,\r\n\t\tvalue: {\r\n\t\t\tlisteners: [listener]\r\n\t\t}\r\n\t});\r\n\r\n\tarrayEvents.forEach(function(key) {\r\n\t\tvar method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);\r\n\t\tvar base = array[key];\r\n\r\n\t\tObject.defineProperty(array, key, {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: false,\r\n\t\t\tvalue: function() {\r\n\t\t\t\tvar args = Array.prototype.slice.call(arguments);\r\n\t\t\t\tvar res = base.apply(this, args);\r\n\r\n\t\t\t\thelpers$1.each(array._chartjs.listeners, function(object) {\r\n\t\t\t\t\tif (typeof object[method] === 'function') {\r\n\t\t\t\t\t\tobject[method].apply(object, args);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn res;\r\n\t\t\t}\r\n\t\t});\r\n\t});\r\n}\r\n\r\n/**\r\n * Removes the given array event listener and cleanup extra attached properties (such as\r\n * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\r\n */\r\nfunction unlistenArrayEvents(array, listener) {\r\n\tvar stub = array._chartjs;\r\n\tif (!stub) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tvar listeners = stub.listeners;\r\n\tvar index = listeners.indexOf(listener);\r\n\tif (index !== -1) {\r\n\t\tlisteners.splice(index, 1);\r\n\t}\r\n\r\n\tif (listeners.length > 0) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tarrayEvents.forEach(function(key) {\r\n\t\tdelete array[key];\r\n\t});\r\n\r\n\tdelete array._chartjs;\r\n}\r\n\r\n// Base class for all dataset controllers (line, bar, etc)\r\nvar DatasetController = function(chart, datasetIndex) {\r\n\tthis.initialize(chart, datasetIndex);\r\n};\r\n\r\nhelpers$1.extend(DatasetController.prototype, {\r\n\r\n\t/**\r\n\t * Element type used to generate a meta dataset (e.g. Chart.element.Line).\r\n\t * @type {Chart.core.element}\r\n\t */\r\n\tdatasetElementType: null,\r\n\r\n\t/**\r\n\t * Element type used to generate a meta data (e.g. Chart.element.Point).\r\n\t * @type {Chart.core.element}\r\n\t */\r\n\tdataElementType: null,\r\n\r\n\t/**\r\n\t * Dataset element option keys to be resolved in _resolveDatasetElementOptions.\r\n\t * A derived controller may override this to resolve controller-specific options.\r\n\t * The keys defined here are for backward compatibility for legend styles.\r\n\t * @private\r\n\t */\r\n\t_datasetElementOptions: [\r\n\t\t'backgroundColor',\r\n\t\t'borderCapStyle',\r\n\t\t'borderColor',\r\n\t\t'borderDash',\r\n\t\t'borderDashOffset',\r\n\t\t'borderJoinStyle',\r\n\t\t'borderWidth'\r\n\t],\r\n\r\n\t/**\r\n\t * Data element option keys to be resolved in _resolveDataElementOptions.\r\n\t * A derived controller may override this to resolve controller-specific options.\r\n\t * The keys defined here are for backward compatibility for legend styles.\r\n\t * @private\r\n\t */\r\n\t_dataElementOptions: [\r\n\t\t'backgroundColor',\r\n\t\t'borderColor',\r\n\t\t'borderWidth',\r\n\t\t'pointStyle'\r\n\t],\r\n\r\n\tinitialize: function(chart, datasetIndex) {\r\n\t\tvar me = this;\r\n\t\tme.chart = chart;\r\n\t\tme.index = datasetIndex;\r\n\t\tme.linkScales();\r\n\t\tme.addElements();\r\n\t\tme._type = me.getMeta().type;\r\n\t},\r\n\r\n\tupdateIndex: function(datasetIndex) {\r\n\t\tthis.index = datasetIndex;\r\n\t},\r\n\r\n\tlinkScales: function() {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar chart = me.chart;\r\n\t\tvar scales = chart.scales;\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar scalesOpts = chart.options.scales;\r\n\r\n\t\tif (meta.xAxisID === null || !(meta.xAxisID in scales) || dataset.xAxisID) {\r\n\t\t\tmeta.xAxisID = dataset.xAxisID || scalesOpts.xAxes[0].id;\r\n\t\t}\r\n\t\tif (meta.yAxisID === null || !(meta.yAxisID in scales) || dataset.yAxisID) {\r\n\t\t\tmeta.yAxisID = dataset.yAxisID || scalesOpts.yAxes[0].id;\r\n\t\t}\r\n\t},\r\n\r\n\tgetDataset: function() {\r\n\t\treturn this.chart.data.datasets[this.index];\r\n\t},\r\n\r\n\tgetMeta: function() {\r\n\t\treturn this.chart.getDatasetMeta(this.index);\r\n\t},\r\n\r\n\tgetScaleForId: function(scaleID) {\r\n\t\treturn this.chart.scales[scaleID];\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getValueScaleId: function() {\r\n\t\treturn this.getMeta().yAxisID;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getIndexScaleId: function() {\r\n\t\treturn this.getMeta().xAxisID;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getValueScale: function() {\r\n\t\treturn this.getScaleForId(this._getValueScaleId());\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getIndexScale: function() {\r\n\t\treturn this.getScaleForId(this._getIndexScaleId());\r\n\t},\r\n\r\n\treset: function() {\r\n\t\tthis._update(true);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tdestroy: function() {\r\n\t\tif (this._data) {\r\n\t\t\tunlistenArrayEvents(this._data, this);\r\n\t\t}\r\n\t},\r\n\r\n\tcreateMetaDataset: function() {\r\n\t\tvar me = this;\r\n\t\tvar type = me.datasetElementType;\r\n\t\treturn type && new type({\r\n\t\t\t_chart: me.chart,\r\n\t\t\t_datasetIndex: me.index\r\n\t\t});\r\n\t},\r\n\r\n\tcreateMetaData: function(index) {\r\n\t\tvar me = this;\r\n\t\tvar type = me.dataElementType;\r\n\t\treturn type && new type({\r\n\t\t\t_chart: me.chart,\r\n\t\t\t_datasetIndex: me.index,\r\n\t\t\t_index: index\r\n\t\t});\r\n\t},\r\n\r\n\taddElements: function() {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar data = me.getDataset().data || [];\r\n\t\tvar metaData = meta.data;\r\n\t\tvar i, ilen;\r\n\r\n\t\tfor (i = 0, ilen = data.length; i < ilen; ++i) {\r\n\t\t\tmetaData[i] = metaData[i] || me.createMetaData(i);\r\n\t\t}\r\n\r\n\t\tmeta.dataset = meta.dataset || me.createMetaDataset();\r\n\t},\r\n\r\n\taddElementAndReset: function(index) {\r\n\t\tvar element = this.createMetaData(index);\r\n\t\tthis.getMeta().data.splice(index, 0, element);\r\n\t\tthis.updateElement(element, index, true);\r\n\t},\r\n\r\n\tbuildOrUpdateElements: function() {\r\n\t\tvar me = this;\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar data = dataset.data || (dataset.data = []);\r\n\r\n\t\t// In order to correctly handle data addition/deletion animation (an thus simulate\r\n\t\t// real-time charts), we need to monitor these data modifications and synchronize\r\n\t\t// the internal meta data accordingly.\r\n\t\tif (me._data !== data) {\r\n\t\t\tif (me._data) {\r\n\t\t\t\t// This case happens when the user replaced the data array instance.\r\n\t\t\t\tunlistenArrayEvents(me._data, me);\r\n\t\t\t}\r\n\r\n\t\t\tif (data && Object.isExtensible(data)) {\r\n\t\t\t\tlistenArrayEvents(data, me);\r\n\t\t\t}\r\n\t\t\tme._data = data;\r\n\t\t}\r\n\r\n\t\t// Re-sync meta data in case the user replaced the data array or if we missed\r\n\t\t// any updates and so make sure that we handle number of datapoints changing.\r\n\t\tme.resyncElements();\r\n\t},\r\n\r\n\t/**\r\n\t * Returns the merged user-supplied and default dataset-level options\r\n\t * @private\r\n\t */\r\n\t_configure: function() {\r\n\t\tvar me = this;\r\n\t\tme._config = helpers$1.merge(Object.create(null), [\r\n\t\t\tme.chart.options.datasets[me._type],\r\n\t\t\tme.getDataset(),\r\n\t\t], {\r\n\t\t\tmerger: function(key, target, source) {\r\n\t\t\t\tif (key !== '_meta' && key !== 'data') {\r\n\t\t\t\t\thelpers$1._merger(key, target, source);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\t_update: function(reset) {\r\n\t\tvar me = this;\r\n\t\tme._configure();\r\n\t\tme._cachedDataOpts = null;\r\n\t\tme.update(reset);\r\n\t},\r\n\r\n\tupdate: helpers$1.noop,\r\n\r\n\ttransition: function(easingValue) {\r\n\t\tvar meta = this.getMeta();\r\n\t\tvar elements = meta.data || [];\r\n\t\tvar ilen = elements.length;\r\n\t\tvar i = 0;\r\n\r\n\t\tfor (; i < ilen; ++i) {\r\n\t\t\telements[i].transition(easingValue);\r\n\t\t}\r\n\r\n\t\tif (meta.dataset) {\r\n\t\t\tmeta.dataset.transition(easingValue);\r\n\t\t}\r\n\t},\r\n\r\n\tdraw: function() {\r\n\t\tvar meta = this.getMeta();\r\n\t\tvar elements = meta.data || [];\r\n\t\tvar ilen = elements.length;\r\n\t\tvar i = 0;\r\n\r\n\t\tif (meta.dataset) {\r\n\t\t\tmeta.dataset.draw();\r\n\t\t}\r\n\r\n\t\tfor (; i < ilen; ++i) {\r\n\t\t\telements[i].draw();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Returns a set of predefined style properties that should be used to represent the dataset\r\n\t * or the data if the index is specified\r\n\t * @param {number} index - data index\r\n\t * @return {IStyleInterface} style object\r\n\t */\r\n\tgetStyle: function(index) {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar dataset = meta.dataset;\r\n\t\tvar style;\r\n\r\n\t\tme._configure();\r\n\t\tif (dataset && index === undefined) {\r\n\t\t\tstyle = me._resolveDatasetElementOptions(dataset || {});\r\n\t\t} else {\r\n\t\t\tindex = index || 0;\r\n\t\t\tstyle = me._resolveDataElementOptions(meta.data[index] || {}, index);\r\n\t\t}\r\n\r\n\t\tif (style.fill === false || style.fill === null) {\r\n\t\t\tstyle.backgroundColor = style.borderColor;\r\n\t\t}\r\n\r\n\t\treturn style;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_resolveDatasetElementOptions: function(element, hover) {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar datasetOpts = me._config;\r\n\t\tvar custom = element.custom || {};\r\n\t\tvar options = chart.options.elements[me.datasetElementType.prototype._type] || {};\r\n\t\tvar elementOptions = me._datasetElementOptions;\r\n\t\tvar values = {};\r\n\t\tvar i, ilen, key, readKey;\r\n\r\n\t\t// Scriptable options\r\n\t\tvar context = {\r\n\t\t\tchart: chart,\r\n\t\t\tdataset: me.getDataset(),\r\n\t\t\tdatasetIndex: me.index,\r\n\t\t\thover: hover\r\n\t\t};\r\n\r\n\t\tfor (i = 0, ilen = elementOptions.length; i < ilen; ++i) {\r\n\t\t\tkey = elementOptions[i];\r\n\t\t\treadKey = hover ? 'hover' + key.charAt(0).toUpperCase() + key.slice(1) : key;\r\n\t\t\tvalues[key] = resolve([\r\n\t\t\t\tcustom[readKey],\r\n\t\t\t\tdatasetOpts[readKey],\r\n\t\t\t\toptions[readKey]\r\n\t\t\t], context);\r\n\t\t}\r\n\r\n\t\treturn values;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_resolveDataElementOptions: function(element, index) {\r\n\t\tvar me = this;\r\n\t\tvar custom = element && element.custom;\r\n\t\tvar cached = me._cachedDataOpts;\r\n\t\tif (cached && !custom) {\r\n\t\t\treturn cached;\r\n\t\t}\r\n\t\tvar chart = me.chart;\r\n\t\tvar datasetOpts = me._config;\r\n\t\tvar options = chart.options.elements[me.dataElementType.prototype._type] || {};\r\n\t\tvar elementOptions = me._dataElementOptions;\r\n\t\tvar values = {};\r\n\r\n\t\t// Scriptable options\r\n\t\tvar context = {\r\n\t\t\tchart: chart,\r\n\t\t\tdataIndex: index,\r\n\t\t\tdataset: me.getDataset(),\r\n\t\t\tdatasetIndex: me.index\r\n\t\t};\r\n\r\n\t\t// `resolve` sets cacheable to `false` if any option is indexed or scripted\r\n\t\tvar info = {cacheable: !custom};\r\n\r\n\t\tvar keys, i, ilen, key;\r\n\r\n\t\tcustom = custom || {};\r\n\r\n\t\tif (helpers$1.isArray(elementOptions)) {\r\n\t\t\tfor (i = 0, ilen = elementOptions.length; i < ilen; ++i) {\r\n\t\t\t\tkey = elementOptions[i];\r\n\t\t\t\tvalues[key] = resolve([\r\n\t\t\t\t\tcustom[key],\r\n\t\t\t\t\tdatasetOpts[key],\r\n\t\t\t\t\toptions[key]\r\n\t\t\t\t], context, index, info);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tkeys = Object.keys(elementOptions);\r\n\t\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\r\n\t\t\t\tkey = keys[i];\r\n\t\t\t\tvalues[key] = resolve([\r\n\t\t\t\t\tcustom[key],\r\n\t\t\t\t\tdatasetOpts[elementOptions[key]],\r\n\t\t\t\t\tdatasetOpts[key],\r\n\t\t\t\t\toptions[key]\r\n\t\t\t\t], context, index, info);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (info.cacheable) {\r\n\t\t\tme._cachedDataOpts = Object.freeze(values);\r\n\t\t}\r\n\r\n\t\treturn values;\r\n\t},\r\n\r\n\tremoveHoverStyle: function(element) {\r\n\t\thelpers$1.merge(element._model, element.$previousStyle || {});\r\n\t\tdelete element.$previousStyle;\r\n\t},\r\n\r\n\tsetHoverStyle: function(element) {\r\n\t\tvar dataset = this.chart.data.datasets[element._datasetIndex];\r\n\t\tvar index = element._index;\r\n\t\tvar custom = element.custom || {};\r\n\t\tvar model = element._model;\r\n\t\tvar getHoverColor = helpers$1.getHoverColor;\r\n\r\n\t\telement.$previousStyle = {\r\n\t\t\tbackgroundColor: model.backgroundColor,\r\n\t\t\tborderColor: model.borderColor,\r\n\t\t\tborderWidth: model.borderWidth\r\n\t\t};\r\n\r\n\t\tmodel.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], undefined, index);\r\n\t\tmodel.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], undefined, index);\r\n\t\tmodel.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], undefined, index);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_removeDatasetHoverStyle: function() {\r\n\t\tvar element = this.getMeta().dataset;\r\n\r\n\t\tif (element) {\r\n\t\t\tthis.removeHoverStyle(element);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_setDatasetHoverStyle: function() {\r\n\t\tvar element = this.getMeta().dataset;\r\n\t\tvar prev = {};\r\n\t\tvar i, ilen, key, keys, hoverOptions, model;\r\n\r\n\t\tif (!element) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmodel = element._model;\r\n\t\thoverOptions = this._resolveDatasetElementOptions(element, true);\r\n\r\n\t\tkeys = Object.keys(hoverOptions);\r\n\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\r\n\t\t\tkey = keys[i];\r\n\t\t\tprev[key] = model[key];\r\n\t\t\tmodel[key] = hoverOptions[key];\r\n\t\t}\r\n\r\n\t\telement.$previousStyle = prev;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tresyncElements: function() {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar data = me.getDataset().data;\r\n\t\tvar numMeta = meta.data.length;\r\n\t\tvar numData = data.length;\r\n\r\n\t\tif (numData < numMeta) {\r\n\t\t\tmeta.data.splice(numData, numMeta - numData);\r\n\t\t} else if (numData > numMeta) {\r\n\t\t\tme.insertElements(numMeta, numData - numMeta);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tinsertElements: function(start, count) {\r\n\t\tfor (var i = 0; i < count; ++i) {\r\n\t\t\tthis.addElementAndReset(start + i);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tonDataPush: function() {\r\n\t\tvar count = arguments.length;\r\n\t\tthis.insertElements(this.getDataset().data.length - count, count);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tonDataPop: function() {\r\n\t\tthis.getMeta().data.pop();\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tonDataShift: function() {\r\n\t\tthis.getMeta().data.shift();\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tonDataSplice: function(start, count) {\r\n\t\tthis.getMeta().data.splice(start, count);\r\n\t\tthis.insertElements(start, arguments.length - 2);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tonDataUnshift: function() {\r\n\t\tthis.insertElements(0, arguments.length);\r\n\t}\r\n});\r\n\r\nDatasetController.extend = helpers$1.inherits;\r\n\r\nvar core_datasetController = DatasetController;\n\nvar TAU = Math.PI * 2;\r\n\r\ncore_defaults._set('global', {\r\n\telements: {\r\n\t\tarc: {\r\n\t\t\tbackgroundColor: core_defaults.global.defaultColor,\r\n\t\t\tborderColor: '#fff',\r\n\t\t\tborderWidth: 2,\r\n\t\t\tborderAlign: 'center'\r\n\t\t}\r\n\t}\r\n});\r\n\r\nfunction clipArc(ctx, arc) {\r\n\tvar startAngle = arc.startAngle;\r\n\tvar endAngle = arc.endAngle;\r\n\tvar pixelMargin = arc.pixelMargin;\r\n\tvar angleMargin = pixelMargin / arc.outerRadius;\r\n\tvar x = arc.x;\r\n\tvar y = arc.y;\r\n\r\n\t// Draw an inner border by cliping the arc and drawing a double-width border\r\n\t// Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\r\n\tctx.beginPath();\r\n\tctx.arc(x, y, arc.outerRadius, startAngle - angleMargin, endAngle + angleMargin);\r\n\tif (arc.innerRadius > pixelMargin) {\r\n\t\tangleMargin = pixelMargin / arc.innerRadius;\r\n\t\tctx.arc(x, y, arc.innerRadius - pixelMargin, endAngle + angleMargin, startAngle - angleMargin, true);\r\n\t} else {\r\n\t\tctx.arc(x, y, pixelMargin, endAngle + Math.PI / 2, startAngle - Math.PI / 2);\r\n\t}\r\n\tctx.closePath();\r\n\tctx.clip();\r\n}\r\n\r\nfunction drawFullCircleBorders(ctx, vm, arc, inner) {\r\n\tvar endAngle = arc.endAngle;\r\n\tvar i;\r\n\r\n\tif (inner) {\r\n\t\tarc.endAngle = arc.startAngle + TAU;\r\n\t\tclipArc(ctx, arc);\r\n\t\tarc.endAngle = endAngle;\r\n\t\tif (arc.endAngle === arc.startAngle && arc.fullCircles) {\r\n\t\t\tarc.endAngle += TAU;\r\n\t\t\tarc.fullCircles--;\r\n\t\t}\r\n\t}\r\n\r\n\tctx.beginPath();\r\n\tctx.arc(arc.x, arc.y, arc.innerRadius, arc.startAngle + TAU, arc.startAngle, true);\r\n\tfor (i = 0; i < arc.fullCircles; ++i) {\r\n\t\tctx.stroke();\r\n\t}\r\n\r\n\tctx.beginPath();\r\n\tctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.startAngle + TAU);\r\n\tfor (i = 0; i < arc.fullCircles; ++i) {\r\n\t\tctx.stroke();\r\n\t}\r\n}\r\n\r\nfunction drawBorder(ctx, vm, arc) {\r\n\tvar inner = vm.borderAlign === 'inner';\r\n\r\n\tif (inner) {\r\n\t\tctx.lineWidth = vm.borderWidth * 2;\r\n\t\tctx.lineJoin = 'round';\r\n\t} else {\r\n\t\tctx.lineWidth = vm.borderWidth;\r\n\t\tctx.lineJoin = 'bevel';\r\n\t}\r\n\r\n\tif (arc.fullCircles) {\r\n\t\tdrawFullCircleBorders(ctx, vm, arc, inner);\r\n\t}\r\n\r\n\tif (inner) {\r\n\t\tclipArc(ctx, arc);\r\n\t}\r\n\r\n\tctx.beginPath();\r\n\tctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.endAngle);\r\n\tctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);\r\n\tctx.closePath();\r\n\tctx.stroke();\r\n}\r\n\r\nvar element_arc = core_element.extend({\r\n\t_type: 'arc',\r\n\r\n\tinLabelRange: function(mouseX) {\r\n\t\tvar vm = this._view;\r\n\r\n\t\tif (vm) {\r\n\t\t\treturn (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\tinRange: function(chartX, chartY) {\r\n\t\tvar vm = this._view;\r\n\r\n\t\tif (vm) {\r\n\t\t\tvar pointRelativePosition = helpers$1.getAngleFromPoint(vm, {x: chartX, y: chartY});\r\n\t\t\tvar angle = pointRelativePosition.angle;\r\n\t\t\tvar distance = pointRelativePosition.distance;\r\n\r\n\t\t\t// Sanitise angle range\r\n\t\t\tvar startAngle = vm.startAngle;\r\n\t\t\tvar endAngle = vm.endAngle;\r\n\t\t\twhile (endAngle < startAngle) {\r\n\t\t\t\tendAngle += TAU;\r\n\t\t\t}\r\n\t\t\twhile (angle > endAngle) {\r\n\t\t\t\tangle -= TAU;\r\n\t\t\t}\r\n\t\t\twhile (angle < startAngle) {\r\n\t\t\t\tangle += TAU;\r\n\t\t\t}\r\n\r\n\t\t\t// Check if within the range of the open/close angle\r\n\t\t\tvar betweenAngles = (angle >= startAngle && angle <= endAngle);\r\n\t\t\tvar withinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);\r\n\r\n\t\t\treturn (betweenAngles && withinRadius);\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\tgetCenterPoint: function() {\r\n\t\tvar vm = this._view;\r\n\t\tvar halfAngle = (vm.startAngle + vm.endAngle) / 2;\r\n\t\tvar halfRadius = (vm.innerRadius + vm.outerRadius) / 2;\r\n\t\treturn {\r\n\t\t\tx: vm.x + Math.cos(halfAngle) * halfRadius,\r\n\t\t\ty: vm.y + Math.sin(halfAngle) * halfRadius\r\n\t\t};\r\n\t},\r\n\r\n\tgetArea: function() {\r\n\t\tvar vm = this._view;\r\n\t\treturn Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));\r\n\t},\r\n\r\n\ttooltipPosition: function() {\r\n\t\tvar vm = this._view;\r\n\t\tvar centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2);\r\n\t\tvar rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;\r\n\r\n\t\treturn {\r\n\t\t\tx: vm.x + (Math.cos(centreAngle) * rangeFromCentre),\r\n\t\t\ty: vm.y + (Math.sin(centreAngle) * rangeFromCentre)\r\n\t\t};\r\n\t},\r\n\r\n\tdraw: function() {\r\n\t\tvar ctx = this._chart.ctx;\r\n\t\tvar vm = this._view;\r\n\t\tvar pixelMargin = (vm.borderAlign === 'inner') ? 0.33 : 0;\r\n\t\tvar arc = {\r\n\t\t\tx: vm.x,\r\n\t\t\ty: vm.y,\r\n\t\t\tinnerRadius: vm.innerRadius,\r\n\t\t\touterRadius: Math.max(vm.outerRadius - pixelMargin, 0),\r\n\t\t\tpixelMargin: pixelMargin,\r\n\t\t\tstartAngle: vm.startAngle,\r\n\t\t\tendAngle: vm.endAngle,\r\n\t\t\tfullCircles: Math.floor(vm.circumference / TAU)\r\n\t\t};\r\n\t\tvar i;\r\n\r\n\t\tctx.save();\r\n\r\n\t\tctx.fillStyle = vm.backgroundColor;\r\n\t\tctx.strokeStyle = vm.borderColor;\r\n\r\n\t\tif (arc.fullCircles) {\r\n\t\t\tarc.endAngle = arc.startAngle + TAU;\r\n\t\t\tctx.beginPath();\r\n\t\t\tctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);\r\n\t\t\tctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);\r\n\t\t\tctx.closePath();\r\n\t\t\tfor (i = 0; i < arc.fullCircles; ++i) {\r\n\t\t\t\tctx.fill();\r\n\t\t\t}\r\n\t\t\tarc.endAngle = arc.startAngle + vm.circumference % TAU;\r\n\t\t}\r\n\r\n\t\tctx.beginPath();\r\n\t\tctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);\r\n\t\tctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);\r\n\t\tctx.closePath();\r\n\t\tctx.fill();\r\n\r\n\t\tif (vm.borderWidth) {\r\n\t\t\tdrawBorder(ctx, vm, arc);\r\n\t\t}\r\n\r\n\t\tctx.restore();\r\n\t}\r\n});\n\nvar valueOrDefault$1 = helpers$1.valueOrDefault;\r\n\r\nvar defaultColor = core_defaults.global.defaultColor;\r\n\r\ncore_defaults._set('global', {\r\n\telements: {\r\n\t\tline: {\r\n\t\t\ttension: 0.4,\r\n\t\t\tbackgroundColor: defaultColor,\r\n\t\t\tborderWidth: 3,\r\n\t\t\tborderColor: defaultColor,\r\n\t\t\tborderCapStyle: 'butt',\r\n\t\t\tborderDash: [],\r\n\t\t\tborderDashOffset: 0.0,\r\n\t\t\tborderJoinStyle: 'miter',\r\n\t\t\tcapBezierPoints: true,\r\n\t\t\tfill: true, // do we fill in the area between the line and its base axis\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar element_line = core_element.extend({\r\n\t_type: 'line',\r\n\r\n\tdraw: function() {\r\n\t\tvar me = this;\r\n\t\tvar vm = me._view;\r\n\t\tvar ctx = me._chart.ctx;\r\n\t\tvar spanGaps = vm.spanGaps;\r\n\t\tvar points = me._children.slice(); // clone array\r\n\t\tvar globalDefaults = core_defaults.global;\r\n\t\tvar globalOptionLineElements = globalDefaults.elements.line;\r\n\t\tvar lastDrawnIndex = -1;\r\n\t\tvar closePath = me._loop;\r\n\t\tvar index, previous, currentVM;\r\n\r\n\t\tif (!points.length) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (me._loop) {\r\n\t\t\tfor (index = 0; index < points.length; ++index) {\r\n\t\t\t\tprevious = helpers$1.previousItem(points, index);\r\n\t\t\t\t// If the line has an open path, shift the point array\r\n\t\t\t\tif (!points[index]._view.skip && previous._view.skip) {\r\n\t\t\t\t\tpoints = points.slice(index).concat(points.slice(0, index));\r\n\t\t\t\t\tclosePath = spanGaps;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// If the line has a close path, add the first point again\r\n\t\t\tif (closePath) {\r\n\t\t\t\tpoints.push(points[0]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tctx.save();\r\n\r\n\t\t// Stroke Line Options\r\n\t\tctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;\r\n\r\n\t\t// IE 9 and 10 do not support line dash\r\n\t\tif (ctx.setLineDash) {\r\n\t\t\tctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\r\n\t\t}\r\n\r\n\t\tctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);\r\n\t\tctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\r\n\t\tctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);\r\n\t\tctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;\r\n\r\n\t\t// Stroke Line\r\n\t\tctx.beginPath();\r\n\r\n\t\t// First point moves to it's starting position no matter what\r\n\t\tcurrentVM = points[0]._view;\r\n\t\tif (!currentVM.skip) {\r\n\t\t\tctx.moveTo(currentVM.x, currentVM.y);\r\n\t\t\tlastDrawnIndex = 0;\r\n\t\t}\r\n\r\n\t\tfor (index = 1; index < points.length; ++index) {\r\n\t\t\tcurrentVM = points[index]._view;\r\n\t\t\tprevious = lastDrawnIndex === -1 ? helpers$1.previousItem(points, index) : points[lastDrawnIndex];\r\n\r\n\t\t\tif (!currentVM.skip) {\r\n\t\t\t\tif ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {\r\n\t\t\t\t\t// There was a gap and this is the first point after the gap\r\n\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Line to next point\r\n\t\t\t\t\thelpers$1.canvas.lineTo(ctx, previous._view, currentVM);\r\n\t\t\t\t}\r\n\t\t\t\tlastDrawnIndex = index;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (closePath) {\r\n\t\t\tctx.closePath();\r\n\t\t}\r\n\r\n\t\tctx.stroke();\r\n\t\tctx.restore();\r\n\t}\r\n});\n\nvar valueOrDefault$2 = helpers$1.valueOrDefault;\r\n\r\nvar defaultColor$1 = core_defaults.global.defaultColor;\r\n\r\ncore_defaults._set('global', {\r\n\telements: {\r\n\t\tpoint: {\r\n\t\t\tradius: 3,\r\n\t\t\tpointStyle: 'circle',\r\n\t\t\tbackgroundColor: defaultColor$1,\r\n\t\t\tborderColor: defaultColor$1,\r\n\t\t\tborderWidth: 1,\r\n\t\t\t// Hover\r\n\t\t\thitRadius: 1,\r\n\t\t\thoverRadius: 4,\r\n\t\t\thoverBorderWidth: 1\r\n\t\t}\r\n\t}\r\n});\r\n\r\nfunction xRange(mouseX) {\r\n\tvar vm = this._view;\r\n\treturn vm ? (Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius) : false;\r\n}\r\n\r\nfunction yRange(mouseY) {\r\n\tvar vm = this._view;\r\n\treturn vm ? (Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius) : false;\r\n}\r\n\r\nvar element_point = core_element.extend({\r\n\t_type: 'point',\r\n\r\n\tinRange: function(mouseX, mouseY) {\r\n\t\tvar vm = this._view;\r\n\t\treturn vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;\r\n\t},\r\n\r\n\tinLabelRange: xRange,\r\n\tinXRange: xRange,\r\n\tinYRange: yRange,\r\n\r\n\tgetCenterPoint: function() {\r\n\t\tvar vm = this._view;\r\n\t\treturn {\r\n\t\t\tx: vm.x,\r\n\t\t\ty: vm.y\r\n\t\t};\r\n\t},\r\n\r\n\tgetArea: function() {\r\n\t\treturn Math.PI * Math.pow(this._view.radius, 2);\r\n\t},\r\n\r\n\ttooltipPosition: function() {\r\n\t\tvar vm = this._view;\r\n\t\treturn {\r\n\t\t\tx: vm.x,\r\n\t\t\ty: vm.y,\r\n\t\t\tpadding: vm.radius + vm.borderWidth\r\n\t\t};\r\n\t},\r\n\r\n\tdraw: function(chartArea) {\r\n\t\tvar vm = this._view;\r\n\t\tvar ctx = this._chart.ctx;\r\n\t\tvar pointStyle = vm.pointStyle;\r\n\t\tvar rotation = vm.rotation;\r\n\t\tvar radius = vm.radius;\r\n\t\tvar x = vm.x;\r\n\t\tvar y = vm.y;\r\n\t\tvar globalDefaults = core_defaults.global;\r\n\t\tvar defaultColor = globalDefaults.defaultColor; // eslint-disable-line no-shadow\r\n\r\n\t\tif (vm.skip) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Clipping for Points.\r\n\t\tif (chartArea === undefined || helpers$1.canvas._isPointInArea(vm, chartArea)) {\r\n\t\t\tctx.strokeStyle = vm.borderColor || defaultColor;\r\n\t\t\tctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);\r\n\t\t\tctx.fillStyle = vm.backgroundColor || defaultColor;\r\n\t\t\thelpers$1.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);\r\n\t\t}\r\n\t}\r\n});\n\nvar defaultColor$2 = core_defaults.global.defaultColor;\r\n\r\ncore_defaults._set('global', {\r\n\telements: {\r\n\t\trectangle: {\r\n\t\t\tbackgroundColor: defaultColor$2,\r\n\t\t\tborderColor: defaultColor$2,\r\n\t\t\tborderSkipped: 'bottom',\r\n\t\t\tborderWidth: 0\r\n\t\t}\r\n\t}\r\n});\r\n\r\nfunction isVertical(vm) {\r\n\treturn vm && vm.width !== undefined;\r\n}\r\n\r\n/**\r\n * Helper function to get the bounds of the bar regardless of the orientation\r\n * @param bar {Chart.Element.Rectangle} the bar\r\n * @return {Bounds} bounds of the bar\r\n * @private\r\n */\r\nfunction getBarBounds(vm) {\r\n\tvar x1, x2, y1, y2, half;\r\n\r\n\tif (isVertical(vm)) {\r\n\t\thalf = vm.width / 2;\r\n\t\tx1 = vm.x - half;\r\n\t\tx2 = vm.x + half;\r\n\t\ty1 = Math.min(vm.y, vm.base);\r\n\t\ty2 = Math.max(vm.y, vm.base);\r\n\t} else {\r\n\t\thalf = vm.height / 2;\r\n\t\tx1 = Math.min(vm.x, vm.base);\r\n\t\tx2 = Math.max(vm.x, vm.base);\r\n\t\ty1 = vm.y - half;\r\n\t\ty2 = vm.y + half;\r\n\t}\r\n\r\n\treturn {\r\n\t\tleft: x1,\r\n\t\ttop: y1,\r\n\t\tright: x2,\r\n\t\tbottom: y2\r\n\t};\r\n}\r\n\r\nfunction swap(orig, v1, v2) {\r\n\treturn orig === v1 ? v2 : orig === v2 ? v1 : orig;\r\n}\r\n\r\nfunction parseBorderSkipped(vm) {\r\n\tvar edge = vm.borderSkipped;\r\n\tvar res = {};\r\n\r\n\tif (!edge) {\r\n\t\treturn res;\r\n\t}\r\n\r\n\tif (vm.horizontal) {\r\n\t\tif (vm.base > vm.x) {\r\n\t\t\tedge = swap(edge, 'left', 'right');\r\n\t\t}\r\n\t} else if (vm.base < vm.y) {\r\n\t\tedge = swap(edge, 'bottom', 'top');\r\n\t}\r\n\r\n\tres[edge] = true;\r\n\treturn res;\r\n}\r\n\r\nfunction parseBorderWidth(vm, maxW, maxH) {\r\n\tvar value = vm.borderWidth;\r\n\tvar skip = parseBorderSkipped(vm);\r\n\tvar t, r, b, l;\r\n\r\n\tif (helpers$1.isObject(value)) {\r\n\t\tt = +value.top || 0;\r\n\t\tr = +value.right || 0;\r\n\t\tb = +value.bottom || 0;\r\n\t\tl = +value.left || 0;\r\n\t} else {\r\n\t\tt = r = b = l = +value || 0;\r\n\t}\r\n\r\n\treturn {\r\n\t\tt: skip.top || (t < 0) ? 0 : t > maxH ? maxH : t,\r\n\t\tr: skip.right || (r < 0) ? 0 : r > maxW ? maxW : r,\r\n\t\tb: skip.bottom || (b < 0) ? 0 : b > maxH ? maxH : b,\r\n\t\tl: skip.left || (l < 0) ? 0 : l > maxW ? maxW : l\r\n\t};\r\n}\r\n\r\nfunction boundingRects(vm) {\r\n\tvar bounds = getBarBounds(vm);\r\n\tvar width = bounds.right - bounds.left;\r\n\tvar height = bounds.bottom - bounds.top;\r\n\tvar border = parseBorderWidth(vm, width / 2, height / 2);\r\n\r\n\treturn {\r\n\t\touter: {\r\n\t\t\tx: bounds.left,\r\n\t\t\ty: bounds.top,\r\n\t\t\tw: width,\r\n\t\t\th: height\r\n\t\t},\r\n\t\tinner: {\r\n\t\t\tx: bounds.left + border.l,\r\n\t\t\ty: bounds.top + border.t,\r\n\t\t\tw: width - border.l - border.r,\r\n\t\t\th: height - border.t - border.b\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction inRange(vm, x, y) {\r\n\tvar skipX = x === null;\r\n\tvar skipY = y === null;\r\n\tvar bounds = !vm || (skipX && skipY) ? false : getBarBounds(vm);\r\n\r\n\treturn bounds\r\n\t\t&& (skipX || x >= bounds.left && x <= bounds.right)\r\n\t\t&& (skipY || y >= bounds.top && y <= bounds.bottom);\r\n}\r\n\r\nvar element_rectangle = core_element.extend({\r\n\t_type: 'rectangle',\r\n\r\n\tdraw: function() {\r\n\t\tvar ctx = this._chart.ctx;\r\n\t\tvar vm = this._view;\r\n\t\tvar rects = boundingRects(vm);\r\n\t\tvar outer = rects.outer;\r\n\t\tvar inner = rects.inner;\r\n\r\n\t\tctx.fillStyle = vm.backgroundColor;\r\n\t\tctx.fillRect(outer.x, outer.y, outer.w, outer.h);\r\n\r\n\t\tif (outer.w === inner.w && outer.h === inner.h) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tctx.save();\r\n\t\tctx.beginPath();\r\n\t\tctx.rect(outer.x, outer.y, outer.w, outer.h);\r\n\t\tctx.clip();\r\n\t\tctx.fillStyle = vm.borderColor;\r\n\t\tctx.rect(inner.x, inner.y, inner.w, inner.h);\r\n\t\tctx.fill('evenodd');\r\n\t\tctx.restore();\r\n\t},\r\n\r\n\theight: function() {\r\n\t\tvar vm = this._view;\r\n\t\treturn vm.base - vm.y;\r\n\t},\r\n\r\n\tinRange: function(mouseX, mouseY) {\r\n\t\treturn inRange(this._view, mouseX, mouseY);\r\n\t},\r\n\r\n\tinLabelRange: function(mouseX, mouseY) {\r\n\t\tvar vm = this._view;\r\n\t\treturn isVertical(vm)\r\n\t\t\t? inRange(vm, mouseX, null)\r\n\t\t\t: inRange(vm, null, mouseY);\r\n\t},\r\n\r\n\tinXRange: function(mouseX) {\r\n\t\treturn inRange(this._view, mouseX, null);\r\n\t},\r\n\r\n\tinYRange: function(mouseY) {\r\n\t\treturn inRange(this._view, null, mouseY);\r\n\t},\r\n\r\n\tgetCenterPoint: function() {\r\n\t\tvar vm = this._view;\r\n\t\tvar x, y;\r\n\t\tif (isVertical(vm)) {\r\n\t\t\tx = vm.x;\r\n\t\t\ty = (vm.y + vm.base) / 2;\r\n\t\t} else {\r\n\t\t\tx = (vm.x + vm.base) / 2;\r\n\t\t\ty = vm.y;\r\n\t\t}\r\n\r\n\t\treturn {x: x, y: y};\r\n\t},\r\n\r\n\tgetArea: function() {\r\n\t\tvar vm = this._view;\r\n\r\n\t\treturn isVertical(vm)\r\n\t\t\t? vm.width * Math.abs(vm.y - vm.base)\r\n\t\t\t: vm.height * Math.abs(vm.x - vm.base);\r\n\t},\r\n\r\n\ttooltipPosition: function() {\r\n\t\tvar vm = this._view;\r\n\t\treturn {\r\n\t\t\tx: vm.x,\r\n\t\t\ty: vm.y\r\n\t\t};\r\n\t}\r\n});\n\nvar elements = {};\r\nvar Arc = element_arc;\r\nvar Line = element_line;\r\nvar Point = element_point;\r\nvar Rectangle = element_rectangle;\nelements.Arc = Arc;\nelements.Line = Line;\nelements.Point = Point;\nelements.Rectangle = Rectangle;\n\nvar deprecated = helpers$1._deprecated;\r\nvar valueOrDefault$3 = helpers$1.valueOrDefault;\r\n\r\ncore_defaults._set('bar', {\r\n\thover: {\r\n\t\tmode: 'label'\r\n\t},\r\n\r\n\tscales: {\r\n\t\txAxes: [{\r\n\t\t\ttype: 'category',\r\n\t\t\toffset: true,\r\n\t\t\tgridLines: {\r\n\t\t\t\toffsetGridLines: true\r\n\t\t\t}\r\n\t\t}],\r\n\r\n\t\tyAxes: [{\r\n\t\t\ttype: 'linear'\r\n\t\t}]\r\n\t}\r\n});\r\n\r\ncore_defaults._set('global', {\r\n\tdatasets: {\r\n\t\tbar: {\r\n\t\t\tcategoryPercentage: 0.8,\r\n\t\t\tbarPercentage: 0.9\r\n\t\t}\r\n\t}\r\n});\r\n\r\n/**\r\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\r\n * @private\r\n */\r\nfunction computeMinSampleSize(scale, pixels) {\r\n\tvar min = scale._length;\r\n\tvar prev, curr, i, ilen;\r\n\r\n\tfor (i = 1, ilen = pixels.length; i < ilen; ++i) {\r\n\t\tmin = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));\r\n\t}\r\n\r\n\tfor (i = 0, ilen = scale.getTicks().length; i < ilen; ++i) {\r\n\t\tcurr = scale.getPixelForTick(i);\r\n\t\tmin = i > 0 ? Math.min(min, Math.abs(curr - prev)) : min;\r\n\t\tprev = curr;\r\n\t}\r\n\r\n\treturn min;\r\n}\r\n\r\n/**\r\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\r\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\r\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\r\n * @private\r\n */\r\nfunction computeFitCategoryTraits(index, ruler, options) {\r\n\tvar thickness = options.barThickness;\r\n\tvar count = ruler.stackCount;\r\n\tvar curr = ruler.pixels[index];\r\n\tvar min = helpers$1.isNullOrUndef(thickness)\r\n\t\t? computeMinSampleSize(ruler.scale, ruler.pixels)\r\n\t\t: -1;\r\n\tvar size, ratio;\r\n\r\n\tif (helpers$1.isNullOrUndef(thickness)) {\r\n\t\tsize = min * options.categoryPercentage;\r\n\t\tratio = options.barPercentage;\r\n\t} else {\r\n\t\t// When bar thickness is enforced, category and bar percentages are ignored.\r\n\t\t// Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\r\n\t\t// and deprecate barPercentage since this value is ignored when thickness is absolute.\r\n\t\tsize = thickness * count;\r\n\t\tratio = 1;\r\n\t}\r\n\r\n\treturn {\r\n\t\tchunk: size / count,\r\n\t\tratio: ratio,\r\n\t\tstart: curr - (size / 2)\r\n\t};\r\n}\r\n\r\n/**\r\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\r\n * percentage options are 1), based on the previous and following categories. This mode\r\n * generates bars with different widths when data are not evenly spaced.\r\n * @private\r\n */\r\nfunction computeFlexCategoryTraits(index, ruler, options) {\r\n\tvar pixels = ruler.pixels;\r\n\tvar curr = pixels[index];\r\n\tvar prev = index > 0 ? pixels[index - 1] : null;\r\n\tvar next = index < pixels.length - 1 ? pixels[index + 1] : null;\r\n\tvar percent = options.categoryPercentage;\r\n\tvar start, size;\r\n\r\n\tif (prev === null) {\r\n\t\t// first data: its size is double based on the next point or,\r\n\t\t// if it's also the last data, we use the scale size.\r\n\t\tprev = curr - (next === null ? ruler.end - ruler.start : next - curr);\r\n\t}\r\n\r\n\tif (next === null) {\r\n\t\t// last data: its size is also double based on the previous point.\r\n\t\tnext = curr + curr - prev;\r\n\t}\r\n\r\n\tstart = curr - (curr - Math.min(prev, next)) / 2 * percent;\r\n\tsize = Math.abs(next - prev) / 2 * percent;\r\n\r\n\treturn {\r\n\t\tchunk: size / ruler.stackCount,\r\n\t\tratio: options.barPercentage,\r\n\t\tstart: start\r\n\t};\r\n}\r\n\r\nvar controller_bar = core_datasetController.extend({\r\n\r\n\tdataElementType: elements.Rectangle,\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_dataElementOptions: [\r\n\t\t'backgroundColor',\r\n\t\t'borderColor',\r\n\t\t'borderSkipped',\r\n\t\t'borderWidth',\r\n\t\t'barPercentage',\r\n\t\t'barThickness',\r\n\t\t'categoryPercentage',\r\n\t\t'maxBarThickness',\r\n\t\t'minBarLength'\r\n\t],\r\n\r\n\tinitialize: function() {\r\n\t\tvar me = this;\r\n\t\tvar meta, scaleOpts;\r\n\r\n\t\tcore_datasetController.prototype.initialize.apply(me, arguments);\r\n\r\n\t\tmeta = me.getMeta();\r\n\t\tmeta.stack = me.getDataset().stack;\r\n\t\tmeta.bar = true;\r\n\r\n\t\tscaleOpts = me._getIndexScale().options;\r\n\t\tdeprecated('bar chart', scaleOpts.barPercentage, 'scales.[x/y]Axes.barPercentage', 'dataset.barPercentage');\r\n\t\tdeprecated('bar chart', scaleOpts.barThickness, 'scales.[x/y]Axes.barThickness', 'dataset.barThickness');\r\n\t\tdeprecated('bar chart', scaleOpts.categoryPercentage, 'scales.[x/y]Axes.categoryPercentage', 'dataset.categoryPercentage');\r\n\t\tdeprecated('bar chart', me._getValueScale().options.minBarLength, 'scales.[x/y]Axes.minBarLength', 'dataset.minBarLength');\r\n\t\tdeprecated('bar chart', scaleOpts.maxBarThickness, 'scales.[x/y]Axes.maxBarThickness', 'dataset.maxBarThickness');\r\n\t},\r\n\r\n\tupdate: function(reset) {\r\n\t\tvar me = this;\r\n\t\tvar rects = me.getMeta().data;\r\n\t\tvar i, ilen;\r\n\r\n\t\tme._ruler = me.getRuler();\r\n\r\n\t\tfor (i = 0, ilen = rects.length; i < ilen; ++i) {\r\n\t\t\tme.updateElement(rects[i], i, reset);\r\n\t\t}\r\n\t},\r\n\r\n\tupdateElement: function(rectangle, index, reset) {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar options = me._resolveDataElementOptions(rectangle, index);\r\n\r\n\t\trectangle._xScale = me.getScaleForId(meta.xAxisID);\r\n\t\trectangle._yScale = me.getScaleForId(meta.yAxisID);\r\n\t\trectangle._datasetIndex = me.index;\r\n\t\trectangle._index = index;\r\n\t\trectangle._model = {\r\n\t\t\tbackgroundColor: options.backgroundColor,\r\n\t\t\tborderColor: options.borderColor,\r\n\t\t\tborderSkipped: options.borderSkipped,\r\n\t\t\tborderWidth: options.borderWidth,\r\n\t\t\tdatasetLabel: dataset.label,\r\n\t\t\tlabel: me.chart.data.labels[index]\r\n\t\t};\r\n\r\n\t\tif (helpers$1.isArray(dataset.data[index])) {\r\n\t\t\trectangle._model.borderSkipped = null;\r\n\t\t}\r\n\r\n\t\tme._updateElementGeometry(rectangle, index, reset, options);\r\n\r\n\t\trectangle.pivot();\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_updateElementGeometry: function(rectangle, index, reset, options) {\r\n\t\tvar me = this;\r\n\t\tvar model = rectangle._model;\r\n\t\tvar vscale = me._getValueScale();\r\n\t\tvar base = vscale.getBasePixel();\r\n\t\tvar horizontal = vscale.isHorizontal();\r\n\t\tvar ruler = me._ruler || me.getRuler();\r\n\t\tvar vpixels = me.calculateBarValuePixels(me.index, index, options);\r\n\t\tvar ipixels = me.calculateBarIndexPixels(me.index, index, ruler, options);\r\n\r\n\t\tmodel.horizontal = horizontal;\r\n\t\tmodel.base = reset ? base : vpixels.base;\r\n\t\tmodel.x = horizontal ? reset ? base : vpixels.head : ipixels.center;\r\n\t\tmodel.y = horizontal ? ipixels.center : reset ? base : vpixels.head;\r\n\t\tmodel.height = horizontal ? ipixels.size : undefined;\r\n\t\tmodel.width = horizontal ? undefined : ipixels.size;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns the stacks based on groups and bar visibility.\r\n\t * @param {number} [last] - The dataset index\r\n\t * @returns {string[]} The list of stack IDs\r\n\t * @private\r\n\t */\r\n\t_getStacks: function(last) {\r\n\t\tvar me = this;\r\n\t\tvar scale = me._getIndexScale();\r\n\t\tvar metasets = scale._getMatchingVisibleMetas(me._type);\r\n\t\tvar stacked = scale.options.stacked;\r\n\t\tvar ilen = metasets.length;\r\n\t\tvar stacks = [];\r\n\t\tvar i, meta;\r\n\r\n\t\tfor (i = 0; i < ilen; ++i) {\r\n\t\t\tmeta = metasets[i];\r\n\t\t\t// stacked   | meta.stack\r\n\t\t\t//           | found | not found | undefined\r\n\t\t\t// false     |   x   |     x     |     x\r\n\t\t\t// true      |       |     x     |\r\n\t\t\t// undefined |       |     x     |     x\r\n\t\t\tif (stacked === false || stacks.indexOf(meta.stack) === -1 ||\r\n\t\t\t\t(stacked === undefined && meta.stack === undefined)) {\r\n\t\t\t\tstacks.push(meta.stack);\r\n\t\t\t}\r\n\t\t\tif (meta.index === last) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn stacks;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns the effective number of stacks based on groups and bar visibility.\r\n\t * @private\r\n\t */\r\n\tgetStackCount: function() {\r\n\t\treturn this._getStacks().length;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns the stack index for the given dataset based on groups and bar visibility.\r\n\t * @param {number} [datasetIndex] - The dataset index\r\n\t * @param {string} [name] - The stack name to find\r\n\t * @returns {number} The stack index\r\n\t * @private\r\n\t */\r\n\tgetStackIndex: function(datasetIndex, name) {\r\n\t\tvar stacks = this._getStacks(datasetIndex);\r\n\t\tvar index = (name !== undefined)\r\n\t\t\t? stacks.indexOf(name)\r\n\t\t\t: -1; // indexOf returns -1 if element is not present\r\n\r\n\t\treturn (index === -1)\r\n\t\t\t? stacks.length - 1\r\n\t\t\t: index;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tgetRuler: function() {\r\n\t\tvar me = this;\r\n\t\tvar scale = me._getIndexScale();\r\n\t\tvar pixels = [];\r\n\t\tvar i, ilen;\r\n\r\n\t\tfor (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {\r\n\t\t\tpixels.push(scale.getPixelForValue(null, i, me.index));\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tpixels: pixels,\r\n\t\t\tstart: scale._startPixel,\r\n\t\t\tend: scale._endPixel,\r\n\t\t\tstackCount: me.getStackCount(),\r\n\t\t\tscale: scale\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Note: pixel values are not clamped to the scale area.\r\n\t * @private\r\n\t */\r\n\tcalculateBarValuePixels: function(datasetIndex, index, options) {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar scale = me._getValueScale();\r\n\t\tvar isHorizontal = scale.isHorizontal();\r\n\t\tvar datasets = chart.data.datasets;\r\n\t\tvar metasets = scale._getMatchingVisibleMetas(me._type);\r\n\t\tvar value = scale._parseValue(datasets[datasetIndex].data[index]);\r\n\t\tvar minBarLength = options.minBarLength;\r\n\t\tvar stacked = scale.options.stacked;\r\n\t\tvar stack = me.getMeta().stack;\r\n\t\tvar start = value.start === undefined ? 0 : value.max >= 0 && value.min >= 0 ? value.min : value.max;\r\n\t\tvar length = value.start === undefined ? value.end : value.max >= 0 && value.min >= 0 ? value.max - value.min : value.min - value.max;\r\n\t\tvar ilen = metasets.length;\r\n\t\tvar i, imeta, ivalue, base, head, size, stackLength;\r\n\r\n\t\tif (stacked || (stacked === undefined && stack !== undefined)) {\r\n\t\t\tfor (i = 0; i < ilen; ++i) {\r\n\t\t\t\timeta = metasets[i];\r\n\r\n\t\t\t\tif (imeta.index === datasetIndex) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (imeta.stack === stack) {\r\n\t\t\t\t\tstackLength = scale._parseValue(datasets[imeta.index].data[index]);\r\n\t\t\t\t\tivalue = stackLength.start === undefined ? stackLength.end : stackLength.min >= 0 && stackLength.max >= 0 ? stackLength.max : stackLength.min;\r\n\r\n\t\t\t\t\tif ((value.min < 0 && ivalue < 0) || (value.max >= 0 && ivalue > 0)) {\r\n\t\t\t\t\t\tstart += ivalue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tbase = scale.getPixelForValue(start);\r\n\t\thead = scale.getPixelForValue(start + length);\r\n\t\tsize = head - base;\r\n\r\n\t\tif (minBarLength !== undefined && Math.abs(size) < minBarLength) {\r\n\t\t\tsize = minBarLength;\r\n\t\t\tif (length >= 0 && !isHorizontal || length < 0 && isHorizontal) {\r\n\t\t\t\thead = base - minBarLength;\r\n\t\t\t} else {\r\n\t\t\t\thead = base + minBarLength;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tsize: size,\r\n\t\t\tbase: base,\r\n\t\t\thead: head,\r\n\t\t\tcenter: head + size / 2\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tcalculateBarIndexPixels: function(datasetIndex, index, ruler, options) {\r\n\t\tvar me = this;\r\n\t\tvar range = options.barThickness === 'flex'\r\n\t\t\t? computeFlexCategoryTraits(index, ruler, options)\r\n\t\t\t: computeFitCategoryTraits(index, ruler, options);\r\n\r\n\t\tvar stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);\r\n\t\tvar center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\r\n\t\tvar size = Math.min(\r\n\t\t\tvalueOrDefault$3(options.maxBarThickness, Infinity),\r\n\t\t\trange.chunk * range.ratio);\r\n\r\n\t\treturn {\r\n\t\t\tbase: center - size / 2,\r\n\t\t\thead: center + size / 2,\r\n\t\t\tcenter: center,\r\n\t\t\tsize: size\r\n\t\t};\r\n\t},\r\n\r\n\tdraw: function() {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar scale = me._getValueScale();\r\n\t\tvar rects = me.getMeta().data;\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar ilen = rects.length;\r\n\t\tvar i = 0;\r\n\r\n\t\thelpers$1.canvas.clipArea(chart.ctx, chart.chartArea);\r\n\r\n\t\tfor (; i < ilen; ++i) {\r\n\t\t\tvar val = scale._parseValue(dataset.data[i]);\r\n\t\t\tif (!isNaN(val.min) && !isNaN(val.max)) {\r\n\t\t\t\trects[i].draw();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thelpers$1.canvas.unclipArea(chart.ctx);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_resolveDataElementOptions: function() {\r\n\t\tvar me = this;\r\n\t\tvar values = helpers$1.extend({}, core_datasetController.prototype._resolveDataElementOptions.apply(me, arguments));\r\n\t\tvar indexOpts = me._getIndexScale().options;\r\n\t\tvar valueOpts = me._getValueScale().options;\r\n\r\n\t\tvalues.barPercentage = valueOrDefault$3(indexOpts.barPercentage, values.barPercentage);\r\n\t\tvalues.barThickness = valueOrDefault$3(indexOpts.barThickness, values.barThickness);\r\n\t\tvalues.categoryPercentage = valueOrDefault$3(indexOpts.categoryPercentage, values.categoryPercentage);\r\n\t\tvalues.maxBarThickness = valueOrDefault$3(indexOpts.maxBarThickness, values.maxBarThickness);\r\n\t\tvalues.minBarLength = valueOrDefault$3(valueOpts.minBarLength, values.minBarLength);\r\n\r\n\t\treturn values;\r\n\t}\r\n\r\n});\n\nvar valueOrDefault$4 = helpers$1.valueOrDefault;\r\nvar resolve$1 = helpers$1.options.resolve;\r\n\r\ncore_defaults._set('bubble', {\r\n\thover: {\r\n\t\tmode: 'single'\r\n\t},\r\n\r\n\tscales: {\r\n\t\txAxes: [{\r\n\t\t\ttype: 'linear', // bubble should probably use a linear scale by default\r\n\t\t\tposition: 'bottom',\r\n\t\t\tid: 'x-axis-0' // need an ID so datasets can reference the scale\r\n\t\t}],\r\n\t\tyAxes: [{\r\n\t\t\ttype: 'linear',\r\n\t\t\tposition: 'left',\r\n\t\t\tid: 'y-axis-0'\r\n\t\t}]\r\n\t},\r\n\r\n\ttooltips: {\r\n\t\tcallbacks: {\r\n\t\t\ttitle: function() {\r\n\t\t\t\t// Title doesn't make sense for scatter since we format the data as a point\r\n\t\t\t\treturn '';\r\n\t\t\t},\r\n\t\t\tlabel: function(item, data) {\r\n\t\t\t\tvar datasetLabel = data.datasets[item.datasetIndex].label || '';\r\n\t\t\t\tvar dataPoint = data.datasets[item.datasetIndex].data[item.index];\r\n\t\t\t\treturn datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar controller_bubble = core_datasetController.extend({\r\n\t/**\r\n\t * @protected\r\n\t */\r\n\tdataElementType: elements.Point,\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_dataElementOptions: [\r\n\t\t'backgroundColor',\r\n\t\t'borderColor',\r\n\t\t'borderWidth',\r\n\t\t'hoverBackgroundColor',\r\n\t\t'hoverBorderColor',\r\n\t\t'hoverBorderWidth',\r\n\t\t'hoverRadius',\r\n\t\t'hitRadius',\r\n\t\t'pointStyle',\r\n\t\t'rotation'\r\n\t],\r\n\r\n\t/**\r\n\t * @protected\r\n\t */\r\n\tupdate: function(reset) {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar points = meta.data;\r\n\r\n\t\t// Update Points\r\n\t\thelpers$1.each(points, function(point, index) {\r\n\t\t\tme.updateElement(point, index, reset);\r\n\t\t});\r\n\t},\r\n\r\n\t/**\r\n\t * @protected\r\n\t */\r\n\tupdateElement: function(point, index, reset) {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar custom = point.custom || {};\r\n\t\tvar xScale = me.getScaleForId(meta.xAxisID);\r\n\t\tvar yScale = me.getScaleForId(meta.yAxisID);\r\n\t\tvar options = me._resolveDataElementOptions(point, index);\r\n\t\tvar data = me.getDataset().data[index];\r\n\t\tvar dsIndex = me.index;\r\n\r\n\t\tvar x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);\r\n\t\tvar y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);\r\n\r\n\t\tpoint._xScale = xScale;\r\n\t\tpoint._yScale = yScale;\r\n\t\tpoint._options = options;\r\n\t\tpoint._datasetIndex = dsIndex;\r\n\t\tpoint._index = index;\r\n\t\tpoint._model = {\r\n\t\t\tbackgroundColor: options.backgroundColor,\r\n\t\t\tborderColor: options.borderColor,\r\n\t\t\tborderWidth: options.borderWidth,\r\n\t\t\thitRadius: options.hitRadius,\r\n\t\t\tpointStyle: options.pointStyle,\r\n\t\t\trotation: options.rotation,\r\n\t\t\tradius: reset ? 0 : options.radius,\r\n\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\r\n\t\t\tx: x,\r\n\t\t\ty: y,\r\n\t\t};\r\n\r\n\t\tpoint.pivot();\r\n\t},\r\n\r\n\t/**\r\n\t * @protected\r\n\t */\r\n\tsetHoverStyle: function(point) {\r\n\t\tvar model = point._model;\r\n\t\tvar options = point._options;\r\n\t\tvar getHoverColor = helpers$1.getHoverColor;\r\n\r\n\t\tpoint.$previousStyle = {\r\n\t\t\tbackgroundColor: model.backgroundColor,\r\n\t\t\tborderColor: model.borderColor,\r\n\t\t\tborderWidth: model.borderWidth,\r\n\t\t\tradius: model.radius\r\n\t\t};\r\n\r\n\t\tmodel.backgroundColor = valueOrDefault$4(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\r\n\t\tmodel.borderColor = valueOrDefault$4(options.hoverBorderColor, getHoverColor(options.borderColor));\r\n\t\tmodel.borderWidth = valueOrDefault$4(options.hoverBorderWidth, options.borderWidth);\r\n\t\tmodel.radius = options.radius + options.hoverRadius;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_resolveDataElementOptions: function(point, index) {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar custom = point.custom || {};\r\n\t\tvar data = dataset.data[index] || {};\r\n\t\tvar values = core_datasetController.prototype._resolveDataElementOptions.apply(me, arguments);\r\n\r\n\t\t// Scriptable options\r\n\t\tvar context = {\r\n\t\t\tchart: chart,\r\n\t\t\tdataIndex: index,\r\n\t\t\tdataset: dataset,\r\n\t\t\tdatasetIndex: me.index\r\n\t\t};\r\n\r\n\t\t// In case values were cached (and thus frozen), we need to clone the values\r\n\t\tif (me._cachedDataOpts === values) {\r\n\t\t\tvalues = helpers$1.extend({}, values);\r\n\t\t}\r\n\r\n\t\t// Custom radius resolution\r\n\t\tvalues.radius = resolve$1([\r\n\t\t\tcustom.radius,\r\n\t\t\tdata.r,\r\n\t\t\tme._config.radius,\r\n\t\t\tchart.options.elements.point.radius\r\n\t\t], context, index);\r\n\r\n\t\treturn values;\r\n\t}\r\n});\n\nvar valueOrDefault$5 = helpers$1.valueOrDefault;\r\n\r\nvar PI$1 = Math.PI;\r\nvar DOUBLE_PI$1 = PI$1 * 2;\r\nvar HALF_PI$1 = PI$1 / 2;\r\n\r\ncore_defaults._set('doughnut', {\r\n\tanimation: {\r\n\t\t// Boolean - Whether we animate the rotation of the Doughnut\r\n\t\tanimateRotate: true,\r\n\t\t// Boolean - Whether we animate scaling the Doughnut from the centre\r\n\t\tanimateScale: false\r\n\t},\r\n\thover: {\r\n\t\tmode: 'single'\r\n\t},\r\n\tlegendCallback: function(chart) {\r\n\t\tvar list = document.createElement('ul');\r\n\t\tvar data = chart.data;\r\n\t\tvar datasets = data.datasets;\r\n\t\tvar labels = data.labels;\r\n\t\tvar i, ilen, listItem, listItemSpan;\r\n\r\n\t\tlist.setAttribute('class', chart.id + '-legend');\r\n\t\tif (datasets.length) {\r\n\t\t\tfor (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {\r\n\t\t\t\tlistItem = list.appendChild(document.createElement('li'));\r\n\t\t\t\tlistItemSpan = listItem.appendChild(document.createElement('span'));\r\n\t\t\t\tlistItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];\r\n\t\t\t\tif (labels[i]) {\r\n\t\t\t\t\tlistItem.appendChild(document.createTextNode(labels[i]));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn list.outerHTML;\r\n\t},\r\n\tlegend: {\r\n\t\tlabels: {\r\n\t\t\tgenerateLabels: function(chart) {\r\n\t\t\t\tvar data = chart.data;\r\n\t\t\t\tif (data.labels.length && data.datasets.length) {\r\n\t\t\t\t\treturn data.labels.map(function(label, i) {\r\n\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\r\n\t\t\t\t\t\tvar style = meta.controller.getStyle(i);\r\n\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\ttext: label,\r\n\t\t\t\t\t\t\tfillStyle: style.backgroundColor,\r\n\t\t\t\t\t\t\tstrokeStyle: style.borderColor,\r\n\t\t\t\t\t\t\tlineWidth: style.borderWidth,\r\n\t\t\t\t\t\t\thidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,\r\n\r\n\t\t\t\t\t\t\t// Extra data used for toggling the correct item\r\n\t\t\t\t\t\t\tindex: i\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\treturn [];\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tonClick: function(e, legendItem) {\r\n\t\t\tvar index = legendItem.index;\r\n\t\t\tvar chart = this.chart;\r\n\t\t\tvar i, ilen, meta;\r\n\r\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\r\n\t\t\t\tmeta = chart.getDatasetMeta(i);\r\n\t\t\t\t// toggle visibility of index if exists\r\n\t\t\t\tif (meta.data[index]) {\r\n\t\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tchart.update();\r\n\t\t}\r\n\t},\r\n\r\n\t// The percentage of the chart that we cut out of the middle.\r\n\tcutoutPercentage: 50,\r\n\r\n\t// The rotation of the chart, where the first data arc begins.\r\n\trotation: -HALF_PI$1,\r\n\r\n\t// The total circumference of the chart.\r\n\tcircumference: DOUBLE_PI$1,\r\n\r\n\t// Need to override these to give a nice default\r\n\ttooltips: {\r\n\t\tcallbacks: {\r\n\t\t\ttitle: function() {\r\n\t\t\t\treturn '';\r\n\t\t\t},\r\n\t\t\tlabel: function(tooltipItem, data) {\r\n\t\t\t\tvar dataLabel = data.labels[tooltipItem.index];\r\n\t\t\t\tvar value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\r\n\r\n\t\t\t\tif (helpers$1.isArray(dataLabel)) {\r\n\t\t\t\t\t// show value on first line of multiline label\r\n\t\t\t\t\t// need to clone because we are changing the value\r\n\t\t\t\t\tdataLabel = dataLabel.slice();\r\n\t\t\t\t\tdataLabel[0] += value;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdataLabel += value;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn dataLabel;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar controller_doughnut = core_datasetController.extend({\r\n\r\n\tdataElementType: elements.Arc,\r\n\r\n\tlinkScales: helpers$1.noop,\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_dataElementOptions: [\r\n\t\t'backgroundColor',\r\n\t\t'borderColor',\r\n\t\t'borderWidth',\r\n\t\t'borderAlign',\r\n\t\t'hoverBackgroundColor',\r\n\t\t'hoverBorderColor',\r\n\t\t'hoverBorderWidth',\r\n\t],\r\n\r\n\t// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly\r\n\tgetRingIndex: function(datasetIndex) {\r\n\t\tvar ringIndex = 0;\r\n\r\n\t\tfor (var j = 0; j < datasetIndex; ++j) {\r\n\t\t\tif (this.chart.isDatasetVisible(j)) {\r\n\t\t\t\t++ringIndex;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn ringIndex;\r\n\t},\r\n\r\n\tupdate: function(reset) {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar chartArea = chart.chartArea;\r\n\t\tvar opts = chart.options;\r\n\t\tvar ratioX = 1;\r\n\t\tvar ratioY = 1;\r\n\t\tvar offsetX = 0;\r\n\t\tvar offsetY = 0;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar arcs = meta.data;\r\n\t\tvar cutout = opts.cutoutPercentage / 100 || 0;\r\n\t\tvar circumference = opts.circumference;\r\n\t\tvar chartWeight = me._getRingWeight(me.index);\r\n\t\tvar maxWidth, maxHeight, i, ilen;\r\n\r\n\t\t// If the chart's circumference isn't a full circle, calculate size as a ratio of the width/height of the arc\r\n\t\tif (circumference < DOUBLE_PI$1) {\r\n\t\t\tvar startAngle = opts.rotation % DOUBLE_PI$1;\r\n\t\t\tstartAngle += startAngle >= PI$1 ? -DOUBLE_PI$1 : startAngle < -PI$1 ? DOUBLE_PI$1 : 0;\r\n\t\t\tvar endAngle = startAngle + circumference;\r\n\t\t\tvar startX = Math.cos(startAngle);\r\n\t\t\tvar startY = Math.sin(startAngle);\r\n\t\t\tvar endX = Math.cos(endAngle);\r\n\t\t\tvar endY = Math.sin(endAngle);\r\n\t\t\tvar contains0 = (startAngle <= 0 && endAngle >= 0) || endAngle >= DOUBLE_PI$1;\r\n\t\t\tvar contains90 = (startAngle <= HALF_PI$1 && endAngle >= HALF_PI$1) || endAngle >= DOUBLE_PI$1 + HALF_PI$1;\r\n\t\t\tvar contains180 = startAngle === -PI$1 || endAngle >= PI$1;\r\n\t\t\tvar contains270 = (startAngle <= -HALF_PI$1 && endAngle >= -HALF_PI$1) || endAngle >= PI$1 + HALF_PI$1;\r\n\t\t\tvar minX = contains180 ? -1 : Math.min(startX, startX * cutout, endX, endX * cutout);\r\n\t\t\tvar minY = contains270 ? -1 : Math.min(startY, startY * cutout, endY, endY * cutout);\r\n\t\t\tvar maxX = contains0 ? 1 : Math.max(startX, startX * cutout, endX, endX * cutout);\r\n\t\t\tvar maxY = contains90 ? 1 : Math.max(startY, startY * cutout, endY, endY * cutout);\r\n\t\t\tratioX = (maxX - minX) / 2;\r\n\t\t\tratioY = (maxY - minY) / 2;\r\n\t\t\toffsetX = -(maxX + minX) / 2;\r\n\t\t\toffsetY = -(maxY + minY) / 2;\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = arcs.length; i < ilen; ++i) {\r\n\t\t\tarcs[i]._options = me._resolveDataElementOptions(arcs[i], i);\r\n\t\t}\r\n\r\n\t\tchart.borderWidth = me.getMaxBorderWidth();\r\n\t\tmaxWidth = (chartArea.right - chartArea.left - chart.borderWidth) / ratioX;\r\n\t\tmaxHeight = (chartArea.bottom - chartArea.top - chart.borderWidth) / ratioY;\r\n\t\tchart.outerRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\r\n\t\tchart.innerRadius = Math.max(chart.outerRadius * cutout, 0);\r\n\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);\r\n\t\tchart.offsetX = offsetX * chart.outerRadius;\r\n\t\tchart.offsetY = offsetY * chart.outerRadius;\r\n\r\n\t\tmeta.total = me.calculateTotal();\r\n\r\n\t\tme.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);\r\n\t\tme.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);\r\n\r\n\t\tfor (i = 0, ilen = arcs.length; i < ilen; ++i) {\r\n\t\t\tme.updateElement(arcs[i], i, reset);\r\n\t\t}\r\n\t},\r\n\r\n\tupdateElement: function(arc, index, reset) {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar chartArea = chart.chartArea;\r\n\t\tvar opts = chart.options;\r\n\t\tvar animationOpts = opts.animation;\r\n\t\tvar centerX = (chartArea.left + chartArea.right) / 2;\r\n\t\tvar centerY = (chartArea.top + chartArea.bottom) / 2;\r\n\t\tvar startAngle = opts.rotation; // non reset case handled later\r\n\t\tvar endAngle = opts.rotation; // non reset case handled later\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / DOUBLE_PI$1);\r\n\t\tvar innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;\r\n\t\tvar outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;\r\n\t\tvar options = arc._options || {};\r\n\r\n\t\thelpers$1.extend(arc, {\r\n\t\t\t// Utility\r\n\t\t\t_datasetIndex: me.index,\r\n\t\t\t_index: index,\r\n\r\n\t\t\t// Desired view properties\r\n\t\t\t_model: {\r\n\t\t\t\tbackgroundColor: options.backgroundColor,\r\n\t\t\t\tborderColor: options.borderColor,\r\n\t\t\t\tborderWidth: options.borderWidth,\r\n\t\t\t\tborderAlign: options.borderAlign,\r\n\t\t\t\tx: centerX + chart.offsetX,\r\n\t\t\t\ty: centerY + chart.offsetY,\r\n\t\t\t\tstartAngle: startAngle,\r\n\t\t\t\tendAngle: endAngle,\r\n\t\t\t\tcircumference: circumference,\r\n\t\t\t\touterRadius: outerRadius,\r\n\t\t\t\tinnerRadius: innerRadius,\r\n\t\t\t\tlabel: helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tvar model = arc._model;\r\n\r\n\t\t// Set correct angles if not resetting\r\n\t\tif (!reset || !animationOpts.animateRotate) {\r\n\t\t\tif (index === 0) {\r\n\t\t\t\tmodel.startAngle = opts.rotation;\r\n\t\t\t} else {\r\n\t\t\t\tmodel.startAngle = me.getMeta().data[index - 1]._model.endAngle;\r\n\t\t\t}\r\n\r\n\t\t\tmodel.endAngle = model.startAngle + model.circumference;\r\n\t\t}\r\n\r\n\t\tarc.pivot();\r\n\t},\r\n\r\n\tcalculateTotal: function() {\r\n\t\tvar dataset = this.getDataset();\r\n\t\tvar meta = this.getMeta();\r\n\t\tvar total = 0;\r\n\t\tvar value;\r\n\r\n\t\thelpers$1.each(meta.data, function(element, index) {\r\n\t\t\tvalue = dataset.data[index];\r\n\t\t\tif (!isNaN(value) && !element.hidden) {\r\n\t\t\t\ttotal += Math.abs(value);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t/* if (total === 0) {\r\n\t\t\ttotal = NaN;\r\n\t\t}*/\r\n\r\n\t\treturn total;\r\n\t},\r\n\r\n\tcalculateCircumference: function(value) {\r\n\t\tvar total = this.getMeta().total;\r\n\t\tif (total > 0 && !isNaN(value)) {\r\n\t\t\treturn DOUBLE_PI$1 * (Math.abs(value) / total);\r\n\t\t}\r\n\t\treturn 0;\r\n\t},\r\n\r\n\t// gets the max border or hover width to properly scale pie charts\r\n\tgetMaxBorderWidth: function(arcs) {\r\n\t\tvar me = this;\r\n\t\tvar max = 0;\r\n\t\tvar chart = me.chart;\r\n\t\tvar i, ilen, meta, arc, controller, options, borderWidth, hoverWidth;\r\n\r\n\t\tif (!arcs) {\r\n\t\t\t// Find the outmost visible dataset\r\n\t\t\tfor (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\r\n\t\t\t\tif (chart.isDatasetVisible(i)) {\r\n\t\t\t\t\tmeta = chart.getDatasetMeta(i);\r\n\t\t\t\t\tarcs = meta.data;\r\n\t\t\t\t\tif (i !== me.index) {\r\n\t\t\t\t\t\tcontroller = meta.controller;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!arcs) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = arcs.length; i < ilen; ++i) {\r\n\t\t\tarc = arcs[i];\r\n\t\t\tif (controller) {\r\n\t\t\t\tcontroller._configure();\r\n\t\t\t\toptions = controller._resolveDataElementOptions(arc, i);\r\n\t\t\t} else {\r\n\t\t\t\toptions = arc._options;\r\n\t\t\t}\r\n\t\t\tif (options.borderAlign !== 'inner') {\r\n\t\t\t\tborderWidth = options.borderWidth;\r\n\t\t\t\thoverWidth = options.hoverBorderWidth;\r\n\r\n\t\t\t\tmax = borderWidth > max ? borderWidth : max;\r\n\t\t\t\tmax = hoverWidth > max ? hoverWidth : max;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn max;\r\n\t},\r\n\r\n\t/**\r\n\t * @protected\r\n\t */\r\n\tsetHoverStyle: function(arc) {\r\n\t\tvar model = arc._model;\r\n\t\tvar options = arc._options;\r\n\t\tvar getHoverColor = helpers$1.getHoverColor;\r\n\r\n\t\tarc.$previousStyle = {\r\n\t\t\tbackgroundColor: model.backgroundColor,\r\n\t\t\tborderColor: model.borderColor,\r\n\t\t\tborderWidth: model.borderWidth,\r\n\t\t};\r\n\r\n\t\tmodel.backgroundColor = valueOrDefault$5(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\r\n\t\tmodel.borderColor = valueOrDefault$5(options.hoverBorderColor, getHoverColor(options.borderColor));\r\n\t\tmodel.borderWidth = valueOrDefault$5(options.hoverBorderWidth, options.borderWidth);\r\n\t},\r\n\r\n\t/**\r\n\t * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly\r\n\t * @private\r\n\t */\r\n\t_getRingWeightOffset: function(datasetIndex) {\r\n\t\tvar ringWeightOffset = 0;\r\n\r\n\t\tfor (var i = 0; i < datasetIndex; ++i) {\r\n\t\t\tif (this.chart.isDatasetVisible(i)) {\r\n\t\t\t\tringWeightOffset += this._getRingWeight(i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn ringWeightOffset;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getRingWeight: function(dataSetIndex) {\r\n\t\treturn Math.max(valueOrDefault$5(this.chart.data.datasets[dataSetIndex].weight, 1), 0);\r\n\t},\r\n\r\n\t/**\r\n\t * Returns the sum of all visibile data set weights.  This value can be 0.\r\n\t * @private\r\n\t */\r\n\t_getVisibleDatasetWeightTotal: function() {\r\n\t\treturn this._getRingWeightOffset(this.chart.data.datasets.length);\r\n\t}\r\n});\n\ncore_defaults._set('horizontalBar', {\r\n\thover: {\r\n\t\tmode: 'index',\r\n\t\taxis: 'y'\r\n\t},\r\n\r\n\tscales: {\r\n\t\txAxes: [{\r\n\t\t\ttype: 'linear',\r\n\t\t\tposition: 'bottom'\r\n\t\t}],\r\n\r\n\t\tyAxes: [{\r\n\t\t\ttype: 'category',\r\n\t\t\tposition: 'left',\r\n\t\t\toffset: true,\r\n\t\t\tgridLines: {\r\n\t\t\t\toffsetGridLines: true\r\n\t\t\t}\r\n\t\t}]\r\n\t},\r\n\r\n\telements: {\r\n\t\trectangle: {\r\n\t\t\tborderSkipped: 'left'\r\n\t\t}\r\n\t},\r\n\r\n\ttooltips: {\r\n\t\tmode: 'index',\r\n\t\taxis: 'y'\r\n\t}\r\n});\r\n\r\ncore_defaults._set('global', {\r\n\tdatasets: {\r\n\t\thorizontalBar: {\r\n\t\t\tcategoryPercentage: 0.8,\r\n\t\t\tbarPercentage: 0.9\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar controller_horizontalBar = controller_bar.extend({\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getValueScaleId: function() {\r\n\t\treturn this.getMeta().xAxisID;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getIndexScaleId: function() {\r\n\t\treturn this.getMeta().yAxisID;\r\n\t}\r\n});\n\nvar valueOrDefault$6 = helpers$1.valueOrDefault;\r\nvar resolve$2 = helpers$1.options.resolve;\r\nvar isPointInArea = helpers$1.canvas._isPointInArea;\r\n\r\ncore_defaults._set('line', {\r\n\tshowLines: true,\r\n\tspanGaps: false,\r\n\r\n\thover: {\r\n\t\tmode: 'label'\r\n\t},\r\n\r\n\tscales: {\r\n\t\txAxes: [{\r\n\t\t\ttype: 'category',\r\n\t\t\tid: 'x-axis-0'\r\n\t\t}],\r\n\t\tyAxes: [{\r\n\t\t\ttype: 'linear',\r\n\t\t\tid: 'y-axis-0'\r\n\t\t}]\r\n\t}\r\n});\r\n\r\nfunction scaleClip(scale, halfBorderWidth) {\r\n\tvar tickOpts = scale && scale.options.ticks || {};\r\n\tvar reverse = tickOpts.reverse;\r\n\tvar min = tickOpts.min === undefined ? halfBorderWidth : 0;\r\n\tvar max = tickOpts.max === undefined ? halfBorderWidth : 0;\r\n\treturn {\r\n\t\tstart: reverse ? max : min,\r\n\t\tend: reverse ? min : max\r\n\t};\r\n}\r\n\r\nfunction defaultClip(xScale, yScale, borderWidth) {\r\n\tvar halfBorderWidth = borderWidth / 2;\r\n\tvar x = scaleClip(xScale, halfBorderWidth);\r\n\tvar y = scaleClip(yScale, halfBorderWidth);\r\n\r\n\treturn {\r\n\t\ttop: y.end,\r\n\t\tright: x.end,\r\n\t\tbottom: y.start,\r\n\t\tleft: x.start\r\n\t};\r\n}\r\n\r\nfunction toClip(value) {\r\n\tvar t, r, b, l;\r\n\r\n\tif (helpers$1.isObject(value)) {\r\n\t\tt = value.top;\r\n\t\tr = value.right;\r\n\t\tb = value.bottom;\r\n\t\tl = value.left;\r\n\t} else {\r\n\t\tt = r = b = l = value;\r\n\t}\r\n\r\n\treturn {\r\n\t\ttop: t,\r\n\t\tright: r,\r\n\t\tbottom: b,\r\n\t\tleft: l\r\n\t};\r\n}\r\n\r\n\r\nvar controller_line = core_datasetController.extend({\r\n\r\n\tdatasetElementType: elements.Line,\r\n\r\n\tdataElementType: elements.Point,\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_datasetElementOptions: [\r\n\t\t'backgroundColor',\r\n\t\t'borderCapStyle',\r\n\t\t'borderColor',\r\n\t\t'borderDash',\r\n\t\t'borderDashOffset',\r\n\t\t'borderJoinStyle',\r\n\t\t'borderWidth',\r\n\t\t'cubicInterpolationMode',\r\n\t\t'fill'\r\n\t],\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_dataElementOptions: {\r\n\t\tbackgroundColor: 'pointBackgroundColor',\r\n\t\tborderColor: 'pointBorderColor',\r\n\t\tborderWidth: 'pointBorderWidth',\r\n\t\thitRadius: 'pointHitRadius',\r\n\t\thoverBackgroundColor: 'pointHoverBackgroundColor',\r\n\t\thoverBorderColor: 'pointHoverBorderColor',\r\n\t\thoverBorderWidth: 'pointHoverBorderWidth',\r\n\t\thoverRadius: 'pointHoverRadius',\r\n\t\tpointStyle: 'pointStyle',\r\n\t\tradius: 'pointRadius',\r\n\t\trotation: 'pointRotation'\r\n\t},\r\n\r\n\tupdate: function(reset) {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar line = meta.dataset;\r\n\t\tvar points = meta.data || [];\r\n\t\tvar options = me.chart.options;\r\n\t\tvar config = me._config;\r\n\t\tvar showLine = me._showLine = valueOrDefault$6(config.showLine, options.showLines);\r\n\t\tvar i, ilen;\r\n\r\n\t\tme._xScale = me.getScaleForId(meta.xAxisID);\r\n\t\tme._yScale = me.getScaleForId(meta.yAxisID);\r\n\r\n\t\t// Update Line\r\n\t\tif (showLine) {\r\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\r\n\t\t\tif (config.tension !== undefined && config.lineTension === undefined) {\r\n\t\t\t\tconfig.lineTension = config.tension;\r\n\t\t\t}\r\n\r\n\t\t\t// Utility\r\n\t\t\tline._scale = me._yScale;\r\n\t\t\tline._datasetIndex = me.index;\r\n\t\t\t// Data\r\n\t\t\tline._children = points;\r\n\t\t\t// Model\r\n\t\t\tline._model = me._resolveDatasetElementOptions(line);\r\n\r\n\t\t\tline.pivot();\r\n\t\t}\r\n\r\n\t\t// Update Points\r\n\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\tme.updateElement(points[i], i, reset);\r\n\t\t}\r\n\r\n\t\tif (showLine && line._model.tension !== 0) {\r\n\t\t\tme.updateBezierControlPoints();\r\n\t\t}\r\n\r\n\t\t// Now pivot the point for animation\r\n\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\tpoints[i].pivot();\r\n\t\t}\r\n\t},\r\n\r\n\tupdateElement: function(point, index, reset) {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar custom = point.custom || {};\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar datasetIndex = me.index;\r\n\t\tvar value = dataset.data[index];\r\n\t\tvar xScale = me._xScale;\r\n\t\tvar yScale = me._yScale;\r\n\t\tvar lineModel = meta.dataset._model;\r\n\t\tvar x, y;\r\n\r\n\t\tvar options = me._resolveDataElementOptions(point, index);\r\n\r\n\t\tx = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);\r\n\t\ty = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);\r\n\r\n\t\t// Utility\r\n\t\tpoint._xScale = xScale;\r\n\t\tpoint._yScale = yScale;\r\n\t\tpoint._options = options;\r\n\t\tpoint._datasetIndex = datasetIndex;\r\n\t\tpoint._index = index;\r\n\r\n\t\t// Desired view properties\r\n\t\tpoint._model = {\r\n\t\t\tx: x,\r\n\t\t\ty: y,\r\n\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\r\n\t\t\t// Appearance\r\n\t\t\tradius: options.radius,\r\n\t\t\tpointStyle: options.pointStyle,\r\n\t\t\trotation: options.rotation,\r\n\t\t\tbackgroundColor: options.backgroundColor,\r\n\t\t\tborderColor: options.borderColor,\r\n\t\t\tborderWidth: options.borderWidth,\r\n\t\t\ttension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),\r\n\t\t\tsteppedLine: lineModel ? lineModel.steppedLine : false,\r\n\t\t\t// Tooltip\r\n\t\t\thitRadius: options.hitRadius\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_resolveDatasetElementOptions: function(element) {\r\n\t\tvar me = this;\r\n\t\tvar config = me._config;\r\n\t\tvar custom = element.custom || {};\r\n\t\tvar options = me.chart.options;\r\n\t\tvar lineOptions = options.elements.line;\r\n\t\tvar values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me, arguments);\r\n\r\n\t\t// The default behavior of lines is to break at null values, according\r\n\t\t// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\r\n\t\t// This option gives lines the ability to span gaps\r\n\t\tvalues.spanGaps = valueOrDefault$6(config.spanGaps, options.spanGaps);\r\n\t\tvalues.tension = valueOrDefault$6(config.lineTension, lineOptions.tension);\r\n\t\tvalues.steppedLine = resolve$2([custom.steppedLine, config.steppedLine, lineOptions.stepped]);\r\n\t\tvalues.clip = toClip(valueOrDefault$6(config.clip, defaultClip(me._xScale, me._yScale, values.borderWidth)));\r\n\r\n\t\treturn values;\r\n\t},\r\n\r\n\tcalculatePointY: function(value, index, datasetIndex) {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar yScale = me._yScale;\r\n\t\tvar sumPos = 0;\r\n\t\tvar sumNeg = 0;\r\n\t\tvar i, ds, dsMeta, stackedRightValue, rightValue, metasets, ilen;\r\n\r\n\t\tif (yScale.options.stacked) {\r\n\t\t\trightValue = +yScale.getRightValue(value);\r\n\t\t\tmetasets = chart._getSortedVisibleDatasetMetas();\r\n\t\t\tilen = metasets.length;\r\n\r\n\t\t\tfor (i = 0; i < ilen; ++i) {\r\n\t\t\t\tdsMeta = metasets[i];\r\n\t\t\t\tif (dsMeta.index === datasetIndex) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tds = chart.data.datasets[dsMeta.index];\r\n\t\t\t\tif (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id) {\r\n\t\t\t\t\tstackedRightValue = +yScale.getRightValue(ds.data[index]);\r\n\t\t\t\t\tif (stackedRightValue < 0) {\r\n\t\t\t\t\t\tsumNeg += stackedRightValue || 0;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tsumPos += stackedRightValue || 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (rightValue < 0) {\r\n\t\t\t\treturn yScale.getPixelForValue(sumNeg + rightValue);\r\n\t\t\t}\r\n\t\t\treturn yScale.getPixelForValue(sumPos + rightValue);\r\n\t\t}\r\n\t\treturn yScale.getPixelForValue(value);\r\n\t},\r\n\r\n\tupdateBezierControlPoints: function() {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar lineModel = meta.dataset._model;\r\n\t\tvar area = chart.chartArea;\r\n\t\tvar points = meta.data || [];\r\n\t\tvar i, ilen, model, controlPoints;\r\n\r\n\t\t// Only consider points that are drawn in case the spanGaps option is used\r\n\t\tif (lineModel.spanGaps) {\r\n\t\t\tpoints = points.filter(function(pt) {\r\n\t\t\t\treturn !pt._model.skip;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfunction capControlPoint(pt, min, max) {\r\n\t\t\treturn Math.max(Math.min(pt, max), min);\r\n\t\t}\r\n\r\n\t\tif (lineModel.cubicInterpolationMode === 'monotone') {\r\n\t\t\thelpers$1.splineCurveMonotone(points);\r\n\t\t} else {\r\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\t\tmodel = points[i]._model;\r\n\t\t\t\tcontrolPoints = helpers$1.splineCurve(\r\n\t\t\t\t\thelpers$1.previousItem(points, i)._model,\r\n\t\t\t\t\tmodel,\r\n\t\t\t\t\thelpers$1.nextItem(points, i)._model,\r\n\t\t\t\t\tlineModel.tension\r\n\t\t\t\t);\r\n\t\t\t\tmodel.controlPointPreviousX = controlPoints.previous.x;\r\n\t\t\t\tmodel.controlPointPreviousY = controlPoints.previous.y;\r\n\t\t\t\tmodel.controlPointNextX = controlPoints.next.x;\r\n\t\t\t\tmodel.controlPointNextY = controlPoints.next.y;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (chart.options.elements.line.capBezierPoints) {\r\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\t\tmodel = points[i]._model;\r\n\t\t\t\tif (isPointInArea(model, area)) {\r\n\t\t\t\t\tif (i > 0 && isPointInArea(points[i - 1]._model, area)) {\r\n\t\t\t\t\t\tmodel.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\r\n\t\t\t\t\t\tmodel.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {\r\n\t\t\t\t\t\tmodel.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\r\n\t\t\t\t\t\tmodel.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tdraw: function() {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar points = meta.data || [];\r\n\t\tvar area = chart.chartArea;\r\n\t\tvar canvas = chart.canvas;\r\n\t\tvar i = 0;\r\n\t\tvar ilen = points.length;\r\n\t\tvar clip;\r\n\r\n\t\tif (me._showLine) {\r\n\t\t\tclip = meta.dataset._model.clip;\r\n\r\n\t\t\thelpers$1.canvas.clipArea(chart.ctx, {\r\n\t\t\t\tleft: clip.left === false ? 0 : area.left - clip.left,\r\n\t\t\t\tright: clip.right === false ? canvas.width : area.right + clip.right,\r\n\t\t\t\ttop: clip.top === false ? 0 : area.top - clip.top,\r\n\t\t\t\tbottom: clip.bottom === false ? canvas.height : area.bottom + clip.bottom\r\n\t\t\t});\r\n\r\n\t\t\tmeta.dataset.draw();\r\n\r\n\t\t\thelpers$1.canvas.unclipArea(chart.ctx);\r\n\t\t}\r\n\r\n\t\t// Draw the points\r\n\t\tfor (; i < ilen; ++i) {\r\n\t\t\tpoints[i].draw(area);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * @protected\r\n\t */\r\n\tsetHoverStyle: function(point) {\r\n\t\tvar model = point._model;\r\n\t\tvar options = point._options;\r\n\t\tvar getHoverColor = helpers$1.getHoverColor;\r\n\r\n\t\tpoint.$previousStyle = {\r\n\t\t\tbackgroundColor: model.backgroundColor,\r\n\t\t\tborderColor: model.borderColor,\r\n\t\t\tborderWidth: model.borderWidth,\r\n\t\t\tradius: model.radius\r\n\t\t};\r\n\r\n\t\tmodel.backgroundColor = valueOrDefault$6(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\r\n\t\tmodel.borderColor = valueOrDefault$6(options.hoverBorderColor, getHoverColor(options.borderColor));\r\n\t\tmodel.borderWidth = valueOrDefault$6(options.hoverBorderWidth, options.borderWidth);\r\n\t\tmodel.radius = valueOrDefault$6(options.hoverRadius, options.radius);\r\n\t},\r\n});\n\nvar resolve$3 = helpers$1.options.resolve;\r\n\r\ncore_defaults._set('polarArea', {\r\n\tscale: {\r\n\t\ttype: 'radialLinear',\r\n\t\tangleLines: {\r\n\t\t\tdisplay: false\r\n\t\t},\r\n\t\tgridLines: {\r\n\t\t\tcircular: true\r\n\t\t},\r\n\t\tpointLabels: {\r\n\t\t\tdisplay: false\r\n\t\t},\r\n\t\tticks: {\r\n\t\t\tbeginAtZero: true\r\n\t\t}\r\n\t},\r\n\r\n\t// Boolean - Whether to animate the rotation of the chart\r\n\tanimation: {\r\n\t\tanimateRotate: true,\r\n\t\tanimateScale: true\r\n\t},\r\n\r\n\tstartAngle: -0.5 * Math.PI,\r\n\tlegendCallback: function(chart) {\r\n\t\tvar list = document.createElement('ul');\r\n\t\tvar data = chart.data;\r\n\t\tvar datasets = data.datasets;\r\n\t\tvar labels = data.labels;\r\n\t\tvar i, ilen, listItem, listItemSpan;\r\n\r\n\t\tlist.setAttribute('class', chart.id + '-legend');\r\n\t\tif (datasets.length) {\r\n\t\t\tfor (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {\r\n\t\t\t\tlistItem = list.appendChild(document.createElement('li'));\r\n\t\t\t\tlistItemSpan = listItem.appendChild(document.createElement('span'));\r\n\t\t\t\tlistItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];\r\n\t\t\t\tif (labels[i]) {\r\n\t\t\t\t\tlistItem.appendChild(document.createTextNode(labels[i]));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn list.outerHTML;\r\n\t},\r\n\tlegend: {\r\n\t\tlabels: {\r\n\t\t\tgenerateLabels: function(chart) {\r\n\t\t\t\tvar data = chart.data;\r\n\t\t\t\tif (data.labels.length && data.datasets.length) {\r\n\t\t\t\t\treturn data.labels.map(function(label, i) {\r\n\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\r\n\t\t\t\t\t\tvar style = meta.controller.getStyle(i);\r\n\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\ttext: label,\r\n\t\t\t\t\t\t\tfillStyle: style.backgroundColor,\r\n\t\t\t\t\t\t\tstrokeStyle: style.borderColor,\r\n\t\t\t\t\t\t\tlineWidth: style.borderWidth,\r\n\t\t\t\t\t\t\thidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,\r\n\r\n\t\t\t\t\t\t\t// Extra data used for toggling the correct item\r\n\t\t\t\t\t\t\tindex: i\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\treturn [];\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tonClick: function(e, legendItem) {\r\n\t\t\tvar index = legendItem.index;\r\n\t\t\tvar chart = this.chart;\r\n\t\t\tvar i, ilen, meta;\r\n\r\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\r\n\t\t\t\tmeta = chart.getDatasetMeta(i);\r\n\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\r\n\t\t\t}\r\n\r\n\t\t\tchart.update();\r\n\t\t}\r\n\t},\r\n\r\n\t// Need to override these to give a nice default\r\n\ttooltips: {\r\n\t\tcallbacks: {\r\n\t\t\ttitle: function() {\r\n\t\t\t\treturn '';\r\n\t\t\t},\r\n\t\t\tlabel: function(item, data) {\r\n\t\t\t\treturn data.labels[item.index] + ': ' + item.yLabel;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar controller_polarArea = core_datasetController.extend({\r\n\r\n\tdataElementType: elements.Arc,\r\n\r\n\tlinkScales: helpers$1.noop,\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_dataElementOptions: [\r\n\t\t'backgroundColor',\r\n\t\t'borderColor',\r\n\t\t'borderWidth',\r\n\t\t'borderAlign',\r\n\t\t'hoverBackgroundColor',\r\n\t\t'hoverBorderColor',\r\n\t\t'hoverBorderWidth',\r\n\t],\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getIndexScaleId: function() {\r\n\t\treturn this.chart.scale.id;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getValueScaleId: function() {\r\n\t\treturn this.chart.scale.id;\r\n\t},\r\n\r\n\tupdate: function(reset) {\r\n\t\tvar me = this;\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar start = me.chart.options.startAngle || 0;\r\n\t\tvar starts = me._starts = [];\r\n\t\tvar angles = me._angles = [];\r\n\t\tvar arcs = meta.data;\r\n\t\tvar i, ilen, angle;\r\n\r\n\t\tme._updateRadius();\r\n\r\n\t\tmeta.count = me.countVisibleElements();\r\n\r\n\t\tfor (i = 0, ilen = dataset.data.length; i < ilen; i++) {\r\n\t\t\tstarts[i] = start;\r\n\t\t\tangle = me._computeAngle(i);\r\n\t\t\tangles[i] = angle;\r\n\t\t\tstart += angle;\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = arcs.length; i < ilen; ++i) {\r\n\t\t\tarcs[i]._options = me._resolveDataElementOptions(arcs[i], i);\r\n\t\t\tme.updateElement(arcs[i], i, reset);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_updateRadius: function() {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar chartArea = chart.chartArea;\r\n\t\tvar opts = chart.options;\r\n\t\tvar minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\r\n\r\n\t\tchart.outerRadius = Math.max(minSize / 2, 0);\r\n\t\tchart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\r\n\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\r\n\r\n\t\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);\r\n\t\tme.innerRadius = me.outerRadius - chart.radiusLength;\r\n\t},\r\n\r\n\tupdateElement: function(arc, index, reset) {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar opts = chart.options;\r\n\t\tvar animationOpts = opts.animation;\r\n\t\tvar scale = chart.scale;\r\n\t\tvar labels = chart.data.labels;\r\n\r\n\t\tvar centerX = scale.xCenter;\r\n\t\tvar centerY = scale.yCenter;\r\n\r\n\t\t// var negHalfPI = -0.5 * Math.PI;\r\n\t\tvar datasetStartAngle = opts.startAngle;\r\n\t\tvar distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\r\n\t\tvar startAngle = me._starts[index];\r\n\t\tvar endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);\r\n\r\n\t\tvar resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\r\n\t\tvar options = arc._options || {};\r\n\r\n\t\thelpers$1.extend(arc, {\r\n\t\t\t// Utility\r\n\t\t\t_datasetIndex: me.index,\r\n\t\t\t_index: index,\r\n\t\t\t_scale: scale,\r\n\r\n\t\t\t// Desired view properties\r\n\t\t\t_model: {\r\n\t\t\t\tbackgroundColor: options.backgroundColor,\r\n\t\t\t\tborderColor: options.borderColor,\r\n\t\t\t\tborderWidth: options.borderWidth,\r\n\t\t\t\tborderAlign: options.borderAlign,\r\n\t\t\t\tx: centerX,\r\n\t\t\t\ty: centerY,\r\n\t\t\t\tinnerRadius: 0,\r\n\t\t\t\touterRadius: reset ? resetRadius : distance,\r\n\t\t\t\tstartAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,\r\n\t\t\t\tendAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,\r\n\t\t\t\tlabel: helpers$1.valueAtIndexOrDefault(labels, index, labels[index])\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tarc.pivot();\r\n\t},\r\n\r\n\tcountVisibleElements: function() {\r\n\t\tvar dataset = this.getDataset();\r\n\t\tvar meta = this.getMeta();\r\n\t\tvar count = 0;\r\n\r\n\t\thelpers$1.each(meta.data, function(element, index) {\r\n\t\t\tif (!isNaN(dataset.data[index]) && !element.hidden) {\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn count;\r\n\t},\r\n\r\n\t/**\r\n\t * @protected\r\n\t */\r\n\tsetHoverStyle: function(arc) {\r\n\t\tvar model = arc._model;\r\n\t\tvar options = arc._options;\r\n\t\tvar getHoverColor = helpers$1.getHoverColor;\r\n\t\tvar valueOrDefault = helpers$1.valueOrDefault;\r\n\r\n\t\tarc.$previousStyle = {\r\n\t\t\tbackgroundColor: model.backgroundColor,\r\n\t\t\tborderColor: model.borderColor,\r\n\t\t\tborderWidth: model.borderWidth,\r\n\t\t};\r\n\r\n\t\tmodel.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\r\n\t\tmodel.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));\r\n\t\tmodel.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_computeAngle: function(index) {\r\n\t\tvar me = this;\r\n\t\tvar count = this.getMeta().count;\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar meta = me.getMeta();\r\n\r\n\t\tif (isNaN(dataset.data[index]) || meta.data[index].hidden) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// Scriptable options\r\n\t\tvar context = {\r\n\t\t\tchart: me.chart,\r\n\t\t\tdataIndex: index,\r\n\t\t\tdataset: dataset,\r\n\t\t\tdatasetIndex: me.index\r\n\t\t};\r\n\r\n\t\treturn resolve$3([\r\n\t\t\tme.chart.options.elements.arc.angle,\r\n\t\t\t(2 * Math.PI) / count\r\n\t\t], context, index);\r\n\t}\r\n});\n\ncore_defaults._set('pie', helpers$1.clone(core_defaults.doughnut));\r\ncore_defaults._set('pie', {\r\n\tcutoutPercentage: 0\r\n});\r\n\r\n// Pie charts are Doughnut chart with different defaults\r\nvar controller_pie = controller_doughnut;\n\nvar valueOrDefault$7 = helpers$1.valueOrDefault;\r\n\r\ncore_defaults._set('radar', {\r\n\tspanGaps: false,\r\n\tscale: {\r\n\t\ttype: 'radialLinear'\r\n\t},\r\n\telements: {\r\n\t\tline: {\r\n\t\t\tfill: 'start',\r\n\t\t\ttension: 0 // no bezier in radar\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar controller_radar = core_datasetController.extend({\r\n\tdatasetElementType: elements.Line,\r\n\r\n\tdataElementType: elements.Point,\r\n\r\n\tlinkScales: helpers$1.noop,\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_datasetElementOptions: [\r\n\t\t'backgroundColor',\r\n\t\t'borderWidth',\r\n\t\t'borderColor',\r\n\t\t'borderCapStyle',\r\n\t\t'borderDash',\r\n\t\t'borderDashOffset',\r\n\t\t'borderJoinStyle',\r\n\t\t'fill'\r\n\t],\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_dataElementOptions: {\r\n\t\tbackgroundColor: 'pointBackgroundColor',\r\n\t\tborderColor: 'pointBorderColor',\r\n\t\tborderWidth: 'pointBorderWidth',\r\n\t\thitRadius: 'pointHitRadius',\r\n\t\thoverBackgroundColor: 'pointHoverBackgroundColor',\r\n\t\thoverBorderColor: 'pointHoverBorderColor',\r\n\t\thoverBorderWidth: 'pointHoverBorderWidth',\r\n\t\thoverRadius: 'pointHoverRadius',\r\n\t\tpointStyle: 'pointStyle',\r\n\t\tradius: 'pointRadius',\r\n\t\trotation: 'pointRotation'\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getIndexScaleId: function() {\r\n\t\treturn this.chart.scale.id;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getValueScaleId: function() {\r\n\t\treturn this.chart.scale.id;\r\n\t},\r\n\r\n\tupdate: function(reset) {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar line = meta.dataset;\r\n\t\tvar points = meta.data || [];\r\n\t\tvar scale = me.chart.scale;\r\n\t\tvar config = me._config;\r\n\t\tvar i, ilen;\r\n\r\n\t\t// Compatibility: If the properties are defined with only the old name, use those values\r\n\t\tif (config.tension !== undefined && config.lineTension === undefined) {\r\n\t\t\tconfig.lineTension = config.tension;\r\n\t\t}\r\n\r\n\t\t// Utility\r\n\t\tline._scale = scale;\r\n\t\tline._datasetIndex = me.index;\r\n\t\t// Data\r\n\t\tline._children = points;\r\n\t\tline._loop = true;\r\n\t\t// Model\r\n\t\tline._model = me._resolveDatasetElementOptions(line);\r\n\r\n\t\tline.pivot();\r\n\r\n\t\t// Update Points\r\n\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\tme.updateElement(points[i], i, reset);\r\n\t\t}\r\n\r\n\t\t// Update bezier control points\r\n\t\tme.updateBezierControlPoints();\r\n\r\n\t\t// Now pivot the point for animation\r\n\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\tpoints[i].pivot();\r\n\t\t}\r\n\t},\r\n\r\n\tupdateElement: function(point, index, reset) {\r\n\t\tvar me = this;\r\n\t\tvar custom = point.custom || {};\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar scale = me.chart.scale;\r\n\t\tvar pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);\r\n\t\tvar options = me._resolveDataElementOptions(point, index);\r\n\t\tvar lineModel = me.getMeta().dataset._model;\r\n\t\tvar x = reset ? scale.xCenter : pointPosition.x;\r\n\t\tvar y = reset ? scale.yCenter : pointPosition.y;\r\n\r\n\t\t// Utility\r\n\t\tpoint._scale = scale;\r\n\t\tpoint._options = options;\r\n\t\tpoint._datasetIndex = me.index;\r\n\t\tpoint._index = index;\r\n\r\n\t\t// Desired view properties\r\n\t\tpoint._model = {\r\n\t\t\tx: x, // value not used in dataset scale, but we want a consistent API between scales\r\n\t\t\ty: y,\r\n\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\r\n\t\t\t// Appearance\r\n\t\t\tradius: options.radius,\r\n\t\t\tpointStyle: options.pointStyle,\r\n\t\t\trotation: options.rotation,\r\n\t\t\tbackgroundColor: options.backgroundColor,\r\n\t\t\tborderColor: options.borderColor,\r\n\t\t\tborderWidth: options.borderWidth,\r\n\t\t\ttension: valueOrDefault$7(custom.tension, lineModel ? lineModel.tension : 0),\r\n\r\n\t\t\t// Tooltip\r\n\t\t\thitRadius: options.hitRadius\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_resolveDatasetElementOptions: function() {\r\n\t\tvar me = this;\r\n\t\tvar config = me._config;\r\n\t\tvar options = me.chart.options;\r\n\t\tvar values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me, arguments);\r\n\r\n\t\tvalues.spanGaps = valueOrDefault$7(config.spanGaps, options.spanGaps);\r\n\t\tvalues.tension = valueOrDefault$7(config.lineTension, options.elements.line.tension);\r\n\r\n\t\treturn values;\r\n\t},\r\n\r\n\tupdateBezierControlPoints: function() {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar area = me.chart.chartArea;\r\n\t\tvar points = meta.data || [];\r\n\t\tvar i, ilen, model, controlPoints;\r\n\r\n\t\t// Only consider points that are drawn in case the spanGaps option is used\r\n\t\tif (meta.dataset._model.spanGaps) {\r\n\t\t\tpoints = points.filter(function(pt) {\r\n\t\t\t\treturn !pt._model.skip;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfunction capControlPoint(pt, min, max) {\r\n\t\t\treturn Math.max(Math.min(pt, max), min);\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\tmodel = points[i]._model;\r\n\t\t\tcontrolPoints = helpers$1.splineCurve(\r\n\t\t\t\thelpers$1.previousItem(points, i, true)._model,\r\n\t\t\t\tmodel,\r\n\t\t\t\thelpers$1.nextItem(points, i, true)._model,\r\n\t\t\t\tmodel.tension\r\n\t\t\t);\r\n\r\n\t\t\t// Prevent the bezier going outside of the bounds of the graph\r\n\t\t\tmodel.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);\r\n\t\t\tmodel.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);\r\n\t\t\tmodel.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);\r\n\t\t\tmodel.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);\r\n\t\t}\r\n\t},\r\n\r\n\tsetHoverStyle: function(point) {\r\n\t\tvar model = point._model;\r\n\t\tvar options = point._options;\r\n\t\tvar getHoverColor = helpers$1.getHoverColor;\r\n\r\n\t\tpoint.$previousStyle = {\r\n\t\t\tbackgroundColor: model.backgroundColor,\r\n\t\t\tborderColor: model.borderColor,\r\n\t\t\tborderWidth: model.borderWidth,\r\n\t\t\tradius: model.radius\r\n\t\t};\r\n\r\n\t\tmodel.backgroundColor = valueOrDefault$7(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\r\n\t\tmodel.borderColor = valueOrDefault$7(options.hoverBorderColor, getHoverColor(options.borderColor));\r\n\t\tmodel.borderWidth = valueOrDefault$7(options.hoverBorderWidth, options.borderWidth);\r\n\t\tmodel.radius = valueOrDefault$7(options.hoverRadius, options.radius);\r\n\t}\r\n});\n\ncore_defaults._set('scatter', {\r\n\thover: {\r\n\t\tmode: 'single'\r\n\t},\r\n\r\n\tscales: {\r\n\t\txAxes: [{\r\n\t\t\tid: 'x-axis-1',    // need an ID so datasets can reference the scale\r\n\t\t\ttype: 'linear',    // scatter should not use a category axis\r\n\t\t\tposition: 'bottom'\r\n\t\t}],\r\n\t\tyAxes: [{\r\n\t\t\tid: 'y-axis-1',\r\n\t\t\ttype: 'linear',\r\n\t\t\tposition: 'left'\r\n\t\t}]\r\n\t},\r\n\r\n\ttooltips: {\r\n\t\tcallbacks: {\r\n\t\t\ttitle: function() {\r\n\t\t\t\treturn '';     // doesn't make sense for scatter since data are formatted as a point\r\n\t\t\t},\r\n\t\t\tlabel: function(item) {\r\n\t\t\t\treturn '(' + item.xLabel + ', ' + item.yLabel + ')';\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\ncore_defaults._set('global', {\r\n\tdatasets: {\r\n\t\tscatter: {\r\n\t\t\tshowLine: false\r\n\t\t}\r\n\t}\r\n});\r\n\r\n// Scatter charts use line controllers\r\nvar controller_scatter = controller_line;\n\n// NOTE export a map in which the key represents the controller type, not\r\n// the class, and so must be CamelCase in order to be correctly retrieved\r\n// by the controller in core.controller.js (`controllers[meta.type]`).\r\n\r\nvar controllers = {\r\n\tbar: controller_bar,\r\n\tbubble: controller_bubble,\r\n\tdoughnut: controller_doughnut,\r\n\thorizontalBar: controller_horizontalBar,\r\n\tline: controller_line,\r\n\tpolarArea: controller_polarArea,\r\n\tpie: controller_pie,\r\n\tradar: controller_radar,\r\n\tscatter: controller_scatter\r\n};\n\n/**\r\n * Helper function to get relative position for an event\r\n * @param {Event|IEvent} event - The event to get the position for\r\n * @param {Chart} chart - The chart\r\n * @returns {object} the event position\r\n */\r\nfunction getRelativePosition(e, chart) {\r\n\tif (e.native) {\r\n\t\treturn {\r\n\t\t\tx: e.x,\r\n\t\t\ty: e.y\r\n\t\t};\r\n\t}\r\n\r\n\treturn helpers$1.getRelativePosition(e, chart);\r\n}\r\n\r\n/**\r\n * Helper function to traverse all of the visible elements in the chart\r\n * @param {Chart} chart - the chart\r\n * @param {function} handler - the callback to execute for each visible item\r\n */\r\nfunction parseVisibleItems(chart, handler) {\r\n\tvar metasets = chart._getSortedVisibleDatasetMetas();\r\n\tvar metadata, i, j, ilen, jlen, element;\r\n\r\n\tfor (i = 0, ilen = metasets.length; i < ilen; ++i) {\r\n\t\tmetadata = metasets[i].data;\r\n\t\tfor (j = 0, jlen = metadata.length; j < jlen; ++j) {\r\n\t\t\telement = metadata[j];\r\n\t\t\tif (!element._view.skip) {\r\n\t\t\t\thandler(element);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Helper function to get the items that intersect the event position\r\n * @param {ChartElement[]} items - elements to filter\r\n * @param {object} position - the point to be nearest to\r\n * @return {ChartElement[]} the nearest items\r\n */\r\nfunction getIntersectItems(chart, position) {\r\n\tvar elements = [];\r\n\r\n\tparseVisibleItems(chart, function(element) {\r\n\t\tif (element.inRange(position.x, position.y)) {\r\n\t\t\telements.push(element);\r\n\t\t}\r\n\t});\r\n\r\n\treturn elements;\r\n}\r\n\r\n/**\r\n * Helper function to get the items nearest to the event position considering all visible items in teh chart\r\n * @param {Chart} chart - the chart to look at elements from\r\n * @param {object} position - the point to be nearest to\r\n * @param {boolean} intersect - if true, only consider items that intersect the position\r\n * @param {function} distanceMetric - function to provide the distance between points\r\n * @return {ChartElement[]} the nearest items\r\n */\r\nfunction getNearestItems(chart, position, intersect, distanceMetric) {\r\n\tvar minDistance = Number.POSITIVE_INFINITY;\r\n\tvar nearestItems = [];\r\n\r\n\tparseVisibleItems(chart, function(element) {\r\n\t\tif (intersect && !element.inRange(position.x, position.y)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar center = element.getCenterPoint();\r\n\t\tvar distance = distanceMetric(position, center);\r\n\t\tif (distance < minDistance) {\r\n\t\t\tnearestItems = [element];\r\n\t\t\tminDistance = distance;\r\n\t\t} else if (distance === minDistance) {\r\n\t\t\t// Can have multiple items at the same distance in which case we sort by size\r\n\t\t\tnearestItems.push(element);\r\n\t\t}\r\n\t});\r\n\r\n\treturn nearestItems;\r\n}\r\n\r\n/**\r\n * Get a distance metric function for two points based on the\r\n * axis mode setting\r\n * @param {string} axis - the axis mode. x|y|xy\r\n */\r\nfunction getDistanceMetricForAxis(axis) {\r\n\tvar useX = axis.indexOf('x') !== -1;\r\n\tvar useY = axis.indexOf('y') !== -1;\r\n\r\n\treturn function(pt1, pt2) {\r\n\t\tvar deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\r\n\t\tvar deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\r\n\t\treturn Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\r\n\t};\r\n}\r\n\r\nfunction indexMode(chart, e, options) {\r\n\tvar position = getRelativePosition(e, chart);\r\n\t// Default axis for index mode is 'x' to match old behaviour\r\n\toptions.axis = options.axis || 'x';\r\n\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\r\n\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\r\n\tvar elements = [];\r\n\r\n\tif (!items.length) {\r\n\t\treturn [];\r\n\t}\r\n\r\n\tchart._getSortedVisibleDatasetMetas().forEach(function(meta) {\r\n\t\tvar element = meta.data[items[0]._index];\r\n\r\n\t\t// don't count items that are skipped (null data)\r\n\t\tif (element && !element._view.skip) {\r\n\t\t\telements.push(element);\r\n\t\t}\r\n\t});\r\n\r\n\treturn elements;\r\n}\r\n\r\n/**\r\n * @interface IInteractionOptions\r\n */\r\n/**\r\n * If true, only consider items that intersect the point\r\n * @name IInterfaceOptions#boolean\r\n * @type Boolean\r\n */\r\n\r\n/**\r\n * Contains interaction related functions\r\n * @namespace Chart.Interaction\r\n */\r\nvar core_interaction = {\r\n\t// Helper function for different modes\r\n\tmodes: {\r\n\t\tsingle: function(chart, e) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\tvar elements = [];\r\n\r\n\t\t\tparseVisibleItems(chart, function(element) {\r\n\t\t\t\tif (element.inRange(position.x, position.y)) {\r\n\t\t\t\t\telements.push(element);\r\n\t\t\t\t\treturn elements;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn elements.slice(0, 1);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * @function Chart.Interaction.modes.label\r\n\t\t * @deprecated since version 2.4.0\r\n\t\t * @todo remove at version 3\r\n\t\t * @private\r\n\t\t */\r\n\t\tlabel: indexMode,\r\n\r\n\t\t/**\r\n\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\r\n\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\r\n\t\t * @function Chart.Interaction.modes.index\r\n\t\t * @since v2.4.0\r\n\t\t * @param {Chart} chart - the chart we are returning items from\r\n\t\t * @param {Event} e - the event we are find things at\r\n\t\t * @param {IInteractionOptions} options - options to use during interaction\r\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n\t\t */\r\n\t\tindex: indexMode,\r\n\r\n\t\t/**\r\n\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\r\n\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\r\n\t\t * @function Chart.Interaction.modes.dataset\r\n\t\t * @param {Chart} chart - the chart we are returning items from\r\n\t\t * @param {Event} e - the event we are find things at\r\n\t\t * @param {IInteractionOptions} options - options to use during interaction\r\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n\t\t */\r\n\t\tdataset: function(chart, e, options) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\toptions.axis = options.axis || 'xy';\r\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\r\n\t\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\r\n\r\n\t\t\tif (items.length > 0) {\r\n\t\t\t\titems = chart.getDatasetMeta(items[0]._datasetIndex).data;\r\n\t\t\t}\r\n\r\n\t\t\treturn items;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * @function Chart.Interaction.modes.x-axis\r\n\t\t * @deprecated since version 2.4.0. Use index mode and intersect == true\r\n\t\t * @todo remove at version 3\r\n\t\t * @private\r\n\t\t */\r\n\t\t'x-axis': function(chart, e) {\r\n\t\t\treturn indexMode(chart, e, {intersect: false});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Point mode returns all elements that hit test based on the event position\r\n\t\t * of the event\r\n\t\t * @function Chart.Interaction.modes.intersect\r\n\t\t * @param {Chart} chart - the chart we are returning items from\r\n\t\t * @param {Event} e - the event we are find things at\r\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n\t\t */\r\n\t\tpoint: function(chart, e) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\treturn getIntersectItems(chart, position);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * nearest mode returns the element closest to the point\r\n\t\t * @function Chart.Interaction.modes.intersect\r\n\t\t * @param {Chart} chart - the chart we are returning items from\r\n\t\t * @param {Event} e - the event we are find things at\r\n\t\t * @param {IInteractionOptions} options - options to use\r\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n\t\t */\r\n\t\tnearest: function(chart, e, options) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\toptions.axis = options.axis || 'xy';\r\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\r\n\t\t\treturn getNearestItems(chart, position, options.intersect, distanceMetric);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * x mode returns the elements that hit-test at the current x coordinate\r\n\t\t * @function Chart.Interaction.modes.x\r\n\t\t * @param {Chart} chart - the chart we are returning items from\r\n\t\t * @param {Event} e - the event we are find things at\r\n\t\t * @param {IInteractionOptions} options - options to use\r\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n\t\t */\r\n\t\tx: function(chart, e, options) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\tvar items = [];\r\n\t\t\tvar intersectsItem = false;\r\n\r\n\t\t\tparseVisibleItems(chart, function(element) {\r\n\t\t\t\tif (element.inXRange(position.x)) {\r\n\t\t\t\t\titems.push(element);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (element.inRange(position.x, position.y)) {\r\n\t\t\t\t\tintersectsItem = true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t// If we want to trigger on an intersect and we don't have any items\r\n\t\t\t// that intersect the position, return nothing\r\n\t\t\tif (options.intersect && !intersectsItem) {\r\n\t\t\t\titems = [];\r\n\t\t\t}\r\n\t\t\treturn items;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * y mode returns the elements that hit-test at the current y coordinate\r\n\t\t * @function Chart.Interaction.modes.y\r\n\t\t * @param {Chart} chart - the chart we are returning items from\r\n\t\t * @param {Event} e - the event we are find things at\r\n\t\t * @param {IInteractionOptions} options - options to use\r\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n\t\t */\r\n\t\ty: function(chart, e, options) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\tvar items = [];\r\n\t\t\tvar intersectsItem = false;\r\n\r\n\t\t\tparseVisibleItems(chart, function(element) {\r\n\t\t\t\tif (element.inYRange(position.y)) {\r\n\t\t\t\t\titems.push(element);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (element.inRange(position.x, position.y)) {\r\n\t\t\t\t\tintersectsItem = true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t// If we want to trigger on an intersect and we don't have any items\r\n\t\t\t// that intersect the position, return nothing\r\n\t\t\tif (options.intersect && !intersectsItem) {\r\n\t\t\t\titems = [];\r\n\t\t\t}\r\n\t\t\treturn items;\r\n\t\t}\r\n\t}\r\n};\n\nvar extend = helpers$1.extend;\r\n\r\nfunction filterByPosition(array, position) {\r\n\treturn helpers$1.where(array, function(v) {\r\n\t\treturn v.pos === position;\r\n\t});\r\n}\r\n\r\nfunction sortByWeight(array, reverse) {\r\n\treturn array.sort(function(a, b) {\r\n\t\tvar v0 = reverse ? b : a;\r\n\t\tvar v1 = reverse ? a : b;\r\n\t\treturn v0.weight === v1.weight ?\r\n\t\t\tv0.index - v1.index :\r\n\t\t\tv0.weight - v1.weight;\r\n\t});\r\n}\r\n\r\nfunction wrapBoxes(boxes) {\r\n\tvar layoutBoxes = [];\r\n\tvar i, ilen, box;\r\n\r\n\tfor (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\r\n\t\tbox = boxes[i];\r\n\t\tlayoutBoxes.push({\r\n\t\t\tindex: i,\r\n\t\t\tbox: box,\r\n\t\t\tpos: box.position,\r\n\t\t\thorizontal: box.isHorizontal(),\r\n\t\t\tweight: box.weight\r\n\t\t});\r\n\t}\r\n\treturn layoutBoxes;\r\n}\r\n\r\nfunction setLayoutDims(layouts, params) {\r\n\tvar i, ilen, layout;\r\n\tfor (i = 0, ilen = layouts.length; i < ilen; ++i) {\r\n\t\tlayout = layouts[i];\r\n\t\t// store width used instead of chartArea.w in fitBoxes\r\n\t\tlayout.width = layout.horizontal\r\n\t\t\t? layout.box.fullWidth && params.availableWidth\r\n\t\t\t: params.vBoxMaxWidth;\r\n\t\t// store height used instead of chartArea.h in fitBoxes\r\n\t\tlayout.height = layout.horizontal && params.hBoxMaxHeight;\r\n\t}\r\n}\r\n\r\nfunction buildLayoutBoxes(boxes) {\r\n\tvar layoutBoxes = wrapBoxes(boxes);\r\n\tvar left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\r\n\tvar right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\r\n\tvar top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\r\n\tvar bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\r\n\r\n\treturn {\r\n\t\tleftAndTop: left.concat(top),\r\n\t\trightAndBottom: right.concat(bottom),\r\n\t\tchartArea: filterByPosition(layoutBoxes, 'chartArea'),\r\n\t\tvertical: left.concat(right),\r\n\t\thorizontal: top.concat(bottom)\r\n\t};\r\n}\r\n\r\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\r\n\treturn Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\r\n}\r\n\r\nfunction updateDims(chartArea, params, layout) {\r\n\tvar box = layout.box;\r\n\tvar maxPadding = chartArea.maxPadding;\r\n\tvar newWidth, newHeight;\r\n\r\n\tif (layout.size) {\r\n\t\t// this layout was already counted for, lets first reduce old size\r\n\t\tchartArea[layout.pos] -= layout.size;\r\n\t}\r\n\tlayout.size = layout.horizontal ? box.height : box.width;\r\n\tchartArea[layout.pos] += layout.size;\r\n\r\n\tif (box.getPadding) {\r\n\t\tvar boxPadding = box.getPadding();\r\n\t\tmaxPadding.top = Math.max(maxPadding.top, boxPadding.top);\r\n\t\tmaxPadding.left = Math.max(maxPadding.left, boxPadding.left);\r\n\t\tmaxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\r\n\t\tmaxPadding.right = Math.max(maxPadding.right, boxPadding.right);\r\n\t}\r\n\r\n\tnewWidth = params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right');\r\n\tnewHeight = params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom');\r\n\r\n\tif (newWidth !== chartArea.w || newHeight !== chartArea.h) {\r\n\t\tchartArea.w = newWidth;\r\n\t\tchartArea.h = newHeight;\r\n\r\n\t\t// return true if chart area changed in layout's direction\r\n\t\tvar sizes = layout.horizontal ? [newWidth, chartArea.w] : [newHeight, chartArea.h];\r\n\t\treturn sizes[0] !== sizes[1] && (!isNaN(sizes[0]) || !isNaN(sizes[1]));\r\n\t}\r\n}\r\n\r\nfunction handleMaxPadding(chartArea) {\r\n\tvar maxPadding = chartArea.maxPadding;\r\n\r\n\tfunction updatePos(pos) {\r\n\t\tvar change = Math.max(maxPadding[pos] - chartArea[pos], 0);\r\n\t\tchartArea[pos] += change;\r\n\t\treturn change;\r\n\t}\r\n\tchartArea.y += updatePos('top');\r\n\tchartArea.x += updatePos('left');\r\n\tupdatePos('right');\r\n\tupdatePos('bottom');\r\n}\r\n\r\nfunction getMargins(horizontal, chartArea) {\r\n\tvar maxPadding = chartArea.maxPadding;\r\n\r\n\tfunction marginForPositions(positions) {\r\n\t\tvar margin = {left: 0, top: 0, right: 0, bottom: 0};\r\n\t\tpositions.forEach(function(pos) {\r\n\t\t\tmargin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\r\n\t\t});\r\n\t\treturn margin;\r\n\t}\r\n\r\n\treturn horizontal\r\n\t\t? marginForPositions(['left', 'right'])\r\n\t\t: marginForPositions(['top', 'bottom']);\r\n}\r\n\r\nfunction fitBoxes(boxes, chartArea, params) {\r\n\tvar refitBoxes = [];\r\n\tvar i, ilen, layout, box, refit, changed;\r\n\r\n\tfor (i = 0, ilen = boxes.length; i < ilen; ++i) {\r\n\t\tlayout = boxes[i];\r\n\t\tbox = layout.box;\r\n\r\n\t\tbox.update(\r\n\t\t\tlayout.width || chartArea.w,\r\n\t\t\tlayout.height || chartArea.h,\r\n\t\t\tgetMargins(layout.horizontal, chartArea)\r\n\t\t);\r\n\t\tif (updateDims(chartArea, params, layout)) {\r\n\t\t\tchanged = true;\r\n\t\t\tif (refitBoxes.length) {\r\n\t\t\t\t// Dimensions changed and there were non full width boxes before this\r\n\t\t\t\t// -> we have to refit those\r\n\t\t\t\trefit = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!box.fullWidth) { // fullWidth boxes don't need to be re-fitted in any case\r\n\t\t\trefitBoxes.push(layout);\r\n\t\t}\r\n\t}\r\n\r\n\treturn refit ? fitBoxes(refitBoxes, chartArea, params) || changed : changed;\r\n}\r\n\r\nfunction placeBoxes(boxes, chartArea, params) {\r\n\tvar userPadding = params.padding;\r\n\tvar x = chartArea.x;\r\n\tvar y = chartArea.y;\r\n\tvar i, ilen, layout, box;\r\n\r\n\tfor (i = 0, ilen = boxes.length; i < ilen; ++i) {\r\n\t\tlayout = boxes[i];\r\n\t\tbox = layout.box;\r\n\t\tif (layout.horizontal) {\r\n\t\t\tbox.left = box.fullWidth ? userPadding.left : chartArea.left;\r\n\t\t\tbox.right = box.fullWidth ? params.outerWidth - userPadding.right : chartArea.left + chartArea.w;\r\n\t\t\tbox.top = y;\r\n\t\t\tbox.bottom = y + box.height;\r\n\t\t\tbox.width = box.right - box.left;\r\n\t\t\ty = box.bottom;\r\n\t\t} else {\r\n\t\t\tbox.left = x;\r\n\t\t\tbox.right = x + box.width;\r\n\t\t\tbox.top = chartArea.top;\r\n\t\t\tbox.bottom = chartArea.top + chartArea.h;\r\n\t\t\tbox.height = box.bottom - box.top;\r\n\t\t\tx = box.right;\r\n\t\t}\r\n\t}\r\n\r\n\tchartArea.x = x;\r\n\tchartArea.y = y;\r\n}\r\n\r\ncore_defaults._set('global', {\r\n\tlayout: {\r\n\t\tpadding: {\r\n\t\t\ttop: 0,\r\n\t\t\tright: 0,\r\n\t\t\tbottom: 0,\r\n\t\t\tleft: 0\r\n\t\t}\r\n\t}\r\n});\r\n\r\n/**\r\n * @interface ILayoutItem\r\n * @prop {string} position - The position of the item in the chart layout. Possible values are\r\n * 'left', 'top', 'right', 'bottom', and 'chartArea'\r\n * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area\r\n * @prop {boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down\r\n * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\r\n * @prop {function} update - Takes two parameters: width and height. Returns size of item\r\n * @prop {function} getPadding -  Returns an object with padding on the edges\r\n * @prop {number} width - Width of item. Must be valid after update()\r\n * @prop {number} height - Height of item. Must be valid after update()\r\n * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update\r\n * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update\r\n * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update\r\n * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\r\n */\r\n\r\n// The layout service is very self explanatory.  It's responsible for the layout within a chart.\r\n// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\r\n// It is this service's responsibility of carrying out that layout.\r\nvar core_layouts = {\r\n\tdefaults: {},\r\n\r\n\t/**\r\n\t * Register a box to a chart.\r\n\t * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\r\n\t * @param {Chart} chart - the chart to use\r\n\t * @param {ILayoutItem} item - the item to add to be layed out\r\n\t */\r\n\taddBox: function(chart, item) {\r\n\t\tif (!chart.boxes) {\r\n\t\t\tchart.boxes = [];\r\n\t\t}\r\n\r\n\t\t// initialize item with default values\r\n\t\titem.fullWidth = item.fullWidth || false;\r\n\t\titem.position = item.position || 'top';\r\n\t\titem.weight = item.weight || 0;\r\n\t\titem._layers = item._layers || function() {\r\n\t\t\treturn [{\r\n\t\t\t\tz: 0,\r\n\t\t\t\tdraw: function() {\r\n\t\t\t\t\titem.draw.apply(item, arguments);\r\n\t\t\t\t}\r\n\t\t\t}];\r\n\t\t};\r\n\r\n\t\tchart.boxes.push(item);\r\n\t},\r\n\r\n\t/**\r\n\t * Remove a layoutItem from a chart\r\n\t * @param {Chart} chart - the chart to remove the box from\r\n\t * @param {ILayoutItem} layoutItem - the item to remove from the layout\r\n\t */\r\n\tremoveBox: function(chart, layoutItem) {\r\n\t\tvar index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\r\n\t\tif (index !== -1) {\r\n\t\t\tchart.boxes.splice(index, 1);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Sets (or updates) options on the given `item`.\r\n\t * @param {Chart} chart - the chart in which the item lives (or will be added to)\r\n\t * @param {ILayoutItem} item - the item to configure with the given options\r\n\t * @param {object} options - the new item options.\r\n\t */\r\n\tconfigure: function(chart, item, options) {\r\n\t\tvar props = ['fullWidth', 'position', 'weight'];\r\n\t\tvar ilen = props.length;\r\n\t\tvar i = 0;\r\n\t\tvar prop;\r\n\r\n\t\tfor (; i < ilen; ++i) {\r\n\t\t\tprop = props[i];\r\n\t\t\tif (options.hasOwnProperty(prop)) {\r\n\t\t\t\titem[prop] = options[prop];\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Fits boxes of the given chart into the given size by having each box measure itself\r\n\t * then running a fitting algorithm\r\n\t * @param {Chart} chart - the chart\r\n\t * @param {number} width - the width to fit into\r\n\t * @param {number} height - the height to fit into\r\n\t */\r\n\tupdate: function(chart, width, height) {\r\n\t\tif (!chart) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar layoutOptions = chart.options.layout || {};\r\n\t\tvar padding = helpers$1.options.toPadding(layoutOptions.padding);\r\n\r\n\t\tvar availableWidth = width - padding.width;\r\n\t\tvar availableHeight = height - padding.height;\r\n\t\tvar boxes = buildLayoutBoxes(chart.boxes);\r\n\t\tvar verticalBoxes = boxes.vertical;\r\n\t\tvar horizontalBoxes = boxes.horizontal;\r\n\r\n\t\t// Essentially we now have any number of boxes on each of the 4 sides.\r\n\t\t// Our canvas looks like the following.\r\n\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\r\n\t\t// B1 is the bottom axis\r\n\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\r\n\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\r\n\t\t// an error will be thrown.\r\n\t\t//\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |                  T1 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |    |    |                 T2                  |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t// |    |    | C1 |                           | C2 |    |\r\n\t\t// |    |    |----|                           |----|    |\r\n\t\t// |    |    |                                     |    |\r\n\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\r\n\t\t// |    |    |                                     |    |\r\n\t\t// |    |    |----|                           |----|    |\r\n\t\t// |    |    | C3 |                           | C4 |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t// |    |    |                 B1                  |    |\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |                  B2 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t//\r\n\r\n\t\tvar params = Object.freeze({\r\n\t\t\touterWidth: width,\r\n\t\t\touterHeight: height,\r\n\t\t\tpadding: padding,\r\n\t\t\tavailableWidth: availableWidth,\r\n\t\t\tvBoxMaxWidth: availableWidth / 2 / verticalBoxes.length,\r\n\t\t\thBoxMaxHeight: availableHeight / 2\r\n\t\t});\r\n\t\tvar chartArea = extend({\r\n\t\t\tmaxPadding: extend({}, padding),\r\n\t\t\tw: availableWidth,\r\n\t\t\th: availableHeight,\r\n\t\t\tx: padding.left,\r\n\t\t\ty: padding.top\r\n\t\t}, padding);\r\n\r\n\t\tsetLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\r\n\r\n\t\t// First fit vertical boxes\r\n\t\tfitBoxes(verticalBoxes, chartArea, params);\r\n\r\n\t\t// Then fit horizontal boxes\r\n\t\tif (fitBoxes(horizontalBoxes, chartArea, params)) {\r\n\t\t\t// if the area changed, re-fit vertical boxes\r\n\t\t\tfitBoxes(verticalBoxes, chartArea, params);\r\n\t\t}\r\n\r\n\t\thandleMaxPadding(chartArea);\r\n\r\n\t\t// Finally place the boxes to correct coordinates\r\n\t\tplaceBoxes(boxes.leftAndTop, chartArea, params);\r\n\r\n\t\t// Move to opposite side of chart\r\n\t\tchartArea.x += chartArea.w;\r\n\t\tchartArea.y += chartArea.h;\r\n\r\n\t\tplaceBoxes(boxes.rightAndBottom, chartArea, params);\r\n\r\n\t\tchart.chartArea = {\r\n\t\t\tleft: chartArea.left,\r\n\t\t\ttop: chartArea.top,\r\n\t\t\tright: chartArea.left + chartArea.w,\r\n\t\t\tbottom: chartArea.top + chartArea.h\r\n\t\t};\r\n\r\n\t\t// Finally update boxes in chartArea (radial scale for example)\r\n\t\thelpers$1.each(boxes.chartArea, function(layout) {\r\n\t\t\tvar box = layout.box;\r\n\t\t\textend(box, chart.chartArea);\r\n\t\t\tbox.update(chartArea.w, chartArea.h);\r\n\t\t});\r\n\t}\r\n};\n\n/**\r\n * Platform fallback implementation (minimal).\r\n * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939\r\n */\r\n\r\nvar platform_basic = {\r\n\tacquireContext: function(item) {\r\n\t\tif (item && item.canvas) {\r\n\t\t\t// Support for any object associated to a canvas (including a context2d)\r\n\t\t\titem = item.canvas;\r\n\t\t}\r\n\r\n\t\treturn item && item.getContext('2d') || null;\r\n\t}\r\n};\n\nvar platform_dom = \"/*\\r\\n * DOM element rendering detection\\r\\n * https://davidwalsh.name/detect-node-insertion\\r\\n */\\r\\n@keyframes chartjs-render-animation {\\r\\n\\tfrom { opacity: 0.99; }\\r\\n\\tto { opacity: 1; }\\r\\n}\\r\\n\\r\\n.chartjs-render-monitor {\\r\\n\\tanimation: chartjs-render-animation 0.001s;\\r\\n}\\r\\n\\r\\n/*\\r\\n * DOM element resizing detection\\r\\n * https://github.com/marcj/css-element-queries\\r\\n */\\r\\n.chartjs-size-monitor,\\r\\n.chartjs-size-monitor-expand,\\r\\n.chartjs-size-monitor-shrink {\\r\\n\\tposition: absolute;\\r\\n\\tdirection: ltr;\\r\\n\\tleft: 0;\\r\\n\\ttop: 0;\\r\\n\\tright: 0;\\r\\n\\tbottom: 0;\\r\\n\\toverflow: hidden;\\r\\n\\tpointer-events: none;\\r\\n\\tvisibility: hidden;\\r\\n\\tz-index: -1;\\r\\n}\\r\\n\\r\\n.chartjs-size-monitor-expand > div {\\r\\n\\tposition: absolute;\\r\\n\\twidth: 1000000px;\\r\\n\\theight: 1000000px;\\r\\n\\tleft: 0;\\r\\n\\ttop: 0;\\r\\n}\\r\\n\\r\\n.chartjs-size-monitor-shrink > div {\\r\\n\\tposition: absolute;\\r\\n\\twidth: 200%;\\r\\n\\theight: 200%;\\r\\n\\tleft: 0;\\r\\n\\ttop: 0;\\r\\n}\\r\\n\";\n\nvar platform_dom$1 = /*#__PURE__*/Object.freeze({\n__proto__: null,\n'default': platform_dom\n});\n\nvar stylesheet = getCjsExportFromNamespace(platform_dom$1);\n\nvar EXPANDO_KEY = '$chartjs';\r\nvar CSS_PREFIX = 'chartjs-';\r\nvar CSS_SIZE_MONITOR = CSS_PREFIX + 'size-monitor';\r\nvar CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';\r\nvar CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';\r\nvar ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];\r\n\r\n/**\r\n * DOM event types -> Chart.js event types.\r\n * Note: only events with different types are mapped.\r\n * @see https://developer.mozilla.org/en-US/docs/Web/Events\r\n */\r\nvar EVENT_TYPES = {\r\n\ttouchstart: 'mousedown',\r\n\ttouchmove: 'mousemove',\r\n\ttouchend: 'mouseup',\r\n\tpointerenter: 'mouseenter',\r\n\tpointerdown: 'mousedown',\r\n\tpointermove: 'mousemove',\r\n\tpointerup: 'mouseup',\r\n\tpointerleave: 'mouseout',\r\n\tpointerout: 'mouseout'\r\n};\r\n\r\n/**\r\n * The \"used\" size is the final value of a dimension property after all calculations have\r\n * been performed. This method uses the computed style of `element` but returns undefined\r\n * if the computed style is not expressed in pixels. That can happen in some cases where\r\n * `element` has a size relative to its parent and this last one is not yet displayed,\r\n * for example because of `display: none` on a parent node.\r\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\r\n * @returns {number} Size in pixels or undefined if unknown.\r\n */\r\nfunction readUsedSize(element, property) {\r\n\tvar value = helpers$1.getStyle(element, property);\r\n\tvar matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\r\n\treturn matches ? Number(matches[1]) : undefined;\r\n}\r\n\r\n/**\r\n * Initializes the canvas style and render size without modifying the canvas display size,\r\n * since responsiveness is handled by the controller.resize() method. The config is used\r\n * to determine the aspect ratio to apply in case no explicit height has been specified.\r\n */\r\nfunction initCanvas(canvas, config) {\r\n\tvar style = canvas.style;\r\n\r\n\t// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\r\n\t// returns null or '' if no explicit value has been set to the canvas attribute.\r\n\tvar renderHeight = canvas.getAttribute('height');\r\n\tvar renderWidth = canvas.getAttribute('width');\r\n\r\n\t// Chart.js modifies some canvas values that we want to restore on destroy\r\n\tcanvas[EXPANDO_KEY] = {\r\n\t\tinitial: {\r\n\t\t\theight: renderHeight,\r\n\t\t\twidth: renderWidth,\r\n\t\t\tstyle: {\r\n\t\t\t\tdisplay: style.display,\r\n\t\t\t\theight: style.height,\r\n\t\t\t\twidth: style.width\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// Force canvas to display as block to avoid extra space caused by inline\r\n\t// elements, which would interfere with the responsive resize process.\r\n\t// https://github.com/chartjs/Chart.js/issues/2538\r\n\tstyle.display = style.display || 'block';\r\n\r\n\tif (renderWidth === null || renderWidth === '') {\r\n\t\tvar displayWidth = readUsedSize(canvas, 'width');\r\n\t\tif (displayWidth !== undefined) {\r\n\t\t\tcanvas.width = displayWidth;\r\n\t\t}\r\n\t}\r\n\r\n\tif (renderHeight === null || renderHeight === '') {\r\n\t\tif (canvas.style.height === '') {\r\n\t\t\t// If no explicit render height and style height, let's apply the aspect ratio,\r\n\t\t\t// which one can be specified by the user but also by charts as default option\r\n\t\t\t// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\r\n\t\t\tcanvas.height = canvas.width / (config.options.aspectRatio || 2);\r\n\t\t} else {\r\n\t\t\tvar displayHeight = readUsedSize(canvas, 'height');\r\n\t\t\tif (displayWidth !== undefined) {\r\n\t\t\t\tcanvas.height = displayHeight;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn canvas;\r\n}\r\n\r\n/**\r\n * Detects support for options object argument in addEventListener.\r\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\r\n * @private\r\n */\r\nvar supportsEventListenerOptions = (function() {\r\n\tvar supports = false;\r\n\ttry {\r\n\t\tvar options = Object.defineProperty({}, 'passive', {\r\n\t\t\t// eslint-disable-next-line getter-return\r\n\t\t\tget: function() {\r\n\t\t\t\tsupports = true;\r\n\t\t\t}\r\n\t\t});\r\n\t\twindow.addEventListener('e', null, options);\r\n\t} catch (e) {\r\n\t\t// continue regardless of error\r\n\t}\r\n\treturn supports;\r\n}());\r\n\r\n// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.\r\n// https://github.com/chartjs/Chart.js/issues/4287\r\nvar eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\r\n\r\nfunction addListener(node, type, listener) {\r\n\tnode.addEventListener(type, listener, eventListenerOptions);\r\n}\r\n\r\nfunction removeListener(node, type, listener) {\r\n\tnode.removeEventListener(type, listener, eventListenerOptions);\r\n}\r\n\r\nfunction createEvent(type, chart, x, y, nativeEvent) {\r\n\treturn {\r\n\t\ttype: type,\r\n\t\tchart: chart,\r\n\t\tnative: nativeEvent || null,\r\n\t\tx: x !== undefined ? x : null,\r\n\t\ty: y !== undefined ? y : null,\r\n\t};\r\n}\r\n\r\nfunction fromNativeEvent(event, chart) {\r\n\tvar type = EVENT_TYPES[event.type] || event.type;\r\n\tvar pos = helpers$1.getRelativePosition(event, chart);\r\n\treturn createEvent(type, chart, pos.x, pos.y, event);\r\n}\r\n\r\nfunction throttled(fn, thisArg) {\r\n\tvar ticking = false;\r\n\tvar args = [];\r\n\r\n\treturn function() {\r\n\t\targs = Array.prototype.slice.call(arguments);\r\n\t\tthisArg = thisArg || this;\r\n\r\n\t\tif (!ticking) {\r\n\t\t\tticking = true;\r\n\t\t\thelpers$1.requestAnimFrame.call(window, function() {\r\n\t\t\t\tticking = false;\r\n\t\t\t\tfn.apply(thisArg, args);\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction createDiv(cls) {\r\n\tvar el = document.createElement('div');\r\n\tel.className = cls || '';\r\n\treturn el;\r\n}\r\n\r\n// Implementation based on https://github.com/marcj/css-element-queries\r\nfunction createResizer(handler) {\r\n\tvar maxSize = 1000000;\r\n\r\n\t// NOTE(SB) Don't use innerHTML because it could be considered unsafe.\r\n\t// https://github.com/chartjs/Chart.js/issues/5902\r\n\tvar resizer = createDiv(CSS_SIZE_MONITOR);\r\n\tvar expand = createDiv(CSS_SIZE_MONITOR + '-expand');\r\n\tvar shrink = createDiv(CSS_SIZE_MONITOR + '-shrink');\r\n\r\n\texpand.appendChild(createDiv());\r\n\tshrink.appendChild(createDiv());\r\n\r\n\tresizer.appendChild(expand);\r\n\tresizer.appendChild(shrink);\r\n\tresizer._reset = function() {\r\n\t\texpand.scrollLeft = maxSize;\r\n\t\texpand.scrollTop = maxSize;\r\n\t\tshrink.scrollLeft = maxSize;\r\n\t\tshrink.scrollTop = maxSize;\r\n\t};\r\n\r\n\tvar onScroll = function() {\r\n\t\tresizer._reset();\r\n\t\thandler();\r\n\t};\r\n\r\n\taddListener(expand, 'scroll', onScroll.bind(expand, 'expand'));\r\n\taddListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));\r\n\r\n\treturn resizer;\r\n}\r\n\r\n// https://davidwalsh.name/detect-node-insertion\r\nfunction watchForRender(node, handler) {\r\n\tvar expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});\r\n\tvar proxy = expando.renderProxy = function(e) {\r\n\t\tif (e.animationName === CSS_RENDER_ANIMATION) {\r\n\t\t\thandler();\r\n\t\t}\r\n\t};\r\n\r\n\thelpers$1.each(ANIMATION_START_EVENTS, function(type) {\r\n\t\taddListener(node, type, proxy);\r\n\t});\r\n\r\n\t// #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class\r\n\t// is removed then added back immediately (same animation frame?). Accessing the\r\n\t// `offsetParent` property will force a reflow and re-evaluate the CSS animation.\r\n\t// https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics\r\n\t// https://github.com/chartjs/Chart.js/issues/4737\r\n\texpando.reflow = !!node.offsetParent;\r\n\r\n\tnode.classList.add(CSS_RENDER_MONITOR);\r\n}\r\n\r\nfunction unwatchForRender(node) {\r\n\tvar expando = node[EXPANDO_KEY] || {};\r\n\tvar proxy = expando.renderProxy;\r\n\r\n\tif (proxy) {\r\n\t\thelpers$1.each(ANIMATION_START_EVENTS, function(type) {\r\n\t\t\tremoveListener(node, type, proxy);\r\n\t\t});\r\n\r\n\t\tdelete expando.renderProxy;\r\n\t}\r\n\r\n\tnode.classList.remove(CSS_RENDER_MONITOR);\r\n}\r\n\r\nfunction addResizeListener(node, listener, chart) {\r\n\tvar expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});\r\n\r\n\t// Let's keep track of this added resizer and thus avoid DOM query when removing it.\r\n\tvar resizer = expando.resizer = createResizer(throttled(function() {\r\n\t\tif (expando.resizer) {\r\n\t\t\tvar container = chart.options.maintainAspectRatio && node.parentNode;\r\n\t\t\tvar w = container ? container.clientWidth : 0;\r\n\t\t\tlistener(createEvent('resize', chart));\r\n\t\t\tif (container && container.clientWidth < w && chart.canvas) {\r\n\t\t\t\t// If the container size shrank during chart resize, let's assume\r\n\t\t\t\t// scrollbar appeared. So we resize again with the scrollbar visible -\r\n\t\t\t\t// effectively making chart smaller and the scrollbar hidden again.\r\n\t\t\t\t// Because we are inside `throttled`, and currently `ticking`, scroll\r\n\t\t\t\t// events are ignored during this whole 2 resize process.\r\n\t\t\t\t// If we assumed wrong and something else happened, we are resizing\r\n\t\t\t\t// twice in a frame (potential performance issue)\r\n\t\t\t\tlistener(createEvent('resize', chart));\r\n\t\t\t}\r\n\t\t}\r\n\t}));\r\n\r\n\t// The resizer needs to be attached to the node parent, so we first need to be\r\n\t// sure that `node` is attached to the DOM before injecting the resizer element.\r\n\twatchForRender(node, function() {\r\n\t\tif (expando.resizer) {\r\n\t\t\tvar container = node.parentNode;\r\n\t\t\tif (container && container !== resizer.parentNode) {\r\n\t\t\t\tcontainer.insertBefore(resizer, container.firstChild);\r\n\t\t\t}\r\n\r\n\t\t\t// The container size might have changed, let's reset the resizer state.\r\n\t\t\tresizer._reset();\r\n\t\t}\r\n\t});\r\n}\r\n\r\nfunction removeResizeListener(node) {\r\n\tvar expando = node[EXPANDO_KEY] || {};\r\n\tvar resizer = expando.resizer;\r\n\r\n\tdelete expando.resizer;\r\n\tunwatchForRender(node);\r\n\r\n\tif (resizer && resizer.parentNode) {\r\n\t\tresizer.parentNode.removeChild(resizer);\r\n\t}\r\n}\r\n\r\n/**\r\n * Injects CSS styles inline if the styles are not already present.\r\n * @param {HTMLDocument|ShadowRoot} rootNode - the node to contain the <style>.\r\n * @param {string} css - the CSS to be injected.\r\n */\r\nfunction injectCSS(rootNode, css) {\r\n\t// https://stackoverflow.com/q/3922139\r\n\tvar expando = rootNode[EXPANDO_KEY] || (rootNode[EXPANDO_KEY] = {});\r\n\tif (!expando.containsStyles) {\r\n\t\texpando.containsStyles = true;\r\n\t\tcss = '/* Chart.js */\\n' + css;\r\n\t\tvar style = document.createElement('style');\r\n\t\tstyle.setAttribute('type', 'text/css');\r\n\t\tstyle.appendChild(document.createTextNode(css));\r\n\t\trootNode.appendChild(style);\r\n\t}\r\n}\r\n\r\nvar platform_dom$2 = {\r\n\t/**\r\n\t * When `true`, prevents the automatic injection of the stylesheet required to\r\n\t * correctly detect when the chart is added to the DOM and then resized. This\r\n\t * switch has been added to allow external stylesheet (`dist/Chart(.min)?.js`)\r\n\t * to be manually imported to make this library compatible with any CSP.\r\n\t * See https://github.com/chartjs/Chart.js/issues/5208\r\n\t */\r\n\tdisableCSSInjection: false,\r\n\r\n\t/**\r\n\t * This property holds whether this platform is enabled for the current environment.\r\n\t * Currently used by platform.js to select the proper implementation.\r\n\t * @private\r\n\t */\r\n\t_enabled: typeof window !== 'undefined' && typeof document !== 'undefined',\r\n\r\n\t/**\r\n\t * Initializes resources that depend on platform options.\r\n\t * @param {HTMLCanvasElement} canvas - The Canvas element.\r\n\t * @private\r\n\t */\r\n\t_ensureLoaded: function(canvas) {\r\n\t\tif (!this.disableCSSInjection) {\r\n\t\t\t// If the canvas is in a shadow DOM, then the styles must also be inserted\r\n\t\t\t// into the same shadow DOM.\r\n\t\t\t// https://github.com/chartjs/Chart.js/issues/5763\r\n\t\t\tvar root = canvas.getRootNode ? canvas.getRootNode() : document;\r\n\t\t\tvar targetNode = root.host ? root : document.head;\r\n\t\t\tinjectCSS(targetNode, stylesheet);\r\n\t\t}\r\n\t},\r\n\r\n\tacquireContext: function(item, config) {\r\n\t\tif (typeof item === 'string') {\r\n\t\t\titem = document.getElementById(item);\r\n\t\t} else if (item.length) {\r\n\t\t\t// Support for array based queries (such as jQuery)\r\n\t\t\titem = item[0];\r\n\t\t}\r\n\r\n\t\tif (item && item.canvas) {\r\n\t\t\t// Support for any object associated to a canvas (including a context2d)\r\n\t\t\titem = item.canvas;\r\n\t\t}\r\n\r\n\t\t// To prevent canvas fingerprinting, some add-ons undefine the getContext\r\n\t\t// method, for example: https://github.com/kkapsner/CanvasBlocker\r\n\t\t// https://github.com/chartjs/Chart.js/issues/2807\r\n\t\tvar context = item && item.getContext && item.getContext('2d');\r\n\r\n\t\t// `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is\r\n\t\t// inside an iframe or when running in a protected environment. We could guess the\r\n\t\t// types from their toString() value but let's keep things flexible and assume it's\r\n\t\t// a sufficient condition if the item has a context2D which has item as `canvas`.\r\n\t\t// https://github.com/chartjs/Chart.js/issues/3887\r\n\t\t// https://github.com/chartjs/Chart.js/issues/4102\r\n\t\t// https://github.com/chartjs/Chart.js/issues/4152\r\n\t\tif (context && context.canvas === item) {\r\n\t\t\t// Load platform resources on first chart creation, to make it possible to\r\n\t\t\t// import the library before setting platform options.\r\n\t\t\tthis._ensureLoaded(item);\r\n\t\t\tinitCanvas(item, config);\r\n\t\t\treturn context;\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t},\r\n\r\n\treleaseContext: function(context) {\r\n\t\tvar canvas = context.canvas;\r\n\t\tif (!canvas[EXPANDO_KEY]) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar initial = canvas[EXPANDO_KEY].initial;\r\n\t\t['height', 'width'].forEach(function(prop) {\r\n\t\t\tvar value = initial[prop];\r\n\t\t\tif (helpers$1.isNullOrUndef(value)) {\r\n\t\t\t\tcanvas.removeAttribute(prop);\r\n\t\t\t} else {\r\n\t\t\t\tcanvas.setAttribute(prop, value);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\thelpers$1.each(initial.style || {}, function(value, key) {\r\n\t\t\tcanvas.style[key] = value;\r\n\t\t});\r\n\r\n\t\t// The canvas render size might have been changed (and thus the state stack discarded),\r\n\t\t// we can't use save() and restore() to restore the initial state. So make sure that at\r\n\t\t// least the canvas context is reset to the default state by setting the canvas width.\r\n\t\t// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\r\n\t\t// eslint-disable-next-line no-self-assign\r\n\t\tcanvas.width = canvas.width;\r\n\r\n\t\tdelete canvas[EXPANDO_KEY];\r\n\t},\r\n\r\n\taddEventListener: function(chart, type, listener) {\r\n\t\tvar canvas = chart.canvas;\r\n\t\tif (type === 'resize') {\r\n\t\t\t// Note: the resize event is not supported on all browsers.\r\n\t\t\taddResizeListener(canvas, listener, chart);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});\r\n\t\tvar proxies = expando.proxies || (expando.proxies = {});\r\n\t\tvar proxy = proxies[chart.id + '_' + type] = function(event) {\r\n\t\t\tlistener(fromNativeEvent(event, chart));\r\n\t\t};\r\n\r\n\t\taddListener(canvas, type, proxy);\r\n\t},\r\n\r\n\tremoveEventListener: function(chart, type, listener) {\r\n\t\tvar canvas = chart.canvas;\r\n\t\tif (type === 'resize') {\r\n\t\t\t// Note: the resize event is not supported on all browsers.\r\n\t\t\tremoveResizeListener(canvas);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar expando = listener[EXPANDO_KEY] || {};\r\n\t\tvar proxies = expando.proxies || {};\r\n\t\tvar proxy = proxies[chart.id + '_' + type];\r\n\t\tif (!proxy) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tremoveListener(canvas, type, proxy);\r\n\t}\r\n};\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n * Provided for backward compatibility, use EventTarget.addEventListener instead.\r\n * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\r\n * @function Chart.helpers.addEvent\r\n * @deprecated since version 2.7.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers$1.addEvent = addListener;\r\n\r\n/**\r\n * Provided for backward compatibility, use EventTarget.removeEventListener instead.\r\n * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener\r\n * @function Chart.helpers.removeEvent\r\n * @deprecated since version 2.7.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers$1.removeEvent = removeListener;\n\n// @TODO Make possible to select another platform at build time.\r\nvar implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;\r\n\r\n/**\r\n * @namespace Chart.platform\r\n * @see https://chartjs.gitbooks.io/proposals/content/Platform.html\r\n * @since 2.4.0\r\n */\r\nvar platform = helpers$1.extend({\r\n\t/**\r\n\t * @since 2.7.0\r\n\t */\r\n\tinitialize: function() {},\r\n\r\n\t/**\r\n\t * Called at chart construction time, returns a context2d instance implementing\r\n\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\r\n\t * @param {*} item - The native item from which to acquire context (platform specific)\r\n\t * @param {object} options - The chart options\r\n\t * @returns {CanvasRenderingContext2D} context2d instance\r\n\t */\r\n\tacquireContext: function() {},\r\n\r\n\t/**\r\n\t * Called at chart destruction time, releases any resources associated to the context\r\n\t * previously returned by the acquireContext() method.\r\n\t * @param {CanvasRenderingContext2D} context - The context2d instance\r\n\t * @returns {boolean} true if the method succeeded, else false\r\n\t */\r\n\treleaseContext: function() {},\r\n\r\n\t/**\r\n\t * Registers the specified listener on the given chart.\r\n\t * @param {Chart} chart - Chart from which to listen for event\r\n\t * @param {string} type - The ({@link IEvent}) type to listen for\r\n\t * @param {function} listener - Receives a notification (an object that implements\r\n\t * the {@link IEvent} interface) when an event of the specified type occurs.\r\n\t */\r\n\taddEventListener: function() {},\r\n\r\n\t/**\r\n\t * Removes the specified listener previously registered with addEventListener.\r\n\t * @param {Chart} chart - Chart from which to remove the listener\r\n\t * @param {string} type - The ({@link IEvent}) type to remove\r\n\t * @param {function} listener - The listener function to remove from the event target.\r\n\t */\r\n\tremoveEventListener: function() {}\r\n\r\n}, implementation);\n\ncore_defaults._set('global', {\r\n\tplugins: {}\r\n});\r\n\r\n/**\r\n * The plugin service singleton\r\n * @namespace Chart.plugins\r\n * @since 2.1.0\r\n */\r\nvar core_plugins = {\r\n\t/**\r\n\t * Globally registered plugins.\r\n\t * @private\r\n\t */\r\n\t_plugins: [],\r\n\r\n\t/**\r\n\t * This identifier is used to invalidate the descriptors cache attached to each chart\r\n\t * when a global plugin is registered or unregistered. In this case, the cache ID is\r\n\t * incremented and descriptors are regenerated during following API calls.\r\n\t * @private\r\n\t */\r\n\t_cacheId: 0,\r\n\r\n\t/**\r\n\t * Registers the given plugin(s) if not already registered.\r\n\t * @param {IPlugin[]|IPlugin} plugins plugin instance(s).\r\n\t */\r\n\tregister: function(plugins) {\r\n\t\tvar p = this._plugins;\r\n\t\t([]).concat(plugins).forEach(function(plugin) {\r\n\t\t\tif (p.indexOf(plugin) === -1) {\r\n\t\t\t\tp.push(plugin);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis._cacheId++;\r\n\t},\r\n\r\n\t/**\r\n\t * Unregisters the given plugin(s) only if registered.\r\n\t * @param {IPlugin[]|IPlugin} plugins plugin instance(s).\r\n\t */\r\n\tunregister: function(plugins) {\r\n\t\tvar p = this._plugins;\r\n\t\t([]).concat(plugins).forEach(function(plugin) {\r\n\t\t\tvar idx = p.indexOf(plugin);\r\n\t\t\tif (idx !== -1) {\r\n\t\t\t\tp.splice(idx, 1);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis._cacheId++;\r\n\t},\r\n\r\n\t/**\r\n\t * Remove all registered plugins.\r\n\t * @since 2.1.5\r\n\t */\r\n\tclear: function() {\r\n\t\tthis._plugins = [];\r\n\t\tthis._cacheId++;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns the number of registered plugins?\r\n\t * @returns {number}\r\n\t * @since 2.1.5\r\n\t */\r\n\tcount: function() {\r\n\t\treturn this._plugins.length;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns all registered plugin instances.\r\n\t * @returns {IPlugin[]} array of plugin objects.\r\n\t * @since 2.1.5\r\n\t */\r\n\tgetAll: function() {\r\n\t\treturn this._plugins;\r\n\t},\r\n\r\n\t/**\r\n\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\r\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\r\n\t * returned value can be used, for instance, to interrupt the current action.\r\n\t * @param {Chart} chart - The chart instance for which plugins should be called.\r\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\r\n\t * @param {Array} [args] - Extra arguments to apply to the hook call.\r\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\r\n\t */\r\n\tnotify: function(chart, hook, args) {\r\n\t\tvar descriptors = this.descriptors(chart);\r\n\t\tvar ilen = descriptors.length;\r\n\t\tvar i, descriptor, plugin, params, method;\r\n\r\n\t\tfor (i = 0; i < ilen; ++i) {\r\n\t\t\tdescriptor = descriptors[i];\r\n\t\t\tplugin = descriptor.plugin;\r\n\t\t\tmethod = plugin[hook];\r\n\t\t\tif (typeof method === 'function') {\r\n\t\t\t\tparams = [chart].concat(args || []);\r\n\t\t\t\tparams.push(descriptor.options);\r\n\t\t\t\tif (method.apply(plugin, params) === false) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns descriptors of enabled plugins for the given chart.\r\n\t * @returns {object[]} [{ plugin, options }]\r\n\t * @private\r\n\t */\r\n\tdescriptors: function(chart) {\r\n\t\tvar cache = chart.$plugins || (chart.$plugins = {});\r\n\t\tif (cache.id === this._cacheId) {\r\n\t\t\treturn cache.descriptors;\r\n\t\t}\r\n\r\n\t\tvar plugins = [];\r\n\t\tvar descriptors = [];\r\n\t\tvar config = (chart && chart.config) || {};\r\n\t\tvar options = (config.options && config.options.plugins) || {};\r\n\r\n\t\tthis._plugins.concat(config.plugins || []).forEach(function(plugin) {\r\n\t\t\tvar idx = plugins.indexOf(plugin);\r\n\t\t\tif (idx !== -1) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar id = plugin.id;\r\n\t\t\tvar opts = options[id];\r\n\t\t\tif (opts === false) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (opts === true) {\r\n\t\t\t\topts = helpers$1.clone(core_defaults.global.plugins[id]);\r\n\t\t\t}\r\n\r\n\t\t\tplugins.push(plugin);\r\n\t\t\tdescriptors.push({\r\n\t\t\t\tplugin: plugin,\r\n\t\t\t\toptions: opts || {}\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\tcache.descriptors = descriptors;\r\n\t\tcache.id = this._cacheId;\r\n\t\treturn descriptors;\r\n\t},\r\n\r\n\t/**\r\n\t * Invalidates cache for the given chart: descriptors hold a reference on plugin option,\r\n\t * but in some cases, this reference can be changed by the user when updating options.\r\n\t * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\r\n\t * @private\r\n\t */\r\n\t_invalidate: function(chart) {\r\n\t\tdelete chart.$plugins;\r\n\t}\r\n};\n\nvar core_scaleService = {\r\n\t// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then\r\n\t// use the new chart options to grab the correct scale\r\n\tconstructors: {},\r\n\t// Use a registration function so that we can move to an ES6 map when we no longer need to support\r\n\t// old browsers\r\n\r\n\t// Scale config defaults\r\n\tdefaults: {},\r\n\tregisterScaleType: function(type, scaleConstructor, scaleDefaults) {\r\n\t\tthis.constructors[type] = scaleConstructor;\r\n\t\tthis.defaults[type] = helpers$1.clone(scaleDefaults);\r\n\t},\r\n\tgetScaleConstructor: function(type) {\r\n\t\treturn this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;\r\n\t},\r\n\tgetScaleDefaults: function(type) {\r\n\t\t// Return the scale defaults merged with the global settings so that we always use the latest ones\r\n\t\treturn this.defaults.hasOwnProperty(type) ? helpers$1.merge(Object.create(null), [core_defaults.scale, this.defaults[type]]) : {};\r\n\t},\r\n\tupdateScaleDefaults: function(type, additions) {\r\n\t\tvar me = this;\r\n\t\tif (me.defaults.hasOwnProperty(type)) {\r\n\t\t\tme.defaults[type] = helpers$1.extend(me.defaults[type], additions);\r\n\t\t}\r\n\t},\r\n\taddScalesToLayout: function(chart) {\r\n\t\t// Adds each scale to the chart.boxes array to be sized accordingly\r\n\t\thelpers$1.each(chart.scales, function(scale) {\r\n\t\t\t// Set ILayoutItem parameters for backwards compatibility\r\n\t\t\tscale.fullWidth = scale.options.fullWidth;\r\n\t\t\tscale.position = scale.options.position;\r\n\t\t\tscale.weight = scale.options.weight;\r\n\t\t\tcore_layouts.addBox(chart, scale);\r\n\t\t});\r\n\t}\r\n};\n\nvar valueOrDefault$8 = helpers$1.valueOrDefault;\r\nvar getRtlHelper = helpers$1.rtl.getRtlAdapter;\r\n\r\ncore_defaults._set('global', {\r\n\ttooltips: {\r\n\t\tenabled: true,\r\n\t\tcustom: null,\r\n\t\tmode: 'nearest',\r\n\t\tposition: 'average',\r\n\t\tintersect: true,\r\n\t\tbackgroundColor: 'rgba(0,0,0,0.8)',\r\n\t\ttitleFontStyle: 'bold',\r\n\t\ttitleSpacing: 2,\r\n\t\ttitleMarginBottom: 6,\r\n\t\ttitleFontColor: '#fff',\r\n\t\ttitleAlign: 'left',\r\n\t\tbodySpacing: 2,\r\n\t\tbodyFontColor: '#fff',\r\n\t\tbodyAlign: 'left',\r\n\t\tfooterFontStyle: 'bold',\r\n\t\tfooterSpacing: 2,\r\n\t\tfooterMarginTop: 6,\r\n\t\tfooterFontColor: '#fff',\r\n\t\tfooterAlign: 'left',\r\n\t\tyPadding: 6,\r\n\t\txPadding: 6,\r\n\t\tcaretPadding: 2,\r\n\t\tcaretSize: 5,\r\n\t\tcornerRadius: 6,\r\n\t\tmultiKeyBackground: '#fff',\r\n\t\tdisplayColors: true,\r\n\t\tborderColor: 'rgba(0,0,0,0)',\r\n\t\tborderWidth: 0,\r\n\t\tcallbacks: {\r\n\t\t\t// Args are: (tooltipItems, data)\r\n\t\t\tbeforeTitle: helpers$1.noop,\r\n\t\t\ttitle: function(tooltipItems, data) {\r\n\t\t\t\tvar title = '';\r\n\t\t\t\tvar labels = data.labels;\r\n\t\t\t\tvar labelCount = labels ? labels.length : 0;\r\n\r\n\t\t\t\tif (tooltipItems.length > 0) {\r\n\t\t\t\t\tvar item = tooltipItems[0];\r\n\t\t\t\t\tif (item.label) {\r\n\t\t\t\t\t\ttitle = item.label;\r\n\t\t\t\t\t} else if (item.xLabel) {\r\n\t\t\t\t\t\ttitle = item.xLabel;\r\n\t\t\t\t\t} else if (labelCount > 0 && item.index < labelCount) {\r\n\t\t\t\t\t\ttitle = labels[item.index];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn title;\r\n\t\t\t},\r\n\t\t\tafterTitle: helpers$1.noop,\r\n\r\n\t\t\t// Args are: (tooltipItems, data)\r\n\t\t\tbeforeBody: helpers$1.noop,\r\n\r\n\t\t\t// Args are: (tooltipItem, data)\r\n\t\t\tbeforeLabel: helpers$1.noop,\r\n\t\t\tlabel: function(tooltipItem, data) {\r\n\t\t\t\tvar label = data.datasets[tooltipItem.datasetIndex].label || '';\r\n\r\n\t\t\t\tif (label) {\r\n\t\t\t\t\tlabel += ': ';\r\n\t\t\t\t}\r\n\t\t\t\tif (!helpers$1.isNullOrUndef(tooltipItem.value)) {\r\n\t\t\t\t\tlabel += tooltipItem.value;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlabel += tooltipItem.yLabel;\r\n\t\t\t\t}\r\n\t\t\t\treturn label;\r\n\t\t\t},\r\n\t\t\tlabelColor: function(tooltipItem, chart) {\r\n\t\t\t\tvar meta = chart.getDatasetMeta(tooltipItem.datasetIndex);\r\n\t\t\t\tvar activeElement = meta.data[tooltipItem.index];\r\n\t\t\t\tvar view = activeElement._view;\r\n\t\t\t\treturn {\r\n\t\t\t\t\tborderColor: view.borderColor,\r\n\t\t\t\t\tbackgroundColor: view.backgroundColor\r\n\t\t\t\t};\r\n\t\t\t},\r\n\t\t\tlabelTextColor: function() {\r\n\t\t\t\treturn this._options.bodyFontColor;\r\n\t\t\t},\r\n\t\t\tafterLabel: helpers$1.noop,\r\n\r\n\t\t\t// Args are: (tooltipItems, data)\r\n\t\t\tafterBody: helpers$1.noop,\r\n\r\n\t\t\t// Args are: (tooltipItems, data)\r\n\t\t\tbeforeFooter: helpers$1.noop,\r\n\t\t\tfooter: helpers$1.noop,\r\n\t\t\tafterFooter: helpers$1.noop\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar positioners = {\r\n\t/**\r\n\t * Average mode places the tooltip at the average position of the elements shown\r\n\t * @function Chart.Tooltip.positioners.average\r\n\t * @param elements {ChartElement[]} the elements being displayed in the tooltip\r\n\t * @returns {object} tooltip position\r\n\t */\r\n\taverage: function(elements) {\r\n\t\tif (!elements.length) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar i, len;\r\n\t\tvar x = 0;\r\n\t\tvar y = 0;\r\n\t\tvar count = 0;\r\n\r\n\t\tfor (i = 0, len = elements.length; i < len; ++i) {\r\n\t\t\tvar el = elements[i];\r\n\t\t\tif (el && el.hasValue()) {\r\n\t\t\t\tvar pos = el.tooltipPosition();\r\n\t\t\t\tx += pos.x;\r\n\t\t\t\ty += pos.y;\r\n\t\t\t\t++count;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tx: x / count,\r\n\t\t\ty: y / count\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Gets the tooltip position nearest of the item nearest to the event position\r\n\t * @function Chart.Tooltip.positioners.nearest\r\n\t * @param elements {Chart.Element[]} the tooltip elements\r\n\t * @param eventPosition {object} the position of the event in canvas coordinates\r\n\t * @returns {object} the tooltip position\r\n\t */\r\n\tnearest: function(elements, eventPosition) {\r\n\t\tvar x = eventPosition.x;\r\n\t\tvar y = eventPosition.y;\r\n\t\tvar minDistance = Number.POSITIVE_INFINITY;\r\n\t\tvar i, len, nearestElement;\r\n\r\n\t\tfor (i = 0, len = elements.length; i < len; ++i) {\r\n\t\t\tvar el = elements[i];\r\n\t\t\tif (el && el.hasValue()) {\r\n\t\t\t\tvar center = el.getCenterPoint();\r\n\t\t\t\tvar d = helpers$1.distanceBetweenPoints(eventPosition, center);\r\n\r\n\t\t\t\tif (d < minDistance) {\r\n\t\t\t\t\tminDistance = d;\r\n\t\t\t\t\tnearestElement = el;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (nearestElement) {\r\n\t\t\tvar tp = nearestElement.tooltipPosition();\r\n\t\t\tx = tp.x;\r\n\t\t\ty = tp.y;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tx: x,\r\n\t\t\ty: y\r\n\t\t};\r\n\t}\r\n};\r\n\r\n// Helper to push or concat based on if the 2nd parameter is an array or not\r\nfunction pushOrConcat(base, toPush) {\r\n\tif (toPush) {\r\n\t\tif (helpers$1.isArray(toPush)) {\r\n\t\t\t// base = base.concat(toPush);\r\n\t\t\tArray.prototype.push.apply(base, toPush);\r\n\t\t} else {\r\n\t\t\tbase.push(toPush);\r\n\t\t}\r\n\t}\r\n\r\n\treturn base;\r\n}\r\n\r\n/**\r\n * Returns array of strings split by newline\r\n * @param {string} value - The value to split by newline.\r\n * @returns {string[]} value if newline present - Returned from String split() method\r\n * @function\r\n */\r\nfunction splitNewlines(str) {\r\n\tif ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\r\n\t\treturn str.split('\\n');\r\n\t}\r\n\treturn str;\r\n}\r\n\r\n\r\n/**\r\n * Private helper to create a tooltip item model\r\n * @param element - the chart element (point, arc, bar) to create the tooltip item for\r\n * @return new tooltip item\r\n */\r\nfunction createTooltipItem(element) {\r\n\tvar xScale = element._xScale;\r\n\tvar yScale = element._yScale || element._scale; // handle radar || polarArea charts\r\n\tvar index = element._index;\r\n\tvar datasetIndex = element._datasetIndex;\r\n\tvar controller = element._chart.getDatasetMeta(datasetIndex).controller;\r\n\tvar indexScale = controller._getIndexScale();\r\n\tvar valueScale = controller._getValueScale();\r\n\r\n\treturn {\r\n\t\txLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',\r\n\t\tyLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',\r\n\t\tlabel: indexScale ? '' + indexScale.getLabelForIndex(index, datasetIndex) : '',\r\n\t\tvalue: valueScale ? '' + valueScale.getLabelForIndex(index, datasetIndex) : '',\r\n\t\tindex: index,\r\n\t\tdatasetIndex: datasetIndex,\r\n\t\tx: element._model.x,\r\n\t\ty: element._model.y\r\n\t};\r\n}\r\n\r\n/**\r\n * Helper to get the reset model for the tooltip\r\n * @param tooltipOpts {object} the tooltip options\r\n */\r\nfunction getBaseModel(tooltipOpts) {\r\n\tvar globalDefaults = core_defaults.global;\r\n\r\n\treturn {\r\n\t\t// Positioning\r\n\t\txPadding: tooltipOpts.xPadding,\r\n\t\tyPadding: tooltipOpts.yPadding,\r\n\t\txAlign: tooltipOpts.xAlign,\r\n\t\tyAlign: tooltipOpts.yAlign,\r\n\r\n\t\t// Drawing direction and text direction\r\n\t\trtl: tooltipOpts.rtl,\r\n\t\ttextDirection: tooltipOpts.textDirection,\r\n\r\n\t\t// Body\r\n\t\tbodyFontColor: tooltipOpts.bodyFontColor,\r\n\t\t_bodyFontFamily: valueOrDefault$8(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),\r\n\t\t_bodyFontStyle: valueOrDefault$8(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),\r\n\t\t_bodyAlign: tooltipOpts.bodyAlign,\r\n\t\tbodyFontSize: valueOrDefault$8(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),\r\n\t\tbodySpacing: tooltipOpts.bodySpacing,\r\n\r\n\t\t// Title\r\n\t\ttitleFontColor: tooltipOpts.titleFontColor,\r\n\t\t_titleFontFamily: valueOrDefault$8(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),\r\n\t\t_titleFontStyle: valueOrDefault$8(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),\r\n\t\ttitleFontSize: valueOrDefault$8(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),\r\n\t\t_titleAlign: tooltipOpts.titleAlign,\r\n\t\ttitleSpacing: tooltipOpts.titleSpacing,\r\n\t\ttitleMarginBottom: tooltipOpts.titleMarginBottom,\r\n\r\n\t\t// Footer\r\n\t\tfooterFontColor: tooltipOpts.footerFontColor,\r\n\t\t_footerFontFamily: valueOrDefault$8(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),\r\n\t\t_footerFontStyle: valueOrDefault$8(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),\r\n\t\tfooterFontSize: valueOrDefault$8(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),\r\n\t\t_footerAlign: tooltipOpts.footerAlign,\r\n\t\tfooterSpacing: tooltipOpts.footerSpacing,\r\n\t\tfooterMarginTop: tooltipOpts.footerMarginTop,\r\n\r\n\t\t// Appearance\r\n\t\tcaretSize: tooltipOpts.caretSize,\r\n\t\tcornerRadius: tooltipOpts.cornerRadius,\r\n\t\tbackgroundColor: tooltipOpts.backgroundColor,\r\n\t\topacity: 0,\r\n\t\tlegendColorBackground: tooltipOpts.multiKeyBackground,\r\n\t\tdisplayColors: tooltipOpts.displayColors,\r\n\t\tborderColor: tooltipOpts.borderColor,\r\n\t\tborderWidth: tooltipOpts.borderWidth\r\n\t};\r\n}\r\n\r\n/**\r\n * Get the size of the tooltip\r\n */\r\nfunction getTooltipSize(tooltip, model) {\r\n\tvar ctx = tooltip._chart.ctx;\r\n\r\n\tvar height = model.yPadding * 2; // Tooltip Padding\r\n\tvar width = 0;\r\n\r\n\t// Count of all lines in the body\r\n\tvar body = model.body;\r\n\tvar combinedBodyLength = body.reduce(function(count, bodyItem) {\r\n\t\treturn count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;\r\n\t}, 0);\r\n\tcombinedBodyLength += model.beforeBody.length + model.afterBody.length;\r\n\r\n\tvar titleLineCount = model.title.length;\r\n\tvar footerLineCount = model.footer.length;\r\n\tvar titleFontSize = model.titleFontSize;\r\n\tvar bodyFontSize = model.bodyFontSize;\r\n\tvar footerFontSize = model.footerFontSize;\r\n\r\n\theight += titleLineCount * titleFontSize; // Title Lines\r\n\theight += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing\r\n\theight += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin\r\n\theight += combinedBodyLength * bodyFontSize; // Body Lines\r\n\theight += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing\r\n\theight += footerLineCount ? model.footerMarginTop : 0; // Footer Margin\r\n\theight += footerLineCount * (footerFontSize); // Footer Lines\r\n\theight += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing\r\n\r\n\t// Title width\r\n\tvar widthPadding = 0;\r\n\tvar maxLineWidth = function(line) {\r\n\t\twidth = Math.max(width, ctx.measureText(line).width + widthPadding);\r\n\t};\r\n\r\n\tctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);\r\n\thelpers$1.each(model.title, maxLineWidth);\r\n\r\n\t// Body width\r\n\tctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);\r\n\thelpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth);\r\n\r\n\t// Body lines may include some extra width due to the color box\r\n\twidthPadding = model.displayColors ? (bodyFontSize + 2) : 0;\r\n\thelpers$1.each(body, function(bodyItem) {\r\n\t\thelpers$1.each(bodyItem.before, maxLineWidth);\r\n\t\thelpers$1.each(bodyItem.lines, maxLineWidth);\r\n\t\thelpers$1.each(bodyItem.after, maxLineWidth);\r\n\t});\r\n\r\n\t// Reset back to 0\r\n\twidthPadding = 0;\r\n\r\n\t// Footer width\r\n\tctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);\r\n\thelpers$1.each(model.footer, maxLineWidth);\r\n\r\n\t// Add padding\r\n\twidth += 2 * model.xPadding;\r\n\r\n\treturn {\r\n\t\twidth: width,\r\n\t\theight: height\r\n\t};\r\n}\r\n\r\n/**\r\n * Helper to get the alignment of a tooltip given the size\r\n */\r\nfunction determineAlignment(tooltip, size) {\r\n\tvar model = tooltip._model;\r\n\tvar chart = tooltip._chart;\r\n\tvar chartArea = tooltip._chart.chartArea;\r\n\tvar xAlign = 'center';\r\n\tvar yAlign = 'center';\r\n\r\n\tif (model.y < size.height) {\r\n\t\tyAlign = 'top';\r\n\t} else if (model.y > (chart.height - size.height)) {\r\n\t\tyAlign = 'bottom';\r\n\t}\r\n\r\n\tvar lf, rf; // functions to determine left, right alignment\r\n\tvar olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\r\n\tvar yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\r\n\tvar midX = (chartArea.left + chartArea.right) / 2;\r\n\tvar midY = (chartArea.top + chartArea.bottom) / 2;\r\n\r\n\tif (yAlign === 'center') {\r\n\t\tlf = function(x) {\r\n\t\t\treturn x <= midX;\r\n\t\t};\r\n\t\trf = function(x) {\r\n\t\t\treturn x > midX;\r\n\t\t};\r\n\t} else {\r\n\t\tlf = function(x) {\r\n\t\t\treturn x <= (size.width / 2);\r\n\t\t};\r\n\t\trf = function(x) {\r\n\t\t\treturn x >= (chart.width - (size.width / 2));\r\n\t\t};\r\n\t}\r\n\r\n\tolf = function(x) {\r\n\t\treturn x + size.width + model.caretSize + model.caretPadding > chart.width;\r\n\t};\r\n\torf = function(x) {\r\n\t\treturn x - size.width - model.caretSize - model.caretPadding < 0;\r\n\t};\r\n\tyf = function(y) {\r\n\t\treturn y <= midY ? 'top' : 'bottom';\r\n\t};\r\n\r\n\tif (lf(model.x)) {\r\n\t\txAlign = 'left';\r\n\r\n\t\t// Is tooltip too wide and goes over the right side of the chart.?\r\n\t\tif (olf(model.x)) {\r\n\t\t\txAlign = 'center';\r\n\t\t\tyAlign = yf(model.y);\r\n\t\t}\r\n\t} else if (rf(model.x)) {\r\n\t\txAlign = 'right';\r\n\r\n\t\t// Is tooltip too wide and goes outside left edge of canvas?\r\n\t\tif (orf(model.x)) {\r\n\t\t\txAlign = 'center';\r\n\t\t\tyAlign = yf(model.y);\r\n\t\t}\r\n\t}\r\n\r\n\tvar opts = tooltip._options;\r\n\treturn {\r\n\t\txAlign: opts.xAlign ? opts.xAlign : xAlign,\r\n\t\tyAlign: opts.yAlign ? opts.yAlign : yAlign\r\n\t};\r\n}\r\n\r\n/**\r\n * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\r\n */\r\nfunction getBackgroundPoint(vm, size, alignment, chart) {\r\n\t// Background Position\r\n\tvar x = vm.x;\r\n\tvar y = vm.y;\r\n\r\n\tvar caretSize = vm.caretSize;\r\n\tvar caretPadding = vm.caretPadding;\r\n\tvar cornerRadius = vm.cornerRadius;\r\n\tvar xAlign = alignment.xAlign;\r\n\tvar yAlign = alignment.yAlign;\r\n\tvar paddingAndSize = caretSize + caretPadding;\r\n\tvar radiusAndPadding = cornerRadius + caretPadding;\r\n\r\n\tif (xAlign === 'right') {\r\n\t\tx -= size.width;\r\n\t} else if (xAlign === 'center') {\r\n\t\tx -= (size.width / 2);\r\n\t\tif (x + size.width > chart.width) {\r\n\t\t\tx = chart.width - size.width;\r\n\t\t}\r\n\t\tif (x < 0) {\r\n\t\t\tx = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tif (yAlign === 'top') {\r\n\t\ty += paddingAndSize;\r\n\t} else if (yAlign === 'bottom') {\r\n\t\ty -= size.height + paddingAndSize;\r\n\t} else {\r\n\t\ty -= (size.height / 2);\r\n\t}\r\n\r\n\tif (yAlign === 'center') {\r\n\t\tif (xAlign === 'left') {\r\n\t\t\tx += paddingAndSize;\r\n\t\t} else if (xAlign === 'right') {\r\n\t\t\tx -= paddingAndSize;\r\n\t\t}\r\n\t} else if (xAlign === 'left') {\r\n\t\tx -= radiusAndPadding;\r\n\t} else if (xAlign === 'right') {\r\n\t\tx += radiusAndPadding;\r\n\t}\r\n\r\n\treturn {\r\n\t\tx: x,\r\n\t\ty: y\r\n\t};\r\n}\r\n\r\nfunction getAlignedX(vm, align) {\r\n\treturn align === 'center'\r\n\t\t? vm.x + vm.width / 2\r\n\t\t: align === 'right'\r\n\t\t\t? vm.x + vm.width - vm.xPadding\r\n\t\t\t: vm.x + vm.xPadding;\r\n}\r\n\r\n/**\r\n * Helper to build before and after body lines\r\n */\r\nfunction getBeforeAfterBodyLines(callback) {\r\n\treturn pushOrConcat([], splitNewlines(callback));\r\n}\r\n\r\nvar exports$4 = core_element.extend({\r\n\tinitialize: function() {\r\n\t\tthis._model = getBaseModel(this._options);\r\n\t\tthis._lastActive = [];\r\n\t},\r\n\r\n\t// Get the title\r\n\t// Args are: (tooltipItem, data)\r\n\tgetTitle: function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me._options;\r\n\t\tvar callbacks = opts.callbacks;\r\n\r\n\t\tvar beforeTitle = callbacks.beforeTitle.apply(me, arguments);\r\n\t\tvar title = callbacks.title.apply(me, arguments);\r\n\t\tvar afterTitle = callbacks.afterTitle.apply(me, arguments);\r\n\r\n\t\tvar lines = [];\r\n\t\tlines = pushOrConcat(lines, splitNewlines(beforeTitle));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(title));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(afterTitle));\r\n\r\n\t\treturn lines;\r\n\t},\r\n\r\n\t// Args are: (tooltipItem, data)\r\n\tgetBeforeBody: function() {\r\n\t\treturn getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));\r\n\t},\r\n\r\n\t// Args are: (tooltipItem, data)\r\n\tgetBody: function(tooltipItems, data) {\r\n\t\tvar me = this;\r\n\t\tvar callbacks = me._options.callbacks;\r\n\t\tvar bodyItems = [];\r\n\r\n\t\thelpers$1.each(tooltipItems, function(tooltipItem) {\r\n\t\t\tvar bodyItem = {\r\n\t\t\t\tbefore: [],\r\n\t\t\t\tlines: [],\r\n\t\t\t\tafter: []\r\n\t\t\t};\r\n\t\t\tpushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));\r\n\t\t\tpushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\r\n\t\t\tpushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));\r\n\r\n\t\t\tbodyItems.push(bodyItem);\r\n\t\t});\r\n\r\n\t\treturn bodyItems;\r\n\t},\r\n\r\n\t// Args are: (tooltipItem, data)\r\n\tgetAfterBody: function() {\r\n\t\treturn getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));\r\n\t},\r\n\r\n\t// Get the footer and beforeFooter and afterFooter lines\r\n\t// Args are: (tooltipItem, data)\r\n\tgetFooter: function() {\r\n\t\tvar me = this;\r\n\t\tvar callbacks = me._options.callbacks;\r\n\r\n\t\tvar beforeFooter = callbacks.beforeFooter.apply(me, arguments);\r\n\t\tvar footer = callbacks.footer.apply(me, arguments);\r\n\t\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);\r\n\r\n\t\tvar lines = [];\r\n\t\tlines = pushOrConcat(lines, splitNewlines(beforeFooter));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(footer));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(afterFooter));\r\n\r\n\t\treturn lines;\r\n\t},\r\n\r\n\tupdate: function(changed) {\r\n\t\tvar me = this;\r\n\t\tvar opts = me._options;\r\n\r\n\t\t// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition\r\n\t\t// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time\r\n\t\t// which breaks any animations.\r\n\t\tvar existingModel = me._model;\r\n\t\tvar model = me._model = getBaseModel(opts);\r\n\t\tvar active = me._active;\r\n\r\n\t\tvar data = me._data;\r\n\r\n\t\t// In the case where active.length === 0 we need to keep these at existing values for good animations\r\n\t\tvar alignment = {\r\n\t\t\txAlign: existingModel.xAlign,\r\n\t\t\tyAlign: existingModel.yAlign\r\n\t\t};\r\n\t\tvar backgroundPoint = {\r\n\t\t\tx: existingModel.x,\r\n\t\t\ty: existingModel.y\r\n\t\t};\r\n\t\tvar tooltipSize = {\r\n\t\t\twidth: existingModel.width,\r\n\t\t\theight: existingModel.height\r\n\t\t};\r\n\t\tvar tooltipPosition = {\r\n\t\t\tx: existingModel.caretX,\r\n\t\t\ty: existingModel.caretY\r\n\t\t};\r\n\r\n\t\tvar i, len;\r\n\r\n\t\tif (active.length) {\r\n\t\t\tmodel.opacity = 1;\r\n\r\n\t\t\tvar labelColors = [];\r\n\t\t\tvar labelTextColors = [];\r\n\t\t\ttooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);\r\n\r\n\t\t\tvar tooltipItems = [];\r\n\t\t\tfor (i = 0, len = active.length; i < len; ++i) {\r\n\t\t\t\ttooltipItems.push(createTooltipItem(active[i]));\r\n\t\t\t}\r\n\r\n\t\t\t// If the user provided a filter function, use it to modify the tooltip items\r\n\t\t\tif (opts.filter) {\r\n\t\t\t\ttooltipItems = tooltipItems.filter(function(a) {\r\n\t\t\t\t\treturn opts.filter(a, data);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// If the user provided a sorting function, use it to modify the tooltip items\r\n\t\t\tif (opts.itemSort) {\r\n\t\t\t\ttooltipItems = tooltipItems.sort(function(a, b) {\r\n\t\t\t\t\treturn opts.itemSort(a, b, data);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Determine colors for boxes\r\n\t\t\thelpers$1.each(tooltipItems, function(tooltipItem) {\r\n\t\t\t\tlabelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));\r\n\t\t\t\tlabelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));\r\n\t\t\t});\r\n\r\n\r\n\t\t\t// Build the Text Lines\r\n\t\t\tmodel.title = me.getTitle(tooltipItems, data);\r\n\t\t\tmodel.beforeBody = me.getBeforeBody(tooltipItems, data);\r\n\t\t\tmodel.body = me.getBody(tooltipItems, data);\r\n\t\t\tmodel.afterBody = me.getAfterBody(tooltipItems, data);\r\n\t\t\tmodel.footer = me.getFooter(tooltipItems, data);\r\n\r\n\t\t\t// Initial positioning and colors\r\n\t\t\tmodel.x = tooltipPosition.x;\r\n\t\t\tmodel.y = tooltipPosition.y;\r\n\t\t\tmodel.caretPadding = opts.caretPadding;\r\n\t\t\tmodel.labelColors = labelColors;\r\n\t\t\tmodel.labelTextColors = labelTextColors;\r\n\r\n\t\t\t// data points\r\n\t\t\tmodel.dataPoints = tooltipItems;\r\n\r\n\t\t\t// We need to determine alignment of the tooltip\r\n\t\t\ttooltipSize = getTooltipSize(this, model);\r\n\t\t\talignment = determineAlignment(this, tooltipSize);\r\n\t\t\t// Final Size and Position\r\n\t\t\tbackgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);\r\n\t\t} else {\r\n\t\t\tmodel.opacity = 0;\r\n\t\t}\r\n\r\n\t\tmodel.xAlign = alignment.xAlign;\r\n\t\tmodel.yAlign = alignment.yAlign;\r\n\t\tmodel.x = backgroundPoint.x;\r\n\t\tmodel.y = backgroundPoint.y;\r\n\t\tmodel.width = tooltipSize.width;\r\n\t\tmodel.height = tooltipSize.height;\r\n\r\n\t\t// Point where the caret on the tooltip points to\r\n\t\tmodel.caretX = tooltipPosition.x;\r\n\t\tmodel.caretY = tooltipPosition.y;\r\n\r\n\t\tme._model = model;\r\n\r\n\t\tif (changed && opts.custom) {\r\n\t\t\topts.custom.call(me, model);\r\n\t\t}\r\n\r\n\t\treturn me;\r\n\t},\r\n\r\n\tdrawCaret: function(tooltipPoint, size) {\r\n\t\tvar ctx = this._chart.ctx;\r\n\t\tvar vm = this._view;\r\n\t\tvar caretPosition = this.getCaretPosition(tooltipPoint, size, vm);\r\n\r\n\t\tctx.lineTo(caretPosition.x1, caretPosition.y1);\r\n\t\tctx.lineTo(caretPosition.x2, caretPosition.y2);\r\n\t\tctx.lineTo(caretPosition.x3, caretPosition.y3);\r\n\t},\r\n\tgetCaretPosition: function(tooltipPoint, size, vm) {\r\n\t\tvar x1, x2, x3, y1, y2, y3;\r\n\t\tvar caretSize = vm.caretSize;\r\n\t\tvar cornerRadius = vm.cornerRadius;\r\n\t\tvar xAlign = vm.xAlign;\r\n\t\tvar yAlign = vm.yAlign;\r\n\t\tvar ptX = tooltipPoint.x;\r\n\t\tvar ptY = tooltipPoint.y;\r\n\t\tvar width = size.width;\r\n\t\tvar height = size.height;\r\n\r\n\t\tif (yAlign === 'center') {\r\n\t\t\ty2 = ptY + (height / 2);\r\n\r\n\t\t\tif (xAlign === 'left') {\r\n\t\t\t\tx1 = ptX;\r\n\t\t\t\tx2 = x1 - caretSize;\r\n\t\t\t\tx3 = x1;\r\n\r\n\t\t\t\ty1 = y2 + caretSize;\r\n\t\t\t\ty3 = y2 - caretSize;\r\n\t\t\t} else {\r\n\t\t\t\tx1 = ptX + width;\r\n\t\t\t\tx2 = x1 + caretSize;\r\n\t\t\t\tx3 = x1;\r\n\r\n\t\t\t\ty1 = y2 - caretSize;\r\n\t\t\t\ty3 = y2 + caretSize;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (xAlign === 'left') {\r\n\t\t\t\tx2 = ptX + cornerRadius + (caretSize);\r\n\t\t\t\tx1 = x2 - caretSize;\r\n\t\t\t\tx3 = x2 + caretSize;\r\n\t\t\t} else if (xAlign === 'right') {\r\n\t\t\t\tx2 = ptX + width - cornerRadius - caretSize;\r\n\t\t\t\tx1 = x2 - caretSize;\r\n\t\t\t\tx3 = x2 + caretSize;\r\n\t\t\t} else {\r\n\t\t\t\tx2 = vm.caretX;\r\n\t\t\t\tx1 = x2 - caretSize;\r\n\t\t\t\tx3 = x2 + caretSize;\r\n\t\t\t}\r\n\t\t\tif (yAlign === 'top') {\r\n\t\t\t\ty1 = ptY;\r\n\t\t\t\ty2 = y1 - caretSize;\r\n\t\t\t\ty3 = y1;\r\n\t\t\t} else {\r\n\t\t\t\ty1 = ptY + height;\r\n\t\t\t\ty2 = y1 + caretSize;\r\n\t\t\t\ty3 = y1;\r\n\t\t\t\t// invert drawing order\r\n\t\t\t\tvar tmp = x3;\r\n\t\t\t\tx3 = x1;\r\n\t\t\t\tx1 = tmp;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn {x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3};\r\n\t},\r\n\r\n\tdrawTitle: function(pt, vm, ctx) {\r\n\t\tvar title = vm.title;\r\n\t\tvar length = title.length;\r\n\t\tvar titleFontSize, titleSpacing, i;\r\n\r\n\t\tif (length) {\r\n\t\t\tvar rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);\r\n\r\n\t\t\tpt.x = getAlignedX(vm, vm._titleAlign);\r\n\r\n\t\t\tctx.textAlign = rtlHelper.textAlign(vm._titleAlign);\r\n\t\t\tctx.textBaseline = 'middle';\r\n\r\n\t\t\ttitleFontSize = vm.titleFontSize;\r\n\t\t\ttitleSpacing = vm.titleSpacing;\r\n\r\n\t\t\tctx.fillStyle = vm.titleFontColor;\r\n\t\t\tctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);\r\n\r\n\t\t\tfor (i = 0; i < length; ++i) {\r\n\t\t\t\tctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFontSize / 2);\r\n\t\t\t\tpt.y += titleFontSize + titleSpacing; // Line Height and spacing\r\n\r\n\t\t\t\tif (i + 1 === length) {\r\n\t\t\t\t\tpt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tdrawBody: function(pt, vm, ctx) {\r\n\t\tvar bodyFontSize = vm.bodyFontSize;\r\n\t\tvar bodySpacing = vm.bodySpacing;\r\n\t\tvar bodyAlign = vm._bodyAlign;\r\n\t\tvar body = vm.body;\r\n\t\tvar drawColorBoxes = vm.displayColors;\r\n\t\tvar xLinePadding = 0;\r\n\t\tvar colorX = drawColorBoxes ? getAlignedX(vm, 'left') : 0;\r\n\r\n\t\tvar rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);\r\n\r\n\t\tvar fillLineOfText = function(line) {\r\n\t\t\tctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyFontSize / 2);\r\n\t\t\tpt.y += bodyFontSize + bodySpacing;\r\n\t\t};\r\n\r\n\t\tvar bodyItem, textColor, labelColors, lines, i, j, ilen, jlen;\r\n\t\tvar bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\r\n\r\n\t\tctx.textAlign = bodyAlign;\r\n\t\tctx.textBaseline = 'middle';\r\n\t\tctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\r\n\r\n\t\tpt.x = getAlignedX(vm, bodyAlignForCalculation);\r\n\r\n\t\t// Before body lines\r\n\t\tctx.fillStyle = vm.bodyFontColor;\r\n\t\thelpers$1.each(vm.beforeBody, fillLineOfText);\r\n\r\n\t\txLinePadding = drawColorBoxes && bodyAlignForCalculation !== 'right'\r\n\t\t\t? bodyAlign === 'center' ? (bodyFontSize / 2 + 1) : (bodyFontSize + 2)\r\n\t\t\t: 0;\r\n\r\n\t\t// Draw body lines now\r\n\t\tfor (i = 0, ilen = body.length; i < ilen; ++i) {\r\n\t\t\tbodyItem = body[i];\r\n\t\t\ttextColor = vm.labelTextColors[i];\r\n\t\t\tlabelColors = vm.labelColors[i];\r\n\r\n\t\t\tctx.fillStyle = textColor;\r\n\t\t\thelpers$1.each(bodyItem.before, fillLineOfText);\r\n\r\n\t\t\tlines = bodyItem.lines;\r\n\t\t\tfor (j = 0, jlen = lines.length; j < jlen; ++j) {\r\n\t\t\t\t// Draw Legend-like boxes if needed\r\n\t\t\t\tif (drawColorBoxes) {\r\n\t\t\t\t\tvar rtlColorX = rtlHelper.x(colorX);\r\n\r\n\t\t\t\t\t// Fill a white rect so that colours merge nicely if the opacity is < 1\r\n\t\t\t\t\tctx.fillStyle = vm.legendColorBackground;\r\n\t\t\t\t\tctx.fillRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize);\r\n\r\n\t\t\t\t\t// Border\r\n\t\t\t\t\tctx.lineWidth = 1;\r\n\t\t\t\t\tctx.strokeStyle = labelColors.borderColor;\r\n\t\t\t\t\tctx.strokeRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize);\r\n\r\n\t\t\t\t\t// Inner square\r\n\t\t\t\t\tctx.fillStyle = labelColors.backgroundColor;\r\n\t\t\t\t\tctx.fillRect(rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), bodyFontSize - 2), pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\r\n\t\t\t\t\tctx.fillStyle = textColor;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfillLineOfText(lines[j]);\r\n\t\t\t}\r\n\r\n\t\t\thelpers$1.each(bodyItem.after, fillLineOfText);\r\n\t\t}\r\n\r\n\t\t// Reset back to 0 for after body\r\n\t\txLinePadding = 0;\r\n\r\n\t\t// After body lines\r\n\t\thelpers$1.each(vm.afterBody, fillLineOfText);\r\n\t\tpt.y -= bodySpacing; // Remove last body spacing\r\n\t},\r\n\r\n\tdrawFooter: function(pt, vm, ctx) {\r\n\t\tvar footer = vm.footer;\r\n\t\tvar length = footer.length;\r\n\t\tvar footerFontSize, i;\r\n\r\n\t\tif (length) {\r\n\t\t\tvar rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);\r\n\r\n\t\t\tpt.x = getAlignedX(vm, vm._footerAlign);\r\n\t\t\tpt.y += vm.footerMarginTop;\r\n\r\n\t\t\tctx.textAlign = rtlHelper.textAlign(vm._footerAlign);\r\n\t\t\tctx.textBaseline = 'middle';\r\n\r\n\t\t\tfooterFontSize = vm.footerFontSize;\r\n\r\n\t\t\tctx.fillStyle = vm.footerFontColor;\r\n\t\t\tctx.font = helpers$1.fontString(footerFontSize, vm._footerFontStyle, vm._footerFontFamily);\r\n\r\n\t\t\tfor (i = 0; i < length; ++i) {\r\n\t\t\t\tctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFontSize / 2);\r\n\t\t\t\tpt.y += footerFontSize + vm.footerSpacing;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tdrawBackground: function(pt, vm, ctx, tooltipSize) {\r\n\t\tctx.fillStyle = vm.backgroundColor;\r\n\t\tctx.strokeStyle = vm.borderColor;\r\n\t\tctx.lineWidth = vm.borderWidth;\r\n\t\tvar xAlign = vm.xAlign;\r\n\t\tvar yAlign = vm.yAlign;\r\n\t\tvar x = pt.x;\r\n\t\tvar y = pt.y;\r\n\t\tvar width = tooltipSize.width;\r\n\t\tvar height = tooltipSize.height;\r\n\t\tvar radius = vm.cornerRadius;\r\n\r\n\t\tctx.beginPath();\r\n\t\tctx.moveTo(x + radius, y);\r\n\t\tif (yAlign === 'top') {\r\n\t\t\tthis.drawCaret(pt, tooltipSize);\r\n\t\t}\r\n\t\tctx.lineTo(x + width - radius, y);\r\n\t\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\r\n\t\tif (yAlign === 'center' && xAlign === 'right') {\r\n\t\t\tthis.drawCaret(pt, tooltipSize);\r\n\t\t}\r\n\t\tctx.lineTo(x + width, y + height - radius);\r\n\t\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\r\n\t\tif (yAlign === 'bottom') {\r\n\t\t\tthis.drawCaret(pt, tooltipSize);\r\n\t\t}\r\n\t\tctx.lineTo(x + radius, y + height);\r\n\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\r\n\t\tif (yAlign === 'center' && xAlign === 'left') {\r\n\t\t\tthis.drawCaret(pt, tooltipSize);\r\n\t\t}\r\n\t\tctx.lineTo(x, y + radius);\r\n\t\tctx.quadraticCurveTo(x, y, x + radius, y);\r\n\t\tctx.closePath();\r\n\r\n\t\tctx.fill();\r\n\r\n\t\tif (vm.borderWidth > 0) {\r\n\t\t\tctx.stroke();\r\n\t\t}\r\n\t},\r\n\r\n\tdraw: function() {\r\n\t\tvar ctx = this._chart.ctx;\r\n\t\tvar vm = this._view;\r\n\r\n\t\tif (vm.opacity === 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar tooltipSize = {\r\n\t\t\twidth: vm.width,\r\n\t\t\theight: vm.height\r\n\t\t};\r\n\t\tvar pt = {\r\n\t\t\tx: vm.x,\r\n\t\t\ty: vm.y\r\n\t\t};\r\n\r\n\t\t// IE11/Edge does not like very small opacities, so snap to 0\r\n\t\tvar opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;\r\n\r\n\t\t// Truthy/falsey value for empty tooltip\r\n\t\tvar hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;\r\n\r\n\t\tif (this._options.enabled && hasTooltipContent) {\r\n\t\t\tctx.save();\r\n\t\t\tctx.globalAlpha = opacity;\r\n\r\n\t\t\t// Draw Background\r\n\t\t\tthis.drawBackground(pt, vm, ctx, tooltipSize);\r\n\r\n\t\t\t// Draw Title, Body, and Footer\r\n\t\t\tpt.y += vm.yPadding;\r\n\r\n\t\t\thelpers$1.rtl.overrideTextDirection(ctx, vm.textDirection);\r\n\r\n\t\t\t// Titles\r\n\t\t\tthis.drawTitle(pt, vm, ctx);\r\n\r\n\t\t\t// Body\r\n\t\t\tthis.drawBody(pt, vm, ctx);\r\n\r\n\t\t\t// Footer\r\n\t\t\tthis.drawFooter(pt, vm, ctx);\r\n\r\n\t\t\thelpers$1.rtl.restoreTextDirection(ctx, vm.textDirection);\r\n\r\n\t\t\tctx.restore();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Handle an event\r\n\t * @private\r\n\t * @param {IEvent} event - The event to handle\r\n\t * @returns {boolean} true if the tooltip changed\r\n\t */\r\n\thandleEvent: function(e) {\r\n\t\tvar me = this;\r\n\t\tvar options = me._options;\r\n\t\tvar changed = false;\r\n\r\n\t\tme._lastActive = me._lastActive || [];\r\n\r\n\t\t// Find Active Elements for tooltips\r\n\t\tif (e.type === 'mouseout') {\r\n\t\t\tme._active = [];\r\n\t\t} else {\r\n\t\t\tme._active = me._chart.getElementsAtEventForMode(e, options.mode, options);\r\n\t\t\tif (options.reverse) {\r\n\t\t\t\tme._active.reverse();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Remember Last Actives\r\n\t\tchanged = !helpers$1.arrayEquals(me._active, me._lastActive);\r\n\r\n\t\t// Only handle target event on tooltip change\r\n\t\tif (changed) {\r\n\t\t\tme._lastActive = me._active;\r\n\r\n\t\t\tif (options.enabled || options.custom) {\r\n\t\t\t\tme._eventPosition = {\r\n\t\t\t\t\tx: e.x,\r\n\t\t\t\t\ty: e.y\r\n\t\t\t\t};\r\n\r\n\t\t\t\tme.update(true);\r\n\t\t\t\tme.pivot();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn changed;\r\n\t}\r\n});\r\n\r\n/**\r\n * @namespace Chart.Tooltip.positioners\r\n */\r\nvar positioners_1 = positioners;\r\n\r\nvar core_tooltip = exports$4;\ncore_tooltip.positioners = positioners_1;\n\nvar valueOrDefault$9 = helpers$1.valueOrDefault;\r\n\r\ncore_defaults._set('global', {\r\n\telements: {},\r\n\tevents: [\r\n\t\t'mousemove',\r\n\t\t'mouseout',\r\n\t\t'click',\r\n\t\t'touchstart',\r\n\t\t'touchmove'\r\n\t],\r\n\thover: {\r\n\t\tonHover: null,\r\n\t\tmode: 'nearest',\r\n\t\tintersect: true,\r\n\t\tanimationDuration: 400\r\n\t},\r\n\tonClick: null,\r\n\tmaintainAspectRatio: true,\r\n\tresponsive: true,\r\n\tresponsiveAnimationDuration: 0\r\n});\r\n\r\n/**\r\n * Recursively merge the given config objects representing the `scales` option\r\n * by incorporating scale defaults in `xAxes` and `yAxes` array items, then\r\n * returns a deep copy of the result, thus doesn't alter inputs.\r\n */\r\nfunction mergeScaleConfig(/* config objects ... */) {\r\n\treturn helpers$1.merge(Object.create(null), [].slice.call(arguments), {\r\n\t\tmerger: function(key, target, source, options) {\r\n\t\t\tif (key === 'xAxes' || key === 'yAxes') {\r\n\t\t\t\tvar slen = source[key].length;\r\n\t\t\t\tvar i, type, scale;\r\n\r\n\t\t\t\tif (!target[key]) {\r\n\t\t\t\t\ttarget[key] = [];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (i = 0; i < slen; ++i) {\r\n\t\t\t\t\tscale = source[key][i];\r\n\t\t\t\t\ttype = valueOrDefault$9(scale.type, key === 'xAxes' ? 'category' : 'linear');\r\n\r\n\t\t\t\t\tif (i >= target[key].length) {\r\n\t\t\t\t\t\ttarget[key].push({});\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!target[key][i].type || (scale.type && scale.type !== target[key][i].type)) {\r\n\t\t\t\t\t\t// new/untyped scale or type changed: let's apply the new defaults\r\n\t\t\t\t\t\t// then merge source scale to correctly overwrite the defaults.\r\n\t\t\t\t\t\thelpers$1.merge(target[key][i], [core_scaleService.getScaleDefaults(type), scale]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// scales type are the same\r\n\t\t\t\t\t\thelpers$1.merge(target[key][i], scale);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\thelpers$1._merger(key, target, source, options);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n}\r\n\r\n/**\r\n * Recursively merge the given config objects as the root options by handling\r\n * default scale options for the `scales` and `scale` properties, then returns\r\n * a deep copy of the result, thus doesn't alter inputs.\r\n */\r\nfunction mergeConfig(/* config objects ... */) {\r\n\treturn helpers$1.merge(Object.create(null), [].slice.call(arguments), {\r\n\t\tmerger: function(key, target, source, options) {\r\n\t\t\tvar tval = target[key] || Object.create(null);\r\n\t\t\tvar sval = source[key];\r\n\r\n\t\t\tif (key === 'scales') {\r\n\t\t\t\t// scale config merging is complex. Add our own function here for that\r\n\t\t\t\ttarget[key] = mergeScaleConfig(tval, sval);\r\n\t\t\t} else if (key === 'scale') {\r\n\t\t\t\t// used in polar area & radar charts since there is only one scale\r\n\t\t\t\ttarget[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);\r\n\t\t\t} else {\r\n\t\t\t\thelpers$1._merger(key, target, source, options);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n}\r\n\r\nfunction initConfig(config) {\r\n\tconfig = config || Object.create(null);\r\n\r\n\t// Do NOT use mergeConfig for the data object because this method merges arrays\r\n\t// and so would change references to labels and datasets, preventing data updates.\r\n\tvar data = config.data = config.data || {};\r\n\tdata.datasets = data.datasets || [];\r\n\tdata.labels = data.labels || [];\r\n\r\n\tconfig.options = mergeConfig(\r\n\t\tcore_defaults.global,\r\n\t\tcore_defaults[config.type],\r\n\t\tconfig.options || {});\r\n\r\n\treturn config;\r\n}\r\n\r\nfunction updateConfig(chart) {\r\n\tvar newOptions = chart.options;\r\n\r\n\thelpers$1.each(chart.scales, function(scale) {\r\n\t\tcore_layouts.removeBox(chart, scale);\r\n\t});\r\n\r\n\tnewOptions = mergeConfig(\r\n\t\tcore_defaults.global,\r\n\t\tcore_defaults[chart.config.type],\r\n\t\tnewOptions);\r\n\r\n\tchart.options = chart.config.options = newOptions;\r\n\tchart.ensureScalesHaveIDs();\r\n\tchart.buildOrUpdateScales();\r\n\r\n\t// Tooltip\r\n\tchart.tooltip._options = newOptions.tooltips;\r\n\tchart.tooltip.initialize();\r\n}\r\n\r\nfunction nextAvailableScaleId(axesOpts, prefix, index) {\r\n\tvar id;\r\n\tvar hasId = function(obj) {\r\n\t\treturn obj.id === id;\r\n\t};\r\n\r\n\tdo {\r\n\t\tid = prefix + index++;\r\n\t} while (helpers$1.findIndex(axesOpts, hasId) >= 0);\r\n\r\n\treturn id;\r\n}\r\n\r\nfunction positionIsHorizontal(position) {\r\n\treturn position === 'top' || position === 'bottom';\r\n}\r\n\r\nfunction compare2Level(l1, l2) {\r\n\treturn function(a, b) {\r\n\t\treturn a[l1] === b[l1]\r\n\t\t\t? a[l2] - b[l2]\r\n\t\t\t: a[l1] - b[l1];\r\n\t};\r\n}\r\n\r\nvar Chart = function(item, config) {\r\n\tthis.construct(item, config);\r\n\treturn this;\r\n};\r\n\r\nhelpers$1.extend(Chart.prototype, /** @lends Chart */ {\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tconstruct: function(item, config) {\r\n\t\tvar me = this;\r\n\r\n\t\tconfig = initConfig(config);\r\n\r\n\t\tvar context = platform.acquireContext(item, config);\r\n\t\tvar canvas = context && context.canvas;\r\n\t\tvar height = canvas && canvas.height;\r\n\t\tvar width = canvas && canvas.width;\r\n\r\n\t\tme.id = helpers$1.uid();\r\n\t\tme.ctx = context;\r\n\t\tme.canvas = canvas;\r\n\t\tme.config = config;\r\n\t\tme.width = width;\r\n\t\tme.height = height;\r\n\t\tme.aspectRatio = height ? width / height : null;\r\n\t\tme.options = config.options;\r\n\t\tme._bufferedRender = false;\r\n\t\tme._layers = [];\r\n\r\n\t\t/**\r\n\t\t * Provided for backward compatibility, Chart and Chart.Controller have been merged,\r\n\t\t * the \"instance\" still need to be defined since it might be called from plugins.\r\n\t\t * @prop Chart#chart\r\n\t\t * @deprecated since version 2.6.0\r\n\t\t * @todo remove at version 3\r\n\t\t * @private\r\n\t\t */\r\n\t\tme.chart = me;\r\n\t\tme.controller = me; // chart.chart.controller #inception\r\n\r\n\t\t// Add the chart instance to the global namespace\r\n\t\tChart.instances[me.id] = me;\r\n\r\n\t\t// Define alias to the config data: `chart.data === chart.config.data`\r\n\t\tObject.defineProperty(me, 'data', {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn me.config.data;\r\n\t\t\t},\r\n\t\t\tset: function(value) {\r\n\t\t\t\tme.config.data = value;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tif (!context || !canvas) {\r\n\t\t\t// The given item is not a compatible context2d element, let's return before finalizing\r\n\t\t\t// the chart initialization but after setting basic chart / controller properties that\r\n\t\t\t// can help to figure out that the chart is not valid (e.g chart.canvas !== null);\r\n\t\t\t// https://github.com/chartjs/Chart.js/issues/2807\r\n\t\t\tconsole.error(\"Failed to create chart: can't acquire context from the given item\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tme.initialize();\r\n\t\tme.update();\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tinitialize: function() {\r\n\t\tvar me = this;\r\n\r\n\t\t// Before init plugin notification\r\n\t\tcore_plugins.notify(me, 'beforeInit');\r\n\r\n\t\thelpers$1.retinaScale(me, me.options.devicePixelRatio);\r\n\r\n\t\tme.bindEvents();\r\n\r\n\t\tif (me.options.responsive) {\r\n\t\t\t// Initial resize before chart draws (must be silent to preserve initial animations).\r\n\t\t\tme.resize(true);\r\n\t\t}\r\n\r\n\t\tme.initToolTip();\r\n\r\n\t\t// After init plugin notification\r\n\t\tcore_plugins.notify(me, 'afterInit');\r\n\r\n\t\treturn me;\r\n\t},\r\n\r\n\tclear: function() {\r\n\t\thelpers$1.canvas.clear(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstop: function() {\r\n\t\t// Stops any current animation loop occurring\r\n\t\tcore_animations.cancelAnimation(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tresize: function(silent) {\r\n\t\tvar me = this;\r\n\t\tvar options = me.options;\r\n\t\tvar canvas = me.canvas;\r\n\t\tvar aspectRatio = (options.maintainAspectRatio && me.aspectRatio) || null;\r\n\r\n\t\t// the canvas render width and height will be casted to integers so make sure that\r\n\t\t// the canvas display style uses the same integer values to avoid blurring effect.\r\n\r\n\t\t// Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collapsed\r\n\t\tvar newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas)));\r\n\t\tvar newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas)));\r\n\r\n\t\tif (me.width === newWidth && me.height === newHeight) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tcanvas.width = me.width = newWidth;\r\n\t\tcanvas.height = me.height = newHeight;\r\n\t\tcanvas.style.width = newWidth + 'px';\r\n\t\tcanvas.style.height = newHeight + 'px';\r\n\r\n\t\thelpers$1.retinaScale(me, options.devicePixelRatio);\r\n\r\n\t\tif (!silent) {\r\n\t\t\t// Notify any plugins about the resize\r\n\t\t\tvar newSize = {width: newWidth, height: newHeight};\r\n\t\t\tcore_plugins.notify(me, 'resize', [newSize]);\r\n\r\n\t\t\t// Notify of resize\r\n\t\t\tif (options.onResize) {\r\n\t\t\t\toptions.onResize(me, newSize);\r\n\t\t\t}\r\n\r\n\t\t\tme.stop();\r\n\t\t\tme.update({\r\n\t\t\t\tduration: options.responsiveAnimationDuration\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\tensureScalesHaveIDs: function() {\r\n\t\tvar options = this.options;\r\n\t\tvar scalesOptions = options.scales || {};\r\n\t\tvar scaleOptions = options.scale;\r\n\r\n\t\thelpers$1.each(scalesOptions.xAxes, function(xAxisOptions, index) {\r\n\t\t\tif (!xAxisOptions.id) {\r\n\t\t\t\txAxisOptions.id = nextAvailableScaleId(scalesOptions.xAxes, 'x-axis-', index);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\thelpers$1.each(scalesOptions.yAxes, function(yAxisOptions, index) {\r\n\t\t\tif (!yAxisOptions.id) {\r\n\t\t\t\tyAxisOptions.id = nextAvailableScaleId(scalesOptions.yAxes, 'y-axis-', index);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tif (scaleOptions) {\r\n\t\t\tscaleOptions.id = scaleOptions.id || 'scale';\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Builds a map of scale ID to scale object for future lookup.\r\n\t */\r\n\tbuildOrUpdateScales: function() {\r\n\t\tvar me = this;\r\n\t\tvar options = me.options;\r\n\t\tvar scales = me.scales || {};\r\n\t\tvar items = [];\r\n\t\tvar updated = Object.keys(scales).reduce(function(obj, id) {\r\n\t\t\tobj[id] = false;\r\n\t\t\treturn obj;\r\n\t\t}, {});\r\n\r\n\t\tif (options.scales) {\r\n\t\t\titems = items.concat(\r\n\t\t\t\t(options.scales.xAxes || []).map(function(xAxisOptions) {\r\n\t\t\t\t\treturn {options: xAxisOptions, dtype: 'category', dposition: 'bottom'};\r\n\t\t\t\t}),\r\n\t\t\t\t(options.scales.yAxes || []).map(function(yAxisOptions) {\r\n\t\t\t\t\treturn {options: yAxisOptions, dtype: 'linear', dposition: 'left'};\r\n\t\t\t\t})\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif (options.scale) {\r\n\t\t\titems.push({\r\n\t\t\t\toptions: options.scale,\r\n\t\t\t\tdtype: 'radialLinear',\r\n\t\t\t\tisDefault: true,\r\n\t\t\t\tdposition: 'chartArea'\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\thelpers$1.each(items, function(item) {\r\n\t\t\tvar scaleOptions = item.options;\r\n\t\t\tvar id = scaleOptions.id;\r\n\t\t\tvar scaleType = valueOrDefault$9(scaleOptions.type, item.dtype);\r\n\r\n\t\t\tif (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {\r\n\t\t\t\tscaleOptions.position = item.dposition;\r\n\t\t\t}\r\n\r\n\t\t\tupdated[id] = true;\r\n\t\t\tvar scale = null;\r\n\t\t\tif (id in scales && scales[id].type === scaleType) {\r\n\t\t\t\tscale = scales[id];\r\n\t\t\t\tscale.options = scaleOptions;\r\n\t\t\t\tscale.ctx = me.ctx;\r\n\t\t\t\tscale.chart = me;\r\n\t\t\t} else {\r\n\t\t\t\tvar scaleClass = core_scaleService.getScaleConstructor(scaleType);\r\n\t\t\t\tif (!scaleClass) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tscale = new scaleClass({\r\n\t\t\t\t\tid: id,\r\n\t\t\t\t\ttype: scaleType,\r\n\t\t\t\t\toptions: scaleOptions,\r\n\t\t\t\t\tctx: me.ctx,\r\n\t\t\t\t\tchart: me\r\n\t\t\t\t});\r\n\t\t\t\tscales[scale.id] = scale;\r\n\t\t\t}\r\n\r\n\t\t\tscale.mergeTicksOptions();\r\n\r\n\t\t\t// TODO(SB): I think we should be able to remove this custom case (options.scale)\r\n\t\t\t// and consider it as a regular scale part of the \"scales\"\" map only! This would\r\n\t\t\t// make the logic easier and remove some useless? custom code.\r\n\t\t\tif (item.isDefault) {\r\n\t\t\t\tme.scale = scale;\r\n\t\t\t}\r\n\t\t});\r\n\t\t// clear up discarded scales\r\n\t\thelpers$1.each(updated, function(hasUpdated, id) {\r\n\t\t\tif (!hasUpdated) {\r\n\t\t\t\tdelete scales[id];\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tme.scales = scales;\r\n\r\n\t\tcore_scaleService.addScalesToLayout(this);\r\n\t},\r\n\r\n\tbuildOrUpdateControllers: function() {\r\n\t\tvar me = this;\r\n\t\tvar newControllers = [];\r\n\t\tvar datasets = me.data.datasets;\r\n\t\tvar i, ilen;\r\n\r\n\t\tfor (i = 0, ilen = datasets.length; i < ilen; i++) {\r\n\t\t\tvar dataset = datasets[i];\r\n\t\t\tvar meta = me.getDatasetMeta(i);\r\n\t\t\tvar type = dataset.type || me.config.type;\r\n\r\n\t\t\tif (meta.type && meta.type !== type) {\r\n\t\t\t\tme.destroyDatasetMeta(i);\r\n\t\t\t\tmeta = me.getDatasetMeta(i);\r\n\t\t\t}\r\n\t\t\tmeta.type = type;\r\n\t\t\tmeta.order = dataset.order || 0;\r\n\t\t\tmeta.index = i;\r\n\r\n\t\t\tif (meta.controller) {\r\n\t\t\t\tmeta.controller.updateIndex(i);\r\n\t\t\t\tmeta.controller.linkScales();\r\n\t\t\t} else {\r\n\t\t\t\tvar ControllerClass = controllers[meta.type];\r\n\t\t\t\tif (ControllerClass === undefined) {\r\n\t\t\t\t\tthrow new Error('\"' + meta.type + '\" is not a chart type.');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmeta.controller = new ControllerClass(me, i);\r\n\t\t\t\tnewControllers.push(meta.controller);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn newControllers;\r\n\t},\r\n\r\n\t/**\r\n\t * Reset the elements of all datasets\r\n\t * @private\r\n\t */\r\n\tresetElements: function() {\r\n\t\tvar me = this;\r\n\t\thelpers$1.each(me.data.datasets, function(dataset, datasetIndex) {\r\n\t\t\tme.getDatasetMeta(datasetIndex).controller.reset();\r\n\t\t}, me);\r\n\t},\r\n\r\n\t/**\r\n\t* Resets the chart back to it's state before the initial animation\r\n\t*/\r\n\treset: function() {\r\n\t\tthis.resetElements();\r\n\t\tthis.tooltip.initialize();\r\n\t},\r\n\r\n\tupdate: function(config) {\r\n\t\tvar me = this;\r\n\t\tvar i, ilen;\r\n\r\n\t\tif (!config || typeof config !== 'object') {\r\n\t\t\t// backwards compatibility\r\n\t\t\tconfig = {\r\n\t\t\t\tduration: config,\r\n\t\t\t\tlazy: arguments[1]\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tupdateConfig(me);\r\n\r\n\t\t// plugins options references might have change, let's invalidate the cache\r\n\t\t// https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\r\n\t\tcore_plugins._invalidate(me);\r\n\r\n\t\tif (core_plugins.notify(me, 'beforeUpdate') === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// In case the entire data object changed\r\n\t\tme.tooltip._data = me.data;\r\n\r\n\t\t// Make sure dataset controllers are updated and new controllers are reset\r\n\t\tvar newControllers = me.buildOrUpdateControllers();\r\n\r\n\t\t// Make sure all dataset controllers have correct meta data counts\r\n\t\tfor (i = 0, ilen = me.data.datasets.length; i < ilen; i++) {\r\n\t\t\tme.getDatasetMeta(i).controller.buildOrUpdateElements();\r\n\t\t}\r\n\r\n\t\tme.updateLayout();\r\n\r\n\t\t// Can only reset the new controllers after the scales have been updated\r\n\t\tif (me.options.animation && me.options.animation.duration) {\r\n\t\t\thelpers$1.each(newControllers, function(controller) {\r\n\t\t\t\tcontroller.reset();\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tme.updateDatasets();\r\n\r\n\t\t// Need to reset tooltip in case it is displayed with elements that are removed\r\n\t\t// after update.\r\n\t\tme.tooltip.initialize();\r\n\r\n\t\t// Last active contains items that were previously in the tooltip.\r\n\t\t// When we reset the tooltip, we need to clear it\r\n\t\tme.lastActive = [];\r\n\r\n\t\t// Do this before render so that any plugins that need final scale updates can use it\r\n\t\tcore_plugins.notify(me, 'afterUpdate');\r\n\r\n\t\tme._layers.sort(compare2Level('z', '_idx'));\r\n\r\n\t\tif (me._bufferedRender) {\r\n\t\t\tme._bufferedRequest = {\r\n\t\t\t\tduration: config.duration,\r\n\t\t\t\teasing: config.easing,\r\n\t\t\t\tlazy: config.lazy\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tme.render(config);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\r\n\t * hook, in which case, plugins will not be called on `afterLayout`.\r\n\t * @private\r\n\t */\r\n\tupdateLayout: function() {\r\n\t\tvar me = this;\r\n\r\n\t\tif (core_plugins.notify(me, 'beforeLayout') === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tcore_layouts.update(this, this.width, this.height);\r\n\r\n\t\tme._layers = [];\r\n\t\thelpers$1.each(me.boxes, function(box) {\r\n\t\t\t// _configure is called twice, once in core.scale.update and once here.\r\n\t\t\t// Here the boxes are fully updated and at their final positions.\r\n\t\t\tif (box._configure) {\r\n\t\t\t\tbox._configure();\r\n\t\t\t}\r\n\t\t\tme._layers.push.apply(me._layers, box._layers());\r\n\t\t}, me);\r\n\r\n\t\tme._layers.forEach(function(item, index) {\r\n\t\t\titem._idx = index;\r\n\t\t});\r\n\r\n\t\t/**\r\n\t\t * Provided for backward compatibility, use `afterLayout` instead.\r\n\t\t * @method IPlugin#afterScaleUpdate\r\n\t\t * @deprecated since version 2.5.0\r\n\t\t * @todo remove at version 3\r\n\t\t * @private\r\n\t\t */\r\n\t\tcore_plugins.notify(me, 'afterScaleUpdate');\r\n\t\tcore_plugins.notify(me, 'afterLayout');\r\n\t},\r\n\r\n\t/**\r\n\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\r\n\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\r\n\t * @private\r\n\t */\r\n\tupdateDatasets: function() {\r\n\t\tvar me = this;\r\n\r\n\t\tif (core_plugins.notify(me, 'beforeDatasetsUpdate') === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfor (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\r\n\t\t\tme.updateDataset(i);\r\n\t\t}\r\n\r\n\t\tcore_plugins.notify(me, 'afterDatasetsUpdate');\r\n\t},\r\n\r\n\t/**\r\n\t * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\r\n\t * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\r\n\t * @private\r\n\t */\r\n\tupdateDataset: function(index) {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getDatasetMeta(index);\r\n\t\tvar args = {\r\n\t\t\tmeta: meta,\r\n\t\t\tindex: index\r\n\t\t};\r\n\r\n\t\tif (core_plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmeta.controller._update();\r\n\r\n\t\tcore_plugins.notify(me, 'afterDatasetUpdate', [args]);\r\n\t},\r\n\r\n\trender: function(config) {\r\n\t\tvar me = this;\r\n\r\n\t\tif (!config || typeof config !== 'object') {\r\n\t\t\t// backwards compatibility\r\n\t\t\tconfig = {\r\n\t\t\t\tduration: config,\r\n\t\t\t\tlazy: arguments[1]\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tvar animationOptions = me.options.animation;\r\n\t\tvar duration = valueOrDefault$9(config.duration, animationOptions && animationOptions.duration);\r\n\t\tvar lazy = config.lazy;\r\n\r\n\t\tif (core_plugins.notify(me, 'beforeRender') === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar onComplete = function(animation) {\r\n\t\t\tcore_plugins.notify(me, 'afterRender');\r\n\t\t\thelpers$1.callback(animationOptions && animationOptions.onComplete, [animation], me);\r\n\t\t};\r\n\r\n\t\tif (animationOptions && duration) {\r\n\t\t\tvar animation = new core_animation({\r\n\t\t\t\tnumSteps: duration / 16.66, // 60 fps\r\n\t\t\t\teasing: config.easing || animationOptions.easing,\r\n\r\n\t\t\t\trender: function(chart, animationObject) {\r\n\t\t\t\t\tvar easingFunction = helpers$1.easing.effects[animationObject.easing];\r\n\t\t\t\t\tvar currentStep = animationObject.currentStep;\r\n\t\t\t\t\tvar stepDecimal = currentStep / animationObject.numSteps;\r\n\r\n\t\t\t\t\tchart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);\r\n\t\t\t\t},\r\n\r\n\t\t\t\tonAnimationProgress: animationOptions.onProgress,\r\n\t\t\t\tonAnimationComplete: onComplete\r\n\t\t\t});\r\n\r\n\t\t\tcore_animations.addAnimation(me, animation, duration, lazy);\r\n\t\t} else {\r\n\t\t\tme.draw();\r\n\r\n\t\t\t// See https://github.com/chartjs/Chart.js/issues/3781\r\n\t\t\tonComplete(new core_animation({numSteps: 0, chart: me}));\r\n\t\t}\r\n\r\n\t\treturn me;\r\n\t},\r\n\r\n\tdraw: function(easingValue) {\r\n\t\tvar me = this;\r\n\t\tvar i, layers;\r\n\r\n\t\tme.clear();\r\n\r\n\t\tif (helpers$1.isNullOrUndef(easingValue)) {\r\n\t\t\teasingValue = 1;\r\n\t\t}\r\n\r\n\t\tme.transition(easingValue);\r\n\r\n\t\tif (me.width <= 0 || me.height <= 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (core_plugins.notify(me, 'beforeDraw', [easingValue]) === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Because of plugin hooks (before/afterDatasetsDraw), datasets can't\r\n\t\t// currently be part of layers. Instead, we draw\r\n\t\t// layers <= 0 before(default, backward compat), and the rest after\r\n\t\tlayers = me._layers;\r\n\t\tfor (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\r\n\t\t\tlayers[i].draw(me.chartArea);\r\n\t\t}\r\n\r\n\t\tme.drawDatasets(easingValue);\r\n\r\n\t\t// Rest of layers\r\n\t\tfor (; i < layers.length; ++i) {\r\n\t\t\tlayers[i].draw(me.chartArea);\r\n\t\t}\r\n\r\n\t\tme._drawTooltip(easingValue);\r\n\r\n\t\tcore_plugins.notify(me, 'afterDraw', [easingValue]);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\ttransition: function(easingValue) {\r\n\t\tvar me = this;\r\n\r\n\t\tfor (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {\r\n\t\t\tif (me.isDatasetVisible(i)) {\r\n\t\t\t\tme.getDatasetMeta(i).controller.transition(easingValue);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tme.tooltip.transition(easingValue);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getSortedDatasetMetas: function(filterVisible) {\r\n\t\tvar me = this;\r\n\t\tvar datasets = me.data.datasets || [];\r\n\t\tvar result = [];\r\n\t\tvar i, ilen;\r\n\r\n\t\tfor (i = 0, ilen = datasets.length; i < ilen; ++i) {\r\n\t\t\tif (!filterVisible || me.isDatasetVisible(i)) {\r\n\t\t\t\tresult.push(me.getDatasetMeta(i));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tresult.sort(compare2Level('order', 'index'));\r\n\r\n\t\treturn result;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getSortedVisibleDatasetMetas: function() {\r\n\t\treturn this._getSortedDatasetMetas(true);\r\n\t},\r\n\r\n\t/**\r\n\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\r\n\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\r\n\t * @private\r\n\t */\r\n\tdrawDatasets: function(easingValue) {\r\n\t\tvar me = this;\r\n\t\tvar metasets, i;\r\n\r\n\t\tif (core_plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmetasets = me._getSortedVisibleDatasetMetas();\r\n\t\tfor (i = metasets.length - 1; i >= 0; --i) {\r\n\t\t\tme.drawDataset(metasets[i], easingValue);\r\n\t\t}\r\n\r\n\t\tcore_plugins.notify(me, 'afterDatasetsDraw', [easingValue]);\r\n\t},\r\n\r\n\t/**\r\n\t * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\r\n\t * hook, in which case, plugins will not be called on `afterDatasetDraw`.\r\n\t * @private\r\n\t */\r\n\tdrawDataset: function(meta, easingValue) {\r\n\t\tvar me = this;\r\n\t\tvar args = {\r\n\t\t\tmeta: meta,\r\n\t\t\tindex: meta.index,\r\n\t\t\teasingValue: easingValue\r\n\t\t};\r\n\r\n\t\tif (core_plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmeta.controller.draw(easingValue);\r\n\r\n\t\tcore_plugins.notify(me, 'afterDatasetDraw', [args]);\r\n\t},\r\n\r\n\t/**\r\n\t * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`\r\n\t * hook, in which case, plugins will not be called on `afterTooltipDraw`.\r\n\t * @private\r\n\t */\r\n\t_drawTooltip: function(easingValue) {\r\n\t\tvar me = this;\r\n\t\tvar tooltip = me.tooltip;\r\n\t\tvar args = {\r\n\t\t\ttooltip: tooltip,\r\n\t\t\teasingValue: easingValue\r\n\t\t};\r\n\r\n\t\tif (core_plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\ttooltip.draw();\r\n\r\n\t\tcore_plugins.notify(me, 'afterTooltipDraw', [args]);\r\n\t},\r\n\r\n\t/**\r\n\t * Get the single element that was clicked on\r\n\t * @return An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw\r\n\t */\r\n\tgetElementAtEvent: function(e) {\r\n\t\treturn core_interaction.modes.single(this, e);\r\n\t},\r\n\r\n\tgetElementsAtEvent: function(e) {\r\n\t\treturn core_interaction.modes.label(this, e, {intersect: true});\r\n\t},\r\n\r\n\tgetElementsAtXAxis: function(e) {\r\n\t\treturn core_interaction.modes['x-axis'](this, e, {intersect: true});\r\n\t},\r\n\r\n\tgetElementsAtEventForMode: function(e, mode, options) {\r\n\t\tvar method = core_interaction.modes[mode];\r\n\t\tif (typeof method === 'function') {\r\n\t\t\treturn method(this, e, options);\r\n\t\t}\r\n\r\n\t\treturn [];\r\n\t},\r\n\r\n\tgetDatasetAtEvent: function(e) {\r\n\t\treturn core_interaction.modes.dataset(this, e, {intersect: true});\r\n\t},\r\n\r\n\tgetDatasetMeta: function(datasetIndex) {\r\n\t\tvar me = this;\r\n\t\tvar dataset = me.data.datasets[datasetIndex];\r\n\t\tif (!dataset._meta) {\r\n\t\t\tdataset._meta = {};\r\n\t\t}\r\n\r\n\t\tvar meta = dataset._meta[me.id];\r\n\t\tif (!meta) {\r\n\t\t\tmeta = dataset._meta[me.id] = {\r\n\t\t\t\ttype: null,\r\n\t\t\t\tdata: [],\r\n\t\t\t\tdataset: null,\r\n\t\t\t\tcontroller: null,\r\n\t\t\t\thidden: null,\t\t\t// See isDatasetVisible() comment\r\n\t\t\t\txAxisID: null,\r\n\t\t\t\tyAxisID: null,\r\n\t\t\t\torder: dataset.order || 0,\r\n\t\t\t\tindex: datasetIndex\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn meta;\r\n\t},\r\n\r\n\tgetVisibleDatasetCount: function() {\r\n\t\tvar count = 0;\r\n\t\tfor (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\r\n\t\t\tif (this.isDatasetVisible(i)) {\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn count;\r\n\t},\r\n\r\n\tisDatasetVisible: function(datasetIndex) {\r\n\t\tvar meta = this.getDatasetMeta(datasetIndex);\r\n\r\n\t\t// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\r\n\t\t// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\r\n\t\treturn typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\r\n\t},\r\n\r\n\tgenerateLegend: function() {\r\n\t\treturn this.options.legendCallback(this);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tdestroyDatasetMeta: function(datasetIndex) {\r\n\t\tvar id = this.id;\r\n\t\tvar dataset = this.data.datasets[datasetIndex];\r\n\t\tvar meta = dataset._meta && dataset._meta[id];\r\n\r\n\t\tif (meta) {\r\n\t\t\tmeta.controller.destroy();\r\n\t\t\tdelete dataset._meta[id];\r\n\t\t}\r\n\t},\r\n\r\n\tdestroy: function() {\r\n\t\tvar me = this;\r\n\t\tvar canvas = me.canvas;\r\n\t\tvar i, ilen;\r\n\r\n\t\tme.stop();\r\n\r\n\t\t// dataset controllers need to cleanup associated data\r\n\t\tfor (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\r\n\t\t\tme.destroyDatasetMeta(i);\r\n\t\t}\r\n\r\n\t\tif (canvas) {\r\n\t\t\tme.unbindEvents();\r\n\t\t\thelpers$1.canvas.clear(me);\r\n\t\t\tplatform.releaseContext(me.ctx);\r\n\t\t\tme.canvas = null;\r\n\t\t\tme.ctx = null;\r\n\t\t}\r\n\r\n\t\tcore_plugins.notify(me, 'destroy');\r\n\r\n\t\tdelete Chart.instances[me.id];\r\n\t},\r\n\r\n\ttoBase64Image: function() {\r\n\t\treturn this.canvas.toDataURL.apply(this.canvas, arguments);\r\n\t},\r\n\r\n\tinitToolTip: function() {\r\n\t\tvar me = this;\r\n\t\tme.tooltip = new core_tooltip({\r\n\t\t\t_chart: me,\r\n\t\t\t_chartInstance: me, // deprecated, backward compatibility\r\n\t\t\t_data: me.data,\r\n\t\t\t_options: me.options.tooltips\r\n\t\t}, me);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tbindEvents: function() {\r\n\t\tvar me = this;\r\n\t\tvar listeners = me._listeners = {};\r\n\t\tvar listener = function() {\r\n\t\t\tme.eventHandler.apply(me, arguments);\r\n\t\t};\r\n\r\n\t\thelpers$1.each(me.options.events, function(type) {\r\n\t\t\tplatform.addEventListener(me, type, listener);\r\n\t\t\tlisteners[type] = listener;\r\n\t\t});\r\n\r\n\t\t// Elements used to detect size change should not be injected for non responsive charts.\r\n\t\t// See https://github.com/chartjs/Chart.js/issues/2210\r\n\t\tif (me.options.responsive) {\r\n\t\t\tlistener = function() {\r\n\t\t\t\tme.resize();\r\n\t\t\t};\r\n\r\n\t\t\tplatform.addEventListener(me, 'resize', listener);\r\n\t\t\tlisteners.resize = listener;\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tunbindEvents: function() {\r\n\t\tvar me = this;\r\n\t\tvar listeners = me._listeners;\r\n\t\tif (!listeners) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tdelete me._listeners;\r\n\t\thelpers$1.each(listeners, function(listener, type) {\r\n\t\t\tplatform.removeEventListener(me, type, listener);\r\n\t\t});\r\n\t},\r\n\r\n\tupdateHoverStyle: function(elements, mode, enabled) {\r\n\t\tvar prefix = enabled ? 'set' : 'remove';\r\n\t\tvar element, i, ilen;\r\n\r\n\t\tfor (i = 0, ilen = elements.length; i < ilen; ++i) {\r\n\t\t\telement = elements[i];\r\n\t\t\tif (element) {\r\n\t\t\t\tthis.getDatasetMeta(element._datasetIndex).controller[prefix + 'HoverStyle'](element);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (mode === 'dataset') {\r\n\t\t\tthis.getDatasetMeta(elements[0]._datasetIndex).controller['_' + prefix + 'DatasetHoverStyle']();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\teventHandler: function(e) {\r\n\t\tvar me = this;\r\n\t\tvar tooltip = me.tooltip;\r\n\r\n\t\tif (core_plugins.notify(me, 'beforeEvent', [e]) === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Buffer any update calls so that renders do not occur\r\n\t\tme._bufferedRender = true;\r\n\t\tme._bufferedRequest = null;\r\n\r\n\t\tvar changed = me.handleEvent(e);\r\n\t\t// for smooth tooltip animations issue #4989\r\n\t\t// the tooltip should be the source of change\r\n\t\t// Animation check workaround:\r\n\t\t// tooltip._start will be null when tooltip isn't animating\r\n\t\tif (tooltip) {\r\n\t\t\tchanged = tooltip._start\r\n\t\t\t\t? tooltip.handleEvent(e)\r\n\t\t\t\t: changed | tooltip.handleEvent(e);\r\n\t\t}\r\n\r\n\t\tcore_plugins.notify(me, 'afterEvent', [e]);\r\n\r\n\t\tvar bufferedRequest = me._bufferedRequest;\r\n\t\tif (bufferedRequest) {\r\n\t\t\t// If we have an update that was triggered, we need to do a normal render\r\n\t\t\tme.render(bufferedRequest);\r\n\t\t} else if (changed && !me.animating) {\r\n\t\t\t// If entering, leaving, or changing elements, animate the change via pivot\r\n\t\t\tme.stop();\r\n\r\n\t\t\t// We only need to render at this point. Updating will cause scales to be\r\n\t\t\t// recomputed generating flicker & using more memory than necessary.\r\n\t\t\tme.render({\r\n\t\t\t\tduration: me.options.hover.animationDuration,\r\n\t\t\t\tlazy: true\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tme._bufferedRender = false;\r\n\t\tme._bufferedRequest = null;\r\n\r\n\t\treturn me;\r\n\t},\r\n\r\n\t/**\r\n\t * Handle an event\r\n\t * @private\r\n\t * @param {IEvent} event the event to handle\r\n\t * @return {boolean} true if the chart needs to re-render\r\n\t */\r\n\thandleEvent: function(e) {\r\n\t\tvar me = this;\r\n\t\tvar options = me.options || {};\r\n\t\tvar hoverOptions = options.hover;\r\n\t\tvar changed = false;\r\n\r\n\t\tme.lastActive = me.lastActive || [];\r\n\r\n\t\t// Find Active Elements for hover and tooltips\r\n\t\tif (e.type === 'mouseout') {\r\n\t\t\tme.active = [];\r\n\t\t} else {\r\n\t\t\tme.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);\r\n\t\t}\r\n\r\n\t\t// Invoke onHover hook\r\n\t\t// Need to call with native event here to not break backwards compatibility\r\n\t\thelpers$1.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);\r\n\r\n\t\tif (e.type === 'mouseup' || e.type === 'click') {\r\n\t\t\tif (options.onClick) {\r\n\t\t\t\t// Use e.native here for backwards compatibility\r\n\t\t\t\toptions.onClick.call(me, e.native, me.active);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Remove styling for last active (even if it may still be active)\r\n\t\tif (me.lastActive.length) {\r\n\t\t\tme.updateHoverStyle(me.lastActive, hoverOptions.mode, false);\r\n\t\t}\r\n\r\n\t\t// Built in hover styling\r\n\t\tif (me.active.length && hoverOptions.mode) {\r\n\t\t\tme.updateHoverStyle(me.active, hoverOptions.mode, true);\r\n\t\t}\r\n\r\n\t\tchanged = !helpers$1.arrayEquals(me.active, me.lastActive);\r\n\r\n\t\t// Remember Last Actives\r\n\t\tme.lastActive = me.active;\r\n\r\n\t\treturn changed;\r\n\t}\r\n});\r\n\r\n/**\r\n * NOTE(SB) We actually don't use this container anymore but we need to keep it\r\n * for backward compatibility. Though, it can still be useful for plugins that\r\n * would need to work on multiple charts?!\r\n */\r\nChart.instances = {};\r\n\r\nvar core_controller = Chart;\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n * Provided for backward compatibility, use Chart instead.\r\n * @class Chart.Controller\r\n * @deprecated since version 2.6\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nChart.Controller = Chart;\r\n\r\n/**\r\n * Provided for backward compatibility, not available anymore.\r\n * @namespace Chart\r\n * @deprecated since version 2.8\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nChart.types = {};\r\n\r\n/**\r\n * Provided for backward compatibility, not available anymore.\r\n * @namespace Chart.helpers.configMerge\r\n * @deprecated since version 2.8.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers$1.configMerge = mergeConfig;\r\n\r\n/**\r\n * Provided for backward compatibility, not available anymore.\r\n * @namespace Chart.helpers.scaleMerge\r\n * @deprecated since version 2.8.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers$1.scaleMerge = mergeScaleConfig;\n\nvar core_helpers = function() {\r\n\r\n\t// -- Basic js utility methods\r\n\r\n\thelpers$1.where = function(collection, filterCallback) {\r\n\t\tif (helpers$1.isArray(collection) && Array.prototype.filter) {\r\n\t\t\treturn collection.filter(filterCallback);\r\n\t\t}\r\n\t\tvar filtered = [];\r\n\r\n\t\thelpers$1.each(collection, function(item) {\r\n\t\t\tif (filterCallback(item)) {\r\n\t\t\t\tfiltered.push(item);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn filtered;\r\n\t};\r\n\thelpers$1.findIndex = Array.prototype.findIndex ?\r\n\t\tfunction(array, callback, scope) {\r\n\t\t\treturn array.findIndex(callback, scope);\r\n\t\t} :\r\n\t\tfunction(array, callback, scope) {\r\n\t\t\tscope = scope === undefined ? array : scope;\r\n\t\t\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {\r\n\t\t\t\tif (callback.call(scope, array[i], i, array)) {\r\n\t\t\t\t\treturn i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn -1;\r\n\t\t};\r\n\thelpers$1.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {\r\n\t\t// Default to start of the array\r\n\t\tif (helpers$1.isNullOrUndef(startIndex)) {\r\n\t\t\tstartIndex = -1;\r\n\t\t}\r\n\t\tfor (var i = startIndex + 1; i < arrayToSearch.length; i++) {\r\n\t\t\tvar currentItem = arrayToSearch[i];\r\n\t\t\tif (filterCallback(currentItem)) {\r\n\t\t\t\treturn currentItem;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\thelpers$1.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {\r\n\t\t// Default to end of the array\r\n\t\tif (helpers$1.isNullOrUndef(startIndex)) {\r\n\t\t\tstartIndex = arrayToSearch.length;\r\n\t\t}\r\n\t\tfor (var i = startIndex - 1; i >= 0; i--) {\r\n\t\t\tvar currentItem = arrayToSearch[i];\r\n\t\t\tif (filterCallback(currentItem)) {\r\n\t\t\t\treturn currentItem;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// -- Math methods\r\n\thelpers$1.isNumber = function(n) {\r\n\t\treturn !isNaN(parseFloat(n)) && isFinite(n);\r\n\t};\r\n\thelpers$1.almostEquals = function(x, y, epsilon) {\r\n\t\treturn Math.abs(x - y) < epsilon;\r\n\t};\r\n\thelpers$1.almostWhole = function(x, epsilon) {\r\n\t\tvar rounded = Math.round(x);\r\n\t\treturn ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\r\n\t};\r\n\thelpers$1.max = function(array) {\r\n\t\treturn array.reduce(function(max, value) {\r\n\t\t\tif (!isNaN(value)) {\r\n\t\t\t\treturn Math.max(max, value);\r\n\t\t\t}\r\n\t\t\treturn max;\r\n\t\t}, Number.NEGATIVE_INFINITY);\r\n\t};\r\n\thelpers$1.min = function(array) {\r\n\t\treturn array.reduce(function(min, value) {\r\n\t\t\tif (!isNaN(value)) {\r\n\t\t\t\treturn Math.min(min, value);\r\n\t\t\t}\r\n\t\t\treturn min;\r\n\t\t}, Number.POSITIVE_INFINITY);\r\n\t};\r\n\thelpers$1.sign = Math.sign ?\r\n\t\tfunction(x) {\r\n\t\t\treturn Math.sign(x);\r\n\t\t} :\r\n\t\tfunction(x) {\r\n\t\t\tx = +x; // convert to a number\r\n\t\t\tif (x === 0 || isNaN(x)) {\r\n\t\t\t\treturn x;\r\n\t\t\t}\r\n\t\t\treturn x > 0 ? 1 : -1;\r\n\t\t};\r\n\thelpers$1.toRadians = function(degrees) {\r\n\t\treturn degrees * (Math.PI / 180);\r\n\t};\r\n\thelpers$1.toDegrees = function(radians) {\r\n\t\treturn radians * (180 / Math.PI);\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the number of decimal places\r\n\t * i.e. the number of digits after the decimal point, of the value of this Number.\r\n\t * @param {number} x - A number.\r\n\t * @returns {number} The number of decimal places.\r\n\t * @private\r\n\t */\r\n\thelpers$1._decimalPlaces = function(x) {\r\n\t\tif (!helpers$1.isFinite(x)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar e = 1;\r\n\t\tvar p = 0;\r\n\t\twhile (Math.round(x * e) / e !== x) {\r\n\t\t\te *= 10;\r\n\t\t\tp++;\r\n\t\t}\r\n\t\treturn p;\r\n\t};\r\n\r\n\t// Gets the angle from vertical upright to the point about a centre.\r\n\thelpers$1.getAngleFromPoint = function(centrePoint, anglePoint) {\r\n\t\tvar distanceFromXCenter = anglePoint.x - centrePoint.x;\r\n\t\tvar distanceFromYCenter = anglePoint.y - centrePoint.y;\r\n\t\tvar radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\r\n\r\n\t\tvar angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\r\n\r\n\t\tif (angle < (-0.5 * Math.PI)) {\r\n\t\t\tangle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tangle: angle,\r\n\t\t\tdistance: radialDistanceFromCenter\r\n\t\t};\r\n\t};\r\n\thelpers$1.distanceBetweenPoints = function(pt1, pt2) {\r\n\t\treturn Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\r\n\t};\r\n\r\n\t/**\r\n\t * Provided for backward compatibility, not available anymore\r\n\t * @function Chart.helpers.aliasPixel\r\n\t * @deprecated since version 2.8.0\r\n\t * @todo remove at version 3\r\n\t */\r\n\thelpers$1.aliasPixel = function(pixelWidth) {\r\n\t\treturn (pixelWidth % 2 === 0) ? 0 : 0.5;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the aligned pixel value to avoid anti-aliasing blur\r\n\t * @param {Chart} chart - The chart instance.\r\n\t * @param {number} pixel - A pixel value.\r\n\t * @param {number} width - The width of the element.\r\n\t * @returns {number} The aligned pixel value.\r\n\t * @private\r\n\t */\r\n\thelpers$1._alignPixel = function(chart, pixel, width) {\r\n\t\tvar devicePixelRatio = chart.currentDevicePixelRatio;\r\n\t\tvar halfWidth = width / 2;\r\n\t\treturn Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\r\n\t};\r\n\r\n\thelpers$1.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {\r\n\t\t// Props to Rob Spencer at scaled innovation for his post on splining between points\r\n\t\t// http://scaledinnovation.com/analytics/splines/aboutSplines.html\r\n\r\n\t\t// This function must also respect \"skipped\" points\r\n\r\n\t\tvar previous = firstPoint.skip ? middlePoint : firstPoint;\r\n\t\tvar current = middlePoint;\r\n\t\tvar next = afterPoint.skip ? middlePoint : afterPoint;\r\n\r\n\t\tvar d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));\r\n\t\tvar d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));\r\n\r\n\t\tvar s01 = d01 / (d01 + d12);\r\n\t\tvar s12 = d12 / (d01 + d12);\r\n\r\n\t\t// If all points are the same, s01 & s02 will be inf\r\n\t\ts01 = isNaN(s01) ? 0 : s01;\r\n\t\ts12 = isNaN(s12) ? 0 : s12;\r\n\r\n\t\tvar fa = t * s01; // scaling factor for triangle Ta\r\n\t\tvar fb = t * s12;\r\n\r\n\t\treturn {\r\n\t\t\tprevious: {\r\n\t\t\t\tx: current.x - fa * (next.x - previous.x),\r\n\t\t\t\ty: current.y - fa * (next.y - previous.y)\r\n\t\t\t},\r\n\t\t\tnext: {\r\n\t\t\t\tx: current.x + fb * (next.x - previous.x),\r\n\t\t\t\ty: current.y + fb * (next.y - previous.y)\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n\thelpers$1.EPSILON = Number.EPSILON || 1e-14;\r\n\thelpers$1.splineCurveMonotone = function(points) {\r\n\t\t// This function calculates Bézier control points in a similar way than |splineCurve|,\r\n\t\t// but preserves monotonicity of the provided data and ensures no local extremums are added\r\n\t\t// between the dataset discrete points due to the interpolation.\r\n\t\t// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\r\n\r\n\t\tvar pointsWithTangents = (points || []).map(function(point) {\r\n\t\t\treturn {\r\n\t\t\t\tmodel: point._model,\r\n\t\t\t\tdeltaK: 0,\r\n\t\t\t\tmK: 0\r\n\t\t\t};\r\n\t\t});\r\n\r\n\t\t// Calculate slopes (deltaK) and initialize tangents (mK)\r\n\t\tvar pointsLen = pointsWithTangents.length;\r\n\t\tvar i, pointBefore, pointCurrent, pointAfter;\r\n\t\tfor (i = 0; i < pointsLen; ++i) {\r\n\t\t\tpointCurrent = pointsWithTangents[i];\r\n\t\t\tif (pointCurrent.model.skip) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\r\n\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\r\n\t\t\tif (pointAfter && !pointAfter.model.skip) {\r\n\t\t\t\tvar slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);\r\n\r\n\t\t\t\t// In the case of two points that appear at the same x pixel, slopeDeltaX is 0\r\n\t\t\t\tpointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (!pointBefore || pointBefore.model.skip) {\r\n\t\t\t\tpointCurrent.mK = pointCurrent.deltaK;\r\n\t\t\t} else if (!pointAfter || pointAfter.model.skip) {\r\n\t\t\t\tpointCurrent.mK = pointBefore.deltaK;\r\n\t\t\t} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {\r\n\t\t\t\tpointCurrent.mK = 0;\r\n\t\t\t} else {\r\n\t\t\t\tpointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Adjust tangents to ensure monotonic properties\r\n\t\tvar alphaK, betaK, tauK, squaredMagnitude;\r\n\t\tfor (i = 0; i < pointsLen - 1; ++i) {\r\n\t\t\tpointCurrent = pointsWithTangents[i];\r\n\t\t\tpointAfter = pointsWithTangents[i + 1];\r\n\t\t\tif (pointCurrent.model.skip || pointAfter.model.skip) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {\r\n\t\t\t\tpointCurrent.mK = pointAfter.mK = 0;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\talphaK = pointCurrent.mK / pointCurrent.deltaK;\r\n\t\t\tbetaK = pointAfter.mK / pointCurrent.deltaK;\r\n\t\t\tsquaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\r\n\t\t\tif (squaredMagnitude <= 9) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\ttauK = 3 / Math.sqrt(squaredMagnitude);\r\n\t\t\tpointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;\r\n\t\t\tpointAfter.mK = betaK * tauK * pointCurrent.deltaK;\r\n\t\t}\r\n\r\n\t\t// Compute control points\r\n\t\tvar deltaX;\r\n\t\tfor (i = 0; i < pointsLen; ++i) {\r\n\t\t\tpointCurrent = pointsWithTangents[i];\r\n\t\t\tif (pointCurrent.model.skip) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\r\n\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\r\n\t\t\tif (pointBefore && !pointBefore.model.skip) {\r\n\t\t\t\tdeltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;\r\n\t\t\t\tpointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;\r\n\t\t\t\tpointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;\r\n\t\t\t}\r\n\t\t\tif (pointAfter && !pointAfter.model.skip) {\r\n\t\t\t\tdeltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;\r\n\t\t\t\tpointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;\r\n\t\t\t\tpointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\thelpers$1.nextItem = function(collection, index, loop) {\r\n\t\tif (loop) {\r\n\t\t\treturn index >= collection.length - 1 ? collection[0] : collection[index + 1];\r\n\t\t}\r\n\t\treturn index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];\r\n\t};\r\n\thelpers$1.previousItem = function(collection, index, loop) {\r\n\t\tif (loop) {\r\n\t\t\treturn index <= 0 ? collection[collection.length - 1] : collection[index - 1];\r\n\t\t}\r\n\t\treturn index <= 0 ? collection[0] : collection[index - 1];\r\n\t};\r\n\t// Implementation of the nice number algorithm used in determining where axis labels will go\r\n\thelpers$1.niceNum = function(range, round) {\r\n\t\tvar exponent = Math.floor(helpers$1.log10(range));\r\n\t\tvar fraction = range / Math.pow(10, exponent);\r\n\t\tvar niceFraction;\r\n\r\n\t\tif (round) {\r\n\t\t\tif (fraction < 1.5) {\r\n\t\t\t\tniceFraction = 1;\r\n\t\t\t} else if (fraction < 3) {\r\n\t\t\t\tniceFraction = 2;\r\n\t\t\t} else if (fraction < 7) {\r\n\t\t\t\tniceFraction = 5;\r\n\t\t\t} else {\r\n\t\t\t\tniceFraction = 10;\r\n\t\t\t}\r\n\t\t} else if (fraction <= 1.0) {\r\n\t\t\tniceFraction = 1;\r\n\t\t} else if (fraction <= 2) {\r\n\t\t\tniceFraction = 2;\r\n\t\t} else if (fraction <= 5) {\r\n\t\t\tniceFraction = 5;\r\n\t\t} else {\r\n\t\t\tniceFraction = 10;\r\n\t\t}\r\n\r\n\t\treturn niceFraction * Math.pow(10, exponent);\r\n\t};\r\n\t// Request animation polyfill - https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n\thelpers$1.requestAnimFrame = (function() {\r\n\t\tif (typeof window === 'undefined') {\r\n\t\t\treturn function(callback) {\r\n\t\t\t\tcallback();\r\n\t\t\t};\r\n\t\t}\r\n\t\treturn window.requestAnimationFrame ||\r\n\t\t\twindow.webkitRequestAnimationFrame ||\r\n\t\t\twindow.mozRequestAnimationFrame ||\r\n\t\t\twindow.oRequestAnimationFrame ||\r\n\t\t\twindow.msRequestAnimationFrame ||\r\n\t\t\tfunction(callback) {\r\n\t\t\t\treturn window.setTimeout(callback, 1000 / 60);\r\n\t\t\t};\r\n\t}());\r\n\t// -- DOM methods\r\n\thelpers$1.getRelativePosition = function(evt, chart) {\r\n\t\tvar mouseX, mouseY;\r\n\t\tvar e = evt.originalEvent || evt;\r\n\t\tvar canvas = evt.target || evt.srcElement;\r\n\t\tvar boundingRect = canvas.getBoundingClientRect();\r\n\r\n\t\tvar touches = e.touches;\r\n\t\tif (touches && touches.length > 0) {\r\n\t\t\tmouseX = touches[0].clientX;\r\n\t\t\tmouseY = touches[0].clientY;\r\n\r\n\t\t} else {\r\n\t\t\tmouseX = e.clientX;\r\n\t\t\tmouseY = e.clientY;\r\n\t\t}\r\n\r\n\t\t// Scale mouse coordinates into canvas coordinates\r\n\t\t// by following the pattern laid out by 'jerryj' in the comments of\r\n\t\t// https://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/\r\n\t\tvar paddingLeft = parseFloat(helpers$1.getStyle(canvas, 'padding-left'));\r\n\t\tvar paddingTop = parseFloat(helpers$1.getStyle(canvas, 'padding-top'));\r\n\t\tvar paddingRight = parseFloat(helpers$1.getStyle(canvas, 'padding-right'));\r\n\t\tvar paddingBottom = parseFloat(helpers$1.getStyle(canvas, 'padding-bottom'));\r\n\t\tvar width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;\r\n\t\tvar height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;\r\n\r\n\t\t// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However\r\n\t\t// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here\r\n\t\tmouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);\r\n\t\tmouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);\r\n\r\n\t\treturn {\r\n\t\t\tx: mouseX,\r\n\t\t\ty: mouseY\r\n\t\t};\r\n\r\n\t};\r\n\r\n\t// Private helper function to convert max-width/max-height values that may be percentages into a number\r\n\tfunction parseMaxStyle(styleValue, node, parentProperty) {\r\n\t\tvar valueInPixels;\r\n\t\tif (typeof styleValue === 'string') {\r\n\t\t\tvalueInPixels = parseInt(styleValue, 10);\r\n\r\n\t\t\tif (styleValue.indexOf('%') !== -1) {\r\n\t\t\t\t// percentage * size in dimension\r\n\t\t\t\tvalueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvalueInPixels = styleValue;\r\n\t\t}\r\n\r\n\t\treturn valueInPixels;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns if the given value contains an effective constraint.\r\n\t * @private\r\n\t */\r\n\tfunction isConstrainedValue(value) {\r\n\t\treturn value !== undefined && value !== null && value !== 'none';\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the max width or height of the given DOM node in a cross-browser compatible fashion\r\n\t * @param {HTMLElement} domNode - the node to check the constraint on\r\n\t * @param {string} maxStyle - the style that defines the maximum for the direction we are using ('max-width' / 'max-height')\r\n\t * @param {string} percentageProperty - property of parent to use when calculating width as a percentage\r\n\t * @see {@link https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser}\r\n\t */\r\n\tfunction getConstraintDimension(domNode, maxStyle, percentageProperty) {\r\n\t\tvar view = document.defaultView;\r\n\t\tvar parentNode = helpers$1._getParentNode(domNode);\r\n\t\tvar constrainedNode = view.getComputedStyle(domNode)[maxStyle];\r\n\t\tvar constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\r\n\t\tvar hasCNode = isConstrainedValue(constrainedNode);\r\n\t\tvar hasCContainer = isConstrainedValue(constrainedContainer);\r\n\t\tvar infinity = Number.POSITIVE_INFINITY;\r\n\r\n\t\tif (hasCNode || hasCContainer) {\r\n\t\t\treturn Math.min(\r\n\t\t\t\thasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,\r\n\t\t\t\thasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\r\n\t\t}\r\n\r\n\t\treturn 'none';\r\n\t}\r\n\t// returns Number or undefined if no constraint\r\n\thelpers$1.getConstraintWidth = function(domNode) {\r\n\t\treturn getConstraintDimension(domNode, 'max-width', 'clientWidth');\r\n\t};\r\n\t// returns Number or undefined if no constraint\r\n\thelpers$1.getConstraintHeight = function(domNode) {\r\n\t\treturn getConstraintDimension(domNode, 'max-height', 'clientHeight');\r\n\t};\r\n\t/**\r\n\t * @private\r\n \t */\r\n\thelpers$1._calculatePadding = function(container, padding, parentDimension) {\r\n\t\tpadding = helpers$1.getStyle(container, padding);\r\n\r\n\t\treturn padding.indexOf('%') > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);\r\n\t};\r\n\t/**\r\n\t * @private\r\n\t */\r\n\thelpers$1._getParentNode = function(domNode) {\r\n\t\tvar parent = domNode.parentNode;\r\n\t\tif (parent && parent.toString() === '[object ShadowRoot]') {\r\n\t\t\tparent = parent.host;\r\n\t\t}\r\n\t\treturn parent;\r\n\t};\r\n\thelpers$1.getMaximumWidth = function(domNode) {\r\n\t\tvar container = helpers$1._getParentNode(domNode);\r\n\t\tif (!container) {\r\n\t\t\treturn domNode.clientWidth;\r\n\t\t}\r\n\r\n\t\tvar clientWidth = container.clientWidth;\r\n\t\tvar paddingLeft = helpers$1._calculatePadding(container, 'padding-left', clientWidth);\r\n\t\tvar paddingRight = helpers$1._calculatePadding(container, 'padding-right', clientWidth);\r\n\r\n\t\tvar w = clientWidth - paddingLeft - paddingRight;\r\n\t\tvar cw = helpers$1.getConstraintWidth(domNode);\r\n\t\treturn isNaN(cw) ? w : Math.min(w, cw);\r\n\t};\r\n\thelpers$1.getMaximumHeight = function(domNode) {\r\n\t\tvar container = helpers$1._getParentNode(domNode);\r\n\t\tif (!container) {\r\n\t\t\treturn domNode.clientHeight;\r\n\t\t}\r\n\r\n\t\tvar clientHeight = container.clientHeight;\r\n\t\tvar paddingTop = helpers$1._calculatePadding(container, 'padding-top', clientHeight);\r\n\t\tvar paddingBottom = helpers$1._calculatePadding(container, 'padding-bottom', clientHeight);\r\n\r\n\t\tvar h = clientHeight - paddingTop - paddingBottom;\r\n\t\tvar ch = helpers$1.getConstraintHeight(domNode);\r\n\t\treturn isNaN(ch) ? h : Math.min(h, ch);\r\n\t};\r\n\thelpers$1.getStyle = function(el, property) {\r\n\t\treturn el.currentStyle ?\r\n\t\t\tel.currentStyle[property] :\r\n\t\t\tdocument.defaultView.getComputedStyle(el, null).getPropertyValue(property);\r\n\t};\r\n\thelpers$1.retinaScale = function(chart, forceRatio) {\r\n\t\tvar pixelRatio = chart.currentDevicePixelRatio = forceRatio || (typeof window !== 'undefined' && window.devicePixelRatio) || 1;\r\n\t\tif (pixelRatio === 1) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar canvas = chart.canvas;\r\n\t\tvar height = chart.height;\r\n\t\tvar width = chart.width;\r\n\r\n\t\tcanvas.height = height * pixelRatio;\r\n\t\tcanvas.width = width * pixelRatio;\r\n\t\tchart.ctx.scale(pixelRatio, pixelRatio);\r\n\r\n\t\t// If no style has been set on the canvas, the render size is used as display size,\r\n\t\t// making the chart visually bigger, so let's enforce it to the \"correct\" values.\r\n\t\t// See https://github.com/chartjs/Chart.js/issues/3575\r\n\t\tif (!canvas.style.height && !canvas.style.width) {\r\n\t\t\tcanvas.style.height = height + 'px';\r\n\t\t\tcanvas.style.width = width + 'px';\r\n\t\t}\r\n\t};\r\n\t// -- Canvas methods\r\n\thelpers$1.fontString = function(pixelSize, fontStyle, fontFamily) {\r\n\t\treturn fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\r\n\t};\r\n\thelpers$1.longestText = function(ctx, font, arrayOfThings, cache) {\r\n\t\tcache = cache || {};\r\n\t\tvar data = cache.data = cache.data || {};\r\n\t\tvar gc = cache.garbageCollect = cache.garbageCollect || [];\r\n\r\n\t\tif (cache.font !== font) {\r\n\t\t\tdata = cache.data = {};\r\n\t\t\tgc = cache.garbageCollect = [];\r\n\t\t\tcache.font = font;\r\n\t\t}\r\n\r\n\t\tctx.font = font;\r\n\t\tvar longest = 0;\r\n\t\tvar ilen = arrayOfThings.length;\r\n\t\tvar i, j, jlen, thing, nestedThing;\r\n\t\tfor (i = 0; i < ilen; i++) {\r\n\t\t\tthing = arrayOfThings[i];\r\n\r\n\t\t\t// Undefined strings and arrays should not be measured\r\n\t\t\tif (thing !== undefined && thing !== null && helpers$1.isArray(thing) !== true) {\r\n\t\t\t\tlongest = helpers$1.measureText(ctx, data, gc, longest, thing);\r\n\t\t\t} else if (helpers$1.isArray(thing)) {\r\n\t\t\t\t// if it is an array lets measure each element\r\n\t\t\t\t// to do maybe simplify this function a bit so we can do this more recursively?\r\n\t\t\t\tfor (j = 0, jlen = thing.length; j < jlen; j++) {\r\n\t\t\t\t\tnestedThing = thing[j];\r\n\t\t\t\t\t// Undefined strings and arrays should not be measured\r\n\t\t\t\t\tif (nestedThing !== undefined && nestedThing !== null && !helpers$1.isArray(nestedThing)) {\r\n\t\t\t\t\t\tlongest = helpers$1.measureText(ctx, data, gc, longest, nestedThing);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar gcLen = gc.length / 2;\r\n\t\tif (gcLen > arrayOfThings.length) {\r\n\t\t\tfor (i = 0; i < gcLen; i++) {\r\n\t\t\t\tdelete data[gc[i]];\r\n\t\t\t}\r\n\t\t\tgc.splice(0, gcLen);\r\n\t\t}\r\n\t\treturn longest;\r\n\t};\r\n\thelpers$1.measureText = function(ctx, data, gc, longest, string) {\r\n\t\tvar textWidth = data[string];\r\n\t\tif (!textWidth) {\r\n\t\t\ttextWidth = data[string] = ctx.measureText(string).width;\r\n\t\t\tgc.push(string);\r\n\t\t}\r\n\t\tif (textWidth > longest) {\r\n\t\t\tlongest = textWidth;\r\n\t\t}\r\n\t\treturn longest;\r\n\t};\r\n\r\n\t/**\r\n\t * @deprecated\r\n\t */\r\n\thelpers$1.numberOfLabelLines = function(arrayOfThings) {\r\n\t\tvar numberOfLines = 1;\r\n\t\thelpers$1.each(arrayOfThings, function(thing) {\r\n\t\t\tif (helpers$1.isArray(thing)) {\r\n\t\t\t\tif (thing.length > numberOfLines) {\r\n\t\t\t\t\tnumberOfLines = thing.length;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn numberOfLines;\r\n\t};\r\n\r\n\thelpers$1.color = !chartjsColor ?\r\n\t\tfunction(value) {\r\n\t\t\tconsole.error('Color.js not found!');\r\n\t\t\treturn value;\r\n\t\t} :\r\n\t\tfunction(value) {\r\n\t\t\t/* global CanvasGradient */\r\n\t\t\tif (value instanceof CanvasGradient) {\r\n\t\t\t\tvalue = core_defaults.global.defaultColor;\r\n\t\t\t}\r\n\r\n\t\t\treturn chartjsColor(value);\r\n\t\t};\r\n\r\n\thelpers$1.getHoverColor = function(colorValue) {\r\n\t\t/* global CanvasPattern */\r\n\t\treturn (colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient) ?\r\n\t\t\tcolorValue :\r\n\t\t\thelpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();\r\n\t};\r\n};\n\nfunction abstract() {\r\n\tthrow new Error(\r\n\t\t'This method is not implemented: either no adapter can ' +\r\n\t\t'be found or an incomplete integration was provided.'\r\n\t);\r\n}\r\n\r\n/**\r\n * Date adapter (current used by the time scale)\r\n * @namespace Chart._adapters._date\r\n * @memberof Chart._adapters\r\n * @private\r\n */\r\n\r\n/**\r\n * Currently supported unit string values.\r\n * @typedef {('millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year')}\r\n * @memberof Chart._adapters._date\r\n * @name Unit\r\n */\r\n\r\n/**\r\n * @class\r\n */\r\nfunction DateAdapter(options) {\r\n\tthis.options = options || {};\r\n}\r\n\r\nhelpers$1.extend(DateAdapter.prototype, /** @lends DateAdapter */ {\r\n\t/**\r\n\t * Returns a map of time formats for the supported formatting units defined\r\n\t * in Unit as well as 'datetime' representing a detailed date/time string.\r\n\t * @returns {{string: string}}\r\n\t */\r\n\tformats: abstract,\r\n\r\n\t/**\r\n\t * Parses the given `value` and return the associated timestamp.\r\n\t * @param {any} value - the value to parse (usually comes from the data)\r\n\t * @param {string} [format] - the expected data format\r\n\t * @returns {(number|null)}\r\n\t * @function\r\n\t */\r\n\tparse: abstract,\r\n\r\n\t/**\r\n\t * Returns the formatted date in the specified `format` for a given `timestamp`.\r\n\t * @param {number} timestamp - the timestamp to format\r\n\t * @param {string} format - the date/time token\r\n\t * @return {string}\r\n\t * @function\r\n\t */\r\n\tformat: abstract,\r\n\r\n\t/**\r\n\t * Adds the specified `amount` of `unit` to the given `timestamp`.\r\n\t * @param {number} timestamp - the input timestamp\r\n\t * @param {number} amount - the amount to add\r\n\t * @param {Unit} unit - the unit as string\r\n\t * @return {number}\r\n\t * @function\r\n\t */\r\n\tadd: abstract,\r\n\r\n\t/**\r\n\t * Returns the number of `unit` between the given timestamps.\r\n\t * @param {number} max - the input timestamp (reference)\r\n\t * @param {number} min - the timestamp to substract\r\n\t * @param {Unit} unit - the unit as string\r\n\t * @return {number}\r\n\t * @function\r\n\t */\r\n\tdiff: abstract,\r\n\r\n\t/**\r\n\t * Returns start of `unit` for the given `timestamp`.\r\n\t * @param {number} timestamp - the input timestamp\r\n\t * @param {Unit} unit - the unit as string\r\n\t * @param {number} [weekday] - the ISO day of the week with 1 being Monday\r\n\t * and 7 being Sunday (only needed if param *unit* is `isoWeek`).\r\n\t * @function\r\n\t */\r\n\tstartOf: abstract,\r\n\r\n\t/**\r\n\t * Returns end of `unit` for the given `timestamp`.\r\n\t * @param {number} timestamp - the input timestamp\r\n\t * @param {Unit} unit - the unit as string\r\n\t * @function\r\n\t */\r\n\tendOf: abstract,\r\n\r\n\t// DEPRECATIONS\r\n\r\n\t/**\r\n\t * Provided for backward compatibility for scale.getValueForPixel(),\r\n\t * this method should be overridden only by the moment adapter.\r\n\t * @deprecated since version 2.8.0\r\n\t * @todo remove at version 3\r\n\t * @private\r\n\t */\r\n\t_create: function(value) {\r\n\t\treturn value;\r\n\t}\r\n});\r\n\r\nDateAdapter.override = function(members) {\r\n\thelpers$1.extend(DateAdapter.prototype, members);\r\n};\r\n\r\nvar _date = DateAdapter;\n\nvar core_adapters = {\n\t_date: _date\n};\n\n/**\r\n * Namespace to hold static tick generation functions\r\n * @namespace Chart.Ticks\r\n */\r\nvar core_ticks = {\r\n\t/**\r\n\t * Namespace to hold formatters for different types of ticks\r\n\t * @namespace Chart.Ticks.formatters\r\n\t */\r\n\tformatters: {\r\n\t\t/**\r\n\t\t * Formatter for value labels\r\n\t\t * @method Chart.Ticks.formatters.values\r\n\t\t * @param value the value to display\r\n\t\t * @return {string|string[]} the label to display\r\n\t\t */\r\n\t\tvalues: function(value) {\r\n\t\t\treturn helpers$1.isArray(value) ? value : '' + value;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Formatter for linear numeric ticks\r\n\t\t * @method Chart.Ticks.formatters.linear\r\n\t\t * @param tickValue {number} the value to be formatted\r\n\t\t * @param index {number} the position of the tickValue parameter in the ticks array\r\n\t\t * @param ticks {number[]} the list of ticks being converted\r\n\t\t * @return {string} string representation of the tickValue parameter\r\n\t\t */\r\n\t\tlinear: function(tickValue, index, ticks) {\r\n\t\t\t// If we have lots of ticks, don't use the ones\r\n\t\t\tvar delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\r\n\r\n\t\t\t// If we have a number like 2.5 as the delta, figure out how many decimal places we need\r\n\t\t\tif (Math.abs(delta) > 1) {\r\n\t\t\t\tif (tickValue !== Math.floor(tickValue)) {\r\n\t\t\t\t\t// not an integer\r\n\t\t\t\t\tdelta = tickValue - Math.floor(tickValue);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar logDelta = helpers$1.log10(Math.abs(delta));\r\n\t\t\tvar tickString = '';\r\n\r\n\t\t\tif (tickValue !== 0) {\r\n\t\t\t\tvar maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));\r\n\t\t\t\tif (maxTick < 1e-4) { // all ticks are small numbers; use scientific notation\r\n\t\t\t\t\tvar logTick = helpers$1.log10(Math.abs(tickValue));\r\n\t\t\t\t\tvar numExponential = Math.floor(logTick) - Math.floor(logDelta);\r\n\t\t\t\t\tnumExponential = Math.max(Math.min(numExponential, 20), 0);\r\n\t\t\t\t\ttickString = tickValue.toExponential(numExponential);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar numDecimal = -1 * Math.floor(logDelta);\r\n\t\t\t\t\tnumDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\r\n\t\t\t\t\ttickString = tickValue.toFixed(numDecimal);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\ttickString = '0'; // never show decimal places for 0\r\n\t\t\t}\r\n\r\n\t\t\treturn tickString;\r\n\t\t},\r\n\r\n\t\tlogarithmic: function(tickValue, index, ticks) {\r\n\t\t\tvar remain = tickValue / (Math.pow(10, Math.floor(helpers$1.log10(tickValue))));\r\n\r\n\t\t\tif (tickValue === 0) {\r\n\t\t\t\treturn '0';\r\n\t\t\t} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\r\n\t\t\t\treturn tickValue.toExponential();\r\n\t\t\t}\r\n\t\t\treturn '';\r\n\t\t}\r\n\t}\r\n};\n\nvar isArray = helpers$1.isArray;\r\nvar isNullOrUndef = helpers$1.isNullOrUndef;\r\nvar valueOrDefault$a = helpers$1.valueOrDefault;\r\nvar valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;\r\n\r\ncore_defaults._set('scale', {\r\n\tdisplay: true,\r\n\tposition: 'left',\r\n\toffset: false,\r\n\r\n\t// grid line settings\r\n\tgridLines: {\r\n\t\tdisplay: true,\r\n\t\tcolor: 'rgba(0,0,0,0.1)',\r\n\t\tlineWidth: 1,\r\n\t\tdrawBorder: true,\r\n\t\tdrawOnChartArea: true,\r\n\t\tdrawTicks: true,\r\n\t\ttickMarkLength: 10,\r\n\t\tzeroLineWidth: 1,\r\n\t\tzeroLineColor: 'rgba(0,0,0,0.25)',\r\n\t\tzeroLineBorderDash: [],\r\n\t\tzeroLineBorderDashOffset: 0.0,\r\n\t\toffsetGridLines: false,\r\n\t\tborderDash: [],\r\n\t\tborderDashOffset: 0.0\r\n\t},\r\n\r\n\t// scale label\r\n\tscaleLabel: {\r\n\t\t// display property\r\n\t\tdisplay: false,\r\n\r\n\t\t// actual label\r\n\t\tlabelString: '',\r\n\r\n\t\t// top/bottom padding\r\n\t\tpadding: {\r\n\t\t\ttop: 4,\r\n\t\t\tbottom: 4\r\n\t\t}\r\n\t},\r\n\r\n\t// label settings\r\n\tticks: {\r\n\t\tbeginAtZero: false,\r\n\t\tminRotation: 0,\r\n\t\tmaxRotation: 50,\r\n\t\tmirror: false,\r\n\t\tpadding: 0,\r\n\t\treverse: false,\r\n\t\tdisplay: true,\r\n\t\tautoSkip: true,\r\n\t\tautoSkipPadding: 0,\r\n\t\tlabelOffset: 0,\r\n\t\t// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\r\n\t\tcallback: core_ticks.formatters.values,\r\n\t\tminor: {},\r\n\t\tmajor: {}\r\n\t}\r\n});\r\n\r\n/** Returns a new array containing numItems from arr */\r\nfunction sample(arr, numItems) {\r\n\tvar result = [];\r\n\tvar increment = arr.length / numItems;\r\n\tvar i = 0;\r\n\tvar len = arr.length;\r\n\r\n\tfor (; i < len; i += increment) {\r\n\t\tresult.push(arr[Math.floor(i)]);\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\r\n\tvar length = scale.getTicks().length;\r\n\tvar validIndex = Math.min(index, length - 1);\r\n\tvar lineValue = scale.getPixelForTick(validIndex);\r\n\tvar start = scale._startPixel;\r\n\tvar end = scale._endPixel;\r\n\tvar epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.\r\n\tvar offset;\r\n\r\n\tif (offsetGridLines) {\r\n\t\tif (length === 1) {\r\n\t\t\toffset = Math.max(lineValue - start, end - lineValue);\r\n\t\t} else if (index === 0) {\r\n\t\t\toffset = (scale.getPixelForTick(1) - lineValue) / 2;\r\n\t\t} else {\r\n\t\t\toffset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\r\n\t\t}\r\n\t\tlineValue += validIndex < index ? offset : -offset;\r\n\r\n\t\t// Return undefined if the pixel is out of the range\r\n\t\tif (lineValue < start - epsilon || lineValue > end + epsilon) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\treturn lineValue;\r\n}\r\n\r\nfunction garbageCollect(caches, length) {\r\n\thelpers$1.each(caches, function(cache) {\r\n\t\tvar gc = cache.gc;\r\n\t\tvar gcLen = gc.length / 2;\r\n\t\tvar i;\r\n\t\tif (gcLen > length) {\r\n\t\t\tfor (i = 0; i < gcLen; ++i) {\r\n\t\t\t\tdelete cache.data[gc[i]];\r\n\t\t\t}\r\n\t\t\tgc.splice(0, gcLen);\r\n\t\t}\r\n\t});\r\n}\r\n\r\n/**\r\n * Returns {width, height, offset} objects for the first, last, widest, highest tick\r\n * labels where offset indicates the anchor point offset from the top in pixels.\r\n */\r\nfunction computeLabelSizes(ctx, tickFonts, ticks, caches) {\r\n\tvar length = ticks.length;\r\n\tvar widths = [];\r\n\tvar heights = [];\r\n\tvar offsets = [];\r\n\tvar widestLabelSize = 0;\r\n\tvar highestLabelSize = 0;\r\n\tvar i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel, widest, highest;\r\n\r\n\tfor (i = 0; i < length; ++i) {\r\n\t\tlabel = ticks[i].label;\r\n\t\ttickFont = ticks[i].major ? tickFonts.major : tickFonts.minor;\r\n\t\tctx.font = fontString = tickFont.string;\r\n\t\tcache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\r\n\t\tlineHeight = tickFont.lineHeight;\r\n\t\twidth = height = 0;\r\n\t\t// Undefined labels and arrays should not be measured\r\n\t\tif (!isNullOrUndef(label) && !isArray(label)) {\r\n\t\t\twidth = helpers$1.measureText(ctx, cache.data, cache.gc, width, label);\r\n\t\t\theight = lineHeight;\r\n\t\t} else if (isArray(label)) {\r\n\t\t\t// if it is an array let's measure each element\r\n\t\t\tfor (j = 0, jlen = label.length; j < jlen; ++j) {\r\n\t\t\t\tnestedLabel = label[j];\r\n\t\t\t\t// Undefined labels and arrays should not be measured\r\n\t\t\t\tif (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\r\n\t\t\t\t\twidth = helpers$1.measureText(ctx, cache.data, cache.gc, width, nestedLabel);\r\n\t\t\t\t\theight += lineHeight;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\twidths.push(width);\r\n\t\theights.push(height);\r\n\t\toffsets.push(lineHeight / 2);\r\n\t\twidestLabelSize = Math.max(width, widestLabelSize);\r\n\t\thighestLabelSize = Math.max(height, highestLabelSize);\r\n\t}\r\n\tgarbageCollect(caches, length);\r\n\r\n\twidest = widths.indexOf(widestLabelSize);\r\n\thighest = heights.indexOf(highestLabelSize);\r\n\r\n\tfunction valueAt(idx) {\r\n\t\treturn {\r\n\t\t\twidth: widths[idx] || 0,\r\n\t\t\theight: heights[idx] || 0,\r\n\t\t\toffset: offsets[idx] || 0\r\n\t\t};\r\n\t}\r\n\r\n\treturn {\r\n\t\tfirst: valueAt(0),\r\n\t\tlast: valueAt(length - 1),\r\n\t\twidest: valueAt(widest),\r\n\t\thighest: valueAt(highest)\r\n\t};\r\n}\r\n\r\nfunction getTickMarkLength(options) {\r\n\treturn options.drawTicks ? options.tickMarkLength : 0;\r\n}\r\n\r\nfunction getScaleLabelHeight(options) {\r\n\tvar font, padding;\r\n\r\n\tif (!options.display) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tfont = helpers$1.options._parseFont(options);\r\n\tpadding = helpers$1.options.toPadding(options.padding);\r\n\r\n\treturn font.lineHeight + padding.height;\r\n}\r\n\r\nfunction parseFontOptions(options, nestedOpts) {\r\n\treturn helpers$1.extend(helpers$1.options._parseFont({\r\n\t\tfontFamily: valueOrDefault$a(nestedOpts.fontFamily, options.fontFamily),\r\n\t\tfontSize: valueOrDefault$a(nestedOpts.fontSize, options.fontSize),\r\n\t\tfontStyle: valueOrDefault$a(nestedOpts.fontStyle, options.fontStyle),\r\n\t\tlineHeight: valueOrDefault$a(nestedOpts.lineHeight, options.lineHeight)\r\n\t}), {\r\n\t\tcolor: helpers$1.options.resolve([nestedOpts.fontColor, options.fontColor, core_defaults.global.defaultFontColor])\r\n\t});\r\n}\r\n\r\nfunction parseTickFontOptions(options) {\r\n\tvar minor = parseFontOptions(options, options.minor);\r\n\tvar major = options.major.enabled ? parseFontOptions(options, options.major) : minor;\r\n\r\n\treturn {minor: minor, major: major};\r\n}\r\n\r\nfunction nonSkipped(ticksToFilter) {\r\n\tvar filtered = [];\r\n\tvar item, index, len;\r\n\tfor (index = 0, len = ticksToFilter.length; index < len; ++index) {\r\n\t\titem = ticksToFilter[index];\r\n\t\tif (typeof item._index !== 'undefined') {\r\n\t\t\tfiltered.push(item);\r\n\t\t}\r\n\t}\r\n\treturn filtered;\r\n}\r\n\r\nfunction getEvenSpacing(arr) {\r\n\tvar len = arr.length;\r\n\tvar i, diff;\r\n\r\n\tif (len < 2) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfor (diff = arr[0], i = 1; i < len; ++i) {\r\n\t\tif (arr[i] - arr[i - 1] !== diff) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\treturn diff;\r\n}\r\n\r\nfunction calculateSpacing(majorIndices, ticks, axisLength, ticksLimit) {\r\n\tvar evenMajorSpacing = getEvenSpacing(majorIndices);\r\n\tvar spacing = (ticks.length - 1) / ticksLimit;\r\n\tvar factors, factor, i, ilen;\r\n\r\n\t// If the major ticks are evenly spaced apart, place the minor ticks\r\n\t// so that they divide the major ticks into even chunks\r\n\tif (!evenMajorSpacing) {\r\n\t\treturn Math.max(spacing, 1);\r\n\t}\r\n\r\n\tfactors = helpers$1.math._factorize(evenMajorSpacing);\r\n\tfor (i = 0, ilen = factors.length - 1; i < ilen; i++) {\r\n\t\tfactor = factors[i];\r\n\t\tif (factor > spacing) {\r\n\t\t\treturn factor;\r\n\t\t}\r\n\t}\r\n\treturn Math.max(spacing, 1);\r\n}\r\n\r\nfunction getMajorIndices(ticks) {\r\n\tvar result = [];\r\n\tvar i, ilen;\r\n\tfor (i = 0, ilen = ticks.length; i < ilen; i++) {\r\n\t\tif (ticks[i].major) {\r\n\t\t\tresult.push(i);\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nfunction skipMajors(ticks, majorIndices, spacing) {\r\n\tvar count = 0;\r\n\tvar next = majorIndices[0];\r\n\tvar i, tick;\r\n\r\n\tspacing = Math.ceil(spacing);\r\n\tfor (i = 0; i < ticks.length; i++) {\r\n\t\ttick = ticks[i];\r\n\t\tif (i === next) {\r\n\t\t\ttick._index = i;\r\n\t\t\tcount++;\r\n\t\t\tnext = majorIndices[count * spacing];\r\n\t\t} else {\r\n\t\t\tdelete tick.label;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction skip(ticks, spacing, majorStart, majorEnd) {\r\n\tvar start = valueOrDefault$a(majorStart, 0);\r\n\tvar end = Math.min(valueOrDefault$a(majorEnd, ticks.length), ticks.length);\r\n\tvar count = 0;\r\n\tvar length, i, tick, next;\r\n\r\n\tspacing = Math.ceil(spacing);\r\n\tif (majorEnd) {\r\n\t\tlength = majorEnd - majorStart;\r\n\t\tspacing = length / Math.floor(length / spacing);\r\n\t}\r\n\r\n\tnext = start;\r\n\r\n\twhile (next < 0) {\r\n\t\tcount++;\r\n\t\tnext = Math.round(start + count * spacing);\r\n\t}\r\n\r\n\tfor (i = Math.max(start, 0); i < end; i++) {\r\n\t\ttick = ticks[i];\r\n\t\tif (i === next) {\r\n\t\t\ttick._index = i;\r\n\t\t\tcount++;\r\n\t\t\tnext = Math.round(start + count * spacing);\r\n\t\t} else {\r\n\t\t\tdelete tick.label;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvar Scale = core_element.extend({\r\n\r\n\tzeroLineIndex: 0,\r\n\r\n\t/**\r\n\t * Get the padding needed for the scale\r\n\t * @method getPadding\r\n\t * @private\r\n\t * @returns {Padding} the necessary padding\r\n\t */\r\n\tgetPadding: function() {\r\n\t\tvar me = this;\r\n\t\treturn {\r\n\t\t\tleft: me.paddingLeft || 0,\r\n\t\t\ttop: me.paddingTop || 0,\r\n\t\t\tright: me.paddingRight || 0,\r\n\t\t\tbottom: me.paddingBottom || 0\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Returns the scale tick objects ({label, major})\r\n\t * @since 2.7\r\n\t */\r\n\tgetTicks: function() {\r\n\t\treturn this._ticks;\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\t_getLabels: function() {\r\n\t\tvar data = this.chart.data;\r\n\t\treturn this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\r\n\t},\r\n\r\n\t// These methods are ordered by lifecyle. Utilities then follow.\r\n\t// Any function defined here is inherited by all scale types.\r\n\t// Any function can be extended by the scale type\r\n\r\n\t/**\r\n\t * Provided for backward compatibility, not available anymore\r\n\t * @function Chart.Scale.mergeTicksOptions\r\n\t * @deprecated since version 2.8.0\r\n\t * @todo remove at version 3\r\n\t */\r\n\tmergeTicksOptions: function() {\r\n\t\t// noop\r\n\t},\r\n\r\n\tbeforeUpdate: function() {\r\n\t\thelpers$1.callback(this.options.beforeUpdate, [this]);\r\n\t},\r\n\r\n\t/**\r\n\t * @param {number} maxWidth - the max width in pixels\r\n\t * @param {number} maxHeight - the max height in pixels\r\n\t * @param {object} margins - the space between the edge of the other scales and edge of the chart\r\n\t *   This space comes from two sources:\r\n\t *     - padding - space that's required to show the labels at the edges of the scale\r\n\t *     - thickness of scales or legends in another orientation\r\n\t */\r\n\tupdate: function(maxWidth, maxHeight, margins) {\r\n\t\tvar me = this;\r\n\t\tvar tickOpts = me.options.ticks;\r\n\t\tvar sampleSize = tickOpts.sampleSize;\r\n\t\tvar i, ilen, labels, ticks, samplingEnabled;\r\n\r\n\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\r\n\t\tme.beforeUpdate();\r\n\r\n\t\t// Absorb the master measurements\r\n\t\tme.maxWidth = maxWidth;\r\n\t\tme.maxHeight = maxHeight;\r\n\t\tme.margins = helpers$1.extend({\r\n\t\t\tleft: 0,\r\n\t\t\tright: 0,\r\n\t\t\ttop: 0,\r\n\t\t\tbottom: 0\r\n\t\t}, margins);\r\n\r\n\t\tme._ticks = null;\r\n\t\tme.ticks = null;\r\n\t\tme._labelSizes = null;\r\n\t\tme._maxLabelLines = 0;\r\n\t\tme.longestLabelWidth = 0;\r\n\t\tme.longestTextCache = me.longestTextCache || {};\r\n\t\tme._gridLineItems = null;\r\n\t\tme._labelItems = null;\r\n\r\n\t\t// Dimensions\r\n\t\tme.beforeSetDimensions();\r\n\t\tme.setDimensions();\r\n\t\tme.afterSetDimensions();\r\n\r\n\t\t// Data min/max\r\n\t\tme.beforeDataLimits();\r\n\t\tme.determineDataLimits();\r\n\t\tme.afterDataLimits();\r\n\r\n\t\t// Ticks - `this.ticks` is now DEPRECATED!\r\n\t\t// Internal ticks are now stored as objects in the PRIVATE `this._ticks` member\r\n\t\t// and must not be accessed directly from outside this class. `this.ticks` being\r\n\t\t// around for long time and not marked as private, we can't change its structure\r\n\t\t// without unexpected breaking changes. If you need to access the scale ticks,\r\n\t\t// use scale.getTicks() instead.\r\n\r\n\t\tme.beforeBuildTicks();\r\n\r\n\t\t// New implementations should return an array of objects but for BACKWARD COMPAT,\r\n\t\t// we still support no return (`this.ticks` internally set by calling this method).\r\n\t\tticks = me.buildTicks() || [];\r\n\r\n\t\t// Allow modification of ticks in callback.\r\n\t\tticks = me.afterBuildTicks(ticks) || ticks;\r\n\r\n\t\t// Ensure ticks contains ticks in new tick format\r\n\t\tif ((!ticks || !ticks.length) && me.ticks) {\r\n\t\t\tticks = [];\r\n\t\t\tfor (i = 0, ilen = me.ticks.length; i < ilen; ++i) {\r\n\t\t\t\tticks.push({\r\n\t\t\t\t\tvalue: me.ticks[i],\r\n\t\t\t\t\tmajor: false\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tme._ticks = ticks;\r\n\r\n\t\t// Compute tick rotation and fit using a sampled subset of labels\r\n\t\t// We generally don't need to compute the size of every single label for determining scale size\r\n\t\tsamplingEnabled = sampleSize < ticks.length;\r\n\t\tlabels = me._convertTicksToLabels(samplingEnabled ? sample(ticks, sampleSize) : ticks);\r\n\r\n\t\t// _configure is called twice, once here, once from core.controller.updateLayout.\r\n\t\t// Here we haven't been positioned yet, but dimensions are correct.\r\n\t\t// Variables set in _configure are needed for calculateTickRotation, and\r\n\t\t// it's ok that coordinates are not correct there, only dimensions matter.\r\n\t\tme._configure();\r\n\r\n\t\t// Tick Rotation\r\n\t\tme.beforeCalculateTickRotation();\r\n\t\tme.calculateTickRotation();\r\n\t\tme.afterCalculateTickRotation();\r\n\r\n\t\tme.beforeFit();\r\n\t\tme.fit();\r\n\t\tme.afterFit();\r\n\r\n\t\t// Auto-skip\r\n\t\tme._ticksToDraw = tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto') ? me._autoSkip(ticks) : ticks;\r\n\r\n\t\tif (samplingEnabled) {\r\n\t\t\t// Generate labels using all non-skipped ticks\r\n\t\t\tlabels = me._convertTicksToLabels(me._ticksToDraw);\r\n\t\t}\r\n\r\n\t\tme.ticks = labels;   // BACKWARD COMPATIBILITY\r\n\r\n\t\t// IMPORTANT: after this point, we consider that `this.ticks` will NEVER change!\r\n\r\n\t\tme.afterUpdate();\r\n\r\n\t\t// TODO(v3): remove minSize as a public property and return value from all layout boxes. It is unused\r\n\t\t// make maxWidth and maxHeight private\r\n\t\treturn me.minSize;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_configure: function() {\r\n\t\tvar me = this;\r\n\t\tvar reversePixels = me.options.ticks.reverse;\r\n\t\tvar startPixel, endPixel;\r\n\r\n\t\tif (me.isHorizontal()) {\r\n\t\t\tstartPixel = me.left;\r\n\t\t\tendPixel = me.right;\r\n\t\t} else {\r\n\t\t\tstartPixel = me.top;\r\n\t\t\tendPixel = me.bottom;\r\n\t\t\t// by default vertical scales are from bottom to top, so pixels are reversed\r\n\t\t\treversePixels = !reversePixels;\r\n\t\t}\r\n\t\tme._startPixel = startPixel;\r\n\t\tme._endPixel = endPixel;\r\n\t\tme._reversePixels = reversePixels;\r\n\t\tme._length = endPixel - startPixel;\r\n\t},\r\n\r\n\tafterUpdate: function() {\r\n\t\thelpers$1.callback(this.options.afterUpdate, [this]);\r\n\t},\r\n\r\n\t//\r\n\r\n\tbeforeSetDimensions: function() {\r\n\t\thelpers$1.callback(this.options.beforeSetDimensions, [this]);\r\n\t},\r\n\tsetDimensions: function() {\r\n\t\tvar me = this;\r\n\t\t// Set the unconstrained dimension before label rotation\r\n\t\tif (me.isHorizontal()) {\r\n\t\t\t// Reset position before calculating rotation\r\n\t\t\tme.width = me.maxWidth;\r\n\t\t\tme.left = 0;\r\n\t\t\tme.right = me.width;\r\n\t\t} else {\r\n\t\t\tme.height = me.maxHeight;\r\n\r\n\t\t\t// Reset position before calculating rotation\r\n\t\t\tme.top = 0;\r\n\t\t\tme.bottom = me.height;\r\n\t\t}\r\n\r\n\t\t// Reset padding\r\n\t\tme.paddingLeft = 0;\r\n\t\tme.paddingTop = 0;\r\n\t\tme.paddingRight = 0;\r\n\t\tme.paddingBottom = 0;\r\n\t},\r\n\tafterSetDimensions: function() {\r\n\t\thelpers$1.callback(this.options.afterSetDimensions, [this]);\r\n\t},\r\n\r\n\t// Data limits\r\n\tbeforeDataLimits: function() {\r\n\t\thelpers$1.callback(this.options.beforeDataLimits, [this]);\r\n\t},\r\n\tdetermineDataLimits: helpers$1.noop,\r\n\tafterDataLimits: function() {\r\n\t\thelpers$1.callback(this.options.afterDataLimits, [this]);\r\n\t},\r\n\r\n\t//\r\n\tbeforeBuildTicks: function() {\r\n\t\thelpers$1.callback(this.options.beforeBuildTicks, [this]);\r\n\t},\r\n\tbuildTicks: helpers$1.noop,\r\n\tafterBuildTicks: function(ticks) {\r\n\t\tvar me = this;\r\n\t\t// ticks is empty for old axis implementations here\r\n\t\tif (isArray(ticks) && ticks.length) {\r\n\t\t\treturn helpers$1.callback(me.options.afterBuildTicks, [me, ticks]);\r\n\t\t}\r\n\t\t// Support old implementations (that modified `this.ticks` directly in buildTicks)\r\n\t\tme.ticks = helpers$1.callback(me.options.afterBuildTicks, [me, me.ticks]) || me.ticks;\r\n\t\treturn ticks;\r\n\t},\r\n\r\n\tbeforeTickToLabelConversion: function() {\r\n\t\thelpers$1.callback(this.options.beforeTickToLabelConversion, [this]);\r\n\t},\r\n\tconvertTicksToLabels: function() {\r\n\t\tvar me = this;\r\n\t\t// Convert ticks to strings\r\n\t\tvar tickOpts = me.options.ticks;\r\n\t\tme.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);\r\n\t},\r\n\tafterTickToLabelConversion: function() {\r\n\t\thelpers$1.callback(this.options.afterTickToLabelConversion, [this]);\r\n\t},\r\n\r\n\t//\r\n\r\n\tbeforeCalculateTickRotation: function() {\r\n\t\thelpers$1.callback(this.options.beforeCalculateTickRotation, [this]);\r\n\t},\r\n\tcalculateTickRotation: function() {\r\n\t\tvar me = this;\r\n\t\tvar options = me.options;\r\n\t\tvar tickOpts = options.ticks;\r\n\t\tvar numTicks = me.getTicks().length;\r\n\t\tvar minRotation = tickOpts.minRotation || 0;\r\n\t\tvar maxRotation = tickOpts.maxRotation;\r\n\t\tvar labelRotation = minRotation;\r\n\t\tvar labelSizes, maxLabelWidth, maxLabelHeight, maxWidth, tickWidth, maxHeight, maxLabelDiagonal;\r\n\r\n\t\tif (!me._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me.isHorizontal()) {\r\n\t\t\tme.labelRotation = minRotation;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlabelSizes = me._getLabelSizes();\r\n\t\tmaxLabelWidth = labelSizes.widest.width;\r\n\t\tmaxLabelHeight = labelSizes.highest.height - labelSizes.highest.offset;\r\n\r\n\t\t// Estimate the width of each grid based on the canvas width, the maximum\r\n\t\t// label width and the number of tick intervals\r\n\t\tmaxWidth = Math.min(me.maxWidth, me.chart.width - maxLabelWidth);\r\n\t\ttickWidth = options.offset ? me.maxWidth / numTicks : maxWidth / (numTicks - 1);\r\n\r\n\t\t// Allow 3 pixels x2 padding either side for label readability\r\n\t\tif (maxLabelWidth + 6 > tickWidth) {\r\n\t\t\ttickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\r\n\t\t\tmaxHeight = me.maxHeight - getTickMarkLength(options.gridLines)\r\n\t\t\t\t- tickOpts.padding - getScaleLabelHeight(options.scaleLabel);\r\n\t\t\tmaxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\r\n\t\t\tlabelRotation = helpers$1.toDegrees(Math.min(\r\n\t\t\t\tMath.asin(Math.min((labelSizes.highest.height + 6) / tickWidth, 1)),\r\n\t\t\t\tMath.asin(Math.min(maxHeight / maxLabelDiagonal, 1)) - Math.asin(maxLabelHeight / maxLabelDiagonal)\r\n\t\t\t));\r\n\t\t\tlabelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\r\n\t\t}\r\n\r\n\t\tme.labelRotation = labelRotation;\r\n\t},\r\n\tafterCalculateTickRotation: function() {\r\n\t\thelpers$1.callback(this.options.afterCalculateTickRotation, [this]);\r\n\t},\r\n\r\n\t//\r\n\r\n\tbeforeFit: function() {\r\n\t\thelpers$1.callback(this.options.beforeFit, [this]);\r\n\t},\r\n\tfit: function() {\r\n\t\tvar me = this;\r\n\t\t// Reset\r\n\t\tvar minSize = me.minSize = {\r\n\t\t\twidth: 0,\r\n\t\t\theight: 0\r\n\t\t};\r\n\r\n\t\tvar chart = me.chart;\r\n\t\tvar opts = me.options;\r\n\t\tvar tickOpts = opts.ticks;\r\n\t\tvar scaleLabelOpts = opts.scaleLabel;\r\n\t\tvar gridLineOpts = opts.gridLines;\r\n\t\tvar display = me._isVisible();\r\n\t\tvar isBottom = opts.position === 'bottom';\r\n\t\tvar isHorizontal = me.isHorizontal();\r\n\r\n\t\t// Width\r\n\t\tif (isHorizontal) {\r\n\t\t\tminSize.width = me.maxWidth;\r\n\t\t} else if (display) {\r\n\t\t\tminSize.width = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);\r\n\t\t}\r\n\r\n\t\t// height\r\n\t\tif (!isHorizontal) {\r\n\t\t\tminSize.height = me.maxHeight; // fill all the height\r\n\t\t} else if (display) {\r\n\t\t\tminSize.height = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);\r\n\t\t}\r\n\r\n\t\t// Don't bother fitting the ticks if we are not showing the labels\r\n\t\tif (tickOpts.display && display) {\r\n\t\t\tvar tickFonts = parseTickFontOptions(tickOpts);\r\n\t\t\tvar labelSizes = me._getLabelSizes();\r\n\t\t\tvar firstLabelSize = labelSizes.first;\r\n\t\t\tvar lastLabelSize = labelSizes.last;\r\n\t\t\tvar widestLabelSize = labelSizes.widest;\r\n\t\t\tvar highestLabelSize = labelSizes.highest;\r\n\t\t\tvar lineSpace = tickFonts.minor.lineHeight * 0.4;\r\n\t\t\tvar tickPadding = tickOpts.padding;\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\t// A horizontal axis is more constrained by the height.\r\n\t\t\t\tvar isRotated = me.labelRotation !== 0;\r\n\t\t\t\tvar angleRadians = helpers$1.toRadians(me.labelRotation);\r\n\t\t\t\tvar cosRotation = Math.cos(angleRadians);\r\n\t\t\t\tvar sinRotation = Math.sin(angleRadians);\r\n\r\n\t\t\t\tvar labelHeight = sinRotation * widestLabelSize.width\r\n\t\t\t\t\t+ cosRotation * (highestLabelSize.height - (isRotated ? highestLabelSize.offset : 0))\r\n\t\t\t\t\t+ (isRotated ? 0 : lineSpace); // padding\r\n\r\n\t\t\t\tminSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\r\n\r\n\t\t\t\tvar offsetLeft = me.getPixelForTick(0) - me.left;\r\n\t\t\t\tvar offsetRight = me.right - me.getPixelForTick(me.getTicks().length - 1);\r\n\t\t\t\tvar paddingLeft, paddingRight;\r\n\r\n\t\t\t\t// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\r\n\t\t\t\t// which means that the right padding is dominated by the font height\r\n\t\t\t\tif (isRotated) {\r\n\t\t\t\t\tpaddingLeft = isBottom ?\r\n\t\t\t\t\t\tcosRotation * firstLabelSize.width + sinRotation * firstLabelSize.offset :\r\n\t\t\t\t\t\tsinRotation * (firstLabelSize.height - firstLabelSize.offset);\r\n\t\t\t\t\tpaddingRight = isBottom ?\r\n\t\t\t\t\t\tsinRotation * (lastLabelSize.height - lastLabelSize.offset) :\r\n\t\t\t\t\t\tcosRotation * lastLabelSize.width + sinRotation * lastLabelSize.offset;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpaddingLeft = firstLabelSize.width / 2;\r\n\t\t\t\t\tpaddingRight = lastLabelSize.width / 2;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Adjust padding taking into account changes in offsets\r\n\t\t\t\t// and add 3 px to move away from canvas edges\r\n\t\t\t\tme.paddingLeft = Math.max((paddingLeft - offsetLeft) * me.width / (me.width - offsetLeft), 0) + 3;\r\n\t\t\t\tme.paddingRight = Math.max((paddingRight - offsetRight) * me.width / (me.width - offsetRight), 0) + 3;\r\n\t\t\t} else {\r\n\t\t\t\t// A vertical axis is more constrained by the width. Labels are the\r\n\t\t\t\t// dominant factor here, so get that length first and account for padding\r\n\t\t\t\tvar labelWidth = tickOpts.mirror ? 0 :\r\n\t\t\t\t\t// use lineSpace for consistency with horizontal axis\r\n\t\t\t\t\t// tickPadding is not implemented for horizontal\r\n\t\t\t\t\twidestLabelSize.width + tickPadding + lineSpace;\r\n\r\n\t\t\t\tminSize.width = Math.min(me.maxWidth, minSize.width + labelWidth);\r\n\r\n\t\t\t\tme.paddingTop = firstLabelSize.height / 2;\r\n\t\t\t\tme.paddingBottom = lastLabelSize.height / 2;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tme.handleMargins();\r\n\r\n\t\tif (isHorizontal) {\r\n\t\t\tme.width = me._length = chart.width - me.margins.left - me.margins.right;\r\n\t\t\tme.height = minSize.height;\r\n\t\t} else {\r\n\t\t\tme.width = minSize.width;\r\n\t\t\tme.height = me._length = chart.height - me.margins.top - me.margins.bottom;\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Handle margins and padding interactions\r\n\t * @private\r\n\t */\r\n\thandleMargins: function() {\r\n\t\tvar me = this;\r\n\t\tif (me.margins) {\r\n\t\t\tme.margins.left = Math.max(me.paddingLeft, me.margins.left);\r\n\t\t\tme.margins.top = Math.max(me.paddingTop, me.margins.top);\r\n\t\t\tme.margins.right = Math.max(me.paddingRight, me.margins.right);\r\n\t\t\tme.margins.bottom = Math.max(me.paddingBottom, me.margins.bottom);\r\n\t\t}\r\n\t},\r\n\r\n\tafterFit: function() {\r\n\t\thelpers$1.callback(this.options.afterFit, [this]);\r\n\t},\r\n\r\n\t// Shared Methods\r\n\tisHorizontal: function() {\r\n\t\tvar pos = this.options.position;\r\n\t\treturn pos === 'top' || pos === 'bottom';\r\n\t},\r\n\tisFullWidth: function() {\r\n\t\treturn this.options.fullWidth;\r\n\t},\r\n\r\n\t// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\r\n\tgetRightValue: function(rawValue) {\r\n\t\t// Null and undefined values first\r\n\t\tif (isNullOrUndef(rawValue)) {\r\n\t\t\treturn NaN;\r\n\t\t}\r\n\t\t// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\r\n\t\tif ((typeof rawValue === 'number' || rawValue instanceof Number) && !isFinite(rawValue)) {\r\n\t\t\treturn NaN;\r\n\t\t}\r\n\r\n\t\t// If it is in fact an object, dive in one more level\r\n\t\tif (rawValue) {\r\n\t\t\tif (this.isHorizontal()) {\r\n\t\t\t\tif (rawValue.x !== undefined) {\r\n\t\t\t\t\treturn this.getRightValue(rawValue.x);\r\n\t\t\t\t}\r\n\t\t\t} else if (rawValue.y !== undefined) {\r\n\t\t\t\treturn this.getRightValue(rawValue.y);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Value is good, return it\r\n\t\treturn rawValue;\r\n\t},\r\n\r\n\t_convertTicksToLabels: function(ticks) {\r\n\t\tvar me = this;\r\n\t\tvar labels, i, ilen;\r\n\r\n\t\tme.ticks = ticks.map(function(tick) {\r\n\t\t\treturn tick.value;\r\n\t\t});\r\n\r\n\t\tme.beforeTickToLabelConversion();\r\n\r\n\t\t// New implementations should return the formatted tick labels but for BACKWARD\r\n\t\t// COMPAT, we still support no return (`this.ticks` internally changed by calling\r\n\t\t// this method and supposed to contain only string values).\r\n\t\tlabels = me.convertTicksToLabels(ticks) || me.ticks;\r\n\r\n\t\tme.afterTickToLabelConversion();\r\n\r\n\t\t// BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)\r\n\t\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\r\n\t\t\tticks[i].label = labels[i];\r\n\t\t}\r\n\r\n\t\treturn labels;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getLabelSizes: function() {\r\n\t\tvar me = this;\r\n\t\tvar labelSizes = me._labelSizes;\r\n\r\n\t\tif (!labelSizes) {\r\n\t\t\tme._labelSizes = labelSizes = computeLabelSizes(me.ctx, parseTickFontOptions(me.options.ticks), me.getTicks(), me.longestTextCache);\r\n\t\t\tme.longestLabelWidth = labelSizes.widest.width;\r\n\t\t}\r\n\r\n\t\treturn labelSizes;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_parseValue: function(value) {\r\n\t\tvar start, end, min, max;\r\n\r\n\t\tif (isArray(value)) {\r\n\t\t\tstart = +this.getRightValue(value[0]);\r\n\t\t\tend = +this.getRightValue(value[1]);\r\n\t\t\tmin = Math.min(start, end);\r\n\t\t\tmax = Math.max(start, end);\r\n\t\t} else {\r\n\t\t\tvalue = +this.getRightValue(value);\r\n\t\t\tstart = undefined;\r\n\t\t\tend = value;\r\n\t\t\tmin = value;\r\n\t\t\tmax = value;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tmin: min,\r\n\t\t\tmax: max,\r\n\t\t\tstart: start,\r\n\t\t\tend: end\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\t_getScaleLabel: function(rawValue) {\r\n\t\tvar v = this._parseValue(rawValue);\r\n\t\tif (v.start !== undefined) {\r\n\t\t\treturn '[' + v.start + ', ' + v.end + ']';\r\n\t\t}\r\n\r\n\t\treturn +this.getRightValue(rawValue);\r\n\t},\r\n\r\n\t/**\r\n\t * Used to get the value to display in the tooltip for the data at the given index\r\n\t * @param index\r\n\t * @param datasetIndex\r\n\t */\r\n\tgetLabelForIndex: helpers$1.noop,\r\n\r\n\t/**\r\n\t * Returns the location of the given data point. Value can either be an index or a numerical value\r\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\r\n\t * @param value\r\n\t * @param index\r\n\t * @param datasetIndex\r\n\t */\r\n\tgetPixelForValue: helpers$1.noop,\r\n\r\n\t/**\r\n\t * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\r\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\r\n\t * @param pixel\r\n\t */\r\n\tgetValueForPixel: helpers$1.noop,\r\n\r\n\t/**\r\n\t * Returns the location of the tick at the given index\r\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\r\n\t */\r\n\tgetPixelForTick: function(index) {\r\n\t\tvar me = this;\r\n\t\tvar offset = me.options.offset;\r\n\t\tvar numTicks = me._ticks.length;\r\n\t\tvar tickWidth = 1 / Math.max(numTicks - (offset ? 0 : 1), 1);\r\n\r\n\t\treturn index < 0 || index > numTicks - 1\r\n\t\t\t? null\r\n\t\t\t: me.getPixelForDecimal(index * tickWidth + (offset ? tickWidth / 2 : 0));\r\n\t},\r\n\r\n\t/**\r\n\t * Utility for getting the pixel location of a percentage of scale\r\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\r\n\t */\r\n\tgetPixelForDecimal: function(decimal) {\r\n\t\tvar me = this;\r\n\r\n\t\tif (me._reversePixels) {\r\n\t\t\tdecimal = 1 - decimal;\r\n\t\t}\r\n\r\n\t\treturn me._startPixel + decimal * me._length;\r\n\t},\r\n\r\n\tgetDecimalForPixel: function(pixel) {\r\n\t\tvar decimal = (pixel - this._startPixel) / this._length;\r\n\t\treturn this._reversePixels ? 1 - decimal : decimal;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns the pixel for the minimum chart value\r\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\r\n\t */\r\n\tgetBasePixel: function() {\r\n\t\treturn this.getPixelForValue(this.getBaseValue());\r\n\t},\r\n\r\n\tgetBaseValue: function() {\r\n\t\tvar me = this;\r\n\t\tvar min = me.min;\r\n\t\tvar max = me.max;\r\n\r\n\t\treturn me.beginAtZero ? 0 :\r\n\t\t\tmin < 0 && max < 0 ? max :\r\n\t\t\tmin > 0 && max > 0 ? min :\r\n\t\t\t0;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns a subset of ticks to be plotted to avoid overlapping labels.\r\n\t * @private\r\n\t */\r\n\t_autoSkip: function(ticks) {\r\n\t\tvar me = this;\r\n\t\tvar tickOpts = me.options.ticks;\r\n\t\tvar axisLength = me._length;\r\n\t\tvar ticksLimit = tickOpts.maxTicksLimit || axisLength / me._tickSize() + 1;\r\n\t\tvar majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\r\n\t\tvar numMajorIndices = majorIndices.length;\r\n\t\tvar first = majorIndices[0];\r\n\t\tvar last = majorIndices[numMajorIndices - 1];\r\n\t\tvar i, ilen, spacing, avgMajorSpacing;\r\n\r\n\t\t// If there are too many major ticks to display them all\r\n\t\tif (numMajorIndices > ticksLimit) {\r\n\t\t\tskipMajors(ticks, majorIndices, numMajorIndices / ticksLimit);\r\n\t\t\treturn nonSkipped(ticks);\r\n\t\t}\r\n\r\n\t\tspacing = calculateSpacing(majorIndices, ticks, axisLength, ticksLimit);\r\n\r\n\t\tif (numMajorIndices > 0) {\r\n\t\t\tfor (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\r\n\t\t\t\tskip(ticks, spacing, majorIndices[i], majorIndices[i + 1]);\r\n\t\t\t}\r\n\t\t\tavgMajorSpacing = numMajorIndices > 1 ? (last - first) / (numMajorIndices - 1) : null;\r\n\t\t\tskip(ticks, spacing, helpers$1.isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\r\n\t\t\tskip(ticks, spacing, last, helpers$1.isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\r\n\t\t\treturn nonSkipped(ticks);\r\n\t\t}\r\n\t\tskip(ticks, spacing);\r\n\t\treturn nonSkipped(ticks);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_tickSize: function() {\r\n\t\tvar me = this;\r\n\t\tvar optionTicks = me.options.ticks;\r\n\r\n\t\t// Calculate space needed by label in axis direction.\r\n\t\tvar rot = helpers$1.toRadians(me.labelRotation);\r\n\t\tvar cos = Math.abs(Math.cos(rot));\r\n\t\tvar sin = Math.abs(Math.sin(rot));\r\n\r\n\t\tvar labelSizes = me._getLabelSizes();\r\n\t\tvar padding = optionTicks.autoSkipPadding || 0;\r\n\t\tvar w = labelSizes ? labelSizes.widest.width + padding : 0;\r\n\t\tvar h = labelSizes ? labelSizes.highest.height + padding : 0;\r\n\r\n\t\t// Calculate space needed for 1 tick in axis direction.\r\n\t\treturn me.isHorizontal()\r\n\t\t\t? h * cos > w * sin ? w / cos : h / sin\r\n\t\t\t: h * sin < w * cos ? h / cos : w / sin;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_isVisible: function() {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar display = me.options.display;\r\n\t\tvar i, ilen, meta;\r\n\r\n\t\tif (display !== 'auto') {\r\n\t\t\treturn !!display;\r\n\t\t}\r\n\r\n\t\t// When 'auto', the scale is visible if at least one associated dataset is visible.\r\n\t\tfor (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\r\n\t\t\tif (chart.isDatasetVisible(i)) {\r\n\t\t\t\tmeta = chart.getDatasetMeta(i);\r\n\t\t\t\tif (meta.xAxisID === me.id || meta.yAxisID === me.id) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_computeGridLineItems: function(chartArea) {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar options = me.options;\r\n\t\tvar gridLines = options.gridLines;\r\n\t\tvar position = options.position;\r\n\t\tvar offsetGridLines = gridLines.offsetGridLines;\r\n\t\tvar isHorizontal = me.isHorizontal();\r\n\t\tvar ticks = me._ticksToDraw;\r\n\t\tvar ticksLength = ticks.length + (offsetGridLines ? 1 : 0);\r\n\r\n\t\tvar tl = getTickMarkLength(gridLines);\r\n\t\tvar items = [];\r\n\t\tvar axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;\r\n\t\tvar axisHalfWidth = axisWidth / 2;\r\n\t\tvar alignPixel = helpers$1._alignPixel;\r\n\t\tvar alignBorderValue = function(pixel) {\r\n\t\t\treturn alignPixel(chart, pixel, axisWidth);\r\n\t\t};\r\n\t\tvar borderValue, i, tick, lineValue, alignedLineValue;\r\n\t\tvar tx1, ty1, tx2, ty2, x1, y1, x2, y2, lineWidth, lineColor, borderDash, borderDashOffset;\r\n\r\n\t\tif (position === 'top') {\r\n\t\t\tborderValue = alignBorderValue(me.bottom);\r\n\t\t\tty1 = me.bottom - tl;\r\n\t\t\tty2 = borderValue - axisHalfWidth;\r\n\t\t\ty1 = alignBorderValue(chartArea.top) + axisHalfWidth;\r\n\t\t\ty2 = chartArea.bottom;\r\n\t\t} else if (position === 'bottom') {\r\n\t\t\tborderValue = alignBorderValue(me.top);\r\n\t\t\ty1 = chartArea.top;\r\n\t\t\ty2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\r\n\t\t\tty1 = borderValue + axisHalfWidth;\r\n\t\t\tty2 = me.top + tl;\r\n\t\t} else if (position === 'left') {\r\n\t\t\tborderValue = alignBorderValue(me.right);\r\n\t\t\ttx1 = me.right - tl;\r\n\t\t\ttx2 = borderValue - axisHalfWidth;\r\n\t\t\tx1 = alignBorderValue(chartArea.left) + axisHalfWidth;\r\n\t\t\tx2 = chartArea.right;\r\n\t\t} else {\r\n\t\t\tborderValue = alignBorderValue(me.left);\r\n\t\t\tx1 = chartArea.left;\r\n\t\t\tx2 = alignBorderValue(chartArea.right) - axisHalfWidth;\r\n\t\t\ttx1 = borderValue + axisHalfWidth;\r\n\t\t\ttx2 = me.left + tl;\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < ticksLength; ++i) {\r\n\t\t\ttick = ticks[i] || {};\r\n\r\n\t\t\t// autoskipper skipped this tick (#4635)\r\n\t\t\tif (isNullOrUndef(tick.label) && i < ticks.length) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (i === me.zeroLineIndex && options.offset === offsetGridLines) {\r\n\t\t\t\t// Draw the first index specially\r\n\t\t\t\tlineWidth = gridLines.zeroLineWidth;\r\n\t\t\t\tlineColor = gridLines.zeroLineColor;\r\n\t\t\t\tborderDash = gridLines.zeroLineBorderDash || [];\r\n\t\t\t\tborderDashOffset = gridLines.zeroLineBorderDashOffset || 0.0;\r\n\t\t\t} else {\r\n\t\t\t\tlineWidth = valueAtIndexOrDefault(gridLines.lineWidth, i, 1);\r\n\t\t\t\tlineColor = valueAtIndexOrDefault(gridLines.color, i, 'rgba(0,0,0,0.1)');\r\n\t\t\t\tborderDash = gridLines.borderDash || [];\r\n\t\t\t\tborderDashOffset = gridLines.borderDashOffset || 0.0;\r\n\t\t\t}\r\n\r\n\t\t\tlineValue = getPixelForGridLine(me, tick._index || i, offsetGridLines);\r\n\r\n\t\t\t// Skip if the pixel is out of the range\r\n\t\t\tif (lineValue === undefined) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\talignedLineValue = alignPixel(chart, lineValue, lineWidth);\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\ttx1 = tx2 = x1 = x2 = alignedLineValue;\r\n\t\t\t} else {\r\n\t\t\t\tty1 = ty2 = y1 = y2 = alignedLineValue;\r\n\t\t\t}\r\n\r\n\t\t\titems.push({\r\n\t\t\t\ttx1: tx1,\r\n\t\t\t\tty1: ty1,\r\n\t\t\t\ttx2: tx2,\r\n\t\t\t\tty2: ty2,\r\n\t\t\t\tx1: x1,\r\n\t\t\t\ty1: y1,\r\n\t\t\t\tx2: x2,\r\n\t\t\t\ty2: y2,\r\n\t\t\t\twidth: lineWidth,\r\n\t\t\t\tcolor: lineColor,\r\n\t\t\t\tborderDash: borderDash,\r\n\t\t\t\tborderDashOffset: borderDashOffset,\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\titems.ticksLength = ticksLength;\r\n\t\titems.borderValue = borderValue;\r\n\r\n\t\treturn items;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_computeLabelItems: function() {\r\n\t\tvar me = this;\r\n\t\tvar options = me.options;\r\n\t\tvar optionTicks = options.ticks;\r\n\t\tvar position = options.position;\r\n\t\tvar isMirrored = optionTicks.mirror;\r\n\t\tvar isHorizontal = me.isHorizontal();\r\n\t\tvar ticks = me._ticksToDraw;\r\n\t\tvar fonts = parseTickFontOptions(optionTicks);\r\n\t\tvar tickPadding = optionTicks.padding;\r\n\t\tvar tl = getTickMarkLength(options.gridLines);\r\n\t\tvar rotation = -helpers$1.toRadians(me.labelRotation);\r\n\t\tvar items = [];\r\n\t\tvar i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\r\n\r\n\t\tif (position === 'top') {\r\n\t\t\ty = me.bottom - tl - tickPadding;\r\n\t\t\ttextAlign = !rotation ? 'center' : 'left';\r\n\t\t} else if (position === 'bottom') {\r\n\t\t\ty = me.top + tl + tickPadding;\r\n\t\t\ttextAlign = !rotation ? 'center' : 'right';\r\n\t\t} else if (position === 'left') {\r\n\t\t\tx = me.right - (isMirrored ? 0 : tl) - tickPadding;\r\n\t\t\ttextAlign = isMirrored ? 'left' : 'right';\r\n\t\t} else {\r\n\t\t\tx = me.left + (isMirrored ? 0 : tl) + tickPadding;\r\n\t\t\ttextAlign = isMirrored ? 'right' : 'left';\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\r\n\t\t\ttick = ticks[i];\r\n\t\t\tlabel = tick.label;\r\n\r\n\t\t\t// autoskipper skipped this tick (#4635)\r\n\t\t\tif (isNullOrUndef(label)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tpixel = me.getPixelForTick(tick._index || i) + optionTicks.labelOffset;\r\n\t\t\tfont = tick.major ? fonts.major : fonts.minor;\r\n\t\t\tlineHeight = font.lineHeight;\r\n\t\t\tlineCount = isArray(label) ? label.length : 1;\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\tx = pixel;\r\n\t\t\t\ttextOffset = position === 'top'\r\n\t\t\t\t\t? ((!rotation ? 0.5 : 1) - lineCount) * lineHeight\r\n\t\t\t\t\t: (!rotation ? 0.5 : 0) * lineHeight;\r\n\t\t\t} else {\r\n\t\t\t\ty = pixel;\r\n\t\t\t\ttextOffset = (1 - lineCount) * lineHeight / 2;\r\n\t\t\t}\r\n\r\n\t\t\titems.push({\r\n\t\t\t\tx: x,\r\n\t\t\t\ty: y,\r\n\t\t\t\trotation: rotation,\r\n\t\t\t\tlabel: label,\r\n\t\t\t\tfont: font,\r\n\t\t\t\ttextOffset: textOffset,\r\n\t\t\t\ttextAlign: textAlign\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn items;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_drawGrid: function(chartArea) {\r\n\t\tvar me = this;\r\n\t\tvar gridLines = me.options.gridLines;\r\n\r\n\t\tif (!gridLines.display) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar ctx = me.ctx;\r\n\t\tvar chart = me.chart;\r\n\t\tvar alignPixel = helpers$1._alignPixel;\r\n\t\tvar axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;\r\n\t\tvar items = me._gridLineItems || (me._gridLineItems = me._computeGridLineItems(chartArea));\r\n\t\tvar width, color, i, ilen, item;\r\n\r\n\t\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\r\n\t\t\titem = items[i];\r\n\t\t\twidth = item.width;\r\n\t\t\tcolor = item.color;\r\n\r\n\t\t\tif (width && color) {\r\n\t\t\t\tctx.save();\r\n\t\t\t\tctx.lineWidth = width;\r\n\t\t\t\tctx.strokeStyle = color;\r\n\t\t\t\tif (ctx.setLineDash) {\r\n\t\t\t\t\tctx.setLineDash(item.borderDash);\r\n\t\t\t\t\tctx.lineDashOffset = item.borderDashOffset;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tctx.beginPath();\r\n\r\n\t\t\t\tif (gridLines.drawTicks) {\r\n\t\t\t\t\tctx.moveTo(item.tx1, item.ty1);\r\n\t\t\t\t\tctx.lineTo(item.tx2, item.ty2);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (gridLines.drawOnChartArea) {\r\n\t\t\t\t\tctx.moveTo(item.x1, item.y1);\r\n\t\t\t\t\tctx.lineTo(item.x2, item.y2);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tctx.stroke();\r\n\t\t\t\tctx.restore();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (axisWidth) {\r\n\t\t\t// Draw the line at the edge of the axis\r\n\t\t\tvar firstLineWidth = axisWidth;\r\n\t\t\tvar lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, items.ticksLength - 1, 1);\r\n\t\t\tvar borderValue = items.borderValue;\r\n\t\t\tvar x1, x2, y1, y2;\r\n\r\n\t\t\tif (me.isHorizontal()) {\r\n\t\t\t\tx1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;\r\n\t\t\t\tx2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;\r\n\t\t\t\ty1 = y2 = borderValue;\r\n\t\t\t} else {\r\n\t\t\t\ty1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;\r\n\t\t\t\ty2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;\r\n\t\t\t\tx1 = x2 = borderValue;\r\n\t\t\t}\r\n\r\n\t\t\tctx.lineWidth = axisWidth;\r\n\t\t\tctx.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);\r\n\t\t\tctx.beginPath();\r\n\t\t\tctx.moveTo(x1, y1);\r\n\t\t\tctx.lineTo(x2, y2);\r\n\t\t\tctx.stroke();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_drawLabels: function() {\r\n\t\tvar me = this;\r\n\t\tvar optionTicks = me.options.ticks;\r\n\r\n\t\tif (!optionTicks.display) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar ctx = me.ctx;\r\n\t\tvar items = me._labelItems || (me._labelItems = me._computeLabelItems());\r\n\t\tvar i, j, ilen, jlen, item, tickFont, label, y;\r\n\r\n\t\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\r\n\t\t\titem = items[i];\r\n\t\t\ttickFont = item.font;\r\n\r\n\t\t\t// Make sure we draw text in the correct color and font\r\n\t\t\tctx.save();\r\n\t\t\tctx.translate(item.x, item.y);\r\n\t\t\tctx.rotate(item.rotation);\r\n\t\t\tctx.font = tickFont.string;\r\n\t\t\tctx.fillStyle = tickFont.color;\r\n\t\t\tctx.textBaseline = 'middle';\r\n\t\t\tctx.textAlign = item.textAlign;\r\n\r\n\t\t\tlabel = item.label;\r\n\t\t\ty = item.textOffset;\r\n\t\t\tif (isArray(label)) {\r\n\t\t\t\tfor (j = 0, jlen = label.length; j < jlen; ++j) {\r\n\t\t\t\t\t// We just make sure the multiline element is a string here..\r\n\t\t\t\t\tctx.fillText('' + label[j], 0, y);\r\n\t\t\t\t\ty += tickFont.lineHeight;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tctx.fillText(label, 0, y);\r\n\t\t\t}\r\n\t\t\tctx.restore();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_drawTitle: function() {\r\n\t\tvar me = this;\r\n\t\tvar ctx = me.ctx;\r\n\t\tvar options = me.options;\r\n\t\tvar scaleLabel = options.scaleLabel;\r\n\r\n\t\tif (!scaleLabel.display) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar scaleLabelFontColor = valueOrDefault$a(scaleLabel.fontColor, core_defaults.global.defaultFontColor);\r\n\t\tvar scaleLabelFont = helpers$1.options._parseFont(scaleLabel);\r\n\t\tvar scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);\r\n\t\tvar halfLineHeight = scaleLabelFont.lineHeight / 2;\r\n\t\tvar position = options.position;\r\n\t\tvar rotation = 0;\r\n\t\tvar scaleLabelX, scaleLabelY;\r\n\r\n\t\tif (me.isHorizontal()) {\r\n\t\t\tscaleLabelX = me.left + me.width / 2; // midpoint of the width\r\n\t\t\tscaleLabelY = position === 'bottom'\r\n\t\t\t\t? me.bottom - halfLineHeight - scaleLabelPadding.bottom\r\n\t\t\t\t: me.top + halfLineHeight + scaleLabelPadding.top;\r\n\t\t} else {\r\n\t\t\tvar isLeft = position === 'left';\r\n\t\t\tscaleLabelX = isLeft\r\n\t\t\t\t? me.left + halfLineHeight + scaleLabelPadding.top\r\n\t\t\t\t: me.right - halfLineHeight - scaleLabelPadding.top;\r\n\t\t\tscaleLabelY = me.top + me.height / 2;\r\n\t\t\trotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\r\n\t\t}\r\n\r\n\t\tctx.save();\r\n\t\tctx.translate(scaleLabelX, scaleLabelY);\r\n\t\tctx.rotate(rotation);\r\n\t\tctx.textAlign = 'center';\r\n\t\tctx.textBaseline = 'middle';\r\n\t\tctx.fillStyle = scaleLabelFontColor; // render in correct colour\r\n\t\tctx.font = scaleLabelFont.string;\r\n\t\tctx.fillText(scaleLabel.labelString, 0, 0);\r\n\t\tctx.restore();\r\n\t},\r\n\r\n\tdraw: function(chartArea) {\r\n\t\tvar me = this;\r\n\r\n\t\tif (!me._isVisible()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tme._drawGrid(chartArea);\r\n\t\tme._drawTitle();\r\n\t\tme._drawLabels();\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_layers: function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar tz = opts.ticks && opts.ticks.z || 0;\r\n\t\tvar gz = opts.gridLines && opts.gridLines.z || 0;\r\n\r\n\t\tif (!me._isVisible() || tz === gz || me.draw !== me._draw) {\r\n\t\t\t// backward compatibility: draw has been overridden by custom scale\r\n\t\t\treturn [{\r\n\t\t\t\tz: tz,\r\n\t\t\t\tdraw: function() {\r\n\t\t\t\t\tme.draw.apply(me, arguments);\r\n\t\t\t\t}\r\n\t\t\t}];\r\n\t\t}\r\n\r\n\t\treturn [{\r\n\t\t\tz: gz,\r\n\t\t\tdraw: function() {\r\n\t\t\t\tme._drawGrid.apply(me, arguments);\r\n\t\t\t\tme._drawTitle.apply(me, arguments);\r\n\t\t\t}\r\n\t\t}, {\r\n\t\t\tz: tz,\r\n\t\t\tdraw: function() {\r\n\t\t\t\tme._drawLabels.apply(me, arguments);\r\n\t\t\t}\r\n\t\t}];\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getMatchingVisibleMetas: function(type) {\r\n\t\tvar me = this;\r\n\t\tvar isHorizontal = me.isHorizontal();\r\n\t\treturn me.chart._getSortedVisibleDatasetMetas()\r\n\t\t\t.filter(function(meta) {\r\n\t\t\t\treturn (!type || meta.type === type)\r\n\t\t\t\t\t&& (isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id);\r\n\t\t\t});\r\n\t}\r\n});\r\n\r\nScale.prototype._draw = Scale.prototype.draw;\r\n\r\nvar core_scale = Scale;\n\nvar isNullOrUndef$1 = helpers$1.isNullOrUndef;\r\n\r\nvar defaultConfig = {\r\n\tposition: 'bottom'\r\n};\r\n\r\nvar scale_category = core_scale.extend({\r\n\tdetermineDataLimits: function() {\r\n\t\tvar me = this;\r\n\t\tvar labels = me._getLabels();\r\n\t\tvar ticksOpts = me.options.ticks;\r\n\t\tvar min = ticksOpts.min;\r\n\t\tvar max = ticksOpts.max;\r\n\t\tvar minIndex = 0;\r\n\t\tvar maxIndex = labels.length - 1;\r\n\t\tvar findIndex;\r\n\r\n\t\tif (min !== undefined) {\r\n\t\t\t// user specified min value\r\n\t\t\tfindIndex = labels.indexOf(min);\r\n\t\t\tif (findIndex >= 0) {\r\n\t\t\t\tminIndex = findIndex;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (max !== undefined) {\r\n\t\t\t// user specified max value\r\n\t\t\tfindIndex = labels.indexOf(max);\r\n\t\t\tif (findIndex >= 0) {\r\n\t\t\t\tmaxIndex = findIndex;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tme.minIndex = minIndex;\r\n\t\tme.maxIndex = maxIndex;\r\n\t\tme.min = labels[minIndex];\r\n\t\tme.max = labels[maxIndex];\r\n\t},\r\n\r\n\tbuildTicks: function() {\r\n\t\tvar me = this;\r\n\t\tvar labels = me._getLabels();\r\n\t\tvar minIndex = me.minIndex;\r\n\t\tvar maxIndex = me.maxIndex;\r\n\r\n\t\t// If we are viewing some subset of labels, slice the original array\r\n\t\tme.ticks = (minIndex === 0 && maxIndex === labels.length - 1) ? labels : labels.slice(minIndex, maxIndex + 1);\r\n\t},\r\n\r\n\tgetLabelForIndex: function(index, datasetIndex) {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\r\n\t\tif (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {\r\n\t\t\treturn me.getRightValue(chart.data.datasets[datasetIndex].data[index]);\r\n\t\t}\r\n\r\n\t\treturn me._getLabels()[index];\r\n\t},\r\n\r\n\t_configure: function() {\r\n\t\tvar me = this;\r\n\t\tvar offset = me.options.offset;\r\n\t\tvar ticks = me.ticks;\r\n\r\n\t\tcore_scale.prototype._configure.call(me);\r\n\r\n\t\tif (!me.isHorizontal()) {\r\n\t\t\t// For backward compatibility, vertical category scale reverse is inverted.\r\n\t\t\tme._reversePixels = !me._reversePixels;\r\n\t\t}\r\n\r\n\t\tif (!ticks) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tme._startValue = me.minIndex - (offset ? 0.5 : 0);\r\n\t\tme._valueRange = Math.max(ticks.length - (offset ? 0 : 1), 1);\r\n\t},\r\n\r\n\t// Used to get data value locations.  Value can either be an index or a numerical value\r\n\tgetPixelForValue: function(value, index, datasetIndex) {\r\n\t\tvar me = this;\r\n\t\tvar valueCategory, labels, idx;\r\n\r\n\t\tif (!isNullOrUndef$1(index) && !isNullOrUndef$1(datasetIndex)) {\r\n\t\t\tvalue = me.chart.data.datasets[datasetIndex].data[index];\r\n\t\t}\r\n\r\n\t\t// If value is a data object, then index is the index in the data array,\r\n\t\t// not the index of the scale. We need to change that.\r\n\t\tif (!isNullOrUndef$1(value)) {\r\n\t\t\tvalueCategory = me.isHorizontal() ? value.x : value.y;\r\n\t\t}\r\n\t\tif (valueCategory !== undefined || (value !== undefined && isNaN(index))) {\r\n\t\t\tlabels = me._getLabels();\r\n\t\t\tvalue = helpers$1.valueOrDefault(valueCategory, value);\r\n\t\t\tidx = labels.indexOf(value);\r\n\t\t\tindex = idx !== -1 ? idx : index;\r\n\t\t\tif (isNaN(index)) {\r\n\t\t\t\tindex = value;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn me.getPixelForDecimal((index - me._startValue) / me._valueRange);\r\n\t},\r\n\r\n\tgetPixelForTick: function(index) {\r\n\t\tvar ticks = this.ticks;\r\n\t\treturn index < 0 || index > ticks.length - 1\r\n\t\t\t? null\r\n\t\t\t: this.getPixelForValue(ticks[index], index + this.minIndex);\r\n\t},\r\n\r\n\tgetValueForPixel: function(pixel) {\r\n\t\tvar me = this;\r\n\t\tvar value = Math.round(me._startValue + me.getDecimalForPixel(pixel) * me._valueRange);\r\n\t\treturn Math.min(Math.max(value, 0), me.ticks.length - 1);\r\n\t},\r\n\r\n\tgetBasePixel: function() {\r\n\t\treturn this.bottom;\r\n\t}\r\n});\r\n\r\n// INTERNAL: static default options, registered in src/index.js\r\nvar _defaults = defaultConfig;\nscale_category._defaults = _defaults;\n\nvar noop = helpers$1.noop;\r\nvar isNullOrUndef$2 = helpers$1.isNullOrUndef;\r\n\r\n/**\r\n * Generate a set of linear ticks\r\n * @param generationOptions the options used to generate the ticks\r\n * @param dataRange the range of the data\r\n * @returns {number[]} array of tick values\r\n */\r\nfunction generateTicks(generationOptions, dataRange) {\r\n\tvar ticks = [];\r\n\t// To get a \"nice\" value for the tick spacing, we will use the appropriately named\r\n\t// \"nice number\" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\r\n\t// for details.\r\n\r\n\tvar MIN_SPACING = 1e-14;\r\n\tvar stepSize = generationOptions.stepSize;\r\n\tvar unit = stepSize || 1;\r\n\tvar maxNumSpaces = generationOptions.maxTicks - 1;\r\n\tvar min = generationOptions.min;\r\n\tvar max = generationOptions.max;\r\n\tvar precision = generationOptions.precision;\r\n\tvar rmin = dataRange.min;\r\n\tvar rmax = dataRange.max;\r\n\tvar spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;\r\n\tvar factor, niceMin, niceMax, numSpaces;\r\n\r\n\t// Beyond MIN_SPACING floating point numbers being to lose precision\r\n\t// such that we can't do the math necessary to generate ticks\r\n\tif (spacing < MIN_SPACING && isNullOrUndef$2(min) && isNullOrUndef$2(max)) {\r\n\t\treturn [rmin, rmax];\r\n\t}\r\n\r\n\tnumSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\r\n\tif (numSpaces > maxNumSpaces) {\r\n\t\t// If the calculated num of spaces exceeds maxNumSpaces, recalculate it\r\n\t\tspacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;\r\n\t}\r\n\r\n\tif (stepSize || isNullOrUndef$2(precision)) {\r\n\t\t// If a precision is not specified, calculate factor based on spacing\r\n\t\tfactor = Math.pow(10, helpers$1._decimalPlaces(spacing));\r\n\t} else {\r\n\t\t// If the user specified a precision, round to that number of decimal places\r\n\t\tfactor = Math.pow(10, precision);\r\n\t\tspacing = Math.ceil(spacing * factor) / factor;\r\n\t}\r\n\r\n\tniceMin = Math.floor(rmin / spacing) * spacing;\r\n\tniceMax = Math.ceil(rmax / spacing) * spacing;\r\n\r\n\t// If min, max and stepSize is set and they make an evenly spaced scale use it.\r\n\tif (stepSize) {\r\n\t\t// If very close to our whole number, use it.\r\n\t\tif (!isNullOrUndef$2(min) && helpers$1.almostWhole(min / spacing, spacing / 1000)) {\r\n\t\t\tniceMin = min;\r\n\t\t}\r\n\t\tif (!isNullOrUndef$2(max) && helpers$1.almostWhole(max / spacing, spacing / 1000)) {\r\n\t\t\tniceMax = max;\r\n\t\t}\r\n\t}\r\n\r\n\tnumSpaces = (niceMax - niceMin) / spacing;\r\n\t// If very close to our rounded value, use it.\r\n\tif (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\r\n\t\tnumSpaces = Math.round(numSpaces);\r\n\t} else {\r\n\t\tnumSpaces = Math.ceil(numSpaces);\r\n\t}\r\n\r\n\tniceMin = Math.round(niceMin * factor) / factor;\r\n\tniceMax = Math.round(niceMax * factor) / factor;\r\n\tticks.push(isNullOrUndef$2(min) ? niceMin : min);\r\n\tfor (var j = 1; j < numSpaces; ++j) {\r\n\t\tticks.push(Math.round((niceMin + j * spacing) * factor) / factor);\r\n\t}\r\n\tticks.push(isNullOrUndef$2(max) ? niceMax : max);\r\n\r\n\treturn ticks;\r\n}\r\n\r\nvar scale_linearbase = core_scale.extend({\r\n\tgetRightValue: function(value) {\r\n\t\tif (typeof value === 'string') {\r\n\t\t\treturn +value;\r\n\t\t}\r\n\t\treturn core_scale.prototype.getRightValue.call(this, value);\r\n\t},\r\n\r\n\thandleTickRangeOptions: function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar tickOpts = opts.ticks;\r\n\r\n\t\t// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\r\n\t\t// do nothing since that would make the chart weird. If the user really wants a weird chart\r\n\t\t// axis, they can manually override it\r\n\t\tif (tickOpts.beginAtZero) {\r\n\t\t\tvar minSign = helpers$1.sign(me.min);\r\n\t\t\tvar maxSign = helpers$1.sign(me.max);\r\n\r\n\t\t\tif (minSign < 0 && maxSign < 0) {\r\n\t\t\t\t// move the top up to 0\r\n\t\t\t\tme.max = 0;\r\n\t\t\t} else if (minSign > 0 && maxSign > 0) {\r\n\t\t\t\t// move the bottom down to 0\r\n\t\t\t\tme.min = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;\r\n\t\tvar setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;\r\n\r\n\t\tif (tickOpts.min !== undefined) {\r\n\t\t\tme.min = tickOpts.min;\r\n\t\t} else if (tickOpts.suggestedMin !== undefined) {\r\n\t\t\tif (me.min === null) {\r\n\t\t\t\tme.min = tickOpts.suggestedMin;\r\n\t\t\t} else {\r\n\t\t\t\tme.min = Math.min(me.min, tickOpts.suggestedMin);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (tickOpts.max !== undefined) {\r\n\t\t\tme.max = tickOpts.max;\r\n\t\t} else if (tickOpts.suggestedMax !== undefined) {\r\n\t\t\tif (me.max === null) {\r\n\t\t\t\tme.max = tickOpts.suggestedMax;\r\n\t\t\t} else {\r\n\t\t\t\tme.max = Math.max(me.max, tickOpts.suggestedMax);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (setMin !== setMax) {\r\n\t\t\t// We set the min or the max but not both.\r\n\t\t\t// So ensure that our range is good\r\n\t\t\t// Inverted or 0 length range can happen when\r\n\t\t\t// ticks.min is set, and no datasets are visible\r\n\t\t\tif (me.min >= me.max) {\r\n\t\t\t\tif (setMin) {\r\n\t\t\t\t\tme.max = me.min + 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tme.min = me.max - 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (me.min === me.max) {\r\n\t\t\tme.max++;\r\n\r\n\t\t\tif (!tickOpts.beginAtZero) {\r\n\t\t\t\tme.min--;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tgetTickLimit: function() {\r\n\t\tvar me = this;\r\n\t\tvar tickOpts = me.options.ticks;\r\n\t\tvar stepSize = tickOpts.stepSize;\r\n\t\tvar maxTicksLimit = tickOpts.maxTicksLimit;\r\n\t\tvar maxTicks;\r\n\r\n\t\tif (stepSize) {\r\n\t\t\tmaxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;\r\n\t\t} else {\r\n\t\t\tmaxTicks = me._computeTickLimit();\r\n\t\t\tmaxTicksLimit = maxTicksLimit || 11;\r\n\t\t}\r\n\r\n\t\tif (maxTicksLimit) {\r\n\t\t\tmaxTicks = Math.min(maxTicksLimit, maxTicks);\r\n\t\t}\r\n\r\n\t\treturn maxTicks;\r\n\t},\r\n\r\n\t_computeTickLimit: function() {\r\n\t\treturn Number.POSITIVE_INFINITY;\r\n\t},\r\n\r\n\thandleDirectionalChanges: noop,\r\n\r\n\tbuildTicks: function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar tickOpts = opts.ticks;\r\n\r\n\t\t// Figure out what the max number of ticks we can support it is based on the size of\r\n\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 40\r\n\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\r\n\t\t// the graph. Make sure we always have at least 2 ticks\r\n\t\tvar maxTicks = me.getTickLimit();\r\n\t\tmaxTicks = Math.max(2, maxTicks);\r\n\r\n\t\tvar numericGeneratorOptions = {\r\n\t\t\tmaxTicks: maxTicks,\r\n\t\t\tmin: tickOpts.min,\r\n\t\t\tmax: tickOpts.max,\r\n\t\t\tprecision: tickOpts.precision,\r\n\t\t\tstepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\r\n\t\t};\r\n\t\tvar ticks = me.ticks = generateTicks(numericGeneratorOptions, me);\r\n\r\n\t\tme.handleDirectionalChanges();\r\n\r\n\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\r\n\t\t// range of the scale\r\n\t\tme.max = helpers$1.max(ticks);\r\n\t\tme.min = helpers$1.min(ticks);\r\n\r\n\t\tif (tickOpts.reverse) {\r\n\t\t\tticks.reverse();\r\n\r\n\t\t\tme.start = me.max;\r\n\t\t\tme.end = me.min;\r\n\t\t} else {\r\n\t\t\tme.start = me.min;\r\n\t\t\tme.end = me.max;\r\n\t\t}\r\n\t},\r\n\r\n\tconvertTicksToLabels: function() {\r\n\t\tvar me = this;\r\n\t\tme.ticksAsNumbers = me.ticks.slice();\r\n\t\tme.zeroLineIndex = me.ticks.indexOf(0);\r\n\r\n\t\tcore_scale.prototype.convertTicksToLabels.call(me);\r\n\t},\r\n\r\n\t_configure: function() {\r\n\t\tvar me = this;\r\n\t\tvar ticks = me.getTicks();\r\n\t\tvar start = me.min;\r\n\t\tvar end = me.max;\r\n\t\tvar offset;\r\n\r\n\t\tcore_scale.prototype._configure.call(me);\r\n\r\n\t\tif (me.options.offset && ticks.length) {\r\n\t\t\toffset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\r\n\t\t\tstart -= offset;\r\n\t\t\tend += offset;\r\n\t\t}\r\n\t\tme._startValue = start;\r\n\t\tme._endValue = end;\r\n\t\tme._valueRange = end - start;\r\n\t}\r\n});\n\nvar defaultConfig$1 = {\r\n\tposition: 'left',\r\n\tticks: {\r\n\t\tcallback: core_ticks.formatters.linear\r\n\t}\r\n};\r\n\r\nvar DEFAULT_MIN = 0;\r\nvar DEFAULT_MAX = 1;\r\n\r\nfunction getOrCreateStack(stacks, stacked, meta) {\r\n\tvar key = [\r\n\t\tmeta.type,\r\n\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\r\n\t\tstacked === undefined && meta.stack === undefined ? meta.index : '',\r\n\t\tmeta.stack\r\n\t].join('.');\r\n\r\n\tif (stacks[key] === undefined) {\r\n\t\tstacks[key] = {\r\n\t\t\tpos: [],\r\n\t\t\tneg: []\r\n\t\t};\r\n\t}\r\n\r\n\treturn stacks[key];\r\n}\r\n\r\nfunction stackData(scale, stacks, meta, data) {\r\n\tvar opts = scale.options;\r\n\tvar stacked = opts.stacked;\r\n\tvar stack = getOrCreateStack(stacks, stacked, meta);\r\n\tvar pos = stack.pos;\r\n\tvar neg = stack.neg;\r\n\tvar ilen = data.length;\r\n\tvar i, value;\r\n\r\n\tfor (i = 0; i < ilen; ++i) {\r\n\t\tvalue = scale._parseValue(data[i]);\r\n\t\tif (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tpos[i] = pos[i] || 0;\r\n\t\tneg[i] = neg[i] || 0;\r\n\r\n\t\tif (opts.relativePoints) {\r\n\t\t\tpos[i] = 100;\r\n\t\t} else if (value.min < 0 || value.max < 0) {\r\n\t\t\tneg[i] += value.min;\r\n\t\t} else {\r\n\t\t\tpos[i] += value.max;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction updateMinMax(scale, meta, data) {\r\n\tvar ilen = data.length;\r\n\tvar i, value;\r\n\r\n\tfor (i = 0; i < ilen; ++i) {\r\n\t\tvalue = scale._parseValue(data[i]);\r\n\t\tif (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tscale.min = Math.min(scale.min, value.min);\r\n\t\tscale.max = Math.max(scale.max, value.max);\r\n\t}\r\n}\r\n\r\nvar scale_linear = scale_linearbase.extend({\r\n\tdetermineDataLimits: function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar chart = me.chart;\r\n\t\tvar datasets = chart.data.datasets;\r\n\t\tvar metasets = me._getMatchingVisibleMetas();\r\n\t\tvar hasStacks = opts.stacked;\r\n\t\tvar stacks = {};\r\n\t\tvar ilen = metasets.length;\r\n\t\tvar i, meta, data, values;\r\n\r\n\t\tme.min = Number.POSITIVE_INFINITY;\r\n\t\tme.max = Number.NEGATIVE_INFINITY;\r\n\r\n\t\tif (hasStacks === undefined) {\r\n\t\t\tfor (i = 0; !hasStacks && i < ilen; ++i) {\r\n\t\t\t\tmeta = metasets[i];\r\n\t\t\t\thasStacks = meta.stack !== undefined;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < ilen; ++i) {\r\n\t\t\tmeta = metasets[i];\r\n\t\t\tdata = datasets[meta.index].data;\r\n\t\t\tif (hasStacks) {\r\n\t\t\t\tstackData(me, stacks, meta, data);\r\n\t\t\t} else {\r\n\t\t\t\tupdateMinMax(me, meta, data);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thelpers$1.each(stacks, function(stackValues) {\r\n\t\t\tvalues = stackValues.pos.concat(stackValues.neg);\r\n\t\t\tme.min = Math.min(me.min, helpers$1.min(values));\r\n\t\t\tme.max = Math.max(me.max, helpers$1.max(values));\r\n\t\t});\r\n\r\n\t\tme.min = helpers$1.isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;\r\n\t\tme.max = helpers$1.isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;\r\n\r\n\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\r\n\t\tme.handleTickRangeOptions();\r\n\t},\r\n\r\n\t// Returns the maximum number of ticks based on the scale dimension\r\n\t_computeTickLimit: function() {\r\n\t\tvar me = this;\r\n\t\tvar tickFont;\r\n\r\n\t\tif (me.isHorizontal()) {\r\n\t\t\treturn Math.ceil(me.width / 40);\r\n\t\t}\r\n\t\ttickFont = helpers$1.options._parseFont(me.options.ticks);\r\n\t\treturn Math.ceil(me.height / tickFont.lineHeight);\r\n\t},\r\n\r\n\t// Called after the ticks are built. We need\r\n\thandleDirectionalChanges: function() {\r\n\t\tif (!this.isHorizontal()) {\r\n\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array\r\n\t\t\tthis.ticks.reverse();\r\n\t\t}\r\n\t},\r\n\r\n\tgetLabelForIndex: function(index, datasetIndex) {\r\n\t\treturn this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);\r\n\t},\r\n\r\n\t// Utils\r\n\tgetPixelForValue: function(value) {\r\n\t\tvar me = this;\r\n\t\treturn me.getPixelForDecimal((+me.getRightValue(value) - me._startValue) / me._valueRange);\r\n\t},\r\n\r\n\tgetValueForPixel: function(pixel) {\r\n\t\treturn this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\r\n\t},\r\n\r\n\tgetPixelForTick: function(index) {\r\n\t\tvar ticks = this.ticksAsNumbers;\r\n\t\tif (index < 0 || index > ticks.length - 1) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\treturn this.getPixelForValue(ticks[index]);\r\n\t}\r\n});\r\n\r\n// INTERNAL: static default options, registered in src/index.js\r\nvar _defaults$1 = defaultConfig$1;\nscale_linear._defaults = _defaults$1;\n\nvar valueOrDefault$b = helpers$1.valueOrDefault;\r\nvar log10 = helpers$1.math.log10;\r\n\r\n/**\r\n * Generate a set of logarithmic ticks\r\n * @param generationOptions the options used to generate the ticks\r\n * @param dataRange the range of the data\r\n * @returns {number[]} array of tick values\r\n */\r\nfunction generateTicks$1(generationOptions, dataRange) {\r\n\tvar ticks = [];\r\n\r\n\tvar tickVal = valueOrDefault$b(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));\r\n\r\n\tvar endExp = Math.floor(log10(dataRange.max));\r\n\tvar endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\r\n\tvar exp, significand;\r\n\r\n\tif (tickVal === 0) {\r\n\t\texp = Math.floor(log10(dataRange.minNotZero));\r\n\t\tsignificand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\r\n\r\n\t\tticks.push(tickVal);\r\n\t\ttickVal = significand * Math.pow(10, exp);\r\n\t} else {\r\n\t\texp = Math.floor(log10(tickVal));\r\n\t\tsignificand = Math.floor(tickVal / Math.pow(10, exp));\r\n\t}\r\n\tvar precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\r\n\r\n\tdo {\r\n\t\tticks.push(tickVal);\r\n\r\n\t\t++significand;\r\n\t\tif (significand === 10) {\r\n\t\t\tsignificand = 1;\r\n\t\t\t++exp;\r\n\t\t\tprecision = exp >= 0 ? 1 : precision;\r\n\t\t}\r\n\r\n\t\ttickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\r\n\t} while (exp < endExp || (exp === endExp && significand < endSignificand));\r\n\r\n\tvar lastTick = valueOrDefault$b(generationOptions.max, tickVal);\r\n\tticks.push(lastTick);\r\n\r\n\treturn ticks;\r\n}\r\n\r\nvar defaultConfig$2 = {\r\n\tposition: 'left',\r\n\r\n\t// label settings\r\n\tticks: {\r\n\t\tcallback: core_ticks.formatters.logarithmic\r\n\t}\r\n};\r\n\r\n// TODO(v3): change this to positiveOrDefault\r\nfunction nonNegativeOrDefault(value, defaultValue) {\r\n\treturn helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;\r\n}\r\n\r\nvar scale_logarithmic = core_scale.extend({\r\n\tdetermineDataLimits: function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar chart = me.chart;\r\n\t\tvar datasets = chart.data.datasets;\r\n\t\tvar isHorizontal = me.isHorizontal();\r\n\t\tfunction IDMatches(meta) {\r\n\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\r\n\t\t}\r\n\t\tvar datasetIndex, meta, value, data, i, ilen;\r\n\r\n\t\t// Calculate Range\r\n\t\tme.min = Number.POSITIVE_INFINITY;\r\n\t\tme.max = Number.NEGATIVE_INFINITY;\r\n\t\tme.minNotZero = Number.POSITIVE_INFINITY;\r\n\r\n\t\tvar hasStacks = opts.stacked;\r\n\t\tif (hasStacks === undefined) {\r\n\t\t\tfor (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {\r\n\t\t\t\tmeta = chart.getDatasetMeta(datasetIndex);\r\n\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\r\n\t\t\t\t\tmeta.stack !== undefined) {\r\n\t\t\t\t\thasStacks = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (opts.stacked || hasStacks) {\r\n\t\t\tvar valuesPerStack = {};\r\n\r\n\t\t\tfor (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {\r\n\t\t\t\tmeta = chart.getDatasetMeta(datasetIndex);\r\n\t\t\t\tvar key = [\r\n\t\t\t\t\tmeta.type,\r\n\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\r\n\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\r\n\t\t\t\t\tmeta.stack\r\n\t\t\t\t].join('.');\r\n\r\n\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\r\n\t\t\t\t\tif (valuesPerStack[key] === undefined) {\r\n\t\t\t\t\t\tvaluesPerStack[key] = [];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdata = datasets[datasetIndex].data;\r\n\t\t\t\t\tfor (i = 0, ilen = data.length; i < ilen; i++) {\r\n\t\t\t\t\t\tvar values = valuesPerStack[key];\r\n\t\t\t\t\t\tvalue = me._parseValue(data[i]);\r\n\t\t\t\t\t\t// invalid, hidden and negative values are ignored\r\n\t\t\t\t\t\tif (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvalues[i] = values[i] || 0;\r\n\t\t\t\t\t\tvalues[i] += value.max;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\thelpers$1.each(valuesPerStack, function(valuesForType) {\r\n\t\t\t\tif (valuesForType.length > 0) {\r\n\t\t\t\t\tvar minVal = helpers$1.min(valuesForType);\r\n\t\t\t\t\tvar maxVal = helpers$1.max(valuesForType);\r\n\t\t\t\t\tme.min = Math.min(me.min, minVal);\r\n\t\t\t\t\tme.max = Math.max(me.max, maxVal);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t} else {\r\n\t\t\tfor (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {\r\n\t\t\t\tmeta = chart.getDatasetMeta(datasetIndex);\r\n\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\r\n\t\t\t\t\tdata = datasets[datasetIndex].data;\r\n\t\t\t\t\tfor (i = 0, ilen = data.length; i < ilen; i++) {\r\n\t\t\t\t\t\tvalue = me._parseValue(data[i]);\r\n\t\t\t\t\t\t// invalid, hidden and negative values are ignored\r\n\t\t\t\t\t\tif (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tme.min = Math.min(value.min, me.min);\r\n\t\t\t\t\t\tme.max = Math.max(value.max, me.max);\r\n\r\n\t\t\t\t\t\tif (value.min !== 0) {\r\n\t\t\t\t\t\t\tme.minNotZero = Math.min(value.min, me.minNotZero);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tme.min = helpers$1.isFinite(me.min) ? me.min : null;\r\n\t\tme.max = helpers$1.isFinite(me.max) ? me.max : null;\r\n\t\tme.minNotZero = helpers$1.isFinite(me.minNotZero) ? me.minNotZero : null;\r\n\r\n\t\t// Common base implementation to handle ticks.min, ticks.max\r\n\t\tthis.handleTickRangeOptions();\r\n\t},\r\n\r\n\thandleTickRangeOptions: function() {\r\n\t\tvar me = this;\r\n\t\tvar tickOpts = me.options.ticks;\r\n\t\tvar DEFAULT_MIN = 1;\r\n\t\tvar DEFAULT_MAX = 10;\r\n\r\n\t\tme.min = nonNegativeOrDefault(tickOpts.min, me.min);\r\n\t\tme.max = nonNegativeOrDefault(tickOpts.max, me.max);\r\n\r\n\t\tif (me.min === me.max) {\r\n\t\t\tif (me.min !== 0 && me.min !== null) {\r\n\t\t\t\tme.min = Math.pow(10, Math.floor(log10(me.min)) - 1);\r\n\t\t\t\tme.max = Math.pow(10, Math.floor(log10(me.max)) + 1);\r\n\t\t\t} else {\r\n\t\t\t\tme.min = DEFAULT_MIN;\r\n\t\t\t\tme.max = DEFAULT_MAX;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (me.min === null) {\r\n\t\t\tme.min = Math.pow(10, Math.floor(log10(me.max)) - 1);\r\n\t\t}\r\n\t\tif (me.max === null) {\r\n\t\t\tme.max = me.min !== 0\r\n\t\t\t\t? Math.pow(10, Math.floor(log10(me.min)) + 1)\r\n\t\t\t\t: DEFAULT_MAX;\r\n\t\t}\r\n\t\tif (me.minNotZero === null) {\r\n\t\t\tif (me.min > 0) {\r\n\t\t\t\tme.minNotZero = me.min;\r\n\t\t\t} else if (me.max < 1) {\r\n\t\t\t\tme.minNotZero = Math.pow(10, Math.floor(log10(me.max)));\r\n\t\t\t} else {\r\n\t\t\t\tme.minNotZero = DEFAULT_MIN;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tbuildTicks: function() {\r\n\t\tvar me = this;\r\n\t\tvar tickOpts = me.options.ticks;\r\n\t\tvar reverse = !me.isHorizontal();\r\n\r\n\t\tvar generationOptions = {\r\n\t\t\tmin: nonNegativeOrDefault(tickOpts.min),\r\n\t\t\tmax: nonNegativeOrDefault(tickOpts.max)\r\n\t\t};\r\n\t\tvar ticks = me.ticks = generateTicks$1(generationOptions, me);\r\n\r\n\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\r\n\t\t// range of the scale\r\n\t\tme.max = helpers$1.max(ticks);\r\n\t\tme.min = helpers$1.min(ticks);\r\n\r\n\t\tif (tickOpts.reverse) {\r\n\t\t\treverse = !reverse;\r\n\t\t\tme.start = me.max;\r\n\t\t\tme.end = me.min;\r\n\t\t} else {\r\n\t\t\tme.start = me.min;\r\n\t\t\tme.end = me.max;\r\n\t\t}\r\n\t\tif (reverse) {\r\n\t\t\tticks.reverse();\r\n\t\t}\r\n\t},\r\n\r\n\tconvertTicksToLabels: function() {\r\n\t\tthis.tickValues = this.ticks.slice();\r\n\r\n\t\tcore_scale.prototype.convertTicksToLabels.call(this);\r\n\t},\r\n\r\n\t// Get the correct tooltip label\r\n\tgetLabelForIndex: function(index, datasetIndex) {\r\n\t\treturn this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);\r\n\t},\r\n\r\n\tgetPixelForTick: function(index) {\r\n\t\tvar ticks = this.tickValues;\r\n\t\tif (index < 0 || index > ticks.length - 1) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\treturn this.getPixelForValue(ticks[index]);\r\n\t},\r\n\r\n\t/**\r\n\t * Returns the value of the first tick.\r\n\t * @param {number} value - The minimum not zero value.\r\n\t * @return {number} The first tick value.\r\n\t * @private\r\n\t */\r\n\t_getFirstTickValue: function(value) {\r\n\t\tvar exp = Math.floor(log10(value));\r\n\t\tvar significand = Math.floor(value / Math.pow(10, exp));\r\n\r\n\t\treturn significand * Math.pow(10, exp);\r\n\t},\r\n\r\n\t_configure: function() {\r\n\t\tvar me = this;\r\n\t\tvar start = me.min;\r\n\t\tvar offset = 0;\r\n\r\n\t\tcore_scale.prototype._configure.call(me);\r\n\r\n\t\tif (start === 0) {\r\n\t\t\tstart = me._getFirstTickValue(me.minNotZero);\r\n\t\t\toffset = valueOrDefault$b(me.options.ticks.fontSize, core_defaults.global.defaultFontSize) / me._length;\r\n\t\t}\r\n\r\n\t\tme._startValue = log10(start);\r\n\t\tme._valueOffset = offset;\r\n\t\tme._valueRange = (log10(me.max) - log10(start)) / (1 - offset);\r\n\t},\r\n\r\n\tgetPixelForValue: function(value) {\r\n\t\tvar me = this;\r\n\t\tvar decimal = 0;\r\n\r\n\t\tvalue = +me.getRightValue(value);\r\n\r\n\t\tif (value > me.min && value > 0) {\r\n\t\t\tdecimal = (log10(value) - me._startValue) / me._valueRange + me._valueOffset;\r\n\t\t}\r\n\t\treturn me.getPixelForDecimal(decimal);\r\n\t},\r\n\r\n\tgetValueForPixel: function(pixel) {\r\n\t\tvar me = this;\r\n\t\tvar decimal = me.getDecimalForPixel(pixel);\r\n\t\treturn decimal === 0 && me.min === 0\r\n\t\t\t? 0\r\n\t\t\t: Math.pow(10, me._startValue + (decimal - me._valueOffset) * me._valueRange);\r\n\t}\r\n});\r\n\r\n// INTERNAL: static default options, registered in src/index.js\r\nvar _defaults$2 = defaultConfig$2;\nscale_logarithmic._defaults = _defaults$2;\n\nvar valueOrDefault$c = helpers$1.valueOrDefault;\r\nvar valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;\r\nvar resolve$4 = helpers$1.options.resolve;\r\n\r\nvar defaultConfig$3 = {\r\n\tdisplay: true,\r\n\r\n\t// Boolean - Whether to animate scaling the chart from the centre\r\n\tanimate: true,\r\n\tposition: 'chartArea',\r\n\r\n\tangleLines: {\r\n\t\tdisplay: true,\r\n\t\tcolor: 'rgba(0,0,0,0.1)',\r\n\t\tlineWidth: 1,\r\n\t\tborderDash: [],\r\n\t\tborderDashOffset: 0.0\r\n\t},\r\n\r\n\tgridLines: {\r\n\t\tcircular: false\r\n\t},\r\n\r\n\t// label settings\r\n\tticks: {\r\n\t\t// Boolean - Show a backdrop to the scale label\r\n\t\tshowLabelBackdrop: true,\r\n\r\n\t\t// String - The colour of the label backdrop\r\n\t\tbackdropColor: 'rgba(255,255,255,0.75)',\r\n\r\n\t\t// Number - The backdrop padding above & below the label in pixels\r\n\t\tbackdropPaddingY: 2,\r\n\r\n\t\t// Number - The backdrop padding to the side of the label in pixels\r\n\t\tbackdropPaddingX: 2,\r\n\r\n\t\tcallback: core_ticks.formatters.linear\r\n\t},\r\n\r\n\tpointLabels: {\r\n\t\t// Boolean - if true, show point labels\r\n\t\tdisplay: true,\r\n\r\n\t\t// Number - Point label font size in pixels\r\n\t\tfontSize: 10,\r\n\r\n\t\t// Function - Used to convert point labels\r\n\t\tcallback: function(label) {\r\n\t\t\treturn label;\r\n\t\t}\r\n\t}\r\n};\r\n\r\nfunction getTickBackdropHeight(opts) {\r\n\tvar tickOpts = opts.ticks;\r\n\r\n\tif (tickOpts.display && opts.display) {\r\n\t\treturn valueOrDefault$c(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nfunction measureLabelSize(ctx, lineHeight, label) {\r\n\tif (helpers$1.isArray(label)) {\r\n\t\treturn {\r\n\t\t\tw: helpers$1.longestText(ctx, ctx.font, label),\r\n\t\t\th: label.length * lineHeight\r\n\t\t};\r\n\t}\r\n\r\n\treturn {\r\n\t\tw: ctx.measureText(label).width,\r\n\t\th: lineHeight\r\n\t};\r\n}\r\n\r\nfunction determineLimits(angle, pos, size, min, max) {\r\n\tif (angle === min || angle === max) {\r\n\t\treturn {\r\n\t\t\tstart: pos - (size / 2),\r\n\t\t\tend: pos + (size / 2)\r\n\t\t};\r\n\t} else if (angle < min || angle > max) {\r\n\t\treturn {\r\n\t\t\tstart: pos - size,\r\n\t\t\tend: pos\r\n\t\t};\r\n\t}\r\n\r\n\treturn {\r\n\t\tstart: pos,\r\n\t\tend: pos + size\r\n\t};\r\n}\r\n\r\n/**\r\n * Helper function to fit a radial linear scale with point labels\r\n */\r\nfunction fitWithPointLabels(scale) {\r\n\r\n\t// Right, this is really confusing and there is a lot of maths going on here\r\n\t// The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\r\n\t//\r\n\t// Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\r\n\t//\r\n\t// Solution:\r\n\t//\r\n\t// We assume the radius of the polygon is half the size of the canvas at first\r\n\t// at each index we check if the text overlaps.\r\n\t//\r\n\t// Where it does, we store that angle and that index.\r\n\t//\r\n\t// After finding the largest index and angle we calculate how much we need to remove\r\n\t// from the shape radius to move the point inwards by that x.\r\n\t//\r\n\t// We average the left and right distances to get the maximum shape radius that can fit in the box\r\n\t// along with labels.\r\n\t//\r\n\t// Once we have that, we can find the centre point for the chart, by taking the x text protrusion\r\n\t// on each side, removing that from the size, halving it and adding the left x protrusion width.\r\n\t//\r\n\t// This will mean we have a shape fitted to the canvas, as large as it can be with the labels\r\n\t// and position it in the most space efficient manner\r\n\t//\r\n\t// https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\r\n\r\n\tvar plFont = helpers$1.options._parseFont(scale.options.pointLabels);\r\n\r\n\t// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\r\n\t// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\r\n\tvar furthestLimits = {\r\n\t\tl: 0,\r\n\t\tr: scale.width,\r\n\t\tt: 0,\r\n\t\tb: scale.height - scale.paddingTop\r\n\t};\r\n\tvar furthestAngles = {};\r\n\tvar i, textSize, pointPosition;\r\n\r\n\tscale.ctx.font = plFont.string;\r\n\tscale._pointLabelSizes = [];\r\n\r\n\tvar valueCount = scale.chart.data.labels.length;\r\n\tfor (i = 0; i < valueCount; i++) {\r\n\t\tpointPosition = scale.getPointPosition(i, scale.drawingArea + 5);\r\n\t\ttextSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i]);\r\n\t\tscale._pointLabelSizes[i] = textSize;\r\n\r\n\t\t// Add quarter circle to make degree 0 mean top of circle\r\n\t\tvar angleRadians = scale.getIndexAngle(i);\r\n\t\tvar angle = helpers$1.toDegrees(angleRadians) % 360;\r\n\t\tvar hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\r\n\t\tvar vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\r\n\r\n\t\tif (hLimits.start < furthestLimits.l) {\r\n\t\t\tfurthestLimits.l = hLimits.start;\r\n\t\t\tfurthestAngles.l = angleRadians;\r\n\t\t}\r\n\r\n\t\tif (hLimits.end > furthestLimits.r) {\r\n\t\t\tfurthestLimits.r = hLimits.end;\r\n\t\t\tfurthestAngles.r = angleRadians;\r\n\t\t}\r\n\r\n\t\tif (vLimits.start < furthestLimits.t) {\r\n\t\t\tfurthestLimits.t = vLimits.start;\r\n\t\t\tfurthestAngles.t = angleRadians;\r\n\t\t}\r\n\r\n\t\tif (vLimits.end > furthestLimits.b) {\r\n\t\t\tfurthestLimits.b = vLimits.end;\r\n\t\t\tfurthestAngles.b = angleRadians;\r\n\t\t}\r\n\t}\r\n\r\n\tscale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);\r\n}\r\n\r\nfunction getTextAlignForAngle(angle) {\r\n\tif (angle === 0 || angle === 180) {\r\n\t\treturn 'center';\r\n\t} else if (angle < 180) {\r\n\t\treturn 'left';\r\n\t}\r\n\r\n\treturn 'right';\r\n}\r\n\r\nfunction fillText(ctx, text, position, lineHeight) {\r\n\tvar y = position.y + lineHeight / 2;\r\n\tvar i, ilen;\r\n\r\n\tif (helpers$1.isArray(text)) {\r\n\t\tfor (i = 0, ilen = text.length; i < ilen; ++i) {\r\n\t\t\tctx.fillText(text[i], position.x, y);\r\n\t\t\ty += lineHeight;\r\n\t\t}\r\n\t} else {\r\n\t\tctx.fillText(text, position.x, y);\r\n\t}\r\n}\r\n\r\nfunction adjustPointPositionForLabelHeight(angle, textSize, position) {\r\n\tif (angle === 90 || angle === 270) {\r\n\t\tposition.y -= (textSize.h / 2);\r\n\t} else if (angle > 270 || angle < 90) {\r\n\t\tposition.y -= textSize.h;\r\n\t}\r\n}\r\n\r\nfunction drawPointLabels(scale) {\r\n\tvar ctx = scale.ctx;\r\n\tvar opts = scale.options;\r\n\tvar pointLabelOpts = opts.pointLabels;\r\n\tvar tickBackdropHeight = getTickBackdropHeight(opts);\r\n\tvar outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\r\n\tvar plFont = helpers$1.options._parseFont(pointLabelOpts);\r\n\r\n\tctx.save();\r\n\r\n\tctx.font = plFont.string;\r\n\tctx.textBaseline = 'middle';\r\n\r\n\tfor (var i = scale.chart.data.labels.length - 1; i >= 0; i--) {\r\n\t\t// Extra pixels out for some label spacing\r\n\t\tvar extra = (i === 0 ? tickBackdropHeight / 2 : 0);\r\n\t\tvar pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5);\r\n\r\n\t\t// Keep this in loop since we may support array properties here\r\n\t\tvar pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);\r\n\t\tctx.fillStyle = pointLabelFontColor;\r\n\r\n\t\tvar angleRadians = scale.getIndexAngle(i);\r\n\t\tvar angle = helpers$1.toDegrees(angleRadians);\r\n\t\tctx.textAlign = getTextAlignForAngle(angle);\r\n\t\tadjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\r\n\t\tfillText(ctx, scale.pointLabels[i], pointLabelPosition, plFont.lineHeight);\r\n\t}\r\n\tctx.restore();\r\n}\r\n\r\nfunction drawRadiusLine(scale, gridLineOpts, radius, index) {\r\n\tvar ctx = scale.ctx;\r\n\tvar circular = gridLineOpts.circular;\r\n\tvar valueCount = scale.chart.data.labels.length;\r\n\tvar lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);\r\n\tvar lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);\r\n\tvar pointPosition;\r\n\r\n\tif ((!circular && !valueCount) || !lineColor || !lineWidth) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tctx.save();\r\n\tctx.strokeStyle = lineColor;\r\n\tctx.lineWidth = lineWidth;\r\n\tif (ctx.setLineDash) {\r\n\t\tctx.setLineDash(gridLineOpts.borderDash || []);\r\n\t\tctx.lineDashOffset = gridLineOpts.borderDashOffset || 0.0;\r\n\t}\r\n\r\n\tctx.beginPath();\r\n\tif (circular) {\r\n\t\t// Draw circular arcs between the points\r\n\t\tctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\r\n\t} else {\r\n\t\t// Draw straight lines connecting each index\r\n\t\tpointPosition = scale.getPointPosition(0, radius);\r\n\t\tctx.moveTo(pointPosition.x, pointPosition.y);\r\n\r\n\t\tfor (var i = 1; i < valueCount; i++) {\r\n\t\t\tpointPosition = scale.getPointPosition(i, radius);\r\n\t\t\tctx.lineTo(pointPosition.x, pointPosition.y);\r\n\t\t}\r\n\t}\r\n\tctx.closePath();\r\n\tctx.stroke();\r\n\tctx.restore();\r\n}\r\n\r\nfunction numberOrZero(param) {\r\n\treturn helpers$1.isNumber(param) ? param : 0;\r\n}\r\n\r\nvar scale_radialLinear = scale_linearbase.extend({\r\n\tsetDimensions: function() {\r\n\t\tvar me = this;\r\n\r\n\t\t// Set the unconstrained dimension before label rotation\r\n\t\tme.width = me.maxWidth;\r\n\t\tme.height = me.maxHeight;\r\n\t\tme.paddingTop = getTickBackdropHeight(me.options) / 2;\r\n\t\tme.xCenter = Math.floor(me.width / 2);\r\n\t\tme.yCenter = Math.floor((me.height - me.paddingTop) / 2);\r\n\t\tme.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;\r\n\t},\r\n\r\n\tdetermineDataLimits: function() {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar min = Number.POSITIVE_INFINITY;\r\n\t\tvar max = Number.NEGATIVE_INFINITY;\r\n\r\n\t\thelpers$1.each(chart.data.datasets, function(dataset, datasetIndex) {\r\n\t\t\tif (chart.isDatasetVisible(datasetIndex)) {\r\n\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\r\n\r\n\t\t\t\thelpers$1.each(dataset.data, function(rawValue, index) {\r\n\t\t\t\t\tvar value = +me.getRightValue(rawValue);\r\n\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmin = Math.min(value, min);\r\n\t\t\t\t\tmax = Math.max(value, max);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tme.min = (min === Number.POSITIVE_INFINITY ? 0 : min);\r\n\t\tme.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);\r\n\r\n\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\r\n\t\tme.handleTickRangeOptions();\r\n\t},\r\n\r\n\t// Returns the maximum number of ticks based on the scale dimension\r\n\t_computeTickLimit: function() {\r\n\t\treturn Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\r\n\t},\r\n\r\n\tconvertTicksToLabels: function() {\r\n\t\tvar me = this;\r\n\r\n\t\tscale_linearbase.prototype.convertTicksToLabels.call(me);\r\n\r\n\t\t// Point labels\r\n\t\tme.pointLabels = me.chart.data.labels.map(function() {\r\n\t\t\tvar label = helpers$1.callback(me.options.pointLabels.callback, arguments, me);\r\n\t\t\treturn label || label === 0 ? label : '';\r\n\t\t});\r\n\t},\r\n\r\n\tgetLabelForIndex: function(index, datasetIndex) {\r\n\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\r\n\t},\r\n\r\n\tfit: function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me.options;\r\n\r\n\t\tif (opts.display && opts.pointLabels.display) {\r\n\t\t\tfitWithPointLabels(me);\r\n\t\t} else {\r\n\t\t\tme.setCenterPoint(0, 0, 0, 0);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Set radius reductions and determine new radius and center point\r\n\t * @private\r\n\t */\r\n\tsetReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {\r\n\t\tvar me = this;\r\n\t\tvar radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\r\n\t\tvar radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\r\n\t\tvar radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\r\n\t\tvar radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);\r\n\r\n\t\tradiusReductionLeft = numberOrZero(radiusReductionLeft);\r\n\t\tradiusReductionRight = numberOrZero(radiusReductionRight);\r\n\t\tradiusReductionTop = numberOrZero(radiusReductionTop);\r\n\t\tradiusReductionBottom = numberOrZero(radiusReductionBottom);\r\n\r\n\t\tme.drawingArea = Math.min(\r\n\t\t\tMath.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\r\n\t\t\tMath.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\r\n\t\tme.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\r\n\t},\r\n\r\n\tsetCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {\r\n\t\tvar me = this;\r\n\t\tvar maxRight = me.width - rightMovement - me.drawingArea;\r\n\t\tvar maxLeft = leftMovement + me.drawingArea;\r\n\t\tvar maxTop = topMovement + me.drawingArea;\r\n\t\tvar maxBottom = (me.height - me.paddingTop) - bottomMovement - me.drawingArea;\r\n\r\n\t\tme.xCenter = Math.floor(((maxLeft + maxRight) / 2) + me.left);\r\n\t\tme.yCenter = Math.floor(((maxTop + maxBottom) / 2) + me.top + me.paddingTop);\r\n\t},\r\n\r\n\tgetIndexAngle: function(index) {\r\n\t\tvar chart = this.chart;\r\n\t\tvar angleMultiplier = 360 / chart.data.labels.length;\r\n\t\tvar options = chart.options || {};\r\n\t\tvar startAngle = options.startAngle || 0;\r\n\r\n\t\t// Start from the top instead of right, so remove a quarter of the circle\r\n\t\tvar angle = (index * angleMultiplier + startAngle) % 360;\r\n\r\n\t\treturn (angle < 0 ? angle + 360 : angle) * Math.PI * 2 / 360;\r\n\t},\r\n\r\n\tgetDistanceFromCenterForValue: function(value) {\r\n\t\tvar me = this;\r\n\r\n\t\tif (helpers$1.isNullOrUndef(value)) {\r\n\t\t\treturn NaN;\r\n\t\t}\r\n\r\n\t\t// Take into account half font size + the yPadding of the top value\r\n\t\tvar scalingFactor = me.drawingArea / (me.max - me.min);\r\n\t\tif (me.options.ticks.reverse) {\r\n\t\t\treturn (me.max - value) * scalingFactor;\r\n\t\t}\r\n\t\treturn (value - me.min) * scalingFactor;\r\n\t},\r\n\r\n\tgetPointPosition: function(index, distanceFromCenter) {\r\n\t\tvar me = this;\r\n\t\tvar thisAngle = me.getIndexAngle(index) - (Math.PI / 2);\r\n\t\treturn {\r\n\t\t\tx: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,\r\n\t\t\ty: Math.sin(thisAngle) * distanceFromCenter + me.yCenter\r\n\t\t};\r\n\t},\r\n\r\n\tgetPointPositionForValue: function(index, value) {\r\n\t\treturn this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\r\n\t},\r\n\r\n\tgetBasePosition: function(index) {\r\n\t\tvar me = this;\r\n\t\tvar min = me.min;\r\n\t\tvar max = me.max;\r\n\r\n\t\treturn me.getPointPositionForValue(index || 0,\r\n\t\t\tme.beginAtZero ? 0 :\r\n\t\t\tmin < 0 && max < 0 ? max :\r\n\t\t\tmin > 0 && max > 0 ? min :\r\n\t\t\t0);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_drawGrid: function() {\r\n\t\tvar me = this;\r\n\t\tvar ctx = me.ctx;\r\n\t\tvar opts = me.options;\r\n\t\tvar gridLineOpts = opts.gridLines;\r\n\t\tvar angleLineOpts = opts.angleLines;\r\n\t\tvar lineWidth = valueOrDefault$c(angleLineOpts.lineWidth, gridLineOpts.lineWidth);\r\n\t\tvar lineColor = valueOrDefault$c(angleLineOpts.color, gridLineOpts.color);\r\n\t\tvar i, offset, position;\r\n\r\n\t\tif (opts.pointLabels.display) {\r\n\t\t\tdrawPointLabels(me);\r\n\t\t}\r\n\r\n\t\tif (gridLineOpts.display) {\r\n\t\t\thelpers$1.each(me.ticks, function(label, index) {\r\n\t\t\t\tif (index !== 0) {\r\n\t\t\t\t\toffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\r\n\t\t\t\t\tdrawRadiusLine(me, gridLineOpts, offset, index);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif (angleLineOpts.display && lineWidth && lineColor) {\r\n\t\t\tctx.save();\r\n\t\t\tctx.lineWidth = lineWidth;\r\n\t\t\tctx.strokeStyle = lineColor;\r\n\t\t\tif (ctx.setLineDash) {\r\n\t\t\t\tctx.setLineDash(resolve$4([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));\r\n\t\t\t\tctx.lineDashOffset = resolve$4([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0.0]);\r\n\t\t\t}\r\n\r\n\t\t\tfor (i = me.chart.data.labels.length - 1; i >= 0; i--) {\r\n\t\t\t\toffset = me.getDistanceFromCenterForValue(opts.ticks.reverse ? me.min : me.max);\r\n\t\t\t\tposition = me.getPointPosition(i, offset);\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.moveTo(me.xCenter, me.yCenter);\r\n\t\t\t\tctx.lineTo(position.x, position.y);\r\n\t\t\t\tctx.stroke();\r\n\t\t\t}\r\n\r\n\t\t\tctx.restore();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_drawLabels: function() {\r\n\t\tvar me = this;\r\n\t\tvar ctx = me.ctx;\r\n\t\tvar opts = me.options;\r\n\t\tvar tickOpts = opts.ticks;\r\n\r\n\t\tif (!tickOpts.display) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar startAngle = me.getIndexAngle(0);\r\n\t\tvar tickFont = helpers$1.options._parseFont(tickOpts);\r\n\t\tvar tickFontColor = valueOrDefault$c(tickOpts.fontColor, core_defaults.global.defaultFontColor);\r\n\t\tvar offset, width;\r\n\r\n\t\tctx.save();\r\n\t\tctx.font = tickFont.string;\r\n\t\tctx.translate(me.xCenter, me.yCenter);\r\n\t\tctx.rotate(startAngle);\r\n\t\tctx.textAlign = 'center';\r\n\t\tctx.textBaseline = 'middle';\r\n\r\n\t\thelpers$1.each(me.ticks, function(label, index) {\r\n\t\t\tif (index === 0 && !tickOpts.reverse) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\toffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\r\n\r\n\t\t\tif (tickOpts.showLabelBackdrop) {\r\n\t\t\t\twidth = ctx.measureText(label).width;\r\n\t\t\t\tctx.fillStyle = tickOpts.backdropColor;\r\n\r\n\t\t\t\tctx.fillRect(\r\n\t\t\t\t\t-width / 2 - tickOpts.backdropPaddingX,\r\n\t\t\t\t\t-offset - tickFont.size / 2 - tickOpts.backdropPaddingY,\r\n\t\t\t\t\twidth + tickOpts.backdropPaddingX * 2,\r\n\t\t\t\t\ttickFont.size + tickOpts.backdropPaddingY * 2\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\tctx.fillStyle = tickFontColor;\r\n\t\t\tctx.fillText(label, 0, -offset);\r\n\t\t});\r\n\r\n\t\tctx.restore();\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_drawTitle: helpers$1.noop\r\n});\r\n\r\n// INTERNAL: static default options, registered in src/index.js\r\nvar _defaults$3 = defaultConfig$3;\nscale_radialLinear._defaults = _defaults$3;\n\nvar deprecated$1 = helpers$1._deprecated;\r\nvar resolve$5 = helpers$1.options.resolve;\r\nvar valueOrDefault$d = helpers$1.valueOrDefault;\r\n\r\n// Integer constants are from the ES6 spec.\r\nvar MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;\r\nvar MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\r\n\r\nvar INTERVALS = {\r\n\tmillisecond: {\r\n\t\tcommon: true,\r\n\t\tsize: 1,\r\n\t\tsteps: 1000\r\n\t},\r\n\tsecond: {\r\n\t\tcommon: true,\r\n\t\tsize: 1000,\r\n\t\tsteps: 60\r\n\t},\r\n\tminute: {\r\n\t\tcommon: true,\r\n\t\tsize: 60000,\r\n\t\tsteps: 60\r\n\t},\r\n\thour: {\r\n\t\tcommon: true,\r\n\t\tsize: 3600000,\r\n\t\tsteps: 24\r\n\t},\r\n\tday: {\r\n\t\tcommon: true,\r\n\t\tsize: 86400000,\r\n\t\tsteps: 30\r\n\t},\r\n\tweek: {\r\n\t\tcommon: false,\r\n\t\tsize: 604800000,\r\n\t\tsteps: 4\r\n\t},\r\n\tmonth: {\r\n\t\tcommon: true,\r\n\t\tsize: 2.628e9,\r\n\t\tsteps: 12\r\n\t},\r\n\tquarter: {\r\n\t\tcommon: false,\r\n\t\tsize: 7.884e9,\r\n\t\tsteps: 4\r\n\t},\r\n\tyear: {\r\n\t\tcommon: true,\r\n\t\tsize: 3.154e10\r\n\t}\r\n};\r\n\r\nvar UNITS = Object.keys(INTERVALS);\r\n\r\nfunction sorter(a, b) {\r\n\treturn a - b;\r\n}\r\n\r\nfunction arrayUnique(items) {\r\n\tvar hash = {};\r\n\tvar out = [];\r\n\tvar i, ilen, item;\r\n\r\n\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\r\n\t\titem = items[i];\r\n\t\tif (!hash[item]) {\r\n\t\t\thash[item] = true;\r\n\t\t\tout.push(item);\r\n\t\t}\r\n\t}\r\n\r\n\treturn out;\r\n}\r\n\r\nfunction getMin(options) {\r\n\treturn helpers$1.valueOrDefault(options.time.min, options.ticks.min);\r\n}\r\n\r\nfunction getMax(options) {\r\n\treturn helpers$1.valueOrDefault(options.time.max, options.ticks.max);\r\n}\r\n\r\n/**\r\n * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\r\n * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\r\n * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\r\n * extremity (left + width or top + height). Note that it would be more optimized to directly\r\n * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\r\n * to create the lookup table. The table ALWAYS contains at least two items: min and max.\r\n *\r\n * @param {number[]} timestamps - timestamps sorted from lowest to highest.\r\n * @param {string} distribution - If 'linear', timestamps will be spread linearly along the min\r\n * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.\r\n * If 'series', timestamps will be positioned at the same distance from each other. In this\r\n * case, only timestamps that break the time linearity are registered, meaning that in the\r\n * best case, all timestamps are linear, the table contains only min and max.\r\n */\r\nfunction buildLookupTable(timestamps, min, max, distribution) {\r\n\tif (distribution === 'linear' || !timestamps.length) {\r\n\t\treturn [\r\n\t\t\t{time: min, pos: 0},\r\n\t\t\t{time: max, pos: 1}\r\n\t\t];\r\n\t}\r\n\r\n\tvar table = [];\r\n\tvar items = [min];\r\n\tvar i, ilen, prev, curr, next;\r\n\r\n\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\r\n\t\tcurr = timestamps[i];\r\n\t\tif (curr > min && curr < max) {\r\n\t\t\titems.push(curr);\r\n\t\t}\r\n\t}\r\n\r\n\titems.push(max);\r\n\r\n\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\r\n\t\tnext = items[i + 1];\r\n\t\tprev = items[i - 1];\r\n\t\tcurr = items[i];\r\n\r\n\t\t// only add points that breaks the scale linearity\r\n\t\tif (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {\r\n\t\t\ttable.push({time: curr, pos: i / (ilen - 1)});\r\n\t\t}\r\n\t}\r\n\r\n\treturn table;\r\n}\r\n\r\n// @see adapted from https://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/\r\nfunction lookup(table, key, value) {\r\n\tvar lo = 0;\r\n\tvar hi = table.length - 1;\r\n\tvar mid, i0, i1;\r\n\r\n\twhile (lo >= 0 && lo <= hi) {\r\n\t\tmid = (lo + hi) >> 1;\r\n\t\ti0 = table[mid - 1] || null;\r\n\t\ti1 = table[mid];\r\n\r\n\t\tif (!i0) {\r\n\t\t\t// given value is outside table (before first item)\r\n\t\t\treturn {lo: null, hi: i1};\r\n\t\t} else if (i1[key] < value) {\r\n\t\t\tlo = mid + 1;\r\n\t\t} else if (i0[key] > value) {\r\n\t\t\thi = mid - 1;\r\n\t\t} else {\r\n\t\t\treturn {lo: i0, hi: i1};\r\n\t\t}\r\n\t}\r\n\r\n\t// given value is outside table (after last item)\r\n\treturn {lo: i1, hi: null};\r\n}\r\n\r\n/**\r\n * Linearly interpolates the given source `value` using the table items `skey` values and\r\n * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')\r\n * returns the position for a timestamp equal to 42. If value is out of bounds, values at\r\n * index [0, 1] or [n - 1, n] are used for the interpolation.\r\n */\r\nfunction interpolate$1(table, skey, sval, tkey) {\r\n\tvar range = lookup(table, skey, sval);\r\n\r\n\t// Note: the lookup table ALWAYS contains at least 2 items (min and max)\r\n\tvar prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;\r\n\tvar next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;\r\n\r\n\tvar span = next[skey] - prev[skey];\r\n\tvar ratio = span ? (sval - prev[skey]) / span : 0;\r\n\tvar offset = (next[tkey] - prev[tkey]) * ratio;\r\n\r\n\treturn prev[tkey] + offset;\r\n}\r\n\r\nfunction toTimestamp(scale, input) {\r\n\tvar adapter = scale._adapter;\r\n\tvar options = scale.options.time;\r\n\tvar parser = options.parser;\r\n\tvar format = parser || options.format;\r\n\tvar value = input;\r\n\r\n\tif (typeof parser === 'function') {\r\n\t\tvalue = parser(value);\r\n\t}\r\n\r\n\t// Only parse if its not a timestamp already\r\n\tif (!helpers$1.isFinite(value)) {\r\n\t\tvalue = typeof format === 'string'\r\n\t\t\t? adapter.parse(value, format)\r\n\t\t\t: adapter.parse(value);\r\n\t}\r\n\r\n\tif (value !== null) {\r\n\t\treturn +value;\r\n\t}\r\n\r\n\t// Labels are in an incompatible format and no `parser` has been provided.\r\n\t// The user might still use the deprecated `format` option for parsing.\r\n\tif (!parser && typeof format === 'function') {\r\n\t\tvalue = format(input);\r\n\r\n\t\t// `format` could return something else than a timestamp, if so, parse it\r\n\t\tif (!helpers$1.isFinite(value)) {\r\n\t\t\tvalue = adapter.parse(value);\r\n\t\t}\r\n\t}\r\n\r\n\treturn value;\r\n}\r\n\r\nfunction parse(scale, input) {\r\n\tif (helpers$1.isNullOrUndef(input)) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tvar options = scale.options.time;\r\n\tvar value = toTimestamp(scale, scale.getRightValue(input));\r\n\tif (value === null) {\r\n\t\treturn value;\r\n\t}\r\n\r\n\tif (options.round) {\r\n\t\tvalue = +scale._adapter.startOf(value, options.round);\r\n\t}\r\n\r\n\treturn value;\r\n}\r\n\r\n/**\r\n * Figures out what unit results in an appropriate number of auto-generated ticks\r\n */\r\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\r\n\tvar ilen = UNITS.length;\r\n\tvar i, interval, factor;\r\n\r\n\tfor (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\r\n\t\tinterval = INTERVALS[UNITS[i]];\r\n\t\tfactor = interval.steps ? interval.steps : MAX_INTEGER;\r\n\r\n\t\tif (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\r\n\t\t\treturn UNITS[i];\r\n\t\t}\r\n\t}\r\n\r\n\treturn UNITS[ilen - 1];\r\n}\r\n\r\n/**\r\n * Figures out what unit to format a set of ticks with\r\n */\r\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\r\n\tvar i, unit;\r\n\r\n\tfor (i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\r\n\t\tunit = UNITS[i];\r\n\t\tif (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\r\n\t\t\treturn unit;\r\n\t\t}\r\n\t}\r\n\r\n\treturn UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\r\n}\r\n\r\nfunction determineMajorUnit(unit) {\r\n\tfor (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\r\n\t\tif (INTERVALS[UNITS[i]].common) {\r\n\t\t\treturn UNITS[i];\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Generates a maximum of `capacity` timestamps between min and max, rounded to the\r\n * `minor` unit using the given scale time `options`.\r\n * Important: this method can return ticks outside the min and max range, it's the\r\n * responsibility of the calling code to clamp values if needed.\r\n */\r\nfunction generate(scale, min, max, capacity) {\r\n\tvar adapter = scale._adapter;\r\n\tvar options = scale.options;\r\n\tvar timeOpts = options.time;\r\n\tvar minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\r\n\tvar stepSize = resolve$5([timeOpts.stepSize, timeOpts.unitStepSize, 1]);\r\n\tvar weekday = minor === 'week' ? timeOpts.isoWeekday : false;\r\n\tvar first = min;\r\n\tvar ticks = [];\r\n\tvar time;\r\n\r\n\t// For 'week' unit, handle the first day of week option\r\n\tif (weekday) {\r\n\t\tfirst = +adapter.startOf(first, 'isoWeek', weekday);\r\n\t}\r\n\r\n\t// Align first ticks on unit\r\n\tfirst = +adapter.startOf(first, weekday ? 'day' : minor);\r\n\r\n\t// Prevent browser from freezing in case user options request millions of milliseconds\r\n\tif (adapter.diff(max, min, minor) > 100000 * stepSize) {\r\n\t\tthrow min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor;\r\n\t}\r\n\r\n\tfor (time = first; time < max; time = +adapter.add(time, stepSize, minor)) {\r\n\t\tticks.push(time);\r\n\t}\r\n\r\n\tif (time === max || options.bounds === 'ticks') {\r\n\t\tticks.push(time);\r\n\t}\r\n\r\n\treturn ticks;\r\n}\r\n\r\n/**\r\n * Returns the start and end offsets from edges in the form of {start, end}\r\n * where each value is a relative width to the scale and ranges between 0 and 1.\r\n * They add extra margins on the both sides by scaling down the original scale.\r\n * Offsets are added when the `offset` option is true.\r\n */\r\nfunction computeOffsets(table, ticks, min, max, options) {\r\n\tvar start = 0;\r\n\tvar end = 0;\r\n\tvar first, last;\r\n\r\n\tif (options.offset && ticks.length) {\r\n\t\tfirst = interpolate$1(table, 'time', ticks[0], 'pos');\r\n\t\tif (ticks.length === 1) {\r\n\t\t\tstart = 1 - first;\r\n\t\t} else {\r\n\t\t\tstart = (interpolate$1(table, 'time', ticks[1], 'pos') - first) / 2;\r\n\t\t}\r\n\t\tlast = interpolate$1(table, 'time', ticks[ticks.length - 1], 'pos');\r\n\t\tif (ticks.length === 1) {\r\n\t\t\tend = last;\r\n\t\t} else {\r\n\t\t\tend = (last - interpolate$1(table, 'time', ticks[ticks.length - 2], 'pos')) / 2;\r\n\t\t}\r\n\t}\r\n\r\n\treturn {start: start, end: end, factor: 1 / (start + 1 + end)};\r\n}\r\n\r\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\r\n\tvar adapter = scale._adapter;\r\n\tvar first = +adapter.startOf(ticks[0].value, majorUnit);\r\n\tvar last = ticks[ticks.length - 1].value;\r\n\tvar major, index;\r\n\r\n\tfor (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\r\n\t\tindex = map[major];\r\n\t\tif (index >= 0) {\r\n\t\t\tticks[index].major = true;\r\n\t\t}\r\n\t}\r\n\treturn ticks;\r\n}\r\n\r\nfunction ticksFromTimestamps(scale, values, majorUnit) {\r\n\tvar ticks = [];\r\n\tvar map = {};\r\n\tvar ilen = values.length;\r\n\tvar i, value;\r\n\r\n\tfor (i = 0; i < ilen; ++i) {\r\n\t\tvalue = values[i];\r\n\t\tmap[value] = i;\r\n\r\n\t\tticks.push({\r\n\t\t\tvalue: value,\r\n\t\t\tmajor: false\r\n\t\t});\r\n\t}\r\n\r\n\t// We set the major ticks separately from the above loop because calling startOf for every tick\r\n\t// is expensive when there is a large number of ticks\r\n\treturn (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\r\n}\r\n\r\nvar defaultConfig$4 = {\r\n\tposition: 'bottom',\r\n\r\n\t/**\r\n\t * Data distribution along the scale:\r\n\t * - 'linear': data are spread according to their time (distances can vary),\r\n\t * - 'series': data are spread at the same distance from each other.\r\n\t * @see https://github.com/chartjs/Chart.js/pull/4507\r\n\t * @since 2.7.0\r\n\t */\r\n\tdistribution: 'linear',\r\n\r\n\t/**\r\n\t * Scale boundary strategy (bypassed by min/max time options)\r\n\t * - `data`: make sure data are fully visible, ticks outside are removed\r\n\t * - `ticks`: make sure ticks are fully visible, data outside are truncated\r\n\t * @see https://github.com/chartjs/Chart.js/pull/4556\r\n\t * @since 2.7.0\r\n\t */\r\n\tbounds: 'data',\r\n\r\n\tadapters: {},\r\n\ttime: {\r\n\t\tparser: false, // false == a pattern string from https://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\r\n\t\tunit: false, // false == automatic or override with week, month, year, etc.\r\n\t\tround: false, // none, or override with week, month, year, etc.\r\n\t\tdisplayFormat: false, // DEPRECATED\r\n\t\tisoWeekday: false, // override week start day - see https://momentjs.com/docs/#/get-set/iso-weekday/\r\n\t\tminUnit: 'millisecond',\r\n\t\tdisplayFormats: {}\r\n\t},\r\n\tticks: {\r\n\t\tautoSkip: false,\r\n\r\n\t\t/**\r\n\t\t * Ticks generation input values:\r\n\t\t * - 'auto': generates \"optimal\" ticks based on scale size and time options.\r\n\t\t * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\r\n\t\t * - 'labels': generates ticks from user given `data.labels` values ONLY.\r\n\t\t * @see https://github.com/chartjs/Chart.js/pull/4507\r\n\t\t * @since 2.7.0\r\n\t\t */\r\n\t\tsource: 'auto',\r\n\r\n\t\tmajor: {\r\n\t\t\tenabled: false\r\n\t\t}\r\n\t}\r\n};\r\n\r\nvar scale_time = core_scale.extend({\r\n\tinitialize: function() {\r\n\t\tthis.mergeTicksOptions();\r\n\t\tcore_scale.prototype.initialize.call(this);\r\n\t},\r\n\r\n\tupdate: function() {\r\n\t\tvar me = this;\r\n\t\tvar options = me.options;\r\n\t\tvar time = options.time || (options.time = {});\r\n\t\tvar adapter = me._adapter = new core_adapters._date(options.adapters.date);\r\n\r\n\t\t// DEPRECATIONS: output a message only one time per update\r\n\t\tdeprecated$1('time scale', time.format, 'time.format', 'time.parser');\r\n\t\tdeprecated$1('time scale', time.min, 'time.min', 'ticks.min');\r\n\t\tdeprecated$1('time scale', time.max, 'time.max', 'ticks.max');\r\n\r\n\t\t// Backward compatibility: before introducing adapter, `displayFormats` was\r\n\t\t// supposed to contain *all* unit/string pairs but this can't be resolved\r\n\t\t// when loading the scale (adapters are loaded afterward), so let's populate\r\n\t\t// missing formats on update\r\n\t\thelpers$1.mergeIf(time.displayFormats, adapter.formats());\r\n\r\n\t\treturn core_scale.prototype.update.apply(me, arguments);\r\n\t},\r\n\r\n\t/**\r\n\t * Allows data to be referenced via 't' attribute\r\n\t */\r\n\tgetRightValue: function(rawValue) {\r\n\t\tif (rawValue && rawValue.t !== undefined) {\r\n\t\t\trawValue = rawValue.t;\r\n\t\t}\r\n\t\treturn core_scale.prototype.getRightValue.call(this, rawValue);\r\n\t},\r\n\r\n\tdetermineDataLimits: function() {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar adapter = me._adapter;\r\n\t\tvar options = me.options;\r\n\t\tvar unit = options.time.unit || 'day';\r\n\t\tvar min = MAX_INTEGER;\r\n\t\tvar max = MIN_INTEGER;\r\n\t\tvar timestamps = [];\r\n\t\tvar datasets = [];\r\n\t\tvar labels = [];\r\n\t\tvar i, j, ilen, jlen, data, timestamp, labelsAdded;\r\n\t\tvar dataLabels = me._getLabels();\r\n\r\n\t\tfor (i = 0, ilen = dataLabels.length; i < ilen; ++i) {\r\n\t\t\tlabels.push(parse(me, dataLabels[i]));\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\r\n\t\t\tif (chart.isDatasetVisible(i)) {\r\n\t\t\t\tdata = chart.data.datasets[i].data;\r\n\r\n\t\t\t\t// Let's consider that all data have the same format.\r\n\t\t\t\tif (helpers$1.isObject(data[0])) {\r\n\t\t\t\t\tdatasets[i] = [];\r\n\r\n\t\t\t\t\tfor (j = 0, jlen = data.length; j < jlen; ++j) {\r\n\t\t\t\t\t\ttimestamp = parse(me, data[j]);\r\n\t\t\t\t\t\ttimestamps.push(timestamp);\r\n\t\t\t\t\t\tdatasets[i][j] = timestamp;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdatasets[i] = labels.slice(0);\r\n\t\t\t\t\tif (!labelsAdded) {\r\n\t\t\t\t\t\ttimestamps = timestamps.concat(labels);\r\n\t\t\t\t\t\tlabelsAdded = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tdatasets[i] = [];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (labels.length) {\r\n\t\t\tmin = Math.min(min, labels[0]);\r\n\t\t\tmax = Math.max(max, labels[labels.length - 1]);\r\n\t\t}\r\n\r\n\t\tif (timestamps.length) {\r\n\t\t\ttimestamps = ilen > 1 ? arrayUnique(timestamps).sort(sorter) : timestamps.sort(sorter);\r\n\t\t\tmin = Math.min(min, timestamps[0]);\r\n\t\t\tmax = Math.max(max, timestamps[timestamps.length - 1]);\r\n\t\t}\r\n\r\n\t\tmin = parse(me, getMin(options)) || min;\r\n\t\tmax = parse(me, getMax(options)) || max;\r\n\r\n\t\t// In case there is no valid min/max, set limits based on unit time option\r\n\t\tmin = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min;\r\n\t\tmax = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max;\r\n\r\n\t\t// Make sure that max is strictly higher than min (required by the lookup table)\r\n\t\tme.min = Math.min(min, max);\r\n\t\tme.max = Math.max(min + 1, max);\r\n\r\n\t\t// PRIVATE\r\n\t\tme._table = [];\r\n\t\tme._timestamps = {\r\n\t\t\tdata: timestamps,\r\n\t\t\tdatasets: datasets,\r\n\t\t\tlabels: labels\r\n\t\t};\r\n\t},\r\n\r\n\tbuildTicks: function() {\r\n\t\tvar me = this;\r\n\t\tvar min = me.min;\r\n\t\tvar max = me.max;\r\n\t\tvar options = me.options;\r\n\t\tvar tickOpts = options.ticks;\r\n\t\tvar timeOpts = options.time;\r\n\t\tvar timestamps = me._timestamps;\r\n\t\tvar ticks = [];\r\n\t\tvar capacity = me.getLabelCapacity(min);\r\n\t\tvar source = tickOpts.source;\r\n\t\tvar distribution = options.distribution;\r\n\t\tvar i, ilen, timestamp;\r\n\r\n\t\tif (source === 'data' || (source === 'auto' && distribution === 'series')) {\r\n\t\t\ttimestamps = timestamps.data;\r\n\t\t} else if (source === 'labels') {\r\n\t\t\ttimestamps = timestamps.labels;\r\n\t\t} else {\r\n\t\t\ttimestamps = generate(me, min, max, capacity);\r\n\t\t}\r\n\r\n\t\tif (options.bounds === 'ticks' && timestamps.length) {\r\n\t\t\tmin = timestamps[0];\r\n\t\t\tmax = timestamps[timestamps.length - 1];\r\n\t\t}\r\n\r\n\t\t// Enforce limits with user min/max options\r\n\t\tmin = parse(me, getMin(options)) || min;\r\n\t\tmax = parse(me, getMax(options)) || max;\r\n\r\n\t\t// Remove ticks outside the min/max range\r\n\t\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\r\n\t\t\ttimestamp = timestamps[i];\r\n\t\t\tif (timestamp >= min && timestamp <= max) {\r\n\t\t\t\tticks.push(timestamp);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tme.min = min;\r\n\t\tme.max = max;\r\n\r\n\t\t// PRIVATE\r\n\t\t// determineUnitForFormatting relies on the number of ticks so we don't use it when\r\n\t\t// autoSkip is enabled because we don't yet know what the final number of ticks will be\r\n\t\tme._unit = timeOpts.unit || (tickOpts.autoSkip\r\n\t\t\t? determineUnitForAutoTicks(timeOpts.minUnit, me.min, me.max, capacity)\r\n\t\t\t: determineUnitForFormatting(me, ticks.length, timeOpts.minUnit, me.min, me.max));\r\n\t\tme._majorUnit = !tickOpts.major.enabled || me._unit === 'year' ? undefined\r\n\t\t\t: determineMajorUnit(me._unit);\r\n\t\tme._table = buildLookupTable(me._timestamps.data, min, max, distribution);\r\n\t\tme._offsets = computeOffsets(me._table, ticks, min, max, options);\r\n\r\n\t\tif (tickOpts.reverse) {\r\n\t\t\tticks.reverse();\r\n\t\t}\r\n\r\n\t\treturn ticksFromTimestamps(me, ticks, me._majorUnit);\r\n\t},\r\n\r\n\tgetLabelForIndex: function(index, datasetIndex) {\r\n\t\tvar me = this;\r\n\t\tvar adapter = me._adapter;\r\n\t\tvar data = me.chart.data;\r\n\t\tvar timeOpts = me.options.time;\r\n\t\tvar label = data.labels && index < data.labels.length ? data.labels[index] : '';\r\n\t\tvar value = data.datasets[datasetIndex].data[index];\r\n\r\n\t\tif (helpers$1.isObject(value)) {\r\n\t\t\tlabel = me.getRightValue(value);\r\n\t\t}\r\n\t\tif (timeOpts.tooltipFormat) {\r\n\t\t\treturn adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);\r\n\t\t}\r\n\t\tif (typeof label === 'string') {\r\n\t\t\treturn label;\r\n\t\t}\r\n\t\treturn adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);\r\n\t},\r\n\r\n\t/**\r\n\t * Function to format an individual tick mark\r\n\t * @private\r\n\t */\r\n\ttickFormatFunction: function(time, index, ticks, format) {\r\n\t\tvar me = this;\r\n\t\tvar adapter = me._adapter;\r\n\t\tvar options = me.options;\r\n\t\tvar formats = options.time.displayFormats;\r\n\t\tvar minorFormat = formats[me._unit];\r\n\t\tvar majorUnit = me._majorUnit;\r\n\t\tvar majorFormat = formats[majorUnit];\r\n\t\tvar tick = ticks[index];\r\n\t\tvar tickOpts = options.ticks;\r\n\t\tvar major = majorUnit && majorFormat && tick && tick.major;\r\n\t\tvar label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);\r\n\t\tvar nestedTickOpts = major ? tickOpts.major : tickOpts.minor;\r\n\t\tvar formatter = resolve$5([\r\n\t\t\tnestedTickOpts.callback,\r\n\t\t\tnestedTickOpts.userCallback,\r\n\t\t\ttickOpts.callback,\r\n\t\t\ttickOpts.userCallback\r\n\t\t]);\r\n\r\n\t\treturn formatter ? formatter(label, index, ticks) : label;\r\n\t},\r\n\r\n\tconvertTicksToLabels: function(ticks) {\r\n\t\tvar labels = [];\r\n\t\tvar i, ilen;\r\n\r\n\t\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\r\n\t\t\tlabels.push(this.tickFormatFunction(ticks[i].value, i, ticks));\r\n\t\t}\r\n\r\n\t\treturn labels;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tgetPixelForOffset: function(time) {\r\n\t\tvar me = this;\r\n\t\tvar offsets = me._offsets;\r\n\t\tvar pos = interpolate$1(me._table, 'time', time, 'pos');\r\n\t\treturn me.getPixelForDecimal((offsets.start + pos) * offsets.factor);\r\n\t},\r\n\r\n\tgetPixelForValue: function(value, index, datasetIndex) {\r\n\t\tvar me = this;\r\n\t\tvar time = null;\r\n\r\n\t\tif (index !== undefined && datasetIndex !== undefined) {\r\n\t\t\ttime = me._timestamps.datasets[datasetIndex][index];\r\n\t\t}\r\n\r\n\t\tif (time === null) {\r\n\t\t\ttime = parse(me, value);\r\n\t\t}\r\n\r\n\t\tif (time !== null) {\r\n\t\t\treturn me.getPixelForOffset(time);\r\n\t\t}\r\n\t},\r\n\r\n\tgetPixelForTick: function(index) {\r\n\t\tvar ticks = this.getTicks();\r\n\t\treturn index >= 0 && index < ticks.length ?\r\n\t\t\tthis.getPixelForOffset(ticks[index].value) :\r\n\t\t\tnull;\r\n\t},\r\n\r\n\tgetValueForPixel: function(pixel) {\r\n\t\tvar me = this;\r\n\t\tvar offsets = me._offsets;\r\n\t\tvar pos = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\r\n\t\tvar time = interpolate$1(me._table, 'pos', pos, 'time');\r\n\r\n\t\t// DEPRECATION, we should return time directly\r\n\t\treturn me._adapter._create(time);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getLabelSize: function(label) {\r\n\t\tvar me = this;\r\n\t\tvar ticksOpts = me.options.ticks;\r\n\t\tvar tickLabelWidth = me.ctx.measureText(label).width;\r\n\t\tvar angle = helpers$1.toRadians(me.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\r\n\t\tvar cosRotation = Math.cos(angle);\r\n\t\tvar sinRotation = Math.sin(angle);\r\n\t\tvar tickFontSize = valueOrDefault$d(ticksOpts.fontSize, core_defaults.global.defaultFontSize);\r\n\r\n\t\treturn {\r\n\t\t\tw: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\r\n\t\t\th: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Crude approximation of what the label width might be\r\n\t * @private\r\n\t */\r\n\tgetLabelWidth: function(label) {\r\n\t\treturn this._getLabelSize(label).w;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tgetLabelCapacity: function(exampleTime) {\r\n\t\tvar me = this;\r\n\t\tvar timeOpts = me.options.time;\r\n\t\tvar displayFormats = timeOpts.displayFormats;\r\n\r\n\t\t// pick the longest format (milliseconds) for guestimation\r\n\t\tvar format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\r\n\t\tvar exampleLabel = me.tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me, [exampleTime], me._majorUnit), format);\r\n\t\tvar size = me._getLabelSize(exampleLabel);\r\n\t\tvar capacity = Math.floor(me.isHorizontal() ? me.width / size.w : me.height / size.h);\r\n\r\n\t\tif (me.options.offset) {\r\n\t\t\tcapacity--;\r\n\t\t}\r\n\r\n\t\treturn capacity > 0 ? capacity : 1;\r\n\t}\r\n});\r\n\r\n// INTERNAL: static default options, registered in src/index.js\r\nvar _defaults$4 = defaultConfig$4;\nscale_time._defaults = _defaults$4;\n\nvar scales = {\r\n\tcategory: scale_category,\r\n\tlinear: scale_linear,\r\n\tlogarithmic: scale_logarithmic,\r\n\tradialLinear: scale_radialLinear,\r\n\ttime: scale_time\r\n};\n\nvar FORMATS = {\r\n\tdatetime: 'MMM D, YYYY, h:mm:ss a',\r\n\tmillisecond: 'h:mm:ss.SSS a',\r\n\tsecond: 'h:mm:ss a',\r\n\tminute: 'h:mm a',\r\n\thour: 'hA',\r\n\tday: 'MMM D',\r\n\tweek: 'll',\r\n\tmonth: 'MMM YYYY',\r\n\tquarter: '[Q]Q - YYYY',\r\n\tyear: 'YYYY'\r\n};\r\n\r\ncore_adapters._date.override(typeof moment === 'function' ? {\r\n\t_id: 'moment', // DEBUG ONLY\r\n\r\n\tformats: function() {\r\n\t\treturn FORMATS;\r\n\t},\r\n\r\n\tparse: function(value, format) {\r\n\t\tif (typeof value === 'string' && typeof format === 'string') {\r\n\t\t\tvalue = moment(value, format);\r\n\t\t} else if (!(value instanceof moment)) {\r\n\t\t\tvalue = moment(value);\r\n\t\t}\r\n\t\treturn value.isValid() ? value.valueOf() : null;\r\n\t},\r\n\r\n\tformat: function(time, format) {\r\n\t\treturn moment(time).format(format);\r\n\t},\r\n\r\n\tadd: function(time, amount, unit) {\r\n\t\treturn moment(time).add(amount, unit).valueOf();\r\n\t},\r\n\r\n\tdiff: function(max, min, unit) {\r\n\t\treturn moment(max).diff(moment(min), unit);\r\n\t},\r\n\r\n\tstartOf: function(time, unit, weekday) {\r\n\t\ttime = moment(time);\r\n\t\tif (unit === 'isoWeek') {\r\n\t\t\treturn time.isoWeekday(weekday).valueOf();\r\n\t\t}\r\n\t\treturn time.startOf(unit).valueOf();\r\n\t},\r\n\r\n\tendOf: function(time, unit) {\r\n\t\treturn moment(time).endOf(unit).valueOf();\r\n\t},\r\n\r\n\t// DEPRECATIONS\r\n\r\n\t/**\r\n\t * Provided for backward compatibility with scale.getValueForPixel().\r\n\t * @deprecated since version 2.8.0\r\n\t * @todo remove at version 3\r\n\t * @private\r\n\t */\r\n\t_create: function(time) {\r\n\t\treturn moment(time);\r\n\t},\r\n} : {});\n\ncore_defaults._set('global', {\r\n\tplugins: {\r\n\t\tfiller: {\r\n\t\t\tpropagate: true\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar mappers = {\r\n\tdataset: function(source) {\r\n\t\tvar index = source.fill;\r\n\t\tvar chart = source.chart;\r\n\t\tvar meta = chart.getDatasetMeta(index);\r\n\t\tvar visible = meta && chart.isDatasetVisible(index);\r\n\t\tvar points = (visible && meta.dataset._children) || [];\r\n\t\tvar length = points.length || 0;\r\n\r\n\t\treturn !length ? null : function(point, i) {\r\n\t\t\treturn (i < length && points[i]._view) || null;\r\n\t\t};\r\n\t},\r\n\r\n\tboundary: function(source) {\r\n\t\tvar boundary = source.boundary;\r\n\t\tvar x = boundary ? boundary.x : null;\r\n\t\tvar y = boundary ? boundary.y : null;\r\n\r\n\t\tif (helpers$1.isArray(boundary)) {\r\n\t\t\treturn function(point, i) {\r\n\t\t\t\treturn boundary[i];\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn function(point) {\r\n\t\t\treturn {\r\n\t\t\t\tx: x === null ? point.x : x,\r\n\t\t\t\ty: y === null ? point.y : y,\r\n\t\t\t};\r\n\t\t};\r\n\t}\r\n};\r\n\r\n// @todo if (fill[0] === '#')\r\nfunction decodeFill(el, index, count) {\r\n\tvar model = el._model || {};\r\n\tvar fill = model.fill;\r\n\tvar target;\r\n\r\n\tif (fill === undefined) {\r\n\t\tfill = !!model.backgroundColor;\r\n\t}\r\n\r\n\tif (fill === false || fill === null) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (fill === true) {\r\n\t\treturn 'origin';\r\n\t}\r\n\r\n\ttarget = parseFloat(fill, 10);\r\n\tif (isFinite(target) && Math.floor(target) === target) {\r\n\t\tif (fill[0] === '-' || fill[0] === '+') {\r\n\t\t\ttarget = index + target;\r\n\t\t}\r\n\r\n\t\tif (target === index || target < 0 || target >= count) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn target;\r\n\t}\r\n\r\n\tswitch (fill) {\r\n\t// compatibility\r\n\tcase 'bottom':\r\n\t\treturn 'start';\r\n\tcase 'top':\r\n\t\treturn 'end';\r\n\tcase 'zero':\r\n\t\treturn 'origin';\r\n\t// supported boundaries\r\n\tcase 'origin':\r\n\tcase 'start':\r\n\tcase 'end':\r\n\t\treturn fill;\r\n\t// invalid fill values\r\n\tdefault:\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\nfunction computeLinearBoundary(source) {\r\n\tvar model = source.el._model || {};\r\n\tvar scale = source.el._scale || {};\r\n\tvar fill = source.fill;\r\n\tvar target = null;\r\n\tvar horizontal;\r\n\r\n\tif (isFinite(fill)) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// Backward compatibility: until v3, we still need to support boundary values set on\r\n\t// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and\r\n\t// controllers might still use it (e.g. the Smith chart).\r\n\r\n\tif (fill === 'start') {\r\n\t\ttarget = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;\r\n\t} else if (fill === 'end') {\r\n\t\ttarget = model.scaleTop === undefined ? scale.top : model.scaleTop;\r\n\t} else if (model.scaleZero !== undefined) {\r\n\t\ttarget = model.scaleZero;\r\n\t} else if (scale.getBasePixel) {\r\n\t\ttarget = scale.getBasePixel();\r\n\t}\r\n\r\n\tif (target !== undefined && target !== null) {\r\n\t\tif (target.x !== undefined && target.y !== undefined) {\r\n\t\t\treturn target;\r\n\t\t}\r\n\r\n\t\tif (helpers$1.isFinite(target)) {\r\n\t\t\thorizontal = scale.isHorizontal();\r\n\t\t\treturn {\r\n\t\t\t\tx: horizontal ? target : null,\r\n\t\t\t\ty: horizontal ? null : target\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\treturn null;\r\n}\r\n\r\nfunction computeCircularBoundary(source) {\r\n\tvar scale = source.el._scale;\r\n\tvar options = scale.options;\r\n\tvar length = scale.chart.data.labels.length;\r\n\tvar fill = source.fill;\r\n\tvar target = [];\r\n\tvar start, end, center, i, point;\r\n\r\n\tif (!length) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tstart = options.ticks.reverse ? scale.max : scale.min;\r\n\tend = options.ticks.reverse ? scale.min : scale.max;\r\n\tcenter = scale.getPointPositionForValue(0, start);\r\n\tfor (i = 0; i < length; ++i) {\r\n\t\tpoint = fill === 'start' || fill === 'end'\r\n\t\t\t? scale.getPointPositionForValue(i, fill === 'start' ? start : end)\r\n\t\t\t: scale.getBasePosition(i);\r\n\t\tif (options.gridLines.circular) {\r\n\t\t\tpoint.cx = center.x;\r\n\t\t\tpoint.cy = center.y;\r\n\t\t\tpoint.angle = scale.getIndexAngle(i) - Math.PI / 2;\r\n\t\t}\r\n\t\ttarget.push(point);\r\n\t}\r\n\treturn target;\r\n}\r\n\r\nfunction computeBoundary(source) {\r\n\tvar scale = source.el._scale || {};\r\n\r\n\tif (scale.getPointPositionForValue) {\r\n\t\treturn computeCircularBoundary(source);\r\n\t}\r\n\treturn computeLinearBoundary(source);\r\n}\r\n\r\nfunction resolveTarget(sources, index, propagate) {\r\n\tvar source = sources[index];\r\n\tvar fill = source.fill;\r\n\tvar visited = [index];\r\n\tvar target;\r\n\r\n\tif (!propagate) {\r\n\t\treturn fill;\r\n\t}\r\n\r\n\twhile (fill !== false && visited.indexOf(fill) === -1) {\r\n\t\tif (!isFinite(fill)) {\r\n\t\t\treturn fill;\r\n\t\t}\r\n\r\n\t\ttarget = sources[fill];\r\n\t\tif (!target) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (target.visible) {\r\n\t\t\treturn fill;\r\n\t\t}\r\n\r\n\t\tvisited.push(fill);\r\n\t\tfill = target.fill;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nfunction createMapper(source) {\r\n\tvar fill = source.fill;\r\n\tvar type = 'dataset';\r\n\r\n\tif (fill === false) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tif (!isFinite(fill)) {\r\n\t\ttype = 'boundary';\r\n\t}\r\n\r\n\treturn mappers[type](source);\r\n}\r\n\r\nfunction isDrawable(point) {\r\n\treturn point && !point.skip;\r\n}\r\n\r\nfunction drawArea(ctx, curve0, curve1, len0, len1) {\r\n\tvar i, cx, cy, r;\r\n\r\n\tif (!len0 || !len1) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// building first area curve (normal)\r\n\tctx.moveTo(curve0[0].x, curve0[0].y);\r\n\tfor (i = 1; i < len0; ++i) {\r\n\t\thelpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);\r\n\t}\r\n\r\n\tif (curve1[0].angle !== undefined) {\r\n\t\tcx = curve1[0].cx;\r\n\t\tcy = curve1[0].cy;\r\n\t\tr = Math.sqrt(Math.pow(curve1[0].x - cx, 2) + Math.pow(curve1[0].y - cy, 2));\r\n\t\tfor (i = len1 - 1; i > 0; --i) {\r\n\t\t\tctx.arc(cx, cy, r, curve1[i].angle, curve1[i - 1].angle, true);\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\r\n\t// joining the two area curves\r\n\tctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);\r\n\r\n\t// building opposite area curve (reverse)\r\n\tfor (i = len1 - 1; i > 0; --i) {\r\n\t\thelpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);\r\n\t}\r\n}\r\n\r\nfunction doFill(ctx, points, mapper, view, color, loop) {\r\n\tvar count = points.length;\r\n\tvar span = view.spanGaps;\r\n\tvar curve0 = [];\r\n\tvar curve1 = [];\r\n\tvar len0 = 0;\r\n\tvar len1 = 0;\r\n\tvar i, ilen, index, p0, p1, d0, d1, loopOffset;\r\n\r\n\tctx.beginPath();\r\n\r\n\tfor (i = 0, ilen = count; i < ilen; ++i) {\r\n\t\tindex = i % count;\r\n\t\tp0 = points[index]._view;\r\n\t\tp1 = mapper(p0, index, view);\r\n\t\td0 = isDrawable(p0);\r\n\t\td1 = isDrawable(p1);\r\n\r\n\t\tif (loop && loopOffset === undefined && d0) {\r\n\t\t\tloopOffset = i + 1;\r\n\t\t\tilen = count + loopOffset;\r\n\t\t}\r\n\r\n\t\tif (d0 && d1) {\r\n\t\t\tlen0 = curve0.push(p0);\r\n\t\t\tlen1 = curve1.push(p1);\r\n\t\t} else if (len0 && len1) {\r\n\t\t\tif (!span) {\r\n\t\t\t\tdrawArea(ctx, curve0, curve1, len0, len1);\r\n\t\t\t\tlen0 = len1 = 0;\r\n\t\t\t\tcurve0 = [];\r\n\t\t\t\tcurve1 = [];\r\n\t\t\t} else {\r\n\t\t\t\tif (d0) {\r\n\t\t\t\t\tcurve0.push(p0);\r\n\t\t\t\t}\r\n\t\t\t\tif (d1) {\r\n\t\t\t\t\tcurve1.push(p1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tdrawArea(ctx, curve0, curve1, len0, len1);\r\n\r\n\tctx.closePath();\r\n\tctx.fillStyle = color;\r\n\tctx.fill();\r\n}\r\n\r\nvar plugin_filler = {\r\n\tid: 'filler',\r\n\r\n\tafterDatasetsUpdate: function(chart, options) {\r\n\t\tvar count = (chart.data.datasets || []).length;\r\n\t\tvar propagate = options.propagate;\r\n\t\tvar sources = [];\r\n\t\tvar meta, i, el, source;\r\n\r\n\t\tfor (i = 0; i < count; ++i) {\r\n\t\t\tmeta = chart.getDatasetMeta(i);\r\n\t\t\tel = meta.dataset;\r\n\t\t\tsource = null;\r\n\r\n\t\t\tif (el && el._model && el instanceof elements.Line) {\r\n\t\t\t\tsource = {\r\n\t\t\t\t\tvisible: chart.isDatasetVisible(i),\r\n\t\t\t\t\tfill: decodeFill(el, i, count),\r\n\t\t\t\t\tchart: chart,\r\n\t\t\t\t\tel: el\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tmeta.$filler = source;\r\n\t\t\tsources.push(source);\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < count; ++i) {\r\n\t\t\tsource = sources[i];\r\n\t\t\tif (!source) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tsource.fill = resolveTarget(sources, i, propagate);\r\n\t\t\tsource.boundary = computeBoundary(source);\r\n\t\t\tsource.mapper = createMapper(source);\r\n\t\t}\r\n\t},\r\n\r\n\tbeforeDatasetsDraw: function(chart) {\r\n\t\tvar metasets = chart._getSortedVisibleDatasetMetas();\r\n\t\tvar ctx = chart.ctx;\r\n\t\tvar meta, i, el, view, points, mapper, color;\r\n\r\n\t\tfor (i = metasets.length - 1; i >= 0; --i) {\r\n\t\t\tmeta = metasets[i].$filler;\r\n\r\n\t\t\tif (!meta || !meta.visible) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tel = meta.el;\r\n\t\t\tview = el._view;\r\n\t\t\tpoints = el._children || [];\r\n\t\t\tmapper = meta.mapper;\r\n\t\t\tcolor = view.backgroundColor || core_defaults.global.defaultColor;\r\n\r\n\t\t\tif (mapper && color && points.length) {\r\n\t\t\t\thelpers$1.canvas.clipArea(ctx, chart.chartArea);\r\n\t\t\t\tdoFill(ctx, points, mapper, view, color, el._loop);\r\n\t\t\t\thelpers$1.canvas.unclipArea(ctx);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\n\nvar getRtlHelper$1 = helpers$1.rtl.getRtlAdapter;\r\nvar noop$1 = helpers$1.noop;\r\nvar valueOrDefault$e = helpers$1.valueOrDefault;\r\n\r\ncore_defaults._set('global', {\r\n\tlegend: {\r\n\t\tdisplay: true,\r\n\t\tposition: 'top',\r\n\t\talign: 'center',\r\n\t\tfullWidth: true,\r\n\t\treverse: false,\r\n\t\tweight: 1000,\r\n\r\n\t\t// a callback that will handle\r\n\t\tonClick: function(e, legendItem) {\r\n\t\t\tvar index = legendItem.datasetIndex;\r\n\t\t\tvar ci = this.chart;\r\n\t\t\tvar meta = ci.getDatasetMeta(index);\r\n\r\n\t\t\t// See controller.isDatasetVisible comment\r\n\t\t\tmeta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;\r\n\r\n\t\t\t// We hid a dataset ... rerender the chart\r\n\t\t\tci.update();\r\n\t\t},\r\n\r\n\t\tonHover: null,\r\n\t\tonLeave: null,\r\n\r\n\t\tlabels: {\r\n\t\t\tboxWidth: 40,\r\n\t\t\tpadding: 10,\r\n\t\t\t// Generates labels shown in the legend\r\n\t\t\t// Valid properties to return:\r\n\t\t\t// text : text to display\r\n\t\t\t// fillStyle : fill of coloured box\r\n\t\t\t// strokeStyle: stroke of coloured box\r\n\t\t\t// hidden : if this legend item refers to a hidden item\r\n\t\t\t// lineCap : cap style for line\r\n\t\t\t// lineDash\r\n\t\t\t// lineDashOffset :\r\n\t\t\t// lineJoin :\r\n\t\t\t// lineWidth :\r\n\t\t\tgenerateLabels: function(chart) {\r\n\t\t\t\tvar datasets = chart.data.datasets;\r\n\t\t\t\tvar options = chart.options.legend || {};\r\n\t\t\t\tvar usePointStyle = options.labels && options.labels.usePointStyle;\r\n\r\n\t\t\t\treturn chart._getSortedDatasetMetas().map(function(meta) {\r\n\t\t\t\t\tvar style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\r\n\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\ttext: datasets[meta.index].label,\r\n\t\t\t\t\t\tfillStyle: style.backgroundColor,\r\n\t\t\t\t\t\thidden: !chart.isDatasetVisible(meta.index),\r\n\t\t\t\t\t\tlineCap: style.borderCapStyle,\r\n\t\t\t\t\t\tlineDash: style.borderDash,\r\n\t\t\t\t\t\tlineDashOffset: style.borderDashOffset,\r\n\t\t\t\t\t\tlineJoin: style.borderJoinStyle,\r\n\t\t\t\t\t\tlineWidth: style.borderWidth,\r\n\t\t\t\t\t\tstrokeStyle: style.borderColor,\r\n\t\t\t\t\t\tpointStyle: style.pointStyle,\r\n\t\t\t\t\t\trotation: style.rotation,\r\n\r\n\t\t\t\t\t\t// Below is extra data used for toggling the datasets\r\n\t\t\t\t\t\tdatasetIndex: meta.index\r\n\t\t\t\t\t};\r\n\t\t\t\t}, this);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tlegendCallback: function(chart) {\r\n\t\tvar list = document.createElement('ul');\r\n\t\tvar datasets = chart.data.datasets;\r\n\t\tvar i, ilen, listItem, listItemSpan;\r\n\r\n\t\tlist.setAttribute('class', chart.id + '-legend');\r\n\r\n\t\tfor (i = 0, ilen = datasets.length; i < ilen; i++) {\r\n\t\t\tlistItem = list.appendChild(document.createElement('li'));\r\n\t\t\tlistItemSpan = listItem.appendChild(document.createElement('span'));\r\n\t\t\tlistItemSpan.style.backgroundColor = datasets[i].backgroundColor;\r\n\t\t\tif (datasets[i].label) {\r\n\t\t\t\tlistItem.appendChild(document.createTextNode(datasets[i].label));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn list.outerHTML;\r\n\t}\r\n});\r\n\r\n/**\r\n * Helper function to get the box width based on the usePointStyle option\r\n * @param {object} labelopts - the label options on the legend\r\n * @param {number} fontSize - the label font size\r\n * @return {number} width of the color box area\r\n */\r\nfunction getBoxWidth(labelOpts, fontSize) {\r\n\treturn labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ?\r\n\t\tfontSize :\r\n\t\tlabelOpts.boxWidth;\r\n}\r\n\r\n/**\r\n * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!\r\n */\r\nvar Legend = core_element.extend({\r\n\r\n\tinitialize: function(config) {\r\n\t\tvar me = this;\r\n\t\thelpers$1.extend(me, config);\r\n\r\n\t\t// Contains hit boxes for each dataset (in dataset order)\r\n\t\tme.legendHitBoxes = [];\r\n\r\n\t\t/**\r\n \t\t * @private\r\n \t\t */\r\n\t\tme._hoveredItem = null;\r\n\r\n\t\t// Are we in doughnut mode which has a different data type\r\n\t\tme.doughnutMode = false;\r\n\t},\r\n\r\n\t// These methods are ordered by lifecycle. Utilities then follow.\r\n\t// Any function defined here is inherited by all legend types.\r\n\t// Any function can be extended by the legend type\r\n\r\n\tbeforeUpdate: noop$1,\r\n\tupdate: function(maxWidth, maxHeight, margins) {\r\n\t\tvar me = this;\r\n\r\n\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\r\n\t\tme.beforeUpdate();\r\n\r\n\t\t// Absorb the master measurements\r\n\t\tme.maxWidth = maxWidth;\r\n\t\tme.maxHeight = maxHeight;\r\n\t\tme.margins = margins;\r\n\r\n\t\t// Dimensions\r\n\t\tme.beforeSetDimensions();\r\n\t\tme.setDimensions();\r\n\t\tme.afterSetDimensions();\r\n\t\t// Labels\r\n\t\tme.beforeBuildLabels();\r\n\t\tme.buildLabels();\r\n\t\tme.afterBuildLabels();\r\n\r\n\t\t// Fit\r\n\t\tme.beforeFit();\r\n\t\tme.fit();\r\n\t\tme.afterFit();\r\n\t\t//\r\n\t\tme.afterUpdate();\r\n\r\n\t\treturn me.minSize;\r\n\t},\r\n\tafterUpdate: noop$1,\r\n\r\n\t//\r\n\r\n\tbeforeSetDimensions: noop$1,\r\n\tsetDimensions: function() {\r\n\t\tvar me = this;\r\n\t\t// Set the unconstrained dimension before label rotation\r\n\t\tif (me.isHorizontal()) {\r\n\t\t\t// Reset position before calculating rotation\r\n\t\t\tme.width = me.maxWidth;\r\n\t\t\tme.left = 0;\r\n\t\t\tme.right = me.width;\r\n\t\t} else {\r\n\t\t\tme.height = me.maxHeight;\r\n\r\n\t\t\t// Reset position before calculating rotation\r\n\t\t\tme.top = 0;\r\n\t\t\tme.bottom = me.height;\r\n\t\t}\r\n\r\n\t\t// Reset padding\r\n\t\tme.paddingLeft = 0;\r\n\t\tme.paddingTop = 0;\r\n\t\tme.paddingRight = 0;\r\n\t\tme.paddingBottom = 0;\r\n\r\n\t\t// Reset minSize\r\n\t\tme.minSize = {\r\n\t\t\twidth: 0,\r\n\t\t\theight: 0\r\n\t\t};\r\n\t},\r\n\tafterSetDimensions: noop$1,\r\n\r\n\t//\r\n\r\n\tbeforeBuildLabels: noop$1,\r\n\tbuildLabels: function() {\r\n\t\tvar me = this;\r\n\t\tvar labelOpts = me.options.labels || {};\r\n\t\tvar legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) || [];\r\n\r\n\t\tif (labelOpts.filter) {\r\n\t\t\tlegendItems = legendItems.filter(function(item) {\r\n\t\t\t\treturn labelOpts.filter(item, me.chart.data);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif (me.options.reverse) {\r\n\t\t\tlegendItems.reverse();\r\n\t\t}\r\n\r\n\t\tme.legendItems = legendItems;\r\n\t},\r\n\tafterBuildLabels: noop$1,\r\n\r\n\t//\r\n\r\n\tbeforeFit: noop$1,\r\n\tfit: function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar labelOpts = opts.labels;\r\n\t\tvar display = opts.display;\r\n\r\n\t\tvar ctx = me.ctx;\r\n\r\n\t\tvar labelFont = helpers$1.options._parseFont(labelOpts);\r\n\t\tvar fontSize = labelFont.size;\r\n\r\n\t\t// Reset hit boxes\r\n\t\tvar hitboxes = me.legendHitBoxes = [];\r\n\r\n\t\tvar minSize = me.minSize;\r\n\t\tvar isHorizontal = me.isHorizontal();\r\n\r\n\t\tif (isHorizontal) {\r\n\t\t\tminSize.width = me.maxWidth; // fill all the width\r\n\t\t\tminSize.height = display ? 10 : 0;\r\n\t\t} else {\r\n\t\t\tminSize.width = display ? 10 : 0;\r\n\t\t\tminSize.height = me.maxHeight; // fill all the height\r\n\t\t}\r\n\r\n\t\t// Increase sizes here\r\n\t\tif (!display) {\r\n\t\t\tme.width = minSize.width = me.height = minSize.height = 0;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tctx.font = labelFont.string;\r\n\r\n\t\tif (isHorizontal) {\r\n\t\t\t// Labels\r\n\r\n\t\t\t// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\r\n\t\t\tvar lineWidths = me.lineWidths = [0];\r\n\t\t\tvar totalHeight = 0;\r\n\r\n\t\t\tctx.textAlign = 'left';\r\n\t\t\tctx.textBaseline = 'middle';\r\n\r\n\t\t\thelpers$1.each(me.legendItems, function(legendItem, i) {\r\n\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\r\n\t\t\t\tvar width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\r\n\r\n\t\t\t\tif (i === 0 || lineWidths[lineWidths.length - 1] + width + 2 * labelOpts.padding > minSize.width) {\r\n\t\t\t\t\ttotalHeight += fontSize + labelOpts.padding;\r\n\t\t\t\t\tlineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\r\n\t\t\t\thitboxes[i] = {\r\n\t\t\t\t\tleft: 0,\r\n\t\t\t\t\ttop: 0,\r\n\t\t\t\t\twidth: width,\r\n\t\t\t\t\theight: fontSize\r\n\t\t\t\t};\r\n\r\n\t\t\t\tlineWidths[lineWidths.length - 1] += width + labelOpts.padding;\r\n\t\t\t});\r\n\r\n\t\t\tminSize.height += totalHeight;\r\n\r\n\t\t} else {\r\n\t\t\tvar vPadding = labelOpts.padding;\r\n\t\t\tvar columnWidths = me.columnWidths = [];\r\n\t\t\tvar columnHeights = me.columnHeights = [];\r\n\t\t\tvar totalWidth = labelOpts.padding;\r\n\t\t\tvar currentColWidth = 0;\r\n\t\t\tvar currentColHeight = 0;\r\n\r\n\t\t\thelpers$1.each(me.legendItems, function(legendItem, i) {\r\n\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\r\n\t\t\t\tvar itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\r\n\r\n\t\t\t\t// If too tall, go to new column\r\n\t\t\t\tif (i > 0 && currentColHeight + fontSize + 2 * vPadding > minSize.height) {\r\n\t\t\t\t\ttotalWidth += currentColWidth + labelOpts.padding;\r\n\t\t\t\t\tcolumnWidths.push(currentColWidth); // previous column width\r\n\t\t\t\t\tcolumnHeights.push(currentColHeight);\r\n\t\t\t\t\tcurrentColWidth = 0;\r\n\t\t\t\t\tcurrentColHeight = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Get max width\r\n\t\t\t\tcurrentColWidth = Math.max(currentColWidth, itemWidth);\r\n\t\t\t\tcurrentColHeight += fontSize + vPadding;\r\n\r\n\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\r\n\t\t\t\thitboxes[i] = {\r\n\t\t\t\t\tleft: 0,\r\n\t\t\t\t\ttop: 0,\r\n\t\t\t\t\twidth: itemWidth,\r\n\t\t\t\t\theight: fontSize\r\n\t\t\t\t};\r\n\t\t\t});\r\n\r\n\t\t\ttotalWidth += currentColWidth;\r\n\t\t\tcolumnWidths.push(currentColWidth);\r\n\t\t\tcolumnHeights.push(currentColHeight);\r\n\t\t\tminSize.width += totalWidth;\r\n\t\t}\r\n\r\n\t\tme.width = minSize.width;\r\n\t\tme.height = minSize.height;\r\n\t},\r\n\tafterFit: noop$1,\r\n\r\n\t// Shared Methods\r\n\tisHorizontal: function() {\r\n\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\r\n\t},\r\n\r\n\t// Actually draw the legend on the canvas\r\n\tdraw: function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar labelOpts = opts.labels;\r\n\t\tvar globalDefaults = core_defaults.global;\r\n\t\tvar defaultColor = globalDefaults.defaultColor;\r\n\t\tvar lineDefault = globalDefaults.elements.line;\r\n\t\tvar legendHeight = me.height;\r\n\t\tvar columnHeights = me.columnHeights;\r\n\t\tvar legendWidth = me.width;\r\n\t\tvar lineWidths = me.lineWidths;\r\n\r\n\t\tif (!opts.display) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar rtlHelper = getRtlHelper$1(opts.rtl, me.left, me.minSize.width);\r\n\t\tvar ctx = me.ctx;\r\n\t\tvar fontColor = valueOrDefault$e(labelOpts.fontColor, globalDefaults.defaultFontColor);\r\n\t\tvar labelFont = helpers$1.options._parseFont(labelOpts);\r\n\t\tvar fontSize = labelFont.size;\r\n\t\tvar cursor;\r\n\r\n\t\t// Canvas setup\r\n\t\tctx.textAlign = rtlHelper.textAlign('left');\r\n\t\tctx.textBaseline = 'middle';\r\n\t\tctx.lineWidth = 0.5;\r\n\t\tctx.strokeStyle = fontColor; // for strikethrough effect\r\n\t\tctx.fillStyle = fontColor; // render in correct colour\r\n\t\tctx.font = labelFont.string;\r\n\r\n\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\r\n\t\tvar hitboxes = me.legendHitBoxes;\r\n\r\n\t\t// current position\r\n\t\tvar drawLegendBox = function(x, y, legendItem) {\r\n\t\t\tif (isNaN(boxWidth) || boxWidth <= 0) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Set the ctx for the box\r\n\t\t\tctx.save();\r\n\r\n\t\t\tvar lineWidth = valueOrDefault$e(legendItem.lineWidth, lineDefault.borderWidth);\r\n\t\t\tctx.fillStyle = valueOrDefault$e(legendItem.fillStyle, defaultColor);\r\n\t\t\tctx.lineCap = valueOrDefault$e(legendItem.lineCap, lineDefault.borderCapStyle);\r\n\t\t\tctx.lineDashOffset = valueOrDefault$e(legendItem.lineDashOffset, lineDefault.borderDashOffset);\r\n\t\t\tctx.lineJoin = valueOrDefault$e(legendItem.lineJoin, lineDefault.borderJoinStyle);\r\n\t\t\tctx.lineWidth = lineWidth;\r\n\t\t\tctx.strokeStyle = valueOrDefault$e(legendItem.strokeStyle, defaultColor);\r\n\r\n\t\t\tif (ctx.setLineDash) {\r\n\t\t\t\t// IE 9 and 10 do not support line dash\r\n\t\t\t\tctx.setLineDash(valueOrDefault$e(legendItem.lineDash, lineDefault.borderDash));\r\n\t\t\t}\r\n\r\n\t\t\tif (labelOpts && labelOpts.usePointStyle) {\r\n\t\t\t\t// Recalculate x and y for drawPoint() because its expecting\r\n\t\t\t\t// x and y to be center of figure (instead of top left)\r\n\t\t\t\tvar radius = boxWidth * Math.SQRT2 / 2;\r\n\t\t\t\tvar centerX = rtlHelper.xPlus(x, boxWidth / 2);\r\n\t\t\t\tvar centerY = y + fontSize / 2;\r\n\r\n\t\t\t\t// Draw pointStyle as legend symbol\r\n\t\t\t\thelpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY, legendItem.rotation);\r\n\t\t\t} else {\r\n\t\t\t\t// Draw box as legend symbol\r\n\t\t\t\tctx.fillRect(rtlHelper.leftForLtr(x, boxWidth), y, boxWidth, fontSize);\r\n\t\t\t\tif (lineWidth !== 0) {\r\n\t\t\t\t\tctx.strokeRect(rtlHelper.leftForLtr(x, boxWidth), y, boxWidth, fontSize);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tctx.restore();\r\n\t\t};\r\n\r\n\t\tvar fillText = function(x, y, legendItem, textWidth) {\r\n\t\t\tvar halfFontSize = fontSize / 2;\r\n\t\t\tvar xLeft = rtlHelper.xPlus(x, boxWidth + halfFontSize);\r\n\t\t\tvar yMiddle = y + halfFontSize;\r\n\r\n\t\t\tctx.fillText(legendItem.text, xLeft, yMiddle);\r\n\r\n\t\t\tif (legendItem.hidden) {\r\n\t\t\t\t// Strikethrough the text if hidden\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.lineWidth = 2;\r\n\t\t\t\tctx.moveTo(xLeft, yMiddle);\r\n\t\t\t\tctx.lineTo(rtlHelper.xPlus(xLeft, textWidth), yMiddle);\r\n\t\t\t\tctx.stroke();\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar alignmentOffset = function(dimension, blockSize) {\r\n\t\t\tswitch (opts.align) {\r\n\t\t\tcase 'start':\r\n\t\t\t\treturn labelOpts.padding;\r\n\t\t\tcase 'end':\r\n\t\t\t\treturn dimension - blockSize;\r\n\t\t\tdefault: // center\r\n\t\t\t\treturn (dimension - blockSize + labelOpts.padding) / 2;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// Horizontal\r\n\t\tvar isHorizontal = me.isHorizontal();\r\n\t\tif (isHorizontal) {\r\n\t\t\tcursor = {\r\n\t\t\t\tx: me.left + alignmentOffset(legendWidth, lineWidths[0]),\r\n\t\t\t\ty: me.top + labelOpts.padding,\r\n\t\t\t\tline: 0\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tcursor = {\r\n\t\t\t\tx: me.left + labelOpts.padding,\r\n\t\t\t\ty: me.top + alignmentOffset(legendHeight, columnHeights[0]),\r\n\t\t\t\tline: 0\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\thelpers$1.rtl.overrideTextDirection(me.ctx, opts.textDirection);\r\n\r\n\t\tvar itemHeight = fontSize + labelOpts.padding;\r\n\t\thelpers$1.each(me.legendItems, function(legendItem, i) {\r\n\t\t\tvar textWidth = ctx.measureText(legendItem.text).width;\r\n\t\t\tvar width = boxWidth + (fontSize / 2) + textWidth;\r\n\t\t\tvar x = cursor.x;\r\n\t\t\tvar y = cursor.y;\r\n\r\n\t\t\trtlHelper.setWidth(me.minSize.width);\r\n\r\n\t\t\t// Use (me.left + me.minSize.width) and (me.top + me.minSize.height)\r\n\t\t\t// instead of me.right and me.bottom because me.width and me.height\r\n\t\t\t// may have been changed since me.minSize was calculated\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\tif (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {\r\n\t\t\t\t\ty = cursor.y += itemHeight;\r\n\t\t\t\t\tcursor.line++;\r\n\t\t\t\t\tx = cursor.x = me.left + alignmentOffset(legendWidth, lineWidths[cursor.line]);\r\n\t\t\t\t}\r\n\t\t\t} else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {\r\n\t\t\t\tx = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\r\n\t\t\t\tcursor.line++;\r\n\t\t\t\ty = cursor.y = me.top + alignmentOffset(legendHeight, columnHeights[cursor.line]);\r\n\t\t\t}\r\n\r\n\t\t\tvar realX = rtlHelper.x(x);\r\n\r\n\t\t\tdrawLegendBox(realX, y, legendItem);\r\n\r\n\t\t\thitboxes[i].left = rtlHelper.leftForLtr(realX, hitboxes[i].width);\r\n\t\t\thitboxes[i].top = y;\r\n\r\n\t\t\t// Fill the actual label\r\n\t\t\tfillText(realX, y, legendItem, textWidth);\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\tcursor.x += width + labelOpts.padding;\r\n\t\t\t} else {\r\n\t\t\t\tcursor.y += itemHeight;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\thelpers$1.rtl.restoreTextDirection(me.ctx, opts.textDirection);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getLegendItemAt: function(x, y) {\r\n\t\tvar me = this;\r\n\t\tvar i, hitBox, lh;\r\n\r\n\t\tif (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\r\n\t\t\t// See if we are touching one of the dataset boxes\r\n\t\t\tlh = me.legendHitBoxes;\r\n\t\t\tfor (i = 0; i < lh.length; ++i) {\r\n\t\t\t\thitBox = lh[i];\r\n\r\n\t\t\t\tif (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\r\n\t\t\t\t\t// Touching an element\r\n\t\t\t\t\treturn me.legendItems[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t},\r\n\r\n\t/**\r\n\t * Handle an event\r\n\t * @private\r\n\t * @param {IEvent} event - The event to handle\r\n\t */\r\n\thandleEvent: function(e) {\r\n\t\tvar me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar type = e.type === 'mouseup' ? 'click' : e.type;\r\n\t\tvar hoveredItem;\r\n\r\n\t\tif (type === 'mousemove') {\r\n\t\t\tif (!opts.onHover && !opts.onLeave) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t} else if (type === 'click') {\r\n\t\t\tif (!opts.onClick) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Chart event already has relative position in it\r\n\t\thoveredItem = me._getLegendItemAt(e.x, e.y);\r\n\r\n\t\tif (type === 'click') {\r\n\t\t\tif (hoveredItem && opts.onClick) {\r\n\t\t\t\t// use e.native for backwards compatibility\r\n\t\t\t\topts.onClick.call(me, e.native, hoveredItem);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (opts.onLeave && hoveredItem !== me._hoveredItem) {\r\n\t\t\t\tif (me._hoveredItem) {\r\n\t\t\t\t\topts.onLeave.call(me, e.native, me._hoveredItem);\r\n\t\t\t\t}\r\n\t\t\t\tme._hoveredItem = hoveredItem;\r\n\t\t\t}\r\n\r\n\t\t\tif (opts.onHover && hoveredItem) {\r\n\t\t\t\t// use e.native for backwards compatibility\r\n\t\t\t\topts.onHover.call(me, e.native, hoveredItem);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\nfunction createNewLegendAndAttach(chart, legendOpts) {\r\n\tvar legend = new Legend({\r\n\t\tctx: chart.ctx,\r\n\t\toptions: legendOpts,\r\n\t\tchart: chart\r\n\t});\r\n\r\n\tcore_layouts.configure(chart, legend, legendOpts);\r\n\tcore_layouts.addBox(chart, legend);\r\n\tchart.legend = legend;\r\n}\r\n\r\nvar plugin_legend = {\r\n\tid: 'legend',\r\n\r\n\t/**\r\n\t * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making\r\n\t * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of\r\n\t * the plugin, which one will be re-exposed in the chart.js file.\r\n\t * https://github.com/chartjs/Chart.js/pull/2640\r\n\t * @private\r\n\t */\r\n\t_element: Legend,\r\n\r\n\tbeforeInit: function(chart) {\r\n\t\tvar legendOpts = chart.options.legend;\r\n\r\n\t\tif (legendOpts) {\r\n\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\r\n\t\t}\r\n\t},\r\n\r\n\tbeforeUpdate: function(chart) {\r\n\t\tvar legendOpts = chart.options.legend;\r\n\t\tvar legend = chart.legend;\r\n\r\n\t\tif (legendOpts) {\r\n\t\t\thelpers$1.mergeIf(legendOpts, core_defaults.global.legend);\r\n\r\n\t\t\tif (legend) {\r\n\t\t\t\tcore_layouts.configure(chart, legend, legendOpts);\r\n\t\t\t\tlegend.options = legendOpts;\r\n\t\t\t} else {\r\n\t\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\r\n\t\t\t}\r\n\t\t} else if (legend) {\r\n\t\t\tcore_layouts.removeBox(chart, legend);\r\n\t\t\tdelete chart.legend;\r\n\t\t}\r\n\t},\r\n\r\n\tafterEvent: function(chart, e) {\r\n\t\tvar legend = chart.legend;\r\n\t\tif (legend) {\r\n\t\t\tlegend.handleEvent(e);\r\n\t\t}\r\n\t}\r\n};\n\nvar noop$2 = helpers$1.noop;\r\n\r\ncore_defaults._set('global', {\r\n\ttitle: {\r\n\t\tdisplay: false,\r\n\t\tfontStyle: 'bold',\r\n\t\tfullWidth: true,\r\n\t\tpadding: 10,\r\n\t\tposition: 'top',\r\n\t\ttext: '',\r\n\t\tweight: 2000         // by default greater than legend (1000) to be above\r\n\t}\r\n});\r\n\r\n/**\r\n * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!\r\n */\r\nvar Title = core_element.extend({\r\n\tinitialize: function(config) {\r\n\t\tvar me = this;\r\n\t\thelpers$1.extend(me, config);\r\n\r\n\t\t// Contains hit boxes for each dataset (in dataset order)\r\n\t\tme.legendHitBoxes = [];\r\n\t},\r\n\r\n\t// These methods are ordered by lifecycle. Utilities then follow.\r\n\r\n\tbeforeUpdate: noop$2,\r\n\tupdate: function(maxWidth, maxHeight, margins) {\r\n\t\tvar me = this;\r\n\r\n\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\r\n\t\tme.beforeUpdate();\r\n\r\n\t\t// Absorb the master measurements\r\n\t\tme.maxWidth = maxWidth;\r\n\t\tme.maxHeight = maxHeight;\r\n\t\tme.margins = margins;\r\n\r\n\t\t// Dimensions\r\n\t\tme.beforeSetDimensions();\r\n\t\tme.setDimensions();\r\n\t\tme.afterSetDimensions();\r\n\t\t// Labels\r\n\t\tme.beforeBuildLabels();\r\n\t\tme.buildLabels();\r\n\t\tme.afterBuildLabels();\r\n\r\n\t\t// Fit\r\n\t\tme.beforeFit();\r\n\t\tme.fit();\r\n\t\tme.afterFit();\r\n\t\t//\r\n\t\tme.afterUpdate();\r\n\r\n\t\treturn me.minSize;\r\n\r\n\t},\r\n\tafterUpdate: noop$2,\r\n\r\n\t//\r\n\r\n\tbeforeSetDimensions: noop$2,\r\n\tsetDimensions: function() {\r\n\t\tvar me = this;\r\n\t\t// Set the unconstrained dimension before label rotation\r\n\t\tif (me.isHorizontal()) {\r\n\t\t\t// Reset position before calculating rotation\r\n\t\t\tme.width = me.maxWidth;\r\n\t\t\tme.left = 0;\r\n\t\t\tme.right = me.width;\r\n\t\t} else {\r\n\t\t\tme.height = me.maxHeight;\r\n\r\n\t\t\t// Reset position before calculating rotation\r\n\t\t\tme.top = 0;\r\n\t\t\tme.bottom = me.height;\r\n\t\t}\r\n\r\n\t\t// Reset padding\r\n\t\tme.paddingLeft = 0;\r\n\t\tme.paddingTop = 0;\r\n\t\tme.paddingRight = 0;\r\n\t\tme.paddingBottom = 0;\r\n\r\n\t\t// Reset minSize\r\n\t\tme.minSize = {\r\n\t\t\twidth: 0,\r\n\t\t\theight: 0\r\n\t\t};\r\n\t},\r\n\tafterSetDimensions: noop$2,\r\n\r\n\t//\r\n\r\n\tbeforeBuildLabels: noop$2,\r\n\tbuildLabels: noop$2,\r\n\tafterBuildLabels: noop$2,\r\n\r\n\t//\r\n\r\n\tbeforeFit: noop$2,\r\n\tfit: function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar minSize = me.minSize = {};\r\n\t\tvar isHorizontal = me.isHorizontal();\r\n\t\tvar lineCount, textSize;\r\n\r\n\t\tif (!opts.display) {\r\n\t\t\tme.width = minSize.width = me.height = minSize.height = 0;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;\r\n\t\ttextSize = lineCount * helpers$1.options._parseFont(opts).lineHeight + opts.padding * 2;\r\n\r\n\t\tme.width = minSize.width = isHorizontal ? me.maxWidth : textSize;\r\n\t\tme.height = minSize.height = isHorizontal ? textSize : me.maxHeight;\r\n\t},\r\n\tafterFit: noop$2,\r\n\r\n\t// Shared Methods\r\n\tisHorizontal: function() {\r\n\t\tvar pos = this.options.position;\r\n\t\treturn pos === 'top' || pos === 'bottom';\r\n\t},\r\n\r\n\t// Actually draw the title block on the canvas\r\n\tdraw: function() {\r\n\t\tvar me = this;\r\n\t\tvar ctx = me.ctx;\r\n\t\tvar opts = me.options;\r\n\r\n\t\tif (!opts.display) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar fontOpts = helpers$1.options._parseFont(opts);\r\n\t\tvar lineHeight = fontOpts.lineHeight;\r\n\t\tvar offset = lineHeight / 2 + opts.padding;\r\n\t\tvar rotation = 0;\r\n\t\tvar top = me.top;\r\n\t\tvar left = me.left;\r\n\t\tvar bottom = me.bottom;\r\n\t\tvar right = me.right;\r\n\t\tvar maxWidth, titleX, titleY;\r\n\r\n\t\tctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor); // render in correct colour\r\n\t\tctx.font = fontOpts.string;\r\n\r\n\t\t// Horizontal\r\n\t\tif (me.isHorizontal()) {\r\n\t\t\ttitleX = left + ((right - left) / 2); // midpoint of the width\r\n\t\t\ttitleY = top + offset;\r\n\t\t\tmaxWidth = right - left;\r\n\t\t} else {\r\n\t\t\ttitleX = opts.position === 'left' ? left + offset : right - offset;\r\n\t\t\ttitleY = top + ((bottom - top) / 2);\r\n\t\t\tmaxWidth = bottom - top;\r\n\t\t\trotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);\r\n\t\t}\r\n\r\n\t\tctx.save();\r\n\t\tctx.translate(titleX, titleY);\r\n\t\tctx.rotate(rotation);\r\n\t\tctx.textAlign = 'center';\r\n\t\tctx.textBaseline = 'middle';\r\n\r\n\t\tvar text = opts.text;\r\n\t\tif (helpers$1.isArray(text)) {\r\n\t\t\tvar y = 0;\r\n\t\t\tfor (var i = 0; i < text.length; ++i) {\r\n\t\t\t\tctx.fillText(text[i], 0, y, maxWidth);\r\n\t\t\t\ty += lineHeight;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tctx.fillText(text, 0, 0, maxWidth);\r\n\t\t}\r\n\r\n\t\tctx.restore();\r\n\t}\r\n});\r\n\r\nfunction createNewTitleBlockAndAttach(chart, titleOpts) {\r\n\tvar title = new Title({\r\n\t\tctx: chart.ctx,\r\n\t\toptions: titleOpts,\r\n\t\tchart: chart\r\n\t});\r\n\r\n\tcore_layouts.configure(chart, title, titleOpts);\r\n\tcore_layouts.addBox(chart, title);\r\n\tchart.titleBlock = title;\r\n}\r\n\r\nvar plugin_title = {\r\n\tid: 'title',\r\n\r\n\t/**\r\n\t * Backward compatibility: since 2.1.5, the title is registered as a plugin, making\r\n\t * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of\r\n\t * the plugin, which one will be re-exposed in the chart.js file.\r\n\t * https://github.com/chartjs/Chart.js/pull/2640\r\n\t * @private\r\n\t */\r\n\t_element: Title,\r\n\r\n\tbeforeInit: function(chart) {\r\n\t\tvar titleOpts = chart.options.title;\r\n\r\n\t\tif (titleOpts) {\r\n\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\r\n\t\t}\r\n\t},\r\n\r\n\tbeforeUpdate: function(chart) {\r\n\t\tvar titleOpts = chart.options.title;\r\n\t\tvar titleBlock = chart.titleBlock;\r\n\r\n\t\tif (titleOpts) {\r\n\t\t\thelpers$1.mergeIf(titleOpts, core_defaults.global.title);\r\n\r\n\t\t\tif (titleBlock) {\r\n\t\t\t\tcore_layouts.configure(chart, titleBlock, titleOpts);\r\n\t\t\t\ttitleBlock.options = titleOpts;\r\n\t\t\t} else {\r\n\t\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\r\n\t\t\t}\r\n\t\t} else if (titleBlock) {\r\n\t\t\tcore_layouts.removeBox(chart, titleBlock);\r\n\t\t\tdelete chart.titleBlock;\r\n\t\t}\r\n\t}\r\n};\n\nvar plugins = {};\r\nvar filler = plugin_filler;\r\nvar legend = plugin_legend;\r\nvar title = plugin_title;\nplugins.filler = filler;\nplugins.legend = legend;\nplugins.title = title;\n\n/**\r\n * @namespace Chart\r\n */\r\n\r\n\r\ncore_controller.helpers = helpers$1;\r\n\r\n// @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!\r\ncore_helpers();\r\n\r\ncore_controller._adapters = core_adapters;\r\ncore_controller.Animation = core_animation;\r\ncore_controller.animationService = core_animations;\r\ncore_controller.controllers = controllers;\r\ncore_controller.DatasetController = core_datasetController;\r\ncore_controller.defaults = core_defaults;\r\ncore_controller.Element = core_element;\r\ncore_controller.elements = elements;\r\ncore_controller.Interaction = core_interaction;\r\ncore_controller.layouts = core_layouts;\r\ncore_controller.platform = platform;\r\ncore_controller.plugins = core_plugins;\r\ncore_controller.Scale = core_scale;\r\ncore_controller.scaleService = core_scaleService;\r\ncore_controller.Ticks = core_ticks;\r\ncore_controller.Tooltip = core_tooltip;\r\n\r\n// Register built-in scales\r\n\r\ncore_controller.helpers.each(scales, function(scale, type) {\r\n\tcore_controller.scaleService.registerScaleType(type, scale, scale._defaults);\r\n});\r\n\r\n// Load to register built-in adapters (as side effects)\r\n\r\n\r\n// Loading built-in plugins\r\n\r\nfor (var k in plugins) {\r\n\tif (plugins.hasOwnProperty(k)) {\r\n\t\tcore_controller.plugins.register(plugins[k]);\r\n\t}\r\n}\r\n\r\ncore_controller.platform.initialize();\r\n\r\nvar src = core_controller;\r\nif (typeof window !== 'undefined') {\r\n\twindow.Chart = core_controller;\r\n}\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n * Provided for backward compatibility, not available anymore\r\n * @namespace Chart.Chart\r\n * @deprecated since version 2.8.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\ncore_controller.Chart = core_controller;\r\n\r\n/**\r\n * Provided for backward compatibility, not available anymore\r\n * @namespace Chart.Legend\r\n * @deprecated since version 2.1.5\r\n * @todo remove at version 3\r\n * @private\r\n */\r\ncore_controller.Legend = plugins.legend._element;\r\n\r\n/**\r\n * Provided for backward compatibility, not available anymore\r\n * @namespace Chart.Title\r\n * @deprecated since version 2.1.5\r\n * @todo remove at version 3\r\n * @private\r\n */\r\ncore_controller.Title = plugins.title._element;\r\n\r\n/**\r\n * Provided for backward compatibility, use Chart.plugins instead\r\n * @namespace Chart.pluginService\r\n * @deprecated since version 2.1.5\r\n * @todo remove at version 3\r\n * @private\r\n */\r\ncore_controller.pluginService = core_controller.plugins;\r\n\r\n/**\r\n * Provided for backward compatibility, inheriting from Chart.PlugingBase has no\r\n * effect, instead simply create/register plugins via plain JavaScript objects.\r\n * @interface Chart.PluginBase\r\n * @deprecated since version 2.5.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\ncore_controller.PluginBase = core_controller.Element.extend({});\r\n\r\n/**\r\n * Provided for backward compatibility, use Chart.helpers.canvas instead.\r\n * @namespace Chart.canvasHelpers\r\n * @deprecated since version 2.6.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\ncore_controller.canvasHelpers = core_controller.helpers.canvas;\r\n\r\n/**\r\n * Provided for backward compatibility, use Chart.layouts instead.\r\n * @namespace Chart.layoutService\r\n * @deprecated since version 2.7.3\r\n * @todo remove at version 3\r\n * @private\r\n */\r\ncore_controller.layoutService = core_controller.layouts;\r\n\r\n/**\r\n * Provided for backward compatibility, not available anymore.\r\n * @namespace Chart.LinearScaleBase\r\n * @deprecated since version 2.8\r\n * @todo remove at version 3\r\n * @private\r\n */\r\ncore_controller.LinearScaleBase = scale_linearbase;\r\n\r\n/**\r\n * Provided for backward compatibility, instead we should create a new Chart\r\n * by setting the type in the config (`new Chart(id, {type: '{chart-type}'}`).\r\n * @deprecated since version 2.8.0\r\n * @todo remove at version 3\r\n */\r\ncore_controller.helpers.each(\r\n\t[\r\n\t\t'Bar',\r\n\t\t'Bubble',\r\n\t\t'Doughnut',\r\n\t\t'Line',\r\n\t\t'PolarArea',\r\n\t\t'Radar',\r\n\t\t'Scatter'\r\n\t],\r\n\tfunction(klass) {\r\n\t\tcore_controller[klass] = function(ctx, cfg) {\r\n\t\t\treturn new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {\r\n\t\t\t\ttype: klass.charAt(0).toLowerCase() + klass.slice(1)\r\n\t\t\t}));\r\n\t\t};\r\n\t}\r\n);\n\nreturn src;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTU8ray5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L0NoYXJ0LmpzPzMwZWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDaGFydC5qcyB2Mi45LjRcbiAqIGh0dHBzOi8vd3d3LmNoYXJ0anMub3JnXG4gKiAoYykgMjAyMCBDaGFydC5qcyBDb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGZ1bmN0aW9uKCkgeyB0cnkgeyByZXR1cm4gcmVxdWlyZSgnbW9tZW50Jyk7IH0gY2F0Y2goZSkgeyB9IH0oKSkgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsncmVxdWlyZSddLCBmdW5jdGlvbihyZXF1aXJlKSB7IHJldHVybiBmYWN0b3J5KGZ1bmN0aW9uKCkgeyB0cnkgeyByZXR1cm4gcmVxdWlyZSgnbW9tZW50Jyk7IH0gY2F0Y2goZSkgeyB9IH0oKSk7IH0pIDpcbihnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLkNoYXJ0ID0gZmFjdG9yeShnbG9iYWwubW9tZW50KSk7XG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxubW9tZW50ID0gbW9tZW50ICYmIG1vbWVudC5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdCcpID8gbW9tZW50WydkZWZhdWx0J10gOiBtb21lbnQ7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG5mdW5jdGlvbiBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlIChuKSB7XG5cdHJldHVybiBuICYmIG5bJ2RlZmF1bHQnXSB8fCBuO1xufVxuXG52YXIgY29sb3JOYW1lID0ge1xyXG5cdFwiYWxpY2VibHVlXCI6IFsyNDAsIDI0OCwgMjU1XSxcclxuXHRcImFudGlxdWV3aGl0ZVwiOiBbMjUwLCAyMzUsIDIxNV0sXHJcblx0XCJhcXVhXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJhcXVhbWFyaW5lXCI6IFsxMjcsIDI1NSwgMjEyXSxcclxuXHRcImF6dXJlXCI6IFsyNDAsIDI1NSwgMjU1XSxcclxuXHRcImJlaWdlXCI6IFsyNDUsIDI0NSwgMjIwXSxcclxuXHRcImJpc3F1ZVwiOiBbMjU1LCAyMjgsIDE5Nl0sXHJcblx0XCJibGFja1wiOiBbMCwgMCwgMF0sXHJcblx0XCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LCAyMzUsIDIwNV0sXHJcblx0XCJibHVlXCI6IFswLCAwLCAyNTVdLFxyXG5cdFwiYmx1ZXZpb2xldFwiOiBbMTM4LCA0MywgMjI2XSxcclxuXHRcImJyb3duXCI6IFsxNjUsIDQyLCA0Ml0sXHJcblx0XCJidXJseXdvb2RcIjogWzIyMiwgMTg0LCAxMzVdLFxyXG5cdFwiY2FkZXRibHVlXCI6IFs5NSwgMTU4LCAxNjBdLFxyXG5cdFwiY2hhcnRyZXVzZVwiOiBbMTI3LCAyNTUsIDBdLFxyXG5cdFwiY2hvY29sYXRlXCI6IFsyMTAsIDEwNSwgMzBdLFxyXG5cdFwiY29yYWxcIjogWzI1NSwgMTI3LCA4MF0sXHJcblx0XCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLCAxNDksIDIzN10sXHJcblx0XCJjb3Juc2lsa1wiOiBbMjU1LCAyNDgsIDIyMF0sXHJcblx0XCJjcmltc29uXCI6IFsyMjAsIDIwLCA2MF0sXHJcblx0XCJjeWFuXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJkYXJrYmx1ZVwiOiBbMCwgMCwgMTM5XSxcclxuXHRcImRhcmtjeWFuXCI6IFswLCAxMzksIDEzOV0sXHJcblx0XCJkYXJrZ29sZGVucm9kXCI6IFsxODQsIDEzNCwgMTFdLFxyXG5cdFwiZGFya2dyYXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2dyZWVuXCI6IFswLCAxMDAsIDBdLFxyXG5cdFwiZGFya2dyZXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2toYWtpXCI6IFsxODksIDE4MywgMTA3XSxcclxuXHRcImRhcmttYWdlbnRhXCI6IFsxMzksIDAsIDEzOV0sXHJcblx0XCJkYXJrb2xpdmVncmVlblwiOiBbODUsIDEwNywgNDddLFxyXG5cdFwiZGFya29yYW5nZVwiOiBbMjU1LCAxNDAsIDBdLFxyXG5cdFwiZGFya29yY2hpZFwiOiBbMTUzLCA1MCwgMjA0XSxcclxuXHRcImRhcmtyZWRcIjogWzEzOSwgMCwgMF0sXHJcblx0XCJkYXJrc2FsbW9uXCI6IFsyMzMsIDE1MCwgMTIyXSxcclxuXHRcImRhcmtzZWFncmVlblwiOiBbMTQzLCAxODgsIDE0M10sXHJcblx0XCJkYXJrc2xhdGVibHVlXCI6IFs3MiwgNjEsIDEzOV0sXHJcblx0XCJkYXJrc2xhdGVncmF5XCI6IFs0NywgNzksIDc5XSxcclxuXHRcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3R1cnF1b2lzZVwiOiBbMCwgMjA2LCAyMDldLFxyXG5cdFwiZGFya3Zpb2xldFwiOiBbMTQ4LCAwLCAyMTFdLFxyXG5cdFwiZGVlcHBpbmtcIjogWzI1NSwgMjAsIDE0N10sXHJcblx0XCJkZWVwc2t5Ymx1ZVwiOiBbMCwgMTkxLCAyNTVdLFxyXG5cdFwiZGltZ3JheVwiOiBbMTA1LCAxMDUsIDEwNV0sXHJcblx0XCJkaW1ncmV5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRvZGdlcmJsdWVcIjogWzMwLCAxNDQsIDI1NV0sXHJcblx0XCJmaXJlYnJpY2tcIjogWzE3OCwgMzQsIDM0XSxcclxuXHRcImZsb3JhbHdoaXRlXCI6IFsyNTUsIDI1MCwgMjQwXSxcclxuXHRcImZvcmVzdGdyZWVuXCI6IFszNCwgMTM5LCAzNF0sXHJcblx0XCJmdWNoc2lhXCI6IFsyNTUsIDAsIDI1NV0sXHJcblx0XCJnYWluc2Jvcm9cIjogWzIyMCwgMjIwLCAyMjBdLFxyXG5cdFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LCAyNDgsIDI1NV0sXHJcblx0XCJnb2xkXCI6IFsyNTUsIDIxNSwgMF0sXHJcblx0XCJnb2xkZW5yb2RcIjogWzIxOCwgMTY1LCAzMl0sXHJcblx0XCJncmF5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImdyZWVuXCI6IFswLCAxMjgsIDBdLFxyXG5cdFwiZ3JlZW55ZWxsb3dcIjogWzE3MywgMjU1LCA0N10sXHJcblx0XCJncmV5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImhvbmV5ZGV3XCI6IFsyNDAsIDI1NSwgMjQwXSxcclxuXHRcImhvdHBpbmtcIjogWzI1NSwgMTA1LCAxODBdLFxyXG5cdFwiaW5kaWFucmVkXCI6IFsyMDUsIDkyLCA5Ml0sXHJcblx0XCJpbmRpZ29cIjogWzc1LCAwLCAxMzBdLFxyXG5cdFwiaXZvcnlcIjogWzI1NSwgMjU1LCAyNDBdLFxyXG5cdFwia2hha2lcIjogWzI0MCwgMjMwLCAxNDBdLFxyXG5cdFwibGF2ZW5kZXJcIjogWzIzMCwgMjMwLCAyNTBdLFxyXG5cdFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LCAyNDAsIDI0NV0sXHJcblx0XCJsYXduZ3JlZW5cIjogWzEyNCwgMjUyLCAwXSxcclxuXHRcImxlbW9uY2hpZmZvblwiOiBbMjU1LCAyNTAsIDIwNV0sXHJcblx0XCJsaWdodGJsdWVcIjogWzE3MywgMjE2LCAyMzBdLFxyXG5cdFwibGlnaHRjb3JhbFwiOiBbMjQwLCAxMjgsIDEyOF0sXHJcblx0XCJsaWdodGN5YW5cIjogWzIyNCwgMjU1LCAyNTVdLFxyXG5cdFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwgMjUwLCAyMTBdLFxyXG5cdFwibGlnaHRncmF5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0Z3JlZW5cIjogWzE0NCwgMjM4LCAxNDRdLFxyXG5cdFwibGlnaHRncmV5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0cGlua1wiOiBbMjU1LCAxODIsIDE5M10sXHJcblx0XCJsaWdodHNhbG1vblwiOiBbMjU1LCAxNjAsIDEyMl0sXHJcblx0XCJsaWdodHNlYWdyZWVuXCI6IFszMiwgMTc4LCAxNzBdLFxyXG5cdFwibGlnaHRza3libHVlXCI6IFsxMzUsIDIwNiwgMjUwXSxcclxuXHRcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsIDE5NiwgMjIyXSxcclxuXHRcImxpZ2h0eWVsbG93XCI6IFsyNTUsIDI1NSwgMjI0XSxcclxuXHRcImxpbWVcIjogWzAsIDI1NSwgMF0sXHJcblx0XCJsaW1lZ3JlZW5cIjogWzUwLCAyMDUsIDUwXSxcclxuXHRcImxpbmVuXCI6IFsyNTAsIDI0MCwgMjMwXSxcclxuXHRcIm1hZ2VudGFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcIm1hcm9vblwiOiBbMTI4LCAwLCAwXSxcclxuXHRcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwgMjA1LCAxNzBdLFxyXG5cdFwibWVkaXVtYmx1ZVwiOiBbMCwgMCwgMjA1XSxcclxuXHRcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LCA4NSwgMjExXSxcclxuXHRcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LCAxMTIsIDIxOV0sXHJcblx0XCJtZWRpdW1zZWFncmVlblwiOiBbNjAsIDE3OSwgMTEzXSxcclxuXHRcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLCAxMDQsIDIzOF0sXHJcblx0XCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwgMjUwLCAxNTRdLFxyXG5cdFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwgMjA5LCAyMDRdLFxyXG5cdFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksIDIxLCAxMzNdLFxyXG5cdFwibWlkbmlnaHRibHVlXCI6IFsyNSwgMjUsIDExMl0sXHJcblx0XCJtaW50Y3JlYW1cIjogWzI0NSwgMjU1LCAyNTBdLFxyXG5cdFwibWlzdHlyb3NlXCI6IFsyNTUsIDIyOCwgMjI1XSxcclxuXHRcIm1vY2Nhc2luXCI6IFsyNTUsIDIyOCwgMTgxXSxcclxuXHRcIm5hdmFqb3doaXRlXCI6IFsyNTUsIDIyMiwgMTczXSxcclxuXHRcIm5hdnlcIjogWzAsIDAsIDEyOF0sXHJcblx0XCJvbGRsYWNlXCI6IFsyNTMsIDI0NSwgMjMwXSxcclxuXHRcIm9saXZlXCI6IFsxMjgsIDEyOCwgMF0sXHJcblx0XCJvbGl2ZWRyYWJcIjogWzEwNywgMTQyLCAzNV0sXHJcblx0XCJvcmFuZ2VcIjogWzI1NSwgMTY1LCAwXSxcclxuXHRcIm9yYW5nZXJlZFwiOiBbMjU1LCA2OSwgMF0sXHJcblx0XCJvcmNoaWRcIjogWzIxOCwgMTEyLCAyMTRdLFxyXG5cdFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LCAyMzIsIDE3MF0sXHJcblx0XCJwYWxlZ3JlZW5cIjogWzE1MiwgMjUxLCAxNTJdLFxyXG5cdFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LCAyMzgsIDIzOF0sXHJcblx0XCJwYWxldmlvbGV0cmVkXCI6IFsyMTksIDExMiwgMTQ3XSxcclxuXHRcInBhcGF5YXdoaXBcIjogWzI1NSwgMjM5LCAyMTNdLFxyXG5cdFwicGVhY2hwdWZmXCI6IFsyNTUsIDIxOCwgMTg1XSxcclxuXHRcInBlcnVcIjogWzIwNSwgMTMzLCA2M10sXHJcblx0XCJwaW5rXCI6IFsyNTUsIDE5MiwgMjAzXSxcclxuXHRcInBsdW1cIjogWzIyMSwgMTYwLCAyMjFdLFxyXG5cdFwicG93ZGVyYmx1ZVwiOiBbMTc2LCAyMjQsIDIzMF0sXHJcblx0XCJwdXJwbGVcIjogWzEyOCwgMCwgMTI4XSxcclxuXHRcInJlYmVjY2FwdXJwbGVcIjogWzEwMiwgNTEsIDE1M10sXHJcblx0XCJyZWRcIjogWzI1NSwgMCwgMF0sXHJcblx0XCJyb3N5YnJvd25cIjogWzE4OCwgMTQzLCAxNDNdLFxyXG5cdFwicm95YWxibHVlXCI6IFs2NSwgMTA1LCAyMjVdLFxyXG5cdFwic2FkZGxlYnJvd25cIjogWzEzOSwgNjksIDE5XSxcclxuXHRcInNhbG1vblwiOiBbMjUwLCAxMjgsIDExNF0sXHJcblx0XCJzYW5keWJyb3duXCI6IFsyNDQsIDE2NCwgOTZdLFxyXG5cdFwic2VhZ3JlZW5cIjogWzQ2LCAxMzksIDg3XSxcclxuXHRcInNlYXNoZWxsXCI6IFsyNTUsIDI0NSwgMjM4XSxcclxuXHRcInNpZW5uYVwiOiBbMTYwLCA4MiwgNDVdLFxyXG5cdFwic2lsdmVyXCI6IFsxOTIsIDE5MiwgMTkyXSxcclxuXHRcInNreWJsdWVcIjogWzEzNSwgMjA2LCAyMzVdLFxyXG5cdFwic2xhdGVibHVlXCI6IFsxMDYsIDkwLCAyMDVdLFxyXG5cdFwic2xhdGVncmF5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNsYXRlZ3JleVwiOiBbMTEyLCAxMjgsIDE0NF0sXHJcblx0XCJzbm93XCI6IFsyNTUsIDI1MCwgMjUwXSxcclxuXHRcInNwcmluZ2dyZWVuXCI6IFswLCAyNTUsIDEyN10sXHJcblx0XCJzdGVlbGJsdWVcIjogWzcwLCAxMzAsIDE4MF0sXHJcblx0XCJ0YW5cIjogWzIxMCwgMTgwLCAxNDBdLFxyXG5cdFwidGVhbFwiOiBbMCwgMTI4LCAxMjhdLFxyXG5cdFwidGhpc3RsZVwiOiBbMjE2LCAxOTEsIDIxNl0sXHJcblx0XCJ0b21hdG9cIjogWzI1NSwgOTksIDcxXSxcclxuXHRcInR1cnF1b2lzZVwiOiBbNjQsIDIyNCwgMjA4XSxcclxuXHRcInZpb2xldFwiOiBbMjM4LCAxMzAsIDIzOF0sXHJcblx0XCJ3aGVhdFwiOiBbMjQ1LCAyMjIsIDE3OV0sXHJcblx0XCJ3aGl0ZVwiOiBbMjU1LCAyNTUsIDI1NV0sXHJcblx0XCJ3aGl0ZXNtb2tlXCI6IFsyNDUsIDI0NSwgMjQ1XSxcclxuXHRcInllbGxvd1wiOiBbMjU1LCAyNTUsIDBdLFxyXG5cdFwieWVsbG93Z3JlZW5cIjogWzE1NCwgMjA1LCA1MF1cclxufTtcblxudmFyIGNvbnZlcnNpb25zID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuLyogTUlUIGxpY2Vuc2UgKi9cblxuXG4vLyBOT1RFOiBjb252ZXJzaW9ucyBzaG91bGQgb25seSByZXR1cm4gcHJpbWl0aXZlIHZhbHVlcyAoaS5lLiBhcnJheXMsIG9yXG4vLyAgICAgICB2YWx1ZXMgdGhhdCBnaXZlIGNvcnJlY3QgYHR5cGVvZmAgcmVzdWx0cykuXG4vLyAgICAgICBkbyBub3QgdXNlIGJveCB2YWx1ZXMgdHlwZXMgKGkuZS4gTnVtYmVyKCksIFN0cmluZygpLCBldGMuKVxuXG52YXIgcmV2ZXJzZUtleXdvcmRzID0ge307XG5mb3IgKHZhciBrZXkgaW4gY29sb3JOYW1lKSB7XG5cdGlmIChjb2xvck5hbWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdHJldmVyc2VLZXl3b3Jkc1tjb2xvck5hbWVba2V5XV0gPSBrZXk7XG5cdH1cbn1cblxudmFyIGNvbnZlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IHtcblx0cmdiOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ3JnYid9LFxuXHRoc2w6IHtjaGFubmVsczogMywgbGFiZWxzOiAnaHNsJ30sXG5cdGhzdjoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdoc3YnfSxcblx0aHdiOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ2h3Yid9LFxuXHRjbXlrOiB7Y2hhbm5lbHM6IDQsIGxhYmVsczogJ2NteWsnfSxcblx0eHl6OiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ3h5eid9LFxuXHRsYWI6IHtjaGFubmVsczogMywgbGFiZWxzOiAnbGFiJ30sXG5cdGxjaDoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdsY2gnfSxcblx0aGV4OiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydoZXgnXX0sXG5cdGtleXdvcmQ6IHtjaGFubmVsczogMSwgbGFiZWxzOiBbJ2tleXdvcmQnXX0sXG5cdGFuc2kxNjoge2NoYW5uZWxzOiAxLCBsYWJlbHM6IFsnYW5zaTE2J119LFxuXHRhbnNpMjU2OiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydhbnNpMjU2J119LFxuXHRoY2c6IHtjaGFubmVsczogMywgbGFiZWxzOiBbJ2gnLCAnYycsICdnJ119LFxuXHRhcHBsZToge2NoYW5uZWxzOiAzLCBsYWJlbHM6IFsncjE2JywgJ2cxNicsICdiMTYnXX0sXG5cdGdyYXk6IHtjaGFubmVsczogMSwgbGFiZWxzOiBbJ2dyYXknXX1cbn07XG5cbi8vIGhpZGUgLmNoYW5uZWxzIGFuZCAubGFiZWxzIHByb3BlcnRpZXNcbmZvciAodmFyIG1vZGVsIGluIGNvbnZlcnQpIHtcblx0aWYgKGNvbnZlcnQuaGFzT3duUHJvcGVydHkobW9kZWwpKSB7XG5cdFx0aWYgKCEoJ2NoYW5uZWxzJyBpbiBjb252ZXJ0W21vZGVsXSkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignbWlzc2luZyBjaGFubmVscyBwcm9wZXJ0eTogJyArIG1vZGVsKTtcblx0XHR9XG5cblx0XHRpZiAoISgnbGFiZWxzJyBpbiBjb252ZXJ0W21vZGVsXSkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignbWlzc2luZyBjaGFubmVsIGxhYmVscyBwcm9wZXJ0eTogJyArIG1vZGVsKTtcblx0XHR9XG5cblx0XHRpZiAoY29udmVydFttb2RlbF0ubGFiZWxzLmxlbmd0aCAhPT0gY29udmVydFttb2RlbF0uY2hhbm5lbHMpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignY2hhbm5lbCBhbmQgbGFiZWwgY291bnRzIG1pc21hdGNoOiAnICsgbW9kZWwpO1xuXHRcdH1cblxuXHRcdHZhciBjaGFubmVscyA9IGNvbnZlcnRbbW9kZWxdLmNoYW5uZWxzO1xuXHRcdHZhciBsYWJlbHMgPSBjb252ZXJ0W21vZGVsXS5sYWJlbHM7XG5cdFx0ZGVsZXRlIGNvbnZlcnRbbW9kZWxdLmNoYW5uZWxzO1xuXHRcdGRlbGV0ZSBjb252ZXJ0W21vZGVsXS5sYWJlbHM7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbbW9kZWxdLCAnY2hhbm5lbHMnLCB7dmFsdWU6IGNoYW5uZWxzfSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbbW9kZWxdLCAnbGFiZWxzJywge3ZhbHVlOiBsYWJlbHN9KTtcblx0fVxufVxuXG5jb252ZXJ0LnJnYi5oc2wgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByID0gcmdiWzBdIC8gMjU1O1xuXHR2YXIgZyA9IHJnYlsxXSAvIDI1NTtcblx0dmFyIGIgPSByZ2JbMl0gLyAyNTU7XG5cdHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcblx0dmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuXHR2YXIgZGVsdGEgPSBtYXggLSBtaW47XG5cdHZhciBoO1xuXHR2YXIgcztcblx0dmFyIGw7XG5cblx0aWYgKG1heCA9PT0gbWluKSB7XG5cdFx0aCA9IDA7XG5cdH0gZWxzZSBpZiAociA9PT0gbWF4KSB7XG5cdFx0aCA9IChnIC0gYikgLyBkZWx0YTtcblx0fSBlbHNlIGlmIChnID09PSBtYXgpIHtcblx0XHRoID0gMiArIChiIC0gcikgLyBkZWx0YTtcblx0fSBlbHNlIGlmIChiID09PSBtYXgpIHtcblx0XHRoID0gNCArIChyIC0gZykgLyBkZWx0YTtcblx0fVxuXG5cdGggPSBNYXRoLm1pbihoICogNjAsIDM2MCk7XG5cblx0aWYgKGggPCAwKSB7XG5cdFx0aCArPSAzNjA7XG5cdH1cblxuXHRsID0gKG1pbiArIG1heCkgLyAyO1xuXG5cdGlmIChtYXggPT09IG1pbikge1xuXHRcdHMgPSAwO1xuXHR9IGVsc2UgaWYgKGwgPD0gMC41KSB7XG5cdFx0cyA9IGRlbHRhIC8gKG1heCArIG1pbik7XG5cdH0gZWxzZSB7XG5cdFx0cyA9IGRlbHRhIC8gKDIgLSBtYXggLSBtaW4pO1xuXHR9XG5cblx0cmV0dXJuIFtoLCBzICogMTAwLCBsICogMTAwXTtcbn07XG5cbmNvbnZlcnQucmdiLmhzdiA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHJkaWY7XG5cdHZhciBnZGlmO1xuXHR2YXIgYmRpZjtcblx0dmFyIGg7XG5cdHZhciBzO1xuXG5cdHZhciByID0gcmdiWzBdIC8gMjU1O1xuXHR2YXIgZyA9IHJnYlsxXSAvIDI1NTtcblx0dmFyIGIgPSByZ2JbMl0gLyAyNTU7XG5cdHZhciB2ID0gTWF0aC5tYXgociwgZywgYik7XG5cdHZhciBkaWZmID0gdiAtIE1hdGgubWluKHIsIGcsIGIpO1xuXHR2YXIgZGlmZmMgPSBmdW5jdGlvbiAoYykge1xuXHRcdHJldHVybiAodiAtIGMpIC8gNiAvIGRpZmYgKyAxIC8gMjtcblx0fTtcblxuXHRpZiAoZGlmZiA9PT0gMCkge1xuXHRcdGggPSBzID0gMDtcblx0fSBlbHNlIHtcblx0XHRzID0gZGlmZiAvIHY7XG5cdFx0cmRpZiA9IGRpZmZjKHIpO1xuXHRcdGdkaWYgPSBkaWZmYyhnKTtcblx0XHRiZGlmID0gZGlmZmMoYik7XG5cblx0XHRpZiAociA9PT0gdikge1xuXHRcdFx0aCA9IGJkaWYgLSBnZGlmO1xuXHRcdH0gZWxzZSBpZiAoZyA9PT0gdikge1xuXHRcdFx0aCA9ICgxIC8gMykgKyByZGlmIC0gYmRpZjtcblx0XHR9IGVsc2UgaWYgKGIgPT09IHYpIHtcblx0XHRcdGggPSAoMiAvIDMpICsgZ2RpZiAtIHJkaWY7XG5cdFx0fVxuXHRcdGlmIChoIDwgMCkge1xuXHRcdFx0aCArPSAxO1xuXHRcdH0gZWxzZSBpZiAoaCA+IDEpIHtcblx0XHRcdGggLT0gMTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gW1xuXHRcdGggKiAzNjAsXG5cdFx0cyAqIDEwMCxcblx0XHR2ICogMTAwXG5cdF07XG59O1xuXG5jb252ZXJ0LnJnYi5od2IgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByID0gcmdiWzBdO1xuXHR2YXIgZyA9IHJnYlsxXTtcblx0dmFyIGIgPSByZ2JbMl07XG5cdHZhciBoID0gY29udmVydC5yZ2IuaHNsKHJnYilbMF07XG5cdHZhciB3ID0gMSAvIDI1NSAqIE1hdGgubWluKHIsIE1hdGgubWluKGcsIGIpKTtcblxuXHRiID0gMSAtIDEgLyAyNTUgKiBNYXRoLm1heChyLCBNYXRoLm1heChnLCBiKSk7XG5cblx0cmV0dXJuIFtoLCB3ICogMTAwLCBiICogMTAwXTtcbn07XG5cbmNvbnZlcnQucmdiLmNteWsgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByID0gcmdiWzBdIC8gMjU1O1xuXHR2YXIgZyA9IHJnYlsxXSAvIDI1NTtcblx0dmFyIGIgPSByZ2JbMl0gLyAyNTU7XG5cdHZhciBjO1xuXHR2YXIgbTtcblx0dmFyIHk7XG5cdHZhciBrO1xuXG5cdGsgPSBNYXRoLm1pbigxIC0gciwgMSAtIGcsIDEgLSBiKTtcblx0YyA9ICgxIC0gciAtIGspIC8gKDEgLSBrKSB8fCAwO1xuXHRtID0gKDEgLSBnIC0gaykgLyAoMSAtIGspIHx8IDA7XG5cdHkgPSAoMSAtIGIgLSBrKSAvICgxIC0gaykgfHwgMDtcblxuXHRyZXR1cm4gW2MgKiAxMDAsIG0gKiAxMDAsIHkgKiAxMDAsIGsgKiAxMDBdO1xufTtcblxuLyoqXG4gKiBTZWUgaHR0cHM6Ly9lbi5tLndpa2lwZWRpYS5vcmcvd2lraS9FdWNsaWRlYW5fZGlzdGFuY2UjU3F1YXJlZF9FdWNsaWRlYW5fZGlzdGFuY2VcbiAqICovXG5mdW5jdGlvbiBjb21wYXJhdGl2ZURpc3RhbmNlKHgsIHkpIHtcblx0cmV0dXJuIChcblx0XHRNYXRoLnBvdyh4WzBdIC0geVswXSwgMikgK1xuXHRcdE1hdGgucG93KHhbMV0gLSB5WzFdLCAyKSArXG5cdFx0TWF0aC5wb3coeFsyXSAtIHlbMl0sIDIpXG5cdCk7XG59XG5cbmNvbnZlcnQucmdiLmtleXdvcmQgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByZXZlcnNlZCA9IHJldmVyc2VLZXl3b3Jkc1tyZ2JdO1xuXHRpZiAocmV2ZXJzZWQpIHtcblx0XHRyZXR1cm4gcmV2ZXJzZWQ7XG5cdH1cblxuXHR2YXIgY3VycmVudENsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuXHR2YXIgY3VycmVudENsb3Nlc3RLZXl3b3JkO1xuXG5cdGZvciAodmFyIGtleXdvcmQgaW4gY29sb3JOYW1lKSB7XG5cdFx0aWYgKGNvbG9yTmFtZS5oYXNPd25Qcm9wZXJ0eShrZXl3b3JkKSkge1xuXHRcdFx0dmFyIHZhbHVlID0gY29sb3JOYW1lW2tleXdvcmRdO1xuXG5cdFx0XHQvLyBDb21wdXRlIGNvbXBhcmF0aXZlIGRpc3RhbmNlXG5cdFx0XHR2YXIgZGlzdGFuY2UgPSBjb21wYXJhdGl2ZURpc3RhbmNlKHJnYiwgdmFsdWUpO1xuXG5cdFx0XHQvLyBDaGVjayBpZiBpdHMgbGVzcywgaWYgc28gc2V0IGFzIGNsb3Nlc3Rcblx0XHRcdGlmIChkaXN0YW5jZSA8IGN1cnJlbnRDbG9zZXN0RGlzdGFuY2UpIHtcblx0XHRcdFx0Y3VycmVudENsb3Nlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuXHRcdFx0XHRjdXJyZW50Q2xvc2VzdEtleXdvcmQgPSBrZXl3b3JkO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjdXJyZW50Q2xvc2VzdEtleXdvcmQ7XG59O1xuXG5jb252ZXJ0LmtleXdvcmQucmdiID0gZnVuY3Rpb24gKGtleXdvcmQpIHtcblx0cmV0dXJuIGNvbG9yTmFtZVtrZXl3b3JkXTtcbn07XG5cbmNvbnZlcnQucmdiLnh5eiA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHIgPSByZ2JbMF0gLyAyNTU7XG5cdHZhciBnID0gcmdiWzFdIC8gMjU1O1xuXHR2YXIgYiA9IHJnYlsyXSAvIDI1NTtcblxuXHQvLyBhc3N1bWUgc1JHQlxuXHRyID0gciA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKHIgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAociAvIDEyLjkyKTtcblx0ZyA9IGcgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChnICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGcgLyAxMi45Mik7XG5cdGIgPSBiID4gMC4wNDA0NSA/IE1hdGgucG93KCgoYiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChiIC8gMTIuOTIpO1xuXG5cdHZhciB4ID0gKHIgKiAwLjQxMjQpICsgKGcgKiAwLjM1NzYpICsgKGIgKiAwLjE4MDUpO1xuXHR2YXIgeSA9IChyICogMC4yMTI2KSArIChnICogMC43MTUyKSArIChiICogMC4wNzIyKTtcblx0dmFyIHogPSAociAqIDAuMDE5MykgKyAoZyAqIDAuMTE5MikgKyAoYiAqIDAuOTUwNSk7XG5cblx0cmV0dXJuIFt4ICogMTAwLCB5ICogMTAwLCB6ICogMTAwXTtcbn07XG5cbmNvbnZlcnQucmdiLmxhYiA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHh5eiA9IGNvbnZlcnQucmdiLnh5eihyZ2IpO1xuXHR2YXIgeCA9IHh5elswXTtcblx0dmFyIHkgPSB4eXpbMV07XG5cdHZhciB6ID0geHl6WzJdO1xuXHR2YXIgbDtcblx0dmFyIGE7XG5cdHZhciBiO1xuXG5cdHggLz0gOTUuMDQ3O1xuXHR5IC89IDEwMDtcblx0eiAvPSAxMDguODgzO1xuXG5cdHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxIC8gMykgOiAoNy43ODcgKiB4KSArICgxNiAvIDExNik7XG5cdHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxIC8gMykgOiAoNy43ODcgKiB5KSArICgxNiAvIDExNik7XG5cdHogPSB6ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh6LCAxIC8gMykgOiAoNy43ODcgKiB6KSArICgxNiAvIDExNik7XG5cblx0bCA9ICgxMTYgKiB5KSAtIDE2O1xuXHRhID0gNTAwICogKHggLSB5KTtcblx0YiA9IDIwMCAqICh5IC0geik7XG5cblx0cmV0dXJuIFtsLCBhLCBiXTtcbn07XG5cbmNvbnZlcnQuaHNsLnJnYiA9IGZ1bmN0aW9uIChoc2wpIHtcblx0dmFyIGggPSBoc2xbMF0gLyAzNjA7XG5cdHZhciBzID0gaHNsWzFdIC8gMTAwO1xuXHR2YXIgbCA9IGhzbFsyXSAvIDEwMDtcblx0dmFyIHQxO1xuXHR2YXIgdDI7XG5cdHZhciB0Mztcblx0dmFyIHJnYjtcblx0dmFyIHZhbDtcblxuXHRpZiAocyA9PT0gMCkge1xuXHRcdHZhbCA9IGwgKiAyNTU7XG5cdFx0cmV0dXJuIFt2YWwsIHZhbCwgdmFsXTtcblx0fVxuXG5cdGlmIChsIDwgMC41KSB7XG5cdFx0dDIgPSBsICogKDEgKyBzKTtcblx0fSBlbHNlIHtcblx0XHR0MiA9IGwgKyBzIC0gbCAqIHM7XG5cdH1cblxuXHR0MSA9IDIgKiBsIC0gdDI7XG5cblx0cmdiID0gWzAsIDAsIDBdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdHQzID0gaCArIDEgLyAzICogLShpIC0gMSk7XG5cdFx0aWYgKHQzIDwgMCkge1xuXHRcdFx0dDMrKztcblx0XHR9XG5cdFx0aWYgKHQzID4gMSkge1xuXHRcdFx0dDMtLTtcblx0XHR9XG5cblx0XHRpZiAoNiAqIHQzIDwgMSkge1xuXHRcdFx0dmFsID0gdDEgKyAodDIgLSB0MSkgKiA2ICogdDM7XG5cdFx0fSBlbHNlIGlmICgyICogdDMgPCAxKSB7XG5cdFx0XHR2YWwgPSB0Mjtcblx0XHR9IGVsc2UgaWYgKDMgKiB0MyA8IDIpIHtcblx0XHRcdHZhbCA9IHQxICsgKHQyIC0gdDEpICogKDIgLyAzIC0gdDMpICogNjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsID0gdDE7XG5cdFx0fVxuXG5cdFx0cmdiW2ldID0gdmFsICogMjU1O1xuXHR9XG5cblx0cmV0dXJuIHJnYjtcbn07XG5cbmNvbnZlcnQuaHNsLmhzdiA9IGZ1bmN0aW9uIChoc2wpIHtcblx0dmFyIGggPSBoc2xbMF07XG5cdHZhciBzID0gaHNsWzFdIC8gMTAwO1xuXHR2YXIgbCA9IGhzbFsyXSAvIDEwMDtcblx0dmFyIHNtaW4gPSBzO1xuXHR2YXIgbG1pbiA9IE1hdGgubWF4KGwsIDAuMDEpO1xuXHR2YXIgc3Y7XG5cdHZhciB2O1xuXG5cdGwgKj0gMjtcblx0cyAqPSAobCA8PSAxKSA/IGwgOiAyIC0gbDtcblx0c21pbiAqPSBsbWluIDw9IDEgPyBsbWluIDogMiAtIGxtaW47XG5cdHYgPSAobCArIHMpIC8gMjtcblx0c3YgPSBsID09PSAwID8gKDIgKiBzbWluKSAvIChsbWluICsgc21pbikgOiAoMiAqIHMpIC8gKGwgKyBzKTtcblxuXHRyZXR1cm4gW2gsIHN2ICogMTAwLCB2ICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaHN2LnJnYiA9IGZ1bmN0aW9uIChoc3YpIHtcblx0dmFyIGggPSBoc3ZbMF0gLyA2MDtcblx0dmFyIHMgPSBoc3ZbMV0gLyAxMDA7XG5cdHZhciB2ID0gaHN2WzJdIC8gMTAwO1xuXHR2YXIgaGkgPSBNYXRoLmZsb29yKGgpICUgNjtcblxuXHR2YXIgZiA9IGggLSBNYXRoLmZsb29yKGgpO1xuXHR2YXIgcCA9IDI1NSAqIHYgKiAoMSAtIHMpO1xuXHR2YXIgcSA9IDI1NSAqIHYgKiAoMSAtIChzICogZikpO1xuXHR2YXIgdCA9IDI1NSAqIHYgKiAoMSAtIChzICogKDEgLSBmKSkpO1xuXHR2ICo9IDI1NTtcblxuXHRzd2l0Y2ggKGhpKSB7XG5cdFx0Y2FzZSAwOlxuXHRcdFx0cmV0dXJuIFt2LCB0LCBwXTtcblx0XHRjYXNlIDE6XG5cdFx0XHRyZXR1cm4gW3EsIHYsIHBdO1xuXHRcdGNhc2UgMjpcblx0XHRcdHJldHVybiBbcCwgdiwgdF07XG5cdFx0Y2FzZSAzOlxuXHRcdFx0cmV0dXJuIFtwLCBxLCB2XTtcblx0XHRjYXNlIDQ6XG5cdFx0XHRyZXR1cm4gW3QsIHAsIHZdO1xuXHRcdGNhc2UgNTpcblx0XHRcdHJldHVybiBbdiwgcCwgcV07XG5cdH1cbn07XG5cbmNvbnZlcnQuaHN2LmhzbCA9IGZ1bmN0aW9uIChoc3YpIHtcblx0dmFyIGggPSBoc3ZbMF07XG5cdHZhciBzID0gaHN2WzFdIC8gMTAwO1xuXHR2YXIgdiA9IGhzdlsyXSAvIDEwMDtcblx0dmFyIHZtaW4gPSBNYXRoLm1heCh2LCAwLjAxKTtcblx0dmFyIGxtaW47XG5cdHZhciBzbDtcblx0dmFyIGw7XG5cblx0bCA9ICgyIC0gcykgKiB2O1xuXHRsbWluID0gKDIgLSBzKSAqIHZtaW47XG5cdHNsID0gcyAqIHZtaW47XG5cdHNsIC89IChsbWluIDw9IDEpID8gbG1pbiA6IDIgLSBsbWluO1xuXHRzbCA9IHNsIHx8IDA7XG5cdGwgLz0gMjtcblxuXHRyZXR1cm4gW2gsIHNsICogMTAwLCBsICogMTAwXTtcbn07XG5cbi8vIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy1jb2xvci8jaHdiLXRvLXJnYlxuY29udmVydC5od2IucmdiID0gZnVuY3Rpb24gKGh3Yikge1xuXHR2YXIgaCA9IGh3YlswXSAvIDM2MDtcblx0dmFyIHdoID0gaHdiWzFdIC8gMTAwO1xuXHR2YXIgYmwgPSBod2JbMl0gLyAxMDA7XG5cdHZhciByYXRpbyA9IHdoICsgYmw7XG5cdHZhciBpO1xuXHR2YXIgdjtcblx0dmFyIGY7XG5cdHZhciBuO1xuXG5cdC8vIHdoICsgYmwgY2FudCBiZSA+IDFcblx0aWYgKHJhdGlvID4gMSkge1xuXHRcdHdoIC89IHJhdGlvO1xuXHRcdGJsIC89IHJhdGlvO1xuXHR9XG5cblx0aSA9IE1hdGguZmxvb3IoNiAqIGgpO1xuXHR2ID0gMSAtIGJsO1xuXHRmID0gNiAqIGggLSBpO1xuXG5cdGlmICgoaSAmIDB4MDEpICE9PSAwKSB7XG5cdFx0ZiA9IDEgLSBmO1xuXHR9XG5cblx0biA9IHdoICsgZiAqICh2IC0gd2gpOyAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvblxuXG5cdHZhciByO1xuXHR2YXIgZztcblx0dmFyIGI7XG5cdHN3aXRjaCAoaSkge1xuXHRcdGRlZmF1bHQ6XG5cdFx0Y2FzZSA2OlxuXHRcdGNhc2UgMDogciA9IHY7IGcgPSBuOyBiID0gd2g7IGJyZWFrO1xuXHRcdGNhc2UgMTogciA9IG47IGcgPSB2OyBiID0gd2g7IGJyZWFrO1xuXHRcdGNhc2UgMjogciA9IHdoOyBnID0gdjsgYiA9IG47IGJyZWFrO1xuXHRcdGNhc2UgMzogciA9IHdoOyBnID0gbjsgYiA9IHY7IGJyZWFrO1xuXHRcdGNhc2UgNDogciA9IG47IGcgPSB3aDsgYiA9IHY7IGJyZWFrO1xuXHRcdGNhc2UgNTogciA9IHY7IGcgPSB3aDsgYiA9IG47IGJyZWFrO1xuXHR9XG5cblx0cmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn07XG5cbmNvbnZlcnQuY215ay5yZ2IgPSBmdW5jdGlvbiAoY215aykge1xuXHR2YXIgYyA9IGNteWtbMF0gLyAxMDA7XG5cdHZhciBtID0gY215a1sxXSAvIDEwMDtcblx0dmFyIHkgPSBjbXlrWzJdIC8gMTAwO1xuXHR2YXIgayA9IGNteWtbM10gLyAxMDA7XG5cdHZhciByO1xuXHR2YXIgZztcblx0dmFyIGI7XG5cblx0ciA9IDEgLSBNYXRoLm1pbigxLCBjICogKDEgLSBrKSArIGspO1xuXHRnID0gMSAtIE1hdGgubWluKDEsIG0gKiAoMSAtIGspICsgayk7XG5cdGIgPSAxIC0gTWF0aC5taW4oMSwgeSAqICgxIC0gaykgKyBrKTtcblxuXHRyZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufTtcblxuY29udmVydC54eXoucmdiID0gZnVuY3Rpb24gKHh5eikge1xuXHR2YXIgeCA9IHh5elswXSAvIDEwMDtcblx0dmFyIHkgPSB4eXpbMV0gLyAxMDA7XG5cdHZhciB6ID0geHl6WzJdIC8gMTAwO1xuXHR2YXIgcjtcblx0dmFyIGc7XG5cdHZhciBiO1xuXG5cdHIgPSAoeCAqIDMuMjQwNikgKyAoeSAqIC0xLjUzNzIpICsgKHogKiAtMC40OTg2KTtcblx0ZyA9ICh4ICogLTAuOTY4OSkgKyAoeSAqIDEuODc1OCkgKyAoeiAqIDAuMDQxNSk7XG5cdGIgPSAoeCAqIDAuMDU1NykgKyAoeSAqIC0wLjIwNDApICsgKHogKiAxLjA1NzApO1xuXG5cdC8vIGFzc3VtZSBzUkdCXG5cdHIgPSByID4gMC4wMDMxMzA4XG5cdFx0PyAoKDEuMDU1ICogTWF0aC5wb3cociwgMS4wIC8gMi40KSkgLSAwLjA1NSlcblx0XHQ6IHIgKiAxMi45MjtcblxuXHRnID0gZyA+IDAuMDAzMTMwOFxuXHRcdD8gKCgxLjA1NSAqIE1hdGgucG93KGcsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG5cdFx0OiBnICogMTIuOTI7XG5cblx0YiA9IGIgPiAwLjAwMzEzMDhcblx0XHQ/ICgoMS4wNTUgKiBNYXRoLnBvdyhiLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuXHRcdDogYiAqIDEyLjkyO1xuXG5cdHIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCByKSwgMSk7XG5cdGcgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBnKSwgMSk7XG5cdGIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBiKSwgMSk7XG5cblx0cmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn07XG5cbmNvbnZlcnQueHl6LmxhYiA9IGZ1bmN0aW9uICh4eXopIHtcblx0dmFyIHggPSB4eXpbMF07XG5cdHZhciB5ID0geHl6WzFdO1xuXHR2YXIgeiA9IHh5elsyXTtcblx0dmFyIGw7XG5cdHZhciBhO1xuXHR2YXIgYjtcblxuXHR4IC89IDk1LjA0Nztcblx0eSAvPSAxMDA7XG5cdHogLz0gMTA4Ljg4MztcblxuXHR4ID0geCA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeCwgMSAvIDMpIDogKDcuNzg3ICogeCkgKyAoMTYgLyAxMTYpO1xuXHR5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMSAvIDMpIDogKDcuNzg3ICogeSkgKyAoMTYgLyAxMTYpO1xuXHR6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMSAvIDMpIDogKDcuNzg3ICogeikgKyAoMTYgLyAxMTYpO1xuXG5cdGwgPSAoMTE2ICogeSkgLSAxNjtcblx0YSA9IDUwMCAqICh4IC0geSk7XG5cdGIgPSAyMDAgKiAoeSAtIHopO1xuXG5cdHJldHVybiBbbCwgYSwgYl07XG59O1xuXG5jb252ZXJ0LmxhYi54eXogPSBmdW5jdGlvbiAobGFiKSB7XG5cdHZhciBsID0gbGFiWzBdO1xuXHR2YXIgYSA9IGxhYlsxXTtcblx0dmFyIGIgPSBsYWJbMl07XG5cdHZhciB4O1xuXHR2YXIgeTtcblx0dmFyIHo7XG5cblx0eSA9IChsICsgMTYpIC8gMTE2O1xuXHR4ID0gYSAvIDUwMCArIHk7XG5cdHogPSB5IC0gYiAvIDIwMDtcblxuXHR2YXIgeTIgPSBNYXRoLnBvdyh5LCAzKTtcblx0dmFyIHgyID0gTWF0aC5wb3coeCwgMyk7XG5cdHZhciB6MiA9IE1hdGgucG93KHosIDMpO1xuXHR5ID0geTIgPiAwLjAwODg1NiA/IHkyIDogKHkgLSAxNiAvIDExNikgLyA3Ljc4Nztcblx0eCA9IHgyID4gMC4wMDg4NTYgPyB4MiA6ICh4IC0gMTYgLyAxMTYpIC8gNy43ODc7XG5cdHogPSB6MiA+IDAuMDA4ODU2ID8gejIgOiAoeiAtIDE2IC8gMTE2KSAvIDcuNzg3O1xuXG5cdHggKj0gOTUuMDQ3O1xuXHR5ICo9IDEwMDtcblx0eiAqPSAxMDguODgzO1xuXG5cdHJldHVybiBbeCwgeSwgel07XG59O1xuXG5jb252ZXJ0LmxhYi5sY2ggPSBmdW5jdGlvbiAobGFiKSB7XG5cdHZhciBsID0gbGFiWzBdO1xuXHR2YXIgYSA9IGxhYlsxXTtcblx0dmFyIGIgPSBsYWJbMl07XG5cdHZhciBocjtcblx0dmFyIGg7XG5cdHZhciBjO1xuXG5cdGhyID0gTWF0aC5hdGFuMihiLCBhKTtcblx0aCA9IGhyICogMzYwIC8gMiAvIE1hdGguUEk7XG5cblx0aWYgKGggPCAwKSB7XG5cdFx0aCArPSAzNjA7XG5cdH1cblxuXHRjID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuXG5cdHJldHVybiBbbCwgYywgaF07XG59O1xuXG5jb252ZXJ0LmxjaC5sYWIgPSBmdW5jdGlvbiAobGNoKSB7XG5cdHZhciBsID0gbGNoWzBdO1xuXHR2YXIgYyA9IGxjaFsxXTtcblx0dmFyIGggPSBsY2hbMl07XG5cdHZhciBhO1xuXHR2YXIgYjtcblx0dmFyIGhyO1xuXG5cdGhyID0gaCAvIDM2MCAqIDIgKiBNYXRoLlBJO1xuXHRhID0gYyAqIE1hdGguY29zKGhyKTtcblx0YiA9IGMgKiBNYXRoLnNpbihocik7XG5cblx0cmV0dXJuIFtsLCBhLCBiXTtcbn07XG5cbmNvbnZlcnQucmdiLmFuc2kxNiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHZhciByID0gYXJnc1swXTtcblx0dmFyIGcgPSBhcmdzWzFdO1xuXHR2YXIgYiA9IGFyZ3NbMl07XG5cdHZhciB2YWx1ZSA9IDEgaW4gYXJndW1lbnRzID8gYXJndW1lbnRzWzFdIDogY29udmVydC5yZ2IuaHN2KGFyZ3MpWzJdOyAvLyBoc3YgLT4gYW5zaTE2IG9wdGltaXphdGlvblxuXG5cdHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAvIDUwKTtcblxuXHRpZiAodmFsdWUgPT09IDApIHtcblx0XHRyZXR1cm4gMzA7XG5cdH1cblxuXHR2YXIgYW5zaSA9IDMwXG5cdFx0KyAoKE1hdGgucm91bmQoYiAvIDI1NSkgPDwgMilcblx0XHR8IChNYXRoLnJvdW5kKGcgLyAyNTUpIDw8IDEpXG5cdFx0fCBNYXRoLnJvdW5kKHIgLyAyNTUpKTtcblxuXHRpZiAodmFsdWUgPT09IDIpIHtcblx0XHRhbnNpICs9IDYwO1xuXHR9XG5cblx0cmV0dXJuIGFuc2k7XG59O1xuXG5jb252ZXJ0Lmhzdi5hbnNpMTYgPSBmdW5jdGlvbiAoYXJncykge1xuXHQvLyBvcHRpbWl6YXRpb24gaGVyZTsgd2UgYWxyZWFkeSBrbm93IHRoZSB2YWx1ZSBhbmQgZG9uJ3QgbmVlZCB0byBnZXRcblx0Ly8gaXQgY29udmVydGVkIGZvciB1cy5cblx0cmV0dXJuIGNvbnZlcnQucmdiLmFuc2kxNihjb252ZXJ0Lmhzdi5yZ2IoYXJncyksIGFyZ3NbMl0pO1xufTtcblxuY29udmVydC5yZ2IuYW5zaTI1NiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHZhciByID0gYXJnc1swXTtcblx0dmFyIGcgPSBhcmdzWzFdO1xuXHR2YXIgYiA9IGFyZ3NbMl07XG5cblx0Ly8gd2UgdXNlIHRoZSBleHRlbmRlZCBncmV5c2NhbGUgcGFsZXR0ZSBoZXJlLCB3aXRoIHRoZSBleGNlcHRpb24gb2Zcblx0Ly8gYmxhY2sgYW5kIHdoaXRlLiBub3JtYWwgcGFsZXR0ZSBvbmx5IGhhcyA0IGdyZXlzY2FsZSBzaGFkZXMuXG5cdGlmIChyID09PSBnICYmIGcgPT09IGIpIHtcblx0XHRpZiAociA8IDgpIHtcblx0XHRcdHJldHVybiAxNjtcblx0XHR9XG5cblx0XHRpZiAociA+IDI0OCkge1xuXHRcdFx0cmV0dXJuIDIzMTtcblx0XHR9XG5cblx0XHRyZXR1cm4gTWF0aC5yb3VuZCgoKHIgLSA4KSAvIDI0NykgKiAyNCkgKyAyMzI7XG5cdH1cblxuXHR2YXIgYW5zaSA9IDE2XG5cdFx0KyAoMzYgKiBNYXRoLnJvdW5kKHIgLyAyNTUgKiA1KSlcblx0XHQrICg2ICogTWF0aC5yb3VuZChnIC8gMjU1ICogNSkpXG5cdFx0KyBNYXRoLnJvdW5kKGIgLyAyNTUgKiA1KTtcblxuXHRyZXR1cm4gYW5zaTtcbn07XG5cbmNvbnZlcnQuYW5zaTE2LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHZhciBjb2xvciA9IGFyZ3MgJSAxMDtcblxuXHQvLyBoYW5kbGUgZ3JleXNjYWxlXG5cdGlmIChjb2xvciA9PT0gMCB8fCBjb2xvciA9PT0gNykge1xuXHRcdGlmIChhcmdzID4gNTApIHtcblx0XHRcdGNvbG9yICs9IDMuNTtcblx0XHR9XG5cblx0XHRjb2xvciA9IGNvbG9yIC8gMTAuNSAqIDI1NTtcblxuXHRcdHJldHVybiBbY29sb3IsIGNvbG9yLCBjb2xvcl07XG5cdH1cblxuXHR2YXIgbXVsdCA9ICh+fihhcmdzID4gNTApICsgMSkgKiAwLjU7XG5cdHZhciByID0gKChjb2xvciAmIDEpICogbXVsdCkgKiAyNTU7XG5cdHZhciBnID0gKCgoY29sb3IgPj4gMSkgJiAxKSAqIG11bHQpICogMjU1O1xuXHR2YXIgYiA9ICgoKGNvbG9yID4+IDIpICYgMSkgKiBtdWx0KSAqIDI1NTtcblxuXHRyZXR1cm4gW3IsIGcsIGJdO1xufTtcblxuY29udmVydC5hbnNpMjU2LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdC8vIGhhbmRsZSBncmV5c2NhbGVcblx0aWYgKGFyZ3MgPj0gMjMyKSB7XG5cdFx0dmFyIGMgPSAoYXJncyAtIDIzMikgKiAxMCArIDg7XG5cdFx0cmV0dXJuIFtjLCBjLCBjXTtcblx0fVxuXG5cdGFyZ3MgLT0gMTY7XG5cblx0dmFyIHJlbTtcblx0dmFyIHIgPSBNYXRoLmZsb29yKGFyZ3MgLyAzNikgLyA1ICogMjU1O1xuXHR2YXIgZyA9IE1hdGguZmxvb3IoKHJlbSA9IGFyZ3MgJSAzNikgLyA2KSAvIDUgKiAyNTU7XG5cdHZhciBiID0gKHJlbSAlIDYpIC8gNSAqIDI1NTtcblxuXHRyZXR1cm4gW3IsIGcsIGJdO1xufTtcblxuY29udmVydC5yZ2IuaGV4ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0dmFyIGludGVnZXIgPSAoKE1hdGgucm91bmQoYXJnc1swXSkgJiAweEZGKSA8PCAxNilcblx0XHQrICgoTWF0aC5yb3VuZChhcmdzWzFdKSAmIDB4RkYpIDw8IDgpXG5cdFx0KyAoTWF0aC5yb3VuZChhcmdzWzJdKSAmIDB4RkYpO1xuXG5cdHZhciBzdHJpbmcgPSBpbnRlZ2VyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRyZXR1cm4gJzAwMDAwMCcuc3Vic3RyaW5nKHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufTtcblxuY29udmVydC5oZXgucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0dmFyIG1hdGNoID0gYXJncy50b1N0cmluZygxNikubWF0Y2goL1thLWYwLTldezZ9fFthLWYwLTldezN9L2kpO1xuXHRpZiAoIW1hdGNoKSB7XG5cdFx0cmV0dXJuIFswLCAwLCAwXTtcblx0fVxuXG5cdHZhciBjb2xvclN0cmluZyA9IG1hdGNoWzBdO1xuXG5cdGlmIChtYXRjaFswXS5sZW5ndGggPT09IDMpIHtcblx0XHRjb2xvclN0cmluZyA9IGNvbG9yU3RyaW5nLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24gKGNoYXIpIHtcblx0XHRcdHJldHVybiBjaGFyICsgY2hhcjtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdHZhciBpbnRlZ2VyID0gcGFyc2VJbnQoY29sb3JTdHJpbmcsIDE2KTtcblx0dmFyIHIgPSAoaW50ZWdlciA+PiAxNikgJiAweEZGO1xuXHR2YXIgZyA9IChpbnRlZ2VyID4+IDgpICYgMHhGRjtcblx0dmFyIGIgPSBpbnRlZ2VyICYgMHhGRjtcblxuXHRyZXR1cm4gW3IsIGcsIGJdO1xufTtcblxuY29udmVydC5yZ2IuaGNnID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgciA9IHJnYlswXSAvIDI1NTtcblx0dmFyIGcgPSByZ2JbMV0gLyAyNTU7XG5cdHZhciBiID0gcmdiWzJdIC8gMjU1O1xuXHR2YXIgbWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgociwgZyksIGIpO1xuXHR2YXIgbWluID0gTWF0aC5taW4oTWF0aC5taW4ociwgZyksIGIpO1xuXHR2YXIgY2hyb21hID0gKG1heCAtIG1pbik7XG5cdHZhciBncmF5c2NhbGU7XG5cdHZhciBodWU7XG5cblx0aWYgKGNocm9tYSA8IDEpIHtcblx0XHRncmF5c2NhbGUgPSBtaW4gLyAoMSAtIGNocm9tYSk7XG5cdH0gZWxzZSB7XG5cdFx0Z3JheXNjYWxlID0gMDtcblx0fVxuXG5cdGlmIChjaHJvbWEgPD0gMCkge1xuXHRcdGh1ZSA9IDA7XG5cdH0gZWxzZVxuXHRpZiAobWF4ID09PSByKSB7XG5cdFx0aHVlID0gKChnIC0gYikgLyBjaHJvbWEpICUgNjtcblx0fSBlbHNlXG5cdGlmIChtYXggPT09IGcpIHtcblx0XHRodWUgPSAyICsgKGIgLSByKSAvIGNocm9tYTtcblx0fSBlbHNlIHtcblx0XHRodWUgPSA0ICsgKHIgLSBnKSAvIGNocm9tYSArIDQ7XG5cdH1cblxuXHRodWUgLz0gNjtcblx0aHVlICU9IDE7XG5cblx0cmV0dXJuIFtodWUgKiAzNjAsIGNocm9tYSAqIDEwMCwgZ3JheXNjYWxlICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaHNsLmhjZyA9IGZ1bmN0aW9uIChoc2wpIHtcblx0dmFyIHMgPSBoc2xbMV0gLyAxMDA7XG5cdHZhciBsID0gaHNsWzJdIC8gMTAwO1xuXHR2YXIgYyA9IDE7XG5cdHZhciBmID0gMDtcblxuXHRpZiAobCA8IDAuNSkge1xuXHRcdGMgPSAyLjAgKiBzICogbDtcblx0fSBlbHNlIHtcblx0XHRjID0gMi4wICogcyAqICgxLjAgLSBsKTtcblx0fVxuXG5cdGlmIChjIDwgMS4wKSB7XG5cdFx0ZiA9IChsIC0gMC41ICogYykgLyAoMS4wIC0gYyk7XG5cdH1cblxuXHRyZXR1cm4gW2hzbFswXSwgYyAqIDEwMCwgZiAqIDEwMF07XG59O1xuXG5jb252ZXJ0Lmhzdi5oY2cgPSBmdW5jdGlvbiAoaHN2KSB7XG5cdHZhciBzID0gaHN2WzFdIC8gMTAwO1xuXHR2YXIgdiA9IGhzdlsyXSAvIDEwMDtcblxuXHR2YXIgYyA9IHMgKiB2O1xuXHR2YXIgZiA9IDA7XG5cblx0aWYgKGMgPCAxLjApIHtcblx0XHRmID0gKHYgLSBjKSAvICgxIC0gYyk7XG5cdH1cblxuXHRyZXR1cm4gW2hzdlswXSwgYyAqIDEwMCwgZiAqIDEwMF07XG59O1xuXG5jb252ZXJ0LmhjZy5yZ2IgPSBmdW5jdGlvbiAoaGNnKSB7XG5cdHZhciBoID0gaGNnWzBdIC8gMzYwO1xuXHR2YXIgYyA9IGhjZ1sxXSAvIDEwMDtcblx0dmFyIGcgPSBoY2dbMl0gLyAxMDA7XG5cblx0aWYgKGMgPT09IDAuMCkge1xuXHRcdHJldHVybiBbZyAqIDI1NSwgZyAqIDI1NSwgZyAqIDI1NV07XG5cdH1cblxuXHR2YXIgcHVyZSA9IFswLCAwLCAwXTtcblx0dmFyIGhpID0gKGggJSAxKSAqIDY7XG5cdHZhciB2ID0gaGkgJSAxO1xuXHR2YXIgdyA9IDEgLSB2O1xuXHR2YXIgbWcgPSAwO1xuXG5cdHN3aXRjaCAoTWF0aC5mbG9vcihoaSkpIHtcblx0XHRjYXNlIDA6XG5cdFx0XHRwdXJlWzBdID0gMTsgcHVyZVsxXSA9IHY7IHB1cmVbMl0gPSAwOyBicmVhaztcblx0XHRjYXNlIDE6XG5cdFx0XHRwdXJlWzBdID0gdzsgcHVyZVsxXSA9IDE7IHB1cmVbMl0gPSAwOyBicmVhaztcblx0XHRjYXNlIDI6XG5cdFx0XHRwdXJlWzBdID0gMDsgcHVyZVsxXSA9IDE7IHB1cmVbMl0gPSB2OyBicmVhaztcblx0XHRjYXNlIDM6XG5cdFx0XHRwdXJlWzBdID0gMDsgcHVyZVsxXSA9IHc7IHB1cmVbMl0gPSAxOyBicmVhaztcblx0XHRjYXNlIDQ6XG5cdFx0XHRwdXJlWzBdID0gdjsgcHVyZVsxXSA9IDA7IHB1cmVbMl0gPSAxOyBicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0cHVyZVswXSA9IDE7IHB1cmVbMV0gPSAwOyBwdXJlWzJdID0gdztcblx0fVxuXG5cdG1nID0gKDEuMCAtIGMpICogZztcblxuXHRyZXR1cm4gW1xuXHRcdChjICogcHVyZVswXSArIG1nKSAqIDI1NSxcblx0XHQoYyAqIHB1cmVbMV0gKyBtZykgKiAyNTUsXG5cdFx0KGMgKiBwdXJlWzJdICsgbWcpICogMjU1XG5cdF07XG59O1xuXG5jb252ZXJ0LmhjZy5oc3YgPSBmdW5jdGlvbiAoaGNnKSB7XG5cdHZhciBjID0gaGNnWzFdIC8gMTAwO1xuXHR2YXIgZyA9IGhjZ1syXSAvIDEwMDtcblxuXHR2YXIgdiA9IGMgKyBnICogKDEuMCAtIGMpO1xuXHR2YXIgZiA9IDA7XG5cblx0aWYgKHYgPiAwLjApIHtcblx0XHRmID0gYyAvIHY7XG5cdH1cblxuXHRyZXR1cm4gW2hjZ1swXSwgZiAqIDEwMCwgdiAqIDEwMF07XG59O1xuXG5jb252ZXJ0LmhjZy5oc2wgPSBmdW5jdGlvbiAoaGNnKSB7XG5cdHZhciBjID0gaGNnWzFdIC8gMTAwO1xuXHR2YXIgZyA9IGhjZ1syXSAvIDEwMDtcblxuXHR2YXIgbCA9IGcgKiAoMS4wIC0gYykgKyAwLjUgKiBjO1xuXHR2YXIgcyA9IDA7XG5cblx0aWYgKGwgPiAwLjAgJiYgbCA8IDAuNSkge1xuXHRcdHMgPSBjIC8gKDIgKiBsKTtcblx0fSBlbHNlXG5cdGlmIChsID49IDAuNSAmJiBsIDwgMS4wKSB7XG5cdFx0cyA9IGMgLyAoMiAqICgxIC0gbCkpO1xuXHR9XG5cblx0cmV0dXJuIFtoY2dbMF0sIHMgKiAxMDAsIGwgKiAxMDBdO1xufTtcblxuY29udmVydC5oY2cuaHdiID0gZnVuY3Rpb24gKGhjZykge1xuXHR2YXIgYyA9IGhjZ1sxXSAvIDEwMDtcblx0dmFyIGcgPSBoY2dbMl0gLyAxMDA7XG5cdHZhciB2ID0gYyArIGcgKiAoMS4wIC0gYyk7XG5cdHJldHVybiBbaGNnWzBdLCAodiAtIGMpICogMTAwLCAoMSAtIHYpICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaHdiLmhjZyA9IGZ1bmN0aW9uIChod2IpIHtcblx0dmFyIHcgPSBod2JbMV0gLyAxMDA7XG5cdHZhciBiID0gaHdiWzJdIC8gMTAwO1xuXHR2YXIgdiA9IDEgLSBiO1xuXHR2YXIgYyA9IHYgLSB3O1xuXHR2YXIgZyA9IDA7XG5cblx0aWYgKGMgPCAxKSB7XG5cdFx0ZyA9ICh2IC0gYykgLyAoMSAtIGMpO1xuXHR9XG5cblx0cmV0dXJuIFtod2JbMF0sIGMgKiAxMDAsIGcgKiAxMDBdO1xufTtcblxuY29udmVydC5hcHBsZS5yZ2IgPSBmdW5jdGlvbiAoYXBwbGUpIHtcblx0cmV0dXJuIFsoYXBwbGVbMF0gLyA2NTUzNSkgKiAyNTUsIChhcHBsZVsxXSAvIDY1NTM1KSAqIDI1NSwgKGFwcGxlWzJdIC8gNjU1MzUpICogMjU1XTtcbn07XG5cbmNvbnZlcnQucmdiLmFwcGxlID0gZnVuY3Rpb24gKHJnYikge1xuXHRyZXR1cm4gWyhyZ2JbMF0gLyAyNTUpICogNjU1MzUsIChyZ2JbMV0gLyAyNTUpICogNjU1MzUsIChyZ2JbMl0gLyAyNTUpICogNjU1MzVdO1xufTtcblxuY29udmVydC5ncmF5LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHJldHVybiBbYXJnc1swXSAvIDEwMCAqIDI1NSwgYXJnc1swXSAvIDEwMCAqIDI1NSwgYXJnc1swXSAvIDEwMCAqIDI1NV07XG59O1xuXG5jb252ZXJ0LmdyYXkuaHNsID0gY29udmVydC5ncmF5LmhzdiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHJldHVybiBbMCwgMCwgYXJnc1swXV07XG59O1xuXG5jb252ZXJ0LmdyYXkuaHdiID0gZnVuY3Rpb24gKGdyYXkpIHtcblx0cmV0dXJuIFswLCAxMDAsIGdyYXlbMF1dO1xufTtcblxuY29udmVydC5ncmF5LmNteWsgPSBmdW5jdGlvbiAoZ3JheSkge1xuXHRyZXR1cm4gWzAsIDAsIDAsIGdyYXlbMF1dO1xufTtcblxuY29udmVydC5ncmF5LmxhYiA9IGZ1bmN0aW9uIChncmF5KSB7XG5cdHJldHVybiBbZ3JheVswXSwgMCwgMF07XG59O1xuXG5jb252ZXJ0LmdyYXkuaGV4ID0gZnVuY3Rpb24gKGdyYXkpIHtcblx0dmFyIHZhbCA9IE1hdGgucm91bmQoZ3JheVswXSAvIDEwMCAqIDI1NSkgJiAweEZGO1xuXHR2YXIgaW50ZWdlciA9ICh2YWwgPDwgMTYpICsgKHZhbCA8PCA4KSArIHZhbDtcblxuXHR2YXIgc3RyaW5nID0gaW50ZWdlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0cmV0dXJuICcwMDAwMDAnLnN1YnN0cmluZyhzdHJpbmcubGVuZ3RoKSArIHN0cmluZztcbn07XG5cbmNvbnZlcnQucmdiLmdyYXkgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciB2YWwgPSAocmdiWzBdICsgcmdiWzFdICsgcmdiWzJdKSAvIDM7XG5cdHJldHVybiBbdmFsIC8gMjU1ICogMTAwXTtcbn07XG59KTtcbnZhciBjb252ZXJzaW9uc18xID0gY29udmVyc2lvbnMucmdiO1xudmFyIGNvbnZlcnNpb25zXzIgPSBjb252ZXJzaW9ucy5oc2w7XG52YXIgY29udmVyc2lvbnNfMyA9IGNvbnZlcnNpb25zLmhzdjtcbnZhciBjb252ZXJzaW9uc180ID0gY29udmVyc2lvbnMuaHdiO1xudmFyIGNvbnZlcnNpb25zXzUgPSBjb252ZXJzaW9ucy5jbXlrO1xudmFyIGNvbnZlcnNpb25zXzYgPSBjb252ZXJzaW9ucy54eXo7XG52YXIgY29udmVyc2lvbnNfNyA9IGNvbnZlcnNpb25zLmxhYjtcbnZhciBjb252ZXJzaW9uc184ID0gY29udmVyc2lvbnMubGNoO1xudmFyIGNvbnZlcnNpb25zXzkgPSBjb252ZXJzaW9ucy5oZXg7XG52YXIgY29udmVyc2lvbnNfMTAgPSBjb252ZXJzaW9ucy5rZXl3b3JkO1xudmFyIGNvbnZlcnNpb25zXzExID0gY29udmVyc2lvbnMuYW5zaTE2O1xudmFyIGNvbnZlcnNpb25zXzEyID0gY29udmVyc2lvbnMuYW5zaTI1NjtcbnZhciBjb252ZXJzaW9uc18xMyA9IGNvbnZlcnNpb25zLmhjZztcbnZhciBjb252ZXJzaW9uc18xNCA9IGNvbnZlcnNpb25zLmFwcGxlO1xudmFyIGNvbnZlcnNpb25zXzE1ID0gY29udmVyc2lvbnMuZ3JheTtcblxuLypcblx0dGhpcyBmdW5jdGlvbiByb3V0ZXMgYSBtb2RlbCB0byBhbGwgb3RoZXIgbW9kZWxzLlxuXG5cdGFsbCBmdW5jdGlvbnMgdGhhdCBhcmUgcm91dGVkIGhhdmUgYSBwcm9wZXJ0eSBgLmNvbnZlcnNpb25gIGF0dGFjaGVkXG5cdHRvIHRoZSByZXR1cm5lZCBzeW50aGV0aWMgZnVuY3Rpb24uIFRoaXMgcHJvcGVydHkgaXMgYW4gYXJyYXlcblx0b2Ygc3RyaW5ncywgZWFjaCB3aXRoIHRoZSBzdGVwcyBpbiBiZXR3ZWVuIHRoZSAnZnJvbScgYW5kICd0bydcblx0Y29sb3IgbW9kZWxzIChpbmNsdXNpdmUpLlxuXG5cdGNvbnZlcnNpb25zIHRoYXQgYXJlIG5vdCBwb3NzaWJsZSBzaW1wbHkgYXJlIG5vdCBpbmNsdWRlZC5cbiovXG5cbmZ1bmN0aW9uIGJ1aWxkR3JhcGgoKSB7XG5cdHZhciBncmFwaCA9IHt9O1xuXHQvLyBodHRwczovL2pzcGVyZi5jb20vb2JqZWN0LWtleXMtdnMtZm9yLWluLXdpdGgtY2xvc3VyZS8zXG5cdHZhciBtb2RlbHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9ucyk7XG5cblx0Zm9yICh2YXIgbGVuID0gbW9kZWxzLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdGdyYXBoW21vZGVsc1tpXV0gPSB7XG5cdFx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS8xLXZzLWluZmluaXR5XG5cdFx0XHQvLyBtaWNyby1vcHQsIGJ1dCB0aGlzIGlzIHNpbXBsZS5cblx0XHRcdGRpc3RhbmNlOiAtMSxcblx0XHRcdHBhcmVudDogbnVsbFxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gZ3JhcGg7XG59XG5cbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JyZWFkdGgtZmlyc3Rfc2VhcmNoXG5mdW5jdGlvbiBkZXJpdmVCRlMoZnJvbU1vZGVsKSB7XG5cdHZhciBncmFwaCA9IGJ1aWxkR3JhcGgoKTtcblx0dmFyIHF1ZXVlID0gW2Zyb21Nb2RlbF07IC8vIHVuc2hpZnQgLT4gcXVldWUgLT4gcG9wXG5cblx0Z3JhcGhbZnJvbU1vZGVsXS5kaXN0YW5jZSA9IDA7XG5cblx0d2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuXHRcdHZhciBjdXJyZW50ID0gcXVldWUucG9wKCk7XG5cdFx0dmFyIGFkamFjZW50cyA9IE9iamVjdC5rZXlzKGNvbnZlcnNpb25zW2N1cnJlbnRdKTtcblxuXHRcdGZvciAodmFyIGxlbiA9IGFkamFjZW50cy5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHZhciBhZGphY2VudCA9IGFkamFjZW50c1tpXTtcblx0XHRcdHZhciBub2RlID0gZ3JhcGhbYWRqYWNlbnRdO1xuXG5cdFx0XHRpZiAobm9kZS5kaXN0YW5jZSA9PT0gLTEpIHtcblx0XHRcdFx0bm9kZS5kaXN0YW5jZSA9IGdyYXBoW2N1cnJlbnRdLmRpc3RhbmNlICsgMTtcblx0XHRcdFx0bm9kZS5wYXJlbnQgPSBjdXJyZW50O1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KGFkamFjZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZ3JhcGg7XG59XG5cbmZ1bmN0aW9uIGxpbmsoZnJvbSwgdG8pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChhcmdzKSB7XG5cdFx0cmV0dXJuIHRvKGZyb20oYXJncykpO1xuXHR9O1xufVxuXG5mdW5jdGlvbiB3cmFwQ29udmVyc2lvbih0b01vZGVsLCBncmFwaCkge1xuXHR2YXIgcGF0aCA9IFtncmFwaFt0b01vZGVsXS5wYXJlbnQsIHRvTW9kZWxdO1xuXHR2YXIgZm4gPSBjb252ZXJzaW9uc1tncmFwaFt0b01vZGVsXS5wYXJlbnRdW3RvTW9kZWxdO1xuXG5cdHZhciBjdXIgPSBncmFwaFt0b01vZGVsXS5wYXJlbnQ7XG5cdHdoaWxlIChncmFwaFtjdXJdLnBhcmVudCkge1xuXHRcdHBhdGgudW5zaGlmdChncmFwaFtjdXJdLnBhcmVudCk7XG5cdFx0Zm4gPSBsaW5rKGNvbnZlcnNpb25zW2dyYXBoW2N1cl0ucGFyZW50XVtjdXJdLCBmbik7XG5cdFx0Y3VyID0gZ3JhcGhbY3VyXS5wYXJlbnQ7XG5cdH1cblxuXHRmbi5jb252ZXJzaW9uID0gcGF0aDtcblx0cmV0dXJuIGZuO1xufVxuXG52YXIgcm91dGUgPSBmdW5jdGlvbiAoZnJvbU1vZGVsKSB7XG5cdHZhciBncmFwaCA9IGRlcml2ZUJGUyhmcm9tTW9kZWwpO1xuXHR2YXIgY29udmVyc2lvbiA9IHt9O1xuXG5cdHZhciBtb2RlbHMgPSBPYmplY3Qua2V5cyhncmFwaCk7XG5cdGZvciAodmFyIGxlbiA9IG1vZGVscy5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHR2YXIgdG9Nb2RlbCA9IG1vZGVsc1tpXTtcblx0XHR2YXIgbm9kZSA9IGdyYXBoW3RvTW9kZWxdO1xuXG5cdFx0aWYgKG5vZGUucGFyZW50ID09PSBudWxsKSB7XG5cdFx0XHQvLyBubyBwb3NzaWJsZSBjb252ZXJzaW9uLCBvciB0aGlzIG5vZGUgaXMgdGhlIHNvdXJjZSBtb2RlbC5cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnZlcnNpb25bdG9Nb2RlbF0gPSB3cmFwQ29udmVyc2lvbih0b01vZGVsLCBncmFwaCk7XG5cdH1cblxuXHRyZXR1cm4gY29udmVyc2lvbjtcbn07XG5cbnZhciBjb252ZXJ0ID0ge307XG5cbnZhciBtb2RlbHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9ucyk7XG5cbmZ1bmN0aW9uIHdyYXBSYXcoZm4pIHtcblx0dmFyIHdyYXBwZWRGbiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdFx0aWYgKGFyZ3MgPT09IHVuZGVmaW5lZCB8fCBhcmdzID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gYXJncztcblx0XHR9XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmbihhcmdzKTtcblx0fTtcblxuXHQvLyBwcmVzZXJ2ZSAuY29udmVyc2lvbiBwcm9wZXJ0eSBpZiB0aGVyZSBpcyBvbmVcblx0aWYgKCdjb252ZXJzaW9uJyBpbiBmbikge1xuXHRcdHdyYXBwZWRGbi5jb252ZXJzaW9uID0gZm4uY29udmVyc2lvbjtcblx0fVxuXG5cdHJldHVybiB3cmFwcGVkRm47XG59XG5cbmZ1bmN0aW9uIHdyYXBSb3VuZGVkKGZuKSB7XG5cdHZhciB3cmFwcGVkRm4gPSBmdW5jdGlvbiAoYXJncykge1xuXHRcdGlmIChhcmdzID09PSB1bmRlZmluZWQgfHwgYXJncyA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGFyZ3M7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHR9XG5cblx0XHR2YXIgcmVzdWx0ID0gZm4oYXJncyk7XG5cblx0XHQvLyB3ZSdyZSBhc3N1bWluZyB0aGUgcmVzdWx0IGlzIGFuIGFycmF5IGhlcmUuXG5cdFx0Ly8gc2VlIG5vdGljZSBpbiBjb252ZXJzaW9ucy5qczsgZG9uJ3QgdXNlIGJveCB0eXBlc1xuXHRcdC8vIGluIGNvbnZlcnNpb24gZnVuY3Rpb25zLlxuXHRcdGlmICh0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Zm9yICh2YXIgbGVuID0gcmVzdWx0Lmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSBNYXRoLnJvdW5kKHJlc3VsdFtpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvLyBwcmVzZXJ2ZSAuY29udmVyc2lvbiBwcm9wZXJ0eSBpZiB0aGVyZSBpcyBvbmVcblx0aWYgKCdjb252ZXJzaW9uJyBpbiBmbikge1xuXHRcdHdyYXBwZWRGbi5jb252ZXJzaW9uID0gZm4uY29udmVyc2lvbjtcblx0fVxuXG5cdHJldHVybiB3cmFwcGVkRm47XG59XG5cbm1vZGVscy5mb3JFYWNoKGZ1bmN0aW9uIChmcm9tTW9kZWwpIHtcblx0Y29udmVydFtmcm9tTW9kZWxdID0ge307XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbZnJvbU1vZGVsXSwgJ2NoYW5uZWxzJywge3ZhbHVlOiBjb252ZXJzaW9uc1tmcm9tTW9kZWxdLmNoYW5uZWxzfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0W2Zyb21Nb2RlbF0sICdsYWJlbHMnLCB7dmFsdWU6IGNvbnZlcnNpb25zW2Zyb21Nb2RlbF0ubGFiZWxzfSk7XG5cblx0dmFyIHJvdXRlcyA9IHJvdXRlKGZyb21Nb2RlbCk7XG5cdHZhciByb3V0ZU1vZGVscyA9IE9iamVjdC5rZXlzKHJvdXRlcyk7XG5cblx0cm91dGVNb2RlbHMuZm9yRWFjaChmdW5jdGlvbiAodG9Nb2RlbCkge1xuXHRcdHZhciBmbiA9IHJvdXRlc1t0b01vZGVsXTtcblxuXHRcdGNvbnZlcnRbZnJvbU1vZGVsXVt0b01vZGVsXSA9IHdyYXBSb3VuZGVkKGZuKTtcblx0XHRjb252ZXJ0W2Zyb21Nb2RlbF1bdG9Nb2RlbF0ucmF3ID0gd3JhcFJhdyhmbik7XG5cdH0pO1xufSk7XG5cbnZhciBjb2xvckNvbnZlcnQgPSBjb252ZXJ0O1xuXG52YXIgY29sb3JOYW1lJDEgPSB7XHJcblx0XCJhbGljZWJsdWVcIjogWzI0MCwgMjQ4LCAyNTVdLFxyXG5cdFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsIDIzNSwgMjE1XSxcclxuXHRcImFxdWFcIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImFxdWFtYXJpbmVcIjogWzEyNywgMjU1LCAyMTJdLFxyXG5cdFwiYXp1cmVcIjogWzI0MCwgMjU1LCAyNTVdLFxyXG5cdFwiYmVpZ2VcIjogWzI0NSwgMjQ1LCAyMjBdLFxyXG5cdFwiYmlzcXVlXCI6IFsyNTUsIDIyOCwgMTk2XSxcclxuXHRcImJsYWNrXCI6IFswLCAwLCAwXSxcclxuXHRcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsIDIzNSwgMjA1XSxcclxuXHRcImJsdWVcIjogWzAsIDAsIDI1NV0sXHJcblx0XCJibHVldmlvbGV0XCI6IFsxMzgsIDQzLCAyMjZdLFxyXG5cdFwiYnJvd25cIjogWzE2NSwgNDIsIDQyXSxcclxuXHRcImJ1cmx5d29vZFwiOiBbMjIyLCAxODQsIDEzNV0sXHJcblx0XCJjYWRldGJsdWVcIjogWzk1LCAxNTgsIDE2MF0sXHJcblx0XCJjaGFydHJldXNlXCI6IFsxMjcsIDI1NSwgMF0sXHJcblx0XCJjaG9jb2xhdGVcIjogWzIxMCwgMTA1LCAzMF0sXHJcblx0XCJjb3JhbFwiOiBbMjU1LCAxMjcsIDgwXSxcclxuXHRcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsIDE0OSwgMjM3XSxcclxuXHRcImNvcm5zaWxrXCI6IFsyNTUsIDI0OCwgMjIwXSxcclxuXHRcImNyaW1zb25cIjogWzIyMCwgMjAsIDYwXSxcclxuXHRcImN5YW5cIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImRhcmtibHVlXCI6IFswLCAwLCAxMzldLFxyXG5cdFwiZGFya2N5YW5cIjogWzAsIDEzOSwgMTM5XSxcclxuXHRcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwgMTM0LCAxMV0sXHJcblx0XCJkYXJrZ3JheVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJrZ3JlZW5cIjogWzAsIDEwMCwgMF0sXHJcblx0XCJkYXJrZ3JleVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJra2hha2lcIjogWzE4OSwgMTgzLCAxMDddLFxyXG5cdFwiZGFya21hZ2VudGFcIjogWzEzOSwgMCwgMTM5XSxcclxuXHRcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwgMTA3LCA0N10sXHJcblx0XCJkYXJrb3JhbmdlXCI6IFsyNTUsIDE0MCwgMF0sXHJcblx0XCJkYXJrb3JjaGlkXCI6IFsxNTMsIDUwLCAyMDRdLFxyXG5cdFwiZGFya3JlZFwiOiBbMTM5LCAwLCAwXSxcclxuXHRcImRhcmtzYWxtb25cIjogWzIzMywgMTUwLCAxMjJdLFxyXG5cdFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsIDE4OCwgMTQzXSxcclxuXHRcImRhcmtzbGF0ZWJsdWVcIjogWzcyLCA2MSwgMTM5XSxcclxuXHRcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsIDc5LCA3OV0sXHJcblx0XCJkYXJrdHVycXVvaXNlXCI6IFswLCAyMDYsIDIwOV0sXHJcblx0XCJkYXJrdmlvbGV0XCI6IFsxNDgsIDAsIDIxMV0sXHJcblx0XCJkZWVwcGlua1wiOiBbMjU1LCAyMCwgMTQ3XSxcclxuXHRcImRlZXBza3libHVlXCI6IFswLCAxOTEsIDI1NV0sXHJcblx0XCJkaW1ncmF5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRpbWdyZXlcIjogWzEwNSwgMTA1LCAxMDVdLFxyXG5cdFwiZG9kZ2VyYmx1ZVwiOiBbMzAsIDE0NCwgMjU1XSxcclxuXHRcImZpcmVicmlja1wiOiBbMTc4LCAzNCwgMzRdLFxyXG5cdFwiZmxvcmFsd2hpdGVcIjogWzI1NSwgMjUwLCAyNDBdLFxyXG5cdFwiZm9yZXN0Z3JlZW5cIjogWzM0LCAxMzksIDM0XSxcclxuXHRcImZ1Y2hzaWFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcImdhaW5zYm9yb1wiOiBbMjIwLCAyMjAsIDIyMF0sXHJcblx0XCJnaG9zdHdoaXRlXCI6IFsyNDgsIDI0OCwgMjU1XSxcclxuXHRcImdvbGRcIjogWzI1NSwgMjE1LCAwXSxcclxuXHRcImdvbGRlbnJvZFwiOiBbMjE4LCAxNjUsIDMyXSxcclxuXHRcImdyYXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiZ3JlZW5cIjogWzAsIDEyOCwgMF0sXHJcblx0XCJncmVlbnllbGxvd1wiOiBbMTczLCAyNTUsIDQ3XSxcclxuXHRcImdyZXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiaG9uZXlkZXdcIjogWzI0MCwgMjU1LCAyNDBdLFxyXG5cdFwiaG90cGlua1wiOiBbMjU1LCAxMDUsIDE4MF0sXHJcblx0XCJpbmRpYW5yZWRcIjogWzIwNSwgOTIsIDkyXSxcclxuXHRcImluZGlnb1wiOiBbNzUsIDAsIDEzMF0sXHJcblx0XCJpdm9yeVwiOiBbMjU1LCAyNTUsIDI0MF0sXHJcblx0XCJraGFraVwiOiBbMjQwLCAyMzAsIDE0MF0sXHJcblx0XCJsYXZlbmRlclwiOiBbMjMwLCAyMzAsIDI1MF0sXHJcblx0XCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsIDI0MCwgMjQ1XSxcclxuXHRcImxhd25ncmVlblwiOiBbMTI0LCAyNTIsIDBdLFxyXG5cdFwibGVtb25jaGlmZm9uXCI6IFsyNTUsIDI1MCwgMjA1XSxcclxuXHRcImxpZ2h0Ymx1ZVwiOiBbMTczLCAyMTYsIDIzMF0sXHJcblx0XCJsaWdodGNvcmFsXCI6IFsyNDAsIDEyOCwgMTI4XSxcclxuXHRcImxpZ2h0Y3lhblwiOiBbMjI0LCAyNTUsIDI1NV0sXHJcblx0XCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLCAyNTAsIDIxMF0sXHJcblx0XCJsaWdodGdyYXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRncmVlblwiOiBbMTQ0LCAyMzgsIDE0NF0sXHJcblx0XCJsaWdodGdyZXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRwaW5rXCI6IFsyNTUsIDE4MiwgMTkzXSxcclxuXHRcImxpZ2h0c2FsbW9uXCI6IFsyNTUsIDE2MCwgMTIyXSxcclxuXHRcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLCAxNzgsIDE3MF0sXHJcblx0XCJsaWdodHNreWJsdWVcIjogWzEzNSwgMjA2LCAyNTBdLFxyXG5cdFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwgMTk2LCAyMjJdLFxyXG5cdFwibGlnaHR5ZWxsb3dcIjogWzI1NSwgMjU1LCAyMjRdLFxyXG5cdFwibGltZVwiOiBbMCwgMjU1LCAwXSxcclxuXHRcImxpbWVncmVlblwiOiBbNTAsIDIwNSwgNTBdLFxyXG5cdFwibGluZW5cIjogWzI1MCwgMjQwLCAyMzBdLFxyXG5cdFwibWFnZW50YVwiOiBbMjU1LCAwLCAyNTVdLFxyXG5cdFwibWFyb29uXCI6IFsxMjgsIDAsIDBdLFxyXG5cdFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLCAyMDUsIDE3MF0sXHJcblx0XCJtZWRpdW1ibHVlXCI6IFswLCAwLCAyMDVdLFxyXG5cdFwibWVkaXVtb3JjaGlkXCI6IFsxODYsIDg1LCAyMTFdLFxyXG5cdFwibWVkaXVtcHVycGxlXCI6IFsxNDcsIDExMiwgMjE5XSxcclxuXHRcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwgMTc5LCAxMTNdLFxyXG5cdFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsIDEwNCwgMjM4XSxcclxuXHRcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLCAyNTAsIDE1NF0sXHJcblx0XCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLCAyMDksIDIwNF0sXHJcblx0XCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwgMjEsIDEzM10sXHJcblx0XCJtaWRuaWdodGJsdWVcIjogWzI1LCAyNSwgMTEyXSxcclxuXHRcIm1pbnRjcmVhbVwiOiBbMjQ1LCAyNTUsIDI1MF0sXHJcblx0XCJtaXN0eXJvc2VcIjogWzI1NSwgMjI4LCAyMjVdLFxyXG5cdFwibW9jY2FzaW5cIjogWzI1NSwgMjI4LCAxODFdLFxyXG5cdFwibmF2YWpvd2hpdGVcIjogWzI1NSwgMjIyLCAxNzNdLFxyXG5cdFwibmF2eVwiOiBbMCwgMCwgMTI4XSxcclxuXHRcIm9sZGxhY2VcIjogWzI1MywgMjQ1LCAyMzBdLFxyXG5cdFwib2xpdmVcIjogWzEyOCwgMTI4LCAwXSxcclxuXHRcIm9saXZlZHJhYlwiOiBbMTA3LCAxNDIsIDM1XSxcclxuXHRcIm9yYW5nZVwiOiBbMjU1LCAxNjUsIDBdLFxyXG5cdFwib3JhbmdlcmVkXCI6IFsyNTUsIDY5LCAwXSxcclxuXHRcIm9yY2hpZFwiOiBbMjE4LCAxMTIsIDIxNF0sXHJcblx0XCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsIDIzMiwgMTcwXSxcclxuXHRcInBhbGVncmVlblwiOiBbMTUyLCAyNTEsIDE1Ml0sXHJcblx0XCJwYWxldHVycXVvaXNlXCI6IFsxNzUsIDIzOCwgMjM4XSxcclxuXHRcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwgMTEyLCAxNDddLFxyXG5cdFwicGFwYXlhd2hpcFwiOiBbMjU1LCAyMzksIDIxM10sXHJcblx0XCJwZWFjaHB1ZmZcIjogWzI1NSwgMjE4LCAxODVdLFxyXG5cdFwicGVydVwiOiBbMjA1LCAxMzMsIDYzXSxcclxuXHRcInBpbmtcIjogWzI1NSwgMTkyLCAyMDNdLFxyXG5cdFwicGx1bVwiOiBbMjIxLCAxNjAsIDIyMV0sXHJcblx0XCJwb3dkZXJibHVlXCI6IFsxNzYsIDIyNCwgMjMwXSxcclxuXHRcInB1cnBsZVwiOiBbMTI4LCAwLCAxMjhdLFxyXG5cdFwicmViZWNjYXB1cnBsZVwiOiBbMTAyLCA1MSwgMTUzXSxcclxuXHRcInJlZFwiOiBbMjU1LCAwLCAwXSxcclxuXHRcInJvc3licm93blwiOiBbMTg4LCAxNDMsIDE0M10sXHJcblx0XCJyb3lhbGJsdWVcIjogWzY1LCAxMDUsIDIyNV0sXHJcblx0XCJzYWRkbGVicm93blwiOiBbMTM5LCA2OSwgMTldLFxyXG5cdFwic2FsbW9uXCI6IFsyNTAsIDEyOCwgMTE0XSxcclxuXHRcInNhbmR5YnJvd25cIjogWzI0NCwgMTY0LCA5Nl0sXHJcblx0XCJzZWFncmVlblwiOiBbNDYsIDEzOSwgODddLFxyXG5cdFwic2Vhc2hlbGxcIjogWzI1NSwgMjQ1LCAyMzhdLFxyXG5cdFwic2llbm5hXCI6IFsxNjAsIDgyLCA0NV0sXHJcblx0XCJzaWx2ZXJcIjogWzE5MiwgMTkyLCAxOTJdLFxyXG5cdFwic2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDIzNV0sXHJcblx0XCJzbGF0ZWJsdWVcIjogWzEwNiwgOTAsIDIwNV0sXHJcblx0XCJzbGF0ZWdyYXlcIjogWzExMiwgMTI4LCAxNDRdLFxyXG5cdFwic2xhdGVncmV5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNub3dcIjogWzI1NSwgMjUwLCAyNTBdLFxyXG5cdFwic3ByaW5nZ3JlZW5cIjogWzAsIDI1NSwgMTI3XSxcclxuXHRcInN0ZWVsYmx1ZVwiOiBbNzAsIDEzMCwgMTgwXSxcclxuXHRcInRhblwiOiBbMjEwLCAxODAsIDE0MF0sXHJcblx0XCJ0ZWFsXCI6IFswLCAxMjgsIDEyOF0sXHJcblx0XCJ0aGlzdGxlXCI6IFsyMTYsIDE5MSwgMjE2XSxcclxuXHRcInRvbWF0b1wiOiBbMjU1LCA5OSwgNzFdLFxyXG5cdFwidHVycXVvaXNlXCI6IFs2NCwgMjI0LCAyMDhdLFxyXG5cdFwidmlvbGV0XCI6IFsyMzgsIDEzMCwgMjM4XSxcclxuXHRcIndoZWF0XCI6IFsyNDUsIDIyMiwgMTc5XSxcclxuXHRcIndoaXRlXCI6IFsyNTUsIDI1NSwgMjU1XSxcclxuXHRcIndoaXRlc21va2VcIjogWzI0NSwgMjQ1LCAyNDVdLFxyXG5cdFwieWVsbG93XCI6IFsyNTUsIDI1NSwgMF0sXHJcblx0XCJ5ZWxsb3dncmVlblwiOiBbMTU0LCAyMDUsIDUwXVxyXG59O1xuXG4vKiBNSVQgbGljZW5zZSAqL1xuXG5cbnZhciBjb2xvclN0cmluZyA9IHtcbiAgIGdldFJnYmE6IGdldFJnYmEsXG4gICBnZXRIc2xhOiBnZXRIc2xhLFxuICAgZ2V0UmdiOiBnZXRSZ2IsXG4gICBnZXRIc2w6IGdldEhzbCxcbiAgIGdldEh3YjogZ2V0SHdiLFxuICAgZ2V0QWxwaGE6IGdldEFscGhhLFxuXG4gICBoZXhTdHJpbmc6IGhleFN0cmluZyxcbiAgIHJnYlN0cmluZzogcmdiU3RyaW5nLFxuICAgcmdiYVN0cmluZzogcmdiYVN0cmluZyxcbiAgIHBlcmNlbnRTdHJpbmc6IHBlcmNlbnRTdHJpbmcsXG4gICBwZXJjZW50YVN0cmluZzogcGVyY2VudGFTdHJpbmcsXG4gICBoc2xTdHJpbmc6IGhzbFN0cmluZyxcbiAgIGhzbGFTdHJpbmc6IGhzbGFTdHJpbmcsXG4gICBod2JTdHJpbmc6IGh3YlN0cmluZyxcbiAgIGtleXdvcmQ6IGtleXdvcmRcbn07XG5cbmZ1bmN0aW9uIGdldFJnYmEoc3RyaW5nKSB7XG4gICBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuO1xuICAgfVxuICAgdmFyIGFiYnIgPSAgL14jKFthLWZBLUYwLTldezMsNH0pJC9pLFxuICAgICAgIGhleCA9ICAvXiMoW2EtZkEtRjAtOV17Nn0oW2EtZkEtRjAtOV17Mn0pPykkL2ksXG4gICAgICAgcmdiYSA9IC9ecmdiYT9cXChcXHMqKFsrLV0/XFxkKylcXHMqLFxccyooWystXT9cXGQrKVxccyosXFxzKihbKy1dP1xcZCspXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKSQvaSxcbiAgICAgICBwZXIgPSAvXnJnYmE/XFwoXFxzKihbKy1dP1tcXGRcXC5dKylcXCVcXHMqLFxccyooWystXT9bXFxkXFwuXSspXFwlXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKVxcJVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkkL2ksXG4gICAgICAga2V5d29yZCA9IC8oXFx3KykvO1xuXG4gICB2YXIgcmdiID0gWzAsIDAsIDBdLFxuICAgICAgIGEgPSAxLFxuICAgICAgIG1hdGNoID0gc3RyaW5nLm1hdGNoKGFiYnIpLFxuICAgICAgIGhleEFscGhhID0gXCJcIjtcbiAgIGlmIChtYXRjaCkge1xuICAgICAgbWF0Y2ggPSBtYXRjaFsxXTtcbiAgICAgIGhleEFscGhhID0gbWF0Y2hbM107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gcGFyc2VJbnQobWF0Y2hbaV0gKyBtYXRjaFtpXSwgMTYpO1xuICAgICAgfVxuICAgICAgaWYgKGhleEFscGhhKSB7XG4gICAgICAgICBhID0gTWF0aC5yb3VuZCgocGFyc2VJbnQoaGV4QWxwaGEgKyBoZXhBbHBoYSwgMTYpIC8gMjU1KSAqIDEwMCkgLyAxMDA7XG4gICAgICB9XG4gICB9XG4gICBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChoZXgpKSB7XG4gICAgICBoZXhBbHBoYSA9IG1hdGNoWzJdO1xuICAgICAgbWF0Y2ggPSBtYXRjaFsxXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBwYXJzZUludChtYXRjaC5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgICAgfVxuICAgICAgaWYgKGhleEFscGhhKSB7XG4gICAgICAgICBhID0gTWF0aC5yb3VuZCgocGFyc2VJbnQoaGV4QWxwaGEsIDE2KSAvIDI1NSkgKiAxMDApIC8gMTAwO1xuICAgICAgfVxuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2gocmdiYSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBwYXJzZUludChtYXRjaFtpICsgMV0pO1xuICAgICAgfVxuICAgICAgYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2gocGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IE1hdGgucm91bmQocGFyc2VGbG9hdChtYXRjaFtpICsgMV0pICogMi41NSk7XG4gICAgICB9XG4gICAgICBhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG4gICB9XG4gICBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChrZXl3b3JkKSkge1xuICAgICAgaWYgKG1hdGNoWzFdID09IFwidHJhbnNwYXJlbnRcIikge1xuICAgICAgICAgcmV0dXJuIFswLCAwLCAwLCAwXTtcbiAgICAgIH1cbiAgICAgIHJnYiA9IGNvbG9yTmFtZSQxW21hdGNoWzFdXTtcbiAgICAgIGlmICghcmdiKSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICB9XG5cbiAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZ2JbaV0gPSBzY2FsZShyZ2JbaV0sIDAsIDI1NSk7XG4gICB9XG4gICBpZiAoIWEgJiYgYSAhPSAwKSB7XG4gICAgICBhID0gMTtcbiAgIH1cbiAgIGVsc2Uge1xuICAgICAgYSA9IHNjYWxlKGEsIDAsIDEpO1xuICAgfVxuICAgcmdiWzNdID0gYTtcbiAgIHJldHVybiByZ2I7XG59XG5cbmZ1bmN0aW9uIGdldEhzbGEoc3RyaW5nKSB7XG4gICBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuO1xuICAgfVxuICAgdmFyIGhzbCA9IC9eaHNsYT9cXChcXHMqKFsrLV0/XFxkKykoPzpkZWcpP1xccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpLztcbiAgIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaChoc2wpO1xuICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgYWxwaGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcbiAgICAgIHZhciBoID0gc2NhbGUocGFyc2VJbnQobWF0Y2hbMV0pLCAwLCAzNjApLFxuICAgICAgICAgIHMgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzJdKSwgMCwgMTAwKSxcbiAgICAgICAgICBsID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFszXSksIDAsIDEwMCksXG4gICAgICAgICAgYSA9IHNjYWxlKGlzTmFOKGFscGhhKSA/IDEgOiBhbHBoYSwgMCwgMSk7XG4gICAgICByZXR1cm4gW2gsIHMsIGwsIGFdO1xuICAgfVxufVxuXG5mdW5jdGlvbiBnZXRId2Ioc3RyaW5nKSB7XG4gICBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuO1xuICAgfVxuICAgdmFyIGh3YiA9IC9eaHdiXFwoXFxzKihbKy1dP1xcZCspKD86ZGVnKT9cXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKS87XG4gICB2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goaHdiKTtcbiAgIGlmIChtYXRjaCkge1xuICAgIHZhciBhbHBoYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgICAgdmFyIGggPSBzY2FsZShwYXJzZUludChtYXRjaFsxXSksIDAsIDM2MCksXG4gICAgICAgICAgdyA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbMl0pLCAwLCAxMDApLFxuICAgICAgICAgIGIgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzNdKSwgMCwgMTAwKSxcbiAgICAgICAgICBhID0gc2NhbGUoaXNOYU4oYWxwaGEpID8gMSA6IGFscGhhLCAwLCAxKTtcbiAgICAgIHJldHVybiBbaCwgdywgYiwgYV07XG4gICB9XG59XG5cbmZ1bmN0aW9uIGdldFJnYihzdHJpbmcpIHtcbiAgIHZhciByZ2JhID0gZ2V0UmdiYShzdHJpbmcpO1xuICAgcmV0dXJuIHJnYmEgJiYgcmdiYS5zbGljZSgwLCAzKTtcbn1cblxuZnVuY3Rpb24gZ2V0SHNsKHN0cmluZykge1xuICB2YXIgaHNsYSA9IGdldEhzbGEoc3RyaW5nKTtcbiAgcmV0dXJuIGhzbGEgJiYgaHNsYS5zbGljZSgwLCAzKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxwaGEoc3RyaW5nKSB7XG4gICB2YXIgdmFscyA9IGdldFJnYmEoc3RyaW5nKTtcbiAgIGlmICh2YWxzKSB7XG4gICAgICByZXR1cm4gdmFsc1szXTtcbiAgIH1cbiAgIGVsc2UgaWYgKHZhbHMgPSBnZXRIc2xhKHN0cmluZykpIHtcbiAgICAgIHJldHVybiB2YWxzWzNdO1xuICAgfVxuICAgZWxzZSBpZiAodmFscyA9IGdldEh3YihzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gdmFsc1szXTtcbiAgIH1cbn1cblxuLy8gZ2VuZXJhdG9yc1xuZnVuY3Rpb24gaGV4U3RyaW5nKHJnYmEsIGEpIHtcbiAgIHZhciBhID0gKGEgIT09IHVuZGVmaW5lZCAmJiByZ2JhLmxlbmd0aCA9PT0gMykgPyBhIDogcmdiYVszXTtcbiAgIHJldHVybiBcIiNcIiArIGhleERvdWJsZShyZ2JhWzBdKSBcbiAgICAgICAgICAgICAgKyBoZXhEb3VibGUocmdiYVsxXSlcbiAgICAgICAgICAgICAgKyBoZXhEb3VibGUocmdiYVsyXSlcbiAgICAgICAgICAgICAgKyAoXG4gICAgICAgICAgICAgICAgIChhID49IDAgJiYgYSA8IDEpXG4gICAgICAgICAgICAgICAgID8gaGV4RG91YmxlKE1hdGgucm91bmQoYSAqIDI1NSkpXG4gICAgICAgICAgICAgICAgIDogXCJcIlxuICAgICAgICAgICAgICApO1xufVxuXG5mdW5jdGlvbiByZ2JTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA8IDEgfHwgKHJnYmFbM10gJiYgcmdiYVszXSA8IDEpKSB7XG4gICAgICByZXR1cm4gcmdiYVN0cmluZyhyZ2JhLCBhbHBoYSk7XG4gICB9XG4gICByZXR1cm4gXCJyZ2IoXCIgKyByZ2JhWzBdICsgXCIsIFwiICsgcmdiYVsxXSArIFwiLCBcIiArIHJnYmFbMl0gKyBcIilcIjtcbn1cblxuZnVuY3Rpb24gcmdiYVN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFscGhhID0gKHJnYmFbM10gIT09IHVuZGVmaW5lZCA/IHJnYmFbM10gOiAxKTtcbiAgIH1cbiAgIHJldHVybiBcInJnYmEoXCIgKyByZ2JhWzBdICsgXCIsIFwiICsgcmdiYVsxXSArIFwiLCBcIiArIHJnYmFbMl1cbiAgICAgICAgICAgKyBcIiwgXCIgKyBhbHBoYSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBwZXJjZW50U3RyaW5nKHJnYmEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPCAxIHx8IChyZ2JhWzNdICYmIHJnYmFbM10gPCAxKSkge1xuICAgICAgcmV0dXJuIHBlcmNlbnRhU3RyaW5nKHJnYmEsIGFscGhhKTtcbiAgIH1cbiAgIHZhciByID0gTWF0aC5yb3VuZChyZ2JhWzBdLzI1NSAqIDEwMCksXG4gICAgICAgZyA9IE1hdGgucm91bmQocmdiYVsxXS8yNTUgKiAxMDApLFxuICAgICAgIGIgPSBNYXRoLnJvdW5kKHJnYmFbMl0vMjU1ICogMTAwKTtcblxuICAgcmV0dXJuIFwicmdiKFwiICsgciArIFwiJSwgXCIgKyBnICsgXCIlLCBcIiArIGIgKyBcIiUpXCI7XG59XG5cbmZ1bmN0aW9uIHBlcmNlbnRhU3RyaW5nKHJnYmEsIGFscGhhKSB7XG4gICB2YXIgciA9IE1hdGgucm91bmQocmdiYVswXS8yNTUgKiAxMDApLFxuICAgICAgIGcgPSBNYXRoLnJvdW5kKHJnYmFbMV0vMjU1ICogMTAwKSxcbiAgICAgICBiID0gTWF0aC5yb3VuZChyZ2JhWzJdLzI1NSAqIDEwMCk7XG4gICByZXR1cm4gXCJyZ2JhKFwiICsgciArIFwiJSwgXCIgKyBnICsgXCIlLCBcIiArIGIgKyBcIiUsIFwiICsgKGFscGhhIHx8IHJnYmFbM10gfHwgMSkgKyBcIilcIjtcbn1cblxuZnVuY3Rpb24gaHNsU3RyaW5nKGhzbGEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPCAxIHx8IChoc2xhWzNdICYmIGhzbGFbM10gPCAxKSkge1xuICAgICAgcmV0dXJuIGhzbGFTdHJpbmcoaHNsYSwgYWxwaGEpO1xuICAgfVxuICAgcmV0dXJuIFwiaHNsKFwiICsgaHNsYVswXSArIFwiLCBcIiArIGhzbGFbMV0gKyBcIiUsIFwiICsgaHNsYVsyXSArIFwiJSlcIjtcbn1cblxuZnVuY3Rpb24gaHNsYVN0cmluZyhoc2xhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFscGhhID0gKGhzbGFbM10gIT09IHVuZGVmaW5lZCA/IGhzbGFbM10gOiAxKTtcbiAgIH1cbiAgIHJldHVybiBcImhzbGEoXCIgKyBoc2xhWzBdICsgXCIsIFwiICsgaHNsYVsxXSArIFwiJSwgXCIgKyBoc2xhWzJdICsgXCIlLCBcIlxuICAgICAgICAgICArIGFscGhhICsgXCIpXCI7XG59XG5cbi8vIGh3YiBpcyBhIGJpdCBkaWZmZXJlbnQgdGhhbiByZ2IoYSkgJiBoc2woYSkgc2luY2UgdGhlcmUgaXMgbm8gYWxwaGEgc3BlY2lmaWMgc3ludGF4XG4vLyAoaHdiIGhhdmUgYWxwaGEgb3B0aW9uYWwgJiAxIGlzIGRlZmF1bHQgdmFsdWUpXG5mdW5jdGlvbiBod2JTdHJpbmcoaHdiLCBhbHBoYSkge1xuICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFscGhhID0gKGh3YlszXSAhPT0gdW5kZWZpbmVkID8gaHdiWzNdIDogMSk7XG4gICB9XG4gICByZXR1cm4gXCJod2IoXCIgKyBod2JbMF0gKyBcIiwgXCIgKyBod2JbMV0gKyBcIiUsIFwiICsgaHdiWzJdICsgXCIlXCJcbiAgICAgICAgICAgKyAoYWxwaGEgIT09IHVuZGVmaW5lZCAmJiBhbHBoYSAhPT0gMSA/IFwiLCBcIiArIGFscGhhIDogXCJcIikgKyBcIilcIjtcbn1cblxuZnVuY3Rpb24ga2V5d29yZChyZ2IpIHtcbiAgcmV0dXJuIHJldmVyc2VOYW1lc1tyZ2Iuc2xpY2UoMCwgMyldO1xufVxuXG4vLyBoZWxwZXJzXG5mdW5jdGlvbiBzY2FsZShudW0sIG1pbiwgbWF4KSB7XG4gICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCBudW0pLCBtYXgpO1xufVxuXG5mdW5jdGlvbiBoZXhEb3VibGUobnVtKSB7XG4gIHZhciBzdHIgPSBudW0udG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gIHJldHVybiAoc3RyLmxlbmd0aCA8IDIpID8gXCIwXCIgKyBzdHIgOiBzdHI7XG59XG5cblxuLy9jcmVhdGUgYSBsaXN0IG9mIHJldmVyc2UgY29sb3IgbmFtZXNcbnZhciByZXZlcnNlTmFtZXMgPSB7fTtcbmZvciAodmFyIG5hbWUgaW4gY29sb3JOYW1lJDEpIHtcbiAgIHJldmVyc2VOYW1lc1tjb2xvck5hbWUkMVtuYW1lXV0gPSBuYW1lO1xufVxuXG4vKiBNSVQgbGljZW5zZSAqL1xuXG5cblxudmFyIENvbG9yID0gZnVuY3Rpb24gKG9iaikge1xuXHRpZiAob2JqIGluc3RhbmNlb2YgQ29sb3IpIHtcblx0XHRyZXR1cm4gb2JqO1xuXHR9XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb2xvcikpIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKG9iaik7XG5cdH1cblxuXHR0aGlzLnZhbGlkID0gZmFsc2U7XG5cdHRoaXMudmFsdWVzID0ge1xuXHRcdHJnYjogWzAsIDAsIDBdLFxuXHRcdGhzbDogWzAsIDAsIDBdLFxuXHRcdGhzdjogWzAsIDAsIDBdLFxuXHRcdGh3YjogWzAsIDAsIDBdLFxuXHRcdGNteWs6IFswLCAwLCAwLCAwXSxcblx0XHRhbHBoYTogMVxuXHR9O1xuXG5cdC8vIHBhcnNlIENvbG9yKCkgYXJndW1lbnRcblx0dmFyIHZhbHM7XG5cdGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuXHRcdHZhbHMgPSBjb2xvclN0cmluZy5nZXRSZ2JhKG9iaik7XG5cdFx0aWYgKHZhbHMpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdyZ2InLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMgPSBjb2xvclN0cmluZy5nZXRIc2xhKG9iaikpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMgPSBjb2xvclN0cmluZy5nZXRId2Iob2JqKSkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2h3YicsIHZhbHMpO1xuXHRcdH1cblx0fSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuXHRcdHZhbHMgPSBvYmo7XG5cdFx0aWYgKHZhbHMuciAhPT0gdW5kZWZpbmVkIHx8IHZhbHMucmVkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdyZ2InLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMubCAhPT0gdW5kZWZpbmVkIHx8IHZhbHMubGlnaHRuZXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMudiAhPT0gdW5kZWZpbmVkIHx8IHZhbHMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzdicsIHZhbHMpO1xuXHRcdH0gZWxzZSBpZiAodmFscy53ICE9PSB1bmRlZmluZWQgfHwgdmFscy53aGl0ZW5lc3MgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2h3YicsIHZhbHMpO1xuXHRcdH0gZWxzZSBpZiAodmFscy5jICE9PSB1bmRlZmluZWQgfHwgdmFscy5jeWFuICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdjbXlrJywgdmFscyk7XG5cdFx0fVxuXHR9XG59O1xuXG5Db2xvci5wcm90b3R5cGUgPSB7XG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWxpZDtcblx0fSxcblx0cmdiOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ3JnYicsIGFyZ3VtZW50cyk7XG5cdH0sXG5cdGhzbDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdoc2wnLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRoc3Y6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRTcGFjZSgnaHN2JywgYXJndW1lbnRzKTtcblx0fSxcblx0aHdiOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ2h3YicsIGFyZ3VtZW50cyk7XG5cdH0sXG5cdGNteWs6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRTcGFjZSgnY215aycsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0cmdiQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMucmdiO1xuXHR9LFxuXHRoc2xBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlcy5oc2w7XG5cdH0sXG5cdGhzdkFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzLmhzdjtcblx0fSxcblx0aHdiQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdFx0aWYgKHZhbHVlcy5hbHBoYSAhPT0gMSkge1xuXHRcdFx0cmV0dXJuIHZhbHVlcy5od2IuY29uY2F0KFt2YWx1ZXMuYWxwaGFdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlcy5od2I7XG5cdH0sXG5cdGNteWtBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlcy5jbXlrO1xuXHR9LFxuXHRyZ2JhQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdFx0cmV0dXJuIHZhbHVlcy5yZ2IuY29uY2F0KFt2YWx1ZXMuYWxwaGFdKTtcblx0fSxcblx0aHNsYUFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHRcdHJldHVybiB2YWx1ZXMuaHNsLmNvbmNhdChbdmFsdWVzLmFscGhhXSk7XG5cdH0sXG5cdGFscGhhOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy52YWx1ZXMuYWxwaGE7XG5cdFx0fVxuXHRcdHRoaXMuc2V0VmFsdWVzKCdhbHBoYScsIHZhbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVkOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgncmdiJywgMCwgdmFsKTtcblx0fSxcblx0Z3JlZW46IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdyZ2InLCAxLCB2YWwpO1xuXHR9LFxuXHRibHVlOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgncmdiJywgMiwgdmFsKTtcblx0fSxcblx0aHVlOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0aWYgKHZhbCkge1xuXHRcdFx0dmFsICU9IDM2MDtcblx0XHRcdHZhbCA9IHZhbCA8IDAgPyAzNjAgKyB2YWwgOiB2YWw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2hzbCcsIDAsIHZhbCk7XG5cdH0sXG5cdHNhdHVyYXRpb246IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc2wnLCAxLCB2YWwpO1xuXHR9LFxuXHRsaWdodG5lc3M6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc2wnLCAyLCB2YWwpO1xuXHR9LFxuXHRzYXR1cmF0aW9udjogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2hzdicsIDEsIHZhbCk7XG5cdH0sXG5cdHdoaXRlbmVzczogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2h3YicsIDEsIHZhbCk7XG5cdH0sXG5cdGJsYWNrbmVzczogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2h3YicsIDIsIHZhbCk7XG5cdH0sXG5cdHZhbHVlOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHN2JywgMiwgdmFsKTtcblx0fSxcblx0Y3lhbjogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2NteWsnLCAwLCB2YWwpO1xuXHR9LFxuXHRtYWdlbnRhOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnY215aycsIDEsIHZhbCk7XG5cdH0sXG5cdHllbGxvdzogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2NteWsnLCAyLCB2YWwpO1xuXHR9LFxuXHRibGFjazogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2NteWsnLCAzLCB2YWwpO1xuXHR9LFxuXG5cdGhleFN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5oZXhTdHJpbmcodGhpcy52YWx1ZXMucmdiKTtcblx0fSxcblx0cmdiU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLnJnYlN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0cmdiYVN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5yZ2JhU3RyaW5nKHRoaXMudmFsdWVzLnJnYiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRwZXJjZW50U3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLnBlcmNlbnRTdHJpbmcodGhpcy52YWx1ZXMucmdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdGhzbFN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5oc2xTdHJpbmcodGhpcy52YWx1ZXMuaHNsLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdGhzbGFTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcuaHNsYVN0cmluZyh0aGlzLnZhbHVlcy5oc2wsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0aHdiU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLmh3YlN0cmluZyh0aGlzLnZhbHVlcy5od2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0a2V5d29yZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5rZXl3b3JkKHRoaXMudmFsdWVzLnJnYiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXG5cdHJnYk51bWJlcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2I7XG5cdFx0cmV0dXJuIChyZ2JbMF0gPDwgMTYpIHwgKHJnYlsxXSA8PCA4KSB8IHJnYlsyXTtcblx0fSxcblxuXHRsdW1pbm9zaXR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNyZWxhdGl2ZWx1bWluYW5jZWRlZlxuXHRcdHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2I7XG5cdFx0dmFyIGx1bSA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hhbiA9IHJnYltpXSAvIDI1NTtcblx0XHRcdGx1bVtpXSA9IChjaGFuIDw9IDAuMDM5MjgpID8gY2hhbiAvIDEyLjkyIDogTWF0aC5wb3coKChjaGFuICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO1xuXHRcdH1cblx0XHRyZXR1cm4gMC4yMTI2ICogbHVtWzBdICsgMC43MTUyICogbHVtWzFdICsgMC4wNzIyICogbHVtWzJdO1xuXHR9LFxuXG5cdGNvbnRyYXN0OiBmdW5jdGlvbiAoY29sb3IyKSB7XG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNjb250cmFzdC1yYXRpb2RlZlxuXHRcdHZhciBsdW0xID0gdGhpcy5sdW1pbm9zaXR5KCk7XG5cdFx0dmFyIGx1bTIgPSBjb2xvcjIubHVtaW5vc2l0eSgpO1xuXHRcdGlmIChsdW0xID4gbHVtMikge1xuXHRcdFx0cmV0dXJuIChsdW0xICsgMC4wNSkgLyAobHVtMiArIDAuMDUpO1xuXHRcdH1cblx0XHRyZXR1cm4gKGx1bTIgKyAwLjA1KSAvIChsdW0xICsgMC4wNSk7XG5cdH0sXG5cblx0bGV2ZWw6IGZ1bmN0aW9uIChjb2xvcjIpIHtcblx0XHR2YXIgY29udHJhc3RSYXRpbyA9IHRoaXMuY29udHJhc3QoY29sb3IyKTtcblx0XHRpZiAoY29udHJhc3RSYXRpbyA+PSA3LjEpIHtcblx0XHRcdHJldHVybiAnQUFBJztcblx0XHR9XG5cblx0XHRyZXR1cm4gKGNvbnRyYXN0UmF0aW8gPj0gNC41KSA/ICdBQScgOiAnJztcblx0fSxcblxuXHRkYXJrOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gWUlRIGVxdWF0aW9uIGZyb20gaHR0cDovLzI0d2F5cy5vcmcvMjAxMC9jYWxjdWxhdGluZy1jb2xvci1jb250cmFzdFxuXHRcdHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2I7XG5cdFx0dmFyIHlpcSA9IChyZ2JbMF0gKiAyOTkgKyByZ2JbMV0gKiA1ODcgKyByZ2JbMl0gKiAxMTQpIC8gMTAwMDtcblx0XHRyZXR1cm4geWlxIDwgMTI4O1xuXHR9LFxuXG5cdGxpZ2h0OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLmRhcmsoKTtcblx0fSxcblxuXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmdiID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdHJnYltpXSA9IDI1NSAtIHRoaXMudmFsdWVzLnJnYltpXTtcblx0XHR9XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ3JnYicsIHJnYik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0bGlnaHRlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHRoc2xbMl0gKz0gaHNsWzJdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZGFya2VuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHNsID0gdGhpcy52YWx1ZXMuaHNsO1xuXHRcdGhzbFsyXSAtPSBoc2xbMl0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgaHNsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzYXR1cmF0ZTogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHRoc2xbMV0gKz0gaHNsWzFdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZGVzYXR1cmF0ZTogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHRoc2xbMV0gLT0gaHNsWzFdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d2hpdGVuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHdiID0gdGhpcy52YWx1ZXMuaHdiO1xuXHRcdGh3YlsxXSArPSBod2JbMV0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHdiJywgaHdiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRibGFja2VuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHdiID0gdGhpcy52YWx1ZXMuaHdiO1xuXHRcdGh3YlsyXSArPSBod2JbMl0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHdiJywgaHdiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRncmV5c2NhbGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3JheXNjYWxlI0NvbnZlcnRpbmdfY29sb3JfdG9fZ3JheXNjYWxlXG5cdFx0dmFyIHZhbCA9IHJnYlswXSAqIDAuMyArIHJnYlsxXSAqIDAuNTkgKyByZ2JbMl0gKiAwLjExO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdyZ2InLCBbdmFsLCB2YWwsIHZhbF0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsZWFyZXI6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBhbHBoYSA9IHRoaXMudmFsdWVzLmFscGhhO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdhbHBoYScsIGFscGhhIC0gKGFscGhhICogcmF0aW8pKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRvcGFxdWVyOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgYWxwaGEgPSB0aGlzLnZhbHVlcy5hbHBoYTtcblx0XHR0aGlzLnNldFZhbHVlcygnYWxwaGEnLCBhbHBoYSArIChhbHBoYSAqIHJhdGlvKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbiAoZGVncmVlcykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0dmFyIGh1ZSA9IChoc2xbMF0gKyBkZWdyZWVzKSAlIDM2MDtcblx0XHRoc2xbMF0gPSBodWUgPCAwID8gMzYwICsgaHVlIDogaHVlO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBQb3J0ZWQgZnJvbSBzYXNzIGltcGxlbWVudGF0aW9uIGluIENcblx0ICogaHR0cHM6Ly9naXRodWIuY29tL3Nhc3MvbGlic2Fzcy9ibG9iLzBlNmI0YTI4NTAwOTIzNTZhYTNlY2UwN2M2YjI0OWYwMjIxY2FjZWQvZnVuY3Rpb25zLmNwcCNMMjA5XG5cdCAqL1xuXHRtaXg6IGZ1bmN0aW9uIChtaXhpbkNvbG9yLCB3ZWlnaHQpIHtcblx0XHR2YXIgY29sb3IxID0gdGhpcztcblx0XHR2YXIgY29sb3IyID0gbWl4aW5Db2xvcjtcblx0XHR2YXIgcCA9IHdlaWdodCA9PT0gdW5kZWZpbmVkID8gMC41IDogd2VpZ2h0O1xuXG5cdFx0dmFyIHcgPSAyICogcCAtIDE7XG5cdFx0dmFyIGEgPSBjb2xvcjEuYWxwaGEoKSAtIGNvbG9yMi5hbHBoYSgpO1xuXG5cdFx0dmFyIHcxID0gKCgodyAqIGEgPT09IC0xKSA/IHcgOiAodyArIGEpIC8gKDEgKyB3ICogYSkpICsgMSkgLyAyLjA7XG5cdFx0dmFyIHcyID0gMSAtIHcxO1xuXG5cdFx0cmV0dXJuIHRoaXNcblx0XHRcdC5yZ2IoXG5cdFx0XHRcdHcxICogY29sb3IxLnJlZCgpICsgdzIgKiBjb2xvcjIucmVkKCksXG5cdFx0XHRcdHcxICogY29sb3IxLmdyZWVuKCkgKyB3MiAqIGNvbG9yMi5ncmVlbigpLFxuXHRcdFx0XHR3MSAqIGNvbG9yMS5ibHVlKCkgKyB3MiAqIGNvbG9yMi5ibHVlKClcblx0XHRcdClcblx0XHRcdC5hbHBoYShjb2xvcjEuYWxwaGEoKSAqIHAgKyBjb2xvcjIuYWxwaGEoKSAqICgxIC0gcCkpO1xuXHR9LFxuXG5cdHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnJnYigpO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gTk9URShTQik6IHVzaW5nIG5vZGUtY2xvbmUgY3JlYXRlcyBhIGRlcGVuZGVuY3kgdG8gQnVmZmVyIHdoZW4gdXNpbmcgYnJvd3NlcmlmeSxcblx0XHQvLyBtYWtpbmcgdGhlIGZpbmFsIGJ1aWxkIHdheSB0byBiaWcgdG8gZW1iZWQgaW4gQ2hhcnQuanMuIFNvIGxldCdzIGRvIGl0IG1hbnVhbGx5LFxuXHRcdC8vIGFzc3VtaW5nIHRoYXQgdmFsdWVzIHRvIGNsb25lIGFyZSAxIGRpbWVuc2lvbiBhcnJheXMgY29udGFpbmluZyBvbmx5IG51bWJlcnMsXG5cdFx0Ly8gZXhjZXB0ICdhbHBoYScgd2hpY2ggaXMgYSBudW1iZXIuXG5cdFx0dmFyIHJlc3VsdCA9IG5ldyBDb2xvcigpO1xuXHRcdHZhciBzb3VyY2UgPSB0aGlzLnZhbHVlcztcblx0XHR2YXIgdGFyZ2V0ID0gcmVzdWx0LnZhbHVlcztcblx0XHR2YXIgdmFsdWUsIHR5cGU7XG5cblx0XHRmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuXHRcdFx0aWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuXHRcdFx0XHR2YWx1ZSA9IHNvdXJjZVtwcm9wXTtcblx0XHRcdFx0dHlwZSA9ICh7fSkudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cdFx0XHRcdGlmICh0eXBlID09PSAnW29iamVjdCBBcnJheV0nKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Byb3BdID0gdmFsdWUuc2xpY2UoMCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcblx0XHRcdFx0XHR0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCd1bmV4cGVjdGVkIGNvbG9yIHZhbHVlOicsIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zcGFjZXMgPSB7XG5cdHJnYjogWydyZWQnLCAnZ3JlZW4nLCAnYmx1ZSddLFxuXHRoc2w6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAnbGlnaHRuZXNzJ10sXG5cdGhzdjogWydodWUnLCAnc2F0dXJhdGlvbicsICd2YWx1ZSddLFxuXHRod2I6IFsnaHVlJywgJ3doaXRlbmVzcycsICdibGFja25lc3MnXSxcblx0Y215azogWydjeWFuJywgJ21hZ2VudGEnLCAneWVsbG93JywgJ2JsYWNrJ11cbn07XG5cbkNvbG9yLnByb3RvdHlwZS5tYXhlcyA9IHtcblx0cmdiOiBbMjU1LCAyNTUsIDI1NV0sXG5cdGhzbDogWzM2MCwgMTAwLCAxMDBdLFxuXHRoc3Y6IFszNjAsIDEwMCwgMTAwXSxcblx0aHdiOiBbMzYwLCAxMDAsIDEwMF0sXG5cdGNteWs6IFsxMDAsIDEwMCwgMTAwLCAxMDBdXG59O1xuXG5Db2xvci5wcm90b3R5cGUuZ2V0VmFsdWVzID0gZnVuY3Rpb24gKHNwYWNlKSB7XG5cdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0dmFyIHZhbHMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFsc1tzcGFjZS5jaGFyQXQoaSldID0gdmFsdWVzW3NwYWNlXVtpXTtcblx0fVxuXG5cdGlmICh2YWx1ZXMuYWxwaGEgIT09IDEpIHtcblx0XHR2YWxzLmEgPSB2YWx1ZXMuYWxwaGE7XG5cdH1cblxuXHQvLyB7cjogMjU1LCBnOiAyNTUsIGI6IDI1NSwgYTogMC40fVxuXHRyZXR1cm4gdmFscztcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbiAoc3BhY2UsIHZhbHMpIHtcblx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHR2YXIgc3BhY2VzID0gdGhpcy5zcGFjZXM7XG5cdHZhciBtYXhlcyA9IHRoaXMubWF4ZXM7XG5cdHZhciBhbHBoYSA9IDE7XG5cdHZhciBpO1xuXG5cdHRoaXMudmFsaWQgPSB0cnVlO1xuXG5cdGlmIChzcGFjZSA9PT0gJ2FscGhhJykge1xuXHRcdGFscGhhID0gdmFscztcblx0fSBlbHNlIGlmICh2YWxzLmxlbmd0aCkge1xuXHRcdC8vIFsxMCwgMTAsIDEwXVxuXHRcdHZhbHVlc1tzcGFjZV0gPSB2YWxzLnNsaWNlKDAsIHNwYWNlLmxlbmd0aCk7XG5cdFx0YWxwaGEgPSB2YWxzW3NwYWNlLmxlbmd0aF07XG5cdH0gZWxzZSBpZiAodmFsc1tzcGFjZS5jaGFyQXQoMCldICE9PSB1bmRlZmluZWQpIHtcblx0XHQvLyB7cjogMTAsIGc6IDEwLCBiOiAxMH1cblx0XHRmb3IgKGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhbHVlc1tzcGFjZV1baV0gPSB2YWxzW3NwYWNlLmNoYXJBdChpKV07XG5cdFx0fVxuXG5cdFx0YWxwaGEgPSB2YWxzLmE7XG5cdH0gZWxzZSBpZiAodmFsc1tzcGFjZXNbc3BhY2VdWzBdXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8ge3JlZDogMTAsIGdyZWVuOiAxMCwgYmx1ZTogMTB9XG5cdFx0dmFyIGNoYW5zID0gc3BhY2VzW3NwYWNlXTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFsdWVzW3NwYWNlXVtpXSA9IHZhbHNbY2hhbnNbaV1dO1xuXHRcdH1cblxuXHRcdGFscGhhID0gdmFscy5hbHBoYTtcblx0fVxuXG5cdHZhbHVlcy5hbHBoYSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIChhbHBoYSA9PT0gdW5kZWZpbmVkID8gdmFsdWVzLmFscGhhIDogYWxwaGEpKSk7XG5cblx0aWYgKHNwYWNlID09PSAnYWxwaGEnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0dmFyIGNhcHBlZDtcblxuXHQvLyBjYXAgdmFsdWVzIG9mIHRoZSBzcGFjZSBwcmlvciBjb252ZXJ0aW5nIGFsbCB2YWx1ZXNcblx0Zm9yIChpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2FwcGVkID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4ZXNbc3BhY2VdW2ldLCB2YWx1ZXNbc3BhY2VdW2ldKSk7XG5cdFx0dmFsdWVzW3NwYWNlXVtpXSA9IE1hdGgucm91bmQoY2FwcGVkKTtcblx0fVxuXG5cdC8vIGNvbnZlcnQgdG8gYWxsIHRoZSBvdGhlciBjb2xvciBzcGFjZXNcblx0Zm9yICh2YXIgc25hbWUgaW4gc3BhY2VzKSB7XG5cdFx0aWYgKHNuYW1lICE9PSBzcGFjZSkge1xuXHRcdFx0dmFsdWVzW3NuYW1lXSA9IGNvbG9yQ29udmVydFtzcGFjZV1bc25hbWVdKHZhbHVlc1tzcGFjZV0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcblxuQ29sb3IucHJvdG90eXBlLnNldFNwYWNlID0gZnVuY3Rpb24gKHNwYWNlLCBhcmdzKSB7XG5cdHZhciB2YWxzID0gYXJnc1swXTtcblxuXHRpZiAodmFscyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gY29sb3IucmdiKClcblx0XHRyZXR1cm4gdGhpcy5nZXRWYWx1ZXMoc3BhY2UpO1xuXHR9XG5cblx0Ly8gY29sb3IucmdiKDEwLCAxMCwgMTApXG5cdGlmICh0eXBlb2YgdmFscyA9PT0gJ251bWJlcicpIHtcblx0XHR2YWxzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG5cdH1cblxuXHR0aGlzLnNldFZhbHVlcyhzcGFjZSwgdmFscyk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuQ29sb3IucHJvdG90eXBlLnNldENoYW5uZWwgPSBmdW5jdGlvbiAoc3BhY2UsIGluZGV4LCB2YWwpIHtcblx0dmFyIHN2YWx1ZXMgPSB0aGlzLnZhbHVlc1tzcGFjZV07XG5cdGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIGNvbG9yLnJlZCgpXG5cdFx0cmV0dXJuIHN2YWx1ZXNbaW5kZXhdO1xuXHR9IGVsc2UgaWYgKHZhbCA9PT0gc3ZhbHVlc1tpbmRleF0pIHtcblx0XHQvLyBjb2xvci5yZWQoY29sb3IucmVkKCkpXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvLyBjb2xvci5yZWQoMTAwKVxuXHRzdmFsdWVzW2luZGV4XSA9IHZhbDtcblx0dGhpcy5zZXRWYWx1ZXMoc3BhY2UsIHN2YWx1ZXMpO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdHdpbmRvdy5Db2xvciA9IENvbG9yO1xufVxuXG52YXIgY2hhcnRqc0NvbG9yID0gQ29sb3I7XG5cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XHJcblx0cmV0dXJuIFsnX19wcm90b19fJywgJ3Byb3RvdHlwZScsICdjb25zdHJ1Y3RvciddLmluZGV4T2Yoa2V5KSA9PT0gLTE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnNcclxuICovXHJcbnZhciBoZWxwZXJzID0ge1xyXG5cdC8qKlxyXG5cdCAqIEFuIGVtcHR5IGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCBmb3Igb3B0aW9uYWwgY2FsbGJhY2suXHJcblx0ICovXHJcblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHVuaXF1ZSBpZCwgc2VxdWVudGlhbGx5IGdlbmVyYXRlZCBmcm9tIGEgZ2xvYmFsIHZhcmlhYmxlLlxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XHJcblx0ICogQGZ1bmN0aW9uXHJcblx0ICovXHJcblx0dWlkOiAoZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgaWQgPSAwO1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gaWQrKztcclxuXHRcdH07XHJcblx0fSgpKSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgbmVpdGhlciBudWxsIG5vciB1bmRlZmluZWQsIGVsc2UgcmV0dXJucyBmYWxzZS5cclxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICogQHNpbmNlIDIuNy4wXHJcblx0ICovXHJcblx0aXNOdWxsT3JVbmRlZjogZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IChpbmNsdWRpbmcgdHlwZWQgYXJyYXlzKSwgZWxzZSByZXR1cm5zIGZhbHNlLlxyXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuXHQgKiBAZnVuY3Rpb25cclxuXHQgKi9cclxuXHRpc0FycmF5OiBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0XHR2YXIgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XHJcblx0XHRpZiAodHlwZS5zdWJzdHIoMCwgNykgPT09ICdbb2JqZWN0JyAmJiB0eXBlLnN1YnN0cigtNikgPT09ICdBcnJheV0nKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCAoZXhjbHVkaW5nIG51bGwpLCBlbHNlIHJldHVybnMgZmFsc2UuXHJcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxyXG5cdCAqIEBzaW5jZSAyLjcuMFxyXG5cdCAqL1xyXG5cdGlzT2JqZWN0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0cmV0dXJuIHZhbHVlICE9PSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSByZXR1cm5zIGZhbHNlXHJcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAgLSBUaGUgdmFsdWUgdG8gdGVzdC5cclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuXHQgKi9cclxuXHRpc0Zpbml0ZTogZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgJiYgaXNGaW5pdGUodmFsdWUpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYHZhbHVlYCBpZiBkZWZpbmVkLCBlbHNlIHJldHVybnMgYGRlZmF1bHRWYWx1ZWAuXHJcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgZGVmaW5lZC5cclxuXHQgKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgYHZhbHVlYCBpcyB1bmRlZmluZWQuXHJcblx0ICogQHJldHVybnMgeyp9XHJcblx0ICovXHJcblx0dmFsdWVPckRlZmF1bHQ6IGZ1bmN0aW9uKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcclxuXHRcdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB2YWx1ZSBhdCB0aGUgZ2l2ZW4gYGluZGV4YCBpbiBhcnJheSBpZiBkZWZpbmVkLCBlbHNlIHJldHVybnMgYGRlZmF1bHRWYWx1ZWAuXHJcblx0ICogQHBhcmFtIHtBcnJheX0gdmFsdWUgLSBUaGUgYXJyYXkgdG8gbG9va3VwIGZvciB2YWx1ZSBhdCBgaW5kZXhgLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBpbiBgdmFsdWVgIHRvIGxvb2t1cCBmb3IgdmFsdWUuXHJcblx0ICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGB2YWx1ZVtpbmRleF1gIGlzIHVuZGVmaW5lZC5cclxuXHQgKiBAcmV0dXJucyB7Kn1cclxuXHQgKi9cclxuXHR2YWx1ZUF0SW5kZXhPckRlZmF1bHQ6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgZGVmYXVsdFZhbHVlKSB7XHJcblx0XHRyZXR1cm4gaGVscGVycy52YWx1ZU9yRGVmYXVsdChoZWxwZXJzLmlzQXJyYXkodmFsdWUpID8gdmFsdWVbaW5kZXhdIDogdmFsdWUsIGRlZmF1bHRWYWx1ZSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2FsbHMgYGZuYCB3aXRoIHRoZSBnaXZlbiBgYXJnc2AgaW4gdGhlIHNjb3BlIGRlZmluZWQgYnkgYHRoaXNBcmdgIGFuZCByZXR1cm5zIHRoZVxyXG5cdCAqIHZhbHVlIHJldHVybmVkIGJ5IGBmbmAuIElmIGBmbmAgaXMgbm90IGEgZnVuY3Rpb24sIHRoaXMgbWV0aG9kIHJldHVybnMgdW5kZWZpbmVkLlxyXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXHJcblx0ICogQHBhcmFtIHtBcnJheXx1bmRlZmluZWR8bnVsbH0gYXJncyAtIFRoZSBhcmd1bWVudHMgd2l0aCB3aGljaCBgZm5gIHNob3VsZCBiZSBjYWxsZWQuXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IFt0aGlzQXJnXSAtIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcHJvdmlkZWQgZm9yIHRoZSBjYWxsIHRvIGBmbmAuXHJcblx0ICogQHJldHVybnMgeyp9XHJcblx0ICovXHJcblx0Y2FsbGJhY2s6IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGlzQXJnKSB7XHJcblx0XHRpZiAoZm4gJiYgdHlwZW9mIGZuLmNhbGwgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIE5vdGUoU0IpIGZvciBwZXJmb3JtYW5jZSBzYWtlLCB0aGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4gbG9vcGFibGUgdHlwZVxyXG5cdCAqIGlzIHVua25vd24gb3IgaW4gbm9uZSBpbnRlbnNpdmUgY29kZSAobm90IGNhbGxlZCBvZnRlbiBhbmQgc21hbGwgbG9vcGFibGUpLiBFbHNlXHJcblx0ICogaXQncyBwcmVmZXJhYmxlIHRvIHVzZSBhIHJlZ3VsYXIgZm9yKCkgbG9vcCBhbmQgc2F2ZSBleHRyYSBmdW5jdGlvbiBjYWxscy5cclxuXHQgKiBAcGFyYW0ge29iamVjdHxBcnJheX0gbG9vcGFibGUgLSBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGJlIGl0ZXJhdGVkLlxyXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaXRlbS5cclxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3RoaXNBcmddIC0gVGhlIHZhbHVlIG9mIGB0aGlzYCBwcm92aWRlZCBmb3IgdGhlIGNhbGwgdG8gYGZuYC5cclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXZlcnNlXSAtIElmIHRydWUsIGl0ZXJhdGVzIGJhY2t3YXJkIG9uIHRoZSBsb29wYWJsZS5cclxuXHQgKi9cclxuXHRlYWNoOiBmdW5jdGlvbihsb29wYWJsZSwgZm4sIHRoaXNBcmcsIHJldmVyc2UpIHtcclxuXHRcdHZhciBpLCBsZW4sIGtleXM7XHJcblx0XHRpZiAoaGVscGVycy5pc0FycmF5KGxvb3BhYmxlKSkge1xyXG5cdFx0XHRsZW4gPSBsb29wYWJsZS5sZW5ndGg7XHJcblx0XHRcdGlmIChyZXZlcnNlKSB7XHJcblx0XHRcdFx0Zm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0XHRcdGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRcdGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChoZWxwZXJzLmlzT2JqZWN0KGxvb3BhYmxlKSkge1xyXG5cdFx0XHRrZXlzID0gT2JqZWN0LmtleXMobG9vcGFibGUpO1xyXG5cdFx0XHRsZW4gPSBrZXlzLmxlbmd0aDtcclxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0Zm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtrZXlzW2ldXSwga2V5c1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGBhMGAgYW5kIGBhMWAgYXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudCwgZWxzZSByZXR1cm5zIGZhbHNlLlxyXG5cdCAqIEBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE0ODUzOTc0XHJcblx0ICogQHBhcmFtIHtBcnJheX0gYTAgLSBUaGUgYXJyYXkgdG8gY29tcGFyZVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGExIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuXHQgKi9cclxuXHRhcnJheUVxdWFsczogZnVuY3Rpb24oYTAsIGExKSB7XHJcblx0XHR2YXIgaSwgaWxlbiwgdjAsIHYxO1xyXG5cclxuXHRcdGlmICghYTAgfHwgIWExIHx8IGEwLmxlbmd0aCAhPT0gYTEubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYTAubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdHYwID0gYTBbaV07XHJcblx0XHRcdHYxID0gYTFbaV07XHJcblxyXG5cdFx0XHRpZiAodjAgaW5zdGFuY2VvZiBBcnJheSAmJiB2MSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcblx0XHRcdFx0aWYgKCFoZWxwZXJzLmFycmF5RXF1YWxzKHYwLCB2MSkpIHtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAodjAgIT09IHYxKSB7XHJcblx0XHRcdFx0Ly8gTk9URTogdHdvIGRpZmZlcmVudCBvYmplY3QgaW5zdGFuY2VzIHdpbGwgbmV2ZXIgYmUgZXF1YWw6IHt4OjIwfSAhPSB7eDoyMH1cclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgZGVlcCBjb3B5IG9mIGBzb3VyY2VgIHdpdGhvdXQga2VlcGluZyByZWZlcmVuY2VzIG9uIG9iamVjdHMgYW5kIGFycmF5cy5cclxuXHQgKiBAcGFyYW0geyp9IHNvdXJjZSAtIFRoZSB2YWx1ZSB0byBjbG9uZS5cclxuXHQgKiBAcmV0dXJucyB7Kn1cclxuXHQgKi9cclxuXHRjbG9uZTogZnVuY3Rpb24oc291cmNlKSB7XHJcblx0XHRpZiAoaGVscGVycy5pc0FycmF5KHNvdXJjZSkpIHtcclxuXHRcdFx0cmV0dXJuIHNvdXJjZS5tYXAoaGVscGVycy5jbG9uZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGhlbHBlcnMuaXNPYmplY3Qoc291cmNlKSkge1xyXG5cdFx0XHR2YXIgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShzb3VyY2UpO1xyXG5cdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XHJcblx0XHRcdHZhciBrbGVuID0ga2V5cy5sZW5ndGg7XHJcblx0XHRcdHZhciBrID0gMDtcclxuXHJcblx0XHRcdGZvciAoOyBrIDwga2xlbjsgKytrKSB7XHJcblx0XHRcdFx0dGFyZ2V0W2tleXNba11dID0gaGVscGVycy5jbG9uZShzb3VyY2Vba2V5c1trXV0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzb3VyY2U7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGRlZmF1bHQgbWVyZ2VyIHdoZW4gQ2hhcnQuaGVscGVycy5tZXJnZSBpcyBjYWxsZWQgd2l0aG91dCBtZXJnZXIgb3B0aW9uLlxyXG5cdCAqIE5vdGUoU0IpOiBhbHNvIHVzZWQgYnkgbWVyZ2VDb25maWcgYW5kIG1lcmdlU2NhbGVDb25maWcgYXMgZmFsbGJhY2suXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfbWVyZ2VyOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XHJcblx0XHRpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xyXG5cdFx0XHQvLyBXZSB3YW50IHRvIGVuc3VyZSB3ZSBkbyBub3QgY29weSBwcm90b3R5cGVzIG92ZXJcclxuXHRcdFx0Ly8gYXMgdGhpcyBjYW4gcG9sbHV0ZSBnbG9iYWwgbmFtZXNwYWNlc1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHR2YWwgPSB0YXJnZXRba2V5XTtcclxuXHRcdHZhciBzdmFsID0gc291cmNlW2tleV07XHJcblxyXG5cdFx0aWYgKGhlbHBlcnMuaXNPYmplY3QodHZhbCkgJiYgaGVscGVycy5pc09iamVjdChzdmFsKSkge1xyXG5cdFx0XHRoZWxwZXJzLm1lcmdlKHR2YWwsIHN2YWwsIG9wdGlvbnMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGFyZ2V0W2tleV0gPSBoZWxwZXJzLmNsb25lKHN2YWwpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIE1lcmdlcyBzb3VyY2Vba2V5XSBpbiB0YXJnZXRba2V5XSBvbmx5IGlmIHRhcmdldFtrZXldIGlzIHVuZGVmaW5lZC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9tZXJnZXJJZjogZnVuY3Rpb24oa2V5LCB0YXJnZXQsIHNvdXJjZSkge1xyXG5cdFx0aWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcclxuXHRcdFx0Ly8gV2Ugd2FudCB0byBlbnN1cmUgd2UgZG8gbm90IGNvcHkgcHJvdG90eXBlcyBvdmVyXHJcblx0XHRcdC8vIGFzIHRoaXMgY2FuIHBvbGx1dGUgZ2xvYmFsIG5hbWVzcGFjZXNcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0dmFsID0gdGFyZ2V0W2tleV07XHJcblx0XHR2YXIgc3ZhbCA9IHNvdXJjZVtrZXldO1xyXG5cclxuXHRcdGlmIChoZWxwZXJzLmlzT2JqZWN0KHR2YWwpICYmIGhlbHBlcnMuaXNPYmplY3Qoc3ZhbCkpIHtcclxuXHRcdFx0aGVscGVycy5tZXJnZUlmKHR2YWwsIHN2YWwpO1xyXG5cdFx0fSBlbHNlIGlmICghdGFyZ2V0Lmhhc093blByb3BlcnR5KGtleSkpIHtcclxuXHRcdFx0dGFyZ2V0W2tleV0gPSBoZWxwZXJzLmNsb25lKHN2YWwpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXHJcblx0ICogSU1QT1JUQU5UOiBgdGFyZ2V0YCBpcyBub3QgY2xvbmVkIGFuZCB3aWxsIGJlIHVwZGF0ZWQgd2l0aCBgc291cmNlYCBwcm9wZXJ0aWVzLlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgc291cmNlcyBhcmUgbWVyZ2VkIGludG8uXHJcblx0ICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IHNvdXJjZSAtIE9iamVjdChzKSB0byBtZXJnZSBpbnRvIGB0YXJnZXRgLlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBNZXJnaW5nIG9wdGlvbnM6XHJcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMubWVyZ2VyXSAtIFRoZSBtZXJnZSBtZXRob2QgKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXHJcblx0ICogQHJldHVybnMge29iamVjdH0gVGhlIGB0YXJnZXRgIG9iamVjdC5cclxuXHQgKi9cclxuXHRtZXJnZTogZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcclxuXHRcdHZhciBzb3VyY2VzID0gaGVscGVycy5pc0FycmF5KHNvdXJjZSkgPyBzb3VyY2UgOiBbc291cmNlXTtcclxuXHRcdHZhciBpbGVuID0gc291cmNlcy5sZW5ndGg7XHJcblx0XHR2YXIgbWVyZ2UsIGksIGtleXMsIGtsZW4sIGs7XHJcblxyXG5cdFx0aWYgKCFoZWxwZXJzLmlzT2JqZWN0KHRhcmdldCkpIHtcclxuXHRcdFx0cmV0dXJuIHRhcmdldDtcclxuXHRcdH1cclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHRcdG1lcmdlID0gb3B0aW9ucy5tZXJnZXIgfHwgaGVscGVycy5fbWVyZ2VyO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0c291cmNlID0gc291cmNlc1tpXTtcclxuXHRcdFx0aWYgKCFoZWxwZXJzLmlzT2JqZWN0KHNvdXJjZSkpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0a2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XHJcblx0XHRcdGZvciAoayA9IDAsIGtsZW4gPSBrZXlzLmxlbmd0aDsgayA8IGtsZW47ICsraykge1xyXG5cdFx0XHRcdG1lcmdlKGtleXNba10sIHRhcmdldCwgc291cmNlLCBvcHRpb25zKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0YXJnZXQ7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVjdXJzaXZlbHkgZGVlcCBjb3BpZXMgYHNvdXJjZWAgcHJvcGVydGllcyBpbnRvIGB0YXJnZXRgICpvbmx5KiBpZiBub3QgZGVmaW5lZCBpbiB0YXJnZXQuXHJcblx0ICogSU1QT1JUQU5UOiBgdGFyZ2V0YCBpcyBub3QgY2xvbmVkIGFuZCB3aWxsIGJlIHVwZGF0ZWQgd2l0aCBgc291cmNlYCBwcm9wZXJ0aWVzLlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgc291cmNlcyBhcmUgbWVyZ2VkIGludG8uXHJcblx0ICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IHNvdXJjZSAtIE9iamVjdChzKSB0byBtZXJnZSBpbnRvIGB0YXJnZXRgLlxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBgdGFyZ2V0YCBvYmplY3QuXHJcblx0ICovXHJcblx0bWVyZ2VJZjogZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UpIHtcclxuXHRcdHJldHVybiBoZWxwZXJzLm1lcmdlKHRhcmdldCwgc291cmNlLCB7bWVyZ2VyOiBoZWxwZXJzLl9tZXJnZXJJZn0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEFwcGxpZXMgdGhlIGNvbnRlbnRzIG9mIHR3byBvciBtb3JlIG9iamVjdHMgdG9nZXRoZXIgaW50byB0aGUgZmlyc3Qgb2JqZWN0LlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgb2JqZWN0cyBhcmUgbWVyZ2VkIGludG8uXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGFyZzEgLSBPYmplY3QgY29udGFpbmluZyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gbWVyZ2UgaW4gdGFyZ2V0LlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhcmdOIC0gQWRkaXRpb25hbCBvYmplY3RzIGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBtZXJnZSBpbiB0YXJnZXQuXHJcblx0ICogQHJldHVybnMge29iamVjdH0gVGhlIGB0YXJnZXRgIG9iamVjdC5cclxuXHQgKi9cclxuXHRleHRlbmQ6IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XHJcblx0XHRyZXR1cm4gaGVscGVycy5tZXJnZSh0YXJnZXQsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwge1xyXG5cdFx0XHRtZXJnZXI6IGZ1bmN0aW9uKGtleSwgZHN0LCBzcmMpIHtcclxuXHRcdFx0XHRkc3Rba2V5XSA9IHNyY1trZXldO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBCYXNpYyBqYXZhc2NyaXB0IGluaGVyaXRhbmNlIGJhc2VkIG9uIHRoZSBtb2RlbCBjcmVhdGVkIGluIEJhY2tib25lLmpzXHJcblx0ICovXHJcblx0aW5oZXJpdHM6IGZ1bmN0aW9uKGV4dGVuc2lvbnMpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgQ2hhcnRFbGVtZW50ID0gKGV4dGVuc2lvbnMgJiYgZXh0ZW5zaW9ucy5oYXNPd25Qcm9wZXJ0eSgnY29uc3RydWN0b3InKSkgPyBleHRlbnNpb25zLmNvbnN0cnVjdG9yIDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiBtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgU3Vycm9nYXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHRoaXMuY29uc3RydWN0b3IgPSBDaGFydEVsZW1lbnQ7XHJcblx0XHR9O1xyXG5cclxuXHRcdFN1cnJvZ2F0ZS5wcm90b3R5cGUgPSBtZS5wcm90b3R5cGU7XHJcblx0XHRDaGFydEVsZW1lbnQucHJvdG90eXBlID0gbmV3IFN1cnJvZ2F0ZSgpO1xyXG5cdFx0Q2hhcnRFbGVtZW50LmV4dGVuZCA9IGhlbHBlcnMuaW5oZXJpdHM7XHJcblxyXG5cdFx0aWYgKGV4dGVuc2lvbnMpIHtcclxuXHRcdFx0aGVscGVycy5leHRlbmQoQ2hhcnRFbGVtZW50LnByb3RvdHlwZSwgZXh0ZW5zaW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Q2hhcnRFbGVtZW50Ll9fc3VwZXJfXyA9IG1lLnByb3RvdHlwZTtcclxuXHRcdHJldHVybiBDaGFydEVsZW1lbnQ7XHJcblx0fSxcclxuXHJcblx0X2RlcHJlY2F0ZWQ6IGZ1bmN0aW9uKHNjb3BlLCB2YWx1ZSwgcHJldmlvdXMsIGN1cnJlbnQpIHtcclxuXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybihzY29wZSArICc6IFwiJyArIHByZXZpb3VzICtcclxuXHRcdFx0XHQnXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcIicgKyBjdXJyZW50ICsgJ1wiIGluc3RlYWQnKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG52YXIgaGVscGVyc19jb3JlID0gaGVscGVycztcclxuXHJcbi8vIERFUFJFQ0FUSU9OU1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5jYWxsYmFjayBpbnN0ZWFkLlxyXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5jYWxsQ2FsbGJhY2tcclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5oZWxwZXJzLmNhbGxDYWxsYmFjayA9IGhlbHBlcnMuY2FsbGJhY2s7XHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiBpbnN0ZWFkLlxyXG4gKiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiBjb21wYXRpYmlsaXR5OiBDaHJvbWUsIE9wZXJhLCBTYWZhcmksIEZGMS41KywgSUU5K1xyXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5pbmRleE9mXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuaGVscGVycy5pbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGZyb21JbmRleCkge1xyXG5cdHJldHVybiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGFycmF5LCBpdGVtLCBmcm9tSW5kZXgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy52YWx1ZU9yRGVmYXVsdCBpbnN0ZWFkLlxyXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdFxyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXHJcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuICogQHByaXZhdGVcclxuICovXHJcbmhlbHBlcnMuZ2V0VmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0O1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQgaW5zdGVhZC5cclxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0XHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQgPSBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdDtcblxuLyoqXHJcbiAqIEVhc2luZyBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tIFJvYmVydCBQZW5uZXIncyBlYXNpbmcgZXF1YXRpb25zLlxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuZWFzaW5nRWZmZWN0c1xyXG4gKiBAc2VlIGh0dHA6Ly93d3cucm9iZXJ0cGVubmVyLmNvbS9lYXNpbmcvXHJcbiAqL1xyXG52YXIgZWZmZWN0cyA9IHtcclxuXHRsaW5lYXI6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHJldHVybiB0O1xyXG5cdH0sXHJcblxyXG5cdGVhc2VJblF1YWQ6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHJldHVybiB0ICogdDtcclxuXHR9LFxyXG5cclxuXHRlYXNlT3V0UXVhZDogZnVuY3Rpb24odCkge1xyXG5cdFx0cmV0dXJuIC10ICogKHQgLSAyKTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbih0KSB7XHJcblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcclxuXHRcdFx0cmV0dXJuIDAuNSAqIHQgKiB0O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIC0wLjUgKiAoKC0tdCkgKiAodCAtIDIpIC0gMSk7XHJcblx0fSxcclxuXHJcblx0ZWFzZUluQ3ViaWM6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHJldHVybiB0ICogdCAqIHQ7XHJcblx0fSxcclxuXHJcblx0ZWFzZU91dEN1YmljOiBmdW5jdGlvbih0KSB7XHJcblx0XHRyZXR1cm4gKHQgPSB0IC0gMSkgKiB0ICogdCArIDE7XHJcblx0fSxcclxuXHJcblx0ZWFzZUluT3V0Q3ViaWM6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xyXG5cdFx0XHRyZXR1cm4gMC41ICogdCAqIHQgKiB0O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICsgMik7XHJcblx0fSxcclxuXHJcblx0ZWFzZUluUXVhcnQ6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHJldHVybiB0ICogdCAqIHQgKiB0O1xyXG5cdH0sXHJcblxyXG5cdGVhc2VPdXRRdWFydDogZnVuY3Rpb24odCkge1xyXG5cdFx0cmV0dXJuIC0oKHQgPSB0IC0gMSkgKiB0ICogdCAqIHQgLSAxKTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5PdXRRdWFydDogZnVuY3Rpb24odCkge1xyXG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XHJcblx0XHRcdHJldHVybiAwLjUgKiB0ICogdCAqIHQgKiB0O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIC0wLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5RdWludDogZnVuY3Rpb24odCkge1xyXG5cdFx0cmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xyXG5cdH0sXHJcblxyXG5cdGVhc2VPdXRRdWludDogZnVuY3Rpb24odCkge1xyXG5cdFx0cmV0dXJuICh0ID0gdCAtIDEpICogdCAqIHQgKiB0ICogdCArIDE7XHJcblx0fSxcclxuXHJcblx0ZWFzZUluT3V0UXVpbnQ6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xyXG5cdFx0XHRyZXR1cm4gMC41ICogdCAqIHQgKiB0ICogdCAqIHQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpO1xyXG5cdH0sXHJcblxyXG5cdGVhc2VJblNpbmU6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHJldHVybiAtTWF0aC5jb3ModCAqIChNYXRoLlBJIC8gMikpICsgMTtcclxuXHR9LFxyXG5cclxuXHRlYXNlT3V0U2luZTogZnVuY3Rpb24odCkge1xyXG5cdFx0cmV0dXJuIE1hdGguc2luKHQgKiAoTWF0aC5QSSAvIDIpKTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5PdXRTaW5lOiBmdW5jdGlvbih0KSB7XHJcblx0XHRyZXR1cm4gLTAuNSAqIChNYXRoLmNvcyhNYXRoLlBJICogdCkgLSAxKTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5FeHBvOiBmdW5jdGlvbih0KSB7XHJcblx0XHRyZXR1cm4gKHQgPT09IDApID8gMCA6IE1hdGgucG93KDIsIDEwICogKHQgLSAxKSk7XHJcblx0fSxcclxuXHJcblx0ZWFzZU91dEV4cG86IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHJldHVybiAodCA9PT0gMSkgPyAxIDogLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5PdXRFeHBvOiBmdW5jdGlvbih0KSB7XHJcblx0XHRpZiAodCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH1cclxuXHRcdGlmICh0ID09PSAxKSB7XHJcblx0XHRcdHJldHVybiAxO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XHJcblx0XHRcdHJldHVybiAwLjUgKiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogLS10KSArIDIpO1xyXG5cdH0sXHJcblxyXG5cdGVhc2VJbkNpcmM6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdGlmICh0ID49IDEpIHtcclxuXHRcdFx0cmV0dXJuIHQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gLShNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpO1xyXG5cdH0sXHJcblxyXG5cdGVhc2VPdXRDaXJjOiBmdW5jdGlvbih0KSB7XHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KDEgLSAodCA9IHQgLSAxKSAqIHQpO1xyXG5cdH0sXHJcblxyXG5cdGVhc2VJbk91dENpcmM6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xyXG5cdFx0XHRyZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5FbGFzdGljOiBmdW5jdGlvbih0KSB7XHJcblx0XHR2YXIgcyA9IDEuNzAxNTg7XHJcblx0XHR2YXIgcCA9IDA7XHJcblx0XHR2YXIgYSA9IDE7XHJcblx0XHRpZiAodCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH1cclxuXHRcdGlmICh0ID09PSAxKSB7XHJcblx0XHRcdHJldHVybiAxO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCFwKSB7XHJcblx0XHRcdHAgPSAwLjM7XHJcblx0XHR9XHJcblx0XHRpZiAoYSA8IDEpIHtcclxuXHRcdFx0YSA9IDE7XHJcblx0XHRcdHMgPSBwIC8gNDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxIC8gYSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gLShhICogTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcclxuXHR9LFxyXG5cclxuXHRlYXNlT3V0RWxhc3RpYzogZnVuY3Rpb24odCkge1xyXG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xyXG5cdFx0dmFyIHAgPSAwO1xyXG5cdFx0dmFyIGEgPSAxO1xyXG5cdFx0aWYgKHQgPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9XHJcblx0XHRpZiAodCA9PT0gMSkge1xyXG5cdFx0XHRyZXR1cm4gMTtcclxuXHRcdH1cclxuXHRcdGlmICghcCkge1xyXG5cdFx0XHRwID0gMC4zO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGEgPCAxKSB7XHJcblx0XHRcdGEgPSAxO1xyXG5cdFx0XHRzID0gcCAvIDQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSAvIGEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKyAxO1xyXG5cdH0sXHJcblxyXG5cdGVhc2VJbk91dEVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHZhciBzID0gMS43MDE1ODtcclxuXHRcdHZhciBwID0gMDtcclxuXHRcdHZhciBhID0gMTtcclxuXHRcdGlmICh0ID09PSAwKSB7XHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCh0IC89IDAuNSkgPT09IDIpIHtcclxuXHRcdFx0cmV0dXJuIDE7XHJcblx0XHR9XHJcblx0XHRpZiAoIXApIHtcclxuXHRcdFx0cCA9IDAuNDU7XHJcblx0XHR9XHJcblx0XHRpZiAoYSA8IDEpIHtcclxuXHRcdFx0YSA9IDE7XHJcblx0XHRcdHMgPSBwIC8gNDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxIC8gYSk7XHJcblx0XHR9XHJcblx0XHRpZiAodCA8IDEpIHtcclxuXHRcdFx0cmV0dXJuIC0wLjUgKiAoYSAqIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKiAwLjUgKyAxO1xyXG5cdH0sXHJcblx0ZWFzZUluQmFjazogZnVuY3Rpb24odCkge1xyXG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xyXG5cdFx0cmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XHJcblx0fSxcclxuXHJcblx0ZWFzZU91dEJhY2s6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHZhciBzID0gMS43MDE1ODtcclxuXHRcdHJldHVybiAodCA9IHQgLSAxKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XHJcblx0fSxcclxuXHJcblx0ZWFzZUluT3V0QmFjazogZnVuY3Rpb24odCkge1xyXG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xyXG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XHJcblx0XHRcdHJldHVybiAwLjUgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0ICsgcykgKyAyKTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5Cb3VuY2U6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHJldHVybiAxIC0gZWZmZWN0cy5lYXNlT3V0Qm91bmNlKDEgLSB0KTtcclxuXHR9LFxyXG5cclxuXHRlYXNlT3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XHJcblx0XHRpZiAodCA8ICgxIC8gMi43NSkpIHtcclxuXHRcdFx0cmV0dXJuIDcuNTYyNSAqIHQgKiB0O1xyXG5cdFx0fVxyXG5cdFx0aWYgKHQgPCAoMiAvIDIuNzUpKSB7XHJcblx0XHRcdHJldHVybiA3LjU2MjUgKiAodCAtPSAoMS41IC8gMi43NSkpICogdCArIDAuNzU7XHJcblx0XHR9XHJcblx0XHRpZiAodCA8ICgyLjUgLyAyLjc1KSkge1xyXG5cdFx0XHRyZXR1cm4gNy41NjI1ICogKHQgLT0gKDIuMjUgLyAyLjc1KSkgKiB0ICsgMC45Mzc1O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIDcuNTYyNSAqICh0IC09ICgyLjYyNSAvIDIuNzUpKSAqIHQgKyAwLjk4NDM3NTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5PdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdGlmICh0IDwgMC41KSB7XHJcblx0XHRcdHJldHVybiBlZmZlY3RzLmVhc2VJbkJvdW5jZSh0ICogMikgKiAwLjU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZWZmZWN0cy5lYXNlT3V0Qm91bmNlKHQgKiAyIC0gMSkgKiAwLjUgKyAwLjU7XHJcblx0fVxyXG59O1xyXG5cclxudmFyIGhlbHBlcnNfZWFzaW5nID0ge1xyXG5cdGVmZmVjdHM6IGVmZmVjdHNcclxufTtcclxuXHJcbi8vIERFUFJFQ0FUSU9OU1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5lYXNpbmcuZWZmZWN0cyBpbnN0ZWFkLlxyXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5lYXNpbmdFZmZlY3RzXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuaGVscGVyc19jb3JlLmVhc2luZ0VmZmVjdHMgPSBlZmZlY3RzO1xuXG52YXIgUEkgPSBNYXRoLlBJO1xyXG52YXIgUkFEX1BFUl9ERUcgPSBQSSAvIDE4MDtcclxudmFyIERPVUJMRV9QSSA9IFBJICogMjtcclxudmFyIEhBTEZfUEkgPSBQSSAvIDI7XHJcbnZhciBRVUFSVEVSX1BJID0gUEkgLyA0O1xyXG52YXIgVFdPX1RISVJEU19QSSA9IFBJICogMiAvIDM7XHJcblxyXG4vKipcclxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmNhbnZhc1xyXG4gKi9cclxudmFyIGV4cG9ydHMkMSA9IHtcclxuXHQvKipcclxuXHQgKiBDbGVhcnMgdGhlIGVudGlyZSBjYW52YXMgYXNzb2NpYXRlZCB0byB0aGUgZ2l2ZW4gYGNoYXJ0YC5cclxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCBmb3Igd2hpY2ggdG8gY2xlYXIgdGhlIGNhbnZhcy5cclxuXHQgKi9cclxuXHRjbGVhcjogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdGNoYXJ0LmN0eC5jbGVhclJlY3QoMCwgMCwgY2hhcnQud2lkdGgsIGNoYXJ0LmhlaWdodCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBhIFwicGF0aFwiIGZvciBhIHJlY3RhbmdsZSB3aXRoIHJvdW5kZWQgY29ybmVycyBhdCBwb3NpdGlvbiAoeCwgeSkgd2l0aCBhXHJcblx0ICogZ2l2ZW4gc2l6ZSAod2lkdGgsIGhlaWdodCkgYW5kIHRoZSBzYW1lIGByYWRpdXNgIGZvciBhbGwgY29ybmVycy5cclxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gVGhlIGNhbnZhcyAyRCBDb250ZXh0LlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggYXhpcyBvZiB0aGUgY29vcmRpbmF0ZSBmb3IgdGhlIHJlY3RhbmdsZSBzdGFydGluZyBwb2ludC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IGF4aXMgb2YgdGhlIGNvb3JkaW5hdGUgZm9yIHRoZSByZWN0YW5nbGUgc3RhcnRpbmcgcG9pbnQuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHJlY3RhbmdsZSdzIHdpZHRoLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgcmVjdGFuZ2xlJ3MgaGVpZ2h0LlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBUaGUgcm91bmRlZCBhbW91bnQgKGluIHBpeGVscykgZm9yIHRoZSBmb3VyIGNvcm5lcnMuXHJcblx0ICogQHRvZG8gaGFuZGxlIGByYWRpdXNgIGFzIHRvcC1sZWZ0LCB0b3AtcmlnaHQsIGJvdHRvbS1yaWdodCwgYm90dG9tLWxlZnQgYXJyYXkvb2JqZWN0P1xyXG5cdCAqL1xyXG5cdHJvdW5kZWRSZWN0OiBmdW5jdGlvbihjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xyXG5cdFx0aWYgKHJhZGl1cykge1xyXG5cdFx0XHR2YXIgciA9IE1hdGgubWluKHJhZGl1cywgaGVpZ2h0IC8gMiwgd2lkdGggLyAyKTtcclxuXHRcdFx0dmFyIGxlZnQgPSB4ICsgcjtcclxuXHRcdFx0dmFyIHRvcCA9IHkgKyByO1xyXG5cdFx0XHR2YXIgcmlnaHQgPSB4ICsgd2lkdGggLSByO1xyXG5cdFx0XHR2YXIgYm90dG9tID0geSArIGhlaWdodCAtIHI7XHJcblxyXG5cdFx0XHRjdHgubW92ZVRvKHgsIHRvcCk7XHJcblx0XHRcdGlmIChsZWZ0IDwgcmlnaHQgJiYgdG9wIDwgYm90dG9tKSB7XHJcblx0XHRcdFx0Y3R4LmFyYyhsZWZ0LCB0b3AsIHIsIC1QSSwgLUhBTEZfUEkpO1xyXG5cdFx0XHRcdGN0eC5hcmMocmlnaHQsIHRvcCwgciwgLUhBTEZfUEksIDApO1xyXG5cdFx0XHRcdGN0eC5hcmMocmlnaHQsIGJvdHRvbSwgciwgMCwgSEFMRl9QSSk7XHJcblx0XHRcdFx0Y3R4LmFyYyhsZWZ0LCBib3R0b20sIHIsIEhBTEZfUEksIFBJKTtcclxuXHRcdFx0fSBlbHNlIGlmIChsZWZ0IDwgcmlnaHQpIHtcclxuXHRcdFx0XHRjdHgubW92ZVRvKGxlZnQsIHkpO1xyXG5cdFx0XHRcdGN0eC5hcmMocmlnaHQsIHRvcCwgciwgLUhBTEZfUEksIEhBTEZfUEkpO1xyXG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgdG9wLCByLCBIQUxGX1BJLCBQSSArIEhBTEZfUEkpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRvcCA8IGJvdHRvbSkge1xyXG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgdG9wLCByLCAtUEksIDApO1xyXG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgYm90dG9tLCByLCAwLCBQSSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y3R4LmFyYyhsZWZ0LCB0b3AsIHIsIC1QSSwgUEkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcclxuXHRcdFx0Y3R4Lm1vdmVUbyh4LCB5KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGRyYXdQb2ludDogZnVuY3Rpb24oY3R4LCBzdHlsZSwgcmFkaXVzLCB4LCB5LCByb3RhdGlvbikge1xyXG5cdFx0dmFyIHR5cGUsIHhPZmZzZXQsIHlPZmZzZXQsIHNpemUsIGNvcm5lclJhZGl1cztcclxuXHRcdHZhciByYWQgPSAocm90YXRpb24gfHwgMCkgKiBSQURfUEVSX0RFRztcclxuXHJcblx0XHRpZiAoc3R5bGUgJiYgdHlwZW9mIHN0eWxlID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHR0eXBlID0gc3R5bGUudG9TdHJpbmcoKTtcclxuXHRcdFx0aWYgKHR5cGUgPT09ICdbb2JqZWN0IEhUTUxJbWFnZUVsZW1lbnRdJyB8fCB0eXBlID09PSAnW29iamVjdCBIVE1MQ2FudmFzRWxlbWVudF0nKSB7XHJcblx0XHRcdFx0Y3R4LnNhdmUoKTtcclxuXHRcdFx0XHRjdHgudHJhbnNsYXRlKHgsIHkpO1xyXG5cdFx0XHRcdGN0eC5yb3RhdGUocmFkKTtcclxuXHRcdFx0XHRjdHguZHJhd0ltYWdlKHN0eWxlLCAtc3R5bGUud2lkdGggLyAyLCAtc3R5bGUuaGVpZ2h0IC8gMiwgc3R5bGUud2lkdGgsIHN0eWxlLmhlaWdodCk7XHJcblx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaXNOYU4ocmFkaXVzKSB8fCByYWRpdXMgPD0gMCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cclxuXHRcdHN3aXRjaCAoc3R5bGUpIHtcclxuXHRcdC8vIERlZmF1bHQgaW5jbHVkZXMgY2lyY2xlXHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHRjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgRE9VQkxFX1BJKTtcclxuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJ3RyaWFuZ2xlJzpcclxuXHRcdFx0Y3R4Lm1vdmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xyXG5cdFx0XHRyYWQgKz0gVFdPX1RISVJEU19QSTtcclxuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xyXG5cdFx0XHRyYWQgKz0gVFdPX1RISVJEU19QSTtcclxuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xyXG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSAncmVjdFJvdW5kZWQnOlxyXG5cdFx0XHQvLyBOT1RFOiB0aGUgcm91bmRlZCByZWN0IGltcGxlbWVudGF0aW9uIGNoYW5nZWQgdG8gdXNlIGBhcmNgIGluc3RlYWQgb2ZcclxuXHRcdFx0Ly8gYHF1YWRyYXRpY0N1cnZlVG9gIHNpbmNlIGl0IGdlbmVyYXRlcyBiZXR0ZXIgcmVzdWx0cyB3aGVuIHJlY3QgaXNcclxuXHRcdFx0Ly8gYWxtb3N0IGEgY2lyY2xlLiAwLjUxNiAoaW5zdGVhZCBvZiAwLjUpIHByb2R1Y2VzIHJlc3VsdHMgd2l0aCB2aXN1YWxseVxyXG5cdFx0XHQvLyBjbG9zZXIgcHJvcG9ydGlvbiB0byB0aGUgcHJldmlvdXMgaW1wbCBhbmQgaXQgaXMgaW5zY3JpYmVkIGluIHRoZVxyXG5cdFx0XHQvLyBjaXJjbGUgd2l0aCBgcmFkaXVzYC4gRm9yIG1vcmUgZGV0YWlscywgc2VlIHRoZSBmb2xsb3dpbmcgUFJzOlxyXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTU5N1xyXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTg1OFxyXG5cdFx0XHRjb3JuZXJSYWRpdXMgPSByYWRpdXMgKiAwLjUxNjtcclxuXHRcdFx0c2l6ZSA9IHJhZGl1cyAtIGNvcm5lclJhZGl1cztcclxuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcclxuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcclxuXHRcdFx0Y3R4LmFyYyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gUEksIHJhZCAtIEhBTEZfUEkpO1xyXG5cdFx0XHRjdHguYXJjKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBIQUxGX1BJLCByYWQpO1xyXG5cdFx0XHRjdHguYXJjKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQsIHJhZCArIEhBTEZfUEkpO1xyXG5cdFx0XHRjdHguYXJjKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgKyBIQUxGX1BJLCByYWQgKyBQSSk7XHJcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlICdyZWN0JzpcclxuXHRcdFx0aWYgKCFyb3RhdGlvbikge1xyXG5cdFx0XHRcdHNpemUgPSBNYXRoLlNRUlQxXzIgKiByYWRpdXM7XHJcblx0XHRcdFx0Y3R4LnJlY3QoeCAtIHNpemUsIHkgLSBzaXplLCAyICogc2l6ZSwgMiAqIHNpemUpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJhZCArPSBRVUFSVEVSX1BJO1xyXG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXHJcblx0XHRjYXNlICdyZWN0Um90JzpcclxuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XHJcblx0XHRcdHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xyXG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XHJcblx0XHRcdGN0eC5saW5lVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcclxuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xyXG5cdFx0XHRjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XHJcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlICdjcm9zc1JvdCc6XHJcblx0XHRcdHJhZCArPSBRVUFSVEVSX1BJO1xyXG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXHJcblx0XHRjYXNlICdjcm9zcyc6XHJcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xyXG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcclxuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xyXG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XHJcblx0XHRcdGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcclxuXHRcdFx0Y3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJ3N0YXInOlxyXG5cdFx0XHR4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcclxuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XHJcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcclxuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xyXG5cdFx0XHRjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XHJcblx0XHRcdGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcclxuXHRcdFx0cmFkICs9IFFVQVJURVJfUEk7XHJcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xyXG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcclxuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xyXG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XHJcblx0XHRcdGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcclxuXHRcdFx0Y3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJ2xpbmUnOlxyXG5cdFx0XHR4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcclxuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XHJcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcclxuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJ2Rhc2gnOlxyXG5cdFx0XHRjdHgubW92ZVRvKHgsIHkpO1xyXG5cdFx0XHRjdHgubGluZVRvKHggKyBNYXRoLmNvcyhyYWQpICogcmFkaXVzLCB5ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cyk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cclxuXHRcdGN0eC5maWxsKCk7XHJcblx0XHRjdHguc3Ryb2tlKCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIHJlY3RhbmdsZVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwb2ludCAtIFRoZSBwb2ludCB0byB0ZXN0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGFyZWEgLSBUaGUgcmVjdGFuZ2xlXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfaXNQb2ludEluQXJlYTogZnVuY3Rpb24ocG9pbnQsIGFyZWEpIHtcclxuXHRcdHZhciBlcHNpbG9uID0gMWUtNjsgLy8gMWUtNiBpcyBtYXJnaW4gaW4gcGl4ZWxzIGZvciBhY2N1bXVsYXRlZCBlcnJvci5cclxuXHJcblx0XHRyZXR1cm4gcG9pbnQueCA+IGFyZWEubGVmdCAtIGVwc2lsb24gJiYgcG9pbnQueCA8IGFyZWEucmlnaHQgKyBlcHNpbG9uICYmXHJcblx0XHRcdHBvaW50LnkgPiBhcmVhLnRvcCAtIGVwc2lsb24gJiYgcG9pbnQueSA8IGFyZWEuYm90dG9tICsgZXBzaWxvbjtcclxuXHR9LFxyXG5cclxuXHRjbGlwQXJlYTogZnVuY3Rpb24oY3R4LCBhcmVhKSB7XHJcblx0XHRjdHguc2F2ZSgpO1xyXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0Y3R4LnJlY3QoYXJlYS5sZWZ0LCBhcmVhLnRvcCwgYXJlYS5yaWdodCAtIGFyZWEubGVmdCwgYXJlYS5ib3R0b20gLSBhcmVhLnRvcCk7XHJcblx0XHRjdHguY2xpcCgpO1xyXG5cdH0sXHJcblxyXG5cdHVuY2xpcEFyZWE6IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHR9LFxyXG5cclxuXHRsaW5lVG86IGZ1bmN0aW9uKGN0eCwgcHJldmlvdXMsIHRhcmdldCwgZmxpcCkge1xyXG5cdFx0dmFyIHN0ZXBwZWQgPSB0YXJnZXQuc3RlcHBlZExpbmU7XHJcblx0XHRpZiAoc3RlcHBlZCkge1xyXG5cdFx0XHRpZiAoc3RlcHBlZCA9PT0gJ21pZGRsZScpIHtcclxuXHRcdFx0XHR2YXIgbWlkcG9pbnQgPSAocHJldmlvdXMueCArIHRhcmdldC54KSAvIDIuMDtcclxuXHRcdFx0XHRjdHgubGluZVRvKG1pZHBvaW50LCBmbGlwID8gdGFyZ2V0LnkgOiBwcmV2aW91cy55KTtcclxuXHRcdFx0XHRjdHgubGluZVRvKG1pZHBvaW50LCBmbGlwID8gcHJldmlvdXMueSA6IHRhcmdldC55KTtcclxuXHRcdFx0fSBlbHNlIGlmICgoc3RlcHBlZCA9PT0gJ2FmdGVyJyAmJiAhZmxpcCkgfHwgKHN0ZXBwZWQgIT09ICdhZnRlcicgJiYgZmxpcCkpIHtcclxuXHRcdFx0XHRjdHgubGluZVRvKHByZXZpb3VzLngsIHRhcmdldC55KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjdHgubGluZVRvKHRhcmdldC54LCBwcmV2aW91cy55KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRhcmdldC50ZW5zaW9uKSB7XHJcblx0XHRcdGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGN0eC5iZXppZXJDdXJ2ZVRvKFxyXG5cdFx0XHRmbGlwID8gcHJldmlvdXMuY29udHJvbFBvaW50UHJldmlvdXNYIDogcHJldmlvdXMuY29udHJvbFBvaW50TmV4dFgsXHJcblx0XHRcdGZsaXAgPyBwcmV2aW91cy5jb250cm9sUG9pbnRQcmV2aW91c1kgOiBwcmV2aW91cy5jb250cm9sUG9pbnROZXh0WSxcclxuXHRcdFx0ZmxpcCA/IHRhcmdldC5jb250cm9sUG9pbnROZXh0WCA6IHRhcmdldC5jb250cm9sUG9pbnRQcmV2aW91c1gsXHJcblx0XHRcdGZsaXAgPyB0YXJnZXQuY29udHJvbFBvaW50TmV4dFkgOiB0YXJnZXQuY29udHJvbFBvaW50UHJldmlvdXNZLFxyXG5cdFx0XHR0YXJnZXQueCxcclxuXHRcdFx0dGFyZ2V0LnkpO1xyXG5cdH1cclxufTtcclxuXHJcbnZhciBoZWxwZXJzX2NhbnZhcyA9IGV4cG9ydHMkMTtcclxuXHJcbi8vIERFUFJFQ0FUSU9OU1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5jYW52YXMuY2xlYXIgaW5zdGVhZC5cclxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmNsZWFyXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuaGVscGVyc19jb3JlLmNsZWFyID0gZXhwb3J0cyQxLmNsZWFyO1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5jYW52YXMucm91bmRlZFJlY3QgaW5zdGVhZC5cclxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmRyYXdSb3VuZGVkUmVjdGFuZ2xlXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuaGVscGVyc19jb3JlLmRyYXdSb3VuZGVkUmVjdGFuZ2xlID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdGV4cG9ydHMkMS5yb3VuZGVkUmVjdC5hcHBseShleHBvcnRzJDEsIGFyZ3VtZW50cyk7XHJcbn07XG5cbnZhciBkZWZhdWx0cyA9IHtcclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9zZXQ6IGZ1bmN0aW9uKHNjb3BlLCB2YWx1ZXMpIHtcclxuXHRcdHJldHVybiBoZWxwZXJzX2NvcmUubWVyZ2UodGhpc1tzY29wZV0gfHwgKHRoaXNbc2NvcGVdID0ge30pLCB2YWx1ZXMpO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIFRPRE8odjMpOiByZW1vdmUgJ2dsb2JhbCcgZnJvbSBuYW1lc3BhY2UuICBhbGwgZGVmYXVsdCBhcmUgZ2xvYmFsIGFuZFxyXG4vLyB0aGVyZSdzIGluY29uc2lzdGVuY3kgYXJvdW5kIHdoaWNoIG9wdGlvbnMgYXJlIHVuZGVyICdnbG9iYWwnXHJcbmRlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcclxuXHRkZWZhdWx0Q29sb3I6ICdyZ2JhKDAsMCwwLDAuMSknLFxyXG5cdGRlZmF1bHRGb250Q29sb3I6ICcjNjY2JyxcclxuXHRkZWZhdWx0Rm9udEZhbWlseTogXCInSGVsdmV0aWNhIE5ldWUnLCAnSGVsdmV0aWNhJywgJ0FyaWFsJywgc2Fucy1zZXJpZlwiLFxyXG5cdGRlZmF1bHRGb250U2l6ZTogMTIsXHJcblx0ZGVmYXVsdEZvbnRTdHlsZTogJ25vcm1hbCcsXHJcblx0ZGVmYXVsdExpbmVIZWlnaHQ6IDEuMixcclxuXHRzaG93TGluZXM6IHRydWVcclxufSk7XHJcblxyXG52YXIgY29yZV9kZWZhdWx0cyA9IGRlZmF1bHRzO1xuXG52YXIgdmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzX2NvcmUudmFsdWVPckRlZmF1bHQ7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIGdpdmVuIGZvbnQgb2JqZWN0IGludG8gYSBDU1MgZm9udCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBmb250IC0gQSBmb250IG9iamVjdC5cclxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgQ1NTIGZvbnQgc3RyaW5nLiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZvbnRcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHRvRm9udFN0cmluZyhmb250KSB7XHJcblx0aWYgKCFmb250IHx8IGhlbHBlcnNfY29yZS5pc051bGxPclVuZGVmKGZvbnQuc2l6ZSkgfHwgaGVscGVyc19jb3JlLmlzTnVsbE9yVW5kZWYoZm9udC5mYW1pbHkpKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdHJldHVybiAoZm9udC5zdHlsZSA/IGZvbnQuc3R5bGUgKyAnICcgOiAnJylcclxuXHRcdCsgKGZvbnQud2VpZ2h0ID8gZm9udC53ZWlnaHQgKyAnICcgOiAnJylcclxuXHRcdCsgZm9udC5zaXplICsgJ3B4ICdcclxuXHRcdCsgZm9udC5mYW1pbHk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAYWxpYXMgQ2hhcnQuaGVscGVycy5vcHRpb25zXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbnZhciBoZWxwZXJzX29wdGlvbnMgPSB7XHJcblx0LyoqXHJcblx0ICogQ29udmVydHMgdGhlIGdpdmVuIGxpbmUgaGVpZ2h0IGB2YWx1ZWAgaW4gcGl4ZWxzIGZvciBhIHNwZWNpZmljIGZvbnQgYHNpemVgLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWUgLSBUaGUgbGluZUhlaWdodCB0byBwYXJzZSAoZWcuIDEuNiwgJzE0cHgnLCAnNzUlJywgJzEuNmVtJykuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSBUaGUgZm9udCBzaXplIChpbiBwaXhlbHMpIHVzZWQgdG8gcmVzb2x2ZSByZWxhdGl2ZSBgdmFsdWVgLlxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBlZmZlY3RpdmUgbGluZSBoZWlnaHQgaW4gcGl4ZWxzIChzaXplICogMS4yIGlmIHZhbHVlIGlzIGludmFsaWQpLlxyXG5cdCAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2xpbmUtaGVpZ2h0XHJcblx0ICogQHNpbmNlIDIuNy4wXHJcblx0ICovXHJcblx0dG9MaW5lSGVpZ2h0OiBmdW5jdGlvbih2YWx1ZSwgc2l6ZSkge1xyXG5cdFx0dmFyIG1hdGNoZXMgPSAoJycgKyB2YWx1ZSkubWF0Y2goL14obm9ybWFsfChcXGQrKD86XFwuXFxkKyk/KShweHxlbXwlKT8pJC8pO1xyXG5cdFx0aWYgKCFtYXRjaGVzIHx8IG1hdGNoZXNbMV0gPT09ICdub3JtYWwnKSB7XHJcblx0XHRcdHJldHVybiBzaXplICogMS4yO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhbHVlID0gK21hdGNoZXNbMl07XHJcblxyXG5cdFx0c3dpdGNoIChtYXRjaGVzWzNdKSB7XHJcblx0XHRjYXNlICdweCc6XHJcblx0XHRcdHJldHVybiB2YWx1ZTtcclxuXHRcdGNhc2UgJyUnOlxyXG5cdFx0XHR2YWx1ZSAvPSAxMDA7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzaXplICogdmFsdWU7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBwYWRkaW5nIG9iamVjdCB3aXRoIHByZS1jb21wdXRlZCB3aWR0aC9oZWlnaHQuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ8b2JqZWN0fSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvbXBvbmVudCxcclxuXHQgKiAgZWxzZSwgaWYgYW5kIG9iamVjdCwgdXNlIGRlZmluZWQgcHJvcGVydGllcyBhbmQgc2V0cyB1bmRlZmluZWQgb25lcyB0byAwLlxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBwYWRkaW5nIHZhbHVlcyAodG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0KVxyXG5cdCAqIEBzaW5jZSAyLjcuMFxyXG5cdCAqL1xyXG5cdHRvUGFkZGluZzogZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdHZhciB0LCByLCBiLCBsO1xyXG5cclxuXHRcdGlmIChoZWxwZXJzX2NvcmUuaXNPYmplY3QodmFsdWUpKSB7XHJcblx0XHRcdHQgPSArdmFsdWUudG9wIHx8IDA7XHJcblx0XHRcdHIgPSArdmFsdWUucmlnaHQgfHwgMDtcclxuXHRcdFx0YiA9ICt2YWx1ZS5ib3R0b20gfHwgMDtcclxuXHRcdFx0bCA9ICt2YWx1ZS5sZWZ0IHx8IDA7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0ID0gciA9IGIgPSBsID0gK3ZhbHVlIHx8IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dG9wOiB0LFxyXG5cdFx0XHRyaWdodDogcixcclxuXHRcdFx0Ym90dG9tOiBiLFxyXG5cdFx0XHRsZWZ0OiBsLFxyXG5cdFx0XHRoZWlnaHQ6IHQgKyBiLFxyXG5cdFx0XHR3aWR0aDogbCArIHJcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUGFyc2VzIGZvbnQgb3B0aW9ucyBhbmQgcmV0dXJucyB0aGUgZm9udCBvYmplY3QuXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBBIG9iamVjdCB0aGF0IGNvbnRhaW5zIGZvbnQgb3B0aW9ucyB0byBiZSBwYXJzZWQuXHJcblx0ICogQHJldHVybiB7b2JqZWN0fSBUaGUgZm9udCBvYmplY3QuXHJcblx0ICogQHRvZG8gU3VwcG9ydCBmb250Liogb3B0aW9ucyBhbmQgcmVuYW1lZCB0byB0b0ZvbnQoKS5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9wYXJzZUZvbnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRcdHZhciBnbG9iYWxEZWZhdWx0cyA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsO1xyXG5cdFx0dmFyIHNpemUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZvbnRTaXplLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFNpemUpO1xyXG5cdFx0dmFyIGZvbnQgPSB7XHJcblx0XHRcdGZhbWlseTogdmFsdWVPckRlZmF1bHQob3B0aW9ucy5mb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSksXHJcblx0XHRcdGxpbmVIZWlnaHQ6IGhlbHBlcnNfY29yZS5vcHRpb25zLnRvTGluZUhlaWdodCh2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmxpbmVIZWlnaHQsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRMaW5lSGVpZ2h0KSwgc2l6ZSksXHJcblx0XHRcdHNpemU6IHNpemUsXHJcblx0XHRcdHN0eWxlOiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZvbnRTdHlsZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTdHlsZSksXHJcblx0XHRcdHdlaWdodDogbnVsbCxcclxuXHRcdFx0c3RyaW5nOiAnJ1xyXG5cdFx0fTtcclxuXHJcblx0XHRmb250LnN0cmluZyA9IHRvRm9udFN0cmluZyhmb250KTtcclxuXHRcdHJldHVybiBmb250O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEV2YWx1YXRlcyB0aGUgZ2l2ZW4gYGlucHV0c2Agc2VxdWVudGlhbGx5IGFuZCByZXR1cm5zIHRoZSBmaXJzdCBkZWZpbmVkIHZhbHVlLlxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGlucHV0cyAtIEFuIGFycmF5IG9mIHZhbHVlcywgZmFsbGluZyBiYWNrIHRvIHRoZSBsYXN0IHZhbHVlLlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCB0aGUgdmFsdWVcclxuXHQgKiBpcyBjYWxsZWQgd2l0aCBgY29udGV4dGAgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHRoZSByZXN1bHQgYmVjb21lcyB0aGUgbmV3IGlucHV0LlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXhdIC0gSWYgZGVmaW5lZCBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgaXMgYW4gYXJyYXksIHRoZSB2YWx1ZVxyXG5cdCAqIGF0IGBpbmRleGAgYmVjb21lIHRoZSBuZXcgaW5wdXQuXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IFtpbmZvXSAtIG9iamVjdCB0byByZXR1cm4gaW5mb3JtYXRpb24gYWJvdXQgcmVzb2x1dGlvbiBpblxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luZm8uY2FjaGVhYmxlXSAtIFdpbGwgYmUgc2V0IHRvIGBmYWxzZWAgaWYgb3B0aW9uIGlzIG5vdCBjYWNoZWFibGUuXHJcblx0ICogQHNpbmNlIDIuNy4wXHJcblx0ICovXHJcblx0cmVzb2x2ZTogZnVuY3Rpb24oaW5wdXRzLCBjb250ZXh0LCBpbmRleCwgaW5mbykge1xyXG5cdFx0dmFyIGNhY2hlYWJsZSA9IHRydWU7XHJcblx0XHR2YXIgaSwgaWxlbiwgdmFsdWU7XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGlucHV0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0dmFsdWUgPSBpbnB1dHNbaV07XHJcblx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlKGNvbnRleHQpO1xyXG5cdFx0XHRcdGNhY2hlYWJsZSA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGhlbHBlcnNfY29yZS5pc0FycmF5KHZhbHVlKSkge1xyXG5cdFx0XHRcdHZhbHVlID0gdmFsdWVbaW5kZXhdO1xyXG5cdFx0XHRcdGNhY2hlYWJsZSA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0aWYgKGluZm8gJiYgIWNhY2hlYWJsZSkge1xyXG5cdFx0XHRcdFx0aW5mby5jYWNoZWFibGUgPSBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59O1xuXG4vKipcclxuICogQGFsaWFzIENoYXJ0LmhlbHBlcnMubWF0aFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG52YXIgZXhwb3J0cyQyID0ge1xyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2YgZmFjdG9ycyBzb3J0ZWQgZnJvbSAxIHRvIHNxcnQodmFsdWUpXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZmFjdG9yaXplOiBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdFx0dmFyIHNxcnQgPSBNYXRoLnNxcnQodmFsdWUpO1xyXG5cdFx0dmFyIGk7XHJcblxyXG5cdFx0Zm9yIChpID0gMTsgaSA8IHNxcnQ7IGkrKykge1xyXG5cdFx0XHRpZiAodmFsdWUgJSBpID09PSAwKSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goaSk7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2godmFsdWUgLyBpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHNxcnQgPT09IChzcXJ0IHwgMCkpIHsgLy8gaWYgdmFsdWUgaXMgYSBzcXVhcmUgbnVtYmVyXHJcblx0XHRcdHJlc3VsdC5wdXNoKHNxcnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJlc3VsdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdFx0cmV0dXJuIGEgLSBiO1xyXG5cdFx0fSkucG9wKCk7XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH0sXHJcblxyXG5cdGxvZzEwOiBNYXRoLmxvZzEwIHx8IGZ1bmN0aW9uKHgpIHtcclxuXHRcdHZhciBleHBvbmVudCA9IE1hdGgubG9nKHgpICogTWF0aC5MT0cxMEU7IC8vIE1hdGguTE9HMTBFID0gMSAvIE1hdGguTE4xMC5cclxuXHRcdC8vIENoZWNrIGZvciB3aG9sZSBwb3dlcnMgb2YgMTAsXHJcblx0XHQvLyB3aGljaCBkdWUgdG8gZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3Igc2hvdWxkIGJlIGNvcnJlY3RlZC5cclxuXHRcdHZhciBwb3dlck9mMTAgPSBNYXRoLnJvdW5kKGV4cG9uZW50KTtcclxuXHRcdHZhciBpc1Bvd2VyT2YxMCA9IHggPT09IE1hdGgucG93KDEwLCBwb3dlck9mMTApO1xyXG5cclxuXHRcdHJldHVybiBpc1Bvd2VyT2YxMCA/IHBvd2VyT2YxMCA6IGV4cG9uZW50O1xyXG5cdH1cclxufTtcclxuXHJcbnZhciBoZWxwZXJzX21hdGggPSBleHBvcnRzJDI7XHJcblxyXG4vLyBERVBSRUNBVElPTlNcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMubWF0aC5sb2cxMCBpbnN0ZWFkLlxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMubG9nMTBcclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjkuMFxyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5oZWxwZXJzX2NvcmUubG9nMTAgPSBleHBvcnRzJDIubG9nMTA7XG5cbnZhciBnZXRSdGxBZGFwdGVyID0gZnVuY3Rpb24ocmVjdFgsIHdpZHRoKSB7XHJcblx0cmV0dXJuIHtcclxuXHRcdHg6IGZ1bmN0aW9uKHgpIHtcclxuXHRcdFx0cmV0dXJuIHJlY3RYICsgcmVjdFggKyB3aWR0aCAtIHg7XHJcblx0XHR9LFxyXG5cdFx0c2V0V2lkdGg6IGZ1bmN0aW9uKHcpIHtcclxuXHRcdFx0d2lkdGggPSB3O1xyXG5cdFx0fSxcclxuXHRcdHRleHRBbGlnbjogZnVuY3Rpb24oYWxpZ24pIHtcclxuXHRcdFx0aWYgKGFsaWduID09PSAnY2VudGVyJykge1xyXG5cdFx0XHRcdHJldHVybiBhbGlnbjtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xyXG5cdFx0fSxcclxuXHRcdHhQbHVzOiBmdW5jdGlvbih4LCB2YWx1ZSkge1xyXG5cdFx0XHRyZXR1cm4geCAtIHZhbHVlO1xyXG5cdFx0fSxcclxuXHRcdGxlZnRGb3JMdHI6IGZ1bmN0aW9uKHgsIGl0ZW1XaWR0aCkge1xyXG5cdFx0XHRyZXR1cm4geCAtIGl0ZW1XaWR0aDtcclxuXHRcdH0sXHJcblx0fTtcclxufTtcclxuXHJcbnZhciBnZXRMdHJBZGFwdGVyID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHtcclxuXHRcdHg6IGZ1bmN0aW9uKHgpIHtcclxuXHRcdFx0cmV0dXJuIHg7XHJcblx0XHR9LFxyXG5cdFx0c2V0V2lkdGg6IGZ1bmN0aW9uKHcpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG5cdFx0fSxcclxuXHRcdHRleHRBbGlnbjogZnVuY3Rpb24oYWxpZ24pIHtcclxuXHRcdFx0cmV0dXJuIGFsaWduO1xyXG5cdFx0fSxcclxuXHRcdHhQbHVzOiBmdW5jdGlvbih4LCB2YWx1ZSkge1xyXG5cdFx0XHRyZXR1cm4geCArIHZhbHVlO1xyXG5cdFx0fSxcclxuXHRcdGxlZnRGb3JMdHI6IGZ1bmN0aW9uKHgsIF9pdGVtV2lkdGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG5cdFx0XHRyZXR1cm4geDtcclxuXHRcdH0sXHJcblx0fTtcclxufTtcclxuXHJcbnZhciBnZXRBZGFwdGVyID0gZnVuY3Rpb24ocnRsLCByZWN0WCwgd2lkdGgpIHtcclxuXHRyZXR1cm4gcnRsID8gZ2V0UnRsQWRhcHRlcihyZWN0WCwgd2lkdGgpIDogZ2V0THRyQWRhcHRlcigpO1xyXG59O1xyXG5cclxudmFyIG92ZXJyaWRlVGV4dERpcmVjdGlvbiA9IGZ1bmN0aW9uKGN0eCwgZGlyZWN0aW9uKSB7XHJcblx0dmFyIHN0eWxlLCBvcmlnaW5hbDtcclxuXHRpZiAoZGlyZWN0aW9uID09PSAnbHRyJyB8fCBkaXJlY3Rpb24gPT09ICdydGwnKSB7XHJcblx0XHRzdHlsZSA9IGN0eC5jYW52YXMuc3R5bGU7XHJcblx0XHRvcmlnaW5hbCA9IFtcclxuXHRcdFx0c3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJyksXHJcblx0XHRcdHN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkoJ2RpcmVjdGlvbicpLFxyXG5cdFx0XTtcclxuXHJcblx0XHRzdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgZGlyZWN0aW9uLCAnaW1wb3J0YW50Jyk7XHJcblx0XHRjdHgucHJldlRleHREaXJlY3Rpb24gPSBvcmlnaW5hbDtcclxuXHR9XHJcbn07XHJcblxyXG52YXIgcmVzdG9yZVRleHREaXJlY3Rpb24gPSBmdW5jdGlvbihjdHgpIHtcclxuXHR2YXIgb3JpZ2luYWwgPSBjdHgucHJldlRleHREaXJlY3Rpb247XHJcblx0aWYgKG9yaWdpbmFsICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdGRlbGV0ZSBjdHgucHJldlRleHREaXJlY3Rpb247XHJcblx0XHRjdHguY2FudmFzLnN0eWxlLnNldFByb3BlcnR5KCdkaXJlY3Rpb24nLCBvcmlnaW5hbFswXSwgb3JpZ2luYWxbMV0pO1xyXG5cdH1cclxufTtcclxuXHJcbnZhciBoZWxwZXJzX3J0bCA9IHtcclxuXHRnZXRSdGxBZGFwdGVyOiBnZXRBZGFwdGVyLFxyXG5cdG92ZXJyaWRlVGV4dERpcmVjdGlvbjogb3ZlcnJpZGVUZXh0RGlyZWN0aW9uLFxyXG5cdHJlc3RvcmVUZXh0RGlyZWN0aW9uOiByZXN0b3JlVGV4dERpcmVjdGlvbixcclxufTtcblxudmFyIGhlbHBlcnMkMSA9IGhlbHBlcnNfY29yZTtcclxudmFyIGVhc2luZyA9IGhlbHBlcnNfZWFzaW5nO1xyXG52YXIgY2FudmFzID0gaGVscGVyc19jYW52YXM7XHJcbnZhciBvcHRpb25zID0gaGVscGVyc19vcHRpb25zO1xyXG52YXIgbWF0aCA9IGhlbHBlcnNfbWF0aDtcclxudmFyIHJ0bCA9IGhlbHBlcnNfcnRsO1xuaGVscGVycyQxLmVhc2luZyA9IGVhc2luZztcbmhlbHBlcnMkMS5jYW52YXMgPSBjYW52YXM7XG5oZWxwZXJzJDEub3B0aW9ucyA9IG9wdGlvbnM7XG5oZWxwZXJzJDEubWF0aCA9IG1hdGg7XG5oZWxwZXJzJDEucnRsID0gcnRsO1xuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShzdGFydCwgdmlldywgbW9kZWwsIGVhc2UpIHtcclxuXHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG1vZGVsKTtcclxuXHR2YXIgaSwgaWxlbiwga2V5LCBhY3R1YWwsIG9yaWdpbiwgdGFyZ2V0LCB0eXBlLCBjMCwgYzE7XHJcblxyXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0a2V5ID0ga2V5c1tpXTtcclxuXHJcblx0XHR0YXJnZXQgPSBtb2RlbFtrZXldO1xyXG5cclxuXHRcdC8vIGlmIGEgdmFsdWUgaXMgYWRkZWQgdG8gdGhlIG1vZGVsIGFmdGVyIHBpdm90KCkgaGFzIGJlZW4gY2FsbGVkLCB0aGUgdmlld1xyXG5cdFx0Ly8gZG9lc24ndCBjb250YWluIGl0LCBzbyBsZXQncyBpbml0aWFsaXplIHRoZSB2aWV3IHRvIHRoZSB0YXJnZXQgdmFsdWUuXHJcblx0XHRpZiAoIXZpZXcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG5cdFx0XHR2aWV3W2tleV0gPSB0YXJnZXQ7XHJcblx0XHR9XHJcblxyXG5cdFx0YWN0dWFsID0gdmlld1trZXldO1xyXG5cclxuXHRcdGlmIChhY3R1YWwgPT09IHRhcmdldCB8fCBrZXlbMF0gPT09ICdfJykge1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXN0YXJ0Lmhhc093blByb3BlcnR5KGtleSkpIHtcclxuXHRcdFx0c3RhcnRba2V5XSA9IGFjdHVhbDtcclxuXHRcdH1cclxuXHJcblx0XHRvcmlnaW4gPSBzdGFydFtrZXldO1xyXG5cclxuXHRcdHR5cGUgPSB0eXBlb2YgdGFyZ2V0O1xyXG5cclxuXHRcdGlmICh0eXBlID09PSB0eXBlb2Ygb3JpZ2luKSB7XHJcblx0XHRcdGlmICh0eXBlID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRcdGMwID0gY2hhcnRqc0NvbG9yKG9yaWdpbik7XHJcblx0XHRcdFx0aWYgKGMwLnZhbGlkKSB7XHJcblx0XHRcdFx0XHRjMSA9IGNoYXJ0anNDb2xvcih0YXJnZXQpO1xyXG5cdFx0XHRcdFx0aWYgKGMxLnZhbGlkKSB7XHJcblx0XHRcdFx0XHRcdHZpZXdba2V5XSA9IGMxLm1peChjMCwgZWFzZSkucmdiU3RyaW5nKCk7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmIChoZWxwZXJzJDEuaXNGaW5pdGUob3JpZ2luKSAmJiBoZWxwZXJzJDEuaXNGaW5pdGUodGFyZ2V0KSkge1xyXG5cdFx0XHRcdHZpZXdba2V5XSA9IG9yaWdpbiArICh0YXJnZXQgLSBvcmlnaW4pICogZWFzZTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZpZXdba2V5XSA9IHRhcmdldDtcclxuXHR9XHJcbn1cclxuXHJcbnZhciBFbGVtZW50ID0gZnVuY3Rpb24oY29uZmlndXJhdGlvbikge1xyXG5cdGhlbHBlcnMkMS5leHRlbmQodGhpcywgY29uZmlndXJhdGlvbik7XHJcblx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5oZWxwZXJzJDEuZXh0ZW5kKEVsZW1lbnQucHJvdG90eXBlLCB7XHJcblx0X3R5cGU6IHVuZGVmaW5lZCxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLmhpZGRlbiA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdHBpdm90OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHRpZiAoIW1lLl92aWV3KSB7XHJcblx0XHRcdG1lLl92aWV3ID0gaGVscGVycyQxLmV4dGVuZCh7fSwgbWUuX21vZGVsKTtcclxuXHRcdH1cclxuXHRcdG1lLl9zdGFydCA9IHt9O1xyXG5cdFx0cmV0dXJuIG1lO1xyXG5cdH0sXHJcblxyXG5cdHRyYW5zaXRpb246IGZ1bmN0aW9uKGVhc2UpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbW9kZWwgPSBtZS5fbW9kZWw7XHJcblx0XHR2YXIgc3RhcnQgPSBtZS5fc3RhcnQ7XHJcblx0XHR2YXIgdmlldyA9IG1lLl92aWV3O1xyXG5cclxuXHRcdC8vIE5vIGFuaW1hdGlvbiAtPiBObyBUcmFuc2l0aW9uXHJcblx0XHRpZiAoIW1vZGVsIHx8IGVhc2UgPT09IDEpIHtcclxuXHRcdFx0bWUuX3ZpZXcgPSBoZWxwZXJzJDEuZXh0ZW5kKHt9LCBtb2RlbCk7XHJcblx0XHRcdG1lLl9zdGFydCA9IG51bGw7XHJcblx0XHRcdHJldHVybiBtZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXZpZXcpIHtcclxuXHRcdFx0dmlldyA9IG1lLl92aWV3ID0ge307XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFzdGFydCkge1xyXG5cdFx0XHRzdGFydCA9IG1lLl9zdGFydCA9IHt9O1xyXG5cdFx0fVxyXG5cclxuXHRcdGludGVycG9sYXRlKHN0YXJ0LCB2aWV3LCBtb2RlbCwgZWFzZSk7XHJcblxyXG5cdFx0cmV0dXJuIG1lO1xyXG5cdH0sXHJcblxyXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiB0aGlzLl9tb2RlbC54LFxyXG5cdFx0XHR5OiB0aGlzLl9tb2RlbC55XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGhhc1ZhbHVlOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBoZWxwZXJzJDEuaXNOdW1iZXIodGhpcy5fbW9kZWwueCkgJiYgaGVscGVycyQxLmlzTnVtYmVyKHRoaXMuX21vZGVsLnkpO1xyXG5cdH1cclxufSk7XHJcblxyXG5FbGVtZW50LmV4dGVuZCA9IGhlbHBlcnMkMS5pbmhlcml0cztcclxuXHJcbnZhciBjb3JlX2VsZW1lbnQgPSBFbGVtZW50O1xuXG52YXIgZXhwb3J0cyQzID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XHJcblx0Y2hhcnQ6IG51bGwsIC8vIHRoZSBhbmltYXRpb24gYXNzb2NpYXRlZCBjaGFydCBpbnN0YW5jZVxyXG5cdGN1cnJlbnRTdGVwOiAwLCAvLyB0aGUgY3VycmVudCBhbmltYXRpb24gc3RlcFxyXG5cdG51bVN0ZXBzOiA2MCwgLy8gZGVmYXVsdCBudW1iZXIgb2Ygc3RlcHNcclxuXHRlYXNpbmc6ICcnLCAvLyB0aGUgZWFzaW5nIHRvIHVzZSBmb3IgdGhpcyBhbmltYXRpb25cclxuXHRyZW5kZXI6IG51bGwsIC8vIHJlbmRlciBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBhbmltYXRpb24gc2VydmljZVxyXG5cclxuXHRvbkFuaW1hdGlvblByb2dyZXNzOiBudWxsLCAvLyB1c2VyIHNwZWNpZmllZCBjYWxsYmFjayB0byBmaXJlIG9uIGVhY2ggc3RlcCBvZiB0aGUgYW5pbWF0aW9uXHJcblx0b25BbmltYXRpb25Db21wbGV0ZTogbnVsbCwgLy8gdXNlciBzcGVjaWZpZWQgY2FsbGJhY2sgdG8gZmlyZSB3aGVuIHRoZSBhbmltYXRpb24gZmluaXNoZXNcclxufSk7XHJcblxyXG52YXIgY29yZV9hbmltYXRpb24gPSBleHBvcnRzJDM7XHJcblxyXG4vLyBERVBSRUNBVElPTlNcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LkFuaW1hdGlvbiBpbnN0ZWFkXHJcbiAqIEBwcm9wIENoYXJ0LkFuaW1hdGlvbiNhbmltYXRpb25PYmplY3RcclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyQzLnByb3RvdHlwZSwgJ2FuaW1hdGlvbk9iamVjdCcsIHtcclxuXHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LkFuaW1hdGlvbiNjaGFydCBpbnN0ZWFkXHJcbiAqIEBwcm9wIENoYXJ0LkFuaW1hdGlvbiNjaGFydEluc3RhbmNlXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMkMy5wcm90b3R5cGUsICdjaGFydEluc3RhbmNlJywge1xyXG5cdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jaGFydDtcclxuXHR9LFxyXG5cdHNldDogZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdHRoaXMuY2hhcnQgPSB2YWx1ZTtcclxuXHR9XHJcbn0pO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcclxuXHRhbmltYXRpb246IHtcclxuXHRcdGR1cmF0aW9uOiAxMDAwLFxyXG5cdFx0ZWFzaW5nOiAnZWFzZU91dFF1YXJ0JyxcclxuXHRcdG9uUHJvZ3Jlc3M6IGhlbHBlcnMkMS5ub29wLFxyXG5cdFx0b25Db21wbGV0ZTogaGVscGVycyQxLm5vb3BcclxuXHR9XHJcbn0pO1xyXG5cclxudmFyIGNvcmVfYW5pbWF0aW9ucyA9IHtcclxuXHRhbmltYXRpb25zOiBbXSxcclxuXHRyZXF1ZXN0OiBudWxsLFxyXG5cclxuXHQvKipcclxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCB0byBhbmltYXRlLlxyXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQW5pbWF0aW9ufSBhbmltYXRpb24gLSBUaGUgYW5pbWF0aW9uIHRoYXQgd2Ugd2lsbCBhbmltYXRlLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbmltYXRpb24gZHVyYXRpb24gaW4gbXMuXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBsYXp5IC0gaWYgdHJ1ZSwgdGhlIGNoYXJ0IGlzIG5vdCBtYXJrZWQgYXMgYW5pbWF0aW5nIHRvIGVuYWJsZSBtb3JlIHJlc3BvbnNpdmUgaW50ZXJhY3Rpb25zXHJcblx0ICovXHJcblx0YWRkQW5pbWF0aW9uOiBmdW5jdGlvbihjaGFydCwgYW5pbWF0aW9uLCBkdXJhdGlvbiwgbGF6eSkge1xyXG5cdFx0dmFyIGFuaW1hdGlvbnMgPSB0aGlzLmFuaW1hdGlvbnM7XHJcblx0XHR2YXIgaSwgaWxlbjtcclxuXHJcblx0XHRhbmltYXRpb24uY2hhcnQgPSBjaGFydDtcclxuXHRcdGFuaW1hdGlvbi5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG5cdFx0YW5pbWF0aW9uLmR1cmF0aW9uID0gZHVyYXRpb247XHJcblxyXG5cdFx0aWYgKCFsYXp5KSB7XHJcblx0XHRcdGNoYXJ0LmFuaW1hdGluZyA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGFuaW1hdGlvbnMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGlmIChhbmltYXRpb25zW2ldLmNoYXJ0ID09PSBjaGFydCkge1xyXG5cdFx0XHRcdGFuaW1hdGlvbnNbaV0gPSBhbmltYXRpb247XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0YW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XHJcblxyXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIG5vIGFuaW1hdGlvbnMgcXVldWVkLCBtYW51YWxseSBraWNrc3RhcnQgYSBkaWdlc3QsIGZvciBsYWNrIG9mIGEgYmV0dGVyIHdvcmRcclxuXHRcdGlmIChhbmltYXRpb25zLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0XHR0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGNhbmNlbEFuaW1hdGlvbjogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdHZhciBpbmRleCA9IGhlbHBlcnMkMS5maW5kSW5kZXgodGhpcy5hbmltYXRpb25zLCBmdW5jdGlvbihhbmltYXRpb24pIHtcclxuXHRcdFx0cmV0dXJuIGFuaW1hdGlvbi5jaGFydCA9PT0gY2hhcnQ7XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XHJcblx0XHRcdHRoaXMuYW5pbWF0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cdFx0XHRjaGFydC5hbmltYXRpbmcgPSBmYWxzZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdGlmIChtZS5yZXF1ZXN0ID09PSBudWxsKSB7XHJcblx0XHRcdC8vIFNraXAgYW5pbWF0aW9uIGZyYW1lIHJlcXVlc3RzIHVudGlsIHRoZSBhY3RpdmUgb25lIGlzIGV4ZWN1dGVkLlxyXG5cdFx0XHQvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiBwcm9jZXNzaW5nIG1vdXNlIGV2ZW50cywgZS5nLiAnbW91c2Vtb3ZlJ1xyXG5cdFx0XHQvLyBhbmQgJ21vdXNlb3V0JyBldmVudHMgd2lsbCB0cmlnZ2VyIG11bHRpcGxlIHJlbmRlcnMuXHJcblx0XHRcdG1lLnJlcXVlc3QgPSBoZWxwZXJzJDEucmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0bWUucmVxdWVzdCA9IG51bGw7XHJcblx0XHRcdFx0bWUuc3RhcnREaWdlc3QoKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzdGFydERpZ2VzdDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cclxuXHRcdG1lLmFkdmFuY2UoKTtcclxuXHJcblx0XHQvLyBEbyB3ZSBoYXZlIG1vcmUgc3R1ZmYgdG8gYW5pbWF0ZT9cclxuXHRcdGlmIChtZS5hbmltYXRpb25zLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0bWUucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRhZHZhbmNlOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBhbmltYXRpb25zID0gdGhpcy5hbmltYXRpb25zO1xyXG5cdFx0dmFyIGFuaW1hdGlvbiwgY2hhcnQsIG51bVN0ZXBzLCBuZXh0U3RlcDtcclxuXHRcdHZhciBpID0gMDtcclxuXHJcblx0XHQvLyAxIGFuaW1hdGlvbiBwZXIgY2hhcnQsIHNvIHdlIGFyZSBsb29waW5nIGNoYXJ0cyBoZXJlXHJcblx0XHR3aGlsZSAoaSA8IGFuaW1hdGlvbnMubGVuZ3RoKSB7XHJcblx0XHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbnNbaV07XHJcblx0XHRcdGNoYXJ0ID0gYW5pbWF0aW9uLmNoYXJ0O1xyXG5cdFx0XHRudW1TdGVwcyA9IGFuaW1hdGlvbi5udW1TdGVwcztcclxuXHJcblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IGN1cnJlbnRTdGVwIHN0YXJ0cyBhdCAxXHJcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy82MTA0XHJcblx0XHRcdG5leHRTdGVwID0gTWF0aC5mbG9vcigoRGF0ZS5ub3coKSAtIGFuaW1hdGlvbi5zdGFydFRpbWUpIC8gYW5pbWF0aW9uLmR1cmF0aW9uICogbnVtU3RlcHMpICsgMTtcclxuXHRcdFx0YW5pbWF0aW9uLmN1cnJlbnRTdGVwID0gTWF0aC5taW4obmV4dFN0ZXAsIG51bVN0ZXBzKTtcclxuXHJcblx0XHRcdGhlbHBlcnMkMS5jYWxsYmFjayhhbmltYXRpb24ucmVuZGVyLCBbY2hhcnQsIGFuaW1hdGlvbl0sIGNoYXJ0KTtcclxuXHRcdFx0aGVscGVycyQxLmNhbGxiYWNrKGFuaW1hdGlvbi5vbkFuaW1hdGlvblByb2dyZXNzLCBbYW5pbWF0aW9uXSwgY2hhcnQpO1xyXG5cclxuXHRcdFx0aWYgKGFuaW1hdGlvbi5jdXJyZW50U3RlcCA+PSBudW1TdGVwcykge1xyXG5cdFx0XHRcdGhlbHBlcnMkMS5jYWxsYmFjayhhbmltYXRpb24ub25BbmltYXRpb25Db21wbGV0ZSwgW2FuaW1hdGlvbl0sIGNoYXJ0KTtcclxuXHRcdFx0XHRjaGFydC5hbmltYXRpbmcgPSBmYWxzZTtcclxuXHRcdFx0XHRhbmltYXRpb25zLnNwbGljZShpLCAxKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQrK2k7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn07XG5cbnZhciByZXNvbHZlID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcclxuXHJcbnZhciBhcnJheUV2ZW50cyA9IFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXTtcclxuXHJcbi8qKlxyXG4gKiBIb29rcyB0aGUgYXJyYXkgbWV0aG9kcyB0aGF0IGFkZCBvciByZW1vdmUgdmFsdWVzICgncHVzaCcsIHBvcCcsICdzaGlmdCcsICdzcGxpY2UnLFxyXG4gKiAndW5zaGlmdCcpIGFuZCBub3RpZnkgdGhlIGxpc3RlbmVyIEFGVEVSIHRoZSBhcnJheSBoYXMgYmVlbiBhbHRlcmVkLiBMaXN0ZW5lcnMgYXJlXHJcbiAqIGNhbGxlZCBvbiB0aGUgJ29uRGF0YSonIGNhbGxiYWNrcyAoZS5nLiBvbkRhdGFQdXNoLCBldGMuKSB3aXRoIHNhbWUgYXJndW1lbnRzLlxyXG4gKi9cclxuZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XHJcblx0aWYgKGFycmF5Ll9jaGFydGpzKSB7XHJcblx0XHRhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksICdfY2hhcnRqcycsIHtcclxuXHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuXHRcdGVudW1lcmFibGU6IGZhbHNlLFxyXG5cdFx0dmFsdWU6IHtcclxuXHRcdFx0bGlzdGVuZXJzOiBbbGlzdGVuZXJdXHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdGFycmF5RXZlbnRzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcblx0XHR2YXIgbWV0aG9kID0gJ29uRGF0YScgKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSk7XHJcblx0XHR2YXIgYmFzZSA9IGFycmF5W2tleV07XHJcblxyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCBrZXksIHtcclxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcclxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuXHRcdFx0XHR2YXIgcmVzID0gYmFzZS5hcHBseSh0aGlzLCBhcmdzKTtcclxuXHJcblx0XHRcdFx0aGVscGVycyQxLmVhY2goYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLCBmdW5jdGlvbihvYmplY3QpIHtcclxuXHRcdFx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRcdFx0b2JqZWN0W21ldGhvZF0uYXBwbHkob2JqZWN0LCBhcmdzKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHJlcztcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIHRoZSBnaXZlbiBhcnJheSBldmVudCBsaXN0ZW5lciBhbmQgY2xlYW51cCBleHRyYSBhdHRhY2hlZCBwcm9wZXJ0aWVzIChzdWNoIGFzXHJcbiAqIHRoZSBfY2hhcnRqcyBzdHViIGFuZCBvdmVycmlkZGVuIG1ldGhvZHMpIGlmIGFycmF5IGRvZXNuJ3QgaGF2ZSBhbnkgbW9yZSBsaXN0ZW5lcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiB1bmxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xyXG5cdHZhciBzdHViID0gYXJyYXkuX2NoYXJ0anM7XHJcblx0aWYgKCFzdHViKSB7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHR2YXIgbGlzdGVuZXJzID0gc3R1Yi5saXN0ZW5lcnM7XHJcblx0dmFyIGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xyXG5cdGlmIChpbmRleCAhPT0gLTEpIHtcclxuXHRcdGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cdH1cclxuXHJcblx0aWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHRhcnJheUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG5cdFx0ZGVsZXRlIGFycmF5W2tleV07XHJcblx0fSk7XHJcblxyXG5cdGRlbGV0ZSBhcnJheS5fY2hhcnRqcztcclxufVxyXG5cclxuLy8gQmFzZSBjbGFzcyBmb3IgYWxsIGRhdGFzZXQgY29udHJvbGxlcnMgKGxpbmUsIGJhciwgZXRjKVxyXG52YXIgRGF0YXNldENvbnRyb2xsZXIgPSBmdW5jdGlvbihjaGFydCwgZGF0YXNldEluZGV4KSB7XHJcblx0dGhpcy5pbml0aWFsaXplKGNoYXJ0LCBkYXRhc2V0SW5kZXgpO1xyXG59O1xyXG5cclxuaGVscGVycyQxLmV4dGVuZChEYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcclxuXHJcblx0LyoqXHJcblx0ICogRWxlbWVudCB0eXBlIHVzZWQgdG8gZ2VuZXJhdGUgYSBtZXRhIGRhdGFzZXQgKGUuZy4gQ2hhcnQuZWxlbWVudC5MaW5lKS5cclxuXHQgKiBAdHlwZSB7Q2hhcnQuY29yZS5lbGVtZW50fVxyXG5cdCAqL1xyXG5cdGRhdGFzZXRFbGVtZW50VHlwZTogbnVsbCxcclxuXHJcblx0LyoqXHJcblx0ICogRWxlbWVudCB0eXBlIHVzZWQgdG8gZ2VuZXJhdGUgYSBtZXRhIGRhdGEgKGUuZy4gQ2hhcnQuZWxlbWVudC5Qb2ludCkuXHJcblx0ICogQHR5cGUge0NoYXJ0LmNvcmUuZWxlbWVudH1cclxuXHQgKi9cclxuXHRkYXRhRWxlbWVudFR5cGU6IG51bGwsXHJcblxyXG5cdC8qKlxyXG5cdCAqIERhdGFzZXQgZWxlbWVudCBvcHRpb24ga2V5cyB0byBiZSByZXNvbHZlZCBpbiBfcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucy5cclxuXHQgKiBBIGRlcml2ZWQgY29udHJvbGxlciBtYXkgb3ZlcnJpZGUgdGhpcyB0byByZXNvbHZlIGNvbnRyb2xsZXItc3BlY2lmaWMgb3B0aW9ucy5cclxuXHQgKiBUaGUga2V5cyBkZWZpbmVkIGhlcmUgYXJlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGZvciBsZWdlbmQgc3R5bGVzLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2RhdGFzZXRFbGVtZW50T3B0aW9uczogW1xyXG5cdFx0J2JhY2tncm91bmRDb2xvcicsXHJcblx0XHQnYm9yZGVyQ2FwU3R5bGUnLFxyXG5cdFx0J2JvcmRlckNvbG9yJyxcclxuXHRcdCdib3JkZXJEYXNoJyxcclxuXHRcdCdib3JkZXJEYXNoT2Zmc2V0JyxcclxuXHRcdCdib3JkZXJKb2luU3R5bGUnLFxyXG5cdFx0J2JvcmRlcldpZHRoJ1xyXG5cdF0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIERhdGEgZWxlbWVudCBvcHRpb24ga2V5cyB0byBiZSByZXNvbHZlZCBpbiBfcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucy5cclxuXHQgKiBBIGRlcml2ZWQgY29udHJvbGxlciBtYXkgb3ZlcnJpZGUgdGhpcyB0byByZXNvbHZlIGNvbnRyb2xsZXItc3BlY2lmaWMgb3B0aW9ucy5cclxuXHQgKiBUaGUga2V5cyBkZWZpbmVkIGhlcmUgYXJlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGZvciBsZWdlbmQgc3R5bGVzLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2RhdGFFbGVtZW50T3B0aW9uczogW1xyXG5cdFx0J2JhY2tncm91bmRDb2xvcicsXHJcblx0XHQnYm9yZGVyQ29sb3InLFxyXG5cdFx0J2JvcmRlcldpZHRoJyxcclxuXHRcdCdwb2ludFN0eWxlJ1xyXG5cdF0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHRtZS5jaGFydCA9IGNoYXJ0O1xyXG5cdFx0bWUuaW5kZXggPSBkYXRhc2V0SW5kZXg7XHJcblx0XHRtZS5saW5rU2NhbGVzKCk7XHJcblx0XHRtZS5hZGRFbGVtZW50cygpO1xyXG5cdFx0bWUuX3R5cGUgPSBtZS5nZXRNZXRhKCkudHlwZTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVJbmRleDogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XHJcblx0XHR0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xyXG5cdH0sXHJcblxyXG5cdGxpbmtTY2FsZXM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xyXG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XHJcblx0XHR2YXIgc2NhbGVzID0gY2hhcnQuc2NhbGVzO1xyXG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XHJcblx0XHR2YXIgc2NhbGVzT3B0cyA9IGNoYXJ0Lm9wdGlvbnMuc2NhbGVzO1xyXG5cclxuXHRcdGlmIChtZXRhLnhBeGlzSUQgPT09IG51bGwgfHwgIShtZXRhLnhBeGlzSUQgaW4gc2NhbGVzKSB8fCBkYXRhc2V0LnhBeGlzSUQpIHtcclxuXHRcdFx0bWV0YS54QXhpc0lEID0gZGF0YXNldC54QXhpc0lEIHx8IHNjYWxlc09wdHMueEF4ZXNbMF0uaWQ7XHJcblx0XHR9XHJcblx0XHRpZiAobWV0YS55QXhpc0lEID09PSBudWxsIHx8ICEobWV0YS55QXhpc0lEIGluIHNjYWxlcykgfHwgZGF0YXNldC55QXhpc0lEKSB7XHJcblx0XHRcdG1ldGEueUF4aXNJRCA9IGRhdGFzZXQueUF4aXNJRCB8fCBzY2FsZXNPcHRzLnlBeGVzWzBdLmlkO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldERhdGFzZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1t0aGlzLmluZGV4XTtcclxuXHR9LFxyXG5cclxuXHRnZXRNZXRhOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRoaXMuaW5kZXgpO1xyXG5cdH0sXHJcblxyXG5cdGdldFNjYWxlRm9ySWQ6IGZ1bmN0aW9uKHNjYWxlSUQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNoYXJ0LnNjYWxlc1tzY2FsZUlEXTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9nZXRWYWx1ZVNjYWxlSWQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWV0YSgpLnlBeGlzSUQ7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZ2V0SW5kZXhTY2FsZUlkOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldE1ldGEoKS54QXhpc0lEO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldFZhbHVlU2NhbGU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0U2NhbGVGb3JJZCh0aGlzLl9nZXRWYWx1ZVNjYWxlSWQoKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZ2V0SW5kZXhTY2FsZTogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRTY2FsZUZvcklkKHRoaXMuX2dldEluZGV4U2NhbGVJZCgpKTtcclxuXHR9LFxyXG5cclxuXHRyZXNldDogZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLl91cGRhdGUodHJ1ZSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuXHRcdGlmICh0aGlzLl9kYXRhKSB7XHJcblx0XHRcdHVubGlzdGVuQXJyYXlFdmVudHModGhpcy5fZGF0YSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Y3JlYXRlTWV0YURhdGFzZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciB0eXBlID0gbWUuZGF0YXNldEVsZW1lbnRUeXBlO1xyXG5cdFx0cmV0dXJuIHR5cGUgJiYgbmV3IHR5cGUoe1xyXG5cdFx0XHRfY2hhcnQ6IG1lLmNoYXJ0LFxyXG5cdFx0XHRfZGF0YXNldEluZGV4OiBtZS5pbmRleFxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Y3JlYXRlTWV0YURhdGE6IGZ1bmN0aW9uKGluZGV4KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHR5cGUgPSBtZS5kYXRhRWxlbWVudFR5cGU7XHJcblx0XHRyZXR1cm4gdHlwZSAmJiBuZXcgdHlwZSh7XHJcblx0XHRcdF9jaGFydDogbWUuY2hhcnQsXHJcblx0XHRcdF9kYXRhc2V0SW5kZXg6IG1lLmluZGV4LFxyXG5cdFx0XHRfaW5kZXg6IGluZGV4XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRhZGRFbGVtZW50czogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XHJcblx0XHR2YXIgZGF0YSA9IG1lLmdldERhdGFzZXQoKS5kYXRhIHx8IFtdO1xyXG5cdFx0dmFyIG1ldGFEYXRhID0gbWV0YS5kYXRhO1xyXG5cdFx0dmFyIGksIGlsZW47XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdG1ldGFEYXRhW2ldID0gbWV0YURhdGFbaV0gfHwgbWUuY3JlYXRlTWV0YURhdGEoaSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bWV0YS5kYXRhc2V0ID0gbWV0YS5kYXRhc2V0IHx8IG1lLmNyZWF0ZU1ldGFEYXRhc2V0KCk7XHJcblx0fSxcclxuXHJcblx0YWRkRWxlbWVudEFuZFJlc2V0OiBmdW5jdGlvbihpbmRleCkge1xyXG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmNyZWF0ZU1ldGFEYXRhKGluZGV4KTtcclxuXHRcdHRoaXMuZ2V0TWV0YSgpLmRhdGEuc3BsaWNlKGluZGV4LCAwLCBlbGVtZW50KTtcclxuXHRcdHRoaXMudXBkYXRlRWxlbWVudChlbGVtZW50LCBpbmRleCwgdHJ1ZSk7XHJcblx0fSxcclxuXHJcblx0YnVpbGRPclVwZGF0ZUVsZW1lbnRzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcclxuXHRcdHZhciBkYXRhID0gZGF0YXNldC5kYXRhIHx8IChkYXRhc2V0LmRhdGEgPSBbXSk7XHJcblxyXG5cdFx0Ly8gSW4gb3JkZXIgdG8gY29ycmVjdGx5IGhhbmRsZSBkYXRhIGFkZGl0aW9uL2RlbGV0aW9uIGFuaW1hdGlvbiAoYW4gdGh1cyBzaW11bGF0ZVxyXG5cdFx0Ly8gcmVhbC10aW1lIGNoYXJ0cyksIHdlIG5lZWQgdG8gbW9uaXRvciB0aGVzZSBkYXRhIG1vZGlmaWNhdGlvbnMgYW5kIHN5bmNocm9uaXplXHJcblx0XHQvLyB0aGUgaW50ZXJuYWwgbWV0YSBkYXRhIGFjY29yZGluZ2x5LlxyXG5cdFx0aWYgKG1lLl9kYXRhICE9PSBkYXRhKSB7XHJcblx0XHRcdGlmIChtZS5fZGF0YSkge1xyXG5cdFx0XHRcdC8vIFRoaXMgY2FzZSBoYXBwZW5zIHdoZW4gdGhlIHVzZXIgcmVwbGFjZWQgdGhlIGRhdGEgYXJyYXkgaW5zdGFuY2UuXHJcblx0XHRcdFx0dW5saXN0ZW5BcnJheUV2ZW50cyhtZS5fZGF0YSwgbWUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoZGF0YSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGRhdGEpKSB7XHJcblx0XHRcdFx0bGlzdGVuQXJyYXlFdmVudHMoZGF0YSwgbWUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG1lLl9kYXRhID0gZGF0YTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBSZS1zeW5jIG1ldGEgZGF0YSBpbiBjYXNlIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IG9yIGlmIHdlIG1pc3NlZFxyXG5cdFx0Ly8gYW55IHVwZGF0ZXMgYW5kIHNvIG1ha2Ugc3VyZSB0aGF0IHdlIGhhbmRsZSBudW1iZXIgb2YgZGF0YXBvaW50cyBjaGFuZ2luZy5cclxuXHRcdG1lLnJlc3luY0VsZW1lbnRzKCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgbWVyZ2VkIHVzZXItc3VwcGxpZWQgYW5kIGRlZmF1bHQgZGF0YXNldC1sZXZlbCBvcHRpb25zXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfY29uZmlndXJlOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHRtZS5fY29uZmlnID0gaGVscGVycyQxLm1lcmdlKE9iamVjdC5jcmVhdGUobnVsbCksIFtcclxuXHRcdFx0bWUuY2hhcnQub3B0aW9ucy5kYXRhc2V0c1ttZS5fdHlwZV0sXHJcblx0XHRcdG1lLmdldERhdGFzZXQoKSxcclxuXHRcdF0sIHtcclxuXHRcdFx0bWVyZ2VyOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlKSB7XHJcblx0XHRcdFx0aWYgKGtleSAhPT0gJ19tZXRhJyAmJiBrZXkgIT09ICdkYXRhJykge1xyXG5cdFx0XHRcdFx0aGVscGVycyQxLl9tZXJnZXIoa2V5LCB0YXJnZXQsIHNvdXJjZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdG1lLl9jb25maWd1cmUoKTtcclxuXHRcdG1lLl9jYWNoZWREYXRhT3B0cyA9IG51bGw7XHJcblx0XHRtZS51cGRhdGUocmVzZXQpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogaGVscGVycyQxLm5vb3AsXHJcblxyXG5cdHRyYW5zaXRpb246IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XHJcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xyXG5cdFx0dmFyIGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xyXG5cdFx0dmFyIGlsZW4gPSBlbGVtZW50cy5sZW5ndGg7XHJcblx0XHR2YXIgaSA9IDA7XHJcblxyXG5cdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0ZWxlbWVudHNbaV0udHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1ldGEuZGF0YXNldCkge1xyXG5cdFx0XHRtZXRhLmRhdGFzZXQudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0ZHJhdzogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xyXG5cdFx0dmFyIGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xyXG5cdFx0dmFyIGlsZW4gPSBlbGVtZW50cy5sZW5ndGg7XHJcblx0XHR2YXIgaSA9IDA7XHJcblxyXG5cdFx0aWYgKG1ldGEuZGF0YXNldCkge1xyXG5cdFx0XHRtZXRhLmRhdGFzZXQuZHJhdygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGVsZW1lbnRzW2ldLmRyYXcoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgc2V0IG9mIHByZWRlZmluZWQgc3R5bGUgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUgZGF0YXNldFxyXG5cdCAqIG9yIHRoZSBkYXRhIGlmIHRoZSBpbmRleCBpcyBzcGVjaWZpZWRcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBkYXRhIGluZGV4XHJcblx0ICogQHJldHVybiB7SVN0eWxlSW50ZXJmYWNlfSBzdHlsZSBvYmplY3RcclxuXHQgKi9cclxuXHRnZXRTdHlsZTogZnVuY3Rpb24oaW5kZXgpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcclxuXHRcdHZhciBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xyXG5cdFx0dmFyIHN0eWxlO1xyXG5cclxuXHRcdG1lLl9jb25maWd1cmUoKTtcclxuXHRcdGlmIChkYXRhc2V0ICYmIGluZGV4ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0c3R5bGUgPSBtZS5fcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhkYXRhc2V0IHx8IHt9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGluZGV4ID0gaW5kZXggfHwgMDtcclxuXHRcdFx0c3R5bGUgPSBtZS5fcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhtZXRhLmRhdGFbaW5kZXhdIHx8IHt9LCBpbmRleCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHN0eWxlLmZpbGwgPT09IGZhbHNlIHx8IHN0eWxlLmZpbGwgPT09IG51bGwpIHtcclxuXHRcdFx0c3R5bGUuYmFja2dyb3VuZENvbG9yID0gc3R5bGUuYm9yZGVyQ29sb3I7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHN0eWxlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3Jlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnM6IGZ1bmN0aW9uKGVsZW1lbnQsIGhvdmVyKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XHJcblx0XHR2YXIgZGF0YXNldE9wdHMgPSBtZS5fY29uZmlnO1xyXG5cdFx0dmFyIGN1c3RvbSA9IGVsZW1lbnQuY3VzdG9tIHx8IHt9O1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzW21lLmRhdGFzZXRFbGVtZW50VHlwZS5wcm90b3R5cGUuX3R5cGVdIHx8IHt9O1xyXG5cdFx0dmFyIGVsZW1lbnRPcHRpb25zID0gbWUuX2RhdGFzZXRFbGVtZW50T3B0aW9ucztcclxuXHRcdHZhciB2YWx1ZXMgPSB7fTtcclxuXHRcdHZhciBpLCBpbGVuLCBrZXksIHJlYWRLZXk7XHJcblxyXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXHJcblx0XHR2YXIgY29udGV4dCA9IHtcclxuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxyXG5cdFx0XHRkYXRhc2V0OiBtZS5nZXREYXRhc2V0KCksXHJcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXgsXHJcblx0XHRcdGhvdmVyOiBob3ZlclxyXG5cdFx0fTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZWxlbWVudE9wdGlvbnMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGtleSA9IGVsZW1lbnRPcHRpb25zW2ldO1xyXG5cdFx0XHRyZWFkS2V5ID0gaG92ZXIgPyAnaG92ZXInICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnNsaWNlKDEpIDoga2V5O1xyXG5cdFx0XHR2YWx1ZXNba2V5XSA9IHJlc29sdmUoW1xyXG5cdFx0XHRcdGN1c3RvbVtyZWFkS2V5XSxcclxuXHRcdFx0XHRkYXRhc2V0T3B0c1tyZWFkS2V5XSxcclxuXHRcdFx0XHRvcHRpb25zW3JlYWRLZXldXHJcblx0XHRcdF0sIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB2YWx1ZXM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9uczogZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY3VzdG9tID0gZWxlbWVudCAmJiBlbGVtZW50LmN1c3RvbTtcclxuXHRcdHZhciBjYWNoZWQgPSBtZS5fY2FjaGVkRGF0YU9wdHM7XHJcblx0XHRpZiAoY2FjaGVkICYmICFjdXN0b20pIHtcclxuXHRcdFx0cmV0dXJuIGNhY2hlZDtcclxuXHRcdH1cclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIGRhdGFzZXRPcHRzID0gbWUuX2NvbmZpZztcclxuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5lbGVtZW50c1ttZS5kYXRhRWxlbWVudFR5cGUucHJvdG90eXBlLl90eXBlXSB8fCB7fTtcclxuXHRcdHZhciBlbGVtZW50T3B0aW9ucyA9IG1lLl9kYXRhRWxlbWVudE9wdGlvbnM7XHJcblx0XHR2YXIgdmFsdWVzID0ge307XHJcblxyXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXHJcblx0XHR2YXIgY29udGV4dCA9IHtcclxuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxyXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxyXG5cdFx0XHRkYXRhc2V0OiBtZS5nZXREYXRhc2V0KCksXHJcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXhcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gYHJlc29sdmVgIHNldHMgY2FjaGVhYmxlIHRvIGBmYWxzZWAgaWYgYW55IG9wdGlvbiBpcyBpbmRleGVkIG9yIHNjcmlwdGVkXHJcblx0XHR2YXIgaW5mbyA9IHtjYWNoZWFibGU6ICFjdXN0b219O1xyXG5cclxuXHRcdHZhciBrZXlzLCBpLCBpbGVuLCBrZXk7XHJcblxyXG5cdFx0Y3VzdG9tID0gY3VzdG9tIHx8IHt9O1xyXG5cclxuXHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheShlbGVtZW50T3B0aW9ucykpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IGVsZW1lbnRPcHRpb25zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRcdGtleSA9IGVsZW1lbnRPcHRpb25zW2ldO1xyXG5cdFx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZShbXHJcblx0XHRcdFx0XHRjdXN0b21ba2V5XSxcclxuXHRcdFx0XHRcdGRhdGFzZXRPcHRzW2tleV0sXHJcblx0XHRcdFx0XHRvcHRpb25zW2tleV1cclxuXHRcdFx0XHRdLCBjb250ZXh0LCBpbmRleCwgaW5mbyk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGtleXMgPSBPYmplY3Qua2V5cyhlbGVtZW50T3B0aW9ucyk7XHJcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRcdGtleSA9IGtleXNbaV07XHJcblx0XHRcdFx0dmFsdWVzW2tleV0gPSByZXNvbHZlKFtcclxuXHRcdFx0XHRcdGN1c3RvbVtrZXldLFxyXG5cdFx0XHRcdFx0ZGF0YXNldE9wdHNbZWxlbWVudE9wdGlvbnNba2V5XV0sXHJcblx0XHRcdFx0XHRkYXRhc2V0T3B0c1trZXldLFxyXG5cdFx0XHRcdFx0b3B0aW9uc1trZXldXHJcblx0XHRcdFx0XSwgY29udGV4dCwgaW5kZXgsIGluZm8pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGluZm8uY2FjaGVhYmxlKSB7XHJcblx0XHRcdG1lLl9jYWNoZWREYXRhT3B0cyA9IE9iamVjdC5mcmVlemUodmFsdWVzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWVzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUhvdmVyU3R5bGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuXHRcdGhlbHBlcnMkMS5tZXJnZShlbGVtZW50Ll9tb2RlbCwgZWxlbWVudC4kcHJldmlvdXNTdHlsZSB8fCB7fSk7XHJcblx0XHRkZWxldGUgZWxlbWVudC4kcHJldmlvdXNTdHlsZTtcclxuXHR9LFxyXG5cclxuXHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihlbGVtZW50KSB7XHJcblx0XHR2YXIgZGF0YXNldCA9IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tlbGVtZW50Ll9kYXRhc2V0SW5kZXhdO1xyXG5cdFx0dmFyIGluZGV4ID0gZWxlbWVudC5faW5kZXg7XHJcblx0XHR2YXIgY3VzdG9tID0gZWxlbWVudC5jdXN0b20gfHwge307XHJcblx0XHR2YXIgbW9kZWwgPSBlbGVtZW50Ll9tb2RlbDtcclxuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XHJcblxyXG5cdFx0ZWxlbWVudC4kcHJldmlvdXNTdHlsZSA9IHtcclxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXHJcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcclxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoXHJcblx0XHR9O1xyXG5cclxuXHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IHJlc29sdmUoW2N1c3RvbS5ob3ZlckJhY2tncm91bmRDb2xvciwgZGF0YXNldC5ob3ZlckJhY2tncm91bmRDb2xvciwgZ2V0SG92ZXJDb2xvcihtb2RlbC5iYWNrZ3JvdW5kQ29sb3IpXSwgdW5kZWZpbmVkLCBpbmRleCk7XHJcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHJlc29sdmUoW2N1c3RvbS5ob3ZlckJvcmRlckNvbG9yLCBkYXRhc2V0LmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3IobW9kZWwuYm9yZGVyQ29sb3IpXSwgdW5kZWZpbmVkLCBpbmRleCk7XHJcblx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IHJlc29sdmUoW2N1c3RvbS5ob3ZlckJvcmRlcldpZHRoLCBkYXRhc2V0LmhvdmVyQm9yZGVyV2lkdGgsIG1vZGVsLmJvcmRlcldpZHRoXSwgdW5kZWZpbmVkLCBpbmRleCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmdldE1ldGEoKS5kYXRhc2V0O1xyXG5cclxuXHRcdGlmIChlbGVtZW50KSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlSG92ZXJTdHlsZShlbGVtZW50KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9zZXREYXRhc2V0SG92ZXJTdHlsZTogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZ2V0TWV0YSgpLmRhdGFzZXQ7XHJcblx0XHR2YXIgcHJldiA9IHt9O1xyXG5cdFx0dmFyIGksIGlsZW4sIGtleSwga2V5cywgaG92ZXJPcHRpb25zLCBtb2RlbDtcclxuXHJcblx0XHRpZiAoIWVsZW1lbnQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1vZGVsID0gZWxlbWVudC5fbW9kZWw7XHJcblx0XHRob3Zlck9wdGlvbnMgPSB0aGlzLl9yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKGVsZW1lbnQsIHRydWUpO1xyXG5cclxuXHRcdGtleXMgPSBPYmplY3Qua2V5cyhob3Zlck9wdGlvbnMpO1xyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGtleSA9IGtleXNbaV07XHJcblx0XHRcdHByZXZba2V5XSA9IG1vZGVsW2tleV07XHJcblx0XHRcdG1vZGVsW2tleV0gPSBob3Zlck9wdGlvbnNba2V5XTtcclxuXHRcdH1cclxuXHJcblx0XHRlbGVtZW50LiRwcmV2aW91c1N0eWxlID0gcHJldjtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHJlc3luY0VsZW1lbnRzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcclxuXHRcdHZhciBkYXRhID0gbWUuZ2V0RGF0YXNldCgpLmRhdGE7XHJcblx0XHR2YXIgbnVtTWV0YSA9IG1ldGEuZGF0YS5sZW5ndGg7XHJcblx0XHR2YXIgbnVtRGF0YSA9IGRhdGEubGVuZ3RoO1xyXG5cclxuXHRcdGlmIChudW1EYXRhIDwgbnVtTWV0YSkge1xyXG5cdFx0XHRtZXRhLmRhdGEuc3BsaWNlKG51bURhdGEsIG51bU1ldGEgLSBudW1EYXRhKTtcclxuXHRcdH0gZWxzZSBpZiAobnVtRGF0YSA+IG51bU1ldGEpIHtcclxuXHRcdFx0bWUuaW5zZXJ0RWxlbWVudHMobnVtTWV0YSwgbnVtRGF0YSAtIG51bU1ldGEpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aW5zZXJ0RWxlbWVudHM6IGZ1bmN0aW9uKHN0YXJ0LCBjb3VudCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XHJcblx0XHRcdHRoaXMuYWRkRWxlbWVudEFuZFJlc2V0KHN0YXJ0ICsgaSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRvbkRhdGFQdXNoOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcblx0XHR0aGlzLmluc2VydEVsZW1lbnRzKHRoaXMuZ2V0RGF0YXNldCgpLmRhdGEubGVuZ3RoIC0gY291bnQsIGNvdW50KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdG9uRGF0YVBvcDogZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLmdldE1ldGEoKS5kYXRhLnBvcCgpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0b25EYXRhU2hpZnQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5nZXRNZXRhKCkuZGF0YS5zaGlmdCgpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0b25EYXRhU3BsaWNlOiBmdW5jdGlvbihzdGFydCwgY291bnQpIHtcclxuXHRcdHRoaXMuZ2V0TWV0YSgpLmRhdGEuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XHJcblx0XHR0aGlzLmluc2VydEVsZW1lbnRzKHN0YXJ0LCBhcmd1bWVudHMubGVuZ3RoIC0gMik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRvbkRhdGFVbnNoaWZ0OiBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMuaW5zZXJ0RWxlbWVudHMoMCwgYXJndW1lbnRzLmxlbmd0aCk7XHJcblx0fVxyXG59KTtcclxuXHJcbkRhdGFzZXRDb250cm9sbGVyLmV4dGVuZCA9IGhlbHBlcnMkMS5pbmhlcml0cztcclxuXHJcbnZhciBjb3JlX2RhdGFzZXRDb250cm9sbGVyID0gRGF0YXNldENvbnRyb2xsZXI7XG5cbnZhciBUQVUgPSBNYXRoLlBJICogMjtcclxuXHJcbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xyXG5cdGVsZW1lbnRzOiB7XHJcblx0XHRhcmM6IHtcclxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3IsXHJcblx0XHRcdGJvcmRlckNvbG9yOiAnI2ZmZicsXHJcblx0XHRcdGJvcmRlcldpZHRoOiAyLFxyXG5cdFx0XHRib3JkZXJBbGlnbjogJ2NlbnRlcidcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gY2xpcEFyYyhjdHgsIGFyYykge1xyXG5cdHZhciBzdGFydEFuZ2xlID0gYXJjLnN0YXJ0QW5nbGU7XHJcblx0dmFyIGVuZEFuZ2xlID0gYXJjLmVuZEFuZ2xlO1xyXG5cdHZhciBwaXhlbE1hcmdpbiA9IGFyYy5waXhlbE1hcmdpbjtcclxuXHR2YXIgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIGFyYy5vdXRlclJhZGl1cztcclxuXHR2YXIgeCA9IGFyYy54O1xyXG5cdHZhciB5ID0gYXJjLnk7XHJcblxyXG5cdC8vIERyYXcgYW4gaW5uZXIgYm9yZGVyIGJ5IGNsaXBpbmcgdGhlIGFyYyBhbmQgZHJhd2luZyBhIGRvdWJsZS13aWR0aCBib3JkZXJcclxuXHQvLyBFbmxhcmdlIHRoZSBjbGlwcGluZyBhcmMgYnkgMC4zMyBwaXhlbHMgdG8gZWxpbWluYXRlIGdsaXRjaGVzIGJldHdlZW4gYm9yZGVyc1xyXG5cdGN0eC5iZWdpblBhdGgoKTtcclxuXHRjdHguYXJjKHgsIHksIGFyYy5vdXRlclJhZGl1cywgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luKTtcclxuXHRpZiAoYXJjLmlubmVyUmFkaXVzID4gcGl4ZWxNYXJnaW4pIHtcclxuXHRcdGFuZ2xlTWFyZ2luID0gcGl4ZWxNYXJnaW4gLyBhcmMuaW5uZXJSYWRpdXM7XHJcblx0XHRjdHguYXJjKHgsIHksIGFyYy5pbm5lclJhZGl1cyAtIHBpeGVsTWFyZ2luLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luLCBzdGFydEFuZ2xlIC0gYW5nbGVNYXJnaW4sIHRydWUpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRjdHguYXJjKHgsIHksIHBpeGVsTWFyZ2luLCBlbmRBbmdsZSArIE1hdGguUEkgLyAyLCBzdGFydEFuZ2xlIC0gTWF0aC5QSSAvIDIpO1xyXG5cdH1cclxuXHRjdHguY2xvc2VQYXRoKCk7XHJcblx0Y3R4LmNsaXAoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZHJhd0Z1bGxDaXJjbGVCb3JkZXJzKGN0eCwgdm0sIGFyYywgaW5uZXIpIHtcclxuXHR2YXIgZW5kQW5nbGUgPSBhcmMuZW5kQW5nbGU7XHJcblx0dmFyIGk7XHJcblxyXG5cdGlmIChpbm5lcikge1xyXG5cdFx0YXJjLmVuZEFuZ2xlID0gYXJjLnN0YXJ0QW5nbGUgKyBUQVU7XHJcblx0XHRjbGlwQXJjKGN0eCwgYXJjKTtcclxuXHRcdGFyYy5lbmRBbmdsZSA9IGVuZEFuZ2xlO1xyXG5cdFx0aWYgKGFyYy5lbmRBbmdsZSA9PT0gYXJjLnN0YXJ0QW5nbGUgJiYgYXJjLmZ1bGxDaXJjbGVzKSB7XHJcblx0XHRcdGFyYy5lbmRBbmdsZSArPSBUQVU7XHJcblx0XHRcdGFyYy5mdWxsQ2lyY2xlcy0tO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdGN0eC5hcmMoYXJjLngsIGFyYy55LCBhcmMuaW5uZXJSYWRpdXMsIGFyYy5zdGFydEFuZ2xlICsgVEFVLCBhcmMuc3RhcnRBbmdsZSwgdHJ1ZSk7XHJcblx0Zm9yIChpID0gMDsgaSA8IGFyYy5mdWxsQ2lyY2xlczsgKytpKSB7XHJcblx0XHRjdHguc3Ryb2tlKCk7XHJcblx0fVxyXG5cclxuXHRjdHguYmVnaW5QYXRoKCk7XHJcblx0Y3R4LmFyYyhhcmMueCwgYXJjLnksIHZtLm91dGVyUmFkaXVzLCBhcmMuc3RhcnRBbmdsZSwgYXJjLnN0YXJ0QW5nbGUgKyBUQVUpO1xyXG5cdGZvciAoaSA9IDA7IGkgPCBhcmMuZnVsbENpcmNsZXM7ICsraSkge1xyXG5cdFx0Y3R4LnN0cm9rZSgpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gZHJhd0JvcmRlcihjdHgsIHZtLCBhcmMpIHtcclxuXHR2YXIgaW5uZXIgPSB2bS5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJztcclxuXHJcblx0aWYgKGlubmVyKSB7XHJcblx0XHRjdHgubGluZVdpZHRoID0gdm0uYm9yZGVyV2lkdGggKiAyO1xyXG5cdFx0Y3R4LmxpbmVKb2luID0gJ3JvdW5kJztcclxuXHR9IGVsc2Uge1xyXG5cdFx0Y3R4LmxpbmVXaWR0aCA9IHZtLmJvcmRlcldpZHRoO1xyXG5cdFx0Y3R4LmxpbmVKb2luID0gJ2JldmVsJztcclxuXHR9XHJcblxyXG5cdGlmIChhcmMuZnVsbENpcmNsZXMpIHtcclxuXHRcdGRyYXdGdWxsQ2lyY2xlQm9yZGVycyhjdHgsIHZtLCBhcmMsIGlubmVyKTtcclxuXHR9XHJcblxyXG5cdGlmIChpbm5lcikge1xyXG5cdFx0Y2xpcEFyYyhjdHgsIGFyYyk7XHJcblx0fVxyXG5cclxuXHRjdHguYmVnaW5QYXRoKCk7XHJcblx0Y3R4LmFyYyhhcmMueCwgYXJjLnksIHZtLm91dGVyUmFkaXVzLCBhcmMuc3RhcnRBbmdsZSwgYXJjLmVuZEFuZ2xlKTtcclxuXHRjdHguYXJjKGFyYy54LCBhcmMueSwgYXJjLmlubmVyUmFkaXVzLCBhcmMuZW5kQW5nbGUsIGFyYy5zdGFydEFuZ2xlLCB0cnVlKTtcclxuXHRjdHguY2xvc2VQYXRoKCk7XHJcblx0Y3R4LnN0cm9rZSgpO1xyXG59XHJcblxyXG52YXIgZWxlbWVudF9hcmMgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcclxuXHRfdHlwZTogJ2FyYycsXHJcblxyXG5cdGluTGFiZWxSYW5nZTogZnVuY3Rpb24obW91c2VYKSB7XHJcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cclxuXHRcdGlmICh2bSkge1xyXG5cdFx0XHRyZXR1cm4gKE1hdGgucG93KG1vdXNlWCAtIHZtLngsIDIpIDwgTWF0aC5wb3codm0ucmFkaXVzICsgdm0uaG92ZXJSYWRpdXMsIDIpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHRpblJhbmdlOiBmdW5jdGlvbihjaGFydFgsIGNoYXJ0WSkge1xyXG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHJcblx0XHRpZiAodm0pIHtcclxuXHRcdFx0dmFyIHBvaW50UmVsYXRpdmVQb3NpdGlvbiA9IGhlbHBlcnMkMS5nZXRBbmdsZUZyb21Qb2ludCh2bSwge3g6IGNoYXJ0WCwgeTogY2hhcnRZfSk7XHJcblx0XHRcdHZhciBhbmdsZSA9IHBvaW50UmVsYXRpdmVQb3NpdGlvbi5hbmdsZTtcclxuXHRcdFx0dmFyIGRpc3RhbmNlID0gcG9pbnRSZWxhdGl2ZVBvc2l0aW9uLmRpc3RhbmNlO1xyXG5cclxuXHRcdFx0Ly8gU2FuaXRpc2UgYW5nbGUgcmFuZ2VcclxuXHRcdFx0dmFyIHN0YXJ0QW5nbGUgPSB2bS5zdGFydEFuZ2xlO1xyXG5cdFx0XHR2YXIgZW5kQW5nbGUgPSB2bS5lbmRBbmdsZTtcclxuXHRcdFx0d2hpbGUgKGVuZEFuZ2xlIDwgc3RhcnRBbmdsZSkge1xyXG5cdFx0XHRcdGVuZEFuZ2xlICs9IFRBVTtcclxuXHRcdFx0fVxyXG5cdFx0XHR3aGlsZSAoYW5nbGUgPiBlbmRBbmdsZSkge1xyXG5cdFx0XHRcdGFuZ2xlIC09IFRBVTtcclxuXHRcdFx0fVxyXG5cdFx0XHR3aGlsZSAoYW5nbGUgPCBzdGFydEFuZ2xlKSB7XHJcblx0XHRcdFx0YW5nbGUgKz0gVEFVO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBDaGVjayBpZiB3aXRoaW4gdGhlIHJhbmdlIG9mIHRoZSBvcGVuL2Nsb3NlIGFuZ2xlXHJcblx0XHRcdHZhciBiZXR3ZWVuQW5nbGVzID0gKGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gZW5kQW5nbGUpO1xyXG5cdFx0XHR2YXIgd2l0aGluUmFkaXVzID0gKGRpc3RhbmNlID49IHZtLmlubmVyUmFkaXVzICYmIGRpc3RhbmNlIDw9IHZtLm91dGVyUmFkaXVzKTtcclxuXHJcblx0XHRcdHJldHVybiAoYmV0d2VlbkFuZ2xlcyAmJiB3aXRoaW5SYWRpdXMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdGdldENlbnRlclBvaW50OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XHJcblx0XHR2YXIgaGFsZkFuZ2xlID0gKHZtLnN0YXJ0QW5nbGUgKyB2bS5lbmRBbmdsZSkgLyAyO1xyXG5cdFx0dmFyIGhhbGZSYWRpdXMgPSAodm0uaW5uZXJSYWRpdXMgKyB2bS5vdXRlclJhZGl1cykgLyAyO1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0eDogdm0ueCArIE1hdGguY29zKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzLFxyXG5cdFx0XHR5OiB2bS55ICsgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXNcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cdFx0cmV0dXJuIE1hdGguUEkgKiAoKHZtLmVuZEFuZ2xlIC0gdm0uc3RhcnRBbmdsZSkgLyAoMiAqIE1hdGguUEkpKSAqIChNYXRoLnBvdyh2bS5vdXRlclJhZGl1cywgMikgLSBNYXRoLnBvdyh2bS5pbm5lclJhZGl1cywgMikpO1xyXG5cdH0sXHJcblxyXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cdFx0dmFyIGNlbnRyZUFuZ2xlID0gdm0uc3RhcnRBbmdsZSArICgodm0uZW5kQW5nbGUgLSB2bS5zdGFydEFuZ2xlKSAvIDIpO1xyXG5cdFx0dmFyIHJhbmdlRnJvbUNlbnRyZSA9ICh2bS5vdXRlclJhZGl1cyAtIHZtLmlubmVyUmFkaXVzKSAvIDIgKyB2bS5pbm5lclJhZGl1cztcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiB2bS54ICsgKE1hdGguY29zKGNlbnRyZUFuZ2xlKSAqIHJhbmdlRnJvbUNlbnRyZSksXHJcblx0XHRcdHk6IHZtLnkgKyAoTWF0aC5zaW4oY2VudHJlQW5nbGUpICogcmFuZ2VGcm9tQ2VudHJlKVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRkcmF3OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHg7XHJcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cdFx0dmFyIHBpeGVsTWFyZ2luID0gKHZtLmJvcmRlckFsaWduID09PSAnaW5uZXInKSA/IDAuMzMgOiAwO1xyXG5cdFx0dmFyIGFyYyA9IHtcclxuXHRcdFx0eDogdm0ueCxcclxuXHRcdFx0eTogdm0ueSxcclxuXHRcdFx0aW5uZXJSYWRpdXM6IHZtLmlubmVyUmFkaXVzLFxyXG5cdFx0XHRvdXRlclJhZGl1czogTWF0aC5tYXgodm0ub3V0ZXJSYWRpdXMgLSBwaXhlbE1hcmdpbiwgMCksXHJcblx0XHRcdHBpeGVsTWFyZ2luOiBwaXhlbE1hcmdpbixcclxuXHRcdFx0c3RhcnRBbmdsZTogdm0uc3RhcnRBbmdsZSxcclxuXHRcdFx0ZW5kQW5nbGU6IHZtLmVuZEFuZ2xlLFxyXG5cdFx0XHRmdWxsQ2lyY2xlczogTWF0aC5mbG9vcih2bS5jaXJjdW1mZXJlbmNlIC8gVEFVKVxyXG5cdFx0fTtcclxuXHRcdHZhciBpO1xyXG5cclxuXHRcdGN0eC5zYXZlKCk7XHJcblxyXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmJhY2tncm91bmRDb2xvcjtcclxuXHRcdGN0eC5zdHJva2VTdHlsZSA9IHZtLmJvcmRlckNvbG9yO1xyXG5cclxuXHRcdGlmIChhcmMuZnVsbENpcmNsZXMpIHtcclxuXHRcdFx0YXJjLmVuZEFuZ2xlID0gYXJjLnN0YXJ0QW5nbGUgKyBUQVU7XHJcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcclxuXHRcdFx0Y3R4LmFyYyhhcmMueCwgYXJjLnksIGFyYy5vdXRlclJhZGl1cywgYXJjLnN0YXJ0QW5nbGUsIGFyYy5lbmRBbmdsZSk7XHJcblx0XHRcdGN0eC5hcmMoYXJjLngsIGFyYy55LCBhcmMuaW5uZXJSYWRpdXMsIGFyYy5lbmRBbmdsZSwgYXJjLnN0YXJ0QW5nbGUsIHRydWUpO1xyXG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XHJcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBhcmMuZnVsbENpcmNsZXM7ICsraSkge1xyXG5cdFx0XHRcdGN0eC5maWxsKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YXJjLmVuZEFuZ2xlID0gYXJjLnN0YXJ0QW5nbGUgKyB2bS5jaXJjdW1mZXJlbmNlICUgVEFVO1xyXG5cdFx0fVxyXG5cclxuXHRcdGN0eC5iZWdpblBhdGgoKTtcclxuXHRcdGN0eC5hcmMoYXJjLngsIGFyYy55LCBhcmMub3V0ZXJSYWRpdXMsIGFyYy5zdGFydEFuZ2xlLCBhcmMuZW5kQW5nbGUpO1xyXG5cdFx0Y3R4LmFyYyhhcmMueCwgYXJjLnksIGFyYy5pbm5lclJhZGl1cywgYXJjLmVuZEFuZ2xlLCBhcmMuc3RhcnRBbmdsZSwgdHJ1ZSk7XHJcblx0XHRjdHguY2xvc2VQYXRoKCk7XHJcblx0XHRjdHguZmlsbCgpO1xyXG5cclxuXHRcdGlmICh2bS5ib3JkZXJXaWR0aCkge1xyXG5cdFx0XHRkcmF3Qm9yZGVyKGN0eCwgdm0sIGFyYyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHR9XHJcbn0pO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkMSA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcclxuXHJcbnZhciBkZWZhdWx0Q29sb3IgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XHJcblxyXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcclxuXHRlbGVtZW50czoge1xyXG5cdFx0bGluZToge1xyXG5cdFx0XHR0ZW5zaW9uOiAwLjQsXHJcblx0XHRcdGJhY2tncm91bmRDb2xvcjogZGVmYXVsdENvbG9yLFxyXG5cdFx0XHRib3JkZXJXaWR0aDogMyxcclxuXHRcdFx0Ym9yZGVyQ29sb3I6IGRlZmF1bHRDb2xvcixcclxuXHRcdFx0Ym9yZGVyQ2FwU3R5bGU6ICdidXR0JyxcclxuXHRcdFx0Ym9yZGVyRGFzaDogW10sXHJcblx0XHRcdGJvcmRlckRhc2hPZmZzZXQ6IDAuMCxcclxuXHRcdFx0Ym9yZGVySm9pblN0eWxlOiAnbWl0ZXInLFxyXG5cdFx0XHRjYXBCZXppZXJQb2ludHM6IHRydWUsXHJcblx0XHRcdGZpbGw6IHRydWUsIC8vIGRvIHdlIGZpbGwgaW4gdGhlIGFyZWEgYmV0d2VlbiB0aGUgbGluZSBhbmQgaXRzIGJhc2UgYXhpc1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG52YXIgZWxlbWVudF9saW5lID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XHJcblx0X3R5cGU6ICdsaW5lJyxcclxuXHJcblx0ZHJhdzogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHZtID0gbWUuX3ZpZXc7XHJcblx0XHR2YXIgY3R4ID0gbWUuX2NoYXJ0LmN0eDtcclxuXHRcdHZhciBzcGFuR2FwcyA9IHZtLnNwYW5HYXBzO1xyXG5cdFx0dmFyIHBvaW50cyA9IG1lLl9jaGlsZHJlbi5zbGljZSgpOyAvLyBjbG9uZSBhcnJheVxyXG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XHJcblx0XHR2YXIgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzID0gZ2xvYmFsRGVmYXVsdHMuZWxlbWVudHMubGluZTtcclxuXHRcdHZhciBsYXN0RHJhd25JbmRleCA9IC0xO1xyXG5cdFx0dmFyIGNsb3NlUGF0aCA9IG1lLl9sb29wO1xyXG5cdFx0dmFyIGluZGV4LCBwcmV2aW91cywgY3VycmVudFZNO1xyXG5cclxuXHRcdGlmICghcG9pbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1lLl9sb29wKSB7XHJcblx0XHRcdGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHBvaW50cy5sZW5ndGg7ICsraW5kZXgpIHtcclxuXHRcdFx0XHRwcmV2aW91cyA9IGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0ocG9pbnRzLCBpbmRleCk7XHJcblx0XHRcdFx0Ly8gSWYgdGhlIGxpbmUgaGFzIGFuIG9wZW4gcGF0aCwgc2hpZnQgdGhlIHBvaW50IGFycmF5XHJcblx0XHRcdFx0aWYgKCFwb2ludHNbaW5kZXhdLl92aWV3LnNraXAgJiYgcHJldmlvdXMuX3ZpZXcuc2tpcCkge1xyXG5cdFx0XHRcdFx0cG9pbnRzID0gcG9pbnRzLnNsaWNlKGluZGV4KS5jb25jYXQocG9pbnRzLnNsaWNlKDAsIGluZGV4KSk7XHJcblx0XHRcdFx0XHRjbG9zZVBhdGggPSBzcGFuR2FwcztcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBJZiB0aGUgbGluZSBoYXMgYSBjbG9zZSBwYXRoLCBhZGQgdGhlIGZpcnN0IHBvaW50IGFnYWluXHJcblx0XHRcdGlmIChjbG9zZVBhdGgpIHtcclxuXHRcdFx0XHRwb2ludHMucHVzaChwb2ludHNbMF0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Y3R4LnNhdmUoKTtcclxuXHJcblx0XHQvLyBTdHJva2UgTGluZSBPcHRpb25zXHJcblx0XHRjdHgubGluZUNhcCA9IHZtLmJvcmRlckNhcFN0eWxlIHx8IGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cy5ib3JkZXJDYXBTdHlsZTtcclxuXHJcblx0XHQvLyBJRSA5IGFuZCAxMCBkbyBub3Qgc3VwcG9ydCBsaW5lIGRhc2hcclxuXHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcclxuXHRcdFx0Y3R4LnNldExpbmVEYXNoKHZtLmJvcmRlckRhc2ggfHwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckRhc2gpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0JDEodm0uYm9yZGVyRGFzaE9mZnNldCwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckRhc2hPZmZzZXQpO1xyXG5cdFx0Y3R4LmxpbmVKb2luID0gdm0uYm9yZGVySm9pblN0eWxlIHx8IGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cy5ib3JkZXJKb2luU3R5bGU7XHJcblx0XHRjdHgubGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQkMSh2bS5ib3JkZXJXaWR0aCwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlcldpZHRoKTtcclxuXHRcdGN0eC5zdHJva2VTdHlsZSA9IHZtLmJvcmRlckNvbG9yIHx8IGdsb2JhbERlZmF1bHRzLmRlZmF1bHRDb2xvcjtcclxuXHJcblx0XHQvLyBTdHJva2UgTGluZVxyXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cclxuXHRcdC8vIEZpcnN0IHBvaW50IG1vdmVzIHRvIGl0J3Mgc3RhcnRpbmcgcG9zaXRpb24gbm8gbWF0dGVyIHdoYXRcclxuXHRcdGN1cnJlbnRWTSA9IHBvaW50c1swXS5fdmlldztcclxuXHRcdGlmICghY3VycmVudFZNLnNraXApIHtcclxuXHRcdFx0Y3R4Lm1vdmVUbyhjdXJyZW50Vk0ueCwgY3VycmVudFZNLnkpO1xyXG5cdFx0XHRsYXN0RHJhd25JbmRleCA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpbmRleCA9IDE7IGluZGV4IDwgcG9pbnRzLmxlbmd0aDsgKytpbmRleCkge1xyXG5cdFx0XHRjdXJyZW50Vk0gPSBwb2ludHNbaW5kZXhdLl92aWV3O1xyXG5cdFx0XHRwcmV2aW91cyA9IGxhc3REcmF3bkluZGV4ID09PSAtMSA/IGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0ocG9pbnRzLCBpbmRleCkgOiBwb2ludHNbbGFzdERyYXduSW5kZXhdO1xyXG5cclxuXHRcdFx0aWYgKCFjdXJyZW50Vk0uc2tpcCkge1xyXG5cdFx0XHRcdGlmICgobGFzdERyYXduSW5kZXggIT09IChpbmRleCAtIDEpICYmICFzcGFuR2FwcykgfHwgbGFzdERyYXduSW5kZXggPT09IC0xKSB7XHJcblx0XHRcdFx0XHQvLyBUaGVyZSB3YXMgYSBnYXAgYW5kIHRoaXMgaXMgdGhlIGZpcnN0IHBvaW50IGFmdGVyIHRoZSBnYXBcclxuXHRcdFx0XHRcdGN0eC5tb3ZlVG8oY3VycmVudFZNLngsIGN1cnJlbnRWTS55KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly8gTGluZSB0byBuZXh0IHBvaW50XHJcblx0XHRcdFx0XHRoZWxwZXJzJDEuY2FudmFzLmxpbmVUbyhjdHgsIHByZXZpb3VzLl92aWV3LCBjdXJyZW50Vk0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsYXN0RHJhd25JbmRleCA9IGluZGV4O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNsb3NlUGF0aCkge1xyXG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3R4LnN0cm9rZSgpO1xyXG5cdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHR9XHJcbn0pO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkMiA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcclxuXHJcbnZhciBkZWZhdWx0Q29sb3IkMSA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcjtcclxuXHJcbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xyXG5cdGVsZW1lbnRzOiB7XHJcblx0XHRwb2ludDoge1xyXG5cdFx0XHRyYWRpdXM6IDMsXHJcblx0XHRcdHBvaW50U3R5bGU6ICdjaXJjbGUnLFxyXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGRlZmF1bHRDb2xvciQxLFxyXG5cdFx0XHRib3JkZXJDb2xvcjogZGVmYXVsdENvbG9yJDEsXHJcblx0XHRcdGJvcmRlcldpZHRoOiAxLFxyXG5cdFx0XHQvLyBIb3ZlclxyXG5cdFx0XHRoaXRSYWRpdXM6IDEsXHJcblx0XHRcdGhvdmVyUmFkaXVzOiA0LFxyXG5cdFx0XHRob3ZlckJvcmRlcldpZHRoOiAxXHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIHhSYW5nZShtb3VzZVgpIHtcclxuXHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cdHJldHVybiB2bSA/IChNYXRoLmFicyhtb3VzZVggLSB2bS54KSA8IHZtLnJhZGl1cyArIHZtLmhpdFJhZGl1cykgOiBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24geVJhbmdlKG1vdXNlWSkge1xyXG5cdHZhciB2bSA9IHRoaXMuX3ZpZXc7XHJcblx0cmV0dXJuIHZtID8gKE1hdGguYWJzKG1vdXNlWSAtIHZtLnkpIDwgdm0ucmFkaXVzICsgdm0uaGl0UmFkaXVzKSA6IGZhbHNlO1xyXG59XHJcblxyXG52YXIgZWxlbWVudF9wb2ludCA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xyXG5cdF90eXBlOiAncG9pbnQnLFxyXG5cclxuXHRpblJhbmdlOiBmdW5jdGlvbihtb3VzZVgsIG1vdXNlWSkge1xyXG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHRcdHJldHVybiB2bSA/ICgoTWF0aC5wb3cobW91c2VYIC0gdm0ueCwgMikgKyBNYXRoLnBvdyhtb3VzZVkgLSB2bS55LCAyKSkgPCBNYXRoLnBvdyh2bS5oaXRSYWRpdXMgKyB2bS5yYWRpdXMsIDIpKSA6IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdGluTGFiZWxSYW5nZTogeFJhbmdlLFxyXG5cdGluWFJhbmdlOiB4UmFuZ2UsXHJcblx0aW5ZUmFuZ2U6IHlSYW5nZSxcclxuXHJcblx0Z2V0Q2VudGVyUG9pbnQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHg6IHZtLngsXHJcblx0XHRcdHk6IHZtLnlcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5QSSAqIE1hdGgucG93KHRoaXMuX3ZpZXcucmFkaXVzLCAyKTtcclxuXHR9LFxyXG5cclxuXHR0b29sdGlwUG9zaXRpb246IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHg6IHZtLngsXHJcblx0XHRcdHk6IHZtLnksXHJcblx0XHRcdHBhZGRpbmc6IHZtLnJhZGl1cyArIHZtLmJvcmRlcldpZHRoXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGRyYXc6IGZ1bmN0aW9uKGNoYXJ0QXJlYSkge1xyXG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHg7XHJcblx0XHR2YXIgcG9pbnRTdHlsZSA9IHZtLnBvaW50U3R5bGU7XHJcblx0XHR2YXIgcm90YXRpb24gPSB2bS5yb3RhdGlvbjtcclxuXHRcdHZhciByYWRpdXMgPSB2bS5yYWRpdXM7XHJcblx0XHR2YXIgeCA9IHZtLng7XHJcblx0XHR2YXIgeSA9IHZtLnk7XHJcblx0XHR2YXIgZ2xvYmFsRGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbDtcclxuXHRcdHZhciBkZWZhdWx0Q29sb3IgPSBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Q29sb3I7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2hhZG93XHJcblxyXG5cdFx0aWYgKHZtLnNraXApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENsaXBwaW5nIGZvciBQb2ludHMuXHJcblx0XHRpZiAoY2hhcnRBcmVhID09PSB1bmRlZmluZWQgfHwgaGVscGVycyQxLmNhbnZhcy5faXNQb2ludEluQXJlYSh2bSwgY2hhcnRBcmVhKSkge1xyXG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSB2bS5ib3JkZXJDb2xvciB8fCBkZWZhdWx0Q29sb3I7XHJcblx0XHRcdGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQyKHZtLmJvcmRlcldpZHRoLCBnbG9iYWxEZWZhdWx0cy5lbGVtZW50cy5wb2ludC5ib3JkZXJXaWR0aCk7XHJcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB2bS5iYWNrZ3JvdW5kQ29sb3IgfHwgZGVmYXVsdENvbG9yO1xyXG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLmRyYXdQb2ludChjdHgsIHBvaW50U3R5bGUsIHJhZGl1cywgeCwgeSwgcm90YXRpb24pO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XG5cbnZhciBkZWZhdWx0Q29sb3IkMiA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcjtcclxuXHJcbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xyXG5cdGVsZW1lbnRzOiB7XHJcblx0XHRyZWN0YW5nbGU6IHtcclxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBkZWZhdWx0Q29sb3IkMixcclxuXHRcdFx0Ym9yZGVyQ29sb3I6IGRlZmF1bHRDb2xvciQyLFxyXG5cdFx0XHRib3JkZXJTa2lwcGVkOiAnYm90dG9tJyxcclxuXHRcdFx0Ym9yZGVyV2lkdGg6IDBcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gaXNWZXJ0aWNhbCh2bSkge1xyXG5cdHJldHVybiB2bSAmJiB2bS53aWR0aCAhPT0gdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgYm91bmRzIG9mIHRoZSBiYXIgcmVnYXJkbGVzcyBvZiB0aGUgb3JpZW50YXRpb25cclxuICogQHBhcmFtIGJhciB7Q2hhcnQuRWxlbWVudC5SZWN0YW5nbGV9IHRoZSBiYXJcclxuICogQHJldHVybiB7Qm91bmRzfSBib3VuZHMgb2YgdGhlIGJhclxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QmFyQm91bmRzKHZtKSB7XHJcblx0dmFyIHgxLCB4MiwgeTEsIHkyLCBoYWxmO1xyXG5cclxuXHRpZiAoaXNWZXJ0aWNhbCh2bSkpIHtcclxuXHRcdGhhbGYgPSB2bS53aWR0aCAvIDI7XHJcblx0XHR4MSA9IHZtLnggLSBoYWxmO1xyXG5cdFx0eDIgPSB2bS54ICsgaGFsZjtcclxuXHRcdHkxID0gTWF0aC5taW4odm0ueSwgdm0uYmFzZSk7XHJcblx0XHR5MiA9IE1hdGgubWF4KHZtLnksIHZtLmJhc2UpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRoYWxmID0gdm0uaGVpZ2h0IC8gMjtcclxuXHRcdHgxID0gTWF0aC5taW4odm0ueCwgdm0uYmFzZSk7XHJcblx0XHR4MiA9IE1hdGgubWF4KHZtLngsIHZtLmJhc2UpO1xyXG5cdFx0eTEgPSB2bS55IC0gaGFsZjtcclxuXHRcdHkyID0gdm0ueSArIGhhbGY7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0bGVmdDogeDEsXHJcblx0XHR0b3A6IHkxLFxyXG5cdFx0cmlnaHQ6IHgyLFxyXG5cdFx0Ym90dG9tOiB5MlxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN3YXAob3JpZywgdjEsIHYyKSB7XHJcblx0cmV0dXJuIG9yaWcgPT09IHYxID8gdjIgOiBvcmlnID09PSB2MiA/IHYxIDogb3JpZztcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VCb3JkZXJTa2lwcGVkKHZtKSB7XHJcblx0dmFyIGVkZ2UgPSB2bS5ib3JkZXJTa2lwcGVkO1xyXG5cdHZhciByZXMgPSB7fTtcclxuXHJcblx0aWYgKCFlZGdlKSB7XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxuXHJcblx0aWYgKHZtLmhvcml6b250YWwpIHtcclxuXHRcdGlmICh2bS5iYXNlID4gdm0ueCkge1xyXG5cdFx0XHRlZGdlID0gc3dhcChlZGdlLCAnbGVmdCcsICdyaWdodCcpO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZiAodm0uYmFzZSA8IHZtLnkpIHtcclxuXHRcdGVkZ2UgPSBzd2FwKGVkZ2UsICdib3R0b20nLCAndG9wJyk7XHJcblx0fVxyXG5cclxuXHRyZXNbZWRnZV0gPSB0cnVlO1xyXG5cdHJldHVybiByZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlQm9yZGVyV2lkdGgodm0sIG1heFcsIG1heEgpIHtcclxuXHR2YXIgdmFsdWUgPSB2bS5ib3JkZXJXaWR0aDtcclxuXHR2YXIgc2tpcCA9IHBhcnNlQm9yZGVyU2tpcHBlZCh2bSk7XHJcblx0dmFyIHQsIHIsIGIsIGw7XHJcblxyXG5cdGlmIChoZWxwZXJzJDEuaXNPYmplY3QodmFsdWUpKSB7XHJcblx0XHR0ID0gK3ZhbHVlLnRvcCB8fCAwO1xyXG5cdFx0ciA9ICt2YWx1ZS5yaWdodCB8fCAwO1xyXG5cdFx0YiA9ICt2YWx1ZS5ib3R0b20gfHwgMDtcclxuXHRcdGwgPSArdmFsdWUubGVmdCB8fCAwO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0ID0gciA9IGIgPSBsID0gK3ZhbHVlIHx8IDA7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0dDogc2tpcC50b3AgfHwgKHQgPCAwKSA/IDAgOiB0ID4gbWF4SCA/IG1heEggOiB0LFxyXG5cdFx0cjogc2tpcC5yaWdodCB8fCAociA8IDApID8gMCA6IHIgPiBtYXhXID8gbWF4VyA6IHIsXHJcblx0XHRiOiBza2lwLmJvdHRvbSB8fCAoYiA8IDApID8gMCA6IGIgPiBtYXhIID8gbWF4SCA6IGIsXHJcblx0XHRsOiBza2lwLmxlZnQgfHwgKGwgPCAwKSA/IDAgOiBsID4gbWF4VyA/IG1heFcgOiBsXHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gYm91bmRpbmdSZWN0cyh2bSkge1xyXG5cdHZhciBib3VuZHMgPSBnZXRCYXJCb3VuZHModm0pO1xyXG5cdHZhciB3aWR0aCA9IGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0O1xyXG5cdHZhciBoZWlnaHQgPSBib3VuZHMuYm90dG9tIC0gYm91bmRzLnRvcDtcclxuXHR2YXIgYm9yZGVyID0gcGFyc2VCb3JkZXJXaWR0aCh2bSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdG91dGVyOiB7XHJcblx0XHRcdHg6IGJvdW5kcy5sZWZ0LFxyXG5cdFx0XHR5OiBib3VuZHMudG9wLFxyXG5cdFx0XHR3OiB3aWR0aCxcclxuXHRcdFx0aDogaGVpZ2h0XHJcblx0XHR9LFxyXG5cdFx0aW5uZXI6IHtcclxuXHRcdFx0eDogYm91bmRzLmxlZnQgKyBib3JkZXIubCxcclxuXHRcdFx0eTogYm91bmRzLnRvcCArIGJvcmRlci50LFxyXG5cdFx0XHR3OiB3aWR0aCAtIGJvcmRlci5sIC0gYm9yZGVyLnIsXHJcblx0XHRcdGg6IGhlaWdodCAtIGJvcmRlci50IC0gYm9yZGVyLmJcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpblJhbmdlKHZtLCB4LCB5KSB7XHJcblx0dmFyIHNraXBYID0geCA9PT0gbnVsbDtcclxuXHR2YXIgc2tpcFkgPSB5ID09PSBudWxsO1xyXG5cdHZhciBib3VuZHMgPSAhdm0gfHwgKHNraXBYICYmIHNraXBZKSA/IGZhbHNlIDogZ2V0QmFyQm91bmRzKHZtKTtcclxuXHJcblx0cmV0dXJuIGJvdW5kc1xyXG5cdFx0JiYgKHNraXBYIHx8IHggPj0gYm91bmRzLmxlZnQgJiYgeCA8PSBib3VuZHMucmlnaHQpXHJcblx0XHQmJiAoc2tpcFkgfHwgeSA+PSBib3VuZHMudG9wICYmIHkgPD0gYm91bmRzLmJvdHRvbSk7XHJcbn1cclxuXHJcbnZhciBlbGVtZW50X3JlY3RhbmdsZSA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xyXG5cdF90eXBlOiAncmVjdGFuZ2xlJyxcclxuXHJcblx0ZHJhdzogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xyXG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHRcdHZhciByZWN0cyA9IGJvdW5kaW5nUmVjdHModm0pO1xyXG5cdFx0dmFyIG91dGVyID0gcmVjdHMub3V0ZXI7XHJcblx0XHR2YXIgaW5uZXIgPSByZWN0cy5pbm5lcjtcclxuXHJcblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYmFja2dyb3VuZENvbG9yO1xyXG5cdFx0Y3R4LmZpbGxSZWN0KG91dGVyLngsIG91dGVyLnksIG91dGVyLncsIG91dGVyLmgpO1xyXG5cclxuXHRcdGlmIChvdXRlci53ID09PSBpbm5lci53ICYmIG91dGVyLmggPT09IGlubmVyLmgpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGN0eC5zYXZlKCk7XHJcblx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRjdHgucmVjdChvdXRlci54LCBvdXRlci55LCBvdXRlci53LCBvdXRlci5oKTtcclxuXHRcdGN0eC5jbGlwKCk7XHJcblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYm9yZGVyQ29sb3I7XHJcblx0XHRjdHgucmVjdChpbm5lci54LCBpbm5lci55LCBpbm5lci53LCBpbm5lci5oKTtcclxuXHRcdGN0eC5maWxsKCdldmVub2RkJyk7XHJcblx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdH0sXHJcblxyXG5cdGhlaWdodDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cdFx0cmV0dXJuIHZtLmJhc2UgLSB2bS55O1xyXG5cdH0sXHJcblxyXG5cdGluUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWCwgbW91c2VZKSB7XHJcblx0XHRyZXR1cm4gaW5SYW5nZSh0aGlzLl92aWV3LCBtb3VzZVgsIG1vdXNlWSk7XHJcblx0fSxcclxuXHJcblx0aW5MYWJlbFJhbmdlOiBmdW5jdGlvbihtb3VzZVgsIG1vdXNlWSkge1xyXG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHRcdHJldHVybiBpc1ZlcnRpY2FsKHZtKVxyXG5cdFx0XHQ/IGluUmFuZ2Uodm0sIG1vdXNlWCwgbnVsbClcclxuXHRcdFx0OiBpblJhbmdlKHZtLCBudWxsLCBtb3VzZVkpO1xyXG5cdH0sXHJcblxyXG5cdGluWFJhbmdlOiBmdW5jdGlvbihtb3VzZVgpIHtcclxuXHRcdHJldHVybiBpblJhbmdlKHRoaXMuX3ZpZXcsIG1vdXNlWCwgbnVsbCk7XHJcblx0fSxcclxuXHJcblx0aW5ZUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWSkge1xyXG5cdFx0cmV0dXJuIGluUmFuZ2UodGhpcy5fdmlldywgbnVsbCwgbW91c2VZKTtcclxuXHR9LFxyXG5cclxuXHRnZXRDZW50ZXJQb2ludDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cdFx0dmFyIHgsIHk7XHJcblx0XHRpZiAoaXNWZXJ0aWNhbCh2bSkpIHtcclxuXHRcdFx0eCA9IHZtLng7XHJcblx0XHRcdHkgPSAodm0ueSArIHZtLmJhc2UpIC8gMjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHggPSAodm0ueCArIHZtLmJhc2UpIC8gMjtcclxuXHRcdFx0eSA9IHZtLnk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHt4OiB4LCB5OiB5fTtcclxuXHR9LFxyXG5cclxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XHJcblxyXG5cdFx0cmV0dXJuIGlzVmVydGljYWwodm0pXHJcblx0XHRcdD8gdm0ud2lkdGggKiBNYXRoLmFicyh2bS55IC0gdm0uYmFzZSlcclxuXHRcdFx0OiB2bS5oZWlnaHQgKiBNYXRoLmFicyh2bS54IC0gdm0uYmFzZSk7XHJcblx0fSxcclxuXHJcblx0dG9vbHRpcFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiB2bS54LFxyXG5cdFx0XHR5OiB2bS55XHJcblx0XHR9O1xyXG5cdH1cclxufSk7XG5cbnZhciBlbGVtZW50cyA9IHt9O1xyXG52YXIgQXJjID0gZWxlbWVudF9hcmM7XHJcbnZhciBMaW5lID0gZWxlbWVudF9saW5lO1xyXG52YXIgUG9pbnQgPSBlbGVtZW50X3BvaW50O1xyXG52YXIgUmVjdGFuZ2xlID0gZWxlbWVudF9yZWN0YW5nbGU7XG5lbGVtZW50cy5BcmMgPSBBcmM7XG5lbGVtZW50cy5MaW5lID0gTGluZTtcbmVsZW1lbnRzLlBvaW50ID0gUG9pbnQ7XG5lbGVtZW50cy5SZWN0YW5nbGUgPSBSZWN0YW5nbGU7XG5cbnZhciBkZXByZWNhdGVkID0gaGVscGVycyQxLl9kZXByZWNhdGVkO1xyXG52YXIgdmFsdWVPckRlZmF1bHQkMyA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcclxuXHJcbmNvcmVfZGVmYXVsdHMuX3NldCgnYmFyJywge1xyXG5cdGhvdmVyOiB7XHJcblx0XHRtb2RlOiAnbGFiZWwnXHJcblx0fSxcclxuXHJcblx0c2NhbGVzOiB7XHJcblx0XHR4QXhlczogW3tcclxuXHRcdFx0dHlwZTogJ2NhdGVnb3J5JyxcclxuXHRcdFx0b2Zmc2V0OiB0cnVlLFxyXG5cdFx0XHRncmlkTGluZXM6IHtcclxuXHRcdFx0XHRvZmZzZXRHcmlkTGluZXM6IHRydWVcclxuXHRcdFx0fVxyXG5cdFx0fV0sXHJcblxyXG5cdFx0eUF4ZXM6IFt7XHJcblx0XHRcdHR5cGU6ICdsaW5lYXInXHJcblx0XHR9XVxyXG5cdH1cclxufSk7XHJcblxyXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcclxuXHRkYXRhc2V0czoge1xyXG5cdFx0YmFyOiB7XHJcblx0XHRcdGNhdGVnb3J5UGVyY2VudGFnZTogMC44LFxyXG5cdFx0XHRiYXJQZXJjZW50YWdlOiAwLjlcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBcIm9wdGltYWxcIiBzYW1wbGUgc2l6ZSB0byBtYWludGFpbiBiYXJzIGVxdWFsbHkgc2l6ZWQgd2hpbGUgcHJldmVudGluZyBvdmVybGFwLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY29tcHV0ZU1pblNhbXBsZVNpemUoc2NhbGUsIHBpeGVscykge1xyXG5cdHZhciBtaW4gPSBzY2FsZS5fbGVuZ3RoO1xyXG5cdHZhciBwcmV2LCBjdXJyLCBpLCBpbGVuO1xyXG5cclxuXHRmb3IgKGkgPSAxLCBpbGVuID0gcGl4ZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0bWluID0gTWF0aC5taW4obWluLCBNYXRoLmFicyhwaXhlbHNbaV0gLSBwaXhlbHNbaSAtIDFdKSk7XHJcblx0fVxyXG5cclxuXHRmb3IgKGkgPSAwLCBpbGVuID0gc2NhbGUuZ2V0VGlja3MoKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdGN1cnIgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2soaSk7XHJcblx0XHRtaW4gPSBpID4gMCA/IE1hdGgubWluKG1pbiwgTWF0aC5hYnMoY3VyciAtIHByZXYpKSA6IG1pbjtcclxuXHRcdHByZXYgPSBjdXJyO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIG1pbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIGFuIFwiaWRlYWxcIiBjYXRlZ29yeSBiYXNlZCBvbiB0aGUgYWJzb2x1dGUgYmFyIHRoaWNrbmVzcyBvciwgaWYgdW5kZWZpbmVkIG9yIG51bGwsXHJcbiAqIHVzZXMgdGhlIHNtYWxsZXN0IGludGVydmFsIChzZWUgY29tcHV0ZU1pblNhbXBsZVNpemUpIHRoYXQgcHJldmVudHMgYmFyIG92ZXJsYXBwaW5nLiBUaGlzXHJcbiAqIG1vZGUgY3VycmVudGx5IGFsd2F5cyBnZW5lcmF0ZXMgYmFycyBlcXVhbGx5IHNpemVkICh1bnRpbCB3ZSBpbnRyb2R1Y2Ugc2NyaXB0YWJsZSBvcHRpb25zPykuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zKSB7XHJcblx0dmFyIHRoaWNrbmVzcyA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzO1xyXG5cdHZhciBjb3VudCA9IHJ1bGVyLnN0YWNrQ291bnQ7XHJcblx0dmFyIGN1cnIgPSBydWxlci5waXhlbHNbaW5kZXhdO1xyXG5cdHZhciBtaW4gPSBoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZih0aGlja25lc3MpXHJcblx0XHQ/IGNvbXB1dGVNaW5TYW1wbGVTaXplKHJ1bGVyLnNjYWxlLCBydWxlci5waXhlbHMpXHJcblx0XHQ6IC0xO1xyXG5cdHZhciBzaXplLCByYXRpbztcclxuXHJcblx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKHRoaWNrbmVzcykpIHtcclxuXHRcdHNpemUgPSBtaW4gKiBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcclxuXHRcdHJhdGlvID0gb3B0aW9ucy5iYXJQZXJjZW50YWdlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyBXaGVuIGJhciB0aGlja25lc3MgaXMgZW5mb3JjZWQsIGNhdGVnb3J5IGFuZCBiYXIgcGVyY2VudGFnZXMgYXJlIGlnbm9yZWQuXHJcblx0XHQvLyBOb3RlKFNCKTogd2UgY291bGQgYWRkIHN1cHBvcnQgZm9yIHJlbGF0aXZlIGJhciB0aGlja25lc3MgKGUuZy4gYmFyVGhpY2tuZXNzOiAnNTAlJylcclxuXHRcdC8vIGFuZCBkZXByZWNhdGUgYmFyUGVyY2VudGFnZSBzaW5jZSB0aGlzIHZhbHVlIGlzIGlnbm9yZWQgd2hlbiB0aGlja25lc3MgaXMgYWJzb2x1dGUuXHJcblx0XHRzaXplID0gdGhpY2tuZXNzICogY291bnQ7XHJcblx0XHRyYXRpbyA9IDE7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0Y2h1bms6IHNpemUgLyBjb3VudCxcclxuXHRcdHJhdGlvOiByYXRpbyxcclxuXHRcdHN0YXJ0OiBjdXJyIC0gKHNpemUgLyAyKVxyXG5cdH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyBhbiBcIm9wdGltYWxcIiBjYXRlZ29yeSB0aGF0IGdsb2JhbGx5IGFycmFuZ2VzIGJhcnMgc2lkZSBieSBzaWRlIChubyBnYXAgd2hlblxyXG4gKiBwZXJjZW50YWdlIG9wdGlvbnMgYXJlIDEpLCBiYXNlZCBvbiB0aGUgcHJldmlvdXMgYW5kIGZvbGxvd2luZyBjYXRlZ29yaWVzLiBUaGlzIG1vZGVcclxuICogZ2VuZXJhdGVzIGJhcnMgd2l0aCBkaWZmZXJlbnQgd2lkdGhzIHdoZW4gZGF0YSBhcmUgbm90IGV2ZW5seSBzcGFjZWQuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucykge1xyXG5cdHZhciBwaXhlbHMgPSBydWxlci5waXhlbHM7XHJcblx0dmFyIGN1cnIgPSBwaXhlbHNbaW5kZXhdO1xyXG5cdHZhciBwcmV2ID0gaW5kZXggPiAwID8gcGl4ZWxzW2luZGV4IC0gMV0gOiBudWxsO1xyXG5cdHZhciBuZXh0ID0gaW5kZXggPCBwaXhlbHMubGVuZ3RoIC0gMSA/IHBpeGVsc1tpbmRleCArIDFdIDogbnVsbDtcclxuXHR2YXIgcGVyY2VudCA9IG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xyXG5cdHZhciBzdGFydCwgc2l6ZTtcclxuXHJcblx0aWYgKHByZXYgPT09IG51bGwpIHtcclxuXHRcdC8vIGZpcnN0IGRhdGE6IGl0cyBzaXplIGlzIGRvdWJsZSBiYXNlZCBvbiB0aGUgbmV4dCBwb2ludCBvcixcclxuXHRcdC8vIGlmIGl0J3MgYWxzbyB0aGUgbGFzdCBkYXRhLCB3ZSB1c2UgdGhlIHNjYWxlIHNpemUuXHJcblx0XHRwcmV2ID0gY3VyciAtIChuZXh0ID09PSBudWxsID8gcnVsZXIuZW5kIC0gcnVsZXIuc3RhcnQgOiBuZXh0IC0gY3Vycik7XHJcblx0fVxyXG5cclxuXHRpZiAobmV4dCA9PT0gbnVsbCkge1xyXG5cdFx0Ly8gbGFzdCBkYXRhOiBpdHMgc2l6ZSBpcyBhbHNvIGRvdWJsZSBiYXNlZCBvbiB0aGUgcHJldmlvdXMgcG9pbnQuXHJcblx0XHRuZXh0ID0gY3VyciArIGN1cnIgLSBwcmV2O1xyXG5cdH1cclxuXHJcblx0c3RhcnQgPSBjdXJyIC0gKGN1cnIgLSBNYXRoLm1pbihwcmV2LCBuZXh0KSkgLyAyICogcGVyY2VudDtcclxuXHRzaXplID0gTWF0aC5hYnMobmV4dCAtIHByZXYpIC8gMiAqIHBlcmNlbnQ7XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRjaHVuazogc2l6ZSAvIHJ1bGVyLnN0YWNrQ291bnQsXHJcblx0XHRyYXRpbzogb3B0aW9ucy5iYXJQZXJjZW50YWdlLFxyXG5cdFx0c3RhcnQ6IHN0YXJ0XHJcblx0fTtcclxufVxyXG5cclxudmFyIGNvbnRyb2xsZXJfYmFyID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xyXG5cclxuXHRkYXRhRWxlbWVudFR5cGU6IGVsZW1lbnRzLlJlY3RhbmdsZSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZGF0YUVsZW1lbnRPcHRpb25zOiBbXHJcblx0XHQnYmFja2dyb3VuZENvbG9yJyxcclxuXHRcdCdib3JkZXJDb2xvcicsXHJcblx0XHQnYm9yZGVyU2tpcHBlZCcsXHJcblx0XHQnYm9yZGVyV2lkdGgnLFxyXG5cdFx0J2JhclBlcmNlbnRhZ2UnLFxyXG5cdFx0J2JhclRoaWNrbmVzcycsXHJcblx0XHQnY2F0ZWdvcnlQZXJjZW50YWdlJyxcclxuXHRcdCdtYXhCYXJUaGlja25lc3MnLFxyXG5cdFx0J21pbkJhckxlbmd0aCdcclxuXHRdLFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWV0YSwgc2NhbGVPcHRzO1xyXG5cclxuXHRcdGNvcmVfZGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XHJcblxyXG5cdFx0bWV0YSA9IG1lLmdldE1ldGEoKTtcclxuXHRcdG1ldGEuc3RhY2sgPSBtZS5nZXREYXRhc2V0KCkuc3RhY2s7XHJcblx0XHRtZXRhLmJhciA9IHRydWU7XHJcblxyXG5cdFx0c2NhbGVPcHRzID0gbWUuX2dldEluZGV4U2NhbGUoKS5vcHRpb25zO1xyXG5cdFx0ZGVwcmVjYXRlZCgnYmFyIGNoYXJ0Jywgc2NhbGVPcHRzLmJhclBlcmNlbnRhZ2UsICdzY2FsZXMuW3gveV1BeGVzLmJhclBlcmNlbnRhZ2UnLCAnZGF0YXNldC5iYXJQZXJjZW50YWdlJyk7XHJcblx0XHRkZXByZWNhdGVkKCdiYXIgY2hhcnQnLCBzY2FsZU9wdHMuYmFyVGhpY2tuZXNzLCAnc2NhbGVzLlt4L3ldQXhlcy5iYXJUaGlja25lc3MnLCAnZGF0YXNldC5iYXJUaGlja25lc3MnKTtcclxuXHRcdGRlcHJlY2F0ZWQoJ2JhciBjaGFydCcsIHNjYWxlT3B0cy5jYXRlZ29yeVBlcmNlbnRhZ2UsICdzY2FsZXMuW3gveV1BeGVzLmNhdGVnb3J5UGVyY2VudGFnZScsICdkYXRhc2V0LmNhdGVnb3J5UGVyY2VudGFnZScpO1xyXG5cdFx0ZGVwcmVjYXRlZCgnYmFyIGNoYXJ0JywgbWUuX2dldFZhbHVlU2NhbGUoKS5vcHRpb25zLm1pbkJhckxlbmd0aCwgJ3NjYWxlcy5beC95XUF4ZXMubWluQmFyTGVuZ3RoJywgJ2RhdGFzZXQubWluQmFyTGVuZ3RoJyk7XHJcblx0XHRkZXByZWNhdGVkKCdiYXIgY2hhcnQnLCBzY2FsZU9wdHMubWF4QmFyVGhpY2tuZXNzLCAnc2NhbGVzLlt4L3ldQXhlcy5tYXhCYXJUaGlja25lc3MnLCAnZGF0YXNldC5tYXhCYXJUaGlja25lc3MnKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHJlY3RzID0gbWUuZ2V0TWV0YSgpLmRhdGE7XHJcblx0XHR2YXIgaSwgaWxlbjtcclxuXHJcblx0XHRtZS5fcnVsZXIgPSBtZS5nZXRSdWxlcigpO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSByZWN0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0bWUudXBkYXRlRWxlbWVudChyZWN0c1tpXSwgaSwgcmVzZXQpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHJlY3RhbmdsZSwgaW5kZXgsIHJlc2V0KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XHJcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcclxuXHRcdHZhciBvcHRpb25zID0gbWUuX3Jlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMocmVjdGFuZ2xlLCBpbmRleCk7XHJcblxyXG5cdFx0cmVjdGFuZ2xlLl94U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueEF4aXNJRCk7XHJcblx0XHRyZWN0YW5nbGUuX3lTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcclxuXHRcdHJlY3RhbmdsZS5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XHJcblx0XHRyZWN0YW5nbGUuX2luZGV4ID0gaW5kZXg7XHJcblx0XHRyZWN0YW5nbGUuX21vZGVsID0ge1xyXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxyXG5cdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcclxuXHRcdFx0Ym9yZGVyU2tpcHBlZDogb3B0aW9ucy5ib3JkZXJTa2lwcGVkLFxyXG5cdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcclxuXHRcdFx0ZGF0YXNldExhYmVsOiBkYXRhc2V0LmxhYmVsLFxyXG5cdFx0XHRsYWJlbDogbWUuY2hhcnQuZGF0YS5sYWJlbHNbaW5kZXhdXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheShkYXRhc2V0LmRhdGFbaW5kZXhdKSkge1xyXG5cdFx0XHRyZWN0YW5nbGUuX21vZGVsLmJvcmRlclNraXBwZWQgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1lLl91cGRhdGVFbGVtZW50R2VvbWV0cnkocmVjdGFuZ2xlLCBpbmRleCwgcmVzZXQsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHJlY3RhbmdsZS5waXZvdCgpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3VwZGF0ZUVsZW1lbnRHZW9tZXRyeTogZnVuY3Rpb24ocmVjdGFuZ2xlLCBpbmRleCwgcmVzZXQsIG9wdGlvbnMpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbW9kZWwgPSByZWN0YW5nbGUuX21vZGVsO1xyXG5cdFx0dmFyIHZzY2FsZSA9IG1lLl9nZXRWYWx1ZVNjYWxlKCk7XHJcblx0XHR2YXIgYmFzZSA9IHZzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcclxuXHRcdHZhciBob3Jpem9udGFsID0gdnNjYWxlLmlzSG9yaXpvbnRhbCgpO1xyXG5cdFx0dmFyIHJ1bGVyID0gbWUuX3J1bGVyIHx8IG1lLmdldFJ1bGVyKCk7XHJcblx0XHR2YXIgdnBpeGVscyA9IG1lLmNhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKG1lLmluZGV4LCBpbmRleCwgb3B0aW9ucyk7XHJcblx0XHR2YXIgaXBpeGVscyA9IG1lLmNhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKG1lLmluZGV4LCBpbmRleCwgcnVsZXIsIG9wdGlvbnMpO1xyXG5cclxuXHRcdG1vZGVsLmhvcml6b250YWwgPSBob3Jpem9udGFsO1xyXG5cdFx0bW9kZWwuYmFzZSA9IHJlc2V0ID8gYmFzZSA6IHZwaXhlbHMuYmFzZTtcclxuXHRcdG1vZGVsLnggPSBob3Jpem9udGFsID8gcmVzZXQgPyBiYXNlIDogdnBpeGVscy5oZWFkIDogaXBpeGVscy5jZW50ZXI7XHJcblx0XHRtb2RlbC55ID0gaG9yaXpvbnRhbCA/IGlwaXhlbHMuY2VudGVyIDogcmVzZXQgPyBiYXNlIDogdnBpeGVscy5oZWFkO1xyXG5cdFx0bW9kZWwuaGVpZ2h0ID0gaG9yaXpvbnRhbCA/IGlwaXhlbHMuc2l6ZSA6IHVuZGVmaW5lZDtcclxuXHRcdG1vZGVsLndpZHRoID0gaG9yaXpvbnRhbCA/IHVuZGVmaW5lZCA6IGlwaXhlbHMuc2l6ZTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBzdGFja3MgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2xhc3RdIC0gVGhlIGRhdGFzZXQgaW5kZXhcclxuXHQgKiBAcmV0dXJucyB7c3RyaW5nW119IFRoZSBsaXN0IG9mIHN0YWNrIElEc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldFN0YWNrczogZnVuY3Rpb24obGFzdCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBzY2FsZSA9IG1lLl9nZXRJbmRleFNjYWxlKCk7XHJcblx0XHR2YXIgbWV0YXNldHMgPSBzY2FsZS5fZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMobWUuX3R5cGUpO1xyXG5cdFx0dmFyIHN0YWNrZWQgPSBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XHJcblx0XHR2YXIgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDtcclxuXHRcdHZhciBzdGFja3MgPSBbXTtcclxuXHRcdHZhciBpLCBtZXRhO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0bWV0YSA9IG1ldGFzZXRzW2ldO1xyXG5cdFx0XHQvLyBzdGFja2VkICAgfCBtZXRhLnN0YWNrXHJcblx0XHRcdC8vICAgICAgICAgICB8IGZvdW5kIHwgbm90IGZvdW5kIHwgdW5kZWZpbmVkXHJcblx0XHRcdC8vIGZhbHNlICAgICB8ICAgeCAgIHwgICAgIHggICAgIHwgICAgIHhcclxuXHRcdFx0Ly8gdHJ1ZSAgICAgIHwgICAgICAgfCAgICAgeCAgICAgfFxyXG5cdFx0XHQvLyB1bmRlZmluZWQgfCAgICAgICB8ICAgICB4ICAgICB8ICAgICB4XHJcblx0XHRcdGlmIChzdGFja2VkID09PSBmYWxzZSB8fCBzdGFja3MuaW5kZXhPZihtZXRhLnN0YWNrKSA9PT0gLTEgfHxcclxuXHRcdFx0XHQoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCkpIHtcclxuXHRcdFx0XHRzdGFja3MucHVzaChtZXRhLnN0YWNrKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAobWV0YS5pbmRleCA9PT0gbGFzdCkge1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHN0YWNrcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBlZmZlY3RpdmUgbnVtYmVyIG9mIHN0YWNrcyBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0U3RhY2tDb3VudDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fZ2V0U3RhY2tzKCkubGVuZ3RoO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHN0YWNrIGluZGV4IGZvciB0aGUgZ2l2ZW4gZGF0YXNldCBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YXNldEluZGV4XSAtIFRoZSBkYXRhc2V0IGluZGV4XHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSAtIFRoZSBzdGFjayBuYW1lIHRvIGZpbmRcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgc3RhY2sgaW5kZXhcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFN0YWNrSW5kZXg6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCwgbmFtZSkge1xyXG5cdFx0dmFyIHN0YWNrcyA9IHRoaXMuX2dldFN0YWNrcyhkYXRhc2V0SW5kZXgpO1xyXG5cdFx0dmFyIGluZGV4ID0gKG5hbWUgIT09IHVuZGVmaW5lZClcclxuXHRcdFx0PyBzdGFja3MuaW5kZXhPZihuYW1lKVxyXG5cdFx0XHQ6IC0xOyAvLyBpbmRleE9mIHJldHVybnMgLTEgaWYgZWxlbWVudCBpcyBub3QgcHJlc2VudFxyXG5cclxuXHRcdHJldHVybiAoaW5kZXggPT09IC0xKVxyXG5cdFx0XHQ/IHN0YWNrcy5sZW5ndGggLSAxXHJcblx0XHRcdDogaW5kZXg7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRSdWxlcjogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHNjYWxlID0gbWUuX2dldEluZGV4U2NhbGUoKTtcclxuXHRcdHZhciBwaXhlbHMgPSBbXTtcclxuXHRcdHZhciBpLCBpbGVuO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBtZS5nZXRNZXRhKCkuZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0cGl4ZWxzLnB1c2goc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShudWxsLCBpLCBtZS5pbmRleCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHBpeGVsczogcGl4ZWxzLFxyXG5cdFx0XHRzdGFydDogc2NhbGUuX3N0YXJ0UGl4ZWwsXHJcblx0XHRcdGVuZDogc2NhbGUuX2VuZFBpeGVsLFxyXG5cdFx0XHRzdGFja0NvdW50OiBtZS5nZXRTdGFja0NvdW50KCksXHJcblx0XHRcdHNjYWxlOiBzY2FsZVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBOb3RlOiBwaXhlbCB2YWx1ZXMgYXJlIG5vdCBjbGFtcGVkIHRvIHRoZSBzY2FsZSBhcmVhLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Y2FsY3VsYXRlQmFyVmFsdWVQaXhlbHM6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCwgaW5kZXgsIG9wdGlvbnMpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBzY2FsZSA9IG1lLl9nZXRWYWx1ZVNjYWxlKCk7XHJcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XHJcblx0XHR2YXIgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xyXG5cdFx0dmFyIG1ldGFzZXRzID0gc2NhbGUuX2dldE1hdGNoaW5nVmlzaWJsZU1ldGFzKG1lLl90eXBlKTtcclxuXHRcdHZhciB2YWx1ZSA9IHNjYWxlLl9wYXJzZVZhbHVlKGRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0pO1xyXG5cdFx0dmFyIG1pbkJhckxlbmd0aCA9IG9wdGlvbnMubWluQmFyTGVuZ3RoO1xyXG5cdFx0dmFyIHN0YWNrZWQgPSBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XHJcblx0XHR2YXIgc3RhY2sgPSBtZS5nZXRNZXRhKCkuc3RhY2s7XHJcblx0XHR2YXIgc3RhcnQgPSB2YWx1ZS5zdGFydCA9PT0gdW5kZWZpbmVkID8gMCA6IHZhbHVlLm1heCA+PSAwICYmIHZhbHVlLm1pbiA+PSAwID8gdmFsdWUubWluIDogdmFsdWUubWF4O1xyXG5cdFx0dmFyIGxlbmd0aCA9IHZhbHVlLnN0YXJ0ID09PSB1bmRlZmluZWQgPyB2YWx1ZS5lbmQgOiB2YWx1ZS5tYXggPj0gMCAmJiB2YWx1ZS5taW4gPj0gMCA/IHZhbHVlLm1heCAtIHZhbHVlLm1pbiA6IHZhbHVlLm1pbiAtIHZhbHVlLm1heDtcclxuXHRcdHZhciBpbGVuID0gbWV0YXNldHMubGVuZ3RoO1xyXG5cdFx0dmFyIGksIGltZXRhLCBpdmFsdWUsIGJhc2UsIGhlYWQsIHNpemUsIHN0YWNrTGVuZ3RoO1xyXG5cclxuXHRcdGlmIChzdGFja2VkIHx8IChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgc3RhY2sgIT09IHVuZGVmaW5lZCkpIHtcclxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRcdGltZXRhID0gbWV0YXNldHNbaV07XHJcblxyXG5cdFx0XHRcdGlmIChpbWV0YS5pbmRleCA9PT0gZGF0YXNldEluZGV4KSB7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChpbWV0YS5zdGFjayA9PT0gc3RhY2spIHtcclxuXHRcdFx0XHRcdHN0YWNrTGVuZ3RoID0gc2NhbGUuX3BhcnNlVmFsdWUoZGF0YXNldHNbaW1ldGEuaW5kZXhdLmRhdGFbaW5kZXhdKTtcclxuXHRcdFx0XHRcdGl2YWx1ZSA9IHN0YWNrTGVuZ3RoLnN0YXJ0ID09PSB1bmRlZmluZWQgPyBzdGFja0xlbmd0aC5lbmQgOiBzdGFja0xlbmd0aC5taW4gPj0gMCAmJiBzdGFja0xlbmd0aC5tYXggPj0gMCA/IHN0YWNrTGVuZ3RoLm1heCA6IHN0YWNrTGVuZ3RoLm1pbjtcclxuXHJcblx0XHRcdFx0XHRpZiAoKHZhbHVlLm1pbiA8IDAgJiYgaXZhbHVlIDwgMCkgfHwgKHZhbHVlLm1heCA+PSAwICYmIGl2YWx1ZSA+IDApKSB7XHJcblx0XHRcdFx0XHRcdHN0YXJ0ICs9IGl2YWx1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRiYXNlID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCk7XHJcblx0XHRoZWFkID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCArIGxlbmd0aCk7XHJcblx0XHRzaXplID0gaGVhZCAtIGJhc2U7XHJcblxyXG5cdFx0aWYgKG1pbkJhckxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIE1hdGguYWJzKHNpemUpIDwgbWluQmFyTGVuZ3RoKSB7XHJcblx0XHRcdHNpemUgPSBtaW5CYXJMZW5ndGg7XHJcblx0XHRcdGlmIChsZW5ndGggPj0gMCAmJiAhaXNIb3Jpem9udGFsIHx8IGxlbmd0aCA8IDAgJiYgaXNIb3Jpem9udGFsKSB7XHJcblx0XHRcdFx0aGVhZCA9IGJhc2UgLSBtaW5CYXJMZW5ndGg7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aGVhZCA9IGJhc2UgKyBtaW5CYXJMZW5ndGg7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRzaXplOiBzaXplLFxyXG5cdFx0XHRiYXNlOiBiYXNlLFxyXG5cdFx0XHRoZWFkOiBoZWFkLFxyXG5cdFx0XHRjZW50ZXI6IGhlYWQgKyBzaXplIC8gMlxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGNhbGN1bGF0ZUJhckluZGV4UGl4ZWxzOiBmdW5jdGlvbihkYXRhc2V0SW5kZXgsIGluZGV4LCBydWxlciwgb3B0aW9ucykge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciByYW5nZSA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzID09PSAnZmxleCdcclxuXHRcdFx0PyBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucylcclxuXHRcdFx0OiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zKTtcclxuXHJcblx0XHR2YXIgc3RhY2tJbmRleCA9IG1lLmdldFN0YWNrSW5kZXgoZGF0YXNldEluZGV4LCBtZS5nZXRNZXRhKCkuc3RhY2spO1xyXG5cdFx0dmFyIGNlbnRlciA9IHJhbmdlLnN0YXJ0ICsgKHJhbmdlLmNodW5rICogc3RhY2tJbmRleCkgKyAocmFuZ2UuY2h1bmsgLyAyKTtcclxuXHRcdHZhciBzaXplID0gTWF0aC5taW4oXHJcblx0XHRcdHZhbHVlT3JEZWZhdWx0JDMob3B0aW9ucy5tYXhCYXJUaGlja25lc3MsIEluZmluaXR5KSxcclxuXHRcdFx0cmFuZ2UuY2h1bmsgKiByYW5nZS5yYXRpbyk7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0YmFzZTogY2VudGVyIC0gc2l6ZSAvIDIsXHJcblx0XHRcdGhlYWQ6IGNlbnRlciArIHNpemUgLyAyLFxyXG5cdFx0XHRjZW50ZXI6IGNlbnRlcixcclxuXHRcdFx0c2l6ZTogc2l6ZVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRkcmF3OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBzY2FsZSA9IG1lLl9nZXRWYWx1ZVNjYWxlKCk7XHJcblx0XHR2YXIgcmVjdHMgPSBtZS5nZXRNZXRhKCkuZGF0YTtcclxuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xyXG5cdFx0dmFyIGlsZW4gPSByZWN0cy5sZW5ndGg7XHJcblx0XHR2YXIgaSA9IDA7XHJcblxyXG5cdFx0aGVscGVycyQxLmNhbnZhcy5jbGlwQXJlYShjaGFydC5jdHgsIGNoYXJ0LmNoYXJ0QXJlYSk7XHJcblxyXG5cdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0dmFyIHZhbCA9IHNjYWxlLl9wYXJzZVZhbHVlKGRhdGFzZXQuZGF0YVtpXSk7XHJcblx0XHRcdGlmICghaXNOYU4odmFsLm1pbikgJiYgIWlzTmFOKHZhbC5tYXgpKSB7XHJcblx0XHRcdFx0cmVjdHNbaV0uZHJhdygpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aGVscGVycyQxLmNhbnZhcy51bmNsaXBBcmVhKGNoYXJ0LmN0eCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9uczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHZhbHVlcyA9IGhlbHBlcnMkMS5leHRlbmQoe30sIGNvcmVfZGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLl9yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zLmFwcGx5KG1lLCBhcmd1bWVudHMpKTtcclxuXHRcdHZhciBpbmRleE9wdHMgPSBtZS5fZ2V0SW5kZXhTY2FsZSgpLm9wdGlvbnM7XHJcblx0XHR2YXIgdmFsdWVPcHRzID0gbWUuX2dldFZhbHVlU2NhbGUoKS5vcHRpb25zO1xyXG5cclxuXHRcdHZhbHVlcy5iYXJQZXJjZW50YWdlID0gdmFsdWVPckRlZmF1bHQkMyhpbmRleE9wdHMuYmFyUGVyY2VudGFnZSwgdmFsdWVzLmJhclBlcmNlbnRhZ2UpO1xyXG5cdFx0dmFsdWVzLmJhclRoaWNrbmVzcyA9IHZhbHVlT3JEZWZhdWx0JDMoaW5kZXhPcHRzLmJhclRoaWNrbmVzcywgdmFsdWVzLmJhclRoaWNrbmVzcyk7XHJcblx0XHR2YWx1ZXMuY2F0ZWdvcnlQZXJjZW50YWdlID0gdmFsdWVPckRlZmF1bHQkMyhpbmRleE9wdHMuY2F0ZWdvcnlQZXJjZW50YWdlLCB2YWx1ZXMuY2F0ZWdvcnlQZXJjZW50YWdlKTtcclxuXHRcdHZhbHVlcy5tYXhCYXJUaGlja25lc3MgPSB2YWx1ZU9yRGVmYXVsdCQzKGluZGV4T3B0cy5tYXhCYXJUaGlja25lc3MsIHZhbHVlcy5tYXhCYXJUaGlja25lc3MpO1xyXG5cdFx0dmFsdWVzLm1pbkJhckxlbmd0aCA9IHZhbHVlT3JEZWZhdWx0JDModmFsdWVPcHRzLm1pbkJhckxlbmd0aCwgdmFsdWVzLm1pbkJhckxlbmd0aCk7XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlcztcclxuXHR9XHJcblxyXG59KTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDQgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XHJcbnZhciByZXNvbHZlJDEgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xyXG5cclxuY29yZV9kZWZhdWx0cy5fc2V0KCdidWJibGUnLCB7XHJcblx0aG92ZXI6IHtcclxuXHRcdG1vZGU6ICdzaW5nbGUnXHJcblx0fSxcclxuXHJcblx0c2NhbGVzOiB7XHJcblx0XHR4QXhlczogW3tcclxuXHRcdFx0dHlwZTogJ2xpbmVhcicsIC8vIGJ1YmJsZSBzaG91bGQgcHJvYmFibHkgdXNlIGEgbGluZWFyIHNjYWxlIGJ5IGRlZmF1bHRcclxuXHRcdFx0cG9zaXRpb246ICdib3R0b20nLFxyXG5cdFx0XHRpZDogJ3gtYXhpcy0wJyAvLyBuZWVkIGFuIElEIHNvIGRhdGFzZXRzIGNhbiByZWZlcmVuY2UgdGhlIHNjYWxlXHJcblx0XHR9XSxcclxuXHRcdHlBeGVzOiBbe1xyXG5cdFx0XHR0eXBlOiAnbGluZWFyJyxcclxuXHRcdFx0cG9zaXRpb246ICdsZWZ0JyxcclxuXHRcdFx0aWQ6ICd5LWF4aXMtMCdcclxuXHRcdH1dXHJcblx0fSxcclxuXHJcblx0dG9vbHRpcHM6IHtcclxuXHRcdGNhbGxiYWNrczoge1xyXG5cdFx0XHR0aXRsZTogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Ly8gVGl0bGUgZG9lc24ndCBtYWtlIHNlbnNlIGZvciBzY2F0dGVyIHNpbmNlIHdlIGZvcm1hdCB0aGUgZGF0YSBhcyBhIHBvaW50XHJcblx0XHRcdFx0cmV0dXJuICcnO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24oaXRlbSwgZGF0YSkge1xyXG5cdFx0XHRcdHZhciBkYXRhc2V0TGFiZWwgPSBkYXRhLmRhdGFzZXRzW2l0ZW0uZGF0YXNldEluZGV4XS5sYWJlbCB8fCAnJztcclxuXHRcdFx0XHR2YXIgZGF0YVBvaW50ID0gZGF0YS5kYXRhc2V0c1tpdGVtLmRhdGFzZXRJbmRleF0uZGF0YVtpdGVtLmluZGV4XTtcclxuXHRcdFx0XHRyZXR1cm4gZGF0YXNldExhYmVsICsgJzogKCcgKyBpdGVtLnhMYWJlbCArICcsICcgKyBpdGVtLnlMYWJlbCArICcsICcgKyBkYXRhUG9pbnQuciArICcpJztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG52YXIgY29udHJvbGxlcl9idWJibGUgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XHJcblx0LyoqXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqL1xyXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuUG9pbnQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2RhdGFFbGVtZW50T3B0aW9uczogW1xyXG5cdFx0J2JhY2tncm91bmRDb2xvcicsXHJcblx0XHQnYm9yZGVyQ29sb3InLFxyXG5cdFx0J2JvcmRlcldpZHRoJyxcclxuXHRcdCdob3ZlckJhY2tncm91bmRDb2xvcicsXHJcblx0XHQnaG92ZXJCb3JkZXJDb2xvcicsXHJcblx0XHQnaG92ZXJCb3JkZXJXaWR0aCcsXHJcblx0XHQnaG92ZXJSYWRpdXMnLFxyXG5cdFx0J2hpdFJhZGl1cycsXHJcblx0XHQncG9pbnRTdHlsZScsXHJcblx0XHQncm90YXRpb24nXHJcblx0XSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqL1xyXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcclxuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGE7XHJcblxyXG5cdFx0Ly8gVXBkYXRlIFBvaW50c1xyXG5cdFx0aGVscGVycyQxLmVhY2gocG9pbnRzLCBmdW5jdGlvbihwb2ludCwgaW5kZXgpIHtcclxuXHRcdFx0bWUudXBkYXRlRWxlbWVudChwb2ludCwgaW5kZXgsIHJlc2V0KTtcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKi9cclxuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihwb2ludCwgaW5kZXgsIHJlc2V0KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XHJcblx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xyXG5cdFx0dmFyIHhTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS54QXhpc0lEKTtcclxuXHRcdHZhciB5U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueUF4aXNJRCk7XHJcblx0XHR2YXIgb3B0aW9ucyA9IG1lLl9yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHBvaW50LCBpbmRleCk7XHJcblx0XHR2YXIgZGF0YSA9IG1lLmdldERhdGFzZXQoKS5kYXRhW2luZGV4XTtcclxuXHRcdHZhciBkc0luZGV4ID0gbWUuaW5kZXg7XHJcblxyXG5cdFx0dmFyIHggPSByZXNldCA/IHhTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMC41KSA6IHhTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyA/IGRhdGEgOiBOYU4sIGluZGV4LCBkc0luZGV4KTtcclxuXHRcdHZhciB5ID0gcmVzZXQgPyB5U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB5U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShkYXRhLCBpbmRleCwgZHNJbmRleCk7XHJcblxyXG5cdFx0cG9pbnQuX3hTY2FsZSA9IHhTY2FsZTtcclxuXHRcdHBvaW50Ll95U2NhbGUgPSB5U2NhbGU7XHJcblx0XHRwb2ludC5fb3B0aW9ucyA9IG9wdGlvbnM7XHJcblx0XHRwb2ludC5fZGF0YXNldEluZGV4ID0gZHNJbmRleDtcclxuXHRcdHBvaW50Ll9pbmRleCA9IGluZGV4O1xyXG5cdFx0cG9pbnQuX21vZGVsID0ge1xyXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxyXG5cdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcclxuXHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXHJcblx0XHRcdGhpdFJhZGl1czogb3B0aW9ucy5oaXRSYWRpdXMsXHJcblx0XHRcdHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcclxuXHRcdFx0cm90YXRpb246IG9wdGlvbnMucm90YXRpb24sXHJcblx0XHRcdHJhZGl1czogcmVzZXQgPyAwIDogb3B0aW9ucy5yYWRpdXMsXHJcblx0XHRcdHNraXA6IGN1c3RvbS5za2lwIHx8IGlzTmFOKHgpIHx8IGlzTmFOKHkpLFxyXG5cdFx0XHR4OiB4LFxyXG5cdFx0XHR5OiB5LFxyXG5cdFx0fTtcclxuXHJcblx0XHRwb2ludC5waXZvdCgpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKi9cclxuXHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihwb2ludCkge1xyXG5cdFx0dmFyIG1vZGVsID0gcG9pbnQuX21vZGVsO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBwb2ludC5fb3B0aW9ucztcclxuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XHJcblxyXG5cdFx0cG9pbnQuJHByZXZpb3VzU3R5bGUgPSB7XHJcblx0XHRcdGJhY2tncm91bmRDb2xvcjogbW9kZWwuYmFja2dyb3VuZENvbG9yLFxyXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXHJcblx0XHRcdGJvcmRlcldpZHRoOiBtb2RlbC5ib3JkZXJXaWR0aCxcclxuXHRcdFx0cmFkaXVzOiBtb2RlbC5yYWRpdXNcclxuXHRcdH07XHJcblxyXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gdmFsdWVPckRlZmF1bHQkNChvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XHJcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDQob3B0aW9ucy5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpKTtcclxuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gdmFsdWVPckRlZmF1bHQkNChvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xyXG5cdFx0bW9kZWwucmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhvdmVyUmFkaXVzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3Jlc29sdmVEYXRhRWxlbWVudE9wdGlvbnM6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XHJcblx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xyXG5cdFx0dmFyIGRhdGEgPSBkYXRhc2V0LmRhdGFbaW5kZXhdIHx8IHt9O1xyXG5cdFx0dmFyIHZhbHVlcyA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLl9yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xyXG5cclxuXHRcdC8vIFNjcmlwdGFibGUgb3B0aW9uc1xyXG5cdFx0dmFyIGNvbnRleHQgPSB7XHJcblx0XHRcdGNoYXJ0OiBjaGFydCxcclxuXHRcdFx0ZGF0YUluZGV4OiBpbmRleCxcclxuXHRcdFx0ZGF0YXNldDogZGF0YXNldCxcclxuXHRcdFx0ZGF0YXNldEluZGV4OiBtZS5pbmRleFxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBJbiBjYXNlIHZhbHVlcyB3ZXJlIGNhY2hlZCAoYW5kIHRodXMgZnJvemVuKSwgd2UgbmVlZCB0byBjbG9uZSB0aGUgdmFsdWVzXHJcblx0XHRpZiAobWUuX2NhY2hlZERhdGFPcHRzID09PSB2YWx1ZXMpIHtcclxuXHRcdFx0dmFsdWVzID0gaGVscGVycyQxLmV4dGVuZCh7fSwgdmFsdWVzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBDdXN0b20gcmFkaXVzIHJlc29sdXRpb25cclxuXHRcdHZhbHVlcy5yYWRpdXMgPSByZXNvbHZlJDEoW1xyXG5cdFx0XHRjdXN0b20ucmFkaXVzLFxyXG5cdFx0XHRkYXRhLnIsXHJcblx0XHRcdG1lLl9jb25maWcucmFkaXVzLFxyXG5cdFx0XHRjaGFydC5vcHRpb25zLmVsZW1lbnRzLnBvaW50LnJhZGl1c1xyXG5cdFx0XSwgY29udGV4dCwgaW5kZXgpO1xyXG5cclxuXHRcdHJldHVybiB2YWx1ZXM7XHJcblx0fVxyXG59KTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDUgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XHJcblxyXG52YXIgUEkkMSA9IE1hdGguUEk7XHJcbnZhciBET1VCTEVfUEkkMSA9IFBJJDEgKiAyO1xyXG52YXIgSEFMRl9QSSQxID0gUEkkMSAvIDI7XHJcblxyXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2RvdWdobnV0Jywge1xyXG5cdGFuaW1hdGlvbjoge1xyXG5cdFx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgd2UgYW5pbWF0ZSB0aGUgcm90YXRpb24gb2YgdGhlIERvdWdobnV0XHJcblx0XHRhbmltYXRlUm90YXRlOiB0cnVlLFxyXG5cdFx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgd2UgYW5pbWF0ZSBzY2FsaW5nIHRoZSBEb3VnaG51dCBmcm9tIHRoZSBjZW50cmVcclxuXHRcdGFuaW1hdGVTY2FsZTogZmFsc2VcclxuXHR9LFxyXG5cdGhvdmVyOiB7XHJcblx0XHRtb2RlOiAnc2luZ2xlJ1xyXG5cdH0sXHJcblx0bGVnZW5kQ2FsbGJhY2s6IGZ1bmN0aW9uKGNoYXJ0KSB7XHJcblx0XHR2YXIgbGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XHJcblx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XHJcblx0XHR2YXIgZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzO1xyXG5cdFx0dmFyIGxhYmVscyA9IGRhdGEubGFiZWxzO1xyXG5cdFx0dmFyIGksIGlsZW4sIGxpc3RJdGVtLCBsaXN0SXRlbVNwYW47XHJcblxyXG5cdFx0bGlzdC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2hhcnQuaWQgKyAnLWxlZ2VuZCcpO1xyXG5cdFx0aWYgKGRhdGFzZXRzLmxlbmd0aCkge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHNbMF0uZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0XHRsaXN0SXRlbSA9IGxpc3QuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKSk7XHJcblx0XHRcdFx0bGlzdEl0ZW1TcGFuID0gbGlzdEl0ZW0uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpKTtcclxuXHRcdFx0XHRsaXN0SXRlbVNwYW4uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gZGF0YXNldHNbMF0uYmFja2dyb3VuZENvbG9yW2ldO1xyXG5cdFx0XHRcdGlmIChsYWJlbHNbaV0pIHtcclxuXHRcdFx0XHRcdGxpc3RJdGVtLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsc1tpXSkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBsaXN0Lm91dGVySFRNTDtcclxuXHR9LFxyXG5cdGxlZ2VuZDoge1xyXG5cdFx0bGFiZWxzOiB7XHJcblx0XHRcdGdlbmVyYXRlTGFiZWxzOiBmdW5jdGlvbihjaGFydCkge1xyXG5cdFx0XHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcclxuXHRcdFx0XHRpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZGF0YS5sYWJlbHMubWFwKGZ1bmN0aW9uKGxhYmVsLCBpKSB7XHJcblx0XHRcdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XHJcblx0XHRcdFx0XHRcdHZhciBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZShpKTtcclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdFx0dGV4dDogbGFiZWwsXHJcblx0XHRcdFx0XHRcdFx0ZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXHJcblx0XHRcdFx0XHRcdFx0c3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxyXG5cdFx0XHRcdFx0XHRcdGxpbmVXaWR0aDogc3R5bGUuYm9yZGVyV2lkdGgsXHJcblx0XHRcdFx0XHRcdFx0aGlkZGVuOiBpc05hTihkYXRhLmRhdGFzZXRzWzBdLmRhdGFbaV0pIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4sXHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIEV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGNvcnJlY3QgaXRlbVxyXG5cdFx0XHRcdFx0XHRcdGluZGV4OiBpXHJcblx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIFtdO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdG9uQ2xpY2s6IGZ1bmN0aW9uKGUsIGxlZ2VuZEl0ZW0pIHtcclxuXHRcdFx0dmFyIGluZGV4ID0gbGVnZW5kSXRlbS5pbmRleDtcclxuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydDtcclxuXHRcdFx0dmFyIGksIGlsZW4sIG1ldGE7XHJcblxyXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcclxuXHRcdFx0XHQvLyB0b2dnbGUgdmlzaWJpbGl0eSBvZiBpbmRleCBpZiBleGlzdHNcclxuXHRcdFx0XHRpZiAobWV0YS5kYXRhW2luZGV4XSkge1xyXG5cdFx0XHRcdFx0bWV0YS5kYXRhW2luZGV4XS5oaWRkZW4gPSAhbWV0YS5kYXRhW2luZGV4XS5oaWRkZW47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjaGFydC51cGRhdGUoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBUaGUgcGVyY2VudGFnZSBvZiB0aGUgY2hhcnQgdGhhdCB3ZSBjdXQgb3V0IG9mIHRoZSBtaWRkbGUuXHJcblx0Y3V0b3V0UGVyY2VudGFnZTogNTAsXHJcblxyXG5cdC8vIFRoZSByb3RhdGlvbiBvZiB0aGUgY2hhcnQsIHdoZXJlIHRoZSBmaXJzdCBkYXRhIGFyYyBiZWdpbnMuXHJcblx0cm90YXRpb246IC1IQUxGX1BJJDEsXHJcblxyXG5cdC8vIFRoZSB0b3RhbCBjaXJjdW1mZXJlbmNlIG9mIHRoZSBjaGFydC5cclxuXHRjaXJjdW1mZXJlbmNlOiBET1VCTEVfUEkkMSxcclxuXHJcblx0Ly8gTmVlZCB0byBvdmVycmlkZSB0aGVzZSB0byBnaXZlIGEgbmljZSBkZWZhdWx0XHJcblx0dG9vbHRpcHM6IHtcclxuXHRcdGNhbGxiYWNrczoge1xyXG5cdFx0XHR0aXRsZTogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuICcnO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24odG9vbHRpcEl0ZW0sIGRhdGEpIHtcclxuXHRcdFx0XHR2YXIgZGF0YUxhYmVsID0gZGF0YS5sYWJlbHNbdG9vbHRpcEl0ZW0uaW5kZXhdO1xyXG5cdFx0XHRcdHZhciB2YWx1ZSA9ICc6ICcgKyBkYXRhLmRhdGFzZXRzW3Rvb2x0aXBJdGVtLmRhdGFzZXRJbmRleF0uZGF0YVt0b29sdGlwSXRlbS5pbmRleF07XHJcblxyXG5cdFx0XHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheShkYXRhTGFiZWwpKSB7XHJcblx0XHRcdFx0XHQvLyBzaG93IHZhbHVlIG9uIGZpcnN0IGxpbmUgb2YgbXVsdGlsaW5lIGxhYmVsXHJcblx0XHRcdFx0XHQvLyBuZWVkIHRvIGNsb25lIGJlY2F1c2Ugd2UgYXJlIGNoYW5naW5nIHRoZSB2YWx1ZVxyXG5cdFx0XHRcdFx0ZGF0YUxhYmVsID0gZGF0YUxhYmVsLnNsaWNlKCk7XHJcblx0XHRcdFx0XHRkYXRhTGFiZWxbMF0gKz0gdmFsdWU7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGRhdGFMYWJlbCArPSB2YWx1ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBkYXRhTGFiZWw7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxudmFyIGNvbnRyb2xsZXJfZG91Z2hudXQgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XHJcblxyXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuQXJjLFxyXG5cclxuXHRsaW5rU2NhbGVzOiBoZWxwZXJzJDEubm9vcCxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZGF0YUVsZW1lbnRPcHRpb25zOiBbXHJcblx0XHQnYmFja2dyb3VuZENvbG9yJyxcclxuXHRcdCdib3JkZXJDb2xvcicsXHJcblx0XHQnYm9yZGVyV2lkdGgnLFxyXG5cdFx0J2JvcmRlckFsaWduJyxcclxuXHRcdCdob3ZlckJhY2tncm91bmRDb2xvcicsXHJcblx0XHQnaG92ZXJCb3JkZXJDb2xvcicsXHJcblx0XHQnaG92ZXJCb3JkZXJXaWR0aCcsXHJcblx0XSxcclxuXHJcblx0Ly8gR2V0IGluZGV4IG9mIHRoZSBkYXRhc2V0IGluIHJlbGF0aW9uIHRvIHRoZSB2aXNpYmxlIGRhdGFzZXRzLiBUaGlzIGFsbG93cyBkZXRlcm1pbmluZyB0aGUgaW5uZXIgYW5kIG91dGVyIHJhZGl1cyBjb3JyZWN0bHlcclxuXHRnZXRSaW5nSW5kZXg6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xyXG5cdFx0dmFyIHJpbmdJbmRleCA9IDA7XHJcblxyXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkYXRhc2V0SW5kZXg7ICsraikge1xyXG5cdFx0XHRpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGopKSB7XHJcblx0XHRcdFx0KytyaW5nSW5kZXg7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmluZ0luZGV4O1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XHJcblx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XHJcblx0XHR2YXIgcmF0aW9YID0gMTtcclxuXHRcdHZhciByYXRpb1kgPSAxO1xyXG5cdFx0dmFyIG9mZnNldFggPSAwO1xyXG5cdFx0dmFyIG9mZnNldFkgPSAwO1xyXG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XHJcblx0XHR2YXIgYXJjcyA9IG1ldGEuZGF0YTtcclxuXHRcdHZhciBjdXRvdXQgPSBvcHRzLmN1dG91dFBlcmNlbnRhZ2UgLyAxMDAgfHwgMDtcclxuXHRcdHZhciBjaXJjdW1mZXJlbmNlID0gb3B0cy5jaXJjdW1mZXJlbmNlO1xyXG5cdFx0dmFyIGNoYXJ0V2VpZ2h0ID0gbWUuX2dldFJpbmdXZWlnaHQobWUuaW5kZXgpO1xyXG5cdFx0dmFyIG1heFdpZHRoLCBtYXhIZWlnaHQsIGksIGlsZW47XHJcblxyXG5cdFx0Ly8gSWYgdGhlIGNoYXJ0J3MgY2lyY3VtZmVyZW5jZSBpc24ndCBhIGZ1bGwgY2lyY2xlLCBjYWxjdWxhdGUgc2l6ZSBhcyBhIHJhdGlvIG9mIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIGFyY1xyXG5cdFx0aWYgKGNpcmN1bWZlcmVuY2UgPCBET1VCTEVfUEkkMSkge1xyXG5cdFx0XHR2YXIgc3RhcnRBbmdsZSA9IG9wdHMucm90YXRpb24gJSBET1VCTEVfUEkkMTtcclxuXHRcdFx0c3RhcnRBbmdsZSArPSBzdGFydEFuZ2xlID49IFBJJDEgPyAtRE9VQkxFX1BJJDEgOiBzdGFydEFuZ2xlIDwgLVBJJDEgPyBET1VCTEVfUEkkMSA6IDA7XHJcblx0XHRcdHZhciBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlO1xyXG5cdFx0XHR2YXIgc3RhcnRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XHJcblx0XHRcdHZhciBzdGFydFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcclxuXHRcdFx0dmFyIGVuZFggPSBNYXRoLmNvcyhlbmRBbmdsZSk7XHJcblx0XHRcdHZhciBlbmRZID0gTWF0aC5zaW4oZW5kQW5nbGUpO1xyXG5cdFx0XHR2YXIgY29udGFpbnMwID0gKHN0YXJ0QW5nbGUgPD0gMCAmJiBlbmRBbmdsZSA+PSAwKSB8fCBlbmRBbmdsZSA+PSBET1VCTEVfUEkkMTtcclxuXHRcdFx0dmFyIGNvbnRhaW5zOTAgPSAoc3RhcnRBbmdsZSA8PSBIQUxGX1BJJDEgJiYgZW5kQW5nbGUgPj0gSEFMRl9QSSQxKSB8fCBlbmRBbmdsZSA+PSBET1VCTEVfUEkkMSArIEhBTEZfUEkkMTtcclxuXHRcdFx0dmFyIGNvbnRhaW5zMTgwID0gc3RhcnRBbmdsZSA9PT0gLVBJJDEgfHwgZW5kQW5nbGUgPj0gUEkkMTtcclxuXHRcdFx0dmFyIGNvbnRhaW5zMjcwID0gKHN0YXJ0QW5nbGUgPD0gLUhBTEZfUEkkMSAmJiBlbmRBbmdsZSA+PSAtSEFMRl9QSSQxKSB8fCBlbmRBbmdsZSA+PSBQSSQxICsgSEFMRl9QSSQxO1xyXG5cdFx0XHR2YXIgbWluWCA9IGNvbnRhaW5zMTgwID8gLTEgOiBNYXRoLm1pbihzdGFydFgsIHN0YXJ0WCAqIGN1dG91dCwgZW5kWCwgZW5kWCAqIGN1dG91dCk7XHJcblx0XHRcdHZhciBtaW5ZID0gY29udGFpbnMyNzAgPyAtMSA6IE1hdGgubWluKHN0YXJ0WSwgc3RhcnRZICogY3V0b3V0LCBlbmRZLCBlbmRZICogY3V0b3V0KTtcclxuXHRcdFx0dmFyIG1heFggPSBjb250YWluczAgPyAxIDogTWF0aC5tYXgoc3RhcnRYLCBzdGFydFggKiBjdXRvdXQsIGVuZFgsIGVuZFggKiBjdXRvdXQpO1xyXG5cdFx0XHR2YXIgbWF4WSA9IGNvbnRhaW5zOTAgPyAxIDogTWF0aC5tYXgoc3RhcnRZLCBzdGFydFkgKiBjdXRvdXQsIGVuZFksIGVuZFkgKiBjdXRvdXQpO1xyXG5cdFx0XHRyYXRpb1ggPSAobWF4WCAtIG1pblgpIC8gMjtcclxuXHRcdFx0cmF0aW9ZID0gKG1heFkgLSBtaW5ZKSAvIDI7XHJcblx0XHRcdG9mZnNldFggPSAtKG1heFggKyBtaW5YKSAvIDI7XHJcblx0XHRcdG9mZnNldFkgPSAtKG1heFkgKyBtaW5ZKSAvIDI7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGFyY3NbaV0uX29wdGlvbnMgPSBtZS5fcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhhcmNzW2ldLCBpKTtcclxuXHRcdH1cclxuXHJcblx0XHRjaGFydC5ib3JkZXJXaWR0aCA9IG1lLmdldE1heEJvcmRlcldpZHRoKCk7XHJcblx0XHRtYXhXaWR0aCA9IChjaGFydEFyZWEucmlnaHQgLSBjaGFydEFyZWEubGVmdCAtIGNoYXJ0LmJvcmRlcldpZHRoKSAvIHJhdGlvWDtcclxuXHRcdG1heEhlaWdodCA9IChjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcCAtIGNoYXJ0LmJvcmRlcldpZHRoKSAvIHJhdGlvWTtcclxuXHRcdGNoYXJ0Lm91dGVyUmFkaXVzID0gTWF0aC5tYXgoTWF0aC5taW4obWF4V2lkdGgsIG1heEhlaWdodCkgLyAyLCAwKTtcclxuXHRcdGNoYXJ0LmlubmVyUmFkaXVzID0gTWF0aC5tYXgoY2hhcnQub3V0ZXJSYWRpdXMgKiBjdXRvdXQsIDApO1xyXG5cdFx0Y2hhcnQucmFkaXVzTGVuZ3RoID0gKGNoYXJ0Lm91dGVyUmFkaXVzIC0gY2hhcnQuaW5uZXJSYWRpdXMpIC8gKG1lLl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCkgfHwgMSk7XHJcblx0XHRjaGFydC5vZmZzZXRYID0gb2Zmc2V0WCAqIGNoYXJ0Lm91dGVyUmFkaXVzO1xyXG5cdFx0Y2hhcnQub2Zmc2V0WSA9IG9mZnNldFkgKiBjaGFydC5vdXRlclJhZGl1cztcclxuXHJcblx0XHRtZXRhLnRvdGFsID0gbWUuY2FsY3VsYXRlVG90YWwoKTtcclxuXHJcblx0XHRtZS5vdXRlclJhZGl1cyA9IGNoYXJ0Lm91dGVyUmFkaXVzIC0gY2hhcnQucmFkaXVzTGVuZ3RoICogbWUuX2dldFJpbmdXZWlnaHRPZmZzZXQobWUuaW5kZXgpO1xyXG5cdFx0bWUuaW5uZXJSYWRpdXMgPSBNYXRoLm1heChtZS5vdXRlclJhZGl1cyAtIGNoYXJ0LnJhZGl1c0xlbmd0aCAqIGNoYXJ0V2VpZ2h0LCAwKTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0bWUudXBkYXRlRWxlbWVudChhcmNzW2ldLCBpLCByZXNldCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24oYXJjLCBpbmRleCwgcmVzZXQpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XHJcblx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XHJcblx0XHR2YXIgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xyXG5cdFx0dmFyIGNlbnRlclggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMjtcclxuXHRcdHZhciBjZW50ZXJZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XHJcblx0XHR2YXIgc3RhcnRBbmdsZSA9IG9wdHMucm90YXRpb247IC8vIG5vbiByZXNldCBjYXNlIGhhbmRsZWQgbGF0ZXJcclxuXHRcdHZhciBlbmRBbmdsZSA9IG9wdHMucm90YXRpb247IC8vIG5vbiByZXNldCBjYXNlIGhhbmRsZWQgbGF0ZXJcclxuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xyXG5cdFx0dmFyIGNpcmN1bWZlcmVuY2UgPSByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUgPyAwIDogYXJjLmhpZGRlbiA/IDAgOiBtZS5jYWxjdWxhdGVDaXJjdW1mZXJlbmNlKGRhdGFzZXQuZGF0YVtpbmRleF0pICogKG9wdHMuY2lyY3VtZmVyZW5jZSAvIERPVUJMRV9QSSQxKTtcclxuXHRcdHZhciBpbm5lclJhZGl1cyA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlID8gMCA6IG1lLmlubmVyUmFkaXVzO1xyXG5cdFx0dmFyIG91dGVyUmFkaXVzID0gcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUgPyAwIDogbWUub3V0ZXJSYWRpdXM7XHJcblx0XHR2YXIgb3B0aW9ucyA9IGFyYy5fb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHRoZWxwZXJzJDEuZXh0ZW5kKGFyYywge1xyXG5cdFx0XHQvLyBVdGlsaXR5XHJcblx0XHRcdF9kYXRhc2V0SW5kZXg6IG1lLmluZGV4LFxyXG5cdFx0XHRfaW5kZXg6IGluZGV4LFxyXG5cclxuXHRcdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcclxuXHRcdFx0X21vZGVsOiB7XHJcblx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcclxuXHRcdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcclxuXHRcdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcclxuXHRcdFx0XHRib3JkZXJBbGlnbjogb3B0aW9ucy5ib3JkZXJBbGlnbixcclxuXHRcdFx0XHR4OiBjZW50ZXJYICsgY2hhcnQub2Zmc2V0WCxcclxuXHRcdFx0XHR5OiBjZW50ZXJZICsgY2hhcnQub2Zmc2V0WSxcclxuXHRcdFx0XHRzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxyXG5cdFx0XHRcdGVuZEFuZ2xlOiBlbmRBbmdsZSxcclxuXHRcdFx0XHRjaXJjdW1mZXJlbmNlOiBjaXJjdW1mZXJlbmNlLFxyXG5cdFx0XHRcdG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcclxuXHRcdFx0XHRpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXHJcblx0XHRcdFx0bGFiZWw6IGhlbHBlcnMkMS52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5sYWJlbCwgaW5kZXgsIGNoYXJ0LmRhdGEubGFiZWxzW2luZGV4XSlcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dmFyIG1vZGVsID0gYXJjLl9tb2RlbDtcclxuXHJcblx0XHQvLyBTZXQgY29ycmVjdCBhbmdsZXMgaWYgbm90IHJlc2V0dGluZ1xyXG5cdFx0aWYgKCFyZXNldCB8fCAhYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlKSB7XHJcblx0XHRcdGlmIChpbmRleCA9PT0gMCkge1xyXG5cdFx0XHRcdG1vZGVsLnN0YXJ0QW5nbGUgPSBvcHRzLnJvdGF0aW9uO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG1vZGVsLnN0YXJ0QW5nbGUgPSBtZS5nZXRNZXRhKCkuZGF0YVtpbmRleCAtIDFdLl9tb2RlbC5lbmRBbmdsZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bW9kZWwuZW5kQW5nbGUgPSBtb2RlbC5zdGFydEFuZ2xlICsgbW9kZWwuY2lyY3VtZmVyZW5jZTtcclxuXHRcdH1cclxuXHJcblx0XHRhcmMucGl2b3QoKTtcclxuXHR9LFxyXG5cclxuXHRjYWxjdWxhdGVUb3RhbDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xyXG5cdFx0dmFyIG1ldGEgPSB0aGlzLmdldE1ldGEoKTtcclxuXHRcdHZhciB0b3RhbCA9IDA7XHJcblx0XHR2YXIgdmFsdWU7XHJcblxyXG5cdFx0aGVscGVycyQxLmVhY2gobWV0YS5kYXRhLCBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xyXG5cdFx0XHR2YWx1ZSA9IGRhdGFzZXQuZGF0YVtpbmRleF07XHJcblx0XHRcdGlmICghaXNOYU4odmFsdWUpICYmICFlbGVtZW50LmhpZGRlbikge1xyXG5cdFx0XHRcdHRvdGFsICs9IE1hdGguYWJzKHZhbHVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0LyogaWYgKHRvdGFsID09PSAwKSB7XHJcblx0XHRcdHRvdGFsID0gTmFOO1xyXG5cdFx0fSovXHJcblxyXG5cdFx0cmV0dXJuIHRvdGFsO1xyXG5cdH0sXHJcblxyXG5cdGNhbGN1bGF0ZUNpcmN1bWZlcmVuY2U6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHR2YXIgdG90YWwgPSB0aGlzLmdldE1ldGEoKS50b3RhbDtcclxuXHRcdGlmICh0b3RhbCA+IDAgJiYgIWlzTmFOKHZhbHVlKSkge1xyXG5cdFx0XHRyZXR1cm4gRE9VQkxFX1BJJDEgKiAoTWF0aC5hYnModmFsdWUpIC8gdG90YWwpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIDA7XHJcblx0fSxcclxuXHJcblx0Ly8gZ2V0cyB0aGUgbWF4IGJvcmRlciBvciBob3ZlciB3aWR0aCB0byBwcm9wZXJseSBzY2FsZSBwaWUgY2hhcnRzXHJcblx0Z2V0TWF4Qm9yZGVyV2lkdGg6IGZ1bmN0aW9uKGFyY3MpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWF4ID0gMDtcclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIGksIGlsZW4sIG1ldGEsIGFyYywgY29udHJvbGxlciwgb3B0aW9ucywgYm9yZGVyV2lkdGgsIGhvdmVyV2lkdGg7XHJcblxyXG5cdFx0aWYgKCFhcmNzKSB7XHJcblx0XHRcdC8vIEZpbmQgdGhlIG91dG1vc3QgdmlzaWJsZSBkYXRhc2V0XHJcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XHJcblx0XHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XHJcblx0XHRcdFx0XHRhcmNzID0gbWV0YS5kYXRhO1xyXG5cdFx0XHRcdFx0aWYgKGkgIT09IG1lLmluZGV4KSB7XHJcblx0XHRcdFx0XHRcdGNvbnRyb2xsZXIgPSBtZXRhLmNvbnRyb2xsZXI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWFyY3MpIHtcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGFyYyA9IGFyY3NbaV07XHJcblx0XHRcdGlmIChjb250cm9sbGVyKSB7XHJcblx0XHRcdFx0Y29udHJvbGxlci5fY29uZmlndXJlKCk7XHJcblx0XHRcdFx0b3B0aW9ucyA9IGNvbnRyb2xsZXIuX3Jlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoYXJjLCBpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvcHRpb25zID0gYXJjLl9vcHRpb25zO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChvcHRpb25zLmJvcmRlckFsaWduICE9PSAnaW5uZXInKSB7XHJcblx0XHRcdFx0Ym9yZGVyV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xyXG5cdFx0XHRcdGhvdmVyV2lkdGggPSBvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGg7XHJcblxyXG5cdFx0XHRcdG1heCA9IGJvcmRlcldpZHRoID4gbWF4ID8gYm9yZGVyV2lkdGggOiBtYXg7XHJcblx0XHRcdFx0bWF4ID0gaG92ZXJXaWR0aCA+IG1heCA/IGhvdmVyV2lkdGggOiBtYXg7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBtYXg7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqL1xyXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKGFyYykge1xyXG5cdFx0dmFyIG1vZGVsID0gYXJjLl9tb2RlbDtcclxuXHRcdHZhciBvcHRpb25zID0gYXJjLl9vcHRpb25zO1xyXG5cdFx0dmFyIGdldEhvdmVyQ29sb3IgPSBoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvcjtcclxuXHJcblx0XHRhcmMuJHByZXZpb3VzU3R5bGUgPSB7XHJcblx0XHRcdGJhY2tncm91bmRDb2xvcjogbW9kZWwuYmFja2dyb3VuZENvbG9yLFxyXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXHJcblx0XHRcdGJvcmRlcldpZHRoOiBtb2RlbC5ib3JkZXJXaWR0aCxcclxuXHRcdH07XHJcblxyXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gdmFsdWVPckRlZmF1bHQkNShvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XHJcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDUob3B0aW9ucy5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpKTtcclxuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gdmFsdWVPckRlZmF1bHQkNShvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCByYWRpdXMgbGVuZ3RoIG9mZnNldCBvZiB0aGUgZGF0YXNldCBpbiByZWxhdGlvbiB0byB0aGUgdmlzaWJsZSBkYXRhc2V0cyB3ZWlnaHRzLiBUaGlzIGFsbG93cyBkZXRlcm1pbmluZyB0aGUgaW5uZXIgYW5kIG91dGVyIHJhZGl1cyBjb3JyZWN0bHlcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9nZXRSaW5nV2VpZ2h0T2Zmc2V0OiBmdW5jdGlvbihkYXRhc2V0SW5kZXgpIHtcclxuXHRcdHZhciByaW5nV2VpZ2h0T2Zmc2V0ID0gMDtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKSB7XHJcblx0XHRcdGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcclxuXHRcdFx0XHRyaW5nV2VpZ2h0T2Zmc2V0ICs9IHRoaXMuX2dldFJpbmdXZWlnaHQoaSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmluZ1dlaWdodE9mZnNldDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9nZXRSaW5nV2VpZ2h0OiBmdW5jdGlvbihkYXRhU2V0SW5kZXgpIHtcclxuXHRcdHJldHVybiBNYXRoLm1heCh2YWx1ZU9yRGVmYXVsdCQ1KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhU2V0SW5kZXhdLndlaWdodCwgMSksIDApO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHN1bSBvZiBhbGwgdmlzaWJpbGUgZGF0YSBzZXQgd2VpZ2h0cy4gIFRoaXMgdmFsdWUgY2FuIGJlIDAuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoKTtcclxuXHR9XHJcbn0pO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2hvcml6b250YWxCYXInLCB7XHJcblx0aG92ZXI6IHtcclxuXHRcdG1vZGU6ICdpbmRleCcsXHJcblx0XHRheGlzOiAneSdcclxuXHR9LFxyXG5cclxuXHRzY2FsZXM6IHtcclxuXHRcdHhBeGVzOiBbe1xyXG5cdFx0XHR0eXBlOiAnbGluZWFyJyxcclxuXHRcdFx0cG9zaXRpb246ICdib3R0b20nXHJcblx0XHR9XSxcclxuXHJcblx0XHR5QXhlczogW3tcclxuXHRcdFx0dHlwZTogJ2NhdGVnb3J5JyxcclxuXHRcdFx0cG9zaXRpb246ICdsZWZ0JyxcclxuXHRcdFx0b2Zmc2V0OiB0cnVlLFxyXG5cdFx0XHRncmlkTGluZXM6IHtcclxuXHRcdFx0XHRvZmZzZXRHcmlkTGluZXM6IHRydWVcclxuXHRcdFx0fVxyXG5cdFx0fV1cclxuXHR9LFxyXG5cclxuXHRlbGVtZW50czoge1xyXG5cdFx0cmVjdGFuZ2xlOiB7XHJcblx0XHRcdGJvcmRlclNraXBwZWQ6ICdsZWZ0J1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHRvb2x0aXBzOiB7XHJcblx0XHRtb2RlOiAnaW5kZXgnLFxyXG5cdFx0YXhpczogJ3knXHJcblx0fVxyXG59KTtcclxuXHJcbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xyXG5cdGRhdGFzZXRzOiB7XHJcblx0XHRob3Jpem9udGFsQmFyOiB7XHJcblx0XHRcdGNhdGVnb3J5UGVyY2VudGFnZTogMC44LFxyXG5cdFx0XHRiYXJQZXJjZW50YWdlOiAwLjlcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxudmFyIGNvbnRyb2xsZXJfaG9yaXpvbnRhbEJhciA9IGNvbnRyb2xsZXJfYmFyLmV4dGVuZCh7XHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZ2V0VmFsdWVTY2FsZUlkOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldE1ldGEoKS54QXhpc0lEO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldEluZGV4U2NhbGVJZDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRNZXRhKCkueUF4aXNJRDtcclxuXHR9XHJcbn0pO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkNiA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcclxudmFyIHJlc29sdmUkMiA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XHJcbnZhciBpc1BvaW50SW5BcmVhID0gaGVscGVycyQxLmNhbnZhcy5faXNQb2ludEluQXJlYTtcclxuXHJcbmNvcmVfZGVmYXVsdHMuX3NldCgnbGluZScsIHtcclxuXHRzaG93TGluZXM6IHRydWUsXHJcblx0c3BhbkdhcHM6IGZhbHNlLFxyXG5cclxuXHRob3Zlcjoge1xyXG5cdFx0bW9kZTogJ2xhYmVsJ1xyXG5cdH0sXHJcblxyXG5cdHNjYWxlczoge1xyXG5cdFx0eEF4ZXM6IFt7XHJcblx0XHRcdHR5cGU6ICdjYXRlZ29yeScsXHJcblx0XHRcdGlkOiAneC1heGlzLTAnXHJcblx0XHR9XSxcclxuXHRcdHlBeGVzOiBbe1xyXG5cdFx0XHR0eXBlOiAnbGluZWFyJyxcclxuXHRcdFx0aWQ6ICd5LWF4aXMtMCdcclxuXHRcdH1dXHJcblx0fVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIHNjYWxlQ2xpcChzY2FsZSwgaGFsZkJvcmRlcldpZHRoKSB7XHJcblx0dmFyIHRpY2tPcHRzID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucy50aWNrcyB8fCB7fTtcclxuXHR2YXIgcmV2ZXJzZSA9IHRpY2tPcHRzLnJldmVyc2U7XHJcblx0dmFyIG1pbiA9IHRpY2tPcHRzLm1pbiA9PT0gdW5kZWZpbmVkID8gaGFsZkJvcmRlcldpZHRoIDogMDtcclxuXHR2YXIgbWF4ID0gdGlja09wdHMubWF4ID09PSB1bmRlZmluZWQgPyBoYWxmQm9yZGVyV2lkdGggOiAwO1xyXG5cdHJldHVybiB7XHJcblx0XHRzdGFydDogcmV2ZXJzZSA/IG1heCA6IG1pbixcclxuXHRcdGVuZDogcmV2ZXJzZSA/IG1pbiA6IG1heFxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRDbGlwKHhTY2FsZSwgeVNjYWxlLCBib3JkZXJXaWR0aCkge1xyXG5cdHZhciBoYWxmQm9yZGVyV2lkdGggPSBib3JkZXJXaWR0aCAvIDI7XHJcblx0dmFyIHggPSBzY2FsZUNsaXAoeFNjYWxlLCBoYWxmQm9yZGVyV2lkdGgpO1xyXG5cdHZhciB5ID0gc2NhbGVDbGlwKHlTY2FsZSwgaGFsZkJvcmRlcldpZHRoKTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHRvcDogeS5lbmQsXHJcblx0XHRyaWdodDogeC5lbmQsXHJcblx0XHRib3R0b206IHkuc3RhcnQsXHJcblx0XHRsZWZ0OiB4LnN0YXJ0XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gdG9DbGlwKHZhbHVlKSB7XHJcblx0dmFyIHQsIHIsIGIsIGw7XHJcblxyXG5cdGlmIChoZWxwZXJzJDEuaXNPYmplY3QodmFsdWUpKSB7XHJcblx0XHR0ID0gdmFsdWUudG9wO1xyXG5cdFx0ciA9IHZhbHVlLnJpZ2h0O1xyXG5cdFx0YiA9IHZhbHVlLmJvdHRvbTtcclxuXHRcdGwgPSB2YWx1ZS5sZWZ0O1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0ID0gciA9IGIgPSBsID0gdmFsdWU7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0dG9wOiB0LFxyXG5cdFx0cmlnaHQ6IHIsXHJcblx0XHRib3R0b206IGIsXHJcblx0XHRsZWZ0OiBsXHJcblx0fTtcclxufVxyXG5cclxuXHJcbnZhciBjb250cm9sbGVyX2xpbmUgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XHJcblxyXG5cdGRhdGFzZXRFbGVtZW50VHlwZTogZWxlbWVudHMuTGluZSxcclxuXHJcblx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5Qb2ludCxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZGF0YXNldEVsZW1lbnRPcHRpb25zOiBbXHJcblx0XHQnYmFja2dyb3VuZENvbG9yJyxcclxuXHRcdCdib3JkZXJDYXBTdHlsZScsXHJcblx0XHQnYm9yZGVyQ29sb3InLFxyXG5cdFx0J2JvcmRlckRhc2gnLFxyXG5cdFx0J2JvcmRlckRhc2hPZmZzZXQnLFxyXG5cdFx0J2JvcmRlckpvaW5TdHlsZScsXHJcblx0XHQnYm9yZGVyV2lkdGgnLFxyXG5cdFx0J2N1YmljSW50ZXJwb2xhdGlvbk1vZGUnLFxyXG5cdFx0J2ZpbGwnXHJcblx0XSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZGF0YUVsZW1lbnRPcHRpb25zOiB7XHJcblx0XHRiYWNrZ3JvdW5kQ29sb3I6ICdwb2ludEJhY2tncm91bmRDb2xvcicsXHJcblx0XHRib3JkZXJDb2xvcjogJ3BvaW50Qm9yZGVyQ29sb3InLFxyXG5cdFx0Ym9yZGVyV2lkdGg6ICdwb2ludEJvcmRlcldpZHRoJyxcclxuXHRcdGhpdFJhZGl1czogJ3BvaW50SGl0UmFkaXVzJyxcclxuXHRcdGhvdmVyQmFja2dyb3VuZENvbG9yOiAncG9pbnRIb3ZlckJhY2tncm91bmRDb2xvcicsXHJcblx0XHRob3ZlckJvcmRlckNvbG9yOiAncG9pbnRIb3ZlckJvcmRlckNvbG9yJyxcclxuXHRcdGhvdmVyQm9yZGVyV2lkdGg6ICdwb2ludEhvdmVyQm9yZGVyV2lkdGgnLFxyXG5cdFx0aG92ZXJSYWRpdXM6ICdwb2ludEhvdmVyUmFkaXVzJyxcclxuXHRcdHBvaW50U3R5bGU6ICdwb2ludFN0eWxlJyxcclxuXHRcdHJhZGl1czogJ3BvaW50UmFkaXVzJyxcclxuXHRcdHJvdGF0aW9uOiAncG9pbnRSb3RhdGlvbidcclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XHJcblx0XHR2YXIgbGluZSA9IG1ldGEuZGF0YXNldDtcclxuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XHJcblx0XHR2YXIgb3B0aW9ucyA9IG1lLmNoYXJ0Lm9wdGlvbnM7XHJcblx0XHR2YXIgY29uZmlnID0gbWUuX2NvbmZpZztcclxuXHRcdHZhciBzaG93TGluZSA9IG1lLl9zaG93TGluZSA9IHZhbHVlT3JEZWZhdWx0JDYoY29uZmlnLnNob3dMaW5lLCBvcHRpb25zLnNob3dMaW5lcyk7XHJcblx0XHR2YXIgaSwgaWxlbjtcclxuXHJcblx0XHRtZS5feFNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnhBeGlzSUQpO1xyXG5cdFx0bWUuX3lTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcclxuXHJcblx0XHQvLyBVcGRhdGUgTGluZVxyXG5cdFx0aWYgKHNob3dMaW5lKSB7XHJcblx0XHRcdC8vIENvbXBhdGliaWxpdHk6IElmIHRoZSBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIHdpdGggb25seSB0aGUgb2xkIG5hbWUsIHVzZSB0aG9zZSB2YWx1ZXNcclxuXHRcdFx0aWYgKGNvbmZpZy50ZW5zaW9uICE9PSB1bmRlZmluZWQgJiYgY29uZmlnLmxpbmVUZW5zaW9uID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRjb25maWcubGluZVRlbnNpb24gPSBjb25maWcudGVuc2lvbjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gVXRpbGl0eVxyXG5cdFx0XHRsaW5lLl9zY2FsZSA9IG1lLl95U2NhbGU7XHJcblx0XHRcdGxpbmUuX2RhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xyXG5cdFx0XHQvLyBEYXRhXHJcblx0XHRcdGxpbmUuX2NoaWxkcmVuID0gcG9pbnRzO1xyXG5cdFx0XHQvLyBNb2RlbFxyXG5cdFx0XHRsaW5lLl9tb2RlbCA9IG1lLl9yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKGxpbmUpO1xyXG5cclxuXHRcdFx0bGluZS5waXZvdCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFVwZGF0ZSBQb2ludHNcclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQocG9pbnRzW2ldLCBpLCByZXNldCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHNob3dMaW5lICYmIGxpbmUuX21vZGVsLnRlbnNpb24gIT09IDApIHtcclxuXHRcdFx0bWUudXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE5vdyBwaXZvdCB0aGUgcG9pbnQgZm9yIGFuaW1hdGlvblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0cG9pbnRzW2ldLnBpdm90KCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24ocG9pbnQsIGluZGV4LCByZXNldCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xyXG5cdFx0dmFyIGN1c3RvbSA9IHBvaW50LmN1c3RvbSB8fCB7fTtcclxuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xyXG5cdFx0dmFyIGRhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xyXG5cdFx0dmFyIHZhbHVlID0gZGF0YXNldC5kYXRhW2luZGV4XTtcclxuXHRcdHZhciB4U2NhbGUgPSBtZS5feFNjYWxlO1xyXG5cdFx0dmFyIHlTY2FsZSA9IG1lLl95U2NhbGU7XHJcblx0XHR2YXIgbGluZU1vZGVsID0gbWV0YS5kYXRhc2V0Ll9tb2RlbDtcclxuXHRcdHZhciB4LCB5O1xyXG5cclxuXHRcdHZhciBvcHRpb25zID0gbWUuX3Jlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMocG9pbnQsIGluZGV4KTtcclxuXHJcblx0XHR4ID0geFNjYWxlLmdldFBpeGVsRm9yVmFsdWUodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IHZhbHVlIDogTmFOLCBpbmRleCwgZGF0YXNldEluZGV4KTtcclxuXHRcdHkgPSByZXNldCA/IHlTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IG1lLmNhbGN1bGF0ZVBvaW50WSh2YWx1ZSwgaW5kZXgsIGRhdGFzZXRJbmRleCk7XHJcblxyXG5cdFx0Ly8gVXRpbGl0eVxyXG5cdFx0cG9pbnQuX3hTY2FsZSA9IHhTY2FsZTtcclxuXHRcdHBvaW50Ll95U2NhbGUgPSB5U2NhbGU7XHJcblx0XHRwb2ludC5fb3B0aW9ucyA9IG9wdGlvbnM7XHJcblx0XHRwb2ludC5fZGF0YXNldEluZGV4ID0gZGF0YXNldEluZGV4O1xyXG5cdFx0cG9pbnQuX2luZGV4ID0gaW5kZXg7XHJcblxyXG5cdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcclxuXHRcdHBvaW50Ll9tb2RlbCA9IHtcclxuXHRcdFx0eDogeCxcclxuXHRcdFx0eTogeSxcclxuXHRcdFx0c2tpcDogY3VzdG9tLnNraXAgfHwgaXNOYU4oeCkgfHwgaXNOYU4oeSksXHJcblx0XHRcdC8vIEFwcGVhcmFuY2VcclxuXHRcdFx0cmFkaXVzOiBvcHRpb25zLnJhZGl1cyxcclxuXHRcdFx0cG9pbnRTdHlsZTogb3B0aW9ucy5wb2ludFN0eWxlLFxyXG5cdFx0XHRyb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcclxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcclxuXHRcdFx0Ym9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXHJcblx0XHRcdGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxyXG5cdFx0XHR0ZW5zaW9uOiB2YWx1ZU9yRGVmYXVsdCQ2KGN1c3RvbS50ZW5zaW9uLCBsaW5lTW9kZWwgPyBsaW5lTW9kZWwudGVuc2lvbiA6IDApLFxyXG5cdFx0XHRzdGVwcGVkTGluZTogbGluZU1vZGVsID8gbGluZU1vZGVsLnN0ZXBwZWRMaW5lIDogZmFsc2UsXHJcblx0XHRcdC8vIFRvb2x0aXBcclxuXHRcdFx0aGl0UmFkaXVzOiBvcHRpb25zLmhpdFJhZGl1c1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zOiBmdW5jdGlvbihlbGVtZW50KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGNvbmZpZyA9IG1lLl9jb25maWc7XHJcblx0XHR2YXIgY3VzdG9tID0gZWxlbWVudC5jdXN0b20gfHwge307XHJcblx0XHR2YXIgb3B0aW9ucyA9IG1lLmNoYXJ0Lm9wdGlvbnM7XHJcblx0XHR2YXIgbGluZU9wdGlvbnMgPSBvcHRpb25zLmVsZW1lbnRzLmxpbmU7XHJcblx0XHR2YXIgdmFsdWVzID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUuX3Jlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMuYXBwbHkobWUsIGFyZ3VtZW50cyk7XHJcblxyXG5cdFx0Ly8gVGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgbGluZXMgaXMgdG8gYnJlYWsgYXQgbnVsbCB2YWx1ZXMsIGFjY29yZGluZ1xyXG5cdFx0Ly8gdG8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI0MzUjaXNzdWVjb21tZW50LTIxNjcxODE1OFxyXG5cdFx0Ly8gVGhpcyBvcHRpb24gZ2l2ZXMgbGluZXMgdGhlIGFiaWxpdHkgdG8gc3BhbiBnYXBzXHJcblx0XHR2YWx1ZXMuc3BhbkdhcHMgPSB2YWx1ZU9yRGVmYXVsdCQ2KGNvbmZpZy5zcGFuR2Fwcywgb3B0aW9ucy5zcGFuR2Fwcyk7XHJcblx0XHR2YWx1ZXMudGVuc2lvbiA9IHZhbHVlT3JEZWZhdWx0JDYoY29uZmlnLmxpbmVUZW5zaW9uLCBsaW5lT3B0aW9ucy50ZW5zaW9uKTtcclxuXHRcdHZhbHVlcy5zdGVwcGVkTGluZSA9IHJlc29sdmUkMihbY3VzdG9tLnN0ZXBwZWRMaW5lLCBjb25maWcuc3RlcHBlZExpbmUsIGxpbmVPcHRpb25zLnN0ZXBwZWRdKTtcclxuXHRcdHZhbHVlcy5jbGlwID0gdG9DbGlwKHZhbHVlT3JEZWZhdWx0JDYoY29uZmlnLmNsaXAsIGRlZmF1bHRDbGlwKG1lLl94U2NhbGUsIG1lLl95U2NhbGUsIHZhbHVlcy5ib3JkZXJXaWR0aCkpKTtcclxuXHJcblx0XHRyZXR1cm4gdmFsdWVzO1xyXG5cdH0sXHJcblxyXG5cdGNhbGN1bGF0ZVBvaW50WTogZnVuY3Rpb24odmFsdWUsIGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciB5U2NhbGUgPSBtZS5feVNjYWxlO1xyXG5cdFx0dmFyIHN1bVBvcyA9IDA7XHJcblx0XHR2YXIgc3VtTmVnID0gMDtcclxuXHRcdHZhciBpLCBkcywgZHNNZXRhLCBzdGFja2VkUmlnaHRWYWx1ZSwgcmlnaHRWYWx1ZSwgbWV0YXNldHMsIGlsZW47XHJcblxyXG5cdFx0aWYgKHlTY2FsZS5vcHRpb25zLnN0YWNrZWQpIHtcclxuXHRcdFx0cmlnaHRWYWx1ZSA9ICt5U2NhbGUuZ2V0UmlnaHRWYWx1ZSh2YWx1ZSk7XHJcblx0XHRcdG1ldGFzZXRzID0gY2hhcnQuX2dldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcclxuXHRcdFx0aWxlbiA9IG1ldGFzZXRzLmxlbmd0aDtcclxuXHJcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0XHRkc01ldGEgPSBtZXRhc2V0c1tpXTtcclxuXHRcdFx0XHRpZiAoZHNNZXRhLmluZGV4ID09PSBkYXRhc2V0SW5kZXgpIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzW2RzTWV0YS5pbmRleF07XHJcblx0XHRcdFx0aWYgKGRzTWV0YS50eXBlID09PSAnbGluZScgJiYgZHNNZXRhLnlBeGlzSUQgPT09IHlTY2FsZS5pZCkge1xyXG5cdFx0XHRcdFx0c3RhY2tlZFJpZ2h0VmFsdWUgPSAreVNjYWxlLmdldFJpZ2h0VmFsdWUoZHMuZGF0YVtpbmRleF0pO1xyXG5cdFx0XHRcdFx0aWYgKHN0YWNrZWRSaWdodFZhbHVlIDwgMCkge1xyXG5cdFx0XHRcdFx0XHRzdW1OZWcgKz0gc3RhY2tlZFJpZ2h0VmFsdWUgfHwgMDtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHN1bVBvcyArPSBzdGFja2VkUmlnaHRWYWx1ZSB8fCAwO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHJpZ2h0VmFsdWUgPCAwKSB7XHJcblx0XHRcdFx0cmV0dXJuIHlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN1bU5lZyArIHJpZ2h0VmFsdWUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB5U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdW1Qb3MgKyByaWdodFZhbHVlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB5U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlQmV6aWVyQ29udHJvbFBvaW50czogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XHJcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcclxuXHRcdHZhciBsaW5lTW9kZWwgPSBtZXRhLmRhdGFzZXQuX21vZGVsO1xyXG5cdFx0dmFyIGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XHJcblx0XHR2YXIgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xyXG5cdFx0dmFyIGksIGlsZW4sIG1vZGVsLCBjb250cm9sUG9pbnRzO1xyXG5cclxuXHRcdC8vIE9ubHkgY29uc2lkZXIgcG9pbnRzIHRoYXQgYXJlIGRyYXduIGluIGNhc2UgdGhlIHNwYW5HYXBzIG9wdGlvbiBpcyB1c2VkXHJcblx0XHRpZiAobGluZU1vZGVsLnNwYW5HYXBzKSB7XHJcblx0XHRcdHBvaW50cyA9IHBvaW50cy5maWx0ZXIoZnVuY3Rpb24ocHQpIHtcclxuXHRcdFx0XHRyZXR1cm4gIXB0Ll9tb2RlbC5za2lwO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQsIG1pbiwgbWF4KSB7XHJcblx0XHRcdHJldHVybiBNYXRoLm1heChNYXRoLm1pbihwdCwgbWF4KSwgbWluKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGluZU1vZGVsLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcclxuXHRcdFx0aGVscGVycyQxLnNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdFx0bW9kZWwgPSBwb2ludHNbaV0uX21vZGVsO1xyXG5cdFx0XHRcdGNvbnRyb2xQb2ludHMgPSBoZWxwZXJzJDEuc3BsaW5lQ3VydmUoXHJcblx0XHRcdFx0XHRoZWxwZXJzJDEucHJldmlvdXNJdGVtKHBvaW50cywgaSkuX21vZGVsLFxyXG5cdFx0XHRcdFx0bW9kZWwsXHJcblx0XHRcdFx0XHRoZWxwZXJzJDEubmV4dEl0ZW0ocG9pbnRzLCBpKS5fbW9kZWwsXHJcblx0XHRcdFx0XHRsaW5lTW9kZWwudGVuc2lvblxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYID0gY29udHJvbFBvaW50cy5wcmV2aW91cy54O1xyXG5cdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueTtcclxuXHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WCA9IGNvbnRyb2xQb2ludHMubmV4dC54O1xyXG5cdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRZID0gY29udHJvbFBvaW50cy5uZXh0Lnk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY2hhcnQub3B0aW9ucy5lbGVtZW50cy5saW5lLmNhcEJlemllclBvaW50cykge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRcdG1vZGVsID0gcG9pbnRzW2ldLl9tb2RlbDtcclxuXHRcdFx0XHRpZiAoaXNQb2ludEluQXJlYShtb2RlbCwgYXJlYSkpIHtcclxuXHRcdFx0XHRcdGlmIChpID4gMCAmJiBpc1BvaW50SW5BcmVhKHBvaW50c1tpIC0gMV0uX21vZGVsLCBhcmVhKSkge1xyXG5cdFx0XHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ggPSBjYXBDb250cm9sUG9pbnQobW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYLCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xyXG5cdFx0XHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1kgPSBjYXBDb250cm9sUG9pbnQobW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZLCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKGkgPCBwb2ludHMubGVuZ3RoIC0gMSAmJiBpc1BvaW50SW5BcmVhKHBvaW50c1tpICsgMV0uX21vZGVsLCBhcmVhKSkge1xyXG5cdFx0XHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WCA9IGNhcENvbnRyb2xQb2ludChtb2RlbC5jb250cm9sUG9pbnROZXh0WCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcclxuXHRcdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBjYXBDb250cm9sUG9pbnQobW9kZWwuY29udHJvbFBvaW50TmV4dFksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0ZHJhdzogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XHJcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcclxuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XHJcblx0XHR2YXIgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcclxuXHRcdHZhciBjYW52YXMgPSBjaGFydC5jYW52YXM7XHJcblx0XHR2YXIgaSA9IDA7XHJcblx0XHR2YXIgaWxlbiA9IHBvaW50cy5sZW5ndGg7XHJcblx0XHR2YXIgY2xpcDtcclxuXHJcblx0XHRpZiAobWUuX3Nob3dMaW5lKSB7XHJcblx0XHRcdGNsaXAgPSBtZXRhLmRhdGFzZXQuX21vZGVsLmNsaXA7XHJcblxyXG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLmNsaXBBcmVhKGNoYXJ0LmN0eCwge1xyXG5cdFx0XHRcdGxlZnQ6IGNsaXAubGVmdCA9PT0gZmFsc2UgPyAwIDogYXJlYS5sZWZ0IC0gY2xpcC5sZWZ0LFxyXG5cdFx0XHRcdHJpZ2h0OiBjbGlwLnJpZ2h0ID09PSBmYWxzZSA/IGNhbnZhcy53aWR0aCA6IGFyZWEucmlnaHQgKyBjbGlwLnJpZ2h0LFxyXG5cdFx0XHRcdHRvcDogY2xpcC50b3AgPT09IGZhbHNlID8gMCA6IGFyZWEudG9wIC0gY2xpcC50b3AsXHJcblx0XHRcdFx0Ym90dG9tOiBjbGlwLmJvdHRvbSA9PT0gZmFsc2UgPyBjYW52YXMuaGVpZ2h0IDogYXJlYS5ib3R0b20gKyBjbGlwLmJvdHRvbVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdG1ldGEuZGF0YXNldC5kcmF3KCk7XHJcblxyXG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLnVuY2xpcEFyZWEoY2hhcnQuY3R4KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBEcmF3IHRoZSBwb2ludHNcclxuXHRcdGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdHBvaW50c1tpXS5kcmF3KGFyZWEpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKi9cclxuXHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihwb2ludCkge1xyXG5cdFx0dmFyIG1vZGVsID0gcG9pbnQuX21vZGVsO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBwb2ludC5fb3B0aW9ucztcclxuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XHJcblxyXG5cdFx0cG9pbnQuJHByZXZpb3VzU3R5bGUgPSB7XHJcblx0XHRcdGJhY2tncm91bmRDb2xvcjogbW9kZWwuYmFja2dyb3VuZENvbG9yLFxyXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXHJcblx0XHRcdGJvcmRlcldpZHRoOiBtb2RlbC5ib3JkZXJXaWR0aCxcclxuXHRcdFx0cmFkaXVzOiBtb2RlbC5yYWRpdXNcclxuXHRcdH07XHJcblxyXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gdmFsdWVPckRlZmF1bHQkNihvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XHJcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDYob3B0aW9ucy5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpKTtcclxuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gdmFsdWVPckRlZmF1bHQkNihvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xyXG5cdFx0bW9kZWwucmFkaXVzID0gdmFsdWVPckRlZmF1bHQkNihvcHRpb25zLmhvdmVyUmFkaXVzLCBvcHRpb25zLnJhZGl1cyk7XHJcblx0fSxcclxufSk7XG5cbnZhciByZXNvbHZlJDMgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xyXG5cclxuY29yZV9kZWZhdWx0cy5fc2V0KCdwb2xhckFyZWEnLCB7XHJcblx0c2NhbGU6IHtcclxuXHRcdHR5cGU6ICdyYWRpYWxMaW5lYXInLFxyXG5cdFx0YW5nbGVMaW5lczoge1xyXG5cdFx0XHRkaXNwbGF5OiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdGdyaWRMaW5lczoge1xyXG5cdFx0XHRjaXJjdWxhcjogdHJ1ZVxyXG5cdFx0fSxcclxuXHRcdHBvaW50TGFiZWxzOiB7XHJcblx0XHRcdGRpc3BsYXk6IGZhbHNlXHJcblx0XHR9LFxyXG5cdFx0dGlja3M6IHtcclxuXHRcdFx0YmVnaW5BdFplcm86IHRydWVcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBCb29sZWFuIC0gV2hldGhlciB0byBhbmltYXRlIHRoZSByb3RhdGlvbiBvZiB0aGUgY2hhcnRcclxuXHRhbmltYXRpb246IHtcclxuXHRcdGFuaW1hdGVSb3RhdGU6IHRydWUsXHJcblx0XHRhbmltYXRlU2NhbGU6IHRydWVcclxuXHR9LFxyXG5cclxuXHRzdGFydEFuZ2xlOiAtMC41ICogTWF0aC5QSSxcclxuXHRsZWdlbmRDYWxsYmFjazogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdHZhciBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcclxuXHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcclxuXHRcdHZhciBkYXRhc2V0cyA9IGRhdGEuZGF0YXNldHM7XHJcblx0XHR2YXIgbGFiZWxzID0gZGF0YS5sYWJlbHM7XHJcblx0XHR2YXIgaSwgaWxlbiwgbGlzdEl0ZW0sIGxpc3RJdGVtU3BhbjtcclxuXHJcblx0XHRsaXN0LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjaGFydC5pZCArICctbGVnZW5kJyk7XHJcblx0XHRpZiAoZGF0YXNldHMubGVuZ3RoKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0c1swXS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRcdGxpc3RJdGVtID0gbGlzdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpKTtcclxuXHRcdFx0XHRsaXN0SXRlbVNwYW4gPSBsaXN0SXRlbS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJykpO1xyXG5cdFx0XHRcdGxpc3RJdGVtU3Bhbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBkYXRhc2V0c1swXS5iYWNrZ3JvdW5kQ29sb3JbaV07XHJcblx0XHRcdFx0aWYgKGxhYmVsc1tpXSkge1xyXG5cdFx0XHRcdFx0bGlzdEl0ZW0uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWxzW2ldKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGxpc3Qub3V0ZXJIVE1MO1xyXG5cdH0sXHJcblx0bGVnZW5kOiB7XHJcblx0XHRsYWJlbHM6IHtcclxuXHRcdFx0Z2VuZXJhdGVMYWJlbHM6IGZ1bmN0aW9uKGNoYXJ0KSB7XHJcblx0XHRcdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xyXG5cdFx0XHRcdGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdHJldHVybiBkYXRhLmxhYmVscy5tYXAoZnVuY3Rpb24obGFiZWwsIGkpIHtcclxuXHRcdFx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcclxuXHRcdFx0XHRcdFx0dmFyIHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdFx0XHR0ZXh0OiBsYWJlbCxcclxuXHRcdFx0XHRcdFx0XHRmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcclxuXHRcdFx0XHRcdFx0XHRzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXHJcblx0XHRcdFx0XHRcdFx0bGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcclxuXHRcdFx0XHRcdFx0XHRoaWRkZW46IGlzTmFOKGRhdGEuZGF0YXNldHNbMF0uZGF0YVtpXSkgfHwgbWV0YS5kYXRhW2ldLmhpZGRlbixcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gRXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgY29ycmVjdCBpdGVtXHJcblx0XHRcdFx0XHRcdFx0aW5kZXg6IGlcclxuXHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gW107XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0b25DbGljazogZnVuY3Rpb24oZSwgbGVnZW5kSXRlbSkge1xyXG5cdFx0XHR2YXIgaW5kZXggPSBsZWdlbmRJdGVtLmluZGV4O1xyXG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xyXG5cdFx0XHR2YXIgaSwgaWxlbiwgbWV0YTtcclxuXHJcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xyXG5cdFx0XHRcdG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuID0gIW1ldGEuZGF0YVtpbmRleF0uaGlkZGVuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjaGFydC51cGRhdGUoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBOZWVkIHRvIG92ZXJyaWRlIHRoZXNlIHRvIGdpdmUgYSBuaWNlIGRlZmF1bHRcclxuXHR0b29sdGlwczoge1xyXG5cdFx0Y2FsbGJhY2tzOiB7XHJcblx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gJyc7XHJcblx0XHRcdH0sXHJcblx0XHRcdGxhYmVsOiBmdW5jdGlvbihpdGVtLCBkYXRhKSB7XHJcblx0XHRcdFx0cmV0dXJuIGRhdGEubGFiZWxzW2l0ZW0uaW5kZXhdICsgJzogJyArIGl0ZW0ueUxhYmVsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbnZhciBjb250cm9sbGVyX3BvbGFyQXJlYSA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcclxuXHJcblx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5BcmMsXHJcblxyXG5cdGxpbmtTY2FsZXM6IGhlbHBlcnMkMS5ub29wLFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9kYXRhRWxlbWVudE9wdGlvbnM6IFtcclxuXHRcdCdiYWNrZ3JvdW5kQ29sb3InLFxyXG5cdFx0J2JvcmRlckNvbG9yJyxcclxuXHRcdCdib3JkZXJXaWR0aCcsXHJcblx0XHQnYm9yZGVyQWxpZ24nLFxyXG5cdFx0J2hvdmVyQmFja2dyb3VuZENvbG9yJyxcclxuXHRcdCdob3ZlckJvcmRlckNvbG9yJyxcclxuXHRcdCdob3ZlckJvcmRlcldpZHRoJyxcclxuXHRdLFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9nZXRJbmRleFNjYWxlSWQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQuc2NhbGUuaWQ7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZ2V0VmFsdWVTY2FsZUlkOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmNoYXJ0LnNjYWxlLmlkO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcclxuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xyXG5cdFx0dmFyIHN0YXJ0ID0gbWUuY2hhcnQub3B0aW9ucy5zdGFydEFuZ2xlIHx8IDA7XHJcblx0XHR2YXIgc3RhcnRzID0gbWUuX3N0YXJ0cyA9IFtdO1xyXG5cdFx0dmFyIGFuZ2xlcyA9IG1lLl9hbmdsZXMgPSBbXTtcclxuXHRcdHZhciBhcmNzID0gbWV0YS5kYXRhO1xyXG5cdFx0dmFyIGksIGlsZW4sIGFuZ2xlO1xyXG5cclxuXHRcdG1lLl91cGRhdGVSYWRpdXMoKTtcclxuXHJcblx0XHRtZXRhLmNvdW50ID0gbWUuY291bnRWaXNpYmxlRWxlbWVudHMoKTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldC5kYXRhLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xyXG5cdFx0XHRzdGFydHNbaV0gPSBzdGFydDtcclxuXHRcdFx0YW5nbGUgPSBtZS5fY29tcHV0ZUFuZ2xlKGkpO1xyXG5cdFx0XHRhbmdsZXNbaV0gPSBhbmdsZTtcclxuXHRcdFx0c3RhcnQgKz0gYW5nbGU7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGFyY3NbaV0uX29wdGlvbnMgPSBtZS5fcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhhcmNzW2ldLCBpKTtcclxuXHRcdFx0bWUudXBkYXRlRWxlbWVudChhcmNzW2ldLCBpLCByZXNldCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfdXBkYXRlUmFkaXVzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XHJcblx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XHJcblx0XHR2YXIgbWluU2l6ZSA9IE1hdGgubWluKGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0LCBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcCk7XHJcblxyXG5cdFx0Y2hhcnQub3V0ZXJSYWRpdXMgPSBNYXRoLm1heChtaW5TaXplIC8gMiwgMCk7XHJcblx0XHRjaGFydC5pbm5lclJhZGl1cyA9IE1hdGgubWF4KG9wdHMuY3V0b3V0UGVyY2VudGFnZSA/IChjaGFydC5vdXRlclJhZGl1cyAvIDEwMCkgKiAob3B0cy5jdXRvdXRQZXJjZW50YWdlKSA6IDEsIDApO1xyXG5cdFx0Y2hhcnQucmFkaXVzTGVuZ3RoID0gKGNoYXJ0Lm91dGVyUmFkaXVzIC0gY2hhcnQuaW5uZXJSYWRpdXMpIC8gY2hhcnQuZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpO1xyXG5cclxuXHRcdG1lLm91dGVyUmFkaXVzID0gY2hhcnQub3V0ZXJSYWRpdXMgLSAoY2hhcnQucmFkaXVzTGVuZ3RoICogbWUuaW5kZXgpO1xyXG5cdFx0bWUuaW5uZXJSYWRpdXMgPSBtZS5vdXRlclJhZGl1cyAtIGNoYXJ0LnJhZGl1c0xlbmd0aDtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihhcmMsIGluZGV4LCByZXNldCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XHJcblx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XHJcblx0XHR2YXIgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xyXG5cdFx0dmFyIHNjYWxlID0gY2hhcnQuc2NhbGU7XHJcblx0XHR2YXIgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHM7XHJcblxyXG5cdFx0dmFyIGNlbnRlclggPSBzY2FsZS54Q2VudGVyO1xyXG5cdFx0dmFyIGNlbnRlclkgPSBzY2FsZS55Q2VudGVyO1xyXG5cclxuXHRcdC8vIHZhciBuZWdIYWxmUEkgPSAtMC41ICogTWF0aC5QSTtcclxuXHRcdHZhciBkYXRhc2V0U3RhcnRBbmdsZSA9IG9wdHMuc3RhcnRBbmdsZTtcclxuXHRcdHZhciBkaXN0YW5jZSA9IGFyYy5oaWRkZW4gPyAwIDogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUoZGF0YXNldC5kYXRhW2luZGV4XSk7XHJcblx0XHR2YXIgc3RhcnRBbmdsZSA9IG1lLl9zdGFydHNbaW5kZXhdO1xyXG5cdFx0dmFyIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIChhcmMuaGlkZGVuID8gMCA6IG1lLl9hbmdsZXNbaW5kZXhdKTtcclxuXHJcblx0XHR2YXIgcmVzZXRSYWRpdXMgPSBhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZSA/IDAgOiBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShkYXRhc2V0LmRhdGFbaW5kZXhdKTtcclxuXHRcdHZhciBvcHRpb25zID0gYXJjLl9vcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdGhlbHBlcnMkMS5leHRlbmQoYXJjLCB7XHJcblx0XHRcdC8vIFV0aWxpdHlcclxuXHRcdFx0X2RhdGFzZXRJbmRleDogbWUuaW5kZXgsXHJcblx0XHRcdF9pbmRleDogaW5kZXgsXHJcblx0XHRcdF9zY2FsZTogc2NhbGUsXHJcblxyXG5cdFx0XHQvLyBEZXNpcmVkIHZpZXcgcHJvcGVydGllc1xyXG5cdFx0XHRfbW9kZWw6IHtcclxuXHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxyXG5cdFx0XHRcdGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxyXG5cdFx0XHRcdGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxyXG5cdFx0XHRcdGJvcmRlckFsaWduOiBvcHRpb25zLmJvcmRlckFsaWduLFxyXG5cdFx0XHRcdHg6IGNlbnRlclgsXHJcblx0XHRcdFx0eTogY2VudGVyWSxcclxuXHRcdFx0XHRpbm5lclJhZGl1czogMCxcclxuXHRcdFx0XHRvdXRlclJhZGl1czogcmVzZXQgPyByZXNldFJhZGl1cyA6IGRpc3RhbmNlLFxyXG5cdFx0XHRcdHN0YXJ0QW5nbGU6IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSA/IGRhdGFzZXRTdGFydEFuZ2xlIDogc3RhcnRBbmdsZSxcclxuXHRcdFx0XHRlbmRBbmdsZTogcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlID8gZGF0YXNldFN0YXJ0QW5nbGUgOiBlbmRBbmdsZSxcclxuXHRcdFx0XHRsYWJlbDogaGVscGVycyQxLnZhbHVlQXRJbmRleE9yRGVmYXVsdChsYWJlbHMsIGluZGV4LCBsYWJlbHNbaW5kZXhdKVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRhcmMucGl2b3QoKTtcclxuXHR9LFxyXG5cclxuXHRjb3VudFZpc2libGVFbGVtZW50czogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xyXG5cdFx0dmFyIG1ldGEgPSB0aGlzLmdldE1ldGEoKTtcclxuXHRcdHZhciBjb3VudCA9IDA7XHJcblxyXG5cdFx0aGVscGVycyQxLmVhY2gobWV0YS5kYXRhLCBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xyXG5cdFx0XHRpZiAoIWlzTmFOKGRhdGFzZXQuZGF0YVtpbmRleF0pICYmICFlbGVtZW50LmhpZGRlbikge1xyXG5cdFx0XHRcdGNvdW50Kys7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBjb3VudDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICovXHJcblx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24oYXJjKSB7XHJcblx0XHR2YXIgbW9kZWwgPSBhcmMuX21vZGVsO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBhcmMuX29wdGlvbnM7XHJcblx0XHR2YXIgZ2V0SG92ZXJDb2xvciA9IGhlbHBlcnMkMS5nZXRIb3ZlckNvbG9yO1xyXG5cdFx0dmFyIHZhbHVlT3JEZWZhdWx0ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xyXG5cclxuXHRcdGFyYy4kcHJldmlvdXNTdHlsZSA9IHtcclxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXHJcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcclxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoLFxyXG5cdFx0fTtcclxuXHJcblx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XHJcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuaG92ZXJCb3JkZXJDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKSk7XHJcblx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfY29tcHV0ZUFuZ2xlOiBmdW5jdGlvbihpbmRleCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjb3VudCA9IHRoaXMuZ2V0TWV0YSgpLmNvdW50O1xyXG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XHJcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcclxuXHJcblx0XHRpZiAoaXNOYU4oZGF0YXNldC5kYXRhW2luZGV4XSkgfHwgbWV0YS5kYXRhW2luZGV4XS5oaWRkZW4pIHtcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXHJcblx0XHR2YXIgY29udGV4dCA9IHtcclxuXHRcdFx0Y2hhcnQ6IG1lLmNoYXJ0LFxyXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxyXG5cdFx0XHRkYXRhc2V0OiBkYXRhc2V0LFxyXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XHJcblx0XHR9O1xyXG5cclxuXHRcdHJldHVybiByZXNvbHZlJDMoW1xyXG5cdFx0XHRtZS5jaGFydC5vcHRpb25zLmVsZW1lbnRzLmFyYy5hbmdsZSxcclxuXHRcdFx0KDIgKiBNYXRoLlBJKSAvIGNvdW50XHJcblx0XHRdLCBjb250ZXh0LCBpbmRleCk7XHJcblx0fVxyXG59KTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdwaWUnLCBoZWxwZXJzJDEuY2xvbmUoY29yZV9kZWZhdWx0cy5kb3VnaG51dCkpO1xyXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ3BpZScsIHtcclxuXHRjdXRvdXRQZXJjZW50YWdlOiAwXHJcbn0pO1xyXG5cclxuLy8gUGllIGNoYXJ0cyBhcmUgRG91Z2hudXQgY2hhcnQgd2l0aCBkaWZmZXJlbnQgZGVmYXVsdHNcclxudmFyIGNvbnRyb2xsZXJfcGllID0gY29udHJvbGxlcl9kb3VnaG51dDtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDcgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XHJcblxyXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ3JhZGFyJywge1xyXG5cdHNwYW5HYXBzOiBmYWxzZSxcclxuXHRzY2FsZToge1xyXG5cdFx0dHlwZTogJ3JhZGlhbExpbmVhcidcclxuXHR9LFxyXG5cdGVsZW1lbnRzOiB7XHJcblx0XHRsaW5lOiB7XHJcblx0XHRcdGZpbGw6ICdzdGFydCcsXHJcblx0XHRcdHRlbnNpb246IDAgLy8gbm8gYmV6aWVyIGluIHJhZGFyXHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbnZhciBjb250cm9sbGVyX3JhZGFyID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xyXG5cdGRhdGFzZXRFbGVtZW50VHlwZTogZWxlbWVudHMuTGluZSxcclxuXHJcblx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5Qb2ludCxcclxuXHJcblx0bGlua1NjYWxlczogaGVscGVycyQxLm5vb3AsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2RhdGFzZXRFbGVtZW50T3B0aW9uczogW1xyXG5cdFx0J2JhY2tncm91bmRDb2xvcicsXHJcblx0XHQnYm9yZGVyV2lkdGgnLFxyXG5cdFx0J2JvcmRlckNvbG9yJyxcclxuXHRcdCdib3JkZXJDYXBTdHlsZScsXHJcblx0XHQnYm9yZGVyRGFzaCcsXHJcblx0XHQnYm9yZGVyRGFzaE9mZnNldCcsXHJcblx0XHQnYm9yZGVySm9pblN0eWxlJyxcclxuXHRcdCdmaWxsJ1xyXG5cdF0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2RhdGFFbGVtZW50T3B0aW9uczoge1xyXG5cdFx0YmFja2dyb3VuZENvbG9yOiAncG9pbnRCYWNrZ3JvdW5kQ29sb3InLFxyXG5cdFx0Ym9yZGVyQ29sb3I6ICdwb2ludEJvcmRlckNvbG9yJyxcclxuXHRcdGJvcmRlcldpZHRoOiAncG9pbnRCb3JkZXJXaWR0aCcsXHJcblx0XHRoaXRSYWRpdXM6ICdwb2ludEhpdFJhZGl1cycsXHJcblx0XHRob3ZlckJhY2tncm91bmRDb2xvcjogJ3BvaW50SG92ZXJCYWNrZ3JvdW5kQ29sb3InLFxyXG5cdFx0aG92ZXJCb3JkZXJDb2xvcjogJ3BvaW50SG92ZXJCb3JkZXJDb2xvcicsXHJcblx0XHRob3ZlckJvcmRlcldpZHRoOiAncG9pbnRIb3ZlckJvcmRlcldpZHRoJyxcclxuXHRcdGhvdmVyUmFkaXVzOiAncG9pbnRIb3ZlclJhZGl1cycsXHJcblx0XHRwb2ludFN0eWxlOiAncG9pbnRTdHlsZScsXHJcblx0XHRyYWRpdXM6ICdwb2ludFJhZGl1cycsXHJcblx0XHRyb3RhdGlvbjogJ3BvaW50Um90YXRpb24nXHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZ2V0SW5kZXhTY2FsZUlkOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmNoYXJ0LnNjYWxlLmlkO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldFZhbHVlU2NhbGVJZDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jaGFydC5zY2FsZS5pZDtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XHJcblx0XHR2YXIgbGluZSA9IG1ldGEuZGF0YXNldDtcclxuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XHJcblx0XHR2YXIgc2NhbGUgPSBtZS5jaGFydC5zY2FsZTtcclxuXHRcdHZhciBjb25maWcgPSBtZS5fY29uZmlnO1xyXG5cdFx0dmFyIGksIGlsZW47XHJcblxyXG5cdFx0Ly8gQ29tcGF0aWJpbGl0eTogSWYgdGhlIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgd2l0aCBvbmx5IHRoZSBvbGQgbmFtZSwgdXNlIHRob3NlIHZhbHVlc1xyXG5cdFx0aWYgKGNvbmZpZy50ZW5zaW9uICE9PSB1bmRlZmluZWQgJiYgY29uZmlnLmxpbmVUZW5zaW9uID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Y29uZmlnLmxpbmVUZW5zaW9uID0gY29uZmlnLnRlbnNpb247XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVXRpbGl0eVxyXG5cdFx0bGluZS5fc2NhbGUgPSBzY2FsZTtcclxuXHRcdGxpbmUuX2RhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xyXG5cdFx0Ly8gRGF0YVxyXG5cdFx0bGluZS5fY2hpbGRyZW4gPSBwb2ludHM7XHJcblx0XHRsaW5lLl9sb29wID0gdHJ1ZTtcclxuXHRcdC8vIE1vZGVsXHJcblx0XHRsaW5lLl9tb2RlbCA9IG1lLl9yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKGxpbmUpO1xyXG5cclxuXHRcdGxpbmUucGl2b3QoKTtcclxuXHJcblx0XHQvLyBVcGRhdGUgUG9pbnRzXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KHBvaW50c1tpXSwgaSwgcmVzZXQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFVwZGF0ZSBiZXppZXIgY29udHJvbCBwb2ludHNcclxuXHRcdG1lLnVwZGF0ZUJlemllckNvbnRyb2xQb2ludHMoKTtcclxuXHJcblx0XHQvLyBOb3cgcGl2b3QgdGhlIHBvaW50IGZvciBhbmltYXRpb25cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdHBvaW50c1tpXS5waXZvdCgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCwgcmVzZXQpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xyXG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XHJcblx0XHR2YXIgc2NhbGUgPSBtZS5jaGFydC5zY2FsZTtcclxuXHRcdHZhciBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4LCBkYXRhc2V0LmRhdGFbaW5kZXhdKTtcclxuXHRcdHZhciBvcHRpb25zID0gbWUuX3Jlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMocG9pbnQsIGluZGV4KTtcclxuXHRcdHZhciBsaW5lTW9kZWwgPSBtZS5nZXRNZXRhKCkuZGF0YXNldC5fbW9kZWw7XHJcblx0XHR2YXIgeCA9IHJlc2V0ID8gc2NhbGUueENlbnRlciA6IHBvaW50UG9zaXRpb24ueDtcclxuXHRcdHZhciB5ID0gcmVzZXQgPyBzY2FsZS55Q2VudGVyIDogcG9pbnRQb3NpdGlvbi55O1xyXG5cclxuXHRcdC8vIFV0aWxpdHlcclxuXHRcdHBvaW50Ll9zY2FsZSA9IHNjYWxlO1xyXG5cdFx0cG9pbnQuX29wdGlvbnMgPSBvcHRpb25zO1xyXG5cdFx0cG9pbnQuX2RhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xyXG5cdFx0cG9pbnQuX2luZGV4ID0gaW5kZXg7XHJcblxyXG5cdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcclxuXHRcdHBvaW50Ll9tb2RlbCA9IHtcclxuXHRcdFx0eDogeCwgLy8gdmFsdWUgbm90IHVzZWQgaW4gZGF0YXNldCBzY2FsZSwgYnV0IHdlIHdhbnQgYSBjb25zaXN0ZW50IEFQSSBiZXR3ZWVuIHNjYWxlc1xyXG5cdFx0XHR5OiB5LFxyXG5cdFx0XHRza2lwOiBjdXN0b20uc2tpcCB8fCBpc05hTih4KSB8fCBpc05hTih5KSxcclxuXHRcdFx0Ly8gQXBwZWFyYW5jZVxyXG5cdFx0XHRyYWRpdXM6IG9wdGlvbnMucmFkaXVzLFxyXG5cdFx0XHRwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXHJcblx0XHRcdHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxyXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxyXG5cdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcclxuXHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXHJcblx0XHRcdHRlbnNpb246IHZhbHVlT3JEZWZhdWx0JDcoY3VzdG9tLnRlbnNpb24sIGxpbmVNb2RlbCA/IGxpbmVNb2RlbC50ZW5zaW9uIDogMCksXHJcblxyXG5cdFx0XHQvLyBUb29sdGlwXHJcblx0XHRcdGhpdFJhZGl1czogb3B0aW9ucy5oaXRSYWRpdXNcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9uczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGNvbmZpZyA9IG1lLl9jb25maWc7XHJcblx0XHR2YXIgb3B0aW9ucyA9IG1lLmNoYXJ0Lm9wdGlvbnM7XHJcblx0XHR2YXIgdmFsdWVzID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUuX3Jlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMuYXBwbHkobWUsIGFyZ3VtZW50cyk7XHJcblxyXG5cdFx0dmFsdWVzLnNwYW5HYXBzID0gdmFsdWVPckRlZmF1bHQkNyhjb25maWcuc3BhbkdhcHMsIG9wdGlvbnMuc3BhbkdhcHMpO1xyXG5cdFx0dmFsdWVzLnRlbnNpb24gPSB2YWx1ZU9yRGVmYXVsdCQ3KGNvbmZpZy5saW5lVGVuc2lvbiwgb3B0aW9ucy5lbGVtZW50cy5saW5lLnRlbnNpb24pO1xyXG5cclxuXHRcdHJldHVybiB2YWx1ZXM7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlQmV6aWVyQ29udHJvbFBvaW50czogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XHJcblx0XHR2YXIgYXJlYSA9IG1lLmNoYXJ0LmNoYXJ0QXJlYTtcclxuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XHJcblx0XHR2YXIgaSwgaWxlbiwgbW9kZWwsIGNvbnRyb2xQb2ludHM7XHJcblxyXG5cdFx0Ly8gT25seSBjb25zaWRlciBwb2ludHMgdGhhdCBhcmUgZHJhd24gaW4gY2FzZSB0aGUgc3BhbkdhcHMgb3B0aW9uIGlzIHVzZWRcclxuXHRcdGlmIChtZXRhLmRhdGFzZXQuX21vZGVsLnNwYW5HYXBzKSB7XHJcblx0XHRcdHBvaW50cyA9IHBvaW50cy5maWx0ZXIoZnVuY3Rpb24ocHQpIHtcclxuXHRcdFx0XHRyZXR1cm4gIXB0Ll9tb2RlbC5za2lwO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQsIG1pbiwgbWF4KSB7XHJcblx0XHRcdHJldHVybiBNYXRoLm1heChNYXRoLm1pbihwdCwgbWF4KSwgbWluKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRtb2RlbCA9IHBvaW50c1tpXS5fbW9kZWw7XHJcblx0XHRcdGNvbnRyb2xQb2ludHMgPSBoZWxwZXJzJDEuc3BsaW5lQ3VydmUoXHJcblx0XHRcdFx0aGVscGVycyQxLnByZXZpb3VzSXRlbShwb2ludHMsIGksIHRydWUpLl9tb2RlbCxcclxuXHRcdFx0XHRtb2RlbCxcclxuXHRcdFx0XHRoZWxwZXJzJDEubmV4dEl0ZW0ocG9pbnRzLCBpLCB0cnVlKS5fbW9kZWwsXHJcblx0XHRcdFx0bW9kZWwudGVuc2lvblxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0Ly8gUHJldmVudCB0aGUgYmV6aWVyIGdvaW5nIG91dHNpZGUgb2YgdGhlIGJvdW5kcyBvZiB0aGUgZ3JhcGhcclxuXHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYID0gY2FwQ29udHJvbFBvaW50KGNvbnRyb2xQb2ludHMucHJldmlvdXMueCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcclxuXHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gY2FwQ29udHJvbFBvaW50KGNvbnRyb2xQb2ludHMucHJldmlvdXMueSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcclxuXHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFggPSBjYXBDb250cm9sUG9pbnQoY29udHJvbFBvaW50cy5uZXh0LngsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XHJcblx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRZID0gY2FwQ29udHJvbFBvaW50KGNvbnRyb2xQb2ludHMubmV4dC55LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKHBvaW50KSB7XHJcblx0XHR2YXIgbW9kZWwgPSBwb2ludC5fbW9kZWw7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHBvaW50Ll9vcHRpb25zO1xyXG5cdFx0dmFyIGdldEhvdmVyQ29sb3IgPSBoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvcjtcclxuXHJcblx0XHRwb2ludC4kcHJldmlvdXNTdHlsZSA9IHtcclxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXHJcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcclxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoLFxyXG5cdFx0XHRyYWRpdXM6IG1vZGVsLnJhZGl1c1xyXG5cdFx0fTtcclxuXHJcblx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ3KG9wdGlvbnMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpKTtcclxuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gdmFsdWVPckRlZmF1bHQkNyhvcHRpb25zLmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcikpO1xyXG5cdFx0bW9kZWwuYm9yZGVyV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQ3KG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XHJcblx0XHRtb2RlbC5yYWRpdXMgPSB2YWx1ZU9yRGVmYXVsdCQ3KG9wdGlvbnMuaG92ZXJSYWRpdXMsIG9wdGlvbnMucmFkaXVzKTtcclxuXHR9XHJcbn0pO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ3NjYXR0ZXInLCB7XHJcblx0aG92ZXI6IHtcclxuXHRcdG1vZGU6ICdzaW5nbGUnXHJcblx0fSxcclxuXHJcblx0c2NhbGVzOiB7XHJcblx0XHR4QXhlczogW3tcclxuXHRcdFx0aWQ6ICd4LWF4aXMtMScsICAgIC8vIG5lZWQgYW4gSUQgc28gZGF0YXNldHMgY2FuIHJlZmVyZW5jZSB0aGUgc2NhbGVcclxuXHRcdFx0dHlwZTogJ2xpbmVhcicsICAgIC8vIHNjYXR0ZXIgc2hvdWxkIG5vdCB1c2UgYSBjYXRlZ29yeSBheGlzXHJcblx0XHRcdHBvc2l0aW9uOiAnYm90dG9tJ1xyXG5cdFx0fV0sXHJcblx0XHR5QXhlczogW3tcclxuXHRcdFx0aWQ6ICd5LWF4aXMtMScsXHJcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxyXG5cdFx0XHRwb3NpdGlvbjogJ2xlZnQnXHJcblx0XHR9XVxyXG5cdH0sXHJcblxyXG5cdHRvb2x0aXBzOiB7XHJcblx0XHRjYWxsYmFja3M6IHtcclxuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiAnJzsgICAgIC8vIGRvZXNuJ3QgbWFrZSBzZW5zZSBmb3Igc2NhdHRlciBzaW5jZSBkYXRhIGFyZSBmb3JtYXR0ZWQgYXMgYSBwb2ludFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24oaXRlbSkge1xyXG5cdFx0XHRcdHJldHVybiAnKCcgKyBpdGVtLnhMYWJlbCArICcsICcgKyBpdGVtLnlMYWJlbCArICcpJztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcclxuXHRkYXRhc2V0czoge1xyXG5cdFx0c2NhdHRlcjoge1xyXG5cdFx0XHRzaG93TGluZTogZmFsc2VcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gU2NhdHRlciBjaGFydHMgdXNlIGxpbmUgY29udHJvbGxlcnNcclxudmFyIGNvbnRyb2xsZXJfc2NhdHRlciA9IGNvbnRyb2xsZXJfbGluZTtcblxuLy8gTk9URSBleHBvcnQgYSBtYXAgaW4gd2hpY2ggdGhlIGtleSByZXByZXNlbnRzIHRoZSBjb250cm9sbGVyIHR5cGUsIG5vdFxyXG4vLyB0aGUgY2xhc3MsIGFuZCBzbyBtdXN0IGJlIENhbWVsQ2FzZSBpbiBvcmRlciB0byBiZSBjb3JyZWN0bHkgcmV0cmlldmVkXHJcbi8vIGJ5IHRoZSBjb250cm9sbGVyIGluIGNvcmUuY29udHJvbGxlci5qcyAoYGNvbnRyb2xsZXJzW21ldGEudHlwZV1gKS5cclxuXHJcbnZhciBjb250cm9sbGVycyA9IHtcclxuXHRiYXI6IGNvbnRyb2xsZXJfYmFyLFxyXG5cdGJ1YmJsZTogY29udHJvbGxlcl9idWJibGUsXHJcblx0ZG91Z2hudXQ6IGNvbnRyb2xsZXJfZG91Z2hudXQsXHJcblx0aG9yaXpvbnRhbEJhcjogY29udHJvbGxlcl9ob3Jpem9udGFsQmFyLFxyXG5cdGxpbmU6IGNvbnRyb2xsZXJfbGluZSxcclxuXHRwb2xhckFyZWE6IGNvbnRyb2xsZXJfcG9sYXJBcmVhLFxyXG5cdHBpZTogY29udHJvbGxlcl9waWUsXHJcblx0cmFkYXI6IGNvbnRyb2xsZXJfcmFkYXIsXHJcblx0c2NhdHRlcjogY29udHJvbGxlcl9zY2F0dGVyXHJcbn07XG5cbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHJlbGF0aXZlIHBvc2l0aW9uIGZvciBhbiBldmVudFxyXG4gKiBAcGFyYW0ge0V2ZW50fElFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdG8gZ2V0IHRoZSBwb3NpdGlvbiBmb3JcclxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnRcclxuICogQHJldHVybnMge29iamVjdH0gdGhlIGV2ZW50IHBvc2l0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KSB7XHJcblx0aWYgKGUubmF0aXZlKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiBlLngsXHJcblx0XHRcdHk6IGUueVxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBoZWxwZXJzJDEuZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gdHJhdmVyc2UgYWxsIG9mIHRoZSB2aXNpYmxlIGVsZW1lbnRzIGluIHRoZSBjaGFydFxyXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gdGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgZm9yIGVhY2ggdmlzaWJsZSBpdGVtXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgaGFuZGxlcikge1xyXG5cdHZhciBtZXRhc2V0cyA9IGNoYXJ0Ll9nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XHJcblx0dmFyIG1ldGFkYXRhLCBpLCBqLCBpbGVuLCBqbGVuLCBlbGVtZW50O1xyXG5cclxuXHRmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRtZXRhZGF0YSA9IG1ldGFzZXRzW2ldLmRhdGE7XHJcblx0XHRmb3IgKGogPSAwLCBqbGVuID0gbWV0YWRhdGEubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XHJcblx0XHRcdGVsZW1lbnQgPSBtZXRhZGF0YVtqXTtcclxuXHRcdFx0aWYgKCFlbGVtZW50Ll92aWV3LnNraXApIHtcclxuXHRcdFx0XHRoYW5kbGVyKGVsZW1lbnQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIGV2ZW50IHBvc2l0aW9uXHJcbiAqIEBwYXJhbSB7Q2hhcnRFbGVtZW50W119IGl0ZW1zIC0gZWxlbWVudHMgdG8gZmlsdGVyXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvXHJcbiAqIEByZXR1cm4ge0NoYXJ0RWxlbWVudFtdfSB0aGUgbmVhcmVzdCBpdGVtc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uKSB7XHJcblx0dmFyIGVsZW1lbnRzID0gW107XHJcblxyXG5cdHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBmdW5jdGlvbihlbGVtZW50KSB7XHJcblx0XHRpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XHJcblx0XHRcdGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdHJldHVybiBlbGVtZW50cztcclxufVxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uIGNvbnNpZGVyaW5nIGFsbCB2aXNpYmxlIGl0ZW1zIGluIHRlaCBjaGFydFxyXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cclxuICogQHBhcmFtIHtvYmplY3R9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG9cclxuICogQHBhcmFtIHtib29sZWFufSBpbnRlcnNlY3QgLSBpZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvblxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkaXN0YW5jZU1ldHJpYyAtIGZ1bmN0aW9uIHRvIHByb3ZpZGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gcG9pbnRzXHJcbiAqIEByZXR1cm4ge0NoYXJ0RWxlbWVudFtdfSB0aGUgbmVhcmVzdCBpdGVtc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgaW50ZXJzZWN0LCBkaXN0YW5jZU1ldHJpYykge1xyXG5cdHZhciBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuXHR2YXIgbmVhcmVzdEl0ZW1zID0gW107XHJcblxyXG5cdHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBmdW5jdGlvbihlbGVtZW50KSB7XHJcblx0XHRpZiAoaW50ZXJzZWN0ICYmICFlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBjZW50ZXIgPSBlbGVtZW50LmdldENlbnRlclBvaW50KCk7XHJcblx0XHR2YXIgZGlzdGFuY2UgPSBkaXN0YW5jZU1ldHJpYyhwb3NpdGlvbiwgY2VudGVyKTtcclxuXHRcdGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XHJcblx0XHRcdG5lYXJlc3RJdGVtcyA9IFtlbGVtZW50XTtcclxuXHRcdFx0bWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuXHRcdH0gZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XHJcblx0XHRcdC8vIENhbiBoYXZlIG11bHRpcGxlIGl0ZW1zIGF0IHRoZSBzYW1lIGRpc3RhbmNlIGluIHdoaWNoIGNhc2Ugd2Ugc29ydCBieSBzaXplXHJcblx0XHRcdG5lYXJlc3RJdGVtcy5wdXNoKGVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gbmVhcmVzdEl0ZW1zO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGEgZGlzdGFuY2UgbWV0cmljIGZ1bmN0aW9uIGZvciB0d28gcG9pbnRzIGJhc2VkIG9uIHRoZVxyXG4gKiBheGlzIG1vZGUgc2V0dGluZ1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpIHtcclxuXHR2YXIgdXNlWCA9IGF4aXMuaW5kZXhPZigneCcpICE9PSAtMTtcclxuXHR2YXIgdXNlWSA9IGF4aXMuaW5kZXhPZigneScpICE9PSAtMTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uKHB0MSwgcHQyKSB7XHJcblx0XHR2YXIgZGVsdGFYID0gdXNlWCA/IE1hdGguYWJzKHB0MS54IC0gcHQyLngpIDogMDtcclxuXHRcdHZhciBkZWx0YVkgPSB1c2VZID8gTWF0aC5hYnMocHQxLnkgLSBwdDIueSkgOiAwO1xyXG5cdFx0cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhkZWx0YVgsIDIpICsgTWF0aC5wb3coZGVsdGFZLCAyKSk7XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW5kZXhNb2RlKGNoYXJ0LCBlLCBvcHRpb25zKSB7XHJcblx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XHJcblx0Ly8gRGVmYXVsdCBheGlzIGZvciBpbmRleCBtb2RlIGlzICd4JyB0byBtYXRjaCBvbGQgYmVoYXZpb3VyXHJcblx0b3B0aW9ucy5heGlzID0gb3B0aW9ucy5heGlzIHx8ICd4JztcclxuXHR2YXIgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMob3B0aW9ucy5heGlzKTtcclxuXHR2YXIgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdCA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbikgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBmYWxzZSwgZGlzdGFuY2VNZXRyaWMpO1xyXG5cdHZhciBlbGVtZW50cyA9IFtdO1xyXG5cclxuXHRpZiAoIWl0ZW1zLmxlbmd0aCkge1xyXG5cdFx0cmV0dXJuIFtdO1xyXG5cdH1cclxuXHJcblx0Y2hhcnQuX2dldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGEpIHtcclxuXHRcdHZhciBlbGVtZW50ID0gbWV0YS5kYXRhW2l0ZW1zWzBdLl9pbmRleF07XHJcblxyXG5cdFx0Ly8gZG9uJ3QgY291bnQgaXRlbXMgdGhhdCBhcmUgc2tpcHBlZCAobnVsbCBkYXRhKVxyXG5cdFx0aWYgKGVsZW1lbnQgJiYgIWVsZW1lbnQuX3ZpZXcuc2tpcCkge1xyXG5cdFx0XHRlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gZWxlbWVudHM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAaW50ZXJmYWNlIElJbnRlcmFjdGlvbk9wdGlvbnNcclxuICovXHJcbi8qKlxyXG4gKiBJZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb2ludFxyXG4gKiBAbmFtZSBJSW50ZXJmYWNlT3B0aW9ucyNib29sZWFuXHJcbiAqIEB0eXBlIEJvb2xlYW5cclxuICovXHJcblxyXG4vKipcclxuICogQ29udGFpbnMgaW50ZXJhY3Rpb24gcmVsYXRlZCBmdW5jdGlvbnNcclxuICogQG5hbWVzcGFjZSBDaGFydC5JbnRlcmFjdGlvblxyXG4gKi9cclxudmFyIGNvcmVfaW50ZXJhY3Rpb24gPSB7XHJcblx0Ly8gSGVscGVyIGZ1bmN0aW9uIGZvciBkaWZmZXJlbnQgbW9kZXNcclxuXHRtb2Rlczoge1xyXG5cdFx0c2luZ2xlOiBmdW5jdGlvbihjaGFydCwgZSkge1xyXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcclxuXHRcdFx0dmFyIGVsZW1lbnRzID0gW107XHJcblxyXG5cdFx0XHRwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgZnVuY3Rpb24oZWxlbWVudCkge1xyXG5cdFx0XHRcdGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcclxuXHRcdFx0XHRcdGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XHJcblx0XHRcdFx0XHRyZXR1cm4gZWxlbWVudHM7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHJldHVybiBlbGVtZW50cy5zbGljZSgwLCAxKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMubGFiZWxcclxuXHRcdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi40LjBcclxuXHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHRcdGxhYmVsOiBpbmRleE1vZGUsXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXR1cm5zIGl0ZW1zIGF0IHRoZSBzYW1lIGluZGV4LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcclxuXHRcdCAqIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBtb2RlIGlzIGZhbHNlLCB3ZSBmaW5kIHRoZSBuZWFyZXN0IGl0ZW0gYW5kIHJldHVybiB0aGUgaXRlbXMgYXQgdGhlIHNhbWUgaW5kZXggYXMgdGhhdCBpdGVtXHJcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW5kZXhcclxuXHRcdCAqIEBzaW5jZSB2Mi40LjBcclxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxyXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcclxuXHRcdCAqIEBwYXJhbSB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlIGR1cmluZyBpbnRlcmFjdGlvblxyXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxyXG5cdFx0ICovXHJcblx0XHRpbmRleDogaW5kZXhNb2RlLFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmV0dXJucyBpdGVtcyBpbiB0aGUgc2FtZSBkYXRhc2V0LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcclxuXHRcdCAqIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBpcyBmYWxzZSwgd2UgZmluZCB0aGUgbmVhcmVzdCBpdGVtIGFuZCByZXR1cm4gdGhlIGl0ZW1zIGluIHRoYXQgZGF0YXNldFxyXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmRhdGFzZXRcclxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxyXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcclxuXHRcdCAqIEBwYXJhbSB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlIGR1cmluZyBpbnRlcmFjdGlvblxyXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxyXG5cdFx0ICovXHJcblx0XHRkYXRhc2V0OiBmdW5jdGlvbihjaGFydCwgZSwgb3B0aW9ucykge1xyXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcclxuXHRcdFx0b3B0aW9ucy5heGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XHJcblx0XHRcdHZhciBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhvcHRpb25zLmF4aXMpO1xyXG5cdFx0XHR2YXIgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdCA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbikgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBmYWxzZSwgZGlzdGFuY2VNZXRyaWMpO1xyXG5cclxuXHRcdFx0aWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRpdGVtcyA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGl0ZW1zWzBdLl9kYXRhc2V0SW5kZXgpLmRhdGE7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBpdGVtcztcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMueC1heGlzXHJcblx0XHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNC4wLiBVc2UgaW5kZXggbW9kZSBhbmQgaW50ZXJzZWN0ID09IHRydWVcclxuXHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHRcdCd4LWF4aXMnOiBmdW5jdGlvbihjaGFydCwgZSkge1xyXG5cdFx0XHRyZXR1cm4gaW5kZXhNb2RlKGNoYXJ0LCBlLCB7aW50ZXJzZWN0OiBmYWxzZX0pO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFBvaW50IG1vZGUgcmV0dXJucyBhbGwgZWxlbWVudHMgdGhhdCBoaXQgdGVzdCBiYXNlZCBvbiB0aGUgZXZlbnQgcG9zaXRpb25cclxuXHRcdCAqIG9mIHRoZSBldmVudFxyXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmludGVyc2VjdFxyXG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXHJcblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxyXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxyXG5cdFx0ICovXHJcblx0XHRwb2ludDogZnVuY3Rpb24oY2hhcnQsIGUpIHtcclxuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XHJcblx0XHRcdHJldHVybiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24pO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIG5lYXJlc3QgbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50IGNsb3Nlc3QgdG8gdGhlIHBvaW50XHJcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW50ZXJzZWN0XHJcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cclxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XHJcblx0XHQgKiBAcGFyYW0ge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxyXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxyXG5cdFx0ICovXHJcblx0XHRuZWFyZXN0OiBmdW5jdGlvbihjaGFydCwgZSwgb3B0aW9ucykge1xyXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcclxuXHRcdFx0b3B0aW9ucy5heGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XHJcblx0XHRcdHZhciBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhvcHRpb25zLmF4aXMpO1xyXG5cdFx0XHRyZXR1cm4gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgb3B0aW9ucy5pbnRlcnNlY3QsIGRpc3RhbmNlTWV0cmljKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiB4IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudHMgdGhhdCBoaXQtdGVzdCBhdCB0aGUgY3VycmVudCB4IGNvb3JkaW5hdGVcclxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy54XHJcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cclxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XHJcblx0XHQgKiBAcGFyYW0ge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxyXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxyXG5cdFx0ICovXHJcblx0XHR4OiBmdW5jdGlvbihjaGFydCwgZSwgb3B0aW9ucykge1xyXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcclxuXHRcdFx0dmFyIGl0ZW1zID0gW107XHJcblx0XHRcdHZhciBpbnRlcnNlY3RzSXRlbSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuXHRcdFx0XHRpZiAoZWxlbWVudC5pblhSYW5nZShwb3NpdGlvbi54KSkge1xyXG5cdFx0XHRcdFx0aXRlbXMucHVzaChlbGVtZW50KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcclxuXHRcdFx0XHRcdGludGVyc2VjdHNJdGVtID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly8gSWYgd2Ugd2FudCB0byB0cmlnZ2VyIG9uIGFuIGludGVyc2VjdCBhbmQgd2UgZG9uJ3QgaGF2ZSBhbnkgaXRlbXNcclxuXHRcdFx0Ly8gdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uLCByZXR1cm4gbm90aGluZ1xyXG5cdFx0XHRpZiAob3B0aW9ucy5pbnRlcnNlY3QgJiYgIWludGVyc2VjdHNJdGVtKSB7XHJcblx0XHRcdFx0aXRlbXMgPSBbXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gaXRlbXM7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogeSBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnRzIHRoYXQgaGl0LXRlc3QgYXQgdGhlIGN1cnJlbnQgeSBjb29yZGluYXRlXHJcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMueVxyXG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXHJcblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxyXG5cdFx0ICogQHBhcmFtIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2VcclxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcclxuXHRcdCAqL1xyXG5cdFx0eTogZnVuY3Rpb24oY2hhcnQsIGUsIG9wdGlvbnMpIHtcclxuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XHJcblx0XHRcdHZhciBpdGVtcyA9IFtdO1xyXG5cdFx0XHR2YXIgaW50ZXJzZWN0c0l0ZW0gPSBmYWxzZTtcclxuXHJcblx0XHRcdHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBmdW5jdGlvbihlbGVtZW50KSB7XHJcblx0XHRcdFx0aWYgKGVsZW1lbnQuaW5ZUmFuZ2UocG9zaXRpb24ueSkpIHtcclxuXHRcdFx0XHRcdGl0ZW1zLnB1c2goZWxlbWVudCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XHJcblx0XHRcdFx0XHRpbnRlcnNlY3RzSXRlbSA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdC8vIElmIHdlIHdhbnQgdG8gdHJpZ2dlciBvbiBhbiBpbnRlcnNlY3QgYW5kIHdlIGRvbid0IGhhdmUgYW55IGl0ZW1zXHJcblx0XHRcdC8vIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvbiwgcmV0dXJuIG5vdGhpbmdcclxuXHRcdFx0aWYgKG9wdGlvbnMuaW50ZXJzZWN0ICYmICFpbnRlcnNlY3RzSXRlbSkge1xyXG5cdFx0XHRcdGl0ZW1zID0gW107XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGl0ZW1zO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcblxudmFyIGV4dGVuZCA9IGhlbHBlcnMkMS5leHRlbmQ7XHJcblxyXG5mdW5jdGlvbiBmaWx0ZXJCeVBvc2l0aW9uKGFycmF5LCBwb3NpdGlvbikge1xyXG5cdHJldHVybiBoZWxwZXJzJDEud2hlcmUoYXJyYXksIGZ1bmN0aW9uKHYpIHtcclxuXHRcdHJldHVybiB2LnBvcyA9PT0gcG9zaXRpb247XHJcblx0fSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNvcnRCeVdlaWdodChhcnJheSwgcmV2ZXJzZSkge1xyXG5cdHJldHVybiBhcnJheS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdHZhciB2MCA9IHJldmVyc2UgPyBiIDogYTtcclxuXHRcdHZhciB2MSA9IHJldmVyc2UgPyBhIDogYjtcclxuXHRcdHJldHVybiB2MC53ZWlnaHQgPT09IHYxLndlaWdodCA/XHJcblx0XHRcdHYwLmluZGV4IC0gdjEuaW5kZXggOlxyXG5cdFx0XHR2MC53ZWlnaHQgLSB2MS53ZWlnaHQ7XHJcblx0fSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyYXBCb3hlcyhib3hlcykge1xyXG5cdHZhciBsYXlvdXRCb3hlcyA9IFtdO1xyXG5cdHZhciBpLCBpbGVuLCBib3g7XHJcblxyXG5cdGZvciAoaSA9IDAsIGlsZW4gPSAoYm94ZXMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0Ym94ID0gYm94ZXNbaV07XHJcblx0XHRsYXlvdXRCb3hlcy5wdXNoKHtcclxuXHRcdFx0aW5kZXg6IGksXHJcblx0XHRcdGJveDogYm94LFxyXG5cdFx0XHRwb3M6IGJveC5wb3NpdGlvbixcclxuXHRcdFx0aG9yaXpvbnRhbDogYm94LmlzSG9yaXpvbnRhbCgpLFxyXG5cdFx0XHR3ZWlnaHQ6IGJveC53ZWlnaHRcclxuXHRcdH0pO1xyXG5cdH1cclxuXHRyZXR1cm4gbGF5b3V0Qm94ZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldExheW91dERpbXMobGF5b3V0cywgcGFyYW1zKSB7XHJcblx0dmFyIGksIGlsZW4sIGxheW91dDtcclxuXHRmb3IgKGkgPSAwLCBpbGVuID0gbGF5b3V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdGxheW91dCA9IGxheW91dHNbaV07XHJcblx0XHQvLyBzdG9yZSB3aWR0aCB1c2VkIGluc3RlYWQgb2YgY2hhcnRBcmVhLncgaW4gZml0Qm94ZXNcclxuXHRcdGxheW91dC53aWR0aCA9IGxheW91dC5ob3Jpem9udGFsXHJcblx0XHRcdD8gbGF5b3V0LmJveC5mdWxsV2lkdGggJiYgcGFyYW1zLmF2YWlsYWJsZVdpZHRoXHJcblx0XHRcdDogcGFyYW1zLnZCb3hNYXhXaWR0aDtcclxuXHRcdC8vIHN0b3JlIGhlaWdodCB1c2VkIGluc3RlYWQgb2YgY2hhcnRBcmVhLmggaW4gZml0Qm94ZXNcclxuXHRcdGxheW91dC5oZWlnaHQgPSBsYXlvdXQuaG9yaXpvbnRhbCAmJiBwYXJhbXMuaEJveE1heEhlaWdodDtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJ1aWxkTGF5b3V0Qm94ZXMoYm94ZXMpIHtcclxuXHR2YXIgbGF5b3V0Qm94ZXMgPSB3cmFwQm94ZXMoYm94ZXMpO1xyXG5cdHZhciBsZWZ0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdsZWZ0JyksIHRydWUpO1xyXG5cdHZhciByaWdodCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAncmlnaHQnKSk7XHJcblx0dmFyIHRvcCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAndG9wJyksIHRydWUpO1xyXG5cdHZhciBib3R0b20gPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2JvdHRvbScpKTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdGxlZnRBbmRUb3A6IGxlZnQuY29uY2F0KHRvcCksXHJcblx0XHRyaWdodEFuZEJvdHRvbTogcmlnaHQuY29uY2F0KGJvdHRvbSksXHJcblx0XHRjaGFydEFyZWE6IGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdjaGFydEFyZWEnKSxcclxuXHRcdHZlcnRpY2FsOiBsZWZ0LmNvbmNhdChyaWdodCksXHJcblx0XHRob3Jpem9udGFsOiB0b3AuY29uY2F0KGJvdHRvbSlcclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsIGEsIGIpIHtcclxuXHRyZXR1cm4gTWF0aC5tYXgobWF4UGFkZGluZ1thXSwgY2hhcnRBcmVhW2FdKSArIE1hdGgubWF4KG1heFBhZGRpbmdbYl0sIGNoYXJ0QXJlYVtiXSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZURpbXMoY2hhcnRBcmVhLCBwYXJhbXMsIGxheW91dCkge1xyXG5cdHZhciBib3ggPSBsYXlvdXQuYm94O1xyXG5cdHZhciBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XHJcblx0dmFyIG5ld1dpZHRoLCBuZXdIZWlnaHQ7XHJcblxyXG5cdGlmIChsYXlvdXQuc2l6ZSkge1xyXG5cdFx0Ly8gdGhpcyBsYXlvdXQgd2FzIGFscmVhZHkgY291bnRlZCBmb3IsIGxldHMgZmlyc3QgcmVkdWNlIG9sZCBzaXplXHJcblx0XHRjaGFydEFyZWFbbGF5b3V0LnBvc10gLT0gbGF5b3V0LnNpemU7XHJcblx0fVxyXG5cdGxheW91dC5zaXplID0gbGF5b3V0Lmhvcml6b250YWwgPyBib3guaGVpZ2h0IDogYm94LndpZHRoO1xyXG5cdGNoYXJ0QXJlYVtsYXlvdXQucG9zXSArPSBsYXlvdXQuc2l6ZTtcclxuXHJcblx0aWYgKGJveC5nZXRQYWRkaW5nKSB7XHJcblx0XHR2YXIgYm94UGFkZGluZyA9IGJveC5nZXRQYWRkaW5nKCk7XHJcblx0XHRtYXhQYWRkaW5nLnRvcCA9IE1hdGgubWF4KG1heFBhZGRpbmcudG9wLCBib3hQYWRkaW5nLnRvcCk7XHJcblx0XHRtYXhQYWRkaW5nLmxlZnQgPSBNYXRoLm1heChtYXhQYWRkaW5nLmxlZnQsIGJveFBhZGRpbmcubGVmdCk7XHJcblx0XHRtYXhQYWRkaW5nLmJvdHRvbSA9IE1hdGgubWF4KG1heFBhZGRpbmcuYm90dG9tLCBib3hQYWRkaW5nLmJvdHRvbSk7XHJcblx0XHRtYXhQYWRkaW5nLnJpZ2h0ID0gTWF0aC5tYXgobWF4UGFkZGluZy5yaWdodCwgYm94UGFkZGluZy5yaWdodCk7XHJcblx0fVxyXG5cclxuXHRuZXdXaWR0aCA9IHBhcmFtcy5vdXRlcldpZHRoIC0gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCAnbGVmdCcsICdyaWdodCcpO1xyXG5cdG5ld0hlaWdodCA9IHBhcmFtcy5vdXRlckhlaWdodCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ3RvcCcsICdib3R0b20nKTtcclxuXHJcblx0aWYgKG5ld1dpZHRoICE9PSBjaGFydEFyZWEudyB8fCBuZXdIZWlnaHQgIT09IGNoYXJ0QXJlYS5oKSB7XHJcblx0XHRjaGFydEFyZWEudyA9IG5ld1dpZHRoO1xyXG5cdFx0Y2hhcnRBcmVhLmggPSBuZXdIZWlnaHQ7XHJcblxyXG5cdFx0Ly8gcmV0dXJuIHRydWUgaWYgY2hhcnQgYXJlYSBjaGFuZ2VkIGluIGxheW91dCdzIGRpcmVjdGlvblxyXG5cdFx0dmFyIHNpemVzID0gbGF5b3V0Lmhvcml6b250YWwgPyBbbmV3V2lkdGgsIGNoYXJ0QXJlYS53XSA6IFtuZXdIZWlnaHQsIGNoYXJ0QXJlYS5oXTtcclxuXHRcdHJldHVybiBzaXplc1swXSAhPT0gc2l6ZXNbMV0gJiYgKCFpc05hTihzaXplc1swXSkgfHwgIWlzTmFOKHNpemVzWzFdKSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVNYXhQYWRkaW5nKGNoYXJ0QXJlYSkge1xyXG5cdHZhciBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XHJcblxyXG5cdGZ1bmN0aW9uIHVwZGF0ZVBvcyhwb3MpIHtcclxuXHRcdHZhciBjaGFuZ2UgPSBNYXRoLm1heChtYXhQYWRkaW5nW3Bvc10gLSBjaGFydEFyZWFbcG9zXSwgMCk7XHJcblx0XHRjaGFydEFyZWFbcG9zXSArPSBjaGFuZ2U7XHJcblx0XHRyZXR1cm4gY2hhbmdlO1xyXG5cdH1cclxuXHRjaGFydEFyZWEueSArPSB1cGRhdGVQb3MoJ3RvcCcpO1xyXG5cdGNoYXJ0QXJlYS54ICs9IHVwZGF0ZVBvcygnbGVmdCcpO1xyXG5cdHVwZGF0ZVBvcygncmlnaHQnKTtcclxuXHR1cGRhdGVQb3MoJ2JvdHRvbScpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRNYXJnaW5zKGhvcml6b250YWwsIGNoYXJ0QXJlYSkge1xyXG5cdHZhciBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XHJcblxyXG5cdGZ1bmN0aW9uIG1hcmdpbkZvclBvc2l0aW9ucyhwb3NpdGlvbnMpIHtcclxuXHRcdHZhciBtYXJnaW4gPSB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwfTtcclxuXHRcdHBvc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHBvcykge1xyXG5cdFx0XHRtYXJnaW5bcG9zXSA9IE1hdGgubWF4KGNoYXJ0QXJlYVtwb3NdLCBtYXhQYWRkaW5nW3Bvc10pO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gbWFyZ2luO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGhvcml6b250YWxcclxuXHRcdD8gbWFyZ2luRm9yUG9zaXRpb25zKFsnbGVmdCcsICdyaWdodCddKVxyXG5cdFx0OiBtYXJnaW5Gb3JQb3NpdGlvbnMoWyd0b3AnLCAnYm90dG9tJ10pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaXRCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMpIHtcclxuXHR2YXIgcmVmaXRCb3hlcyA9IFtdO1xyXG5cdHZhciBpLCBpbGVuLCBsYXlvdXQsIGJveCwgcmVmaXQsIGNoYW5nZWQ7XHJcblxyXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBib3hlcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdGxheW91dCA9IGJveGVzW2ldO1xyXG5cdFx0Ym94ID0gbGF5b3V0LmJveDtcclxuXHJcblx0XHRib3gudXBkYXRlKFxyXG5cdFx0XHRsYXlvdXQud2lkdGggfHwgY2hhcnRBcmVhLncsXHJcblx0XHRcdGxheW91dC5oZWlnaHQgfHwgY2hhcnRBcmVhLmgsXHJcblx0XHRcdGdldE1hcmdpbnMobGF5b3V0Lmhvcml6b250YWwsIGNoYXJ0QXJlYSlcclxuXHRcdCk7XHJcblx0XHRpZiAodXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0KSkge1xyXG5cdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcclxuXHRcdFx0aWYgKHJlZml0Qm94ZXMubGVuZ3RoKSB7XHJcblx0XHRcdFx0Ly8gRGltZW5zaW9ucyBjaGFuZ2VkIGFuZCB0aGVyZSB3ZXJlIG5vbiBmdWxsIHdpZHRoIGJveGVzIGJlZm9yZSB0aGlzXHJcblx0XHRcdFx0Ly8gLT4gd2UgaGF2ZSB0byByZWZpdCB0aG9zZVxyXG5cdFx0XHRcdHJlZml0ID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKCFib3guZnVsbFdpZHRoKSB7IC8vIGZ1bGxXaWR0aCBib3hlcyBkb24ndCBuZWVkIHRvIGJlIHJlLWZpdHRlZCBpbiBhbnkgY2FzZVxyXG5cdFx0XHRyZWZpdEJveGVzLnB1c2gobGF5b3V0KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiByZWZpdCA/IGZpdEJveGVzKHJlZml0Qm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zKSB8fCBjaGFuZ2VkIDogY2hhbmdlZDtcclxufVxyXG5cclxuZnVuY3Rpb24gcGxhY2VCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMpIHtcclxuXHR2YXIgdXNlclBhZGRpbmcgPSBwYXJhbXMucGFkZGluZztcclxuXHR2YXIgeCA9IGNoYXJ0QXJlYS54O1xyXG5cdHZhciB5ID0gY2hhcnRBcmVhLnk7XHJcblx0dmFyIGksIGlsZW4sIGxheW91dCwgYm94O1xyXG5cclxuXHRmb3IgKGkgPSAwLCBpbGVuID0gYm94ZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRsYXlvdXQgPSBib3hlc1tpXTtcclxuXHRcdGJveCA9IGxheW91dC5ib3g7XHJcblx0XHRpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcclxuXHRcdFx0Ym94LmxlZnQgPSBib3guZnVsbFdpZHRoID8gdXNlclBhZGRpbmcubGVmdCA6IGNoYXJ0QXJlYS5sZWZ0O1xyXG5cdFx0XHRib3gucmlnaHQgPSBib3guZnVsbFdpZHRoID8gcGFyYW1zLm91dGVyV2lkdGggLSB1c2VyUGFkZGluZy5yaWdodCA6IGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnc7XHJcblx0XHRcdGJveC50b3AgPSB5O1xyXG5cdFx0XHRib3guYm90dG9tID0geSArIGJveC5oZWlnaHQ7XHJcblx0XHRcdGJveC53aWR0aCA9IGJveC5yaWdodCAtIGJveC5sZWZ0O1xyXG5cdFx0XHR5ID0gYm94LmJvdHRvbTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGJveC5sZWZ0ID0geDtcclxuXHRcdFx0Ym94LnJpZ2h0ID0geCArIGJveC53aWR0aDtcclxuXHRcdFx0Ym94LnRvcCA9IGNoYXJ0QXJlYS50b3A7XHJcblx0XHRcdGJveC5ib3R0b20gPSBjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmg7XHJcblx0XHRcdGJveC5oZWlnaHQgPSBib3guYm90dG9tIC0gYm94LnRvcDtcclxuXHRcdFx0eCA9IGJveC5yaWdodDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGNoYXJ0QXJlYS54ID0geDtcclxuXHRjaGFydEFyZWEueSA9IHk7XHJcbn1cclxuXHJcbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xyXG5cdGxheW91dDoge1xyXG5cdFx0cGFkZGluZzoge1xyXG5cdFx0XHR0b3A6IDAsXHJcblx0XHRcdHJpZ2h0OiAwLFxyXG5cdFx0XHRib3R0b206IDAsXHJcblx0XHRcdGxlZnQ6IDBcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBpbnRlcmZhY2UgSUxheW91dEl0ZW1cclxuICogQHByb3Age3N0cmluZ30gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gaW4gdGhlIGNoYXJ0IGxheW91dC4gUG9zc2libGUgdmFsdWVzIGFyZVxyXG4gKiAnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgYW5kICdjaGFydEFyZWEnXHJcbiAqIEBwcm9wIHtudW1iZXJ9IHdlaWdodCAtIFRoZSB3ZWlnaHQgdXNlZCB0byBzb3J0IHRoZSBpdGVtLiBIaWdoZXIgd2VpZ2h0cyBhcmUgZnVydGhlciBhd2F5IGZyb20gdGhlIGNoYXJ0IGFyZWFcclxuICogQHByb3Age2Jvb2xlYW59IGZ1bGxXaWR0aCAtIGlmIHRydWUsIGFuZCB0aGUgaXRlbSBpcyBob3Jpem9udGFsLCB0aGVuIHB1c2ggdmVydGljYWwgYm94ZXMgZG93blxyXG4gKiBAcHJvcCB7ZnVuY3Rpb259IGlzSG9yaXpvbnRhbCAtIHJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5b3V0IGl0ZW0gaXMgaG9yaXpvbnRhbCAoaWUuIHRvcCBvciBib3R0b20pXHJcbiAqIEBwcm9wIHtmdW5jdGlvbn0gdXBkYXRlIC0gVGFrZXMgdHdvIHBhcmFtZXRlcnM6IHdpZHRoIGFuZCBoZWlnaHQuIFJldHVybnMgc2l6ZSBvZiBpdGVtXHJcbiAqIEBwcm9wIHtmdW5jdGlvbn0gZ2V0UGFkZGluZyAtICBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHBhZGRpbmcgb24gdGhlIGVkZ2VzXHJcbiAqIEBwcm9wIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgaXRlbS4gTXVzdCBiZSB2YWxpZCBhZnRlciB1cGRhdGUoKVxyXG4gKiBAcHJvcCB7bnVtYmVyfSBoZWlnaHQgLSBIZWlnaHQgb2YgaXRlbS4gTXVzdCBiZSB2YWxpZCBhZnRlciB1cGRhdGUoKVxyXG4gKiBAcHJvcCB7bnVtYmVyfSBsZWZ0IC0gTGVmdCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXHJcbiAqIEBwcm9wIHtudW1iZXJ9IHRvcCAtIFRvcCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXHJcbiAqIEBwcm9wIHtudW1iZXJ9IHJpZ2h0IC0gUmlnaHQgZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxyXG4gKiBAcHJvcCB7bnVtYmVyfSBib3R0b20gLSBCb3R0b20gZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxyXG4gKi9cclxuXHJcbi8vIFRoZSBsYXlvdXQgc2VydmljZSBpcyB2ZXJ5IHNlbGYgZXhwbGFuYXRvcnkuICBJdCdzIHJlc3BvbnNpYmxlIGZvciB0aGUgbGF5b3V0IHdpdGhpbiBhIGNoYXJ0LlxyXG4vLyBTY2FsZXMsIExlZ2VuZHMgYW5kIFBsdWdpbnMgYWxsIHJlbHkgb24gdGhlIGxheW91dCBzZXJ2aWNlIGFuZCBjYW4gZWFzaWx5IHJlZ2lzdGVyIHRvIGJlIHBsYWNlZCBhbnl3aGVyZSB0aGV5IG5lZWRcclxuLy8gSXQgaXMgdGhpcyBzZXJ2aWNlJ3MgcmVzcG9uc2liaWxpdHkgb2YgY2Fycnlpbmcgb3V0IHRoYXQgbGF5b3V0LlxyXG52YXIgY29yZV9sYXlvdXRzID0ge1xyXG5cdGRlZmF1bHRzOiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVnaXN0ZXIgYSBib3ggdG8gYSBjaGFydC5cclxuXHQgKiBBIGJveCBpcyBzaW1wbHkgYSByZWZlcmVuY2UgdG8gYW4gb2JqZWN0IHRoYXQgcmVxdWlyZXMgbGF5b3V0LiBlZy4gU2NhbGVzLCBMZWdlbmQsIFRpdGxlLlxyXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIHVzZVxyXG5cdCAqIEBwYXJhbSB7SUxheW91dEl0ZW19IGl0ZW0gLSB0aGUgaXRlbSB0byBhZGQgdG8gYmUgbGF5ZWQgb3V0XHJcblx0ICovXHJcblx0YWRkQm94OiBmdW5jdGlvbihjaGFydCwgaXRlbSkge1xyXG5cdFx0aWYgKCFjaGFydC5ib3hlcykge1xyXG5cdFx0XHRjaGFydC5ib3hlcyA9IFtdO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGluaXRpYWxpemUgaXRlbSB3aXRoIGRlZmF1bHQgdmFsdWVzXHJcblx0XHRpdGVtLmZ1bGxXaWR0aCA9IGl0ZW0uZnVsbFdpZHRoIHx8IGZhbHNlO1xyXG5cdFx0aXRlbS5wb3NpdGlvbiA9IGl0ZW0ucG9zaXRpb24gfHwgJ3RvcCc7XHJcblx0XHRpdGVtLndlaWdodCA9IGl0ZW0ud2VpZ2h0IHx8IDA7XHJcblx0XHRpdGVtLl9sYXllcnMgPSBpdGVtLl9sYXllcnMgfHwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiBbe1xyXG5cdFx0XHRcdHo6IDAsXHJcblx0XHRcdFx0ZHJhdzogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRpdGVtLmRyYXcuYXBwbHkoaXRlbSwgYXJndW1lbnRzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1dO1xyXG5cdFx0fTtcclxuXHJcblx0XHRjaGFydC5ib3hlcy5wdXNoKGl0ZW0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZSBhIGxheW91dEl0ZW0gZnJvbSBhIGNoYXJ0XHJcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gcmVtb3ZlIHRoZSBib3ggZnJvbVxyXG5cdCAqIEBwYXJhbSB7SUxheW91dEl0ZW19IGxheW91dEl0ZW0gLSB0aGUgaXRlbSB0byByZW1vdmUgZnJvbSB0aGUgbGF5b3V0XHJcblx0ICovXHJcblx0cmVtb3ZlQm94OiBmdW5jdGlvbihjaGFydCwgbGF5b3V0SXRlbSkge1xyXG5cdFx0dmFyIGluZGV4ID0gY2hhcnQuYm94ZXMgPyBjaGFydC5ib3hlcy5pbmRleE9mKGxheW91dEl0ZW0pIDogLTE7XHJcblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XHJcblx0XHRcdGNoYXJ0LmJveGVzLnNwbGljZShpbmRleCwgMSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyAob3IgdXBkYXRlcykgb3B0aW9ucyBvbiB0aGUgZ2l2ZW4gYGl0ZW1gLlxyXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IGluIHdoaWNoIHRoZSBpdGVtIGxpdmVzIChvciB3aWxsIGJlIGFkZGVkIHRvKVxyXG5cdCAqIEBwYXJhbSB7SUxheW91dEl0ZW19IGl0ZW0gLSB0aGUgaXRlbSB0byBjb25maWd1cmUgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gdGhlIG5ldyBpdGVtIG9wdGlvbnMuXHJcblx0ICovXHJcblx0Y29uZmlndXJlOiBmdW5jdGlvbihjaGFydCwgaXRlbSwgb3B0aW9ucykge1xyXG5cdFx0dmFyIHByb3BzID0gWydmdWxsV2lkdGgnLCAncG9zaXRpb24nLCAnd2VpZ2h0J107XHJcblx0XHR2YXIgaWxlbiA9IHByb3BzLmxlbmd0aDtcclxuXHRcdHZhciBpID0gMDtcclxuXHRcdHZhciBwcm9wO1xyXG5cclxuXHRcdGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdHByb3AgPSBwcm9wc1tpXTtcclxuXHRcdFx0aWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcclxuXHRcdFx0XHRpdGVtW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEZpdHMgYm94ZXMgb2YgdGhlIGdpdmVuIGNoYXJ0IGludG8gdGhlIGdpdmVuIHNpemUgYnkgaGF2aW5nIGVhY2ggYm94IG1lYXN1cmUgaXRzZWxmXHJcblx0ICogdGhlbiBydW5uaW5nIGEgZml0dGluZyBhbGdvcml0aG1cclxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSB3aWR0aCB0byBmaXQgaW50b1xyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSB0aGUgaGVpZ2h0IHRvIGZpdCBpbnRvXHJcblx0ICovXHJcblx0dXBkYXRlOiBmdW5jdGlvbihjaGFydCwgd2lkdGgsIGhlaWdodCkge1xyXG5cdFx0aWYgKCFjaGFydCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGxheW91dE9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmxheW91dCB8fCB7fTtcclxuXHRcdHZhciBwYWRkaW5nID0gaGVscGVycyQxLm9wdGlvbnMudG9QYWRkaW5nKGxheW91dE9wdGlvbnMucGFkZGluZyk7XHJcblxyXG5cdFx0dmFyIGF2YWlsYWJsZVdpZHRoID0gd2lkdGggLSBwYWRkaW5nLndpZHRoO1xyXG5cdFx0dmFyIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0O1xyXG5cdFx0dmFyIGJveGVzID0gYnVpbGRMYXlvdXRCb3hlcyhjaGFydC5ib3hlcyk7XHJcblx0XHR2YXIgdmVydGljYWxCb3hlcyA9IGJveGVzLnZlcnRpY2FsO1xyXG5cdFx0dmFyIGhvcml6b250YWxCb3hlcyA9IGJveGVzLmhvcml6b250YWw7XHJcblxyXG5cdFx0Ly8gRXNzZW50aWFsbHkgd2Ugbm93IGhhdmUgYW55IG51bWJlciBvZiBib3hlcyBvbiBlYWNoIG9mIHRoZSA0IHNpZGVzLlxyXG5cdFx0Ly8gT3VyIGNhbnZhcyBsb29rcyBsaWtlIHRoZSBmb2xsb3dpbmcuXHJcblx0XHQvLyBUaGUgYXJlYXMgTDEgYW5kIEwyIGFyZSB0aGUgbGVmdCBheGVzLiBSMSBpcyB0aGUgcmlnaHQgYXhpcywgVDEgaXMgdGhlIHRvcCBheGlzIGFuZFxyXG5cdFx0Ly8gQjEgaXMgdGhlIGJvdHRvbSBheGlzXHJcblx0XHQvLyBUaGVyZSBhcmUgYWxzbyA0IHF1YWRyYW50LWxpa2UgbG9jYXRpb25zIChsZWZ0IHRvIHJpZ2h0IGluc3RlYWQgb2YgY2xvY2t3aXNlKSByZXNlcnZlZCBmb3IgY2hhcnQgb3ZlcmxheXNcclxuXHRcdC8vIFRoZXNlIGxvY2F0aW9ucyBhcmUgc2luZ2xlLWJveCBsb2NhdGlvbnMgb25seSwgd2hlbiB0cnlpbmcgdG8gcmVnaXN0ZXIgYSBjaGFydEFyZWEgbG9jYXRpb24gdGhhdCBpcyBhbHJlYWR5IHRha2VuLFxyXG5cdFx0Ly8gYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXHJcblx0XHQvL1xyXG5cdFx0Ly8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XHJcblx0XHQvLyB8ICAgICAgICAgICAgICAgICAgVDEgKEZ1bGwgV2lkdGgpICAgICAgICAgICAgICAgICAgIHxcclxuXHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxyXG5cdFx0Ly8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgIFQyICAgICAgICAgICAgICAgICAgfCAgICB8XHJcblx0XHQvLyB8ICAgIHwtLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLXxcclxuXHRcdC8vIHwgICAgfCAgICB8IEMxIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEMyIHwgICAgfFxyXG5cdFx0Ly8gfCAgICB8ICAgIHwtLS0tfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwtLS0tfCAgICB8XHJcblx0XHQvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHxcclxuXHRcdC8vIHwgTDEgfCBMMiB8ICAgICAgICAgICBDaGFydEFyZWEgKEMwKSAgICAgICAgICAgIHwgUjEgfFxyXG5cdFx0Ly8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICB8XHJcblx0XHQvLyB8ICAgIHwgICAgfC0tLS18ICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLS18ICAgIHxcclxuXHRcdC8vIHwgICAgfCAgICB8IEMzIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEM0IHwgICAgfFxyXG5cdFx0Ly8gfCAgICB8LS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS18XHJcblx0XHQvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgQjEgICAgICAgICAgICAgICAgICB8ICAgIHxcclxuXHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxyXG5cdFx0Ly8gfCAgICAgICAgICAgICAgICAgIEIyIChGdWxsIFdpZHRoKSAgICAgICAgICAgICAgICAgICB8XHJcblx0XHQvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcclxuXHRcdC8vXHJcblxyXG5cdFx0dmFyIHBhcmFtcyA9IE9iamVjdC5mcmVlemUoe1xyXG5cdFx0XHRvdXRlcldpZHRoOiB3aWR0aCxcclxuXHRcdFx0b3V0ZXJIZWlnaHQ6IGhlaWdodCxcclxuXHRcdFx0cGFkZGluZzogcGFkZGluZyxcclxuXHRcdFx0YXZhaWxhYmxlV2lkdGg6IGF2YWlsYWJsZVdpZHRoLFxyXG5cdFx0XHR2Qm94TWF4V2lkdGg6IGF2YWlsYWJsZVdpZHRoIC8gMiAvIHZlcnRpY2FsQm94ZXMubGVuZ3RoLFxyXG5cdFx0XHRoQm94TWF4SGVpZ2h0OiBhdmFpbGFibGVIZWlnaHQgLyAyXHJcblx0XHR9KTtcclxuXHRcdHZhciBjaGFydEFyZWEgPSBleHRlbmQoe1xyXG5cdFx0XHRtYXhQYWRkaW5nOiBleHRlbmQoe30sIHBhZGRpbmcpLFxyXG5cdFx0XHR3OiBhdmFpbGFibGVXaWR0aCxcclxuXHRcdFx0aDogYXZhaWxhYmxlSGVpZ2h0LFxyXG5cdFx0XHR4OiBwYWRkaW5nLmxlZnQsXHJcblx0XHRcdHk6IHBhZGRpbmcudG9wXHJcblx0XHR9LCBwYWRkaW5nKTtcclxuXHJcblx0XHRzZXRMYXlvdXREaW1zKHZlcnRpY2FsQm94ZXMuY29uY2F0KGhvcml6b250YWxCb3hlcyksIHBhcmFtcyk7XHJcblxyXG5cdFx0Ly8gRmlyc3QgZml0IHZlcnRpY2FsIGJveGVzXHJcblx0XHRmaXRCb3hlcyh2ZXJ0aWNhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcyk7XHJcblxyXG5cdFx0Ly8gVGhlbiBmaXQgaG9yaXpvbnRhbCBib3hlc1xyXG5cdFx0aWYgKGZpdEJveGVzKGhvcml6b250YWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMpKSB7XHJcblx0XHRcdC8vIGlmIHRoZSBhcmVhIGNoYW5nZWQsIHJlLWZpdCB2ZXJ0aWNhbCBib3hlc1xyXG5cdFx0XHRmaXRCb3hlcyh2ZXJ0aWNhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aGFuZGxlTWF4UGFkZGluZyhjaGFydEFyZWEpO1xyXG5cclxuXHRcdC8vIEZpbmFsbHkgcGxhY2UgdGhlIGJveGVzIHRvIGNvcnJlY3QgY29vcmRpbmF0ZXNcclxuXHRcdHBsYWNlQm94ZXMoYm94ZXMubGVmdEFuZFRvcCwgY2hhcnRBcmVhLCBwYXJhbXMpO1xyXG5cclxuXHRcdC8vIE1vdmUgdG8gb3Bwb3NpdGUgc2lkZSBvZiBjaGFydFxyXG5cdFx0Y2hhcnRBcmVhLnggKz0gY2hhcnRBcmVhLnc7XHJcblx0XHRjaGFydEFyZWEueSArPSBjaGFydEFyZWEuaDtcclxuXHJcblx0XHRwbGFjZUJveGVzKGJveGVzLnJpZ2h0QW5kQm90dG9tLCBjaGFydEFyZWEsIHBhcmFtcyk7XHJcblxyXG5cdFx0Y2hhcnQuY2hhcnRBcmVhID0ge1xyXG5cdFx0XHRsZWZ0OiBjaGFydEFyZWEubGVmdCxcclxuXHRcdFx0dG9wOiBjaGFydEFyZWEudG9wLFxyXG5cdFx0XHRyaWdodDogY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEudyxcclxuXHRcdFx0Ym90dG9tOiBjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmhcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gRmluYWxseSB1cGRhdGUgYm94ZXMgaW4gY2hhcnRBcmVhIChyYWRpYWwgc2NhbGUgZm9yIGV4YW1wbGUpXHJcblx0XHRoZWxwZXJzJDEuZWFjaChib3hlcy5jaGFydEFyZWEsIGZ1bmN0aW9uKGxheW91dCkge1xyXG5cdFx0XHR2YXIgYm94ID0gbGF5b3V0LmJveDtcclxuXHRcdFx0ZXh0ZW5kKGJveCwgY2hhcnQuY2hhcnRBcmVhKTtcclxuXHRcdFx0Ym94LnVwZGF0ZShjaGFydEFyZWEudywgY2hhcnRBcmVhLmgpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xuXG4vKipcclxuICogUGxhdGZvcm0gZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gKG1pbmltYWwpLlxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDU5MSNpc3N1ZWNvbW1lbnQtMzE5NTc1OTM5XHJcbiAqL1xyXG5cclxudmFyIHBsYXRmb3JtX2Jhc2ljID0ge1xyXG5cdGFjcXVpcmVDb250ZXh0OiBmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xyXG5cdFx0XHQvLyBTdXBwb3J0IGZvciBhbnkgb2JqZWN0IGFzc29jaWF0ZWQgdG8gYSBjYW52YXMgKGluY2x1ZGluZyBhIGNvbnRleHQyZClcclxuXHRcdFx0aXRlbSA9IGl0ZW0uY2FudmFzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpdGVtICYmIGl0ZW0uZ2V0Q29udGV4dCgnMmQnKSB8fCBudWxsO1xyXG5cdH1cclxufTtcblxudmFyIHBsYXRmb3JtX2RvbSA9IFwiLypcXHJcXG4gKiBET00gZWxlbWVudCByZW5kZXJpbmcgZGV0ZWN0aW9uXFxyXFxuICogaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvZGV0ZWN0LW5vZGUtaW5zZXJ0aW9uXFxyXFxuICovXFxyXFxuQGtleWZyYW1lcyBjaGFydGpzLXJlbmRlci1hbmltYXRpb24ge1xcclxcblxcdGZyb20geyBvcGFjaXR5OiAwLjk5OyB9XFxyXFxuXFx0dG8geyBvcGFjaXR5OiAxOyB9XFxyXFxufVxcclxcblxcclxcbi5jaGFydGpzLXJlbmRlci1tb25pdG9yIHtcXHJcXG5cXHRhbmltYXRpb246IGNoYXJ0anMtcmVuZGVyLWFuaW1hdGlvbiAwLjAwMXM7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuICogRE9NIGVsZW1lbnQgcmVzaXppbmcgZGV0ZWN0aW9uXFxyXFxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcmNqL2Nzcy1lbGVtZW50LXF1ZXJpZXNcXHJcXG4gKi9cXHJcXG4uY2hhcnRqcy1zaXplLW1vbml0b3IsXFxyXFxuLmNoYXJ0anMtc2l6ZS1tb25pdG9yLWV4cGFuZCxcXHJcXG4uY2hhcnRqcy1zaXplLW1vbml0b3Itc2hyaW5rIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0ZGlyZWN0aW9uOiBsdHI7XFxyXFxuXFx0bGVmdDogMDtcXHJcXG5cXHR0b3A6IDA7XFxyXFxuXFx0cmlnaHQ6IDA7XFxyXFxuXFx0Ym90dG9tOiAwO1xcclxcblxcdG92ZXJmbG93OiBoaWRkZW47XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuXFx0dmlzaWJpbGl0eTogaGlkZGVuO1xcclxcblxcdHotaW5kZXg6IC0xO1xcclxcbn1cXHJcXG5cXHJcXG4uY2hhcnRqcy1zaXplLW1vbml0b3ItZXhwYW5kID4gZGl2IHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0d2lkdGg6IDEwMDAwMDBweDtcXHJcXG5cXHRoZWlnaHQ6IDEwMDAwMDBweDtcXHJcXG5cXHRsZWZ0OiAwO1xcclxcblxcdHRvcDogMDtcXHJcXG59XFxyXFxuXFxyXFxuLmNoYXJ0anMtc2l6ZS1tb25pdG9yLXNocmluayA+IGRpdiB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdHdpZHRoOiAyMDAlO1xcclxcblxcdGhlaWdodDogMjAwJTtcXHJcXG5cXHRsZWZ0OiAwO1xcclxcblxcdHRvcDogMDtcXHJcXG59XFxyXFxuXCI7XG5cbnZhciBwbGF0Zm9ybV9kb20kMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbidkZWZhdWx0JzogcGxhdGZvcm1fZG9tXG59KTtcblxudmFyIHN0eWxlc2hlZXQgPSBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlKHBsYXRmb3JtX2RvbSQxKTtcblxudmFyIEVYUEFORE9fS0VZID0gJyRjaGFydGpzJztcclxudmFyIENTU19QUkVGSVggPSAnY2hhcnRqcy0nO1xyXG52YXIgQ1NTX1NJWkVfTU9OSVRPUiA9IENTU19QUkVGSVggKyAnc2l6ZS1tb25pdG9yJztcclxudmFyIENTU19SRU5ERVJfTU9OSVRPUiA9IENTU19QUkVGSVggKyAncmVuZGVyLW1vbml0b3InO1xyXG52YXIgQ1NTX1JFTkRFUl9BTklNQVRJT04gPSBDU1NfUFJFRklYICsgJ3JlbmRlci1hbmltYXRpb24nO1xyXG52YXIgQU5JTUFUSU9OX1NUQVJUX0VWRU5UUyA9IFsnYW5pbWF0aW9uc3RhcnQnLCAnd2Via2l0QW5pbWF0aW9uU3RhcnQnXTtcclxuXHJcbi8qKlxyXG4gKiBET00gZXZlbnQgdHlwZXMgLT4gQ2hhcnQuanMgZXZlbnQgdHlwZXMuXHJcbiAqIE5vdGU6IG9ubHkgZXZlbnRzIHdpdGggZGlmZmVyZW50IHR5cGVzIGFyZSBtYXBwZWQuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzXHJcbiAqL1xyXG52YXIgRVZFTlRfVFlQRVMgPSB7XHJcblx0dG91Y2hzdGFydDogJ21vdXNlZG93bicsXHJcblx0dG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcclxuXHR0b3VjaGVuZDogJ21vdXNldXAnLFxyXG5cdHBvaW50ZXJlbnRlcjogJ21vdXNlZW50ZXInLFxyXG5cdHBvaW50ZXJkb3duOiAnbW91c2Vkb3duJyxcclxuXHRwb2ludGVybW92ZTogJ21vdXNlbW92ZScsXHJcblx0cG9pbnRlcnVwOiAnbW91c2V1cCcsXHJcblx0cG9pbnRlcmxlYXZlOiAnbW91c2VvdXQnLFxyXG5cdHBvaW50ZXJvdXQ6ICdtb3VzZW91dCdcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgXCJ1c2VkXCIgc2l6ZSBpcyB0aGUgZmluYWwgdmFsdWUgb2YgYSBkaW1lbnNpb24gcHJvcGVydHkgYWZ0ZXIgYWxsIGNhbGN1bGF0aW9ucyBoYXZlXHJcbiAqIGJlZW4gcGVyZm9ybWVkLiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBjb21wdXRlZCBzdHlsZSBvZiBgZWxlbWVudGAgYnV0IHJldHVybnMgdW5kZWZpbmVkXHJcbiAqIGlmIHRoZSBjb21wdXRlZCBzdHlsZSBpcyBub3QgZXhwcmVzc2VkIGluIHBpeGVscy4gVGhhdCBjYW4gaGFwcGVuIGluIHNvbWUgY2FzZXMgd2hlcmVcclxuICogYGVsZW1lbnRgIGhhcyBhIHNpemUgcmVsYXRpdmUgdG8gaXRzIHBhcmVudCBhbmQgdGhpcyBsYXN0IG9uZSBpcyBub3QgeWV0IGRpc3BsYXllZCxcclxuICogZm9yIGV4YW1wbGUgYmVjYXVzZSBvZiBgZGlzcGxheTogbm9uZWAgb24gYSBwYXJlbnQgbm9kZS5cclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvdXNlZF92YWx1ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBTaXplIGluIHBpeGVscyBvciB1bmRlZmluZWQgaWYgdW5rbm93bi5cclxuICovXHJcbmZ1bmN0aW9uIHJlYWRVc2VkU2l6ZShlbGVtZW50LCBwcm9wZXJ0eSkge1xyXG5cdHZhciB2YWx1ZSA9IGhlbHBlcnMkMS5nZXRTdHlsZShlbGVtZW50LCBwcm9wZXJ0eSk7XHJcblx0dmFyIG1hdGNoZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXihcXGQrKShcXC5cXGQrKT9weCQvKTtcclxuXHRyZXR1cm4gbWF0Y2hlcyA/IE51bWJlcihtYXRjaGVzWzFdKSA6IHVuZGVmaW5lZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemVzIHRoZSBjYW52YXMgc3R5bGUgYW5kIHJlbmRlciBzaXplIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBjYW52YXMgZGlzcGxheSBzaXplLFxyXG4gKiBzaW5jZSByZXNwb25zaXZlbmVzcyBpcyBoYW5kbGVkIGJ5IHRoZSBjb250cm9sbGVyLnJlc2l6ZSgpIG1ldGhvZC4gVGhlIGNvbmZpZyBpcyB1c2VkXHJcbiAqIHRvIGRldGVybWluZSB0aGUgYXNwZWN0IHJhdGlvIHRvIGFwcGx5IGluIGNhc2Ugbm8gZXhwbGljaXQgaGVpZ2h0IGhhcyBiZWVuIHNwZWNpZmllZC5cclxuICovXHJcbmZ1bmN0aW9uIGluaXRDYW52YXMoY2FudmFzLCBjb25maWcpIHtcclxuXHR2YXIgc3R5bGUgPSBjYW52YXMuc3R5bGU7XHJcblxyXG5cdC8vIE5PVEUoU0IpIGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgIT09IGNhbnZhcy53aWR0aDogaW4gdGhlIGZpcnN0IGNhc2UgaXRcclxuXHQvLyByZXR1cm5zIG51bGwgb3IgJycgaWYgbm8gZXhwbGljaXQgdmFsdWUgaGFzIGJlZW4gc2V0IHRvIHRoZSBjYW52YXMgYXR0cmlidXRlLlxyXG5cdHZhciByZW5kZXJIZWlnaHQgPSBjYW52YXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKTtcclxuXHR2YXIgcmVuZGVyV2lkdGggPSBjYW52YXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xyXG5cclxuXHQvLyBDaGFydC5qcyBtb2RpZmllcyBzb21lIGNhbnZhcyB2YWx1ZXMgdGhhdCB3ZSB3YW50IHRvIHJlc3RvcmUgb24gZGVzdHJveVxyXG5cdGNhbnZhc1tFWFBBTkRPX0tFWV0gPSB7XHJcblx0XHRpbml0aWFsOiB7XHJcblx0XHRcdGhlaWdodDogcmVuZGVySGVpZ2h0LFxyXG5cdFx0XHR3aWR0aDogcmVuZGVyV2lkdGgsXHJcblx0XHRcdHN0eWxlOiB7XHJcblx0XHRcdFx0ZGlzcGxheTogc3R5bGUuZGlzcGxheSxcclxuXHRcdFx0XHRoZWlnaHQ6IHN0eWxlLmhlaWdodCxcclxuXHRcdFx0XHR3aWR0aDogc3R5bGUud2lkdGhcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8vIEZvcmNlIGNhbnZhcyB0byBkaXNwbGF5IGFzIGJsb2NrIHRvIGF2b2lkIGV4dHJhIHNwYWNlIGNhdXNlZCBieSBpbmxpbmVcclxuXHQvLyBlbGVtZW50cywgd2hpY2ggd291bGQgaW50ZXJmZXJlIHdpdGggdGhlIHJlc3BvbnNpdmUgcmVzaXplIHByb2Nlc3MuXHJcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI1MzhcclxuXHRzdHlsZS5kaXNwbGF5ID0gc3R5bGUuZGlzcGxheSB8fCAnYmxvY2snO1xyXG5cclxuXHRpZiAocmVuZGVyV2lkdGggPT09IG51bGwgfHwgcmVuZGVyV2lkdGggPT09ICcnKSB7XHJcblx0XHR2YXIgZGlzcGxheVdpZHRoID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ3dpZHRoJyk7XHJcblx0XHRpZiAoZGlzcGxheVdpZHRoICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Y2FudmFzLndpZHRoID0gZGlzcGxheVdpZHRoO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0aWYgKHJlbmRlckhlaWdodCA9PT0gbnVsbCB8fCByZW5kZXJIZWlnaHQgPT09ICcnKSB7XHJcblx0XHRpZiAoY2FudmFzLnN0eWxlLmhlaWdodCA9PT0gJycpIHtcclxuXHRcdFx0Ly8gSWYgbm8gZXhwbGljaXQgcmVuZGVyIGhlaWdodCBhbmQgc3R5bGUgaGVpZ2h0LCBsZXQncyBhcHBseSB0aGUgYXNwZWN0IHJhdGlvLFxyXG5cdFx0XHQvLyB3aGljaCBvbmUgY2FuIGJlIHNwZWNpZmllZCBieSB0aGUgdXNlciBidXQgYWxzbyBieSBjaGFydHMgYXMgZGVmYXVsdCBvcHRpb25cclxuXHRcdFx0Ly8gKGkuZS4gb3B0aW9ucy5hc3BlY3RSYXRpbykuIElmIG5vdCBzcGVjaWZpZWQsIHVzZSBjYW52YXMgYXNwZWN0IHJhdGlvIG9mIDIuXHJcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBjYW52YXMud2lkdGggLyAoY29uZmlnLm9wdGlvbnMuYXNwZWN0UmF0aW8gfHwgMik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgZGlzcGxheUhlaWdodCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICdoZWlnaHQnKTtcclxuXHRcdFx0aWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IGRpc3BsYXlIZWlnaHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBjYW52YXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXRlY3RzIHN1cHBvcnQgZm9yIG9wdGlvbnMgb2JqZWN0IGFyZ3VtZW50IGluIGFkZEV2ZW50TGlzdGVuZXIuXHJcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyI1NhZmVseV9kZXRlY3Rpbmdfb3B0aW9uX3N1cHBvcnRcclxuICogQHByaXZhdGVcclxuICovXHJcbnZhciBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID0gKGZ1bmN0aW9uKCkge1xyXG5cdHZhciBzdXBwb3J0cyA9IGZhbHNlO1xyXG5cdHRyeSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XHJcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnZXR0ZXItcmV0dXJuXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0c3VwcG9ydHMgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlJywgbnVsbCwgb3B0aW9ucyk7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0Ly8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxyXG5cdH1cclxuXHRyZXR1cm4gc3VwcG9ydHM7XHJcbn0oKSk7XHJcblxyXG4vLyBEZWZhdWx0IHBhc3NpdmUgdG8gdHJ1ZSBhcyBleHBlY3RlZCBieSBDaHJvbWUgZm9yICd0b3VjaHN0YXJ0JyBhbmQgJ3RvdWNoZW5kJyBldmVudHMuXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80Mjg3XHJcbnZhciBldmVudExpc3RlbmVyT3B0aW9ucyA9IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcclxuXHJcbmZ1bmN0aW9uIGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XHJcblx0bm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XHJcblx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50KHR5cGUsIGNoYXJ0LCB4LCB5LCBuYXRpdmVFdmVudCkge1xyXG5cdHJldHVybiB7XHJcblx0XHR0eXBlOiB0eXBlLFxyXG5cdFx0Y2hhcnQ6IGNoYXJ0LFxyXG5cdFx0bmF0aXZlOiBuYXRpdmVFdmVudCB8fCBudWxsLFxyXG5cdFx0eDogeCAhPT0gdW5kZWZpbmVkID8geCA6IG51bGwsXHJcblx0XHR5OiB5ICE9PSB1bmRlZmluZWQgPyB5IDogbnVsbCxcclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSB7XHJcblx0dmFyIHR5cGUgPSBFVkVOVF9UWVBFU1tldmVudC50eXBlXSB8fCBldmVudC50eXBlO1xyXG5cdHZhciBwb3MgPSBoZWxwZXJzJDEuZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudCwgY2hhcnQpO1xyXG5cdHJldHVybiBjcmVhdGVFdmVudCh0eXBlLCBjaGFydCwgcG9zLngsIHBvcy55LCBldmVudCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRocm90dGxlZChmbiwgdGhpc0FyZykge1xyXG5cdHZhciB0aWNraW5nID0gZmFsc2U7XHJcblx0dmFyIGFyZ3MgPSBbXTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcblx0XHR0aGlzQXJnID0gdGhpc0FyZyB8fCB0aGlzO1xyXG5cclxuXHRcdGlmICghdGlja2luZykge1xyXG5cdFx0XHR0aWNraW5nID0gdHJ1ZTtcclxuXHRcdFx0aGVscGVycyQxLnJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHRpY2tpbmcgPSBmYWxzZTtcclxuXHRcdFx0XHRmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlRGl2KGNscykge1xyXG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdGVsLmNsYXNzTmFtZSA9IGNscyB8fCAnJztcclxuXHRyZXR1cm4gZWw7XHJcbn1cclxuXHJcbi8vIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJjai9jc3MtZWxlbWVudC1xdWVyaWVzXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlc2l6ZXIoaGFuZGxlcikge1xyXG5cdHZhciBtYXhTaXplID0gMTAwMDAwMDtcclxuXHJcblx0Ly8gTk9URShTQikgRG9uJ3QgdXNlIGlubmVySFRNTCBiZWNhdXNlIGl0IGNvdWxkIGJlIGNvbnNpZGVyZWQgdW5zYWZlLlxyXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81OTAyXHJcblx0dmFyIHJlc2l6ZXIgPSBjcmVhdGVEaXYoQ1NTX1NJWkVfTU9OSVRPUik7XHJcblx0dmFyIGV4cGFuZCA9IGNyZWF0ZURpdihDU1NfU0laRV9NT05JVE9SICsgJy1leHBhbmQnKTtcclxuXHR2YXIgc2hyaW5rID0gY3JlYXRlRGl2KENTU19TSVpFX01PTklUT1IgKyAnLXNocmluaycpO1xyXG5cclxuXHRleHBhbmQuYXBwZW5kQ2hpbGQoY3JlYXRlRGl2KCkpO1xyXG5cdHNocmluay5hcHBlbmRDaGlsZChjcmVhdGVEaXYoKSk7XHJcblxyXG5cdHJlc2l6ZXIuYXBwZW5kQ2hpbGQoZXhwYW5kKTtcclxuXHRyZXNpemVyLmFwcGVuZENoaWxkKHNocmluayk7XHJcblx0cmVzaXplci5fcmVzZXQgPSBmdW5jdGlvbigpIHtcclxuXHRcdGV4cGFuZC5zY3JvbGxMZWZ0ID0gbWF4U2l6ZTtcclxuXHRcdGV4cGFuZC5zY3JvbGxUb3AgPSBtYXhTaXplO1xyXG5cdFx0c2hyaW5rLnNjcm9sbExlZnQgPSBtYXhTaXplO1xyXG5cdFx0c2hyaW5rLnNjcm9sbFRvcCA9IG1heFNpemU7XHJcblx0fTtcclxuXHJcblx0dmFyIG9uU2Nyb2xsID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXNpemVyLl9yZXNldCgpO1xyXG5cdFx0aGFuZGxlcigpO1xyXG5cdH07XHJcblxyXG5cdGFkZExpc3RlbmVyKGV4cGFuZCwgJ3Njcm9sbCcsIG9uU2Nyb2xsLmJpbmQoZXhwYW5kLCAnZXhwYW5kJykpO1xyXG5cdGFkZExpc3RlbmVyKHNocmluaywgJ3Njcm9sbCcsIG9uU2Nyb2xsLmJpbmQoc2hyaW5rLCAnc2hyaW5rJykpO1xyXG5cclxuXHRyZXR1cm4gcmVzaXplcjtcclxufVxyXG5cclxuLy8gaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvZGV0ZWN0LW5vZGUtaW5zZXJ0aW9uXHJcbmZ1bmN0aW9uIHdhdGNoRm9yUmVuZGVyKG5vZGUsIGhhbmRsZXIpIHtcclxuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IChub2RlW0VYUEFORE9fS0VZXSA9IHt9KTtcclxuXHR2YXIgcHJveHkgPSBleHBhbmRvLnJlbmRlclByb3h5ID0gZnVuY3Rpb24oZSkge1xyXG5cdFx0aWYgKGUuYW5pbWF0aW9uTmFtZSA9PT0gQ1NTX1JFTkRFUl9BTklNQVRJT04pIHtcclxuXHRcdFx0aGFuZGxlcigpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdGhlbHBlcnMkMS5lYWNoKEFOSU1BVElPTl9TVEFSVF9FVkVOVFMsIGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRcdGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIHByb3h5KTtcclxuXHR9KTtcclxuXHJcblx0Ly8gIzQ3Mzc6IENocm9tZSBtaWdodCBza2lwIHRoZSBDU1MgYW5pbWF0aW9uIHdoZW4gdGhlIENTU19SRU5ERVJfTU9OSVRPUiBjbGFzc1xyXG5cdC8vIGlzIHJlbW92ZWQgdGhlbiBhZGRlZCBiYWNrIGltbWVkaWF0ZWx5IChzYW1lIGFuaW1hdGlvbiBmcmFtZT8pLiBBY2Nlc3NpbmcgdGhlXHJcblx0Ly8gYG9mZnNldFBhcmVudGAgcHJvcGVydHkgd2lsbCBmb3JjZSBhIHJlZmxvdyBhbmQgcmUtZXZhbHVhdGUgdGhlIENTUyBhbmltYXRpb24uXHJcblx0Ly8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzVkNTJmYjA4MWIzNTcwYzgxZTNhI2JveC1tZXRyaWNzXHJcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQ3MzdcclxuXHRleHBhbmRvLnJlZmxvdyA9ICEhbm9kZS5vZmZzZXRQYXJlbnQ7XHJcblxyXG5cdG5vZGUuY2xhc3NMaXN0LmFkZChDU1NfUkVOREVSX01PTklUT1IpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1bndhdGNoRm9yUmVuZGVyKG5vZGUpIHtcclxuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IHt9O1xyXG5cdHZhciBwcm94eSA9IGV4cGFuZG8ucmVuZGVyUHJveHk7XHJcblxyXG5cdGlmIChwcm94eSkge1xyXG5cdFx0aGVscGVycyQxLmVhY2goQU5JTUFUSU9OX1NUQVJUX0VWRU5UUywgZnVuY3Rpb24odHlwZSkge1xyXG5cdFx0XHRyZW1vdmVMaXN0ZW5lcihub2RlLCB0eXBlLCBwcm94eSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRkZWxldGUgZXhwYW5kby5yZW5kZXJQcm94eTtcclxuXHR9XHJcblxyXG5cdG5vZGUuY2xhc3NMaXN0LnJlbW92ZShDU1NfUkVOREVSX01PTklUT1IpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRSZXNpemVMaXN0ZW5lcihub2RlLCBsaXN0ZW5lciwgY2hhcnQpIHtcclxuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IChub2RlW0VYUEFORE9fS0VZXSA9IHt9KTtcclxuXHJcblx0Ly8gTGV0J3Mga2VlcCB0cmFjayBvZiB0aGlzIGFkZGVkIHJlc2l6ZXIgYW5kIHRodXMgYXZvaWQgRE9NIHF1ZXJ5IHdoZW4gcmVtb3ZpbmcgaXQuXHJcblx0dmFyIHJlc2l6ZXIgPSBleHBhbmRvLnJlc2l6ZXIgPSBjcmVhdGVSZXNpemVyKHRocm90dGxlZChmdW5jdGlvbigpIHtcclxuXHRcdGlmIChleHBhbmRvLnJlc2l6ZXIpIHtcclxuXHRcdFx0dmFyIGNvbnRhaW5lciA9IGNoYXJ0Lm9wdGlvbnMubWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiBub2RlLnBhcmVudE5vZGU7XHJcblx0XHRcdHZhciB3ID0gY29udGFpbmVyID8gY29udGFpbmVyLmNsaWVudFdpZHRoIDogMDtcclxuXHRcdFx0bGlzdGVuZXIoY3JlYXRlRXZlbnQoJ3Jlc2l6ZScsIGNoYXJ0KSk7XHJcblx0XHRcdGlmIChjb250YWluZXIgJiYgY29udGFpbmVyLmNsaWVudFdpZHRoIDwgdyAmJiBjaGFydC5jYW52YXMpIHtcclxuXHRcdFx0XHQvLyBJZiB0aGUgY29udGFpbmVyIHNpemUgc2hyYW5rIGR1cmluZyBjaGFydCByZXNpemUsIGxldCdzIGFzc3VtZVxyXG5cdFx0XHRcdC8vIHNjcm9sbGJhciBhcHBlYXJlZC4gU28gd2UgcmVzaXplIGFnYWluIHdpdGggdGhlIHNjcm9sbGJhciB2aXNpYmxlIC1cclxuXHRcdFx0XHQvLyBlZmZlY3RpdmVseSBtYWtpbmcgY2hhcnQgc21hbGxlciBhbmQgdGhlIHNjcm9sbGJhciBoaWRkZW4gYWdhaW4uXHJcblx0XHRcdFx0Ly8gQmVjYXVzZSB3ZSBhcmUgaW5zaWRlIGB0aHJvdHRsZWRgLCBhbmQgY3VycmVudGx5IGB0aWNraW5nYCwgc2Nyb2xsXHJcblx0XHRcdFx0Ly8gZXZlbnRzIGFyZSBpZ25vcmVkIGR1cmluZyB0aGlzIHdob2xlIDIgcmVzaXplIHByb2Nlc3MuXHJcblx0XHRcdFx0Ly8gSWYgd2UgYXNzdW1lZCB3cm9uZyBhbmQgc29tZXRoaW5nIGVsc2UgaGFwcGVuZWQsIHdlIGFyZSByZXNpemluZ1xyXG5cdFx0XHRcdC8vIHR3aWNlIGluIGEgZnJhbWUgKHBvdGVudGlhbCBwZXJmb3JtYW5jZSBpc3N1ZSlcclxuXHRcdFx0XHRsaXN0ZW5lcihjcmVhdGVFdmVudCgncmVzaXplJywgY2hhcnQpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0pKTtcclxuXHJcblx0Ly8gVGhlIHJlc2l6ZXIgbmVlZHMgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIG5vZGUgcGFyZW50LCBzbyB3ZSBmaXJzdCBuZWVkIHRvIGJlXHJcblx0Ly8gc3VyZSB0aGF0IGBub2RlYCBpcyBhdHRhY2hlZCB0byB0aGUgRE9NIGJlZm9yZSBpbmplY3RpbmcgdGhlIHJlc2l6ZXIgZWxlbWVudC5cclxuXHR3YXRjaEZvclJlbmRlcihub2RlLCBmdW5jdGlvbigpIHtcclxuXHRcdGlmIChleHBhbmRvLnJlc2l6ZXIpIHtcclxuXHRcdFx0dmFyIGNvbnRhaW5lciA9IG5vZGUucGFyZW50Tm9kZTtcclxuXHRcdFx0aWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIgIT09IHJlc2l6ZXIucGFyZW50Tm9kZSkge1xyXG5cdFx0XHRcdGNvbnRhaW5lci5pbnNlcnRCZWZvcmUocmVzaXplciwgY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBUaGUgY29udGFpbmVyIHNpemUgbWlnaHQgaGF2ZSBjaGFuZ2VkLCBsZXQncyByZXNldCB0aGUgcmVzaXplciBzdGF0ZS5cclxuXHRcdFx0cmVzaXplci5fcmVzZXQoKTtcclxuXHRcdH1cclxuXHR9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlUmVzaXplTGlzdGVuZXIobm9kZSkge1xyXG5cdHZhciBleHBhbmRvID0gbm9kZVtFWFBBTkRPX0tFWV0gfHwge307XHJcblx0dmFyIHJlc2l6ZXIgPSBleHBhbmRvLnJlc2l6ZXI7XHJcblxyXG5cdGRlbGV0ZSBleHBhbmRvLnJlc2l6ZXI7XHJcblx0dW53YXRjaEZvclJlbmRlcihub2RlKTtcclxuXHJcblx0aWYgKHJlc2l6ZXIgJiYgcmVzaXplci5wYXJlbnROb2RlKSB7XHJcblx0XHRyZXNpemVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocmVzaXplcik7XHJcblx0fVxyXG59XHJcblxyXG4vKipcclxuICogSW5qZWN0cyBDU1Mgc3R5bGVzIGlubGluZSBpZiB0aGUgc3R5bGVzIGFyZSBub3QgYWxyZWFkeSBwcmVzZW50LlxyXG4gKiBAcGFyYW0ge0hUTUxEb2N1bWVudHxTaGFkb3dSb290fSByb290Tm9kZSAtIHRoZSBub2RlIHRvIGNvbnRhaW4gdGhlIDxzdHlsZT4uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3MgLSB0aGUgQ1NTIHRvIGJlIGluamVjdGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gaW5qZWN0Q1NTKHJvb3ROb2RlLCBjc3MpIHtcclxuXHQvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMzkyMjEzOVxyXG5cdHZhciBleHBhbmRvID0gcm9vdE5vZGVbRVhQQU5ET19LRVldIHx8IChyb290Tm9kZVtFWFBBTkRPX0tFWV0gPSB7fSk7XHJcblx0aWYgKCFleHBhbmRvLmNvbnRhaW5zU3R5bGVzKSB7XHJcblx0XHRleHBhbmRvLmNvbnRhaW5zU3R5bGVzID0gdHJ1ZTtcclxuXHRcdGNzcyA9ICcvKiBDaGFydC5qcyAqL1xcbicgKyBjc3M7XHJcblx0XHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xyXG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XHJcblx0XHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcclxuXHRcdHJvb3ROb2RlLmFwcGVuZENoaWxkKHN0eWxlKTtcclxuXHR9XHJcbn1cclxuXHJcbnZhciBwbGF0Zm9ybV9kb20kMiA9IHtcclxuXHQvKipcclxuXHQgKiBXaGVuIGB0cnVlYCwgcHJldmVudHMgdGhlIGF1dG9tYXRpYyBpbmplY3Rpb24gb2YgdGhlIHN0eWxlc2hlZXQgcmVxdWlyZWQgdG9cclxuXHQgKiBjb3JyZWN0bHkgZGV0ZWN0IHdoZW4gdGhlIGNoYXJ0IGlzIGFkZGVkIHRvIHRoZSBET00gYW5kIHRoZW4gcmVzaXplZC4gVGhpc1xyXG5cdCAqIHN3aXRjaCBoYXMgYmVlbiBhZGRlZCB0byBhbGxvdyBleHRlcm5hbCBzdHlsZXNoZWV0IChgZGlzdC9DaGFydCgubWluKT8uanNgKVxyXG5cdCAqIHRvIGJlIG1hbnVhbGx5IGltcG9ydGVkIHRvIG1ha2UgdGhpcyBsaWJyYXJ5IGNvbXBhdGlibGUgd2l0aCBhbnkgQ1NQLlxyXG5cdCAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTIwOFxyXG5cdCAqL1xyXG5cdGRpc2FibGVDU1NJbmplY3Rpb246IGZhbHNlLFxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIHByb3BlcnR5IGhvbGRzIHdoZXRoZXIgdGhpcyBwbGF0Zm9ybSBpcyBlbmFibGVkIGZvciB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cclxuXHQgKiBDdXJyZW50bHkgdXNlZCBieSBwbGF0Zm9ybS5qcyB0byBzZWxlY3QgdGhlIHByb3BlciBpbXBsZW1lbnRhdGlvbi5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9lbmFibGVkOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnLFxyXG5cclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplcyByZXNvdXJjZXMgdGhhdCBkZXBlbmQgb24gcGxhdGZvcm0gb3B0aW9ucy5cclxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBUaGUgQ2FudmFzIGVsZW1lbnQuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZW5zdXJlTG9hZGVkOiBmdW5jdGlvbihjYW52YXMpIHtcclxuXHRcdGlmICghdGhpcy5kaXNhYmxlQ1NTSW5qZWN0aW9uKSB7XHJcblx0XHRcdC8vIElmIHRoZSBjYW52YXMgaXMgaW4gYSBzaGFkb3cgRE9NLCB0aGVuIHRoZSBzdHlsZXMgbXVzdCBhbHNvIGJlIGluc2VydGVkXHJcblx0XHRcdC8vIGludG8gdGhlIHNhbWUgc2hhZG93IERPTS5cclxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU3NjNcclxuXHRcdFx0dmFyIHJvb3QgPSBjYW52YXMuZ2V0Um9vdE5vZGUgPyBjYW52YXMuZ2V0Um9vdE5vZGUoKSA6IGRvY3VtZW50O1xyXG5cdFx0XHR2YXIgdGFyZ2V0Tm9kZSA9IHJvb3QuaG9zdCA/IHJvb3QgOiBkb2N1bWVudC5oZWFkO1xyXG5cdFx0XHRpbmplY3RDU1ModGFyZ2V0Tm9kZSwgc3R5bGVzaGVldCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0YWNxdWlyZUNvbnRleHQ6IGZ1bmN0aW9uKGl0ZW0sIGNvbmZpZykge1xyXG5cdFx0aWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRpdGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaXRlbSk7XHJcblx0XHR9IGVsc2UgaWYgKGl0ZW0ubGVuZ3RoKSB7XHJcblx0XHRcdC8vIFN1cHBvcnQgZm9yIGFycmF5IGJhc2VkIHF1ZXJpZXMgKHN1Y2ggYXMgalF1ZXJ5KVxyXG5cdFx0XHRpdGVtID0gaXRlbVswXTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xyXG5cdFx0XHQvLyBTdXBwb3J0IGZvciBhbnkgb2JqZWN0IGFzc29jaWF0ZWQgdG8gYSBjYW52YXMgKGluY2x1ZGluZyBhIGNvbnRleHQyZClcclxuXHRcdFx0aXRlbSA9IGl0ZW0uY2FudmFzO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRvIHByZXZlbnQgY2FudmFzIGZpbmdlcnByaW50aW5nLCBzb21lIGFkZC1vbnMgdW5kZWZpbmUgdGhlIGdldENvbnRleHRcclxuXHRcdC8vIG1ldGhvZCwgZm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ra2Fwc25lci9DYW52YXNCbG9ja2VyXHJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjgwN1xyXG5cdFx0dmFyIGNvbnRleHQgPSBpdGVtICYmIGl0ZW0uZ2V0Q29udGV4dCAmJiBpdGVtLmdldENvbnRleHQoJzJkJyk7XHJcblxyXG5cdFx0Ly8gYGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEYCBmYWlscyB3aGVuIHRoZSBpdGVtIGlzXHJcblx0XHQvLyBpbnNpZGUgYW4gaWZyYW1lIG9yIHdoZW4gcnVubmluZyBpbiBhIHByb3RlY3RlZCBlbnZpcm9ubWVudC4gV2UgY291bGQgZ3Vlc3MgdGhlXHJcblx0XHQvLyB0eXBlcyBmcm9tIHRoZWlyIHRvU3RyaW5nKCkgdmFsdWUgYnV0IGxldCdzIGtlZXAgdGhpbmdzIGZsZXhpYmxlIGFuZCBhc3N1bWUgaXQnc1xyXG5cdFx0Ly8gYSBzdWZmaWNpZW50IGNvbmRpdGlvbiBpZiB0aGUgaXRlbSBoYXMgYSBjb250ZXh0MkQgd2hpY2ggaGFzIGl0ZW0gYXMgYGNhbnZhc2AuXHJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzg4N1xyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxMDJcclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80MTUyXHJcblx0XHRpZiAoY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcyA9PT0gaXRlbSkge1xyXG5cdFx0XHQvLyBMb2FkIHBsYXRmb3JtIHJlc291cmNlcyBvbiBmaXJzdCBjaGFydCBjcmVhdGlvbiwgdG8gbWFrZSBpdCBwb3NzaWJsZSB0b1xyXG5cdFx0XHQvLyBpbXBvcnQgdGhlIGxpYnJhcnkgYmVmb3JlIHNldHRpbmcgcGxhdGZvcm0gb3B0aW9ucy5cclxuXHRcdFx0dGhpcy5fZW5zdXJlTG9hZGVkKGl0ZW0pO1xyXG5cdFx0XHRpbml0Q2FudmFzKGl0ZW0sIGNvbmZpZyk7XHJcblx0XHRcdHJldHVybiBjb250ZXh0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdHJlbGVhc2VDb250ZXh0OiBmdW5jdGlvbihjb250ZXh0KSB7XHJcblx0XHR2YXIgY2FudmFzID0gY29udGV4dC5jYW52YXM7XHJcblx0XHRpZiAoIWNhbnZhc1tFWFBBTkRPX0tFWV0pIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpbml0aWFsID0gY2FudmFzW0VYUEFORE9fS0VZXS5pbml0aWFsO1xyXG5cdFx0WydoZWlnaHQnLCAnd2lkdGgnXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcclxuXHRcdFx0dmFyIHZhbHVlID0gaW5pdGlhbFtwcm9wXTtcclxuXHRcdFx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKHZhbHVlKSkge1xyXG5cdFx0XHRcdGNhbnZhcy5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y2FudmFzLnNldEF0dHJpYnV0ZShwcm9wLCB2YWx1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdGhlbHBlcnMkMS5lYWNoKGluaXRpYWwuc3R5bGUgfHwge30sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcclxuXHRcdFx0Y2FudmFzLnN0eWxlW2tleV0gPSB2YWx1ZTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIFRoZSBjYW52YXMgcmVuZGVyIHNpemUgbWlnaHQgaGF2ZSBiZWVuIGNoYW5nZWQgKGFuZCB0aHVzIHRoZSBzdGF0ZSBzdGFjayBkaXNjYXJkZWQpLFxyXG5cdFx0Ly8gd2UgY2FuJ3QgdXNlIHNhdmUoKSBhbmQgcmVzdG9yZSgpIHRvIHJlc3RvcmUgdGhlIGluaXRpYWwgc3RhdGUuIFNvIG1ha2Ugc3VyZSB0aGF0IGF0XHJcblx0XHQvLyBsZWFzdCB0aGUgY2FudmFzIGNvbnRleHQgaXMgcmVzZXQgdG8gdGhlIGRlZmF1bHQgc3RhdGUgYnkgc2V0dGluZyB0aGUgY2FudmFzIHdpZHRoLlxyXG5cdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTEvV0QtaHRtbDUtMjAxMTA1MjUvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWxcclxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxyXG5cdFx0Y2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xyXG5cclxuXHRcdGRlbGV0ZSBjYW52YXNbRVhQQU5ET19LRVldO1xyXG5cdH0sXHJcblxyXG5cdGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xyXG5cdFx0dmFyIGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcclxuXHRcdGlmICh0eXBlID09PSAncmVzaXplJykge1xyXG5cdFx0XHQvLyBOb3RlOiB0aGUgcmVzaXplIGV2ZW50IGlzIG5vdCBzdXBwb3J0ZWQgb24gYWxsIGJyb3dzZXJzLlxyXG5cdFx0XHRhZGRSZXNpemVMaXN0ZW5lcihjYW52YXMsIGxpc3RlbmVyLCBjaGFydCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZXhwYW5kbyA9IGxpc3RlbmVyW0VYUEFORE9fS0VZXSB8fCAobGlzdGVuZXJbRVhQQU5ET19LRVldID0ge30pO1xyXG5cdFx0dmFyIHByb3hpZXMgPSBleHBhbmRvLnByb3hpZXMgfHwgKGV4cGFuZG8ucHJveGllcyA9IHt9KTtcclxuXHRcdHZhciBwcm94eSA9IHByb3hpZXNbY2hhcnQuaWQgKyAnXycgKyB0eXBlXSA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRcdGxpc3RlbmVyKGZyb21OYXRpdmVFdmVudChldmVudCwgY2hhcnQpKTtcclxuXHRcdH07XHJcblxyXG5cdFx0YWRkTGlzdGVuZXIoY2FudmFzLCB0eXBlLCBwcm94eSk7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XHJcblx0XHR2YXIgY2FudmFzID0gY2hhcnQuY2FudmFzO1xyXG5cdFx0aWYgKHR5cGUgPT09ICdyZXNpemUnKSB7XHJcblx0XHRcdC8vIE5vdGU6IHRoZSByZXNpemUgZXZlbnQgaXMgbm90IHN1cHBvcnRlZCBvbiBhbGwgYnJvd3NlcnMuXHJcblx0XHRcdHJlbW92ZVJlc2l6ZUxpc3RlbmVyKGNhbnZhcyk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZXhwYW5kbyA9IGxpc3RlbmVyW0VYUEFORE9fS0VZXSB8fCB7fTtcclxuXHRcdHZhciBwcm94aWVzID0gZXhwYW5kby5wcm94aWVzIHx8IHt9O1xyXG5cdFx0dmFyIHByb3h5ID0gcHJveGllc1tjaGFydC5pZCArICdfJyArIHR5cGVdO1xyXG5cdFx0aWYgKCFwcm94eSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0cmVtb3ZlTGlzdGVuZXIoY2FudmFzLCB0eXBlLCBwcm94eSk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gREVQUkVDQVRJT05TXHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBFdmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyIGluc3RlYWQuXHJcbiAqIEV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIgY29tcGF0aWJpbGl0eTogQ2hyb21lLCBPcGVyYSA3LCBTYWZhcmksIEZGMS41KywgSUU5K1xyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyXHJcbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmFkZEV2ZW50XHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuaGVscGVycyQxLmFkZEV2ZW50ID0gYWRkTGlzdGVuZXI7XHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBFdmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyIGluc3RlYWQuXHJcbiAqIEV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIgY29tcGF0aWJpbGl0eTogQ2hyb21lLCBPcGVyYSA3LCBTYWZhcmksIEZGMS41KywgSUU5K1xyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9yZW1vdmVFdmVudExpc3RlbmVyXHJcbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLnJlbW92ZUV2ZW50XHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuaGVscGVycyQxLnJlbW92ZUV2ZW50ID0gcmVtb3ZlTGlzdGVuZXI7XG5cbi8vIEBUT0RPIE1ha2UgcG9zc2libGUgdG8gc2VsZWN0IGFub3RoZXIgcGxhdGZvcm0gYXQgYnVpbGQgdGltZS5cclxudmFyIGltcGxlbWVudGF0aW9uID0gcGxhdGZvcm1fZG9tJDIuX2VuYWJsZWQgPyBwbGF0Zm9ybV9kb20kMiA6IHBsYXRmb3JtX2Jhc2ljO1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgQ2hhcnQucGxhdGZvcm1cclxuICogQHNlZSBodHRwczovL2NoYXJ0anMuZ2l0Ym9va3MuaW8vcHJvcG9zYWxzL2NvbnRlbnQvUGxhdGZvcm0uaHRtbFxyXG4gKiBAc2luY2UgMi40LjBcclxuICovXHJcbnZhciBwbGF0Zm9ybSA9IGhlbHBlcnMkMS5leHRlbmQoe1xyXG5cdC8qKlxyXG5cdCAqIEBzaW5jZSAyLjcuMFxyXG5cdCAqL1xyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge30sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGxlZCBhdCBjaGFydCBjb25zdHJ1Y3Rpb24gdGltZSwgcmV0dXJucyBhIGNvbnRleHQyZCBpbnN0YW5jZSBpbXBsZW1lbnRpbmdcclxuXHQgKiB0aGUgW1czQyBDYW52YXMgMkQgQ29udGV4dCBBUEkgc3RhbmRhcmRde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yZGNvbnRleHQvfS5cclxuXHQgKiBAcGFyYW0geyp9IGl0ZW0gLSBUaGUgbmF0aXZlIGl0ZW0gZnJvbSB3aGljaCB0byBhY3F1aXJlIGNvbnRleHQgKHBsYXRmb3JtIHNwZWNpZmljKVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gVGhlIGNoYXJ0IG9wdGlvbnNcclxuXHQgKiBAcmV0dXJucyB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0MmQgaW5zdGFuY2VcclxuXHQgKi9cclxuXHRhY3F1aXJlQ29udGV4dDogZnVuY3Rpb24oKSB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2FsbGVkIGF0IGNoYXJ0IGRlc3RydWN0aW9uIHRpbWUsIHJlbGVhc2VzIGFueSByZXNvdXJjZXMgYXNzb2NpYXRlZCB0byB0aGUgY29udGV4dFxyXG5cdCAqIHByZXZpb3VzbHkgcmV0dXJuZWQgYnkgdGhlIGFjcXVpcmVDb250ZXh0KCkgbWV0aG9kLlxyXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IC0gVGhlIGNvbnRleHQyZCBpbnN0YW5jZVxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBtZXRob2Qgc3VjY2VlZGVkLCBlbHNlIGZhbHNlXHJcblx0ICovXHJcblx0cmVsZWFzZUNvbnRleHQ6IGZ1bmN0aW9uKCkge30sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZ2lzdGVycyB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyIG9uIHRoZSBnaXZlbiBjaGFydC5cclxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIENoYXJ0IGZyb20gd2hpY2ggdG8gbGlzdGVuIGZvciBldmVudFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlICh7QGxpbmsgSUV2ZW50fSkgdHlwZSB0byBsaXN0ZW4gZm9yXHJcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBSZWNlaXZlcyBhIG5vdGlmaWNhdGlvbiAoYW4gb2JqZWN0IHRoYXQgaW1wbGVtZW50c1xyXG5cdCAqIHRoZSB7QGxpbmsgSUV2ZW50fSBpbnRlcmZhY2UpIHdoZW4gYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vycy5cclxuXHQgKi9cclxuXHRhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbigpIHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggYWRkRXZlbnRMaXN0ZW5lci5cclxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIENoYXJ0IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lclxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlICh7QGxpbmsgSUV2ZW50fSkgdHlwZSB0byByZW1vdmVcclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byByZW1vdmUgZnJvbSB0aGUgZXZlbnQgdGFyZ2V0LlxyXG5cdCAqL1xyXG5cdHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge31cclxuXHJcbn0sIGltcGxlbWVudGF0aW9uKTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XHJcblx0cGx1Z2luczoge31cclxufSk7XHJcblxyXG4vKipcclxuICogVGhlIHBsdWdpbiBzZXJ2aWNlIHNpbmdsZXRvblxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0LnBsdWdpbnNcclxuICogQHNpbmNlIDIuMS4wXHJcbiAqL1xyXG52YXIgY29yZV9wbHVnaW5zID0ge1xyXG5cdC8qKlxyXG5cdCAqIEdsb2JhbGx5IHJlZ2lzdGVyZWQgcGx1Z2lucy5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9wbHVnaW5zOiBbXSxcclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBpZGVudGlmaWVyIGlzIHVzZWQgdG8gaW52YWxpZGF0ZSB0aGUgZGVzY3JpcHRvcnMgY2FjaGUgYXR0YWNoZWQgdG8gZWFjaCBjaGFydFxyXG5cdCAqIHdoZW4gYSBnbG9iYWwgcGx1Z2luIGlzIHJlZ2lzdGVyZWQgb3IgdW5yZWdpc3RlcmVkLiBJbiB0aGlzIGNhc2UsIHRoZSBjYWNoZSBJRCBpc1xyXG5cdCAqIGluY3JlbWVudGVkIGFuZCBkZXNjcmlwdG9ycyBhcmUgcmVnZW5lcmF0ZWQgZHVyaW5nIGZvbGxvd2luZyBBUEkgY2FsbHMuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfY2FjaGVJZDogMCxcclxuXHJcblx0LyoqXHJcblx0ICogUmVnaXN0ZXJzIHRoZSBnaXZlbiBwbHVnaW4ocykgaWYgbm90IGFscmVhZHkgcmVnaXN0ZXJlZC5cclxuXHQgKiBAcGFyYW0ge0lQbHVnaW5bXXxJUGx1Z2lufSBwbHVnaW5zIHBsdWdpbiBpbnN0YW5jZShzKS5cclxuXHQgKi9cclxuXHRyZWdpc3RlcjogZnVuY3Rpb24ocGx1Z2lucykge1xyXG5cdFx0dmFyIHAgPSB0aGlzLl9wbHVnaW5zO1xyXG5cdFx0KFtdKS5jb25jYXQocGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcclxuXHRcdFx0aWYgKHAuaW5kZXhPZihwbHVnaW4pID09PSAtMSkge1xyXG5cdFx0XHRcdHAucHVzaChwbHVnaW4pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHR0aGlzLl9jYWNoZUlkKys7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVW5yZWdpc3RlcnMgdGhlIGdpdmVuIHBsdWdpbihzKSBvbmx5IGlmIHJlZ2lzdGVyZWQuXHJcblx0ICogQHBhcmFtIHtJUGx1Z2luW118SVBsdWdpbn0gcGx1Z2lucyBwbHVnaW4gaW5zdGFuY2UocykuXHJcblx0ICovXHJcblx0dW5yZWdpc3RlcjogZnVuY3Rpb24ocGx1Z2lucykge1xyXG5cdFx0dmFyIHAgPSB0aGlzLl9wbHVnaW5zO1xyXG5cdFx0KFtdKS5jb25jYXQocGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcclxuXHRcdFx0dmFyIGlkeCA9IHAuaW5kZXhPZihwbHVnaW4pO1xyXG5cdFx0XHRpZiAoaWR4ICE9PSAtMSkge1xyXG5cdFx0XHRcdHAuc3BsaWNlKGlkeCwgMSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHRoaXMuX2NhY2hlSWQrKztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmUgYWxsIHJlZ2lzdGVyZWQgcGx1Z2lucy5cclxuXHQgKiBAc2luY2UgMi4xLjVcclxuXHQgKi9cclxuXHRjbGVhcjogZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLl9wbHVnaW5zID0gW107XHJcblx0XHR0aGlzLl9jYWNoZUlkKys7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJlZ2lzdGVyZWQgcGx1Z2lucz9cclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG5cdCAqIEBzaW5jZSAyLjEuNVxyXG5cdCAqL1xyXG5cdGNvdW50OiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLl9wbHVnaW5zLmxlbmd0aDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGFsbCByZWdpc3RlcmVkIHBsdWdpbiBpbnN0YW5jZXMuXHJcblx0ICogQHJldHVybnMge0lQbHVnaW5bXX0gYXJyYXkgb2YgcGx1Z2luIG9iamVjdHMuXHJcblx0ICogQHNpbmNlIDIuMS41XHJcblx0ICovXHJcblx0Z2V0QWxsOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLl9wbHVnaW5zO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGxzIGVuYWJsZWQgcGx1Z2lucyBmb3IgYGNoYXJ0YCBvbiB0aGUgc3BlY2lmaWVkIGhvb2sgYW5kIHdpdGggdGhlIGdpdmVuIGFyZ3MuXHJcblx0ICogVGhpcyBtZXRob2QgaW1tZWRpYXRlbHkgcmV0dXJucyBhcyBzb29uIGFzIGEgcGx1Z2luIGV4cGxpY2l0bHkgcmV0dXJucyBmYWxzZS4gVGhlXHJcblx0ICogcmV0dXJuZWQgdmFsdWUgY2FuIGJlIHVzZWQsIGZvciBpbnN0YW5jZSwgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50IGFjdGlvbi5cclxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZSBmb3Igd2hpY2ggcGx1Z2lucyBzaG91bGQgYmUgY2FsbGVkLlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBob29rIC0gVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiBtZXRob2QgdG8gY2FsbCAoZS5nLiAnYmVmb3JlVXBkYXRlJykuXHJcblx0ICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdIC0gRXh0cmEgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBob29rIGNhbGwuXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIGFueSBvZiB0aGUgcGx1Z2lucyByZXR1cm4gZmFsc2UsIGVsc2UgcmV0dXJucyB0cnVlLlxyXG5cdCAqL1xyXG5cdG5vdGlmeTogZnVuY3Rpb24oY2hhcnQsIGhvb2ssIGFyZ3MpIHtcclxuXHRcdHZhciBkZXNjcmlwdG9ycyA9IHRoaXMuZGVzY3JpcHRvcnMoY2hhcnQpO1xyXG5cdFx0dmFyIGlsZW4gPSBkZXNjcmlwdG9ycy5sZW5ndGg7XHJcblx0XHR2YXIgaSwgZGVzY3JpcHRvciwgcGx1Z2luLCBwYXJhbXMsIG1ldGhvZDtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yc1tpXTtcclxuXHRcdFx0cGx1Z2luID0gZGVzY3JpcHRvci5wbHVnaW47XHJcblx0XHRcdG1ldGhvZCA9IHBsdWdpbltob29rXTtcclxuXHRcdFx0aWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRwYXJhbXMgPSBbY2hhcnRdLmNvbmNhdChhcmdzIHx8IFtdKTtcclxuXHRcdFx0XHRwYXJhbXMucHVzaChkZXNjcmlwdG9yLm9wdGlvbnMpO1xyXG5cdFx0XHRcdGlmIChtZXRob2QuYXBwbHkocGx1Z2luLCBwYXJhbXMpID09PSBmYWxzZSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgZGVzY3JpcHRvcnMgb2YgZW5hYmxlZCBwbHVnaW5zIGZvciB0aGUgZ2l2ZW4gY2hhcnQuXHJcblx0ICogQHJldHVybnMge29iamVjdFtdfSBbeyBwbHVnaW4sIG9wdGlvbnMgfV1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGRlc2NyaXB0b3JzOiBmdW5jdGlvbihjaGFydCkge1xyXG5cdFx0dmFyIGNhY2hlID0gY2hhcnQuJHBsdWdpbnMgfHwgKGNoYXJ0LiRwbHVnaW5zID0ge30pO1xyXG5cdFx0aWYgKGNhY2hlLmlkID09PSB0aGlzLl9jYWNoZUlkKSB7XHJcblx0XHRcdHJldHVybiBjYWNoZS5kZXNjcmlwdG9ycztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcGx1Z2lucyA9IFtdO1xyXG5cdFx0dmFyIGRlc2NyaXB0b3JzID0gW107XHJcblx0XHR2YXIgY29uZmlnID0gKGNoYXJ0ICYmIGNoYXJ0LmNvbmZpZykgfHwge307XHJcblx0XHR2YXIgb3B0aW9ucyA9IChjb25maWcub3B0aW9ucyAmJiBjb25maWcub3B0aW9ucy5wbHVnaW5zKSB8fCB7fTtcclxuXHJcblx0XHR0aGlzLl9wbHVnaW5zLmNvbmNhdChjb25maWcucGx1Z2lucyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcclxuXHRcdFx0dmFyIGlkeCA9IHBsdWdpbnMuaW5kZXhPZihwbHVnaW4pO1xyXG5cdFx0XHRpZiAoaWR4ICE9PSAtMSkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGlkID0gcGx1Z2luLmlkO1xyXG5cdFx0XHR2YXIgb3B0cyA9IG9wdGlvbnNbaWRdO1xyXG5cdFx0XHRpZiAob3B0cyA9PT0gZmFsc2UpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChvcHRzID09PSB0cnVlKSB7XHJcblx0XHRcdFx0b3B0cyA9IGhlbHBlcnMkMS5jbG9uZShjb3JlX2RlZmF1bHRzLmdsb2JhbC5wbHVnaW5zW2lkXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHBsdWdpbnMucHVzaChwbHVnaW4pO1xyXG5cdFx0XHRkZXNjcmlwdG9ycy5wdXNoKHtcclxuXHRcdFx0XHRwbHVnaW46IHBsdWdpbixcclxuXHRcdFx0XHRvcHRpb25zOiBvcHRzIHx8IHt9XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Y2FjaGUuZGVzY3JpcHRvcnMgPSBkZXNjcmlwdG9ycztcclxuXHRcdGNhY2hlLmlkID0gdGhpcy5fY2FjaGVJZDtcclxuXHRcdHJldHVybiBkZXNjcmlwdG9ycztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBJbnZhbGlkYXRlcyBjYWNoZSBmb3IgdGhlIGdpdmVuIGNoYXJ0OiBkZXNjcmlwdG9ycyBob2xkIGEgcmVmZXJlbmNlIG9uIHBsdWdpbiBvcHRpb24sXHJcblx0ICogYnV0IGluIHNvbWUgY2FzZXMsIHRoaXMgcmVmZXJlbmNlIGNhbiBiZSBjaGFuZ2VkIGJ5IHRoZSB1c2VyIHdoZW4gdXBkYXRpbmcgb3B0aW9ucy5cclxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTExMSNpc3N1ZWNvbW1lbnQtMzU1OTM0MTY3XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfaW52YWxpZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdGRlbGV0ZSBjaGFydC4kcGx1Z2lucztcclxuXHR9XHJcbn07XG5cbnZhciBjb3JlX3NjYWxlU2VydmljZSA9IHtcclxuXHQvLyBTY2FsZSByZWdpc3RyYXRpb24gb2JqZWN0LiBFeHRlbnNpb25zIGNhbiByZWdpc3RlciBuZXcgc2NhbGUgdHlwZXMgKHN1Y2ggYXMgbG9nIG9yIERCIHNjYWxlcykgYW5kIHRoZW5cclxuXHQvLyB1c2UgdGhlIG5ldyBjaGFydCBvcHRpb25zIHRvIGdyYWIgdGhlIGNvcnJlY3Qgc2NhbGVcclxuXHRjb25zdHJ1Y3RvcnM6IHt9LFxyXG5cdC8vIFVzZSBhIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbiBzbyB0aGF0IHdlIGNhbiBtb3ZlIHRvIGFuIEVTNiBtYXAgd2hlbiB3ZSBubyBsb25nZXIgbmVlZCB0byBzdXBwb3J0XHJcblx0Ly8gb2xkIGJyb3dzZXJzXHJcblxyXG5cdC8vIFNjYWxlIGNvbmZpZyBkZWZhdWx0c1xyXG5cdGRlZmF1bHRzOiB7fSxcclxuXHRyZWdpc3RlclNjYWxlVHlwZTogZnVuY3Rpb24odHlwZSwgc2NhbGVDb25zdHJ1Y3Rvciwgc2NhbGVEZWZhdWx0cykge1xyXG5cdFx0dGhpcy5jb25zdHJ1Y3RvcnNbdHlwZV0gPSBzY2FsZUNvbnN0cnVjdG9yO1xyXG5cdFx0dGhpcy5kZWZhdWx0c1t0eXBlXSA9IGhlbHBlcnMkMS5jbG9uZShzY2FsZURlZmF1bHRzKTtcclxuXHR9LFxyXG5cdGdldFNjYWxlQ29uc3RydWN0b3I6IGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9ycy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSA/IHRoaXMuY29uc3RydWN0b3JzW3R5cGVdIDogdW5kZWZpbmVkO1xyXG5cdH0sXHJcblx0Z2V0U2NhbGVEZWZhdWx0czogZnVuY3Rpb24odHlwZSkge1xyXG5cdFx0Ly8gUmV0dXJuIHRoZSBzY2FsZSBkZWZhdWx0cyBtZXJnZWQgd2l0aCB0aGUgZ2xvYmFsIHNldHRpbmdzIHNvIHRoYXQgd2UgYWx3YXlzIHVzZSB0aGUgbGF0ZXN0IG9uZXNcclxuXHRcdHJldHVybiB0aGlzLmRlZmF1bHRzLmhhc093blByb3BlcnR5KHR5cGUpID8gaGVscGVycyQxLm1lcmdlKE9iamVjdC5jcmVhdGUobnVsbCksIFtjb3JlX2RlZmF1bHRzLnNjYWxlLCB0aGlzLmRlZmF1bHRzW3R5cGVdXSkgOiB7fTtcclxuXHR9LFxyXG5cdHVwZGF0ZVNjYWxlRGVmYXVsdHM6IGZ1bmN0aW9uKHR5cGUsIGFkZGl0aW9ucykge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdGlmIChtZS5kZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xyXG5cdFx0XHRtZS5kZWZhdWx0c1t0eXBlXSA9IGhlbHBlcnMkMS5leHRlbmQobWUuZGVmYXVsdHNbdHlwZV0sIGFkZGl0aW9ucyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRhZGRTY2FsZXNUb0xheW91dDogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdC8vIEFkZHMgZWFjaCBzY2FsZSB0byB0aGUgY2hhcnQuYm94ZXMgYXJyYXkgdG8gYmUgc2l6ZWQgYWNjb3JkaW5nbHlcclxuXHRcdGhlbHBlcnMkMS5lYWNoKGNoYXJ0LnNjYWxlcywgZnVuY3Rpb24oc2NhbGUpIHtcclxuXHRcdFx0Ly8gU2V0IElMYXlvdXRJdGVtIHBhcmFtZXRlcnMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblx0XHRcdHNjYWxlLmZ1bGxXaWR0aCA9IHNjYWxlLm9wdGlvbnMuZnVsbFdpZHRoO1xyXG5cdFx0XHRzY2FsZS5wb3NpdGlvbiA9IHNjYWxlLm9wdGlvbnMucG9zaXRpb247XHJcblx0XHRcdHNjYWxlLndlaWdodCA9IHNjYWxlLm9wdGlvbnMud2VpZ2h0O1xyXG5cdFx0XHRjb3JlX2xheW91dHMuYWRkQm94KGNoYXJ0LCBzY2FsZSk7XHJcblx0XHR9KTtcclxuXHR9XHJcbn07XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ4ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xyXG52YXIgZ2V0UnRsSGVscGVyID0gaGVscGVycyQxLnJ0bC5nZXRSdGxBZGFwdGVyO1xyXG5cclxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XHJcblx0dG9vbHRpcHM6IHtcclxuXHRcdGVuYWJsZWQ6IHRydWUsXHJcblx0XHRjdXN0b206IG51bGwsXHJcblx0XHRtb2RlOiAnbmVhcmVzdCcsXHJcblx0XHRwb3NpdGlvbjogJ2F2ZXJhZ2UnLFxyXG5cdFx0aW50ZXJzZWN0OiB0cnVlLFxyXG5cdFx0YmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjgpJyxcclxuXHRcdHRpdGxlRm9udFN0eWxlOiAnYm9sZCcsXHJcblx0XHR0aXRsZVNwYWNpbmc6IDIsXHJcblx0XHR0aXRsZU1hcmdpbkJvdHRvbTogNixcclxuXHRcdHRpdGxlRm9udENvbG9yOiAnI2ZmZicsXHJcblx0XHR0aXRsZUFsaWduOiAnbGVmdCcsXHJcblx0XHRib2R5U3BhY2luZzogMixcclxuXHRcdGJvZHlGb250Q29sb3I6ICcjZmZmJyxcclxuXHRcdGJvZHlBbGlnbjogJ2xlZnQnLFxyXG5cdFx0Zm9vdGVyRm9udFN0eWxlOiAnYm9sZCcsXHJcblx0XHRmb290ZXJTcGFjaW5nOiAyLFxyXG5cdFx0Zm9vdGVyTWFyZ2luVG9wOiA2LFxyXG5cdFx0Zm9vdGVyRm9udENvbG9yOiAnI2ZmZicsXHJcblx0XHRmb290ZXJBbGlnbjogJ2xlZnQnLFxyXG5cdFx0eVBhZGRpbmc6IDYsXHJcblx0XHR4UGFkZGluZzogNixcclxuXHRcdGNhcmV0UGFkZGluZzogMixcclxuXHRcdGNhcmV0U2l6ZTogNSxcclxuXHRcdGNvcm5lclJhZGl1czogNixcclxuXHRcdG11bHRpS2V5QmFja2dyb3VuZDogJyNmZmYnLFxyXG5cdFx0ZGlzcGxheUNvbG9yczogdHJ1ZSxcclxuXHRcdGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwKScsXHJcblx0XHRib3JkZXJXaWR0aDogMCxcclxuXHRcdGNhbGxiYWNrczoge1xyXG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcclxuXHRcdFx0YmVmb3JlVGl0bGU6IGhlbHBlcnMkMS5ub29wLFxyXG5cdFx0XHR0aXRsZTogZnVuY3Rpb24odG9vbHRpcEl0ZW1zLCBkYXRhKSB7XHJcblx0XHRcdFx0dmFyIHRpdGxlID0gJyc7XHJcblx0XHRcdFx0dmFyIGxhYmVscyA9IGRhdGEubGFiZWxzO1xyXG5cdFx0XHRcdHZhciBsYWJlbENvdW50ID0gbGFiZWxzID8gbGFiZWxzLmxlbmd0aCA6IDA7XHJcblxyXG5cdFx0XHRcdGlmICh0b29sdGlwSXRlbXMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSB0b29sdGlwSXRlbXNbMF07XHJcblx0XHRcdFx0XHRpZiAoaXRlbS5sYWJlbCkge1xyXG5cdFx0XHRcdFx0XHR0aXRsZSA9IGl0ZW0ubGFiZWw7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGl0ZW0ueExhYmVsKSB7XHJcblx0XHRcdFx0XHRcdHRpdGxlID0gaXRlbS54TGFiZWw7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGxhYmVsQ291bnQgPiAwICYmIGl0ZW0uaW5kZXggPCBsYWJlbENvdW50KSB7XHJcblx0XHRcdFx0XHRcdHRpdGxlID0gbGFiZWxzW2l0ZW0uaW5kZXhdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHRpdGxlO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRhZnRlclRpdGxlOiBoZWxwZXJzJDEubm9vcCxcclxuXHJcblx0XHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxyXG5cdFx0XHRiZWZvcmVCb2R5OiBoZWxwZXJzJDEubm9vcCxcclxuXHJcblx0XHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXHJcblx0XHRcdGJlZm9yZUxhYmVsOiBoZWxwZXJzJDEubm9vcCxcclxuXHRcdFx0bGFiZWw6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtLCBkYXRhKSB7XHJcblx0XHRcdFx0dmFyIGxhYmVsID0gZGF0YS5kYXRhc2V0c1t0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXhdLmxhYmVsIHx8ICcnO1xyXG5cclxuXHRcdFx0XHRpZiAobGFiZWwpIHtcclxuXHRcdFx0XHRcdGxhYmVsICs9ICc6ICc7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICghaGVscGVycyQxLmlzTnVsbE9yVW5kZWYodG9vbHRpcEl0ZW0udmFsdWUpKSB7XHJcblx0XHRcdFx0XHRsYWJlbCArPSB0b29sdGlwSXRlbS52YWx1ZTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0bGFiZWwgKz0gdG9vbHRpcEl0ZW0ueUxhYmVsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gbGFiZWw7XHJcblx0XHRcdH0sXHJcblx0XHRcdGxhYmVsQ29sb3I6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtLCBjaGFydCkge1xyXG5cdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcclxuXHRcdFx0XHR2YXIgYWN0aXZlRWxlbWVudCA9IG1ldGEuZGF0YVt0b29sdGlwSXRlbS5pbmRleF07XHJcblx0XHRcdFx0dmFyIHZpZXcgPSBhY3RpdmVFbGVtZW50Ll92aWV3O1xyXG5cdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRib3JkZXJDb2xvcjogdmlldy5ib3JkZXJDb2xvcixcclxuXHRcdFx0XHRcdGJhY2tncm91bmRDb2xvcjogdmlldy5iYWNrZ3JvdW5kQ29sb3JcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRsYWJlbFRleHRDb2xvcjogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuX29wdGlvbnMuYm9keUZvbnRDb2xvcjtcclxuXHRcdFx0fSxcclxuXHRcdFx0YWZ0ZXJMYWJlbDogaGVscGVycyQxLm5vb3AsXHJcblxyXG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcclxuXHRcdFx0YWZ0ZXJCb2R5OiBoZWxwZXJzJDEubm9vcCxcclxuXHJcblx0XHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxyXG5cdFx0XHRiZWZvcmVGb290ZXI6IGhlbHBlcnMkMS5ub29wLFxyXG5cdFx0XHRmb290ZXI6IGhlbHBlcnMkMS5ub29wLFxyXG5cdFx0XHRhZnRlckZvb3RlcjogaGVscGVycyQxLm5vb3BcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxudmFyIHBvc2l0aW9uZXJzID0ge1xyXG5cdC8qKlxyXG5cdCAqIEF2ZXJhZ2UgbW9kZSBwbGFjZXMgdGhlIHRvb2x0aXAgYXQgdGhlIGF2ZXJhZ2UgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnRzIHNob3duXHJcblx0ICogQGZ1bmN0aW9uIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnMuYXZlcmFnZVxyXG5cdCAqIEBwYXJhbSBlbGVtZW50cyB7Q2hhcnRFbGVtZW50W119IHRoZSBlbGVtZW50cyBiZWluZyBkaXNwbGF5ZWQgaW4gdGhlIHRvb2x0aXBcclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSB0b29sdGlwIHBvc2l0aW9uXHJcblx0ICovXHJcblx0YXZlcmFnZTogZnVuY3Rpb24oZWxlbWVudHMpIHtcclxuXHRcdGlmICghZWxlbWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaSwgbGVuO1xyXG5cdFx0dmFyIHggPSAwO1xyXG5cdFx0dmFyIHkgPSAwO1xyXG5cdFx0dmFyIGNvdW50ID0gMDtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG5cdFx0XHR2YXIgZWwgPSBlbGVtZW50c1tpXTtcclxuXHRcdFx0aWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHR2YXIgcG9zID0gZWwudG9vbHRpcFBvc2l0aW9uKCk7XHJcblx0XHRcdFx0eCArPSBwb3MueDtcclxuXHRcdFx0XHR5ICs9IHBvcy55O1xyXG5cdFx0XHRcdCsrY291bnQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiB4IC8gY291bnQsXHJcblx0XHRcdHk6IHkgLyBjb3VudFxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSB0b29sdGlwIHBvc2l0aW9uIG5lYXJlc3Qgb2YgdGhlIGl0ZW0gbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb25cclxuXHQgKiBAZnVuY3Rpb24gQ2hhcnQuVG9vbHRpcC5wb3NpdGlvbmVycy5uZWFyZXN0XHJcblx0ICogQHBhcmFtIGVsZW1lbnRzIHtDaGFydC5FbGVtZW50W119IHRoZSB0b29sdGlwIGVsZW1lbnRzXHJcblx0ICogQHBhcmFtIGV2ZW50UG9zaXRpb24ge29iamVjdH0gdGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCBpbiBjYW52YXMgY29vcmRpbmF0ZXNcclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSB0aGUgdG9vbHRpcCBwb3NpdGlvblxyXG5cdCAqL1xyXG5cdG5lYXJlc3Q6IGZ1bmN0aW9uKGVsZW1lbnRzLCBldmVudFBvc2l0aW9uKSB7XHJcblx0XHR2YXIgeCA9IGV2ZW50UG9zaXRpb24ueDtcclxuXHRcdHZhciB5ID0gZXZlbnRQb3NpdGlvbi55O1xyXG5cdFx0dmFyIG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG5cdFx0dmFyIGksIGxlbiwgbmVhcmVzdEVsZW1lbnQ7XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuXHRcdFx0dmFyIGVsID0gZWxlbWVudHNbaV07XHJcblx0XHRcdGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0dmFyIGNlbnRlciA9IGVsLmdldENlbnRlclBvaW50KCk7XHJcblx0XHRcdFx0dmFyIGQgPSBoZWxwZXJzJDEuZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGV2ZW50UG9zaXRpb24sIGNlbnRlcik7XHJcblxyXG5cdFx0XHRcdGlmIChkIDwgbWluRGlzdGFuY2UpIHtcclxuXHRcdFx0XHRcdG1pbkRpc3RhbmNlID0gZDtcclxuXHRcdFx0XHRcdG5lYXJlc3RFbGVtZW50ID0gZWw7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG5lYXJlc3RFbGVtZW50KSB7XHJcblx0XHRcdHZhciB0cCA9IG5lYXJlc3RFbGVtZW50LnRvb2x0aXBQb3NpdGlvbigpO1xyXG5cdFx0XHR4ID0gdHAueDtcclxuXHRcdFx0eSA9IHRwLnk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0eDogeCxcclxuXHRcdFx0eTogeVxyXG5cdFx0fTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBIZWxwZXIgdG8gcHVzaCBvciBjb25jYXQgYmFzZWQgb24gaWYgdGhlIDJuZCBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb3Igbm90XHJcbmZ1bmN0aW9uIHB1c2hPckNvbmNhdChiYXNlLCB0b1B1c2gpIHtcclxuXHRpZiAodG9QdXNoKSB7XHJcblx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkodG9QdXNoKSkge1xyXG5cdFx0XHQvLyBiYXNlID0gYmFzZS5jb25jYXQodG9QdXNoKTtcclxuXHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYmFzZSwgdG9QdXNoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGJhc2UucHVzaCh0b1B1c2gpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGJhc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFycmF5IG9mIHN0cmluZ3Mgc3BsaXQgYnkgbmV3bGluZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc3BsaXQgYnkgbmV3bGluZS5cclxuICogQHJldHVybnMge3N0cmluZ1tdfSB2YWx1ZSBpZiBuZXdsaW5lIHByZXNlbnQgLSBSZXR1cm5lZCBmcm9tIFN0cmluZyBzcGxpdCgpIG1ldGhvZFxyXG4gKiBAZnVuY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIHNwbGl0TmV3bGluZXMoc3RyKSB7XHJcblx0aWYgKCh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpICYmIHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XHJcblx0XHRyZXR1cm4gc3RyLnNwbGl0KCdcXG4nKTtcclxuXHR9XHJcblx0cmV0dXJuIHN0cjtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBQcml2YXRlIGhlbHBlciB0byBjcmVhdGUgYSB0b29sdGlwIGl0ZW0gbW9kZWxcclxuICogQHBhcmFtIGVsZW1lbnQgLSB0aGUgY2hhcnQgZWxlbWVudCAocG9pbnQsIGFyYywgYmFyKSB0byBjcmVhdGUgdGhlIHRvb2x0aXAgaXRlbSBmb3JcclxuICogQHJldHVybiBuZXcgdG9vbHRpcCBpdGVtXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwSXRlbShlbGVtZW50KSB7XHJcblx0dmFyIHhTY2FsZSA9IGVsZW1lbnQuX3hTY2FsZTtcclxuXHR2YXIgeVNjYWxlID0gZWxlbWVudC5feVNjYWxlIHx8IGVsZW1lbnQuX3NjYWxlOyAvLyBoYW5kbGUgcmFkYXIgfHwgcG9sYXJBcmVhIGNoYXJ0c1xyXG5cdHZhciBpbmRleCA9IGVsZW1lbnQuX2luZGV4O1xyXG5cdHZhciBkYXRhc2V0SW5kZXggPSBlbGVtZW50Ll9kYXRhc2V0SW5kZXg7XHJcblx0dmFyIGNvbnRyb2xsZXIgPSBlbGVtZW50Ll9jaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XHJcblx0dmFyIGluZGV4U2NhbGUgPSBjb250cm9sbGVyLl9nZXRJbmRleFNjYWxlKCk7XHJcblx0dmFyIHZhbHVlU2NhbGUgPSBjb250cm9sbGVyLl9nZXRWYWx1ZVNjYWxlKCk7XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR4TGFiZWw6IHhTY2FsZSA/IHhTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXHJcblx0XHR5TGFiZWw6IHlTY2FsZSA/IHlTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXHJcblx0XHRsYWJlbDogaW5kZXhTY2FsZSA/ICcnICsgaW5kZXhTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXHJcblx0XHR2YWx1ZTogdmFsdWVTY2FsZSA/ICcnICsgdmFsdWVTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXHJcblx0XHRpbmRleDogaW5kZXgsXHJcblx0XHRkYXRhc2V0SW5kZXg6IGRhdGFzZXRJbmRleCxcclxuXHRcdHg6IGVsZW1lbnQuX21vZGVsLngsXHJcblx0XHR5OiBlbGVtZW50Ll9tb2RlbC55XHJcblx0fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciB0byBnZXQgdGhlIHJlc2V0IG1vZGVsIGZvciB0aGUgdG9vbHRpcFxyXG4gKiBAcGFyYW0gdG9vbHRpcE9wdHMge29iamVjdH0gdGhlIHRvb2x0aXAgb3B0aW9uc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QmFzZU1vZGVsKHRvb2x0aXBPcHRzKSB7XHJcblx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHQvLyBQb3NpdGlvbmluZ1xyXG5cdFx0eFBhZGRpbmc6IHRvb2x0aXBPcHRzLnhQYWRkaW5nLFxyXG5cdFx0eVBhZGRpbmc6IHRvb2x0aXBPcHRzLnlQYWRkaW5nLFxyXG5cdFx0eEFsaWduOiB0b29sdGlwT3B0cy54QWxpZ24sXHJcblx0XHR5QWxpZ246IHRvb2x0aXBPcHRzLnlBbGlnbixcclxuXHJcblx0XHQvLyBEcmF3aW5nIGRpcmVjdGlvbiBhbmQgdGV4dCBkaXJlY3Rpb25cclxuXHRcdHJ0bDogdG9vbHRpcE9wdHMucnRsLFxyXG5cdFx0dGV4dERpcmVjdGlvbjogdG9vbHRpcE9wdHMudGV4dERpcmVjdGlvbixcclxuXHJcblx0XHQvLyBCb2R5XHJcblx0XHRib2R5Rm9udENvbG9yOiB0b29sdGlwT3B0cy5ib2R5Rm9udENvbG9yLFxyXG5cdFx0X2JvZHlGb250RmFtaWx5OiB2YWx1ZU9yRGVmYXVsdCQ4KHRvb2x0aXBPcHRzLmJvZHlGb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSksXHJcblx0XHRfYm9keUZvbnRTdHlsZTogdmFsdWVPckRlZmF1bHQkOCh0b29sdGlwT3B0cy5ib2R5Rm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKSxcclxuXHRcdF9ib2R5QWxpZ246IHRvb2x0aXBPcHRzLmJvZHlBbGlnbixcclxuXHRcdGJvZHlGb250U2l6ZTogdmFsdWVPckRlZmF1bHQkOCh0b29sdGlwT3B0cy5ib2R5Rm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSksXHJcblx0XHRib2R5U3BhY2luZzogdG9vbHRpcE9wdHMuYm9keVNwYWNpbmcsXHJcblxyXG5cdFx0Ly8gVGl0bGVcclxuXHRcdHRpdGxlRm9udENvbG9yOiB0b29sdGlwT3B0cy50aXRsZUZvbnRDb2xvcixcclxuXHRcdF90aXRsZUZvbnRGYW1pbHk6IHZhbHVlT3JEZWZhdWx0JDgodG9vbHRpcE9wdHMudGl0bGVGb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSksXHJcblx0XHRfdGl0bGVGb250U3R5bGU6IHZhbHVlT3JEZWZhdWx0JDgodG9vbHRpcE9wdHMudGl0bGVGb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpLFxyXG5cdFx0dGl0bGVGb250U2l6ZTogdmFsdWVPckRlZmF1bHQkOCh0b29sdGlwT3B0cy50aXRsZUZvbnRTaXplLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFNpemUpLFxyXG5cdFx0X3RpdGxlQWxpZ246IHRvb2x0aXBPcHRzLnRpdGxlQWxpZ24sXHJcblx0XHR0aXRsZVNwYWNpbmc6IHRvb2x0aXBPcHRzLnRpdGxlU3BhY2luZyxcclxuXHRcdHRpdGxlTWFyZ2luQm90dG9tOiB0b29sdGlwT3B0cy50aXRsZU1hcmdpbkJvdHRvbSxcclxuXHJcblx0XHQvLyBGb290ZXJcclxuXHRcdGZvb3RlckZvbnRDb2xvcjogdG9vbHRpcE9wdHMuZm9vdGVyRm9udENvbG9yLFxyXG5cdFx0X2Zvb3RlckZvbnRGYW1pbHk6IHZhbHVlT3JEZWZhdWx0JDgodG9vbHRpcE9wdHMuZm9vdGVyRm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRGYW1pbHkpLFxyXG5cdFx0X2Zvb3RlckZvbnRTdHlsZTogdmFsdWVPckRlZmF1bHQkOCh0b29sdGlwT3B0cy5mb290ZXJGb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpLFxyXG5cdFx0Zm9vdGVyRm9udFNpemU6IHZhbHVlT3JEZWZhdWx0JDgodG9vbHRpcE9wdHMuZm9vdGVyRm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSksXHJcblx0XHRfZm9vdGVyQWxpZ246IHRvb2x0aXBPcHRzLmZvb3RlckFsaWduLFxyXG5cdFx0Zm9vdGVyU3BhY2luZzogdG9vbHRpcE9wdHMuZm9vdGVyU3BhY2luZyxcclxuXHRcdGZvb3Rlck1hcmdpblRvcDogdG9vbHRpcE9wdHMuZm9vdGVyTWFyZ2luVG9wLFxyXG5cclxuXHRcdC8vIEFwcGVhcmFuY2VcclxuXHRcdGNhcmV0U2l6ZTogdG9vbHRpcE9wdHMuY2FyZXRTaXplLFxyXG5cdFx0Y29ybmVyUmFkaXVzOiB0b29sdGlwT3B0cy5jb3JuZXJSYWRpdXMsXHJcblx0XHRiYWNrZ3JvdW5kQ29sb3I6IHRvb2x0aXBPcHRzLmJhY2tncm91bmRDb2xvcixcclxuXHRcdG9wYWNpdHk6IDAsXHJcblx0XHRsZWdlbmRDb2xvckJhY2tncm91bmQ6IHRvb2x0aXBPcHRzLm11bHRpS2V5QmFja2dyb3VuZCxcclxuXHRcdGRpc3BsYXlDb2xvcnM6IHRvb2x0aXBPcHRzLmRpc3BsYXlDb2xvcnMsXHJcblx0XHRib3JkZXJDb2xvcjogdG9vbHRpcE9wdHMuYm9yZGVyQ29sb3IsXHJcblx0XHRib3JkZXJXaWR0aDogdG9vbHRpcE9wdHMuYm9yZGVyV2lkdGhcclxuXHR9O1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBzaXplIG9mIHRoZSB0b29sdGlwXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRUb29sdGlwU2l6ZSh0b29sdGlwLCBtb2RlbCkge1xyXG5cdHZhciBjdHggPSB0b29sdGlwLl9jaGFydC5jdHg7XHJcblxyXG5cdHZhciBoZWlnaHQgPSBtb2RlbC55UGFkZGluZyAqIDI7IC8vIFRvb2x0aXAgUGFkZGluZ1xyXG5cdHZhciB3aWR0aCA9IDA7XHJcblxyXG5cdC8vIENvdW50IG9mIGFsbCBsaW5lcyBpbiB0aGUgYm9keVxyXG5cdHZhciBib2R5ID0gbW9kZWwuYm9keTtcclxuXHR2YXIgY29tYmluZWRCb2R5TGVuZ3RoID0gYm9keS5yZWR1Y2UoZnVuY3Rpb24oY291bnQsIGJvZHlJdGVtKSB7XHJcblx0XHRyZXR1cm4gY291bnQgKyBib2R5SXRlbS5iZWZvcmUubGVuZ3RoICsgYm9keUl0ZW0ubGluZXMubGVuZ3RoICsgYm9keUl0ZW0uYWZ0ZXIubGVuZ3RoO1xyXG5cdH0sIDApO1xyXG5cdGNvbWJpbmVkQm9keUxlbmd0aCArPSBtb2RlbC5iZWZvcmVCb2R5Lmxlbmd0aCArIG1vZGVsLmFmdGVyQm9keS5sZW5ndGg7XHJcblxyXG5cdHZhciB0aXRsZUxpbmVDb3VudCA9IG1vZGVsLnRpdGxlLmxlbmd0aDtcclxuXHR2YXIgZm9vdGVyTGluZUNvdW50ID0gbW9kZWwuZm9vdGVyLmxlbmd0aDtcclxuXHR2YXIgdGl0bGVGb250U2l6ZSA9IG1vZGVsLnRpdGxlRm9udFNpemU7XHJcblx0dmFyIGJvZHlGb250U2l6ZSA9IG1vZGVsLmJvZHlGb250U2l6ZTtcclxuXHR2YXIgZm9vdGVyRm9udFNpemUgPSBtb2RlbC5mb290ZXJGb250U2l6ZTtcclxuXHJcblx0aGVpZ2h0ICs9IHRpdGxlTGluZUNvdW50ICogdGl0bGVGb250U2l6ZTsgLy8gVGl0bGUgTGluZXNcclxuXHRoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgPyAodGl0bGVMaW5lQ291bnQgLSAxKSAqIG1vZGVsLnRpdGxlU3BhY2luZyA6IDA7IC8vIFRpdGxlIExpbmUgU3BhY2luZ1xyXG5cdGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCA/IG1vZGVsLnRpdGxlTWFyZ2luQm90dG9tIDogMDsgLy8gVGl0bGUncyBib3R0b20gTWFyZ2luXHJcblx0aGVpZ2h0ICs9IGNvbWJpbmVkQm9keUxlbmd0aCAqIGJvZHlGb250U2l6ZTsgLy8gQm9keSBMaW5lc1xyXG5cdGhlaWdodCArPSBjb21iaW5lZEJvZHlMZW5ndGggPyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gMSkgKiBtb2RlbC5ib2R5U3BhY2luZyA6IDA7IC8vIEJvZHkgTGluZSBTcGFjaW5nXHJcblx0aGVpZ2h0ICs9IGZvb3RlckxpbmVDb3VudCA/IG1vZGVsLmZvb3Rlck1hcmdpblRvcCA6IDA7IC8vIEZvb3RlciBNYXJnaW5cclxuXHRoZWlnaHQgKz0gZm9vdGVyTGluZUNvdW50ICogKGZvb3RlckZvbnRTaXplKTsgLy8gRm9vdGVyIExpbmVzXHJcblx0aGVpZ2h0ICs9IGZvb3RlckxpbmVDb3VudCA/IChmb290ZXJMaW5lQ291bnQgLSAxKSAqIG1vZGVsLmZvb3RlclNwYWNpbmcgOiAwOyAvLyBGb290ZXIgTGluZSBTcGFjaW5nXHJcblxyXG5cdC8vIFRpdGxlIHdpZHRoXHJcblx0dmFyIHdpZHRoUGFkZGluZyA9IDA7XHJcblx0dmFyIG1heExpbmVXaWR0aCA9IGZ1bmN0aW9uKGxpbmUpIHtcclxuXHRcdHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGN0eC5tZWFzdXJlVGV4dChsaW5lKS53aWR0aCArIHdpZHRoUGFkZGluZyk7XHJcblx0fTtcclxuXHJcblx0Y3R4LmZvbnQgPSBoZWxwZXJzJDEuZm9udFN0cmluZyh0aXRsZUZvbnRTaXplLCBtb2RlbC5fdGl0bGVGb250U3R5bGUsIG1vZGVsLl90aXRsZUZvbnRGYW1pbHkpO1xyXG5cdGhlbHBlcnMkMS5lYWNoKG1vZGVsLnRpdGxlLCBtYXhMaW5lV2lkdGgpO1xyXG5cclxuXHQvLyBCb2R5IHdpZHRoXHJcblx0Y3R4LmZvbnQgPSBoZWxwZXJzJDEuZm9udFN0cmluZyhib2R5Rm9udFNpemUsIG1vZGVsLl9ib2R5Rm9udFN0eWxlLCBtb2RlbC5fYm9keUZvbnRGYW1pbHkpO1xyXG5cdGhlbHBlcnMkMS5lYWNoKG1vZGVsLmJlZm9yZUJvZHkuY29uY2F0KG1vZGVsLmFmdGVyQm9keSksIG1heExpbmVXaWR0aCk7XHJcblxyXG5cdC8vIEJvZHkgbGluZXMgbWF5IGluY2x1ZGUgc29tZSBleHRyYSB3aWR0aCBkdWUgdG8gdGhlIGNvbG9yIGJveFxyXG5cdHdpZHRoUGFkZGluZyA9IG1vZGVsLmRpc3BsYXlDb2xvcnMgPyAoYm9keUZvbnRTaXplICsgMikgOiAwO1xyXG5cdGhlbHBlcnMkMS5lYWNoKGJvZHksIGZ1bmN0aW9uKGJvZHlJdGVtKSB7XHJcblx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5iZWZvcmUsIG1heExpbmVXaWR0aCk7XHJcblx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5saW5lcywgbWF4TGluZVdpZHRoKTtcclxuXHRcdGhlbHBlcnMkMS5lYWNoKGJvZHlJdGVtLmFmdGVyLCBtYXhMaW5lV2lkdGgpO1xyXG5cdH0pO1xyXG5cclxuXHQvLyBSZXNldCBiYWNrIHRvIDBcclxuXHR3aWR0aFBhZGRpbmcgPSAwO1xyXG5cclxuXHQvLyBGb290ZXIgd2lkdGhcclxuXHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKGZvb3RlckZvbnRTaXplLCBtb2RlbC5fZm9vdGVyRm9udFN0eWxlLCBtb2RlbC5fZm9vdGVyRm9udEZhbWlseSk7XHJcblx0aGVscGVycyQxLmVhY2gobW9kZWwuZm9vdGVyLCBtYXhMaW5lV2lkdGgpO1xyXG5cclxuXHQvLyBBZGQgcGFkZGluZ1xyXG5cdHdpZHRoICs9IDIgKiBtb2RlbC54UGFkZGluZztcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHdpZHRoOiB3aWR0aCxcclxuXHRcdGhlaWdodDogaGVpZ2h0XHJcblx0fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciB0byBnZXQgdGhlIGFsaWdubWVudCBvZiBhIHRvb2x0aXAgZ2l2ZW4gdGhlIHNpemVcclxuICovXHJcbmZ1bmN0aW9uIGRldGVybWluZUFsaWdubWVudCh0b29sdGlwLCBzaXplKSB7XHJcblx0dmFyIG1vZGVsID0gdG9vbHRpcC5fbW9kZWw7XHJcblx0dmFyIGNoYXJ0ID0gdG9vbHRpcC5fY2hhcnQ7XHJcblx0dmFyIGNoYXJ0QXJlYSA9IHRvb2x0aXAuX2NoYXJ0LmNoYXJ0QXJlYTtcclxuXHR2YXIgeEFsaWduID0gJ2NlbnRlcic7XHJcblx0dmFyIHlBbGlnbiA9ICdjZW50ZXInO1xyXG5cclxuXHRpZiAobW9kZWwueSA8IHNpemUuaGVpZ2h0KSB7XHJcblx0XHR5QWxpZ24gPSAndG9wJztcclxuXHR9IGVsc2UgaWYgKG1vZGVsLnkgPiAoY2hhcnQuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpKSB7XHJcblx0XHR5QWxpZ24gPSAnYm90dG9tJztcclxuXHR9XHJcblxyXG5cdHZhciBsZiwgcmY7IC8vIGZ1bmN0aW9ucyB0byBkZXRlcm1pbmUgbGVmdCwgcmlnaHQgYWxpZ25tZW50XHJcblx0dmFyIG9sZiwgb3JmOyAvLyBmdW5jdGlvbnMgdG8gZGV0ZXJtaW5lIGlmIGxlZnQvcmlnaHQgYWxpZ25tZW50IGNhdXNlcyB0b29sdGlwIHRvIGdvIG91dHNpZGUgY2hhcnRcclxuXHR2YXIgeWY7IC8vIGZ1bmN0aW9uIHRvIGdldCB0aGUgeSBhbGlnbm1lbnQgaWYgdGhlIHRvb2x0aXAgZ29lcyBvdXRzaWRlIG9mIHRoZSBsZWZ0IG9yIHJpZ2h0IGVkZ2VzXHJcblx0dmFyIG1pZFggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMjtcclxuXHR2YXIgbWlkWSA9IChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyO1xyXG5cclxuXHRpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xyXG5cdFx0bGYgPSBmdW5jdGlvbih4KSB7XHJcblx0XHRcdHJldHVybiB4IDw9IG1pZFg7XHJcblx0XHR9O1xyXG5cdFx0cmYgPSBmdW5jdGlvbih4KSB7XHJcblx0XHRcdHJldHVybiB4ID4gbWlkWDtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdGxmID0gZnVuY3Rpb24oeCkge1xyXG5cdFx0XHRyZXR1cm4geCA8PSAoc2l6ZS53aWR0aCAvIDIpO1xyXG5cdFx0fTtcclxuXHRcdHJmID0gZnVuY3Rpb24oeCkge1xyXG5cdFx0XHRyZXR1cm4geCA+PSAoY2hhcnQud2lkdGggLSAoc2l6ZS53aWR0aCAvIDIpKTtcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRvbGYgPSBmdW5jdGlvbih4KSB7XHJcblx0XHRyZXR1cm4geCArIHNpemUud2lkdGggKyBtb2RlbC5jYXJldFNpemUgKyBtb2RlbC5jYXJldFBhZGRpbmcgPiBjaGFydC53aWR0aDtcclxuXHR9O1xyXG5cdG9yZiA9IGZ1bmN0aW9uKHgpIHtcclxuXHRcdHJldHVybiB4IC0gc2l6ZS53aWR0aCAtIG1vZGVsLmNhcmV0U2l6ZSAtIG1vZGVsLmNhcmV0UGFkZGluZyA8IDA7XHJcblx0fTtcclxuXHR5ZiA9IGZ1bmN0aW9uKHkpIHtcclxuXHRcdHJldHVybiB5IDw9IG1pZFkgPyAndG9wJyA6ICdib3R0b20nO1xyXG5cdH07XHJcblxyXG5cdGlmIChsZihtb2RlbC54KSkge1xyXG5cdFx0eEFsaWduID0gJ2xlZnQnO1xyXG5cclxuXHRcdC8vIElzIHRvb2x0aXAgdG9vIHdpZGUgYW5kIGdvZXMgb3ZlciB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgY2hhcnQuP1xyXG5cdFx0aWYgKG9sZihtb2RlbC54KSkge1xyXG5cdFx0XHR4QWxpZ24gPSAnY2VudGVyJztcclxuXHRcdFx0eUFsaWduID0geWYobW9kZWwueSk7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmIChyZihtb2RlbC54KSkge1xyXG5cdFx0eEFsaWduID0gJ3JpZ2h0JztcclxuXHJcblx0XHQvLyBJcyB0b29sdGlwIHRvbyB3aWRlIGFuZCBnb2VzIG91dHNpZGUgbGVmdCBlZGdlIG9mIGNhbnZhcz9cclxuXHRcdGlmIChvcmYobW9kZWwueCkpIHtcclxuXHRcdFx0eEFsaWduID0gJ2NlbnRlcic7XHJcblx0XHRcdHlBbGlnbiA9IHlmKG1vZGVsLnkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0dmFyIG9wdHMgPSB0b29sdGlwLl9vcHRpb25zO1xyXG5cdHJldHVybiB7XHJcblx0XHR4QWxpZ246IG9wdHMueEFsaWduID8gb3B0cy54QWxpZ24gOiB4QWxpZ24sXHJcblx0XHR5QWxpZ246IG9wdHMueUFsaWduID8gb3B0cy55QWxpZ24gOiB5QWxpZ25cclxuXHR9O1xyXG59XHJcblxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCB0aGUgbG9jYXRpb24gYSB0b29sdGlwIG5lZWRzIHRvIGJlIHBsYWNlZCBhdCBnaXZlbiB0aGUgaW5pdGlhbCBwb3NpdGlvbiAodmlhIHRoZSB2bSkgYW5kIHRoZSBzaXplIGFuZCBhbGlnbm1lbnRcclxuICovXHJcbmZ1bmN0aW9uIGdldEJhY2tncm91bmRQb2ludCh2bSwgc2l6ZSwgYWxpZ25tZW50LCBjaGFydCkge1xyXG5cdC8vIEJhY2tncm91bmQgUG9zaXRpb25cclxuXHR2YXIgeCA9IHZtLng7XHJcblx0dmFyIHkgPSB2bS55O1xyXG5cclxuXHR2YXIgY2FyZXRTaXplID0gdm0uY2FyZXRTaXplO1xyXG5cdHZhciBjYXJldFBhZGRpbmcgPSB2bS5jYXJldFBhZGRpbmc7XHJcblx0dmFyIGNvcm5lclJhZGl1cyA9IHZtLmNvcm5lclJhZGl1cztcclxuXHR2YXIgeEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcclxuXHR2YXIgeUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcclxuXHR2YXIgcGFkZGluZ0FuZFNpemUgPSBjYXJldFNpemUgKyBjYXJldFBhZGRpbmc7XHJcblx0dmFyIHJhZGl1c0FuZFBhZGRpbmcgPSBjb3JuZXJSYWRpdXMgKyBjYXJldFBhZGRpbmc7XHJcblxyXG5cdGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcclxuXHRcdHggLT0gc2l6ZS53aWR0aDtcclxuXHR9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2NlbnRlcicpIHtcclxuXHRcdHggLT0gKHNpemUud2lkdGggLyAyKTtcclxuXHRcdGlmICh4ICsgc2l6ZS53aWR0aCA+IGNoYXJ0LndpZHRoKSB7XHJcblx0XHRcdHggPSBjaGFydC53aWR0aCAtIHNpemUud2lkdGg7XHJcblx0XHR9XHJcblx0XHRpZiAoeCA8IDApIHtcclxuXHRcdFx0eCA9IDA7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAoeUFsaWduID09PSAndG9wJykge1xyXG5cdFx0eSArPSBwYWRkaW5nQW5kU2l6ZTtcclxuXHR9IGVsc2UgaWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcclxuXHRcdHkgLT0gc2l6ZS5oZWlnaHQgKyBwYWRkaW5nQW5kU2l6ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0eSAtPSAoc2l6ZS5oZWlnaHQgLyAyKTtcclxuXHR9XHJcblxyXG5cdGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XHJcblx0XHRpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcclxuXHRcdFx0eCArPSBwYWRkaW5nQW5kU2l6ZTtcclxuXHRcdH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XHJcblx0XHRcdHggLT0gcGFkZGluZ0FuZFNpemU7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xyXG5cdFx0eCAtPSByYWRpdXNBbmRQYWRkaW5nO1xyXG5cdH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XHJcblx0XHR4ICs9IHJhZGl1c0FuZFBhZGRpbmc7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0eDogeCxcclxuXHRcdHk6IHlcclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRBbGlnbmVkWCh2bSwgYWxpZ24pIHtcclxuXHRyZXR1cm4gYWxpZ24gPT09ICdjZW50ZXInXHJcblx0XHQ/IHZtLnggKyB2bS53aWR0aCAvIDJcclxuXHRcdDogYWxpZ24gPT09ICdyaWdodCdcclxuXHRcdFx0PyB2bS54ICsgdm0ud2lkdGggLSB2bS54UGFkZGluZ1xyXG5cdFx0XHQ6IHZtLnggKyB2bS54UGFkZGluZztcclxufVxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciB0byBidWlsZCBiZWZvcmUgYW5kIGFmdGVyIGJvZHkgbGluZXNcclxuICovXHJcbmZ1bmN0aW9uIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKGNhbGxiYWNrKSB7XHJcblx0cmV0dXJuIHB1c2hPckNvbmNhdChbXSwgc3BsaXROZXdsaW5lcyhjYWxsYmFjaykpO1xyXG59XHJcblxyXG52YXIgZXhwb3J0cyQ0ID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLl9tb2RlbCA9IGdldEJhc2VNb2RlbCh0aGlzLl9vcHRpb25zKTtcclxuXHRcdHRoaXMuX2xhc3RBY3RpdmUgPSBbXTtcclxuXHR9LFxyXG5cclxuXHQvLyBHZXQgdGhlIHRpdGxlXHJcblx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcclxuXHRnZXRUaXRsZTogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdHMgPSBtZS5fb3B0aW9ucztcclxuXHRcdHZhciBjYWxsYmFja3MgPSBvcHRzLmNhbGxiYWNrcztcclxuXHJcblx0XHR2YXIgYmVmb3JlVGl0bGUgPSBjYWxsYmFja3MuYmVmb3JlVGl0bGUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XHJcblx0XHR2YXIgdGl0bGUgPSBjYWxsYmFja3MudGl0bGUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XHJcblx0XHR2YXIgYWZ0ZXJUaXRsZSA9IGNhbGxiYWNrcy5hZnRlclRpdGxlLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xyXG5cclxuXHRcdHZhciBsaW5lcyA9IFtdO1xyXG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlVGl0bGUpKTtcclxuXHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKHRpdGxlKSk7XHJcblx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlclRpdGxlKSk7XHJcblxyXG5cdFx0cmV0dXJuIGxpbmVzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXHJcblx0Z2V0QmVmb3JlQm9keTogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXModGhpcy5fb3B0aW9ucy5jYWxsYmFja3MuYmVmb3JlQm9keS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxyXG5cdGdldEJvZHk6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtcywgZGF0YSkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjYWxsYmFja3MgPSBtZS5fb3B0aW9ucy5jYWxsYmFja3M7XHJcblx0XHR2YXIgYm9keUl0ZW1zID0gW107XHJcblxyXG5cdFx0aGVscGVycyQxLmVhY2godG9vbHRpcEl0ZW1zLCBmdW5jdGlvbih0b29sdGlwSXRlbSkge1xyXG5cdFx0XHR2YXIgYm9keUl0ZW0gPSB7XHJcblx0XHRcdFx0YmVmb3JlOiBbXSxcclxuXHRcdFx0XHRsaW5lczogW10sXHJcblx0XHRcdFx0YWZ0ZXI6IFtdXHJcblx0XHRcdH07XHJcblx0XHRcdHB1c2hPckNvbmNhdChib2R5SXRlbS5iZWZvcmUsIHNwbGl0TmV3bGluZXMoY2FsbGJhY2tzLmJlZm9yZUxhYmVsLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBkYXRhKSkpO1xyXG5cdFx0XHRwdXNoT3JDb25jYXQoYm9keUl0ZW0ubGluZXMsIGNhbGxiYWNrcy5sYWJlbC5jYWxsKG1lLCB0b29sdGlwSXRlbSwgZGF0YSkpO1xyXG5cdFx0XHRwdXNoT3JDb25jYXQoYm9keUl0ZW0uYWZ0ZXIsIHNwbGl0TmV3bGluZXMoY2FsbGJhY2tzLmFmdGVyTGFiZWwuY2FsbChtZSwgdG9vbHRpcEl0ZW0sIGRhdGEpKSk7XHJcblxyXG5cdFx0XHRib2R5SXRlbXMucHVzaChib2R5SXRlbSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gYm9keUl0ZW1zO1xyXG5cdH0sXHJcblxyXG5cdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXHJcblx0Z2V0QWZ0ZXJCb2R5OiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyh0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5hZnRlckJvZHkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gR2V0IHRoZSBmb290ZXIgYW5kIGJlZm9yZUZvb3RlciBhbmQgYWZ0ZXJGb290ZXIgbGluZXNcclxuXHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxyXG5cdGdldEZvb3RlcjogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGNhbGxiYWNrcyA9IG1lLl9vcHRpb25zLmNhbGxiYWNrcztcclxuXHJcblx0XHR2YXIgYmVmb3JlRm9vdGVyID0gY2FsbGJhY2tzLmJlZm9yZUZvb3Rlci5hcHBseShtZSwgYXJndW1lbnRzKTtcclxuXHRcdHZhciBmb290ZXIgPSBjYWxsYmFja3MuZm9vdGVyLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xyXG5cdFx0dmFyIGFmdGVyRm9vdGVyID0gY2FsbGJhY2tzLmFmdGVyRm9vdGVyLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xyXG5cclxuXHRcdHZhciBsaW5lcyA9IFtdO1xyXG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlRm9vdGVyKSk7XHJcblx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhmb290ZXIpKTtcclxuXHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGFmdGVyRm9vdGVyKSk7XHJcblxyXG5cdFx0cmV0dXJuIGxpbmVzO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24oY2hhbmdlZCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBvcHRzID0gbWUuX29wdGlvbnM7XHJcblxyXG5cdFx0Ly8gTmVlZCB0byByZWdlbmVyYXRlIHRoZSBtb2RlbCBiZWNhdXNlIGl0cyBmYXN0ZXIgdGhhbiB1c2luZyBleHRlbmQgYW5kIGl0IGlzIG5lY2Vzc2FyeSBkdWUgdG8gdGhlIG9wdGltaXphdGlvbiBpbiBDaGFydC5FbGVtZW50LnRyYW5zaXRpb25cclxuXHRcdC8vIHRoYXQgZG9lcyBfdmlldyA9IF9tb2RlbCBpZiBlYXNlID09PSAxLiBUaGlzIGNhdXNlcyB0aGUgMm5kIHRvb2x0aXAgdXBkYXRlIHRvIHNldCBwcm9wZXJ0aWVzIGluIGJvdGggdGhlIHZpZXcgYW5kIG1vZGVsIGF0IHRoZSBzYW1lIHRpbWVcclxuXHRcdC8vIHdoaWNoIGJyZWFrcyBhbnkgYW5pbWF0aW9ucy5cclxuXHRcdHZhciBleGlzdGluZ01vZGVsID0gbWUuX21vZGVsO1xyXG5cdFx0dmFyIG1vZGVsID0gbWUuX21vZGVsID0gZ2V0QmFzZU1vZGVsKG9wdHMpO1xyXG5cdFx0dmFyIGFjdGl2ZSA9IG1lLl9hY3RpdmU7XHJcblxyXG5cdFx0dmFyIGRhdGEgPSBtZS5fZGF0YTtcclxuXHJcblx0XHQvLyBJbiB0aGUgY2FzZSB3aGVyZSBhY3RpdmUubGVuZ3RoID09PSAwIHdlIG5lZWQgdG8ga2VlcCB0aGVzZSBhdCBleGlzdGluZyB2YWx1ZXMgZm9yIGdvb2QgYW5pbWF0aW9uc1xyXG5cdFx0dmFyIGFsaWdubWVudCA9IHtcclxuXHRcdFx0eEFsaWduOiBleGlzdGluZ01vZGVsLnhBbGlnbixcclxuXHRcdFx0eUFsaWduOiBleGlzdGluZ01vZGVsLnlBbGlnblxyXG5cdFx0fTtcclxuXHRcdHZhciBiYWNrZ3JvdW5kUG9pbnQgPSB7XHJcblx0XHRcdHg6IGV4aXN0aW5nTW9kZWwueCxcclxuXHRcdFx0eTogZXhpc3RpbmdNb2RlbC55XHJcblx0XHR9O1xyXG5cdFx0dmFyIHRvb2x0aXBTaXplID0ge1xyXG5cdFx0XHR3aWR0aDogZXhpc3RpbmdNb2RlbC53aWR0aCxcclxuXHRcdFx0aGVpZ2h0OiBleGlzdGluZ01vZGVsLmhlaWdodFxyXG5cdFx0fTtcclxuXHRcdHZhciB0b29sdGlwUG9zaXRpb24gPSB7XHJcblx0XHRcdHg6IGV4aXN0aW5nTW9kZWwuY2FyZXRYLFxyXG5cdFx0XHR5OiBleGlzdGluZ01vZGVsLmNhcmV0WVxyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgaSwgbGVuO1xyXG5cclxuXHRcdGlmIChhY3RpdmUubGVuZ3RoKSB7XHJcblx0XHRcdG1vZGVsLm9wYWNpdHkgPSAxO1xyXG5cclxuXHRcdFx0dmFyIGxhYmVsQ29sb3JzID0gW107XHJcblx0XHRcdHZhciBsYWJlbFRleHRDb2xvcnMgPSBbXTtcclxuXHRcdFx0dG9vbHRpcFBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0cy5wb3NpdGlvbl0uY2FsbChtZSwgYWN0aXZlLCBtZS5fZXZlbnRQb3NpdGlvbik7XHJcblxyXG5cdFx0XHR2YXIgdG9vbHRpcEl0ZW1zID0gW107XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGFjdGl2ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG5cdFx0XHRcdHRvb2x0aXBJdGVtcy5wdXNoKGNyZWF0ZVRvb2x0aXBJdGVtKGFjdGl2ZVtpXSkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIGZpbHRlciBmdW5jdGlvbiwgdXNlIGl0IHRvIG1vZGlmeSB0aGUgdG9vbHRpcCBpdGVtc1xyXG5cdFx0XHRpZiAob3B0cy5maWx0ZXIpIHtcclxuXHRcdFx0XHR0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGEpIHtcclxuXHRcdFx0XHRcdHJldHVybiBvcHRzLmZpbHRlcihhLCBkYXRhKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gSWYgdGhlIHVzZXIgcHJvdmlkZWQgYSBzb3J0aW5nIGZ1bmN0aW9uLCB1c2UgaXQgdG8gbW9kaWZ5IHRoZSB0b29sdGlwIGl0ZW1zXHJcblx0XHRcdGlmIChvcHRzLml0ZW1Tb3J0KSB7XHJcblx0XHRcdFx0dG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG9wdHMuaXRlbVNvcnQoYSwgYiwgZGF0YSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIERldGVybWluZSBjb2xvcnMgZm9yIGJveGVzXHJcblx0XHRcdGhlbHBlcnMkMS5lYWNoKHRvb2x0aXBJdGVtcywgZnVuY3Rpb24odG9vbHRpcEl0ZW0pIHtcclxuXHRcdFx0XHRsYWJlbENvbG9ycy5wdXNoKG9wdHMuY2FsbGJhY2tzLmxhYmVsQ29sb3IuY2FsbChtZSwgdG9vbHRpcEl0ZW0sIG1lLl9jaGFydCkpO1xyXG5cdFx0XHRcdGxhYmVsVGV4dENvbG9ycy5wdXNoKG9wdHMuY2FsbGJhY2tzLmxhYmVsVGV4dENvbG9yLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBtZS5fY2hhcnQpKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cclxuXHRcdFx0Ly8gQnVpbGQgdGhlIFRleHQgTGluZXNcclxuXHRcdFx0bW9kZWwudGl0bGUgPSBtZS5nZXRUaXRsZSh0b29sdGlwSXRlbXMsIGRhdGEpO1xyXG5cdFx0XHRtb2RlbC5iZWZvcmVCb2R5ID0gbWUuZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIGRhdGEpO1xyXG5cdFx0XHRtb2RlbC5ib2R5ID0gbWUuZ2V0Qm9keSh0b29sdGlwSXRlbXMsIGRhdGEpO1xyXG5cdFx0XHRtb2RlbC5hZnRlckJvZHkgPSBtZS5nZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBkYXRhKTtcclxuXHRcdFx0bW9kZWwuZm9vdGVyID0gbWUuZ2V0Rm9vdGVyKHRvb2x0aXBJdGVtcywgZGF0YSk7XHJcblxyXG5cdFx0XHQvLyBJbml0aWFsIHBvc2l0aW9uaW5nIGFuZCBjb2xvcnNcclxuXHRcdFx0bW9kZWwueCA9IHRvb2x0aXBQb3NpdGlvbi54O1xyXG5cdFx0XHRtb2RlbC55ID0gdG9vbHRpcFBvc2l0aW9uLnk7XHJcblx0XHRcdG1vZGVsLmNhcmV0UGFkZGluZyA9IG9wdHMuY2FyZXRQYWRkaW5nO1xyXG5cdFx0XHRtb2RlbC5sYWJlbENvbG9ycyA9IGxhYmVsQ29sb3JzO1xyXG5cdFx0XHRtb2RlbC5sYWJlbFRleHRDb2xvcnMgPSBsYWJlbFRleHRDb2xvcnM7XHJcblxyXG5cdFx0XHQvLyBkYXRhIHBvaW50c1xyXG5cdFx0XHRtb2RlbC5kYXRhUG9pbnRzID0gdG9vbHRpcEl0ZW1zO1xyXG5cclxuXHRcdFx0Ly8gV2UgbmVlZCB0byBkZXRlcm1pbmUgYWxpZ25tZW50IG9mIHRoZSB0b29sdGlwXHJcblx0XHRcdHRvb2x0aXBTaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgbW9kZWwpO1xyXG5cdFx0XHRhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQodGhpcywgdG9vbHRpcFNpemUpO1xyXG5cdFx0XHQvLyBGaW5hbCBTaXplIGFuZCBQb3NpdGlvblxyXG5cdFx0XHRiYWNrZ3JvdW5kUG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQobW9kZWwsIHRvb2x0aXBTaXplLCBhbGlnbm1lbnQsIG1lLl9jaGFydCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtb2RlbC5vcGFjaXR5ID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRtb2RlbC54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xyXG5cdFx0bW9kZWwueUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcclxuXHRcdG1vZGVsLnggPSBiYWNrZ3JvdW5kUG9pbnQueDtcclxuXHRcdG1vZGVsLnkgPSBiYWNrZ3JvdW5kUG9pbnQueTtcclxuXHRcdG1vZGVsLndpZHRoID0gdG9vbHRpcFNpemUud2lkdGg7XHJcblx0XHRtb2RlbC5oZWlnaHQgPSB0b29sdGlwU2l6ZS5oZWlnaHQ7XHJcblxyXG5cdFx0Ly8gUG9pbnQgd2hlcmUgdGhlIGNhcmV0IG9uIHRoZSB0b29sdGlwIHBvaW50cyB0b1xyXG5cdFx0bW9kZWwuY2FyZXRYID0gdG9vbHRpcFBvc2l0aW9uLng7XHJcblx0XHRtb2RlbC5jYXJldFkgPSB0b29sdGlwUG9zaXRpb24ueTtcclxuXHJcblx0XHRtZS5fbW9kZWwgPSBtb2RlbDtcclxuXHJcblx0XHRpZiAoY2hhbmdlZCAmJiBvcHRzLmN1c3RvbSkge1xyXG5cdFx0XHRvcHRzLmN1c3RvbS5jYWxsKG1lLCBtb2RlbCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1lO1xyXG5cdH0sXHJcblxyXG5cdGRyYXdDYXJldDogZnVuY3Rpb24odG9vbHRpcFBvaW50LCBzaXplKSB7XHJcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xyXG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHRcdHZhciBjYXJldFBvc2l0aW9uID0gdGhpcy5nZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgdm0pO1xyXG5cclxuXHRcdGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MSwgY2FyZXRQb3NpdGlvbi55MSk7XHJcblx0XHRjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDIsIGNhcmV0UG9zaXRpb24ueTIpO1xyXG5cdFx0Y3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngzLCBjYXJldFBvc2l0aW9uLnkzKTtcclxuXHR9LFxyXG5cdGdldENhcmV0UG9zaXRpb246IGZ1bmN0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgdm0pIHtcclxuXHRcdHZhciB4MSwgeDIsIHgzLCB5MSwgeTIsIHkzO1xyXG5cdFx0dmFyIGNhcmV0U2l6ZSA9IHZtLmNhcmV0U2l6ZTtcclxuXHRcdHZhciBjb3JuZXJSYWRpdXMgPSB2bS5jb3JuZXJSYWRpdXM7XHJcblx0XHR2YXIgeEFsaWduID0gdm0ueEFsaWduO1xyXG5cdFx0dmFyIHlBbGlnbiA9IHZtLnlBbGlnbjtcclxuXHRcdHZhciBwdFggPSB0b29sdGlwUG9pbnQueDtcclxuXHRcdHZhciBwdFkgPSB0b29sdGlwUG9pbnQueTtcclxuXHRcdHZhciB3aWR0aCA9IHNpemUud2lkdGg7XHJcblx0XHR2YXIgaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XHJcblxyXG5cdFx0aWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcclxuXHRcdFx0eTIgPSBwdFkgKyAoaGVpZ2h0IC8gMik7XHJcblxyXG5cdFx0XHRpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcclxuXHRcdFx0XHR4MSA9IHB0WDtcclxuXHRcdFx0XHR4MiA9IHgxIC0gY2FyZXRTaXplO1xyXG5cdFx0XHRcdHgzID0geDE7XHJcblxyXG5cdFx0XHRcdHkxID0geTIgKyBjYXJldFNpemU7XHJcblx0XHRcdFx0eTMgPSB5MiAtIGNhcmV0U2l6ZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR4MSA9IHB0WCArIHdpZHRoO1xyXG5cdFx0XHRcdHgyID0geDEgKyBjYXJldFNpemU7XHJcblx0XHRcdFx0eDMgPSB4MTtcclxuXHJcblx0XHRcdFx0eTEgPSB5MiAtIGNhcmV0U2l6ZTtcclxuXHRcdFx0XHR5MyA9IHkyICsgY2FyZXRTaXplO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcclxuXHRcdFx0XHR4MiA9IHB0WCArIGNvcm5lclJhZGl1cyArIChjYXJldFNpemUpO1xyXG5cdFx0XHRcdHgxID0geDIgLSBjYXJldFNpemU7XHJcblx0XHRcdFx0eDMgPSB4MiArIGNhcmV0U2l6ZTtcclxuXHRcdFx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcclxuXHRcdFx0XHR4MiA9IHB0WCArIHdpZHRoIC0gY29ybmVyUmFkaXVzIC0gY2FyZXRTaXplO1xyXG5cdFx0XHRcdHgxID0geDIgLSBjYXJldFNpemU7XHJcblx0XHRcdFx0eDMgPSB4MiArIGNhcmV0U2l6ZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR4MiA9IHZtLmNhcmV0WDtcclxuXHRcdFx0XHR4MSA9IHgyIC0gY2FyZXRTaXplO1xyXG5cdFx0XHRcdHgzID0geDIgKyBjYXJldFNpemU7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcclxuXHRcdFx0XHR5MSA9IHB0WTtcclxuXHRcdFx0XHR5MiA9IHkxIC0gY2FyZXRTaXplO1xyXG5cdFx0XHRcdHkzID0geTE7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0eTEgPSBwdFkgKyBoZWlnaHQ7XHJcblx0XHRcdFx0eTIgPSB5MSArIGNhcmV0U2l6ZTtcclxuXHRcdFx0XHR5MyA9IHkxO1xyXG5cdFx0XHRcdC8vIGludmVydCBkcmF3aW5nIG9yZGVyXHJcblx0XHRcdFx0dmFyIHRtcCA9IHgzO1xyXG5cdFx0XHRcdHgzID0geDE7XHJcblx0XHRcdFx0eDEgPSB0bXA7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB7eDE6IHgxLCB4MjogeDIsIHgzOiB4MywgeTE6IHkxLCB5MjogeTIsIHkzOiB5M307XHJcblx0fSxcclxuXHJcblx0ZHJhd1RpdGxlOiBmdW5jdGlvbihwdCwgdm0sIGN0eCkge1xyXG5cdFx0dmFyIHRpdGxlID0gdm0udGl0bGU7XHJcblx0XHR2YXIgbGVuZ3RoID0gdGl0bGUubGVuZ3RoO1xyXG5cdFx0dmFyIHRpdGxlRm9udFNpemUsIHRpdGxlU3BhY2luZywgaTtcclxuXHJcblx0XHRpZiAobGVuZ3RoKSB7XHJcblx0XHRcdHZhciBydGxIZWxwZXIgPSBnZXRSdGxIZWxwZXIodm0ucnRsLCB2bS54LCB2bS53aWR0aCk7XHJcblxyXG5cdFx0XHRwdC54ID0gZ2V0QWxpZ25lZFgodm0sIHZtLl90aXRsZUFsaWduKTtcclxuXHJcblx0XHRcdGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKHZtLl90aXRsZUFsaWduKTtcclxuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG5cclxuXHRcdFx0dGl0bGVGb250U2l6ZSA9IHZtLnRpdGxlRm9udFNpemU7XHJcblx0XHRcdHRpdGxlU3BhY2luZyA9IHZtLnRpdGxlU3BhY2luZztcclxuXHJcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB2bS50aXRsZUZvbnRDb2xvcjtcclxuXHRcdFx0Y3R4LmZvbnQgPSBoZWxwZXJzJDEuZm9udFN0cmluZyh0aXRsZUZvbnRTaXplLCB2bS5fdGl0bGVGb250U3R5bGUsIHZtLl90aXRsZUZvbnRGYW1pbHkpO1xyXG5cclxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcblx0XHRcdFx0Y3R4LmZpbGxUZXh0KHRpdGxlW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIHRpdGxlRm9udFNpemUgLyAyKTtcclxuXHRcdFx0XHRwdC55ICs9IHRpdGxlRm9udFNpemUgKyB0aXRsZVNwYWNpbmc7IC8vIExpbmUgSGVpZ2h0IGFuZCBzcGFjaW5nXHJcblxyXG5cdFx0XHRcdGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRwdC55ICs9IHZtLnRpdGxlTWFyZ2luQm90dG9tIC0gdGl0bGVTcGFjaW5nOyAvLyBJZiBMYXN0LCBhZGQgbWFyZ2luLCByZW1vdmUgc3BhY2luZ1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGRyYXdCb2R5OiBmdW5jdGlvbihwdCwgdm0sIGN0eCkge1xyXG5cdFx0dmFyIGJvZHlGb250U2l6ZSA9IHZtLmJvZHlGb250U2l6ZTtcclxuXHRcdHZhciBib2R5U3BhY2luZyA9IHZtLmJvZHlTcGFjaW5nO1xyXG5cdFx0dmFyIGJvZHlBbGlnbiA9IHZtLl9ib2R5QWxpZ247XHJcblx0XHR2YXIgYm9keSA9IHZtLmJvZHk7XHJcblx0XHR2YXIgZHJhd0NvbG9yQm94ZXMgPSB2bS5kaXNwbGF5Q29sb3JzO1xyXG5cdFx0dmFyIHhMaW5lUGFkZGluZyA9IDA7XHJcblx0XHR2YXIgY29sb3JYID0gZHJhd0NvbG9yQm94ZXMgPyBnZXRBbGlnbmVkWCh2bSwgJ2xlZnQnKSA6IDA7XHJcblxyXG5cdFx0dmFyIHJ0bEhlbHBlciA9IGdldFJ0bEhlbHBlcih2bS5ydGwsIHZtLngsIHZtLndpZHRoKTtcclxuXHJcblx0XHR2YXIgZmlsbExpbmVPZlRleHQgPSBmdW5jdGlvbihsaW5lKSB7XHJcblx0XHRcdGN0eC5maWxsVGV4dChsaW5lLCBydGxIZWxwZXIueChwdC54ICsgeExpbmVQYWRkaW5nKSwgcHQueSArIGJvZHlGb250U2l6ZSAvIDIpO1xyXG5cdFx0XHRwdC55ICs9IGJvZHlGb250U2l6ZSArIGJvZHlTcGFjaW5nO1xyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgYm9keUl0ZW0sIHRleHRDb2xvciwgbGFiZWxDb2xvcnMsIGxpbmVzLCBpLCBqLCBpbGVuLCBqbGVuO1xyXG5cdFx0dmFyIGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uID0gcnRsSGVscGVyLnRleHRBbGlnbihib2R5QWxpZ24pO1xyXG5cclxuXHRcdGN0eC50ZXh0QWxpZ24gPSBib2R5QWxpZ247XHJcblx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XHJcblx0XHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKGJvZHlGb250U2l6ZSwgdm0uX2JvZHlGb250U3R5bGUsIHZtLl9ib2R5Rm9udEZhbWlseSk7XHJcblxyXG5cdFx0cHQueCA9IGdldEFsaWduZWRYKHZtLCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbik7XHJcblxyXG5cdFx0Ly8gQmVmb3JlIGJvZHkgbGluZXNcclxuXHRcdGN0eC5maWxsU3R5bGUgPSB2bS5ib2R5Rm9udENvbG9yO1xyXG5cdFx0aGVscGVycyQxLmVhY2godm0uYmVmb3JlQm9keSwgZmlsbExpbmVPZlRleHQpO1xyXG5cclxuXHRcdHhMaW5lUGFkZGluZyA9IGRyYXdDb2xvckJveGVzICYmIGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uICE9PSAncmlnaHQnXHJcblx0XHRcdD8gYm9keUFsaWduID09PSAnY2VudGVyJyA/IChib2R5Rm9udFNpemUgLyAyICsgMSkgOiAoYm9keUZvbnRTaXplICsgMilcclxuXHRcdFx0OiAwO1xyXG5cclxuXHRcdC8vIERyYXcgYm9keSBsaW5lcyBub3dcclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBib2R5Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRib2R5SXRlbSA9IGJvZHlbaV07XHJcblx0XHRcdHRleHRDb2xvciA9IHZtLmxhYmVsVGV4dENvbG9yc1tpXTtcclxuXHRcdFx0bGFiZWxDb2xvcnMgPSB2bS5sYWJlbENvbG9yc1tpXTtcclxuXHJcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XHJcblx0XHRcdGhlbHBlcnMkMS5lYWNoKGJvZHlJdGVtLmJlZm9yZSwgZmlsbExpbmVPZlRleHQpO1xyXG5cclxuXHRcdFx0bGluZXMgPSBib2R5SXRlbS5saW5lcztcclxuXHRcdFx0Zm9yIChqID0gMCwgamxlbiA9IGxpbmVzLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xyXG5cdFx0XHRcdC8vIERyYXcgTGVnZW5kLWxpa2UgYm94ZXMgaWYgbmVlZGVkXHJcblx0XHRcdFx0aWYgKGRyYXdDb2xvckJveGVzKSB7XHJcblx0XHRcdFx0XHR2YXIgcnRsQ29sb3JYID0gcnRsSGVscGVyLngoY29sb3JYKTtcclxuXHJcblx0XHRcdFx0XHQvLyBGaWxsIGEgd2hpdGUgcmVjdCBzbyB0aGF0IGNvbG91cnMgbWVyZ2UgbmljZWx5IGlmIHRoZSBvcGFjaXR5IGlzIDwgMVxyXG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmxlZ2VuZENvbG9yQmFja2dyb3VuZDtcclxuXHRcdFx0XHRcdGN0eC5maWxsUmVjdChydGxIZWxwZXIubGVmdEZvckx0cihydGxDb2xvclgsIGJvZHlGb250U2l6ZSksIHB0LnksIGJvZHlGb250U2l6ZSwgYm9keUZvbnRTaXplKTtcclxuXHJcblx0XHRcdFx0XHQvLyBCb3JkZXJcclxuXHRcdFx0XHRcdGN0eC5saW5lV2lkdGggPSAxO1xyXG5cdFx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvcnMuYm9yZGVyQ29sb3I7XHJcblx0XHRcdFx0XHRjdHguc3Ryb2tlUmVjdChydGxIZWxwZXIubGVmdEZvckx0cihydGxDb2xvclgsIGJvZHlGb250U2l6ZSksIHB0LnksIGJvZHlGb250U2l6ZSwgYm9keUZvbnRTaXplKTtcclxuXHJcblx0XHRcdFx0XHQvLyBJbm5lciBzcXVhcmVcclxuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9ycy5iYWNrZ3JvdW5kQ29sb3I7XHJcblx0XHRcdFx0XHRjdHguZmlsbFJlY3QocnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLnhQbHVzKHJ0bENvbG9yWCwgMSksIGJvZHlGb250U2l6ZSAtIDIpLCBwdC55ICsgMSwgYm9keUZvbnRTaXplIC0gMiwgYm9keUZvbnRTaXplIC0gMik7XHJcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdGV4dENvbG9yO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZmlsbExpbmVPZlRleHQobGluZXNbal0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5hZnRlciwgZmlsbExpbmVPZlRleHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJlc2V0IGJhY2sgdG8gMCBmb3IgYWZ0ZXIgYm9keVxyXG5cdFx0eExpbmVQYWRkaW5nID0gMDtcclxuXHJcblx0XHQvLyBBZnRlciBib2R5IGxpbmVzXHJcblx0XHRoZWxwZXJzJDEuZWFjaCh2bS5hZnRlckJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcclxuXHRcdHB0LnkgLT0gYm9keVNwYWNpbmc7IC8vIFJlbW92ZSBsYXN0IGJvZHkgc3BhY2luZ1xyXG5cdH0sXHJcblxyXG5cdGRyYXdGb290ZXI6IGZ1bmN0aW9uKHB0LCB2bSwgY3R4KSB7XHJcblx0XHR2YXIgZm9vdGVyID0gdm0uZm9vdGVyO1xyXG5cdFx0dmFyIGxlbmd0aCA9IGZvb3Rlci5sZW5ndGg7XHJcblx0XHR2YXIgZm9vdGVyRm9udFNpemUsIGk7XHJcblxyXG5cdFx0aWYgKGxlbmd0aCkge1xyXG5cdFx0XHR2YXIgcnRsSGVscGVyID0gZ2V0UnRsSGVscGVyKHZtLnJ0bCwgdm0ueCwgdm0ud2lkdGgpO1xyXG5cclxuXHRcdFx0cHQueCA9IGdldEFsaWduZWRYKHZtLCB2bS5fZm9vdGVyQWxpZ24pO1xyXG5cdFx0XHRwdC55ICs9IHZtLmZvb3Rlck1hcmdpblRvcDtcclxuXHJcblx0XHRcdGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKHZtLl9mb290ZXJBbGlnbik7XHJcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcclxuXHJcblx0XHRcdGZvb3RlckZvbnRTaXplID0gdm0uZm9vdGVyRm9udFNpemU7XHJcblxyXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gdm0uZm9vdGVyRm9udENvbG9yO1xyXG5cdFx0XHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKGZvb3RlckZvbnRTaXplLCB2bS5fZm9vdGVyRm9udFN0eWxlLCB2bS5fZm9vdGVyRm9udEZhbWlseSk7XHJcblxyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuXHRcdFx0XHRjdHguZmlsbFRleHQoZm9vdGVyW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIGZvb3RlckZvbnRTaXplIC8gMik7XHJcblx0XHRcdFx0cHQueSArPSBmb290ZXJGb250U2l6ZSArIHZtLmZvb3RlclNwYWNpbmc7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRkcmF3QmFja2dyb3VuZDogZnVuY3Rpb24ocHQsIHZtLCBjdHgsIHRvb2x0aXBTaXplKSB7XHJcblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYmFja2dyb3VuZENvbG9yO1xyXG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gdm0uYm9yZGVyQ29sb3I7XHJcblx0XHRjdHgubGluZVdpZHRoID0gdm0uYm9yZGVyV2lkdGg7XHJcblx0XHR2YXIgeEFsaWduID0gdm0ueEFsaWduO1xyXG5cdFx0dmFyIHlBbGlnbiA9IHZtLnlBbGlnbjtcclxuXHRcdHZhciB4ID0gcHQueDtcclxuXHRcdHZhciB5ID0gcHQueTtcclxuXHRcdHZhciB3aWR0aCA9IHRvb2x0aXBTaXplLndpZHRoO1xyXG5cdFx0dmFyIGhlaWdodCA9IHRvb2x0aXBTaXplLmhlaWdodDtcclxuXHRcdHZhciByYWRpdXMgPSB2bS5jb3JuZXJSYWRpdXM7XHJcblxyXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0Y3R4Lm1vdmVUbyh4ICsgcmFkaXVzLCB5KTtcclxuXHRcdGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XHJcblx0XHRcdHRoaXMuZHJhd0NhcmV0KHB0LCB0b29sdGlwU2l6ZSk7XHJcblx0XHR9XHJcblx0XHRjdHgubGluZVRvKHggKyB3aWR0aCAtIHJhZGl1cywgeSk7XHJcblx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHJhZGl1cyk7XHJcblx0XHRpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdyaWdodCcpIHtcclxuXHRcdFx0dGhpcy5kcmF3Q2FyZXQocHQsIHRvb2x0aXBTaXplKTtcclxuXHRcdH1cclxuXHRcdGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcclxuXHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcmFkaXVzLCB5ICsgaGVpZ2h0KTtcclxuXHRcdGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XHJcblx0XHRcdHRoaXMuZHJhd0NhcmV0KHB0LCB0b29sdGlwU2l6ZSk7XHJcblx0XHR9XHJcblx0XHRjdHgubGluZVRvKHggKyByYWRpdXMsIHkgKyBoZWlnaHQpO1xyXG5cdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XHJcblx0XHRpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdsZWZ0Jykge1xyXG5cdFx0XHR0aGlzLmRyYXdDYXJldChwdCwgdG9vbHRpcFNpemUpO1xyXG5cdFx0fVxyXG5cdFx0Y3R4LmxpbmVUbyh4LCB5ICsgcmFkaXVzKTtcclxuXHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByYWRpdXMsIHkpO1xyXG5cdFx0Y3R4LmNsb3NlUGF0aCgpO1xyXG5cclxuXHRcdGN0eC5maWxsKCk7XHJcblxyXG5cdFx0aWYgKHZtLmJvcmRlcldpZHRoID4gMCkge1xyXG5cdFx0XHRjdHguc3Ryb2tlKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0ZHJhdzogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xyXG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHJcblx0XHRpZiAodm0ub3BhY2l0eSA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRvb2x0aXBTaXplID0ge1xyXG5cdFx0XHR3aWR0aDogdm0ud2lkdGgsXHJcblx0XHRcdGhlaWdodDogdm0uaGVpZ2h0XHJcblx0XHR9O1xyXG5cdFx0dmFyIHB0ID0ge1xyXG5cdFx0XHR4OiB2bS54LFxyXG5cdFx0XHR5OiB2bS55XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIElFMTEvRWRnZSBkb2VzIG5vdCBsaWtlIHZlcnkgc21hbGwgb3BhY2l0aWVzLCBzbyBzbmFwIHRvIDBcclxuXHRcdHZhciBvcGFjaXR5ID0gTWF0aC5hYnModm0ub3BhY2l0eSA8IDFlLTMpID8gMCA6IHZtLm9wYWNpdHk7XHJcblxyXG5cdFx0Ly8gVHJ1dGh5L2ZhbHNleSB2YWx1ZSBmb3IgZW1wdHkgdG9vbHRpcFxyXG5cdFx0dmFyIGhhc1Rvb2x0aXBDb250ZW50ID0gdm0udGl0bGUubGVuZ3RoIHx8IHZtLmJlZm9yZUJvZHkubGVuZ3RoIHx8IHZtLmJvZHkubGVuZ3RoIHx8IHZtLmFmdGVyQm9keS5sZW5ndGggfHwgdm0uZm9vdGVyLmxlbmd0aDtcclxuXHJcblx0XHRpZiAodGhpcy5fb3B0aW9ucy5lbmFibGVkICYmIGhhc1Rvb2x0aXBDb250ZW50KSB7XHJcblx0XHRcdGN0eC5zYXZlKCk7XHJcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XHJcblxyXG5cdFx0XHQvLyBEcmF3IEJhY2tncm91bmRcclxuXHRcdFx0dGhpcy5kcmF3QmFja2dyb3VuZChwdCwgdm0sIGN0eCwgdG9vbHRpcFNpemUpO1xyXG5cclxuXHRcdFx0Ly8gRHJhdyBUaXRsZSwgQm9keSwgYW5kIEZvb3RlclxyXG5cdFx0XHRwdC55ICs9IHZtLnlQYWRkaW5nO1xyXG5cclxuXHRcdFx0aGVscGVycyQxLnJ0bC5vdmVycmlkZVRleHREaXJlY3Rpb24oY3R4LCB2bS50ZXh0RGlyZWN0aW9uKTtcclxuXHJcblx0XHRcdC8vIFRpdGxlc1xyXG5cdFx0XHR0aGlzLmRyYXdUaXRsZShwdCwgdm0sIGN0eCk7XHJcblxyXG5cdFx0XHQvLyBCb2R5XHJcblx0XHRcdHRoaXMuZHJhd0JvZHkocHQsIHZtLCBjdHgpO1xyXG5cclxuXHRcdFx0Ly8gRm9vdGVyXHJcblx0XHRcdHRoaXMuZHJhd0Zvb3RlcihwdCwgdm0sIGN0eCk7XHJcblxyXG5cdFx0XHRoZWxwZXJzJDEucnRsLnJlc3RvcmVUZXh0RGlyZWN0aW9uKGN0eCwgdm0udGV4dERpcmVjdGlvbik7XHJcblxyXG5cdFx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEhhbmRsZSBhbiBldmVudFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtJRXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSB0b29sdGlwIGNoYW5nZWRcclxuXHQgKi9cclxuXHRoYW5kbGVFdmVudDogZnVuY3Rpb24oZSkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBvcHRpb25zID0gbWUuX29wdGlvbnM7XHJcblx0XHR2YXIgY2hhbmdlZCA9IGZhbHNlO1xyXG5cclxuXHRcdG1lLl9sYXN0QWN0aXZlID0gbWUuX2xhc3RBY3RpdmUgfHwgW107XHJcblxyXG5cdFx0Ly8gRmluZCBBY3RpdmUgRWxlbWVudHMgZm9yIHRvb2x0aXBzXHJcblx0XHRpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XHJcblx0XHRcdG1lLl9hY3RpdmUgPSBbXTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1lLl9hY3RpdmUgPSBtZS5fY2hhcnQuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBvcHRpb25zLm1vZGUsIG9wdGlvbnMpO1xyXG5cdFx0XHRpZiAob3B0aW9ucy5yZXZlcnNlKSB7XHJcblx0XHRcdFx0bWUuX2FjdGl2ZS5yZXZlcnNlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBSZW1lbWJlciBMYXN0IEFjdGl2ZXNcclxuXHRcdGNoYW5nZWQgPSAhaGVscGVycyQxLmFycmF5RXF1YWxzKG1lLl9hY3RpdmUsIG1lLl9sYXN0QWN0aXZlKTtcclxuXHJcblx0XHQvLyBPbmx5IGhhbmRsZSB0YXJnZXQgZXZlbnQgb24gdG9vbHRpcCBjaGFuZ2VcclxuXHRcdGlmIChjaGFuZ2VkKSB7XHJcblx0XHRcdG1lLl9sYXN0QWN0aXZlID0gbWUuX2FjdGl2ZTtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmVuYWJsZWQgfHwgb3B0aW9ucy5jdXN0b20pIHtcclxuXHRcdFx0XHRtZS5fZXZlbnRQb3NpdGlvbiA9IHtcclxuXHRcdFx0XHRcdHg6IGUueCxcclxuXHRcdFx0XHRcdHk6IGUueVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdG1lLnVwZGF0ZSh0cnVlKTtcclxuXHRcdFx0XHRtZS5waXZvdCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNoYW5nZWQ7XHJcblx0fVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnNcclxuICovXHJcbnZhciBwb3NpdGlvbmVyc18xID0gcG9zaXRpb25lcnM7XHJcblxyXG52YXIgY29yZV90b29sdGlwID0gZXhwb3J0cyQ0O1xuY29yZV90b29sdGlwLnBvc2l0aW9uZXJzID0gcG9zaXRpb25lcnNfMTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDkgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XHJcblxyXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcclxuXHRlbGVtZW50czoge30sXHJcblx0ZXZlbnRzOiBbXHJcblx0XHQnbW91c2Vtb3ZlJyxcclxuXHRcdCdtb3VzZW91dCcsXHJcblx0XHQnY2xpY2snLFxyXG5cdFx0J3RvdWNoc3RhcnQnLFxyXG5cdFx0J3RvdWNobW92ZSdcclxuXHRdLFxyXG5cdGhvdmVyOiB7XHJcblx0XHRvbkhvdmVyOiBudWxsLFxyXG5cdFx0bW9kZTogJ25lYXJlc3QnLFxyXG5cdFx0aW50ZXJzZWN0OiB0cnVlLFxyXG5cdFx0YW5pbWF0aW9uRHVyYXRpb246IDQwMFxyXG5cdH0sXHJcblx0b25DbGljazogbnVsbCxcclxuXHRtYWludGFpbkFzcGVjdFJhdGlvOiB0cnVlLFxyXG5cdHJlc3BvbnNpdmU6IHRydWUsXHJcblx0cmVzcG9uc2l2ZUFuaW1hdGlvbkR1cmF0aW9uOiAwXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZWx5IG1lcmdlIHRoZSBnaXZlbiBjb25maWcgb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlIGBzY2FsZXNgIG9wdGlvblxyXG4gKiBieSBpbmNvcnBvcmF0aW5nIHNjYWxlIGRlZmF1bHRzIGluIGB4QXhlc2AgYW5kIGB5QXhlc2AgYXJyYXkgaXRlbXMsIHRoZW5cclxuICogcmV0dXJucyBhIGRlZXAgY29weSBvZiB0aGUgcmVzdWx0LCB0aHVzIGRvZXNuJ3QgYWx0ZXIgaW5wdXRzLlxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VTY2FsZUNvbmZpZygvKiBjb25maWcgb2JqZWN0cyAuLi4gKi8pIHtcclxuXHRyZXR1cm4gaGVscGVycyQxLm1lcmdlKE9iamVjdC5jcmVhdGUobnVsbCksIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwge1xyXG5cdFx0bWVyZ2VyOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XHJcblx0XHRcdGlmIChrZXkgPT09ICd4QXhlcycgfHwga2V5ID09PSAneUF4ZXMnKSB7XHJcblx0XHRcdFx0dmFyIHNsZW4gPSBzb3VyY2Vba2V5XS5sZW5ndGg7XHJcblx0XHRcdFx0dmFyIGksIHR5cGUsIHNjYWxlO1xyXG5cclxuXHRcdFx0XHRpZiAoIXRhcmdldFtrZXldKSB7XHJcblx0XHRcdFx0XHR0YXJnZXRba2V5XSA9IFtdO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHNsZW47ICsraSkge1xyXG5cdFx0XHRcdFx0c2NhbGUgPSBzb3VyY2Vba2V5XVtpXTtcclxuXHRcdFx0XHRcdHR5cGUgPSB2YWx1ZU9yRGVmYXVsdCQ5KHNjYWxlLnR5cGUsIGtleSA9PT0gJ3hBeGVzJyA/ICdjYXRlZ29yeScgOiAnbGluZWFyJyk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKGkgPj0gdGFyZ2V0W2tleV0ubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdHRhcmdldFtrZXldLnB1c2goe30pO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICghdGFyZ2V0W2tleV1baV0udHlwZSB8fCAoc2NhbGUudHlwZSAmJiBzY2FsZS50eXBlICE9PSB0YXJnZXRba2V5XVtpXS50eXBlKSkge1xyXG5cdFx0XHRcdFx0XHQvLyBuZXcvdW50eXBlZCBzY2FsZSBvciB0eXBlIGNoYW5nZWQ6IGxldCdzIGFwcGx5IHRoZSBuZXcgZGVmYXVsdHNcclxuXHRcdFx0XHRcdFx0Ly8gdGhlbiBtZXJnZSBzb3VyY2Ugc2NhbGUgdG8gY29ycmVjdGx5IG92ZXJ3cml0ZSB0aGUgZGVmYXVsdHMuXHJcblx0XHRcdFx0XHRcdGhlbHBlcnMkMS5tZXJnZSh0YXJnZXRba2V5XVtpXSwgW2NvcmVfc2NhbGVTZXJ2aWNlLmdldFNjYWxlRGVmYXVsdHModHlwZSksIHNjYWxlXSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHQvLyBzY2FsZXMgdHlwZSBhcmUgdGhlIHNhbWVcclxuXHRcdFx0XHRcdFx0aGVscGVycyQxLm1lcmdlKHRhcmdldFtrZXldW2ldLCBzY2FsZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGhlbHBlcnMkMS5fbWVyZ2VyKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWN1cnNpdmVseSBtZXJnZSB0aGUgZ2l2ZW4gY29uZmlnIG9iamVjdHMgYXMgdGhlIHJvb3Qgb3B0aW9ucyBieSBoYW5kbGluZ1xyXG4gKiBkZWZhdWx0IHNjYWxlIG9wdGlvbnMgZm9yIHRoZSBgc2NhbGVzYCBhbmQgYHNjYWxlYCBwcm9wZXJ0aWVzLCB0aGVuIHJldHVybnNcclxuICogYSBkZWVwIGNvcHkgb2YgdGhlIHJlc3VsdCwgdGh1cyBkb2Vzbid0IGFsdGVyIGlucHV0cy5cclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlQ29uZmlnKC8qIGNvbmZpZyBvYmplY3RzIC4uLiAqLykge1xyXG5cdHJldHVybiBoZWxwZXJzJDEubWVyZ2UoT2JqZWN0LmNyZWF0ZShudWxsKSwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLCB7XHJcblx0XHRtZXJnZXI6IGZ1bmN0aW9uKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcclxuXHRcdFx0dmFyIHR2YWwgPSB0YXJnZXRba2V5XSB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cdFx0XHR2YXIgc3ZhbCA9IHNvdXJjZVtrZXldO1xyXG5cclxuXHRcdFx0aWYgKGtleSA9PT0gJ3NjYWxlcycpIHtcclxuXHRcdFx0XHQvLyBzY2FsZSBjb25maWcgbWVyZ2luZyBpcyBjb21wbGV4LiBBZGQgb3VyIG93biBmdW5jdGlvbiBoZXJlIGZvciB0aGF0XHJcblx0XHRcdFx0dGFyZ2V0W2tleV0gPSBtZXJnZVNjYWxlQ29uZmlnKHR2YWwsIHN2YWwpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ3NjYWxlJykge1xyXG5cdFx0XHRcdC8vIHVzZWQgaW4gcG9sYXIgYXJlYSAmIHJhZGFyIGNoYXJ0cyBzaW5jZSB0aGVyZSBpcyBvbmx5IG9uZSBzY2FsZVxyXG5cdFx0XHRcdHRhcmdldFtrZXldID0gaGVscGVycyQxLm1lcmdlKHR2YWwsIFtjb3JlX3NjYWxlU2VydmljZS5nZXRTY2FsZURlZmF1bHRzKHN2YWwudHlwZSksIHN2YWxdKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRoZWxwZXJzJDEuX21lcmdlcihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0Q29uZmlnKGNvbmZpZykge1xyXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cclxuXHQvLyBEbyBOT1QgdXNlIG1lcmdlQ29uZmlnIGZvciB0aGUgZGF0YSBvYmplY3QgYmVjYXVzZSB0aGlzIG1ldGhvZCBtZXJnZXMgYXJyYXlzXHJcblx0Ly8gYW5kIHNvIHdvdWxkIGNoYW5nZSByZWZlcmVuY2VzIHRvIGxhYmVscyBhbmQgZGF0YXNldHMsIHByZXZlbnRpbmcgZGF0YSB1cGRhdGVzLlxyXG5cdHZhciBkYXRhID0gY29uZmlnLmRhdGEgPSBjb25maWcuZGF0YSB8fCB7fTtcclxuXHRkYXRhLmRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cyB8fCBbXTtcclxuXHRkYXRhLmxhYmVscyA9IGRhdGEubGFiZWxzIHx8IFtdO1xyXG5cclxuXHRjb25maWcub3B0aW9ucyA9IG1lcmdlQ29uZmlnKFxyXG5cdFx0Y29yZV9kZWZhdWx0cy5nbG9iYWwsXHJcblx0XHRjb3JlX2RlZmF1bHRzW2NvbmZpZy50eXBlXSxcclxuXHRcdGNvbmZpZy5vcHRpb25zIHx8IHt9KTtcclxuXHJcblx0cmV0dXJuIGNvbmZpZztcclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlQ29uZmlnKGNoYXJ0KSB7XHJcblx0dmFyIG5ld09wdGlvbnMgPSBjaGFydC5vcHRpb25zO1xyXG5cclxuXHRoZWxwZXJzJDEuZWFjaChjaGFydC5zY2FsZXMsIGZ1bmN0aW9uKHNjYWxlKSB7XHJcblx0XHRjb3JlX2xheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBzY2FsZSk7XHJcblx0fSk7XHJcblxyXG5cdG5ld09wdGlvbnMgPSBtZXJnZUNvbmZpZyhcclxuXHRcdGNvcmVfZGVmYXVsdHMuZ2xvYmFsLFxyXG5cdFx0Y29yZV9kZWZhdWx0c1tjaGFydC5jb25maWcudHlwZV0sXHJcblx0XHRuZXdPcHRpb25zKTtcclxuXHJcblx0Y2hhcnQub3B0aW9ucyA9IGNoYXJ0LmNvbmZpZy5vcHRpb25zID0gbmV3T3B0aW9ucztcclxuXHRjaGFydC5lbnN1cmVTY2FsZXNIYXZlSURzKCk7XHJcblx0Y2hhcnQuYnVpbGRPclVwZGF0ZVNjYWxlcygpO1xyXG5cclxuXHQvLyBUb29sdGlwXHJcblx0Y2hhcnQudG9vbHRpcC5fb3B0aW9ucyA9IG5ld09wdGlvbnMudG9vbHRpcHM7XHJcblx0Y2hhcnQudG9vbHRpcC5pbml0aWFsaXplKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5leHRBdmFpbGFibGVTY2FsZUlkKGF4ZXNPcHRzLCBwcmVmaXgsIGluZGV4KSB7XHJcblx0dmFyIGlkO1xyXG5cdHZhciBoYXNJZCA9IGZ1bmN0aW9uKG9iaikge1xyXG5cdFx0cmV0dXJuIG9iai5pZCA9PT0gaWQ7XHJcblx0fTtcclxuXHJcblx0ZG8ge1xyXG5cdFx0aWQgPSBwcmVmaXggKyBpbmRleCsrO1xyXG5cdH0gd2hpbGUgKGhlbHBlcnMkMS5maW5kSW5kZXgoYXhlc09wdHMsIGhhc0lkKSA+PSAwKTtcclxuXHJcblx0cmV0dXJuIGlkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwb3NpdGlvbklzSG9yaXpvbnRhbChwb3NpdGlvbikge1xyXG5cdHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wYXJlMkxldmVsKGwxLCBsMikge1xyXG5cdHJldHVybiBmdW5jdGlvbihhLCBiKSB7XHJcblx0XHRyZXR1cm4gYVtsMV0gPT09IGJbbDFdXHJcblx0XHRcdD8gYVtsMl0gLSBiW2wyXVxyXG5cdFx0XHQ6IGFbbDFdIC0gYltsMV07XHJcblx0fTtcclxufVxyXG5cclxudmFyIENoYXJ0ID0gZnVuY3Rpb24oaXRlbSwgY29uZmlnKSB7XHJcblx0dGhpcy5jb25zdHJ1Y3QoaXRlbSwgY29uZmlnKTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbmhlbHBlcnMkMS5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCAvKiogQGxlbmRzIENoYXJ0ICovIHtcclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdDogZnVuY3Rpb24oaXRlbSwgY29uZmlnKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cclxuXHRcdGNvbmZpZyA9IGluaXRDb25maWcoY29uZmlnKTtcclxuXHJcblx0XHR2YXIgY29udGV4dCA9IHBsYXRmb3JtLmFjcXVpcmVDb250ZXh0KGl0ZW0sIGNvbmZpZyk7XHJcblx0XHR2YXIgY2FudmFzID0gY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcztcclxuXHRcdHZhciBoZWlnaHQgPSBjYW52YXMgJiYgY2FudmFzLmhlaWdodDtcclxuXHRcdHZhciB3aWR0aCA9IGNhbnZhcyAmJiBjYW52YXMud2lkdGg7XHJcblxyXG5cdFx0bWUuaWQgPSBoZWxwZXJzJDEudWlkKCk7XHJcblx0XHRtZS5jdHggPSBjb250ZXh0O1xyXG5cdFx0bWUuY2FudmFzID0gY2FudmFzO1xyXG5cdFx0bWUuY29uZmlnID0gY29uZmlnO1xyXG5cdFx0bWUud2lkdGggPSB3aWR0aDtcclxuXHRcdG1lLmhlaWdodCA9IGhlaWdodDtcclxuXHRcdG1lLmFzcGVjdFJhdGlvID0gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBudWxsO1xyXG5cdFx0bWUub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xyXG5cdFx0bWUuX2J1ZmZlcmVkUmVuZGVyID0gZmFsc2U7XHJcblx0XHRtZS5fbGF5ZXJzID0gW107XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgQ2hhcnQgYW5kIENoYXJ0LkNvbnRyb2xsZXIgaGF2ZSBiZWVuIG1lcmdlZCxcclxuXHRcdCAqIHRoZSBcImluc3RhbmNlXCIgc3RpbGwgbmVlZCB0byBiZSBkZWZpbmVkIHNpbmNlIGl0IG1pZ2h0IGJlIGNhbGxlZCBmcm9tIHBsdWdpbnMuXHJcblx0XHQgKiBAcHJvcCBDaGFydCNjaGFydFxyXG5cdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxyXG5cdFx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cdFx0bWUuY2hhcnQgPSBtZTtcclxuXHRcdG1lLmNvbnRyb2xsZXIgPSBtZTsgLy8gY2hhcnQuY2hhcnQuY29udHJvbGxlciAjaW5jZXB0aW9uXHJcblxyXG5cdFx0Ly8gQWRkIHRoZSBjaGFydCBpbnN0YW5jZSB0byB0aGUgZ2xvYmFsIG5hbWVzcGFjZVxyXG5cdFx0Q2hhcnQuaW5zdGFuY2VzW21lLmlkXSA9IG1lO1xyXG5cclxuXHRcdC8vIERlZmluZSBhbGlhcyB0byB0aGUgY29uZmlnIGRhdGE6IGBjaGFydC5kYXRhID09PSBjaGFydC5jb25maWcuZGF0YWBcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZSwgJ2RhdGEnLCB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1lLmNvbmZpZy5kYXRhO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHRcdFx0bWUuY29uZmlnLmRhdGEgPSB2YWx1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKCFjb250ZXh0IHx8ICFjYW52YXMpIHtcclxuXHRcdFx0Ly8gVGhlIGdpdmVuIGl0ZW0gaXMgbm90IGEgY29tcGF0aWJsZSBjb250ZXh0MmQgZWxlbWVudCwgbGV0J3MgcmV0dXJuIGJlZm9yZSBmaW5hbGl6aW5nXHJcblx0XHRcdC8vIHRoZSBjaGFydCBpbml0aWFsaXphdGlvbiBidXQgYWZ0ZXIgc2V0dGluZyBiYXNpYyBjaGFydCAvIGNvbnRyb2xsZXIgcHJvcGVydGllcyB0aGF0XHJcblx0XHRcdC8vIGNhbiBoZWxwIHRvIGZpZ3VyZSBvdXQgdGhhdCB0aGUgY2hhcnQgaXMgbm90IHZhbGlkIChlLmcgY2hhcnQuY2FudmFzICE9PSBudWxsKTtcclxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcclxuXHRcdFx0Y29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgY2hhcnQ6IGNhbid0IGFjcXVpcmUgY29udGV4dCBmcm9tIHRoZSBnaXZlbiBpdGVtXCIpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bWUuaW5pdGlhbGl6ZSgpO1xyXG5cdFx0bWUudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblxyXG5cdFx0Ly8gQmVmb3JlIGluaXQgcGx1Z2luIG5vdGlmaWNhdGlvblxyXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZUluaXQnKTtcclxuXHJcblx0XHRoZWxwZXJzJDEucmV0aW5hU2NhbGUobWUsIG1lLm9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyk7XHJcblxyXG5cdFx0bWUuYmluZEV2ZW50cygpO1xyXG5cclxuXHRcdGlmIChtZS5vcHRpb25zLnJlc3BvbnNpdmUpIHtcclxuXHRcdFx0Ly8gSW5pdGlhbCByZXNpemUgYmVmb3JlIGNoYXJ0IGRyYXdzIChtdXN0IGJlIHNpbGVudCB0byBwcmVzZXJ2ZSBpbml0aWFsIGFuaW1hdGlvbnMpLlxyXG5cdFx0XHRtZS5yZXNpemUodHJ1ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bWUuaW5pdFRvb2xUaXAoKTtcclxuXHJcblx0XHQvLyBBZnRlciBpbml0IHBsdWdpbiBub3RpZmljYXRpb25cclxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckluaXQnKTtcclxuXHJcblx0XHRyZXR1cm4gbWU7XHJcblx0fSxcclxuXHJcblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xyXG5cdFx0aGVscGVycyQxLmNhbnZhcy5jbGVhcih0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHN0b3A6IGZ1bmN0aW9uKCkge1xyXG5cdFx0Ly8gU3RvcHMgYW55IGN1cnJlbnQgYW5pbWF0aW9uIGxvb3Agb2NjdXJyaW5nXHJcblx0XHRjb3JlX2FuaW1hdGlvbnMuY2FuY2VsQW5pbWF0aW9uKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0cmVzaXplOiBmdW5jdGlvbihzaWxlbnQpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XHJcblx0XHR2YXIgY2FudmFzID0gbWUuY2FudmFzO1xyXG5cdFx0dmFyIGFzcGVjdFJhdGlvID0gKG9wdGlvbnMubWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiBtZS5hc3BlY3RSYXRpbykgfHwgbnVsbDtcclxuXHJcblx0XHQvLyB0aGUgY2FudmFzIHJlbmRlciB3aWR0aCBhbmQgaGVpZ2h0IHdpbGwgYmUgY2FzdGVkIHRvIGludGVnZXJzIHNvIG1ha2Ugc3VyZSB0aGF0XHJcblx0XHQvLyB0aGUgY2FudmFzIGRpc3BsYXkgc3R5bGUgdXNlcyB0aGUgc2FtZSBpbnRlZ2VyIHZhbHVlcyB0byBhdm9pZCBibHVycmluZyBlZmZlY3QuXHJcblxyXG5cdFx0Ly8gU2V0IHRvIDAgaW5zdGVhZCBvZiBjYW52YXMuc2l6ZSBiZWNhdXNlIHRoZSBzaXplIGRlZmF1bHRzIHRvIDMwMHgxNTAgaWYgdGhlIGVsZW1lbnQgaXMgY29sbGFwc2VkXHJcblx0XHR2YXIgbmV3V2lkdGggPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKGhlbHBlcnMkMS5nZXRNYXhpbXVtV2lkdGgoY2FudmFzKSkpO1xyXG5cdFx0dmFyIG5ld0hlaWdodCA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3IoYXNwZWN0UmF0aW8gPyBuZXdXaWR0aCAvIGFzcGVjdFJhdGlvIDogaGVscGVycyQxLmdldE1heGltdW1IZWlnaHQoY2FudmFzKSkpO1xyXG5cclxuXHRcdGlmIChtZS53aWR0aCA9PT0gbmV3V2lkdGggJiYgbWUuaGVpZ2h0ID09PSBuZXdIZWlnaHQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNhbnZhcy53aWR0aCA9IG1lLndpZHRoID0gbmV3V2lkdGg7XHJcblx0XHRjYW52YXMuaGVpZ2h0ID0gbWUuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xyXG5cdFx0Y2FudmFzLnN0eWxlLndpZHRoID0gbmV3V2lkdGggKyAncHgnO1xyXG5cdFx0Y2FudmFzLnN0eWxlLmhlaWdodCA9IG5ld0hlaWdodCArICdweCc7XHJcblxyXG5cdFx0aGVscGVycyQxLnJldGluYVNjYWxlKG1lLCBvcHRpb25zLmRldmljZVBpeGVsUmF0aW8pO1xyXG5cclxuXHRcdGlmICghc2lsZW50KSB7XHJcblx0XHRcdC8vIE5vdGlmeSBhbnkgcGx1Z2lucyBhYm91dCB0aGUgcmVzaXplXHJcblx0XHRcdHZhciBuZXdTaXplID0ge3dpZHRoOiBuZXdXaWR0aCwgaGVpZ2h0OiBuZXdIZWlnaHR9O1xyXG5cdFx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAncmVzaXplJywgW25ld1NpemVdKTtcclxuXHJcblx0XHRcdC8vIE5vdGlmeSBvZiByZXNpemVcclxuXHRcdFx0aWYgKG9wdGlvbnMub25SZXNpemUpIHtcclxuXHRcdFx0XHRvcHRpb25zLm9uUmVzaXplKG1lLCBuZXdTaXplKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bWUuc3RvcCgpO1xyXG5cdFx0XHRtZS51cGRhdGUoe1xyXG5cdFx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLnJlc3BvbnNpdmVBbmltYXRpb25EdXJhdGlvblxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRlbnN1cmVTY2FsZXNIYXZlSURzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cdFx0dmFyIHNjYWxlc09wdGlvbnMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcclxuXHRcdHZhciBzY2FsZU9wdGlvbnMgPSBvcHRpb25zLnNjYWxlO1xyXG5cclxuXHRcdGhlbHBlcnMkMS5lYWNoKHNjYWxlc09wdGlvbnMueEF4ZXMsIGZ1bmN0aW9uKHhBeGlzT3B0aW9ucywgaW5kZXgpIHtcclxuXHRcdFx0aWYgKCF4QXhpc09wdGlvbnMuaWQpIHtcclxuXHRcdFx0XHR4QXhpc09wdGlvbnMuaWQgPSBuZXh0QXZhaWxhYmxlU2NhbGVJZChzY2FsZXNPcHRpb25zLnhBeGVzLCAneC1heGlzLScsIGluZGV4KTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aGVscGVycyQxLmVhY2goc2NhbGVzT3B0aW9ucy55QXhlcywgZnVuY3Rpb24oeUF4aXNPcHRpb25zLCBpbmRleCkge1xyXG5cdFx0XHRpZiAoIXlBeGlzT3B0aW9ucy5pZCkge1xyXG5cdFx0XHRcdHlBeGlzT3B0aW9ucy5pZCA9IG5leHRBdmFpbGFibGVTY2FsZUlkKHNjYWxlc09wdGlvbnMueUF4ZXMsICd5LWF4aXMtJywgaW5kZXgpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoc2NhbGVPcHRpb25zKSB7XHJcblx0XHRcdHNjYWxlT3B0aW9ucy5pZCA9IHNjYWxlT3B0aW9ucy5pZCB8fCAnc2NhbGUnO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEJ1aWxkcyBhIG1hcCBvZiBzY2FsZSBJRCB0byBzY2FsZSBvYmplY3QgZm9yIGZ1dHVyZSBsb29rdXAuXHJcblx0ICovXHJcblx0YnVpbGRPclVwZGF0ZVNjYWxlczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIHNjYWxlcyA9IG1lLnNjYWxlcyB8fCB7fTtcclxuXHRcdHZhciBpdGVtcyA9IFtdO1xyXG5cdFx0dmFyIHVwZGF0ZWQgPSBPYmplY3Qua2V5cyhzY2FsZXMpLnJlZHVjZShmdW5jdGlvbihvYmosIGlkKSB7XHJcblx0XHRcdG9ialtpZF0gPSBmYWxzZTtcclxuXHRcdFx0cmV0dXJuIG9iajtcclxuXHRcdH0sIHt9KTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5zY2FsZXMpIHtcclxuXHRcdFx0aXRlbXMgPSBpdGVtcy5jb25jYXQoXHJcblx0XHRcdFx0KG9wdGlvbnMuc2NhbGVzLnhBeGVzIHx8IFtdKS5tYXAoZnVuY3Rpb24oeEF4aXNPcHRpb25zKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4ge29wdGlvbnM6IHhBeGlzT3B0aW9ucywgZHR5cGU6ICdjYXRlZ29yeScsIGRwb3NpdGlvbjogJ2JvdHRvbSd9O1xyXG5cdFx0XHRcdH0pLFxyXG5cdFx0XHRcdChvcHRpb25zLnNjYWxlcy55QXhlcyB8fCBbXSkubWFwKGZ1bmN0aW9uKHlBeGlzT3B0aW9ucykge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHtvcHRpb25zOiB5QXhpc09wdGlvbnMsIGR0eXBlOiAnbGluZWFyJywgZHBvc2l0aW9uOiAnbGVmdCd9O1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuc2NhbGUpIHtcclxuXHRcdFx0aXRlbXMucHVzaCh7XHJcblx0XHRcdFx0b3B0aW9uczogb3B0aW9ucy5zY2FsZSxcclxuXHRcdFx0XHRkdHlwZTogJ3JhZGlhbExpbmVhcicsXHJcblx0XHRcdFx0aXNEZWZhdWx0OiB0cnVlLFxyXG5cdFx0XHRcdGRwb3NpdGlvbjogJ2NoYXJ0QXJlYSdcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aGVscGVycyQxLmVhY2goaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdFx0dmFyIHNjYWxlT3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcclxuXHRcdFx0dmFyIGlkID0gc2NhbGVPcHRpb25zLmlkO1xyXG5cdFx0XHR2YXIgc2NhbGVUeXBlID0gdmFsdWVPckRlZmF1bHQkOShzY2FsZU9wdGlvbnMudHlwZSwgaXRlbS5kdHlwZSk7XHJcblxyXG5cdFx0XHRpZiAocG9zaXRpb25Jc0hvcml6b250YWwoc2NhbGVPcHRpb25zLnBvc2l0aW9uKSAhPT0gcG9zaXRpb25Jc0hvcml6b250YWwoaXRlbS5kcG9zaXRpb24pKSB7XHJcblx0XHRcdFx0c2NhbGVPcHRpb25zLnBvc2l0aW9uID0gaXRlbS5kcG9zaXRpb247XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHVwZGF0ZWRbaWRdID0gdHJ1ZTtcclxuXHRcdFx0dmFyIHNjYWxlID0gbnVsbDtcclxuXHRcdFx0aWYgKGlkIGluIHNjYWxlcyAmJiBzY2FsZXNbaWRdLnR5cGUgPT09IHNjYWxlVHlwZSkge1xyXG5cdFx0XHRcdHNjYWxlID0gc2NhbGVzW2lkXTtcclxuXHRcdFx0XHRzY2FsZS5vcHRpb25zID0gc2NhbGVPcHRpb25zO1xyXG5cdFx0XHRcdHNjYWxlLmN0eCA9IG1lLmN0eDtcclxuXHRcdFx0XHRzY2FsZS5jaGFydCA9IG1lO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBzY2FsZUNsYXNzID0gY29yZV9zY2FsZVNlcnZpY2UuZ2V0U2NhbGVDb25zdHJ1Y3RvcihzY2FsZVR5cGUpO1xyXG5cdFx0XHRcdGlmICghc2NhbGVDbGFzcykge1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRzY2FsZSA9IG5ldyBzY2FsZUNsYXNzKHtcclxuXHRcdFx0XHRcdGlkOiBpZCxcclxuXHRcdFx0XHRcdHR5cGU6IHNjYWxlVHlwZSxcclxuXHRcdFx0XHRcdG9wdGlvbnM6IHNjYWxlT3B0aW9ucyxcclxuXHRcdFx0XHRcdGN0eDogbWUuY3R4LFxyXG5cdFx0XHRcdFx0Y2hhcnQ6IG1lXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0c2NhbGVzW3NjYWxlLmlkXSA9IHNjYWxlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzY2FsZS5tZXJnZVRpY2tzT3B0aW9ucygpO1xyXG5cclxuXHRcdFx0Ly8gVE9ETyhTQik6IEkgdGhpbmsgd2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVtb3ZlIHRoaXMgY3VzdG9tIGNhc2UgKG9wdGlvbnMuc2NhbGUpXHJcblx0XHRcdC8vIGFuZCBjb25zaWRlciBpdCBhcyBhIHJlZ3VsYXIgc2NhbGUgcGFydCBvZiB0aGUgXCJzY2FsZXNcIlwiIG1hcCBvbmx5ISBUaGlzIHdvdWxkXHJcblx0XHRcdC8vIG1ha2UgdGhlIGxvZ2ljIGVhc2llciBhbmQgcmVtb3ZlIHNvbWUgdXNlbGVzcz8gY3VzdG9tIGNvZGUuXHJcblx0XHRcdGlmIChpdGVtLmlzRGVmYXVsdCkge1xyXG5cdFx0XHRcdG1lLnNjYWxlID0gc2NhbGU7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0Ly8gY2xlYXIgdXAgZGlzY2FyZGVkIHNjYWxlc1xyXG5cdFx0aGVscGVycyQxLmVhY2godXBkYXRlZCwgZnVuY3Rpb24oaGFzVXBkYXRlZCwgaWQpIHtcclxuXHRcdFx0aWYgKCFoYXNVcGRhdGVkKSB7XHJcblx0XHRcdFx0ZGVsZXRlIHNjYWxlc1tpZF07XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdG1lLnNjYWxlcyA9IHNjYWxlcztcclxuXHJcblx0XHRjb3JlX3NjYWxlU2VydmljZS5hZGRTY2FsZXNUb0xheW91dCh0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRidWlsZE9yVXBkYXRlQ29udHJvbGxlcnM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBuZXdDb250cm9sbGVycyA9IFtdO1xyXG5cdFx0dmFyIGRhdGFzZXRzID0gbWUuZGF0YS5kYXRhc2V0cztcclxuXHRcdHZhciBpLCBpbGVuO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcclxuXHRcdFx0dmFyIGRhdGFzZXQgPSBkYXRhc2V0c1tpXTtcclxuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShpKTtcclxuXHRcdFx0dmFyIHR5cGUgPSBkYXRhc2V0LnR5cGUgfHwgbWUuY29uZmlnLnR5cGU7XHJcblxyXG5cdFx0XHRpZiAobWV0YS50eXBlICYmIG1ldGEudHlwZSAhPT0gdHlwZSkge1xyXG5cdFx0XHRcdG1lLmRlc3Ryb3lEYXRhc2V0TWV0YShpKTtcclxuXHRcdFx0XHRtZXRhID0gbWUuZ2V0RGF0YXNldE1ldGEoaSk7XHJcblx0XHRcdH1cclxuXHRcdFx0bWV0YS50eXBlID0gdHlwZTtcclxuXHRcdFx0bWV0YS5vcmRlciA9IGRhdGFzZXQub3JkZXIgfHwgMDtcclxuXHRcdFx0bWV0YS5pbmRleCA9IGk7XHJcblxyXG5cdFx0XHRpZiAobWV0YS5jb250cm9sbGVyKSB7XHJcblx0XHRcdFx0bWV0YS5jb250cm9sbGVyLnVwZGF0ZUluZGV4KGkpO1xyXG5cdFx0XHRcdG1ldGEuY29udHJvbGxlci5saW5rU2NhbGVzKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIENvbnRyb2xsZXJDbGFzcyA9IGNvbnRyb2xsZXJzW21ldGEudHlwZV07XHJcblx0XHRcdFx0aWYgKENvbnRyb2xsZXJDbGFzcyA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIG1ldGEudHlwZSArICdcIiBpcyBub3QgYSBjaGFydCB0eXBlLicpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bWV0YS5jb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXJDbGFzcyhtZSwgaSk7XHJcblx0XHRcdFx0bmV3Q29udHJvbGxlcnMucHVzaChtZXRhLmNvbnRyb2xsZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ld0NvbnRyb2xsZXJzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlc2V0IHRoZSBlbGVtZW50cyBvZiBhbGwgZGF0YXNldHNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHJlc2V0RWxlbWVudHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdGhlbHBlcnMkMS5lYWNoKG1lLmRhdGEuZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xyXG5cdFx0XHRtZS5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIucmVzZXQoKTtcclxuXHRcdH0sIG1lKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQqIFJlc2V0cyB0aGUgY2hhcnQgYmFjayB0byBpdCdzIHN0YXRlIGJlZm9yZSB0aGUgaW5pdGlhbCBhbmltYXRpb25cclxuXHQqL1xyXG5cdHJlc2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMucmVzZXRFbGVtZW50cygpO1xyXG5cdFx0dGhpcy50b29sdGlwLmluaXRpYWxpemUoKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uKGNvbmZpZykge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBpLCBpbGVuO1xyXG5cclxuXHRcdGlmICghY29uZmlnIHx8IHR5cGVvZiBjb25maWcgIT09ICdvYmplY3QnKSB7XHJcblx0XHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblx0XHRcdGNvbmZpZyA9IHtcclxuXHRcdFx0XHRkdXJhdGlvbjogY29uZmlnLFxyXG5cdFx0XHRcdGxhenk6IGFyZ3VtZW50c1sxXVxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHVwZGF0ZUNvbmZpZyhtZSk7XHJcblxyXG5cdFx0Ly8gcGx1Z2lucyBvcHRpb25zIHJlZmVyZW5jZXMgbWlnaHQgaGF2ZSBjaGFuZ2UsIGxldCdzIGludmFsaWRhdGUgdGhlIGNhY2hlXHJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTExMSNpc3N1ZWNvbW1lbnQtMzU1OTM0MTY3XHJcblx0XHRjb3JlX3BsdWdpbnMuX2ludmFsaWRhdGUobWUpO1xyXG5cclxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlVXBkYXRlJykgPT09IGZhbHNlKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJbiBjYXNlIHRoZSBlbnRpcmUgZGF0YSBvYmplY3QgY2hhbmdlZFxyXG5cdFx0bWUudG9vbHRpcC5fZGF0YSA9IG1lLmRhdGE7XHJcblxyXG5cdFx0Ly8gTWFrZSBzdXJlIGRhdGFzZXQgY29udHJvbGxlcnMgYXJlIHVwZGF0ZWQgYW5kIG5ldyBjb250cm9sbGVycyBhcmUgcmVzZXRcclxuXHRcdHZhciBuZXdDb250cm9sbGVycyA9IG1lLmJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpO1xyXG5cclxuXHRcdC8vIE1ha2Ugc3VyZSBhbGwgZGF0YXNldCBjb250cm9sbGVycyBoYXZlIGNvcnJlY3QgbWV0YSBkYXRhIGNvdW50c1xyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IG1lLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XHJcblx0XHRcdG1lLmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXIuYnVpbGRPclVwZGF0ZUVsZW1lbnRzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bWUudXBkYXRlTGF5b3V0KCk7XHJcblxyXG5cdFx0Ly8gQ2FuIG9ubHkgcmVzZXQgdGhlIG5ldyBjb250cm9sbGVycyBhZnRlciB0aGUgc2NhbGVzIGhhdmUgYmVlbiB1cGRhdGVkXHJcblx0XHRpZiAobWUub3B0aW9ucy5hbmltYXRpb24gJiYgbWUub3B0aW9ucy5hbmltYXRpb24uZHVyYXRpb24pIHtcclxuXHRcdFx0aGVscGVycyQxLmVhY2gobmV3Q29udHJvbGxlcnMsIGZ1bmN0aW9uKGNvbnRyb2xsZXIpIHtcclxuXHRcdFx0XHRjb250cm9sbGVyLnJlc2V0KCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1lLnVwZGF0ZURhdGFzZXRzKCk7XHJcblxyXG5cdFx0Ly8gTmVlZCB0byByZXNldCB0b29sdGlwIGluIGNhc2UgaXQgaXMgZGlzcGxheWVkIHdpdGggZWxlbWVudHMgdGhhdCBhcmUgcmVtb3ZlZFxyXG5cdFx0Ly8gYWZ0ZXIgdXBkYXRlLlxyXG5cdFx0bWUudG9vbHRpcC5pbml0aWFsaXplKCk7XHJcblxyXG5cdFx0Ly8gTGFzdCBhY3RpdmUgY29udGFpbnMgaXRlbXMgdGhhdCB3ZXJlIHByZXZpb3VzbHkgaW4gdGhlIHRvb2x0aXAuXHJcblx0XHQvLyBXaGVuIHdlIHJlc2V0IHRoZSB0b29sdGlwLCB3ZSBuZWVkIHRvIGNsZWFyIGl0XHJcblx0XHRtZS5sYXN0QWN0aXZlID0gW107XHJcblxyXG5cdFx0Ly8gRG8gdGhpcyBiZWZvcmUgcmVuZGVyIHNvIHRoYXQgYW55IHBsdWdpbnMgdGhhdCBuZWVkIGZpbmFsIHNjYWxlIHVwZGF0ZXMgY2FuIHVzZSBpdFxyXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyVXBkYXRlJyk7XHJcblxyXG5cdFx0bWUuX2xheWVycy5zb3J0KGNvbXBhcmUyTGV2ZWwoJ3onLCAnX2lkeCcpKTtcclxuXHJcblx0XHRpZiAobWUuX2J1ZmZlcmVkUmVuZGVyKSB7XHJcblx0XHRcdG1lLl9idWZmZXJlZFJlcXVlc3QgPSB7XHJcblx0XHRcdFx0ZHVyYXRpb246IGNvbmZpZy5kdXJhdGlvbixcclxuXHRcdFx0XHRlYXNpbmc6IGNvbmZpZy5lYXNpbmcsXHJcblx0XHRcdFx0bGF6eTogY29uZmlnLmxhenlcclxuXHRcdFx0fTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1lLnJlbmRlcihjb25maWcpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhlIGNoYXJ0IGxheW91dCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlTGF5b3V0YFxyXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckxheW91dGAuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHJcblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZUxheW91dCcpID09PSBmYWxzZSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29yZV9sYXlvdXRzLnVwZGF0ZSh0aGlzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcblxyXG5cdFx0bWUuX2xheWVycyA9IFtdO1xyXG5cdFx0aGVscGVycyQxLmVhY2gobWUuYm94ZXMsIGZ1bmN0aW9uKGJveCkge1xyXG5cdFx0XHQvLyBfY29uZmlndXJlIGlzIGNhbGxlZCB0d2ljZSwgb25jZSBpbiBjb3JlLnNjYWxlLnVwZGF0ZSBhbmQgb25jZSBoZXJlLlxyXG5cdFx0XHQvLyBIZXJlIHRoZSBib3hlcyBhcmUgZnVsbHkgdXBkYXRlZCBhbmQgYXQgdGhlaXIgZmluYWwgcG9zaXRpb25zLlxyXG5cdFx0XHRpZiAoYm94Ll9jb25maWd1cmUpIHtcclxuXHRcdFx0XHRib3guX2NvbmZpZ3VyZSgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG1lLl9sYXllcnMucHVzaC5hcHBseShtZS5fbGF5ZXJzLCBib3guX2xheWVycygpKTtcclxuXHRcdH0sIG1lKTtcclxuXHJcblx0XHRtZS5fbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcclxuXHRcdFx0aXRlbS5faWR4ID0gaW5kZXg7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgYGFmdGVyTGF5b3V0YCBpbnN0ZWFkLlxyXG5cdFx0ICogQG1ldGhvZCBJUGx1Z2luI2FmdGVyU2NhbGVVcGRhdGVcclxuXHRcdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi41LjBcclxuXHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlclNjYWxlVXBkYXRlJyk7XHJcblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJMYXlvdXQnKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIGFsbCBkYXRhc2V0cyB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldHNVcGRhdGVgXHJcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNVcGRhdGVgLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlRGF0YXNldHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHJcblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURhdGFzZXRzVXBkYXRlJykgPT09IGZhbHNlKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgaWxlbiA9IG1lLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdG1lLnVwZGF0ZURhdGFzZXQoaSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRGF0YXNldHNVcGRhdGUnKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIGRhdGFzZXQgYXQgaW5kZXggdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRVcGRhdGVgXHJcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldFVwZGF0ZWAuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVEYXRhc2V0OiBmdW5jdGlvbihpbmRleCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBtZXRhID0gbWUuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xyXG5cdFx0dmFyIGFyZ3MgPSB7XHJcblx0XHRcdG1ldGE6IG1ldGEsXHJcblx0XHRcdGluZGV4OiBpbmRleFxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURhdGFzZXRVcGRhdGUnLCBbYXJnc10pID09PSBmYWxzZSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bWV0YS5jb250cm9sbGVyLl91cGRhdGUoKTtcclxuXHJcblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEYXRhc2V0VXBkYXRlJywgW2FyZ3NdKTtcclxuXHR9LFxyXG5cclxuXHRyZW5kZXI6IGZ1bmN0aW9uKGNvbmZpZykge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHJcblx0XHRpZiAoIWNvbmZpZyB8fCB0eXBlb2YgY29uZmlnICE9PSAnb2JqZWN0Jykge1xyXG5cdFx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cdFx0XHRjb25maWcgPSB7XHJcblx0XHRcdFx0ZHVyYXRpb246IGNvbmZpZyxcclxuXHRcdFx0XHRsYXp5OiBhcmd1bWVudHNbMV1cclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYW5pbWF0aW9uT3B0aW9ucyA9IG1lLm9wdGlvbnMuYW5pbWF0aW9uO1xyXG5cdFx0dmFyIGR1cmF0aW9uID0gdmFsdWVPckRlZmF1bHQkOShjb25maWcuZHVyYXRpb24sIGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5kdXJhdGlvbik7XHJcblx0XHR2YXIgbGF6eSA9IGNvbmZpZy5sYXp5O1xyXG5cclxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlUmVuZGVyJykgPT09IGZhbHNlKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb25Db21wbGV0ZSA9IGZ1bmN0aW9uKGFuaW1hdGlvbikge1xyXG5cdFx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJSZW5kZXInKTtcclxuXHRcdFx0aGVscGVycyQxLmNhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vbkNvbXBsZXRlLCBbYW5pbWF0aW9uXSwgbWUpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoYW5pbWF0aW9uT3B0aW9ucyAmJiBkdXJhdGlvbikge1xyXG5cdFx0XHR2YXIgYW5pbWF0aW9uID0gbmV3IGNvcmVfYW5pbWF0aW9uKHtcclxuXHRcdFx0XHRudW1TdGVwczogZHVyYXRpb24gLyAxNi42NiwgLy8gNjAgZnBzXHJcblx0XHRcdFx0ZWFzaW5nOiBjb25maWcuZWFzaW5nIHx8IGFuaW1hdGlvbk9wdGlvbnMuZWFzaW5nLFxyXG5cclxuXHRcdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKGNoYXJ0LCBhbmltYXRpb25PYmplY3QpIHtcclxuXHRcdFx0XHRcdHZhciBlYXNpbmdGdW5jdGlvbiA9IGhlbHBlcnMkMS5lYXNpbmcuZWZmZWN0c1thbmltYXRpb25PYmplY3QuZWFzaW5nXTtcclxuXHRcdFx0XHRcdHZhciBjdXJyZW50U3RlcCA9IGFuaW1hdGlvbk9iamVjdC5jdXJyZW50U3RlcDtcclxuXHRcdFx0XHRcdHZhciBzdGVwRGVjaW1hbCA9IGN1cnJlbnRTdGVwIC8gYW5pbWF0aW9uT2JqZWN0Lm51bVN0ZXBzO1xyXG5cclxuXHRcdFx0XHRcdGNoYXJ0LmRyYXcoZWFzaW5nRnVuY3Rpb24oc3RlcERlY2ltYWwpLCBzdGVwRGVjaW1hbCwgY3VycmVudFN0ZXApO1xyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdG9uQW5pbWF0aW9uUHJvZ3Jlc3M6IGFuaW1hdGlvbk9wdGlvbnMub25Qcm9ncmVzcyxcclxuXHRcdFx0XHRvbkFuaW1hdGlvbkNvbXBsZXRlOiBvbkNvbXBsZXRlXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Y29yZV9hbmltYXRpb25zLmFkZEFuaW1hdGlvbihtZSwgYW5pbWF0aW9uLCBkdXJhdGlvbiwgbGF6eSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtZS5kcmF3KCk7XHJcblxyXG5cdFx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzM3ODFcclxuXHRcdFx0b25Db21wbGV0ZShuZXcgY29yZV9hbmltYXRpb24oe251bVN0ZXBzOiAwLCBjaGFydDogbWV9KSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1lO1xyXG5cdH0sXHJcblxyXG5cdGRyYXc6IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGksIGxheWVycztcclxuXHJcblx0XHRtZS5jbGVhcigpO1xyXG5cclxuXHRcdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZihlYXNpbmdWYWx1ZSkpIHtcclxuXHRcdFx0ZWFzaW5nVmFsdWUgPSAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1lLnRyYW5zaXRpb24oZWFzaW5nVmFsdWUpO1xyXG5cclxuXHRcdGlmIChtZS53aWR0aCA8PSAwIHx8IG1lLmhlaWdodCA8PSAwKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURyYXcnLCBbZWFzaW5nVmFsdWVdKSA9PT0gZmFsc2UpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEJlY2F1c2Ugb2YgcGx1Z2luIGhvb2tzIChiZWZvcmUvYWZ0ZXJEYXRhc2V0c0RyYXcpLCBkYXRhc2V0cyBjYW4ndFxyXG5cdFx0Ly8gY3VycmVudGx5IGJlIHBhcnQgb2YgbGF5ZXJzLiBJbnN0ZWFkLCB3ZSBkcmF3XHJcblx0XHQvLyBsYXllcnMgPD0gMCBiZWZvcmUoZGVmYXVsdCwgYmFja3dhcmQgY29tcGF0KSwgYW5kIHRoZSByZXN0IGFmdGVyXHJcblx0XHRsYXllcnMgPSBtZS5fbGF5ZXJzO1xyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxheWVycy5sZW5ndGggJiYgbGF5ZXJzW2ldLnogPD0gMDsgKytpKSB7XHJcblx0XHRcdGxheWVyc1tpXS5kcmF3KG1lLmNoYXJ0QXJlYSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bWUuZHJhd0RhdGFzZXRzKGVhc2luZ1ZhbHVlKTtcclxuXHJcblx0XHQvLyBSZXN0IG9mIGxheWVyc1xyXG5cdFx0Zm9yICg7IGkgPCBsYXllcnMubGVuZ3RoOyArK2kpIHtcclxuXHRcdFx0bGF5ZXJzW2ldLmRyYXcobWUuY2hhcnRBcmVhKTtcclxuXHRcdH1cclxuXHJcblx0XHRtZS5fZHJhd1Rvb2x0aXAoZWFzaW5nVmFsdWUpO1xyXG5cclxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckRyYXcnLCBbZWFzaW5nVmFsdWVdKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHRyYW5zaXRpb246IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gKG1lLmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRpZiAobWUuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xyXG5cdFx0XHRcdG1lLmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXIudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRtZS50b29sdGlwLnRyYW5zaXRpb24oZWFzaW5nVmFsdWUpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldFNvcnRlZERhdGFzZXRNZXRhczogZnVuY3Rpb24oZmlsdGVyVmlzaWJsZSkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBkYXRhc2V0cyA9IG1lLmRhdGEuZGF0YXNldHMgfHwgW107XHJcblx0XHR2YXIgcmVzdWx0ID0gW107XHJcblx0XHR2YXIgaSwgaWxlbjtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGlmICghZmlsdGVyVmlzaWJsZSB8fCBtZS5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2gobWUuZ2V0RGF0YXNldE1ldGEoaSkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmVzdWx0LnNvcnQoY29tcGFyZTJMZXZlbCgnb3JkZXInLCAnaW5kZXgnKSk7XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLl9nZXRTb3J0ZWREYXRhc2V0TWV0YXModHJ1ZSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogRHJhd3MgYWxsIGRhdGFzZXRzIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0c0RyYXdgXHJcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNEcmF3YC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGRyYXdEYXRhc2V0czogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWV0YXNldHMsIGk7XHJcblxyXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEYXRhc2V0c0RyYXcnLCBbZWFzaW5nVmFsdWVdKSA9PT0gZmFsc2UpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1ldGFzZXRzID0gbWUuX2dldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcclxuXHRcdGZvciAoaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcblx0XHRcdG1lLmRyYXdEYXRhc2V0KG1ldGFzZXRzW2ldLCBlYXNpbmdWYWx1ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRGF0YXNldHNEcmF3JywgW2Vhc2luZ1ZhbHVlXSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogRHJhd3MgZGF0YXNldCBhdCBpbmRleCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldERyYXdgXHJcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldERyYXdgLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0ZHJhd0RhdGFzZXQ6IGZ1bmN0aW9uKG1ldGEsIGVhc2luZ1ZhbHVlKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGFyZ3MgPSB7XHJcblx0XHRcdG1ldGE6IG1ldGEsXHJcblx0XHRcdGluZGV4OiBtZXRhLmluZGV4LFxyXG5cdFx0XHRlYXNpbmdWYWx1ZTogZWFzaW5nVmFsdWVcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEYXRhc2V0RHJhdycsIFthcmdzXSkgPT09IGZhbHNlKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRtZXRhLmNvbnRyb2xsZXIuZHJhdyhlYXNpbmdWYWx1ZSk7XHJcblxyXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRGF0YXNldERyYXcnLCBbYXJnc10pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIERyYXdzIHRvb2x0aXAgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZVRvb2x0aXBEcmF3YFxyXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlclRvb2x0aXBEcmF3YC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9kcmF3VG9vbHRpcDogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgdG9vbHRpcCA9IG1lLnRvb2x0aXA7XHJcblx0XHR2YXIgYXJncyA9IHtcclxuXHRcdFx0dG9vbHRpcDogdG9vbHRpcCxcclxuXHRcdFx0ZWFzaW5nVmFsdWU6IGVhc2luZ1ZhbHVlXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlVG9vbHRpcERyYXcnLCBbYXJnc10pID09PSBmYWxzZSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dG9vbHRpcC5kcmF3KCk7XHJcblxyXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyVG9vbHRpcERyYXcnLCBbYXJnc10pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgc2luZ2xlIGVsZW1lbnQgdGhhdCB3YXMgY2xpY2tlZCBvblxyXG5cdCAqIEByZXR1cm4gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGFzZXQgaW5kZXggYW5kIGVsZW1lbnQgaW5kZXggb2YgdGhlIG1hdGNoaW5nIGVsZW1lbnQuIEFsc28gY29udGFpbnMgdGhlIHJlY3RhbmdsZSB0aGF0IHdhcyBkcmF3XHJcblx0ICovXHJcblx0Z2V0RWxlbWVudEF0RXZlbnQ6IGZ1bmN0aW9uKGUpIHtcclxuXHRcdHJldHVybiBjb3JlX2ludGVyYWN0aW9uLm1vZGVzLnNpbmdsZSh0aGlzLCBlKTtcclxuXHR9LFxyXG5cclxuXHRnZXRFbGVtZW50c0F0RXZlbnQ6IGZ1bmN0aW9uKGUpIHtcclxuXHRcdHJldHVybiBjb3JlX2ludGVyYWN0aW9uLm1vZGVzLmxhYmVsKHRoaXMsIGUsIHtpbnRlcnNlY3Q6IHRydWV9KTtcclxuXHR9LFxyXG5cclxuXHRnZXRFbGVtZW50c0F0WEF4aXM6IGZ1bmN0aW9uKGUpIHtcclxuXHRcdHJldHVybiBjb3JlX2ludGVyYWN0aW9uLm1vZGVzWyd4LWF4aXMnXSh0aGlzLCBlLCB7aW50ZXJzZWN0OiB0cnVlfSk7XHJcblx0fSxcclxuXHJcblx0Z2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZTogZnVuY3Rpb24oZSwgbW9kZSwgb3B0aW9ucykge1xyXG5cdFx0dmFyIG1ldGhvZCA9IGNvcmVfaW50ZXJhY3Rpb24ubW9kZXNbbW9kZV07XHJcblx0XHRpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRyZXR1cm4gbWV0aG9kKHRoaXMsIGUsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBbXTtcclxuXHR9LFxyXG5cclxuXHRnZXREYXRhc2V0QXRFdmVudDogZnVuY3Rpb24oZSkge1xyXG5cdFx0cmV0dXJuIGNvcmVfaW50ZXJhY3Rpb24ubW9kZXMuZGF0YXNldCh0aGlzLCBlLCB7aW50ZXJzZWN0OiB0cnVlfSk7XHJcblx0fSxcclxuXHJcblx0Z2V0RGF0YXNldE1ldGE6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBkYXRhc2V0ID0gbWUuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xyXG5cdFx0aWYgKCFkYXRhc2V0Ll9tZXRhKSB7XHJcblx0XHRcdGRhdGFzZXQuX21ldGEgPSB7fTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbWV0YSA9IGRhdGFzZXQuX21ldGFbbWUuaWRdO1xyXG5cdFx0aWYgKCFtZXRhKSB7XHJcblx0XHRcdG1ldGEgPSBkYXRhc2V0Ll9tZXRhW21lLmlkXSA9IHtcclxuXHRcdFx0XHR0eXBlOiBudWxsLFxyXG5cdFx0XHRcdGRhdGE6IFtdLFxyXG5cdFx0XHRcdGRhdGFzZXQ6IG51bGwsXHJcblx0XHRcdFx0Y29udHJvbGxlcjogbnVsbCxcclxuXHRcdFx0XHRoaWRkZW46IG51bGwsXHRcdFx0Ly8gU2VlIGlzRGF0YXNldFZpc2libGUoKSBjb21tZW50XHJcblx0XHRcdFx0eEF4aXNJRDogbnVsbCxcclxuXHRcdFx0XHR5QXhpc0lEOiBudWxsLFxyXG5cdFx0XHRcdG9yZGVyOiBkYXRhc2V0Lm9yZGVyIHx8IDAsXHJcblx0XHRcdFx0aW5kZXg6IGRhdGFzZXRJbmRleFxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtZXRhO1xyXG5cdH0sXHJcblxyXG5cdGdldFZpc2libGVEYXRhc2V0Q291bnQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGNvdW50ID0gMDtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRpZiAodGhpcy5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XHJcblx0XHRcdFx0Y291bnQrKztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNvdW50O1xyXG5cdH0sXHJcblxyXG5cdGlzRGF0YXNldFZpc2libGU6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xyXG5cdFx0dmFyIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XHJcblxyXG5cdFx0Ly8gbWV0YS5oaWRkZW4gaXMgYSBwZXIgY2hhcnQgZGF0YXNldCBoaWRkZW4gZmxhZyBvdmVycmlkZSB3aXRoIDMgc3RhdGVzOiBpZiB0cnVlIG9yIGZhbHNlLFxyXG5cdFx0Ly8gdGhlIGRhdGFzZXQuaGlkZGVuIHZhbHVlIGlzIGlnbm9yZWQsIGVsc2UgaWYgbnVsbCwgdGhlIGRhdGFzZXQgaGlkZGVuIHN0YXRlIGlzIHJldHVybmVkLlxyXG5cdFx0cmV0dXJuIHR5cGVvZiBtZXRhLmhpZGRlbiA9PT0gJ2Jvb2xlYW4nID8gIW1ldGEuaGlkZGVuIDogIXRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmhpZGRlbjtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZUxlZ2VuZDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmxlZ2VuZENhbGxiYWNrKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0ZGVzdHJveURhdGFzZXRNZXRhOiBmdW5jdGlvbihkYXRhc2V0SW5kZXgpIHtcclxuXHRcdHZhciBpZCA9IHRoaXMuaWQ7XHJcblx0XHR2YXIgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xyXG5cdFx0dmFyIG1ldGEgPSBkYXRhc2V0Ll9tZXRhICYmIGRhdGFzZXQuX21ldGFbaWRdO1xyXG5cclxuXHRcdGlmIChtZXRhKSB7XHJcblx0XHRcdG1ldGEuY29udHJvbGxlci5kZXN0cm95KCk7XHJcblx0XHRcdGRlbGV0ZSBkYXRhc2V0Ll9tZXRhW2lkXTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2FudmFzID0gbWUuY2FudmFzO1xyXG5cdFx0dmFyIGksIGlsZW47XHJcblxyXG5cdFx0bWUuc3RvcCgpO1xyXG5cclxuXHRcdC8vIGRhdGFzZXQgY29udHJvbGxlcnMgbmVlZCB0byBjbGVhbnVwIGFzc29jaWF0ZWQgZGF0YVxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IG1lLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdG1lLmRlc3Ryb3lEYXRhc2V0TWV0YShpKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY2FudmFzKSB7XHJcblx0XHRcdG1lLnVuYmluZEV2ZW50cygpO1xyXG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLmNsZWFyKG1lKTtcclxuXHRcdFx0cGxhdGZvcm0ucmVsZWFzZUNvbnRleHQobWUuY3R4KTtcclxuXHRcdFx0bWUuY2FudmFzID0gbnVsbDtcclxuXHRcdFx0bWUuY3R4ID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnZGVzdHJveScpO1xyXG5cclxuXHRcdGRlbGV0ZSBDaGFydC5pbnN0YW5jZXNbbWUuaWRdO1xyXG5cdH0sXHJcblxyXG5cdHRvQmFzZTY0SW1hZ2U6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2FudmFzLnRvRGF0YVVSTC5hcHBseSh0aGlzLmNhbnZhcywgYXJndW1lbnRzKTtcclxuXHR9LFxyXG5cclxuXHRpbml0VG9vbFRpcDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0bWUudG9vbHRpcCA9IG5ldyBjb3JlX3Rvb2x0aXAoe1xyXG5cdFx0XHRfY2hhcnQ6IG1lLFxyXG5cdFx0XHRfY2hhcnRJbnN0YW5jZTogbWUsIC8vIGRlcHJlY2F0ZWQsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcclxuXHRcdFx0X2RhdGE6IG1lLmRhdGEsXHJcblx0XHRcdF9vcHRpb25zOiBtZS5vcHRpb25zLnRvb2x0aXBzXHJcblx0XHR9LCBtZSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRiaW5kRXZlbnRzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gbWUuX2xpc3RlbmVycyA9IHt9O1xyXG5cdFx0dmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdG1lLmV2ZW50SGFuZGxlci5hcHBseShtZSwgYXJndW1lbnRzKTtcclxuXHRcdH07XHJcblxyXG5cdFx0aGVscGVycyQxLmVhY2gobWUub3B0aW9ucy5ldmVudHMsIGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRcdFx0cGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihtZSwgdHlwZSwgbGlzdGVuZXIpO1xyXG5cdFx0XHRsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIEVsZW1lbnRzIHVzZWQgdG8gZGV0ZWN0IHNpemUgY2hhbmdlIHNob3VsZCBub3QgYmUgaW5qZWN0ZWQgZm9yIG5vbiByZXNwb25zaXZlIGNoYXJ0cy5cclxuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjIxMFxyXG5cdFx0aWYgKG1lLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xyXG5cdFx0XHRsaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdG1lLnJlc2l6ZSgpO1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0cGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihtZSwgJ3Jlc2l6ZScsIGxpc3RlbmVyKTtcclxuXHRcdFx0bGlzdGVuZXJzLnJlc2l6ZSA9IGxpc3RlbmVyO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dW5iaW5kRXZlbnRzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gbWUuX2xpc3RlbmVycztcclxuXHRcdGlmICghbGlzdGVuZXJzKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRkZWxldGUgbWUuX2xpc3RlbmVycztcclxuXHRcdGhlbHBlcnMkMS5lYWNoKGxpc3RlbmVycywgZnVuY3Rpb24obGlzdGVuZXIsIHR5cGUpIHtcclxuXHRcdFx0cGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihtZSwgdHlwZSwgbGlzdGVuZXIpO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlSG92ZXJTdHlsZTogZnVuY3Rpb24oZWxlbWVudHMsIG1vZGUsIGVuYWJsZWQpIHtcclxuXHRcdHZhciBwcmVmaXggPSBlbmFibGVkID8gJ3NldCcgOiAncmVtb3ZlJztcclxuXHRcdHZhciBlbGVtZW50LCBpLCBpbGVuO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0ZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xyXG5cdFx0XHRpZiAoZWxlbWVudCkge1xyXG5cdFx0XHRcdHRoaXMuZ2V0RGF0YXNldE1ldGEoZWxlbWVudC5fZGF0YXNldEluZGV4KS5jb250cm9sbGVyW3ByZWZpeCArICdIb3ZlclN0eWxlJ10oZWxlbWVudCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAobW9kZSA9PT0gJ2RhdGFzZXQnKSB7XHJcblx0XHRcdHRoaXMuZ2V0RGF0YXNldE1ldGEoZWxlbWVudHNbMF0uX2RhdGFzZXRJbmRleCkuY29udHJvbGxlclsnXycgKyBwcmVmaXggKyAnRGF0YXNldEhvdmVyU3R5bGUnXSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0ZXZlbnRIYW5kbGVyOiBmdW5jdGlvbihlKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHRvb2x0aXAgPSBtZS50b29sdGlwO1xyXG5cclxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRXZlbnQnLCBbZV0pID09PSBmYWxzZSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQnVmZmVyIGFueSB1cGRhdGUgY2FsbHMgc28gdGhhdCByZW5kZXJzIGRvIG5vdCBvY2N1clxyXG5cdFx0bWUuX2J1ZmZlcmVkUmVuZGVyID0gdHJ1ZTtcclxuXHRcdG1lLl9idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xyXG5cclxuXHRcdHZhciBjaGFuZ2VkID0gbWUuaGFuZGxlRXZlbnQoZSk7XHJcblx0XHQvLyBmb3Igc21vb3RoIHRvb2x0aXAgYW5pbWF0aW9ucyBpc3N1ZSAjNDk4OVxyXG5cdFx0Ly8gdGhlIHRvb2x0aXAgc2hvdWxkIGJlIHRoZSBzb3VyY2Ugb2YgY2hhbmdlXHJcblx0XHQvLyBBbmltYXRpb24gY2hlY2sgd29ya2Fyb3VuZDpcclxuXHRcdC8vIHRvb2x0aXAuX3N0YXJ0IHdpbGwgYmUgbnVsbCB3aGVuIHRvb2x0aXAgaXNuJ3QgYW5pbWF0aW5nXHJcblx0XHRpZiAodG9vbHRpcCkge1xyXG5cdFx0XHRjaGFuZ2VkID0gdG9vbHRpcC5fc3RhcnRcclxuXHRcdFx0XHQ/IHRvb2x0aXAuaGFuZGxlRXZlbnQoZSlcclxuXHRcdFx0XHQ6IGNoYW5nZWQgfCB0b29sdGlwLmhhbmRsZUV2ZW50KGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckV2ZW50JywgW2VdKTtcclxuXHJcblx0XHR2YXIgYnVmZmVyZWRSZXF1ZXN0ID0gbWUuX2J1ZmZlcmVkUmVxdWVzdDtcclxuXHRcdGlmIChidWZmZXJlZFJlcXVlc3QpIHtcclxuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBhbiB1cGRhdGUgdGhhdCB3YXMgdHJpZ2dlcmVkLCB3ZSBuZWVkIHRvIGRvIGEgbm9ybWFsIHJlbmRlclxyXG5cdFx0XHRtZS5yZW5kZXIoYnVmZmVyZWRSZXF1ZXN0KTtcclxuXHRcdH0gZWxzZSBpZiAoY2hhbmdlZCAmJiAhbWUuYW5pbWF0aW5nKSB7XHJcblx0XHRcdC8vIElmIGVudGVyaW5nLCBsZWF2aW5nLCBvciBjaGFuZ2luZyBlbGVtZW50cywgYW5pbWF0ZSB0aGUgY2hhbmdlIHZpYSBwaXZvdFxyXG5cdFx0XHRtZS5zdG9wKCk7XHJcblxyXG5cdFx0XHQvLyBXZSBvbmx5IG5lZWQgdG8gcmVuZGVyIGF0IHRoaXMgcG9pbnQuIFVwZGF0aW5nIHdpbGwgY2F1c2Ugc2NhbGVzIHRvIGJlXHJcblx0XHRcdC8vIHJlY29tcHV0ZWQgZ2VuZXJhdGluZyBmbGlja2VyICYgdXNpbmcgbW9yZSBtZW1vcnkgdGhhbiBuZWNlc3NhcnkuXHJcblx0XHRcdG1lLnJlbmRlcih7XHJcblx0XHRcdFx0ZHVyYXRpb246IG1lLm9wdGlvbnMuaG92ZXIuYW5pbWF0aW9uRHVyYXRpb24sXHJcblx0XHRcdFx0bGF6eTogdHJ1ZVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRtZS5fYnVmZmVyZWRSZW5kZXIgPSBmYWxzZTtcclxuXHRcdG1lLl9idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xyXG5cclxuXHRcdHJldHVybiBtZTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7SUV2ZW50fSBldmVudCB0aGUgZXZlbnQgdG8gaGFuZGxlXHJcblx0ICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2hhcnQgbmVlZHMgdG8gcmUtcmVuZGVyXHJcblx0ICovXHJcblx0aGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnMgfHwge307XHJcblx0XHR2YXIgaG92ZXJPcHRpb25zID0gb3B0aW9ucy5ob3ZlcjtcclxuXHRcdHZhciBjaGFuZ2VkID0gZmFsc2U7XHJcblxyXG5cdFx0bWUubGFzdEFjdGl2ZSA9IG1lLmxhc3RBY3RpdmUgfHwgW107XHJcblxyXG5cdFx0Ly8gRmluZCBBY3RpdmUgRWxlbWVudHMgZm9yIGhvdmVyIGFuZCB0b29sdGlwc1xyXG5cdFx0aWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xyXG5cdFx0XHRtZS5hY3RpdmUgPSBbXTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1lLmFjdGl2ZSA9IG1lLmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgaG92ZXJPcHRpb25zLm1vZGUsIGhvdmVyT3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSW52b2tlIG9uSG92ZXIgaG9va1xyXG5cdFx0Ly8gTmVlZCB0byBjYWxsIHdpdGggbmF0aXZlIGV2ZW50IGhlcmUgdG8gbm90IGJyZWFrIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sob3B0aW9ucy5vbkhvdmVyIHx8IG9wdGlvbnMuaG92ZXIub25Ib3ZlciwgW2UubmF0aXZlLCBtZS5hY3RpdmVdLCBtZSk7XHJcblxyXG5cdFx0aWYgKGUudHlwZSA9PT0gJ21vdXNldXAnIHx8IGUudHlwZSA9PT0gJ2NsaWNrJykge1xyXG5cdFx0XHRpZiAob3B0aW9ucy5vbkNsaWNrKSB7XHJcblx0XHRcdFx0Ly8gVXNlIGUubmF0aXZlIGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblx0XHRcdFx0b3B0aW9ucy5vbkNsaWNrLmNhbGwobWUsIGUubmF0aXZlLCBtZS5hY3RpdmUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gUmVtb3ZlIHN0eWxpbmcgZm9yIGxhc3QgYWN0aXZlIChldmVuIGlmIGl0IG1heSBzdGlsbCBiZSBhY3RpdmUpXHJcblx0XHRpZiAobWUubGFzdEFjdGl2ZS5sZW5ndGgpIHtcclxuXHRcdFx0bWUudXBkYXRlSG92ZXJTdHlsZShtZS5sYXN0QWN0aXZlLCBob3Zlck9wdGlvbnMubW9kZSwgZmFsc2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEJ1aWx0IGluIGhvdmVyIHN0eWxpbmdcclxuXHRcdGlmIChtZS5hY3RpdmUubGVuZ3RoICYmIGhvdmVyT3B0aW9ucy5tb2RlKSB7XHJcblx0XHRcdG1lLnVwZGF0ZUhvdmVyU3R5bGUobWUuYWN0aXZlLCBob3Zlck9wdGlvbnMubW9kZSwgdHJ1ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y2hhbmdlZCA9ICFoZWxwZXJzJDEuYXJyYXlFcXVhbHMobWUuYWN0aXZlLCBtZS5sYXN0QWN0aXZlKTtcclxuXHJcblx0XHQvLyBSZW1lbWJlciBMYXN0IEFjdGl2ZXNcclxuXHRcdG1lLmxhc3RBY3RpdmUgPSBtZS5hY3RpdmU7XHJcblxyXG5cdFx0cmV0dXJuIGNoYW5nZWQ7XHJcblx0fVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBOT1RFKFNCKSBXZSBhY3R1YWxseSBkb24ndCB1c2UgdGhpcyBjb250YWluZXIgYW55bW9yZSBidXQgd2UgbmVlZCB0byBrZWVwIGl0XHJcbiAqIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBUaG91Z2gsIGl0IGNhbiBzdGlsbCBiZSB1c2VmdWwgZm9yIHBsdWdpbnMgdGhhdFxyXG4gKiB3b3VsZCBuZWVkIHRvIHdvcmsgb24gbXVsdGlwbGUgY2hhcnRzPyFcclxuICovXHJcbkNoYXJ0Lmluc3RhbmNlcyA9IHt9O1xyXG5cclxudmFyIGNvcmVfY29udHJvbGxlciA9IENoYXJ0O1xyXG5cclxuLy8gREVQUkVDQVRJT05TXHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydCBpbnN0ZWFkLlxyXG4gKiBAY2xhc3MgQ2hhcnQuQ29udHJvbGxlclxyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNlxyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5DaGFydC5Db250cm9sbGVyID0gQ2hhcnQ7XHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZS5cclxuICogQG5hbWVzcGFjZSBDaGFydFxyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOFxyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5DaGFydC50eXBlcyA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmUuXHJcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVycy5jb25maWdNZXJnZVxyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXHJcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuICogQHByaXZhdGVcclxuICovXHJcbmhlbHBlcnMkMS5jb25maWdNZXJnZSA9IG1lcmdlQ29uZmlnO1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmUuXHJcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVycy5zY2FsZU1lcmdlXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuaGVscGVycyQxLnNjYWxlTWVyZ2UgPSBtZXJnZVNjYWxlQ29uZmlnO1xuXG52YXIgY29yZV9oZWxwZXJzID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdC8vIC0tIEJhc2ljIGpzIHV0aWxpdHkgbWV0aG9kc1xyXG5cclxuXHRoZWxwZXJzJDEud2hlcmUgPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBmaWx0ZXJDYWxsYmFjaykge1xyXG5cdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KGNvbGxlY3Rpb24pICYmIEFycmF5LnByb3RvdHlwZS5maWx0ZXIpIHtcclxuXHRcdFx0cmV0dXJuIGNvbGxlY3Rpb24uZmlsdGVyKGZpbHRlckNhbGxiYWNrKTtcclxuXHRcdH1cclxuXHRcdHZhciBmaWx0ZXJlZCA9IFtdO1xyXG5cclxuXHRcdGhlbHBlcnMkMS5lYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdFx0aWYgKGZpbHRlckNhbGxiYWNrKGl0ZW0pKSB7XHJcblx0XHRcdFx0ZmlsdGVyZWQucHVzaChpdGVtKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGZpbHRlcmVkO1xyXG5cdH07XHJcblx0aGVscGVycyQxLmZpbmRJbmRleCA9IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXggP1xyXG5cdFx0ZnVuY3Rpb24oYXJyYXksIGNhbGxiYWNrLCBzY29wZSkge1xyXG5cdFx0XHRyZXR1cm4gYXJyYXkuZmluZEluZGV4KGNhbGxiYWNrLCBzY29wZSk7XHJcblx0XHR9IDpcclxuXHRcdGZ1bmN0aW9uKGFycmF5LCBjYWxsYmFjaywgc2NvcGUpIHtcclxuXHRcdFx0c2NvcGUgPSBzY29wZSA9PT0gdW5kZWZpbmVkID8gYXJyYXkgOiBzY29wZTtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGlsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0XHRpZiAoY2FsbGJhY2suY2FsbChzY29wZSwgYXJyYXlbaV0sIGksIGFycmF5KSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiAtMTtcclxuXHRcdH07XHJcblx0aGVscGVycyQxLmZpbmROZXh0V2hlcmUgPSBmdW5jdGlvbihhcnJheVRvU2VhcmNoLCBmaWx0ZXJDYWxsYmFjaywgc3RhcnRJbmRleCkge1xyXG5cdFx0Ly8gRGVmYXVsdCB0byBzdGFydCBvZiB0aGUgYXJyYXlcclxuXHRcdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZihzdGFydEluZGV4KSkge1xyXG5cdFx0XHRzdGFydEluZGV4ID0gLTE7XHJcblx0XHR9XHJcblx0XHRmb3IgKHZhciBpID0gc3RhcnRJbmRleCArIDE7IGkgPCBhcnJheVRvU2VhcmNoLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBjdXJyZW50SXRlbSA9IGFycmF5VG9TZWFyY2hbaV07XHJcblx0XHRcdGlmIChmaWx0ZXJDYWxsYmFjayhjdXJyZW50SXRlbSkpIHtcclxuXHRcdFx0XHRyZXR1cm4gY3VycmVudEl0ZW07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdGhlbHBlcnMkMS5maW5kUHJldmlvdXNXaGVyZSA9IGZ1bmN0aW9uKGFycmF5VG9TZWFyY2gsIGZpbHRlckNhbGxiYWNrLCBzdGFydEluZGV4KSB7XHJcblx0XHQvLyBEZWZhdWx0IHRvIGVuZCBvZiB0aGUgYXJyYXlcclxuXHRcdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZihzdGFydEluZGV4KSkge1xyXG5cdFx0XHRzdGFydEluZGV4ID0gYXJyYXlUb1NlYXJjaC5sZW5ndGg7XHJcblx0XHR9XHJcblx0XHRmb3IgKHZhciBpID0gc3RhcnRJbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdHZhciBjdXJyZW50SXRlbSA9IGFycmF5VG9TZWFyY2hbaV07XHJcblx0XHRcdGlmIChmaWx0ZXJDYWxsYmFjayhjdXJyZW50SXRlbSkpIHtcclxuXHRcdFx0XHRyZXR1cm4gY3VycmVudEl0ZW07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvLyAtLSBNYXRoIG1ldGhvZHNcclxuXHRoZWxwZXJzJDEuaXNOdW1iZXIgPSBmdW5jdGlvbihuKSB7XHJcblx0XHRyZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xyXG5cdH07XHJcblx0aGVscGVycyQxLmFsbW9zdEVxdWFscyA9IGZ1bmN0aW9uKHgsIHksIGVwc2lsb24pIHtcclxuXHRcdHJldHVybiBNYXRoLmFicyh4IC0geSkgPCBlcHNpbG9uO1xyXG5cdH07XHJcblx0aGVscGVycyQxLmFsbW9zdFdob2xlID0gZnVuY3Rpb24oeCwgZXBzaWxvbikge1xyXG5cdFx0dmFyIHJvdW5kZWQgPSBNYXRoLnJvdW5kKHgpO1xyXG5cdFx0cmV0dXJuICgocm91bmRlZCAtIGVwc2lsb24pIDw9IHgpICYmICgocm91bmRlZCArIGVwc2lsb24pID49IHgpO1xyXG5cdH07XHJcblx0aGVscGVycyQxLm1heCA9IGZ1bmN0aW9uKGFycmF5KSB7XHJcblx0XHRyZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKG1heCwgdmFsdWUpIHtcclxuXHRcdFx0aWYgKCFpc05hTih2YWx1ZSkpIHtcclxuXHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgobWF4LCB2YWx1ZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG1heDtcclxuXHRcdH0sIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XHJcblx0fTtcclxuXHRoZWxwZXJzJDEubWluID0gZnVuY3Rpb24oYXJyYXkpIHtcclxuXHRcdHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24obWluLCB2YWx1ZSkge1xyXG5cdFx0XHRpZiAoIWlzTmFOKHZhbHVlKSkge1xyXG5cdFx0XHRcdHJldHVybiBNYXRoLm1pbihtaW4sIHZhbHVlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbWluO1xyXG5cdFx0fSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcclxuXHR9O1xyXG5cdGhlbHBlcnMkMS5zaWduID0gTWF0aC5zaWduID9cclxuXHRcdGZ1bmN0aW9uKHgpIHtcclxuXHRcdFx0cmV0dXJuIE1hdGguc2lnbih4KTtcclxuXHRcdH0gOlxyXG5cdFx0ZnVuY3Rpb24oeCkge1xyXG5cdFx0XHR4ID0gK3g7IC8vIGNvbnZlcnQgdG8gYSBudW1iZXJcclxuXHRcdFx0aWYgKHggPT09IDAgfHwgaXNOYU4oeCkpIHtcclxuXHRcdFx0XHRyZXR1cm4geDtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4geCA+IDAgPyAxIDogLTE7XHJcblx0XHR9O1xyXG5cdGhlbHBlcnMkMS50b1JhZGlhbnMgPSBmdW5jdGlvbihkZWdyZWVzKSB7XHJcblx0XHRyZXR1cm4gZGVncmVlcyAqIChNYXRoLlBJIC8gMTgwKTtcclxuXHR9O1xyXG5cdGhlbHBlcnMkMS50b0RlZ3JlZXMgPSBmdW5jdGlvbihyYWRpYW5zKSB7XHJcblx0XHRyZXR1cm4gcmFkaWFucyAqICgxODAgLyBNYXRoLlBJKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcclxuXHQgKiBpLmUuIHRoZSBudW1iZXIgb2YgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBOdW1iZXIuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBBIG51bWJlci5cclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aGVscGVycyQxLl9kZWNpbWFsUGxhY2VzID0gZnVuY3Rpb24oeCkge1xyXG5cdFx0aWYgKCFoZWxwZXJzJDEuaXNGaW5pdGUoeCkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGUgPSAxO1xyXG5cdFx0dmFyIHAgPSAwO1xyXG5cdFx0d2hpbGUgKE1hdGgucm91bmQoeCAqIGUpIC8gZSAhPT0geCkge1xyXG5cdFx0XHRlICo9IDEwO1xyXG5cdFx0XHRwKys7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcDtcclxuXHR9O1xyXG5cclxuXHQvLyBHZXRzIHRoZSBhbmdsZSBmcm9tIHZlcnRpY2FsIHVwcmlnaHQgdG8gdGhlIHBvaW50IGFib3V0IGEgY2VudHJlLlxyXG5cdGhlbHBlcnMkMS5nZXRBbmdsZUZyb21Qb2ludCA9IGZ1bmN0aW9uKGNlbnRyZVBvaW50LCBhbmdsZVBvaW50KSB7XHJcblx0XHR2YXIgZGlzdGFuY2VGcm9tWENlbnRlciA9IGFuZ2xlUG9pbnQueCAtIGNlbnRyZVBvaW50Lng7XHJcblx0XHR2YXIgZGlzdGFuY2VGcm9tWUNlbnRlciA9IGFuZ2xlUG9pbnQueSAtIGNlbnRyZVBvaW50Lnk7XHJcblx0XHR2YXIgcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyID0gTWF0aC5zcXJ0KGRpc3RhbmNlRnJvbVhDZW50ZXIgKiBkaXN0YW5jZUZyb21YQ2VudGVyICsgZGlzdGFuY2VGcm9tWUNlbnRlciAqIGRpc3RhbmNlRnJvbVlDZW50ZXIpO1xyXG5cclxuXHRcdHZhciBhbmdsZSA9IE1hdGguYXRhbjIoZGlzdGFuY2VGcm9tWUNlbnRlciwgZGlzdGFuY2VGcm9tWENlbnRlcik7XHJcblxyXG5cdFx0aWYgKGFuZ2xlIDwgKC0wLjUgKiBNYXRoLlBJKSkge1xyXG5cdFx0XHRhbmdsZSArPSAyLjAgKiBNYXRoLlBJOyAvLyBtYWtlIHN1cmUgdGhlIHJldHVybmVkIGFuZ2xlIGlzIGluIHRoZSByYW5nZSBvZiAoLVBJLzIsIDNQSS8yXVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGFuZ2xlOiBhbmdsZSxcclxuXHRcdFx0ZGlzdGFuY2U6IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlclxyXG5cdFx0fTtcclxuXHR9O1xyXG5cdGhlbHBlcnMkMS5kaXN0YW5jZUJldHdlZW5Qb2ludHMgPSBmdW5jdGlvbihwdDEsIHB0Mikge1xyXG5cdFx0cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwdDIueCAtIHB0MS54LCAyKSArIE1hdGgucG93KHB0Mi55IC0gcHQxLnksIDIpKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlXHJcblx0ICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuYWxpYXNQaXhlbFxyXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcclxuXHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcblx0ICovXHJcblx0aGVscGVycyQxLmFsaWFzUGl4ZWwgPSBmdW5jdGlvbihwaXhlbFdpZHRoKSB7XHJcblx0XHRyZXR1cm4gKHBpeGVsV2lkdGggJSAyID09PSAwKSA/IDAgOiAwLjU7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgYWxpZ25lZCBwaXhlbCB2YWx1ZSB0byBhdm9pZCBhbnRpLWFsaWFzaW5nIGJsdXJcclxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWwgLSBBIHBpeGVsIHZhbHVlLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgZWxlbWVudC5cclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgYWxpZ25lZCBwaXhlbCB2YWx1ZS5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGhlbHBlcnMkMS5fYWxpZ25QaXhlbCA9IGZ1bmN0aW9uKGNoYXJ0LCBwaXhlbCwgd2lkdGgpIHtcclxuXHRcdHZhciBkZXZpY2VQaXhlbFJhdGlvID0gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW87XHJcblx0XHR2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xyXG5cdFx0cmV0dXJuIE1hdGgucm91bmQoKHBpeGVsIC0gaGFsZldpZHRoKSAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbyArIGhhbGZXaWR0aDtcclxuXHR9O1xyXG5cclxuXHRoZWxwZXJzJDEuc3BsaW5lQ3VydmUgPSBmdW5jdGlvbihmaXJzdFBvaW50LCBtaWRkbGVQb2ludCwgYWZ0ZXJQb2ludCwgdCkge1xyXG5cdFx0Ly8gUHJvcHMgdG8gUm9iIFNwZW5jZXIgYXQgc2NhbGVkIGlubm92YXRpb24gZm9yIGhpcyBwb3N0IG9uIHNwbGluaW5nIGJldHdlZW4gcG9pbnRzXHJcblx0XHQvLyBodHRwOi8vc2NhbGVkaW5ub3ZhdGlvbi5jb20vYW5hbHl0aWNzL3NwbGluZXMvYWJvdXRTcGxpbmVzLmh0bWxcclxuXHJcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIG11c3QgYWxzbyByZXNwZWN0IFwic2tpcHBlZFwiIHBvaW50c1xyXG5cclxuXHRcdHZhciBwcmV2aW91cyA9IGZpcnN0UG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogZmlyc3RQb2ludDtcclxuXHRcdHZhciBjdXJyZW50ID0gbWlkZGxlUG9pbnQ7XHJcblx0XHR2YXIgbmV4dCA9IGFmdGVyUG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogYWZ0ZXJQb2ludDtcclxuXHJcblx0XHR2YXIgZDAxID0gTWF0aC5zcXJ0KE1hdGgucG93KGN1cnJlbnQueCAtIHByZXZpb3VzLngsIDIpICsgTWF0aC5wb3coY3VycmVudC55IC0gcHJldmlvdXMueSwgMikpO1xyXG5cdFx0dmFyIGQxMiA9IE1hdGguc3FydChNYXRoLnBvdyhuZXh0LnggLSBjdXJyZW50LngsIDIpICsgTWF0aC5wb3cobmV4dC55IC0gY3VycmVudC55LCAyKSk7XHJcblxyXG5cdFx0dmFyIHMwMSA9IGQwMSAvIChkMDEgKyBkMTIpO1xyXG5cdFx0dmFyIHMxMiA9IGQxMiAvIChkMDEgKyBkMTIpO1xyXG5cclxuXHRcdC8vIElmIGFsbCBwb2ludHMgYXJlIHRoZSBzYW1lLCBzMDEgJiBzMDIgd2lsbCBiZSBpbmZcclxuXHRcdHMwMSA9IGlzTmFOKHMwMSkgPyAwIDogczAxO1xyXG5cdFx0czEyID0gaXNOYU4oczEyKSA/IDAgOiBzMTI7XHJcblxyXG5cdFx0dmFyIGZhID0gdCAqIHMwMTsgLy8gc2NhbGluZyBmYWN0b3IgZm9yIHRyaWFuZ2xlIFRhXHJcblx0XHR2YXIgZmIgPSB0ICogczEyO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHByZXZpb3VzOiB7XHJcblx0XHRcdFx0eDogY3VycmVudC54IC0gZmEgKiAobmV4dC54IC0gcHJldmlvdXMueCksXHJcblx0XHRcdFx0eTogY3VycmVudC55IC0gZmEgKiAobmV4dC55IC0gcHJldmlvdXMueSlcclxuXHRcdFx0fSxcclxuXHRcdFx0bmV4dDoge1xyXG5cdFx0XHRcdHg6IGN1cnJlbnQueCArIGZiICogKG5leHQueCAtIHByZXZpb3VzLngpLFxyXG5cdFx0XHRcdHk6IGN1cnJlbnQueSArIGZiICogKG5leHQueSAtIHByZXZpb3VzLnkpXHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0fTtcclxuXHRoZWxwZXJzJDEuRVBTSUxPTiA9IE51bWJlci5FUFNJTE9OIHx8IDFlLTE0O1xyXG5cdGhlbHBlcnMkMS5zcGxpbmVDdXJ2ZU1vbm90b25lID0gZnVuY3Rpb24ocG9pbnRzKSB7XHJcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgQsOpemllciBjb250cm9sIHBvaW50cyBpbiBhIHNpbWlsYXIgd2F5IHRoYW4gfHNwbGluZUN1cnZlfCxcclxuXHRcdC8vIGJ1dCBwcmVzZXJ2ZXMgbW9ub3RvbmljaXR5IG9mIHRoZSBwcm92aWRlZCBkYXRhIGFuZCBlbnN1cmVzIG5vIGxvY2FsIGV4dHJlbXVtcyBhcmUgYWRkZWRcclxuXHRcdC8vIGJldHdlZW4gdGhlIGRhdGFzZXQgZGlzY3JldGUgcG9pbnRzIGR1ZSB0byB0aGUgaW50ZXJwb2xhdGlvbi5cclxuXHRcdC8vIFNlZSA6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vbm90b25lX2N1YmljX2ludGVycG9sYXRpb25cclxuXHJcblx0XHR2YXIgcG9pbnRzV2l0aFRhbmdlbnRzID0gKHBvaW50cyB8fCBbXSkubWFwKGZ1bmN0aW9uKHBvaW50KSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0bW9kZWw6IHBvaW50Ll9tb2RlbCxcclxuXHRcdFx0XHRkZWx0YUs6IDAsXHJcblx0XHRcdFx0bUs6IDBcclxuXHRcdFx0fTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIENhbGN1bGF0ZSBzbG9wZXMgKGRlbHRhSykgYW5kIGluaXRpYWxpemUgdGFuZ2VudHMgKG1LKVxyXG5cdFx0dmFyIHBvaW50c0xlbiA9IHBvaW50c1dpdGhUYW5nZW50cy5sZW5ndGg7XHJcblx0XHR2YXIgaSwgcG9pbnRCZWZvcmUsIHBvaW50Q3VycmVudCwgcG9pbnRBZnRlcjtcclxuXHRcdGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xyXG5cdFx0XHRwb2ludEN1cnJlbnQgPSBwb2ludHNXaXRoVGFuZ2VudHNbaV07XHJcblx0XHRcdGlmIChwb2ludEN1cnJlbnQubW9kZWwuc2tpcCkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwb2ludEJlZm9yZSA9IGkgPiAwID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgLSAxXSA6IG51bGw7XHJcblx0XHRcdHBvaW50QWZ0ZXIgPSBpIDwgcG9pbnRzTGVuIC0gMSA/IHBvaW50c1dpdGhUYW5nZW50c1tpICsgMV0gOiBudWxsO1xyXG5cdFx0XHRpZiAocG9pbnRBZnRlciAmJiAhcG9pbnRBZnRlci5tb2RlbC5za2lwKSB7XHJcblx0XHRcdFx0dmFyIHNsb3BlRGVsdGFYID0gKHBvaW50QWZ0ZXIubW9kZWwueCAtIHBvaW50Q3VycmVudC5tb2RlbC54KTtcclxuXHJcblx0XHRcdFx0Ly8gSW4gdGhlIGNhc2Ugb2YgdHdvIHBvaW50cyB0aGF0IGFwcGVhciBhdCB0aGUgc2FtZSB4IHBpeGVsLCBzbG9wZURlbHRhWCBpcyAwXHJcblx0XHRcdFx0cG9pbnRDdXJyZW50LmRlbHRhSyA9IHNsb3BlRGVsdGFYICE9PSAwID8gKHBvaW50QWZ0ZXIubW9kZWwueSAtIHBvaW50Q3VycmVudC5tb2RlbC55KSAvIHNsb3BlRGVsdGFYIDogMDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCFwb2ludEJlZm9yZSB8fCBwb2ludEJlZm9yZS5tb2RlbC5za2lwKSB7XHJcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gcG9pbnRDdXJyZW50LmRlbHRhSztcclxuXHRcdFx0fSBlbHNlIGlmICghcG9pbnRBZnRlciB8fCBwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcclxuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSBwb2ludEJlZm9yZS5kZWx0YUs7XHJcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5zaWduKHBvaW50QmVmb3JlLmRlbHRhSykgIT09IHRoaXMuc2lnbihwb2ludEN1cnJlbnQuZGVsdGFLKSkge1xyXG5cdFx0XHRcdHBvaW50Q3VycmVudC5tSyA9IDA7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gKHBvaW50QmVmb3JlLmRlbHRhSyArIHBvaW50Q3VycmVudC5kZWx0YUspIC8gMjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFkanVzdCB0YW5nZW50cyB0byBlbnN1cmUgbW9ub3RvbmljIHByb3BlcnRpZXNcclxuXHRcdHZhciBhbHBoYUssIGJldGFLLCB0YXVLLCBzcXVhcmVkTWFnbml0dWRlO1xyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHBvaW50c0xlbiAtIDE7ICsraSkge1xyXG5cdFx0XHRwb2ludEN1cnJlbnQgPSBwb2ludHNXaXRoVGFuZ2VudHNbaV07XHJcblx0XHRcdHBvaW50QWZ0ZXIgPSBwb2ludHNXaXRoVGFuZ2VudHNbaSArIDFdO1xyXG5cdFx0XHRpZiAocG9pbnRDdXJyZW50Lm1vZGVsLnNraXAgfHwgcG9pbnRBZnRlci5tb2RlbC5za2lwKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChoZWxwZXJzJDEuYWxtb3N0RXF1YWxzKHBvaW50Q3VycmVudC5kZWx0YUssIDAsIHRoaXMuRVBTSUxPTikpIHtcclxuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSBwb2ludEFmdGVyLm1LID0gMDtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YWxwaGFLID0gcG9pbnRDdXJyZW50Lm1LIC8gcG9pbnRDdXJyZW50LmRlbHRhSztcclxuXHRcdFx0YmV0YUsgPSBwb2ludEFmdGVyLm1LIC8gcG9pbnRDdXJyZW50LmRlbHRhSztcclxuXHRcdFx0c3F1YXJlZE1hZ25pdHVkZSA9IE1hdGgucG93KGFscGhhSywgMikgKyBNYXRoLnBvdyhiZXRhSywgMik7XHJcblx0XHRcdGlmIChzcXVhcmVkTWFnbml0dWRlIDw9IDkpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGF1SyA9IDMgLyBNYXRoLnNxcnQoc3F1YXJlZE1hZ25pdHVkZSk7XHJcblx0XHRcdHBvaW50Q3VycmVudC5tSyA9IGFscGhhSyAqIHRhdUsgKiBwb2ludEN1cnJlbnQuZGVsdGFLO1xyXG5cdFx0XHRwb2ludEFmdGVyLm1LID0gYmV0YUsgKiB0YXVLICogcG9pbnRDdXJyZW50LmRlbHRhSztcclxuXHRcdH1cclxuXHJcblx0XHQvLyBDb21wdXRlIGNvbnRyb2wgcG9pbnRzXHJcblx0XHR2YXIgZGVsdGFYO1xyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XHJcblx0XHRcdHBvaW50Q3VycmVudCA9IHBvaW50c1dpdGhUYW5nZW50c1tpXTtcclxuXHRcdFx0aWYgKHBvaW50Q3VycmVudC5tb2RlbC5za2lwKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHBvaW50QmVmb3JlID0gaSA+IDAgPyBwb2ludHNXaXRoVGFuZ2VudHNbaSAtIDFdIDogbnVsbDtcclxuXHRcdFx0cG9pbnRBZnRlciA9IGkgPCBwb2ludHNMZW4gLSAxID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgKyAxXSA6IG51bGw7XHJcblx0XHRcdGlmIChwb2ludEJlZm9yZSAmJiAhcG9pbnRCZWZvcmUubW9kZWwuc2tpcCkge1xyXG5cdFx0XHRcdGRlbHRhWCA9IChwb2ludEN1cnJlbnQubW9kZWwueCAtIHBvaW50QmVmb3JlLm1vZGVsLngpIC8gMztcclxuXHRcdFx0XHRwb2ludEN1cnJlbnQubW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYID0gcG9pbnRDdXJyZW50Lm1vZGVsLnggLSBkZWx0YVg7XHJcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSA9IHBvaW50Q3VycmVudC5tb2RlbC55IC0gZGVsdGFYICogcG9pbnRDdXJyZW50Lm1LO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChwb2ludEFmdGVyICYmICFwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcclxuXHRcdFx0XHRkZWx0YVggPSAocG9pbnRBZnRlci5tb2RlbC54IC0gcG9pbnRDdXJyZW50Lm1vZGVsLngpIC8gMztcclxuXHRcdFx0XHRwb2ludEN1cnJlbnQubW9kZWwuY29udHJvbFBvaW50TmV4dFggPSBwb2ludEN1cnJlbnQubW9kZWwueCArIGRlbHRhWDtcclxuXHRcdFx0XHRwb2ludEN1cnJlbnQubW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBwb2ludEN1cnJlbnQubW9kZWwueSArIGRlbHRhWCAqIHBvaW50Q3VycmVudC5tSztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0aGVscGVycyQxLm5leHRJdGVtID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgaW5kZXgsIGxvb3ApIHtcclxuXHRcdGlmIChsb29wKSB7XHJcblx0XHRcdHJldHVybiBpbmRleCA+PSBjb2xsZWN0aW9uLmxlbmd0aCAtIDEgPyBjb2xsZWN0aW9uWzBdIDogY29sbGVjdGlvbltpbmRleCArIDFdO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGluZGV4ID49IGNvbGxlY3Rpb24ubGVuZ3RoIC0gMSA/IGNvbGxlY3Rpb25bY29sbGVjdGlvbi5sZW5ndGggLSAxXSA6IGNvbGxlY3Rpb25baW5kZXggKyAxXTtcclxuXHR9O1xyXG5cdGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBpbmRleCwgbG9vcCkge1xyXG5cdFx0aWYgKGxvb3ApIHtcclxuXHRcdFx0cmV0dXJuIGluZGV4IDw9IDAgPyBjb2xsZWN0aW9uW2NvbGxlY3Rpb24ubGVuZ3RoIC0gMV0gOiBjb2xsZWN0aW9uW2luZGV4IC0gMV07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gaW5kZXggPD0gMCA/IGNvbGxlY3Rpb25bMF0gOiBjb2xsZWN0aW9uW2luZGV4IC0gMV07XHJcblx0fTtcclxuXHQvLyBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgbmljZSBudW1iZXIgYWxnb3JpdGhtIHVzZWQgaW4gZGV0ZXJtaW5pbmcgd2hlcmUgYXhpcyBsYWJlbHMgd2lsbCBnb1xyXG5cdGhlbHBlcnMkMS5uaWNlTnVtID0gZnVuY3Rpb24ocmFuZ2UsIHJvdW5kKSB7XHJcblx0XHR2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMChyYW5nZSkpO1xyXG5cdFx0dmFyIGZyYWN0aW9uID0gcmFuZ2UgLyBNYXRoLnBvdygxMCwgZXhwb25lbnQpO1xyXG5cdFx0dmFyIG5pY2VGcmFjdGlvbjtcclxuXHJcblx0XHRpZiAocm91bmQpIHtcclxuXHRcdFx0aWYgKGZyYWN0aW9uIDwgMS41KSB7XHJcblx0XHRcdFx0bmljZUZyYWN0aW9uID0gMTtcclxuXHRcdFx0fSBlbHNlIGlmIChmcmFjdGlvbiA8IDMpIHtcclxuXHRcdFx0XHRuaWNlRnJhY3Rpb24gPSAyO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDwgNykge1xyXG5cdFx0XHRcdG5pY2VGcmFjdGlvbiA9IDU7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bmljZUZyYWN0aW9uID0gMTA7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPD0gMS4wKSB7XHJcblx0XHRcdG5pY2VGcmFjdGlvbiA9IDE7XHJcblx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDw9IDIpIHtcclxuXHRcdFx0bmljZUZyYWN0aW9uID0gMjtcclxuXHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPD0gNSkge1xyXG5cdFx0XHRuaWNlRnJhY3Rpb24gPSA1O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmljZUZyYWN0aW9uID0gMTA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5pY2VGcmFjdGlvbiAqIE1hdGgucG93KDEwLCBleHBvbmVudCk7XHJcblx0fTtcclxuXHQvLyBSZXF1ZXN0IGFuaW1hdGlvbiBwb2x5ZmlsbCAtIGh0dHBzOi8vd3d3LnBhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cclxuXHRoZWxwZXJzJDEucmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbigpIHtcclxuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHRcdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuXHRcdFx0d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG5cdFx0XHR3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcblx0XHRcdHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcblx0XHRcdHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG5cdFx0XHRmdW5jdGlvbihjYWxsYmFjaykge1xyXG5cdFx0XHRcdHJldHVybiB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcclxuXHRcdFx0fTtcclxuXHR9KCkpO1xyXG5cdC8vIC0tIERPTSBtZXRob2RzXHJcblx0aGVscGVycyQxLmdldFJlbGF0aXZlUG9zaXRpb24gPSBmdW5jdGlvbihldnQsIGNoYXJ0KSB7XHJcblx0XHR2YXIgbW91c2VYLCBtb3VzZVk7XHJcblx0XHR2YXIgZSA9IGV2dC5vcmlnaW5hbEV2ZW50IHx8IGV2dDtcclxuXHRcdHZhciBjYW52YXMgPSBldnQudGFyZ2V0IHx8IGV2dC5zcmNFbGVtZW50O1xyXG5cdFx0dmFyIGJvdW5kaW5nUmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcblx0XHR2YXIgdG91Y2hlcyA9IGUudG91Y2hlcztcclxuXHRcdGlmICh0b3VjaGVzICYmIHRvdWNoZXMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRtb3VzZVggPSB0b3VjaGVzWzBdLmNsaWVudFg7XHJcblx0XHRcdG1vdXNlWSA9IHRvdWNoZXNbMF0uY2xpZW50WTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtb3VzZVggPSBlLmNsaWVudFg7XHJcblx0XHRcdG1vdXNlWSA9IGUuY2xpZW50WTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBTY2FsZSBtb3VzZSBjb29yZGluYXRlcyBpbnRvIGNhbnZhcyBjb29yZGluYXRlc1xyXG5cdFx0Ly8gYnkgZm9sbG93aW5nIHRoZSBwYXR0ZXJuIGxhaWQgb3V0IGJ5ICdqZXJyeWonIGluIHRoZSBjb21tZW50cyBvZlxyXG5cdFx0Ly8gaHR0cHM6Ly93d3cuaHRtbDVjYW52YXN0dXRvcmlhbHMuY29tL2FkdmFuY2VkL2h0bWw1LWNhbnZhcy1tb3VzZS1jb29yZGluYXRlcy9cclxuXHRcdHZhciBwYWRkaW5nTGVmdCA9IHBhcnNlRmxvYXQoaGVscGVycyQxLmdldFN0eWxlKGNhbnZhcywgJ3BhZGRpbmctbGVmdCcpKTtcclxuXHRcdHZhciBwYWRkaW5nVG9wID0gcGFyc2VGbG9hdChoZWxwZXJzJDEuZ2V0U3R5bGUoY2FudmFzLCAncGFkZGluZy10b3AnKSk7XHJcblx0XHR2YXIgcGFkZGluZ1JpZ2h0ID0gcGFyc2VGbG9hdChoZWxwZXJzJDEuZ2V0U3R5bGUoY2FudmFzLCAncGFkZGluZy1yaWdodCcpKTtcclxuXHRcdHZhciBwYWRkaW5nQm90dG9tID0gcGFyc2VGbG9hdChoZWxwZXJzJDEuZ2V0U3R5bGUoY2FudmFzLCAncGFkZGluZy1ib3R0b20nKSk7XHJcblx0XHR2YXIgd2lkdGggPSBib3VuZGluZ1JlY3QucmlnaHQgLSBib3VuZGluZ1JlY3QubGVmdCAtIHBhZGRpbmdMZWZ0IC0gcGFkZGluZ1JpZ2h0O1xyXG5cdFx0dmFyIGhlaWdodCA9IGJvdW5kaW5nUmVjdC5ib3R0b20gLSBib3VuZGluZ1JlY3QudG9wIC0gcGFkZGluZ1RvcCAtIHBhZGRpbmdCb3R0b207XHJcblxyXG5cdFx0Ly8gV2UgZGl2aWRlIGJ5IHRoZSBjdXJyZW50IGRldmljZSBwaXhlbCByYXRpbywgYmVjYXVzZSB0aGUgY2FudmFzIGlzIHNjYWxlZCB1cCBieSB0aGF0IGFtb3VudCBpbiBlYWNoIGRpcmVjdGlvbi4gSG93ZXZlclxyXG5cdFx0Ly8gdGhlIGJhY2tlbmQgbW9kZWwgaXMgaW4gdW5zY2FsZWQgY29vcmRpbmF0ZXMuIFNpbmNlIHdlIGFyZSBnb2luZyB0byBkZWFsIHdpdGggb3VyIG1vZGVsIGNvb3JkaW5hdGVzLCB3ZSBnbyBiYWNrIGhlcmVcclxuXHRcdG1vdXNlWCA9IE1hdGgucm91bmQoKG1vdXNlWCAtIGJvdW5kaW5nUmVjdC5sZWZ0IC0gcGFkZGluZ0xlZnQpIC8gKHdpZHRoKSAqIGNhbnZhcy53aWR0aCAvIGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKTtcclxuXHRcdG1vdXNlWSA9IE1hdGgucm91bmQoKG1vdXNlWSAtIGJvdW5kaW5nUmVjdC50b3AgLSBwYWRkaW5nVG9wKSAvIChoZWlnaHQpICogY2FudmFzLmhlaWdodCAvIGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKTtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiBtb3VzZVgsXHJcblx0XHRcdHk6IG1vdXNlWVxyXG5cdFx0fTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gUHJpdmF0ZSBoZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBtYXgtd2lkdGgvbWF4LWhlaWdodCB2YWx1ZXMgdGhhdCBtYXkgYmUgcGVyY2VudGFnZXMgaW50byBhIG51bWJlclxyXG5cdGZ1bmN0aW9uIHBhcnNlTWF4U3R5bGUoc3R5bGVWYWx1ZSwgbm9kZSwgcGFyZW50UHJvcGVydHkpIHtcclxuXHRcdHZhciB2YWx1ZUluUGl4ZWxzO1xyXG5cdFx0aWYgKHR5cGVvZiBzdHlsZVZhbHVlID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHR2YWx1ZUluUGl4ZWxzID0gcGFyc2VJbnQoc3R5bGVWYWx1ZSwgMTApO1xyXG5cclxuXHRcdFx0aWYgKHN0eWxlVmFsdWUuaW5kZXhPZignJScpICE9PSAtMSkge1xyXG5cdFx0XHRcdC8vIHBlcmNlbnRhZ2UgKiBzaXplIGluIGRpbWVuc2lvblxyXG5cdFx0XHRcdHZhbHVlSW5QaXhlbHMgPSB2YWx1ZUluUGl4ZWxzIC8gMTAwICogbm9kZS5wYXJlbnROb2RlW3BhcmVudFByb3BlcnR5XTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFsdWVJblBpeGVscyA9IHN0eWxlVmFsdWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlSW5QaXhlbHM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGlmIHRoZSBnaXZlbiB2YWx1ZSBjb250YWlucyBhbiBlZmZlY3RpdmUgY29uc3RyYWludC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIGlzQ29uc3RyYWluZWRWYWx1ZSh2YWx1ZSkge1xyXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09ICdub25lJztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIG1heCB3aWR0aCBvciBoZWlnaHQgb2YgdGhlIGdpdmVuIERPTSBub2RlIGluIGEgY3Jvc3MtYnJvd3NlciBjb21wYXRpYmxlIGZhc2hpb25cclxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21Ob2RlIC0gdGhlIG5vZGUgdG8gY2hlY2sgdGhlIGNvbnN0cmFpbnQgb25cclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWF4U3R5bGUgLSB0aGUgc3R5bGUgdGhhdCBkZWZpbmVzIHRoZSBtYXhpbXVtIGZvciB0aGUgZGlyZWN0aW9uIHdlIGFyZSB1c2luZyAoJ21heC13aWR0aCcgLyAnbWF4LWhlaWdodCcpXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHBlcmNlbnRhZ2VQcm9wZXJ0eSAtIHByb3BlcnR5IG9mIHBhcmVudCB0byB1c2Ugd2hlbiBjYWxjdWxhdGluZyB3aWR0aCBhcyBhIHBlcmNlbnRhZ2VcclxuXHQgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5uYXRoYW5hZWxqb25lcy5jb20vYmxvZy8yMDEzL3JlYWRpbmctbWF4LXdpZHRoLWNyb3NzLWJyb3dzZXJ9XHJcblx0ICovXHJcblx0ZnVuY3Rpb24gZ2V0Q29uc3RyYWludERpbWVuc2lvbihkb21Ob2RlLCBtYXhTdHlsZSwgcGVyY2VudGFnZVByb3BlcnR5KSB7XHJcblx0XHR2YXIgdmlldyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG5cdFx0dmFyIHBhcmVudE5vZGUgPSBoZWxwZXJzJDEuX2dldFBhcmVudE5vZGUoZG9tTm9kZSk7XHJcblx0XHR2YXIgY29uc3RyYWluZWROb2RlID0gdmlldy5nZXRDb21wdXRlZFN0eWxlKGRvbU5vZGUpW21heFN0eWxlXTtcclxuXHRcdHZhciBjb25zdHJhaW5lZENvbnRhaW5lciA9IHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnROb2RlKVttYXhTdHlsZV07XHJcblx0XHR2YXIgaGFzQ05vZGUgPSBpc0NvbnN0cmFpbmVkVmFsdWUoY29uc3RyYWluZWROb2RlKTtcclxuXHRcdHZhciBoYXNDQ29udGFpbmVyID0gaXNDb25zdHJhaW5lZFZhbHVlKGNvbnN0cmFpbmVkQ29udGFpbmVyKTtcclxuXHRcdHZhciBpbmZpbml0eSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuXHJcblx0XHRpZiAoaGFzQ05vZGUgfHwgaGFzQ0NvbnRhaW5lcikge1xyXG5cdFx0XHRyZXR1cm4gTWF0aC5taW4oXHJcblx0XHRcdFx0aGFzQ05vZGUgPyBwYXJzZU1heFN0eWxlKGNvbnN0cmFpbmVkTm9kZSwgZG9tTm9kZSwgcGVyY2VudGFnZVByb3BlcnR5KSA6IGluZmluaXR5LFxyXG5cdFx0XHRcdGhhc0NDb250YWluZXIgPyBwYXJzZU1heFN0eWxlKGNvbnN0cmFpbmVkQ29udGFpbmVyLCBwYXJlbnROb2RlLCBwZXJjZW50YWdlUHJvcGVydHkpIDogaW5maW5pdHkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAnbm9uZSc7XHJcblx0fVxyXG5cdC8vIHJldHVybnMgTnVtYmVyIG9yIHVuZGVmaW5lZCBpZiBubyBjb25zdHJhaW50XHJcblx0aGVscGVycyQxLmdldENvbnN0cmFpbnRXaWR0aCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcclxuXHRcdHJldHVybiBnZXRDb25zdHJhaW50RGltZW5zaW9uKGRvbU5vZGUsICdtYXgtd2lkdGgnLCAnY2xpZW50V2lkdGgnKTtcclxuXHR9O1xyXG5cdC8vIHJldHVybnMgTnVtYmVyIG9yIHVuZGVmaW5lZCBpZiBubyBjb25zdHJhaW50XHJcblx0aGVscGVycyQxLmdldENvbnN0cmFpbnRIZWlnaHQgPSBmdW5jdGlvbihkb21Ob2RlKSB7XHJcblx0XHRyZXR1cm4gZ2V0Q29uc3RyYWludERpbWVuc2lvbihkb21Ob2RlLCAnbWF4LWhlaWdodCcsICdjbGllbnRIZWlnaHQnKTtcclxuXHR9O1xyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcbiBcdCAqL1xyXG5cdGhlbHBlcnMkMS5fY2FsY3VsYXRlUGFkZGluZyA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgcGFkZGluZywgcGFyZW50RGltZW5zaW9uKSB7XHJcblx0XHRwYWRkaW5nID0gaGVscGVycyQxLmdldFN0eWxlKGNvbnRhaW5lciwgcGFkZGluZyk7XHJcblxyXG5cdFx0cmV0dXJuIHBhZGRpbmcuaW5kZXhPZignJScpID4gLTEgPyBwYXJlbnREaW1lbnNpb24gKiBwYXJzZUludChwYWRkaW5nLCAxMCkgLyAxMDAgOiBwYXJzZUludChwYWRkaW5nLCAxMCk7XHJcblx0fTtcclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGhlbHBlcnMkMS5fZ2V0UGFyZW50Tm9kZSA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcclxuXHRcdHZhciBwYXJlbnQgPSBkb21Ob2RlLnBhcmVudE5vZGU7XHJcblx0XHRpZiAocGFyZW50ICYmIHBhcmVudC50b1N0cmluZygpID09PSAnW29iamVjdCBTaGFkb3dSb290XScpIHtcclxuXHRcdFx0cGFyZW50ID0gcGFyZW50Lmhvc3Q7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcGFyZW50O1xyXG5cdH07XHJcblx0aGVscGVycyQxLmdldE1heGltdW1XaWR0aCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSBoZWxwZXJzJDEuX2dldFBhcmVudE5vZGUoZG9tTm9kZSk7XHJcblx0XHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0XHRyZXR1cm4gZG9tTm9kZS5jbGllbnRXaWR0aDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgY2xpZW50V2lkdGggPSBjb250YWluZXIuY2xpZW50V2lkdGg7XHJcblx0XHR2YXIgcGFkZGluZ0xlZnQgPSBoZWxwZXJzJDEuX2NhbGN1bGF0ZVBhZGRpbmcoY29udGFpbmVyLCAncGFkZGluZy1sZWZ0JywgY2xpZW50V2lkdGgpO1xyXG5cdFx0dmFyIHBhZGRpbmdSaWdodCA9IGhlbHBlcnMkMS5fY2FsY3VsYXRlUGFkZGluZyhjb250YWluZXIsICdwYWRkaW5nLXJpZ2h0JywgY2xpZW50V2lkdGgpO1xyXG5cclxuXHRcdHZhciB3ID0gY2xpZW50V2lkdGggLSBwYWRkaW5nTGVmdCAtIHBhZGRpbmdSaWdodDtcclxuXHRcdHZhciBjdyA9IGhlbHBlcnMkMS5nZXRDb25zdHJhaW50V2lkdGgoZG9tTm9kZSk7XHJcblx0XHRyZXR1cm4gaXNOYU4oY3cpID8gdyA6IE1hdGgubWluKHcsIGN3KTtcclxuXHR9O1xyXG5cdGhlbHBlcnMkMS5nZXRNYXhpbXVtSGVpZ2h0ID0gZnVuY3Rpb24oZG9tTm9kZSkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IGhlbHBlcnMkMS5fZ2V0UGFyZW50Tm9kZShkb21Ob2RlKTtcclxuXHRcdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRcdHJldHVybiBkb21Ob2RlLmNsaWVudEhlaWdodDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgY2xpZW50SGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcclxuXHRcdHZhciBwYWRkaW5nVG9wID0gaGVscGVycyQxLl9jYWxjdWxhdGVQYWRkaW5nKGNvbnRhaW5lciwgJ3BhZGRpbmctdG9wJywgY2xpZW50SGVpZ2h0KTtcclxuXHRcdHZhciBwYWRkaW5nQm90dG9tID0gaGVscGVycyQxLl9jYWxjdWxhdGVQYWRkaW5nKGNvbnRhaW5lciwgJ3BhZGRpbmctYm90dG9tJywgY2xpZW50SGVpZ2h0KTtcclxuXHJcblx0XHR2YXIgaCA9IGNsaWVudEhlaWdodCAtIHBhZGRpbmdUb3AgLSBwYWRkaW5nQm90dG9tO1xyXG5cdFx0dmFyIGNoID0gaGVscGVycyQxLmdldENvbnN0cmFpbnRIZWlnaHQoZG9tTm9kZSk7XHJcblx0XHRyZXR1cm4gaXNOYU4oY2gpID8gaCA6IE1hdGgubWluKGgsIGNoKTtcclxuXHR9O1xyXG5cdGhlbHBlcnMkMS5nZXRTdHlsZSA9IGZ1bmN0aW9uKGVsLCBwcm9wZXJ0eSkge1xyXG5cdFx0cmV0dXJuIGVsLmN1cnJlbnRTdHlsZSA/XHJcblx0XHRcdGVsLmN1cnJlbnRTdHlsZVtwcm9wZXJ0eV0gOlxyXG5cdFx0XHRkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcclxuXHR9O1xyXG5cdGhlbHBlcnMkMS5yZXRpbmFTY2FsZSA9IGZ1bmN0aW9uKGNoYXJ0LCBmb3JjZVJhdGlvKSB7XHJcblx0XHR2YXIgcGl4ZWxSYXRpbyA9IGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gZm9yY2VSYXRpbyB8fCAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8pIHx8IDE7XHJcblx0XHRpZiAocGl4ZWxSYXRpbyA9PT0gMSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcclxuXHRcdHZhciBoZWlnaHQgPSBjaGFydC5oZWlnaHQ7XHJcblx0XHR2YXIgd2lkdGggPSBjaGFydC53aWR0aDtcclxuXHJcblx0XHRjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcclxuXHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcclxuXHRcdGNoYXJ0LmN0eC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcclxuXHJcblx0XHQvLyBJZiBubyBzdHlsZSBoYXMgYmVlbiBzZXQgb24gdGhlIGNhbnZhcywgdGhlIHJlbmRlciBzaXplIGlzIHVzZWQgYXMgZGlzcGxheSBzaXplLFxyXG5cdFx0Ly8gbWFraW5nIHRoZSBjaGFydCB2aXN1YWxseSBiaWdnZXIsIHNvIGxldCdzIGVuZm9yY2UgaXQgdG8gdGhlIFwiY29ycmVjdFwiIHZhbHVlcy5cclxuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzU3NVxyXG5cdFx0aWYgKCFjYW52YXMuc3R5bGUuaGVpZ2h0ICYmICFjYW52YXMuc3R5bGUud2lkdGgpIHtcclxuXHRcdFx0Y2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XHJcblx0XHRcdGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcclxuXHRcdH1cclxuXHR9O1xyXG5cdC8vIC0tIENhbnZhcyBtZXRob2RzXHJcblx0aGVscGVycyQxLmZvbnRTdHJpbmcgPSBmdW5jdGlvbihwaXhlbFNpemUsIGZvbnRTdHlsZSwgZm9udEZhbWlseSkge1xyXG5cdFx0cmV0dXJuIGZvbnRTdHlsZSArICcgJyArIHBpeGVsU2l6ZSArICdweCAnICsgZm9udEZhbWlseTtcclxuXHR9O1xyXG5cdGhlbHBlcnMkMS5sb25nZXN0VGV4dCA9IGZ1bmN0aW9uKGN0eCwgZm9udCwgYXJyYXlPZlRoaW5ncywgY2FjaGUpIHtcclxuXHRcdGNhY2hlID0gY2FjaGUgfHwge307XHJcblx0XHR2YXIgZGF0YSA9IGNhY2hlLmRhdGEgPSBjYWNoZS5kYXRhIHx8IHt9O1xyXG5cdFx0dmFyIGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCB8fCBbXTtcclxuXHJcblx0XHRpZiAoY2FjaGUuZm9udCAhPT0gZm9udCkge1xyXG5cdFx0XHRkYXRhID0gY2FjaGUuZGF0YSA9IHt9O1xyXG5cdFx0XHRnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gW107XHJcblx0XHRcdGNhY2hlLmZvbnQgPSBmb250O1xyXG5cdFx0fVxyXG5cclxuXHRcdGN0eC5mb250ID0gZm9udDtcclxuXHRcdHZhciBsb25nZXN0ID0gMDtcclxuXHRcdHZhciBpbGVuID0gYXJyYXlPZlRoaW5ncy5sZW5ndGg7XHJcblx0XHR2YXIgaSwgaiwgamxlbiwgdGhpbmcsIG5lc3RlZFRoaW5nO1xyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47IGkrKykge1xyXG5cdFx0XHR0aGluZyA9IGFycmF5T2ZUaGluZ3NbaV07XHJcblxyXG5cdFx0XHQvLyBVbmRlZmluZWQgc3RyaW5ncyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcclxuXHRcdFx0aWYgKHRoaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpbmcgIT09IG51bGwgJiYgaGVscGVycyQxLmlzQXJyYXkodGhpbmcpICE9PSB0cnVlKSB7XHJcblx0XHRcdFx0bG9uZ2VzdCA9IGhlbHBlcnMkMS5tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCB0aGluZyk7XHJcblx0XHRcdH0gZWxzZSBpZiAoaGVscGVycyQxLmlzQXJyYXkodGhpbmcpKSB7XHJcblx0XHRcdFx0Ly8gaWYgaXQgaXMgYW4gYXJyYXkgbGV0cyBtZWFzdXJlIGVhY2ggZWxlbWVudFxyXG5cdFx0XHRcdC8vIHRvIGRvIG1heWJlIHNpbXBsaWZ5IHRoaXMgZnVuY3Rpb24gYSBiaXQgc28gd2UgY2FuIGRvIHRoaXMgbW9yZSByZWN1cnNpdmVseT9cclxuXHRcdFx0XHRmb3IgKGogPSAwLCBqbGVuID0gdGhpbmcubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XHJcblx0XHRcdFx0XHRuZXN0ZWRUaGluZyA9IHRoaW5nW2pdO1xyXG5cdFx0XHRcdFx0Ly8gVW5kZWZpbmVkIHN0cmluZ3MgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXHJcblx0XHRcdFx0XHRpZiAobmVzdGVkVGhpbmcgIT09IHVuZGVmaW5lZCAmJiBuZXN0ZWRUaGluZyAhPT0gbnVsbCAmJiAhaGVscGVycyQxLmlzQXJyYXkobmVzdGVkVGhpbmcpKSB7XHJcblx0XHRcdFx0XHRcdGxvbmdlc3QgPSBoZWxwZXJzJDEubWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgbmVzdGVkVGhpbmcpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XHJcblx0XHRpZiAoZ2NMZW4gPiBhcnJheU9mVGhpbmdzLmxlbmd0aCkge1xyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZ2NMZW47IGkrKykge1xyXG5cdFx0XHRcdGRlbGV0ZSBkYXRhW2djW2ldXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRnYy5zcGxpY2UoMCwgZ2NMZW4pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGxvbmdlc3Q7XHJcblx0fTtcclxuXHRoZWxwZXJzJDEubWVhc3VyZVRleHQgPSBmdW5jdGlvbihjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBzdHJpbmcpIHtcclxuXHRcdHZhciB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ107XHJcblx0XHRpZiAoIXRleHRXaWR0aCkge1xyXG5cdFx0XHR0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ10gPSBjdHgubWVhc3VyZVRleHQoc3RyaW5nKS53aWR0aDtcclxuXHRcdFx0Z2MucHVzaChzdHJpbmcpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRleHRXaWR0aCA+IGxvbmdlc3QpIHtcclxuXHRcdFx0bG9uZ2VzdCA9IHRleHRXaWR0aDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBsb25nZXN0O1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBkZXByZWNhdGVkXHJcblx0ICovXHJcblx0aGVscGVycyQxLm51bWJlck9mTGFiZWxMaW5lcyA9IGZ1bmN0aW9uKGFycmF5T2ZUaGluZ3MpIHtcclxuXHRcdHZhciBudW1iZXJPZkxpbmVzID0gMTtcclxuXHRcdGhlbHBlcnMkMS5lYWNoKGFycmF5T2ZUaGluZ3MsIGZ1bmN0aW9uKHRoaW5nKSB7XHJcblx0XHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheSh0aGluZykpIHtcclxuXHRcdFx0XHRpZiAodGhpbmcubGVuZ3RoID4gbnVtYmVyT2ZMaW5lcykge1xyXG5cdFx0XHRcdFx0bnVtYmVyT2ZMaW5lcyA9IHRoaW5nLmxlbmd0aDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIG51bWJlck9mTGluZXM7XHJcblx0fTtcclxuXHJcblx0aGVscGVycyQxLmNvbG9yID0gIWNoYXJ0anNDb2xvciA/XHJcblx0XHRmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKCdDb2xvci5qcyBub3QgZm91bmQhJyk7XHJcblx0XHRcdHJldHVybiB2YWx1ZTtcclxuXHRcdH0gOlxyXG5cdFx0ZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdFx0LyogZ2xvYmFsIENhbnZhc0dyYWRpZW50ICovXHJcblx0XHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIENhbnZhc0dyYWRpZW50KSB7XHJcblx0XHRcdFx0dmFsdWUgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBjaGFydGpzQ29sb3IodmFsdWUpO1xyXG5cdFx0fTtcclxuXHJcblx0aGVscGVycyQxLmdldEhvdmVyQ29sb3IgPSBmdW5jdGlvbihjb2xvclZhbHVlKSB7XHJcblx0XHQvKiBnbG9iYWwgQ2FudmFzUGF0dGVybiAqL1xyXG5cdFx0cmV0dXJuIChjb2xvclZhbHVlIGluc3RhbmNlb2YgQ2FudmFzUGF0dGVybiB8fCBjb2xvclZhbHVlIGluc3RhbmNlb2YgQ2FudmFzR3JhZGllbnQpID9cclxuXHRcdFx0Y29sb3JWYWx1ZSA6XHJcblx0XHRcdGhlbHBlcnMkMS5jb2xvcihjb2xvclZhbHVlKS5zYXR1cmF0ZSgwLjUpLmRhcmtlbigwLjEpLnJnYlN0cmluZygpO1xyXG5cdH07XHJcbn07XG5cbmZ1bmN0aW9uIGFic3RyYWN0KCkge1xyXG5cdHRocm93IG5ldyBFcnJvcihcclxuXHRcdCdUaGlzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQ6IGVpdGhlciBubyBhZGFwdGVyIGNhbiAnICtcclxuXHRcdCdiZSBmb3VuZCBvciBhbiBpbmNvbXBsZXRlIGludGVncmF0aW9uIHdhcyBwcm92aWRlZC4nXHJcblx0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERhdGUgYWRhcHRlciAoY3VycmVudCB1c2VkIGJ5IHRoZSB0aW1lIHNjYWxlKVxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0Ll9hZGFwdGVycy5fZGF0ZVxyXG4gKiBAbWVtYmVyb2YgQ2hhcnQuX2FkYXB0ZXJzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEN1cnJlbnRseSBzdXBwb3J0ZWQgdW5pdCBzdHJpbmcgdmFsdWVzLlxyXG4gKiBAdHlwZWRlZiB7KCdtaWxsaXNlY29uZCd8J3NlY29uZCd8J21pbnV0ZSd8J2hvdXInfCdkYXknfCd3ZWVrJ3wnbW9udGgnfCdxdWFydGVyJ3wneWVhcicpfVxyXG4gKiBAbWVtYmVyb2YgQ2hhcnQuX2FkYXB0ZXJzLl9kYXRlXHJcbiAqIEBuYW1lIFVuaXRcclxuICovXHJcblxyXG4vKipcclxuICogQGNsYXNzXHJcbiAqL1xyXG5mdW5jdGlvbiBEYXRlQWRhcHRlcihvcHRpb25zKSB7XHJcblx0dGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxufVxyXG5cclxuaGVscGVycyQxLmV4dGVuZChEYXRlQWRhcHRlci5wcm90b3R5cGUsIC8qKiBAbGVuZHMgRGF0ZUFkYXB0ZXIgKi8ge1xyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBtYXAgb2YgdGltZSBmb3JtYXRzIGZvciB0aGUgc3VwcG9ydGVkIGZvcm1hdHRpbmcgdW5pdHMgZGVmaW5lZFxyXG5cdCAqIGluIFVuaXQgYXMgd2VsbCBhcyAnZGF0ZXRpbWUnIHJlcHJlc2VudGluZyBhIGRldGFpbGVkIGRhdGUvdGltZSBzdHJpbmcuXHJcblx0ICogQHJldHVybnMge3tzdHJpbmc6IHN0cmluZ319XHJcblx0ICovXHJcblx0Zm9ybWF0czogYWJzdHJhY3QsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFBhcnNlcyB0aGUgZ2l2ZW4gYHZhbHVlYCBhbmQgcmV0dXJuIHRoZSBhc3NvY2lhdGVkIHRpbWVzdGFtcC5cclxuXHQgKiBAcGFyYW0ge2FueX0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gcGFyc2UgKHVzdWFsbHkgY29tZXMgZnJvbSB0aGUgZGF0YSlcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW2Zvcm1hdF0gLSB0aGUgZXhwZWN0ZWQgZGF0YSBmb3JtYXRcclxuXHQgKiBAcmV0dXJucyB7KG51bWJlcnxudWxsKX1cclxuXHQgKiBAZnVuY3Rpb25cclxuXHQgKi9cclxuXHRwYXJzZTogYWJzdHJhY3QsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGZvcm1hdHRlZCBkYXRlIGluIHRoZSBzcGVjaWZpZWQgYGZvcm1hdGAgZm9yIGEgZ2l2ZW4gYHRpbWVzdGFtcGAuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcCAtIHRoZSB0aW1lc3RhbXAgdG8gZm9ybWF0XHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIHRoZSBkYXRlL3RpbWUgdG9rZW5cclxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XHJcblx0ICogQGZ1bmN0aW9uXHJcblx0ICovXHJcblx0Zm9ybWF0OiBhYnN0cmFjdCxcclxuXHJcblx0LyoqXHJcblx0ICogQWRkcyB0aGUgc3BlY2lmaWVkIGBhbW91bnRgIG9mIGB1bml0YCB0byB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCB0byBhZGRcclxuXHQgKiBAcGFyYW0ge1VuaXR9IHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcclxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XHJcblx0ICogQGZ1bmN0aW9uXHJcblx0ICovXHJcblx0YWRkOiBhYnN0cmFjdCxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGB1bml0YCBiZXR3ZWVuIHRoZSBnaXZlbiB0aW1lc3RhbXBzLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSB0aGUgaW5wdXQgdGltZXN0YW1wIChyZWZlcmVuY2UpXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pbiAtIHRoZSB0aW1lc3RhbXAgdG8gc3Vic3RyYWN0XHJcblx0ICogQHBhcmFtIHtVbml0fSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXHJcblx0ICogQHJldHVybiB7bnVtYmVyfVxyXG5cdCAqIEBmdW5jdGlvblxyXG5cdCAqL1xyXG5cdGRpZmY6IGFic3RyYWN0LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHN0YXJ0IG9mIGB1bml0YCBmb3IgdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXHJcblx0ICogQHBhcmFtIHtVbml0fSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3ZWVrZGF5XSAtIHRoZSBJU08gZGF5IG9mIHRoZSB3ZWVrIHdpdGggMSBiZWluZyBNb25kYXlcclxuXHQgKiBhbmQgNyBiZWluZyBTdW5kYXkgKG9ubHkgbmVlZGVkIGlmIHBhcmFtICp1bml0KiBpcyBgaXNvV2Vla2ApLlxyXG5cdCAqIEBmdW5jdGlvblxyXG5cdCAqL1xyXG5cdHN0YXJ0T2Y6IGFic3RyYWN0LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGVuZCBvZiBgdW5pdGAgZm9yIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxyXG5cdCAqIEBwYXJhbSB7VW5pdH0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xyXG5cdCAqIEBmdW5jdGlvblxyXG5cdCAqL1xyXG5cdGVuZE9mOiBhYnN0cmFjdCxcclxuXHJcblx0Ly8gREVQUkVDQVRJT05TXHJcblxyXG5cdC8qKlxyXG5cdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGZvciBzY2FsZS5nZXRWYWx1ZUZvclBpeGVsKCksXHJcblx0ICogdGhpcyBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4gb25seSBieSB0aGUgbW9tZW50IGFkYXB0ZXIuXHJcblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxyXG5cdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHRyZXR1cm4gdmFsdWU7XHJcblx0fVxyXG59KTtcclxuXHJcbkRhdGVBZGFwdGVyLm92ZXJyaWRlID0gZnVuY3Rpb24obWVtYmVycykge1xyXG5cdGhlbHBlcnMkMS5leHRlbmQoRGF0ZUFkYXB0ZXIucHJvdG90eXBlLCBtZW1iZXJzKTtcclxufTtcclxuXHJcbnZhciBfZGF0ZSA9IERhdGVBZGFwdGVyO1xuXG52YXIgY29yZV9hZGFwdGVycyA9IHtcblx0X2RhdGU6IF9kYXRlXG59O1xuXG4vKipcclxuICogTmFtZXNwYWNlIHRvIGhvbGQgc3RhdGljIHRpY2sgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcclxuICogQG5hbWVzcGFjZSBDaGFydC5UaWNrc1xyXG4gKi9cclxudmFyIGNvcmVfdGlja3MgPSB7XHJcblx0LyoqXHJcblx0ICogTmFtZXNwYWNlIHRvIGhvbGQgZm9ybWF0dGVycyBmb3IgZGlmZmVyZW50IHR5cGVzIG9mIHRpY2tzXHJcblx0ICogQG5hbWVzcGFjZSBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzXHJcblx0ICovXHJcblx0Zm9ybWF0dGVyczoge1xyXG5cdFx0LyoqXHJcblx0XHQgKiBGb3JtYXR0ZXIgZm9yIHZhbHVlIGxhYmVsc1xyXG5cdFx0ICogQG1ldGhvZCBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzLnZhbHVlc1xyXG5cdFx0ICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBkaXNwbGF5XHJcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd8c3RyaW5nW119IHRoZSBsYWJlbCB0byBkaXNwbGF5XHJcblx0XHQgKi9cclxuXHRcdHZhbHVlczogZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdFx0cmV0dXJuIGhlbHBlcnMkMS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogJycgKyB2YWx1ZTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBGb3JtYXR0ZXIgZm9yIGxpbmVhciBudW1lcmljIHRpY2tzXHJcblx0XHQgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMubGluZWFyXHJcblx0XHQgKiBAcGFyYW0gdGlja1ZhbHVlIHtudW1iZXJ9IHRoZSB2YWx1ZSB0byBiZSBmb3JtYXR0ZWRcclxuXHRcdCAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSB0aGUgcG9zaXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXIgaW4gdGhlIHRpY2tzIGFycmF5XHJcblx0XHQgKiBAcGFyYW0gdGlja3Mge251bWJlcltdfSB0aGUgbGlzdCBvZiB0aWNrcyBiZWluZyBjb252ZXJ0ZWRcclxuXHRcdCAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyXHJcblx0XHQgKi9cclxuXHRcdGxpbmVhcjogZnVuY3Rpb24odGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcclxuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBsb3RzIG9mIHRpY2tzLCBkb24ndCB1c2UgdGhlIG9uZXNcclxuXHRcdFx0dmFyIGRlbHRhID0gdGlja3MubGVuZ3RoID4gMyA/IHRpY2tzWzJdIC0gdGlja3NbMV0gOiB0aWNrc1sxXSAtIHRpY2tzWzBdO1xyXG5cclxuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIG51bWJlciBsaWtlIDIuNSBhcyB0aGUgZGVsdGEsIGZpZ3VyZSBvdXQgaG93IG1hbnkgZGVjaW1hbCBwbGFjZXMgd2UgbmVlZFxyXG5cdFx0XHRpZiAoTWF0aC5hYnMoZGVsdGEpID4gMSkge1xyXG5cdFx0XHRcdGlmICh0aWNrVmFsdWUgIT09IE1hdGguZmxvb3IodGlja1ZhbHVlKSkge1xyXG5cdFx0XHRcdFx0Ly8gbm90IGFuIGludGVnZXJcclxuXHRcdFx0XHRcdGRlbHRhID0gdGlja1ZhbHVlIC0gTWF0aC5mbG9vcih0aWNrVmFsdWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGxvZ0RlbHRhID0gaGVscGVycyQxLmxvZzEwKE1hdGguYWJzKGRlbHRhKSk7XHJcblx0XHRcdHZhciB0aWNrU3RyaW5nID0gJyc7XHJcblxyXG5cdFx0XHRpZiAodGlja1ZhbHVlICE9PSAwKSB7XHJcblx0XHRcdFx0dmFyIG1heFRpY2sgPSBNYXRoLm1heChNYXRoLmFicyh0aWNrc1swXSksIE1hdGguYWJzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdKSk7XHJcblx0XHRcdFx0aWYgKG1heFRpY2sgPCAxZS00KSB7IC8vIGFsbCB0aWNrcyBhcmUgc21hbGwgbnVtYmVyczsgdXNlIHNjaWVudGlmaWMgbm90YXRpb25cclxuXHRcdFx0XHRcdHZhciBsb2dUaWNrID0gaGVscGVycyQxLmxvZzEwKE1hdGguYWJzKHRpY2tWYWx1ZSkpO1xyXG5cdFx0XHRcdFx0dmFyIG51bUV4cG9uZW50aWFsID0gTWF0aC5mbG9vcihsb2dUaWNrKSAtIE1hdGguZmxvb3IobG9nRGVsdGEpO1xyXG5cdFx0XHRcdFx0bnVtRXhwb25lbnRpYWwgPSBNYXRoLm1heChNYXRoLm1pbihudW1FeHBvbmVudGlhbCwgMjApLCAwKTtcclxuXHRcdFx0XHRcdHRpY2tTdHJpbmcgPSB0aWNrVmFsdWUudG9FeHBvbmVudGlhbChudW1FeHBvbmVudGlhbCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBudW1EZWNpbWFsID0gLTEgKiBNYXRoLmZsb29yKGxvZ0RlbHRhKTtcclxuXHRcdFx0XHRcdG51bURlY2ltYWwgPSBNYXRoLm1heChNYXRoLm1pbihudW1EZWNpbWFsLCAyMCksIDApOyAvLyB0b0ZpeGVkIGhhcyBhIG1heCBvZiAyMCBkZWNpbWFsIHBsYWNlc1xyXG5cdFx0XHRcdFx0dGlja1N0cmluZyA9IHRpY2tWYWx1ZS50b0ZpeGVkKG51bURlY2ltYWwpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aWNrU3RyaW5nID0gJzAnOyAvLyBuZXZlciBzaG93IGRlY2ltYWwgcGxhY2VzIGZvciAwXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aWNrU3RyaW5nO1xyXG5cdFx0fSxcclxuXHJcblx0XHRsb2dhcml0aG1pYzogZnVuY3Rpb24odGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcclxuXHRcdFx0dmFyIHJlbWFpbiA9IHRpY2tWYWx1ZSAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAodGlja1ZhbHVlKSkpKTtcclxuXHJcblx0XHRcdGlmICh0aWNrVmFsdWUgPT09IDApIHtcclxuXHRcdFx0XHRyZXR1cm4gJzAnO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHJlbWFpbiA9PT0gMSB8fCByZW1haW4gPT09IDIgfHwgcmVtYWluID09PSA1IHx8IGluZGV4ID09PSAwIHx8IGluZGV4ID09PSB0aWNrcy5sZW5ndGggLSAxKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRpY2tWYWx1ZS50b0V4cG9uZW50aWFsKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuICcnO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcblxudmFyIGlzQXJyYXkgPSBoZWxwZXJzJDEuaXNBcnJheTtcclxudmFyIGlzTnVsbE9yVW5kZWYgPSBoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZjtcclxudmFyIHZhbHVlT3JEZWZhdWx0JGEgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XHJcbnZhciB2YWx1ZUF0SW5kZXhPckRlZmF1bHQgPSBoZWxwZXJzJDEudmFsdWVBdEluZGV4T3JEZWZhdWx0O1xyXG5cclxuY29yZV9kZWZhdWx0cy5fc2V0KCdzY2FsZScsIHtcclxuXHRkaXNwbGF5OiB0cnVlLFxyXG5cdHBvc2l0aW9uOiAnbGVmdCcsXHJcblx0b2Zmc2V0OiBmYWxzZSxcclxuXHJcblx0Ly8gZ3JpZCBsaW5lIHNldHRpbmdzXHJcblx0Z3JpZExpbmVzOiB7XHJcblx0XHRkaXNwbGF5OiB0cnVlLFxyXG5cdFx0Y29sb3I6ICdyZ2JhKDAsMCwwLDAuMSknLFxyXG5cdFx0bGluZVdpZHRoOiAxLFxyXG5cdFx0ZHJhd0JvcmRlcjogdHJ1ZSxcclxuXHRcdGRyYXdPbkNoYXJ0QXJlYTogdHJ1ZSxcclxuXHRcdGRyYXdUaWNrczogdHJ1ZSxcclxuXHRcdHRpY2tNYXJrTGVuZ3RoOiAxMCxcclxuXHRcdHplcm9MaW5lV2lkdGg6IDEsXHJcblx0XHR6ZXJvTGluZUNvbG9yOiAncmdiYSgwLDAsMCwwLjI1KScsXHJcblx0XHR6ZXJvTGluZUJvcmRlckRhc2g6IFtdLFxyXG5cdFx0emVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0OiAwLjAsXHJcblx0XHRvZmZzZXRHcmlkTGluZXM6IGZhbHNlLFxyXG5cdFx0Ym9yZGVyRGFzaDogW10sXHJcblx0XHRib3JkZXJEYXNoT2Zmc2V0OiAwLjBcclxuXHR9LFxyXG5cclxuXHQvLyBzY2FsZSBsYWJlbFxyXG5cdHNjYWxlTGFiZWw6IHtcclxuXHRcdC8vIGRpc3BsYXkgcHJvcGVydHlcclxuXHRcdGRpc3BsYXk6IGZhbHNlLFxyXG5cclxuXHRcdC8vIGFjdHVhbCBsYWJlbFxyXG5cdFx0bGFiZWxTdHJpbmc6ICcnLFxyXG5cclxuXHRcdC8vIHRvcC9ib3R0b20gcGFkZGluZ1xyXG5cdFx0cGFkZGluZzoge1xyXG5cdFx0XHR0b3A6IDQsXHJcblx0XHRcdGJvdHRvbTogNFxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIGxhYmVsIHNldHRpbmdzXHJcblx0dGlja3M6IHtcclxuXHRcdGJlZ2luQXRaZXJvOiBmYWxzZSxcclxuXHRcdG1pblJvdGF0aW9uOiAwLFxyXG5cdFx0bWF4Um90YXRpb246IDUwLFxyXG5cdFx0bWlycm9yOiBmYWxzZSxcclxuXHRcdHBhZGRpbmc6IDAsXHJcblx0XHRyZXZlcnNlOiBmYWxzZSxcclxuXHRcdGRpc3BsYXk6IHRydWUsXHJcblx0XHRhdXRvU2tpcDogdHJ1ZSxcclxuXHRcdGF1dG9Ta2lwUGFkZGluZzogMCxcclxuXHRcdGxhYmVsT2Zmc2V0OiAwLFxyXG5cdFx0Ly8gV2UgcGFzcyB0aHJvdWdoIGFycmF5cyB0byBiZSByZW5kZXJlZCBhcyBtdWx0aWxpbmUgbGFiZWxzLCB3ZSBjb252ZXJ0IE90aGVycyB0byBzdHJpbmdzIGhlcmUuXHJcblx0XHRjYWxsYmFjazogY29yZV90aWNrcy5mb3JtYXR0ZXJzLnZhbHVlcyxcclxuXHRcdG1pbm9yOiB7fSxcclxuXHRcdG1ham9yOiB7fVxyXG5cdH1cclxufSk7XHJcblxyXG4vKiogUmV0dXJucyBhIG5ldyBhcnJheSBjb250YWluaW5nIG51bUl0ZW1zIGZyb20gYXJyICovXHJcbmZ1bmN0aW9uIHNhbXBsZShhcnIsIG51bUl0ZW1zKSB7XHJcblx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdHZhciBpbmNyZW1lbnQgPSBhcnIubGVuZ3RoIC8gbnVtSXRlbXM7XHJcblx0dmFyIGkgPSAwO1xyXG5cdHZhciBsZW4gPSBhcnIubGVuZ3RoO1xyXG5cclxuXHRmb3IgKDsgaSA8IGxlbjsgaSArPSBpbmNyZW1lbnQpIHtcclxuXHRcdHJlc3VsdC5wdXNoKGFycltNYXRoLmZsb29yKGkpXSk7XHJcblx0fVxyXG5cdHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFBpeGVsRm9yR3JpZExpbmUoc2NhbGUsIGluZGV4LCBvZmZzZXRHcmlkTGluZXMpIHtcclxuXHR2YXIgbGVuZ3RoID0gc2NhbGUuZ2V0VGlja3MoKS5sZW5ndGg7XHJcblx0dmFyIHZhbGlkSW5kZXggPSBNYXRoLm1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XHJcblx0dmFyIGxpbmVWYWx1ZSA9IHNjYWxlLmdldFBpeGVsRm9yVGljayh2YWxpZEluZGV4KTtcclxuXHR2YXIgc3RhcnQgPSBzY2FsZS5fc3RhcnRQaXhlbDtcclxuXHR2YXIgZW5kID0gc2NhbGUuX2VuZFBpeGVsO1xyXG5cdHZhciBlcHNpbG9uID0gMWUtNjsgLy8gMWUtNiBpcyBtYXJnaW4gaW4gcGl4ZWxzIGZvciBhY2N1bXVsYXRlZCBlcnJvci5cclxuXHR2YXIgb2Zmc2V0O1xyXG5cclxuXHRpZiAob2Zmc2V0R3JpZExpbmVzKSB7XHJcblx0XHRpZiAobGVuZ3RoID09PSAxKSB7XHJcblx0XHRcdG9mZnNldCA9IE1hdGgubWF4KGxpbmVWYWx1ZSAtIHN0YXJ0LCBlbmQgLSBsaW5lVmFsdWUpO1xyXG5cdFx0fSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xyXG5cdFx0XHRvZmZzZXQgPSAoc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKDEpIC0gbGluZVZhbHVlKSAvIDI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvZmZzZXQgPSAobGluZVZhbHVlIC0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXggLSAxKSkgLyAyO1xyXG5cdFx0fVxyXG5cdFx0bGluZVZhbHVlICs9IHZhbGlkSW5kZXggPCBpbmRleCA/IG9mZnNldCA6IC1vZmZzZXQ7XHJcblxyXG5cdFx0Ly8gUmV0dXJuIHVuZGVmaW5lZCBpZiB0aGUgcGl4ZWwgaXMgb3V0IG9mIHRoZSByYW5nZVxyXG5cdFx0aWYgKGxpbmVWYWx1ZSA8IHN0YXJ0IC0gZXBzaWxvbiB8fCBsaW5lVmFsdWUgPiBlbmQgKyBlcHNpbG9uKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGxpbmVWYWx1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpIHtcclxuXHRoZWxwZXJzJDEuZWFjaChjYWNoZXMsIGZ1bmN0aW9uKGNhY2hlKSB7XHJcblx0XHR2YXIgZ2MgPSBjYWNoZS5nYztcclxuXHRcdHZhciBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XHJcblx0XHR2YXIgaTtcclxuXHRcdGlmIChnY0xlbiA+IGxlbmd0aCkge1xyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZ2NMZW47ICsraSkge1xyXG5cdFx0XHRcdGRlbGV0ZSBjYWNoZS5kYXRhW2djW2ldXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRnYy5zcGxpY2UoMCwgZ2NMZW4pO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB7d2lkdGgsIGhlaWdodCwgb2Zmc2V0fSBvYmplY3RzIGZvciB0aGUgZmlyc3QsIGxhc3QsIHdpZGVzdCwgaGlnaGVzdCB0aWNrXHJcbiAqIGxhYmVscyB3aGVyZSBvZmZzZXQgaW5kaWNhdGVzIHRoZSBhbmNob3IgcG9pbnQgb2Zmc2V0IGZyb20gdGhlIHRvcCBpbiBwaXhlbHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wdXRlTGFiZWxTaXplcyhjdHgsIHRpY2tGb250cywgdGlja3MsIGNhY2hlcykge1xyXG5cdHZhciBsZW5ndGggPSB0aWNrcy5sZW5ndGg7XHJcblx0dmFyIHdpZHRocyA9IFtdO1xyXG5cdHZhciBoZWlnaHRzID0gW107XHJcblx0dmFyIG9mZnNldHMgPSBbXTtcclxuXHR2YXIgd2lkZXN0TGFiZWxTaXplID0gMDtcclxuXHR2YXIgaGlnaGVzdExhYmVsU2l6ZSA9IDA7XHJcblx0dmFyIGksIGosIGpsZW4sIGxhYmVsLCB0aWNrRm9udCwgZm9udFN0cmluZywgY2FjaGUsIGxpbmVIZWlnaHQsIHdpZHRoLCBoZWlnaHQsIG5lc3RlZExhYmVsLCB3aWRlc3QsIGhpZ2hlc3Q7XHJcblxyXG5cdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG5cdFx0bGFiZWwgPSB0aWNrc1tpXS5sYWJlbDtcclxuXHRcdHRpY2tGb250ID0gdGlja3NbaV0ubWFqb3IgPyB0aWNrRm9udHMubWFqb3IgOiB0aWNrRm9udHMubWlub3I7XHJcblx0XHRjdHguZm9udCA9IGZvbnRTdHJpbmcgPSB0aWNrRm9udC5zdHJpbmc7XHJcblx0XHRjYWNoZSA9IGNhY2hlc1tmb250U3RyaW5nXSA9IGNhY2hlc1tmb250U3RyaW5nXSB8fCB7ZGF0YToge30sIGdjOiBbXX07XHJcblx0XHRsaW5lSGVpZ2h0ID0gdGlja0ZvbnQubGluZUhlaWdodDtcclxuXHRcdHdpZHRoID0gaGVpZ2h0ID0gMDtcclxuXHRcdC8vIFVuZGVmaW5lZCBsYWJlbHMgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXHJcblx0XHRpZiAoIWlzTnVsbE9yVW5kZWYobGFiZWwpICYmICFpc0FycmF5KGxhYmVsKSkge1xyXG5cdFx0XHR3aWR0aCA9IGhlbHBlcnMkMS5tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbGFiZWwpO1xyXG5cdFx0XHRoZWlnaHQgPSBsaW5lSGVpZ2h0O1xyXG5cdFx0fSBlbHNlIGlmIChpc0FycmF5KGxhYmVsKSkge1xyXG5cdFx0XHQvLyBpZiBpdCBpcyBhbiBhcnJheSBsZXQncyBtZWFzdXJlIGVhY2ggZWxlbWVudFxyXG5cdFx0XHRmb3IgKGogPSAwLCBqbGVuID0gbGFiZWwubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XHJcblx0XHRcdFx0bmVzdGVkTGFiZWwgPSBsYWJlbFtqXTtcclxuXHRcdFx0XHQvLyBVbmRlZmluZWQgbGFiZWxzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxyXG5cdFx0XHRcdGlmICghaXNOdWxsT3JVbmRlZihuZXN0ZWRMYWJlbCkgJiYgIWlzQXJyYXkobmVzdGVkTGFiZWwpKSB7XHJcblx0XHRcdFx0XHR3aWR0aCA9IGhlbHBlcnMkMS5tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbmVzdGVkTGFiZWwpO1xyXG5cdFx0XHRcdFx0aGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHR3aWR0aHMucHVzaCh3aWR0aCk7XHJcblx0XHRoZWlnaHRzLnB1c2goaGVpZ2h0KTtcclxuXHRcdG9mZnNldHMucHVzaChsaW5lSGVpZ2h0IC8gMik7XHJcblx0XHR3aWRlc3RMYWJlbFNpemUgPSBNYXRoLm1heCh3aWR0aCwgd2lkZXN0TGFiZWxTaXplKTtcclxuXHRcdGhpZ2hlc3RMYWJlbFNpemUgPSBNYXRoLm1heChoZWlnaHQsIGhpZ2hlc3RMYWJlbFNpemUpO1xyXG5cdH1cclxuXHRnYXJiYWdlQ29sbGVjdChjYWNoZXMsIGxlbmd0aCk7XHJcblxyXG5cdHdpZGVzdCA9IHdpZHRocy5pbmRleE9mKHdpZGVzdExhYmVsU2l6ZSk7XHJcblx0aGlnaGVzdCA9IGhlaWdodHMuaW5kZXhPZihoaWdoZXN0TGFiZWxTaXplKTtcclxuXHJcblx0ZnVuY3Rpb24gdmFsdWVBdChpZHgpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHdpZHRoOiB3aWR0aHNbaWR4XSB8fCAwLFxyXG5cdFx0XHRoZWlnaHQ6IGhlaWdodHNbaWR4XSB8fCAwLFxyXG5cdFx0XHRvZmZzZXQ6IG9mZnNldHNbaWR4XSB8fCAwXHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdGZpcnN0OiB2YWx1ZUF0KDApLFxyXG5cdFx0bGFzdDogdmFsdWVBdChsZW5ndGggLSAxKSxcclxuXHRcdHdpZGVzdDogdmFsdWVBdCh3aWRlc3QpLFxyXG5cdFx0aGlnaGVzdDogdmFsdWVBdChoaWdoZXN0KVxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gb3B0aW9ucy5kcmF3VGlja3MgPyBvcHRpb25zLnRpY2tNYXJrTGVuZ3RoIDogMDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0U2NhbGVMYWJlbEhlaWdodChvcHRpb25zKSB7XHJcblx0dmFyIGZvbnQsIHBhZGRpbmc7XHJcblxyXG5cdGlmICghb3B0aW9ucy5kaXNwbGF5KSB7XHJcblx0XHRyZXR1cm4gMDtcclxuXHR9XHJcblxyXG5cdGZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KG9wdGlvbnMpO1xyXG5cdHBhZGRpbmcgPSBoZWxwZXJzJDEub3B0aW9ucy50b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcclxuXHJcblx0cmV0dXJuIGZvbnQubGluZUhlaWdodCArIHBhZGRpbmcuaGVpZ2h0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZUZvbnRPcHRpb25zKG9wdGlvbnMsIG5lc3RlZE9wdHMpIHtcclxuXHRyZXR1cm4gaGVscGVycyQxLmV4dGVuZChoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KHtcclxuXHRcdGZvbnRGYW1pbHk6IHZhbHVlT3JEZWZhdWx0JGEobmVzdGVkT3B0cy5mb250RmFtaWx5LCBvcHRpb25zLmZvbnRGYW1pbHkpLFxyXG5cdFx0Zm9udFNpemU6IHZhbHVlT3JEZWZhdWx0JGEobmVzdGVkT3B0cy5mb250U2l6ZSwgb3B0aW9ucy5mb250U2l6ZSksXHJcblx0XHRmb250U3R5bGU6IHZhbHVlT3JEZWZhdWx0JGEobmVzdGVkT3B0cy5mb250U3R5bGUsIG9wdGlvbnMuZm9udFN0eWxlKSxcclxuXHRcdGxpbmVIZWlnaHQ6IHZhbHVlT3JEZWZhdWx0JGEobmVzdGVkT3B0cy5saW5lSGVpZ2h0LCBvcHRpb25zLmxpbmVIZWlnaHQpXHJcblx0fSksIHtcclxuXHRcdGNvbG9yOiBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlKFtuZXN0ZWRPcHRzLmZvbnRDb2xvciwgb3B0aW9ucy5mb250Q29sb3IsIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250Q29sb3JdKVxyXG5cdH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZVRpY2tGb250T3B0aW9ucyhvcHRpb25zKSB7XHJcblx0dmFyIG1pbm9yID0gcGFyc2VGb250T3B0aW9ucyhvcHRpb25zLCBvcHRpb25zLm1pbm9yKTtcclxuXHR2YXIgbWFqb3IgPSBvcHRpb25zLm1ham9yLmVuYWJsZWQgPyBwYXJzZUZvbnRPcHRpb25zKG9wdGlvbnMsIG9wdGlvbnMubWFqb3IpIDogbWlub3I7XHJcblxyXG5cdHJldHVybiB7bWlub3I6IG1pbm9yLCBtYWpvcjogbWFqb3J9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBub25Ta2lwcGVkKHRpY2tzVG9GaWx0ZXIpIHtcclxuXHR2YXIgZmlsdGVyZWQgPSBbXTtcclxuXHR2YXIgaXRlbSwgaW5kZXgsIGxlbjtcclxuXHRmb3IgKGluZGV4ID0gMCwgbGVuID0gdGlja3NUb0ZpbHRlci5sZW5ndGg7IGluZGV4IDwgbGVuOyArK2luZGV4KSB7XHJcblx0XHRpdGVtID0gdGlja3NUb0ZpbHRlcltpbmRleF07XHJcblx0XHRpZiAodHlwZW9mIGl0ZW0uX2luZGV4ICE9PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRmaWx0ZXJlZC5wdXNoKGl0ZW0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZmlsdGVyZWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEV2ZW5TcGFjaW5nKGFycikge1xyXG5cdHZhciBsZW4gPSBhcnIubGVuZ3RoO1xyXG5cdHZhciBpLCBkaWZmO1xyXG5cclxuXHRpZiAobGVuIDwgMikge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Zm9yIChkaWZmID0gYXJyWzBdLCBpID0gMTsgaSA8IGxlbjsgKytpKSB7XHJcblx0XHRpZiAoYXJyW2ldIC0gYXJyW2kgLSAxXSAhPT0gZGlmZikge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBkaWZmO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIGF4aXNMZW5ndGgsIHRpY2tzTGltaXQpIHtcclxuXHR2YXIgZXZlbk1ham9yU3BhY2luZyA9IGdldEV2ZW5TcGFjaW5nKG1ham9ySW5kaWNlcyk7XHJcblx0dmFyIHNwYWNpbmcgPSAodGlja3MubGVuZ3RoIC0gMSkgLyB0aWNrc0xpbWl0O1xyXG5cdHZhciBmYWN0b3JzLCBmYWN0b3IsIGksIGlsZW47XHJcblxyXG5cdC8vIElmIHRoZSBtYWpvciB0aWNrcyBhcmUgZXZlbmx5IHNwYWNlZCBhcGFydCwgcGxhY2UgdGhlIG1pbm9yIHRpY2tzXHJcblx0Ly8gc28gdGhhdCB0aGV5IGRpdmlkZSB0aGUgbWFqb3IgdGlja3MgaW50byBldmVuIGNodW5rc1xyXG5cdGlmICghZXZlbk1ham9yU3BhY2luZykge1xyXG5cdFx0cmV0dXJuIE1hdGgubWF4KHNwYWNpbmcsIDEpO1xyXG5cdH1cclxuXHJcblx0ZmFjdG9ycyA9IGhlbHBlcnMkMS5tYXRoLl9mYWN0b3JpemUoZXZlbk1ham9yU3BhY2luZyk7XHJcblx0Zm9yIChpID0gMCwgaWxlbiA9IGZhY3RvcnMubGVuZ3RoIC0gMTsgaSA8IGlsZW47IGkrKykge1xyXG5cdFx0ZmFjdG9yID0gZmFjdG9yc1tpXTtcclxuXHRcdGlmIChmYWN0b3IgPiBzcGFjaW5nKSB7XHJcblx0XHRcdHJldHVybiBmYWN0b3I7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSB7XHJcblx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdHZhciBpLCBpbGVuO1xyXG5cdGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcclxuXHRcdGlmICh0aWNrc1tpXS5tYWpvcikge1xyXG5cdFx0XHRyZXN1bHQucHVzaChpKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZnVuY3Rpb24gc2tpcE1ham9ycyh0aWNrcywgbWFqb3JJbmRpY2VzLCBzcGFjaW5nKSB7XHJcblx0dmFyIGNvdW50ID0gMDtcclxuXHR2YXIgbmV4dCA9IG1ham9ySW5kaWNlc1swXTtcclxuXHR2YXIgaSwgdGljaztcclxuXHJcblx0c3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nKTtcclxuXHRmb3IgKGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdHRpY2sgPSB0aWNrc1tpXTtcclxuXHRcdGlmIChpID09PSBuZXh0KSB7XHJcblx0XHRcdHRpY2suX2luZGV4ID0gaTtcclxuXHRcdFx0Y291bnQrKztcclxuXHRcdFx0bmV4dCA9IG1ham9ySW5kaWNlc1tjb3VudCAqIHNwYWNpbmddO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZGVsZXRlIHRpY2subGFiZWw7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBza2lwKHRpY2tzLCBzcGFjaW5nLCBtYWpvclN0YXJ0LCBtYWpvckVuZCkge1xyXG5cdHZhciBzdGFydCA9IHZhbHVlT3JEZWZhdWx0JGEobWFqb3JTdGFydCwgMCk7XHJcblx0dmFyIGVuZCA9IE1hdGgubWluKHZhbHVlT3JEZWZhdWx0JGEobWFqb3JFbmQsIHRpY2tzLmxlbmd0aCksIHRpY2tzLmxlbmd0aCk7XHJcblx0dmFyIGNvdW50ID0gMDtcclxuXHR2YXIgbGVuZ3RoLCBpLCB0aWNrLCBuZXh0O1xyXG5cclxuXHRzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcpO1xyXG5cdGlmIChtYWpvckVuZCkge1xyXG5cdFx0bGVuZ3RoID0gbWFqb3JFbmQgLSBtYWpvclN0YXJ0O1xyXG5cdFx0c3BhY2luZyA9IGxlbmd0aCAvIE1hdGguZmxvb3IobGVuZ3RoIC8gc3BhY2luZyk7XHJcblx0fVxyXG5cclxuXHRuZXh0ID0gc3RhcnQ7XHJcblxyXG5cdHdoaWxlIChuZXh0IDwgMCkge1xyXG5cdFx0Y291bnQrKztcclxuXHRcdG5leHQgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgY291bnQgKiBzcGFjaW5nKTtcclxuXHR9XHJcblxyXG5cdGZvciAoaSA9IE1hdGgubWF4KHN0YXJ0LCAwKTsgaSA8IGVuZDsgaSsrKSB7XHJcblx0XHR0aWNrID0gdGlja3NbaV07XHJcblx0XHRpZiAoaSA9PT0gbmV4dCkge1xyXG5cdFx0XHR0aWNrLl9pbmRleCA9IGk7XHJcblx0XHRcdGNvdW50Kys7XHJcblx0XHRcdG5leHQgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgY291bnQgKiBzcGFjaW5nKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGRlbGV0ZSB0aWNrLmxhYmVsO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxudmFyIFNjYWxlID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XHJcblxyXG5cdHplcm9MaW5lSW5kZXg6IDAsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgcGFkZGluZyBuZWVkZWQgZm9yIHRoZSBzY2FsZVxyXG5cdCAqIEBtZXRob2QgZ2V0UGFkZGluZ1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHJldHVybnMge1BhZGRpbmd9IHRoZSBuZWNlc3NhcnkgcGFkZGluZ1xyXG5cdCAqL1xyXG5cdGdldFBhZGRpbmc6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGxlZnQ6IG1lLnBhZGRpbmdMZWZ0IHx8IDAsXHJcblx0XHRcdHRvcDogbWUucGFkZGluZ1RvcCB8fCAwLFxyXG5cdFx0XHRyaWdodDogbWUucGFkZGluZ1JpZ2h0IHx8IDAsXHJcblx0XHRcdGJvdHRvbTogbWUucGFkZGluZ0JvdHRvbSB8fCAwXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHNjYWxlIHRpY2sgb2JqZWN0cyAoe2xhYmVsLCBtYWpvcn0pXHJcblx0ICogQHNpbmNlIDIuN1xyXG5cdCAqL1xyXG5cdGdldFRpY2tzOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLl90aWNrcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQqIEBwcml2YXRlXHJcblx0Ki9cclxuXHRfZ2V0TGFiZWxzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5sYWJlbHMgfHwgKHRoaXMuaXNIb3Jpem9udGFsKCkgPyBkYXRhLnhMYWJlbHMgOiBkYXRhLnlMYWJlbHMpIHx8IGRhdGEubGFiZWxzIHx8IFtdO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRoZXNlIG1ldGhvZHMgYXJlIG9yZGVyZWQgYnkgbGlmZWN5bGUuIFV0aWxpdGllcyB0aGVuIGZvbGxvdy5cclxuXHQvLyBBbnkgZnVuY3Rpb24gZGVmaW5lZCBoZXJlIGlzIGluaGVyaXRlZCBieSBhbGwgc2NhbGUgdHlwZXMuXHJcblx0Ly8gQW55IGZ1bmN0aW9uIGNhbiBiZSBleHRlbmRlZCBieSB0aGUgc2NhbGUgdHlwZVxyXG5cclxuXHQvKipcclxuXHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlXHJcblx0ICogQGZ1bmN0aW9uIENoYXJ0LlNjYWxlLm1lcmdlVGlja3NPcHRpb25zXHJcblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxyXG5cdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuXHQgKi9cclxuXHRtZXJnZVRpY2tzT3B0aW9uczogZnVuY3Rpb24oKSB7XHJcblx0XHQvLyBub29wXHJcblx0fSxcclxuXHJcblx0YmVmb3JlVXBkYXRlOiBmdW5jdGlvbigpIHtcclxuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVXBkYXRlLCBbdGhpc10pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhXaWR0aCAtIHRoZSBtYXggd2lkdGggaW4gcGl4ZWxzXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heEhlaWdodCAtIHRoZSBtYXggaGVpZ2h0IGluIHBpeGVsc1xyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBtYXJnaW5zIC0gdGhlIHNwYWNlIGJldHdlZW4gdGhlIGVkZ2Ugb2YgdGhlIG90aGVyIHNjYWxlcyBhbmQgZWRnZSBvZiB0aGUgY2hhcnRcclxuXHQgKiAgIFRoaXMgc3BhY2UgY29tZXMgZnJvbSB0d28gc291cmNlczpcclxuXHQgKiAgICAgLSBwYWRkaW5nIC0gc3BhY2UgdGhhdCdzIHJlcXVpcmVkIHRvIHNob3cgdGhlIGxhYmVscyBhdCB0aGUgZWRnZXMgb2YgdGhlIHNjYWxlXHJcblx0ICogICAgIC0gdGhpY2tuZXNzIG9mIHNjYWxlcyBvciBsZWdlbmRzIGluIGFub3RoZXIgb3JpZW50YXRpb25cclxuXHQgKi9cclxuXHR1cGRhdGU6IGZ1bmN0aW9uKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xyXG5cdFx0dmFyIHNhbXBsZVNpemUgPSB0aWNrT3B0cy5zYW1wbGVTaXplO1xyXG5cdFx0dmFyIGksIGlsZW4sIGxhYmVscywgdGlja3MsIHNhbXBsaW5nRW5hYmxlZDtcclxuXHJcblx0XHQvLyBVcGRhdGUgTGlmZWN5Y2xlIC0gUHJvYmFibHkgZG9uJ3Qgd2FudCB0byBldmVyIGV4dGVuZCBvciBvdmVyd3JpdGUgdGhpcyBmdW5jdGlvbiA7KVxyXG5cdFx0bWUuYmVmb3JlVXBkYXRlKCk7XHJcblxyXG5cdFx0Ly8gQWJzb3JiIHRoZSBtYXN0ZXIgbWVhc3VyZW1lbnRzXHJcblx0XHRtZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xyXG5cdFx0bWUubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xyXG5cdFx0bWUubWFyZ2lucyA9IGhlbHBlcnMkMS5leHRlbmQoe1xyXG5cdFx0XHRsZWZ0OiAwLFxyXG5cdFx0XHRyaWdodDogMCxcclxuXHRcdFx0dG9wOiAwLFxyXG5cdFx0XHRib3R0b206IDBcclxuXHRcdH0sIG1hcmdpbnMpO1xyXG5cclxuXHRcdG1lLl90aWNrcyA9IG51bGw7XHJcblx0XHRtZS50aWNrcyA9IG51bGw7XHJcblx0XHRtZS5fbGFiZWxTaXplcyA9IG51bGw7XHJcblx0XHRtZS5fbWF4TGFiZWxMaW5lcyA9IDA7XHJcblx0XHRtZS5sb25nZXN0TGFiZWxXaWR0aCA9IDA7XHJcblx0XHRtZS5sb25nZXN0VGV4dENhY2hlID0gbWUubG9uZ2VzdFRleHRDYWNoZSB8fCB7fTtcclxuXHRcdG1lLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcclxuXHRcdG1lLl9sYWJlbEl0ZW1zID0gbnVsbDtcclxuXHJcblx0XHQvLyBEaW1lbnNpb25zXHJcblx0XHRtZS5iZWZvcmVTZXREaW1lbnNpb25zKCk7XHJcblx0XHRtZS5zZXREaW1lbnNpb25zKCk7XHJcblx0XHRtZS5hZnRlclNldERpbWVuc2lvbnMoKTtcclxuXHJcblx0XHQvLyBEYXRhIG1pbi9tYXhcclxuXHRcdG1lLmJlZm9yZURhdGFMaW1pdHMoKTtcclxuXHRcdG1lLmRldGVybWluZURhdGFMaW1pdHMoKTtcclxuXHRcdG1lLmFmdGVyRGF0YUxpbWl0cygpO1xyXG5cclxuXHRcdC8vIFRpY2tzIC0gYHRoaXMudGlja3NgIGlzIG5vdyBERVBSRUNBVEVEIVxyXG5cdFx0Ly8gSW50ZXJuYWwgdGlja3MgYXJlIG5vdyBzdG9yZWQgYXMgb2JqZWN0cyBpbiB0aGUgUFJJVkFURSBgdGhpcy5fdGlja3NgIG1lbWJlclxyXG5cdFx0Ly8gYW5kIG11c3Qgbm90IGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gb3V0c2lkZSB0aGlzIGNsYXNzLiBgdGhpcy50aWNrc2AgYmVpbmdcclxuXHRcdC8vIGFyb3VuZCBmb3IgbG9uZyB0aW1lIGFuZCBub3QgbWFya2VkIGFzIHByaXZhdGUsIHdlIGNhbid0IGNoYW5nZSBpdHMgc3RydWN0dXJlXHJcblx0XHQvLyB3aXRob3V0IHVuZXhwZWN0ZWQgYnJlYWtpbmcgY2hhbmdlcy4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzY2FsZSB0aWNrcyxcclxuXHRcdC8vIHVzZSBzY2FsZS5nZXRUaWNrcygpIGluc3RlYWQuXHJcblxyXG5cdFx0bWUuYmVmb3JlQnVpbGRUaWNrcygpO1xyXG5cclxuXHRcdC8vIE5ldyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBvYmplY3RzIGJ1dCBmb3IgQkFDS1dBUkQgQ09NUEFULFxyXG5cdFx0Ly8gd2Ugc3RpbGwgc3VwcG9ydCBubyByZXR1cm4gKGB0aGlzLnRpY2tzYCBpbnRlcm5hbGx5IHNldCBieSBjYWxsaW5nIHRoaXMgbWV0aG9kKS5cclxuXHRcdHRpY2tzID0gbWUuYnVpbGRUaWNrcygpIHx8IFtdO1xyXG5cclxuXHRcdC8vIEFsbG93IG1vZGlmaWNhdGlvbiBvZiB0aWNrcyBpbiBjYWxsYmFjay5cclxuXHRcdHRpY2tzID0gbWUuYWZ0ZXJCdWlsZFRpY2tzKHRpY2tzKSB8fCB0aWNrcztcclxuXHJcblx0XHQvLyBFbnN1cmUgdGlja3MgY29udGFpbnMgdGlja3MgaW4gbmV3IHRpY2sgZm9ybWF0XHJcblx0XHRpZiAoKCF0aWNrcyB8fCAhdGlja3MubGVuZ3RoKSAmJiBtZS50aWNrcykge1xyXG5cdFx0XHR0aWNrcyA9IFtdO1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gbWUudGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdFx0dGlja3MucHVzaCh7XHJcblx0XHRcdFx0XHR2YWx1ZTogbWUudGlja3NbaV0sXHJcblx0XHRcdFx0XHRtYWpvcjogZmFsc2VcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG1lLl90aWNrcyA9IHRpY2tzO1xyXG5cclxuXHRcdC8vIENvbXB1dGUgdGljayByb3RhdGlvbiBhbmQgZml0IHVzaW5nIGEgc2FtcGxlZCBzdWJzZXQgb2YgbGFiZWxzXHJcblx0XHQvLyBXZSBnZW5lcmFsbHkgZG9uJ3QgbmVlZCB0byBjb21wdXRlIHRoZSBzaXplIG9mIGV2ZXJ5IHNpbmdsZSBsYWJlbCBmb3IgZGV0ZXJtaW5pbmcgc2NhbGUgc2l6ZVxyXG5cdFx0c2FtcGxpbmdFbmFibGVkID0gc2FtcGxlU2l6ZSA8IHRpY2tzLmxlbmd0aDtcclxuXHRcdGxhYmVscyA9IG1lLl9jb252ZXJ0VGlja3NUb0xhYmVscyhzYW1wbGluZ0VuYWJsZWQgPyBzYW1wbGUodGlja3MsIHNhbXBsZVNpemUpIDogdGlja3MpO1xyXG5cclxuXHRcdC8vIF9jb25maWd1cmUgaXMgY2FsbGVkIHR3aWNlLCBvbmNlIGhlcmUsIG9uY2UgZnJvbSBjb3JlLmNvbnRyb2xsZXIudXBkYXRlTGF5b3V0LlxyXG5cdFx0Ly8gSGVyZSB3ZSBoYXZlbid0IGJlZW4gcG9zaXRpb25lZCB5ZXQsIGJ1dCBkaW1lbnNpb25zIGFyZSBjb3JyZWN0LlxyXG5cdFx0Ly8gVmFyaWFibGVzIHNldCBpbiBfY29uZmlndXJlIGFyZSBuZWVkZWQgZm9yIGNhbGN1bGF0ZVRpY2tSb3RhdGlvbiwgYW5kXHJcblx0XHQvLyBpdCdzIG9rIHRoYXQgY29vcmRpbmF0ZXMgYXJlIG5vdCBjb3JyZWN0IHRoZXJlLCBvbmx5IGRpbWVuc2lvbnMgbWF0dGVyLlxyXG5cdFx0bWUuX2NvbmZpZ3VyZSgpO1xyXG5cclxuXHRcdC8vIFRpY2sgUm90YXRpb25cclxuXHRcdG1lLmJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbigpO1xyXG5cdFx0bWUuY2FsY3VsYXRlVGlja1JvdGF0aW9uKCk7XHJcblx0XHRtZS5hZnRlckNhbGN1bGF0ZVRpY2tSb3RhdGlvbigpO1xyXG5cclxuXHRcdG1lLmJlZm9yZUZpdCgpO1xyXG5cdFx0bWUuZml0KCk7XHJcblx0XHRtZS5hZnRlckZpdCgpO1xyXG5cclxuXHRcdC8vIEF1dG8tc2tpcFxyXG5cdFx0bWUuX3RpY2tzVG9EcmF3ID0gdGlja09wdHMuZGlzcGxheSAmJiAodGlja09wdHMuYXV0b1NraXAgfHwgdGlja09wdHMuc291cmNlID09PSAnYXV0bycpID8gbWUuX2F1dG9Ta2lwKHRpY2tzKSA6IHRpY2tzO1xyXG5cclxuXHRcdGlmIChzYW1wbGluZ0VuYWJsZWQpIHtcclxuXHRcdFx0Ly8gR2VuZXJhdGUgbGFiZWxzIHVzaW5nIGFsbCBub24tc2tpcHBlZCB0aWNrc1xyXG5cdFx0XHRsYWJlbHMgPSBtZS5fY29udmVydFRpY2tzVG9MYWJlbHMobWUuX3RpY2tzVG9EcmF3KTtcclxuXHRcdH1cclxuXHJcblx0XHRtZS50aWNrcyA9IGxhYmVsczsgICAvLyBCQUNLV0FSRCBDT01QQVRJQklMSVRZXHJcblxyXG5cdFx0Ly8gSU1QT1JUQU5UOiBhZnRlciB0aGlzIHBvaW50LCB3ZSBjb25zaWRlciB0aGF0IGB0aGlzLnRpY2tzYCB3aWxsIE5FVkVSIGNoYW5nZSFcclxuXHJcblx0XHRtZS5hZnRlclVwZGF0ZSgpO1xyXG5cclxuXHRcdC8vIFRPRE8odjMpOiByZW1vdmUgbWluU2l6ZSBhcyBhIHB1YmxpYyBwcm9wZXJ0eSBhbmQgcmV0dXJuIHZhbHVlIGZyb20gYWxsIGxheW91dCBib3hlcy4gSXQgaXMgdW51c2VkXHJcblx0XHQvLyBtYWtlIG1heFdpZHRoIGFuZCBtYXhIZWlnaHQgcHJpdmF0ZVxyXG5cdFx0cmV0dXJuIG1lLm1pblNpemU7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfY29uZmlndXJlOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgcmV2ZXJzZVBpeGVscyA9IG1lLm9wdGlvbnMudGlja3MucmV2ZXJzZTtcclxuXHRcdHZhciBzdGFydFBpeGVsLCBlbmRQaXhlbDtcclxuXHJcblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcclxuXHRcdFx0c3RhcnRQaXhlbCA9IG1lLmxlZnQ7XHJcblx0XHRcdGVuZFBpeGVsID0gbWUucmlnaHQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdGFydFBpeGVsID0gbWUudG9wO1xyXG5cdFx0XHRlbmRQaXhlbCA9IG1lLmJvdHRvbTtcclxuXHRcdFx0Ly8gYnkgZGVmYXVsdCB2ZXJ0aWNhbCBzY2FsZXMgYXJlIGZyb20gYm90dG9tIHRvIHRvcCwgc28gcGl4ZWxzIGFyZSByZXZlcnNlZFxyXG5cdFx0XHRyZXZlcnNlUGl4ZWxzID0gIXJldmVyc2VQaXhlbHM7XHJcblx0XHR9XHJcblx0XHRtZS5fc3RhcnRQaXhlbCA9IHN0YXJ0UGl4ZWw7XHJcblx0XHRtZS5fZW5kUGl4ZWwgPSBlbmRQaXhlbDtcclxuXHRcdG1lLl9yZXZlcnNlUGl4ZWxzID0gcmV2ZXJzZVBpeGVscztcclxuXHRcdG1lLl9sZW5ndGggPSBlbmRQaXhlbCAtIHN0YXJ0UGl4ZWw7XHJcblx0fSxcclxuXHJcblx0YWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclVwZGF0ZSwgW3RoaXNdKTtcclxuXHR9LFxyXG5cclxuXHQvL1xyXG5cclxuXHRiZWZvcmVTZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcclxuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcclxuXHR9LFxyXG5cdHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXHJcblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcclxuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXHJcblx0XHRcdG1lLndpZHRoID0gbWUubWF4V2lkdGg7XHJcblx0XHRcdG1lLmxlZnQgPSAwO1xyXG5cdFx0XHRtZS5yaWdodCA9IG1lLndpZHRoO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xyXG5cclxuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXHJcblx0XHRcdG1lLnRvcCA9IDA7XHJcblx0XHRcdG1lLmJvdHRvbSA9IG1lLmhlaWdodDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBSZXNldCBwYWRkaW5nXHJcblx0XHRtZS5wYWRkaW5nTGVmdCA9IDA7XHJcblx0XHRtZS5wYWRkaW5nVG9wID0gMDtcclxuXHRcdG1lLnBhZGRpbmdSaWdodCA9IDA7XHJcblx0XHRtZS5wYWRkaW5nQm90dG9tID0gMDtcclxuXHR9LFxyXG5cdGFmdGVyU2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XHJcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcclxuXHR9LFxyXG5cclxuXHQvLyBEYXRhIGxpbWl0c1xyXG5cdGJlZm9yZURhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVEYXRhTGltaXRzLCBbdGhpc10pO1xyXG5cdH0sXHJcblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogaGVscGVycyQxLm5vb3AsXHJcblx0YWZ0ZXJEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcclxuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJEYXRhTGltaXRzLCBbdGhpc10pO1xyXG5cdH0sXHJcblxyXG5cdC8vXHJcblx0YmVmb3JlQnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XHJcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUJ1aWxkVGlja3MsIFt0aGlzXSk7XHJcblx0fSxcclxuXHRidWlsZFRpY2tzOiBoZWxwZXJzJDEubm9vcCxcclxuXHRhZnRlckJ1aWxkVGlja3M6IGZ1bmN0aW9uKHRpY2tzKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0Ly8gdGlja3MgaXMgZW1wdHkgZm9yIG9sZCBheGlzIGltcGxlbWVudGF0aW9ucyBoZXJlXHJcblx0XHRpZiAoaXNBcnJheSh0aWNrcykgJiYgdGlja3MubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBoZWxwZXJzJDEuY2FsbGJhY2sobWUub3B0aW9ucy5hZnRlckJ1aWxkVGlja3MsIFttZSwgdGlja3NdKTtcclxuXHRcdH1cclxuXHRcdC8vIFN1cHBvcnQgb2xkIGltcGxlbWVudGF0aW9ucyAodGhhdCBtb2RpZmllZCBgdGhpcy50aWNrc2AgZGlyZWN0bHkgaW4gYnVpbGRUaWNrcylcclxuXHRcdG1lLnRpY2tzID0gaGVscGVycyQxLmNhbGxiYWNrKG1lLm9wdGlvbnMuYWZ0ZXJCdWlsZFRpY2tzLCBbbWUsIG1lLnRpY2tzXSkgfHwgbWUudGlja3M7XHJcblx0XHRyZXR1cm4gdGlja3M7XHJcblx0fSxcclxuXHJcblx0YmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uOiBmdW5jdGlvbigpIHtcclxuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xyXG5cdH0sXHJcblx0Y29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdC8vIENvbnZlcnQgdGlja3MgdG8gc3RyaW5nc1xyXG5cdFx0dmFyIHRpY2tPcHRzID0gbWUub3B0aW9ucy50aWNrcztcclxuXHRcdG1lLnRpY2tzID0gbWUudGlja3MubWFwKHRpY2tPcHRzLnVzZXJDYWxsYmFjayB8fCB0aWNrT3B0cy5jYWxsYmFjaywgdGhpcyk7XHJcblx0fSxcclxuXHRhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbjogZnVuY3Rpb24oKSB7XHJcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xyXG5cdH0sXHJcblxyXG5cdC8vXHJcblxyXG5cdGJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbjogZnVuY3Rpb24oKSB7XHJcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbiwgW3RoaXNdKTtcclxuXHR9LFxyXG5cdGNhbGN1bGF0ZVRpY2tSb3RhdGlvbjogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcclxuXHRcdHZhciBudW1UaWNrcyA9IG1lLmdldFRpY2tzKCkubGVuZ3RoO1xyXG5cdFx0dmFyIG1pblJvdGF0aW9uID0gdGlja09wdHMubWluUm90YXRpb24gfHwgMDtcclxuXHRcdHZhciBtYXhSb3RhdGlvbiA9IHRpY2tPcHRzLm1heFJvdGF0aW9uO1xyXG5cdFx0dmFyIGxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcclxuXHRcdHZhciBsYWJlbFNpemVzLCBtYXhMYWJlbFdpZHRoLCBtYXhMYWJlbEhlaWdodCwgbWF4V2lkdGgsIHRpY2tXaWR0aCwgbWF4SGVpZ2h0LCBtYXhMYWJlbERpYWdvbmFsO1xyXG5cclxuXHRcdGlmICghbWUuX2lzVmlzaWJsZSgpIHx8ICF0aWNrT3B0cy5kaXNwbGF5IHx8IG1pblJvdGF0aW9uID49IG1heFJvdGF0aW9uIHx8IG51bVRpY2tzIDw9IDEgfHwgIW1lLmlzSG9yaXpvbnRhbCgpKSB7XHJcblx0XHRcdG1lLmxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxhYmVsU2l6ZXMgPSBtZS5fZ2V0TGFiZWxTaXplcygpO1xyXG5cdFx0bWF4TGFiZWxXaWR0aCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xyXG5cdFx0bWF4TGFiZWxIZWlnaHQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC0gbGFiZWxTaXplcy5oaWdoZXN0Lm9mZnNldDtcclxuXHJcblx0XHQvLyBFc3RpbWF0ZSB0aGUgd2lkdGggb2YgZWFjaCBncmlkIGJhc2VkIG9uIHRoZSBjYW52YXMgd2lkdGgsIHRoZSBtYXhpbXVtXHJcblx0XHQvLyBsYWJlbCB3aWR0aCBhbmQgdGhlIG51bWJlciBvZiB0aWNrIGludGVydmFsc1xyXG5cdFx0bWF4V2lkdGggPSBNYXRoLm1pbihtZS5tYXhXaWR0aCwgbWUuY2hhcnQud2lkdGggLSBtYXhMYWJlbFdpZHRoKTtcclxuXHRcdHRpY2tXaWR0aCA9IG9wdGlvbnMub2Zmc2V0ID8gbWUubWF4V2lkdGggLyBudW1UaWNrcyA6IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gMSk7XHJcblxyXG5cdFx0Ly8gQWxsb3cgMyBwaXhlbHMgeDIgcGFkZGluZyBlaXRoZXIgc2lkZSBmb3IgbGFiZWwgcmVhZGFiaWxpdHlcclxuXHRcdGlmIChtYXhMYWJlbFdpZHRoICsgNiA+IHRpY2tXaWR0aCkge1xyXG5cdFx0XHR0aWNrV2lkdGggPSBtYXhXaWR0aCAvIChudW1UaWNrcyAtIChvcHRpb25zLm9mZnNldCA/IDAuNSA6IDEpKTtcclxuXHRcdFx0bWF4SGVpZ2h0ID0gbWUubWF4SGVpZ2h0IC0gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucy5ncmlkTGluZXMpXHJcblx0XHRcdFx0LSB0aWNrT3B0cy5wYWRkaW5nIC0gZ2V0U2NhbGVMYWJlbEhlaWdodChvcHRpb25zLnNjYWxlTGFiZWwpO1xyXG5cdFx0XHRtYXhMYWJlbERpYWdvbmFsID0gTWF0aC5zcXJ0KG1heExhYmVsV2lkdGggKiBtYXhMYWJlbFdpZHRoICsgbWF4TGFiZWxIZWlnaHQgKiBtYXhMYWJlbEhlaWdodCk7XHJcblx0XHRcdGxhYmVsUm90YXRpb24gPSBoZWxwZXJzJDEudG9EZWdyZWVzKE1hdGgubWluKFxyXG5cdFx0XHRcdE1hdGguYXNpbihNYXRoLm1pbigobGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIDYpIC8gdGlja1dpZHRoLCAxKSksXHJcblx0XHRcdFx0TWF0aC5hc2luKE1hdGgubWluKG1heEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIDEpKSAtIE1hdGguYXNpbihtYXhMYWJlbEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwpXHJcblx0XHRcdCkpO1xyXG5cdFx0XHRsYWJlbFJvdGF0aW9uID0gTWF0aC5tYXgobWluUm90YXRpb24sIE1hdGgubWluKG1heFJvdGF0aW9uLCBsYWJlbFJvdGF0aW9uKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bWUubGFiZWxSb3RhdGlvbiA9IGxhYmVsUm90YXRpb247XHJcblx0fSxcclxuXHRhZnRlckNhbGN1bGF0ZVRpY2tSb3RhdGlvbjogZnVuY3Rpb24oKSB7XHJcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyQ2FsY3VsYXRlVGlja1JvdGF0aW9uLCBbdGhpc10pO1xyXG5cdH0sXHJcblxyXG5cdC8vXHJcblxyXG5cdGJlZm9yZUZpdDogZnVuY3Rpb24oKSB7XHJcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUZpdCwgW3RoaXNdKTtcclxuXHR9LFxyXG5cdGZpdDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0Ly8gUmVzZXRcclxuXHRcdHZhciBtaW5TaXplID0gbWUubWluU2l6ZSA9IHtcclxuXHRcdFx0d2lkdGg6IDAsXHJcblx0XHRcdGhlaWdodDogMFxyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcclxuXHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XHJcblx0XHR2YXIgc2NhbGVMYWJlbE9wdHMgPSBvcHRzLnNjYWxlTGFiZWw7XHJcblx0XHR2YXIgZ3JpZExpbmVPcHRzID0gb3B0cy5ncmlkTGluZXM7XHJcblx0XHR2YXIgZGlzcGxheSA9IG1lLl9pc1Zpc2libGUoKTtcclxuXHRcdHZhciBpc0JvdHRvbSA9IG9wdHMucG9zaXRpb24gPT09ICdib3R0b20nO1xyXG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xyXG5cclxuXHRcdC8vIFdpZHRoXHJcblx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XHJcblx0XHRcdG1pblNpemUud2lkdGggPSBtZS5tYXhXaWR0aDtcclxuXHRcdH0gZWxzZSBpZiAoZGlzcGxheSkge1xyXG5cdFx0XHRtaW5TaXplLndpZHRoID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZExpbmVPcHRzKSArIGdldFNjYWxlTGFiZWxIZWlnaHQoc2NhbGVMYWJlbE9wdHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGhlaWdodFxyXG5cdFx0aWYgKCFpc0hvcml6b250YWwpIHtcclxuXHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7IC8vIGZpbGwgYWxsIHRoZSBoZWlnaHRcclxuXHRcdH0gZWxzZSBpZiAoZGlzcGxheSkge1xyXG5cdFx0XHRtaW5TaXplLmhlaWdodCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRMaW5lT3B0cykgKyBnZXRTY2FsZUxhYmVsSGVpZ2h0KHNjYWxlTGFiZWxPcHRzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBEb24ndCBib3RoZXIgZml0dGluZyB0aGUgdGlja3MgaWYgd2UgYXJlIG5vdCBzaG93aW5nIHRoZSBsYWJlbHNcclxuXHRcdGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmIGRpc3BsYXkpIHtcclxuXHRcdFx0dmFyIHRpY2tGb250cyA9IHBhcnNlVGlja0ZvbnRPcHRpb25zKHRpY2tPcHRzKTtcclxuXHRcdFx0dmFyIGxhYmVsU2l6ZXMgPSBtZS5fZ2V0TGFiZWxTaXplcygpO1xyXG5cdFx0XHR2YXIgZmlyc3RMYWJlbFNpemUgPSBsYWJlbFNpemVzLmZpcnN0O1xyXG5cdFx0XHR2YXIgbGFzdExhYmVsU2l6ZSA9IGxhYmVsU2l6ZXMubGFzdDtcclxuXHRcdFx0dmFyIHdpZGVzdExhYmVsU2l6ZSA9IGxhYmVsU2l6ZXMud2lkZXN0O1xyXG5cdFx0XHR2YXIgaGlnaGVzdExhYmVsU2l6ZSA9IGxhYmVsU2l6ZXMuaGlnaGVzdDtcclxuXHRcdFx0dmFyIGxpbmVTcGFjZSA9IHRpY2tGb250cy5taW5vci5saW5lSGVpZ2h0ICogMC40O1xyXG5cdFx0XHR2YXIgdGlja1BhZGRpbmcgPSB0aWNrT3B0cy5wYWRkaW5nO1xyXG5cclxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xyXG5cdFx0XHRcdC8vIEEgaG9yaXpvbnRhbCBheGlzIGlzIG1vcmUgY29uc3RyYWluZWQgYnkgdGhlIGhlaWdodC5cclxuXHRcdFx0XHR2YXIgaXNSb3RhdGVkID0gbWUubGFiZWxSb3RhdGlvbiAhPT0gMDtcclxuXHRcdFx0XHR2YXIgYW5nbGVSYWRpYW5zID0gaGVscGVycyQxLnRvUmFkaWFucyhtZS5sYWJlbFJvdGF0aW9uKTtcclxuXHRcdFx0XHR2YXIgY29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xyXG5cdFx0XHRcdHZhciBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlUmFkaWFucyk7XHJcblxyXG5cdFx0XHRcdHZhciBsYWJlbEhlaWdodCA9IHNpblJvdGF0aW9uICogd2lkZXN0TGFiZWxTaXplLndpZHRoXHJcblx0XHRcdFx0XHQrIGNvc1JvdGF0aW9uICogKGhpZ2hlc3RMYWJlbFNpemUuaGVpZ2h0IC0gKGlzUm90YXRlZCA/IGhpZ2hlc3RMYWJlbFNpemUub2Zmc2V0IDogMCkpXHJcblx0XHRcdFx0XHQrIChpc1JvdGF0ZWQgPyAwIDogbGluZVNwYWNlKTsgLy8gcGFkZGluZ1xyXG5cclxuXHRcdFx0XHRtaW5TaXplLmhlaWdodCA9IE1hdGgubWluKG1lLm1heEhlaWdodCwgbWluU2l6ZS5oZWlnaHQgKyBsYWJlbEhlaWdodCArIHRpY2tQYWRkaW5nKTtcclxuXHJcblx0XHRcdFx0dmFyIG9mZnNldExlZnQgPSBtZS5nZXRQaXhlbEZvclRpY2soMCkgLSBtZS5sZWZ0O1xyXG5cdFx0XHRcdHZhciBvZmZzZXRSaWdodCA9IG1lLnJpZ2h0IC0gbWUuZ2V0UGl4ZWxGb3JUaWNrKG1lLmdldFRpY2tzKCkubGVuZ3RoIC0gMSk7XHJcblx0XHRcdFx0dmFyIHBhZGRpbmdMZWZ0LCBwYWRkaW5nUmlnaHQ7XHJcblxyXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGF0IG91ciB0aWNrcyBhcmUgYWx3YXlzIGluc2lkZSB0aGUgY2FudmFzLiBXaGVuIHJvdGF0ZWQsIHRpY2tzIGFyZSByaWdodCBhbGlnbmVkXHJcblx0XHRcdFx0Ly8gd2hpY2ggbWVhbnMgdGhhdCB0aGUgcmlnaHQgcGFkZGluZyBpcyBkb21pbmF0ZWQgYnkgdGhlIGZvbnQgaGVpZ2h0XHJcblx0XHRcdFx0aWYgKGlzUm90YXRlZCkge1xyXG5cdFx0XHRcdFx0cGFkZGluZ0xlZnQgPSBpc0JvdHRvbSA/XHJcblx0XHRcdFx0XHRcdGNvc1JvdGF0aW9uICogZmlyc3RMYWJlbFNpemUud2lkdGggKyBzaW5Sb3RhdGlvbiAqIGZpcnN0TGFiZWxTaXplLm9mZnNldCA6XHJcblx0XHRcdFx0XHRcdHNpblJvdGF0aW9uICogKGZpcnN0TGFiZWxTaXplLmhlaWdodCAtIGZpcnN0TGFiZWxTaXplLm9mZnNldCk7XHJcblx0XHRcdFx0XHRwYWRkaW5nUmlnaHQgPSBpc0JvdHRvbSA/XHJcblx0XHRcdFx0XHRcdHNpblJvdGF0aW9uICogKGxhc3RMYWJlbFNpemUuaGVpZ2h0IC0gbGFzdExhYmVsU2l6ZS5vZmZzZXQpIDpcclxuXHRcdFx0XHRcdFx0Y29zUm90YXRpb24gKiBsYXN0TGFiZWxTaXplLndpZHRoICsgc2luUm90YXRpb24gKiBsYXN0TGFiZWxTaXplLm9mZnNldDtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cGFkZGluZ0xlZnQgPSBmaXJzdExhYmVsU2l6ZS53aWR0aCAvIDI7XHJcblx0XHRcdFx0XHRwYWRkaW5nUmlnaHQgPSBsYXN0TGFiZWxTaXplLndpZHRoIC8gMjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIEFkanVzdCBwYWRkaW5nIHRha2luZyBpbnRvIGFjY291bnQgY2hhbmdlcyBpbiBvZmZzZXRzXHJcblx0XHRcdFx0Ly8gYW5kIGFkZCAzIHB4IHRvIG1vdmUgYXdheSBmcm9tIGNhbnZhcyBlZGdlc1xyXG5cdFx0XHRcdG1lLnBhZGRpbmdMZWZ0ID0gTWF0aC5tYXgoKHBhZGRpbmdMZWZ0IC0gb2Zmc2V0TGVmdCkgKiBtZS53aWR0aCAvIChtZS53aWR0aCAtIG9mZnNldExlZnQpLCAwKSArIDM7XHJcblx0XHRcdFx0bWUucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgoKHBhZGRpbmdSaWdodCAtIG9mZnNldFJpZ2h0KSAqIG1lLndpZHRoIC8gKG1lLndpZHRoIC0gb2Zmc2V0UmlnaHQpLCAwKSArIDM7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gQSB2ZXJ0aWNhbCBheGlzIGlzIG1vcmUgY29uc3RyYWluZWQgYnkgdGhlIHdpZHRoLiBMYWJlbHMgYXJlIHRoZVxyXG5cdFx0XHRcdC8vIGRvbWluYW50IGZhY3RvciBoZXJlLCBzbyBnZXQgdGhhdCBsZW5ndGggZmlyc3QgYW5kIGFjY291bnQgZm9yIHBhZGRpbmdcclxuXHRcdFx0XHR2YXIgbGFiZWxXaWR0aCA9IHRpY2tPcHRzLm1pcnJvciA/IDAgOlxyXG5cdFx0XHRcdFx0Ly8gdXNlIGxpbmVTcGFjZSBmb3IgY29uc2lzdGVuY3kgd2l0aCBob3Jpem9udGFsIGF4aXNcclxuXHRcdFx0XHRcdC8vIHRpY2tQYWRkaW5nIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgaG9yaXpvbnRhbFxyXG5cdFx0XHRcdFx0d2lkZXN0TGFiZWxTaXplLndpZHRoICsgdGlja1BhZGRpbmcgKyBsaW5lU3BhY2U7XHJcblxyXG5cdFx0XHRcdG1pblNpemUud2lkdGggPSBNYXRoLm1pbihtZS5tYXhXaWR0aCwgbWluU2l6ZS53aWR0aCArIGxhYmVsV2lkdGgpO1xyXG5cclxuXHRcdFx0XHRtZS5wYWRkaW5nVG9wID0gZmlyc3RMYWJlbFNpemUuaGVpZ2h0IC8gMjtcclxuXHRcdFx0XHRtZS5wYWRkaW5nQm90dG9tID0gbGFzdExhYmVsU2l6ZS5oZWlnaHQgLyAyO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bWUuaGFuZGxlTWFyZ2lucygpO1xyXG5cclxuXHRcdGlmIChpc0hvcml6b250YWwpIHtcclxuXHRcdFx0bWUud2lkdGggPSBtZS5fbGVuZ3RoID0gY2hhcnQud2lkdGggLSBtZS5tYXJnaW5zLmxlZnQgLSBtZS5tYXJnaW5zLnJpZ2h0O1xyXG5cdFx0XHRtZS5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1lLndpZHRoID0gbWluU2l6ZS53aWR0aDtcclxuXHRcdFx0bWUuaGVpZ2h0ID0gbWUuX2xlbmd0aCA9IGNoYXJ0LmhlaWdodCAtIG1lLm1hcmdpbnMudG9wIC0gbWUubWFyZ2lucy5ib3R0b207XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogSGFuZGxlIG1hcmdpbnMgYW5kIHBhZGRpbmcgaW50ZXJhY3Rpb25zXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRoYW5kbGVNYXJnaW5zOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHRpZiAobWUubWFyZ2lucykge1xyXG5cdFx0XHRtZS5tYXJnaW5zLmxlZnQgPSBNYXRoLm1heChtZS5wYWRkaW5nTGVmdCwgbWUubWFyZ2lucy5sZWZ0KTtcclxuXHRcdFx0bWUubWFyZ2lucy50b3AgPSBNYXRoLm1heChtZS5wYWRkaW5nVG9wLCBtZS5tYXJnaW5zLnRvcCk7XHJcblx0XHRcdG1lLm1hcmdpbnMucmlnaHQgPSBNYXRoLm1heChtZS5wYWRkaW5nUmlnaHQsIG1lLm1hcmdpbnMucmlnaHQpO1xyXG5cdFx0XHRtZS5tYXJnaW5zLmJvdHRvbSA9IE1hdGgubWF4KG1lLnBhZGRpbmdCb3R0b20sIG1lLm1hcmdpbnMuYm90dG9tKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRhZnRlckZpdDogZnVuY3Rpb24oKSB7XHJcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyRml0LCBbdGhpc10pO1xyXG5cdH0sXHJcblxyXG5cdC8vIFNoYXJlZCBNZXRob2RzXHJcblx0aXNIb3Jpem9udGFsOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XHJcblx0XHRyZXR1cm4gcG9zID09PSAndG9wJyB8fCBwb3MgPT09ICdib3R0b20nO1xyXG5cdH0sXHJcblx0aXNGdWxsV2lkdGg6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5mdWxsV2lkdGg7XHJcblx0fSxcclxuXHJcblx0Ly8gR2V0IHRoZSBjb3JyZWN0IHZhbHVlLiBOYU4gYmFkIGlucHV0cywgSWYgdGhlIHZhbHVlIHR5cGUgaXMgb2JqZWN0IGdldCB0aGUgeCBvciB5IGJhc2VkIG9uIHdoZXRoZXIgd2UgYXJlIGhvcml6b250YWwgb3Igbm90XHJcblx0Z2V0UmlnaHRWYWx1ZTogZnVuY3Rpb24ocmF3VmFsdWUpIHtcclxuXHRcdC8vIE51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgZmlyc3RcclxuXHRcdGlmIChpc051bGxPclVuZGVmKHJhd1ZhbHVlKSkge1xyXG5cdFx0XHRyZXR1cm4gTmFOO1xyXG5cdFx0fVxyXG5cdFx0Ly8gaXNOYU4ob2JqZWN0KSByZXR1cm5zIHRydWUsIHNvIG1ha2Ugc3VyZSBOYU4gaXMgY2hlY2tpbmcgZm9yIGEgbnVtYmVyOyBEaXNjYXJkIEluZmluaXRlIHZhbHVlc1xyXG5cdFx0aWYgKCh0eXBlb2YgcmF3VmFsdWUgPT09ICdudW1iZXInIHx8IHJhd1ZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJiAhaXNGaW5pdGUocmF3VmFsdWUpKSB7XHJcblx0XHRcdHJldHVybiBOYU47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSWYgaXQgaXMgaW4gZmFjdCBhbiBvYmplY3QsIGRpdmUgaW4gb25lIG1vcmUgbGV2ZWxcclxuXHRcdGlmIChyYXdWYWx1ZSkge1xyXG5cdFx0XHRpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xyXG5cdFx0XHRcdGlmIChyYXdWYWx1ZS54ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUueCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKHJhd1ZhbHVlLnkgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUueSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBWYWx1ZSBpcyBnb29kLCByZXR1cm4gaXRcclxuXHRcdHJldHVybiByYXdWYWx1ZTtcclxuXHR9LFxyXG5cclxuXHRfY29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKHRpY2tzKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGxhYmVscywgaSwgaWxlbjtcclxuXHJcblx0XHRtZS50aWNrcyA9IHRpY2tzLm1hcChmdW5jdGlvbih0aWNrKSB7XHJcblx0XHRcdHJldHVybiB0aWNrLnZhbHVlO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0bWUuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XHJcblxyXG5cdFx0Ly8gTmV3IGltcGxlbWVudGF0aW9ucyBzaG91bGQgcmV0dXJuIHRoZSBmb3JtYXR0ZWQgdGljayBsYWJlbHMgYnV0IGZvciBCQUNLV0FSRFxyXG5cdFx0Ly8gQ09NUEFULCB3ZSBzdGlsbCBzdXBwb3J0IG5vIHJldHVybiAoYHRoaXMudGlja3NgIGludGVybmFsbHkgY2hhbmdlZCBieSBjYWxsaW5nXHJcblx0XHQvLyB0aGlzIG1ldGhvZCBhbmQgc3VwcG9zZWQgdG8gY29udGFpbiBvbmx5IHN0cmluZyB2YWx1ZXMpLlxyXG5cdFx0bGFiZWxzID0gbWUuY29udmVydFRpY2tzVG9MYWJlbHModGlja3MpIHx8IG1lLnRpY2tzO1xyXG5cclxuXHRcdG1lLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XHJcblxyXG5cdFx0Ly8gQkFDS1dBUkQgQ09NUEFUOiBzeW5jaHJvbml6ZSBgX3RpY2tzYCB3aXRoIGxhYmVscyAoc28gcG90ZW50aWFsbHkgYHRoaXMudGlja3NgKVxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHR0aWNrc1tpXS5sYWJlbCA9IGxhYmVsc1tpXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbGFiZWxzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldExhYmVsU2l6ZXM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBsYWJlbFNpemVzID0gbWUuX2xhYmVsU2l6ZXM7XHJcblxyXG5cdFx0aWYgKCFsYWJlbFNpemVzKSB7XHJcblx0XHRcdG1lLl9sYWJlbFNpemVzID0gbGFiZWxTaXplcyA9IGNvbXB1dGVMYWJlbFNpemVzKG1lLmN0eCwgcGFyc2VUaWNrRm9udE9wdGlvbnMobWUub3B0aW9ucy50aWNrcyksIG1lLmdldFRpY2tzKCksIG1lLmxvbmdlc3RUZXh0Q2FjaGUpO1xyXG5cdFx0XHRtZS5sb25nZXN0TGFiZWxXaWR0aCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBsYWJlbFNpemVzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3BhcnNlVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHR2YXIgc3RhcnQsIGVuZCwgbWluLCBtYXg7XHJcblxyXG5cdFx0aWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcblx0XHRcdHN0YXJ0ID0gK3RoaXMuZ2V0UmlnaHRWYWx1ZSh2YWx1ZVswXSk7XHJcblx0XHRcdGVuZCA9ICt0aGlzLmdldFJpZ2h0VmFsdWUodmFsdWVbMV0pO1xyXG5cdFx0XHRtaW4gPSBNYXRoLm1pbihzdGFydCwgZW5kKTtcclxuXHRcdFx0bWF4ID0gTWF0aC5tYXgoc3RhcnQsIGVuZCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YWx1ZSA9ICt0aGlzLmdldFJpZ2h0VmFsdWUodmFsdWUpO1xyXG5cdFx0XHRzdGFydCA9IHVuZGVmaW5lZDtcclxuXHRcdFx0ZW5kID0gdmFsdWU7XHJcblx0XHRcdG1pbiA9IHZhbHVlO1xyXG5cdFx0XHRtYXggPSB2YWx1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRtaW46IG1pbixcclxuXHRcdFx0bWF4OiBtYXgsXHJcblx0XHRcdHN0YXJ0OiBzdGFydCxcclxuXHRcdFx0ZW5kOiBlbmRcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0KiBAcHJpdmF0ZVxyXG5cdCovXHJcblx0X2dldFNjYWxlTGFiZWw6IGZ1bmN0aW9uKHJhd1ZhbHVlKSB7XHJcblx0XHR2YXIgdiA9IHRoaXMuX3BhcnNlVmFsdWUocmF3VmFsdWUpO1xyXG5cdFx0aWYgKHYuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gJ1snICsgdi5zdGFydCArICcsICcgKyB2LmVuZCArICddJztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gK3RoaXMuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXNlZCB0byBnZXQgdGhlIHZhbHVlIHRvIGRpc3BsYXkgaW4gdGhlIHRvb2x0aXAgZm9yIHRoZSBkYXRhIGF0IHRoZSBnaXZlbiBpbmRleFxyXG5cdCAqIEBwYXJhbSBpbmRleFxyXG5cdCAqIEBwYXJhbSBkYXRhc2V0SW5kZXhcclxuXHQgKi9cclxuXHRnZXRMYWJlbEZvckluZGV4OiBoZWxwZXJzJDEubm9vcCxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgbG9jYXRpb24gb2YgdGhlIGdpdmVuIGRhdGEgcG9pbnQuIFZhbHVlIGNhbiBlaXRoZXIgYmUgYW4gaW5kZXggb3IgYSBudW1lcmljYWwgdmFsdWVcclxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcclxuXHQgKiBAcGFyYW0gdmFsdWVcclxuXHQgKiBAcGFyYW0gaW5kZXhcclxuXHQgKiBAcGFyYW0gZGF0YXNldEluZGV4XHJcblx0ICovXHJcblx0Z2V0UGl4ZWxGb3JWYWx1ZTogaGVscGVycyQxLm5vb3AsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVzZWQgdG8gZ2V0IHRoZSBkYXRhIHZhbHVlIGZyb20gYSBnaXZlbiBwaXhlbC4gVGhpcyBpcyB0aGUgaW52ZXJzZSBvZiBnZXRQaXhlbEZvclZhbHVlXHJcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXHJcblx0ICogQHBhcmFtIHBpeGVsXHJcblx0ICovXHJcblx0Z2V0VmFsdWVGb3JQaXhlbDogaGVscGVycyQxLm5vb3AsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGxvY2F0aW9uIG9mIHRoZSB0aWNrIGF0IHRoZSBnaXZlbiBpbmRleFxyXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xyXG5cdCAqL1xyXG5cdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb2Zmc2V0ID0gbWUub3B0aW9ucy5vZmZzZXQ7XHJcblx0XHR2YXIgbnVtVGlja3MgPSBtZS5fdGlja3MubGVuZ3RoO1xyXG5cdFx0dmFyIHRpY2tXaWR0aCA9IDEgLyBNYXRoLm1heChudW1UaWNrcyAtIChvZmZzZXQgPyAwIDogMSksIDEpO1xyXG5cclxuXHRcdHJldHVybiBpbmRleCA8IDAgfHwgaW5kZXggPiBudW1UaWNrcyAtIDFcclxuXHRcdFx0PyBudWxsXHJcblx0XHRcdDogbWUuZ2V0UGl4ZWxGb3JEZWNpbWFsKGluZGV4ICogdGlja1dpZHRoICsgKG9mZnNldCA/IHRpY2tXaWR0aCAvIDIgOiAwKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgcGl4ZWwgbG9jYXRpb24gb2YgYSBwZXJjZW50YWdlIG9mIHNjYWxlXHJcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXHJcblx0ICovXHJcblx0Z2V0UGl4ZWxGb3JEZWNpbWFsOiBmdW5jdGlvbihkZWNpbWFsKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cclxuXHRcdGlmIChtZS5fcmV2ZXJzZVBpeGVscykge1xyXG5cdFx0XHRkZWNpbWFsID0gMSAtIGRlY2ltYWw7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1lLl9zdGFydFBpeGVsICsgZGVjaW1hbCAqIG1lLl9sZW5ndGg7XHJcblx0fSxcclxuXHJcblx0Z2V0RGVjaW1hbEZvclBpeGVsOiBmdW5jdGlvbihwaXhlbCkge1xyXG5cdFx0dmFyIGRlY2ltYWwgPSAocGl4ZWwgLSB0aGlzLl9zdGFydFBpeGVsKSAvIHRoaXMuX2xlbmd0aDtcclxuXHRcdHJldHVybiB0aGlzLl9yZXZlcnNlUGl4ZWxzID8gMSAtIGRlY2ltYWwgOiBkZWNpbWFsO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHBpeGVsIGZvciB0aGUgbWluaW11bSBjaGFydCB2YWx1ZVxyXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xyXG5cdCAqL1xyXG5cdGdldEJhc2VQaXhlbDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xyXG5cdH0sXHJcblxyXG5cdGdldEJhc2VWYWx1ZTogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG1pbiA9IG1lLm1pbjtcclxuXHRcdHZhciBtYXggPSBtZS5tYXg7XHJcblxyXG5cdFx0cmV0dXJuIG1lLmJlZ2luQXRaZXJvID8gMCA6XHJcblx0XHRcdG1pbiA8IDAgJiYgbWF4IDwgMCA/IG1heCA6XHJcblx0XHRcdG1pbiA+IDAgJiYgbWF4ID4gMCA/IG1pbiA6XHJcblx0XHRcdDA7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHN1YnNldCBvZiB0aWNrcyB0byBiZSBwbG90dGVkIHRvIGF2b2lkIG92ZXJsYXBwaW5nIGxhYmVscy5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9hdXRvU2tpcDogZnVuY3Rpb24odGlja3MpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xyXG5cdFx0dmFyIGF4aXNMZW5ndGggPSBtZS5fbGVuZ3RoO1xyXG5cdFx0dmFyIHRpY2tzTGltaXQgPSB0aWNrT3B0cy5tYXhUaWNrc0xpbWl0IHx8IGF4aXNMZW5ndGggLyBtZS5fdGlja1NpemUoKSArIDE7XHJcblx0XHR2YXIgbWFqb3JJbmRpY2VzID0gdGlja09wdHMubWFqb3IuZW5hYmxlZCA/IGdldE1ham9ySW5kaWNlcyh0aWNrcykgOiBbXTtcclxuXHRcdHZhciBudW1NYWpvckluZGljZXMgPSBtYWpvckluZGljZXMubGVuZ3RoO1xyXG5cdFx0dmFyIGZpcnN0ID0gbWFqb3JJbmRpY2VzWzBdO1xyXG5cdFx0dmFyIGxhc3QgPSBtYWpvckluZGljZXNbbnVtTWFqb3JJbmRpY2VzIC0gMV07XHJcblx0XHR2YXIgaSwgaWxlbiwgc3BhY2luZywgYXZnTWFqb3JTcGFjaW5nO1xyXG5cclxuXHRcdC8vIElmIHRoZXJlIGFyZSB0b28gbWFueSBtYWpvciB0aWNrcyB0byBkaXNwbGF5IHRoZW0gYWxsXHJcblx0XHRpZiAobnVtTWFqb3JJbmRpY2VzID4gdGlja3NMaW1pdCkge1xyXG5cdFx0XHRza2lwTWFqb3JzKHRpY2tzLCBtYWpvckluZGljZXMsIG51bU1ham9ySW5kaWNlcyAvIHRpY2tzTGltaXQpO1xyXG5cdFx0XHRyZXR1cm4gbm9uU2tpcHBlZCh0aWNrcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0c3BhY2luZyA9IGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgYXhpc0xlbmd0aCwgdGlja3NMaW1pdCk7XHJcblxyXG5cdFx0aWYgKG51bU1ham9ySW5kaWNlcyA+IDApIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IG51bU1ham9ySW5kaWNlcyAtIDE7IGkgPCBpbGVuOyBpKyspIHtcclxuXHRcdFx0XHRza2lwKHRpY2tzLCBzcGFjaW5nLCBtYWpvckluZGljZXNbaV0sIG1ham9ySW5kaWNlc1tpICsgMV0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGF2Z01ham9yU3BhY2luZyA9IG51bU1ham9ySW5kaWNlcyA+IDEgPyAobGFzdCAtIGZpcnN0KSAvIChudW1NYWpvckluZGljZXMgLSAxKSA6IG51bGw7XHJcblx0XHRcdHNraXAodGlja3MsIHNwYWNpbmcsIGhlbHBlcnMkMS5pc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyAwIDogZmlyc3QgLSBhdmdNYWpvclNwYWNpbmcsIGZpcnN0KTtcclxuXHRcdFx0c2tpcCh0aWNrcywgc3BhY2luZywgbGFzdCwgaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoYXZnTWFqb3JTcGFjaW5nKSA/IHRpY2tzLmxlbmd0aCA6IGxhc3QgKyBhdmdNYWpvclNwYWNpbmcpO1xyXG5cdFx0XHRyZXR1cm4gbm9uU2tpcHBlZCh0aWNrcyk7XHJcblx0XHR9XHJcblx0XHRza2lwKHRpY2tzLCBzcGFjaW5nKTtcclxuXHRcdHJldHVybiBub25Ta2lwcGVkKHRpY2tzKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF90aWNrU2l6ZTogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdGlvblRpY2tzID0gbWUub3B0aW9ucy50aWNrcztcclxuXHJcblx0XHQvLyBDYWxjdWxhdGUgc3BhY2UgbmVlZGVkIGJ5IGxhYmVsIGluIGF4aXMgZGlyZWN0aW9uLlxyXG5cdFx0dmFyIHJvdCA9IGhlbHBlcnMkMS50b1JhZGlhbnMobWUubGFiZWxSb3RhdGlvbik7XHJcblx0XHR2YXIgY29zID0gTWF0aC5hYnMoTWF0aC5jb3Mocm90KSk7XHJcblx0XHR2YXIgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4ocm90KSk7XHJcblxyXG5cdFx0dmFyIGxhYmVsU2l6ZXMgPSBtZS5fZ2V0TGFiZWxTaXplcygpO1xyXG5cdFx0dmFyIHBhZGRpbmcgPSBvcHRpb25UaWNrcy5hdXRvU2tpcFBhZGRpbmcgfHwgMDtcclxuXHRcdHZhciB3ID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoICsgcGFkZGluZyA6IDA7XHJcblx0XHR2YXIgaCA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgcGFkZGluZyA6IDA7XHJcblxyXG5cdFx0Ly8gQ2FsY3VsYXRlIHNwYWNlIG5lZWRlZCBmb3IgMSB0aWNrIGluIGF4aXMgZGlyZWN0aW9uLlxyXG5cdFx0cmV0dXJuIG1lLmlzSG9yaXpvbnRhbCgpXHJcblx0XHRcdD8gaCAqIGNvcyA+IHcgKiBzaW4gPyB3IC8gY29zIDogaCAvIHNpblxyXG5cdFx0XHQ6IGggKiBzaW4gPCB3ICogY29zID8gaCAvIGNvcyA6IHcgLyBzaW47XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfaXNWaXNpYmxlOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBkaXNwbGF5ID0gbWUub3B0aW9ucy5kaXNwbGF5O1xyXG5cdFx0dmFyIGksIGlsZW4sIG1ldGE7XHJcblxyXG5cdFx0aWYgKGRpc3BsYXkgIT09ICdhdXRvJykge1xyXG5cdFx0XHRyZXR1cm4gISFkaXNwbGF5O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFdoZW4gJ2F1dG8nLCB0aGUgc2NhbGUgaXMgdmlzaWJsZSBpZiBhdCBsZWFzdCBvbmUgYXNzb2NpYXRlZCBkYXRhc2V0IGlzIHZpc2libGUuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcclxuXHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XHJcblx0XHRcdFx0aWYgKG1ldGEueEF4aXNJRCA9PT0gbWUuaWQgfHwgbWV0YS55QXhpc0lEID09PSBtZS5pZCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2NvbXB1dGVHcmlkTGluZUl0ZW1zOiBmdW5jdGlvbihjaGFydEFyZWEpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcclxuXHRcdHZhciBncmlkTGluZXMgPSBvcHRpb25zLmdyaWRMaW5lcztcclxuXHRcdHZhciBwb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XHJcblx0XHR2YXIgb2Zmc2V0R3JpZExpbmVzID0gZ3JpZExpbmVzLm9mZnNldEdyaWRMaW5lcztcclxuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcclxuXHRcdHZhciB0aWNrcyA9IG1lLl90aWNrc1RvRHJhdztcclxuXHRcdHZhciB0aWNrc0xlbmd0aCA9IHRpY2tzLmxlbmd0aCArIChvZmZzZXRHcmlkTGluZXMgPyAxIDogMCk7XHJcblxyXG5cdFx0dmFyIHRsID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZExpbmVzKTtcclxuXHRcdHZhciBpdGVtcyA9IFtdO1xyXG5cdFx0dmFyIGF4aXNXaWR0aCA9IGdyaWRMaW5lcy5kcmF3Qm9yZGVyID8gdmFsdWVBdEluZGV4T3JEZWZhdWx0KGdyaWRMaW5lcy5saW5lV2lkdGgsIDAsIDApIDogMDtcclxuXHRcdHZhciBheGlzSGFsZldpZHRoID0gYXhpc1dpZHRoIC8gMjtcclxuXHRcdHZhciBhbGlnblBpeGVsID0gaGVscGVycyQxLl9hbGlnblBpeGVsO1xyXG5cdFx0dmFyIGFsaWduQm9yZGVyVmFsdWUgPSBmdW5jdGlvbihwaXhlbCkge1xyXG5cdFx0XHRyZXR1cm4gYWxpZ25QaXhlbChjaGFydCwgcGl4ZWwsIGF4aXNXaWR0aCk7XHJcblx0XHR9O1xyXG5cdFx0dmFyIGJvcmRlclZhbHVlLCBpLCB0aWNrLCBsaW5lVmFsdWUsIGFsaWduZWRMaW5lVmFsdWU7XHJcblx0XHR2YXIgdHgxLCB0eTEsIHR4MiwgdHkyLCB4MSwgeTEsIHgyLCB5MiwgbGluZVdpZHRoLCBsaW5lQ29sb3IsIGJvcmRlckRhc2gsIGJvcmRlckRhc2hPZmZzZXQ7XHJcblxyXG5cdFx0aWYgKHBvc2l0aW9uID09PSAndG9wJykge1xyXG5cdFx0XHRib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUobWUuYm90dG9tKTtcclxuXHRcdFx0dHkxID0gbWUuYm90dG9tIC0gdGw7XHJcblx0XHRcdHR5MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcclxuXHRcdFx0eTEgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS50b3ApICsgYXhpc0hhbGZXaWR0aDtcclxuXHRcdFx0eTIgPSBjaGFydEFyZWEuYm90dG9tO1xyXG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcclxuXHRcdFx0Ym9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKG1lLnRvcCk7XHJcblx0XHRcdHkxID0gY2hhcnRBcmVhLnRvcDtcclxuXHRcdFx0eTIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5ib3R0b20pIC0gYXhpc0hhbGZXaWR0aDtcclxuXHRcdFx0dHkxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xyXG5cdFx0XHR0eTIgPSBtZS50b3AgKyB0bDtcclxuXHRcdH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xyXG5cdFx0XHRib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUobWUucmlnaHQpO1xyXG5cdFx0XHR0eDEgPSBtZS5yaWdodCAtIHRsO1xyXG5cdFx0XHR0eDIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XHJcblx0XHRcdHgxID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEubGVmdCkgKyBheGlzSGFsZldpZHRoO1xyXG5cdFx0XHR4MiA9IGNoYXJ0QXJlYS5yaWdodDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZShtZS5sZWZ0KTtcclxuXHRcdFx0eDEgPSBjaGFydEFyZWEubGVmdDtcclxuXHRcdFx0eDIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5yaWdodCkgLSBheGlzSGFsZldpZHRoO1xyXG5cdFx0XHR0eDEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XHJcblx0XHRcdHR4MiA9IG1lLmxlZnQgKyB0bDtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGlja3NMZW5ndGg7ICsraSkge1xyXG5cdFx0XHR0aWNrID0gdGlja3NbaV0gfHwge307XHJcblxyXG5cdFx0XHQvLyBhdXRvc2tpcHBlciBza2lwcGVkIHRoaXMgdGljayAoIzQ2MzUpXHJcblx0XHRcdGlmIChpc051bGxPclVuZGVmKHRpY2subGFiZWwpICYmIGkgPCB0aWNrcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGkgPT09IG1lLnplcm9MaW5lSW5kZXggJiYgb3B0aW9ucy5vZmZzZXQgPT09IG9mZnNldEdyaWRMaW5lcykge1xyXG5cdFx0XHRcdC8vIERyYXcgdGhlIGZpcnN0IGluZGV4IHNwZWNpYWxseVxyXG5cdFx0XHRcdGxpbmVXaWR0aCA9IGdyaWRMaW5lcy56ZXJvTGluZVdpZHRoO1xyXG5cdFx0XHRcdGxpbmVDb2xvciA9IGdyaWRMaW5lcy56ZXJvTGluZUNvbG9yO1xyXG5cdFx0XHRcdGJvcmRlckRhc2ggPSBncmlkTGluZXMuemVyb0xpbmVCb3JkZXJEYXNoIHx8IFtdO1xyXG5cdFx0XHRcdGJvcmRlckRhc2hPZmZzZXQgPSBncmlkTGluZXMuemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0IHx8IDAuMDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsaW5lV2lkdGggPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmxpbmVXaWR0aCwgaSwgMSk7XHJcblx0XHRcdFx0bGluZUNvbG9yID0gdmFsdWVBdEluZGV4T3JEZWZhdWx0KGdyaWRMaW5lcy5jb2xvciwgaSwgJ3JnYmEoMCwwLDAsMC4xKScpO1xyXG5cdFx0XHRcdGJvcmRlckRhc2ggPSBncmlkTGluZXMuYm9yZGVyRGFzaCB8fCBbXTtcclxuXHRcdFx0XHRib3JkZXJEYXNoT2Zmc2V0ID0gZ3JpZExpbmVzLmJvcmRlckRhc2hPZmZzZXQgfHwgMC4wO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsaW5lVmFsdWUgPSBnZXRQaXhlbEZvckdyaWRMaW5lKG1lLCB0aWNrLl9pbmRleCB8fCBpLCBvZmZzZXRHcmlkTGluZXMpO1xyXG5cclxuXHRcdFx0Ly8gU2tpcCBpZiB0aGUgcGl4ZWwgaXMgb3V0IG9mIHRoZSByYW5nZVxyXG5cdFx0XHRpZiAobGluZVZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YWxpZ25lZExpbmVWYWx1ZSA9IGFsaWduUGl4ZWwoY2hhcnQsIGxpbmVWYWx1ZSwgbGluZVdpZHRoKTtcclxuXHJcblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcclxuXHRcdFx0XHR0eDEgPSB0eDIgPSB4MSA9IHgyID0gYWxpZ25lZExpbmVWYWx1ZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0eTEgPSB0eTIgPSB5MSA9IHkyID0gYWxpZ25lZExpbmVWYWx1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aXRlbXMucHVzaCh7XHJcblx0XHRcdFx0dHgxOiB0eDEsXHJcblx0XHRcdFx0dHkxOiB0eTEsXHJcblx0XHRcdFx0dHgyOiB0eDIsXHJcblx0XHRcdFx0dHkyOiB0eTIsXHJcblx0XHRcdFx0eDE6IHgxLFxyXG5cdFx0XHRcdHkxOiB5MSxcclxuXHRcdFx0XHR4MjogeDIsXHJcblx0XHRcdFx0eTI6IHkyLFxyXG5cdFx0XHRcdHdpZHRoOiBsaW5lV2lkdGgsXHJcblx0XHRcdFx0Y29sb3I6IGxpbmVDb2xvcixcclxuXHRcdFx0XHRib3JkZXJEYXNoOiBib3JkZXJEYXNoLFxyXG5cdFx0XHRcdGJvcmRlckRhc2hPZmZzZXQ6IGJvcmRlckRhc2hPZmZzZXQsXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGl0ZW1zLnRpY2tzTGVuZ3RoID0gdGlja3NMZW5ndGg7XHJcblx0XHRpdGVtcy5ib3JkZXJWYWx1ZSA9IGJvcmRlclZhbHVlO1xyXG5cclxuXHRcdHJldHVybiBpdGVtcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9jb21wdXRlTGFiZWxJdGVtczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIG9wdGlvblRpY2tzID0gb3B0aW9ucy50aWNrcztcclxuXHRcdHZhciBwb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XHJcblx0XHR2YXIgaXNNaXJyb3JlZCA9IG9wdGlvblRpY2tzLm1pcnJvcjtcclxuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcclxuXHRcdHZhciB0aWNrcyA9IG1lLl90aWNrc1RvRHJhdztcclxuXHRcdHZhciBmb250cyA9IHBhcnNlVGlja0ZvbnRPcHRpb25zKG9wdGlvblRpY2tzKTtcclxuXHRcdHZhciB0aWNrUGFkZGluZyA9IG9wdGlvblRpY2tzLnBhZGRpbmc7XHJcblx0XHR2YXIgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWRMaW5lcyk7XHJcblx0XHR2YXIgcm90YXRpb24gPSAtaGVscGVycyQxLnRvUmFkaWFucyhtZS5sYWJlbFJvdGF0aW9uKTtcclxuXHRcdHZhciBpdGVtcyA9IFtdO1xyXG5cdFx0dmFyIGksIGlsZW4sIHRpY2ssIGxhYmVsLCB4LCB5LCB0ZXh0QWxpZ24sIHBpeGVsLCBmb250LCBsaW5lSGVpZ2h0LCBsaW5lQ291bnQsIHRleHRPZmZzZXQ7XHJcblxyXG5cdFx0aWYgKHBvc2l0aW9uID09PSAndG9wJykge1xyXG5cdFx0XHR5ID0gbWUuYm90dG9tIC0gdGwgLSB0aWNrUGFkZGluZztcclxuXHRcdFx0dGV4dEFsaWduID0gIXJvdGF0aW9uID8gJ2NlbnRlcicgOiAnbGVmdCc7XHJcblx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xyXG5cdFx0XHR5ID0gbWUudG9wICsgdGwgKyB0aWNrUGFkZGluZztcclxuXHRcdFx0dGV4dEFsaWduID0gIXJvdGF0aW9uID8gJ2NlbnRlcicgOiAncmlnaHQnO1xyXG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XHJcblx0XHRcdHggPSBtZS5yaWdodCAtIChpc01pcnJvcmVkID8gMCA6IHRsKSAtIHRpY2tQYWRkaW5nO1xyXG5cdFx0XHR0ZXh0QWxpZ24gPSBpc01pcnJvcmVkID8gJ2xlZnQnIDogJ3JpZ2h0JztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHggPSBtZS5sZWZ0ICsgKGlzTWlycm9yZWQgPyAwIDogdGwpICsgdGlja1BhZGRpbmc7XHJcblx0XHRcdHRleHRBbGlnbiA9IGlzTWlycm9yZWQgPyAncmlnaHQnIDogJ2xlZnQnO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0dGljayA9IHRpY2tzW2ldO1xyXG5cdFx0XHRsYWJlbCA9IHRpY2subGFiZWw7XHJcblxyXG5cdFx0XHQvLyBhdXRvc2tpcHBlciBza2lwcGVkIHRoaXMgdGljayAoIzQ2MzUpXHJcblx0XHRcdGlmIChpc051bGxPclVuZGVmKGxhYmVsKSkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwaXhlbCA9IG1lLmdldFBpeGVsRm9yVGljayh0aWNrLl9pbmRleCB8fCBpKSArIG9wdGlvblRpY2tzLmxhYmVsT2Zmc2V0O1xyXG5cdFx0XHRmb250ID0gdGljay5tYWpvciA/IGZvbnRzLm1ham9yIDogZm9udHMubWlub3I7XHJcblx0XHRcdGxpbmVIZWlnaHQgPSBmb250LmxpbmVIZWlnaHQ7XHJcblx0XHRcdGxpbmVDb3VudCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwubGVuZ3RoIDogMTtcclxuXHJcblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcclxuXHRcdFx0XHR4ID0gcGl4ZWw7XHJcblx0XHRcdFx0dGV4dE9mZnNldCA9IHBvc2l0aW9uID09PSAndG9wJ1xyXG5cdFx0XHRcdFx0PyAoKCFyb3RhdGlvbiA/IDAuNSA6IDEpIC0gbGluZUNvdW50KSAqIGxpbmVIZWlnaHRcclxuXHRcdFx0XHRcdDogKCFyb3RhdGlvbiA/IDAuNSA6IDApICogbGluZUhlaWdodDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR5ID0gcGl4ZWw7XHJcblx0XHRcdFx0dGV4dE9mZnNldCA9ICgxIC0gbGluZUNvdW50KSAqIGxpbmVIZWlnaHQgLyAyO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpdGVtcy5wdXNoKHtcclxuXHRcdFx0XHR4OiB4LFxyXG5cdFx0XHRcdHk6IHksXHJcblx0XHRcdFx0cm90YXRpb246IHJvdGF0aW9uLFxyXG5cdFx0XHRcdGxhYmVsOiBsYWJlbCxcclxuXHRcdFx0XHRmb250OiBmb250LFxyXG5cdFx0XHRcdHRleHRPZmZzZXQ6IHRleHRPZmZzZXQsXHJcblx0XHRcdFx0dGV4dEFsaWduOiB0ZXh0QWxpZ25cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGl0ZW1zO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2RyYXdHcmlkOiBmdW5jdGlvbihjaGFydEFyZWEpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgZ3JpZExpbmVzID0gbWUub3B0aW9ucy5ncmlkTGluZXM7XHJcblxyXG5cdFx0aWYgKCFncmlkTGluZXMuZGlzcGxheSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGN0eCA9IG1lLmN0eDtcclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIGFsaWduUGl4ZWwgPSBoZWxwZXJzJDEuX2FsaWduUGl4ZWw7XHJcblx0XHR2YXIgYXhpc1dpZHRoID0gZ3JpZExpbmVzLmRyYXdCb3JkZXIgPyB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmxpbmVXaWR0aCwgMCwgMCkgOiAwO1xyXG5cdFx0dmFyIGl0ZW1zID0gbWUuX2dyaWRMaW5lSXRlbXMgfHwgKG1lLl9ncmlkTGluZUl0ZW1zID0gbWUuX2NvbXB1dGVHcmlkTGluZUl0ZW1zKGNoYXJ0QXJlYSkpO1xyXG5cdFx0dmFyIHdpZHRoLCBjb2xvciwgaSwgaWxlbiwgaXRlbTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGl0ZW0gPSBpdGVtc1tpXTtcclxuXHRcdFx0d2lkdGggPSBpdGVtLndpZHRoO1xyXG5cdFx0XHRjb2xvciA9IGl0ZW0uY29sb3I7XHJcblxyXG5cdFx0XHRpZiAod2lkdGggJiYgY29sb3IpIHtcclxuXHRcdFx0XHRjdHguc2F2ZSgpO1xyXG5cdFx0XHRcdGN0eC5saW5lV2lkdGggPSB3aWR0aDtcclxuXHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcclxuXHRcdFx0XHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XHJcblx0XHRcdFx0XHRjdHguc2V0TGluZURhc2goaXRlbS5ib3JkZXJEYXNoKTtcclxuXHRcdFx0XHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IGl0ZW0uYm9yZGVyRGFzaE9mZnNldDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcclxuXHJcblx0XHRcdFx0aWYgKGdyaWRMaW5lcy5kcmF3VGlja3MpIHtcclxuXHRcdFx0XHRcdGN0eC5tb3ZlVG8oaXRlbS50eDEsIGl0ZW0udHkxKTtcclxuXHRcdFx0XHRcdGN0eC5saW5lVG8oaXRlbS50eDIsIGl0ZW0udHkyKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChncmlkTGluZXMuZHJhd09uQ2hhcnRBcmVhKSB7XHJcblx0XHRcdFx0XHRjdHgubW92ZVRvKGl0ZW0ueDEsIGl0ZW0ueTEpO1xyXG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyhpdGVtLngyLCBpdGVtLnkyKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcclxuXHRcdFx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGF4aXNXaWR0aCkge1xyXG5cdFx0XHQvLyBEcmF3IHRoZSBsaW5lIGF0IHRoZSBlZGdlIG9mIHRoZSBheGlzXHJcblx0XHRcdHZhciBmaXJzdExpbmVXaWR0aCA9IGF4aXNXaWR0aDtcclxuXHRcdFx0dmFyIGxhc3RMaW5lV2lkdGggPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmxpbmVXaWR0aCwgaXRlbXMudGlja3NMZW5ndGggLSAxLCAxKTtcclxuXHRcdFx0dmFyIGJvcmRlclZhbHVlID0gaXRlbXMuYm9yZGVyVmFsdWU7XHJcblx0XHRcdHZhciB4MSwgeDIsIHkxLCB5MjtcclxuXHJcblx0XHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xyXG5cdFx0XHRcdHgxID0gYWxpZ25QaXhlbChjaGFydCwgbWUubGVmdCwgZmlyc3RMaW5lV2lkdGgpIC0gZmlyc3RMaW5lV2lkdGggLyAyO1xyXG5cdFx0XHRcdHgyID0gYWxpZ25QaXhlbChjaGFydCwgbWUucmlnaHQsIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XHJcblx0XHRcdFx0eTEgPSB5MiA9IGJvcmRlclZhbHVlO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHkxID0gYWxpZ25QaXhlbChjaGFydCwgbWUudG9wLCBmaXJzdExpbmVXaWR0aCkgLSBmaXJzdExpbmVXaWR0aCAvIDI7XHJcblx0XHRcdFx0eTIgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5ib3R0b20sIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XHJcblx0XHRcdFx0eDEgPSB4MiA9IGJvcmRlclZhbHVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjdHgubGluZVdpZHRoID0gYXhpc1dpZHRoO1xyXG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmNvbG9yLCAwKTtcclxuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRjdHgubW92ZVRvKHgxLCB5MSk7XHJcblx0XHRcdGN0eC5saW5lVG8oeDIsIHkyKTtcclxuXHRcdFx0Y3R4LnN0cm9rZSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2RyYXdMYWJlbHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBvcHRpb25UaWNrcyA9IG1lLm9wdGlvbnMudGlja3M7XHJcblxyXG5cdFx0aWYgKCFvcHRpb25UaWNrcy5kaXNwbGF5KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgY3R4ID0gbWUuY3R4O1xyXG5cdFx0dmFyIGl0ZW1zID0gbWUuX2xhYmVsSXRlbXMgfHwgKG1lLl9sYWJlbEl0ZW1zID0gbWUuX2NvbXB1dGVMYWJlbEl0ZW1zKCkpO1xyXG5cdFx0dmFyIGksIGosIGlsZW4sIGpsZW4sIGl0ZW0sIHRpY2tGb250LCBsYWJlbCwgeTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGl0ZW0gPSBpdGVtc1tpXTtcclxuXHRcdFx0dGlja0ZvbnQgPSBpdGVtLmZvbnQ7XHJcblxyXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2UgZHJhdyB0ZXh0IGluIHRoZSBjb3JyZWN0IGNvbG9yIGFuZCBmb250XHJcblx0XHRcdGN0eC5zYXZlKCk7XHJcblx0XHRcdGN0eC50cmFuc2xhdGUoaXRlbS54LCBpdGVtLnkpO1xyXG5cdFx0XHRjdHgucm90YXRlKGl0ZW0ucm90YXRpb24pO1xyXG5cdFx0XHRjdHguZm9udCA9IHRpY2tGb250LnN0cmluZztcclxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRpY2tGb250LmNvbG9yO1xyXG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XHJcblx0XHRcdGN0eC50ZXh0QWxpZ24gPSBpdGVtLnRleHRBbGlnbjtcclxuXHJcblx0XHRcdGxhYmVsID0gaXRlbS5sYWJlbDtcclxuXHRcdFx0eSA9IGl0ZW0udGV4dE9mZnNldDtcclxuXHRcdFx0aWYgKGlzQXJyYXkobGFiZWwpKSB7XHJcblx0XHRcdFx0Zm9yIChqID0gMCwgamxlbiA9IGxhYmVsLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xyXG5cdFx0XHRcdFx0Ly8gV2UganVzdCBtYWtlIHN1cmUgdGhlIG11bHRpbGluZSBlbGVtZW50IGlzIGEgc3RyaW5nIGhlcmUuLlxyXG5cdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KCcnICsgbGFiZWxbal0sIDAsIHkpO1xyXG5cdFx0XHRcdFx0eSArPSB0aWNrRm9udC5saW5lSGVpZ2h0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjdHguZmlsbFRleHQobGFiZWwsIDAsIHkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGN0eC5yZXN0b3JlKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZHJhd1RpdGxlOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY3R4ID0gbWUuY3R4O1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIHNjYWxlTGFiZWwgPSBvcHRpb25zLnNjYWxlTGFiZWw7XHJcblxyXG5cdFx0aWYgKCFzY2FsZUxhYmVsLmRpc3BsYXkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzY2FsZUxhYmVsRm9udENvbG9yID0gdmFsdWVPckRlZmF1bHQkYShzY2FsZUxhYmVsLmZvbnRDb2xvciwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRDb2xvcik7XHJcblx0XHR2YXIgc2NhbGVMYWJlbEZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KHNjYWxlTGFiZWwpO1xyXG5cdFx0dmFyIHNjYWxlTGFiZWxQYWRkaW5nID0gaGVscGVycyQxLm9wdGlvbnMudG9QYWRkaW5nKHNjYWxlTGFiZWwucGFkZGluZyk7XHJcblx0XHR2YXIgaGFsZkxpbmVIZWlnaHQgPSBzY2FsZUxhYmVsRm9udC5saW5lSGVpZ2h0IC8gMjtcclxuXHRcdHZhciBwb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XHJcblx0XHR2YXIgcm90YXRpb24gPSAwO1xyXG5cdFx0dmFyIHNjYWxlTGFiZWxYLCBzY2FsZUxhYmVsWTtcclxuXHJcblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcclxuXHRcdFx0c2NhbGVMYWJlbFggPSBtZS5sZWZ0ICsgbWUud2lkdGggLyAyOyAvLyBtaWRwb2ludCBvZiB0aGUgd2lkdGhcclxuXHRcdFx0c2NhbGVMYWJlbFkgPSBwb3NpdGlvbiA9PT0gJ2JvdHRvbSdcclxuXHRcdFx0XHQ/IG1lLmJvdHRvbSAtIGhhbGZMaW5lSGVpZ2h0IC0gc2NhbGVMYWJlbFBhZGRpbmcuYm90dG9tXHJcblx0XHRcdFx0OiBtZS50b3AgKyBoYWxmTGluZUhlaWdodCArIHNjYWxlTGFiZWxQYWRkaW5nLnRvcDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBpc0xlZnQgPSBwb3NpdGlvbiA9PT0gJ2xlZnQnO1xyXG5cdFx0XHRzY2FsZUxhYmVsWCA9IGlzTGVmdFxyXG5cdFx0XHRcdD8gbWUubGVmdCArIGhhbGZMaW5lSGVpZ2h0ICsgc2NhbGVMYWJlbFBhZGRpbmcudG9wXHJcblx0XHRcdFx0OiBtZS5yaWdodCAtIGhhbGZMaW5lSGVpZ2h0IC0gc2NhbGVMYWJlbFBhZGRpbmcudG9wO1xyXG5cdFx0XHRzY2FsZUxhYmVsWSA9IG1lLnRvcCArIG1lLmhlaWdodCAvIDI7XHJcblx0XHRcdHJvdGF0aW9uID0gaXNMZWZ0ID8gLTAuNSAqIE1hdGguUEkgOiAwLjUgKiBNYXRoLlBJO1xyXG5cdFx0fVxyXG5cclxuXHRcdGN0eC5zYXZlKCk7XHJcblx0XHRjdHgudHJhbnNsYXRlKHNjYWxlTGFiZWxYLCBzY2FsZUxhYmVsWSk7XHJcblx0XHRjdHgucm90YXRlKHJvdGF0aW9uKTtcclxuXHRcdGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuXHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcclxuXHRcdGN0eC5maWxsU3R5bGUgPSBzY2FsZUxhYmVsRm9udENvbG9yOyAvLyByZW5kZXIgaW4gY29ycmVjdCBjb2xvdXJcclxuXHRcdGN0eC5mb250ID0gc2NhbGVMYWJlbEZvbnQuc3RyaW5nO1xyXG5cdFx0Y3R4LmZpbGxUZXh0KHNjYWxlTGFiZWwubGFiZWxTdHJpbmcsIDAsIDApO1xyXG5cdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHR9LFxyXG5cclxuXHRkcmF3OiBmdW5jdGlvbihjaGFydEFyZWEpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCFtZS5faXNWaXNpYmxlKCkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1lLl9kcmF3R3JpZChjaGFydEFyZWEpO1xyXG5cdFx0bWUuX2RyYXdUaXRsZSgpO1xyXG5cdFx0bWUuX2RyYXdMYWJlbHMoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9sYXllcnM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcclxuXHRcdHZhciB0eiA9IG9wdHMudGlja3MgJiYgb3B0cy50aWNrcy56IHx8IDA7XHJcblx0XHR2YXIgZ3ogPSBvcHRzLmdyaWRMaW5lcyAmJiBvcHRzLmdyaWRMaW5lcy56IHx8IDA7XHJcblxyXG5cdFx0aWYgKCFtZS5faXNWaXNpYmxlKCkgfHwgdHogPT09IGd6IHx8IG1lLmRyYXcgIT09IG1lLl9kcmF3KSB7XHJcblx0XHRcdC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IGRyYXcgaGFzIGJlZW4gb3ZlcnJpZGRlbiBieSBjdXN0b20gc2NhbGVcclxuXHRcdFx0cmV0dXJuIFt7XHJcblx0XHRcdFx0ejogdHosXHJcblx0XHRcdFx0ZHJhdzogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRtZS5kcmF3LmFwcGx5KG1lLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fV07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFt7XHJcblx0XHRcdHo6IGd6LFxyXG5cdFx0XHRkcmF3OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRtZS5fZHJhd0dyaWQuYXBwbHkobWUsIGFyZ3VtZW50cyk7XHJcblx0XHRcdFx0bWUuX2RyYXdUaXRsZS5hcHBseShtZSwgYXJndW1lbnRzKTtcclxuXHRcdFx0fVxyXG5cdFx0fSwge1xyXG5cdFx0XHR6OiB0eixcclxuXHRcdFx0ZHJhdzogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0bWUuX2RyYXdMYWJlbHMuYXBwbHkobWUsIGFyZ3VtZW50cyk7XHJcblx0XHRcdH1cclxuXHRcdH1dO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldE1hdGNoaW5nVmlzaWJsZU1ldGFzOiBmdW5jdGlvbih0eXBlKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xyXG5cdFx0cmV0dXJuIG1lLmNoYXJ0Ll9nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKClcclxuXHRcdFx0LmZpbHRlcihmdW5jdGlvbihtZXRhKSB7XHJcblx0XHRcdFx0cmV0dXJuICghdHlwZSB8fCBtZXRhLnR5cGUgPT09IHR5cGUpXHJcblx0XHRcdFx0XHQmJiAoaXNIb3Jpem9udGFsID8gbWV0YS54QXhpc0lEID09PSBtZS5pZCA6IG1ldGEueUF4aXNJRCA9PT0gbWUuaWQpO1xyXG5cdFx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuU2NhbGUucHJvdG90eXBlLl9kcmF3ID0gU2NhbGUucHJvdG90eXBlLmRyYXc7XHJcblxyXG52YXIgY29yZV9zY2FsZSA9IFNjYWxlO1xuXG52YXIgaXNOdWxsT3JVbmRlZiQxID0gaGVscGVycyQxLmlzTnVsbE9yVW5kZWY7XHJcblxyXG52YXIgZGVmYXVsdENvbmZpZyA9IHtcclxuXHRwb3NpdGlvbjogJ2JvdHRvbSdcclxufTtcclxuXHJcbnZhciBzY2FsZV9jYXRlZ29yeSA9IGNvcmVfc2NhbGUuZXh0ZW5kKHtcclxuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbGFiZWxzID0gbWUuX2dldExhYmVscygpO1xyXG5cdFx0dmFyIHRpY2tzT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XHJcblx0XHR2YXIgbWluID0gdGlja3NPcHRzLm1pbjtcclxuXHRcdHZhciBtYXggPSB0aWNrc09wdHMubWF4O1xyXG5cdFx0dmFyIG1pbkluZGV4ID0gMDtcclxuXHRcdHZhciBtYXhJbmRleCA9IGxhYmVscy5sZW5ndGggLSAxO1xyXG5cdFx0dmFyIGZpbmRJbmRleDtcclxuXHJcblx0XHRpZiAobWluICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Ly8gdXNlciBzcGVjaWZpZWQgbWluIHZhbHVlXHJcblx0XHRcdGZpbmRJbmRleCA9IGxhYmVscy5pbmRleE9mKG1pbik7XHJcblx0XHRcdGlmIChmaW5kSW5kZXggPj0gMCkge1xyXG5cdFx0XHRcdG1pbkluZGV4ID0gZmluZEluZGV4O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1heCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdC8vIHVzZXIgc3BlY2lmaWVkIG1heCB2YWx1ZVxyXG5cdFx0XHRmaW5kSW5kZXggPSBsYWJlbHMuaW5kZXhPZihtYXgpO1xyXG5cdFx0XHRpZiAoZmluZEluZGV4ID49IDApIHtcclxuXHRcdFx0XHRtYXhJbmRleCA9IGZpbmRJbmRleDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG1lLm1pbkluZGV4ID0gbWluSW5kZXg7XHJcblx0XHRtZS5tYXhJbmRleCA9IG1heEluZGV4O1xyXG5cdFx0bWUubWluID0gbGFiZWxzW21pbkluZGV4XTtcclxuXHRcdG1lLm1heCA9IGxhYmVsc1ttYXhJbmRleF07XHJcblx0fSxcclxuXHJcblx0YnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGxhYmVscyA9IG1lLl9nZXRMYWJlbHMoKTtcclxuXHRcdHZhciBtaW5JbmRleCA9IG1lLm1pbkluZGV4O1xyXG5cdFx0dmFyIG1heEluZGV4ID0gbWUubWF4SW5kZXg7XHJcblxyXG5cdFx0Ly8gSWYgd2UgYXJlIHZpZXdpbmcgc29tZSBzdWJzZXQgb2YgbGFiZWxzLCBzbGljZSB0aGUgb3JpZ2luYWwgYXJyYXlcclxuXHRcdG1lLnRpY2tzID0gKG1pbkluZGV4ID09PSAwICYmIG1heEluZGV4ID09PSBsYWJlbHMubGVuZ3RoIC0gMSkgPyBsYWJlbHMgOiBsYWJlbHMuc2xpY2UobWluSW5kZXgsIG1heEluZGV4ICsgMSk7XHJcblx0fSxcclxuXHJcblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cclxuXHRcdGlmIChjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIuX2dldFZhbHVlU2NhbGVJZCgpID09PSBtZS5pZCkge1xyXG5cdFx0XHRyZXR1cm4gbWUuZ2V0UmlnaHRWYWx1ZShjaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtZS5fZ2V0TGFiZWxzKClbaW5kZXhdO1xyXG5cdH0sXHJcblxyXG5cdF9jb25maWd1cmU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBvZmZzZXQgPSBtZS5vcHRpb25zLm9mZnNldDtcclxuXHRcdHZhciB0aWNrcyA9IG1lLnRpY2tzO1xyXG5cclxuXHRcdGNvcmVfc2NhbGUucHJvdG90eXBlLl9jb25maWd1cmUuY2FsbChtZSk7XHJcblxyXG5cdFx0aWYgKCFtZS5pc0hvcml6b250YWwoKSkge1xyXG5cdFx0XHQvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdmVydGljYWwgY2F0ZWdvcnkgc2NhbGUgcmV2ZXJzZSBpcyBpbnZlcnRlZC5cclxuXHRcdFx0bWUuX3JldmVyc2VQaXhlbHMgPSAhbWUuX3JldmVyc2VQaXhlbHM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aWNrcykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bWUuX3N0YXJ0VmFsdWUgPSBtZS5taW5JbmRleCAtIChvZmZzZXQgPyAwLjUgOiAwKTtcclxuXHRcdG1lLl92YWx1ZVJhbmdlID0gTWF0aC5tYXgodGlja3MubGVuZ3RoIC0gKG9mZnNldCA/IDAgOiAxKSwgMSk7XHJcblx0fSxcclxuXHJcblx0Ly8gVXNlZCB0byBnZXQgZGF0YSB2YWx1ZSBsb2NhdGlvbnMuICBWYWx1ZSBjYW4gZWl0aGVyIGJlIGFuIGluZGV4IG9yIGEgbnVtZXJpY2FsIHZhbHVlXHJcblx0Z2V0UGl4ZWxGb3JWYWx1ZTogZnVuY3Rpb24odmFsdWUsIGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgdmFsdWVDYXRlZ29yeSwgbGFiZWxzLCBpZHg7XHJcblxyXG5cdFx0aWYgKCFpc051bGxPclVuZGVmJDEoaW5kZXgpICYmICFpc051bGxPclVuZGVmJDEoZGF0YXNldEluZGV4KSkge1xyXG5cdFx0XHR2YWx1ZSA9IG1lLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJZiB2YWx1ZSBpcyBhIGRhdGEgb2JqZWN0LCB0aGVuIGluZGV4IGlzIHRoZSBpbmRleCBpbiB0aGUgZGF0YSBhcnJheSxcclxuXHRcdC8vIG5vdCB0aGUgaW5kZXggb2YgdGhlIHNjYWxlLiBXZSBuZWVkIHRvIGNoYW5nZSB0aGF0LlxyXG5cdFx0aWYgKCFpc051bGxPclVuZGVmJDEodmFsdWUpKSB7XHJcblx0XHRcdHZhbHVlQ2F0ZWdvcnkgPSBtZS5pc0hvcml6b250YWwoKSA/IHZhbHVlLnggOiB2YWx1ZS55O1xyXG5cdFx0fVxyXG5cdFx0aWYgKHZhbHVlQ2F0ZWdvcnkgIT09IHVuZGVmaW5lZCB8fCAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBpc05hTihpbmRleCkpKSB7XHJcblx0XHRcdGxhYmVscyA9IG1lLl9nZXRMYWJlbHMoKTtcclxuXHRcdFx0dmFsdWUgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQodmFsdWVDYXRlZ29yeSwgdmFsdWUpO1xyXG5cdFx0XHRpZHggPSBsYWJlbHMuaW5kZXhPZih2YWx1ZSk7XHJcblx0XHRcdGluZGV4ID0gaWR4ICE9PSAtMSA/IGlkeCA6IGluZGV4O1xyXG5cdFx0XHRpZiAoaXNOYU4oaW5kZXgpKSB7XHJcblx0XHRcdFx0aW5kZXggPSB2YWx1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG1lLmdldFBpeGVsRm9yRGVjaW1hbCgoaW5kZXggLSBtZS5fc3RhcnRWYWx1ZSkgLyBtZS5fdmFsdWVSYW5nZSk7XHJcblx0fSxcclxuXHJcblx0Z2V0UGl4ZWxGb3JUaWNrOiBmdW5jdGlvbihpbmRleCkge1xyXG5cdFx0dmFyIHRpY2tzID0gdGhpcy50aWNrcztcclxuXHRcdHJldHVybiBpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxXHJcblx0XHRcdD8gbnVsbFxyXG5cdFx0XHQ6IHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0sIGluZGV4ICsgdGhpcy5taW5JbmRleCk7XHJcblx0fSxcclxuXHJcblx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgdmFsdWUgPSBNYXRoLnJvdW5kKG1lLl9zdGFydFZhbHVlICsgbWUuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIG1lLl92YWx1ZVJhbmdlKTtcclxuXHRcdHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgMCksIG1lLnRpY2tzLmxlbmd0aCAtIDEpO1xyXG5cdH0sXHJcblxyXG5cdGdldEJhc2VQaXhlbDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5ib3R0b207XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIElOVEVSTkFMOiBzdGF0aWMgZGVmYXVsdCBvcHRpb25zLCByZWdpc3RlcmVkIGluIHNyYy9pbmRleC5qc1xyXG52YXIgX2RlZmF1bHRzID0gZGVmYXVsdENvbmZpZztcbnNjYWxlX2NhdGVnb3J5Ll9kZWZhdWx0cyA9IF9kZWZhdWx0cztcblxudmFyIG5vb3AgPSBoZWxwZXJzJDEubm9vcDtcclxudmFyIGlzTnVsbE9yVW5kZWYkMiA9IGhlbHBlcnMkMS5pc051bGxPclVuZGVmO1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIGEgc2V0IG9mIGxpbmVhciB0aWNrc1xyXG4gKiBAcGFyYW0gZ2VuZXJhdGlvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGlja3NcclxuICogQHBhcmFtIGRhdGFSYW5nZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcclxuICogQHJldHVybnMge251bWJlcltdfSBhcnJheSBvZiB0aWNrIHZhbHVlc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XHJcblx0dmFyIHRpY2tzID0gW107XHJcblx0Ly8gVG8gZ2V0IGEgXCJuaWNlXCIgdmFsdWUgZm9yIHRoZSB0aWNrIHNwYWNpbmcsIHdlIHdpbGwgdXNlIHRoZSBhcHByb3ByaWF0ZWx5IG5hbWVkXHJcblx0Ly8gXCJuaWNlIG51bWJlclwiIGFsZ29yaXRobS4gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg1MDY4ODEvbmljZS1sYWJlbC1hbGdvcml0aG0tZm9yLWNoYXJ0cy13aXRoLW1pbmltdW0tdGlja3NcclxuXHQvLyBmb3IgZGV0YWlscy5cclxuXHJcblx0dmFyIE1JTl9TUEFDSU5HID0gMWUtMTQ7XHJcblx0dmFyIHN0ZXBTaXplID0gZ2VuZXJhdGlvbk9wdGlvbnMuc3RlcFNpemU7XHJcblx0dmFyIHVuaXQgPSBzdGVwU2l6ZSB8fCAxO1xyXG5cdHZhciBtYXhOdW1TcGFjZXMgPSBnZW5lcmF0aW9uT3B0aW9ucy5tYXhUaWNrcyAtIDE7XHJcblx0dmFyIG1pbiA9IGdlbmVyYXRpb25PcHRpb25zLm1pbjtcclxuXHR2YXIgbWF4ID0gZ2VuZXJhdGlvbk9wdGlvbnMubWF4O1xyXG5cdHZhciBwcmVjaXNpb24gPSBnZW5lcmF0aW9uT3B0aW9ucy5wcmVjaXNpb247XHJcblx0dmFyIHJtaW4gPSBkYXRhUmFuZ2UubWluO1xyXG5cdHZhciBybWF4ID0gZGF0YVJhbmdlLm1heDtcclxuXHR2YXIgc3BhY2luZyA9IGhlbHBlcnMkMS5uaWNlTnVtKChybWF4IC0gcm1pbikgLyBtYXhOdW1TcGFjZXMgLyB1bml0KSAqIHVuaXQ7XHJcblx0dmFyIGZhY3RvciwgbmljZU1pbiwgbmljZU1heCwgbnVtU3BhY2VzO1xyXG5cclxuXHQvLyBCZXlvbmQgTUlOX1NQQUNJTkcgZmxvYXRpbmcgcG9pbnQgbnVtYmVycyBiZWluZyB0byBsb3NlIHByZWNpc2lvblxyXG5cdC8vIHN1Y2ggdGhhdCB3ZSBjYW4ndCBkbyB0aGUgbWF0aCBuZWNlc3NhcnkgdG8gZ2VuZXJhdGUgdGlja3NcclxuXHRpZiAoc3BhY2luZyA8IE1JTl9TUEFDSU5HICYmIGlzTnVsbE9yVW5kZWYkMihtaW4pICYmIGlzTnVsbE9yVW5kZWYkMihtYXgpKSB7XHJcblx0XHRyZXR1cm4gW3JtaW4sIHJtYXhdO1xyXG5cdH1cclxuXHJcblx0bnVtU3BhY2VzID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAtIE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpO1xyXG5cdGlmIChudW1TcGFjZXMgPiBtYXhOdW1TcGFjZXMpIHtcclxuXHRcdC8vIElmIHRoZSBjYWxjdWxhdGVkIG51bSBvZiBzcGFjZXMgZXhjZWVkcyBtYXhOdW1TcGFjZXMsIHJlY2FsY3VsYXRlIGl0XHJcblx0XHRzcGFjaW5nID0gaGVscGVycyQxLm5pY2VOdW0obnVtU3BhY2VzICogc3BhY2luZyAvIG1heE51bVNwYWNlcyAvIHVuaXQpICogdW5pdDtcclxuXHR9XHJcblxyXG5cdGlmIChzdGVwU2l6ZSB8fCBpc051bGxPclVuZGVmJDIocHJlY2lzaW9uKSkge1xyXG5cdFx0Ly8gSWYgYSBwcmVjaXNpb24gaXMgbm90IHNwZWNpZmllZCwgY2FsY3VsYXRlIGZhY3RvciBiYXNlZCBvbiBzcGFjaW5nXHJcblx0XHRmYWN0b3IgPSBNYXRoLnBvdygxMCwgaGVscGVycyQxLl9kZWNpbWFsUGxhY2VzKHNwYWNpbmcpKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gSWYgdGhlIHVzZXIgc3BlY2lmaWVkIGEgcHJlY2lzaW9uLCByb3VuZCB0byB0aGF0IG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xyXG5cdFx0ZmFjdG9yID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XHJcblx0XHRzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcgKiBmYWN0b3IpIC8gZmFjdG9yO1xyXG5cdH1cclxuXHJcblx0bmljZU1pbiA9IE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpICogc3BhY2luZztcclxuXHRuaWNlTWF4ID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAqIHNwYWNpbmc7XHJcblxyXG5cdC8vIElmIG1pbiwgbWF4IGFuZCBzdGVwU2l6ZSBpcyBzZXQgYW5kIHRoZXkgbWFrZSBhbiBldmVubHkgc3BhY2VkIHNjYWxlIHVzZSBpdC5cclxuXHRpZiAoc3RlcFNpemUpIHtcclxuXHRcdC8vIElmIHZlcnkgY2xvc2UgdG8gb3VyIHdob2xlIG51bWJlciwgdXNlIGl0LlxyXG5cdFx0aWYgKCFpc051bGxPclVuZGVmJDIobWluKSAmJiBoZWxwZXJzJDEuYWxtb3N0V2hvbGUobWluIC8gc3BhY2luZywgc3BhY2luZyAvIDEwMDApKSB7XHJcblx0XHRcdG5pY2VNaW4gPSBtaW47XHJcblx0XHR9XHJcblx0XHRpZiAoIWlzTnVsbE9yVW5kZWYkMihtYXgpICYmIGhlbHBlcnMkMS5hbG1vc3RXaG9sZShtYXggLyBzcGFjaW5nLCBzcGFjaW5nIC8gMTAwMCkpIHtcclxuXHRcdFx0bmljZU1heCA9IG1heDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdG51bVNwYWNlcyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBzcGFjaW5nO1xyXG5cdC8vIElmIHZlcnkgY2xvc2UgdG8gb3VyIHJvdW5kZWQgdmFsdWUsIHVzZSBpdC5cclxuXHRpZiAoaGVscGVycyQxLmFsbW9zdEVxdWFscyhudW1TcGFjZXMsIE1hdGgucm91bmQobnVtU3BhY2VzKSwgc3BhY2luZyAvIDEwMDApKSB7XHJcblx0XHRudW1TcGFjZXMgPSBNYXRoLnJvdW5kKG51bVNwYWNlcyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdG51bVNwYWNlcyA9IE1hdGguY2VpbChudW1TcGFjZXMpO1xyXG5cdH1cclxuXHJcblx0bmljZU1pbiA9IE1hdGgucm91bmQobmljZU1pbiAqIGZhY3RvcikgLyBmYWN0b3I7XHJcblx0bmljZU1heCA9IE1hdGgucm91bmQobmljZU1heCAqIGZhY3RvcikgLyBmYWN0b3I7XHJcblx0dGlja3MucHVzaChpc051bGxPclVuZGVmJDIobWluKSA/IG5pY2VNaW4gOiBtaW4pO1xyXG5cdGZvciAodmFyIGogPSAxOyBqIDwgbnVtU3BhY2VzOyArK2opIHtcclxuXHRcdHRpY2tzLnB1c2goTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3IpO1xyXG5cdH1cclxuXHR0aWNrcy5wdXNoKGlzTnVsbE9yVW5kZWYkMihtYXgpID8gbmljZU1heCA6IG1heCk7XHJcblxyXG5cdHJldHVybiB0aWNrcztcclxufVxyXG5cclxudmFyIHNjYWxlX2xpbmVhcmJhc2UgPSBjb3JlX3NjYWxlLmV4dGVuZCh7XHJcblx0Z2V0UmlnaHRWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdHJldHVybiArdmFsdWU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY29yZV9zY2FsZS5wcm90b3R5cGUuZ2V0UmlnaHRWYWx1ZS5jYWxsKHRoaXMsIHZhbHVlKTtcclxuXHR9LFxyXG5cclxuXHRoYW5kbGVUaWNrUmFuZ2VPcHRpb25zOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XHJcblx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xyXG5cclxuXHRcdC8vIElmIHdlIGFyZSBmb3JjaW5nIGl0IHRvIGJlZ2luIGF0IDAsIGJ1dCAwIHdpbGwgYWxyZWFkeSBiZSByZW5kZXJlZCBvbiB0aGUgY2hhcnQsXHJcblx0XHQvLyBkbyBub3RoaW5nIHNpbmNlIHRoYXQgd291bGQgbWFrZSB0aGUgY2hhcnQgd2VpcmQuIElmIHRoZSB1c2VyIHJlYWxseSB3YW50cyBhIHdlaXJkIGNoYXJ0XHJcblx0XHQvLyBheGlzLCB0aGV5IGNhbiBtYW51YWxseSBvdmVycmlkZSBpdFxyXG5cdFx0aWYgKHRpY2tPcHRzLmJlZ2luQXRaZXJvKSB7XHJcblx0XHRcdHZhciBtaW5TaWduID0gaGVscGVycyQxLnNpZ24obWUubWluKTtcclxuXHRcdFx0dmFyIG1heFNpZ24gPSBoZWxwZXJzJDEuc2lnbihtZS5tYXgpO1xyXG5cclxuXHRcdFx0aWYgKG1pblNpZ24gPCAwICYmIG1heFNpZ24gPCAwKSB7XHJcblx0XHRcdFx0Ly8gbW92ZSB0aGUgdG9wIHVwIHRvIDBcclxuXHRcdFx0XHRtZS5tYXggPSAwO1xyXG5cdFx0XHR9IGVsc2UgaWYgKG1pblNpZ24gPiAwICYmIG1heFNpZ24gPiAwKSB7XHJcblx0XHRcdFx0Ly8gbW92ZSB0aGUgYm90dG9tIGRvd24gdG8gMFxyXG5cdFx0XHRcdG1lLm1pbiA9IDA7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc2V0TWluID0gdGlja09wdHMubWluICE9PSB1bmRlZmluZWQgfHwgdGlja09wdHMuc3VnZ2VzdGVkTWluICE9PSB1bmRlZmluZWQ7XHJcblx0XHR2YXIgc2V0TWF4ID0gdGlja09wdHMubWF4ICE9PSB1bmRlZmluZWQgfHwgdGlja09wdHMuc3VnZ2VzdGVkTWF4ICE9PSB1bmRlZmluZWQ7XHJcblxyXG5cdFx0aWYgKHRpY2tPcHRzLm1pbiAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdG1lLm1pbiA9IHRpY2tPcHRzLm1pbjtcclxuXHRcdH0gZWxzZSBpZiAodGlja09wdHMuc3VnZ2VzdGVkTWluICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0aWYgKG1lLm1pbiA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdG1lLm1pbiA9IHRpY2tPcHRzLnN1Z2dlc3RlZE1pbjtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRtZS5taW4gPSBNYXRoLm1pbihtZS5taW4sIHRpY2tPcHRzLnN1Z2dlc3RlZE1pbik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGlja09wdHMubWF4ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0bWUubWF4ID0gdGlja09wdHMubWF4O1xyXG5cdFx0fSBlbHNlIGlmICh0aWNrT3B0cy5zdWdnZXN0ZWRNYXggIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRpZiAobWUubWF4ID09PSBudWxsKSB7XHJcblx0XHRcdFx0bWUubWF4ID0gdGlja09wdHMuc3VnZ2VzdGVkTWF4O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG1lLm1heCA9IE1hdGgubWF4KG1lLm1heCwgdGlja09wdHMuc3VnZ2VzdGVkTWF4KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzZXRNaW4gIT09IHNldE1heCkge1xyXG5cdFx0XHQvLyBXZSBzZXQgdGhlIG1pbiBvciB0aGUgbWF4IGJ1dCBub3QgYm90aC5cclxuXHRcdFx0Ly8gU28gZW5zdXJlIHRoYXQgb3VyIHJhbmdlIGlzIGdvb2RcclxuXHRcdFx0Ly8gSW52ZXJ0ZWQgb3IgMCBsZW5ndGggcmFuZ2UgY2FuIGhhcHBlbiB3aGVuXHJcblx0XHRcdC8vIHRpY2tzLm1pbiBpcyBzZXQsIGFuZCBubyBkYXRhc2V0cyBhcmUgdmlzaWJsZVxyXG5cdFx0XHRpZiAobWUubWluID49IG1lLm1heCkge1xyXG5cdFx0XHRcdGlmIChzZXRNaW4pIHtcclxuXHRcdFx0XHRcdG1lLm1heCA9IG1lLm1pbiArIDE7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdG1lLm1pbiA9IG1lLm1heCAtIDE7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1lLm1pbiA9PT0gbWUubWF4KSB7XHJcblx0XHRcdG1lLm1heCsrO1xyXG5cclxuXHRcdFx0aWYgKCF0aWNrT3B0cy5iZWdpbkF0WmVybykge1xyXG5cdFx0XHRcdG1lLm1pbi0tO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0VGlja0xpbWl0OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xyXG5cdFx0dmFyIHN0ZXBTaXplID0gdGlja09wdHMuc3RlcFNpemU7XHJcblx0XHR2YXIgbWF4VGlja3NMaW1pdCA9IHRpY2tPcHRzLm1heFRpY2tzTGltaXQ7XHJcblx0XHR2YXIgbWF4VGlja3M7XHJcblxyXG5cdFx0aWYgKHN0ZXBTaXplKSB7XHJcblx0XHRcdG1heFRpY2tzID0gTWF0aC5jZWlsKG1lLm1heCAvIHN0ZXBTaXplKSAtIE1hdGguZmxvb3IobWUubWluIC8gc3RlcFNpemUpICsgMTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1heFRpY2tzID0gbWUuX2NvbXB1dGVUaWNrTGltaXQoKTtcclxuXHRcdFx0bWF4VGlja3NMaW1pdCA9IG1heFRpY2tzTGltaXQgfHwgMTE7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1heFRpY2tzTGltaXQpIHtcclxuXHRcdFx0bWF4VGlja3MgPSBNYXRoLm1pbihtYXhUaWNrc0xpbWl0LCBtYXhUaWNrcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1heFRpY2tzO1xyXG5cdH0sXHJcblxyXG5cdF9jb21wdXRlVGlja0xpbWl0OiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcblx0fSxcclxuXHJcblx0aGFuZGxlRGlyZWN0aW9uYWxDaGFuZ2VzOiBub29wLFxyXG5cclxuXHRidWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XHJcblx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xyXG5cclxuXHRcdC8vIEZpZ3VyZSBvdXQgd2hhdCB0aGUgbWF4IG51bWJlciBvZiB0aWNrcyB3ZSBjYW4gc3VwcG9ydCBpdCBpcyBiYXNlZCBvbiB0aGUgc2l6ZSBvZlxyXG5cdFx0Ly8gdGhlIGF4aXMgYXJlYS4gRm9yIG5vdywgd2Ugc2F5IHRoYXQgdGhlIG1pbmltdW0gdGljayBzcGFjaW5nIGluIHBpeGVscyBtdXN0IGJlIDQwXHJcblx0XHQvLyBXZSBhbHNvIGxpbWl0IHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyB0byAxMSB3aGljaCBnaXZlcyBhIG5pY2UgMTAgc3F1YXJlcyBvblxyXG5cdFx0Ly8gdGhlIGdyYXBoLiBNYWtlIHN1cmUgd2UgYWx3YXlzIGhhdmUgYXQgbGVhc3QgMiB0aWNrc1xyXG5cdFx0dmFyIG1heFRpY2tzID0gbWUuZ2V0VGlja0xpbWl0KCk7XHJcblx0XHRtYXhUaWNrcyA9IE1hdGgubWF4KDIsIG1heFRpY2tzKTtcclxuXHJcblx0XHR2YXIgbnVtZXJpY0dlbmVyYXRvck9wdGlvbnMgPSB7XHJcblx0XHRcdG1heFRpY2tzOiBtYXhUaWNrcyxcclxuXHRcdFx0bWluOiB0aWNrT3B0cy5taW4sXHJcblx0XHRcdG1heDogdGlja09wdHMubWF4LFxyXG5cdFx0XHRwcmVjaXNpb246IHRpY2tPcHRzLnByZWNpc2lvbixcclxuXHRcdFx0c3RlcFNpemU6IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5maXhlZFN0ZXBTaXplLCB0aWNrT3B0cy5zdGVwU2l6ZSlcclxuXHRcdH07XHJcblx0XHR2YXIgdGlja3MgPSBtZS50aWNrcyA9IGdlbmVyYXRlVGlja3MobnVtZXJpY0dlbmVyYXRvck9wdGlvbnMsIG1lKTtcclxuXHJcblx0XHRtZS5oYW5kbGVEaXJlY3Rpb25hbENoYW5nZXMoKTtcclxuXHJcblx0XHQvLyBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIHRvIHVwZGF0ZSBvdXIgbWF4IGFuZCBtaW4gZ2l2ZW4gdGhlIHRpY2sgdmFsdWVzIHNpbmNlIHdlIGhhdmUgZXhwYW5kZWQgdGhlXHJcblx0XHQvLyByYW5nZSBvZiB0aGUgc2NhbGVcclxuXHRcdG1lLm1heCA9IGhlbHBlcnMkMS5tYXgodGlja3MpO1xyXG5cdFx0bWUubWluID0gaGVscGVycyQxLm1pbih0aWNrcyk7XHJcblxyXG5cdFx0aWYgKHRpY2tPcHRzLnJldmVyc2UpIHtcclxuXHRcdFx0dGlja3MucmV2ZXJzZSgpO1xyXG5cclxuXHRcdFx0bWUuc3RhcnQgPSBtZS5tYXg7XHJcblx0XHRcdG1lLmVuZCA9IG1lLm1pbjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1lLnN0YXJ0ID0gbWUubWluO1xyXG5cdFx0XHRtZS5lbmQgPSBtZS5tYXg7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Y29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdG1lLnRpY2tzQXNOdW1iZXJzID0gbWUudGlja3Muc2xpY2UoKTtcclxuXHRcdG1lLnplcm9MaW5lSW5kZXggPSBtZS50aWNrcy5pbmRleE9mKDApO1xyXG5cclxuXHRcdGNvcmVfc2NhbGUucHJvdG90eXBlLmNvbnZlcnRUaWNrc1RvTGFiZWxzLmNhbGwobWUpO1xyXG5cdH0sXHJcblxyXG5cdF9jb25maWd1cmU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciB0aWNrcyA9IG1lLmdldFRpY2tzKCk7XHJcblx0XHR2YXIgc3RhcnQgPSBtZS5taW47XHJcblx0XHR2YXIgZW5kID0gbWUubWF4O1xyXG5cdFx0dmFyIG9mZnNldDtcclxuXHJcblx0XHRjb3JlX3NjYWxlLnByb3RvdHlwZS5fY29uZmlndXJlLmNhbGwobWUpO1xyXG5cclxuXHRcdGlmIChtZS5vcHRpb25zLm9mZnNldCAmJiB0aWNrcy5sZW5ndGgpIHtcclxuXHRcdFx0b2Zmc2V0ID0gKGVuZCAtIHN0YXJ0KSAvIE1hdGgubWF4KHRpY2tzLmxlbmd0aCAtIDEsIDEpIC8gMjtcclxuXHRcdFx0c3RhcnQgLT0gb2Zmc2V0O1xyXG5cdFx0XHRlbmQgKz0gb2Zmc2V0O1xyXG5cdFx0fVxyXG5cdFx0bWUuX3N0YXJ0VmFsdWUgPSBzdGFydDtcclxuXHRcdG1lLl9lbmRWYWx1ZSA9IGVuZDtcclxuXHRcdG1lLl92YWx1ZVJhbmdlID0gZW5kIC0gc3RhcnQ7XHJcblx0fVxyXG59KTtcblxudmFyIGRlZmF1bHRDb25maWckMSA9IHtcclxuXHRwb3NpdGlvbjogJ2xlZnQnLFxyXG5cdHRpY2tzOiB7XHJcblx0XHRjYWxsYmFjazogY29yZV90aWNrcy5mb3JtYXR0ZXJzLmxpbmVhclxyXG5cdH1cclxufTtcclxuXHJcbnZhciBERUZBVUxUX01JTiA9IDA7XHJcbnZhciBERUZBVUxUX01BWCA9IDE7XHJcblxyXG5mdW5jdGlvbiBnZXRPckNyZWF0ZVN0YWNrKHN0YWNrcywgc3RhY2tlZCwgbWV0YSkge1xyXG5cdHZhciBrZXkgPSBbXHJcblx0XHRtZXRhLnR5cGUsXHJcblx0XHQvLyB3ZSBoYXZlIGEgc2VwYXJhdGUgc3RhY2sgZm9yIHN0YWNrPXVuZGVmaW5lZCBkYXRhc2V0cyB3aGVuIHRoZSBvcHRzLnN0YWNrZWQgaXMgdW5kZWZpbmVkXHJcblx0XHRzdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayA9PT0gdW5kZWZpbmVkID8gbWV0YS5pbmRleCA6ICcnLFxyXG5cdFx0bWV0YS5zdGFja1xyXG5cdF0uam9pbignLicpO1xyXG5cclxuXHRpZiAoc3RhY2tzW2tleV0gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0c3RhY2tzW2tleV0gPSB7XHJcblx0XHRcdHBvczogW10sXHJcblx0XHRcdG5lZzogW11cclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gc3RhY2tzW2tleV07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0YWNrRGF0YShzY2FsZSwgc3RhY2tzLCBtZXRhLCBkYXRhKSB7XHJcblx0dmFyIG9wdHMgPSBzY2FsZS5vcHRpb25zO1xyXG5cdHZhciBzdGFja2VkID0gb3B0cy5zdGFja2VkO1xyXG5cdHZhciBzdGFjayA9IGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBzdGFja2VkLCBtZXRhKTtcclxuXHR2YXIgcG9zID0gc3RhY2sucG9zO1xyXG5cdHZhciBuZWcgPSBzdGFjay5uZWc7XHJcblx0dmFyIGlsZW4gPSBkYXRhLmxlbmd0aDtcclxuXHR2YXIgaSwgdmFsdWU7XHJcblxyXG5cdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdHZhbHVlID0gc2NhbGUuX3BhcnNlVmFsdWUoZGF0YVtpXSk7XHJcblx0XHRpZiAoaXNOYU4odmFsdWUubWluKSB8fCBpc05hTih2YWx1ZS5tYXgpIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4pIHtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cG9zW2ldID0gcG9zW2ldIHx8IDA7XHJcblx0XHRuZWdbaV0gPSBuZWdbaV0gfHwgMDtcclxuXHJcblx0XHRpZiAob3B0cy5yZWxhdGl2ZVBvaW50cykge1xyXG5cdFx0XHRwb3NbaV0gPSAxMDA7XHJcblx0XHR9IGVsc2UgaWYgKHZhbHVlLm1pbiA8IDAgfHwgdmFsdWUubWF4IDwgMCkge1xyXG5cdFx0XHRuZWdbaV0gKz0gdmFsdWUubWluO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cG9zW2ldICs9IHZhbHVlLm1heDtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZU1pbk1heChzY2FsZSwgbWV0YSwgZGF0YSkge1xyXG5cdHZhciBpbGVuID0gZGF0YS5sZW5ndGg7XHJcblx0dmFyIGksIHZhbHVlO1xyXG5cclxuXHRmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHR2YWx1ZSA9IHNjYWxlLl9wYXJzZVZhbHVlKGRhdGFbaV0pO1xyXG5cdFx0aWYgKGlzTmFOKHZhbHVlLm1pbikgfHwgaXNOYU4odmFsdWUubWF4KSB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuKSB7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHNjYWxlLm1pbiA9IE1hdGgubWluKHNjYWxlLm1pbiwgdmFsdWUubWluKTtcclxuXHRcdHNjYWxlLm1heCA9IE1hdGgubWF4KHNjYWxlLm1heCwgdmFsdWUubWF4KTtcclxuXHR9XHJcbn1cclxuXHJcbnZhciBzY2FsZV9saW5lYXIgPSBzY2FsZV9saW5lYXJiYXNlLmV4dGVuZCh7XHJcblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XHJcblx0XHR2YXIgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xyXG5cdFx0dmFyIG1ldGFzZXRzID0gbWUuX2dldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XHJcblx0XHR2YXIgaGFzU3RhY2tzID0gb3B0cy5zdGFja2VkO1xyXG5cdFx0dmFyIHN0YWNrcyA9IHt9O1xyXG5cdFx0dmFyIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7XHJcblx0XHR2YXIgaSwgbWV0YSwgZGF0YSwgdmFsdWVzO1xyXG5cclxuXHRcdG1lLm1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuXHRcdG1lLm1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcclxuXHJcblx0XHRpZiAoaGFzU3RhY2tzID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Zm9yIChpID0gMDsgIWhhc1N0YWNrcyAmJiBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdFx0bWV0YSA9IG1ldGFzZXRzW2ldO1xyXG5cdFx0XHRcdGhhc1N0YWNrcyA9IG1ldGEuc3RhY2sgIT09IHVuZGVmaW5lZDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0bWV0YSA9IG1ldGFzZXRzW2ldO1xyXG5cdFx0XHRkYXRhID0gZGF0YXNldHNbbWV0YS5pbmRleF0uZGF0YTtcclxuXHRcdFx0aWYgKGhhc1N0YWNrcykge1xyXG5cdFx0XHRcdHN0YWNrRGF0YShtZSwgc3RhY2tzLCBtZXRhLCBkYXRhKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR1cGRhdGVNaW5NYXgobWUsIG1ldGEsIGRhdGEpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aGVscGVycyQxLmVhY2goc3RhY2tzLCBmdW5jdGlvbihzdGFja1ZhbHVlcykge1xyXG5cdFx0XHR2YWx1ZXMgPSBzdGFja1ZhbHVlcy5wb3MuY29uY2F0KHN0YWNrVmFsdWVzLm5lZyk7XHJcblx0XHRcdG1lLm1pbiA9IE1hdGgubWluKG1lLm1pbiwgaGVscGVycyQxLm1pbih2YWx1ZXMpKTtcclxuXHRcdFx0bWUubWF4ID0gTWF0aC5tYXgobWUubWF4LCBoZWxwZXJzJDEubWF4KHZhbHVlcykpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0bWUubWluID0gaGVscGVycyQxLmlzRmluaXRlKG1lLm1pbikgJiYgIWlzTmFOKG1lLm1pbikgPyBtZS5taW4gOiBERUZBVUxUX01JTjtcclxuXHRcdG1lLm1heCA9IGhlbHBlcnMkMS5pc0Zpbml0ZShtZS5tYXgpICYmICFpc05hTihtZS5tYXgpID8gbWUubWF4IDogREVGQVVMVF9NQVg7XHJcblxyXG5cdFx0Ly8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIHRpY2tzLm1pbiwgdGlja3MubWF4LCB0aWNrcy5iZWdpbkF0WmVyb1xyXG5cdFx0bWUuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xyXG5cdH0sXHJcblxyXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIGJhc2VkIG9uIHRoZSBzY2FsZSBkaW1lbnNpb25cclxuXHRfY29tcHV0ZVRpY2tMaW1pdDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHRpY2tGb250O1xyXG5cclxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xyXG5cdFx0XHRyZXR1cm4gTWF0aC5jZWlsKG1lLndpZHRoIC8gNDApO1xyXG5cdFx0fVxyXG5cdFx0dGlja0ZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KG1lLm9wdGlvbnMudGlja3MpO1xyXG5cdFx0cmV0dXJuIE1hdGguY2VpbChtZS5oZWlnaHQgLyB0aWNrRm9udC5saW5lSGVpZ2h0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBDYWxsZWQgYWZ0ZXIgdGhlIHRpY2tzIGFyZSBidWlsdC4gV2UgbmVlZFxyXG5cdGhhbmRsZURpcmVjdGlvbmFsQ2hhbmdlczogZnVuY3Rpb24oKSB7XHJcblx0XHRpZiAoIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcclxuXHRcdFx0Ly8gV2UgYXJlIGluIGEgdmVydGljYWwgb3JpZW50YXRpb24uIFRoZSB0b3AgdmFsdWUgaXMgdGhlIGhpZ2hlc3QuIFNvIHJldmVyc2UgdGhlIGFycmF5XHJcblx0XHRcdHRoaXMudGlja3MucmV2ZXJzZSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldExhYmVsRm9ySW5kZXg6IGZ1bmN0aW9uKGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9nZXRTY2FsZUxhYmVsKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcclxuXHR9LFxyXG5cclxuXHQvLyBVdGlsc1xyXG5cdGdldFBpeGVsRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0cmV0dXJuIG1lLmdldFBpeGVsRm9yRGVjaW1hbCgoK21lLmdldFJpZ2h0VmFsdWUodmFsdWUpIC0gbWUuX3N0YXJ0VmFsdWUpIC8gbWUuX3ZhbHVlUmFuZ2UpO1xyXG5cdH0sXHJcblxyXG5cdGdldFZhbHVlRm9yUGl4ZWw6IGZ1bmN0aW9uKHBpeGVsKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2U7XHJcblx0fSxcclxuXHJcblx0Z2V0UGl4ZWxGb3JUaWNrOiBmdW5jdGlvbihpbmRleCkge1xyXG5cdFx0dmFyIHRpY2tzID0gdGhpcy50aWNrc0FzTnVtYmVycztcclxuXHRcdGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0pO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBJTlRFUk5BTDogc3RhdGljIGRlZmF1bHQgb3B0aW9ucywgcmVnaXN0ZXJlZCBpbiBzcmMvaW5kZXguanNcclxudmFyIF9kZWZhdWx0cyQxID0gZGVmYXVsdENvbmZpZyQxO1xuc2NhbGVfbGluZWFyLl9kZWZhdWx0cyA9IF9kZWZhdWx0cyQxO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkYiA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcclxudmFyIGxvZzEwID0gaGVscGVycyQxLm1hdGgubG9nMTA7XHJcblxyXG4vKipcclxuICogR2VuZXJhdGUgYSBzZXQgb2YgbG9nYXJpdGhtaWMgdGlja3NcclxuICogQHBhcmFtIGdlbmVyYXRpb25PcHRpb25zIHRoZSBvcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpY2tzXHJcbiAqIEBwYXJhbSBkYXRhUmFuZ2UgdGhlIHJhbmdlIG9mIHRoZSBkYXRhXHJcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gYXJyYXkgb2YgdGljayB2YWx1ZXNcclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MkMShnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XHJcblx0dmFyIHRpY2tzID0gW107XHJcblxyXG5cdHZhciB0aWNrVmFsID0gdmFsdWVPckRlZmF1bHQkYihnZW5lcmF0aW9uT3B0aW9ucy5taW4sIE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKGRhdGFSYW5nZS5taW4pKSkpO1xyXG5cclxuXHR2YXIgZW5kRXhwID0gTWF0aC5mbG9vcihsb2cxMChkYXRhUmFuZ2UubWF4KSk7XHJcblx0dmFyIGVuZFNpZ25pZmljYW5kID0gTWF0aC5jZWlsKGRhdGFSYW5nZS5tYXggLyBNYXRoLnBvdygxMCwgZW5kRXhwKSk7XHJcblx0dmFyIGV4cCwgc2lnbmlmaWNhbmQ7XHJcblxyXG5cdGlmICh0aWNrVmFsID09PSAwKSB7XHJcblx0XHRleHAgPSBNYXRoLmZsb29yKGxvZzEwKGRhdGFSYW5nZS5taW5Ob3RaZXJvKSk7XHJcblx0XHRzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IoZGF0YVJhbmdlLm1pbk5vdFplcm8gLyBNYXRoLnBvdygxMCwgZXhwKSk7XHJcblxyXG5cdFx0dGlja3MucHVzaCh0aWNrVmFsKTtcclxuXHRcdHRpY2tWYWwgPSBzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRleHAgPSBNYXRoLmZsb29yKGxvZzEwKHRpY2tWYWwpKTtcclxuXHRcdHNpZ25pZmljYW5kID0gTWF0aC5mbG9vcih0aWNrVmFsIC8gTWF0aC5wb3coMTAsIGV4cCkpO1xyXG5cdH1cclxuXHR2YXIgcHJlY2lzaW9uID0gZXhwIDwgMCA/IE1hdGgucG93KDEwLCBNYXRoLmFicyhleHApKSA6IDE7XHJcblxyXG5cdGRvIHtcclxuXHRcdHRpY2tzLnB1c2godGlja1ZhbCk7XHJcblxyXG5cdFx0KytzaWduaWZpY2FuZDtcclxuXHRcdGlmIChzaWduaWZpY2FuZCA9PT0gMTApIHtcclxuXHRcdFx0c2lnbmlmaWNhbmQgPSAxO1xyXG5cdFx0XHQrK2V4cDtcclxuXHRcdFx0cHJlY2lzaW9uID0gZXhwID49IDAgPyAxIDogcHJlY2lzaW9uO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRpY2tWYWwgPSBNYXRoLnJvdW5kKHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xyXG5cdH0gd2hpbGUgKGV4cCA8IGVuZEV4cCB8fCAoZXhwID09PSBlbmRFeHAgJiYgc2lnbmlmaWNhbmQgPCBlbmRTaWduaWZpY2FuZCkpO1xyXG5cclxuXHR2YXIgbGFzdFRpY2sgPSB2YWx1ZU9yRGVmYXVsdCRiKGdlbmVyYXRpb25PcHRpb25zLm1heCwgdGlja1ZhbCk7XHJcblx0dGlja3MucHVzaChsYXN0VGljayk7XHJcblxyXG5cdHJldHVybiB0aWNrcztcclxufVxyXG5cclxudmFyIGRlZmF1bHRDb25maWckMiA9IHtcclxuXHRwb3NpdGlvbjogJ2xlZnQnLFxyXG5cclxuXHQvLyBsYWJlbCBzZXR0aW5nc1xyXG5cdHRpY2tzOiB7XHJcblx0XHRjYWxsYmFjazogY29yZV90aWNrcy5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljXHJcblx0fVxyXG59O1xyXG5cclxuLy8gVE9ETyh2Myk6IGNoYW5nZSB0aGlzIHRvIHBvc2l0aXZlT3JEZWZhdWx0XHJcbmZ1bmN0aW9uIG5vbk5lZ2F0aXZlT3JEZWZhdWx0KHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcclxuXHRyZXR1cm4gaGVscGVycyQxLmlzRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA+PSAwID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XHJcbn1cclxuXHJcbnZhciBzY2FsZV9sb2dhcml0aG1pYyA9IGNvcmVfc2NhbGUuZXh0ZW5kKHtcclxuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XHJcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XHJcblx0XHRmdW5jdGlvbiBJRE1hdGNoZXMobWV0YSkge1xyXG5cdFx0XHRyZXR1cm4gaXNIb3Jpem9udGFsID8gbWV0YS54QXhpc0lEID09PSBtZS5pZCA6IG1ldGEueUF4aXNJRCA9PT0gbWUuaWQ7XHJcblx0XHR9XHJcblx0XHR2YXIgZGF0YXNldEluZGV4LCBtZXRhLCB2YWx1ZSwgZGF0YSwgaSwgaWxlbjtcclxuXHJcblx0XHQvLyBDYWxjdWxhdGUgUmFuZ2VcclxuXHRcdG1lLm1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuXHRcdG1lLm1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcclxuXHRcdG1lLm1pbk5vdFplcm8gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcblxyXG5cdFx0dmFyIGhhc1N0YWNrcyA9IG9wdHMuc3RhY2tlZDtcclxuXHRcdGlmIChoYXNTdGFja3MgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRmb3IgKGRhdGFzZXRJbmRleCA9IDA7IGRhdGFzZXRJbmRleCA8IGRhdGFzZXRzLmxlbmd0aDsgZGF0YXNldEluZGV4KyspIHtcclxuXHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcclxuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSAmJlxyXG5cdFx0XHRcdFx0bWV0YS5zdGFjayAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRoYXNTdGFja3MgPSB0cnVlO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdHMuc3RhY2tlZCB8fCBoYXNTdGFja3MpIHtcclxuXHRcdFx0dmFyIHZhbHVlc1BlclN0YWNrID0ge307XHJcblxyXG5cdFx0XHRmb3IgKGRhdGFzZXRJbmRleCA9IDA7IGRhdGFzZXRJbmRleCA8IGRhdGFzZXRzLmxlbmd0aDsgZGF0YXNldEluZGV4KyspIHtcclxuXHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcclxuXHRcdFx0XHR2YXIga2V5ID0gW1xyXG5cdFx0XHRcdFx0bWV0YS50eXBlLFxyXG5cdFx0XHRcdFx0Ly8gd2UgaGF2ZSBhIHNlcGFyYXRlIHN0YWNrIGZvciBzdGFjaz11bmRlZmluZWQgZGF0YXNldHMgd2hlbiB0aGUgb3B0cy5zdGFja2VkIGlzIHVuZGVmaW5lZFxyXG5cdFx0XHRcdFx0KChvcHRzLnN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQpID8gZGF0YXNldEluZGV4IDogJycpLFxyXG5cdFx0XHRcdFx0bWV0YS5zdGFja1xyXG5cdFx0XHRcdF0uam9pbignLicpO1xyXG5cclxuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSkge1xyXG5cdFx0XHRcdFx0aWYgKHZhbHVlc1BlclN0YWNrW2tleV0gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZXNQZXJTdGFja1trZXldID0gW107XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YTtcclxuXHRcdFx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xyXG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVzID0gdmFsdWVzUGVyU3RhY2tba2V5XTtcclxuXHRcdFx0XHRcdFx0dmFsdWUgPSBtZS5fcGFyc2VWYWx1ZShkYXRhW2ldKTtcclxuXHRcdFx0XHRcdFx0Ly8gaW52YWxpZCwgaGlkZGVuIGFuZCBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGlnbm9yZWRcclxuXHRcdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlLm1pbikgfHwgaXNOYU4odmFsdWUubWF4KSB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuIHx8IHZhbHVlLm1pbiA8IDAgfHwgdmFsdWUubWF4IDwgMCkge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHZhbHVlc1tpXSA9IHZhbHVlc1tpXSB8fCAwO1xyXG5cdFx0XHRcdFx0XHR2YWx1ZXNbaV0gKz0gdmFsdWUubWF4O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aGVscGVycyQxLmVhY2godmFsdWVzUGVyU3RhY2ssIGZ1bmN0aW9uKHZhbHVlc0ZvclR5cGUpIHtcclxuXHRcdFx0XHRpZiAodmFsdWVzRm9yVHlwZS5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0XHR2YXIgbWluVmFsID0gaGVscGVycyQxLm1pbih2YWx1ZXNGb3JUeXBlKTtcclxuXHRcdFx0XHRcdHZhciBtYXhWYWwgPSBoZWxwZXJzJDEubWF4KHZhbHVlc0ZvclR5cGUpO1xyXG5cdFx0XHRcdFx0bWUubWluID0gTWF0aC5taW4obWUubWluLCBtaW5WYWwpO1xyXG5cdFx0XHRcdFx0bWUubWF4ID0gTWF0aC5tYXgobWUubWF4LCBtYXhWYWwpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Zm9yIChkYXRhc2V0SW5kZXggPSAwOyBkYXRhc2V0SW5kZXggPCBkYXRhc2V0cy5sZW5ndGg7IGRhdGFzZXRJbmRleCsrKSB7XHJcblx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XHJcblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkpIHtcclxuXHRcdFx0XHRcdGRhdGEgPSBkYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGE7XHJcblx0XHRcdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0dmFsdWUgPSBtZS5fcGFyc2VWYWx1ZShkYXRhW2ldKTtcclxuXHRcdFx0XHRcdFx0Ly8gaW52YWxpZCwgaGlkZGVuIGFuZCBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGlnbm9yZWRcclxuXHRcdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlLm1pbikgfHwgaXNOYU4odmFsdWUubWF4KSB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuIHx8IHZhbHVlLm1pbiA8IDAgfHwgdmFsdWUubWF4IDwgMCkge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRtZS5taW4gPSBNYXRoLm1pbih2YWx1ZS5taW4sIG1lLm1pbik7XHJcblx0XHRcdFx0XHRcdG1lLm1heCA9IE1hdGgubWF4KHZhbHVlLm1heCwgbWUubWF4KTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICh2YWx1ZS5taW4gIT09IDApIHtcclxuXHRcdFx0XHRcdFx0XHRtZS5taW5Ob3RaZXJvID0gTWF0aC5taW4odmFsdWUubWluLCBtZS5taW5Ob3RaZXJvKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG1lLm1pbiA9IGhlbHBlcnMkMS5pc0Zpbml0ZShtZS5taW4pID8gbWUubWluIDogbnVsbDtcclxuXHRcdG1lLm1heCA9IGhlbHBlcnMkMS5pc0Zpbml0ZShtZS5tYXgpID8gbWUubWF4IDogbnVsbDtcclxuXHRcdG1lLm1pbk5vdFplcm8gPSBoZWxwZXJzJDEuaXNGaW5pdGUobWUubWluTm90WmVybykgPyBtZS5taW5Ob3RaZXJvIDogbnVsbDtcclxuXHJcblx0XHQvLyBDb21tb24gYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBoYW5kbGUgdGlja3MubWluLCB0aWNrcy5tYXhcclxuXHRcdHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xyXG5cdH0sXHJcblxyXG5cdGhhbmRsZVRpY2tSYW5nZU9wdGlvbnM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XHJcblx0XHR2YXIgREVGQVVMVF9NSU4gPSAxO1xyXG5cdFx0dmFyIERFRkFVTFRfTUFYID0gMTA7XHJcblxyXG5cdFx0bWUubWluID0gbm9uTmVnYXRpdmVPckRlZmF1bHQodGlja09wdHMubWluLCBtZS5taW4pO1xyXG5cdFx0bWUubWF4ID0gbm9uTmVnYXRpdmVPckRlZmF1bHQodGlja09wdHMubWF4LCBtZS5tYXgpO1xyXG5cclxuXHRcdGlmIChtZS5taW4gPT09IG1lLm1heCkge1xyXG5cdFx0XHRpZiAobWUubWluICE9PSAwICYmIG1lLm1pbiAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdG1lLm1pbiA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKG1lLm1pbikpIC0gMSk7XHJcblx0XHRcdFx0bWUubWF4ID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAobWUubWF4KSkgKyAxKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRtZS5taW4gPSBERUZBVUxUX01JTjtcclxuXHRcdFx0XHRtZS5tYXggPSBERUZBVUxUX01BWDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKG1lLm1pbiA9PT0gbnVsbCkge1xyXG5cdFx0XHRtZS5taW4gPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMChtZS5tYXgpKSAtIDEpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKG1lLm1heCA9PT0gbnVsbCkge1xyXG5cdFx0XHRtZS5tYXggPSBtZS5taW4gIT09IDBcclxuXHRcdFx0XHQ/IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKG1lLm1pbikpICsgMSlcclxuXHRcdFx0XHQ6IERFRkFVTFRfTUFYO1xyXG5cdFx0fVxyXG5cdFx0aWYgKG1lLm1pbk5vdFplcm8gPT09IG51bGwpIHtcclxuXHRcdFx0aWYgKG1lLm1pbiA+IDApIHtcclxuXHRcdFx0XHRtZS5taW5Ob3RaZXJvID0gbWUubWluO1xyXG5cdFx0XHR9IGVsc2UgaWYgKG1lLm1heCA8IDEpIHtcclxuXHRcdFx0XHRtZS5taW5Ob3RaZXJvID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAobWUubWF4KSkpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG1lLm1pbk5vdFplcm8gPSBERUZBVUxUX01JTjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGJ1aWxkVGlja3M6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XHJcblx0XHR2YXIgcmV2ZXJzZSA9ICFtZS5pc0hvcml6b250YWwoKTtcclxuXHJcblx0XHR2YXIgZ2VuZXJhdGlvbk9wdGlvbnMgPSB7XHJcblx0XHRcdG1pbjogbm9uTmVnYXRpdmVPckRlZmF1bHQodGlja09wdHMubWluKSxcclxuXHRcdFx0bWF4OiBub25OZWdhdGl2ZU9yRGVmYXVsdCh0aWNrT3B0cy5tYXgpXHJcblx0XHR9O1xyXG5cdFx0dmFyIHRpY2tzID0gbWUudGlja3MgPSBnZW5lcmF0ZVRpY2tzJDEoZ2VuZXJhdGlvbk9wdGlvbnMsIG1lKTtcclxuXHJcblx0XHQvLyBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIHRvIHVwZGF0ZSBvdXIgbWF4IGFuZCBtaW4gZ2l2ZW4gdGhlIHRpY2sgdmFsdWVzIHNpbmNlIHdlIGhhdmUgZXhwYW5kZWQgdGhlXHJcblx0XHQvLyByYW5nZSBvZiB0aGUgc2NhbGVcclxuXHRcdG1lLm1heCA9IGhlbHBlcnMkMS5tYXgodGlja3MpO1xyXG5cdFx0bWUubWluID0gaGVscGVycyQxLm1pbih0aWNrcyk7XHJcblxyXG5cdFx0aWYgKHRpY2tPcHRzLnJldmVyc2UpIHtcclxuXHRcdFx0cmV2ZXJzZSA9ICFyZXZlcnNlO1xyXG5cdFx0XHRtZS5zdGFydCA9IG1lLm1heDtcclxuXHRcdFx0bWUuZW5kID0gbWUubWluO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWUuc3RhcnQgPSBtZS5taW47XHJcblx0XHRcdG1lLmVuZCA9IG1lLm1heDtcclxuXHRcdH1cclxuXHRcdGlmIChyZXZlcnNlKSB7XHJcblx0XHRcdHRpY2tzLnJldmVyc2UoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLnRpY2tWYWx1ZXMgPSB0aGlzLnRpY2tzLnNsaWNlKCk7XHJcblxyXG5cdFx0Y29yZV9zY2FsZS5wcm90b3R5cGUuY29udmVydFRpY2tzVG9MYWJlbHMuY2FsbCh0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBHZXQgdGhlIGNvcnJlY3QgdG9vbHRpcCBsYWJlbFxyXG5cdGdldExhYmVsRm9ySW5kZXg6IGZ1bmN0aW9uKGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9nZXRTY2FsZUxhYmVsKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcclxuXHR9LFxyXG5cclxuXHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XHJcblx0XHR2YXIgdGlja3MgPSB0aGlzLnRpY2tWYWx1ZXM7XHJcblx0XHRpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgdGljay5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgbWluaW11bSBub3QgemVybyB2YWx1ZS5cclxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBmaXJzdCB0aWNrIHZhbHVlLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldEZpcnN0VGlja1ZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0dmFyIGV4cCA9IE1hdGguZmxvb3IobG9nMTAodmFsdWUpKTtcclxuXHRcdHZhciBzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IodmFsdWUgLyBNYXRoLnBvdygxMCwgZXhwKSk7XHJcblxyXG5cdFx0cmV0dXJuIHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCk7XHJcblx0fSxcclxuXHJcblx0X2NvbmZpZ3VyZTogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHN0YXJ0ID0gbWUubWluO1xyXG5cdFx0dmFyIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0Y29yZV9zY2FsZS5wcm90b3R5cGUuX2NvbmZpZ3VyZS5jYWxsKG1lKTtcclxuXHJcblx0XHRpZiAoc3RhcnQgPT09IDApIHtcclxuXHRcdFx0c3RhcnQgPSBtZS5fZ2V0Rmlyc3RUaWNrVmFsdWUobWUubWluTm90WmVybyk7XHJcblx0XHRcdG9mZnNldCA9IHZhbHVlT3JEZWZhdWx0JGIobWUub3B0aW9ucy50aWNrcy5mb250U2l6ZSwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRTaXplKSAvIG1lLl9sZW5ndGg7XHJcblx0XHR9XHJcblxyXG5cdFx0bWUuX3N0YXJ0VmFsdWUgPSBsb2cxMChzdGFydCk7XHJcblx0XHRtZS5fdmFsdWVPZmZzZXQgPSBvZmZzZXQ7XHJcblx0XHRtZS5fdmFsdWVSYW5nZSA9IChsb2cxMChtZS5tYXgpIC0gbG9nMTAoc3RhcnQpKSAvICgxIC0gb2Zmc2V0KTtcclxuXHR9LFxyXG5cclxuXHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBkZWNpbWFsID0gMDtcclxuXHJcblx0XHR2YWx1ZSA9ICttZS5nZXRSaWdodFZhbHVlKHZhbHVlKTtcclxuXHJcblx0XHRpZiAodmFsdWUgPiBtZS5taW4gJiYgdmFsdWUgPiAwKSB7XHJcblx0XHRcdGRlY2ltYWwgPSAobG9nMTAodmFsdWUpIC0gbWUuX3N0YXJ0VmFsdWUpIC8gbWUuX3ZhbHVlUmFuZ2UgKyBtZS5fdmFsdWVPZmZzZXQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbWUuZ2V0UGl4ZWxGb3JEZWNpbWFsKGRlY2ltYWwpO1xyXG5cdH0sXHJcblxyXG5cdGdldFZhbHVlRm9yUGl4ZWw6IGZ1bmN0aW9uKHBpeGVsKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGRlY2ltYWwgPSBtZS5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpO1xyXG5cdFx0cmV0dXJuIGRlY2ltYWwgPT09IDAgJiYgbWUubWluID09PSAwXHJcblx0XHRcdD8gMFxyXG5cdFx0XHQ6IE1hdGgucG93KDEwLCBtZS5fc3RhcnRWYWx1ZSArIChkZWNpbWFsIC0gbWUuX3ZhbHVlT2Zmc2V0KSAqIG1lLl92YWx1ZVJhbmdlKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gSU5URVJOQUw6IHN0YXRpYyBkZWZhdWx0IG9wdGlvbnMsIHJlZ2lzdGVyZWQgaW4gc3JjL2luZGV4LmpzXHJcbnZhciBfZGVmYXVsdHMkMiA9IGRlZmF1bHRDb25maWckMjtcbnNjYWxlX2xvZ2FyaXRobWljLl9kZWZhdWx0cyA9IF9kZWZhdWx0cyQyO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkYyA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcclxudmFyIHZhbHVlQXRJbmRleE9yRGVmYXVsdCQxID0gaGVscGVycyQxLnZhbHVlQXRJbmRleE9yRGVmYXVsdDtcclxudmFyIHJlc29sdmUkNCA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XHJcblxyXG52YXIgZGVmYXVsdENvbmZpZyQzID0ge1xyXG5cdGRpc3BsYXk6IHRydWUsXHJcblxyXG5cdC8vIEJvb2xlYW4gLSBXaGV0aGVyIHRvIGFuaW1hdGUgc2NhbGluZyB0aGUgY2hhcnQgZnJvbSB0aGUgY2VudHJlXHJcblx0YW5pbWF0ZTogdHJ1ZSxcclxuXHRwb3NpdGlvbjogJ2NoYXJ0QXJlYScsXHJcblxyXG5cdGFuZ2xlTGluZXM6IHtcclxuXHRcdGRpc3BsYXk6IHRydWUsXHJcblx0XHRjb2xvcjogJ3JnYmEoMCwwLDAsMC4xKScsXHJcblx0XHRsaW5lV2lkdGg6IDEsXHJcblx0XHRib3JkZXJEYXNoOiBbXSxcclxuXHRcdGJvcmRlckRhc2hPZmZzZXQ6IDAuMFxyXG5cdH0sXHJcblxyXG5cdGdyaWRMaW5lczoge1xyXG5cdFx0Y2lyY3VsYXI6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0Ly8gbGFiZWwgc2V0dGluZ3NcclxuXHR0aWNrczoge1xyXG5cdFx0Ly8gQm9vbGVhbiAtIFNob3cgYSBiYWNrZHJvcCB0byB0aGUgc2NhbGUgbGFiZWxcclxuXHRcdHNob3dMYWJlbEJhY2tkcm9wOiB0cnVlLFxyXG5cclxuXHRcdC8vIFN0cmluZyAtIFRoZSBjb2xvdXIgb2YgdGhlIGxhYmVsIGJhY2tkcm9wXHJcblx0XHRiYWNrZHJvcENvbG9yOiAncmdiYSgyNTUsMjU1LDI1NSwwLjc1KScsXHJcblxyXG5cdFx0Ly8gTnVtYmVyIC0gVGhlIGJhY2tkcm9wIHBhZGRpbmcgYWJvdmUgJiBiZWxvdyB0aGUgbGFiZWwgaW4gcGl4ZWxzXHJcblx0XHRiYWNrZHJvcFBhZGRpbmdZOiAyLFxyXG5cclxuXHRcdC8vIE51bWJlciAtIFRoZSBiYWNrZHJvcCBwYWRkaW5nIHRvIHRoZSBzaWRlIG9mIHRoZSBsYWJlbCBpbiBwaXhlbHNcclxuXHRcdGJhY2tkcm9wUGFkZGluZ1g6IDIsXHJcblxyXG5cdFx0Y2FsbGJhY2s6IGNvcmVfdGlja3MuZm9ybWF0dGVycy5saW5lYXJcclxuXHR9LFxyXG5cclxuXHRwb2ludExhYmVsczoge1xyXG5cdFx0Ly8gQm9vbGVhbiAtIGlmIHRydWUsIHNob3cgcG9pbnQgbGFiZWxzXHJcblx0XHRkaXNwbGF5OiB0cnVlLFxyXG5cclxuXHRcdC8vIE51bWJlciAtIFBvaW50IGxhYmVsIGZvbnQgc2l6ZSBpbiBwaXhlbHNcclxuXHRcdGZvbnRTaXplOiAxMCxcclxuXHJcblx0XHQvLyBGdW5jdGlvbiAtIFVzZWQgdG8gY29udmVydCBwb2ludCBsYWJlbHNcclxuXHRcdGNhbGxiYWNrOiBmdW5jdGlvbihsYWJlbCkge1xyXG5cdFx0XHRyZXR1cm4gbGFiZWw7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuZnVuY3Rpb24gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpIHtcclxuXHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xyXG5cclxuXHRpZiAodGlja09wdHMuZGlzcGxheSAmJiBvcHRzLmRpc3BsYXkpIHtcclxuXHRcdHJldHVybiB2YWx1ZU9yRGVmYXVsdCRjKHRpY2tPcHRzLmZvbnRTaXplLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udFNpemUpICsgdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWSAqIDI7XHJcblx0fVxyXG5cdHJldHVybiAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtZWFzdXJlTGFiZWxTaXplKGN0eCwgbGluZUhlaWdodCwgbGFiZWwpIHtcclxuXHRpZiAoaGVscGVycyQxLmlzQXJyYXkobGFiZWwpKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR3OiBoZWxwZXJzJDEubG9uZ2VzdFRleHQoY3R4LCBjdHguZm9udCwgbGFiZWwpLFxyXG5cdFx0XHRoOiBsYWJlbC5sZW5ndGggKiBsaW5lSGVpZ2h0XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHc6IGN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGgsXHJcblx0XHRoOiBsaW5lSGVpZ2h0XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb3MsIHNpemUsIG1pbiwgbWF4KSB7XHJcblx0aWYgKGFuZ2xlID09PSBtaW4gfHwgYW5nbGUgPT09IG1heCkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0c3RhcnQ6IHBvcyAtIChzaXplIC8gMiksXHJcblx0XHRcdGVuZDogcG9zICsgKHNpemUgLyAyKVxyXG5cdFx0fTtcclxuXHR9IGVsc2UgaWYgKGFuZ2xlIDwgbWluIHx8IGFuZ2xlID4gbWF4KSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRzdGFydDogcG9zIC0gc2l6ZSxcclxuXHRcdFx0ZW5kOiBwb3NcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0c3RhcnQ6IHBvcyxcclxuXHRcdGVuZDogcG9zICsgc2l6ZVxyXG5cdH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZml0IGEgcmFkaWFsIGxpbmVhciBzY2FsZSB3aXRoIHBvaW50IGxhYmVsc1xyXG4gKi9cclxuZnVuY3Rpb24gZml0V2l0aFBvaW50TGFiZWxzKHNjYWxlKSB7XHJcblxyXG5cdC8vIFJpZ2h0LCB0aGlzIGlzIHJlYWxseSBjb25mdXNpbmcgYW5kIHRoZXJlIGlzIGEgbG90IG9mIG1hdGhzIGdvaW5nIG9uIGhlcmVcclxuXHQvLyBUaGUgZ2lzdCBvZiB0aGUgcHJvYmxlbSBpcyBoZXJlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9ubm5pY2svNjk2Y2M5YzU1ZjRiMGJlYjhmZTlcclxuXHQvL1xyXG5cdC8vIFJlYWN0aW9uOiBodHRwczovL2RsLmRyb3Bib3h1c2VyY29udGVudC5jb20vdS8zNDYwMTM2My90b29tdWNoc2NpZW5jZS5naWZcclxuXHQvL1xyXG5cdC8vIFNvbHV0aW9uOlxyXG5cdC8vXHJcblx0Ly8gV2UgYXNzdW1lIHRoZSByYWRpdXMgb2YgdGhlIHBvbHlnb24gaXMgaGFsZiB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzIGF0IGZpcnN0XHJcblx0Ly8gYXQgZWFjaCBpbmRleCB3ZSBjaGVjayBpZiB0aGUgdGV4dCBvdmVybGFwcy5cclxuXHQvL1xyXG5cdC8vIFdoZXJlIGl0IGRvZXMsIHdlIHN0b3JlIHRoYXQgYW5nbGUgYW5kIHRoYXQgaW5kZXguXHJcblx0Ly9cclxuXHQvLyBBZnRlciBmaW5kaW5nIHRoZSBsYXJnZXN0IGluZGV4IGFuZCBhbmdsZSB3ZSBjYWxjdWxhdGUgaG93IG11Y2ggd2UgbmVlZCB0byByZW1vdmVcclxuXHQvLyBmcm9tIHRoZSBzaGFwZSByYWRpdXMgdG8gbW92ZSB0aGUgcG9pbnQgaW53YXJkcyBieSB0aGF0IHguXHJcblx0Ly9cclxuXHQvLyBXZSBhdmVyYWdlIHRoZSBsZWZ0IGFuZCByaWdodCBkaXN0YW5jZXMgdG8gZ2V0IHRoZSBtYXhpbXVtIHNoYXBlIHJhZGl1cyB0aGF0IGNhbiBmaXQgaW4gdGhlIGJveFxyXG5cdC8vIGFsb25nIHdpdGggbGFiZWxzLlxyXG5cdC8vXHJcblx0Ly8gT25jZSB3ZSBoYXZlIHRoYXQsIHdlIGNhbiBmaW5kIHRoZSBjZW50cmUgcG9pbnQgZm9yIHRoZSBjaGFydCwgYnkgdGFraW5nIHRoZSB4IHRleHQgcHJvdHJ1c2lvblxyXG5cdC8vIG9uIGVhY2ggc2lkZSwgcmVtb3ZpbmcgdGhhdCBmcm9tIHRoZSBzaXplLCBoYWx2aW5nIGl0IGFuZCBhZGRpbmcgdGhlIGxlZnQgeCBwcm90cnVzaW9uIHdpZHRoLlxyXG5cdC8vXHJcblx0Ly8gVGhpcyB3aWxsIG1lYW4gd2UgaGF2ZSBhIHNoYXBlIGZpdHRlZCB0byB0aGUgY2FudmFzLCBhcyBsYXJnZSBhcyBpdCBjYW4gYmUgd2l0aCB0aGUgbGFiZWxzXHJcblx0Ly8gYW5kIHBvc2l0aW9uIGl0IGluIHRoZSBtb3N0IHNwYWNlIGVmZmljaWVudCBtYW5uZXJcclxuXHQvL1xyXG5cdC8vIGh0dHBzOi8vZGwuZHJvcGJveHVzZXJjb250ZW50LmNvbS91LzM0NjAxMzYzL3llYWhzY2llbmNlLmdpZlxyXG5cclxuXHR2YXIgcGxGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChzY2FsZS5vcHRpb25zLnBvaW50TGFiZWxzKTtcclxuXHJcblx0Ly8gR2V0IG1heGltdW0gcmFkaXVzIG9mIHRoZSBwb2x5Z29uLiBFaXRoZXIgaGFsZiB0aGUgaGVpZ2h0IChtaW51cyB0aGUgdGV4dCB3aWR0aCkgb3IgaGFsZiB0aGUgd2lkdGguXHJcblx0Ly8gVXNlIHRoaXMgdG8gY2FsY3VsYXRlIHRoZSBvZmZzZXQgKyBjaGFuZ2UuIC0gTWFrZSBzdXJlIEwvUiBwcm90cnVzaW9uIGlzIGF0IGxlYXN0IDAgdG8gc3RvcCBpc3N1ZXMgd2l0aCBjZW50cmUgcG9pbnRzXHJcblx0dmFyIGZ1cnRoZXN0TGltaXRzID0ge1xyXG5cdFx0bDogMCxcclxuXHRcdHI6IHNjYWxlLndpZHRoLFxyXG5cdFx0dDogMCxcclxuXHRcdGI6IHNjYWxlLmhlaWdodCAtIHNjYWxlLnBhZGRpbmdUb3BcclxuXHR9O1xyXG5cdHZhciBmdXJ0aGVzdEFuZ2xlcyA9IHt9O1xyXG5cdHZhciBpLCB0ZXh0U2l6ZSwgcG9pbnRQb3NpdGlvbjtcclxuXHJcblx0c2NhbGUuY3R4LmZvbnQgPSBwbEZvbnQuc3RyaW5nO1xyXG5cdHNjYWxlLl9wb2ludExhYmVsU2l6ZXMgPSBbXTtcclxuXHJcblx0dmFyIHZhbHVlQ291bnQgPSBzY2FsZS5jaGFydC5kYXRhLmxhYmVscy5sZW5ndGg7XHJcblx0Zm9yIChpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xyXG5cdFx0cG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgc2NhbGUuZHJhd2luZ0FyZWEgKyA1KTtcclxuXHRcdHRleHRTaXplID0gbWVhc3VyZUxhYmVsU2l6ZShzY2FsZS5jdHgsIHBsRm9udC5saW5lSGVpZ2h0LCBzY2FsZS5wb2ludExhYmVsc1tpXSk7XHJcblx0XHRzY2FsZS5fcG9pbnRMYWJlbFNpemVzW2ldID0gdGV4dFNpemU7XHJcblxyXG5cdFx0Ly8gQWRkIHF1YXJ0ZXIgY2lyY2xlIHRvIG1ha2UgZGVncmVlIDAgbWVhbiB0b3Agb2YgY2lyY2xlXHJcblx0XHR2YXIgYW5nbGVSYWRpYW5zID0gc2NhbGUuZ2V0SW5kZXhBbmdsZShpKTtcclxuXHRcdHZhciBhbmdsZSA9IGhlbHBlcnMkMS50b0RlZ3JlZXMoYW5nbGVSYWRpYW5zKSAlIDM2MDtcclxuXHRcdHZhciBoTGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLngsIHRleHRTaXplLncsIDAsIDE4MCk7XHJcblx0XHR2YXIgdkxpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi55LCB0ZXh0U2l6ZS5oLCA5MCwgMjcwKTtcclxuXHJcblx0XHRpZiAoaExpbWl0cy5zdGFydCA8IGZ1cnRoZXN0TGltaXRzLmwpIHtcclxuXHRcdFx0ZnVydGhlc3RMaW1pdHMubCA9IGhMaW1pdHMuc3RhcnQ7XHJcblx0XHRcdGZ1cnRoZXN0QW5nbGVzLmwgPSBhbmdsZVJhZGlhbnM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGhMaW1pdHMuZW5kID4gZnVydGhlc3RMaW1pdHMucikge1xyXG5cdFx0XHRmdXJ0aGVzdExpbWl0cy5yID0gaExpbWl0cy5lbmQ7XHJcblx0XHRcdGZ1cnRoZXN0QW5nbGVzLnIgPSBhbmdsZVJhZGlhbnM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHZMaW1pdHMuc3RhcnQgPCBmdXJ0aGVzdExpbWl0cy50KSB7XHJcblx0XHRcdGZ1cnRoZXN0TGltaXRzLnQgPSB2TGltaXRzLnN0YXJ0O1xyXG5cdFx0XHRmdXJ0aGVzdEFuZ2xlcy50ID0gYW5nbGVSYWRpYW5zO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh2TGltaXRzLmVuZCA+IGZ1cnRoZXN0TGltaXRzLmIpIHtcclxuXHRcdFx0ZnVydGhlc3RMaW1pdHMuYiA9IHZMaW1pdHMuZW5kO1xyXG5cdFx0XHRmdXJ0aGVzdEFuZ2xlcy5iID0gYW5nbGVSYWRpYW5zO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0c2NhbGUuc2V0UmVkdWN0aW9ucyhzY2FsZS5kcmF3aW5nQXJlYSwgZnVydGhlc3RMaW1pdHMsIGZ1cnRoZXN0QW5nbGVzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpIHtcclxuXHRpZiAoYW5nbGUgPT09IDAgfHwgYW5nbGUgPT09IDE4MCkge1xyXG5cdFx0cmV0dXJuICdjZW50ZXInO1xyXG5cdH0gZWxzZSBpZiAoYW5nbGUgPCAxODApIHtcclxuXHRcdHJldHVybiAnbGVmdCc7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gJ3JpZ2h0JztcclxufVxyXG5cclxuZnVuY3Rpb24gZmlsbFRleHQoY3R4LCB0ZXh0LCBwb3NpdGlvbiwgbGluZUhlaWdodCkge1xyXG5cdHZhciB5ID0gcG9zaXRpb24ueSArIGxpbmVIZWlnaHQgLyAyO1xyXG5cdHZhciBpLCBpbGVuO1xyXG5cclxuXHRpZiAoaGVscGVycyQxLmlzQXJyYXkodGV4dCkpIHtcclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSB0ZXh0Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRjdHguZmlsbFRleHQodGV4dFtpXSwgcG9zaXRpb24ueCwgeSk7XHJcblx0XHRcdHkgKz0gbGluZUhlaWdodDtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0Y3R4LmZpbGxUZXh0KHRleHQsIHBvc2l0aW9uLngsIHkpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYWRqdXN0UG9pbnRQb3NpdGlvbkZvckxhYmVsSGVpZ2h0KGFuZ2xlLCB0ZXh0U2l6ZSwgcG9zaXRpb24pIHtcclxuXHRpZiAoYW5nbGUgPT09IDkwIHx8IGFuZ2xlID09PSAyNzApIHtcclxuXHRcdHBvc2l0aW9uLnkgLT0gKHRleHRTaXplLmggLyAyKTtcclxuXHR9IGVsc2UgaWYgKGFuZ2xlID4gMjcwIHx8IGFuZ2xlIDwgOTApIHtcclxuXHRcdHBvc2l0aW9uLnkgLT0gdGV4dFNpemUuaDtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyYXdQb2ludExhYmVscyhzY2FsZSkge1xyXG5cdHZhciBjdHggPSBzY2FsZS5jdHg7XHJcblx0dmFyIG9wdHMgPSBzY2FsZS5vcHRpb25zO1xyXG5cdHZhciBwb2ludExhYmVsT3B0cyA9IG9wdHMucG9pbnRMYWJlbHM7XHJcblx0dmFyIHRpY2tCYWNrZHJvcEhlaWdodCA9IGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKTtcclxuXHR2YXIgb3V0ZXJEaXN0YW5jZSA9IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKG9wdHMudGlja3MucmV2ZXJzZSA/IHNjYWxlLm1pbiA6IHNjYWxlLm1heCk7XHJcblx0dmFyIHBsRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQocG9pbnRMYWJlbE9wdHMpO1xyXG5cclxuXHRjdHguc2F2ZSgpO1xyXG5cclxuXHRjdHguZm9udCA9IHBsRm9udC5zdHJpbmc7XHJcblx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG5cclxuXHRmb3IgKHZhciBpID0gc2NhbGUuY2hhcnQuZGF0YS5sYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdC8vIEV4dHJhIHBpeGVscyBvdXQgZm9yIHNvbWUgbGFiZWwgc3BhY2luZ1xyXG5cdFx0dmFyIGV4dHJhID0gKGkgPT09IDAgPyB0aWNrQmFja2Ryb3BIZWlnaHQgLyAyIDogMCk7XHJcblx0XHR2YXIgcG9pbnRMYWJlbFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBvdXRlckRpc3RhbmNlICsgZXh0cmEgKyA1KTtcclxuXHJcblx0XHQvLyBLZWVwIHRoaXMgaW4gbG9vcCBzaW5jZSB3ZSBtYXkgc3VwcG9ydCBhcnJheSBwcm9wZXJ0aWVzIGhlcmVcclxuXHRcdHZhciBwb2ludExhYmVsRm9udENvbG9yID0gdmFsdWVBdEluZGV4T3JEZWZhdWx0JDEocG9pbnRMYWJlbE9wdHMuZm9udENvbG9yLCBpLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udENvbG9yKTtcclxuXHRcdGN0eC5maWxsU3R5bGUgPSBwb2ludExhYmVsRm9udENvbG9yO1xyXG5cclxuXHRcdHZhciBhbmdsZVJhZGlhbnMgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKGkpO1xyXG5cdFx0dmFyIGFuZ2xlID0gaGVscGVycyQxLnRvRGVncmVlcyhhbmdsZVJhZGlhbnMpO1xyXG5cdFx0Y3R4LnRleHRBbGlnbiA9IGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKTtcclxuXHRcdGFkanVzdFBvaW50UG9zaXRpb25Gb3JMYWJlbEhlaWdodChhbmdsZSwgc2NhbGUuX3BvaW50TGFiZWxTaXplc1tpXSwgcG9pbnRMYWJlbFBvc2l0aW9uKTtcclxuXHRcdGZpbGxUZXh0KGN0eCwgc2NhbGUucG9pbnRMYWJlbHNbaV0sIHBvaW50TGFiZWxQb3NpdGlvbiwgcGxGb250LmxpbmVIZWlnaHQpO1xyXG5cdH1cclxuXHRjdHgucmVzdG9yZSgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkcmF3UmFkaXVzTGluZShzY2FsZSwgZ3JpZExpbmVPcHRzLCByYWRpdXMsIGluZGV4KSB7XHJcblx0dmFyIGN0eCA9IHNjYWxlLmN0eDtcclxuXHR2YXIgY2lyY3VsYXIgPSBncmlkTGluZU9wdHMuY2lyY3VsYXI7XHJcblx0dmFyIHZhbHVlQ291bnQgPSBzY2FsZS5jaGFydC5kYXRhLmxhYmVscy5sZW5ndGg7XHJcblx0dmFyIGxpbmVDb2xvciA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdCQxKGdyaWRMaW5lT3B0cy5jb2xvciwgaW5kZXggLSAxKTtcclxuXHR2YXIgbGluZVdpZHRoID0gdmFsdWVBdEluZGV4T3JEZWZhdWx0JDEoZ3JpZExpbmVPcHRzLmxpbmVXaWR0aCwgaW5kZXggLSAxKTtcclxuXHR2YXIgcG9pbnRQb3NpdGlvbjtcclxuXHJcblx0aWYgKCghY2lyY3VsYXIgJiYgIXZhbHVlQ291bnQpIHx8ICFsaW5lQ29sb3IgfHwgIWxpbmVXaWR0aCkge1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0Y3R4LnNhdmUoKTtcclxuXHRjdHguc3Ryb2tlU3R5bGUgPSBsaW5lQ29sb3I7XHJcblx0Y3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcclxuXHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XHJcblx0XHRjdHguc2V0TGluZURhc2goZ3JpZExpbmVPcHRzLmJvcmRlckRhc2ggfHwgW10pO1xyXG5cdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gZ3JpZExpbmVPcHRzLmJvcmRlckRhc2hPZmZzZXQgfHwgMC4wO1xyXG5cdH1cclxuXHJcblx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdGlmIChjaXJjdWxhcikge1xyXG5cdFx0Ly8gRHJhdyBjaXJjdWxhciBhcmNzIGJldHdlZW4gdGhlIHBvaW50c1xyXG5cdFx0Y3R4LmFyYyhzY2FsZS54Q2VudGVyLCBzY2FsZS55Q2VudGVyLCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gRHJhdyBzdHJhaWdodCBsaW5lcyBjb25uZWN0aW5nIGVhY2ggaW5kZXhcclxuXHRcdHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKDAsIHJhZGl1cyk7XHJcblx0XHRjdHgubW92ZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xyXG5cdFx0XHRwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCByYWRpdXMpO1xyXG5cdFx0XHRjdHgubGluZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcclxuXHRcdH1cclxuXHR9XHJcblx0Y3R4LmNsb3NlUGF0aCgpO1xyXG5cdGN0eC5zdHJva2UoKTtcclxuXHRjdHgucmVzdG9yZSgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBudW1iZXJPclplcm8ocGFyYW0pIHtcclxuXHRyZXR1cm4gaGVscGVycyQxLmlzTnVtYmVyKHBhcmFtKSA/IHBhcmFtIDogMDtcclxufVxyXG5cclxudmFyIHNjYWxlX3JhZGlhbExpbmVhciA9IHNjYWxlX2xpbmVhcmJhc2UuZXh0ZW5kKHtcclxuXHRzZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblxyXG5cdFx0Ly8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cclxuXHRcdG1lLndpZHRoID0gbWUubWF4V2lkdGg7XHJcblx0XHRtZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7XHJcblx0XHRtZS5wYWRkaW5nVG9wID0gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG1lLm9wdGlvbnMpIC8gMjtcclxuXHRcdG1lLnhDZW50ZXIgPSBNYXRoLmZsb29yKG1lLndpZHRoIC8gMik7XHJcblx0XHRtZS55Q2VudGVyID0gTWF0aC5mbG9vcigobWUuaGVpZ2h0IC0gbWUucGFkZGluZ1RvcCkgLyAyKTtcclxuXHRcdG1lLmRyYXdpbmdBcmVhID0gTWF0aC5taW4obWUuaGVpZ2h0IC0gbWUucGFkZGluZ1RvcCwgbWUud2lkdGgpIC8gMjtcclxuXHR9LFxyXG5cclxuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBtaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcblx0XHR2YXIgbWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xyXG5cclxuXHRcdGhlbHBlcnMkMS5lYWNoKGNoYXJ0LmRhdGEuZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xyXG5cdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpKSB7XHJcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xyXG5cclxuXHRcdFx0XHRoZWxwZXJzJDEuZWFjaChkYXRhc2V0LmRhdGEsIGZ1bmN0aW9uKHJhd1ZhbHVlLCBpbmRleCkge1xyXG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUpO1xyXG5cdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbikge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bWluID0gTWF0aC5taW4odmFsdWUsIG1pbik7XHJcblx0XHRcdFx0XHRtYXggPSBNYXRoLm1heCh2YWx1ZSwgbWF4KTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0bWUubWluID0gKG1pbiA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZID8gMCA6IG1pbik7XHJcblx0XHRtZS5tYXggPSAobWF4ID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPyAwIDogbWF4KTtcclxuXHJcblx0XHQvLyBDb21tb24gYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBoYW5kbGUgdGlja3MubWluLCB0aWNrcy5tYXgsIHRpY2tzLmJlZ2luQXRaZXJvXHJcblx0XHRtZS5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgYmFzZWQgb24gdGhlIHNjYWxlIGRpbWVuc2lvblxyXG5cdF9jb21wdXRlVGlja0xpbWl0OiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBNYXRoLmNlaWwodGhpcy5kcmF3aW5nQXJlYSAvIGdldFRpY2tCYWNrZHJvcEhlaWdodCh0aGlzLm9wdGlvbnMpKTtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cclxuXHRcdHNjYWxlX2xpbmVhcmJhc2UucHJvdG90eXBlLmNvbnZlcnRUaWNrc1RvTGFiZWxzLmNhbGwobWUpO1xyXG5cclxuXHRcdC8vIFBvaW50IGxhYmVsc1xyXG5cdFx0bWUucG9pbnRMYWJlbHMgPSBtZS5jaGFydC5kYXRhLmxhYmVscy5tYXAoZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciBsYWJlbCA9IGhlbHBlcnMkMS5jYWxsYmFjayhtZS5vcHRpb25zLnBvaW50TGFiZWxzLmNhbGxiYWNrLCBhcmd1bWVudHMsIG1lKTtcclxuXHRcdFx0cmV0dXJuIGxhYmVsIHx8IGxhYmVsID09PSAwID8gbGFiZWwgOiAnJztcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdGdldExhYmVsRm9ySW5kZXg6IGZ1bmN0aW9uKGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcclxuXHRcdHJldHVybiArdGhpcy5nZXRSaWdodFZhbHVlKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcclxuXHR9LFxyXG5cclxuXHRmaXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcclxuXHJcblx0XHRpZiAob3B0cy5kaXNwbGF5ICYmIG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xyXG5cdFx0XHRmaXRXaXRoUG9pbnRMYWJlbHMobWUpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWUuc2V0Q2VudGVyUG9pbnQoMCwgMCwgMCwgMCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHJhZGl1cyByZWR1Y3Rpb25zIGFuZCBkZXRlcm1pbmUgbmV3IHJhZGl1cyBhbmQgY2VudGVyIHBvaW50XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZXRSZWR1Y3Rpb25zOiBmdW5jdGlvbihsYXJnZXN0UG9zc2libGVSYWRpdXMsIGZ1cnRoZXN0TGltaXRzLCBmdXJ0aGVzdEFuZ2xlcykge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciByYWRpdXNSZWR1Y3Rpb25MZWZ0ID0gZnVydGhlc3RMaW1pdHMubCAvIE1hdGguc2luKGZ1cnRoZXN0QW5nbGVzLmwpO1xyXG5cdFx0dmFyIHJhZGl1c1JlZHVjdGlvblJpZ2h0ID0gTWF0aC5tYXgoZnVydGhlc3RMaW1pdHMuciAtIG1lLndpZHRoLCAwKSAvIE1hdGguc2luKGZ1cnRoZXN0QW5nbGVzLnIpO1xyXG5cdFx0dmFyIHJhZGl1c1JlZHVjdGlvblRvcCA9IC1mdXJ0aGVzdExpbWl0cy50IC8gTWF0aC5jb3MoZnVydGhlc3RBbmdsZXMudCk7XHJcblx0XHR2YXIgcmFkaXVzUmVkdWN0aW9uQm90dG9tID0gLU1hdGgubWF4KGZ1cnRoZXN0TGltaXRzLmIgLSAobWUuaGVpZ2h0IC0gbWUucGFkZGluZ1RvcCksIDApIC8gTWF0aC5jb3MoZnVydGhlc3RBbmdsZXMuYik7XHJcblxyXG5cdFx0cmFkaXVzUmVkdWN0aW9uTGVmdCA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25MZWZ0KTtcclxuXHRcdHJhZGl1c1JlZHVjdGlvblJpZ2h0ID0gbnVtYmVyT3JaZXJvKHJhZGl1c1JlZHVjdGlvblJpZ2h0KTtcclxuXHRcdHJhZGl1c1JlZHVjdGlvblRvcCA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25Ub3ApO1xyXG5cdFx0cmFkaXVzUmVkdWN0aW9uQm90dG9tID0gbnVtYmVyT3JaZXJvKHJhZGl1c1JlZHVjdGlvbkJvdHRvbSk7XHJcblxyXG5cdFx0bWUuZHJhd2luZ0FyZWEgPSBNYXRoLm1pbihcclxuXHRcdFx0TWF0aC5mbG9vcihsYXJnZXN0UG9zc2libGVSYWRpdXMgLSAocmFkaXVzUmVkdWN0aW9uTGVmdCArIHJhZGl1c1JlZHVjdGlvblJpZ2h0KSAvIDIpLFxyXG5cdFx0XHRNYXRoLmZsb29yKGxhcmdlc3RQb3NzaWJsZVJhZGl1cyAtIChyYWRpdXNSZWR1Y3Rpb25Ub3AgKyByYWRpdXNSZWR1Y3Rpb25Cb3R0b20pIC8gMikpO1xyXG5cdFx0bWUuc2V0Q2VudGVyUG9pbnQocmFkaXVzUmVkdWN0aW9uTGVmdCwgcmFkaXVzUmVkdWN0aW9uUmlnaHQsIHJhZGl1c1JlZHVjdGlvblRvcCwgcmFkaXVzUmVkdWN0aW9uQm90dG9tKTtcclxuXHR9LFxyXG5cclxuXHRzZXRDZW50ZXJQb2ludDogZnVuY3Rpb24obGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWF4UmlnaHQgPSBtZS53aWR0aCAtIHJpZ2h0TW92ZW1lbnQgLSBtZS5kcmF3aW5nQXJlYTtcclxuXHRcdHZhciBtYXhMZWZ0ID0gbGVmdE1vdmVtZW50ICsgbWUuZHJhd2luZ0FyZWE7XHJcblx0XHR2YXIgbWF4VG9wID0gdG9wTW92ZW1lbnQgKyBtZS5kcmF3aW5nQXJlYTtcclxuXHRcdHZhciBtYXhCb3R0b20gPSAobWUuaGVpZ2h0IC0gbWUucGFkZGluZ1RvcCkgLSBib3R0b21Nb3ZlbWVudCAtIG1lLmRyYXdpbmdBcmVhO1xyXG5cclxuXHRcdG1lLnhDZW50ZXIgPSBNYXRoLmZsb29yKCgobWF4TGVmdCArIG1heFJpZ2h0KSAvIDIpICsgbWUubGVmdCk7XHJcblx0XHRtZS55Q2VudGVyID0gTWF0aC5mbG9vcigoKG1heFRvcCArIG1heEJvdHRvbSkgLyAyKSArIG1lLnRvcCArIG1lLnBhZGRpbmdUb3ApO1xyXG5cdH0sXHJcblxyXG5cdGdldEluZGV4QW5nbGU6IGZ1bmN0aW9uKGluZGV4KSB7XHJcblx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xyXG5cdFx0dmFyIGFuZ2xlTXVsdGlwbGllciA9IDM2MCAvIGNoYXJ0LmRhdGEubGFiZWxzLmxlbmd0aDtcclxuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucyB8fCB7fTtcclxuXHRcdHZhciBzdGFydEFuZ2xlID0gb3B0aW9ucy5zdGFydEFuZ2xlIHx8IDA7XHJcblxyXG5cdFx0Ly8gU3RhcnQgZnJvbSB0aGUgdG9wIGluc3RlYWQgb2YgcmlnaHQsIHNvIHJlbW92ZSBhIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxyXG5cdFx0dmFyIGFuZ2xlID0gKGluZGV4ICogYW5nbGVNdWx0aXBsaWVyICsgc3RhcnRBbmdsZSkgJSAzNjA7XHJcblxyXG5cdFx0cmV0dXJuIChhbmdsZSA8IDAgPyBhbmdsZSArIDM2MCA6IGFuZ2xlKSAqIE1hdGguUEkgKiAyIC8gMzYwO1xyXG5cdH0sXHJcblxyXG5cdGdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHJcblx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XHJcblx0XHRcdHJldHVybiBOYU47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVGFrZSBpbnRvIGFjY291bnQgaGFsZiBmb250IHNpemUgKyB0aGUgeVBhZGRpbmcgb2YgdGhlIHRvcCB2YWx1ZVxyXG5cdFx0dmFyIHNjYWxpbmdGYWN0b3IgPSBtZS5kcmF3aW5nQXJlYSAvIChtZS5tYXggLSBtZS5taW4pO1xyXG5cdFx0aWYgKG1lLm9wdGlvbnMudGlja3MucmV2ZXJzZSkge1xyXG5cdFx0XHRyZXR1cm4gKG1lLm1heCAtIHZhbHVlKSAqIHNjYWxpbmdGYWN0b3I7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHZhbHVlIC0gbWUubWluKSAqIHNjYWxpbmdGYWN0b3I7XHJcblx0fSxcclxuXHJcblx0Z2V0UG9pbnRQb3NpdGlvbjogZnVuY3Rpb24oaW5kZXgsIGRpc3RhbmNlRnJvbUNlbnRlcikge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciB0aGlzQW5nbGUgPSBtZS5nZXRJbmRleEFuZ2xlKGluZGV4KSAtIChNYXRoLlBJIC8gMik7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiBNYXRoLmNvcyh0aGlzQW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgbWUueENlbnRlcixcclxuXHRcdFx0eTogTWF0aC5zaW4odGhpc0FuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIG1lLnlDZW50ZXJcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Z2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlOiBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb24oaW5kZXgsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpKTtcclxuXHR9LFxyXG5cclxuXHRnZXRCYXNlUG9zaXRpb246IGZ1bmN0aW9uKGluZGV4KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG1pbiA9IG1lLm1pbjtcclxuXHRcdHZhciBtYXggPSBtZS5tYXg7XHJcblxyXG5cdFx0cmV0dXJuIG1lLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCB8fCAwLFxyXG5cdFx0XHRtZS5iZWdpbkF0WmVybyA/IDAgOlxyXG5cdFx0XHRtaW4gPCAwICYmIG1heCA8IDAgPyBtYXggOlxyXG5cdFx0XHRtaW4gPiAwICYmIG1heCA+IDAgPyBtaW4gOlxyXG5cdFx0XHQwKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9kcmF3R3JpZDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGN0eCA9IG1lLmN0eDtcclxuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcclxuXHRcdHZhciBncmlkTGluZU9wdHMgPSBvcHRzLmdyaWRMaW5lcztcclxuXHRcdHZhciBhbmdsZUxpbmVPcHRzID0gb3B0cy5hbmdsZUxpbmVzO1xyXG5cdFx0dmFyIGxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JGMoYW5nbGVMaW5lT3B0cy5saW5lV2lkdGgsIGdyaWRMaW5lT3B0cy5saW5lV2lkdGgpO1xyXG5cdFx0dmFyIGxpbmVDb2xvciA9IHZhbHVlT3JEZWZhdWx0JGMoYW5nbGVMaW5lT3B0cy5jb2xvciwgZ3JpZExpbmVPcHRzLmNvbG9yKTtcclxuXHRcdHZhciBpLCBvZmZzZXQsIHBvc2l0aW9uO1xyXG5cclxuXHRcdGlmIChvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcclxuXHRcdFx0ZHJhd1BvaW50TGFiZWxzKG1lKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZ3JpZExpbmVPcHRzLmRpc3BsYXkpIHtcclxuXHRcdFx0aGVscGVycyQxLmVhY2gobWUudGlja3MsIGZ1bmN0aW9uKGxhYmVsLCBpbmRleCkge1xyXG5cdFx0XHRcdGlmIChpbmRleCAhPT0gMCkge1xyXG5cdFx0XHRcdFx0b2Zmc2V0ID0gbWUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUobWUudGlja3NBc051bWJlcnNbaW5kZXhdKTtcclxuXHRcdFx0XHRcdGRyYXdSYWRpdXNMaW5lKG1lLCBncmlkTGluZU9wdHMsIG9mZnNldCwgaW5kZXgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGFuZ2xlTGluZU9wdHMuZGlzcGxheSAmJiBsaW5lV2lkdGggJiYgbGluZUNvbG9yKSB7XHJcblx0XHRcdGN0eC5zYXZlKCk7XHJcblx0XHRcdGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XHJcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGxpbmVDb2xvcjtcclxuXHRcdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xyXG5cdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChyZXNvbHZlJDQoW2FuZ2xlTGluZU9wdHMuYm9yZGVyRGFzaCwgZ3JpZExpbmVPcHRzLmJvcmRlckRhc2gsIFtdXSkpO1xyXG5cdFx0XHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IHJlc29sdmUkNChbYW5nbGVMaW5lT3B0cy5ib3JkZXJEYXNoT2Zmc2V0LCBncmlkTGluZU9wdHMuYm9yZGVyRGFzaE9mZnNldCwgMC4wXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoaSA9IG1lLmNoYXJ0LmRhdGEubGFiZWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0b2Zmc2V0ID0gbWUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUob3B0cy50aWNrcy5yZXZlcnNlID8gbWUubWluIDogbWUubWF4KTtcclxuXHRcdFx0XHRwb3NpdGlvbiA9IG1lLmdldFBvaW50UG9zaXRpb24oaSwgb2Zmc2V0KTtcclxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRcdFx0Y3R4Lm1vdmVUbyhtZS54Q2VudGVyLCBtZS55Q2VudGVyKTtcclxuXHRcdFx0XHRjdHgubGluZVRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xyXG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9kcmF3TGFiZWxzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY3R4ID0gbWUuY3R4O1xyXG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcclxuXHJcblx0XHRpZiAoIXRpY2tPcHRzLmRpc3BsYXkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdGFydEFuZ2xlID0gbWUuZ2V0SW5kZXhBbmdsZSgwKTtcclxuXHRcdHZhciB0aWNrRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQodGlja09wdHMpO1xyXG5cdFx0dmFyIHRpY2tGb250Q29sb3IgPSB2YWx1ZU9yRGVmYXVsdCRjKHRpY2tPcHRzLmZvbnRDb2xvciwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRDb2xvcik7XHJcblx0XHR2YXIgb2Zmc2V0LCB3aWR0aDtcclxuXHJcblx0XHRjdHguc2F2ZSgpO1xyXG5cdFx0Y3R4LmZvbnQgPSB0aWNrRm9udC5zdHJpbmc7XHJcblx0XHRjdHgudHJhbnNsYXRlKG1lLnhDZW50ZXIsIG1lLnlDZW50ZXIpO1xyXG5cdFx0Y3R4LnJvdGF0ZShzdGFydEFuZ2xlKTtcclxuXHRcdGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuXHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcclxuXHJcblx0XHRoZWxwZXJzJDEuZWFjaChtZS50aWNrcywgZnVuY3Rpb24obGFiZWwsIGluZGV4KSB7XHJcblx0XHRcdGlmIChpbmRleCA9PT0gMCAmJiAhdGlja09wdHMucmV2ZXJzZSkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b2Zmc2V0ID0gbWUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUobWUudGlja3NBc051bWJlcnNbaW5kZXhdKTtcclxuXHJcblx0XHRcdGlmICh0aWNrT3B0cy5zaG93TGFiZWxCYWNrZHJvcCkge1xyXG5cdFx0XHRcdHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcclxuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdGlja09wdHMuYmFja2Ryb3BDb2xvcjtcclxuXHJcblx0XHRcdFx0Y3R4LmZpbGxSZWN0KFxyXG5cdFx0XHRcdFx0LXdpZHRoIC8gMiAtIHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZ1gsXHJcblx0XHRcdFx0XHQtb2Zmc2V0IC0gdGlja0ZvbnQuc2l6ZSAvIDIgLSB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdZLFxyXG5cdFx0XHRcdFx0d2lkdGggKyB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdYICogMixcclxuXHRcdFx0XHRcdHRpY2tGb250LnNpemUgKyB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdZICogMlxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB0aWNrRm9udENvbG9yO1xyXG5cdFx0XHRjdHguZmlsbFRleHQobGFiZWwsIDAsIC1vZmZzZXQpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9kcmF3VGl0bGU6IGhlbHBlcnMkMS5ub29wXHJcbn0pO1xyXG5cclxuLy8gSU5URVJOQUw6IHN0YXRpYyBkZWZhdWx0IG9wdGlvbnMsIHJlZ2lzdGVyZWQgaW4gc3JjL2luZGV4LmpzXHJcbnZhciBfZGVmYXVsdHMkMyA9IGRlZmF1bHRDb25maWckMztcbnNjYWxlX3JhZGlhbExpbmVhci5fZGVmYXVsdHMgPSBfZGVmYXVsdHMkMztcblxudmFyIGRlcHJlY2F0ZWQkMSA9IGhlbHBlcnMkMS5fZGVwcmVjYXRlZDtcclxudmFyIHJlc29sdmUkNSA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XHJcbnZhciB2YWx1ZU9yRGVmYXVsdCRkID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xyXG5cclxuLy8gSW50ZWdlciBjb25zdGFudHMgYXJlIGZyb20gdGhlIEVTNiBzcGVjLlxyXG52YXIgTUlOX0lOVEVHRVIgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiB8fCAtOTAwNzE5OTI1NDc0MDk5MTtcclxudmFyIE1BWF9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTtcclxuXHJcbnZhciBJTlRFUlZBTFMgPSB7XHJcblx0bWlsbGlzZWNvbmQ6IHtcclxuXHRcdGNvbW1vbjogdHJ1ZSxcclxuXHRcdHNpemU6IDEsXHJcblx0XHRzdGVwczogMTAwMFxyXG5cdH0sXHJcblx0c2Vjb25kOiB7XHJcblx0XHRjb21tb246IHRydWUsXHJcblx0XHRzaXplOiAxMDAwLFxyXG5cdFx0c3RlcHM6IDYwXHJcblx0fSxcclxuXHRtaW51dGU6IHtcclxuXHRcdGNvbW1vbjogdHJ1ZSxcclxuXHRcdHNpemU6IDYwMDAwLFxyXG5cdFx0c3RlcHM6IDYwXHJcblx0fSxcclxuXHRob3VyOiB7XHJcblx0XHRjb21tb246IHRydWUsXHJcblx0XHRzaXplOiAzNjAwMDAwLFxyXG5cdFx0c3RlcHM6IDI0XHJcblx0fSxcclxuXHRkYXk6IHtcclxuXHRcdGNvbW1vbjogdHJ1ZSxcclxuXHRcdHNpemU6IDg2NDAwMDAwLFxyXG5cdFx0c3RlcHM6IDMwXHJcblx0fSxcclxuXHR3ZWVrOiB7XHJcblx0XHRjb21tb246IGZhbHNlLFxyXG5cdFx0c2l6ZTogNjA0ODAwMDAwLFxyXG5cdFx0c3RlcHM6IDRcclxuXHR9LFxyXG5cdG1vbnRoOiB7XHJcblx0XHRjb21tb246IHRydWUsXHJcblx0XHRzaXplOiAyLjYyOGU5LFxyXG5cdFx0c3RlcHM6IDEyXHJcblx0fSxcclxuXHRxdWFydGVyOiB7XHJcblx0XHRjb21tb246IGZhbHNlLFxyXG5cdFx0c2l6ZTogNy44ODRlOSxcclxuXHRcdHN0ZXBzOiA0XHJcblx0fSxcclxuXHR5ZWFyOiB7XHJcblx0XHRjb21tb246IHRydWUsXHJcblx0XHRzaXplOiAzLjE1NGUxMFxyXG5cdH1cclxufTtcclxuXHJcbnZhciBVTklUUyA9IE9iamVjdC5rZXlzKElOVEVSVkFMUyk7XHJcblxyXG5mdW5jdGlvbiBzb3J0ZXIoYSwgYikge1xyXG5cdHJldHVybiBhIC0gYjtcclxufVxyXG5cclxuZnVuY3Rpb24gYXJyYXlVbmlxdWUoaXRlbXMpIHtcclxuXHR2YXIgaGFzaCA9IHt9O1xyXG5cdHZhciBvdXQgPSBbXTtcclxuXHR2YXIgaSwgaWxlbiwgaXRlbTtcclxuXHJcblx0Zm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0aXRlbSA9IGl0ZW1zW2ldO1xyXG5cdFx0aWYgKCFoYXNoW2l0ZW1dKSB7XHJcblx0XHRcdGhhc2hbaXRlbV0gPSB0cnVlO1xyXG5cdFx0XHRvdXQucHVzaChpdGVtKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBvdXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldE1pbihvcHRpb25zKSB7XHJcblx0cmV0dXJuIGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdChvcHRpb25zLnRpbWUubWluLCBvcHRpb25zLnRpY2tzLm1pbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldE1heChvcHRpb25zKSB7XHJcblx0cmV0dXJuIGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdChvcHRpb25zLnRpbWUubWF4LCBvcHRpb25zLnRpY2tzLm1heCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIHt0aW1lLCBwb3N9IG9iamVjdHMgdXNlZCB0byBpbnRlcnBvbGF0ZSBhIHNwZWNpZmljIGB0aW1lYCBvciBwb3NpdGlvblxyXG4gKiAoYHBvc2ApIG9uIHRoZSBzY2FsZSwgYnkgc2VhcmNoaW5nIGVudHJpZXMgYmVmb3JlIGFuZCBhZnRlciB0aGUgcmVxdWVzdGVkIHZhbHVlLiBgcG9zYCBpc1xyXG4gKiBhIGRlY2ltYWwgYmV0d2VlbiAwIGFuZCAxOiAwIGJlaW5nIHRoZSBzdGFydCBvZiB0aGUgc2NhbGUgKGxlZnQgb3IgdG9wKSBhbmQgMSB0aGUgb3RoZXJcclxuICogZXh0cmVtaXR5IChsZWZ0ICsgd2lkdGggb3IgdG9wICsgaGVpZ2h0KS4gTm90ZSB0aGF0IGl0IHdvdWxkIGJlIG1vcmUgb3B0aW1pemVkIHRvIGRpcmVjdGx5XHJcbiAqIHN0b3JlIHByZS1jb21wdXRlZCBwaXhlbHMsIGJ1dCB0aGUgc2NhbGUgZGltZW5zaW9ucyBhcmUgbm90IGd1YXJhbnRlZWQgYXQgdGhlIHRpbWUgd2UgbmVlZFxyXG4gKiB0byBjcmVhdGUgdGhlIGxvb2t1cCB0YWJsZS4gVGhlIHRhYmxlIEFMV0FZUyBjb250YWlucyBhdCBsZWFzdCB0d28gaXRlbXM6IG1pbiBhbmQgbWF4LlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcltdfSB0aW1lc3RhbXBzIC0gdGltZXN0YW1wcyBzb3J0ZWQgZnJvbSBsb3dlc3QgdG8gaGlnaGVzdC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3RyaWJ1dGlvbiAtIElmICdsaW5lYXInLCB0aW1lc3RhbXBzIHdpbGwgYmUgc3ByZWFkIGxpbmVhcmx5IGFsb25nIHRoZSBtaW5cclxuICogYW5kIG1heCByYW5nZSwgc28gYmFzaWNhbGx5LCB0aGUgdGFibGUgd2lsbCBjb250YWlucyBvbmx5IHR3byBpdGVtczoge21pbiwgMH0gYW5kIHttYXgsIDF9LlxyXG4gKiBJZiAnc2VyaWVzJywgdGltZXN0YW1wcyB3aWxsIGJlIHBvc2l0aW9uZWQgYXQgdGhlIHNhbWUgZGlzdGFuY2UgZnJvbSBlYWNoIG90aGVyLiBJbiB0aGlzXHJcbiAqIGNhc2UsIG9ubHkgdGltZXN0YW1wcyB0aGF0IGJyZWFrIHRoZSB0aW1lIGxpbmVhcml0eSBhcmUgcmVnaXN0ZXJlZCwgbWVhbmluZyB0aGF0IGluIHRoZVxyXG4gKiBiZXN0IGNhc2UsIGFsbCB0aW1lc3RhbXBzIGFyZSBsaW5lYXIsIHRoZSB0YWJsZSBjb250YWlucyBvbmx5IG1pbiBhbmQgbWF4LlxyXG4gKi9cclxuZnVuY3Rpb24gYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzLCBtaW4sIG1heCwgZGlzdHJpYnV0aW9uKSB7XHJcblx0aWYgKGRpc3RyaWJ1dGlvbiA9PT0gJ2xpbmVhcicgfHwgIXRpbWVzdGFtcHMubGVuZ3RoKSB7XHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHR7dGltZTogbWluLCBwb3M6IDB9LFxyXG5cdFx0XHR7dGltZTogbWF4LCBwb3M6IDF9XHJcblx0XHRdO1xyXG5cdH1cclxuXHJcblx0dmFyIHRhYmxlID0gW107XHJcblx0dmFyIGl0ZW1zID0gW21pbl07XHJcblx0dmFyIGksIGlsZW4sIHByZXYsIGN1cnIsIG5leHQ7XHJcblxyXG5cdGZvciAoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0Y3VyciA9IHRpbWVzdGFtcHNbaV07XHJcblx0XHRpZiAoY3VyciA+IG1pbiAmJiBjdXJyIDwgbWF4KSB7XHJcblx0XHRcdGl0ZW1zLnB1c2goY3Vycik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpdGVtcy5wdXNoKG1heCk7XHJcblxyXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdG5leHQgPSBpdGVtc1tpICsgMV07XHJcblx0XHRwcmV2ID0gaXRlbXNbaSAtIDFdO1xyXG5cdFx0Y3VyciA9IGl0ZW1zW2ldO1xyXG5cclxuXHRcdC8vIG9ubHkgYWRkIHBvaW50cyB0aGF0IGJyZWFrcyB0aGUgc2NhbGUgbGluZWFyaXR5XHJcblx0XHRpZiAocHJldiA9PT0gdW5kZWZpbmVkIHx8IG5leHQgPT09IHVuZGVmaW5lZCB8fCBNYXRoLnJvdW5kKChuZXh0ICsgcHJldikgLyAyKSAhPT0gY3Vycikge1xyXG5cdFx0XHR0YWJsZS5wdXNoKHt0aW1lOiBjdXJyLCBwb3M6IGkgLyAoaWxlbiAtIDEpfSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGFibGU7XHJcbn1cclxuXHJcbi8vIEBzZWUgYWRhcHRlZCBmcm9tIGh0dHBzOi8vd3d3LmFudWpnYWtoYXIuY29tLzIwMTQvMDMvMDEvYmluYXJ5LXNlYXJjaC1pbi1qYXZhc2NyaXB0L1xyXG5mdW5jdGlvbiBsb29rdXAodGFibGUsIGtleSwgdmFsdWUpIHtcclxuXHR2YXIgbG8gPSAwO1xyXG5cdHZhciBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XHJcblx0dmFyIG1pZCwgaTAsIGkxO1xyXG5cclxuXHR3aGlsZSAobG8gPj0gMCAmJiBsbyA8PSBoaSkge1xyXG5cdFx0bWlkID0gKGxvICsgaGkpID4+IDE7XHJcblx0XHRpMCA9IHRhYmxlW21pZCAtIDFdIHx8IG51bGw7XHJcblx0XHRpMSA9IHRhYmxlW21pZF07XHJcblxyXG5cdFx0aWYgKCFpMCkge1xyXG5cdFx0XHQvLyBnaXZlbiB2YWx1ZSBpcyBvdXRzaWRlIHRhYmxlIChiZWZvcmUgZmlyc3QgaXRlbSlcclxuXHRcdFx0cmV0dXJuIHtsbzogbnVsbCwgaGk6IGkxfTtcclxuXHRcdH0gZWxzZSBpZiAoaTFba2V5XSA8IHZhbHVlKSB7XHJcblx0XHRcdGxvID0gbWlkICsgMTtcclxuXHRcdH0gZWxzZSBpZiAoaTBba2V5XSA+IHZhbHVlKSB7XHJcblx0XHRcdGhpID0gbWlkIC0gMTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiB7bG86IGkwLCBoaTogaTF9O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gZ2l2ZW4gdmFsdWUgaXMgb3V0c2lkZSB0YWJsZSAoYWZ0ZXIgbGFzdCBpdGVtKVxyXG5cdHJldHVybiB7bG86IGkxLCBoaTogbnVsbH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaW5lYXJseSBpbnRlcnBvbGF0ZXMgdGhlIGdpdmVuIHNvdXJjZSBgdmFsdWVgIHVzaW5nIHRoZSB0YWJsZSBpdGVtcyBgc2tleWAgdmFsdWVzIGFuZFxyXG4gKiByZXR1cm5zIHRoZSBhc3NvY2lhdGVkIGB0a2V5YCB2YWx1ZS4gRm9yIGV4YW1wbGUsIGludGVycG9sYXRlKHRhYmxlLCAndGltZScsIDQyLCAncG9zJylcclxuICogcmV0dXJucyB0aGUgcG9zaXRpb24gZm9yIGEgdGltZXN0YW1wIGVxdWFsIHRvIDQyLiBJZiB2YWx1ZSBpcyBvdXQgb2YgYm91bmRzLCB2YWx1ZXMgYXRcclxuICogaW5kZXggWzAsIDFdIG9yIFtuIC0gMSwgbl0gYXJlIHVzZWQgZm9yIHRoZSBpbnRlcnBvbGF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gaW50ZXJwb2xhdGUkMSh0YWJsZSwgc2tleSwgc3ZhbCwgdGtleSkge1xyXG5cdHZhciByYW5nZSA9IGxvb2t1cCh0YWJsZSwgc2tleSwgc3ZhbCk7XHJcblxyXG5cdC8vIE5vdGU6IHRoZSBsb29rdXAgdGFibGUgQUxXQVlTIGNvbnRhaW5zIGF0IGxlYXN0IDIgaXRlbXMgKG1pbiBhbmQgbWF4KVxyXG5cdHZhciBwcmV2ID0gIXJhbmdlLmxvID8gdGFibGVbMF0gOiAhcmFuZ2UuaGkgPyB0YWJsZVt0YWJsZS5sZW5ndGggLSAyXSA6IHJhbmdlLmxvO1xyXG5cdHZhciBuZXh0ID0gIXJhbmdlLmxvID8gdGFibGVbMV0gOiAhcmFuZ2UuaGkgPyB0YWJsZVt0YWJsZS5sZW5ndGggLSAxXSA6IHJhbmdlLmhpO1xyXG5cclxuXHR2YXIgc3BhbiA9IG5leHRbc2tleV0gLSBwcmV2W3NrZXldO1xyXG5cdHZhciByYXRpbyA9IHNwYW4gPyAoc3ZhbCAtIHByZXZbc2tleV0pIC8gc3BhbiA6IDA7XHJcblx0dmFyIG9mZnNldCA9IChuZXh0W3RrZXldIC0gcHJldlt0a2V5XSkgKiByYXRpbztcclxuXHJcblx0cmV0dXJuIHByZXZbdGtleV0gKyBvZmZzZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRvVGltZXN0YW1wKHNjYWxlLCBpbnB1dCkge1xyXG5cdHZhciBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XHJcblx0dmFyIG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zLnRpbWU7XHJcblx0dmFyIHBhcnNlciA9IG9wdGlvbnMucGFyc2VyO1xyXG5cdHZhciBmb3JtYXQgPSBwYXJzZXIgfHwgb3B0aW9ucy5mb3JtYXQ7XHJcblx0dmFyIHZhbHVlID0gaW5wdXQ7XHJcblxyXG5cdGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHR2YWx1ZSA9IHBhcnNlcih2YWx1ZSk7XHJcblx0fVxyXG5cclxuXHQvLyBPbmx5IHBhcnNlIGlmIGl0cyBub3QgYSB0aW1lc3RhbXAgYWxyZWFkeVxyXG5cdGlmICghaGVscGVycyQxLmlzRmluaXRlKHZhbHVlKSkge1xyXG5cdFx0dmFsdWUgPSB0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJ1xyXG5cdFx0XHQ/IGFkYXB0ZXIucGFyc2UodmFsdWUsIGZvcm1hdClcclxuXHRcdFx0OiBhZGFwdGVyLnBhcnNlKHZhbHVlKTtcclxuXHR9XHJcblxyXG5cdGlmICh2YWx1ZSAhPT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuICt2YWx1ZTtcclxuXHR9XHJcblxyXG5cdC8vIExhYmVscyBhcmUgaW4gYW4gaW5jb21wYXRpYmxlIGZvcm1hdCBhbmQgbm8gYHBhcnNlcmAgaGFzIGJlZW4gcHJvdmlkZWQuXHJcblx0Ly8gVGhlIHVzZXIgbWlnaHQgc3RpbGwgdXNlIHRoZSBkZXByZWNhdGVkIGBmb3JtYXRgIG9wdGlvbiBmb3IgcGFyc2luZy5cclxuXHRpZiAoIXBhcnNlciAmJiB0eXBlb2YgZm9ybWF0ID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHR2YWx1ZSA9IGZvcm1hdChpbnB1dCk7XHJcblxyXG5cdFx0Ly8gYGZvcm1hdGAgY291bGQgcmV0dXJuIHNvbWV0aGluZyBlbHNlIHRoYW4gYSB0aW1lc3RhbXAsIGlmIHNvLCBwYXJzZSBpdFxyXG5cdFx0aWYgKCFoZWxwZXJzJDEuaXNGaW5pdGUodmFsdWUpKSB7XHJcblx0XHRcdHZhbHVlID0gYWRhcHRlci5wYXJzZSh2YWx1ZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdmFsdWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlKHNjYWxlLCBpbnB1dCkge1xyXG5cdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZihpbnB1dCkpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0dmFyIG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zLnRpbWU7XHJcblx0dmFyIHZhbHVlID0gdG9UaW1lc3RhbXAoc2NhbGUsIHNjYWxlLmdldFJpZ2h0VmFsdWUoaW5wdXQpKTtcclxuXHRpZiAodmFsdWUgPT09IG51bGwpIHtcclxuXHRcdHJldHVybiB2YWx1ZTtcclxuXHR9XHJcblxyXG5cdGlmIChvcHRpb25zLnJvdW5kKSB7XHJcblx0XHR2YWx1ZSA9ICtzY2FsZS5fYWRhcHRlci5zdGFydE9mKHZhbHVlLCBvcHRpb25zLnJvdW5kKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB2YWx1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpZ3VyZXMgb3V0IHdoYXQgdW5pdCByZXN1bHRzIGluIGFuIGFwcHJvcHJpYXRlIG51bWJlciBvZiBhdXRvLWdlbmVyYXRlZCB0aWNrc1xyXG4gKi9cclxuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyhtaW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcclxuXHR2YXIgaWxlbiA9IFVOSVRTLmxlbmd0aDtcclxuXHR2YXIgaSwgaW50ZXJ2YWwsIGZhY3RvcjtcclxuXHJcblx0Zm9yIChpID0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaSA8IGlsZW4gLSAxOyArK2kpIHtcclxuXHRcdGludGVydmFsID0gSU5URVJWQUxTW1VOSVRTW2ldXTtcclxuXHRcdGZhY3RvciA9IGludGVydmFsLnN0ZXBzID8gaW50ZXJ2YWwuc3RlcHMgOiBNQVhfSU5URUdFUjtcclxuXHJcblx0XHRpZiAoaW50ZXJ2YWwuY29tbW9uICYmIE1hdGguY2VpbCgobWF4IC0gbWluKSAvIChmYWN0b3IgKiBpbnRlcnZhbC5zaXplKSkgPD0gY2FwYWNpdHkpIHtcclxuXHRcdFx0cmV0dXJuIFVOSVRTW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIFVOSVRTW2lsZW4gLSAxXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpZ3VyZXMgb3V0IHdoYXQgdW5pdCB0byBmb3JtYXQgYSBzZXQgb2YgdGlja3Mgd2l0aFxyXG4gKi9cclxuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcoc2NhbGUsIG51bVRpY2tzLCBtaW5Vbml0LCBtaW4sIG1heCkge1xyXG5cdHZhciBpLCB1bml0O1xyXG5cclxuXHRmb3IgKGkgPSBVTklUUy5sZW5ndGggLSAxOyBpID49IFVOSVRTLmluZGV4T2YobWluVW5pdCk7IGktLSkge1xyXG5cdFx0dW5pdCA9IFVOSVRTW2ldO1xyXG5cdFx0aWYgKElOVEVSVkFMU1t1bml0XS5jb21tb24gJiYgc2NhbGUuX2FkYXB0ZXIuZGlmZihtYXgsIG1pbiwgdW5pdCkgPj0gbnVtVGlja3MgLSAxKSB7XHJcblx0XHRcdHJldHVybiB1bml0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIFVOSVRTW21pblVuaXQgPyBVTklUUy5pbmRleE9mKG1pblVuaXQpIDogMF07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRldGVybWluZU1ham9yVW5pdCh1bml0KSB7XHJcblx0Zm9yICh2YXIgaSA9IFVOSVRTLmluZGV4T2YodW5pdCkgKyAxLCBpbGVuID0gVU5JVFMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRpZiAoSU5URVJWQUxTW1VOSVRTW2ldXS5jb21tb24pIHtcclxuXHRcdFx0cmV0dXJuIFVOSVRTW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIG1heGltdW0gb2YgYGNhcGFjaXR5YCB0aW1lc3RhbXBzIGJldHdlZW4gbWluIGFuZCBtYXgsIHJvdW5kZWQgdG8gdGhlXHJcbiAqIGBtaW5vcmAgdW5pdCB1c2luZyB0aGUgZ2l2ZW4gc2NhbGUgdGltZSBgb3B0aW9uc2AuXHJcbiAqIEltcG9ydGFudDogdGhpcyBtZXRob2QgY2FuIHJldHVybiB0aWNrcyBvdXRzaWRlIHRoZSBtaW4gYW5kIG1heCByYW5nZSwgaXQncyB0aGVcclxuICogcmVzcG9uc2liaWxpdHkgb2YgdGhlIGNhbGxpbmcgY29kZSB0byBjbGFtcCB2YWx1ZXMgaWYgbmVlZGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGUoc2NhbGUsIG1pbiwgbWF4LCBjYXBhY2l0eSkge1xyXG5cdHZhciBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XHJcblx0dmFyIG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zO1xyXG5cdHZhciB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcclxuXHR2YXIgbWlub3IgPSB0aW1lT3B0cy51bml0IHx8IGRldGVybWluZVVuaXRGb3JBdXRvVGlja3ModGltZU9wdHMubWluVW5pdCwgbWluLCBtYXgsIGNhcGFjaXR5KTtcclxuXHR2YXIgc3RlcFNpemUgPSByZXNvbHZlJDUoW3RpbWVPcHRzLnN0ZXBTaXplLCB0aW1lT3B0cy51bml0U3RlcFNpemUsIDFdKTtcclxuXHR2YXIgd2Vla2RheSA9IG1pbm9yID09PSAnd2VlaycgPyB0aW1lT3B0cy5pc29XZWVrZGF5IDogZmFsc2U7XHJcblx0dmFyIGZpcnN0ID0gbWluO1xyXG5cdHZhciB0aWNrcyA9IFtdO1xyXG5cdHZhciB0aW1lO1xyXG5cclxuXHQvLyBGb3IgJ3dlZWsnIHVuaXQsIGhhbmRsZSB0aGUgZmlyc3QgZGF5IG9mIHdlZWsgb3B0aW9uXHJcblx0aWYgKHdlZWtkYXkpIHtcclxuXHRcdGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgJ2lzb1dlZWsnLCB3ZWVrZGF5KTtcclxuXHR9XHJcblxyXG5cdC8vIEFsaWduIGZpcnN0IHRpY2tzIG9uIHVuaXRcclxuXHRmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsIHdlZWtkYXkgPyAnZGF5JyA6IG1pbm9yKTtcclxuXHJcblx0Ly8gUHJldmVudCBicm93c2VyIGZyb20gZnJlZXppbmcgaW4gY2FzZSB1c2VyIG9wdGlvbnMgcmVxdWVzdCBtaWxsaW9ucyBvZiBtaWxsaXNlY29uZHNcclxuXHRpZiAoYWRhcHRlci5kaWZmKG1heCwgbWluLCBtaW5vcikgPiAxMDAwMDAgKiBzdGVwU2l6ZSkge1xyXG5cdFx0dGhyb3cgbWluICsgJyBhbmQgJyArIG1heCArICcgYXJlIHRvbyBmYXIgYXBhcnQgd2l0aCBzdGVwU2l6ZSBvZiAnICsgc3RlcFNpemUgKyAnICcgKyBtaW5vcjtcclxuXHR9XHJcblxyXG5cdGZvciAodGltZSA9IGZpcnN0OyB0aW1lIDwgbWF4OyB0aW1lID0gK2FkYXB0ZXIuYWRkKHRpbWUsIHN0ZXBTaXplLCBtaW5vcikpIHtcclxuXHRcdHRpY2tzLnB1c2godGltZSk7XHJcblx0fVxyXG5cclxuXHRpZiAodGltZSA9PT0gbWF4IHx8IG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnKSB7XHJcblx0XHR0aWNrcy5wdXNoKHRpbWUpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRpY2tzO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgc3RhcnQgYW5kIGVuZCBvZmZzZXRzIGZyb20gZWRnZXMgaW4gdGhlIGZvcm0gb2Yge3N0YXJ0LCBlbmR9XHJcbiAqIHdoZXJlIGVhY2ggdmFsdWUgaXMgYSByZWxhdGl2ZSB3aWR0aCB0byB0aGUgc2NhbGUgYW5kIHJhbmdlcyBiZXR3ZWVuIDAgYW5kIDEuXHJcbiAqIFRoZXkgYWRkIGV4dHJhIG1hcmdpbnMgb24gdGhlIGJvdGggc2lkZXMgYnkgc2NhbGluZyBkb3duIHRoZSBvcmlnaW5hbCBzY2FsZS5cclxuICogT2Zmc2V0cyBhcmUgYWRkZWQgd2hlbiB0aGUgYG9mZnNldGAgb3B0aW9uIGlzIHRydWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyh0YWJsZSwgdGlja3MsIG1pbiwgbWF4LCBvcHRpb25zKSB7XHJcblx0dmFyIHN0YXJ0ID0gMDtcclxuXHR2YXIgZW5kID0gMDtcclxuXHR2YXIgZmlyc3QsIGxhc3Q7XHJcblxyXG5cdGlmIChvcHRpb25zLm9mZnNldCAmJiB0aWNrcy5sZW5ndGgpIHtcclxuXHRcdGZpcnN0ID0gaW50ZXJwb2xhdGUkMSh0YWJsZSwgJ3RpbWUnLCB0aWNrc1swXSwgJ3BvcycpO1xyXG5cdFx0aWYgKHRpY2tzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0XHRzdGFydCA9IDEgLSBmaXJzdDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN0YXJ0ID0gKGludGVycG9sYXRlJDEodGFibGUsICd0aW1lJywgdGlja3NbMV0sICdwb3MnKSAtIGZpcnN0KSAvIDI7XHJcblx0XHR9XHJcblx0XHRsYXN0ID0gaW50ZXJwb2xhdGUkMSh0YWJsZSwgJ3RpbWUnLCB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXSwgJ3BvcycpO1xyXG5cdFx0aWYgKHRpY2tzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0XHRlbmQgPSBsYXN0O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZW5kID0gKGxhc3QgLSBpbnRlcnBvbGF0ZSQxKHRhYmxlLCAndGltZScsIHRpY2tzW3RpY2tzLmxlbmd0aCAtIDJdLCAncG9zJykpIC8gMjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB7c3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgZmFjdG9yOiAxIC8gKHN0YXJ0ICsgMSArIGVuZCl9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpIHtcclxuXHR2YXIgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xyXG5cdHZhciBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YodGlja3NbMF0udmFsdWUsIG1ham9yVW5pdCk7XHJcblx0dmFyIGxhc3QgPSB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZTtcclxuXHR2YXIgbWFqb3IsIGluZGV4O1xyXG5cclxuXHRmb3IgKG1ham9yID0gZmlyc3Q7IG1ham9yIDw9IGxhc3Q7IG1ham9yID0gK2FkYXB0ZXIuYWRkKG1ham9yLCAxLCBtYWpvclVuaXQpKSB7XHJcblx0XHRpbmRleCA9IG1hcFttYWpvcl07XHJcblx0XHRpZiAoaW5kZXggPj0gMCkge1xyXG5cdFx0XHR0aWNrc1tpbmRleF0ubWFqb3IgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gdGlja3M7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRpY2tzRnJvbVRpbWVzdGFtcHMoc2NhbGUsIHZhbHVlcywgbWFqb3JVbml0KSB7XHJcblx0dmFyIHRpY2tzID0gW107XHJcblx0dmFyIG1hcCA9IHt9O1xyXG5cdHZhciBpbGVuID0gdmFsdWVzLmxlbmd0aDtcclxuXHR2YXIgaSwgdmFsdWU7XHJcblxyXG5cdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdHZhbHVlID0gdmFsdWVzW2ldO1xyXG5cdFx0bWFwW3ZhbHVlXSA9IGk7XHJcblxyXG5cdFx0dGlja3MucHVzaCh7XHJcblx0XHRcdHZhbHVlOiB2YWx1ZSxcclxuXHRcdFx0bWFqb3I6IGZhbHNlXHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8vIFdlIHNldCB0aGUgbWFqb3IgdGlja3Mgc2VwYXJhdGVseSBmcm9tIHRoZSBhYm92ZSBsb29wIGJlY2F1c2UgY2FsbGluZyBzdGFydE9mIGZvciBldmVyeSB0aWNrXHJcblx0Ly8gaXMgZXhwZW5zaXZlIHdoZW4gdGhlcmUgaXMgYSBsYXJnZSBudW1iZXIgb2YgdGlja3NcclxuXHRyZXR1cm4gKGlsZW4gPT09IDAgfHwgIW1ham9yVW5pdCkgPyB0aWNrcyA6IHNldE1ham9yVGlja3Moc2NhbGUsIHRpY2tzLCBtYXAsIG1ham9yVW5pdCk7XHJcbn1cclxuXHJcbnZhciBkZWZhdWx0Q29uZmlnJDQgPSB7XHJcblx0cG9zaXRpb246ICdib3R0b20nLFxyXG5cclxuXHQvKipcclxuXHQgKiBEYXRhIGRpc3RyaWJ1dGlvbiBhbG9uZyB0aGUgc2NhbGU6XHJcblx0ICogLSAnbGluZWFyJzogZGF0YSBhcmUgc3ByZWFkIGFjY29yZGluZyB0byB0aGVpciB0aW1lIChkaXN0YW5jZXMgY2FuIHZhcnkpLFxyXG5cdCAqIC0gJ3Nlcmllcyc6IGRhdGEgYXJlIHNwcmVhZCBhdCB0aGUgc2FtZSBkaXN0YW5jZSBmcm9tIGVhY2ggb3RoZXIuXHJcblx0ICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1MDdcclxuXHQgKiBAc2luY2UgMi43LjBcclxuXHQgKi9cclxuXHRkaXN0cmlidXRpb246ICdsaW5lYXInLFxyXG5cclxuXHQvKipcclxuXHQgKiBTY2FsZSBib3VuZGFyeSBzdHJhdGVneSAoYnlwYXNzZWQgYnkgbWluL21heCB0aW1lIG9wdGlvbnMpXHJcblx0ICogLSBgZGF0YWA6IG1ha2Ugc3VyZSBkYXRhIGFyZSBmdWxseSB2aXNpYmxlLCB0aWNrcyBvdXRzaWRlIGFyZSByZW1vdmVkXHJcblx0ICogLSBgdGlja3NgOiBtYWtlIHN1cmUgdGlja3MgYXJlIGZ1bGx5IHZpc2libGUsIGRhdGEgb3V0c2lkZSBhcmUgdHJ1bmNhdGVkXHJcblx0ICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1NTZcclxuXHQgKiBAc2luY2UgMi43LjBcclxuXHQgKi9cclxuXHRib3VuZHM6ICdkYXRhJyxcclxuXHJcblx0YWRhcHRlcnM6IHt9LFxyXG5cdHRpbWU6IHtcclxuXHRcdHBhcnNlcjogZmFsc2UsIC8vIGZhbHNlID09IGEgcGF0dGVybiBzdHJpbmcgZnJvbSBodHRwczovL21vbWVudGpzLmNvbS9kb2NzLyMvcGFyc2luZy9zdHJpbmctZm9ybWF0LyBvciBhIGN1c3RvbSBjYWxsYmFjayB0aGF0IGNvbnZlcnRzIGl0cyBhcmd1bWVudCB0byBhIG1vbWVudFxyXG5cdFx0dW5pdDogZmFsc2UsIC8vIGZhbHNlID09IGF1dG9tYXRpYyBvciBvdmVycmlkZSB3aXRoIHdlZWssIG1vbnRoLCB5ZWFyLCBldGMuXHJcblx0XHRyb3VuZDogZmFsc2UsIC8vIG5vbmUsIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cclxuXHRcdGRpc3BsYXlGb3JtYXQ6IGZhbHNlLCAvLyBERVBSRUNBVEVEXHJcblx0XHRpc29XZWVrZGF5OiBmYWxzZSwgLy8gb3ZlcnJpZGUgd2VlayBzdGFydCBkYXkgLSBzZWUgaHR0cHM6Ly9tb21lbnRqcy5jb20vZG9jcy8jL2dldC1zZXQvaXNvLXdlZWtkYXkvXHJcblx0XHRtaW5Vbml0OiAnbWlsbGlzZWNvbmQnLFxyXG5cdFx0ZGlzcGxheUZvcm1hdHM6IHt9XHJcblx0fSxcclxuXHR0aWNrczoge1xyXG5cdFx0YXV0b1NraXA6IGZhbHNlLFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGlja3MgZ2VuZXJhdGlvbiBpbnB1dCB2YWx1ZXM6XHJcblx0XHQgKiAtICdhdXRvJzogZ2VuZXJhdGVzIFwib3B0aW1hbFwiIHRpY2tzIGJhc2VkIG9uIHNjYWxlIHNpemUgYW5kIHRpbWUgb3B0aW9ucy5cclxuXHRcdCAqIC0gJ2RhdGEnOiBnZW5lcmF0ZXMgdGlja3MgZnJvbSBkYXRhIChpbmNsdWRpbmcgbGFiZWxzIGZyb20gZGF0YSB7dHx4fHl9IG9iamVjdHMpLlxyXG5cdFx0ICogLSAnbGFiZWxzJzogZ2VuZXJhdGVzIHRpY2tzIGZyb20gdXNlciBnaXZlbiBgZGF0YS5sYWJlbHNgIHZhbHVlcyBPTkxZLlxyXG5cdFx0ICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1MDdcclxuXHRcdCAqIEBzaW5jZSAyLjcuMFxyXG5cdFx0ICovXHJcblx0XHRzb3VyY2U6ICdhdXRvJyxcclxuXHJcblx0XHRtYWpvcjoge1xyXG5cdFx0XHRlbmFibGVkOiBmYWxzZVxyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbnZhciBzY2FsZV90aW1lID0gY29yZV9zY2FsZS5leHRlbmQoe1xyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5tZXJnZVRpY2tzT3B0aW9ucygpO1xyXG5cdFx0Y29yZV9zY2FsZS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIHRpbWUgPSBvcHRpb25zLnRpbWUgfHwgKG9wdGlvbnMudGltZSA9IHt9KTtcclxuXHRcdHZhciBhZGFwdGVyID0gbWUuX2FkYXB0ZXIgPSBuZXcgY29yZV9hZGFwdGVycy5fZGF0ZShvcHRpb25zLmFkYXB0ZXJzLmRhdGUpO1xyXG5cclxuXHRcdC8vIERFUFJFQ0FUSU9OUzogb3V0cHV0IGEgbWVzc2FnZSBvbmx5IG9uZSB0aW1lIHBlciB1cGRhdGVcclxuXHRcdGRlcHJlY2F0ZWQkMSgndGltZSBzY2FsZScsIHRpbWUuZm9ybWF0LCAndGltZS5mb3JtYXQnLCAndGltZS5wYXJzZXInKTtcclxuXHRcdGRlcHJlY2F0ZWQkMSgndGltZSBzY2FsZScsIHRpbWUubWluLCAndGltZS5taW4nLCAndGlja3MubWluJyk7XHJcblx0XHRkZXByZWNhdGVkJDEoJ3RpbWUgc2NhbGUnLCB0aW1lLm1heCwgJ3RpbWUubWF4JywgJ3RpY2tzLm1heCcpO1xyXG5cclxuXHRcdC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IGJlZm9yZSBpbnRyb2R1Y2luZyBhZGFwdGVyLCBgZGlzcGxheUZvcm1hdHNgIHdhc1xyXG5cdFx0Ly8gc3VwcG9zZWQgdG8gY29udGFpbiAqYWxsKiB1bml0L3N0cmluZyBwYWlycyBidXQgdGhpcyBjYW4ndCBiZSByZXNvbHZlZFxyXG5cdFx0Ly8gd2hlbiBsb2FkaW5nIHRoZSBzY2FsZSAoYWRhcHRlcnMgYXJlIGxvYWRlZCBhZnRlcndhcmQpLCBzbyBsZXQncyBwb3B1bGF0ZVxyXG5cdFx0Ly8gbWlzc2luZyBmb3JtYXRzIG9uIHVwZGF0ZVxyXG5cdFx0aGVscGVycyQxLm1lcmdlSWYodGltZS5kaXNwbGF5Rm9ybWF0cywgYWRhcHRlci5mb3JtYXRzKCkpO1xyXG5cclxuXHRcdHJldHVybiBjb3JlX3NjYWxlLnByb3RvdHlwZS51cGRhdGUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQWxsb3dzIGRhdGEgdG8gYmUgcmVmZXJlbmNlZCB2aWEgJ3QnIGF0dHJpYnV0ZVxyXG5cdCAqL1xyXG5cdGdldFJpZ2h0VmFsdWU6IGZ1bmN0aW9uKHJhd1ZhbHVlKSB7XHJcblx0XHRpZiAocmF3VmFsdWUgJiYgcmF3VmFsdWUudCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJhd1ZhbHVlID0gcmF3VmFsdWUudDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBjb3JlX3NjYWxlLnByb3RvdHlwZS5nZXRSaWdodFZhbHVlLmNhbGwodGhpcywgcmF3VmFsdWUpO1xyXG5cdH0sXHJcblxyXG5cdGRldGVybWluZURhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIGFkYXB0ZXIgPSBtZS5fYWRhcHRlcjtcclxuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcclxuXHRcdHZhciB1bml0ID0gb3B0aW9ucy50aW1lLnVuaXQgfHwgJ2RheSc7XHJcblx0XHR2YXIgbWluID0gTUFYX0lOVEVHRVI7XHJcblx0XHR2YXIgbWF4ID0gTUlOX0lOVEVHRVI7XHJcblx0XHR2YXIgdGltZXN0YW1wcyA9IFtdO1xyXG5cdFx0dmFyIGRhdGFzZXRzID0gW107XHJcblx0XHR2YXIgbGFiZWxzID0gW107XHJcblx0XHR2YXIgaSwgaiwgaWxlbiwgamxlbiwgZGF0YSwgdGltZXN0YW1wLCBsYWJlbHNBZGRlZDtcclxuXHRcdHZhciBkYXRhTGFiZWxzID0gbWUuX2dldExhYmVscygpO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhTGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRsYWJlbHMucHVzaChwYXJzZShtZSwgZGF0YUxhYmVsc1tpXSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XHJcblx0XHRcdFx0ZGF0YSA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbaV0uZGF0YTtcclxuXHJcblx0XHRcdFx0Ly8gTGV0J3MgY29uc2lkZXIgdGhhdCBhbGwgZGF0YSBoYXZlIHRoZSBzYW1lIGZvcm1hdC5cclxuXHRcdFx0XHRpZiAoaGVscGVycyQxLmlzT2JqZWN0KGRhdGFbMF0pKSB7XHJcblx0XHRcdFx0XHRkYXRhc2V0c1tpXSA9IFtdO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoaiA9IDAsIGpsZW4gPSBkYXRhLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xyXG5cdFx0XHRcdFx0XHR0aW1lc3RhbXAgPSBwYXJzZShtZSwgZGF0YVtqXSk7XHJcblx0XHRcdFx0XHRcdHRpbWVzdGFtcHMucHVzaCh0aW1lc3RhbXApO1xyXG5cdFx0XHRcdFx0XHRkYXRhc2V0c1tpXVtqXSA9IHRpbWVzdGFtcDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0ZGF0YXNldHNbaV0gPSBsYWJlbHMuc2xpY2UoMCk7XHJcblx0XHRcdFx0XHRpZiAoIWxhYmVsc0FkZGVkKSB7XHJcblx0XHRcdFx0XHRcdHRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzLmNvbmNhdChsYWJlbHMpO1xyXG5cdFx0XHRcdFx0XHRsYWJlbHNBZGRlZCA9IHRydWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGRhdGFzZXRzW2ldID0gW107XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGFiZWxzLmxlbmd0aCkge1xyXG5cdFx0XHRtaW4gPSBNYXRoLm1pbihtaW4sIGxhYmVsc1swXSk7XHJcblx0XHRcdG1heCA9IE1hdGgubWF4KG1heCwgbGFiZWxzW2xhYmVscy5sZW5ndGggLSAxXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XHJcblx0XHRcdHRpbWVzdGFtcHMgPSBpbGVuID4gMSA/IGFycmF5VW5pcXVlKHRpbWVzdGFtcHMpLnNvcnQoc29ydGVyKSA6IHRpbWVzdGFtcHMuc29ydChzb3J0ZXIpO1xyXG5cdFx0XHRtaW4gPSBNYXRoLm1pbihtaW4sIHRpbWVzdGFtcHNbMF0pO1xyXG5cdFx0XHRtYXggPSBNYXRoLm1heChtYXgsIHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bWluID0gcGFyc2UobWUsIGdldE1pbihvcHRpb25zKSkgfHwgbWluO1xyXG5cdFx0bWF4ID0gcGFyc2UobWUsIGdldE1heChvcHRpb25zKSkgfHwgbWF4O1xyXG5cclxuXHRcdC8vIEluIGNhc2UgdGhlcmUgaXMgbm8gdmFsaWQgbWluL21heCwgc2V0IGxpbWl0cyBiYXNlZCBvbiB1bml0IHRpbWUgb3B0aW9uXHJcblx0XHRtaW4gPSBtaW4gPT09IE1BWF9JTlRFR0VSID8gK2FkYXB0ZXIuc3RhcnRPZihEYXRlLm5vdygpLCB1bml0KSA6IG1pbjtcclxuXHRcdG1heCA9IG1heCA9PT0gTUlOX0lOVEVHRVIgPyArYWRhcHRlci5lbmRPZihEYXRlLm5vdygpLCB1bml0KSArIDEgOiBtYXg7XHJcblxyXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbWF4IGlzIHN0cmljdGx5IGhpZ2hlciB0aGFuIG1pbiAocmVxdWlyZWQgYnkgdGhlIGxvb2t1cCB0YWJsZSlcclxuXHRcdG1lLm1pbiA9IE1hdGgubWluKG1pbiwgbWF4KTtcclxuXHRcdG1lLm1heCA9IE1hdGgubWF4KG1pbiArIDEsIG1heCk7XHJcblxyXG5cdFx0Ly8gUFJJVkFURVxyXG5cdFx0bWUuX3RhYmxlID0gW107XHJcblx0XHRtZS5fdGltZXN0YW1wcyA9IHtcclxuXHRcdFx0ZGF0YTogdGltZXN0YW1wcyxcclxuXHRcdFx0ZGF0YXNldHM6IGRhdGFzZXRzLFxyXG5cdFx0XHRsYWJlbHM6IGxhYmVsc1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRidWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWluID0gbWUubWluO1xyXG5cdFx0dmFyIG1heCA9IG1lLm1heDtcclxuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcclxuXHRcdHZhciB0aWNrT3B0cyA9IG9wdGlvbnMudGlja3M7XHJcblx0XHR2YXIgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XHJcblx0XHR2YXIgdGltZXN0YW1wcyA9IG1lLl90aW1lc3RhbXBzO1xyXG5cdFx0dmFyIHRpY2tzID0gW107XHJcblx0XHR2YXIgY2FwYWNpdHkgPSBtZS5nZXRMYWJlbENhcGFjaXR5KG1pbik7XHJcblx0XHR2YXIgc291cmNlID0gdGlja09wdHMuc291cmNlO1xyXG5cdFx0dmFyIGRpc3RyaWJ1dGlvbiA9IG9wdGlvbnMuZGlzdHJpYnV0aW9uO1xyXG5cdFx0dmFyIGksIGlsZW4sIHRpbWVzdGFtcDtcclxuXHJcblx0XHRpZiAoc291cmNlID09PSAnZGF0YScgfHwgKHNvdXJjZSA9PT0gJ2F1dG8nICYmIGRpc3RyaWJ1dGlvbiA9PT0gJ3NlcmllcycpKSB7XHJcblx0XHRcdHRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzLmRhdGE7XHJcblx0XHR9IGVsc2UgaWYgKHNvdXJjZSA9PT0gJ2xhYmVscycpIHtcclxuXHRcdFx0dGltZXN0YW1wcyA9IHRpbWVzdGFtcHMubGFiZWxzO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGltZXN0YW1wcyA9IGdlbmVyYXRlKG1lLCBtaW4sIG1heCwgY2FwYWNpdHkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xyXG5cdFx0XHRtaW4gPSB0aW1lc3RhbXBzWzBdO1xyXG5cdFx0XHRtYXggPSB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV07XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRW5mb3JjZSBsaW1pdHMgd2l0aCB1c2VyIG1pbi9tYXggb3B0aW9uc1xyXG5cdFx0bWluID0gcGFyc2UobWUsIGdldE1pbihvcHRpb25zKSkgfHwgbWluO1xyXG5cdFx0bWF4ID0gcGFyc2UobWUsIGdldE1heChvcHRpb25zKSkgfHwgbWF4O1xyXG5cclxuXHRcdC8vIFJlbW92ZSB0aWNrcyBvdXRzaWRlIHRoZSBtaW4vbWF4IHJhbmdlXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gdGltZXN0YW1wcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0dGltZXN0YW1wID0gdGltZXN0YW1wc1tpXTtcclxuXHRcdFx0aWYgKHRpbWVzdGFtcCA+PSBtaW4gJiYgdGltZXN0YW1wIDw9IG1heCkge1xyXG5cdFx0XHRcdHRpY2tzLnB1c2godGltZXN0YW1wKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG1lLm1pbiA9IG1pbjtcclxuXHRcdG1lLm1heCA9IG1heDtcclxuXHJcblx0XHQvLyBQUklWQVRFXHJcblx0XHQvLyBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyByZWxpZXMgb24gdGhlIG51bWJlciBvZiB0aWNrcyBzbyB3ZSBkb24ndCB1c2UgaXQgd2hlblxyXG5cdFx0Ly8gYXV0b1NraXAgaXMgZW5hYmxlZCBiZWNhdXNlIHdlIGRvbid0IHlldCBrbm93IHdoYXQgdGhlIGZpbmFsIG51bWJlciBvZiB0aWNrcyB3aWxsIGJlXHJcblx0XHRtZS5fdW5pdCA9IHRpbWVPcHRzLnVuaXQgfHwgKHRpY2tPcHRzLmF1dG9Ta2lwXHJcblx0XHRcdD8gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCBtZS5taW4sIG1lLm1heCwgY2FwYWNpdHkpXHJcblx0XHRcdDogZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcobWUsIHRpY2tzLmxlbmd0aCwgdGltZU9wdHMubWluVW5pdCwgbWUubWluLCBtZS5tYXgpKTtcclxuXHRcdG1lLl9tYWpvclVuaXQgPSAhdGlja09wdHMubWFqb3IuZW5hYmxlZCB8fCBtZS5fdW5pdCA9PT0gJ3llYXInID8gdW5kZWZpbmVkXHJcblx0XHRcdDogZGV0ZXJtaW5lTWFqb3JVbml0KG1lLl91bml0KTtcclxuXHRcdG1lLl90YWJsZSA9IGJ1aWxkTG9va3VwVGFibGUobWUuX3RpbWVzdGFtcHMuZGF0YSwgbWluLCBtYXgsIGRpc3RyaWJ1dGlvbik7XHJcblx0XHRtZS5fb2Zmc2V0cyA9IGNvbXB1dGVPZmZzZXRzKG1lLl90YWJsZSwgdGlja3MsIG1pbiwgbWF4LCBvcHRpb25zKTtcclxuXHJcblx0XHRpZiAodGlja09wdHMucmV2ZXJzZSkge1xyXG5cdFx0XHR0aWNrcy5yZXZlcnNlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRpY2tzRnJvbVRpbWVzdGFtcHMobWUsIHRpY2tzLCBtZS5fbWFqb3JVbml0KTtcclxuXHR9LFxyXG5cclxuXHRnZXRMYWJlbEZvckluZGV4OiBmdW5jdGlvbihpbmRleCwgZGF0YXNldEluZGV4KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGFkYXB0ZXIgPSBtZS5fYWRhcHRlcjtcclxuXHRcdHZhciBkYXRhID0gbWUuY2hhcnQuZGF0YTtcclxuXHRcdHZhciB0aW1lT3B0cyA9IG1lLm9wdGlvbnMudGltZTtcclxuXHRcdHZhciBsYWJlbCA9IGRhdGEubGFiZWxzICYmIGluZGV4IDwgZGF0YS5sYWJlbHMubGVuZ3RoID8gZGF0YS5sYWJlbHNbaW5kZXhdIDogJyc7XHJcblx0XHR2YXIgdmFsdWUgPSBkYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF07XHJcblxyXG5cdFx0aWYgKGhlbHBlcnMkMS5pc09iamVjdCh2YWx1ZSkpIHtcclxuXHRcdFx0bGFiZWwgPSBtZS5nZXRSaWdodFZhbHVlKHZhbHVlKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aW1lT3B0cy50b29sdGlwRm9ybWF0KSB7XHJcblx0XHRcdHJldHVybiBhZGFwdGVyLmZvcm1hdCh0b1RpbWVzdGFtcChtZSwgbGFiZWwpLCB0aW1lT3B0cy50b29sdGlwRm9ybWF0KTtcclxuXHRcdH1cclxuXHRcdGlmICh0eXBlb2YgbGFiZWwgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdHJldHVybiBsYWJlbDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBhZGFwdGVyLmZvcm1hdCh0b1RpbWVzdGFtcChtZSwgbGFiZWwpLCB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cy5kYXRldGltZSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogRnVuY3Rpb24gdG8gZm9ybWF0IGFuIGluZGl2aWR1YWwgdGljayBtYXJrXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR0aWNrRm9ybWF0RnVuY3Rpb246IGZ1bmN0aW9uKHRpbWUsIGluZGV4LCB0aWNrcywgZm9ybWF0KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGFkYXB0ZXIgPSBtZS5fYWRhcHRlcjtcclxuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcclxuXHRcdHZhciBmb3JtYXRzID0gb3B0aW9ucy50aW1lLmRpc3BsYXlGb3JtYXRzO1xyXG5cdFx0dmFyIG1pbm9yRm9ybWF0ID0gZm9ybWF0c1ttZS5fdW5pdF07XHJcblx0XHR2YXIgbWFqb3JVbml0ID0gbWUuX21ham9yVW5pdDtcclxuXHRcdHZhciBtYWpvckZvcm1hdCA9IGZvcm1hdHNbbWFqb3JVbml0XTtcclxuXHRcdHZhciB0aWNrID0gdGlja3NbaW5kZXhdO1xyXG5cdFx0dmFyIHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcclxuXHRcdHZhciBtYWpvciA9IG1ham9yVW5pdCAmJiBtYWpvckZvcm1hdCAmJiB0aWNrICYmIHRpY2subWFqb3I7XHJcblx0XHR2YXIgbGFiZWwgPSBhZGFwdGVyLmZvcm1hdCh0aW1lLCBmb3JtYXQgPyBmb3JtYXQgOiBtYWpvciA/IG1ham9yRm9ybWF0IDogbWlub3JGb3JtYXQpO1xyXG5cdFx0dmFyIG5lc3RlZFRpY2tPcHRzID0gbWFqb3IgPyB0aWNrT3B0cy5tYWpvciA6IHRpY2tPcHRzLm1pbm9yO1xyXG5cdFx0dmFyIGZvcm1hdHRlciA9IHJlc29sdmUkNShbXHJcblx0XHRcdG5lc3RlZFRpY2tPcHRzLmNhbGxiYWNrLFxyXG5cdFx0XHRuZXN0ZWRUaWNrT3B0cy51c2VyQ2FsbGJhY2ssXHJcblx0XHRcdHRpY2tPcHRzLmNhbGxiYWNrLFxyXG5cdFx0XHR0aWNrT3B0cy51c2VyQ2FsbGJhY2tcclxuXHRcdF0pO1xyXG5cclxuXHRcdHJldHVybiBmb3JtYXR0ZXIgPyBmb3JtYXR0ZXIobGFiZWwsIGluZGV4LCB0aWNrcykgOiBsYWJlbDtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24odGlja3MpIHtcclxuXHRcdHZhciBsYWJlbHMgPSBbXTtcclxuXHRcdHZhciBpLCBpbGVuO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0bGFiZWxzLnB1c2godGhpcy50aWNrRm9ybWF0RnVuY3Rpb24odGlja3NbaV0udmFsdWUsIGksIHRpY2tzKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGxhYmVscztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFBpeGVsRm9yT2Zmc2V0OiBmdW5jdGlvbih0aW1lKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9mZnNldHMgPSBtZS5fb2Zmc2V0cztcclxuXHRcdHZhciBwb3MgPSBpbnRlcnBvbGF0ZSQxKG1lLl90YWJsZSwgJ3RpbWUnLCB0aW1lLCAncG9zJyk7XHJcblx0XHRyZXR1cm4gbWUuZ2V0UGl4ZWxGb3JEZWNpbWFsKChvZmZzZXRzLnN0YXJ0ICsgcG9zKSAqIG9mZnNldHMuZmFjdG9yKTtcclxuXHR9LFxyXG5cclxuXHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGRhdGFzZXRJbmRleCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciB0aW1lID0gbnVsbDtcclxuXHJcblx0XHRpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0SW5kZXggIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aW1lID0gbWUuX3RpbWVzdGFtcHMuZGF0YXNldHNbZGF0YXNldEluZGV4XVtpbmRleF07XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRpbWUgPT09IG51bGwpIHtcclxuXHRcdFx0dGltZSA9IHBhcnNlKG1lLCB2YWx1ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRpbWUgIT09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIG1lLmdldFBpeGVsRm9yT2Zmc2V0KHRpbWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgpIHtcclxuXHRcdHZhciB0aWNrcyA9IHRoaXMuZ2V0VGlja3MoKTtcclxuXHRcdHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgdGlja3MubGVuZ3RoID9cclxuXHRcdFx0dGhpcy5nZXRQaXhlbEZvck9mZnNldCh0aWNrc1tpbmRleF0udmFsdWUpIDpcclxuXHRcdFx0bnVsbDtcclxuXHR9LFxyXG5cclxuXHRnZXRWYWx1ZUZvclBpeGVsOiBmdW5jdGlvbihwaXhlbCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBvZmZzZXRzID0gbWUuX29mZnNldHM7XHJcblx0XHR2YXIgcG9zID0gbWUuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XHJcblx0XHR2YXIgdGltZSA9IGludGVycG9sYXRlJDEobWUuX3RhYmxlLCAncG9zJywgcG9zLCAndGltZScpO1xyXG5cclxuXHRcdC8vIERFUFJFQ0FUSU9OLCB3ZSBzaG91bGQgcmV0dXJuIHRpbWUgZGlyZWN0bHlcclxuXHRcdHJldHVybiBtZS5fYWRhcHRlci5fY3JlYXRlKHRpbWUpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldExhYmVsU2l6ZTogZnVuY3Rpb24obGFiZWwpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgdGlja3NPcHRzID0gbWUub3B0aW9ucy50aWNrcztcclxuXHRcdHZhciB0aWNrTGFiZWxXaWR0aCA9IG1lLmN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XHJcblx0XHR2YXIgYW5nbGUgPSBoZWxwZXJzJDEudG9SYWRpYW5zKG1lLmlzSG9yaXpvbnRhbCgpID8gdGlja3NPcHRzLm1heFJvdGF0aW9uIDogdGlja3NPcHRzLm1pblJvdGF0aW9uKTtcclxuXHRcdHZhciBjb3NSb3RhdGlvbiA9IE1hdGguY29zKGFuZ2xlKTtcclxuXHRcdHZhciBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlKTtcclxuXHRcdHZhciB0aWNrRm9udFNpemUgPSB2YWx1ZU9yRGVmYXVsdCRkKHRpY2tzT3B0cy5mb250U2l6ZSwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRTaXplKTtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR3OiAodGlja0xhYmVsV2lkdGggKiBjb3NSb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogc2luUm90YXRpb24pLFxyXG5cdFx0XHRoOiAodGlja0xhYmVsV2lkdGggKiBzaW5Sb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogY29zUm90YXRpb24pXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENydWRlIGFwcHJveGltYXRpb24gb2Ygd2hhdCB0aGUgbGFiZWwgd2lkdGggbWlnaHQgYmVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldExhYmVsV2lkdGg6IGZ1bmN0aW9uKGxhYmVsKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fZ2V0TGFiZWxTaXplKGxhYmVsKS53O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0TGFiZWxDYXBhY2l0eTogZnVuY3Rpb24oZXhhbXBsZVRpbWUpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgdGltZU9wdHMgPSBtZS5vcHRpb25zLnRpbWU7XHJcblx0XHR2YXIgZGlzcGxheUZvcm1hdHMgPSB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cztcclxuXHJcblx0XHQvLyBwaWNrIHRoZSBsb25nZXN0IGZvcm1hdCAobWlsbGlzZWNvbmRzKSBmb3IgZ3Vlc3RpbWF0aW9uXHJcblx0XHR2YXIgZm9ybWF0ID0gZGlzcGxheUZvcm1hdHNbdGltZU9wdHMudW5pdF0gfHwgZGlzcGxheUZvcm1hdHMubWlsbGlzZWNvbmQ7XHJcblx0XHR2YXIgZXhhbXBsZUxhYmVsID0gbWUudGlja0Zvcm1hdEZ1bmN0aW9uKGV4YW1wbGVUaW1lLCAwLCB0aWNrc0Zyb21UaW1lc3RhbXBzKG1lLCBbZXhhbXBsZVRpbWVdLCBtZS5fbWFqb3JVbml0KSwgZm9ybWF0KTtcclxuXHRcdHZhciBzaXplID0gbWUuX2dldExhYmVsU2l6ZShleGFtcGxlTGFiZWwpO1xyXG5cdFx0dmFyIGNhcGFjaXR5ID0gTWF0aC5mbG9vcihtZS5pc0hvcml6b250YWwoKSA/IG1lLndpZHRoIC8gc2l6ZS53IDogbWUuaGVpZ2h0IC8gc2l6ZS5oKTtcclxuXHJcblx0XHRpZiAobWUub3B0aW9ucy5vZmZzZXQpIHtcclxuXHRcdFx0Y2FwYWNpdHktLTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY2FwYWNpdHkgPiAwID8gY2FwYWNpdHkgOiAxO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBJTlRFUk5BTDogc3RhdGljIGRlZmF1bHQgb3B0aW9ucywgcmVnaXN0ZXJlZCBpbiBzcmMvaW5kZXguanNcclxudmFyIF9kZWZhdWx0cyQ0ID0gZGVmYXVsdENvbmZpZyQ0O1xuc2NhbGVfdGltZS5fZGVmYXVsdHMgPSBfZGVmYXVsdHMkNDtcblxudmFyIHNjYWxlcyA9IHtcclxuXHRjYXRlZ29yeTogc2NhbGVfY2F0ZWdvcnksXHJcblx0bGluZWFyOiBzY2FsZV9saW5lYXIsXHJcblx0bG9nYXJpdGhtaWM6IHNjYWxlX2xvZ2FyaXRobWljLFxyXG5cdHJhZGlhbExpbmVhcjogc2NhbGVfcmFkaWFsTGluZWFyLFxyXG5cdHRpbWU6IHNjYWxlX3RpbWVcclxufTtcblxudmFyIEZPUk1BVFMgPSB7XHJcblx0ZGF0ZXRpbWU6ICdNTU0gRCwgWVlZWSwgaDptbTpzcyBhJyxcclxuXHRtaWxsaXNlY29uZDogJ2g6bW06c3MuU1NTIGEnLFxyXG5cdHNlY29uZDogJ2g6bW06c3MgYScsXHJcblx0bWludXRlOiAnaDptbSBhJyxcclxuXHRob3VyOiAnaEEnLFxyXG5cdGRheTogJ01NTSBEJyxcclxuXHR3ZWVrOiAnbGwnLFxyXG5cdG1vbnRoOiAnTU1NIFlZWVknLFxyXG5cdHF1YXJ0ZXI6ICdbUV1RIC0gWVlZWScsXHJcblx0eWVhcjogJ1lZWVknXHJcbn07XHJcblxyXG5jb3JlX2FkYXB0ZXJzLl9kYXRlLm92ZXJyaWRlKHR5cGVvZiBtb21lbnQgPT09ICdmdW5jdGlvbicgPyB7XHJcblx0X2lkOiAnbW9tZW50JywgLy8gREVCVUcgT05MWVxyXG5cclxuXHRmb3JtYXRzOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBGT1JNQVRTO1xyXG5cdH0sXHJcblxyXG5cdHBhcnNlOiBmdW5jdGlvbih2YWx1ZSwgZm9ybWF0KSB7XHJcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHR2YWx1ZSA9IG1vbWVudCh2YWx1ZSwgZm9ybWF0KTtcclxuXHRcdH0gZWxzZSBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIG1vbWVudCkpIHtcclxuXHRcdFx0dmFsdWUgPSBtb21lbnQodmFsdWUpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlLmlzVmFsaWQoKSA/IHZhbHVlLnZhbHVlT2YoKSA6IG51bGw7XHJcblx0fSxcclxuXHJcblx0Zm9ybWF0OiBmdW5jdGlvbih0aW1lLCBmb3JtYXQpIHtcclxuXHRcdHJldHVybiBtb21lbnQodGltZSkuZm9ybWF0KGZvcm1hdCk7XHJcblx0fSxcclxuXHJcblx0YWRkOiBmdW5jdGlvbih0aW1lLCBhbW91bnQsIHVuaXQpIHtcclxuXHRcdHJldHVybiBtb21lbnQodGltZSkuYWRkKGFtb3VudCwgdW5pdCkudmFsdWVPZigpO1xyXG5cdH0sXHJcblxyXG5cdGRpZmY6IGZ1bmN0aW9uKG1heCwgbWluLCB1bml0KSB7XHJcblx0XHRyZXR1cm4gbW9tZW50KG1heCkuZGlmZihtb21lbnQobWluKSwgdW5pdCk7XHJcblx0fSxcclxuXHJcblx0c3RhcnRPZjogZnVuY3Rpb24odGltZSwgdW5pdCwgd2Vla2RheSkge1xyXG5cdFx0dGltZSA9IG1vbWVudCh0aW1lKTtcclxuXHRcdGlmICh1bml0ID09PSAnaXNvV2VlaycpIHtcclxuXHRcdFx0cmV0dXJuIHRpbWUuaXNvV2Vla2RheSh3ZWVrZGF5KS52YWx1ZU9mKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGltZS5zdGFydE9mKHVuaXQpLnZhbHVlT2YoKTtcclxuXHR9LFxyXG5cclxuXHRlbmRPZjogZnVuY3Rpb24odGltZSwgdW5pdCkge1xyXG5cdFx0cmV0dXJuIG1vbWVudCh0aW1lKS5lbmRPZih1bml0KS52YWx1ZU9mKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gREVQUkVDQVRJT05TXHJcblxyXG5cdC8qKlxyXG5cdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggc2NhbGUuZ2V0VmFsdWVGb3JQaXhlbCgpLlxyXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcclxuXHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfY3JlYXRlOiBmdW5jdGlvbih0aW1lKSB7XHJcblx0XHRyZXR1cm4gbW9tZW50KHRpbWUpO1xyXG5cdH0sXHJcbn0gOiB7fSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xyXG5cdHBsdWdpbnM6IHtcclxuXHRcdGZpbGxlcjoge1xyXG5cdFx0XHRwcm9wYWdhdGU6IHRydWVcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxudmFyIG1hcHBlcnMgPSB7XHJcblx0ZGF0YXNldDogZnVuY3Rpb24oc291cmNlKSB7XHJcblx0XHR2YXIgaW5kZXggPSBzb3VyY2UuZmlsbDtcclxuXHRcdHZhciBjaGFydCA9IHNvdXJjZS5jaGFydDtcclxuXHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xyXG5cdFx0dmFyIHZpc2libGUgPSBtZXRhICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaW5kZXgpO1xyXG5cdFx0dmFyIHBvaW50cyA9ICh2aXNpYmxlICYmIG1ldGEuZGF0YXNldC5fY2hpbGRyZW4pIHx8IFtdO1xyXG5cdFx0dmFyIGxlbmd0aCA9IHBvaW50cy5sZW5ndGggfHwgMDtcclxuXHJcblx0XHRyZXR1cm4gIWxlbmd0aCA/IG51bGwgOiBmdW5jdGlvbihwb2ludCwgaSkge1xyXG5cdFx0XHRyZXR1cm4gKGkgPCBsZW5ndGggJiYgcG9pbnRzW2ldLl92aWV3KSB8fCBudWxsO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRib3VuZGFyeTogZnVuY3Rpb24oc291cmNlKSB7XHJcblx0XHR2YXIgYm91bmRhcnkgPSBzb3VyY2UuYm91bmRhcnk7XHJcblx0XHR2YXIgeCA9IGJvdW5kYXJ5ID8gYm91bmRhcnkueCA6IG51bGw7XHJcblx0XHR2YXIgeSA9IGJvdW5kYXJ5ID8gYm91bmRhcnkueSA6IG51bGw7XHJcblxyXG5cdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KGJvdW5kYXJ5KSkge1xyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24ocG9pbnQsIGkpIHtcclxuXHRcdFx0XHRyZXR1cm4gYm91bmRhcnlbaV07XHJcblx0XHRcdH07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHBvaW50KSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0eDogeCA9PT0gbnVsbCA/IHBvaW50LnggOiB4LFxyXG5cdFx0XHRcdHk6IHkgPT09IG51bGwgPyBwb2ludC55IDogeSxcclxuXHRcdFx0fTtcclxuXHRcdH07XHJcblx0fVxyXG59O1xyXG5cclxuLy8gQHRvZG8gaWYgKGZpbGxbMF0gPT09ICcjJylcclxuZnVuY3Rpb24gZGVjb2RlRmlsbChlbCwgaW5kZXgsIGNvdW50KSB7XHJcblx0dmFyIG1vZGVsID0gZWwuX21vZGVsIHx8IHt9O1xyXG5cdHZhciBmaWxsID0gbW9kZWwuZmlsbDtcclxuXHR2YXIgdGFyZ2V0O1xyXG5cclxuXHRpZiAoZmlsbCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRmaWxsID0gISFtb2RlbC5iYWNrZ3JvdW5kQ29sb3I7XHJcblx0fVxyXG5cclxuXHRpZiAoZmlsbCA9PT0gZmFsc2UgfHwgZmlsbCA9PT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0aWYgKGZpbGwgPT09IHRydWUpIHtcclxuXHRcdHJldHVybiAnb3JpZ2luJztcclxuXHR9XHJcblxyXG5cdHRhcmdldCA9IHBhcnNlRmxvYXQoZmlsbCwgMTApO1xyXG5cdGlmIChpc0Zpbml0ZSh0YXJnZXQpICYmIE1hdGguZmxvb3IodGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XHJcblx0XHRpZiAoZmlsbFswXSA9PT0gJy0nIHx8IGZpbGxbMF0gPT09ICcrJykge1xyXG5cdFx0XHR0YXJnZXQgPSBpbmRleCArIHRhcmdldDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGFyZ2V0ID09PSBpbmRleCB8fCB0YXJnZXQgPCAwIHx8IHRhcmdldCA+PSBjb3VudCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldDtcclxuXHR9XHJcblxyXG5cdHN3aXRjaCAoZmlsbCkge1xyXG5cdC8vIGNvbXBhdGliaWxpdHlcclxuXHRjYXNlICdib3R0b20nOlxyXG5cdFx0cmV0dXJuICdzdGFydCc7XHJcblx0Y2FzZSAndG9wJzpcclxuXHRcdHJldHVybiAnZW5kJztcclxuXHRjYXNlICd6ZXJvJzpcclxuXHRcdHJldHVybiAnb3JpZ2luJztcclxuXHQvLyBzdXBwb3J0ZWQgYm91bmRhcmllc1xyXG5cdGNhc2UgJ29yaWdpbic6XHJcblx0Y2FzZSAnc3RhcnQnOlxyXG5cdGNhc2UgJ2VuZCc6XHJcblx0XHRyZXR1cm4gZmlsbDtcclxuXHQvLyBpbnZhbGlkIGZpbGwgdmFsdWVzXHJcblx0ZGVmYXVsdDpcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpIHtcclxuXHR2YXIgbW9kZWwgPSBzb3VyY2UuZWwuX21vZGVsIHx8IHt9O1xyXG5cdHZhciBzY2FsZSA9IHNvdXJjZS5lbC5fc2NhbGUgfHwge307XHJcblx0dmFyIGZpbGwgPSBzb3VyY2UuZmlsbDtcclxuXHR2YXIgdGFyZ2V0ID0gbnVsbDtcclxuXHR2YXIgaG9yaXpvbnRhbDtcclxuXHJcblx0aWYgKGlzRmluaXRlKGZpbGwpKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IHVudGlsIHYzLCB3ZSBzdGlsbCBuZWVkIHRvIHN1cHBvcnQgYm91bmRhcnkgdmFsdWVzIHNldCBvblxyXG5cdC8vIHRoZSBtb2RlbCAoc2NhbGVUb3AsIHNjYWxlQm90dG9tIGFuZCBzY2FsZVplcm8pIGJlY2F1c2Ugc29tZSBleHRlcm5hbCBwbHVnaW5zIGFuZFxyXG5cdC8vIGNvbnRyb2xsZXJzIG1pZ2h0IHN0aWxsIHVzZSBpdCAoZS5nLiB0aGUgU21pdGggY2hhcnQpLlxyXG5cclxuXHRpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xyXG5cdFx0dGFyZ2V0ID0gbW9kZWwuc2NhbGVCb3R0b20gPT09IHVuZGVmaW5lZCA/IHNjYWxlLmJvdHRvbSA6IG1vZGVsLnNjYWxlQm90dG9tO1xyXG5cdH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcclxuXHRcdHRhcmdldCA9IG1vZGVsLnNjYWxlVG9wID09PSB1bmRlZmluZWQgPyBzY2FsZS50b3AgOiBtb2RlbC5zY2FsZVRvcDtcclxuXHR9IGVsc2UgaWYgKG1vZGVsLnNjYWxlWmVybyAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZVplcm87XHJcblx0fSBlbHNlIGlmIChzY2FsZS5nZXRCYXNlUGl4ZWwpIHtcclxuXHRcdHRhcmdldCA9IHNjYWxlLmdldEJhc2VQaXhlbCgpO1xyXG5cdH1cclxuXHJcblx0aWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkICYmIHRhcmdldCAhPT0gbnVsbCkge1xyXG5cdFx0aWYgKHRhcmdldC54ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0LnkgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChoZWxwZXJzJDEuaXNGaW5pdGUodGFyZ2V0KSkge1xyXG5cdFx0XHRob3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0eDogaG9yaXpvbnRhbCA/IHRhcmdldCA6IG51bGwsXHJcblx0XHRcdFx0eTogaG9yaXpvbnRhbCA/IG51bGwgOiB0YXJnZXRcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpIHtcclxuXHR2YXIgc2NhbGUgPSBzb3VyY2UuZWwuX3NjYWxlO1xyXG5cdHZhciBvcHRpb25zID0gc2NhbGUub3B0aW9ucztcclxuXHR2YXIgbGVuZ3RoID0gc2NhbGUuY2hhcnQuZGF0YS5sYWJlbHMubGVuZ3RoO1xyXG5cdHZhciBmaWxsID0gc291cmNlLmZpbGw7XHJcblx0dmFyIHRhcmdldCA9IFtdO1xyXG5cdHZhciBzdGFydCwgZW5kLCBjZW50ZXIsIGksIHBvaW50O1xyXG5cclxuXHRpZiAoIWxlbmd0aCkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cclxuXHRzdGFydCA9IG9wdGlvbnMudGlja3MucmV2ZXJzZSA/IHNjYWxlLm1heCA6IHNjYWxlLm1pbjtcclxuXHRlbmQgPSBvcHRpb25zLnRpY2tzLnJldmVyc2UgPyBzY2FsZS5taW4gOiBzY2FsZS5tYXg7XHJcblx0Y2VudGVyID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKDAsIHN0YXJ0KTtcclxuXHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuXHRcdHBvaW50ID0gZmlsbCA9PT0gJ3N0YXJ0JyB8fCBmaWxsID09PSAnZW5kJ1xyXG5cdFx0XHQ/IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCBmaWxsID09PSAnc3RhcnQnID8gc3RhcnQgOiBlbmQpXHJcblx0XHRcdDogc2NhbGUuZ2V0QmFzZVBvc2l0aW9uKGkpO1xyXG5cdFx0aWYgKG9wdGlvbnMuZ3JpZExpbmVzLmNpcmN1bGFyKSB7XHJcblx0XHRcdHBvaW50LmN4ID0gY2VudGVyLng7XHJcblx0XHRcdHBvaW50LmN5ID0gY2VudGVyLnk7XHJcblx0XHRcdHBvaW50LmFuZ2xlID0gc2NhbGUuZ2V0SW5kZXhBbmdsZShpKSAtIE1hdGguUEkgLyAyO1xyXG5cdFx0fVxyXG5cdFx0dGFyZ2V0LnB1c2gocG9pbnQpO1xyXG5cdH1cclxuXHRyZXR1cm4gdGFyZ2V0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wdXRlQm91bmRhcnkoc291cmNlKSB7XHJcblx0dmFyIHNjYWxlID0gc291cmNlLmVsLl9zY2FsZSB8fCB7fTtcclxuXHJcblx0aWYgKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSkge1xyXG5cdFx0cmV0dXJuIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSk7XHJcblx0fVxyXG5cdHJldHVybiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpbmRleCwgcHJvcGFnYXRlKSB7XHJcblx0dmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xyXG5cdHZhciBmaWxsID0gc291cmNlLmZpbGw7XHJcblx0dmFyIHZpc2l0ZWQgPSBbaW5kZXhdO1xyXG5cdHZhciB0YXJnZXQ7XHJcblxyXG5cdGlmICghcHJvcGFnYXRlKSB7XHJcblx0XHRyZXR1cm4gZmlsbDtcclxuXHR9XHJcblxyXG5cdHdoaWxlIChmaWxsICE9PSBmYWxzZSAmJiB2aXNpdGVkLmluZGV4T2YoZmlsbCkgPT09IC0xKSB7XHJcblx0XHRpZiAoIWlzRmluaXRlKGZpbGwpKSB7XHJcblx0XHRcdHJldHVybiBmaWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRhcmdldCA9IHNvdXJjZXNbZmlsbF07XHJcblx0XHRpZiAoIXRhcmdldCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRhcmdldC52aXNpYmxlKSB7XHJcblx0XHRcdHJldHVybiBmaWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZpc2l0ZWQucHVzaChmaWxsKTtcclxuXHRcdGZpbGwgPSB0YXJnZXQuZmlsbDtcclxuXHR9XHJcblxyXG5cdHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTWFwcGVyKHNvdXJjZSkge1xyXG5cdHZhciBmaWxsID0gc291cmNlLmZpbGw7XHJcblx0dmFyIHR5cGUgPSAnZGF0YXNldCc7XHJcblxyXG5cdGlmIChmaWxsID09PSBmYWxzZSkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cclxuXHRpZiAoIWlzRmluaXRlKGZpbGwpKSB7XHJcblx0XHR0eXBlID0gJ2JvdW5kYXJ5JztcclxuXHR9XHJcblxyXG5cdHJldHVybiBtYXBwZXJzW3R5cGVdKHNvdXJjZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRHJhd2FibGUocG9pbnQpIHtcclxuXHRyZXR1cm4gcG9pbnQgJiYgIXBvaW50LnNraXA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyYXdBcmVhKGN0eCwgY3VydmUwLCBjdXJ2ZTEsIGxlbjAsIGxlbjEpIHtcclxuXHR2YXIgaSwgY3gsIGN5LCByO1xyXG5cclxuXHRpZiAoIWxlbjAgfHwgIWxlbjEpIHtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblxyXG5cdC8vIGJ1aWxkaW5nIGZpcnN0IGFyZWEgY3VydmUgKG5vcm1hbClcclxuXHRjdHgubW92ZVRvKGN1cnZlMFswXS54LCBjdXJ2ZTBbMF0ueSk7XHJcblx0Zm9yIChpID0gMTsgaSA8IGxlbjA7ICsraSkge1xyXG5cdFx0aGVscGVycyQxLmNhbnZhcy5saW5lVG8oY3R4LCBjdXJ2ZTBbaSAtIDFdLCBjdXJ2ZTBbaV0pO1xyXG5cdH1cclxuXHJcblx0aWYgKGN1cnZlMVswXS5hbmdsZSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRjeCA9IGN1cnZlMVswXS5jeDtcclxuXHRcdGN5ID0gY3VydmUxWzBdLmN5O1xyXG5cdFx0ciA9IE1hdGguc3FydChNYXRoLnBvdyhjdXJ2ZTFbMF0ueCAtIGN4LCAyKSArIE1hdGgucG93KGN1cnZlMVswXS55IC0gY3ksIDIpKTtcclxuXHRcdGZvciAoaSA9IGxlbjEgLSAxOyBpID4gMDsgLS1pKSB7XHJcblx0XHRcdGN0eC5hcmMoY3gsIGN5LCByLCBjdXJ2ZTFbaV0uYW5nbGUsIGN1cnZlMVtpIC0gMV0uYW5nbGUsIHRydWUpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0Ly8gam9pbmluZyB0aGUgdHdvIGFyZWEgY3VydmVzXHJcblx0Y3R4LmxpbmVUbyhjdXJ2ZTFbbGVuMSAtIDFdLngsIGN1cnZlMVtsZW4xIC0gMV0ueSk7XHJcblxyXG5cdC8vIGJ1aWxkaW5nIG9wcG9zaXRlIGFyZWEgY3VydmUgKHJldmVyc2UpXHJcblx0Zm9yIChpID0gbGVuMSAtIDE7IGkgPiAwOyAtLWkpIHtcclxuXHRcdGhlbHBlcnMkMS5jYW52YXMubGluZVRvKGN0eCwgY3VydmUxW2ldLCBjdXJ2ZTFbaSAtIDFdLCB0cnVlKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRvRmlsbChjdHgsIHBvaW50cywgbWFwcGVyLCB2aWV3LCBjb2xvciwgbG9vcCkge1xyXG5cdHZhciBjb3VudCA9IHBvaW50cy5sZW5ndGg7XHJcblx0dmFyIHNwYW4gPSB2aWV3LnNwYW5HYXBzO1xyXG5cdHZhciBjdXJ2ZTAgPSBbXTtcclxuXHR2YXIgY3VydmUxID0gW107XHJcblx0dmFyIGxlbjAgPSAwO1xyXG5cdHZhciBsZW4xID0gMDtcclxuXHR2YXIgaSwgaWxlbiwgaW5kZXgsIHAwLCBwMSwgZDAsIGQxLCBsb29wT2Zmc2V0O1xyXG5cclxuXHRjdHguYmVnaW5QYXRoKCk7XHJcblxyXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0aW5kZXggPSBpICUgY291bnQ7XHJcblx0XHRwMCA9IHBvaW50c1tpbmRleF0uX3ZpZXc7XHJcblx0XHRwMSA9IG1hcHBlcihwMCwgaW5kZXgsIHZpZXcpO1xyXG5cdFx0ZDAgPSBpc0RyYXdhYmxlKHAwKTtcclxuXHRcdGQxID0gaXNEcmF3YWJsZShwMSk7XHJcblxyXG5cdFx0aWYgKGxvb3AgJiYgbG9vcE9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGQwKSB7XHJcblx0XHRcdGxvb3BPZmZzZXQgPSBpICsgMTtcclxuXHRcdFx0aWxlbiA9IGNvdW50ICsgbG9vcE9mZnNldDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZDAgJiYgZDEpIHtcclxuXHRcdFx0bGVuMCA9IGN1cnZlMC5wdXNoKHAwKTtcclxuXHRcdFx0bGVuMSA9IGN1cnZlMS5wdXNoKHAxKTtcclxuXHRcdH0gZWxzZSBpZiAobGVuMCAmJiBsZW4xKSB7XHJcblx0XHRcdGlmICghc3Bhbikge1xyXG5cdFx0XHRcdGRyYXdBcmVhKGN0eCwgY3VydmUwLCBjdXJ2ZTEsIGxlbjAsIGxlbjEpO1xyXG5cdFx0XHRcdGxlbjAgPSBsZW4xID0gMDtcclxuXHRcdFx0XHRjdXJ2ZTAgPSBbXTtcclxuXHRcdFx0XHRjdXJ2ZTEgPSBbXTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiAoZDApIHtcclxuXHRcdFx0XHRcdGN1cnZlMC5wdXNoKHAwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGQxKSB7XHJcblx0XHRcdFx0XHRjdXJ2ZTEucHVzaChwMSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRkcmF3QXJlYShjdHgsIGN1cnZlMCwgY3VydmUxLCBsZW4wLCBsZW4xKTtcclxuXHJcblx0Y3R4LmNsb3NlUGF0aCgpO1xyXG5cdGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcclxuXHRjdHguZmlsbCgpO1xyXG59XHJcblxyXG52YXIgcGx1Z2luX2ZpbGxlciA9IHtcclxuXHRpZDogJ2ZpbGxlcicsXHJcblxyXG5cdGFmdGVyRGF0YXNldHNVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0LCBvcHRpb25zKSB7XHJcblx0XHR2YXIgY291bnQgPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoO1xyXG5cdFx0dmFyIHByb3BhZ2F0ZSA9IG9wdGlvbnMucHJvcGFnYXRlO1xyXG5cdFx0dmFyIHNvdXJjZXMgPSBbXTtcclxuXHRcdHZhciBtZXRhLCBpLCBlbCwgc291cmNlO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XHJcblx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcclxuXHRcdFx0ZWwgPSBtZXRhLmRhdGFzZXQ7XHJcblx0XHRcdHNvdXJjZSA9IG51bGw7XHJcblxyXG5cdFx0XHRpZiAoZWwgJiYgZWwuX21vZGVsICYmIGVsIGluc3RhbmNlb2YgZWxlbWVudHMuTGluZSkge1xyXG5cdFx0XHRcdHNvdXJjZSA9IHtcclxuXHRcdFx0XHRcdHZpc2libGU6IGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSksXHJcblx0XHRcdFx0XHRmaWxsOiBkZWNvZGVGaWxsKGVsLCBpLCBjb3VudCksXHJcblx0XHRcdFx0XHRjaGFydDogY2hhcnQsXHJcblx0XHRcdFx0XHRlbDogZWxcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtZXRhLiRmaWxsZXIgPSBzb3VyY2U7XHJcblx0XHRcdHNvdXJjZXMucHVzaChzb3VyY2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XHJcblx0XHRcdHNvdXJjZSA9IHNvdXJjZXNbaV07XHJcblx0XHRcdGlmICghc291cmNlKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNvdXJjZS5maWxsID0gcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpLCBwcm9wYWdhdGUpO1xyXG5cdFx0XHRzb3VyY2UuYm91bmRhcnkgPSBjb21wdXRlQm91bmRhcnkoc291cmNlKTtcclxuXHRcdFx0c291cmNlLm1hcHBlciA9IGNyZWF0ZU1hcHBlcihzb3VyY2UpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGJlZm9yZURhdGFzZXRzRHJhdzogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdHZhciBtZXRhc2V0cyA9IGNoYXJ0Ll9nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XHJcblx0XHR2YXIgY3R4ID0gY2hhcnQuY3R4O1xyXG5cdFx0dmFyIG1ldGEsIGksIGVsLCB2aWV3LCBwb2ludHMsIG1hcHBlciwgY29sb3I7XHJcblxyXG5cdFx0Zm9yIChpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuXHRcdFx0bWV0YSA9IG1ldGFzZXRzW2ldLiRmaWxsZXI7XHJcblxyXG5cdFx0XHRpZiAoIW1ldGEgfHwgIW1ldGEudmlzaWJsZSkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRlbCA9IG1ldGEuZWw7XHJcblx0XHRcdHZpZXcgPSBlbC5fdmlldztcclxuXHRcdFx0cG9pbnRzID0gZWwuX2NoaWxkcmVuIHx8IFtdO1xyXG5cdFx0XHRtYXBwZXIgPSBtZXRhLm1hcHBlcjtcclxuXHRcdFx0Y29sb3IgPSB2aWV3LmJhY2tncm91bmRDb2xvciB8fCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XHJcblxyXG5cdFx0XHRpZiAobWFwcGVyICYmIGNvbG9yICYmIHBvaW50cy5sZW5ndGgpIHtcclxuXHRcdFx0XHRoZWxwZXJzJDEuY2FudmFzLmNsaXBBcmVhKGN0eCwgY2hhcnQuY2hhcnRBcmVhKTtcclxuXHRcdFx0XHRkb0ZpbGwoY3R4LCBwb2ludHMsIG1hcHBlciwgdmlldywgY29sb3IsIGVsLl9sb29wKTtcclxuXHRcdFx0XHRoZWxwZXJzJDEuY2FudmFzLnVuY2xpcEFyZWEoY3R4KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufTtcblxudmFyIGdldFJ0bEhlbHBlciQxID0gaGVscGVycyQxLnJ0bC5nZXRSdGxBZGFwdGVyO1xyXG52YXIgbm9vcCQxID0gaGVscGVycyQxLm5vb3A7XHJcbnZhciB2YWx1ZU9yRGVmYXVsdCRlID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xyXG5cclxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XHJcblx0bGVnZW5kOiB7XHJcblx0XHRkaXNwbGF5OiB0cnVlLFxyXG5cdFx0cG9zaXRpb246ICd0b3AnLFxyXG5cdFx0YWxpZ246ICdjZW50ZXInLFxyXG5cdFx0ZnVsbFdpZHRoOiB0cnVlLFxyXG5cdFx0cmV2ZXJzZTogZmFsc2UsXHJcblx0XHR3ZWlnaHQ6IDEwMDAsXHJcblxyXG5cdFx0Ly8gYSBjYWxsYmFjayB0aGF0IHdpbGwgaGFuZGxlXHJcblx0XHRvbkNsaWNrOiBmdW5jdGlvbihlLCBsZWdlbmRJdGVtKSB7XHJcblx0XHRcdHZhciBpbmRleCA9IGxlZ2VuZEl0ZW0uZGF0YXNldEluZGV4O1xyXG5cdFx0XHR2YXIgY2kgPSB0aGlzLmNoYXJ0O1xyXG5cdFx0XHR2YXIgbWV0YSA9IGNpLmdldERhdGFzZXRNZXRhKGluZGV4KTtcclxuXHJcblx0XHRcdC8vIFNlZSBjb250cm9sbGVyLmlzRGF0YXNldFZpc2libGUgY29tbWVudFxyXG5cdFx0XHRtZXRhLmhpZGRlbiA9IG1ldGEuaGlkZGVuID09PSBudWxsID8gIWNpLmRhdGEuZGF0YXNldHNbaW5kZXhdLmhpZGRlbiA6IG51bGw7XHJcblxyXG5cdFx0XHQvLyBXZSBoaWQgYSBkYXRhc2V0IC4uLiByZXJlbmRlciB0aGUgY2hhcnRcclxuXHRcdFx0Y2kudXBkYXRlKCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdG9uSG92ZXI6IG51bGwsXHJcblx0XHRvbkxlYXZlOiBudWxsLFxyXG5cclxuXHRcdGxhYmVsczoge1xyXG5cdFx0XHRib3hXaWR0aDogNDAsXHJcblx0XHRcdHBhZGRpbmc6IDEwLFxyXG5cdFx0XHQvLyBHZW5lcmF0ZXMgbGFiZWxzIHNob3duIGluIHRoZSBsZWdlbmRcclxuXHRcdFx0Ly8gVmFsaWQgcHJvcGVydGllcyB0byByZXR1cm46XHJcblx0XHRcdC8vIHRleHQgOiB0ZXh0IHRvIGRpc3BsYXlcclxuXHRcdFx0Ly8gZmlsbFN0eWxlIDogZmlsbCBvZiBjb2xvdXJlZCBib3hcclxuXHRcdFx0Ly8gc3Ryb2tlU3R5bGU6IHN0cm9rZSBvZiBjb2xvdXJlZCBib3hcclxuXHRcdFx0Ly8gaGlkZGVuIDogaWYgdGhpcyBsZWdlbmQgaXRlbSByZWZlcnMgdG8gYSBoaWRkZW4gaXRlbVxyXG5cdFx0XHQvLyBsaW5lQ2FwIDogY2FwIHN0eWxlIGZvciBsaW5lXHJcblx0XHRcdC8vIGxpbmVEYXNoXHJcblx0XHRcdC8vIGxpbmVEYXNoT2Zmc2V0IDpcclxuXHRcdFx0Ly8gbGluZUpvaW4gOlxyXG5cdFx0XHQvLyBsaW5lV2lkdGggOlxyXG5cdFx0XHRnZW5lcmF0ZUxhYmVsczogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdFx0XHR2YXIgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xyXG5cdFx0XHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5sZWdlbmQgfHwge307XHJcblx0XHRcdFx0dmFyIHVzZVBvaW50U3R5bGUgPSBvcHRpb25zLmxhYmVscyAmJiBvcHRpb25zLmxhYmVscy51c2VQb2ludFN0eWxlO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gY2hhcnQuX2dldFNvcnRlZERhdGFzZXRNZXRhcygpLm1hcChmdW5jdGlvbihtZXRhKSB7XHJcblx0XHRcdFx0XHR2YXIgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodXNlUG9pbnRTdHlsZSA/IDAgOiB1bmRlZmluZWQpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdHRleHQ6IGRhdGFzZXRzW21ldGEuaW5kZXhdLmxhYmVsLFxyXG5cdFx0XHRcdFx0XHRmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcclxuXHRcdFx0XHRcdFx0aGlkZGVuOiAhY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShtZXRhLmluZGV4KSxcclxuXHRcdFx0XHRcdFx0bGluZUNhcDogc3R5bGUuYm9yZGVyQ2FwU3R5bGUsXHJcblx0XHRcdFx0XHRcdGxpbmVEYXNoOiBzdHlsZS5ib3JkZXJEYXNoLFxyXG5cdFx0XHRcdFx0XHRsaW5lRGFzaE9mZnNldDogc3R5bGUuYm9yZGVyRGFzaE9mZnNldCxcclxuXHRcdFx0XHRcdFx0bGluZUpvaW46IHN0eWxlLmJvcmRlckpvaW5TdHlsZSxcclxuXHRcdFx0XHRcdFx0bGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcclxuXHRcdFx0XHRcdFx0c3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxyXG5cdFx0XHRcdFx0XHRwb2ludFN0eWxlOiBzdHlsZS5wb2ludFN0eWxlLFxyXG5cdFx0XHRcdFx0XHRyb3RhdGlvbjogc3R5bGUucm90YXRpb24sXHJcblxyXG5cdFx0XHRcdFx0XHQvLyBCZWxvdyBpcyBleHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBkYXRhc2V0c1xyXG5cdFx0XHRcdFx0XHRkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXhcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fSwgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRsZWdlbmRDYWxsYmFjazogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdHZhciBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcclxuXHRcdHZhciBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XHJcblx0XHR2YXIgaSwgaWxlbiwgbGlzdEl0ZW0sIGxpc3RJdGVtU3BhbjtcclxuXHJcblx0XHRsaXN0LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjaGFydC5pZCArICctbGVnZW5kJyk7XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xyXG5cdFx0XHRsaXN0SXRlbSA9IGxpc3QuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKSk7XHJcblx0XHRcdGxpc3RJdGVtU3BhbiA9IGxpc3RJdGVtLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKSk7XHJcblx0XHRcdGxpc3RJdGVtU3Bhbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBkYXRhc2V0c1tpXS5iYWNrZ3JvdW5kQ29sb3I7XHJcblx0XHRcdGlmIChkYXRhc2V0c1tpXS5sYWJlbCkge1xyXG5cdFx0XHRcdGxpc3RJdGVtLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGFzZXRzW2ldLmxhYmVsKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbGlzdC5vdXRlckhUTUw7XHJcblx0fVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBib3ggd2lkdGggYmFzZWQgb24gdGhlIHVzZVBvaW50U3R5bGUgb3B0aW9uXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBsYWJlbG9wdHMgLSB0aGUgbGFiZWwgb3B0aW9ucyBvbiB0aGUgbGVnZW5kXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmb250U2l6ZSAtIHRoZSBsYWJlbCBmb250IHNpemVcclxuICogQHJldHVybiB7bnVtYmVyfSB3aWR0aCBvZiB0aGUgY29sb3IgYm94IGFyZWFcclxuICovXHJcbmZ1bmN0aW9uIGdldEJveFdpZHRoKGxhYmVsT3B0cywgZm9udFNpemUpIHtcclxuXHRyZXR1cm4gbGFiZWxPcHRzLnVzZVBvaW50U3R5bGUgJiYgbGFiZWxPcHRzLmJveFdpZHRoID4gZm9udFNpemUgP1xyXG5cdFx0Zm9udFNpemUgOlxyXG5cdFx0bGFiZWxPcHRzLmJveFdpZHRoO1xyXG59XHJcblxyXG4vKipcclxuICogSU1QT1JUQU5UOiB0aGlzIGNsYXNzIGlzIGV4cG9zZWQgcHVibGljbHkgYXMgQ2hhcnQuTGVnZW5kLCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHJlcXVpcmVkIVxyXG4gKi9cclxudmFyIExlZ2VuZCA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbihjb25maWcpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHRoZWxwZXJzJDEuZXh0ZW5kKG1lLCBjb25maWcpO1xyXG5cclxuXHRcdC8vIENvbnRhaW5zIGhpdCBib3hlcyBmb3IgZWFjaCBkYXRhc2V0IChpbiBkYXRhc2V0IG9yZGVyKVxyXG5cdFx0bWUubGVnZW5kSGl0Qm94ZXMgPSBbXTtcclxuXHJcblx0XHQvKipcclxuIFx0XHQgKiBAcHJpdmF0ZVxyXG4gXHRcdCAqL1xyXG5cdFx0bWUuX2hvdmVyZWRJdGVtID0gbnVsbDtcclxuXHJcblx0XHQvLyBBcmUgd2UgaW4gZG91Z2hudXQgbW9kZSB3aGljaCBoYXMgYSBkaWZmZXJlbnQgZGF0YSB0eXBlXHJcblx0XHRtZS5kb3VnaG51dE1vZGUgPSBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHQvLyBUaGVzZSBtZXRob2RzIGFyZSBvcmRlcmVkIGJ5IGxpZmVjeWNsZS4gVXRpbGl0aWVzIHRoZW4gZm9sbG93LlxyXG5cdC8vIEFueSBmdW5jdGlvbiBkZWZpbmVkIGhlcmUgaXMgaW5oZXJpdGVkIGJ5IGFsbCBsZWdlbmQgdHlwZXMuXHJcblx0Ly8gQW55IGZ1bmN0aW9uIGNhbiBiZSBleHRlbmRlZCBieSB0aGUgbGVnZW5kIHR5cGVcclxuXHJcblx0YmVmb3JlVXBkYXRlOiBub29wJDEsXHJcblx0dXBkYXRlOiBmdW5jdGlvbihtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cclxuXHRcdC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXHJcblx0XHRtZS5iZWZvcmVVcGRhdGUoKTtcclxuXHJcblx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcclxuXHRcdG1lLm1heFdpZHRoID0gbWF4V2lkdGg7XHJcblx0XHRtZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XHJcblx0XHRtZS5tYXJnaW5zID0gbWFyZ2lucztcclxuXHJcblx0XHQvLyBEaW1lbnNpb25zXHJcblx0XHRtZS5iZWZvcmVTZXREaW1lbnNpb25zKCk7XHJcblx0XHRtZS5zZXREaW1lbnNpb25zKCk7XHJcblx0XHRtZS5hZnRlclNldERpbWVuc2lvbnMoKTtcclxuXHRcdC8vIExhYmVsc1xyXG5cdFx0bWUuYmVmb3JlQnVpbGRMYWJlbHMoKTtcclxuXHRcdG1lLmJ1aWxkTGFiZWxzKCk7XHJcblx0XHRtZS5hZnRlckJ1aWxkTGFiZWxzKCk7XHJcblxyXG5cdFx0Ly8gRml0XHJcblx0XHRtZS5iZWZvcmVGaXQoKTtcclxuXHRcdG1lLmZpdCgpO1xyXG5cdFx0bWUuYWZ0ZXJGaXQoKTtcclxuXHRcdC8vXHJcblx0XHRtZS5hZnRlclVwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiBtZS5taW5TaXplO1xyXG5cdH0sXHJcblx0YWZ0ZXJVcGRhdGU6IG5vb3AkMSxcclxuXHJcblx0Ly9cclxuXHJcblx0YmVmb3JlU2V0RGltZW5zaW9uczogbm9vcCQxLFxyXG5cdHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXHJcblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcclxuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXHJcblx0XHRcdG1lLndpZHRoID0gbWUubWF4V2lkdGg7XHJcblx0XHRcdG1lLmxlZnQgPSAwO1xyXG5cdFx0XHRtZS5yaWdodCA9IG1lLndpZHRoO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xyXG5cclxuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXHJcblx0XHRcdG1lLnRvcCA9IDA7XHJcblx0XHRcdG1lLmJvdHRvbSA9IG1lLmhlaWdodDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBSZXNldCBwYWRkaW5nXHJcblx0XHRtZS5wYWRkaW5nTGVmdCA9IDA7XHJcblx0XHRtZS5wYWRkaW5nVG9wID0gMDtcclxuXHRcdG1lLnBhZGRpbmdSaWdodCA9IDA7XHJcblx0XHRtZS5wYWRkaW5nQm90dG9tID0gMDtcclxuXHJcblx0XHQvLyBSZXNldCBtaW5TaXplXHJcblx0XHRtZS5taW5TaXplID0ge1xyXG5cdFx0XHR3aWR0aDogMCxcclxuXHRcdFx0aGVpZ2h0OiAwXHJcblx0XHR9O1xyXG5cdH0sXHJcblx0YWZ0ZXJTZXREaW1lbnNpb25zOiBub29wJDEsXHJcblxyXG5cdC8vXHJcblxyXG5cdGJlZm9yZUJ1aWxkTGFiZWxzOiBub29wJDEsXHJcblx0YnVpbGRMYWJlbHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBsYWJlbE9wdHMgPSBtZS5vcHRpb25zLmxhYmVscyB8fCB7fTtcclxuXHRcdHZhciBsZWdlbmRJdGVtcyA9IGhlbHBlcnMkMS5jYWxsYmFjayhsYWJlbE9wdHMuZ2VuZXJhdGVMYWJlbHMsIFttZS5jaGFydF0sIG1lKSB8fCBbXTtcclxuXHJcblx0XHRpZiAobGFiZWxPcHRzLmZpbHRlcikge1xyXG5cdFx0XHRsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRcdFx0cmV0dXJuIGxhYmVsT3B0cy5maWx0ZXIoaXRlbSwgbWUuY2hhcnQuZGF0YSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtZS5vcHRpb25zLnJldmVyc2UpIHtcclxuXHRcdFx0bGVnZW5kSXRlbXMucmV2ZXJzZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1lLmxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXM7XHJcblx0fSxcclxuXHRhZnRlckJ1aWxkTGFiZWxzOiBub29wJDEsXHJcblxyXG5cdC8vXHJcblxyXG5cdGJlZm9yZUZpdDogbm9vcCQxLFxyXG5cdGZpdDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIGxhYmVsT3B0cyA9IG9wdHMubGFiZWxzO1xyXG5cdFx0dmFyIGRpc3BsYXkgPSBvcHRzLmRpc3BsYXk7XHJcblxyXG5cdFx0dmFyIGN0eCA9IG1lLmN0eDtcclxuXHJcblx0XHR2YXIgbGFiZWxGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChsYWJlbE9wdHMpO1xyXG5cdFx0dmFyIGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XHJcblxyXG5cdFx0Ly8gUmVzZXQgaGl0IGJveGVzXHJcblx0XHR2YXIgaGl0Ym94ZXMgPSBtZS5sZWdlbmRIaXRCb3hlcyA9IFtdO1xyXG5cclxuXHRcdHZhciBtaW5TaXplID0gbWUubWluU2l6ZTtcclxuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcclxuXHJcblx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XHJcblx0XHRcdG1pblNpemUud2lkdGggPSBtZS5tYXhXaWR0aDsgLy8gZmlsbCBhbGwgdGhlIHdpZHRoXHJcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gZGlzcGxheSA/IDEwIDogMDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1pblNpemUud2lkdGggPSBkaXNwbGF5ID8gMTAgOiAwO1xyXG5cdFx0XHRtaW5TaXplLmhlaWdodCA9IG1lLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEluY3JlYXNlIHNpemVzIGhlcmVcclxuXHRcdGlmICghZGlzcGxheSkge1xyXG5cdFx0XHRtZS53aWR0aCA9IG1pblNpemUud2lkdGggPSBtZS5oZWlnaHQgPSBtaW5TaXplLmhlaWdodCA9IDA7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcclxuXHJcblx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XHJcblx0XHRcdC8vIExhYmVsc1xyXG5cclxuXHRcdFx0Ly8gV2lkdGggb2YgZWFjaCBsaW5lIG9mIGxlZ2VuZCBib3hlcy4gTGFiZWxzIHdyYXAgb250byBtdWx0aXBsZSBsaW5lcyB3aGVuIHRoZXJlIGFyZSB0b28gbWFueSB0byBmaXQgb24gb25lXHJcblx0XHRcdHZhciBsaW5lV2lkdGhzID0gbWUubGluZVdpZHRocyA9IFswXTtcclxuXHRcdFx0dmFyIHRvdGFsSGVpZ2h0ID0gMDtcclxuXHJcblx0XHRcdGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XHJcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcclxuXHJcblx0XHRcdGhlbHBlcnMkMS5lYWNoKG1lLmxlZ2VuZEl0ZW1zLCBmdW5jdGlvbihsZWdlbmRJdGVtLCBpKSB7XHJcblx0XHRcdFx0dmFyIGJveFdpZHRoID0gZ2V0Qm94V2lkdGgobGFiZWxPcHRzLCBmb250U2l6ZSk7XHJcblx0XHRcdFx0dmFyIHdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xyXG5cclxuXHRcdFx0XHRpZiAoaSA9PT0gMCB8fCBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKyB3aWR0aCArIDIgKiBsYWJlbE9wdHMucGFkZGluZyA+IG1pblNpemUud2lkdGgpIHtcclxuXHRcdFx0XHRcdHRvdGFsSGVpZ2h0ICs9IGZvbnRTaXplICsgbGFiZWxPcHRzLnBhZGRpbmc7XHJcblx0XHRcdFx0XHRsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gKGkgPiAwID8gMCA6IDEpXSA9IDA7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBTdG9yZSB0aGUgaGl0Ym94IHdpZHRoIGFuZCBoZWlnaHQgaGVyZS4gRmluYWwgcG9zaXRpb24gd2lsbCBiZSB1cGRhdGVkIGluIGBkcmF3YFxyXG5cdFx0XHRcdGhpdGJveGVzW2ldID0ge1xyXG5cdFx0XHRcdFx0bGVmdDogMCxcclxuXHRcdFx0XHRcdHRvcDogMCxcclxuXHRcdFx0XHRcdHdpZHRoOiB3aWR0aCxcclxuXHRcdFx0XHRcdGhlaWdodDogZm9udFNpemVcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKz0gd2lkdGggKyBsYWJlbE9wdHMucGFkZGluZztcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRtaW5TaXplLmhlaWdodCArPSB0b3RhbEhlaWdodDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgdlBhZGRpbmcgPSBsYWJlbE9wdHMucGFkZGluZztcclxuXHRcdFx0dmFyIGNvbHVtbldpZHRocyA9IG1lLmNvbHVtbldpZHRocyA9IFtdO1xyXG5cdFx0XHR2YXIgY29sdW1uSGVpZ2h0cyA9IG1lLmNvbHVtbkhlaWdodHMgPSBbXTtcclxuXHRcdFx0dmFyIHRvdGFsV2lkdGggPSBsYWJlbE9wdHMucGFkZGluZztcclxuXHRcdFx0dmFyIGN1cnJlbnRDb2xXaWR0aCA9IDA7XHJcblx0XHRcdHZhciBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcclxuXHJcblx0XHRcdGhlbHBlcnMkMS5lYWNoKG1lLmxlZ2VuZEl0ZW1zLCBmdW5jdGlvbihsZWdlbmRJdGVtLCBpKSB7XHJcblx0XHRcdFx0dmFyIGJveFdpZHRoID0gZ2V0Qm94V2lkdGgobGFiZWxPcHRzLCBmb250U2l6ZSk7XHJcblx0XHRcdFx0dmFyIGl0ZW1XaWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcclxuXHJcblx0XHRcdFx0Ly8gSWYgdG9vIHRhbGwsIGdvIHRvIG5ldyBjb2x1bW5cclxuXHRcdFx0XHRpZiAoaSA+IDAgJiYgY3VycmVudENvbEhlaWdodCArIGZvbnRTaXplICsgMiAqIHZQYWRkaW5nID4gbWluU2l6ZS5oZWlnaHQpIHtcclxuXHRcdFx0XHRcdHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoICsgbGFiZWxPcHRzLnBhZGRpbmc7XHJcblx0XHRcdFx0XHRjb2x1bW5XaWR0aHMucHVzaChjdXJyZW50Q29sV2lkdGgpOyAvLyBwcmV2aW91cyBjb2x1bW4gd2lkdGhcclxuXHRcdFx0XHRcdGNvbHVtbkhlaWdodHMucHVzaChjdXJyZW50Q29sSGVpZ2h0KTtcclxuXHRcdFx0XHRcdGN1cnJlbnRDb2xXaWR0aCA9IDA7XHJcblx0XHRcdFx0XHRjdXJyZW50Q29sSGVpZ2h0ID0gMDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIEdldCBtYXggd2lkdGhcclxuXHRcdFx0XHRjdXJyZW50Q29sV2lkdGggPSBNYXRoLm1heChjdXJyZW50Q29sV2lkdGgsIGl0ZW1XaWR0aCk7XHJcblx0XHRcdFx0Y3VycmVudENvbEhlaWdodCArPSBmb250U2l6ZSArIHZQYWRkaW5nO1xyXG5cclxuXHRcdFx0XHQvLyBTdG9yZSB0aGUgaGl0Ym94IHdpZHRoIGFuZCBoZWlnaHQgaGVyZS4gRmluYWwgcG9zaXRpb24gd2lsbCBiZSB1cGRhdGVkIGluIGBkcmF3YFxyXG5cdFx0XHRcdGhpdGJveGVzW2ldID0ge1xyXG5cdFx0XHRcdFx0bGVmdDogMCxcclxuXHRcdFx0XHRcdHRvcDogMCxcclxuXHRcdFx0XHRcdHdpZHRoOiBpdGVtV2lkdGgsXHJcblx0XHRcdFx0XHRoZWlnaHQ6IGZvbnRTaXplXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHR0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aDtcclxuXHRcdFx0Y29sdW1uV2lkdGhzLnB1c2goY3VycmVudENvbFdpZHRoKTtcclxuXHRcdFx0Y29sdW1uSGVpZ2h0cy5wdXNoKGN1cnJlbnRDb2xIZWlnaHQpO1xyXG5cdFx0XHRtaW5TaXplLndpZHRoICs9IHRvdGFsV2lkdGg7XHJcblx0XHR9XHJcblxyXG5cdFx0bWUud2lkdGggPSBtaW5TaXplLndpZHRoO1xyXG5cdFx0bWUuaGVpZ2h0ID0gbWluU2l6ZS5oZWlnaHQ7XHJcblx0fSxcclxuXHRhZnRlckZpdDogbm9vcCQxLFxyXG5cclxuXHQvLyBTaGFyZWQgTWV0aG9kc1xyXG5cdGlzSG9yaXpvbnRhbDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAndG9wJyB8fCB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEFjdHVhbGx5IGRyYXcgdGhlIGxlZ2VuZCBvbiB0aGUgY2FudmFzXHJcblx0ZHJhdzogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIGxhYmVsT3B0cyA9IG9wdHMubGFiZWxzO1xyXG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XHJcblx0XHR2YXIgZGVmYXVsdENvbG9yID0gZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdENvbG9yO1xyXG5cdFx0dmFyIGxpbmVEZWZhdWx0ID0gZ2xvYmFsRGVmYXVsdHMuZWxlbWVudHMubGluZTtcclxuXHRcdHZhciBsZWdlbmRIZWlnaHQgPSBtZS5oZWlnaHQ7XHJcblx0XHR2YXIgY29sdW1uSGVpZ2h0cyA9IG1lLmNvbHVtbkhlaWdodHM7XHJcblx0XHR2YXIgbGVnZW5kV2lkdGggPSBtZS53aWR0aDtcclxuXHRcdHZhciBsaW5lV2lkdGhzID0gbWUubGluZVdpZHRocztcclxuXHJcblx0XHRpZiAoIW9wdHMuZGlzcGxheSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHJ0bEhlbHBlciA9IGdldFJ0bEhlbHBlciQxKG9wdHMucnRsLCBtZS5sZWZ0LCBtZS5taW5TaXplLndpZHRoKTtcclxuXHRcdHZhciBjdHggPSBtZS5jdHg7XHJcblx0XHR2YXIgZm9udENvbG9yID0gdmFsdWVPckRlZmF1bHQkZShsYWJlbE9wdHMuZm9udENvbG9yLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udENvbG9yKTtcclxuXHRcdHZhciBsYWJlbEZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KGxhYmVsT3B0cyk7XHJcblx0XHR2YXIgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcclxuXHRcdHZhciBjdXJzb3I7XHJcblxyXG5cdFx0Ly8gQ2FudmFzIHNldHVwXHJcblx0XHRjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbignbGVmdCcpO1xyXG5cdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG5cdFx0Y3R4LmxpbmVXaWR0aCA9IDAuNTtcclxuXHRcdGN0eC5zdHJva2VTdHlsZSA9IGZvbnRDb2xvcjsgLy8gZm9yIHN0cmlrZXRocm91Z2ggZWZmZWN0XHJcblx0XHRjdHguZmlsbFN0eWxlID0gZm9udENvbG9yOyAvLyByZW5kZXIgaW4gY29ycmVjdCBjb2xvdXJcclxuXHRcdGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcclxuXHJcblx0XHR2YXIgYm94V2lkdGggPSBnZXRCb3hXaWR0aChsYWJlbE9wdHMsIGZvbnRTaXplKTtcclxuXHRcdHZhciBoaXRib3hlcyA9IG1lLmxlZ2VuZEhpdEJveGVzO1xyXG5cclxuXHRcdC8vIGN1cnJlbnQgcG9zaXRpb25cclxuXHRcdHZhciBkcmF3TGVnZW5kQm94ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xyXG5cdFx0XHRpZiAoaXNOYU4oYm94V2lkdGgpIHx8IGJveFdpZHRoIDw9IDApIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFNldCB0aGUgY3R4IGZvciB0aGUgYm94XHJcblx0XHRcdGN0eC5zYXZlKCk7XHJcblxyXG5cdFx0XHR2YXIgbGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQkZShsZWdlbmRJdGVtLmxpbmVXaWR0aCwgbGluZURlZmF1bHQuYm9yZGVyV2lkdGgpO1xyXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gdmFsdWVPckRlZmF1bHQkZShsZWdlbmRJdGVtLmZpbGxTdHlsZSwgZGVmYXVsdENvbG9yKTtcclxuXHRcdFx0Y3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdCRlKGxlZ2VuZEl0ZW0ubGluZUNhcCwgbGluZURlZmF1bHQuYm9yZGVyQ2FwU3R5bGUpO1xyXG5cdFx0XHRjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdCRlKGxlZ2VuZEl0ZW0ubGluZURhc2hPZmZzZXQsIGxpbmVEZWZhdWx0LmJvcmRlckRhc2hPZmZzZXQpO1xyXG5cdFx0XHRjdHgubGluZUpvaW4gPSB2YWx1ZU9yRGVmYXVsdCRlKGxlZ2VuZEl0ZW0ubGluZUpvaW4sIGxpbmVEZWZhdWx0LmJvcmRlckpvaW5TdHlsZSk7XHJcblx0XHRcdGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XHJcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0JGUobGVnZW5kSXRlbS5zdHJva2VTdHlsZSwgZGVmYXVsdENvbG9yKTtcclxuXHJcblx0XHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcclxuXHRcdFx0XHQvLyBJRSA5IGFuZCAxMCBkbyBub3Qgc3VwcG9ydCBsaW5lIGRhc2hcclxuXHRcdFx0XHRjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQkZShsZWdlbmRJdGVtLmxpbmVEYXNoLCBsaW5lRGVmYXVsdC5ib3JkZXJEYXNoKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChsYWJlbE9wdHMgJiYgbGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcclxuXHRcdFx0XHQvLyBSZWNhbGN1bGF0ZSB4IGFuZCB5IGZvciBkcmF3UG9pbnQoKSBiZWNhdXNlIGl0cyBleHBlY3RpbmdcclxuXHRcdFx0XHQvLyB4IGFuZCB5IHRvIGJlIGNlbnRlciBvZiBmaWd1cmUgKGluc3RlYWQgb2YgdG9wIGxlZnQpXHJcblx0XHRcdFx0dmFyIHJhZGl1cyA9IGJveFdpZHRoICogTWF0aC5TUVJUMiAvIDI7XHJcblx0XHRcdFx0dmFyIGNlbnRlclggPSBydGxIZWxwZXIueFBsdXMoeCwgYm94V2lkdGggLyAyKTtcclxuXHRcdFx0XHR2YXIgY2VudGVyWSA9IHkgKyBmb250U2l6ZSAvIDI7XHJcblxyXG5cdFx0XHRcdC8vIERyYXcgcG9pbnRTdHlsZSBhcyBsZWdlbmQgc3ltYm9sXHJcblx0XHRcdFx0aGVscGVycyQxLmNhbnZhcy5kcmF3UG9pbnQoY3R4LCBsZWdlbmRJdGVtLnBvaW50U3R5bGUsIHJhZGl1cywgY2VudGVyWCwgY2VudGVyWSwgbGVnZW5kSXRlbS5yb3RhdGlvbik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gRHJhdyBib3ggYXMgbGVnZW5kIHN5bWJvbFxyXG5cdFx0XHRcdGN0eC5maWxsUmVjdChydGxIZWxwZXIubGVmdEZvckx0cih4LCBib3hXaWR0aCksIHksIGJveFdpZHRoLCBmb250U2l6ZSk7XHJcblx0XHRcdFx0aWYgKGxpbmVXaWR0aCAhPT0gMCkge1xyXG5cdFx0XHRcdFx0Y3R4LnN0cm9rZVJlY3QocnRsSGVscGVyLmxlZnRGb3JMdHIoeCwgYm94V2lkdGgpLCB5LCBib3hXaWR0aCwgZm9udFNpemUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIGZpbGxUZXh0ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSwgdGV4dFdpZHRoKSB7XHJcblx0XHRcdHZhciBoYWxmRm9udFNpemUgPSBmb250U2l6ZSAvIDI7XHJcblx0XHRcdHZhciB4TGVmdCA9IHJ0bEhlbHBlci54UGx1cyh4LCBib3hXaWR0aCArIGhhbGZGb250U2l6ZSk7XHJcblx0XHRcdHZhciB5TWlkZGxlID0geSArIGhhbGZGb250U2l6ZTtcclxuXHJcblx0XHRcdGN0eC5maWxsVGV4dChsZWdlbmRJdGVtLnRleHQsIHhMZWZ0LCB5TWlkZGxlKTtcclxuXHJcblx0XHRcdGlmIChsZWdlbmRJdGVtLmhpZGRlbikge1xyXG5cdFx0XHRcdC8vIFN0cmlrZXRocm91Z2ggdGhlIHRleHQgaWYgaGlkZGVuXHJcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRcdGN0eC5saW5lV2lkdGggPSAyO1xyXG5cdFx0XHRcdGN0eC5tb3ZlVG8oeExlZnQsIHlNaWRkbGUpO1xyXG5cdFx0XHRcdGN0eC5saW5lVG8ocnRsSGVscGVyLnhQbHVzKHhMZWZ0LCB0ZXh0V2lkdGgpLCB5TWlkZGxlKTtcclxuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIGFsaWdubWVudE9mZnNldCA9IGZ1bmN0aW9uKGRpbWVuc2lvbiwgYmxvY2tTaXplKSB7XHJcblx0XHRcdHN3aXRjaCAob3B0cy5hbGlnbikge1xyXG5cdFx0XHRjYXNlICdzdGFydCc6XHJcblx0XHRcdFx0cmV0dXJuIGxhYmVsT3B0cy5wYWRkaW5nO1xyXG5cdFx0XHRjYXNlICdlbmQnOlxyXG5cdFx0XHRcdHJldHVybiBkaW1lbnNpb24gLSBibG9ja1NpemU7XHJcblx0XHRcdGRlZmF1bHQ6IC8vIGNlbnRlclxyXG5cdFx0XHRcdHJldHVybiAoZGltZW5zaW9uIC0gYmxvY2tTaXplICsgbGFiZWxPcHRzLnBhZGRpbmcpIC8gMjtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBIb3Jpem9udGFsXHJcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XHJcblx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XHJcblx0XHRcdGN1cnNvciA9IHtcclxuXHRcdFx0XHR4OiBtZS5sZWZ0ICsgYWxpZ25tZW50T2Zmc2V0KGxlZ2VuZFdpZHRoLCBsaW5lV2lkdGhzWzBdKSxcclxuXHRcdFx0XHR5OiBtZS50b3AgKyBsYWJlbE9wdHMucGFkZGluZyxcclxuXHRcdFx0XHRsaW5lOiAwXHJcblx0XHRcdH07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjdXJzb3IgPSB7XHJcblx0XHRcdFx0eDogbWUubGVmdCArIGxhYmVsT3B0cy5wYWRkaW5nLFxyXG5cdFx0XHRcdHk6IG1lLnRvcCArIGFsaWdubWVudE9mZnNldChsZWdlbmRIZWlnaHQsIGNvbHVtbkhlaWdodHNbMF0pLFxyXG5cdFx0XHRcdGxpbmU6IDBcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHRoZWxwZXJzJDEucnRsLm92ZXJyaWRlVGV4dERpcmVjdGlvbihtZS5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XHJcblxyXG5cdFx0dmFyIGl0ZW1IZWlnaHQgPSBmb250U2l6ZSArIGxhYmVsT3B0cy5wYWRkaW5nO1xyXG5cdFx0aGVscGVycyQxLmVhY2gobWUubGVnZW5kSXRlbXMsIGZ1bmN0aW9uKGxlZ2VuZEl0ZW0sIGkpIHtcclxuXHRcdFx0dmFyIHRleHRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xyXG5cdFx0XHR2YXIgd2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgdGV4dFdpZHRoO1xyXG5cdFx0XHR2YXIgeCA9IGN1cnNvci54O1xyXG5cdFx0XHR2YXIgeSA9IGN1cnNvci55O1xyXG5cclxuXHRcdFx0cnRsSGVscGVyLnNldFdpZHRoKG1lLm1pblNpemUud2lkdGgpO1xyXG5cclxuXHRcdFx0Ly8gVXNlIChtZS5sZWZ0ICsgbWUubWluU2l6ZS53aWR0aCkgYW5kIChtZS50b3AgKyBtZS5taW5TaXplLmhlaWdodClcclxuXHRcdFx0Ly8gaW5zdGVhZCBvZiBtZS5yaWdodCBhbmQgbWUuYm90dG9tIGJlY2F1c2UgbWUud2lkdGggYW5kIG1lLmhlaWdodFxyXG5cdFx0XHQvLyBtYXkgaGF2ZSBiZWVuIGNoYW5nZWQgc2luY2UgbWUubWluU2l6ZSB3YXMgY2FsY3VsYXRlZFxyXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XHJcblx0XHRcdFx0aWYgKGkgPiAwICYmIHggKyB3aWR0aCArIGxhYmVsT3B0cy5wYWRkaW5nID4gbWUubGVmdCArIG1lLm1pblNpemUud2lkdGgpIHtcclxuXHRcdFx0XHRcdHkgPSBjdXJzb3IueSArPSBpdGVtSGVpZ2h0O1xyXG5cdFx0XHRcdFx0Y3Vyc29yLmxpbmUrKztcclxuXHRcdFx0XHRcdHggPSBjdXJzb3IueCA9IG1lLmxlZnQgKyBhbGlnbm1lbnRPZmZzZXQobGVnZW5kV2lkdGgsIGxpbmVXaWR0aHNbY3Vyc29yLmxpbmVdKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAoaSA+IDAgJiYgeSArIGl0ZW1IZWlnaHQgPiBtZS50b3AgKyBtZS5taW5TaXplLmhlaWdodCkge1xyXG5cdFx0XHRcdHggPSBjdXJzb3IueCA9IHggKyBtZS5jb2x1bW5XaWR0aHNbY3Vyc29yLmxpbmVdICsgbGFiZWxPcHRzLnBhZGRpbmc7XHJcblx0XHRcdFx0Y3Vyc29yLmxpbmUrKztcclxuXHRcdFx0XHR5ID0gY3Vyc29yLnkgPSBtZS50b3AgKyBhbGlnbm1lbnRPZmZzZXQobGVnZW5kSGVpZ2h0LCBjb2x1bW5IZWlnaHRzW2N1cnNvci5saW5lXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciByZWFsWCA9IHJ0bEhlbHBlci54KHgpO1xyXG5cclxuXHRcdFx0ZHJhd0xlZ2VuZEJveChyZWFsWCwgeSwgbGVnZW5kSXRlbSk7XHJcblxyXG5cdFx0XHRoaXRib3hlc1tpXS5sZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocmVhbFgsIGhpdGJveGVzW2ldLndpZHRoKTtcclxuXHRcdFx0aGl0Ym94ZXNbaV0udG9wID0geTtcclxuXHJcblx0XHRcdC8vIEZpbGwgdGhlIGFjdHVhbCBsYWJlbFxyXG5cdFx0XHRmaWxsVGV4dChyZWFsWCwgeSwgbGVnZW5kSXRlbSwgdGV4dFdpZHRoKTtcclxuXHJcblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcclxuXHRcdFx0XHRjdXJzb3IueCArPSB3aWR0aCArIGxhYmVsT3B0cy5wYWRkaW5nO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGN1cnNvci55ICs9IGl0ZW1IZWlnaHQ7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdGhlbHBlcnMkMS5ydGwucmVzdG9yZVRleHREaXJlY3Rpb24obWUuY3R4LCBvcHRzLnRleHREaXJlY3Rpb24pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldExlZ2VuZEl0ZW1BdDogZnVuY3Rpb24oeCwgeSkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBpLCBoaXRCb3gsIGxoO1xyXG5cclxuXHRcdGlmICh4ID49IG1lLmxlZnQgJiYgeCA8PSBtZS5yaWdodCAmJiB5ID49IG1lLnRvcCAmJiB5IDw9IG1lLmJvdHRvbSkge1xyXG5cdFx0XHQvLyBTZWUgaWYgd2UgYXJlIHRvdWNoaW5nIG9uZSBvZiB0aGUgZGF0YXNldCBib3hlc1xyXG5cdFx0XHRsaCA9IG1lLmxlZ2VuZEhpdEJveGVzO1xyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGgubGVuZ3RoOyArK2kpIHtcclxuXHRcdFx0XHRoaXRCb3ggPSBsaFtpXTtcclxuXHJcblx0XHRcdFx0aWYgKHggPj0gaGl0Qm94LmxlZnQgJiYgeCA8PSBoaXRCb3gubGVmdCArIGhpdEJveC53aWR0aCAmJiB5ID49IGhpdEJveC50b3AgJiYgeSA8PSBoaXRCb3gudG9wICsgaGl0Qm94LmhlaWdodCkge1xyXG5cdFx0XHRcdFx0Ly8gVG91Y2hpbmcgYW4gZWxlbWVudFxyXG5cdFx0XHRcdFx0cmV0dXJuIG1lLmxlZ2VuZEl0ZW1zW2ldO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEhhbmRsZSBhbiBldmVudFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtJRXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxyXG5cdCAqL1xyXG5cdGhhbmRsZUV2ZW50OiBmdW5jdGlvbihlKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIHR5cGUgPSBlLnR5cGUgPT09ICdtb3VzZXVwJyA/ICdjbGljaycgOiBlLnR5cGU7XHJcblx0XHR2YXIgaG92ZXJlZEl0ZW07XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdtb3VzZW1vdmUnKSB7XHJcblx0XHRcdGlmICghb3B0cy5vbkhvdmVyICYmICFvcHRzLm9uTGVhdmUpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xyXG5cdFx0XHRpZiAoIW9wdHMub25DbGljaykge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENoYXJ0IGV2ZW50IGFscmVhZHkgaGFzIHJlbGF0aXZlIHBvc2l0aW9uIGluIGl0XHJcblx0XHRob3ZlcmVkSXRlbSA9IG1lLl9nZXRMZWdlbmRJdGVtQXQoZS54LCBlLnkpO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnY2xpY2snKSB7XHJcblx0XHRcdGlmIChob3ZlcmVkSXRlbSAmJiBvcHRzLm9uQ2xpY2spIHtcclxuXHRcdFx0XHQvLyB1c2UgZS5uYXRpdmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblx0XHRcdFx0b3B0cy5vbkNsaWNrLmNhbGwobWUsIGUubmF0aXZlLCBob3ZlcmVkSXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChvcHRzLm9uTGVhdmUgJiYgaG92ZXJlZEl0ZW0gIT09IG1lLl9ob3ZlcmVkSXRlbSkge1xyXG5cdFx0XHRcdGlmIChtZS5faG92ZXJlZEl0ZW0pIHtcclxuXHRcdFx0XHRcdG9wdHMub25MZWF2ZS5jYWxsKG1lLCBlLm5hdGl2ZSwgbWUuX2hvdmVyZWRJdGVtKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bWUuX2hvdmVyZWRJdGVtID0gaG92ZXJlZEl0ZW07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChvcHRzLm9uSG92ZXIgJiYgaG92ZXJlZEl0ZW0pIHtcclxuXHRcdFx0XHQvLyB1c2UgZS5uYXRpdmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblx0XHRcdFx0b3B0cy5vbkhvdmVyLmNhbGwobWUsIGUubmF0aXZlLCBob3ZlcmVkSXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlTmV3TGVnZW5kQW5kQXR0YWNoKGNoYXJ0LCBsZWdlbmRPcHRzKSB7XHJcblx0dmFyIGxlZ2VuZCA9IG5ldyBMZWdlbmQoe1xyXG5cdFx0Y3R4OiBjaGFydC5jdHgsXHJcblx0XHRvcHRpb25zOiBsZWdlbmRPcHRzLFxyXG5cdFx0Y2hhcnQ6IGNoYXJ0XHJcblx0fSk7XHJcblxyXG5cdGNvcmVfbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgbGVnZW5kT3B0cyk7XHJcblx0Y29yZV9sYXlvdXRzLmFkZEJveChjaGFydCwgbGVnZW5kKTtcclxuXHRjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XHJcbn1cclxuXHJcbnZhciBwbHVnaW5fbGVnZW5kID0ge1xyXG5cdGlkOiAnbGVnZW5kJyxcclxuXHJcblx0LyoqXHJcblx0ICogQmFja3dhcmQgY29tcGF0aWJpbGl0eTogc2luY2UgMi4xLjUsIHRoZSBsZWdlbmQgaXMgcmVnaXN0ZXJlZCBhcyBhIHBsdWdpbiwgbWFraW5nXHJcblx0ICogQ2hhcnQuTGVnZW5kIG9ic29sZXRlLiBUbyBhdm9pZCBhIGJyZWFraW5nIGNoYW5nZSwgd2UgZXhwb3J0IHRoZSBMZWdlbmQgYXMgcGFydCBvZlxyXG5cdCAqIHRoZSBwbHVnaW4sIHdoaWNoIG9uZSB3aWxsIGJlIHJlLWV4cG9zZWQgaW4gdGhlIGNoYXJ0LmpzIGZpbGUuXHJcblx0ICogaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC8yNjQwXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZWxlbWVudDogTGVnZW5kLFxyXG5cclxuXHRiZWZvcmVJbml0OiBmdW5jdGlvbihjaGFydCkge1xyXG5cdFx0dmFyIGxlZ2VuZE9wdHMgPSBjaGFydC5vcHRpb25zLmxlZ2VuZDtcclxuXHJcblx0XHRpZiAobGVnZW5kT3B0cykge1xyXG5cdFx0XHRjcmVhdGVOZXdMZWdlbmRBbmRBdHRhY2goY2hhcnQsIGxlZ2VuZE9wdHMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdHZhciBsZWdlbmRPcHRzID0gY2hhcnQub3B0aW9ucy5sZWdlbmQ7XHJcblx0XHR2YXIgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xyXG5cclxuXHRcdGlmIChsZWdlbmRPcHRzKSB7XHJcblx0XHRcdGhlbHBlcnMkMS5tZXJnZUlmKGxlZ2VuZE9wdHMsIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmxlZ2VuZCk7XHJcblxyXG5cdFx0XHRpZiAobGVnZW5kKSB7XHJcblx0XHRcdFx0Y29yZV9sYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBsZWdlbmRPcHRzKTtcclxuXHRcdFx0XHRsZWdlbmQub3B0aW9ucyA9IGxlZ2VuZE9wdHM7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y3JlYXRlTmV3TGVnZW5kQW5kQXR0YWNoKGNoYXJ0LCBsZWdlbmRPcHRzKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChsZWdlbmQpIHtcclxuXHRcdFx0Y29yZV9sYXlvdXRzLnJlbW92ZUJveChjaGFydCwgbGVnZW5kKTtcclxuXHRcdFx0ZGVsZXRlIGNoYXJ0LmxlZ2VuZDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRhZnRlckV2ZW50OiBmdW5jdGlvbihjaGFydCwgZSkge1xyXG5cdFx0dmFyIGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcclxuXHRcdGlmIChsZWdlbmQpIHtcclxuXHRcdFx0bGVnZW5kLmhhbmRsZUV2ZW50KGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcblxudmFyIG5vb3AkMiA9IGhlbHBlcnMkMS5ub29wO1xyXG5cclxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XHJcblx0dGl0bGU6IHtcclxuXHRcdGRpc3BsYXk6IGZhbHNlLFxyXG5cdFx0Zm9udFN0eWxlOiAnYm9sZCcsXHJcblx0XHRmdWxsV2lkdGg6IHRydWUsXHJcblx0XHRwYWRkaW5nOiAxMCxcclxuXHRcdHBvc2l0aW9uOiAndG9wJyxcclxuXHRcdHRleHQ6ICcnLFxyXG5cdFx0d2VpZ2h0OiAyMDAwICAgICAgICAgLy8gYnkgZGVmYXVsdCBncmVhdGVyIHRoYW4gbGVnZW5kICgxMDAwKSB0byBiZSBhYm92ZVxyXG5cdH1cclxufSk7XHJcblxyXG4vKipcclxuICogSU1QT1JUQU5UOiB0aGlzIGNsYXNzIGlzIGV4cG9zZWQgcHVibGljbHkgYXMgQ2hhcnQuTGVnZW5kLCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHJlcXVpcmVkIVxyXG4gKi9cclxudmFyIFRpdGxlID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oY29uZmlnKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0aGVscGVycyQxLmV4dGVuZChtZSwgY29uZmlnKTtcclxuXHJcblx0XHQvLyBDb250YWlucyBoaXQgYm94ZXMgZm9yIGVhY2ggZGF0YXNldCAoaW4gZGF0YXNldCBvcmRlcilcclxuXHRcdG1lLmxlZ2VuZEhpdEJveGVzID0gW107XHJcblx0fSxcclxuXHJcblx0Ly8gVGhlc2UgbWV0aG9kcyBhcmUgb3JkZXJlZCBieSBsaWZlY3ljbGUuIFV0aWxpdGllcyB0aGVuIGZvbGxvdy5cclxuXHJcblx0YmVmb3JlVXBkYXRlOiBub29wJDIsXHJcblx0dXBkYXRlOiBmdW5jdGlvbihtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cclxuXHRcdC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXHJcblx0XHRtZS5iZWZvcmVVcGRhdGUoKTtcclxuXHJcblx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcclxuXHRcdG1lLm1heFdpZHRoID0gbWF4V2lkdGg7XHJcblx0XHRtZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XHJcblx0XHRtZS5tYXJnaW5zID0gbWFyZ2lucztcclxuXHJcblx0XHQvLyBEaW1lbnNpb25zXHJcblx0XHRtZS5iZWZvcmVTZXREaW1lbnNpb25zKCk7XHJcblx0XHRtZS5zZXREaW1lbnNpb25zKCk7XHJcblx0XHRtZS5hZnRlclNldERpbWVuc2lvbnMoKTtcclxuXHRcdC8vIExhYmVsc1xyXG5cdFx0bWUuYmVmb3JlQnVpbGRMYWJlbHMoKTtcclxuXHRcdG1lLmJ1aWxkTGFiZWxzKCk7XHJcblx0XHRtZS5hZnRlckJ1aWxkTGFiZWxzKCk7XHJcblxyXG5cdFx0Ly8gRml0XHJcblx0XHRtZS5iZWZvcmVGaXQoKTtcclxuXHRcdG1lLmZpdCgpO1xyXG5cdFx0bWUuYWZ0ZXJGaXQoKTtcclxuXHRcdC8vXHJcblx0XHRtZS5hZnRlclVwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiBtZS5taW5TaXplO1xyXG5cclxuXHR9LFxyXG5cdGFmdGVyVXBkYXRlOiBub29wJDIsXHJcblxyXG5cdC8vXHJcblxyXG5cdGJlZm9yZVNldERpbWVuc2lvbnM6IG5vb3AkMixcclxuXHRzZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHQvLyBTZXQgdGhlIHVuY29uc3RyYWluZWQgZGltZW5zaW9uIGJlZm9yZSBsYWJlbCByb3RhdGlvblxyXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XHJcblx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxyXG5cdFx0XHRtZS53aWR0aCA9IG1lLm1heFdpZHRoO1xyXG5cdFx0XHRtZS5sZWZ0ID0gMDtcclxuXHRcdFx0bWUucmlnaHQgPSBtZS53aWR0aDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1lLmhlaWdodCA9IG1lLm1heEhlaWdodDtcclxuXHJcblx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxyXG5cdFx0XHRtZS50b3AgPSAwO1xyXG5cdFx0XHRtZS5ib3R0b20gPSBtZS5oZWlnaHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gUmVzZXQgcGFkZGluZ1xyXG5cdFx0bWUucGFkZGluZ0xlZnQgPSAwO1xyXG5cdFx0bWUucGFkZGluZ1RvcCA9IDA7XHJcblx0XHRtZS5wYWRkaW5nUmlnaHQgPSAwO1xyXG5cdFx0bWUucGFkZGluZ0JvdHRvbSA9IDA7XHJcblxyXG5cdFx0Ly8gUmVzZXQgbWluU2l6ZVxyXG5cdFx0bWUubWluU2l6ZSA9IHtcclxuXHRcdFx0d2lkdGg6IDAsXHJcblx0XHRcdGhlaWdodDogMFxyXG5cdFx0fTtcclxuXHR9LFxyXG5cdGFmdGVyU2V0RGltZW5zaW9uczogbm9vcCQyLFxyXG5cclxuXHQvL1xyXG5cclxuXHRiZWZvcmVCdWlsZExhYmVsczogbm9vcCQyLFxyXG5cdGJ1aWxkTGFiZWxzOiBub29wJDIsXHJcblx0YWZ0ZXJCdWlsZExhYmVsczogbm9vcCQyLFxyXG5cclxuXHQvL1xyXG5cclxuXHRiZWZvcmVGaXQ6IG5vb3AkMixcclxuXHRmaXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcclxuXHRcdHZhciBtaW5TaXplID0gbWUubWluU2l6ZSA9IHt9O1xyXG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xyXG5cdFx0dmFyIGxpbmVDb3VudCwgdGV4dFNpemU7XHJcblxyXG5cdFx0aWYgKCFvcHRzLmRpc3BsYXkpIHtcclxuXHRcdFx0bWUud2lkdGggPSBtaW5TaXplLndpZHRoID0gbWUuaGVpZ2h0ID0gbWluU2l6ZS5oZWlnaHQgPSAwO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bGluZUNvdW50ID0gaGVscGVycyQxLmlzQXJyYXkob3B0cy50ZXh0KSA/IG9wdHMudGV4dC5sZW5ndGggOiAxO1xyXG5cdFx0dGV4dFNpemUgPSBsaW5lQ291bnQgKiBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KG9wdHMpLmxpbmVIZWlnaHQgKyBvcHRzLnBhZGRpbmcgKiAyO1xyXG5cclxuXHRcdG1lLndpZHRoID0gbWluU2l6ZS53aWR0aCA9IGlzSG9yaXpvbnRhbCA/IG1lLm1heFdpZHRoIDogdGV4dFNpemU7XHJcblx0XHRtZS5oZWlnaHQgPSBtaW5TaXplLmhlaWdodCA9IGlzSG9yaXpvbnRhbCA/IHRleHRTaXplIDogbWUubWF4SGVpZ2h0O1xyXG5cdH0sXHJcblx0YWZ0ZXJGaXQ6IG5vb3AkMixcclxuXHJcblx0Ly8gU2hhcmVkIE1ldGhvZHNcclxuXHRpc0hvcml6b250YWw6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcclxuXHRcdHJldHVybiBwb3MgPT09ICd0b3AnIHx8IHBvcyA9PT0gJ2JvdHRvbSc7XHJcblx0fSxcclxuXHJcblx0Ly8gQWN0dWFsbHkgZHJhdyB0aGUgdGl0bGUgYmxvY2sgb24gdGhlIGNhbnZhc1xyXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjdHggPSBtZS5jdHg7XHJcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKCFvcHRzLmRpc3BsYXkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmb250T3B0cyA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQob3B0cyk7XHJcblx0XHR2YXIgbGluZUhlaWdodCA9IGZvbnRPcHRzLmxpbmVIZWlnaHQ7XHJcblx0XHR2YXIgb2Zmc2V0ID0gbGluZUhlaWdodCAvIDIgKyBvcHRzLnBhZGRpbmc7XHJcblx0XHR2YXIgcm90YXRpb24gPSAwO1xyXG5cdFx0dmFyIHRvcCA9IG1lLnRvcDtcclxuXHRcdHZhciBsZWZ0ID0gbWUubGVmdDtcclxuXHRcdHZhciBib3R0b20gPSBtZS5ib3R0b207XHJcblx0XHR2YXIgcmlnaHQgPSBtZS5yaWdodDtcclxuXHRcdHZhciBtYXhXaWR0aCwgdGl0bGVYLCB0aXRsZVk7XHJcblxyXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdChvcHRzLmZvbnRDb2xvciwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRDb2xvcik7IC8vIHJlbmRlciBpbiBjb3JyZWN0IGNvbG91clxyXG5cdFx0Y3R4LmZvbnQgPSBmb250T3B0cy5zdHJpbmc7XHJcblxyXG5cdFx0Ly8gSG9yaXpvbnRhbFxyXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XHJcblx0XHRcdHRpdGxlWCA9IGxlZnQgKyAoKHJpZ2h0IC0gbGVmdCkgLyAyKTsgLy8gbWlkcG9pbnQgb2YgdGhlIHdpZHRoXHJcblx0XHRcdHRpdGxlWSA9IHRvcCArIG9mZnNldDtcclxuXHRcdFx0bWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aXRsZVggPSBvcHRzLnBvc2l0aW9uID09PSAnbGVmdCcgPyBsZWZ0ICsgb2Zmc2V0IDogcmlnaHQgLSBvZmZzZXQ7XHJcblx0XHRcdHRpdGxlWSA9IHRvcCArICgoYm90dG9tIC0gdG9wKSAvIDIpO1xyXG5cdFx0XHRtYXhXaWR0aCA9IGJvdHRvbSAtIHRvcDtcclxuXHRcdFx0cm90YXRpb24gPSBNYXRoLlBJICogKG9wdHMucG9zaXRpb24gPT09ICdsZWZ0JyA/IC0wLjUgOiAwLjUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGN0eC5zYXZlKCk7XHJcblx0XHRjdHgudHJhbnNsYXRlKHRpdGxlWCwgdGl0bGVZKTtcclxuXHRcdGN0eC5yb3RhdGUocm90YXRpb24pO1xyXG5cdFx0Y3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG5cdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG5cclxuXHRcdHZhciB0ZXh0ID0gb3B0cy50ZXh0O1xyXG5cdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KHRleHQpKSB7XHJcblx0XHRcdHZhciB5ID0gMDtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdFx0Y3R4LmZpbGxUZXh0KHRleHRbaV0sIDAsIHksIG1heFdpZHRoKTtcclxuXHRcdFx0XHR5ICs9IGxpbmVIZWlnaHQ7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGN0eC5maWxsVGV4dCh0ZXh0LCAwLCAwLCBtYXhXaWR0aCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlTmV3VGl0bGVCbG9ja0FuZEF0dGFjaChjaGFydCwgdGl0bGVPcHRzKSB7XHJcblx0dmFyIHRpdGxlID0gbmV3IFRpdGxlKHtcclxuXHRcdGN0eDogY2hhcnQuY3R4LFxyXG5cdFx0b3B0aW9uczogdGl0bGVPcHRzLFxyXG5cdFx0Y2hhcnQ6IGNoYXJ0XHJcblx0fSk7XHJcblxyXG5cdGNvcmVfbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCB0aXRsZU9wdHMpO1xyXG5cdGNvcmVfbGF5b3V0cy5hZGRCb3goY2hhcnQsIHRpdGxlKTtcclxuXHRjaGFydC50aXRsZUJsb2NrID0gdGl0bGU7XHJcbn1cclxuXHJcbnZhciBwbHVnaW5fdGl0bGUgPSB7XHJcblx0aWQ6ICd0aXRsZScsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IHNpbmNlIDIuMS41LCB0aGUgdGl0bGUgaXMgcmVnaXN0ZXJlZCBhcyBhIHBsdWdpbiwgbWFraW5nXHJcblx0ICogQ2hhcnQuVGl0bGUgb2Jzb2xldGUuIFRvIGF2b2lkIGEgYnJlYWtpbmcgY2hhbmdlLCB3ZSBleHBvcnQgdGhlIFRpdGxlIGFzIHBhcnQgb2ZcclxuXHQgKiB0aGUgcGx1Z2luLCB3aGljaCBvbmUgd2lsbCBiZSByZS1leHBvc2VkIGluIHRoZSBjaGFydC5qcyBmaWxlLlxyXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvMjY0MFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2VsZW1lbnQ6IFRpdGxlLFxyXG5cclxuXHRiZWZvcmVJbml0OiBmdW5jdGlvbihjaGFydCkge1xyXG5cdFx0dmFyIHRpdGxlT3B0cyA9IGNoYXJ0Lm9wdGlvbnMudGl0bGU7XHJcblxyXG5cdFx0aWYgKHRpdGxlT3B0cykge1xyXG5cdFx0XHRjcmVhdGVOZXdUaXRsZUJsb2NrQW5kQXR0YWNoKGNoYXJ0LCB0aXRsZU9wdHMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdHZhciB0aXRsZU9wdHMgPSBjaGFydC5vcHRpb25zLnRpdGxlO1xyXG5cdFx0dmFyIHRpdGxlQmxvY2sgPSBjaGFydC50aXRsZUJsb2NrO1xyXG5cclxuXHRcdGlmICh0aXRsZU9wdHMpIHtcclxuXHRcdFx0aGVscGVycyQxLm1lcmdlSWYodGl0bGVPcHRzLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC50aXRsZSk7XHJcblxyXG5cdFx0XHRpZiAodGl0bGVCbG9jaykge1xyXG5cdFx0XHRcdGNvcmVfbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlQmxvY2ssIHRpdGxlT3B0cyk7XHJcblx0XHRcdFx0dGl0bGVCbG9jay5vcHRpb25zID0gdGl0bGVPcHRzO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNyZWF0ZU5ld1RpdGxlQmxvY2tBbmRBdHRhY2goY2hhcnQsIHRpdGxlT3B0cyk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAodGl0bGVCbG9jaykge1xyXG5cdFx0XHRjb3JlX2xheW91dHMucmVtb3ZlQm94KGNoYXJ0LCB0aXRsZUJsb2NrKTtcclxuXHRcdFx0ZGVsZXRlIGNoYXJ0LnRpdGxlQmxvY2s7XHJcblx0XHR9XHJcblx0fVxyXG59O1xuXG52YXIgcGx1Z2lucyA9IHt9O1xyXG52YXIgZmlsbGVyID0gcGx1Z2luX2ZpbGxlcjtcclxudmFyIGxlZ2VuZCA9IHBsdWdpbl9sZWdlbmQ7XHJcbnZhciB0aXRsZSA9IHBsdWdpbl90aXRsZTtcbnBsdWdpbnMuZmlsbGVyID0gZmlsbGVyO1xucGx1Z2lucy5sZWdlbmQgPSBsZWdlbmQ7XG5wbHVnaW5zLnRpdGxlID0gdGl0bGU7XG5cbi8qKlxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0XHJcbiAqL1xyXG5cclxuXHJcbmNvcmVfY29udHJvbGxlci5oZWxwZXJzID0gaGVscGVycyQxO1xyXG5cclxuLy8gQHRvZG8gZGlzcGF0Y2ggdGhlc2UgaGVscGVycyBpbnRvIGFwcHJvcHJpYXRlZCBoZWxwZXJzL2hlbHBlcnMuKiBmaWxlIGFuZCB3cml0ZSB1bml0IHRlc3RzIVxyXG5jb3JlX2hlbHBlcnMoKTtcclxuXHJcbmNvcmVfY29udHJvbGxlci5fYWRhcHRlcnMgPSBjb3JlX2FkYXB0ZXJzO1xyXG5jb3JlX2NvbnRyb2xsZXIuQW5pbWF0aW9uID0gY29yZV9hbmltYXRpb247XHJcbmNvcmVfY29udHJvbGxlci5hbmltYXRpb25TZXJ2aWNlID0gY29yZV9hbmltYXRpb25zO1xyXG5jb3JlX2NvbnRyb2xsZXIuY29udHJvbGxlcnMgPSBjb250cm9sbGVycztcclxuY29yZV9jb250cm9sbGVyLkRhdGFzZXRDb250cm9sbGVyID0gY29yZV9kYXRhc2V0Q29udHJvbGxlcjtcclxuY29yZV9jb250cm9sbGVyLmRlZmF1bHRzID0gY29yZV9kZWZhdWx0cztcclxuY29yZV9jb250cm9sbGVyLkVsZW1lbnQgPSBjb3JlX2VsZW1lbnQ7XHJcbmNvcmVfY29udHJvbGxlci5lbGVtZW50cyA9IGVsZW1lbnRzO1xyXG5jb3JlX2NvbnRyb2xsZXIuSW50ZXJhY3Rpb24gPSBjb3JlX2ludGVyYWN0aW9uO1xyXG5jb3JlX2NvbnRyb2xsZXIubGF5b3V0cyA9IGNvcmVfbGF5b3V0cztcclxuY29yZV9jb250cm9sbGVyLnBsYXRmb3JtID0gcGxhdGZvcm07XHJcbmNvcmVfY29udHJvbGxlci5wbHVnaW5zID0gY29yZV9wbHVnaW5zO1xyXG5jb3JlX2NvbnRyb2xsZXIuU2NhbGUgPSBjb3JlX3NjYWxlO1xyXG5jb3JlX2NvbnRyb2xsZXIuc2NhbGVTZXJ2aWNlID0gY29yZV9zY2FsZVNlcnZpY2U7XHJcbmNvcmVfY29udHJvbGxlci5UaWNrcyA9IGNvcmVfdGlja3M7XHJcbmNvcmVfY29udHJvbGxlci5Ub29sdGlwID0gY29yZV90b29sdGlwO1xyXG5cclxuLy8gUmVnaXN0ZXIgYnVpbHQtaW4gc2NhbGVzXHJcblxyXG5jb3JlX2NvbnRyb2xsZXIuaGVscGVycy5lYWNoKHNjYWxlcywgZnVuY3Rpb24oc2NhbGUsIHR5cGUpIHtcclxuXHRjb3JlX2NvbnRyb2xsZXIuc2NhbGVTZXJ2aWNlLnJlZ2lzdGVyU2NhbGVUeXBlKHR5cGUsIHNjYWxlLCBzY2FsZS5fZGVmYXVsdHMpO1xyXG59KTtcclxuXHJcbi8vIExvYWQgdG8gcmVnaXN0ZXIgYnVpbHQtaW4gYWRhcHRlcnMgKGFzIHNpZGUgZWZmZWN0cylcclxuXHJcblxyXG4vLyBMb2FkaW5nIGJ1aWx0LWluIHBsdWdpbnNcclxuXHJcbmZvciAodmFyIGsgaW4gcGx1Z2lucykge1xyXG5cdGlmIChwbHVnaW5zLmhhc093blByb3BlcnR5KGspKSB7XHJcblx0XHRjb3JlX2NvbnRyb2xsZXIucGx1Z2lucy5yZWdpc3RlcihwbHVnaW5zW2tdKTtcclxuXHR9XHJcbn1cclxuXHJcbmNvcmVfY29udHJvbGxlci5wbGF0Zm9ybS5pbml0aWFsaXplKCk7XHJcblxyXG52YXIgc3JjID0gY29yZV9jb250cm9sbGVyO1xyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHR3aW5kb3cuQ2hhcnQgPSBjb3JlX2NvbnRyb2xsZXI7XHJcbn1cclxuXHJcbi8vIERFUFJFQ0FUSU9OU1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmVcclxuICogQG5hbWVzcGFjZSBDaGFydC5DaGFydFxyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXHJcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvcmVfY29udHJvbGxlci5DaGFydCA9IGNvcmVfY29udHJvbGxlcjtcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlXHJcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuTGVnZW5kXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi4xLjVcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29yZV9jb250cm9sbGVyLkxlZ2VuZCA9IHBsdWdpbnMubGVnZW5kLl9lbGVtZW50O1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmVcclxuICogQG5hbWVzcGFjZSBDaGFydC5UaXRsZVxyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuMS41XHJcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvcmVfY29udHJvbGxlci5UaXRsZSA9IHBsdWdpbnMudGl0bGUuX2VsZW1lbnQ7XHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5wbHVnaW5zIGluc3RlYWRcclxuICogQG5hbWVzcGFjZSBDaGFydC5wbHVnaW5TZXJ2aWNlXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi4xLjVcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29yZV9jb250cm9sbGVyLnBsdWdpblNlcnZpY2UgPSBjb3JlX2NvbnRyb2xsZXIucGx1Z2lucztcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgaW5oZXJpdGluZyBmcm9tIENoYXJ0LlBsdWdpbmdCYXNlIGhhcyBub1xyXG4gKiBlZmZlY3QsIGluc3RlYWQgc2ltcGx5IGNyZWF0ZS9yZWdpc3RlciBwbHVnaW5zIHZpYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXHJcbiAqIEBpbnRlcmZhY2UgQ2hhcnQuUGx1Z2luQmFzZVxyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNS4wXHJcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvcmVfY29udHJvbGxlci5QbHVnaW5CYXNlID0gY29yZV9jb250cm9sbGVyLkVsZW1lbnQuZXh0ZW5kKHt9KTtcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMuY2FudmFzIGluc3RlYWQuXHJcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuY2FudmFzSGVscGVyc1xyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNi4wXHJcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvcmVfY29udHJvbGxlci5jYW52YXNIZWxwZXJzID0gY29yZV9jb250cm9sbGVyLmhlbHBlcnMuY2FudmFzO1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQubGF5b3V0cyBpbnN0ZWFkLlxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmxheW91dFNlcnZpY2VcclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuM1xyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb3JlX2NvbnRyb2xsZXIubGF5b3V0U2VydmljZSA9IGNvcmVfY29udHJvbGxlci5sYXlvdXRzO1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmUuXHJcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuTGluZWFyU2NhbGVCYXNlXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44XHJcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvcmVfY29udHJvbGxlci5MaW5lYXJTY2FsZUJhc2UgPSBzY2FsZV9saW5lYXJiYXNlO1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBpbnN0ZWFkIHdlIHNob3VsZCBjcmVhdGUgYSBuZXcgQ2hhcnRcclxuICogYnkgc2V0dGluZyB0aGUgdHlwZSBpbiB0aGUgY29uZmlnIChgbmV3IENoYXJ0KGlkLCB7dHlwZTogJ3tjaGFydC10eXBlfSd9YCkuXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKi9cclxuY29yZV9jb250cm9sbGVyLmhlbHBlcnMuZWFjaChcclxuXHRbXHJcblx0XHQnQmFyJyxcclxuXHRcdCdCdWJibGUnLFxyXG5cdFx0J0RvdWdobnV0JyxcclxuXHRcdCdMaW5lJyxcclxuXHRcdCdQb2xhckFyZWEnLFxyXG5cdFx0J1JhZGFyJyxcclxuXHRcdCdTY2F0dGVyJ1xyXG5cdF0sXHJcblx0ZnVuY3Rpb24oa2xhc3MpIHtcclxuXHRcdGNvcmVfY29udHJvbGxlcltrbGFzc10gPSBmdW5jdGlvbihjdHgsIGNmZykge1xyXG5cdFx0XHRyZXR1cm4gbmV3IGNvcmVfY29udHJvbGxlcihjdHgsIGNvcmVfY29udHJvbGxlci5oZWxwZXJzLm1lcmdlKGNmZyB8fCB7fSwge1xyXG5cdFx0XHRcdHR5cGU6IGtsYXNzLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsga2xhc3Muc2xpY2UoMSlcclxuXHRcdFx0fSkpO1xyXG5cdFx0fTtcclxuXHR9XHJcbik7XG5cbnJldHVybiBzcmM7XG5cbn0pKSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///MO+k\n");

/***/ })

}]);