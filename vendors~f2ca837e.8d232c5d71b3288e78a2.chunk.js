(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~f2ca837e"],{

/***/ "aurelia-bodylight-plugin/elements/dygraphchart":
/*!********************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/dygraphchart.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.Dygraphchart = void 0;\n\nvar _dygraph = __webpack_require__(/*! ../utils/dygraph */ \"PA41\");\n\nvar _aureliaFramework = __webpack_require__(/*! aurelia-framework */ \"aurelia-framework\");\n\nvar _fileSaver = __webpack_require__(/*! file-saver */ \"Iab2\");\n\nvar _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5;\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\nvar Dygraphchart = (_class = /*#__PURE__*/function () {\n  function Dygraphchart() {\n    var _this = this;\n\n    _initializerDefineProperty(this, \"inputs\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"fromid\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"maxdata\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"refindex\", _descriptor4, this);\n\n    _initializerDefineProperty(this, \"refvalues\", _descriptor5, this);\n\n    this.initialdata = true;\n    //this.data = [[0, 0, 0]];\n    //this.data=[[1, 5], [2, 5], [3, 4.9], [4, 4.8], [5, 5.2]];\n    //create lambda function which is added as listener later\n    console.log('dygraph chart constructor');\n\n    this.handleValueChange = function (e) {\n      var datapoint = [e.detail.time]; //e.detail do not reallocate - using same buffer, thus slicing to append to data array\n\n      var edata = e.detail.data.slice();\n\n      for (var i = _this.refindex; i < _this.refindex + _this.refvalues; i++) {\n        datapoint.push(edata[i]);\n      }\n\n      if (_this.initialdata) {\n        _this.data = [];\n        _this.initialdata = false;\n      } //datapoint\n\n\n      _this.data.push(datapoint); //shift - remove first element if data is too big\n\n\n      if (_this.data.length > _this.maxdata) _this.data.shift(); //console.log('Dygraphchar data', this.data);\n\n      _this.dygraph.updateOptions({\n        'file': _this.data\n      });\n    };\n\n    this.handleReset = function (e) {\n      _this.resetdata();\n\n      _this.dygraph.updateOptions({\n        'file': _this.data\n      });\n    };\n  }\n\n  var _proto = Dygraphchart.prototype;\n\n  _proto.resetdata = function resetdata() {\n    this.data = [];\n    var initdatapoint = Array(parseInt(this.refvalues, 10) + 1).fill(0);\n    this.data.push(initdatapoint);\n    this.initialdata = true;\n  };\n\n  _proto.attached = function attached() {\n    //listening to custom event fmidata\n    console.log('dygraph attached');\n    var fmielement = document.getElementById(this.fromid);\n\n    if (fmielement) {\n      fmielement.addEventListener('fmidata', this.handleValueChange);\n      fmielement.addEventListener('fmireset', this.handleReset);\n    } //labels are separated by , in attribute inputs\n    //console.log('BdlDygraphchart attached inputs', this.inputs);\n\n\n    this.labels = this.inputs.split(','); //console.log('BdlDygraphchart attached labels', labels);\n    //create dygraph\n\n    this.resetdata(); //console.log('BdlDygraphchart attached initial data init data', initdatapoint, ' data:', this.data);\n\n    this.initdygraph();\n    /*data.push([x, y]);\n    g.updateOptions( { 'file': data } );*/\n  };\n\n  _proto.initdygraph = function initdygraph() {\n    //console.log('initdygraph:',Dygraph);\n    this.dygraph = new _dygraph.Dygraph(this.dygraphcanvas, this.data, {\n      //Draw a small dot at each point\n      drawPoints: true,\n      //rolling average period text box to be show\n      //showRoller: true,\n      //customBars if series is low;middle;high where range between low and high is visualised\n      //customBars: true,\n      //range selector\n      //showRangeSelector: true,\n      labels: this.labels\n    });\n  };\n\n  _proto.detached = function detached() {\n    if (document.getElementById(this.fromid)) document.getElementById(this.fromid).removeEventListener('fmidata', this.handleValueChange);\n    if (document.getElementById(this.fromid)) document.getElementById(this.fromid).removeEventListener('fmireset', this.handleReset);\n  };\n\n  _proto.download = function download() {\n    var filename = prompt('File name (*.csv):', 'data.csv');\n\n    if (filename) {\n      if (!filename.endsWith('.csv')) filename = filename.concat('.csv');\n      var content = this.inputs + '\\n' + this.data.map(function (e) {\n        return e.join(',');\n      }).join('\\n');\n      var blob = new Blob([content], {\n        type: 'text/csv;charset=utf-8;'\n      });\n      (0, _fileSaver.saveAs)(blob, filename);\n    }\n  };\n\n  _proto.preview = function preview() {\n    var content = this.inputs + '\\n' + this.data.map(function (e) {\n      return e.join(',');\n    }).join('\\n');\n    var blob = new Blob([content], {\n      type: 'text/csv;charset=utf-8;'\n    });\n    var url = URL.createObjectURL(blob);\n    this.popup = window.open(url, 'BodylightPreview', 'width=800,height=600,menubar=no,status=no,titlebar=no,toolbar=no');\n  };\n\n  return Dygraphchart;\n}(), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"inputs\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"fromid\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"maxdata\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 300;\n  }\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, \"refindex\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, \"refvalues\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 1;\n  }\n})), _class);\nexports.Dygraphchart = Dygraphchart;\n//# sourceMappingURL=dygraphchart.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2R5Z3JhcGhjaGFydC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLWJvZHlsaWdodC1wbHVnaW4vZGlzdC9uYXRpdmUtbW9kdWxlcy9lbGVtZW50cy9keWdyYXBoY2hhcnQuanM/NDcxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuRHlncmFwaGNoYXJ0ID0gdm9pZCAwO1xuXG52YXIgX2R5Z3JhcGggPSByZXF1aXJlKFwiLi4vdXRpbHMvZHlncmFwaFwiKTtcblxudmFyIF9hdXJlbGlhRnJhbWV3b3JrID0gcmVxdWlyZShcImF1cmVsaWEtZnJhbWV3b3JrXCIpO1xuXG52YXIgX2ZpbGVTYXZlciA9IHJlcXVpcmUoXCJmaWxlLXNhdmVyXCIpO1xuXG52YXIgX2NsYXNzLCBfZGVzY3JpcHRvciwgX2Rlc2NyaXB0b3IyLCBfZGVzY3JpcHRvcjMsIF9kZXNjcmlwdG9yNCwgX2Rlc2NyaXB0b3I1O1xuXG5mdW5jdGlvbiBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7IGlmICghZGVzY3JpcHRvcikgcmV0dXJuOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgeyBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsIHdyaXRhYmxlOiBkZXNjcmlwdG9yLndyaXRhYmxlLCB2YWx1ZTogZGVzY3JpcHRvci5pbml0aWFsaXplciA/IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMCB9KTsgfVxuXG5mdW5jdGlvbiBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHksIGRlY29yYXRvcnMsIGRlc2NyaXB0b3IsIGNvbnRleHQpIHsgdmFyIGRlc2MgPSB7fTsgT2JqZWN0LmtleXMoZGVzY3JpcHRvcikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGRlc2Nba2V5XSA9IGRlc2NyaXB0b3Jba2V5XTsgfSk7IGRlc2MuZW51bWVyYWJsZSA9ICEhZGVzYy5lbnVtZXJhYmxlOyBkZXNjLmNvbmZpZ3VyYWJsZSA9ICEhZGVzYy5jb25maWd1cmFibGU7IGlmICgndmFsdWUnIGluIGRlc2MgfHwgZGVzYy5pbml0aWFsaXplcikgeyBkZXNjLndyaXRhYmxlID0gdHJ1ZTsgfSBkZXNjID0gZGVjb3JhdG9ycy5zbGljZSgpLnJldmVyc2UoKS5yZWR1Y2UoZnVuY3Rpb24gKGRlc2MsIGRlY29yYXRvcikgeyByZXR1cm4gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHksIGRlc2MpIHx8IGRlc2M7IH0sIGRlc2MpOyBpZiAoY29udGV4dCAmJiBkZXNjLmluaXRpYWxpemVyICE9PSB2b2lkIDApIHsgZGVzYy52YWx1ZSA9IGRlc2MuaW5pdGlhbGl6ZXIgPyBkZXNjLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDA7IGRlc2MuaW5pdGlhbGl6ZXIgPSB1bmRlZmluZWQ7IH0gaWYgKGRlc2MuaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYyk7IGRlc2MgPSBudWxsOyB9IHJldHVybiBkZXNjOyB9XG5cbmZ1bmN0aW9uIF9pbml0aWFsaXplcldhcm5pbmdIZWxwZXIoZGVzY3JpcHRvciwgY29udGV4dCkgeyB0aHJvdyBuZXcgRXJyb3IoJ0RlY29yYXRpbmcgY2xhc3MgcHJvcGVydHkgZmFpbGVkLiBQbGVhc2UgZW5zdXJlIHRoYXQgJyArICdwcm9wb3NhbC1jbGFzcy1wcm9wZXJ0aWVzIGlzIGVuYWJsZWQgYW5kIHJ1bnMgYWZ0ZXIgdGhlIGRlY29yYXRvcnMgdHJhbnNmb3JtLicpOyB9XG5cbnZhciBEeWdyYXBoY2hhcnQgPSAoX2NsYXNzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRHlncmFwaGNoYXJ0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlucHV0c1wiLCBfZGVzY3JpcHRvciwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZyb21pZFwiLCBfZGVzY3JpcHRvcjIsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhkYXRhXCIsIF9kZXNjcmlwdG9yMywgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZmluZGV4XCIsIF9kZXNjcmlwdG9yNCwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZnZhbHVlc1wiLCBfZGVzY3JpcHRvcjUsIHRoaXMpO1xuXG4gICAgdGhpcy5pbml0aWFsZGF0YSA9IHRydWU7XG4gICAgLy90aGlzLmRhdGEgPSBbWzAsIDAsIDBdXTtcbiAgICAvL3RoaXMuZGF0YT1bWzEsIDVdLCBbMiwgNV0sIFszLCA0LjldLCBbNCwgNC44XSwgWzUsIDUuMl1dO1xuICAgIC8vY3JlYXRlIGxhbWJkYSBmdW5jdGlvbiB3aGljaCBpcyBhZGRlZCBhcyBsaXN0ZW5lciBsYXRlclxuICAgIGNvbnNvbGUubG9nKCdkeWdyYXBoIGNoYXJ0IGNvbnN0cnVjdG9yJyk7XG5cbiAgICB0aGlzLmhhbmRsZVZhbHVlQ2hhbmdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBkYXRhcG9pbnQgPSBbZS5kZXRhaWwudGltZV07IC8vZS5kZXRhaWwgZG8gbm90IHJlYWxsb2NhdGUgLSB1c2luZyBzYW1lIGJ1ZmZlciwgdGh1cyBzbGljaW5nIHRvIGFwcGVuZCB0byBkYXRhIGFycmF5XG5cbiAgICAgIHZhciBlZGF0YSA9IGUuZGV0YWlsLmRhdGEuc2xpY2UoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IF90aGlzLnJlZmluZGV4OyBpIDwgX3RoaXMucmVmaW5kZXggKyBfdGhpcy5yZWZ2YWx1ZXM7IGkrKykge1xuICAgICAgICBkYXRhcG9pbnQucHVzaChlZGF0YVtpXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5pbml0aWFsZGF0YSkge1xuICAgICAgICBfdGhpcy5kYXRhID0gW107XG4gICAgICAgIF90aGlzLmluaXRpYWxkYXRhID0gZmFsc2U7XG4gICAgICB9IC8vZGF0YXBvaW50XG5cblxuICAgICAgX3RoaXMuZGF0YS5wdXNoKGRhdGFwb2ludCk7IC8vc2hpZnQgLSByZW1vdmUgZmlyc3QgZWxlbWVudCBpZiBkYXRhIGlzIHRvbyBiaWdcblxuXG4gICAgICBpZiAoX3RoaXMuZGF0YS5sZW5ndGggPiBfdGhpcy5tYXhkYXRhKSBfdGhpcy5kYXRhLnNoaWZ0KCk7IC8vY29uc29sZS5sb2coJ0R5Z3JhcGhjaGFyIGRhdGEnLCB0aGlzLmRhdGEpO1xuXG4gICAgICBfdGhpcy5keWdyYXBoLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICAnZmlsZSc6IF90aGlzLmRhdGFcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLmhhbmRsZVJlc2V0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIF90aGlzLnJlc2V0ZGF0YSgpO1xuXG4gICAgICBfdGhpcy5keWdyYXBoLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICAnZmlsZSc6IF90aGlzLmRhdGFcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRHlncmFwaGNoYXJ0LnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVzZXRkYXRhID0gZnVuY3Rpb24gcmVzZXRkYXRhKCkge1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHZhciBpbml0ZGF0YXBvaW50ID0gQXJyYXkocGFyc2VJbnQodGhpcy5yZWZ2YWx1ZXMsIDEwKSArIDEpLmZpbGwoMCk7XG4gICAgdGhpcy5kYXRhLnB1c2goaW5pdGRhdGFwb2ludCk7XG4gICAgdGhpcy5pbml0aWFsZGF0YSA9IHRydWU7XG4gIH07XG5cbiAgX3Byb3RvLmF0dGFjaGVkID0gZnVuY3Rpb24gYXR0YWNoZWQoKSB7XG4gICAgLy9saXN0ZW5pbmcgdG8gY3VzdG9tIGV2ZW50IGZtaWRhdGFcbiAgICBjb25zb2xlLmxvZygnZHlncmFwaCBhdHRhY2hlZCcpO1xuICAgIHZhciBmbWllbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5mcm9taWQpO1xuXG4gICAgaWYgKGZtaWVsZW1lbnQpIHtcbiAgICAgIGZtaWVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm1pZGF0YScsIHRoaXMuaGFuZGxlVmFsdWVDaGFuZ2UpO1xuICAgICAgZm1pZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdmbWlyZXNldCcsIHRoaXMuaGFuZGxlUmVzZXQpO1xuICAgIH0gLy9sYWJlbHMgYXJlIHNlcGFyYXRlZCBieSAsIGluIGF0dHJpYnV0ZSBpbnB1dHNcbiAgICAvL2NvbnNvbGUubG9nKCdCZGxEeWdyYXBoY2hhcnQgYXR0YWNoZWQgaW5wdXRzJywgdGhpcy5pbnB1dHMpO1xuXG5cbiAgICB0aGlzLmxhYmVscyA9IHRoaXMuaW5wdXRzLnNwbGl0KCcsJyk7IC8vY29uc29sZS5sb2coJ0JkbER5Z3JhcGhjaGFydCBhdHRhY2hlZCBsYWJlbHMnLCBsYWJlbHMpO1xuICAgIC8vY3JlYXRlIGR5Z3JhcGhcblxuICAgIHRoaXMucmVzZXRkYXRhKCk7IC8vY29uc29sZS5sb2coJ0JkbER5Z3JhcGhjaGFydCBhdHRhY2hlZCBpbml0aWFsIGRhdGEgaW5pdCBkYXRhJywgaW5pdGRhdGFwb2ludCwgJyBkYXRhOicsIHRoaXMuZGF0YSk7XG5cbiAgICB0aGlzLmluaXRkeWdyYXBoKCk7XG4gICAgLypkYXRhLnB1c2goW3gsIHldKTtcbiAgICBnLnVwZGF0ZU9wdGlvbnMoIHsgJ2ZpbGUnOiBkYXRhIH0gKTsqL1xuICB9O1xuXG4gIF9wcm90by5pbml0ZHlncmFwaCA9IGZ1bmN0aW9uIGluaXRkeWdyYXBoKCkge1xuICAgIC8vY29uc29sZS5sb2coJ2luaXRkeWdyYXBoOicsRHlncmFwaCk7XG4gICAgdGhpcy5keWdyYXBoID0gbmV3IF9keWdyYXBoLkR5Z3JhcGgodGhpcy5keWdyYXBoY2FudmFzLCB0aGlzLmRhdGEsIHtcbiAgICAgIC8vRHJhdyBhIHNtYWxsIGRvdCBhdCBlYWNoIHBvaW50XG4gICAgICBkcmF3UG9pbnRzOiB0cnVlLFxuICAgICAgLy9yb2xsaW5nIGF2ZXJhZ2UgcGVyaW9kIHRleHQgYm94IHRvIGJlIHNob3dcbiAgICAgIC8vc2hvd1JvbGxlcjogdHJ1ZSxcbiAgICAgIC8vY3VzdG9tQmFycyBpZiBzZXJpZXMgaXMgbG93O21pZGRsZTtoaWdoIHdoZXJlIHJhbmdlIGJldHdlZW4gbG93IGFuZCBoaWdoIGlzIHZpc3VhbGlzZWRcbiAgICAgIC8vY3VzdG9tQmFyczogdHJ1ZSxcbiAgICAgIC8vcmFuZ2Ugc2VsZWN0b3JcbiAgICAgIC8vc2hvd1JhbmdlU2VsZWN0b3I6IHRydWUsXG4gICAgICBsYWJlbHM6IHRoaXMubGFiZWxzXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmRldGFjaGVkID0gZnVuY3Rpb24gZGV0YWNoZWQoKSB7XG4gICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZnJvbWlkKSkgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5mcm9taWQpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZtaWRhdGEnLCB0aGlzLmhhbmRsZVZhbHVlQ2hhbmdlKTtcbiAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5mcm9taWQpKSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmZyb21pZCkucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm1pcmVzZXQnLCB0aGlzLmhhbmRsZVJlc2V0KTtcbiAgfTtcblxuICBfcHJvdG8uZG93bmxvYWQgPSBmdW5jdGlvbiBkb3dubG9hZCgpIHtcbiAgICB2YXIgZmlsZW5hbWUgPSBwcm9tcHQoJ0ZpbGUgbmFtZSAoKi5jc3YpOicsICdkYXRhLmNzdicpO1xuXG4gICAgaWYgKGZpbGVuYW1lKSB7XG4gICAgICBpZiAoIWZpbGVuYW1lLmVuZHNXaXRoKCcuY3N2JykpIGZpbGVuYW1lID0gZmlsZW5hbWUuY29uY2F0KCcuY3N2Jyk7XG4gICAgICB2YXIgY29udGVudCA9IHRoaXMuaW5wdXRzICsgJ1xcbicgKyB0aGlzLmRhdGEubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLmpvaW4oJywnKTtcbiAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbY29udGVudF0sIHtcbiAgICAgICAgdHlwZTogJ3RleHQvY3N2O2NoYXJzZXQ9dXRmLTg7J1xuICAgICAgfSk7XG4gICAgICAoMCwgX2ZpbGVTYXZlci5zYXZlQXMpKGJsb2IsIGZpbGVuYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnByZXZpZXcgPSBmdW5jdGlvbiBwcmV2aWV3KCkge1xuICAgIHZhciBjb250ZW50ID0gdGhpcy5pbnB1dHMgKyAnXFxuJyArIHRoaXMuZGF0YS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBlLmpvaW4oJywnKTtcbiAgICB9KS5qb2luKCdcXG4nKTtcbiAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtjb250ZW50XSwge1xuICAgICAgdHlwZTogJ3RleHQvY3N2O2NoYXJzZXQ9dXRmLTg7J1xuICAgIH0pO1xuICAgIHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIHRoaXMucG9wdXAgPSB3aW5kb3cub3Blbih1cmwsICdCb2R5bGlnaHRQcmV2aWV3JywgJ3dpZHRoPTgwMCxoZWlnaHQ9NjAwLG1lbnViYXI9bm8sc3RhdHVzPW5vLHRpdGxlYmFyPW5vLHRvb2xiYXI9bm8nKTtcbiAgfTtcblxuICByZXR1cm4gRHlncmFwaGNoYXJ0O1xufSgpLCAoX2Rlc2NyaXB0b3IgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiaW5wdXRzXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjIgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiZnJvbWlkXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjMgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwibWF4ZGF0YVwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiBpbml0aWFsaXplcigpIHtcbiAgICByZXR1cm4gMzAwO1xuICB9XG59KSwgX2Rlc2NyaXB0b3I0ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcInJlZmluZGV4XCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjUgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwicmVmdmFsdWVzXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uIGluaXRpYWxpemVyKCkge1xuICAgIHJldHVybiAxO1xuICB9XG59KSksIF9jbGFzcyk7XG5leHBvcnRzLkR5Z3JhcGhjaGFydCA9IER5Z3JhcGhjaGFydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWR5Z3JhcGhjaGFydC5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/dygraphchart\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/dygraphchart.html":
/*!**********************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/dygraphchart.html ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template bindable=\\\"width,height\\\">   <!--other attributes @bindable inputs;  @bindable fromid;  @bindable maxdata=300;-->\\n  <div class=\\\"w3-container\\\">\\n    <span class=\\\"w3-small\\\">\\n      <i class=\\\"fa fa-download w3-border\\\" title=\\\"download csv data\\\" click.delegate=\\\"download()\\\"></i>\\n      <!--i class=\\\"fa fa-eye w3-border\\\" title=\\\"preview csv data\\\" click.delegate=\\\"preview()\\\"></i-->\\n    </span>\\n  <div ref=\\\"dygraphcanvas\\\" style=\\\"width:${width}px; height:${height}px;\\\"></div>\\n  </div>\\n</template>\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2R5Z3JhcGhjaGFydC5odG1sLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F1cmVsaWEtYm9keWxpZ2h0LXBsdWdpbi9kaXN0L25hdGl2ZS1tb2R1bGVzL2VsZW1lbnRzL2R5Z3JhcGhjaGFydC5odG1sPzdlMTgiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIjx0ZW1wbGF0ZSBiaW5kYWJsZT1cXFwid2lkdGgsaGVpZ2h0XFxcIj4gICA8IS0tb3RoZXIgYXR0cmlidXRlcyBAYmluZGFibGUgaW5wdXRzOyAgQGJpbmRhYmxlIGZyb21pZDsgIEBiaW5kYWJsZSBtYXhkYXRhPTMwMDstLT5cXG4gIDxkaXYgY2xhc3M9XFxcInczLWNvbnRhaW5lclxcXCI+XFxuICAgIDxzcGFuIGNsYXNzPVxcXCJ3My1zbWFsbFxcXCI+XFxuICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWRvd25sb2FkIHczLWJvcmRlclxcXCIgdGl0bGU9XFxcImRvd25sb2FkIGNzdiBkYXRhXFxcIiBjbGljay5kZWxlZ2F0ZT1cXFwiZG93bmxvYWQoKVxcXCI+PC9pPlxcbiAgICAgIDwhLS1pIGNsYXNzPVxcXCJmYSBmYS1leWUgdzMtYm9yZGVyXFxcIiB0aXRsZT1cXFwicHJldmlldyBjc3YgZGF0YVxcXCIgY2xpY2suZGVsZWdhdGU9XFxcInByZXZpZXcoKVxcXCI+PC9pLS0+XFxuICAgIDwvc3Bhbj5cXG4gIDxkaXYgcmVmPVxcXCJkeWdyYXBoY2FudmFzXFxcIiBzdHlsZT1cXFwid2lkdGg6JHt3aWR0aH1weDsgaGVpZ2h0OiR7aGVpZ2h0fXB4O1xcXCI+PC9kaXY+XFxuICA8L2Rpdj5cXG48L3RlbXBsYXRlPlxcblwiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/dygraphchart.html\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/ecg":
/*!***********************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/ecg.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.Ecg = void 0;\n\nvar _chartjsTime = __webpack_require__(/*! ./chartjs-time */ \"aurelia-bodylight-plugin/elements/chartjs-time\");\n\nvar _aureliaTemplating = __webpack_require__(/*! aurelia-templating */ \"hij8\");\n\nvar _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6;\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\n//import {PLATFORM} from 'aurelia-pal';\n//@useView(PLATFORM.moduleName('./bdl-chartjs.html'))\nvar Ecg = (_dec = (0, _aureliaTemplating.useView)('./chartjs.html'), _dec(_class = (_class2 = /*#__PURE__*/function (_ChartjsTime) {\n  _inheritsLoose(Ecg, _ChartjsTime);\n\n  //2 * 5*8 ecgvalues = 2 cardiac cycles\n  //@bindable refindex;\n  //  @bindable refvalues;\n  //initiate\n  // ]; //values in mV in segments\n  //ecgvalueslbb=[]\n  //labels related to values\n  function Ecg() {\n    var _this;\n\n    _this = _ChartjsTime.call(this) || this;\n\n    _initializerDefineProperty(_this, \"fromid\", _descriptor, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"labels\", _descriptor2, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"maxdata\", _descriptor3, _assertThisInitialized(_this));\n\n    _this.refindex = 0;\n    _this.refvalues = 1;\n    _this.previousreltime = 0;\n\n    _initializerDefineProperty(_this, \"type\", _descriptor4, _assertThisInitialized(_this));\n\n    _this.ecgvalues = [[0.2, 0.12, 0, 0, 0, 0, -0.1, 1.4], //4b\n    [-0.5, 0, 0, 0, 0, 0, 0, 0], //1\n    [0, 0, 0, 0, 0.15, 0.28, 0.35, 0.38], //2\n    [0.38, 0.35, 0.28, 0.15, 0, 0, 0, 0], //3\n    [0, 0, 0, 0, 0, 0, 0.12, 0.2] //4a\n    ];\n    _this.ecglabels = [['P', '', '', '', '', '', 'Q', 'R'], //4b\n    ['S', '', '', '', '', '', '', ''], //1\n    ['', '', '', '', '', '', '', 'T'], //2\n    ['', '', '', '', '', '', '', ''], //3\n    ['', '', '', '', '', '', '', 'P'] //4a\n    ];\n    _this.ecgindex = 0;\n    _this.ecgsegment = 1;\n\n    _initializerDefineProperty(_this, \"width\", _descriptor5, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"height\", _descriptor6, _assertThisInitialized(_this));\n\n    console.log('BdlEcg()'); //this.type = 'line';\n    //need to define method here in order to register it for eventlistener later\n\n    _this.handleValueChange = function (e) {\n      _this.handleValueChangeImpl(e);\n    };\n\n    return _this;\n  }\n\n  var _proto = Ecg.prototype;\n\n  _proto.bind = function bind() {\n    _ChartjsTime.prototype.bind.call(this);\n\n    this.datalabels = true; //disable labels on xaxes\n\n    this.options.scales.xAxes = [{\n      ticks: {\n        display: false\n      }\n    }];\n  };\n\n  _proto.attached = function attached() {\n    _ChartjsTime.prototype.attached.call(this);\n\n    var fromidel = document.getElementById(this.fromid);\n\n    if (fromidel) {\n      fromidel.addEventListener('animatedata', this.handleValueChange);\n    } //instantiate datalabels\n\n\n    if (!this.chart.data.datasets[0].datalabels) this.chart.data.datasets[0].datalabels = [];\n  };\n\n  _proto.detached = function detached() {\n    _ChartjsTime.prototype.detached.call(this);\n\n    if (document.getElementById(this.fromid)) {\n      document.getElementById(this.fromid).removeEventListener('animatedata', this.handleValueChange);\n    }\n  };\n\n  _proto.handleValueChangeImpl = function handleValueChangeImpl(e) {\n    console.log('bdl-ecg handlevaluechange e.detail', e.detail);\n    var mysegment = e.detail.segment;\n    var myreltime = e.detail.relativetime; //reset index if new segment\n\n    if (this.currentsegment !== mysegment) {\n      //reset index\n      this.previousindex = 0;\n      this.index = 0;\n      this.currentsegment = mysegment;\n      this.previousreltime = 0; //TODO draw points from previous segments - if not already drawn\n    } else {\n      this.previousindex = this.index;\n    } //count difference in this step\n\n\n    var rd = myreltime - this.previousreltime; //e.g. 0.33 of segments\n    //count how many points of ECG to draw - >1 -\n\n    var npoints = Math.round(this.ecgvalues[mysegment].length * rd);\n    this.index += npoints; //set previousreltime to current points of time used\n\n    this.previousreltime = this.previousreltime + npoints / this.ecgvalues[mysegment].length; //TODO push multiple values - per percent in current segment - or do approximation\n    //push multiple values - if in ecgvalues\n\n    console.log('bdl-ecg handlevaluechange npoints,previndex,index:', npoints, this.previousindex, this.index);\n\n    if (npoints > 0) {\n      var _this$chart$data$data, _this$chart$data$data2, _this$chart$data$labe;\n\n      (_this$chart$data$data = this.chart.data.datasets[0].data).push.apply(_this$chart$data$data, this.ecgvalues[mysegment].slice(this.previousindex, this.index));\n\n      (_this$chart$data$data2 = this.chart.data.datasets[0].datalabels).push.apply(_this$chart$data$data2, this.ecglabels[mysegment].slice(this.previousindex, this.index)); //push npoints times the 'time' label\n\n\n      (_this$chart$data$labe = this.chart.data.labels).push.apply(_this$chart$data$labe, Array(npoints).fill(e.detail.time)); //shift\n\n\n      if (this.chart.data.datasets[0].data.length > this.maxdata) {\n        //console.log('shifting dataset chartjs-time', this.chart.data.datasets[j].data);\n        var pointstoremove = this.chart.data.datasets[0].data.length - this.maxdata;\n        this.chart.data.datasets[0].data.splice(0, pointstoremove);\n        this.chart.data.datasets[0].datalabels.splice(0, pointstoremove);\n        this.chart.data.labels.splice(0, pointstoremove);\n      }\n    } //shift - remove first element if data is too big\n    //console.log('chartjs handlevaluechange() chart.data.datasets[0].data', this.chart.data.datasets[0].data);\n\n\n    this.chart.update(0);\n  };\n\n  return Ecg;\n}(_chartjsTime.ChartjsTime), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"fromid\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"labels\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 'ECG I (mV)';\n  }\n}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, \"maxdata\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 80;\n  }\n}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, \"type\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, \"width\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return '300';\n  }\n}), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, \"height\", [_aureliaTemplating.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return '50';\n  }\n})), _class2)) || _class);\nexports.Ecg = Ecg;\n//# sourceMappingURL=ecg.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2VjZy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLWJvZHlsaWdodC1wbHVnaW4vZGlzdC9uYXRpdmUtbW9kdWxlcy9lbGVtZW50cy9lY2cuanM/OTA0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuRWNnID0gdm9pZCAwO1xuXG52YXIgX2NoYXJ0anNUaW1lID0gcmVxdWlyZShcIi4vY2hhcnRqcy10aW1lXCIpO1xuXG52YXIgX2F1cmVsaWFUZW1wbGF0aW5nID0gcmVxdWlyZShcImF1cmVsaWEtdGVtcGxhdGluZ1wiKTtcblxudmFyIF9kZWMsIF9jbGFzcywgX2NsYXNzMiwgX2Rlc2NyaXB0b3IsIF9kZXNjcmlwdG9yMiwgX2Rlc2NyaXB0b3IzLCBfZGVzY3JpcHRvcjQsIF9kZXNjcmlwdG9yNSwgX2Rlc2NyaXB0b3I2O1xuXG5mdW5jdGlvbiBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7IGlmICghZGVzY3JpcHRvcikgcmV0dXJuOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgeyBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsIHdyaXRhYmxlOiBkZXNjcmlwdG9yLndyaXRhYmxlLCB2YWx1ZTogZGVzY3JpcHRvci5pbml0aWFsaXplciA/IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMCB9KTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVjb3JhdG9ycywgZGVzY3JpcHRvciwgY29udGV4dCkgeyB2YXIgZGVzYyA9IHt9OyBPYmplY3Qua2V5cyhkZXNjcmlwdG9yKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZGVzY1trZXldID0gZGVzY3JpcHRvcltrZXldOyB9KTsgZGVzYy5lbnVtZXJhYmxlID0gISFkZXNjLmVudW1lcmFibGU7IGRlc2MuY29uZmlndXJhYmxlID0gISFkZXNjLmNvbmZpZ3VyYWJsZTsgaWYgKCd2YWx1ZScgaW4gZGVzYyB8fCBkZXNjLmluaXRpYWxpemVyKSB7IGRlc2Mud3JpdGFibGUgPSB0cnVlOyB9IGRlc2MgPSBkZWNvcmF0b3JzLnNsaWNlKCkucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbiAoZGVzYywgZGVjb3JhdG9yKSB7IHJldHVybiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYykgfHwgZGVzYzsgfSwgZGVzYyk7IGlmIChjb250ZXh0ICYmIGRlc2MuaW5pdGlhbGl6ZXIgIT09IHZvaWQgMCkgeyBkZXNjLnZhbHVlID0gZGVzYy5pbml0aWFsaXplciA/IGRlc2MuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMDsgZGVzYy5pbml0aWFsaXplciA9IHVuZGVmaW5lZDsgfSBpZiAoZGVzYy5pbml0aWFsaXplciA9PT0gdm9pZCAwKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjKTsgZGVzYyA9IG51bGw7IH0gcmV0dXJuIGRlc2M7IH1cblxuZnVuY3Rpb24gX2luaXRpYWxpemVyV2FybmluZ0hlbHBlcihkZXNjcmlwdG9yLCBjb250ZXh0KSB7IHRocm93IG5ldyBFcnJvcignRGVjb3JhdGluZyBjbGFzcyBwcm9wZXJ0eSBmYWlsZWQuIFBsZWFzZSBlbnN1cmUgdGhhdCAnICsgJ3Byb3Bvc2FsLWNsYXNzLXByb3BlcnRpZXMgaXMgZW5hYmxlZCBhbmQgcnVucyBhZnRlciB0aGUgZGVjb3JhdG9ycyB0cmFuc2Zvcm0uJyk7IH1cblxuLy9pbXBvcnQge1BMQVRGT1JNfSBmcm9tICdhdXJlbGlhLXBhbCc7XG4vL0B1c2VWaWV3KFBMQVRGT1JNLm1vZHVsZU5hbWUoJy4vYmRsLWNoYXJ0anMuaHRtbCcpKVxudmFyIEVjZyA9IChfZGVjID0gKDAsIF9hdXJlbGlhVGVtcGxhdGluZy51c2VWaWV3KSgnLi9jaGFydGpzLmh0bWwnKSwgX2RlYyhfY2xhc3MgPSAoX2NsYXNzMiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NoYXJ0anNUaW1lKSB7XG4gIF9pbmhlcml0c0xvb3NlKEVjZywgX0NoYXJ0anNUaW1lKTtcblxuICAvLzIgKiA1KjggZWNndmFsdWVzID0gMiBjYXJkaWFjIGN5Y2xlc1xuICAvL0BiaW5kYWJsZSByZWZpbmRleDtcbiAgLy8gIEBiaW5kYWJsZSByZWZ2YWx1ZXM7XG4gIC8vaW5pdGlhdGVcbiAgLy8gXTsgLy92YWx1ZXMgaW4gbVYgaW4gc2VnbWVudHNcbiAgLy9lY2d2YWx1ZXNsYmI9W11cbiAgLy9sYWJlbHMgcmVsYXRlZCB0byB2YWx1ZXNcbiAgZnVuY3Rpb24gRWNnKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0NoYXJ0anNUaW1lLmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcImZyb21pZFwiLCBfZGVzY3JpcHRvciwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibGFiZWxzXCIsIF9kZXNjcmlwdG9yMiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibWF4ZGF0YVwiLCBfZGVzY3JpcHRvcjMsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF90aGlzLnJlZmluZGV4ID0gMDtcbiAgICBfdGhpcy5yZWZ2YWx1ZXMgPSAxO1xuICAgIF90aGlzLnByZXZpb3VzcmVsdGltZSA9IDA7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ0eXBlXCIsIF9kZXNjcmlwdG9yNCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX3RoaXMuZWNndmFsdWVzID0gW1swLjIsIDAuMTIsIDAsIDAsIDAsIDAsIC0wLjEsIDEuNF0sIC8vNGJcbiAgICBbLTAuNSwgMCwgMCwgMCwgMCwgMCwgMCwgMF0sIC8vMVxuICAgIFswLCAwLCAwLCAwLCAwLjE1LCAwLjI4LCAwLjM1LCAwLjM4XSwgLy8yXG4gICAgWzAuMzgsIDAuMzUsIDAuMjgsIDAuMTUsIDAsIDAsIDAsIDBdLCAvLzNcbiAgICBbMCwgMCwgMCwgMCwgMCwgMCwgMC4xMiwgMC4yXSAvLzRhXG4gICAgXTtcbiAgICBfdGhpcy5lY2dsYWJlbHMgPSBbWydQJywgJycsICcnLCAnJywgJycsICcnLCAnUScsICdSJ10sIC8vNGJcbiAgICBbJ1MnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJ10sIC8vMVxuICAgIFsnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJ1QnXSwgLy8yXG4gICAgWycnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJ10sIC8vM1xuICAgIFsnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJ1AnXSAvLzRhXG4gICAgXTtcbiAgICBfdGhpcy5lY2dpbmRleCA9IDA7XG4gICAgX3RoaXMuZWNnc2VnbWVudCA9IDE7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ3aWR0aFwiLCBfZGVzY3JpcHRvcjUsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KF90aGlzLCBcImhlaWdodFwiLCBfZGVzY3JpcHRvcjYsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIGNvbnNvbGUubG9nKCdCZGxFY2coKScpOyAvL3RoaXMudHlwZSA9ICdsaW5lJztcbiAgICAvL25lZWQgdG8gZGVmaW5lIG1ldGhvZCBoZXJlIGluIG9yZGVyIHRvIHJlZ2lzdGVyIGl0IGZvciBldmVudGxpc3RlbmVyIGxhdGVyXG5cbiAgICBfdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBfdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZUltcGwoZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBFY2cucHJvdG90eXBlO1xuXG4gIF9wcm90by5iaW5kID0gZnVuY3Rpb24gYmluZCgpIHtcbiAgICBfQ2hhcnRqc1RpbWUucHJvdG90eXBlLmJpbmQuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuZGF0YWxhYmVscyA9IHRydWU7IC8vZGlzYWJsZSBsYWJlbHMgb24geGF4ZXNcblxuICAgIHRoaXMub3B0aW9ucy5zY2FsZXMueEF4ZXMgPSBbe1xuICAgICAgdGlja3M6IHtcbiAgICAgICAgZGlzcGxheTogZmFsc2VcbiAgICAgIH1cbiAgICB9XTtcbiAgfTtcblxuICBfcHJvdG8uYXR0YWNoZWQgPSBmdW5jdGlvbiBhdHRhY2hlZCgpIHtcbiAgICBfQ2hhcnRqc1RpbWUucHJvdG90eXBlLmF0dGFjaGVkLmNhbGwodGhpcyk7XG5cbiAgICB2YXIgZnJvbWlkZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmZyb21pZCk7XG5cbiAgICBpZiAoZnJvbWlkZWwpIHtcbiAgICAgIGZyb21pZGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2FuaW1hdGVkYXRhJywgdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZSk7XG4gICAgfSAvL2luc3RhbnRpYXRlIGRhdGFsYWJlbHNcblxuXG4gICAgaWYgKCF0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YWxhYmVscykgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGFsYWJlbHMgPSBbXTtcbiAgfTtcblxuICBfcHJvdG8uZGV0YWNoZWQgPSBmdW5jdGlvbiBkZXRhY2hlZCgpIHtcbiAgICBfQ2hhcnRqc1RpbWUucHJvdG90eXBlLmRldGFjaGVkLmNhbGwodGhpcyk7XG5cbiAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5mcm9taWQpKSB7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmZyb21pZCkucmVtb3ZlRXZlbnRMaXN0ZW5lcignYW5pbWF0ZWRhdGEnLCB0aGlzLmhhbmRsZVZhbHVlQ2hhbmdlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZVZhbHVlQ2hhbmdlSW1wbCA9IGZ1bmN0aW9uIGhhbmRsZVZhbHVlQ2hhbmdlSW1wbChlKSB7XG4gICAgY29uc29sZS5sb2coJ2JkbC1lY2cgaGFuZGxldmFsdWVjaGFuZ2UgZS5kZXRhaWwnLCBlLmRldGFpbCk7XG4gICAgdmFyIG15c2VnbWVudCA9IGUuZGV0YWlsLnNlZ21lbnQ7XG4gICAgdmFyIG15cmVsdGltZSA9IGUuZGV0YWlsLnJlbGF0aXZldGltZTsgLy9yZXNldCBpbmRleCBpZiBuZXcgc2VnbWVudFxuXG4gICAgaWYgKHRoaXMuY3VycmVudHNlZ21lbnQgIT09IG15c2VnbWVudCkge1xuICAgICAgLy9yZXNldCBpbmRleFxuICAgICAgdGhpcy5wcmV2aW91c2luZGV4ID0gMDtcbiAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgdGhpcy5jdXJyZW50c2VnbWVudCA9IG15c2VnbWVudDtcbiAgICAgIHRoaXMucHJldmlvdXNyZWx0aW1lID0gMDsgLy9UT0RPIGRyYXcgcG9pbnRzIGZyb20gcHJldmlvdXMgc2VnbWVudHMgLSBpZiBub3QgYWxyZWFkeSBkcmF3blxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByZXZpb3VzaW5kZXggPSB0aGlzLmluZGV4O1xuICAgIH0gLy9jb3VudCBkaWZmZXJlbmNlIGluIHRoaXMgc3RlcFxuXG5cbiAgICB2YXIgcmQgPSBteXJlbHRpbWUgLSB0aGlzLnByZXZpb3VzcmVsdGltZTsgLy9lLmcuIDAuMzMgb2Ygc2VnbWVudHNcbiAgICAvL2NvdW50IGhvdyBtYW55IHBvaW50cyBvZiBFQ0cgdG8gZHJhdyAtID4xIC1cblxuICAgIHZhciBucG9pbnRzID0gTWF0aC5yb3VuZCh0aGlzLmVjZ3ZhbHVlc1tteXNlZ21lbnRdLmxlbmd0aCAqIHJkKTtcbiAgICB0aGlzLmluZGV4ICs9IG5wb2ludHM7IC8vc2V0IHByZXZpb3VzcmVsdGltZSB0byBjdXJyZW50IHBvaW50cyBvZiB0aW1lIHVzZWRcblxuICAgIHRoaXMucHJldmlvdXNyZWx0aW1lID0gdGhpcy5wcmV2aW91c3JlbHRpbWUgKyBucG9pbnRzIC8gdGhpcy5lY2d2YWx1ZXNbbXlzZWdtZW50XS5sZW5ndGg7IC8vVE9ETyBwdXNoIG11bHRpcGxlIHZhbHVlcyAtIHBlciBwZXJjZW50IGluIGN1cnJlbnQgc2VnbWVudCAtIG9yIGRvIGFwcHJveGltYXRpb25cbiAgICAvL3B1c2ggbXVsdGlwbGUgdmFsdWVzIC0gaWYgaW4gZWNndmFsdWVzXG5cbiAgICBjb25zb2xlLmxvZygnYmRsLWVjZyBoYW5kbGV2YWx1ZWNoYW5nZSBucG9pbnRzLHByZXZpbmRleCxpbmRleDonLCBucG9pbnRzLCB0aGlzLnByZXZpb3VzaW5kZXgsIHRoaXMuaW5kZXgpO1xuXG4gICAgaWYgKG5wb2ludHMgPiAwKSB7XG4gICAgICB2YXIgX3RoaXMkY2hhcnQkZGF0YSRkYXRhLCBfdGhpcyRjaGFydCRkYXRhJGRhdGEyLCBfdGhpcyRjaGFydCRkYXRhJGxhYmU7XG5cbiAgICAgIChfdGhpcyRjaGFydCRkYXRhJGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YSkucHVzaC5hcHBseShfdGhpcyRjaGFydCRkYXRhJGRhdGEsIHRoaXMuZWNndmFsdWVzW215c2VnbWVudF0uc2xpY2UodGhpcy5wcmV2aW91c2luZGV4LCB0aGlzLmluZGV4KSk7XG5cbiAgICAgIChfdGhpcyRjaGFydCRkYXRhJGRhdGEyID0gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGFsYWJlbHMpLnB1c2guYXBwbHkoX3RoaXMkY2hhcnQkZGF0YSRkYXRhMiwgdGhpcy5lY2dsYWJlbHNbbXlzZWdtZW50XS5zbGljZSh0aGlzLnByZXZpb3VzaW5kZXgsIHRoaXMuaW5kZXgpKTsgLy9wdXNoIG5wb2ludHMgdGltZXMgdGhlICd0aW1lJyBsYWJlbFxuXG5cbiAgICAgIChfdGhpcyRjaGFydCRkYXRhJGxhYmUgPSB0aGlzLmNoYXJ0LmRhdGEubGFiZWxzKS5wdXNoLmFwcGx5KF90aGlzJGNoYXJ0JGRhdGEkbGFiZSwgQXJyYXkobnBvaW50cykuZmlsbChlLmRldGFpbC50aW1lKSk7IC8vc2hpZnRcblxuXG4gICAgICBpZiAodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGEubGVuZ3RoID4gdGhpcy5tYXhkYXRhKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ3NoaWZ0aW5nIGRhdGFzZXQgY2hhcnRqcy10aW1lJywgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2pdLmRhdGEpO1xuICAgICAgICB2YXIgcG9pbnRzdG9yZW1vdmUgPSB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YS5sZW5ndGggLSB0aGlzLm1heGRhdGE7XG4gICAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhLnNwbGljZSgwLCBwb2ludHN0b3JlbW92ZSk7XG4gICAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhbGFiZWxzLnNwbGljZSgwLCBwb2ludHN0b3JlbW92ZSk7XG4gICAgICAgIHRoaXMuY2hhcnQuZGF0YS5sYWJlbHMuc3BsaWNlKDAsIHBvaW50c3RvcmVtb3ZlKTtcbiAgICAgIH1cbiAgICB9IC8vc2hpZnQgLSByZW1vdmUgZmlyc3QgZWxlbWVudCBpZiBkYXRhIGlzIHRvbyBiaWdcbiAgICAvL2NvbnNvbGUubG9nKCdjaGFydGpzIGhhbmRsZXZhbHVlY2hhbmdlKCkgY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhJywgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGEpO1xuXG5cbiAgICB0aGlzLmNoYXJ0LnVwZGF0ZSgwKTtcbiAgfTtcblxuICByZXR1cm4gRWNnO1xufShfY2hhcnRqc1RpbWUuQ2hhcnRqc1RpbWUpLCAoX2Rlc2NyaXB0b3IgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcImZyb21pZFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMiA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzMi5wcm90b3R5cGUsIFwibGFiZWxzXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiBpbml0aWFsaXplcigpIHtcbiAgICByZXR1cm4gJ0VDRyBJIChtViknO1xuICB9XG59KSwgX2Rlc2NyaXB0b3IzID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MyLnByb3RvdHlwZSwgXCJtYXhkYXRhXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiBpbml0aWFsaXplcigpIHtcbiAgICByZXR1cm4gODA7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjQgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcInR5cGVcIiwgW19hdXJlbGlhVGVtcGxhdGluZy5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjUgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcIndpZHRoXCIsIFtfYXVyZWxpYVRlbXBsYXRpbmcuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiBpbml0aWFsaXplcigpIHtcbiAgICByZXR1cm4gJzMwMCc7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjYgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzczIucHJvdG90eXBlLCBcImhlaWdodFwiLCBbX2F1cmVsaWFUZW1wbGF0aW5nLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gaW5pdGlhbGl6ZXIoKSB7XG4gICAgcmV0dXJuICc1MCc7XG4gIH1cbn0pKSwgX2NsYXNzMikpIHx8IF9jbGFzcyk7XG5leHBvcnRzLkVjZyA9IEVjZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVjZy5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/ecg\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/ecg.html":
/*!*************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/ecg.html ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template>\\n  <!-- not used, inherited from chartjs-->\\n  ECG:\\n  <div id=\\\"canvas-holder\\\">\\n    <span class=\\\"w3-small\\\">\\n      <i class=\\\"fa fa-download\\\" title=\\\"download csv data, row=data in time point\\\" click.delegate=\\\"download()\\\"></i>\\n      <i class=\\\"fa fa-download fa-rotate-270\\\" title=\\\"download flat csv data, row=all data for variable\\\" click.delegate=\\\"downloadflat()\\\"></i>\\n      <!--i class=\\\"fa fa-eye w3-border\\\" title=\\\"preview csv data\\\" click.delegate=\\\"preview()\\\"></i-->\\n    </span>\\n    <canvas id=\\\"${id}-canvas\\\" ref=\\\"chartcanvas\\\" width=\\\"${width}\\\" height=\\\"${height}\\\"></canvas> <!-- width=\\\"${width}\\\" height=\\\"${height}\\\" -->\\n  </div>\\n</template>\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2VjZy5odG1sLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F1cmVsaWEtYm9keWxpZ2h0LXBsdWdpbi9kaXN0L25hdGl2ZS1tb2R1bGVzL2VsZW1lbnRzL2VjZy5odG1sPzExYjYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIjx0ZW1wbGF0ZT5cXG4gIDwhLS0gbm90IHVzZWQsIGluaGVyaXRlZCBmcm9tIGNoYXJ0anMtLT5cXG4gIEVDRzpcXG4gIDxkaXYgaWQ9XFxcImNhbnZhcy1ob2xkZXJcXFwiPlxcbiAgICA8c3BhbiBjbGFzcz1cXFwidzMtc21hbGxcXFwiPlxcbiAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1kb3dubG9hZFxcXCIgdGl0bGU9XFxcImRvd25sb2FkIGNzdiBkYXRhLCByb3c9ZGF0YSBpbiB0aW1lIHBvaW50XFxcIiBjbGljay5kZWxlZ2F0ZT1cXFwiZG93bmxvYWQoKVxcXCI+PC9pPlxcbiAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1kb3dubG9hZCBmYS1yb3RhdGUtMjcwXFxcIiB0aXRsZT1cXFwiZG93bmxvYWQgZmxhdCBjc3YgZGF0YSwgcm93PWFsbCBkYXRhIGZvciB2YXJpYWJsZVxcXCIgY2xpY2suZGVsZWdhdGU9XFxcImRvd25sb2FkZmxhdCgpXFxcIj48L2k+XFxuICAgICAgPCEtLWkgY2xhc3M9XFxcImZhIGZhLWV5ZSB3My1ib3JkZXJcXFwiIHRpdGxlPVxcXCJwcmV2aWV3IGNzdiBkYXRhXFxcIiBjbGljay5kZWxlZ2F0ZT1cXFwicHJldmlldygpXFxcIj48L2ktLT5cXG4gICAgPC9zcGFuPlxcbiAgICA8Y2FudmFzIGlkPVxcXCIke2lkfS1jYW52YXNcXFwiIHJlZj1cXFwiY2hhcnRjYW52YXNcXFwiIHdpZHRoPVxcXCIke3dpZHRofVxcXCIgaGVpZ2h0PVxcXCIke2hlaWdodH1cXFwiPjwvY2FudmFzPiA8IS0tIHdpZHRoPVxcXCIke3dpZHRofVxcXCIgaGVpZ2h0PVxcXCIke2hlaWdodH1cXFwiIC0tPlxcbiAgPC9kaXY+XFxuPC90ZW1wbGF0ZT5cXG5cIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/ecg.html\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/fmi":
/*!***********************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/fmi.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.thirdpartytimeout = exports.Fmi = void 0;\n\nvar _aureliaFramework = __webpack_require__(/*! aurelia-framework */ \"aurelia-framework\");\n\nvar _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16, _descriptor17, _descriptor18, _descriptor19, _descriptor20, _descriptor21;\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\nvar thirdpartytimeout = 5000;\nexports.thirdpartytimeout = thirdpartytimeout;\nvar Fmi = (_class = /*#__PURE__*/function () {\n  //0.000030517578\n  //if >0 then fmi will stop at stoptime\n  //input==continuous/change==when user drops the value\n  //continuous or oneshot or onestep\n  //0.0078125;\n  function Fmi() {\n    var _this = this;\n\n    _initializerDefineProperty(this, \"fminame\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"tolerance\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"starttime\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"stoptime\", _descriptor4, this);\n\n    _initializerDefineProperty(this, \"guid\", _descriptor5, this);\n\n    _initializerDefineProperty(this, \"id\", _descriptor6, this);\n\n    _initializerDefineProperty(this, \"inputs\", _descriptor7, this);\n\n    _initializerDefineProperty(this, \"otherinputs\", _descriptor8, this);\n\n    _initializerDefineProperty(this, \"valuereferences\", _descriptor9, this);\n\n    _initializerDefineProperty(this, \"ticksToUpdate\", _descriptor10, this);\n\n    _initializerDefineProperty(this, \"src\", _descriptor11, this);\n\n    _initializerDefineProperty(this, \"fstepsize\", _descriptor12, this);\n\n    _initializerDefineProperty(this, \"controlid\", _descriptor13, this);\n\n    _initializerDefineProperty(this, \"showcontrols\", _descriptor14, this);\n\n    _initializerDefineProperty(this, \"fpslimit\", _descriptor15, this);\n\n    _initializerDefineProperty(this, \"showtime\", _descriptor16, this);\n\n    _initializerDefineProperty(this, \"showtimemultiply\", _descriptor17, this);\n\n    _initializerDefineProperty(this, \"eventlisten\", _descriptor18, this);\n\n    _initializerDefineProperty(this, \"mode\", _descriptor19, this);\n\n    _initializerDefineProperty(this, \"stepsperframe\", _descriptor20, this);\n\n    _initializerDefineProperty(this, \"fmuspeed\", _descriptor21, this);\n\n    this.cosimulation = 1;\n    this.stepSize = 0.01;\n    this.doingstep = false;\n    this.animationstarted = false;\n    this.measurefps = false;\n    this.d = void 0;\n    this.fpstick = 0;\n    this.stepi = 0;\n    this.resetBeforeChange = false;\n    this.simulationtime = 0;\n    this.isOneshot = false;\n    this.isOnestep = false;\n    this.perfstartTime = void 0;\n    this.perfendTime = void 0;\n    //create lambda function which is added as listener later\n    this.changeinputs = {}; //[]; change to associative array\n\n    this.handleValueChange = function (e) {\n      //e.target; //triggered the event\n      var targetid;\n      if (e.detail && e.detail.id) targetid = e.detail.id;else if (e.target.id.length > 0) targetid = e.target.id;else targetid = e.target.parentElement.parentElement.id;\n      var targetvalue = e.detail && e.detail.value ? e.detail.value : e.target.value; //bug sometimes value change is double fired, check whether changeinputs already contains the same value\n\n      if (_this.changeinputs[targetid] && _this.changeinputs[targetid].value === targetvalue) return;\n      _this.changeinputs[targetid] = {\n        id: targetid,\n        value: targetvalue\n      }; //detail will hold the value being changed\n      //determine whether it is fixed parameter - further reset is needed?\n\n      _this.resetBeforeChange = _this.resetBeforeChange || _this.inputreferences[targetid].fixed; //do step if mode is onestep\n\n      if (_this.isOnestep) setTimeout(_this.step.bind(_this), 100); //do simulation step after 100 ms\n\n      if (_this.isOneshot) {\n        //TODO do start\n        setTimeout(_this.shot.bind(_this), 100);\n      } //do simulation step after 100 ms\n\n    };\n\n    this.handleDetailChange = function (e) {\n      //this.changeinputs.push({valuereference: e.detail.valuereference, value: e.detail.value, fromid: e.detail.id}); //detail will hold the value being changed\n      //bug sometimes value change is double fired, check whether changeinputs already contains the same value\n      if (_this.changeinputs[e.detail.id] && _this.changeinputs[e.detail.id].value === e.detail.value) return;\n      _this.changeinputs[e.detail.id] = {\n        valuereference: e.detail.valuereference,\n        value: e.detail.value,\n        fromid: e.detail.id\n      }; //this.changeinputs[targetid] = targetvalue; //detail will hold the value being changed TODO valuereference???\n\n      console.log('fmi handle detail change', _this.changeinputs); //do step if mode is onestep\n\n      if (_this.isOnestep) setTimeout(_this.step.bind(_this), 100); //do simulation step after 100 ms\n\n      if (_this.isOneshot) {\n        //TODO do start\n        setTimeout(_this.shot.bind(_this), 100);\n      } //do simulation step after 100 ms\n\n    };\n\n    this.handleStart = function (e) {\n      _this.startevent(e);\n    };\n\n    this.handleStop = function (e) {\n      _this.stopevent(e);\n    }; //this handles event to register inputs - may be sent by subsequent component which change inputs/outputs communicating with fmi\n\n\n    this.handleRegister = function () {\n      _this.deregisterInputs();\n\n      _this.registerInputs();\n\n      if (_this.isOnestep) _this.step(); //do simulation step immediately;\n\n      if (_this.isOneshot) _this.shot(); //do simulation shot immediately;\n    };\n\n    this.handleStep = function () {\n      _this.shot();\n    };\n\n    this.inst = false;\n  }\n\n  var _proto = Fmi.prototype;\n\n  _proto.registerInputs = function registerInputs() {\n    if (this.inputs) {\n      //register DOM elements to listen to their 'change' event directly\n      var inputparts = this.inputs.split(';'); //splits groups delimited by ;\n\n      this.inputreferences = [];\n\n      for (var _iterator = _createForOfIteratorHelperLoose(inputparts), _step; !(_step = _iterator()).done;) {\n        var inputpart = _step.value;\n        var myinputs = inputpart.split(','); //splits reference and id by ,\n\n        var numerator = myinputs.length > 2 ? parseFloat(myinputs[2]) : 1;\n        var denominator = myinputs.length > 3 ? parseFloat(myinputs[3]) : 1;\n        var addconst = myinputs.length > 4 ? parseFloat(myinputs[4]) : 0;\n        var fixedsignature = myinputs.length > 5 ? myinputs[5] === 'f' : false;\n\n        if (isNaN(addconst)) {\n          addconst = 0;\n          fixedsignature = myinputs[4] === 'f';\n        } //fixes bug, setting  instead of NaN, when 4th param is omited and instead 'f' or 't' is specified\n\n\n        var inputref = {\n          ref: myinputs[1],\n          numerator: numerator,\n          denominator: denominator,\n          addconst: addconst,\n          fixed: fixedsignature\n        };\n\n        if (this.inputreferences[myinputs[0]]) {\n          this.inputreferences[myinputs[0]].fixed = this.inputreferences[myinputs[0]].fixed || fixedsignature;\n          this.inputreferences[myinputs[0]].refs.push(inputref); //first is id second is reference\n        } else this.inputreferences[myinputs[0]] = {\n          fixed: fixedsignature,\n          refs: [inputref]\n        }; //first is id second is reference\n        //register change event - the alteration is commited\n\n\n        var dependentEl = document.getElementById(myinputs[0]); //now register 'change' event or eventlisten\n\n        if (dependentEl) dependentEl.addEventListener(this.eventlisten, this.handleValueChange);else console.warn('cannot register changes for non-existing element id:', myinputs[0]);\n        console.log('registering input, ref, num,den,add,fixed', myinputs[0], myinputs[1], numerator, denominator, addconst, fixedsignature);\n      }\n    }\n\n    if (this.otherinputs) {\n      var otherinputtargets = this.otherinputs.split(';');\n\n      for (var _iterator2 = _createForOfIteratorHelperLoose(otherinputtargets), _step2; !(_step2 = _iterator2()).done;) {\n        var target = _step2.value;\n        document.getElementById(target).addEventListener('fmiinput', this.handleDetailChange);\n      }\n    } //TODO check if onestep - do step after\n\n    /*if (this.isOnestep) {\n      //console.log('onestep scheduling startevent in promise() to do step()')\n      setTimeout(this.sendStartEvent.bind(this),1000);\n      console.log('onestep scheduling promise() to do step()')\n      setTimeout(this.step.bind(this),1500);\n    } */\n    //do simulation step after 100 ms\n\n  };\n\n  _proto.deregisterInputs = function deregisterInputs() {\n    //do removeListeners()\n    if (this.inputs) {\n      var inputparts = this.inputs.split(';');\n\n      for (var _iterator3 = _createForOfIteratorHelperLoose(inputparts), _step3; !(_step3 = _iterator3()).done;) {\n        var inputpart = _step3.value;\n        var myinputs = inputpart.split(',');\n\n        try {\n          document.getElementById(myinputs[0]).removeEventListener(this.eventlisten, this.handleValueChange);\n        } catch (e) {}\n      }\n    }\n\n    if (this.otherinputs) {\n      var otherinputtargets = this.otherinputs.split(';');\n\n      for (var _iterator4 = _createForOfIteratorHelperLoose(otherinputtargets), _step4; !(_step4 = _iterator4()).done;) {\n        var target = _step4.value;\n\n        try {\n          document.getElementById(target).removeEventListener('fmiinput', this.handleDetailChange);\n        } catch (e) {}\n      }\n    }\n  };\n\n  _proto.attached = function attached() {\n    console.log('fmi attached');\n    this.mydata = [0, 0]; //split references by ,\n\n    this.references = this.valuereferences.split(',');\n    this.registerInputs(); //if src is not specified - then expects that fmi scripts is loaded in HTML page prior thus should be available\n\n    if (this.src && this.src.length > 0) {\n      console.log('loading script first, then init fmi'); //keep 'this' reference in global for callback\n\n      window.thisfmi = this;\n      this.getScript(this.src, this.initfmi);\n    } else {\n      //src is specified, thus load it - browser loads it at the end, thus adding the rest as callback after loaded\n      console.log('init fmi without loading script: fminame, this:', this.fminame, this);\n      this.initfmi();\n    }\n\n    if (this.controlid) {\n      document.getElementById(this.controlid).addEventListener('fmistart', this.handleStart);\n      document.getElementById(this.controlid).addEventListener('fmistop', this.handleStop);\n    }\n\n    if (typeof this.showcontrols === 'string') {\n      this.showcontrols = this.showcontrols === 'true';\n    }\n\n    document.addEventListener('fmiregister', this.handleRegister);\n    document.addEventListener('dostep', this.handleStep); //sending attached event - some may detect it to register it's outpu listener if attached before\n\n    var event = new CustomEvent('fmiattached');\n    document.dispatchEvent(event);\n  } //detects whether script with FMU is already loaded, if not it adds it to DOM and loads\n  //get script element and registers 'onload' callback to be called when the script is loaded\n  ;\n\n  _proto.getScript = function getScript(source, callback) {\n    //check whether the script is not already there\n    if (Array.from(document.getElementsByTagName('script')).filter(function (x) {\n      return x.getAttribute('src') === source;\n    }).length > 0) {\n      console.log('fmi.getScript() WARNING, script is already added into DOM:', source); //do callback?\n\n      if (callback) setTimeout(callback, 0);\n      return;\n    } //console.log('fmi getscript()');\n\n\n    var script = document.createElement('script');\n    var prior = document.getElementsByTagName('script')[0];\n    script.async = 1;\n\n    script.onerror = function () {\n      if (!script.readyState || /loaded|complete/.test(script.readyState)) {\n        script.onerror = script.onload = script.onreadystatechange = null;\n        script = undefined; // try to insert script by other app for previewing - scripts might be inserted into DOM\n\n        if (window.editorapi && typeof window.editorapi.insertScriptById === 'function') {\n          console.log('inserting script by thirdparty api');\n          window.editorapi.insertScriptById(source, 'fmiobj');\n        } //do callback even if isAbort - scripts might be inserted into DOM by another app\n\n\n        if (callback) setTimeout(callback, 1200);\n      }\n    };\n\n    script.onload = script.onreadystatechange = function (_, isAbort) {\n      if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {\n        script.onerror = script.onload = script.onreadystatechange = null;\n        script = undefined; //do callback - scripts might be inserted into DOM by another app\n\n        if (!isAbort && callback) setTimeout(callback, 0);\n      }\n    };\n\n    script.src = window.bdlBaseHref ? window.bdlBaseHref + source : source;\n    prior.parentNode.insertBefore(script, prior);\n  } //make inst object globally - in case of globals (non-src) declaration\n  ;\n\n  _proto.initfmi = function initfmi() {\n    console.log('fmi initfmi()');\n    var that = {};\n\n    if (window.thisfmi) {\n      that.fminame = window.thisfmi.fminame;\n      console.log('using global fmi initfmi() fminame', that.fminame);\n    } else {\n      that.fminame = this.fminame;\n      console.log('using local fmi initfmi() fminame', that.fminame);\n    } //create instance\n\n\n    var myinst = window[that.fminame](); //EMSDK v 3.x compiles fmu to Promise based api\n\n    if (myinst instanceof Promise) {\n      myinst.then(function (inst) {\n        that.inst = inst;\n\n        if (!window.fmiinst) {\n          window.fmiinst = [];\n        }\n\n        window.fmiinst[that.fminame] = that; //console.log('fmi callback from Promise that', that, that.inst);\n        //do one step if mode is onestep\n        //https://newbedev.com/pass-correct-this-context-to-settimeout-callback\n        //TODO check if this step/shot is needed\n\n        if (window.thisfmi.isOnestep) {\n          //console.log('onestep scheduling startevent in promise() to do step()')\n          setTimeout(window.thisfmi.sendStartEvent.bind(window.thisfmi), 1000);\n          console.log('onestep scheduling promise() to do step()');\n          setTimeout(window.thisfmi.step.bind(window.thisfmi), 1500);\n        } //do simulation step after 100 ms\n\n\n        if (window.thisfmi.isOneshot) {\n          //console.log('oneshot scheduling startevent in promise() to do step()')\n          setTimeout(window.thisfmi.sendStartEvent.bind(window.thisfmi), 1000);\n          console.log('oneshot scheduling promise() to do shot()');\n          setTimeout(window.thisfmi.shot.bind(window.thisfmi), 1500);\n        } //do simulation step after 100 ms\n\n      });\n    } else {\n      //older EMSDK prior 3.x compiles directly to api, keep compatibility\n      that.inst = myinst;\n\n      if (!window.fmiinst) {\n        window.fmiinst = [];\n      }\n\n      window.fmiinst[that.fminame] = that; //console.log('fmi callback that, that.inst', that, that.inst);\n      //do one step if mode is onestep\n      //https://newbedev.com/pass-correct-this-context-to-settimeout-callback\n\n      if (window.thisfmi.isOnestep) {\n        console.log('onestep scheduling direct(nopromise) to do step()');\n        setTimeout(window.thisfmi.sendStartEvent.bind(window.thisfmi), 1000);\n        setTimeout(window.thisfmi.step.bind(window.thisfmi), 1500);\n      } //do simulation step after 100 ms\n\n\n      if (window.thisfmi.isOneshot) {\n        console.log('oneshot scheduling direct(nopromise) to do step()');\n        setTimeout(window.thisfmi.sendStartEvent.bind(window.thisfmi), 1000);\n        setTimeout(window.thisfmi.shot.bind(window.thisfmi), 1500);\n      } //do simulation step after 100 ms\n\n    }\n  };\n\n  _proto.bind = function bind() {\n    this.isOneshot = this.mode === 'oneshot';\n    this.isOnestep = this.mode === 'onestep';\n\n    if (this.isOnestep) {\n      this.showcontrols = false;\n    }\n\n    if (this.isOneshot) {\n      this.showcontrols = false;\n    }\n\n    if (typeof this.stoptime === 'string') {\n      this.stoptime = parseFloat(this.stoptime);\n    }\n\n    if (typeof this.starttime === 'string') {\n      this.starttime = parseFloat(this.starttime);\n    }\n\n    if (typeof this.stepsperframee === 'string') {\n      this.stepsperframe = parseInt(this.stepsperframe);\n    }\n  };\n\n  _proto.detached = function detached() {\n    document.removeEventListener('fmiregister', this.handleRegister);\n\n    if (this.animationstarted) {\n      this.startstop();\n    }\n\n    this.deregisterInputs();\n\n    if (this.controlid) {\n      document.getElementById(this.controlid).removeEventListener('fmistart', this.handleStart);\n      document.getElementById(this.controlid).removeEventListener('fmistop', this.handleStop);\n    }\n  }\n  /**\n   * Implements a rudimentary browser console logger for the FMU.\n   */\n  ;\n\n  _proto.consoleLogger = function consoleLogger(componentEnvironment, instanceName, status, category, message, other) {\n    var _this2 = this;\n\n    /* Fills variables into message returned by the FMU, the C way */\n    var formatMessage = function formatMessage(message1, other1) {\n      // get a new pointer\n      var ptr = _this2.inst._malloc(1); // get the size of the resulting formated message\n\n\n      var num = _this2.inst._snprintf(ptr, 0, message1, other1);\n\n      _this2.inst._free(ptr);\n\n      num++; // TODO: Error handling num < 0\n\n      ptr = _this2.inst._malloc(num);\n\n      _this2.inst._snprintf(ptr, num, message1, other1); // return pointer to the resulting message string\n\n\n      return ptr;\n    }; // eslint-disable-next-line new-cap\n\n\n    console.log('FMU(' + this.inst.UTF8ToString(instanceName) + ':' + status + ':' + this.inst.UTF8ToString(category) + ') msg: ' + this.inst.UTF8ToString(formatMessage(message, other)));\n\n    this.inst._free(formatMessage);\n  };\n\n  _proto.initialize = function initialize() {\n    console.log('fmi initialize()');\n    this.fmiEnterInit(this.fmiinst);\n    this.fmiExitInit(this.fmiinst);\n  };\n\n  _proto.instantiate = function instantiate() {\n    console.log('fmi instantiate()'); //first define FMI API function names;\n\n    var sReset = 'fmi2Reset';\n    var sInstantiate = 'fmi2Instantiate';\n    var sSetup = 'fmi2SetupExperiment';\n    var sEnterinit = 'fmi2EnterInitializationMode';\n    var sExitinit = 'fmi2ExitInitializationMode';\n    var sSetreal = 'fmi2SetReal';\n    var sSetboolean = 'fmi2SetBoolean';\n    var sGetreal = 'fmi2GetReal';\n    var sGetboolean = 'fmi2GetBoolean';\n    var sDostep = 'fmi2DoStep';\n    var sCreateCallback = 'createFmi2CallbackFunctions';\n    this.stepTime = 0;\n    this.stepSize = typeof this.fstepsize === 'string' ? parseFloat(this.fstepsize) : this.fstepsize;\n    this.mystep = this.stepSize; //console callback ptr, per emsripten create int ptr with signature viiiiii\n\n    if (window.fmiinst && window.fmiinst[this.fminame]) this.inst = window.fmiinst[this.fminame].inst;else {\n      console.warn('fmi instantiate() error initfmi() probably not called');\n    } //else this.inst = null;//if (window.thisfmi) {this.inst = window.thisfmi.inst;}\n\n    console.log('instantiate() this.inst', this.inst); //set the fminame and JS WASM function references\n\n    var separator = '_';\n    var prefix = this.fminame; //console.log('attached fminame:', that.fminame);\n    // OpenModelica exports function names without prefix\n\n    if (typeof this.inst._fmi2GetVersion === 'function') {\n      prefix = '';\n      separator = '';\n    } //now use a 'cwrap' delivered by emscripten to facilitate calling C functions with C primitives (string,number) from Javascript\n\n\n    this.fmiCreateCallback = this.inst.cwrap(sCreateCallback, 'number', ['number']);\n    this.fmiReset = this.inst.cwrap(prefix + separator + sReset, 'number', ['number']);\n    this.fmiInstantiate = this.inst.cwrap(prefix + separator + sInstantiate, 'number', ['string', 'number', 'string', 'string', 'number', 'number', 'number']);\n    this.fmiSetup = this.inst.cwrap(prefix + separator + sSetup, 'number', ['number', 'number', 'number', 'number', 'number', 'number']);\n    this.fmiEnterInit = this.inst.cwrap(prefix + separator + sEnterinit, 'number', ['number']);\n    this.fmiExitInit = this.inst.cwrap(prefix + separator + sExitinit, 'number', ['number']);\n    this.fmiSetReal = this.inst.cwrap(prefix + separator + sSetreal, 'number', ['number', 'number', 'number', 'number']);\n    this.fmiGetReal = this.inst.cwrap(prefix + separator + sGetreal, 'number', ['number', 'number', 'number', 'number']);\n    this.fmiSetBoolean = this.inst.cwrap(prefix + separator + sSetboolean, 'number', ['number', 'number', 'number', 'number']);\n    this.fmiGetBoolean = this.inst.cwrap(prefix + separator + sGetboolean, 'number', ['number', 'number', 'number', 'number']);\n    this.fmiDoStep = this.inst.cwrap(prefix + separator + sDostep, 'number', ['number', 'number', 'number', 'number']);\n    this.fmiGetVersion = this.inst.cwrap(prefix + separator + 'fmi2GetVersion', 'string');\n    this.fmiGetTypesPlatform = this.inst.cwrap(prefix + separator + 'fmi2GetTypesPlatform', 'string');\n    this.fmi2FreeInstance = this.inst.cwrap(prefix + separator + 'fmi2FreeInstance', 'number', ['number']);\n    this.instantiated = false; //calculate pow, power of stepsize\n\n    this.pow = this.stepSize < 1 ? -Math.ceil(-Math.log10(this.stepSize)) : Math.ceil(Math.log10(this.stepSize)); //use Math.trunc ??\n    //console.log('instantiate() this', this);\n\n    this.consoleLoggerPtr = this.inst.addFunction(this.consoleLogger.bind(this), 'viiiiii');\n    this.callbackptr = this.fmiCreateCallback(this.consoleLoggerPtr); //console.log('fminame',this.fminame);\n    //console.log('guid',this.guid);\n    //console.log('callbackptr',this.callbackptr);\n    //console.log('fmiinstantiate fnc:',this.fmiInstantiate);\n    //create instance of model simulation\n\n    this.fmiinst = this.fmiInstantiate(this.fminame, this.cosimulation, this.guid, '', this.callbackptr, 0, 0); //last 1 debug, 0 nodebug\n\n    this.setupExperiment();\n  };\n\n  _proto.setupExperiment = function setupExperiment() {\n    //setup experiment\n    this.fmiSetup(this.fmiinst, 1, this.tolerance, this.starttime, 0);\n    console.log('setupExperiment() fmiinst', this.fmiinst);\n    this.instantiated = true;\n  };\n\n  _proto.simulate = function simulate() {};\n\n  _proto.setReal = function setReal(query, value, count) {\n    console.log('setreal query,value,count', query, value, count);\n    return this.fmiSetReal(this.fmiinst, query.byteOffset, count, value.byteOffset);\n  };\n\n  _proto.setBoolean = function setBoolean(query, value, count) {\n    return this.fmiSetBoolean(this.fmiinst, query.byteOffset, count, value.byteOffset);\n  }\n  /**\n   * Loads Reals from FMU\n   */\n  ;\n\n  _proto.getReal = function getReal(query, output, count) {\n    return this.fmiGetReal(this.fmiinst, query.byteOffset, count, output.byteOffset);\n  }\n  /**\n   * Loads Booleans from FMU\n   */\n  ;\n\n  _proto.getBoolean = function getBoolean(query, output, count) {\n    return this.fmiGetBoolean(this.fmiinst, query.byteOffset, count, output.byteOffset);\n  };\n\n  _proto.startevent = function startevent(e) {\n    console.log('fmi startevent recieved', e);\n    if (!this.animationstarted) this.startSimulation();\n  };\n\n  _proto.stopevent = function stopevent(e) {\n    console.log('fmi stopevent recieved', e);\n    if (this.animationstarted) this.stopSimulation();\n  } //action to be performed when clicking the play/pause button\n  //sends fmistart/fmistop event and starts/stops simulation\n  ;\n\n  _proto.startstop = function startstop() {\n    if (this.animationstarted) {\n      this.stopSimulation();\n      this.sendStopEvent();\n      this.perfend();\n    } else {\n      this.perfstart();\n      this.sendStartEvent();\n      this.startSimulation();\n    }\n  } //defines action to be done during browser animationframe and starts\n  ;\n\n  _proto.startSimulation = function startSimulation() {\n    var _this3 = this;\n\n    this.animationstarted = true;\n    this.fpsInterval = 1000 / (isNaN(this.fpslimit) ? parseInt(this.fpslimit, 10) : this.fpslimit);\n    this.then = window.performance.now();\n\n    var performAnimation = function performAnimation(newtime) {\n      if (!_this3.animationstarted) return;\n      _this3.request = requestAnimationFrame(performAnimation);\n\n      if (_this3.fpslimit && _this3.fpslimit < 60) {\n        if (isNaN(_this3.fpslimit)) _this3.fpslimit = parseInt(_this3.fpslimit, 10);\n        _this3.now = newtime; //console.log('limiting fps to fpslimit, newtime, now, then, fpsinterval', this.fpslimit, newtime, this.now, this.then, this.fpsInterval);\n\n        _this3.elapsed = _this3.now - _this3.then; //console.log('elapsed,fpsinterval', this.elapsed, this.fpsInterval);\n\n        if (_this3.elapsed > _this3.fpsInterval) {\n          _this3.then = _this3.now - _this3.elapsed % _this3.fpsInterval;\n\n          _this3.step();\n        }\n      } else {\n        for (var i = 0; i < _this3.stepsperframe; i++) {\n          _this3.step();\n        }\n      }\n    };\n\n    performAnimation();\n  } //cancels all action to be done during browser animationframe and starts\n  ;\n\n  _proto.stopSimulation = function stopSimulation() {\n    //stop animation\n    this.animationstarted = false;\n    cancelAnimationFrame(this.request);\n  } //sends fmistop event\n  ;\n\n  _proto.sendStopEvent = function sendStopEvent() {\n    //create custom event\n    var event = new CustomEvent('fmistop', {\n      detail: {\n        time: this.round(this.stepTime, this.pow)\n      }\n    }); //dispatch event - it should be listened by some other component\n\n    document.getElementById(this.id).dispatchEvent(event);\n  };\n\n  _proto.sendStartEvent = function sendStartEvent() {\n    //create custom event\n    console.log('fmi.sendStartEvent(). Sending start event for adobeobj');\n    var event = new CustomEvent('fmistart', {\n      detail: {\n        time: this.round(this.stepTime, this.pow)\n      }\n    }); //dispatch event - it should be listened by some other component\n\n    document.getElementById(this.id).dispatchEvent(event); //animate using requestAnimationFrame\n  };\n\n  _proto.round = function round(value, decimals) {\n    if (decimals < 0) {\n      var posdecimals = -decimals;\n      return Number(Math.round(value + 'e' + posdecimals) + 'e-' + posdecimals);\n    }\n\n    return Number(Math.round(value + 'e-' + decimals) + 'e+' + decimals);\n  };\n\n  _proto.step = function step() {\n    //this = window.thisfmi;\n    //primitive semaphore, only one instance can perform this call\n    if (!this.doingstep) {\n      console.log('fmu step()');\n      this.doingstep = true;\n\n      try {\n        if (!this.instantiated) {\n          this.instantiate();\n          this.initialize();\n        }\n\n        this.stepi++; //changeinputs\n\n        if (this.resetBeforeChange) {\n          //fmi call\n          this.setupExperiment(); //do reset\n\n          this.fmiReset(this.fmiinst); //setting fixed parameters are now allowed\n\n          this.setInputVariables(); //initialize\n\n          this.initialize(); //make big step from 0 to current stepTime ???\n          //const res =\n          //make big step only if it is not onestep\n\n          if (!this.isOnestep) this.fmiDoStep(this.fmiinst, this.starttime, this.stepTime, 1);else this.stepTime = this.starttime; //reset the signature\n\n          this.resetBeforeChange = false;\n        } else {\n          //do only change of variables\n          this.setInputVariables();\n        } //dostep\n        //compute step to round the desired time\n\n\n        var res = this.fmiDoStep(this.fmiinst, this.stepTime, this.mystep, 1);\n        this.stepTime = this.stepTime + this.mystep;\n        this.mystep = this.stepSize; //update correction step to current step\n\n        if (res === 1 || res === 2) {\n          console.warn('step() returned state<>0, doing reset()', res);\n          this.fmiReset(this.fmiinst);\n          this.initialize();\n        } //distribute simulation data to listeners\n\n\n        this.mydata = this.getReals(this.references); //create custom event\n\n        var event = new CustomEvent('fmidata', {\n          detail: {\n            time: this.round(this.stepTime, this.pow),\n            data: this.mydata\n          }\n        }); //dispatch event - it should be listened by some other component\n\n        document.getElementById(this.id).dispatchEvent(event); //compute showtime\n\n        if (this.showtime) this.simulationtime = this.secondsToTime(this.stepTime, this.showtimemultiply); //do computation only every tickstoupdate tick\n\n        if (this.measurefps) {\n          if (this.fpstick === 0) {\n            this.startfpstime = window.performance.now();\n          }\n\n          this.fpstick++;\n\n          if (this.fpstick >= this.ticksToUpdate) {\n            this.fpsInterval = 1000 / (isNaN(this.fpslimit) ? parseInt(this.fpslimit, 10) : this.fpslimit); //update ticks - so it will be every 3 seconds\n\n            this.ticksToUpdate = Math.round(3000 / this.fpsInterval); //do correction step calculation\n\n            if (this.stepSize < 1) {\n              this.pow = -Math.ceil(-Math.log10(this.stepSize));\n            } else {\n              this.pow = Math.ceil(Math.log10(this.stepSize));\n            }\n\n            this.mystep = this.round(this.stepTime + this.stepSize, this.pow) - this.stepTime; //do fps calculation\n\n            this.fps = (1000 * this.ticksToUpdate / (window.performance.now() - this.startfpstime)).toPrecision(4);\n            this.fpstick = 0;\n          }\n        } //stop simulation when stoptime is defined and reached\n\n\n        if (this.stoptime > 0 && this.animationstarted && this.stoptime < this.stepTime) {\n          this.startstop();\n        }\n      } catch (err) {\n        console.error('error catched during fmu step', err);\n      } finally {\n        this.doingstep = false;\n      }\n    }\n  };\n\n  _proto.shot = function shot() {\n    //check whether initialized and instantiated\n    if (!this.inst) {\n      //not instantiated\n      if (window.fmiinst && window.fmiinst[this.fminame]) {\n        this.instantiate();\n      } else {\n        //no initfmi() called = wait for script to be loaded, do nothing\n        return;\n      }\n    } else {\n      this.reset(); //this.setInputVariables();\n    } // do steps from starttime to stoptime\n\n\n    do {\n      this.step();\n    } while (this.stoptime > this.stepTime);\n  };\n\n  _proto.setInputVariables = function setInputVariables() {\n    for (var key in this.changeinputs) {\n      var myinputs = this.changeinputs[key]; //console.log('changing inputs', myinputs);\n      //set real - reference is in - one input one reference\n      //sets individual values - if id is in input, then reference is taken from inputs definition\n\n      console.log('changing inputs,id,value', this.inputreferences, myinputs.id, myinputs.value);\n\n      for (var _iterator5 = _createForOfIteratorHelperLoose(this.inputreferences[myinputs.id].refs), _step5; !(_step5 = _iterator5()).done;) {\n        var iref = _step5.value;\n        var normalizedvalue = myinputs.value * iref.numerator / iref.denominator + iref.addconst;\n        if (myinputs.id) this.setSingleReal(iref.ref, normalizedvalue); // if reference is in input, then it is set directly\n        else if (myinputs.valuereference) this.setSingleReal(myinputs.valuereference, normalizedvalue);\n      }\n    }\n\n    this.flushRealQueue();\n    this.changeinputs = {};\n    /*if (this.changeinputs.length > 0) {\n      while (this.changeinputs.length > 0) {\n        let myinputs = this.changeinputs.shift(); //remove first item\n        //console.log('changing inputs', myinputs);\n        //set real - reference is in - one input one reference\n        //sets individual values - if id is in input, then reference is taken from inputs definition\n        console.log('changing inputs,id,value', this.inputreferences, myinputs.id, myinputs.value);\n        for (let iref of this.inputreferences[myinputs.id].refs) {\n          let normalizedvalue = myinputs.value * iref.numerator / iref.denominator + iref.addconst;\n          if (myinputs.id) this.setSingleReal(iref.ref, normalizedvalue);\n          // if reference is in input, then it is set directly\n          else if (myinputs.valuereference) this.setSingleReal(myinputs.valuereference, normalizedvalue);\n        }\n      }\n      //flush all in one call to fmi\n      this.flushRealQueue();\n    }*/\n  };\n\n  _proto.reset = function reset() {\n    console.log('doing reset()');\n    this.stepTime = this.starttime;\n    this.stepSize = typeof this.fstepsize === 'string' ? parseFloat(this.fstepsize) : this.fstepsize;\n    this.mystep = this.stepSize;\n    this.setupExperiment();\n    this.fmiReset(this.fmiinst); //set input variables for possible change of non-tunable - fixed parameter values\n\n    this.setInputVariables();\n    this.initialize(); //create custom event\n\n    var event = new CustomEvent('fmireset'); //dispatch event - it should be listened by some other component\n\n    document.getElementById(this.id).dispatchEvent(event);\n  };\n\n  _proto.softreset = function softreset() {\n    this.stepTime = this.starttime;\n    this.stepSize = typeof this.fstepsize === 'string' ? parseFloat(this.fstepsize) : this.fstepsize;\n    this.mystep = this.stepSize; //this.setupExperiment();\n    //this.fmiReset(this.fmiinst);\n    //set input variables for possible change of non-tunable - fixed parameter values\n\n    this.setInputVariables(); //this.initialize();\n    //create custom event\n\n    var event = new CustomEvent('fmireset'); //dispatch event - it should be listened by some other component\n\n    document.getElementById(this.id).dispatchEvent(event);\n  }\n  /* routines to alloc buffer for getting/setting from fmi*/\n  ;\n\n  _proto.createBuffer = function createBuffer(arr) {\n    var size = arr.length * arr.BYTES_PER_ELEMENT;\n\n    var ptr = this.inst._malloc(size);\n\n    return {\n      ptr: ptr,\n      size: size\n    };\n  };\n\n  _proto.createAndFillBuffer = function createAndFillBuffer(arr) {\n    var buffer = this.createBuffer(arr);\n    this.fillBuffer(buffer, arr);\n    return buffer;\n  };\n\n  _proto.freeBuffer = function freeBuffer(buffer) {\n    if (buffer.ptr !== null) {\n      this.inst._free(buffer.ptr);\n    }\n\n    buffer.ptr = null;\n    buffer.size = null;\n  };\n\n  _proto.viewBuffer = function viewBuffer(buffer) {\n    return new Uint8Array(this.inst.HEAPU8.buffer, buffer.ptr, buffer.size);\n  };\n\n  _proto.fillBuffer = function fillBuffer(buffer, arr) {\n    var view = this.viewBuffer(buffer);\n    view.set(new Uint8Array(arr.buffer));\n    return buffer;\n  };\n\n  _proto.getReals = function getReals(references) {\n    var queryBuffer = this.createAndFillBuffer(new Int32Array(references));\n    var query = this.viewBuffer(queryBuffer);\n    var outputBuffer = this.createBuffer(new Float64Array(references.length));\n    var output = this.viewBuffer(outputBuffer);\n    this.getReal(query, output, references.length);\n    var real = new Float64Array(output.buffer, output.byteOffset, references.length);\n    this.freeBuffer(queryBuffer);\n    this.freeBuffer(outputBuffer);\n    return real;\n  };\n\n  _proto.getSingleReal = function getSingleReal(reference) {\n    var queryBuffer = this.createAndFillBuffer(new Int32Array([reference]));\n    var query = this.viewBuffer(queryBuffer);\n    var outputBuffer = this.createBuffer(new Float64Array(1));\n    var output = this.viewBuffer(outputBuffer);\n    this.getReal(query, output, 1);\n    var real = new Float64Array(output.buffer, output.byteOffset, 1);\n    this.freeBuffer(queryBuffer);\n    this.freeBuffer(outputBuffer);\n    return real[0];\n  }\n  /**\n     * Adds a real value to setRealQueue\n     */\n  ;\n\n  _proto.setSingleReal = function setSingleReal(reference, value) {\n    console.log('setSingleReal reference,value', reference, value);\n\n    if (!this.setRealQueue) {\n      this.setRealQueue = {\n        references: [],\n        values: []\n      };\n    }\n\n    this.setRealQueue.references.push(reference);\n    this.setRealQueue.values.push(value);\n  };\n\n  _proto.flushRealQueue = function flushRealQueue() {\n    if (this.setRealQueue) {\n      var referenceBuffer = this.createAndFillBuffer(new Int32Array(this.setRealQueue.references));\n      var references = this.viewBuffer(referenceBuffer);\n      var valueBuffer = this.createAndFillBuffer(new Float64Array(this.setRealQueue.values));\n      var values = this.viewBuffer(valueBuffer);\n      this.setReal(references, values, this.setRealQueue.references.length);\n      this.freeBuffer(referenceBuffer);\n      this.freeBuffer(valueBuffer);\n      this.setRealQueue = false;\n    }\n  };\n\n  _proto.flushBooleanQueue = function flushBooleanQueue() {\n    if (this.setBooleanQueue) {\n      var referenceBuffer = this.createAndFillBuffer(new Int32Array(this.setBooleanQueue.references));\n      var references = this.viewBuffer(referenceBuffer);\n      var valueBuffer = this.createAndFillBuffer(new Int32Array(this.setBooleanQueue.values));\n      var values = this.viewBuffer(valueBuffer);\n      this.setBoolean(references, values, this.setBooleanQueue.references.length);\n      this.freeBuffer(referenceBuffer);\n      this.freeBuffer(valueBuffer);\n      this.setBooleanQueue = false;\n    }\n  }\n  /**\n     */\n  ;\n\n  _proto.setSingleBoolean = function setSingleBoolean(reference, value) {\n    if (!this.setBooleanQueue) {\n      this.setBooleanQueue = {\n        references: [],\n        values: []\n      };\n    }\n\n    this.setBooleanQueue.references.push(reference);\n    this.setBooleanQueue.values.push(value);\n  }\n  /**\n     * Loads a single boolean value based on reference, this is a shorthand function.\n     * It is recommended to use Module.getBoolean with reusable mallocs.\n     */\n  ;\n\n  _proto.getSingleBoolean = function getSingleBoolean(reference) {\n    var queryBuffer = this.createAndFillBuffer(new Int32Array([reference]));\n    var query = this.viewBuffer(queryBuffer);\n    var outputBuffer = this.createBuffer(new Int32Array(1));\n    var output = this.viewBuffer(outputBuffer);\n    this.getBoolean(query, output, 1);\n    var bool = new Int32Array(output.buffer, output.byteOffset, 1);\n    this.freeBuffer(queryBuffer);\n    this.freeBuffer(outputBuffer);\n    return bool[0];\n  };\n\n  _proto.getBooleans = function getBooleans(references) {\n    var queryBuffer = this.createAndFillBuffer(new Int32Array(references));\n    var query = this.viewBuffer(queryBuffer);\n    var outputBuffer = this.createBuffer(new Int32Array(references.length));\n    var output = this.viewBuffer(outputBuffer);\n    this.getBoolean(query, output, references.length);\n    var bool = new Int32Array(output.buffer, output.byteOffset, references.length);\n    this.freeBuffer(queryBuffer);\n    this.freeBuffer(outputBuffer);\n    return bool;\n  };\n\n  _proto.secondsToTime = function secondsToTime(sec, multiply) {\n    if (multiply === void 0) {\n      multiply = 1;\n    }\n\n    var x = Math.floor(sec * multiply);\n    var seconds = Math.floor(x % 60).toString().padStart(2, '0');\n    x /= 60;\n    var minutes = Math.floor(x % 60).toString().padStart(2, '0');\n    x /= 60;\n    var hours = Math.floor(x % 24).toString().padStart(2, '0');\n    x /= 24;\n    var days = Math.floor(x);\n    return ' ' + days + ' ' + hours + ':' + minutes + ':' + seconds;\n  };\n\n  _proto.perfstart = function perfstart() {\n    this.perfstartTime = new Date();\n  };\n\n  //outputs how many s the simulation was performed - at the end of simulation, good to measure performance\n  _proto.perfend = function perfend() {\n    this.perfendTime = new Date();\n    var timeDiff = this.perfendTime - this.perfstartTime; //in ms\n    // strip the ms\n\n    timeDiff /= 1000; // get seconds\n\n    console.warn(\"Simulation took \" + timeDiff + \" seconds\");\n  };\n\n  _proto.fmuspeedChanged = function fmuspeedChanged(newValue) {\n    this.stepSize = this.fmuspeed * (typeof this.fstepsize === 'string' ? parseFloat(this.fstepsize) : this.fstepsize);\n  };\n\n  return Fmi;\n}(), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"fminame\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 'N/A';\n  }\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"tolerance\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 0.000001;\n  }\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"starttime\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 0;\n  }\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, \"stoptime\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 0;\n  }\n}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, \"guid\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 'N/A';\n  }\n}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, \"id\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor7 = _applyDecoratedDescriptor(_class.prototype, \"inputs\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor8 = _applyDecoratedDescriptor(_class.prototype, \"otherinputs\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor9 = _applyDecoratedDescriptor(_class.prototype, \"valuereferences\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor10 = _applyDecoratedDescriptor(_class.prototype, \"ticksToUpdate\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 30;\n  }\n}), _descriptor11 = _applyDecoratedDescriptor(_class.prototype, \"src\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor12 = _applyDecoratedDescriptor(_class.prototype, \"fstepsize\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 0.01;\n  }\n}), _descriptor13 = _applyDecoratedDescriptor(_class.prototype, \"controlid\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor14 = _applyDecoratedDescriptor(_class.prototype, \"showcontrols\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return true;\n  }\n}), _descriptor15 = _applyDecoratedDescriptor(_class.prototype, \"fpslimit\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 60;\n  }\n}), _descriptor16 = _applyDecoratedDescriptor(_class.prototype, \"showtime\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return false;\n  }\n}), _descriptor17 = _applyDecoratedDescriptor(_class.prototype, \"showtimemultiply\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 1;\n  }\n}), _descriptor18 = _applyDecoratedDescriptor(_class.prototype, \"eventlisten\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 'input';\n  }\n}), _descriptor19 = _applyDecoratedDescriptor(_class.prototype, \"mode\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return \"continuous\";\n  }\n}), _descriptor20 = _applyDecoratedDescriptor(_class.prototype, \"stepsperframe\", [_aureliaFramework.bindable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 1;\n  }\n}), _descriptor21 = _applyDecoratedDescriptor(_class.prototype, \"fmuspeed\", [_aureliaFramework.observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 1;\n  }\n})), _class);\nexports.Fmi = Fmi;\n//# sourceMappingURL=fmi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2ZtaS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLWJvZHlsaWdodC1wbHVnaW4vZGlzdC9uYXRpdmUtbW9kdWxlcy9lbGVtZW50cy9mbWkuanM/NGZjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudGhpcmRwYXJ0eXRpbWVvdXQgPSBleHBvcnRzLkZtaSA9IHZvaWQgMDtcblxudmFyIF9hdXJlbGlhRnJhbWV3b3JrID0gcmVxdWlyZShcImF1cmVsaWEtZnJhbWV3b3JrXCIpO1xuXG52YXIgX2NsYXNzLCBfZGVzY3JpcHRvciwgX2Rlc2NyaXB0b3IyLCBfZGVzY3JpcHRvcjMsIF9kZXNjcmlwdG9yNCwgX2Rlc2NyaXB0b3I1LCBfZGVzY3JpcHRvcjYsIF9kZXNjcmlwdG9yNywgX2Rlc2NyaXB0b3I4LCBfZGVzY3JpcHRvcjksIF9kZXNjcmlwdG9yMTAsIF9kZXNjcmlwdG9yMTEsIF9kZXNjcmlwdG9yMTIsIF9kZXNjcmlwdG9yMTMsIF9kZXNjcmlwdG9yMTQsIF9kZXNjcmlwdG9yMTUsIF9kZXNjcmlwdG9yMTYsIF9kZXNjcmlwdG9yMTcsIF9kZXNjcmlwdG9yMTgsIF9kZXNjcmlwdG9yMTksIF9kZXNjcmlwdG9yMjAsIF9kZXNjcmlwdG9yMjE7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmIChpdCkgcmV0dXJuIChpdCA9IGl0LmNhbGwobykpLm5leHQuYmluZChpdCk7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7IGlmICghZGVzY3JpcHRvcikgcmV0dXJuOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgeyBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsIHdyaXRhYmxlOiBkZXNjcmlwdG9yLndyaXRhYmxlLCB2YWx1ZTogZGVzY3JpcHRvci5pbml0aWFsaXplciA/IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMCB9KTsgfVxuXG5mdW5jdGlvbiBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHksIGRlY29yYXRvcnMsIGRlc2NyaXB0b3IsIGNvbnRleHQpIHsgdmFyIGRlc2MgPSB7fTsgT2JqZWN0LmtleXMoZGVzY3JpcHRvcikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGRlc2Nba2V5XSA9IGRlc2NyaXB0b3Jba2V5XTsgfSk7IGRlc2MuZW51bWVyYWJsZSA9ICEhZGVzYy5lbnVtZXJhYmxlOyBkZXNjLmNvbmZpZ3VyYWJsZSA9ICEhZGVzYy5jb25maWd1cmFibGU7IGlmICgndmFsdWUnIGluIGRlc2MgfHwgZGVzYy5pbml0aWFsaXplcikgeyBkZXNjLndyaXRhYmxlID0gdHJ1ZTsgfSBkZXNjID0gZGVjb3JhdG9ycy5zbGljZSgpLnJldmVyc2UoKS5yZWR1Y2UoZnVuY3Rpb24gKGRlc2MsIGRlY29yYXRvcikgeyByZXR1cm4gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHksIGRlc2MpIHx8IGRlc2M7IH0sIGRlc2MpOyBpZiAoY29udGV4dCAmJiBkZXNjLmluaXRpYWxpemVyICE9PSB2b2lkIDApIHsgZGVzYy52YWx1ZSA9IGRlc2MuaW5pdGlhbGl6ZXIgPyBkZXNjLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDA7IGRlc2MuaW5pdGlhbGl6ZXIgPSB1bmRlZmluZWQ7IH0gaWYgKGRlc2MuaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYyk7IGRlc2MgPSBudWxsOyB9IHJldHVybiBkZXNjOyB9XG5cbmZ1bmN0aW9uIF9pbml0aWFsaXplcldhcm5pbmdIZWxwZXIoZGVzY3JpcHRvciwgY29udGV4dCkgeyB0aHJvdyBuZXcgRXJyb3IoJ0RlY29yYXRpbmcgY2xhc3MgcHJvcGVydHkgZmFpbGVkLiBQbGVhc2UgZW5zdXJlIHRoYXQgJyArICdwcm9wb3NhbC1jbGFzcy1wcm9wZXJ0aWVzIGlzIGVuYWJsZWQgYW5kIHJ1bnMgYWZ0ZXIgdGhlIGRlY29yYXRvcnMgdHJhbnNmb3JtLicpOyB9XG5cbnZhciB0aGlyZHBhcnR5dGltZW91dCA9IDUwMDA7XG5leHBvcnRzLnRoaXJkcGFydHl0aW1lb3V0ID0gdGhpcmRwYXJ0eXRpbWVvdXQ7XG52YXIgRm1pID0gKF9jbGFzcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vMC4wMDAwMzA1MTc1NzhcbiAgLy9pZiA+MCB0aGVuIGZtaSB3aWxsIHN0b3AgYXQgc3RvcHRpbWVcbiAgLy9pbnB1dD09Y29udGludW91cy9jaGFuZ2U9PXdoZW4gdXNlciBkcm9wcyB0aGUgdmFsdWVcbiAgLy9jb250aW51b3VzIG9yIG9uZXNob3Qgb3Igb25lc3RlcFxuICAvLzAuMDA3ODEyNTtcbiAgZnVuY3Rpb24gRm1pKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZtaW5hbWVcIiwgX2Rlc2NyaXB0b3IsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b2xlcmFuY2VcIiwgX2Rlc2NyaXB0b3IyLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhcnR0aW1lXCIsIF9kZXNjcmlwdG9yMywgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3B0aW1lXCIsIF9kZXNjcmlwdG9yNCwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImd1aWRcIiwgX2Rlc2NyaXB0b3I1LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwgX2Rlc2NyaXB0b3I2LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5wdXRzXCIsIF9kZXNjcmlwdG9yNywgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm90aGVyaW5wdXRzXCIsIF9kZXNjcmlwdG9yOCwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbHVlcmVmZXJlbmNlc1wiLCBfZGVzY3JpcHRvcjksIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aWNrc1RvVXBkYXRlXCIsIF9kZXNjcmlwdG9yMTAsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJzcmNcIiwgX2Rlc2NyaXB0b3IxMSwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZzdGVwc2l6ZVwiLCBfZGVzY3JpcHRvcjEyLCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udHJvbGlkXCIsIF9kZXNjcmlwdG9yMTMsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJzaG93Y29udHJvbHNcIiwgX2Rlc2NyaXB0b3IxNCwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZwc2xpbWl0XCIsIF9kZXNjcmlwdG9yMTUsIHRoaXMpO1xuXG4gICAgX2luaXRpYWxpemVyRGVmaW5lUHJvcGVydHkodGhpcywgXCJzaG93dGltZVwiLCBfZGVzY3JpcHRvcjE2LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwic2hvd3RpbWVtdWx0aXBseVwiLCBfZGVzY3JpcHRvcjE3LCB0aGlzKTtcblxuICAgIF9pbml0aWFsaXplckRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXZlbnRsaXN0ZW5cIiwgX2Rlc2NyaXB0b3IxOCwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1vZGVcIiwgX2Rlc2NyaXB0b3IxOSwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0ZXBzcGVyZnJhbWVcIiwgX2Rlc2NyaXB0b3IyMCwgdGhpcyk7XG5cbiAgICBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZtdXNwZWVkXCIsIF9kZXNjcmlwdG9yMjEsIHRoaXMpO1xuXG4gICAgdGhpcy5jb3NpbXVsYXRpb24gPSAxO1xuICAgIHRoaXMuc3RlcFNpemUgPSAwLjAxO1xuICAgIHRoaXMuZG9pbmdzdGVwID0gZmFsc2U7XG4gICAgdGhpcy5hbmltYXRpb25zdGFydGVkID0gZmFsc2U7XG4gICAgdGhpcy5tZWFzdXJlZnBzID0gZmFsc2U7XG4gICAgdGhpcy5kID0gdm9pZCAwO1xuICAgIHRoaXMuZnBzdGljayA9IDA7XG4gICAgdGhpcy5zdGVwaSA9IDA7XG4gICAgdGhpcy5yZXNldEJlZm9yZUNoYW5nZSA9IGZhbHNlO1xuICAgIHRoaXMuc2ltdWxhdGlvbnRpbWUgPSAwO1xuICAgIHRoaXMuaXNPbmVzaG90ID0gZmFsc2U7XG4gICAgdGhpcy5pc09uZXN0ZXAgPSBmYWxzZTtcbiAgICB0aGlzLnBlcmZzdGFydFRpbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5wZXJmZW5kVGltZSA9IHZvaWQgMDtcbiAgICAvL2NyZWF0ZSBsYW1iZGEgZnVuY3Rpb24gd2hpY2ggaXMgYWRkZWQgYXMgbGlzdGVuZXIgbGF0ZXJcbiAgICB0aGlzLmNoYW5nZWlucHV0cyA9IHt9OyAvL1tdOyBjaGFuZ2UgdG8gYXNzb2NpYXRpdmUgYXJyYXlcblxuICAgIHRoaXMuaGFuZGxlVmFsdWVDaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgLy9lLnRhcmdldDsgLy90cmlnZ2VyZWQgdGhlIGV2ZW50XG4gICAgICB2YXIgdGFyZ2V0aWQ7XG4gICAgICBpZiAoZS5kZXRhaWwgJiYgZS5kZXRhaWwuaWQpIHRhcmdldGlkID0gZS5kZXRhaWwuaWQ7ZWxzZSBpZiAoZS50YXJnZXQuaWQubGVuZ3RoID4gMCkgdGFyZ2V0aWQgPSBlLnRhcmdldC5pZDtlbHNlIHRhcmdldGlkID0gZS50YXJnZXQucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50LmlkO1xuICAgICAgdmFyIHRhcmdldHZhbHVlID0gZS5kZXRhaWwgJiYgZS5kZXRhaWwudmFsdWUgPyBlLmRldGFpbC52YWx1ZSA6IGUudGFyZ2V0LnZhbHVlOyAvL2J1ZyBzb21ldGltZXMgdmFsdWUgY2hhbmdlIGlzIGRvdWJsZSBmaXJlZCwgY2hlY2sgd2hldGhlciBjaGFuZ2VpbnB1dHMgYWxyZWFkeSBjb250YWlucyB0aGUgc2FtZSB2YWx1ZVxuXG4gICAgICBpZiAoX3RoaXMuY2hhbmdlaW5wdXRzW3RhcmdldGlkXSAmJiBfdGhpcy5jaGFuZ2VpbnB1dHNbdGFyZ2V0aWRdLnZhbHVlID09PSB0YXJnZXR2YWx1ZSkgcmV0dXJuO1xuICAgICAgX3RoaXMuY2hhbmdlaW5wdXRzW3RhcmdldGlkXSA9IHtcbiAgICAgICAgaWQ6IHRhcmdldGlkLFxuICAgICAgICB2YWx1ZTogdGFyZ2V0dmFsdWVcbiAgICAgIH07IC8vZGV0YWlsIHdpbGwgaG9sZCB0aGUgdmFsdWUgYmVpbmcgY2hhbmdlZFxuICAgICAgLy9kZXRlcm1pbmUgd2hldGhlciBpdCBpcyBmaXhlZCBwYXJhbWV0ZXIgLSBmdXJ0aGVyIHJlc2V0IGlzIG5lZWRlZD9cblxuICAgICAgX3RoaXMucmVzZXRCZWZvcmVDaGFuZ2UgPSBfdGhpcy5yZXNldEJlZm9yZUNoYW5nZSB8fCBfdGhpcy5pbnB1dHJlZmVyZW5jZXNbdGFyZ2V0aWRdLmZpeGVkOyAvL2RvIHN0ZXAgaWYgbW9kZSBpcyBvbmVzdGVwXG5cbiAgICAgIGlmIChfdGhpcy5pc09uZXN0ZXApIHNldFRpbWVvdXQoX3RoaXMuc3RlcC5iaW5kKF90aGlzKSwgMTAwKTsgLy9kbyBzaW11bGF0aW9uIHN0ZXAgYWZ0ZXIgMTAwIG1zXG5cbiAgICAgIGlmIChfdGhpcy5pc09uZXNob3QpIHtcbiAgICAgICAgLy9UT0RPIGRvIHN0YXJ0XG4gICAgICAgIHNldFRpbWVvdXQoX3RoaXMuc2hvdC5iaW5kKF90aGlzKSwgMTAwKTtcbiAgICAgIH0gLy9kbyBzaW11bGF0aW9uIHN0ZXAgYWZ0ZXIgMTAwIG1zXG5cbiAgICB9O1xuXG4gICAgdGhpcy5oYW5kbGVEZXRhaWxDaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgLy90aGlzLmNoYW5nZWlucHV0cy5wdXNoKHt2YWx1ZXJlZmVyZW5jZTogZS5kZXRhaWwudmFsdWVyZWZlcmVuY2UsIHZhbHVlOiBlLmRldGFpbC52YWx1ZSwgZnJvbWlkOiBlLmRldGFpbC5pZH0pOyAvL2RldGFpbCB3aWxsIGhvbGQgdGhlIHZhbHVlIGJlaW5nIGNoYW5nZWRcbiAgICAgIC8vYnVnIHNvbWV0aW1lcyB2YWx1ZSBjaGFuZ2UgaXMgZG91YmxlIGZpcmVkLCBjaGVjayB3aGV0aGVyIGNoYW5nZWlucHV0cyBhbHJlYWR5IGNvbnRhaW5zIHRoZSBzYW1lIHZhbHVlXG4gICAgICBpZiAoX3RoaXMuY2hhbmdlaW5wdXRzW2UuZGV0YWlsLmlkXSAmJiBfdGhpcy5jaGFuZ2VpbnB1dHNbZS5kZXRhaWwuaWRdLnZhbHVlID09PSBlLmRldGFpbC52YWx1ZSkgcmV0dXJuO1xuICAgICAgX3RoaXMuY2hhbmdlaW5wdXRzW2UuZGV0YWlsLmlkXSA9IHtcbiAgICAgICAgdmFsdWVyZWZlcmVuY2U6IGUuZGV0YWlsLnZhbHVlcmVmZXJlbmNlLFxuICAgICAgICB2YWx1ZTogZS5kZXRhaWwudmFsdWUsXG4gICAgICAgIGZyb21pZDogZS5kZXRhaWwuaWRcbiAgICAgIH07IC8vdGhpcy5jaGFuZ2VpbnB1dHNbdGFyZ2V0aWRdID0gdGFyZ2V0dmFsdWU7IC8vZGV0YWlsIHdpbGwgaG9sZCB0aGUgdmFsdWUgYmVpbmcgY2hhbmdlZCBUT0RPIHZhbHVlcmVmZXJlbmNlPz8/XG5cbiAgICAgIGNvbnNvbGUubG9nKCdmbWkgaGFuZGxlIGRldGFpbCBjaGFuZ2UnLCBfdGhpcy5jaGFuZ2VpbnB1dHMpOyAvL2RvIHN0ZXAgaWYgbW9kZSBpcyBvbmVzdGVwXG5cbiAgICAgIGlmIChfdGhpcy5pc09uZXN0ZXApIHNldFRpbWVvdXQoX3RoaXMuc3RlcC5iaW5kKF90aGlzKSwgMTAwKTsgLy9kbyBzaW11bGF0aW9uIHN0ZXAgYWZ0ZXIgMTAwIG1zXG5cbiAgICAgIGlmIChfdGhpcy5pc09uZXNob3QpIHtcbiAgICAgICAgLy9UT0RPIGRvIHN0YXJ0XG4gICAgICAgIHNldFRpbWVvdXQoX3RoaXMuc2hvdC5iaW5kKF90aGlzKSwgMTAwKTtcbiAgICAgIH0gLy9kbyBzaW11bGF0aW9uIHN0ZXAgYWZ0ZXIgMTAwIG1zXG5cbiAgICB9O1xuXG4gICAgdGhpcy5oYW5kbGVTdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBfdGhpcy5zdGFydGV2ZW50KGUpO1xuICAgIH07XG5cbiAgICB0aGlzLmhhbmRsZVN0b3AgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgX3RoaXMuc3RvcGV2ZW50KGUpO1xuICAgIH07IC8vdGhpcyBoYW5kbGVzIGV2ZW50IHRvIHJlZ2lzdGVyIGlucHV0cyAtIG1heSBiZSBzZW50IGJ5IHN1YnNlcXVlbnQgY29tcG9uZW50IHdoaWNoIGNoYW5nZSBpbnB1dHMvb3V0cHV0cyBjb21tdW5pY2F0aW5nIHdpdGggZm1pXG5cblxuICAgIHRoaXMuaGFuZGxlUmVnaXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5kZXJlZ2lzdGVySW5wdXRzKCk7XG5cbiAgICAgIF90aGlzLnJlZ2lzdGVySW5wdXRzKCk7XG5cbiAgICAgIGlmIChfdGhpcy5pc09uZXN0ZXApIF90aGlzLnN0ZXAoKTsgLy9kbyBzaW11bGF0aW9uIHN0ZXAgaW1tZWRpYXRlbHk7XG5cbiAgICAgIGlmIChfdGhpcy5pc09uZXNob3QpIF90aGlzLnNob3QoKTsgLy9kbyBzaW11bGF0aW9uIHNob3QgaW1tZWRpYXRlbHk7XG4gICAgfTtcblxuICAgIHRoaXMuaGFuZGxlU3RlcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNob3QoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5pbnN0ID0gZmFsc2U7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRm1pLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVnaXN0ZXJJbnB1dHMgPSBmdW5jdGlvbiByZWdpc3RlcklucHV0cygpIHtcbiAgICBpZiAodGhpcy5pbnB1dHMpIHtcbiAgICAgIC8vcmVnaXN0ZXIgRE9NIGVsZW1lbnRzIHRvIGxpc3RlbiB0byB0aGVpciAnY2hhbmdlJyBldmVudCBkaXJlY3RseVxuICAgICAgdmFyIGlucHV0cGFydHMgPSB0aGlzLmlucHV0cy5zcGxpdCgnOycpOyAvL3NwbGl0cyBncm91cHMgZGVsaW1pdGVkIGJ5IDtcblxuICAgICAgdGhpcy5pbnB1dHJlZmVyZW5jZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShpbnB1dHBhcnRzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGlucHV0cGFydCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICB2YXIgbXlpbnB1dHMgPSBpbnB1dHBhcnQuc3BsaXQoJywnKTsgLy9zcGxpdHMgcmVmZXJlbmNlIGFuZCBpZCBieSAsXG5cbiAgICAgICAgdmFyIG51bWVyYXRvciA9IG15aW5wdXRzLmxlbmd0aCA+IDIgPyBwYXJzZUZsb2F0KG15aW5wdXRzWzJdKSA6IDE7XG4gICAgICAgIHZhciBkZW5vbWluYXRvciA9IG15aW5wdXRzLmxlbmd0aCA+IDMgPyBwYXJzZUZsb2F0KG15aW5wdXRzWzNdKSA6IDE7XG4gICAgICAgIHZhciBhZGRjb25zdCA9IG15aW5wdXRzLmxlbmd0aCA+IDQgPyBwYXJzZUZsb2F0KG15aW5wdXRzWzRdKSA6IDA7XG4gICAgICAgIHZhciBmaXhlZHNpZ25hdHVyZSA9IG15aW5wdXRzLmxlbmd0aCA+IDUgPyBteWlucHV0c1s1XSA9PT0gJ2YnIDogZmFsc2U7XG5cbiAgICAgICAgaWYgKGlzTmFOKGFkZGNvbnN0KSkge1xuICAgICAgICAgIGFkZGNvbnN0ID0gMDtcbiAgICAgICAgICBmaXhlZHNpZ25hdHVyZSA9IG15aW5wdXRzWzRdID09PSAnZic7XG4gICAgICAgIH0gLy9maXhlcyBidWcsIHNldHRpbmcgIGluc3RlYWQgb2YgTmFOLCB3aGVuIDR0aCBwYXJhbSBpcyBvbWl0ZWQgYW5kIGluc3RlYWQgJ2YnIG9yICd0JyBpcyBzcGVjaWZpZWRcblxuXG4gICAgICAgIHZhciBpbnB1dHJlZiA9IHtcbiAgICAgICAgICByZWY6IG15aW5wdXRzWzFdLFxuICAgICAgICAgIG51bWVyYXRvcjogbnVtZXJhdG9yLFxuICAgICAgICAgIGRlbm9taW5hdG9yOiBkZW5vbWluYXRvcixcbiAgICAgICAgICBhZGRjb25zdDogYWRkY29uc3QsXG4gICAgICAgICAgZml4ZWQ6IGZpeGVkc2lnbmF0dXJlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMuaW5wdXRyZWZlcmVuY2VzW215aW5wdXRzWzBdXSkge1xuICAgICAgICAgIHRoaXMuaW5wdXRyZWZlcmVuY2VzW215aW5wdXRzWzBdXS5maXhlZCA9IHRoaXMuaW5wdXRyZWZlcmVuY2VzW215aW5wdXRzWzBdXS5maXhlZCB8fCBmaXhlZHNpZ25hdHVyZTtcbiAgICAgICAgICB0aGlzLmlucHV0cmVmZXJlbmNlc1tteWlucHV0c1swXV0ucmVmcy5wdXNoKGlucHV0cmVmKTsgLy9maXJzdCBpcyBpZCBzZWNvbmQgaXMgcmVmZXJlbmNlXG4gICAgICAgIH0gZWxzZSB0aGlzLmlucHV0cmVmZXJlbmNlc1tteWlucHV0c1swXV0gPSB7XG4gICAgICAgICAgZml4ZWQ6IGZpeGVkc2lnbmF0dXJlLFxuICAgICAgICAgIHJlZnM6IFtpbnB1dHJlZl1cbiAgICAgICAgfTsgLy9maXJzdCBpcyBpZCBzZWNvbmQgaXMgcmVmZXJlbmNlXG4gICAgICAgIC8vcmVnaXN0ZXIgY2hhbmdlIGV2ZW50IC0gdGhlIGFsdGVyYXRpb24gaXMgY29tbWl0ZWRcblxuXG4gICAgICAgIHZhciBkZXBlbmRlbnRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15aW5wdXRzWzBdKTsgLy9ub3cgcmVnaXN0ZXIgJ2NoYW5nZScgZXZlbnQgb3IgZXZlbnRsaXN0ZW5cblxuICAgICAgICBpZiAoZGVwZW5kZW50RWwpIGRlcGVuZGVudEVsLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5ldmVudGxpc3RlbiwgdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZSk7ZWxzZSBjb25zb2xlLndhcm4oJ2Nhbm5vdCByZWdpc3RlciBjaGFuZ2VzIGZvciBub24tZXhpc3RpbmcgZWxlbWVudCBpZDonLCBteWlucHV0c1swXSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdyZWdpc3RlcmluZyBpbnB1dCwgcmVmLCBudW0sZGVuLGFkZCxmaXhlZCcsIG15aW5wdXRzWzBdLCBteWlucHV0c1sxXSwgbnVtZXJhdG9yLCBkZW5vbWluYXRvciwgYWRkY29uc3QsIGZpeGVkc2lnbmF0dXJlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vdGhlcmlucHV0cykge1xuICAgICAgdmFyIG90aGVyaW5wdXR0YXJnZXRzID0gdGhpcy5vdGhlcmlucHV0cy5zcGxpdCgnOycpO1xuXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvdGhlcmlucHV0dGFyZ2V0cyksIF9zdGVwMjsgIShfc3RlcDIgPSBfaXRlcmF0b3IyKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldCkuYWRkRXZlbnRMaXN0ZW5lcignZm1paW5wdXQnLCB0aGlzLmhhbmRsZURldGFpbENoYW5nZSk7XG4gICAgICB9XG4gICAgfSAvL1RPRE8gY2hlY2sgaWYgb25lc3RlcCAtIGRvIHN0ZXAgYWZ0ZXJcblxuICAgIC8qaWYgKHRoaXMuaXNPbmVzdGVwKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKCdvbmVzdGVwIHNjaGVkdWxpbmcgc3RhcnRldmVudCBpbiBwcm9taXNlKCkgdG8gZG8gc3RlcCgpJylcbiAgICAgIHNldFRpbWVvdXQodGhpcy5zZW5kU3RhcnRFdmVudC5iaW5kKHRoaXMpLDEwMDApO1xuICAgICAgY29uc29sZS5sb2coJ29uZXN0ZXAgc2NoZWR1bGluZyBwcm9taXNlKCkgdG8gZG8gc3RlcCgpJylcbiAgICAgIHNldFRpbWVvdXQodGhpcy5zdGVwLmJpbmQodGhpcyksMTUwMCk7XG4gICAgfSAqL1xuICAgIC8vZG8gc2ltdWxhdGlvbiBzdGVwIGFmdGVyIDEwMCBtc1xuXG4gIH07XG5cbiAgX3Byb3RvLmRlcmVnaXN0ZXJJbnB1dHMgPSBmdW5jdGlvbiBkZXJlZ2lzdGVySW5wdXRzKCkge1xuICAgIC8vZG8gcmVtb3ZlTGlzdGVuZXJzKClcbiAgICBpZiAodGhpcy5pbnB1dHMpIHtcbiAgICAgIHZhciBpbnB1dHBhcnRzID0gdGhpcy5pbnB1dHMuc3BsaXQoJzsnKTtcblxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoaW5wdXRwYXJ0cyksIF9zdGVwMzsgIShfc3RlcDMgPSBfaXRlcmF0b3IzKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBpbnB1dHBhcnQgPSBfc3RlcDMudmFsdWU7XG4gICAgICAgIHZhciBteWlucHV0cyA9IGlucHV0cGFydC5zcGxpdCgnLCcpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXlpbnB1dHNbMF0pLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5ldmVudGxpc3RlbiwgdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3RoZXJpbnB1dHMpIHtcbiAgICAgIHZhciBvdGhlcmlucHV0dGFyZ2V0cyA9IHRoaXMub3RoZXJpbnB1dHMuc3BsaXQoJzsnKTtcblxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2Uob3RoZXJpbnB1dHRhcmdldHMpLCBfc3RlcDQ7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNCgpKS5kb25lOykge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gX3N0ZXA0LnZhbHVlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0KS5yZW1vdmVFdmVudExpc3RlbmVyKCdmbWlpbnB1dCcsIHRoaXMuaGFuZGxlRGV0YWlsQ2hhbmdlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmF0dGFjaGVkID0gZnVuY3Rpb24gYXR0YWNoZWQoKSB7XG4gICAgY29uc29sZS5sb2coJ2ZtaSBhdHRhY2hlZCcpO1xuICAgIHRoaXMubXlkYXRhID0gWzAsIDBdOyAvL3NwbGl0IHJlZmVyZW5jZXMgYnkgLFxuXG4gICAgdGhpcy5yZWZlcmVuY2VzID0gdGhpcy52YWx1ZXJlZmVyZW5jZXMuc3BsaXQoJywnKTtcbiAgICB0aGlzLnJlZ2lzdGVySW5wdXRzKCk7IC8vaWYgc3JjIGlzIG5vdCBzcGVjaWZpZWQgLSB0aGVuIGV4cGVjdHMgdGhhdCBmbWkgc2NyaXB0cyBpcyBsb2FkZWQgaW4gSFRNTCBwYWdlIHByaW9yIHRodXMgc2hvdWxkIGJlIGF2YWlsYWJsZVxuXG4gICAgaWYgKHRoaXMuc3JjICYmIHRoaXMuc3JjLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCdsb2FkaW5nIHNjcmlwdCBmaXJzdCwgdGhlbiBpbml0IGZtaScpOyAvL2tlZXAgJ3RoaXMnIHJlZmVyZW5jZSBpbiBnbG9iYWwgZm9yIGNhbGxiYWNrXG5cbiAgICAgIHdpbmRvdy50aGlzZm1pID0gdGhpcztcbiAgICAgIHRoaXMuZ2V0U2NyaXB0KHRoaXMuc3JjLCB0aGlzLmluaXRmbWkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL3NyYyBpcyBzcGVjaWZpZWQsIHRodXMgbG9hZCBpdCAtIGJyb3dzZXIgbG9hZHMgaXQgYXQgdGhlIGVuZCwgdGh1cyBhZGRpbmcgdGhlIHJlc3QgYXMgY2FsbGJhY2sgYWZ0ZXIgbG9hZGVkXG4gICAgICBjb25zb2xlLmxvZygnaW5pdCBmbWkgd2l0aG91dCBsb2FkaW5nIHNjcmlwdDogZm1pbmFtZSwgdGhpczonLCB0aGlzLmZtaW5hbWUsIHRoaXMpO1xuICAgICAgdGhpcy5pbml0Zm1pKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29udHJvbGlkKSB7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmNvbnRyb2xpZCkuYWRkRXZlbnRMaXN0ZW5lcignZm1pc3RhcnQnLCB0aGlzLmhhbmRsZVN0YXJ0KTtcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuY29udHJvbGlkKS5hZGRFdmVudExpc3RlbmVyKCdmbWlzdG9wJywgdGhpcy5oYW5kbGVTdG9wKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMuc2hvd2NvbnRyb2xzID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5zaG93Y29udHJvbHMgPSB0aGlzLnNob3djb250cm9scyA9PT0gJ3RydWUnO1xuICAgIH1cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZtaXJlZ2lzdGVyJywgdGhpcy5oYW5kbGVSZWdpc3Rlcik7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZG9zdGVwJywgdGhpcy5oYW5kbGVTdGVwKTsgLy9zZW5kaW5nIGF0dGFjaGVkIGV2ZW50IC0gc29tZSBtYXkgZGV0ZWN0IGl0IHRvIHJlZ2lzdGVyIGl0J3Mgb3V0cHUgbGlzdGVuZXIgaWYgYXR0YWNoZWQgYmVmb3JlXG5cbiAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2ZtaWF0dGFjaGVkJyk7XG4gICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH0gLy9kZXRlY3RzIHdoZXRoZXIgc2NyaXB0IHdpdGggRk1VIGlzIGFscmVhZHkgbG9hZGVkLCBpZiBub3QgaXQgYWRkcyBpdCB0byBET00gYW5kIGxvYWRzXG4gIC8vZ2V0IHNjcmlwdCBlbGVtZW50IGFuZCByZWdpc3RlcnMgJ29ubG9hZCcgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIHNjcmlwdCBpcyBsb2FkZWRcbiAgO1xuXG4gIF9wcm90by5nZXRTY3JpcHQgPSBmdW5jdGlvbiBnZXRTY3JpcHQoc291cmNlLCBjYWxsYmFjaykge1xuICAgIC8vY2hlY2sgd2hldGhlciB0aGUgc2NyaXB0IGlzIG5vdCBhbHJlYWR5IHRoZXJlXG4gICAgaWYgKEFycmF5LmZyb20oZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpKS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmdldEF0dHJpYnV0ZSgnc3JjJykgPT09IHNvdXJjZTtcbiAgICB9KS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZygnZm1pLmdldFNjcmlwdCgpIFdBUk5JTkcsIHNjcmlwdCBpcyBhbHJlYWR5IGFkZGVkIGludG8gRE9NOicsIHNvdXJjZSk7IC8vZG8gY2FsbGJhY2s/XG5cbiAgICAgIGlmIChjYWxsYmFjaykgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gICAgICByZXR1cm47XG4gICAgfSAvL2NvbnNvbGUubG9nKCdmbWkgZ2V0c2NyaXB0KCknKTtcblxuXG4gICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHZhciBwcmlvciA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgICBzY3JpcHQuYXN5bmMgPSAxO1xuXG4gICAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNjcmlwdC5yZWFkeVN0YXRlIHx8IC9sb2FkZWR8Y29tcGxldGUvLnRlc3Qoc2NyaXB0LnJlYWR5U3RhdGUpKSB7XG4gICAgICAgIHNjcmlwdC5vbmVycm9yID0gc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICBzY3JpcHQgPSB1bmRlZmluZWQ7IC8vIHRyeSB0byBpbnNlcnQgc2NyaXB0IGJ5IG90aGVyIGFwcCBmb3IgcHJldmlld2luZyAtIHNjcmlwdHMgbWlnaHQgYmUgaW5zZXJ0ZWQgaW50byBET01cblxuICAgICAgICBpZiAod2luZG93LmVkaXRvcmFwaSAmJiB0eXBlb2Ygd2luZG93LmVkaXRvcmFwaS5pbnNlcnRTY3JpcHRCeUlkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ2luc2VydGluZyBzY3JpcHQgYnkgdGhpcmRwYXJ0eSBhcGknKTtcbiAgICAgICAgICB3aW5kb3cuZWRpdG9yYXBpLmluc2VydFNjcmlwdEJ5SWQoc291cmNlLCAnZm1pb2JqJyk7XG4gICAgICAgIH0gLy9kbyBjYWxsYmFjayBldmVuIGlmIGlzQWJvcnQgLSBzY3JpcHRzIG1pZ2h0IGJlIGluc2VydGVkIGludG8gRE9NIGJ5IGFub3RoZXIgYXBwXG5cblxuICAgICAgICBpZiAoY2FsbGJhY2spIHNldFRpbWVvdXQoY2FsbGJhY2ssIDEyMDApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIChfLCBpc0Fib3J0KSB7XG4gICAgICBpZiAoaXNBYm9ydCB8fCAhc2NyaXB0LnJlYWR5U3RhdGUgfHwgL2xvYWRlZHxjb21wbGV0ZS8udGVzdChzY3JpcHQucmVhZHlTdGF0ZSkpIHtcbiAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIHNjcmlwdCA9IHVuZGVmaW5lZDsgLy9kbyBjYWxsYmFjayAtIHNjcmlwdHMgbWlnaHQgYmUgaW5zZXJ0ZWQgaW50byBET00gYnkgYW5vdGhlciBhcHBcblxuICAgICAgICBpZiAoIWlzQWJvcnQgJiYgY2FsbGJhY2spIHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzY3JpcHQuc3JjID0gd2luZG93LmJkbEJhc2VIcmVmID8gd2luZG93LmJkbEJhc2VIcmVmICsgc291cmNlIDogc291cmNlO1xuICAgIHByaW9yLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgcHJpb3IpO1xuICB9IC8vbWFrZSBpbnN0IG9iamVjdCBnbG9iYWxseSAtIGluIGNhc2Ugb2YgZ2xvYmFscyAobm9uLXNyYykgZGVjbGFyYXRpb25cbiAgO1xuXG4gIF9wcm90by5pbml0Zm1pID0gZnVuY3Rpb24gaW5pdGZtaSgpIHtcbiAgICBjb25zb2xlLmxvZygnZm1pIGluaXRmbWkoKScpO1xuICAgIHZhciB0aGF0ID0ge307XG5cbiAgICBpZiAod2luZG93LnRoaXNmbWkpIHtcbiAgICAgIHRoYXQuZm1pbmFtZSA9IHdpbmRvdy50aGlzZm1pLmZtaW5hbWU7XG4gICAgICBjb25zb2xlLmxvZygndXNpbmcgZ2xvYmFsIGZtaSBpbml0Zm1pKCkgZm1pbmFtZScsIHRoYXQuZm1pbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuZm1pbmFtZSA9IHRoaXMuZm1pbmFtZTtcbiAgICAgIGNvbnNvbGUubG9nKCd1c2luZyBsb2NhbCBmbWkgaW5pdGZtaSgpIGZtaW5hbWUnLCB0aGF0LmZtaW5hbWUpO1xuICAgIH0gLy9jcmVhdGUgaW5zdGFuY2VcblxuXG4gICAgdmFyIG15aW5zdCA9IHdpbmRvd1t0aGF0LmZtaW5hbWVdKCk7IC8vRU1TREsgdiAzLnggY29tcGlsZXMgZm11IHRvIFByb21pc2UgYmFzZWQgYXBpXG5cbiAgICBpZiAobXlpbnN0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgbXlpbnN0LnRoZW4oZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgdGhhdC5pbnN0ID0gaW5zdDtcblxuICAgICAgICBpZiAoIXdpbmRvdy5mbWlpbnN0KSB7XG4gICAgICAgICAgd2luZG93LmZtaWluc3QgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdpbmRvdy5mbWlpbnN0W3RoYXQuZm1pbmFtZV0gPSB0aGF0OyAvL2NvbnNvbGUubG9nKCdmbWkgY2FsbGJhY2sgZnJvbSBQcm9taXNlIHRoYXQnLCB0aGF0LCB0aGF0Lmluc3QpO1xuICAgICAgICAvL2RvIG9uZSBzdGVwIGlmIG1vZGUgaXMgb25lc3RlcFxuICAgICAgICAvL2h0dHBzOi8vbmV3YmVkZXYuY29tL3Bhc3MtY29ycmVjdC10aGlzLWNvbnRleHQtdG8tc2V0dGltZW91dC1jYWxsYmFja1xuICAgICAgICAvL1RPRE8gY2hlY2sgaWYgdGhpcyBzdGVwL3Nob3QgaXMgbmVlZGVkXG5cbiAgICAgICAgaWYgKHdpbmRvdy50aGlzZm1pLmlzT25lc3RlcCkge1xuICAgICAgICAgIC8vY29uc29sZS5sb2coJ29uZXN0ZXAgc2NoZWR1bGluZyBzdGFydGV2ZW50IGluIHByb21pc2UoKSB0byBkbyBzdGVwKCknKVxuICAgICAgICAgIHNldFRpbWVvdXQod2luZG93LnRoaXNmbWkuc2VuZFN0YXJ0RXZlbnQuYmluZCh3aW5kb3cudGhpc2ZtaSksIDEwMDApO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdvbmVzdGVwIHNjaGVkdWxpbmcgcHJvbWlzZSgpIHRvIGRvIHN0ZXAoKScpO1xuICAgICAgICAgIHNldFRpbWVvdXQod2luZG93LnRoaXNmbWkuc3RlcC5iaW5kKHdpbmRvdy50aGlzZm1pKSwgMTUwMCk7XG4gICAgICAgIH0gLy9kbyBzaW11bGF0aW9uIHN0ZXAgYWZ0ZXIgMTAwIG1zXG5cblxuICAgICAgICBpZiAod2luZG93LnRoaXNmbWkuaXNPbmVzaG90KSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZygnb25lc2hvdCBzY2hlZHVsaW5nIHN0YXJ0ZXZlbnQgaW4gcHJvbWlzZSgpIHRvIGRvIHN0ZXAoKScpXG4gICAgICAgICAgc2V0VGltZW91dCh3aW5kb3cudGhpc2ZtaS5zZW5kU3RhcnRFdmVudC5iaW5kKHdpbmRvdy50aGlzZm1pKSwgMTAwMCk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ29uZXNob3Qgc2NoZWR1bGluZyBwcm9taXNlKCkgdG8gZG8gc2hvdCgpJyk7XG4gICAgICAgICAgc2V0VGltZW91dCh3aW5kb3cudGhpc2ZtaS5zaG90LmJpbmQod2luZG93LnRoaXNmbWkpLCAxNTAwKTtcbiAgICAgICAgfSAvL2RvIHNpbXVsYXRpb24gc3RlcCBhZnRlciAxMDAgbXNcblxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vb2xkZXIgRU1TREsgcHJpb3IgMy54IGNvbXBpbGVzIGRpcmVjdGx5IHRvIGFwaSwga2VlcCBjb21wYXRpYmlsaXR5XG4gICAgICB0aGF0Lmluc3QgPSBteWluc3Q7XG5cbiAgICAgIGlmICghd2luZG93LmZtaWluc3QpIHtcbiAgICAgICAgd2luZG93LmZtaWluc3QgPSBbXTtcbiAgICAgIH1cblxuICAgICAgd2luZG93LmZtaWluc3RbdGhhdC5mbWluYW1lXSA9IHRoYXQ7IC8vY29uc29sZS5sb2coJ2ZtaSBjYWxsYmFjayB0aGF0LCB0aGF0Lmluc3QnLCB0aGF0LCB0aGF0Lmluc3QpO1xuICAgICAgLy9kbyBvbmUgc3RlcCBpZiBtb2RlIGlzIG9uZXN0ZXBcbiAgICAgIC8vaHR0cHM6Ly9uZXdiZWRldi5jb20vcGFzcy1jb3JyZWN0LXRoaXMtY29udGV4dC10by1zZXR0aW1lb3V0LWNhbGxiYWNrXG5cbiAgICAgIGlmICh3aW5kb3cudGhpc2ZtaS5pc09uZXN0ZXApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ29uZXN0ZXAgc2NoZWR1bGluZyBkaXJlY3Qobm9wcm9taXNlKSB0byBkbyBzdGVwKCknKTtcbiAgICAgICAgc2V0VGltZW91dCh3aW5kb3cudGhpc2ZtaS5zZW5kU3RhcnRFdmVudC5iaW5kKHdpbmRvdy50aGlzZm1pKSwgMTAwMCk7XG4gICAgICAgIHNldFRpbWVvdXQod2luZG93LnRoaXNmbWkuc3RlcC5iaW5kKHdpbmRvdy50aGlzZm1pKSwgMTUwMCk7XG4gICAgICB9IC8vZG8gc2ltdWxhdGlvbiBzdGVwIGFmdGVyIDEwMCBtc1xuXG5cbiAgICAgIGlmICh3aW5kb3cudGhpc2ZtaS5pc09uZXNob3QpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ29uZXNob3Qgc2NoZWR1bGluZyBkaXJlY3Qobm9wcm9taXNlKSB0byBkbyBzdGVwKCknKTtcbiAgICAgICAgc2V0VGltZW91dCh3aW5kb3cudGhpc2ZtaS5zZW5kU3RhcnRFdmVudC5iaW5kKHdpbmRvdy50aGlzZm1pKSwgMTAwMCk7XG4gICAgICAgIHNldFRpbWVvdXQod2luZG93LnRoaXNmbWkuc2hvdC5iaW5kKHdpbmRvdy50aGlzZm1pKSwgMTUwMCk7XG4gICAgICB9IC8vZG8gc2ltdWxhdGlvbiBzdGVwIGFmdGVyIDEwMCBtc1xuXG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5iaW5kID0gZnVuY3Rpb24gYmluZCgpIHtcbiAgICB0aGlzLmlzT25lc2hvdCA9IHRoaXMubW9kZSA9PT0gJ29uZXNob3QnO1xuICAgIHRoaXMuaXNPbmVzdGVwID0gdGhpcy5tb2RlID09PSAnb25lc3RlcCc7XG5cbiAgICBpZiAodGhpcy5pc09uZXN0ZXApIHtcbiAgICAgIHRoaXMuc2hvd2NvbnRyb2xzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNPbmVzaG90KSB7XG4gICAgICB0aGlzLnNob3djb250cm9scyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5zdG9wdGltZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuc3RvcHRpbWUgPSBwYXJzZUZsb2F0KHRoaXMuc3RvcHRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5zdGFydHRpbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnN0YXJ0dGltZSA9IHBhcnNlRmxvYXQodGhpcy5zdGFydHRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5zdGVwc3BlcmZyYW1lZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuc3RlcHNwZXJmcmFtZSA9IHBhcnNlSW50KHRoaXMuc3RlcHNwZXJmcmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5kZXRhY2hlZCA9IGZ1bmN0aW9uIGRldGFjaGVkKCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZtaXJlZ2lzdGVyJywgdGhpcy5oYW5kbGVSZWdpc3Rlcik7XG5cbiAgICBpZiAodGhpcy5hbmltYXRpb25zdGFydGVkKSB7XG4gICAgICB0aGlzLnN0YXJ0c3RvcCgpO1xuICAgIH1cblxuICAgIHRoaXMuZGVyZWdpc3RlcklucHV0cygpO1xuXG4gICAgaWYgKHRoaXMuY29udHJvbGlkKSB7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmNvbnRyb2xpZCkucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm1pc3RhcnQnLCB0aGlzLmhhbmRsZVN0YXJ0KTtcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuY29udHJvbGlkKS5yZW1vdmVFdmVudExpc3RlbmVyKCdmbWlzdG9wJywgdGhpcy5oYW5kbGVTdG9wKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgYSBydWRpbWVudGFyeSBicm93c2VyIGNvbnNvbGUgbG9nZ2VyIGZvciB0aGUgRk1VLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jb25zb2xlTG9nZ2VyID0gZnVuY3Rpb24gY29uc29sZUxvZ2dlcihjb21wb25lbnRFbnZpcm9ubWVudCwgaW5zdGFuY2VOYW1lLCBzdGF0dXMsIGNhdGVnb3J5LCBtZXNzYWdlLCBvdGhlcikge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgLyogRmlsbHMgdmFyaWFibGVzIGludG8gbWVzc2FnZSByZXR1cm5lZCBieSB0aGUgRk1VLCB0aGUgQyB3YXkgKi9cbiAgICB2YXIgZm9ybWF0TWVzc2FnZSA9IGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2UobWVzc2FnZTEsIG90aGVyMSkge1xuICAgICAgLy8gZ2V0IGEgbmV3IHBvaW50ZXJcbiAgICAgIHZhciBwdHIgPSBfdGhpczIuaW5zdC5fbWFsbG9jKDEpOyAvLyBnZXQgdGhlIHNpemUgb2YgdGhlIHJlc3VsdGluZyBmb3JtYXRlZCBtZXNzYWdlXG5cblxuICAgICAgdmFyIG51bSA9IF90aGlzMi5pbnN0Ll9zbnByaW50ZihwdHIsIDAsIG1lc3NhZ2UxLCBvdGhlcjEpO1xuXG4gICAgICBfdGhpczIuaW5zdC5fZnJlZShwdHIpO1xuXG4gICAgICBudW0rKzsgLy8gVE9ETzogRXJyb3IgaGFuZGxpbmcgbnVtIDwgMFxuXG4gICAgICBwdHIgPSBfdGhpczIuaW5zdC5fbWFsbG9jKG51bSk7XG5cbiAgICAgIF90aGlzMi5pbnN0Ll9zbnByaW50ZihwdHIsIG51bSwgbWVzc2FnZTEsIG90aGVyMSk7IC8vIHJldHVybiBwb2ludGVyIHRvIHRoZSByZXN1bHRpbmcgbWVzc2FnZSBzdHJpbmdcblxuXG4gICAgICByZXR1cm4gcHRyO1xuICAgIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG5cblxuICAgIGNvbnNvbGUubG9nKCdGTVUoJyArIHRoaXMuaW5zdC5VVEY4VG9TdHJpbmcoaW5zdGFuY2VOYW1lKSArICc6JyArIHN0YXR1cyArICc6JyArIHRoaXMuaW5zdC5VVEY4VG9TdHJpbmcoY2F0ZWdvcnkpICsgJykgbXNnOiAnICsgdGhpcy5pbnN0LlVURjhUb1N0cmluZyhmb3JtYXRNZXNzYWdlKG1lc3NhZ2UsIG90aGVyKSkpO1xuXG4gICAgdGhpcy5pbnN0Ll9mcmVlKGZvcm1hdE1lc3NhZ2UpO1xuICB9O1xuXG4gIF9wcm90by5pbml0aWFsaXplID0gZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICBjb25zb2xlLmxvZygnZm1pIGluaXRpYWxpemUoKScpO1xuICAgIHRoaXMuZm1pRW50ZXJJbml0KHRoaXMuZm1paW5zdCk7XG4gICAgdGhpcy5mbWlFeGl0SW5pdCh0aGlzLmZtaWluc3QpO1xuICB9O1xuXG4gIF9wcm90by5pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uIGluc3RhbnRpYXRlKCkge1xuICAgIGNvbnNvbGUubG9nKCdmbWkgaW5zdGFudGlhdGUoKScpOyAvL2ZpcnN0IGRlZmluZSBGTUkgQVBJIGZ1bmN0aW9uIG5hbWVzO1xuXG4gICAgdmFyIHNSZXNldCA9ICdmbWkyUmVzZXQnO1xuICAgIHZhciBzSW5zdGFudGlhdGUgPSAnZm1pMkluc3RhbnRpYXRlJztcbiAgICB2YXIgc1NldHVwID0gJ2ZtaTJTZXR1cEV4cGVyaW1lbnQnO1xuICAgIHZhciBzRW50ZXJpbml0ID0gJ2ZtaTJFbnRlckluaXRpYWxpemF0aW9uTW9kZSc7XG4gICAgdmFyIHNFeGl0aW5pdCA9ICdmbWkyRXhpdEluaXRpYWxpemF0aW9uTW9kZSc7XG4gICAgdmFyIHNTZXRyZWFsID0gJ2ZtaTJTZXRSZWFsJztcbiAgICB2YXIgc1NldGJvb2xlYW4gPSAnZm1pMlNldEJvb2xlYW4nO1xuICAgIHZhciBzR2V0cmVhbCA9ICdmbWkyR2V0UmVhbCc7XG4gICAgdmFyIHNHZXRib29sZWFuID0gJ2ZtaTJHZXRCb29sZWFuJztcbiAgICB2YXIgc0Rvc3RlcCA9ICdmbWkyRG9TdGVwJztcbiAgICB2YXIgc0NyZWF0ZUNhbGxiYWNrID0gJ2NyZWF0ZUZtaTJDYWxsYmFja0Z1bmN0aW9ucyc7XG4gICAgdGhpcy5zdGVwVGltZSA9IDA7XG4gICAgdGhpcy5zdGVwU2l6ZSA9IHR5cGVvZiB0aGlzLmZzdGVwc2l6ZSA9PT0gJ3N0cmluZycgPyBwYXJzZUZsb2F0KHRoaXMuZnN0ZXBzaXplKSA6IHRoaXMuZnN0ZXBzaXplO1xuICAgIHRoaXMubXlzdGVwID0gdGhpcy5zdGVwU2l6ZTsgLy9jb25zb2xlIGNhbGxiYWNrIHB0ciwgcGVyIGVtc3JpcHRlbiBjcmVhdGUgaW50IHB0ciB3aXRoIHNpZ25hdHVyZSB2aWlpaWlpXG5cbiAgICBpZiAod2luZG93LmZtaWluc3QgJiYgd2luZG93LmZtaWluc3RbdGhpcy5mbWluYW1lXSkgdGhpcy5pbnN0ID0gd2luZG93LmZtaWluc3RbdGhpcy5mbWluYW1lXS5pbnN0O2Vsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdmbWkgaW5zdGFudGlhdGUoKSBlcnJvciBpbml0Zm1pKCkgcHJvYmFibHkgbm90IGNhbGxlZCcpO1xuICAgIH0gLy9lbHNlIHRoaXMuaW5zdCA9IG51bGw7Ly9pZiAod2luZG93LnRoaXNmbWkpIHt0aGlzLmluc3QgPSB3aW5kb3cudGhpc2ZtaS5pbnN0O31cblxuICAgIGNvbnNvbGUubG9nKCdpbnN0YW50aWF0ZSgpIHRoaXMuaW5zdCcsIHRoaXMuaW5zdCk7IC8vc2V0IHRoZSBmbWluYW1lIGFuZCBKUyBXQVNNIGZ1bmN0aW9uIHJlZmVyZW5jZXNcblxuICAgIHZhciBzZXBhcmF0b3IgPSAnXyc7XG4gICAgdmFyIHByZWZpeCA9IHRoaXMuZm1pbmFtZTsgLy9jb25zb2xlLmxvZygnYXR0YWNoZWQgZm1pbmFtZTonLCB0aGF0LmZtaW5hbWUpO1xuICAgIC8vIE9wZW5Nb2RlbGljYSBleHBvcnRzIGZ1bmN0aW9uIG5hbWVzIHdpdGhvdXQgcHJlZml4XG5cbiAgICBpZiAodHlwZW9mIHRoaXMuaW5zdC5fZm1pMkdldFZlcnNpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByZWZpeCA9ICcnO1xuICAgICAgc2VwYXJhdG9yID0gJyc7XG4gICAgfSAvL25vdyB1c2UgYSAnY3dyYXAnIGRlbGl2ZXJlZCBieSBlbXNjcmlwdGVuIHRvIGZhY2lsaXRhdGUgY2FsbGluZyBDIGZ1bmN0aW9ucyB3aXRoIEMgcHJpbWl0aXZlcyAoc3RyaW5nLG51bWJlcikgZnJvbSBKYXZhc2NyaXB0XG5cblxuICAgIHRoaXMuZm1pQ3JlYXRlQ2FsbGJhY2sgPSB0aGlzLmluc3QuY3dyYXAoc0NyZWF0ZUNhbGxiYWNrLCAnbnVtYmVyJywgWydudW1iZXInXSk7XG4gICAgdGhpcy5mbWlSZXNldCA9IHRoaXMuaW5zdC5jd3JhcChwcmVmaXggKyBzZXBhcmF0b3IgKyBzUmVzZXQsICdudW1iZXInLCBbJ251bWJlciddKTtcbiAgICB0aGlzLmZtaUluc3RhbnRpYXRlID0gdGhpcy5pbnN0LmN3cmFwKHByZWZpeCArIHNlcGFyYXRvciArIHNJbnN0YW50aWF0ZSwgJ251bWJlcicsIFsnc3RyaW5nJywgJ251bWJlcicsICdzdHJpbmcnLCAnc3RyaW5nJywgJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJ10pO1xuICAgIHRoaXMuZm1pU2V0dXAgPSB0aGlzLmluc3QuY3dyYXAocHJlZml4ICsgc2VwYXJhdG9yICsgc1NldHVwLCAnbnVtYmVyJywgWydudW1iZXInLCAnbnVtYmVyJywgJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJywgJ251bWJlciddKTtcbiAgICB0aGlzLmZtaUVudGVySW5pdCA9IHRoaXMuaW5zdC5jd3JhcChwcmVmaXggKyBzZXBhcmF0b3IgKyBzRW50ZXJpbml0LCAnbnVtYmVyJywgWydudW1iZXInXSk7XG4gICAgdGhpcy5mbWlFeGl0SW5pdCA9IHRoaXMuaW5zdC5jd3JhcChwcmVmaXggKyBzZXBhcmF0b3IgKyBzRXhpdGluaXQsICdudW1iZXInLCBbJ251bWJlciddKTtcbiAgICB0aGlzLmZtaVNldFJlYWwgPSB0aGlzLmluc3QuY3dyYXAocHJlZml4ICsgc2VwYXJhdG9yICsgc1NldHJlYWwsICdudW1iZXInLCBbJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJywgJ251bWJlciddKTtcbiAgICB0aGlzLmZtaUdldFJlYWwgPSB0aGlzLmluc3QuY3dyYXAocHJlZml4ICsgc2VwYXJhdG9yICsgc0dldHJlYWwsICdudW1iZXInLCBbJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJywgJ251bWJlciddKTtcbiAgICB0aGlzLmZtaVNldEJvb2xlYW4gPSB0aGlzLmluc3QuY3dyYXAocHJlZml4ICsgc2VwYXJhdG9yICsgc1NldGJvb2xlYW4sICdudW1iZXInLCBbJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJywgJ251bWJlciddKTtcbiAgICB0aGlzLmZtaUdldEJvb2xlYW4gPSB0aGlzLmluc3QuY3dyYXAocHJlZml4ICsgc2VwYXJhdG9yICsgc0dldGJvb2xlYW4sICdudW1iZXInLCBbJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJywgJ251bWJlciddKTtcbiAgICB0aGlzLmZtaURvU3RlcCA9IHRoaXMuaW5zdC5jd3JhcChwcmVmaXggKyBzZXBhcmF0b3IgKyBzRG9zdGVwLCAnbnVtYmVyJywgWydudW1iZXInLCAnbnVtYmVyJywgJ251bWJlcicsICdudW1iZXInXSk7XG4gICAgdGhpcy5mbWlHZXRWZXJzaW9uID0gdGhpcy5pbnN0LmN3cmFwKHByZWZpeCArIHNlcGFyYXRvciArICdmbWkyR2V0VmVyc2lvbicsICdzdHJpbmcnKTtcbiAgICB0aGlzLmZtaUdldFR5cGVzUGxhdGZvcm0gPSB0aGlzLmluc3QuY3dyYXAocHJlZml4ICsgc2VwYXJhdG9yICsgJ2ZtaTJHZXRUeXBlc1BsYXRmb3JtJywgJ3N0cmluZycpO1xuICAgIHRoaXMuZm1pMkZyZWVJbnN0YW5jZSA9IHRoaXMuaW5zdC5jd3JhcChwcmVmaXggKyBzZXBhcmF0b3IgKyAnZm1pMkZyZWVJbnN0YW5jZScsICdudW1iZXInLCBbJ251bWJlciddKTtcbiAgICB0aGlzLmluc3RhbnRpYXRlZCA9IGZhbHNlOyAvL2NhbGN1bGF0ZSBwb3csIHBvd2VyIG9mIHN0ZXBzaXplXG5cbiAgICB0aGlzLnBvdyA9IHRoaXMuc3RlcFNpemUgPCAxID8gLU1hdGguY2VpbCgtTWF0aC5sb2cxMCh0aGlzLnN0ZXBTaXplKSkgOiBNYXRoLmNlaWwoTWF0aC5sb2cxMCh0aGlzLnN0ZXBTaXplKSk7IC8vdXNlIE1hdGgudHJ1bmMgPz9cbiAgICAvL2NvbnNvbGUubG9nKCdpbnN0YW50aWF0ZSgpIHRoaXMnLCB0aGlzKTtcblxuICAgIHRoaXMuY29uc29sZUxvZ2dlclB0ciA9IHRoaXMuaW5zdC5hZGRGdW5jdGlvbih0aGlzLmNvbnNvbGVMb2dnZXIuYmluZCh0aGlzKSwgJ3ZpaWlpaWknKTtcbiAgICB0aGlzLmNhbGxiYWNrcHRyID0gdGhpcy5mbWlDcmVhdGVDYWxsYmFjayh0aGlzLmNvbnNvbGVMb2dnZXJQdHIpOyAvL2NvbnNvbGUubG9nKCdmbWluYW1lJyx0aGlzLmZtaW5hbWUpO1xuICAgIC8vY29uc29sZS5sb2coJ2d1aWQnLHRoaXMuZ3VpZCk7XG4gICAgLy9jb25zb2xlLmxvZygnY2FsbGJhY2twdHInLHRoaXMuY2FsbGJhY2twdHIpO1xuICAgIC8vY29uc29sZS5sb2coJ2ZtaWluc3RhbnRpYXRlIGZuYzonLHRoaXMuZm1pSW5zdGFudGlhdGUpO1xuICAgIC8vY3JlYXRlIGluc3RhbmNlIG9mIG1vZGVsIHNpbXVsYXRpb25cblxuICAgIHRoaXMuZm1paW5zdCA9IHRoaXMuZm1pSW5zdGFudGlhdGUodGhpcy5mbWluYW1lLCB0aGlzLmNvc2ltdWxhdGlvbiwgdGhpcy5ndWlkLCAnJywgdGhpcy5jYWxsYmFja3B0ciwgMCwgMCk7IC8vbGFzdCAxIGRlYnVnLCAwIG5vZGVidWdcblxuICAgIHRoaXMuc2V0dXBFeHBlcmltZW50KCk7XG4gIH07XG5cbiAgX3Byb3RvLnNldHVwRXhwZXJpbWVudCA9IGZ1bmN0aW9uIHNldHVwRXhwZXJpbWVudCgpIHtcbiAgICAvL3NldHVwIGV4cGVyaW1lbnRcbiAgICB0aGlzLmZtaVNldHVwKHRoaXMuZm1paW5zdCwgMSwgdGhpcy50b2xlcmFuY2UsIHRoaXMuc3RhcnR0aW1lLCAwKTtcbiAgICBjb25zb2xlLmxvZygnc2V0dXBFeHBlcmltZW50KCkgZm1paW5zdCcsIHRoaXMuZm1paW5zdCk7XG4gICAgdGhpcy5pbnN0YW50aWF0ZWQgPSB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5zaW11bGF0ZSA9IGZ1bmN0aW9uIHNpbXVsYXRlKCkge307XG5cbiAgX3Byb3RvLnNldFJlYWwgPSBmdW5jdGlvbiBzZXRSZWFsKHF1ZXJ5LCB2YWx1ZSwgY291bnQpIHtcbiAgICBjb25zb2xlLmxvZygnc2V0cmVhbCBxdWVyeSx2YWx1ZSxjb3VudCcsIHF1ZXJ5LCB2YWx1ZSwgY291bnQpO1xuICAgIHJldHVybiB0aGlzLmZtaVNldFJlYWwodGhpcy5mbWlpbnN0LCBxdWVyeS5ieXRlT2Zmc2V0LCBjb3VudCwgdmFsdWUuYnl0ZU9mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLnNldEJvb2xlYW4gPSBmdW5jdGlvbiBzZXRCb29sZWFuKHF1ZXJ5LCB2YWx1ZSwgY291bnQpIHtcbiAgICByZXR1cm4gdGhpcy5mbWlTZXRCb29sZWFuKHRoaXMuZm1paW5zdCwgcXVlcnkuYnl0ZU9mZnNldCwgY291bnQsIHZhbHVlLmJ5dGVPZmZzZXQpO1xuICB9XG4gIC8qKlxuICAgKiBMb2FkcyBSZWFscyBmcm9tIEZNVVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRSZWFsID0gZnVuY3Rpb24gZ2V0UmVhbChxdWVyeSwgb3V0cHV0LCBjb3VudCkge1xuICAgIHJldHVybiB0aGlzLmZtaUdldFJlYWwodGhpcy5mbWlpbnN0LCBxdWVyeS5ieXRlT2Zmc2V0LCBjb3VudCwgb3V0cHV0LmJ5dGVPZmZzZXQpO1xuICB9XG4gIC8qKlxuICAgKiBMb2FkcyBCb29sZWFucyBmcm9tIEZNVVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRCb29sZWFuID0gZnVuY3Rpb24gZ2V0Qm9vbGVhbihxdWVyeSwgb3V0cHV0LCBjb3VudCkge1xuICAgIHJldHVybiB0aGlzLmZtaUdldEJvb2xlYW4odGhpcy5mbWlpbnN0LCBxdWVyeS5ieXRlT2Zmc2V0LCBjb3VudCwgb3V0cHV0LmJ5dGVPZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5zdGFydGV2ZW50ID0gZnVuY3Rpb24gc3RhcnRldmVudChlKSB7XG4gICAgY29uc29sZS5sb2coJ2ZtaSBzdGFydGV2ZW50IHJlY2lldmVkJywgZSk7XG4gICAgaWYgKCF0aGlzLmFuaW1hdGlvbnN0YXJ0ZWQpIHRoaXMuc3RhcnRTaW11bGF0aW9uKCk7XG4gIH07XG5cbiAgX3Byb3RvLnN0b3BldmVudCA9IGZ1bmN0aW9uIHN0b3BldmVudChlKSB7XG4gICAgY29uc29sZS5sb2coJ2ZtaSBzdG9wZXZlbnQgcmVjaWV2ZWQnLCBlKTtcbiAgICBpZiAodGhpcy5hbmltYXRpb25zdGFydGVkKSB0aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gIH0gLy9hY3Rpb24gdG8gYmUgcGVyZm9ybWVkIHdoZW4gY2xpY2tpbmcgdGhlIHBsYXkvcGF1c2UgYnV0dG9uXG4gIC8vc2VuZHMgZm1pc3RhcnQvZm1pc3RvcCBldmVudCBhbmQgc3RhcnRzL3N0b3BzIHNpbXVsYXRpb25cbiAgO1xuXG4gIF9wcm90by5zdGFydHN0b3AgPSBmdW5jdGlvbiBzdGFydHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uc3RhcnRlZCkge1xuICAgICAgdGhpcy5zdG9wU2ltdWxhdGlvbigpO1xuICAgICAgdGhpcy5zZW5kU3RvcEV2ZW50KCk7XG4gICAgICB0aGlzLnBlcmZlbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wZXJmc3RhcnQoKTtcbiAgICAgIHRoaXMuc2VuZFN0YXJ0RXZlbnQoKTtcbiAgICAgIHRoaXMuc3RhcnRTaW11bGF0aW9uKCk7XG4gICAgfVxuICB9IC8vZGVmaW5lcyBhY3Rpb24gdG8gYmUgZG9uZSBkdXJpbmcgYnJvd3NlciBhbmltYXRpb25mcmFtZSBhbmQgc3RhcnRzXG4gIDtcblxuICBfcHJvdG8uc3RhcnRTaW11bGF0aW9uID0gZnVuY3Rpb24gc3RhcnRTaW11bGF0aW9uKCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdGhpcy5hbmltYXRpb25zdGFydGVkID0gdHJ1ZTtcbiAgICB0aGlzLmZwc0ludGVydmFsID0gMTAwMCAvIChpc05hTih0aGlzLmZwc2xpbWl0KSA/IHBhcnNlSW50KHRoaXMuZnBzbGltaXQsIDEwKSA6IHRoaXMuZnBzbGltaXQpO1xuICAgIHRoaXMudGhlbiA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcblxuICAgIHZhciBwZXJmb3JtQW5pbWF0aW9uID0gZnVuY3Rpb24gcGVyZm9ybUFuaW1hdGlvbihuZXd0aW1lKSB7XG4gICAgICBpZiAoIV90aGlzMy5hbmltYXRpb25zdGFydGVkKSByZXR1cm47XG4gICAgICBfdGhpczMucmVxdWVzdCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShwZXJmb3JtQW5pbWF0aW9uKTtcblxuICAgICAgaWYgKF90aGlzMy5mcHNsaW1pdCAmJiBfdGhpczMuZnBzbGltaXQgPCA2MCkge1xuICAgICAgICBpZiAoaXNOYU4oX3RoaXMzLmZwc2xpbWl0KSkgX3RoaXMzLmZwc2xpbWl0ID0gcGFyc2VJbnQoX3RoaXMzLmZwc2xpbWl0LCAxMCk7XG4gICAgICAgIF90aGlzMy5ub3cgPSBuZXd0aW1lOyAvL2NvbnNvbGUubG9nKCdsaW1pdGluZyBmcHMgdG8gZnBzbGltaXQsIG5ld3RpbWUsIG5vdywgdGhlbiwgZnBzaW50ZXJ2YWwnLCB0aGlzLmZwc2xpbWl0LCBuZXd0aW1lLCB0aGlzLm5vdywgdGhpcy50aGVuLCB0aGlzLmZwc0ludGVydmFsKTtcblxuICAgICAgICBfdGhpczMuZWxhcHNlZCA9IF90aGlzMy5ub3cgLSBfdGhpczMudGhlbjsgLy9jb25zb2xlLmxvZygnZWxhcHNlZCxmcHNpbnRlcnZhbCcsIHRoaXMuZWxhcHNlZCwgdGhpcy5mcHNJbnRlcnZhbCk7XG5cbiAgICAgICAgaWYgKF90aGlzMy5lbGFwc2VkID4gX3RoaXMzLmZwc0ludGVydmFsKSB7XG4gICAgICAgICAgX3RoaXMzLnRoZW4gPSBfdGhpczMubm93IC0gX3RoaXMzLmVsYXBzZWQgJSBfdGhpczMuZnBzSW50ZXJ2YWw7XG5cbiAgICAgICAgICBfdGhpczMuc3RlcCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzMy5zdGVwc3BlcmZyYW1lOyBpKyspIHtcbiAgICAgICAgICBfdGhpczMuc3RlcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHBlcmZvcm1BbmltYXRpb24oKTtcbiAgfSAvL2NhbmNlbHMgYWxsIGFjdGlvbiB0byBiZSBkb25lIGR1cmluZyBicm93c2VyIGFuaW1hdGlvbmZyYW1lIGFuZCBzdGFydHNcbiAgO1xuXG4gIF9wcm90by5zdG9wU2ltdWxhdGlvbiA9IGZ1bmN0aW9uIHN0b3BTaW11bGF0aW9uKCkge1xuICAgIC8vc3RvcCBhbmltYXRpb25cbiAgICB0aGlzLmFuaW1hdGlvbnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJlcXVlc3QpO1xuICB9IC8vc2VuZHMgZm1pc3RvcCBldmVudFxuICA7XG5cbiAgX3Byb3RvLnNlbmRTdG9wRXZlbnQgPSBmdW5jdGlvbiBzZW5kU3RvcEV2ZW50KCkge1xuICAgIC8vY3JlYXRlIGN1c3RvbSBldmVudFxuICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnZm1pc3RvcCcsIHtcbiAgICAgIGRldGFpbDoge1xuICAgICAgICB0aW1lOiB0aGlzLnJvdW5kKHRoaXMuc3RlcFRpbWUsIHRoaXMucG93KVxuICAgICAgfVxuICAgIH0pOyAvL2Rpc3BhdGNoIGV2ZW50IC0gaXQgc2hvdWxkIGJlIGxpc3RlbmVkIGJ5IHNvbWUgb3RoZXIgY29tcG9uZW50XG5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfTtcblxuICBfcHJvdG8uc2VuZFN0YXJ0RXZlbnQgPSBmdW5jdGlvbiBzZW5kU3RhcnRFdmVudCgpIHtcbiAgICAvL2NyZWF0ZSBjdXN0b20gZXZlbnRcbiAgICBjb25zb2xlLmxvZygnZm1pLnNlbmRTdGFydEV2ZW50KCkuIFNlbmRpbmcgc3RhcnQgZXZlbnQgZm9yIGFkb2Jlb2JqJyk7XG4gICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmbWlzdGFydCcsIHtcbiAgICAgIGRldGFpbDoge1xuICAgICAgICB0aW1lOiB0aGlzLnJvdW5kKHRoaXMuc3RlcFRpbWUsIHRoaXMucG93KVxuICAgICAgfVxuICAgIH0pOyAvL2Rpc3BhdGNoIGV2ZW50IC0gaXQgc2hvdWxkIGJlIGxpc3RlbmVkIGJ5IHNvbWUgb3RoZXIgY29tcG9uZW50XG5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKS5kaXNwYXRjaEV2ZW50KGV2ZW50KTsgLy9hbmltYXRlIHVzaW5nIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICB9O1xuXG4gIF9wcm90by5yb3VuZCA9IGZ1bmN0aW9uIHJvdW5kKHZhbHVlLCBkZWNpbWFscykge1xuICAgIGlmIChkZWNpbWFscyA8IDApIHtcbiAgICAgIHZhciBwb3NkZWNpbWFscyA9IC1kZWNpbWFscztcbiAgICAgIHJldHVybiBOdW1iZXIoTWF0aC5yb3VuZCh2YWx1ZSArICdlJyArIHBvc2RlY2ltYWxzKSArICdlLScgKyBwb3NkZWNpbWFscyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE51bWJlcihNYXRoLnJvdW5kKHZhbHVlICsgJ2UtJyArIGRlY2ltYWxzKSArICdlKycgKyBkZWNpbWFscyk7XG4gIH07XG5cbiAgX3Byb3RvLnN0ZXAgPSBmdW5jdGlvbiBzdGVwKCkge1xuICAgIC8vdGhpcyA9IHdpbmRvdy50aGlzZm1pO1xuICAgIC8vcHJpbWl0aXZlIHNlbWFwaG9yZSwgb25seSBvbmUgaW5zdGFuY2UgY2FuIHBlcmZvcm0gdGhpcyBjYWxsXG4gICAgaWYgKCF0aGlzLmRvaW5nc3RlcCkge1xuICAgICAgY29uc29sZS5sb2coJ2ZtdSBzdGVwKCknKTtcbiAgICAgIHRoaXMuZG9pbmdzdGVwID0gdHJ1ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCF0aGlzLmluc3RhbnRpYXRlZCkge1xuICAgICAgICAgIHRoaXMuaW5zdGFudGlhdGUoKTtcbiAgICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RlcGkrKzsgLy9jaGFuZ2VpbnB1dHNcblxuICAgICAgICBpZiAodGhpcy5yZXNldEJlZm9yZUNoYW5nZSkge1xuICAgICAgICAgIC8vZm1pIGNhbGxcbiAgICAgICAgICB0aGlzLnNldHVwRXhwZXJpbWVudCgpOyAvL2RvIHJlc2V0XG5cbiAgICAgICAgICB0aGlzLmZtaVJlc2V0KHRoaXMuZm1paW5zdCk7IC8vc2V0dGluZyBmaXhlZCBwYXJhbWV0ZXJzIGFyZSBub3cgYWxsb3dlZFxuXG4gICAgICAgICAgdGhpcy5zZXRJbnB1dFZhcmlhYmxlcygpOyAvL2luaXRpYWxpemVcblxuICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpOyAvL21ha2UgYmlnIHN0ZXAgZnJvbSAwIHRvIGN1cnJlbnQgc3RlcFRpbWUgPz8/XG4gICAgICAgICAgLy9jb25zdCByZXMgPVxuICAgICAgICAgIC8vbWFrZSBiaWcgc3RlcCBvbmx5IGlmIGl0IGlzIG5vdCBvbmVzdGVwXG5cbiAgICAgICAgICBpZiAoIXRoaXMuaXNPbmVzdGVwKSB0aGlzLmZtaURvU3RlcCh0aGlzLmZtaWluc3QsIHRoaXMuc3RhcnR0aW1lLCB0aGlzLnN0ZXBUaW1lLCAxKTtlbHNlIHRoaXMuc3RlcFRpbWUgPSB0aGlzLnN0YXJ0dGltZTsgLy9yZXNldCB0aGUgc2lnbmF0dXJlXG5cbiAgICAgICAgICB0aGlzLnJlc2V0QmVmb3JlQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9kbyBvbmx5IGNoYW5nZSBvZiB2YXJpYWJsZXNcbiAgICAgICAgICB0aGlzLnNldElucHV0VmFyaWFibGVzKCk7XG4gICAgICAgIH0gLy9kb3N0ZXBcbiAgICAgICAgLy9jb21wdXRlIHN0ZXAgdG8gcm91bmQgdGhlIGRlc2lyZWQgdGltZVxuXG5cbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuZm1pRG9TdGVwKHRoaXMuZm1paW5zdCwgdGhpcy5zdGVwVGltZSwgdGhpcy5teXN0ZXAsIDEpO1xuICAgICAgICB0aGlzLnN0ZXBUaW1lID0gdGhpcy5zdGVwVGltZSArIHRoaXMubXlzdGVwO1xuICAgICAgICB0aGlzLm15c3RlcCA9IHRoaXMuc3RlcFNpemU7IC8vdXBkYXRlIGNvcnJlY3Rpb24gc3RlcCB0byBjdXJyZW50IHN0ZXBcblxuICAgICAgICBpZiAocmVzID09PSAxIHx8IHJlcyA9PT0gMikge1xuICAgICAgICAgIGNvbnNvbGUud2Fybignc3RlcCgpIHJldHVybmVkIHN0YXRlPD4wLCBkb2luZyByZXNldCgpJywgcmVzKTtcbiAgICAgICAgICB0aGlzLmZtaVJlc2V0KHRoaXMuZm1paW5zdCk7XG4gICAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIH0gLy9kaXN0cmlidXRlIHNpbXVsYXRpb24gZGF0YSB0byBsaXN0ZW5lcnNcblxuXG4gICAgICAgIHRoaXMubXlkYXRhID0gdGhpcy5nZXRSZWFscyh0aGlzLnJlZmVyZW5jZXMpOyAvL2NyZWF0ZSBjdXN0b20gZXZlbnRcblxuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2ZtaWRhdGEnLCB7XG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICB0aW1lOiB0aGlzLnJvdW5kKHRoaXMuc3RlcFRpbWUsIHRoaXMucG93KSxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMubXlkYXRhXG4gICAgICAgICAgfVxuICAgICAgICB9KTsgLy9kaXNwYXRjaCBldmVudCAtIGl0IHNob3VsZCBiZSBsaXN0ZW5lZCBieSBzb21lIG90aGVyIGNvbXBvbmVudFxuXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpLmRpc3BhdGNoRXZlbnQoZXZlbnQpOyAvL2NvbXB1dGUgc2hvd3RpbWVcblxuICAgICAgICBpZiAodGhpcy5zaG93dGltZSkgdGhpcy5zaW11bGF0aW9udGltZSA9IHRoaXMuc2Vjb25kc1RvVGltZSh0aGlzLnN0ZXBUaW1lLCB0aGlzLnNob3d0aW1lbXVsdGlwbHkpOyAvL2RvIGNvbXB1dGF0aW9uIG9ubHkgZXZlcnkgdGlja3N0b3VwZGF0ZSB0aWNrXG5cbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZWZwcykge1xuICAgICAgICAgIGlmICh0aGlzLmZwc3RpY2sgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRmcHN0aW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZnBzdGljaysrO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZnBzdGljayA+PSB0aGlzLnRpY2tzVG9VcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZnBzSW50ZXJ2YWwgPSAxMDAwIC8gKGlzTmFOKHRoaXMuZnBzbGltaXQpID8gcGFyc2VJbnQodGhpcy5mcHNsaW1pdCwgMTApIDogdGhpcy5mcHNsaW1pdCk7IC8vdXBkYXRlIHRpY2tzIC0gc28gaXQgd2lsbCBiZSBldmVyeSAzIHNlY29uZHNcblxuICAgICAgICAgICAgdGhpcy50aWNrc1RvVXBkYXRlID0gTWF0aC5yb3VuZCgzMDAwIC8gdGhpcy5mcHNJbnRlcnZhbCk7IC8vZG8gY29ycmVjdGlvbiBzdGVwIGNhbGN1bGF0aW9uXG5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0ZXBTaXplIDwgMSkge1xuICAgICAgICAgICAgICB0aGlzLnBvdyA9IC1NYXRoLmNlaWwoLU1hdGgubG9nMTAodGhpcy5zdGVwU2l6ZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5wb3cgPSBNYXRoLmNlaWwoTWF0aC5sb2cxMCh0aGlzLnN0ZXBTaXplKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubXlzdGVwID0gdGhpcy5yb3VuZCh0aGlzLnN0ZXBUaW1lICsgdGhpcy5zdGVwU2l6ZSwgdGhpcy5wb3cpIC0gdGhpcy5zdGVwVGltZTsgLy9kbyBmcHMgY2FsY3VsYXRpb25cblxuICAgICAgICAgICAgdGhpcy5mcHMgPSAoMTAwMCAqIHRoaXMudGlja3NUb1VwZGF0ZSAvICh3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLnN0YXJ0ZnBzdGltZSkpLnRvUHJlY2lzaW9uKDQpO1xuICAgICAgICAgICAgdGhpcy5mcHN0aWNrID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy9zdG9wIHNpbXVsYXRpb24gd2hlbiBzdG9wdGltZSBpcyBkZWZpbmVkIGFuZCByZWFjaGVkXG5cblxuICAgICAgICBpZiAodGhpcy5zdG9wdGltZSA+IDAgJiYgdGhpcy5hbmltYXRpb25zdGFydGVkICYmIHRoaXMuc3RvcHRpbWUgPCB0aGlzLnN0ZXBUaW1lKSB7XG4gICAgICAgICAgdGhpcy5zdGFydHN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2Vycm9yIGNhdGNoZWQgZHVyaW5nIGZtdSBzdGVwJywgZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuZG9pbmdzdGVwID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5zaG90ID0gZnVuY3Rpb24gc2hvdCgpIHtcbiAgICAvL2NoZWNrIHdoZXRoZXIgaW5pdGlhbGl6ZWQgYW5kIGluc3RhbnRpYXRlZFxuICAgIGlmICghdGhpcy5pbnN0KSB7XG4gICAgICAvL25vdCBpbnN0YW50aWF0ZWRcbiAgICAgIGlmICh3aW5kb3cuZm1paW5zdCAmJiB3aW5kb3cuZm1paW5zdFt0aGlzLmZtaW5hbWVdKSB7XG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vbm8gaW5pdGZtaSgpIGNhbGxlZCA9IHdhaXQgZm9yIHNjcmlwdCB0byBiZSBsb2FkZWQsIGRvIG5vdGhpbmdcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc2V0KCk7IC8vdGhpcy5zZXRJbnB1dFZhcmlhYmxlcygpO1xuICAgIH0gLy8gZG8gc3RlcHMgZnJvbSBzdGFydHRpbWUgdG8gc3RvcHRpbWVcblxuXG4gICAgZG8ge1xuICAgICAgdGhpcy5zdGVwKCk7XG4gICAgfSB3aGlsZSAodGhpcy5zdG9wdGltZSA+IHRoaXMuc3RlcFRpbWUpO1xuICB9O1xuXG4gIF9wcm90by5zZXRJbnB1dFZhcmlhYmxlcyA9IGZ1bmN0aW9uIHNldElucHV0VmFyaWFibGVzKCkge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNoYW5nZWlucHV0cykge1xuICAgICAgdmFyIG15aW5wdXRzID0gdGhpcy5jaGFuZ2VpbnB1dHNba2V5XTsgLy9jb25zb2xlLmxvZygnY2hhbmdpbmcgaW5wdXRzJywgbXlpbnB1dHMpO1xuICAgICAgLy9zZXQgcmVhbCAtIHJlZmVyZW5jZSBpcyBpbiAtIG9uZSBpbnB1dCBvbmUgcmVmZXJlbmNlXG4gICAgICAvL3NldHMgaW5kaXZpZHVhbCB2YWx1ZXMgLSBpZiBpZCBpcyBpbiBpbnB1dCwgdGhlbiByZWZlcmVuY2UgaXMgdGFrZW4gZnJvbSBpbnB1dHMgZGVmaW5pdGlvblxuXG4gICAgICBjb25zb2xlLmxvZygnY2hhbmdpbmcgaW5wdXRzLGlkLHZhbHVlJywgdGhpcy5pbnB1dHJlZmVyZW5jZXMsIG15aW5wdXRzLmlkLCBteWlucHV0cy52YWx1ZSk7XG5cbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRoaXMuaW5wdXRyZWZlcmVuY2VzW215aW5wdXRzLmlkXS5yZWZzKSwgX3N0ZXA1OyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUoKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGlyZWYgPSBfc3RlcDUudmFsdWU7XG4gICAgICAgIHZhciBub3JtYWxpemVkdmFsdWUgPSBteWlucHV0cy52YWx1ZSAqIGlyZWYubnVtZXJhdG9yIC8gaXJlZi5kZW5vbWluYXRvciArIGlyZWYuYWRkY29uc3Q7XG4gICAgICAgIGlmIChteWlucHV0cy5pZCkgdGhpcy5zZXRTaW5nbGVSZWFsKGlyZWYucmVmLCBub3JtYWxpemVkdmFsdWUpOyAvLyBpZiByZWZlcmVuY2UgaXMgaW4gaW5wdXQsIHRoZW4gaXQgaXMgc2V0IGRpcmVjdGx5XG4gICAgICAgIGVsc2UgaWYgKG15aW5wdXRzLnZhbHVlcmVmZXJlbmNlKSB0aGlzLnNldFNpbmdsZVJlYWwobXlpbnB1dHMudmFsdWVyZWZlcmVuY2UsIG5vcm1hbGl6ZWR2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mbHVzaFJlYWxRdWV1ZSgpO1xuICAgIHRoaXMuY2hhbmdlaW5wdXRzID0ge307XG4gICAgLyppZiAodGhpcy5jaGFuZ2VpbnB1dHMubGVuZ3RoID4gMCkge1xuICAgICAgd2hpbGUgKHRoaXMuY2hhbmdlaW5wdXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IG15aW5wdXRzID0gdGhpcy5jaGFuZ2VpbnB1dHMuc2hpZnQoKTsgLy9yZW1vdmUgZmlyc3QgaXRlbVxuICAgICAgICAvL2NvbnNvbGUubG9nKCdjaGFuZ2luZyBpbnB1dHMnLCBteWlucHV0cyk7XG4gICAgICAgIC8vc2V0IHJlYWwgLSByZWZlcmVuY2UgaXMgaW4gLSBvbmUgaW5wdXQgb25lIHJlZmVyZW5jZVxuICAgICAgICAvL3NldHMgaW5kaXZpZHVhbCB2YWx1ZXMgLSBpZiBpZCBpcyBpbiBpbnB1dCwgdGhlbiByZWZlcmVuY2UgaXMgdGFrZW4gZnJvbSBpbnB1dHMgZGVmaW5pdGlvblxuICAgICAgICBjb25zb2xlLmxvZygnY2hhbmdpbmcgaW5wdXRzLGlkLHZhbHVlJywgdGhpcy5pbnB1dHJlZmVyZW5jZXMsIG15aW5wdXRzLmlkLCBteWlucHV0cy52YWx1ZSk7XG4gICAgICAgIGZvciAobGV0IGlyZWYgb2YgdGhpcy5pbnB1dHJlZmVyZW5jZXNbbXlpbnB1dHMuaWRdLnJlZnMpIHtcbiAgICAgICAgICBsZXQgbm9ybWFsaXplZHZhbHVlID0gbXlpbnB1dHMudmFsdWUgKiBpcmVmLm51bWVyYXRvciAvIGlyZWYuZGVub21pbmF0b3IgKyBpcmVmLmFkZGNvbnN0O1xuICAgICAgICAgIGlmIChteWlucHV0cy5pZCkgdGhpcy5zZXRTaW5nbGVSZWFsKGlyZWYucmVmLCBub3JtYWxpemVkdmFsdWUpO1xuICAgICAgICAgIC8vIGlmIHJlZmVyZW5jZSBpcyBpbiBpbnB1dCwgdGhlbiBpdCBpcyBzZXQgZGlyZWN0bHlcbiAgICAgICAgICBlbHNlIGlmIChteWlucHV0cy52YWx1ZXJlZmVyZW5jZSkgdGhpcy5zZXRTaW5nbGVSZWFsKG15aW5wdXRzLnZhbHVlcmVmZXJlbmNlLCBub3JtYWxpemVkdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL2ZsdXNoIGFsbCBpbiBvbmUgY2FsbCB0byBmbWlcbiAgICAgIHRoaXMuZmx1c2hSZWFsUXVldWUoKTtcbiAgICB9Ki9cbiAgfTtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBjb25zb2xlLmxvZygnZG9pbmcgcmVzZXQoKScpO1xuICAgIHRoaXMuc3RlcFRpbWUgPSB0aGlzLnN0YXJ0dGltZTtcbiAgICB0aGlzLnN0ZXBTaXplID0gdHlwZW9mIHRoaXMuZnN0ZXBzaXplID09PSAnc3RyaW5nJyA/IHBhcnNlRmxvYXQodGhpcy5mc3RlcHNpemUpIDogdGhpcy5mc3RlcHNpemU7XG4gICAgdGhpcy5teXN0ZXAgPSB0aGlzLnN0ZXBTaXplO1xuICAgIHRoaXMuc2V0dXBFeHBlcmltZW50KCk7XG4gICAgdGhpcy5mbWlSZXNldCh0aGlzLmZtaWluc3QpOyAvL3NldCBpbnB1dCB2YXJpYWJsZXMgZm9yIHBvc3NpYmxlIGNoYW5nZSBvZiBub24tdHVuYWJsZSAtIGZpeGVkIHBhcmFtZXRlciB2YWx1ZXNcblxuICAgIHRoaXMuc2V0SW5wdXRWYXJpYWJsZXMoKTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTsgLy9jcmVhdGUgY3VzdG9tIGV2ZW50XG5cbiAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2ZtaXJlc2V0Jyk7IC8vZGlzcGF0Y2ggZXZlbnQgLSBpdCBzaG91bGQgYmUgbGlzdGVuZWQgYnkgc29tZSBvdGhlciBjb21wb25lbnRcblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9O1xuXG4gIF9wcm90by5zb2Z0cmVzZXQgPSBmdW5jdGlvbiBzb2Z0cmVzZXQoKSB7XG4gICAgdGhpcy5zdGVwVGltZSA9IHRoaXMuc3RhcnR0aW1lO1xuICAgIHRoaXMuc3RlcFNpemUgPSB0eXBlb2YgdGhpcy5mc3RlcHNpemUgPT09ICdzdHJpbmcnID8gcGFyc2VGbG9hdCh0aGlzLmZzdGVwc2l6ZSkgOiB0aGlzLmZzdGVwc2l6ZTtcbiAgICB0aGlzLm15c3RlcCA9IHRoaXMuc3RlcFNpemU7IC8vdGhpcy5zZXR1cEV4cGVyaW1lbnQoKTtcbiAgICAvL3RoaXMuZm1pUmVzZXQodGhpcy5mbWlpbnN0KTtcbiAgICAvL3NldCBpbnB1dCB2YXJpYWJsZXMgZm9yIHBvc3NpYmxlIGNoYW5nZSBvZiBub24tdHVuYWJsZSAtIGZpeGVkIHBhcmFtZXRlciB2YWx1ZXNcblxuICAgIHRoaXMuc2V0SW5wdXRWYXJpYWJsZXMoKTsgLy90aGlzLmluaXRpYWxpemUoKTtcbiAgICAvL2NyZWF0ZSBjdXN0b20gZXZlbnRcblxuICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnZm1pcmVzZXQnKTsgLy9kaXNwYXRjaCBldmVudCAtIGl0IHNob3VsZCBiZSBsaXN0ZW5lZCBieSBzb21lIG90aGVyIGNvbXBvbmVudFxuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCkuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cbiAgLyogcm91dGluZXMgdG8gYWxsb2MgYnVmZmVyIGZvciBnZXR0aW5nL3NldHRpbmcgZnJvbSBmbWkqL1xuICA7XG5cbiAgX3Byb3RvLmNyZWF0ZUJ1ZmZlciA9IGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlcihhcnIpIHtcbiAgICB2YXIgc2l6ZSA9IGFyci5sZW5ndGggKiBhcnIuQllURVNfUEVSX0VMRU1FTlQ7XG5cbiAgICB2YXIgcHRyID0gdGhpcy5pbnN0Ll9tYWxsb2Moc2l6ZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcHRyOiBwdHIsXG4gICAgICBzaXplOiBzaXplXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uY3JlYXRlQW5kRmlsbEJ1ZmZlciA9IGZ1bmN0aW9uIGNyZWF0ZUFuZEZpbGxCdWZmZXIoYXJyKSB7XG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMuY3JlYXRlQnVmZmVyKGFycik7XG4gICAgdGhpcy5maWxsQnVmZmVyKGJ1ZmZlciwgYXJyKTtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9O1xuXG4gIF9wcm90by5mcmVlQnVmZmVyID0gZnVuY3Rpb24gZnJlZUJ1ZmZlcihidWZmZXIpIHtcbiAgICBpZiAoYnVmZmVyLnB0ciAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5pbnN0Ll9mcmVlKGJ1ZmZlci5wdHIpO1xuICAgIH1cblxuICAgIGJ1ZmZlci5wdHIgPSBudWxsO1xuICAgIGJ1ZmZlci5zaXplID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8udmlld0J1ZmZlciA9IGZ1bmN0aW9uIHZpZXdCdWZmZXIoYnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuaW5zdC5IRUFQVTguYnVmZmVyLCBidWZmZXIucHRyLCBidWZmZXIuc2l6ZSk7XG4gIH07XG5cbiAgX3Byb3RvLmZpbGxCdWZmZXIgPSBmdW5jdGlvbiBmaWxsQnVmZmVyKGJ1ZmZlciwgYXJyKSB7XG4gICAgdmFyIHZpZXcgPSB0aGlzLnZpZXdCdWZmZXIoYnVmZmVyKTtcbiAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShhcnIuYnVmZmVyKSk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfTtcblxuICBfcHJvdG8uZ2V0UmVhbHMgPSBmdW5jdGlvbiBnZXRSZWFscyhyZWZlcmVuY2VzKSB7XG4gICAgdmFyIHF1ZXJ5QnVmZmVyID0gdGhpcy5jcmVhdGVBbmRGaWxsQnVmZmVyKG5ldyBJbnQzMkFycmF5KHJlZmVyZW5jZXMpKTtcbiAgICB2YXIgcXVlcnkgPSB0aGlzLnZpZXdCdWZmZXIocXVlcnlCdWZmZXIpO1xuICAgIHZhciBvdXRwdXRCdWZmZXIgPSB0aGlzLmNyZWF0ZUJ1ZmZlcihuZXcgRmxvYXQ2NEFycmF5KHJlZmVyZW5jZXMubGVuZ3RoKSk7XG4gICAgdmFyIG91dHB1dCA9IHRoaXMudmlld0J1ZmZlcihvdXRwdXRCdWZmZXIpO1xuICAgIHRoaXMuZ2V0UmVhbChxdWVyeSwgb3V0cHV0LCByZWZlcmVuY2VzLmxlbmd0aCk7XG4gICAgdmFyIHJlYWwgPSBuZXcgRmxvYXQ2NEFycmF5KG91dHB1dC5idWZmZXIsIG91dHB1dC5ieXRlT2Zmc2V0LCByZWZlcmVuY2VzLmxlbmd0aCk7XG4gICAgdGhpcy5mcmVlQnVmZmVyKHF1ZXJ5QnVmZmVyKTtcbiAgICB0aGlzLmZyZWVCdWZmZXIob3V0cHV0QnVmZmVyKTtcbiAgICByZXR1cm4gcmVhbDtcbiAgfTtcblxuICBfcHJvdG8uZ2V0U2luZ2xlUmVhbCA9IGZ1bmN0aW9uIGdldFNpbmdsZVJlYWwocmVmZXJlbmNlKSB7XG4gICAgdmFyIHF1ZXJ5QnVmZmVyID0gdGhpcy5jcmVhdGVBbmRGaWxsQnVmZmVyKG5ldyBJbnQzMkFycmF5KFtyZWZlcmVuY2VdKSk7XG4gICAgdmFyIHF1ZXJ5ID0gdGhpcy52aWV3QnVmZmVyKHF1ZXJ5QnVmZmVyKTtcbiAgICB2YXIgb3V0cHV0QnVmZmVyID0gdGhpcy5jcmVhdGVCdWZmZXIobmV3IEZsb2F0NjRBcnJheSgxKSk7XG4gICAgdmFyIG91dHB1dCA9IHRoaXMudmlld0J1ZmZlcihvdXRwdXRCdWZmZXIpO1xuICAgIHRoaXMuZ2V0UmVhbChxdWVyeSwgb3V0cHV0LCAxKTtcbiAgICB2YXIgcmVhbCA9IG5ldyBGbG9hdDY0QXJyYXkob3V0cHV0LmJ1ZmZlciwgb3V0cHV0LmJ5dGVPZmZzZXQsIDEpO1xuICAgIHRoaXMuZnJlZUJ1ZmZlcihxdWVyeUJ1ZmZlcik7XG4gICAgdGhpcy5mcmVlQnVmZmVyKG91dHB1dEJ1ZmZlcik7XG4gICAgcmV0dXJuIHJlYWxbMF07XG4gIH1cbiAgLyoqXG4gICAgICogQWRkcyBhIHJlYWwgdmFsdWUgdG8gc2V0UmVhbFF1ZXVlXG4gICAgICovXG4gIDtcblxuICBfcHJvdG8uc2V0U2luZ2xlUmVhbCA9IGZ1bmN0aW9uIHNldFNpbmdsZVJlYWwocmVmZXJlbmNlLCB2YWx1ZSkge1xuICAgIGNvbnNvbGUubG9nKCdzZXRTaW5nbGVSZWFsIHJlZmVyZW5jZSx2YWx1ZScsIHJlZmVyZW5jZSwgdmFsdWUpO1xuXG4gICAgaWYgKCF0aGlzLnNldFJlYWxRdWV1ZSkge1xuICAgICAgdGhpcy5zZXRSZWFsUXVldWUgPSB7XG4gICAgICAgIHJlZmVyZW5jZXM6IFtdLFxuICAgICAgICB2YWx1ZXM6IFtdXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuc2V0UmVhbFF1ZXVlLnJlZmVyZW5jZXMucHVzaChyZWZlcmVuY2UpO1xuICAgIHRoaXMuc2V0UmVhbFF1ZXVlLnZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgfTtcblxuICBfcHJvdG8uZmx1c2hSZWFsUXVldWUgPSBmdW5jdGlvbiBmbHVzaFJlYWxRdWV1ZSgpIHtcbiAgICBpZiAodGhpcy5zZXRSZWFsUXVldWUpIHtcbiAgICAgIHZhciByZWZlcmVuY2VCdWZmZXIgPSB0aGlzLmNyZWF0ZUFuZEZpbGxCdWZmZXIobmV3IEludDMyQXJyYXkodGhpcy5zZXRSZWFsUXVldWUucmVmZXJlbmNlcykpO1xuICAgICAgdmFyIHJlZmVyZW5jZXMgPSB0aGlzLnZpZXdCdWZmZXIocmVmZXJlbmNlQnVmZmVyKTtcbiAgICAgIHZhciB2YWx1ZUJ1ZmZlciA9IHRoaXMuY3JlYXRlQW5kRmlsbEJ1ZmZlcihuZXcgRmxvYXQ2NEFycmF5KHRoaXMuc2V0UmVhbFF1ZXVlLnZhbHVlcykpO1xuICAgICAgdmFyIHZhbHVlcyA9IHRoaXMudmlld0J1ZmZlcih2YWx1ZUJ1ZmZlcik7XG4gICAgICB0aGlzLnNldFJlYWwocmVmZXJlbmNlcywgdmFsdWVzLCB0aGlzLnNldFJlYWxRdWV1ZS5yZWZlcmVuY2VzLmxlbmd0aCk7XG4gICAgICB0aGlzLmZyZWVCdWZmZXIocmVmZXJlbmNlQnVmZmVyKTtcbiAgICAgIHRoaXMuZnJlZUJ1ZmZlcih2YWx1ZUJ1ZmZlcik7XG4gICAgICB0aGlzLnNldFJlYWxRdWV1ZSA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZmx1c2hCb29sZWFuUXVldWUgPSBmdW5jdGlvbiBmbHVzaEJvb2xlYW5RdWV1ZSgpIHtcbiAgICBpZiAodGhpcy5zZXRCb29sZWFuUXVldWUpIHtcbiAgICAgIHZhciByZWZlcmVuY2VCdWZmZXIgPSB0aGlzLmNyZWF0ZUFuZEZpbGxCdWZmZXIobmV3IEludDMyQXJyYXkodGhpcy5zZXRCb29sZWFuUXVldWUucmVmZXJlbmNlcykpO1xuICAgICAgdmFyIHJlZmVyZW5jZXMgPSB0aGlzLnZpZXdCdWZmZXIocmVmZXJlbmNlQnVmZmVyKTtcbiAgICAgIHZhciB2YWx1ZUJ1ZmZlciA9IHRoaXMuY3JlYXRlQW5kRmlsbEJ1ZmZlcihuZXcgSW50MzJBcnJheSh0aGlzLnNldEJvb2xlYW5RdWV1ZS52YWx1ZXMpKTtcbiAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLnZpZXdCdWZmZXIodmFsdWVCdWZmZXIpO1xuICAgICAgdGhpcy5zZXRCb29sZWFuKHJlZmVyZW5jZXMsIHZhbHVlcywgdGhpcy5zZXRCb29sZWFuUXVldWUucmVmZXJlbmNlcy5sZW5ndGgpO1xuICAgICAgdGhpcy5mcmVlQnVmZmVyKHJlZmVyZW5jZUJ1ZmZlcik7XG4gICAgICB0aGlzLmZyZWVCdWZmZXIodmFsdWVCdWZmZXIpO1xuICAgICAgdGhpcy5zZXRCb29sZWFuUXVldWUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAgICovXG4gIDtcblxuICBfcHJvdG8uc2V0U2luZ2xlQm9vbGVhbiA9IGZ1bmN0aW9uIHNldFNpbmdsZUJvb2xlYW4ocmVmZXJlbmNlLCB2YWx1ZSkge1xuICAgIGlmICghdGhpcy5zZXRCb29sZWFuUXVldWUpIHtcbiAgICAgIHRoaXMuc2V0Qm9vbGVhblF1ZXVlID0ge1xuICAgICAgICByZWZlcmVuY2VzOiBbXSxcbiAgICAgICAgdmFsdWVzOiBbXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEJvb2xlYW5RdWV1ZS5yZWZlcmVuY2VzLnB1c2gocmVmZXJlbmNlKTtcbiAgICB0aGlzLnNldEJvb2xlYW5RdWV1ZS52YWx1ZXMucHVzaCh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAgICogTG9hZHMgYSBzaW5nbGUgYm9vbGVhbiB2YWx1ZSBiYXNlZCBvbiByZWZlcmVuY2UsIHRoaXMgaXMgYSBzaG9ydGhhbmQgZnVuY3Rpb24uXG4gICAgICogSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIE1vZHVsZS5nZXRCb29sZWFuIHdpdGggcmV1c2FibGUgbWFsbG9jcy5cbiAgICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRTaW5nbGVCb29sZWFuID0gZnVuY3Rpb24gZ2V0U2luZ2xlQm9vbGVhbihyZWZlcmVuY2UpIHtcbiAgICB2YXIgcXVlcnlCdWZmZXIgPSB0aGlzLmNyZWF0ZUFuZEZpbGxCdWZmZXIobmV3IEludDMyQXJyYXkoW3JlZmVyZW5jZV0pKTtcbiAgICB2YXIgcXVlcnkgPSB0aGlzLnZpZXdCdWZmZXIocXVlcnlCdWZmZXIpO1xuICAgIHZhciBvdXRwdXRCdWZmZXIgPSB0aGlzLmNyZWF0ZUJ1ZmZlcihuZXcgSW50MzJBcnJheSgxKSk7XG4gICAgdmFyIG91dHB1dCA9IHRoaXMudmlld0J1ZmZlcihvdXRwdXRCdWZmZXIpO1xuICAgIHRoaXMuZ2V0Qm9vbGVhbihxdWVyeSwgb3V0cHV0LCAxKTtcbiAgICB2YXIgYm9vbCA9IG5ldyBJbnQzMkFycmF5KG91dHB1dC5idWZmZXIsIG91dHB1dC5ieXRlT2Zmc2V0LCAxKTtcbiAgICB0aGlzLmZyZWVCdWZmZXIocXVlcnlCdWZmZXIpO1xuICAgIHRoaXMuZnJlZUJ1ZmZlcihvdXRwdXRCdWZmZXIpO1xuICAgIHJldHVybiBib29sWzBdO1xuICB9O1xuXG4gIF9wcm90by5nZXRCb29sZWFucyA9IGZ1bmN0aW9uIGdldEJvb2xlYW5zKHJlZmVyZW5jZXMpIHtcbiAgICB2YXIgcXVlcnlCdWZmZXIgPSB0aGlzLmNyZWF0ZUFuZEZpbGxCdWZmZXIobmV3IEludDMyQXJyYXkocmVmZXJlbmNlcykpO1xuICAgIHZhciBxdWVyeSA9IHRoaXMudmlld0J1ZmZlcihxdWVyeUJ1ZmZlcik7XG4gICAgdmFyIG91dHB1dEJ1ZmZlciA9IHRoaXMuY3JlYXRlQnVmZmVyKG5ldyBJbnQzMkFycmF5KHJlZmVyZW5jZXMubGVuZ3RoKSk7XG4gICAgdmFyIG91dHB1dCA9IHRoaXMudmlld0J1ZmZlcihvdXRwdXRCdWZmZXIpO1xuICAgIHRoaXMuZ2V0Qm9vbGVhbihxdWVyeSwgb3V0cHV0LCByZWZlcmVuY2VzLmxlbmd0aCk7XG4gICAgdmFyIGJvb2wgPSBuZXcgSW50MzJBcnJheShvdXRwdXQuYnVmZmVyLCBvdXRwdXQuYnl0ZU9mZnNldCwgcmVmZXJlbmNlcy5sZW5ndGgpO1xuICAgIHRoaXMuZnJlZUJ1ZmZlcihxdWVyeUJ1ZmZlcik7XG4gICAgdGhpcy5mcmVlQnVmZmVyKG91dHB1dEJ1ZmZlcik7XG4gICAgcmV0dXJuIGJvb2w7XG4gIH07XG5cbiAgX3Byb3RvLnNlY29uZHNUb1RpbWUgPSBmdW5jdGlvbiBzZWNvbmRzVG9UaW1lKHNlYywgbXVsdGlwbHkpIHtcbiAgICBpZiAobXVsdGlwbHkgPT09IHZvaWQgMCkge1xuICAgICAgbXVsdGlwbHkgPSAxO1xuICAgIH1cblxuICAgIHZhciB4ID0gTWF0aC5mbG9vcihzZWMgKiBtdWx0aXBseSk7XG4gICAgdmFyIHNlY29uZHMgPSBNYXRoLmZsb29yKHggJSA2MCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgIHggLz0gNjA7XG4gICAgdmFyIG1pbnV0ZXMgPSBNYXRoLmZsb29yKHggJSA2MCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgIHggLz0gNjA7XG4gICAgdmFyIGhvdXJzID0gTWF0aC5mbG9vcih4ICUgMjQpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICB4IC89IDI0O1xuICAgIHZhciBkYXlzID0gTWF0aC5mbG9vcih4KTtcbiAgICByZXR1cm4gJyAnICsgZGF5cyArICcgJyArIGhvdXJzICsgJzonICsgbWludXRlcyArICc6JyArIHNlY29uZHM7XG4gIH07XG5cbiAgX3Byb3RvLnBlcmZzdGFydCA9IGZ1bmN0aW9uIHBlcmZzdGFydCgpIHtcbiAgICB0aGlzLnBlcmZzdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICB9O1xuXG4gIC8vb3V0cHV0cyBob3cgbWFueSBzIHRoZSBzaW11bGF0aW9uIHdhcyBwZXJmb3JtZWQgLSBhdCB0aGUgZW5kIG9mIHNpbXVsYXRpb24sIGdvb2QgdG8gbWVhc3VyZSBwZXJmb3JtYW5jZVxuICBfcHJvdG8ucGVyZmVuZCA9IGZ1bmN0aW9uIHBlcmZlbmQoKSB7XG4gICAgdGhpcy5wZXJmZW5kVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgdmFyIHRpbWVEaWZmID0gdGhpcy5wZXJmZW5kVGltZSAtIHRoaXMucGVyZnN0YXJ0VGltZTsgLy9pbiBtc1xuICAgIC8vIHN0cmlwIHRoZSBtc1xuXG4gICAgdGltZURpZmYgLz0gMTAwMDsgLy8gZ2V0IHNlY29uZHNcblxuICAgIGNvbnNvbGUud2FybihcIlNpbXVsYXRpb24gdG9vayBcIiArIHRpbWVEaWZmICsgXCIgc2Vjb25kc1wiKTtcbiAgfTtcblxuICBfcHJvdG8uZm11c3BlZWRDaGFuZ2VkID0gZnVuY3Rpb24gZm11c3BlZWRDaGFuZ2VkKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5zdGVwU2l6ZSA9IHRoaXMuZm11c3BlZWQgKiAodHlwZW9mIHRoaXMuZnN0ZXBzaXplID09PSAnc3RyaW5nJyA/IHBhcnNlRmxvYXQodGhpcy5mc3RlcHNpemUpIDogdGhpcy5mc3RlcHNpemUpO1xuICB9O1xuXG4gIHJldHVybiBGbWk7XG59KCksIChfZGVzY3JpcHRvciA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJmbWluYW1lXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uIGluaXRpYWxpemVyKCkge1xuICAgIHJldHVybiAnTi9BJztcbiAgfVxufSksIF9kZXNjcmlwdG9yMiA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJ0b2xlcmFuY2VcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gaW5pdGlhbGl6ZXIoKSB7XG4gICAgcmV0dXJuIDAuMDAwMDAxO1xuICB9XG59KSwgX2Rlc2NyaXB0b3IzID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcInN0YXJ0dGltZVwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiBpbml0aWFsaXplcigpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufSksIF9kZXNjcmlwdG9yNCA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJzdG9wdGltZVwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiBpbml0aWFsaXplcigpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufSksIF9kZXNjcmlwdG9yNSA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJndWlkXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uIGluaXRpYWxpemVyKCkge1xuICAgIHJldHVybiAnTi9BJztcbiAgfVxufSksIF9kZXNjcmlwdG9yNiA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJpZFwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I3ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImlucHV0c1wiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBudWxsXG59KSwgX2Rlc2NyaXB0b3I4ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcIm90aGVyaW5wdXRzXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjkgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwidmFsdWVyZWZlcmVuY2VzXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IG51bGxcbn0pLCBfZGVzY3JpcHRvcjEwID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcInRpY2tzVG9VcGRhdGVcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gaW5pdGlhbGl6ZXIoKSB7XG4gICAgcmV0dXJuIDMwO1xuICB9XG59KSwgX2Rlc2NyaXB0b3IxMSA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJzcmNcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMTIgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiZnN0ZXBzaXplXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uIGluaXRpYWxpemVyKCkge1xuICAgIHJldHVybiAwLjAxO1xuICB9XG59KSwgX2Rlc2NyaXB0b3IxMyA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJjb250cm9saWRcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogbnVsbFxufSksIF9kZXNjcmlwdG9yMTQgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwic2hvd2NvbnRyb2xzXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uIGluaXRpYWxpemVyKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59KSwgX2Rlc2NyaXB0b3IxNSA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJmcHNsaW1pdFwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiBpbml0aWFsaXplcigpIHtcbiAgICByZXR1cm4gNjA7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjE2ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcInNob3d0aW1lXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uIGluaXRpYWxpemVyKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSksIF9kZXNjcmlwdG9yMTcgPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwic2hvd3RpbWVtdWx0aXBseVwiLCBbX2F1cmVsaWFGcmFtZXdvcmsuYmluZGFibGVdLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGluaXRpYWxpemVyOiBmdW5jdGlvbiBpbml0aWFsaXplcigpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxufSksIF9kZXNjcmlwdG9yMTggPSBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiZXZlbnRsaXN0ZW5cIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gaW5pdGlhbGl6ZXIoKSB7XG4gICAgcmV0dXJuICdpbnB1dCc7XG4gIH1cbn0pLCBfZGVzY3JpcHRvcjE5ID0gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcIm1vZGVcIiwgW19hdXJlbGlhRnJhbWV3b3JrLmJpbmRhYmxlXSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBpbml0aWFsaXplcjogZnVuY3Rpb24gaW5pdGlhbGl6ZXIoKSB7XG4gICAgcmV0dXJuIFwiY29udGludW91c1wiO1xuICB9XG59KSwgX2Rlc2NyaXB0b3IyMCA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJzdGVwc3BlcmZyYW1lXCIsIFtfYXVyZWxpYUZyYW1ld29yay5iaW5kYWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uIGluaXRpYWxpemVyKCkge1xuICAgIHJldHVybiAxO1xuICB9XG59KSwgX2Rlc2NyaXB0b3IyMSA9IF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJmbXVzcGVlZFwiLCBbX2F1cmVsaWFGcmFtZXdvcmsub2JzZXJ2YWJsZV0sIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uIGluaXRpYWxpemVyKCkge1xuICAgIHJldHVybiAxO1xuICB9XG59KSksIF9jbGFzcyk7XG5leHBvcnRzLkZtaSA9IEZtaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZtaS5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/fmi\n");

/***/ }),

/***/ "aurelia-bodylight-plugin/elements/fmi.html":
/*!*************************************************************************************!*\
  !*** ./node_modules/aurelia-bodylight-plugin/dist/native-modules/elements/fmi.html ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = \"<template>\\n  <require from=\\\"./w3.css\\\"></require>\\n  <!--require from=\\\"font-awesome/css/font-awesome.min.css\\\"></require>\\n  <require from=\\\"font-awesome/fonts/fontawesome-webfont.woff\\\"></require>\\n  <require from=\\\"font-awesome/fonts/fontawesome-webfont.ttf\\\"></require>\\n  <require from=\\\"font-awesome/fonts/fontawesome-webfont.woff2\\\"></require-->\\n  <div show.bind=\\\"showcontrols\\\">\\n    <table>\\n      <tr>\\n        <td>\\n          <button class=\\\"w3-button w3-theme\\\" click.delegate=\\\"startstop()\\\" title=\\\"Start/Stop simulation\\\"><i class.bind=\\\"animationstarted? 'fa fa-stop':'fa fa-play'\\\"></i> &nbsp;</button>\\n        </td>\\n        <td>\\n          <button class=\\\"w3-button w3-theme\\\" click.delegate=\\\"step()\\\" title=\\\"Do simulation step\\\"><i class=\\\"fa fa-step-forward\\\"> <sub><b>1</b></sub></i> &nbsp;</button>\\n        </td>\\n        <td>\\n          <button class=\\\"w3-button w3-theme\\\" click.delegate=\\\"reset()\\\" title=\\\"Reset simulation\\\"><i class=\\\"fa fa-refresh\\\"></i> &nbsp;</button>\\n        </td>\\n        <td class=\\\"w3-tiny\\\">\\n          <table>\\n            <tr><td><input type=\\\"checkbox\\\" checked.bind=\\\"measurefps\\\"/>\\n              <i show.bind=\\\"measurefps\\\" title=\\\"FMI: ${fminame}\\\">FPS:${fps}</i></td>\\n              <td show.bind=\\\"measurefps\\\">\\n                <label><input type=\\\"radio\\\" name=\\\"fmuspeed\\\" checked.bind=\\\"fmuspeed\\\" model.bind=\\\"0.1\\\"/>0.1 x</label>\\n                <label><input type=\\\"radio\\\" name=\\\"fmuspeed\\\" checked.bind=\\\"fmuspeed\\\" model.bind=\\\"1\\\"/>1.0 x</label>\\n              </td>\\n            </tr>\\n            <tr><td show.bind=\\\"measurefps\\\"><input type=\\\"number\\\" min=\\\"1\\\" max=\\\"60\\\" value.bind=\\\"fpslimit\\\" style=\\\"width:8ch\\\" /></td>\\n              <td show.bind=\\\"measurefps\\\">\\n                <label><input type=\\\"radio\\\" name=\\\"fmuspeed\\\" checked.bind=\\\"fmuspeed\\\" model.bind=\\\"10\\\"/>10 x</label>\\n                <label><input type=\\\"radio\\\" name=\\\"fmuspeed\\\" checked.bind=\\\"fmuspeed\\\" model.bind=\\\"100\\\"/>100 x</label>\\n              </td>\\n            </tr>\\n          </table>\\n        </td>\\n        <td show.bind=\\\"showtime\\\">\\n          <table style=\\\"font-family:Consolas,'courier new';line-height: 1.0;\\\" title=\\\"simulation time\\\">\\n            <tr><td><span>d hh:mm:ss</span></td></tr>\\n            <tr><td><span>${simulationtime}</span></td></tr>\\n          </table>\\n        </td>\\n      </tr>\\n    </table>\\n  </div>\\n</template>\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1ib2R5bGlnaHQtcGx1Z2luL2VsZW1lbnRzL2ZtaS5odG1sLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F1cmVsaWEtYm9keWxpZ2h0LXBsdWdpbi9kaXN0L25hdGl2ZS1tb2R1bGVzL2VsZW1lbnRzL2ZtaS5odG1sPzFjYWYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIjx0ZW1wbGF0ZT5cXG4gIDxyZXF1aXJlIGZyb209XFxcIi4vdzMuY3NzXFxcIj48L3JlcXVpcmU+XFxuICA8IS0tcmVxdWlyZSBmcm9tPVxcXCJmb250LWF3ZXNvbWUvY3NzL2ZvbnQtYXdlc29tZS5taW4uY3NzXFxcIj48L3JlcXVpcmU+XFxuICA8cmVxdWlyZSBmcm9tPVxcXCJmb250LWF3ZXNvbWUvZm9udHMvZm9udGF3ZXNvbWUtd2ViZm9udC53b2ZmXFxcIj48L3JlcXVpcmU+XFxuICA8cmVxdWlyZSBmcm9tPVxcXCJmb250LWF3ZXNvbWUvZm9udHMvZm9udGF3ZXNvbWUtd2ViZm9udC50dGZcXFwiPjwvcmVxdWlyZT5cXG4gIDxyZXF1aXJlIGZyb209XFxcImZvbnQtYXdlc29tZS9mb250cy9mb250YXdlc29tZS13ZWJmb250LndvZmYyXFxcIj48L3JlcXVpcmUtLT5cXG4gIDxkaXYgc2hvdy5iaW5kPVxcXCJzaG93Y29udHJvbHNcXFwiPlxcbiAgICA8dGFibGU+XFxuICAgICAgPHRyPlxcbiAgICAgICAgPHRkPlxcbiAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJ3My1idXR0b24gdzMtdGhlbWVcXFwiIGNsaWNrLmRlbGVnYXRlPVxcXCJzdGFydHN0b3AoKVxcXCIgdGl0bGU9XFxcIlN0YXJ0L1N0b3Agc2ltdWxhdGlvblxcXCI+PGkgY2xhc3MuYmluZD1cXFwiYW5pbWF0aW9uc3RhcnRlZD8gJ2ZhIGZhLXN0b3AnOidmYSBmYS1wbGF5J1xcXCI+PC9pPiAmbmJzcDs8L2J1dHRvbj5cXG4gICAgICAgIDwvdGQ+XFxuICAgICAgICA8dGQ+XFxuICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcInczLWJ1dHRvbiB3My10aGVtZVxcXCIgY2xpY2suZGVsZWdhdGU9XFxcInN0ZXAoKVxcXCIgdGl0bGU9XFxcIkRvIHNpbXVsYXRpb24gc3RlcFxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXN0ZXAtZm9yd2FyZFxcXCI+IDxzdWI+PGI+MTwvYj48L3N1Yj48L2k+ICZuYnNwOzwvYnV0dG9uPlxcbiAgICAgICAgPC90ZD5cXG4gICAgICAgIDx0ZD5cXG4gICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwidzMtYnV0dG9uIHczLXRoZW1lXFxcIiBjbGljay5kZWxlZ2F0ZT1cXFwicmVzZXQoKVxcXCIgdGl0bGU9XFxcIlJlc2V0IHNpbXVsYXRpb25cXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1yZWZyZXNoXFxcIj48L2k+ICZuYnNwOzwvYnV0dG9uPlxcbiAgICAgICAgPC90ZD5cXG4gICAgICAgIDx0ZCBjbGFzcz1cXFwidzMtdGlueVxcXCI+XFxuICAgICAgICAgIDx0YWJsZT5cXG4gICAgICAgICAgICA8dHI+PHRkPjxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCIgY2hlY2tlZC5iaW5kPVxcXCJtZWFzdXJlZnBzXFxcIi8+XFxuICAgICAgICAgICAgICA8aSBzaG93LmJpbmQ9XFxcIm1lYXN1cmVmcHNcXFwiIHRpdGxlPVxcXCJGTUk6ICR7Zm1pbmFtZX1cXFwiPkZQUzoke2Zwc308L2k+PC90ZD5cXG4gICAgICAgICAgICAgIDx0ZCBzaG93LmJpbmQ9XFxcIm1lYXN1cmVmcHNcXFwiPlxcbiAgICAgICAgICAgICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XFxcInJhZGlvXFxcIiBuYW1lPVxcXCJmbXVzcGVlZFxcXCIgY2hlY2tlZC5iaW5kPVxcXCJmbXVzcGVlZFxcXCIgbW9kZWwuYmluZD1cXFwiMC4xXFxcIi8+MC4xIHg8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XFxcInJhZGlvXFxcIiBuYW1lPVxcXCJmbXVzcGVlZFxcXCIgY2hlY2tlZC5iaW5kPVxcXCJmbXVzcGVlZFxcXCIgbW9kZWwuYmluZD1cXFwiMVxcXCIvPjEuMCB4PC9sYWJlbD5cXG4gICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICA8dHI+PHRkIHNob3cuYmluZD1cXFwibWVhc3VyZWZwc1xcXCI+PGlucHV0IHR5cGU9XFxcIm51bWJlclxcXCIgbWluPVxcXCIxXFxcIiBtYXg9XFxcIjYwXFxcIiB2YWx1ZS5iaW5kPVxcXCJmcHNsaW1pdFxcXCIgc3R5bGU9XFxcIndpZHRoOjhjaFxcXCIgLz48L3RkPlxcbiAgICAgICAgICAgICAgPHRkIHNob3cuYmluZD1cXFwibWVhc3VyZWZwc1xcXCI+XFxuICAgICAgICAgICAgICAgIDxsYWJlbD48aW5wdXQgdHlwZT1cXFwicmFkaW9cXFwiIG5hbWU9XFxcImZtdXNwZWVkXFxcIiBjaGVja2VkLmJpbmQ9XFxcImZtdXNwZWVkXFxcIiBtb2RlbC5iaW5kPVxcXCIxMFxcXCIvPjEwIHg8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XFxcInJhZGlvXFxcIiBuYW1lPVxcXCJmbXVzcGVlZFxcXCIgY2hlY2tlZC5iaW5kPVxcXCJmbXVzcGVlZFxcXCIgbW9kZWwuYmluZD1cXFwiMTAwXFxcIi8+MTAwIHg8L2xhYmVsPlxcbiAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgPC90ZD5cXG4gICAgICAgIDx0ZCBzaG93LmJpbmQ9XFxcInNob3d0aW1lXFxcIj5cXG4gICAgICAgICAgPHRhYmxlIHN0eWxlPVxcXCJmb250LWZhbWlseTpDb25zb2xhcywnY291cmllciBuZXcnO2xpbmUtaGVpZ2h0OiAxLjA7XFxcIiB0aXRsZT1cXFwic2ltdWxhdGlvbiB0aW1lXFxcIj5cXG4gICAgICAgICAgICA8dHI+PHRkPjxzcGFuPmQgaGg6bW06c3M8L3NwYW4+PC90ZD48L3RyPlxcbiAgICAgICAgICAgIDx0cj48dGQ+PHNwYW4+JHtzaW11bGF0aW9udGltZX08L3NwYW4+PC90ZD48L3RyPlxcbiAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgPC90ZD5cXG4gICAgICA8L3RyPlxcbiAgICA8L3RhYmxlPlxcbiAgPC9kaXY+XFxuPC90ZW1wbGF0ZT5cXG5cIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///aurelia-bodylight-plugin/elements/fmi.html\n");

/***/ })

}]);